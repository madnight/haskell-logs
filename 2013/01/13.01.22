00:00:14 <shachaf> srhb: #haskell people in the US tend to live by European time zones, as far as I can tell.
00:00:23 <srhb> Oh. :P
00:00:31 <shachaf> @localtime srhb
00:00:31 <lambdabot> Local time for srhb is Tue Jan 22 09:00:16 2013
00:01:06 <shachaf> srhb: Anyway, the answer is clearly to move to the US.
00:01:11 <johnw> 2am for me here
00:01:14 <srhb> No thanks!
00:01:17 <zett_zelett> Why is that?
00:04:09 <otters> @localtime othiym23
00:04:09 <lambdabot> Local time for othiym23 is Tue Jan 22 00:03:54 2013
00:04:12 <otters> @localtime otters
00:04:15 <lambdabot> Local time for otters is Tue, 22 Jan 2013 03:03:57 -0500
00:04:20 <otters> huh, crazy
00:04:40 <srhb> It even obeys locale formatting? :P
00:06:06 <shachaf> srhb: Did you hear lens 3.8 is out?
00:06:14 <shachaf> Speaking of waking up.
00:12:16 <startling> what's the way to use 'zoom'?
00:17:26 <johnw> startling: http://localhost:8687/file//Users/johnw/.cabal/share/doc/lens-3.8.0.2/html/Control-Lens-Zoom.html#v:zoom
00:17:28 <johnw> has a few examples
00:17:31 <johnw> grr
00:17:43 <johnw> i keep forgetting I can't paste links from my own Hoogle
00:18:38 <hpaste> edwardk pasted “parallel traversal” at http://hpaste.org/81110
00:19:25 <edwardk> shachaf: that much at least shows that if you can use it at small scale it can gain _some_ speed.
00:19:36 <edwardk> it might be better with longer running leaf tasks
00:20:15 <edwardk> making the leaf tasks bigger brings it closer
00:21:08 <edwardk> the fact that i'm never getting ahead seems to indicate i'm doing something wrong
00:21:22 <johnw> never getting ahead of what?
00:21:35 <edwardk> of the naive traversal
00:22:04 <edwardk> trying to find a combinator for doing parallel traversals over part of the traversal chain
00:22:56 <edwardk> so you'd say something like sumOf (parallel traverse . traverse)      and it'd do that first traversal in parallel. sequencing the subsequnt traversals and taking the total before moving up
00:26:57 <edwardk> it'd just be nice to have for sparking down to a grainsize and then running
00:27:21 <shachaf> Well, those tasks are tiny, so I'm not too surprised.
00:27:50 <shachaf> Why is "sum" faster than the unparallel fold version?
00:28:01 <edwardk> adding decimal places
00:28:17 <Estrellas> is there a way to make the scope of an clause above a where clause extend into the where clause
00:28:53 <edwardk> dunno
00:29:02 <edwardk> that why i'm playing with it as a benchmark
00:29:05 <Estrellas> ie f = let { x = 4} in y where y = x
00:29:15 <shachaf> edwardk: I get better results when I use yumOf l = getSum . foldMapOf l Sum
00:29:20 <shachaf> (As opposed to ala.)
00:29:48 <shachaf> After increasing the task size, anyway.
00:30:03 <shachaf> But then "parallel" makes it even worse.
00:30:44 <shachaf> Estrellas: The "where" is associated with the binding, i.e. with the "=" here.
00:30:58 <Estrellas> oh I guess I should just use a let
00:31:15 <shachaf> Yep.
00:31:23 <shachaf> let is much more fundamental than where.
00:31:26 <shachaf> It can be used anywhere.
00:31:36 <Estrellas> yeah I just read the relevant wiki article
00:31:39 <Estrellas> thanks anyway!
00:32:15 <shachaf> Hmm, now I'm getting different results.
00:32:16 * shachaf sighs.
00:32:40 <shachaf> Benchmarking is, like, hard, man.
00:36:50 <shachaf> OK, this is too unpredictable to do anything useful with.
00:37:00 <shachaf> I run the same benchmark twice and I get two different winners.
00:37:11 <shachaf> So apparently I'm missing something. :-)
00:38:04 <shachaf> Oh, wait.
00:38:15 <shachaf> OK, I had other processes running taking 100% CPU.
00:38:21 <shachaf> So everything I said until now is useless.
00:40:15 <nyc> Statistical methods should be used for comparison anyway, but there's more surrounding the nature of the benchmark, too.
00:49:11 <simpson> Hackage is down?
00:49:17 <shachaf> @where hackage-mirror
00:49:17 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
00:49:26 <simpson> Mm.
00:51:34 <hpaste> fragamus pasted “golf invitational” at http://hpaste.org/81111
00:52:22 <alpounet> nyc, that's what criterion does
00:52:23 <shachaf> I think (& f) === f
00:53:08 <nyc> Thermal shutdown issues prevent browsing while big compiles are ongoing.
00:53:46 <spacekitteh> hello friends!
00:53:51 <spacekitteh> i have a question.
00:53:58 <simpson> Excellent.
00:54:15 <spacekitteh> how can i plot a bunch of Doubles without generating a shitton of strings and sending those strings to a .csv file and then setting gnuplot upon it?
00:54:29 * spacekitteh glares at the gnuplot package
00:55:05 <fragamus> nyc: my buddy wrote a cpu throttling script that adjusts cpu speed according to temperature.  It runs on his linux laptop
00:55:09 <spacekitteh> plotting 150k Double's requires about 1gb of ram.
00:55:46 <spacekitteh> and the vast majority of that is strings
00:56:03 <spacekitteh> ByteSTrings to be specific
00:56:11 <shachaf> ByteStrings aren't strings.
00:56:16 <spacekitteh> oh.
00:56:19 <spacekitteh> i guess not :v
00:56:19 <shachaf> (What an unfortunate name!)
00:56:52 <shachaf> Anyway, why do you need to keep it all in RAM at once?
00:57:01 <spacekitteh> the 150K doubles?
00:57:09 <spacekitteh> it's an ODE solver
00:57:31 <shachaf> The bytestrings.
00:57:45 <spacekitteh> oh, i don't know, i didn't write the gnuplot library on hackage
00:57:57 <spacekitteh> all i'm doing is passing a [Double]
00:58:13 <m3ga> it makes me sad when hackage is down. i have a ghc bug to report.
00:58:33 <shachaf> BUG: Hackage is down
00:58:38 <m3ga> spacekitteh: ouch thats a linked list of Double. if your list has 150k elements thats going to be sloooowwwwww
00:58:49 <m3ga> shachaf: :-)
00:58:57 <shachaf> m3ga: Depends on what you're doing with it.
00:59:02 <shachaf> But sure, in general.
00:59:03 <spacekitteh> m3ga: it takes about 5 seconds to generate the whole list
00:59:09 <spacekitteh> it takes about 50 seconds to plot it
00:59:14 <shachaf> > last [1..150000]
00:59:16 <lambdabot>   150000
01:04:11 <spacekitteh> shachaf, m3ga: http://bpaste.net/show/72014 the cost center "errythingButPlottingTheFuckingThing" takes about 10% of the total runtime
01:04:23 <spacekitteh> for n > 50k
01:05:33 <shachaf> I don't know anything about the library gnuplot.
01:05:47 <shachaf> You say it's an issue with the library. So what can I tell you?
01:06:00 * spacekitteh shrugs
01:06:11 <spacekitteh> an alternative to []?
01:06:11 <shachaf> (Other than WRITE TYPE SIGNATURES IN YOUR CODE! If you're going to be pasting it, anyway.)
01:06:30 <shachaf> I thought it was the library that accepted []
01:06:36 <shachaf> What format does the library accept?
01:06:58 <spacekitteh> [], but m3ga said [18:58:23] <m3ga> spacekitteh: ouch thats a linked list of Double. if your list has 150k elements thats going to be sloooowwwwww
01:07:16 <spacekitteh> this is my first ever haskell program, so yeah. learning :V
01:07:35 <frerich> Hm, hackage down?
01:07:56 <shachaf> @where hackage-mirror
01:07:56 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
01:08:16 <frerich> Thanks
01:08:25 <m3ga> hackage mirror doesn't have a ghc bug tracker :-(
01:08:30 <shachaf> spacekitteh: If the library wants to use [] and you want to use the library, you want to use [].
01:08:33 <shachaf> (Transitivity!)
01:08:42 <spacekitteh> shachaf: yeah, got that :P
01:10:00 <shachaf> Anyway, I can't run this program on my own computer, and I don't know the library you're using, so I'm not sure how I can help. :-)
01:10:33 <shachaf> If you paste a whole program that people can run, maybe someone would want to take a look at it.
01:11:44 <frerich> Does anybody know a good package for handling (i.e. constructing and working on) directed *cyclic* graphs?
01:13:48 <otters> crap
01:13:51 <frerich> I'd like to try making my web crawler use less of an imperative style by modelling a page hierarchy as a cyclic graph and then offering all kinds of functions on that.
01:13:56 <otters> somehow I have to remind myself to upload kevin-0.3.tar.gz tomorrow
01:14:49 <shachaf> @tell otters upload kevin-0.3.tar.gz
01:14:49 <lambdabot> Consider it noted.
01:15:00 <otters> thanks schlumpi
01:15:00 <lambdabot> otters: You have 1 new message. '/msg lambdabot @messages' to read it.
01:15:03 <otters> shachaf:
01:15:05 <otters> thanks
01:15:14 <shachaf> @tell otters read your messages
01:15:14 <lambdabot> Consider it noted.
01:15:17 <otters> I keep thinking your name begins with sch, but it doesn't, so that's what happened
01:15:17 <lambdabot> otters: You have 2 new messages. '/msg lambdabot @messages' to read them.
01:15:30 <shachaf> @tell otters please disregard previous message
01:15:30 <lambdabot> Consider it noted.
01:15:37 <mysticc> I have a function of type myfun :: A a => a -> ExpQ, Now I have instances of A for Int and [Int]. Now the following use gives me ambiguous type variable error [| $(myfun 1) |] whereas provinding explicit type $(myfun (1 :: Int)) works. Is there any way to force numbers passed to be of Int or anyother way to make it work without giving explicit types. What I am doing now is defined a new function myfun' :: Int -> ExpQ ; myfun' = myfun and using this.
01:15:38 <frerich> :-)
01:16:03 <shachaf> mysticc: default Int, perhaps?
01:16:11 <shachaf> Or maybe not.
01:16:18 <mysticc> shachaf: nopes
01:16:24 <mysticc> I doesn't help
01:16:27 <mysticc> *IT
01:16:38 <shachaf> OK, what's going on here?
01:16:45 <shachaf> I'm running the exact same benchmark twice, in criterion.
01:16:57 <shachaf> Each time it's telling me the stddev is <2 ms
01:17:08 <shachaf> But the means are 20ms apart.
01:18:50 <augur_> hm
01:18:53 <shachaf> I think the issue here is that summing is too fast to be meaningful to measure.
01:19:16 <augur_> so it seems that dividing a deck of cards evenly in half and then perfectly interleaving them will not randomize the cards
01:19:30 <shachaf> Anyway, I don't know.
01:19:34 <shachaf> I'll leave this for another time.
01:19:43 <augur_> in fact, it will cycle after 8 shuffles
01:20:36 <augur_> at least if you bias so that the first card remains first
01:20:49 <augur_> if you bias so the second card becomes first, you get 52 shuffles
01:21:24 <augur_> second bias seems to take as many shuffles as cards
01:21:48 <augur_> oh no, its not quite that. interesting
01:23:02 <augur_> aha, theres an oeis sequence for the second bias case :)
01:25:10 <augur_> i guess that means card shuffles depend crucially on uneven splits and uneven riffles
01:26:19 <benley> hey, anyone know what the story is with hackage being unreachable?
01:27:21 <shachaf> @where hackage-mirror
01:27:21 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
01:27:24 <t7> benley, galois dropping the ball
01:27:34 <t7> letting the team down
01:28:07 <shachaf> Man, those Galwegians!
01:28:12 <shachaf> They just hate Haskell.
01:28:27 <t7> they had 1 job... beside their actual jobs
01:28:31 <augur_> hand shuffling must be slightly better in that you often strip the cards
01:28:51 <frerich> I think shachaf is actually an alias for a group of people in different timezones, and whoever is awake has to hang out in #haskell (and one of them likes a lot of things because they are so easy).
01:29:49 <shachaf> I can neither confirm nor deny these allegations.
01:32:10 <b__thesunalso> which one of you can't?
01:38:32 <wuttf> Hackage down?
01:39:29 <srhb> Looks like it.
01:41:35 <SoleSoul> Hi. I'm struggling to do something very simple. I want to read a number from the user multiple times, until a condition is met. Each time the prompt changes according to the previous input. Usually I would do it with while-if-else but in Haskell I'm a bit lost. Can anyone show me the right direction?
01:42:44 <shachaf> Maybe something like foo prompt = do { putStr prompt; s <- getLine; if condition s then ... else foo s } ?
01:42:59 <shachaf> Or foo (makepromptfrom s)
01:43:36 <shachaf> Or are you making a "guess the number" game or something?
01:43:45 <SoleSoul> I am :)
01:43:48 <SoleSoul> the computer guesses
01:44:25 <SoleSoul> I taught my uncle python using this example and then I asked myself, do I know how to do it in Haskell, and it seems like I don't know :/
01:44:37 <shachaf> In that case your responses would be something like yes/no or high/low, wouldn't they?
01:44:43 <SoleSoul> true
01:45:20 <shachaf> Anyway, a recursive thing would be the "obvious" way to do it.
01:45:33 <SoleSoul> I'm still thinking with "while". It takes time to get used to functional thinking
01:45:42 <SoleSoul> so you say a recursive IO function?
01:46:03 <shachaf> That's one way!
01:46:06 <SoleSoul> what would be the type of such recursive IO function?
01:46:18 <shachaf> I don't know.
01:46:23 <shachaf> something -> IO somethingelse?
01:46:38 <wuttf> Where can I find the sources of cabal installed libs on win?
01:46:53 <SoleSoul> can I do IO in any function other than main?
01:47:04 <shachaf> wuttf: On UNIX it would probably ~/.cabal/packages/
01:47:09 <shachaf> So wherever the Windows equivalent is.
01:47:21 <shachaf> SoleSoul: I have the feeling you should read about how I/O works in Haskell. :-)
01:47:31 <SoleSoul> I have, multiple times
01:48:06 <frerich> SoleSoul: You could have a function which plays a single round like 'guess :: Int -> String -> IO ()'. The first argument is the secret number, the second argument is the promtp to show. You initially call this like 'guess 4711 "Guess what my number is?"'. The function would print the prompt, then read an number, and then depending on whether the number is lower/greater than it calls itself again with a different
01:48:06 <frerich>  prompt. If the number is fine, the function does not recurse.
01:48:20 <SoleSoul> and it says something like, IO actions are being run only if they are bound to variables in main
01:48:27 <shachaf> frerich: The computer is the one doing the guessing.
01:48:43 <shachaf> SoleSoul: Saying "only main can do IO in Haskell" is like saying "only main() can do I/O in C".
01:49:49 <shachaf> In one sense, nothing can do I/O on its own, because it has to be running before it can do anything.
01:49:54 <shachaf> But once it runs, it can run other things.
01:49:58 <shachaf> The same is true in Haskell.
01:50:23 <frerich> SoleSoul, shachaf: If the computer is the one doing the guessing, the approach would be the same. Instead of passing the secret number, the function gets the guess. And instead of reading a number, you read a hint from the user :-)
01:50:54 <SoleSoul> frerich and shachaf: ok, thanks. now the picture is a bit clearer. I thought that IO in Haskell is isolated to main alone, now I see it is less strict than I thought
01:51:13 <shachaf> It has nothing to do with main as such.
01:51:22 <shachaf> An IO action can run other IO actions.
01:51:37 <shachaf> Just like a C procedure ("function") can run other C procedures.
01:52:08 <shachaf> In the end, just one gets run, and that one is called main in both cases.
01:52:49 <SoleSoul> This is a quote from lyah IO chapter: "So, when will an I/O action be performed? Well, this is where main comes in. An I/O action will be performed when we give it a name of main and then run our program."
01:53:05 <shachaf> Well, that's LYAH for you.
01:53:10 <shachaf> Not that it's wrong.
01:53:23 <shachaf> If main = do { a; b; c }, then running main will run a, then b, then c.
01:53:33 <shachaf> Just like int main() { a(); b(); c(); }
01:53:48 <SoleSoul> another quote: "I/O actions will only be performed when they are given a name of main or when they're inside a bigger I/O action that we composed with a do block."
01:53:53 <Maxdamantus> But what runs them?
01:54:02 <frerich> Maxdamantus: The run-time system
01:54:10 <Maxdamantus> Indeed, not "main"
01:54:21 <shachaf> Maxdamantus: Hmm?
01:54:29 <shachaf> The RTS is not mentioned anywhere in the Haskell Report.
01:55:03 <srhb> SoleSoul: If a name of a function is never used if you traverse all functions called from main, that function is superfluous. Just another way of putting it.
01:55:05 <shachaf> I am fine with saying that in main = do { a; b }, main is running a.
01:55:24 * shachaf thinks people put too much voodoo on the way I/O works in Haskell.
01:55:27 <srhb> Where called from is perhaps a bit crappy terminology.
01:55:28 <shachaf> It's no different from C.
01:55:30 <srhb> shachaf: Right.
01:55:55 <shachaf> Well, OK, difference: Haskell has things which can't do I/O themselves, called "functions".
01:56:02 <SoleSoul> So why lyah says that? "We can also use a do block to glue together a few I/O actions and then we can use that I/O action in another do block and so on. Either way, they'll be performed only if they eventually fall into main."
01:56:02 <srhb> Instead of all the blahblah the books should just say "when you run your program, main is executed"
01:56:12 <srhb> SoleSoul: Because it's true
01:56:13 <SoleSoul> if it's no different than C?
01:56:19 <shachaf> For example, a function (+) such that you can't say "x + y = do { print blah; return ... }"
01:56:20 <srhb> SoleSoul: It's also trivial.
01:56:29 <shachaf> I don't know why LYAH says the things it does.
01:56:44 <srhb> SoleSoul: Consider a function in c that is never called from main, or from a function called from main. It is never run.
01:56:46 <shachaf> There is always:
01:56:51 <shachaf> @google introduction to io in haskell
01:56:53 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
01:56:53 <lambdabot> Title: Introduction to IO - HaskellWiki
01:57:02 <srhb> SoleSoul: I think you're mentally making this a bigger deal than it is. :P
01:57:13 <Maxdamantus> > let a + b = do { a; b } in putChar 'a' + putChar 'b'
01:57:14 <SoleSoul> I thought it's something special because lyah talks about it in length
01:57:14 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
01:57:14 <lambdabot>    arising from a use of ...
01:57:20 <shachaf> Thanks, Maxdamantus.
01:57:23 <srhb> SoleSoul: It is not. LYAH is doing it wrong.
01:57:35 <Maxdamantus> > let a + b = do { a; b } in Just 4 + Just 5
01:57:37 <lambdabot>   Just 5
01:57:45 <shachaf> Maxdamantus: In the future I'll have to specify that I'm keeping (+)'s type as it is. Should I also specify that I'm not allowing unsafePeformIO?
01:57:46 <srhb> SoleSoul: anyway I sent you a /msg - perhaps you can use it
01:58:13 <SoleSoul> srhb: ah, thank you :)
01:58:36 <SoleSoul> thanks all! I'll go try to write it again.
01:58:39 <shachaf> Uh oh, srhb is passing notes.
01:58:45 <srhb> <_<
01:58:57 <Athas> #!/bin/sh
01:59:04 <shachaf> hi Argue
01:59:11 <Argue> sup shach
01:59:32 <shachaf> @yarr
01:59:32 <lambdabot> Keelhaul the swabs!
02:00:23 <SoleSoul> shachaf: btw, do you live where I think you do? Do you know "sayeret lambda"?
02:03:10 <shachaf> SoleSoul: Nope, I live in the US. :-)
02:03:30 <shachaf> Some other people in this channel have gone, though, I think.
02:04:54 <SoleSoul> I discovered it not long ago. They hosted a talk about haskell and they are one of the few who are seriously talking about finctional languages here
02:06:41 * shachaf is off for a bit -- back later.
02:06:58 * SamanthaD waves at shachaf.
02:16:33 * mysticc says see yaa
02:23:32 <shachaf> hi SamanthaD
02:24:08 <SamanthaD> shachaf: how's it going?
02:24:33 <shachaf> It seems that you have the sleep schedule of a #haskeller.
02:25:12 <shachaf> We shipped lens 3.8! It's great.
02:26:36 <SamanthaD> shachaf: sunlight glares my screen...
02:27:00 <SamanthaD> shachaf: Lens a haskell library?
02:27:03 <shachaf> SamanthaD may be a vampire.
02:27:07 <shachaf> Yes, a Haskell library.
02:27:41 <fmap> the Haskell library
02:29:06 <srhb> Is there a story somewhere of why 3.8 is great?
02:29:45 <shachaf> There is https://github.com/ekmett/lens/blob/master/CHANGELOG.markdown
02:30:03 <srhb> Thanks.
02:30:37 <shachaf> Hmm, edwardk wanted me to write a post about profunctors or something, which I forgot about.
02:30:57 <SamanthaD> shachaf: a post where?
02:31:05 <shachaf> Well, there's plenty of time for that after we actually work out how they should work. :-)
02:32:02 <awgn> is someone having problem with hackage or I am the only one ?
02:32:11 <shachaf> SamanthaD: On his website, I think? Anyway, the Golden Age of Profunctors has yet to come.
02:32:14 <shachaf> awgn: Yep, it's down.
02:32:16 <srhb> awgn: It's down.
02:32:17 <shachaf> @where hackage-mirror
02:32:17 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
02:32:26 <awgn> ok thank you :-)
02:32:55 <SamanthaD> shachaf: Oh, I was wondering if you had a blog or something. You've always been rather helpful so I figured it might be something worth reading.
02:33:12 <shachaf> I have a website but I don't post very much to it.
02:33:18 <shachaf> In fact it has three pages.
02:33:53 <SamanthaD> shachaf: Oooh, fancy!
02:34:32 <shachaf> I should probably write some things in a more durable form than IRC logs, really.
02:34:44 <shachaf> Those tend to disappear and then you have to type the same thing all over again.
02:35:25 <johnw> i have it all recorded, shachaf, i just like to watch you type it all over again
02:35:39 <shachaf> I am aware.
02:35:53 <shachaf> johnw is always watching me.
02:36:16 <johnw> you said "X is/are so easy" 44 times to my knowledge
02:36:32 <shachaf> Hmm, I've said it more than that in another channel, I think.
02:36:43 <srhb> #python?
02:36:45 <srhb> :P
02:36:48 <johnw> and you've said it more here too I'm sure, I don't log when I'm not actively watching the channel
02:37:14 <srhb> In that case I expect it to be dominated by "Haskell is so easy"
02:37:15 <johnw> (that is, my IRC bouncer only keeps the most recent 5000 lines for me, so I missed anything beyond that when my client isn't running)
02:37:26 <shachaf> Maybe my strategy should be explaining things to people like johnw and SamanthaD so they can write it up instead.
02:37:36 <shachaf> And then complain because they miscommunicated my true intent!
02:37:41 <johnw> :)
02:37:50 <SamanthaD> shachaf: Once I get a bit more experienced with the language I'd *love* to document things!
02:37:54 <johnw> i was thinking last night of writing about profunctors
02:38:02 <shachaf> SamanthaD: Do you like writing benchmarks too?
02:38:04 <b_work> johnw: please do
02:38:07 <shachaf> lens could use some benchmarks.
02:38:16 <srhb> I've actually dreamed of profunctors as a consequence of the discussion on -lens
02:38:29 <srhb> I have no idea what they are, but that didn't stop my dream from being about them, somehow
02:38:34 <SamanthaD> shachaf: I've never tried... I'm thinking more along the lines of tutorials and what not
02:38:43 <`ramses> srhb: what did they look like? :)
02:38:44 <shachaf> srhb: Profunctors are so easy!
02:38:50 <shachaf> srhb: You should know what they are.
02:38:53 <srhb> shachaf: :D
02:38:57 <shachaf> srhb: Do you know what functors are?
02:38:58 <b_work> yes I dreamt once about meeting a female musician who wrote her software in attoparsec
02:39:01 <b_work> I am not to be outdone
02:39:01 <srhb> `ramses: Unfortunately it;s slipped.
02:39:04 <srhb> shachaf: Yes. :P
02:39:05 <shachaf> Er, Functors. As in the Haskell class.
02:39:11 <srhb> That, too.
02:39:12 <shachaf> OK. Do you know what contravariant functors are?
02:39:15 <shachaf> As in the class Contravariant.
02:39:45 <johnw> the function instance of Profunctor allows you to selectively map either the input or output variable of a function
02:41:00 <johnw> so, lmap (read :: Int) (+1) has type String -> Int, because I've mapped the first argument of (+1) from an Int to a String
02:41:12 <srhb> shachaf: Nope, I don't think so.
02:41:15 <johnw> > lmap (read :: Int) (+1) $ "20"
02:41:17 <lambdabot>   Not in scope: `lmap'
02:41:17 <lambdabot>  Perhaps you meant one of these:
02:41:19 <lambdabot>    `map' (imported fr...
02:41:25 <johnw> > Data.Profunctor.lmap (read :: Int) (+1) $ "20"
02:41:26 <lambdabot>   Not in scope: `Data.Profunctor.lmap'
02:41:32 * johnw shakes fist at lambdabot
02:41:40 <shachaf> srhb: OK, so the class looks like this: class Contravariant f where contramap :: (a -> b) -> f b -> f a
02:41:54 <srhb> That's weird.
02:41:57 <shachaf> If you're thinking in terms of normal functors, it looks really bizarre.
02:42:06 <johnw> and Data.Profunctor.rmap show (+1) would create a function Int -> String that increments a number and then renders it as a string
02:42:25 <SamanthaD> speaking of benchmarks... I read a comment somewhere that stated that GHC doesn't scale well above ~12 cores. I'd be interested to know if there's any truth to that statement since I see pocket supercomputers in my future.
02:42:35 <johnw> rmap is just (.), clearly
02:42:37 <shachaf> srhb: Here's an example of a contravariant type: type Predicate a = a -> Bool
02:42:47 <johnw> (for functions, that is)
02:43:00 <shachaf> SamanthaD: There are some issues with the GC beyond a certain number of cores, I understand.
02:43:07 <johnw> ooh, I love hearing shachaf explains contravariantness
02:43:10 * johnw grabs popcorn
02:43:24 <johnw> contravariety?
02:43:35 <srhb> Contravariance?
02:43:38 <johnw> doh
02:43:45 <shachaf> Higgledy piggledy / contravariety /
02:43:48 <srhb> :P
02:44:05 <srhb> Was that example type the punchline? If so, I didn't get it. :P
02:44:17 <SamanthaD> shachaf: I see. Well, I guess I'll cross that bridge when I get to it. I was just thinking that I could get a 12 core computer for under two grand and for simulations such a machine would be really swell!
02:44:18 <shachaf> Nope.
02:44:30 <shachaf> srhb: Can you write contramap for Predicate?
02:44:46 <b52> SamanthaD: also checkout Amdahl's law
02:45:05 <srhb> Hmm
02:46:58 <SamanthaD> b52: Oh, I see! That makes a lot of sense.
02:47:19 <srhb> No, I don't see it.
02:47:27 <b52> SamanthaD: thats a good read http://community.haskell.org/~simonmar/papers/par-tutorial-cefp-2012.pdf
02:47:33 <shachaf> srhb: OK, can you give its type?
02:47:50 <shachaf> (Do you understand Predicate?)
02:48:14 <srhb> (a -> b) -> Predicate b -> Predicate a ? Maybe I don't
02:48:35 <`ramses> shachaf: (is it flip (.) ?)
02:48:58 <shachaf> srhb: Well, that's the right type. Now expand it.
02:49:07 <SamanthaD> b52: So, in short what you're saying is that GHC's ability to scale w/rt number of cores has less to do with a limitation in GHC/Haskell as it does with basic fundamental principles of computing.
02:49:28 <srhb> (a -> b) -> (b -> Bool) -> (a -> Bool)
02:49:51 <neutrino> lose the last paren
02:50:06 <shachaf> Yep.
02:50:14 <shachaf> Now do you see how to write that function?
02:50:18 <shachaf> SamanthaD: No, that's not really true.
02:50:38 <b52> SamanthaD: thats a good read http://community.haskell.org/~simonmar/papers/par-tutorial-cefp-2012.pdf
02:50:40 <b_work> isn't lmap 'flip (.)'
02:50:45 <b52> ah gnah, sorry
02:50:53 <SamanthaD> b52: Thanks, I'm actually reading it now ;)
02:51:24 <shachaf> b52: Yes.
02:51:29 <b52> SamanthaD: No, but that there might be a point where throwing more cores at the problem won't help
02:51:49 <shachaf> SamanthaD: Things depend a lot on the problem that you're solving. Some are very easy to parallelize.
02:52:00 <shachaf> But with some of those, GHC's GC can get in the way, for various reasons.
02:52:04 <`ramses> cool, and the catch is probably that you can only implement contraMap when f's type argument is in a contravariant position, then?
02:52:21 <shachaf> `ramses: Yep. That's why it's called Contravariant. :-)
02:52:38 <shachaf> There is also class Invariant f where invmap :: (a -> b) -> (b -> a) -> f a -> f b
02:52:50 <shachaf> Every normal Haskell type can be made an instance of that.
02:53:01 <srhb> contramap f pb a = (pb . f) a ?
02:53:10 <shachaf> Yep!
02:53:23 <SamanthaD> b52, shachaf: thanks
02:53:23 <srhb> I see.
02:53:25 <`ramses> shachaf: every type? It has to be a type constructor, right?
02:53:30 <shachaf> Let's think about what this means (johnw knows what I'm going to say now).
02:54:04 <shachaf> srhb: If I have a machine that can classify cats, and I have a machine that can turn a dog into a cat, then I can build a machine that can classify dogs.
02:54:22 <b52> :D
02:54:23 <neutrino> b52: amdahl's law has the inherent flaw that it assumes there's one element that blocks every resource. an easy way to circumvent it is to not have such an element.
02:54:27 <srhb> Right.
02:54:37 <b52> shachaf: neat picture
02:54:39 <shachaf> So our mapping is "backwards".
02:54:45 <srhb> Yes, I see.
02:54:46 <neutrino> b52: for example, if you have 16 cores, have "sequential" elements that only block 4 cores at a time.
02:54:57 <shachaf> The reason is that x is an *input* to f x.
02:55:18 <srhb> Right. Weird!
02:55:24 <srhb> Or perhaps just unfamiliar.
02:55:32 <shachaf> In a vague, general sense, you can say that for a Functor f, "f x" "produces" xs.
02:55:55 <neutrino> doesn't Invariant => Iso?
02:56:35 <shachaf> Note that this includes [x] (which can produce multiple items), Maybe x (which can produce nothing), IO x (which can't be executed directly), (Blah -> x) (which can only produce an x if you pass in an argument), etc.
02:56:53 <shachaf> But all of these have in common the fact that they only "give you" xs.
02:56:59 <srhb> Yes, I understood the vagueness :-)
02:57:08 <shachaf> On the other hand, for Contravariant f, "f x" "consumes" xs.
02:57:47 <srhb> Hm.. Yes.
02:57:58 <shachaf> So you might have "x -> Bool" or "x -> somethingelse" or "Int" or "[x] -> x -> a" or who knows.
02:58:01 <shachaf> `ramses: What do you mean?
02:58:49 <`ramses> shachaf: you say every type can be an instance of Invariant, but Invariant takes something of kind * -> *, right?
02:59:06 <shachaf> Well, sure.
02:59:11 <shachaf> Anything that's not a kind error etc.
02:59:27 <`ramses> can every such thing be an invariant, then?
03:00:08 <shachaf> Well, not special types like IORefs.
03:00:15 <shachaf> But every type you can define in plain Haskell.
03:00:17 <`ramses> I have to go noz, I'll probably nag you about this agian later, it's very interesting!
03:00:45 <shachaf> srhb: Anyway, a Profunctor is something that takes two arguments, and is contravariant in the first, and covariant int he second.
03:00:48 <shachaf> So you have:
03:01:06 <srhb> wait wait, covariant?
03:01:14 <shachaf> Oh, that means "like a normal Functor"
03:01:18 <srhb> Aha
03:01:21 <shachaf> class Profunctor p where lmap :: (a -> a') -> p a' b -> p a b; rmap :: (b -> b') -> p a b -> p a b'
03:02:24 <shachaf> srhb: An obvious example of a profunctor is (->)
03:02:32 <srhb> Yes... Obvious.
03:02:32 <shachaf> (a -> b) "consumes" an a and "produces" a b.
03:02:33 <srhb> :P
03:02:42 <srhb> Right.
03:02:44 <shachaf> Fine, the classic example.
03:03:00 <neutrino> right now you wish for {-# LANGUAGE EinsteinNotation #-}
03:03:01 <shachaf> Some other profunctors:
03:03:04 <shachaf> p a b = b
03:03:06 <shachaf> p a b = a -> r
03:03:23 <shachaf> p a b = [a] -> [b]; p a b = [a -> b]; p a b = a -> [b]; p a b = [a] -> b
03:03:27 <shachaf> Etc.
03:04:01 <b_work> contravariance is just (a -> b) -> b -> a, and covariance (a -> b) -> a -> b right?
03:04:10 <shachaf> Well, for any functors f and g, g a -> b, a -> f b, g a -> f b, f (a -> b), etc. are all profunctors.
03:04:11 <srhb> OK, I guess for (->) the contravariant version is actually clearer.
03:04:22 <srhb> So I guess I can agree on "obvious" now that I've digested it :P
03:04:25 <shachaf> b_work: With more "f"s, yes.
03:04:34 <b_work> yes
03:04:41 <shachaf> srhb: lmap and rmap are just flip (.) and (.) for (->)
03:04:47 <srhb> Yeah.
03:05:21 <shachaf> Anyway, so that's all there is to profunctors.
03:05:25 <srhb> Thanks!
03:05:27 <shachaf> They're simpler than I made them out to be.
03:05:30 <srhb> awesome. ^^
03:05:35 <shachaf> But it's a great abstraction! We use it in lens a lot.
03:07:54 <hiptobecubic> the definition of 'covariant' in the dictionary is supremely unhelpful
03:08:19 <johnw> @wn covariant
03:08:20 <lambdabot> *** "covariant" wn "WordNet (r) 3.0 (2006)"
03:08:20 <lambdabot> covariant
03:08:20 <lambdabot>     adj 1: changing so that interrelations with another variable
03:08:20 <lambdabot>            quantity or set of quantities remain unchanged
03:08:37 <srhb> ie. proportional? :P
03:08:39 <johnw> yeah, got to agree there
03:08:47 <hiptobecubic> n. In mathematics, a function which stands in the same relation to the primitive function from which it is derived as any of its linear transforms to a similarly derived transform of its primitive; a function of the coefficients and variables of a given quantic, such that when the quantic is linearly transformed, the same function of the new variables and coefficients is equal to the old function multiplied
03:08:48 <hiptobecubic> by some power of the modulus of transformation. Covariants were discovered by Cayley, and so named by Sylvester, 1852.
03:08:50 <shachaf> @wn contravariant
03:08:50 <lambdabot> No match for "contravariant".
03:09:06 <b_work> @wn contravariance
03:09:06 <lambdabot> No match for "contravariance".
03:09:27 <shachaf> johnw: I think you can find the essence of the Haskell "covariant" in there if you look hard enough. :-)
03:09:51 <srhb> hiptobecubic: The fuck.
03:09:54 <srhb> @wn quantic
03:09:54 <lambdabot> *** "quantic" wn "WordNet (r) 3.0 (2006)"
03:09:54 <lambdabot> quantic
03:09:54 <lambdabot>     n 1: a homogeneous polynomial having at least two variables
03:09:59 <johnw> you mean, like the fact that const 12 always returns 12?
03:10:10 <neutrino> here's a good piece of background johnw  http://en.wikipedia.org/wiki/Covariance_and_contravariance_of_vectors
03:10:32 <wuttf> Anyone else missing a builtin map type?
03:10:41 <shachaf> No.
03:10:45 <hiptobecubic> lol
03:10:46 <shachaf> The one in Data.Map is good enough for me.
03:11:05 <johnw> and i like being to swap it out for Data.HashMap
03:11:19 <neutrino> "The terms covariant and contravariant were introduced by J.J. Sylvester in 1853 in order to study algebraic invariant theory. In this context, for instance, a system of simultaneous equations is contravariant in the variables."
03:11:20 <wuttf> Fair enough.
03:11:27 <shachaf> SamanthaD: You should do a talk at bahaskell instead of writing a tutorial!
03:11:32 <shachaf> Or in addition to.
03:11:37 <shachaf> I don't know. I hear they like talks.
03:12:12 <hiptobecubic> What is the big benefit of hashmap over map?
03:12:27 <hiptobecubic> Beyond "hashing".
03:12:36 <fmap> It's often faster
03:12:43 <fmap> (for lookups)
03:12:56 <SamanthaD> shachaf: Eek! Speaking!
03:13:01 <fmap> actually it's often faster than IntMap
03:13:19 <hiptobecubic> how can it be faster than intmap
03:13:34 <hiptobecubic> doesn't it hash to an int, essentially?
03:14:00 <johnw> also, the key type in a Map might have an expensive equality comparison, where a hash lookup is always a very simple comparison
03:14:17 <nellthu> is there an alternative for hackage.haskell.org?
03:14:20 <shachaf> SamanthaD: I know, man, I feel the same way.
03:14:23 <shachaf> @where hackage-mirror
03:14:23 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
03:14:31 <shachaf> SamanthaD: But that doesn't mean I can't tell other people to do it!
03:14:36 <johnw> shachaf: sadly, that alternative is only for cabal install'ing
03:14:44 <johnw> it doesn't help people looking for Haddock documentation :(
03:15:02 <johnw> because Hoogle's up, but nothing that it links to is
03:15:23 <hiptobecubic> Why not always use hashmap?
03:15:24 <SamanthaD> shachaf: Indeed...
03:15:32 <johnw> hiptobecubic: is everything hashable?
03:15:38 <shachaf> http://hdiff.luite.com/cgit/lens/tree/src/Control/Lens/Type.hs -- documentation!
03:15:42 <shachaf> It's just in source form.
03:15:56 <shachaf> johnw: Yep.
03:16:00 <hiptobecubic> What has Eq but isn't hashable?
03:16:04 <shachaf> hashAnything :: a -> Int; hashAnything = 0
03:16:12 <johnw> lol
03:16:16 <shachaf> Hmm, const 0
03:16:23 <shachaf> I'll just pretend you had NumInstances in scope.
03:16:26 <johnw> that should just be the definition of Data.Map :)
03:16:32 <johnw> a HashMap where everything hashes to 0
03:16:47 <johnw> or is lookup linear in HashMap beyond the hash lookup?
03:16:49 <hiptobecubic> State?
03:17:01 <saeidw> it would be linear I think
03:21:19 <mikeplus64> @hoogle a -> m (f a)
03:21:19 <lambdabot> Data.Generics.Aliases unGM :: GenericM' m -> forall a. Data a => a -> m a
03:21:19 <lambdabot> Control.Monad.List runListT :: ListT a -> m [a]
03:21:19 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
03:21:29 <shachaf> return . pure
03:22:01 <mikeplus64> that's what i'm using, it's just lame for no logical reason other than code cuteness :(
03:22:29 <shachaf> fmap pure pure??
03:22:59 <mikeplus64> > pure`fmap`pure$0::Maybe[Int]
03:23:01 <lambdabot>   Just [0]
03:23:04 <mikeplus64> heh
03:23:38 <mikeplus64> @pl fmap pure pure
03:23:38 <lambdabot> fmap pure pure
03:23:48 <mikeplus64> @pl return . return
03:23:48 <lambdabot> return . return
03:23:50 <johnw> :t fmap pure uprue
03:23:51 <lambdabot> Not in scope: `uprue'
03:23:52 <johnw> :t fmap pure pure
03:23:54 <lambdabot> (Applicative f1, Applicative f) => a -> f (f1 a)
03:24:15 <johnw> :t pure . pure
03:24:16 <lambdabot> (Applicative f1, Applicative f) => a -> f (f1 a)
03:24:32 <johnw> caleskel
03:25:08 <shachaf> @ty ap (ap (const const) (ap (const ap) (ap (const const) id))) (const id)
03:25:09 <lambdabot> (a -> b) -> (b1 -> a) -> b1 -> b
03:25:14 <johnw> ah, they are identical even without caleskel
03:25:41 <johnw> that's flip (.)?
03:25:51 <johnw> no, it's just (.)
03:26:11 <shachaf> @ty ap (ap (pure pure) (ap (pure ap) (ap (pure pure) id))) (pure id)
03:26:12 <lambdabot> (Monad m, Applicative m) => (a -> b) -> m a -> m b
03:26:14 <shachaf> zomg
03:26:40 <srhb> What.. o_o
03:28:06 <zomg> shachaf
03:28:58 <johnw> :t ap . return
03:28:59 <lambdabot> Monad m => (a -> b) -> m a -> m b
03:29:18 <johnw> :t ap . pure
03:29:19 <lambdabot> (Monad m, Applicative m) => (a -> b) -> m a -> m b
03:29:38 <Lethalman> :t ap
03:29:40 <lambdabot> Monad m => m (a -> b) -> m a -> m b
03:29:54 <Lethalman> oh isn't that <*>
03:30:03 <Lethalman> but for monads
03:30:09 <johnw> yep
03:30:09 <Lethalman> :t (<*>)
03:30:11 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:30:12 <Lethalman> ok
03:31:06 <johnw> i had to use it for the first time the other day
03:31:25 <johnw> because I was making an instance for a type class that had a Monad constraint, but no Applicative constraint
03:33:08 <shachaf> @ty WrapMonad
03:33:09 <lambdabot> m a -> WrappedMonad m a
03:33:49 <johnw> cool
03:33:53 <johnw> i did'nt know about that
03:34:11 <swi> Hello. if i type in emacs tail, emacs shows it's definition in buffer line, but do not show such thing for my function written in this file. Did i miss something ?
03:34:52 <shachaf> path[l]: Are you by any chance both (a) in the bay area and (b) unaware of bahaskell?
03:35:47 <johnw> swi: try M-x turn-on-haskell-decl-scan
03:37:59 <SamanthaD> shachaf: speaking of, any chance of a meetup in the near future?
03:38:13 <swi> johnw: nothing comes out
03:40:23 <johnw> swi: I don't have any better ideas, I'm sorry
03:40:54 <swi> johnw: it's ok
03:42:33 <shachaf> SamanthaD: Of bahaskell? I don't know of any plans.
03:42:52 <shachaf> SamanthaD: I think there's a bit of a lack of a venue these days?
03:43:07 <shachaf> If you know any places that could work in SF you should mention it. :-)
03:43:20 <shachaf> Usually meetings have been on the third Wed of the month.
03:43:22 <SamanthaD> shachaf: Would a venue in San Jose work, too?
03:43:43 <shachaf> I think most people who go are in SF/Berkeley, so San Jose is a bit far.
03:43:59 <shachaf> We've had a meeting at Stanford before and even that was somewhat far for some people.
03:44:35 <chemist_> #help
03:44:43 <chemist_> whereis hackage ?
03:44:48 <shachaf> Down.
03:44:49 <shachaf> @where hackage-mirror
03:44:50 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
03:44:57 <chemist_> thanks
03:45:03 <SamanthaD> shachaf: Well, I know that the SJSU library has (albiet very small) conference rooms that are rentable for free.
03:46:02 <shachaf> Hmm, sometimes we have a bunch of people coming, and also San Jose is probably a bit far for most people.
03:46:14 <shachaf> But it's something to keep in mind.
03:46:54 <shachaf> (Are you at SJSU?)
03:48:40 <SamanthaD> shachaf: Yeah, I was and I still have a lot of connections there. I might even be able to get a classroom for a couple hours if you ask nicely. ;)
03:53:02 <q0tw4> why hackage is down again
03:53:19 <shachaf> @where hackage-mirror
03:53:19 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
03:54:30 <edwardoc> who runs hackage?
03:54:52 <shachaf> Galois.
03:54:54 <parcs> it is a mystery
03:55:02 <edwardoc> Ah really
03:55:27 <shachaf> Alternatively: No one. It's not running.
03:55:27 <edwardoc> Its a little disconcerting
03:55:38 <shachaf> It would be good if it didn't go down.
03:55:40 <edwardoc> given haskells reliablility and all
03:56:00 <shachaf> I'm not sure what one thing has to do with the other?
03:56:22 <edwardoc> well nothing but public image
03:56:31 <edwardoc> no technical relation
03:56:58 <ciaranm> it's reliable: it works eventually
03:57:07 <ciaranm> you just don't know how long it'll take or how much RAM it'll need
03:57:35 <SamanthaD> Maybe hackage needs to be implemented as a server pool rather than a discrete server?
03:57:51 <ciaranm> maybe you need to know what the problem is before deciding that
03:57:57 <edwardoc> most likely, it has quite a bit of traffic
03:58:14 <parcs> lol
03:58:21 <SamanthaD> edwardoc: Which would make implementing as a server pool a clear solution.
04:01:04 <wuttf> Are lists represented as linked lists?
04:02:19 <shachaf> Lists are linked lists.
04:02:40 <shachaf> How they are represented depends on what you mean by representation.
04:02:45 <Maxdamantus> Are linked lists represented by linked lists?
04:02:52 <alpounet> SamanthaD, hackage is also being rewritten, a significant part is already done, you may want to check that out :)
04:03:03 <Maxdamantus> Is it using darcs?
04:03:55 <alpounet> it's in a darcs repo right now, but will be on github or smth similar once released (but most likely github), but not before the 2.0 is out
04:04:29 <Maxdamantus> I meant for distributing package source.
04:04:43 <shachaf> No.
04:04:55 <wuttf> I though a Haskell list is an abstract entity, which does not specify an underlying implementation
04:05:12 <shachaf> Here is the implementation of []:
04:05:18 <shachaf> data [] a = [] | a : [] a
04:05:24 <shachaf> With less confusing syntax:
04:05:30 <shachaf> data List a = Nil | Cons a (List a)
04:05:33 <wuttf> For me an implementation is C or assembly, but okay.
04:05:41 <alpounet> Maxdamantus, nope, just good old .tar.gz, that won't change
04:05:46 <wuttf> Something close to the metal.
04:05:53 <latermuse> how exactly does the (>=>) operator work? does it differ much from a unix pipe?
04:06:00 <shachaf> That's asking for an implementation of all ADTs.
04:06:13 <shachaf> I can give it to you, but it's more involved.
04:06:15 <shachaf> @where stg
04:06:15 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
04:06:18 <shachaf> @where ptr-tag
04:06:19 <lambdabot> http://research.microsoft.com/~simonpj/papers/ptr-tag/index.htm
04:06:37 <shachaf> You can start with those two papers. :-)
04:06:46 <shachaf> Alternatively you can read the assembly code that GHC generates.
04:07:11 <shachaf> (Also: Assembly isn't really "close to the metal". It's just another abstraction layer.)
04:07:13 <wuttf> I will start with the papers, thanks.
04:07:17 <shachaf> (C is even more removed.)
04:07:22 * Maxdamantus loaded all his ArchLinux packages into a git repository once.
04:07:35 <Maxdamantus> It shrunk in size (relative to the tar.xzs)
04:07:53 * Maxdamantus can't remember how significant it was.
04:08:18 <Maxdamantus> (the contents of the tar.xzs were git trees addressable by tags)
04:09:25 <wuttf> shachaf: Anyway, I am just thinking about if it would be possible (or being done) to optimize lists to have better cache locality
04:10:10 <wuttf> Because naive linked lists aren't exactly known for exhibiting good locality
04:10:59 <wuttf> They also waste a lot of space for pointers if the elements are sufficiently small.
04:11:05 <SamanthaD> shachaf: Thanks for the implementation of lists! For some reason I had it worked into my head that there was something more special than that involved.
04:11:41 <SamanthaD> shachaf: Something so central to the language and it's not even a primitive! Amazing!
04:11:58 <shachaf> wuttf: Well, there are many data structures other than lists.
04:12:14 <shachaf> Lists in Haskell are lazy, which can make all the things you're thinking about a good deal trickier.
04:12:29 <shachaf> In fact in many ways Haskell lists correspond to other languages' loops, rather than lists.
04:12:42 <shachaf> SamanthaD: Well, the syntax is primitive. But other than the syntax you could define it yourself.
04:12:45 <wuttf> shachaf: That's my question, that's why I am interested in the implementation, how much do I lose if I use a [Char] for example? In terms of space, time etc
04:13:00 <shachaf> wuttf: It's pretty bad. :-)
04:13:23 <wuttf> :-) Lol.
04:13:24 <shachaf> data [a] = [] | a : [a]; data Char = C# Char#
04:14:01 <SamanthaD> shachaf: So, you're saying theoretically it's just an algebraic data type but in reality GHC handles it as a primitive for performance reasons? That makes sense though for some reason it makes me sad inside...
04:14:13 <shachaf> SamanthaD: No, not performance. Just syntax.
04:14:35 <shachaf> You could define data List a = Nil | Cons a (List a) and then do all the optimizations on it that real GHC lists get.
04:15:31 <SamanthaD> shachaf: Oh, I understand now. You mean the [ and-i-can-put-stuff-in-here ] deal is coded into the compiler but the structure of the list itself isn't anything special
04:15:47 <SamanthaD> shachaf: just the way we write the list as stuff between brackets.
04:15:51 <shachaf> wuttf: On a 64-bit machine, I think something like the string 'a' : 'b' : [] will take, uh, 10 machine words? So 80 bytes?
04:16:02 <shachaf> wuttf: Though there are all sorts of optimizations.
04:16:09 <shachaf> SamanthaD: Right.
04:17:50 <shachaf> wuttf: We have more space-efficient types like Data.Text.
04:18:35 <SamanthaD> shachaf: I suppose I can accept syntactic sugar without being sad. It's really amazing how consistent the Haskell language definition is. The more I learn about the language the more I feel like I'm staring at some kind of fractal.
04:22:27 <mSSM> In my .cabal file, I have entries for the executables `foo' and `bar'. Can I somehow tell $ cabal-dev install to only compile `bar', but ignore `foo'?
04:23:01 <shachaf> SamanthaD: Note that if you defined your own list type like I said and just used it naïvely, you wouldn't get all the performance of [], because there are lots of hidden optimizations in Data.List and so on.
04:23:08 <shachaf> foldr/build fusion and things like that.
04:23:09 <alpounet> mSSM, you can use a flag to optionally build foo
04:23:12 <alpounet> i guess
04:23:12 <shachaf> But you *could* get it.
04:25:36 <SamanthaD> shachaf: Well... I was just toying in my head earlier today about how one would go about implementing a function to generate the Fibonacci sequence without using anything other than pattern matching and Int. You just filled in the last bit I need.
04:26:02 <ciaranm> SamanthaD: WHY WOULD YOU DO THAT?
04:26:16 <SamanthaD> ciaranm: For fun ;)
04:26:50 <shachaf> SamanthaD: Why allow yourself Int?
04:26:55 <shachaf> data Nat = Zero | Succ Nat
04:27:19 <ciaranm> SamanthaD: fun is learning the good way of calculating them
04:27:56 <SamanthaD> shachaf: Yes, that had just occurred to me. Though, my idea was to use lists of various lengths to represent numbers.
04:28:10 <SamanthaD> shachaf: you see... succ is a function found in Prelude ;)
04:28:13 <shachaf> That's pretty much the same thing.
04:28:18 <shachaf> SamanthaD: But Succ isn't!
04:28:26 <SamanthaD> shachaf: it isn't?!
04:28:58 <SamanthaD> shachaf: Then it's a primitive function. Still against the rules. Remember, nothing but pattern matching!
04:29:53 <shachaf> ?
04:30:03 <shachaf> > "Succ" /= "succ"
04:30:05 <lambdabot>   True
04:30:20 <SamanthaD> shachaf: I guess I'm confused then
04:30:28 <shachaf> It doesn't matter.
04:30:31 <shachaf> We meant the same thing.
04:31:15 <ciaranm> another more interesting question is, given your data Nat, how you define Int
04:31:26 <SamanthaD> shachaf: Oh, I get it. >.< Succ is a data constructor and your Nat type is just a stack of Nats
04:31:40 <ciaranm> you can't really do equivalence classes in haskell
04:33:06 <shachaf> Int is just a different interepretation of the same type!
04:33:15 <shachaf> SamanthaD: Right. Note how that's equivalent to [()]
04:34:02 <SamanthaD> shachaf: Isn't there a breed of lambda calculus that handles integers in just such a fashion?
04:35:03 <ciaranm> church numerals
04:35:13 <shachaf> Well, in pure lambda calculus you usually just represent Nats as functions.
04:35:23 <shachaf> You can do it in Haskell too.
04:35:33 <shachaf> It's a lot like foldr.
04:36:33 <SamanthaD> ciaranm, shachaf: Yes, that's what I was thinking of. I just could'nt remember the name.
04:37:01 <ciaranm> it's an amusing party trick, but that's about it
04:37:39 <chrisdone> anyone tried compiling hugs with emscripten?
04:37:41 <quicksilver> why don't I ever get invited to parties like that?
04:38:07 <ciaranm> quicksilver: because of that one time where you got drunk and started advocating NBG
04:38:16 <blueonyx> hi, is there a way to view packages' documentation on http://hdiff.luite.com?
04:40:02 <alpounet> blueonyx, no but you can enable documentation generation in your ~/.cabal/config
04:40:16 <alpounet> and you'll have them locally, built whenever you build a package
04:41:21 <blueonyx> thanks
04:43:04 <alpounet> blueonyx, incidentally, that also lets you hae the documentation of some package you've written (and even its dependencies if you pass haddock the right options) offline, or stored on your webserver for convenience for your user, whatever
04:43:45 <alpounet> users*
04:45:00 <blueonyx> i don't dare to upload my code anywhere ;)
04:45:16 <mSSM> Hackage is down?
04:45:18 <mSSM> :(
04:45:22 <mSSM> oh noooooo
04:46:48 <mSSM> Is there an alternative resource for hackage goodness?
04:47:00 <osfameron> mirrors?
04:47:04 <t7> node.js packages
04:47:11 <b_work> in the case of some packages github
04:47:41 <ulkon> http://comonad.com/reader/2012/hackage-mirror/
04:48:12 <osfameron> hurrah
04:48:35 <eddayyy> hackage is down?
04:49:08 <t7> i have experienced several hackage outages in my time
04:49:41 <mSSM> To be honest, I just want to look at package documentation. That's all I care about.
04:49:48 <mSSM> I don't want to download packages.
04:49:56 <t7> mSSM, try hayoo
04:50:26 <mSSM> t7: It seems down too :(
04:50:29 <mSSM> oh noooooooo
04:50:36 <t7> mother of god
04:50:51 <b_work> there's this series of functions (.), (.) . (.), (.) . (.) . (.) which turned out to be useful abstractions, but "in between" those you have (.) (.), (.) . (.) (.), etc.. is this a much used pattern?
04:51:03 <ciaranm> :t (.:)
04:51:04 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
04:51:18 <Lethalman> /o\
04:51:27 <osfameron> (.:) is usually defined as (.).(.) isn't it?
04:51:32 <b_work> yes
04:51:45 <b_work> :t (.) (.)
04:51:46 <lambdabot> (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
04:51:51 <b_work> what about this though?
04:52:07 <b_work> :t let a = (.) in a a
04:52:08 <lambdabot> (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
04:52:10 <b_work> :t let a = (.) in a a a
04:52:11 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
04:52:12 <t7> > (+ 123) .: Right (Just 321)
04:52:12 <b_work> :t let a = (.) in a a a a
04:52:14 <lambdabot> (Functor f2, Functor f1, Functor f) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
04:52:14 <lambdabot>   Right (Just 444)
04:53:07 <hiptobecubic> poor hackage
04:53:10 <hiptobecubic> Why is it so bad?
04:53:26 <t7> @hoogle a (b x) -> b (a x)
04:53:27 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
04:53:27 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
04:53:27 <lambdabot> Test.QuickCheck.Gen promote :: Monad m => m (Gen a) -> Gen (m a)
04:53:50 <mSSM> hiptobecubic: because it's written in haskell? http://www.badumtss.net/
04:54:46 <t7> haskell just isnt webscale !
04:56:15 * osfameron pats hackage on the head
04:56:31 <osfameron> one day it will be a real infrastructure!
04:57:44 <aleator_> Why exactly does hackage go down so often? Who do I give money so it doesn't?
04:57:56 <jang> I'll accept a fiver.
04:58:19 <t7> do americans say fiver?
04:58:20 <ciaranm> i'll accept two fivers!
04:58:24 <aleator_> jang: Does it help?
04:58:31 <jang> it won't make it worse.
04:58:35 <t7> hehe
05:00:07 <mSSM> The definition of (>>=) for MaybeT on http://en.wikibooks.org/wiki/Haskell/Monad_transformers : Wouldn't it be cleaner to write `Nothing -> MaybeT . return $ Nothing', so that one doesn't have to `runMaybeT $ f value', but skip runMaybeT ?
05:01:14 <mSSM> It seems silly: `f' puts `value' into the `MaybeT' context, but we use MaybeT's accessor to get out the underlying representation, to wrap it up again?!
05:01:42 <hiptobecubic> t7, no
05:01:57 <q0tw4> If I will use haskell in my projects I probably will create own hackage with all packages up to date (or removed) and rewrite some packages
05:02:14 <ciaranm> yeah? well i'm going to create my own hackage. with blackjack! and hookers!
05:02:38 <b52> :D
05:03:08 <mSSM> so, we would have: `x >>= f = do { maybe_value <- runMaybeT x ; case maybe_value of { Nothing -> MaybeT . return $ Nothing ; Just value -> f value } }
05:03:11 <mSSM> Or am I missing something?
05:03:25 <b52> http://i1.kym-cdn.com/photos/images/original/000/335/042/72f.png
05:03:44 <mSSM> Right now it reads: `x >>= f = MaybeT $ do { maybe_value <- runMaybeT x ; case maybe_value of { Nothing -> return $ Nothing ; Just value -> runMaybeT $ f value } }
05:04:19 * mSSM (de-)sugaring all day long!
05:04:26 <q0tw4> I don't like some architecture decisions in some packages
05:06:12 <mSSM> Oh, ok; they state it right after: the do block must be in the m monad.
05:06:26 <mSSM> Dat makes sense!
05:14:24 <SamanthaD> anyway... sleep time
05:14:25 <SamanthaD> night all
05:20:47 <mysticc> I have an executable which I want to profile. I have configures using cabal configure --enable-executable-profiling and set ghc-prof-options to -auto-all in cabal but after I build, I am not able to pass -p to RTS to generate profiling info. what I am doing wrong?
05:22:02 <hiptobecubic> Maybe it's misguided, but I feel like I learn more about OOP in here than elsewhere.
05:22:12 <soiamso> Can anyone access  hackage.haskell.org   ?
05:22:16 <hiptobecubic> soiamso, no
05:22:33 <hiptobecubic> there is a mirror though
05:22:42 <soiamso> hiptobecubic:  hayoo just recover ?
05:22:59 <soiamso> hiptobecubic: any hint to the mirror ?
05:23:17 <hiptobecubic> i don't remember how to summon it. let me look at logs
05:23:24 <hiptobecubic> hayoo appears to be working
05:23:38 <blueonyx> http://comonad.com/reader/2012/hackage-mirror/
05:23:48 <soiamso> blueonyx:  thanks
05:23:51 <hiptobecubic> hackage also just worked fo rme
05:24:39 <blueonyx> yay it's back
05:25:06 <soiamso> great !
05:36:49 <alpounet> mysticc, you need to build your program with "-rtsopts"
05:37:08 <alpounet> that enables the +RTS thingy
05:37:43 <Yuu-chan> How to open the Prelude sources? http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html is displayed correctly, but all "Source" links redirect to some unreadable URL (/packages/archive/%01/%02/doc/html/src)
05:39:07 <kosl90> hey, guys, I start to learn haskell those days, but I can't find a good indent file for vim. Any advice?
05:39:29 <mysticc> alpounet: That doesn't help. I have to explicitly add -prof to ghc-options in the cabal file then while configuring it complains to use -enable-library or executable profiling flag but profiling works where as If I use those flags then it doesn't work
05:40:45 <alpounet> mysticc, well, you have a "ghc-prof-options" field available for use in a cabal file, there you can put anything you want, including, say, -rtsopts and whatnot
05:41:03 <alpounet> that field will be used when you use --enable-{library, executable}-profiling
05:41:55 <alpounet> so, -prof -rtsopts, among other things, there
05:42:01 <mysticc> alpounet: That does not work
05:42:13 <alpounet> mysticc, could you be more precise?
05:42:57 <alpounet> mysticc, because this *does* work: https://github.com/alpmestan/kmeans-vector/blob/master/kmeans-vector.cabal#L35
05:43:37 <alpounet> you also need all profiling versions of your dependencies (i strongly advise to make that permanent in your ~/.cabal/config
05:43:39 <alpounet> )
05:43:40 <mysticc> alpounet: This is the line I have ghc-prof-options: -prof -rtsopts -auto-all and this is how I configure and build cabal configure --enable-executable-profiling ; cabal build. but when I run program from ./dist/build .. +RTS -p it complainst to enable profiling
05:43:55 <mysticc> alpounet: I have every library installed with profilin
05:44:23 <mysticc> alpounet: When I mention -prof in ghc-options field in the cabal file it complains but profiling works
05:44:36 <alpounet> what does it say?
05:44:40 <alpounet> (when complaining)
05:44:54 <mysticc> alpounet: : the flag -p requires the program to be built with -prof
05:45:13 <mysticc> alpounet: And then whole bunch of help mentioning about various RTS options
05:45:54 <mysticc> alpounet: You can try yourself with a single executable in the cabal file and see if this works
05:46:35 <dcoutts_> mysticc: what version of cabal? iirc there was a bug in some intermediate dev version where profiling was broken
05:46:38 <mysticc> alpounet: I suppose there is some bug in cabal or something
05:46:57 <mysticc> alpounet: cabal-install version 1.16.0.2
05:48:34 <alpounet> mysticc, i haven't ever encoutered a bug re. profiling and cabal, but that's possible! so when you put -rtsopts -prof -auto-all in "ghc-options" instead of "ghc-prof-options", things go smoothly?
05:48:54 <dcoutts_> mysticc: what version of Cabal library?
05:48:55 <mysticc> alpounet: I just need to put -prof there
05:49:12 <mysticc> alpounet: cabal 1.6.0 I think
05:49:45 <mysticc> I am updating it 1.6.0.3 now to see if still persists
05:49:45 <alpounet> mysticc, ok it seems odd, i'll let dcoutts_ take it from here, but you may have encountered a bug
05:50:32 <dcoutts_> mysticc: there was also a dud release of 1.6.0.x, using cabal-install built against 1.6.0.3 is a good idea
05:51:37 <mysticc> dcoutts_: Ok I will let you know after updating cabal to 1.6.0.3 I already have cabal-install 1.6.0.3 version.
05:52:29 <latermuse> why is this function giving a type error?  if x == Nothing then BL.putStr BL.empty else BL.putStr x
05:52:31 <dcoutts_> mysticc: you mean cabal-install-1.6.0.2, there is no .3 for that
05:52:54 <mysticc> dcoutts_: oops .. yeah
05:53:06 <dcoutts_> mysticc: note that cabal-install needs to be built against that Cabal lib. You'll be able to tell by using cabal --version, it reports both.
05:53:09 <latermuse> why is this function giving a type error?  if x == Nothing then BL.putStr BL.empty else BL.putStr $ fromJust x
05:53:17 <latermuse> sorry, i missed that fromJust
05:53:23 <latermuse> still a type error though
05:53:43 <sipa> :t BL
05:53:45 <lambdabot> Not in scope: data constructor `BL'
05:53:53 <sipa> :t BL.putStr
05:53:54 <lambdabot> Couldn't find qualified module.
05:53:55 <Botje> latermuse: we're going to need more context.
05:53:59 <latermuse> BL = ByteString lazy
05:55:04 <mysticc> dcoutts_: cabal-install version 1.16.0.2
05:55:05 <mysticc> using version 1.16.0 of the Cabal library
05:55:48 <dcoutts_> mysticc: so you want to reinstall cabal-install (assuming you've now got the latest Cabal lib installed)
05:56:20 <latermuse> it gives this error: Couldn't match expected type `()' with actual type `[a0]'
05:56:55 <Botje> latermuse: can you put a small test case on hpaste.org?
05:57:00 <mysticc> dcoutts_: I have installed Cabal 1.16.0.3 now how do I remove the old cabal ? ghc-pkg unregister doesn't see to work
05:57:26 <latermuse> sure, one moment
05:57:27 <dcoutts_> mysticc: you don't need to unregister the old one
05:57:44 <mysticc> dcoutts_: Ok So I will reinstall cabal-install and see
05:58:47 <mysticc> dcoutts_: How do I build cabal-install with 1.6.0.3, It is still using the older version
06:00:05 <dcoutts_> mysticc: it should just pick it up when you rebuild it. It shouldn't be necessary, but you can force it by saying --constraint='Cabal == 1.6.0.3'
06:01:58 <hpaste> latermuse pasted “problem here” at http://hpaste.org/81118
06:02:23 <latermuse> Botje: I just posted it
06:02:36 <mysticc> dcoutts_: http://hpaste.org/81119
06:02:52 <hiptobecubic> Does anyone know what the hell Mixins really are and what serves their role in Haskell? It looks like an interface that doesn't bring any type information with it.
06:03:08 <johnsonw> Why are so many important libraries, like array, still at 0.x. That means I can't rely the API to be stable at all, doesn't it? Why's the situation so bad for so many core libraries?
06:03:15 <mysticc> dcoutts_: my bad
06:03:20 <elliott> johnsonw: your assumption is incorrect.
06:03:26 <Botje> latermuse: I fear you might be bitten by the dreaded monomorphism restriction.
06:03:34 <latermuse> what is that?
06:03:48 <latermuse> does that explain why this code compiled just fine a few mintues ago, then stopped compiling all of a sudden?
06:03:52 <Botje> let me verify.
06:04:21 <johnsonw> elliott: does Haskell not use semantic versioning? if it doesn't what do the version numbers mean?
06:04:34 <gary> hi
06:04:54 <mauke> johnsonw: version 1 means it's finished. version < 1 means it's still being worked on
06:05:09 <typoclass> johnsonw: among haskellers (and many open-source people) the "0.xxx" doesn't really mean it's immature. they just chose 0 as the starting point. i guess it's arbitrary
06:05:15 <Botje> latermuse: hmm, no. that piece of code compiles just fine, actually.
06:05:22 <elliott> johnsonw: http://www.haskell.org/haskellwiki/Package_versioning_policy
06:05:23 <mauke> also, Haskell doesn't even have version numbers ಠ_ಠ
06:05:37 <latermuse> yeah it was compiling just fine for me a few minutes ago. then I went to eat dinner and came back and it stopped compiling
06:05:45 <latermuse> super strange
06:05:57 <latermuse> Couldn't match expected type `()' with actual type `[a0]'
06:05:58 <`ramses> probabilistic compiler? :)
06:06:00 <latermuse> thats the error im getting
06:06:09 <mauke> latermuse: what's the actual error message?
06:06:15 <Botje> latermuse: it compiles and runs just fine though.
06:06:21 <dcoutts_> mysticc: ?
06:06:23 <Botje> latermuse: did you forget to save or something?
06:06:30 <Botje> latermuse: at which line is the error pointing?
06:06:30 <latermuse> nope
06:06:40 <johnsonw> Why does't the haskell community use existing standards for version numbers instead of inventing their own?
06:06:59 <mauke> johnsonw: who are you calling "the haskell community" and what are these existing standards you speak of?
06:07:00 <dcoutts_> mysticc: ohhh 1.6 vs 1.16
06:07:01 <Doikor> what existing standard?
06:07:09 <Philippa> johnsonw: this /is/ an existing standard
06:07:19 <latermuse> it points to the: if x == Nothing then BL.putStr BL.empty else fileOut $ fromJust x
06:07:39 <dcoutts_> mysticc: I was just reproducing the problem and I didn't spot that either :-)
06:07:41 <latermuse> in the expression: fileOut $ fromJust x
06:07:41 <johnsonw> mauke: this wiki is what the haskell community propose as version numbers, and semantic versioning is the standard
06:07:44 <`nand`> standards? for version numbers!?
06:07:54 <mauke> johnsonw: that didn't answer either of my questions
06:07:56 <mauke> johnsonw: try again
06:07:57 <typoclass> johnsonw: i can see how it can look confusing for a moment, but really, i think most open-source software everywhere doesn't care much about "version 1.0"
06:08:01 <Botje> latermuse: and how are you using checkAndOutputfiles?
06:08:38 <johnsonw> mauke: the standard is semantic versioning http://semver.org - is that an answer to your second question
06:08:43 <Philippa> right, the assumption is that what you start with when you first release isn't equivalent to a commercial 1.0 release, it's a work-in-progress hack that might change drastically
06:08:44 <`nand`> mauke: as far as I can tell, “the editors of the haskell wiki” is what he calls “the haskell community”
06:09:03 <Philippa> johnsonw: I've been programming for 25 years, why is this the first time I've seen that URL?
06:09:13 <mauke> johnsonw: how is that a "standard"?
06:09:16 <`nand`> it's the first time I've seen it as well, though I've been programming for significantly shorter :(
06:09:17 <Philippa> hint: the answer is not "stuck in MS land"
06:09:23 <Philippa> mauke: Standards are great, everyone has one!
06:09:31 <Botje> some people have two!
06:09:33 <latermuse> checkAndOutputFiles fileList
06:09:39 <latermuse> not too complicated there
06:09:41 <Botje> latermuse: and where is fileList defined?
06:09:44 <Lethalman> lol what's that link
06:09:49 <magic> when should I use the 'do' keyword?
06:10:03 <mauke> magic: when you feel like it
06:10:15 <latermuse> fileList is just a list of files ["/home/file1.txt","/home/file2.txt"]
06:10:24 <`nand`> when it reduces code size, obviously :P
06:10:41 <Botje> latermuse: I could compile your file just find and run CheckAndOutput...
06:10:46 <Philippa> magic: when it's easier than using the monad combinators by hand
06:10:57 <Philippa> (which initially is probably "whenever you're doing something monadic, including IO")
06:11:46 <Botje> latermuse: could you re-download your paste to a different file and load that in ghci?
06:12:16 <typoclass> magic: it introduces a 'do block', for example "do \n print 42 \n print 37". this will first print 42, then 37. you could write the same as "print 42 >> print 37", so there's some room for personal style
06:12:26 <Philippa> magic: are you also wondering when to use monads/when you are using them?
06:12:42 <magic> thank you, that's I have a lot to learn about haskell and monad :D
06:13:26 <latermuse> Botje: Yeah, working on that
06:14:41 <latermuse> works just fine; the code i posted on hpaste
06:14:48 <latermuse> this sucks haha
06:15:02 <latermuse> maybe the cat stepped on my keyboard or deleted something somewhere while i was gone
06:16:00 <typoclass> latermuse: awwww =)
06:17:06 <mauke> aw, what happened to johnsonw
06:17:17 <mauke> that versioning thing is pretty hilarious, actually
06:17:21 <`nand`>  <-- │ johnsonw (4f4cf309@gateway/web/freenode/ip.79.76.243.9) has quit (Quit: Page closed)
06:17:32 <mauke> it doesn't claim to be a standard, just a rule proposal
06:17:33 <`nand`> shortly after Philippa's comment about not being stuck in ms land
06:18:01 <mauke> it itself is at version "2.0.0-rc.1" (there's also an older version "1.0.0", but no changelog)
06:18:20 <Philippa> `nand`: sure, but we can still discuss it if people want to sans trollvocate
06:18:43 <Philippa> (the 0.x problem is, er, widespread. Perfectionists don't like calling things done enough to be stable, what else is new?)
06:18:48 <mauke> points 2 and 3 in the specification contradict each other
06:18:49 <typoclass> latermuse: in python, the program would still "run", just give weird behavior or a crash at some future point =)
06:19:45 <mauke> apparently the only change between versions 1 and 2 of the spec is that v2 disallows negative version numbers, allows multipart pre-release identifiers, and adds syntax for build versions
06:19:54 <TorosFanny> what's the meaning of "_|_"?
06:20:04 <latermuse> typoclass: guess im lucky that its not running, right?
06:20:09 <`nand`> bottom, undefined, error, will not terminate
06:20:23 <elliott> I like how the PVP predates the Semantic Versioning thing by approximately ten billion years.
06:20:41 <mauke> I like how he explicitly disallowed negative version numbers but still left the pre-release tag syntax ambiguous
06:21:34 <mauke> e.g. it's not clear whether "1.2.3-" is a valid version, and if so, whether it sorts before or after "1.2.3-0"
06:22:30 * `nand` is a fan of using base-ω decimals for versioning
06:22:36 <wmasson> if I have a function square x = x * x and a computationally intensive function f and I calculate (square (f x)) does (f x) get computed twice? Or is it memoized after the first time?
06:22:50 <latermuse> Botje: I refactored that if statement to use maybe, then the compiler spit out an error that I understood and I fixed it :)
06:23:03 <mauke> wmasson: I wouldn't call it "memoized" but it's only computed once because you gave it a name ("x")
06:23:10 <byorgey> wmasson: f x  is only computed once.  It is not memoized, the result is shared.
06:23:12 <Doikor> and that "1.0 is good enough for commercial use" is kinda foobar with open source projects when most devs never originally intend their work to be used commercially. why should they care about something like that in such a case?
06:23:31 <latermuse> Ok, modules loaded: Main.
06:23:32 <wmasson> okay that makes sense, thanks
06:23:33 <`nand`> wmasson: ‘f’ is not memoized; but a single value will be shared once it is computed; you can still compute the same value twice though but then you'd have to write ‘f x’ twice or something
06:29:46 <roadfish> is there a module for vector arithmetic? so that I can do (2,3)+(6,4) to give (8,7)
06:30:46 <zhulikas> roadfish, you may write instance (a, b) for Num
06:30:48 <mysticc> dcoutts_: Thanks, It is ok now
06:31:07 <zhulikas> roadfish, http://en.wikibooks.org/wiki/Haskell/Advanced_type_classes
06:31:46 <`nand`> there are a few classes for actual vector arithmetic, assuming you want anything more complex than componentwise addition
06:33:22 <`nand`> edwardk: what are your thoughts on a generalization of ‘zipWith’ to arbitrary traversals of the same length?
06:33:49 <roadfish> zhulikas:thank
06:35:23 <roadfish> `nand`:I probably don't need anything too complex. But I am curious. I did a hoogle on vector and it lists 10. is it one of those?
06:35:27 <`nand`> or, well, a single traversal
06:35:40 <roadfish> @hoogle vector
06:35:41 <lambdabot> Test.QuickCheck.Arbitrary vector :: Arbitrary a => Int -> Gen [a]
06:35:41 <lambdabot> Test.QuickCheck vector :: Arbitrary a => Int -> Gen [a]
06:35:41 <lambdabot> package vector
06:35:56 <`nand`> oh, mistake on my part: “a few classes for” <- I meant “a few libraries for”
06:36:02 <`nand`> I wasn't thinking of anything in particular
06:36:16 <zhulikas> vector is not what you're looking for
06:36:33 <`nand`> the first that pops into my mind would be ‘repa’
06:36:49 <`nand`> actually,
06:36:52 <`nand`> I'm not sure if that's what I was thinking of
06:37:42 <`nand`> oh, I was thinking of hmatrix
06:37:47 <abbe> @hoogle (a -> b)  -> (a, a) -> (b, b)
06:37:48 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
06:37:48 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
06:37:48 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
06:38:10 <`nand`> :t over both -- abbe
06:38:11 <lambdabot> (a -> b) -> (a, a) -> (b, b)
06:38:35 <fmap> roadfish: did you see linear?
06:38:35 <abbe> hmm ?
06:38:47 <roadfish> repa looks high octane. unboxed parallel computation. I have a feeling that hmatrix in better for simpler applications.
06:39:18 <abbe> `nand`, hmm...?
06:39:23 <roadfish> fmap/`nand`:ok, I'll check out linear and hmatrix
06:39:37 <`nand`> abbe: I uh.. weren't you looking for a function like that?
06:39:41 <roadfish> thanks for the leads
06:39:45 <abbe> right, I'm.
06:39:49 <hpaste> marek__ pasted “enum” at http://hpaste.org/81120
06:39:59 <marek__> in file: http://okmij.org/ftp/Haskell/Iteratee/Iteratee.hs there's code: http://hpaste.org/81120 - is that code correct?
06:40:10 <abbe> `nand`, I didn't understand ':t over both'
06:40:14 <`nand`> http://hackage.haskell.org/package/vector-space-0.8.6 this also seems relevant
06:40:32 <fmap> @ty join (***) `asTypeOf` over both
06:40:33 <`nand`> ‘:t’ is a lambdabot command to print out the type signature of something
06:40:33 <lambdabot> (b -> c) -> (b, b) -> (c, c)
06:41:17 <abbe> what is 'over both' ?
06:41:40 <`nand`> a function; not sure what you're asking
06:41:44 <fmap> @ty join Data.Bifunctor.bimap `asTypeOf` over both
06:41:45 <lambdabot> (a -> b) -> (a, a) -> (b, b)
06:41:49 <marek__> from first line i deduce that "enum_eof" is just a constant, but in definition of enum_eof it's defined that this function is getting parameter
06:41:57 <abbe> @hoogle over both
06:41:57 <lambdabot> No results found
06:42:37 <fmap> abbe: over and both are from lens library
06:42:39 <abbe> okay, i'm confused. I'm a newbie, so just wondered if there is any pre-existing function which I could use. I don't see any thing like 'over both'.
06:42:44 <blueonyx> hi, i want my Setup.hs to call a function from the lib i just installed, is there something like ruby -e to do that?
06:42:44 <ski> @type [join (***),over both]
06:42:46 <lambdabot> [(b -> c) -> (b, b) -> (c, c)]
06:42:47 <abbe> oh, okay
06:43:13 <geekosaur> blueonyx, there may be a better way but there is ghc -e
06:43:15 <`nand`> join (***) only needs stuff available in ‘base’
06:43:29 <abbe> thanks fmap, `nand`
06:43:30 <`nand`> namely Control.Monad (join) and Control.Applicative ((***))
06:43:39 <`nand`> oh
06:43:42 <`nand`> Control.Arrow
06:43:45 <srhb> *** is in Control.Arrow?
06:43:47 <srhb> Yeah
06:43:48 <`nand`> those darn names with A always confuse me
06:44:10 <srhb> If it's a long symbol, it's in Arrow.
06:44:13 <srhb> My rule of thumb. :P
06:44:18 <elliott> both f (a,b) = (,) <$> f a <*> f b; over l f = runIdentity (l (Identity . f)) -- look ma, just base!
06:44:20 <srhb> <*> feels shorter somehow.
06:44:23 <elliott> (OK, plus transformers for Identity :( )
06:44:27 <quchen> F is even worse. import Data.Funct[TAB] -> spam
06:44:53 <`nand`> ooh, ooh, ooh; ‘linear’ is lensy
06:44:57 <edwardk> `nand`: it sounds like something that would have a monstrous ad-hoc type and hard invariants
06:44:58 <srhb> Is there something called a functoid yet? we need functoids.
06:45:02 <typoclass> abbe: you could also write your own function, which is easy
06:45:21 <abbe> typoclass, right which is what I should do
06:45:30 <edwardk> you can write over with () ->
06:45:35 <edwardk> that stays in base
06:45:35 <mSSM> The type of of `get' in stateful computations confuses me: if I present (st,st) as the result, doesn't have my stateful computation have to have the type `State s s' ??
06:45:49 <mSSM> too many haves
06:45:59 <blueonyx> geekosaur: of course xD thanks
06:46:10 <elliott> edwardk: oh, good point
06:46:10 <mauke> :t get
06:46:12 <lambdabot> MonadState s m => m s
06:46:19 <elliott> overl f = l (const . f) ()?
06:46:25 <elliott> :t \l f -> l (const . f) ()
06:46:26 <lambdabot> Functor f => (f (b -> a) -> () -> t) -> f a -> t
06:46:27 <mauke> mSSM: no, only get itself
06:46:33 <elliott> $(*$@*( caleskell
06:46:38 <elliott> :t \l f -> l (const Prelude.. f) ()
06:46:39 <lambdabot> ((a -> b1 -> b) -> () -> t) -> (a -> b) -> t
06:46:59 <mauke> mSSM: depends on what exactly you mean by "present (st,st) as the result", though
06:47:05 <elliott> :t \l f s -> l (const Prelude.. f) s ()
06:47:06 <lambdabot> ((a -> b1 -> b) -> t1 -> () -> t) -> (a -> b) -> t1 -> t
06:47:09 <elliott> what.
06:47:11 <mSSM> mauke: State $ \st -> (st,st)
06:47:22 <mauke> mSSM: are you reimplementing get?
06:47:25 <typoclass> srhb: what's a functoid?
06:47:35 <srhb> typoclass: No idea, sounds cool though doesn't it?
06:47:38 <mSSM> mauke: no, I am looking at http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State
06:47:52 <edwardk> that looks right
06:47:59 <typoclass> srhb: yeah =)
06:48:19 <mauke> mSSM: ok, so 'get :: State s s'
06:48:28 <srhb> Speaking of -oids, why do we have . instead of <> ? don't functions form monoids with id?
06:48:35 <mauke> srhb: no
06:48:39 <mauke> only some functions
06:48:54 <edwardk> srhb: only when the function is from a -> a could they.
06:48:56 <srhb> Oh, right. Durh.
06:48:58 <`nand`> they form categories with id
06:49:03 <mauke> :t Endo
06:49:04 <lambdabot> (a -> a) -> Endo a
06:49:05 <mSSM> mauke: I am just incredibly confused at how I can have a function like `State $ \st -> (st,st)' in a do block, which actually is supposed to be of type `State st a)
06:49:11 <mSSM> `State st a'
06:49:12 <edwardk> but we have a different monoid on functions
06:49:23 <mauke> mSSM: that's not a function, it's a State value
06:49:24 <edwardk> :t iso
06:49:25 <lambdabot> (Functor f, Isomorphic k) => (s -> a) -> (b -> t) -> k (a -> f b) (s -> f t)
06:49:30 <ski> mSSM : that action has type `State st st'
06:49:32 <edwardk> still ancient lens
06:49:35 <srhb> Right.
06:49:53 <mauke> mSSM: and State st st is an instance of State st a
06:49:54 <`nand`> :t (>>=) -- mSSM: monad combinators are polymorphic enough to allow you to change the result type in a do block
06:49:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:50:21 <`nand`> :t (>>=) `asAppliedTo` (get :: State s s)
06:50:22 <lambdabot> StateT a Identity a -> (a -> StateT a Identity b) -> StateT a Identity b
06:50:31 <ski>   (>>=) :: State st a -> (a -> State st b) -> State st b  -- in your case
06:51:05 <ski> (s/StateT a Identity/State a/)
06:51:34 <mSSM> messy
06:51:36 <mSSM> :(
06:51:51 <`nand`> I do wish GHC were smarter about preserving type synonyms
06:52:02 <`nand`> especially when dealing with lenses!
06:52:27 <byorgey> it actually works fairly hard to preserve type synonyms
06:52:40 <byorgey> it's tricky
06:52:55 <byorgey> the problem is that once you expand a type synonym it's very difficult to unexpand
06:53:05 <`nand`> λ let foo :: Traversal' a a; foo = id
06:53:07 <`nand`> λ :t foo
06:53:09 <`nand`> foo :: Applicative f => (a -> f a) -> a -> f a
06:53:23 <`nand`> I mean, I expect cases like this to stay in unexpanded form
06:53:51 <byorgey> well, it can't see that Traversal' a a  unifies with the type of id without expanding it
06:54:21 <byorgey> though I suppose it's reasonable to want it to just expand internally while checking and then show you the unexpanded form
06:54:55 <byorgey> `nand`: just out of curiosity, what happens if you replace id with 'undefined'?
06:55:09 <`nand`> the intuition I would approach this kind of thing with (as a human, not a compiler) would be to keep track of all type synonyms used in the signatures of the component functions, then try to reverse those where possibly
06:55:10 <`nand`> possible*
06:55:30 <`nand`> byorgey: same thing
06:55:37 <`nand`> curiously
06:55:39 <byorgey> hmm, that's strange then
06:55:42 <`nand`> λ let bar :: String; bar = "foobar"
06:55:44 <`nand`> λ :t bar
06:55:46 <`nand`> bar :: String
06:56:40 <byorgey> ok, you're right, something odd is going on
06:56:48 <byorgey> `nand`: 'reverse where possible' would be weird though.  If I declare   foo :: String -> [Char] -> Int  would you want it to show    foo :: String -> String -> Int?
06:58:05 <quicksilver> I don't think it should ever reverse gratuitously
06:58:19 <quicksilver> but it should keep expansions annotated with teh synonym used
06:58:21 <`nand`> byorgey: maybe. I guess another reasonable thing to expect though is that user-declared type signatures stay in the form they were given; I would probably live with (\x -> foo x) changing that though
06:58:30 <quicksilver> and re-collapse where it can
06:58:38 <byorgey> `nand`: yes, that would make sense
06:58:47 <`nand`> quicksilver: yes, I think that would be better
06:59:09 <byorgey> sounds like a fun GSoC project
07:00:03 <`nand`> like, if it considers “StateT s Identity a [State s a]” and “StateT s Identity a” as distinct types (that still unify); but preserves the annotations when alpha renaming / unifying or whatever -- then recollapses during pretty printing
07:00:07 <`nand`> oh
07:00:11 <`nand`> that was unfortunate pseudo-syntax
07:00:18 <`nand`> the [State s a] here was meant to be a type synonym annotation
07:00:19 <typoclass> quicksilver: right. this could even lead to more informative error messages. "does not match type Foo a -> Bleep, which expanded to Glink -> Bonk a a -> f a -> Runk"
07:00:23 <`nand`> {} would have been better :)
07:00:31 <elliott> byorgey: or worse
07:00:38 <elliott> byorgey: foo :: String -> () becomes foo :: FilePath -> ()
07:00:44 <byorgey> hahaha
07:00:49 <byorgey> right
07:01:24 <quicksilver> typoclass: could be unwieldy when there were multiple expansions
07:01:34 <elliott> really, the compiler should just try to keep it as much as in the source as possible
07:01:37 <quicksilver> I used to think that type synonyms were almost useless anyway
07:01:39 <elliott> use synonyms exactly when the source did
07:01:43 <elliott> of course composition makes this hard.
07:01:51 <quicksilver> btu someone recently pointed out that they had some users
07:01:53 <quicksilver> uses.
07:02:36 <`nand`> I think type synonyms are immensely helpful for stuff like ‘lens’
07:03:12 <`nand`> I mean
07:03:40 <`nand`> compare something like Iso' Foo Bar with (Functor f, Profunctor p) => p Bar (f t) -> p Foo (f t)
07:04:03 <`nand`> the former is immediately recognizable as an isomorphism between foo and bar; the latter only so to the guys writing the libraries :P
07:04:56 <`nand`> err
07:04:59 <`nand`> that type signature is incorrect :(
07:05:11 <`nand`> p Bar (f Bar) -> p Foo (f Foo)
07:06:13 <typoclass> `nand`: that just proves how valuable it is to have "Iso' Foo Bar"
07:06:56 <byorgey> dq
07:07:06 <byorgey> whoops
07:07:06 <`nand`> it might've helped if I actually knew what Iso' expands to, other than copy-pasting ‘id :: Iso' a a’ from ghci and changing a few type variables
07:07:07 <Peaker> the lens use of synonyms seems to be mostly motivated by the monomorphism of (.) and id in the Prelude
07:07:13 <elliott> `nand`: thankfully that f cruft might die sometime
07:07:16 <Peaker> otherwise, newtypes could have worked better?
07:07:27 <edwardk> newtypes for lens would be terrible
07:07:28 <elliott> (Profunctor p => p Bar Bar -> p Foo Foo) is much more accessible
07:07:34 <elliott> Peaker: no, we get subtyping
07:07:38 <elliott> couldn't do that with newtypes
07:07:43 <elliott> it relies on the constraints
07:07:45 <edwardk> the whole api would explode into something 10x as large
07:07:50 <`nand`> Peaker: the whole deal of lens is unification of different lens types with different combinator types
07:08:01 <Peaker> elliott, well, LensLike is still parameterized on "f" and the subtyping relates to the constraints on "f"
07:08:12 <Peaker> elliott, maybe not for everything, but for LensLike, a newtype would still allow subtyping?
07:08:26 <elliott> ok, so what's the gain if you do that?
07:08:32 <elliott> you make defining lenses by hand harder
07:08:35 <Peaker> :t that makes sense :)
07:08:37 <lambdabot> parse error on input `)'
07:08:43 <`nand`> elliott: still better than the good ol' Isomorphic k =>
07:08:45 <elliott> for instance you have to depend on lens to export lenses if you do that
07:08:50 <edwardk> Peaker: we don't parameterize on just f, we parameterize on    p a (f b) -> q s (f t) in the end. by putting that in a newtype what is gained? you piss away the ability to apply a lens and require the end user to use something that isn't a category to compose
07:09:09 <edwardk> and in the end its just a function arrow anyways
07:09:31 <Peaker> edwardk, it might cause a whole lot of trouble, I haven't thought it through.. But there does seem to be a benefit with saner responses from :t
07:10:06 <`nand`> Peaker: naive ‘keep type annotations the way they were given’ would already fix most of that
07:10:10 <edwardk> and as elliott noted you piss away the advantage that lens gives you the ability to write lenses without even depending on it. that has been getting us lenses in a lot of libraries that don't have an explicit backwards dependency on lens
07:10:14 <Peaker> lens does expose a bit too much of the internal structure/complexity to unwitting users
07:10:35 <elliott> Peaker: you wouldn't really get nicer responses from :t
07:10:36 * hackagebot sizes 2.1.0 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-2.1.0 (JohnWiegley)
07:10:38 * hackagebot lens 3.8.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.8.1 (EdwardKmett)
07:10:45 <elliott> (Applicative f, Gettable f) => LensLike f Foo Foo Bar Bar
07:10:49 <elliott> that's not accessible
07:11:02 <edwardk> lens exposes a lot but it has been a conscious decision to maintain the openness of the api to encourage expansion.
07:11:03 <elliott> er I mean Settable there I think
07:11:26 <edwardk> and as elliott noted even with newtypes you wind up with most of its guts displayed. more so than with the type aliases we have
07:12:30 <Peaker> edwardk, losing the ability to directly apply lens can actually be a good thing, btw. forcing the use of "traverseOf" could allow changing the representation without breaking code
07:13:02 <`nand`> lens? caring about breaking code?
07:13:05 <edwardk> well, you're likely to get something closer to your wish in 4.0 if those become profunctors
07:13:22 <edwardk> but the outer type constructor would remain (->)
07:13:23 <`nand`> I'd use %%~ either way, probably
07:13:45 <TylerE> How can I unpack a tuple and use it as the arguments to a function (E.g. I have a pair and a function that takes 2 args)
07:13:58 <Peaker> @type uncurry
07:13:59 <lambdabot> (a -> b -> c) -> (a, b) -> c
07:13:59 <edwardk> type Lens s t a b = Representable p => p a b -> p s t
07:14:11 <`nand`> by ‘unpack a tuple’ I thought you meant (# , #) :(
07:14:22 <mSSM> If I combine `evalState . replicateM n', I don't understand how replicateM will yield `m [a]'.
07:14:28 <Peaker> edwardk, lens seems to have 20 years of history of development condensed into less than a year :)
07:14:39 <byorgey> @type replicateM
07:14:40 <edwardk> Peaker: you say that like its a bad thing ;)
07:14:40 <lambdabot> Monad m => Int -> m a -> m [a]
07:14:42 <Peaker> TylerE, see the type of uncurry above
07:14:55 <SuperNoeMan> would anybody be willing to give some ocaml help? the #ocaml channel is very quiet right now...
07:15:10 <`nand`> Peaker: that's the best development model; speed up evolution in order to weed out the deficits /before/ it becomes too big to change
07:15:29 <TylerE> Peaker: Unfortunatly I'm not actually with a pair, but rather a 4-tuple
07:15:37 <TylerE> so I was really hoping for a general solution
07:15:39 <Peaker> edwardk, no, it's awesome. I see it as finally solving the overly-monomorphic Prelude problem alongside the first-class-patterns and first-class-fields problem..  So a lot of big holes filled at once
07:15:41 <byorgey> mSSM: the type of replicateM shows that it returns  m [a].  Or do you mean you don't understand how it works?  Or you don't understand its semantics?
07:15:52 <SuperNoeMan> I know this is #haskell, but I'm a beginner, and ocaml is a functional language
07:15:57 <mSSM> byorgey: will the stateful computation `i' work with the new state returned from `i-1' ?
07:16:19 <bacon1989> So I was wondering, does anyone here have any material on connecting to a MS SQL server using hdbc-odbc on windows?
07:16:24 <byorgey> TylerE: there is not a more general solution, unfortunately
07:16:25 <Peaker> TylerE, so I guess  \(a, b, c, d) -> f a b c d   is too ugly?
07:16:29 <bacon1989> i'm lost, and can't find any material on the matter
07:16:36 <edwardk> the types in lens are interesting because they take lots of categorical objects and compose and quantify over them in ways that are completely alien to category theorists ;)
07:16:43 <mSSM> byorgey: I am not sure if I understand how evalState actually works on `replicate n'
07:17:15 <`nand`> mSSM: ‘runState . replicateM n’ plumbs the state through from head to tail, if that's what you're asking
07:17:18 <byorgey> mSSM: yes, replicateM n  means to run an action n times in sequence, and collect up the results in a list
07:17:37 <`nand`> mSSM: replicate is defined in terms of >>=, which is what does the ‘plumbing’ in State
07:17:47 <`nand`> it's all regular functions under the hood, there's really nothing special about evalState/runState
07:18:18 <`nand`> replicateM*
07:18:23 <byorgey> mSSM: so yes, stateful computation i sees the new state returned from the (i-1)st copy
07:18:30 <mSSM> `nand`: So I can imagine that `replicateM' just give me a huge chain of stateful computation `>>='d together?
07:18:38 <mauke> @src replicateM
07:18:38 <lambdabot> replicateM n x = sequence (replicate n x)
07:18:43 <mauke> @src sequence
07:18:43 <lambdabot> sequence []     = return []
07:18:43 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:18:43 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
07:18:51 <TylerE> Peaker: Doh, yea, I gues a lambda would work!
07:18:59 <`nand`> mSSM: yes, with the functions collecting the results in a list
07:20:33 <mSSM> `nand`: so the result would be a tuple ([a],[st]) ?
07:20:43 <`nand`> mSSM: ([a],st)
07:20:52 <`nand`> the state gets passed through, it doesn't get collected
07:21:58 <mSSM> jesus
07:22:02 <mSSM> My head bursts
07:22:24 <Botje> have some complimentary duct tape
07:22:25 <SuperNoeMan> so can anybody help with a single ocaml function?
07:22:33 <SuperNoeMan> #ocaml is very quiet right now...
07:22:47 <`nand`> you could try writing your ocaml function in Haskell :P
07:23:01 <ski> @quote paperwork
07:23:01 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
07:23:15 <flux> supernoeman, it can, nevertheles, help if you do actuall ask it on #ocaml :)
07:23:23 <emias> SuperNoeMan: You didn't even ask in #ocaml.
07:23:49 <mSSM> `nand`: So what if I don't actually care about all the [a], but only about the last a - would `evalState . replicateM_ n myStatefulComp $ st' help me with that?
07:24:00 <Peaker> edwardk, when is hackage getting some new lens goodness?
07:24:04 <Peaker> (3.8?)
07:24:07 <mSSM> `nand`: That is, I only want to chain a ton of stateful computations together.
07:24:14 <edwardk> Peaker: yesterday
07:24:24 <Peaker> oh, awesome! :)
07:24:25 <`nand`> mSSM: replicateM_ would throw away all the results, including the last one
07:24:27 <Peaker> missed it
07:24:33 <mSSM> `nand`: yes :( that's what I thought.
07:24:38 <edwardk> http://hackage.haskell.org/package/lens
07:24:41 <Botje> mSSM: you could do replicateM_ (n-1) foo >> foo
07:24:42 <`nand`> mSSM: (keep in mind the case where n=0)
07:24:59 <mSSM> Botje: smart
07:25:14 <Botje> mSSM: or last `liftM` replicateM n foo
07:25:19 <`nand`> fmap safeLast . replicateM n -- rough first approximation
07:25:37 <mSSM> Botje: that seems expensive
07:26:05 <Botje> eh, let the compiler worry about it :)
07:27:02 <mSSM> cool
07:27:04 <mSSM> thanks all!
07:27:43 <`nand`> ..of course, since you're in a State, you may as well keep the last output in the state..
07:40:46 <Gwern-away> @quote
07:40:47 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
07:45:36 * hackagebot cabal2nix 1.43 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.43 (PeterSimons)
07:46:58 <path[l]> why hello shachaf, yes I've recently moved to the bay area and I hadn't heard of bahaskell
07:47:38 <ikenov> If I have (Integer a) => a -> a, and I find that I need Int instead, I wish I could just do (Int a) => a -> a, rather than rewrite the type sig with Ints. Is there a GADT thing that would help?
07:48:28 <ikenov> I realize Integer is a class, etc etc. Just wondering if there's a more elegant way.
07:48:40 <`nand`> Integer isn't a class
07:48:48 <`nand`> you're probably thinking of Integral
07:48:59 <ikenov> Yes I mean Integral
07:49:07 <`nand`> you can do (a ~ Int)
07:49:44 <`nand`> :t (+) :: (a ~ Int) => a -> a -> a
07:49:45 <lambdabot>     Illegal equational constraint a ~ Int
07:49:45 <lambdabot>     (Use -XGADTs or -XTypeFamilies to permit this)
07:49:45 <lambdabot>     In an expression type signature: a ~ Int => a -> a -> a
07:49:49 <`nand`> bleh
07:50:15 <`nand`> well, you heard the error
07:51:39 <vamega> Hi
07:53:11 <ikenov> `nand`: thanks, that's it
07:53:12 <vamega> I'd like to get some possible feedback on implementing an ssh client in Haskell.
07:53:40 <`nand`> one piece of advice I would have is to use an existing library for the cryptography stuff
07:53:52 <vamega> I've never really written a large project in Haskell and was hoping to get some feedback on that?
07:54:15 <`nand`> do it using lenses and FRP and stuff
07:54:19 <`nand`> show the world :D
07:54:23 <vamega> `nand` - something like crpyto?
07:54:30 <`nand`> crpyto?
07:54:38 <vamega> The package?
07:54:39 <vamega> http://hackage.haskell.org/package/Crypto-4.2.5.1
07:55:02 <`nand`> I don't know what SSH uses internally, doesn't it use something like PGP though?
07:55:12 <fmap> > "crpyto" `elemIndex` permutations "crypto"
07:55:14 <lambdabot>   Just 14
07:56:12 <vamega> SSH supports a large number of algorithms
07:56:16 <Botje> vamega: steal the test suites in openssh if they exist
07:56:17 <Lethalman> `nand`, it uses rsa, no relationship with pgp that I know
07:56:22 <Lethalman> rsa or dsa or..
07:56:34 <vamega> I think I'd be targeting RSA.
07:56:37 <`nand`> okay, this is where my advice ends
07:56:38 <vamega> At least as a first effort.
07:56:51 <Lethalman> vamega, maybe you should use libssh to write an ssh client
07:56:55 <tac-tics> Is there a standard name for a two-tailed, infinite stream data type in Haskell?
07:57:03 <ikenov> As a general rule, it recursion considered "low-level" and that anything written with it should probably be refactored with HOFs?
07:57:04 <tac-tics> (or rather, in standard nomenclature?)
07:57:05 <Lethalman> @where libssh
07:57:05 <lambdabot> I know nothing about libssh.
07:57:08 <`nand`> Lethalman: well, I guess this is an exercise, so that may well defeat the point
07:57:10 <vamega> Botje - Thanks, that's a great idea. Didn't occur to me
07:57:18 <Botje> I just checked, they don't have any :/
07:57:33 <Lethalman> `nand`, ah in that sense
07:57:34 <`nand`> unless of course vamega is just wanting to create a nice front-end or something
07:57:56 <vamega> Not trying to create a frontend
07:58:01 <Botje> vamega: looks like you can steal tests from libssh
07:58:03 <vamega> I'd be doing this for credit at university
07:58:29 <`ramses> tac-tics: you could implement that using a Zipper
07:59:12 <tac-tics> yeah, what I'm thinking of is probably just a zipper in Haskell. thanks
08:04:27 <mysticc> Is -j option of cabal not stable yet?
08:04:38 <Yuu-chan> Where to find Prelude sources?
08:06:12 <jonkri> how do you manage multiple ghc installations? do you make install the builds into different directories, use environment variables to select the binary to use when building, or something else?
08:06:34 <Peaker> jonkri, cabal already does that for you
08:06:44 <Peaker> jonkri, cabal -wghc-7.6.1 install foo
08:06:56 <Peaker> jonkri, it uses different directories for packages for the different ghc versions
08:07:08 <jonkri> awesome, thanks Peaker
08:14:56 <Michae___> what are the rules behind requiring modules in other modules? When I put import above the module definition, I get "File name does not match module name \n saw main" When I put the import below the module definition, it just doesn't import what I'm requiring
08:16:52 <S11001001> Michae___: imports must go below module
08:19:13 <Michae___> S11001001, Thanks, but why is this file throwing errors: https://gist.github.com/4595959? The import statement is below the module definition
08:19:43 <Botje> Michae___: what does the module Agent look like?
08:20:18 <Michae___> Botje: like this: https://gist.github.com/4595971.
08:20:48 <blueonyx> hi, how do i stick my 'render' function into the $(hamletFile "blub.hamlet")?
08:20:55 <Botje> Michae___: okay, you also need to include the module that defines the Agent data type
08:21:14 <Botje> (or define it, of course)
08:21:50 <Michae___> Oh, thank you so much. To put that in the module definition I would just say module Agent(Agent()...)?
08:23:04 <Botje> if you export it like that I think you only export the type, not the constructor.
08:24:33 <Botje> I think it's just module Agent (Agent, ...)
08:24:38 <Botje> or Agent(...) if that fails.
08:25:11 <Saizan> it's Agent(..)
08:27:43 <blueonyx>  renderHtml $ $(hamletFile "blub.hamlet") renderUrl -- how to embed TH like that?
08:32:58 <Saizan> renderHtml $(hamletFile "blub.hamlet") renderUrl -- that's more likely what you want
08:33:19 <Saizan> but it depends on the type of the code generate by hamletFile
08:33:31 <Saizan> *generated
08:34:04 <blueonyx> renderHtml takes only 1 argument and hamletFile creates render
08:34:11 <blueonyx> Url-type -> Text
08:34:38 <blueonyx> ah works with parentheses
08:35:03 <blueonyx> renderHtml ($(hamletFile "blub.hamlet") renderUrl)
08:35:09 <yunxing> Newbie question: do we have any map function in haskell that can skip some elements?
08:35:10 <Saizan> ah, ok
08:35:29 <sipa> yunxing: filter?
08:35:32 <sipa> :t filter
08:35:34 <lambdabot> (a -> Bool) -> [a] -> [a]
08:36:10 <yunxing> 1 minute
08:36:13 <tac> > filter (\x -> x > 2) [0, 1,2,3,4,5]
08:36:15 <lambdabot>   [3,4,5]
08:38:01 <yunxing> ah make sense, thansk!
08:41:27 <ski> > mapMaybe (\x -> elemIndex x "crpyto") "python"
08:41:28 <lambdabot>   [2,3,4,5]
08:46:21 <Peaker> can cabal-defined tests/benchmarks import modules that are inside executables and not inside libraries?
08:47:47 <hpaste> marek__ pasted “IFELSE” at http://hpaste.org/81129
08:47:53 <marek__> what's wrong with ^^ code?
08:47:56 <yitz> Peaker: could be that works. but i think the technique is to define the package as both a library and as an executable so that the tests can import it.
08:48:43 <Peaker> yitz, well, it is already divided into the "general infrastructure" stuff as a library, and the "executable-specific" parts in the executable
08:48:57 <yitz> marek__: why do you think something is wrong?
08:49:14 <Peaker> maybe he's not using the DoIfThenElse extension?
08:49:21 <Peaker> (from H2010?)
08:49:29 <yitz> Peaker: i see. well maybe define the same stuff that is in the executable part as another library with a different name, and import that too?
08:49:36 <geekosaur> or buffering
08:49:43 <Peaker> yitz, I think you can only have one library section in a .cabal file
08:49:49 <hpaste> otters pasted “does this mean hackage is still down?” at http://hpaste.org/81130
08:49:50 <geekosaur> getChar is always suspicious for line buffering
08:49:51 <marek__> yitz: main.hs:7:4: parse error (possibly incorrect indentation)
08:50:01 <yitz> ah the else needs to be indented
08:50:02 <geekosaur> that would be DoAndIfThenElse
08:51:07 <marek__> yitz: thanks
08:51:08 <yitz> marek__: if .. then .. else .. is one calculation. if part of it is outdented to the "do" column, that ends the previous do item and starts a new one.
08:51:42 <yitz> marek__: as geekosaur points out, there is an extension that allows you to split it up, but in standard haskell that's what you need to do.
08:54:54 <yitz> geekosaur: i can't find DoIfThenElse in the GHC docs.
08:55:29 <yitz> geekosaur: MultiWayIf would certainly solve the problem though
08:55:52 <geekosaur> I suspect that subsumed the other one
08:56:02 <yitz> ah could be
08:56:55 <yitz> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#multi-way-if
09:06:07 <Peaker> would be nice if ghci replaced name ambiguity warnings with just executing the given command on all the names, when harmless (e.g: ":t ambiguousName")
09:07:30 <notdan> peaker, depends on what do you mean by "harmless"
09:07:49 <notdan> what about really computational-heavy expressions?
09:08:03 <ciaranm> obviously ghci should work out how expensive it is
09:08:04 <notdan> or even non-terminating ones
09:08:09 <ciaranm> and whether it terminates
09:08:13 <Peaker> notdan, it's just a "get type of"
09:08:24 <Peaker> the type is probably already inferred
09:08:28 <Peaker> just needs to be printed
09:08:37 <notdan> o, sorry, i missread
09:09:32 <monochrom> the problem explodes when you enter ":type amv1 + amf2 amv3", where each identifier has 3 disambiguations, therefore you get 27 answers. that may baffle you in practice
09:10:08 <monochrom> or perhaps 81 answers because + also has 3 disambiguations
09:10:21 <Peaker> it'd probably be a pretty rare occasion :)
09:10:37 <ciaranm> ah, the "what could possibly go wrong" approach to programming
09:10:41 <Peaker> and a 0-information error message is not that much better anyway
09:11:10 <geekosaur> also in theory typing an expression with UndecidableInstances turned on could be nonterminating
09:12:27 <Peaker> geekosaur, isn't that true anyway?
09:12:34 <Peaker> we're just enumerating over multiple names
09:12:42 <Peaker> you could manually type in those fully qualified names
09:13:07 <Sculptor> hi!
09:13:52 <geekosaur> Peaker, yes, but it'd be easier to hit by accident
09:14:26 <Peaker> why?
09:15:46 <tac> If I want to send email via haskell, can I use something like this? http://hackage.haskell.org/packages/archive/HaskellNet/0.2.1/doc/html/HaskellNet-SMTP.html
09:15:58 <tac> or do I need to go through sendmail still
09:16:13 * tac doesn't really understand email, so if that question doesn't make sense, please correct him.
09:16:14 <geekosaur> because you might not notice that one of the possible completions is something you really don't want to use there?
09:17:10 <geekosaur> tac, that should work if you know where you're sending mail.  sometimes the advantage of using sendmail is that sendmail knows what to talk to to actually send the mail (e.g. relay host)
09:17:24 <tac> hmm
09:17:28 <tac> thanks geekosaur
09:17:38 <Eduard_Munteanu> tac: instead of sendmail you can use stuff like ssmtp, it's a lot simpler
09:18:04 <tac> ah, a simpler option would be great
09:18:04 <tac> thanks
09:18:19 <geekosaur> tac: the real issue is you can't easily tell when you can get away with sending directly (althogh these days you usually can) and when you need to let something else deal.  but, there's no good answer to that one in general
09:18:29 <tac> yeah
09:18:38 <tac> I'm looking to be heavily abstracted from the process
09:18:54 <tac> I just want SendMail :: [Address] -> Text -> IO ()
09:20:38 * hackagebot cpphs 1.16 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.16 (MalcolmWallace)
09:25:54 <tac> Eduard_Munteanu: so ssmtp uses an existing email system to send your emails? (ie: it sends them through your gmail account?)
09:26:59 <Eduard_Munteanu> tac: yeah, it's intended as a system MTA replacement that relays mail through another server.
09:27:24 <tac> that will work for what I want
09:27:25 <tac> ty again
09:28:06 <Eduard_Munteanu> Sure, np.
09:28:28 <tac> except I will need a new gmail account. No way in hell am I putting my email password into plaintext anything :P
09:29:05 <Clint> msmtp may be nicer depending on your needs
09:29:40 <Peaker> SPECIALIZE pragma used on an imported name generates an "orphan rule" warning.. why is there a warning for that?
09:29:50 <Peaker> I need to specialize some generic code from a different module for the specific types that I use
09:31:35 <srhb> tac: Wouldn't you be able to use their per-app passwords for that?
09:31:46 <srhb> Maybe not, actually.
09:31:48 <tac> I didn't know such a thing existed
09:32:06 <tac> I really don't want to futz with email. I just want to send myself reminders via my IRC bot :)
09:45:39 * hackagebot hakyll 4.1.2.1 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.1.2.1 (JasperVanDerJeugt)
09:52:17 <otters> is there any documentation for lens-3.8
09:52:17 <lambdabot> otters: You have 3 new messages. '/msg lambdabot @messages' to read them.
09:54:07 <fmap> otters: http://ekmett.github.com/lens/frames.html
10:04:48 <tac> Eduard_Munteanu: thanks again. Ssmtp is working beautifully.
10:07:01 <Peaker> downloading ghc at 50K/sec or so.. then restarting the download -> 1MB/sec. ??
10:07:21 <otters> how should I remove only the first item from a list that matches a predicate
10:07:53 <Peaker> @hoogle delete
10:07:53 <lambdabot> Data.HashTable delete :: HashTable key val -> key -> IO ()
10:07:53 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
10:07:53 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
10:08:20 <otters> oh
10:08:22 <Peaker> deleteBy is somewhat silly
10:08:36 <Peaker> it doesn't actually help you (at least if you try to use it in a sane way)
10:08:36 <tac> Peaker: why do you say that?
10:08:47 <otters> a -> a -> Bool??
10:08:48 <Peaker> tac, because it takes the first 2 params just to apply one to the other
10:08:55 <Peaker> @src deleteBy
10:08:55 <lambdabot> deleteBy eq x []        = []
10:08:55 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
10:09:11 <Peaker> it should have just taken a predicate and done what otters wanted directly
10:09:17 <Peaker> > break (>5) [1..10]
10:09:18 <tac> ah
10:09:19 <lambdabot>   ([1,2,3,4,5],[6,7,8,9,10])
10:09:41 <otters> yeah, who designed that functio
10:09:43 <otters> n
10:09:45 <otters> that is bizarre
10:10:07 <Peaker> > let deleteFirst p = uncurry (++) . second tail . break p in deleteFirst (>5) [1..10]
10:10:09 <lambdabot>   [1,2,3,4,5,7,8,9,10]
10:11:02 <Peaker> > let deleteFirst p xs = start++end where (start, x:end) = break p xs in deleteFirst (>5) [1..10]
10:11:04 <lambdabot>   [1,2,3,4,5,7,8,9,10]
10:11:10 <Peaker> The latter is for humans
10:11:30 <Peaker> and for less imports :)
10:13:58 <Peaker> why does the RTS define its own int types and not re-use <stdint.h> ?
10:40:43 * hackagebot blink1 0.3 - Control library for blink(1) LED from ThingM  http://hackage.haskell.org/package/blink1-0.3 (DylanSimon)
10:49:14 <burbul> @unmtl StateT RobotState (LogicT (ReaderT Library Identity))
10:49:14 <lambdabot> Plugin `unmtl' failed with: `StateT RobotState (LogicT (ReaderT Library Identity))' is not applied to enough arguments, giving `/\A. RobotState -> LogicT (ReaderT Library Identity) (A, RobotState)'
10:49:17 <otters> does lens provide a facility to update all list elements that match a predicate
10:49:32 <burbul> @unmtl StateT RobotState (LogicT (ReaderT Library Identity)) a
10:49:32 <lambdabot> RobotState -> LogicT (ReaderT Library Identity) (a, RobotState)
10:50:00 <burbul> Why isn't that unwrapping all the way?
10:50:20 <burbul> @unmtl StateT RobotState (ListT (ReaderT Library Identity)) a
10:50:20 <lambdabot> RobotState -> Library -> [(a, RobotState)]
10:50:24 <burbul> ahhh...
10:50:25 <ski> it probably doesn't know what `LogicT' is
10:50:30 <burbul> yup
10:53:01 <fmap> > [1..10] & traverse . filtered even %~ (+2)
10:53:03 <lambdabot>   [1,4,3,6,5,8,7,10,9,12]
10:53:07 <fmap> otters: ^
10:53:15 <otters> cool
10:53:55 <b_work> "Introduces Lists and Tuples, the most important data structures in Haskell." -- http://shuklan.com/haskell/
10:55:51 <fmap> otters: note that `filtered' is only legal if traversal doesn't affect a predicate on target
10:55:58 <monochrom> haha, the most important? I would only say the most basic, as in the easiest
10:55:59 <otters> okay
10:56:13 <lispy_> and common
10:56:32 <monochrom> I love tuple and list, they are so important? :)
11:10:40 <b_work> that course gives the example `Prelude> let royal p = if p>9000 then True else False`
11:11:22 <ikenov> Is there name for the pattern of folding pairs, where you start with ([], data) and wind up with (transformedData, []) ? Each fold grabs a chunk of data and leaves behind the remaining data.
11:12:20 <ski> example ?
11:13:51 <b_work> http://shuklan.com/haskell/lec02.html#/0/5
11:14:16 <Peaker> b_work, hlint will get that straight
11:15:09 <ski> "Everything is a function" !?
11:15:26 <ikenov> ski: http://hpaste.org/81133 I had wished the fold was cleaner, but the recursive one looks better to me. Maybe there is a better fold pattern or HOF or something.
11:15:45 * hackagebot aws-sdk 0.9.2.1 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.9.2.1 (YusukeNomura)
11:19:00 <b_work> good intentions are a ho
11:19:21 <b_work> the people who put time into educating are clueless, and the clever people are too busy to educate
11:19:36 <srhb> b_work: Generalize much, do we.
11:20:02 <b_work> I confess
11:20:57 <b_work> this channel is proof of the opposite, you could say
11:21:44 <monochrom> haha, are you hunting down dysfunctional tutorials? :)
11:22:01 <ski> > mapAccumL (\as size -> swap (splitAt size as)) "abcdefghij" [0,1,2,3]  -- ikenov, how about this one ?
11:22:02 <b_> not really
11:22:02 <lambdabot> b_: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:22:04 <lambdabot>   ("ghij",["","a","bc","def"])
11:22:15 <Nisstyre-laptop> Is this a good way of writing a generalized permutations function? https://gist.github.com/4597501
11:22:19 <Nisstyre-laptop> Is there a better base case?
11:22:54 <Nisstyre-laptop> (it works at least)
11:23:43 <srhb> b_: Anyway, you should shoot a comments on github to the author of the slides, I'm sure that's more productive.
11:23:55 <b_> monochrom: the problem with most tutorials is that they are written right after what the writer perceives as a Eureka moment, or way too late when they forgot what ignorance was like.
11:24:04 <b_> srhb I sent a mail
11:24:35 <ikenov> ski: thanks, that's the kind of thing I was looking for
11:24:51 <Nisstyre-laptop> b_: there are some people who are brilliant but also great teachers
11:24:56 <Nisstyre-laptop> I admit they are far and few between
11:25:02 <b_> yeah
11:25:20 <ikenov> I happened to have in mind the converse, a monad that helps you extract from a list. I'll make it my exercise.
11:25:45 * hackagebot hs-excelx 0.5.0.0 - HS-Excelx provides basic read-only access to Excel 2007 and 2010 documents in XLSX format.  http://hackage.haskell.org/package/hs-excelx-0.5.0.0 (MarkBaran)
11:25:55 <Nisstyre-laptop> b_: I get that feeling reading Knuth's stuff
11:29:52 <otters> I still can't upload to hackage
11:30:09 <otters> oh, wait, I know why
11:30:15 <otters> I was using the luite mirror instead of actual hackage
11:30:17 <ski> ikenov : .. like a parser ?
11:34:36 <TylerE> Trying to figure out the best way to handle something. I have a list of strings, some of which start with '>'. I'd like to have a list of lists, with each sublist starting with a line starting with '>'.  eg.   foo ['>a','b','c','>e','f'] -> [['>a','b','c'],['>e','f']]
11:34:46 <ikenov> ski: yes I suppose even a simple de-accumulator works out to be a kind of parser.
11:35:45 * hackagebot kevin 0.4 - a dAmn  IRC proxy  http://hackage.haskell.org/package/kevin-0.4 (JoelTaylor)
11:38:08 <Nisstyre-laptop> TylerE: map (\(x:xs) -> case x of '>' -> xs ; _ -> '>':x:xs) xs
11:38:12 <Nisstyre-laptop> is that what you want approximately?
11:38:34 <skuggi> TylerE: repeatedly calling partition would work.
11:39:00 <Nisstyre-laptop> oh wait I misread your question
11:39:01 <Nisstyre-laptop> sorry
11:39:04 <TylerE> actually looks like what I want is Data.List.splitWhen
11:39:09 <TylerE> which I just discovered
11:39:15 <Nisstyre-laptop> yeah splitWhen will do it
11:40:17 <skuggi> never seen that function. hoogle doesn't seem to know about it
11:41:16 <byorgey> splitWhen by itself will drop the delimiters though.
11:41:27 <byorgey> i.e. it would just give you  [b,c], [f]
11:41:28 <TylerE> byorgey: yes, that's what I just discovered
11:41:36 <byorgey> however, this works:
11:41:47 <byorgey> > (Data.List.Split.split . dropBlanks . keepDelimsL $ whenElt (">" `isPrefixOf`)) [">a", "b", "c", ">d", "e"]
11:41:49 <lambdabot>   [[">a","b","c"],[">d","e"]]
11:42:19 <byorgey> You don't need the Data.List.Split part in front of split, I just used that because lambdabot also has another 'split' imported from somewhere else
11:42:42 <TylerE> awesome
11:42:44 <TylerE> yep that does it
11:42:58 <byorgey> great =)
11:43:15 <TylerE> Working on learning haskell by working through the rosalind problems (http://rosalind.info/problems/gc/)
11:43:26 <TylerE> so I'm kinda of figuring out how to do things as I need to
11:44:01 <skuggi> oh, partition doesn't do at all what i thought it did
11:44:17 <byorgey> TylerE: cool
11:48:12 <ski> > replicateM 3 grab `runAffine` "abcde" :: [(String,String)]
11:48:14 <lambdabot>   [("abc","de")]
11:48:19 <ski> > replicateM 3 pick `evalAffine` "abcde" :: [String]
11:48:22 <lambdabot>   ["abc","abd","abe","acd","ace","ade","bcd","bce","bde","cde"]
11:48:23 <ski> > replicateM 3 choose `evalAffine` "abcd" :: [String]
11:48:26 <lambdabot>   ["abc","abd","acb","acd","adb","adc","bac","bad","bca","bcd","bda","bdc","c...
11:49:15 <aluink> anyone here ever use ZoomCache?
11:49:38 <mauke> anyone here ever use Zombo.Com?
11:49:58 <TylerE> You can do _everything_ at Zombo.com
11:50:05 <acowley> It's my IRC client
11:50:17 <Canar> zombo.com introduced me to my wife
11:50:38 * aluink doesn't get the joke
11:50:46 * hackagebot linear 0.9.2 - Linear Algebra  http://hackage.haskell.org/package/linear-0.9.2 (AnthonyCowley)
11:50:50 <TylerE> Ok, next dumb newbie question - so i have a do block where I'm doing some IO, and end up with a pure value inside the do. How do I "return" one of those values outside of the monad, so it be used in pure code?
11:51:18 <mauke> TylerE: "no"
11:51:23 <ciaranm> what do lenses have to do with finite state automata?
11:51:27 <peddie> @faq can haskell do everything zombo.com can do?
11:51:27 <lambdabot> The answer is: Yes! Haskell can do that.
11:51:52 <mauke> TylerE: you can't leave IO. you should punch your pure code into IO instead
11:51:53 <TylerE> mauke: So how do I write any sort of code that does IO without just doing the whole thing in a giant do block?
11:52:07 <ski> TylerE : what you can do is pass that value to some non-`IO'-function, called from inside the `IO'-action
11:52:11 <mauke> TylerE: with >>= and return, ultimately
11:52:23 <mauke> or fmap
11:52:35 <edwardk> ciaranm: not a whole lot
11:52:54 <hiptobecubic> i forgot how great zombo.com is
11:53:03 <ciaranm> edwardk: are you sure?
11:53:17 <Nisstyre-laptop> hiptobecubic: zombocom is awesome
11:53:20 <Lethalman> does linear hackage support NxN matrix? I can only see fixed size matrix
11:53:21 <Lethalman> ?
11:53:38 <edwardk> ciaranm: no. feel free to prove me wrong ;)
11:53:50 <ski> TylerE : it's also possible to invoke other `IO'-actions from inside the `do'-expression
11:54:15 <ski> TylerE : any particular example you're pondering atm ?
11:54:23 <TylerE> actually, I think I get it now
11:54:34 <TylerE> I was sorta temporarily forgetting that my main funciton is _also_ in IO
11:54:37 <aluink> you could use unsafePerformIO, but that's highly discouraged. I'm prolly going to get shot just for mentioning it
11:54:42 <TylerE> so returning an IO isn't really a problem for me
11:54:45 <ciaranm> model checking an FSA looks an awful lot like some kind of F-algebra-with-a-co-in-it-somewhere
11:54:52 <kennyd> TylerE main isn’t a function actually. it’s an IO action
11:55:25 <TylerE> this is a bit of a rough change for me…I'm so used to building small support functions first, and then building "out" instead of being a bit forced to write from the top down
11:55:25 <ski> aluink : yes, it's not going to help to mention that at this point
11:55:49 <mauke> TylerE: why can't you still do that?
11:56:12 <aluink> ski: I was late the party :(
11:56:15 <ski> TylerE : you can test stuff in the interactor, before writing `main'
11:56:20 <TylerE> I'm used to a very interactive REPL-driven environment where often the calling code doesn't exist at the point where I'm testing stuff
11:56:22 <`ramses> kennyd: main is still a function, it just does not take parameters
11:56:31 <mauke> TylerE: ... and?
11:56:45 <mauke> `ramses: that makes no sense
11:56:48 <kennyd> `ramses no it isn’t
11:56:48 <simpson> Is there a Gaussian weighted sampler for random numbers, or do I get to do it myself?
11:56:58 <frerich_> `ramses: That's not really correct.
11:57:04 <`ramses> why not?
11:57:07 <TylerE> well, the code I'm writing now deals with args from getArgs and a few other things so just importing my module into ghci isn't 100% representative of what I'm trying to do
11:57:08 <Nisstyre-laptop> simpson: the random library has a function that will pick an element using weights
11:57:14 <mauke> `ramses: that's like saying "hello" is still a number, you just can't do arithmetic with it
11:57:24 <frerich_> `ramses: In Haskell, only the stuff which has "->" in it's signature is a function.
11:57:29 <ciaranm> TylerE: you just need to split your code up better
11:57:34 <Nisstyre-laptop> simpson: just create your own gaussian distribution
11:57:44 <mauke> @hoogle withArgs
11:57:44 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
11:57:48 <Nisstyre-laptop> then you make a list of tuples, etc...
11:57:56 <simpson> Nisstyre-laptop: I'm not seeing the function that will use a list of weights.
11:58:01 <melvin-> ramses all haskell functions take one argument
11:58:03 <Ralith> simpson: https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform
11:58:24 <`ramses> what would you guys call main then?
11:58:29 <Nisstyre-laptop> simpson: MR.fromList
11:58:32 <simpson> Ralith: Yes, just confirming that that's what I have to do.
11:58:35 <mauke> `ramses: an IO action
11:58:38 <simpson> Nisstyre-laptop: Oh, monad-random.
11:58:41 <Nisstyre-laptop> yes
11:58:58 <Ralith> simpson: I dunno about *have* to, but it's sufficiently easy to that I wouldn't worry about it.
11:58:59 <melvin-> ramses look at it's type.. main :: IO ()
11:59:10 <Nisstyre-laptop> sorry, I guess that's not the normal random module
11:59:15 <Nisstyre-laptop> but yeah, you can use that
12:01:21 * ski hands aluink a `⊸'
12:09:57 <chailon> I'm using Cabal and HUnit. Where in the directory structure should I put my tests? I don't want them compiled into the final binary, but I'm testing an application, not a library, so they seem to have to be in the same src directory. Any ideas?
12:10:46 * hackagebot hs-excelx 0.5.1.0 - HS-Excelx provides basic read-only access to Excel 2007 and 2010 documents in XLSX format.  http://hackage.haskell.org/package/hs-excelx-0.5.1.0 (MarkBaran)
12:11:36 <Clint> chailon: often people use a test/ or tests/ directory
12:11:46 <acowley> chailon: MyPackage/src/Data/MyPackage.hs, MyPackage/tests/tests.hs
12:12:15 <aavogt> in the  cabal file you can put   hs-source-dirs: src tests/
12:12:35 <Taneb> In GHC 7.8, does TypeOperators behave like in 7.6 or 7.4?
12:13:01 <chailon> aavogt: didn't know i coudl do that thanks
12:13:08 <acowley> You only want src included in your test suite if you need to test an unexported module
12:13:27 <acowley> most of the time, you specifically want to *not* put src in the hs-source-dirs of your test-suite so you can depend on the compiled library
12:13:34 <acowley> this saves you a compilation of your library code
12:25:52 <johnbaptham> please do how i learn to write in haskell language?
12:26:00 <Clint> one function at a time
12:26:23 <byorgey> @where lyah
12:26:23 <lambdabot> http://www.learnyouahaskell.com/
12:26:33 <byorgey> johnbaptham: ^^^ that's a good place to start
12:27:08 <johnbaptham> thank you
12:30:47 * hackagebot sizes 2.1.1 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-2.1.1 (JohnWiegley)
12:33:31 <frerich_> Is there something like a 'pipe' type which builds on top of TChan but rather exposes the chan as two values (a source and a sink) so that I can use uni-directional chains with more type safety? I think I could whip it up myself, but it doesn't seem that crazy to me, so maybe there is something like this already?
12:34:16 <frerich_> I'm thinking of something like 'makePipe :: TChan a -> (TSource a, TSink a)' and then I could pass the source handle to the consumer threads and keep the sink handle to the producer thread.
12:34:27 <frerich_> (and you can only read from a source and only write to a sink)
12:34:48 <Choko_> like a queue!
12:35:08 <Eduard_Munteanu> You can dup channels.
12:35:13 <frerich_> Well yeah, like a TChan, except that with a TChan all parties who have a handle to the chan can read *and* write
12:35:19 <Eduard_Munteanu> But that doesn't make them unidirectional.
12:35:46 <Eduard_Munteanu> Actually forget that, probably irrelevant.
12:36:28 <Choko_> probably you could look at conduits
12:36:56 <frerich_> Good call! http://hackage.haskell.org/package/stm-conduit sounds exactly like what I described
12:37:59 <frerich_> Thanks :-)
12:39:45 <frerich_> Follow-up question (since this is actually what triggered my interest in restricting what you can do with a chan): are there some best practices or tips for how to debug or avoid 'thread blocked indefinitely in an STM transaction' errors at runtime?
12:40:22 <frerich_> I can reproduce the issue very well, and right now I trace it down by commenting code out and seeing whether the error still occurs. I wish I knew *which* transaction this is.
12:40:36 <deggis> frerich_: i guess it's worth mentioning that there's also pipes http://hackage.haskell.org/package/pipes-3.1.0 some prefer pipes over conduits
12:40:57 <Axman6> forkChan :: (Sink a -> IO ()) -> IO (Source a) -- to be super sure there's only one reader
12:40:58 <deggis> i'm not familiar with either so i'll just pass the link :)
12:41:08 <Axman6> well, unless they pass the sink to another thread
12:41:20 <Choko_> I didn't know there was a STM channel type with close semantics, that's really useful!
12:43:06 <frerich_> deggis: The pipes package went whoosh above my head.
12:45:30 <parcs> :t zipWith3
12:45:32 <lambdabot> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
12:46:02 <deggis> frerich_: went for me too at first, but this was really useful http://hackage.haskell.org/packages/archive/pipes/3.1.0/doc/html/Control-Proxy-Tutorial.html
12:46:22 <parcs> > let facs = 1 : 1 : zipWith (\a b -> a + a^2/b) facs (tail facs) in facs
12:46:24 <lambdabot>   [1.0,1.0,2.0,1.5,4.666666666666666,1.9821428571428572,15.653653653653649,2....
12:47:11 <parcs> > let facs = 1 : 1 : zipWith (\a b -> a + a^2/b) (tail facs) facs in facs
12:47:13 <lambdabot>   [1.0,1.0,2.0,6.0,24.0,120.0,720.0,5040.0,40320.0,362880.0,3628800.0,3.99168...
12:47:16 <parcs> :)
12:48:00 <ion> @oeis 1 1 2 1.5 4.67 1.98 15.65
12:48:00 <lambdabot>  Sequence not found.
12:48:22 <ion> @oers 1 1 2 1.5 4.67 1.98 15.65
12:48:22 <lambdabot>  Sequence not found.
12:49:20 <parcs> i have an even better one
12:50:13 * geekosaur wonders whether those make sense with oeIs
12:52:40 <parcs> > let squared_facs = 1 : 1 : zipWith (\a b c -> (2*c-1 + a^2)/b) (tail facs) facs [2..] in squared_facs
12:52:41 <lambdabot>   Not in scope: `facs'Not in scope: `facs'
12:52:48 <parcs> > let facs = 1 : 1 : zipWith (\a b c -> (2*c-1 + a^2)/b) (tail facs) facs [2..] in facs
12:52:49 <lambdabot>   The function `GHC.List.zipWith' is applied to four arguments,
12:52:49 <lambdabot>  but its type...
12:53:44 <parcs> never mind
12:54:30 <parcs> > let facs = 1 : 1 : zipWith3 (\a b c -> a*(2*c-1 + a`div`b)) (tail facs) facs [2..] in facs
12:54:32 <lambdabot>   [1,1,4,36,576,14400,518400,25401600,1625702400,131681894400,13168189440000,...
12:54:38 <parcs> @oeis 1 1 4 36 576
12:54:40 <lambdabot>  (n!)^2.
12:54:40 <lambdabot>  [1,1,4,36,576,14400,518400,25401600,1625702400,131681894400,13168189440000,1...
13:01:11 <parcs> > let facs = 1 : 1 : 4 : 36 : zipWith4 (\a b c d -> a*(3*a`div`b - 3*b`div`c + c`div`d)) (drop 3 facs) (drop 2 facs) (tail facs) facs in facs
13:01:13 <lambdabot>   [1,1,4,36,576,14400,518400,25401600,1625702400,131681894400,13168189440000,...
13:02:04 <parcs> recurrence relations are magical
13:04:52 <Fuuzetsu> @src mod
13:04:52 <lambdabot> Source not found. My brain just exploded
13:18:12 <parcs> > let squares = 0:1:4 : zipWith3 (\a b c -> 3*a - 3*b + c) (drop 2 squares) (tail squares) squares in squares
13:18:14 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
13:29:37 <spjt> This is probably a stupid question, but I can't google it: What does "in" do?
13:29:55 <ciaranm> on its own, nothing
13:30:08 <ciaranm> it comes as part of a let statement
13:30:14 <ciaranm> > let x = 5 in x * 2
13:30:16 <lambdabot>   10
13:30:22 <spjt> e.g. let (x,y) = (1,2) in x
13:30:25 <ciaranm> > x * 2 where x = 5
13:30:27 <lambdabot>   <hint>:1:7: parse error on input `where'
13:30:56 <geekosaur> spjt, if your only awareness of let is part of a "do" construct (including the one that ghci's promot lives in) then you've been seeing a shorthand for of let ... in
13:31:06 <geekosaur> *shorthand form of
13:32:27 <spjt> I guess the problem is maybe just that it looks like it's saying let (x,y) = (1,2) in x, as in = having a right and left side
13:32:29 <awestroke> is there a way to get a default value for a type? I have a generic type with an Ord constraint, and I need to create a value of that type in a function
13:33:14 <ciaranm> awestroke: there is a typeclass
13:33:20 <ciaranm> or two
13:33:51 <ciaranm> either Monoid or Default
13:34:11 <spjt> I'm sure my notation is wrong, but does let <a> in <b> basically create a scope for b that contains a?
13:34:27 <ciaranm> spjt: i suppose you could say that
13:34:42 <ciaranm> spjt: you'd be kind of wrong, though...
13:35:00 <ciaranm> > let x = fix (1:) in 2 + 2
13:35:02 <lambdabot>   4
13:36:30 <spjt> I suppose it's good enough at this point
13:36:42 <spjt> thanks
13:40:48 * hackagebot fay 0.12.0.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.12.0.0 (ChrisDone)
13:43:19 <mm_freak_> is the full (i.e. complex) riemann zeta function defined in some library, preferably using some high precision floating point type?
13:44:02 <ion> “high precision” “floating point type”
13:44:34 <mm_freak_> some floating point type with a large mantissa
13:44:37 <ciaranm> the zeta hypothesis is false if you work over IEEE754 rather than the reals
13:44:39 <mm_freak_> that's high precision
13:44:54 <mm_freak_> ciaranm: i know…  that's not what i need it for
13:45:00 <ion> Yeah, i was just joking. Naturally there’s no theoretical limit on how much precision you can have with a floating point type.
13:45:19 <ciaranm> if you're looking for precision, though, then floats aren't the way to go
13:46:32 <mm_freak_> i need floats, because the zeta function is too unstable for fixed-point types
13:46:46 <ciaranm> that's what we call a false dichotomy
13:46:46 <mm_freak_> btw, i'm happy with floats with another base than 2
13:53:52 <tac> Bool is the type of false dichotomies in Haskell
13:55:41 <ski> @where+ boolean-blindness http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
13:55:41 <lambdabot> It is stored.
13:56:17 <tac> I loved that article
13:56:39 <tac> It's the thing that taught me the difference between Dec P and Bool
13:57:41 <ciaranm> quick! how many functions Bool -> Bool are there?
13:58:03 <ion> unsafeCoerce, id, not, …
13:58:48 <aristid> ciaranm: all, or just the total ones?
13:59:02 <ciaranm> aristid: all the ones not involving unsafe*
13:59:21 <ski> "How many is two?" by Andrej Bauer in 2005-05-16 at <http://math.andrej.com/2005/05/16/how-many-is-two/> is also fun
13:59:26 <tac> ciaranm: I did this exercise with a friend yesterday
13:59:38 <ion> There there, it was just a bad dream. There’s no such thing as two.
13:59:52 <tac> hehe
14:00:26 <aristid> ciaranm: less than 27.
14:00:34 <ciaranm> the question is whether you count _|_ and const _|_
14:00:40 <ciaranm> as being different
14:00:44 <shachaf> Of course you do.
14:00:59 <aristid> shachaf: why of course?
14:01:19 <ciaranm> are we talking about functions, or about values of the function type?
14:01:19 <shachaf> Because these are Haskell functions, and the Haskell report specifies they're different.
14:01:37 <shachaf> In Haskell "function" means something of type _ -> _
14:01:58 <ski> .. one can also talk about a type of semi-decidable propositions
14:02:05 <ski> (`Sierpinski')
14:05:34 <binroot> Haskell Lecture 2 is live! http://shuklan.com/haskell
14:06:09 <feliperosa> Is there any disadvantage in using Monad instead of Applicative? (I'm reading a tutorial that a Applicative functor is something in between Functor and Monad)
14:06:19 <ciaranm> some things are not monads
14:06:31 <feliperosa> Oh, right
14:06:54 <feliperosa> I thought it was just for the fact that you wouldn't need to implement so many things.
14:07:01 <ion> The Applicative interface may also be more convenient for some things.
14:07:39 <ion> Are you thinking from the point of view of the implementor or the user of something that has Applicative and Monad instances?
14:08:40 <feliperosa> I'm think about the way you reason about something
14:09:10 <ion> Needing to “implement so many things” doesn’t really apply from the user’s point of view.
14:09:28 <feliperosa> yeah
14:10:35 <feliperosa> I think I thought something like: If I can define something as a Monad I could also define it as a Applicative, but one has more functionality than the other
14:10:56 <feliperosa> writing it down it seems to me I was making little or no sense, hehe
14:11:10 <ciaranm> no, you're along the right lines
14:11:20 <ion> You should implement an Applicative instance for anything for which you implement a Monad instance. You can always choose to implement the former as: instance Applicative Foo where pure = return; (<*>) = ap;
14:11:28 <hughfdjackson> why doesn't !! use Maybe?
14:11:35 <ion> When using something, just use whichever API is the more convenient for what you’re doing.
14:11:45 <hughfdjackson> was Maybe not a thing when the prelude was written??
14:11:53 <hughfdjackson> s/??/?/
14:11:56 <Hermit> I'm having a problem with import. I have both mtl and monads-tf installed, which implement almost the same things. When importing, ghc gets confused as to which to import from. How can I make one of the two the default choice?
14:12:24 <mizu_no_oto> Are there any good textbooks in Haskell meant to teach someone who hasn't done *any* programming?
14:12:41 <ion> hermit: “ghc-pkg hide package” IIRC
14:12:41 <Mortchek> hughfdjackson, I've heard an answer along the lines of "to make it easier for newbies".
14:12:43 <ciaranm> mizu_no_oto: LYAH is probably ok if you've done a bit of maths
14:12:52 <mizu_no_oto> Something like a Haskell version of How To Design Programs or something
14:12:53 * Hermit checks
14:12:57 <ciaranm> mizu_no_oto: there's also Bird and Wadler, which is fairly horrible
14:12:59 <hughfdjackson> Mortchek: :/ i hope that's not the case
14:13:13 <hpc> lyah might have a few assumptions of programming that can be met by a bit of wikipedia / tech savvy
14:13:13 <geekosaur> well, arguably using !! means you're using the wrong data structure
14:13:30 <feliperosa> ion: I see, so it's more convinient for the library user to have both instances
14:13:42 <hpc> but i don't think it requires prior experience to get benefit from
14:13:47 <feliperosa> ion: If one could
14:13:47 <ion> mortchek: The reasoning for e.g. map being not fmap is that AFAIU, but i’m not sure the reason for (!!) being partial is that.
14:13:48 <hughfdjackson> geekosaur: this is the javascript way of thinking
14:13:51 <hughfdjackson> hehe
14:14:04 <Hermit> ion: that did it, thanks
14:14:18 <ion> feliperosa: Yeah, better provide an instance for all “standard” things you can implement.
14:14:19 <hughfdjackson> (so long as you know how to avoid the pitfalls, then you're fine; to hell with the confusing parts of the language)
14:14:44 <feliperosa> ion: Alright, thank you very much
14:14:49 <hughfdjackson> geekosaur: what list-like structure is preferable?
14:14:59 <geekosaur> there are perodic arguments on haskell-cafe about that :)
14:15:29 <ion> hughfdjackson: Depends on what you’re doing exactly.
14:15:38 <osfameron> as a beginner, haskell's error messages make no sense already, so making them harder probably won't matter that much ;-P
14:15:40 <geekosaur> hughfdjackson, [] is a singly-linked list, not a vector or array; (!!) is fairly expensive.  Vector is rather preferred if you really intend indexed access to elements
14:15:51 <hughfdjackson> geekosaur: :) that makes sense
14:16:48 <geekosaur> [] captures iteration as a data structure; it's designed to be stepped through, not indexed
14:17:05 <geekosaur> you *can* index it but you should really consider if that's what you want to do
14:17:08 <hughfdjackson> geekosaur: makes sense; especially in context of ranges and infinite lists
14:18:02 <hughfdjackson> ion: what are the common choices?
14:18:44 <Hafydd> Oh, it's High "File Descriptor" Jackson again.
14:18:48 <Hafydd> *Hugh
14:18:49 <hughfdjackson> Hafydd: it happens
14:18:51 <hughfdjackson> :D
14:19:11 <frerich_> I was just made aware of the strict-concurrency package. This made me wonder - how can I tell that I do want more strictness in my concurrent code?
14:19:35 <b_faulkner> > scanl1 (+) [0..10] == [sum [0..x] | x <- [0..10]]
14:19:36 <lambdabot>   True
14:23:48 <ski> @check \ns -> scanl (+) 0 ns == [sum ns | ns <- inits ns]
14:23:49 <lambdabot>   Not in scope: `myquickcheck'
14:23:55 <ski> hmpf
14:24:53 <marekw2143_home> can I use "case of" inside "do" ?
14:25:04 <b_faulkner> scanl1 f == map (foldl1 f . enumFromTo 0)
14:25:05 <b_faulkner> rite?
14:25:08 <mauke> marekw2143_home: sure
14:25:09 <ciaranm> marekw2143_home: yes
14:25:41 <b_faulkner> for f: Num a => a -> a -> a
14:28:10 <patlondon> > pl \a b -> = bar $ baz a b
14:28:12 <lambdabot>   <hint>:1:4: parse error on input `\'
14:28:20 <patlondon> > pl \a b -> bar $ baz a b
14:28:21 <lambdabot>   <hint>:1:4: parse error on input `\'
14:28:29 <b_faulkner> @pf \a b -> = bar $ baz a b
14:28:29 <lambdabot> Maybe you meant: bf pl
14:28:33 <b_faulkner> @pl \a b -> = bar $ baz a b
14:28:33 <lambdabot> (line 1, column 9):
14:28:33 <lambdabot> unexpected "="
14:28:33 <lambdabot> expecting lambda abstraction or expression
14:28:39 <b_faulkner> @pl \a b -> bar $ baz a b
14:28:39 <lambdabot> (bar .) . baz
14:29:04 <patlondon> Cheers, but what on earth does (bar .) mean?
14:29:25 <otters> it means the same as (.) bar
14:29:59 <b_faulkner> @pl let (.:) = (.) . (.) in bar .: baz
14:29:59 <lambdabot> (line 1, column 5):
14:29:59 <lambdabot> unexpected "("
14:29:59 <lambdabot> expecting "()", natural, identifier or "in"
14:30:09 <hpc> in general, infix operators in haskell can be applied as "sections"
14:30:15 <patlondon> I have no idea what this means now. I don't get why     bar . baz    isn't enough?
14:30:34 <hpc> baz wants two arguments
14:30:43 <mauke> patlondon: because (f . g) x y = f (g x) y
14:30:52 <hpc> (bar . baz) a b = (bar (baz a)) b
14:30:52 <mauke> but you want f (g x y)
14:31:23 <patlondon> mauke: ok, how does the extra . solve it - i can't picture what the sectioned operator is doing
14:31:40 <shachaf> patlondon: Expand it out by hand, like mauke did.
14:31:56 <mauke> ((f .) . g) x y = ((f .) (g x)) y = (f . g x) y = f (g x y)
14:32:04 <b_faulkner> it composes bar and baz in such a way that it takes 2 arguments
14:32:07 <hpc> patlondon: ... what shachaf said; you'll learn quite a bit from it
14:32:24 <mauke> </spoilers>
14:32:28 <shachaf> b_faulkner: I think patlondon is asking how, not what. :-)
14:32:43 <shachaf> Anyway, being able to do reductions like this by hand is very important/useful.
14:32:45 <b_faulkner> the how was being provided
14:32:49 <patlondon> i guess the second argument is sort of 'nested' isn't it, and i have to do something to get than one level deeper
14:32:59 <hpc> yes
14:33:20 <shachaf> You can also think about it from the SEC perspective.
14:33:35 <shachaf> ((.) f) applies f to the result of a function.
14:33:51 <shachaf> So (.) ((.) f) applies f to the result of the result.
14:34:15 <shachaf> In the same way that map (map f) applies f to each element in a list of lists.
14:34:30 <shachaf> ((.) is just map for functions rather than lists.)
14:34:43 <hpc> this generalizes in a neat way to fmap
14:35:34 <shachaf> !list categories
14:35:35 <shachaf> !list
14:35:35 <monochrom> shachaf: http://hackage.haskell.org/packages/archive/pkg-list.html
14:35:58 <frerich_> Is there a way to search the source code of all packages on Hackage? Sometimes I'd like to see a few example uses of a function (in this case: alwaysSucceeds from the stm package).
14:36:20 <shachaf> frerich_: Just go to the package it's defined in.
14:36:36 <hpc> shachaf: i think he means other users of the function
14:36:42 <shachaf> Oh, oops.
14:36:50 <frerich_> Yeah :-)
14:36:50 <shachaf> No, not really.
14:37:03 <hpc> could be an interesting thing to have
14:37:06 <frerich_> In many cases, Google doesn't give useful output for things like "Haskell alwaysSucceeds" ;-)
14:37:08 <shachaf> My approach is: Whenever I'm curious about a package, I `cabal unpack` it in ~/Hkg
14:37:21 <shachaf> Now I can search that directory and get many examples of things.
14:37:24 <hpc> shachaf: you mean you don't mirror hackage?
14:37:27 <hpc> (me neither)
14:37:33 <shachaf> It has 129 packages now.
14:37:51 <frerich_> Google Code Search just finds a single entry, heh: http://code.google.com/codesearch#search/&q=alwaysSucceeds%20lang:%5Ehaskell$&type=cs - the one from RWH
14:38:17 <shachaf> Note that there is a variant called "always".
14:38:28 <frerich_> Yeah, but that gives even less useful search results :-}
14:39:07 <hpc> there's a reverse deps search somewhere
14:39:48 <frerich_> You mean, listing the packages depending on stm? That's probably a lot...
14:40:08 <geekosaur> http://packdeps.haskellers.com but I'm not sure it will help with this; it searches packages, not code
14:45:21 <unlink`> What's the idiom for this: \f xs -> case xs of { [] -> Nothing ; _ -> Just (f xs) }
14:46:08 <allsystemsarego> Hi, what's the easiest way to generate an infinite list similar to [0,0,0,4,0,0,0,8,0,0,0,12, ...] but for arbitrary given numbers? (the example I gave was for the number 4)
14:46:09 <mauke> listToMaybe . map f
14:46:40 <shachaf> Or fmap f . listToMaybe
14:46:52 <shachaf> Natural transformations, man!!
14:46:54 <unlink`> Those both do something different.
14:47:01 <shachaf> True.
14:47:03 <Eduard_Munteanu> :t listToMaybe .: map
14:47:04 <lambdabot> (a1 -> a) -> [a1] -> Maybe a
14:47:10 * shachaf was going by mauke's thing.
14:47:22 <shachaf> I would just pattern-match.
14:47:28 <mauke> my emperor!
14:47:41 <shachaf> allsystemsarego: concatMap (\x -> [0,0,0,x]) [4,8..] ?
14:47:59 <allsystemsarego> shachaf, thanks
14:48:14 <unlink`> for example: thisCombinator maximum [1,8,3]
14:48:31 <unlink`> => Just 8
14:48:56 <unlink`> It *feels* like there's something for this.
14:49:19 <unlink`> And it's not traverse or mapMaybe, cause those are the ones I usually forget.
14:49:24 <elliott> > maximum []
14:49:25 <lambdabot>   *Exception: Prelude.maximum: empty list
14:49:32 <elliott> thisCombinator can't really exist
14:49:34 <elliott> well
14:49:38 <Eduard_Munteanu> spoon!
14:49:41 <Eduard_Munteanu> :D
14:49:42 <elliott> thisCombinator _ [] = Nothing; thisCombinator f xs = Just (f xs) I guess
14:49:54 <mauke> @src maximum
14:49:54 <lambdabot> maximum [] = undefined
14:49:54 <lambdabot> maximum xs = foldl1 max xs
14:50:07 <shapr> What's up with threadDelay not actually delaying? Do I need to use -threaded or something?
14:50:17 <elliott> how big a number are you passing
14:50:31 <shapr> 30?
14:50:34 <frerich_> shapr: Maybe your timer resolution is not fine enough
14:50:34 <mauke> haha
14:50:38 <shachaf> 30 µs is not very long.
14:50:39 <elliott> it's delaying
14:50:42 <elliott> it's just not delaying for very long
14:50:43 <monochrom> 30 microseconds
14:50:43 <johnw> is there a way to give multi-line input to a doctest?
14:50:46 <shapr> oh wait, MICROseconds
14:50:54 * shapr sighs
14:51:12 <ion> johnw: I didn’t find a way. :-(
14:51:12 <shachaf> Also: When you ask a question like that, you should post code. :-)
14:51:13 <monochrom> not to say that it does have that much precision
14:51:47 <hpc> maybe if you had a REALLY custom kernel
14:52:14 <Eduard_Munteanu> You might be able to get that with realtime prios.
14:52:17 <hpaste> shapr pasted “Moodclock.hs” at http://hpaste.org/81138
14:52:22 <shapr> It doesn't seem to be delaying.
14:53:02 <monochrom> 3 milliseconds is still pretty hard to notice
14:53:37 <Eduard_Munteanu> That's 300 ms.
14:54:02 <shachaf> No, it's 3ms.
14:54:02 <Eduard_Munteanu> Oh, you were talking about the one in main.
14:54:13 <shachaf> Oh.
14:54:15 <shachaf> Yes.
14:54:54 <shachaf> shapr: 1 s = 1000000 µs
14:55:22 <monochrom> > [255..1]
14:55:24 <lambdabot>   []
14:55:33 <monochrom> setColor is dead code :)
14:56:27 <shachaf> Good point.
14:56:45 <shachaf> This is why you paste actual code.
14:57:01 <shapr> monochrom: How is setColor dead code?
14:57:25 <monochrom> you are just doing mapM_ of setcolor to [255..1], right?
14:57:32 <shapr> yes?
14:57:35 <monochrom> > [255..1]
14:57:37 <lambdabot>   []
14:58:30 <ikenov> how do I make this elegant? f g x ys = let (a, b) = g x in (a, b : ys)  -- I want to say (,) id (: ys) or something -- how do I apply two functions in parallel like that?
14:58:41 <shapr> monochrom: That's a point.
14:59:30 <mauke> @pl f g x ys = let (a, b) = g x in (a, b : ys)
14:59:30 <lambdabot> (line 1, column 11):
14:59:30 <lambdabot> unexpected " "
14:59:30 <lambdabot> expecting operator
14:59:48 <mauke> @pl \g x ys -> let (a, b) = g x in (a, b : ys)
14:59:48 <lambdabot> (line 1, column 16):
14:59:48 <lambdabot> unexpected "("
14:59:48 <lambdabot> expecting "()", natural, identifier or "in"
15:00:21 <fragamus> help!   I'm trying to de-lambda this:       (\as -> foo =<< (bar as))
15:00:33 <mauke> @pl (\as -> foo =<< (bar as))
15:00:33 <lambdabot> (foo =<<) . bar
15:00:44 <mauke> :t \g x ys -> let (a, b) = g x in (a, b : ys)
15:00:46 <lambdabot> (t -> (t1, a)) -> t -> [a] -> (t1, [a])
15:00:52 <fragamus> wow what was that!
15:01:00 <fragamus> pl?
15:01:12 <mauke> :t \g x ys -> fmap (: ys) (g x)
15:01:14 <lambdabot> Functor f => (t -> f a) -> t -> [a] -> f [a]
15:01:14 <Eduard_Munteanu> @help pl
15:01:14 <lambdabot> pointless <expr>. Play with pointfree code.
15:01:23 <fragamus> wow
15:01:34 <mauke> @pl \g x ys -> fmap (: ys) (g x)
15:01:35 <lambdabot> (flip (fmap . flip (:)) .)
15:01:41 <unlink`> Is there a combinator for: \(x,y) -> (x,) <$> y?
15:01:49 <b_faulkner> you can `/msg lambdabot @pl your expression`
15:01:54 <S11001001> unlink`: strenght
15:01:58 <S11001001> s,ht,th,
15:02:21 <unlink`> strength?
15:02:21 <S11001001> @ty (<=<) -- fragamus
15:02:22 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
15:02:35 <ikenov> mauke: thanks
15:03:28 <ikenov> The result isn't really that nice. I suppose I was hoping (id, (:ys)) .  might work or something like it
15:03:42 <ikenov> apply functions across a tuple
15:04:16 * shapr sighs
15:04:21 <mauke> ikenov: that's (***)
15:04:43 <mauke> but why bother with id if you only want to mess with the second half?
15:05:20 <ikenov> just to have a function there; keep in mind i don't really know what i'm talking about
15:05:42 <fragamus> @pl (\as -> foo =<< bar x <$> sortBy (comparing snd) <$> (baz as))
15:05:42 <lambdabot> (foo =<<) . ((bar x <$> sortBy (comparing snd)) <$>) . baz
15:06:00 <mauke> > (length *** show) ("hello", 42)
15:06:02 <lambdabot>   (5,"42")
15:06:09 <mauke> > first length ("hello", 42)
15:06:11 <lambdabot>   (5,42)
15:06:16 <mauke> > second show ("hello", 42)
15:06:18 <lambdabot>   ("hello","42")
15:06:21 <ion> @pl \as foo bar x sortBy comparing snd baz -> foo =<< bar x <$> sortBy (comparing snd) <$> (baz as)
15:06:22 <lambdabot> flip ((.) . (.) . (.) . (.) . (.) . (.) . (=<<)) . flip (flip . ((flip . ((flip . ((flip . (((.) . (<$>)) .)) .)) .)) .) . flip flip (.) . (((.) . (.) . (.) . (<$>)) .)) . flip id
15:06:23 <mauke> > fmap show ("hello", 42)
15:06:24 <lambdabot>   ("hello","42")
15:06:31 <ciaranm> :t (***)
15:06:32 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
15:06:34 <shachaf> > over _1 length ("hello",42)
15:06:35 <lambdabot>   (5,42)
15:06:41 <ikenov> where is ***? (it's not very googleable)
15:06:50 <shapr> @hoogle (***)
15:06:50 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
15:06:52 <ion> It should be hoogleable.
15:06:54 <shachaf> ikenov: It's very Hoogleable!
15:06:55 <shachaf> @where hoogle
15:06:55 <lambdabot> http://haskell.org/hoogle
15:07:00 <shapr> ikenov: hoogle can often find operators for you
15:07:04 <frerich_> Is there a good module for dealing with directed graphs which have cycles? So far I'm resorting to an additional indirection (a map of ID values to the actual elements, and the elements then reference their successors by IDs) but that is a little clumsy and it has a risk for inconsistencies.
15:07:12 <ikenov> ok thanks
15:07:20 <frerich_> Anything I found on Hackage seems to deal with acyclic graphs.
15:07:29 <shapr> frerich_: Have you tried the Haskell Functional Graph Library?
15:07:53 <monochrom> I would start with that too. "fgl". comes with Haskell Platform
15:07:55 <frerich_> Hm is that fgl? I think I just looked at that, let me check
15:08:40 <ikenov> I'm going to call *** the swearing operator, if nobody minds.
15:09:53 <monochrom> but what will you call &&& ?
15:10:09 <ikenov> thrand
15:10:26 <monochrom> and >>> ?
15:10:35 <ikenov> thataway
15:10:36 <frerich_> shape, monochrome: thanks, I think fgl might do what I want - I should've looked close the first time...
15:10:38 <monochrom> there is also |||
15:10:44 <shachaf> By the way the Arrow hierarchy is all wrong.
15:10:52 <shapr> shachaf: What's right?
15:10:53 <shachaf> elliott and I worked out what the One True Arrow Hierarchy should be.
15:10:55 <S11001001> unlink`: yeah
15:11:00 <ski> ikenov : `f g x ys = fmap (: ys) (g x)', using `Functor (w,)'
15:11:01 <shachaf> For one, it's more granular.
15:11:10 <shachaf> And a lot of the classes don't have Category superclasses.
15:11:10 <shapr> shachaf: So, put it on hackage?
15:11:34 <shachaf> That won't do much good when it's not in base. :-)
15:11:58 <shapr> shachaf: You don't get to complain without doing something about it :-P
15:12:16 <b_faulkner> it's smileys with noses day
15:12:24 <ikenov> ski: ah that's closer to my vague aim
15:12:27 <shachaf> shapr: We've done lots of things about it.
15:12:37 <shachaf> These complaints of mine have made real progress in certain packages.
15:13:13 <shachaf> shapr: Example: http://hackage.haskell.org/packages/archive/profunctors/3.2/doc/html/Data-Profunctor.html#t:Choice
15:13:14 <shapr> shachaf: Do you have a HaskellWiki page up that describes the One True Arrow Hierarchy?
15:13:25 <ikenov> I wonder if it makes sense for (.) to work on tuples, just to shorten syntax?
15:13:33 <shachaf> Part of it is in profunctors now.
15:13:49 <ikenov> have a tuple of functions, apply them all with just (.)
15:13:59 <shachaf> ikenov: It makes sense if you make sense of it.
15:14:01 <mauke> > sqrt . (2, 4)
15:14:03 <lambdabot>   (2,2.0)
15:14:03 <fragamus> @pl (\as -> foo =<< bar x <$> sortBy (comparing snd) <$> (baz as))
15:14:03 <lambdabot> (foo =<<) . ((bar x <$> sortBy (comparing snd)) <$>) . baz
15:14:07 <ski> > (: ["baz","quux"]) . splitAt 2 "fubar"
15:14:09 <lambdabot>   ("fu",["bar","baz","quux"])
15:14:21 <shachaf> ikenov: I'm not sure what (.) has to do with that.
15:14:34 <fragamus> ok now… that looks weird    see the part where it says            <$>) .
15:14:48 <fragamus> thats just incomprehensible
15:14:58 <fragamus> but i want to comprehend it
15:15:29 <elliott> That @pl'd code is pretty unreadable.
15:15:38 <ion> s/That/Most/
15:15:40 <fragamus> but i want to read it
15:17:52 <S11001001> fragamus: do it piece by piece, adding in combinators you know, and you'll do a more readable job than pl
15:17:55 <S11001001> one step at a time
15:18:02 <S11001001> first step: (foo =<< bar x <$> sortBy (comparing snd) <$>) . baz
15:18:14 <unlink`> Why isn't there a built-in instance for Foldable / Traversable for (,) a?
15:18:29 <S11001001> actually, considering that's pointfree, you're done
15:18:38 <geekosaur> :)
15:18:50 <S11001001> so pl just did a bunch of extra transforms to make it less readable :)
15:18:56 <unlink`> I wish I could do: mapMaybe sequenceA [('a', Just 'b'), ('c', Nothing), ('d', Just 'f')]
15:19:00 <Eduard_Munteanu> There's still 'x' in there.
15:19:03 <ikenov> shachaf: yeah (.) is not related. I was looking for more like (sqrt, id) (4, 3) --> (2, 3)
15:19:04 <unlink`> (and have it work without writing orphan instances.)
15:19:21 <ion> eduard_munteanu: No \x ->
15:19:31 <mauke> > uncurry (***) (sqrt, id) (4, 3)
15:19:33 <lambdabot>   (2.0,3)
15:19:51 <Eduard_Munteanu> Ah.
15:20:17 <S11001001> ikenov: or, bifunctors! http://hackage.haskell.org/packages/archive/bifunctors/3.0.3/doc/html/Data-Bifunctor-Apply.html
15:20:43 <S11001001> don't worry, trifunctors and maybe octofunctors coming soon
15:22:38 <augur_> its interesting how divide and conquer schemes have different amounts of each step
15:24:17 <ikenov> Just out of curiosity, would break the haskell grammar to allow tuples in the function position e.g. (sqrt, id) (4, 3) ?
15:24:25 -ChanServ(ChanServ@services.)- shapr set flags +F on johnw.
15:24:56 <ikenov> not that I'm really advocating it
15:25:17 <lispy> :t (sqrt, id)
15:25:19 <lambdabot> Floating a => (a -> a, a1 -> a1)
15:25:34 <lispy> doesn't seem to break anything here
15:25:40 <augur_> ikenov: why not use one of the combinators?
15:25:51 * hackagebot type-unary 0.2.8 - Type-level and typed unary natural numbers, inequality proofs, vectors  http://hackage.haskell.org/package/type-unary-0.2.8 (ConalElliott)
15:26:09 <mauke> ikenov: looks like it would break type inference
15:26:32 <augur_> it would definitely break haskell as is, but you could probably fix it
15:26:39 <augur_> but really why do that? just use a combinator
15:26:51 <Eduard_Munteanu> You could overload function application.
15:27:01 <Eduard_Munteanu> That's what you actually want.
15:27:11 <augur_> Eduard_Munteanu: sounds shady
15:27:23 <ski> ikenov : if `(sqrt, id) (4, 3)' would work, would `id (sqrt, id) (4, 3)' work ?
15:27:24 <Eduard_Munteanu> (since as pointed out above, (sqrt, id) is valid as it is)
15:28:37 <augur_> ski: if you overload as Eduard_Munteanu suggests, it might work
15:28:45 <ion> instance IsFunction (a -> a', b -> b') (a, b) (a', b') where
15:28:52 <augur_> like, in a type-class-y way
15:28:56 <Eduard_Munteanu> Yeah.
15:28:59 <hughfdjackson> :# this is a very newbie question, but can you pattern match against the result of an expression?
15:29:10 <Ralith> augur_: that sounds entertaining
15:29:29 <Ralith> hm
15:29:30 <hughfdjackson> I want to return an empty string ("") if there isn't a member for a map for the input string
15:29:31 <Eduard_Munteanu> instance (IsFunction f, IsFunction g) => IsFunction (f, g) where
15:29:36 <Ralith> dunno how that would work with unification
15:29:44 <mauke> hughfdjackson: use a guard
15:30:26 <ski> hughfdjackson : perhaps you want `case'
15:31:10 <hpaste> “Anonymous Coward” pasted “unwrap Maybe into "" or name” at http://hpaste.org/81143
15:31:37 <hughfdjackson> oh, that was me :p i didn't supply a name
15:32:07 <ski> @type fromMaybe
15:32:08 <Eduard_Munteanu> (actually I guess you want to parametrize IsFunction by an argument type as well)
15:32:08 <lambdabot> a -> Maybe a -> a
15:32:17 <ski> hughfdjackson ^
15:32:24 <monochrom> fromMaybe "" (lookup c namesForChars)
15:32:27 <hughfdjackson> :| that does make sense
15:32:31 <hughfdjackson> thanks both :)
15:33:08 <Eduard_Munteanu> instance (IsFunction f a, IsFunction g b) => IsFunction (f, g) (a, b) where (f, g) $ (a, b) = (f a, g b)
15:33:13 <hughfdjackson> oh, fromMaybe is perfect :D thankyou
15:34:34 <Eduard_Munteanu> One could already test this if they add '$' all over the place.
15:34:50 * Eduard_Munteanu is bored :)
15:36:11 <johnw> can somebody take a look at my "boolean monoids and monads" library, and tell me if I'm not just reinventing some wheel?  http://ftp.newartisans.com/pub/monad-bool/Control-Monad-Bool.html
15:37:08 * ciaranm hugs johnw 
15:38:08 <ciaranm> johnw: plz2generalise for lists, empty lists being like Nothing
15:38:19 <johnw> i have a ToBool instance for []
15:38:26 <johnw> oh
15:38:29 <johnw> haha!
15:38:30 <johnw> i'll use Attempt
15:38:44 <johnw> then it can be Maybe or [], however you prefer
15:39:02 <ciaranm> i don't think Maybe is special
15:39:30 <ciaranm> it should work with Either, and [], and probably other things too
15:39:36 <ikenov> ski: could you explain Functor (w,)? f g x ys = fmap (: ys) (g x) compiles but I guess I need an instance of Functor. So I say `instance (w,) of Functor' or something?
15:40:01 <johnw> ciaranm: changing now... one sec
15:40:21 <shapr> ohh, I was missing hFlush!
15:41:15 <Eduard_Munteanu> shapr: or hSetBuffering maybe?
15:41:24 <monochrom> oh! I forgot to advise you of hFlush too!
15:41:36 <ikenov> Oh I need (Functor ((,) t0)) as the error says
15:43:18 <mauke> ikenov: import Control.Monad.Instances
15:43:29 <bgamari> when are we going to get a release of cabal with sandboxing?
15:43:58 <dcoutts_> bgamari: sooner if you use the dev version and help :-)
15:44:11 <bgamari> dcoutts, I can do that
15:44:27 <bgamari> dcoutts, Is there an understanding of what the user interface should look like?
15:44:35 <ikenov> mauke: yes that does it, thanks
15:44:39 <dcoutts_> bgamari: only partly, that's part of the issue
15:45:53 <bgamari> I see
15:46:02 <bgamari> I can have a look at cabal git soon
15:46:03 <mauke> Eduard_Munteanu: http://hpaste.org/81145
15:46:24 <ikenov> It seems undesirable for ghci to hog my command line by listing all imports. At least that shouldn't be the default. Just sayin'.
15:46:36 <ski> ikenov : iirc, import `Control.Monad.Writer' or `Control.Monad.Instances' to get it
15:46:49 <ikenov> yep it's the latter
15:47:02 <Eduard_Munteanu> Oh, hm, type families.
15:47:04 <ski> both, i think
15:47:15 <Eduard_Munteanu> I guess that does too.
15:47:29 <mauke> Eduard_Munteanu: you want fundeps instead?
15:48:03 <Eduard_Munteanu> mauke: um, can you do it with fundeps? Not sure how you'd translate it.
15:48:23 <mauke> class Fun argument result f | f -> argument, f -> result where
15:48:43 <mauke> instance Fun a b (a -> b)
15:48:56 <ikenov> ski: just Control.Monad.Instances works for me
15:48:56 <Eduard_Munteanu> Ah, yeah... that's a bit more like what I was doing above
15:49:31 <ski> ikenov : yes
15:49:50 <ski> it's your choice
15:49:53 <hpaste> hughfdjackson pasted “getName for crit” at http://hpaste.org/81146
15:50:17 <hughfdjackson> if any of you kind peeps would like to tell me if you'd do this differently, that'd be awesome ^^
15:51:26 <fragamus> @pl (foo =<<) . bar
15:51:26 <lambdabot> (foo =<<) . bar
15:51:48 <fragamus> what does it mean
15:51:52 <mm_freak_> wow, i didn't know that actually calculating the zeta function is such difficult
15:52:09 <mauke> @unpl (foo =<<) . bar
15:52:09 <lambdabot> (\ d -> (bar d) >>= foo)
15:52:50 <johnw> ciaranm: now using Attempt instead of Maybe: http://ftp.newartisans.com/pub/monad-bool/Control-Monad-Bool.html
15:52:55 <fragamus> thanks but i want to understand the point free one
15:53:21 <fragamus> and is there a clearer way to be point free on it
15:53:32 <fragamus> @pl (foo =<<) . bar
15:53:32 <lambdabot> (foo =<<) . bar
15:54:06 <johnw> (foo =<<) . bar says to pass the incoming argument to bar, then take the return value from that evaluation of bar and bind to an invocation of foo
15:54:07 <fragamus> it seems like that dot shouldn't be there
15:54:25 <johnw> it is the same as: foo <=< bar
15:54:32 <fragamus> ahhh
15:54:37 <nathanfh1> Yay, left fish!
15:54:50 <fragamus> I LOVE IT
15:55:01 <ciaranm> why isn't [] an instance of Attempt?
15:55:06 <johnw> it should be
15:55:15 <fragamus> @pl foo <=< bar
15:55:15 <lambdabot> foo <=< bar
15:55:19 <ciaranm> oh, it's FromAttempt
15:55:29 <johnw> yeah
15:56:13 <fragamus> I really love that!!
15:56:28 <Eduard_Munteanu> mm_freak_: how so? You can get some approximation by summing the first few terms, I'd say, at least for convergent stuff.
15:57:20 <ciaranm> i feel like there should be an Attempt m => m a -> a -> a somewhere
15:59:41 <ikenov> ski: oh I misundersood, I thought you meant "you need both"
16:00:28 <ikenov> Where do I lobby to remove the default behavior of ghci hogging my command line with imports?
16:00:31 <ion_> hello
16:00:34 <ion_> clear
16:00:47 <ciaranm> maybe i want evalOrM. it is too late at night to think about monad transformers.
16:00:51 * hackagebot monad-bool 0.1.0.0 - Short-circuiting boolean monads  http://hackage.haskell.org/package/monad-bool-0.1.0.0 (JohnWiegley)
16:01:15 <ciaranm> or possibly evalAndM.
16:01:37 <ski> @hoogle evalOrM
16:01:37 <lambdabot> No results found
16:01:43 <johnw> there is an evalOrM
16:01:54 <ciaranm> yeah. i mean, maybe that's what i want.
16:01:59 <johnw> ah
16:02:36 <fragamus> =<<      is to    <=<      as      <$>    is to   what?
16:02:39 <mm_freak_> Eduard_Munteanu: the convergent points are all outside the critical strip
16:03:02 <mm_freak_> the simple zeta sum formula is undefined there
16:03:50 <Saizan> (.) ?
16:04:12 <mm_freak_> let's see if i can implement the riemann-siegel formula
16:05:44 <ion> fragamus: (b -> c) -> (a -> f b) -> a -> f c
16:06:18 <ion> @type \f g -> fmap f . g
16:06:19 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
16:06:28 <ion> @type \f g -> fmap f (Prelude..) g
16:06:30 <lambdabot> (((a -> b1) -> a -> c) -> b) -> (b1 -> c) -> b
16:06:32 <ion> @type \f g -> fmap f Prelude.. g
16:06:33 <lambdabot> Functor f => (a1 -> b) -> (a -> f a1) -> a -> f b
16:10:52 * hackagebot monad-bool 0.1.1 - Short-circuiting, value-returning boolean monoids and monads  http://hackage.haskell.org/package/monad-bool-0.1.1 (JohnWiegley)
16:11:26 <ciaranm> that is almost a cool surname
16:11:34 <johnw> hahah, almost? :)
16:11:44 <johnw> i've had people laugh out loud in my face after asking me my name
16:11:53 <ciaranm> it's almost wriggly
16:12:00 <ciaranm> maybe i've been watching too much gollum
16:12:00 <johnw> and my wife, Dr. Wiegley, gets amused reactions all the time
16:12:36 <johnw> growing up my Mom used to read "Uncle Wiggly" to me :)
16:16:27 <lightquake> ?!
16:16:27 <lambdabot> Maybe you meant: . ? @ v
16:16:37 <lightquake> why am i getting an error that there's no Monad (Either e) instance
16:16:51 <ciaranm> lightquake: because you didn't import Control.Monad.Instances
16:16:54 <ciaranm> next!
16:17:05 <lightquake> i thought it was defined in Data.Either
16:17:20 <johnw> that only defines Either, not the Monad instances
16:17:29 <liyang> It's an orphan. :<
16:17:39 <johnw> i was surprised to find that EitherT isn't in transformers
16:17:40 <lightquake> looks like Data.Either defines it in base 4.6
16:17:42 <ciaranm> put it to work in the coal mines
16:17:53 <lightquake> but C.M.I defines it in 4.5
16:18:12 <fragamus> @pl (foo <$>) . bar
16:18:12 <lambdabot> (foo <$>) . bar
16:18:52 <johnw> fragamus: haha, are you try this pattern with every combinator? :)
16:18:58 <fragamus> this is similarly cryptic and you guys helped me before by introducing me to <=<    what do I use here
16:19:09 <fragamus> no this is the last one
16:19:16 <johnw> let's rewrite that
16:19:20 <johnw> fmap foo . bar
16:19:26 <johnw> what is that saying?
16:19:29 <ciaranm> everyone knows the first lines of all haskell programs are {-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, TupleSections, NoMonomorphismRestriction #-} ; import Control.Monad ; import Control.Applicative ; import Control.Monad.Instances ; import Whatever.Lens.Library.Is.Cool.Today
16:19:37 <johnw> it applies foo to the value inside the functor value returned by bar
16:19:49 <johnw> there is no simpler form of that construction
16:20:11 <fragamus> ok   i just don't comprehend that dot
16:20:17 <patcolo> Does Haskell have something like symbols, keywords, atoms from other languages? Is there an idiom to do the same thing if there isn't? I'm using arbitrary Int values at the moment. Should I do something else?
16:20:28 <S11001001> ciaranm: you forgot import Prelude hiding (lots of things)
16:20:37 <johnw> fragamus: do you get the difference between f . g and (f .) . g?
16:20:41 <ion> patcolo: data Foo = Bar | Baz | Quux | Poit
16:20:52 <fragamus> no
16:20:57 <ciaranm> S11001001: i used to hide (.) but now i just use <$> everywhere instead...
16:21:18 <johnw> (f . g) x = f (g x), while ((f .) . g) x y = f (g x y)
16:21:18 <sipa> patcolo: you can just write numberOfAvogadro = 602210000000000000000000
16:21:22 <S11001001> ciaranm: foldl, foldr
16:21:29 <johnw> i suggest you play with those definitions for a little bit, to get comfortable with them
16:21:36 <fragamus> ok thanks
16:21:37 <geekosaur> are you sure patcolo doesn't mean Data.Unique?
16:22:00 <ciaranm> S11001001: for some reason i rarely write folds
16:22:01 <sipa> aah, could be!
16:22:12 <johnw> fragamus: one hint you'll need: the functor involved in that second definition is the Functor instance for ((->) e)
16:22:19 <patcolo> no, I mean like the data example - so obvious when I see it!
16:22:39 <fragamus> oh that is discussed in lyah
16:22:44 <johnw> another way to read (f .) . g is: compose f with the function *returned* by g
16:22:53 <johnw> whereas f . g is compose f with g
16:23:51 <fragamus> so (f <$>) . g   is fmap f with the functor returned by g
16:24:06 <johnw> is applies fmap f to the functor returned by g
16:24:07 <Eduard_Munteanu> functor?
16:24:59 <Eduard_Munteanu> @unpl (f .) . g
16:24:59 <lambdabot> (\ d i -> f (g d i))
16:25:34 <Eduard_Munteanu> @unpl f . g
16:25:34 <lambdabot> (\ c -> f (g c))
16:26:09 <johnw> > (((+1) .) . (+)) 4 5
16:26:11 <lambdabot>   10
16:26:23 <johnw> that does: (4 + 5) + 1
16:26:39 <nejucomo> Well this is an odd parsec result: Left "\"<test input>\" (line 1, column 4):\nunexpected end of input\nexpecting end of input"
16:28:17 <nejucomo> It comes from: eof <|> lookAhead otherParser
16:28:27 * nejucomo tries to make a minimal test case.
16:28:34 <johnw> yes, that would help :)
16:29:14 <edwardk> ciaranm: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Monad-Instances.html is empty now
16:29:44 <edwardk> :t iso
16:29:46 <lambdabot> (Functor f, Isomorphic k) => (s -> a) -> (b -> t) -> k (a -> f b) (s -> f t)
16:29:47 <nejucomo> I have two different versions of Text.Parsec installed so that ghci complains when I do :mod Text.Parsec.
16:29:50 <nejucomo> How can I resolve this?
16:29:51 <edwardk> still old and busted
16:30:09 <edwardk> nejucomo ghc-pkg unregister the old one
16:30:28 <nejucomo> I tried :set -package parsec-3.1.3
16:30:54 <nejucomo> edwardk: Must I unregister the old one, or can I instruct ghci to use a specific one?
16:31:29 <edwardk> you probably can do the latter, in fact, i have some tests that automaticall switch to specific versions of things, but i don't have a useful intuition for it
16:32:07 <nejucomo> Also, I'm confused by the various parsec versions.  The colliding packages are: parsec-3.1.3 parsec3-1.0.0.4
16:32:10 <edwardk> https://github.com/ekmett/lens/blob/master/tests/doctests.hsc#L59 is the only thing i use that has any manual package management https://github.com/ekmett/lens/blob/master/tests/doctests.hsc#L59
16:32:17 <edwardk> parsec3 is by someone else
16:32:22 <edwardk> and its just a crap idea
16:32:29 * johnw puts in a good word for trifecta over parsec :)
16:32:34 <nejucomo> ok.  What's it's idea?
16:33:25 <nejucomo> Also, At some point I saw Text.ParserCombinators.Parsec versus Text.Parsec.  Does it matter which namespace I use?  (Both are in 3.1.3)
16:33:39 <nejucomo> johnw: How doe trifecta compare.
16:33:41 <nejucomo> ?
16:33:57 <johnw> nejucomo: it's close to the same interface, but much better error reproting
16:33:59 <Letchik> Hello. I've just started reading Yet Another Haskell Tutorial and there is a string of code:
16:33:59 <Letchik> map Char.toUpper "Hello World"
16:33:59 <Letchik> But if I type it in ghci, it says
16:33:59 <Letchik> Prelude> map Char.toUpper "Hello World"
16:33:59 <Letchik> <interactive>:2:5:
16:33:59 <Letchik>     Failed to load interface for `Char'
16:34:00 <Letchik>     It is a member of the hidden package `haskell98-2
16:34:00 <Letchik>     Use -v to see a list of the files searched for.
16:34:07 <johnw> and it's got that edwardk goodness baked right in
16:34:49 <Eduard_Munteanu> Letchik: you want Data.Char
16:34:52 <Eduard_Munteanu> @index toUpper
16:34:52 <lambdabot> Data.Char
16:35:12 <edwardk> derek elkins used to maintain parsec, after he handed it to antoine latter, antoine forked off a copy of parsec2 as an explicit parsec2 package so people wouldn't transitively depend on parsec >= 3 and parsec < 3. christian maeder copied that style and copied parsec to parsec3, which kinda defeats the point
16:35:15 <edwardk> and nobody uses it
16:35:16 <Letchik> So that book that I'm reading is seriously outdated?
16:35:40 <edwardk> i think he also did some parsec1 haskell98 package too
16:35:51 <johnw> edwardk: how is the lensification of trifecta coming?
16:36:06 <ion> and the trifectification of lens
16:36:08 <Eduard_Munteanu> Letchik: not really, I suppose it came out before Haskell2010
16:36:24 <Letchik> Eduard_Munteanu: Didn't know there was Haskell2010
16:36:24 <nejucomo> edwardk: Thanks.
16:36:36 <Letchik> Any good tutorials for haskell2010 with exercises?
16:36:38 <edwardk> but the thing is parsec3 is a bad package. it uses the same module names that are used by the 'real' parsec. so any would=-be users wind up in your situation
16:36:55 <Eduard_Munteanu> Letchik: it's just a revision of the standard, not some new language
16:36:57 <edwardk> nobody moved and all it does right now is create problems like you've experienced
16:37:07 <Eduard_Munteanu> Letchik: LYAH should be fine
16:37:30 <Letchik> Eduard_Munteanu: Is that "Learn You a Haskell for Great Good"?
16:37:34 <Eduard_Munteanu> @seen BONUS
16:37:34 <lambdabot> Unknown command, try @list
16:37:36 <edwardk> so in addition to that, it lags behind
16:37:37 <Eduard_Munteanu> Letchik: yeah
16:37:40 <ski> @where LYAH
16:37:40 <lambdabot> http://www.learnyouahaskell.com/
16:37:42 <Eduard_Munteanu> preflex: seen BONUS
16:37:43 <preflex>  BONUS was last seen on #haskell 1 year, 268 days, 5 hours, 9 minutes and 50 seconds ago, saying: yeah i think that's better as well
16:37:43 <ski> @where YAHT
16:37:43 <lambdabot> "Yet Another Haskell Tutorial", Hal Daume III,<http://www.cs.utah.edu/~hal/htut/>,<http://en.wikibooks.org/wiki/Haskell/YAHT>,<http://hal3.name/docs/daume02yaht.p(df|s)>,<http://darcs.haskell.org/
16:37:43 <lambdabot> yaht/yaht.p(df|s)>
16:37:45 <edwardk> its currently a version behind parsec
16:38:36 <edwardk> nejucomo: re trifecta. trifecta is basically parsec with much nicer error reporting and support for being transformed with monad transformers
16:38:57 <edwardk> it basically spits out clang-style colored diagnostics, with carets and fixits, etc.
16:39:10 <ion> Fixits?
16:39:17 <shanse> does the speed compare?
16:39:24 <edwardk> http://clang.llvm.org/diagnostics.html
16:39:28 <nejucomo> How can I import only a set of names from a module in ghci?
16:39:44 <johnw> import Foo (name, name, name)
16:39:47 <johnw> oh, in ghci...
16:40:00 <johnw> i think import works in ghci
16:40:06 <nejucomo> johnw: hehe...  I was about to say I wish ghci just had the same import syntax.
16:40:12 <Eduard_Munteanu> It should.
16:40:15 <shanse> it does
16:40:23 <nejucomo> Nice!
16:40:24 <edwardk> shanse: its faster than parsec for what i call 'human scale' languages, because the major parser right now holes onto a rope of the entire input, but nothing stops you from working with a streaming trifecta parser other than the fact i never wrote one ;)
16:40:26 <nejucomo> It does.
16:40:29 <ion> edwardk: Aren’t they what Parsec has, too?
16:40:36 <Letchik> What do additional lines mean when I'm using toUpper?
16:40:36 <Letchik> *** Parser:
16:40:36 <Letchik> *** Desugar:
16:40:36 <Letchik> *** Simplify:
16:40:36 <Letchik> *** CorePrep:
16:40:36 <Letchik> *** ByteCodeGen:
16:40:37 <Letchik> "HELLO WORLD!"
16:41:05 <Eduard_Munteanu> Letchik: don't paste a lot of stuff into the channel, use a pastebin
16:41:09 <Eduard_Munteanu> @where hpaste
16:41:09 <lambdabot> http://hpaste.org/
16:41:13 <shanse> edwardk: Guess, I'll have to take a look at trifecta then
16:41:14 <Letchik> Eduard_Munteanu: ok, sorry.
16:41:23 <edwardk> ion: look at the struct point origin = { x: 0.0, y: 0.0 }; example
16:41:27 <johnw> shanse: if you like parsec, it's a no-brainer
16:41:28 <Eduard_Munteanu> Letchik: how are you running your code?
16:41:40 <Letchik> Eduard_Munteanu: ghci
16:41:41 <edwardk> shanse: i'm about to release a fairly major improvement to it as soon as max-bolingbroke takes my patches
16:41:54 <ion> edwardk: Ah, thanks. I only searched for fixit, didn’t see “fix-it”. :-)
16:41:56 <edwardk> the api shrinks by about a factor of 6x
16:42:09 <Eduard_Munteanu> Hm, weird.
16:42:15 <Letchik> wait, no.
16:42:19 <Letchik> That was because I used -v
16:42:55 <Letchik> @where LYAH
16:42:55 <lambdabot> http://www.learnyouahaskell.com/
16:43:52 <edwardk> anyways the major impovements in trifecta over parsec are things like automatic highlighter generation using highlight info baked into the token parsers, easier token parsing, the ability to seek back and reparse part of the input, the ability to easily capture fixits, spans, and carets in the original source and basically 'draw' on a diagnostic.
16:44:21 <edwardk> also under some corner cases parsec will 'move' an error message to the wrong location, trifecta lacks that bug
16:45:10 <shanse> I like it
16:45:27 <edwardk> with trifecta-HEAD its built on my 'parsers' package, which provides a common monad-transformable set of parser combinators
16:45:45 <edwardk> you can use parsec-parsers to write code in parsers that you can move between parsec and trifecta-HEAD fairly easily
16:46:58 * monochrom giggles at (a -> ErrState e -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r) -> (ErrState e -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r) -> (a -> ErrState e -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r) -> (ErrState e -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r) -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r
16:47:22 <shachaf> monochrom: Where is that?
16:47:29 <geekosaur> gesundheit
16:47:34 <monochrom> the definition of Parser in trifecta
16:47:40 <JoeyA> I'm using a GADT to tag the type parameter of some values I'm carrying around, e.g. data Tag e where FooTag :: Tag Foo; BarTag :: Tag Bar (the number of tags is intentionally limited).  Is there a slightly more elegant way to do this with DataKinds or similar?
16:48:00 <edwardk> monochrom: i'm mostly concerned with speed there ;)
16:48:22 <edwardk> if i don't cps it it i get asymptotic problems.
16:48:27 <shachaf> good type
16:48:31 <edwardk> and the constant factors suck
16:48:46 <edwardk> this is very similar to the type in parsec 3.1.x
16:48:54 <edwardk> with a few minor additions
16:49:50 <nejucomo> Why doesn't that type signature rely on type aliases?
16:49:56 <monochrom> it looks hardcoded to Bytestring
16:50:03 <nejucomo> (Just a style question.)
16:51:11 <JoeyA> My mental model of how GHC executes CPS: a continuation call turns into a goto, and parameters and context passed to the continuation are usually dragged along with registers.
16:51:17 <JoeyA> Is that about right?
16:51:24 <JoeyA> dragged along using*
16:52:43 <johnw> #ghc might know?
16:53:08 <JoeyA> I'm not worried about it too much, just curious.
16:53:42 <liyang> (Why is it data and not newtype?)
16:55:54 <luite> JoeyA: if the call is really a tail call then it's just jumped to, if it's some local closure then a heap object with pointers to its free variables is passed in a register. if it's not a tail call, a stack frame is pushed when the call is made.
16:57:40 <JoeyA> Thanks.
16:58:08 <applicative> JoeyA: data FB = Foo | Bar; data Tag :: FB -> * where TagB :: Tag Bar; TagF :: Tag Foo
16:59:01 <luite> JoeyA: for those non-tail calls, when something has been reduced to a value, the return address on the top of the stack is called with that value.
16:59:50 <luite> JoeyA: it's a tad more complicated in practice because ghc does some escape analysis so some stuff lives on the stack instead of the heap
17:01:13 <applicative> ghc wants ( TagB :: Tag 'Bar ;  TagF :: Tag 'Foo) rather
17:01:41 <ion> sleepe →
17:02:57 <JoeyA> applicative: Thanks, but what is the advantage of doing this?
17:04:07 <applicative> JoeyA: Inference is generally better; Tag Int is not just unconstructable, but nonsense
17:04:48 <applicative> That is, it is not just an empty type; it doesnt exist
17:05:23 <ikenov> @pl \x y -> swap (f y x)
17:05:24 <lambdabot> (swap .) . flip f
17:06:17 <JoeyA> I guess I'm looking to use types as values, rather than values as types.
17:06:33 <JoeyA> E.g. instead of: insertEntry :: EntryTag e -> Entry e -> IO ()
17:06:44 <JoeyA> Where EntryTag is FooTag or BarTag
17:07:23 <JoeyA> say: insertEntry :: EntryType e -> Entry e -> IO (), where EntryType can use the names Foo or Bar (referring to types).
17:07:39 <JoeyA> I know it's dependent-type-ish
17:08:24 <JoeyA> Really, the tag approach works out great.  I'm just wondering if I can do a little better.
17:17:02 <jollytime> hi guys, how do I find out the precedence of a function's parameter vs another operator. ie: reverse' (x:xs) = reverse' xs ++ [x], how do I know what precedence level the (reverse' xs) is? :)
17:17:22 <applicative> JoeyA: oh i didnt see what more you had said; the Tag x types above are the socalled singleton types associated with the so called promoted types 'Foo and 'Bar; one does use them for this sort of matching
17:17:41 <monochrom> function application is higher than all infix operators
17:17:57 <monochrom> for infix operators, ghci has :info
17:18:05 <applicative> jollytime: inside ghci do :i ++ for operators, and as monochrom says for regular functions
17:18:21 <applicative> well, both as monochrom says....
17:18:53 <ikenov> Is there a ghci plugin to auto-import what's needed when something is undefined? Obviously it could be ambiguous, in which case it would list more than one option.
17:19:04 <jollytime> thanks guys, so nobody knows what level it actually is other than it has higher priority than all infix operators?
17:19:58 <serialhex> quick Q:  anyone have any advice for implementing a (simple) component-entity-system in haskell?
17:21:23 <ski> jollytime : it's `10', i think
17:21:42 <monochrom> except that 10 is not a legal level
17:22:15 <monochrom> I am inclined to say, yes, nobody knows
17:22:25 <jollytime> ski, thanks :)
17:22:30 <monochrom> in the same sense as: in C, nobody knows the level of +
17:22:34 <applicative> how come so few levels; agda has so many....
17:22:47 <ijp> prolog has a lot too
17:22:54 <applicative> oh really.
17:23:00 <ijp> at least IIRC
17:23:09 <applicative> infixl 3.14159..
17:23:16 <serialhex> :P
17:23:23 <ski> at least both GHC and Hugs passes `11' as precedence to `showsPrec' for the argument of a data constructor ..
17:23:32 <JoeyA> serialhex: quick Q: what is a
17:23:35 <monochrom> in C, + is not given a level. (it is given an explicit place in the grammar.) therefore, nobody knows what its level is, because it has none.
17:23:37 <JoeyA> oops
17:23:40 <ski> ijp : yeah, 1200 levels
17:23:51 <ijp> ski: beat me to it
17:24:09 <jollytime> how many does haskell have?
17:24:18 <serialhex> 9 i think
17:24:24 <ski> ten that you can set yourself
17:24:30 <monochrom> similarly, function application in Haskell is not given a level. it is given an explicit place in the grammar. whereas infix operators are given levels, not explicit places in the grammar
17:24:39 <ski> (`$' is at level `0')
17:24:45 <jollytime> what!
17:24:49 <jollytime> you can set them?
17:24:54 <jmcarthur> yes
17:24:55 <monochrom> 10 is not a legal level because "infix 10 ***" is an error
17:25:01 <ski> jollytime : for your own operations, sure
17:25:09 <ski> monochrom : yes
17:26:01 <JoeyA> serialhex: I don't know what exactly a component-entity-system is, but I have struggled for a while with breaking down programs into components, and might be able to provide some key insights.
17:27:30 <monochrom> HOL4 has 2^31 or whatever the number of machine integers you have
17:27:47 <serialhex> JoeyA: i have linkage: http://www.chris-granger.com/2012/12/11/anatomy-of-a-knockout/ it's used in games a lot, and unfortunately the best docs i can find is that link :(
17:27:56 <monochrom> fortunately for programmers, HOL4 is a proof language, not a programming language
17:28:19 <ski> imo, it could be more sensible to set precedence of operators relative to others (or groups of others)
17:28:38 <Eduard_Munteanu> ski++
17:28:38 <monochrom> I agree. partial order ftw
17:29:03 <cmccann> infix (ω+5i) $%%>
17:29:22 <Eduard_Munteanu> One just needs to figure out a way to do that without having to write a big bunch of rules every time they introduce a new operator.
17:29:23 <monochrom> but failing that, go BASIC, use line numbers, and go 10, 20, 30... at the beginning, so that later you can insert 15
17:29:28 <ski> .. i suspect that requiring transitivity for reasonability is more important that not requiring it, for flexibility
17:29:46 <ski> monochrom : which is what Prolog does
17:29:48 <serialhex> JoeyA: basically, you have an entity - your player or walls or whatever - and then you have components that act on that entity, givint it hp or armor or the ability to attack or move, etc
17:30:23 <serialhex> i know *what* it does - ish - i'm just unsure how to implement it
17:30:27 <monochrom> it seems that some ideas from the 1970s were not bunk afterall! :)
17:30:38 * ski grins
17:30:52 <JoeyA> Sounds sort of relational.  I suppose in SQL, you might do: CREATE TABLE entities (id SERIAL AUTOINCREMENT INTEGER PRIMARY KEY or whatever, ...);
17:31:25 <JoeyA> Then hang additional data (hp, armor, etc.) on entities by creating additional tables.
17:32:10 <ikenov> Are there any functions which @pl cannot decide? Is there a "godel sentence" I could give it?
17:32:41 <serialhex> yeah, something like that, and you would use those same components to "move" the entity to a new state, from 10hp -> 2hp
17:33:30 <monochrom> Eduard_Munteanu: type restrictions imply that I will almost never write like "x + y ++ z". and even in an exception where I do, I would rather parenthesize explicitly and not rely on an arbitrary decision of "+ is higher than ++" or "+ is lower than ++"
17:33:45 <JoeyA> serialhex: Do "entities" themselves store anything, like common properties every entity will have?  Or is entities no more than a set of IDs?
17:34:29 <monochrom> therefore, in general, when you add an operator, there are not a lot of rules to add. many pairs of operators are better off incomparable.
17:34:30 <serialhex> JoeyA: ideally, just the UID
17:35:02 <tac> ikenov: I don't know for sure, but I think due to the SKI calculus, you can always transform a regular term into a point-free term.
17:35:35 <JoeyA> Also, suppose you want to "kill" an entity.  What do you do with the components that reference it?
17:35:49 <serialhex> JoeyA: i was thinking of representing the entities as `data Entity = Entity [Component]` or something...
17:35:49 <ski> > let infixr 5 /\/; (/\/) :: [a] -> [a] -> [a]; [    ] /\/ ys =     ys; (x:xs) /\/ ys = x : ys /\/ xs  in fix ((0 :) . tail . \ns -> ns /\/ map succ ns)  -- jollytime, simple example
17:35:50 <JoeyA> Or maybe you just want to "push" an entity.
17:35:51 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
17:36:01 <monochrom>  @pl does not try to be complete
17:36:20 <ski> jollytime : you can also say things like  infix 4 `elem`
17:36:32 <xenon_> foo = 10 -- is foo a function that returns 10?
17:36:46 <monochrom> ooh, that one is hard
17:36:50 <JoeyA> serialhex: This doesn't support efficient update.  You could use some of the types from the containers package.
17:36:52 <serialhex> JoeyA:  well the components are functions that transform the entity, they essentially *are* the state
17:37:11 <monochrom> I am only confident to say that "g = True" g is not a function
17:37:20 <monochrom> however, I know how to ask you back!
17:37:37 * ski agrees with monochrom on the "better off incomparable" thing
17:37:39 <monochrom> "is foo a function that returns 10" = "is 10 a function that returns 10"
17:38:00 <ski> > let foo = 10 in foo 5  -- is `foo' a function that returns `10' ?
17:38:01 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> t))
17:38:02 <lambdabot>    arising from the ambiguity chec...
17:38:10 <serialhex> JoeyA: i'm not tooooo concerned with performance just yet, i'm just trying to learn how to do this, make it spiffy-fast later
17:38:13 <JoeyA> e.g. (Set EntityId, Map EntityId FooComponent, Map EntityId BarComponent)
17:38:13 <ski> oh, they removed it :(
17:38:21 <xenon_> I was told that everything is a function in haskell, hence the confusion
17:38:22 <monochrom> \∩/
17:38:33 <ski> xenon_ : everything is *not* a function in Haskell
17:39:00 <JoeyA> serialhex: Good idea.  Though Set, Map, etc. are good to have in your vocabulary even if you aren't shooting for speed.
17:39:11 <tac> (everything is a function is category theory)
17:39:32 <monochrom> functions are certainly pervasive in haskell. some people mistake that to mean "everything is a function"
17:39:33 <serialhex> JoeyA: true, very true :D
17:40:55 <tac> In Haskell, "everything is an object" >:]
17:41:06 <jmcarthur> xenon_: most things are values in haskell, even functions!
17:41:22 <jmcarthur> except for the things that aren't values
17:41:26 <ski> xenon_ : e.g. `()',`[]',`""',`(3,())',`Just ()',`Nothing' are not functions
17:41:36 <monochrom> but even if someone says, "True is a function", that does not bother me the most
17:41:49 <tac> jmcarthur: "value" has a technical meaning in FP that isn't quite that :)
17:41:51 <ijp> I've seen this confusion with scheme a few times, with people wondering why integers weren't church numerals
17:41:51 <jmcarthur> ski: "" could be a function, with OverloadedStrings
17:42:01 <ski> jmcarthur : true
17:42:05 <monochrom> what bothers me the most: you have to be indirect, you have to say "define g=True. is g a function?"
17:42:09 <jmcarthur> tac: did i say something that implied what a value is at all?
17:42:37 <monochrom> since you write "g=True", substitute equal for equal, "is g a function?" is the same question as "is True a function?"
17:43:36 <monochrom> it is a failure of highschool and university education that you have to give a name to a function before you can discuss it. just saying "True" or "(\x -> x+1)" is not enough.
17:43:53 <tac> monochrom: agreed
17:44:02 <JoeyA> serialhex: So I suppose when you want to, say, "morph" an object, you scan its Components looking for one that knows how to "morph" ?
17:44:05 <tac> "Let f(x) be a polynomial...."
17:44:31 <monochrom> oh, it gets better, tac. they write "let f(x)=x^2+1 be a polynomial"
17:44:33 <tac> And already, the child is hopelessly unable to distinguish functions from their evaluation at some mysterious point x
17:45:15 <ski> monochrom : .. or nonsense like `(d f(x) / d x)(3)'
17:45:17 <tac> monochrom: I saw a thread about how "the square root of 4 is plus or minus 2" earlier today. I quietly wept to myself.
17:45:29 <serialhex> JoeyA: yeah, or give it a property... like have an `position x y` component, and then a `move x y` that will change `position x y`
17:45:37 <tac> ski: dy/dx is nonsense notation to begin with >____>
17:45:41 <ikenov> monochrom: but could @pl be complete in principle? I was trying to think of whether there could be a "this sentence is false" in function terms.
17:45:46 * JoeyA thinks back to a StarCraft hack that would let you morph anything into anything it could "produce".  E.g. turn a probe into a Nexus.
17:45:53 <ski> tac : i used to think so for some years, but i changed my mind
17:46:00 <monochrom> I don't know
17:46:08 <serialhex> tac: dosn't dx/dy just equal x/y?  :P
17:46:22 <tac> heh
17:46:35 <tac> I spent my entire senior year making my math teacher cry
17:46:46 <tac> I would ace all the tests... but every test I used a different invented notation
17:46:51 <JoeyA> lol
17:46:58 <serialhex> nice!!  :P
17:47:12 <tac> because I couldn't figure out a way to make calculus notation coherent
17:47:17 <ski> first : view `d E / d x' as a macro for `(λ x ↦ E)(x)' (`x' being any variable, and `E' any expression)
17:47:29 <monochrom> when "" is a function: http://article.gmane.org/gmane.comp.lang.haskell.cafe/101620/
17:47:41 <ski> er, for `D(λ x ↦ E)(x)', rather
17:47:46 <tac> "What is a dx? Is it an integer? No... another kind of thing maybe? Well, you can cancel it.... sometimes...... and what the hell is with y being equal to f(x)??"
17:47:53 <ski> where `D' is our beloved differentiation HOF
17:48:16 <ski> tac : i don't know whether there is a sensible answer to those questions
17:48:34 <jmcarthur> xenon_: i would say that functional programming is really "value-oriented" programming. instead of necessarily *doing* something, an expression *means* something.
17:48:34 <tac> yes. it took me 4 years of college to realize that.
17:48:36 * geekosaur is tempted to invite misinterpretations of C's 0["a"]
17:48:37 <ski> however, it's useful to have a pointful alternative form for talking about derivatives
17:48:54 <tac> I don't deny leibniz notation is effective for solving problems
17:49:00 <mm_freak_> monochrom: i could have written that one
17:49:09 <tac> But why do schools only use math to train engineers? T___T
17:49:11 <ski> tac : however, `d y / d x' is another matter
17:49:13 <serialhex> ski: how are you doing all the spiffy utf chars?  you have a nice program to make that easier?
17:49:21 <ski> serialhex : it's called Emacs
17:49:30 <serialhex> -_-
17:49:53 <tac> That is also why I am so deeply fascinated by dependent types
17:49:57 <mm_freak_> serialhex: i do that using xmodmap…
17:49:58 <lispy> serialhex: learn agda and in the process you'll learn the agda-mode (in emacs) shortcuts for pretty unicode math symbols :)
17:49:58 * jmcarthur probably stands alone in thinking that   instance IsString b => IsString (a -> b)   might be a pretty useful instance
17:50:17 <tac> I wanted to know how to "make sense" out of logic.... to figure out a language that could be verified by a computer.
17:50:25 <mm_freak_> although i do even my algebra and plotting in emacs, IRC is about the only thing i don't do with it
17:50:31 <tac> sadly, I didn't find agda and coq until I was 4 years out of college
17:50:44 <lispy> jmcarthur: hmm...ShowS basically does that to have efficient append, right?
17:51:00 <ski> serialhex : there is a `TeX' input method in Emacs, of which i use the `Agda' variant (and then copy to Irssi, using GNU Screen)
17:51:05 <applicative> fromString f = fromString (f undefined)  -- ?
17:51:11 <jmcarthur> lispy: the ideas might be related
17:51:18 <ski> lispy : yes
17:51:26 <JoeyA> serialhex: How about Map (EntityId, ComponentTag) Component
17:51:29 <mm_freak_> applicative: that's a type error
17:51:32 <mm_freak_> :t fromString
17:51:33 <lambdabot>     Not in scope: `fromString'
17:51:33 <lambdabot>     Perhaps you meant `showString' (imported from Prelude)
17:51:40 <mm_freak_> :t Data.String.fromString
17:51:41 <JoeyA> data ComponentTag = PositionTag | HealthTag | ...
17:51:41 <lambdabot> Data.String.IsString a => String -> a
17:51:47 <jmcarthur> applicative: fromString = const
17:51:48 <elliott> ski: obviously should use an emacs terminal
17:51:50 <JoeyA> data Component = Position ... | Health ... |
17:51:58 <elliott> jmcarthur: const . fromString, to be precise
17:52:05 <jmcarthur> elliott: woops, yes
17:52:06 <mm_freak_> but i often have this:  fromString = pure
17:52:11 <ski> elliott : .. or rcirc or something, perhaps
17:52:14 <applicative> what am I thinking of course. const . fromString how is that useful
17:52:15 <mm_freak_> (of which fromString = const is a special case, of course)
17:52:19 <serialhex> JoeyA: hmm... okay
17:52:20 <jmcarthur> applicative: fromString = const . fromString   as elliott points out
17:52:40 <JoeyA> serialhex: Is that what you're shooting for?
17:52:42 <applicative> yea no wonder I cant figure out Profunctor ...
17:52:42 <mm_freak_> as i think of it i realize that /all/ my IsString instances had fromString = pure
17:52:53 <jmcarthur> it's just like NumInstances
17:53:01 <mm_freak_> or rather:  fromString = pure . fromString
17:53:08 <JoeyA> Namely, a bunch of properties attached to entities in an ad-hoc fashion.
17:53:26 <jmcarthur> literals of all kinds typically have a pretty natural lifting through Applicative
17:53:48 <applicative> but the going Num instance for functions is a bit dull, no?
17:53:59 <mm_freak_> i'm still waiting for -XOverloadedFunctions
17:54:08 <jmcarthur> mm_freak_: inference would be nuts
17:54:16 <mm_freak_> sure =)
17:54:26 <jmcarthur> mm_freak_: trust me... i wrote a preprocessor to replace applications with ($) just so i could overload it...
17:54:48 <applicative> maybe conal should add applicative string to http://hackage.haskell.org/package/applicative-numbers
17:54:54 <mm_freak_> i don't question it…  overloading gone crazy =)
17:55:13 <jmcarthur> it was fun though
17:55:13 * applicative dimly remembers dolio had some template haskell that did that somehow
17:55:24 <jmcarthur> i enjoyed indexing into collections via function application
17:55:31 <mm_freak_> jmcarthur: on the other hand you could have function defaulting
17:55:32 <serialhex> JoeyA: kind of, though the components should be able to be easily added, like if in 2 years i want to add something, adding a `Component` and a `ComponentTag` for each thing i want to add... kind of wonky
17:55:38 <monochrom> holy smoke batman, "applicative can be numeric"
17:55:40 <keithdj> I shouldn't worry about including constant expressions in where blocks of functions should I? GHC will factor them out no problem won't it?
17:55:43 <applicative> whitespace was reinterpreted as whatever-applicative-functor <*>
17:56:03 <gnuwilliam> Hi guys
17:56:09 <applicative> hi gnuwilliam
17:56:15 <mm_freak_> keithdj: the constants will be shared, so it may even be a good idea
17:56:17 <gnuwilliam> I'm started to learn Haskell today and I'm really excited!
17:56:27 <ski> that's great !
17:56:30 <gnuwilliam> I'm reading this tutorial -> http://learnyouahaskell.com/introduction#about-this-tutorial
17:56:32 <mm_freak_> keithdj: f x = y + sin(y) where y = x^2
17:56:35 <gnuwilliam> Is it a good one to start?
17:56:37 <mm_freak_> x^2 will be calculated only once
17:56:41 <monochrom> don't write too many excited blogs
17:56:47 <mm_freak_> oh, did i actually write "sin(y)"?
17:56:53 <monochrom> yes it is a good start
17:56:53 <mm_freak_> worked too much with maxima lately
17:56:56 <applicative> gnuwilliam: excellent tutorial in the majority view
17:56:59 <serialhex> gnuwilliam: excellent!  learning haskell has been a pain in my butt since i started, but it's quite fun :D
17:57:02 <mm_freak_> keithdj: f x = y + sin y where y = x^2
17:57:04 <mm_freak_> sorry =)
17:57:04 <tac> gnuwilliam: cool. good luck :)
17:57:05 <keithdj> mm_freak_: great thanks, don't want to assume a sufficently clever compiler
17:57:07 <monochrom> haha maxima is ok
17:57:12 <gnuwilliam> Great!
17:57:14 <kini> it seems many packages on hackage broke because of http://hackage.haskell.org/trac/ghc/ticket/4865
17:57:14 <kini> is there some standard way to "fix" them? Maybe some other place where the old Prelude.catch is hiding?
17:57:32 <mm_freak_> keithdj: that's a safe assumption…  i'd say, a compiler that doesn't implement sharing, is severely broken
17:57:34 <kini> in particular I'm trying to build haskore-vintage on GHC 7.6.1
17:57:39 <applicative> gnuwilliam: if you have trouble with type errors and so on, post code on hpaste.org and people here can explain it
17:57:46 <JoeyA> serialhex: "adding a `Component` and a `ComponentTag` for each thing i want to add... kind of wonky"  Why so?
17:58:07 <JoeyA> It'd be pretty easy to do.  When you add a new Component, you know just where to put it.
17:58:18 <gnuwilliam> I'm really surprised with the number of users in this channel, I wasn't expecting much. The community looks great!
17:58:36 <monochrom> was 1000+ a few weeks ago
17:58:41 <mm_freak_> monochrom: i haven't found a good alternative to maxima either…  i know there is sage, but whenever i tried using it, i ran away crying
17:59:04 <serialhex> JoeyA: well, in order to add one thingi may have to add code in 2 or more places...  but that might not be too bad
17:59:05 <mm_freak_> perhaps it's just a stupid idea to do algebra in python
17:59:08 <gnuwilliam> Thanks for the answers, I will talk to you guys if I have any trouble :D
17:59:13 <Taslem> I think it's ranked as like #8 or so in size of channels on freenode.
17:59:22 <kini> mm_freak_: very early in Sage's history there was apparently a debate about what language to use
17:59:24 <jmcarthur> :t id + sin <<< (^2)
17:59:25 <lambdabot> (Floating c, Num (c -> c)) => c -> c
17:59:29 <kini> Python eventually won, over Haskell and OCaml
17:59:45 <applicative> grrr
17:59:51 <monochrom> fortunately, haskell and ocaml would not help
18:00:03 <tac> gnuwilliam: Haskell is the most active functional programming language on Freenode.
18:00:18 <mm_freak_> kini: that's probably why sage sucks…  feels like an imperative language with a lot of rewriters…  maxima feels more coherent and algebraic
18:00:22 <elliott> still in the top 5 channels, aren't we?
18:00:38 <applicative> oh maxima is a language??
18:00:41 <tac> Isn't there a lambdabot feature for that?
18:00:42 <tac> !users
18:00:44 <kini> maxima is written in ECL
18:00:44 <ByronJohnson> Exec: /bin/sh: Permission denied
18:00:47 <tac> @users
18:00:47 <lambdabot> Unknown command, try @list
18:00:50 <elliott> !users
18:00:51 <ByronJohnson> Exec: /bin/sh: Permission denied
18:00:54 <elliott> ByronJohnson: um...
18:00:56 <tac> lol
18:00:59 <mm_freak_> maxima itself is a language…  a weird one, but it's a language
18:01:01 <jmcarthur> preflex: ?users
18:01:02 <elliott> !list
18:01:03 <monochrom> elliott: http://hackage.haskell.org/packages/archive/pkg-list.html
18:01:06 <mm_freak_> and it's not lisp =)
18:01:06 <elliott> haha
18:01:12 <applicative> bizarre, the ! is actually making it to ghci
18:01:13 <elliott> monochrom: A+ bot
18:01:23 <gnuwilliam> tac: nice! I'm really excited to learn. I used to program in Python and JavaScript
18:01:27 <kini> mm_freak_: Sage actually uses maxima for much of its calculus stuff... through an expect interface, IIRC
18:02:00 <tac> gnuwilliam: Quick rundown. It's very different. You will get very frustrated, most likely. But it's worth it. And even if you never use it, it will make you a better developer in those languages.
18:02:08 <mm_freak_> i use PARI/GP when maxima sucks =)
18:02:30 <kini> Sage expects out to pari/gp as well, hahah
18:02:32 <gnuwilliam> tac: that's good to know! :-) Thanks for the words
18:02:35 <mm_freak_> lol
18:02:36 <kini> it's one giant ball of stuff
18:02:56 <jmcarthur> gnuwilliam: add to that rundown... you will not like other languages as much as you used to, even if you don't end up sticking with haskell in the long run. that's a downside
18:02:57 <mm_freak_> anyway, sage is stupid…  you actually have to declare your variables…
18:02:59 <elliott> gnuwilliam: if you haven't already found an introduction to read:
18:03:00 <elliott> @where lyah
18:03:01 <lambdabot> http://www.learnyouahaskell.com/
18:03:02 <elliott> is good
18:03:10 <monochrom> he has
18:03:12 <ski> gnuwilliam : also, don't hesitate to ask here when you're wondering about something -- and it might be interesting to lurk on what others talk about in here as well
18:03:15 <tac> jmcarthur: heh. true...
18:03:19 <JoeyA> serialhex: See if you can write a stub interface that provides the accessors you want.
18:03:21 <kini> mm_freak_: it's worse than that, when you declare your variables they are automatically made global
18:03:26 <serialhex> lurking in here is always fun
18:03:27 <kini> there's no scoping of symbolic variables
18:03:30 <serialhex> ...and interesting
18:03:43 <mm_freak_> kini: really?  how did sage get that popular?
18:03:51 <JoeyA> E.g. updatePosition :: EntityId -> Int -> Int -> Game ()
18:03:51 <jmcarthur> serialhex: where else do you get to learn about zygohistormorphic prepromorphisms?
18:04:03 <jmcarthur> *zygohistomorphic
18:04:04 <kini> mm_freak_: lots of funding, lots of enthusiasm, and the python community
18:04:06 <jmcarthur> a common typo
18:04:07 <serialhex> jmcarthur:  wikipedia
18:04:10 <serialhex> :P
18:04:12 <monochrom> people love global variables. it makes sage popular
18:04:14 <mm_freak_> i see
18:04:20 <jmcarthur> serialhex: but when you would you thought to google it?
18:04:24 <shachaf> monochrom: global variables are so easy
18:04:24 <jmcarthur> *you have
18:04:27 <JoeyA> or statePosition :: EntityId -> (Position -> (a, Position)) -> Game a -- get and set in one operation
18:04:28 <kini> anyway, mathematicians often don't care about being "nice" on the programming language level (ironically enough)
18:04:34 <kini> as long as they can get their computations done
18:04:40 <serialhex> jmcarthur: never
18:04:48 <jmcarthur> point stands
18:04:57 <kini> the beautiful cathedrals exist in their minds and on their notebook paper, computers are just workhorses :P
18:05:02 <serialhex> jmcarthur: i never tried to deny it!
18:05:25 <applicative> the have a dim opinion of computation, and are thus indifferent to the merits of programming language
18:05:29 <applicative> s
18:05:33 <gnuwilliam> Wow, nice! You guys are very receptive, that's really a good point. ;) I won't hesitate to ask something here
18:05:48 <JoeyA> serialhex: coming up with game state accessors without worrying about their implementation may provide some insights.
18:05:50 <kini> (full disclosure, I'm a Sage dev in some capacity lol)
18:06:06 <applicative> they think programming is just engineering; so of course it should look like C
18:06:19 <mm_freak_> kini: it's not a matter of beauty…  sage is too difficult…  you're distracted by a lot of stupid meta-stuff you have to do…  sage : maxima = C : haskell
18:06:35 <monochrom> they like python because of the notation f(x)
18:07:23 <serialhex> JoeyA: i'm thinking about it... but i'm still very new, so i'm having a hard time coming up with anything
18:07:24 <JoeyA> But if your game state API is clean and type-safe (i.e. doesn't let you do things that are clearly wrong), you can use whatever messy implementation you want inside.  The mess will be confined to the module.
18:07:35 <ski>   "The above has been triggered by a recent incident, when, in an emotional outburst, one of my mathematical colleagues at the University —not a computing scientist— accused a number of younger computing scientists of \"pedantry\" because —as they do by habit— they started numbering at zero. He took consciously adopting the most sensible convention as a provocation."
18:07:39 <applicative> monochrom: maybe we should convince them this is necessary in haskell
18:07:40 <ski>   "Why numbering should start at zero" by Edsger Wybe Dijkstra in 1982-08-11 at <http://www.cs.utexas.edu/~EWD/transcriptions/EWD08xx/EWD831.html>
18:07:46 <mm_freak_> i guess the only advantage of sage over maxima is that you don't need an emacs mode to make it easy to use =)
18:07:51 <kini> monochrom: but they dislike python notation enough to pass all input through a preparser, thus making the Sage language a slight variant of Python
18:07:56 <applicative> > let square(x) = x*x in square(3)
18:07:58 <lambdabot>   9
18:08:00 <serialhex> JoeyA: you have messes in your modules!?!?!?  (fakes pure horror)
18:08:10 <kini> even more fun, the preparser is not any kind of principled parser or anything, it's just a string search and replace machine
18:08:29 <JoeyA> Well, a mess *inside* of a module is a lot better than a mess outside a module, or worse, spanning several modules.
18:08:33 <tac> God didn't invent the integers. Have you ever tried to write the basic integer type in Agda? It's a PITA. God made the naturals. Man later got frustrated it didn't form a group and invented the rest.
18:08:47 <kini> in Sage, there are global state variables that affect the syntax of the language :)
18:08:57 * ijp cries
18:09:01 <applicative> ski: that argument of Dijkstra is decisive evidence, if any were needed, that he was a machine
18:09:23 <mm_freak_> lol
18:09:45 <kini> haha, that's one of my favorite EWDs
18:09:52 <JoeyA> serialhex: To answer your question, no.  All of my code is perfect.  Hire me.
18:10:03 <tac> One thing that makes me a little uncomfortable is that some category theorists sometimes talk about n-things
18:10:11 <jmcarthur> tac: if it's too complicated for Man then surely God was responsible for the creation of Z
18:10:17 <tac> where n is *usually* a natural, but sometimes also a (-2)-thing or a (-1)-thing
18:10:26 <serialhex> JoeyA: i'm a broke-ass college student, i have no money to hire you :P
18:10:33 <JoeyA> Me neither :P
18:10:41 <serialhex> lol
18:11:32 <tac> If a point is a 0-simplex and a line segment is a 1-complex.... what kind of cruel God would make the empty set a (-1)-simplex?
18:11:33 <jmcarthur> JoeyA: your code may all be perfect, but how long does it take to write?
18:11:49 <JoeyA> serialhex: Do you know how to create packages that build with cabal?  Or at the very least, create programs with multiple modules?
18:12:06 <serialhex> JoeyA: ...very carefully
18:12:18 <JoeyA> jmcarthur: That's the catch.  ~7x as long as it should.
18:12:37 <ski> tac : cf. degree of zero polynomial
18:12:55 <jmcarthur> JoeyA: so all i need is seven of you!
18:13:22 <tac> ski: perhaps the index is of type Maybe Nat
18:13:30 <mm_freak_> jmcarthur: if the work is embarassingly parallel
18:13:33 <dolio> tac: Naturals start at -2.
18:13:35 <dolio> Obviously.
18:13:38 <tac> obviously :P
18:13:42 <mm_freak_> otherwise that formula whose name i always forget holds
18:14:04 <serialhex> JoeyA: i've been mainly working on usiing one module...and learning how cabal works (or dosn't work)
18:14:11 <tac> at least Voevodsky did the morally correct thing, bumped everything up by 2, and called it an hLevel.
18:14:21 <dolio> applicative: I'm not sure what you were talking about earlier, but it's hard to believe I had template haskell for anything.
18:14:28 <jmcarthur> mm_freak_: that's not the only way it could be true
18:14:33 <dolio> Since I don't like template haskell much.
18:14:46 <jmcarthur> mm_freak_: speculative evaluation can recover some time lost due to the problem not be embarassing enough
18:14:56 <jmcarthur> *being
18:14:59 <ijp> mm_freak_: amdahls law?
18:15:17 <mm_freak_> ijp: yeah
18:15:54 * hackagebot logict 0.6 - A backtracking logic-programming monad.  http://hackage.haskell.org/package/logict-0.6 (DanDoel)
18:16:39 <monochrom> updates for logict?!
18:16:47 <serialhex> JoeyA: though it's mainly b/c i havn't has a sufficent reason to learn, but if you give me a good enough reason to learn i can definately do that :)
18:16:48 <JoeyA> serialhex: if you're getting started, you could just put all your modules in a folder and ghc -Wall Main.hs (as of GHC 7, this builds all referenced modules)
18:17:05 <ski> tac : hm, you could define `deg p < n' as `forall i. i >= n. coeff p i = 0', and then you get `-1' from allowing `deg p =< n - 1' as an alternative form
18:17:31 <ski> (s/n./n ->/)
18:17:39 <serialhex> JoeyA: cool cool
18:18:25 <mm_freak_> dolio: what's new in logict?  i'm using it quite extensively
18:18:33 <dolio> >>- now has non-default fixity.
18:18:41 <dolio> It's now the same as >>=
18:18:49 <monochrom> \∩/
18:18:57 <mm_freak_> dolio: anything else?
18:19:00 <dolio> Nope.
18:19:06 <monochrom> darn. haha
18:19:27 <shachaf> ⎝∩⎠
18:19:35 <shachaf> Hmm, that looks more sinister.
18:19:53 <mm_freak_> alright, thanks =)
18:20:20 <parcs> hmm, looks like fixity changes aren't specified by the PvP
18:20:31 <monochrom> haha
18:20:43 <JoeyA> serialhex: Also, if you haven't already, learn how to work with monads.  In particular, learn how to implement a State monad.
18:20:55 <shachaf> parcs: I think they would be.
18:20:56 * hackagebot EdisonAPI 1.2.2 - A library of efficent, purely-functional data structures (API)  http://hackage.haskell.org/package/EdisonAPI-1.2.2 (RobertDockins)
18:20:58 * hackagebot EdisonCore 1.2.2 - A library of efficent, purely-functional data structures (Core Implementations)  http://hackage.haskell.org/package/EdisonCore-1.2.2 (RobertDockins)
18:21:22 <shachaf> Since a program can break by upgrading, even if it only used qualified imports.
18:21:30 <dolio> I bumped the major version just to be safe.
18:21:58 <shachaf> Perhaps you should add more lenses while you're at it.
18:22:16 <JoeyA> The ironic thing about packages like transformers and arrows is that you pretty much have to implement them yourself to understand how to use them.
18:22:17 <dolio> Hmm....
18:22:28 <serialhex> JoeyA: yes, the inevitable Monad...
18:22:28 <JoeyA> Sort of like math.
18:22:29 <dolio> I'm not sure what lenses would go in there.
18:22:39 <dolio> It's not much of a data structure.
18:22:49 <dolio> I guess I could add some traversals.
18:23:04 <shachaf> Those are good too.
18:23:08 <shachaf> Prisms? Isomorphisms?
18:23:18 <shachaf> You could always add some type equalities.
18:23:24 <edwardk> hrmm, logict traversals
18:23:37 <dolio> It's a list.
18:23:45 <dolio> I could add cons prisms.
18:23:52 <dolio> edwardk likes those.
18:23:59 <edwardk> =)
18:24:07 <JoeyA> serialhex: Well, just write a whole bunch of functions like updatePosition :: EntityId -> Int -> Int -> GameState -> GameState until you get tired of threading GameState around.
18:24:08 <shachaf> _Cons is slightly evil. :-(
18:24:16 <edwardk> the dependency for that is kinda evil though =/
18:24:17 <dolio> It's not quite a list, though.
18:24:20 <edwardk> yeah
18:24:26 <edwardk> shachaf: whats wrong with _Cons?
18:24:35 <edwardk> too ad hoc for you?
18:24:47 <shachaf> Somewhat, yes.
18:24:55 <shachaf> Also, there's no constructor named Cons!
18:25:08 <edwardk> it forms a series of internally consistent laws with _head, _tail, uncons, cons
18:25:15 <serialhex> JoeyA: and then what?
18:25:20 <edwardk> by its very construction
18:25:39 <serialhex> JoeyA: pray???
18:26:39 <JoeyA> serialhex: a State monad threads state like this for you.
18:27:42 <JoeyA> Implementing a State monad is pretty easy, but will give you a good feel for what monads are about.
18:27:58 <tac> State monads are great monads.
18:28:32 <serialhex> hmm... any linkage on where to learn about State monads?
18:29:27 <monochrom> http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
18:29:35 <JoeyA> http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State
18:29:51 * ski thinks "What the hell are Monads?" by Noel Winstanley in 1999 at <http://www-users.mat.uni.torun.pl/~fly/materialy/fp/haskell-doc/Monads.html> is nice, though it's a bit old
18:30:08 <lispy> dolio: Is the expected use of logict inplace of tools like prolog?
18:30:43 <JoeyA> serialhex: also, you have to write a monad tutorial.  It is a rite of passage for Haskell programmers.
18:30:56 <dolio> Any time you want to do some kind of backtracking search stuff.
18:31:03 <lispy> Have you guys seen this: http://softlang.wikidot.com/course:sle1213
18:31:12 <lispy> That looks like a really good course
18:31:13 <JoeyA> (Haskell in-joke)
18:31:30 <lispy> dolio: I already knew that much for the description of it on hackage :)
18:31:41 <lispy> dolio: My question may not make sense though
18:31:44 <serialhex> JoeyA: i got it anyway :D  there are enough monad tutorials, and i
18:31:50 <serialhex> ve been around long enough to get it
18:31:55 <JoeyA> ah, okay
18:32:23 <dolio> lispy: I think Prolog implementations tend to use more clever strategies than are in logict.
18:32:24 <lispy> dolio: Basically, I think like this: I tried to learn prolog and it bit me. I feel like a number of puzzles I have day-to-day could be efficiently solved with prolog. Therefore, I'm sometimes on the lookout for a Haskell-based replacement to prolog :)
18:33:03 <lispy> dolio: curry is probably close to what I want, but it's bitrotted?
18:33:18 <dolio> LogicT is a church encoded version of 'ListT m a = m (1 + a * ListT m a)'
18:33:25 <serialhex> JoeyA: i personally like one that a guy wrote that explains monads in a more math-centric way, going from a function, to a map, then a monad...
18:33:29 <serialhex> ...or something
18:33:29 <ski> lispy : iirc, there's no logic variables in `LogicT' (is there ?)
18:33:37 <dolio> No, nothing like that.
18:33:41 <lispy> ah
18:34:01 <lispy> Someone make a PrologT monad then :)
18:34:23 * ski sortof made one, years ago
18:35:23 <lispy> ski: I wonder if recursive do would be useful for a PrologT seems like that would give you a natural form of logic variable
18:35:57 <ski> (as a project for a course -- it's actually in one aspect more powerful than Prolog; which was my main interest at that time)
18:36:38 <ski> lispy : heh, i've made some experiments with something like that ;)
18:37:12 <ski> (iiuc what you were implying)
18:37:30 <lispy> I bet LogicT would be handy for doing register allocation algorithms in the backend of a compiler
18:37:31 <sm> johnw: how do you load up sizes in ghci, if you do ?
18:37:49 <johnw> see `runSizes`
18:37:53 <lispy> ski: probably, but I'm not very good with recursive do. I read some TMR articles and now I'm going pro ;)
18:38:03 <johnw> oh, hmm... maybe I don't anymore
18:38:15 <sm> johnw: it's just that I can't load it because of the C/FFI
18:38:17 <johnw> you just need to fabricate a default SizesOpts
18:38:19 <johnw> ohhh
18:38:24 <johnw> no, I don't bother trlying to do that anymore
18:40:01 <sm> so I wonder how to load up a hs/c project in ghci. I tried naming the c/h files as extra arguments and it complains about missing HsFFI.h, even with -I/path/to/it
18:40:45 <lispy> sm: -I doesn't take a full path, perhaps you overspecified?
18:40:55 <lispy> it takes the path excluding the filename
18:41:07 <sm> yup I had it right
18:41:36 <lispy> sm: not sure without experimenting then
18:41:46 <sm> not sure why I would have to specify it anyway since it came with GHC
18:41:55 <lispy> sm: you might try cabal-dev ghci and see if that magically just works
18:42:11 <ski> lispy : i would have to ponder for a while to reconstruct the ones i was thinking of ..
18:45:44 <sm> lispy: installing that would break my world, I'll try on another machine some time. cabal-ghci didn't help. I actually can load it with ghci, running is the problem (it can't see the c module). I'm not sure how to run such programs interpreted
18:46:12 <sm> and this topic is strangely ungoogleable
18:46:21 <lispy> ski: checkout the second talk here: http://www.cs.uu.nl/research/techreps/repo/CS-1999/1999-28.pdf
18:47:17 <lispy> sm: what if you compile it and feed ghci the .o? ghc foo.c -> ghci foo.o
18:49:01 <Kallikanzarid> fib = 1:1:(zipWith (+) fib (tail fib))
18:49:28 <shachaf> ✔
18:49:58 <sm> lispy: aha! I just found the magic, and you're  right: ghci HsStat.o Main.hs
18:49:59 * ski spots a heathen
18:50:02 <sm> thanks
18:50:47 <lispy> sm: yw, glad we figured it out
18:50:47 <ski> lispy : do you mean "Embedding Prolog in Haskell" by Silvija Seres and Mike Spivey ?
18:51:04 <lispy> ski: yeah, I just started read it
18:53:15 <ski> lispy : my project was based on that, and on the later paper "Typed Logical Variables in Haskell" by Koen Claessen,Peter Ljunglöf in 2000 at <http://www.cs.nott.ac.uk/~gmh/papers/20.ps>
18:55:00 <lispy> thanks
19:00:56 * hackagebot hs-excelx 0.5.2.0 - HS-Excelx provides basic read-only access to Excel 2007 and 2010 documents in XLSX format.  http://hackage.haskell.org/package/hs-excelx-0.5.2.0 (MarkBaran)
19:02:09 <tieTYT2> fst :: (a, b) -> a    is this saying that this function will return the first part of the pair or is it saying it will return the same type as the first part of the pair?
19:02:48 * lispy wonders why MarkBaran didn't contribute to SpreadSheetML a project with the same goals
19:02:51 <tieTYT2> ... I think it's the second.  If I defined a fstPlus1 that added one to the first part, it'd have the same signature
19:03:52 <monochrom> see my http://groups.google.com/group/comp.lang.haskell/msg/a1444af2476a6a53
19:03:56 <tieTYT2> actually it'd be: fstPlus1 :: Num a => (a, t) -> a
19:04:07 <tieTYT2> can someone answer my original question just so I know I'm right?
19:04:16 <monochrom> see my http://groups.google.com/group/comp.lang.haskell/msg/a1444af2476a6a53
19:04:54 <tieTYT2> monochrom: is that for me?
19:04:59 <monochrom> yes
19:05:50 <tieTYT2> as far as I can tell, that's answering the question of, "What does fst do?"
19:05:58 <tieTYT2> well, "how is fst implemented?"
19:06:03 <tieTYT2> that's not the same question I'm asking
19:06:17 <applicative> @type let tieTYT2 (x,y) = x in tieTYT2
19:06:19 <lambdabot> (t, t1) -> t
19:06:25 <monochrom> no, my article does not rely on how to implement. only on type.
19:06:49 <applicative> @type let tieTYT2 (x,y) = x in tieTYT2 (text "hello", 22)
19:06:50 <ski> @free fst :: (a, b) -> a
19:06:51 <lambdabot> Doc
19:06:51 <lambdabot> f . fst = fst . $map_Pair f g
19:07:01 <applicative> > let tieTYT2 (x,y) = x in tieTYT2 (text "hello", 22)
19:07:02 <lambdabot>   hello
19:07:22 <monochrom> "Now I use it to prove: e1 = fst (e1, e2)"
19:07:33 <lispy> ski: do you know if dolio's LogicT is essentially the same as the BacktrT given in the second paper you linked?
19:07:39 <monochrom> e1 = fst (e1,e2) is the logical conclusion, not the premise
19:07:47 <lispy> ski: it sounds similar, but I'm not sure which details to check
19:07:53 <dolio> BacktrT is different.
19:07:58 <dolio> I think.
19:08:09 <lispy> dolio: you're not ski ;)
19:08:14 <lispy> dolio: thanks :)
19:08:24 * ski is not dolio
19:08:49 * applicative is not ski either
19:09:20 <applicative> tieTYT2: was anyone answering your question intelligibly?
19:09:30 <dolio> lispy: Oh, that paper isn't what I was expecting.
19:09:36 <monochrom> I would think my answer is intelligible
19:09:47 <dolio> lispy: Oleg has a FBacktrack 'monad' that's different from LogicT.
19:09:54 <monochrom> fine. whatever.
19:10:54 <lispy> dolio: hmm...okay
19:10:58 <dolio> lispy: I'm not sure if BacktrT is exactly the same, but it's probably similar.
19:10:59 <tieTYT2> monochrom: I understand the first half of your answer.  The second half goes over my head
19:11:05 <dolio> Similar to LogicT, that is.
19:11:06 * lispy wonders if the stuff in this paper is already on hackage in some form
19:11:59 <tieTYT2> monochrom: basically, if the signature is (a, b) -> a   it has to mean that it's returning the input because to do anything else with it would require some java-like instanceof usage of the "a" and as a result it wouldn't be a polymorphic function anymore.  Right?
19:12:12 <monochrom> yes
19:12:58 <tieTYT2> cool, that said, the reality of the situation is that signature is really talking about how the "a" is the same type
19:13:42 <tieTYT2> through a proof, you know the "a"s are the same value, too.  But the signature is _saying_ that they're the same type
19:15:26 <tieTYT2> I really should just start from another example:  head :: [a] -> a
19:16:21 <tieTYT2> that's just saying that the input is a list of a type and the output is a single value of that same type
19:16:33 <Eduard_Munteanu> It would break parametricity, rather. I think there are type-theories in which you can match on types.
19:16:47 <monochrom> from the type [a]->a, I conclude that (head xs) cannot return an item not already in xs
19:17:38 <tieTYT2> monochrom: i see
19:18:20 <monochrom> also, suppose head ([x,y,z] :: [Int]) returns z. then head ([a,b,c] :: Bool]) returns c.
19:18:53 <monochrom> screw return. s/returns/=/
19:18:53 <ski> lispy : in my case, i used `newtype Logic m o a = L (forall n p . ContStack m n => Bool -> (a -> (o -> n p) -> n p) -> (o -> n p) -> n p)' instead of that `newtype BacktrT m a = BTT (forall ans. (a -> m [ans]) -> m [ans])'
19:19:30 <lispy> ski: so you had type indexes that mean what?
19:19:31 <ski> :)
19:20:36 <lispy> ski: I supposed since I'm not familiar with ContStack I probably can't guess what that type means :)
19:20:37 <monochrom> yes Eduard_Munteanu, programming language textbooks discuss both
19:20:47 <tieTYT2> monochrom: that's because head is polymorphic and can't do different things depending on the type, right?
19:20:48 <ski> lispy : `a' is the type of the result value, `o' is an experiment, to make it more symmetric (and easier to code), `m' is the "bottom" monad
19:20:54 <monochrom> yes
19:21:56 <tieTYT2> ok cool.  I think I get your lesson
19:22:35 <Eduard_Munteanu> monochrom: they do, usually? I'm referring to an eliminator for *, perhaps you're thinking of less type-theoretic languages (say ad-hoc polymorphism).
19:23:59 <jollytime> why do I need to use `` around `elem` when sectioning?
19:24:10 <ski> lispy : anyway, can you follow the version `newtype BacktrT m a = BTT (forall o. (a -> m o -> m o) -> m o -> m o)' ?
19:24:14 <monochrom> to first obtain an infix operator
19:24:15 <shachaf> Because `` makes identifiers infix.
19:24:24 <edwardk> :t iso
19:24:25 <lambdabot> (Functor f, Isomorphic k) => (s -> a) -> (b -> t) -> k (a -> f b) (s -> f t)
19:24:26 <Eduard_Munteanu> jollytime: sections only make sense for infix operators
19:24:29 <shachaf> Cale!
19:24:40 <jollytime> aha, I see, thanks
19:24:41 <jollytime> :)
19:24:43 <monochrom> I am thinking of ad-hoc polymorphism, yes
19:25:00 <shachaf> monochrom: i love ad-hoc polymorphism
19:25:16 * cmccann prefers ad-hoc monomorphism.
19:25:33 <Eduard_Munteanu> monochrom: ah, I see. I think dolio mentioned Set eliminators in #agda back when I was wondering about it, sounded pretty fancy in that context.
19:25:45 <lispy> ski: yeah, roughly
19:26:05 <ski> lispy : in `BTT (\succeed fail -> ..(let redo = ... in ..(succeed result redo)..)..fail..)'. `succeed' is the success continuation, and `fail' the failure continuation
19:26:07 <M30W> Are there any benchmarks for snap vs happstack vs yesod?
19:26:47 <ski> lispy : the success continuation takes a failure continuation as argument, which is where to go if the computation after the current one backtracks
19:27:27 <lispy> ski: okay, that makes sense
19:27:35 <ski> lispy : in case you don't want to add an alternative at this moment, you just pass `fail' as the `redo' argument -- otherwise you could try another thing (and eventually `fail' on some later backtrack back into the current goal)
19:29:06 <ski> lispy : now, we can first change the type to `newtype BacktrT m o a = BTT (forall p. (a -> (o -> m p) -> m p) -> (o -> m p) -> m p)', to make the two-stage CPS nature of it more apparent
19:30:12 <ski> iow, `newtype BacktrT m o a = BTT (forall p. (a -> ContT p m o) -> ContT p m o)'
19:30:29 <ski> iow, `newtype BacktrT m o a = BTT (forall p. ContT o (ContT p m) a)'
19:30:40 <lispy> and that's how you get to ContStack?
19:30:45 <ski> not quite
19:31:08 <ski> my goal was to implement a kind of implication
19:31:34 <ski> where `( Foo => Bar )' would generate each solution of `Foo', and call `Bar' for each such solution
19:32:09 <ski> in Prolog, you can write this as `\+ ( Foo,\+ Bar )' (`\+' is Prolog's negation-as-failure)
19:32:26 <ski> however, this can only detect whether `Bar' holds for each solution of `Foo'
19:32:52 <ski> it can't actually compute any information that you export from this goal (by instantiating variables)
19:33:11 <ski> (well, you can cheat by using side-effects, to export information, but that's not nice)
19:33:26 <ski> so, i wanted to lift this restriction
19:33:38 <ski> lispy : do you know basic Prolog syntax ?
19:36:58 <lispy> ski: sorry, I got pulled away by something else
19:37:12 <lispy> I barely know prolog
19:37:17 <lispy> syntax or otherwise
19:37:26 <ski> do you have time now, or should we perhaps continue another time ?
19:37:49 <ski> hm, ok
19:38:38 <ski> consider a goal `( member(X,[0,1,2]) => p(X) )'
19:39:00 <ski> the antecedent here has solutions `X = 0',`X = 1',`X = 2'
19:39:40 <ski> iow, the antecedent is logically equivalent to `( X = 0 ; X = 1 ; X = 2 )' (where `;' is disjunction)
19:40:08 <ski> so, our implication is logically equivalent to `( ( X = 0 ; X = 1 ; X = 2 ) => p(X) )'
19:40:43 <ski> which is logically equivalent to `( X = 0 => p(X) ),( X = 1 => p(X) ),( X = 2 => p(X) )'
19:40:52 <ski> which is logically equivalent to `p(0),p(1),p(2)'
19:41:14 <monochrom> are you use ; for disjunction, , for conjunction?
19:41:22 <ski> so, i want `( member(X,[0,1,2]) => p(X) )' to behave similarly as `p(0),p(1),p(2)' (`,' is conjunction in Prolog, yes)
19:42:00 <ski> now `p(X)' here really stands for any goal possibly mentioning `X', and possibly other (nonlocal) variables as well
19:42:17 <ski> perhaps we had `q(X,Y)' instead
19:42:36 <ski> so the implication then amounts to `p(0,Y),p(1,Y),p(2,Y)'
19:42:41 <ski> er, s/p/q/
19:43:26 <ski> and we want these calls to q/2 to be able to instantiate `Y', based on the other argument passed to q/2
19:44:36 <ski> if we write in Prolog `\+ ( member(X,[0,1,2]),\+ q(X,Y) )', then the `q(X,Y)' call here will instantiate `Y' accordingly to the value of `X' (computed by the member/2 call)
19:45:01 <ski> but, when the negation `\+ q(X,Y)' finishes, it discards any instantiations made by it
19:45:10 <ski> similarly for the outer instantiation
19:45:22 <ski> i want the instantiations made by the inner negation to persist
19:45:58 <ski> the other problem occurs if `q(X,Y)' can have multiple solutions (say `X + 1' solutions)
19:46:32 <ski> then `( member(X,[0,1,2]) => q(X,Y) )', which ought to be equivalent to `q(0,Y),q(1,Y),q(2,Y)' ought to have `1 * 2 * 3', i.e. `6' solutions
19:47:39 <ski> to compute a single one of these solutions, we must :
19:47:50 <ski> find the first solution of the antecedent, and then find the first solution of the corresponding succedent
19:48:32 <ski> (assuming the succedent succeeded) we now backtrack the antecedent, seeking a new solution of it (*without* backtracking the succedent)
19:49:12 <ski> if we find any more such solution, we invoke the succedent anew with it, looking for a solution
19:49:25 <ski> and so on, until we have exhausted the solutions of the antecedent
19:49:42 <dublisk> in haskell, you can't e.g. create an array, then modify it? you don't have mutable variables?
19:49:48 <ski> then, the funny thing :)
19:49:57 <monochrom> there are mutable arrays
19:50:49 <ski> to find the next solution of the implication, we first try to find the next solution of the last invocation of the succedent (if there is any, we have a new complete solution. this is known, so let's suppose we didn't find a solution here)
19:51:06 <ski> then, we must now *backtrack* backtracking itself :)
19:51:35 <lispy> ski: sorry, I'll have to continue later. Thank you for taking the time to explain so much
19:51:41 <ski> so that we go back to the next to last solution of the antecedent, so it can be used when searching for an alternative solution of the corresponding succedent invocation
19:52:02 <ski> this business of backtracking the backtracking process is very strange
19:52:16 <ski> to model it, i need not just two, but *three* continuation levels
19:52:31 <ski> and, i of course want to be able to left-nest implication as many times as i want
19:52:55 <ski> so, the result is that i, in a sense, need an *infinite* number of continuation levels ;)
19:53:47 <ski> however, i still need a bottom level, which can e.g. be `IO' or `ST s', so that i can implement the basic mutation commonly used to implement logic variables efficiently
19:54:27 <ski> i only have a "potential infinity" here -- the user of a goal determines how many continuation levels they want to use it with
19:54:50 <ski> if `( Foo => Bar )' is used with `n+2' levels, then `Foo' is used with `n+3' levels, and `Bar' with `n+2' levels
19:56:43 <ski> lispy : so, the purpose of `ContStack m n' is to be able to lift actions in the basic monad `m' up to the level of the `n' monad -- (and also to provide *trailed* update of mutable cells, that will be undone when backtracking, and where the undoing will be undon when backtracking backtracking, &c.)
19:58:04 <ski> it is defined as `class (Monad m,Monad n) => ContStack m n | n -> m where liftStack :: m a -> n a; trailedWriteRef :: MonadRef ref m => ref a -> a -> a -> Bool -> (() -> (o -> n p) -> n p) -> (o -> n p) -> n p'
19:58:23 <ski> with instances `instance Monad m => ContStack m (IdentityT m)' and `instance ContStack m n => ContStack m (ContT q n)'
19:58:42 <ski> lispy : and that's basically it
19:59:13 <ski> dublisk : do you need a mutable array ?
19:59:26 <dublisk> I guess so
19:59:44 <ski> what are you wanting to do ?
19:59:47 <dublisk> I don't know, I'm just thinking about something and the most natural solution is to use a mutable array
19:59:53 <dublisk> at least, most natural for me.
20:00:08 <ski> dynamic programming ?
20:00:15 <dublisk> Just a sieve of eratosthenes
20:00:40 <mm_freak_> for the sieve of eratosthenes a mutable array is indeed the most natural solution
20:00:45 <mm_freak_> and also the fastest
20:01:59 <dublisk> should I use Vector then?
20:02:10 <mm_freak_> i suggest STUArray in this case
20:06:40 <monochrom> Data.Vector.Unboxed.Mutable
20:09:19 <mm_freak_> mutable vectors are slower than mutable arrays
20:09:34 <monochrom> wait, I thought it was the opposite
20:09:52 <monochrom> then again, I have not tested
20:15:47 <dublisk> sorry about silly question, but can you not define multiline functions like doing (let x = 3; let y = x*x; return y)
20:17:09 <shachaf> > let x = 3; y = x*x in y
20:17:10 <lambdabot>   9
20:17:19 <shachaf> Oh, that's not what you wanted.
20:17:26 <shachaf> Or is it?
20:17:28 <shachaf> I don't know what you wanted.
20:17:38 <dublisk> I guess that, but in a function
20:19:49 <shachaf> > let f x = let y = x*x in y in f 5
20:19:50 <lambdabot>   25
20:20:04 <dublisk> so you have to have it as a single expression?
20:20:13 <shachaf> What does that mean?
20:20:18 <shachaf> Everything in Haskell is expressions.
20:20:31 <shachaf> What's something you'd want to write that you can't?
20:20:44 <fragamus> to lift or not to lift….   I have a choice of using fmap  or to lift my function into the monad     which is better style
20:20:47 <shachaf> Note: "return" has nothing to do with functions that "return" things.
20:21:00 <shachaf> Use fmap.
20:21:17 <fragamus> that's good enough for me
20:21:29 <S11001001> fragamus: you  mean a fun that would otherwise be pure?
20:21:39 <fragamus> yes
20:22:02 <dublisk> schachaf: I mean, like having multiple expressions for a single function...
20:22:56 <S11001001> dublisk: shachaf started out by fixing your example and showing it worked with lambdabot; what more do you want?
20:22:57 <shachaf> What does that mean?
20:23:08 <dublisk> I'm not sure how to describe it other than in the pseudo code
20:23:41 <S11001001> fragamus: I would think lift then.  That is, use fmap but outside :]
20:23:41 <shachaf> > let { foo x = let { y = x*x; z = y + 1 } in z } in foo 5
20:23:42 <lambdabot>   26
20:25:47 <fragamus> wait are you saying something different than shachaf
20:26:56 <shachaf> I think if your function works as A -> B, there's not much point in defining it as m A -> m B.
20:27:12 <fragamus> yes that is the situation
20:30:58 <gnuwilliam> Hey guys, someone here actually works with with Haskell in a company or something like that? I heard that is a bit difficult to find a job
20:31:11 <fragamus> yes
20:31:25 <fragamus> its like being a bostwainian lumberjack
20:31:45 <gnuwilliam> haha lol
20:32:44 <fragamus> I have never met another haskell coder
20:32:50 <Pseudomander> Hey there, a friend of mine is hosting the server demonstrated here, http://www.haskell.org/haskellwiki/Implement_a_chat_server#Trivial_server. (Only the trivial example)
20:33:02 <gnuwilliam> I think here will be more difficult, I live in Brazil. It's all about PHP, Java and sometimes Python
20:33:06 <stepcut> gnuwilliam: I've been a full time haskell developer for around 10 years
20:33:21 <fragamus> wow cool
20:33:24 <monochrom> dublisk: if "let {x=3; y=x*x} in y" does not fit your context, then you need to show more context. note: you can break that into 3 lines.
20:33:27 <Pseudomander> And we're trying to connect to it via python, if someone know's both I was wondering if they could possibly lend an eye to help us conclude why it may not be connecting
20:33:38 <gnuwilliam> stepcut: sounds awesome!
20:33:57 <monochrom> if you say, "in a function", sure: "g p = let {x=p; y=x*x} in y"
20:35:18 <monochrom> haskell coders are like python optometrists. there is no lens in python.
20:35:34 <dublisk> I guess I'm just seeing all the functions as single expressions, as opposed to doing something like "let x = 3; let y = 5; let z = 3*5; return sqrt(3*5)", which would be 4 expressions.
20:35:45 * stepcut goes to bed now
20:35:47 <dublisk> but I'm just trying to understand that basics
20:36:20 <shachaf> dublisk: There is no "return"
20:36:37 <shachaf> Forget about "return". There are only expressions.
20:36:41 <shachaf> With that said:
20:36:54 <shachaf> > let { x = 3; y = 5; z = 3*5 } in sqrt (3*5)
20:36:56 <lambdabot>   3.872983346207417
20:37:19 <dublisk> k
20:37:22 <luite> w00t ghcjs runs on ghc head now \o/
20:37:33 <monochrom> h p = let { x = 3; y = 5; z = 3*5 } in z.  you can call that 1 expression, or 4 expressions. I don't see the difference.
20:38:16 <monochrom> you can also write: h p = z where {x=3; y=5; z=x*y}. same difference
20:38:33 <monochrom> in all of the above, you can use multiple lines, not one single line. same difference
20:38:54 <dublisk> ok
20:42:56 <monochrom> I now think that "unlearning" only scratches the surface
20:44:25 <monochrom> there are more than unlearning. there are a lot of prejudices and personal convictions you must give up.
20:57:48 <mm_freak_> luite: did it get easier to install GHCJS?
20:59:39 <luite> mm_freak_: no not yet, but it's one of the steps. with GHC 7.8 you can hopefully build 32 bit javascript code with a 64 bit compiler, might need a few changes to GHC itself
21:00:21 <mm_freak_> i wonder why for all compilers in the world cross-compilation is so difficult
21:00:31 <luite> mm_freak_: building the base libraries from a GHC tree works fairly reliably now here, i'll probably add a quick boot option that downloads prebuilt base libs for your compiler
21:01:05 <mm_freak_> luite: is GHCJS a proper GHC backend?
21:02:15 <luite> mm_freak_: atm it's a standalone program that uses the GHC API, when multi-target cross compilation is ready in GHC itself we'll probably look into switching to that kind of setup
21:03:35 <luite> mm_freak_: that means building native code to be able to run template haskell, and then javascript code
21:03:51 <luite> javascript is more or less 32 bit, since it doesn't have 64 bit ints
21:24:21 <mm_freak_> what about VM-based solutions?  any chance to generate javascript code from LLVM?
21:26:05 <luite> yes, emscripten
21:42:23 <mm_freak_> luite: did anyone succeed in using GHC with emscripten?
21:43:05 <luite> mm_freak_: no
21:44:12 <Guest61588>  Warning: -fglasgow-exts is deprecated: Use individual extensions instead?
21:44:51 <Guest61588> what to do ^
21:45:07 <shachaf> I recommend that you use individual extensions instead of -fglasgow-exts.
21:45:24 <Guest61588> what are individual flags?
21:45:37 <Guest61588> i mean which ones?
21:45:42 <edwardk> turn off -fglasgow-exts  and you can turn them on with -XFoo
21:45:52 <edwardk> it'll probably prompt you
21:46:34 <edwardk> -fglasgow-exts was a big mishmash of stuff that was always changing
21:48:42 <Guest61588> i am trying to compile this http://jonathan.tang.name/files/scheme_in_48/code/listing10.hs
21:50:03 <Guest61588> ghc -package parsec -fglasgow-exts -o lisp [../code/listing9.hs listing9.hs]
21:50:50 <shachaf> And what edwardk said doesn't work?
21:51:16 <Guest61588> what do you mean by -XFoo? that is a flag?
21:51:38 <edwardk> Guest61588: turn off -fglasgow-exts first. try and compile, it may complain about something
21:51:54 <edwardk> e.g. needing a language pragma for Rank2Types, then that would be an additional -XRank2Types for the command line
21:52:02 <Guest61588> listing10.hs:9:1: parse error (possibly incorrect indentation)
21:53:13 <edwardk> well the first problem there is its using IO, so that example is pretty old. lets see
21:54:00 <edwardk> i don't know how to get that file to compile without rewriting it
21:54:05 <edwardk> it uses Data.IORef and haskell98
21:54:23 <johnw> can I rename a Hackage package?
21:54:33 <johnw> or do I just mark that one as deprecated and upload under another name?
21:54:38 <edwardk> johnw: no, but you can contact ross paterson and get the old one deprecated
21:54:50 <edwardk> embarassed by the monad-bool name?
21:55:03 <johnw> well, considering that I can't even write a Monad instance, just a bit
21:55:09 <edwardk> fair enough
21:55:20 <Guest61588> edwark it compiled before with small changes
21:55:20 <johnw> i want to rename it to monoid-bool
21:55:23 <johnw> since those are still relevant
21:56:03 <johnw> and aristid had apparently written a 'shortcircuit' library more than two years which does much of what I was aiming for (missing only the monoids)
21:56:07 <johnw> so maybe I'll just join up with him
21:56:50 <johnw> edwardk: https://github.com/jwiegley/monoid-bool/blob/master/Data/Monoid/Bool.hs
21:57:34 <edwardk> turning on {-# LANGUAGE ExistentialQuantification #-}  and swapping Monad to import Control.Monad  and import IO hiding (try) to import System.IO   makes it compile here
21:57:47 <XexonixXexillion> What data structures (apart from ((,) e) and zippers) are comonads?
21:58:16 <edwardk> ((->)m) for a monoid m, everything in comonad-transformers, the store comonad, the bazaar comonad i use in lens
21:58:34 <edwardk> funlists, non-empty lists, streams of various sorts, the cofree comonad of any functor
21:59:47 <johnw> XexonixXexillion: Env is another one that edwardk uses
21:59:53 <johnw> and Traced
22:00:03 <edwardk> there is also coyoneda f and yoneda f of any comonad, also http://hackage.haskell.org/packages/archive/kan-extensions/2.1.2/doc/html/Control-Comonad-Density.html
22:00:05 <copumpkin> how about tracer-t?
22:00:30 <edwardk> Env is a generalization of the (,) e  comonad to a comonad-transformer, traced is a generalization of the (->) m   comonad to a comonad-transformer
22:01:14 <edwardk> hrmm, other comonads, include the pointer comonad which is a variation on the store comonad (dan piponi wrote about it, its in my comonad-extras package)
22:02:49 <edwardk> there are other comonads, out there, including the "molten" comonad i use in lens to 'pour out a magma' representing the shape of a structure with indexing intact. https://github.com/ekmett/lens/blob/master/src/Control/Lens/Internal/Magma.hs#L152
22:03:29 <edwardk> but that can be viewed as a defunctionalized bazaar
22:03:45 <edwardk> XexonixXexillion: that enough to get you started? =)
22:05:39 <johnw> edwardk: would be interested in my returnIf and returnUnless for your either library?
22:05:55 <XexonixXexillion> edwardk: yep. Thanks
22:06:15 <edwardk> probably not, thats what i use guard for ;)
22:06:33 <johnw> but guard doesn't yield a short-circuiting value, does it?
22:07:21 <johnw> and you can't say: when True (left 10)
22:07:52 <edwardk> returnIf :: Monad m => Bool -> e -> EitherT e m ()
22:07:52 <XexonixXexillion> edwardk: can you recommend any papers on them (besides uustalu's)?
22:07:52 <edwardk> returnIf p a = if p then left a else right ()
22:07:55 <edwardk> is very weird logic
22:08:19 <edwardk> XexonixXexillion: sadly i wrote most of them when i wasn't in a very paper-writing mood ;)
22:08:20 <johnw> it is a left a if the predicate is true, otherwise it's the same "return ()"
22:08:49 <shachaf> That's probably meant to be "return" in the opposite sense of "return".
22:08:53 <shachaf> I.e. throwing an exception.
22:09:05 <edwardk> johnw: the name returnIf strikes me as more of an assertNot
22:09:19 <johnw> i also thought of abortWhen
22:09:19 <edwardk> and its a condition on the failure
22:09:35 <johnw> the idea is that if the predicate is true, short-circuit by yielding a Left value from the monadic computation
22:09:47 <edwardk> but the thing is this doesn't fit the common usage of EitherT, we don't usually have the type we're testing _as_ the error type
22:09:53 <shachaf> edwardk: Only if you think of failure as failure.
22:10:14 <shachaf> Think of C: int foo(int x) { if (invalid(x)) return -1; ... }
22:10:19 <shachaf> At least I assume that's what johnw is getting at.
22:10:28 <johnw> yeah, shachaf is very close
22:10:39 <johnw> the alternative is a nested if's
22:10:47 <johnw> or, ContT
22:10:57 <johnw> i guess I could always just use ContT
22:10:57 <johnw> sigh
22:11:24 <shachaf> johnw: It seems to me that "when" and "left" do what you want.
22:11:31 <shachaf> @src when
22:11:31 <lambdabot> when p s = if p then s else return ()
22:11:40 <johnw> that's return ()
22:11:41 <shachaf> rigght = return
22:11:43 <johnw> hm
22:11:48 <johnw> i couldn't get that to compile
22:11:49 <johnw> let me try that again
22:11:59 <shachaf> Just add more unsafeCoerce.
22:12:03 <johnw> stop it
22:12:08 <edwardk> hah
22:12:38 <edwardk> johnw: you realize we're required by law to give you crap about this for the next 6 months
22:12:45 <johnw> which part?
22:12:48 <edwardk> yes
22:12:50 <johnw> dude, I made so many mistakes today
22:12:54 <johnw> i just feel like going back to sleep
22:12:57 <johnw> and hoping the day didn't happen
22:13:32 <edwardk> i export one little unsafeCoerce in an otherwise reasonable place that is visible by using horrible GADT hacks and elliott still gives me crap.
22:13:44 <edwardk> so now, like an abused sibling, i pass it on to you
22:13:49 <johnw> lol
22:14:11 <shachaf> To be fair, that unsafeCoerce was completely invalid.
22:14:18 <edwardk> sure
22:14:24 <edwardk> and i've repented
22:14:33 <johnw> at least I become a channel founder for #haskell today.  tease me at your peril! :)
22:14:54 <edwardk> invented time travel i see
22:15:01 <johnw> yeah, chanserv let's you do that
22:15:05 <edwardk> must be the power of unsafeCoerce
22:15:10 <johnw> now you get it
22:15:11 <tac-tics> unsafeCoerce johnw :: ChannelFounder
22:15:34 <sw2wolf> :t unsafeCoerce
22:15:35 <lambdabot> Not in scope: `unsafeCoerce'
22:15:47 <johnw> shachaf: i actually wrote that when x (left y) at one point, and got a type check error about () not matching a or some such.  SIGH
22:15:51 <johnw> it works just perfectly fine
22:15:57 <edwardk> pretty soon shapr will arrive in the channel in 2000 or whenever and it'll already be populated by time travelers who know more about haskell than he does.
22:17:10 <johnw> i did install that Tardis monad somewhere around here...
22:17:27 <johnw> edwardk: ok, are my Monoids at least sane?
22:17:37 <edwardk> i should read them
22:17:49 <johnw> oh no, anything but an instant yes is doom
22:17:52 <Guest61588> edwardk, u are my new hero
22:18:20 <Guest61588> edwardk, what about this warning  Warning: Pattern match(es) are overlapped
22:18:20 <Guest61588>           In an equation for `cdr': cdr [DottedList [xs] x] = ...
22:18:22 <shachaf> johnw: It seems to me that you have a bunch of evil orphan instances.
22:18:22 <edwardk> why do and and or share a logic failure type?
22:18:37 <johnw> you mean the ToBool guys?
22:18:45 <shachaf> Yes.
22:18:52 <johnw> edwardk: good question
22:18:57 <shachaf> If they weren't orphan, they would just be evil instances.
22:19:01 <edwardk> no i mean data LogicException = LogicalAndFailed String | LogicalOrFailed String
22:19:14 <johnw> how do I provide those instances without changes the cond library?
22:19:34 <edwardk> you don't throw it, so what keeps that from just being 'String'
22:19:44 <johnw> Attempt wants an Exception type
22:19:50 <shachaf> Attempt is, uh, isomorphic to Either SomeException, sort of?
22:19:58 <johnw> yeah, exactly
22:20:11 * edwardk goes and looks up 'Attempt'
22:20:38 <edwardk> ah, its like mzero's pure exception monad
22:21:09 <shachaf> Oh, mzero the person.
22:21:10 <edwardk> ok, then my issue still stands, why do they share an exception type?
22:21:16 <johnw> no reason
22:21:17 <edwardk> shachaf: yeah =)
22:21:20 <johnw> unsharing now
22:21:28 <shachaf> Why are you using Attempt?
22:21:42 <edwardk> i don't grok the role of attempt in this
22:21:55 <johnw> because I want the error to be consumable as a Maybe or an Either or a List
22:22:00 <johnw> error/result*
22:23:08 <johnw> I had it as a Maybe at first, but ciaranm wanted it to be consumable as a List
22:23:17 <edwardk> this isn't 'fundamental' complexity, its incidental complexity.
22:23:44 <johnw> hmmm
22:24:02 <johnw> you should I could just newtype Maybe?
22:24:06 <johnw> s/should/mean
22:24:28 <johnw> that would get rid of extra "layers"
22:24:31 <johnw> or I could newtype Attempt
22:24:41 <johnw> err, type
22:24:46 <johnw> no, i guess it has to be newtype
22:25:00 <johnw> in which case I'm already doing that
22:25:07 <johnw> newtype And a = And { getAnd :: Attempt a }
22:25:08 <edwardk> attempt is currently just holding onto an exception
22:25:14 <johnw> yes
22:25:16 <edwardk> and in the end, its converting that to a singleton list
22:25:18 <edwardk> or a maybe
22:25:23 <edwardk> not a list of all the exceptions it saw
22:25:24 <johnw> or an either Exception
22:25:26 <edwardk> a singleton list
22:25:35 <edwardk> e point is this is a whole lot of nonsense
22:25:41 <edwardk> for something that is fundamentally Either String
22:25:47 <edwardk> there isn't any value added
22:25:50 <edwardk> just complexity
22:25:53 <johnw> and I don't even care about the String
22:25:57 <johnw> I really just want Maybe or List
22:25:57 <edwardk> exactly
22:26:02 <edwardk> a list of what?
22:26:06 <johnw> [] to mean false
22:26:12 <johnw> singleton to mean true
22:26:18 <edwardk> you only get one answer back
22:26:24 <edwardk> thats not a list ;)
22:26:27 <johnw> ciaranm then wanted a list
22:26:28 <edwardk> thats a crappy form of maybe
22:26:28 <johnw> but you're right
22:26:33 <johnw> i want to go back to maybe
22:26:47 <edwardk> now, you can upgrade this to get a list of failures
22:26:58 <edwardk> Either [b] a
22:27:05 <edwardk> for some error type b
22:27:11 <edwardk> which you can have be string like you mentioned
22:27:14 <johnw> but is that really going to be useful?
22:27:20 <edwardk> but if you don't want the string, then whats the point?
22:27:23 <johnw> yeah
22:27:38 <johnw> oh, and I did try to make these classes applicitave
22:27:41 <edwardk> something equivalent to Either Int a can form a perfectly reasonable monoid, which counts failures
22:27:42 <johnw> and found that I could not do it
22:27:45 <johnw> i was missing the constraint
22:27:55 <edwardk> (it cant be Either though, because it can't extend to be compatible with the Either Monad)
22:28:03 <johnw> ah
22:28:03 * shachaf would also strongly recommend abandoning the 0=false, other things=true thing.
22:28:08 <FYCouch> hello, any C masters? i need to hire a C tutor for brief skype sessions several times per week.
22:28:23 <FYCouch> preferrably another US citizen with great communication skills
22:28:40 <edwardk> shachaf: i agree, the very notion of truthy and falsy values is a disease, but i was going to let him come to that realization in his own time ;)
22:28:52 <johnw> FYCouch: this is really the wrong channel to ask that
22:28:54 <FYCouch> false isn't a valid value?
22:29:03 <FYCouch> johnw: but is it? very bright ppl do haskell
22:29:10 <johnw> but we don't do C very much
22:29:25 <Maxdamantus> He was just banned in the more-appropriate-but-not-actually-appropriate one.
22:29:32 <edwardk> johnw is known for his hatred of all things c/c++
22:29:55 <edwardk> he spends all his time trying to get them to change the standards
22:30:02 <johnw> not as much time anymore :)
22:30:12 <shachaf> I don't know C++ well enough to be qualified to hate it. :-(
22:31:31 * Maxdamantus learnt the other day what happens when assigning an object to a variable of one of its supertypes.
22:31:41 <azmenthe> haha I know it well enough to enjoy parts of it and hate other parts, but my learning goal is haskell
22:31:57 <sclv> truthy and falsy values are perfectly legit under an adjunction to some appropriate boolean algebra :-P
22:32:05 <Guest61588> i like the c vs haskell war on reddit
22:32:11 <edwardk> doing years of c++ made working with haskell's notion of parametric polymorphism a breeze. its like that scene in hellraiser, where they talk about how some things have to be endured to make the pleasures sweeter.
22:32:29 <johnw> lol
22:32:40 <johnw> i just watched hellraiser 9 or whatever, and that was the central theme this time
22:32:50 <Maxdamantus> Because the two notions of parametric polymorphism are similar, or because the other one's horrible?
22:32:55 <johnw> yes, pinhead designed C++ as a gateway to Haskell
22:33:33 <cmears> If I have a function like this:  putTwo a b = putStrLn a >> putStrLn b
22:33:34 <shachaf> C++ doesn't have a notion of parametric polymorphism. :-)
22:33:40 <cmears> and I want to feed getLine directly into it
22:33:47 <cmears> Is this the best way?  join (putTwo <$> getLine <*> getLine)
22:33:53 <johnw> ok, edwardklint: https://github.com/jwiegley/monoid-bool/blob/master/Data/Monoid/Bool.hs
22:33:55 <edwardk> Maxdamantus: because you can do a lot in the turing tarpit that is template meta-programming, and its sort of a gateway to haskell development, where you transcend all that craziness, and its all beautiful… until you reach template haskell, and the guy is flaying your skin off again.
22:34:03 <shachaf> cmears: That's a pretty reasonable way.
22:34:25 <cmears> shachaf: I felt like the "join" could be eliminated somehow, but I couldn't figure out how
22:34:55 <shachaf> There's no function for this in the standard library, as far as I know.
22:35:02 <shachaf> It would probably be called bind2 or something.
22:35:15 <edwardk> so with the Maybe version (and what you had before) i notice that you have no notion of 'what caused the failure' you just get 'Nothing'
22:35:23 <johnw> correct
22:35:30 <johnw> how would I indicate what caused the failure?
22:35:35 <cmears> shachaf: OK, thanks; I will keep the join (:
22:35:41 <johnw> you think I should return that value?
22:35:45 <edwardk> not sure
22:35:56 <johnw> it's just going to be some form of falsity, so probably not very revealing
22:36:09 <edwardk> , but if i have short-circuiting selector that grabs the first failure then i kind of want the 'false' value as the result
22:36:18 <johnw> hmm
22:36:23 <edwardk> if you are willing to accept the notion of falsy values to begin with
22:36:31 * shachaf would recommend not.
22:36:37 <johnw> then I'd kind of want Either e a
22:36:44 <edwardk> shachaf: as would i, but accepting the madness for a moment
22:36:49 <edwardk> well, Either a a would work
22:36:57 <johnw> ah, Either a a, my old friend
22:37:11 <edwardk> and you can implement a version using (Bool, a) _if_ you copy the Either a a semantics
22:37:31 <johnw> is it worth doing so?
22:37:54 <johnw> using plain Either makes it easier to work with the result values
22:37:57 <edwardk> well, as it is i don't see much value to the current design, with that at least you have the short-circuiting.
22:38:08 <shachaf> > let f x = view chosen $ do { when (x < 5) (Left "too small"); when (x > 100) (Left "too big"); return ("your number was " ++ show x) } in map f [2,20,120]
22:38:10 <lambdabot>   ["too small","your number was 20","too big"]
22:38:12 <edwardk> might as well go with Either
22:38:15 <johnw> ok
22:38:46 <johnw> what about mempty though?
22:38:55 <johnw> i need not only a toBool, but a 'false'
22:39:04 <johnw> which is what aristid's library provides
22:39:21 <edwardk> well, this seems to give rise to a problem with the current design.
22:39:34 <johnw> is this only a semigroup?
22:39:35 <edwardk> what were you doing with And and Or before?
22:39:42 <johnw> mempty = And Nothing
22:39:53 <edwardk> then you weren't even a monoid
22:39:58 <edwardk> x@(And Nothing)  `mappend` _ = x
22:40:08 <johnw> i wasn't?
22:40:12 <edwardk> mempty `mappend` x = mempty
22:40:13 <edwardk> not x
22:40:32 <edwardk> see the problem?
22:40:44 <johnw> this is And behavior, if anything is Nothing the result should be Nothing
22:40:59 <shachaf> That is not a monoid.
22:41:01 <edwardk> but mempty for 'And' isn't 'false' its 'true'
22:41:10 <johnw> oh
22:41:17 <johnw> you are right
22:41:19 <edwardk> :t mempty :: All
22:41:21 <lambdabot> All
22:41:24 <edwardk> > mempty :: All
22:41:25 <lambdabot>   All {getAll = True}
22:41:29 <edwardk> > mempty :: Any
22:41:30 <lambdabot>   Any {getAny = False}
22:41:36 <shachaf> Is there a type like data Bounded a = Bottom | Top | Middle a?
22:41:51 <shachaf> Not that that makes any sense, actually. :-)
22:42:02 <johnw> so this cant' be a monoid at all, because there is on arbitrary "true" for mempty to rethurn
22:42:03 <edwardk> shachaf: there are variations of it, usually with the constructors sorted differently in various places. reactive had one
22:42:08 <johnw> but it can be a semigroup?
22:42:12 <edwardk> johnw: yes
22:42:27 <johnw> ok
22:42:45 <edwardk> notice how this is dwindling away to not much there
22:42:52 <shachaf> Ah, http://hackage.haskell.org/packages/archive/reactive/0.11.5/doc/html/Data-AddBounds.html
22:42:53 <johnw> yeah, don't remind me
22:43:18 <edwardk> we wouldn't give you crap if we didn't care ;)
22:43:25 <johnw> I feel the love :)
22:44:06 <johnw> it seems like Semigroup shouldn't use <>...
22:44:19 <edwardk> import Data.Semigroup _rather_ than Data.Monoid and it works
22:44:27 <edwardk> it re-exports the relevant bits from Data.Monoid
22:44:56 <edwardk> Data.Semigroup had priority since, it took 2 years to get (<>) added to Data.Monoid and in disgust i wrote Data.Semigroup in the meantime
22:45:20 <edwardk> after Data.Monoid added it, i changed hundreds of source files to work around it
22:45:26 <edwardk> i'm not changing it again ;)
22:47:18 <johnw> and I guess i can't have a functor instance either with Either a a
22:47:48 <shachaf> A functor instance for what?
22:47:59 <johnw> for And based on Either a a
22:48:05 <johnw> fmap f (And (Left x)) = And (Left x) cannot unify a with b
22:48:07 <shachaf> For what type?
22:48:13 <edwardk> you can write a functor for And
22:48:21 <edwardk> just you just have to fmap over both sides
22:48:27 <johnw> oh
22:48:29 <johnw> hmm
22:48:39 <shachaf> I wrote this fmap instance in the other channel.
22:48:41 <edwardk> fmap f (And (Left x)) = And (Left (f x))
22:48:41 <johnw> i guess that makes an And-y kind of sense
22:48:50 <johnw> shachaf: i went and reviewed that instance
22:49:04 <johnw> yeah, that does make it type check, it just felt odd to allow fmapping over the failure result
22:49:22 <edwardk> basically the fmap is changing out the result type completely
22:49:35 <shachaf> There is at most one correct Functor instance for every type (disregarding _|_)
22:49:50 <shachaf> (Also disregarding unsafeCoerce)
22:54:34 <johnw> edwardk: good thing I didn't upload monoid-bool
22:54:35 <johnw> :)
22:54:36 <johnw> lol
22:54:41 <edwardk> hahaha
22:54:44 <johnw> ok: https://github.com/jwiegley/monoid-bool/blob/master/Data/Monoid/Bool.hs
22:54:58 <johnw> pretty soon I'll just have unit-bool that contains only comments
22:55:18 <edwardk> at last check you didn't have a unit
22:55:20 <edwardk> ;)
22:55:33 <johnw> no, ok, there is extremely little code here now
22:55:39 <johnw> i can hear the echoes when I type
22:55:52 * shachaf predicted this.
22:56:01 <edwardk> i'm thinking its fallen below critical mass
22:56:19 <johnw> it's not even a useful semigroup?
22:56:27 <edwardk> so now all we have to do is point out the absurdity of truthy and falsy values and you'll be able to get this with 'find'  ;)
22:56:47 <johnw> i'll see if aristid wants to fold this into shortcircuit
22:56:50 <johnw> maybe it can find a home there
22:56:57 <edwardk> > find (==0) [1,2,3,4,6,3,0,2,3,4,5,5]
22:56:58 <lambdabot>   Just 0
22:57:02 <edwardk> magic!
22:57:21 <johnw> oh no
22:57:50 <edwardk> so when its a monoid what are you getting out of it, the last non-falsy value?
22:58:05 <edwardk> er the first falsy value or the last one that wasn't?
22:58:08 <johnw> i'm still getting that
22:58:17 <shachaf> lastOf (traverse.filtered isTruthy)
22:58:24 <shachaf> You only pay 1000x!
22:58:33 <edwardk> hah
22:58:38 <johnw> for And, you get either the Right last true value, or the Left first false value
22:58:40 <edwardk> beat me to it =)
22:59:02 <johnw> for Or, it's the Right first true value, or the Left last false value
22:59:45 <edwardk> so what is the value of fixing the decision procedure?
23:00:00 <johnw> i guess none; what's the general way?
23:00:29 <johnw> you guys are like a sieve; you're dissolving my entire's days effort down to one lens expression, aren't you?
23:00:31 <edwardk> well, lets see. i have *> and Either a a
23:00:45 <edwardk> er
23:00:50 <edwardk> i guess i need something more
23:01:27 <edwardk> > Right 1 *> Right 2
23:01:29 <lambdabot>   Right 2
23:01:33 <edwardk> > Left 1 *> Right 2
23:01:34 <lambdabot>   Left 1
23:01:39 <edwardk> > Right 1 *> Right 2 *> Right 5
23:01:41 <lambdabot>   Right 5
23:01:47 <johnw> ok, that's And
23:02:12 <edwardk> > Left 1 <|> Right 2 <|> Right 5
23:02:13 <johnw> > Right 1 *> Right 2 *> Left 2 *> Right 5
23:02:14 <lambdabot>   Ambiguous type variable `a0' in the constraints:
23:02:14 <lambdabot>    (GHC.Num.Num a0)
23:02:14 <lambdabot>      a...
23:02:14 <lambdabot>   can't find file: L.hs
23:02:21 <edwardk> > Left 1 <|> Right 2 <|> Right 5
23:02:22 <lambdabot>   Ambiguous type variable `a0' in the constraints:
23:02:22 <lambdabot>    (GHC.Num.Num a0)
23:02:22 <lambdabot>      a...
23:02:28 <edwardk> > Left 1 <|> Right 2 <|> Right 5 :: Either Int Int
23:02:29 <lambdabot>   No instance for (Control.Monad.Trans.Error.Error GHC.Types.Int)
23:02:29 <lambdabot>    arising ...
23:02:37 <edwardk> bah
23:02:46 <johnw> > Right 1 *> Right 2 *> Left 2 *> Right 5
23:02:47 <lambdabot>   Left 2
23:02:49 <Maxdamantus> :t (*>)
23:02:50 <lambdabot> Applicative f => f a -> f b -> f b
23:03:03 <edwardk> Maxdamantus: thats just the applicative version of (>>)
23:03:05 <edwardk> :t (>>)
23:03:06 <lambdabot> Monad m => m a -> m b -> m b
23:03:14 <Maxdamantus> Mk.
23:03:29 <edwardk> johnw: anyways with a decent version of (<|>) you can write Or.
23:03:54 <edwardk> same reasoning
23:04:36 <edwardk> :t let Left x |> y = y; Right x |> _ = RIght x in (|>)
23:04:38 <lambdabot>     Not in scope: data constructor `RIght'
23:04:38 <lambdabot>     Perhaps you meant `Right' (imported from Data.Either)
23:05:03 <edwardk> :t Right
23:05:04 <lambdabot> b -> Either a b
23:05:34 <edwardk> :t let Left x |> y = y; x |> _ = x in (|>)
23:05:36 <lambdabot> Either t t1 -> Either t t1 -> Either t t1
23:05:58 <edwardk> :t let Left x |> y = y; x |> _ = x in Left 1 |> Left 2 |> Right 3 |> Right 4
23:05:59 <lambdabot> (Num t1, Num t) => Either t t1
23:06:03 <edwardk> > let Left x |> y = y; x |> _ = x in Left 1 |> Left 2 |> Right 3 |> Right 4
23:06:05 <lambdabot>   Right 3
23:06:22 <johnw> not quite
23:06:27 <edwardk> > let Left x |> y = y; x |> _ = x in Left 1 |> Left  2 |> Left 3 |> Left 4
23:06:29 <lambdabot>   Left 4
23:06:32 <edwardk> the logic is flipped
23:06:34 <edwardk> its the last left
23:06:36 <edwardk> or the first right
23:06:42 <edwardk> but its the same thing you asked for
23:06:59 <johnw> i need the last right for it to be Or
23:07:01 <shachaf> @ty iso
23:07:03 <lambdabot> (Functor f, Isomorphic k) => (s -> a) -> (b -> t) -> k (a -> f b) (s -> f t)
23:07:11 <shachaf> @yarrgh
23:07:11 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
23:07:12 <johnw> oh, no  I don't
23:07:13 <edwardk> its just flipped
23:07:18 <johnw> i need the first right, you're right
23:07:23 <tertl3> i need help with another error in this putStrLn (readExpr (args !! 0))
23:07:31 <tertl3> http://jonathan.tang.name/files/scheme_in_48/code/listing3.1.hs
23:08:01 <edwardk> so with that basically the whole lib boils away to two combinators, one already in base ;)
23:08:02 <shachaf> tertl3: You need to learn how to ask these questions such that it's easy to help you. :-)
23:08:35 <shachaf> When you have a question like that, you should go to hpaste.org, and paste in your code and your error.
23:08:43 <edwardk> and the other which would be there if it wasn't for the goofy MonadPlus for Either folks used to like
23:08:46 <shachaf> Then you should say what you expected to have happen.
23:08:49 <tertl3> shachaf, its in the main module
23:09:02 <edwardk> (and the fact that there is no sane mzero/empty for it
23:09:49 <shachaf> instance Monoid e => MonadPlus (Either e)?
23:09:50 <edwardk> i do kind of wish we'd been able to make the fail case for the EIther monad Left _|_ instead of _|_
23:10:22 <edwardk> shachaf: i would have taken it, but its kinda galling to have a monoid you only use for empty
23:10:42 <edwardk> instance Default e => MonadPlus (Either e) is closer to accurate
23:10:46 <shachaf> edwardk: mplus would use the plus, presumably.
23:10:49 <shachaf> Or maybe that's broken.
23:10:56 <edwardk> but thats little less than the mtl's silly Error class
23:11:14 <edwardk> you can't glue together errors in the applicative and have the applicative be compatible with the monad
23:11:41 <edwardk> but basically gluing them is broken by the laws
23:11:55 <edwardk> you can make an alternative that uses the monoid.
23:12:07 <edwardk> we have it in scalaz as 'Validation'
23:12:25 <tertl3> im sorry guys, it was a indent error I think
23:14:51 <johnw> edwardk: this should make you laugh: https://github.com/jwiegley/semigroup-bool/blob/master/Data/Semigroup/Bool.hs
23:15:14 <edwardk> hahahahah
23:15:17 <johnw> johnw 0 haskell 1
23:15:27 <edwardk>    This library implements a pair of Boolean monoids and monads, to support
23:15:28 <edwardk>    short-circuited, value-returning computations similar to what Python and
23:15:29 <edwardk>    Ruby offer with their native @&&@ and @||@ operators.
23:15:34 <edwardk> thats a bit misstated now =)
23:15:41 <johnw> uh, yeah
23:15:44 <johnw> not really worth fixing
23:15:48 <edwardk> look at it this way you learned something
23:15:54 <johnw> yes indeed
23:16:05 <edwardk> we all go through these epiphany moments, some more publicly than others ;)
23:16:08 <johnw> it was really the first time I try to invent my own monad, so it was a valuable exercise
23:16:11 <johnw> lol
23:16:20 <johnw> yeah, you just keep rubbing it in
23:16:40 <edwardk> don't worry. its not like you announced the package to the world or anything. nobody will know.
23:16:47 <johnw> lololol
23:16:49 <johnw> stop!
23:17:09 <shachaf> Y'all should rub my mistakes in too.
23:17:23 <shachaf> Remember when I wrote that silly zipper code?
23:17:24 <edwardk> we do. you chose the wrong coast to live on. weirdo.
23:17:35 <edwardk> you need to move to boston
23:17:50 <shachaf> @google boston weather
23:17:51 <johnw> edwardk: i intend to come to ICFP
23:17:51 <edwardk> there is a boston haskell tomorrow. you can fly in, right?
23:17:52 <lambdabot> No Result Found.
23:17:54 <johnw> will you be around then?
23:18:00 <edwardk> yeah i will
23:18:17 <shachaf> edwardk: My east coast trip has been delayed.
23:18:22 <johnw> i'm heading to London late March
23:18:48 <shachaf> But I don't think it'll coïncide with bostonhaskell anyway.
23:19:22 <shachaf> Probably first or second week of March.
23:19:26 <edwardk> shachaf: we're probably going to change the format so we meet on the 3rd week of every month regardless of scheduled speakers
23:19:38 <edwardk> so you should aim for the third week ;)
23:19:43 <mm_freak_> johnw: oh, you're the monad-bool guy? =)
23:19:51 * johnw hides head in shame
23:19:57 <edwardk> mm_freak_: we gave him crap about it all day.
23:20:12 <johnw> i'm going to get it from all the europeans in a few hours
23:20:15 <shachaf> edwardk: I'll keep that in mind for when I move to Boston.
23:20:35 <mm_freak_> johnw: i'm european…  you already got it from me =P
23:20:48 <johnw> ah, that's right, it's gotten later than I thought
23:21:07 <mm_freak_> you got it at 4:13 AM =P
23:21:17 <mm_freak_> now it's 8:21 =)
23:21:34 <johnw> france?
23:21:37 <mm_freak_> germany
23:21:44 <johnw> ah, guten morgen
23:22:12 <mm_freak_> morgen =)
23:22:24 <kfish> hi johnw :)
23:22:49 <johnw> hast du ein kleines frühstuck zum essen?
23:22:50 <johnw> hi kfish!
23:23:10 <mm_freak_> (don't worry, germans aren't any less lazy…  we usually just say hi or "moin")
23:24:51 <mm_freak_> erst mal nur kaffee…  i don't frühstück =)
23:25:01 <johnw> i don't either, actually
23:25:32 <tertl3> is it ok to drink coffee at 3 am?
23:25:42 <edwardk> tertl3: yes
23:26:00 <johnw> if I had coffee now, I'd have trouble sleeping _tomorrow_ night
23:26:29 <shachaf> edwardk is a machine that turns unsafeErces into ffee.
23:26:41 <edwardk> heh
23:26:52 <johnw> ffee is a beverage that turns wakefulness into sleepiness
23:27:08 <edwardk> as long as folks are willing to pay my ffee, i'm willing to unsafeErce.
23:27:21 <johnw> is that at your regular mpany?
23:27:32 <mm_freak_> tertl3: is there an ok time for coffee?
23:27:43 <johnw> mm_freak_: yes
23:27:44 <latermuse> Is there an easy to way apply a function to the value of every member in a hash map?
23:27:47 <johnw> there is one perfect time for coffee
23:27:52 <tertl3> i thought morning was ideal
23:27:53 <edwardk> well, sure, but i have many llaborators.
23:27:58 <johnw> latermuse: fmap doesn't work?
23:28:30 <tertl3> i am at the wierd part of youtube
23:28:38 <edwardk> latermuse: fmap
23:28:39 <latermuse> johnw: perfect! love you john
23:28:42 <latermuse> :D
23:28:50 <edwardk> > :t HM.fromList
23:28:52 <lambdabot>   <hint>:1:1: parse error on input `:'
23:28:53 <edwardk> :t HM.fromList
23:28:54 <lambdabot> Couldn't find qualified module.
23:28:59 <edwardk> aw no hashmap
23:29:01 <latermuse> type system blows my mind every day
23:29:16 <johnw> yeah, except when you use unsafeCoerce to ignore it :(
23:29:31 <latermuse> unsafeCoerce can ignore the type system?
23:29:39 <johnw> where is that quote...
23:29:43 <johnw> @quote unsafeCoerce
23:29:43 <lambdabot> roconnor says: unsafeCoerce isn't even safe
23:29:43 <latermuse> what happens when you try to add a String and an Integer with unsafeCorce on?
23:29:48 <johnw> @quote unsafeCoerce
23:29:48 <lambdabot> int-e says: What, unsafeCoerce# is kind-preserving? how boring :/
23:29:49 <edwardk> he type system is like my conscience. unsafeCoerce is like listening to the little devil voice inside my head. iv'e been a bad bad boy with lens.
23:29:55 <shachaf> lambdabot: Probably a segfault.
23:30:00 <johnw> "unsafeCoerce takes any argument; and it wins that argument"
23:30:00 <edwardk> i've even
23:30:06 <shachaf> @quote Jafet unsafeCoerce
23:30:06 <lambdabot> Jafet says: unsafeCoerce takes any argument. AND IT WINS THAT ARGUMENT.
23:30:21 <latermuse> hehe neat :)
23:30:32 <shachaf> latermuse: Please don't use unsafeCoerce.
23:30:34 <johnw> latermuse: unsafeCoerce tells Haskell that the thing value you have is whatever type you want it to have
23:30:37 <mm_freak_> coffee doesn't work on me anymore…  i drink it because it's tasty
23:30:45 <latermuse> not planning to use it. neat that it is available though
23:30:46 <mm_freak_> often i drink a red bull for sleep
23:30:47 <shachaf> latermuse: If your thing doesn't type check, there's a reason.
23:30:54 <johnw> mm_freak_: good coffee is unreasonably tasty
23:30:58 <johnw> mm_freak_: bad coffee is unreasonably bad
23:31:11 <edwardk> mm_freak_: i pretty much drink caffiene all day while i'm awake. this may be a factor in why i don't sleep much
23:31:29 <johnw> i can't really find a time when you and shachaf do sleep
23:31:38 <johnw> whenever I'm on the channel, you seem to be; and my hours are WEIRD
23:31:41 <mm_freak_> johnw: oh, i usually put milk in my coffee…  that makes almost any non-instant coffee taste fine =)
23:31:44 <mm_freak_> edwardk: ditto
23:31:50 <shachaf> johnw: I sleep 12 hours a day.
23:31:56 <johnw> mm_freak_: i really only drink cappuccino
23:31:56 <mm_freak_> although often the caffeine comes from black tea (is it called that way?)
23:32:02 <johnw> shachaf: you do?
23:32:14 <johnw> yes, black tea
23:32:19 <shachaf> johnw: Every other 30 seconds.
23:32:24 <johnw> shachaf: hmm
23:32:26 <edwardk> i moved to a pretty much endless stream of diet coke, rather than coffee.
23:32:30 <johnw> you are like a fravashi master
23:32:42 <johnw> your brain is in four parts, and one part is always sleeping; but if they all sleep at the same time, you die
23:33:26 <shachaf> edwardk: If you move to California, you get three extra hours every day.
23:33:32 <shachaf> It's only 23:33 here!
23:33:36 <tertl3> not true
23:34:03 <liyang> johnw: like the timecube.
23:34:10 <edwardk> my experience with living in california is i keep the same screwed up hours there.
23:34:11 <mm_freak_> edwardk: try black tea or ice tea…  if you make the ice tea yourself you can make it have as much caffeine as you want, plus you control the sugar
23:34:18 <shachaf> FOUR SIMULTANEOUS TYPE SYSTEMS IN A SINGLE LAMBDA CUBE ROTATION
23:34:22 <mm_freak_> diet coke isn't really as diet as most people think =)
23:34:23 <simpson> Ha.
23:34:59 <liyang> shachaf: exactly.
23:35:00 <tertl3> its 0 calories
23:35:09 <snowylike> i once conducted an informal study around my uni, whether there's a correlation between departement and caffeine intake
23:35:18 <edwardk> mm_freak_: it has the benefit that i can get my hands on it with no appreciable forethought.
23:35:22 <snowylike> would you like to guess which departements had the highest?
23:35:27 <kfish> import Data.Thyme.Cube
23:35:27 <latermuse> snowylike: what were the results?
23:35:28 <johnw> IT?
23:35:32 <snowylike> (caffeine intake, that means)
23:35:52 <edwardk> and you know its late when #haskell turns into #haskell-blah ;)
23:36:00 <mm_freak_> lol
23:36:04 <AfC> heh
23:36:07 <snowylike> well, computer science, mathematics and chemistry are strongly corelated with caffeine intake
23:36:08 <shachaf> #blahskell
23:36:23 <mm_freak_> snowylike: marketing guys seem to live on caffeine
23:36:27 <liyang> kfish: Good idea.
23:36:39 <snowylike> thankfully, we had no business crap around
23:36:46 <latermuse> programmers take caffeine as input, and output code
23:37:02 <mm_freak_> but otherwise i'd assume non-programming computer tasks
23:37:08 <tertl3> one sec
23:37:13 <mm_freak_> i don't drink much coffee /while/ programming
23:37:28 * Maxdamantus has never had coffee.
23:37:48 * shachaf occasionally drinks coffee.
23:37:51 <shachaf> Every few months.
23:37:59 <snowylike> some people called me wally, because i always had a cup of coffee in my hands
23:38:01 * cmccann occasionally doesn't drink coffee.
23:38:10 * Maxdamantus drinks 1½-2l of Coke a day though.
23:38:11 <mm_freak_> the problem with coffee is that every now and then you have to get up and make it (or be happy with the bad taste of old coffee)
23:38:12 <tertl3> http://www.quora.com/Coffee/What-are-some-of-the-most-mind-blowing-facts-about-coffee
23:38:12 <shachaf> Well, I'm not sure I drank any in 2012, actually.
23:38:21 <mm_freak_> so getting coffee gets you out of The Zone
23:38:21 <cmccann> actually that's not true, I mostly drink a lot of tea.
23:39:18 <snowylike> guess i'll have to move to finland
23:39:25 <Maxdamantus> Miksi?
23:39:32 <mm_freak_> tertl3: wow, they actually seem to assume that everyone has a twitter or facebook account
23:39:42 <mm_freak_> i have neither, and i don't intend to sign up for that site
23:39:51 <tertl3> sry mm_freak_ :(
23:40:06 <tertl3> u can still look no?
23:40:08 <Maxdamantus> Ah.
23:40:13 <mm_freak_> nope
23:40:22 <mm_freak_> that stupid window doesn't close when told to
23:40:37 <tertl3> thats uberspammy
23:40:37 <mm_freak_> external javascript i guess
23:41:15 <shachaf> mm_freak_: It's pretty awful.
23:41:17 * cmccann opens Developer Tools in chrome, inspects the stupid modal bullshit div, deletes the element.
23:41:20 <cmccann> problem solved!
23:41:34 <shachaf> mm_freak_: You can see the first answer without it, though.
23:42:01 <mm_freak_> cmccann: there are billions of websites on the internet…  i don't waste my time to see a single one that doesn't work =)
23:42:02 <cmccann> also, not using shitty websites that do that: problem even more solved.
23:42:14 <mm_freak_> exactly
23:42:20 <mm_freak_> shachaf: i don't really care
23:42:39 <shachaf> mm_freak_: Good point.
23:42:43 <johnw> are there actually billions of websites?
23:42:54 <johnw> that's like almost a website per possible IPv4 address
23:42:57 <mm_freak_> johnw: i read once that there are more websites than IP addresses
23:42:59 <cmccann> mm_freak_: I seem to recall you're a big fan of not signing up for websites even when they ARE useful :P
23:43:10 <mm_freak_> johnw: you can have many websites per IP address
23:43:11 <johnw> huh
23:43:24 <johnw> yeah, that's true
23:43:24 <mm_freak_> johnw: see the HTTP header "Host"
23:43:45 <johnw> i actually run two websites at one IP, so I should have known better
23:43:47 <mm_freak_> cmccann: shut up, i signed up for stackoverflow recently =P
23:43:52 <cmccann> :O
23:43:54 <cmccann> really?!
23:43:59 <mm_freak_> yes
23:44:16 <mm_freak_> because otherwise they would spam me with a "pleeeeease sign up" email for every answer i write
23:44:23 <cmccann> hahahaha
23:44:29 <mm_freak_> yes, they do, and yes, it's new
23:44:36 <cmccann> that's kind of annoying.
23:44:58 <johnw> i guess their strategy worked
23:45:03 <mm_freak_> yeah
23:45:33 <johnw> I think this should be the #haskell mascott: http://static.wannasmile.com/wp-content/uploads/2008/02/omg_wtf.jpg
23:46:02 <mm_freak_> no, the haskell mascot would hold a solved cube =)
23:46:16 <johnw> yeah, that's the haskell mascott, not the #haskell mascott :)
23:46:25 <mm_freak_> ah =)
23:46:38 <dolio> No, the Haskell mascot is: http://www.haskell.org/pipermail/haskell/attachments/20090401/9fb8fa05/haskell-mascot.jpg
23:46:55 <mm_freak_> is that SPJ?
23:47:21 <dolio> Yes.
23:47:28 <mm_freak_> lol ok
23:47:34 <mm_freak_> i'd prefer the cat ;)
23:47:39 <mm_freak_> i love cats
23:50:05 <mm_freak_> what's the 'lens' equivalent of data-lens' 'focus' function?
23:50:50 <shachaf> zoom?
23:51:34 <mm_freak_> > runState (zoom _1 (put 3)) (4, 5)
23:51:36 <lambdabot>   ((),(3,5))
23:51:42 <mm_freak_> indeed, thanks
23:52:04 <shachaf> @ty iso
23:52:05 <lambdabot> (Functor f, Isomorphic k) => (s -> a) -> (b -> t) -> k (a -> f b) (s -> f t)
23:52:36 <shachaf> Ｃａｌｅ！
23:54:31 <fmap> @ty zoom
23:54:33 <lambdabot> Zoom m n k s t => SimpleLensLike (k c) t s -> m c -> n c
23:55:04 <edwardk> thats lost the k parameter in 3.8
23:55:10 <edwardk> so now its just the two state parameters
23:55:47 <shachaf> zoom :: Zoom m n s t => LensLike' (Zoomed m c) t s -> m c -> n c
23:57:01 <latermuse> why am I getting -infinity as output when doing some floating point calculations?
23:57:19 <fmap> > 1/(-0)
23:57:21 <lambdabot>   -Infinity
23:57:39 <latermuse> ah gotcha
23:57:43 <latermuse> makes sense
23:58:33 <mm_freak_> every lens is a traversal, right?
23:58:38 <edwardk> yes
