00:00:51 <Tordek> > itrPrime xs@(x:_) = itrPrime (nextPrime xs (succ x) : xs)
00:00:53 <lambdabot>   <hint>:1:19: parse error on input `='
00:01:27 <SamanthaD> Tordek: What's wrong with it?
00:01:36 <Tordek> no value escapes that function
00:01:41 <slack1256> :q
00:01:50 <Tordek> rofl
00:02:13 <statusfailed> SamanthaD: isn't "isPrime" going to return True for n == 4 and xs == [3, 2]
00:02:25 <SamanthaD> Tordek: Maybe I don't understand laziness then... wouldn't take 5 cause it to terminate when the list gets to a length of five?
00:02:50 <Tordek> SamanthaD: try to run the call by hand:
00:03:09 <simpson> Tordek: As far as that Reddit post goes, the fundamental problem is definitely that those bits of logic should never have been called with nullable things in the first place.
00:03:19 <SamanthaD> statusfailed: Yes, it will, thanks for noticing that! I need to have it check to make sure it's not N!
00:03:20 <Tordek> itrPrime [2] => itrprime (nextPrime [2] (succ 2) : [2])
00:04:06 <statusfailed> :)
00:04:07 <SamanthaD> which will return itrPrime [3:2]... OOOH!
00:04:18 <Tordek> yes
00:04:29 <SamanthaD> Tordek: I need [3:2] not itrPrime [3:2]!
00:04:54 <srhb> :t flip (id >=>)
00:04:56 <lambdabot> Monad m => m b -> (b -> m c) -> m c
00:04:59 <Tordek> you need  2 : (itrPrime [3]), I'm guessing
00:05:00 <srhb> oh yay
00:05:47 <Tordek> also, *divisible, not divisable
00:05:56 <SamanthaD> Tordek: Yes, that's what I was thinking but the thing is the whole point of itrPrime is for it to pass the FULL list of prime numbers to nextPrime because otherwise netxPrime can't pass the full list to isPrime and without the full list isPrime doesn't work right
00:06:08 <SamanthaD> Tordek: nevermind that isPrime apparently doesn't work right anyway ;)
00:06:26 <SamanthaD> Tordek: oh, yes... will fix that too. Thanks.
00:06:36 <Tordek> SamanthaD: so... exploit laziness!
00:06:57 <Tordek> instead of passing nextPrime the list of primes, just have it call `primes`
00:07:44 <SamanthaD> Tordek: won't that... won't that cause it to start calculating from the beginning though?!
00:08:24 <SamanthaD> Tordek: because if that's the case I don't need itrPrimes at ALL, I could just have isPrime call primes!
00:08:54 <Axman6> SamanthaD: give the list of prime numbers a name, then you can oass that to isPrime
00:09:27 <Axman6> so, primes = (computation to compute primes)
00:09:48 <Axman6> then, you can pass itrPrimes primes
00:10:09 <SamanthaD> Axman6: Yes, I have that. primes is a function named primes.
00:10:10 <Axman6> SamanthaD: it looks like you might be onto something =)
00:10:10 <simpson> SamanthaD: Is this homework or personal study?
00:10:17 * simpson wants to paste the one-liner of magic and wonder
00:10:26 <SamanthaD> Axman6: thanks
00:10:32 <SamanthaD> simpson: It's for fun.
00:10:32 <Tordek> Oh, thanks for reding that, simpson, btw
00:11:02 <simpson> > nubBy (\x y -> gcd x y > 1) [2..]
00:11:03 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
00:11:16 <simpson> Using Data.List.nubBy.
00:11:35 <Axman6> that one's no fun
00:11:36 <simpson> It took me a while to really grok this one, but once I got it, it was enlightening.
00:11:48 <Axman6> als it has somewhat gross complexity
00:11:49 <SamanthaD> simpson: thanks!
00:12:04 <Axman6> SamanthaD: keep going with what you havem it's much more fun and you'll learn more
00:12:04 <simpson> Axman6: No grosser than any other general enumeration of primes.
00:12:24 <Tordek> I'm afraid to ask...
00:12:32 <Tordek> what does nubBy do?
00:12:51 <Axman6> > nubBy (==) [1,2,3,1,2,3,1,2,3,4,5,6]
00:12:53 <lambdabot>   [1,2,3,4,5,6]
00:12:55 <simpson> SamanthaD: This is just another way to do things. Hopefully it fills you with wide-eyed wonder at the magic of programming.
00:12:59 <SamanthaD> axman6: It's a bit complex but the optimization ought to provide HUGE performance gains, especially as you get to very large primes.
00:13:34 <simpson> Tordek: nub uniquifies a list. nubBy lets you alter the comparison from (==) to something else.
00:13:36 <Axman6> SamanthaD: Well, I don't know about Huge, but it'll be better than the nubBy example
00:13:52 <simpson> Tordek: It's not very performant. :3
00:14:07 <Axman6> @src nubBy
00:14:07 <lambdabot> nubBy eq []             =  []
00:14:07 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
00:14:18 <SamanthaD> Axman6: well... as you get to the high numbers the distance between primes becomes very large. Therefore, if your iterator is skipping 99% of the test conditions...
00:14:47 <simpson> SamanthaD: As you get larger, the quality of your sieves starts to matter.
00:15:17 * hackagebot wai-extra 1.3.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.2 (MichaelSnoyman)
00:15:23 <SamanthaD> simpson: are you saying there's a problem with my mathematical reasoning or are you talking about nubBy?
00:15:48 <simpson> SamanthaD: Oh, neither. Just in general. Your math doesn't look wrong.
00:16:00 <shachaf> That nubBy thing is an abuse of nubBy
00:16:08 <SamanthaD> simpson: that's good!
00:16:13 <shachaf> And also terribly inefficient.
00:16:16 <SamanthaD> Oh, hey shachaf!
00:16:16 <simpson> Yeah, I'd be ashamed but I'm not the one that invented it.
00:16:31 <shachaf> hi SamanthaD
00:16:56 <basdirks> @src length
00:16:57 <lambdabot> Source not found. Wrong!  You cheating scum!
00:17:00 <SamanthaD> shachaf: I just invented an algorithm but I made a mistake so it extremely efficiently got stuck in a loop ;)
00:17:02 <shachaf> simpson: The only reason that says ">1" is for maximum golfing.
00:17:14 <shachaf> > (((>1).).gcd)[2..]
00:17:15 <lambdabot>   No instance for (GHC.Real.Integral [t0])
00:17:15 <lambdabot>    arising from a use of `e_112'
00:17:15 <lambdabot>  ...
00:17:17 <basdirks> @src Prelude.length
00:17:17 <lambdabot> Source not found. You speak an infinite deal of nothing
00:17:21 <SamanthaD> shachaf: fortunately, it's a problem of implementation and not mathematical reasoning so I haven't just wasted my entire day.
00:17:22 <shachaf> > nubBy(((>1).).gcd)[2..]
00:17:22 <simpson> shachaf: Yeah, I know.
00:17:25 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
00:17:32 <shachaf> Really it should be (/=1)
00:17:34 <shachaf> Or something.
00:18:13 <simpson> > nubBy (\x y -> gcd x y /= 1) $ concatMap (\x -> [x-1, x+1]) [6,12..]
00:18:14 <lambdabot>   [5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103...
00:18:44 <simpson> > nubBy (\x y -> gcd x y /= 1) $ [2,3] ++ concatMap (\x -> [x-1, x+1]) [6,12..]
00:18:46 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
00:18:48 <SamanthaD> Anyway, thanks for the input. I'm going to go drop out for a moment so I can concentrate on my source. I'll paste the fixed up source when I'm done in a few minutes!
00:18:50 <basdirks> > foldr (\_ -> (+1)) 0 "foodoo"
00:18:51 <lambdabot>   6
00:18:57 <shachaf> SamanthaD: Mathematical reasoning that leads nowhere is not wasted.
00:19:01 <simpson> Using the first wheel sieve.
00:19:11 <SamanthaD> shachaf: point taken
00:19:45 <basdirks> is that an ugly definition of length?
00:19:54 <basdirks> foldr (\_ -> (+1)) 0
00:20:06 <shachaf> Looks OK to me.
00:20:16 <basdirks> I think it's cute, but maybe too cute
00:20:34 <simpson> Well, isn't the canonical definition of length just that fold, simplified and type-restricted?
00:20:36 <shachaf> It's not good for actual programs, but it's fine as an exercise in foldrism.
00:20:37 <simpson> @src length
00:20:37 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
00:21:02 <basdirks> length []        =  0
00:21:02 <basdirks> length (_:l)     =  1 + length l
00:21:09 * simpson thought it was something like length [] = 0; length (x:xs) = 1 + length xs
00:21:20 <shachaf> Well, that's the same as the foldr definition.
00:22:14 <basdirks> yes I came up with the foldr definition for an exercise in RWH, but I think it's the same as the Prelude definition
00:23:10 <Tordek> > :t \_ -> (+1)
00:23:12 <lambdabot>   <hint>:1:1: parse error on input `:'
00:23:15 <Tordek>  :t \_ -> (+1)
00:23:21 <Tordek> :t \_ -> (+1)
00:23:22 <lambdabot> Num a => t -> a -> a
00:23:55 <Nereid> ok, shelly is cool.
00:24:05 <Tordek> hmm?
00:34:45 <Nereid> current use case: sending an email
00:35:25 <Nereid> shelly $ setStdin blahblah >> run_ "mail" ["-s" "blah" "foo@example.com"]
00:35:26 <Nereid> too easy.
00:35:48 <Tordek> oh, quick question
00:36:07 <Tordek> why's main IO () instead of IO Byte or something?
00:36:19 <Nereid> it can be IO anything.
00:36:23 <shachaf> Why would it be IO Byte?
00:36:28 <Nereid> but the return value is ignored.
00:36:33 <Axman6> it would be IO Int, and we have another function for setting the return value to the OS
00:36:36 <Tordek> shachaf: standard Unix return code?
00:36:40 <Nereid> if you want an exit code, use System.Ext
00:36:43 <Nereid> System.Exit
00:37:05 <shachaf> I'm not sure that particularly belongs as the return value of main.
00:37:11 <shachaf> But anyway what other people said.
00:50:56 <SamanthaD> what's the standard way of appending an element to the end of a list efficiently?
00:51:09 <Nereid> once or repeatedly?
00:51:10 <mauke> not using a list
00:51:38 <SamanthaD> Nereid: repeatedly
00:51:48 <Nereid> right. use a DList or something, then.
00:51:57 <simpson> Or keep the list in reversed order.
00:52:32 <SamanthaD> simpson: hmmm... the thing is that won't work because then the functions that accept the list won't work right...
00:53:11 <Nereid> @hackage dlist
00:53:11 <lambdabot> http://hackage.haskell.org/package/dlist
00:54:08 <simpson> SamanthaD: Well, I guess it depends on what you want to do with the list's contents.
00:54:43 <SamanthaD> simpson: let me fix it up with a ++ and then upload the source and you can see for yourself
00:54:55 <malthe> morning
00:55:15 <Nereid> a third of my 50-line haskell program consists of imports. :(
00:55:33 <srhb> Nereid: Time to make your own Prelude!
00:55:51 <srhb> malthe: Morning
00:56:04 <Nereid> half the stuff is stuff I wouldn't want in a Prelude though.
00:56:14 <Nereid> and can you even export things qualified?
00:56:26 <malthe> question: for an experiment in writing a key/value database, is haskell an "academic", or very unobvious choice?
00:56:27 <frerich> Nereid: I guess that means that you get to enjoy a lot of code reuse :)
00:56:45 <hpaste> “Samantha Davis” pasted “Incomplete Prime Generator” at http://hpaste.org/80524
00:56:50 <srhb> malthe: Naw, it's entirely possible
00:57:02 <srhb> malthe: Look at ixset for instance.
00:57:13 <srhb> malthe: Or even Map
00:57:20 <SamanthaD> simpson: as you can see, the list is supposed to contain a list of known prime numbers in order to expidite the searching of new ones.
00:57:40 <SamanthaD> simpson: it's MUCH more important that the list be easy to read than easy to append to, though... which is why I'm leery of using dlists
00:57:53 <Nereid> it's just a little thing though. http-conduit-browser to fetch page contents, tagsoup to extract some info from it, and shelly to invoke `mail` depending on what it sees in the page.
00:58:00 <malthe> srhb, there's quite a bit of computation involved in the algorithm I found, but I guess Haskell is actually pretty good at multi-core.
00:58:02 <Nereid> fairly pleasing.
00:58:14 <srhb> malthe: Pretty good is probably an understatement.
00:58:20 <malthe> I'll take a look at ixset, definitely.
00:58:38 <Nereid> SamanthaD: dlists are easy to read though.
00:58:43 <srhb> But of course, you have to be able to adapt your algorithm.
00:58:48 <malthe> :-).
00:58:49 <Nereid> via toList
00:59:04 <srhb> malthe: Also yay to more Danes in #haskell. ;)
00:59:08 <SamanthaD> Nereid: Hmm... as efficient as normal lists? Maybe I should use them. I've just never used dlists before.
00:59:20 <malthe> it's sort of like a log structured merge tree.
00:59:21 <Nereid> DList has O(1) append and O(n) toList.
00:59:38 <Nereid> O(1) append is the reason it exists.
00:59:56 <SamanthaD> Nereid: eeew... I don't like that O(n) toList... when this girl starts chugging that list is going to be positively ENORMOUS.
01:00:03 <malthe> srhb :-) ... yup, a fellow Dane here.
01:00:09 <Nereid> well
01:00:14 <SamanthaD> Nereid: also, it's very important to keep copying of that list down to an absolute minimum
01:00:25 <Nereid> but you only do that once.
01:00:34 <Nereid> oh, and it's lazy I guess.
01:00:34 <SamanthaD> Nereid: if I don't the memory footprint skyrockets untennably.
01:00:54 <Nereid> basically all it does is reassociates all your appends to the right.
01:01:21 <SamanthaD> Nereid: Hmm... would toList make a copy of it?
01:01:28 <Nereid> look at the implementation.
01:01:32 <Nereid> it's very simple.
01:01:42 <srhb> malthe: To expand a bit, I think that databases like Postgre and friends really fill the market currently, but if I wanted to experiment with writing one anyway, I really think Haskell would be one of the more comfortable languages to do it in.
01:02:05 <srhb> malthe: Of course, it depends on which parameters you have and what you're going to be using the database for.
01:03:23 <swi> Hello. I have a trouble with understanding some part about recursive types. Can someone help me ?
01:03:38 <srhb> swi: State your question instead. :)
01:04:46 <malthe> srhb, yeah, it's mostly an exercise: take some theory, implement it and hopefully use it as a vehicle to learn a new language.
01:05:13 <srhb> malthe: Then I think you've made the right choice. Ever done Haskell before? It might be a bit time before you can write an actual DB then ;)
01:05:13 <malthe> i'm a bit of a burned-out python consultant, needing to reconnect with computer science :-).
01:05:19 * hackagebot cprng-aes 0.3.3 - Crypto Pseudo Random Number Generator using AES in counter mode.  http://hackage.haskell.org/package/cprng-aes-0.3.3 (VincentHanquez)
01:05:21 * hackagebot cryptocipher 0.4.0 - Symmetrical block and stream ciphers.  http://hackage.haskell.org/package/cryptocipher-0.4.0 (VincentHanquez)
01:05:23 <srhb> malthe: Ah, no better cure. :P
01:05:57 <malthe> well, I read the two books RWH and the Slovenian one.
01:06:01 <srhb> malthe: If you've not done some real functional programming before, Haskell is probably going to take some time becoming proficient in, but it's worth it.
01:06:02 <srhb> LYAH?
01:06:11 <malthe> ya
01:06:15 <srhb> You're good to go then. :-)
01:06:37 <malthe> We used ML at university.
01:07:01 <srhb> malthe: Which uni?
01:07:07 <malthe> copenhagen
01:07:12 <srhb> malthe: Ah, so mosML
01:07:16 <srhb> malthe: That helps a lot.
01:08:06 <malthe> a key/value store is slightly daunting, _but_ there's a lot of bits and pieces, and I guess the whole idea with functional is that you can work with them individually.
01:08:15 <srhb> Yes, definitely.
01:08:16 <SamanthaD> Ugh... it's one in the morning. No wonder my eyes hurt. I got the list to append properly but the damn program is still being buggy. I'm going to hang it up for tonight and maybe I'll dream in math tonight and fix it in the morning.
01:08:20 <SamanthaD> thanks for all your help everyone!
01:08:39 <srhb> malthe: You could totally write a blog about the journey (hint hint)
01:08:47 <hpaste> swi pasted “recursive” at http://hpaste.org/80526
01:08:50 <malthe> hehe, that's not a bad idea.
01:08:55 <SamanthaD> Goodnight!
01:09:12 <srhb> malthe: :-) I'd love to follow it.
01:09:34 <srhb> swi: So, prefer pattern matching. Problem is your first pattern matches immediately.
01:09:38 <swi> srhb: http://hpaste.org/80526 - why there is error at the end and what i need to make exception there ?
01:09:44 <srhb> swi: and the tail is empy
01:09:52 <srhb> > tail [1]
01:09:53 <lambdabot>   []
01:10:19 * hackagebot tls 1.1.0 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.1.0 (VincentHanquez)
01:10:21 * hackagebot tls-extra 0.6.0 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.6.0 (VincentHanquez)
01:10:23 * hackagebot tls-debug 0.2.2 - Set of programs for TLS testing and debugging  http://hackage.haskell.org/package/tls-debug-0.2.2 (VincentHanquez)
01:10:25 <srhb> swi: If you really want to implement head, why not make it safe and write a [a] -> Maybe a ?
01:11:21 <srhb> swi: Oh, sorry, not head. But still! Same reasoning applies.
01:12:02 <srhb> swi: mySecond (_:x:_) = Just x; mySecond _ = Nothing -- can you see why that's much better?
01:16:42 <swi> srhb: .. put aside _ - that mean that my mySecond Non-exhaustive
01:16:43 <swi> ?
01:16:54 <Nereid> :t listToMaybe
01:16:55 <lambdabot> [a] -> Maybe a
01:16:58 <Nereid> aka safeHead
01:17:00 <srhb> swi: My definition is not nonexhaustive
01:17:17 <srhb> swi: _ is a wildcard, it matches anything and binds nothing.
01:17:34 <swi> srhb: yes. but my does not have [] version
01:17:47 <swi> i mean i can write mySecond [] = Nothing
01:17:55 <srhb> swi: Yes.
01:18:13 <Nereid> > map (listToMaybe . drop1) ([1,2,3], [1], [])
01:18:14 <lambdabot>   Not in scope: `drop1'
01:18:14 <lambdabot>  Perhaps you meant one of these:
01:18:14 <lambdabot>    `drop' (imported ...
01:18:18 <Nereid> > map (listToMaybe . drop 1) ([1,2,3], [1], [])
01:18:19 <lambdabot>   Couldn't match expected type `[[a0]]'
01:18:19 <lambdabot>              with actual type `(t0, t...
01:18:31 <Nereid> > map (listToMaybe . drop 1) [[1,2,3], [1], []] -- duh
01:18:33 <lambdabot>   [Just 2,Nothing,Nothing]
01:18:48 <srhb> swi: And?
01:19:12 <Nereid> but still, pattern matching is probably a good to go.
01:19:13 <Nereid> good way.
01:19:30 <srhb> I think especially at this level, it's the way to go... :)
01:19:38 <srhb> Understanding the basics before moving to the right combinators.
01:19:45 <srhb> (Some people disagre, I know)
01:19:48 <swi> srhb: hm. seems i can't write mySecond [] = Nothing :)
01:19:55 <srhb> swi: Sure you can.
01:20:00 <srhb> swi: But you need to handle the other cases as well.
01:20:04 <Nereid> you can if you put it on top.
01:20:13 <swi> Couldn't match type `a' with `Maybe a0'
01:20:22 <srhb> swi: Then you have another case that does not return a Maybe
01:20:25 <srhb> swi: That's a type error
01:20:41 <swi> In an equation for `mySecond': mySecond [] = Nothing
01:20:53 <srhb> swi: Right, but that's not the error (if you want to use Maybe)
01:20:55 <Nereid> because your type signature is wrong.
01:21:07 <Nereid> or something.
01:21:10 <hpaste> Nereid annotated “recursive” with “recursive (annotation)” at http://hpaste.org/80526#a80527
01:21:26 <srhb> > let mySecond [] = Nothing in mySecond []
01:21:27 <lambdabot>   Nothing
01:21:28 <swi> Nereid: i see. cause [] is a [a] but Nothing is Maybe
01:21:47 <Nereid> @let safeIndex xs n = maybeToList (drop n xs)
01:21:47 <lambdabot>  <local>:3:31:
01:21:47 <lambdabot>      Couldn't match expected type `Maybe a0' with actual type ...
01:21:53 <Nereid> w
01:21:57 <Nereid> @let safeIndex xs n = listToMaybe (drop n xs)
01:21:59 <lambdabot>  Defined.
01:22:03 <Nereid> > safeIndex [1,2,3] 1
01:22:05 <lambdabot>   Just 2
01:22:15 <Nereid> hmm I should have defined that flipped.
01:22:27 <srhb> Wonder if this is possible
01:22:33 <srhb> @let safeIndex = flip safeIndex
01:22:34 <lambdabot>  <local>:3:1:
01:22:34 <lambdabot>      Equations for `safeIndex' have different numbers of argume...
01:22:36 <srhb> Aw.
01:22:38 <swi> hm.
01:22:43 <Nereid> interesting message.
01:22:44 <swi> Not in scope: data constructor `Maybe'
01:22:49 <Nereid> @let safeIndex _ _ = undefined
01:22:50 <lambdabot>  <local>:3:1:
01:22:50 <lambdabot>      Warning: Pattern match(es) are overlapped
01:22:50 <lambdabot>               In...
01:22:55 <srhb> swi: Maybe is the type, not the value constructor
01:23:02 <srhb> swi: What exactly are you trying to do now?
01:23:03 <Nereid> oh ok.
01:23:16 <Nereid> Maybe is not a function.
01:23:20 <Nereid> it's a type constructor.
01:23:22 <swi> srhb: seems i'm lost in that
01:23:24 <Nereid> it goes in types, not values.
01:23:28 <srhb> swi: In what you want to do?
01:24:07 <Nereid> you should paste the code that's erroring, though, to make it easier for us to help.
01:24:16 <Nereid> along with the error of course
01:24:42 <swi> well. in mySecond i want function return second element of list or make an exception if list too short or empty
01:24:53 <srhb> swi: Exceptions are evil. Why do you want to do that?
01:24:56 <Nereid> you already have done that.
01:25:03 <srhb> swi: And yes, your function does exactly that
01:25:14 <Nereid> but exceptions can't be caught in pure code.
01:25:30 <swi> Nereid: exceptions here just for example.
01:25:37 <srhb> swi: Well, then you're done.
01:26:07 <Nereid> also, note that your function will give a _different_ error when you pass it []
01:26:15 <srhb> let mySecond xs = if null (tail xs) then error "too short" else head (tail xs) in mySecond [1]
01:26:17 <Nereid> because tail xs errors before you can see if it's null
01:26:19 <srhb> > let mySecond xs = if null (tail xs) then error "too short" else head (tail xs) in mySecond [1]
01:26:21 <lambdabot>   *Exception: too short
01:26:25 <srhb> > let mySecond xs = if null (tail xs) then error "too short" else head (tail xs) in mySecond [1,2]
01:26:26 <lambdabot>   2
01:26:31 <srhb> See, it works like a charm.
01:26:35 <Nereid> > let mySecond xs = if null (tail xs) then error "too short" else head (tail xs) in mySecond []
01:26:36 <lambdabot>   *Exception: Prelude.tail: empty list
01:26:38 <srhb> (Except you should not use exceptions)
01:27:04 <ehamberg> in the ST monad, using Data.Vector.Mutable (MV) I can do “a <- MV.new n” to get a new, mutable vector of length n. how do I get a 2-dimensional mutable vector of size m×n?
01:27:49 <swi> srhb: Nereid ahh. i think i catch you
01:27:49 <statusfailed> Can I write a function like "maybe" for arbitrary Alternative instances?
01:27:55 <Hugosthlm> How can I run Hoogle server as user on Ubuntu? http://pastebin.com/qCwazdzW
01:27:57 <Nereid> ehamberg: use array instead of vector.
01:27:57 <mauke> The paste qCwazdzW has been copied to http://hpaste.org/80528
01:28:21 <srhb> Hugosthlm: You're not allowed to bind such low port numbers as non-root
01:28:22 <t7> Hugosthlm: use a higher port number
01:28:36 <Nereid> specifically, port 1024 or higher
01:28:46 <Hugosthlm> Thanx, trying
01:29:26 <ehamberg> Nereid: so I should use Data.Array.ST for 2-dim. (or larger)?
01:29:27 <t7> running a socket server as root seems a bit risky
01:29:43 <tdammers> t7: not just a bit.
01:29:47 <simpson> authbind is your friend.
01:30:10 <t7> i used to just re direct 80 to 8000 when i had my server
01:30:13 <Nereid> which is why a lot of things run as root just long enough to bind the port and then drop to a less-privileged user.
01:30:21 <`ramses> statusfailed: what would the type be?
01:30:43 <Fuuzetsu> @pl f x = g x == h x
01:30:43 <lambdabot> f = liftM2 (==) g h
01:30:59 <Nereid> or liftA2
01:31:07 <tdammers> t7: I use a reverse proxy
01:31:11 <Nereid> or (==) <$> g <*> h if you're into that sort of thing.
01:31:54 <Nereid> ah, authbind does what I thought it does.
01:32:22 <tdammers> my application listens on 8000; that port is firewalled off of the outside world, and apache is configured to reverse-proxy, if the conditions are right
01:35:04 <Hugosthlm> Now Hoogle server starts. When I try to open it in the browser the server terminates. http://tny.cz/2862a219
01:35:56 <swi> srhb: can i use Maybe in ADT ?
01:36:33 <`ramses> swi: sure
01:37:09 <mrout> remind me why the IO monad is pure
01:37:39 <tdammers> mrout: because *everything* in Haskell is?
01:37:52 <srhb> mrout: It's a recipe for producing a value. That recipe is pure.
01:38:00 <mrout> not UnsafePerformIO That's not pure.
01:38:04 <swi> > let data Foo = Foo Int deriving (Show)
01:38:05 <lambdabot>   <hint>:1:5: parse error on input `data'
01:38:30 <swi> > data Foo = Foo Int deriving (Show)
01:38:31 <lambdabot>   <hint>:1:1: parse error on input `data'
01:38:39 <Nereid> you can't define data things in lambdabot
01:38:40 <srhb> swi: Lambdabot does not do that
01:38:47 <swi> :) i see
01:38:52 <tdammers> I like to pretend unsafePerformIO doesn't exist
01:38:56 <Nereid> if only we could. :c
01:39:19 <merijn> mrout: One way to look at it is this: "getLine" is a "program fragment" that reads a string and returns it. getLine *always* returns the exact same program fragment (which makes it pure)
01:39:23 <mrout> Anyway, WHY is IO pure? It performs a sideffect, right?
01:39:27 <swi> well, this work in ghci. How can i put Maybe (where) in this data definition ?
01:39:41 <tdammers> mrout: not directly
01:39:48 <srhb> mrout: The RTS might.
01:39:54 <tdammers> IO is just an opaque data structure
01:39:55 <`ramses> mrout: the runtime system performs the side-effect
01:39:55 <merijn> mrout: Since you *can't* run program fragments, they can't produce side effects. You can *combine* program fragments into *bigger* fragments using, for example, >>=
01:40:06 <tdammers> the side effects occur when you run it through the runtime
01:40:26 <tdammers> but that happens outside the realm of the Haskell programming language
01:40:38 <merijn> mrout: "getLine >>= putStrLn" is basically combining a program fragment that produces strings and a function that takes a string and returns a program fragment into a bigger program fragment that prints something
01:40:50 <srhb> swi: data Foo a = Bar (Maybe a) | Baz
01:40:52 <mrout> if you say so.
01:40:55 <mrout> fair enough
01:40:57 <merijn> mrout: No matter where or when, that text will always return the *exact* same program fragment
01:40:57 <srhb> swi: (Useless data type, but still)
01:41:43 <Fuuzetsu> @pl f x y = (g x y) == (h x y)
01:41:43 <lambdabot> f = ap (ap . ((==) .) . g) h
01:41:45 <mrout> that does make sense
01:41:48 <Fuuzetsu> nope
01:41:48 <merijn> mrout: Now, when the RTS executes the main action it will start to actually run various program fragments (and produce side effects), but that's not visible from within Haskell
01:41:55 <Fuuzetsu> :t ap
01:41:56 <lambdabot> Monad m => m (a -> b) -> m a -> m b
01:41:58 <mrout> It returns the program fragment "get some text then print it", right?
01:42:12 <Nereid> ap f g x = f x (g x)
01:42:15 <merijn> mrout: Yes, which is the same regardless of context (i.e. referentially transparent)
01:42:19 <swi> srhb: oh.. bracers.. i forgot
01:42:19 <mrout> Huh
01:42:22 <mrout> That's neat
01:42:40 <srhb> swi: Note that, as Nereid pointed out, Maybe is a _type_ constructor, it needs an argument to produce a concrete type. Maybe is a type constructor, Maybe a is a type
01:42:44 <srhb> (fsvo a)
01:42:47 <mrout> Seems like a cheat when you first think about it, but it's actually a pretty clever way of thinking about it
01:42:55 <merijn> mrout: *running* it, is not referentially transparent, but you *can't* run things from within Haskell. Only the RTS system can execute things (i.e. main)
01:43:23 <srhb> I suppose the logical question to ask is then "why is printf not pure in C?" and then note the difference
01:43:29 <merijn> mrout: Another way to look at it, is this
01:43:35 <merijn> @quote shachaf getLine
01:43:35 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
01:43:55 <merijn> If you think of getLine as "ls", then >>= would be the | operators from shell
01:44:53 <Spockz> kosmikus: how do I escape the @ in \@ifundefined?
01:45:10 <Spockz> kosmikus: when using lhs2tex, that is
01:45:26 <noname_> how does haskell help for a web developer
01:46:24 <swi> srhb: so, if have Some :: Maybe Int -> Some data i can't use it  :)
01:46:56 * swi feels like it' try to use Maybe in wrong places
01:47:30 <noname_> ?
01:47:35 <tdammers> noname_: it can help in many ways
01:47:58 <tdammers> there are a few web frameworks, and they are quite comfortable, type-safe, and blazing fast
01:48:05 <srhb> swi: You probably are. I don't understand your question. What do you mean by "Some" ? Is that a type? If so, what does the type signature mean?
01:48:19 <swi> Some is data
01:48:20 <mrout> Still, it's not really for web development, is it?
01:48:22 <tdammers> but you can also use Haskell to write tools for developing in a more mainstream language
01:48:27 <srhb> swi: But then :: makes very little sense.
01:48:42 <noname_> ok... much more like c#
01:48:43 <noname_> ?
01:48:48 <tdammers> mrout: it's just as much "for" web development as python
01:49:01 <srhb> swi: And of course, if you can define a data type, you can use it.
01:49:11 <mrout> Join #d. This guy has gone full retard. Apparently "ha, and as it is pure, it is implementable in haskell. As it is big, let's focus on a simple part of it : outputting on the console. you can output on the console using IO monad, right ?"
01:49:23 <swi> srhb: data Some = Some (Maybe Int) deriving (Show); But i can't use it as Some 1
01:49:38 <tdammers> the thing that makes Haskell especially interesting for web dev is its type system
01:49:38 <Nereid> well no, 1 isn't a Maybe Int
01:49:44 <swi> yes
01:50:07 <swi> so this data type is practicaly useless ?
01:50:09 <srhb> swi: But you can say Some (Just 1)
01:50:15 <tdammers> for example, you can define a type to represent HTML source, and now the compiler can prevent you from throwing plain strings into a context that expects HTML source by accident
01:50:17 <Nereid> or Some Nothing
01:50:18 <zxq9> noname_: Not sure if you're asking the right question... You have to define what it is you want to do first.
01:50:19 <srhb> swi: Yes, it's useless. You're just wrapping Maybe Int after all
01:50:20 * hackagebot dynamic-object 0.2 - Object-oriented programming with duck typing and  singleton classes.  http://hackage.haskell.org/package/dynamic-object-0.2 (TakayukiMuranushi)
01:50:38 <tdammers> Haskell also excels at building parsers and such
01:50:46 <mrout> tdammers: well to be fair, a plain string is a valid HTML source, at least in the sense that a web browser will read it and parse it and turn it into a (simple) web page.
01:50:58 <srhb> swi: There's no functional difference between Some (Maybe Int) and Maybe Int if the Some type does not have other value constructors than the Some constructor.
01:51:11 <Fuuzetsu> @pl m (f:fs) t = f t && m fs t
01:51:11 <lambdabot> m = fix ((`ap` tail) . (. head) . flip ((.) . liftM2 (&&)))
01:51:13 <Nereid> well, there is a subtle difference.
01:51:14 <tdammers> mrout: raw strings and HTML source can both be represented as bytestrings, but they're not interchangeable
01:51:37 <tdammers> about half the security problems on the internet are caused by this
01:51:41 <`ramses> srhb: except if some has some interesting instances
01:51:52 <srhb> I doubt that's relevant right now.
01:51:59 <tdammers> (or similar mechanisms in the realm of SQL queries, JavaScript, etc.)
01:52:04 <`ramses> probably
01:52:33 <tdammers> the thing is, HTML and raw strings aren't the same, and you cannot naively treat any given string as HTML without running into problems at some point
01:52:48 <mrout> tdammers: why on earth not?
01:53:02 <mrout> a given string won't necessarily be VALID html.
01:53:14 <tdammers> but what's worse, it might accidentally be
01:53:17 <mrout> might not even be WELL FORMED html.
01:53:21 <Jafet> If it's not valid HTML, why would you consider it HTML?
01:53:25 <swi> srhb: Nereid thanks for your patience. Seems like a i catch a point
01:53:44 <Jafet> Its type should not be HTML unless it is valid HTML.
01:53:49 <tdammers> and there is no way to automatically decide whether a given string is raw or HTML without extra information
01:54:08 <zxq9> tdammers: Well, getting more basic about half of that half of server-side security problems are caused by telling the "app" or "app server" layer to handle security instead of actually defining a security model within the DB like they were designed to be used...
01:54:38 <Nereid> mrout: you know that to do things safely, you need to escape text before inserting it into your HTML.
01:54:43 <tdammers> zxq9: how does a security model in the DB help prevent SQL injection and XSS?
01:54:50 <Nereid> else you're prone to XSS vulnerabilities and such.
01:55:21 <Nereid> so to prevent you from accidentally forgetting to escape, we can make a type-level distinction between arbitrary text and HTML.
01:55:26 <Nereid> that's the point.
01:55:31 <tdammers> yup
01:56:12 <Jafet> @quote shachaf domain.specific
01:56:12 <lambdabot> No quotes match. :(
01:56:24 <Jafet> Oh, I didn't add it
01:56:24 <tdammers> in typical PHP code, this distinction also has to be made, but it's not usually explicit in the code - the programmer has to remember which strings are supposed to be HTML and which aren't
01:56:25 <zxq9> tdammers: Injected code shouldn't have the priviledge of executing if the DB side is designed properly.
01:56:55 <tdammers> zxq9: that's one part, but if the code that constructs queries is insecure, you can't prevent all leaks
01:56:55 <Nereid> zxq9: not really.
01:57:13 <tdammers> you have to give the application *some* permissions; SELECT at the very least
01:57:21 <`ramses> zxq9: that can't prevent xss or csrf
01:57:30 <tdammers> and there is plenty of damage you can do just by injecting into SELECT queries
01:57:31 <zxq9> tdammers: Schema, table, column, trigger, function, etc. priviledge levels being set prevents that. But most frameworks don't split the tasks of standup, maintenance and service among roles (at all!) so injection has been a big problem.
01:57:32 <Nereid> if you have code that inserts some rows into a table, DB privileges won't prevent you from making some SQL injection thing that'll insert other rows that you didn't intend
01:57:39 <Nereid> or select, or ...
01:58:14 <Jafet> Priviledge, the best ledge
01:58:23 <tdammers> simple example: your application's login page simply *has* to have SELECT permissions on the users table, there is no way around this
01:58:42 <zxq9> `ramses: True, I'm just addressing SQL injection -- which is the widest gaping hole (or at least was until very recently). The nature of XSS and CSRF is very different.
01:59:01 <tdammers> if you have an SQL injection vulnerability, that's enough privilege to enumerate users and read out their hashed passwords
01:59:03 <zxq9> `ramses: As in its part of the "let's pretend documents are programs" philosophical hole we've dug.
01:59:06 <Nereid> XSS and SQL injection are essentially the same class of vulnerability
01:59:11 <`ramses> ah, okay, I had the impression you were talking about web security in general
01:59:17 <tdammers> or maybe even bypass the authentication altogether
01:59:38 <Jafet> SQL injection is a thing of the past'--
01:59:47 <tdammers> the famous WHERE username = 'johndoe' AND password = 'not the correct one' OR 1=1; -- '
01:59:57 <tdammers> or
02:00:05 <Jafet> All the cool startups are using nosql now, so SQL injection doesn't work any more
02:00:14 <Jafet> The cool startups also drink notea
02:00:19 <`ramses> NoSQL injection? :)
02:00:19 <tdammers> WHERE username = 'johndoe' OR 1=1; -- ' AND password = 'not the correct one'
02:00:52 <merijn> The sad thing about SQL injections and XSS is that they're so simple to prevent using the same short mantra
02:00:55 <tdammers> Jafet: I'm pretty sure those new nosql are much more secure than the decade-old relational db codebases
02:01:04 <zxq9> tdammers: It doesn't have to have SELECT priviledge if the login cycle is a procedure which itself is protected and restricted to a specific form of query... but I digress. Consider how the Postgres systems tables are handled by non superusers, for example. This problem has been well thought through already.
02:01:11 <merijn> "never, ever, ever trust input from the fucking user"
02:01:30 <Jafet> Naw, they can trust me.
02:01:35 <tdammers> zxq9: still
02:02:16 <tdammers> you just can't guarantee that there is absolutely no way to call those procedures in a way that wasn't intended if you allow users to submit their own queries
02:02:30 <zxq9> tdammers: I'm not discounting the type system of Haskell -- its not just powerful, its beautiful because its not even something that incurs mental overhead (amazing!) -- I'm just saying there are well understood security basics that are being overlooked by web developers in general.
02:02:44 <tdammers> I'm not overlooking them
02:02:52 <tdammers> I'm just saying they're insufficient by themselves
02:02:56 <saeidw> There's a whole "langsec" philosophy about not doing ad-hoc processing of user input
02:03:05 <merijn> zxq9: "doesn't incur mental overhead" clearly you haven't looked at much of edwardk's code ;)
02:03:05 <zxq9> bingo
02:03:10 <saeidw> http://www.cs.dartmouth.edu/~sergey/langsec/
02:03:29 <Jafet> merijn: that's a different meaning of "overhead"
02:03:43 <tdammers> proper database permissions are important, but having them in place is no excuse for SQL injection vulnerabilities in your code
02:03:45 <merijn> Jafet++
02:03:45 <`ramses> merijn: I imagine such code would be even worse without types
02:04:02 <merijn> `ramses: Pretty sure it can't run without types in some cases :)
02:04:09 <Nereid> Jafet: the "whoosh" kind of meaning?
02:04:22 <`ramses> it can, but reading it would be harder still, I think
02:04:34 <`ramses> oh I thought you said it can
02:04:34 <Jafet> The plaid kind
02:04:37 <zxq9> tdammers: I definitely agree with you there. And most people aren't willing to go to the trouble of thoroughly designing their data model in the first place, instead just relying on whatever an ORM or builder framework spews out.
02:04:40 <`ramses> I don't know if it can :)
02:05:20 * hackagebot cprng-aes 0.3.4 - Crypto Pseudo Random Number Generator using AES in counter mode.  http://hackage.haskell.org/package/cprng-aes-0.3.4 (VincentHanquez)
02:05:59 <zxq9> tdammers: But I don't think there is really any way to secure the web in the first place. The idea that we can secure what was designed to be an unsecure, public, unthrottled document broadcast publication protocol is a bit silly to begin with...
02:06:26 <tdammers> of course
02:06:33 <tdammers> security is relative
02:07:17 <Jafet> Al Gore designed the web to be a high-quality enabling technology platform for sharing cat pictures over facebook
02:07:28 <tdammers> one doesn't aim for "impossible", but rather just "not worth it"
02:07:38 <Jafet> Claiming that we should not work on security is defeatism. It's also unpatriotic.
02:07:52 <zxq9> hehe
02:08:18 <tdammers> i.e., if your data is worth a million dollars, then you should design your security so that getting at your data costs significantly more than a million dollars
02:08:44 <zxq9> Security for networked applications that can be arbitrarily called/browsed would have to start with designing a protocol around that concept, then, not around trying to make public data selectivly private.
02:08:53 <Jafet> I wonder how many janitors you can hire for a million dollars
02:09:17 <zxq9> So an application browser would look significantly different than a document browser.
02:09:58 <zxq9> Jafet: If they keep diluting the dollar then the number will soon shrink to a very few.
02:13:01 <frerich> Finally, after months of lobbying in the company, I have colleagues reading LYAH and we end up discussing things like how to fold a tree when waiting for the coffee machine!
02:13:06 <frerich> Niahahaha!
02:13:39 <srhb> frerich: Bliss!
02:13:39 <tdammers> zxq9: it's called "inflation", and it's basically required to keep a growth-based economy going
02:14:26 <tdammers> without inflation, spending your money would be stupid, because you could just wait for it to increase in value
02:14:43 <tdammers> and then when everyone does that, the economy comes to a grinding halt
02:14:54 <pettter> tdammers: or you could spend it because you actually want the thing you are buying
02:15:07 <zxq9> tdammers: Inflationary spending to cover deficit spending is not the same thing. And growth has its limits as a policy.
02:15:13 <frerich> tdammers: Or maybe you have to spend your money no matter what since you need food and pay rent :}
02:15:43 <tdammers> I don't subscribe to growth-based economy models myself, but it looks like we're stuck with one for now
02:16:03 <tdammers> frerich: I'm talking about investable money here
02:16:06 <zxq9> tdammers: I'm well aware the hazards of deflation spirals -- I live in Japan and we're trying to sit out deflationary pressure at the moment, which isn't working well -- because it never works well.
02:16:49 <tdammers> the kind of money that people can make actual choices about
02:17:08 <frerich> I keep hearing about that, must be cool ;-)
02:17:17 <srhb> frerich: Same.. :P
02:17:40 <zxq9> tdammers: But our current deflationary pressure is the direct result of government actions taken in the interest of forcing (instead of permitting) a growth environment. I'm a fan of halds-off because corrections come faster. This one we're in now is in its *third decade* because of meddling and there's no end in sight.
02:19:01 <tdammers> I'm not going to go into a Free Market discussion right now
02:19:30 <tdammers> back to web security
02:20:02 <tdammers> you do realize that the HTTP protocol *does* in fact contain a whole bunch of access control features and such?
02:21:34 <pettter> 402 Payment Required
02:21:50 <pettter> and 401 Unauthorized
02:22:06 <pettter> for example
02:22:08 <tdammers> 418 I'm A Teapot
02:22:14 <pettter> :)
02:22:32 <tdammers> anyway
02:22:35 <saeidw> not to mention Authorization headers
02:22:40 <tdammers> IMO, the problem is not so much the protocol
02:23:10 <tdammers> the problem is people (and tools) using it wrong because they don't care enough about security
02:23:23 <pettter> that is generally the case
02:23:33 <tdammers> I think PHP and C should take much of the blame
02:23:50 <zxq9> Oh, I was unaware. I suppose there's no problem then. I hereby declare the web Secure. Order new lock icons for all websites! Documents really are program interfaces after all. What ever were those native-applications people thinking!
02:24:10 <tdammers> zxq9: I didn't say that
02:24:22 <tdammers> HTTP is not just about documents though
02:24:31 <pettter> zxq9: would you care to propose a "secure" replacement protocol?
02:24:56 <tdammers> consider a single-page javascript / ajax application
02:25:21 <tdammers> there is one document being served, which is empty save a little script tag to include the bootstrapping javascript
02:25:26 <zxq9> pettter: I'm working on developing a distributed application browser, actually. So indirectly, yes.
02:25:42 <tdammers> there you go, application browser.
02:25:54 <zxq9> pettter: A big part of the problem is the concept of letting a document browser drive what has essentially become a window manager environment.
02:26:06 <pettter> is that (distributed application) browser, or distributed (application browser)?
02:26:39 <`ramses> haha, english associativity
02:26:52 <zxq9> pettter: Both, but not at the same time. One of the central ideas is that you can "pitch" a program in execution to another device when desired.
02:27:02 <tdammers> except for the dummy document, all you ever exchange with the server is application code and raw data
02:28:11 <pettter> zxq9: User interaction required to actually run the code?
02:30:04 <zxq9> pettter: Yes, but the idea is to make it feel a lot like starting a native application instead of just looking at a webpage somewhere and having stuff go on in the background if you have $extension enabled/installed.
02:31:01 <pettter> zxq9: so I take it that you are optimistic about people generally (or at least a specific subset) being interested in things that behave like native applications
02:31:18 <zxq9> pettter: The browser itself is designed to be mini-instances of a window manager -- so far just been playing with a kdelibs base since its available nearly everywhere.
02:32:21 <pettter> do you have a webpage/whitepaper somewhere?
02:32:48 <zxq9> pettter: In the business world, yes. I'm not trying to reinvent Facebook like everyone else. The initial problems we faced with trying to deliver business applications over the web were security, good rendering times and handling analytics processing on largish datasets.
02:33:37 <pettter> Right, I can see those problems potentially being problematic
02:34:02 <zxq9> pettter: I haven't published anything, no. I've got a teeny tiny software company out here in Okinawa and we're working on this ourselves.
02:34:44 <zxq9> pettter: The ultimate goal is to bring a thing we're calling "island computing" into existence, instead of "cloud computing" which is marketing slang for "whatever I want it to mean just now".
02:35:21 * hackagebot PBKDF2 0.3.1.2 - Make password-based security schemes more secure.  http://hackage.haskell.org/package/PBKDF2-0.3.1.2 (ErikHesselink)
02:35:22 <pettter> nah, I'm not overly impressed with cloud computing, but it generally means "I don't care where it runs, but it's not here"
02:36:25 <statusfailed> zxq9: are you using Haskell?
02:36:45 <zxq9> pettter: We're trying to make physical posession of the data part of the security model, make the peer map (almost) match the actual user relation map, and diversify routes a more natural way.
02:37:10 <pettter> definitely an issue for some businesses
02:37:50 <zxq9> pettter: That's led us to have to develop an application browser, a search wrapper API, an anchor-island/profile concept, etc. Its just a really different model than the "its native or its web/cloud" paradigm.
02:38:54 <merijn> zxq9: So you're reinventing the X protocol for p2p systems? :)
02:39:08 <gspr> Does anybody know if there's been any serious attempts at reviving Qt bindings? Or even hooking Qt up with something like reactive-banana?
02:39:22 <zxq9> statusfailed: I'm finding that it drastically clarifies things in many cases (not all, but many). I'm also playing with Eiffel and of course C (Postgres extensions) and C++ (Qt) play a large role. But its really polyglot. Not sure if I can completely prevent language proliferation, honestly.
02:39:27 <pettter> and/or ActiveX :)
02:40:02 <zxq9> merijn: That's not so far from the truth, its just the way its being used instead. There are some gaps in X, but overall it was extremely forward looking.
02:40:19 <merijn> zxq9: I don't suppose you have money and looking to hire people with interest in distributed systems? ;)
02:41:14 <zxq9> merijn: I'm working on the money part. We're not anywhere close to being well financed -- but all new development is angled at this effort ultimately.
02:41:18 <liyang> zxq9: do you go to any of the Haskell meetups in Tokyo?
02:41:45 <zxq9> merijn: But an interest in hiring when money is available -- absolutely. Finding smart people who are genuinely interested in data problems is sort of hard.
02:41:57 <zxq9> liyang: I have not yet, but that's just for lack of time.
02:42:26 <zxq9> liyang: I hardly participate on IRC -- for the same reason! I'm way too busy these days.
02:42:28 <merijn> Although, Okinawa seems a bit far out of the way :p
02:42:51 <zxq9> merijn: It is -- but its a *completey* isolated SMB market, and that's where I'm swimming right now.
02:43:16 <liyang> zxq9: my excuse is that my conversational Japanese is rubbish, as is for probably a few people I work with. :-/
02:43:17 <zxq9> merijn: Nobody markets solutions to anybody here because its a backwater -- but its a backwater with enough construction companies with enormous data problems that it can finance my effort.
02:43:37 <zxq9> liyang: Haha
02:44:13 <zxq9> liyang: I've got a weird problem because I never went to school. I can converse very well, and I can talk about IT or military operations very well, but nothing in between. Huge gaps in my language ability in funny places.
02:44:25 <merijn> zxq9: I'm not questioning your company location, more the fact that even if you did have money, finding people might be hard
02:45:04 <zxq9> merijn: This is true. I thought that would not be the case, but I was overly optimistic about being able to locate people, especially in Japan.
02:45:27 <liyang> zxq9: Oleg came and gave an extended version of his APLAS talk last month, which was interesting. Actually I've no idea how into Haskell you are, so that may not mean anything.
02:45:40 <djcoin> Is there something close to ocaml functor in haskell ? I was thinking: is it possible to call a function returning a constructor with an opaque (and thus different) type ? The goal being to have some kind of dependent type. (I hope I named things corectly)
02:46:01 <djcoin> correctly *
02:46:56 <zxq9> liyang: I'm still a tadpole when it comes to Haskell. Most of that is a time issue as well. In particular, I have a hard time deciding where the appropriate places to break the IO barrier is in a program.
02:47:48 <zxq9> liyang: As in, "OK, I've got beautifu processes... but they exist in isolation. How/where best to actually have them interact with the rest of the world without winding up reinventing imperative programming?"
02:48:15 <liyang> djcoin: you might be able to use a existential with some class constraint…
02:48:45 <liyang> djcoin: but nothing directly corresponding to O'Caml functors.
02:49:01 <zxq9> And I assume that experience is what fixes this. I'd love to take a two month break from reality and just get deeply familiar with some of the newer concepts tickling my mind.
02:49:27 <zxq9> liyang: Is there a recording or notes versions of Oleg's talk somewhere?
02:50:37 <djcoin> liyang: thanks I will look into, I was just being curious
02:53:06 <liyang> zxq9: Probably not. https://twitter.com/kazu_yamamoto hosted the event. And while we're on Twitter you might be interested in these workshops too: https://twitter.com/start_haskell
02:53:33 <anborn> hi. I see that both the bytestring package and blaze-builder have a Builder for ByteStrings. Which one should I choose for best performances?
02:53:36 <zxq9> liyang: Thanks for the links. I'll check them out over the weekend.
02:53:58 <joaosal> Hi everyone
02:54:01 <swi> tdammers: from where do you get hashed password with sql injection ?
02:54:16 <liyang> zxq9: the next @start_haskell event is Sunday the 20th. :)
02:54:32 <tdammers> swi: uhm, the database?
02:55:07 <zxq9> liyang: How do the run? Are they IRL?
02:55:13 <swi> tdammers: and what will you do with those hash ?
02:55:20 <liyang> zxq9: IRL I'm afraid.
02:55:21 * hackagebot dynamic-object 0.2.0.1 - Object-oriented programming with duck typing and  singleton classes.  http://hackage.haskell.org/package/dynamic-object-0.2.0.1 (TakayukiMuranushi)
02:55:23 * hackagebot free-game 0.3.1.2 - Create graphical applications for free.  http://hackage.haskell.org/package/free-game-0.3.1.2 (FumiakiKinoshita)
02:55:37 <tdammers> generate collisions, then log in as the corresponding user
02:56:02 <tdammers> but if you can bypass the password check entirely with SQL injection, it's even easier
02:56:28 <epta> Are there some hlint analogues in java?
02:56:28 <zxq9> liyang: One of these days I'll be able to show up. For the meantime I'll be up to my ears in much more mundane business issues.
02:56:34 <epta> for java*
02:57:08 <liyang> zxq9: good luck. :)
02:57:18 <swi> tdammers: yep. so this is not a language/framework issue, but people's :)
02:57:25 <tdammers> both, really
02:57:52 <swi> tdammers: why the language?
02:58:15 <tdammers> for starters, because the available interfaces to your database differ
02:58:42 <tdammers> e.g., PHP's mysql_something() API doesn't give you parametrized queries, and so everyone just concatenated values into queries directly
02:59:10 <tdammers> and then typing discipline, expressivity, and abstraction tools
02:59:24 <bxc> whats . but the othey way round? i can't find a library definition for it?
02:59:29 <swi> tdammers: it' about stupid people again
02:59:52 <tdammers> my point is that writing secure web applications with, say, happstack, is much easier to get right than with PHP
02:59:54 <swi> stupid people think that some 'amazing magic' tool will help them not to think
03:00:03 <srhb> bxc: Probably isn't one aside from flip (.)
03:00:08 <srhb> :t (.)
03:00:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:00:25 <tdammers> well, there is nothing in PHP that prevents you from writing raw strings into the response
03:00:34 <tdammers> and it's really really easy to do it by accident
03:00:40 <srhb> @hoogle a -> (a -> b) -> b
03:00:41 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
03:00:41 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
03:00:41 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
03:00:48 <swi> tdammers: haskell have a more higher incoming level to study it :) php have a very low level -> that's the point
03:01:00 <tdammers> that's not all of it
03:01:16 <tdammers> even excellent programmers can easily make security-relevant mistakes in PHP
03:01:32 <swi> tdammers: how ?
03:01:50 <tdammers> lots and lots of opportunities
03:01:55 <bxc> srhb: thanks
03:02:00 <swi> i mean, yes, in php shoot your app's in the head easier :)
03:02:18 <liyang> swi: no, PHP just fools you into thinking you understand what's going on when you really don't, in terribly ways.
03:02:29 <swi> liyang: and this too
03:02:46 <swi> a vision of easiness
03:02:48 <tdammers> for example, PHP has no way of making it refuse any output that doesn't go through a template system of your choice
03:02:58 <tdammers> you cannot hide superglobals from any scope
03:03:10 <swi> tdammers: i never said that php is good lang :)
03:03:20 <tdammers> neither did I
03:03:40 <swi> tdammers: but good programmer will use good tool for specified task :)
03:03:46 <tdammers> I'm saying that these things make writing secure code much harder than it has to be
03:04:04 <tdammers> you don't always get to choose your tools
03:04:12 <swi> i.e. -- he will not use php for something bigger that simple 'Home page' :)
03:04:45 <tdammers> simple home pages grow into business-critical systems all the time
03:04:46 <bxc> well thats what the HP in PHP stands for
03:04:50 <swi> tdammers: sadly, but somtimes yes
03:04:57 <tdammers> bxc: not anymore
03:05:02 <swi> bxc: :)
03:05:08 <bxc> tdammers: yeah not any more
03:05:15 <tdammers> it's now "Hypertext Preprocessor"
03:05:20 <tdammers> both of which are lies
03:05:25 <bxc> now it stands for "business-critical system"
03:05:33 <tdammers> :D
03:05:47 * swi saw people writing cli programm on php
03:06:48 <kosmikus> \@@ifundefined
03:06:52 <kosmikus> Spockz: ^^
03:07:36 <bxc> i guess the drupal shell is written as commandline php?
03:08:28 * swi spew on drupal
03:09:15 <tdammers> I write CLI PHP all the time
03:09:31 <tdammers> I actually find it somewhat saner than web-server-php
03:10:00 <swi> tdammers: why you touch php anyway?
03:10:18 <bxc> swi: i really like drupal
03:10:25 <tdammers> swi: pays the bills
03:10:58 <bxc> i can see why #haskell would hate on it though
03:11:19 <swi> bxc: maybe drupal not so piece of shit.. i'm just supporting one site for my friend.. and there is joomla.. i hate it every single time
03:12:02 <bxc> never used joomla. i support some fairly high traffic sites in drupal and its ok - non-technical users can do most of the admin stuff on it, and it doesn't explode too much under load.
03:12:13 <tdammers> php itself is bearable; it's the surrounding culture that makes me sick
03:12:17 <bxc> heh
03:12:20 <swi> tdammers: may be search for another place where is no huge amount of 'managers who knows what you need to use for you job' ? :)
03:12:29 <tdammers> nah
03:12:45 <tdammers> there is this existing 10-year-old PHP codebase we're working on
03:12:51 <tdammers> rewriting is not an option
03:13:00 <swi> aaaah
03:13:06 <tdammers> for reasons even I have to agree on
03:13:08 <swi> that's the truth
03:13:38 <swi> old stone heritage..
03:13:45 <swi> i have one too on my work
03:14:00 <swi> called 'mysql 4' and '100500 html files'
03:14:02 <bxc> one of the "hello world as written by ..." docs had a funny web programmer example
03:14:06 <bxc> i cna't find it easily
03:15:07 <tdammers> no, but the real problem with PHP is a culture where ideas that are long common wisdom in other communities get shot down, ruthlessly
03:15:34 <tdammers> just look at the bug report about `finally` missing from PHP's exception syntax
03:15:54 <tdammers> it took the PHP team *10 years* to acknowledge that `finally` is actually a useful thing
03:16:23 <bxc> it reminds me of unprogrammers programming in the same way that a lot of programming in academia does.
03:16:58 <zxq9> gspr: About Qt -- I missed your questions earlier -- we couldn't find any decent Qt bindings ourselves. At the moment we've dropped back to writing application faces in C++ or PySide.
03:17:06 <Spockz> kosmikus: that gave me errors: ! You can't use `\spacefactor' in vertical mode.
03:18:04 <snowylike> bxc: do you mean non-cs academical programming or cs academical programming?
03:18:24 <bxc> any of the programming done by people with a research agenda rather than producing software.
03:18:28 <bxc> as the end goal.
03:18:30 <swi> zxq9: btw, why qt?
03:18:35 <bxc> in any dept
03:18:55 <snowylike> well, from my own experience there are still some interesting differences between, say, computational chemists and computer scientists
03:19:19 <zxq9> gspr: Which sucks -- depending on how things go, we might eventually have the organization bandwidth to pick up where HQK left off.
03:19:20 <bxc> which probably means the majority of people doing programming in the world who just want to get their job done.
03:20:50 <zxq9> swi: Because its nearly everywhere. The "browser" we're working on is really a cut-down window manager running in its own space (one space per app -- no mixing). KDE gives us a big headstart and its easy to make it work on mobile devices, any *nix, Windows, Mac, etc. which is really important for this project.
03:21:52 <zxq9> swi: Its also really easy to get access to the most common rendering tools without costing to much, and look and feel can be uniform across platforms instead of masquerading in the local flavor.
03:22:19 <hugosthlm> Illegal instruction(memory printout created). Anyone has a clue to where I can find the printout? http://tny.cz/6ed727e5
03:24:10 <zxq9> swi: Also, the whole Gnome world looks to be in pretty sketchy shape at the moment. I didn't want to invest people's time (or mine!) in digging deeper into it when they are going to "everything is a web page" and maybe ditching GTK in the future (depending of the temperament of the one guy on the planet whose full-time job it is to maintain it).
03:24:27 <tdammers> meh
03:24:46 <tdammers> didn't people try the everything-is-a-web-page thing a decade ago and decided it didn't work?
03:25:22 * hackagebot free-game 0.3.1.3 - Create graphical applications for free.  http://hackage.haskell.org/package/free-game-0.3.1.3 (FumiakiKinoshita)
03:25:36 <zxq9> yes. But people with deep pockets and pixelicious shareholder briefs are funding the current effort to have all things Fedora self-digest themselves out of existence. Sadly.
03:26:25 <zxq9> Its politics, not tech, really. And it reminds me a lot of what happened to Unix in the 80's. I ranted about this in a huge blog post a while back.
03:27:00 <zxq9> Anyway, that's why KDE, not Gnome. And as for why not wx, wx doesn't have a full-blown window manager I can leverage.
03:27:45 <zxq9> s/KDE/Qt; s/Gnome/GTK
03:28:06 <tdammers> zxq9: luckily, unlike UNIX in the 80's, those packages are all free software
03:28:15 <tdammers> so people can just fork them back to sanity
03:28:16 <zxq9> tdammers: Yes, the saving grace indeed!
03:28:36 <tdammers> or just ignore them and let them die a peaceful death
03:28:53 <tdammers> really, there is some interesting market force at work in free software
03:29:21 <zxq9> Which is where I think things will head over there. "Free" doesn't mean it doesn't take corporate backing to put polish on non-trivial projects.
03:29:35 <tdammers> 'course not
03:29:54 <tdammers> at least not for corporatey projects like a large desktop environment
03:30:09 <zxq9> But when the business effort results in project suicide, the fact the code can live on in a new form reaps unforseen benefits -- for everyone.
03:30:14 <srhb> Seems this has turned into #haskell-blah
03:30:22 <srhb> You know about #haskell-blah, right?
03:31:05 * bxc joins that
03:31:13 <zxq9> srhb: Good call.
03:31:23 <srhb> Thanks. :)
03:34:53 <swi> srhb: sorry :)
03:36:51 <srhb> swi: Don't be, it's easy to get caught up in it. :-) Just a friendly reminder.
03:40:03 <lpsmith> It's kinda scary how usable haskell-mode is for embedded SQL quasiquotes
03:40:20 <srhb> lpsmith: How so?
03:40:44 <lpsmith> srhb, coloration is pretty appropriate,  at least for the way I write sql
03:40:58 <lpsmith> Indentation is often (but not always) reasonable
03:41:30 <lpsmith> sometimes it even copies column names for me in ways that I actually like
03:42:31 <lpsmith> also,  sql comments are haskell comments
03:42:57 <lpsmith> though my quasiquoter mangles comments, unfortunately
03:43:01 <swi> lpsmith: emacs?
03:43:05 <lpsmith> swi, yeah
03:43:26 <swi> lpsmith: oh! can you post a screenshot of what it's looks like with sql ?
03:43:53 * swi loves haskell-mode for all those prety prints like -> \ etc 
03:44:08 <lpsmith> heh, I don't use thouse
03:44:21 <lpsmith> swi, maybe at some point, when I have something screenshot-able
03:45:27 <lpsmith> I should add support for comments though in my quasiquoter
03:45:43 <Dextr> hi
03:46:14 <hugosthlm> hoogle crashes with "illegal instruction", then apport crashes and the apport error handling crashes. Anyone has a clue to how or where I can find a stack trace ? http://tny.cz/6ed727e5
03:46:38 <lpsmith> Though,  what I really need is some level of understanding SQL syntax and some way to parameterize things in sql that aren't normally parameterizable
03:47:25 <lpsmith> Dextr, how are you?
03:47:35 <Dextr> i need to represent a permutation group (of fixed length) in a program, any idea on what type to use? is it possible to have numeric enumerations? like data P5 = 12345 | 23451 | etc. ?
03:48:15 <lpsmith> DexterLB, almost,  you could have P5 = P12345 | P23451, etc
03:48:20 <lpsmith> I wouldn't recommend that though
03:48:32 <lpsmith> err, sorry, Dextr
03:48:38 <hugosthlm> Hoogle server worked nicely on root in this machine, but was different compilation and running as root. "ghc-pkg check" is clean.
03:48:46 <Dextr> yes, not sure if P123.. qualifies for a solution :\
03:48:52 <Dextr> what should i  use instead?
03:49:04 <lpsmith> Dextr, I'd suggest an unpacked vector maybe
03:49:24 <Dextr> what is that?
03:49:46 <lpsmith> http://hackage.haskell.org/package/vector
03:49:57 <lpsmith> Just guessing that would be a reasonable way to go
03:50:03 <zzKon> is there an elegant way to add two pairs of list?  ([1], [3])  `something` ([2], [4]) => ([1,2], [3,4])
03:50:31 <Taneb> :t (++) *** (++)
03:50:33 <lambdabot> (Monoid b', Monoid b) => (b, b') -> (b -> b, b' -> b')
03:50:33 <lpsmith> In terms of efficiency and the size of the code, that is
03:51:04 <`ramses> :t liftA2 (++) fst snd
03:51:05 <Taneb> > let foo = (++) *** (++) in ([1],[3]) `foo` ([2],[4])
03:51:05 <lambdabot> Monoid c => (c, c) -> c
03:51:06 <lambdabot>   The operator `foo' takes two arguments,
03:51:06 <lambdabot>  but its type `(b0, b'0) -> (b0 -> ...
03:51:08 <Dextr> how does the usage of that look like?
03:51:16 <Taneb> Wait
03:51:30 <Taneb> > ([1],[3]) `mappend` ([2],[4])
03:51:31 <lambdabot>   ([1,2],[3,4])
03:51:58 <Taneb> zzKon: it's a monoid
03:51:59 <zzKon> oh nice
03:52:12 <zzKon> didn't know tuples are monoid
03:52:25 <`ramses> that's a useful instance I didn't know about :)
03:52:36 <Taneb> > ([1], First (Just 3)) `mappend` ([3,4], First (Just 7))
03:52:38 <lambdabot>   ([1,3,4],First {getFirst = Just 3})
03:52:47 <Taneb> You can even mix and match
03:52:56 <zzKon> sweet
03:52:57 <Taneb> I think up to either 7 or 9 tuples are monoids
03:53:06 <Taneb> And it's relatively easy to extend it further
03:53:10 <Taneb> But you probably shouldn't
03:53:45 <zzKon> can't remember last time I used 7+ element tuple
03:53:59 <zzKon> or 3+
03:54:13 <t7> > 3 seems like you need a data type
03:54:14 <lambdabot>   <hint>:1:25: parse error on input `data'
03:54:17 <basdirks> any Dutchy's going to NL-FP dag 2013 tomorrow?
03:54:18 <lpsmith> Dextr,  fromList [1,2,3,4,5].    Probably not as good as you'd like... but
03:54:44 <lpsmith> If you go the P12345 route, that's 120 elements and a 120*120 entries in your multiplication table
03:55:21 <Dextr> hm :x
03:55:32 <lpsmith> Dextr,  you could probably use template haskell and/or something like quasiquotes to cut down on the syntactic overhead though
03:55:33 <`ramses> Taneb: I only see instances up to 5-tuples here in ghci
03:55:47 <Dextr> no it has to be something simple - one xec
03:55:49 <Dextr> *sec
03:56:11 <Taneb> `ramses: I knew it was some odd number
03:56:33 <`ramses> should be enough for sane usage :)
03:57:02 <Dextr> http://ideone.com/WLjeSG <- this is what i have so far lpsmith, for Double and Klein's V Group .. i need something for P5 that will fit that same input-template
03:58:06 <lpsmith> Dextr,  you could write a program to generate such a module
03:58:30 <plhk> > putStrLn "текст"
03:58:30 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
03:58:36 <Dextr> yes, i could write a program to generate the type and table .. but i don't think that qualifies for a solution :x
03:58:39 <lpsmith> Though I would *highly* recommend using case statements instead of boolean guards in your multiplication table though
03:58:55 <plhk> ):
03:59:00 <lpsmith> GHC can do more with case statements
03:59:03 <Dextr> what's the difference lpsmith?
03:59:17 <Dextr> you mean in terms of optimization?
03:59:18 <lpsmith> and you don't have to keep repeating your variable names
03:59:24 <lpsmith> Dextr, right
03:59:41 <Dextr> can i have multi-variable cases?
03:59:58 <lpsmith> case (x,y) of
04:00:02 <Dextr> oh, ok
04:00:03 <`ramses> Dextr: just put them in tuples
04:00:28 <Dextr> but that still doesn't solve the P5 problem :\
04:00:47 <frerich> Hmm, wasn't there some ghci command to search all installed packages for some identifier? :info appears to scan just what's loaded.
04:01:18 <lpsmith> Dextr, if you are insistent upon the same basic approach, the thing to do would be to write a program to generate your datatype definition and multiplication table for you
04:02:00 <Dextr> so there's no other way, without having to change the i/o template?
04:02:19 <lpsmith> well,  syntactic style,  not i/o template
04:03:05 <lpsmith> Hmm, actually you could define an IsString instance for vector or whatever
04:03:05 <Dextr> lines 100 - 144 are the i/o template
04:04:28 <lpsmith> Dextr, ok if that's what you care about,  you have full control over the syntax.  I thought you were worried about Haskell literals
04:05:03 <lpsmith> You just have to write some bit of code that would translate some textual input into whatever haskell value you want it to represent
04:05:47 <lpsmith> although I think an IsString instance for your permutation type would be a relatively simple and cheap hack if you want nice haskell literals
04:06:07 <lpsmith> that way it'd be as simple as   P "12345" or  even just "12345"
04:08:06 <lpsmith> I was talking about your lines 171 - 207 "template"
04:08:46 <Dextr> 171 onwards is what i have written, so it wasn't a template ^^
04:09:32 <Dextr> hm.. wouldn't it be possible to just read in stings and use the individual characters as the numbers?
04:10:40 <hpaste> marekw2143 pasted “sequenceA” at http://hpaste.org/80533
04:10:53 <lpsmith> Dextr, yeah you could potentially use raw Haskell strings as the representation,  if you don't care about speed or dealing with large permutation groups
04:11:00 <lpsmith> Is this for class?
04:11:22 <marekw2143> hello, I've got a question: since following code: http://hpaste.org/80533 defines sequence which returns APplicative of list, why does sequenceA [(+3),(+2),(+1)] 3   is valid call?
04:12:07 <marekw2143> From my look, sequence A returns applicative, which  is list in our case, and list isn't function !
04:12:14 <marekw2143> *sequenceA
04:12:59 <mreh> :t sequenceA
04:13:00 <lambdabot>     Not in scope: `sequenceA'
04:13:00 <lambdabot>     Perhaps you meant one of these:
04:13:00 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
04:13:10 <mreh> :t Data.Traversable.sequenceA
04:13:12 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
04:13:35 <Peaker_> > sequenceA . sequenceA $ [[1,2,3],[4,5,6]]
04:13:36 <lambdabot>   Not in scope: `sequenceA'
04:13:36 <lambdabot>  Perhaps you meant one of these:
04:13:36 <lambdabot>    `Data.Travers...
04:13:45 <Peaker_> > Data.Traversable.sequenceA . Data.Traversable.sequenceA $ [[1,2,3],[4,5,6]]
04:13:47 <lambdabot>   [[1,1,1,2,2,2,3,3,3],[1,1,1,2,2,2,3,3,6],[1,1,1,2,2,2,3,5,3],[1,1,1,2,2,2,3...
04:13:50 <watermind> if newtype F x = F (Con x)    shouldn't  instance Blah F  be derivable for every instance Blah Con ?
04:13:59 <mreh> marekw2143, it's the function instance of Applicative
04:14:23 <mreh> watermind, with GeneralizedNewtypeDeriving turned on
04:14:34 <watermind> mreh: ah was using the wrong flag, thanks!
04:15:03 <marekw2143> mreh: isn't it just a list?
04:15:29 <mreh> marekw2143, look closely at the type of sequenceA and see what the type variables resolve to
04:16:43 <marekw2143> mreh: so we have as input Traversable (list in our case) of functors of some type, right?
04:17:46 <mreh> in this case sequenceA turns a list of functions of one argument into a function one argument that produces a list
04:18:03 <mreh> of one argument*
04:18:11 <mreh> so yeah
04:18:52 <aleator> I'd like to have a string representation of a type with kind other than *. Is there a generic solution for this?
04:19:22 <mreh> there is an applicative instance for (-> e), which is also called Reader but without a type wrapper
04:19:48 <merijn> mreh: Yeah, it's just (-> e), I think
04:20:05 <Dextr_> sry lpsmith, got disconnected :x
04:20:25 <Dextr_> yes, this is sort of homework, the i/o part was given, and the rest was to implement
04:20:25 <watermind> even then, this doesn't work newtype A a = A [a] deriving Monad
04:20:39 <merijn> :t (<*>)
04:20:41 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
04:20:47 <marekw2143> mreh: but in my example, "f" stands for function, right?
04:21:01 <marekw2143> mreh: i thought that "f" meant "Functor" there
04:21:39 <merijn> :t sequenceA
04:21:40 <lambdabot>     Not in scope: `sequenceA'
04:21:40 <lambdabot>     Perhaps you meant one of these:
04:21:40 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
04:22:20 <merijn> :t Data.Traversable.sequenceA [(+3)]
04:22:22 <lambdabot> Num a => a -> [a]
04:22:33 <merijn> > Data.Traversable.sequenceA [(+3)] 1
04:22:35 <lambdabot>   [4]
04:22:53 <merijn> > Data.Traversable.sequenceA [(+3),(+2),(+1)] 1
04:22:54 <lambdabot>   [4,3,2]
04:23:24 <marekw2143> hmm, but part of sequenceA definition is: sequenceA (x:xs) = (:) <$> x <*> sequenceA xs
04:23:57 <merijn> marekw2143: No, the f stands for Applicative (which is a superset of Functor)
04:23:59 <marekw2143> so when there is place for argument (like 1) in merijn's last example
04:24:09 <merijn> marekw2143: i.e. every Applicative is a Functor (but not vice versa)
04:24:43 <marekw2143> merijn: OT: then it's subset :)
04:25:01 <merijn> marekw2143: No, the operations exposed by Applicative are a superset of Functor, is what I meant
04:25:12 <marekw2143> merijn: ok, I see
04:25:16 <merijn> The *members* are a subset, yeah :)
04:26:04 <basdirks> any Dutchies going to NL-FP dag 2013 tomorrow?
04:26:12 <merijn> Wait, that's tomorrow?
04:26:16 <merijn> Where?
04:26:32 <basdirks> Nijmegen
04:27:03 <marekw2143> but back to the topic: sequenceA (x:xs) = (:) <$> x <*> sequenceA xs - it just returns fmapping whose type is list
04:27:09 <basdirks> http://wiki.clean.cs.ru.nl/NL-FP_dag_2013
04:27:13 <marekw2143> *fmapping over list
04:28:28 <merijn> marekw2143: The fmap it is using is the one for "(->) e"
04:28:54 <merijn> eh, rather, not the fmap, but the <*>
04:29:07 <merijn> :t Data.Traversable.sequenceA
04:29:08 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
04:29:34 <merijn> marekw2143: So the Traversable is [], right? So you get "[f a] -> f [a]"
04:29:40 <marekw2143> yep
04:29:53 <merijn> The f here is "(->) e"
04:30:00 <merijn> (Functions)
04:30:15 <merijn> So you get "[e -> a] -> e -> [a]"
04:30:36 <marekw2143> true
04:30:57 <marekw2143> but how do you know that "f here is (->) e" ?
04:31:07 <merijn> marekw2143: Well, look at the type
04:31:13 <merijn> :t [(+3)]
04:31:14 <lambdabot> Num a => [a -> a]
04:31:27 <marekw2143> :t (>5)
04:31:28 <lambdabot> (Num a, Ord a) => a -> Bool
04:32:04 <merijn> The contents of the "t" (list) are "a -> a", which happens to an Applicative, because "(->) e" is an Applicative
04:32:28 <lpsmith> Dextr_, that's ok.   I dunno about how this would fit into your I/O template,  or whether it's acceptable to modify it (it probably is unless there's an autograder),   but for simple interactive use like this you could just go with plain old strings
04:32:30 <merijn> :t Data.Traversable.sequenceA [(>5)]
04:32:31 <lambdabot> (Num a, Ord a) => a -> [Bool]
04:32:48 <marekw2143> but in code i've pasted type is different: http://hpaste.org/80533
04:32:57 <marekw2143> merijn: type there is: sequenceA :: (Applicative f) => [f a] -> f [a]
04:33:06 <Dextr_> how would i handle non-valid input with strings?
04:33:13 <marekw2143> merijn:  but, wait, [] is replaced by "t", right
04:33:25 <merijn> marekw2143: Yeah, your version is just slightly less general
04:33:35 <marekw2143> ok, so my "sequenceA" has type of "list of functions with one parameter a number'?
04:33:35 <merijn> marekw2143: i.e. only works on [] instead of any Traversable
04:34:07 <marekw2143> *a is of type "Num"
04:34:19 <merijn> marekw2143: Well, it has type "any applicative"
04:34:40 <zzKon> how would I get path to a file file that is in the same directory as executable?
04:34:46 <merijn> If you use [(+3)] then it'll be "functions with one parameter", yes
04:34:57 <merijn> marekw2143: But you can use other Applicatives
04:35:25 <merijn> marekw2143: For example
04:35:34 <merijn> :t Data.Traversable.sequenceA [Just]
04:35:35 <lambdabot> a -> [Maybe a]
04:36:04 <merijn> :t Data.Traversable.sequenceA [(+)]
04:36:05 <lambdabot> Num a => a -> [a -> a]
04:36:28 <marekw2143> :t Data.Traversable.sequenceA [(,,)]
04:36:29 <lambdabot> a -> [b -> c -> (a, b, c)]
04:37:08 <marekw2143> hmm, I don't understand how all expression is evaluated, e.g.: sequenceA [(+3)] 7
04:37:15 <marekw2143> it's lazy evaluated, right?
04:37:19 <merijn> marekw2143: Yes
04:37:26 <Taneb> > sequenceA [(+3), (+ 4)] 7
04:37:27 <lambdabot>   Not in scope: `sequenceA'
04:37:27 <lambdabot>  Perhaps you meant one of these:
04:37:27 <lambdabot>    `Data.Travers...
04:37:33 <Taneb> > sequence [(+3), (+ 4)] 7
04:37:34 <lambdabot>   [10,11]
04:37:46 <merijn> marekw2143: Let's take this example: "sequenceA [(+), (*), (/)"
04:38:26 <merijn> marekw2143: "sequenceA [(+), (*), (/)] 3" basically returns "each function in the list with 3 as it's first argument"
04:38:38 <merijn> marekw2143: The fact that the result is a list of functions is not a problem
04:39:17 <frerich> Hm, what is the 'fix' combinator useful for? The documentation says "fix f is the least fixed point of the function f, i.e. the least defined x such that f x = x." but to be honest that doesn't tell me anything. :-}
04:39:30 <merijn> > let seqA = Data.Traversable.sequenceA in seqA (seqA [(+), (*), (/)] 10) 2
04:39:32 <lambdabot>   [12.0,20.0,5.0]
04:39:43 <marekw2143> merijn: so in our definition of sequenceA: sequenceA (x:xs) = (:) <$> x <*> sequenceA xs  then "x" represents ann Applicative, right? ?
04:39:51 <merijn> marekw2143: Yes
04:40:52 <Athas> Is there a library/tool/program for parsing Haskell code properly, ie. also dealing with operator priority?
04:40:54 <merijn> marekw2143: You are fmapping (:) into the applicative, and then inserting the "sequenceA xs" into the applicative after it
04:40:56 <Athas> Does anything (apart from GHC) do this?
04:41:04 <Peaker_> Athas, haskell-src-exts?
04:41:04 <marekw2143> :t fmap
04:41:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:41:17 <marekw2143> :t fmap (+3) 1
04:41:19 <lambdabot> (Functor f, Num (f b), Num b) => f b
04:41:25 <Athas> Peaker_: it only handles single-module parsing, you still have to chase down fixity declarations from module imports yourself.
04:41:48 <merijn> marekw2143: That only works if 1 is a Functor (which it's normally not)
04:41:49 <Athas> This seems like a really bad problem if you want to do static analysis on Haskell.
04:41:59 <merijn> :t fmap (+3) []
04:42:00 <lambdabot> Num b => [b]
04:42:06 <merijn> :t fmap (+3) Nothing
04:42:07 <lambdabot> Num b => Maybe b
04:42:44 <merijn> :t fmap (+) (Just 1)
04:42:45 <lambdabot> Num a => Maybe (a -> a)
04:42:59 <merijn> marekw2143: You see how my last example has a function inside the Maybe, right?
04:43:31 <marekw2143> merijn: ritght
04:43:40 <merijn> Actually, let's make it even clearer and borrow a bit of code from sequenceA
04:43:48 <merijn> :t fmap (:) (Just 'a')
04:43:49 <lambdabot> Maybe ([Char] -> [Char])
04:44:29 <nathanel> frerich: you can use it make anonymous recursive functions, see http://en.wikipedia.org/wiki/Fixed-point_combinator
04:44:30 <marekw2143> wait wait, so ":" is applied on "a" and not on "Just"?
04:44:36 <merijn> marekw2143: Yes
04:45:02 <marekw2143> merijn: so how "(:)" can be applied on "one argument function" ?
04:45:02 <merijn> :t (:) <$> (Just 'a')
04:45:03 <lambdabot> Maybe ([Char] -> [Char])
04:45:30 <merijn> marekw2143: It's not, it's mapped "inside" the one argument function
04:45:36 <frerich> nathanel: hmm, interesting. I noticed that every time I think that I have a use case for 'fix', I actually want 'iterate'. :-}
04:45:40 <Dextr> would i still need a data type P5, if i go with strings, lpsmith?
04:45:55 <merijn> > succ 1
04:45:57 <lambdabot>   2
04:46:01 <merijn> > succ . succ $ 1
04:46:03 <lambdabot>   3
04:46:15 <merijn> :t succ <$> succ
04:46:16 <lambdabot> Enum b => b -> b
04:46:34 <merijn> marekw2143: fmap on functions is basically function composition
04:47:02 <merijn> :t (:) <$> succ
04:47:03 <lambdabot> Enum a => a -> [a] -> [a]
04:47:07 <merijn> :t (:) . succ
04:47:08 <lambdabot> Enum a => a -> [a] -> [a]
04:47:48 <marekw2143> merijn: ok, but as <$> is equivalent for fmap .... then:
04:47:58 <marekw2143> assume call to: sequenceA [(+3)] 7
04:48:03 <merijn> marekw2143: <$> is not equivalent to fmap, it *is* fmap
04:48:16 <marekw2143> merijn: thanks :)
04:48:38 <marekw2143> then  sequenceA evaluates for: (:) <$> (+3) <*> []
04:48:53 <merijn> marekw2143: You might want to study the implementation of <*> for functions
04:49:02 <merijn> marekw2143: That's where the magic happens
04:49:06 <marekw2143> then it evaluates for: fmap (:) ( (+3) <*> []) ritght?
04:49:37 <merijn> marekw2143: No, that becomes "(fmap (:) (+3)) <*> []"
04:51:46 <marekw2143> :t fmap (:) (+3)
04:51:47 <lambdabot> Num a => a -> [a] -> [a]
04:52:12 <merijn> :t (<*>)
04:52:13 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
04:52:54 <merijn> marekw2143: Here f = "a ->", a = "[a]" and b = "[a]"
04:53:44 <merijn> So "(fmap (:) (+3)) <*>" is "(a -> [a]) -> a -> [a]"
04:53:55 <merijn> :t ((fmap (:) (+3)) <*>)
04:53:56 <lambdabot> Num a => (a -> [a]) -> a -> [a]
04:54:24 <merijn> marekw2143: Guess what the result type of "sequenceA xs" is :)
04:55:25 <marekw2143> function of that many arguments as each element in xs needs?
04:56:17 <marekw2143> buy I just don't understand fmap here: fmap (:) (+3)
04:56:51 <merijn> :t fmap
04:56:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:56:54 <marekw2143> there (+3) is  an applicative, and that means that it can be "applicated" to elements contained somewhere (e.g. in maye)
04:57:11 <merijn> marekw2143: Yes, but all Applicatives are also Functor's
04:57:16 <mreh> how much scope is there for integrating an existing imperative API with an FRP lib?
04:57:18 <merijn> :t (:)
04:57:19 <lambdabot> a -> [a] -> [a]
04:57:29 <merijn> :t (+3)
04:57:30 <mreh> I know that reactive has ways of doing it easily, but it doesn't work yet :(
04:57:30 <lambdabot> Num a => a -> a
04:57:47 <mreh> it's such a shame nobody could fix reactive
04:58:30 <merijn> In the fmap signature: a = "a", b = "[a] -> [a]" and f = "Num a => a ->"
04:58:45 <merijn> :t fmap (:)
04:58:46 <lambdabot> Functor f => f a -> f ([a] -> [a])
04:58:55 <merijn> :t fmap (:) (+3)
04:58:56 <lambdabot> Num a => a -> [a] -> [a]
04:59:42 <merijn> marekw2143: Normally (:) takes an element and appends to the start of the list, "fmap (:) (+3)" takes an element, adds 3 to it and *then* hands it to (:) to append it to the start of a list.
05:02:24 <marekw2143> how can it get element to be applied  to  3
05:02:34 <marekw2143> since "fmap" is two arguemnt fucntion
05:02:46 <marekw2143> is it due to lazy nature of haskell?
05:03:34 <merijn> marekw2143: No, fmap may be a two argument function, but it can return another function
05:03:53 <merijn> marekw2143: id is a one argument function, but "id (+)" takes two arguments
05:03:54 <merijn> :t id
05:03:55 <lambdabot> a -> a
05:03:59 <merijn> :t id (+)
05:04:00 <lambdabot> Num a => a -> a -> a
05:05:14 <marekw2143> sorry, brb
05:13:27 <mSSM> Line 96 in https://github.com/aivuk/Simple-Ising/blob/master/ising.hs - when sdlUpIsing calls itself, is the mutable vector contained in `i' copied or is it still the same object?
05:15:40 <Dextr> are you still here lpsmith? what's the last line from me that got here?
05:15:51 <Dextr> (this connection now is hopefully more reliable)
05:21:55 <hugosthlm> I ran hoogle server in strace. Problem: Got killed by sigill. Illegal instruction. Instruction:  "<__kernel_vsyscall+16>: pop %ebp". You have to add some special permissions to run hoogle server on a normal user?  I have added "cap_net_raw,cap_net_admin=eip"
05:21:59 <Dextr> if i have a list someList (of type [a]) an index b and some a, how would i replace the element at position b in someList by a?
05:23:57 <mSSM> Dextr: use splitAt
05:25:28 <mSSM> Dextr: let (xs,_:ys) = splitAt i l ; in xs ++ x' : ys
05:25:30 * hackagebot MFlow 0.2.0.2 - Web app server for stateful processes with safe, composable user interfaces.  http://hackage.haskell.org/package/MFlow-0.2.0.2 (AlbertoCorona)
05:25:40 <Dextr> ok, that looks good - but i still need to remove the last element from the first part
05:25:49 <Dextr> ah, ok
05:25:56 <mSSM> Dextr: no :P
05:26:02 <mSSM> Dextr: you remove the head of the 2nd
05:26:15 <Dextr> what does ; do?
05:26:24 <mSSM> Dextr: read it as new line
05:26:33 <Dextr> ok
05:26:39 <frerich> It's not needed in that case either.
05:26:52 <mSSM> ^
05:27:20 <mSSM> Dextr: keep in mind that list concatenation is expensive
05:27:30 <Dextr> why did you use : the second time and not ++ ?
05:27:30 <frerich> mSSM: Can the second tuple element returned by splitAt ever be empty? If so, I guess the pattern matching _:ys could fail.
05:27:47 <zzKon> > 'a' : "bcd"
05:27:48 <lambdabot>   "abcd"
05:27:55 <zzKon> > "a" ++ "bcd"
05:27:56 <lambdabot>   "abcd"
05:28:03 <mSSM> frerich: yeah, you need to make sure that your index fits
05:28:31 <mSSM> frerich: i.e. it should go from 0 to n-1 if your list has n elements
05:28:56 <mSSM> frerich: or add a pattern match
05:29:16 <mSSM> Dextr: consider using a Map or a Vector
05:29:59 <Dextr> why?
05:30:37 <Dextr> why wouldn't an empty list be matched by ys?
05:31:05 <mSSM> Dextr: if your 2nd part is [], how can _:ys match that
05:31:06 <mSSM> ?
05:31:28 <mSSM> Dextr: _:ys needs to have a list of at least one element
05:31:35 <Dextr> ohh, ok
05:31:51 <zzKon> how come canonicalizePath  returns IO FilePath instead of FilePath?
05:32:02 <Dextr> couldn't i do xs:_,ys?
05:32:14 <mSSM> Dextr: you have the same problem
05:32:21 <mSSM> Dextr: what if xs is [] ?
05:32:29 <mSSM> Dextr: no
05:32:32 <frerich> Dextr: In 'xs:_', 'xs' would be a single element.
05:32:33 <mSSM> Dextr: what if the first part is []
05:32:45 <mSSM> frerich: not quite :)
05:32:48 <Dextr> no, because i just need to make sure the index is > 0, that easier than < n - 1
05:33:03 <mSSM> Dextr: you can't do that
05:33:17 <frerich> > let (xs:_) = [0..5] in xs
05:33:19 <lambdabot>   0
05:33:25 <mSSM> Dextr: think about what : does
05:33:37 <frerich> mSSM: Whatever is at the left-hand side of (:) is a single element :)
05:33:42 <frerich> No matter what it's called.
05:33:52 <mSSM> Dextr: xs:_ takes the first element of the first part and discards the rest of the list
05:33:56 <mSSM> Dextr: that's not replacing
05:34:10 <Dextr> right :\
05:34:42 <mSSM> But again, it's very expensive to replace elements in a list
05:34:49 <Dextr> ah, but there's last
05:34:50 <mSSM> Believe me, I have tried that :D
05:35:06 <Dextr> mSSM, yes, but this isn't production code .. ^^
05:35:59 <mSSM> Dextr: anyhow, it's not exactly hard to check that i fits the dimension of the list
05:35:59 <frerich> Dextr: A list is a (singly-)linked list. So to get to the n'th element you always have to start at the front. And to append something to a list you first have to walk all the way to the end.
05:36:26 <frerich> Dextr: So something like [1..100] ++ [1] is rather inefficient since you first have to walk to the end of the 100-element list, and then tack on the [1] list with a single element.
05:36:45 <Dextr> the list is of fixed size in this case - 5 elements
05:37:30 <frerich> Dextr: Yeah, it doesn't really matter much in that case. The only argument in favor of something like Vector or so is that they often come with API which makes something like "replace the n'th" element very easy.
05:37:37 <frerich> I.e. they are tailored for that kind of access.
05:38:01 <Dextr> is there a way to auto-convert a string (which is a list) into a vector?
05:38:22 <mSSM> frerich: or Map :)
05:38:30 <mSSM> Dextr: fromList
05:38:37 <mSSM> Dextr: check the vector documentation
05:38:42 <frerich> mSSM: Yes there are fromList (and toList) methods
05:39:05 <mSSM> frerich: anyhow, it's much more horrible to f*ck around with mutable data structures in haskell
05:39:31 <frerich> mSSM: Right; luckily the 'vector' package as mutable as well as immutable vectors. :-)
05:39:47 <hugosthlm> any groups you need to run hoogle server as a user in ubuntu?
05:39:48 <mSSM> frerich: yeah, but since you can't use mutable as a drop in replacement... ;)
05:46:18 <zzKon> why does canonicalizePath return IO FilePath? seems like replacing separators etc could be done in pure code
05:47:06 <ziman> perhaps it depends on the OS?
05:47:08 <merijn> zzKon: That probably needs to track down symlinks
05:47:13 <donri> because it also follows symlinks
05:47:15 <merijn> Which is clearly IO
05:47:46 <mm_freak>  @quote church and state
05:47:51 <mm_freak> @quote church and state
05:47:51 <lambdabot> No quotes for this person.
05:48:14 <donri> @quote church.and.state
05:48:14 <lambdabot> GuySteele says: Some people prefer not to commingle the functional, lambda-calculus part of a language with the parts that do side effects. It seems they believe in the separation of Church and
05:48:14 <lambdabot> state.
05:48:36 <Elench> Hehe
05:48:52 <Elench>  That's a great quote
05:49:21 <kennyd> > canonicalizePath "./foo.txt"
05:49:22 <lambdabot>   Not in scope: `canonicalizePath'
05:49:36 <merijn> kennyd: lambdabot doesn't do IO
05:49:36 <kennyd> it's expanded to full path
05:49:43 <kennyd> merijn yeah I forgot
05:50:09 <donri> ah yea so it also needs PWD?
05:54:41 <alpounet> @hoogle canonicalizePath
05:54:41 <lambdabot> System.Directory canonicalizePath :: FilePath -> IO FilePath
05:54:49 <alpounet> it seems so
06:04:22 <mSSM> During compilation, are errors written to somewhere? Unfortunately, cabal-dev install dumps everything to stdout, and I can't put that into an extra file (i.e. cabal-dev install > log)
06:04:27 <mSSM> it's still dumped to stdout
06:04:40 <beaky> hello
06:04:41 <tdammers> mSSM: are you sure that's not stderr?
06:04:45 <beaky> hello
06:04:59 <tdammers> i.e., try cabal-dev install |& tee log
06:05:11 <parcs> what does |& do
06:05:12 <donri> mSSM: 2>%1 > log, but see also ~/.cabal/logs
06:05:18 <YOLO> yolo
06:05:24 <mSSM> tdammers: yeah, you are right
06:05:30 <donri> 2>&1 that is
06:05:37 <pettter> parcs: redirect stderr instead of stdout
06:05:38 <tdammers> |& is shorthand for "pipe both stdout and stderr to the next argument"
06:05:44 <mm_freak> beaky: hi there
06:05:44 <mm_freak> beaky: hi there
06:05:52 <pettter> oh it's both? my bad
06:05:56 <tdammers> yep
06:06:01 <parcs> neat. is that a bashism
06:06:04 <tdammers> yeah
06:06:09 <tdammers> works in zsh too
06:06:10 <YOLO_> yooo
06:06:13 <tdammers> and maybe tcsh
06:06:14 <tdammers> not sure
06:06:20 <mSSM> donri: .cabal-dev/logs in my case does not contain compilation errors
06:06:21 <YOLO_> YOLO
06:06:34 <donri> mSSM: needs cabal 1.16 and -j i think
06:06:34 <YOLO__> hey guize
06:06:35 <mSSM> donri: only info about packages I use
06:06:44 <parcs> LOL look at this funny guy
06:06:53 <YOLO__> LOL look at this funny guy
06:07:00 <tdammers> you mean the one who is about to go on my ignore list?
06:07:01 <beaky> how do I implement sum types using closures?
06:07:05 <YOLO_> you mean the one who is about to go on my ignore list?
06:07:10 <YOLO__> you mean the one who is about to go on my ignore list?
06:07:17 <tdammers> heh
06:07:18 <tdammers> no need
06:07:31 <tdammers> <3 freenode
06:07:53 <mm_freak> apparently it's also a zshism
06:07:53 <mm_freak> great
06:08:11 <tdammers> 15:05 < tdammers> works in zsh too
06:08:20 <tdammers> ;)
06:08:27 <mm_freak> yeah, sorry…  i started just trying it out right away =)
06:08:37 <tdammers> no hard feelings
06:09:05 <kamatsu> beaky: a catamorphism
06:09:17 <mm_freak> beaky: myEither :: (a -> c) -> (b -> c) -> c
06:09:38 <mm_freak> beaky: you implement the corresponding fold, i.e. what kamatsu said =)
06:10:05 <mm_freak> boolFold :: a -> a -> Bool -> a
06:10:09 <mm_freak> myBool :: a -> a -> a
06:10:31 * hackagebot yesod-auth-deskcom 1.0 - Desk.com remote authentication support for Yesod apps.  http://hackage.haskell.org/package/yesod-auth-deskcom-1.0 (FelipeLessa)
06:10:31 <mm_freak> maybeFold :: b -> (a -> b) -> Maybe a -> b
06:10:33 * hackagebot http-conduit 1.8.6.3 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.6.3 (MichaelSnoyman)
06:10:41 <mm_freak> myMaybe :: b -> (a -> b) -> b
06:11:01 <beaky> hello
06:11:13 <mm_freak> beaky: you implement the corresponding fold, i.e. what kamatsu said =)
06:11:23 <beaky> ah thanks
06:11:37 <beaky> hmm let me try to implement a simple linked list with only closures
06:11:50 <mm_freak> beaky: the fold for Either is 'either', and a church-encoded Either value is basically just the fold without the actual argument
06:12:06 <mm_freak> either :: (a -> c) -> (b -> c) -> Either a b -> c
06:12:14 <mm_freak> myEither :: (a -> c) -> (b -> c) -> c
06:12:26 <beaky> wow
06:13:14 <mm_freak> beaky: similarly for Bools the fold is just the 'if' function
06:13:25 <beaky> what is a fold?
06:13:27 <mm_freak> so a boolean is the 'if' function without taking a predicate
06:17:05 <kamatsu> :t foldl
06:17:06 <lambdabot> (a -> b -> a) -> a -> [b] -> a
06:17:13 <beaky> ah
06:17:19 <beaky> a fold is just a reverse ctor
06:17:25 <kamatsu> yes, a destructor
06:17:26 <lpsmith> Dextr:  not necessarily
06:17:32 <marekw2143> what is "r" in:     instance Functor ((->) r) where     fmap = (.)
06:17:52 <kamatsu> marekw2143: (r ->) is the reader monad
06:18:13 <marekw2143> kamatsu: but in the definition : "instance ... " has the "r" any meaning?
06:18:21 <marekw2143> could it be simply "q" or somethign else?
06:18:26 <kamatsu> marekw2143: it's a type variable, so yeah
06:18:47 <marekw2143> kamatsu: but what that type variable defines in "->"  ?
06:18:53 <marekw2143> since "->" is a function, right?
06:18:58 <kamatsu> -> is a function type, yeah
06:19:08 <kamatsu> view ((->) r) as (r ->), because that's what it is
06:19:22 <Dextr> what does "Cannot use type synonym in instance head" mean?
06:19:39 <kamatsu> Dextr: It means you are trying to instantiate a class on a type synonym
06:19:40 <Dextr> (the offending line is instance Group String where )
06:19:48 <marekw2143> kamatsu: so in type declaration, "->" denotes function
06:19:48 <Dextr> string is a synonym?
06:20:01 <marekw2143> so in that context "r" is type of first argument, right?
06:20:02 <kamatsu> marekw2143: yes, so for that functor instance, the type becomes:
06:20:18 <kamatsu> fmap :: (a -> b) -> (r -> a) -> (r -> b)
06:20:56 <kamatsu> so f ~ (r ->)
06:22:09 <Dextr> if Sting is a type synonym, what is the actual type named?
06:22:15 <kamatsu> Dextr: [Char]
06:22:17 <tdammers> [Char]
06:22:26 <kamatsu> String's are bad, though, for any serious string work.
06:22:28 <Dextr> ah, right
06:22:36 <tdammers> kamatsu: not necessarily
06:22:43 <tdammers> depends what you do to them
06:22:53 <tdammers> if it's mostly iterating and taking tails, they're quite efficient
06:22:55 <Dextr> well i need something that maps automatically to strings
06:22:57 <elliott> Strings are good if you produce and process them in a streamy kind of manner.
06:23:53 <kamatsu> lazy text and bytestring are better though
06:24:00 <tdammers> but if it's more like the typical text manipulation stuff - replace substrings, swap things around, glue hundreds of them together, etc., then yeah, Text is better
06:24:08 <Dextr> putting [Char] on the instance head leads to a syntax error
06:24:29 <kamatsu> you can't have instances that specific without FlexibleInstances
06:24:34 <kamatsu> what are you trying to do?
06:24:35 <Dextr> so if i can't use String or [Char], what is the proper way to do this?
06:24:48 <mm_freak> beaky: intuitively a fold is a complete destruction with identity
06:24:55 <mm_freak> beaky: foldl is not a fold
06:24:59 <mm_freak> but foldr is
06:25:00 <beaky> ah
06:25:06 <kamatsu> yes, sorry, i should've used foldr, beaky
06:25:14 <mSSM> In a do statement, I can do the following: `do { check <- foo; let a { | check = somePureFunction | otherwise = someDefault } ; return a }'. -- Now, what if somePureFunction is monadic now? Is it possible to bind something to ` a <- ... ' in the same way with guards?
06:25:17 <kamatsu> (been writing too much ML)
06:25:19 <mm_freak> foldr [] (:) = id
06:25:28 <mm_freak> maybe Nothing Just = id
06:25:33 <mm_freak> either Left Right = id
06:25:40 <mm_freak> if' True False = id
06:25:41 <mm_freak> etc.
06:26:21 <Dextr> kamatsu: http://ideone.com/FC7giE the instance i want to create is on line 216
06:26:29 <mm_freak> now imagine you apply the argument already…  then you can turn this into the original data structure, so a fold applied to the data structure is equivalent to the data structure itself
06:27:23 <mm_freak> myMaybeInt :: a -> (Int -> a) -> a
06:27:31 <mm_freak> imagine that's should represent a Just 3
06:27:40 <mm_freak> myMaybeInt n j = j 3
06:27:53 <mm_freak> and you can turn this into Just 3 easily:  myMaybeInt Nothing Just
06:28:21 <mm_freak> there is also the other way around:  myMaybeInt n j = maybe n j (Just 3)
06:28:29 <Dextr> can i put List as type in the instance?
06:28:41 <hpaste> j4hr0m pasted “exception” at http://hpaste.org/80537
06:28:49 <mm_freak> beaky: and that's called church encoding
06:28:52 <j4hr0m> hi guys, is this a bug?
06:29:16 <kamatsu> Dextr: You should probably not use Char for this
06:29:34 <marekw2143> :t fmap
06:29:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:29:44 <Dextr> what do you suggest kamatsu?
06:29:51 <marekw2143> :t fmap (\x -> x)
06:29:52 <lambdabot> Functor f => f b -> f b
06:30:10 <mm_freak> j4hr0m: huh?  i didn't even know that syntax was allowed, but yes, loading shouldn't throw an exception, so you better report that
06:30:31 * hackagebot yesod-auth-deskcom 1.1 - Desk.com remote authentication support for Yesod apps.  http://hackage.haskell.org/package/yesod-auth-deskcom-1.1 (FelipeLessa)
06:30:41 <j4hr0m> mm_freak: where can i report that?
06:30:41 <kamatsu> Dextr: Well, i'm not sure what you're trying to do, but Char isn't a good representation for a type of 5 elements.
06:31:05 <mm_freak> j4hr0m: http://hackage.haskell.org/trac/ghc/wiki/ReportABug
06:31:05 <kamatsu> also, perm :: [a] [a] -> [a] is a syntax error
06:31:06 <Dextr> well, it's not just 5, it's 120
06:31:27 <Dextr> yes, ok - the code is obviously not finished
06:31:51 <kamatsu> i'm just trying to figure out what you're trying to do here
06:32:01 <Dextr> i thought of doing it as a enum first, but that obviously not practical
06:32:12 <Dextr> it's supposed to be a permutation group
06:32:20 <j4hr0m> mm_freak: ok, thanks
06:34:05 <kamatsu> ok, so you should probably represent a permutation as a list [FiveThings] where data FiveThings = C1 | C2 | C3 | C4 |C5
06:35:14 <kamatsu> then you'll have to enable {-# LANGUAGE FlexibleInstances #-} to make the [FiveThings] valid
06:35:17 <Dextr> is it 5 things?
06:35:24 <Dextr> ah, ok
06:35:31 <Dextr> but that still leads to the same problem
06:35:36 <kamatsu> what problem?
06:35:39 <Dextr> because i'm having a list in the instance head
06:35:45 <kamatsu> flexibleinstances fixes that
06:35:52 <kamatsu> GHC should've suggested it
06:36:02 <Dextr> i'm using hugs
06:36:08 <kamatsu> why?
06:36:11 <Dextr> what is flexibleinstances?
06:36:23 <kamatsu> it's a language extension
06:36:30 <Dextr> hugs was recomended for usage for the exercise :x
06:36:33 <kamatsu> not part of the language spec, but commonly implemented in Haskell implementations
06:36:56 <kamatsu> ah, in that case you'll have to use a newtype
06:37:00 <kamatsu> go
06:37:09 <Dextr> hm?
06:37:12 <kamatsu> newtype PermGroup = PG [FiveThings]
06:37:22 <kamatsu> and then instance Group PermGroup
06:37:32 <Dextr> oh, ok
06:37:35 <Dextr> what does that do?
06:37:46 <kamatsu> newtypes introduce a newtype
06:37:47 <Dextr> that is, why does it work in constrast du just using string?
06:37:49 <kamatsu> er
06:37:53 <kamatsu> new type
06:38:16 <kamatsu> which have a constructor, that takes one argument
06:38:25 <kamatsu> the type [FiveThings]
06:38:39 <kamatsu> like a data declaration, except there's only one alternative.
06:39:03 <kamatsu> It's a fairly old restriction in Haskell: You can't' instantiate a typeclass on [Char], only on [a] or [b].
06:39:26 <Dextr> i see
06:39:49 <Dextr> so writing [a] in the instance would work fine?
06:39:49 <`nand`> I switched to [PeanoNat] instead of Symbol for type-level strings and now type checking is super slow and errors fill several pages :(
06:40:03 <kamatsu> `nand`: Why not use symbol?
06:40:09 <`nand`> is there a more efficient Nat somewhere, barring the TypeNat branch of GHC head?
06:40:14 <`nand`> kamatsu: can't compare them
06:40:26 <kamatsu> Dextr: If you use [a], then the typeclass is more general
06:40:41 <kamatsu> Dextr: It becomes an instance for any group, your identity element wouldn't be an identity for all groups.
06:40:47 <Dextr> yes, but that will eventually get straightened out by the read part
06:40:51 <kamatsu> *all permutation groups
06:40:55 <yogsototh> Hi all. Is there somewhere an example to help me not to read an understand the complete repa/repa-devil documentation to pass from ((x,y),color) -> writing a jpg on my hard disk? My google fu is weak.
06:40:59 <Dextr> yes, that's true
06:41:17 <Dextr> but if i use a more complex type, i'm unsure about how to do the user-interface part
06:41:17 <kamatsu> one option is to use Enum
06:41:28 <Dextr> enum is not practical for this size
06:41:43 <kamatsu> sure it is
06:41:47 <kamatsu> you've only got 5 elements in the set
06:42:06 <marekw2143> in command: fmap (+) (Just 3) <*>  Just 4
06:42:14 <marekw2143> there applicative is (+) or Maybe ?
06:42:30 <kamatsu> Dextr: Just go instance Enum a => Group [a]
06:42:30 <`nand`> you can instantiate a typeclass on [Char] with FlexibleInstances, if that's really what you need
06:42:38 <`nand`> just mentioning it
06:42:44 <Dextr> hm... but if i do it like that, it's not compatible with the user interface part
06:42:54 <`nand`> but a more general instance would be greatly preferred
06:43:26 <kamatsu> `nand`:  yeah, I pointed that out before, but he's using hugs for a school exercise
06:43:30 <kamatsu> you have three otions
06:43:33 <kamatsu> *options
06:43:38 <`nand`> oh, hugs
06:43:56 <`nand`> there's also the trick Show/Read use to special-case String in haskell98
06:44:05 <kamatsu> a general interface using Bounded and Enum,  a specific interface using a newtype, or a specific interface using a language extension.
06:44:24 <kamatsu> `nand`: I doubt he can change his class that substantially.
06:44:30 <`nand`> some would frown upon the use of Bounded and Enum :)
06:44:45 <Dextr> how would i read in stuff when using  [FiveThings] with data FiveThings = C1 | C2 | C3 | C4 |C5 ?
06:44:48 <`nand`> if this is in the context of a school exercise, I hope it would make sense
06:45:01 <zl64c> Hey, matrix operations in haskell are easy?
06:45:04 <`nand`> without requiring hacks, that is
06:45:16 <`nand`> zl64c: there are matrix libraries around
06:45:19 <`nand`> that make them quite easy
06:45:41 <zl64c> thanks
06:46:07 <kamatsu> Dextr: well, which representation have you decided on?
06:46:32 <Dextr> your suggestion looks good, but as i said, how would i do the i/o?
06:47:13 <kamatsu> do you have any constraints on how your UI is supposed to behave?
06:47:33 <Dextr> not sure, but i guess the idea is to not fiddle too much with it
06:47:36 <kamatsu> i mean you can just slap on "deriving (Read, Show, Bounded, Enum)" and you'll get basic read and show functions.
06:47:49 <kamatsu> (you'll need bounded and enum too to write a general typeclass)
06:47:56 <Dextr> how would i type in the values if i do that?
06:48:49 <kamatsu> uh, do you understand the UI code that's already written?
06:49:29 <Dextr> well somewhat - i wrote the parts with --TODO next to them ^^
06:50:23 <kamatsu> so, note the definition of Group
06:50:25 <kamatsu> class (http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq a, http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show a, http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read a) => Group a where
06:50:29 <kamatsu> ergh, Adium!
06:50:32 <kamatsu> sorry all
06:50:50 <kamatsu> class (Eq a, Show a, Read a) => Group a where
06:51:14 <kamatsu> that means all instances of Group must have instances of Eq, Show and Read
06:51:21 <Dextr> yes
06:51:33 <kamatsu> Show gives you a function, that looks like this:
06:51:34 <kamatsu> :t show
06:51:35 <lambdabot> Show a => a -> String
06:51:41 <kamatsu> Read gives you the inverse:
06:51:42 <kamatsu> :t read
06:51:43 <lambdabot> Read a => String -> a
06:51:53 <Dextr> i've implemented the show part, but red was always provided automatically so far
06:52:06 <Dextr> *read
06:52:28 <merijn> Dextr: You can automatically derive a bunch of stuff
06:52:49 <merijn> Dextr: In your FiveThings example it should just work to add "deriving (Show,Read,Eq)" after
06:53:05 <merijn> i.e. "data FiveThings = C1 | C2 | C3 | C4 |C5 deriving (Show,Read,Eq)"
06:53:09 <Dextr> ok, but how would i enter the value then?
06:53:15 <kamatsu> however you'd have to write [C1, C2, C3] or somesuch
06:53:21 <kamatsu> [C1, C2, C3, C4, C5]
06:53:36 <Dextr> oh, ok
06:53:40 <kamatsu> if you want to read in strings like "12345" you'd have to write your own Read function.
06:53:42 <Dextr> didn't expect that to work
06:53:46 <merijn> Dextr: read "[C1, C2, C3]" should work
06:53:57 <Dextr> ok, that solves it then i guess
06:54:08 <merijn> (or better, use Text.Read.readMaybe if you have a recent version of GHC!)
06:54:18 <Dextr> why would i need to derive bounded and enum?
06:54:33 <merijn> Dextr: Well, you don't *need* to, but it can't hurt
06:54:34 <kamatsu> (merijn: he has hugs, his teacher appears to use bad haskell practices too)
06:55:12 <Dextr> what would enum and bounded do?
06:55:25 <kamatsu> Dextr: Bounded and enum let you make a typeclass for general permutation groups of any enumerable, bounded type
06:55:51 <kamatsu> Dextr: Seeing as you just need a typeclass for permutation groups of FiveThings, you can narrow things down by using a newtype instead.
06:56:03 <prots> hey guys i need your help. im trying to make a function which turns a value into a list and do this .... for example if i use f 3 i want to do this [[3],[2],[1]]
06:56:03 <kamatsu> or go with the general implementation
06:56:28 <Nisstyre> Is it accurate to think of Enum instances as types that have a cardinality?
06:56:30 <kamatsu> If you use EnumBounded, it lets you go [minBound..maxBound] for the identity element.
06:56:39 <osfameron> prots: what have you tried so far?
06:56:43 <Dextr> oh, ok
06:56:56 <kamatsu> prots: That's weird, but you could just go:
06:57:38 <osfameron> prots: use hpaste.org in chan
06:58:06 <kamatsu> :t let f n = map (:[]) . reverse . [0..n]
06:58:08 <lambdabot> <no location info>:
06:58:08 <lambdabot>     not an expression: `let f n = map (:[]) . reverse . [0..n]'
06:58:10 <kamatsu> oops
06:58:16 <kamatsu> well yeah, you get the idea
06:58:25 <kamatsu> but it seems like a very odd function to want to write
06:58:49 <Nisstyre> > (\x -> map (:[]) [1..x]) 1
06:58:50 <lambdabot>   [[1]]
06:58:53 <kamatsu> yeah, that's it
06:58:54 <Dextr> so newtype would let me narrow down the types for the group to just [FiveThings] instead of [a]?
06:58:57 <Nisstyre> > (\x -> map (:[]) [1..x]) 10
06:58:57 <kamatsu> been a long day
06:58:58 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
06:59:14 <kamatsu> Dextr: Yeah, but you'd have to unwrap and rewrap the list in a newtype
06:59:44 <kamatsu> so
06:59:46 <osfameron> (:[]) is a bit confusing for a beginner, no?
06:59:51 <Nisstyre> osfameron: I guess
06:59:54 <kamatsu> ofsameron: is return better?
06:59:59 <osfameron> (\a -> [a]) ?
07:00:12 <kamatsu> lambdas, eq
07:00:14 <Dextr> what would the wrapping look like?
07:00:14 <kamatsu> *ew
07:00:19 <Nisstyre> osfameron: that might be clearer yeah
07:00:31 <kamatsu> Dextr: so, newtypes introduce a constructor, just like data decls
07:00:43 <kamatsu> Dextr: newtype PermGroup = PG [FiveThings]
07:00:52 <kamatsu> PG :: [FiveThings] -> PermGroup
07:00:57 <kamatsu> and you can go the other way via pattern matching
07:00:59 <osfameron> prots: so:
07:01:06 <hpaste> prots pasted “list” at http://hpaste.org/80538
07:01:07 <osfameron> > map (\a -> [a]) [1..3]
07:01:09 <lambdabot>   [[1],[2],[3]]
07:01:11 <Dextr> oh, ok
07:01:20 <Nisstyre> > liftM (:[]) [1..10]
07:01:21 <osfameron> > map (\a -> [a]) $ reverse [1..3]
07:01:21 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
07:01:22 <lambdabot>   can't find file: L.hs
07:01:43 <osfameron> L.hs?
07:01:52 <kamatsu> what happened?
07:02:26 <prots> hpaste u see the code
07:02:32 <Nisstyre> @pl (\x -> liftM (:[]) $ reverse [1..x])
07:02:32 <lambdabot> fmap return . reverse . enumFromTo 1
07:02:41 <Dextr> thanks kamatsu
07:02:57 <prots> @hpaste u see the code
07:02:57 <lambdabot> Haskell pastebin: http://hpaste.org/
07:03:04 <kamatsu> yeah, I tend to use return :: a -> [a]
07:03:28 <kamatsu> prots: fmap return . reverse . enumFromTo 1 is what i would use
07:03:32 <kamatsu> but i love pointfree too much
07:03:41 <kamatsu> or rather map return...
07:03:55 <elliott> pure > return
07:04:03 <kamatsu> why do you want a bunch of singleton lists though?
07:04:07 <prots> @osfameron u see the code ?
07:04:07 <lambdabot> Unknown command, try @list
07:04:27 <osfameron> prots: yes.  do you see the discussion above?  several people have posted suggestions for you
07:04:36 <kamatsu> elliott: yeah, but return is what i reflexively reach for
07:04:48 <kamatsu> elliot: should probably break that habit
07:05:32 * hackagebot histogram-fill 0.7.4.0 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.7.4.0 (AlexeyKhudyakov)
07:05:37 <osfameron> > let x = 3 in reverse [1..x]
07:05:38 <lambdabot>   [3,2,1]
07:06:04 <osfameron> prots: that's how you can get [3,2,1] from the parameter you passed in
07:06:16 <Nisstyre> > let singletons = fmap return . reverse . enumFromTo 1 in singletons 3
07:06:17 <lambdabot>   No instance for (GHC.Show.Show (m0 a0))
07:06:18 <lambdabot>    arising from a use of `M62075174...
07:06:23 <Nisstyre> bah
07:06:35 <osfameron> > map (\a -> [a]) [3,2,1]
07:06:37 <lambdabot>   [[3],[2],[1]]
07:06:55 <osfameron> prots: ^^ and that's *one* way of turning 3 into [3] and so on
07:07:04 <osfameron> prots: if you look at the discussion you'll see there are plenty of others
07:07:44 <\rs> > map return [3,2,1]
07:07:46 <lambdabot>   No instance for (GHC.Show.Show (m0 a0))
07:07:46 <lambdabot>    arising from a use of `M65611167...
07:08:24 <osfameron> return will work in his case, as he has a type
07:08:51 <prots> ty guys but how can i do this with only the - operator and without predefined functions/operator only with -
07:09:31 <osfameron> prots: huh?
07:09:48 <osfameron> prots: this is homework obviously.  What is the prof getting at?
07:09:56 <osfameron> oh, is it recursion?
07:10:06 <prots> i think a recursion
07:10:15 <osfameron> prots: so, how much do you know about recusion?
07:10:35 <prots> a little bit ^^
07:10:50 <osfameron> @where lyah
07:10:50 <lambdabot> http://www.learnyouahaskell.com/
07:11:08 <osfameron> prots: ^^ you might want to work through that tutorial
07:11:09 <Nisstyre> prots: do you know pattern matching?
07:11:33 <Nisstyre> also, do you know what : does?
07:11:47 <prots> i think yeas
07:12:03 <Nisstyre> prots: okay, so, do you know how you would construct a list recursively?
07:12:11 <Nisstyre> construct :P
07:12:51 <prots> @n´Nisstyre nope
07:12:52 <lambdabot> Unknown command, try @list
07:13:19 <watermind> @source Data.List.unfoldr
07:13:19 <lambdabot> Data.List.unfoldr not available
07:13:20 <prots> i have no idea
07:13:26 <watermind> @source unfoldr
07:13:27 <lambdabot> unfoldr not available
07:13:50 <watermind> why not? :/
07:14:01 <`^_^v> @source upon
07:14:01 <lambdabot> upon not available
07:14:32 <Peaker> I have "foo x y = ..." in a "where" clause, and it only works if I add a type signature, as if the MR kicks in, despite it having explicit args?
07:14:47 <Nisstyre> prots: I'll give you a hint. Part of your function should look like "range 0 = []" (assuming you want it to be a list of n to 0)
07:15:04 <Nisstyre> er, "range 0 = [0]"
07:15:15 <prots> yes
07:16:02 <prots> range :: Int -> [Int]
07:16:09 <Nisstyre> prots: now think about the general case of that
07:16:13 <Nisstyre> what's going on with any n?
07:16:18 <Nisstyre> oops, wrong person
07:16:29 <Nisstyre> oh nevermind, sorry, tired
07:17:10 <Nisstyre> prots: you see what I'm getting at?
07:17:45 <prots> i cant imagine this ^^
07:17:54 <Nisstyre> the key thing to understand about this kind of recursion is that the general case should look tautological
07:18:05 <Nisstyre> that is, it should be circular logic, until the base case happens
07:18:06 <hpaste> prots pasted “list” at http://hpaste.org/80539
07:18:35 <Nisstyre> prots: that's easy, just use map to apply the singleton function to each element
07:18:48 <frerich> prots: Another hint: if 'range 0 = [0]', then you could have 'range 1 = [1,0]' which you can also write as 'range 1 = 1 : [0]'
07:18:49 <Nisstyre> but I'm guessing you're supposed to implement it without map
07:19:07 <prots> is map a predefined function ?
07:19:10 <Nisstyre> yes
07:19:19 <Nisstyre> it's in Prelude
07:19:49 <prots> the problem use im trying use only the predefined operator - and nothing more
07:19:51 <prots> ^^
07:20:04 <Nisstyre> prots: that's possible using the method I am trying to explain
07:20:10 <Peaker> when are "where"s monomorphized by ghc?
07:20:17 <Nisstyre> well, as well as the syntax of GHC
07:20:35 <Nisstyre> s/GHC/Haskell/
07:20:42 <Guest00000> prots: well you can use subtract in case - syntax is messing you up
07:20:55 <Guest00000> > 9 `subtract` 1
07:20:56 <lambdabot>   -8
07:20:59 <Guest00000> oops
07:21:18 <prots> ^^
07:21:40 <spacekitteh> is yampa still like, the main FRP framework? or has it been superceded?
07:21:40 <Guest00000> > subtract 1 9
07:21:41 <Nisstyre> prots: if you were to write it all as one function, then "singletons 0 = [[0]]"
07:21:42 <lambdabot>   8
07:21:50 <elliott> spacekitteh: I don't think many people use yampa any more
07:21:54 <elliott> take a look at reactive-banana and netwire
07:22:00 <elliott> netwire's closer to yampa I guess
07:22:13 <osfameron> actually, from his example, singletons 0 = []   no?
07:22:31 <Nisstyre> osfameron: depends if he wants to include 0 I guess
07:22:46 <Nisstyre> though that is nicer looking :P
07:22:46 <osfameron> well, I'm only going by his paste, which didn't
07:22:52 <Nisstyre> fair enough
07:23:00 <spacekitteh> elliott: ah, thanks
07:23:07 <prots> @nisstyre yep , but i want to change the function to get at the and the result singeltons 3 = [[3],[2],[1]]
07:23:07 <lambdabot> Unknown command, try @list
07:23:32 <Nisstyre> prots: yes, that is encapsulated by the more general case of n
07:23:35 <spacekitteh> i'm trying to learn haskell by writing a basic dynamics/control system library
07:23:38 <Nisstyre> which I am leaving to you to figure out
07:24:17 <Nisstyre> I'll give you another hint and say that the function will return a call to : (also known as cons)
07:25:58 <osfameron> prots: remember you can write [[3],[2],[1]] as [3]:[2]:[1]:[]
07:26:07 <Nisstyre> :t (:)
07:26:08 <lambdabot> a -> [a] -> [a]
07:26:19 <hpaste> prots pasted “list” at http://hpaste.org/80540
07:26:20 <osfameron> prots: and singletons 0 = []
07:26:50 <prots> @osfameron ty for this hint ^^
07:26:50 <lambdabot> Unknown command, try @list
07:26:55 <osfameron> prots: good!  but you have 2 problems
07:27:06 <prots> are ?
07:27:07 <osfameron> prots: you've wrapped x in too many []
07:27:14 <osfameron> prots: and you're missing the singletons 0  case
07:27:15 <kamatsu> prots: stop using @, it's confusing poor lambdabot
07:28:02 <Nisstyre> :t (\a xs -> [a] : xs)
07:28:03 <lambdabot> t -> [[t]] -> [[t]]
07:28:15 <Nisstyre> a = [t]
07:28:28 <DMcGill> I have a list t := [t0, t1, ...] and an initial element j0. I want the list [j0, j0 - t0, j0 - t0 - t1, ...]. Is there some clever fold that does this?
07:28:30 <Nisstyre> that is what we call an instance of "a -> [a] -> [a]"
07:28:40 <Peaker> I want an automatic DebugShow instance that everything has :(  Getting a Show constraint to propagate through so many functions for a debug print is so annoying
07:28:44 <DMcGill> it seems like a cross between a fold and zipWith
07:29:01 <kamatsu> Peaker: I agree, but what about situations where it's impossible
07:29:08 <prots> ty u guys u helped me alot ^^
07:29:16 <kamatsu> Peaker: e.g (show $ \x -> x)
07:29:20 <Peaker> kamatsu, a DebugShow is always possible
07:29:27 <Peaker> kamatsu, it could show "Function at 0x21312321"
07:29:31 <Peaker> kamatsu, (at worst)
07:29:38 <Peaker> kamatsu, or "\x -> x" at best
07:29:51 <Nisstyre> er, well that's not quite accurate, but t = a in that context
07:30:03 <Peaker> it doesn't need to give any correctness guarantees or laws.. just something to help with debugging
07:30:06 <kamatsu> i doubt it would be recoverable by that point.
07:30:12 <kamatsu> (\x -> x)
07:30:27 <Peaker> even if functions are shown as "<func at <ptr>>" and Showable stuff were shown, it'd be a huge improvement
07:30:37 <kamatsu> it would be nice
07:30:44 <kamatsu> i basically only ever use Show for debugging anyway
07:30:58 <kamatsu> but usually it's just a matter of adding "deriving Show" to all my types
07:31:01 <kamatsu> not too onerous
07:31:25 <XexonixXexillion> Is there anyway I can have a datatype which only wraps  (), or a -> (), or a -> b -> () or a -> b -> c -> () or a -> b -> c -> d -> () etc. ?
07:31:42 <Nisstyre> Peaker: I think the reason they don't do that is because of the supposed relationship between Show and Read
07:32:39 <Peaker> kamatsu, the problem is debugging inside polymorphic functions
07:32:54 <Peaker> kamatsu, I need to add a (Show a) constraint to tons of polymorphic functions
07:33:07 <Megant> DMcGill: scanl?
07:33:08 <Peaker> Nisstyre, that's why I want a "DebugShow" with no laws, no guarantees, etc.
07:33:16 <Peaker> Nisstyre, that's different from Show, and always available
07:33:20 <Peaker> (perhaps only in debug mode!)
07:34:42 <XexonixXexillion> Peaker: Wouldn't DebugShow need to know the type of what it's showing?
07:35:16 <Peaker> XexonixXexillion, it would be like you had an automatic "deriving DebugShow" on all types, and an implicit "DebugShow" constraint on all type variables
07:35:38 <Peaker> which might be expensive, perhaps (not entirely sure), in which case, it can be a debug mode thing
07:35:53 <ski> (s/all type variables/all type variables of kind `*'/ ?)
07:36:19 <ski> XexonixXexillion : what do you want to do with these functions ?
07:36:25 <merijn> XexonixXexillion: You could do that using typeclasses and then use GADTs to restrict your datatype to only accept argument of that typeclass, why do you need that?
07:36:43 <wuttf> I am cheking HUnit and I am not really keen on having to write boilerplate like  test = TestList [ TestLabel "test1" test1, ... etc
07:36:49 <wuttf> Are there any alternatives?
07:37:19 <XexonixXexillion> ski: Simply unwrap them. I just want the compiler to make sure I haven't given it garbage
07:37:41 <ski> ok, so you never want to call the functions inside, then ?
07:38:47 <ski> `Foo ()' with `data Foo a = It a | forall b. Wrap (Foo (b -> a))' would work, i think
07:38:58 <DMcGill> Megant: that's exactly what I needed, thanks
07:39:21 <ski> given `f :: a -> b -> ()', you get `Wrap (Wrap (It f)) :: Foo ()'
07:43:32 <XexonixXexillion> ski: thanks
07:43:42 <kamatsu> wuttf, without template haskell, i doubt it
07:44:07 <wuttf> kamatsu: I see.
07:44:20 <ski> XexonixXexillion : .. i'm still wondering what use you'd have of this
07:45:44 <Peaker> ski, yeah, all type vars of kind *, though maybe also magically require constraints for (forall a. DebugShow (f a))
07:50:08 <ski> Peaker : hm, Hugs with flag `-u' has something like what you want
07:50:33 * hackagebot clckwrks 0.14.2 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.14.2 (JeremyShaw)
07:51:09 <Peaker> ski, hugs still exists? :)
07:51:36 <ski> yes :)
07:55:33 * hackagebot kure 2.6.14 - Combinators for Strategic Programming  http://hackage.haskell.org/package/kure-2.6.14 (NeilSculthorpe)
07:55:35 * hackagebot clckwrks-cli 0.2.1 - a command-line interface for adminstrating some aspects of clckwrks  http://hackage.haskell.org/package/clckwrks-cli-0.2.1 (JeremyShaw)
07:59:05 <Peaker> ski, is it maintained?
08:00:33 * hackagebot clckwrks-plugin-bugs 0.3.4 - bug tracking plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-bugs-0.3.4 (JeremyShaw)
08:00:57 <XexonixXexillion> Now for something a bit harder. If we know can be wrapped as Foo a, can we somehow compose a function of type a -> b with it. I.e f . g = f (g <x1> .. <xn>)
08:05:01 <mSSM> If I understand mersenne-random correctly, it doesn't have a functionality like randomR (a,b) to e.g. give me an Int in the range [a,b] ?
08:05:35 * hackagebot clckwrks-plugin-media 0.3.2 - media plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-media-0.3.2 (JeremyShaw)
08:05:36 <geekosaur> XexonixXexillion, if you have a functor instance for Foo, then you can fmap your function over a Foo a
08:05:37 * hackagebot clckwrks-plugin-ircbot 0.3.2 - ircbot plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-ircbot-0.3.2 (JeremyShaw)
08:05:39 <geekosaur> to get a Foo b
08:05:39 * hackagebot clckwrks-theme-bootstrap 0.2.4 - simple bootstrap based template for clckwrks  http://hackage.haskell.org/package/clckwrks-theme-bootstrap-0.2.4 (JeremyShaw)
08:06:10 <geekosaur> "to get Foo b" --- lose the "a", it might be grammatically correct, but it's potentially confusing :)
08:07:20 <ski> Peaker : the last release is 2006-09
08:08:56 <zomg> Anyone know if there's some way to use these functions from parsec in code importing it, without literally having to copy-paste them? http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/src/Text-Parsec-Token.html#line-423
08:09:15 <zomg> (the ones related to the stringLiteral function)
08:09:51 <XexonixXexillion> geekosaur: I can't think of how to define an instance of Functor over data Foo a = It a | forall b. Wrap (Foo (b -> a))
08:10:41 <geekosaur> oh, I apparently missed earlier context.  if you're forall-ing then it gets harder, yes
08:11:34 <mSSM> When I do time profiling in GHC, how precise are its measurements? For example, I have roughly 3.0*10^7 operations of reading one element from a vector. Profiling tells me that the program spends 42% of its run time (8 sec) doing that, so about 3.5 sec in total. Is that a realistic estimate?
08:12:01 <Nisstyre> mSSM: profiling will necessarily never be perfect because the profiler has to interact with the program
08:12:12 <Nisstyre> (heisenberg for programmers basically)
08:12:13 <n-dolio> fmap f (It a) = It (f a) ; fmap f (Wrap g) = Wrap (fmap (f .) g)
08:12:52 <startling> Nisstyre: ...eh?
08:13:05 <Nisstyre> startling: which part don't you understand?
08:13:26 <mSSM> Nisstyre: Well, I have noticed that profiling causes a massive increase in time. That's okay.
08:13:40 <mSSM> Nisstyre: What I wonder about is whether the time increase scales over the whole program
08:14:05 <startling> Nisstyre, just write the program without the interaction bits, then
08:14:22 <mSSM> so for example - should I try and improve the time it spends on reading from the vector, or are there other parts in my program which in fact take more time.
08:14:22 <startling> oh, maybe you mean something else.
08:14:29 <Nisstyre> startling: then you'd be measuring how long the program took to run
08:14:31 <startling> serves me write for jumping in without context.
08:14:34 <Nisstyre> not profiling portions of it
08:14:43 <mSSM> How do I understand where my bottlenecks are?
08:15:09 <Nisstyre> mSSM: you can analyze your program to see which functions have worse time-complexity than others
08:16:06 <mSSM> Nisstyre: how do i go about doing that?
08:16:28 <Nisstyre> mSSM: but as to your original question, I'm not sure how accurate GHC's profiling is overall, or even if that would make sense to ask
08:16:42 <Nisstyre> mSSM: well do you know how average case time complexity works?
08:17:42 <Nisstyre> mSSM: you don't have to be ub3r formal about it anyway
08:17:58 <Nisstyre> just go through your program and figure out if any of your functions are going to run in exponential time
08:17:59 <mSSM> Nisstyre: I understand that... at least when I think back to my cs classes.
08:18:04 <Nisstyre> or non-polynomial time in general
08:18:18 <mSSM> Nisstyre: But how that translates to my haskell code is a different matter...
08:19:19 <ski> XexonixXexillion : what n-dolio said
08:20:10 <sdrodge> I want to create a type that is Integral but has a step size of 10, is there an easy way to do this?
08:20:43 <mSSM> Nisstyre: oh well; I am going to think about this. I am off for now.
08:20:47 <mSSM> Nisstyre: thanks for your input
08:23:05 <CodeDmitry_> hello :P
08:23:09 <startling> sdrodge: sure. newtype ByTen = ByTen Integer
08:23:30 <Nisstyre> sdrodge: how about "data Tens = AddTen Tens | Ten"
08:23:31 <startling> and then write the Real and Enum instances
08:23:32 <CodeDmitry_> can somebody here explain what a projection of a vector onto a vector mean?
08:23:35 <CodeDmitry_> >.>
08:23:58 <spacekitteh> basically, how much of the first vector is a part of the second vector
08:24:08 <sdrodge> startling: I'm not sure how to go about writing the Enum instance
08:24:18 <Eelis> CodeDmitry_: http://en.wikipedia.org/wiki/Dot_product has some diagrams
08:24:31 <startling> sdrodge, succ (ByTen n) = ByTen (n + 10)
08:24:44 <startling> sdrodge: pred (ByTen n) = ByTen (n - 10)
08:25:19 <Nisstyre> note that that doesn't preclude you from writing "ByTen 4"
08:25:35 <startling> Nisstyre's idea would also work (and might be more straightforward) but I'd do data Tens = AddTen Tens | Zero instead
08:25:35 <sdrodge> Nisstyre: is there a way to preclude that?
08:25:46 <startling> sdrodge, don't export "ByTen"
08:25:47 <Nisstyre> sdrodge: yes, but it's fairly advanced
08:25:55 <startling> Nisstyre: eh?
08:26:01 <Nisstyre> well, other than just hiding the data constructor
08:26:09 <Nisstyre> startling: I'm referring to dependent types
08:26:26 <startling> Nisstyre: well, good thing haskell doesn't have those!
08:26:31 <Nisstyre> yes it does
08:26:37 <startling> No, it really doesn't.
08:26:40 <Nisstyre> it's just hard to use
08:26:52 <Nisstyre> Functional Dependencies lets you write dependent types
08:27:29 <startling> Nisstyre, in a way that would be useful here?
08:28:18 <Nisstyre> startling: depends on how probable an error is, I would say it's not very likely that someone would make that error, especially if you hid the data constructor like you said
08:28:47 <sdrodge> startling: I still have to implement fromEnum and toEnum though, right?
08:29:43 <startling> sdrodge: yep. toEnum n = ByTens (toInteger n * 10) and fromEnum (ByTens n) = n `div` 10
08:31:03 <ski> Nisstyre : FDs doesn't let you write dependent types
08:33:00 <Nisstyre> ski: doesn't it let you do the same thing as some dependent types though?
08:33:23 <startling> Nisstyre: sort of but not really
08:33:47 <startling> Nisstyre: you still can't write x : Type -> Value or whatever
08:34:45 <ski> or write the type of binary search trees
08:35:19 <Nisstyre> yeah, I wasn't trying to say that you can do everything you can do with a real dependent type system
08:35:25 <Nisstyre> just that you can do some of the same things
08:36:40 <ski> you can simulate some of the applications, yes
08:37:02 <ski> (but you still can't have types depend on values)
08:39:14 <startling> (which is the definition of "dependent types", isn't it?)
08:39:36 <EarlGray^> What is the best way to handle complex binary layouts?
08:39:41 <ski> (afaiu, yes)
08:40:29 <EarlGray^> I know about Data.Binary.Get/Put, but it's too lowlevel, I still need write Get monads manually, and I want a declarative description of binary layout
08:41:29 <bxc> like parser combinators parsing a bit stream rather than a character stream?
08:41:49 <EarlGray^> yes, something like this
08:42:08 <quicksilver> is your bit stream really bits?
08:42:13 <n-dolio> All the 'faking dependent types' stuff only really fakes it for data.
08:42:14 <quicksilver> or is it, in fact, organised into bytes?
08:42:14 <bxc> is it byte aligned?
08:42:18 * bxc loses
08:42:53 <n-dolio> You can create singleton types where the type determines the value as data.
08:43:03 <mreh_> how much scope is there for integrating an existing imperative API with an FRP lib?
08:43:08 <EarlGray^> I need some tool to process a binary layout, I am into a primitive driver of Ext2fs
08:43:30 <quicksilver> pretty sure ext2fs stuff is in bytes.
08:43:30 <bxc> thats almost definitely going to be byte aligned then, I'd think
08:43:36 <quicksilver> in which case, you can just use parsec
08:43:44 <EarlGray^> and I don't want to use FFI, I want a binary layout description from scratch
08:43:48 <quicksilver> and probably most of the other parser libraries aren't actually chat-dependent.
08:44:06 <n-dolio> But there is no analogue to that with functions, unless you have a very limited set of functions that can be represented as a data type (like, codes for a few base functions, and compositions of them).
08:44:20 <EarlGray^> yes, I don't need to read bits, just a byte layout in little endian
08:44:21 <n-dolio> So, if you want types that depend on value-level functions, you're in trouble.
08:44:23 <bxc> quicksilver: parsec could parse bits too, right? (maybe quite ugly though)
08:44:50 <mreh_> parsec will parse lists of anything
08:44:54 <bxc> right
08:44:57 <bxc> thats what i though.
08:45:12 <mreh_> the Stream class implements that
08:45:23 <mreh_> IRRC
08:45:23 <mreh_> :)
08:45:34 <donri> re http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html -- the part proofs doesn't work for the operational package, does it?
08:45:42 <donri> the part about proofs*
08:45:46 <EarlGray^> I've already gotten a version with bare Data.Binary.Get working, but it's quite verbose
08:46:19 <donri> with operational you'd have, ExitSuccess :: TeletypeI (), which has the same problem as exitSuccess :: IO ()?
08:46:41 <EarlGray^> there what I have now: https://github.com/EarlGray/haskell-snippets/blob/master/ext2hs/Ext2.hs
08:46:56 <marekw2143> why does:
08:46:58 <marekw2143> > (+) <$> Just 3 <*> Just 5
08:47:00 <lambdabot>   Just 8
08:47:17 <startling> :t (+) <$> Just 3
08:47:18 <lambdabot> Num a => Maybe (a -> a)
08:47:28 <marekw2143> work, and " fmap (fmap (+) (Just 3))  (Just 5)" doesn't work
08:47:28 <startling> marekw2143: ^ do you understand that?
08:47:41 <startling> marekw2143: (<*>) isn't fmap
08:47:46 <marekw2143> Yes, it returns a Maybe storing function from a to a
08:47:56 <startling> marekw2143: and then look at
08:47:56 <ski> marekw2143 : `(<$>') is the same as `fmap', `(<*>)' does more
08:48:01 <startling> :t (<*>)
08:48:02 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:48:06 <Lethalman> marekw2143, fmap wants an (a -> b) but (+) <$> Just 3 will give you Just (+3)
08:48:17 <ski> > Just (+) <*> Just 3 <*> Just 5
08:48:18 <lambdabot>   Just 8
08:48:41 <startling> > ((+) <$> Just 3) <*> Just 5
08:48:43 <lambdabot>   Just 8
08:48:44 <ski> `f <$> blah' can be seen as a shorthand of `pure f <*> blah'
08:49:06 <marekw2143> startling: yeah, just looked at definition of Applicative for Maybe
08:49:30 <ski>   (+) :: Integer -> Integer -> Integer
08:49:35 <startling> marekw2143: not really necessary, just look at the types
08:49:38 <ski>   Just (+) :: Maybe (Integer -> Integer -> Integer)
08:49:44 <ski>   Just 3 :: Maybe Integer
08:49:51 <ski>   Just (+) <*> Just 3 :: Maybe (Integer -> Integer)
08:49:54 <ski>   Just 5 :: Maybe Integer
08:50:02 <ski>   Just (+) <*> Just 3 <*> Just 5 :: Maybe Integer
08:51:06 <ski> `(<*>)' takes two (in this case) `Maybe'-wrapped things, and applies the function in the first (if any) to the argument in the second (if any), and rewraps the result
08:51:07 <marekw2143> :t fmap (+) Just 5
08:51:08 <lambdabot> (Num a, Num (Maybe a)) => Maybe a -> Maybe a
08:51:30 <ski> @type fmap (+) (Just 5)
08:51:31 <lambdabot> Num a => Maybe (a -> a)
08:51:41 <ski> (i think you meant)
08:52:11 <marekw2143> Num (Maybe a)  - what's that?
08:52:24 <marekw2143> :t fmap (+) (Just 5)
08:52:25 <lambdabot> Num a => Maybe (a -> a)
08:52:41 <marekw2143> :t (+) <*> (Just 5)
08:52:43 <lambdabot>     Couldn't match expected type `b0 -> b0' with actual type `Maybe a0'
08:52:43 <lambdabot>     In the return type of a call of `Just'
08:52:43 <lambdabot>     Probable cause: `Just' is applied to too many arguments
08:53:16 <kennyd> :t Just (+) <*> Just 5
08:53:17 <lambdabot> Num a => Maybe (a -> a)
08:54:25 <marekw2143> ok, so Just (+) <*> Just 5 returns Maybe packing function
08:54:29 <bxc> marekw2143: Num (Maybe a) means that it will work if   Maybe a   (for example Maybe Int) has number operations defined on it, like +
08:54:34 <bxc> marekw2143: which is not the case
08:54:44 <marekw2143> then why following:
08:55:02 <bxc> you could do that if you wanted to, I guess, but you'd end up with a lot of this applicative code in a diffrent place i think
08:55:06 <marekw2143> fmap ( fmap (+) (Just 5 )) (Just 3)
08:55:08 <marekw2143> > fmap ( fmap (+) (Just 5 )) (Just 3)
08:55:10 <lambdabot>   Couldn't match expected type `a0 -> a1'
08:55:10 <lambdabot>              with actual type `Data...
08:55:11 <marekw2143> doesn't work
08:55:23 <Clint> because the types
08:55:30 <ski> marekw2143 : `fmap' only takes a single `Maybe'-thing here. you need `(<*>)' to combine two of them
08:55:55 <bxc> thats (+) <$> (Just 5) <$> (Just 4)
08:56:06 <ski>   fmap :: (a -> b) -> (Maybe a -> Maybe b)
08:56:18 <ski>   (<*>) :: Maybe (a -> b) -> (Maybe a -> Maybe b)
08:56:27 <bxc> thats (+) <$> (Just 5) <*> (Just 4)
08:56:34 <bxc> grr
08:57:06 <bxc> marekw2143: your fmap example is the same as (+) <$> (Just 5) <$> (Just 3),  not (+) <$> (Just 5) <*> (Just 3)
08:57:18 <bxc> marekw2143: they're different expressions!
08:57:31 <marekw2143> hmm, I'll analyze that
08:58:07 <marekw2143> but from <*> definition of Maybe (maybe that's wrong definition :); I took it from: http://learnyouahaskell.com/functors-applicative-functors-and-monoids)
08:58:21 <marekw2143> it occurs that <*> for Maybe is:     (Just f) <*> something = fmap f something
08:58:30 <bxc> yep
08:58:48 <marekw2143> Ohh, I see now
08:59:00 <marekw2143> my inner fmap returns (Just (+5))
08:59:12 <marekw2143> and it should return (+5), right?
08:59:34 <bxc> if you want it to work with <$> rathan that <*>
08:59:36 <bxc> yes
08:59:41 <ski> for the outer 'fmap' to accept it, yes
08:59:44 <bxc> thats what the <*> does: that magic extra unwrapping
09:00:04 <marekw2143> but wait
09:00:42 <marekw2143> if     (Just f) <*> something = fmap f something   is good definition, then everywhere I use " (Just a) <*> (Just b)"
09:01:08 <marekw2143> then I can replace it with:  fmap a Just b
09:02:43 <marekw2143> hmm, can <*> be always changed with something else?
09:02:57 <bxc> what do you mean "changed with something else?"
09:03:31 <marekw2143> can we write compiler for haskell applications, which will change every occurrence of "<*>" with finite amount of code?
09:03:48 <marekw2143> having same semantics^^
09:04:08 <marekw2143> with assumption that
09:04:13 <marekw2143> <*> will be used for Maybe only
09:05:01 <bxc> you can do that for any function, if you have some other code that does the same as that first function
09:05:41 <kennyd> @src (<*>)
09:05:41 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:05:57 <bxc> kennyd: its in a typeclass
09:06:04 <kennyd> yeah, brain fart moment
09:06:22 <Nereid> @src Maybe (<*>)
09:06:22 <lambdabot> (<*>) = ap
09:06:26 <Nereid> cool
09:06:28 <Nereid> :(
09:06:45 <Nereid> Just f <*> Just x = Just (f x); _ <*> _ = Nothing
09:08:17 <basdirks> Just f <*> x = f <$> x
09:08:22 <basdirks> or is that considered uglier?
09:08:37 * madhadron giggles at all the furor his comment on C caused on Hacker News.
09:09:44 <bxc> madhadron: in the unreasonable effectiveness of C?
09:09:55 <madhadron> bxc: Yeah.
09:10:08 <madhadron> Oh, the children, ignorant of the history and extent of their craft.
09:10:10 <marekw2143> how is <*> defined for functions?
09:10:22 <marekw2143> @src (-> r) (<*>)
09:10:22 <lambdabot> Source not found. :(
09:10:28 <Rembane> :t <*>
09:10:29 <lambdabot> parse error on input `<*>'
09:10:36 <Rembane> :t (<*>)
09:10:38 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:10:40 <`ramses> @src ((->) r) (<*>)
09:10:40 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:10:50 <quicksilver> marekw2143: it supplies the same environment to function and parameter both
09:10:54 <quicksilver> (what else could it do?)
09:10:55 <bxc> madhadron: yeah i see it right at the top
09:11:09 <quicksilver> f <*> x = \e -> (f e) (x e)
09:11:39 <madhadron> bxc: Oh, don't waste your time.
09:12:28 <`ramses> marekw2143: something like f <*> h = \r -> f r (h r)
09:12:48 * bxc starts a flame reply.
09:13:23 <marekw2143> so it's like function composition?
09:13:56 <madhadron> bxc: Hey now, I've already done the Haskell community's part to cheapen discourse in that corner of the Internet!
09:16:19 * bxc gets bored of reading through the comments.
09:17:41 <`ramses> marekw2143: not really.. the types are pretty different
09:17:47 <`ramses> :t (<*>)
09:17:48 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:17:50 <`ramses> :t (.)
09:17:51 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:18:13 <`ramses> :t (.).(.)
09:18:15 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:18:26 <`ramses> :t flip ((.).(.))
09:18:27 <lambdabot> (Functor f1, Functor f) => f (f1 a) -> (a -> b) -> f (f1 b)
09:18:39 <bxc> `ramses: now draw a spider
09:18:42 <quicksilver> you can use (.) as part of it
09:18:43 <`ramses> nah, it's different :)
09:18:46 <quicksilver> but it isn't (.)
09:18:53 <Anchakor> :t map(<).maximum
09:18:54 <Lethalman> marekw2143, partial function application where functions are inside functors
09:18:55 <lambdabot> Ord a => [[a]] -> [a -> Bool]
09:19:09 <Anchakor> :t maximum
09:19:11 <lambdabot> Ord a => [a] -> a
09:19:55 <madhadron> bxc: Yeah, I'm only following it because I'm running a slow unit test suite.
09:20:14 <bxc> `ramses: where is that (.) definition from? (which module?)
09:20:29 <`ramses> bxc: in lambdabot (.) == fmap
09:20:36 <bxc> oh
09:20:43 <bxc> lambdabot special sauce
09:20:43 <glguy> bxc: lambdabot is just broken, it's not used like this anywhere else
09:20:50 <bxc> yeah i was confused for a bit...
09:21:07 <michaeltbaker> Hello, I'm trying to work with the OpenGL bindings. I have a display function and I have it registered as the display callback, but it only seems to be run once. Is there something special that determines when it gets run? I'm checking when it runs by including a putStrLn in the middle of the display function. The output only appears on the console once.
09:21:22 * ski . o O ( s/==/=/ )
09:21:36 <ski> @src (.)
09:21:36 <lambdabot> (f . g) x = f (g x)
09:21:36 <lambdabot> NB: In lambdabot,  (.) = fmap
09:21:47 <`ramses> bxc: if you view all those functors as just extra function parameters you get a normal (.)
09:21:51 <bxc> right
09:21:55 <Phlogistique> and (.)(.) = fap
09:22:06 <marekw2143> see, so <*> is function composition when function is packed in functor, right?
09:22:07 <Phlogistique> (hope this channel is not publicly logged)
09:22:08 <bxc> i see that - I just didn't remember see it abstracted that way in the standard libraries
09:22:43 <ski> Phlogistique : see <http://tunes.org/~nef/logs/haskell/13.01.10>
09:22:47 <elliott> Phlogistique: It is.
09:22:48 <quicksilver> marekw2143: no.
09:22:51 <Phlogistique> heh
09:23:11 <quicksilver> marekw2143: it's function application (very different from composition)
09:23:27 <marekw2143> quicksilver: understood
09:23:29 <gurrag> what is the off topic Haskell channel again?
09:24:02 <quicksilver> #haskell-blah
09:25:07 <quchen> marekw2143: for functions, fmap = (.). The Applicative instance for function is actually SK calculus, with pure = K, <*> = S.
09:25:33 <marekw2143> quchen: what is "SK calculus" ?
09:26:21 <ski> marekw2143 : <http://en.wikipedia.org/wiki/SKI_combinator_calculus>
09:26:30 <quchen> It's a theoretical language that can be shown to be equivalent to lambda calculus. It has only two syntactic elements, the S and K function. Composing them makes a full language.
09:27:08 <quchen> I have yet to see an application of the Applicative instance for functions that's useful (and not just for brevity).
09:27:14 <quchen> I don't think anyone can actually read it
09:27:55 <magneticduck> question: are IORefs the closest you can get to a pointer in haskell?
09:27:58 <mauke> I can read ap
09:28:05 <mauke> magneticduck: no, Ptr is
09:28:17 <magneticduck> mauke: kk
09:28:19 <startling> quchen, it's useful for reader-ish things
09:28:32 <magneticduck> and, are IORefs made using pointers?
09:28:38 <magneticduck> well
09:28:42 <magneticduck> everything's made using pointers
09:28:45 <magneticduck> except files
09:28:46 <startling> :t (,) <$> snd <*> fst
09:28:47 <magneticduck> :P
09:28:48 <lambdabot> (a, a1) -> (a1, a)
09:28:51 <magneticduck> but, are they implemented within the language?
09:29:01 <mauke> @src IORef
09:29:01 <lambdabot> newtype IORef a = IORef (STRef RealWorld a)
09:29:08 <mauke> @src STRef
09:29:08 <lambdabot> data STRef s a = STRef (MutVar# s a)
09:29:11 <quchen> startling: Are there cases where it's better to use (r ->) and not Reader?
09:29:12 <mauke> apparently not
09:29:17 <ski> @type liftM2 (,) snd fst
09:29:18 <lambdabot> (a2, a1) -> (a1, a2)
09:29:18 <magneticduck> hum
09:29:22 <quicksilver> no, they're not implemented within the language
09:29:25 <quicksilver> they're GHC primitives.
09:29:30 <startling> quchen, yes, you can use ordinary functions.
09:29:33 <magneticduck> cool
09:29:37 <`ramses> quicksilver: when you said you can write that (<*>) for functor with (.), you meant like  join (flip f . h) ? or is there a prettier way? :)
09:29:40 <magneticduck> just found out about them
09:29:42 <startling> :t (,) <$> head <*> tail
09:29:44 <lambdabot> [a] -> (a, [a])
09:30:13 <quchen> startling: Hm. That then qualifies I guess. How do you read <*> then?
09:30:17 <quicksilver> `ramses: erm, something liek that, yes :)
09:30:26 <Torres> Hi! I want to learn haskell? how do I start?
09:30:29 <bxc> isn't it cheating to use join?
09:30:38 <quchen> Torres: LYAH is a great start.
09:30:40 <mauke> @where lyah
09:30:40 <quchen> @where lyah
09:30:40 <lambdabot> http://www.learnyouahaskell.com/
09:30:40 <lambdabot> http://www.learnyouahaskell.com/
09:30:49 <quchen> Also it's funny.
09:30:52 <`ramses> bxc: yeah, that's why I asked, it's the best I can come up with
09:30:53 <mauke> Torres: or tryhaskell.org
09:30:54 <monochrom> you can also play with tryhaskell.org
09:30:55 <startling> quchen: "comma over head applied to tail"
09:31:00 <Torres> okey
09:31:04 <Torres> thanks people ;)
09:31:14 <magneticduck> Torres: hehe, we answer questions like that fast
09:31:20 <`ramses> join relies on the monad instance :(
09:31:35 <quchen> startling: Wait what?
09:31:38 <magneticduck> another question: I know Ptrs are used for interacting with C code, but why would anyone need an IORef?
09:31:45 <bxc> `ramses: right - monad > applicative > functor - you should be able to implement stuff in the lesser using stuff from the higher
09:31:51 <mauke> magneticduck: to get mutable variables in IO
09:32:07 <startling> quchen: (,) <$> head <*> tail
09:32:07 <magneticduck> but..
09:32:09 <magneticduck> this is haskell!
09:32:11 <magneticduck> :D
09:32:13 <magneticduck> oh well
09:32:28 <magneticduck> my GLUT tutorial was using them
09:32:35 <magneticduck> but then, my GLUT tutorial has no style
09:32:37 <magneticduck> GLUT has no style
09:32:38 <`ramses> bxc: I know.. you have an idea for a point-free (<*>) for ((->) r) without using monad stuff?
09:32:41 <madhadron> magneticduck: Sometimes you actually want a C style variable.
09:32:43 <applicative> magneticduck: you can use STRefs instead. ...
09:32:45 <startling> magneticduck, having an actual mutable variable can be useful sometimes.
09:32:46 <quchen> startling: I don't see how that is related to the Applicative instance of functions
09:32:51 <monochrom> you are asking, "why would anyone want mutable state". the answer is the same as for: "why would anyone want pointers"
09:32:52 <magneticduck> I see
09:32:55 <applicative> magneticduck: oh maybe not in a GLUT tutorial
09:33:06 <quchen> startling: OOhhh. Wait.
09:33:08 <quchen> I see.
09:33:13 <magneticduck> alright
09:33:31 <magneticduck> I'll add that to my toolbox I guess, reluctantly
09:33:38 <madhadron> magneticduck: It tends to be when you have a specific, imperative algorithm that is going to be your best option and you're by god going to do it.
09:33:43 <monochrom> my http://hpaste.org/80484 uses IORef
09:33:43 <startling> quchen: :)
09:34:09 <madhadron> magneticduck: Or if you want unsynchronized and unprotected sharing of data among threads
09:34:12 <marekw2143> is knowledge about lambda calculus very helpfull in understanding Haskell?
09:34:14 <magneticduck> ahah
09:34:22 <magneticduck> yeah that would make sense
09:34:23 <startling> marekw2143: not especially, but it doesn't hurt.
09:34:33 <quchen> startling: Saw "head" and thought of lists there
09:34:34 <madhadron> magneticduck: There are some very neat parallel algorithms that work without locks and the like, and for those cases the IORef is perfect.
09:34:52 <startling> quchen, head is a function, not a list!
09:34:52 <EarlGray^> I think interactive animation should use threads instead of IORef and such
09:35:22 <madhadron> EarlGray^: Yes, IORef doesn't sound like the right solution there to me, either
09:35:40 <quchen> startling: Yeah, I know, but as soon I thought about lists everything was list and then <*> was list and list list list. Anyway, got it now, thanks.
09:35:53 <EarlGray^> passing messages between  a rendering thread and a thread reading UI events looks like a much nicer solution
09:35:56 <startling> quchen: heh
09:36:07 <marekw2143> when evaluating: (+) <$> (Just 5) <*> (Just 3), then <$> is evaluated before <*> ?
09:36:13 <startling> yes.
09:36:17 <EarlGray^> though I haven't written anything to proof this concept yet
09:36:25 <startling> it's the same as ((+) <$> Just 5) <*> Just 3
09:36:28 <EarlGray^> for me, at least
09:36:43 <quchen> marekw2143: Both are infixl 4. Therefore, the <$> in your case is evaluated first.
09:37:17 <marekw2143> @src (<$>)
09:37:17 <lambdabot> f <$> a = fmap f a
09:37:33 <marekw2143> > fmap (+) (Just 5)
09:37:34 <lambdabot>   No instance for (GHC.Show.Show (a0 -> a0))
09:37:34 <lambdabot>    arising from a use of `M68319...
09:38:02 <quchen> > fmap (+2) (Just 5)
09:38:04 <lambdabot>   Just 7
09:38:20 <monochrom> @type (+) <$> Just 5
09:38:22 <lambdabot> Num a => Maybe (a -> a)
09:38:45 <marekw2143> :t fmap (:) [(+3)]
09:38:46 <lambdabot> Num a => [[a -> a] -> [a -> a]]
09:39:23 <marekw2143> so this expression evaluates to: list of functions which takes a list of functions a->a and returns list of functions a->a ?
09:41:03 <roadfish> @hoogle breakEnd
09:41:03 <lambdabot> Data.ByteString.Char8 breakEnd :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
09:41:04 <lambdabot> Data.ByteString breakEnd :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
09:41:29 <roadfish> is there a version of breakEnd for general lists? and not just ByteString?
09:41:41 <monochrom> soon, you will find that "x ++ (foldr blahblah)" does not evaluate foldr first
09:41:46 <mauke> roadfish: no
09:42:04 <Smaked> What we can do with Haskell language?
09:42:19 <marekw2143> Smaked: learn it !
09:42:22 <mauke> Smaked: write programs
09:42:26 <mauke> prove things
09:42:41 <Eelis> that's a bit of an exaggeration ;)
09:42:46 <roadfish> alternatively, is there a version of takeWhile that gives the shortest "non-empty" sequence ... as opposed to the longest sequence
09:43:01 <madhadron> Smaked: Act supercilious to those imperative programmers!
09:43:01 <mauke> Eelis: then what are all the papers that use Haskell about?
09:43:11 <Eelis> mauke: not about using Haskell to prove things
09:43:22 <Eelis> those papers use Coq etc
09:43:29 <mauke> wat
09:43:37 <mauke> the papers that use Haskell don't all use Coq
09:43:44 <Eelis> no, the papers that prove things
09:43:52 <mauke> those don't either
09:43:56 <Eelis> oh well
09:44:25 <mauke> in fact, I'm pretty sure none of dozen papers I have here uses Coq
09:44:26 <Smaked> is haskell hard?
09:44:31 <mauke> Smaked: sometimes
09:44:36 <Eelis> mauke: good luck proving stuff with Haskell
09:44:41 <quchen> Is C++ hard?
09:44:47 <monochrom> Eelis: "what can we do with haskell? answer: learn it" does not mean write a haskell program to learn haskell. therefore, "what can we do with haskell? answer: prove things" does not mean write a haskell program to prove things. presumably, it means humans can prove things about haskell.
09:44:50 <mauke> Eelis: well, you really prove stuff with maths
09:44:58 <mauke> Haskell is just along for the ride
09:45:20 <Eelis> if someone asks "what can i do with Haskell", then "prove things about it" is a pretty lame answer
09:45:30 <mauke> no, prove things about algorithms
09:45:41 <Eelis> Coq is better for that
09:45:44 <monochrom> yes, so are "learn it" and "write programs"
09:45:56 <Eelis> *much* better in fact
09:46:04 <mauke> then why didn't the Haskell committee design Coq instead of Haskell?
09:46:11 <Eelis> because proving things wasn't their goal
09:46:17 <monochrom> you are just religious about Coq
09:46:18 <Eelis> like it was for the Coq developers
09:46:21 <mauke> [citation needed]
09:46:30 <quchen> What is quite unique about Haskell as a general-purpose language is the frequency you look at a five line function thinking "wow, I just wrote a truly beautiful piece of code".
09:46:30 <monochrom> and possibly religious about curry-howard
09:46:41 <Eelis> monochrom: if you think Coq isn't better for proving things than Haskell, then you are just uninformed :)
09:46:53 <mauke> AFAIK one of the design goals of Haskell was to get a "standard" lazy functional language you could use in CS papers
09:46:53 <madhadron> monochrom: Hey, don't you dis my Janus-like idol!
09:47:16 <monochrom> I am not thinking that
09:47:19 <madhadron> (Sorry I'm not being serious folks. I'm just trying to stay sane in the face of Ruby.)
09:47:34 <Eelis> monochrom: then you agree it's not a religious issue
09:47:43 <monochrom> I like to prove things about Haskell. what do I use for my proofs? perhaps Coq. perhaps HOL. perhaps myself
09:48:55 <monochrom> ok, explain why you said <Eelis> if someone asks "what can i do with Haskell", then "prove things about it" is a pretty lame answer
09:49:02 <Eelis> monochrom: no
09:49:08 <monochrom> are you saying that we should not prove things about haskell?
09:49:12 <neutrino> monochrom: i would say the same
09:49:17 <neutrino> it's a pretty lame answer
09:49:19 <Smaked> If If I learn haskell in the college can I get easily a job?
09:49:25 <Eelis> Smaked: no
09:49:31 <marekw2143> Smaked: why do you want to know what can you do with haskell?
09:49:42 <madhadron> Smaked: I'm curious. Do you have a list of questions you're asking for a project?
09:49:53 <citizen93> I have a small question regarding the "mysterious" function seq... I have looked at the source but it's non-existent (http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:seq)
09:49:57 <madhadron> If so, it might be easier to post them at once in a gist or a pastebin, and ask people for responses.
09:50:01 <citizen93> can I define seq myself?
09:50:06 <mauke> citizen93: no
09:50:35 <Eelis> if you want to formally prove something about an algorithm, it's a lot more sane to write it in Coq and then prove things about that Coq version, than to first write it in Haskell and then encode Haskell in some other logic and work through a thick layer of representation to prove anything
09:50:36 <citizen93> .... that's a disappointing answer...
09:51:06 <Jafet> @quote kmc curry-howard
09:51:06 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
09:51:13 <Eelis> yup
09:51:14 <quchen> citizen93: seq creates an artificial dependency between two things. When "seq a b" is evaluated, seq returns b; however, the compiler is tricked into thinking that for this, it first has to evaluate a.
09:51:15 <mauke> citizen93: you can't define IO either
09:51:35 <elliott> Technically not "first".
09:51:40 <ski> @type let seq !_ a = a in seq  -- cheating
09:51:41 <lambdabot> t -> t1 -> t1
09:51:59 <elliott> All you really know about seq is that seq _|_ b = _|_, seq a b = b where a =/= _|_
09:52:04 <elliott> In fact GHC will sometimes evaluate the b before the a.
09:52:13 <ski> quchen : s/first //
09:52:15 <elliott> (You can use pseq if you care about the operational details)
09:52:36 <citizen93> ah I see
09:52:48 <neutrino> citizen93: seq needs support from the run-time system. check out simon peyton jones's talks on parallel haskell
09:52:58 <quchen> elliott: That's actually the definition of seq, isn't it?
09:53:07 <elliott> quchen: What you said isn't.
09:53:18 <neutrino> Smaked: if you learn haskell in the college, then yes, you can easily land a job, because it teaches you things you can use in other languages too.
09:53:22 <quchen> elliott: I meant your line above, seq bot _ = bot
09:53:23 <quchen> etc
09:53:26 <ski> quchen : `_|_' isn't valid Haskell code
09:53:48 <elliott> quchen: right, that is
09:54:00 <elliott> well, assuming you mean the "specification" rather than the definition
09:54:10 <citizen93> so I cannot create a dependency myself
09:54:10 <Eelis> neutrino: so you still need to learn the other languages to get the job ;)
09:54:18 <citizen93> between like [Int] and Int or something?
09:54:18 <tps_> haskell
09:54:34 <monochrom> well, that's religious about Coq. here is why. I want to write, prove correct, and use a Haskell program, not a Coq program. you are now saying, don't do that, write and use Coq programs. well I refuse. perhaps you can say, I am religious in Haskell
09:54:35 <quchen> elliott: "Definition" in the mathematical sense, yeah. The thing that describes how it behaves.
09:54:36 <citizen93> or are there exceptions in which I can do this without using seq itself?
09:54:37 <tps_> sorry… my bad.
09:54:39 <elliott> citizen93: that's not really what "dependency" means here
09:54:45 <elliott> or, I don't know what you mean by dependency
09:54:51 <citizen93> it means that a should be evaluated first right?
09:54:53 <neutrino> Eelis: you always have to learn the industry standards after college.
09:54:53 <elliott> quchen: Except it doesn't always behave like that even in practice.
09:54:57 <ski> citizen93 : `seq_ListInt :: [Int] -> Int -> Int; seq_ListInt [] n = n; seq_ListInt (_:_) n = n' ?
09:55:00 <zl64c> can i use haskell for programing on android and iOS?
09:55:02 <neutrino> Smaked: haskell is slowly becoming accepted in the industry.
09:55:24 <neutrino> Smaked: anyways, it's definitely the best language i came across for learning during college
09:55:30 <Eelis> monochrom: if one is serious about formal proofs, and one is sane, a system like Coq is currently the best way to go. i'm sorry if you don't like that state of affairs
09:55:35 <citizen93> elliot, can you explain why this forces the first one to be evaluated first?
09:55:46 <citizen93> or am I misunderstanding the concept of dependency?
09:55:48 <ski> citizen93 : it means that whenever `seq a b' is evaluated, `a' is also evaluated
09:55:51 <Eelis> formal proofs about algorithms, that is
09:56:06 <quchen> elliott: It would've been better if I had said "seq is a bottom checker", but what I wrote above is what rather pops up in my head when I think about it. It may be wrong, but helps me remember it for all practical purposes.
09:56:23 <Eelis> Haskell is nice for programming, but formally it's a joke
09:56:41 <elliott> quchen: Well, if you use seq for semantic purposes that might mess up your code sometime.
09:56:44 <ski> citizen93 : so, when `seq a b' is evaluated, both `a' and `b' are evaluated (not necessarily in that order) and the value of `b' is returned
09:56:45 <neutrino> Eelis: right now you're just trolling monochrom, and monochrom is trolling you. i would ask you both to stop.
09:56:49 <quchen> citizen93: Do you have the Haskell 2010 report? seq is defined on page 75.
09:56:53 <elliott> Semantic as in "if this 'a' doesn't get evaluated before this 'b' everything will explode".
09:57:00 <Eelis> neutrino: and you're trolling us both :P
09:57:21 <neutrino> no, i'm letting you two know you're disruptive.
09:57:26 <Saizan> Eelis: i think monochrom is fine doing the algorithm in one system and the proof in another, while you seem to assume we want both in one
09:57:30 <quchen> citizen93: http://i.imgur.com/NMF7R.png
09:57:43 <monochrom> have you seen http://www.cs.utoronto.ca/~hehner/aPToP/ ?
09:57:46 <Eelis> Saizan: there are obvious benefits to doing both in the same system
09:57:56 <mauke> "obvious"
09:58:11 <Eelis> not to you?
09:58:14 <monochrom> alternatively, have you done a survey on formal methods?
09:58:15 <citizen93> thank you for the link
09:58:16 <mauke> of course not
09:58:17 <Saizan> Eelis: yes, but Haskell is still nicer to prove things about than many other langs
09:58:19 <neutrino> the proof is left as an excercise to the reader
09:58:21 <citizen93> I will read it =)
09:58:45 <basdirks> monochrom: is that book beneficial for programming in Haskell?
09:58:50 <Eelis> mauke: if you have two, then you need to model one in the other, which is overhead. hence "obvious" :)
09:58:58 <quchen> citizen93: What's actually important is the definition, and that's the same thing that elliott said in the channel earlier
09:59:03 <monochrom> I don't know. it is beneficial for imperative programming
09:59:11 <Eelis> Saizan: yup
09:59:16 <mauke> Eelis: is overhead bad?
09:59:23 <Eelis> mauke: yup
09:59:25 <basdirks> can you extrapolate that to my question?
09:59:44 <mauke> Eelis: does it outweigh the disadvantages of not using Haskell?
10:00:10 <Eelis> mauke: for most algorithms, i would say yes, because for most algorithms it doesn't make that much difference whether you write them in Coq or in Haskell
10:00:10 <citizen93> ah I see... but I have another question! Why is the data type seq a -> b -> b and not just I dont know just a?
10:00:19 <monochrom> it doesn't cover too much functional programming. it is probably not very applicable to haskell
10:00:22 <Eelis> mauke: except that in Coq you get a nice formal object that you can prove things about inside Coq without overhead
10:00:24 <citizen93> since it's build into the GHC right?
10:00:25 <basdirks> okay =]
10:00:36 <mauke> Eelis: but I don't know Coq
10:00:41 <Eelis> mauke: it's not too late to learn! :D
10:00:45 <mauke> so all of that is useless to me
10:00:52 <mauke> Eelis: that's just overhead
10:00:55 <citizen93> or am I now just asking stupid obvious questions?
10:00:56 <Jafet> The nice thing about writing the algorithm in coq is that you don't ever have to worry about using it in practical applications
10:00:59 <glguy> citizen93: seq a b  forces a when b is forced. What would (seq a) do?
10:01:05 <Eelis> mauke: i see neutrino's talk about trolling has inspired you
10:01:14 <citizen93> seq a forces evaluation of just a?
10:01:23 <citizen93> a -> a?
10:01:24 <glguy> citizen93: When?
10:01:27 <mauke> Eelis: I see you're making a lot of hidden assumptions
10:01:28 <quchen> citizen93: The only variable of type "a" is bottom, i.e. something you can't do anything with. That wouldn't make much sense for seq.
10:01:39 <citizen93> always?
10:01:48 <George_> hi
10:01:58 <basdirks> we had #haskell vs javaguy like yesterday
10:02:06 <mauke> citizen93: seq x x is just x
10:02:06 <basdirks> this is round two?
10:02:18 <quchen> I think so. Maybe one of the proper computer scientists can help out here
10:02:34 <citizen93> yes I know that I tried seq 5 5...
10:02:48 <Eelis> basdirks: not at all, Haskell has many nice uses
10:02:49 <basdirks> netsplit to the rescue
10:02:51 <prophile> from what I recall, seq is \a b -> case a of {_ -> b}
10:03:01 <glguy> citizen93: (seq a) wouldn't force a until seq a was forced, but that doesn't help you
10:03:13 <basdirks> Eelis I know you're not anti-haskell, but the discussion is a typical x vs y discussion
10:03:16 <glguy> if you could force seq a you might as well force a
10:03:18 <mauke> prophile: not within Haskell
10:03:27 <Eelis> basdirks: only if you make an effort to see it that way
10:03:28 <basdirks> would be cool if it was x && y
10:03:42 <mauke> basdirks: yeah, I agree with Eelis there
10:03:58 <citizen93> yes, but since seq can't be defined in regular haskell... that wouldn't be a problem creating a function that just does that right?
10:04:01 <quchen> citizen93: What type other than a -> b -> b would make sense? Do you have anything specific in mind?
10:04:03 <prophile> mauke: no? it forces the evaluation of a then hands you b, no?
10:04:06 <mauke> citizen93: does what?
10:04:10 <mauke> prophile: no
10:04:21 <mauke> > case undefined of _ -> 42
10:04:22 <lambdabot>   42
10:04:24 <mauke> no evaluation is forced
10:04:44 <Jafet> @where seq
10:04:44 <lambdabot> I know nothing about seq.
10:04:47 <citizen93> I had in mind this: unsafeForce :: a -> a, which is what seq does but then without the need of the first parameter
10:04:48 <Eelis> i'm hoping that Coq and Haskell are growing closer together and will one day converge so that there won't be a convenience penalty anymore for working in a more formal system
10:04:49 <prophile> ah, I thought case caused evaluation
10:04:53 <Eelis> and i think they are
10:04:58 <prophile> I must have misunderstood
10:04:58 <Eelis> and there's things like Agda
10:05:03 <glguy> citizen93: when would (unsafeForce a) be evaluated?
10:05:20 <Eelis> which is wonderful
10:05:25 <citizen93> oh I seem to get it now
10:05:29 <citizen93> stupid of me...
10:05:31 <quchen> citizen93: That would be something like force x = seq x x. Something like that exists (Control.DeepSeq.force)
10:05:40 <ski> prophile : pattern-matching cuases evaluation
10:05:54 <prophile> ski: ah, and that case statement doesn't cause any pattern-matching?
10:06:00 <quchen> citizen93: Actually, seq x x is by definition the same as x.
10:06:10 <Eelis> but while Coq and Haskell have not yet converged, we need to be realistic about their relative strengths and weaknesses, and being able to prove shit is a strength of Coq
10:06:10 <citizen93> ah I see...
10:06:20 <citizen93> so the seq is actually a generalized version of what I had in mind?
10:06:37 <ski> prophile : yes, because `_' is an irrefutable pattern
10:06:41 <quchen> citizen93: (Case A: x = bottom. Then seq x x = seq bottom x = bottom by definition of seq. Case B: x /= bottom. Then seq _ x = x.)
10:06:43 <thoughtpolice> @seen shapr
10:06:43 <lambdabot> Unknown command, try @list
10:06:48 <thoughtpolice> oh, right. no preflex
10:06:52 <prophile> ski: righty, thanks for clearing that up for me :)
10:07:05 <ski> (prophile : so i suppose, it strictly depends on what you include in the term "pattern-matching")
10:07:09 <citizen93> ah Thank you guys, I learned a lot today!
10:07:17 <quchen> citizen93: Yes, in a sense. seq allows you to check another variable for bottomness when demanding a variable.
10:07:32 <prophile> ski: from what I recall case always causes evaluation in... STG? or perhaps Core
10:07:42 <prophile> I presume that irrefutable patterns are eaten at some point before that
10:07:48 <ski> prophile : in Core yes, iirc
10:07:53 <Jafet> I have this weird urge to enhance my coq now.
10:07:55 <citizen93> so I can force evaluations in two ways, with either seq or _ in pattern matching right?
10:07:58 <Anchakor> when converting functions to pointfree versions, does the number of the arguments of the used functions matter?
10:08:00 <quchen> In practice, you're often not really concerned about bottom when using seq (as it'll make your program misbehave). However, you can "abuse" seq to evaluate stuff a little bit.
10:08:02 <Jafet> @quote learn.agda
10:08:02 <lambdabot> ManuelChakravarty says: We used to say, "Learn Haskell, it makes you a better Java programmer." Now we say, "Learn Agda, it makes you a better Haskell programmer."
10:08:07 <prophile> Jafet: I get spam emails about that all the time
10:08:18 <ski> citizen93 : yes, but `seq' is polymorphic
10:08:25 <citizen93> yes I know =)
10:08:31 <mauke> citizen93: no
10:08:34 <Eelis> Jafet: you can read Coq'Art :) it's a great read
10:08:56 <bxc> | Copointed does not require a Functor, as the only relationship between copoint and fmap is given by a free theorem.
10:09:08 <ski> quchen : it's be nice if we could formulate this without assuming the domain is decidable
10:09:11 <Eelis> Jafet: and it will certainly enhance your coq
10:09:13 <bxc> whats the theroem? that fmap over a copointed gives the same value as fmap over the extacted value?
10:09:35 <quchen> ski: Hold your horses, I'm a physicist :s
10:10:02 <quchen> In different words: what?
10:10:20 <ski> quchen : without assuming that either `x = bottom' or `x =/= bottom'
10:10:57 <quchen> What would be the benefit of this?
10:11:18 <ski> more accutate modelling of the computation, perhaps
10:11:40 <ski> in reality, we can't decide whether an arbitrary computation halts or not
10:12:06 <Eelis> Coq extraction to Haskell is also interesting, but not mature
10:12:10 <Jafet> Eelis: I'll just wait for the great revolutionary unification of lcf, coq and mizar to happen, then use the result
10:12:15 <quchen> (On a side note: Haha, I just found a good joke in the Haskell report (page 76))
10:12:19 <Eelis> Jafet: could be decade or two :P
10:12:38 <Jafet> Oh, you're so optimistic
10:12:45 <Eelis> ^_^
10:13:06 <ski> quchen : i.e., instead of using classical math/logic in the modelling, i'd want to use constructive math/logic
10:13:20 <Eelis> meanwhile, i'm applying for C++ jobs because nobody wants Haskell programmers :'(
10:13:48 <quchen> ski: Ah, as in "seq can't prove that a = bottom (a => absurdum) doesn't mean anything"?
10:15:25 <Anchakor> anybody knows how to remove the x (make it pointfree) from: flip foldr1 (map x [3,4,5])
10:15:48 <quchen> Anchakor: use Lambdabot!
10:15:55 <quchen> @pl \x -> flip foldr1 (map x [3,4,5])
10:15:55 <lambdabot> flip foldr1 . flip map [3, 4, 5]
10:16:14 <ski> quchen : i don't follow (what do you mean by "a => absurdum" ?)
10:16:18 <Anchakor> damn I tried this in ghci and it didn't work
10:16:56 <Anchakor> @pl  foldr1 (+) (map (+1) [3,4,5])
10:16:56 <lambdabot> foldr1 (+) [4, 5, 6]
10:16:59 <quchen> ski: Constructive logic means that you can't use reductio ad absurdum to prove things, right?
10:17:01 <ski> @type foldr1 `flip` (`map` [3,4,5])
10:17:02 <lambdabot>     Couldn't match expected type `[c0]'
10:17:03 <lambdabot>                 with actual type `(a0 -> b0) -> [b0]'
10:17:03 <lambdabot>     In the second argument of `flip', namely `(`map` [3, 4, 5])'
10:17:07 <Jafet> :t flip foldr ?f
10:17:08 <lambdabot> (?f::b) => (a -> b -> b) -> [a] -> b
10:17:20 <ski> @type (foldr1 `flip`) . (`map` [3,4,5])
10:17:21 <lambdabot> Num a => (a -> c) -> (c -> c -> c) -> c
10:17:30 <quchen> ski: I thought you meant that when you talked about the fancy seq
10:17:30 <Anchakor> lambdabot: help
10:17:37 <Eelis> quchen: not in general, no
10:17:46 <quchen> Anchakor: /q lambdabot @list
10:17:50 <Anchakor> lambdabot: @help
10:17:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:18:13 <Eelis> quchen:  there /are/ propositions for which ~~P->P is provable even in constructive logic
10:18:13 <ski> quchen : in this case, i was more thinking about not having excluded middle `A \/ Not A', specifically in the form `a = b \/ Not (a = b)'
10:18:51 <quchen> Oh.
10:19:07 <quchen> Now I'm lost.
10:19:12 <Anchakor> @eval flip foldr1 (map (+1) [3,4,5]) (+)
10:19:25 <ski> quchen : where ?
10:19:42 <Anchakor> @run flip foldr1 (map (+1) [3,4,5]) (+)
10:19:43 <quchen> Dropping the excluded middle seems highly awkward
10:19:43 <lambdabot>   15
10:19:53 <Eelis> quchen: it certainly takes getting used to
10:20:03 <Anchakor> @run (flip foldr1) . (flip map [3,4,5]) (+1) (+)
10:20:05 <lambdabot>   Couldn't match expected type `t0 -> f0 [c0]'
10:20:05 <lambdabot>              with actual type ...
10:20:17 <`ramses> lambdabot: prepending code with ">" runs it as well
10:20:21 <quchen> Is it somehow describable what that does to the logic system?
10:20:24 <`ramses> Anchakor: ^^
10:20:50 <Eelis> quchen: you can start with http://en.wikipedia.org/wiki/Intuitionistic_logic
10:21:06 <Anchakor> > flip foldr1 . flip map [3, 4, 5] (+1) (+)
10:21:07 <lambdabot>   Couldn't match expected type `t0 -> f0 [c0]'
10:21:07 <lambdabot>              with actual type ...
10:21:17 <Anchakor> > flip foldr1 . flip map [3, 4, 5] (+) (+1)
10:21:18 <lambdabot>   Couldn't match expected type `t0 -> f0 [c0]'
10:21:19 <lambdabot>              with actual type ...
10:21:22 <`ramses> Anchakor: btw, this isn't ghci :)
10:21:26 <quchen> Alright, time for a Wikipedia session. Thanks!
10:21:33 <ski> quchen : consider an infinite stream of booleans -- we don't know how to decide whether it is equal to `repeat False' or not
10:21:46 <Anchakor> that is the same errors I got in ghci
10:21:58 <Jafet> ramses: see, you were wrong.
10:22:09 <`ramses> ?
10:22:13 <ski> if there is a `True' in it, we can find it, and so know the equality is false. if there isn't, then we'll never know (in general)
10:22:20 <Anchakor> @pl flip foldr1 (map x [3,4,5])
10:22:20 <lambdabot> flip foldr1 [x 3, x 4, x 5]
10:22:49 <Anchakor> @pl \x -> flip foldr1 (map x [3,4,5])
10:22:49 <lambdabot> flip foldr1 . flip map [3, 4, 5]
10:22:54 <`ramses> Jafet: what are you talking about?
10:23:31 <Anchakor> see this?
10:23:38 <Anchakor> now lets check it:
10:23:42 <Anchakor> > flip foldr1 (map (+1) [3,4,5]) (+)
10:23:43 <lambdabot>   15
10:23:56 <Jafet> ghc --irc
10:24:01 <Anchakor> > flip foldr1 . flip map [3, 4, 5] (+) (+1)
10:24:02 <lambdabot>   Couldn't match expected type `t0 -> f0 [c0]'
10:24:02 <lambdabot>              with actual type ...
10:24:08 <Anchakor> why this error?
10:24:32 <mauke> Anchakor: precedence
10:24:34 <Jafet> Because wrong order, in words are yours.
10:24:35 <Anchakor> the result should be the same no?
10:24:47 <`ramses> :t flip foldr1 . flip map [] $ (+) (+1)
10:24:48 <lambdabot> (Num a, Num (a -> a)) => ((a -> a) -> (a -> a) -> a -> a) -> a -> a
10:24:50 <`ramses> Anchakor: ^^
10:25:01 <quchen> ski: Makes sense. How does that relate to the logic discussion above?
10:25:02 <mauke> `ramses: wtf?
10:25:05 <Anchakor> > (flip foldr1 . flip map [3, 4, 5]) (+) (+1)
10:25:07 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = a0 -> a0
10:25:17 <Anchakor> wtf
10:25:24 <quchen> ski: I don't know much (read: anything) about logic, so this may be a little hard to explain to me :-)
10:25:26 <`ramses> mauke: oops :)
10:25:33 <ski> quchen : how it relates to RAA, or how it relates to `_|_' ?
10:25:51 <quchen> RAA?
10:25:58 <ski> Reductio Ad Absurdum
10:26:02 <Anchakor> I don't understand
10:26:09 <quchen> Ah. Well, start with RAA then.
10:26:20 <Anchakor> @pl \x -> flip foldr1 (map x [3,4,5])
10:26:20 <lambdabot> flip foldr1 . flip map [3, 4, 5]
10:26:21 <quchen> I also don't understand the bottom part, but let's postpone that ;-)
10:26:26 <Anchakor> why this doesn't work?
10:26:32 <ski> quchen : if you know `A \/ Not A', you can prove `Not (Not A) -> A' (which is basically RAA)
10:26:38 <mauke> Anchakor: what do you mean by "doesn't work"?
10:26:52 <Anchakor> (\x -> flip foldr1 (map x [3,4,5])) (+1) (+)
10:26:56 <Anchakor> > (\x -> flip foldr1 (map x [3,4,5])) (+1) (+)
10:26:58 <lambdabot>   15
10:27:04 <ski> quchen : if you know `Not (Not A) -> A' (for any `A'), you can prove `A \/ Not A' (for any `A')
10:27:15 <Anchakor> > (flip foldr1 . flip map [3, 4, 5]) (+1) (+)
10:27:16 <lambdabot>   15
10:27:28 <Anchakor> oh damn, now it works
10:27:41 <quchen> ski: So Not (Not A) <=> A \/ Not A
10:27:52 <ski> not quite
10:28:09 <quchen> Ah, the quantifiers
10:28:10 <glguy> Anchakor: There are probably easier ways to write unreadable code :-p
10:28:10 <ski> as *general* principles (holding for *every* `A'), they are equivalent
10:28:42 <ski> for a particular `A', you only get the `(A \/ Not A) -> (Not (Not A) -> A)' direction
10:28:45 <Anchakor> glguy: I don't need this for a real code, but to pass the test of a lunatic teacher
10:28:51 <hpaste> danr pasted “Two vars is not two vars” at http://hpaste.org/80546
10:28:54 <ski> @djinn Either a (Not a) -> (Not (Not a) -> a)
10:28:54 <lambdabot> f a b =
10:28:54 <lambdabot>     case a of
10:28:54 <lambdabot>     Left c -> c
10:28:54 <lambdabot>     Right d -> void (b d)
10:29:03 <ski> @djinn (Not (Not a) -> a) -> Either a (Not a)
10:29:03 <lambdabot> -- f cannot be realized.
10:29:28 <Jafet> @djinn (forall a. Not (Not a) -> a) -> Either a (Not a)
10:29:28 <lambdabot> -- f cannot be realized.
10:29:44 <ski> `djinn' doesn't understand higher-rank types
10:29:44 <Lethalman> :t void
10:29:45 <lambdabot> Functor f => f a -> f ()
10:29:58 <ski> lambdabot : in `djinn', `void :: Void -> a'
10:30:04 <ski> Lethalman ^
10:30:05 <quchen> Ah, I see. I thought you omitted the quantifiers in the first line. So "A \/ Not A  ==>  Not (Not A) -> A", and "Exists A : Not (Not A) -> A => A \/ Not A"
10:30:10 <Lethalman> ok
10:30:11 <ski> and `type Not a = a -> Void'
10:31:08 <ski> quchen : i'm not sure if you mean `(Exists A : ...) => ...' or `Exists A : (... => ...)'
10:31:19 <quchen> ski: Neither am I
10:31:35 <quchen> Anyway, flipping the "=>" requires additional constraints.
10:31:43 <ski> for the latter, it's provable constructively
10:32:20 <ski> for the former, it's not clear how you're quantifying the `A' in `A \/ Not A'
10:34:17 <ski> quchen : anyway, if we're quantifying over a finite domain/type, and know how to decide the proposition for each value in the domain, then we can decide the quantified proposition
10:34:29 <mebaran151> I have a type signature (from http-conduit) that references a huge number of typeclasses.  I would like to simply the type signature by finding the actual concrete type that satisifies all the constraints to make my code clear.  What's the best way of finding out what type the type variable is taking in practice?
10:34:41 <Anchakor> btw does ghci have the @pl command too?
10:34:58 <ski> quchen : e.g. `forall x : {0,1,2}. P(x)' and `exists x : {0,1,2}. P(x)' are both decidable, if `P(x)' is decidable for any `x' in `{0,1,2}'
10:35:20 <Jafet> No, concealed carry is not legal everywhere.
10:35:21 <mebaran151> (Control.Failure.Failure
10:35:22 <mebaran151>      http-conduit-1.8.6.1:Network.HTTP.Conduit.Types.HttpException m,
10:35:22 <mebaran151>    Control.Monad.Trans.Resource.MonadResource m,
10:35:22 <mebaran151>    Control.Monad.Trans.Control.MonadBaseControl IO m) << how can I figure out what m is?
10:35:56 <quchen> Anchakor: No, all the @ stuff is Lambdabot.
10:35:59 <ski> quchen : however, when we switch to an infinite domain, like `forall x : {0,1,2,...}. P(x)' and `exists x : {0,1,2,...}. P(x)', there's no reason why these should be dedicable, even if `P(x)' is for every `x'
10:36:12 <ski> Anchakor : iirc, there's some way to get lambdabot in GHCi
10:36:33 <quchen> You can install Lambdabot locally though, see http://www.haskell.org/haskellwiki/Lambdabot
10:37:22 <applicative> Anchakor: it is easier to install @pl
10:37:30 <ski> quchen : writing `{0,1,2,...}' as `|N', an infinite sequence/stream of `A's can be represented as a function of type `|N -> A'
10:38:02 <ski> quchen : and two such functions (iow infinite sequences) `f' and `g' are equal iff `forall i : |N. f(i) = g(i)'
10:38:30 <quchen> Alright
10:39:21 * Jafet hands out the ℕs
10:39:22 <applicative> Anchakor: http://hackage.haskell.org/package/pointfree . cabal install pointfree then put a line :def pf \str -> return $ ":! $HOME/.cabal/bin/pointfree \"" ++ str ++ "\"" in your .ghci file
10:39:31 <ski> but since we have no reason to expect to be able to decide `forall i : |N. f(i) = g(i)' generally (for arbitrary `f' and 'g')
10:39:44 <ski> we have no reason to expect to be able to decide `f = g'
10:39:58 <ski> and so `f = g \/ Not (f = g)' can't be expected to hold in this case
10:40:24 <ski> and so `A \/ Not A' can't be expected to hold generally
10:40:26 <ski> quchen : ok ?
10:40:29 <quchen> OK!
10:40:48 <applicative> oh  Anchanor left after tab completion.  ...
10:41:12 <ski> (is that an "ok, i see", or an "ok, ok, this is too much for me to handle atm" ? ;)
10:41:20 <quchen> OK I understand
10:41:28 <quchen> It's a fairly easy example after all :-)
10:41:48 <ski> for me yes, i don't know your background
10:43:47 <ski> quchen : anyway, knowing whether an `Integer' will compute to an actual number, or just remain as `_|_' is similar to knowing whether `exists n : |N. P(n)' will turn out to be true for some `n', or will remain being false for all the `n's you've checked so far
10:44:33 <ski> (e.g. `P(n)' could state that "`n' is an odd perfect number")
10:45:13 <quchen> ski: I'm a theoretical physicist, so I'm not easily scared by math, however logic isn't my primary research subject.
10:46:03 <basdirks> I read this as "so I'm not easily scared by meth" :[
10:46:21 <Jafet> That's applied chemistry, not theoretical physics
10:46:30 <byorgey> those theoretical physicists and their meth
10:46:48 <quchen> ski: I guess it makes sense for undecidable or not-yet-proven theorems then
10:46:51 <Jafet> Little known fact: that's what the M in M-theory stands for
10:47:14 <quchen> Is there some notion of this? Say you get ternary or quar...tiary logic, with True/False/Dunno/Maybe?
10:47:19 <basdirks> "space and time are relative"
10:48:03 <krakrjak> True/FAlse/Dunno/Maybe/Both/Guessing/I should know this shouldn't I/Are you sure you want to know
10:48:04 <ski> quchen : you'd need an infinite number of "truth values", i think
10:49:15 <quchen> basdirks: If you're able to think in d dimensions, meth is lame as it restricts you to wobbly n = 3. I only take meth sometimes to get away from serious drugs
10:49:49 <quchen> Such as the tangent bundle of the cotangent bundle, that stuff is nasty ;-)
10:50:27 <quchen> ski: OK, so I now think that removing the excluded middle is a useful thing to have in some cases.
10:50:56 <quchen> Is our initial seq problem still in there somewhere?
10:51:18 <merijn> quchen: Well, you have things like paraconsistent logic (which is basically ternary logic) and temporal logic where the truth value of something depends on "when"
10:51:18 <ski> quchen : "How many is two?" at <http://math.andrej.com/2005/05/16/how-many-is-two/> and "Intuitionistic mathematics for physics" <http://math.andrej.com/2008/08/13/intuitionistic-mathematics-for-physics/> by Andrej Bauer might perhaps be interesting
10:51:46 <quchen> Love the title of the first one :D
10:52:05 <merijn> Well, paraconsistent logic is more a group of logics, but ternary logic would be one of them. Not sure whether *all* paraconsistent logics are ternary
10:53:44 <ski> isn't "ternary" more of a description of a truth-value semantics for the logic ?
10:54:44 <ski> quchen : re `seq', i'd want some way to reason about `_|_' that gives us the same result for `seq', but which doesn't depend on `forall x. x = _|_ \/ Not (x = _|_)'
10:55:05 <merijn> ski: I'm talking about stuff I have only casual familiarity with, so I'm trying to not be to specific, so I can pretend to not be wrong when I inevitably am
10:57:13 <gwern> @quote
10:57:14 <lambdabot> Zao says: [on the haskellmode-emacs trac being full of spam] M-x trac-spam-cleanup-mode?
10:59:55 <ski> merijn : paraconsistent logic is a group of logics, yes
11:00:57 <nicoo> ski: What is paraconsistent logic ?
11:01:19 <alistair> So, as a hacker who learned javascript, then php, then python by reverse-engineering things, Haskell looks way over my head.
11:01:38 <alistair> But I have heard enough about it that I'm curious
11:01:39 <monochrom> paraconsisent logic seems to mean that some inconsistencies can be tolerated
11:02:28 <byorgey> alistair: Haskell *is* way over your head.  But by learning it you can raise the level of your head. =)
11:02:32 <krakrjak> alistair: you can do it, just remeber you don't need those silly variable decorators and that if statements are for chumps and you'll do fine.
11:02:37 <ski> nicoo : <http://plato.stanford.edu/entries/logic-paraconsistent/>
11:02:41 <nicoo> ski: NVM, gone to WP
11:02:44 <nicoo> Ok, thx
11:03:27 <alistair> It really looks like a language designed for people with post-grad compsci degrees. Yet... something draws me to it.
11:03:31 <Jafet> alistair: check that your head isn't up the wrong place
11:03:38 <Jafet> It happens sometimes
11:03:47 <quchen> alistair: What makes Haskell fun is learning the things about it you don't actually need. It's a fine programming language without knowing many things, but learning about these things makes it awesome. :-D
11:03:51 <ski> nicoo : <http://ncatlab.org/nlab/show/paraconsistent+logic> might also be fun
11:04:27 <nicoo> alistair: You don't need knowledge of funky algebra to understand and write Haskell code ;)
11:04:46 <alistair> Ok, that is a solid reason right there
11:04:57 <quchen> alistair: Ever tried reading the source code of PHP to get a better understanding of something? No? Thought so. In Haskell you can a) do that and b) it's fun and c) you learn a lot. You can still decide not to do it.
11:05:02 * ski . o O ( "Everyone knows that debugging is twice as hard as writing a program in the first place. So if you're as clever as you can be when you write it, how will you ever debug it?" <http://www.linusakesson.net/programming/kernighans-lever/index.php> )
11:05:23 <monochrom> haskell is not designed for people with post-grad compsci degrees
11:05:35 <chreekat> When trying to 'cabal install haskellnet', I get the following: "Ambiguous module name `Prelude': ... found in multiple packages: base haskell98-2.0.0.1"
11:05:39 <shachaf> ski: Currently I'm not even clever enough to write the program I'm writing, let alone debug it.
11:05:58 <byorgey> chreekat: looks like haskellnet has not been updated to work with more recent versions of base/ghc
11:05:59 <alistair> Interestingly, I went to university at Simon Fraser and had no idea that there was any development going on there.
11:06:06 <ski> shachaf : the thesis of that post might be different from what you originally would think
11:06:24 <chreekat> byorgey: Indeed it looks a bit crufty. Is there any quick workaround?
11:06:47 <glguy> shachaf: Then you probably won't have to debug it :-D
11:06:51 <byorgey> chreekat: the first step is to remove 'haskell98' from the build-depends list in the .cabal file
11:07:03 <byorgey> chreekat: that might just do it, or there may then be additional errors to fix
11:07:22 <byorgey> chreekat: e.g. it might be using old-style imports like 'import List' which would have to be changed to 'import Data.List'
11:07:30 <alistair> My degree was Archaeology in 1988 though - long before I wanted to program
11:07:39 <srruby> how do I extract the "right" part of either ? Do I have to use "case" ?
11:07:56 <ski> srruby : elaborate ?
11:08:13 <monochrom> eh? there is a recent HaskellNet version. 0.3.1, uploaded January 8. does it help you?
11:08:33 <chreekat> monochrom: Oh! I saw the updated version but didn't thing to do a cabal update. Hang on
11:08:47 <monochrom> it no longer asks for haskell98
11:08:55 <ski> > map (either id show) [Left "oops",42]
11:08:57 <lambdabot>   No instance for (GHC.Num.Num
11:08:57 <lambdabot>                     (Data.Either.Either GHC.Ba...
11:08:57 <chreekat> That _did_ confuse me a bit, seeing the new upload and still having issues
11:09:02 <ski> > map (either id show) [Left "oops",Right 42]
11:09:03 <lambdabot>   ["oops","42"]
11:09:41 <srruby> parse cell "" "9 20 "   ---> Right (Cell {segments = [], cellLength = 9.0})
11:10:22 <srruby> calling parse returns Either a parse result of a parse error
11:10:24 <monochrom> yes srruby use case or other pattern-matching things
11:10:44 <srruby> what other pattern matching tool can I use?
11:10:59 <monochrom> function definition
11:11:04 <glguy> :t either
11:11:05 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
11:11:42 <chreekat> Yep, latest version of HaskellNet installs fine
11:11:45 <chreekat> Good timing, I guess
11:11:48 <monochrom> \∩/
11:12:21 <monochrom> have you all seen my continuation parsec style? http://hpaste.org/80484
11:13:18 <ski>   case cell "" "9 20 " of
11:13:23 <ski>     Left  err  -> ..err..
11:13:32 <ski>     Right cell -> ..cell..
11:13:40 <ski> srruby : perhaps something like that
11:14:39 <srruby> Thanks. That is what I've been using but I wasn't sure it is idiomatic. In ghci I was looking for a way to easily unwrap it.
11:15:03 <ski> you could try `Right cell <- cell "" "9 20 "' in GHCi
11:15:24 <ski> er, probably using 'Right blah' instead of `Right cell'
11:15:50 <ski> .. and also inserting an actual call to `parse'
11:15:56 <monochrom> then I will tell you about the dark side of pattern matching. "let Right x = blah ..." and "Right x <- blah" (if in do-block)
11:16:44 <prophile> alistair: good name
11:16:46 <ski> > [x | Right x <- [88,Left "oops",56]]
11:16:47 <lambdabot>   No instance for (GHC.Num.Num
11:16:47 <lambdabot>                     (Data.Either.Either [GHC.T...
11:16:55 <srruby> Perfect!. Just what I wanted. I understand that you wouldn't want this in production code.
11:16:56 <ski> > [x | Right x <- [Right 88,Left "oops",Right 56]]
11:16:58 <lambdabot>   [88,56]
11:17:06 <prophile> alistair: i'm disappointed you're actually active, i wanted to claim it :<
11:17:08 <monochrom> in fact, you don't need "let". you can write "Right x = blah" at the top level, too
11:17:31 <ski> prophile : your given name is "Alistair" ?
11:17:38 <prophile> indeed
11:18:00 <pheaver> i started using GHC.Event.registerTimeout (http://hackage.haskell.org/packages/archive/base/4.4.0.0/doc/html/GHC-Event.html). i'm observing that if the action you provide to registerTimeout blocks, then the entire application blocks. is that true? is it because i'm using getSystemEventManager, when I really should use GHC.Event.new to get a new event manager?
11:18:32 <ski> prophile : hm, i suspect the current alistair isn't the one who registered it
11:18:44 <croikle> > rights [Right 88,Left "oops",Right 56]
11:18:46 <lambdabot>   [88,56]
11:18:59 <ski> prophile : you could probably ask #freenode to have the current registration dropped, seeing as noone has identified to it, for some time
11:19:06 <aristid> "know your rights"</bad pun>
11:19:28 <dotnetisyourpet> sorry for interrupt.. I am slowly getting mad about this: how can I [[String]] -> [[Maybe String]]? I know all values are Just Strings, but maybe string is needed for sExecuteMany in dbmc. Anyone knowledgable about this? thanks
11:19:38 <mauke> dotnetisyourpet: map
11:19:40 <issimus> hi all question: Data.Vector.Unboxed.modify says: "Apply a destructive operation to a vector. The operation will be performed in place if it is safe to do so and will modify a copy of the vector otherwise." How do I know if an operation will be performed in place? Looking at the source it seems clone is always called first. Does anybody know off the top of their head? or should I just read the sou
11:19:59 <mauke> issimus: why do you need to know?
11:20:08 <ski> dotnetisyourpet : `map (map Just)' perhaps ?
11:20:25 <ski> mauke : preflex is retired, yes ?
11:20:39 <mauke> it's still sleeping
11:20:41 <yitz> ski: often written (map.map) Just
11:20:48 <mauke> and I'm currently rebuilding ghc (sigh)
11:20:49 <ski> yitz : *nod*
11:21:25 <dotnetisyourpet> ski: yitz: could I make a function like so: f a = (map.map) Just a ?
11:21:42 <ski> dotnetisyourpet : yes, you could even define it as `f = (map . map) Just'
11:21:53 <byorgey> monochrom: neat!
11:21:55 <issimus> mauke: I'm using a vector as a histogram, so i'd like to write a function like, "increment this index", currently I'm using unsafeAccum with all indexes, and athrowaway parameter in the snd place of the tuple.
11:22:04 <dotnetisyourpet> ski: thats great, thank you
11:22:05 <byorgey> monochrom: (re: continuation parsec style)
11:22:18 <glguy> issimus: The library is able to optimize (clone (new p) = p)
11:22:26 <issimus> mauke: the other option is to fold over the list of indices and call modify, but i dont want to copy a vector n-times
11:23:34 <issimus> mauke: i like the second option better because i'm not constructing data for unsafeAccum only to ignore it later
11:23:45 <mauke> why are you using a vector?
11:24:37 <roadfish> @hoogle tdfa
11:24:37 <lambdabot> package regex-tdfa
11:24:37 <lambdabot> package regex-tdfa-unittest
11:24:37 <lambdabot> package regex-tdfa-utf8
11:25:20 <issimus> mauke: my data values are near continguous, so instead of using a Data.Map and doing update, i'm using a vector and incrementing, this should make update O(1) instead of O(log n) right?
11:25:38 <mauke> issimus: what's the difference?
11:25:59 <ClaudiusMaximus> @tell hiptobecubic https://gitorious.org/maximus/butterflies works on my old laptop now (OpenGL 2.1 Mesa 8.0.5 Gallium 0.4 ATI RV350), needed to patch OpenGLRaw21 though (just a dependency upper version bound bump)
11:25:59 <lambdabot> Consider it noted.
11:27:41 <issimus> mauke: like in all things, i should just profile to prove one method is better, but my intuition is using the vector would be faster, but i was unsure about the performance of a sequence of modify calls
11:29:07 <quchen> issimus: The problem with vectors is that you always have to create an entirely new one for updates (you can combine updates with ST though, so updating many things in one go is also just one vector update). On the other hand, updating a Map is O(log(n)), which is small for most practical purposes.
11:29:30 <quchen> So the difference between O(1) and O(log(n)) may not be very large.
11:30:09 <quchen> Also, copying a vector is O(n) in space and time, so that one's even worse if you're doing a lot of constructing. If you're mainly reading, Vector could give you a performance advantage.
11:30:23 <quchen> In any case, profiling seems to be the right idea
11:33:34 <issimus> quchen: ive got a 100k's of elements and i'm folding over like a 1M, so i dont want to copy the vector for each update, i was just thrown by the documentation for modify
11:34:46 <k0ral> Hello
11:34:48 <quchen> If you can do all the writing in one go, just use the ST monad to construct the vector
11:35:11 <quchen> That'll be destructive updates, terminated by a freeze to give you a nice Haskell array
11:37:08 <issimus> quchen: ah ok, yes i can, right now i'm starting with vector then doing the updates in one go, so if i start with mvector, i can do the work and get the vector out when i'm done, thanks
11:37:44 <k0ral> I have f :: (Monad1 m, Monad2 m, ..., MonadN m) => Type1 -> ... -> m TypeP; is there a way to define MonadX such that I could write f :: (MonadX m) => Type1 -> ... -> m TypeP ?
11:38:39 <byorgey> k0ral: if you have GHC 7.4+ and turn on -XConstraintKinds, you can simply write   type MonadX m = (Monad1 m, ..., MonadN m)
11:38:40 <k0ral> (getting tired of enumerating monads all over the place...)
11:39:33 <k0ral> byorgey: allright, and how bad is that extension, as I assume any GHC extension has to be bad somehow for not being activated by default ?
11:40:16 <k0ral> (I'm reading about ConstraintKinds but would also like your opinion)
11:41:29 <glguy> k0ral: The better strategy in general is to newtype wrap your monad transformer stack and create your own set of operations you support written in terms of the Monad* operations
11:41:56 <glguy> k0ral: The Monad* family of classes is often best just used to automatically lift operations through a stack of transformers, not to expose to your program
11:43:31 <k0ral> glguy: the thing is: I don't want the monads order in the stack to matter, that's (notably) why I work with Monad* classes
11:44:36 <k0ral> glguy: and I certainly don't want to have lifts all over the place
11:44:46 <glguy> k0ral: then you misunderstood me
11:45:14 <glguy> you use the low-level Monad* operations to implement high-level operations specific to your monad
11:45:36 <glguy> rather than exposing the low-level Monad* operations
11:47:08 <k0ral> why not exposing the low-level Monad* operations ? it allows users to potentially roll their own monads, provided they fit into the constraints
11:48:44 <byorgey> k0ral: your assumption is wrong.  No GHC extensions are enabled by default, whether good or bad.
11:48:57 <glguy> k0ral: I don't know what you're trying to build, so maybe a big collection of exposed Monad* classes makes sense
11:48:57 <byorgey> what you get by default is (something very close to) the Haskell2010 standard
11:49:19 <k0ral> byorgey: I phrased it bad, I meant: if it's not Haskell98 compliant, there must be a reason
11:49:20 <byorgey> k0ral: ConstraintKinds is a fairly simple and uncontroversial extension, IMO.
11:49:45 <byorgey> k0ral: that assumption is also wrong.  Or at least, it's not the sort of reasons you might think.
11:50:10 <byorgey> often the reason is simply "no one has done the work to propose it as an official part of the standard"
11:50:12 <monochrom> -fglasgow-exts enables all ghc extensions by default
11:50:48 <monochrom> I am joking. adding a flag does not count as "default" :)
11:50:52 <k0ral> byorgey: well, I read some extensions just make the compiler's life harder, but still give perfectly valid code
11:51:09 <roadfish> if a package is available through the distro (such as apt), then is in better to install with cabal or install with apt-get?
11:51:32 <monochrom> but more seriously, don't look too hard for "reason" in human decisions
11:51:44 <monochrom> especially collective human decisions
11:51:45 <shachaf> monochrom: -fglasgow-exts enables all GHC extensions that existed before -fglasgow-exts became deprecated.
11:51:49 <byorgey> roadfish: it doesn't matter.  what does matter is that you should probably not mix-and-match.
11:51:52 <dcoutts> roadfish: I'd suggest to start with your distro's packages and then install extra things via cabal (locally per-user)
11:52:30 <k0ral> glguy: it's a program that can be dynamically reconfigured in Haskell
11:52:54 <scooty-puff> i noticed in hoopl that there is data O, data C, and data Shape ex, which using DataKinds would look like data S = O | C; data Shape (ex :: S) where ...; is it possible to lump S and Shape into a single data type?
11:52:59 <scooty-puff> e.g.: data Bool (bool :: Bool) where True :: Bool True; False :: Bool False
11:53:25 <dcoutts> roadfish: the mix-n-match issue byorgey refers to is that if you upgrade Haskell libraries via the distro then it breaks other libraries you installed via cabal
11:53:40 <ClaudiusMaximus> design question... i made a type-class[0] for 2D geometry on a surface, with instances for Euclidean plane and hyperbolic plane (using Poincaré half-plane model) - but now I want to add toruses of different shapes with shape determined at runtime, and i don't fancy lifting shape to type-level..   [0] https://gitorious.org/maximus/butterflies/blobs/master/Geometry/Class.hs
11:54:11 <ClaudiusMaximus> so i'm thinking of having the surface be a record of functions
11:54:15 <roadfish> I'm guessing that the biggest difference is that cabal has the newest packages. But I noticed that you have to manually install dependencies with cabal.
11:54:23 <dcoutts> roadfish: some distros update them only when they update ghc, which is fine. Ones that update frequently will leave you with that problem (e.g. arch).
11:54:31 <monochrom> roadfish, you need to see my http://www.vex.net/~trebla/haskell/sicp.xhtml#unsafeInterleave
11:54:38 <monochrom> in fact, see the whole thing
11:54:56 <dcoutts> roadfish: you have to manually install some dependencies, like deps on C libs
11:54:57 <ClaudiusMaximus> should i worry about type safety for that?  i might accidentally use a geodesic from one torus on a differently shaped one, or something
11:55:56 <parcs> scooty-puff: i've wondered that too. i don't think it's currently possible
11:56:19 <roadfish> on a different theme, I am trying out profiling. Going from Prelude to was a big win ...
11:56:36 <srhb> roadfish: To what?
11:56:40 <roadfish> but going from Text.Regex.Posix to Text.Regex.TDFA was a big loss
11:56:44 <srhb> Ah, to Text.
11:56:55 <byorgey> ClaudiusMaximus: it seems your question amounts to "tracking property X at the type level is too much effort.  So I won't do that.  Should I be worried about confusing things with different property X?"
11:57:14 <roadfish> Posix 0.032s but TDFA 3.5s
11:57:31 <roadfish> I guessing that the expression is getting "recompiled" each time with TDFA
11:58:04 <ClaudiusMaximus> byorgey: mm, i suppose so...
11:58:23 <roadfish> I think I missed out point from above ... I went from Prelude to Data.ByteString.Char8
11:58:26 <roadfish> that was the big win
11:58:29 <ClaudiusMaximus> byorgey: but maybe i could use the ST trick somehow?
11:59:02 <ClaudiusMaximus> byorgey: so i don't have to encode real numbers as types, but i can stop mixing different surfaces?
11:59:05 <byorgey> ClaudiusMaximus: I guess you can use the ST trick if you never want to be able to use two tori with different shapes in the same code
11:59:27 <byorgey> though I'm not exactly sure how that would work in practice
11:59:30 <roadfish> anyway, I read somewhere that the Regex pattern is supposed to be automatically compiled once and then memoized.
12:00:10 <monochrom> that depends mainly on your coding
12:00:38 <eacameron> does ghc use static linking by default so my executable has no dynamic dependencies?
12:00:59 <monochrom> both. static link haskell libs. dynamic link c libs
12:01:13 <monochrom> use the ldd command to find out more
12:01:13 <eacameron> that's the default?
12:01:17 <monochrom> yes
12:01:20 <monochrom> use the ldd command to find out more
12:01:25 <eacameron> ok thanks
12:02:38 <monochrom> to dynamic link haskell libs and static link c libs: -dynamic -optl-static. may also need -optl-pthread
12:04:20 <monochrom> wait, I haven't tried that. and there may be a reason it doesn't do what I claim
12:05:00 <monochrom> I was making a joke. who would want to dynamic link haskell libs and static link c libs? :)
12:05:02 <navaati> hi
12:05:33 <beaky> hello
12:05:44 <beaky> on archlinux, should I install haskell-platform from the AUR?
12:06:41 <derdon> beaky: yes
12:06:48 <ClaudiusMaximus> byorgey: do you think something like this would work?  torus :: Double {- r0 -} -> Double {- r1 -} -> (forall s. Surface s -> r) -> r  with  data Surface s = Surface{ geodesic :: Point s -> Point s -> Geodesic s, ... }
12:08:34 <navaati> what is the best structure that 1/ can store values in an ordered way (so, not Set) 2/ enables to insert and delete them efficiently 3/ doesn't require them to be Ord instances ?
12:08:41 <ClaudiusMaximus> maybe i shouldn't care so much, i doubt anyone is going to hack on this code apart from me :)
12:09:20 <navaati> ah, and 4/ enables to change their order in the list efficiently
12:12:30 <osfameron> navaati: something like a fingertree?
12:14:28 <navaati> osfameron: ah, maybe. But by "structure" i was more thinking about an existing structure in haskell than about an abstract kind of structure that i could implement by myself ^^
12:14:48 <osfameron> navaati: there is http://hackage.haskell.org/packages/archive/fingertree/0.0.1.1/doc/html/Data-FingerTree.html
12:15:06 <osfameron> I have no idea if that's a good package
12:15:43 <scooty-puff> parcs: bah, that sucks
12:15:57 <byorgey> it is, but instead of using fingertree directly navaati probably wants Data.Sequence from containers
12:16:01 <osfameron> good lord.  the haddock even has an Excample in it!
12:16:08 <osfameron> aha
12:16:32 <osfameron> the fingertree haddock mentioned Data.Sequence, but helpfully didn't link to it
12:16:38 <navaati> fingertree doesn't seem to be usable out of the box
12:16:42 <byorgey> yeah, I noticed that =P
12:17:00 <navaati> ah ! i always forget about Data.Sequence !
12:17:10 <navaati> might be the right thing, thanks byorgey
12:17:32 <byorgey> ClaudiusMaximus: no idea if that will work, try it and see I guess =)
12:18:51 <navaati> ClaudiusMaximus: nooo, don't enter in the church of static corectness enforcment ! If you do, you'll code ten time slower, and you'll love it :D
12:20:14 <parcs> > 15171244032 `div` 1024^2
12:20:16 <lambdabot>   14468
12:23:40 <madjestic> how can I convert a Fractional to an Int?
12:24:06 <croikle> round, floor, ceiling
12:24:44 <Taneb> croikle, they are all for RealFrac
12:25:06 <monochrom> @type floor
12:25:08 <lambdabot> (Integral b, RealFrac a) => a -> b
12:25:16 <Taneb> madjestic, if it's a RealFrac as well (a lot of them are, although Rational for instance isn't), you can do what croikle said
12:25:27 <croikle> hm, okay
12:25:27 <monochrom> oh, Fractional! such as complex number?
12:25:59 <monochrom> @type Rational
12:26:00 <lambdabot> Not in scope: data constructor `Rational'
12:26:03 <Taneb> Strictly speaking, there is no way to convert an arbitrary Fractional to an Int
12:26:22 <monochrom> @type 1%3
12:26:23 <lambdabot>     Not in scope: `%'
12:26:23 <lambdabot>     Perhaps you meant `R.%' (imported from Data.Ratio)
12:26:39 <monochrom> > floor (1 R.% 3)
12:26:40 <lambdabot>   0
12:26:45 <madjestic> round realToFrac 5  gives me an error
12:26:45 <Taneb> You've got fromInteger and fromRational as the only ones that change types
12:26:56 <croikle> I see why you'd have a hard time turning a Complex into an Int
12:26:57 <Taneb> And those are both the wrong way round
12:27:05 <monochrom> > round (realToFrac 5)
12:27:06 <lambdabot>   5
12:27:53 <quchen> Does anyone here have experience with using the RasPi (or similar) to do analog stuff with Haskell? Could you point me in the right direction on how to make a LED light up via Haskell?
12:28:18 <madjestic> duh.  Thanks croikle
12:28:49 <madjestic> Thanks, Taneb
12:28:52 <Taneb> :)
12:29:12 <osfameron> quchen: sounds like fun.  I can't get my raspi to boot up even ;-)
12:29:14 <Taneb> madjestic, basically, work out which Fractional you're going for
12:30:02 <osfameron> quchen: you've read http://www.haskell.org/haskellwiki/Raspberry_Pi ?
12:30:34 <quchen> osfameron: I've used ASM on an Atmel microcontroller roughly 5 hours in my life. Recently, I got the idea to automate a garden with it.
12:30:50 <osfameron> that seems to be more about getting haskell stuff to run, not so much about the libraries to speak to the gpio pins
12:31:02 <quchen> I don't think the problem is making Haskell run on the RasPi. It's more "how do I get Haskell to put 5V on that pin"
12:31:13 <osfameron> yeah
12:31:16 <quchen> Yeah, I'm more interested in the pin problem right now
12:31:36 <monochrom> FFi to a C lib that turns on the pin?
12:32:03 <S11001001> haskell can't apply voltage, it can only produce heat
12:32:16 <quchen> monochrom: That would be a working solution in case I can't find something haskelly
12:32:41 <osfameron> doesn't appear to be a raspi library on hackage
12:32:54 <quchen> At least it's not called anything like that
12:33:01 <monochrom> someone could add a few primitive operations to GHC that talks to the hardware
12:34:12 <osfameron> see what the python bindings do and port that?
12:34:17 <osfameron> they probably call a C library
12:35:15 <quchen> Yeah, that's what Python does: being an elaborate C linker
12:35:24 <monochrom> haha
12:35:37 <Taneb> @faq Can Haskell be an elaborate C linker?
12:35:37 <lambdabot> The answer is: Yes! Haskell can do that.
12:35:43 <quchen> :-)
12:36:04 <quchen> @faw Can Haskell not do that?
12:36:04 <lambdabot> The answer is: Yes! Haskell can do that.
12:36:51 <beaky> it is very easy to invoke haskell from C
12:37:42 <quchen> beaky: Wait wait waaaait. I don't plan on solving my problem. I plan on solving my problem with Haskell.
12:37:52 <quchen> Calling Haskell from C is not an option.
12:38:04 <osfameron> quchen: it looks like it writes and reads /sys/class/gpio/*
12:38:20 <osfameron> so you can probably port the concepts in http://pypi.python.org/pypi/RPi.GPIO/0.2.0 to haskell without having to call C
12:38:58 <quchen> If C is involved, it'll be a second class library that sits in the corner until invoked :D
12:39:27 <monochrom> oh! /sys stuff, that's much better. I forgot they exists :)
12:39:47 <osfameron> I didn't know it did it like that.  It's quite cute
12:40:00 * osfameron looks forward to quchen's lib on hackage!
12:40:19 <monochrom> afterall, linux for x86 works like that too
12:42:18 <osfameron> quchen: not that I want to discourage you from playing with this stuff with haskell, but if you just wanted to Get Shit Done, arduino might well be a better platform for garden management
12:44:25 <quchen> osfameron: I know that. But I want to do it with Haskell.
12:44:35 <osfameron> cool!
12:44:36 <quchen> I can't *stand* other languages anymore. ;-(
12:44:40 <osfameron> hehe
12:44:49 <quchen> In any case, thanks so much for the input, I gotta go now
12:44:55 <quchen> Let's see where the project goes
12:45:06 <quchen> (This is just brainstorming phase, nothing's even remotely planned)
12:45:19 <basdirks> ah the phase where life's still good
12:45:41 <appamatto> How can do's be nested?
12:45:42 <basdirks> nono I joke, good luck ;]
12:45:49 <appamatto> I'm trying to work with Maybe inside another monad
12:46:12 <`ramses> appamatto: nested monads? sounds like you need a transformer
12:46:15 <hpaste> benmachine pasted “I feel like this is interesting but I'm not sure how” at http://hpaste.org/80552
12:47:07 <`ramses> :t runMaybeT
12:47:08 <lambdabot> Not in scope: `runMaybeT'
12:47:29 <`ramses> :t Control.Monad.Trans.Maybe.runMaybeT
12:47:30 <lambdabot> Control.Monad.Trans.Maybe.MaybeT m a -> m (Maybe a)
12:47:44 <`ramses> appamatto: ^^ that does what you want
12:48:45 <beaky> :t runIO
12:48:46 <lambdabot> Not in scope: `runIO'
12:48:48 <croikle> :t Data.Traversable.sequence
12:48:50 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
12:49:08 <croikle> with Maybe for t
12:50:54 <k0ral> I'm reading RWH and I can see the following example: "newtype MyApp a = MyA { runA :: ReaderT AppConfig (StateT AppState IO) a } deriving (Monad, MonadIO, MonadReader AppConfig, MonadState AppState)"; how would I do if I wanted to stack several ReaderT, given that it can only be instance of MonadReader once ?
12:51:55 <`ramses> k0ral: the derived MonadReader instance will correspond to the outermost ReaderT I think
12:52:03 <`ramses> to access the others you'll need to use lift
12:52:45 <k0ral> alright, but is there any trick to avoid writing lifts everywhere ?
12:53:05 <`ramses> you only have to do so if you stack multiple monads of the same type
12:53:16 <k0ral> I'm working on a code with 4 stacked readerT, I really don't want to lift . lift . lift
12:53:28 <`ramses> and I'd write helper functions, like askConfig = lift . ask
12:53:35 <`ramses> then you can just use askConfig
12:53:41 <fmap> reflection!
12:53:45 * fmap hides
12:53:52 <k0ral> fmap: is that a joke ?
12:53:59 <k0ral> fmap: if it is, I didn't get it
12:54:09 <roadfish> I can get "profiling libraries" from the distro. But how do you get them otherwise? None of the options in "cabal --help" mentioned building the profiling libraries.
12:54:11 <k0ral> fmap: if it's not... I don't get it anyway
12:54:15 <`ramses> k0ral: then write four ask functions whose names detail what they ask for
12:54:24 <dcoutts> roadfish: see cabal install --help
12:54:32 <k0ral> `ramses: sounds acceptable enough
12:54:40 <parcs> roadfish: cabal install --help
12:54:42 <fmap> k0ral: well, reflection is certainly usable with multiple environments "stacked", but I won't recommend it
12:54:43 <roadfish> ok, thanks
12:54:45 <dcoutts> roadfish: it's there, -p or --enable-library-profiling
12:54:52 <`ramses> k0ral: I'm not expert either though, so maybe there are even better ways
12:54:55 <dcoutts> roadfish: or the equiv in the ~/.cabal/config
12:55:38 <k0ral> next question
12:56:08 <k0ral> I have a lot of functions f :: (MonadReader r m, HasX r, HasY r, ...) => m ()
12:57:07 <k0ral> how to change it's type to make it accept stacked readers instead of a single reader with a stacked type ?
12:57:11 <k0ral> its*
12:57:59 <k0ral> (next question is even trickier :) )
13:00:42 <zomg> haha, my shitty php evaluator I wrote in haskell is merely 8.7 times slower than php itself in a test that calculates a bunch of numbers...
13:00:55 <appamatto> `ramses do you need to use both runMaybeT and MaybeT?
13:01:05 <zomg> (don't ask me why I wrote a php evaluator, I think it was momentary insanity)
13:01:13 <mauke> zomg: ah, but is it semantically correct?
13:01:45 <zomg> As in?
13:01:48 <`ramses> appamatto: MaybeT is the type, runMaybeT is used to "run the computation", i.e. unwrap the newtype
13:02:14 <mauke> zomg: 100% compatible with PHP
13:02:26 <zomg> nah, that would require more than just momentary insanity
13:02:27 <zomg> =)
13:02:43 <roadfish> ok, so .p_hi ... the "p_" means this version is instrumented for profiling.
13:02:59 <`ramses> appamatto: if you have a MaybeT IO a, runMaybeT on a value of that type will give you an IO (Maybe a)
13:03:18 <zomg> It is compatible for the parts that I made it compatible with, at least it pretends to be. Probably has some edge cases even with those where it isn't exactly 1 to 1
13:04:02 <zomg> Maybe I will now write a code generator that generates haskell code from the PHP AST and then compile that with ghc...
13:04:36 <`ramses> appamatto: try this: let m = do {return 3} :: MaybeT [] Int in runMaybeT m
13:05:03 <`ramses> should give [Just 3], but lambdabot hasn't got the MaybeT module imported...
13:05:44 <appamatto> `ramses I think I'm having trouble with lift
13:05:53 <osfameron> http://alenribic.com/posts/2012-08-17-raspberry-pi-in-a-haskell-cloud.html is quite interesting
13:06:05 <`ramses> appamatto: what are you trying to do? you might not need lift
13:06:13 <appamatto> I have something which is IO (Maybe String)
13:06:32 <appamatto> I'm trying to mess with the maybeness of that value inside runMaybeT
13:06:46 <fmap> k0ral: do you have that code with 4 readers available public somewhere?
13:07:17 <`ramses> well, make a type "MaybeT IO String" and make your functions return that instead of the IO (Maybe String)
13:07:27 <`ramses> all your do-blocks should just keep working
13:07:50 <`ramses> and then you can use the runMaybeT to get the IO (Maybe Stirng) out at the end
13:08:09 <`ramses> but I'm not sure whether you need this actually, maybe you should show what you're trying to do
13:08:22 <k0ral> fmap: I'm trying to have it compile so not public yet
13:08:31 <appamatto> I just have an IO function which returns Maybe String
13:08:46 <`ramses> written yourself?
13:08:47 <appamatto> And I'm trying to mess around with that without having a bunch of =<<
13:08:51 <appamatto> No, it's in a library
13:09:05 <k0ral> fmap: for now, I have a single reader on a "stacked object", but I dislike this design that gathers in a single datatype many very different things
13:09:25 <`ramses> appamatto: ahh... sorry, forget the transformer then...
13:09:48 <`ramses> use bind with a function that consists of a do-block then
13:09:54 <k0ral> fmap: that's why I'm trying to split the data types into logical units, and stack a reader layer for each of them
13:10:15 <appamatto> `ramses, ah that makes sense
13:10:37 <k0ral> fmap: the current code is available on hackage: package hbro
13:10:38 <`ramses> appamatto: no, sorry, not bind, fmap rather
13:10:50 <`ramses> then you can just work with the maybe value
13:11:19 <zomg> appamatto: you can use liftM and fmap
13:12:03 <zomg> appamatto: eg. assuming myIO :: IO (Maybe String), you can do liftM (fmap (++ "foo")) myIO
13:13:16 <appamatto> Hmm
13:13:21 <appamatto> Isn't there a way to do this with do?
13:13:53 <`ramses> appamatto: fmap over the IO part with a function (Maybe a -> Maybe b), that function can be written using do then
13:14:16 <`ramses> (liftM == fmap)
13:14:20 <zomg> or, do { maybeSomething <- myIO; return $ fmap (++ "foo") maybeSomething }
13:14:25 <zomg> or something along those lines
13:14:39 <appamatto> Hmm
13:15:03 <appamatto> I see. I thought that MaybeT would make this easier somehow
13:15:55 <latro`a> monad transformers help if your problem matches their >>=
13:15:59 <latro`a> which is often but not always the case
13:16:07 <`ramses> appamatto: it would but you don't have a MaybeT...
13:17:55 <appamatto> Can't I get a MaybeT somehow?
13:20:03 <byorgey> appamatto: MaybeT :: IO (Maybe a) -> MaybeT IO a
13:20:07 <byorgey> does that help?
13:20:13 <`ramses> appamatto: ah, yeah actually, run "MaybeT" on the monad
13:23:40 <appamatto> I see
13:23:45 <appamatto> MaybeT is like lift
13:23:58 <`ramses> no, it's a constructor
13:24:10 <`ramses> lift lifts an action through a transformer stack
13:24:14 <glguy> lift would be (IO a -> MaybeT IO a)
13:26:01 * hackagebot html-kure 0.2 - HTML rewrite engine, using KURE.  http://hackage.haskell.org/package/html-kure-0.2 (AndyGill)
13:26:03 * hackagebot diagrams-qrcode 1.0 - Draw QR codes to SVG, PNG, PDF or PS files.  http://hackage.haskell.org/package/diagrams-qrcode-1.0 (FelipeLessa)
13:26:55 <byorgey> ooh, neat =)
13:27:07 <appamatto> Woot, that finall worked
13:27:08 <danr> can one cabal file install two libraries?
13:27:17 <krakrjak> diagrams-qrcode...  time to go read the docs.
13:27:20 <`ramses> appamatto: runMaybeT $ (do { x <- lift getLine; return x} :: MaybeT IO String) :: IO (Maybe String)
13:27:26 <byorgey> danr: no
13:27:28 <dcoutts> danr: no
13:27:51 <navaati> night
13:27:51 <`ramses> that lifts the getLine action from IO into MaybeT IO
13:28:22 <danr> :(
13:28:27 <dcoutts> danr: we might extend that, but it'll always be only one exposed & registered library (we might add private libs for sharing code within a package)
13:29:05 <dcoutts> danr: what are you trying to do?
13:29:32 <fons> Hi
13:29:32 <danr> dcoutts: I'm just trying to be convenient
13:29:55 <danr> I have one puny little TH function in my library, and that makes all packages I depend on get loaded when compiling
13:30:48 <danr> or maybe TH would load them all anyway? My guess was that it would be related to the package the TH function is defined in
13:30:55 <fons> The bottleneck in a test-generation problem is a subset obtention function
13:31:02 <fons> it works correctly
13:31:09 <fons> but performs horribly bad
13:31:17 <fons> http://stackoverflow.com/questions/14267196/fast-obtention-of-all-the-subsets-of-size-n-in-haskell
13:31:23 <dcoutts> danr: the issue there is that ghc doesn't know that your TH code isn't going to use things from those other packages
13:31:37 <dcoutts> so it conservatively loads them all
13:31:45 <danr> dcoutts: right
13:31:57 <danr> dcoutts: so it wouldn't help to put it in an own library?
13:32:00 <fons> I tried to use an intermediate data structure to avoid the O(log(n)) of insertions
13:32:08 <fons> like a list
13:32:27 <fons> but the cost of reconverting it to a set seems to be too high
13:32:39 <fons> I would appreciate if somebody could have a look at it
13:32:41 <fons> thanks!
13:32:55 <dcoutts> danr: no I don't think so, and it'd be recompiled in the same circumstances, so I don't think it saves anything
13:34:02 <badkins> I'm writing a snippet of code from a dynamic language in Haskell. The dynamic code uses "send" to create a function name at runtime to be called. What are some idiomatic ways to accomplish something similar in Haskell? I'd prefer to not use template Haskell just yet: http://pastie.org/private/th7zlsqjrtob09mixesg
13:34:37 <danr> dcoutts: ok :) thank you for your insights
13:34:44 <dcoutts> np
13:34:48 <badkins> I'm using Haskell records in place of objects, but I'm open to other ways of structuring the data.
13:35:43 <dcoutts> danr: what would be possible is for ghc to be improved so it only loads the packages that are imported by the module using TH, rather than all packages the package being compiled depends on
13:36:10 <dcoutts> danr: that would sometimes let you have your TH code in one module that hardly imports anything
13:36:51 <monochrom> badkins: perhaps Data.Map to associate "31" with a_accessor_31 etc. afterall I'm pretty sure this is how send is implemented, modulo s/map/hash table/
13:37:52 <badkins> monochrom: I'll look at Data.Map. That's basically what I'm doing manually via the case now.
13:38:16 <monochrom> yes, but Data.Map runs faster than case
13:38:43 <badkins> ok
13:39:36 <`ramses> badkins: are all those functions known beforehand or should it be possible to dynamically add them?
13:39:50 <badkins> `ramses: known before
13:42:20 <danr> dcoutts: yeah, that would be nice
13:51:39 <nh2> can I make a "static dynamic library" as an .so that I can use from C/Python? It shall include *all* of my code and dependencies
13:51:50 <nh2> if possible, without recompiling world with -fPIC
13:51:58 <nh2> can that be done?
13:55:36 <ParahSailin> what's performance of random vs randomIO
13:56:21 <Dextr> hi
13:56:22 <c_wraith> randomIO is necessarily slower, since it has to read the StdGen out of an IORef and write it back in.
13:56:47 <c_wraith> ..  With a call to random in the middle
13:57:10 <ParahSailin> ah, thx
13:57:44 <srruby> how do I turn something like [1,4,5,10] into [1,5,10,20]  ?
13:57:59 * merijn waits for the lens example to flood the channel
13:58:01 <simpson> srruby: What's the pattern?
13:58:09 <Dextr> if i have permutation group, e.g. [3, 4, 2, 1, 5], is there any ease way to calculate the inverse ([4, 3, 1, 2, 5])? (that is without using vectors)
13:58:19 <`ramses> merijn++ :)
13:58:19 <Dextr> *easy
13:58:21 <Taneb> > scanl1 (+) [1,4,5,10] [1,5,10,20]
13:58:22 <lambdabot>   The function `GHC.List.scanl1' is applied to three arguments,
13:58:22 <lambdabot>  but its type...
13:58:25 <Taneb> > scanl1 (+) [1,4,5,10]
13:58:26 <lambdabot>   [1,5,10,20]
13:58:34 <simpson> Taneb: Nice eye.
13:58:41 <Taneb> :)
13:59:24 <Dextr> was that for me taneb?
13:59:43 <Taneb> That was for srruby, sorry
13:59:57 <srruby> Thanks Taneb. I had looked at scanl but not scanl1
14:00:14 <Taneb> > scanl (+) 0 [1,4,5,10]
14:00:15 <lambdabot>   [0,1,5,10,20]
14:00:36 <simpson> > tail $ scanl (+) 0 [1,4,5,10]
14:00:37 <lambdabot>   [1,5,10,20]
14:00:45 * simpson is just slow today
14:00:54 <srruby> Thanks.
14:03:08 <`ramses> Dextr: group theory has been a while... why is that the inverse? what representation is this?
14:04:06 <`ramses> Dextr: ah, I see it now :)
14:04:07 <Dextr> the inverse is what leads back to the zero element (12345), the represantion is that 34215 means 12345 -> 34215
14:04:10 <srruby> I should have looked up the signature in hoogle. It had to be (a -> a -> a) -> [a] -> [a]
14:04:52 <srruby> hoogle gave scanl1 as the first answer
14:05:37 <alistair> @prophile sorry
14:05:37 <lambdabot> Unknown command, try @list
14:06:09 <alistair> @list
14:06:09 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:06:26 <S11001001> alistair: lambdabot's scolding you for using twitterspeak :)
14:07:25 <alistair> I see
14:07:31 <alistair> Not sure how to talk at someone then
14:07:36 * ski . o O ( "the IRC convention for addressing someone is \"fred: I ate your beans\", not \"@fred I ate your beans\"" )
14:07:38 <S11001001> alistair: ??
14:07:59 <alistair> Ah, thx
14:08:09 <alistair> ski: thanks
14:08:17 <Taneb> Heh, I started IRCing on a smaller channel that still had lambdabot.
14:08:20 <Taneb> This worked well for me
14:09:38 <glguy> Dextr: This doesn't seem to avoid your vectors concern, but it's short :)
14:09:39 <glguy> > let f xs = elems $ array (1,length xs) (zip xs [1..]) in f [3,4,2,1,5]
14:09:40 <lambdabot>   [4,3,1,2,5]
14:09:54 <Lethalman> anybody used haskell for 3d here? what library did you use?
14:10:07 <Dextr> what does $ do
14:10:14 <S11001001> @ty ($)
14:10:15 <lambdabot> (a -> b) -> a -> b
14:10:24 <glguy> ?src $
14:10:24 <lambdabot> f $ x = f x
14:10:27 <ski> > length $ "not much"
14:10:29 <simpson> Lethalman: I use OpenGL.
14:10:29 <lambdabot>   8
14:10:44 <Lethalman> I was looking for something like clutter, there are bindings but are outdated
14:10:55 <Lethalman> simpson, plain opengl? ok
14:11:04 <Dextr> so it's just avoid parenthesis?
14:11:04 <simpson> Lethalman: Yep. I'm weird like that.
14:11:59 <ski> Dextr : basically, yes
14:12:03 <ski> one can also use it like
14:12:21 <S11001001> Dextr: in concert with other features it allows other neat things
14:12:27 <ski> > map ($ pi / 3) [cos,sin,tan]
14:12:28 <lambdabot>   [0.5000000000000001,0.8660254037844386,1.7320508075688767]
14:12:39 <S11001001> @ty \x -> (($ x) <$>)
14:12:40 <lambdabot> Functor f => a -> f (a -> b) -> f b
14:12:44 <ski> > map ($ pi / 3) [cos,sin,tan] :: [Expr]
14:12:45 <lambdabot>   [cos (pi / 3),sin (pi / 3),sin (pi / 3) / cos (pi / 3)]
14:12:54 <Dextr> oh, ok
14:13:15 <parcs> > zipWith ($) [(+1), subtract 1, negate] [2,3,4]
14:13:17 <lambdabot>   [3,2,-4]
14:13:38 <ski> > zipWith id [(+1), subtract 1, negate] [2,3,4]
14:13:40 <lambdabot>   [3,2,-4]
14:14:38 <RichyB> ski: I'd really rather read "zipWith ($)" than "zipWith id", even though they're identical in effect.
14:14:46 <Dextr> is array a standard function?  hoogle doesn't give any result in prelude
14:14:49 <S11001001> have written "flip id x" a few times
14:15:06 <RichyB> Dextr: it's in the Data.Array packages.
14:15:20 <ski> RichyB : yes
14:15:35 <ski> @type Data.Array.array
14:15:37 <lambdabot> Ix i => (i, i) -> [(i, e)] -> Array i e
14:15:43 <RichyB> Dextr: in GHCi, type ":m +Data.Array", in a .hs file, add "import Data.Array".
14:15:45 <ski> @index array
14:15:45 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.Array
14:15:48 <S11001001> @pl coseq fs x = flip id x <$> fs
14:15:48 <lambdabot> coseq = flip ((<$>) . flip id)
14:15:49 <Dextr> oh, ok, but that still doesn't give me a list then
14:16:13 <ski> what doesn't give you a list ?
14:16:23 <glguy> Dextr: That's why the example I gave you called "elems"
14:16:45 <ski> S11001001 : why `coseq' ?
14:16:59 <S11001001> ski: specialization of cosequence
14:17:40 <Dextr> ok, i have to take a closer look at that - thanks
14:17:54 <S11001001> ski: which alas is called distribute in http://hackage.haskell.org/packages/archive/distributive/0.3/doc/html/Data-Distributive.html
14:18:29 <ski> @type Data.Traversable.sequence :: Traversable t => t (a -> b) -> (a -> t b)
14:18:30 <lambdabot> Traversable t => t (a -> b) -> a -> t b
14:18:43 <ski> why would you call it `cosequence' ?
14:18:56 <S11001001> ski: cosequence only requires Functor t
14:18:57 <ski> (and what would the general type be ?)
14:19:43 <glguy> > let f xs = map snd $ sort $ zip xs [1..] in f [3,4,2,1,5]
14:19:44 <lambdabot>   [4,3,1,2,5]
14:20:07 <S11001001> @ty Data.Distributive.distribute :: Functor f => f (a -> b) -> a -> f b
14:20:08 <lambdabot> Functor f => f (a -> b) -> a -> f b
14:20:49 <`ramses> glguy: nice, I was still searching for a way to do it with lists
14:21:58 <ski> S11001001 : you said that's a specialization of `cosequence', so what's the general type ?
14:22:07 <S11001001> @ty Data.Distributive.distribute
14:22:08 <lambdabot> (Functor f, Data.Distributive.Distributive g) => f (g a) -> g (f a)
14:22:20 <S11001001> distribute = cosequence
14:22:32 <ski> @type Data.Traversable.sequenceA
14:22:33 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
14:23:31 <ski> mhm
14:23:46 <S11001001> generalizes several interesting things
14:24:02 <S11001001> @ty Data.Distributive.distribute `asTypeOf` flip
14:24:03 <lambdabot> (a1 -> b -> a) -> b -> a1 -> a
14:24:55 <Dextr> is there any other way to convert strings to ints than read x::Int?
14:25:06 <mauke> yes
14:25:07 <Clint> yes
14:25:15 <Dextr> how?
14:25:19 <mauke> length
14:25:32 <Lethalman> \o/
14:25:45 <Dextr> hm.. that won't work ^^
14:25:58 <mauke> yes, it will
14:26:01 <mauke> > length "four"
14:26:03 <lambdabot>   4
14:26:09 <Dextr> xD
14:26:20 <Clint> Data.Text.Read.decimal . Data.Text.pack
14:26:26 <Dextr> still it's not what i'm looking for
14:26:35 <mauke> what are you looking for?
14:27:20 <S11001001> Dextr: how about a type signature for it?
14:27:54 <m3ga> Dextr: most of the parse string containing digits into Int style functions are defined on ByteString or Text. see eg readDecimal etc in bytestring-lexing package.
14:28:12 <Dextr> i have a generic class, and what to create an instance for it with [Char], but that doesn't seem possible, so i created the instance for [a], but now du to read someA::Int the infered type for the method is [[Char]], which isn't general enough for [a]
14:28:29 <shachaf> preflex: zencode "hello preflex!"
14:28:40 <shachaf> preflex: zenc "hello preflex!"
14:28:40 <preflex>  z22Uhelloz20Upreflexznz22U
14:28:46 <Dextr> so i guess what i need is a more relaxed version of read, that silently fails on non-chars
14:28:53 <Clint> :t reads
14:28:54 <lambdabot> Read a => ReadS a
14:28:56 <shachaf> mauke++
14:28:59 <shachaf> preflex: seen simonpj
14:29:00 <preflex>  simonpj was last seen on #ghc 4 years, 123 days, 7 hours, 21 minutes and 23 seconds ago, saying: Sorry went away for a moment.  I am clueless about branch tagging, but feel free to discuss it anyway!
14:29:16 <ski> preflex: welcome back
14:29:24 <thoughtpolice> shapr: so, i actually got my odroid yesterday! and it's running ubuntu
14:29:31 <mauke> Dextr: why do you have a generic class?
14:29:36 <thoughtpolice> hopefully by tonight I can get LLVM and GHC working
14:29:37 <shapr> thoughtpolice: awesome! How do you like it?
14:29:50 <shapr> thoughtpolice: You're stdlib on twitter, right?
14:29:52 <Dextr> is that important?
14:29:55 <thoughtpolice> shapr: it's very nice hardware. boots fast and is easily the most responsive SoC i've used so far
14:29:58 <thoughtpolice> shapr: yes
14:30:01 <shapr> I thought so.
14:30:20 <thoughtpolice> and the small form factor + USB wifi means you can shove it anywhere :P
14:30:38 <shapr> How does the physical size compare to the Raspberry Pi?
14:30:53 <thoughtpolice> basically, cut an rpi in half, and stack the halves on top of each other
14:31:02 <thoughtpolice> and that's the rough dimensions of the board + aluminium case
14:31:06 <thoughtpolice> with no case, it's smaller than an rpi
14:31:13 <thoughtpolice> (by an inch or two)
14:31:39 * ski idly wonders what Dextr's generic class is meant for
14:31:49 <thoughtpolice> shapr: just a word to the wise, if you get an eMMC card for it, you should also probably get a UART USB connector
14:32:18 <thoughtpolice> shapr: the eMMC -> microSD reader is garbage. it works, but the cut-out of the board is too fat to fit in a SDHC adapter
14:32:28 <thoughtpolice> so i had to file the edges of the adapter down to get it to fit
14:32:32 <thoughtpolice> :/
14:33:12 <shapr> that sucks
14:33:26 <thoughtpolice> so you can do that, but you can also just boot off the SD card, and use the UART to hold the bootloader and enable the eMMC chip (it needs to be recognized on boot.) then boot normally, and you can just write to the eMMC like any other sd card/usb device
14:33:48 <thoughtpolice> and then unpull and reboot again off the eMMC
14:34:23 <thoughtpolice> shapr: but it does work. the trimmings from the PCB just make it too fat. there's plenty of room so that e.g. i didn't accidentally file the pins
14:40:18 <parcs> DexterLB: do you have a particular conversion in mind?
14:40:31 <parcs> DexterLB: oops sorry
14:40:48 <monochrom> it is important that you don't make things too generic
14:42:23 <linduxed> what unit testing package should i use if i've never used anyone so far?
14:42:31 <monochrom> the OOP doctrine of "write a very general class" is very damaging. you don't even know the future direction of generalization. the doctrine tells you to bake in a possibly wrong generalization.
14:42:32 <nathanfh> quickcheck.
14:42:36 <linduxed> i've heard of quicktest, hunit and hspec
14:42:47 <linduxed> oh yeah, quickcheck it's called
14:42:52 <nathanfh> http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck
14:43:03 <linduxed> but isn't hunit better to learn in the long run?
14:43:11 <linduxed> just wondering what i should dedicate time to
14:43:15 <S11001001> linduxed: quickcheck
14:43:15 <fik> Hello.
14:43:45 <fik> I have a list of lists that contain strings; I need to convert these strings into ints.
14:43:48 <fik> Need  help!
14:44:25 <S11001001> fik: how much haskell do you know?
14:44:36 <fik> Not much, probably obviously.
14:44:49 <linduxed> ok then, thx!
14:44:54 <linduxed> i'll look into quickcheck
14:45:23 <fik> I'm trying to do "map (map (read)) mylistoflists", but that doesn't work.
14:45:38 <S11001001> doesn't work how?
14:45:38 <mauke> "doesn't work" is not a problem description
14:45:48 <fik> Ok, one sec.
14:45:51 <parcs> fik: what's the type error?
14:46:28 <fik> "Ambiguous type variable".
14:46:33 <scooty-puff> fik: you may need to give an explicit type to the result if you using it in ghci
14:46:38 <fik> And I don't know how to qualify read.
14:46:40 <scooty-puff> <solution> :: [[Int]]
14:46:41 <donri> "read" doesn't know the type to read to
14:46:59 <donri> > read "5" :: Int
14:47:00 <lambdabot>   5
14:47:04 <scooty-puff> or let readInt = read :: String -> Int
14:47:14 <donri> try addind :: [[Int]]
14:47:43 <fik> I tried "map (map (read :: Int)) wGrid".
14:48:13 <fik> ... which screams "WRONG".
14:48:17 <donri> you'd need to make that read :: String -> Int, there
14:48:29 <fik> Oh, ok. I'll give that a try.
14:48:47 <donri> but you can add it at the end including the lists and it will be inferred
14:48:58 <fik> Hey, that worked.
14:49:00 <monochrom> I hope you learn function types from this
14:49:01 <fik> : D
14:49:14 <donri> map (map read) wGrid :: [[Int]]
14:49:21 <fik> Yep, this was pretty enlightening.
14:49:25 <fik> Thank you, guys.
14:49:28 <Lethalman> > let inc = modify $ (+1) :: State Int () in snd $ flip runState 1 $ do inc; inc; inc; inc
14:49:29 <lambdabot>   5
14:49:50 <Lethalman> > let inc = modify $ (+1) in snd $ flip runState 1 $ do inc; inc; inc; inc
14:49:51 <lambdabot>   5
14:49:52 <fik> Thanks a lot!
14:50:14 <donri> Lethalman: there's also evalState
14:50:26 <Lethalman> > let inc = modify $ (+1) in flip evalState 1 $ do inc; inc; inc; inc
14:50:28 <lambdabot>   ()
14:50:34 <Lethalman> > let inc = modify $ (+1) in flip evalState 1 $ do inc; inc; inc; inc; get
14:50:35 <lambdabot>   5
14:50:37 <Lethalman> :)
14:50:56 <Lethalman> @hoogle State s a -> s -> s
14:50:57 <lambdabot> Control.Monad.Trans.State.Lazy execState :: State s a -> s -> s
14:50:57 <lambdabot> Control.Monad.Trans.State.Strict execState :: State s a -> s -> s
14:50:57 <lambdabot> Control.Monad.State.Lazy execState :: State s a -> s -> s
14:50:58 <donri> and execState
14:51:04 <Lethalman> ehhe
14:53:50 <shachaf> byorgey: I hear someone in #haskell who might be you once talked about logarithm types.
14:53:54 <shachaf> Was it you?
14:54:54 <donri> > let inc = tell $ Endo succ in appEndo 0 $ flip execWriter $ do inc; inc; inc
14:54:56 <lambdabot>   No instances for (GHC.Num.Num
14:54:56 <lambdabot>                      (Data.Monoid.Endo
14:54:56 <lambdabot>       ...
14:55:20 <donri> > let inc = tell $ Endo succ in flip appEndo 0 $ flip execWriter $ do inc; inc; inc
14:55:22 <lambdabot>   Couldn't match expected type `Data.Monoid.Endo c0'
14:55:22 <lambdabot>              with actual...
14:55:29 <donri> :(
14:55:32 <fik> Another quickie: will x = 2 + someY be evaluated every time it's called?
14:55:42 <shachaf> Maybe.
14:56:02 <fik> What if x = 2 + 3?
14:56:13 <donri> fik: it doesn't matter, so you can't rely on it
14:56:17 <monochrom> depends on context
14:56:39 <fik> I have this:
14:56:46 <ski> depends on the type of `x'
14:56:50 <fik> makeGrid =  map (map (read)) wGrid :: [[Int]]
14:56:58 <fik> where wGrid = [take 20 x | x <- [drop y $ words rawGrid | y <- [0,20..399]]]
14:57:15 <fik> I have to work on the resulting grid.
14:57:43 <monochrom> then both are evaluated once
14:57:45 <fik> Should I store the resulting grid?
14:57:53 <ski> i think `rawGrid',`wGrid',`makeGrid' there would be evaluated only once in GHC
14:58:09 <fik> Ah, ok. So I can safely work with makeGrid.
14:58:31 <ski> shachaf : logatithm types ?
14:58:37 <donri> it's pure, so safety doesn't really enter into it :P
14:58:52 <fik> Ha, I'm trying to wrap my head around that.
14:58:56 <monochrom> ow, "safely" is just English here
14:59:04 <ski> the only consideration here would be efficiency
14:59:11 <fik> Yes, that's my worry.
14:59:28 <ski> but it should be fine in your case, with GHC
14:59:30 <shachaf> ski: I think I have a class like class Unapplicative p where unpure :: p Void; unstar :: p (a,b) -> Either (p a) (p b)
14:59:56 <donri> if performance is your concern you should maybe focus on things like using more efficient/appropriate/stricter data structures
15:00:07 <fik> A priori I don't see much reason for this being evaluated every time.
15:00:24 <fik> Oh, I'm just trying to develop good habits from the start.
15:00:32 <ski> shachaf : any instance ?
15:00:53 <shachaf> ski: I don't think so, other than trivial ones.
15:01:00 <fik> Thank you again.
15:01:08 <shachaf> ski: But maybe if you used classical disjunction instead of Either you'd be able to make some.
15:01:28 <ski> fik : if you have `foo = ...' where `foo' is polymorphic, specifically where it depends on constraints (usually class constraints), then it would need to be recomputed for each time `foo' is used
15:02:25 <ski> fik : e.g. if you have `primes :: Integral i => [i]', `primes' being a list of all primes, it would need to be recomputed if you wanted to use it at a different type `i'
15:02:51 <glguy> fik: "Should I store the resulting grid?" How were you planning on storing it somewhere?
15:02:58 <ski> shachaf : shouldn't you have `unpure :: p () -> Void' with that `unstar' ?
15:03:09 <fik> Yes, that doesn't make sense, right?
15:03:17 <fik> I'm being imperative, I guess.
15:03:30 <ski> it's already "stored" in `makeGrid'
15:03:44 <ski> (but won't be computed until/unless you need it)
15:03:50 <glguy> fik: I just think with that comment and the name "makeGrid" you might have the wrong idea about what's happening
15:04:06 <shachaf> ski: I'm not sure. Maybe that one is more valid.
15:04:26 <fik> Yeah, I think so.
15:04:33 <ski> shachaf : well, it's certainly not equivalent
15:04:47 <donri> > let inc = tell $ Endo succ in flip appEndo 0 $ execWriter $ do inc; inc; inc
15:04:48 <lambdabot>   3
15:04:49 <shachaf> ski: Right.
15:04:56 <donri> Lethalman: ^ ;)
15:05:01 <fik> Everything is a function: x = 5 is a function.
15:05:04 <fik> Right?
15:05:05 <ski> shachaf : but i think a classical disjunction might be more interesting, yes
15:05:06 <donri> fik: no
15:05:14 <donri> fik: http://conal.net/blog/posts/everything-is-a-function-in-haskell
15:05:24 <shachaf> ski: It seems that your function makes more sense.
15:05:26 <ski> shachaf : .. perhaps if you replace `->' with some kleisli arrow
15:05:38 <ski> (e.g. `Kleisli []')
15:05:45 <monochrom> function type has "->". if you don't see "->" you are not looking at a function
15:05:51 <Lethalman> donri, oh don't know what Endo is :)
15:06:00 <elliott> ski: in my and shachaf's experience adding classical disjunction gets you a lot of instances and 0 use cases :P
15:06:06 <fik> So functions take parameters, always.
15:06:12 <fik> makeGrid is not a function, then.
15:06:25 <ski>   newtype Endo a = Endo {appEndo :: a -> a}
15:06:29 <donri> Lethalman: an endofunction is an a -> a which forms a monoid under composition
15:06:51 * Lethalman starting headache
15:06:55 <ski> elliott : what more specifically do you mean by "classical disjunction", here ?
15:07:10 <monochrom> a logic course may say "constant is a function, 0 arity" for uniformity. that is good for them. haskell does not need this uniformity
15:07:37 <ski> fik : yes, exactly
15:07:39 <donri> Lethalman: basically my code is just: (succ . succ . succ) 0
15:07:40 <elliott> ski: just COr a b = Not (Not a, Not b)
15:07:44 <elliott> Not a = a -> Void
15:07:50 <Lethalman> donri, mh ok
15:07:57 <ski> elliott : i agree that that one isn't very useful
15:08:00 <elliott> me and shachaf have been playing about with stuff vaguely related to this in a file for a day
15:08:06 <monochrom> you will soon find that every niche twists definitions for its own convenience. even mathematicians divide into two groups for whether 0 is a natural number.
15:08:20 <elliott> We tried a more general one that didn't fix the return type to Void but it didn't work out.
15:08:21 <Lethalman> monochrom, foo :: IO () is a function though even if it has no -> ?
15:08:29 <elliott> Lethalman: foo is not a function
15:08:30 <monochrom> not a function
15:08:33 <ski> elliott : but if you replace `-> Void' with `M Void' for some `M', it could be more interesting
15:08:42 <monochrom> I recommend "command", "action"
15:08:44 <ski> er, with `-> M Void'
15:09:00 <ski> Lethalman : `foo' is an `IO'-action
15:09:03 <donri> Lethalman: but it's a nice way to do "write-only state". you weren't "get"ing your state so ;)
15:09:14 <monochrom> or "procedure"
15:09:32 <fik> Donri: Thanks for the article.
15:09:40 <Lethalman> donri, yes I think I got it
15:09:41 * ski generally prefers the terminology "command" to "statement", in imperative languages
15:09:58 <ski> ("statements" sounds more like what you write in Prolog)
15:10:07 <monochrom> dijkstra agrees with ski. "guarded command language"
15:10:22 <Lethalman> > appEndo 0 (Endo succ, Endo succ)
15:10:24 <lambdabot>   No instance for (GHC.Num.Num
15:10:24 <lambdabot>                     (Data.Monoid.Endo (Data.Mo...
15:10:31 <Lethalman> > appEndo 0 (Endo succ, Endo succ) :: Int
15:10:33 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:10:33 <lambdabot>              with actual type ...
15:10:44 <donri> Lethalman: it's a monoid, you want mappend or mconcat (or Writer)
15:10:46 <ski> > appEndo (Endo succ `mappend` Endo succ) 0
15:10:48 <lambdabot>   2
15:10:51 <fik> I wanted to know if, once makeGrid is evaluated, and given it doesn't depend on anything, there will be no further need to evaluated when it's used again.
15:10:59 <Lethalman> ooh ok
15:11:09 <ski> > Endo succ `mappend` Endo succ `appEndo` 0  -- if you prefer
15:11:11 <fik> *for it to be evaluated
15:11:11 <lambdabot>   2
15:11:16 <Lethalman> > appEndo (Endo succ . Endo succ) 0
15:11:18 <lambdabot>   Couldn't match expected type `a1 -> a0'
15:11:18 <lambdabot>              with actual type `Data...
15:11:21 <donri> > appEndo (Endo succ <> Endo succ) 0
15:11:23 <lambdabot>   2
15:11:27 <Lethalman> ops
15:11:40 <monochrom> but BASIC repls want the distinction between "do it now" and "put it in a program, don't do now". so they coined "command" vs "statement".  "print 4" command, "10 print 4" statement
15:11:49 <donri> Lethalman: the operator is <>
15:11:54 <Lethalman> donri, yes
15:12:08 <Lethalman> :t appEndo
15:12:09 <lambdabot> Endo a -> a -> a
15:12:15 <ski> fik : yes
15:12:22 <monochrom> another example of every niche hijacking words for its own convenience
15:12:41 <donri> Lethalman: Endo itself is just a newtype to work around the fact there's another monoid instance for functions
15:12:45 <fik> ski: Thank you.
15:13:05 <ski> monochrom : would `10 print 4:goto 10' be one statement or two ?
15:13:16 <ski> (the latter, i assume)
15:13:19 <monochrom> haha, I forgot
15:13:49 <Lethalman> donri, and what's the mempty?
15:14:01 <donri> Endo id
15:14:02 <Lethalman> > appEndo mempty 0
15:14:03 <monochrom> I suppose we BASIC users are not intelligent enough to ask that question
15:14:04 <lambdabot>   0
15:14:05 <ski> (iow, `10 print 4:goto 10' would be an interactive command which enters two statement into program line `10')
15:14:08 <Lethalman> donri, ah! guessed that :)
15:14:09 <Lethalman> ok thanks
15:14:26 <donri> :)
15:15:42 <monochrom> anyway, I am surprised no one argues "but IO() = FSM -> ((), FSM), that's a function!"
15:16:11 <elliott> monochrom: I was waiting for that to happen.
15:16:15 <gwern> @quote
15:16:15 <lambdabot> knobo says: I really like this :) I can see that haskell is really cool now. This i a "matrix moment" for me :)
15:16:22 * elliott mentally half-composed an objection.
15:17:35 <parcs> > appEndo (Endo succ <> Endo succ <> Endo 0) undefined
15:17:37 <lambdabot>   No instance for (GHC.Num.Num (a0 -> a0))
15:17:37 <lambdabot>    arising from a use of `e_10'
15:17:37 <lambdabot>  P...
15:17:40 <Saizan> Flying Spaghetti Monster?
15:17:50 <monochrom> yes
15:18:29 <ski> @quote excising
15:18:29 <lambdabot> luite says: *amacleod started excising GOTOs from his BASIC code when he was 10.  *roconnor started excising GOTOs from his Pascal code when he was 11.  *luite used goto's in his C code last year.
15:18:58 <luite> oh noes
15:19:07 <ski> we've got you now !
15:19:21 <donri> we've goto you now!
15:19:59 <monochrom> I played with setjmp, longjmp last year
15:20:03 <croikle> we could probably make a goto monad with continuations
15:20:13 <monochrom> perhaps just 2 months ago or less, too
15:21:08 <monochrom> yes, my http://www.vex.net/~trebla/haskell/cont-monad.xhtml almost has it. I just haven't figured out jumping forward
15:21:22 <shachaf> I think you would need to do some preprocessing to jump forward.
15:21:37 <shachaf> Construct the program in advance with labels, then run it. Or something.
15:21:42 <monochrom> and have you seen my continuation parsec style? http://www.vex.net/~trebla/haskell/cont-monad.xhtml
15:21:58 <monochrom> err, http://hpaste.org/80484
15:22:28 <shachaf> monochrom: augustss does forward GOTOs in his Haskell BASIC.
15:22:46 <shachaf> E.g. http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
15:23:01 <monochrom> how does he do it? preprocessing?
15:23:07 <monochrom> or mfix?
15:23:31 <shachaf> I don't know.
15:23:38 <monochrom> I want to use mfix, but I am not sure whether ContT can have mfix. I heard no.
15:23:42 <shachaf> Oh, I think preprocessing.
15:23:49 <shachaf> Since he compiles to LLVM or something?
15:24:53 <ski> @where MonadFix_Cont
15:24:53 <lambdabot> "Value recursion in the continuation monad" by Magnus Carlsson in 2003-01-07 at <http://www.carlssonia.org/ogi/mdo-callcc.pdf> (there's also slides at <http://www.carlssonia.org/ogi/mdo-callcc-
15:24:53 <lambdabot> slides.pdf>)
15:25:39 * Lethalman just learn StateVar from opengl, now I can go sleep :S
15:26:20 * lambdabot . o O ( "Value recursion in the continuation monad" by Magnus Carlsson in 2003-01-07 at <http://www.carlssonia.org/ogi/mdo-callcc.pdf> (there's also slides at <http://www.carlssonia.org/ogi/mdo-
15:26:20 <lambdabot> callcc-slides.pdf>)
15:26:29 <monochrom> thanks ski
15:26:58 <Dextr> are multi-argument lambdas valid? how would i write that?
15:27:28 <shachaf> You can write (\a b c -> ...).
15:27:38 <Dextr> thanks
15:27:44 <shachaf> But of course that's still a function that returns a function.
15:27:56 <Dextr> yes
15:28:06 <monochrom> you can also write (\a -> \b -> \c -> body) if you like
15:28:32 <Dextr> oh, right, i keep forgetting about that :X
15:31:33 <shachaf> @quote cmccann ::
15:31:33 <lambdabot> cmccann says: newtype Natural = N { denature :: Integer }
15:31:52 <shachaf> @quote cmccann ::
15:31:53 <lambdabot> cmccann says: :t \f -> \x -> f x :: Int :: (Int -> Int) :: (Int -> Int) -> Int -> Int
15:38:06 <parcs> :t \f -> \x -> f x :: Int ()
15:38:07 <lambdabot>     `Int' is applied to too many type arguments
15:38:07 <lambdabot>     In an expression type signature: Int ()
15:38:07 <lambdabot>     In the expression: f x :: Int ()
15:41:30 <shachaf> monochrom: Can you make a variant of setjmp that lets you pass information back?
15:41:55 <shachaf> I suppose it would be something like m (Maybe a, a -> m b)
15:43:15 <monochrom> I think so. my latest Yield module passes information both directions
15:45:14 <martint> so i can fold over all kinds of inductive data types, and i can map over all kinds of container types, including graphs, but is there an equivalent of a graph-fold? i.e. a systematic way of generating a value from a graph
15:49:46 <Dextr> what's the correct indentation for multiline-lambdas? (http://ideone.com/6WIMMv)
15:51:21 <shachaf> Dextr: Why not let f2 x = ...?
15:51:47 <Dextr> hm?
15:52:04 <shachaf> Or, for that matter, let f2 x | x == n = ... | otherwise = ...
15:52:20 <shachaf> It's just a function.
15:52:23 <Dextr> i need to bootstrap that somewhere somehow - currently i do this with     let fs = p5InverseBuildLambdas a (\_ -> []) 0 in
15:52:31 <Dextr> so i need a lambda there, right?
15:52:42 <monochrom> in the broad sense, if the compiler accepts your file, you have correct indentation
15:53:10 <jubos> hi, can someone help me understand a syntax a bit more.  I am looking at http://www.haskell.org/ghc/docs/7.0.2/html/libraries/process-1.0.1.5/System-Process.html, and I don't quite get createProcess (proc "ls" []){ std_out = CreatePipe }.
15:53:27 <Dextr> monochrom that's why i'm asking .. line 3 seems to have the wrong indentation level
15:53:39 <jubos> proc's return type is CreateProcess.  how does the record syntax fit in there as well?
15:53:59 <lennart_> Dextr: the expression for f2 must be more indented than f2 itself (all lines, including the case)
15:53:59 <monochrom> Oh, i see it now. move 3-5 to the right more. more right than "f2"
15:54:06 <glguy> createProcess (proc "ls" []){ std_out = CreatePipe } ==> createProcess ((proc "ls" []){ std_out = CreatePipe })
15:54:19 <Dextr> oh, ok
15:54:20 <shachaf> Dextr: You can do what monochrom said, as the minimal change.
15:54:25 <shachaf> But I think what I said would be much simpler.
15:54:32 <monochrom> yes too
15:54:35 <Dextr> how would that work?
15:54:37 <glguy> jubos: that was for you
15:54:42 <shachaf> 15:51 <shachaf> Or, for that matter, let f2 x | x == n = ... | otherwise = ...
15:54:49 <shachaf> f2 is a function.
15:55:02 <shachaf> Instead of writing "f = \x -> ...", write "f x = ..."
15:55:06 <shachaf> You do that everywhere else.
15:55:09 <Dextr> oh, so i can have closure-stuff in non-lambdas too?
15:55:27 <shachaf> I don't know what "closure-stuff" is.
15:55:38 <Dextr> accessing f an m
15:55:38 <shachaf> Lexical scope applies everywhere, if that's what you mean.
15:55:40 <Dextr> *and
15:55:52 <Dextr> ok, thanks
15:55:56 <jubos> glguy: so is this a common way to use both record syntax and a functional constructor?
15:55:58 <shachaf> Also, note that your inner "x" shadows the outer "x".
15:56:03 <shachaf> Better to use a different variable name.
15:56:26 <Dextr> yes, that's fine .. i don't need x, but i need to control the recursion somehow
15:56:26 <monochrom> http://ideone.com/a3D0OX
15:57:32 <Dextr> http://ideone.com/BMcLAQ <- this is what i'm actually doing
15:57:52 <Dextr> so ultimately it's sort of kludge for a loop
15:58:52 <glguy> jubos: It is just the standard syntax in Haskell for updating a record
15:59:26 <jubos> so proc creates a CreateProcess first, then std_out is called on it and the result is returned to createProcess?
16:19:43 <nh2> is it known that new cabal install with multiple parallel jobs breaks with --reinstall / --force-reinstalls?
16:19:57 <nh2> it just seems to ignore the required order
16:28:38 <plaeremans> hello, I'm trying to understand a data definition in Haskell
16:28:42 <plaeremans> data BufRange = BufRange {-# UNPACK #-} !(Ptr Word8) {-# UNPACK #-} !(Ptr Word8)
16:28:50 <plaeremans> what does the ! mean in this expression ?
16:31:14 <aavogt> plaeremans: it means that    (BufRange undefined) is undefined
16:34:15 <plaeremans> aavogt that looks strange to me, so  I can create a value of type BufRange undefined and it has as type undefined ?
16:34:51 <aavogt> no the value is undefined
16:34:58 <plaeremans> ok
16:35:06 <plaeremans> thanks
16:35:07 <aavogt> > Just undefined
16:35:08 <lambdabot>   Just *Exception: Prelude.undefined
16:35:16 <aavogt> > Just $! undefined
16:35:17 <lambdabot>   *Exception: Prelude.undefined
16:35:24 <plaeremans> :-)
16:35:30 <Noldorin> is there a haskell function in the core libraries that returns elements in a sequence by adjacent pairs?
16:35:50 <shachaf> Noldorin: You should be more specific.
16:35:57 <shachaf> (With an example, for example.)
16:35:58 <Noldorin> i.e. in [a, b, c, d] returns [(a, b), (b, c), (c, d), (d, e)]
16:36:04 <Noldorin> err, one too many
16:36:06 <Noldorin> but you get the idea
16:36:11 <shachaf> > (zip <*> tail) "hello"
16:36:12 <lambdabot>   [('h','e'),('e','l'),('l','l'),('l','o')]
16:36:26 <dcoutts> nh2: no, I don't think that is known.
16:36:28 <shachaf> Or generally zipWith f xs (tail xs)
16:37:02 <dcoutts> nh2: the algorithm is to not start an install job until all the dependent jobs are done
16:37:09 <Noldorin> shachaf, what's the diff?
16:37:18 <dcoutts> nh2: if you can reproduce and report it, that'd be appreciated
16:37:19 <Noldorin> also, i'm presuming <*> is the tuple constructor operator.
16:37:30 <shachaf> Noldorin: No, (<*>) is a function.
16:37:36 <shachaf> (<*>) f g x = f x (g x)
16:37:41 <Noldorin> oh
16:37:43 <shachaf> (It also does some other things.)
16:37:52 <nh2> dcoutts: maybe it is tricked out by the fact that the libs are already there, but we need to reinstall them to get things like profiling/-dyn?
16:37:52 <shachaf> Anyway never mind the (<*>), it's just a trick.
16:37:53 <nh2> dcoutts: (I also just posted it on haskell-cafe)
16:37:59 <shachaf> The main idea is zipping with the tail.
16:38:04 <shachaf> > let list = "hello" in zip list (tail list)
16:38:06 <lambdabot>   [('h','e'),('e','l'),('l','l'),('l','o')]
16:38:21 <dcoutts> nh2: the parallel install algorithm doesn't care about the fact that they're reinstalls
16:38:48 <nh2> dcoutts: so do you mean it will just treat them as installed already?
16:39:35 <dcoutts> nh2: no, it makes a plan for what to install and then it does it, according to the plan. It doesn't look at what's already installed, it blindly follows the plan (a dep graph, in dep order)
16:40:18 <Noldorin> shachaf, oh, fair enough. you just suggested (zip <*> tail) because it's point-free?
16:40:33 <nh2> dcoutts: weird. I will try to make a minimal fresh cabal for which a world reinstall like this breaks.
16:40:54 <shachaf> Noldorin: That's the general idea, but it's just a silly trick.
16:40:58 <dcoutts> nh2: if you only look at the install plan, you (or rather the code that executes it) can't actually tell if it's a reinstall or not
16:41:00 <Noldorin> fair enough
16:41:03 <Noldorin> thanks anyway :)
16:41:19 <nh2> dcoutts: can I print the reinstall plan?
16:42:05 <dcoutts> nh2: yes, that's what --dry-run shows you (or rather it shows just the bits of the plan that involve installing, not the bits of the plan that describe existing installed deps)
16:42:34 <dcoutts> nh2: well, it shows the flattened plan. The real install plan is a dep graph.
16:45:12 <nh2> dcoutts: I will put what you said in a github issue because I cannot deal with it right now, but maybe someone else can
16:45:21 <dcoutts> nh2: thanks
16:52:20 <shachaf> Maybe this type is simple enough to exist elsewhere: newtype Un p a s = Un (p s -> p a)
16:52:24 <shachaf> Does it?
16:52:55 <mason_> hello. is there a portable library for launching and interacting with a CLI process?  I need to interactively read from it's stdout and write to it's stdin
16:53:41 <shachaf> mason_: System.Process?
16:53:48 <Cale> mason_: Yes, that's in System.Process
16:53:55 <nyc> haskeline?
16:53:56 <shachaf> @hoogle runInteractiveProcess
16:53:56 <lambdabot> System.Process runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
16:54:02 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/process-1.1.0.2/System-Process.html
16:54:18 <nyc> Woops I misunderstood.
16:55:14 <mason_> thanks
16:57:13 <shachaf> Nereid: Do you still hate anticategories?
16:57:23 <Nereid> I never hated them.
16:57:25 <Nereid> they're just scary
16:57:48 <shachaf> What about antiapplicatives?
16:58:06 <shachaf> p () -> Void; p (a,b) -> Either (p a) (p b)
16:59:28 <Nereid> I still have yet to see an example of one.
16:59:54 <shachaf> Nereid: Oh, we made these uncategories work by using classical disjunction.
16:59:59 <Nereid> :(
17:00:07 <shachaf> By "work" I mean we made some instances.
17:00:35 <shachaf> p t s -> Not (Not (p t x), Not (p x s))
17:12:27 <mason_> having issues with System.Process, reading a char blocks. would appreciate if someone can take a look
17:12:41 <hpaste> mason pasted “blocking read” at http://hpaste.org/80558
17:14:28 <shachaf> mason_; Works for me.
17:14:53 <shachaf> (You should, if possible, @paste files that are ready to run.)
17:17:09 <mason_> I just realized that it sort of works in here too, but I have to wait around 5 seconds for character to be read. odd
17:17:28 <`Jake`> Is it possible to do something like vim or man in haskell, where you have a sort of graphical user interface in the terminal?
17:17:58 <shachaf> mason_: Well, you didn't paste a complete program and didn't specify how you're running it, so there's not much more I can say.
17:18:10 <shachaf> `Jake`: It is possible.
17:18:19 <shachaf> (Why wouldn't it be?)
17:18:45 <Nereid> `Jake`: there's a curses library for haskell
17:18:45 <`Jake`> shachaf: Can you give me a hint to how it is achieved?
17:18:51 <`Jake`> ah, i see
17:19:05 <`Jake`> haven't really gotten into curses, but that makes sense
17:19:13 <`Jake`> thanks
17:20:40 <mason_> shachaf: are you saying it may be normal that I am 5 seconds for hGetChar to return depending on how I am running that code?
17:21:39 <shachaf> mason_: I have no idea what's going on.
17:21:50 <shachaf> I can't reproduce your results, therefore I can't help.
17:22:10 <shachaf> It could be that you're running your program from ghci, for example. Who knows what ghci does with buffering? It probably does its own thing.
17:22:14 <shachaf> Or it could be that X.
17:24:25 <RobertLJ>  /Join #erlang
17:24:28 <Nereid> I tried it within ghci and I didn't get any delays.
17:26:14 <shachaf> Is there a class for either of: foo :: Foo p => p a -> p (b,a); bar :: Bar p => p a -> p (Either b a)
17:30:25 <shachaf> @remember cmccann Clearly the reason why edwardk uses Haskell now is because every C++ compiler has a restraining order against him.
17:30:25 <lambdabot> Okay.
17:31:15 <glguy> Gee, lambdabot. Maybe you could be more enthusiastic ...
17:31:52 <lambdabot> no thanks
17:31:58 <cmccann> @faq can Haskell make lambdabot more enthusiastic?
17:31:58 <lambdabot> The answer is: Yes! Haskell can do that.
17:32:02 <cmccann> problem solved.
17:32:02 <lambdabot> cmccann: You have 1 new message. '/msg lambdabot @messages' to read it.
17:32:28 <shachaf> Oh, that was me, wasn't it.
17:32:32 <cmccann> yes.
17:32:54 * shachaf checks what he asked about.
17:33:05 <cmccann> logic stuff.
17:33:06 <shachaf> Oh, linear orders.
17:33:27 <cmccann> I'm not sure exactly what you meant though.
17:33:50 <shachaf> So http://ncatlab.org/nlab/show/linear+order says that < is more powerful than ≤ constructively.
17:33:52 <Pseudonym> Can Haskell make lambdabot more sardonic?
17:34:14 <lambdabot> Suuure it can.
17:34:20 <shachaf> Since you can't just look at Not (y > x) or something.
17:34:33 <shachaf> Is the situation the other way around dual-constructively?
17:34:52 <cmccann> hm
17:35:27 * cmccann reads the nlab article quickly
17:36:23 <cmccann> oh, does this just come down to LEM?
17:36:30 <shachaf> Maybe.
17:37:50 <parcs> > reverse (1:2:undefined)
17:37:52 <lambdabot>   *Exception: Prelude.undefined
17:37:52 <applicative> mason_: were you just writing a command line program that takes input, or were you wanting to give System.Process things like "cat" as orders
17:39:05 <cmccann> shachaf: yeah the situation is probably reversed I would expect
17:39:26 <applicative> mason_: God knows there are much easier ways to collect input than  via runInteractiveProcess "cat" [] Nothing Nothing
17:39:34 <mason_> applicative: the latter. I want to control interactive CLI program
17:40:04 <shachaf> cmccann: That's pretty weird.
17:40:33 <shachaf> cmccann: Also linear orders have "comparison" and "irreflexivity" which are the properties I was talking about yesterday.
17:40:35 <Nereid> @let reverse' xs = let go [] _ = []; go (x:xs) ~(y:ys) = y:go xs ys in go xs (reverse xs)
17:40:36 <lambdabot>  Defined.
17:40:37 <shachaf> (They also have other things.)
17:40:39 <cmccann> shachaf: I'd have to work through it explicitly to be sure though
17:40:40 <Nereid> > reverse' (1:2:undefined)
17:40:42 <lambdabot>   [*Exception: Prelude.undefined
17:40:45 <Nereid> > map (const ()) $ reverse' (1:2:undefined)
17:40:46 <shachaf> @where sneaky2
17:40:46 <lambdabot> lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = []
17:40:47 <lambdabot>   [(),()*Exception: Prelude.undefined
17:40:55 <shachaf> Is it that?
17:40:57 <Nereid> yes
17:41:04 <shachaf> What's the context?
17:41:10 <Nereid> none
17:41:14 <shachaf> I remember talking about this function in here a while ago.
17:41:17 <Nereid> me too
17:41:29 <Nereid> @where sneaky
17:41:29 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
17:41:32 <Nereid> @where sneaky3
17:41:32 <lambdabot> I know nothing about sneaky3.
17:42:13 <shachaf> @where sneaky4
17:42:13 <lambdabot> I know nothing about sneaky4.
17:42:23 <shachaf> Hmm, I was thinking they'd be sneaky and hide it.
17:42:32 <shachaf> (By "they" I mean "me", I think.)
17:42:33 <Nereid> @where sneaky0
17:42:33 <lambdabot> I know nothing about sneaky0.
17:42:42 <Nereid> @where sneaky1
17:42:42 <lambdabot> I know nothing about sneaky1.
17:42:43 <lambdabot> While we're at it, I know nothing about sneaky5 or sneaky-1 either.
17:42:50 <Nereid> huh.
17:43:17 <shachaf> It's good to have you back, Pseudonym.
17:43:21 <Pseudonym> :-)
17:43:25 <Nereid> :(
17:43:43 <Pseudonym> We should hand out sockpuppet mode more freely, I think.
17:43:52 <dobs> hi
17:43:57 <Nereid> > map (const ()) $ reverse' [1..]
17:43:58 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
17:44:04 <shachaf> Pseudonym: We sort of do.
17:44:05 <dobs> how are you folks
17:44:16 <Nereid> you assume we are folks
17:44:26 <shachaf> Pseudonym: By which I mean that lambdabot doesn't check for nickserv identification.
17:44:31 <shachaf> So anyone can /nick Pseudonym
17:44:32 <dobs> and other asorted androids
17:44:41 <Nereid> :P
17:44:44 <Pseudonym> Ah.
17:44:45 <shachaf> (Well, not now. But the list of admins is long.)
17:45:01 <Pseudonym> We should probably fix that.
17:45:51 <shachaf> That would be a shame.
17:45:57 <cmccann> shachaf: the more I think about it I'm not even sure how to translate the definitions into dual-intuitionistic logic properly
17:47:11 <cmccann> being careful about things that you'd expect to be equivalent classically but aren't in this case &c.
17:47:26 <shachaf> Right.
17:47:40 * ski seconds shachaf's welcome
17:47:41 <shachaf> Until yesterdayish I expected ≤ and < to be equivalent. :-)
17:48:03 <cmccann> and it's been a while since I was playing with this stuff so I don't have a good intuition for it right now
17:48:35 <shachaf> WHAT ABOUT A COINTUITION HA HA HA
17:48:45 <cmccann> obvious/10
17:49:00 <cmccann> nice try though
17:49:16 <shachaf> > obvious
17:49:18 <lambdabot>   9.5
17:49:23 <shachaf> Pretty good.
17:49:29 <cmccann> ...heh
17:49:49 <shachaf> cmccann: Also you should name those operations.
17:50:10 <cmccann> which operations
17:50:20 <shachaf> p a -> p (a,b), p a -> p (Either a b)
17:51:06 <ski> shachaf : btw, note that equality in a finitely presented group in some sense behaves "oppositely" to equality for reals (represented as Cauchy sequences)
17:51:09 <cmccann> I think I've lost the context here, where did those come from
17:51:15 <shachaf> Lenses, where else?
17:51:23 <cmccann> that hardly narrows it down much
17:51:30 <shachaf> http://slbkbs.org/s.hs
17:51:38 <Nereid> what's p?
17:51:46 <shachaf> Nereid: An invariant functor.
17:51:53 <Nereid> a what.
17:52:08 <shachaf> Nereid: class Invariant p where invmap :: (a -> b) -> (b -> a) -> p a -> p b
17:52:12 <ski> shachaf : for reals, you can detect when two reals are apart, but not when they're equal. for finitely presented groups, you can detech when two elements are equal, but not when they're apart
17:52:29 <simpson> Fo' reals.
17:52:30 <shachaf> ski: Hmm.
17:53:09 <ski> (instead of reals, you may simply take infinite streams/sequences, if you prefer)
17:53:09 <Nereid> well you can for some groups.
17:53:17 <ski> yes, but not generally
17:53:52 <ski> (so it's not directly comparing like with like, yes. still i think the opposing behaviour is interesting)
17:54:26 <shachaf> cmccann: Given invmap and p a -> p (a,b), you can define lenses.
17:54:36 <shachaf> Given invmap and p a -> p (Either a b), you can define prisms.
17:54:57 <shachaf> In fact those things are themselves a lens and a prism respectively, in this encoding.
17:55:13 <shachaf> So you can take them as a "canonical" lens/prism and build up other ones from them.
17:55:53 <ski> shachaf : is `p' in `Invariant p' supposed to be a functor from the category with morphisms being only isomorphisms, or just one from the category with morphisms being pairs of opposite morphisms ?
17:56:34 <ski> (iow, are the two arguments of `invmap' supposed to be inverses of each other ?)
17:56:54 <shachaf> ski: Hmm, I'm not sure. I think in general they aren't?
17:57:03 <shachaf> We define type Iso s a = forall p. Invariant p => p a -> p s
17:57:07 <ivanm> kamatsu: I'm working on a new graph library btw
17:57:16 <ivanm> (which is why I haven't bothered doing anything except bug fixes to FGL)
17:57:26 <shachaf> But that has an additional law to be an isomorphism.
17:59:28 <ski> being ?
18:00:12 <shachaf> Being the one you mentioned, that the two arguments are inverses.
18:05:30 <zomg> hm, generating haskell code is easy as long as you remain pure... but when you start dealing with impure code, it starts to get tricky because things no longer work as directly :P
18:09:52 <ski> shachaf : hm, i don't see two arguments in the definition of `Iso' ..
18:11:16 <shachaf> ski: iso :: (a -> s) -> (s -> a) -> Iso s a; iso = invmap
18:12:14 <ski> oh, ok
18:13:22 <shachaf> ski: When you allow more operations on top of invmap, you get other structures.
18:13:34 <shachaf> For example p a -> p (a,b) gives you a lens, and p a -> p (Either a b) gives you a prism.
18:13:47 <shachaf> (These aren't great lenses/prisms because they're not polymorphic.)
18:13:52 <mason_> is there a way to check if reading a Handle will block?
18:14:21 <JoeyA> mason_: Don't do that.  Not portable.
18:14:35 <JoeyA> If you really need to, there's hWaitForInput.
18:14:44 <zachk> is the 'lens thang' unified and sorted out for the most part these days?
18:14:48 <JoeyA> mason_: But why would you need to do that?
18:15:20 <cmccann> lens is very polymorphic, it unifies with all kinds of stuff
18:15:24 <mason_> to avoid blocking on read? :)
18:15:32 <mm_freak> mason_: in haskell you want reading to block
18:15:35 <zachk> cabal install what-for-lens ?
18:15:37 <mm_freak> mason_: use concurrency
18:15:40 <JoeyA> mason_: Why not fork a thread and have it do the reading?
18:16:35 <mm_freak> mason_: your haskell threads will be combined into a number of OS threads with epoll/winapi…  there is no need to do the polling manually
18:16:42 <mason_> JoeyA: I am a bit wary of using threads when I dont need to
18:16:53 <mm_freak> mason_: you always need to in haskell ;)
18:16:58 <shachaf> mason_: You should read the FAQ on this.
18:16:59 <shachaf> @where faq
18:16:59 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
18:17:02 <JoeyA> mason_: They're pretty cheap.  They're not like threads in C.
18:17:04 <mm_freak> I/O works that way
18:17:12 <shachaf> mason_: http://www.haskell.org/haskellwiki/FAQ#How_can_I_do_X_without_resorting_to_threads.3F
18:17:49 <JoeyA> I want hWaitForInput and non-blocking I/O (e.g. hGetBufNonBlocking) to be deprecated, since Windows doesn't really support it well.  See the end of http://hackage.haskell.org/trac/ghc/ticket/4144
18:18:50 <JoeyA> I'd be interested to know what legitimate uses people have for non-blocking I/O that lightweight threads doesn't do already.
18:19:13 <zomg> JoeyA: but.. but.. nodejs!
18:19:15 <zomg> ;>
18:19:15 <JoeyA> (non-blocking I/O and polling)
18:19:36 <ski> shachaf : mhm, ok
18:19:37 <mason_> I am not worried about performance but threading issues. I know immutability helps but there are still potential issues when wrapping C functions etc. or maybe I am worrying too much
18:20:16 <JoeyA> Actually, I'm aware of one case: PostgreSQL's libpq library requires you to poll a socket to wait for asynchronous notifications.
18:20:40 <JoeyA> But hWaitForInput wouldn't do any good for that, and threadWaitRead can't tell the difference between a socket and a file descriptor (there's a difference on Windows)
18:21:31 <mason_> take a look at setCurrentDirectory for example, and it's remarks about concurrency. how many more functions like that are there in standard library? hard to keep track if you are using one
18:22:04 <shachaf> Which remarks?
18:22:39 <mason_> about global state
18:23:27 <JoeyA> mason_: But what has that to do with Handle I/O ?
18:24:20 <JoeyA> Also, if you're using forkIO threads, they may jump between OS threads.  forkOS doesn't have that problem, but has the same overhead that threads have in C.
18:24:23 <mason_> JoeyA: nothing. But if I use a separate thread for reading data I would do more than just reading
18:24:53 <mason_> and I may accidentally use a function with similar issues
18:27:46 <applicative> zachk: cabal install lens
18:28:09 <kini> I'm told that some version of Haskell used to support expressions like ( (foo :: a) `(some expression of type a -> b -> c)` (bar :: b) ) :: c
18:28:17 <kini> is there some ghc pragma which does this today?
18:28:46 <shachaf> No.
18:28:47 <applicative> ScopedTypeVariables
18:28:49 <kini> ok haha
18:29:02 <shachaf> Or, or yes?
18:29:06 <shachaf> Which thing do you want?
18:29:15 <shachaf> I thought you wanted expressions in backticks.
18:29:21 <kini> no, you intepreted my badly formed question correctly, shachaf
18:29:29 <ofan> hi, is there any way to setup a global hook in cabal?
18:29:41 <shachaf> kini: You can fake it with operators, though.
18:29:54 <shachaf> foo |- some expression -| bar
18:30:06 <applicative> kini, like sum xs = 0 `fold (+)` xs
18:30:06 <JoeyA> mason_: If you constantly worry about those sneaky little issues before writing your application, you'll go mad.  Other such issues: asynchronous exceptions popping up anywhere, bottom values in unexpected places.
18:30:09 <cmccann> that's kind of horrible though.
18:30:16 <cmccann> and you'll feel guilty for abusing operators that way.
18:30:39 <kini> yeah I wasn't really wanting to do it, I was just curious
18:30:43 <applicative> cmccann: I wouldn't; but  I always forget my wacky plan before the next time I wan't to use it....
18:30:51 <cmccann> applicative: that's the other danger.
18:31:19 <cmccann> the other other danger is doing things that shachaf suggests.
18:31:21 <JoeyA> mason_: I recommend focusing on dividing your application into well-separated modules (a DB module, a connection module, etc.), writing your application, and *then* tackling such cross-cutting concerns.
18:31:24 <shachaf> I wan't to use it also.
18:31:39 <shachaf> cmccann: "suggests"?!
18:31:48 <shachaf> All I was doing was saying that it's possible!
18:31:57 <shachaf> Surely you can sympathize with saying that horrible things are possible.
18:32:07 <cmccann> yes.
18:32:14 <cmccann> doing things that I suggest is also unwise.
18:32:15 <aavogt> why's it so horrible?
18:33:19 <shachaf> I suggest that it was cmccann, on stack overflow, with the functional dependecy.
18:33:42 <cmccann> no, I've sworn off fundeps.
18:33:45 <cmccann> type families all the way.
18:33:52 <aavogt> also unrelated, is there a current package that has a quasiquoter like http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.3.1/doc/html/Language-Haskell-Meta-QQ-Hs.html
18:34:19 <statusfailed> Hullo everyone
18:34:29 <aavogt> benmachine split up the package and I think some of those QQ dissapeared
18:34:30 <cmccann> aavogt: anyway faking syntax via operators like that is a bit brittle and occasionally means not-quite what you want it to.
18:35:14 <cmccann> there are a few cases where "(f $ g x)" and "(f (g x))" are not equivalent, for example
18:35:28 <mason_> JoeyA: I got burned by writing multithreaded code (albeit not in haskell) enough times to stay clear from them whenever possible. maybe things are better in haskell, but.. is it even ok to have one thread reading from launched process stdout, while other writes to it's stdin? it doesnt say so in the docs as far as I can see.
18:36:00 <shachaf> mason_: Why not have one thread responsible for writing to the process, and then send messages to that thread?
18:36:06 <aavogt> cmccann: for f g x being expressions, not just plain variables?
18:36:21 <JoeyA> mason_: burned howso?
18:36:27 <shachaf> I think cmccann means rank-2 types or something.
18:36:54 <cmccann> yeah, rank-2 types is where that happens most often
18:37:10 <cmccann> especially when you have data constructors and lambdas floating around
18:37:13 <geekosaur> mason_: it will work as long as neither side blocks.  I am still not convinced that the runtime does nonblocking output, at least, properly.
18:38:00 <JoeyA> mason_: If you want to write an I/O-intensive program that works because you reasoned about it, not because you tested it, then Haskell is currently not the way to go.
18:38:01 <applicative> > let infixr 1 |-; x |- y = y x ; infixr 0 -| ; (-|) = ($) in 0 |- foldr (+) -| [1..10]
18:38:03 <lambdabot>   55
18:38:30 <aavogt> > runST $ do v <- newSTRef 0; modifySTRef (+1) v; readSTRef v
18:38:32 <lambdabot>   Couldn't match expected type `GHC.STRef.STRef s a0'
18:38:32 <lambdabot>              with actua...
18:38:33 <shachaf> JoeyA: What *is* the way to go?
18:38:37 <JoeyA> GHC chose to play the lightweight thread game, while O'Caml did not.
18:38:57 <mason_> I am not worried about performance but about correctness
18:39:04 <aavogt> > runST $ do v <- newSTRef 0; modifySTRef v (+1); readSTRef v
18:39:05 <geekosaur> even light vs. heavy threads may not matter much, if the runtime doesn't manage nonblocking I/O properly
18:39:05 <lambdabot>   1
18:39:42 <JoeyA> shachaf: IMHO, for Haskell, treat I/O in the traditional style: squash bugs with tests.
18:40:04 <JoeyA> Otherwise, use O'Caml (disclaimer: I'm going by hearsay)
18:40:21 <applicative> > runST $ do v <- newSTRef 0; modifySTRef v (+1); readSTRef v
18:40:23 <lambdabot>   1
18:41:08 <geekosaur> also note that managing "properly" includes the invoked program doing sensible things, and that there may be circumstances where there is no sensible thing that does not involve either blocking or throwing data away.
18:41:57 <JoeyA> mason_: I say this because I got burned pretty badly: socket I/O can't be interrupted on Windows, and nobody seems to care but me.
18:42:13 <dcoutts> mason_: reading to and from a launched processes stdin & stdout concurrently is fine
18:42:19 <geekosaur> other threads should at least continue to run in those cases if nonblocking I/O is being done correctly, but you can still effectively deadlock on communication with the subprocess, and no language or threading mechanism or programming technique will help in some cases
18:42:20 <mason_> geekosaur: if reading thread cant block then I am back at square one, looking for something like listen
18:43:03 <mason_> dcoutts: on all supported OSes?
18:43:09 <dcoutts> mason_: yes
18:43:17 <geekosaur> um, if ghc's runtime is doing the right thing then it is select()ing (or poll or more advanced techniques, especially in more recent ghc) and scheduling threads appropriately
18:43:18 <dcoutts> it doesn't say there's a restriction in the docs, because there is no restriction
18:43:23 <newsham> working on a small example haskell program.. wanted to know if there's a reasonable way to get rid of some of the IO without adding much complexity -- http://www.thenewsh.com/~newsham/x/machine/questions/questions2.hs
18:43:44 <JoeyA> geekosaur: Not for Windows.  On Windows, it uses blocking FFI calls (even the "nonblocking" methods do that).
18:43:46 <JoeyA> It's a mess.
18:44:09 <geekosaur> but at some point you can still end up with a subprocess that is not reading (or writing) data for whatever reason, and nothing you can do on the haskell end can help with a blocked subprocess
18:44:33 <geekosaur> JoeyA, so I have heard but I lack windows experience and I don't even know if it has suitable APIs
18:45:13 <dcoutts> JoeyA: the I/O situation on windows is not so good, mainly lack of dev resources to do it properly, the volunteers don't seem to care about windows
18:45:21 <geekosaur> mason_, you might explain the actual problem you're trying to solve
18:45:25 <JoeyA> It has I/O completion ports.  This doesn't support polling/non-blocking, but you can do efficient, scalable I/O with it.
18:45:34 <geekosaur> I'm talking egenralities but have no idea if they even apply to your situation
18:45:45 <mason_> geekosaur: I want to interact with chess engine
18:45:57 <dcoutts> JoeyA: though as far as I know it mostly means it's using more resources than necessary, rather than wrong. But yes that will not help for highly concurrent servers on windows.
18:46:23 <JoeyA> dcoutts: the other problem is that you can't interrupt an FFI call with an async exception.
18:46:34 <JoeyA> It wouldn't make sense.  C functions don't know what async exceptions are.
18:46:52 <dcoutts> JoeyA: right. Another thing that would work properly if we had an I/O manager impl on windows.
18:47:23 <dcoutts> it's totally possible, e.g. using io completion ports
18:47:26 <dcoutts> just work
18:47:27 <geekosaur> that's not nearly enough information...
18:47:27 <JoeyA> dcoutts: I tried to implement one.  It's difficult because the overlapped I/O API is sensitive to calling threads.
18:47:35 <JoeyA> It would need to be worked into the scheduler.
18:47:40 <dcoutts> hmm, really?
18:47:52 <dcoutts> I looked at this a bit, I didn't notice anything horrid
18:47:53 <JoeyA> dcoutts: http://hackage.haskell.org/trac/ghc/ticket/7353
18:48:06 <JoeyA> I implemented an I/O manager, but every I/O operation involves a context switch with this design.
18:48:35 <JoeyA> It funnels I/O requests into a thread, and allocates extra threads when there are multiple operations on the same handle.
18:49:16 <dcoutts> JoeyA: so I don't think you want to use threadWaitRead and threadWaitWrite at all
18:49:23 <JoeyA> dcoutts: the issues are: 1) When an OS thread exits, it cancels pending overlapped I/O  2) CancelIo cancels all pending I/O for a handle by the current thread.  CancelIoEx doesn't have this problem, but it was introduced in Vista.
18:49:33 <dcoutts> that approach relies on non-blocking IO, and that's just not how windows does it
18:49:37 <JoeyA> dcoutts: Right, that's another problem.
18:50:30 <dcoutts> it's not really a problem, it just means doing a different impl of an IODevice, rather than reusing the unix fd one
18:50:47 <dcoutts> the Handle infrastructure is set up to allow different implementations
18:50:48 <JoeyA> dcoutts: Tried that, too, but... http://hackage.haskell.org/trac/ghc/ticket/4144
18:51:20 <JoeyA> dcoutts: the BufferedIO interface needs nonblocking I/O funcs.
18:51:50 <mason_> blocking in the reading thread seems to work. I will just assume thats true until proven otherwise
18:52:18 <dcoutts> JoeyA: mm, that's a good point, the interface asks for both
18:52:26 <geekosaur> yes, while it's "nonblocking" at the scheduler level, your thread will not be scheduled until there is available input so to the thread it will look blocking
18:53:20 <JoeyA> dcoutts: Here was my initial approach: https://github.com/joeyadams/packages-base/blob/custom-device-fix/GHC/IO/BufferedIO.hs#L62
18:53:41 <JoeyA> Add readBuffered and writeBuffered, so devices can implement hGetBuf and hPutBuf themselves.  Add nonblocking variants too.
18:54:14 <JoeyA> Maybe we should just break BufferedIO entirely and only have it require readBuffered and writeBuffered.
18:54:32 <JoeyA> err, nevermind.  Just don't require nonblocking.
18:54:48 <JoeyA> (character I/O needs fill and flush)
18:57:37 <dcoutts> JoeyA: mm, tricky. And it's all there because Handle supports hGet/PutBufNonBlocking
18:57:56 <dcoutts> which again, you probably wouldn't need on windows
18:58:07 <JoeyA> dcoutts: another issue is that hGetSome currently (or used to) greedily grab all available bytes (up to the request)
18:58:26 <JoeyA> This means doing nonblocking reads after doing a blocking read to fill the buffer.
18:58:37 <dcoutts> JoeyA: you mean on windows, or in general?
18:58:50 <JoeyA> dcoutts: I mean in general. That's how it's currently implemented.
18:59:17 <JoeyA> (though the patch for #5843 changed that, I think)
18:59:27 <dcoutts> JoeyA: you're not confusing it with hGet? the hGetSome is there exactly because the hGet is too greedy
18:59:37 <JoeyA> Right.
19:00:07 <JoeyA> Should hGetSome 10000 stop if there's 1 byte in the byte buffer, but a subsequent nonblocking read could satisfy the entire read?
19:00:27 <JoeyA> Or should the caller simply call it again if they want more data?
19:00:58 <dcoutts> the latter I think
19:01:13 <dcoutts> well, maybe it's not even specified
19:01:37 <JoeyA> Right.
19:01:40 <dcoutts> certainly it should do at most one read()
19:01:54 <dcoutts> and not block, since there are bytes in the buffer
19:02:17 <JoeyA> dcoutts: but what if non-blocking read isn't available?
19:02:26 <dcoutts> :-)
19:03:00 <JoeyA> Why can't Unix conform to standards and not have nonblocking I/O?
19:03:07 <dcoutts> so I'd try and attack it by starting by ignoring the non-blocking bits, and go for the windows-style of aio, probably iocp
19:03:32 <JoeyA> dcoutts: but that doesn't address the interface issue.
19:03:40 <geekosaur> you can ignore nonblocking IO, you then run into all the buggy AIO implementations out there which is what you really should be complaining about
19:03:44 * geekosaur grumps
19:04:01 <geekosaur> nobody bothers with aio on unix because it's so broken on so many implementations
19:04:03 <dcoutts> geekosaur: we're talking about windows, nobody would ever want to use linux aio :-)
19:04:14 <geekosaur> [10 22:02] <JoeyA> Why can't Unix conform to standards and not have nonblocking I/O?
19:04:47 <dcoutts> on windows, IO completion ports are probably the best way to manage lots of IO with reasonable resource use
19:05:08 <dcoutts> JoeyA: I'd avoid WaitForMultipleObjects, it also has a limit of 64 or something like that
19:05:09 <JoeyA> I tried to implement interruptible I/O for the network package using select() (only on Windows), but couldn't because BufferedIO doesn't have the right interface.
19:05:23 <JoeyA> dcoutts: There's RegisterWaitForSingleObject, which is pretty scalable.
19:05:29 <JoeyA> But I don't think you can poll files with it.  I don't know.
19:05:46 <JoeyA> (RegisterWaitForSingleObject lets the OS do the thread pooling for you)
19:05:51 * dcoutts wasn't aware of RegisterWaitForSingleObject
19:05:59 <JoeyA> So you can do about 20000 simultaneous waits or so.
19:06:50 <dcoutts> JoeyA: any advantage over using IOCP?
19:07:06 <dcoutts> looks like under the hood it's basically the same mechanism
19:07:08 <JoeyA> Well, if polling were available, it would fit in with the existing infrastructure a little better.
19:07:23 <JoeyA> (which assumes polling-based I/O)
19:08:28 <dcoutts> JoeyA: so when you say BufferedIO doesn't have the right interface, you mean because it also includes the non-blocking versions?
19:09:02 <JoeyA> dcoutts: Right.
19:09:41 <JoeyA> It assumes you can use nonblocking reads to squeeze more bytes out of the device without blocking.
19:10:05 <JoeyA> You'd need this to implement buffered reads that don't look like buffered reads from the outside.
19:10:06 <dcoutts> JoeyA: I bet we could emulate it ok. Afterall, disk files on linux don't support non-blocking IO
19:11:00 <JoeyA> dcoutts: I suppose you could by reading ahead.  This might be a great solution for stream devices.
19:11:07 <dcoutts> though it might be better to do it in the Handle layer rather than the io device
19:12:36 <dcoutts> JoeyA: would it work to emulate by just saying if there's no bytes in the buffer, then we init a read and return
19:13:03 <JoeyA> dcoutts: not if the caller expects a nonblocking read to return bytes after hWaitForInput returned True.
19:13:34 <JoeyA> I suppose hWaitForInput (IODevice.ready) could issue the read...
19:14:12 <dcoutts> JoeyA: right, init a read, wait for it to return (partly filling the buffer)
19:15:08 <JoeyA> Another issue is nonblocking write.  With the BufferedIO interface, if we write bytes to the buffer, do a nonblocking flush, and it only flushes some of them, what do we return?
19:15:25 <JoeyA> Can't return the number of bytes written to the buffer, because then the caller will think those bytes are going down the wire.
19:15:28 <dcoutts> JoeyA: btw, I have a new implementation of the Handle buffer layer. I wrote it for bytestring but it might be useful to you too
19:15:45 <JoeyA> dcoutts: Where is it?
19:16:04 * dcoutts notices he hasn't pushed it to the public repo yet
19:16:23 <dcoutts> JoeyA: I can email it to you, it's mostly complete but not quite enough to include in bytestring yet
19:17:00 <dcoutts> na, I'll just upload it ...
19:19:47 <dcoutts> JoeyA: oh, wrong machine, I don't have the latest version with all the QC tests
19:19:55 <dcoutts> JoeyA: this is an older version http://code.haskell.org/~duncan/ByteString-IO.hs
19:20:55 * dcoutts is actually rather pleased with the QC tests for the buffering strategies
19:22:32 <dcoutts> JoeyA: anyway, my general advice would be to go for the windows style of IO, not try to shoehorn it into the unix style, possibly by making the BufferedIO explicitly indicate if it supports non-blocking
19:22:39 <dcoutts> and then make the Handle layer do something sensible to emulate hGetBufNonblocking
19:23:06 <dcoutts> ie do it properly on the inside, and emulate for the users that insist on using hGetBufNonblocking
19:23:42 * dcoutts disappears
19:32:25 <hue_> could please someone explain this f :: Num a :: a -> a -> a  g :: Num a :: a -> a g = f 3  g y ⇔ 3*3 + y*y
19:33:43 <shachaf> I think you mean =>, not ::
19:33:46 <shachaf> What's confusing about it?
19:34:01 <arbn> hue_: I can't mentally parse that. Could you use hpaste and newlines?
19:34:31 <hue_> it is a tutorial http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/ there
19:35:04 <arbn> hue_: In what section?
19:35:17 <hue_> More precisely f 3 4 is equivalent to (f 3) 4. Note f 3 is a function: serach that
19:36:23 <monochrom> do you agree: f 3 :: Num a => a -> a ?
19:36:36 <monochrom> or at least: f 3 :: Something -> Something ?
19:37:44 <arbn> monochrom: Yeah. Looks like a typo in that tutorial. It's definitely Num a => a -> a -> a
19:37:52 <mason_> is that a good turorial? learn haskell the hard way
19:39:02 <arbn> "f x y = x*x + y*y" and "g = f 3" so g y <=> 3*3 + y*y
19:39:18 <arbn> hue_: What about this don't you understand?
19:39:44 <monochrom> arbn, there is no typo. and I am talking about f 3, not f
19:40:27 <arbn> monochrom: OK. I guess that syntax is introduced earlier in the tutorial.
19:44:40 <hue_> weird
19:46:55 <hue_> if f "takes" 2 arguments shoulnt it fail when is only given 1
19:47:08 <hue_> and also what is <=>
19:47:26 <monochrom> the tutorial says, "Yes, strange. In fact, in Haskell no function really has two arguments. Instead all functions have only one argument. But we will note that taking two arguments is equivalent to taking one argument and returning a function taking the second argument as parameter."
19:47:27 <kennyd> all haskell functions take one argument
19:47:43 <arbn> hue_: Partial application. In Haskell applying a function to one value returns a function that takes the rest.
19:47:48 <monochrom> therefore, f can take just one argument
19:47:59 <kennyd> > map (+10) [1..5]
19:48:01 <lambdabot>   [11,12,13,14,15]
19:48:10 <kennyd> :t (+)
19:48:11 <lambdabot> Num a => a -> a -> a
19:48:47 <monochrom> you can say, f is a function from Int to (Int->Int), or Integer to (Integer->Integer), or Double to (Double->Double), etc
19:48:58 <Nereid> f :: Int -> (Int -> Int)
19:49:13 <monochrom> a->a->a is shorthand for a->(a->a)
19:49:34 <arbn> hue_: Earlier in the tutorial, "I use the ⇔ symbol to state that two expression are equivalent. It is a meta notation, ⇔ does not exists in Haskell. I will also use ⇒ to show what is the return of an expression."
19:50:09 <arbn> There's another typo here... should be "exist" there.
19:50:59 <hue_> later in the tutorial
19:51:51 <arbn> hue_: Oh, so it is. Heh.
19:52:08 <arbn> hue_: Yeah... I guess the author decided to use notation before explaining it.
19:52:11 <unlink> Is there any reasonably complete, up-to-date documentation for regular expressions out there?
19:52:36 <hue_> dont think so
19:52:41 <hue_> hoogle ;D?
19:53:20 <unlink> I'll be damned if I can make a single example compile.
19:53:30 <hue_> someone should make and editable online tutorial like a wiki
19:53:45 <hue_> an*
19:53:49 <unlink> I'm not particularly interested in computing the instance derivations myself.
19:54:02 <monochrom> that's http://en.wikibooks.org/wiki/Haskell
19:54:55 <hue_> i guess i didnt look where i had to
19:55:23 <monochrom> no no
19:55:33 <hue_> seems old  / /_\// /_/ / /  | |      GHC Interactive, version 6.6, for Haskell 98.
19:55:48 <monochrom> if you actually found Haskell the Hard Way, you already did more searching than you should
19:55:56 <arbn> hue_: LYaH is a pretty solid way to learn Haskell. It takes a bit longer than going through a quick tutorial, though.
19:56:03 <monochrom> most people would just find LYAH and RWH
19:56:08 <hue_> gotta edit
19:56:17 <mason_> lyah is great
19:56:22 <hue_> haskell has changed a lot
19:56:34 <hue_> some thing wont work in those tutos
19:56:38 <monochrom> the reason you did not know http://en.wikibooks.org/wiki/Haskell is that few people use it anymore, so no one talks about it
19:56:39 <Nereid> oh man I remember that ghci banner.
19:56:47 <Nereid> how long has it been.
19:57:20 <shachaf> Nereid: You can always use Idris if you want "the banner experience"!
19:57:20 <arbn> hue_: Just read LYaH. Then, you'll be ready to learn from Haddocked API docs and scattered blog posts, like the rest of us. :P
19:57:21 <monochrom> and my point is: you wish for an editable wiki-like tutorial? it already exists, now look how many people care
20:02:46 <hue_> ok
20:04:38 <mason_> is there a way to intercept Ctrl+C, to clean the messes before quitting?
20:05:37 <arbn> mason_: Well, what sort of "mess" have you made? Maybe the solution is to make less of one.
20:06:18 <mason_> I have launched a process and I want to terminate it before quitting
20:06:29 <monochrom> when ctrl-c happens, the main thread receives exception UserInterrupt (value) of AsynException (type)
20:07:15 <Nereid> at least the first time, on linux. the second time it just dies.
20:07:27 <Nereid> unless you register your own signal handler.
20:08:59 <mason_> monochrom: so just catching haskell exception will do it?
20:09:16 <monochrom> I would do that first
20:10:02 <mason_> or maybe just use finally? if it works the way I expect it to
20:10:58 <mason_> (have yet to use exceptions in haskell)
20:11:31 <monochrom> to clean up, finally suffices
20:18:27 <mason_> nice it worked
20:18:40 <mason_> thanks
20:18:45 <`nand`> I think I found the haskell wikibook first, got interested by it, and then found LYAH
20:18:54 <mason_> good night all
20:38:32 <peanuts> help! http://pastebin.com/jgs0UwPY
20:38:40 <mauke> The paste jgs0UwPY has been copied to http://hpaste.org/80562
20:39:12 <shachaf> peanuts: Did you try what it said to try?
20:40:11 <peanuts> shachaf: sorry. i'm a bit confused as to why cabal is talking about eselect. i'm asking in #gentoo-haskell
20:40:32 <monochrom> yes, because there is a "$ eselect wxwidgets list"
20:40:44 <ivanm> peanuts: see line 65
20:40:56 <ivanm> eselect wxwidgets set 1
20:41:00 <peanuts> i understand i should try that
20:41:09 <peanuts> but i want to know what i am doing
20:41:45 <peanuts> oh, i see...
20:41:50 <monochrom> it is not really cabal talking about eselect. it is wxc's Setup calling wx-config
20:41:56 <peanuts> wx-config is talking about eselec-yeah
20:42:37 <Tordek> I'm trying to install wx, too, but I get a different error: wxc-0.90.0.4 failed during the configure step. The exception was:
20:42:40 <Tordek> ExitFailure 1
20:43:36 <Tordek> (also, if I manually run Setup.hs configure, I get Setup.hs: At least the following dependencies are missing:
20:43:39 <Tordek> wxdirect >=0.90
20:44:00 <Tordek> but that is already installed
20:44:24 <hpaste> “Anonymous Coward” pasted “cabal install wx” at http://hpaste.org/80563
20:44:38 <peanuts> help! http://hpaste.org/80563
20:44:53 * peanuts laughs
20:45:18 <monochrom> do you have the c-side libs of wx?
20:47:20 <peanuts> monochrom: no! i see it in the repo though. dev-haskell/wxc
20:47:33 <peanuts> "wxHaskell C++ wrapper"
20:47:41 <peanuts> why would a haskell lib need a C++ wrapper?
20:48:35 <peanuts> oh, it looks like cabal knows about wxc too
20:48:50 <monochrom> wait, base-unicode-release-2.8? --version=2.9?
20:48:55 <peanuts> it says i need wxWidgets 2.9
20:49:24 <monochrom> wxc wants 2.9 but you are at 2.8?
20:49:46 <monochrom> perhaps you need a different version of wxc, one that accepts 2.8
20:50:17 <peanuts> okay, so i have x11-libs/wxGTK installed...
20:50:28 <peanuts> there is no package called wxWidgets
20:53:18 <hpaste> peanuts pasted “cabal install wxc” at http://hpaste.org/80564
21:12:20 <perrth> how to install an in-place ghc 7.6.1?
21:12:41 <SamanthaD> Hello World
21:12:49 <Clint> yes
21:13:13 <perrth> in windows
21:56:06 <shachaf> Can you find a q such that (q t s -> q b a) ~~ ((a -> f b) -> s -> f t), for some f?
21:56:44 <Nereid> why do you want these perverse lenses.
21:56:51 <hpaste> bobajett pasted “basic syntax question” at http://hpaste.org/80567
21:57:05 <shachaf> Nereid: Don't you want to be able to turn lenses around?
21:57:13 <Nereid> no, that's weird :(
21:57:31 <shachaf> Nereid: Well, just plain prisms.
21:57:38 <SamanthaD> I like looking through telescopes backwards!
21:57:39 <shachaf> Don't you want to be able to turn a prism around and get a getter?
21:57:42 <simpson> Turn the lens around~
21:57:46 * SamanthaD waves at shachaf and Nereid
21:57:47 <simpson> Look at things all blurry~
21:57:50 <shachaf> See? SamanthaD knows what's up.
21:58:15 <bobajett> all your problems look so small when you view them that way thru a telescope :-)
21:58:40 <Nereid> shachaf: we can already do that.
21:58:47 <Nereid> sorta.
21:58:59 <shachaf> Nereid: True. But don't you want a single function that can do it to both prisms and isomorphisms?
21:59:05 <shachaf> Pseudonym also knows what's up. Though in that case it isn't about lenses so much.
21:59:12 <Nereid> well we can do that too.
21:59:14 <bobajett> a little help with a basic syntax question? http://hpaste.org/80567
21:59:18 <Nereid> because isomorphisms are prisms.
21:59:24 <Pseudonym> I'm a bit shaky on bananas and barbed wire, too.
21:59:31 <shachaf> Pseudonym: Not that kind of lens.
21:59:48 <SamanthaD> bobajett: what's the question?
21:59:52 <shachaf> Nereid: We don't have one function that can (a) turn an iso into the reverse iso and (b) turn a prism into a getter.
21:59:59 <Pseudonym> I know a thing or two about optical lenses, if that's what you mean.
22:00:07 <Nereid> bobajett: if n > 100 then ... else ...
22:00:10 <Nereid> bobajett: or use a guard:
22:00:10 <shachaf> Pseudonym: I meant the Haskell kind.
22:00:14 <Nereid> convert n | n > 100 = ...
22:00:15 <Pseudonym> Ah.
22:00:17 <Nereid>         | otherwise = ...
22:00:19 <bobajett> SamanthaD: sorry I put the question in the hpaste as well.
22:00:27 <SamanthaD> bobajett: Oh, I see
22:00:34 <Nereid> shachaf: truie.
22:00:35 <Nereid> true
22:00:50 <shachaf> Nereid: Anyway, that already works in bizarro-lens-world!
22:01:00 <shachaf> Pretty great, right?
22:01:02 <Nereid> I don't want to go to bizarro-lens-world, it's too scary.
22:01:17 <shachaf> Stop being so scared, man.
22:01:23 <shachaf> SamanthaD and Pseudonym aren't scared.
22:02:07 <SamanthaD> bobajett: I would use guards
22:02:18 <Nereid> me too
22:02:23 <SamanthaD> speaking of...
22:02:29 <Pseudonym> The only things we have to fear are fear itself, and zombies.
22:02:30 <_hemanth_> ghci> doubleMe x = x + x
22:02:30 <_hemanth_> <interactive>:5:12: parse error on input `='
22:02:39 <_hemanth_> new to haskell, why that issue?
22:02:45 <Nereid> _hemanth_: you need a "let" in front of definitions in ghci
22:02:54 <shachaf> Pseudonym: And bizarro-lenses.
22:03:07 <_hemanth_> Nereid, kool, from which version was let started?
22:03:12 <Nereid> forever
22:03:17 <Pseudonym> Since do-notation.
22:03:26 <Pseudonym> So not quite forever.
22:03:35 <Nereid> may as well be forever
22:03:37 <Pseudonym> Yeah.
22:03:48 <bobajett> SamanthaD: and Nereid: but if I do that the solution looks too verbose to me:
22:03:51 <hpaste> bobajett pasted “basic syntax question” at http://hpaste.org/80568
22:04:09 <_hemanth_> Nereid, yikes, was going through http://learnyouahaskell.com/ wrong site ?
22:04:09 <Nereid> bobajett: you can use a while clause to use the same definition for d and c
22:04:25 <Nereid> bobajett: also, you probably want d > 2, not n > 100
22:04:38 <Nereid> _hemanth_: no
22:04:40 <bobajett> you mean d > 1 :-)
22:04:48 <Nereid> bobajett: gah, I thought I typed that.
22:04:52 <Pseudonym> 256 `divRem` 100
22:04:56 <Pseudonym> > 256 `divRem` 100
22:04:57 <lambdabot>   Not in scope: `divRem'
22:05:00 <Nereid> I had it right in my head but it came out my fingers wrong.
22:05:02 <Pseudonym> Uhm.
22:05:06 <Nereid> Pseudonym: that doesn't exist. divMod or quotRem
22:05:10 <Nereid> don't mix them up :p
22:05:12 <Pseudonym> That's right.
22:05:13 <_hemanth_> Nereid, any other suggestion?
22:05:21 <Nereid> _hemanth_: LYAH is fine.
22:05:21 <Pseudonym> In my defence, bobajett mixed them up.
22:05:25 <shachaf> @let divRem x y = (x `div` y, x `rem` y)
22:05:26 <lambdabot>  Defined.
22:05:30 <shachaf> There you go!
22:05:34 <Nereid> _hemanth_: you don't need let for top-level definitions in haskell source files.
22:05:38 <_hemanth_> Nereid, it does not have let
22:05:46 <Hafydd> @let quotMod x y  = (x `quot` y, x `mod` y)
22:05:47 <Nereid> _hemanth_: but ghci is not the top level of a haskell source file.
22:05:48 <lambdabot>  Defined.
22:05:53 <shachaf> > (-5) `divRem` 20
22:05:54 <Nereid> Hafydd: please no :(
22:05:56 <lambdabot>   (-1,-5)
22:06:01 <shachaf> Perfect.
22:06:04 <SamanthaD> bobajett: what about then using a where statement with an if-then-else?
22:06:04 <Nereid> shachaf: please no :(
22:06:06 <slack1256> > quotMod 5 2
22:06:07 <lambdabot>   (2,1)
22:06:13 <shachaf> @let divQuot x y = (x `div` y, x `quot` y)
22:06:15 <lambdabot>  Defined.
22:06:17 <Hafydd> XD
22:06:25 <Pseudonym> But I want remDiv.
22:06:46 <hpaste> Nereid annotated “basic syntax question” with “basic syntax question (annotation)” at http://hpaste.org/80568#a80569
22:06:51 <_hemanth_> Nereid, okies thanks :)
22:07:17 <Nereid> actually, quotRem is probably more appropriate for this application.
22:07:20 <hpaste> “Anonymous Coward” annotated “basic syntax question” with “basic syntax question (annotation)” at http://hpaste.org/80568#a80570
22:07:22 <Nereid> but whatever.
22:07:29 <Nereid> (the difference is when n is negative)
22:08:23 <bobajett> Nereid: sweet!
22:08:29 <PatrickRobotham> I didn't know about divMod!
22:08:45 <Nereid> also I'd do something about cents too.
22:09:09 <Nereid> else you might have 5 dollars and 1 cents.
22:09:19 <_hemanth_> > ['woo']+'t'
22:09:21 <lambdabot>   Syntax error on 'woo'
22:09:21 <lambdabot>  Perhaps you intended to use -XTemplateHaskell
22:09:28 <_hemanth_> why not?
22:09:41 <SamanthaD> I, for one, don't have any cents...
22:09:42 <Nereid> because '' is for single characters
22:09:42 <slack1256> > "woo" ++ "t"
22:09:44 <lambdabot>   "woot"
22:09:49 <Pseudonym> Or:
22:09:54 <Pseudonym> > "woo" ++ ['t']
22:09:56 <lambdabot>   "woot"
22:10:00 <Pseudonym> Also:
22:10:07 <Pseudonym> > snoc "woo" 't'
22:10:09 <lambdabot>   Not in scope: `snoc'
22:10:09 <lambdabot>  Perhaps you meant one of these:
22:10:09 <lambdabot>    `BS.snoc' (importe...
22:10:10 <bobajett> SamanthaD: my spidey syntax senses were tingling with the verbose stuff I wrote, but Nereid's solution makes clear that I needed a "where", and that would work nice with an "if d > 1 then ..dollars else ..dollar" too.
22:10:20 <Pseudonym> Once you've imported it, anyway.
22:10:25 <slack1256> > ['w', 'o', 'o'] ++ ['t']
22:10:26 <lambdabot>   "woot"
22:11:08 <_hemanth_> kool!
22:11:17 <SamanthaD> bobajett: awesome! Nereid's solution isn't what I meant. I meant that you would replace "dollars" with a variable and then define said variable in the where statement. His solution is more elegant though.
22:11:34 <hpaste> PatrickRobotham annotated “basic syntax question” with “basic syntax question (annotation) (annotation)” at http://hpaste.org/80568#a80572
22:11:58 <bobajett> oh like so ^^^^
22:12:46 <_hemanth_> http://s3.amazonaws.com/lyah/listmonster.png sweet!
22:12:49 <bobajett> cool thanks guys
22:12:50 <Nereid> PatrickRobotham: I was about to paste sometihng like that. except
22:12:51 <Nereid> not quite
22:12:52 <Pseudonym> > let cents c = show c ++ " cent" ++ ['s'|c/=1] in [ cents i | i <- [0..2] ]
22:12:54 <lambdabot>   ["0 cents","1 cent","2 cents"]
22:13:31 <bobajett> http://shuklan.com/haskell/lec01.html#/0/8
22:13:57 <bobajett> damn Haskell! didn't realize Im sitting here on a Friday night!
22:14:04 <bobajett> oh its Thursday. :-)
22:14:22 <hpaste> Nereid annotated “basic syntax question” with “basic syntax question (annotation) (annotation) (annotation)” at http://hpaste.org/80568#a80573
22:14:32 <Nereid> less duplication of code.
22:15:01 <Pseudonym> Nereid, won't that claim "0 cent"?
22:15:06 <Nereid> true.
22:15:09 <Nereid> replace > with /=
22:15:20 <PatrickRobotham> And now to incorporate Pseudonym's idea!
22:15:39 <Nereid> now make it work in Russian
22:16:05 <hpaste> PatrickRobotham annotated “basic syntax question” with “basic syntax question (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/80568#a80574
22:16:22 <Nereid> I like the list comprehension.
22:16:37 <PatrickRobotham> Now it's idiomatic haskell!
22:16:43 <Nereid> =D
22:17:10 <SamanthaD> Haha, Nereid implemented my idea and made it actually not look like a mesS!
22:17:12 <shachaf> > let cents = join $ run (later show . now " cent" . onlyif (/=1) "s") in [cents i | i <- [0..2]]
22:17:12 <bobajett> nice!
22:17:14 <PatrickRobotham> (If your function takes more than one line, you've done something wrong)
22:17:14 <lambdabot>   ["0 cents","1 cent","2 cents"]
22:17:17 <shachaf> I don't like that that join.
22:17:34 <shachaf> I wonder if you can adapt that to ask for the same value multiple times?
22:17:36 <Nereid> :t onlyif
22:17:37 <lambdabot> Monoid m => (t1 -> Bool) -> m -> (m -> t) -> m -> t1 -> t
22:17:42 <Nereid> oh yeah your silly thing.
22:17:44 <PatrickRobotham> :t later
22:17:45 <lambdabot> Monoid m => (t1 -> m) -> (m -> t) -> m -> t1 -> t
22:17:47 <Nereid> when did that make it into lambdabot
22:17:56 <shachaf> Nereid: When @let was invented.
22:18:01 <latro`a> lol
22:18:02 <bobajett> :t join
22:18:03 <lambdabot> Monad m => m (m a) -> m a
22:18:06 <Nereid> :(
22:18:20 <PatrickRobotham> We've given shachaf too much power :P
22:19:18 * Pseudonym points out that shows is even more idiomatic Haskell
22:19:40 <_hemanth_> > take -1 [1,2,3]
22:19:42 <lambdabot>   Could not deduce (GHC.Num.Num
22:19:42 <lambdabot>                      ([t0] -> GHC.Types.Int -...
22:19:54 <Nereid> try (-1)
22:19:54 <shachaf> Pseudonym: shows would be better here, of course.
22:19:57 <_hemanth_> that was foolsih ;)
22:20:07 <shachaf> Pseudonym: The nice thing about now and later is taking arguments.
22:20:14 <Nereid> > take (-1) [1,2,3]
22:20:15 <lambdabot>   []
22:20:16 <_hemanth_> wow
22:20:23 <shachaf> > run (now "x = " . later show . now ", y = " . later show) 2 4
22:20:24 <lambdabot>   "x = 2, y = 4"
22:20:28 <_hemanth_> awesome!
22:20:32 <shachaf> Like a type-safe printf.
22:20:45 <PatrickRobotham> :t shows
22:20:46 <lambdabot> Show a => a -> ShowS
22:21:00 <Nereid> ShowS = String -> String
22:21:07 <PatrickRobotham> Ah.
22:21:16 <Pseudonym> > let cents c = shows c . showString " cent" . (if c == 1 then id else showChar 's') $ "" in [ cents i | i <- [0..2] ]
22:21:16 <PatrickRobotham> shows 9 "a"
22:21:17 <shachaf> Nereid: Can you adapt this now/later thing to let you ask for the same argument multiple times?
22:21:18 <lambdabot>   ["0 cents","1 cent","2 cents"]
22:21:22 <PatrickRobotham> > shows 9 "a"
22:21:23 <lambdabot>   "9a"
22:21:43 <Nereid> shachaf: I don't know how your thing works.
22:21:45 <Nereid> I haven't looked.
22:21:55 <mauke> everyone who thinks this is like a type-safe printf doesn't understand what makes printf great, IMHO
22:22:00 <shachaf> Nereid: We simplified it.
22:22:08 <Nereid> where is it.
22:22:09 <shachaf> mauke: I know, I know. It's still neat.
22:22:13 <shachaf> Nereid: @let now a k b = k (b <> a); later f k m a = k (m <> f a); run l = l id mempty
22:22:41 <mauke> in fact, most "type-safe printf"s suck
22:22:47 <Pseudonym> Actually...
22:22:56 <Nereid> :t (now,later,run)
22:22:57 <lambdabot> (Monoid a1, Monoid m1, Monoid m) => (m -> (m -> t) -> m -> t, (t2 -> m1) -> (m1 -> t1) -> m1 -> t2 -> t1, ((a -> a) -> a1 -> t3) -> t3)
22:23:11 <Pseudonym> > let cents c = shows c . showString " cent" . $ ['s'|c/=1] in [ cents i | i <- [0..2] ]
22:23:11 <Nereid> I shouldn't have done that.
22:23:12 <lambdabot>   <hint>:1:46: parse error on input `$'
22:23:15 <Pseudonym> Hmm.
22:23:19 <mauke> . $
22:23:22 <Pseudonym> > let cents c = shows c . showString " cent" $ ['s'|c/=1] in [ cents i | i <- [0..2] ]
22:23:24 <lambdabot>   ["0 cents","1 cent","2 cents"]
22:23:29 <_hemanth_> > 4 in [1,2,3,4]
22:23:30 <lambdabot>   <hint>:1:3: parse error on input `in'
22:23:37 <shachaf> Pseudonym: That's just luck!
22:23:46 <Pseudonym> Almost ready for the IOHCC.
22:23:54 <_hemanth_> would be fun, why `elem` :|?
22:24:05 <mauke> _hemanth_: what
22:24:09 <Nereid> in is a keyword, and even if it wasn't, it couldn't be used infix.
22:24:10 <_hemanth_> can we alias `elem` to in?
22:24:16 <PatrickRobotham> mauke: We got rid of all that formatting nonsense.
22:24:17 <shachaf> Can you use MonadComprehensions there to keep the nice comprehension syntax?
22:24:23 <shachaf> I guess (r ->) isn't MonadPlus.
22:24:23 <_hemanth_> oh ok
22:24:28 <mauke> PatrickRobotham: that's one of the problems
22:24:33 <_hemanth_> mauke, nothing!
22:24:37 <Nereid> > let x = 5 in x+1
22:24:38 <lambdabot>   6
22:24:51 <_hemanth_> :)
22:25:03 <mauke> _hemanth_: even if 'in' wasn't a keyword, it's much too short
22:25:05 <shachaf> λ> let (∈) = elem in 4 ∈ [1,2,3,4]
22:25:05 <shachaf> True
22:25:14 <Pseudonym> Actually, even more idiomatic would be to use Text.PrettyPrint.HughesPJ.
22:25:39 * _hemanth_ agrees 
22:25:54 <statusfailed> What does "global constraint requires installed
22:25:58 <statusfailed> instace" mean?
22:26:01 * _hemanth_ oh man! just loving it!
22:26:05 <statusfailed> instance*
22:26:12 <mauke> (the magic word is huffmanization)
22:32:09 <_hemanth_> > let l = [1,"hemanth','x']
22:32:10 <lambdabot>   <hint>:1:26:
22:32:10 <lambdabot>      lexical error in string/character literal at end of input
22:32:18 <_hemanth_> :(
22:32:34 <Nereid> lambdabot only does expressions.
22:32:41 <Nereid> with >, anyway
22:32:49 <shachaf> lambdabot also doesn't do syntax errors. Or type errors.
22:32:52 <Nereid> true.
22:32:59 <shachaf> So that wasn't going to work.
22:33:01 <mm_freak> it does "do" them
22:33:52 <_hemanth_> cant mix types in list?
22:34:16 <bobajett> _hemanth_: nope
22:34:16 <Nereid> nope
22:34:32 <_hemanth_> hmm
22:34:41 <mm_freak> _hemanth_: a list of type [a] is either the empty list or an element of type 'a' prepended to another list of type [a]
22:35:00 <_hemanth_> okies
22:35:08 <mm_freak> heath: forget the "nopes" you've got from others…  try to answer that question yourself
22:35:18 <mm_freak> @ _hemanth_
22:35:44 <_hemanth_> mm_freak, :)
22:36:02 * shachaf suspects that mm_freak's definition is only helpful to someone who already knows the answer.
22:36:26 <SamanthaD> Could anyone recommend a good tutorial covering how to reason about performance in haskell?
22:36:33 <mm_freak> shachaf: i'm the counterexample
22:36:43 <PatrickRobotham> SamanthaD: I can only think of Purely Functional Data Structures
22:36:43 <shachaf> SamanthaD: tibbe had some nice slides.
22:36:57 <shachaf> SamanthaD: Hmm, those might be lower-level than what you want.
22:37:09 <SamanthaD> PatrickRobotham: Thanks!
22:37:19 <SamanthaD> shachaf: no, I want to know the nitty gritty!
22:37:36 <shachaf> SamanthaD: A good understanding of laziness -- at a high level -- is very useful, before you get to worrying about constant factors.
22:37:47 <shachaf> I don't know how much of that you have. I think you were having some confusion with that the other day?
22:37:58 <SamanthaD> PatrickRobatham: Do you know if the current edition is significantly better than the edition that's available online?
22:37:59 <slack1256> this. what shachaf said!
22:38:01 <PatrickRobotham> shachaf: Sorry to flake out on you with the lens stuff.
22:38:02 <_hemanth_> shachaf, no mm_freak defination was neat!
22:38:09 <PatrickRobotham> SamanthaD: No, I haven't actually read the book.
22:38:24 <mm_freak> _hemanth_: i hope it also answers your question =)
22:38:27 <shachaf> I haven't read the book either.
22:38:32 <SamanthaD> PatrikRobotham: Oh, okay. Thanks though!
22:38:37 <mauke> @src []
22:38:37 <lambdabot> data [] a = [] | a : [a]
22:38:37 <_hemanth_> mm_freak, yes! very much
22:38:40 * PatrickRobotham bluffs
22:38:54 <SamanthaD> shachaf: I've been meaning to read that book but for different reasons. I just wanted to know about functional data structures!
22:38:54 <PatrickRobotham> The bluffer's guide to haskell: Make lots of monad and category theory jokes.
22:39:01 <shachaf> SamanthaD: Here are tibbe's slides: http://blog.johantibell.com/2010/09/slides-from-my-high-performance-haskell.html
22:39:05 <bobajett> _hemanth_: how far are you into LYAH?
22:39:20 <PatrickRobotham> What's a good book for a second course in haskell?
22:39:21 <shachaf> SamanthaD: (He did that talk at bahaskell once! Last year, I think.)
22:39:21 <SamanthaD> shachaf: Thanks for the slides
22:39:25 <PatrickRobotham> After LYAH?
22:39:37 <_hemanth_> bobajett, started today, now in "Types and Typeclasses" heh heh
22:40:22 <SamanthaD> shachaf: you're gonna keep luring me into your little group now, ain'cha?!
22:40:43 <shachaf> SamanthaD: I heard it's the place to be!
22:41:17 <PatrickRobotham> shachaf: What's the group?
22:41:26 <SamanthaD> shachaf: why the heck not? You can do worse than spend an afternoon with a bunch of math nerds!
22:41:29 <PatrickRobotham> Oh right, bahaskell.
22:41:32 <shachaf> PatrickRobotham: Bay area Haskell. It's not particularly mine.
22:41:58 <bobajett> is bahaskell safe for newbies? :-)
22:42:14 <SamanthaD> bobajett: I hope so, I'm pretty new myself.
22:42:15 <shachaf> Yes!
22:42:36 <bobajett> I haven't even gotten to Monads yet :-)
22:42:50 <SamanthaD> shachaf: is it full of kind gurus looking to adopt a newbie? *assumes her cute puppy eyes*
22:43:20 <bobajett> adoption sounds great, I've been learning tons just hanging around here
22:44:12 <SamanthaD> bobajett: Yes... the people in #haskell are invaluable when the books come up short.
22:44:28 <shachaf> SamanthaD: It's pretty friendly toward humans. I'm not sure about puppies.
22:44:44 <Pseudonym> Puppies are yet to grasp the basics of abstract algebra.
22:44:58 <slack1256> A friend told me he wanted to stop fighting with the language and embrace the non-strict idioms
22:45:12 <bobajett> SamanthaD: btw thanks! I had no idea Purely Functional Data Structures was available online. It's been sitting in my Amazon wishlist for years.
22:45:23 <slack1256> the thing is, that i don't know many, the trick with the memoization of the lazy arrays is cool, and tying the knot is useful.
22:45:26 <shachaf> Is it?
22:45:30 <SamanthaD> bobajett: apparently it's an older version, though...
22:45:32 <shachaf> Are you talking about http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf ?
22:45:33 <slack1256> but where could i get more non-strict idioms?
22:45:50 <SamanthaD> bobajett: I'm pretty tight on cash right now but if there's a tonne of new stuff it that book... I dunno...
22:46:00 <bobajett> shachaf: yep thats the one I found by Googling after I heard it from SamanthaD
22:46:03 <Nisstyre> slack1256: "ones = 1 : ones" ?
22:46:08 <Pseudonym> slack1256, have you looked at the haskell wiki?
22:46:14 <Pseudonym> TBH, the best way is just to play.
22:46:21 <shachaf> That PDF is a PhD thesis. The book is a book.
22:46:28 <slack1256> yes, in fact I was thinking on expanding it
22:46:37 <shachaf> I think they're fairly different?
22:46:44 <slack1256> the trick of memoization with lazy arrays is incomplete.
22:46:52 * lispy discovers that his agda install is broken...again
22:47:00 * lispy quickly blames 'cabal'
22:47:00 <bobajett> oh ok. next year then.
22:47:11 <Nisstyre> slack1256: one thing is doing corecursion with unfold, there are probably a fair number of uses for that
22:47:13 <shachaf> bobajett: Not to say that you shouldn't read it!
22:47:24 <shachaf> Also there are lots of other ways of learning about purely functional data structures.
22:47:30 <SamanthaD> shachaf: I suppose... maybe the book would be more digestable. Either way, I'm knee deep in a theory-heavy Haskell book as it is.
22:47:32 <Pseudonym> slack1256: http://www.haskell.org/haskellwiki/Memoising_CAFs
22:47:55 <shachaf> Which one?
22:47:56 <slack1256> Nisstyre: haven't checked that out.
22:48:01 <bobajett> which one?
22:48:03 <PatrickRobotham> SamanthaD: What's the theory heavy Haskell book?
22:48:23 <arbn> SamanthaD: I'm fairly sure that there's only one edition of Purely Functional Data Structures...
22:48:30 <bobajett> everyone's curiosity piques at the mention of a theory heavy Haskell book :-)
22:49:11 <PatrickRobotham> SamanthaD: http://libgen.org/get?nametype=orig&md5=EFF59C468FCEA9BFCE3BE2B36B4E581A
22:49:24 <SamanthaD> PatrickRobotham: The Haskell Road to Math, Logic, and Programming
22:49:31 <Nisstyre> PatrickRobotham: is that the entire book?
22:49:35 <shachaf> SamanthaD: I'm not sure I'd call that a Haskell book. :-)
22:49:37 <PatrickRobotham> Nisstyre: Yes.
22:49:46 <arbn> That's more of a Deiscrete Math book than a Haskell one. Just Haskell notation.
22:49:50 <shachaf> (Which isn't to say you shouldn't read it. But it's not really about Haskell.)
22:49:51 <arbn> Discrete*
22:49:52 <Nisstyre> PatrickRobotham: I guess it would be too much to ask for an epub or mobi version? :P
22:49:53 <slack1256> Nisstyre: oh I remembered, the use of codata in haskell and usage
22:49:53 <SamanthaD> arbn: Yeah... I was referring to the thesis. My bad.
22:50:09 <Pseudonym> Deiscrete sounds classical and theological.
22:50:20 <PatrickRobotham> Nisstyre: There's only .djvu and .pdf
22:50:30 <SamanthaD> PatrikRobotham: Oh! Nifty! Thanks.
22:50:41 <Nisstyre> PatrickRobotham: djvu might work
22:50:53 <SamanthaD> arbn: I know, and it's been quite enlightening.
22:50:58 <PatrickRobotham> Nisstyre: http://gen.lib.rus.ec/search?req=Purely+Functional+Data+Structures&nametype=orig&column[]=title&column[]=author&column[]=series&column[]=periodical&column[]=publisher&column[]=year
22:51:14 <arbn> SamanthaD: Yeah. Learning more about math and proof can't hurt. :)
22:51:47 * PatrickRobotham wonders whether he's qualified to adopt SamanthaD
22:51:50 <SamanthaD> arbn: It's also inspired me to start using literate sources rather than traditional ones. I <3 .lhs
22:52:12 <hrumph> hi
22:52:14 <SamanthaD> PatrickRobotham: Sure, why not?
22:52:21 <hrumph> how do i convert char to text?
22:52:23 <PatrickRobotham> Good enough for me!
22:52:29 <Pseudonym> I suspect it's more about how much time you have than whether or not you have the Haskell-Fu.
22:52:33 <PatrickRobotham> hrumph: show or print
22:52:34 <SamanthaD> hrumph: Wait... you mean a char to a string?
22:52:38 <covi> @src foldr
22:52:38 <lambdabot> foldr f z []     = z
22:52:38 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:52:42 <hrumph> sorry i meant String to Text
22:52:43 <bobajett> oh the book and thesis are different. different last couple of chapters.
22:52:53 <Nisstyre> @src unfoldr
22:52:53 <lambdabot> unfoldr f b  = case f b of
22:52:53 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
22:52:53 <lambdabot>    Nothing        -> []
22:53:06 * PatrickRobotham googles for the Text type
22:53:15 <arbn> hrumph: pack
22:53:36 <bobajett> :t Text
22:53:38 <lambdabot> Not in scope: data constructor `Text'
22:53:43 <bobajett> Text
22:54:03 <arbn> http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text-Lazy.html#v:pack
22:55:17 <Raimond> hello!
22:55:17 <arbn> Oh. I guess you use singleton to convert a Char into a Text. pack is for String.
22:55:30 <arbn> I've never wanted to convert a single character, though.
22:55:31 <shachaf> Or you can just pack the string.
22:55:44 <shachaf> Yes, it doesn't make much sense usually.
22:55:54 <lispy> hrmph. I removed all the upper bounds in agda.cabal and it's building.
22:56:09 <shachaf> You don't even win anything performance-wise by using a single-Char Text.
22:56:14 <shachaf> (In fact you lose.)
22:56:23 <shachaf> And building up Text by consing is a bad plan.
22:56:24 <lispy> The PVP is great in some ways, but I'm starting to be of the opinion that upper bounds are mostly useless.
22:56:43 <bobajett> SamanthaD: course-wise is this your first or second Haskell course? Im curious if "The Haskell Road to Math, Logic, and Programming" is being used as a supplimentary or primary text?
22:56:49 <lispy> (as in, most of the time they actually create problems and only rarely prevent or fix them)
22:57:15 <shachaf> Oh, this is a course?
22:57:43 <SamanthaD> bobajett: It's my first course. But I'm using it in conjunction with both Real World Haskell and Learn You a Haskell.
22:58:16 <shachaf> Where is it?
22:58:17 <arbn> SamanthaD: Oh. Cool. That sounds like a nice combination for study.
22:58:37 <SamanthaD> bobajett: I would say that Haskell Road does a thoroughly LOUSY job of teaching the basics but it provides interesting problems to actually cut your teeth on.
22:59:07 <bobajett> Im a sucker for books, that one's going on my list as well then.
22:59:10 * arbn is envious of all these kids who get to use Haskell in courses.
22:59:34 <SamanthaD> bobajett: Well... mayb not... It's kinda like SICP in the sense that it doesn't really teach the language but introduces it enough where you can work with it for the book's actual intent.
22:59:45 <Raimond> that's language is bullshit!!!!!
22:59:55 <SamanthaD> bobajett: I'm mostly using the book so that I'll have something to do with Haskell as I learn it.
23:00:20 <hiptobecubic> SamanthaD, where are you taking the course?
23:00:20 <lambdabot> hiptobecubic: You have 1 new message. '/msg lambdabot @messages' to read it.
23:00:45 <Raimond> It's not simple to understand...
23:01:01 <Raimond> better learn about python...
23:01:12 <Raimond> much more easy and with practical use.
23:01:19 <hiptobecubic> Raimond, go ahead then.
23:01:23 * PatrickRobotham suspects Raimond is a troll
23:01:30 <Raimond> not really...
23:01:32 <bobajett> arbn: yeah I wonder for kids who's first programming course is haskell, how does that color their experience when working with other languages
23:01:40 <Pseudonym> Ten years ago, it's "why should we learn Python, Java is much more practical".
23:01:46 <hiptobecubic> bobajett, it spoils them :)
23:01:46 <johnw> Raimond: if you prefer to learn python, there is #python
23:01:59 <slack1256> bobajett: the only language i know is haskell
23:02:05 <Pseudonym> In the 80s, it was "why should we learn Pascal, Fortran is much more practical".
23:02:07 <johnw> slack1256: seriously?  cool
23:02:08 <Pseudonym> The more things change...
23:02:20 <Raimond> ok...
23:02:24 <Raimond> sorry.
23:02:36 <hiptobecubic> In the 80's that was true
23:02:40 <johnw> Raimond: we're here because we want to learn Haskell, not necessarily because we should
23:02:42 <hiptobecubic> (and today)
23:02:49 <lispy> Pseudonym: Why should we learn Haskell, Agda is so much more sound"
23:02:54 <Pseudonym> Raimond, the question is this: Are you learning a programming language, or are you learning computer science?
23:03:06 <slack1256> johnw: I am trying to learn rust just because the type system seems more approachable than plain C
23:03:48 <Pseudonym> Languages like Haskell and Scheme have the advantage that they don't get in the way of learning computer science.
23:04:07 <Raimond> ok. The problem is that language (For me) is not intuitive, but It's not the point of this channel. Sorry again!
23:04:10 * lispy wishes someone would revive cyclone (and possibly simplify it a bit to be closer to the metal like c)
23:04:21 <Pseudonym> Where "intuitive" means "what I'm used to"?
23:04:38 <Pseudonym> Anyway, must dash.
23:04:39 <johnw> Raimond: it is indeed hard to build intuitions for, but it's rather nicely intuitive once you have built them :)
23:04:45 <Raimond> No. Means simple like speak a language.
23:04:58 <Nereid> haskell is pretty simple
23:05:00 <hiptobecubic> spoken language is way more complicated than anything haskell can manage
23:05:02 <Nereid> at its core
23:05:09 <arbn> Having learned Scheme as my first language, nothing about Haskell ever seemed unintuitive.
23:05:20 <johnw> Raimond: one thing most people will agree on is that those intuitions are worth the effort
23:05:40 <hiptobecubic> Even starting with python, i didn't think haskell was crazy
23:06:12 <hiptobecubic> understanding *why* things are how they are is difficult, but it's not hard to just understand what they do
23:06:17 <SamanthaD> arbn: I agree. About the only thing I find unintuitive about Haskell is reasoning about performance. And 99% of the time for me that's because of lack of information on a library (prelude included)
23:06:58 <bobajett> is reasoning about performance different in OCaml than Haskell?
23:07:10 <Nereid> it's easier in a strict language
23:07:10 <lispy> bobajett: yes
23:07:30 <covi> I am writing a simple Scheme interpreter. I want to deal with (ignore) comments in some source input string. One approach might be to preprocess the advent of the semicolon, but uses like (raw strings:) ';' and "*;*" should not be ignored. This looks complex to me. Another way is to introduce an additional data type 'Comment' into my Parser, but I haven't really experimented with this approach yet. What do you recommend?
23:07:48 <lispy> bobajett: purity and laziness both change performance reasoning
23:07:49 <Raimond> OK guys. Bye and good luck with Haskell!
23:08:29 <shachaf> SamanthaD: Lack of information on a library of all things?
23:08:44 <shachaf> What sort of lack?
23:09:19 <hiptobecubic> things like foldl, i imagine
23:09:23 <lispy> bobajett: due to purity we might build a string in reverse and then reverse it at the end. But, then also due to purity the compiler can do much more sophisticated transformations on our code to speed it up.
23:09:47 <SamanthaD> shachaf: Well... like, if I were to write [1..10000] ++ [5] am I adding a pointer from the end of the first list to the beginning of the second or am I copping the whole first list?
23:09:51 <SamanthaD> shachaf: that kind of thing
23:10:18 <lispy> bobajett: and laziness can be hard to reason about because things get evaluated as needed instead of evaluated at specific points in the programs
23:10:22 <PatrickRobotham> SamanthaD: You might enjoy this:
23:10:24 <PatrickRobotham> http://ww2.cs.mu.oz.au/~zs/326/lec/index.shtml
23:10:24 <shachaf> SamanthaD: OK, so an understanding of Haskell's evaluation model.
23:10:34 <shachaf> SamanthaD: Or, rather, GHC's evaluation model.
23:10:37 <shachaf> Haskell doesn't specify.
23:10:38 <bobajett> lispy: and Ocaml is less pure?
23:11:11 <shachaf> SamanthaD: You should read about laziness and exactly what it means (e.g. as opposed to non-strictness), and have at least a vague operational idea of how it works.
23:11:20 <lispy> bobajett: yes, although I would imagine that most of the time ocaml programmers write code in a style that is pure.
23:11:27 <shachaf> It helps a lot.
23:11:32 <shachaf> monochrom has a nice article:
23:11:34 <shachaf> @where lazy
23:11:34 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
23:11:45 <PatrickRobotham> SamanthaD: Look at section 1.7
23:11:59 <SamanthaD> shachaf: indeed... Remember that prime number generator I was working on last night? Well... i got it to work, theoretically, but it leaks memory left and right after about the thousandth prime or so. I'm pretty sure it has to do with how GHC handles list construction. That or how I was trying to use a functional language to write imperative code but we won't talk about that ;)
23:12:00 <lispy> bobajett: an important differece though is whether the compiler's optimizer knows if something is pure and does optimizations with that knowldge
23:12:14 <bobajett> lispy: makes sense.
23:12:40 <SamanthaD> PatrickRobotham: Thank you, I will
23:13:05 <shachaf> SamanthaD: I don't remember much about it.
23:13:22 <shachaf> SamanthaD: GHC, for the most part, "handles list construction" in the obvious way.
23:13:52 <shachaf> By obvious I mean "given that you have a good idea for how laziness works, you would do it this way".
23:13:55 <SamanthaD> shachaf: Yeah... I'm pretty sure though it was my trying to force it to work imperatively rather than letting the compiler optimize my declarative code.
23:14:01 <shachaf> Not "obvious" obvious. :-)
23:14:09 <lispy> obviously
23:14:18 <mauke> modulo semantics
23:14:21 <bobajett> heh
23:14:29 <shachaf> It has a bunch of optimizations on that but you shouldn't really expect them to change anything other than constant factors.
23:14:34 <arbn> I think people overstate the "magical optimizations" of the compiler.
23:15:11 <bobajett> shachaf: oh thanks for pointing out that lazy article. I was looking for something that would explain that in more detail!
23:15:43 <lispy> How's it go? 20 years of compiler research gives the same performance gains as waiting 18 months and buying a newer CPU?
23:15:49 <SamanthaD> arbn: well... I know it's not magic but still. What I was doing was passing a list through several functions to be parsed when I could have just recursively called the base function from whithin it and relied on compiler memoization.
23:16:11 <shachaf> SamanthaD: GHC doesn't do memoization.
23:16:25 <shachaf> It does sharing, which is a different thing.
23:16:39 <shachaf> Sometimes you can use sharing to memoize the results of functions.
23:16:50 <SamanthaD> shachaf: 'fraid I don't know the difference
23:17:10 <shachaf> SamanthaD: For example, the difference between "let x = 1 + 1 in x + x" and "(1 + 1) + (1 + 1)"
23:17:24 <lispy> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs -- this memoizes the previous fibs calculations
23:17:25 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
23:17:29 <shachaf> In the former (1 + 1) would be computed once; in the latter once.
23:17:41 <shachaf> lispy: I think using the word "memoization" here is misleading. :-)
23:18:02 <SamanthaD> shachaf: Oh yes, I see
23:18:18 <shachaf> SamanthaD: You should read that monochrom article I linked to.
23:18:36 <shachaf> SamanthaD: Laziness is much less magical than people sometimes assume it is.
23:18:47 <hpaste> SamanthaD pasted “Prime Number Generator” at http://hpaste.org/80577
23:18:59 <shachaf> It follows simple evaluation rules, just like any other evaluation strategy.
23:18:59 <SamanthaD> There's my code for anyone who's interested
23:19:24 <lispy> shachaf: fair enough. I just wanted to make an example of something that looks like memoization but uses sharing.
23:19:43 <PatrickRobotham> What was that lovely one line primes generator?
23:19:47 <shachaf> lispy: I also think that code is confusing in general for someone wanting to learn about laziness.
23:20:03 <shachaf> PatrickRobotham: nubBy(((>1).).gcd)[2..] . But that certainly won't help here at all.
23:20:14 <PatrickRobotham> Ah there we go.
23:20:28 <shachaf> SamanthaD: I haven't read the code in much detail, but that has some red flags, certainly.
23:20:56 <lispy> shachaf: <shrug> I think it's a great exercise for beginners. Expanding it out equationally helps teach laziness, IMO.
23:20:57 <SamanthaD> shachaf: I'll bet it would run really REALLY fast in FORTRAN!
23:21:36 <shachaf> SamanthaD: FORTRAN would use an array, not a linked list.
23:21:49 <PatrickRobotham> SamanthaD: You could say primes = filter isPrime [2..]
23:21:50 <shachaf> You're working with linked lists, but you're appending to the end and getting the last element.
23:22:07 <SamanthaD> shachaf: Yes, I'm aware.
23:22:42 <shachaf> PatrickRobotham: I don't think that'll work.
23:23:08 <PatrickRobotham> Oh you want an efficient prime number generator.
23:23:15 <SamanthaD> shachaf: I'm appending to the end of the lists because I assumed I'd suffer a much lower performance penalty to append to the end than to read backwards considering the append action is MUCH rarer than the read actions by quite the margian.
23:23:22 <PatrickRobotham> http://www.haskell.org/haskellwiki/Prime_numbers
23:23:31 <shachaf> PatrickRobotham: No, I just want one that'll terminate.
23:24:02 <shachaf> SamanthaD: What you want is a solution that uses the list structure rather than fighting it.
23:24:07 <PatrickRobotham> What are you guys trying to do?
23:24:08 <SamanthaD> PatrickRobotham: I know there are already good prime number generators. The point wasn't to have one. The point was to make one myself ;)
23:24:29 <bobajett> a'ight off to bed - g'nite folks.
23:24:42 <SamanthaD> PatrickRobotham: I was trying to make an ultra-efficient prime number generator for fun.
23:24:48 <SamanthaD> bobajett: nice talking with you
23:25:11 <SamanthaD> shachaf: Yes... but I'm not sure how...
23:25:46 <PatrickRobotham> SamanthaD: You know about map, filter and fold right?
23:26:10 <SamanthaD> PatrickRobotham: Yes.
23:26:24 <PatrickRobotham> Cool.
23:26:26 <SamanthaD> PatrickRobotham: Or... I'm learning them. They're still new concepts for me.
23:26:44 <SamanthaD> PatrickRobotham: But I know what they do. What I'm saying is I probably don't really understand the subtleties yet.
23:28:31 <PatrickRobotham> SamanthaD: Ah, one bit of inefficiency in your code is you're using last.
23:28:34 * shachaf has given up on anything involving prime number generators and #haskell long ago.
23:28:45 * lispy is still waiting for agda to install...
23:29:07 * Nereid uses Data.Numbers.Primes and moves on
23:29:10 <SamanthaD> PatrickRobotham: What should I be using?
23:29:54 <shachaf> @quote ddarius platitude
23:29:54 <lambdabot> ddarius says: "use the right platitude for the job"
23:29:58 <PatrickRobotham> SamanthaD: Well, the problem with using last is that you have to eat up all of the list, which takes O(n) time.
23:30:14 <byorgey> shachaf: re: logarithm types, yes, it could have been me
23:30:45 <SamanthaD> PatrickRobotham: True, indeed... ... OOOOH! That actually explains some of the inefficencies!
23:30:47 <shachaf> hi byorgey
23:31:06 <SamanthaD> PatrickRobotham: At least in terms of speed. But the main problem with that code is that it consumes an ENORMOUS amount of memory.
23:31:08 <johnw> oh, that reminds me, what does exponentiation looks like at the type level?
23:31:13 <johnw> a -> b?
23:31:16 <shachaf> johnw: Functions.
23:31:17 <johnw> = b^a?
23:31:19 <shachaf> byorgey: I was trying to figure out this odd Unapplicative that came up.
23:31:20 <johnw> ah, thanks
23:31:40 <SamanthaD> PatrickRobotham: and I was under the impression that last was O(1)?
23:31:56 <shachaf> byorgey: With the operations, I think, unpure :: p () -> Void; unstar :: p (a,b) -> Either (p a) (p b)
23:31:58 <byorgey> shachaf: do tell, I haven't heard of Unapplicative
23:32:01 <PatrickRobotham> SamanthaD: No. head is O(1).
23:32:12 <shachaf> byorgey: Well, that's because we made it up. :-) But it came up in a context!
23:32:15 <SamanthaD> PatrickRobotham: I meant in terms of space.
23:32:25 <byorgey> =)
23:32:32 <shachaf> byorgey: Anyway, those operations remind me of a logarithm.
23:32:47 <PatrickRobotham> Oh, yeah, I'm not sure what's going on with the space thing.
23:32:48 <shachaf> So that's pretty much it.
23:32:49 <applicative> SamanthaD: I guess it was mentioned that the case isPrime n [] isn't defined ...
23:33:05 <shachaf> byorgey: It came up from trying to make newtype Un p a s = Un (p s -> p a) an instance of Applicative.
23:33:07 <byorgey> shachaf: hmm, indeed
23:33:08 <lispy> agda built/installed, and now it seems to be too new for my copy of the standard lib :)
23:33:30 <SamanthaD> applicative: isPrime n [], if it were called, would be an exception anyway.
23:33:44 <SamanthaD> applicative: if that were to happen it would mean that my understanding of the algorithm is flawed.
23:34:05 <PatrickRobotham> SamanthaD: My only guess re: space is that you're passing around copies of an increasingly growing list.
23:34:05 <shachaf> byorgey: Similarly Uncategory with coid :: p x x -> ? (where ? is either Void or p a b, not sure); mpose :: p t s -> Either (p t x) (p x s)
23:34:14 <byorgey> shachaf: the usual observation about logarithm is that log p gives you the type of "positions" in container p
23:34:25 <PatrickRobotham> SamanthaD: But that's probably not right.
23:34:38 <byorgey> note it only really works for representable p
23:34:58 <shachaf> byorgey: I suspect these types aren't very meaningful in Haskell. If it wasn't for parametricity etc., Uncategory could have instances like "type inequality"
23:35:02 <SamanthaD> PatrickRobotham: That's what i thought too, but it's my understanding that GHC uses pointers for that sort of thing.
23:35:07 <shachaf> And Unapplicative could have an instance like "this type is uninhabited"
23:35:23 <shachaf> byorgey: Representable meaning what?
23:35:30 <mauke> SamanthaD: there are no pointers
23:35:33 <PatrickRobotham> SamanthaD: Well, try to rewrite itrPrime to compute p more efficiently.
23:35:46 <shachaf> byorgey: That (F x) ~ (T -> x) for some T?
23:35:54 * PatrickRobotham resists urge to spoil
23:36:00 <byorgey> shachaf: right
23:36:08 <SamanthaD> mauke: No no, I didn't mean in the haskell language. I meant in the machine code that the program compiles to.
23:36:17 <shachaf> byorgey: OK, I can see how that would relate to logarithms. :-)
23:36:24 <byorgey> indeed =)
23:36:30 <applicative> SamanthaD: I was thinking of interpreting it as 'n isnt divisible by any of xs'
23:36:34 <shachaf> I'm not sure how that relates to my class, though.
23:36:47 <mauke> SamanthaD: you don't need to think about that
23:36:52 <byorgey> yeah, I'm not sure it does.
23:37:07 <shachaf> byorgey: I guess you could treat some instances of Unapplicative as corepresentable by Void?
23:37:13 <shachaf> Sort of trivially, I guess.
23:37:18 <byorgey> you are matching on the *arguments* to p, not the structure of p itself
23:37:22 <shachaf> Except you can't actually use Either, you have to use classical disjunction.
23:37:27 <SamanthaD> applicative: Yes, that's what I'm trying to do in isPrime. isPrime is actually more efficient because it can intelligently stop at x ^2 > n
23:37:37 <shachaf> byorgey: Right.
23:37:47 <shachaf> Not that you can really do that in Haskell.
23:37:58 <byorgey> well, with type families
23:38:12 <shachaf> Well, yes, but here it has to work for any type.
23:38:35 <SamanthaD> mauke: I know... but it shows that the list isn't actually coppied when you do something like a:as
23:38:51 <shachaf> But anyway I thought that logarithmic structure is interesting.
23:39:07 <shachaf> SamanthaD: I think mauke means that you can use a higher-level operation model than machine code to reason about Haskell.
23:39:08 <PatrickRobotham> SamanthaD: Another bit of inefficency: you're appending at the end rather than consing.
23:39:10 <mauke> SamanthaD: nothing is ever copied
23:39:22 <shachaf> I shouldn't speak for mauke, though.
23:39:25 <shachaf> *I'll* say that. :-)
23:39:32 <mauke> shachaf: that sounds about right
23:39:45 <shachaf> Graph reduction is a perfectly good high-level operational model for reasoning about lazy evaluation.
23:39:53 <mauke> x : xs will use x and xs
23:40:07 <shachaf> You have a graph which can share nodes. That's all you need, no pointers or thunks.
23:40:11 <applicative> SamanthaD: itrPrime has a lot of no-nos in it, but I'm not sure how to break it up
23:40:30 <SamanthaD> PatrickRobotham: Yeah... I know that too. I deliberately chose to do that beacuse I felt that appending at the end when I got a new prime number would be more efficient than having to check the prime numbers for divisibility in reverse order which would mean that I would have to get rid of the x ^ 2 > n optimization.
23:40:52 <arbn> Hmm. What do you need to get the type of an expression under the cursor in Emacs? Is haskell-mode enough, or do I need something else?
23:41:08 <PatrickRobotham> SamanthaD: I think you can have the best of both worlds.
23:41:56 <SamanthaD> PatrickRobotham: I hope so!
23:42:21 <SamanthaD> PatrickRobotham: I have to get the algorithm super optimized so I can break RSA once and for all and take over the world!
23:42:51 <arbn> Ah. Nevermind. Found it.
23:43:16 <SamanthaD> RatrickRobotham: Actually, my goal is to calculate the billionth prime number as quickly as possible without crashing my computer due to a memory leak.
23:43:33 <Nereid> > primes !! 10^9
23:43:34 <lambdabot>   Not in scope: `primes'
23:43:36 <Nereid> hm
23:43:56 <shachaf> @google what is the billionth prime number
23:43:58 <lambdabot> http://www.bigprimes.net/
23:43:58 <lambdabot> Title: Big Primes: large list of prime numbers
23:44:08 <Nereid> ok, even for 10^6 it takes a few seconds.
23:44:19 <SamanthaD> shachaf: That's cheating!
23:47:18 <PatrickRobotham> > let isPrime n [] = True; isPrime n (x : xs) = if x `divides` n then False else isPrime n xs; in filter isPrime [2..]
23:47:19 <lambdabot>  Terminated
23:48:45 <PatrickRobotham> > let isPrime n [] = True; isPrime n (x : xs) = if x `divides` n then False else isPrime n xs; in filter isPrime [2..10]
23:48:46 <lambdabot>   Not in scope: `divides'
23:49:06 <PatrickRobotham> > let isPrime n [] = True; isPrime n (x : xs) = if x `mod` n == 0 then False else isPrime n xs; in filter isPrime [2..10]
23:49:08 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
23:49:08 <lambdabot>              with actual type...
23:49:16 * applicative proposes the hackage the Big Primes list, after the fashion of the immortal http://hackage.haskell.org/package/gutenberg-fibonaccis
23:50:25 <PatrickRobotham> let isPrime n xs = all (\x -> x `mod` n == 0) xs in filter isPrime [2..]
23:50:33 <PatrickRobotham> > let isPrime n xs = all (\x -> x `mod` n == 0) xs in filter isPrime [2..]
23:50:34 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
23:50:34 <lambdabot>              with actual type...
23:50:41 <Cale> applicative: lol, what the heck?
23:50:47 <PatrickRobotham> > let isPrime n xs = all (\x -> (x `mod` n) == 0) xs in filter isPrime [2..]
23:50:48 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
23:50:48 <lambdabot>              with actual type...
23:50:57 <Cale> Why would someone write a package like that?
23:51:01 <applicative> Cale it's amazing
23:51:46 <beaky> hello
23:51:50 <PatrickRobotham> :t (\x -> (x `mod `3) == 0)
23:51:51 <lambdabot> Integral a => a -> Bool
23:51:52 <applicative> Fortunately, it's GPL'd
23:52:24 <PatrickRobotham> :t all (\x -> (x `mod `3) == 0)
23:52:25 <lambdabot> Integral a => [a] -> Bool
23:52:52 <PatrickRobotham> blah, silly me.
23:52:55 <applicative> Hah, on github it has its own special webpage http://justinhanekom.github.com/gutenberg-fibonaccis/
23:53:39 <arbn> applicative: "its own special webpage"? It's hosted on GitHub. :P
23:54:11 <Cale> I love how he chose a super light typeface and then made it grey instead of black
23:54:20 <applicative> arbn, no, I mean the page on his github website.
23:54:26 <AndIrc_92> Don't spoil applicatives excitement.
23:54:38 <arbn> applicative: Aha. Yeah. I see. I guess that is going a *little* out of his way.
23:55:10 <AndIrc_92> it's hip with the javascript kids Cale
23:56:53 <applicative> it's his only repo on github. that he didn't put it under 'acme' on hackage is the master stroke....
23:58:16 <hiptobecubic> "firstFib" :D
23:59:22 <SamanthaD> PatrickRobotham: You mean ... filter isPrime xs, right?
23:59:47 <SamanthaD> PatrickRobotham: The whole point of that code is that you're only testing the candidate prime against already known primes.
