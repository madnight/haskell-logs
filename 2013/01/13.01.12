00:00:40 <croikle> foldr (\x y -> x:x:y) []
00:01:22 <mauke> > foldr (\x z -> replicate 100 'A') [] [1,2,3]
00:01:24 <lambdabot>   "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
00:01:38 <slack1256> croikle: yes.
00:02:52 <johnw> slack1256: a catamorphism means a homomorphism from an initial algebra into some other algebra (even another list algebra); it does not mean a larger structure into a smaller structure, although that's pretty typical
00:03:31 <simon> croikle, maybe looking for such simple cases isn't really that useful unless you're doing something like filter.
00:03:55 <slack1256> johnw: yes, thanks
00:04:11 <simon> croikle, I'd hate to run into the halting problem or any hard computational problem in determining if there is size-reduction.
00:06:41 <simon> johnw, I suppose the examples I was thinking of have little variation from filter (e.g. functions that return something of a fixed size where this can be somewhat easily determined by static analysis).
00:07:15 <johnw> so, what are the temps you were thinking of in those cases?
00:20:20 <mauke> why do people flush stderr?
00:22:36 <slack1256> mauke: bad memories with C and get char
00:22:40 <slack1256> *getchar
00:22:59 <slack1256> oh stderr, i read stdin
00:23:18 <m3ga> mauke: flushing stderr is still valid if you want to flush part of a line :-)
00:24:17 <mauke> m3ga: no, it's not
00:24:22 <mauke> stderr is unbuffered
00:24:53 <m3ga> i thought it was line buffered
00:25:19 <m3ga> mauke: you are right.
00:25:38 <mauke> I've seen it in xmonad, and just now I've seen someone do it in C
00:25:40 <m3ga> people do it because just flushing it is faster than reading the man page :-)
00:29:13 <E0000> conals retweet about advice for noobs installing ghc... i had a lot of trouble with homebrew haskell platform i just ended installing everything from scratch i think
00:47:24 * hackagebot libmpd 0.8.0.2 - An MPD client library.  http://hackage.haskell.org/package/libmpd-0.8.0.2 (JoachimFasting)
00:50:35 <ctc> any way to call a preprocessor with parameters in GHC? I tried these and they failed: ghci Test.hs -F -pgmF "pp -t"   and   ghci Test.hs -F -pgmF (pp -t)
00:52:27 <roadfish> I figured out how to get cabal to install my package:
00:52:27 <roadfish>     cabal install blank-canvas --constraint=blank-canvas==0.2.0.1
00:53:09 <roadfish> I kept on back stepping on --constraint=... version until cabal stopped complaining about dependencies or about getting broken by the reinstalls.
00:53:13 <roadfish> so here is my question:
00:53:42 <roadfish>    is there some way to have cabal automatically keep backstepping through vesions until one is accepted without dependency issues?
00:54:18 <dcoutts_> roadfish: if you're using a recent version of cabal, then it does that automagically
00:55:14 <roadfish> cabal -V  ---> 0.14.0
00:55:44 <roadfish> dcoutts_: so, what magic hit-points is your cabal at?
00:56:22 <dcoutts_> roadfish: that was the first version with the new solver, but the main release with it was 0.16.x
00:57:09 <roadfish> ok, thanks. I'm running off of Ubuntu 12.04 Haskell Platform
00:58:13 <roadfish> my ghc is 7.4.1 ... but I heard (possibly incorrectly) that some people have problems at 7.6 because a lot of packages in Hackage aren't upgraded to 7.6.
00:58:53 <Nereid> it's true, but it's better now than it was a few months ago
00:59:10 <roadfish> I'm wondering if I should go to the effect of installing 7.6 from source. Or maybe just wait until things settle into more happiness at 7.6.
00:59:24 <Nereid> which is why the current platform ships with 7.4.2, even though 7.6.1 was already out.
00:59:55 <roadfish> or maybe Ubuntu 12.04 LTS (long term support) will jump to 7.6 once it hits a certain level.
01:00:15 <roadfish> apt-get is much simpler than wget/tar/make/etc
01:00:37 <Nereid> kind of doubtful, but what do I know.
01:00:54 <Nereid> anyway, 7.6 doesn't bring a whole lot of new stuff
01:01:04 <Nereid> unless your itching to play with DataKinds/PolyKinds, 7.4 is perfectly fine.
01:01:07 <Nereid> you're.
01:01:57 <roadfish> actually, I still in the learning curve. my main interest would be to be getting the maximum hackage. more packages to play with means more learning and stuff to play with.
01:02:09 <Nereid> stick with 7.4, then. :)
01:02:24 <roadfish> out of curiosity, so you are doing 7.6? if so, how did you make the jump to 7.6?
01:02:49 <roadfish> did you do the whole compile ghc source? or do you have a more active distro?
01:03:35 <Nereid> I use gentoo, and 7.6.1 is available in the gentoo-haskell overlay so I use that.
01:03:45 <Nereid> if it wasn't there, I'd probably just have gotten the binary package.
01:03:47 <Nereid> which you can do too.
01:03:57 <Nereid> on the ghc download page.
01:04:12 <roadfish> ok, so the binary will probably run fine on Ubuntu too.
01:04:16 <Nereid> sure.
01:04:22 <Nereid> although you kinda have to know what you're doing.
01:04:33 <roadfish> I guess gentoo (and I've heard Arch too) are distros that do more bleeding edge
01:04:50 <roadfish> but Ubuntu hangs back a bit too much at times
01:05:41 <Nereid> well by default, gentoo only has 7.4.2 available anyway
01:15:08 <mauke> by default, gentoo uses 6.12.3
01:19:21 <Nereid> but 7.4.2 is still in portage.
01:19:31 <Nereid> just keyworded.
01:22:19 <E0000> hehe
01:22:42 <slack1256> haddock has the means to link to instances?
01:22:43 <E0000> in my 6 parameter function 2 of them are the same type, and i mixed them up
01:22:58 <E0000> type checker did not help
01:23:06 <slack1256> for example when looking at the codensity monad a link to the monad instance definition
01:27:29 <Lethalman> wow ghci has -lfoo and auto compiles .hs with ffi, awesome
01:35:38 <JoeyA> Does cabal always run tests from the package root?
01:36:05 <JoeyA> I want to generate temporary files in a test.  Where should I put them?
01:36:12 <notdan> Does anyone here uses postgresql-simple?
01:36:36 <JoeyA> notdan: I do, I do!
01:36:40 <notdan> I can't seem to understand how to make use of postgre-specific types like money, point, etc
01:36:55 <notdan> Do I have to write my own FromField parser for them?
01:37:24 <notdan> It would have been nice if I could just parse point into (Double,Double)
01:38:28 <JoeyA> notdan: Looks like postgresql-simple doesn't support that at the moment.  You could contribute a patch if you wanted it.
01:38:46 <notdan> I guess I'll give it a go then
01:39:50 <JoeyA> notdan: I wouldn't recommend attaching the instance to (Double, Double).  Easy to get mixed up with records.
01:40:08 <JoeyA> A user might think they're matching a row, but they're matching a point.
01:41:15 <JoeyA> Please use a custom data type instead, e.g. data Pt x y = Pt x y
01:41:51 <notdan> Ok
01:42:24 <notdan> I also have a question on connection management. If I have a loop like this, I usually terminate it with Ctrl-C: http://pastebin.com/9mbNjDEX
01:42:25 <mauke> The paste 9mbNjDEX has been copied to http://hpaste.org/80646
01:42:37 <notdan> Do I need to 'close conn' at some point or it's not a bigie?
01:43:38 <JoeyA> notdan: It's garbage collected.  It uses a ForeignPtr under the hood.
01:45:41 <notdan> cool, thanks
01:45:54 <notdan> And it's fine from the database side too?
01:45:58 <JoeyA> (note that sqlite-simple's Connection is not garbage-collected at the moment)
01:46:11 <JoeyA> notdan: what do you mean from the database side?
01:46:58 <JoeyA> Oh.  Well, the OS will close all of the program's sockets, so the server should see it close.
01:48:02 <JoeyA> I would recommend issuing 'close' explicitly, though, in case not doing so causes the server to hiccup.
01:51:07 <notdan> I see, thanks JoeyA
02:17:31 * hackagebot hecc 0.4 - Elliptic Curve Cryptography for Haskell  http://hackage.haskell.org/package/hecc-0.4 (MarcelFourne)
02:18:19 <skp> hello
02:18:36 <skp> I have a fonction that is :: a -> b -> ‚Ä¶ -> MaybeT IO z
02:18:47 <skp> I do in its body:
02:18:58 <skp>   SDL.init [InitVideo]
02:19:03 <skp> SDL.init is IO ()
02:19:13 <skp> so what should I do ?
02:19:15 <skp> lift it ?
02:19:25 <skp> lift $ SDL.init [InitVideo]
02:19:25 <skp> ?
02:19:34 <skp> in order to be in MaybeT
02:19:58 <skp> thanks in advance!
02:20:26 <Lethalman> yes lift
02:21:17 <skp> is lift implemented for MaybeT?
02:21:30 <skp> I saw it‚Äôs in Control.Monad.Trans
02:21:37 <skp> not in Control.Monad.Trans.Maybe
02:22:14 <Lethalman> skp, did you try your code already?
02:22:20 <notdan> It's in the MonadTrans typeclass, skp
02:22:36 <skp> yes Lethalman
02:22:39 <skp> if I lift
02:22:41 <skp> I got
02:22:42 <skp>     Couldn't match type `IO' with `MaybeT IO'
02:22:46 <skp> on the next line
02:22:48 <skp> wich is
02:23:04 <skp>   screen <- SDL.trySetVideoMode w h d [HWSurface, DoubleBuf]
02:23:13 <Lethalman> skp, that's not lifted
02:23:17 <skp> do I have to lift that line again ?
02:23:23 <Lethalman> yes
02:23:26 <skp> that‚Äôs pretty borring
02:23:45 <srhb> If you have to lift every line, your design is probably wrong.
02:23:47 <skp> maybe there‚Äôs a way to be more straight-forward
02:23:50 <Lethalman> maybe you are doing something wrong
02:23:50 <zomg> you can put a do-block inside liftIO if you need to do that
02:23:57 <zomg> eg. liftIO $ do ...
02:24:14 <skp> or just lift $ do
02:24:15 <skp> ?
02:24:25 <zomg> Yep
02:24:29 <skp> actually
02:24:44 <skp> the fuction is tryGetScreen
02:24:48 <skp> it aims to enable SDL
02:24:51 <skp> get a screen
02:24:56 <skp> with trySetVideoMode
02:25:05 <skp> and maybe return the screen
02:25:17 <skp> I could write IO (Maybe Surface)
02:25:27 <skp> but I‚Äôm learning monad transformers
02:25:36 <Lethalman> depends on how many operations you'r doing, probably IO (Maybe Surface) is easier
02:25:56 <skp> well
02:25:59 <skp> the thing is
02:26:05 <skp> if i do such a thing
02:26:11 <skp> I can‚Äôt do
02:26:13 <srhb> skp: Please stop using return instead of comma.
02:26:19 <srhb> You're spamming like crazy.
02:26:27 <skp> screen <- tryGetScreen ‚Ä¶
02:26:47 <skp> and have the current do block evaluated to Nothing if tryGetScreen fails
02:26:51 <skp> isn‚Äôt it?
02:27:04 <skp> sorry srhb, it‚Äôs my way to write
02:27:06 <Lethalman> skp, yes tryGetScreen should probably return IO (Maybe ...)
02:27:13 <skp> Lethalman: huh?
02:27:29 <skp> if I do so, I have to use case ‚Ä¶ of
02:27:53 <skp> or I didn‚Äôt get what‚Äôs the point with monad transformers :(
02:28:39 <srhb> skp: Perhaps it's time you posted some more code so we can see what you're actually trying to do.
02:28:46 <srhb> @where hpaste
02:28:46 <lambdabot> http://hpaste.org/
02:29:14 <skp> ok wait
02:30:06 <skp> srhb: https://github.com/skypers/phraskell/blob/unstable/src/Render.hs#L11
02:30:09 <skp> here‚Äôs the source file
02:30:12 <skp> and here
02:30:45 <skp> https://github.com/skypers/phraskell/blob/unstable/src/Phraskell.hs#L74
02:31:04 <skp> I actually want the main function to behave like a
02:31:09 <skp> Maybe monad
02:31:18 <skp> if getting the screen process fails
02:31:20 <skp> I want
02:31:23 <skp> damn
02:31:35 <skp> I want the main function not to run anymore, and just quit
02:31:45 <skp> or something like dat
02:33:01 <srhb> I don't see anything wrong with doing what you're about to with case screen of
02:39:41 <skp> srhb: it‚Äôs painful isn‚Äôt is?
02:39:43 <skp> it*
02:40:20 <srhb> skp: Cases? I certainly don't think so.
02:40:22 <skp> I could replace it with just two lines
02:40:37 <skp> you think it‚Äôs the correct way to do?
02:40:56 <skp> so what‚Äôs the point with monad transformers!?
02:41:04 <srhb> I think it's one correct way to go.
02:41:19 <srhb> I'm not sure what you mean by that. Surely you could also runMaybeT instead, but the consequence would be the same.
02:42:15 <srhb> Perhaps you'll find it easier to see the point with mtl once you have some State you need to keep track of and alter through a lot of different functions.
02:42:15 <skp> runMaybeT?
02:42:30 <skp> I see
02:42:36 <skp> I have States
02:42:48 <skp> (see App and its associated AppState)
02:43:27 <srhb> I kind of dislike MIO, but that's your business.
02:44:09 <srhb> It might actually work out nicely, I guess.
02:44:20 <srhb> but anyway, once you start using StateT, you'll see the point.
02:54:05 <absence> why isn't there a Foldable instance for DList? is it better to just toList it before folding?
02:55:36 <skp> 11:43 < srhb> I kind of dislike MIO, but that's your business.
02:55:38 <skp> why?
02:55:43 <skp> it‚Äôs great tho
02:56:35 <srhb> You're probably right. I actually changed my mind a bit.
02:58:05 <srhb> absence: Sounds like an oversight.
03:03:56 <notdan> I have a question about a usual workflow. So, say I am hacking on some library, and I made a bunch of changes. I did 'cabal-dev install' in the library folder. Now, I have my own file Test.hs that contains some code I want to run against my modified version of the library? How do I do this? If I just ':cd' into a directory with modify source and load the file via the haskell-mode it still picks up the old unmodifed version.
03:13:29 <covi> @src when
03:13:29 <lambdabot> when p s = if p then s else return ()
03:27:40 <hpaste> ‚ÄúAkshaya TOday‚Äù pasted ‚ÄúAkshaya Today‚Äù at http://hpaste.org/80648
03:28:06 <zomg> haha
03:28:16 <zomg> indians \o/
03:39:13 <covi> @hoogle FilePath -> FilePath -> FilePath
03:39:13 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
03:39:13 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
03:39:13 <lambdabot> System.FilePath.Windows combine :: FilePath -> FilePath -> FilePath
03:46:59 <beaky> hello
03:47:33 * hackagebot reactive-banana 0.7.1.1 - Practical library for functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.7.1.1 (HeinrichApfelmus)
03:50:04 <beaky> > const 3 1 2
03:50:06 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> t))
03:50:06 <lambdabot>    arising from the ambiguity chec...
03:50:09 <beaky> :(
03:51:45 <mauke> > const const 3 1 2
03:51:46 <lambdabot>   1
03:52:07 <hpaste> beaky pasted ‚ÄúOOP with Closures‚Äù at http://hpaste.org/80649
03:52:46 <beaky> how do I simulate inheritance and polymorphism?
03:53:13 <mauke> that's not OO
03:53:22 <mauke> that's just a church-encoded record
03:53:26 <beaky> ah
03:53:34 <zomg> beaky: so you want to have shapes that all support things like calculating their area?
03:53:52 <mauke> @where oohaskell
03:53:52 <lambdabot> http://homepages.cwi.nl/~ralf/OOHaskell/
03:54:37 <snowylike> "Authors
03:54:37 <snowylike>     Oleg Kiselyov and Ralf L‰mmel " small world
03:57:34 * hackagebot tomato-rubato-openal 0.1.0.2 - Easy to use library for audio programming.  http://hackage.haskell.org/package/tomato-rubato-openal-0.1.0.2 (HeinrichApfelmus)
04:00:47 <beaky> I wanna prove that you can do smalltalk-style OOP using closures and lambdas
04:01:44 <zomg> heh, interesting
04:02:16 <simpson> beaky: Knowing how Scheme does it might be helpful.
04:02:18 <Lethalman> is it possible to dynamically load a .hs file and e.g. call a function? much like dlopen
04:03:23 <Lethalman> http://hackage.haskell.org/package/plugins seems what I'm looking for
04:03:44 <beaky> scheme does it with cons-cells or something
04:03:46 <zomg> Lethalman: yeah it's possible
04:03:54 <zomg> but to my knowledge it requires the use of the GHC API
04:04:37 <Lethalman> zomg, looks like so
04:05:19 <absence> what are the most useful ddump options for looking at core?
04:05:41 <zomg> Lethalman: this is how you can do it using GHC 6.x but the API has changed after that, but hopefully this will help you get started http://codeutopia.net/blog/2011/08/20/adventures-in-haskell-dynamic-loading-and-compiling-of-modules/
04:06:32 <Lethalman> zomg, I believe that's what the plugins hackage is for
04:06:55 <Lethalman> it has a nice loadFunction
04:06:55 <mikeplus64> hm, unsafePerformIO (IO f) = case f (unsafeCoerce# (# #)) of (# _, a #) -> a
04:07:01 <mikeplus64> that works
04:07:20 <zomg> Lethalman: yeah not sure if it does full .hs source loading though, from what I could tell from looking at it, it loads .o files
04:08:17 <leftover> Hi
04:08:53 <mikeplus64> however, using unsafeCoerce# () won't work in some cases -- it works for e.g. unsafePerformIO getLine, but not unsafePerformIO (print ()). anyone know why that is?
04:09:11 <beaky> objects are a poor mans closures
04:10:50 <beaky> http://okmij.org/ftp/Scheme/oop-in-fp.txt
04:10:52 <leftover> I've a question about interpreting typeclass instance declarations, e.g. instance MonadReader r (Reader r) where
04:11:46 <leftover> could anyone explain how to read/interpret it as
04:13:04 <leftover> class MonadReader e m, Reader :: e -> r
04:20:17 <frerich> Hm, I have a binary search tree. Now I'd like to transform this tree into a new tree which has the 'depth' of each node (the distance from the root) associated with each node. Right now I'm doing this using manual recursion. Is there some sort of 'tree fold' function which I can use to get rid of the manual recursion?
04:20:59 <merijn> frerich: Depends, is the binary search tree an instance of Foldable?
04:21:20 <merijn> (See Data.Foldable)
04:21:21 <frerich> merijn: I made it an instance, yes - but the foldr implementation I got doesn't seem to be what I want
04:21:49 <merijn> :t Data.Foldable.foldr
04:21:51 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
04:21:54 <frerich> merijn: My idea was to keep track of the recursion depth in the accumulator, but then I noticed that this won't work since I want the same recursion depth passed to both the left and the right child
04:22:06 <frerich> merijn: Yes, I have this implemented.
04:22:18 <merijn> I think manual recursion might just be the simplest solution
04:22:18 <frerich> Or maybe my implementation is not so good:
04:22:29 <frerich> instance F.Foldable Tree where
04:22:30 <frerich>     foldr f acc EmptyTree = acc
04:22:30 <frerich>     foldr f acc (Node n left right) = F.foldr f (F.foldr f (f n acc) left) right
04:22:59 <frerich> I.e. the accumulator given by folding the left subtree is then passed to the right-subtree, so I guess I can't keep track of the 'recursion depth' like this...
04:27:53 <k0ral> hello
04:45:31 <oio> anyones know how to run ghc in 64 bit mode on mac os x?
04:46:01 <Igloo> If you have a 64bit GHC then it'll always run in 64 bit mode
04:53:47 <oio> mmm any idea how to unisntall haskell platform for an update ?
04:58:29 <frerich> Hm, is there a ready-made function for getting the average of two values (like 'average x y = x + (y - x) `div` 2')? Hoogling for 'Integral a => a -> a -> a' didn't show anything relevant, but this function doesn't seem very esoteric to me...
04:59:19 <epta> http://hpaste.org/80651 how can I rewrite this in applicative style?
04:59:24 <Iceland_jack> frerich: if there would be a function it would probably give you the average of a list of values
05:02:03 <zomg> frerich: something like count <$> (how to get edges) <*> (how to get triple)
05:02:12 <zomg> errm
05:02:17 <zomg> tha was for epta
05:02:17 <zomg> :P
05:02:21 <frerich> epta: I guess that was for you
05:03:02 <frerich> Iceland_jack: Maybe, yes (Hoogling for 'Integral a => [a] -> a' didn't show anything either though). I imagine such an average function over a list would be just a fold, and I'd like just the step function it uses :)
05:03:06 <zomg> I looked twice that it was epta who asked that and I still typed your name...
05:03:07 <zomg> =)
05:03:17 <frerich> What can I say‚Ä¶ Charisma! :)
05:03:20 <zomg> haha
05:03:59 <croikle> oio: you can just install the new one, and then it tells you to run uninstall-hs to remove the old version
05:04:13 <oio> ok yhnks
05:04:22 <epta> zomg: triple and edges are parsers
05:05:17 <Iceland_jack> frerich: a fold?
05:05:21 <basdirks> frerich:
05:05:23 <basdirks> average = liftM2 div sum (fromIntegral . length)
05:05:36 <basdirks> average :: Integral a => [a] -> a
05:06:27 <basdirks> pointfully: average xs = sum xs `div` fromIntegral (length xs)
05:07:03 <frerich> A good counter-example for point free style.
05:09:15 <zomg> epta: yeah I'd think assuming 'count' is not a parser, what I showed should work
05:13:32 <fmap> assuming `count' is not a parser http://hpaste.org/80651 wouldn't typecheck :)
05:13:46 <zomg> haha, that is true
05:14:07 <zomg> coincidentally I've been working with code that uses parsec this week
05:14:39 <zomg> https://github.com/jhartikainen/hs-language-php
05:14:50 <zomg> php parser (+ evaluator + haskell codegenerator)
05:15:00 <zomg> pretty incomplete but hey was just some random experiments =)
05:15:14 <epta> zomg: it's great, but what about particular example?
05:15:27 <zomg> huh?
05:16:17 <epta> `count <$> (how to get edges) <*> (how to get triple)' this is not a right answer :[
05:16:26 <zomg> yeah :P
05:20:43 <beaky> I love functional programming
05:20:56 <beaky> but what is a function in the context of FP?
05:21:50 <beaky> are they just mappings between data?
05:23:58 <Jaxan> what else would it be?
05:24:14 <Eelis> beaky: yes and no. we'd like to think of them that way for the purposes of reasoning, but in practice, even extentionally equal functions can have practically important performance and laziness differences
05:24:18 <beaky> ah
05:24:34 <zomg> function is a function is a function
05:24:35 <zomg> =)
05:24:48 <beaky> I love how real functional programming languages like Haskell make you think of functions as rules for substituting values
05:25:16 <basdirks> or you can see functions as behaviours of types
05:25:22 <basdirks> I like that more =]
05:25:23 <beaky> in traditional von-neumann languages functions are just series of steps to be carried out.
05:25:28 <beaky> ah
05:26:43 <alanz> zomg: have you seen https://github.com/facebook/lex-pass
05:27:22 <zomg> alanz: interesting :)
05:27:40 <zomg> I wrote my stuff mostly just out of curiosity in how writing something like that would work, not as any kind of practical application
05:29:34 <frerich> Did anybody here tune vim so that it indents 'where' consistently? Sometimes it uses two spaces, sometimes four spaces for me.
05:33:30 <alanz> It is php to php with manipulations. I think haskell->php is much more interesting, for legacy code bases
05:36:36 <zomg> frerich: I have some haskell thingy for vim and it still indents things a bit funkily at times
05:36:39 <zomg> I just ignore it :P
05:36:55 <zomg> I think it tries to be clever and line things up or something
05:37:51 <Casca> hello everyone
05:38:58 <beaky> ehllo
05:40:07 <zomg> ehllo <- what hello sounds like if you breathe in instead of out
05:41:43 <basdirks> astute observation
05:42:13 <Casca> any recommendations on introductory reading material? i've read both Learn You a Haskell and Real World Haskell and i'd like to read more on functors, applicative functors, monoids and monads from different authors
05:42:31 <basdirks> http://www.haskell.org/haskellwiki/Typeclassopedia
05:43:04 <Casca> looks great, thanks basdirks
05:43:16 <basdirks> np
05:43:17 <Casca> can you recommend any full length books?
05:44:05 <Lethalman> basdirks, awesome! thanks
05:44:55 <basdirks> no I am not aware of any Haskell-specific ones that deal with Types and Category theory very deeply, maybe someone else knows though
05:45:32 <Adeon> :t (***)
05:45:33 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
05:46:06 <soiamso> Casca: 9780198568612
05:46:12 <Adeon> I like the introduction part of that typeclassopedia
05:46:14 <Casca> thanks soiamso
05:47:29 <basdirks> that's one expensive book!
05:47:49 <soiamso> Casca: hava an online draft edition.
05:51:15 <k0ral> could someone have a look at https://gist.github.com/4518149 and tell me what's wrong please ?
05:53:44 <EarlGray> I feel stupid asking this questions, but how to get CDouble dividing two Int's?
05:54:35 <srhb> EarlGray: What do you mean? How to divide a CDouble with and Int? I don't quite understand your wording.
05:54:40 <croikle> fromIntegral on the ints?
05:54:53 <Saizan> yeah
05:55:03 <EarlGray> let ratio = realToFrac (w/h)
05:55:20 <srhb> Right, fromIntegral the Int
05:55:26 <croikle> > (/) `on` fromIntegral $ 1 2 :: CDouble
05:55:27 <lambdabot>   Not in scope: type constructor or class `CDouble'
05:55:27 <lambdabot>  Perhaps you meant `Doubl...
05:55:37 <Saizan> EarlGray: fromIntegral w / fromIntegral h
05:55:51 <Saizan> croikle: $ doesn't quite work like that
05:56:11 <EarlGray> yes, fromIntegral on both operands works
05:56:14 <EarlGray> thanks
05:57:28 <croikle> Saizan: ah, backticks and $ have same precedence, I see
05:57:34 <EarlGray> I used to `div` two integers, but I thought (/) always produces Fractional
05:58:00 <EarlGray> :t (/)
05:58:01 <lambdabot> Fractional a => a -> a -> a
05:58:10 <tdammers> :info (/)
05:58:14 <tdammers> oh wait
05:58:18 <tdammers> not ghci :P
05:58:46 <EarlGray> ah, I just needed fromIntegral :)
06:00:32 <hpaste> ‚ÄúAnonymous Coward‚Äù pasted ‚ÄúStyle question for trivial monadic values‚Äù at http://hpaste.org/80652
06:00:47 <frerich> Oh oops, that coward would be me.
06:01:14 <frerich> I wonder - how would experienced Haskellers write a simple monadic value (like "main") as shown in that paste?
06:01:18 <srhb> frerich: Matter of taste, really.
06:01:22 <XexoniXexillion> k0ral: What happens if you also require a monad instance on m  for f (i.e "f :: (Monad m, MonadIO m, ConfigReader n m) => m FilePath")?
06:01:33 <frerich> srhb: I currently have the upper version but just realized I could write it point-free, too.
06:01:34 <Saizan> croikle: no, you get (...) (1 2) out of your expression, and i don't think you wanted to apply 1 to 2
06:01:35 <srhb> frerich: It's nice to be able to pattern match on getArgs though
06:01:49 <frerich> srhb: 'pureMain' does that
06:02:09 <srhb> frerich: Either way is fine.
06:02:24 <srhb> frerich: I don't like your composition in the former version though
06:02:36 <srhb> frerich: putStr . pureMain $ args -- nicer
06:02:45 <srhb> (But again, matter of taste)
06:03:11 <basdirks> Reite: I prefer the latter but I am not so experienced
06:03:18 <basdirks> oops, frerich*
06:03:28 <frerich> srhb: I tend to do it that way if I have more than two functions (since 'a $ b $ c x' is uglier than 'a . b . c $ x')
06:04:12 <srhb> frerich: I just like to see directly which functions are composed
06:04:14 <frerich> Ok, so I see this is a peanut issue :)
06:04:18 <srhb> Definitely.
06:04:40 <frerich> I was just wondering since I noticed a while ago that I'm really over-using "do" sometimes.
06:05:02 <frerich> Like "do { a <- foo; return a }" instead of just "foo" :-)
06:05:17 <srhb> Right, that is a case where there's really no discussion
06:05:38 <mauke> do do foo
06:05:47 <k0ral> XexoniXexillion: no better
06:05:56 <k0ral> Monad is implied by MonadIO
06:06:14 <beaky> a monad is like a closure
06:06:32 <beaky> woah
06:07:01 <tdammers> beaky: I don't know how you did that, but it's impressive
06:07:16 <frerich> Maybe it's the reflex people have developed when they read "monad is like"
06:08:41 <croikle> a monad is like a netsplit
06:09:35 <beaky> there's no escape from monads
06:09:57 <XexoniXexillion> s/monad/warm fuzzy thing/
06:11:22 <k0ral> so, no one has a clue on https://gist.github.com/4518149 ? (not really subtle way to reask the question...)
06:12:26 <croikle> throw some more explicit type signatures in, maybe? I don't know
06:13:40 <k0ral> but I don't want explicit types, I want genericity
06:14:51 <mauke> what's the type of socketDir?
06:15:06 <XexoniXexillion> I think it's socketDir :: Simple Lens (Config m)  a
06:15:28 <k0ral> yes
06:15:45 <k0ral> it's built by makeClassy ''Config, from Control.Lens
06:16:03 <mauke> I don't know how makeClassy works
06:16:04 <XexoniXexillion> which means the error is caused by the fact that there isn't a (ConfigReader n m) instance for all n
06:16:53 <k0ral> mauke: it creates lenses for each field in Config
06:17:17 <k0ral> mauke: removing the starting "_" to name the lenses
06:17:34 <k0ral> so socketDir is the lens associated to _socketDit
06:18:43 <k0ral> XexoniXexillion: I don't know how you deduced than, would you care to explain ?
06:18:57 <k0ral> I added | m -> n in ConfigReader definition and it seems to work now
06:19:03 <fmap> k0ral: you need to annotate `socketDir' so ghc would understand `n0 ~ n'
06:19:23 <fmap> fundeps will also work, yes
06:19:48 <k0ral> fmap: annotate ?
06:20:07 <mauke> {-# LANGUAGE ScopedTypeVariables #-}
06:20:24 <XexoniXexillion> k0ral: The type states that there exists a type n, for which there is a ConfigReader n m instance, but it doesn't say anywhere that socketDir uses that n
06:20:34 <mauke> f :: forall n m. (MonadIO m, ConfigReader n m) => m FilePath
06:20:44 <tom22931> I'm considering writing a DSL. An ordinary haskell library wouldn't be suitable though. Quasiquotes are an option though. Of course, I could write everything from scratch. Does anybody know of anywhere that discusses the tradeoffs between QQ and written from scratch wrt new languages?
06:20:55 <bxc> what kind of DSL?
06:20:59 <mauke> f = readConfig (socketDir :: Simple Lens (Config m) a)
06:21:05 <fmap> k0ral: yes, socketDir is `Simple Lens (Config n0) a' and you only have instance for `ConfigReader n m', n /= n0, so ghc complains
06:21:32 <bxc> what makes writing a library insufficient? custom syntax?
06:21:35 <bxc> tom22931: ^
06:22:27 <bxc> tom22931: the big tradeoff for me when writing custom languages has been that at some point in the rowth suddenly you want to be able to do things like string processing or reading files or whatever, and you are suddenly side tracked into dealing with stuff like that rather than concentrating on the core value of your language.
06:22:48 <bxc> tom22931: embedding inside anothe rlanguage that already provides all that "obvious but expensive to implement" stuff pays off, if it turns out your application space needs that
06:23:02 <tom22931> bxc: Yes, custom syntax. Plus, to avoid the use of arbitrary haskell code, which would then not be readable by those who know the domain,but not haskell.
06:23:17 <bxc> in my case, for example, we had a simple DAG language for describing ordered computation, and then over a few years suddenly people wanted ifs and booleans and string processing
06:23:34 <tom22931> bxc: It's fully text goes in, text comes out. There's no need for reading files, for example, otherwise than entry into the DSL.
06:23:38 <bxc> an din my case, being able ot put in arbitrary host lagnuage code would have been a *benefit*
06:23:50 <bxc> so it sounds liek that s a bit different from your case
06:24:08 <bxc> sounds perhaps more like you should implement a language using parsec?
06:24:12 <k0ral> mauke: I understand why your proposition should work, but it doesn't :(
06:24:29 <mauke> k0ral: what's the error?
06:24:43 <tom22931> bxc: Even using parsec, I could still go down either the QQ or new language route though, afaict.
06:24:44 <k0ral> it boils down to inform GHC that the socketDir we use works with the same n as in the signature of f
06:24:57 <k0ral> mauke: same error as before
06:25:05 <mauke> fun
06:25:09 <tom22931> bxc: I'll play around with QQ and parsec to get a feel for what they provide/don't provide.
06:25:17 <bxc> tom22931: parsec will let you make exactly your own syntax
06:25:22 <bxc> for you to then evaluate
06:25:26 <bxc> wihtout any haskell in there
06:25:49 <tom22931> bxc: I thought QQ did too, and without the DSL being able to use haskell.
06:25:50 <k0ral> ScopedTypeVariables doesn't help either
06:25:51 <bxc> a QQ approach, I guess, will let you mix and mathc haskell syntax and your own syntax
06:26:06 <bxc> but QQ (if I understand what you mean by that) will be inside a haskell wrapper program
06:26:09 <bxc> right?
06:26:15 <k0ral> up to now, the only thing that got it working was adding the dependency | m -> n
06:26:16 <tom22931> bxc: Yes.
06:26:25 <mauke> k0ral: what do you mean, "either"?
06:26:47 <k0ral> :: Simple Lens (Config n) FilePath didn't help
06:26:55 <k0ral> ScopedTypeVariables didn't help EITHER :)
06:27:09 <fmap> k0ral: did you add foralls?
06:27:25 <k0ral> isn't that implied by the syntax ?
06:27:35 <mauke> rephrase: did you make all three changes I suggested?
06:27:38 <XexoniXexillion> k0ral: not for scoped type variables
06:27:41 <k0ral> I mean, when prefixing the type with constraints, isn't that always "forall" ?
06:27:46 <k0ral> allright
06:29:16 <k0ral> it works fine indeed
06:29:43 <k0ral> could you please give me a summary of what are the prons & cons of each solution ?
06:29:58 <mauke> >prons
06:31:40 <XexoniXexillion> k0ral: The scoped type variables is probably what you're looking for. It means that the function will work for any instance of ConfigReader n m. Fundeps mean that type type of m imply the type of n. That does mean however that there is exactly one type n for each m
06:32:01 <XexoniXexillion> s/type type/the type/
06:32:21 <k0ral> fundeps doesn't seem to be what I want
06:37:06 <k0ral> thank you guys, very interesting as always
06:41:01 <Lethalman> is it safe to enable shared and executable-dynamic and executable-profiling and library-profiling in .cabal/config?
06:41:16 <Lethalman> or shared/dynamic is an experimental feature?
06:49:59 <Ziarkaen> I'm asked to list a Binary Tree's nodes in left-to-right order.  Isn;t it possible for two nodes to be "vertically aligned"?
06:50:28 <Rembane> Ziarkaen: Why?
06:50:30 <mauke> huh?
06:50:44 <Lethalman> Ziarkaen, a child node is always either on the left or on the right
06:51:53 <Ziarkaen> Lethalman, Sure, I get that.  But if n1 has path [L] and n2 has path [R,L,L] from the root node, they will be vertically aligned if drawn on paper, right?
06:52:00 <Wizek> How can I conditionally define my main function so that I can compile the same file with ghc and also load it into ghci?
06:52:22 <mauke> Ziarkaen: only if you do it wrong
06:52:34 <basdirks> Wizek, you don't have to
06:52:37 * hackagebot hackage-plot 0.2.1 - Generate cumulative graphs of hackage uploads  http://hackage.haskell.org/package/hackage-plot-0.2.1 (DonaldStewart)
06:52:45 <basdirks> you can load it into ghci usually
06:52:47 <mauke> Ziarkaen: basically, sort paths alphabetically
06:52:50 <zomg> Wizek: :load in ghci doesn't run main automatically
06:52:57 <skp>        
06:52:58 <mauke> > compare "L" "RLL"
06:52:59 <lambdabot>   LT
06:53:17 <Wizek> basdirks, zomg: When I defined main, ghci only sees my main function and not the rest
06:53:21 <Ziarkaen> mauke, OK, thanks.
06:53:28 <mauke> Wizek: no, that's only if you compile the file
06:53:37 <skp> *a√ß
06:53:45 <mauke> because then ghci will pick up the compiled code instead of the source
06:53:53 <Wizek> oh
06:54:06 <mauke> and if you don't have a module declaration, it will default to 'module Main (main) where'
06:54:14 <mauke> meaning the only exported symbol is 'main'
06:54:39 <niklasb> soo, I have a function (a -> IO ()) -> IO () that takes a callback, stores it and returns immediately. later on, after a certain event triggers, the callback will be called. now i want to write a function "((a -> IO ()) -> IO ()) -> IO a" that makes a synchronous operation out of this. how can this be implemented? does callCC or the cont monad help?
06:54:50 <mauke> workarounds: rm the .o file, :load *foo.hs, or add 'module Main where'
06:55:13 <mauke> niklasb: MVar
06:55:24 <Wizek> looking into these
06:55:35 <niklasb> mauke: okay, that was my first thought. thanks
06:56:39 <mauke> :t let foo register = do v <- newEmptyMVar; register (putMVar v); takeMVar v in foo
06:56:40 <lambdabot> Not in scope: `newEmptyMVar'
06:56:40 <lambdabot>     Not in scope: `putMVar'
06:56:40 <lambdabot>     Perhaps you meant `putChar' (imported from Prelude)
06:56:46 <mauke> :-(
06:56:51 <hpaste> ctc pasted ‚ÄúUncurry type function‚Äù at http://hpaste.org/80657
06:56:57 <niklasb> mauke: yeah, I know how it works :)
06:57:03 <niklasb> thanks
06:58:14 <mysticc> Can anyone give an example of using quickcheck where If I pass a function it returns a random evaluation of this function along with the values of its argument where the function is evaluated
06:58:42 <mysticc> Assuming all arguments of the function has Arbitrary instances
06:59:18 <ctc> how can I make this http://hpaste.org/80657 compile? Why it doesn't compile with overlapping instances?
07:01:50 <bitonic> ctc: ‚Äò() -> a‚Äô doesn‚Äôt work.
07:02:21 <ctc> bitonic: why?
07:02:31 <bitonic> ctc: with fundeps, the thing on the right of the arrow has to ‚Äòdepend‚Äô on the thing on the left in quite syntactic way - all the type var to the right need to appear to the left
07:03:27 <bitonic> ctc: <www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html>, check section 6
07:03:32 <bitonic> *7.6.3.2
07:03:58 <bitonic> in fact none of those instances is fine.
07:04:53 <beaky> I love object-oriented programming
07:05:18 <srhb> beaky: It passes.
07:06:24 <ctc> bitonic: ok, is it possible to achieve the similar functionality in any other way?
07:06:40 <bitonic> ctc: what ‚Äòfunctionality‚Äô?
07:07:00 <bitonic> type families might be the answer but I don‚Äôt know what you want to do
07:07:48 <ctc> a type function with the similar cases
07:14:10 <bitonic> ctc: can you explain more clearly what your goal is?  because it is not obvious to me from that code
07:17:29 <hpaste> ctc pasted ‚ÄúUncurry type function 2‚Äù at http://hpaste.org/80659
07:17:47 <ctc> bitonic: hope it clarifies: http://hpaste.org/80659
07:18:09 <ctc> I would like to get rid of "Singleton"
07:19:17 <bitonic> ctc: you can‚Äôt.  ‚Äòa‚Äô will match any type.
07:19:32 <ctc> but it is more general than the others
07:19:37 <`nand`> you could use a type family instance group
07:19:43 <ctc> so I would like to use overlapping instances
07:21:43 <hpaste> ‚Äú`nand`‚Äù annotated ‚ÄúUncurry type function 2‚Äù with ‚ÄúUncurry type function 2 (annotation)‚Äù at http://hpaste.org/80659#a80661
07:22:05 <`nand`> excuse the cases being out of order :(
07:23:10 <bitonic> `nand`: is that in HEAD?
07:23:25 <`nand`> since GHC 7.7.20121213 or so
07:23:33 <ctc> :( I cannot install the HEAD binary
07:23:37 <bitonic> right, so probably not a solution
07:24:10 <ctc> I use Ubuntu x86
07:24:18 <ctc> but I fail to install
07:24:28 <bitonic> ctc: OverlappingInstances doesn‚Äôt work with type families.  I don‚Äôt remember why.  that‚Äôs the only shortcoming compared to fundeps
07:24:47 <`nand`> OverlappingInstances is a mess in general
07:24:51 <ctc> I see but as you could see fundeps did not work too!
07:24:52 <bitonic> yeah
07:25:03 <bitonic> ctc: fundeps doesn‚Äôt work in this instance for other reasons
07:25:50 <bitonic> ctc: is this an exercise or are you actually trying to solve a problem?
07:27:14 <ctc> I am trying to write an interface like SHE does for Applicatives to automatically apply uncurry and curry
07:28:16 <bitonic> oh, I don‚Äôt know about that
07:28:38 <ctc> nothing complicated
07:28:54 <Wizek> mauke: very strangely, it works now, and I didn't need to modify anything. Anyways, thanks for the tips for when it breaks again due to main fn.
07:29:01 <ctc> I guess I need to focus on installing the HEAD
07:29:28 <ctc> anyone installed HEAD on Ubuntu x86 here?
07:29:39 <bitonic> ctc: shouldn‚Äôt be a big deal
07:30:41 <`nand`> there are builds of GHC which you should be able to just download and run
07:31:17 <ctc> `nand`: do you know where I can find them?
07:33:07 <`nand`> ctc: http://www.haskell.org/ghc/dist/current/dist/
07:33:52 <`nand`> hmm, I don't know if those include x86 builds
07:34:01 <ctc> `nand`: "ghc-7.7.20121213-x86_64-unknown-linux.tar.bz2" is the one right?
07:34:01 <mysticc> Can anybody answer this http://stackoverflow.com/questions/14294802/evaluating-function-at-random-arguments-using-quickcheck
07:34:18 <bitonic> ctc: that‚Äôs x86_64 as the name suggests
07:34:49 <`nand`> also, the .20121213 archive was broken if I remember correctly
07:34:52 <`nand`> I just built from git
07:38:13 <Wizek> Also, is it possible to get a string representation of some piece of code in haskell? like `fn (==)` which returns a tuple `((==),"==")`
07:38:50 <mauke> why would it return "=="?
07:39:57 <ctc> `nand`: should I remove the old version of GHC?
07:41:22 <`nand`> I wouldn't do that, because the majority of the world is probably incompatible with 7.7
07:44:23 <Wizek> mauke: The "why" is a little complicated, but here is how: http://codepad.org/sZBGa1dl
07:44:37 <Wizek> at leas in C I know how to do that
07:45:10 <bitonic> Wizek: there are some reflection facilities but not what you want
07:45:21 <bitonic> e.g. Data.Data, GHC.Generics
07:45:29 <Saizan> Wizek: you could use a similar #define in haskell
07:45:44 <Wizek> Saizan: How to do that?
07:46:00 <Saizan> Wizek: or TemplateHaskell quoting with '
07:46:14 <Saizan> Wizek: {-# LANGUAGE CPP #-}
07:47:33 <mauke> Wizek: I have a better idea: why not write "myVar" instead of asString(myVar)?
07:47:36 <mauke> it's much shorter
07:49:55 * Wizek is shuffling through old documents to present an answer
07:49:58 <osa1> does importing only some types/constructors/functions istead of the whole module affect binary size/compile time/performance/etc. ?
07:51:45 <mauke> osa1: I don't see how it would
07:52:24 <`nand`> hypothetically, the compiler would have to look through fewer names in scope?
07:53:13 <`nand`> don't count on that making a difference
07:53:36 <mauke> I don't think that difference is even measurable
07:54:49 <carlos_> Guys, I'm needing help with haskeline. Trying to use a function of type  IO( ) inside the Input IO () monad, but no deal...  Not knowing how to use liftM too...
07:55:53 <carlos_> Guys, I'm needing help with haskeline. Trying to use a function of type  IO( ) inside the InputT  IO () monad, but no deal...  Not knowing how to use liftM too...
07:56:19 <`nand`> liftIO, or liftM
07:56:25 <hpc> :t lift
07:56:26 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
07:56:28 <`nand`> oh
07:56:30 <`nand`> not liftM
07:56:30 <hpc> `nand`: not liftM :P
07:56:32 <`nand`> I meant lift
07:56:38 <`nand`> but liftIO should work too :)
07:56:47 <carlos_> Let me try...
07:56:50 <`nand`> man, liftM is confusing; should be removed in favor of fmap :(
07:57:11 <hpc> so much Monad cruft should be removed in favor of a real class heirarchy
07:57:12 <cocon> yes, and Monad should be a subclass of Functor...
07:57:28 * `nand` .oO( mmap :: Monad m => (a -> b) -> m a -> m b )
08:00:45 <carlos_> Working!     nand, Thanks a lot!
08:04:48 <Wizek> mauke: Here is a very simple, yet I feel compared to it's size to be quite powerful "testing framework" written in C: http://codepad.org/a8cZ655D and I'd like to do something similar in haskell. Both because I'd like to write some unittests (and no, not with quickcheck) and because I'd like to know how it can be done.
08:06:23 <hpc> i am having trouble working out a higher ranked type
08:07:03 <hpc> just for this example, suppose i am sorting a bunch of (Int, Bool) tuples, or some similarly heterogenous thing
08:07:05 * Wizek looks at tempate haskell with high hopes
08:07:10 <hpc> i would like to be able to do something like
08:07:12 <hpc> sortByMany [snd, negate . fst]
08:07:13 <mauke> Wizek: that stuff is overrated
08:07:24 <mauke> manual test descriptions are usually better
08:07:37 <Wizek> mauke: Overrated by whom?
08:07:39 <hpc> obviously [snd, negate . fst] is a higher ranked type, but i am having trouble working out exactly what type it is
08:07:42 <mauke> and/or separating the test values
08:08:03 <hpc> my first pass was [forall b. Ord b => a -> b], which ghc is not accepting
08:08:04 <mauke> is(myVar, 2);  // now you can autogenerate nice descriptions on failure
08:08:16 <hpc> i have ImpredicativeTypes turned on
08:08:36 <Wizek> mauke: also, can I print the line number or stack trace in case of a failure?
08:09:05 <mauke> not as far as I know
08:09:25 <hpc> http://hpaste.org/80664
08:12:39 <Clint> hpc: why is the constraint inside the brackets?
08:13:52 <hpc> :t [snd, fst]
08:13:53 <lambdabot> [(b, b) -> b]
08:14:12 <shachaf> Ord a => [forall b. Ord b => a -> b] -> [a] -> [a] looks wrong.
08:14:36 <hpc> yeah, i don't do extensions that often
08:14:47 <hpc> the goal is just to get it so someone can write
08:14:48 <hpc> sortByMany [snd, negate . fst]
08:15:15 <mauke> :t [snd, negate . fst]
08:15:16 <lambdabot> Num b => [(b, b) -> b]
08:15:28 <hpc> mauke: but work on tuples that aren't (b, b)
08:15:33 <mauke> impossible
08:15:38 <mauke> look at the type
08:15:41 <hpc> even with extensions?
08:15:52 <mauke> that doesn't change the inherent type of the list
08:16:20 <hpc> hmm
08:17:44 <mauke> :t Handler
08:17:45 <lambdabot> Not in scope: data constructor `Handler'
08:17:52 <mauke> @hoogle Handler
08:17:52 <lambdabot> Control.Exception Handler :: (e -> IO a) -> Handler a
08:17:53 <lambdabot> Control.Exception data Handler a
08:17:53 <lambdabot> System.Posix.Signals data Handler
08:27:44 * hackagebot sqlite-simple 0.4.0.0 - Mid-Level SQLite client library  http://hackage.haskell.org/package/sqlite-simple-0.4.0.0 (JanneHellsten)
08:29:19 <Ziarkaen> Equivalent of (\ f l -> zip (map f l) l) ?
08:29:24 <Ziarkaen> http://www.haskell.org/hoogle/?hoogle=%28a-%3Eb%29+-%3E+%5Ba%5D+-%3E+%5B%28b%2Ca%29%5D doesn;t seem to help
08:30:15 <Lethalman_> @pl f l = zip (map f l) l
08:30:15 <lambdabot> f = fix (join . (zip .) . map)
08:30:20 <Lethalman_> \o/
08:31:07 <mauke> :t \f -> map (\x -> (f x, x))
08:31:08 <lambdabot> (t1 -> t) -> [t1] -> [(t, t1)]
08:31:46 <XexoniXexillion> :t map . (flip liftM2 (,)) id
08:31:46 <mauke> :t \f -> map ((,) =<< f)
08:31:47 <lambdabot> (a -> a2) -> [a] -> [(a, a2)]
08:31:48 <lambdabot> (a -> a1) -> [a] -> [(a1, a)]
08:32:06 <XexoniXexillion> > map . (flip liftM2 (,)) id (*2) [1..5]
08:32:07 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `[t0]'
08:32:12 <mauke> :t map . (=<<) (,)
08:32:13 <lambdabot> (a -> a1) -> [a] -> [(a1, a)]
08:32:29 <mauke> > fmap map (=<<) (,) (*2) [1..5]
08:32:31 <lambdabot>   Couldn't match expected type `t0 -> t1' with actual type `[b0]'
08:32:31 <XexoniXexillion> > (map . (flip liftM2 (,)) id) (*2) [1..5]
08:32:34 <lambdabot>   [(1,2),(2,4),(3,6),(4,8),(5,10)]
08:32:43 <mauke> > fmap map ((=<<) (,)) (*2) [1..5]
08:32:44 <lambdabot>   [(2,1),(4,2),(6,3),(8,4),(10,5)]
08:38:26 <robde> hello, how is haskell that fast calculating factorial?
08:38:42 <robde> how does it even store that big numbers?
08:38:58 <shachaf> It can be as slow as you like.
08:39:14 <shachaf> What's the question?
08:39:25 <shachaf> Are you asking how numbers work?
08:39:37 <robde> yes, in haskell
08:39:45 <mauke> which numbers?
08:39:46 <shachaf> What about them?
08:40:21 <robde> how does it store numbers bigger than long long?
08:40:27 <mauke> heh
08:40:34 <mauke> how does it store numbers smaller than long long?
08:42:11 <shachaf> `long long long' is too long for gcc, I'm told -- but apparently it's OK for ghc?!
08:42:48 <Clint> robde: as MPIs, i believe
08:42:52 <robde> but, is it even limited? will haskell even swap a number to hd if it gets too big?
08:43:13 <mauke> haskell doesn't swap
08:43:30 <mauke> you're confusing categories all over the place
08:44:00 <mauke> (namely: haskell, ghc, C, "numbers", swap)
08:44:00 <robde> sry, I‚Äôm young and impatient
08:44:08 <shachaf> > swap (1,2) -- what now?
08:44:09 <lambdabot>   (2,1)
08:44:22 <mauke> @index swap
08:44:22 <lambdabot> bzzt
08:44:27 <shachaf> Data.Tuple
08:44:27 <mauke> doesn't actually exist
08:44:32 <shachaf> I guess it's not in the report.
08:44:58 <srhb> Does _anything_ exist according to @index?
08:44:59 <XexoniXexillion> robde: the haskell standard defines arbitrary precision integers. GHC by default (I think) uses gmp for the implementation
08:45:04 <shachaf> @index id
08:45:04 <lambdabot> Prelude
08:45:07 <srhb> Fantastic.
08:45:09 <XexoniXexillion> @index undefined
08:45:09 <lambdabot> Prelude
08:45:10 <srhb> @index words
08:45:11 <lambdabot> Data.List, Prelude
08:45:12 <fragamus> (\(a,b) -> [a,b]) . (splitAt poolSize)
08:45:22 <srhb> So basically it's "almost base, but not quite"
08:45:29 <shachaf> @ty toListOf both
08:45:30 <lambdabot> (a, a) -> [a]
08:45:48 <fragamus> i hate that split returns a tuple instead of an array
08:45:55 <jmcarthur> :t toListOf both . splitAt poolSize
08:45:57 <lambdabot> Not in scope: `poolSize'
08:46:00 <shachaf> Why would it return an array?
08:46:02 <fragamus> is there anything more elegant
08:46:05 <jmcarthur> :t \n -> toListOf both . splitAt n
08:46:06 <lambdabot> Int -> [a] -> [[a]]
08:46:09 <mauke> fragamus: which type of array?
08:46:13 <jmcarthur> fragamus: a tuple makes a lot more sense to me...
08:46:29 <jmcarthur> fragamus: there can only be two results from splitAt
08:46:52 <jmcarthur> well, actually, i guess something like   data Pair a = Pair a a   would make even more sense
08:47:02 <jmcarthur> since we know the types are the same
08:47:05 <fragamus> I'm doing this:
08:47:07 <fragamus> transpose . (\(a,b) -> [a,b]) . (splitAt poolSize)
08:47:25 <fragamus> :t toListof
08:47:26 <lambdabot>     Not in scope: `toListof'
08:47:26 <lambdabot>     Perhaps you meant one of these:
08:47:26 <lambdabot>       `toListOf' (imported from Control.Lens),
08:47:29 <jmcarthur> :t uncurry zip
08:47:30 <lambdabot> ([a], [b]) -> [(a, b)]
08:48:00 <fragamus> :t uncurry
08:48:01 <lambdabot> (a -> b -> c) -> (a, b) -> c
08:49:35 <fragamus> :t toListOf
08:49:36 <lambdabot> Getting (Endo [a]) s t a b -> s -> [a]
08:50:15 <fragamus> oh man every time I think I know a little Haskell
08:50:27 <mauke> that's lens craziness
08:50:54 <jmcarthur> is there a lensier way to say   map (toListOf both)  ?
08:51:01 <shachaf> lens craziness is fun!
08:51:03 * jmcarthur still is not a fluent lens user
08:51:28 <shachaf> toListOf (traverse.both)?
08:51:41 <shachaf> That won't work for structures in general, though, since it always gives you back a list.
08:51:46 <jmcarthur> different type
08:51:56 <jmcarthur> map (toListOf both) gives a list of lists
08:52:03 <shachaf> Oh, yes.
08:52:05 <shachaf> So even that won't work.
08:52:15 <shachaf> So I don't think so.
08:52:25 <jmcarthur> :t (map.toListOf) both
08:52:26 <lambdabot> [(a, a)] -> [[a]]
08:52:29 <shachaf> Well, you can say "over mapped" instead of "mapped"
08:52:34 <jmcarthur> meh
08:52:45 <shachaf> That composition seems pretty ad-hoc. :-)
08:52:45 * hackagebot clientsession 0.8.0.3 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.8.0.3 (MichaelSnoyman)
08:52:49 <hpc> got that sorting function working by creating a data type
08:52:52 <hpc> https://github.com/headprogrammingczar/sorting-combinators
08:55:30 <jmcarthur> shachaf: yeah i can't think of a more general interesting idea to pull out of it
08:58:36 <fragamus> ok ugh i need to learn lenses
08:59:05 <fragamus> last time i tried my eye popped out of its socket and dangled on my face
08:59:10 <timemage> heh
08:59:37 <XexoniXexillion> Is there a nice function to take a Word8 -> [Bool]? Or am I stuck with \x -> map (testBit x) [0..7] ?
09:00:01 <jmcarthur> hpc: what on earth is that code intended for?
09:00:37 <jmcarthur> :t testBit
09:00:38 <lambdabot> Bits a => a -> Int -> Bool
09:01:12 <jmcarthur> XexoniXexillion: i think you mean  map (flip testBit) [0..7]  , but no, i don't know of an already-defined function for that
09:01:26 <jmcarthur> gah, i was wrong too
09:01:45 <jmcarthur> :t \n -> map (testBit n) [0..7]
09:01:46 <lambdabot> Bits a => a -> [Bool]
09:01:49 <jmcarthur> there we go
09:02:00 <shachaf> > toListOf bits (223 :: Word8)
09:02:02 <lambdabot>   [True,True,True,True,True,False,True,True]
09:02:07 <jmcarthur> heh
09:02:10 <jmcarthur> moar lens
09:02:24 <fragamus> ow my eye!
09:02:43 <jmcarthur> > toListOf bits (1 :: Word8)  -- seeing what endiannes it has
09:02:44 <lambdabot>   [True,False,False,False,False,False,False,False]
09:02:53 <jmcarthur> derp
09:02:55 <XexoniXexillion> shachaf: I like that. I think I'll use that
09:02:56 <jmcarthur> that's not sufficient
09:03:00 <jmcarthur> > toListOf bits (1 :: Word16)  -- seeing what endiannes it has
09:03:02 <lambdabot>   [True,False,False,False,False,False,False,False,False,False,False,False,Fal...
09:03:20 <shachaf> "good endian"
09:03:22 <jmcarthur> little (and the bits are in 0.. order)
09:03:34 <shachaf> > toListOf bits (13 :: Integer)
09:03:36 <lambdabot>   [True,False,True,True,False,False,False,False,False,False,False,False,False...
09:03:43 <shachaf> Do that with big-endian.
09:03:44 <jmcarthur> ah!
09:04:21 <jmcarthur> on the other hand, you lose the ability to tell when you have traversed enough bits to reconstruct the original number
09:04:38 <shachaf> ?
09:04:50 <jmcarthur> since i assume that will not terminate
09:05:02 <shachaf> You can't reconstruct Integers, sadly.
09:05:13 <shachaf> (But understandably.)
09:05:32 <jmcarthur> well, it would still be possible to give a list that does allow it, just more complicated
09:05:46 <shachaf> Not a list of a fixed size.
09:05:54 <shachaf> Which is what you (presumably) want for e.g. Word8
09:05:59 <jmcarthur> no, but a list of some appropriate (dynamic) length
09:06:04 <jmcarthur> right
09:06:21 <jmcarthur> this is after all the difference between Word*/Int* and Integer
09:06:44 <shachaf> Maybe there should be a dynamic length bits that starts at the highest set bit.
09:06:48 <hpc> jmcarthur: for more involved sorting logic, that package will let you do something like
09:06:52 <hpc> Œª> sortByMany [S fst, S $ negate . snd] [(False, 1), (False, 2), (True, 0)]
09:06:53 <hpc> [(False,2),(False,1),(True,0)]
09:06:56 <ocharles> joeyh: ping
09:07:44 <shachaf> > sortBy (comparing fst ++ comparing (negate . snd)) [(False, 1), (False, 2), (True, 0)]
09:07:46 <lambdabot>   [(False,2),(False,1),(True,0)]
09:08:16 <jmcarthur> > sortBy (comparing $ second negate) [(False, 1), (False, 2), (True, 0)]
09:08:18 <lambdabot>   [(False,2),(False,1),(True,0)]
09:08:34 <jmcarthur> :t sortOn
09:08:35 <lambdabot>     Not in scope: `sortOn'
09:08:35 <lambdabot>     Perhaps you meant one of these:
09:08:35 <lambdabot>       `sort' (imported from Data.List),
09:08:38 <jmcarthur> darn
09:08:55 <shachaf> > let sortByMany = sortBy . mconcat; s = comparing in sortByMany [s fst, s (negate . snd)] [(False, 1), (False, 2), (True, 0)]
09:08:57 <lambdabot>   [(False,2),(False,1),(True,0)]
09:09:04 <shachaf> hpc: No data type needed.
09:09:20 <jmcarthur> @let sortOn f = map snd . sortBy (comparing fst) . map (f &&& id)
09:09:22 <lambdabot>  Defined.
09:09:24 <jmcarthur> :t sortOn
09:09:26 <lambdabot> Ord a => (b -> a) -> [b] -> [b]
09:09:49 <shachaf> hpc: Existential types are really overrated.
09:09:50 <jmcarthur> > sortOn (second negate) [(False, 1), (False, 2), (True, 0)]
09:09:51 <lambdabot>   [(False,2),(False,1),(True,0)]
09:09:59 <shachaf> Well, they're actually pretty great.
09:10:05 <shachaf> But they're overrated for things like this.
09:10:06 <jmcarthur> they are overused though
09:10:30 <shachaf> Maybe it's type classes that are overrated.
09:10:48 <shachaf> Partly because they make people think they want existential types when they actually don't.
09:10:51 <jmcarthur> i don't think so. i love type classes
09:10:58 <jmcarthur> hmm
09:11:20 <XexoniXexillion> is there any danger in using unsafeCoerce that the compiler might try and optimise something in a way which breaks it?
09:11:33 <jmcarthur> no, i think people are just used to a more existentially-typed style of thinking due to other languages
09:11:39 <shachaf> XexoniXexillion: Sure.
09:11:48 <jmcarthur> XexoniXexillion: unsafeCoerce is usually dangerous
09:11:49 <shachaf> Anything goes when you use unsafeCoerce.
09:11:52 <shachaf> No guarantees.
09:11:52 <startling> XexoniXexillion: hence "unsafe"
09:12:34 <fragamus> unsafe actually means dangerous
09:12:40 <fragamus> yah
09:12:41 <hpc> shachaf: i went with a data type for purely namespace reasons
09:13:05 <hpc> suppose someone uses 's' as a parameter or something
09:13:14 <shachaf> So don't call it s?
09:13:21 <Saizan> XexoniXexillion: unsafeCoercing into Any and then back to the original type is supposed to work fine, and between newtypes i think
09:13:28 <shachaf> "S" usually means "successor"
09:13:39 <jmcarthur> hpc: i don't understand what this has to do with namespacing
09:13:42 <cmccann> XexoniXexillion: if you unsafeCoerce between types that aren't the same from the compiler's standpoint, everything may explode
09:13:59 <shachaf> OK, Saizan makes a good point -- I guess there may be *some* guarantees that GHC secretly gives you.
09:14:10 <Saizan> some are documented
09:14:18 <cmccann> newtypes having the same representation isn't really a secret.
09:14:34 <cmccann> and the whole point of Any is a stand-in for types with a particular kind of representation
09:14:46 <shachaf> I don't think H98 promises that unsafeCoercing between newtypes is safe. :-)
09:15:01 <jmcarthur> H98 says newtypes must have the same representation as their underlying types
09:15:06 <hpc> shachaf: good thing it's not the latest spec anymore! ;)
09:15:24 <jmcarthur> or perhaps i'm overstating what it actually intended
09:15:27 * jmcarthur looks it up
09:15:34 <hpc> shachaf: i'll look at my code later and come up with a good name for it
09:15:35 <mauke> representation is overrated
09:15:39 <jmcarthur> i did this recently. i should remember...
09:15:43 <shachaf> jmcarthur: Do you read that as "you can unsafeCoerce between newtypes and the thing they're newtyping"?
09:15:47 <Saizan> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.0/Unsafe-Coerce.html http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.0.0/GHC-Prim.html#v:unsafeCoerce-35-
09:15:55 <parcs> does H98 even have unsafeCoerce?
09:15:56 <mauke> heh, C actually has something like typeclasses
09:16:09 <shachaf> Does it?
09:16:20 <jmcarthur> shachaf: i would not say representation alone is sufficient for that to be safe
09:16:21 <mauke> that is, you can get (subtly) different behavior for things with identical representations
09:16:49 <mauke> just like different instances for newtypes in Haskell (stretching the analogy)
09:16:49 <jmcarthur> shachaf: since the purpose of a newtype (in the software engineering sense) could be to *hide* the representation
09:17:25 <Saizan> well, depends on how safe you want to be
09:18:32 <Saizan> i was discussing something like memory safety, invariant-safe is another problem
09:18:40 <jmcarthur> right
09:18:43 <XexoniXexillion> so if I have a data type with no constructors, a Map of this data type, which I use with unsafeCoerce to make it contain any type, where each variable in the map has its own lens which is properly typed, am I going to run into problems?
09:18:54 <cmccann> what about programmer-safe
09:19:08 <shachaf> XexoniXexillion: Sounds like maybe you want Vault?
09:19:54 <cmccann> XexoniXexillion: that sounds complicated, so yes you'll probably run into problems somewhere
09:20:00 <jmcarthur> XexoniXexillion: what good is a map keyed on a data type with no constructors?
09:20:14 <cmccann> that's why it's better to do simple things or, if possible, let someone else do the complicated parts for you
09:20:23 <XexoniXexillion> jmcarthur: it's not keyed on that, the keys point to those
09:20:27 <jmcarthur> ah
09:20:41 <jmcarthur> i still stand by my question. what is this for?
09:20:59 <shachaf> jmcarthur: The best way to learn about lens things is surely to join #haskell-lens
09:21:03 <Saizan> so you only access them through the lens? this might need an existential
09:21:12 <XexoniXexillion> and Vault isn't suitable, it needs the IO monad
09:21:40 <jmcarthur> shachaf: i am normally in there... i forgot to add it to my autoconnect list and i had to bounce my irc client a while ago
09:21:49 <shachaf> XexoniXexillion: Does it?
09:21:51 <XexoniXexillion> For the record, I already have this, and it seems to work perfectly, I'm just wondering if it's simply luck that it works
09:22:17 <jmcarthur> XexoniXexillion: what exactly is the data being stored in the map?
09:22:28 <XexoniXexillion> shachaf: newKey :: IO (Key a)
09:22:45 <shachaf> Well, creating keys.
09:22:52 <shachaf> Anyway I don't know what you're actually doing here.
09:22:58 <XexoniXexillion> jmcarthur: currently just Vectors, Ints and Doubles
09:23:08 <jmcarthur> XexoniXexillion: but why the empty data type?
09:23:15 <jmcarthur> and why the unsafeCoerce?
09:24:20 <XexoniXexillion> jmcarthur: What other data type would I use? It doesn't make sense to have a value of this type
09:24:39 <jmcarthur> XexoniXexillion: why not just make the values of the map an ADT?
09:24:55 <jmcarthur> oh wait, i think i'm seeing what you're doing
09:25:03 <jmcarthur> the type of the key determines the type of the value?
09:26:41 <jmcarthur> XexoniXexillion: although i still don't understand your implementation. why not just store Any as the values?
09:26:54 <XexoniXexillion> jmcarthur: They key is an Int. The key is not seen by the user. The value is of some type a, which has been changed to this data which has no constructors by unsafeCoerce. It is then accessed with the returned lens
09:27:02 <jmcarthur> at least then you are doing something guaranteed to work (by ghc, at least)
09:27:42 <jmcarthur> vault doesn't require IO btw. it works with ST, too
09:29:09 <hpaste> XexonixXexillion pasted ‚ÄúAn example‚Äù at http://hpaste.org/80666
09:29:27 <mysticc> Suppose I have a class A, and class B. Now I want to declare instances for class b for all types which have instances for class a + some extra. Is there a way to do that. When I do something line instance A a => B a where and then few other instances I had to load flexible and undecidable instances extensions and then get overlapping instances error when I actually try to use them
09:29:30 <jmcarthur> XexoniXexillion: i did a similar trick to what you're trying to do in my stable-memo package, although it's further complicated by other unsafePerformIO craziness
09:29:36 <jmcarthur> XexoniXexillion: http://hackage.haskell.org/packages/archive/stable-memo/0.2.1/doc/html/src/Data-StableMemo-Internal.html
09:29:38 <XexoniXexillion> The map is simply being used to store my mutable variables
09:30:39 <shachaf> You're implementing your own ST?
09:32:06 <jmcarthur> i do wish we had a nice, pure HMap
09:33:28 <jmcarthur> if (Map k v) is like (k -> Maybe v), (HMap k v) would be like (forall a. k a -> Maybe (v a))
09:33:38 <XexoniXexillion> shachaf: Not quite, it's simply a library to let me define "pure" imperative functions in an imperative style. I wrote it because I was bored one night
09:34:24 <jmcarthur> hmm... implementation would be subtle, if it must be pure, though
09:34:48 <jmcarthur> might require some constraints on the relation between keys and values anyway
09:35:36 <XexoniXexillion> If you can guarantee that you can safely unsafeCoerce to and from Any, it's not hard to implement
09:35:58 <jmcarthur> well, i meant pure without the use of unsafeCoerce
09:36:32 <jmcarthur> like i already said, i've done this with Any before, but the keys still had to be controlled tightly
09:37:46 * hackagebot thyme 0.1.0.0 - A faster time library  http://hackage.haskell.org/package/thyme-0.1.0.0 (LiyangHu)
09:39:11 <mysticc> What is the use of coarbitrary in quickcheck.
09:39:57 <liyang> mysticc: when it has to generate a random function to give to you.
09:40:07 <jmcarthur> i guess this type class would be sufficient for what i'm talking about     class TypeEq k where teq :: k a -> k b -> Maybe (a == b)
09:40:15 <mysticc> liyang: What do you mean by random function?
09:40:17 <jmcarthur> which could be instantiated for a lot of pure GADTs without unsafeCoerce
09:40:58 <shachaf> whoa, dude, you can name equality == these days.
09:41:02 <liyang> mysticc: prop_Something :: (Int -> Bool) -> Bool or something
09:41:03 <jmcarthur> mysticc: when the property you are testing requires a function as a parameter, one which needs to be randomly generated
09:41:10 <jmcarthur> shachaf: yeah, i love that :)
09:41:23 <jmcarthur> shachaf: i miss the old behavior in many ways too, though
09:41:30 <shachaf> That was nice too.
09:41:49 <shachaf> Did you know lens (HEAD) provides type equality?
09:41:56 <shachaf> forall p. p a b -> p s t
09:42:10 <mauke> pabst
09:42:12 <jmcarthur> wat
09:42:24 <cmccann> mauke has beer on the mind
09:42:32 <jmcarthur> terrible beer, at that
09:42:34 <shachaf> Actually it's forall p. p a (f b) -> p s (f t)
09:42:39 <cmccann> still better than stabs
09:42:49 <shachaf> jmcarthur: Hmm, have you seen the whole profunctor thing?
09:43:03 <mysticc> liyang: Oh.. Thanks..
09:43:03 <jmcarthur> i've seen bits of discussion about it, is all
09:43:15 <shachaf> It's pretty simple.
09:43:30 <shachaf> "pure" profunctor lenses use (p a b -> p s t) instead of ((a -> f b) -> s -> f t)
09:43:41 <shachaf> So you can pick any p you like.
09:43:46 <jmcarthur> ah!
09:43:48 <mysticc> Is it possible to define instance for a typeclass for all instances of another typeclass without manually enumerating each of them.
09:43:49 <shachaf> Including for example p a b = a -> f b
09:43:55 <jmcarthur> cool
09:44:04 <shachaf> jmcarthur: "lens" profunctor lenses use (p a (f b) -> p s (f t))
09:44:16 <shachaf> So that way you can unify p with (->)
09:44:16 <cmccann> shachaf: where does it get the "f" in that case anyway
09:44:22 <jmcarthur> this doesn't make inference (much) harder?
09:44:22 <shachaf> And get the old lens behavior back.
09:44:28 <mysticc> I mean suppose I have class A. I want to declare instances for class B for all types which belongs to class A.
09:44:34 <shachaf> jmcarthur: Why would it?
09:44:46 <shachaf> cmccann: newtype Foo f a b = Foo (a -> f b); p = Foo f
09:44:54 <jmcarthur> i would think that most interesting instantiations for p would require some type class constraints on it?
09:45:07 <shachaf> jmcarthur: lens uses type class constraints everywhere anyway.
09:45:09 <jmcarthur> oh, the p is the same on both sides
09:45:14 <jmcarthur> i misread that
09:45:18 <shachaf> Yes, you run into trouble when you use p and q.
09:45:19 <cmccann> shachaf: ok just wanted to make sure it wasn't doing something extra weird there
09:45:21 <shachaf> We tried that. :-)
09:45:25 <jmcarthur> ha
09:45:33 <shachaf> jmcarthur: The main type class is Profunctor.
09:45:47 <shachaf> Which gives you lmap :: (a -> a') -> p a' b -> p a b
09:45:55 <shachaf> And rmap :: (b -> b') -> p a b -> p a b'
09:46:16 <shachaf> So type Iso s t a b = forall p. Profunctor p => p a b -> p s t
09:46:29 <fragamus> eye!
09:46:33 <jmcarthur> mysticc: you can't (or at least shouldn't) do that, but you can add a constraint to class A that requires an instance of class B to express that you expect all instances of A to also be instances of B
09:46:46 <jmcarthur> mysticc: and you can provide a convenient way to instantiate B given an instance of A
09:46:57 <shachaf> http://slbkbs.org/k.hs has some examples of the things you can do with pure profunctor lenses.
09:47:02 <jmcarthur> so that defining new instances of A doesn't require so much extra work to implement B
09:47:34 <mysticc> jmcarthur: But I have few extra instances for B.
09:47:49 <mysticc> jmcarthur: Something like all types in A + some extra = B
09:47:50 <TheRedMoodie> Hmm.
09:47:50 <jmcarthur> mysticc: which is not a problem with my proposal!
09:48:27 <jmcarthur> shachaf: not sure i like the names lmap and rmap, but i can't think of anything better
09:48:30 <shachaf> mysticc: Can you make A a superclass of B?
09:48:35 <TheRedMoodie> And I don't quite get the ::(i think they said it was signatures?), are there some documentation on this?
09:48:36 <mysticc> jmcarthur: I dont have control to A. It is defined in a library
09:48:40 <shachaf> jmcarthur: premap and postmap are proposed somewhere.
09:48:42 <TheRedMoodie> Or rather, where is the documentation?
09:48:43 <TheRedMoodie> :p
09:48:44 <jmcarthur> shachaf: in particular, "lmap" doesn't remind you that it's a contravariant map
09:48:46 <TheRedMoodie> :o*
09:49:00 <mysticc> shachaf: Yes If I have access to both class definitions
09:49:07 <jmcarthur> i like premap and postmap more i think, yes
09:49:07 <TheRedMoodie> Doing the 'tryhaskell.org' website lessons
09:49:20 <mysticc> shachaf: My class A is a library class and I am defining class B
09:50:08 <mysticc> Is there a way to not to import an instance of a typeclass for a particular type.
09:50:28 <shachaf> No.
09:50:40 <shachaf> jmcarthur: Note that rmap = fmap
09:50:50 <jmcarthur> shachaf: ooh, Holey fits the pattern!
09:51:06 <jmcarthur> yeah, rmap is just the familiar map
09:51:21 <shachaf> jmcarthur: Sort of. Lots of things seem to fit the pattern but don't quite work.
09:51:35 <jmcarthur> oh?
09:51:49 <shachaf> Not sure in the case of Holey. We didn't do that much with it.
09:53:03 <shachaf> Anyway we had this in Lens once, but it's out for now.
09:53:07 <cmccann> TheRedMoodie: if you're just asking about :: then yes, that means a type signature
09:53:39 <TheRedMoodie> Yes, I am asking if there is any good documentation on it, for people just getting started with haskell :o
09:53:48 <cmccann> TheRedMoodie: there isn't really "documentation" as such because it's part of the core language syntax
09:53:49 <TheRedMoodie> Some of the documentation seemed very... hard :(
09:53:56 <cmccann> try some other tutorials I guess?
09:54:02 <cmccann> have you seen LYAH?
09:54:07 <TheRedMoodie> Okay. thanks a lot :)
09:54:09 <cmccann> @where lyah
09:54:09 <lambdabot> http://www.learnyouahaskell.com/
09:54:10 <TheRedMoodie> I have seen it yes
09:54:13 <shachaf> jmcarthur: The latest addition has been Bizarre, which is kind of bizarre.
09:54:24 <TheRedMoodie> But I wanted to do tryhasell.org first .D
09:54:26 <TheRedMoodie> :D
09:54:31 <jmcarthur> yeah i did see that one
09:54:37 <shachaf> You can use it to turn lensy things around, and you get into this bizarre universe of unlenses.
09:54:41 <jmcarthur> no wait
09:54:43 <startling> tryhaskell.org doesn't explain type signatures?
09:54:56 <jmcarthur> i'm thinking Bazar
09:55:03 <startling> jmcarthur: heh
09:55:03 <jmcarthur> that's a lens thing too, right?
09:55:08 <jmcarthur> :(
09:55:11 <startling> Bazaar, yeah
09:55:14 <shachaf> Yes.
09:55:18 <jmcarthur> sadness
09:55:18 <shachaf> Bizarre is named after Bazaar.
09:55:23 <shachaf> Even though it turned out to be nothing like it.
09:55:31 <jmcarthur> greater sadness
09:55:39 <shachaf> SORRY
09:55:43 <jmcarthur> :P
09:55:57 <shachaf> http://slbkbs.org/s.hs has a "simple lenses" variety of all this.
09:55:57 <cmccann> shachaf: well then it's a bizarre choice of name isn't it
09:56:04 <cmccann> problem solved.
09:56:05 <shachaf> I.e. "p a -> p s", rather than "p a b -> p s t"
09:56:10 <shachaf> cmccann: elliott named it.
09:56:13 <TheRedMoodie> I just got done with tryhaskell.org
09:56:14 <TheRedMoodie> :D
09:56:32 <cmccann> shachaf: you let elliott name things?
09:56:33 <jcp> So I'm co
09:56:40 <jcp> gah, ignore that
09:56:58 <shachaf> cmccann: It's true.
09:57:14 <TheRedMoodie> Should I read "Real World Haskell" or "Learn You a Haskell For Great Good!" First?
09:57:21 <TheRedMoodie> Or is it a personal taste thing?
09:57:29 <cmccann> probably LYAH
09:57:31 <monochrom> LYAH first
09:57:38 <srhb> RWH is more about real world examples.
09:57:44 <srhb> Useful once you've got the basics down.
09:57:45 <cmccann> sort of a matter of taste, but most people find LYAH more helpful I think
09:58:00 <TheRedMoodie> Okay.
09:58:02 <monochrom> LYAH, then The Gentle Introduction, then RWH
09:58:12 <TheRedMoodie> Thanks a lot :)
09:58:38 <TheRedMoodie> I must say that Haskell looks tasty :3
09:58:45 <`nand`> shachaf: what is Bizarre used for?
09:58:54 <shachaf> `nand`: Turning lenses around.
09:58:55 <TheRedMoodie> Compared to most other languages once I have learned some C they all looked the same.
09:59:00 <`nand`> I meant, any examples in ‚Äòlens‚Äô?
09:59:06 <TheRedMoodie> But then I saw haskell and it was like somehing brand new :o
09:59:07 <shachaf> lens has "from" and "remit"
09:59:15 <shachaf> One of them turns an isomorphism into an antiisomorphism
09:59:17 <elliott> <shachaf> Bizarre is named after Bazaar.
09:59:20 <elliott> After BazaarT.
09:59:25 <shachaf> The other one turns a prism into a getter.
09:59:37 <shachaf> Bizarre lets you unify every possible "turn-around" function.
09:59:37 <elliott> shachaf: It doesn't have "remit".
09:59:39 <TheRedMoodie> ... I am not smart enough to be in this channel X)
09:59:47 <cmccann> TheRedMoodie: pf, ignore those two :P
09:59:51 <shachaf> elliott: What's it called now?
09:59:59 <E0000> of all the C looking languages C is only one with such interesting semantics. the rest are pretty borign
10:00:00 <elliott> shachaf: "re".
10:00:03 <TheRedMoodie> cmccann: But they seem so smart :o
10:00:04 <shachaf> TheRedMoodie: Don't worry, we're just making up words.
10:00:08 <shachaf> "re"ally?
10:00:10 <TheRedMoodie> ohh
10:00:10 <cmccann> most people in here don't know what elliott and shachaf are talking about most of the time
10:00:11 <TheRedMoodie> Okay
10:00:11 <TheRedMoodie> X3
10:00:24 <elliott> shachaf: "re"ally.
10:00:27 <elliott> Complaints to edwardk -->
10:00:44 <TheRedMoodie> I thought is was wierd to use a prisem which i only know from mathematics to a getter which I know from OOP.
10:00:55 <TheRedMoodie> But again, I think haskell could do that :)
10:01:11 <elliott> TheRedMoodie: (We're not actually just making up words.)
10:01:28 <startling> TheRedMoodie, someday you'll start to understand some of what they're saying and all of the sudden you'll have commit access to 'lens' and start to question your sanity.
10:01:30 <Taneb> You're... not just making up words?
10:01:50 <cmccann> more making up new definitions for existing words.
10:02:14 <cmccann> if they were willing to make up words then edwardk wouldn't have a bunch of dictionaries bookmarked to hunt through for new words to steal
10:02:23 <TheRedMoodie> elliott: (I know that, I am just trying to comfort my own phyc")
10:02:38 <TheRedMoodie> What is edwardk ?
10:02:49 <cmccann> that is a very good question
10:02:51 <TheRedMoodie> Is he a bot or a demigod in haskell?
10:02:52 <`nand`> edwardk is a recursive library generating automata
10:03:01 <TheRedMoodie> ......... edwardk <---
10:03:03 <TheRedMoodie> ?
10:03:03 <startling> TheRedMoodie: yes
10:03:07 <cmccann> TheRedMoodie: they're talking about implementation issues for a library which is much simpler to use than to understand and very handy in practice
10:03:25 <TheRedMoodie> Well
10:03:31 <TheRedMoodie> edwardk: Is a person to is seems.
10:03:42 <`nand`> cmccann: the ‚Äòsimple to use‚Äô bit seems to be declining rapidly as soon as you hit a type error
10:03:42 <cmccann> but not something to worry about until you finish LYAH and whatnot
10:03:59 <TheRedMoodie> ..
10:04:00 <TheRedMoodie> X3
10:04:01 <cmccann> `nand`: the trick is to not have type errors really
10:04:17 <TheRedMoodie> you teaser. Now the only thing I can think about is edwardk
10:04:26 <`nand`> cmccann: the solution is to generalize everything to the point where you can use anything as anything, possibly with weird semantics
10:05:25 <cmccann> @quote cmccann without.even
10:05:26 <lambdabot> cmccann says: so edwardk has abstracted things to the point where you can use his libraries without even installing them
10:05:37 <`nand`> :)
10:05:49 <TheRedMoodie> ...
10:06:01 <TheRedMoodie> :) This room is atleast some fun!
10:06:01 <TheRedMoodie> :D
10:06:15 <cmccann> oh wait, better yet
10:06:18 <cmccann> @quote edwardk too.complicated
10:06:18 <lambdabot> edwardk says: Control.Lens is my secret ploy to get everyone to give up on Haskell and just move on to Agda as they find the Haskell types too complicated by comparison.
10:06:49 <shachaf> @quote lens
10:06:49 <lambdabot> roconnor says: a lens is a monoidal natural transformation between higher-order coalgebra functors, what's the problem?
10:06:54 <`nand`> the humor of that is mostly lost on me without having seen the agda-y versions of lens for comparison
10:07:04 <TheRedMoodie> lens?
10:07:06 <TheRedMoodie> WHat is lens?
10:07:12 <TheRedMoodie> T_T
10:07:14 <cmccann> actually I don't think lens would really work in agda as such
10:07:20 <`nand`> http://lens.github.com/
10:07:23 <cmccann> too reliant on typeclass trickery I think
10:07:37 <cmccann> "lens" is the library being discussed here
10:08:06 * `nand` needs to sleep
10:08:23 <shachaf> cmccann: I think aristid tried it and came to the same conclusion.
10:08:33 <TheRedMoodie> So!
10:08:44 <TheRedMoodie> It is kind of a super syntax suger for haskell?
10:08:46 <Saizan> yes, there' some typeclass trickery but not as much, and no implicit generalization either
10:08:56 <TheRedMoodie> Like on top of the allready loads of sugar there is?
10:08:57 <cmccann> shachaf: I think that's what I'm remembering yeah
10:09:05 <Saizan> TheRedMoodie: just a library
10:09:12 <aristid> cmccann: yeah i played with it a bit. the basics did work though
10:09:13 <cmccann> rather, it's "just" a library
10:09:33 <TheRedMoodie> Saizan: ? But the faq said it wanted to abstract haskell more.
10:09:35 <cmccann> but Haskell syntax is pretty flexible so libraries can sometimes look a lot like syntactic sugar
10:09:41 <beaky> I love lenses
10:09:50 <TheRedMoodie> Ph
10:09:55 <TheRedMoodie> Yeah, I knew it was a libary
10:09:57 <aristid> cmccann: i wrote Iso, and "review" worked like a charm but "view" required explicit type annotations due to agda's limited typeclass-alike system
10:10:16 <cmccann> aristid: yeah, I figured "view" wouldn't work as-is
10:10:53 <ocharles> You're trying to do lenses in agda?
10:11:05 <aristid> cmccann: it did work when you explicitly put the right type in scope with a where. funny system
10:11:16 <monochrom> therefore, lens is a secret ploy to get everyone to give up agda and go back to haskell...
10:11:30 <hpc> haha
10:11:55 * beaky does the haskell dance
10:11:56 <cmccann> aristid: but of course, much of lens's utility comes from being able to have things work generically with minimal syntactic noise
10:11:58 <aristid> cmccann: another thing i didn't even try yet is putting the laws into the types, which you obviously can in agda
10:12:06 <shachaf> beaky: are lenses easy
10:12:14 <elliott> aristid: Maybe Un would help out?
10:12:14 <ocharles> aristid: got any code up?
10:12:15 <elliott> Maybe not.
10:12:20 <aristid> ocharles: sure, wait a second
10:12:21 <beaky> shachaf: yeah they are just composable getters and setters
10:12:31 <elliott> from/review separation is so pass√´.
10:12:31 <shachaf> i love lenses
10:12:33 <shachaf> they are so easy
10:12:37 <elliott> pass√™
10:12:37 <beaky> they are ^^
10:12:43 <shachaf> ^^
10:12:43 <aristid> ocharles: https://github.com/aristidb/lens-agda
10:12:46 * beaky does the lens dans
10:12:51 <beaky> dance*
10:13:02 <shachaf> beaky: do you love lenses or monoids more
10:13:04 <TheRedMoodie> Hmm
10:13:06 <TheRedMoodie> the ++
10:13:09 <TheRedMoodie> Is a fun idea.
10:13:22 <jmcarthur> TheRedMoodie: ?
10:13:24 <beaky> shachaf: monoids
10:13:24 <aristid> shachaf: that's a mean question! having to decide between those things :(
10:13:24 <TheRedMoodie> Does that mean that if you want to increment something, you will need to write it out?
10:13:36 <shachaf> elliott: Remember the thing where there are some things you can review but you can't view . from?
10:13:37 <TheRedMoodie> Well that woulden't be a problem, since there are no changing in variables X3
10:13:42 <ocharles> very cool :)
10:13:42 <aristid> beaky: do you love monoids or general categories more?
10:13:57 <TheRedMoodie> I have to eat now
10:14:00 <TheRedMoodie> I will join again later .)
10:14:01 <beaky> what are general catoegires?
10:14:02 <TheRedMoodie> :)*
10:14:07 <jmcarthur> TheRedMoodie: some monads give you something that looks like mutation. at least two give you real mutation
10:14:10 <aristid> beaky: category theory categories.
10:14:17 <beaky> oh
10:14:24 <beaky> what are those?
10:14:24 <TheRedMoodie> jmcarthur: thanks  for the info, I will look into that later
10:14:29 <jmcarthur> don't yet :)
10:14:30 <shachaf> beaky: they're like monoids, except more general
10:14:38 <beaky> ah
10:14:46 <shachaf> beaky: monoids + types
10:14:46 <elliott> shachaf: You can only review profunctor traversals because we don't know what profunctor traversals are.
10:14:55 <beaky> general categories sound neat
10:14:58 <shachaf> elliott: True. But *whatever* Trav is, you can review it.
10:15:02 <aristid> beaky: thingamajigs with objects and arrows and the arrows always have a source and target object, and there are identity arrows and arrows are closed under composition, oh and obviously there needs to be composition
10:15:04 <shachaf> i love general categories
10:15:05 <shachaf> they are so easy
10:15:08 <elliott> shachaf: And reviewing it is useful.
10:15:18 <shachaf> elliott: Maybe.
10:15:20 <ocharles> aristid: this is cool, nice work :)
10:15:28 <aristid> ocharles: thanks:)
10:15:29 <ocharles> terrifying, but cool. that's my normal agda reaction
10:15:37 <elliott> shachaf: Er. I meant to type "useless".
10:15:46 <jmcarthur> agda code is only as terrifying as the things it does
10:15:51 <elliott> I don't think reviewing it even works in general.
10:15:57 <jmcarthur> you can of course write "normal" code in it too. it's just that nobody does that :)
10:16:01 <ocharles> agda code is only terrifying because i haven't studied it enough. i never got as far as records
10:16:01 <shachaf> elliott: It should?
10:16:05 <ocharles> but i generally get the idea behind them
10:16:14 <cmccann> beaky: think monoids except that things have types on each end so that you can only use the monoid operation if the right side of the first matches the type of the left side of the second
10:16:52 <beaky> so functions are monoids too?
10:16:59 <lispy> hello
10:17:11 <jmcarthur> beaky: in at least two ways
10:17:17 <cmccann> well, functions are a category. if you restrict it to functions (a -> a) for a single type they're a monoid
10:17:45 <jmcarthur> beaky: in addition to what cmccann says, there's another monoid on functions for    Monoid b => (a -> b)
10:17:54 <beaky> ah
10:18:12 <ocharles> Monoid b => (a -> b) is a cool one, i need to learn to spot that one quicker
10:18:26 <cmccann> yeah, though the function part is kind of incidental there
10:18:34 <jmcarthur> it's for any applicative
10:18:48 <cmccann> since it's the reader monad + some existing monoid
10:18:49 <jmcarthur> mempty = pure mempty; mappend = liftA2 mappend
10:19:25 <elliott> shachaf: Anyway I think you can review Trav if you give it another parameter.
10:19:37 <elliott> Like how we had to make "view" use Op, not Identity, for simple lenses. Or something.
10:19:47 <shachaf> elliott: You can't even from it.
10:19:59 <shachaf> In a useful way.
10:20:08 <lispy> shachaf: how to parse that?
10:20:21 <lispy> you can't even from-it?
10:20:40 <shachaf> lispy: "from" is a function.
10:20:44 <lispy> ah
10:21:27 <monochrom> soon, "from russia with love" would be valid code using lenses
10:22:17 <sipa> :t from
10:22:18 <lambdabot> (Functor f, Isomorphic k) => AnIso s t a b -> k (t -> f s) (b -> f a)
10:25:22 <shachaf> sipa: That's "old from".
10:25:27 <shachaf> "cool new from" is in k.hs
10:25:31 <beaky> I love functions
10:28:40 <aristid> jmcarthur: re writing normal code: my code in that repo is pretty normal, it isn't far from the haskell implementation of the same things in lens.
10:33:00 <hpc> @src (->) (<|>)
10:33:00 <lambdabot> Source not found. :(
10:33:04 <hpc> :(
10:36:28 <aristid> hpc: is there even a general Alternative on that?
10:37:35 <hpc> unsure
10:37:50 <hpc> but it was easier to search than to figure out if it was possible :P
10:38:04 <Lethalman_> what's alternative? <|>
10:38:28 <fragamus> Im having problems with cryptohash because it allocates pinned memory and seems very wasteful
10:41:21 <hoknamahn> hi guys. i'm trying to compile qtHaskell with ghc 7.6.1 but without luck. ghc 7.4 mentioned this http://pasteboard.co/2gYvH0JI.jpg
10:41:40 <hoknamahn> is it possible to force 7.6.1 to behave in a similar to 7.4 way?
10:42:51 <shachaf> Probably not.
10:43:07 <shachaf> That package should be fixed.
10:43:09 <hpc> i can't even find qthaskell on hackage
10:43:11 <shachaf> It's broken.
10:43:21 <shachaf> [212 of 662]?
10:43:30 <shachaf> That's a lot of modules. :-(
10:43:34 <hoknamahn> yep it's huge
10:43:39 <hpc> qt is huge
10:43:43 <hoknamahn> Qt itself is huge
10:44:29 <hpc> i have strangely never really heard anyone talk about qt
10:44:40 <tryhaskell> there are 3 hoobits and 3 orks on one side of a shore. 2 orks eat 1 hobbit and 3 orks eat 2 hobbits. i need an alglrithm that gives me all possibly variations of carrying all hobbits and orks to the other shore. can someone give me tipps?
10:44:42 <hpc> loads of moaning about gtk not doing sensible things, but never qt
10:44:58 * Lethalman_ trying to revive haskell-gi for gtk3
10:45:10 <hoknamahn> qt is great and already a standard in some industries
10:45:15 <Lethalman_> anybody knows any general reason why haskell-gi would be abandoned?
10:49:36 <parcs> :t \p -> catMaybes . map ((<$) <*> guard . p)
10:49:37 <lambdabot> (a -> Bool) -> [a] -> [a]
10:51:08 <monochrom> tryhaskell: http://xkcd.com/1134/ :)
10:51:55 <monochrom> summary: leave the orcs behind
10:52:26 <s_kilk> hi all, if im using ubuntu, what is the prefered way of installing haskell? i notice that the repository version if haskell platform is 12.02 while the most recent version should be 12.04
10:53:01 <s_kilk> would i be better off installing from source?
10:53:14 <tryhaskell> monochrom: this is funny but doesnt help :D
10:53:14 <hpc> not unless you have lots of time on your hands ;)
10:53:23 <jmcarthur> aristid: yes, it seems pretty normal to me
10:53:26 <hpc> s_kilk: there's binary distributions of the platform
10:53:45 <Lethalman> hpc, is the binary distribution compiled for profiling and shared that you know?
10:53:46 <hpc> s_kilk: don't go through the ubuntu repo or else you risk breakage when you use cabal to install something that's missing
10:53:56 <hpc> Lethalman: i would assume so
10:54:03 <parcs> binary distributions which most likely won't work on modern linux systems
10:54:21 * Lethalman just installed ghc and then all by cabal install with profile and shared and dynamic etc
10:54:29 <Lethalman> no haskell-platform
10:54:44 <s_kilk> hpc: so would you advise building from source?
10:55:15 <parcs> what ghc verson does 12.02 have? if it's recent enough i would say just install the HP via ubuntu
10:55:34 <hpc> parcs: still causes problems when you start using cabal
10:56:31 <parcs> well even the latest HP release can cause the same problems
10:56:41 <s_kilk> parcs: i think the ghc is recent enough, though the only issue i have is that id like to play with the rethinkdb package, but it requires base >=4.6 i think, or something like that
10:57:09 <shachaf> base 0.4.6 == ghc 7.6
10:57:40 <s_kilk> here http://hackage.haskell.org/package/rethinkdb
10:57:48 <parcs> s_kilk: that's a maintainer fail
10:58:04 <roadfish> does it make sense to have multiple ~/.ghc directories? I mean move ~/.ghc to ~/.ghc-v1 then do cabal install operations with different--constraint= values. Then do renaming of ~/.ghc to switch between v1 and v2?
10:58:09 <s_kilk> parcs: i suppose it is
10:58:48 <monochrom> haskell platform is not at ghc 7.6 yet
10:58:49 <hpc> roadfish: you'd just use multiple ghcs
10:59:07 <hpc> the multiple compiler versioning support is already there
10:59:08 <hpc> $ ls .ghc/
10:59:08 <hpc> ghci_history  i386-linux-7.0.4  i386-linux-7.4.1
10:59:25 <parcs> still on 32bit?
10:59:31 <s_kilk> now that im looking at it, a requirement for base 4.6 seems crazy
10:59:34 <fmap> parcs: nah, apparently it uses -XDataKinds and they don't work on 7.4
10:59:45 <hpc> parcs: it's a truly ancient laptop that i am running into the ground
11:00:08 <hpc> it's been good for me too; my record uptime with it is 380 days
11:00:21 <hpc> keep trying to beat that, but there's always a power disruption or someone unplugs it
11:01:56 <monochrom> roadfish: you are better off using a complete sandboxing solution such as cabal-dev or there is another one not on hackage
11:02:24 <roadfish> hpc: I had to do --constraint=... to get blank-canvas package installed. But the version that I installed isn't working. So I thought if I start from a fresh slate, then I could get a newer version of blank-canvas.
11:02:30 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml for what is in ~/.ghc and what is not
11:03:02 <roadfish> monochrom: ok, so there is something called sandboxing. I think this is what I want to try.
11:04:04 <roadfish> I was browsing sicp.xhtml and it says that you can just erase ~/.ghc to start from fresh slate ... don't need to delete ~/.cabal
11:04:19 <roadfish> but maybe sandboxing is what I want instead of switching between different ~/.ghc directories.
11:04:53 <monochrom> I say just erase ~/.ghc because later ~/.cabal will be irrecoverably overwritten
11:04:53 <johnw> roadfish: right, you don't need to delete ~/.cabal; but have you tried cabal-dev?
11:05:23 <roadfish> I'm going to be reading up on cabal-dev now. Thanks
11:06:34 <monochrom> but you are saying, don't erase ~/.ghc, save it somewhere, restore it later, but not until you irrecoverably overwrite things in ~/.cabal . well that's clearly different
11:07:40 <roadfish> so my idea of switching .ghc files is a bad idea ... what I really want to use is sandboxing.
11:09:09 <osa1> what is the easiest way to print to console with colors ? is it possible without using any libraries ?
11:10:02 <c_wraith> osa1: if you know you're printing to a terminal that supports ANSI escape sequences, you can send them without a library.  It's just painful and errorprone.
11:10:07 <jmcarthur> osa1: you can just find the correct code sequence to write out.
11:11:03 <osa1> ok I think I'll try ANSI escape seqs before moving to a third-party lib
11:11:48 <hpc> it can be different escapes for different terminals afaik
11:14:20 <c_wraith> Yes, it can
11:14:53 <HalfMadDad> hi. This channel has over 1K people in it. Haskell does not seem so popular on the tiobe and transparent popularity language indexes. Is Haskell a sleeping giant or are there pretty girls in here or something?
11:15:28 <roadfish> a bit of both I hope
11:15:33 <zomg> HalfMadDad: nah there just are many people who don't know how to haskell so they come here seeking for englithenment
11:15:41 <zomg> *enlightenment
11:15:49 <monochrom> I can't see any relation between your 3 sentences. are you sure you are coherent?
11:16:02 <hpc> roadfish: haskell is a sleeping giant full of pretty girls? sounds like a grimm fairy tale
11:16:11 <HalfMadDad> zomg, Ah! Thanks
11:16:26 <roadfish> hpc: calls for some Haskell heroics!
11:16:52 <hpc> also whoa, we really did break 1000
11:17:20 <HalfMadDad> hpc your up there with ubuntu
11:17:20 <roadfish> Haskell is harder to learn. So newbies do have to ask questions longer. Also, you stay a newbie longer ... maybe indefinitely.
11:17:26 <lispy> HalfMadDad: #haskell is known for being friendlier than the other language channels on freenode. Perhaps those channels would be even larger if they shared our reputation.
11:18:10 <hpc> theoretically, #haskell is friendlier precisely because of how deep the language is
11:18:11 <roadfish> The scope of ideas seems to be much less in other languages. So there just isn't much to talk about.
11:18:25 <hpc> everyone in here is still a newbie at some aspect, so they know what it's like when someone completely new comes in
11:18:45 <hpc> and are much less inclined to be of the "i know the language perfectly and you are wrong" persuasion
11:19:09 <lispy> HalfMadDad: BTW, are you here to learn haskell? have you seen tryhaskell.org or http://learnyouahaskell.com/ ?
11:19:12 <Lethalman> also, from reading people in this channel often you learn many things that aren't explained elsewhere
11:19:32 * Lethalman is sitting in here also because of that, not just to ask
11:19:32 <HalfMadDad> lispy, I think I might, thanks for the link
11:19:35 * monochrom is inclined to "I don't know it perfectly, but you are still wrong"
11:19:50 <slack1256> Lethalman: I know that feel
11:19:53 <roadfish> I'm gotten the impression that Haskell is really a cutting edge of language development. New ideas are created here first and explored more deeply. I've read that may ideas are even developed by thrashing it out on #haskell first.
11:19:54 <conal> Hi All. I just wrote a StackOverflow comment on "Why are getArgs and getProgName IO actions?" (and more broadly): http://stackoverflow.com/questions/14295582/why-are-getargs-and-getprogname-io-actions/14296888#14296888 . Sharing here, since it addresses something of FAQ.
11:20:27 <lispy> conal: cool
11:20:39 <HalfMadDad> gotta go again, thanks for the feedback and tips everyone :)
11:20:42 <Lethalman> especially on ways to do things and have some ideas on what's deprecated and what's new in the typeclass world
11:21:16 <roadfish> recently, I used getArgs and getFullArgs so that the program auto-supplies parameters when running in ghci but not when compiled by ghc.
11:21:46 <lispy> conal: I find the phrase "mathematical value" feels wrong to me. What is a non-mathematical value?
11:22:02 <lispy> HalfMadDad: enjoy :)
11:22:37 <conal> lispy: if you're a math-head (like me), it's redundant. i added "mathematical" to stress that i mean something precise, not hand-wavy.
11:23:00 * lispy ponders that
11:23:35 <monochrom> perhaps a value of type "IO X" is a non-mathematical value
11:23:41 <conal> lispy: since complexity can (and does) hide behind hand-waving.
11:23:42 <shachaf> conal: Hah, I thought of you when I saw that question.
11:23:49 <conal> shachaf: :)
11:23:52 <Lethalman> conal, are you the one here? http://conal.net/papers/push-pull-frp/
11:24:03 <conal> Lethalman: yep. hi.
11:24:03 <Lethalman> awesome :)
11:24:40 <conal> lispy: i'm not attached to this this phrasing. i'd love to improve it, as this topic is very important to me.
11:24:59 <Lethalman> conal, can you point me to a library implementing some of those recent FRP concepts?
11:25:05 <Lethalman> (if any)
11:25:35 <conal> Lethalman: FRP theory & implementation are rather chaotic these days.
11:26:19 <conal> i'm often stunned by what people label as "FRP". often based on operational aspects like dependency tracking & updating.
11:26:34 <lispy> conal: Using mathematical here as a synonym for "precise, not hand-wavy" seems okay to me. I think what was getting to me is hard to express.
11:26:57 <roadfish> conal: I was doing some reading on arrows and FRP last night. I see that your blog has entries tagged on FRP. I'm getting the sense that FRP is useful for GUI creation. Don't quite understanding arrows yet but am getting a bit of a sense of FRP.
11:27:16 <Lethalman> conal, ok thanks
11:27:18 <lispy> conal: I think often people say "mathematical" without taking the time to be mathematical about what they mean by that :)
11:27:27 <conal> lispy: indeed :)
11:28:03 <lispy> conal: I would almost argue that we shouldn't say "mathematical" as short hand for "precise, not hand-wavy" and that instead we should call it euclidean
11:28:10 <conal> lispy: and i'm guilty of hand-waving in that SO comment. for instance, i swept bottoms under the rug.
11:28:24 <Lethalman> roadfish, there's lots of libraries in http://www.haskell.org/haskellwiki/Functional_Reactive_Programming but seems like reactive-banana is the most concrete for what concerns the GUI
11:28:36 <monochrom> euclid had his share of handwaving too, but ok!
11:28:42 <hpc> haskell has a long tradition of simultaneously caring about and ignoring bottoms :P
11:28:45 <conal> lispy: oh, hm! i'm intrigued. what do you get out of "euclidean"√∑
11:28:53 <lispy> conal: euclidean because he seems to be the one that took the time to demonstrate the power of reasoning from simple axioms in his elements
11:28:58 <conal> hpc: we sure do.
11:29:03 <Lethalman> or better I can't grasp the other ones :S
11:29:53 <monochrom> euclidean here means "like The Elements" as opposed to "like sqrt(x^2+y^2)"
11:30:05 <lispy> conal: much of greek geometry was known already, but a librarian he took the time to put it paper in a coherent way that showed you could use it as a foundation for building beautiful things
11:30:19 <conal> lispy: ah. nice. :)
11:30:52 <monochrom> however, if you say euclidean to the SO bunch, they will think sqrt(x^2+y^2) too, just like you did
11:30:57 <lispy> yeah
11:31:00 <lispy> that's a problem :)
11:31:09 <monochrom> rigorous
11:31:17 <roadfish> maybe we could divide into Euclidean and Platonic
11:31:24 <monochrom> however, "rigorous value" sounds strange
11:31:40 <lispy> maybe landin's terminology would spare us
11:32:04 <roadfish> that being?
11:32:31 <lispy> roadfish: see the "Edit:" at the bottom of conal's answer: http://stackoverflow.com/questions/14295582/why-are-getargs-and-getprogname-io-actions/14296888#14296888
11:32:37 <parcs> lol http://i.imgur.com/rxec4.png
11:33:06 <Lethalman> conal, is this your library of reference or there are others? http://hackage.haskell.org/package/reactive
11:33:06 <monochrom> oh, denotative value works
11:33:33 <conal> Lethalman: that library corresponds pretty closely to the push-pull paper.
11:33:37 <roadfish> lispy: ok, so a bit like denote vs connote
11:33:48 <hpc> parcs: it's so simple!
11:34:16 <conal> i've been trying to raise awareness of this notion of "denotative" programming for the last few years, since it brings clarity to fundamental questions where "functional" doesn't.
11:36:21 <conal> and while haskell might be "purely functional" (whatever that means), it's not yet "purely denotative". and i think correct reasoning arises from denotative programming.
11:37:20 <lispy> interesting, wikipedia's article about denotations says that in CS denotational semantics is contrasted with operational semantics (seems like it's contrastable with more than just operational semantics)
11:37:37 <roadfish> parcs: is this like Feynman diagrams for Haskell code?
11:38:23 <roadfish> parcs: do you have the article URL that this comes from?
11:38:30 <conal> I just added a comment on another answer: http://stackoverflow.com/a/14296232/127335
11:38:45 <conal> (on getProgName and IO)
11:39:39 <nus> conal,  "However, there is no such sequence of characters that captures the intent behind getProg." -- perhaps, a bit more elaboration on that would help in the answer
11:40:02 <conal> nus: thanks.
11:42:15 <hpc> perhaps, "... captures the intent behind getProg. getProg could be many different things, ranging from 'prog.exe' to 'prog_i386' or perhaps someone installed your program improperly and instead it could be 'fnord'."
11:42:21 <conal> nus: how about this:
11:42:25 <conal> However, there is no *single* sequence of characters that captures the intent behind `getProgName`.
11:42:25 <conal> (*Edit*: Presumably, you want `getProgName` to yield different strings when it appears in differently-named programs.)
11:42:49 <hpc> conal: do it from the library perspective
11:42:55 <lispy> "A rule of thumb I like to use is that any pure value could be completely evaluated at compile time." <-- I don't see how this rule of thumb works or is even true.
11:43:15 <hpc> there's no single sequence of characters that you can denote getProgName to be equal to, that you can put into a library that's reused in many programs
11:43:46 <hpc> lispy: any pure top-level value
11:43:51 <conal> lispy: that rule of thumb puzzles me as well. i have no idea where it comes from.
11:43:55 <hpc> perhaps
11:44:04 <lispy> hpc: CAFs?
11:44:24 <lispy> hpc: surely head is a pure top-level value (functions are values, right?)
11:44:29 <hpc> yes
11:45:09 <lispy> conal: I wonder if that rule of thumb is conflating totality with something else
11:45:12 <hpc> one could even say that the mere act of compiling haskell is computing the final value of main
11:45:24 <hpc> and the value of main is a program that gets executed later
11:46:05 <startling> what's the way to turn a "Simple Lens X [Y]" into a "Simple Traversal X Y" ?
11:46:32 <edwardk> .traverse
11:47:02 <monochrom> there is no single number denoting "maxBound :: Int". probably, "maxBound :: Char" too, as the Unicode standard is updated and GHC follows
11:47:05 <startling> OH, right, neat
11:47:06 <lispy> startling: I'm not confident in saying this, but I think edwardk's talk in NYC about lens covers that example
11:47:07 <edwardk> > (1,"hello") & _2.traverse %~ toUpper
11:47:09 <lambdabot>   (1,"HELLO")
11:47:31 <startling> lispy: I've seen it before, I just forgot how to make the types fit. :)
11:47:39 <startling> the crazy type signatures in HEAD aren't helping
11:48:11 <monochrom> I am saying that "it must be the same value across all executions, across all environments" is dubious
11:49:08 <elliott> startling: Just look at the example type signatures that are given in the docs.
11:49:10 <elliott> Not the actual types.
11:49:32 <startling> elliott: my type errors aren't in the docs. :/
11:50:15 <elliott> Complain to edwardk then :P
11:50:47 <startling> the bigger problem ime is telling whether a huge type signature of something I wrote is correct and overly general or terrible and wrong
11:52:48 <edwardk> startling: in the last 48 hours head has simplified a number of the signatures
11:52:54 * hackagebot mustache2hs 0.2.1 - Utility to generate Haskell code from Mustache templates  http://hackage.haskell.org/package/mustache2hs-0.2.1 (StephenWeber)
11:52:59 <lispy> My tip of the day for Haskellers on windows: Install DejaVu Sans and use DejaVu Sans Mono for your Haskell stuff. I thought MS's Consolas was nice but DejaVu Sans is very similar typographically but has many more glyphs than Consolas.
11:53:02 <startling> edwardk: good to know. :)
11:53:31 <lispy> I hooked my vim up to DejaVu Sans and now I can use the unicode-haskell.vim plugin
11:54:00 <hoknamahn> is anyone experienced a bug when leksah doesn't save a file?
11:54:14 <lispy> no, but that sounds annoying
11:54:22 <lispy> (I also don't use leksah)
11:55:00 <hoknamahn> yep it is very annoying
11:55:13 <nus> conal, maybe something like "while type String denotes all strings, getProgName :: Sting would denote only one of them.." to emphsize the typing relationship
11:55:38 <nus> err, spelling
11:56:36 <conal> nus: i'm confused. String does denote all strings, and to say "e :: String" does mean to me that e denotes one of them.
11:57:40 <conal> i.e., i understand "e :: t" as "meaning e ‚àà meaning t", so elements on the left and collections on the right.
11:58:35 <conal> we don't want getProgName to denote a string or a set of strings. rather some kind of function from hairy context to strings.
11:58:36 <startling> hoknamahn, sounds almost as bad as the GHC bug that deleted code that didn't typecheck
12:00:12 <hoknamahn> starling, wow i didn't know about such ghc bug
12:00:22 <jmcarthur> it's from quite a long time ago
12:00:42 <nus> conal, yes, that's clear, but the topic starter wasn't getting that, what it would mean to bind a name to a value
12:03:18 <jmcarthur> conal: as you can guess, i'm with you here, but to play devil's advocate, i think a lot of people might be envisioning these sorts of things as free variables. that is, "my program is running is running in some context. i don't know how i got them, but here are some values i can use, at least until i leave this context"
12:04:54 <conal> jmcarthur: yeah. i've run into that sort of thinking.
12:08:05 <conal> jmcarthur: i wonder how it is that they choose when it's cool to fill in that context and when it's not. for instance at compilation, program startup, program migration (to another thread, processor, machine, OS, ...), or randomly.
12:09:26 <ski> conal : s/"strings"/"strings"./,s/then the then/then the/
12:09:53 <monochrom> I choose program execution session. perhaps that's your program startup
12:10:29 <monochrom> cmdline arguments and maxBound::Int are invariant across thread migration
12:11:06 <conal> ski: thanks very much! fixe.
12:11:12 <ski> conal : another problem with stuff like `getProgName' and `getArgs' (and environment variables, &c.) is that giving them types `String' and `[String]' would complicate mobile code or stuff like `exportML' and `exportFn' at <http://www.smlnj.org/doc/SMLofNJ/pages/smlnj.html#SIG:SML_OF_NJ.exportML:VAL>
12:11:15 <monochrom> I cannot use migration to another hardware+OS here and now. it is hypothetical.
12:11:31 <jmcarthur> conal: since they are free variables, i think it only makes sense for it to happen some time prior to execution
12:11:42 <jmcarthur> even if only immediately prior
12:11:51 <monochrom> the only such migration I know is wholesale virtual machine migration, but that one works very hard to keep even maxBound::Int invariant
12:12:22 <conal> jmcarthur: i wonder: what is that sense that it only makes? and why only then?
12:13:57 <jmcarthur> conal: i will try to be more precise (and i think it will involve backing out from the point a bit)...
12:14:16 <timau> is this how one would implement setAt (changing list element) in haskell?
12:14:30 <hpaste> timau pasted ‚ÄúsetAt‚Äù at http://hpaste.org/80670
12:15:03 <conal> ski: amen about mobile code.  http://conal.net/blog/posts/notions-of-purity-in-haskell#comment-17812
12:15:05 <ski> jmcarthur : hm, i suppose if we had module functors, one could express a program as a functor from a context module to the actual program ..
12:15:28 <conal> ski:  and my next comment on that page about Y2K.
12:18:27 <beaky> I love haskell
12:18:58 <johnw> beaky: :)
12:18:58 <aristid> beaky: then you're in the right channel.
12:19:18 <johnw> hi aristid!
12:19:20 <monochrom> beaky has been in the right channel for a month or two
12:19:24 <aristid> hi johnw
12:19:46 <aristid> johnw: you and bas are the same "release aws!" pressure group, right? :P
12:19:47 <nexx> You are so insightful aristid
12:19:53 <johnw> yep
12:20:31 <jmcarthur> conal: i think i will just take back my "it only makes sense when" point and make a different one. i think it is simply unimportant *when* a free variable is filled. it only matters that it is treated like a normal value, even though you don't know what that value is.
12:20:38 <aristid> nexx: i am? :P
12:21:10 <monochrom> > splitAt 2 [0, 1, 2]
12:21:11 <lambdabot>   ([0,1],[2])
12:21:32 <monochrom> yes timau
12:21:59 <timau> monochrom: how?
12:22:23 <monochrom> eh? you pasted code and I am saying it is correct
12:22:37 <timau> oh, you meant that is how one would implement it
12:22:56 <timau> I thought it could maybe be done more efficiently
12:23:26 <jmcarthur> conal: the ability to migrate a program with free variables would require that the contexts be the same, of course
12:23:50 <shachaf> timau: It can probably be a bit more efficient, but if it really matters, you shouldn't be using lists.
12:23:53 <jmcarthur> conal: otherwise the free variables are not being treated like values (since they would change destructively when you migrate the program)
12:23:58 <shachaf> Wait, you're the chessboard person, aren't you?
12:24:05 <shachaf> You shouldn't represent a chessboard as a list of lists.
12:24:06 <jmcarthur> s/they/the environment/
12:24:34 <shachaf> > set (element 2) 'x' "hello"
12:24:36 <lambdabot>   "hexlo"
12:25:11 <monochrom> perhaps this is why gcc decides to say that int is 32-bits on both x86 (32-bit) and x86-64
12:25:19 <timau> shachaf: yes that's me. I am just doing this for learning purposes
12:25:42 <timau> shachaf: how could it be done more efficiently?
12:25:53 <timau> without switching to array
12:25:57 <basdirks> a bitboard
12:26:01 <basdirks> oh =[
12:26:06 <shachaf> You could build up the list as you go or something.
12:26:08 <shachaf> I don't know.
12:26:08 <basdirks> bitboards are fun though
12:26:13 <shachaf> No one said to switch to arrays.
12:26:22 <Taneb> How would you represent a list of lists THAT ARE THE SAME LENGTH, but you don't care about the length
12:27:04 <shachaf> So a list of length n^2 for some n?
12:27:06 <timau> basdirks: that sounds interesting.
12:27:31 <jmcarthur> Taneb: must the outer list also be of that length?
12:27:49 <shachaf> Oh, I suppose maybe it doesn't have to.
12:27:57 <Taneb> jmcarthur, no
12:28:13 <shachaf> Never mind, then.
12:28:36 <timau> one bit for color, and 3 bits for piece
12:28:41 <basdirks> either you do data Board = Board { BlackRook :: Int8, etc...
12:28:42 <jmcarthur> Taneb: is this intended to be used as some sort of a 2d array or something?
12:28:48 <Taneb> jmcarthur, sort of
12:28:55 <Taneb> Array (Int, Int) isn't quite
12:29:03 <jmcarthur> oh, what's the difference?
12:29:04 <Taneb> Because I want the corner to be (0,0) if anything
12:29:06 <basdirks> or you do bitboards
12:29:10 <basdirks> bitboards are nicer
12:29:20 <Taneb> Whereas with Array it could be anything
12:29:24 <basdirks> data Board = { BlackRooks = Int8 etc
12:29:26 <Taneb> It could be (72, -432905)
12:29:35 <jmcarthur> Taneb: then use Array (Word, Word)
12:29:53 <jmcarthur> wait
12:29:54 <Taneb> jmcarthur, so the corner could be (65, 23)?
12:30:09 <jmcarthur> i've not used Data.Array in a long time
12:30:16 <jmcarthur> i don't remember that property
12:30:18 <basdirks> you'll need 12 Boards
12:30:28 <basdirks> 2x6 kinds of pieces
12:30:35 <jmcarthur> oh i see
12:30:38 <jmcarthur> now i remember
12:30:48 <basdirks> then you can XOR the boards etcx
12:31:01 <basdirks> it's really convenient =]
12:31:41 <monochrom> do you want a rectangle array, jmcarthur? it's Array indextype contenttype. try indextype = (Int,Int)
12:31:45 <basdirks> like freeSquares = fold XOR AllBlackPieces
12:31:55 <Taneb> monochrom, he's trying to help me
12:31:56 <jmcarthur> monochrom: you mean Taneb?
12:32:08 <monochrom> yes
12:32:13 <Taneb> I want a rectangular thingy, but with the lower bound stuck on (0,0)
12:32:37 <jmcarthur> my understanding is that Taneb wants the floating origin to be inexpressible
12:32:41 <monochrom> lower and upper bounds are specified at run time, when you call "array" or "listArray"
12:33:03 <jmcarthur> Taneb: the only other higher dimensional array library i use is repa, which is often not what you want
12:33:04 <monochrom> @type listArray
12:33:05 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
12:33:18 <jmcarthur> Taneb: but repa does at least always have the origin at 0
12:33:26 <monochrom> listArray ((0,0), (1,1)) [a, b, c, d]
12:33:38 <jmcarthur> (except for delayed arrays, maybe, but that would probably be misusing it if you did that)
12:33:41 <Taneb> I don't really know repa, I'll give it a look
12:34:16 <jmcarthur> Taneb: i still think Data.Array is probably fine. you could define your own interface around it if you want to limit how it may be used
12:45:11 <k0ral> hello, let type A = Monad1T (Monad2T (Monad3T X))); let newtype A' a = A' { runA' :: A a }; I would like to work with A' and still access the inner Monad2, but the fact that I wrapped A seems to prevent me from using lift; how would you do ?
12:46:09 <k0ral> in real world haskell chapter 18, the use of lift is explained only for A, not for A'
12:46:22 <Nereid> k0ral: you should give A' the appropriate monad transformer instances.
12:46:42 <k0ral> Nereid: which ones ?
12:46:44 <Nereid> er, as in MonadTrans.
12:46:49 <Nereid> for lift.
12:46:53 <Nereid> or MonadIO for liftIO, or ...
12:47:11 <Nereid> you can derive them with GeneralizedNewtypeDeriving
12:47:24 <k0ral> it works with Monad, MonadIO, but not MonadTrans
12:47:32 <shachaf> You can derive *anything* with GeneralizedNewtypeDeriving!
12:47:35 <shachaf> Like unsafeCoerce.
12:47:38 <Nereid> :D
12:47:55 <Nereid> isn't that only in combination with something else like TypeFamilies though?
12:48:36 <shachaf> TypeFamilies or GADTs or something.
12:48:38 <k0ral> ok guys, I may be wrong but even if this automatic deriving would have worked, I'm not sure this would give me what I want
12:48:41 <shachaf> Or isn't Rank2Types enough?
12:49:25 <Nereid> hmm.
12:49:38 <k0ral> I mean, if A' is made instance of MonadTrans, I could use lift, but I don't think it would do what I want, ie unwrap a single monad of the stack
12:49:39 <Nereid> maybe you're right.
12:50:05 <Nereid> ah.
12:50:10 <k0ral> it would lift the whole A' transformer
12:50:14 <Nereid> sure.
12:50:21 <k0ral> what I want is to unwrap only Monad1
12:50:29 <Nereid> hmm.
12:50:36 <k0ral> and to be able to do lift . lift to unwrap Monad1 & Monad2
12:50:49 <monochrom> MonadIO is designed so that one liftIO shoots through all layers. MonadTrans is designed so that you write N lift's for N layers. this is because no one but you knows how many layers to shoot through. perhaps you have 10 layers in total but you only want to shoot through 3 today
12:51:28 <k0ral> monochrom: err, I'm okay with that, so ?
12:51:29 <monochrom> but you can define your own MonadK class with method liftk to automatically shoot through all layers
12:51:38 <Nereid> ok, then I guess that doesn't work if you use a newtype.
12:52:10 <allsystemsarego> Hi all, what does the alias <*> stand for?
12:52:13 <k0ral> basically I would like to define a class HasMonad2, and make (A' m) instance of it
12:52:22 <Nereid> allsystemsarego: it's a method of the Applicative class.
12:52:22 <allsystemsarego> @hoogle <*>
12:52:23 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
12:52:57 <monochrom> you have "A' (M1 (M2 (M3 X)))", you want to get at M2? so that's shooting through A' and M1. lift (lift (blah))
12:53:00 <Nereid> k0ral: what, may I ask, are Monad1T etc.?
12:53:04 <k0ral> HasMonad2 would be to Monad2 what MonadReader is to Reader
12:53:11 <allsystemsarego> Nereid, thanks, could you give a usage example?
12:53:25 <Nereid> allsystemsarego: that is as difficult as giving a usage example for monads.
12:53:40 <allsystemsarego> ok :(
12:53:47 <Nereid> @where typeclassopedia
12:53:47 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
12:53:52 <Nereid> this might be a place to start.
12:54:02 <allsystemsarego> thanks
12:54:05 <k0ral> Nereid: if you must know, it's : newtype (Monad m) => KT m a = KT { runKT :: ErrorT HError (WriterT String (ReaderT CliOptions (ReaderT (IORef (Config (KT m))) (ReaderT (GUI (KT m)) (ReaderT IPC m))))) a}
12:54:09 <monochrom> ok, you want to do it the HasMonad2 way?
12:54:28 <Nereid> k0ral: you can replace a bunch of stacked ReaderTs with a single ReaderT of a product.
12:54:44 <monochrom> instance HasMonad2 A' where lift2 (A' x) = A' (lift2 x)
12:54:51 <k0ral> Nereid: I did this before, and I don't want to do it anymore
12:55:00 <Nereid> why not?
12:55:05 <k0ral> Nereid: it breaks the logical separation
12:55:10 <Nereid> :(
12:56:33 <k0ral> monochrom: trying to understand what you wrote; basically, lift2 unwraps A', right ?
12:57:05 <monochrom> I wouldn't say that. since it re-adds A'
12:57:16 <k0ral> hmmm
12:57:43 <monochrom> if you want a "basically", basically, lift2 shoots through layers "recursively"
12:58:14 <monochrom> generally, I would forget "basically" inaccurate simplifications
12:58:44 <monochrom> typo
12:58:52 <k0ral> I got it working
12:59:05 <monochrom> instance (HasMonad2 m) => HasMonad2 (A' m) where lift2 (A' x) = A' (lift2 x)
12:59:26 <k0ral> KT $ ((lift . lift . lift) ask >>= liftIO . readIORef
13:00:01 <k0ral> that's the way I access the inner Config (KT m) in the type I quoted above
13:00:09 <k0ral> A' is KT here
13:00:29 <monochrom> you got it working. so we can close the case now
13:01:05 <k0ral> thank you, your lift2 made me understand I had to apply A' on top of all the lift . lift . lift
13:03:37 <ski> `HasMonad2'
13:03:39 <ski> ?
13:05:33 <parcs> how does 'atomically (mapM readTMVar list_of_tmvars)' work? do the TMVars get read & returned sequentially or do they get read in the order that they become full and then get returned in order?
13:05:33 <k0ral> ski: yes ?
13:05:52 <ski> i was wondering what it meant, or how it was defined
13:05:53 <Wizek> Can I write `zip [0..5] (repeat 0) ++ zip (repeat 0) [1..5]` more elegantly?
13:06:38 <parcs> Wizek: i think that's pretty elegant
13:06:43 <derdon> Wizek: write a general function for that
13:06:50 <ski> Wizek : perhaps `map (flip (,) 0) [0 .. 5] ++ map ((,) 0) [1 .. 5]' ?
13:07:15 <Mortchek> Wizek, depending on your meaning / reason for doing that, you could use a cartesia product function
13:07:20 <Mortchek> cartesian*
13:07:31 <k0ral> ski: just a way to abstract the MonadXXX (MonadReader, MonadWriter...)
13:07:36 <derdon> ski: what does (,) do?
13:07:48 <Nereid> (,) a b = (a,b)
13:07:58 <Nereid> :t (,)
13:07:59 <lambdabot> a -> b -> (a, b)
13:08:08 <derdon> oh, I didn't know that the comma is a function there. neat!
13:08:16 <Nereid> :t (,,,,,,,,,,,,,,,,,,,,)
13:08:17 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)
13:08:19 <derdon> another reason to love haskell :)
13:08:29 <Nereid> it's special syntax.
13:08:55 <Nereid> with TupleSections, you could write
13:08:57 <derdon> so the comma in (a,b) works just like an infix operator
13:08:58 <Nereid> (,) 0 = (0,)
13:09:01 <Nereid> flip (,) 0 = (,0)
13:09:08 <derdon> nice
13:09:10 <Nereid> you could think of it that way.
13:09:11 <k0ral> :t flip (,) 0
13:09:12 <lambdabot> Num b => a -> (a, b)
13:09:14 <Nereid> but it's really special syntax.
13:09:40 <Nereid> :t (,0)
13:09:41 <lambdabot> Illegal tuple section: use -XTupleSections
13:09:43 <Nereid> baw
13:09:55 <Nereid> :t (.)
13:09:56 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:10:07 <Nereid> Cale: TupleSections please, and also change (.)
13:10:09 <Nereid> ;)
13:10:19 <Wizek> :t (::)
13:10:20 <lambdabot> parse error on input `::'
13:10:40 <c_wraith> :: is syntax
13:10:46 <c_wraith> Not an operator
13:11:25 <Nereid> :t (:::)
13:11:26 <lambdabot> Not in scope: data constructor `:::'
13:11:36 <Wizek> Why isn't everything a function? :)
13:12:27 <parcs> if only values were types then :: could be a function
13:12:35 <parcs> er, types were values
13:12:58 <Nereid> what would its return type be?
13:13:31 <Nereid> it's as much a function as = is
13:14:27 <parcs> (::) :: (T : Set) -> (a : T) -> T
13:14:36 <parcs> okay the arguments are reversed and you need dependent types
13:15:06 <Nereid> oh, I was thinking :: for top level declarations.
13:15:24 <Wizek> derdon: I'm thinking of one, none came to mind yet. ski: well, that's a little more ofuscated, I'm unsure I'd use that. Mortchek: does that yield len a * len b array? If so then it's not good since I need len a + len b - 1
13:15:28 <ski> `::' is more like a syntax operator
13:15:28 <elliott> It's weird that you can't do (a : T) -> (T : Set) -> T.
13:15:31 <parcs> oh, yeah, i meant type annotations in an expression context
13:15:41 <Nereid> yeah. that makes sense.
13:16:00 <ski> elliott : why ?
13:16:11 <Mortchek> Wizek, well, it'd be two trivial cartesian products. But I wouldn't do it if the logic just happens to look like one but doesn't generalize to one.
13:16:33 <elliott> ski: Well, it's not so much weird as annoying.
13:16:48 <Wizek> I see Mortchek
13:17:12 <Mortchek> {a, b, c}√ó{0} = {(a, 0), (b, 0), (c, 0)}. {0}√ó{a, b, c} = {(0, a), (0, b), (0, c)}
13:18:52 <ski> elliott : in Alfa (using Agda1 as proof engine) you could/can make the visual order of arguments differ from the "core" one
13:19:48 <elliott> ski: cool
13:21:09 <ski> @where Alfa
13:21:09 <lambdabot> Proof editor, using Agda1 proof engine/checker, at <http://www.cse.chalmers.se/~hallgren/Alfa/>,(broken) <http://www.cs.chalmers.se/~hallgren/untested>,<http://ogi.altocumulus.org/~hallgren/untested>
13:21:09 <lambdabot> ,<http://ogi.altocumulus.org/~hallgren/untested/for_Linux/alfa-041029-bin-i386-Linux-RedHat9.tar.gz>,<http://ogi.altocumulus.org/~hallgren/untested/Source_code/alfa-050126.src.tar.gz>. Also see `
13:21:09 <lambdabot> Agda',`Fudgets',`GF'
13:21:21 <ski> elliott : example screenshot <http://i.imgur.com/Fn6Gr.png>
13:22:31 <elliott> looks more readable than agda2 code :P
13:23:33 <parcs> looks like 'mapM readTMVar' attempts to read each TMVar one-by-one, sequentially
13:24:26 <ski> elliott : i'm using a special "Natural Deduction" view of the proofs there -- otherwise it looks more or less like Agda2
13:25:13 <ski> (and yes, it's possibly change to "tall" instead of "wide" view of the ND proofs)
13:27:18 <ski> you write code/proofs by placing point at a hole ("?"), and then typing the chars according to the option (auto-generated, including local variables, only showing things fitting the type of the hole) you want to use in the window to the right
13:28:34 <ski> .. and any type variables that get unified to something by inserting a node into such a hole automatically gets propagated to other holes, if required by typing
13:28:53 <parcs> the async library is great
13:32:35 <fragamus> :t Data.Digest.Pure.MD5.md5Finalize
13:32:36 <lambdabot> Couldn't find qualified module.
13:33:06 <fragamus> :import Data.Digest.Pure.MD5
13:35:05 <fragamus> Data.Digest.Pure.MD5.md5Finalize type signature is wrong     there is an extra parameter thet seems weird
13:41:44 <elliott> fragamus: What's wrong about it?
13:41:57 <fragamus> theres an extra parameter
13:42:11 <elliott> Extra compared to what?
13:42:12 <fragamus> a byte string that seems to have no purpose
13:42:23 <fragamus> it should just take a context
13:42:30 <fragamus> I'm looking at source
13:45:40 <fragamus> has something to do with padding
13:49:59 <johnw> does anyone know where the Automatic type class comes from?
13:50:16 <bergmark> johnw: fay?
13:50:35 <nus> @where hayoo
13:50:35 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
13:50:42 <nus> johnw, ^^^
13:51:09 <johnw> nus: that does not help, neither can hoogle find it
13:51:45 <johnw> it's being used by fay, but not defined by fay....
13:52:01 <johnw> anyway, i'll just keep digging
13:52:48 <bergmark> johnw: it's a magic thingie
13:52:55 <johnw> yeah?
13:53:01 <bergmark> https://github.com/faylang/fay#the-ffi
13:53:04 <johnw> it's in fay-base, and is preventing it from compiling
13:53:26 <bergmark> i can compile fay-base fine O-o
13:53:52 <johnw> really?  I'm getting: Not in scope: type constructor or class `Automatic'
13:54:00 <johnw> ah, you're the bergmark on the issue discussion!
13:54:35 <johnw> i was able to build last night, which is what perplexes me the most
13:55:17 <bergmark> are you just doing cabal install?
13:55:21 <Nereid> it's defined in fay
13:55:21 <johnw> yes
13:55:28 <bergmark> though it it a bit suspicious that it's not defined anywhere
13:56:28 <bergmark> oooh right, johnw it's defined in Language.Fay.FFI
13:56:57 <johnw> so i need to install fay before fay-base...
13:57:02 <johnw> i think that was my probelm
13:57:03 <bergmark> yes
13:57:10 <johnw> cabal-meta was installing an old version of fay
13:57:25 <johnw> thanks
13:58:41 <johnw> success
13:58:56 <bergmark> \o/
13:59:15 <johnw> should my fay modules still import Language.Fay.Prelude?
13:59:37 <bergmark> no just Prelude now
14:00:02 <johnw> k, trying...
14:04:36 <johnw> btw, after installing fay-base, many packages fail to install because Prelude is now an ambiguous module name
14:04:39 <monochrom> soon, I will have to make a web page on "undocumented cabal". http://thread.gmane.org/gmane.comp.lang.haskell.glasgow.user/23162/focus=23163
14:04:42 <johnw> for example, postgresql-libpq
14:04:58 <bergmark> ouch, hmm
14:06:15 <cmccann> monochrom: yes, but what well-known acronym will you steal for it?
14:06:19 <cmccann> that is the important question.
14:06:51 <monochrom> I will steal "cabal". it means secrets.
14:06:52 <elliott> "GHC"
14:06:53 <Taneb> Cabal Stuff that's Interesting
14:07:03 <elliott> Great Heists of Cabal
14:07:11 <monochrom> haha
14:07:33 <johnw> Great Hidden Cabal features
14:07:35 <Taneb> Cabal Stuff that's Interesting: Never Tellow
14:07:42 <Taneb> *Yello
14:07:43 <Taneb> w
14:07:47 <elliott> tellow
14:08:00 <Taneb> It's late, I can't type
14:08:12 <Taneb> I probably should be in a channel with 1000+ people when I'm like this
14:08:20 <bergmark> johnw: i'm not sure why that happens when -libpq only has base as a dependency, file a ticket to fay and let the cabal wizards sort it out :)
14:08:31 <cmccann> I vote for johnw's suggestion, with the page named "ghc-features".
14:10:22 <johnw> do we really have >1000 people here?
14:10:31 <jmcarthur> no
14:10:48 <Taneb> Including bots and duplicates, yes
14:10:59 <cmccann> what is the current user count? can't remember how to get the total
14:11:05 <Taneb> 1003
14:11:22 <Nereid> you get the total by counting.
14:11:29 <Nereid> some clients count for you I guess.
14:11:39 <cmccann> no, counting is too much work.
14:11:42 <johnw> wow, it only feels like maybe 40 people are listening
14:11:53 <snowylike> that's normal
14:11:53 <geekosaur> when there's 1000+ of them, you better hope the client is counting :)
14:12:05 <cmccann> I think probably more people are reading at any given point than you'd expect
14:12:13 <cmccann> but certainly most of the channel is just idling
14:12:49 <nus> "2013: The year when idling on #haskell became trendy"
14:12:51 <elliott> cmccann: try /names
14:13:01 <johnw> i wonder if there are people here just so their "whois" shows them in #haskell :)
14:13:17 <elliott> their /whois will only show them in Haskell if the person /whoising is also in #haskell normally
14:13:28 <jmcarthur> that is the case on freenode
14:13:35 <johnw> oh?  didn't realize that
14:13:44 <jmcarthur> by default, at least. it might be configurable per user
14:14:54 * donri lurk herp derp
14:15:05 <johnw> lol
14:15:38 <johnw> well, hello 997 other people
14:15:52 <johnw> i'll take your silence as tacit return of greeting
14:15:59 <sm> hello johnw!
14:16:38 <nus> > 1000 / 12
14:16:40 <lambdabot>   83.33333333333333
14:16:47 <nus> per time-zone
14:17:07 <johnw> how do you know how many time zones they are in?
14:17:12 <donri> because you only irc one hour a day?
14:18:03 * hackagebot stream-fusion 0.1.2.5 - Faster Haskell lists using stream fusion  http://hackage.haskell.org/package/stream-fusion-0.1.2.5 (DonaldStewart)
14:19:10 <donri> i thought the stdlib did stream fusion for list operations?
14:20:05 <jmcarthur> woah, a stream fusion package update
14:20:09 <jmcarthur> no
14:20:23 <jmcarthur> donri: we still haven't found a way to make it always an optimization
14:20:31 <donri> or maybe it just does fusion?
14:20:35 <ski> elliott : unless the person being `whois'ed has set user mode `-i' (as i've done)
14:20:41 <donri> what again is 'build' doing
14:20:45 <cmccann> jmcarthur: not just that, dons not being missing forever anymore
14:20:48 <jmcarthur> donri: nested loops are still too crazy for ghc, such as in concatMap
14:21:00 <jmcarthur> donri: with stream fusion, that is
14:21:05 <elliott> ski: yeah, I wasn't sure of the exact user mode
14:21:26 <donri> ski: isn't it a channel flag also?
14:21:30 <ski> jmcarthur : yes, configurable per user
14:21:30 <jmcarthur> donri: build is a part of the fusion that is in use currently
14:21:36 <ski> donri : hm, not sure
14:25:31 <ski> donri : hm, yes, `+s' on a channel seems to prevent that channel from showing up with `whois' (unless the querent is also in the channel)
14:25:47 <donri> so what is +p?
14:26:23 <donri> IIRC there's some silly distinction between "secret" and "private" channels
14:26:31 <cmccann> IRC is weird.
14:26:32 <ski> "p - Private - People who aren't joined to channel can't see it for example with /WHOISing people who are in channel.","s - Secret - Like private, but the channel isn't displayed in /LIST's output." apparently
14:26:37 <johnw> +p disable /knock
14:26:44 <johnw> oh.. hmm
14:26:46 <donri> ah
14:28:03 <johnw> freenode docs say "+p - When set, the KNOCK command cannot be used on the channel to request an invite, and users will not be shown the channel in WHOIS replies unless they are on it. Unlike on some ircds, +p and +s can be set together."
14:28:21 <johnw> ok, that's mostly what ski said
14:28:25 <zardoz8> x = map (^2) [1..10]  <- will map be executed every time I refer to x?
14:28:33 <ski> (<http://freenode.net/using_the_network.shtml> has some more info on FreeNode modes)
14:29:22 <johnw> zardoz8: in general, no
14:29:27 <cmccann> zardoz8: x is a list, there's nothing to execute there
14:29:37 <zardoz8> in general, meaning sometimes it could?
14:29:39 <cmccann> the list may or may not have been computed yet, but that's another matter
14:29:46 <johnw> meaning my knowledge of Haskell may have gaps :)
14:30:08 <johnw> also, it's not referral that causes any execution, but evaluation
14:30:22 <cmccann> inside the scope where x is bound, it should be computed at most once
14:30:24 <zardoz8> so execution might be delayed until i first refer to the list, and then it won't be repeated again
14:30:27 <johnw> when x is evaluated the first time, map will run, but thereafter it will not
14:30:56 <cmccann> furthermore, map won't run completely unless you force the entire list
14:30:57 <elliott> polymorphism messes this up though!
14:31:07 <elliott> so be careful if you define x at top level and turn off monomorphism restriction without knowing what you're doing
14:31:15 <ski> zardoz8 : depends on whether `x' is constrained polymorphic or not
14:31:54 <cmccann> pf, polymorphism is overrated. let's all go back to simply-typed lambda calculus.
14:32:49 <saeidw> wait, I don't understand how polymorphism messes this up
14:33:02 <johnw> neither do I
14:33:05 <cmccann> anyway, it's more that when you have something like "x :: (Num a) => [a]" x is not actually a single value, it's an implicit "function" from a specific type (with Num instance) to a value
14:34:16 <ski> if you use `x :: [Integer]' one time, and `x :: [Double]' another time, then `x' will (probably) be recomputed
14:34:31 <johnw> ah, good explanation ski
14:34:35 <ski> note that this only happens with *constrained* polymorphism
14:34:39 <saeidw> yeah, that makes sense
14:34:48 <cmccann> and even if you use "x :: [Integer]" multiple times it may be recomputed
14:35:08 <ski> (ordinary polymorphism, with no (e.g. class) constraints, don't have this problem in GHC or Hugs)
14:35:14 <ski> yes
14:35:40 <ski> btw, note that this is the cause for introducing the DMR in the first place
14:36:34 <johnw> what is the D in DMR?
14:37:00 <donri> dreaded
14:37:00 <mm21> @type left
14:37:03 <mm21> @type left (1+)
14:37:04 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
14:37:08 <lambdabot> Num c => Either c d -> Either c d
14:37:14 <mm21> why's the second one not an arrow?
14:37:56 <donri> because you passed it a function as the arrow
14:38:03 * hackagebot haskades 0.1 - Utility to generate bindings for BlackBerry Cascades  http://hackage.haskell.org/package/haskades-0.1 (StephenWeber)
14:38:12 <donri> the "a" was selected as "->"
14:38:20 <cmccann> @type left (arr (1 +))
14:38:22 <lambdabot> (Num c, ArrowChoice a) => a (Either c d) (Either c d)
14:38:40 <mm21> ahh, that makes sense thank you
14:40:08 * ski would prefer it if the type of `left' was given as `ArrowChoice (~>) => (a0 ~> a1) -> (Either a0 b ~> Either a1 b)', or, lacking infix type variables, as `ArrowChoice ar => ar a0 a1 -> ar (Either a0 b) (Either a1 b)'
14:40:23 <donri> ski: can't have that in ghc 7.6
14:40:25 <ski> (and similarly for other arrowy and categorical stuff)
14:40:30 <ski> donri : yes i know :(
14:40:48 <donri> which is broken IMHO
14:41:20 <donri> makes types inconsistent with term constructors
14:51:52 <Lethalman> is there anywhere an example of monad usage (like reader or writer) but with arrows?
14:53:03 <Lethalman> ehm
14:53:31 <Lethalman> some kind of monad usage translated to use arrows
14:53:47 <johnw> Lethalman: monads can do things arrows can't
14:54:58 <mm21> why? every monad is an arrow, right?
14:55:00 <parcs> Lethalman: check out http://hackage.haskell.org/package/arrows
14:55:09 <mm21> oh no
14:55:14 <mm21> sorry other way round
14:56:15 <Lethalman> ok thanks
14:56:24 <mm21> i'm confused right now :)
14:56:35 <Heffalump> mm21: yes, every monad is an arrow
14:57:02 <johnw> mm21: but the Arrow interface does not expose the functionality of Monad
14:57:13 <mm21> Heffalump: yes so why can monads things, arrows cannot?
14:57:18 <johnw> just as every monad is a functor, but Functor won't let you do everything a monad can
14:57:34 <ski> @type app
14:57:34 <Heffalump> if you're writing code that relies on something being a monad, then it won't necessarily work with an arrow
14:57:35 <lambdabot> ArrowApply a => a (a b c, b) c
14:57:58 <johnw> http://www.ittc-ku.net/Projects/SLDG/filing_cabinet/Hughes_Generalizing_Monads_to_Arrows.pdf
14:58:02 * Lethalman confused as well
14:58:11 * ski would rather say that every monad can be represented as an arrow, rather than saying that it is an arrow
15:00:46 <mm21> johnw: u said monads can do things arrows cannot...but i can get an arrow from a monad so what can a monad do what an arrow can't?
15:00:59 <mm21> sorry if i'm too confused
15:00:59 <elliott> because you can't get a monad from an arrow
15:01:10 <johnw> if you only have the Arrow interface, you cannot apply monadic operations to that value
15:01:16 <johnw> even if that value is actually a monad
15:01:53 <johnw> Arrow is more general, which means it lessens functionality for the sake of generality
15:02:51 <donri> ArrowApply gives you a monad
15:03:32 <johnw> donri: good to know!
15:03:40 <donri> but the whole point to arrow is to not do that :)
15:04:13 <Lethalman> ok that's clear now :) thanks
15:04:43 <donri> Lethalman: you can wrap a monad as an arrow with Kleisli
15:04:58 <donri> an example user of that is scoutess: http://hub.darcs.net/alp/scoutess
15:05:21 <cmccann> monads and arrows are really not comparable things
15:05:38 <cmccann> anything about getting one from the other is implying something far more limited than "every monad is a functor" and such.
15:05:50 <donri> http://hub.darcs.net/alp/scoutess/browse/Scoutess/Types.hs#35
15:06:20 <cmccann> if memory serves me ArrowApply amounts to turning any arrow into something like ReaderT
15:06:42 <cmccann> and kleisli arrows aren't much more than the regular (->) arrow with a monad bolted onto the tip
15:06:53 <donri> yea
15:07:22 <johnw> my understanding is that Kleisli arrows given you monadic binding via composition
15:07:40 <cmccann> so you can turn many arrows into variations on a specific monad, and you can use any monad in a specific kind of arrow
15:07:50 <donri> johnw: you're thinking of >=> i think
15:08:02 <cmccann> a kleisli arrow is just a function (a -> m b)
15:08:07 <johnw> ah
15:08:14 <cmccann> @src (<=<)
15:08:14 <lambdabot> Source not found. Just try something else.
15:08:17 <johnw> i thought KleisliArrow a b = a -> m b
15:08:20 <cmccann> argh
15:08:20 <donri> which is also kleisli, but not Kleisli :) (IIUC)
15:08:21 <johnw> and you can >>> KleisliArrows
15:08:36 <cmccann> the Kleisli newtype wrapper just lets you have an Arrow instance
15:08:43 <donri> @src (>=>)
15:08:43 <lambdabot> Source not found. My pet ferret can type better than you!
15:08:43 <johnw> the binding happens via runKleisli, doesn't it?
15:08:45 <cmccann> since otherwise it'd be ambiguous with the instance for (->)
15:09:22 <donri> :t (>=>)
15:09:23 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:10:37 <donri> runKleisli (Kleisli f >>> Kleisli g) = f >=> g -- i guess?
15:11:41 <johnw> yes, that's what I meant
15:11:45 <johnw> i've actually used that once
15:12:04 <cmccann> yeah, for Kleisli (.) = (<=<) and id = return
15:12:10 <cmccann> modulo newtype wrapping and unwrapping
15:12:14 <Lethalman> ah
15:12:18 <Lethalman> that's even more clear now
15:12:25 <donri> \o/
15:12:55 <Lethalman> :t (>>>)
15:12:57 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
15:13:14 <Lethalman> ok that's the basic composition of arrows I believe
15:14:28 <Lethalman> :t (<=<)
15:14:30 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
15:14:33 <Lethalman> :t (.)
15:14:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:14:37 <cmccann> :t (Prelude..)
15:14:39 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:14:45 <cmccann> lambdabot is silly.
15:14:51 <donri> in lambdabot (.) is fmap :p
15:14:52 <Lethalman> they look very similar
15:15:06 <ski> cmccann : `ReaderT' ?
15:15:09 <Lethalman> there's no <<< ? :)
15:15:33 <cmccann> ski: well just Reader I guess
15:15:35 <donri> :t (<<<)
15:15:36 <lambdabot> Control.Category.Category cat => cat b c -> cat a b -> cat a c
15:15:44 <ski> i don't see that
15:15:52 <cmccann> though speaking of which, fun fact: ReaderT and Kleisli are identical except for the order of type parameters :]
15:15:56 <donri> :t (Control.Category..)
15:15:57 <lambdabot> Control.Category.Category cat => cat b c -> cat a b -> cat a c
15:16:07 <Lethalman> ah
15:16:11 <hpc> cmccann: ahaha
15:16:19 <Lethalman> wrong imported module in ghci :)
15:17:45 <donri> :t (>>^)
15:17:47 <lambdabot> Arrow a => a b c -> (c -> d) -> a b d
15:17:49 <cmccann> ski: it's been a while since I bothered looking at it I guess
15:18:20 <simpson> I still don't grok arrows in the general sense. Are there any common non-Kleisli arrows?
15:18:30 <Lethalman> donri, that lifts a function in the arrow flow?
15:19:19 <donri> Lethalman: it's just f >>> arr g, i think
15:19:21 <croikle> composes a pure function on to the end
15:19:30 <Lethalman> right
15:19:38 <Lethalman> @src (>>^)
15:19:38 <lambdabot> a >>^ f = a >>> arr f
15:19:40 <Lethalman> :P
15:19:57 <cmccann> simpson: stream transducers
15:19:58 <Lethalman> is it only me that feels lost with all these symbols?
15:20:06 <cmccann> Lethalman: you get used to it
15:20:29 <donri> @quote mappend
15:20:30 <lambdabot> elliott says: |\/|/-\|-|-|=|\||} is my preferred mappend operator
15:20:37 <Lethalman> cmccann, but wasn't it clearer to have, e.g. a `compose` b rather than >>>
15:20:39 <Lethalman> or something else
15:20:42 <ion> Alas, that‚Äôs an invalid operator.
15:20:47 <elliott> (>>>) is long enough as it is
15:20:58 <Lethalman> what's the point of >>^ instead of some other name
15:21:00 <elliott> ion: s/}/>/
15:21:04 <ion> elliott: Verily.
15:21:04 <cmccann> Lethalman: it's clearer at first, but once you learn what (>>>) means writing "compose" is a lot harder to read
15:21:12 <cmccann> more visual noise and such
15:21:19 <donri> Lethalman: there's four of those, so you need some symmetry
15:21:31 <donri> >>^ ^>> <<^ ^<<
15:21:39 <cmccann> that said, I don't really see the point of (>>^) and such
15:21:45 <Lethalman> but then there are $>, <$, $=, .......
15:21:51 <Lethalman> infinite of them for each library
15:22:03 <donri> cmccann: less parenthesis ;)
15:22:15 <donri> we so hate the parenthesis in haskelland
15:22:20 <cmccann> pf
15:23:18 <cmccann> Lethalman: learning a whole pile of cryptic names for each library isn't really much easier than learning a bunch of operators
15:23:37 <cmccann> in fact, it's exactly as much easier as "no fixities to remember".
15:24:29 * ski doesn't hate brackets
15:24:33 <elliott> cmccann: Except you can give a fixity to `compose`.
15:24:39 * ocharles is starting to introduce more and more ((brackets)) in his code
15:25:07 <cmccann> elliott, but in practice you rarely see a whole bunch of backticky functions with no parens that you can't parse without knowing fixities.
15:25:20 <hpc> cmccann: we should rectify that omission
15:27:24 <ski> ocharles : in case one could write `<expression> <keyword> ...' (with `\' included amongst the keywords), i think i would rarely use `$' at all
15:27:50 <donri> Lethalman: i've seen "o" used for compose so you write f `o` g ... ;)
15:28:04 <Lethalman> :P
15:28:24 <cmccann> donri: that's just because people don't have the guts to use (‚àò) like they wish they could
15:29:02 <donri> i have vim display . as that character
15:29:07 <ski> donri : perhaps an MLism ..
15:29:29 <ski> (using `o', i.e.)
15:30:00 <Lethalman> for example &&& is understandable, can be remembered, but *** not much :S
15:30:37 * ski can remember both, fwiw
15:30:58 <donri> :t both
15:30:59 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
15:31:02 * donri ducks
15:31:04 <cmccann> haha
15:31:28 <croikle> :t (<#%=)
15:31:29 <lambdabot> MonadState s m => Loupe s s a b -> (a -> b) -> m b
15:31:39 <cmccann> now that's what I call an operator!
15:31:41 <Lethalman> :S
15:31:52 <croikle> you've got nothing to complain about with arrow operators :)
15:31:57 <donri> that's not even the worst one in lens i don't think
15:32:02 * cmccann can't recall what the # in there means
15:32:11 <johnw> i know what the < and %= parts mean; what does the # mean?
15:32:11 <donri> is that indexed?
15:32:14 <Lethalman> see :P
15:32:38 <croikle> I just picked an arbitrary one from the index
15:32:40 <johnw> lens operators are just a condensed mini-language
15:33:11 <parcs> :k Loupe
15:33:12 <lambdabot> Top level:
15:33:12 <lambdabot>     Type synonym `Loupe' should have 4 arguments, but has been given none
15:33:12 <lambdabot>     In a type in a GHCi command: Loupe
15:33:20 <johnw> <#%= means: returning the output from the operation, perform an indexed operation on the current state given by the lens on the left-hand side, and the function on the right-hand side
15:34:32 <donri> :t (^@?!)
15:34:33 <lambdabot>     Not in scope: `^@?!'
15:34:33 <lambdabot>     Perhaps you meant `^?!' (imported from Control.Lens)
15:34:45 <donri> ok it's new in git
15:34:55 <croikle> http://hackage.haskell.org/packages/archive/lens/3.7.3/doc/html/doc-index-60.html
15:34:58 <Lethalman> \o/
15:35:02 <donri> http://ekmett.github.com/lens/Control-Lens-Operators.html
15:35:49 <cmccann> personally I find all the cute prepositions harder to remember than the operators
15:36:01 <cmccann> the latter are, like johnw says, a mini-language of sorts
15:36:09 * Lethalman so scared
15:36:30 <elliott> well, the prepositions are too
15:36:38 <elliott> pre-, re-, -s, etc.
15:36:52 <elliott> cmccann: the # means loupe
15:36:55 <cmccann> true, that helps
15:37:01 <cmccann> and yes, I looked it up
15:37:04 <elliott> as in "you probably don't care about this"
15:37:11 <cmccann> not that I remember what a loupe is but hey
15:37:17 <johnw> lol
15:37:28 <johnw> i think loupes postdate the last time I read the lens docs
15:37:44 <zardoz8> am I using withFile wrong? it returns empty string even though file isn't empty. withFile "test.txt" ReadMode hGetContents
15:38:12 <cmccann> concepts and identifiers in lens seem to have a half life of a week or so before they get changed or replaced
15:38:15 <donri> zardoz8: yay lazy IO!
15:38:25 <mauke> zardoz8: yes
15:38:29 <mauke> zardoz8: you should use readFile
15:38:33 <zardoz8> hmm
15:38:38 <donri> zardoz8: it is closed before you evaluate the hGetContents
15:38:39 <elliott> cmccann: in fact loupe is gone in HEAD :P
15:38:58 <cmccann> elliott: see what I mean?
15:39:04 <zardoz8> I am not getting it
15:39:20 <elliott> cmccann: but you can use ALens instead!!
15:39:22 <elliott> the combinators are still there
15:39:23 <zardoz8> repl is asking for the result, since it wants to print it
15:39:26 <mauke> zardoz8: readFile. use it.
15:39:33 <cmccann> elliott: for the next few weeks at least
15:39:41 <johnw> huh, we've said lens like 10 times and neither edwardk nor shachaf has shown up
15:39:45 <johnw> guess the magic is wearing off
15:39:51 <cmccann> edwardk is afk
15:40:05 <johnw> when has that stopped him from responding?
15:40:06 <ski> zardoz8 : you should not close a handle sent to `hGetContents'
15:40:12 <zardoz8> I don't mind using it, but I am wondering what's the point in withFile then
15:40:17 <donri> zardoz8: hGetContents returns immediately, a lazy list. withFile closes the handle after the io action returns.
15:40:24 <mauke> zardoz8: not using hGetContents with it
15:40:27 <monochrom> withFile closes the file immediately
15:40:48 <cmccann> johnw: edwardk is afk making sure his wife still remembers who he is apparently
15:40:53 <zardoz8> well this is very weird
15:40:54 <mauke> if you use hGetContents, you shouldn't touch the handle afterwards in any way
15:41:03 <mauke> withFile does touch the handle (it closes it)
15:41:36 <monochrom> withFile together with hPutwhatever, hGetLine etc is fine
15:41:38 <hpc> or to be a bit more pedantic, hGetContents does touch the handle, but it touches it "eventually"
15:41:56 <mauke> hpc: ?
15:41:58 <ski> `hGetContents' (lazily) closes the handle (when it reaches EOF, or when the string is GCed, i think)
15:42:05 <hpc> ^
15:42:24 <shachaf> hi johnw
15:42:28 <hpc> and anything you do to the handle from then on interferes with hGetContents' assumptions of what the handle is doing
15:42:29 <mauke> hpc: yes, that's why you shouldn't touch the handle afterwards: hGetContents effectively owns it
15:42:33 <monochrom> but withFile closes earlier than hGetContents does
15:42:44 <johnw> shachaf: hi shachaf!
15:43:04 * hackagebot ldif 0.0.12 - The LDAP Data Interchange Format (LDIF) tools  http://hackage.haskell.org/package/ldif-0.0.12 (RadoslavDorcik)
15:44:17 <zardoz8> so I can't use withFile with a function that calls hGetContents and parses the result either? should I use openFile then?
15:44:29 <mauke> no, readFile
15:44:38 <zardoz8> readFile is of no use
15:44:42 <mauke> why not?
15:44:54 <zardoz8> because I have a function that accepts a handle
15:45:02 <mauke> ah, that sucks
15:45:05 <mauke> then yes, openFile
15:45:18 <mauke> and you may have to block exceptions
15:45:46 <elliott> or withFile and just read it strictly
15:46:11 <zardoz8> how would I read it strictly?
15:46:14 <zardoz8> seq?
15:46:23 <mauke> elliott: no, that's technically still wrong
15:46:30 <mauke> you're closing the handle twice
15:46:42 <elliott> oh, I meant pass the handle from inside the withFile
15:47:01 <elliott> zardoz8: "s <- hGetContents h; evaluate $ length s" is the quick and dirty way
15:47:14 <hpc> zardoz8: there's absolutely no chance of removing the hGetContents call?
15:48:03 <zardoz8> I can remove it, but I have to use something else then. I have a parsing function that accepts Handle, since I use it to parse from a file or from stdin
15:48:15 <mrout> I'd like to write a parser and compiler for a language I'm working on. I've heard haskell is amazing for such things. Why is that?
15:48:17 <cmccann> stuff like this is why I don't like lazy IO being used in any of the "default" standard library functions
15:48:21 <mauke> zardoz8: why not accept a String?
15:48:53 <zardoz8> I guess I can accept a string too. would that be prefered way of doing it
15:48:54 <donri> zardoz8: just use hGetContents without withFile
15:49:02 <donri> zardoz8: it closes it for you at the end
15:49:14 <monochrom> I don't understand this design which wants both the Handle and hGetContents
15:49:28 <cmccann> mrout: well, parsers and compilers have always been a strong suit of functional languages in general
15:49:28 <mrout> I'd like to write a parser and compiler for a language I'm working on. I've heard haskell is amazing for such things. Why is that?
15:49:40 <mrout> cmccann: ahh, why's that in particular though?
15:49:45 <donri> if you're worried about leaking descriptors and such, use strict text or bytestring IO or some iteratee library
15:50:09 <zardoz8> monochrom I had readFoo :: Handle -> IO Stuff  that called hGetContents
15:50:30 <cmccann> mrout: various reasons, but an emphasis on recursion and recursively structured data types is part of it
15:50:53 <monochrom> I don't like that
15:50:57 <mrout> That's interesting.
15:51:13 <cmccann> most of that's not specific to haskell, though.
15:51:29 <zardoz8> so readFoo :: String -> Stuff instead?
15:52:11 <monochrom> perhaps. I of course know nothing about the complete task and the complete code
15:52:15 <zardoz8> I can see how that's better, it's pure for one.
15:52:20 <cmccann> mrout: also, parser combinators (which we have multiple libraries for in Haskell) tend to be a more pleasant way to write parsers than the usual alternatives
15:53:57 <mauke> compilers really like to transform trees
15:54:03 <mrout> the usual alternatives seem to be fairly horrific. not a big lex/yacc fan tbh
15:54:25 <cmccann> mrout: beyond that, if you're a fan of static type checking Haskell is better for that than any other language with an established user base
15:54:26 <ski> @where bnfc
15:54:26 <lambdabot> BNF Converter, <http://www.cse.chalmers.se/research/group/Language-technology/BNFC/>
15:54:34 <ski> mrout : that ^ might also be intersting
15:55:21 <cmccann> mrout: parser combinators let you write simple code that follows the same structure as the grammar it parsers, directly in Haskell instead of using an external tool
15:55:31 <ski> (it can be made to output a parser in Haskell, and skeletons for traversing ASTs)
15:55:45 <mrout> cmccann: So Haskell is a strong statically typed language.
15:55:46 <mrout> nice
15:55:58 <elliott> not in lens it isn't
15:56:18 <simpson> Well, mostly.
15:57:12 <cmccann> Haskell is still more reliably statically typed than any other language that's used much in practice
15:57:18 <cmccann> despite elliott's best efforts
15:57:49 <elliott> cmccann: using C is so boring. there's no challenge :(
15:58:05 <elliott> not as bad as Forth though. you can't even *do* anything there
15:58:35 <cmccann> actually C is very type safe once you realize it only has one type ("a bunch of bytes") and some newtypes around that
15:58:45 <mrout> can't do anything with Forth?
15:58:50 <mrout> HAHAHAHAHAHAHAHAHAHAHAHAHAHA
15:58:53 <johnw> bergmark: ping
15:59:09 <mauke> cmccann: that's demonstrably wrong
15:59:21 <cmccann> probably
15:59:30 <cmccann> but I'm too lazy to remember why
15:59:34 <cmccann> haven't used C in years
15:59:34 <mauke> functions aren't made of bytes, and I'm pretty sure register variables aren't either
16:00:00 <mauke> bitfields are murky
16:00:14 <cmccann> ah, I was probably conflating functions with pointers to them, but that's no good
16:00:20 <cmccann> and register variables is a very good point
16:00:23 <mrout> C is not type safe.
16:00:29 <mrout> That isn't in and of itself a bad thing
16:00:40 <mrout> It doesn't make a language inherently bad to be weak typed
16:00:51 <johnw> mauke: and what about volatile...
16:00:52 <mauke> mrout: "weak" and "strong" are meaningless, btw
16:01:00 <mrout> No they aren't.
16:01:02 <mauke> johnw: that doesn't affect storage
16:01:04 <mrout> They're very meaningful
16:01:10 <mauke> mrout: how do you define them?
16:01:13 <cmccann> mrout: and everyone has their own meaning for them
16:01:56 <cmccann> mrout: I'm sure you have a good and useful meaning in mind, but lots of people will have equally good and useful conflicting meanings in their mind
16:01:59 <mrout> a weak typed language is one that supports a lot of implicit type conversion.
16:02:05 <cmccann> there is no standard agreed-upon definition
16:02:11 <cmccann> though that's one of the more popular ones, yes
16:02:40 <simpson> A weakly-typed language is one that doesn't even lift types.
16:02:52 <johnw> what does "is not a derivable class" mean in GHC?
16:02:57 <johnw> what have I failed to export?
16:02:58 * cmccann prefers to define a weakly typed language as one where circumventing whatever type restrictions exist is accepted as good programming practice.
16:03:25 <mrout> cmccann: what is accepted as good programming practice has nothing to do with a language. it's standard does.
16:03:25 <johnw> cmccann: you mean, where void* is the recommended way to implement generic containers?
16:03:27 <mrout> *its
16:03:42 <mrout> johnw: s/recommended/only feasible/
16:03:43 <mauke> mrout: what about standardless languages?
16:03:43 <cmccann> mrout: yes. that's one of the intended points of my definition.
16:03:58 <johnw> mrout: right
16:04:13 <mrout> every language has some sort of standard. Python's standard is its reference implementation
16:04:21 <mauke> mrout: [citation needed]
16:04:25 <Rembane> C!
16:04:32 <mauke> Rembane: you're fired
16:04:33 <cmccann> johnw: that depends on whether using generic containers is accepted by the community using that language!
16:05:08 <Rembane> mauke: :D:D:D
16:05:12 <Rembane> LISP! :D
16:05:43 <mauke> Rembane: you're double fired
16:06:12 <Rembane> mauke: Oh yeah! :D This is like trying to play softball... :/
16:06:23 <mrout> nothing wrong with generic containers. I think the high quality and reusability of the C++ stdlib has shown how much better generic programming is than OOP.
16:06:26 <simpson> mrout: There's a standard Python semantic guide in CPython's documentation, and a couple people are working on formal semantics in K for Python.
16:06:29 <cmccann> mrout: anyway, for what it's worth Haskell is extremely strongly typed by your definition, and by most common definitions
16:07:02 <cmccann> mrout: well C# and Java have generics these days y'know
16:07:11 <mrout> cmccann: they aren't templates.
16:07:11 <cmccann> (they got them from a Haskell programmer fyi)
16:07:23 <mrout> templates are something else entirel
16:07:25 <mrout> *entirely
16:07:27 <cmccann> that is true, they are
16:07:28 <mauke> so much the better
16:07:47 <hrumph> in yesod, what's the best way to deal with errors inside a runDB?
16:08:04 <hrumph> would it be best to put the runDB inside an errorT, or is there a more conventional way?
16:08:12 <JoeyA> Use the types, Luke (/me looks it up)
16:08:21 <cmccann> I thought yesod had template haskell magic to make all errors impossible :P
16:08:23 <mrout> I've never seen a language feature that comes anywhere near templates in usefulness and power in any language I've come across
16:08:32 <JoeyA> Where is runDB defined?
16:08:33 <mrout> I'm hoping Haskell will change that
16:08:54 <cmccann> mrout: full-blown lisp macros are probably more powerful.
16:08:55 <mauke> mrout: do you know lisp?
16:09:04 <cmccann> but you'd need to find a serious lisp hacker to explain why in detail
16:09:04 <johnw> JoeyA: Yesod.Persist
16:09:08 <mauke> cmccann: s/probably/easily/ :-)
16:09:11 <hrumph> ok  a hypothetical scenario would be a auser putting in a look up value that doesn't correspond to anything in the db
16:09:18 <mapf> Hi everyone. I have a lib question. I need to send buffer (or just C array) from haskell world to C world. But buffers are vectors too. So I want to use some convenient API like Data.Vector. Is Data.Vector.Storable recommended to do this?
16:09:31 <JoeyA> http://hackage.haskell.org/packages/archive/yesod-persistent/latest/doc/html/Yesod-Persist.html#v:runDB
16:09:36 <hrumph> joeyA not sure but its the way that DB operations are generally done in handler functions in yesod
16:09:36 <mrout> No, I don't. I'm also not a huge fan of lisp, and I doubt lisp could do what templates can do in as consise a manner.
16:09:38 <cmccann> mauke: I was giving C++ templates the benefit of the doubt :P
16:09:50 <johnw> note that it returns a GHandler, which gives you some flexibility
16:09:56 <mauke> blub coder detected
16:10:11 <mrout> with a programmer with the same experience.
16:10:18 <newsham> c++ templates are turing complete.. isnt that enough benefit for your doubt?
16:10:26 <cmccann> mrout: I would be shocked if C++ templates could do as much as lisp macros anywhere near as concisely
16:10:37 <mauke> cmccann: templates are basically a slightly less stupid preprocessor
16:10:41 <mrout> cmccann: you'd need to be a lot better with lisp than I am with C++
16:10:56 <mrout> mauke: I recommend you find out a bit more than you already do about templates bro
16:11:10 <mauke> I'm not your "bro", buddy
16:11:33 <elliott> typeclasses compete with templates for usefulness and power
16:11:46 <elliott> (compete with, not are equivalent to)
16:11:54 <cmccann> mauke: if by slightly less stupid you mean just less-stupid enough to be turing complete yeah
16:11:55 <mrout> I'm not your "buddy", bro
16:11:55 <mrout> :P
16:11:55 <cmccann> turing tarpit city
16:12:01 <JoeyA> hrumph: I'm not sure, but I think you'll want to use Control.Exception.Lifted: http://hackage.haskell.org/packages/archive/lifted-base/latest/doc/html/Control-Exception-Lifted.html
16:12:07 <zardoz8> mrout meh, lisp macros are a lot more powerful. metaprogramming via C++ templates is a hack that was discovered by accident
16:12:17 <elliott> cmccann: at least you can use ints
16:12:23 <cmccann> and I expect Template Haskell can do anything C++ templates can, more easily and with less code
16:12:37 <mauke> cmccann: that would surprise me, actually
16:12:40 <mrout> zardoz8: accident or not, they're pretty amazing. lisp macros allow you to basically rewrite the language if I remember correctly from reading about them.
16:12:56 <elliott> ugh, I'd prefer C++ templates to TH
16:13:11 <cmccann> I'd prefer neither
16:13:13 <mapf> is Data.Vector.unsafeToForeignPtr forces all elements of vector?
16:13:18 <cmccann> so my opinion is not necessarily reliable here
16:13:25 <mrout> Haskell seems to do everything that templates do, by default. All that recursive typing stuff.
16:13:30 <elliott> cmccann: ditto
16:13:32 <cmccann> TH is pretty painless as long as you stay within the bounds of what can be quoted easily though
16:13:34 <zardoz8> mrout yes. extend lisp with new syntax is as easy as manipulating a list
16:13:39 <elliott> mrout: all that recursive typing stuff?
16:13:41 <newsham> there are things that you cant do in haskel that you can do in TH
16:13:51 <zardoz8> extending*
16:14:10 <cmccann> but once you find yourself building ASTs by hand TH is infinite suffering
16:14:30 <Hafydd> Countably infinite suffering.
16:14:32 <mrout> elliott: well that's basically a major part of templates in C++ TMP. template <int n> etc. etc. One example anyway
16:14:33 <hrumph> joeyA ok i'll look into it. my next question is that it seems that using SQL table joins is not part of the Persistent idiom, so what do i do in stead? supposing i want the equivalent of the data from two joined tables? Do i get the data from both tables and then join them myself with haskell code or do I do multiple selects getting the data one row at a time? please set me straight on this
16:15:05 <JoeyA> mapf: Data.Vector.Storable's Vector is different from Data.Vector's Vector
16:15:08 <JoeyA> http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/src/Data-Vector-Storable.html#Vector
16:15:35 <JoeyA> It's implemented with a ForeignPtr (sort of like ByteString does).
16:15:55 <mikeplus64> cmccann: at those points i just wish TH was a dumb string preprocessor (but still with the Q monad) :(
16:16:00 <mapf> JoeyA: yep, I saw. But I doubt a bit.
16:16:17 <mrout> lol C macros. "#define square(x)      x*x" <-- nope. "#define square(x) ({typedef xtype =3D x; xtype xval =3D x; xval*xval; }) wooo!
16:16:19 <roadfish> I want to build up SVG strings and then render them to images, say png or jpg. Also, I want to be able to access items at the pixel level. Any recommendations for Haskell packages. hoogle svg has a bunch of matches.
16:16:24 <newsham> mike: you can always write a program to generate haskell code
16:16:25 <cmccann> mikeplus64: I wonder what ever happened to the ideas about splitting TH into two separate metaprogramming thingies
16:16:28 <JoeyA> hrumph: I don't know, sorry.
16:16:40 <mauke> mrout: =3D?
16:17:04 <shachaf> > chr 0x3D
16:17:05 <lambdabot>   '='
16:17:26 <newsham> mrout: just dont pass in side effects
16:17:33 <mauke> mrout: are you just making up syntax?
16:17:38 <mrout> mauke: not at all
16:17:47 <mrout> using compiler extension to do that, because you can't any other way
16:17:59 <mauke> mrout: what compiles supports 'typedef xtype = x'?
16:18:08 <newsham> i think mrout was saying that you have to do extra work to make sure side effects dont ruin your cpp macros
16:18:21 <mrout> that's my point.
16:18:30 <mrout> whichever one this guy uses
16:18:31 <mrout> #define square(x) ({typedef xtype =3D x; xtype xval =3D x; xval*xva=
16:18:31 <mrout> l; })
16:18:35 <mrout> fuck http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html
16:19:06 <cmccann> mrout: anyway, arguments about C and C++ aside, yes it sounds to me like Haskell would probably be good for what you want to do and you'd probably find it interesting
16:19:10 <newsham> mrout: dont use side effects with call-by-name semantics
16:19:11 <newsham> duh
16:19:12 <newsham> ;-)
16:19:47 <cmccann> mrout: but it's probably very different from any languages you already know so expect a significant learning curve
16:19:56 <mauke> mrout: so you're copying pseudocode from a mailing list archive with broken formatting
16:19:57 <mrout> cmccann; thanks. I agree that Haskell looks great for what i want to do. I also think it's a great learnign experience.
16:20:03 <mikeplus64> cmccann: yeah, it doesn't seem to be very big a deal since the only time TH actually gets type-checked meaningfully is if you don't write the AST yourself (which is sometimes impossible)
16:20:09 <JoeyA> mapf: Regular Data.Vector and Data.Array use the Array# primitive, which lets them store boxed valued (from what I can tell)
16:21:06 <cmccann> mrout: and most of the difficulty will be in letting go of preconceived ideas about how programming languages work, so in a way it's a good learning experience just for revealing assumptions you didn't even realize were there
16:21:35 <mrout> the best question about lisp is probably "Why the fuck is the function for getting the first thing in a list 'car'"?
16:21:39 <mrout> cmccann: mhm
16:21:53 <cmccann> mrout: also #haskell and the haskell community tends to be pretty friendly and helpful most of the time, except when people say silly things about C or C++ in front of mauke
16:22:08 <newsham> If you're frightened of dying, and you're holding on, you'll see devils tearing your life away. If you've made your peace, then the devils are really angels, freeing you from the Earth.
16:22:08 <mauke> or about Perl or Lisp
16:22:13 <mrout> Can't be worse than ##c.
16:22:18 <johnw> mrout: short for "Contents of the Address part of Register number"
16:22:25 * mauke is now known as Zhivago
16:22:26 <johnw> cdr = Decrement part
16:22:33 <simpson> I get a little foamy when people insult Python, but whatever.
16:22:43 <mrout> Fuck. I dare you to go to ##c and ask about heap-allocated variables.
16:22:44 <simpson> I thought cdr was Data Register.
16:22:47 <cmccann> car and cdr are a hilarious example of obsolete implementation details persisting long after their relevance
16:22:48 <mrout> They'll foam at the mouth
16:22:58 <mrout> mauke: oh please no god don't be Zhivago
16:23:02 <shachaf> cmccann: Or when people are being very abrasive repeatedly.
16:23:16 <shachaf> Maybe that's not the right word.
16:24:19 <mauke> mrout: the best question about C++ is probably "Why the fuck is the bitwise left shift operator used for output?"
16:24:26 <cmccann> hahaha
16:24:41 <mrout> mauke: oh god I know right?
16:24:48 <mrout> mauke: that's perhaps the stupidest thing about C++
16:24:50 <newsham> def __lshift__(self, n) :
16:24:50 <JoeyA> Why doesn't Haskell use << for bitwise shift?
16:24:53 <cmccann> I don't think #haskell is in any position to be making fun of other language's use of operators though
16:24:54 <simpson> mauke: My favorite is "Why can you redefine operator*() ?"
16:25:17 <mauke> simpson: kids' stuff. operator,() is where it's at
16:25:30 <simpson> mauke: ...Is that legal? My god.
16:25:36 <JoeyA> (Might be possible with a newtype wrapper, but would probably break all the Monad laws)
16:25:41 <mrout> simpson: that's unary * right? Well obviously it's so you can implement smart pointers.
16:26:00 <mrout> so you don't have to type my_smart_pointer.dereference()
16:26:05 * shachaf likes overloading unary &
16:26:06 <simpson> mrout: Obviously. Totally and completely intuitive for all of those old C programmers making the switchover. >:3
16:26:11 <mauke> JoeyA: it doesn't use << because then it wouldn't be symmetric to >>
16:26:41 <newsham> why all the c++ hate?
16:26:43 <mrout> simpson: what's unintuitive about that?
16:26:44 <shachaf> Once you've overloaded unary &, how do you get the address of something?
16:26:47 <newsham> let the c++ers have their overloading fun
16:26:50 <shachaf> Maybe that's off-topic in here.
16:27:02 <johnw> #haskell-blah is a perfect place for our regular round of C++ bashing
16:27:04 <simpson> mrout: It doesn't actually behave like you'd like it to behave. :3
16:27:05 <mrout> Don't say Maybe, it gives me the shivers
16:27:15 <cmccann> yeah, let's argue about misuse of operators in Haskell instead
16:27:17 <newsham> maybe funke
16:27:21 <cmccann> shachaf knows all about that
16:27:22 <simpson> mrout: I just don't get why C++ people complain about garbage collection and bounded types, and then work so hard to avoid manual memory management and NULLs.
16:27:26 * mauke moves to #haskell-blah
16:27:32 * simpson shuts up
16:27:36 <JoeyA> http://ro-che.info/ccc/15.html
16:27:50 <newsham> err maeby funke
16:30:30 <cmccann> mrout: at any rate, if you decide you'd like to learn haskell, feel free to ask for advice and help in here.
16:30:56 <mrout> already learning myself a haskell
16:31:05 <cmccann> good choice!
16:31:19 <newsham> for great good?
16:31:29 <cmccann> that is the first piece of advice you would have received, I expect.
16:33:22 <E0000> f ' ' ["a", "b", "c"]
16:33:25 <E0000> "a b c"
16:33:26 <E0000> ?
16:33:47 <ion> !
16:33:50 <mauke> intersperse
16:34:10 <cmccann> not quite intersperse
16:34:12 <E0000> concat . interspere
16:34:16 <E0000> ok
16:34:27 <cmccann> > intercalate " " ["a", "b", "c"]
16:34:28 <johnw> and ' ' would have to be " "
16:34:28 <lambdabot>   "a b c"
16:34:46 <cmccann> > intersperse ' ' ['a', 'b', 'c']
16:34:47 <lambdabot>   "a b c"
16:35:45 <zardoz8> > unwords ["a", "b", "c"]
16:35:46 <lambdabot>   "a b c"
16:35:58 <E0000> unwords yeah
16:36:10 <mauke> > const unwords ' ' ["a", "b", "c"]
16:36:11 <lambdabot>   "a b c"
16:36:41 <croikle> > (intercalate . (:[])) ' ' ["a","b","c"]
16:36:42 <lambdabot>   "a b c"
16:36:56 <rhyceU> I was trying to get an account on Hackage to publish a small package I have written. I read that I should send an email to Ross Paterson -- does anyone know if this is correct?
16:38:01 <mauke> rhyceU: http://hackage.haskell.org/packages/accounts.html
16:38:42 <rhyceU> mauke: That's where I got the information, yes. I just haven't encountered too many websites that have manual registration ;)
16:39:03 <fmap> rhyceU: that's correct
16:39:23 <rhyceU> fmap: thanks, just wanted to be sure.
16:55:14 <timau> scanlSomething = scanl (\acc x ...)
16:55:34 <timau> foldlSomething = last . scanlSomething
16:55:57 <timau> when I call foldlSomething will all intermediate lists be created?
16:56:52 <timau> or only the last one due to laziness?
16:57:18 <mauke> :t scanl
16:57:19 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
16:57:29 <mauke> > scanl f z [a,b,c]
16:57:31 <lambdabot>   [z,f z a,f (f z a) b,f (f (f z a) b) c]
16:57:40 <mauke> timau: what difference does it make?
16:57:55 <mauke> the last expression refers to all previous elements
16:58:45 <timau> if all are created I will use foldl and repeat the labda function
16:59:02 <mauke> wat
16:59:25 <timau> did you see the two lines I typed
16:59:59 <mauke> no, 6
17:00:17 <hpaste> Tordek pasted ‚ÄúWC install woes‚Äù at http://hpaste.org/80677
17:00:21 <zhulikas> > take 5 . scanl (+) 1 $ [1..]
17:00:23 <lambdabot>   [1,2,4,7,11]
17:00:37 <zhulikas> ok, scanl is lazy
17:00:45 <zhulikas> but foldl isn't, afaik
17:00:55 <Tordek> I'm having that issue while trying to install wx; anyone would know why?
17:01:40 <zhulikas> timau, my best guess would be that all intermediate results would be calculated, there is no way to determine last element without previous
17:05:38 <timau> they have to be calculated, but do all intermediate results have to be kept in memory until the end?
17:06:04 <mauke> dude.
17:06:11 <mauke> I don't think you understand the question you're asking
17:06:20 <timau> or to rephrase my question, is last . scanl significantly last efficient than just foldl
17:06:25 <mauke> @src scanl
17:06:25 <lambdabot> scanl f q ls = q : case ls of
17:06:25 <lambdabot>     []   -> []
17:06:25 <lambdabot>     x:xs -> scanl f (f q x) xs
17:06:33 <timau> significantly less efficient*
17:06:42 <mauke> probably not, but try and see
17:06:48 <parcs> :t scanl'
17:06:49 <lambdabot>     Not in scope: scanl'
17:06:50 <lambdabot>     Perhaps you meant one of these:
17:06:50 <lambdabot>       `scanl' (imported from Data.List),
17:06:51 <mauke> and give your "lambda function" a name
17:07:14 <parcs> > scanl (flip (:)) [1..10]
17:07:16 <lambdabot>   No instance for (GHC.Show.Show ([b0] -> [[b0]]))
17:07:16 <lambdabot>    arising from a use of `...
17:07:20 <parcs> > scanl (flip (:)) [] [1..10]
17:07:22 <lambdabot>   [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1],[6,5,4,3,2,1],[7,6,5,4,3,2,1],[...
17:12:08 <mapf> f :: Storable a => Ptr a -> IO Int;  how to find sizeOf `a' without scoped type variables or peeking?
17:13:01 <parcs> mapf: f a = sizeof (((\_ -> undefined) :: Ptr a -> a) a)
17:13:06 * hackagebot backward-state 0.1.0.0 - A state monad that runs the state in reverse through the computation  http://hackage.haskell.org/package/backward-state-0.1.0.0 (LukePalmer)
17:13:08 * hackagebot backward-state 0.1.0.1 - A state monad that runs the state in reverse through the computation  http://hackage.haskell.org/package/backward-state-0.1.0.1 (LukePalmer)
17:14:24 <mapf> parcs: thx, I forgot that sizeOf should not use values.
17:17:23 <zardoz8> :t sizeOf
17:17:24 <lambdabot>     Not in scope: `sizeOf'
17:17:24 <lambdabot>     Perhaps you meant one of these:
17:17:24 <lambdabot>       `IM.size' (imported from Data.IntMap),
17:17:39 <johnw> it's in the FFI library
17:17:53 <johnw> Foreign.Storable
17:18:13 <Nereid> asPtrTypeOf :: a -> Ptr a -> a; asPtrTypeOf = const
17:18:21 <Nereid> f a = sizeOf (undefined `asPtrTypeOf` a)
17:18:37 <Nereid> I dunno about the name but whatever.
17:18:58 <mapf> Nereid: I use (tie :: p a -> a) usually :)
17:19:28 <fmap> why doesn't sizeOf use Proxy?
17:19:29 <Nereid> ok, so it can be generalized.
17:19:32 <Nereid> it should.
17:19:40 <Nereid> but proxy isn't in base
17:19:41 <mauke> f a = sizeOf (ptr a) where ptr :: a -> Ptr a; ptr = undefined
17:20:13 <Nereid> that should be Ptr a -> a, and that will error.
17:20:18 <Nereid> no wait.
17:20:19 <Nereid> never mind.
17:20:24 <mapf> mauke: and undefined
17:20:40 <mapf> tie _ = undefined; not tie = undefined
17:21:07 <mapf> or `const undefined'
17:21:38 <parcs> perhaps sizeOf :: Storable a => f a -> Int
17:22:43 <parcs> no, nevermind. that would be too permissive, leading to obscure runtime errors
17:22:54 <Nereid> it would?
17:23:08 <Nereid> I suppose Proxy a ~ forall f. f a
17:23:11 <mapf> anyway it's pretty strange that unsafeToForeignPtr return length of vector, but not size of buffer.
17:23:28 <Nereid> no wait
17:23:31 <Nereid> never mind.
17:23:46 <parcs> Nereid: you could pass in a list of Ptrs or something stupid like that
17:23:55 <Nereid> what's wrong with that?
17:24:03 <Nereid> it never looks at the list.
17:24:27 <parcs> but the programmer probably didn't mean to pass in a list of Ptrs
17:24:52 <Nereid> fine.
17:25:01 <Nereid> Proxy is the right way to go about this anyway.
17:25:21 <parcs> right, if it was in base
17:26:19 <Nereid> exactly.
17:29:15 <johnw> is there a way to get cabal to run an arbitrary build-time command with the Simple builder, or does that pretty much require Custom by definition?
17:29:29 <parcs> somebody should propose adding Proxy to base
17:29:43 * shapr proposes parcs do it as a proxy for shapr actually proposing it
17:30:03 <shachaf> parcs: You don't actually need it for a lot of things.
17:30:16 <shachaf> For example, you can say "foo :: proxy a -> ..." instead of "Proxy a -> ..."
17:30:39 <shachaf> So things that consume proxies don't actually to consume Proxy (it's arguably better for them not to).
17:31:00 <parcs> shachaf: that's too permissive. you don't want the compiler to accept you passing in a list of [a]'s
17:31:09 <parcs> er, a list of as
17:31:23 <shachaf> Maybe not.
17:31:55 <shachaf> On the other hand being polymorphic is pretty nice.
17:32:30 <simpson> Well, in this specific instance, can't a type's Storable instance say that different constructors of the type have different sizes?
17:32:41 <parcs> wasn't there talk about making Typeable kind-polymorphic and using Proxy for that?
17:32:46 <simpson> Actually, no, that would be nonsensical. Ignore me.
17:33:02 * simpson was thinking of Binary
17:33:13 <napping> it's reasonable, but not what Storable means
17:35:10 <mapf> Is where at least one reason to make (mapM :: (a -> m b) -> Vector a -> m (Vector b)) but not just instance of traversable? How it's annoying to import/hiding/quialified blahblah... aw
17:38:17 <parcs> shachaf: perhaps the Proxy constructor could be hidden and a smart constructor (is that what they're caled?) could be exported
17:38:22 <shachaf> mapf: I see an instance of Traversable.
17:40:26 <mapf> but why we should export mapM? hiding every time?
17:40:44 <parcs> backwards compatibility?
17:41:03 <mapf> parcs: oh, is vector so old?
17:41:17 <shachaf> mapf: mapM lets you work with a monad.
17:41:23 <shachaf> Not all instances of Monad are instances of Applicative.
17:41:36 <Nereid> but Data.Traversable has mapM
17:41:38 <parcs> mapf: it's from at least 2008, according to hackage
17:41:42 <shachaf> The Data.Vector API is generally meant to be used qualified.
17:41:48 <shachaf> Mostly it just mirrors Data.List.
17:41:50 <shachaf> Data.List has mapM
17:42:02 <Nereid> Control.Monad has mapM
17:42:05 <Nereid> it's everywhere =(
17:42:21 <shachaf> Nereid: Oh, I was wrong.
17:42:25 <shachaf> Data.List doesn't have mapM
17:42:30 <shachaf> You should just ignore everything I say.
17:42:32 <Nereid> ok
17:42:38 <Nereid> will do
17:42:59 <parcs> shachaf: why is it better for Proxy to net get consumed?
17:42:59 <shachaf> Nereid: p () -> Void; p (a,b) -> Either (p a) (p b)
17:44:33 <Nereid> I think this is going too far just to avoid Control.Category :(
17:44:46 <shachaf> Nereid: ?
17:44:49 <johnw> why would one want to avoid Control.Category?  is it slower?
17:44:56 <Nereid> no, but you have to import it
17:44:59 <shachaf> parcs: One reason is that you don't have to depend on Proxy! :-)
17:45:03 <Nereid> and hide Prelude.id and (.)
17:45:24 <shachaf> Control.Category's (.)/id are annoying.
17:45:29 <shachaf> There's no defaulting for them.
17:45:45 <johnw> what a default even look like?
17:52:16 <johnw> i mean, what would a default for Control.Category.(.) even look like?
17:52:32 <johnw> i guess you meant "no default is possible for them"
17:52:33 <shachaf> Defaulting as in default 5 to an Integer.
17:52:58 <johnw> well, if Control.Category provided an instance for (->), that would cover most of the problem, no?
17:53:06 <Nereid> it already does.
17:53:10 <Nereid> but it's not a default.
17:53:12 <shachaf> Not really.
17:53:19 <shachaf> Try it out:
17:53:24 <shachaf> import Prelude hiding ((.),id)
17:53:27 <shachaf> import Control.Category
17:53:31 <shachaf> In your .ghci, that is.
17:53:37 <shachaf> Then see how long you can stand it.
17:53:47 <johnw> actually, that's how I start most of my modules :)
17:53:52 <Taslem> @pl choose a b = a
17:53:52 <lambdabot> choose = const
17:53:55 <johnw> i baked it into general-prelude, even
17:54:04 <johnw> oh, in .ghci
17:54:04 <Taslem> @pl choose a x = if a then x else 0
17:54:04 <lambdabot> choose = flip flip 0 . if'
17:54:07 <johnw> that I haven't tried
17:54:38 <parcs> > [(.),(Control.Category..)]
17:54:39 <lambdabot>   Not in scope: `Control.Category..'
17:55:06 <Nereid> > [(.),(Prelude..)]
17:55:07 <lambdabot>   Not in scope: `Prelude..'
17:55:07 <lambdabot>  Perhaps you meant one of these:
17:55:07 <lambdabot>    `Prelude.-' (...
17:55:14 <Nereid> :t [(.),(Prelude..)]
17:55:15 <lambdabot> [(a -> b) -> (a1 -> a) -> a1 -> b]
17:55:22 <Taslem> @pl f p (h:t) = if p h then h : f p t else f p t
17:55:23 <lambdabot> f = fix (flip flip tail . (ap .) . flip flip head . ((.) .) . (ap =<< ((flip . (ap .)) .) . liftM2 ap (((.) . if') .) . (flip ((.) . (:)) .)))
17:55:25 <Nereid> :t [(.),(Control.Category..)]
17:55:27 <lambdabot> [(a -> b) -> (a1 -> a) -> a1 -> b]
17:55:36 <Nereid> :t [fmap,(Control.Category..)]
17:55:38 <lambdabot> [(a -> b) -> (a1 -> a) -> a1 -> b]
17:55:41 <Nereid> well.
17:56:29 <Taslem> @pl f p l = if p (head l) then (head l) : f p (tail l) else f p (tail l)
17:56:29 <lambdabot> f = fix (ap (ap . (ap .) . ap (ap . (if' .) . (. head)) . (liftM2 (:) head .) . flip flip tail . ((.) .)) (flip flip tail . ((.) .)))
17:56:48 <Taslem> @pl f p l = if null l then [] else if p (head l) then (head l) : f p (tail l) else f p (tail l)
17:56:48 <lambdabot> f = fix ((ap (flip if' [] . null) .) . ap (ap . (ap .) . ap (ap . (if' .) . (. head)) . (liftM2 (:) head .) . flip flip tail . ((.) .)) (flip flip tail . ((.) .)))
17:56:53 <Nereid> @pl filter
17:56:53 <lambdabot> filter
17:57:02 <Taslem> Yeah, trying to avoid that. :3
17:57:05 <message144> Hi.. I apologize for the stupid question... Even after going through the IO tutorials on haskell.org, I am having trouble figuring out how to rewrite this in "do" syntax: `main = print . maximum . prods . input =<< getContents` . Perhaps someone could give me some tips?
17:57:29 <Nereid> :t \p l -> foldr (\x -> if p x then (x:) else id) []l
17:57:30 <ski> message144 : `main = do print . maximum . prods . input =<< getContents', done
17:57:30 <lambdabot> (a -> Bool) -> [a] -> [a]
17:57:33 <parcs> :t fmap catMaybes . map . ap (<$) . fmap guard
17:57:34 <lambdabot> (a -> Bool) -> [a] -> [a]
17:57:35 <johnw> message144: main do x <- getContents ; print . maximum . prods . input$ x
17:57:39 <shachaf> message144: main = do { s <- getContents; print (maximum (prods (input x)))
17:57:39 <shachaf> }
17:58:10 <Nereid> @do print . maximum . prods . input =<< getContents
17:58:10 <lambdabot> print . maximum . prods . input =<< getContents
17:58:13 <Nereid> hmm
17:58:31 <Nereid> @do getContents >>= print . maximum . prods . input
17:58:31 <lambdabot> do { a <- getContents; (print . maximum . prods . input) a}
17:58:39 <message144> johnw, oh, i guess i am confused by the $ after "input"...
17:58:41 <shachaf> Nereid: @do doesn't do much.
17:58:44 <ski> @botsnack
17:58:44 <lambdabot> :)
17:58:47 <Taslem> @pl f x = x : f (x+1)
17:58:47 <lambdabot> f = fix (ap (:) . (. (1 +)))
17:58:48 <Nereid> evidently.
17:58:48 <shachaf> message144: Ignore the $
17:59:02 <message144> shachaf, oh ok... shachaf , johnw : those are helpful. thank you
17:59:03 <shachaf> message144: do { x <- getContents; (print . maximum . prods . input) x }
17:59:04 <shachaf> Same thing.
17:59:10 <johnw> message144: f . g $ a is the same as (f . g ) a is the same as f (g a)
17:59:27 <applicative> do {contents <-  getContents; print ( maximum ( prods ( input contents))))}
18:00:10 <message144> seeing the different syntaxes does help me a lot to understanding what was going on in that statement
18:00:22 <message144> thanks guys/gals
18:00:42 <johnw> Nereid: nice, I didn't know about @do
18:00:54 <Nereid> there is also @undo
18:01:21 <Nereid> @do x >>= \a -> y a
18:01:21 <lambdabot> do { a <- x; y a}
18:02:05 <Nereid> @do x >>= \a b -> y a b
18:02:05 <lambdabot> do { c <- x; \ a b -> y a b c}
18:02:13 <Nereid> what???????????????
18:02:17 <Nereid> oh wait.
18:02:24 <Nereid> too many ? there.
18:02:32 <Nereid> hmmm
18:02:53 <Nereid> :t ?x >>= \a b -> ?y a b
18:02:54 <lambdabot> (?x::t -> a, ?y::a -> t -> b) => t -> b
18:03:00 <ski> missing brackets
18:03:26 <Nereid> ahh, the (t -> ) monad
18:03:39 <Nereid> ok.
18:03:58 <Nereid> :t do {c <- ?x; \a b -> ?y a b c}
18:03:58 <ski> @type \ a b -> ?y a b ?c
18:03:59 <lambdabot> (?x::t -> t1, ?y::t -> t3 -> t1 -> t2) => t -> t3 -> t2
18:03:59 <ski> @type (\ a b -> ?y a b) ?c
18:03:59 <lambdabot> (?y::t1 -> t2 -> t3 -> t, ?c::t3) => t1 -> t2 -> t
18:04:00 <lambdabot> (?y::t1 -> t2 -> t, ?c::t1) => t2 -> t
18:04:12 <Nereid> haha
18:04:18 <Nereid> yeah ok, so it's doing something funny.
18:04:41 <Nereid> @undo do { c <- x; \ a b -> y a b c}
18:04:41 <lambdabot> x >>= \ c -> \ a b -> y a b c
18:04:42 <ski> it should be `do { c <- x; (\ a b -> y a b) c}'
18:04:45 <Nereid> @undo do { c <- x; (\ a b -> y a b) c}
18:04:45 <lambdabot> x >>= \ c -> (\ a b -> y a b) c
18:04:53 <Nereid> yeah
18:05:06 <mapf> what's the difference between `forall a. Show a => [a]' and `forall a. [Show a => a]'?
18:05:37 <ski> in the latter case, each element will take a constraint
18:05:56 <johnw> a constrained list of elements, vs. a list of constrained elements
18:06:00 <Nereid> does the latter even make sense?
18:06:05 <mikeplus64> no
18:06:06 <johnw> the two are pretty much equivalent though, aren't they?
18:06:09 <shachaf> Since constraints are unique, though, it'll always wind up being the same, I think.
18:06:18 <shachaf> Well, instances, not constraints.
18:06:39 <ski> `forall a. Foo a => [forall b. Bar a b => T a b]' could make sense
18:06:41 <mikeplus64> oh wow, apparently it's valid
18:06:52 <mapf> ski: nice!
18:07:27 <mapf> well, in this case it's really can make sence.
18:07:33 <shachaf> You could have e.g. forall a. [(?x :: a) => a]
18:07:35 <shachaf> Or something.
18:07:52 <Nereid> uh
18:07:59 <ski> sounds fun
18:08:02 <shachaf> Or maybe not that?
18:08:22 <shachaf> rwbarton had a good example where a nested (non-MPTC) class constraint actually made good sense.
18:08:26 <shachaf> I don't remember what it was, though.
18:08:38 <shachaf> elliott: Do you remember?
18:08:41 <elliott> Nope.
18:08:43 <shachaf> And/or know another example?
18:08:44 <pdxleif> Har har, guys: () is a monoid. :J
18:08:53 <ski> shachaf : not on a GADT constructor, by any chance ?
18:09:05 <ski> > () `mappend` ()
18:09:06 <lambdabot>   ()
18:09:07 <shachaf> ski: I think it may well have involved GADTs.
18:09:09 <shachaf> > () <> undefined :: ()
18:09:10 <lambdabot>   ()
18:09:16 <shachaf> But it wasn't on a constructor, I'm pretty sure.
18:09:21 <shachaf> (I could be wrong.)
18:09:36 <johnw> would someone be able to point me to an article that clarifies the relationship between ADTs in Haskell and initial F-algebras?
18:09:39 <shachaf> > undefined <> undefined :: ()
18:09:40 <lambdabot>  Terminated
18:09:45 <ski> `data Foo a where Blah :: Foo a => T a -> Foo a' e.g.
18:09:46 <shachaf> > undefined <> undefined :: ()
18:09:48 <lambdabot>   ()
18:09:56 <pdxleif> () is an abelian group, even, I think.  Can you make a ring out of it?
18:09:58 <shachaf> Hmm, is that too lazy?
18:10:18 <shachaf> > compare (undefined::()) undefined
18:10:20 <lambdabot>   *Exception: Prelude.undefined
18:10:21 <shachaf> > (==) (undefined::()) undefined
18:10:23 <lambdabot>   *Exception: Prelude.undefined
18:10:30 <shachaf> Sometimes I wish those were lazier.
18:10:39 <ski> > seq (((),()) `mappend` ((),())) ()
18:10:41 <lambdabot>   ()
18:10:54 <johnw> shachaf: since all maps to () are equal, it doesn't matter what the value is if the type is (), right?
18:11:17 <johnw> does the supplied value (undefined <> undefined) get thrown away by the compiler?
18:11:25 <shachaf> Try it out.
18:11:28 <shachaf> I'm not the compiler.
18:11:34 <pdxleif> I know that all computations of type () will (okay, should) have the value (); seems the compiler could just short-circuit everything of type ().
18:11:36 <johnw> you're kind of the next best thing, though
18:11:42 <Nereid> > undefined <> undefined :: ()
18:11:44 <lambdabot>   ()
18:11:50 <ski> pdxleif : there's bottoms
18:11:53 <shachaf> pdxleif: There are two values of type ()
18:12:07 <shachaf> compare respects this; <> doesn't.
18:12:13 <shachaf> (I think I prefer <>'s behavior.)
18:12:46 <pdxleif> Yeah... but, maybe I'd like to consider that the undesired direction; wouldn't I always want () and not _|_?
18:13:20 <parcs> the better question is would you ever want to use the Ord or Monoid instances of ()
18:13:25 <ski> not if you're using `()' to model `Sierpinski'
18:13:26 <Nereid> > undefined < ()
18:13:28 <lambdabot>   *Exception: Prelude.undefined
18:13:42 <Nereid> I'd use the Monoid instance of ()
18:13:51 <ski> parcs : sometimes you might want to instantiate a type variable with `()'
18:13:55 <Nereid> it makes e.g. Const () an Applicative.
18:13:57 <pdxleif> parcs: Yeah, it seems kinda silly - that's why I chuckled when I saw a Monoid instance defined for it.
18:14:31 <Nereid> there are probably better reasons.
18:15:02 <fmap> Nereid: isn't Const () a Monad?
18:15:16 <Nereid> is it?
18:15:32 <Nereid> well, one can make it a Monad, but
18:15:39 <fmap> well, I don't know but why not?
18:16:06 <Nereid> it's pretty exceptional.
18:16:12 <Nereid> not many other Const t could be made monads.
18:16:42 <Nereid> as in no others.
18:17:04 <applicative> Monoid a =>  Monad (Const a)
18:17:09 <Nereid> nope.
18:17:11 <Nereid> how do you define bind?
18:17:19 <Nereid> you only get an Applicative.
18:17:47 <Nereid> ok, you can define bind, but it won't satisfy some law I'm pretty sure.
18:17:58 <applicative> is it newtype Const a b = Const a ?
18:18:02 <Nereid> yes
18:18:08 * hackagebot hOpenPGP 0.6 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.6 (ClintAdams)
18:18:22 <applicative> if everything is Const mempty how could an equality fail?
18:18:33 <cmccann> pf, () is just the church-decoded version of id.
18:18:51 <Nereid> because not everything is Const mempty.
18:19:16 <Nereid> consider return a >> Const b
18:19:44 <Nereid> that should be Const b, but you can't get that.
18:19:52 <shachaf> cmccann: Boehm-Berarducci decoded, surely!
18:20:19 <Nereid> unless, of course, there is only one possible value for b.
18:20:47 <cmccann> shachaf: no, that has too many letters to type
18:21:50 <shachaf> Can you "church-decode" arbitrary function types to ADTs?
18:21:53 <shachaf> It seems like probably not.
18:21:57 <shachaf> How do you distinguish?
18:22:21 <lightquake> is there anybody on who knows how to hack on haskell-mode?
18:22:46 <shapr> lightquake: I have some minor clue, what's up?
18:23:01 <lightquake> https://github.com/haskell/haskell-mode/issues/110 is annoying me a lot lately
18:23:48 <johnw> lightquake: I do
18:23:57 <johnw> ah, yes
18:24:05 <cmccann> shachaf: well, as I just said. I stick with church encoding in order to... B] ...avoid typing.
18:24:09 <johnw> this is actually not hard to fix
18:24:40 <johnw> lightquake: search for "mdo", and just replicate the code you see for "rec"
18:24:50 <johnw> in haskell-indentation.el
18:26:06 <lightquake> ah, that works
18:26:30 <lightquake> speaking of, why is there haskell-indentation and haskell-indent?
18:26:41 <johnw> there are actually 3 of them
18:26:44 <johnw> it's just the march of history
18:26:56 <johnw> haskell-simple-indent is the 3rd
18:26:59 <lightquake> sigh
18:27:19 <johnw> can you send a pull request for that fix?
18:27:57 <lightquake> sure
18:28:08 <elliott> I find the simple indent more usable than the fancier ones to be honest
18:28:26 <lightquake> also, i tried haskell-indent, but if I type 'a <- b' and hit enter, it indents to align with the b and not a
18:28:29 <lightquake> which is really annoying
18:28:59 <elliott> I think the best autoindent for Haskell is probably just something that matches the indentation of the previous line plus a tab key that inserts $indentwidth spaces.
18:30:17 <lightquake> I think I'm just going to use indentation with the rec fix
18:30:56 <lightquake> will submit a pull request after a reboot, since there's something wonky that's making github look awful
18:31:16 <johnw> i like indentation, there are just a few things it doesn't do that I'd like
18:32:36 <johnw> and my attempts to fix them, although they worked for that case, broke too many other things, so I'm still working on refining it
18:33:21 <lightquake> i wish they had more different names
18:33:40 <johnw> you wish what did?
18:34:24 <E0000> heh, i went through every combination of Control/Data . Applicative/Alternative
18:34:28 <E0000> ffs
18:36:27 <lightquake> johnw: -indent vs -indentation
18:38:23 <johnw> lightquake: the real question is, what comes next...
18:38:44 <lightquake> we need another synonym!
18:39:10 <johnw> haskell-adjusted-spacing
18:39:35 <lightquake> ok, weird, it's saying that i have a bunch of changes that replace blank lines with blank lines
18:39:49 <johnw> who says that?
18:39:54 <lightquake> git-diff
18:39:58 <johnw> try git diff -w
18:40:33 <johnw> due to haskell-indentation, you likely have "blank" lines composed of spaces up to the next indentation column
18:40:49 <lightquake> no, i mean
18:40:51 <lightquake> in the .el file
18:40:57 <johnw> ah
18:41:03 <johnw> did you change the line endings?
18:41:07 <lightquake> not intentionally
18:41:37 <lightquake> ah, there's a bunch of trailing whitespace on blank lines
18:42:56 <mapf> lightquake: i think save-hook should be helpful here. (mapf is going to google....)
18:43:13 <johnw> M-x whitespace-cleanup should generally take care of any errant whitespace
18:43:19 <lightquake> no, i mean, there was whitespace in the original
18:43:22 <lightquake> that i was cleaning up
18:43:57 <johnw> ah
18:44:01 <lightquake> now i just have to remember how to attach the commit I just made locally to the pull request...
18:44:38 <johnw> easiest way is to put it on a branch, push to the branch to your fork on github, then go to github, switch to that branch, then click Pull Request
18:44:49 <johnw> or use the "hub" CLI tool
18:44:59 <johnw> hub pull-request <mybranch>
18:45:31 <johnw> (you may need "hub fork" first)
18:57:19 <pdxleif> The wikipedia reference on http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html doesn't sound quite right to me in the context.
18:57:33 <pdxleif> "Any semigroup S may be turned into a monoid simply by adjoining an element e not in S and defining e*e = e and e*s = s = s*e for all s ‚àà S."
18:57:53 <shachaf> I like http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Category.html
18:57:57 <shachaf> "A class for categories. id and (.) must form a monoid."
18:58:11 <pdxleif> It's not simply adding an identity  elemement to an existing set; the set is lifted into Maybe, and the <+> is defined as being isomorphic, and then hey, free identity (Nothing)
18:58:12 <shachaf> pdxleif: Why doesn't that seem right?
18:58:32 <shachaf> pdxleif: I think they're talking about monoids with sets, not types.
18:58:42 <shachaf> Oh.
18:58:50 <shachaf> You're talking about the Maybe instance?
18:58:53 <pdxleif> Yeah
18:59:06 <shachaf> I like how the Maybe instance demands a Monoid and then ignores mempty.
18:59:13 <shachaf> "defeating most of the purpose??"
18:59:42 <shachaf> Anyway, which part is wrong?
18:59:48 <shachaf> The thing Wikipedia says looks correct to me.
18:59:56 <pdxleif> I guess I was picturing wikipedia saying, "given semigroup Nmod5, +, you can make it into a monoid by adding 0 (Zmod5)"
18:59:58 <shachaf> Of course since we're dealing with types and not sets, the best we can do is an isomorphism.
19:00:23 <MaybeCallMe> I am tired of modifying one record at a time in my data-type while inside a state monad function.. what do i do? I cannot change multiple records at the same time.
19:00:44 <johnw> why can't you?
19:01:03 <parcs> one record or one field?
19:01:10 <johnw> modify (\x -> x { field1 = foo, field2 = bar })
19:01:15 <shachaf> I'm not sure what your question is, but maybe lens is the answer.
19:01:37 <pdxleif> I guess Nothing is not in a, but Nothing `mappend` a does not equal a; that's not defined.
19:01:50 <lightquake> my magic psychic powers make me want to guess that MaybeCallMe is using lens and their datatype is polymorphic
19:01:51 <applicative> pdxleif: it seems like it's just another, characteristically mathematical, way of saying you can write Semigroup s => Monoid (Maybe s) where ...
19:01:56 <shachaf> pdxleif: Yes, but we're talking about sets.
19:01:58 <MaybeCallMe> johnw: i didnt know that notation
19:02:00 <mapf> shachaf: it seems like lens is always the answer
19:02:08 <MaybeCallMe> shachaf: will check outlens
19:02:09 <lightquake> so they have something like data Foo a = Foo { bar :: a, baz :: a }
19:02:11 <E0000> an answer looking for a question xD
19:02:12 <lightquake> ‚Ä¶ or not
19:02:24 <MaybeCallMe> parcs: one field inside a data type
19:02:26 <johnw> lens is at least always the question, whether the asker knows or not
19:02:34 <napping> pdxleif: Maybe A is the type of A with one extra element adjoined, Just is the injection of A and Nothing is the new element
19:02:50 <shachaf> pdxleif: If we have the set S = {a, b, c}, we can define the set T = S ‚à™ {z}, and a new operation which behaves the same as the old one for any element not involving z, and as an identity for any operation involving z.
19:05:18 <johnw> @faq Can lens manufacture an identity for any Semigroup?
19:05:18 <lambdabot> The answer is: Yes! Haskell can do that.
19:05:47 <PatrickRobotham> Can haskell do something impossible for haskell to do?
19:05:59 <PatrickRobotham> @faq Can haskell do something impossible for haskell to do?
19:05:59 <lambdabot> The answer is: Yes! Haskell can do that.
19:06:06 <shachaf> If we defined newtype Foo m a b = Foo { unFoo :: forall c. (b -> m c) -> a -> m c }, would that have the same benefits as Codensity?
19:06:07 <johnw> @faq Can Haskell create an instance of the Void type?
19:06:07 <lambdabot> The answer is: Yes! Haskell can do that.
19:06:15 <mapf> heh
19:06:18 <cmccann> @remember shachaf I'm not sure what your question is, but maybe lens is the answer.
19:06:18 <lambdabot> Done.
19:06:24 <MaybeCallMe> johnw: in data A = B { c::Int, e::F}, can I modify \s - s { c = 0 }?
19:06:38 <johnw> modify $ \s -> s { c = 0 }
19:06:46 <shachaf> MaybeCallMe:: You can also modify (\s -> s {c = 0, e = someF })
19:07:05 <shachaf> You can also use lens, and say "c .= 0"
19:07:06 <MaybeCallMe> shachaf: yeah but i only want  to modify one field
19:07:17 <shachaf> OK. I thought your question about about multiple fields. :-)
19:07:20 <johnw> shachaf: but only if he creates a lens for 'c'
19:07:26 <shachaf> johnw: Sure.
19:07:48 <johnw> i do much prefer the lens operators for working with state
19:07:56 <pdxleif> The stuff about Semigroup s => Monoid (Maybe s) and Just is the injection of A makes sense; it just seemed weird to me in terms of sets, as Maybe String isn't simply String ‚à™ Nothing.
19:08:03 <MaybeCallMe> shchaf: hmm this lens stuff keeps being talked about quite a lot.
19:08:03 <MaybeCallMe> johnw: so i can change one field inside my data type using modify... didnt know that
19:08:16 <johnw> MaybeCallMe: it's not modify that's magical here, it's just record syntax
19:08:17 <pdxleif> Just String is isomorphic to String, though.
19:08:29 <shachaf> Just String is an error. :-)
19:08:37 <shachaf> But yes.
19:08:38 <pdxleif> bah
19:08:39 <MaybeCallMe> johnw: dint know that about record syntax then
19:08:57 <johnw> record creation: Foo { field = value}, record mutation: foo { field = value }
19:08:59 <shachaf> pdxleif: When you're working with types rather than sets, you generally have to say annoying things like "up to isomorphism"
19:09:07 <shachaf> In fact you have to say them so much that people don't even say them.
19:09:13 <MaybeCallMe> johnw: thanks
19:09:20 <johnw> you can even mutate the results of function calls: (returnAFoo x) { field = value }
19:09:24 <johnw> the parens are necessary
19:09:36 <cmccann> saying "up to isomorphism" is the same as not saying it, up to isomorphism.
19:09:45 <Nereid> record update binds more tightly than function application.
19:09:52 <johnw> @remember cmccann saying "up to isomorphism" is the same as not saying it, up to isomorphism
19:09:53 <lambdabot> Nice!
19:11:00 * cmccann is very familiar with it being a pain to write out "up to isomorphism" often.
19:11:11 <johnw> you don't have a uti macro?
19:11:20 <shachaf> johnw: That sounds unpleasant.
19:11:36 <johnw> and my wife is a doctor too... if she were reading over my shoulder, she'd say whaaa?
19:11:43 <cmccann> hahahaha
19:11:49 <byorgey> hehehe
19:12:50 <cmccann> johnw: for context, my primary email address uses the domain uptoisomorphism.net
19:13:20 <shachaf> cmccann: You lasted for over 2 minutes before explaining!
19:13:24 * shachaf was waiting for it.
19:13:53 <cmccann> alas, I cannot resist the siren call of explaining.
19:13:57 <cmccann> it's a compulsion.
19:14:53 <pdxleif> You can say Just String :: Maybe Type in Idris, though. :J
19:14:53 <pdxleif> Just String :: Maybe * in Haskellese
19:15:13 <shachaf> pdxleif: Hah, true, GHC even supports that now!
19:15:32 <johnw> how come GHC uses * for kinds instead of Type or Set?
19:15:58 <shachaf> I think it's meant to represent ‚òÖ
19:16:00 <cmccann> Haskell uses * because people would complain about having to type ‚òÖ
19:16:53 <lightquake> ok, added
19:17:08 <lightquake> thanks to github being weird I wound up creating another issue by accident :(
19:17:20 <johnw> that's normal behavior for making a pull request
19:17:30 <johnw> it looks like an issue so the maintainer can comment on it
19:18:39 <lightquake> yeah, but i already had an issue
19:18:43 <lightquake> so now there's #110 and #111
19:18:47 <lightquake> i was hoping to 'convert' #110
19:18:53 <johnw> yeah, i've never found a way to do that
19:18:59 <lightquake> so what am i supposed to do?
19:19:02 <johnw> just close #110 with a reference to #111
19:19:57 <lightquake> that's what I wound up doing
19:20:12 <johnw> and in the future, submit patches instead of opening issues :)
19:20:37 <johnw> problem solved!
19:20:49 <elliott> you're meant to leave #110 open until #111 is merged I think
19:21:01 <lightquake> that's annoying.
19:21:26 <cmccann> clearly you need to open another issue for fixing the issues caused by opening too many issues.
19:25:14 <byorgey> lightquake: the other thing you can do is that if your commit message has something like  'fixes #110' or 'closes #110' or whatever in it, #110 will automatically get closed when #111 is merged
19:26:06 <byorgey> that's actually a fairly standard thing to do.
19:26:41 <byorgey> it makes sense to have a separate ticket for the issue AND for the pull request, because the pull request might be rejected
19:27:06 <byorgey> and it makes sense to have a discussion on the particular pull request as separate from the issue itself.
19:32:43 <darkf> How can people say Haskell is strictly pure functional if `unsafePerformIO` exists and allows you to write imperative programs with globally mutable data?
19:33:18 <mrout> wow, totally didn't actually expect you to come here. You MUST be confident.
19:34:10 <mrout> Sorry, this question is asked a lot here, I expect many people get sick of it.
19:34:29 <shachaf> darkf: It's a trade-off.
19:34:46 <shachaf> I don't really care whether Haskell is "strictly pure functional".
19:34:54 <darkf> shachaf: Right, but I am asking more about the aspect of people referring to it as "pure functional"
19:35:02 <shachaf> Words, words, words.
19:35:05 <mrout> I'd say that Haskell is a pure functional language, whereas GHC is an implementation of a superset of Haskell including the foreign function interface, which is not.
19:35:20 <shachaf> The FFI addendum includes unsafePerformIO, they say.
19:35:35 <darkf> mrout: That was not your argument elsewhere.
19:35:37 <shachaf> Anyway, Haskell 2010 includes the FFI.
19:35:38 <E0000> uhg
19:35:47 <mrout> darkf: yes it was.
19:35:55 <E0000> note the self dont use > instead of < in the shell on a file you onyl have one copy of
19:35:57 <shachaf> Let's keep elsewhere arguments elsewhere.
19:36:08 <mrout> I said Haskell was 100% pure functional, and I didn't mention any specific implementation.
19:36:46 <shachaf> darkf: Arguing about words is really not worth your time, I think. Haskell has many nice properties, and if you use unsafePerformIO you lose some of these properties.
19:36:52 <shachaf> That's why it's called "unsafe".
19:37:17 <shachaf> If you wanted, you could make Haskell-without-unsafePerformIO.
19:37:28 <cmccann> haskell is 100% anything given sufficient quibbling over semantics
19:37:29 <shachaf> But to do some practical things, like FFI, you more or less need it.
19:37:37 <darkf> shachaf: Yeah :P I just find it silly people insist it's always pure-functional when if you include unsafePerformIO you could write C-like imperative programs.
19:37:37 <shachaf> Yay, quibbling!
19:37:52 <simpson> darkf: Uh, you can write C-like imperative programs without it too.
19:38:00 <darkf> simpson: I mean mutably.
19:38:09 <shachaf> You can write programs with mutation without unsafePerformIO.
19:38:14 <shachaf> Just use IO the normal way.
19:38:19 <darkf> I'm not counting ST, but IORef.
19:38:22 <cmccann> in fact, you don't want to use unsafePerformIO if you're writing imperative code.
19:38:24 <simpson> darkf: Well, IORef gives you in-place mutability.
19:38:31 <cmccann> it makes things impossible to understand.
19:38:34 <simpson> darkf: And even without that, you can still have "mutable" semantics.
19:38:39 <cmccann> on-demand evaluation and side effects do not mix
19:39:38 <roadfish> perhaps Haskell can be thought of the best language for pure-functional programming ... _if_ you so choose to discipline yourself to pure-functional programming.
19:39:55 <darkf> Yep.
19:40:13 <shachaf> cmccann: But http://www.reddit.com/r/haskell/comments/jarp0 !
19:40:37 <cmccann> shachaf: oh thanks I had forgotten about that
19:40:46 <cmccann> man wtf
19:40:54 <cmccann> I still don't understand why he was doing that :[
19:41:17 <darkf> wow
19:41:38 <mapf> where is difference between constraints and fact that `terms depends on types'?
19:42:11 <cmccann> mapf: what kind of constraints do you mean? type classes?
19:42:15 <mapf> or `terms depends on types' entail constraints or vise versa?
19:42:26 <mapf> cmccann: yes?
19:43:05 <cmccann> and for "terms depend on types" that depends on whether you're parametric for the types
19:43:43 <cmccann> i.e. if you always bind types to generic variables and use those you get the usual parametric polymorphism
19:43:56 <cmccann> but that's still type -> term
19:44:08 <MaybeCallMe> How do I call update :: Double -> State s a from C?
19:44:29 <shachaf> C as in the language? FFI?
19:44:51 <MaybeCallMe> FFI..update :: Double -> State s a is inside a DLL created by GHC
19:45:09 <shachaf> You'll have to make it into something C understands.
19:45:10 <cmccann> mapf: whereas you can think of type classes as inspecting the choice of type somehow, so that you can pick different terms depending on which type is given
19:45:45 <roadfish> mapf: constraints on a type signature limit what types can be used. for instance, you can limit a sort function to only accept types that have a comparision operation defined for them.
19:46:18 <cmccann> mapf: if types were actually classified usefully by kinds the way data constructors go with type constructors you'd be done and not need constraints
19:46:39 <shachaf> cmccann: Classified types? Is that the next level after just not exporting them?
19:46:59 <cmccann> but since type classes are open functions and kinds are mostly *, you need a way to say that a function inspecting a type argument is given only types it knows how to work with
19:47:21 <cmccann> which is what constraints like (Ord a) => are doing
19:47:52 <mapf> roadfish: yes, i understand. But i wonder about relationship between constraints and type -> term.
19:47:53 <cmccann> shachaf: sorry, you don't have the clearance needed to know the answer to that.
19:48:32 <cmccann> mapf: did my explanation make any sense?
19:48:48 * cmccann is doing too many things at once, and may be saying nonsense
19:48:50 <mapf> yes, i slow a bit.
19:49:09 <mapf> thanks :)
19:49:21 <roadfish> mapf: ok, then you know more than me. I guess I don't understand what a "term" is in the context of Haskell.
19:49:45 <cmccann> roadfish: "term :: type"
19:49:52 <cmccann> and "type :: kind"
19:50:02 <shachaf> roadfish: "term" is just Haskell terminology.
19:50:07 <cmccann> also called "values" or whatnot.
19:50:20 <cmccann> basically an implementation detail needed to convince GHC that your types are correct
19:50:24 <cmccann> not something to worry about overmuch
19:50:24 <shachaf> I thought expressions have types, and values don't?
19:50:25 <shachaf> Or something.
19:50:27 <shachaf> I'm not sure.
19:50:37 <mapf> i was thinking that term is rather form of expression.
19:50:49 <mapf> * a form of expression.
19:51:29 <cmccann> no, * is a kind ;]
19:52:19 <roadfish> would it be correct to say that a term is an instance of a type? so the term (or value) 3 is an instance of the type Int.
19:52:26 <shachaf> cmccann: Aw, you replied to the follow-up question about existentials vs. universals.
19:52:34 <shachaf> Well, I would probably've been too lazy to write a proper answer anyway.
19:52:42 <cmccann> "instance" usually means type class instances around here
19:52:48 <shachaf> Also I don't do the stackover flow thing much.
19:52:54 <cmccann> shachaf: you should.
19:52:56 <cmccann> it's fun.
19:53:09 <cmccann> you could try to beat elliott's high score!
19:53:20 <shachaf> cmccann: I'm going to get a GOLD BADGE, I hear!
19:53:27 <tikhonjelvis> I think "term" usually means something closer to "expression" than "value". As in "lambda term" or something like that.
19:53:29 <shachaf> The boring one.
19:53:40 <mapf> types is terms too.
19:53:45 <shachaf> My browser has visited stackoverflow.com every day for the last 80 days
19:53:48 <tikhonjelvis> Confusingly, 3 can be either one
19:53:50 <roadfish> ok, ... so then you want to say 3 is a _____ of Int, what do you say? 3 is a term of type Int?
19:53:51 <shachaf> Apparently you can get a badge for that.
19:54:09 <cmccann> shachaf: good work, glad you could rise to the challenge
19:54:24 <shachaf> cmccann: You have 12 gold badges, I'm told.
19:54:30 <tikhonjelvis> roadfish: It can really be either. The expression `3' is a term and the number 3 is a value.
19:54:31 <cmccann> who told you that?
19:54:34 <tikhonjelvis> at least that's my understanding
19:55:39 <cmccann> yeah, I think "term" is more syntactic than "value"... I dunno, I still get lost with too much type theory jargon
19:56:26 <tikhonjelvis> I think some people use these words loosely, at least in conversation
19:56:39 <shachaf> cmccann: Is there a way to make something which both isomorphic to [a] and composable with (.)?
19:56:52 <shachaf> Instead of [a], feel free to pick some other monoid or category "or whatever".
19:57:01 <shachaf> (Functions don't count.)
19:57:24 <cmccann> composable in what sense
19:57:34 <cmccann> do you want (.) to concatenate the lists?
19:58:01 <shachaf> That's what I was thinking.
19:58:10 <shachaf> Like the monoid instance.
19:58:19 <shachaf> You can use [a] -> [a] but that's clearly not isomorphic to [a]
19:58:29 <shachaf> (Trivial monoids also don't count.)
20:00:44 <cmccann> shachaf: wouldn't some sort of partially applied foldr work?
20:01:04 <shachaf> cmcann: How?
20:01:24 <shachaf> I was thinking along those lines but I can't figure out how to make it both (.)-composable and isomorphic to [a]
20:02:54 <cmccann> shachaf: you'd need to abstract over the choice of folding function somehow I think
20:03:14 <roconnor> shachaf: can it be rank 2?
20:04:20 <cmccann> anything simple like just (\z -> foldr (:) z "foo") probably leaves you open to extra junk in the resulting type
20:04:35 <shachaf> roconnor: It's surely better if it's not, but rank-2 is better than nothing.
20:06:34 <cmccann> shachaf: partially applying foldr to the string would work except that you can't compose with (.) because of needing to give it the function argument, right?
20:06:49 <cmccann> :t \f z -> foldr f z "foo"
20:06:50 <lambdabot> (Char -> b -> b) -> b -> b
20:07:24 <shachaf> cmccann: Right.
20:07:32 <shachaf> That's isomorphic to [Char]
20:07:39 <cmccann> heheh
20:07:42 <shachaf> (And it also gives you the (asymptotic) performance benefits of DList.)
20:07:45 <shachaf> (Which is nice.)
20:07:56 <cmccann> in that case, how about (?f :: a -> b -> b) => b -> b
20:07:58 <cmccann> :D
20:08:06 <cmccann> same thing, but composes with (.)
20:08:40 * cmccann cheats
20:10:45 * cmccann interprets the lack of response as shachaf being too horrified to speak
20:11:50 <aavogt> cmccann: -XImplicitResponse
20:12:01 <cmccann> :D
20:12:20 <cmccann> I think that was the first time I've used implicit pararms for anything other than generating errors.
20:12:36 <shachaf> cmccann: I love the errors generated by ImplicitParams.
20:12:49 <cmccann> they're more useful than implicit params themselves.
20:12:56 <shachaf> Give me implicit params over holes as I understand them in GHC HEAD any day.
20:13:01 <Fuuzetsu> smooth topic change
20:13:51 <cmccann> shachaf: anyway you could probably do something similar using other constraints to get your concatenate with (.) thing
20:14:18 <cmccann> since it's the implicitude of constraints in general that makes that work
20:14:19 <shachaf> Not constraints, please.
20:14:56 <cmccann> picky, picky.
20:15:12 <cmccann> I gave you a solution, now you're stuck with it.
20:15:15 <cmccann> no changing the rules.
20:18:29 <frost_> a bit stupid question, but aprox what percentage of your code is pure and what perc. IO?
20:18:41 <shachaf> Depends on the code.
20:19:07 <frost_> a ballpark estimate
20:19:18 <shachaf> I've never written a ballpark estimator.
20:19:27 <shachaf> Seems kind of specialized.
20:20:14 <frost_> and if you were to write a ballpark estimator, what percentage of your code would be pure?  (:
20:21:01 <shachaf> I don't know much about baseball.
20:21:54 <shachaf> What are you trying to figure out from your question? I suspect this varies quite a lot depending on the code.
20:22:47 <Ralith> I'd probably write a ballpark estimator that was pure except for the part that read input parameters.
20:22:50 <Ralith> but that's just me.
20:23:09 <cmccann> generally, I use IO in the parts of my code that require IO, and in the parts that do not require IO, I don't use it.
20:24:55 <shachaf> What non-Functors p have instances of p a -> p (Either b a)?
20:25:00 <shachaf> Or of p (a,b) -> p a
20:25:30 <cmccann> shachaf: anything that could be a Functor except nobody wrote an instance for it?
20:25:45 <shachaf> cmccann: Well, Endo is also an instance of the former.
20:25:50 <frost_> I find myself pulling out parts of code from IO function and placing it pure function, and ending up with more complex code
20:26:03 <shachaf> (In a useful way, that is.)
20:26:19 <cmccann> frost_: then you're either pulling parts out the wrong way, or pulling out parts that shouldn't be pulled out
20:26:20 <shachaf> (Of course you could just give id, but that's not what I mean. You can use the a.)
20:26:22 <Fuuzetsu> frost_: but now you can re-use that pure code somewhere else
20:26:28 <Fuuzetsu> make it more generic if need be
20:26:58 <cmccann> on the other hand, if it doesn't generalize meaningfully, don't extract it for the sake of extracting it
20:27:32 <monochrom> I would think the proportion of IO code varies wildly by application, no?
20:27:54 <aavogt> frost_: I think that can happen. If you don't make use of being able to test the smaller pieces independently it's easier to just keep making spagetti
20:31:13 <monochrom> sometimes factoring out IO parts and non-IO parts increases size, yes. I even know a C++ example
20:32:04 <monochrom> I saw this beginner C++ code. the goal is to write a class for complex numbers. class Complex { public: Complex() { cout << "please enter the real part: "; cin >> r; ...
20:33:36 <monochrom> that is "simpler" (certainly smaller) then doing it right: the ctor has to take 2 parameters, use main to ask user for the 2 parameters. definitely 10 tokens longer than just asking right in the ctor
20:33:57 <monochrom> but I hope you wouldn't use this to justify the beginner code, would you?
20:34:46 <cmccann> shachaf: you can get a "p (a, b) -> p a" example using the same idea as Endo, but I can't think of anything that isn't a variation on that
20:35:19 <monochrom> even in C++, you would separate IO and pure code, and you would not mind it being bigger
20:35:35 <Tordek> I'm having this problem trying to install wx: http://hpaste.org/80677
20:35:39 <shachaf> cmccann: Unendo r a = (a -> a) -> r, you mean?
20:35:47 <Tordek> anyone has gotten it running successfully?
20:36:27 <cmccann> shachaf: yes, a contravariant Endo basically
20:36:32 <shachaf> Yep.
20:36:47 <shachaf> cmccann: Two more classes: p (Either b a) -> p a, p a -> p (b,a)
20:36:57 <cmccann> e.g. \(Unendo f) = Unendo (f . (*** id))
20:37:02 <cmccann> er, -> not =
20:37:02 <shachaf> You can implement these for any contravariant functor, and for Endo and Unendo.
20:37:28 <shachaf> Anyway having four classes seems like way too many.
20:37:39 <shachaf> I want to know these can be reduced in some reasonable way.
20:37:56 <shachaf> "ideally", two of these would be superclasses of Functor, and the other two superclasses of Contravariant.
20:38:00 <shachaf> (Of course that's not very ideal.)
20:39:11 <frost_> monochrom: yeah that would be pretty bad. but if you say had a function that is obviously IO, I wouldnt feel the need to isolate non-IO parts out of it in C++ like I do in haskell.
20:39:16 <cmccann> shachaf: sort of an anti-variance thing going on here in a way
20:39:34 <cmccann> since they work for not-contravariant and not-covariant
20:39:49 <cmccann> where Endo is neither
20:39:53 <shachaf> Right.
20:40:04 <shachaf> By the way, two of these let you define lenses, and the other two let you define prisms.
20:40:14 <shachaf> Simple lenses and prisms, that is, not polymorphic ones.
20:40:22 <cmccann> "simple lenses" sounds like an oxymoron
20:40:33 <shachaf> cmccann: Simple as in the type "Simple"
20:40:33 <monochrom> if I had a function that is obvious IO, C++ or Haskell, there would be too little non-IO parts to separate out to begin with
20:40:38 <Fuuzetsu> sounds like?
20:40:43 <cmccann> shachaf: stop spoiling my joke
20:40:48 <shachaf> SORRY
20:42:44 <monochrom> but perhaps we have different definitions of "obviously IO"
21:07:17 <lightquake> anybody here good with netwire? i'm trying to figure out how you set up something like a dynamic collection of objects with it
21:23:12 * hackagebot clientsession 0.8.1 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.8.1 (MichaelSnoyman)
21:25:22 <jozefg> Hm anyone got any advice for starting a Haskell meetup?
21:25:52 <shachaf> Step 1: Don't live in Minnesota.
21:26:12 <shachaf> Actually it looks like there are some people.
21:26:22 <Fuuzetsu> That meetup got 1 attendee I believe.
21:26:39 <jozefg> Yeah I'm just wondering if anyone has any experience cause mine is around 0
21:26:55 <jozefg> Don't want to make too much of an idiot of myself
21:26:56 <shachaf> I have experience attending Haskell meetings. That counts, right?
21:27:06 <shachaf> Also, spamming #haskell about them once in a while.
21:27:10 <Fuuzetsu> It's probably easier to find an FP group; there are likely to be Haskellers there
21:27:26 * cmccann lives in enemy territory. probably not much of any haskell meetups here.
21:27:47 <shachaf> cmccann: Aren't you in Pittsburgh?
21:27:54 <cmccann> yes.
21:28:02 <shachaf> There are lots of Haskelling people in Pittsburgh.
21:28:51 <cmccann> I was mostly joking.
21:30:59 <Axman6> jozefg: find people near you on IRC and haskell-cafe first. I've run the AusHac hackathon three times now, I have a feeling I know at least half the aussie haskellers out there now (sadly)
21:35:04 <jozefg> Axman6: Thanks, I think I may go badger people at the university tomorrow, there are usual a few functional people there...
21:35:22 <Axman6> good plan
21:35:43 <Axman6> also a good idea putting out an expression of interest email on -cafew though
21:35:44 <Axman6> -w
21:43:30 <jozefg> Yep that ones out there, /r/haskell gave a better response interestingly though
21:43:53 <fragamus> :t Crypto.classes.finalize
21:43:55 <lambdabot> Couldn't find qualified module.
21:44:05 <fragamus> :t Crypto.Classes.finalize
21:44:06 <lambdabot> Couldn't find qualified module.
21:44:13 <shachaf> Why would lambdabot have a random module like tha?
21:44:57 <fragamus> :m +Crypto.Classes
21:44:57 <Fuuzetsu> http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=Crypto.Classes
21:48:13 * hackagebot crypto-numbers 0.1.2 - Cryptographic numbers: functions and algorithms  http://hackage.haskell.org/package/crypto-numbers-0.1.2 (VincentHanquez)
21:57:49 <hrumph> :t rundb
21:57:50 <lambdabot> Not in scope: `rundb'
21:57:54 <hrumph> oops sorry
21:58:03 <hrumph> meant that for my ghci window
21:58:13 * hackagebot crypto-pubkey 0.1.2 - Public Key cryptography  http://hackage.haskell.org/package/crypto-pubkey-0.1.2 (VincentHanquez)
21:58:15 * hackagebot hmatrix-quadprogpp 0.2.0.1 - Bindings to the QuadProg++ quadratic programming library  http://hackage.haskell.org/package/hmatrix-quadprogpp-0.2.0.1 (AkioTakano)
22:18:09 * ion notices http://hackage.haskell.org/package/JuicyPixels named a module ‚ÄúJpg‚Äù and cringes
22:18:42 <shachaf> You'd prefer JPEG?
22:19:32 <ion> The only reason for the missing ‚Äúe‚Äù is the 8+3 filename length restriction in a 1970s filesystem.
22:19:52 <Fuuzetsu> Is that the actual reason?
22:22:16 <ion> Jpg.decodeJpeg http://hackage.haskell.org/packages/archive/JuicyPixels/2.0.2/doc/html/Codec-Picture-Jpg.html
22:24:35 <jozefg> :info Cont
22:24:45 <ion> Control.Lns.lens
22:29:12 <Axman6> "This is great! So now our solution for fiilter looks like this:"
22:29:13 <Axman6> fiilter p = foldRight (if' id . (:) <*> p) []
22:29:16 <Axman6> heh
22:29:22 <Axman6> from http://blog.tmorris.net/posts/refactoring-filter/
22:29:50 <ion> :-D
22:30:52 <ion> [trollface]
22:33:26 <Jupiter123> Hi
22:47:52 <Ghoul_> idk what this does, so here goes everything
22:47:54 <Ghoul_> > mapM_ putStrLn . snd $ runWriter $ mapM_ (tell . replicate 1 . (++) "Hi " . show) everyone
22:47:55 <lambdabot>   Not in scope: `everyone'
22:48:06 <Fuuzetsu> hue
22:48:25 <Fuuzetsu> > mapM_ putStrLn . snd $ runWriter $ mapM_ (tell . replicate 1 . (++) "Hi " .  show) "everyone"
22:48:27 <Ghoul_> some guy failed to send it to lambdabot in another #haskell channel
22:48:27 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
22:48:27 <lambdabot>    arising from a use of ...
22:49:47 <`nand`> snd . runWriter = execWriter
22:50:34 <`nand`> replicate 1 = return/pure = (:[])
22:51:14 <`nand`> so that's:  mapM_ putStrLn . execWriter $ mapM_ (\e -> tell ["Hi " ++ show e]) everywone
22:51:18 <`nand`> perhaps a bit more clear (imo)
22:51:27 <ion> > execWriter $ mapM_ (\a -> tell ["Hi " ++ show a]) "everyone"
22:51:29 <lambdabot>   ["Hi 'e'","Hi 'v'","Hi 'e'","Hi 'r'","Hi 'y'","Hi 'o'","Hi 'n'","Hi 'e'"]
22:51:46 <ion> > map (\a -> "Hi " ++ show a) "everyone"
22:51:47 <lambdabot>   ["Hi 'e'","Hi 'v'","Hi 'e'","Hi 'r'","Hi 'y'","Hi 'o'","Hi 'n'","Hi 'e'"]
22:51:56 <elliott> `nand`: mapM_ putStrLn $ foldMap (\e -> ["Hi " ++ show e]) everyone
22:52:21 <`nand`> elliott: yeah, that's much better than using the writer
22:52:43 <`nand`> of course
22:52:59 <`nand`> mapM_ (\e -> putStrLn $ "Hi " ++ show e) everyone
22:53:04 <`nand`> is the same thing
22:53:32 <`nand`> in fact, that one might actually be clearer in pointless form
22:53:43 <`nand`> mapM_ (putStrLn . "Hi " ++ . show) everyone
22:53:47 <`nand`> oh
22:53:50 <ion> mapM_ (\e -> putStrLn . ("Hi "++) . show) everyone
22:53:52 <`nand`> ("Hi "++)
22:53:54 <ion> err
22:53:59 <ion> mapM_ (putStrLn . ("Hi "++) . show) everyone
22:55:52 <Axman6> everyone must suerly be IO [Person] though
22:56:13 <Axman6> everyone >>= mapM_ (putStrLn . ("Hi " ++) . show)
22:56:24 <`nand`> Axman6: could be in scope as do { everyone <- getEveryone; ... }
22:57:53 <Axman6> perhaps. eitherway, it hasn't been declared yet, so the type checker is going to chuck a hissy fit when it tries to figure this one out!
22:59:03 <`nand`> looks like there's an ‚Äòeveryone‚Äô in liboleg
22:59:52 <ninegrid> ow my eyes http://i.imgur.com/rxec4.png
23:00:09 <`nand`> makes perfect sense!
23:00:25 <Fuuzetsu> why would anyone do that
23:00:39 <cmccann> what the actual fuck is that diagram doing
23:00:39 <ninegrid> hate in their heart
23:00:40 <`nand`> also that signature for length is wrong
23:01:31 <ninegrid> `nand`: so is x <- ask :: String
23:01:31 <Fuuzetsu> maybe it's a magic length where a is already a list
23:01:47 <Fuuzetsu> although you couldn't fmap that I guess
23:03:15 * hackagebot tls 1.1.1 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.1.1 (VincentHanquez)
23:07:42 <`nand`> Fuuzetsu: length . unsafeCoerce :: a -> Int
23:07:56 <cmccann> unsafeCoerce saves the day again!
23:16:28 <Fuuzetsu> :t unsafeCoerce
23:16:29 <lambdabot> Not in scope: `unsafeCoerce'
23:16:35 <Fuuzetsu> @src unsafeCoerce
23:16:36 <lambdabot> Source not found. My mind is going. I can feel it.
23:16:40 <Fuuzetsu> ;_;
23:16:49 <cmccann> lambdabot doesn't approve of unsafeCoerce
23:16:55 * Fuuzetsu stays away from anything with `unsafe' in it
23:17:16 <cmccann> anyway, it's "unsafeCoerce :: a -> b"
23:17:28 <Fuuzetsu> How does it work?
23:17:34 <cmccann> the implementation is the same as for "id"
23:17:39 <cmccann> it works because the compiler lets it work
23:17:40 <elliott> Fuuzetsu: It doesn't
23:17:48 <thoughtpolice> heh
23:17:49 <elliott> Trust me, I've tried.
23:18:03 <cmccann> it's a great way to do things you can't normally do in Haskell
23:18:05 <cmccann> like cause segfaults
23:18:19 <Fuuzetsu> Does it get special treatment from the compiler?
23:18:33 <thoughtpolice> Fuuzetsu: yes, although you can define it yourself using unsafePerformIO
23:18:41 <thoughtpolice> so just stay away from unsafe* :)
23:19:08 <mapf> until you get to work with FFI
23:19:19 <cmccann> you can also define unsafeCoerce using GeneralizedNewtypeDeriving!
23:19:28 <Fuuzetsu> Is there a way to ensure that none of the libraries I might use don't use the unsafe functions?
23:19:38 <mapf> cmccann: how?
23:19:59 <cmccann> mapf: http://joyoftypes.blogspot.com/2012/08/generalizednewtypederiving-is.html
23:20:12 <Fuuzetsu> >Fauna & Flora International
23:20:32 <Fuuzetsu> ah, external calls
23:20:36 <thoughtpolice> mapf: you can use it to break system-f, basically. read that link, and read this ticket: http://hackage.haskell.org/trac/ghc/ticket/1496
23:23:14 <thoughtpolice> Fuuzetsu: in general, you can use SafeHaskell to roughly enforce the kind of thing you want. i say roughly because it doesn't necessarily mean that libraries you use don't use unsafe functions (bytestring/text use them, for example,) but it does enforce boundaries at the module level, as to whether you can use code that's explicitly unsafe
23:23:51 <thoughtpolice> which rules out GeneralizedNewtypeDeriving, the unsafe* functions, TH, etc
23:25:01 <Fuuzetsu> Trustworthy and Unsafe seem like nice ideas too
23:25:04 <elliott> Fuuzetsu: you generally don't want to ensure that.
23:25:09 <elliott> unsafeCoerce is there for a reason: it has important uses.
23:25:17 <cmccann> who needs bytestring and FFI bindings anyway
23:28:10 <E0000> exactly
23:58:11 <ttoz> hello
23:59:31 <ttoz> anyone?
23:59:56 <ion> Nope, just us 925 non-existent users.
