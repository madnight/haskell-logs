00:02:27 <hpaste> adnap pasted ‚Äúcabal problem‚Äù at http://hpaste.org/84248
00:02:37 <adnap> What do I do about this?
00:03:05 <adnap> I actually want to use yesod and reactive-banana in my project.
00:08:42 <Heffalump> adnap: install them both on the same command line, then cabal will try to find an install plan that works for both
00:08:53 <Heffalump> i.e. 'cabal install yesod-platform reactive-banana'
00:08:58 <Heffalump> and if it fails it will try to explain why
00:21:14 <no-n> what kinds of software is haskell mostly used for creating?
00:21:29 <arkeet> any software.
00:30:25 <m3ga> no-n: to expand on arkeet's response, haskell is good for most kinds of user space programming. it is especially good for compilers and is starting to be really good for web apps. mathematical and scientific programming is also a strong point. GUI centric programs is possibly its only really weak area.
00:31:51 <no-n> cool
00:48:14 <donri> m3ga: i wouldn't call it great for "systems" programming either
00:49:36 <tsou> m3ga: did you have something specific in your mind when you wrote "starting to be really good for web apps"?
00:51:34 <augur> do i just cabal install to update a package?
00:56:30 <davorak> augur: yes that is the way to update with cabal
00:56:36 <sw2wolf> augur: cabal doesnot support updating. You need `ghc-pkg unregister <pkg>` and `rm - -fr ...`
00:57:17 <davorak> maybe I have been using nixos for too long if I got that wrong.
00:58:45 <augur> davorak: no i think you're right. cabal tells me to update cabal-install that way
00:58:51 <augur> so im guessing thats how it works for everything
00:59:01 <arkeet> sw2wolf: the rm step isn't necessary
00:59:13 <dannybtran> Hi everyone ‚Ä¶ I'm very new to FP and Haskell ‚Ä¶ I just started on my first program ‚Ä¶ tic tac toe ‚Ä¶ clearly a toy project, but would love some feedback on the code ‚Ä¶
00:59:16 <dannybtran> https://github.com/dannybtran/haskell-tic-tac-toe
00:59:22 <arkeet> augur: there is no "update", there is only "install a new version"
00:59:36 <latermuse> arkeet: most haskell works that way
00:59:37 <arkeet> you are responsible for making sure things don't break and possibly removing the old version
00:59:57 <sw2wolf> arkeet: just want disk to be clean
01:01:12 <donri> 'install' will leave old versions of libraries also installed, but replaces executables
01:02:03 <sw2wolf> @type (.)
01:02:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:02:11 <sw2wolf> @type fmap
01:02:13 <arkeet> @type (Prelude..)
01:02:13 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:02:15 <lambdabot> (b -> c) -> (a -> b) -> a -> c
01:02:38 <donri> sw2wolf: lambdabot is silly
01:02:45 <arkeet> cale is silly.
01:02:46 <sw2wolf> indeed silly
02:17:54 <adek> Does ghc define constants saying for example when binary was built? Something like in C we have __NAME and stuff like that
02:19:34 <ion> TIL a constructed record with a missing field will compile with the field simply being bottom.
02:19:44 <ion> > (isJust Just{}, maybeToList Just{})
02:19:46 <lambdabot>   (True,[*Exception: <interactive>:3:29-34: Missing field in record construct...
02:20:18 <danr> ion: isn't this what you would expect? :)
02:20:28 <quicksilver> ion: yes. Annoying, isn't it? Or, convenient, isn't it?
02:20:31 <quicksilver> depends what you wanted.
02:20:31 <c_wraith> the alternative is a compile error
02:20:35 <ion> quicksilver: Yes, both.
02:20:44 <c_wraith> there are cases for both, obviously
02:21:51 <ion> > Just{} & _Just .~ 42
02:21:54 <lambdabot>   Just 42
02:22:08 <danr> c_wraith: I would prefer that only with -Wall -Werror
02:22:19 <c_wraith> adek: if you use cabal-install to build, it will define some pre-processor constants, but nothing like that. To encode build time, the usual approach is template haskell.
02:22:59 <c_wraith> doesn't -Wall warn about incomplete record construction, which would mean it already does that?
02:23:01 <ion> danr: But it doesn‚Äôt even give a compile-time warning.
02:23:21 <danr> ion: that's horrible!
02:23:31 <danr> ion: are you using -Wall?
02:23:40 <ion> danr: Yes. -Wall -Werror
02:23:42 <adek> c_wraith: How can it be done using template haskell then?
02:24:02 <danr> ion: ugh
02:24:13 <danr> I would patch ghc if I had some spare time :)
02:24:16 <ion> The test source file: main :: IO (); main = print (Just{} :: Maybe Integer)
02:24:32 <ion> GHC 7.6.2
02:24:48 <danr> ion: why don't you put it on the ghc trac?
02:25:18 <ion> danr: I‚Äôll try to remember to do that a bit later.
02:25:57 <srhb> Yeah it's rather scary.
02:27:17 <liyang> ion: if the field is strict, it's always a compile-time error.
02:28:02 <srhb> Oh? Didn't know that.
02:28:20 <c_wraith> adek: If I weren't just about to go to sleep, I'd rough out a sample module. Since I am about to go, here's a quick sketch. Create a separate module for this (due to TH limitations, it's best to use it in modules that are as small as possible). Have the module export a single value. Define the value with a TH splice that uses runIO to get the current time, and then converts it to a string however you like. If you know TH, this is easy. If you don't
02:28:20 <c_wraith>  know it, google around a bit.
02:28:23 <ion> liyang: ok
02:28:25 * liyang has lots of {-# UNPACK #-}! fields in his code.
02:28:54 <srhb> liyang: Isn't it sufficient to just throw ! at the fields?
02:29:20 <danr> liyang: interesting
02:29:26 <adek> c_wraith: thanks! Gonna follow your hints.
02:29:31 <liyang> srhb: with -funpack-strict-{primitive-,}fields or something, yes.
02:29:55 <tdammers> I can confirm the Just{} thing
02:30:00 <liyang> srhb: otherwise you still end up with an indirection; still much faster than a lazy field though.
02:30:09 <tdammers> compiles without warning, but yields a runtime error
02:30:32 <srhb> liyang: OK, thanks. :)
02:30:59 <liyang> srhb: but I don't always want to unpack every strict field, only primitive ones, and tibbe only added -funpack-strict-primitive-fields recently.
02:31:10 <bitonic> curiously if the datatype is a record GHC warns about unitialised fields
02:31:24 <bitonic> e.g. `data Foo = Foo {foo :: Int}; main = print Foo{}'
02:31:25 <quicksilver> I think that part is a bug.
02:31:41 <quicksilver> I mean, it's a bug that the warning only shows when the data type was declared with record notation.
02:31:42 <srhb> liyang: Right. I'm not entirely sure I understand the consequences wrt. memory usage of doing all this.
02:31:48 <quicksilver> the warning should be there in both cases.
02:31:53 <bitonic> agreed ehe
02:33:36 <tdammers> shouldn't ghc even warn about non-record types being initialized with record syntax?
02:34:33 <liyang> srhb: if it's unpacked, the #type is stored directly in the constructor without an extra pointer indirection, so saves one word. The downside as it were, is that if you need to pass it to a function expecting a boxed value, you end up explicitly re-boxing it.
02:34:45 <srhb> Right.
02:34:54 <bitonic> tdammers: well yes, since if you are initialising a non-record with record syntax it‚Äôs always going to have unitialised fields
02:35:32 <tdammers> plus there really isn't anything meaningful you could put inside the {} in the first plaxce
02:35:38 <bitonic> tdammers: that‚Äôs what I meant
02:35:38 <tdammers> s/plaxce/place/
02:35:49 <liyang> Usually most primitive types are passed around unboxed though, so -funpack-strict-primitive-fields is a win. You might not want to do that for more complicated fields though.
02:35:51 <bitonic> tbh record syntax for ordinary data types is useful for pattern matching only
02:36:06 <liyang> (after GHC -O has had a go at it.)
02:45:10 <mcstar> presonally, id enforce initialization
02:45:25 <mcstar> i dont see the convenience in allowing it
02:45:31 <mcstar> can somebody shed light on this?
02:46:16 <mcstar> i think i only thought about this, when i had a big record, and i ended up writing a defaultRecord value
02:46:30 <mcstar> big record == many fields
02:46:45 <tdammers> I do the defaultRecord thing a lot
02:46:58 <mcstar> ah right, when i wanted to partially initialize it, in different functions
02:47:29 <mcstar> i.e it had some fields that had common values for different uses, and had fields, that needed different init values
02:47:44 <mcstar> but really, i dont think this is a good enough reason to allow non-initialization
02:47:53 <srhb> I tend to encapsulate that in different functions.
02:48:02 <srhb> Not that it really gets at the core problem.
02:48:21 <mcstar> srhb: but you need to initializa those fields too, that you would nevertheless change...
02:48:27 <mcstar> for the full initialization
02:48:40 <srhb> Yeah.
02:48:56 <mcstar> but thats ok, i think, no need to prostitute the language
02:57:03 <mm_freak> what is the core problem you people are talking about?
03:00:23 <tdammers> mm_freak: that you can leave a record type partially uninitialized, and then only use the initialized values, but this does yield a compiler warning
03:00:58 <mm_freak> so the core problem is:  "compiling without -W"
03:01:14 <mm_freak> i see a simple fix there:  add -W to your compiler command line
03:01:15 <mm_freak> ;)
03:01:28 <tdammers> data Foo = Foo { bar :: Int, baz :: Int }; main = do { let foo = Foo { bar = 23 }; print $ bar foo }
03:02:29 <tdammers> why is this problematic? the compiler should be able to figure out that the baz field is never accessed in this case
03:02:44 <mm_freak> tdammers: because there is a bottom
03:03:23 <mm_freak> you don't see it, because you don't write it, but it's no better than using "(x, undefined)" instead of "x"
03:03:51 <tdammers> hmm, yes, but the bottom can be guaranteed to never be hit
03:03:57 <tdammers> in this particular case at least
03:04:32 <mm_freak> can it?  perhaps when the data type is non-exported and values of it never leave the module, but it's dangerous to rely on that
03:05:08 <tdammers> more like the data flow is such that the incomplete record never leaves the module
03:05:19 <tdammers> but you're right, I see how it is hard to guarantee that
03:05:34 <tdammers> especially when taking things like MVars / IORefs into account
03:05:46 <mm_freak> you should see how you're forcing yourself to write nontotal code
03:06:02 <mm_freak> if you need only two values, don't use a 3-tuple
03:06:50 <tdammers> it would be practical though to have default initializers
03:06:55 <tdammers> something like
03:07:13 <tdammers> data Foo = Foo { bar = 23 :: Int, baz = 42 :: Int }
03:07:21 <tdammers> foo = Foo { bar = 1; }
03:07:31 <tdammers> -- which would evaluate to
03:07:39 <tdammers> Foo { bar = 1, baz = 42 }
03:08:17 <tdammers> right now, I write a defaultFoo whenever I want this, which adds considerable amounts of boilerplate
03:08:27 <tdammers> it works, and it's only a minor nuisance, but still
03:09:08 <mm_freak> apart from the syntactic difference i don't see much additional code‚Ä¶  in fact i like the clear separation between type definition and default value
03:09:24 <tdammers> point taken
03:09:46 <tdammers> the additional code lies in the fact that the defaultFoo definition duplicates all the field names
03:10:07 <tdammers> so I have two almost identical structures in the code, one to declare the fields with types, and one to define their default values
03:10:16 <mm_freak> this also gives you a useful tool:  if you fail to initialize all fields you get a warning‚Ä¶  if the type itself would provide default values the compiler couldn't help you to fully initialize a data structure
03:10:35 <mm_freak> in other words:  your coding style is only /one/ way to use records
03:22:51 * liyang wonders what happens when you RecordWildCards pattern match a non-record constructor.
04:12:12 <jfz_> is this hackage material? i don't want to add to the pollution there if i can help it: https://github.com/jfeltz/testsync (makes quickcheck tests a little less painful)
04:15:17 <cariveri> O
04:16:17 <cariveri> hello. can anyone help we undersand this little example code ? ->https://gist.github.com/sw17ch/2048516
04:18:35 <srhb> cariveri: What are you having trouble understanding?
04:21:05 <cariveri> srhb: well Name and Item are simply strings and I dont know how to get in a more comple type.
04:21:35 <cariveri> lets say Name has its own constructor.
04:21:40 <srhb> cariveri: Right
04:22:27 <srhb> cariveri: Either you'll end your do-blocks with return $ YourConstructor field1val field2val ...
04:23:04 <srhb> cariveri: Or you'll use an Applicative style and your parsers will start with YourConstructor <$> field1val <*> field2val <*> ...
04:23:27 <srhb> Where field1val in the latter example are actually the parsers for each field
04:23:33 <srhb> etc.
04:24:34 <cariveri> The first way I tried, and aMethods have a different return type.
04:25:27 <srhb> cariveri: Perhaps you should paste the code that's causing you troubles.
04:25:45 <cariveri> ok . one moment.
04:33:56 <cariveri> http://pastebin.com/RitLLPbt there it is.
04:34:00 <mauke> The paste RitLLPbt has been copied to http://hpaste.org/84249
04:35:28 <srhb> cariveri: It would be helpful if you remember to paste your errors, too
04:36:13 <cariveri> `ParsecT String () (State SourcePos) ArgComp' . actual [t0]
04:37:14 <srhb> cariveri: What do you think withBlock ArgComp aHeader [anArgComp] means?
04:39:19 <cariveri> srhb: I think it means Construct an ArgComp with a Header and there is an  indented content which gets pushed to a list of ArgComps. the aMethods should return a Parser, but I dont know how.
04:40:00 * hackagebot snap-app 0.3.1 - Simple modules for writing apps with Snap, abstracted from hpaste.  http://hackage.haskell.org/package/snap-app-0.3.1 (ChrisDone)
04:40:30 <srhb> cariveri: No, the third argument to withBlock is supposed to be a parser, but [anArgComp] is not a parser.
04:40:54 <cariveri> srhb: the demo code had [anItem] in there.
04:41:06 <srhb> No it didn't.
04:41:19 <srhb> b <- withBlock NamedList aName anItem
04:41:48 <cariveri> ah yes. it didnt.
04:45:50 <srhb> cariveri: All good now then?
04:51:26 <cariveri> No I think I had tried this too once. it compiles but the parsing does not work as it should . see now http://hpaste.org/84249
04:52:10 <cariveri> it only reads in the first toplevel line. the content is not filled.
04:54:01 <srhb> cariveri: What's your input?
04:54:13 <srhb> And what's your output?
04:54:40 <cariveri> see the comment block of http://hpaste.org/84249 thats is the input.
04:56:04 <srhb> anArgComp doesn't admit spaces after the header
04:56:15 <cariveri> I parsed: ArgComp (Header (A "Several")) []
04:56:30 <cariveri> ^ is output.
04:56:33 <srhb> You even have it commented out in aHeader
04:57:06 <cariveri> I have tried a lot
04:57:14 <srhb> Comment it back in.
04:57:25 <cariveri> sure.
04:58:13 <cariveri> no change.
04:58:32 <srhb> cariveri: You have headers that consist of multiple words
04:58:38 <srhb> but aHeader does not parse multiple words
05:00:15 <cariveri> ok thats one thing, but its not the main problem. I mean the list is just empty.
05:02:47 <supki> what's  withBlock ?
05:03:31 <srhb> supki: A parser from indents package
05:04:26 <isomorphic> is there a sensible way of using a value bound by <- in a where clause?
05:04:54 <supki> okay
05:04:59 <supki> r2 <- option [] (indented >> block p)
05:05:20 <supki> cariveri: if you get [] that means second parser failed
05:05:31 <supki> (without consuming any input)
05:06:57 <cariveri> supki: still I dont know why it failed. there is input.
05:07:27 <srhb> cariveri: Because of what I said.
05:09:54 <quicksilver> isomorphic: it's more natural to use let for that.
05:09:57 <markus3> hi! quick question: does using shared libraries help with compile-time of the main executable, and is it possible for cabal to compile only the shared libraries? I googled, but it gave some old threads on haskell-cafe..
05:10:17 <srhb> cariveri: It parses "Several" and then tries to parse an indented block, but the next thing available is 'w' -- not an indented block
05:10:30 <isomorphic> quicksilver: thanks.
05:13:25 <srhb> cariveri: That's not your only problem though.
05:13:39 <srhb> cariveri: Once you fix that, you have _ in the next header, which alphaNum does not parse, afaik
05:14:04 <cariveri> srhb: I see. I looking for a  s <- "line" alphaNum .
05:14:32 <srhb> cariveri: May I suggest simplifying your headers a bit while getting a working version
05:14:39 <srhb> cariveri: Then you can elaborate on your header parser later.
05:16:24 <srhb> cariveri: For instance, if you have aHeader = do { th <- string "T:"; s <- many1 alphaNum; spaces, return $ Header $ A s }
05:16:38 <srhb> cariveri: Just make sure your test file has no spaces (at all) in the headers
05:17:09 <srhb> cariveri: So they all go like T:OneWordOnlyAndNoSpaces
05:18:04 <cariveri> alright
05:18:13 <srhb> Now it should work.
05:19:02 <linduxed> what do you call the "foobar :: something" line?
05:19:12 <linduxed> signature or definition?
05:19:15 <srhb> linduxed: The type signature.
05:19:21 <linduxed> ok thx
05:23:19 <cariveri> srhb: yes it did. so I need to change many1 alphaNum to something that parses a line of arbitrary symbols, I guess.
05:23:27 <srhb> cariveri: Right
05:23:42 <hpaste> ‚ÄúAnonymous Coward‚Äù pasted ‚ÄúTest (annotation)‚Äù at http://hpaste.org/84252
05:24:12 <srhb> cariveri: you want something like do { th <- string "T:"; spaces; s <- manyUntil anyChar $ char '\n'; spaces; return . Header $ A s
05:24:14 <srhb> }
05:25:30 <srhb> Sorry, it's called manyTill
05:28:50 <srhb> cariveri: Also note that you're doing nothing to parse more than one top-level anArgComp
05:29:07 <srhb> cariveri: You might want to change the parser in the call of iParse to be (many anArgComp)
05:33:52 <cariveri> srhb: yes. I thought that would solved with another aMethod. aListArg or so.
05:34:09 <srhb> Up to you.
05:34:38 <srhb> Parsing into a list of top-level anArgComps is one solution. What you want is not for me to say. :)
05:36:26 <cariveri> ill try it.
05:38:07 <cariveri> srhb: you helped a great deal . thank you. (many anArg..) worked fine.
05:38:11 <jfz_> can anyone here get ghc-syb-utils-0.2.1.1 to install with  cabal 1.16.0.3 and ghc-7.4.2? i'm getting broken package errors on a fresh .cabal and .ghc
05:38:13 <srhb> cariveri: Sure thing. :)
05:39:33 <cariveri> I need to go now. have a good time all of you.
05:41:52 <isomorphic> hrmm-- I have a heap of setters that take eg: a string, or an int, and a configuration m, and then return a configuration m .    What's the right way to cascade them together?
05:43:02 <isomorphic> eg:  An example would be ByteString -> Config m a -> Config m a
05:43:36 <isomorphic> But there a few that I'd like to set together without repeatedly referring to the Config
05:44:28 <supki> @karma hrmm
05:44:28 <lambdabot> hrmm has a karma of -1
05:44:52 <supki> isomorphic: doesn't (.) work?
05:45:28 <supki> setFoo foo . setBar bar :: Config m a -> Config m a
05:45:36 <isomorphic> oh, as in ‚Ä¶  setter "string" . setting "otherstring" conf?
05:45:43 <supki> yes
05:45:46 <isomorphic> s/setting/setter
05:46:17 <isomorphic> Ah- Yes, I guess it would.. You know I looked around and found somebody using mconcat to do it
05:46:22 <isomorphic> but it looked awkward ;)
05:49:52 <isomorphic> Thanks :)
05:54:45 <kmels> hello, how can i avoid a lexical error at a line that starts with #if ? I'm trying to compile base:GHC.Enum.lhs with `ghc --make -fext-core`
05:55:10 <supki> isomorphic: well, if the list is really long something along the lines of  appEndo . foldMap Endo [setFoo foo, setBar bar, ...]  might look less awkward then chain of (.)s
05:55:18 <supki> I assume mconcat does something similar
05:57:20 <isomorphic> kmels - enable the C preprocessor, eg: -XCPP?
05:57:41 <isomorphic> supki: thanks :)
05:58:26 <beaky> hello
05:59:02 <kmels> isomorphic: thanks, that worked
06:01:06 <quchen> What's the idea behind a HashMap? Since two values can have the same hash, how does it make sure two distinct elements don't overwrite each other when inserted?
06:01:39 <RichyB> quchen: it has to use the Eq instance to disambiguate keys with equal hashes, same as any other hash table implementation.
06:02:15 <quchen> Oh right, it requires Eq, haven't seen that. I thought it was only Hashable.
06:02:51 <sclv> you can use a linked list of collisions, or an approach where you go to the next bucket, etc.
06:02:51 <sclv> there's a huge family of options
06:03:02 <quchen> So basically it's a normal tree structure ordered by hash values, and if a duplicate hash appears there's a subtree which is traversed using Eq?
06:03:17 <quchen> (Handwavy so I have something to picture)
06:06:26 <no-n> how could I rewrite a (b (c d) e) with $?
06:07:18 <srhb> no-n: You can't really.
06:07:23 <ziman> for a tree to be useful you need Ord; with Eq, a list will do
06:07:24 <no-n> ok
06:07:47 <srhb> flip b e $ c d
06:07:48 <t7`> a $ b (c d) e
06:07:49 <srhb> or something
06:08:14 <no-n> hehe
06:08:16 <srhb> Oh, I didn't notice the 'a'
06:08:19 <srhb> That helps.
06:08:57 <fizbin> a $ flip b e $ c d
06:09:08 <t7`> @unpl a (b (c d) e)
06:09:08 <lambdabot> a (b (c d) e)
06:09:37 <typoclass> fizbin: i'm not sure if that makes it clearer, compared to t7's solution
06:09:37 <fizbin> @unpl \a b c d e -> a (b (c d) e)
06:09:38 <lambdabot> \ a b c d e -> a (b (c d) e)
06:09:52 <srhb> typoclass: FEWER PARENS
06:10:04 <srhb> Obviously clearer! Also you can exploit that flip . flip . flip = flip
06:10:07 <srhb> For even more clarity.
06:15:02 <maltem> Just wondering, is there anything in the type system literature that somehow leverages the isomorphism between a and () -> a ? I feel like there should be a language where those types unify
06:15:52 <maltem> If this could be made to work somehow, then application and composition would be the same
06:16:11 <b_jonas> huh?
06:17:17 <maltem> I take that to mean that I'm not making sense?
06:19:12 <zachk> man this cabal update is taking forever...
06:20:36 <srhb> zachk: That was incredibly stupid of you. Now everyone started cabal update, flooding hackage to its knees. ;)
06:21:03 <srhb> (Just kidding) ;)
06:21:12 <maltem> zachk, as in `cabal update`? That shouldn't take forever
06:21:21 <dcoutts> maltem: there's lots of system where there are isomorphisms but don't make them transparent identities
06:21:59 <dcoutts> cabal update can be a bit slow, it's downloading ~5.5Mb
06:23:41 <maltem> dcoutts, I was just hoping that someone had worked out what happened if  a  and  () -> a  did unify (or if there's a compelling reason not to)
06:24:00 <quchen> srhb: flip.flip.flip = flip!?
06:24:16 <quchen> What is this magic!
06:24:28 <zaltekk> flipadelphia?
06:24:33 <srhb> quchen: Yes! And it's infinity% more compositional, so the former form should always be preferred.
06:24:49 <srhb> quchen: If you can get away with flip.flip.flip.flip.flip you should totally go for it.
06:25:07 <quchen> This reminds me of writing the inverse Fourier transformation as F.F.F
06:25:18 <quchen> Which you would totally not get away with ;-)
06:25:36 <srhb> Also, never use id when you can instead use an equal number of flips. Sadly this doesn't work for arguments that take less than two arguments themselves.
06:25:48 <srhb> :(
06:26:41 <quchen> So flip.flip is basically $ for binary functions
06:27:04 <quchen> ap2 = liftM2 (flip.flip)
06:27:05 <quchen> :D
06:27:12 <srhb> beautiful.
06:28:31 <maltem> dcoutts, it would be a paradise where function application was associative, and id, (.), ($) were all the same concept
06:28:47 <dcoutts> maltem: hmm, sounds confusing :-)
06:29:10 <maltem> no no, beautiful :-p
06:29:43 <FireFly> Sounds concatenative
06:29:44 <dcoutts> all you're saying is that () -> a  isn't really a function, but you still need functions a -> b
06:30:29 <quchen> srhb: Any other pearls like this?
06:30:46 <maltem> dcoutts, sure, it's functions all the way down
06:30:48 <quchen> I've also heard of "fmap fix return".
06:32:00 <maltem> FireFly, hm, that looks related indeed
06:34:11 <deech> Hi all, I'm working on a trying to make continuous compilation faster in ghc-mod by using deferred type errors. What is a good codebase that's currently slow to compile on Hackage to test the speed on?
06:35:18 <srhb> lens?
06:35:49 <maltem> FireFly, is Cat the only concatenative language with an interesting type system?
06:35:50 <deech> srhb: Cool, I'll try that to.
06:36:21 <FireFly> maltem: as far as I know, yup. But I'm certainly no expert on the topic
06:36:48 <deech> FireFly: Have you looked at StrongForth?
06:36:53 <maltem> deech, compile with profiling if you want it to use more resources
06:37:22 <deech> maltem: Good call, thanks!
06:39:04 <FireFly> deech: hm, nope, hadn't heard about it
06:41:42 <kurkale6ka> Hi, I don't understand the f g x part in here: http://bpaste.net/show/84510/ Form the type declaration, isn't comp supposed to take 2 functions as arguments? Why are we allowed to put the x to the left like this?
06:42:40 <maltem> kurkale6ka, from the type signature, comp takes indeed 3 arguments
06:42:42 <parcs> comp has 3 arguments
06:43:23 <tromp__> terrible name, comp
06:43:40 <tromp__> just write compose
06:44:59 <kurkale6ka> maltem: my bad :)
06:46:50 <supki> or c
06:47:23 <tromp__> or .
06:47:29 <parcs> f `o` g
06:47:36 <srhb> > '\n' == '\LF' -- always?
06:47:38 <lambdabot>   True
06:48:06 <maltem> See, guys? In my hypothetical language, kurkale6ka wouldn't have had that problem because composition would be the basic building block :)
06:48:49 <kurkale6ka> :) It's just a name used for . in https://www.fpcomplete.com/school/introduction-to-haskell/4-higher-order-programming-and-type-inference
06:48:51 <srhb> Or is it platform dependent?
06:50:45 <geekosaur> always, I believe
06:50:59 <Martty> like severus would say
06:51:28 <geekosaur> translation is done on iinput and output, haskell does not internally try to keep track of the platform newline convention
06:54:36 <geekosaur> hm, actually that's on;ly true for current haskell compilers; I don't tink the report requires it. but it also doesn't specify how platform newline might interact with escape sequences, so I guess if you want maximal portability with future compilers you can't assume that
06:58:47 <FireFly> maltem: http://evincarofautumn.blogspot.se/2012/02/why-concatenative-programming-matters.html might be of interest to you, by the way
07:00:10 <maltem> thanks, bookmarked for the moment
07:02:20 <johnw> does Haskell have rassoc lists, [(v,k)]?
07:03:23 <srhb> johnw: That's a strange question.
07:03:48 <johnw> yeah?
07:04:06 <srhb> Well.. Clearly you can construct a value of that type. I guess I'm just not getting what you mean by "Does Haskell have..."
07:04:17 <johnw> ah, I see
07:04:24 <johnw> right
07:04:38 <srhb> ie. map swap on an assoclist. :P
07:04:40 <johnw> i guess i mean, the Hackage-based ecosystem with Haskell as its core language
07:04:52 <johnw> yeah, that's what I did
07:04:58 <johnw> was just wondering if there as an rlookup, like Lisp has
07:05:01 <byorgey> johnw: I have never seen those used anywhere
07:05:08 <byorgey> there is not a standard rlookup.
07:07:02 <Cale> Association lists are frequently a source of inefficiency (but thankfully we have Data.Map which is easy to replace them with), if you need bidirectional lookup there's a bimap package
07:07:20 <johnw> ah, ok
07:07:22 <johnw> thanks!
07:07:24 <Cale> Or more fancily, stuff like IxSet
07:07:35 <Cale> bimap is just a pair of Data.Maps
07:07:47 <Cale> with appropriate functions for working with them
07:07:48 <srhb> bimap also has such an easy learning curve, just stick -R on anyfunction to make it work the other way around.
07:08:27 <Cale> Yeah, IxSet by contrast is a good deal steeper :)
07:14:22 <dannybtran>  morning all ‚Ä¶ i'm brand new to FP and Haskell ‚Ä¶ would love some critiques of my first program ‚Ä¶ tic tac toe!  https://github.com/dannybtran/haskell-tic-tac-toe/blob/master/ttt.hs
07:14:47 <quchen> What's that rlookup thing you're talking about?
07:14:56 <quchen> What's it used for?
07:15:11 <johnw> dannybtran: nicely done
07:15:21 <dannybtran> johnw: thx
07:15:24 <johnw> quchen: it looks up an assoc list member by its value
07:15:39 <dannybtran> i'm bummed the executable is 1.9MB lol ‚Ä¶ i guess that's cause Haskell is statically typed
07:15:43 <dannybtran> err
07:15:55 <dannybtran> statically linked
07:16:05 <Cale> dannybtran: Statically *linked*, yes :)
07:16:09 <johnw> dannybtran: it can support fully dynamic linking
07:16:38 <Cale> (it's just very few people who aren't haskell programmers have the libraries it would dynamically link against)
07:16:39 <quchen> johnw: Like Map k v -> v -> k?
07:16:58 <johnw> like [(k,v)] -> v -> (k,v)
07:17:26 <quchen> I see.
07:17:47 <quchen> That would probably be O(n) if you just bruteforced it onto Data.Map, right
07:22:02 <dannybtran> johnw: Cale: ‚Ä¶ ah I see
07:22:07 <ysulsky> Hi, is this a good place to request some code review?
07:23:05 <Cale> ysulsky: It's a decent place to try :)
07:23:18 <ysulsky> haha great, thanks.
07:23:27 <ysulsky> Here's the link: https://github.com/ysulsky/sexp-hs
07:23:41 <ysulsky> it's a port of ocaml's sexplib
07:23:46 <ysulsky> well a small part of it
07:24:11 <ysulsky> I'm just starting to learn Haskell, and I'd love to know what I can do better in that code
07:25:02 <Cale> Just a little layout thing, the usual way to lay out if/then/else if you break it across multiple lines is to align the 'then' and 'else' like:
07:25:03 <Cale> if foo
07:25:05 <Cale>    then bar
07:25:08 <Cale>    else quux
07:25:15 <Cale> So that it's symmetrical :)
07:25:32 <ysulsky> ah, perfect, thanks. I'll note that
07:26:23 <ysulsky> I know I'm probably using too many language extensions
07:27:10 <ysulsky> or is it common to use that many in one project?
07:27:17 <Cale> Another thing which you might like to look into is the ReadP library. This Read instance isn't *too* bad I suppose, but it can be nice to have a parser combinator library handy for writing those.
07:27:37 <Cale> That's a perfectly ordinary number of language extensions
07:28:29 <ysulsky> Great, i've never heard of ReadP
07:29:22 <Cale> It's interesting to see someone using DeriveGeneric, I don't know how many people are aware of that one :)
07:30:13 <ysulsky> Thanks, that's the result of learning Haskell via Google, I guess. You use some obscure feature but don't know how to format if statements
07:30:16 <ocharles> I need to spend some time learning about generics at some point
07:30:38 <ocharles> Generally the idea of doing things "generically" makes me scream because the result is usually a restrictive disaster
07:31:10 <ysulsky> ocharles: what do you mean by restrictive?
07:31:54 <ocharles> The generic solution is able to express less than writing something out by hand
07:32:09 <ocharles> that's my experience in doing things generically in other languages such as Perl
07:32:21 <Cale> ocharles: This is generics in the sense of providing a uniform representation of algebraic datastructures.
07:32:27 <ocharles> I know
07:32:41 <ocharles> but even that scares me, but irrationally - that's why I should look at it
07:32:46 <Cale> (so, useful for things like automatically constructing serialisations)
07:32:55 <ocharles> yea, that's exactly the thing that I've always seen go wrong :)
07:32:56 <hiptobecubic> i'm looking at http://www.haskell.org/haskellwiki/GHC.Generics but I don't understand the usefulness of the default type signature using the DefaultSignatures extension
07:33:35 <hiptobecubic> we say this "However, we cannot make putDefault the default implementation of the put method, because that would require adding the (Generic a, GSerialize (Rep a)) constraint to the class head. This would restrict the ability to give ad-hoc instances for types that are not representable, for instance.", but then we give a default implementation that uses it anyway, so how can anyone use this typeclass
07:33:37 <hiptobecubic> without satisfying it
07:33:53 <Cale> hiptobecubic: That says *if* there's an instance, you can use that default, without requiring every instance of the class to have those constraints.
07:33:55 <hpaste> a pasted ‚Äúaa‚Äù at http://hpaste.org/84261
07:34:49 <Cale> hiptobecubic: Ordinarily, in a default implementation inside a class declaration, you're not allowed to assume anything further about the type that the class is generalised over than what's implied by the superclass constraints.
07:35:05 <hiptobecubic> sure, which makes sense
07:35:24 <Cale> hiptobecubic: But adding Generic a and GSerialise (Rep a) to the superclass constraints of Serialize would be painful
07:35:32 <hiptobecubic> so you are making a default implementation for the subset of types which do satisfy some additional constraints?
07:35:35 <Cale> yeah
07:35:44 <hiptobecubic> I see
07:36:16 <hiptobecubic> can you also supply a default implementation the normal way? does the more specific one take priority then, i assume?
07:36:22 <hiptobecubic> well it must, i guess
07:36:55 <Cale> I forget if you're allowed more than one
07:37:14 <skp_> hello, I‚Äôm looking for a way to make an operator both prefix and postfix
07:37:27 <skp_> in order to simply `norm x` in `|x|`
07:37:31 <skp_> is it even possible?
07:37:39 <bitonic> skp_: there is no way to mae a prefix or postfix operator in haskell
07:37:48 <bitonic> the only definable operators are infix binary ones
07:37:52 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#class-default-signatures
07:38:09 <bitonic> skp_: there is one exception in the standard, the unary prefix `-'
07:38:15 <Cale> seems you can only have one
07:38:55 <bitonic> default signatures make for really confusing error messages.  I wished they had better reporting
07:39:38 <hiptobecubic> Cale, it doesn't actually say, but I assume you are correct.
07:40:13 <armlesshobo> where can i find how lists behave with (>>=)?
07:40:25 <johnw> a bit of syntactic sugar I wouldn't mind copying from C#: a type name T? is equivalent to Maybe T
07:40:27 <Cale> > [1,2,3] >>= \x -> [x, 10*x]
07:40:29 <lambdabot>   [1,10,2,20,3,30]
07:40:45 <Cale> armlesshobo: xs >>= f = concat (map f xs)
07:40:49 <hiptobecubic> @src [] (>>=)
07:40:49 <lambdabot> xs >>= f     = concatMap f xs
07:41:06 <armlesshobo> :O thank you :)
07:42:15 <Cale> > let f '*' = "* *"; f _ = "   " in "*" >>= f >>= f >>= f
07:42:16 <lambdabot>   "* *   * *         * *   * *"
07:42:41 <quchen> Is there some Lambdabot syntax reference? Every now and then someone uses a new command (or parameter) and I wonder how people come up with it.
07:42:47 <Cale> > let f '*' = "* *"; f _ = "   " in "*" >>= f >>= f >>= f >>= f
07:42:49 <lambdabot>   "* *   * *         * *   * *                           * *   * *         * ...
07:42:53 <Cale> aww
07:43:08 <bitonic> @help
07:43:08 <Cale> quchen: there's a slightly out of date one...
07:43:08 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:43:11 <Cale> @list
07:43:12 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:43:12 <bitonic> @list
07:43:12 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:43:26 <Cale> some of those modules are presently disabled
07:43:33 <bitonic> @help djinn
07:43:33 <lambdabot> djinn <type>.
07:43:33 <lambdabot> Generates Haskell code from a type.
07:43:33 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
07:43:43 <Cale> and I don't know if there are some which are missing from that list
07:43:59 <Cale> (I'd lean towards no)
07:44:11 <quchen> Cale: Problem is that list doesn't tell you what the commands do
07:44:12 <bitonic> @djinn Either a b -> (a -> c) -> (b -> c) -> c
07:44:12 <lambdabot> f a b c =
07:44:12 <lambdabot>     case a of
07:44:12 <lambdabot>     Left d -> b d
07:44:12 <lambdabot>     Right e -> c e
07:44:18 <bitonic> quchen: @help does
07:44:19 <Cale> @help djinn
07:44:20 <lambdabot> djinn <type>.
07:44:20 <lambdabot> Generates Haskell code from a type.
07:44:20 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
07:44:35 <quchen> How do I feed djinn's results to @pl?
07:44:35 <armlesshobo> is there an equivalent of @src in ghci?
07:44:38 <Cale> @djinn (a -> b -> c) -> b -> a -> c
07:44:38 <lambdabot> f a b c = a c b
07:44:40 <quchen> There's some @ trickery in there
07:44:45 <bitonic> quchen: @@
07:44:53 <quchen> Ah, I used @ only. Thanks
07:44:59 <bitonic> iirc anyway
07:45:07 <Cale> @. pl djinn (a -> b -> c) -> b -> a -> c
07:45:07 <lambdabot> f = flip
07:45:19 <bitonic> ok, clearly I don‚Äôt rc :P
07:45:25 <quchen> @@ @pl @djinn (a,b) -> a
07:45:26 <lambdabot>  f = fst
07:45:40 <bitonic> oh, it‚Äôs both of them
07:45:43 <quchen> What's the difference between @@ and @.?
07:45:43 <bitonic> @help get-shapr
07:45:43 <lambdabot> get-shapr. Summon shapr instantly
07:45:48 <bitonic> @get-shapr
07:45:48 <lambdabot> shapr!!
07:46:02 <danr> @get-bitonic
07:46:02 <quchen> This bot has power
07:46:02 <lambdabot> Unknown command, try @list
07:46:06 <danr> :(
07:46:08 <Cale> @yhjulwwiefzojcbxybbruweejw
07:46:08 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
07:46:21 <Cale> @keal
07:46:21 <lambdabot> making a bot of me is highly offensive
07:46:24 <bitonic> @protontorpedo
07:46:24 <lambdabot> can u build things fast in haskell?
07:46:29 <bitonic> aha.
07:46:40 <Cale> @keal
07:46:40 <lambdabot> someone needs to write a boids for haskell that emulates humans going on and off topic
07:46:44 <bitonic> @girl19
07:46:44 <lambdabot> is this a help channel for hackers-beginners?
07:46:51 <bitonic> SEXISM
07:47:04 <bitonic> R.I.P. vixen
07:47:05 <quchen> Nope, that's not how sexism works.
07:47:14 <Cale> I believe all of these are now actual quotes
07:47:30 <Cale> @palomer
07:47:31 <lambdabot> Hrmph
07:47:33 <Cale> lol
07:47:41 <Cale> I wonder what happened to palomer
07:47:45 <quchen> Great quote, thanks lambdabot
07:47:53 <bitonic> @fact
07:47:53 <lambdabot> I can not handle empty facts.
07:47:54 <Cale> and actually, many of the people from early #haskell days
07:47:58 <bitonic> @help fact
07:47:58 <lambdabot> fact <fact>, Retrieve a fact from the database
07:48:04 <bitonic> @fact obama
07:48:04 <lambdabot> I know nothing about obama
07:48:11 <quchen> @fact shapr
07:48:11 <lambdabot> I know nothing about shapr
07:48:11 <bitonic> thanks obama.
07:48:13 <Cale> @keal
07:48:13 <lambdabot> my proof show math is broken right now
07:48:25 <srhb> Woah. Those are good.
07:48:25 <bitonic> @fact potato
07:48:25 <lambdabot> I know nothing about potato
07:48:36 <quchen> @fact anything
07:48:36 <lambdabot> I know nothing about anything
07:48:38 <bitonic> @fact duck
07:48:38 <lambdabot> I know nothing about duck
07:48:39 <quchen> I knew it
07:48:41 <Cale> @keal
07:48:41 <lambdabot> can you make a macro that builds the expression accoridng to a genetic algorithm where you decide what is good and what is bad?
07:48:48 <bitonic> ehe
07:48:52 <bitonic> I like this keal guy
07:48:53 <srhb> keal is a gold-trove
07:48:55 <danr> @Cale
07:48:55 <lambdabot> Unknown command, try @list
07:48:55 <quchen> @fact haskell
07:48:56 <lambdabot> haskell: It's kewl.
07:49:02 <quchen> Finally!
07:49:05 <danr> @fact Cale
07:49:05 <lambdabot> I know nothing about cale
07:49:08 <aCube> Is there a better way to write this function (or does it have a name?): \f a b -> liftM2 f a b <|> a <|> b
07:49:08 <danr> :(
07:49:24 <bitonic> I have a couple of other user-specific @ in mind....
07:49:42 <Cale> aCube: I doubt you'll get much better than that.
07:49:47 <bitonic> @poll-show
07:49:47 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
07:49:49 <srhb> Isn't it the same as asking @quote name?
07:49:52 <bitonic> @help poll
07:49:52 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
07:50:01 <quchen> aCube: Use liftA2 instead and you won't need a monad
07:50:06 <Cale> srhb: what?
07:50:17 <bitonic> @help free
07:50:17 <lambdabot> free <ident>. Generate theorems for free
07:50:17 <johnw> @keal
07:50:18 <lambdabot> ithink has to do with hardcased government failsafe in chip
07:50:19 <srhb> Cale: Is @keal the same as @quote keal?
07:50:22 <aCube> how would one call this function? Because I'm needing it frequently
07:50:23 <Cale> It's not
07:50:25 <srhb> Ah.
07:50:34 <bitonic> @free map id = id
07:50:34 <lambdabot> Extra stuff at end of line
07:50:34 <quchen> If so I'd call myself "pl" :-D
07:50:38 <bitonic> @free map
07:50:40 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
07:50:50 <bitonic> uhm.
07:50:55 <Cale> aCube: I don't know what you'd call it, it's your function :)
07:51:00 <bitonic> @free mappend
07:51:02 <lambdabot> Extra stuff at end of line in retrieved type "Monoid a => a -> a -> a\n"
07:51:02 <aCube> :D
07:51:21 <bitonic> @free const
07:51:22 <lambdabot> f . const x = const (f x) . g
07:51:25 <bitonic> @free id
07:51:26 <lambdabot> f . id = id . f
07:51:29 <bitonic> this is fun
07:51:35 <danr> @free (.)
07:51:35 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:21-35
07:51:35 <johnw> @pl \f a b -> liftM2 f a b <|> a <|> b
07:51:36 <lambdabot> flip flip id . (liftM2 (<|>) .) . join . ((flip . ((<|>) .)) .) . liftM2
07:51:37 <Cale> @free map
07:51:38 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
07:51:49 <Cale> @free foldr
07:51:51 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
07:52:04 <bitonic> @free scanl
07:52:05 <lambdabot> (forall x. f . h x = k (f x) . g) => $map f . scanl h y = scanl k (f y) . $map g
07:52:08 <Cale> (It computes these from the types)
07:52:11 <bitonic> yeah
07:52:16 <bitonic> parametricity ftw
07:52:33 <aCube> @help pl
07:52:33 <lambdabot> pointless <expr>. Play with pointfree code.
07:52:42 <hiptobecubic> @free reverse
07:52:44 <lambdabot> $map f . reverse = reverse . $map f
07:52:45 <aCube> Is there pl_step or soemthing?
07:52:53 <hiptobecubic> aCube, would be nice
07:53:02 <Cale> @free \f g x -> f (g x)
07:53:02 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:21-35
07:53:02 <bitonic> of course this is all about magical Haskell without bottom and strictness annotations
07:53:06 <danr> aCube: if you install it as a command-line executable you can see the trace
07:53:08 <quchen> Would also spam the channel to oblivion
07:53:17 <danr> cabal install pointless
07:53:22 <danr> or uhm pl maybe
07:53:29 <danr> pointfree :D
07:53:42 <aCube> thx
07:53:43 <Cale> @protontorpedo
07:53:43 <lambdabot> The things I dotn get about relatinal databases is that they take wrok to maintain
07:53:48 <bitonic> aha
07:54:42 <aCube> @pl_resume \f a b = liftA2 f a b <|> a <|> b
07:54:43 <lambdabot> pointless: sorry, nothing to resume.
07:54:45 <Cale> protontorpedo was this guy who spent all his time asking about what he should learn instead of learning anything, for months on end. It's probable that he was just trolling the entire time.
07:54:59 <aCube> @help pl_resume
07:54:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:55:00 <bitonic> you can never be sure with those people
07:55:04 <Cale> (But maybe not, it was an excellent troll if it was a troll)
07:55:41 <bitonic> Cale: so did he just disappear one day?
07:55:47 <Cale> I think so
07:56:09 <quchen> What other funny frequenters were there? A couple of days back there was this guy coming here to complain about haskell
07:56:12 <Cale> I don't think he was banned, but it's possible that dons or someone had finally had enough of him :)
07:56:17 <quchen> Turns out it's a poor choice of a place to do so
07:57:01 <Cale> @palomer
07:57:01 <lambdabot> Category theory is the Paris Hilton of mathematics
07:57:09 <ClaudiusMaximus> some output from my recent haskell experiments making noise with genetic algorithms http://mathr.co.uk/misc/2013-03-18_bitbreeder.mkv (20MB)
07:57:20 <bitonic> @yarr
07:57:20 <lambdabot> Shiver me timbers!
07:57:23 <Cale> Palomer was an actual Haskell user, he was just frequently grouchy :)
07:57:31 <bitonic> @b52s
07:57:31 <lambdabot> You belong in Ripley's Believe It Or Not
07:57:36 <ziman> wow, does anybody have a clue what he meant with that? (re palomer)
07:57:37 <bitonic> lol
07:57:44 <srhb> ziman: Yeah.
07:57:46 <Cale> ziman: Shallow
07:57:50 <bitonic> ziman: vain
07:58:02 <Cale> haha
07:58:26 <Hafydd> What is Paris Hilton being considered as? A human being?
07:58:30 <bitonic> ziman: undeserving the attention it gets
07:59:06 <hiptobecubic> Exremely famous and valuable?
07:59:11 <Cale> The criticism is funny because there's a hint of truth to it, but it's pretty unfair if you take it too seriously. :)
07:59:27 <quchen> Does she still exist? I should watch more MTV instead of SPJ
07:59:36 <bitonic> ziman: porn to boost career
07:59:46 <hiptobecubic> Has had millions of people arouse themselves over it?
07:59:48 <bitonic> it‚Äôs quite fitting actually
07:59:51 <osfameron> there is a category theory sex-tape?
08:00:11 <johnw> I think this conversation is better taken to #haskell-blah...
08:00:17 <Cale> osfameron: http://www.youtube.com/thecatsters
08:00:20 <bitonic> osfameron: oh man, those underground catster videos
08:00:24 <bitonic> Cale: !!
08:00:53 <bitonic> yeah johnw might be right :P
08:02:03 <quchen> Fun fact: every time someone directs a conversation to #haskell-blah, it doesn't move - it just dies, including this comment
08:02:38 <Cale> ClaudiusMaximus: is the video supposed to be mostly-grey, or is there something wrong with my video player?
08:02:47 <bitonic> quchen: I have assisted to successful transfers in my lifetime.
08:02:55 <ziman> i'd have various adjectives for CT but "shallow" is definitely not among them :) might be a bit funny if you take it ironically but it doesn't fit well either (usually jokes have side matches to the actual thing)
08:03:11 <bitonic> to that I say
08:03:13 <bitonic> @palomer
08:03:13 <ClaudiusMaximus> Cale: it's colourful here
08:03:13 <lambdabot> Learning vim is pointless
08:03:17 <Cale> ziman: Well, it's forced to be shallow through abstraction
08:03:32 <ClaudiusMaximus> Cale: with glyphs in a sort of treee
08:04:11 <Cale> ziman: You tend not to be able to prove really specific things about particular categories from a strictly categorical perspective (or else it's often quite challenging)
08:04:25 <johnw> CT is fun when Cale draws string diagrams online while you watch :)
08:04:27 <Cale> ClaudiusMaximus: okay, my video decoder is broken
08:04:33 <Cale> :)
08:04:48 <ClaudiusMaximus> Cale: someone else had a problem with it "being blank", so it might be something i did when encoding it (was just "avconv -i images -i audio -shortest output.mkv", on wheezy with deb-multimedia)
08:06:09 <ClaudiusMaximus> Cale: here's a screenshot http://mathr.co.uk/misc/2013-03-18_bitbreeder.png
08:06:48 <johnw> ClaudiusMaximus: that's cool!
08:07:21 <ClaudiusMaximus> johnw: :) thanks
08:07:52 <Cale> Yeah, it doesn't look like that at all here ;)
08:07:56 <ziman> Cale, I've had just an introductory course on CT but it appeared to me that there are lots of deep things you could study on the categorical level itself (even when not considering what specifics they translate to in various applications of CT)
08:08:01 <Cale> and the audio is somewhat challenging to listen to
08:08:11 <Cale> ziman: Yeah
08:08:26 <Cale> ziman: That's a much saner and more reasonable perspective to take
08:08:32 <johnw> ziman: i keep studying functors, and they keep behaving like a carrot on a stick.  it seems like there is always more subtlety to them
08:08:49 <Cale> But people had really high expectations of category theory when it got started
08:10:01 <srhb> Cale: I'm glad you gave me that warning.
08:10:04 <srhb> Cale: Nearly blasted out my speakers anyway.
08:10:18 <ClaudiusMaximus> srhb, Cale: i did say "noise"...
08:10:53 <Cale> ClaudiusMaximus: I'm not confident that we're hearing the same things, given what's happened to the video though :)
08:11:14 <srhb> I actually didn't assume it was audio noise
08:11:21 <srhb> So it's noise that results from the corresponding picture?
08:12:06 <srhb> Cale: fwiw it's click click click click BEEEEEEEEeEEEEeEEEEEE
08:12:51 <Cale> haha, more or less, yeah
08:13:09 <ClaudiusMaximus> srhb: yep, the displayed expression is what makes the sound at that time
08:13:17 <srhb> ClaudiusMaximus: Right. :)
08:13:26 <srhb> Then I believe it works for me. With colors and everything.
08:13:31 <Cale> ah, okay, so that part is intentional then :)
08:13:34 <quchen> Did someone say noise? http://youtu.be/QPEbjXzg5RU
08:14:06 <srhb> quchen: /kickban
08:17:53 <Cale> http://www.youtube.com/watch?v=A6Mti91l2Sc
08:19:55 <srhb> is '\LF' == '\n' always?
08:21:53 <hiptobecubic> srhb, apparently
08:22:12 <Cale> > '\LF' == '\n'
08:22:12 <srhb> I was wondering if \n might be platform dependent.
08:22:13 <lambdabot>   True
08:22:35 <Cale> srhb: The platform dependent handling of '\n' happens on the IO side of things
08:22:38 <hiptobecubic> srhb, the io libraries should handle that.
08:22:41 <srhb> Alright :)
08:24:57 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#g:25
08:35:13 <maltem> ziman, my impression is rather that CT gets really illuminating only if one considers various specifics it translates to. Just as any rich mathematical theory, really. Trouble is, those ìapplicationsî are very hard to teach
08:41:55 <Philippa> maltem: sort of. Conceptual Mathematics is a pretty illuminating book if you're coming from an angle that doesn't involve a degree in maths
08:43:10 <skp_> hi
08:43:27 <skp_> I have an issue with some experimental code I‚Äôm writting
08:43:56 <skp_> https://gist.github.com/skypers/5188099
08:44:02 <skp_> line 21
08:44:08 <skp_> I can‚Äôt do that
08:44:16 <skp_> but I don‚Äôt really understand why
08:44:26 <skp_> a is both Num and Floating
08:44:31 <skp_> so why can‚Äôt I do such a thing?
08:45:05 <skp_> I‚Äôm gonna try an instance like
08:45:11 <skp_> instance NumVec Vec2 Int
08:45:13 <Philippa> what error message do you get?
08:45:39 <skp_> Philippa: I added a comment to the gist for error messages
08:46:23 <Jaak> probably something to do with polymorphic return type of dim?
08:46:34 <skp_> if I make an instance with Int
08:46:36 <skp_> and
08:46:37 <skp_> norm (Vec2 x y) = sqrt $ fromIntegral $ x*x + y*y
08:46:39 <skp_> it compiles
08:47:03 <Jaak> yeah, your current implementation associates a and d
08:47:17 <monoidal> skp_: norm :: v a -> b means that for any a b your norm function must work
08:47:34 <monoidal> skp_: if you change it to norm :: v a -> a it will compile
08:47:59 <skp_> ok but it‚Äôs not what I want!
08:48:03 <skp_> norm (Vec2 x y) = sqrt $ fromIntegral $ x*x + y*y
08:48:03 <skp_> here
08:48:08 <skp_> a :: Int
08:48:21 <skp_> but norm returns Floating constrainted value
08:48:48 <Jaak> if you want that then you have to use fromIntegral to remove association between input and return types
08:49:01 <Jaak> or something akin to fromIntegral
08:49:18 <monoidal> skp_: you need the Integral constraint to use fromIntegral
08:49:33 <skp_> monoidal: hm I know
08:49:37 <skp_> how could I say that
08:49:45 <skp_> instance (Floating a) => NumVec Vec2 a where
08:49:52 <skp_> I fail to write that instance
08:49:53 <skp_> but
08:50:00 <skp_> instance NumVec Vec2 Int where
08:50:01 <skp_> that one
08:50:06 <skp_> I succeeded
08:50:14 <skp_> because here it‚Äôs trivial
08:50:25 <skp_> hm
08:50:36 <skp_> I could simply write an instance for a :: Float
08:50:38 <skp_> a :: Double
08:50:40 <skp_> and so on
08:50:49 <skp_> but it would be painful don‚Äôt you think?
08:51:15 <skp_> well
08:51:18 <skp_> if you have any idea
08:51:28 <monoidal> skp_: sqrt returns the same type as it gets (it's Floating a => a -> a)
08:51:38 <skp_> I know
08:51:43 <skp_> that‚Äôs why I used fromIntegral
08:51:51 <skp_> haven‚Äôt you read the gist?
08:53:04 <skp_> h√ß
08:53:08 <skp_> weird
08:53:11 <skp_> it worked with Int
08:53:15 <skp_> but not with Float
08:54:16 <skp_> fuck
08:54:20 <skp_> I can‚Äôt understand
08:54:35 <skp_> it works with realToFrac $ x*x + y*y
08:54:40 <skp_> it doesn‚Äôt make any sense
08:55:01 <skp_> since x and y are already Floating (Float is)
08:55:10 <skp_> maybe it‚Äôs because there‚Äôre stricts?
08:55:23 <skp_> data Vec2 a = Vec2 !a !a
08:55:25 <skp_> ?
08:55:30 <monoidal> skp_: no, strictness does not change here anything. you have a type error
08:55:35 <alpounet> non that doesn't affect type checking
08:55:39 <alpounet> no*
08:56:05 <skp_> sqrt expects a Floating value
08:56:07 <skp_> Float is
08:56:18 <skp_> it fails although
08:56:42 <skp_> if I feed the realToFrac function with the Float, it‚Äôs ok
08:56:44 <skp_> wait, wat?
08:58:04 <skp__> timeouted, what were you saying?
08:59:06 <skp__> alpounet: ?
08:59:33 <amyers> skp__: alpounet was saying that strictness annotations (!) don't affect type checking.
08:59:57 <skp__> yes I read that
08:59:58 <alpounet> skp__, your problem is that sqrt returns an 'a' here, since x and y's type is 'a'. Now, you have to put there some function that can do: (Floating a, Floating b) => a -> b
09:00:13 <skp__> ah
09:00:14 <skp__> I see
09:00:19 <skp__> even if for me
09:00:27 <skp__> a and b or both Floating
09:00:30 <skp__> for GHC type system
09:00:36 <skp__> it‚Äôs different though
09:00:37 <alpounet> since you want to result type to vary independently from the input type
09:00:54 <alpounet> Floating isn' a type
09:00:57 <alpounet> it's a typeclasss
09:01:01 <alpounet> -s
09:01:11 <skp__> yes I meant Floating type
09:01:14 <skp__> (Float here)
09:01:28 <quicksilver> a and b are both *some* floating type
09:01:34 <quicksilver> but not necesarily the same one.
09:01:42 <monochrom> a could be Float, b could be CReal
09:01:43 <quicksilver> one might be Float and one might be Double, for example.
09:01:51 <skp__> it‚Äôs still confusing
09:02:03 <skp__> because if I force the instance with Float
09:02:04 <monochrom> all confusions are caused by wrong assumptions
09:02:05 <skp__> a is Float
09:02:12 <skp__> and b is Floating
09:02:13 <skp__> oh
09:02:14 <skp__> I see
09:02:15 <skp__> :D
09:02:25 <skp__> b could be Double
09:02:28 <skp__> I see ahah
09:02:35 <skp__> thank you
09:02:43 <skp__> I‚Äôma fix that
09:02:48 <Jaak> i'd imagine you'd have much easier time if you picked the result of the norm to be Double
09:03:06 <skp__> why?
09:03:11 <alpounet> or, worst case, just 'a'
09:03:32 <monochrom> I would just make it "norm :: v a -> a". why have a different type.
09:03:43 <monochrom> (rhetorical question!)
09:03:44 <Jaak> norm usually maps to reals
09:03:54 <monochrom> I see
09:04:13 <Jaak> and Double is pretty good approximation of reals
09:04:14 <alpounet> Jaak, yeah but those have different representations on computers
09:04:32 <skp__> alpounet: because Vectors of Int are not uncommon in gl applications
09:04:38 <arkeet> Double isn't very good at all.
09:04:41 <skp__> and sqrt will fail on that
09:04:41 <arkeet> it's not even infinite!
09:04:51 <Jaak> *approximation*
09:04:51 <skp__> arkeet: but Real is?
09:04:58 <tac> Jaak: FSVO "pretty good"
09:05:03 <arkeet> what's Real?
09:05:17 <alpounet> skp__, yeah I supposed so
09:05:30 <skp__> I always thought haskell has a type called Real
09:05:32 <monoidal> Real is a class with Float, Double, Int, Integer
09:05:34 <skp__> like in D language
09:05:34 <arkeet> since when?
09:05:39 <Jaak> is "pretty useful" better?
09:05:41 <skp__> oh it‚Äôs a class
09:05:43 <monoidal> skp__: you *really* need to distinguish types and typeclasses
09:05:43 <skp__> ok nvm then
09:05:46 <arkeet> :k Real
09:05:47 <lambdabot> * -> Constraint
09:05:54 <skp__> it‚Äôs much better imho
09:06:16 <skp__> cause those vectors will be mapped between client and server GPU memory
09:06:28 <skp__> which often gathers Float data
09:06:33 <skp__> or Double
09:06:41 <skp__> regarding the shader stages inputs
09:06:49 <skp__> stages‚Äô
09:07:43 <skp__>  
09:07:51 <monochrom> don't generalize prematurely
09:08:15 <skp__> I do write GLSL applications
09:08:27 <skp__> and float are ‚Äì for common applications ‚Äì large enough
09:12:44 <simpson> skp__: So, uh, have you seen the linear package?
09:12:56 <simpson> And types like V2? http://hackage.haskell.org/packages/archive/linear/0.6.1/doc/html/Linear-V2.html
09:13:10 <simpson> I've been doing GL stuff with this and it works great.
09:24:26 <trescenzi> Ok so maybe this is a stupid question: Is there any way to do something then take that result and do something else with it outside of a monad in Haskell
09:25:06 <arkeet> :t fmap
09:25:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:25:19 <Philippa> somethingElse (something)
09:25:23 <arkeet> heh
09:25:30 <trescenzi> Yea I should be a bit more specific
09:25:35 <Philippa> but also what arkeet just showed you
09:25:37 <trescenzi> I want to avoid left hand recursion
09:26:02 <trescenzi> but yea fmap works i guess
09:28:59 <trescenzi> I guess my real hope was to not have to box any types with functors or monads
09:29:48 <otters> let b = f a in g b
09:29:48 <Philippa> once you're using a monad, you're using a monad. But you can have as many islands of purity inside it as you like
09:32:24 <trescenzi> are there any good tutorials you can recommend on how to actually "make your own" monad
09:32:50 <srhb> You could have invented monads, perhaps? It's really about the standard monads, but once you get that pattern, you're pretty much set.
09:33:35 <Philippa> trescenzi: the technique I always like but fail to write up properly is to write it as an interpreter first
09:33:53 <Philippa> build an AST for the "monad language" using a GADT, write a runMonad function - and then fuse the two together
09:34:07 <srhb> I'd love to see that written up properly :D
09:34:20 <Philippa> mmm. I did give a talk on it at one AngloHaskell
09:34:24 <trescenzi> huh that's interesting
09:34:45 <trescenzi> what I'm working on right now actually is a recursive descent parser
09:35:01 <Philippa> http://flippac.org/talks/Fusion.pdf
09:35:17 <Philippa> can't remember how good the slides are, it's been a while
09:35:25 <trescenzi> I think I'm just confused as to what exactly the Monad m => really does
09:35:36 <otters> it means m is a Monad
09:35:41 <trescenzi> yea sorry
09:35:41 <srhb> It constrains the type m to one that has an instance for Monad.
09:35:59 <trescenzi> I get that but what it does to the type it boxes
09:36:07 <Philippa> it says "whatever m is, I'm going to get the proof it's a Monad and that you can do Monad things with it"
09:36:16 <trescenzi> so it forces it to have an instance for a monad?
09:36:32 <Philippa> you're going to get passed a "dictionary" which contains the class's methods for that particular type
09:36:33 <Philippa> right
09:36:44 <trescenzi> ok
09:37:25 <trescenzi> and that means the type must have at least return and >>=?
09:38:10 <monochrom> I think "box" is a misunderstanding
09:38:11 <srhb> trescenzi: You can query ghci about what functions that are of consequence by saying :i Monad
09:38:26 <Philippa> trescenzi: yes, you'll get return and >>=
09:38:28 <srhb> (Though some may have default implementations)
09:41:21 <Philippa> trescenzi: there's an old paper by Wadler explaining type classes as once were and the dictionary passing transformation that you might find useful
09:41:54 <EarlGray^> Hello
09:42:01 <trescenzi> hmm ok I'll have to check it out
09:42:01 <srhb> EarlGray^: Hello.
09:42:28 <EarlGray^> I am trying to do some array operations and I can't wrap my mind about multiple class parameters
09:42:50 <trescenzi> so if I'm getting errors along the lines of m10 is too general that means I need to specify the actual implementation of the monad functions?
09:43:29 <EarlGray^> for example, I am trying to write a function rndArray :: (IArray a e) => Int -> IO (a Int e)
09:43:59 <srhb> EarlGray^: I don't remember IArray. What are the constraints on a?
09:44:31 <srhb> I don't remember it having kind  * -> * -> * -- isn't that what your code is saying? (I may be completely wrong here and someone will hopefully correct me)
09:44:42 <elliott> that's what IArray looks like
09:44:45 <elliott> @hoogle listArray
09:44:45 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
09:44:45 <lambdabot> Data.Array listArray :: Ix i => (i, i) -> [e] -> Array i e
09:44:45 <lambdabot> Data.Array.MArray newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
09:44:50 <elliott> "a" is the array type
09:44:55 <EarlGray^> I use a function rndList :: Int -> IO [Int] , which uses randomRIO and fetch its output to Data.Array.array
09:45:19 <srhb> HOw does a Int e make sense then?
09:45:24 <EarlGray^> and since rndList has already defined type, I have to specify that e is Int in the IArray constraints
09:45:39 <EarlGray^> But I can't put Int instead of e
09:45:57 <monoidal> EarlGray^: you want an array of integers?
09:46:09 <EarlGray^> yep, a random array of integers
09:46:48 <armlesshobo> liftM (++ ", in bed.") getLine -- fortune cookie joke
09:47:04 <monochrom> perhaps don't generalize prematurely. don't use the IArray type class first. use concretely Array (from Data.Array)
09:47:09 <monoidal> EarlGray&: why you can't put Int instead of e?
09:47:56 <EarlGray^>  Non type-variable argument in the constraint: IArray a Int
09:47:58 <EarlGray^>     (Use -XFlexibleContexts to permit this)
09:48:01 <monochrom> rndArray :: Int -> Array Int Int
09:48:09 <EarlGray^> Is the extention required here?
09:48:19 <monoidal> EarlGray^: yes, and it's harmless
09:49:11 <EarlGray^> Ok, I'll use the extension
09:50:04 <EarlGray^> It's one of my first efforts to do something with arrays and I try to avoid extensions for irrational reasons
09:50:08 * hackagebot HGamer3D-CEGUI-Binding 0.2.1 - Windows Game Engine for the Haskell Programmer - CEGUI Bindings  http://hackage.haskell.org/package/HGamer3D-CEGUI-Binding-0.2.1 (PeterAlthainz)
09:50:10 * hackagebot HGamer3D-Bullet-Binding 0.2.1 - Windows Game Engine for the Haskell Programmer - Bullet Bindings  http://hackage.haskell.org/package/HGamer3D-Bullet-Binding-0.2.1 (PeterAlthainz)
09:50:12 * hackagebot HGamer3D-Ogre-Binding 0.2.1 - Windows Game Engine for the Haskell Programmer - Ogre Bindings  http://hackage.haskell.org/package/HGamer3D-Ogre-Binding-0.2.1 (PeterAlthainz)
09:50:14 * hackagebot HGamer3D 0.2.1 - Windows Game Engine for the Haskell Programmer  http://hackage.haskell.org/package/HGamer3D-0.2.1 (PeterAlthainz)
09:50:51 <johnw> if there's a library for ogres, what about other monsters?
09:51:21 <srhb> johnw: Ogres are extremely polymorphic.
09:51:38 <johnw> then it should be HGamer3D-Shapeshifter-Binding
09:51:53 <srhb> :)
09:53:08 <monochrom> or HGamer3D-IOgres-Binding
09:54:51 <th0gz19_>  a
09:54:54 <Swineflu> is there away to use maximum with tuples?
09:55:19 <sipa> :t maximum
09:55:20 <lambdabot> Ord a => [a] -> a
09:55:26 <monochrom> yes
09:55:45 <johnw> maximum (map fst tuples)
09:56:01 <ocharles> :t map fst
09:56:02 <sipa> Swineflu: if you have a list of tuples, maximum will select the lexicographically-ordered highest of them
09:56:03 <lambdabot> [(b, b1)] -> [b]
09:56:17 <sipa> > maximum [(1,2,3),(2,1,3),(3,2,1)]
09:56:18 <lambdabot>   (3,2,1)
09:56:32 <johnw> sipa: interesting, did not know that
09:56:52 <ocharles> I actually guessing Swineflu wants something  :: (a, b, c, d, e, etc) -> a | b | c | d
09:56:54 <sipa> johnw: Ord on tuples sorts lexicographicallyu
09:57:01 <johnw> ah
09:57:10 <johnw> didn't know tuples had an Ord instance
09:57:17 <ocharles> Swineflu: do you have a list of tuples, or do you want the maximum element in a single tuple?
09:57:26 <Swineflu> a single tuple
09:57:51 <ocharles> then it becomes a bit more difficult :)
09:57:54 <Swineflu> ;(
09:57:57 <sipa> Swineflu: that makes no sense, as there is not even a requirement that all elements in the tuple have the same type
09:58:01 <ocharles> are the elements of the tuple different types, or all the same type?
09:58:16 <Swineflu> All the same type (int)
09:58:40 <Swineflu> Its a homework task so i dont want a answer was just wondering if there was something maximum
09:58:47 <Swineflu> Since it seems to work in python
09:58:59 <ocharles> python treats tuples as lists, you don't get that same freedom in haskell
09:59:35 <ocharles> it *can* be done, but folding a homogeneous tuple is not simple - so I suggest just writing as single function for your specific tuple
09:59:43 <trescenzi> do you know the size of the tuple?
09:59:47 <Swineflu> I'm just going to have to pull the vars out in to a list and use max
09:59:52 <Swineflu> Yeah its a 3-tuple
10:00:00 <Swineflu> I think i can do it with max and a boolen or
10:00:08 <trescenzi> then you could easily write your own max
10:04:43 <monoidal> Swineflu: unzip3 + maximum + zip3?
10:05:03 <monoidal> Swineflu: or that's not what you need?
10:05:22 <trescenzi> Swineflu: this is a way to do it if you know you have a three tupple max' (x,y,z) = maximum (x:y:z:[])
10:06:09 <danr> maximum [x,y,z]
10:06:18 <trescenzi> that too lol
10:07:26 <Swineflu> Thats what I have pretty much :p
10:07:40 <Swineflu> I wanna do it without turning it in to a list since we get marks for elegance
10:08:04 <trescenzi> that's pretty damn elegant if I may say so
10:08:12 <trescenzi> especially if you just do it as [x,y,z]
10:08:30 <Swineflu> Thats what I have
10:08:30 <Swineflu> idk if thats what the professor wants though :(
10:08:30 <c_wraith> on the other hand, you could go with max (max x y) z
10:08:45 <danr> hard to say what's more elegant :)
10:08:52 <c_wraith> I can't say which is better
10:08:55 <danr> I'd go for the list
10:09:11 <Swineflu> hmm
10:09:13 <monoidal> x `max` y `max` z
10:09:23 <Swineflu> what is `
10:09:47 <eacameron> is there a wrapper for haskell's threads to do some of the basic sync stuff for you (like interrupting, terminating/ etc.)?
10:09:50 <geekosaur> allows you to use a function as an infix operator
10:09:57 <monoidal> Swineflu: "a `f` b" is the same as "f a b", you can use a function as an infix operator
10:10:05 <geekosaur> similarly wrapping an operator in parens makes it a prefix function.
10:10:11 <c_wraith> eacameron: have you checked out the async package?
10:10:11 <geekosaur> (no, you can't nest them, though)
10:10:27 <eacameron> c_wraith: no, I'll look
10:11:15 <c_wraith> eacameron: it's one of Simon Marlow's projects, so it's likely to be mostly-correct. The only question is if it actually works for you.
10:11:23 <c_wraith> For your use case, that is
10:13:05 <trescenzi> Any thoughts on the best implementation of a hashtable? There are a few standard ones right?
10:13:58 <EarlGray^> My second array beginner question: I want to write a stub for array sort like bubblesort :: Ord e => Array Int e -> Array Int e
10:14:14 <ion> @hackage unordered-containers  -- trescenzi
10:14:14 <lambdabot> http://hackage.haskell.org/package/unordered-containers  -- trescenzi
10:14:36 <trescenzi> thanks ion
10:14:39 <EarlGray^> And first of all I want to operate on a mutable array inside, I am trying to compile this:
10:14:44 <latro`a> hm, I have a function sort of like: f :: (Fractional r,Ord r,Num e,Ord e) =
10:14:47 <latro`a> gah, typo
10:14:59 <latro`a> (didn't mean to hit enter that early)
10:15:02 <EarlGray^> bubblesort a = thaw a >>= freeze
10:15:09 <EarlGray^> bubblesort a = runST $ thaw a >>= freeze
10:15:09 <alpounet> trescenzi, there's the "hashtables" package and a HashMap module or two in 'unordered-containers'
10:15:12 <latro`a> hm, I have a function sort of like: f :: (Fractional r,Ord r,Num e,Ord e) => r -> e -> r
10:15:23 <latro`a> which seems to compare its first two arguments (not exactly, somewhat more involved than that)
10:15:27 <latro`a> it shouldn't be able to do that, should it?
10:16:30 <EarlGray^> and I get an error: freeze must receive (MArray a i ST), but it gets (MArray a i (ST s))
10:16:30 <c_wraith> EarlGray^: that won't quite work because the type signatures of thaw and freeze are too general. You'll need to specify the type of the intermediate value
10:17:03 <geekosaur> :t fromRational
10:17:05 <lambdabot> Fractional a => Rational -> a
10:17:18 <geekosaur> hm, no, wrong direction
10:18:39 <hpaste> ‚ÄúAnonymous Coward‚Äù pasted ‚Äúr==e???‚Äù at http://hpaste.org/84267
10:18:49 <latro`a> herp, forgot to fill name field
10:19:03 <piezo> I'm trying to get a class commutative, something like : instance (C b a) => C a b where op = flip op
10:19:07 <piezo> is it feasible ?
10:19:30 <latro`a> you can't really enforce laws like that in the language itself
10:19:34 <monoidal> piezo: due to way instance resolution works, no
10:19:37 <latro`a> oh wait nvm
10:20:05 <latro`a> you can do it with a newtype of sorts, but no, generally you can't do that, and allowing doing that makes typechecking undecidable
10:20:11 <piezo> ok
10:20:59 <latro`a> anyway yeah, in that code it looks like err and eps have to have the same type, but err :: r, eps :: e
10:22:11 <piezo> so I have to mirror every instance ?
10:22:25 <piezo> I want commutativity on type, not on term
10:23:04 <DanielDiaz> hello, what libraries are available on Hackage to perform operations with matrices?
10:23:12 <latro`a> you do have to mirror it, unless you use a newtype
10:23:15 <monoidal> latro`a: the only thing of type "e" is depth, everything else uses "r"
10:23:34 <latro`a> oh, duh, that explains it
10:23:35 <latro`a> thanks
10:23:51 <latro`a> I wrote this code a while back and miscounted the argument order in looking back over it -_-
10:24:28 <piezo> latro`a: ok thanks
10:27:49 <trescenzi> are there cabal doc style comments or something that cabal will use to automatically build documentation
10:28:10 <dcoutts> trescenzi: we use a tool called haddock
10:28:12 <dcoutts> @where haddock
10:28:12 <lambdabot> http://www.haskell.org/haddock/
10:28:22 <trescenzi> k thanks
10:28:31 <monochrom> cabal will call up haddock
10:29:06 <monochrom> but you have to add flag --enable-documentation or change a setting in ~/.cabal/config. the default is wrong.
10:29:55 <trescenzi> alright thanks
10:57:28 <Walther> What is the status of GHC on RaspberryPi btw?
10:57:57 <srhb> Hm, I can't remember who was working on that.
10:58:12 <Walther> At least GHCi isn't available as is
10:58:19 <ion> walther: I‚Äôm running GHC on Beagle Bone successfully FWIW. The Debian package works.
10:58:27 <srhb> I know there's _someone_ in this channel who's an expert, but I don't remember whom
10:58:33 <srhb> who*
11:02:01 <Ralith> does anyone have edwardk's article re: how to best implement IO handy?
11:02:08 * Ralith isn't sure what keywords to search for
11:02:14 <edwardk> http://comonad.com/reader/2011/free-monads-for-less-3/
11:02:42 <edwardk> that describes a (slightly simplified) version of how we implement it here
11:03:02 <Ralith> for reference, is your language there strict or lazy?
11:03:06 <edwardk> lazy
11:03:25 <Ralith> am I correct in understanding that the semantics of IO as implemented there aren't particularly affected by that?
11:03:33 <edwardk> correct
11:03:36 <Ralith> great, thanks
11:04:01 <edwardk> you can implement a free monad that doesn't blow the stack in a strict language, so you can build the same construction
11:04:09 <edwardk> you don't want to use the 'church free' monad though then
11:04:27 <edwardk> you want to use something that looks more like apfelmus' operational monad to avoid blowing the stack
11:04:46 <mcstar> how can there be different 'monads'?
11:05:02 <Ralith> noted
11:05:44 <edwardk> if you look at the scalaz implementation of the trampoline monad it is closer to what you need in a strict language, because the direct free monad implementation and the church free version both will blow a strict stack. if you have proper tail calls you can ignore this advice.
11:05:49 <mcstar> i sort of expect that a code that has monadic semantics behaves exactly the same with each implementation
11:06:16 <mcstar> (is this just an implementational aspect?)
11:06:33 <Philippa> mcstar: it only behaves the same as far as the monad laws. It can otherwise vary widely
11:06:40 <johnw> mcstar: compare [] to ZipList, for example
11:07:00 <edwardk> mcstar: the constructions were not described in terms of the stack semantics of each machine. if you try to run the standard free monad you wind up with asymptotic slowdown on repeated left associated binds and in a strict environment you blow the stack
11:07:28 <mcstar> nono, i mean different behavior parameterized with the type parameter, dont instantiate the type var.
11:07:31 <Ralith> do you have a precise definition of 'proper' handy?
11:07:39 <edwardk> in the if your semantics don't cover the important aspects of whether or not the code will actually terminate for non-toy examples, i would argue that you haven't chosen the most useful semantics ;)
11:08:05 <mcstar> edwardk: is that basically how foldl and foldr work?
11:08:08 <edwardk> Ralith: i mean proper in the sense that they need to be tail call optimized even if they aren't 'self tail calls'
11:08:57 <edwardk> there is a strong difference between foldl and foldr. foldr is a catamorphism, it follows the natural 'parenthesization' of the original structure. foldl on the other hand requires n re-associations for an n item list before it can start. this is somewhat problematic when n is infinite.
11:09:20 <hiptobecubic> johnw, I thought ZipList did not form a monad
11:09:25 <edwardk> Ralith: in this sense scala lacks proper tailcalls.
11:09:29 <edwardk> hiptobecubic: it doesn't
11:09:43 <hiptobecubic> Right. So I don't see how that's a very good exapmle
11:09:45 <hiptobecubic> or example
11:10:16 <johnw> hiptobecubic: ah, never mind me then
11:10:41 <hiptobecubic> I think it's just an Applicative
11:10:55 <edwardk> it is
11:10:59 <Ralith> edwardk: the meaning isn't obvious to me--can you recommend a reference?
11:11:01 <hiptobecubic> the easiest one to "see" in my opinion
11:11:02 <trescenzi> so in a do block the first time something evaluates to a result it just stops evaluating?
11:11:26 <edwardk> Ralith: scala for instance can optimize tailcalls from the function to itself, because it can compile those into a loop
11:11:43 <edwardk> but it can't tailcall into another function because that would require either radical restructuring of the code in the back end or support from the jvm
11:12:14 <hiptobecubic> Does scala compile to jvm bytecode directly?
11:12:32 <Ralith> LLVM, in contrast, has sibling call optimization, but I suspect that too is more restricted than what you have in mind
11:12:35 <hiptobecubic> I suppose i could just ask that overthere
11:12:38 <edwardk> Ralith: now in scala, (>>=) is implemented by defining a function 'flatMap' as a member of the object in question that you want to (>>=) from. this is all well and good until you realize that flatMap and the function it is passed cannot be the same thing, so you never get the opportunity to optimize tail calls for any monad in scala
11:13:05 <Ralith> ouch
11:13:06 <edwardk> this means that to implement a monad in scala you have to choose your poison.
11:13:09 <edwardk> 1.)  you can implement the super-naive version that looks like any haskell tutorial and crash for non-toy examples.
11:13:48 <edwardk> 2.) you can implement a tail-call-like scheme where you call yourself and track how deep you've gone and throw an exception to blow the stack down to a trampoline that you bounce off of every so often to avoid unbounded stack usage
11:13:55 <edwardk> 3.) you can trampoline off every call
11:14:06 <edwardk> 2 and 3 come with a serious (100x) performance degradation for monadic code
11:14:38 <Ralith> on further examination it looks like LLVM has pretty unrestricted tailcalls
11:14:48 <edwardk> It is clear to me why Martin Odersky dislikes "pure functional programming". He has written a language that is remarkably bad at it.
11:14:56 <Ralith> haha
11:14:58 <sproingie> even gcc can do arbitrary tailcall elimination these days
11:15:06 <Ralith> yeah, I'm glad I don't have to deal with that
11:15:09 <edwardk> If the way I had to view the world was tinted by scala-colored lenses I'd hate functional programming, too.
11:15:39 <hiptobecubic> What is trampolining? I'm imagining some kind of 'base' function you launch things from?
11:15:54 <edwardk> anyways that was the distinction i was trying to raise about 'proper tail call optimization'. it can't just be self-tail-calls
11:16:00 <sproingie> my love of FP comes more from lisp and less from haskell
11:16:01 <hiptobecubic> i guess if you could get it to know what to call, you could use it for "looping" as in tail calls
11:16:07 <edwardk> in any scheme you'll be fine
11:16:21 <edwardk> hiptobecubic: think of it as a function that calls each step in turn
11:16:46 <trescenzi> Yeah what's the consensus on Haskell vs Lisp? I know I personally find Lisp a lot more intuitive
11:17:07 <ion> I think the consensus is that both exist.
11:17:08 <Ralith> edwardk: so, to be certain I understand you correctly, free monads are stack-safe iff you have proper tail calls?
11:17:13 <trescenzi> ha
11:17:15 <johnw> trescenzi: consensus formed by #haskell?  hmm... ;)
11:17:18 <tac> trescenzi: Don't you think you'll get a bias asking in this channel?
11:17:44 <elliott> trescenzi: that kind of discussion isn't going to be productive anywhere. but especially not #haskell.
11:17:58 <RenJuan> lisp is the most popular lang in its class
11:17:58 <trescenzi> Lol fair enough
11:18:00 <hiptobecubic> trescenzi, poo on you
11:18:07 <elliott> for example.
11:18:12 <RenJuan> (including both dialects)
11:18:20 <armlesshobo> ion: we'll continue here.
11:18:23 <RenJuan> a class which includes haskell
11:18:59 <hiptobecubic> edwardk, does clojure suffer this same problem then? because of the jvm?
11:19:09 <RenJuan> not as much buzz/froth but way more practical use
11:19:29 <trescenzi> I want to think I like Haskell there just seem to sometimes be things that I don't know how to do which isn't a problem in any other language I've come across
11:19:38 <powergiant> Is it possible to map someting like "read a::float" ?
11:20:14 <monoidal> powergiant: map (read :: String -> Float) xs?
11:20:19 <hiptobecubic> trescenzi, it wouldn't be interesting otherwise
11:20:23 <elliott> trescenzi: probably because those languages let you run into the programs you run into by not understanding them
11:20:31 <monoidal> powergiant: or (map read xs) :: [Float]
11:20:32 <ion> powergiant: map (reads :: ReadS Float) (which is different but won‚Äôt raise exceptions) or map (read :: String -> Float) or map read ‚Ä¶ :: [Float]
11:20:47 <elliott> e.g. a lot of langauges find themselves hopelessly confused because they lack first-class "programs"...
11:20:49 <trescenzi> elliott: yea I think that's a great point
11:20:56 <Hannibal_Smith> Changing a little the topic, this style it's ok or there are something better?
11:20:57 <Hannibal_Smith> data Permissions = None
11:20:57 <Hannibal_Smith>                  | ReadOnly
11:20:57 <Hannibal_Smith>                  | Reply
11:20:57 <Hannibal_Smith>                  | StartNew
11:20:57 <Hannibal_Smith>                  | Moderate
11:20:59 <Hannibal_Smith>                  | Administrate deriving Show
11:21:02 <elliott> Hannibal_Smith: please use hpaste
11:21:04 <elliott> @hpaste
11:21:04 <lambdabot> Haskell pastebin: http://hpaste.org/
11:21:14 <Hannibal_Smith> elliott, ok
11:21:14 <notdan> Where from does the ghc-pkg get info about packages?
11:21:18 <powergiant> Ah yes that makes sense. Thank you!
11:21:24 <ion> I would put ‚Äú  deriving Show‚Äù on a new line.
11:21:40 <elliott> Hannibal_Smith: there is e.g. https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
11:22:08 <Hannibal_Smith> Using algebric types, there are a better way to express permissions?
11:22:27 <sproingie> Hannibal_Smith: i'd name it PostPermissions or ThreadPermissions or something relevant to what the permissions pertain to
11:22:44 <Hannibal_Smith> sproingie, good point, thank you
11:22:51 <geekosaur> notdan, if you run ghc-pkg list, it shows you the paths of both the global and user package registries
11:23:27 <elliott> oh, this is a domain-specific design question, not a code style question
11:24:00 <Hannibal_Smith> There are some code that use advanced permissions that can I look?
11:25:06 <Hannibal_Smith> elliott, do you think that permissions it's strict domain-specific?
11:25:36 <Hannibal_Smith> It is not possible to make it more generic?
11:25:40 <Walther> So, uh, Haskell / GHC and Raspberry Pi, what's the status? Last time I checked GHCi wasn't available and GHC version was a bit low
11:26:26 <edwardk> back
11:26:32 <edwardk> hiptobecubic: it has the same problems
11:26:34 <geekosaur> Hannibal_Smith, permissions do tend to be domain specific. permissons applicable to a web forum do not necessarily 1-to-1 map to those of a fileserver, or an industrial process control system
11:27:07 <Hannibal_Smith> geekosaur, ok
11:27:08 <Clint> Walther: http://archive.raspbian.org/raspbian/pool/main/g/ghc/
11:27:50 <hiptobecubic> edwardk, this is all pretty saddening. I had the impression that scala or clojure would be the one to "make it" in the wild but still allow fun toys.
11:28:07 <edwardk> you are not alone in that ;)
11:28:08 <hiptobecubic> Not that Haskell is about to do that, but it would be a disaster if it did
11:28:28 <hiptobecubic> I guess it's better than nothing
11:28:40 <mcstar> edwardk: i wasnt trying to imply foldr and foldl are the same..., just that they have different semantics wrt stack blowing, dont they? (in that i can be mistaken)
11:28:51 <hiptobecubic> they do
11:29:08 <hiptobecubic> > foldl (+) 0 [1..1000000]
11:29:10 <lambdabot>   *Exception: stack overflow
11:29:17 <trescenzi> mcstar: they don't always produce the same result either
11:29:26 <mcstar> in case of inifinite lists
11:29:33 <mcstar> and whether the operator is associative or not
11:29:38 <trescenzi> yea
11:29:39 <hiptobecubic> or if the op is associative
11:29:44 <hiptobecubic> is not*
11:29:44 <geekosaur> and even if you limit your interest to fileservers, you would have great difficulty producing a security model that can handle all of: traditional unix, POSIX ACLs, Windows/NTFS, NFS3, NFS4, and AFS at the same time (various storage vendors have tried and given up)
11:29:44 <arkeet> foldl doesn't generalize to branchy data structures either
11:29:52 <arkeet> or does it? I'd be interested.
11:30:13 <mcstar> (i was afk, sry, i hate that when i ask a question, and i need to leave)
11:30:22 <Hannibal_Smith> geekosaur, from what I have seen ( http://www.haskell.org/ghc/docs/7.0.1/html/libraries/directory-1.1.0.0/src/System-Directory.html#Permissions ) tend to don't be typesafe
11:31:25 <edwardk> arkeet: depends on what you mean by generalize. Data.Foldable provides foldl happily for any branchy structure, by just making it look like a list ;)
11:31:35 <Hannibal_Smith> Uhm...maybe it's a matter of domain, is that library it's not important do make permissions typesafe
11:31:40 <geekosaur> hm? FFI code is going to look horridd regardless. but I for one would not want to trust how mingw maps unix-like permissions to ntfs!
11:31:46 <geekosaur> and vice versa
11:32:55 <geekosaur> FFI interfacing code has to take liberties with types, because C is almost type-less compared to Haskell
11:33:14 <mcstar> linux has support for acl permission, doesnt it?
11:33:22 <geekosaur> that says less about Haskell than it does about C (and about OS interfaces designed for C)
11:33:27 <Eduard_Munteanu> mcstar: sure
11:33:42 <mcstar> doesnt cygwin use that?
11:33:50 <Hannibal_Smith> geekosaur, do you have any good example for a typesafe permission system?
11:33:59 <geekosaur> it tries, but POSIX ACLs do not map cleanly to NTFS ACLs
11:34:03 <Eduard_Munteanu> mcstar: what for? There are other uses for them
11:34:17 <geekosaur> as has been repeatedly rediscovered by pretty much every storage device vendor out there :)
11:34:20 <mcstar> ok, just thinking out loudly..
11:34:45 <Eduard_Munteanu> geekosaur: how do you mean, what's this have to do with storage devices?
11:34:57 <Eduard_Munteanu> Oh, you mean NAS servers / appliances?
11:35:03 <geekosaur> yes
11:35:48 <geekosaur> sorry, that may be a sysadminny shorthand of sorts, 'storage' implies a level of management beyond that of raw disk
11:35:52 <Eduard_Munteanu> Samba also attempts to map those two things.
11:36:13 <geekosaur> ...poorly
11:36:18 <mcstar> it has to..
11:36:34 * geekosaur has worked with that code. and for a while maintained samba's attempt at mapping to afs acls... oy
11:36:41 <mcstar> what filesystem do these commodity nas's use?
11:36:54 <geekosaur> (cf. the sysadmin aphorism: disk is cheap, storage is expensive)
11:37:00 <geekosaur> it varies
11:37:19 <Hannibal_Smith> If I define a data for example: data ThreadPersmission = Read | Reply | Close | Delete
11:37:27 <mcstar> geekosaur: is storage then, something you can retrieve data from, not just possibly store data on? :)
11:37:40 <Hannibal_Smith> Is it possible to make a typesafe data that is similar to
11:38:09 <Hannibal_Smith> newtype UserGroup [Read, Reply] ?
11:38:44 <geekosaur> mcstar, very roughly, storage is something you have to talk to as a network filesystem server, not just as a raw disk device. you can't (usually) get direct access to whatever it uses as a backend without jumping through hoops (if at all); it's a black box
11:38:44 <Hannibal_Smith> (Sorry for the example, it's not valid Haskell)
11:38:49 <Eduard_Munteanu> That looks wrong or more than one level.
11:38:54 <Eduard_Munteanu> s/or/on/
11:39:29 <mcstar> i see, i suspected a pun wrt data loss, but i was wrong
11:39:36 <geekosaur> Hannibal_Smith, ThreadPermission there is a type; Read, Reply, etc. are not, they are data values
11:39:49 <Hannibal_Smith> All I can think is define something like
11:39:54 <Hannibal_Smith> data Read = Read
11:39:54 <Hannibal_Smith> ...
11:40:18 <Eduard_Munteanu> Maybe you should explain what you mean.
11:40:20 <Hannibal_Smith> newtype UserGroup = (Maybe Read) (Maybe Write)
11:40:23 <Hannibal_Smith> And so on
11:40:36 <latro`a> data UserGroup = UserGroup (Maybe Read) (Maybe Write)
11:40:46 <latro`a> except that's isomorphic to
11:40:53 <latro`a> data UserGroup = UserGroup Bool Bool
11:41:06 <latro`a> if Read and Write only have one element
11:41:31 <geekosaur> Hannibal_Smith, you're assuming we know what you're trying to accomplish with this. can you provide a high level description of your permissions model *not* in terms of incorrect code?
11:41:35 <Hannibal_Smith> Is it not more semantically corrent to use Maybe insead of Bool?
11:41:38 <Eduard_Munteanu> I mean, explain it in words rather than pseudo-Haskell.
11:41:45 <monochrom> then perhaps data UserGroup = UserGroup{can_read::Bool, can_write::Bool}
11:41:50 <latro`a> ^
11:42:02 <geekosaur> I mean, what is the purpose of UserGroup in this model?
11:42:29 <Hannibal_Smith> geekosaur, define permissions in terms of "list of possible actions"
11:42:42 <Hannibal_Smith> Instead of "A data type of aggregate actions
11:42:51 <Hannibal_Smith> Like the one I pasted before
11:42:52 <monochrom> it is always more semantically correct to use the simplest data. the no-junk principle of denotative programming
11:43:03 <latro`a> if it's just "what can you do", then data UserGroup = UserGroup {can_X :: Bool} for various X is optimal
11:43:13 <geekosaur> and where does splitting out UserGroup fit into that?
11:43:28 <latro`a> but it seems more likely that you'd actually have actions, with more structure than just "what are you allowed to do"
11:43:43 <Swineflu> Is there away I can use patterns to print if x is higher than y
11:43:45 <latro`a> in particular, you'd have a representation of a read action
11:43:52 <latro`a> Swineflu, what's "higher"?
11:43:59 <latro`a> bigger as a number?
11:44:08 <geekosaur> if it's just a list of permissions, data UserPermission = [ThreadPermission] -- although I think you really want some kind of map from *what* thread to the permissions granted. and how do you deal with threads not already in that map?
11:44:09 <arkeet> print what?
11:44:17 <geekosaur> you have not really described your permisisons system
11:44:25 <Hannibal_Smith> Yes geekosaur
11:44:33 <Hannibal_Smith> If I Use [ThreadPermission]
11:44:36 <mcstar> are you looking for a tuple of bools, to mimick the unix file permissions?
11:44:49 <Hannibal_Smith> I [ThreadPermission] I can insert something like [Read, Read, None]
11:44:58 <mcstar> you dont want a list
11:45:02 <mcstar> afaict
11:45:04 <Swineflu> latro`a: yes as a int
11:45:10 <latro`a> it sounds like you want a map from threads to a bool tuple
11:45:20 <latro`a> Swineflu, then as arkeet said, print what?
11:45:21 <mcstar> yep
11:45:39 <Swineflu> ((A,B),(A,B)) I want to do something if B is bigger than the second B
11:45:41 <mcstar> print something
11:45:41 <Swineflu> etc
11:46:04 <arkeet> Swineflu: if/then/else no good?
11:46:13 <Hannibal_Smith> geekosaur, think about a simplet list of actions on a thread
11:46:27 <mcstar> he wants patterns, which he can use
11:46:30 <geekosaur> yes, what about it?
11:46:37 <Hannibal_Smith> Such of: User Can: Read, Reply, Moderate, Edit others reply
11:46:41 <mcstar> case x > y of True -> (); False -> ()
11:46:43 <Swineflu> arkeet: that could work but it'd be prettier with patterns
11:46:47 <arkeet> it would?
11:46:53 <Swineflu> I'm trying to think haskell rather than think java
11:46:54 <Swineflu> I guess
11:46:58 <Hannibal_Smith> Is it possible to map this to a typesafe "system"?
11:47:01 <latro`a> also case compare x y of GT -> ...; LT -> ...; EQ -> ...
11:47:06 <Hannibal_Smith> Like
11:47:18 <arkeet> also when (x > y) (...)
11:47:30 <arkeet> :t when
11:47:32 <Hannibal_Smith> post :: Permissions User -> ()
11:47:34 <lambdabot> Monad m => Bool -> m () -> m ()
11:47:34 <mcstar> also, if/then/else is strongly recommended for a two-way branching
11:47:41 <arkeet> it is?
11:47:44 <mcstar> yes
11:47:48 <Hannibal_Smith> post :: (CanReply _ _ ...) = ...
11:47:55 <mcstar> it is clear, you dont need clutter
11:47:55 <elliott> if by "two-way" you mean "boolean", sure.
11:48:00 <mcstar> yes
11:48:05 <mcstar> he wants to branch on a bool
11:48:05 <latro`a> do you mean IO () or something, Hannibal_Smith
11:48:06 <latro`a> ?
11:48:07 <mcstar> x>y
11:48:16 <latro`a> because () only has one member (two if you count _|_)
11:48:38 <Hannibal_Smith> latro`a, yes I's sorry, I tend to write invalid Haskell code :-P
11:49:44 <Hannibal_Smith> So the best way, it's write something like
11:49:54 <jfischoff> @src when
11:49:54 <lambdabot> when p s = if p then s else return ()
11:49:56 <Hannibal_Smith> data UserGroup = Bool Bool Bool?
11:50:30 <latro`a> possibly naming the parameters
11:50:31 <Hannibal_Smith> Maybe better
11:50:36 <Hannibal_Smith> type Read = Bool
11:50:56 <latro`a> data UserGroup = UserGroup { can_read :: Bool; can_write :: Bool; can_modify :: Bool}
11:51:11 <monochrom> I recommend disbelieving in religious rules such as "always use if" and "never use if".
11:51:12 <Hannibal_Smith> Ok
11:51:44 <ion> never believe in these rules
11:51:56 <Hannibal_Smith> Another questions, how can I make sure that is it impossible tu create ad invalid UserGroup?
11:51:58 <Hannibal_Smith> Like
11:52:31 <latro`a> typically with smart constructors and hiding the original constructor
11:52:35 <Hannibal_Smith> UserGroup { can_read =False, can_write = True ... }
11:52:41 <ParahSailin> @hoogle w2c
11:52:41 <lambdabot> No results found
11:52:42 <Hannibal_Smith> Uhm...ok
11:53:06 <Swineflu> Hmm so I can have P1 > P2 in my patren :(
11:53:09 <geekosaur> Hannibal_Smith, smart constructor
11:53:10 <Hannibal_Smith> I like this code
11:53:38 <Hannibal_Smith> Thak you to all of you (and sorry for my english)
11:53:42 <Hannibal_Smith> *thank
11:53:44 <geekosaur> instead of exporting the real constructor, you export a function which validates its parameters and then creates the real value
11:54:00 <Hannibal_Smith> Yes I did read something of this topic
11:54:58 <mcstar> Hannibal_Smith: why is that invalid?
11:55:14 <Hannibal_Smith> mceier, what?
11:55:20 <mceier> dunno
11:55:27 <mcstar> UserGroup { can_read =False, can_write = True ... }
11:55:31 <mcstar> mceier: hello :)
11:55:32 <notdan> Do you folks know if it's possible to make cabal-dev use global packages? http://hpaste.org/84274
11:55:35 <mceier> mcstar: hi :)
11:55:40 <mceier> same mistake, I see ;)
11:55:55 <Hannibal_Smith> mceier, I tend to write invalid Haskell code, I don't write always invalid Haskell code :-P
11:56:22 <Swineflu> Why can't i just do something like: "points "((HT,P1 > P2),(A2,P2 < P1)) = putStr "P1 is bigger than P2""
11:56:22 <mcstar> Hannibal_Smith: not haskell, why is that an invalid permission?
11:56:45 <arkeet> Swineflu: you can't use > in a pattern
11:56:46 <Hannibal_Smith> mceier, it makes no sense reply in a thread that you cannot read
11:56:52 <mceier> Hannibal_Smith: lol ;)
11:56:52 <arkeet> that doesn't make sense
11:56:55 <elliott> Swineflu: points ((ht,p1),(a2,p2)) | p1 > p2 = putStr ...
11:56:55 <latro`a> Swineflu, that's not how > works, it's a function; patterns aren't as powerful as that
11:57:05 <mceier> Hannibal_Smith: I don't know what you are talking about :)
11:57:09 <Hannibal_Smith> Ok
11:57:31 <mcstar> Hannibal_Smith: i dont see why would it make no sense
11:57:51 <mcstar> you can guarantee a one way communication that way
11:57:54 <mcstar> it makes sense to me
11:57:58 <Swineflu> latro`a: They should be
11:58:09 <Swineflu> elliott: thanks
11:58:10 <mcstar> (maybe in the exact context it doesn, with which im not familiar)
11:58:12 <latro`a> not really, they're there to bind variables and match what a constructor is
11:58:15 <mcstar> doesnt
11:58:21 <Hannibal_Smith> <mcstar> (maybe in the exact context it doesn, with which im not familiar) <-This
11:58:37 <mcstar> ok
11:58:48 <latro`a> that simple pattern looks meaningful, but make it even slightly more complicated and it's not at all clear what it should mean
11:58:57 <Hannibal_Smith> It's like: "Oh I'm banned from #haskell...I will write them how to code in C#!"
11:58:57 <supki> notdan: if you install with --global then cabal-dev should just use them
11:59:21 <notdan> supki: well I installed it as a user package
11:59:40 <supki> notdan: ah, no idea then
12:01:13 <geekosaur> Swineflu, patterns are not a whole lot different from parameter declarations in other programming languages. would you expect to be able to put a conditional in a parameter list in C?
12:01:13 <Hannibal_Smith> Ah another question: data SomeData a = TestA a | TestB -> Is it possible to constrains a to an specific typeclass?
12:02:04 <elliott> Hannibal_Smith: yes with GADTs, but there's no point
12:02:04 <geekosaur> "yes" but it won't work the way you might hope unless you use a GADT. (in particular you still need to specify the typeclass constraint in any function that uses it)
12:02:14 <elliott> just put the constraint on your functions instead
12:02:17 <Hannibal_Smith> elliott, uhm? Why?
12:02:22 <Hannibal_Smith> Ok
12:02:25 <epta> notdan: –æ—á–∫–æ, —Ç—ã?
12:02:28 <Hannibal_Smith> Hiding the costructor?
12:02:29 <elliott> Hannibal_Smith: well, it costs you flexibility for little reason.
12:02:35 <elliott> why hide the constructor?
12:02:40 <elliott> I mean, if you want to, sure.
12:02:56 <Hannibal_Smith> Ok
12:03:25 <shachaf> geekosaur: Is "data Foo a = Blah a => Foo a" a GADT?
12:03:51 <elliott> you need ExistentialQuantification for that instead right?
12:03:55 <elliott> so weird.
12:04:05 <sproingie> nope.  "data where" gives you a gadt
12:04:21 <Hannibal_Smith> Thank you geekosaur, elliott
12:04:22 <shachaf> sproingie: As long as we're nitpicking, "data where" gives you a syntax error.
12:04:32 * sproingie glares
12:12:33 <Eduard_Munteanu> shachaf: mind that actually is   data Foo a = forall b. (Blah b) => Foo b
12:12:50 <shachaf> Eduard_Munteanu: ?
12:12:58 <shachaf> That's a different type.
12:12:58 <monochrom> then you can delete "a"
12:13:15 <Eduard_Munteanu> Yeah.
12:14:18 <Eduard_Munteanu> shachaf: what else would it mean? You can't simply place a class constraint on that 'a' for a particular constructor. Unless you mean a GADT, but that require GADT syntax, no?
12:15:24 <shachaf> Œª> data Foo a = Show a => Foo a
12:15:27 <shachaf> Œª> :t \(Foo x) -> show x
12:15:27 <shachaf> \(Foo x) -> show x :: forall t. Foo t -> [Char]
12:16:58 <Eduard_Munteanu> shachaf: ok, but what's the type of 'x'?
12:17:30 <shachaf> t, in this case
12:17:46 <Eduard_Munteanu> I think not.
12:18:17 <shachaf> \(Foo x) -> (x, show x) :: forall t. Foo t -> (t, String)
12:18:46 <Eduard_Munteanu> Hm.
12:20:01 <Eduard_Munteanu> I find that odd, assuming it defines an indexed GADT.
12:20:47 <shachaf> This is an alternative syntax for "data Foo a where Foo :: Show a => Foo a"
12:20:59 <shachaf> Is it the syntax or the behaviour that you find odd?
12:21:25 <Eduard_Munteanu> Syntax, I thought you could only define GADTs with the special syntax.
12:21:49 <monoidal> you can write data Eq x y = (x ~ y) => Eq
12:22:05 <elliott> data Eq x y where Refl :: Eq x x
12:22:17 <shachaf> Well, this is just like the ExistentialQuantification syntax, except with a constraint instead of a forall.
12:22:18 <Eduard_Munteanu> LOL... "(Use -XExistentialQuantification or -XGADTs to allow this)" -- and indeed it allows it either way
12:22:28 <Eduard_Munteanu> So, different semantics with different extensions? :O
12:22:38 <shachaf> No, it's the same thing.
12:25:46 <monoidal> as an aside, I hate the syntax "data D a b where ...". "data D :: * -> * -> * where ..." is much better
12:27:05 <shachaf> It is longer.
12:28:58 <sproingie> i hate having to use kind syntax where i dont have to
12:29:03 <monoidal> my reasons are 1) telling kind when declaring type is analogous to telling type when declaring a term 2) those "a" and "b" are not bound anywhere, they tell essentially nothing
12:29:55 <sproingie> in a world where more than one letter is used, those type params could document usage
12:30:20 <monoidal> sproingie: indeed, but I think constructors are a better place for this
12:30:43 <sproingie> they document at different levels
12:31:13 <monoidal> sproingie: both are types, no? like data D username where X :: String -> D username
12:31:47 <sproingie> i take the point about the binding tho
12:32:02 <Hermit> monoidal: and how would you specialize constructors from a type constructor?
12:32:33 <monoidal> Hermit: i don't understand the question
12:34:43 <Hermit> hmm, now that I look closely, you were writing  data D ... where ...   not  data D ... = ...
12:35:21 <monoidal> indeed. my objection is to the type variables part
12:35:44 <Eduard_Munteanu> That's... strange.
12:36:17 <Eduard_Munteanu> So   data Foo a = Show a => Foo a   pretty much gives you a GADT without {-# LANGUAGE GADTs #-}
12:36:19 <shachaf> monoidal: I agree that it makes more sense, but it's longer!
12:36:27 <Eduard_Munteanu> You just need ExistentialQuantification. :/
12:36:40 <shachaf> Eduard_Munteanu: ExistentialQuantification + equality constraints give you GADTs
12:36:42 <Eduard_Munteanu> Oh, wait, the constraint is missing.
12:37:07 <Eduard_Munteanu> Hm.
12:37:27 <shachaf> In fact I think that's how you express GADTs in TH.
12:38:26 <jfischoff> shachaf: yep
12:38:55 <shachaf> In fact I think jfischoff told me that once.
12:39:01 <jfischoff> :)
12:39:03 <monoidal> on the other hand, "data X a b where" is consistent with "class X a b where", but here a,b are bound.
12:39:34 <elliott> class X :: * -> Constraint where
12:39:38 <elliott> er, and another * ->
12:39:55 <monoidal> elliott: the methods need to somehow refer to the type parameters
12:40:07 <elliott> it was not a serious suggestion :)
12:40:13 <elliott> perhaps:
12:40:22 <elliott> class Num :: * -> Constraint where fromInteger :: Num a => Integer -> a
12:40:33 <elliott> similar to GADTs doing ... -> TheType a b c
12:42:51 <monoidal> that makes some sense with "GADCs": class X a b where f :: X a a => Int -> a
12:43:14 <monoidal> so the method needs to be implemented only when a~b
12:43:53 <elliott> sounds interesting.
12:44:02 <elliott> of course we already have ~ and can use it inside classes, so we don't get more power
12:44:24 <shachaf> Is that true?
12:44:42 <shachaf> How would you do that here?
12:45:08 <elliott> class X a b where f :: a ~ b => Int -> a
12:45:22 <elliott> of course you have to be able to prove a ~/ b to get away with not implementing it.
12:46:29 <shachaf> That goes back to that extra type inequality thing GADTs let you do, though.
12:46:35 <shachaf> Don't you get the same sort of thing here?
12:47:16 <scooty-puff> anyone here familiar with logict and odd interactions between LogicT and an underlying Reader?
12:47:28 <scooty-puff> in particular involving local
12:48:35 <tac> Is there a list monad implementation which iterates over the lists diagonally?
12:49:07 <tac> so do x <- [1..]; do y <- [1..]; return (x, y) returns a list of all pairs (x, y).... rather than just all pairs (1, y)?
12:49:35 <monoidal> tac: don't know any nice implementation, but you can use (Integer ->) monad
12:49:47 <tac> monoidal: hmm
12:49:49 <tac> thanks
12:50:00 <monoidal> tac: i.e. infinite stream [a] ~ function Integer -> a
12:50:07 <tac> right right
12:50:39 * tac wonders if in a total language, Haskell's List monad definition actually satisfies all the monad laws.
12:50:54 <srhb> So, now I have a Message type that encapsulates IRC messages, and I want my bot to actually deal with this in various ways. This seems to me a lot of case m^command of ... case m^.params of ... case ^.message of ... case m^.sender of ... because of the fields being Maybes and lists. Is there a nice way to encapsulate this? I suppose something like when is what I want, because when there's nothing I most often want return ()
12:51:05 <srhb> But I'm wondering if this is a general pattern.
12:51:17 <shachaf> srhb is writing Lambdabot 2.0?
12:51:17 <hpaste> scooty-puff pasted ‚ÄúLogicT and Reader‚Äù at http://hpaste.org/84276
12:51:26 <typoclass> shachaf: 7.0
12:51:27 <srhb> shachaf: shhh.
12:51:31 <elliott> shachaf: well, sure.
12:51:37 <elliott> shachaf: I was assuming you had TypeFamilies too or whatever.
12:51:46 <srhb> I think I'm mostly failing to write lambdabot n.0
12:51:54 <srhb> BUt it's worth the experience. Maybe. :-)
12:52:03 <aCube> srhb: Monads?
12:52:15 <aCube> or maybe? (The function)
12:52:18 <aCube> :t maybe
12:52:19 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:52:38 <srhb> Yeah, I can use that a lot of places by using maybe (return ())
12:52:46 <shachaf> @ty maybe (return ())
12:52:47 <lambdabot> Monad m => (a -> m ()) -> Maybe a -> m ()
12:52:55 <srhb> But a lot of the cruft arises from having to deal with the possible Nothings when I dive into fields
12:52:57 <shachaf> @ty Data.Foldable.for_
12:52:59 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
12:53:03 <typoclass> srhb: i don't know what (^.) is, but if you don't like the nested cases, you sometimes can do "case (thing, otherthing, ...) of (Foo, _, ThisAndThat)" to match it all in one. as far as return () is concerned, i guess "guard" and the Maybe monad could help
12:53:13 <srhb> Yeah..
12:53:22 <srhb> The Maybe monad will probably help
12:53:50 <tieTYT> I'm on windows and I've decided to regretably give up learning haskell because I got to the point where I wanted to write a "real" program that leveraged libraries and I spent over an hour trying to figure out how to install every library I wanted to use.  Only one of them actually worked in the end.  I'm thinking about clojure as an alternative, but I really love the haskell language.  I'm
12:53:50 <tieTYT> wondering if someone can give me some advice
12:53:52 <srhb> m^.msg == "!someCommand" is still what I want, but can't because m^.msg is a Maybe
12:54:32 <srhb> Though I suppose a specialization of maybe will help there, too
12:54:33 <monoidal> srhb: maybe (return ()) == sequenceA_?
12:54:41 <srhb> monoidal: IT is?
12:54:45 <shachaf> monoidal: traverse_?
12:54:55 <tieTYT> i wanted to use the curl library and from what I can tell, the only way to get that working is to compile the curl libs on my computer.  Really don't want to have to deal with C to use haskell
12:55:11 <mauke> ew, curl
12:55:14 <srhb> tieTYT: No curl for you, then.
12:55:19 <typoclass> srhb: depending on what you want, you could do ¬´case m^.msg of Just "!someCommand" -> ... Just _ -> ... Nothing -> ...¬ª
12:55:33 <elliott> tieTYT: installing them should be a one-liner if you're on Debian or Ubuntu or basically any linux distro
12:55:37 <tieTYT> seems like "no libraries for you, then"
12:55:38 <elliott> "sudo apt-get install libcurl-dev" or such.
12:55:41 <srhb> typoclass: Yeah. That gets ugly fast, though, becuase depending on what the user is that command may or may not be allowed
12:55:45 <monoidal> ah, right, it should be traverse_
12:55:48 <srhb> Etc.
12:55:49 <tieTYT> elliott: sure, but I'm not on those systems
12:55:53 <Hannibal_Smith> tieTYT, you could install Linux as a virtual machine
12:56:23 <elliott> tieTYT: Windows?
12:56:41 <tieTYT> yes but then my program only works on some os'.  That seems like a scary situation. A pre-java one
12:56:48 <elliott> then yes native libraries will be a pain.
12:56:50 <Jeanne-Kamikaze> infidel!
12:56:52 <elliott> what do you mean by that?
12:56:55 <srhb> I think this might all tidy up if I use MaybeT.
12:56:57 <elliott> curl is portable.
12:57:09 <elliott> it will work on Windows if you'll compile it for Windows (or download a binary or something).
12:57:26 <tieTYT> yes but after you build curl, getting cabal to realize I did is tricky.  Especially because I don't know what I'm doing at all with C or Haskell yet
12:57:29 <Jeanne-Kamikaze> can't you get it rolling on cygwin ?
12:57:50 <elliott> compiled Haskell binaries are already OS-specific
12:57:52 <aCube> srhb: is that what you want: (== "!somcomand") <$> m^.msg ?
12:57:53 <tieTYT> Jeanne-Kamikaze: nope, i've been trying.  I installed the curl libs
12:58:03 <typoclass> tieTYT: sorry to hear that :-/ i'm sure that in general, the maintainers of the problematic packages would like to hear about the problems. if you even manage to write up what worked for you in the end, they'll thank you for the install guide. that said, curl is probably more complicated than you need. have you considered http-conduit?
12:58:16 <typoclass> (or even the 'http' package)
12:58:29 <sproingie> curl in particular you'd need to do the same steps to compile it on windows.  the general problem you're running into is that hackage doesn't distribute compiled binaries
12:58:31 <tieTYT> elliott: right but even if I give someone the source I gotta tell them, "You have to compile this on linux or follow these really intimidating steps to get them working on windows."  Steps I haven't even figured out yet on my own.
12:58:37 <srhb> aCube: Oh, I guess Applicative could also do interesting things.
12:58:41 <tieTYT> typoclass: I emailed one
12:58:47 <elliott> tieTYT: it's Windows. you could just distribute the binary.
12:58:56 <aCube> srhb: (<$>) is just sugar for fmap
12:58:59 <srhb> Yeah
12:59:07 <tieTYT> elliott: I see, well that's some good news
12:59:12 <tieTYT> sproingie: yeah
12:59:36 <srhb> aCube: Just got inspired. :-)
12:59:42 <srhb> Thanks everyone for the inspiration in fact.
12:59:44 <sproingie> i wouldn't mind a repo system for compiled artifacts targeting, say, the current haskell platform
12:59:55 <sproingie> but i'm not volunteering my bandwidth :)
13:00:08 <tieTYT> sproingie: that's not that bad.  I mean i can easily get the binaries installed on cygwin.  But after I do cabal still doesn't install curl.  I don't knwo what i'm doing wrong and as a newb this is very frustrating
13:00:21 <typoclass> srhb: you could always post code on hpaste and ask how to make it nicer and awesomer and eleganter ... :-)
13:00:28 <sproingie> because windows is still very much a red-headed stepchild in the haskell world
13:00:57 <srhb> typoclass: Good idea, too. :D I just want it to be not super-ugly as it is now, though
13:01:16 <sproingie> hell even perl didn't get a really solid windows distribution with cpan and everything til relatively recently with strawberry perl
13:01:22 <typoclass> tieTYT: could you tell us more about what you're planning? if it's just downloading a few files, curl is probably not really the right choice
13:01:23 <tieTYT> and I figure if I learn clojure, I can use any java library that's already written.  That's a huge advantage.  There's a curl client written in pure java, I bet. Anyone could run my source.  The biggest downside is it's not in Haskell :(  I really like the haskell language
13:01:35 <dmj> If you were interviewing someone and asked them what a monad was and there answer was, "It's a design pattern for the sequencing of computations" Would you think that to be sufficient?
13:01:41 <dmj> their*
13:01:48 <sproingie> if you really like haskell, you're better off using it on linux
13:02:00 <tieTYT> typoclass: sure, but that's not really the point.  I've had trouble installing wget and encoding, too.  I've yet to have a package install just by typing cabal install
13:02:15 <meyersh> dmj: I would accept "It's like a burrito" as well.
13:02:20 <tieTYT> i always gotta come here to get help
13:02:31 <aCube> wget and curl are typical linux programs, aren't they
13:02:37 <aCube> ?
13:02:39 <typoclass> dmj: it's a decent start, i guess. some people around here really don't like the term "design pattern" for some reason
13:02:48 <tieTYT> aCube: true, they've got that in common
13:03:06 <tieTYT> there's another app called shpider which looked really cool, but it depends on curl
13:03:12 <tieTYT> so i couldn't install that either
13:03:20 <skp> hi
13:03:33 <sproingie> fixing the curl bindings to work on windows would certainly be nice
13:03:36 <skp> what‚Äôs the difference between these:
13:03:55 <tieTYT> sproingie: or maybe a "curl" impl written in haskell
13:03:59 <c_wraith> fixing the curl bindings to not segfault would also be nice
13:04:00 <skp> class Foo a b where foo :: b -> a b
13:04:01 <skp> and
13:04:04 <skp> class Foo a where foo :: b -> a b
13:04:07 <skp> I don‚Äôt get it
13:04:14 <c_wraith> I just don't think anyone cares about curl anymore
13:04:16 <tieTYT> sproingie: but if I did that, i can't make the other libraries use it instead so no point
13:04:27 <dmj> @typoclass: Instead of "design pattern" what other synonyms would you accept
13:04:28 <lambdabot> Unknown command, try @list
13:04:29 <typoclass> tieTYT: right, but that's what i'm trying to get at. i'd expect a pure-haskell library to be easier to install, and a library with both a haskell and a native side to be more work and more risk. (in principle that isn't different for linux either.)
13:04:29 <monoidal> skp: in the first case, there's a separate instance for each b
13:04:32 <tieTYT> c_wraith: there are other libraries that use it.  Like shpider
13:04:32 <sproingie> depends on what they're doing, libcurl has a lot of bells and whistles
13:04:48 <monoidal> skp: in the second case, there should be a single instance with a *polymorphic* (parametric) function that works on any b
13:04:50 <skp> monoidal: whereas only one for each seconde?
13:04:52 <monochrom> in "class Foo a where foo :: b -> a b", imagine "class Foo a where foo :: forall b. b -> a b"
13:04:52 <skp> second*
13:04:59 <skp> I see
13:05:03 <elliott> tieTYT: if you want "curl" in Haskell then just use HTTP or whatever.
13:05:05 <elliott> @hackage HTTP
13:05:05 <lambdabot> http://hackage.haskell.org/package/HTTP
13:05:11 <skp> I see
13:05:15 <tieTYT> typoclass: right.  Well in my very limited experience, 100% of the haskell libraries have a native side :)
13:05:26 <sproingie> your experience is limited indeed
13:05:30 <elliott> that experience is extremely skewed, then
13:05:41 <sproingie> anyway, if you want to learn the language, then use a platform you don't have to fight
13:05:48 <typoclass> tieTYT: have you considered http-conduit? it's easy to use and purely haskell afaik
13:06:00 <skp> 21:04 < monochrom> in "class Foo a where foo :: b -> a b", imagine "class Foo a where foo :: forall b. b -> a b"
13:06:04 <tieTYT> I want to use cookies, submit forms, etc.  I want something higher level than just HTTP
13:06:08 <skp> I have trouble with that
13:06:19 <tieTYT> does conduit make that easy, or just possible?
13:06:19 <skp> because Foo is declared as Foo a
13:06:23 <skp> and used as a b
13:06:23 <nardul> Hey! Okay, I'm new to haskell. Can someone help me with this code? :  http://pastebin.com/JnXkna8v   I added the type specifier.
13:06:27 <mauke> The paste JnXkna8v has been copied to http://hpaste.org/84277
13:06:32 <skp> like it‚Äôs kind is * ‚àí> * against *
13:06:37 <skp> its*
13:06:47 <otters> nardul: gotta ad
13:06:53 <otters> gotta add Eq and Ord to the class constraints
13:06:54 <tac> (haskell can do multi-branched if statements??)
13:06:56 <typoclass> tieTYT: in general you're right, it can be very difficult to guess if "package X which i just found on hackage" is actively developed, abandoned but working, non-working, more trouble than it's worth, nice but there's easier alternatives, etc. etc.
13:06:58 <monochrom> "a" has kind *->* throughout. b has kind * throughout
13:07:14 <nardul> otters: Can you explain that in english? :)
13:07:15 <shachaf> nardul: You should comment out the type and use :t to find out what it should really be.
13:07:17 <ion> ‚Äú‚àí>‚Äù
13:07:22 <monoidal> tac: multiwayif is since 7.6, if that's what you're asking
13:07:30 <nardul> shachaf: It doesn't work if i don't add a type.
13:07:31 <tieTYT> typoclass: yeah, true anywhere
13:07:36 <tac> monoidal: interesting.
13:07:47 <skp> huh?
13:07:50 <aCube> tieTYT: try http-conduit-browser
13:07:52 <monochrom> when you write "a b" you already force the kinds. it does not matter whether it is "Foo a" or "Foo a b"
13:07:52 <otters> nardul: like, (Ord a, Eq b, ...
13:07:52 <skp> foo :: b -> a b
13:07:55 <otters> )
13:07:57 <shachaf> nardul: It type-checks, though.
13:07:57 <nardul> shachaf: It says: No instance for (Integral a10) arising from a use of `fn'
13:07:59 <skp> here a has a kind * -> *
13:08:01 <skp> isn‚Äôt it?
13:08:09 <monochrom> yes, that's what I'm saying
13:08:10 <shachaf> nardul: The trouble is that there's no type that supports all these operations.
13:08:13 <tieTYT> typoclass: i mean in any language.  But google seems to put curl and wget at the top when you search for how to use an http client
13:08:14 <skp> so it means
13:08:22 <skp> class Foo a where
13:08:24 <skp> here
13:08:31 <skp> there‚Äôs no indication on the kind?
13:08:33 <tieTYT> aCube: this? http://hackage.haskell.org/package/http-conduit-browser
13:08:38 <shachaf> nardul: You're using mod -- which only works for Integer-alikes -- and (/) and (**) -- which only work for Fractional/Floating.
13:08:38 <monochrom> that's right
13:08:44 <monoidal> skp: in the first line, no. you can write class Foo (a :: * -> *) where to make it clear
13:08:59 <skp> so where‚Äôs it strictly defined?
13:09:02 <skp> I mean
13:09:03 <typoclass> dmj: i don't really have anything against "design pattern" myself :-) i've just seen people around here not like it for some reason. i think your original explanation isn't half bad
13:09:08 <skp> a functor has a kind * -> *
13:09:14 <skp> where is it defined?
13:09:16 <monochrom> "class Monad m where" you have seen this. no kind inferred. "return :: a -> m a" this makes m :: *->*
13:09:22 <typoclass> tieTYT: check this out, it's fairly easy to use and it worked well for me http://hackage.haskell.org/packages/archive/http-conduit/1.9.2.2/doc/html/Network-HTTP-Conduit.html
13:09:25 <nardul> shachaf: So this is impossible in haskell? :P
13:09:29 <aCube> tieTYT: yes
13:09:35 <skp> so it depends on the method?
13:09:37 <monoidal> skp: that follows from the fact that Functor f has fmap :: (a -> b) -> f a -> f b, and this type forces f :: * -> *
13:09:45 <monochrom> it depends on type sigs
13:09:50 <tieTYT> ok i'll give this one more shot since I really like haskell
13:09:53 <skp> I see
13:09:59 <skp> that‚Äôs a bit hard to follow
13:10:00 <shachaf> nardul: The code you wrote is asking for nonsense, and nonsense is difficult.
13:10:02 <monoidal> skp: kind inference gives missing kinds just like type inference gives missing types
13:10:26 <shachaf> nardul: Try using (`div`) instead of (/) and (^) instead of (**)
13:10:31 <nardul> shachaf: Well. It isn't really is it? It's just a fast power. But i could probably write more functions.
13:10:39 <nardul> shachaf: I'll try.
13:10:52 <nardul> shachaf: Don't know the difference between the functions
13:10:54 * tieTYT sees if this installs
13:11:03 <shachaf> nardul: OK, then go find out the difference between the functions.
13:11:06 <skp> I don‚Äôt get it monoidal
13:11:21 <skp> for me
13:11:37 <skp> something in the class monad has a kind * -> *
13:11:42 <typoclass> tieTYT: when i think "i need to do X, but i don't know what the most sensible haskell library is", i usually ask #haskell
13:11:46 <nardul> shachaf: On it, thanks!
13:11:56 <skp> so isn‚Äôt precisely defined in the class declaration?
13:12:03 <monochrom> yes, and it is because of "a -> m a". not because of "class Monad m".
13:12:10 <monoidal> skp: it is
13:12:14 <skp> it‚Äôs not!
13:12:21 <monochrom> nothing in "class Meh a b c d e f g" says anything about kind.
13:12:23 <skp> we have to read the class‚Äô methods
13:12:29 <tieTYT> typoclass: yeah good idea.  Someone suggested this to me earlier, but I couldn't find it by searching
13:12:42 <skp> why?
13:12:53 <skp> why isn‚Äôt it in the class ¬´ header ¬ª?
13:13:23 <hpc> skp: it's possible to put it there with kind signatures, iirc
13:13:31 <skp> hpc: I see
13:13:40 <skp> well thank you for your help
13:14:07 <skp> what the minimal class that adds the (/) operator?
13:14:09 <skp> Floating?
13:14:17 <monoidal> :t (/)
13:14:19 <typoclass> tieTYT: ... or you could even google "doing X in haskell"; sometimes there's a stack overflow question about your topic
13:14:19 <lambdabot> Fractional a => a -> a -> a
13:14:25 <skp> Fractional, ok
13:14:28 <skp> ty
13:15:06 <tieTYT> typoclass: something like that got me to wget/curl/shpider
13:17:19 <ParahSailin> @hoogle unI
13:17:19 <lambdabot> Data.Unique module Data.Unique
13:17:19 <lambdabot> Data.Fixed type Uni = Fixed E0
13:17:19 <lambdabot> Control.Exception.Base uninterruptibleMask :: ((forall a. IO a -> IO a) -> IO b) -> IO b
13:17:32 <tieTYT> sigh
13:17:52 <tieTYT> failed to install let me paste the error
13:18:13 <tieTYT> http://hpaste.org/84279
13:18:27 <typoclass> tieTYT: you're right, you need to take it with a grain of salt. but sometimes it works. googling "http request in haskell" gives me the 'http' package as the #1 result, which has some weaknesses but works well enough. #3 is a stack overflow page suggesting 'http' and 'http-conduit'
13:19:35 <tieTYT> to me this error seems to suggest there's something wrong with the conduit source code
13:21:36 <ParahSailin> is there any trick to allow import of hidden modules?
13:21:57 <ParahSailin> i need to get at Data.Attoparsec.Internal.Types
13:23:36 <typoclass> tieTYT: hm ... hackage claims that package builds correctly with ghc 7.6 ... hang on
13:23:56 <aCube> typoclass: seems to me it doesn't
13:24:04 <aCube> I tried it too, got a different error
13:24:05 <tieTYT> $ ghc --version
13:24:05 <tieTYT> The Glorious Glasgow Haskell Compilation System, version 7.4.2
13:24:16 <tieTYT> am I out of date?
13:24:53 <Swineflu> points (String,Int,String,Int)
13:24:55 <typoclass> tieTYT: no, seems ok. i think that package is not well-tested
13:24:58 <Swineflu> I'm trying to use that pattern
13:25:04 <tieTYT> ha
13:25:07 <Swineflu> but i just get not in scope errors
13:25:08 <Swineflu> ;s
13:25:22 <trescenzi> what's points?
13:25:24 <skp> ok now
13:25:27 <skp> class Foo a b
13:25:34 <skp> the instance should be written:
13:25:42 <skp> instante Foo Bar Int
13:25:44 <skp> that‚Äôs it?
13:25:50 <skp> instance*
13:26:01 <monoidal> Swineflu: on String and Int? they are types, unavailable at the value level
13:26:18 <Swineflu> trescenzi: points :: Match -> ((Team,Points),(Team,Points))
13:26:35 <tieTYT> typoclass: so now what?
13:26:43 <monoidal> Swineflu: case points match1 of ((t1,p1),(t2,p2)) -> ...
13:26:48 <typoclass> tieTYT: have you tried http-conduit ?
13:26:57 <tieTYT> no
13:27:00 <Swineflu> monochrom: so i should just use vars
13:27:08 <tieTYT> but this library works at the abstraction I want to work at
13:27:10 <ParahSailin> no easy way to import hidden modules from packages?
13:27:41 <monoidal> Swineflu: yes
13:27:58 <typoclass> tieTYT: i see
13:28:35 <Swineflu> monoidal: ahhh, I was sure i'd tried that but it seems to work
13:28:47 * aCube wishes for an import replacing ... (Overwrites the functions in scope, instead of making them ambigous)
13:29:34 <monoidal> aCube: you can hide the unwanted functions
13:29:59 <tieTYT> typoclass: i mean even the example on that module is exactly what I want to do.  It would be perfect
13:30:00 <aCube> yes, but it's anyoing to have to hide all of Traversable + Foldable from prelude
13:30:55 <typoclass> ParahSailin: i guess you could "cabal unpack thepackage", edit thepackage.cabal to expose the modules you need, bump the version number, and do "cabal install" inside the directory
13:31:17 <typoclass> tieTYT: hang on, i'm trying to replicate your problem
13:31:28 <tieTYT> typoclass: ok thanks
13:31:50 <tieTYT> typoclass: I'm thinking I should try installing just conduit
13:32:05 <skp> gosh it‚Äôs hard
13:32:08 <tieTYT> typoclass: just to see if that works at least
13:32:14 <skp> I have a typeclass Foo a b
13:32:29 <skp> and I want to make all instances of Foo functors
13:32:42 <skp> instance (Foo a b) => Functor a where‚Ä¶
13:32:45 <skp> doesn‚Äôt work
13:32:59 <skp> any idea?
13:33:01 <elliott> you can't do that
13:33:03 <aCube> typeclass + tieTYT : Btw, the 1.8.1 version works for me
13:33:13 <elliott> the correct approach is class Functor a => Foo a b where...
13:33:14 <tieTYT> aCube: how do I use that?
13:33:29 <aCube> cabal install http-conduit-1.8.1
13:33:35 <aCube> cabal install http-conduit-browser-1.8.1
13:33:39 <aCube> sry, typo
13:33:43 <skp> huh elliott?
13:33:50 <skp> it‚Äôs like
13:34:00 <tieTYT> aCube: ok trying that
13:34:05 <skp> I don‚Äôt get it
13:34:07 <tieTYT> still errored for me
13:34:20 <tieTYT> let me paste
13:34:32 <elliott> skp: when finding typeclass instances the part before the => is not considered
13:34:35 <tieTYT> http://hpaste.org/84280
13:34:36 <elliott> what you did is say "every a is a Functor".
13:34:41 <elliott> only after the instance is picked is its constraints checked
13:34:48 <skp> that‚Äôs true, fuck
13:35:08 <skp> so I can‚Äôt make it an instance of Functor
13:35:21 <skp> it would be fancy though
13:35:26 <tieTYT> aCube: Do I have to unregister the previous attempt I had?
13:35:44 <aCube> tieTYT: i don't think so
13:37:03 <latro`a> can you have two identical instance heads that aren't universal with different constraints?
13:37:22 <scooty-puff> if stuck in the ST monad, is there any reason to believe ReaderT (STRef s state) (ST s) a may be more efficient then StateT state (ST s) a?
13:37:24 <latro`a> for example, instance Foo a => Bar (Baz a); instance Qwag a => Bar (Baz a)
13:37:38 <monoidal> latro`a: this won't work
13:37:42 <ParahSailin> typoclass: thanks
13:37:52 <latro`a> I figured as much
13:37:55 <skp> hihi
13:38:01 <aCube> tieTYT: you could try http-conduit too
13:38:08 <skp> (Functor a) => Foo a b
13:38:10 <skp> it works
13:38:10 <scooty-puff> i assume STRef does not support unboxed values at all?
13:38:11 <skp> hihi
13:38:13 <skp> so nice
13:38:17 <skp> thanks!
13:38:34 <monoidal> latro`a: when finding an instance of Bar (Baz a) the compiler does not care what is before =>. so it would attempt to use say the first instance without caring about the context
13:38:48 <tieTYT> aCube: I could, but it's not the level of abstraction I want to work at.  That's like saying you could use Network.HTTP instead of conduit
13:38:57 <aCube> yes, i know
13:39:02 <monoidal> latro`a: additionally, if you have instances for Foo X and Qwag X, it's unclear what to do on Bar (Baz X)
13:39:12 <latro`a> good point
13:39:32 <aCube> unfortunaly, I don't have ghc 7.4.2 on my machine :(
13:39:39 <tieTYT> aCube: what do you have?
13:40:11 <aCube> 7.6.2
13:40:24 <tieTYT> oh dude, I'll upgrade
13:40:31 <tieTYT> it's not like I'm saying I don't want to upgrade
13:40:33 <hpaste> beefcube pasted ‚Äúghc-mod install problem‚Äù at http://hpaste.org/84281
13:40:42 <aCube> no, ghc 7.4.2 is what haskell platform ships
13:40:48 <tieTYT> oh
13:40:49 <aCube> and many people recommend it
13:40:54 <aCube> afaik
13:40:56 <tieTYT> ugh this sucks
13:41:10 <typoclass> tieTYT: ok, i've now replicated your problem. if i do "cabal-dev install http-conduit-browser", it installs h-c-b-1.9.0 correctly, with the dependency of failure-0.2.0.1. but it if i use h-c-b-1.9.0 with failure-0.1.2, i get the error you pasted
13:41:35 <typoclass> tieTYT: i think you're fine with ghc 7.4, it works for me
13:41:54 <typoclass> ... question now is, what to do about it :-)
13:41:55 <RenJuan> yeah, it sucks but that's the price of having progress and stability at the same time
13:41:59 <tieTYT> i don't have cabal-dev
13:42:08 <supki> beefcube: you don't have ghc package probably
13:42:14 <supki> beefcube: try ghc-pkg list ghc
13:42:16 <tieTYT> why does using cabal-dev make a difference?
13:42:19 <beefcube> ok
13:42:35 * RenJuan never uses cabal-dev
13:42:38 <fryguybob> tieTYT: cabal-dev just does a local sandbox rather then installing for you user.
13:42:40 <typoclass> tieTYT: don't worry, i just did that because i installed into /tmp/somewhere/. it's just so i don't mess up my ~/.cabal directory
13:42:48 <beefcube> /home/jpf/local/ghc-7.4.2/lib/ghc-7.4.2/package.conf.d
13:42:49 <beefcube>    ghc-7.4.2
13:42:56 <typoclass> tieTYT: cabal-dev is just a wrapper that runs cabal with a few extra options
13:42:59 <supki> hmm
13:43:30 <fryguybob> tieTYT: What version of failure do you have installed? (cabal list failure)
13:43:34 <tieTYT> typoclass: ok so i shouldn't need to use cabal-dev, I just need to force it to use failure-0.2.0.1?
13:43:48 <typoclass> general question, can you install failure-0.1.2 and failure-0.2.0.1 in parallel, without going to cabal hell?
13:44:24 <fryguybob> typoclass: yes, but it depends on what depends on failure.
13:45:20 <typoclass> fryguybob: ok, would you recommend it? i'm no expert at cabal wrangling
13:45:40 <beefcube> supki: so clueless here, this seems so out of the blue, .ghc and .cabal the only state this would depend on?
13:45:58 <fryguybob> typoclass: I'm no expert either, but I never have cabal hell that gets talked about.
13:46:04 <skp> is there a way to convert Floating between each others?
13:46:08 <skp> (Floating a, b) => a -> b
13:46:18 <supki> beefcube: well, ghc package is bundled with ghc, it's ghc api
13:46:27 <supki> I'm not sure how can it be broken
13:46:30 <elliott> :t realToFrac
13:46:32 <lambdabot> (Fractional b, Real a) => a -> b
13:46:37 <elliott> skp: probably that is what you want
13:46:45 <skp> no
13:46:48 <fryguybob> tieTYT: You can tell cabal that you want to install h-c-b with the constraint that failure is 0.2.0.1.
13:46:50 <skp> I have Floating constraint
13:46:53 <aCube> :i fromRational . toRational
13:47:00 <aCube> :t fromRational . toRational
13:47:01 <fryguybob> tieTYT: It might then tell you that this will break some packages.
13:47:01 <lambdabot> (Fractional b, Real a) => a -> b
13:47:03 <skp> whaaaaaaaaaaaaaaaaaaat
13:47:10 <aCube> :o, that's the same
13:47:21 <skp> Floating are not Real
13:47:29 <fryguybob> tieTYT: What I usually do in that case is unregister the packages that it would break, then install with the constraint.
13:47:40 <typoclass> tieTYT: i'll tentatively say yes. try ¬´cabal install http-conduit-browser --dry-run --constraint="failure==0.2.0.1"¬ª. if it looks reasonable, remove the --dry-run and do it. i hope you sacrificed your goat this month ...
13:48:13 <typoclass> dcoutts: hello?
13:48:17 <otters> unReal
13:49:22 <tieTYT> looks like it'll work
13:49:32 <tieTYT> why didn't it install 2.0.1 in the first place?
13:49:46 <fryguybob> tieTYT: Because you already had the other version?
13:49:57 <tieTYT> oh
13:50:19 * hackagebot snaplet-fay 0.3.1.0 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.3.1.0 (AdamBergmark)
13:50:31 <tieTYT> ok no error with that
13:50:32 <fryguybob> tieTYT: (or you already had something further back that failure depended on)
13:50:38 <typoclass> tieTYT: you probably have failure-0.1.x installed already, and it preferred that one. arguably the problem is that the author of h-c-b should have said "needs failure >= 0.2", but actually has said "needs any version of failure"
13:50:41 <tieTYT> but i fear I just gave myself days of troubleshooting in the future
13:51:05 <supki> beefcube: oh, actually I see, it will break if you reinstall another core package like filepath/directory
13:51:09 <skp> so
13:51:19 <skp> there‚Äôs no way to convert Floating to Floating
13:51:20 <supki> beefcube: so yes, problem is probably in ~/.ghc somewhere
13:51:24 <skp> that‚Äôs pretty weird
13:51:49 <typoclass> tieTYT: that's a possibility, but the good news is, #haskell can usually figure out cabal issues quickly
13:52:03 <tieTYT> hrm..
13:57:02 <tieTYT> i'll email the maintainer
13:57:20 <typoclass> tieTYT: thanks, that's helpful of you
13:57:30 <fryguybob> tieTYT: There are indeed frustrating points getting libraries installed (especially when you involve Windows), and while I have spent a while trying to install a package occasionally I don't feel like this is a recurring problem for me.
13:58:27 <tieTYT> fryguybob: I guess i've just been having bad luck
13:58:32 <tieTYT> i mean tagsoup installed immediately
13:58:37 <tieTYT> that's the next thing I'll need to use
14:01:26 <typoclass> tieTYT: yep, afaik tagsoup is a haskell-only library (with no native part). it'll be easier to install
14:02:22 <srhb> I still haven't quite figured out how tagsoup is useful. Searching through the resulting soup still seems massively hard.
14:02:27 <tieTYT> i plan on writing haskell programs on windows because that's my main os and i like to write programs to fix problems i have
14:02:38 <srhb> Maybe I just haven't understood it yet.
14:02:41 <tieTYT> srhb: is there a different library I should use
14:02:42 <tieTYT> ?
14:02:50 <srhb> Nono, I'm pretty sure it's just me being dense.
14:03:02 <sproingie> one of the problems you'll now have is "this library doesn't work on windows"
14:03:13 <srhb> tagsoup should work on Windows?
14:03:14 * typoclass hasn't used tagsoup yet
14:03:23 <srhb> I don't think it uses anything out of the ordinary.
14:03:32 <tieTYT> sproingie: that doesn't happen very much w/ java IME.  And that's why i'm thinking of using clojure instead
14:03:51 <sproingie> well, java certainly does better there
14:07:38 <typoclass> tieTYT: it's true that that haskell has its weaknesses in the department of stuff being compatible across versions. i hope the community can partially compensate that, until it gets systematically better
14:08:19 <srhb> I also think we're getting less dependent on external libraries.
14:08:24 <srhb> At least in some departments.
14:08:30 <tieTYT> srhb: that would make things better
14:08:33 <tieTYT> for me
14:08:44 <typoclass> srhb: yeah, and i keep hearing that the upcoming cabal versions will also contribute
14:08:46 <srhb> Already now I feel like it's the exception rather than the rule.
14:08:57 <srhb> typoclass: Oh? I've no idea what's going on in cabal land.
14:09:09 <typoclass> (sandbox feature and inspiration from nix and whatnot)
14:09:11 <tieTYT> srhb: well IME, it's the rule rather than the exception :P  I hope that I just chose a bad first project idea
14:09:36 <srhb> tieTYT: I didn't follow the conversation, so I don't know what you've gone through.
14:10:10 <tieTYT> i've attempted to install encoding, wget, curl, http-conduit-browser and tagsoup
14:10:23 <tieTYT> only tagsoup worked on the first attempt
14:10:37 <typoclass> srhb: i don't really know about cabal development, it's just random stuff i keep hearing in #haskell
14:10:45 <tieTYT> i couldn't get wget and curl working.  I could install wget but it hangs when you use it.  Emailed the maintainer he said it's kind of obsolete
14:11:04 <tieTYT> i only figured out encoding w/ fryguybob's help
14:11:25 <srhb> Hm. I don't know about conduit, but curl and wget should probably be avoided since we can do all this without external dependencies.
14:11:51 <timtom> hi guys, i have a question concerning monad transformers and acid-state. is it better to ask here or in #happs?
14:11:53 <tieTYT> in theory yes, but there are other libraries that depend on them
14:12:06 <srhb> timtom: Either place :)
14:12:23 <typoclass> srhb: yup, that's the short version. tieTYT learned this the hard way
14:12:29 <tieTYT> for my task, this library seems better than http-conduit-browser: http://hackage.haskell.org/package/shpider-0.2.1.1
14:12:30 <srhb> typoclass: Ok :)
14:12:32 <tieTYT> but I can't use it :(
14:13:53 <timtom> so, i have a acidstate database that i want to run a query on. the query consists of several phases that can return Nothing in which case the result of the whole thing should be nothing. the query also uses randomization which is why i use a StateT System.Random.StdGen transformer around everything.
14:14:33 <timtom> should my type be: StateT System.RandomStdGen (Data.Acid.Query DBState) (Maybe Task) ?
14:14:53 <timtom> or should i use a maybeT instead of having the maybe on the inside?
14:15:04 <timtom> and if so, before or after the stateT
14:20:06 <supki> @unmtl StateT s m (Maybe a)
14:20:06 <lambdabot> s -> m (Maybe a, s)
14:20:14 <supki> @unmtl MaybeT (StateT s m) a
14:20:14 <lambdabot> s -> m (Maybe a, s)
14:22:26 <typoclass> announcement: i've made this new lambdacat http://i.imgur.com/4owJPOp.jpg
14:23:05 <monochrom> haha neat
14:23:35 <ion> heh
14:23:38 <typoclass> thanks
14:26:59 <monochrom> typoclass: may I add it to my http://www.vex.net/~trebla/haskell/sicp.xhtml ?
14:27:25 <typoclass> monochrom: sure! i'm flattered
14:34:50 <beefcube> supki: fixed after reinstalling same version of platform and ghc, strange
14:35:58 <hpaste> ‚ÄúAnonymous Coward‚Äù annotated ‚Äúghc-mod install problem‚Äù with ‚Äúghc-mod install problem (annotation)‚Äù at http://hpaste.org/84281#a84282
14:56:17 <Xaratas> Hi i have a stack overflow, which does not want to go away, i have tryed $!! and bangpatterns, but it does not help. Can you help me? http://hpaste.org/edit/84186
14:57:18 <otters> Xaratas: I believe those foralls are redundant
14:57:28 <monochrom> typoclass: it is used here! http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon
14:57:47 <elliott> Xaratas: (($!) (++) result shortlist) doesn't really do anything.
14:57:52 <elliott> that's result `seq` result ++ shortlist
14:58:01 <typoclass> monochrom: awwww :-) that's fantastic
14:58:03 <elliott> not only does it not force evaluation of shortlist, but (++) is already strict in its first argument
14:58:07 <Xaratas> elliott: yes that i lerned yesterday
14:58:25 <otters> does $! force evaluation of both arguments, or just the second, or what
14:58:51 <elliott> f $! x = x `seq` f x
14:58:59 <elliott> application is already strict in the function, by definition
14:59:06 <Xaratas> otters: that could be, the compiler said that is the type it finds out
14:59:07 <elliott> (how do you know what (f x) is without knowing what f is?)
14:59:27 <ion> Chuck Norris would know.
14:59:35 <typoclass> oleg knows
14:59:37 <monochrom> in "f $! x", either both are ignored for the same reason, or both are evaluated for different reasons
15:00:55 <monochrom> similarly, in "seq x y", either both are ignored for the same reason, or both are evaluated for different reasons
15:01:29 <monochrom> as a corollary, "seq x x" is simplified to "x"
15:01:34 <Xaratas> oooo
15:01:45 <Xaratas> thanks elliott
15:02:09 <shachaf> That's why I use force x = (x `seq` x) `seq` (x `seq` x)
15:02:25 <otters> so which one gets evaluated
15:02:27 <Xaratas> a, wait, argÖ wrong code
15:02:28 <c_wraith> to be sure that x gets evaluated when you evaluate x
15:02:35 <shachaf> c_wraith: Exactly!
15:02:37 <shachaf> Extra-sure.
15:02:47 <elliott> force x = x `seq` force x
15:02:47 <c_wraith> so sure that you've nearly nuked it from orbit
15:02:50 <elliott> infinite assurance.
15:02:57 <otters> @pl \x -> (x `seq` x) `seq` (x `seq` x)
15:02:57 <lambdabot> ap (seq . join seq) (join seq)
15:02:57 <shachaf> elliott: That's more like it.
15:03:01 <otters> nice
15:03:04 <monochrom> either both are ignored, or both are evaluated
15:03:06 <ion> force x = force x `seq` force x
15:03:08 <elliott> force' x = force' x `seq` force' x
15:03:11 <elliott> the ' is for strict.
15:03:23 <elliott> also I'm arresting ion.
15:03:28 <otters> @pl \x -> ((x `seq` x) `seq` (x `seq` x)) `seq` ((x `seq` x) `seq` (x `seq` x))
15:03:28 <lambdabot> ap (seq . ap (seq . join seq) (join seq)) (ap (seq . join seq) (join seq))
15:04:10 <ion> force x = force `seq` x `seq` force x
15:04:55 <ion> force x = seq `seq` force `seq` x `seq` force x
15:04:58 <otters> force x = force $! (x `seq` force $! x
15:05:12 <arkeet> > let f f = () in f ()
15:05:12 <otters> force = (`seq` seq)
15:05:14 <lambdabot>   ()
15:05:20 <arkeet> > let f f = f in f f
15:05:21 <otters> force = (seq $!)
15:05:22 <lambdabot>   No instance for (GHC.Show.Show (t0 -> t0))
15:05:22 <lambdabot>    arising from a use of `M80695...
15:05:26 <arkeet> :t let f f = f in f f
15:05:27 <lambdabot> t -> t
15:05:30 <sproingie> force = fix seq
15:05:31 <arkeet> :t let f f = f in f
15:05:32 <lambdabot> t -> t
15:06:00 <arkeet> > let f f = f in f 5
15:06:03 <lambdabot>   5
15:06:28 <c_wraith> yay shadowing
15:06:32 <Xaratas> ‰hm?
15:06:48 <monochrom> "f f = f" is renamed to "f x = x"
15:06:51 <quchen> Some heavy forcing going on here?
15:06:52 <otters> :t fix seq
15:06:53 <lambdabot> b -> b
15:07:01 <otters> > fix seq 3
15:07:03 <lambdabot>   3
15:07:06 <otters> it works
15:07:38 <monoidal> fix (seq 3), on the other hand...
15:07:48 <elliott> > let fix' f = f (fix' f) in fix' seq 3
15:07:50 <lambdabot>   3
15:08:14 <otters> > fix (seq 3)
15:08:18 <lambdabot>   mueval-core: Time limit exceeded
15:08:20 <otters> rats
15:08:24 <shachaf> > fix seq 3
15:08:26 <lambdabot>   3
15:08:28 <elliott> wait, how does that work?
15:08:33 <elliott> the fix' version.
15:08:59 <otters> > let fix' f = f $! (fix' $! f) in fix' seq 3
15:08:59 <shachaf> fix' seq 3 = seq (seq (seq ...)) 3
15:09:01 <lambdabot>   *Exception: stack overflow
15:09:04 <ion> > seq (fix id) 3
15:09:07 <lambdabot>   mueval-core: Time limit exceeded
15:09:10 <otters> no way
15:09:16 <elliott> shachaf: oh, I guess the first argument is immediately a lambda.
15:09:27 <quchen> I don't get it. fix seq 3 = seq (fix seq) 3 = seq (seq (fix seq)) 3 = ... - why does this terminate?
15:09:51 <c_wraith> because seq goes to WHNF, which means it stops at functions
15:09:51 <shachaf> quchen: Because fix seq is not _|_
15:09:54 <arkeet> because seq (fix seq) is in whnf
15:09:56 <shachaf> (Because seq is not a strict function.)
15:09:57 <otters> becasue magic
15:10:18 <Xaratas> otters wins
15:10:22 * hackagebot xmonad-contrib 0.11.1 - Third party extensions for xmonad  http://hackage.haskell.org/package/xmonad-contrib-0.11.1 (AdamVogt)
15:10:27 <otters> i didn't even spell it properly
15:10:35 <DanBurton> Having trouble wrapping my brain around how commuting monad transformer layers affects things. What's the difference between <<StateT s (MaybeT m) a>> and <<MaybeT (StateT s m) a>> ?
15:10:38 <quchen> shachaf: ah right, seq might evaluate to bottom but isn't bottom itself.
15:10:49 <shachaf> > let strictSeq x = x `seq` id in fix strictSeq 3
15:10:53 <lambdabot>   mueval-core: Time limit exceeded
15:11:02 <quchen> DanBurton: Use @unmtl!
15:11:04 <shachaf> DanBurton: @unmtl to the rescue!
15:11:10 <quchen> @unmtl StateT s (MaybeT m) a
15:11:10 <lambdabot> s -> m (Maybe (a, s))
15:11:25 <quchen> @unmtl MaybeT (StateT s m) a
15:11:25 <lambdabot> s -> m (Maybe a, s)
15:11:49 <DanBurton> ah
15:11:50 <monochrom> the difference is, if Nothing happens, do you still have a new state
15:11:50 <shachaf> DanBurton: In this case the difference is that in the second case, the state will be updated even in the case of failure (it looks like).
15:11:52 <quchen> In the second case, you always get a final state, whereas in the first case you may get no state and no value
15:12:28 <arkeet> @unmtl StateT s Maybe
15:12:28 <lambdabot> Plugin `unmtl' failed with: `StateT s Maybe' is not applied to enough arguments, giving `/\A. s -> Maybe (A, s)'
15:12:34 <arkeet> @unmtl StateT s Maybe a
15:12:34 <lambdabot> s -> Maybe (a, s)
15:12:41 <arkeet> @unmtl MaybeT (State s) a
15:12:41 <lambdabot> s -> (Maybe a, s)
15:12:47 <arkeet> @unmtl MaybeT (StateT s Identity) a
15:12:48 <lambdabot> s -> (Maybe a, s)
15:13:24 <monochrom> > seq ((&&) undefined) ()
15:13:26 <lambdabot>   ()
15:13:49 <shachaf> Most "two-argument functions" are not strict.
15:14:25 <shachaf> @quote ddarius partial
15:14:25 <lambdabot> No quotes match. That's something I cannot allow to happen.
15:14:56 <shachaf> @remember ddarius (f x) is a partial application iff f x == (curry (uncurry f) x)
15:14:56 <lambdabot> Done.
15:16:06 <DanBurton> > let (&&) b = if b then \x -> x else const False in seq ((&&) undefined) ()
15:16:07 <lambdabot>   *Exception: Prelude.undefined
15:16:13 <elliott> :t curry . uncurry
15:16:15 <lambdabot> (a -> b -> c) -> a -> b -> c
15:16:27 <lightquake> is it possible to say 'this function has type a -> b for all types a that are in a typeclass that has instances for types Int and String'?
15:16:59 <elliott> lightquake: um, I seriously doubt it
15:16:59 <monochrom> ddarius's rule is profound
15:17:06 <elliott> what on earth are you doing?
15:17:19 <arkeet> forall (C :: * -> Constraint) (C Int, C String, C a) => a -> b ?????
15:17:24 <arkeet> er, lowercase c.
15:17:26 <lightquake> arkeet: haha, that works
15:17:30 <arkeet> does it?
15:17:33 <lightquake> i just discovered that
15:17:39 <arkeet> and a .
15:17:41 <lightquake> well, not with that syntax, but you can do the moral equiavlent
15:17:46 <arkeet> ok
15:17:47 <lightquake> elliott: stupid stuff
15:17:59 <monoidal> in arkeet's definition, c might be ambiguous
15:18:06 <arkeet> true
15:18:14 <shachaf> monochrom: It captures lots of different things all at once!
15:18:17 <DanBurton> lightquake: I get the feeling that what you really want is a function of type (Int | String) -> b
15:18:24 <shachaf> The type change, the effect change, etc.
15:18:39 <lightquake> I have GADTs with typeclass constraints
15:18:40 <DanBurton> lightquake: which isn't possible in Haskell unless you use tagged unions, e.g. Either
15:18:40 <shachaf> In impure languages the distinction is much bigger, of course.
15:18:43 <arkeet> haha it works.
15:18:49 <arkeet> or at least, it doesn't complain.
15:19:02 <elliott> well lightquake could easily make (a -> b) where a has to be Int or String
15:19:04 <elliott> with a new typeclass
15:19:05 <arkeet> no kind annotation needed
15:19:20 <arkeet> elliott: but typeclasses are open
15:19:31 <DanBurton> only if they are exposed
15:19:32 <elliott> arkeet: sure, but module encapsulation lets you make closed typeclasses.
15:19:53 <arkeet> ehh
15:20:06 <arkeet> not really
15:20:27 <arkeet> they're still "open"
15:20:39 <DanBurton> The catch is that users cannot refer to a typeclass that is thusly "closed"
15:20:47 <Philippa> elliott: not that the system knows they're closed
15:20:48 <arkeet> but it's not closed closed, it's just "closed"
15:20:51 <arkeet> ^
15:21:02 <elliott> Philippa: sure. but it seemst o achieve the intended effect DanBurton wants.
15:21:09 <elliott> you can give a class that can only ever have instances for Int and String, anyway
15:21:12 <elliott> (modulo _|_)
15:21:26 <elliott> class Closed a where close :: (a ~ Int => r) -> (a ~ String => r) -> r
15:21:38 <arkeet> sure
15:21:39 <ion> > 42 `mod` undefined
15:21:41 <lambdabot>   *Exception: Prelude.undefined
15:21:41 <elliott> instance Closed Int where close p _ = p; instance Closed String where close _ q = q
15:22:08 <elliott> class Closed a => EvenClosederer a; instance EvenClosederer Int; instance EvenClosederer String and then don't export Closed.
15:22:34 <lightquake> basically here's the problem. i'm trying to represent x86 assembly instructions
15:22:37 <arkeet> instance Closed Bool where close = undefined
15:22:38 <elliott> then you have EvenClosederer a => (Int -> r) -> (String -> r) -> a -> r and "a" is pretty close to (Int | String) with no explicit tag
15:22:55 <elliott> arkeet: hence the EvenClosederer subclass. though I did say modulo _|_
15:22:58 <lightquake> and certain instructions can take, for example, a register or a memory location in their second argument
15:23:11 <lightquake> so i have a Mov a b typeclass that has instances for everything you can use mov on
15:23:11 <arkeet> elliott: the type system cares not about _|_
15:23:21 <elliott> arkeet: but the module system makes it irrelevant
15:23:23 <DanBurton> elliott: very interesting
15:23:26 <arkeet> not to the typechecker
15:23:29 <elliott> even with undefined you can't give an EvenClosederer instance.
15:23:32 <ocharles> Is there a built in fold for <|> ?
15:23:39 <arkeet> ocharles: asum
15:23:41 <ocharles> I want to try a list of alternatives from left to right, and wondered if that combinator existed
15:23:44 <ocharles> ta!
15:23:45 <elliott> arkeet: sure, but is that relevant for the problem of writing a function that you can pass either an Int or a String to but ntohing else?
15:23:49 <ocharles> :t asum
15:23:50 <lambdabot>     Not in scope: `asum'
15:23:50 <lambdabot>     Perhaps you meant one of these:
15:23:50 <lambdabot>       `Data.Foldable.asum' (imported from Data.Foldable),
15:23:56 <lightquake> i also have a GenericLoc data type that can either have a Literal, Register, or Addr
15:23:57 <ocharles> :t Control.Alternative.asum
15:23:58 <arkeet> one should be able to infer from forall c. (c Int, c a) that Int ~ a
15:23:59 <lambdabot> Couldn't find qualified module.
15:24:02 <ocharles> to hoogle
15:24:03 <arkeet> (by taking c = (~) Int
15:24:13 <arkeet> ocharles: from Foldable
15:24:13 <lightquake> so i want to be able to say 'if you can do something on a literal, register, or address, you can do it on a GenericLoc'
15:24:19 <elliott> I agree it's not full moral closedness
15:24:22 <DanBurton> :t Data.FOldable.asum
15:24:23 <lambdabot> Couldn't find qualified module.
15:24:24 <DanBurton> fml
15:24:26 <ocharles> yea, got it
15:24:32 <DanBurton> :t Data.Foldable.asum
15:24:34 <timtom> xD
15:24:34 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
15:24:40 <shachaf> @ty asumOf folded
15:24:41 <lambdabot> (Foldable f1, Alternative f) => f1 (f a) -> f a
15:25:10 <monochrom> lightquake: use Either (or equivalent) if you know all the finitely many cases
15:27:19 <lightquake> monochrom: but then i need to rewrite the 'applier' each time
15:27:35 <monochrom> what is applier?
15:27:51 <lightquake> so, for example, i have a Push constructor, and you can Push anything in the GenericLoc type
15:28:26 <lightquake> ‚Ä¶ actually wait, never mind.
15:28:35 <arkeet> oh right, 7.4 sucks with polykinds
15:32:08 <lightquake> wait, ok
15:33:09 <ctult> Is the binary created by Haskell able to be immediately ran on a foreign (non-Haskell-installed) platform?
15:33:15 <timtom> @unmtl StateT System.Random.StdGen (MaybeT (Data.Acid.Query DBState)) a
15:33:15 <lambdabot> System.Random.StdGen -> Data.Acid.Query DBState (Maybe (a, System.Random.StdGen))
15:34:22 <elliott> ctult: by default, haskell libraries are statically linked with GHC. but not the C libraries GHC depends on.
15:34:33 <elliott> *GHC binaries depend on, that is
15:35:29 <ctult> elliott: So if someone on Windows wanted to run a Haskell program, would they have to install anything, and if so, what?
15:36:06 <elliott> I guess a Windows binary will probably work out of the box. but don't quote me on that
15:36:12 <lispy> elliott: also, that's very likely to change in the (near?) future
15:36:12 <arkeet> I would guess so too.
15:36:33 <lispy> elliott: (change to dynamic by default for Haskell deps)
15:37:12 <ctult> lispy: could I still statically link for Windows platforms?
15:37:38 <elliott> lispy: right, though the trac wiki page on the subject makes me sceptical that it's so near
15:37:54 <ctult> I don't really care about mac linux, because they could just brew/apt-get/yum/whatever gmp if it's not installed.
15:38:10 <lispy> ctult: As I understand it, they will keep that ability... but also as I understand it, dynamic-by-default will fix bugs (by using the system linker) so I don't know how well the static linking will work
15:38:43 <lispy> ctult: But, when we get to that point, hopefully it will be a matter of collecting up your .dlls
15:39:01 <arkeet> what the hell am I doing.
15:39:09 <lispy> does windows have an equivalent to ldd?
15:39:09 <arkeet> >>> let f :: forall a. (forall c. (c Int, c a) => c) a => a -> Int; f x = x
15:39:10 <arkeet> ghc: panic! (the 'impossible' happened)
15:39:21 <arkeet> I don't know if this even makes sense.
15:39:21 <monoidal> arkeet: which ghc?
15:39:25 <arkeet> 7.6.1
15:39:52 <monoidal> arkeet: wow! also in head
15:39:56 <arkeet> haha
15:40:10 <monoidal> there were many kindFunResult bugs fixed
15:40:13 <srhb> Yep.
15:40:14 <arkeet> yeah, same on the feb. 16 nightly I have here.
15:40:30 <monoidal> i'll try to minimize the case
15:40:34 <arkeet> haha
15:40:34 <arkeet> ok
15:40:53 <arkeet> I just realized that what I wrote doesn't even make sense.
15:42:08 <arkeet> f :: (forall c. (c Int) => c) a => (); f = ()
15:42:11 <arkeet> smaller thing that errors.
15:42:20 <arkeet> the variable a can be replaced with () too
15:43:04 <arkeet> removing the constraint on c gives a malformed predicate error.
15:43:10 <arkeet> too bad.
15:43:14 <arkeet> I want to quantify over classes.
15:43:22 <arkeet> (I really don't.)
15:46:48 <monoidal> `type T = forall c. ((Num Int) => c) () => ()` is alternative
15:47:06 <arkeet> heh
15:47:56 <arkeet> ah, it doesn't matter whether you put the quantifier inside or outside the constraint.
15:47:57 <monoidal> `type T = ((Num Int) => Num) () => ()`
15:48:01 <arkeet> nice.
15:48:50 <arkeet> who would write such perverse and awful types, anyway? :p
15:48:54 <arkeet> besides elliott
15:49:47 <shachaf> edwardk?
15:49:54 <aristid> shachaf?
15:50:21 <arkeet> edwardk writes perverse but awesome types.
15:50:24 <arkeet> shachaf is shachaf.
15:50:40 <shachaf> what's that supposed to mean
15:50:41 <elliott> arkeet doesn't think my types are awesome. :(
15:50:45 <arkeet> :(
15:50:49 <shachaf> Hmm, that panics even in HEAD.
15:50:49 <monochrom> speaking of the edwardk
15:50:55 <arkeet> indeed.
15:51:05 <edwardk> ?
15:51:15 <arkeet> type T = ((Num Int) => Num) () => (). discuss.
15:51:24 <monochrom> <shachaf> edwardk?
15:51:31 <monochrom> also <arkeet> edwardk writes perverse but awesome types.
15:51:35 <quchen> arkeet: Was that a joke? Can't tell.
15:52:05 <monochrom> "achievement unlocked: summon edwardk"
15:52:14 <arkeet> :(
15:52:55 <quchen> Maybe it's edwardkbot, his private version of Lambdabot where adding an unsafeCoerce made it sentient by accident
15:53:04 <shachaf> monochrom: Watch your insolence, or you'll find yourself with a commit bit.
15:53:04 <edwardk> thats lensbot
15:53:13 <edwardk> it can message the lens channel without being there.
15:53:26 <shachaf> Well, anyone can do that.
15:53:52 <edwardk> the sound of its awakening was a somewhat anticlimactic broadcast message to every irc channel at the same time.
15:54:01 <arkeet> I don't think I've seen a real channel with mode -n before.
15:54:10 <srhb> edwardk: Oops :P
15:54:50 <monochrom> what did the broadcast message say?
15:54:52 <aristid> edwardk: hmm reminds me of some passage in one of the hitchhiker books :P
15:54:58 <edwardk> monochrom: "oops"
15:55:07 <monochrom> haha great message
15:55:15 <quchen> Brilliant. Good thing you weren't the first man on the moon ;-)
15:55:29 <shachaf> aristid: #haskell-lens isn't +anything
15:55:36 <edwardk> aristid: i was going for the final line of Job in the "Lawnmower Man" movie, but that works
15:55:53 <aristid> shachaf: ?
15:55:53 <quchen> Lawnmower man movie?
15:55:57 <quchen> You mean Braindead?
15:56:04 <cajla> Hi, i checked out Data.Trees.KdTree and Data.Octree, and they both are made to use Doubles everywhere
15:56:12 <shachaf> aristid: The channel mode.
15:56:13 <edwardk> http://www.imdb.com/title/tt0104692/
15:56:30 <cajla> why do some ppl write code that uses an very explicit type when it is not needed?
15:56:39 <aristid> shachaf: unlike elliott i am not a walking lexicon of channel modes
15:56:40 <cajla> For me it is a dealbreaker
15:56:40 <srhb> cajla: To make it easier to read, often.
15:56:53 <edwardk> cajla: i can empathize. it tends to make me write libraries
15:56:58 <typoclass> i was slightly confused after misreading 'monochrom' as 'edwardk' in the message "<shachaf> monochrom: Watch your insolence, or you'll find yourself with a commit bit."
15:57:12 <elliott> aristid: I know about channel modes?
15:57:26 <aristid> elliott: well one of your elliott gang surely does
15:57:34 * edwardk knows how to google for them. does that count?
15:57:39 <shachaf> cajla: What is a very explicit type?
15:57:43 <cajla> Double
15:57:45 <elliott> aristid: true.
15:57:51 <shachaf> edwardk: Shh, don't ruin the illusion.
15:58:04 <yitz> last line of Job: And Job died, old and full of days.
15:58:05 <elliott> edwardk: hmm, did you just hone the single skill of googling things really fast, and that's how you look like you know lots of things?
15:58:13 <elliott> thus saving yourself an almost infinite amount of work.
15:58:16 <edwardk> =)
15:58:27 <edwardk> I usually say that Google is the smart half of my brain.
15:58:42 <quchen> Google makes up half of your brain!? That explains it
15:58:56 <sproingie> yitz: dude, spoilers!
15:58:58 <sproingie> :)
15:59:12 <cajla> tbh it is not about googling fast as much as being fast to google
15:59:14 <yitz> sproingie: not really. happens to everyone.
15:59:26 <monoidal> arkeet: given Dict :: Constraint -> * the bug can be triggered with type T = Dict ((Num Int => Num) ())
15:59:39 <monochrom> the opposite of nailing to Double is generalizing to polymorphism over an obfuscated class hierarchy. I would rather take Double then.
15:59:53 <edwardk> monoidal: which bug?
16:00:09 <monoidal> edwardk: head and 7.6 panic on a lovely type T = ((Num Int) => Num) () => ()
16:00:13 <shachaf> edwardk: type T = (Show () => Show) () => ()
16:00:16 <shachaf> I guess he's gone.
16:00:27 <quchen> What is that type?
16:00:29 <cajla> monochrom: how do i represent 16,777,217 with a 32b double?
16:00:37 <quchen> It looks highly awkward, but what does it *mean*?
16:00:38 <yitz> oh oh i hope i didn't do that to edwardk
16:00:45 <shachaf> What is a 32b double?
16:00:54 <c_wraith> sounds like a Float, to me
16:01:09 <cajla> That is machine specific
16:01:14 <monochrom> the movie character is Jobe, not Job.
16:01:47 <elliott> yitz: not everyone dies old
16:02:01 <monochrom> his last line was either "ah, a backdoor!" or a lot of phones ringing simultaneously, depending on how you look at it
16:02:31 <yitz> elliott: true. Job did well then.
16:04:35 <edwardk> re generality:
16:04:36 <DanBurton> shachaf: it is a floating point number in some system where standard precision is 16b?
16:04:40 * edwardk tends to prefer to just do everything that i can with a completely abstract type, falling back on a class or an actual value depending on how painfully specific my needs are about the properties of that type.
16:04:51 <shachaf> edwardk: type T = (Show () => Show) () => ()
16:05:05 <edwardk> shachaf: that typechecks?
16:05:10 <shachaf> No, it panics.
16:05:12 <shachaf> Even in HEAD.
16:05:17 <edwardk> well, that is something at least ;)
16:05:20 <shachaf> That's the thing that monoidal mentioned before.
16:05:42 <edwardk> had it typechecked i'd have been disturbed
16:05:53 <edwardk> panicking just means someone didn't consider it
16:05:59 <shachaf> Why shouldn't it type-check?
16:06:11 <edwardk> (=>) :: Constraint -> * -> *   effectively
16:06:14 <DanBurton> what does T even mean?
16:06:25 <edwardk> so the right hand side there was ill-kinded.
16:06:27 <elliott> shachaf: instance Num (Show a => T a) -- should that typecheck?
16:06:34 <yitz> does anyone know why ghc doesn't provide a standard type for 80 bit fp numbers, given that those have been supported in hardware on virtually every platform for ages?
16:06:35 <monoidal> DanBurton: T is just a placeholder
16:06:38 <edwardk> i say 'effectively, because instances are written with a different signature
16:06:57 <DanBurton> monoidal: what I meant was, what does the right-hand side of that "type T =" mean?
16:07:25 <shachaf> (=>) :: Constraint -> k -> k, clearly
16:07:51 <edwardk> good luck assigning meaning to that
16:08:04 <elliott> (Show () => (=>)) (Show a) (a -> String)
16:08:07 <elliott> Or even
16:08:09 <monoidal> DanBurton: i have no idea. it was found by arkeet during experiments with forall (c :: Constraint)
16:08:11 <elliott> (Show a => (=>)) (Show a) (a -> String)
16:08:11 <shachaf> Meaning is for people like conal.
16:08:38 <edwardk> i can see the bounded kind polymorphism for Star,Constraint like i proposed using for the kind of the type (,), but when you start talking about * -> *, etc in there for k it becomes nonsense quickly
16:09:04 <bitonic> I can‚Äôt imagine what putting constraints on non-value things
16:09:05 <bitonic> yeah
16:10:20 <edwardk> the other problem is that if you permit k = Constraint in any context other than an instance declaration you need to define what (Eq a => Ord a) => ‚Ä¶ means
16:10:31 <elliott> edwardk: clearly it should mean "implies".
16:10:40 <elliott> (Ord a => Eq a) holds, of course.
16:10:42 <edwardk> (er instance or class)
16:10:43 <edwardk> i tried to make that work, i'm not that smart
16:10:49 <silver> yitz, http://hackage.haskell.org/trac/ghc/ticket/3353
16:10:50 <elliott> but what about ((c a, c b) => c (a, b))?
16:10:54 <elliott> it holds for Show and Eq!
16:11:12 <edwardk> the problem is for that you really want polymorphism
16:11:15 <elliott> oh, and those aren't foralled.
16:11:24 <edwardk> yeah
16:11:37 <edwardk> and you can't put the quantifier in the constraint
16:12:15 <elliott> foo :: ((c a, c b) => c (a, b), Show a, Show b) => (forall a. c a => a -> String) -> (forall a. Show a => (c a => (String, String)) -> (String, String)) -> a -> b -> (String, String)
16:12:25 <monoidal> (interestingly, GHC once had a bug when you could put a quantifier in the constraint, and due to some strange coincidence it somehow worked.)
16:12:36 <elliott> foo what help a b = help (help (what (a, b)))
16:13:10 <hpc> monoidal: that's fantastic
16:13:35 <elliott> monoidal: they're hiding the functionality from us?!
16:13:36 <yitz> silver: thanks, that explains it. too bad.
16:14:59 <monoidal> hpc, elliott: http://hackage.haskell.org/trac/ghc/ticket/7019#comment:3
16:15:50 <elliott> monoidal: hmm, but did it fail to typecheck if the quantification wasn't satisfied?
16:16:14 <monoidal> elliott: i don't know
16:16:24 * elliott wonders why something like the skolemy solution in edwardk's constraints package wouldn't work for checking forall constraints...
16:16:38 <yitz> @. djinn type \what help a b -> help (help (what (a, b)))
16:16:40 <lambdabot> f a b c d = b (a (c, d))
16:17:21 <ctult> Is there any port of Haskell to .NET, even if it's just syntactical?
16:18:53 <shachaf> Haskell has a long history with .org (and .edu, I suppose)
16:19:22 <ctult> lol
16:19:38 <ctult> trololol
16:19:46 <Jeanne-Kamikaze> why would you port haskell to .NET ?
16:20:03 <ctult> Jeanne-Kamikaze: XNA?
16:20:06 <ctult> WPF?
16:20:08 <Jeanne-Kamikaze> xna is dead
16:20:09 <shachaf> lispy was working on something but I don't think much has happened yet.
16:20:11 <ctult> LINQ?
16:20:18 <shachaf> Anyway I don't know what a syntactic poort of Haskell is.
16:20:31 <DanBurton> something like Frege on the JVM, I imagine
16:20:40 <ctult> Jeanne-Kamikaze: Okay, do YOU want to tell all the Xbox developers that?
16:20:47 <Jeanne-Kamikaze> sure
16:21:14 <Jeanne-Kamikaze> seriously, it's dead, it's part of the windows 8 "windows sdk" move
16:21:24 <ctult> IK it's dead
16:21:30 <ctult> But it's still being used. ;)
16:21:48 <Jeanne-Kamikaze> in any case, no serious developer should depend on any proprietary technology
16:22:13 <elliott> Jeanne-Kamikaze: that's a pretty exclusionary definition of "serious developer".
16:22:15 <ctult> OK, but if it's dead then what cross-platform kit should be used?
16:22:34 <srhb> It's a pretty exclusionary definition of "developer" even
16:22:46 <sproingie> xna is hardly cross platform
16:22:51 <Jeanne-Kamikaze> ctult, one that is free/libre
16:23:23 <ctult> Jeanne-Kamikaze: For Xbox...
16:23:26 <elliott> "one that is X" is not an answer to "what Y".
16:23:29 <Canar> <Steve_Ballmer> developers developers developers developers
16:23:40 <typoclass> ctult: what exactly are you asking for? you're trying to interact with .net code from haskell code ...?
16:23:45 <Jeanne-Kamikaze> well, maybe nothing exists yet, so I cannot give a Y
16:24:10 <Jeanne-Kamikaze> ctult, you should even question yourself why are you developing for a closed platform
16:24:14 <srhb> You could have just said that. :P
16:24:17 <sproingie> no haskell, but F# is a decent enough language
16:24:26 <ctult> typoclass: That question would be void if I was able to make a cross-platform (including Xbox) game.
16:24:28 <typoclass> ctult: at any rate, you could be interested in f#. i haven't looked at it, but supposedly it's inspired by haskell quite a bit
16:24:30 <srhb> And maybe stop imposing philosophy on others, too.
16:24:35 <elliott> Jeanne-Kamikaze: can we not do this? I mean, this is off-topic to start with. but we don't need a pointless closed/open software flamewar.
16:24:39 <shachaf> Jeanne-Kamikaze: I'm not sure this conversation is very productive.
16:24:45 <Jeanne-Kamikaze> ok
16:24:55 <ctult> Jeanne-Kamikaze: XNA is not a closed platform, it works on Mono.
16:25:07 <Jeanne-Kamikaze> and mono is held under the "microsoft promise"
16:25:11 <Jeanne-Kamikaze> it's not even technically legal
16:25:21 <sproingie> platform of choice for mono would be Unity
16:25:21 <silver> ctult, so you want run haskell code on xbox?
16:25:34 <ctult> silver, with some sort of game engine, yes.
16:25:44 <Jeanne-Kamikaze> so one day microsoft comes and says, all your mono projects are belong to us
16:26:05 <sproingie> Jeanne-Kamikaze: allow me to join in the chorus of those asking you to drop it
16:26:08 <ctult> Jeanne-Kamikaze: I don't think that's going to happen.  Microsoft USES mono.
16:26:16 <srhb> ctult: You, too, though.
16:26:20 <ctult> Yeah, I shouldn't argue anymore
16:26:25 <srhb> This discussion is neither productive nor conducive to a good atmosphere.
16:26:46 <sproingie> anyway, no haskell for .NET or otherwise targeting xbox.  you might be able to do F#, not sure.
16:26:50 <ctult> Okay, well, I need a Haskell game engine that works on Win/Mac/Lin/Xbox
16:26:58 <sproingie> F# might not work with the compact framework used by the xbox
16:27:02 <ctult> I dislike Unity.
16:27:11 <ctult> It feels awkward and monolithic.
16:27:12 <sproingie> ctult: there is no such beast, and none forthcoming
16:27:15 <elliott> there isn't much in terms of ready-made haskell games engines (though there are a couple I think, not sure how complete or updated they are)
16:27:17 <srhb> There aren't a whole lot of choices out there.
16:27:29 <ctult> I could just do it directly in OpenGL, too.
16:27:36 <silver> I doubt decent haskell engine exists for any platform
16:27:37 <elliott> there's OpenGL, yes
16:27:40 <sproingie> you could, tho that *still* rules out xbox
16:27:56 <elliott> tehre is http://hackage.haskell.org/packages/archive/pkg-list.html#cat:game%20engine
16:27:57 <typoclass> what did the nikki guys use? nikki supports at least 2 or 3 platforms, doesn't it?
16:27:59 <elliott> *there
16:28:04 <elliott> typoclass: they wrote their own Qt binding(!)
16:28:06 <sproingie> only thing i've seen that qualifies as game engine is lambdacube
16:28:18 <sproingie> and lambdacube looks like it has a ways to go
16:28:22 <typoclass> elliott: that sounds decidedly funky
16:28:22 <elliott> hmm, that category is incomplete.
16:28:32 <elliott> right, LambdaCube was the one I was thinking o
16:28:34 <elliott> f.
16:28:46 <srhb> Nikki used QTHaskell
16:28:50 <hpc> elliott: "this category is incomplete; you can help by expanding it"
16:28:52 <srhb> Ah, elliot said so.
16:29:07 <srhb> How horrible is SDL?
16:29:10 <sproingie> i'm interested in doing some haskell opengl stuff too, but i'm well aware i'll have to be doing it mostly from scratch
16:29:14 <monoidal> arkeet: report the bug to ghc trac?
16:29:25 * elliott has used SDL as a windowing library for OpenGL (in Haskell). it worked ok
16:29:45 <sproingie> if you're doing opengl, i'd recommend GLFW or GLFW-b, not SDL
16:29:57 <ctult> Does Unity have mod/custom map support?
16:30:07 <sproingie> it does if you write it
16:30:25 <sproingie> unity is not a game.  perhaps you'd prefer to mod an existing game.
16:30:45 <ctult> I am making a game, and I want mod/custom map support for it.
16:30:45 <sproingie> if it has a C API, you could mod it in haskell
16:31:02 <silver> unreal engine and possibly cryengine will run on xbox
16:31:13 <Jeanne-Kamikaze> oh, someone recommending GLFW over GLFW-b :)
16:31:16 <sproingie> haskell libs for UE would be righteous
16:31:17 <silver> they're available for free with limitations
16:31:18 <ctult> silver: are they good for 2D?
16:31:30 <silver> don't thinks so
16:31:52 <silver> you can pseudo-2d I guess
16:31:59 <silver> can do*
16:32:35 <Jeanne-Kamikaze> sproingie, any particular reason why you prefer the non-b GLFW ?
16:32:40 <ctult> I guess I don't *need* Xbox support ;_;
16:32:48 <sproingie> Jeanne-Kamikaze: i don't, i was just trying to be noncommittal :)
16:33:24 <sproingie> chopping out xbox leave three relatively open intel platforms with lots of options
16:33:44 <sproingie> haskell will do fine on all of them.  still no real game engines for haskell, mind you.
16:33:51 <srhb> Not _that_ many options, still. Unless you want to do your own bindings.
16:34:08 <ctult> Could I make an Ogre binding?
16:34:18 <sproingie> you could, it's also been done already
16:34:20 <srhb> There is one.
16:35:04 <monochrom> HGame3d-Ogres-something
16:35:19 <monochrom> along with other HGame3d-other-things
16:35:27 <srhb> It's Windows only though.
16:35:36 <monochrom> they are just released and announced today! you're right on time
16:36:13 <ctult> It seems as if using Haskell just complicated my life...
16:36:32 <srhb> ctult: Haskell isn't incredibly mature in this area wrt. libraries.
16:36:34 <silver> just use c++
16:37:04 <ctult> c++ has horrible mod support.
16:37:09 <sproingie> you can always use FFI to add haskell in "soft" layers like scripting
16:37:21 <ctult> hmm
16:37:21 <silver> mod?
16:37:22 <srhb> ctult: Huh?
16:37:23 <sproingie> not that this is particularly easy, but it's doable
16:37:37 <srhb> It doesn't make sense to say a language has horrible mod support, I think :P
16:37:50 <ctult> well, I would need to make a cross-platform VM.
16:37:55 <ctult> Then I would need to tie it in
16:37:57 <monochrom> some people use "language" to mean "community"
16:37:59 <ctult> and make a language for it.
16:38:05 <srhb> monochrom: Ah, yes.
16:38:12 <silver> why
16:38:34 <monochrom> example: haskell is friendly, c is snobbish :)
16:38:42 <srhb> :P
16:38:45 <sproingie> considering all the existing AAA engines use C++, i'd say it does modding just fine
16:38:59 <monochrom> "I just talked to haskell today and they were very welcoming"
16:39:18 <srhb> monochrom: What, you don't say hash-haskell?
16:39:31 <monochrom> I don't know hash-haskell
16:39:34 <sproingie> "we are ALL haskell"
16:39:50 <shachaf> sulamit-haskell
16:39:56 <silver> don't talk to haskell when other people can hear you
16:39:56 <monochrom> but I talk to my computer everyday
16:40:47 <ctult> That was why I wanted to use .NET
16:40:57 <ctult> Because I could reflect in DLLs.
16:41:08 <silver> I reflect in twitter
16:41:12 <silver> jk
16:41:25 <sproingie> you might want to work on making your goals a little more concrete
16:41:35 <silver> ctult, why is c++ isn't cross-platform enough for you?
16:41:36 <sproingie> and take a risk on learning something you eventually decide you don't like and discard
16:41:43 <silver> oh nvm, it's  a bit offtopic
16:41:47 <ctult> silver, it is...
16:42:26 <sproingie> just pick up a cheap off the shelf engine like unity or torque and have at it
16:42:27 <DanBurton> of course these statements about Haskell are much more interesting when you are in the mindset of talking about SPJ's cat
16:42:57 <srhb> Haskell is very fluffy. Haskell (probably) doesn't understand Monads.
16:43:02 <typoclass> DanBurton: the cat is named haskell? awwww! :-)
16:43:06 <monochrom> SPJ's cat may be evaluated or unevaluated :)
16:43:19 <silver> or both
16:43:22 <johnw> is it lazy?
16:43:24 <silver> if it's in the box
16:43:24 <DanBurton> @faq can Haskell be extremely adorable?
16:43:24 <lambdabot> The answer is: Yes! Haskell can do that.
16:43:36 <johnw> it says, "I can haz Haskell?"
16:43:48 <johnw> wait, I iz Haskell!
16:43:48 <typoclass> can has burrito?
16:44:00 <sproingie> monads are like litterboxes?
16:45:06 <ctult> Could I intergrate Torque 2D with Haskell?
16:45:39 <johnw> monad cat: http://whitsblog.com/wp-content/uploads/2012/05/2676840148_3112bffbba.jpg
16:46:20 <typoclass> johnw: thanks, excellent. are you aware of http://i.imgur.com/4owJPOp.jpg ?
16:46:58 <johnw> hahaa
16:47:29 <srhb> ctult: Most likely. I don't see why not
16:47:34 <srhb> ctult: It's probably a rather big effort.
16:47:46 <johnw> ergh, i've been stuck in monad transformer purgatory for hours today
16:47:55 <johnw> trying to get my brain around monad-control
16:48:34 <typoclass> srhb: the project as ctult has described it so far sounds monumental
16:48:40 <srhb> Yes.
16:48:41 <monochrom> yeah, monad-control is going to take some work, since it makes exception handling penetrate your State or Reader etc
16:49:36 <ctult> I think I will just stick with OCaml.  I even think it's embeddable.
16:49:40 <ctult> D:
16:51:34 <elliott> ctult: ocaml has game engines?
16:55:09 <hpaste> johnw pasted ‚Äúmonad-control.hs‚Äù at http://hpaste.org/84286
16:55:25 <johnw> so, that code's doWith doesn't type check
16:55:33 <johnw> says it can't unify m with t m
16:55:53 <johnw> even just a clue would be cool...
16:56:27 <ctult> elliott: I could embed OCaml into something like Torque or Unigine
16:56:43 <elliott> I'm sure you could do the same for Haskell...
16:57:48 <ctult> elliott: I am actually thinking about using Unity.
16:57:58 <ctult> And now I'm back at square one.
16:58:00 <DanBurton> well you can do anything with enough knowledge and elbow grease..
16:58:14 <ctult> Could I embed Haskell into .NET?
16:58:27 <DanBurton> with enough knowledge and elbow grease
16:58:33 <DanBurton> I don't see why not
16:58:37 <ctult> ...on Xbox?
16:58:48 <hpc> you have some weird elbows
16:58:49 <DanBurton> @faq what say ye?
16:58:49 <lambdabot> The answer is: Yes! Haskell can do that.
16:59:12 <ctult> @faq is DanBurton lying?
16:59:12 <lambdabot> The answer is: Yes! Haskell can do that.
16:59:22 <luite> ctult: just write some ghc backend, it's so easy
16:59:24 <ctult> lol that made no sense
16:59:31 <ctult> luite: For Xbox
16:59:33 <ctult> ?
16:59:45 <luite> ctult: sure, they got one working for iPhone too
17:00:39 <silver> and how about one working for android?
17:02:11 <lemao> how do I convert from a GHC Word to an Int?
17:02:36 <monochrom> fromIntegral
17:05:33 <johnw> DanBurton: i actually tried using Tardis the other day, that's some crazy stuff
17:06:16 <DanBurton> Oh that reminds me, I need to clean up and release reverse-state
17:16:05 <typoclass> ok i'm obviously making an idiotic mistake ... "doWith action = control $ \run -> run action" is not the same as "doWith action = control f where f run = run action". but why?
17:17:12 <c_wraith> typoclass: is it because let/where bindings get monomorphised in recent versions of ghc?
17:18:26 <typoclass> c_wraith: hm, thanks for the idea. i have actually turned NoMonomorphismRestriction on and off, but that didn't make a difference
17:18:58 <monochrom> also, GHC gives $ a special typing treatment not implied by the nominal type "(a -> b) -> a -> b"
17:19:15 <int-e> typoclass: I think it's NoMonoLocalBinds in this case
17:19:46 <sm> hey all.. how can I tell cabal install to ignore user-installed packages ? I'd like to check that it could find an install plan, but I don't want to actually reset my packages
17:19:47 <elliott> hmm, I heard ($)'s hack got removed or something.
17:19:50 <elliott> perhaps replaced by a worse hack
17:20:02 <monochrom> so that $ is typed the same way built-in function application is. so that for example "runST x" and "runST $ x" are typed the same way
17:20:04 <sm> --help says something about --package-db=clear but it seems to no longer work
17:20:39 <monochrom> --dry-run tells you install plan and installs nothing
17:20:40 <typoclass> there seems to be no difference between ( ) and $, if that is relevant
17:20:43 <int-e> typoclass: and btw you have not really told us what's going wrong.
17:20:52 <typoclass> monochrom: oh, that's interesting
17:20:58 <Saizan> sm: --global ?
17:21:36 <sm> monochrom: yes, but I'd like it to ignore installed (user) packages, so I can see what install plan it would find with a clean package db
17:21:45 <sm> hmm
17:21:50 <monochrom> then add --global
17:21:55 <geekosaur> ($)'s hack was replaced with another hack for a while involving impredicativetypes, but it was serious fail so the original hack was put back
17:21:58 <geekosaur> IIRC
17:22:59 <sm> yes that seems essentially what I want, thanks both
17:25:33 <hpaste> typoclass annotated ‚Äúmonad-control.hs‚Äù with ‚Äúmonad-control.hs (annotation)‚Äù at http://hpaste.org/84286#a84287
17:25:54 <typoclass> int-e: i've prepared a hpaste with the errors ^^
17:32:11 <int-e> typoclass: wild; I get a type error with both versions (ghc 7.6.2 + monad-control-0.3.1.4)
17:32:29 <johnw> typoclass: i think i'm closing in on my problem, and it's mostly unrelated to what I pastde
17:34:12 <typoclass> int-e: oh, that's probably it, i used ghc 7.4
17:39:00 <crdueck> looking at the Vector Stream library, its essentially a CPS iteree like conduit or pipes. I know Streams are used to eliminate intermediate data structures and other optimizations, so iteree libraries must also have these same effects right?
17:39:29 <int-e> typoclass: it's still strange; 7.4.1 says "Couldn't match type `m' with `t m'" for the  control $ \run -> run action  version for me.
17:39:52 <int-e> typoclass: (same monad-control version)
17:40:37 <typoclass> int-e: right, that's the same for me. $ and () make no difference, both give the error from hpaste line 26
17:41:51 <int-e> typoclass: so the "change in behaviour" is just a different formulation of the type error?
17:43:14 <duairc_> Does GHC give any guarantees about when a ForeignPtr will be finalised?
17:43:14 <int-e> typoclass: (RunInBase m b  is a type alias:  (forall a. m a -> b (StM m a)); if you unfold that, you'll see that trying to match  RunInBase m b0 with t m a -> t0 will indeed try to match m with t m.
17:44:05 <hpaste> typoclass annotated ‚Äúmonad-control.hs‚Äù with ‚Äúmonad-control.hs (annotation) (annotation)‚Äù at http://hpaste.org/84286#a84288
17:45:12 <typoclass> int-e: yeah the two errors for ( ) vs. $ seem identical, except "in the first argument of 'run', namely 'action'" vs. "in the expression" (see paste)
17:45:15 <duairc_> (Nevermind, I just saw this: "There is no guarantee of promptness")
17:47:17 <typoclass> int-e: anyway, thanks for checking
17:47:59 <hpaste> afsd pasted ‚Äúfds‚Äù at http://hpaste.org/84289
17:48:49 <joker_89> how can i do this code better because i have a list of 4 items and i want to itarete each one but i dont know how and i do this:? http://hpaste.org/84289
17:49:19 <joker_89> the first item don care, and then the 1, 2 and 3 index positions are important for see if i need to return 1 or Nothing
17:49:35 <hpaste> afsd pasted ‚Äúfds‚Äù at http://hpaste.org/84290
17:49:42 <joker_89> sorry i update: http://hpaste.org/84290
17:50:35 * hackagebot rev-state 0.1 - Reverse State monad transformer  http://hackage.haskell.org/package/rev-state-0.1 (DanBurton)
17:50:48 <DanBurton> there I uploaded it :P
17:53:17 <int-e> joker_89: next time please either add a sensible nick and title or don't select the #haskell channel
17:55:12 <joker_89> why int-e is very esential?
17:55:51 <hpaste> int-e annotated ‚Äúfds‚Äù with ‚Äúfds (annotation)‚Äù at http://hpaste.org/84290#a84291
17:56:29 <int-e> joker_89: we get these announcements on the channel; they are annoying if they do not convey any useful information
17:57:06 <joker_89> ok sorry
17:57:11 <joker_89> but whatn can i do?
17:57:28 <DanBurton> joker_89: I find your code to be incomprehensible
17:57:51 <typoclass> joker_89: int-e has made a suggestion for you. it's below the code that you pasted
17:58:06 <DanBurton> who is teaching the newbies to use list comprehensions mixed with !! these days?
17:58:18 <DanBurton> Not the first time I've seen this flavor of odd coding
17:58:26 <int-e> joker_89: see annotation for a suggestion. (but I have not thought too deeply about the code, I don't know what you're doing exactly.)
17:58:58 * int-e is also confused why the index starts at 1.
17:59:05 <int-e> > [1,2,3] !! 1
17:59:06 <lambdabot>   2
17:59:54 <joker_89> yes because i only want the 3 last items
17:59:57 <joker_89> not the head
18:00:21 <int-e> (all I've really done is get rid of the code duplication. the code makes just as much sense as before.)
18:00:43 <joker_89> mm i have a [[Carta]] list wich i need to itareate (there are 4 lists inside the list) and then a list of 4 'Cartas'
18:01:51 <joker_89> i want to do it recursive but then i dont know how to reutrn 1, 2 or 3 like the conditions
18:01:53 <DanBurton> what do you mean by "iterate"? What do you need to *do* with each quadruplet of Cartas
18:02:52 <typoclass> > let x = [1..22] in drop 10 x ++ take 10 x
18:02:55 <lambdabot>   [11,12,13,14,15,16,17,18,19,20,21,22,1,2,3,4,5,6,7,8,9,10]
18:02:56 <joker_89> i neeed to pass in the "jugades" function the next position of the [[Cartes]] and the positions before of the [Carta]
18:02:59 <kvda> Are there any other syntax highlighting libs besides 'highlighting-kate' to look into?
18:03:56 <joker_89> typoclass why you put that?
18:04:26 <DanBurton> joker_89: what do you mean "positions"?
18:04:30 <typoclass> joker_89: i was wondering about line 7 of your code. it has something very similar
18:04:57 <typoclass> joker_89: lambdabot told me what the result is :-) it's a little clearer now for me
18:04:58 <joker_89> position fo the list : position 0,1,2,3,4..
18:05:05 <joker_89> but i have only 4 positions always
18:05:07 <DanBurton> why is the position of a Cartes in the list of lists relevant? Does a Cartes have a different meaning if it is in a different posiiton?
18:05:46 <joker_89> because the same position in [[Cartes]] and [Cartes] means a relation between
18:06:16 <int-e> > let xs = [1..22] in (cycle xs !! (10 + 15), (drop 10 xs ++ take 10 xs) !! 15)
18:06:19 <lambdabot>   (4,4)
18:06:37 <joker_89> well, the funciton recives 4 lists of the cards of 4 players, then the type of card that win the game , then a list of the cards in the table (max are 4)
18:07:09 <pdxleif> If Haskell is "The Taliban version of ML", what's e.g. Agda?
18:08:09 <monochrom> the taliban version of cobol
18:08:12 <Radish> Hey is it possible to access an infinite list from the definition of that list without keeping around lagged memory?
18:08:13 <hpaste> ‚Äúmatch on fixed-size lists‚Äù pasted ‚ÄúDanBurton‚Äù at http://hpaste.org/84292
18:08:20 <joker_89> i have a where because i rearoder the [[Cartas]] for have the same order than [Carta]
18:08:43 <elliott> Radish: what do you mean? ones = 1 : ones won't use any memory when you go through it, for instance.
18:08:43 <Radish> like say I wanted to do fibonacci or something can I access the previous elements without keeping them around?  its probably slow if i can...
18:08:52 <joker_89> and then i need to iterate each [Carta] and each Carta at the same position
18:09:02 <elliott> and if your list is defined reasonably, it'll be garbage collected if you consume it unless you keep a reference to the old list
18:09:10 <elliott> (a top-level definition counts as a reference here)
18:09:16 <Radish> I'm trying to do a primes list
18:09:30 <Radish> I'm doing a sieve
18:09:53 <yitz> joker_89: what does jugades do?
18:09:58 <monochrom> Radish: it can be done, but you have to carefully code for it, i.e., do not allow anyone to hold on to unneeded prefixes
18:10:10 <Radish> I start each number from it's square but my algorithm will be a lot faster if I don't have to keep the primes around which when squared are more than how far along I am
18:10:48 <joker_89> retunr a list of Cards that are paremited to play, so i check if every player plays correctly
18:10:49 <Radish> monochrom: what's an "unneeded prefix"? sorry I'm still just getting the hang of haskell especially the jargon
18:11:25 <joker_89> i pass to te function jugades the cards list of the player with the card which put on the table and then compare if was permitted to play
18:11:25 <monochrom> "unneeded" is just English. "prefix" is previous elements
18:11:44 <Radish> monochrom: just keep a reference around?
18:11:47 <joker_89> if not return the number of player (1,2 or 3)
18:11:54 <joker_89> the 0 player dont mean because is the first
18:12:00 <monochrom> no, the opposite, just keep no reference around
18:12:13 <Radish> monochrom: i mean the ones pending
18:12:33 <monochrom> then probably yes
18:12:37 <Radish> monochrom: i just didn't want to 1) wait to get that information and 2) keep a copy of the output around for later...
18:13:00 <Radish> monochrom: so keeping a partial list around... i was worried about making doubles.
18:13:25 <Radish> monochrom: wasn't sure how I was supposed to access the list I'm streaming.
18:14:30 <Radish> I'm worried about carrying elements I've output.  That's wrong.  It creates duplicates.
18:14:40 <Radish> Right??
18:14:42 <monochrom> then perhaps I speak too abstractly.
18:14:51 <lispy> Is there a reason why cabal always relinks?
18:15:03 <Radish> monochrom: no no thank you very much
18:15:11 <lispy> Suppose your code in the current directory is up to date and you type 'cabal install'
18:15:16 <Radish> monochrom: I think your leading me correctly
18:15:17 <lispy> It will say that it's linking
18:15:26 <lispy> I find it odd and wasteful.
18:15:34 <typoclass> lispy: please refer to http://i.imgur.com/4owJPOp.jpg
18:15:49 <lispy> poor cabal kitteh
18:16:02 <Radish> lol that's great!
18:16:33 <Radish> Well thanks everyone I'll just get some code going and come back and ask if I am doing it wrong. :D
18:16:45 <monochrom> lispy, I just tried on my own exe-only project and could not reproduce it
18:16:50 <Radish> monochrom: thanks
18:16:53 <Radish> elliott: thank you
18:17:02 <typoclass> Radish: yep, feel free to do that :-) remember to use hpaste if the code is >1 line
18:17:05 <lispy> monochrom: so maybe it's because of cabal-dev?
18:17:19 <Radish> typoclass: Yes I love hpaste thank you!
18:17:27 <monochrom> I don't know. not going to try cabal-dev because I am too lazy
18:17:44 <monochrom> P.S. I do my own sandboxing by hand
18:17:55 <jfischoff>  what does  (‚Ä¶) mean when looking at a .prof file?
18:18:46 <hpaste> ‚ÄúJonathan Fischoff‚Äù pasted ‚Äú.prof question‚Äù at http://hpaste.org/84293
18:19:08 <jfischoff> ^ any ideas what the (‚Ä¶) means?
18:19:57 <lispy> monochrom: http://hpaste.org/84294
18:20:35 <monochrom> which line refers to linking?
18:21:32 <lispy> It configured it and built it
18:21:41 <lispy> THat output doesn't talk about linking
18:21:58 <monochrom> ok, two points.
18:22:26 <monochrom> 1. "install" goes through "configure" and "build". always. "cabal install" /= "Setup install".
18:23:38 <monochrom> 2. "build" merely calls ghc, and ghc knows when to avoid work. in fact, if there were really real compiling and/or linking, you would see more chats than this.
18:24:27 <monochrom> you would see GHC's famous "[1/100]", "[2/100]", ... eventually "Linking blahblah"
18:24:30 <lispy> How about this: I have a makefile and I want to delegate to cabal{-dev} for building Haskell. What I'm finding is that cabal does a lot of extra work when I ask it to build things. Eg., if something is already built it will still do a lot of the steps the second time.
18:24:47 <Peaker> hlint seems to have a parse error at the import of (#) from Lens...
18:25:08 <monochrom> use separate "cabal configure" and "cabal build" etc. at least you could skip "configure" some times
18:25:18 <tac> monochrom: has the notion of a concurrent build system ever been brought up in GHC talk?
18:25:18 <monochrom> but have you been reading my answer?
18:25:24 <Peaker> monochrom, "cabal build" seems to always relink, whereas ghc's make only relinks if necessary
18:25:36 <monochrom> I just tried. could not reproduce
18:25:58 <Peaker> monochrom, the relinking?
18:26:08 <monochrom> I have literally re-entered "cabal build" 5 times now. no re-linking
18:26:53 <Peaker> hmm.. happens for me in lamdu every time
18:30:00 <hpaste> yitz annotated ‚Äúfds‚Äù with ‚Äúfds (annotation)‚Äù at http://hpaste.org/84290#a84295
18:30:31 <yitz> aww joker_89 is gone :(
18:32:13 <monochrom> tac: I don't know
18:33:57 <lispy> monochrom: I can't reproduce the link-every-time behavior in my simple examples but it's happening in my real-world code.
18:35:02 <monochrom> then, you have to decide how much you want to figure out why
18:38:10 <yitz> tac: being worked on. installing packages in parallel done. installing modules in parallel within a package currently being worked on. https://github.com/haskell/cabal/issues/976
18:38:33 <tac> neat
18:40:52 <yitz> lispy: perhaps your makefile touches or moves either objs or exes somehow?
18:40:53 <amatsu> Is there a data type like a list that maintains uniqueness, but doesn't have an Ord constraint like Set?
18:41:19 <yitz> amatsu: you can use Data.List.nub
18:41:29 <yitz> @src nub
18:41:29 <lambdabot> nub = nubBy (==)
18:41:35 <yitz> @src nubBy
18:41:35 <lambdabot> nubBy eq []             =  []
18:41:36 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
18:42:15 <amatsu> yitz: that's O(n^2).. would searching a list for an existing element before insertion be more efficient?
18:42:16 <elliott> amatsu: out of curiosity: what type do you have that is Eq but not Ord?
18:42:38 <yitz> amatsu: it's fast, and nicely lazy, for lists up to about 100 elements. above that, you start getting hit by O(n^2), yes.
18:43:18 <monochrom> if you refuse Ord, you must accept n^2
18:43:21 <yitz> amatsu: i don't see how you can avoid asymptotic n^2 without some kind of ordering.
18:43:36 <amatsu> elliott: cellular automaton cell states with coordinates as a tuple. Would it be easier to add an Ord constraint to, say, my coordinates then?
18:43:39 <monochrom> and if you refuse Eq too, then can't be done at all
18:43:50 <elliott> you should probably just get an Ord
18:43:57 <elliott> it doesn't matter if your ordering makes much sense, really
18:43:58 <yitz> monochrom: well amatsu can refuse Ord but implement ordering some other way i suppose
18:44:32 <amatsu> I'll probably just add an Ord instance then
18:45:08 <amatsu> it's for an assignment, I don't know if we're allowed to fiddle with the datatypes, but I'll go with Ord and Sets for now I think.
18:45:24 <monochrom> perhaps you may accept hashing. then the package unordered-containers may help you
18:45:47 <monochrom> perhaps the assignment accepts n^2
18:46:43 <amatsu> monochrom: I'll take a look at unordered-containers
18:46:50 <amatsu> I assume it has a conversion back to []?
18:46:54 <lispy> yitz: I think it's because a previous step reinstalls a library even though the library hasn't changed.
18:47:23 <yitz> lispy: you mean a previous makefile step, i suppose
18:47:23 <arkeet> :t map head . group . sort
18:47:24 <lambdabot> Ord b => [b] -> [b]
18:47:30 <arkeet> put your own sort here
18:47:36 <lispy> yitz: correct
18:48:08 <lispy> Mixing cabal and make leads to exactly the kind of problem you hit with recursive make :)
18:48:47 <lispy> What I want cabal to do is realize that there is no work to do in the "install" command for the library.
18:49:04 <lispy> That would save me an expensive linker step later
18:49:25 <yitz> sigh. separate compilation sounds so cool. but everything in this world has its cost.
18:50:12 <amatsu> alright then
18:50:13 <monochrom> if you don't use "install", but "build" instead, will it reinstall the unchanged library?
18:50:19 <timtom> @src nubBy
18:50:19 <lambdabot> nubBy eq []             =  []
18:50:19 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
18:50:22 <ab9rf> monochrom: hashing was the solution that came to my mind
18:50:27 <lispy> monochrom: I don't think so
18:50:32 <ab9rf> monochrom: of course hashing is O(n^2) in the pathological case
18:51:33 <monochrom> I think it makes sense to say: if you're writing a makefile to call up cabal, don't call its "install" which is the anti-thesis to fine-grained control
18:51:45 <lispy> monochrom: but then I think I would need a way to detect when no work was needed and then conditionally copy/register
18:52:31 <amatsu> thanks all!
18:53:27 <monochrom> people who use make expects to enter a seperate "make install" by hand. that's when you call "cabal copy" and "cabal register". and there is no condition. the user has demanded "make install", so just do the copying and registering.
18:54:04 <lispy> monochrom: the library is an internal dependency
18:57:10 <lispy> I think the only that makes pragmatic sense (meaning, I don't want to write a complicated makefile) is to deal with the unnecessary reinstall/relinking.
18:57:38 <lispy> I could do some sophisticated make targets that conditionally copy/register but I think I'll regret it later
18:59:13 <yitz> lispy: no way to separate the cabal stuff from the make stuff? it's fully interleaved?
19:03:26 <lispy> yitz: make is just a wrapper in this case
19:03:55 <lispy> yitz: In that sense I could actually be using one meta-cabal file
19:04:53 <lispy> (That's not an option I considered previously)
19:05:36 <lispy> I guess the problem with that might be that I'd still have to create a package index that told the meta package where to find the other packages
19:06:07 * lispy calls it a day and says he'll stew on it
19:06:34 <yitz> lispy: you can use a yackage server
19:15:34 <sw17ch> dcoutts: i was reading through some old logs from 2008. you gave me quite a bit of help when I was first getting started with Haskell. Wanted to say thanks in a semi-public way.
19:19:56 * dainanaki I'm having issues running cabal install on a local package that I'm working on. Here's the message that I'm getting:cabal: Error: some packages failed to install:
19:19:57 <dainanaki> zippy-riak-0.1.0.0 failed during the final install step. The exception was:
19:19:57 <dainanaki> ExitFailure 1
19:20:29 <dainanaki> There's no error logged to the console to indicate what went wrong though.
19:26:25 <monochrom> then perhaps "cabal install -v3"
19:31:20 <yitz> preflex: seen dcoutts
19:31:20 <preflex>  dcoutts was last seen on #ghc 8 hours, 33 minutes and 3 seconds ago, saying: worth a go
19:50:48 <luite> is there a Set datastructure that can efficiently lookup elements by index (in the set order) and retrieve the index of elements?
19:51:20 <shachaf> luite: Data.Map has an API for that.
19:52:02 <luite> wai not Set! :/
19:52:27 <shachaf> Oh, Data.Set has it too now.
19:52:32 <shachaf> http://hackage.haskell.org/packages/archive/containers/0.5.2.1/doc/html/Data-Set.html#g:8
19:52:32 <luite> shachaf: hehe I was trying to do this to save some memory by avoiding a Map and ints
19:52:35 <shachaf> It didn't use to.
19:52:49 <shachaf> Or did I misunderstand?
19:52:50 <luite> oh hey, that's what i get for looking at outdated haddocks
19:53:08 <shachaf> Hmm.
19:53:12 <shachaf> 0.5.0.0 doesn't have it.
19:53:29 <parcs> i added those operations!
19:53:31 <shachaf> Pretty annoying how you can't upgrade containers.
19:53:33 <shachaf> parcs++
19:53:53 <sw17ch> hey, yitz, you're also on the list of people who helped me learn haskell 5ish years ago now. thanks!
19:53:54 <luite> parcs: tnx :)
19:54:31 <luite> does ghc depend on containers?
19:55:07 <shachaf> Yes.
19:55:16 <luite> bleh then i can't upgrade it
19:55:40 <shachaf> Pretty annoying.
19:55:57 <luite> perhaps i can upgrade ghc thouch
19:55:59 <luite> though
19:57:58 <luite> parcs: I'd have preferred them to be a bit less errorry :)
20:01:24 <luite> but i guess it's closre to array now in api
20:01:53 <parcs> they were modelled after the existing indexing operations on Map, which themselves are errory
20:03:00 <tsinnema> is there a working implementation of polymorphically extensible records that doesn't permit duplication of fields?
20:03:48 <tsinnema> (i am very unclear on how mature any implementations are, not even accounting for that particular feature)
20:08:57 <edwardk> tsinnema: MLPolyR
20:12:30 <tsinnema> edwardk, thank you!
20:13:05 <edwardk> we also have something of a polymorphic extensible record story here, but we haven't released our tools publicly yet
20:15:34 <luite> parcs: do you know when it's going to be included in HEAD?
20:17:50 <BMeph> edwardk: What, no Ur? ;)
20:18:49 <edwardk> ur is a different story. they have great records, nice tools for programing with those crazy kinds, etc. but you still have to explicitly mention them. more of a checking than an inference story compared to mlpolyr.
20:21:17 <parcs> luite: hmm i figured it would be included by now -- but nope, no idea
20:29:15 * sw2wolf time for lunch
20:32:18 <GreenLeaf> Hi all
20:50:33 <carter> luite: build ghc with your fav versions of the libs it uses :)
20:51:32 <crdueck> is there a specialized join for Vectors?
20:51:40 <crdueck> f :: Vector (Vector a) -> Vector a
20:51:49 <elliott> crdueck: concat?
20:51:55 <crdueck> i hoogled it, just join came up
20:52:18 <crdueck> elliott: V.concat :: [V.Vector a] -> V.Vector a
20:52:48 <elliott> oh, hm
20:52:51 <carter> crdueck if you do that + fromlist, it might get fusioned into a fast form...
20:52:52 <elliott> is there no monad instance for unboxed vectors?
20:52:58 <elliott> er
20:52:58 <elliott> boxed
20:53:06 <elliott> if you're using unboxd vectors then idk
20:53:10 <carter> elliott monad instance of what?
20:53:15 <elliott> Vector
20:53:19 <elliott> (boxed)
20:53:23 <fumieval> http://hackage.haskell.org/packages/archive/vector/latest/doc/html/Data-Vector.html
20:53:23 <crdueck> elliott: there is, but i wonder if theres a specialized one
20:53:26 <elliott> since that is a perfectly good Monad I think
20:53:33 <elliott> crdueck: well it should be as specialised as it gets for boxed vectors
20:53:53 <shachaf> elliott: You could probably do a more efficient one that allocates a vector in one go or something.
20:54:12 <carter> vector lib has lots of work for fusion
20:54:14 <elliott> I guess you save the >>= id part
20:54:18 <carter> maybe it fires on that well
20:54:22 <elliott> well, the id part.
20:54:28 <shachaf> carter: I'd be surprised if it fused on >>= id but who knows.
20:54:36 <carter> where would the bind appear?
20:54:39 <shachaf> That's kind of a magic thing to do.
20:54:42 <shachaf> join x = x >>= id
20:54:51 <carter> oh, for writing the flatten?
20:54:58 <crdueck> I'm trying to use an unfold to create a Vector, and the unfolding step function returns a Vector. so I end up with a Vector (Vector a)
20:54:59 <shachaf> You can do special things when you know the function is id so you can precalculate the size.
20:55:19 <carter> i was thinking moreso concat . fromlist
20:55:24 <shachaf> crdueck: Unfold? Maybe you should be using >>= or something?
20:56:17 <crdueck> where is the monad instance for Vector defined?
20:56:49 <shachaf> Why are you asking us? Ask ghci.
20:56:54 <shachaf> :i Vector
21:01:00 <elliott> shachaf: do you actually save much work precalculating?
21:01:06 <elliott> you still have to look at the length of each component vector
21:01:10 <elliott> applying id isn't much more work
21:02:38 <luite> carter: yeah but no one else can use them if ghc is released with an older version
21:02:45 <luite> unless they also rebuild their ghc...
21:02:49 <carter> yeah...
21:03:01 <carter> this is why we need better multi version support
21:03:02 <shachaf> elliott: Well, you have to reallocate to grow the vector, presumably.
21:03:18 <luite> carter: wouldn't work here, since my package depends on ghc itself, ghc depends on containers
21:03:25 <shachaf> Or maybe not.
21:03:29 <carter> huh
21:03:33 <shachaf> Never mind, it probably wouldn't be implemented that way anyway.
21:03:52 <carter> i'm trying to figure out if i have a crazy ass cabal-install bug or if ive got dirtydata
21:03:57 <shachaf> Anyway I just meant that maybe you could do something.
21:04:21 <Saturn`> i'm trying to debug a parallel haskell program; i'm not getting the HEC utilisation i'm expecting, does anyone know of a tool i an use to inspect what's happening?
21:04:53 <arkeet> threadscope?
21:05:48 <Saturn`> i've tried that; it tells me my utilisation, but i can't seem to get any more useful information out of it, specifically what functions are blocking utilisation
21:05:52 <Saturn`> maybe i'm using it wrong
21:06:37 <carter> Saturn` have you done normal profiling too?
21:06:55 <carter> if your not parallel bits are too slow...
21:07:00 <carter> or if theres too much locking?
21:08:03 <Saturn`> carter: how do i profile that?
21:08:11 <slack1256> Saturn': the profiling options are different in the theaded rts. check out the utilization (percentage) of all function if i remember with -prof-all
21:08:13 <Saturn`> (i'm quite new to this)
21:08:23 <slack1256> also you have to compile with debug support
21:09:00 <hpaste> carter pasted ‚Äúcrazy cabal error (maybe bug?)‚Äù at http://hpaste.org/84299
21:09:23 <carter> hey all: i'm getting the following panic sort of thing happening
21:09:38 <carter> i think it might be a bug in cabal-install head
21:09:55 <carter> but i'm not sure
21:10:39 <slack1256> carter: that's no bug in cabal-head
21:10:54 <slack1256> is a bug in kate-highlight (I've hit it also with pandoc install)
21:11:11 <slack1256> the previous version was building correctly, to me, could you try to install that one?
21:11:56 <carter> 1.11.1
21:12:03 <carter> i mean 1.11.0
21:12:06 <carter> or 1.10.1
21:12:11 <slack1256> I got the version 1.9.4.2 which built correctly
21:12:21 <Saturn`> hmm, i'm sure there was a program i've seen that would show utilisation by function... gransim possibly?
21:12:22 <slack1256> I don't think it has changed much in 4 month soo.
21:12:36 <Saturn`> i've seen reference to that, but i can't find anywhere i can download it
21:13:17 <carter> pandoc 1.10.1 was my last good build
21:13:25 <carter> i was also getting some weird panics on other things
21:13:30 <carter> lemme try 1.10.1
21:13:45 <slack1256> Sasturn`: for theads utilization there is always threadscope (graphically) for memory utilization the profiller gives information which can be made a postscript, also knowing the +RTS option is good too
21:14:28 <slack1256> carter: yeah, kate-highlight is difficult because is a bunch of javascript regex on a weak binding, but works with some versions
21:14:31 <Saturn`> huh, okay, new problem: i tried compiling with -prof, but ghc now gives me "cannot find module Prelude"
21:14:50 <carter> slack1256 i'm not sure if its that specifically...
21:14:59 <carter> how would that create the error i got?
21:15:07 <slack1256> carter: your paste says that
21:15:23 <carter> ah
21:15:33 <slack1256> Configuring highlighting-kate-0.5.3.8...
21:15:35 <slack1256> Building highlighting-kate-0.5.3.8...
21:15:49 <slack1256> Failed highlighting-kate-0.5.3.8...
21:15:54 <carter> umm
21:16:00 <carter> but the failure was " Something is amiss; requested module  transformers-0.3.0.0:Control.Monad.Trans.List differs from name found in the interface file List-0.5.1:Control.Monad.Trans.ListCannot continue after interface file error"
21:16:23 <slack1256> carter: that isn't what I see in the paste, sorry.
21:17:05 <slack1256> Saturn`: the haskell plataform comes in 3 flavors the normal statically version, the shared libraries version and the debug version
21:17:20 <slack1256> you have the Prelude without the debug version
21:17:31 <slack1256> check out the packages on your distribution for it.
21:17:42 <slack1256> BTW which distro or OS are you using?
21:18:04 <slack1256> (also this explain why GHC is bigger than normal compilers, 3 version of everything)
21:18:15 <Saturn`> ah, cheers, found a package called ghc-prof
21:18:20 <Saturn`> which i presume is what i'll need
21:19:11 <carter> ok
21:19:26 <carter> so basically i should fork LIst and make it not have that clobber module
21:20:36 <carter> or
21:20:37 <carter> hrmm
21:20:49 <slack1256> what?
21:21:40 * slack1256 welcomes you to the haskell clinic, how is your haskell feeling today? any new symptoms?
21:24:12 <carter> ohhh
21:24:30 * carter i made an edit to where cabal puts libraries
21:24:33 <carter> and that borked things
21:24:54 <slack1256> and does it work now?
21:25:03 <carter> I will find out!
21:25:07 <Saturn`> thanks all, i think i've found my problem!
21:25:17 * arkeet I love it when people use ACTION in the first person and/or with a superfluous subject.
21:25:51 <slack1256> Saturn`: A well put problem is half done :-)
21:26:33 <slack1256> arkeet: I don't understand
21:27:29 <amatsu> What's the overhead of converting to and extracting from a newtype?
21:27:34 <sproingie> zero
21:27:57 <slack1256> amatsu: zero
21:28:02 <slack1256> @quote newtype
21:28:02 <lambdabot> ghc says: parse error in data/newtype declaration
21:28:06 <slack1256> @quote newtype
21:28:06 <lambdabot> <basti_> says: Snow doeth lay upon the lands. Even with cunning newtype; deriving the newtype is recursive. Great leaders brings less pain.
21:28:11 <sproingie> newtypes are erased at runtime
21:29:09 <slack1256> as jhc? said: A newtype is a old regular type with a coat, groucho marx glasses and a sign which says "You haven't seen me anywhere"
21:29:35 <amatsu> slack1256: sproingie: alright then, thanks!
21:30:24 <elliott> unfortunately you can still run into overhead from using newtypes. e.g. "map Newtype", "map unNewType" are not necessarily free
21:30:37 <elliott> on the plus side, you can use "unsafeCoerce" instead...
21:30:48 <sproingie> i didn't even know you could map Newtype
21:31:02 <elliott> why wouldn't you be able to? constructors are functions
21:31:05 <sproingie> but anyway that's as cheap as any other use
21:31:09 <slack1256> but wasn't that overhead related to re-boxing a result because of the newtype?
21:31:43 <slack1256> it wasn't for the newtype per s√©, right?
21:35:43 * hackagebot matrix 0.1 - A native implementation of matrix operations.  http://hackage.haskell.org/package/matrix-0.1 (DanielDiaz)
21:35:45 * hackagebot HaTeX 3.5 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.5 (DanielDiaz)
21:42:01 <arkeet> elliott: no worse than map id
21:42:20 <elliott> arkeet: yes. but it can get even worse if you use another functor, etc.
21:42:27 <arkeet> :p
22:18:13 <carter> lesson learned, be careful when editing the cabal config file for a local install
22:29:00 <dacto> if I have my parsec state to exist as a list, how do I prepend to the state with updateState? Intuitively I think to do updateState (something:)..but i have a feeling that this is incorrect.
22:29:19 <shachaf> What is the type of updateState?
22:29:43 <dacto> It would be a [Token], where token is my own data type
22:29:51 <shachaf> updateState is a list?
22:30:17 <dacto> yeah..if it is possible. all the examples ive see treat it as an int and updateState is (+#)
22:30:29 <applicative_> updateState :: Monad m => (u -> u) -> ParsecT s u m ()
22:30:31 <shachaf> Shouldn't it be a function? :-)
22:30:43 <shachaf> http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Prim.html says it's an alias for modifyState
22:31:04 <shachaf> The way you're thinking of using it seems about right. I don't know if it's the right thing to be doing in general.
22:31:18 <dacto> ah yeah, I guess so, ok so when I call runParser, I would then supply the state function?
22:31:18 <shachaf> But the answer to that question seems to be yes.
22:31:22 <applicative_> I was going to say, modifyState would be the name youd expect
22:31:35 <shachaf> Function?
22:31:40 <shachaf> I assume you just supply an initial state.
22:31:53 <dacto> right so, so far i just give it an []
22:32:48 <dacto> I guess im not understanding what acutally needs to happen when I want to prepend a token to my list
22:32:57 <dacto> within the state of course
22:33:21 <shachaf> Do you understand Control.Monad.State?
22:33:50 <dacto> In a rough sense. I know that it persists through the parsec instance
22:34:08 <dacto> well that parsec comes from state monad
22:39:48 <applicative_> dacto: so [Token] is the state you yourself are keeping ( the 'u') in ParsecT s u m a ?  or is the the 'stream' type -- the s in the usual lettering
22:40:30 <dacto> the 'u', at least that's what I would like.
22:40:36 <shachaf> I,I ParsecT s t a b
22:40:55 <dacto> wait, lemme look at parsec in hoogle to be sure im saying the right thing
22:41:10 <dacto> Yeah,, 'u'
22:43:15 <applicative_> dacto and when certain parsers succeed on a string or bytestring,you want to add or subtract a 'token' from the user state
22:43:47 <dacto> Yeah
22:44:06 <dacto> Basically, I'm trying to keep track of variable tokens
22:44:24 <dacto> and what type they are
22:44:34 <Rotaerk> hmm how powerful is Yi?  is it actually a viable competitor with vim?
22:47:37 <applicative_> hm, then it seems your original design seems right dacto , you would write things like do {token <- tokenParser17; updateState (token:); ...}
22:48:24 <dacto> Alrighty, I'll keep chugging along then, Thanks :)
23:15:46 * hackagebot bson 0.2.2 - BSON documents are JSON-like objects with a standard binary  encoding.  http://hackage.haskell.org/package/bson-0.2.2 (FedorGogolev)
23:20:46 * hackagebot log-domain 0.3 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.3 (EdwardKmett)
23:30:46 * hackagebot compensated 0.1 - Compensated floating-point arithmetic  http://hackage.haskell.org/package/compensated-0.1 (EdwardKmett)
23:35:46 * hackagebot compensated 0.1.1 - Compensated floating-point arithmetic  http://hackage.haskell.org/package/compensated-0.1.1 (EdwardKmett)
23:40:00 <BadKitty> How can I using <> concat a bytestring and it's length? (Length at the start, 4bytes)
