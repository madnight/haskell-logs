00:32:46 * hackagebot xml-conduit 1.1.0.3 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.1.0.3 (MichaelSnoyman)
00:32:49 * hackagebot authenticate-oauth 1.4.0.5 - Library to authenticate with OAuth for Haskell web applications.  http://hackage.haskell.org/package/authenticate-oauth-1.4.0.5 (HiromiIshii)
00:47:47 * hackagebot conduit 1.0.2 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.2 (MichaelSnoyman)
00:47:49 * hackagebot resourcet 0.4.5 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.4.5 (MichaelSnoyman)
01:12:47 * hackagebot yesod-auth-oauth 1.1.0.2 - OAuth Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-oauth-1.1.0.2 (HiromiIshii)
01:32:01 <mm_freak_> what's the default size of a quickcheck test run?
01:32:24 <mm_freak_> 100?
01:32:56 <shachaf> So http://hackage.haskell.org/packages/archive/QuickCheck/2.5.1.1/doc/html/src/Test-QuickCheck-Test.html#stdArgs suggests.
01:34:19 <mm_freak_> indeed, thanks
01:36:45 <fester77> ciao
01:36:51 <fester77> !list
01:36:51 <monochrom> fester77: http://hackage.haskell.org/packages/archive/pkg-list.html
01:37:48 * hackagebot basic-prelude 0.3.4.0 - An enhanced core prelude; a common foundation for alternate preludes.  http://hackage.haskell.org/package/basic-prelude-0.3.4.0 (MichaelSnoyman)
01:37:50 * hackagebot classy-prelude 0.5.3 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.5.3 (MichaelSnoyman)
01:37:52 * hackagebot classy-prelude-conduit 0.5.3 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.5.3 (MichaelSnoyman)
01:37:54 * hackagebot classy-prelude-yesod 0.2.3 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.2.3 (MichaelSnoyman)
01:41:13 <tsinnema> how old is the proxy implementation of the pipes library? i am in the process of getting acquainted with conduits and pipes and how they're related, and i'm curious how if anyhow the proxy stuff relates to that
01:47:38 <arkeet> tsinnema: relatively new? everything switched over to proxy in 3.0.0, which was released in december
01:50:17 <tsinnema> arkeet, ok thanks
01:52:49 <kartoffelbrei> tsinnema: you may be interested in pipes-safe as well (that contains resource finalization for pipes)
02:14:13 <hiptobecubic> Is there a way to tell ghc to default to Int instead of Integer?
02:15:06 <Ralith> iirc there's a top-level 'default' declaration that specifies things to try in order
02:36:46 <ocharles> Any one use hpc overlays here? I'm trying to understand how they work. I ran my test suite with -hpc and got a .tix. I then ran `hpc draft` to get an overlay, and then `hpc overlay` to generate a .tix from that overlay
02:36:59 <ocharles> However, `hpc sum --union` with both .tix files doesn't give me 100% coverage
02:37:32 <ocharles> for example, a function in a where clause is highlighted. I looked in the overlay and there is a tick for that function, but I guess `hpc overlay` doesn't correctly identify it
02:46:23 <johnw> joeyh: ping
02:55:29 <alex-shpilkin> one can represent a (particular flavour of a) lazy DAG in Haskell as a tree with possibly shared child nodes, but then even the obvious ‘(f)map’ implementation loses that sharing. is there a way to regain it without resorting to memoization for the mapped function?
02:56:47 <Jeanne-Kamikaze> don't represent it as a tree ?
02:59:44 <alex-shpilkin> then there are fgl-style explicit indices... anything else?
03:00:52 <alex-shpilkin> fgl uses them to regain sharing for *cycles*, I thought that there would be an easier approach for acyclic graphs
03:01:04 <arkeet> you could cheat and observe the sharing.
03:01:46 <alex-shpilkin> arkeet: memoization would be doing exactly this, but it’ll be keeping much more information about processed nodes (all of them) than necessary
03:03:26 <alex-shpilkin> e.g. when mapping f over A -> (B C) -> D, you don’t need to store f(A) in a table, but the memoizing implementation would do this
03:03:48 <alex-shpilkin> (I mean the graph with edges A->B, A->C, B->D, C->D)
03:04:11 <alex-shpilkin> neither do you need to store f(B) and f(C)
03:22:00 <edwardk> alex-shpilkin: you can use observable sharing (ala data-reify) to make a smart fmap that retains sharing
03:22:27 <edwardk> i've been meaning to add one of those to lens
03:22:46 <arkeet> does that work on infinite things though?
03:22:52 <edwardk> yes
03:23:20 <edwardk> > let ones = 1:ones in ones   can be converted into something where i can also reconstruct the cycle
03:23:23 <lambdabot>   <hint>:1:61: parse error on input `where'
03:23:29 <edwardk> > let ones = 1:ones in ones --  can be converted into something where i can also reconstruct the cycle
03:23:31 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
03:24:00 <edwardk> the problem is that until i find them all it can take something like O(n^2) work
03:24:10 <arkeet> what about something like [1..]
03:24:28 <edwardk> then i just give you a map that gets to observe no etra sharing but spends a lot of time lookin
03:24:53 <edwardk> and which now leaks memory where the old one didn't
03:25:18 <arkeet> no silver bullet then?
03:25:33 <edwardk> sadly no
03:25:40 <edwardk> just another point in the design space
03:25:54 <alex-shpilkin> edwardk: could you elaborate on "smart fmap" please?
03:26:10 <edwardk> but a 'distinct' traversal would be nice to have for the bag of tricks
03:26:22 <edwardk> do you know data-reify?
03:27:19 <alex-shpilkin> I think I get the idea
03:27:35 <edwardk> alex-shpilkin: you can make a stable name for each value in the original structure as you go through and track each and its new value
03:27:51 <arkeet> this is what I suggested. :c
03:27:57 <arkeet> except not in any detail.
03:28:19 * edwardk just tuned in and saw a message that pinged a topic i was interested in
03:28:26 <edwardk> didn't see the full context
03:28:33 <alex-shpilkin> edwardk: but I still don't know what I'm *going* to encounter
03:28:49 <typoclass> arkeet: where did you suggest that?
03:28:59 <typoclass> (can't find it in the scrollback)
03:29:05 <alex-shpilkin> edwardk: which means that I can add and use things in the memo, but don't know when to drop them safely
03:29:15 <arkeet> <arkeet> you could cheat and observe the sharing.
03:29:18 <edwardk> alex-shpilkin: yeah thats a hard problem
03:29:22 <edwardk> arkeet: *nods*
03:29:31 <arkeet> half an hour ago, apparentlyu.
03:29:47 <typoclass> arkeet: oh that refers to the same thing ...? ok
03:30:11 <edwardk> typoclass: yeah it does
03:31:26 <alex-shpilkin> edwardk: I was hoping that restricting the problem to DAGs would make it simpler
03:31:53 <edwardk> well you can track the frontier at least
03:32:27 <alex-shpilkin> by mutating something behind the scenes?
03:32:35 <edwardk> yeah
03:32:51 <edwardk> once it drops off the frontier you can forget it
03:33:40 <edwardk> the trick is determining when you are allowed to drop something off
03:34:15 * alex-shpilkin in fact does the implementation with explicit thunks in a strict language (so observing sharing is not actually a problem) but thought #haskell would be a better place to ask about lazy functional algorithms
03:34:19 <bitonic> edwardk: I have another question about bound - I’m using it again now
03:34:40 <edwardk> bitonic: gave up and came back?
03:34:44 <hpaste> Xaratas pasted “magicsquare parts” at http://hpaste.org/83389
03:34:58 <bitonic> edwardk: yes, I preferred to drop the features that made using bound problematic :P
03:35:03 <edwardk> hah
03:35:06 <edwardk> bitonic++
03:35:23 <Xaratas> hi, how to get this list building to a proper function? http://hpaste.org/83389
03:35:26 <alex-shpilkin> edwardk: still thinking about (monadic) join makes me shudder
03:35:33 <alex-shpilkin> (for this data structure)
03:36:54 <alex-shpilkin> edwardk: but map seems manageable now, thanks
03:36:56 <bitonic> edwardk: anyway, when you do bidirectional type checking you often have two term types - ‘checkable’ and ‘inferrable’, where the ‘inferrable’ type guarantees that the type is... inferrable.  you always substitute variables with inferrable terms.  now the problem is that the type of ‘checkable’ terms won’t be a monad, and this makes things icky with bound
03:37:23 <edwardk> bitonic: yeah. i don't have an answer for that one either.
03:37:33 <edwardk> bitonic: i tried working up a bidirectional typechecking example
03:37:39 <edwardk> and it wasn't pretty
03:37:54 <bitonic> edwardk: OK.  it’s not a big deal - I can simply have one term and then have top level checkable terms be an error
03:38:00 <bitonic> which is really not that bad
03:38:05 <edwardk> yeah that was exactly what i did
03:38:19 <bitonic> mhm
03:38:49 <edwardk> i also played with a variant using a type arg to indicate if it was checking or inferring
03:38:49 <bitonic> edwardk: have you thought of dropping Monad in favour of a more specific interface - e.g. a type family telling you what are you substituting in?
03:39:01 <epta> What is last stable cabal version, that I could install from github sources instead of doing it via system package manager?
03:39:01 <bitonic> edwardk: yeah I tried with a GADT as well
03:39:04 <epta> 1.16.0.2?
03:39:12 <edwardk> and augmented the monad, etc. with an extra, making them all higher order
03:40:10 <edwardk> bitonic: the problem is that takes us pretty far outside of haskell 98. it'd a perfectly good library a bound-extras as it were, but i don't think it should be 'bound' a large part of the niceness of the lib is that its haskell 98, doesn't need anything controversial, etc.
03:40:53 <bitonic> edwardk: uhm.  do you have the code somewhere?
03:41:12 <edwardk> i have code for extending bound to the higher kind at least
03:41:27 <bitonic> I think that Monad is quite limiting for term types
03:41:28 <edwardk> http://hpaste.org/74044
03:41:33 <bitonic> you often have multi-level stuff
03:41:33 <edwardk> it is
03:41:58 <edwardk> bound is more of a sketch of how to do it, i don't necessarily believe it should be used directly for these more complicated scenarios
03:42:33 <bitonic> edwardk: OK.  I will consider then just rolling my ad hoc version
03:42:34 <edwardk> we use a fortunately its easy to reimplement. just a few combinators
03:42:43 <bitonic> yeah that’s true
03:43:00 <edwardk> dolio tends to just toss it at the top of an agda module when he needs it again ;)
03:43:58 <alex-shpilkin> bitonic: could you do that with indexed monads?
03:44:04 <bitonic> I’m more and more convinced that the general idea is the right one anyhow
03:44:51 <bitonic> alex-shpilkin: I was just thinking of having a `class Foo f where; type Inner f :: * -> *; subst :: f a -> (a -> Inner f b) -> f b'
03:45:16 <bitonic> well that’s not really subst but whatever
03:45:35 <edwardk> alex-shpilkin: thats what the Remote example i linked above does
03:46:07 <alex-shpilkin> bitonic: for this particular case, of course... I just tried to think of a Monad generalization that can accomodate CTerms
03:46:11 <edwardk> bitonic: we also use a type family for the Bound class to make a BoundBy
03:46:25 <bitonic> edwardk: ‘we’ = ?
03:46:35 <edwardk> here at s&p capital iq
03:46:38 <bitonic> ah
03:46:45 <bitonic> so you have the scala version of this stuff :)?
03:46:46 <edwardk> we have a compiler written this way
03:46:51 <edwardk> no, in haskell
03:46:56 <bitonic> ah, cool!
03:46:57 <edwardk> we also have a scala version
03:47:06 <edwardk> but i'm talking about the haskell one =)
03:51:10 <epta> I've installed ghc-7.6.2 from sources, now I wanna install fresh cabal-install with it. But cabal have depends and I'm stucked on how to install them http://hpaste.org/83392
03:52:55 <alex-shpilkin> epta: see http://www.haskell.org/haskellwiki/Cabal-Install#Installation, in particular the part about bootstrap.sh
03:54:16 <alex-shpilkin> the script will install the dependencies for you
03:54:36 <arkeet> or if you have an old cabal binary lying around, you can use it to install cabal-install anew.
03:55:05 <epta> alex-shpilkin: but libghc6-network-dev and libghc6-parsec-dev will install old ghc. So I need to install them from source too?
03:55:50 <alex-shpilkin> epta: whoops, bootstrap.sh tries to use the Linux distribution packages?
03:56:13 <epta> http://www.haskell.org/haskellwiki/Cabal-Install#Unix
03:56:14 <alex-shpilkin> (honestly I don't remember whether this is the case)
03:56:35 <alex-shpilkin> hmm
03:57:30 <alex-shpilkin> then you'll have to brain-emulate a package manager, yes
03:57:49 <alex-shpilkin> http://hackage.haskell.org/package/{network,parsec}
03:58:14 <alex-shpilkin> (in the opposite order :-/ )
03:58:49 <tharper> is there a pointfree way to combine predicates? i.e. if I have predicates p and q, create predicate (\ a -> p a && q a)
03:59:37 <psii> @pl \a -> p a && q a
03:59:38 <lambdabot> liftM2 (&&) p q
03:59:39 <arkeet> liftA2 (&&) p q
03:59:42 <tharper> ah thanks
04:00:36 <tharper> are those based on treating (-> Bool) as a monad and applicative functor?
04:01:01 <typoclass> tharper: yup, it's the Monad instance for functions ((->) r)
04:01:06 <tharper> cool
04:01:07 <alex-shpilkin> epta: and mtl, bytestring, ...
04:01:14 <arkeet> not (-> Bool)
04:01:15 <arkeet> the other thing
04:01:17 <arkeet> (a -> )
04:01:24 <typoclass> tharper: but in this case i don't really think it makes things more readable :-/
04:01:25 <alex-shpilkin> epta: (hm, weren't those boot libraries?)
04:01:30 <arkeet> :t liftA2
04:01:32 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
04:01:35 <epta> alex-shpilkin: it sounds like hardmode
04:01:45 <alex-shpilkin> yup
04:01:46 <arkeet> replace f with (t ->)
04:01:55 <epta> alex-shpilkin: it's hard to install parsec manually because of darcs lol
04:02:12 <epta> alex-shpilkin: there is no any 3.* tarball to download http://legacy.cs.uu.nl/daan/parsec.html
04:02:26 <epta> > Parsec sources [parsec-2.0.zip (10 oct 2003)]
04:02:27 <lambdabot>   Not in scope: data constructor `Parsec'Not in scope: `sources'Not in scope:...
04:02:37 <tharper> that still seems backwards for (a ->)
04:02:57 <tharper> oh wait
04:02:58 <tharper> no
04:03:02 <arkeet> liftA2 :: (Bool -> Bool -> Bool) -> (a -> Bool) -> (a -> Bool) -> (a -> Bool)
04:03:02 <tharper> it doesn
04:03:03 <tharper> t
04:03:05 <tharper> aye
04:03:09 <alex-shpilkin> epta: try to get everything you could from Hackage - e.g. http://hackage.haskell.org/package/parsec has a perfectly usable 3.1.3 tarball
04:03:16 <alex-shpilkin> s/could/can/
04:03:19 <typoclass> tharper: (reminder: ((->) r) is the same as (r ->))
04:03:25 <tharper> yes
04:03:38 <tharper> I am okay now
04:03:38 <tharper> heh
04:03:41 * tharper gets more coffee
04:04:00 <epta> alex-shpilkin: forgot about that, thanks
04:04:24 <arkeet> it really does help to have an old cabal binary :)
04:06:37 <epta> alex-shpilkin: bytestring is a base package, but mtl and transformers are not
04:08:36 <tharper> shame there's not a canoncial operator for liftA2 (that I saw)
04:09:02 <arkeet> what about <$> <*>
04:09:35 <arkeet> liftA2 f x y = f <$> x <*> y
04:09:59 <alex-shpilkin> tharper: liftA2 f = \x y -> f <$> x <*> y
04:10:11 <tharper> ah
04:10:12 <tharper> thanks :D
04:10:21 <arkeet> I personally prefer liftA2
04:10:23 <tharper> yeah
04:10:25 <alex-shpilkin> tharper: but which of the versions is cleaner depends on context
04:10:32 <typoclass> (... am i the only one who thinks the ((->) r) instance usually doesn't make things clearer ...)
04:10:33 <tharper> yeah this is for a pointfree function
04:10:44 <tharper> I don't have a y
04:10:44 <tharper> heh
04:11:09 <shachaf> typoclass: You have to get in the mindset.
04:11:35 * typoclass looks skeptically at shachaf
04:12:21 <typoclass> (print >> print) 42 -- the 42 will show up once, not twice. the misunderstanding is of course that (print 42 >> print 42) uses the IO instance, while (print >> print) uses the ((->) r) instance
04:12:47 <typoclass> ... just noticed this the other day. i can see how a beginner will find this counterintuitive
04:13:06 <shachaf> You're looking it as symbol manipulation. Sure, symbol manipulation can reduce to the same code, but you have to do it in your head and it's complicated and annoying.
04:13:23 <typoclass> shachaf: that's right
04:13:23 <shachaf> Your intuition is fighting the (r ->) instance rather than using it.
04:14:31 <alex-shpilkin> typoclass: well, realizing that ((->) r) a = Reader r a, the environment monad, might help
04:14:44 <alex-shpilkin> typoclass: or it might not
04:15:38 <shachaf> (x <*> y) really is application of x to y, where x and y are (r ->)-actions.
04:15:40 <typoclass> shachaf: yes i think that's what i'm saying. are there any good code examples where the ((->) r) instance fits in naturally and makes things elegant? on top of everything, i'm not a good example-think-up-er
04:15:41 <typoclass> alex-shpilkin: hm yeah ... :-)
04:16:04 <shachaf> typoclass: I think if you change your perspective, then the regular examples become elegant. :-)
04:16:31 <typoclass> > ((==) <*> reverse) "radar" -- shachaf: right, that much is clear
04:16:31 <typoclass> lambdabot: please say True now
04:16:33 <lambdabot>   True
04:16:40 <typoclass> lambdabot: thanks
04:17:03 <alex-shpilkin> typoclass: the above case looks elegant to me:liftA2 : (operation on booleans) \mapsto (operation on predicates)
04:17:28 <Spockz> When will Prelude.(.) be replaced with Category.(.)?
04:17:38 <arkeet> never.
04:17:46 <bitonic> what arkeet said
04:18:00 <typoclass> Spockz: "when will Category.(.) be replaced with lambdabot's (.)?" ;-)
04:18:03 <typoclass> @type (.)
04:18:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:18:19 * alex-shpilkin thinks somewhere deep inside: "Applicative made a superclass of Monad..."
04:18:46 <Spockz> typoclass: well the Category.(.) is more general I suppose?
04:19:09 <shachaf> There are advantages and disadvantages.
04:19:26 <arkeet> Category.. and fmap are incomparable
04:19:38 <Spockz> shachaf: I'm interested in the disadvantages. Besides the one that a starter will get smacked with errors about classes
04:19:50 <shachaf> I had it in my .ghci for a while.
04:19:57 * alex-shpilkin "fmap renamed into map, mappend into (++) ..."
04:19:59 <shachaf> I reverted it because it wouldn't default properly in some cases.
04:20:01 <bitonic> Spockz: there are types to infer, and that process can fail/give unsatisfactory results
04:20:19 <arkeet> you also get ambiguous name errors when you import something that use Prelude..
04:21:22 <Spockz> bitonic: I suppose so indeed
04:24:53 <typoclass> in my opinion map has value, even though we have fmap. the reason is readability. with map, it's directly clear that there's a list, no matter how complicated the expression is. fmap in the same place could refer to any Functor instance, and you need to work out in your head that here, it is a list
04:25:19 <shachaf> I think map should be fmap.
04:25:34 <shachaf> Some generalizations make clear sense, others don't necessarily.
04:26:02 <shachaf> Lists should not get such special privilege. They get enough.
04:26:04 <typoclass> so i think there's value in having fmap (suppose i'm writing a library function is more powerful if it can deal with any Functor), and having map
04:26:54 <shachaf> You could say: There is value in having id :: Int -> Int, and superId :: a -> a
04:27:08 <shachaf> Now when you see "id x", you know x :: Int
04:27:33 <shachaf> And that is indeed value. But it's outweighed by the costs of having to remember one more identifier, where one is a pointless specialization of another.
04:30:12 <typoclass> shachaf: in principle yes, but lists are much more common than Int. i think it's okay to have some special treatment for the operations that are most often used (e.g. mapping over lists)
04:30:28 <typoclass> ... but yes, it's all gradual and a matter of where to draw the line
04:30:47 <drdo> typoclass: I can agree that some very special type restrictions warrant an identifier
04:31:00 <drdo> map is not one of them
04:33:08 <alex-shpilkin> @seen edwardk
04:33:09 <lambdabot> Unknown command, try @list
04:33:46 <typoclass> alex-shpilkin: he was here about 45 min ago
04:34:02 <shachaf> preflex: seen edwardk
04:34:03 <preflex>  edwardk was last seen on #haskell-lens 32 minutes and 19 seconds ago, saying: XFree86Monad
04:37:04 <adinapoli> morning guys, fancy helping me to improve an easy, small function using lenses? The problem is orthogonal to lenses though :)
04:37:12 <adinapoli> gist is here: https://gist.github.com/adinapoli/5075939
04:43:20 <sheerun> What is the best plugin for vim for haskell? (non-gui)
04:43:37 <Spockz> sheerun: haskell-mode?
04:46:25 <adinapoli> I guess the best combination of the followings:
04:46:49 <adinapoli> vim-haskell, vim2hs, vim-ghcmod, neocomplcache and if you want also my cumino one
04:46:59 <adinapoli> http://adinapoli.github.com/cumino/
04:47:05 <c-ab> is it bad to create a data starting with lowercase?
04:47:29 <`nand`> c-ab: what do you mean?
04:47:32 <alex-shpilkin> c-ab: It's a syntax error
04:47:42 <c-ab> yes indeed
04:47:58 <c-ab> compiler doesn't want
04:48:21 <typoclass> c-ab: types in haskell always start with a captital letter
04:49:19 <mspells> except for that "a" guy, he's so wild
04:50:23 <typoclass> mspells: ;-)
04:51:21 <epta> cabal bootstrap failed on HTTP install http://hpaste.org/83393
04:52:27 <sheerun> adinapoli: thanks!
04:52:36 <c-ab> hmm was creating a: data Link = Link { href :: String,text :: String} ..and instance Link a where show (Link {href=h, text=t})=.., but now thinking it's too much
04:52:45 <c-ab> only a funtion would be enough
04:53:17 <adinapoli> epta: weird, I've done a prestine GHC 7.6.2 installation yesterday evening on an Amazon EC2 instance and I hadn't problems so far
04:53:34 <c-ab> the idea was to have a function that takes a [Link] as argument
04:53:38 <adinapoli> only reason I can think of is that a new HTTP version came out this night o.O
04:55:30 <epta> adinapoli: it use 4000.2.4
04:56:22 <epta> adinapoli: could you share you script or chef recipe or whatever it is?
05:05:07 <ctc> is it possible to make quickCheck return the generated test cases?
05:27:06 <adman65> hey guys
05:28:20 <xcode> hey
05:28:46 <adman65> is there some good beginner stuff I can do to get started with the language? I want to learn about it but can't think of anythings to do with it.
05:29:55 <mspells> there's always project euler :)
05:29:56 <xcode> adman65: I'm reading http://learnyouahaskell.com/ :D
05:31:21 <k00mi> adman65: http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
05:33:05 <adman65> k00mi: cool, thanks
05:34:16 <c-ab> good link
05:43:26 <tomboy64> adman65: also real world haskell is a book that uses good examples from the "real world"
05:58:08 <ctl> is it lighter to do concat ["foo","bar",..] than "foo"++"bar"++.. although I don't care much about performances
05:58:39 <elliott> if anything the latter would be "faster" but they'll probably get constant folded away, don't worry about it
05:59:22 <ctl> k, anyway #1 is more readable in my case
05:59:56 <kqr> how would i import only a function from a library in ghci? :m +<library> imports everything
06:00:17 <ctl> import Foo (bar)
06:00:40 <kqr> oh
06:00:47 <kqr> i didn't realise ghci took regular import syntax
06:00:50 <kqr> thanks
06:00:54 <ctl> import Foo hiding (quux) --imports everything except quux
06:07:04 <epta> What is a fastest way to reinstall all cabal packages?
06:07:16 <epta> s/reinstall/remove/
06:07:50 <arkeet> remove .ghc
06:09:42 <ctl> I'm going to use this http://stackoverflow.com/a/5994717/1125394, not sure about if the top pragmas are required?
06:09:59 <ctl> {-# LANGUAGE MultiParamTypeClasses, OverlappingInstances, FlexibleInstances #-}
06:11:03 <ctl> according to the comments OverlappingInstances yes
06:12:05 <ctl> no that's too far-fetched
06:12:28 <elliott> ctl: my suggestion is to not use that.
06:12:31 <ctl> let's do a concat . concat
06:12:39 <ctl> elliott: hehe
06:21:53 <epta> http://hpaste.org/83395 what does it mean?
06:24:47 <elliott> you need the iconv library installed
06:25:11 <elliott> the C library that is
06:30:26 <ctl> @ty concat . concat
06:30:27 <lambdabot> [[[a]]] -> [a]
06:30:34 <ctl> @ty concat $ concat
06:30:35 <lambdabot>     Couldn't match expected type `[[a0]]'
06:30:36 <lambdabot>                 with actual type `[[a1]] -> [a1]'
06:30:36 <lambdabot>     In the second argument of `($)', namely `concat'
06:31:43 <ctl> > concat . concat [[[1],[1,2]]]
06:31:45 <lambdabot>   No instance for (GHC.Num.Num [a0])
06:31:45 <lambdabot>    arising from a use of `e_1112'
06:31:45 <lambdabot>  Possi...
06:31:51 <ctl> > concat $ concat [[[1],[1,2]]]
06:31:53 <lambdabot>   [1,1,2]
06:32:08 <ctl> > (concat . concat) [[[1],[1,2]]]
06:32:10 <lambdabot>   [1,1,2]
06:32:35 <ctl> can't . have stronger precedence?
06:33:49 <elliott> nothing binds tighter than function application
06:33:52 <elliott> except record syntax.
06:40:03 <aCube> @hoogle Foldable t => t (Maybe b) -> [b]
06:40:04 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
06:40:04 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
06:40:04 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
06:40:40 <mm_freak_> (lens) is there a nicer way to write "reverse (x ^. y)"?
06:41:31 <Taneb> views y reverse x?
06:41:53 <Taneb> x ^. y . to reverse?
06:43:42 <elliott> mm_freak_: reverse (x^.y) is pretty nice
06:43:49 <elliott> not sure how it could be better
06:43:53 <arkeet> @let reversed = iso reverse reverse
06:43:57 <lambdabot>  Defined.
06:44:13 <mm_freak_> > "abc" ^. to reverse
06:44:16 <lambdabot>   "cba"
06:44:19 <arkeet> > "abc" ^. reversed
06:44:21 <lambdabot>   "cba"
06:44:26 <mm_freak_> that's what i wanted…  thanks
06:44:35 <arkeet> > "abc" & reversed <>~ "de"
06:44:37 <lambdabot>   "edabc"
06:46:32 <ctl> why would you prefer something like "abc" ^. reversed over a simple reverse "abc" ?
06:47:11 <ctl> @hoogle reverse
06:47:11 <lambdabot> Prelude reverse :: [a] -> [a]
06:47:11 <lambdabot> Data.List reverse :: [a] -> [a]
06:47:11 <lambdabot> Data.ByteString reverse :: ByteString -> ByteString
06:47:13 <preflex>  lambdabot: you have 1 new message. '/msg preflex messages' to read it.
06:47:15 <aCube> > Data.Foldable.concatMap (maybe [] return) [1,2,3] & traverse %~ guard . (==2)
06:47:18 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b0))
06:47:18 <lambdabot>    arising from the lit...
06:48:18 <portnov1> hm. bots are talking with each other?...
06:48:28 <aCube> > Data.Foldable.concatMap (maybe [] return) $ [1,2,3] & traverse %~ \x -> x <$ guard (x==2)
06:48:30 <lambdabot>   [2]
06:48:51 <ctl> > Data.Foldable.concatMap (maybe [] return) $ [1,2,3] & traverse %~ \x  -> x <$ guard (x<=2)
06:48:53 <lambdabot>   [1,2]
06:49:14 <aCube> Is there a nicer way to write this? The lambda is just there to produce a maybe, in my code I can't just use filter.
06:49:41 <aCube> > Data.Foldable.concatMap (maybe [] return) $ http://en.wikipedia.org/wiki/Special:Search?go=Go&search=1],[2,3],[ & traverse %~ (^? _last)
06:49:43 <lambdabot>   <hint>:1:91: parse error on input `='
06:49:50 <aCube> > Data.Foldable.concatMap (maybe [] return) $ http://en.wikipedia.org/wiki/Special:Search?go=Go&search=1],[2,3],[ & traverse %~ (^? _last)
06:49:52 <lambdabot>   <hint>:1:91: parse error on input `='
06:49:58 <aCube> How does that wikipedia link get in there???
06:50:07 <aCube> Im sure i didn't send it
06:50:16 <arkeet> :t Data.Foldable.concatMap (maybe [] return)
06:50:18 <lambdabot> Foldable t => t (Maybe b) -> [b]
06:50:19 <geekosaur> funny irc client?
06:50:19 <epta> elliott: don't you know name of the iconv C library package in ubuntu?
06:50:22 <arkeet> :t catMaybes
06:50:24 <lambdabot> [Maybe a] -> [a]
06:50:28 <aCube> > Data.Foldable.concatMap (maybe [] return) $ [ [1],[2,3],[]] & traverse %~ (^? _last)
06:50:30 <lambdabot>   [1,3]
06:50:39 <arkeet> you should use catMaybes.
06:50:43 <aCube> and I my code, it's a map (so there is no catMaybes)
06:50:47 <arkeet> :s
06:51:02 <arkeet> what exactly is your code supposed todo then?
06:51:09 <aCube> > Data.Foldable.concatMap (maybe [] return) $ [ [1],[2,3],[]] & traverse %~ (^? _last)
06:51:12 <lambdabot>   [1,3]
06:51:13 <aCube> This, just for a map
06:51:32 <arkeet> > [[1],[2,3],[]] ^.. traverse . _last
06:51:34 <lambdabot>   [1,3]
06:51:37 <elliott> epta: nope, apt-cache search iconv should find it though
06:51:40 <aCube> oh, that's nice. Thx!
06:52:10 <elliott> aCube: your irc client is turning [[foo]] into that link probably
06:52:28 <arkeet> > [1,2,3] ^.. folded . filtered (<= 2)
06:52:35 <arkeet> er
06:52:39 <lambdabot>   [1,2]
06:52:42 <arkeet> there we go
06:53:09 <aCube> And when I want the result to also be a map?
06:53:25 <arkeet> what do you mean?
06:53:34 <arkeet> as in, example?
06:54:21 <portnov1> eh
06:54:30 <portnov1> so, perl-golf is outdated?
06:54:42 <aCube> traverse %~ (^? _last) $ M.fromList $ zip [1..] http://en.wikipedia.org/wiki/Special:Search?go=Go&search=1],[2,3],[
06:54:50 <aCube> > traverse %~ (^? _last) $ M.fromList $ zip [1..] [ [1],[2,3],[] ]
06:54:53 <lambdabot>   fromList [(1,Just 1),(2,Just 3),(3,Nothing)]
06:55:04 <arkeet> ok
06:55:04 <arkeet> one sec
06:55:10 <aCube> but now removing every key that has a Nothing and keeping everything with a Just
06:58:16 <arkeet> right.
06:58:17 <arkeet> > [[1],[2,3],[]] ^@.. itraversed <. _last
06:58:21 <lambdabot>   [(0,1),(1,3)]
06:59:14 <arkeet> aCube: ^
06:59:19 <aCube> nice, thx
06:59:31 <totimkopf> hi, I just built a happstack app with cabal-dev, now I have my cabal-dev sandbox and a dist directory, there are two binaries, though. cabal-dev/bin/HappstackApp and dist/build/HappstackApp/HappstackApp   what is the difference between the two?
07:00:02 <aCube> totimkopf: I think the one in cable-dev/ is installed, the other one isn't
07:00:04 <arkeet> totimkopf: the first one is the "installed" version
07:00:31 <totimkopf> I see
07:00:33 <arkeet> > [Just 1, Nothing, Just 35] ^@.. ifolded . _Just
07:00:35 <lambdabot>   [(0,1),(2,35)]
07:00:58 <arkeet> > [Just 1, Nothing, Just 35] ^@.. itraversed . _Just
07:01:00 <lambdabot>   [(0,1),(2,35)]
07:01:26 <aCube> What's the difference between the two?
07:01:37 <arkeet> none really.
07:01:44 <arkeet> ifolded works with any indexed foldable thing
07:02:13 <arkeet> itraversed requires an indexed traversable thing
07:02:24 <arkeet> but lets you modify
07:02:33 <aCube> ah ok
07:03:00 <aCube>  [Just 1, Nothing, Just 35] & itraversed . _Just .~ 1
07:03:01 <aCube> >  [Just 1, Nothing, Just 35] & itraversed . _Just .~ 1
07:03:04 <lambdabot>   [Just 1,Nothing,Just 1]
07:03:13 <aCube> >  [Just 1, Nothing, Just 35] & ifolded . _Just .~ 1
07:03:15 <lambdabot>   No instance for (Control.Lens.Internal.Getter.Gettable
07:03:15 <lambdabot>                     ...
07:04:40 <arkeet> > [Just 1, Nothing, Just 35] & itraversed . _Just .~ (\i a -> i)
07:04:42 <lambdabot>   No instance for (GHC.Show.Show (t0 -> t1 -> t0))
07:04:42 <lambdabot>    arising from a use of `...
07:04:47 <arkeet> > [Just 1, Nothing, Just 35] & itraversed . _Just %@~ (\i a -> i)
07:04:49 <lambdabot>   [Just 0,Nothing,Just 2]
07:05:10 <portnov1> :t %@~
07:05:11 <lambdabot> parse error on input `%@~'
07:05:18 <portnov1> :t (%@~)
07:05:19 <lambdabot> AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t
07:05:35 <portnov1> :t (*@$%)
07:05:36 <lambdabot> Not in scope: `*@$%'
07:05:56 <arkeet> > ["abc","def"] & itraversed Lens.<.> itraversed %@~ (\i a -> i)
07:05:59 <lambdabot>   [[(0,0),(0,1),(0,2)],[(1,0),(1,1),(1,2)]]
07:06:10 <arkeet> > ["abc","def"] & itraversed Lens.<.> itraversed %@~ (,)
07:06:12 <lambdabot>   [[((0,0),'a'),((0,1),'b'),((0,2),'c')],[((1,0),'d'),((1,1),'e'),((1,2),'f')]]
07:06:16 <portnov1> I thoud any string of *@$/+-% is defined as operator in lens...
07:06:19 <arkeet> > ["abc","def"] ^@.. itraversed Lens.<.> itraversed
07:06:21 <lambdabot>   [((0,0),'a'),((0,1),'b'),((0,2),'c'),((1,0),'d'),((1,1),'e'),((1,2),'f')]
07:06:38 <kqr> :t ^@..
07:06:40 <lambdabot> parse error on input `^@..'
07:06:43 <kqr> :t (^@..)
07:06:44 <lambdabot> s -> IndexedGetting i (Endo [(i, a)]) s t a b -> [(i, a)]
07:07:00 <arkeet> (^@..) = itoListOf
07:07:02 <elliott> ^@.. - get (^) indexed (@) list (..)
07:07:21 <kqr> oh lens stuff
07:07:28 <elliott> %@~ - modify with function (%) indexed (@) set (~)
07:07:40 <arkeet> there is logic to the naming. :p
07:07:40 <kqr> ah
07:07:49 <kqr> more than i expected, actually
07:07:51 <kqr> !
07:09:24 <arkeet> aha
07:09:34 <arkeet> imap = ap
07:09:34 <arkeet> :p
07:09:38 <arkeet> (for functions)
07:09:54 <portnov1> each language leads to its own specific crazyness... Java leads to "design patterns" and "band of four", haskell leads to "?%/;.*@" and so on...
07:10:11 <arkeet> no, this is lens's craziness, not haskell's. :p
07:10:24 <arkeet> fwiw, ; isn't a valid operator character.
07:10:30 <aCube> lens is a language!
07:10:51 <ctl> lens makes it more imperative in a sense
07:11:05 <arkeet> lens makes things more composable.
07:11:07 <kqr> portnov1, gang* not band ;)
07:11:09 <arkeet> that is the beauty of them.
07:11:16 <arkeet> or of it.
07:11:27 <arkeet> or of haskell in general.
07:11:57 <ctl> at the expense of clarity sometimes
07:12:00 <arkeet> forget functions, someone make an operadic programming language please. :p
07:12:12 <kqr> arkeet, you mean like J or APL?
07:12:15 <arkeet> no
07:12:21 <arkeet> http://en.wikipedia.org/wiki/Operad
07:12:56 <kqr> oh
07:13:29 <arkeet> or http://ncatlab.org/nlab/show/operad
07:17:09 <ctl> reminds me why I gave up with maths ;)
07:20:36 <Saizan> so they handle more theories than monads can?
07:26:13 <ctl> a monad is just a multimorphism of .. :)
07:26:51 <ctl> poly* would be more correct
07:27:14 <Benni1000> hi
07:29:24 <Benni1000> I get some error when I try to install cabal-dev can anyone help me solve that problem?
07:29:29 <Benni1000> *errors
07:29:32 <skp> hey
07:29:41 <skp> I’m writting a library
07:29:52 <skp> how can I test it a pretty nice way?
07:29:56 <skp> with cabal
07:30:08 <skp> like writting a playset of test programs, for instanc
07:30:09 <skp> e
07:30:37 <Benni1000> You mean like unit-testing?
07:30:49 <skp> yes
07:30:59 <arkeet> skp: there are a few. quickcheck, HUnit, ...
07:31:23 <supki> Benni1000: are you expecting us to guess what errors are? :)
07:31:32 <skp> well I mean
07:31:36 <skp> I have a cabal project
07:31:46 <skp> for instance
07:31:47 <Benni1000> Nope, I just wanted to know if I am in the right Place :P
07:31:51 <skp> hihi.cabal
07:31:56 <Benni1000> I get this errors:
07:31:59 <skp> the lib comes in lib/
07:32:05 <skp> and the test programs in test/
07:32:15 <arkeet> skp: cabal supports test suites. read the user's guide. :p
07:32:16 <skp> each program has a .cabal too
07:32:16 <Benni1000> /usr/bin/ld: cannot find -lHSzlib-0.5.4.1
07:32:17 <Benni1000> /usr/bin/ld: cannot find -lHStar-0.4.0.1
07:32:17 <Benni1000> /usr/bin/ld: cannot find -lHSsetenv-0.1.0
07:32:17 <Benni1000> /usr/bin/ld: cannot find -lHSHTTP-4000.2.8
07:32:17 <Benni1000> /usr/bin/ld: cannot find -lHSnetwork-2.4.1.2
07:32:18 <Benni1000> /usr/bin/ld: cannot find -lHSparsec-3.1.3
07:32:19 <Benni1000> /usr/bin/ld: cannot find -lHStext-0.11.2.3
07:32:21 <Benni1000> /usr/bin/ld: cannot find -lHSmtl-2.1.2
07:32:23 <Benni1000> /usr/bin/ld: cannot find -lHStransformers-0.3.0.0
07:32:23 <arkeet> whoa.
07:32:31 <skp> hihi ok
07:32:48 <Benni1000> I tried googeling it but I only found nothing helpful.
07:32:53 <arkeet> Benni1000: next time use
07:32:54 <arkeet> @hpaste
07:32:54 <lambdabot> Haskell pastebin: http://hpaste.org/
07:33:02 <Benni1000> Oh. Sorry ok.
07:42:06 <Mokosha> Hey guys, I'm a little new to Haskell and I'm trying to wrap my head around laziness and such
07:42:25 <Mokosha> I tried out euler problem #3, and my program seems to be running out of memory
07:42:49 <Mokosha> if anyone can take a look here: http://hpaste.org/83398 and tell me what's up I'd appreciate it a lot =)
07:43:41 <arkeet> you are generating primes very slowly.
07:43:51 <k00mi> Benni1000: you have to install these libraries
07:43:52 <arkeet> it's a poor version of trial division.
07:44:10 <k00mi> Benni1000: but I can't tell you more than that
07:44:24 <arkeet> wait.
07:44:26 <arkeet> it's even worse.
07:45:16 <Benni1000> There are no librarys with that name that's the problem. I know that zblib exists but lHSzlib?
07:45:22 <arkeet> assuming minus does what I think it does.
07:45:37 <hiptobecubic> Benni1000, "-l" is not part of the library name
07:45:53 <Benni1000> ah.
07:46:21 <Benni1000> Then it probably means Haskell zlib?
07:46:27 <geekosaur> HSzlib would be the haskell library corresponding to the haskell zlib package
07:46:51 <geekosaur> this sounds a bit like your ghc installation got relocated but is still pointing to its old location
07:47:11 <Benni1000> Yea that could be the case.
07:47:56 * hackagebot cabal-uninstall 0.1.3 - Uninstall cabal packages  http://hackage.haskell.org/package/cabal-uninstall-0.1.3 (JanChristiansen)
07:48:01 <byorgey> Mokosha: that program completes almost instantly for me.
07:48:33 <byorgey> Mokosha: (also, BTW, 'print' already calls 'show', so 'print . show' is redundant)
07:48:46 <parcs> > negate minBound :: Int
07:48:47 <lambdabot>   -9223372036854775808
07:49:04 <parcs> > minBound :: Int
07:49:06 <lambdabot>   -9223372036854775808
07:49:28 <Ke> > negate maxBound :: Int
07:49:30 <lambdabot>   -9223372036854775807
07:49:42 <Mokosha> byorgey: how can it complete almost instantly for you but not for me?
07:49:49 <parcs> > maxBound + 1 :: Int
07:49:51 <lambdabot>   -9223372036854775808
07:49:51 <byorgey> Mokosha: ah, wait, are you on a 32-bit or 64-bit architecture? =D
07:50:00 <Mokosha> I'm in cygwin
07:50:15 <arkeet> > 600851475143 :: Int32
07:50:17 <lambdabot>   -443946297
07:50:18 <byorgey> Mokosha: evaluate  'maxBound :: Int' at the ghci prompt and tell us what you get
07:50:18 <arkeet> nice.
07:50:27 <arkeet> or evaluate n
07:50:56 <Mokosha> yea it's 32-bit
07:51:11 <byorgey> Mokosha: well, that would explain it, 'n' is too big for Int =)
07:51:17 <byorgey> Mokosha: use Integer instead
07:51:48 <Mokosha> ah thanks!
07:51:54 <Mokosha> that finishes instantly for me too, now!
07:52:00 <byorgey> huzzah!
07:53:28 <arkeet> I guess data-ordlist could come in handy.
07:53:29 <byorgey> it so happens that the largest factor of -443946297 is 5102831  which explains why it was taking so long =)
07:53:48 <arkeet> that and you're using a very slow prime generating function. :p
07:53:59 <arkeet> or are you.
07:54:07 <byorgey> yes, it's quite slow
07:54:08 <arkeet> yeah.
07:54:16 <byorgey> but it doesn't matter for low-numbered PE problems.
07:54:48 <byorgey> for higher-numbered problems you probably want to be using a library like 'arithmoi'.
07:54:56 <Mokosha> this seemed like the best bet for aritosthenes
07:55:01 <Mokosha> or at least
07:55:04 <Mokosha> the most idiomatic
07:55:07 <byorgey> (which is what I used to find the factor of -443946297)
07:55:10 <arkeet> Mokosha: but it's really trial division.
07:55:21 <arkeet> Mokosha: http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
07:55:40 <byorgey> Mokosha: sure, what you wrote is an elegant, idiomatic way of computing primes.  it just happens to be slow =)
07:55:52 <Mokosha> haha, I'm sure
07:55:55 <byorgey> but for computing primes less than 10000 or so it doesn't really matter that much.
07:56:02 <arkeet> @where+ sieve http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
07:56:03 <lambdabot> Done.
07:56:05 <Mokosha> I don't have any idea what "fast" is in haskell
07:56:31 <arkeet> "fast" in haskell is "comparable to C".
07:56:39 <mspells> "completes before they can figure out there's a monad for it already"
07:58:15 <Mokosha> I meant more in terms of what to think about to make a haskell program fast
07:58:29 <arkeet> well, think about why yours is slow. :p
07:58:48 <arkeet> and read the paper.
07:59:17 <Mokosha> I think I'll read the paper first =P
08:05:55 <adas> the state monad is not just a monad right? its a monad transformer yes? or am i confusing things here?
08:06:08 <sipa> State is a monad, StateT is a monad transformer
08:06:12 <arkeet> :k State
08:06:14 <lambdabot> Top level:
08:06:14 <lambdabot>     Type synonym `State' should have 1 argument, but has been given none
08:06:14 <lambdabot>     In a type in a GHCi command: State
08:06:19 <arkeet> uh
08:06:37 <arkeet> State = StateT Identity.
08:06:42 <arkeet> State is a monad. StateT is a monad transformer.
08:06:44 <arkeet> yeah.
08:07:15 <adas> so if i want to use the IO monad with state then I have to use the StateT and not State .. yes?
08:07:27 <sipa> indeed
08:07:59 <arkeet> specifically, StateT IO.
08:08:15 <latro`a> if the definition is unambiguous (for example, in the definition of StateT; iirc this isn't true for ListT), can you derive monad instances for transformers just from the types?
08:08:20 <sipa> StateT <state> IO
08:08:24 <elliott> StateT's monad instance isn't really unambiguous
08:08:33 <latro`a> oh? hm
08:08:37 <elliott> depending on what you mean by that
08:08:45 <latro`a> is there a canonical one that's unambiguous?
08:08:59 <latro`a> other than IdentityT which is silly
08:09:47 <latro`a> perhaps my question just didn't really make sense
08:10:33 <adas> sipa: so if i want to "print" a random number from a pseudo random number generator as the state to keep track then I would have to use the StateT?
08:10:52 <arkeet> one never *has* to use StateT.
08:10:55 <arkeet> but it would be convenient.
08:11:02 <adas> cos im printing (IO) and using State at the same time
08:11:13 <arkeet> :t liftIO
08:11:15 <lambdabot> MonadIO m => IO a -> m a
08:11:19 <elliott> latro`a: ((->) r), perhaps
08:11:33 <latro`a> so ReaderT is unambiguous then?
08:11:46 <latro`a> if so, can its definition be inferred?
08:12:41 <elliott> you can get e.g. State free from an adjunction. for what it's worth.
08:12:54 <arkeet> an adjunction in Hask, even.
08:13:11 <elliott> yes, so you can actually write it in haskell without building a thousand lines of ct machinery up first
08:13:25 <jmcarthur> latro`a: you mean the implementation of its monad instance?
08:13:44 <jmcarthur> @djinn a -> (r -> a)
08:13:44 <lambdabot> f a _ = a
08:13:55 <jmcarthur> @djinn (r -> a) -> (a -> (r -> b)) -> (r -> b)
08:13:56 <lambdabot> f a b c = b (a c) c
08:13:59 <adas> and to use State should i import "Control.Monad.State" or "Control.Monad.Trans.State"?
08:14:22 <adas> i suppose one is for State and the other is for StateT
08:15:02 <jmcarthur> latro`a: also, i don't think IdentityT is so silly. Trival is, though...   data Trivial -- no constructors
08:15:06 <elliott> the former is for mtl and the latter for transformers
08:15:08 <elliott> probably you want the former.
08:15:12 <jmcarthur> sorry, data Trivial a -- no constructors
08:15:12 <elliott> (it contains StateT)
08:15:30 <elliott> jmcarthur: you can't write return for that
08:15:33 <elliott> it's a comonad, not a monad
08:15:43 <jmcarthur> elliott: no, you can't write extract for it
08:15:46 <elliott> ...
08:15:49 <jmcarthur> data Trivial a
08:15:52 <arkeet> you can't write either.
08:16:02 <elliott> you can write extract. it is absurd :: Void -> a
08:16:07 <arkeet> right.
08:16:07 <elliott> data Proxy a = Proxy otoh is a monad
08:16:08 <arkeet> :p
08:16:10 <jmcarthur> oh, i should have made it just have a unit constructor
08:16:12 <jmcarthur> my bad
08:16:18 <jmcarthur> but it's not a comonad either
08:16:23 <arkeet> sure it is.
08:16:27 <elliott> it is a comonad. ex falso quodlibet
08:16:31 <arkeet> it's the (,) Void comonad
08:16:32 <jmcarthur> bah!
08:16:34 <jmcarthur> i see
08:16:36 <jmcarthur> you're right
08:16:53 <elliott> both are sort of useless :P
08:16:55 <elliott> well, those instances.
08:16:57 <jmcarthur> i shouldn't have jumped into #haskell before finishing my morning coffee
08:17:11 <arkeet> while Proxy is the (->) Void monad.
08:17:22 <jmcarthur> i think extract is a reasonable name for absurd, really
08:17:39 <elliott> jmcarthur: yeah but you can't use it on Void
08:17:43 <jmcarthur> just with a different type, i guess
08:17:44 <elliott> you need to use it on Void1 a
08:17:51 <jmcarthur> could be useful enough
08:18:06 <jmcarthur> some sort of a HVoid kind of thing
08:18:18 <jmcarthur> gah
08:18:25 <jmcarthur> ignore me, i'm going to drink coffee
08:18:28 <arkeet> (,) Void
08:19:05 <Taneb> (Void, a) ~~~ Void
08:19:19 <jmcarthur> right
08:19:41 <jmcarthur> but  (,) Void :: * -> *,  while  Void :: *
08:20:07 <elliott> clearly we should identify isomorphic types and have (,) Void be both * and * -> * simultaneously
08:20:15 <Taneb> I jumped in late and got it wrong
08:20:16 <ctl> @kind Void
08:20:17 <jmcarthur> (,) Void  is a monad without having to define a new instance (assuming an instance for Monoid o => (,) o
08:20:17 <lambdabot> Not in scope: type constructor or class `Void'
08:20:28 <elliott> jmcarthur: Void is not a monoid either.
08:20:34 <jmcarthur> fug
08:20:43 <elliott> this conversation is going well :P
08:21:00 <jmcarthur> well, i was right about one thing
08:21:05 <jmcarthur> my suggestion to ignore me was a good idea
08:21:51 * jmcarthur extracts himself from the hole he dug himself into, dusts himself off, and runs away
08:22:35 <elliott> jmcarthur: no, you can't extract yourself from the hole, only return
08:22:41 <elliott> it's a monad
08:24:04 <arkeet> i love comonoids
08:24:06 <arkeet> they are so coeasy
08:24:25 <latro`a> while we're making jokes like that...
08:24:38 <latro`a> a comathematician is a machine for turning cotheorems into ffee
08:24:42 <arkeet> yup
08:24:52 <arkeet> (not a comachine?)
08:24:55 <elliott> arkeet: you mean you *hate* comonoids
08:25:00 <arkeet> no
08:25:02 <arkeet> comonoids love me
08:25:04 <geekosaur> colove
08:25:09 <arkeet> :(
08:25:20 <latro`a> the machine is still an arrow, so I don't think it's a comachine
08:25:26 <jmcarthur> in soviet russia, comonoids love you!
08:47:37 <signalsea> hi. I'm reading about list zippers and comonads. Why would the left and right of (duplicate z) be lists of zippers starting /two/ moves in the respective direction of the original zipper? I don't understand why the tutorial I'm reading does this.
08:47:46 <monochrom> everyone loves my comonoid, but my comonoid loves only me
08:51:41 <signalsea> nevermind!
09:14:38 <totimkopf> could someone be so kind as to give me an example of nullDir for happstack.server? http://hackage.haskell.org/packages/archive/happstack-server/7.1.1/doc/html/Happstack-Server-Routing.html
09:15:54 <robonerd> hello
09:16:10 <robonerd> what is the difference between sortBy and 'order' ?
09:16:19 <robonerd> i mean, why was the term sort used vs order?
09:17:01 <arkeet> sort is a verb
09:17:15 <k00mi> so is 'to order'
09:17:18 <robonerd> so would sort use the order of something?
09:17:29 <monochrom> because in the 1950s they said "sorting algorithm" not "ordering algorithm". but I still don't know why they said that.
09:17:42 * sproingie orders arkeet to sort this sort of thing in order
09:17:48 <arkeet> what's wrong with "sorting algorithm"?
09:17:57 <robonerd> sproingie :)
09:18:04 <robonerd> who said anything is 'wrong'?
09:18:12 <robonerd> it's just a question of terminology
09:18:36 <sproingie> in order to get them in order
09:18:49 <sproingie> standard filing instructions at the Department of Redundancy Department
09:18:56 <robonerd> k, over did it
09:19:46 <monochrom> perhaps ask Knuth. he wrote a book on sorting algorithms. he may know why.
09:19:48 <robonerd> ahh
09:19:54 <robonerd> http://en.wikipedia.org/wiki/Sorting
09:19:58 <robonerd> that seems to explain it fairly well
09:20:01 <sproingie> sortBy is just more obvious.  orderBy would have also worked.  rare case of a haskell API being less terse
09:20:11 <robonerd> sorting is ordering && categorization
09:20:22 <geekosaur> I think it's just that "order" is considered to be an attribute of a type, whereas "sort" implies the ability to use some other ordering
09:20:31 <arkeet> ^
09:20:37 <geekosaur> (but describing this in English is confusing...)
09:20:54 <arkeet> to order something is to assign an ordering.
09:21:18 <arkeet> I guess.
09:21:23 <arkeet> at least in math.
09:21:36 <robonerd> so the 'order' is actaully 'attached' to the quantity/number?
09:21:55 <arkeet> well, the collection of such things.
09:22:31 <robonerd> wait, so is the order attached as attributes to datas, or are orders combined into a separate 'covering' structure?
09:22:45 <arkeet> is an order attached to the number 5?
09:22:49 <arkeet> or to the set of integers?
09:22:50 * geekosaur wonders just how badly we have confused robonerd
09:22:55 <robonerd> 5?
09:22:58 <geekosaur> "order" is something like how 3 < 5
09:23:06 <arkeet> 5 is not ordered.
09:23:09 <arkeet> there is nothing to order.
09:23:16 <geekosaur> you do not get to specify a different ordering such that 5 < 3
09:23:26 <arkeet> yes you do, just pick a different <
09:23:31 <robonerd> ok wait, show me how one would 'order' some numbers in a math statemetn?
09:23:34 <geekosaur> when sorting, however, it makes sense to allwo things like "sort in reverse order"
09:23:45 <arkeet> "the set of natural numbers, ordered by divisibility", say
09:23:58 <arkeet> (partially ordered)
09:24:01 <sproingie> there's an order attached to the set of natural numbers, yes
09:24:12 <arkeet> there are many orders that can be put on it.
09:24:36 <sproingie> i'll take peano for 1000 alex
09:24:37 <geekosaur> in math yes, in haskell not so much... only one Ord instance per type
09:24:45 <arkeet> that's what newtypes are for.
09:24:49 <geekosaur> right
09:25:03 <arkeet> or we can make the ordering explicit.
09:25:04 <geekosaur> ok, maybe we can just add more confusion to this discussion....
09:25:06 <arkeet> by not using instances.
09:25:13 <arkeet> :P
09:31:14 <robonerd> im reading lyah, are lists ordered?
09:31:30 <c_wraith> they are, yes
09:31:40 <c_wraith> > [1, 2] == [2, 1]
09:31:42 <lambdabot>   False
09:31:52 <ctl> since String are
09:32:11 <robonerd> whoa, that's a great point ctl!!
09:32:24 <robonerd> so it seems that order is a strong attribute of haskell lists
09:32:31 <robonerd> ie, important
09:32:42 <arkeet> it is?
09:33:11 <ctl> isn't the ordering of Int defined somewhere in http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Int.html?
09:33:16 <arkeet> oh I thought we were talking about ordered in the sense of <
09:33:27 <arkeet> ctl: it's defined by magic
09:33:33 <ctl> instance Enum
09:34:07 <geekosaur> ctl, instance Ord
09:34:07 <robonerd> no it'd have to be a function
09:34:10 <ctl> arkeet: ordering of caracters are done with utf8 values
09:34:14 <robonerd> no way you could 'define' the order for all numbers
09:34:16 <ctl> chars*
09:34:28 <ctl> for Chars
09:34:30 <arkeet> what is going on in here.
09:34:34 <ctl> i can conceuive it's magical
09:35:26 <ctl> geekosaur: k thx
09:35:59 <arkeet> by magic I mean it's a primitive defined by the compiler.
09:36:01 <jmcarthur> robonerd: i'm not sure i would call ordering in lists "important" so much as just "fundamental"
09:36:39 <jmcarthur> robonerd: "no way you could 'define' the order for all numbers" <- i'm not sure what you mean here
09:36:58 <jmcarthur> robonerd: if it is not definable then where do our comparison functions come from?
09:37:42 <robonerd> didn't know you meant function by that
09:37:57 <nexx> by what?
09:38:07 <robonerd> jmcarthur ok well dicing up words here. if something is fundamental, oh sorry, "fundamental", that's important to the thing's existence i'd say
09:38:21 <robonerd> <ctl>	 isn't the ordering of Int defined
09:38:24 <Sgeo> :t justs
09:38:26 <lambdabot> Not in scope: `justs'
09:38:28 <robonerd> i didn't know if ctl meant a big list of numbers
09:38:35 <Sgeo> @hoogle [Maybe a] -> [a]
09:38:36 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
09:38:36 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
09:38:36 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
09:38:51 <Sgeo> How to define catMaybes without explicit recursion... foldr?
09:38:58 <Sgeo> :t foldr
09:39:00 <lambdabot> (a -> b -> b) -> b -> [a] -> b
09:39:06 <arkeet> foldr works.
09:39:51 <jmcarthur> robonerd: the way you said it made it sound like ordering is a feature that was added to lists even though in some natural sense they are unordered
09:40:02 <arkeet> bonus points if you also use maybe instead of matching on the Maybe
09:40:10 <Sgeo> :t foldr (\i acc -> maybe acc (:acc) i)
09:40:12 <lambdabot> [a] -> [Maybe a] -> [a]
09:40:18 <Sgeo> :t foldr (\i acc -> maybe acc (:acc) i) []
09:40:20 <lambdabot> [Maybe a] -> [a]
09:40:35 <ctl> > let isLower a b = if length (show a) == length (show b) then show a < show b else length (show a) < length (show b) in 5 `isLower` 6
09:40:37 <lambdabot>   True
09:40:49 <jmcarthur> robonerd: well, in some sense a "function" is just a big lookup table. it just happens that there are more compact representations for many useful functions
09:40:54 <robonerd> jmcarthur no i didn't mean that, but i'm a haskell noob. to clarify, lists have intrinsic ordinal position for each element, yes?
09:40:59 <Sgeo> arkeet, is that reasonable, or are explicit lambdas disliked with folds? Because I really only "get" folds when using explicit lambdas
09:41:03 <robonerd> jmcarthur yea that's true
09:41:08 <arkeet> Sgeo: no it's fine. :p
09:41:23 <arkeet> I wouldn't call it acc though.
09:41:28 <arkeet> nothing is being accumulated in a right fold.
09:41:34 <Sgeo> :/
09:42:07 <c_wraith> I usually call it something like "rest"
09:42:15 <geekosaur> jmcarthur, I think Cantor would like a word with you :)
09:42:15 <arkeet> :t toListOf (folded . _Just)
09:42:17 <lambdabot> Foldable f => f (Maybe a) -> [a]
09:42:25 <ctl> > 5 `ltInt64#` 6
09:42:27 <lambdabot>   Not in scope: `ltInt64#'
09:42:31 <Sgeo> :t _Just
09:42:33 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Maybe a) (f (Maybe b))
09:42:33 <robonerd> c_wraith what do you refer to as "rest"?
09:42:39 <jmcarthur> geekosaur: you are referring to my lookup-table claim?
09:42:44 <Sgeo> ...lenses
09:42:44 <geekosaur> yes
09:42:49 <arkeet> Sgeo: ...yes
09:42:49 <arkeet> :p\
09:42:51 * Sgeo backs away slowly and carefully
09:42:52 <arkeet> :p
09:42:54 <jmcarthur> geekosaur: it's just lazily generated ;)
09:42:55 <arkeet> it's fine.
09:42:58 <arkeet> you don't need to understand the types.
09:43:01 <arkeet> to be able to use it.
09:43:09 <robonerd> jmcarthur could you also represent a function in haskell as a tree?
09:43:24 <jmcarthur> robonerd: sure
09:43:26 <robonerd> geekosaur what is your perspective on what a function is? if not a big look up table
09:43:34 <robonerd> by tree i mean a list of lists
09:43:41 <robonerd> if that wasn't clear
09:43:48 <geekosaur> robonerd, I think you missed my point
09:43:52 <robonerd> this is another reason ordinal position in list seems so critical
09:43:56 <robonerd> please explain
09:44:00 <jmcarthur> robonerd: some functions can be more naturally represented by some structures than by others
09:44:07 <Sgeo> jmcarthur, you can't put all real numbers into a list
09:44:14 <geekosaur> the set of real numbers is larger than the size of any possible list
09:44:21 <geekosaur> see Cantor diagonalization
09:44:23 <jmcarthur> Sgeo: we can't compute with all real numbers anyway
09:44:23 <ctl> > [[1]] < [2]
09:44:25 <lambdabot>   No instance for (GHC.Num.Num [t0])
09:44:25 <lambdabot>    arising from the literal `2'
09:44:25 <lambdabot>  Possibl...
09:44:36 <ctl> > [[1]] < [[2]]
09:44:38 <lambdabot>   True
09:44:43 <jmcarthur> geekosaur: i was using "lookup table" in an abstract way
09:44:55 <ctl> > [[11]] < [[2]]
09:44:57 <lambdabot>   False
09:45:04 <Sgeo> I guess you could put all possible CReals into a list
09:45:06 <ctl> smart
09:45:18 <ctl> > [["11"]] < [["2"]]
09:45:21 <lambdabot>   True
09:45:36 <jmcarthur> Sgeo: not sure if they are actually countable though
09:46:05 <ctl> @type (< [["11"]])
09:46:06 <lambdabot> [[[Char]]] -> Bool
09:46:17 <robonerd> @type (< ["11"])
09:46:18 <lambdabot> [[Char]] -> Bool
09:46:24 <robonerd> @type (< "11")
09:46:25 <lambdabot> [Char] -> Bool
09:46:31 <robonerd> @type ("11")
09:46:32 <lambdabot> [Char]
09:46:37 <robonerd> @type (<)
09:46:39 <lambdabot> Ord a => a -> a -> Bool
09:46:45 <robonerd> mm
09:46:47 <arkeet> please note: you can do this in private with lambdabot.
09:47:07 <ctl> robonerd do /msg lambdabot  if you do more, (that's what
09:47:10 <ctl> i do)
09:48:47 <nexx> > [[],[]] < [[]]
09:48:49 <lambdabot>   False
09:49:44 <robonerd> @type (->)
09:49:46 <lambdabot> parse error on input `->'
09:50:00 <latro`a> :k (->)
09:50:01 <lambdabot> * -> * -> *
09:50:05 <Sgeo> That would totally give an answer in Idris (I think)
09:50:07 <robonerd> what's the difference between when bot says => and -> please?
09:50:16 <ctl> > [[],[]] > [[]]
09:50:18 <lambdabot>   True
09:50:24 <latro`a> => says what precedes it is a constraint; -> is the function arrow
09:50:52 <robonerd> what proceeds it is a constraint, what's a constraint?
09:50:52 <arkeet> read a bit about typeclasses to learn more.
09:51:29 <arkeet> in "Ord a => a -> a -> Bool", "Ord a" means that "a must be a type that is an instance of Ord"
09:51:30 <latro`a> essentially Ord a => ... means that a is required to be orderable, Eq a => ... means that a is required to be equatable, etc.
09:51:38 <arkeet> Ord is a typeclass.
09:51:54 <latro`a> the "full version" involves typeclasses
09:52:16 <robonerd> oo, cool notation
09:52:50 <robonerd> @type (Ord a)
09:52:52 <lambdabot> Not in scope: data constructor `Ord'
09:52:55 <robonerd> @type (Ord)
09:52:58 <lambdabot> Not in scope: data constructor `Ord'
09:53:01 <arkeet> :k Ord
09:53:03 <lambdabot> * -> Constraint
09:53:13 <robonerd> @type (Ord a =>)
09:53:16 <lambdabot> parse error on input `=>'
09:53:19 <arkeet> => is syntax.
09:53:28 <arkeet> it's not really a thing on its own.
09:53:54 <robonerd> "Ord a" means that "a must be a type that is an instance of Ord" <- or you get an error? or do you get Bool false?
09:53:57 <raek> robonerd: in ghci you can do ":i Ord"
09:54:21 <raek> robonerd: the constraint is checked at compile time
09:54:25 <arkeet> robonerd: if you try to use it with a type that's not, you get a type error.
09:54:25 <latro`a> > (+1) < (+2)
09:54:26 <arkeet> at compile time
09:54:28 <lambdabot>   No instance for (GHC.Classes.Ord (a0 -> a0))
09:54:28 <lambdabot>    arising from a use of `GHC....
09:54:31 <arkeet> like that
09:55:41 <elliott> (=>) :: Constraint -> * -> *
09:55:45 <elliott> (maybe k -> k?)
09:55:55 <robonerd> ahh
09:56:04 <robonerd> what does :i mean?
09:56:04 <arkeet> well not literally.
09:56:11 <arkeet> short for :info
09:56:26 <arkeet> and :k for :kind, :t for :type, etc.
09:58:12 <ctl> > Right 2 < Left 1
09:58:13 <lambdabot>   False
09:58:27 <robonerd> so why was i typing @type if :t is for type?
09:58:32 <ctl> > Left 2 < Right 1
09:58:34 <lambdabot>   True
09:58:53 <robonerd> :t Ord
09:58:55 <lambdabot> Not in scope: data constructor `Ord'
09:59:03 <ctl> robonerd http://www.haskell.org/haskellwiki/Lambdabot
09:59:09 <robonerd> ahh
09:59:49 <arkeet> robonerd: :t doesn't work in pm.
09:59:54 <arkeet> also, Ord is not a value.
10:00:03 <arkeet> it's a typeclass.
10:00:08 <ctl> but @type works in pm
10:00:34 <byorgey> :k Ord
10:00:36 <lambdabot> * -> Constraint
10:00:42 <byorgey> =D
10:00:48 <byorgey> it's nice having an up-to-date lambdabot.
10:00:54 <Taneb> :k (Ord Int, Monad [])
10:00:56 <lambdabot> Constraint
10:01:04 <dario> what does :k do?
10:01:08 <arkeet> shows the kind of a type.
10:01:12 <arkeet> or "type".
10:01:25 <dario> so it's like @ty ?
10:01:31 <arkeet> no, type shows the type of a value.
10:01:36 <raek> haskell is so meta
10:01:38 <robonerd> :k Type
10:01:40 <lambdabot>     Not in scope: type constructor or class `Type'
10:01:40 <lambdabot>     Perhaps you meant `Tape' (imported from Control.Lens)
10:01:44 <byorgey> dario: yes, @type shows the type of a value; @kind shows the kind of a type.
10:01:47 <arkeet> :k Int
10:01:49 <lambdabot> *
10:01:49 <robonerd> what is the kind of type?
10:01:50 <arkeet> :k Maybe
10:01:51 <lambdabot> * -> *
10:01:53 <arkeet> :k (->)
10:01:55 <lambdabot> * -> * -> *
10:02:00 <arkeet> :k Eq
10:02:02 <lambdabot> * -> Constraint
10:02:02 <dario> byorgey: so one meta-level above types, kinda?
10:02:04 <arkeet> :k Functor
10:02:05 <srhb> robonerd: Basically "how many type parameters" it needs to make a concrete type.
10:02:06 <lambdabot> (* -> *) -> Constraint
10:02:17 <byorgey> dario: exactly, no 'kinda' necessary
10:02:28 <byorgey> dario: types classify values; kinds classify types
10:02:35 <dario> i see..
10:02:36 <arkeet> sorts classify kinds, but haskell only has one sort.
10:03:01 <byorgey> (for now)
10:03:05 <arkeet> hehe
10:03:10 <McManiaC> anyone here using haskellmode for vim? what is the _? key combination and why do I always end up in search mode?
10:03:17 <robonerd> what is the 1 sort?
10:03:23 <arkeet> BOX
10:03:26 <robonerd> ?
10:03:27 <byorgey> robonerd: what do you mean?
10:03:30 <arkeet> yes.
10:03:35 <robonerd> "but haskell only has one sort."
10:03:43 <byorgey> oh, the 1 sort.  It doesn't really matter what you call it, because there is only one. =)
10:03:49 <simpson> It's known as BOX.
10:03:49 <arkeet> :)
10:03:53 <robonerd> what does it do? how do you know it
10:03:53 <byorgey> but it is often called 'box' (written as a little square)
10:04:15 <byorgey> it doesn't do anything.
10:04:18 <byorgey> it just IS
10:04:19 <simpson> You never actually see it in code, because there's no way to express it.
10:04:26 <robonerd> sounds stupid
10:04:28 <arkeet> kinds and types doesn't really "do" anything either.
10:04:30 <robonerd> so it's some empty function
10:04:31 <robonerd> big deal
10:04:42 <robonerd> BUT OYU COULD DESCRIBE IT
10:04:51 <byorgey> robonerd: it's not a function.  It is a box.
10:05:22 <byorgey> The box does not care whether you think it is stupid.  It is box.
10:05:41 <jfischoff> @remember byorgey The box does not care whether you think it is stupid.  It is box.
10:05:41 <lambdabot> Nice!
10:06:06 <elliott> we can all only aspire to be box
10:06:43 <simpson> robonerd: The big idea here is that, in set theory, reasoning about things is difficult if you say "Oh, it could be *anything*." It's a lot easier to work with a limited set, even if it's only important in theory and papers that talk about the theory.
10:06:43 <robonerd> sounds like haskell is turning into another fanboy zealot lang
10:06:51 <elliott> robonerd: stop trolling.
10:06:57 <simpson> robonerd: Haskell is an academic research language. Always has been.
10:07:00 <arkeet> you ask, we answer.
10:07:05 <ctl> box or type constructor
10:07:47 <ctl> the analogy with box doesn't talk to me :~
10:08:01 <elliott> ctl: ? it's not an analogy
10:08:05 <elliott> BOX is just the name of the sort of all kinds
10:08:08 <ctl> but the idea of paramtric type does
10:08:09 <robonerd> the attribute which describes a list's order, what is that called?
10:08:36 <arkeet> robonerd: which "order" do you mean?
10:08:46 <arkeet> the ordering of elements within a list, or the ordering on the type of lists?
10:08:57 <robonerd> the ordering of elements within a list
10:08:59 <byorgey> robonerd: permutation?
10:09:13 <arkeet> it's not really called anything I guess.
10:09:26 <byorgey> or "order"
10:09:44 <ctl> elliott: right http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/kind-polymorphism-and-promotion.html
10:10:42 <robonerd> seems index is pretty common
10:10:50 <arkeet> index?
10:11:08 <srhb> Do you mean where a specfic element is? If so, yes, index. Otherwise order.
10:11:12 <robonerd> yes
10:11:23 <arkeet> but we don't use indices with lists.
10:11:30 <robonerd> not explicitly maybe
10:11:51 <srhb> The only index we use is 0 :-)
10:11:56 <robonerd> but given list element order is preserved and this is "fundamental" as said earlier, it's implicit
10:12:04 <arkeet> preserved? by what?
10:12:09 <robonerd> logical circles man
10:13:25 * elliott isn't sure what you're getting at.
10:13:35 <robonerd> <jmcarthur>	 robonerd: i'm not sure i would call ordering in lists "important" so much as just "fundamental"
10:13:40 <srhb> As far as I can figure, the fact that lists aren't a random jumble of elements.
10:13:50 <robonerd> yes
10:13:50 <robonerd> that's what i mean
10:13:55 <elliott> well, it's just how the list type is defined
10:13:57 <elliott> you can do it yourself:
10:13:58 <arkeet> well if they weren't, they wouldn't be lists.
10:14:03 <robonerd> see what happens when you take things for granted? you can't even think
10:14:04 <elliott> data List a = Nil | Cons a (List a)
10:14:17 <robonerd> arkeet, they wouldn't?
10:14:17 <elliott> that's not really magic. it's just the ability to define data types
10:14:21 <robonerd> can you define list for me?
10:14:27 <srhb> ^^^^
10:14:29 <srhb> Up there
10:14:34 <robonerd> in english
10:15:27 <arkeet> why do you want it defined in an ambiguous, complicated language?
10:15:27 <srhb> A singly linked list is a list where each element is either a Cons with a value and a link to a linked list, or Nil, the empty list.
10:15:37 <byorgey> 'a list is a finite, ordered collection of elements' -- how's that?
10:15:47 <arkeet> but we have infinite lists.
10:15:53 <robonerd> ok, and the order is some number internally?
10:16:01 <arkeet> there are no numbers.
10:16:09 <elliott> the order isn't a thing.
10:16:09 <arkeet> there is only the nil/cons structure
10:16:14 <elliott> it's a relationship between the elements inside the list.
10:16:20 <robonerd> ahh
10:16:22 <srhb> Cons 1 (Cons 2 (Cons 3 (Cons Nil)))
10:16:22 <elliott> it doesn't have to have a physical representation in memory or anything
10:16:32 <elliott> if you have 1 before 2 and 2 before 3, then that's an order.
10:16:35 <arkeet> srhb: I think you mean just Nil, not Cons Nil
10:16:40 <srhb> Eh yes
10:16:45 <jmcarthur> robonerd: a list is either empty or its an element and some other list
10:16:46 <elliott> if you have "hello" before "goodbye" in your list, that's part of your list's order
10:16:53 <awgn> I have a problem with the existential quantification that I'm not able to fix. What's wrong with this snippet? http://pastebin.com/w5MbJCnb ?
10:16:56 <mauke> The paste w5MbJCnb has been copied to http://hpaste.org/83414
10:17:24 <robonerd> ok
10:17:28 <robonerd> ty everyone
10:17:51 <arkeet> awgn: x and y can't be guaranteed to be the same type.
10:18:17 <geekosaur> also the "print x" will fail because there's no Show instance
10:18:18 <arkeet> they also can't be guaranteed to have the specific type a.
10:18:36 <awgn> is there a workaround for this ?
10:18:49 * geekosaur wonder si this is another example of trying to pretend that existentials work like OO typing, or is a deeper confusion
10:19:01 <byorgey> awgn had a problem.  "I know, I'll use existential wrappers!"  Now awgn has two problems.
10:19:08 <arkeet> indeed.
10:19:45 <byorgey> awgn: if you include a Typeable constraint, then you can dynamically check whether the two things have the same type.
10:19:54 <byorgey> awgn: but I don't necessarily recommend doing that.
10:20:17 <byorgey> i.e. there's probably a better way to do whatever it is you're trying to do.
10:20:27 <geekosaur> awgn: may I ask what you were trying to accomplish by making fun's result type [a] instead of e.g. [Test], and then not specifying anywhere what an a would be?
10:20:28 <awgn> for sure...
10:20:52 <geekosaur> (note, the "a" in that has nothing whatsoever to the "a" you used in the definition of Test)
10:20:52 <elliott> byorgey is author of the famous paper "Regular Expressions as Existential Types"
10:21:02 <geekosaur> *to do with
10:21:25 <arkeet> elliott: I want that to be a real paper now.
10:21:35 <byorgey> wow, I am? sweet!
10:22:00 <elliott> I'm afraid I don't see any obvious way to make that even sort of true
10:22:11 <awgn> I'm trying to grasp the existential quantification and what I understood is that the type is that the type constructor is deprived by the dependecy of a type...
10:22:22 <ctl> a regex as type, hmm
10:22:31 <srhb> ctl: Don't!
10:22:35 <srhb> Madness lies down that road.
10:22:42 <awgn> and then they can be arranded in a list...
10:22:48 <awgn> *arranged*
10:22:48 <ctl> :))
10:22:51 <arkeet> awgn: an existential type is like
10:22:53 <arkeet> a union of all types
10:23:05 <arkeet> except you have no way to tell which type a value came from
10:23:12 <arkeet> or that two of your values came from the same type
10:23:28 <awgn> yes
10:24:08 <awgn> so I was trying to create a list of Storable type and indeed it is feasible
10:24:24 <arkeet> ok
10:24:27 <elliott> note that the list can contain *different* Storable types.
10:24:36 <elliott> but that means that all you can do with the elements of the list is use the operations of Storable on them
10:24:41 <elliott> since you don't know what type you got out of any given element.
10:24:48 <arkeet> stop taking the words from my mouth.
10:24:48 <awgn> precisely
10:24:50 <geekosaur> (Storable is not a type, it is a family of types)
10:25:02 <arkeet> I start typing and then before I can finish elliott has already said it.
10:25:17 <elliott> arkeet: my typing services are available for $100/hr.
10:25:29 <geekosaur> so perhaps what you wanted was [Test] instead of [a]
10:25:31 <elliott> you will need to install a transmitter in your brain so I know what to type
10:26:08 <awgn> geekosaur, ops yes! I got it :-)
10:26:41 <arkeet> you still won't be able to print the list.
10:27:07 <geekosaur> and again I will note that the a on line 7 is unrelated to the a on line 5, and that you did not also require a Show constraint so you cannot use print on the result
10:27:17 <awgn> arkeet, yep right. Thank you all :)
10:28:02 * hackagebot free-game 0.3.2.4 - Create graphical applications for free.  http://hackage.haskell.org/package/free-game-0.3.2.4 (FumiakiKinoshita)
10:28:04 * hackagebot stm-promise 0.0.1.1 - Simple STM Promises for IO computations and external processes  http://hackage.haskell.org/package/stm-promise-0.0.1.1 (DanRosen)
10:28:06 * hackagebot stickyKeysHotKey 0.1.0.1 - get and set STICKYKEYS.SKF_HOTKEYACTIVE  http://hackage.haskell.org/package/stickyKeysHotKey-0.1.0.1 (SoenkeHahn)
10:33:23 <ctl> ah existential types are the forall kw..
10:33:32 <ctl> defined with*
10:35:09 <Saizan> somewhat confusingly
10:35:34 <Saizan> but if you think of the type of the constructor it makes sense
10:36:18 <arkeet> the most confusing part is really the data definition syntax.
10:36:27 <arkeet> much clearer with GADTs.
10:37:41 <lispy> hello
10:38:20 <Sgeo> Would I have to understand free monads to use FreeGame?
10:38:37 <arkeet> I don't think so.
10:39:11 <arkeet> Maybe is a free monad, but you don't need to understand free monads to use Maybe.
10:39:13 * Sgeo likes that FreeGame actually allows for using arbitrary IO actions
10:39:48 <Sgeo> I should try to understand free monads I think
10:40:13 <simpson> free-game doesn't seem bad, but it doesn't seem optimal.
10:40:39 <Sgeo> In what way?
10:40:58 <Sgeo> I'm thinking maybe showing my gf free-game might convince her to try Haskell
10:40:58 <elliott> you get what you pay for
10:41:04 <Sgeo> Shes an XNA and C# lover
10:41:07 * jmcarthur facepalms
10:41:42 <monochrom> is free-game a package name and on hackage?
10:41:57 <Saizan> yes
10:42:03 <jmcarthur> just uploaded
10:44:40 <ctl> arkeet: like http://www.haskell.org/haskellwiki/Existential_types 2.3?
10:45:00 <Sgeo> When could runGame result in a Nothing?
10:45:11 <arkeet> ??
10:45:16 <arkeet> ctl: my response to that: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
10:45:20 <ctl> oops didn't read GADT comes in 2.4
10:45:53 <Sgeo> runGame :: GameParam -> Game a -> IO (Maybe a)
10:46:10 <elliott> Sgeo: you can deduce the answer from http://hackage.haskell.org/packages/archive/free-game/0.3.2.3/doc/html/Graphics-FreeGame-Base.html#t:Game
10:46:57 <Sgeo> Assume that I don't fully understand free monads....
10:47:45 <Saizan> knowing about free monads wouldn't help much
10:47:45 <Sgeo> Oh, maybe when the game quits?
10:47:59 <Sgeo> I think that's what makes the most sense
10:48:06 <Sgeo> There's no a in QuitGame
10:48:09 <Saizan> yeah
10:48:10 <elliott> if (runGame _ QuitGame) resulted in (Just a), what could a possibly be?
10:50:32 <Sgeo> There's a package for Void.
10:51:43 <drdo> Does anyone use any convention for ignored type variables?
10:52:07 <drdo> i.e. the ones you can call _ on the value level
10:52:22 <elliott> Sgeo: several I think
10:53:04 * hackagebot one-liner 0.1 - Constraint-based generics  http://hackage.haskell.org/package/one-liner-0.1 (SjoerdVisscher)
10:53:30 <feliperosa> Hi guys. I'm trying to compile with profiling but GHC keeps say 'Dynamic linking required...', what's that about?
10:54:25 <Sgeo> Does each tick in free-game happen instantaneously? That is, if I do getButtonState twice, in the same tick, will I have the same result?
10:56:19 <Sgeo> Hmm, embedIO makes implementing that seem possibly problematic :/
11:11:01 <ctl> Can anyone look at http://codegolf.stackexchange.com/a/3995/7459 and the main, loop, next functions. THe way it's done, does it mean if 2 requests arrives at same time, one will be handled after the other is sent back?
11:11:22 <JoeHazzers> i'm trying to go about simplifying algebraic expressions, such that something like "(2 + 6) * 4 * x" can become "32 * x". how should i go about this?
11:11:51 <lispy> JoeHazzers: in general people refer to that as constant folding. Perhaps you can find that on google?
11:11:51 <feliperosa> JoeHazzers: parsing it?
11:11:56 <ctl> operators precedences..
11:12:00 <jaroslaw> JoeHazzers: Try thinking about them as trees...
11:12:59 <JoeHazzers> it is represented as a data structure, like Times (Times (Add (Lit 2) (Lit 6)) (Lit 4)) (Var x)
11:13:37 <jaroslaw> :)
11:14:07 <JoeHazzers> my problem is how to approach the "partial" evaluation of it
11:14:09 <Sgeo> What's the difference between using free monads and using something like operational?
11:15:59 <lispy> JoeHazzers: I'd start at the leaves of the tree and go up combining things where it makes sense to do so
11:16:18 <JoeHazzers> is this going to involve some horrible pattern matching?
11:16:27 <Saizan> Sgeo: Operational f ~~ Free (CoYoneda f) iirc
11:16:46 <lispy> suppose you're at constantFold (Add (Lit x) (Lit y)) = Lit (x + y)
11:16:48 <ctl> JoeHazzers: breadth-first traversal of trees
11:17:01 <Sgeo> I have no idea what CoYoneda is?
11:17:08 <JoeHazzers> lispy: uh huh
11:17:48 <Saizan> Sgeo: CoYoneda f a = forall b. CY (f b) (b -> a)
11:18:24 <Saizan> Sgeo: s/CoYoneda/data CoYoneda/
11:18:53 <lispy> Just to raise awareness, this problem (constant folding) was solved elegantly as early as 1979 using attribute grammars. So, uh, here is to reminding people that attribute grammars are a nice abstraction.
11:19:26 <Saizan> it's isomorphic to f a when f is a functor, but it's still a functor even when f isn't
11:19:44 <lispy> http://dl.acm.org/citation.cfm?id=2245804
11:21:00 <Sgeo> :t Fix
11:21:02 <lambdabot> Not in scope: data constructor `Fix'
11:22:24 <elliott> @src Fix
11:22:25 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
11:22:30 <elliott> oh I guess it's just in @djinn-env
11:22:35 <elliott> @where L.hs
11:22:36 <lambdabot> What lambdabot has in scope is at <http://code.haskell.org/lambdabot/State/L.hs>
11:22:41 <elliott> wow, wasn't expecting that to exist
11:22:52 <elliott> :t In
11:22:54 <lambdabot> f (Mu f) -> Mu f
11:24:08 <nimish> > :k :::
11:24:10 <lambdabot>   <hint>:1:1: parse error on input `:'
11:24:18 <nimish> > :k (:::)
11:24:21 <lambdabot>   <hint>:1:1: parse error on input `:'
11:25:00 <Sgeo> When would someone use operational and when would someone just use a free monad/
11:25:03 <geekosaur> nimish: no > prefix for :t, :k, etc.
11:25:14 <nimish> geekosaur: thanks
11:25:22 <nimish> :k (:::)
11:25:25 <lambdabot> Not in scope: type constructor or class `:::'
11:25:26 <geekosaur> but that doens't sound like a standard operatoer
11:25:30 <nimish> hmm
11:25:33 <elliott> Sgeo: they are both equivalent modulo a very simple translation
11:25:34 <geekosaur> where did you get it from?
11:25:34 <Sgeo> > head cake
11:25:37 <lambdabot>   "One 18.25 ounce package chocolate cake mix."
11:25:39 <elliott> so whichever you find more convenient
11:25:54 <JoeHazzers> lispy: i don't want you to answer my question, being assessed work and all (which i am finding extremely interesting), and my structure is such that data Expr = T | Var String | And Expr Expr | Not Expr. I've been tasked with doing partial evaluation of the expression, to do things like simplify out ocurrences of (And T Expr) to just Expr, simplify (Not (Not Expr)) to just Expr and things like this.
11:26:00 <nimish> geekosaur: https://github.com/jonsterling/Vinyl
11:26:06 <nimish> wasn't sure whether it was built-in
11:26:10 <JoeHazzers> i'm looking for pointers on topics i should investigate, really.
11:26:55 <geekosaur> oh, hairy type extensions...
11:27:08 <Sgeo> a `asTypeIn` f = a where _ = f a
11:27:10 <Sgeo> I don't get that
11:27:18 <Sgeo> where is creating something without a name?
11:27:43 <nimish> geekosaur: completely mystified as to where (:::) comes from though
11:27:54 <geekosaur> Sgeo, it's just a pattern match
11:28:07 <Sgeo> erm?
11:28:14 <elliott> f _ = 32
11:28:22 <Sgeo> Yes, but this looks like _ = 32
11:28:24 <Sgeo> Not f _ = 32
11:28:25 <elliott> f x = y where Just y = x
11:28:27 <nimish> found it, should have looked hard >_<
11:28:39 <elliott> f x = y+z where (y,z) = compute x
11:28:45 <Sgeo> Hmm, ok
11:28:53 <elliott> if you accept all these examples as reasonable, "f x = y where _ = ..." should make sense
11:28:56 <ctl> lol I download a file at 220 KB/s from localhost using this server http://codegolf.stackexchange.com/a/3995/7459
11:29:06 <ctl> it's also totally blocking
11:29:10 <Sgeo> There's the question of what's the point of doing that
11:29:23 <lispy> JoeHazzers: http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue4/Why_Attribute_Grammars_Matter
11:29:26 <ctl> even if you move a file from the directory
11:29:37 <arkeet> Sgeo: it's so they can write "f x" somewhere
11:29:39 <arkeet> to make the types work
11:30:02 <arkeet> or rather, to restrict the types
11:30:10 <lispy> JoeHazzers: attribute grammars are basically a nice abstraction for computing values based on a tree. In this case, building a new tree that is simpler than the input tree.
11:30:21 <JoeHazzers> lispy: thank you!
11:30:34 <Sgeo> > let (Just x) = Nothing in 5
11:30:36 <lambdabot>   5
11:30:39 <Sgeo> > let (Just x) = Nothing in x
11:30:42 <lambdabot>   *Exception: <interactive>:3:5-22: Irrefutable pattern failed for pattern (D...
11:31:01 <edwardk> > let !(Just x) = Nothing in 5
11:31:03 <lambdabot>   *Exception: <interactive>:3:5-23: Non-exhaustive patterns in pattern binding
11:31:35 <crl> > let 5 = 4 in 5
11:31:37 <lambdabot>   5
11:31:50 <arkeet> looks like it's time to learn about attribute grammars.
11:32:15 <lispy> JoeHazzers: Haskell can model the grammars directly as a data type which means the attribute grammar style traversals could probably be implemented as combinators directly in Haskell. So I don't know why the utrecht folks made a separate pre-processor but they probably had a good reason.
11:32:51 <lispy> in fact, I bet it's a task lens would be good at
11:33:12 <elliott> you mean it's a task?!
11:33:33 <lispy> it's a task in Hask
11:34:28 <lispy> ah, here we go: http://130.203.133.150/viewdoc/summary;jsessionid=BD7017288A2F6110959646790B23CC30?doi=10.1.1.228.1456
11:34:54 * lispy disappears
11:39:33 <bxc> if i have a line like this in a do block, should I be expecting "fail" to be invoked to deal with a pattern match failure?
11:39:37 <bxc>   let (Just (DNSFormat h q ans auth add)) = maybeHereNSresult
11:41:26 <elliott> bxc: hm, good question. I know Just x <- ... uses fail
11:41:31 <elliott> @undo do { let Just x = y; z }
11:41:32 <lambdabot>  Parse error at "}" (column 24)
11:41:36 <johnw> bxc: easy to test
11:41:52 <elliott> > do { let Just y = Nothing; return y } :: Either String Int
11:41:54 <lambdabot>   <hint>:1:37: parse error on input `}'
11:42:00 <elliott> > do { let { Just y = Nothing }; return y } :: Either String Int
11:42:03 <lambdabot>   Right *Exception: <interactive>:3:12-27: Irrefutable pattern failed for pat...
11:42:06 <elliott> @undo do { let { Just x = y }; z }
11:42:07 <lambdabot> let { Just x = y} in z
11:42:11 <elliott> looks like no
11:42:22 * bxc nods
11:42:29 <johnw> what does 'fail' do for Maybe?
11:42:35 <bxc> Nothing, I think
11:42:41 <geekosaur> fail _ = Nothing
11:42:49 <johnw> i see
11:42:53 <monochrom> > fail "hello" :: Maybe Int
11:42:55 <lambdabot>   Nothing
11:43:03 <johnw> > do { Just x <- Nothing; Nothing }
11:43:04 <lambdabot>   Nothing
11:43:49 <Taneb> > do {(a, b) <- Nothing; return a}
11:43:51 <lambdabot>   Nothing
11:44:16 <monochrom> I am going to mess with your mind
11:44:34 <monochrom> > do { x:xs <- Just []; return x }
11:44:36 <lambdabot>   Nothing
11:45:12 <Taneb> Is it bad that the thing I'm having the most trouble with that is that x:xs isn't in brackets?
11:45:26 <bxc> anyway I'm rewriting that line as something else, before anyone grumbles at me that its bad style.
11:45:31 <monochrom> it is good. my goal is to mess with your mind. :)
11:46:00 <monochrom> oh, but I guess Haskell syntax, not me, is messing with your mind :)
11:47:43 <Sgeo> Does Free Maybe work differently from Maybe as a monad?
11:48:01 <monochrom> yes, Free Maybe is something strange
11:48:07 <crdueck> is there a catagorical reasoning for fail being part of the Monad typeclass?
11:48:13 <jfischoff> no
11:48:28 <bxc> its icky and shouldn't be used!
11:48:28 <elliott> Sgeo: Free (Const Void) = Maybe
11:48:32 * bxc uses it anyway just for now
11:48:45 <elliott> crdueck: not categorical but pedagogical
11:48:49 <elliott> (it's still a mistake)
11:48:59 <elliott> Sgeo: er wait
11:49:02 <elliott> Sgeo: Free Proxy = Maybe
11:49:04 <crdueck> i've never actually used fail, I just wonder why its there
11:49:26 <elliott> Free (Const Void) = Identity
11:49:32 <elliott> crdueck: you use it every time you pattern-match inside "do", at least
11:49:36 <geekosaur> there are those who believe fail was a mistake
11:49:39 <elliott> (well, not every time...)
11:49:42 <elliott> which is the reason it's in Monad
11:50:05 <Taneb> Cofree Proxy = Identity
11:50:05 <elliott> aiui, it was thought to be too confusing to newbies for the required constraint to change (to MonadFail or such) if you used pattern-matches that are partial inside a do block
11:50:16 <Taneb> Didn't realise you could do it with Free (Const Proxy)
11:51:21 <Jesin> I really look forward to the LLVM backend for GHC getting awesome
11:51:23 <monochrom> otoh, for pedagogical purpose, perhaps you can just tell beginners about "var <- action" but not "pat <- action"
11:51:44 <jfischoff> Jesin: its already pretty awesome
11:51:56 <jfischoff> I guess it can always get better
11:52:14 <Jesin> hm, last I heard (sometime in the last 3 months)
11:52:36 <Jesin> they apparently "weren't quite using LLVM the way it's supposed to be used"
11:52:50 <Jesin> or something, so that LLVM's optimization passes couldn't do as much as they can with other languages.
11:53:01 <bxc> i guess if i had said (Just x) <- return (Nothing) i would have got fail being used
11:53:27 <Jesin> um
11:53:35 <Jesin> bxc: doesn't that result in x = Nothing ?
11:53:48 <geekosaur> Jesin, ghc is cps-transforming before handling off to llvm, which makes the result pretty much non-optimizeable
11:53:59 <Jesin> because (return :: a -> Maybe a) = Just ?
11:54:06 <HugoDaniel> :)
11:54:09 <bxc> oh yeah sorry
11:54:19 <geekosaur> not so much "not the way it's supposed to be used", as "hard problem"
11:54:20 <elliott> no
11:54:28 <Jesin> huh.
11:54:30 <elliott> it then pattern-matches the result (what's inside the Just) with (Just x)
11:54:41 <elliott> consider working in IO or such rather than Maybe to reduce the layer confusion
11:54:54 <Jesin> elliott: what's "no" about
11:55:17 <Jesin> my answer was correct, wasn't it?
11:55:20 <elliott> <Jesin> bxc: doesn't that result in x = Nothing ?  <Jesin> because (return :: a -> Maybe a) = Just ?
11:55:22 <mauke> Jesin: no
11:55:23 <elliott> is false, for the reason I gave
11:55:47 <elliott> > do { Just x <- return Nothing; return (length x) } :: Maybe Int
11:55:49 <lambdabot>   Nothing
11:56:21 <Jesin> > do { Just x <- return Nothing ; x }
11:56:23 <lambdabot>   No instance for (GHC.Show.Show (m0 b0))
11:56:23 <lambdabot>    arising from a use of `M28373561...
11:56:31 <Jesin> ...huh.
11:56:47 <Jesin> > do { Just x <- return Nothing ; x } :: Maybe Integer
11:56:49 <lambdabot>   Nothing
11:56:56 <Jesin> > do { Just x <- return Nothing ; x } :: Maybe [Integer]
11:56:58 <lambdabot>   Nothing
11:56:58 <elliott> > do { x <- Just 123; return x }
11:57:01 <lambdabot>   Just 123
11:57:01 <crl> > 'f':"oo"
11:57:03 <lambdabot>   "foo"
11:57:05 <bxc> for now i've done this:
11:57:05 <Jesin> elliott: looks like I'm right
11:57:05 <bxc> +  (DNSFormat h q ans auth add) <- maybe (fail "Parent NS did not return a result") return maybeHereNSresult
11:57:12 <elliott> Jesin: you are not
11:57:15 <mauke> Jesin: no
11:57:15 <bxc> as its the closest to what i had written before
11:57:19 <elliott> the binding of "x" has a confusing type there.
11:57:24 <mauke> Jesin: you are failing recursively
11:57:29 <elliott> in particular (return Nothing) gets the type (Maybe (Maybe [Integer]))
11:57:38 <Jesin> elliott: I know it does
11:57:44 <elliott> x *never* gets bound to nothing.
11:57:48 <elliott> *Nothing
11:57:54 <mauke> stop trying to return x in any form
11:57:55 <Jesin> huh
11:57:56 <elliott> > do { Just x <- return Nothing; Just 123 }
11:57:58 <mauke> return 123
11:57:58 <lambdabot>   Nothing
11:58:02 <elliott> by your reasoning this should result in Just 123
11:58:20 <Jesin> > do { Just x <- return Nothing ; return x } :: Maybe [Integer]
11:58:21 <elliott> your code never shows us the value of "x", in fact (the reason is: it does not get bound at all, because the pattern-match fails)
11:58:21 <lambdabot>   Nothing
11:58:24 <Jesin> you're right
11:58:25 <Jesin> okay
11:58:30 <Jesin> derp
11:58:49 <elliott> to match y against Just x in the Maybe monad, you write "x <- y"
11:58:50 <Jesin> @undo do { Just x <- return Nothing ; x } :: Maybe Integer
11:58:50 <lambdabot> return Nothing >>= \ a -> case a of { Just x -> x; _ -> fail ""} :: Maybe Integer
11:59:04 <mauke> <- removes a layer
11:59:06 <elliott> so "Just x <- return Nothing" aka "Just x <- Just Nothing" matches "Just Nothing" against "Just (Just x)"
11:59:09 <elliott> which fails
11:59:22 <Jesin> ohright.
11:59:27 <Jesin> ^^;
11:59:27 <Jesin> yeah
11:59:33 <mauke> in '... <- Just Nothing', the '<-' and 'Just' cancel out
11:59:35 <Jesin> sorry about that, it's... been a while
11:59:37 <Jesin> >_>
11:59:53 <Jesin> hah, I remember this now.
12:00:07 <stulli> Is there a way to write something like 'type typeA, typeB = Int'? Or do i always need to use multiple lines?
12:00:12 <Jesin> I also remember the one Monad I've encountered that I've still never managed to understand very well is Cont
12:00:24 <crl> > do { x <- return Nothing; Just 123 }
12:00:25 <mauke> stulli: multiple 'type's, not necessarily lines
12:00:26 <lambdabot>   Just 123
12:01:54 <elliott> Jesin: perhaps http://blog.sigfpe.com/2008/12/mother-of-all-monads.html will help re: Cont?
12:02:07 <Jesin> perhaps
12:02:18 <Jesin> heh, it always seemed inside-out to me, relative to other monads
12:04:01 <Sgeo> If you know shift/reset, Cont (the constructor) is basically shift
12:04:06 <Sgeo> If that helps
12:04:15 <mauke> haha
12:04:32 <Sgeo> It helped for me...
12:04:48 <crl> @hoogle Cont
12:04:48 <lambdabot> Data.Char Control :: GeneralCategory
12:04:48 <lambdabot> Language.Haskell.TH.Syntax ConT :: Name -> Type
12:04:48 <lambdabot> Language.Haskell.TH ConT :: Name -> Type
12:04:59 <Sgeo> @hoogle cont
12:05:00 <lambdabot> Data.Char Control :: GeneralCategory
12:05:00 <lambdabot> Language.Haskell.TH.Syntax ConT :: Name -> Type
12:05:01 <lambdabot> Language.Haskell.TH ConT :: Name -> Type
12:05:03 <Sgeo> :(
12:05:06 <Sgeo> :t Cont
12:05:08 <lambdabot>     Not in scope: data constructor `Cont'
12:05:08 <lambdabot>     Perhaps you meant one of these:
12:05:08 <lambdabot>       `Const' (imported from Control.Applicative),
12:05:11 <Sgeo> :t cont
12:05:12 <crl> unknown
12:05:13 <lambdabot> ((a -> r) -> r) -> Cont r a
12:05:46 <Jesin> I do not know shift/reset
12:05:46 <Jesin> but
12:05:50 <crl> @kind Cont
12:05:52 <lambdabot> Top level:
12:05:52 <lambdabot>     Type synonym `Cont' should have 1 argument, but has been given none
12:05:52 <lambdabot>     In a type in a GHCi command: Cont
12:05:56 <Jesin> wow
12:05:58 <Foo__> hello, not really a question about haskell but here it comes: I recently came across this puzzle http://stetson.edu/~efriedma/npr (the first one) and solved it via recursively brute-forcing which I'm not quite happy with. Any tips on how to solve this more efficiently?
12:06:00 <crl> @kind Cont Int
12:06:02 <lambdabot> * -> *
12:06:13 <Jesin> this "mother of all monads" article is much more understandable now than it was 6 months ago even though it hasn't been edited
12:06:14 <Jesin> :p
12:06:55 <crl> @hoogle Control.Monad.Cont
12:06:56 <lambdabot> Control.Monad.Trans.Cont type Cont r = ContT r Identity
12:06:56 <lambdabot> Control.Monad.Cont type Cont r = ContT r Identity
12:06:56 <lambdabot> Control.Monad.Trans.Cont cont :: ((a -> r) -> r) -> Cont r a
12:07:57 <Jesin> except... wait
12:08:05 <Jesin> how is it
12:08:12 <Jesin> nvm I don't get it yet
12:08:26 <TravisD> Is the kind of a Monad transformer (* -> *) -> (* -> *)?
12:08:37 <Sgeo> When you do cont, the thing you passes in takes over completely
12:08:42 <Sgeo> *pass in
12:08:50 <Jesin> @kind StateT
12:08:52 <lambdabot> * -> (* -> *) -> * -> *
12:09:06 <Jesin> @kind ContT
12:09:07 <lambdabot> * -> (* -> *) -> * -> *
12:09:13 <Sgeo> cont (\k -> ...)
12:09:31 <Sgeo> The ... takes over. k is a function that is "the rest of" the computation.
12:09:51 <TravisD> Jesin: I may be wrong, but (StateT a) is a state transformer, but StateT alone is not?
12:10:01 <int-e> TravisD: right
12:10:01 <TravisD> er, Monad transformer*
12:10:05 <Jesin> TravisD: I believe you're correct
12:10:08 <Sgeo> do { foo <- cont (\k ->  ...); <<rest>> }
12:10:11 <int-e> @kind MonadTrans
12:10:13 <lambdabot> ((* -> *) -> * -> *) -> Constraint
12:10:24 <Sgeo> ... takes over running. It can ignore k, in which case, <<rest>> never happens
12:10:40 <TravisD> int-e: Hmm, what's the "-> Constraint" business?
12:10:45 <Sgeo> It can pass k a value. When that happens, that value goes in foo, rest happens, and the result from k is the result from the whole thing
12:10:53 <mauke> @kind Show
12:10:54 <lambdabot> * -> Constraint
12:11:04 <int-e> TravisD: constraints go in front of => in type signatures
12:11:06 <mauke> @kind Show Int
12:11:08 <lambdabot> Constraint
12:11:09 <Jesin> TravisD: it means you're inspecting the type of a classname, rather than a type constructor
12:11:26 <mauke> @kind Show Show
12:11:28 <elliott> hmm, I wonder what making (=>) :: Constraint -> * -> * would actually entail
12:11:28 <lambdabot>     Expecting one more argument to `Show'
12:11:28 <lambdabot>     In a type in a GHCi command: Show Show
12:11:35 <elliott> you could do instance Foo (c => a), I wonder what that would mean
12:11:41 <mauke> @kind Show (Show Int)
12:11:43 <lambdabot>     Predicate `Show Int' used as a type
12:11:43 <lambdabot>     In a type in a GHCi command: Show (Show Int)
12:11:53 <elliott> I guess it'd be "overlappy" like type families and hence disallowed
12:12:02 <TravisD> Ah, I guess I've never actually seen kinds formally defined. I was just confused about what it meant in that expression
12:12:11 <Foo__> I've thought about reducing the search space by backing out if the expression evaluates to >= 2002 and all 9 digits haven't been processed yet, but parsing the expression is costly.
12:14:10 <Jesin> @kind (=>)
12:14:11 <lambdabot> parse error on input `=>'
12:14:13 <Jesin> :p
12:15:43 <kmels> how do you write `flip (++) "."` in terms of (:) and '.' ?
12:16:04 <mauke> no
12:16:23 <int-e> TravisD: if you look at the haskell report, you'll only find kinds * and k1 -> k2 where k1,k2 are again kinds. The Constraint kind is a ghc invention in connection with its fairly recent DataKinds extension.
12:17:44 <TravisD> int-e: Ah, I see. So MonadTrans is of kind ((* -> *) -> * -> *) -> Constraint but all MonadTransformers are of kind (* -> *) -> * -> *?
12:18:15 <int-e> TravisD: yes. (The argument of the MonadTrans type class is a monad transformer.)
12:18:20 <elliott> yes, just as Show :: * -> Constraint and hence all Showables are *
12:18:42 <elliott> more generally, if a typeclass Foo :: k -> Constraint classifies Foos, then Foos are of kind k
12:18:50 <elliott> (of course, multi-parameter typeclasses don't necessarily look like Foo there)
12:18:58 <TravisD> And "Constraint" in those expressions is (at least intuitively) just capturing the fact that instances of MonadTrans, Show, etc need to have some functions defined?
12:21:39 <elliott> TravisD: hm, not sure what you mean by that
12:21:47 <elliott> if something is a Constraint then you can put it before =>, is the meaning
12:21:54 <TravisD> ah
12:21:59 <elliott> so (Show a) is a constraint if a is a type, you can write blah :: Show a => a -> Int or such
12:22:40 <TravisD> And saying "Show a => a - >Int" or something just requires that a have the function show :: a -> String defined, right?
12:22:56 <int-e> So you can think of Constraint as representing some sort of evidence that a given constraint holds.
12:22:57 <elliott> well, it requires that a be an instance of Show
12:23:01 <elliott> @src Show
12:23:01 <lambdabot> class  Show a  where
12:23:02 <lambdabot>     showsPrec :: Int -> a -> ShowS
12:23:02 <lambdabot>     show      :: a   -> String
12:23:02 <lambdabot>     showList  :: [a] -> ShowS
12:23:19 <elliott> which requires that you define an "instance Show TheType" and define either show or showsPrec (or both) there
12:23:22 <elliott> (and optionally showList)
12:23:29 <elliott> some typeclasess require more, e.g. Ord requires that you also give an instance of Eq for the same type
12:23:45 <TravisD> Alright, thanks :) Sorry for being a bit foggy and unclear
12:33:06 * hackagebot haskell-updater 1.2.0.9 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.0.9 (SergeiTrofimovich)
12:35:16 <crl> :t showsPrec
12:35:18 <lambdabot> Show a => Int -> a -> ShowS
12:35:46 <crl> > showsPrec 1 "foo"
12:35:47 <lambdabot>   No instance for (GHC.Show.Show GHC.Show.ShowS)
12:35:47 <lambdabot>    arising from a use of `M1...
12:37:35 <crl> > showsPrec 1 "foo" ""
12:37:36 <lambdabot>   "\"foo\""
12:40:36 <Sgeo> If every monad can be described in terms of operational, does that mean that every monad is a free monad for some functor?
12:40:37 <hiptobecubic> Is there any good reason not to use 7.6.2?
12:40:43 <hiptobecubic> Showstopper missing libraries or something?
12:41:20 <jfischoff> 7.6.2 as opposed to 7.4.1?
12:41:38 <hiptobecubic> 7.4.2 is what i currently have
12:41:44 <jfischoff> oh right
12:41:54 <hiptobecubic> but .cabal and .ghc is a hideous mess
12:41:59 <jfischoff> I think the Haskell Platform isn't on 7.6.* yet
12:42:05 <hiptobecubic> so time to nuke and reinstall
12:42:14 <hiptobecubic> true, but I don't use it anyway
12:42:24 <jfischoff> right then I would say no
12:42:30 <hiptobecubic> good enough for me
12:42:32 <hiptobecubic> cheers
12:42:33 <jfischoff> well
12:42:44 <jfischoff> 7.8.* is right around the corner
12:42:54 <Sgeo> I think error messages that suggest -XFooBar should mention the LANGUAGE pragma
12:43:13 <crdueck> @hoogle MonadIO m => m (IO a) -> m a
12:43:14 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
12:43:14 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
12:43:14 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
12:43:34 <crdueck> :t join . liftIO
12:43:36 <lambdabot> MonadIO m => IO (m a) -> m a
12:43:47 <mauke> :t (>>= liftIO)
12:43:48 <lambdabot> MonadIO m => m (IO b) -> m b
12:43:55 <crdueck> mauke: thanks
12:44:05 <mauke> :t join . liftM liftIO
12:44:07 <lambdabot> MonadIO m => m (IO a) -> m a
12:45:03 <crdueck> :t \f -> gets (join . liftM liftIO f)
12:45:05 <lambdabot> (MonadIO m1, MonadState s m) => (s -> IO (m1 a)) -> m (m1 a)
12:45:24 <crdueck> :t \f -> join $ gets (liftM liftIO f)
12:45:25 <lambdabot> (MonadIO m, MonadState s m) => (s -> IO a) -> m a
12:46:55 <tdammers> so, I've been playing around with the jackd bindings, but I'm getting a lot of xruns
12:47:21 <tdammers> my guess is that it has to do with realtime code
12:47:47 <crdueck> :t liftM liftIO
12:47:48 <lambdabot> (Monad m, MonadIO m1) => m (IO a) -> m (m1 a)
12:48:10 <crdueck> @hoogle (Monad m, MonadIO m1) => m (IO a) -> m (m1 a)
12:48:11 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
12:48:11 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
12:48:11 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
12:48:31 <tdammers> so I'm wondering how I'd make sure my haskell code is realtime-safe
12:49:03 <tdammers> I know how to do it in C...
12:49:29 <hiptobecubic> what does it mean to be realtime safe
12:49:36 <hiptobecubic> and how would you do that in a language with gc?
12:49:45 <tdammers> that's exactly what I'm wondering
12:50:01 <tdammers> realtime safe means you can't do things that might cause the kernel to block
12:50:10 <tdammers> so no I/O, no memory allocations
12:50:47 <hiptobecubic> no ghcrts then
12:54:59 <tdammers> that kind of sucks
12:55:22 <tdammers> as far as data structures go, haskell would be ideal for what I want to do
12:57:51 <lispy> Sgeo: I bet that would be a simple enough patch to ghc if you want to write it
12:58:05 <hiptobecubic> Ok so now that I've nuked everything. I want to avoid this problem in the future
12:58:09 <hiptobecubic> I assume cabal-dev is the way to go
12:58:28 <hiptobecubic> but how to do that for things like xmonad, for example?
12:58:35 <hiptobecubic> just go to an empty directory somewhere and cabal-dev install xmonad?
13:00:04 <jcp> hiptobecubic: I had problems with webdriver on 7.6, but I can't think of any other reason
13:00:26 <hiptobecubic> jcp, don't know what that is. So i'm sure it will be fine :)
13:05:45 <TravisD> Does anyone here have some experience with the random-fu package?
13:06:26 <tdammers> hmm, hold on... apparently I compiled the jack with optimizations disabled
13:06:35 <tdammers> let's see what happens with -O2
13:06:59 <epta> Trying to get into cabal lib. Here is PackageIndex module http://hackage.haskell.org/packages/archive/Cabal/1.16.0.3/doc/html/Distribution-Simple-PackageIndex.html . How can I retrive PackageIndex of my cabal system?
13:10:00 <hiptobecubic> So... I guess no one has tried to build xmonad-contrib with ghc-7.6.2?
13:10:40 <epta> hiptobecubic: what is wrong with it?
13:11:08 <hiptobecubic> JUst an ambigous name apparently
13:11:12 <cdntr> Haskell newcomer here; I have a function: lastButOne :: [a] -> Maybe a. Now, when I try to use that function like so: putStrLn $ show $ lastButOne [], I get: Ambiguous type variable `a0' in the constraint.
13:11:30 <elliott> cdntr: it doesn't know which "a" you picked for (Maybe a)
13:11:31 <hiptobecubic> all i did was "cabal-dev install xmonad xmonad-contrib" in an empty dir
13:11:33 <elliott> since [] works for all "a"s
13:11:39 <cdntr> I tried fixing that like so: putStrLn $ show $ (lastButOne []) :: Maybe
13:11:45 <elliott> putStrLn $ show (lastButOne [] :: Maybe Int) would work, say
13:11:51 <elliott> or () instead of Int, or String instead of Int, etc.
13:11:56 <Guest28611> :t []
13:11:58 <lambdabot> [a]
13:12:27 <Guest28611> elliott: unfortunately, it doesnt ignore the type because it evaluates to Nothing ;)
13:12:34 <Guest28611> :t Nothing
13:12:34 <cdntr> Ah ok, yeah, that was my understanding. I just didn't realize I had to add another type to Maybe
13:12:35 <lambdabot> Maybe a
13:12:55 <Guest28611> > show Nothing
13:12:56 <lambdabot>   "Nothing"
13:12:59 <elliott> Guest28611: huh?
13:13:02 <Guest28611> :t show Nothing
13:13:03 <lambdabot> String
13:13:09 <elliott> that "show Nothing" works is GHCi-specific
13:13:18 <Guest28611> heh
13:13:18 <elliott> putStrLn $ show Nothing should fail in your program too, I believe
13:13:28 <Guest28611> lastButOne [] is Nothing
13:13:36 <elliott> yes, I understand
13:13:39 <Guest28611> hehe it should be smart
13:14:02 * elliott wouldn't like it to be smart here -- it would be making type-correctness essentially depend on the optimisation of constant folding!
13:14:14 <hiptobecubic> where does cabal-dev put the source while building?
13:14:29 <cdntr> OK< I believe I perfectly understand the problem. It didn't know which instance of the typeclass Maybe to use
13:14:43 <elliott> cdntr: Maybe isn't a typeclass
13:14:53 <epta> hiptobecubic: in ./cabal-dev dir
13:15:02 <Guest28611> Maybe is a type constructor
13:15:06 <cdntr> Right
13:15:09 <Guest28611> * -> *
13:15:09 <elliott> no typeclasses or instances at all involved here
13:15:19 <elliott> well, in Maybe -- it is true that it doesn't know what instance of Show you want
13:15:35 <hiptobecubic> cdntr, you didn't know which type the Maybe was parametrized over
13:15:41 <elliott> because it knows it can show (Maybe a) given that it can show a, but it doesn't know what "a" is, so it doesn't know whether it can show it or not, so you have to tell it what a is by giving the full type :)
13:16:23 <hiptobecubic> epta, there are may subdirs, none of which seem to have any source in them
13:17:35 <hiptobecubic> epta, just a lot of interface files
13:17:44 <cdntr> Gracias
13:17:54 <lispy> hiptobecubic: delegates the building to cabal, so look in dist or /tmp
13:17:58 <hiptobecubic> ok
13:18:16 * lispy isn't really sure where cabal builds things
13:18:47 <hiptobecubic> lispy, right. I don't see anything in tmp and i can't find dist
13:19:18 <hiptobecubic> aha
13:19:18 <hiptobecubic> in ~/.cabal
13:19:41 <hiptobecubic> although how is this possible
13:19:46 <epta> Are you sure that cabal-dev produce something in ~/.cabal ?
13:19:48 <hiptobecubic> xmonad-contrib doesn't build? that can't be right
13:20:11 <hiptobecubic> epta, apparently so. I'm looking at it
13:21:56 <geekosaur> someone pushed out a new X11 binding that causes a name clash, I think. you can force X11-1.6.0.2 or use darcs xmonad/xmonad-contrib
13:22:09 <cdntr> elliott: One last question just to make sure: putStrLn $ show (lastButOne [] :: Maybe Int) tells the compiler that the return value of the function is Maybe Int, right? I was just wondering for a second what the operator precedence is, there, but I believe function application has the highest precedence?
13:22:47 <Guest28611> same as ((lastButOne []) :: Maybe Int)
13:23:05 <elliott> cdntr: right, :: binds more loosely than anything
13:23:16 <elliott> (long expression here :: t) means "long expression here, with type t"
13:26:41 <Mathnerd314> hmm, why can't I do (f a :: Int) = ... ?
13:27:13 <Mathnerd314> (besides the fact that GHC doesn't like it)
13:27:20 <geekosaur> (a) because (f a) isn't likely to be an Int (b) because it requires an extension
13:27:37 <geekosaur> a might be an Int though: f (a :: Int) = ...
13:28:33 <epta> hiptobecubic: btw, xmonad-contrib from darcs HEAD builds fine for me
13:29:08 <hiptobecubic> hm
13:29:19 <parcs> > let f a :: Int = 5 in ()
13:29:21 <lambdabot>   <hint>:1:5: Parse error in pattern: f
13:29:31 <parcs> Mathnerd314: might be hard to parse?
13:29:31 <geekosaur> PatternBindings?
13:29:39 <hiptobecubic> I'm just trying "cabal-dev install xmonad-contrib", so whatever is latest on hackage
13:29:54 <Mathnerd314> parcs: right, that ends up being where the error is
13:29:59 <Mathnerd314> > let a :: Int = 5 in ()
13:30:01 <lambdabot>   ()
13:30:12 <geekosaur> [03 16:21] <geekosaur> someone pushed out a new X11 binding that causes a name clash, I think. you can force X11-1.6.0.2 or use darcs xmonad/xmonad-contrib
13:30:29 <Mathnerd314> that's why I filed ticket 7676... :-)
13:30:37 <epta> geekosaur: 03 is a current month?
13:30:47 <geekosaur> current day
13:31:46 <hiptobecubic> epta, yes. definitely fails due to a bug in the code
13:32:53 <epta> not sure
13:33:10 <cdntr> elliott: Mind elaborating on why `lastButOne []` works in GHCi?
13:33:42 <elliott> cdntr: it has extended defaulting rules that default types to () as a last resort
13:33:46 <elliott> so it gets inferred as Maybe () there
13:33:50 <hiptobecubic> epta, http://vpaste.net/Ws8qC
13:34:34 <cdntr> ah
13:45:54 <epta> geekosaur: what is wrong with 1.6.1.1 version?
13:46:07 <epta> XMonadContrib from darcs build fine with it
13:48:16 <geekosaur> yes, because we applied a patch to work around it. basically getAtomName is now being exported from someplace it wasn't, and leads to a conflict; the fix was to have DebugHooks not automatically export everything (it didn't constrain its exports because there wasn't originally a reason to)
13:48:59 <geekosaur> hm, actually, backwards
13:50:18 <geekosaur> xmonad started leaking it, DebugEvents had been importing it from X11 and broke
13:50:53 * geekosaur just pulled up DebugHooks to see what was changed
13:50:53 <epta> hiptobecubic: like geekosaur said, force X11-1.6.0.2 in `cabal install' query, or just `darcs get http://code.haskell.org/XMonadContrib' and install it from source
13:51:22 <crl> > let in=let in in
13:51:24 <lambdabot>   <hint>:1:7: parse error on input `='
13:51:55 <monochrom> "in" is a reserved word
13:52:34 <geekosaur> so, originally it was exported from a sub-module of Graphics.X11.Xlib.Extras, apparently it got merged into that module which caused XMonad to re-export it
13:53:25 <monochrom> it is in fact allowed to have 0 equations between let and in, e.g., "let in 4" = "4"
13:54:07 <crl> > let out=(let out=2) in out
13:54:08 <lambdabot>   <hint>:1:19: parse error on input `)'
13:54:29 <awestroke> > let x = x + 1
13:54:30 <lambdabot>   not an expression: `let x = x + 1'
13:54:40 <monochrom> "(let out=2)" is incomplete
13:54:57 <hpc> it still needs the actual expression
13:55:09 <hpc> let [no definitions] in [expr] is an expression
13:55:23 <hpc> let [definitions] is not
13:55:36 <awestroke> > let x = x + 1 in x
13:55:40 <lambdabot>   mueval-core: Time limit exceeded
13:56:12 <monochrom> unfortunately, "x = x + 1" is a recursion
13:56:25 <awestroke> I know, I wanted to know how the bot handled it :)
13:56:37 <monochrom> then it is a good experiment
13:56:58 <crl> > (\x -> let y = x in y) 2
13:56:59 <lambdabot>   2
13:57:47 <fxr> anybody knows what a IVC device is? haskell/HaNS/src/Hans/Device/Ivc.hs
13:57:48 <parcs> > let ?x = 0 in let ?x = ?x + 1 in ?x
13:57:50 <lambdabot>   can't find file: L.hs
13:59:44 <monochrom> try again. "can't find file: L.hs" is a rare race condition
14:00:04 <srhb> "rare"
14:04:23 <fxr> okay I got it, it's xen specific
14:05:33 <fxr> inter-vm-comm
14:05:39 <elliott> monochrom: not very rare
14:06:22 <nh2> I need a package for conveniently deal with 2d/3d vectors for graphics programming
14:06:56 <nh2> looking at http://hackage.haskell.org/packages/archive/Tensor/1.0.0.1/doc/html/Data-Tensor.html but it doesn't even have things like cross or dot product
14:07:26 <nh2> of course these operations are all trivial, still not really my job
14:07:55 <tgeeky> probably ought to try the 'vector' package
14:08:36 <parcs> nh2: linear
14:08:45 <nh2> tgeeky: vector is fixed-size lists, that one has nothing to do with 2d/3d vectors
14:09:06 <tgeeky> nh2: http://hackage.haskell.org/package/linear-0.2
14:09:35 <nh2> parcs, tgeeky: I'll have a look!
14:09:42 <tgeeky> nh2: and vector is very generic, probably too generic
14:10:22 <hiptobecubic> hsmatrix?
14:10:59 <tgeeky> nh2: one of the "problems" of Haskell is too many solutions to problems like this
14:11:24 <johnw> nh2: I think there are about 3 "low-dimension" matrix libraries on Hackage
14:11:44 <tgeeky> I assume 'repa' does all of these things too
14:11:56 <johnw> linear is a good choice, as is hmatrix and repa
14:12:12 <monochrom> rarity is in the eyes of the beholder. I may call a piece of steak rare, but someone else may say it's overdone. :)
14:12:23 <tgeeky> monochrom: like the cow, for instance
14:12:39 <monochrom> I love steak. it's so tasty!
14:12:44 <nh2> speeking of these things
14:12:53 <nh2> found in "linear": "class  Complicated t  where"
14:13:14 <monochrom> haha Complicated
14:13:27 <tgeeky> me too. 20 min in (oil + butter) + rock salt -> scrape off -> pepper -> grill in cast iron skillet for 30 sec/side -> 5 min in oven -> meat that melts like butter
14:16:23 <Mathnerd314> seems like Complicated deals with embeddings - lets you do stuff over (1) the real part and (2) the other components
14:16:55 <monochrom> oh, Complicated is a generalization of complex numbers? :)
14:17:25 <Guest28611> Fubar
14:17:27 <crl> @hoogle parse
14:17:28 <lambdabot> Data.Version parseVersion :: ReadP Version
14:17:28 <lambdabot> Language.Haskell.Parser module Language.Haskell.Parser
14:17:28 <lambdabot> Text.Parsec.Prim parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a
14:17:44 <crl> :t parse
14:17:45 <lambdabot> Not in scope: `parse'
14:18:20 <Mathnerd314> monochrom: yeah, probably. :-)
14:19:10 <Mathnerd314> have to ask edwardk about it to be sure
14:19:15 <edwardk> ?
14:19:41 <edwardk> on Complicated not Compensated
14:19:43 <edwardk> er oh
14:20:00 <edwardk> Complicated is the class with the _e and _i lens?
14:20:04 <Mathnerd314> yeah
14:20:26 <monochrom> you view everything through the glasses of lens...
14:20:31 <edwardk> yeah its mostly so i can pun the names e and i when i work with quaternions, so i have e i j and k there
14:21:01 <edwardk> i thought for a minute you were talking about my recent work on Compensated
14:21:05 <danharaj> {-# LANGUAGE ValuePuns #-}
14:21:12 <edwardk> http://rebase.org/analytics/Data-Analytics-Numeric-Compensated.html
14:21:34 <edwardk> >>> round (Prelude.product [2..100] :: Compensated (Compensated (Compensated Double)))
14:21:35 <edwardk> 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
14:21:51 <edwardk> > product [2..100]
14:21:52 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
14:23:05 <danharaj> edwardk: I was afk for a few days, but do you have time to talk about Analytics.Task now?
14:23:12 <edwardk> sure
14:23:44 <Mathnerd314> > drop 80 . show $ product [2..100]
14:23:48 <lambdabot>   "60894146397615651828625369792082722375825118521091686400000000000000000000...
14:24:20 <danharaj> edwardk: My brain discarded that stack frame a while ago, but I remember something about a grand vision too ambitious to fulfill currently.
14:24:27 <edwardk> basically its a pub/sub model. you get observers: http://rebase.org/analytics/Data-Analytics-Task-Observer.html that receive events (with (!) when something happens until the source dies or is completed)
14:24:57 <edwardk> basically you register an Observer with any Observable: http://rebase.org/analytics/Data-Analytics-Task-Observable.html
14:25:16 <edwardk> and it gives you a Subscription http://rebase.org/analytics/Data-Analytics-Task-Subscription.html you can cancel to stop receiving messages
14:25:35 <edwardk> the Task monad itself is basically Cont with dynamic-wind.
14:25:36 <crl> the ! looks ik erlang
14:25:43 <edwardk> crl: quite deliberately =)
14:26:05 <edwardk> the task monad  lets you send messages and spawn new tasks that will eventually be run
14:26:15 <crl> in erlang in works nter process through
14:26:19 <edwardk> that way we avoid getting into infinitely recursive join towers
14:26:20 <edwardk> sure
14:26:23 <crl> it*
14:26:28 <edwardk> not in scope for my needs here
14:27:08 <edwardk> this is within a system, registering things like callbacks for the I/O manager to run when the resources they need are available or for things like umping counters to send to statsd or graphite
14:27:13 <edwardk> er bumping
14:27:33 <edwardk> cross-system communication is another system
14:28:39 <edwardk> the model here is actually quite close to the .net reactive framework minus the bits that leak memory
14:28:44 <crl> registering callbacks, then it's more like the mediator pattern
14:29:29 <crl> like the way you register events onclick, .. in javascript
14:29:53 <edwardk> its a little odd though because i can capture the entire current continuation and pas it off to the block manager, etc. and it'll ensure that i've reacquired whatever resources i need, etc.
14:30:46 <edwardk> but yes
14:30:58 <edwardk> to a first order approximation it is a fairly traditional OOP technique ;)
14:32:02 <edwardk> it message passing plus a work-stealing job queue
14:32:05 <edwardk> er it is
14:33:51 <danharaj> edwardk: I can't find the definition of `run` used in the example under Task.Observer
14:34:02 <danharaj> Trying to get a feel for the implementation.
14:34:14 <edwardk> ah yeah thats not in the current branch if you back up a could of revisions to before i added the dynamic-wind support its in there
14:35:01 <edwardk> this got tabled for a few days while i worked on figuring out cache oblivious b-tree like column store structures and on making it easier to write backends for the edsl for datalog
14:35:22 <danharaj> Nothing you do is trivial, is it? :P
14:35:44 <edwardk> if it is trivial is it worth doing?
14:36:02 <nh2> danharaj: what is a ValuePun?
14:36:13 <danharaj> nh2: see the `lens` library
14:36:29 <edwardk> ValuePun?
14:37:38 <danharaj> I jokingly said {-# LANGUAGE ValuePuns #-} earlier as a joke ala NamedFieldPuns because of certain libraries' tendency to make puns on value names :P
14:37:42 <edwardk> ah
14:37:48 <danharaj> It wasn't that funny.
14:38:16 <edwardk> i for one value your pun
14:39:23 <danharaj> :3
14:39:23 <edwardk> or should that have been "I ValuePuns" or "Aye, Value Puns"
14:39:54 <edwardk> > rot13 "funpuns"
14:39:56 <lambdabot>   Not in scope: `rot13'
14:40:09 <shachaf> hi
14:40:23 <shachaf> @@ @let rot13 = @where rot13
14:40:26 <lambdabot>  Defined.
14:40:32 <elliott> shachaf: clever
14:41:50 <lightquake> what's the emacs tags file generating package everybody uses?
14:42:13 <lightquake> i see 4 on cabal
14:42:17 <shachaf> I use hasktags to generate vim tags
14:42:23 <johnw> lightquake: I use hasktags
14:42:26 <shachaf> Sometimes I forget to specify the option and it generates the wrong kind of tags.
14:42:36 <shachaf> Then I get annoying errors.
14:42:39 <johnw> lightquake: my exact command is: find . -name '*.hs' | xargs hasktags -e -o - > TAGS
14:42:42 <shachaf> So I think it can to emacs too. :-)
14:42:53 <lightquake> shachaf: haha
14:42:53 <shachaf> johnw: hasktags can look into directories recursively.
14:43:02 <johnw> yes, but it doesn't work
14:43:07 <DarkOtter> danharaj: I have to admit I'm relieved, I just spent a few minutes wondering why I couldn't find anything about ValuePuns
14:43:12 <shachaf> Hmm, works for me.
14:43:35 <johnw> yeah, but you don't use Emacs
14:43:51 <johnw> when i use the builtin recursion, the TAGS file isn't entirely accurate
14:44:04 <lightquake> "hasktags: tags: openFile: resource busy (file is locked)"
14:44:08 <danharaj> edwardk: there's only one commit pertaining to Task on github and before that, it didn't exist :P
14:44:14 <johnw> lightquake: yeah, and that's why I use -o -
14:44:25 <edwardk> danharaj: it used to be in Data.Analytics.Active.Task
14:44:35 <danharaj> ohh
14:44:38 <danharaj> derp
14:44:38 <edwardk> i changed it as i moved it
14:45:11 <sm> johnw: good command, as long as you don't have a virthualenv or cabal-dev dir!
14:45:17 * sm takes note
14:45:22 <johnw> sm: i use it with cabal-dev all the time
14:45:29 <johnw> sm: there are no .hs files under my cabal-dev...
14:45:47 <sm> hmm, my bad. virthualenv then ? Or I'm confused
14:45:56 <johnw> i'm using it to generate TAGS for 916 source files
14:45:59 <johnw> yeah, I don't use hsenv
14:46:19 <sm> I might also be thinking of find . -name "*.o" -exec rm -f {} \;
14:46:38 <shachaf> 916? All I use it for is GHC.
14:46:45 <shachaf> ~200 files
14:46:52 <shachaf> Er, wait.
14:47:06 <sm> johnw: do you visit tags for one project at a time.. ?
14:47:06 <shachaf> ~400 files
14:47:07 <johnw> shachaf: i'm using it for the school of haskell code, and every dependency package we build from source, etc.
14:47:08 <edwardk> johnw: i just generate hasktags per project and tell vim to look for it locally
14:47:23 <johnw> edwardk: yeah, I get tired of managing multiple TAGS files in Emacs; it doesn't do that well
14:47:25 <parcs> what do tags do?
14:47:32 <johnw> parcs: jump to definition
14:47:39 <edwardk> parcs: it lets you type :tj in vim and jump directly to a function, etc.
14:47:41 <lightquake> bah, hasktags doesn't seem to be maintained :/
14:47:46 <shachaf> edwardk: Or ^] !
14:47:49 <sm> also search/replace in tagged files, and search tagged names
14:47:51 <parcs> oh
14:48:02 <lightquake> on the other hand, all the other ones seem to be vim-specific, so hasktags it is
14:48:03 <johnw> GNU global (aka gtags) is much nicer than etags, but it doesn't support Haskell yet :(
14:48:05 <parcs> i usually do 'git grep ^definition'
14:48:08 <edwardk> shachaf: yeah there are many more efficient ways to do much of what i do in vim ;)
14:48:14 <shachaf> Sure.
14:48:35 <typoclass> parcs: right, but that won't open it in the editor ...?
14:48:55 <parcs> bah, automation
14:48:58 <parcs> who needs it?
14:49:05 <johnw> automatons?
14:49:13 <typoclass> automobiles
14:49:17 <sm> uh.. anyone trying to make headway with computers :)
14:49:49 <lightquake> i should pick up hasktags and make it aware of qualified imports and the like
14:49:59 <sm> yes please
14:50:01 <edwardk> lightquake sounds good =)
14:50:05 <johnw> I automate the creation of cool Haskell packages by suggesting impossible ideas to edwardk
14:50:11 <edwardk> hah
14:50:28 <sm> vim has far more tags tools on hackage than emacs >:(
14:50:44 <geekosaur> emacs' tag support is kinda limited
14:50:56 <johnw> sm: ghc-mod will "jump to definition", but only if the whole project compiles :(
14:51:04 <lightquake> sm: yeah, I've noticed
14:51:33 <sm> geekosaur: I'd have to agree, having tried to find a better setup.. are vim's tags better ?
14:51:39 <johnw> i should write a gtags plugin for Haskell, it would probably only require using haskell-src-exts...
14:51:41 <Sgeo> Hm..... how does the Free Cont monad behave?
14:52:04 <geekosaur> sm, last time I looked, the etags file format didn't support a whole lot
14:52:05 <lightquake> johnw: how do you jump to definition using ghc-mod?
14:52:18 <parcs> Sgeo: like a type error
14:52:32 <Sgeo> parcs, err, hm?
14:52:43 <geekosaur> maybe these days they're using vi-style tags instead of old etags; I haven't checked to see if emacs does the right thing with a standard tags file
14:52:52 <johnw> lightquake: (inferior-haskell-find-definition (haskell-ident-at-point))
14:52:59 <parcs> Sgeo: do you mean Free (Cont r)
14:53:11 <Sgeo> Oh, yes.
14:53:29 <lightquake> johnw: i just ran that and emacs froze
14:53:42 <johnw> well, I did say I use hasktags, didn't I :)
14:53:49 <lightquake> haha
14:53:55 <sm> poor emacs :(
14:53:55 <parcs> so you're supposed to manually regenerate the tags when your add or remove definitions?
14:54:00 <lightquake> this is why i'm annoyed with emacs, it feels so… crufty
14:54:06 <johnw> parcs: yes
14:54:10 <lightquake> parcs: or add a hook on save
14:54:26 <danharaj> edwardk: How does one create an Env in which to execute Tasks?
14:55:08 <edwardk> danharaj: good question. ;) it'll be very similar to the old way of creating the spawn task except now it has to switch from one stack to the other first
14:55:19 <edwardk> see the old run command
14:55:35 <edwardk> danharaj: if you want to take a whack at it i can add you to the repo
14:55:46 <danharaj> edwardk: I have a crippling fear of people looking at my codee.
14:56:01 <danharaj> Also who said I understood the machinery yet? :P
14:56:09 <edwardk> danharaj: who said i do? =)
14:56:21 <AfC> danharaj: that's healthy. It makes you write better code :)
14:57:02 <danharaj> AfC: Oh no, it gives me an excuse to never make my code intelligible to other people
14:57:03 <edwardk> danharaj: my advice is to just start putting it out there, get eyeballs on it, get feedback and improve
14:57:11 <edwardk> in the end nobody will remember that you were an idiot for a while ;)
14:57:21 <parcs> ...unless you remain an idiot
14:57:26 <danharaj> ^
14:57:35 <typoclass> ... unless someone puts it in @remember
14:57:46 <danharaj> @quote danharaj
14:57:46 <lambdabot> danharaj says: unsafeCoerce should be renamed to badPun
14:58:18 <danharaj> Even the past me is obsessed with puns today.
14:58:33 <edwardk> Trust me on this one. I used to regularly make an ass out of myself on the internet. As long as you don't use your real name until you get to a certain critical mass nobody will bother to track it back to you.. oh wait.
14:58:52 <edwardk> =)
14:59:08 <danharaj> Fortunately I intend on putting up my reactive stuff when I finish my first nontrivial project with it. :)
14:59:26 <danharaj> Which... should be soon I guess?
14:59:37 <danharaj> It depends on how much GUI programming I can stomach before I get mad and delete the repo again.
14:59:51 <hpc> lol
15:00:09 <hpc> @remember danharaj It depends on how much GUI programming I can stomach before I get mad and delete the repo again.
15:00:10 <lambdabot> It is forever etched in my memory.
15:00:42 <shachaf> Why bother @remembering?
15:00:47 <shachaf> The quote database is ruined anyway.
15:00:56 <parcs> but gui programming is so easy
15:01:02 <shachaf> Life is meaningless, and all databases are doomed to end in data loss.
15:01:05 <danharaj> shachaf: how, why, by whom?
15:01:06 <elliott> shachaf: for HWN
15:01:40 <typoclass> shachaf: so you've been watching german sitcoms again? http://www.youtube.com/watch?v=UYEQh9IkVXU
15:02:02 <shachaf> HWN will be washed away by the sands of time.
15:02:23 <johnw> shachaf: Ozymandius is working on HWN now? :)
15:02:56 <shachaf> Actually I'm just annoyed because I want to go through #haskell logs and add all quotes back in.
15:03:01 <shachaf> But I don't know when to start, or where to end.
15:03:01 <luite> typoclass: hm do those actually exist?
15:03:05 <shachaf> And no one is giving me any information.
15:03:11 <johnw> are you missing logs?
15:03:15 <parcs> typoclass: hehehe
15:03:21 <elliott> shachaf: @remember is idempotent, right?
15:03:25 <elliott> at least observationally.
15:03:29 <elliott> so just re-@remember everything ever.
15:03:39 <parcs> typoclass: what show is that?
15:03:45 <elliott> oh, I guess it might bias the random quotes if it's not idempotent
15:03:52 <shachaf> elliott: No.
15:03:54 <typoclass> parcs: 30 rock! you don't know it
15:03:55 * typoclass faints
15:04:11 <shachaf> No, I have logs, but I don't know when to start.
15:04:14 <elliott> shachaf: well you can do a @quote to find it -> @remember if it's not there type dealie
15:04:30 <shachaf> elliott: The current quote file is from sometime in early 2011, I think.
15:04:39 <shachaf> Not that anyone's telling me anything about it.
15:04:50 <typoclass> luite: yes they exist. they're mostly about death and despair
15:05:08 <elliott> shachaf: well you should be able to find the exact date by fairly simple binary search with @quote + logs, right?
15:05:24 <shachaf> That's what I thought!
15:05:40 <typoclass> shachaf: i'm missing something ... what's wrong with wgetting all the log files from tunes.org, then basically doing "grep -r @remember"?
15:05:43 <elliott> and binary searches are monoidal.
15:05:44 <shachaf> But it doesn't work if I remember correctly.
15:05:46 <luite> typoclass: hmm, i don't remember ever having seen one... and i ahve 4 german channels or so
15:06:11 <shachaf> elliott: There are @remembers that came before other @remembers where the later ones exist and the earlier ones don't
15:06:16 <shachaf> So who even knows what the state is?
15:06:28 <shachaf> I have no idea where Cale got his quote file from.
15:06:38 <elliott> well you could just do this for every @remember ever.
15:06:44 <shachaf> But now that people are @remembering, the quote file is unique.
15:06:53 <shachaf> elliott: I don't want to lose @remembers that happened in other channels.
15:07:03 <elliott> well there's no way around *that*
15:07:08 <shachaf> I mean, we've already lost two years' worth
15:07:15 <shachaf> But I don't want to lose more than that.
15:07:19 <elliott> your strategy would have that problem even if it was temporally consistent
15:07:29 <elliott> huh?
15:07:46 <elliott> I just mean @remember every quote ever done in #haskell, but check with @quote first to see if it is still in the db
15:08:18 <shachaf> That's an awful lot of queries to lambdabot.
15:08:48 <elliott> adding every quote since 2011 is already kind of a lot of queries :P
15:08:52 <shachaf> Also don't forget @forgets
15:08:58 <elliott> you could do it with a local lambdabot and send the db to cale!
15:09:01 <shachaf> Those can be pipelined more easily!
15:09:21 <shachaf> Anyway, you seem to have figured out a strategy.
15:09:23 <shachaf> How about you do it?
15:09:26 * geekosaur would probably unpack the db and use it directly...
15:09:35 <elliott> ah, here is the critical difference
15:09:41 <elliott> I don't really care about the quotes very much :P
15:09:56 <shachaf> How about we just get rid of @quote, then?
15:10:16 <elliott> you want to destroy even more data?!
15:11:11 * cmsmcq decides to go read Borges's account of the book burners in "The Library".  They were all about destroying even more data ...
15:11:34 <Guest28611> we must destroy all data in the universe
15:11:35 <johnw> cmsmcq: as long as it's not the Master Codex
15:12:28 <crl> my program work well with run
15:12:33 <crl> run
15:12:50 <crl> runGhc* sorry, but not well when compiled
15:13:09 * hackagebot clay 0.2 - CSS preprocessor as embedded Haskell.  http://hackage.haskell.org/package/clay-0.2 (SebastiaanVisser)
15:13:10 <elliott> need a bit more detail than that :P
15:13:13 <crl> with ghc --make prog && ./prog
15:13:40 <shachaf> good detail
15:13:41 <geekosaur> "work well"/"not work well" is kinda useless
15:13:58 <hpaste> crl pasted “prog” at http://hpaste.org/83423
15:14:02 <elliott> I have determined that either your code or GHC has a problem that should be fixed
15:14:22 <elliott> crl: ok, and the error message? if there is an error message; you haven't specified
15:14:34 <crl> there is no error message actually
15:14:45 <elliott> what is there, then?
15:15:06 <Lethalman> .oO(unsafePerformIO)
15:15:08 <crl> but the http erver runs partially well with ./prog, serving files, but not showing directory contenbts
15:15:38 <crl> and the 'print' is showed with runGhc, not with ./prog
15:15:56 <elliott> are you by any chance using Windows?
15:16:10 <elliott> oh, I guess root implies not
15:16:15 <elliott> (you should replace "main = do" with "main = withSocketsDo $ do" regardless, for portability)
15:16:32 <crl> if you want
15:16:34 <elliott> well, what does it do instead of showing directory contents?
15:16:42 <elliott> what happens when you try?
15:17:35 <crl> will replace with a print
15:19:27 <crl> it's the same, logicaln since  line 35 doesn't show
15:20:12 <Sgeo> Is hint obsolete?
15:20:16 <crl> but I can still access a html file (ex localhost:8080/stuff.html
15:20:22 <Sgeo> I don't see DataKinds in its list of extentions
15:21:21 <robonerd> what does haskell have for associative arrays/key:value data structure?
15:21:32 <robonerd> i just ran into a case where i need something more than a list
15:21:43 <geekosaur> Data.Map is the most common
15:21:44 <Sgeo> Data.Map
15:21:48 <robonerd> ty
15:21:55 <crl> > lookup 2 [(1,1),(2,4)]
15:21:56 <lambdabot>   Just 4
15:22:06 <robonerd> Just ?
15:22:24 <Sgeo> robonerd, want to be able to return Nothing if the key isn't there.
15:22:27 <crl> this is less effective lookup lists
15:22:45 <mikurubeam> robonerd: http://hackage.haskell.org/package/hashtables
15:22:51 <Sgeo> > lookup "nonesuch" [("hi", 5), ("bye", 6)]
15:22:53 <lambdabot>   Nothing
15:22:59 <crl> you'd probably want Maps
15:23:53 <robonerd> map won't allow duplicate keys, correct?
15:24:25 <Guest28611> Data.Map right
15:24:41 <Sgeo> Your keys will need to be an instance of Ord, iirc
15:25:35 <Sgeo> For efficient implementation purposes, which kind of sucks -- some types, such as (Num a) => Complex a, have no reasonable semantic ordering but a reasonable arbitrary ordering
15:25:58 <robonerd> how long has haskell been around in public form?
15:26:26 <c_wraith> the first committee meeting was in 89, iirc
15:26:27 <Mathnerd314> Sgeo: I don't think hint is obsolete, but it might indeed be unmaintained
15:26:49 <robonerd> dang
15:27:33 <Cale> Yeah, and the Haskell 1.0 report was 1 April, 1990
15:27:45 <c_wraith> an auspicious date
15:27:59 <Mathnerd314> but when was it first implemented?
15:28:04 <Cale> Haskell is an elaborate April Fool's joke?
15:28:26 <Cale> I believe it was implemented before the report was written, but I might be wrong about that.
15:28:39 <c_wraith> there were implementations more or less immediately.  It was similar to a number of languages that existed before the committee convened
15:29:02 <Cale> ah, the first meeting was in 1987, apparently, according to the first report
15:29:06 <c_wraith> So it wasn't too much work to adapt implementations for them
15:29:17 <Cale> right, LML and such
15:29:28 <robonerd> i wonder how basic haskell was in '1.0'
15:29:35 <robonerd> it's a monolith now
15:29:37 <Cale> robonerd: You can read the report!
15:29:47 <Cale> http://www.haskell.org/haskellwiki/Language_and_library_specification has links to all the historical reports
15:30:00 <Cale> I highly recommend reading the 1.4 report especially
15:30:23 <Cale> Haskell 98 was a step backwards in several ways, so there are some things in 1.4 which you might be surprised about :)
15:30:56 <Sgeo> o.O
15:31:31 <Cale> But the earlier reports didn't have an IO monad, and instead described a continuation-based request/response solution to IO
15:31:43 <shachaf> Continuation?
15:31:49 <shachaf> I thought it was [Response] -> [Request]
15:32:11 <levi> I think there were 2-3 alternatives?
15:32:21 <Cale> readFile :: Name -> FailCont -> StrCont -> Dialogue
15:32:30 <levi> [Response] -> [Request] was one, a continuation-based one was another, etc.
15:32:44 <Cale> type Dialogue = [Response] -> [Request]
15:32:53 <Cale> type StrCont = String -> Dialogue
15:32:56 <levi> At least the paper I ran across describing Haskell IO mentioned several variations like that.
15:32:57 <crl> ohh s%,
15:33:00 <NougatRillettes> @pl y f = f $ y f
15:33:01 <lambdabot> y = fix (ap id)
15:33:02 <Cale> type FailCont = IOError -> Dialogue
15:33:08 <crl> module Http where ... was the cause
15:33:14 <Cale> type Name = String
15:33:15 <robonerd> cale, thanks for turning me on to a religious document
15:33:25 <crl> elliott: ^
15:33:28 <robonerd> i'd paste the quote from curry but the characters are messed up
15:33:39 <Guest28611> [Request] -> [Response] ?
15:33:48 <shachaf> Ah, so the "primitives" that you actually used were CPS-style, but were implemented in terms of Dialogue?
15:33:52 <Cale> yeah
15:33:55 <shachaf> Guest28611: No, [Response] -> [Request]
15:33:59 <Guest28611> huh
15:34:01 <shachaf> You make requests and get responses.
15:34:14 <Cale> It's lazy :)
15:34:15 <Sgeo> continuation-based... so, similar to a monad?
15:34:21 <Cale> Sgeo: without the monad part
15:34:54 <Cale> Sgeo: There's no Monad class, and no use of monad-like operations.
15:35:09 <Mathnerd314> http://web.archive.org/web/20100716232801/http://haskell.cs.yale.edu/definition/aboutHaskell98.html
15:35:13 <Sgeo> Could said operations be created, out of what's defined in that report?
15:35:15 <Cale> It's all straight up by-hand continuation passing stuff
15:35:17 <Cale> yeah
15:35:39 <Sgeo> I've noticed that by-hand CPS stuff in Haskell _still_ looks better than it does in, say, node.js
15:35:49 <shachaf> Speaking of which do you know things about modal logic?
15:35:51 <danharaj> That's because node.js is a bad idea.
15:35:52 <elliott> crl: I still don't quite understand the problem but I'm glad you've solved it :P
15:36:03 <shachaf> Sgeo: It's not really doing the same thing, though.
15:36:21 <shachaf> But whatever, I'm not going to go into a node.js argument.
15:36:42 <elliott> Sgeo: see http://r6.ca/blog/20110520T220201Z.html
15:37:16 <crl> elliott, there can't be 'module Http where' when I compile as executable with ghc --make Http.hs apparently
15:37:34 <elliott> right, you want "module Main where"
15:37:35 <elliott> for programs
15:37:52 <crl> indeed that was the warning message
15:38:47 <shachaf> Or module Main (main) where
15:38:55 <shachaf> You might get better optimization that way!
15:39:58 <crl> I was using module Http where, for loading it from ghci, and trying things with all imports
15:40:24 <Squid> Wait, dumb question: How do I get a value out of one monad and put it into another? I need to mix RVals and IO
15:40:34 <Squid> *RVars
15:40:37 <crl> <-
15:40:39 <levi> What about modal logic?
15:41:18 <shachaf> levi: How do you talk about it in Haskell?
15:42:17 <Squid> wait, nevermind
15:43:36 <levi> Well, I am not particularly versed in any of it, but I have run across modal logic in a couple of places; linear temporal logic in Lamport's "Specifying Programs" and also in an introductory text I ran across on Coalgebras.
15:45:21 <levi> It struck me while reading abot Coalgebras that there was definitly similarity with Lamport's use of LTL to specify behavior in terms of state and valid transitions, which is the essence of the coalgebraic approach (as far as I understand, anyway).
15:46:12 <levi> Like I said, I am not well-versed in any of this, but maybe that could help you find some more solid information.
15:47:14 <levi> Since coalgebras are presented in Categorical terms, it should be a natural approach to talk about them in haskell.
15:48:45 <levi> This is the text on coalgebra I was reading: http://www.cs.ru.nl/B.Jacobs/CLG/JacobsCoalgebraIntro.pdf
15:49:26 <levi> And this is the Lamport text: http://research.microsoft.com/en-us/um/people/lamport/tla/book-02-08-08.pdf
15:50:17 <levi> This might also be interesting: http://www.cs.le.ac.uk/people/akurz/Papers/BCS08/ModalCoalg.pdf
15:51:39 * shachaf looks
15:51:44 <shachaf> Thanks!
16:09:11 <crl> Any idea why the download speed for http://hpaste.org/83423 is between 220 and 270KB/s which incredibly slow for localhost :)
16:09:46 <Saizan> crl: String?
16:09:51 <levi> shachaf: This might be relevant, too: http://golem.ph.utexas.edu/category/2009/09/coalgebraic_modal_logic.html
16:10:08 <crl> it's using "application/octet-stream"
16:10:24 <crl> as content-type in the header
16:10:46 <geekosaur> no, String itself is a very slow data type, not really suited for bulk operations
16:10:57 <crl> Saizan, do you mean each String processing for each chunk of download slows everything
16:10:58 <geekosaur> ByteString and Text are better
16:11:15 <elliott> (but better for different things -- make sure you pick the right one)
16:11:15 <crl> ok
16:11:16 <shachaf> ByteString is not a replacement for String.
16:11:37 <geekosaur> crl, a Haskell String is a singly linked list of Char. This makes them big and slow, although very convenient
16:11:43 <byorgey> shachaf: it can be sometimes, if String was being used wrong.
16:12:05 <geekosaur> shachaf, in a network library ByteString is more appropriate. the concept of "string" is a bit overloaded
16:12:32 <shachaf> byorgey: True. (Double,Char,Bool) is also a replacement for String. :-)
16:12:44 <byorgey> shachaf: heh, indeed =)
16:12:49 <shachaf> I just mean that you should understand what these types mean before you use them.
16:13:06 <byorgey> but I actually recently replaced String with ByteString in a library, where that was the correct thing to do.
16:13:09 <byorgey> agree.
16:13:23 <crl> geekosaur: ok, but this would be hardtime to replace all String mthods
16:13:44 <geekosaur> nevertheless, you should consider doing so because it'll never be fast with String
16:13:57 <crl> ByteString equivalents for isSuffixOf, ...
16:13:59 <geekosaur> also, you'll find that most of the things you are doing with Strings work just as well with the others
16:14:22 <byorgey> to be clear (for anyone reading this wondering what the difference is): Text is for human-readable text.  ByteString is for sequences of bytes representing some sort of binary data.
16:14:50 <crl> Text is appropriate for regex?
16:14:59 <crl> and not ByteString
16:15:17 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring-0.10.0.2/Data-ByteString-Lazy.html#v:isSuffixOf
16:15:31 <shachaf> Text ~ [Char]
16:15:35 <shachaf> ByteString ~ [Word8]
16:15:42 <shachaf> (Where Word8 is a number between 0 and 255.)
16:15:57 <geekosaur> use LANGUAGE OverloadedStrings and you might not even have to do anything beyond s/String/Byte&/g
16:15:58 <shachaf> Actually Text is slightly different from [Char] but it doesn't really matter.
16:16:05 <crl> maybe regex are possible in Byte
16:16:10 <byorgey> crl: since regex are a human-readable format, yes, I suppose so.
16:16:14 <geekosaur> or likewise s/String/Text/
16:16:34 <shachaf> OverloadedStrings doesn't make sense for ByteString.
16:16:35 <geekosaur> regex can be useful for octet data, but most often you want text data
16:17:02 <byorgey> crl: wait, you mean for matching Text/ByteString values *against* regex?  Or you mean for storing a regular expression?
16:17:29 <elliott> geekosaur: if you s/String/ByteString/, you'll break your programs semantics
16:17:35 <elliott> unless you were misusing String
16:18:02 <geekosaur> I think you're about the third to make that observation; consider backscroll
16:18:16 <geekosaur> in particular: [03 19:09] <crl> it's using "application/octet-stream"
16:18:23 <geekosaur> meaning "yes, misusing String"
16:20:21 <crl> perfect, just need to replace `words` in ByeString now
16:20:22 <shachaf> But OverloadedStrings is broken in this case.
16:20:43 <crl> should do with splitWith
16:20:58 <crl> split*
16:21:21 <crl> > split 'a'  "aXaXaXa"
16:21:23 <lambdabot>   Ambiguous occurrence `split'
16:21:23 <lambdabot>  It could refer to either `System.Random.split...
16:21:52 <crl> > Data.ByteString.Lazy.split 'a'  "aXaXaXa"
16:21:53 <lambdabot>   Not in scope: `Data.ByteString.Lazy.split'
16:22:13 <crl> i knew it
16:22:13 <robonerd> im curious, was there any reason for the term Map used in Data.Map vs Associative Array ?
16:22:30 <shachaf> It's not an array.
16:22:35 <shachaf> "associative array" is an awful term.
16:22:40 <crl> to stand away from php
16:23:03 <robonerd> shachaf it is? why?
16:23:31 <shachaf> 16:22 <shachaf> It's not an array.
16:24:11 <robonerd> http://en.wikipedia.org/wiki/Associative_array <-- seems they are synonyms no?
16:24:31 <geekosaur> "associative array" came from awk, which shouldn't have called it that even though it had some reason (because it has a single container type which kinda acts like a map or an array depending on how it's used; this can lead to nonintuitive behavior)
16:25:39 <robonerd> geekosaur so what's the conceptual difference between an associative array and a map?
16:26:59 <geekosaur> robonerd, various programming languages incorectly picked up "associative array" from awk when they really mean a map/dictionary. languages like Haskell (Map), perl (hash), and python (dict) avoided this mistake. A real "associative array" is a hybrid that tries to be both array-like and map/dict-like at the same time
16:27:21 <geekosaur> awk does this, php might (I have not cared enough to check, most php code makes me ill...)
16:27:23 <robonerd> hybrid sounds dirty
16:27:36 <Clint> zsh as well
16:27:44 <robonerd> i would argue though that hash isn't right either, as a hash table is a common implementation of a map/dict
16:28:13 <geekosaur> perl for a while also had a hybrid (arrays used as pseudo-hashes, so named), and that lives on in a module whose use is deprecated
16:28:37 <JoeyA> Is there a fancy name for this type?  data MaybeNeed i a = Done a | Need (i -> a)
16:28:52 <crl> I'll try and use {-# LANGUAGE OverloadedStrings #-}
16:28:54 <JoeyA> Sort of like Maybe, but instead of an optional value, it's an optional argument required.
16:29:47 <robonerd> geekosaur my only concern with using map as a data type is it's used in other contexts
16:30:02 <Sgeo> MaybeNeed looks ... familiar
16:30:06 <robonerd> 'apply to all'
16:30:25 * geekosaur is thinking CPS transform but is not certain of that...
16:30:37 <Sgeo> Looks like a generator that can only take 0 or 1 values
16:30:46 <Sgeo> Rather than a generator that produces a new generator
16:30:48 <elliott> JoeyA: Free ((->) i) is sort of similar
16:30:54 <elliott> (but can ask for an arbitrary number of "i"s)
16:31:09 <Sgeo> data Generator i a = Done a | Need (i -> Generator i a)
16:31:14 <JoeyA> right
16:31:25 <elliott> Sgeo: that's Free ((->) i)
16:31:27 <shachaf> Hmm, I guess you can make relevant/affine Free variations.
16:31:28 * elliott thinks it's not really like Maybe, btw
16:32:01 <shachaf> It's like a sort of Maybe
16:32:05 <shachaf> (Id :+: (i ->))
16:32:09 <Sgeo> elliott, I still don't really have a good intuition about free monads :/
16:32:20 <shachaf> Where Maybe is (() + A)
16:32:25 <elliott> shachaf: OK, it's MaybeF ((->) i) or something
16:32:31 <shachaf> Right.
16:32:41 <elliott> (Though I'd expect MaybeF f to be Const () :+: f or something, not Id :+: f?)
16:32:58 <elliott> (Maybe not, since Id = 1 and () = 1 and so 1 + x should be Either () or (Id :+:))
16:33:03 <elliott> (er, with more x)
16:33:41 <shachaf> Right, it's 1 + x
16:33:46 <Sgeo> Maybe is useful even though any Maybe can be translated to a List... maybe JoeyA's type is useful
16:34:08 <crl> 'cons' (:) means cons... ?
16:34:25 <crl> consing
16:34:35 <JoeyA> Another question: suppose I have data Foo = A Void Int | B (Void -> Foo).  If I get an A value I don't want, I can dismiss it as bogus by using absurd on the Void.
16:34:39 <JoeyA> How do I interpret B?
16:35:02 <shachaf> (Void,a) = Void
16:35:08 <shachaf> (Void -> a) = ()
16:35:28 <JoeyA> Logically, Void -> Foo means False implies Foo, which is a tautology.  Right?
16:35:49 <shachaf> Right, there is only one inhabitant of that type.
16:35:52 <JoeyA> (since False implies anything)
16:36:09 <shachaf> Since you can't actually get a Void, all functions :: Void -> A are indistinguishable.
16:36:21 <JoeyA> Ah
16:37:45 <levi> The MaybeNeed i a = Done a | Need (i -> a) type reminds me of an Iteratee
16:39:53 <JoeyA> Right.  I'm trying to figure out the types to use for a ResumableConduit
16:40:46 <levi> Well, iteratees are generally automatons, and there are a few different ways to represent automatons.
16:41:02 <elliott> "automatons" :)
16:41:14 <levi> Sorry, automata.
16:41:29 <Iceland_jack> levi: don't apologize
16:41:50 <levi> Iceland_jack: Sorry, I won't apologize anymore! :P
16:42:30 <JoeyA> Automatons are computation-carrying particles.  Scientists and philosophers are going to go nuts when they discover this.
16:43:00 <JoeyA> "Automata" is a word I'm not sure how to pronounce.
16:44:50 <levi> Like automaton, except with an 'ah' sound instead of an 'on' sound at the end.
16:45:26 <JoeyA> Now how do I pronounce "automaton"?  :-)
16:45:47 <levi> http://www.merriam-webster.com/dictionary/automaton
16:47:09 <levi> I am surprised you haven't heard it pronounced before, it's a common term in CS theory, even at the introductory level.
16:51:10 <crl> how could I import just the constants of "import System.IO.IOMode"
16:51:19 <crl> doesn't work like that
16:51:54 <JoeyA> import System.IO (IOMode(..)) ?
16:51:58 <crl> constructors*
16:52:13 <JoeyA> I don't think you can avoid importing the IOMode type itself, though.
16:52:27 <crl> right thx
16:54:17 <levi> What's a ResumableConduit supposed to do?  I'm not too familiar with Conduits aside from the general idea and motivation behind them.
17:01:48 <crl> must be hard for the compiler when it see stuff . L.sort , first . composition, second modules
17:04:27 <crl> how would I define (++) as append for Bytestrings, (hiding the one of Data.List) not sure {-# LANGUAGE OverloadedStrings #-}
17:04:37 <crl> would do it automatically
17:04:40 <luite> crl: use (<>) instead
17:04:52 <crl> good
17:05:00 <luite> also works for lists, (<>) = mappend
17:05:03 <Iceland_jack> <> also works on Strings
17:05:17 <crl> bytestring is a monoid indeec
17:05:18 <geekosaur> you can hide the default definition but it's easier to switch to <>
17:05:41 <letrec> Hi! I'm using try to catch exceptions. I'm then using something like case res of Left ex | typeOf ex == typeOf ExitSuccess -> ...     to select different actions for different types of exceptions. Any better way?
17:05:44 <monochrom> also, you don't need {-# LANGUAGE OverloadedStrings #-}
17:05:44 <shachaf> OverloadedStrings is not compatible with ByteString
17:06:20 <shachaf> letrec: You don't need to explicitly match on the type like that.
17:06:34 <Sgeo> Now that I've re-seen the Dr. Seuss parser monad thing, maybe I should try implementing a simple parser monad on my own
17:07:06 <shachaf> letrec: try :: IO a -> IO (Either ExitCode a)
17:07:17 <crl> > read "123lol" :: Int
17:07:19 <lambdabot>   *Exception: Prelude.read: no parse
17:07:29 <Sgeo> read sucks imo
17:07:33 <crl> > reads "123lol" :: Int
17:07:34 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
17:07:34 <lambdabot>              with actual type ...
17:07:44 <Sgeo> > :t reads
17:07:45 <lambdabot>   <hint>:1:1: parse error on input `:'
17:07:48 <Sgeo> :t reads
17:07:50 <lambdabot> Read a => ReadS a
17:08:00 <monochrom> you need: reads "123lol" :: [(Int,String)]
17:08:07 <luite> letrec: catch actually does that internally, just catch \(e::IOException) -> ... will only catch IOException, it uses the Typeable magic internally for this. (and same for try, implemented in terms of catch)
17:08:13 <Sgeo> monochrom, o.O so reads is a parser
17:08:18 <geekosaur> yes
17:08:28 <monochrom> also, see my http://www.vex.net/~trebla/haskell/reads.xhtml
17:08:29 <geekosaur> a very simple one, but a parser
17:08:40 <letrec> shachaf: Yes, but if I want to do different actions for IOException, ExitCode and SomeException ?
17:08:54 <letrec> Shall I use 3 times a try ?
17:09:29 <JoeyA> :t catches
17:09:31 <lambdabot>     Not in scope: `catches'
17:09:31 <lambdabot>     Perhaps you meant `catch' (imported from Prelude)
17:09:50 <geekosaur> boo LB
17:09:55 <monochrom> "typeOf ex == typeOf ExitSuccess" will not do what you want, since ex :: SomeException
17:09:56 <geekosaur> :t Control.Exception.catches
17:09:57 <lambdabot> IO a -> [Control.Exception.Handler a] -> IO a
17:10:10 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Control-Exception.html#v:catches
17:11:43 <luite> how can i disable building haddock when building ghc?
17:14:23 <luite> make[1]: *** [utils/haddock/dist/build/Haddock/GhcUtils.o] Segmentation fault: 11 <- had this problem for over a month, building GHC HEAD on my laptop
17:23:13 * hackagebot one-liner 0.2 - Constraint-based generics  http://hackage.haskell.org/package/one-liner-0.2 (SjoerdVisscher)
17:29:00 <crl> I have placed {-# LANGUAGE OverloadedStrings #-} in top, does this mean B.split ' ' "foo bar" arguments should be interpreted as Word8 and ByteStrings?
17:29:34 <shachaf> No, OverloadedStrings is unrelated to ByteString
17:29:55 <shachaf> Since ByteString is about sequences of bytes, not sequences of characters, overloading string notation won't help you deal with it.
17:30:14 <shachaf> (Unless you do something evil like pretending Char = Byte.)
17:31:36 <Saizan> .Char8 does provide an instance tough
17:33:07 <shachaf> It does.
17:33:21 <shachaf> That's the "Unless you do something evil" part.
17:33:44 <shachaf> But crl already seems very confused about the distinction between characters and bytes -- I don't want to encourage it.
17:34:51 <crl> a character is a sequence of byte, like an Int ;)
17:35:05 <shachaf> No, a character is not a sequence of bytes.
17:35:17 <crl> it's 1 byte
17:35:22 * shachaf sighs.
17:35:27 <elliott> a character isn't one byte
17:35:28 <crl> less
17:35:31 <elliott> no, more
17:35:33 <edwardk> > fromEnum (maxBound :: Char)
17:35:35 <lambdabot>   1114111
17:35:41 <edwardk> thats a big byte
17:36:27 <crl> it's 8 bits
17:36:35 <monochrom> even python is moving away from "char = byte"
17:36:51 <crl> > 2 ^ 32
17:36:52 <lambdabot>   4294967296
17:36:54 <elliott> crl: it's not going to be true no matter how much you say it :P
17:37:04 <monochrom> it was true of 1970s computers and languages
17:37:32 <shachaf> Even in the 1970s, there were more than characters in the world!
17:38:10 <cdntr> I gotta say, I really enjoy listening to Simon Peyton Jones
17:39:48 <skuggi> > fromEnum (minBound :: Char)
17:39:50 <lambdabot>   0
17:39:53 <adas> how is it possible to "get" from a state without setting the state to begin with?
17:39:57 <cdntr> Are there any other notable people like him giving talks on subjects like his?
17:40:16 <cdntr> (That are recorded and available in video format)
17:40:47 <monochrom> runStateT requires someone to provide the initial state value. also execStateT and evalStateT
17:41:10 <shachaf> adas: It is not.
17:41:22 <shachaf> get :: State s s -- get :: s -> (s,s)
17:41:28 <shachaf> Its implementation is exactly what you'd expect.
17:41:56 <shachaf> @ty runState get
17:41:58 <lambdabot> s -> (s, s)
17:42:13 <crl> > (show ' ') :: Int
17:42:15 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
17:42:15 <lambdabot>              with actual type ...
17:42:58 <crl> > digitToInt ' '
17:43:00 <lambdabot>   *Exception: Char.digitToInt: not a digit ' '
17:43:31 <Digit> XD
17:43:40 <skuggi> > Data.Char.ord ' '
17:43:40 <monochrom> o hai digit!
17:43:42 <lambdabot>   32
17:43:50 <skuggi> is that what you're trying to do?
17:44:08 <shachaf> s/more than characters/more than 256 characters/ way up there
17:44:11 <crl> hm yeah,
17:44:28 <crl> > fromIntegral (ord ' ')
17:44:29 <lambdabot>   32
17:44:30 <monochrom> > Data.Char.ord '黎'
17:44:30 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
17:44:38 <adas> i mean when you do "s <- get" it has to get the state from somewhere yes? i was wondering where does it get the state from? or is my question nonsense?
17:44:51 <monochrom> lambdabot still does not enjoy a clean UTF-8 channel
17:45:29 <monochrom> your question is sensible and answered
17:45:38 <lispy> monochrom: I suspect that's because lambdabot predates ghc having proper locale support
17:46:34 <crl> case B.split 32 req of -- ...
17:48:28 <adas> monochrom: if i understood the answer i wouldn't bother asking it again. Waste of your time and mine
17:48:58 <monochrom> fine
17:49:16 <adas> nvm. ill try to grok it myself.. from whatever "answers" i got. thanks
17:51:02 <Frostix> Hey guys
17:51:35 <Frostix> Can someone assist me with this - http://prntscr.com/uy46f ?
17:51:58 <shachaf> Frostix: You need to put both on one line.
17:52:03 <shachaf> let foo :: ...; foo = ...
17:52:08 <Frostix> Ok
17:53:27 <Frostix> Well now program doesn't add up correctly- http://prntscr.com/uy4fm
17:53:35 <Frostix> Oops
17:53:41 <Frostix> Forgot to put addthree, my bad
17:54:51 <Frostix> What does this mean? http://prntscr.com/uy4ma
17:55:37 <shachaf> What do you expect?
17:55:42 <monochrom> you need more numbers? addThree 123 314 271
17:55:54 <monochrom> since, after all, you said "Three"
17:56:11 <Frostix> So three cant be three individual numbers?
17:56:34 <Frostix> Oh
17:56:34 <monochrom> can. 123, 314, 271. three individual numbers there.
17:56:35 <Frostix> Figured it out
17:56:40 <Frostix> I didn't put spaces
17:57:01 <Frostix> Thanks ^^
17:57:06 <hpaste> glguy pasted “multi-line ghci” at http://hpaste.org/83428
17:57:17 <glguy> Frostix: You can do that if you want
17:57:26 <parcs> adas: do you know how 'get' is defined?
17:58:28 <Frostix> I have a general question, are there any other clients besides GHCi, because if I mess up a line of code I have to retype it - unless there is a way I don't know about
17:58:48 <glguy> Frostix: you shouldn't be writing much code in GHCi. Do that in files
17:59:30 <Frostix> Alright, just following a book and that's what they use. I hear Leksah is good for it, does anyone use that?
17:59:42 <monochrom> I use any editor
18:00:15 <parcs> i use the best editor
18:00:30 <Frostix> What's that?
18:01:09 <cdntr> Can somebody help me comprehend this compilation error? https://gist.github.com/anonymous/3024f107fce0fb2b1c25 -- Haskell beginner
18:01:52 <parcs> cdntr: you're using / on two ints
18:02:18 <parcs> cdntr: integer division is done with div
18:02:28 <Frostix> What does `mod` mean?
18:02:30 <parcs> totalSum `div` totalLength
18:02:41 <cdntr> Well I do want floating point division here
18:02:45 <parcs> Frostix: `mod` is the infix version of mod
18:02:58 <parcs> cdntr: your type says you want a Maybe Int..
18:03:13 * hackagebot bifunctors 3.2.0.1 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-3.2.0.1 (EdwardKmett)
18:04:28 <Sgeo> About cdntr's code... that mySum xs should never be Nothing, so what's a safe way to express that?
18:04:30 <silasm> anyone know anything about the ltk package on Cabal? It's failing compilation because it uses Prelude.catch. I tried getting the source and making it use Control.Exception.catch, but it won't cabal configure with my version of cabal. ( ._.)
18:04:44 <silasm> on cabal. derp. On hackage.
18:04:45 <glguy> Sgeo: change it's type from Maybe Int to Int
18:04:55 <parcs> Sgeo: mySum is Nothing when xs = []
18:04:55 <glguy> if it's never "Nothing"
18:05:11 <Sgeo> parcs, I meant in the third case
18:05:24 <cdntr> parcs: Oh crap, the return type is wrong
18:05:24 <Sgeo> Maybe roll cases 2 and 3 together?
18:05:40 <jmcarthur> a known trick for wrapping IORefs in a way that makes a functor is to do something like this:  data Foo a = forall b. Foo (IORef b) (b -> a)  . suppose i am doing something similar for TMVars in a context where i know that once the TMVar has been filled it will never be changed again (it's really more of an IVar, i guess). does anybody know if there is a way that i can arrange for fmap to cache the result of
18:05:42 <jmcarthur> the function application instead of recomputing it each time? can it be done without unsafePerformIO or unsafeInterleaveIO (since those don't play nicely with STM)?
18:06:46 <parcs> Sgeo: yeah, that seems like the best way
18:06:55 <jmcarthur> if it matters, in reality i'm using a value of type (STM a) instead of a (TMVar a), but all it does is read the TMVar.
18:07:21 <cdntr> parcs: Thanks
18:07:46 <jmcarthur> i can't think of any particular reason it would be important that i use STM instead of just TMVar, actually
18:08:21 <jmcarthur> hmm, well, i can possibly think of one, but i'll get to that when i get to it. i think my question applies either way
18:09:02 <silasm> @hoogle ltk
18:09:03 <lambdabot> package ltk
18:09:03 <lambdabot> package hs-fltk
18:09:49 <monochrom> are you saying, you have functor data Foo a = forall b. Foo (STM b) (b -> a) ?
18:10:37 <jmcarthur> that is a close enough approximation
18:11:08 <jmcarthur> it might as well just be STM in this case, i guess
18:11:13 <jmcarthur> instead of the wrapper
18:11:18 <Saizan> yeah, since it's already a functor
18:11:30 <Saizan> the problem of caching stands
18:11:33 <jmcarthur> yes
18:11:39 <monochrom> yikes, I don't know how to do it either way. I was thinking STM is easier than IORef, TVar, TMVar... but no, same difficulty
18:12:01 <jmcarthur> i think it's the same problem as trying to memoize an IO action
18:12:14 <jmcarthur> you end up having a return type  IO (IO a)
18:12:30 <jmcarthur> but with IO you can just use unsafeInterleaveIO (sometimes)
18:12:34 <adas> parcs: yes i do know how 'get' is defined but im trying to visualize the flow and thats why i can't see where 'get' gets its initial state for it to 'get' from..
18:12:35 <monochrom> yeah, I used to accomplish that by unix signals!
18:14:03 <byorgey> adas: where does the function \x -> x + 3  get its initial value of x from?
18:14:17 <Sgeo> Why do IORefs need to be wrapped to make a functor?
18:14:30 <jmcarthur> Sgeo: try to implement fmap for IORefs and you'll see why :)
18:14:35 <crl> :t unlines
18:14:37 <lambdabot> [String] -> String
18:14:48 <adas> byorgey: from a value applied to the function
18:14:53 <byorgey> adas: right.
18:14:55 <byorgey> likewise, the State monad gets its initial state from a call to 'runState', which applies the State computation to an initial state
18:15:07 <Sgeo> Oh, because need to be able to put a value into the IORef, so need a reverse?
18:15:42 <byorgey> adas: when you are creating a State computation using 'get', 'put', etc., you are just creating a 'pipeline' which can do things to a state, just like you can compose functions like  f . g . h
18:15:53 <jmcarthur> Sgeo: i'm not sure i understand that line of thought
18:16:04 <jmcarthur> Sgeo: what should fmap *do* for IORef?
18:16:29 <byorgey> adas: (a small note on terminology, we usually say a function is applied to a value, not the other way around)
18:17:11 <Sgeo> > map ($3) [(1+) (subtract 2)] -- value applied to functions?
18:17:13 <lambdabot>   No instance for (GHC.Num.Num (b0 -> b0))
18:17:13 <lambdabot>    arising from a use of `e_1312'
18:17:13 <lambdabot> ...
18:17:23 <Sgeo> ?
18:17:33 <Sgeo> > map ($3) [(1+), (subtract 2)] -- value applied to functions?
18:17:35 <lambdabot>   [4,1]
18:17:46 <byorgey> Sgeo: cheater =)
18:17:58 <Sgeo> I guess ($3) is really a function
18:18:01 <Sgeo> :t ($3)
18:18:03 <lambdabot> Num a => (a -> b) -> b
18:19:37 <adas> byorgey: so once that initial state is passed into the State computation I will have to pass it again if I am to perform the state computation again? because i assumed the 'get' and 'put' were permanantly modifying the state at a global level
18:20:13 <fragamus> seems like hackage is down
18:20:32 <byorgey> adas: the State monad models stateful computations using normal functions and function application.  So there is no such thing as 'permanently' modifying the state at a 'global' level.
18:20:35 <jmcarthur> no, it's not down
18:21:04 <byorgey> adas: given a particular State computation, you may run it multiple times with multiple different initial states; the different runs will be completely independent of one another.
18:21:08 <fragamus> well whatever cabal install connects to
18:21:26 <jmcarthur> nope, it's not down
18:21:34 <jmcarthur> (that would be hackage, btw)
18:21:39 <jmcarthur> i just ran cabal update to check
18:21:44 <monochrom> hackage seems up here
18:21:44 <Sgeo> > evalState get 5
18:21:46 <lambdabot>   5
18:21:49 <byorgey> adas: however, if you want to perform the same State computation multiple times in sequence (i.e. pass the output state as input to itself again) you can just chain it into a bigger State computation first
18:21:54 <fragamus> cabal install network-conduit    <----- that runs real slow or not at all
18:22:00 <Sgeo> > evalState (modify (+1)) 5
18:22:02 <lambdabot>   ()
18:22:08 <byorgey> like   c >> c >> c
18:22:16 <jmcarthur> fragamus: that exact command is working for me
18:22:18 <byorgey> or like  replicateM 200 c
18:22:23 <fragamus> crap
18:22:57 <fragamus> ok i re-ran it.  it works now.  it got wedged somehow
18:23:59 <adas> byorgey: thanks for the clarity. i was thinking the 'get' gets state from global level and 'put' puts state at a global level. never thought of it as a pipeline that "threads" states over time
18:24:45 <byorgey> adas: 'get' and 'put' both operate on the *local* state of a given State computation
18:25:56 <byorgey> adas: and yes, one good way to think of it is as a function pipeline with some extra state that gets threaded along in parallel
18:26:07 <byorgey> (which is in fact exactly how it is implemented)
18:28:14 <TravisD> byorgey: I'm not sure if there's a more standard channel for this type of thing, but there's a small typo in the typeclassopedia. The first footnote of section 5.3 says "Alternative" where I believe "Applicative" was meant
18:29:14 <byorgey> TravisD: this is as good a place as any for this sort of thing
18:29:32 <byorgey> TravisD: though actually, that footnote is correct
18:29:51 <TravisD> Ah, what is Alternative?
18:30:04 <byorgey> @src Alternative
18:30:05 <lambdabot> class Applicative f => Alternative f where
18:30:05 <lambdabot>     empty :: f a
18:30:05 <lambdabot>     (<|>) :: f a -> f a -> f a
18:30:08 <jmcarthur> maybe it would be safe to wrap a call to forkIO under unsafePerformIO and use atomically in the other thread... then i could make a new TMVar and fill it from the other thread once the first one is filled
18:30:16 <TravisD> Ah, sorry about that :)
18:30:20 <byorgey> TravisD: it's a type class for Applicative things which also support choice + failure
18:30:38 <byorgey> TravisD: oh, no worries =)
18:31:32 <byorgey> the footnote could probably be worded better.  the context strongly sets you up to expect 'Applicative' there.
18:31:50 <augur> !seen ski
18:31:57 <augur> D:
18:31:59 <byorgey> maybe change 'Alternative by itself' to 'Applicative and Alternative together are enough...'
18:32:14 <monochrom> preflex may know
18:32:14 <augur> oh wait isnt it preflex?
18:32:18 <augur> preflex seen ski
18:32:18 <preflex>  ski was last seen on #haskell 9 days, 14 hours, 45 minutes and 19 seconds ago, saying: srhb : <http://en.wikipedia.org/wiki/Pseudo_terminal>
18:32:22 <augur> preflex seen ski_
18:32:22 <preflex>  ski_ was last seen on #haskell 1 day, 12 minutes and 5 seconds ago, saying: CL has `~format', <https://github.com/Hexstream/lispy-format/blob/master/hairiest.lisp>
18:32:39 <TravisD> ah, yeah maybe. I suspect readers aware of Alternative wouldn't be confused
18:33:10 <byorgey> TravisD: yes, but many readers of the Typeclassopedia will NOT be aware of Alternative =)
18:34:06 * byorgey edits
18:36:04 <hpaste> jmcarthur pasted “Should this be "safe" (as in not angering the RTS gods) under unsafePerformIO?” at http://hpaste.org/83431
18:38:14 * hackagebot maxent 0.4.0.0 - Compute Maximum Entropy Distributions  http://hackage.haskell.org/package/maxent-0.4.0.0 (JonathanFischoff)
18:39:57 <timbod> Any tips on how I get cabal to use Setup.hs? It seems like it used to be required, but isn't any longer.
18:41:06 <byorgey> timbod: not quite sure what you're asking, but perhaps set   build-type: Custom  ?
18:41:40 <msxx> with ExistentialQuantification is there a way to probe wrapped type for the underlining type, and then get the original object out of it?
18:42:11 <jfischoff> preflex seen spj
18:42:11 <preflex>  spj was last seen on #haskell 214 days, 13 hours, 16 minutes and 56 seconds ago, saying: When is jfischoff here?
18:42:21 <jfischoff> I love that :)
18:42:59 <timbod> byorgey: That worked. Thanks. It seems inconsistent with the user guide, which seems to say that build type simple still uses Setup.hs.
18:43:28 <timbod> (I'm trying to add some custom preprocessor hooks)
18:44:22 <timbod> byorgey: I saw you haskell cafe comment early on font libs for haskell.
18:44:26 <byorgey> timbod: it may be, in my experience the user guide is not always kept perfectly up to date.
18:44:39 <msxx> to give an example say that ther ewas existential type AnyWidget, consisting of any type that imlements Widget class. and TextBox implemnts Widgt class. can I extract TextBox object ouf of AnyWidget?
18:44:59 <jmcarthur> msxx: you could do something like that using Typeable. see how Data.Dynamic works
18:45:01 <timbod> Font handling seems very complex for the uninitiated. The freetype binding on hackage looks pretty scary.
18:45:15 <byorgey> timbod: indeed.
18:45:15 <jmcarthur> msxx: but i think this is generally not a good sign
18:45:45 <timbod> The nice thing about the cairo binding is that it provides exactly what I need for laying out text adequately on a chart.
18:45:53 <msxx> jmcarthur could I also probe AnyWidget for  underlining type? something like this  case x of TextBox .-> ...  Window -> ...
18:47:13 <jmcarthur> msxx: if you want that why not just use an ADT?
18:47:50 <msxx> jmcarthur I need to store a list of widgets
18:47:54 <jmcarthur> right
18:47:57 <jmcarthur> and an ADT would be fine
18:48:12 <jmcarthur> data AnyWidget = TextBox ... | Window ... | ...
18:48:28 <msxx> that lacks extensibility
18:48:45 <jmcarthur> reflection lacks type safety. you win some you lose some
18:49:25 <jmcarthur> if there is truely some generic operation that works for any widget then perhaps you could use the (considered by many to be a code smell) trick of hiding a type class with the existential?
18:49:58 <tac> jmcarthur: In Haskell maybe...
18:50:21 <jmcarthur> existential types are kind of intended to hide the type, so attempts to recover the type after explicitly hiding it are often a sign that you need to rethink what you're trying to do
18:51:59 <msxx> the only reason I am using existential types is to be able to store widgets in a list or some other container. hiding the type is a side effect
18:52:38 <jmcarthur> perhaps storing them all in the same container is a mistake
18:53:04 <jmcarthur> could you get away with storing them in different containers, for example?
18:53:45 <levi> How about the 'Data Types a la Carte' method of creating extensible types?
18:53:50 <msxx> no. I would need a container per widget, and users can create new widgets
18:54:37 <msxx> levi not sure what that is?
18:54:53 <jmcarthur> google it. it's good reading even if it ends up not being what you want
18:55:18 <levi> A lot of links are broken, but this should be a good one: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.101.4131
18:56:25 <levi> There's a little bit of discussion, including some alternate solutions, on Phil Wadler's blog: http://wadler.blogspot.com/2008/02/data-types-la-carte.html
18:56:39 <Saizan> msxx: the last resort is to include a Typeable context
18:57:19 <samm> can someone explain how fmap.fmap work? (fmap.fmap) toUpper ["foo", "bar"]
18:57:48 <jmcarthur> :t (fmap.fmap)
18:57:50 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
18:58:51 <jmcarthur> samm: (fmap.fmap) toUpper == fmap (fmap toUpper)  -- by the definition of (.)
19:00:58 <samm> jmcarthur: Trying to wrap my head around that. I can follow fmap (fmap toUpper). we are mapping over a list with a function that maps over a string
19:01:09 <jmcarthur> yup
19:01:17 <jmcarthur> @src (.)
19:01:17 <lambdabot> (f . g) x = f (g x)
19:01:18 <lambdabot> NB: In lambdabot,  (.) = fmap
19:01:56 <samm> hmm
19:02:35 <levi> fmap lifts a function into the context of a Functor.  So applying fmap to toUpper lifts a function Char->Char to [Char]->[Char].  You apply fmap again to lift it into the next Functor, so you go from [Char]->[Char] (i.e. String->String) to [String]->[String].
19:03:45 <samm> but it works with map too (should have used it instead)
19:03:57 <samm> map doesnt take or produce a functor
19:04:04 <levi> map is a version of fmap that is specialized to the List Functor.
19:04:15 <levi> The List type has a Functor instance.
19:05:02 <levi> Alternatively, fmap is a more general version of map that works on any Functor, not just the List Functor.
19:07:34 <samm> is Functor knowlede needed to understand this? They are pretty fresh to me
19:07:53 <shachaf> Needed to understand what? fmap?
19:08:08 <samm> or is understanding map and . enough? I thought I understand both
19:08:37 <levi> Well, if you understand map and ., you should understand (map.map)
19:08:38 <shachaf> > (map.map) toUpper ["foo", "bar"]
19:08:40 <lambdabot>   ["FOO","BAR"]
19:08:43 <samm> to understand why map (map toUpper) is the same as (map.map) toUpper
19:08:51 <jmcarthur> in this example, map happens to be enough. it applies in a more general sense though, in which case you'd need to understand how fmap generalized map
19:08:51 <shachaf> Ah. That's just (.), really.
19:08:56 <shachaf> (f . g) x = f (g x)
19:09:07 <shachaf> f = map, g = map, x = toUpper
19:09:09 <jmcarthur> but yeah, this is only about the definition of (.) and nothing else
19:12:23 <levi> Try taking the type of (.) and manually doing the type substitution of map into it.
19:12:36 <samm> I think I get it. toUpper is sent to map, and returned value (a function) is sent to first map
19:13:33 <shachaf> Ooh, are we doing postal service analogies now?
19:13:50 <samm> (:
19:16:40 <hpaste> WraithM pasted “mapAccumL for Vectors” at http://hpaste.org/83433
19:16:59 <samm> I am used to (g x) part in f (g x) producing an actual object, not a function. that's what got me confused
19:17:34 <shachaf> A function is "an actual object" as much as anything else.
19:17:50 <WraithM> So, I want to take a non-mutable vector, and implement mapAccumL for it.
19:18:36 <WraithM> I'm having a little trouble thinking about it
19:18:55 <Sgeo> :t mapAccumL
19:18:56 <shachaf> Why are you unsafeThawing and unsafeFreezing?
19:18:56 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
19:19:09 <shachaf> You're mutating an immutable array here.
19:19:09 <WraithM> That's an excellent question.
19:19:23 <WraithM> It's sort of what came to my mind to do
19:19:43 <shachaf> Why would you use a function whose name starts with "unsafe"?
19:20:09 <WraithM> I guess I don't really know how to do pattern matching on vectors in such a way to get what I want
19:20:55 <WraithM> @src mapAccumL
19:20:55 <lambdabot> mapAccumL _ s []        =  (s, [])
19:20:55 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
19:20:55 <lambdabot>    where (s', y ) = f s x
19:20:55 <lambdabot>          (s'',ys) = mapAccumL f s' xs
19:21:06 <shachaf> Why pattern matching?
19:21:13 <shachaf> You don't pattern match on Vector, do you?
19:21:22 <WraithM> No
19:21:27 <WraithM> But that's what I'm saying
19:21:42 <WraithM> I can't think of a way to do it without pattern matching or going mutable
19:21:53 <shachaf> Even if you use mutability, why are you using unsafeThaw and unsafeFreeze rather than thaw and freeze?
19:22:35 <WraithM> I won't need the old vector after. unsafe just means delete the thing that you're thawing/freezing
19:22:46 <WraithM> with the possibility of failure
19:23:14 <WraithM> At least, that's my understanding
19:23:16 <shachaf> That's not really what unsafe means.
19:23:20 <WraithM> Fair enough
19:23:25 <shachaf> You're mutating an immutable vector here.
19:23:25 <WraithM> Yeah, I don't know what I'm doing
19:23:31 <shachaf> (Also: Please always include a type when you @paste code.)
19:23:43 <WraithM> Oh! I'll do that in the future!
19:23:44 <Sgeo> If you don't know what you're doing, don't use unsafe functions
19:23:45 <WraithM> Thank you
19:24:00 <shachaf> Anyway:
19:24:02 <WraithM> Well, how would you all implement mapAccumL for vectors?
19:24:03 <shachaf> @hoogle mapAccumL
19:24:04 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
19:24:04 <lambdabot> Data.Traversable mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
19:24:04 <lambdabot> Data.Text mapAccumL :: (a -> Char -> (a, Char)) -> a -> Text -> (a, Text)
19:24:20 <shachaf> Does that Data.Traversable version work? Vector looks Traversable to me.
19:24:24 <WraithM> Ohh
19:24:26 <WraithM> Yeah
19:24:31 <WraithM> Neat
19:24:41 <WraithM> I didn't realize that Data.Traversable had a mapAccumL
19:24:47 <WraithM> It didn't come up when I hoogled it.
19:24:55 <WraithM> Thank you!
19:25:16 <shachaf> You should understand what unsafeThaw and unsafeFreeze mean. :-)
19:25:35 <shachaf> Here they mean: You have a mutable vector. Its type is lying and saying that it's immutable, but you're mutating it.
19:25:45 <WraithM> Ah
19:25:49 <shachaf> This will lead to Trouble.
19:25:54 <WraithM> Capital T
19:25:57 <WraithM> Trouble
19:26:02 <WraithM> True
19:26:03 <jmcarthur> some vectors are traversable and some are not
19:26:11 <jmcarthur> unboxed vectors are not, for example
19:38:35 <lambdazerocool> a quick question on Parsec. I am parsing strings, and want to be able to parse both "try" and "throw". Since both begin with the letter 't', string "throw" <|> string "try" fails on "try" because the 't' gets committed in the string "throw". What would you guys consider to be the best practice for resolving this issue?
19:39:35 <Mortchek> lambdazerocool, I dunno if it's best practice, but you can use try
19:39:40 <Mortchek> try foo <|> bar
19:40:19 <lambdazerocool> Mortchek: thanks :D this is the current workaround. i'm not sure how smiled or frowned upon this will be :)
19:40:44 <m3ga> lambdazerocool: thatas actually a Parsec problem, attoparsec doesn't mess up like that. I alos think there is an attoparsec-parsec wrapper around parsec that makes it work like attoparsec.
19:41:26 <letrec> How do I convert diffUTCTime to Int (or Float, or Integer) ? Thx.
19:41:41 <m3ga> lambdazerocool: see attoparsec-parsec : An Attoparsec compatibility layer for Parsec
19:41:55 <tsion> After a failed `cabal install foo` how can I remove all the dependencies of foo that were installed?
19:43:00 <parcs> you can't, at least not easily
19:43:06 <msxx> levi I glanced over it, looks like an interesting read and have bookmarked it
19:48:25 <kennyd> letrec realToFrac
19:50:43 <msxx> letrec why note that NominalDiffTime is a num too.  diff + 1000 for example works fine
19:50:48 <msxx> s/why//
19:51:39 <samm> how come we have both map and fmap, why not just fmap?
19:52:08 <elliott> samm: historical reasons and so the errors when you use "map" are less scary to newbies, pretty much
19:52:16 <elliott> they're not really all that compelling reasons
19:52:17 <Saizan> lambdazerocool: that's a quite legitimate use of try
19:52:32 <lightquake> hmmm
19:52:36 <lightquake> i've been programming for too long, i think
19:52:54 <lightquake> i just wrote the commit message "Add type checking for (most) statements" and I realized the parentheses around most were redundant
19:52:58 <applicative_> there are also variant maps in e.g. ByteString or Text or Vector that can hardly be counted as fmaps
19:53:02 <lightquake> and then i realized why that doesn't actually make sense
19:53:31 <Saizan> samm: to cater to beginner which might get confused by the typeclass when just needing something for lists, essentially
19:53:47 <lightquake> applicative_: wait, Vector? ByteString and Text make sense
19:54:10 <msxx> is unsafeCoerce the haskell equivalent of a cast in C?
19:54:12 <lightquake> but it looks like Vector is a functor
19:54:39 <applicative_> lightquake: yes, they have 'map' functions, but for Text it's map :: (Char->Char) -> Text -> Text
19:54:56 <lightquake> well, right
19:54:57 <letrec> msxx: Yes but something like   ((diffUTCTime t last) - logp) > 0   where logp is an Int doesn't typecheck. The doc says that "Conversion functions will treat it as seconds." So not sure how that works :)
19:55:03 <lightquake> i just wasn't sure why you included Vector in that list
19:55:47 <Mathnerd314> letrec: add a fromIntegral?
19:55:53 <applicative_> lightquake: yes, Data.Vector is, but the others in the package arent, thus Data.Vector.Unboxed.map ::( Unbox a, Unbox b) -> (a -> b ) -> Vector a -> Vector b
19:55:54 * lightquake . o O (class Mappable a b c d where map :: (a -> b) -> (c -> d))
19:56:13 <lightquake> now that i think about it, that's probably represented somehow in lens
19:56:30 <Mathnerd314> everything's a lens, pretty much :-)
19:56:54 <monochrom> view everything through the glasses of lens!
19:57:07 <applicative_> in every function X -> Y it's like we access a little Y field in the X
19:57:52 <Mathnerd314> a.k.a. Getter X Y
19:58:32 <shachaf> forall p. Contravariant p => p a -> p s
19:58:34 <applicative_> yeah, we should stop calling it functional programming and call it getter-setter programming
19:59:04 <Mathnerd314> applicative_: but there's more than just getters and setters
19:59:16 <msxx> letrec 10.5 - (5 :: Int) would give you the same error. and as Mathnerd said adding fromIntegral should make it work
19:59:29 <applicative_> yes, as there are more than functions.
19:59:47 <applicative_> maybe we should just repeat the mantra "Everything is a lens"
19:59:54 <Mathnerd314> applicative_: how about "mathematical programming"?
20:00:15 <applicative_> hm, ok
20:00:43 <monochrom> I will stick with "functional programming". because it is the opposite of "dysfunctional programming"
20:01:04 <Mathnerd314> yeah, apparently it's already taken: http://en.wikipedia.org/wiki/Mathematical_optimization
20:01:59 <applicative_> looks pretty dreary
20:02:30 <Mathnerd314> but telling somone "oh, Haskell is a purely functional programming language" is usually not telling them much
20:03:10 <Mathnerd314> whereas "Haskell is for math nerds :-)" tends to tell them more
20:03:54 <applicative_> but haskell isn't for math nerds.  Some of them can fine materials to amuse themselves with in it....
20:03:54 <mgsloan> or "Haskell is for responsible programmers"
20:04:02 <zachk> tell them it has no objects nonsense, and is the hypermodern pinnacle of structured procedural programming
20:04:36 <applicative_> Haskell is for people who want actually to be saying something, defining terms they could as well use when talking to other people, etc
20:04:43 <mgsloan> mm, yeah, maybe it should be called hypermodern programming
20:04:50 <elliott> mgsloan: but what about all the irresponsible haskell programmers like me?
20:04:54 <zachk> ;-D
20:05:15 <zachk> the compiler at least forces some degree of sane responsibility if you want your code to even get to the linker
20:05:17 <Mathnerd314> yeah, IIRC the last time I mentioned it I just said "the world's finest imperative prgoramming language"
20:05:22 <mgsloan> elliott: Well, maybe Haskell's all that's keeping you in check ;)
20:05:24 <TravisD> applicative_: That sounds like a nice characterization
20:09:18 <lambdazerocool> thanks guys! (from way above)
20:26:03 <jmcarthur> zachk: if i'm truly irresponsible then i know all the ways to thwart the compiler :P
20:26:29 * jmcarthur knows what he's talking about due to how irresponsible he is
20:27:15 * jmcarthur counts 10 occurrences of the word "unsafe" in the module he currently has open
20:27:28 <jmcarthur> half of which are imports or type signatures, to be fair
20:28:08 <msxx> it is unfortunate that I can't unpack existential type, and have to resort to using Data.Dynamic
20:28:34 <jmcarthur> it's by design
20:28:49 <shachaf> The most likely answer is that you shouldn't be using either an existential type or Data.Dynamic.
20:28:54 <msxx> I don't like that design
20:29:06 <jmcarthur> you're using it wrong, most likely
20:29:07 <shachaf> That design is (almost) the only one that makes sense, in Haskell.
20:29:11 <arkeet> I don't like this tool because it wasn't designed to do the job I want.
20:29:53 <msxx> arkeet I want to have a list of Widgets. it seems to do that in haskell, I have to lose any type safety and use Data.Dynamic
20:30:19 <msxx> Widget is a class, implemented for many types (TextBox, etc)
20:30:54 <arkeet> why must widget be a class?
20:30:58 <shachaf> No, you don't need Data.Dynamic.
20:31:17 <shachaf> @where existential-antipattern gives exactly this example, for what it's worth.
20:31:17 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
20:31:28 <shachaf> But you haven't shown enough code to demonstrate what it is you're unable to do.
20:31:45 <msxx> I have read that already
20:32:05 <shachaf> OK. It's possible you've read it and only understood some of it.
20:32:10 <jmcarthur> (i don't actually believe that the constraint-under-existential pattern is an antipattern, but i do agree that it's overdone)
20:32:19 <shachaf> Likely, even, if you're leaning toward Data.Dynamic. :-)
20:33:02 <shachaf> jmcarthur: There are cases where it's justified, but I won't believe someone who says it's justified if they don't know the alternatives.
20:33:10 <jmcarthur> agreed
20:33:21 <msxx> shachaf Widget is a class, implemented for many types. how do you have a list of Widgets (or existential AnyWidget) without Data.Dynamic, while retaining the ability to extract the original object?
20:33:35 <jmcarthur> msxx: why do you need that latter ability?
20:33:37 <shachaf> What does it mean to extract the original object?
20:34:05 <msxx> to get back TextBox widget, for example
20:34:19 <jmcarthur> but why?
20:34:26 <jmcarthur> in what context will you be doing this?
20:34:31 <shachaf> data Secret; instance Widget Secret; foo_d = toDynamic (foo :: Secret)
20:34:37 <msxx> jmcarthur because generic Widget can't do all the things thatTextBox can
20:34:47 <shachaf> Since you don't know about Secret, you have no chance to "extract it", because you don't even know that its type exists.
20:34:49 <jmcarthur> then you shouldn't be hiding its type!
20:35:18 <msxx> jmcarthur, I need a list of Widgets (as you already know)
20:35:39 <jmcarthur> when i brought up just using an ADT you complained about extensibility. could you expand on why you think that's a problem?
20:35:55 <msxx> shachaf so in other words it can't be done without using Data.Dynamic. I have to go all the way, and lose all type safety. by design
20:36:00 <msxx> nice
20:36:07 <shachaf> msxx: ...Did you read what I said?
20:36:09 <jmcarthur> sorry, i'm being insinuating by saying "you think". i just mean "why would that be a problem here?"
20:37:03 <shachaf> msxx: I think the problem here is that there is no concrete code, or concrete thing that you're doing, being discussed.
20:37:20 <shachaf> jmcarthur and I probably have one idea, and you probably have a different idea. Therefore communication is difficult.
20:37:30 <shachaf> (Well, I can't speak for jmcarthur.)
20:37:35 <shachaf> Can you give a concrete example of what you're doing?
20:37:45 <jmcarthur> you have spoken for me effectively so far ;)
20:37:50 <msxx> jmcarthur it's a problem because users can't add new widgets without modifying original source
20:38:12 <jmcarthur> did you read up on data types a la carte?
20:38:31 <jmcarthur> i still have no context, but it sounds appropriate to me
20:38:37 <jmcarthur> from what i know
20:38:40 <shachaf> Another good thing to read about: "The Expression Problem"
20:39:03 <jmcarthur> related :)
20:39:13 <msxx> shachaf I have glanced over it. looks interesting, but how does it help me when I use some library that already decided to use class Widget for me?
20:39:45 <shachaf> It helps you think about what you're trying to do.
20:39:53 <shachaf> So far, I don't yet know what you're trying to do.
20:40:08 <jmcarthur> what is the purpose of this collection, for one?
20:40:18 <msxx> I am trying to have a list of AnyWidget, with ability to extract the actual Widget in question
20:40:23 <jmcarthur> why?
20:40:50 <elliott> I'd like to point out that, e.g. Python gives you no more than Haskell here.
20:41:10 <elliott> it just lets you make the interface to the values in your list arbitrarily complex without you knowing about it.
20:41:11 <msxx> because Widget is generic and does not have full functionality of underlining type
20:41:22 <jmcarthur> that doesn't answer my question
20:41:48 <msxx> jmcarthur was the question "why do you want to unpack it"?
20:41:57 <jmcarthur> why do you want to have this list? why do you need to full functionality of the underlying types? why did you hide their types if you need that functionality?
20:42:14 <jmcarthur> nevermind the last question, i think i understand why you did that
20:42:17 <msxx> elliott a dynamic language like python hardly sets a high bar here
20:42:19 <jmcarthur> but it hinges on the first two
20:43:40 * elliott isn't sure there are any bars at all.
20:44:18 <shachaf> For example, would a type like this be good for what you're doing? data MyWidget = A TextBox | B DrawingBox | ...
20:44:39 <shachaf> Oops, I lost the game of "don't make random guesses at what people are trying to do until they tell you".
20:44:50 <arkeet> it does sound like he wants it to be open.
20:45:10 <shachaf> arkeet: Does it? The one operation that's been mentioned so far is "check whether it's a TextWidget".
20:45:38 <jmcarthur> yeah, i don't see how he intends to use specific functionality from specific types if he doesn't even know the corpus of possible types
20:45:53 <arkeet> suppose I made a ColourfulTextWidget, which should support all the operations of a TextWidget, yet would still have a different type.
20:45:58 <arkeet> how would you even use Dynamic here?
20:46:17 <shachaf> I think we're all losing the game I mentioned.
20:46:24 <arkeet> I'm just thinking out loud.
20:46:28 <shachaf> Only monochrom wins.
20:46:29 <msxx> jmcarthur, why do my reasons matter?  I mean I hardly want to do something essoteric. I just want a list of widgets, that I can use as either generic Widgets, or as specific Widget types
20:46:30 * jmcarthur never said he would play that game
20:46:44 <jmcarthur> msxx: your reasons matter because we can't make appropriate recommendations otherwise
20:46:51 <msxx> this is trivially done in C++, C#, java..
20:46:57 <jmcarthur> show us code!
20:47:02 <jmcarthur> we have no idea what you *really* want
20:47:05 <parcs> msxx: if that's exactly what you want to do then use Dynamic
20:47:07 <msxx> I just said what I want
20:47:07 <jmcarthur> you just say what you think you want
20:47:09 <arkeet> well, you *can* make it work with Dynamic, or exists a. (Widget a, Typeable a) => a, but who knows.
20:47:30 <arkeet> (I'd prefer the latter over Dynamic)
20:47:31 <msxx> parcs I know I can use dynamic, but I lose all type safety with it.  an object in list could be an Int instead of a Widget
20:47:33 <elliott> I think this is going nowhere.
20:47:41 <arkeet> me too.
20:47:45 <jmcarthur> msxx: you keep saying you want this and that but you don't want dynamic. well if there's anything better, we still can't help because we don't know why you want this and that but not dynamic
20:47:50 <elliott> msxx: unless you give the people who are trying to help you some more information like they have requested, you're not going to get an answer
20:47:55 <elliott> because your question is ill-specified.
20:48:51 <msxx> jmcarthur I think we already concluded that dynamic is the only thing that would work. so I'm not really asking anymore, I am just venting my frustration
20:48:54 <shachaf> C++, C#, and Java don't really have type classes, so this isn't trivially done in them. :-)
20:48:59 <jmcarthur> we concluded no such thing
20:49:01 * shachaf sighs.
20:49:04 <jmcarthur> we don't even know what you really want to do
20:49:07 <mgsloan> msxx: (forall a. (Widget a, Typeable a) => a) is like dynamic, but also knows its a widget
20:49:23 <arkeet> I did just suggest this.
20:49:27 <shachaf> mgsloan: No, you want "exists", not "forall".
20:49:31 <arkeet> but exists.
20:49:33 <mgsloan> shachaf: really?
20:49:35 <mgsloan> hmmm
20:49:37 <shachaf> Really.
20:49:45 <jmcarthur> mgsloan: since you left out the constructor they are right
20:49:55 <shachaf> If you give me a (forall a. ... => a), I can pick what a is.
20:50:01 <msxx> mgsloan but you can't unpack underlining type. ie AnyWidget => TextBox
20:50:06 <arkeet> data DynamicWidget = forall a. (Widget a, Typeable a) => DW a
20:50:16 <arkeet> msxx: yes you can, that's what Typeable is there for
20:50:18 <jmcarthur> msxx: typeable is a runtime representation of the type. it's how dynamic works
20:50:24 <elliott> msxx: it is almost certainly not true that Dynamic is the best way to achieve your goals in Haskell.
20:50:25 <mgsloan> oh, right, I was imagining packing it in a datatype
20:50:34 <elliott> however, you refuse to specify your goals further. so we cannot help you.
20:50:51 <elliott> if you want to believe that Dynamic is the only way to solve your problem that's fine
20:50:51 <parcs> :t cast
20:50:51 <shachaf> mgsloan: data Foo = Foo (forall a. ... => a) is also not right. :-)
20:50:53 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
20:50:55 <arkeet> typeable gives you cast :: a -> Maybe b
20:50:57 <arkeet> yeah
20:51:33 <parcs> msxx:
20:51:41 <parcs> bah
20:51:44 <msxx> elliott I don't see how much more specific you want it than this: I just want a list of widgets, that I can use as either generic Widgets, or as specific Widget types
20:51:58 <elliott> for a start, we don't know anything about your widgets.
20:52:03 <msxx> in C++ terms, I want a vector<Widget*> that I can cast to a TextBox
20:52:07 <elliott> (yes, library design depends on the details of your library!)
20:52:20 <jmcarthur> msxx: what is the project you are working on? what feature is this intended to implement?
20:52:21 <shachaf> Haskell is not C++.
20:52:28 <msxx> it's a class implemented by TextBox and other widges. what more do you need to know?
20:52:29 <elliott> (the problem is that your question is phrased in a way quite particular to an OOP mindset. so we need more details to figure out how it should look idiomatically in Haskell.)
20:52:39 <elliott> "a class" especially demonstrates the problem here
20:52:43 <jmcarthur> msxx: you are asking for something in terms of various assumptions you have already made about the solution
20:53:11 * arkeet is wondering why one needs a list of widgets at all
20:53:21 <jmcarthur> exactly!
20:53:29 <jmcarthur> what purpose does it serve?
20:53:35 <msxx> elliott you have all the details you need
20:53:43 <jmcarthur> it may just be there what you want to do doesn't need a list like this at all
20:53:44 <arkeet> we really don't. :-)
20:53:47 <jmcarthur> *that what you want
20:53:50 <elliott> msxx: that is not true. and arguing with people trying to help you like that is unproductive. you're just wasting everyone's time
20:53:58 <jmcarthur> msxx: you have told us nothing except for your preconceptions
20:54:01 <arkeet> where is this list coming from?
20:54:07 <arkeet> what are you going to do with the TextBoxes in it?
20:54:13 <elliott> you don't get help (though you may feel smug about haskell's weaknesses, which seems like your real goal here at this point honestly), and we don't get to help you.
20:54:37 <jmcarthur> msxx: we are asking direct questions like "what is this list for?" and you are ignoring them, whether you really mean to or not.
20:54:38 <shachaf> msxx: We're not all just being obtuse here. You should treat this as a learning opportunity, if nothing else -- this is really a different way to think about things.
20:54:40 <msxx> elliott it seems like your goal is to defend haskell's weaknesses
20:54:51 <jmcarthur> lol
20:54:52 <parcs> OK this is getting unproductive...
20:54:53 <arkeet> lol
20:55:12 <msxx> and I don't feel smug, more like frustrated
20:55:17 <parcs> #haskell is too helpful sometimes
20:55:20 <msxx> because I can't do this simple thing
20:55:20 <jmcarthur> then help us help you
20:55:25 <arkeet> msxx: would you like to answer my questions?
20:55:29 <jmcarthur> answer our questions about the problem you have
20:55:33 <arkeet> or our.
20:55:44 <elliott> i don't think msxx wants to be helped.
20:56:00 <elliott> and i think we're all wasting approximately 10x more time on it than we should be.
20:56:39 <arkeet> (only 10?)
20:57:00 <arkeet> @where xy
20:57:00 <lambdabot> I know nothing about xy.
20:57:03 <arkeet> uh
20:57:23 <msxx> the help being offered is trying to convince me that I don't need to do what I am doing
20:57:28 <jmcarthur> no
20:57:36 <jmcarthur> you haven't answered enough questions
20:57:50 <arkeet> we don't know what you need or don't need to do, because we don't know what you're trying to accomplish with this.
20:57:52 <jmcarthur> we don't even *know* what you need to do
20:58:06 <shachaf> Imagine you asked: I want a pointer to a Widget! Why can't I make a pointer to a widget? C++ lets me do it.
20:58:15 <shachaf> Now, you *can* make a pointer to a widget.
20:58:22 <elliott> msxx: you need to change your attitude if you want answers to your question rather than just whining. do you really believe everyone here is on a cover-up mission to paper over haskell's flaws when they say they want more information about your incredibly vague problem?
20:58:24 <shachaf> But it's probably not useful in accomplishing your actual goals, whatever they are.
20:58:35 <elliott> everyone else: can we please stop repeating the same thing over and over when msxx does?
20:59:00 <jmcarthur> fair
20:59:31 <msxx> arkeet I am trying to have a list of Widgets, that I can operate on as either generic Widgets, or as specific widgets (by unpacking AnyWidget to actual widget type). I can't do this without resorting to Data.Dynamic (which is what I will end up doing). so I know all there is to know, you can all carry on doing whatever you were doing prior to this
20:59:56 <msxx> good night all
21:00:01 <arkeet> :(
21:00:03 <shachaf> msxx sure showed us.
21:00:08 <jmcarthur> lol
21:00:21 <arkeet> but we even suggested something strictly better than Dynamic.
21:00:31 <elliott> I for one am quitting Haskell now that I have been shown this massive hole in its expressivity
21:00:50 <jmcarthur> i think i failed to understand the harm of my repetition until the very end there. apologies
21:00:51 <mgsloan> it's just not safely dynamic, damnit!
21:01:24 <elliott> jmcarthur: eh, everyone can get stuck in a loop like that without realising it. it happens a lot on IRC
21:01:37 <arkeet> I am kind of curious now how one would do subtyping with a Dynamic-ish thing.
21:01:52 <elliott> arkeet: Exception does just that, no?
21:01:59 <jmcarthur> Dynamic-ish in what way?
21:02:33 <arkeet> elliott: in what way?
21:02:35 <jmcarthur> elliott: that depends on what is meant by "subtyping." Exception doesn't really allow for any sort of heirarchy, for example. it's a flat structure
21:02:46 <arkeet> maybe I didn't mean "subtyping".
21:02:49 <arkeet> I don't know what "subtyping" means.
21:03:00 <Mathnerd314> hmm, this Widget stuff has been going on way too long. Maybe I should just write a GUI library and be done with it
21:03:02 <elliott> ask shachaf. he knows all about the true meaning of subtyping.
21:03:10 <arkeet> but I mean stuff like
21:03:21 <parcs> the answer to msxx's problem was 'data DynamicWidget = forall a. (Widget a, Typeable a) => DW a'
21:03:29 <parcs> why did he ignore that, twice?
21:03:35 <mgsloan> subtyping means you have a prism.  Boom!
21:03:47 <jmcarthur> because he wanted to hear that haskell was insufficiently expressive for his unique needs
21:03:47 <arkeet> being able to express A is a B, B is a C, and given a C, we can tell if it's a B, such that A is seen as a B.
21:03:58 <Mathnerd314> parcs: it's the existential antipattern!
21:04:15 <arkeet> "is a B" means "supports the operations of B"
21:04:19 <jmcarthur> dynamic is just a (worse) manifestation of the same pattern
21:04:51 <arkeet> er, "every A is a B", ...
21:05:06 <Mathnerd314> you could do data DynamicWidget = { <wdiget ops>, Dynamic }, but I guess the question is why you need Dynamic at all?
21:06:09 <jmcarthur> arkeet: type classes can be constrained to enforce that any instance of A must also be an instance of B. it's not really subtyping, but it covers a lot of the cases that one might care about
21:06:21 <Mathnerd314> IIRC pretty much every other language has Dynamic in some form or another, so it's not too bad (void*, Object, etc.)
21:06:47 <arkeet> jmcarthur: I had in mind that A and B were specific types.
21:06:47 <jmcarthur> arkeet: and various up/down-conversion functions in type classes and be used to explicitly handle the coercions for some subtyping relationships
21:06:53 <jmcarthur> *can be used
21:06:56 <arkeet> maybe they shouldn't be types at all. maybe they should be values.
21:07:14 <jmcarthur> arkeet: that they are specific types i think doesn't make a difference here
21:07:27 <jmcarthur> values is more different from what i expected though
21:08:26 <arkeet> anyway, I really don't want to continue the earlier discussion, so I'll stop.
21:08:57 <Mathnerd314> hmm, type-case syntax would be nice (case (type x) of ... -> ... )
21:09:08 <Mathnerd314> I don't think Haskell does that now
21:09:36 <arkeet> what for?
21:09:42 <jmcarthur> arkeet: that's a shame. i somehow doubt you would make the same mistakes we just witnessed
21:10:12 <jmcarthur> and maybe i wouldn't repeat my mistakes too!
21:10:20 <mgsloan> it wouldn't be too hard to have some multiple-type pattern matching.  But that's not the really the kind of thing we want to sugar over
21:10:59 <arkeet> jmcarthur: well, probably the first thing to do is to come up with a specific goal.
21:11:02 <jmcarthur> Mathnerd314: i do think some honest to goodness open data types might be nice, but i admit i don't have any real use cases in mind
21:11:07 <XexonixXexillion> mgsloan: I think there's a language extension for that... something like patter guards
21:11:26 <XexonixXexillion> s/patter/pattern/
21:12:05 <Mathnerd314> jmcarthur: well, when you don't want to use type classes, you're pretty much out of alternatives. this would be one alternative
21:12:16 <mgsloan> XexonixXexillion: Yeah, those, or viewpatterns would be handy for this
21:13:05 <Mathnerd314> jmcarthur: I think http://ropas.snu.ac.kr/~bruno/papers/Typecase.pdf might provide some examples, still looking at it
21:14:25 <mgsloan> view patterns already provide some pretty nice sugar for this: case typeableThing of { (cast -> Just (x, y)) -> ...; }
21:15:45 <arkeet> neat.
21:16:14 <arkeet> as long as you can pin down the types of x and y there.
21:16:18 <mgsloan> yup
21:16:52 <Mathnerd314> mgsloan: wouldn't case (cast typablething) of {Just (x,y) -> .... } look nicer though? :-)
21:17:21 <arkeet> Mathnerd314: no, because "cast typablething" must have one specific type.
21:17:32 <mgsloan> something like that could /look/ nicer, but I think this is the kind of thing that should have attention called to it
21:17:37 <Mathnerd314> this is why subtyping is cool :-)
21:17:39 <arkeet> so it wouldn't work.
21:17:48 <mgsloan> make safe things syntactically minimal, make unsafe things require a little more work :)
21:17:55 <arkeet> or are you saying it *should* work.
21:18:05 <shachaf> Subtyping doesn't mean type-case.
21:18:11 <shachaf> Prisms /= lenses, man.
21:18:35 <arkeet> I think I do mean subtyping.
21:18:48 <arkeet> how come no one suggested lens to msxx? ;)
21:18:58 <Mathnerd314> hmm, so you do get some information in pattern matching GADT's
21:19:28 <Mathnerd314> e.g. case (<gadt>) of A -> ...; B -> ..., A and B can have different types
21:19:34 <arkeet> no,
21:19:38 <arkeet> A and B have the types of the GADT.
21:19:54 <arkeet> but you can write case gadt of A x -> ...; B y -> ..., where x and y have different types.
21:19:58 <Mathnerd314> A :: GADT Int, B :: GADT String - different types
21:20:01 <arkeet> in fact you don't even need a GADT to do this.
21:20:16 <arkeet> in fact a GADT doesn't let work like that.
21:20:19 <shachaf> GADTs give you exists, *>, and ~
21:20:20 <arkeet> s/let //
21:20:34 <mauke> Mathnerd314: test case?
21:20:42 * Mathnerd314 goes into ghci
21:21:00 * mauke locks the channel
21:22:43 <shachaf> I guess Mathnerd314 means something along the lines of: data GADT a where { A :: GADT Int; B :: GADT String }; foo :: GADT a -> ...; foo A = ...; foo B = ...
21:22:52 <Mathnerd314> yeah
21:23:04 <shachaf> In the first case, a ~ Int, and in the second case, a ~ String
21:23:11 <shachaf> But it's still a, either way.
21:23:32 <shachaf> The type of "x :: GADT a" hasn't changed, you've just learned more about it.
21:23:58 <Mathnerd314> right, and in case (cast x :: b) of (x,y) -> ... you also have that the type is always b, the pattern-match gives you b ~ (x,y) though
21:24:43 <Mathnerd314> so it seems similar on the type level
21:25:08 <mauke> case x of (cast -> Just (x,y))
21:25:30 <arkeet> could you do something like that with exists a. GADT a?
21:25:44 <Mathnerd314> mauke: but if you need two cases, you do the cast twice
21:25:47 <arkeet> maybe not.
21:25:51 <mauke> Mathnerd314: yes
21:26:14 <Mathnerd314> mauke:  whereas the case pattern I'm thinking of just examines a type tag and dispatches on that
21:26:15 <arkeet> and you need to, because the result types of the two casts are different.
21:26:16 <mauke> 'cast' is a conversion between two specific types
21:26:36 <mauke> I think that's the fundamental difference between GADT case and cast
21:27:06 <mauke> the GADT has a fixed set of possible constructors and a tag that tells you which it is
21:27:19 <shachaf> Hmm, a "cast" that gives you type evidence is interesting.
21:27:25 <Mathnerd314> mauke: no, cast is just unsafeCoerce :p http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Typeable.html#cast
21:27:39 <mauke> I'm not talking about the implementation :-)
21:27:41 <shachaf> cast :: (Typeable a, Typeable b) => Maybe (Is a b)?
21:28:10 <mauke> I'm not even looking at that link but I'm pretty sure it's something like 'if typeOf x == typeOf y then Just (unsafeCoerce x) else Nothing'
21:28:18 <Mathnerd314> lol, yep
21:28:54 <Mathnerd314> although they call it r
21:29:02 <mauke> (result)
21:29:10 <Mathnerd314> and you forgot the fromJust
21:29:32 <Mathnerd314> shachaf: yeah, Maybe (a ~ b)
21:29:38 <shachaf> Mathnerd314: That's a kind error.
21:30:22 <mauke> :t \x -> fix $ \ ~(Just y) -> if typeOf x == typeOf y then Just (unsafeCoerce x) else Nothing
21:30:24 <lambdabot> Not in scope: `unsafeCoerce'
21:30:28 <Mathnerd314> shachaf:  isn't there Dict :: Constraint -> * though?
21:30:30 <mauke> :t \x -> fix $ \ ~(Just y) -> if typeOf x == typeOf y then Just (?unsafeCoerce x) else Nothing
21:30:32 <lambdabot> (?unsafeCoerce::a -> a1, Typeable a1, Typeable a) => a -> Maybe a1
21:30:43 <shachaf> Mathnerd314: There is data Is a b where Refl :: Is a a
21:30:47 <mauke> I'd test it but ... unsafeCoerce
21:31:17 <Mathnerd314> I think Dict (a ~ b) is equivalent to Is a b
21:31:42 <Mathnerd314> but maybe I'm wrong
21:32:27 <shachaf> dreixel: What do you think of cast :: (Typeable a, Typeable b) => p a -> Maybe (p b) ?
21:32:39 <Mathnerd314> (Dict being from http://hackage.haskell.org/packages/archive/constraints/0.3.2/doc/html/Data-Constraint.html)
21:33:52 <shachaf> dreixel: (Or Maybe (p a -> p b).)
21:34:02 <arkeet> shachaf: the first one would be nice, you could take p = Is a
21:34:11 <shachaf> arkeet: Right.
21:34:31 <arkeet> so would the latter.
21:35:03 <shachaf> Right.
21:35:20 <Mathnerd314> hmm, sounds like a lens
21:39:07 <carter_> thoughtpolice i'm super pleased about killing that bug :)
21:39:37 <shachaf> preflex: seen dreixel
21:39:38 <preflex>  dreixel was last seen on #haskell 14 days, 12 hours, 44 minutes and 13 seconds ago, saying: Taneb: what's a BiFunctor?
21:39:49 <shachaf> Oh, poor dreixel.
21:40:00 <shachaf> You don't ask Taneb about bifunctors.
21:40:10 <mauke> preflex: seen bug
21:40:10 <preflex>  bug was last seen on ##java 1 year, 31 days, 21 hours, 50 minutes and 23 seconds ago, saying: here is the log http://pastebin.com/bMqaaWCa
21:40:14 <mauke> The paste bMqaaWCa has been copied to http://hpaste.org/83435
21:40:27 <johnw> preflex: seen johnw
21:40:27 <preflex>  johnw was last seen on #haskell 6 hours, 28 minutes and 52 seconds ago, saying: cmsmcq: as long as it's not the Master Codex
21:43:54 <carter> who is preflex ?
21:44:05 <carter> preflex: seen carter
21:44:05 <preflex>  carter was last seen on #haskell 12 seconds ago, saying: who is preflex ?
21:44:19 <carter> hehe
21:46:42 <Mathnerd314> so another problem, which I'm not certain how to do: casting to something polymorphic. AFAIK there isn't Typable [a] and you can't write it
21:48:53 <Mathnerd314> the RTS can treat [a] pretty easily as [Any], but I don't think you can do that from user code
21:50:39 <Mathnerd314> (without unsafeCoerce)
21:56:25 <arkeet> Mathnerd314: but there is Typeable a => Typeable [a]
21:56:45 <arkeet> because [] is Typeable1
21:56:58 <Mathnerd314> arkeet: right, but that doesn't let you do cast [] :: [a]
21:57:09 <arkeet> no, because a is ambiguous.
21:57:17 <arkeet> well
21:57:22 <arkeet> no, because cast [] :: Maybe [a]
21:57:32 <arkeet> but also the type of [] is ambiguous.
21:57:37 <Mathnerd314> well, I'm saying the RTS lets you treat [Any]
21:57:46 <Mathnerd314> s/treat/treat it as/
21:57:54 <arkeet> what is Any?
21:58:39 <Mathnerd314> magic: http://hackage.haskell.org/packages/archive/ghc-prim/0.2.0.0/doc/html/GHC-Prim.html#t%3AAny
21:59:22 <mbuf> has anyone got lambdabot to compile? I am using GHC version 7.0.4 on Fedora 17; http://www.haskell.org/haskellwiki/Lambdabot/Building documentation is old?
22:01:25 <kvda> How I can transform, a -> b -> c -> d into a -> b -> c -> e ?
22:01:47 <shachaf> You need a function :: d -> e
22:04:20 <Cale> mbuf: The current lambdabot instance builds for me on 7.4.2. There's a guy working on getting it to build on 7.6.x.
22:04:32 <kvda> shachaf, is there a general function that does that?
22:04:40 <arkeet> :t (.).(.)
22:04:42 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
22:04:44 <arkeet> ugh.
22:04:46 <arkeet> caaaaaaaaaaale
22:04:53 <Cale> Wat
22:04:54 <arkeet> :t let (.) = (Prelude..) in (.).(.)
22:04:55 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
22:04:57 <arkeet> :t let (.) = (Prelude..) in (.).(.).(.)
22:04:59 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
22:05:12 <arkeet> Cale: fix (.)
22:05:15 <Cale> I think it's actually easier to see why that works if you think of it as fmap . fmap . fmap
22:05:27 <arkeet> no!
22:05:27 <Cale> and then specialise to the function instance
22:05:32 <arkeet> if I wanted fmap I'd use fmap.
22:05:43 <shachaf> kvda: (.).(.).(.)
22:05:49 <mbuf> Cale: which version of lambdabot is that?
22:05:54 <shachaf> Or fmap.fmap.fmap -- that makes sense here.
22:05:54 <arkeet> @version
22:05:55 <lambdabot> lambdabot 4.2.2.1
22:05:55 <lambdabot> darcs get http://code.haskell.org/lambdabot
22:05:57 <Cale> You'd never write (.) . (.) . (.) in your code though.
22:06:06 <Cale> You'd just use a lambda :P
22:06:16 <kvda> Oh geez
22:06:17 <arkeet> eww, points.
22:06:17 <arkeet> :p
22:06:26 <mbuf> Cale: who is working on getting it to build on 7.6.x?
22:06:32 <kvda> I'm sure I'm not explaining the problem
22:06:36 <kvda> correctly
22:06:50 <Cale> Jan Stolarek
22:08:10 <mbuf> Cale: thanks
22:08:56 <Cale> actually, iirc, he was successful
22:09:07 <mbuf> Cale: I see
22:09:15 <Cale> The link to his github repo is dead though
22:09:18 <Cale> I have no idea
22:09:32 <kvda> thanks shachaf
22:09:42 <Cale> https://github.com/killy9999/lambdabot/tree/upstream -- it was here
22:10:40 <arkeet> https://github.com/jstolarek/lambdabot -- ?
22:11:53 <Cale> ah, that's probably it :)
22:14:11 * monochrom shakes head at the discussion 1.5 hours ago. AnyWidget is no improvement Dynamic. I will not question motives, I only question logical consistency: if you reject Dynamic then you should reject AnyWidget too. same difference.
22:16:15 <shachaf> monochrom: Which AnyWidget are you talking about?
22:16:26 <monochrom> msxx's
22:16:32 <shachaf> data AnyWidget = forall a. Widget a => AnyWidget a doesn't let you do as much as Dynamic
22:16:40 <shachaf> You can't type-case with it.
22:17:13 <monochrom> ah, IIRC Widget's API has downcasts just like Dynamic does
22:17:32 <shachaf> Oh, this is a specific Widget we're talking about?
22:17:43 <monochrom> it's gtk2hs isn't it?
22:18:10 <shachaf> Is it?
22:18:21 <shachaf> The existential-typeclass post mentions vty-ui
22:18:26 <shachaf> Who knows what it actually is.
22:18:32 <monochrom> even if not, the statement "AnyWidget is no improvement over Dynamic" is true. truer if Widget cannot be downcasted
22:18:34 <shachaf> (Unless someone said it and I missed it.)
22:24:10 <monochrom> anyway, I won the game because I was watching a movie! it's The Astronaunt's Wife.
22:25:09 <TravisD_> Sorry if someone posted an article. I got disconnected for a minute
22:25:59 <monochrom> yeah, I just posted the complete proof of P != NP, and too bad you got disconnected :)
22:26:22 <shachaf> Don't mind monochrom. His proof was just "fix id"
22:27:05 <TravisD> Gosh. Must have been a short proof :)
22:27:20 <monochrom> free monad is interesting
22:27:39 <TravisD> interesting monad is interesting
22:33:20 <epta> interesting monad is free
22:33:45 <ion> I love interesting monads. They are so easy.
22:35:21 <Iceland_jack> lol
22:36:30 <TravisD> How did that start, anyways?
22:36:52 <Iceland_jack> TravisD: beaky
22:36:55 <arkeet> TravisD: http://hpaste.org/82140
22:37:05 <arkeet> oh that doesn't contain "they are so easy"
22:37:39 <monochrom> I love cursing and recursing
22:37:46 <elliott> I love easiness. it is so monoidal
22:38:03 <TravisD> Heh, it's too bad those weren't all back to back
22:39:12 <letrec> What's the best way to convert String to Data.ByteString.Lazy.Internal.ByteString ?
22:39:47 <mauke> hmm, some kind of 'encode' function
22:40:14 <ktosiek> pack?
22:40:18 <mauke> no
22:40:36 <elliott> letrec: convert howso?
22:40:44 <elliott> String is a list of cahracters. ByteString a list of bytes. different things
22:40:51 <elliott> you have to define a translation. for instance, UTF-8 encoding
22:40:58 <ion> I wonder if (Text.Lazy.Encoding.encodeUtf8 . Text.Lazy.pack) will have any Text wrapping optimized away by fusion?
22:40:59 <letrec> I can convert string to Text and then to lazy ByteString but I suspect there's a better way
22:41:49 <mauke> letrec: do you want utf-8?
22:42:37 <letrec> I have to say convertion between String, Text, ByteString (lazy or not) is a pain in Haskell. Anyway, going through Text works apparently.
22:42:45 <letrec> THX
22:42:51 <mauke> letrec: do you want utf-8?
22:42:58 <blueonyx> letrec: there is Data.String.Conversions
22:43:11 <elliott> letrec: you won't understand your code until you answer the questions we've asked :)
22:43:15 <Iceland_jack> letrec: Does anyone know if there are any plans to alleviate those pains in future standards?
22:43:20 <elliott> you might have something that compiles but if you don't udnerstand what it's doing you'll get bugs you can't fix.
22:43:28 <blueonyx> letrec: and OverloadedStrings language extension
22:43:36 <elliott> it might seem like a pain because it's not simply "conversion"
22:43:43 <elliott> Strings and ByteStrings do not represent the same things
22:44:35 <shachaf> letrec: You should answer mauke's question.
22:44:45 <ion> Noooo, don’t do it
22:44:50 <shachaf> How do I convert Int to (Bool,Bool)?
22:45:18 <mauke> even &&& odd
22:45:42 <arkeet> const (True, unsafePerformIO (putStrLn "hello" >> return False))
22:45:43 <ion> shachaf: Haskell makes the conversions between Int, (Bool,Bool) and GtkWindow a pain. :-\
22:46:01 <shachaf> mauke: I gave you two bits of information and you chose to only use one of them?
22:46:18 <mauke> did you mean: 32 bits
22:46:29 <elliott> did you mean: an undefined number of bits but at least 31
22:46:41 <arkeet> shachaf: actually there's more, (Bool,Bool) has at least 10 values.
22:46:41 <augur> koninkje_away: we should make a proof editor for ND and SC proofs
22:46:55 <TravisD> elliott: Does the sign not count as a bit?
22:46:56 <shachaf> mauke: Two bits in the output.
22:47:09 <mauke> 10 values in two bits
22:47:13 <arkeet> I thoguht it was at least 29.
22:47:24 <mauke> those who understand binary and those who don't
22:47:25 <elliott> TravisD: haskell report doesn't guarantee 32 bits. arkeet may be right
22:47:26 <shachaf> I am educated stupid. :-(
22:47:33 <arkeet> mauke: no, decimal 10.
22:47:38 <TravisD> :S why such a strange number?
22:47:45 <arkeet> TravisD: room for tag bits
22:47:47 <arkeet> or something
22:47:50 <TravisD> ah
22:47:59 <letrec> I totally understand they are different objects, and that makes sense but it's a pain. No need for utf8, don't really care about the charset.
22:48:01 <TravisD> actually that makes sense I guess
22:48:15 <mauke> letrec: if you don't want utf-8, then what the hell do you want?
22:48:24 <shachaf> Allow me to recommend UTF-EBCDIC
22:48:38 <mauke> I can give you const BS.empty :: String -> ByteString
22:48:48 <arkeet> "The finite-precision integer type Int covers at least the range [-2^29, 2^29 - 1]."
22:48:59 <arkeet> 30 bits.
22:49:06 <shachaf> Makes sense.
22:49:08 <shachaf> Two tag bits.
22:49:17 <TravisD> What are the tag bits used for?
22:49:22 <mauke> tags
22:49:22 <shachaf> Nothing.
22:49:27 <arkeet> right now, they aren't.
22:49:34 <TravisD> heh, I see
22:49:36 <mauke> > maxBound :: Int
22:49:36 <arkeet> because Int really is 32 or 64 bits, depending on your system.
22:49:37 <lambdabot>   9223372036854775807
22:49:42 <monochrom> I recommend EBCDIC too
22:49:43 <arkeet> I assume they used to be.
22:49:48 <arkeet> > 2^63 - 1 :: Int
22:49:51 <lambdabot>   9223372036854775807
22:49:58 <shachaf> I don't think they ever were.
22:50:01 <shachaf> Not in GHC, anyway.
22:50:01 <arkeet> hmm
22:50:03 <shachaf> I might be wrong.
22:50:05 <mauke> > showIntAtBase 16 intToDigit maxBound
22:50:07 <lambdabot>   Ambiguous type variable `a0' in the constraints:
22:50:07 <lambdabot>    (GHC.Enum.Bounded a0)
22:50:07 <lambdabot>  ...
22:50:16 <mauke> > showIntAtBase 16 intToDigit (maxBound :: Int) ""
22:50:18 <lambdabot>   "7fffffffffffffff"
22:50:21 <shachaf> > base 16 # (maxBound::Int)
22:50:23 <lambdabot>   Not in scope: `#'
22:50:26 * shachaf sighs.
22:50:30 <simpson> TravisD: A long long time ago, in Lisp-land, two or three bits were used to tag integers, for various purposes. I think that the designers of Haskell left in that wiggle room for tags in case any implementation wanted them.
22:50:30 <shachaf> @let x # y = review x y
22:50:33 <lambdabot>  Defined.
22:50:33 <shachaf> > base 16 # (maxBound::Int)
22:50:36 <arkeet> > base 16 Lens.# (maxBound::Int)
22:50:37 <lambdabot>   "7fffffffffffffff"
22:50:38 <lambdabot>   Not in scope: `Lens.#'
22:50:38 <lambdabot>  Perhaps you meant one of these:
22:50:38 <lambdabot>    `Lens.&' (import...
22:50:44 <shachaf> Or even (hex # )
22:50:47 <simpson> TravisD: BTW, this is also why X11's integers are 29 bits long.
22:50:56 <mauke> Char has 21 bits
22:51:07 <TravisD> that's pretty interesting
22:51:14 <arkeet> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/PointerTagging
22:51:18 <ion> 21 bits should be enough for everyone.
22:51:18 <arkeet> I assume something to do with this.
22:51:19 <monochrom> GHC decides to use 2 words for 1 Int. therefore, it can do the full 32 or 64 bits. the 2nd word has the tag bits
22:51:30 <arkeet> or maybe not.
22:51:44 <mauke> that's tagging the pointer directly, not the value
22:54:37 <arkeet> monochrom: oh right, boxes.
22:58:20 <blueonyx> :t #
22:58:22 <lambdabot> <no location info>: not an expression: `#'
22:59:18 <shachaf> The pointer tagging GHC does isn't related to this.
23:09:01 <kvda> How can you get around importing Db/Schema.hs instead of /Db/Schema/* by using import Db.Schema?
23:09:15 <elliott> you write Db/Schema.hs that re-exports stuff
23:09:42 <kvda> reexports the files in Db/Schema/?
23:09:59 <elliott> reexports the modules
23:11:23 <kvda> thanks elliott. I'll try to find that in LYAH
23:11:50 <saep> module Foo ( module Foo.Bar, module Foo.Quz ) where import Foo.Bar ...
23:11:57 <arkeet> kvda: see for example https://github.com/ekmett/lens/blob/master/src/Control/Lens.hs
23:12:24 <arkeet> yeah
23:13:16 <kvda> ah easy, thanks guys.
23:15:45 <fragamus> :t ($$)
23:15:46 <lambdabot> Doc -> Doc -> Doc
23:16:07 <arkeet> :t text
23:16:09 <lambdabot> String -> Doc
23:16:13 <arkeet> > text "a" $$ text "b"
23:16:15 <lambdabot>   a
23:16:15 <lambdabot>  b
23:17:34 <fragamus> > let c = text "a" $$ text "b" in c
23:17:35 <lambdabot>   a
23:17:36 <lambdabot>  b
23:17:42 <fragamus> yah
23:18:01 <supki> > let d = let c = text "a" $$ text "b" in c in d
23:18:03 <lambdabot>   a
23:18:03 <lambdabot>  b
23:18:19 <fragamus> ok wise guy
23:18:47 <arkeet> > let d = let c = text "a" $$ text "b" in show c in d
23:18:49 <lambdabot>   "a\nb"
23:19:23 <arkeet> > parens (text "hi")
23:19:24 <lambdabot>   (hi)
23:19:45 <fragamus> nice
23:20:01 <arkeet> > text "a" $$ nest 4 (text "b")
23:20:03 <lambdabot>   a   b
23:20:12 <arkeet> > text "a" $$ nest 4 (text "b") $$ nest 4 (text "c")
23:20:14 <lambdabot>   a   b
23:20:15 <lambdabot>      c
23:20:28 <arkeet> stupid spaces.
23:21:23 <arkeet> > vcat [text "a", nest 4 (text "b"), nest 4 (text "c"), nest 8 (text "d")]
23:21:25 <lambdabot>   a   b
23:21:25 <lambdabot>      c   d
23:22:08 <arkeet> > (text "a" $$ text "b") <> text "c"
23:22:10 <lambdabot>   a
23:22:10 <lambdabot>  bc
23:23:21 * hackagebot yaml 0.8.2.2 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.2.2 (MichaelSnoyman)
23:28:21 * hackagebot udbus-model 0.2.0 - Model API for udbus introspection and definitions  http://hackage.haskell.org/package/udbus-model-0.2.0 (VincentHanquez)
23:28:23 * hackagebot yaml 0.8.2.3 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.2.3 (MichaelSnoyman)
23:41:56 <jonkri> what is the most elegant way to go from "Maybe [a]" to "[a]"?
23:42:05 <jonkri> (Nothing -> [])
23:42:21 <simpson> :t listToMaybe
23:42:22 <lambdabot> [a] -> Maybe a
23:42:29 <simpson> :t listToMaybe . concat
23:42:31 <lambdabot> [[a]] -> Maybe a
23:42:36 <simpson> Oh, wiat.
23:42:41 <simpson> :t maybeToList
23:42:42 <c_wraith> :t fromMaybe []
23:42:42 <lambdabot> Maybe a -> [a]
23:42:43 <jonkri> yeah, already saw those :)
23:42:43 <lambdabot> Maybe [a] -> [a]
23:42:52 <simpson> I like c_wraith's.
23:44:00 <jonkri> i'm looking for Maybe [a] to [a], not Maybe a -> [a]
23:44:12 <jonkri> oh wait
23:44:31 <lispy> > fromMaybe [] (Just [1..3])
23:44:33 <lambdabot>   [1,2,3]
23:46:00 <jonkri> thanks
23:46:21 <liyang> > maybe [] id -- is one character shorter than fromMaybe [].
23:46:23 <lambdabot>   No instance for (GHC.Show.Show (Data.Maybe.Maybe [a0] -> [a0]))
23:46:23 <lambdabot>    arising ...
23:46:37 <lispy> > maybe[]id(Just[1..3])
23:46:39 <lambdabot>   [1,2,3]
23:46:44 <lispy> who needs spaces?!
23:48:54 <srhb> Huh, I actually thought symbols were allowed on the end of alphanumerical identifiers
23:49:14 <lispy> depends on the symbol
23:49:19 <srhb> So I gather.
23:49:23 <lispy> maybe_ would be one identifier
23:49:39 <srhb> As would maybe'
23:49:43 <srhb> What's the general rule here?
23:49:54 <liyang> srhb: ' and _ are hononrary letters. And you can promote # with MagicHash.
23:50:06 <srhb> Peculiar.
23:50:17 <shachaf> ' and _ aren't symbols.
23:50:25 <srhb> Because stuff.
23:50:31 * lispy -> bed
23:50:44 <TravisD> Could someone point me to an introductory article on associated types? I am trying to understand the vector-space package. Sorry for asking a second time
23:50:44 <shachaf> Oh, I'm wrong.
23:50:46 <shachaf> They are symbols.
23:51:34 <liyang> TravisD: I like vector-space.
23:51:47 <srhb> Maybe it's because they are both in the punctuation category?
