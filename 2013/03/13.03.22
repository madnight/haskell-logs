00:00:16 <BadKitty> shachaf: As explained on what wikipedia pagE?
00:00:25 <shachaf> AES
00:00:44 * BadKitty sees quites a blank wikipedia page
00:00:57 <BadKitty> http://simple.wikipedia.org/wiki/Advanced_Encryption_Standard -- Skimming, I skip?
00:01:17 <BadKitty> oh wtf did simple. come from O.o
00:03:03 <BadKitty> shachaf: Where am I meant to be looking ... :|
00:03:20 <pharaun> known attacks?
00:03:41 <shachaf> All known attacks are computationally infeasible. For AES-128, the key can be recovered with a computational complexity of 2126.1 using bicliques. For biclique attacks on AES-192 and AES-256, the computational complexities of 2189.7 and 2254.4 respectively apply. Related-key attacks can break AES-192 and AES-256 with complexities 2176 and 299.5, respectively.
00:04:06 <shachaf> Skimming Wikipedia pages is a valuable skill -- much more valuable than knowing about the existence of theoretical weaknesses in AES-256.
00:04:29 <pharaun> 299.5?
00:04:37 <pharaun> that seems unusually low
00:05:02 <pharaun> oh 2^99.5
00:05:28 <Shin-LaC> http://crypto.stackexchange.com/questions/5118/is-aes-256-weaker-than-192-and-128-bit-versions
00:05:55 <BadKitty> Strange
00:06:10 <BadKitty> Intereting that more is less O.o
00:06:17 <BadKitty> (In this exact context)
00:06:59 <pharaun> interesting i was not aware of 256 being weaker in some sense
00:07:02 <shachaf> With that said, you probably shouldn't be dealing with any cryptography library that makes you decide whether to use AES-256 or AES-128.
00:07:47 <BadKitty> shachaf: tls
00:07:55 <BadKitty> Not make but options are there
00:08:47 <pharaun> In the formal land of academic cryptanalysis, related-key attacks still count as worthwhile results, despite their lack of applicability to most practical scenarios.
00:09:46 <otters> that's the kind of stuff #haskell loves though
00:11:43 <pharaun> this is educational
00:12:30 <pharaun> also for additional fun, read up on lucky 13, beast, crime, and all of the other fun tls/ssl attacks
00:14:34 <BadKitty> How would one make a basic tls client/server where the certificates are required, no public sent in the plain and signed by a top level certificate?
00:14:45 <BadKitty> Or.. Just top-level sign I guess.
00:17:08 <BadKitty> Need to send bytestrings around through tls
00:37:14 <paddymahoney> hey all, what are you using to edit haskell?
00:37:25 <MasseR> Vim
00:38:35 <Hermit> emacs
00:39:07 <BadKitty> vim
00:40:17 <BadKitty> Oh and zsh
00:40:39 <BadKitty> Substitutions <3
00:40:43 <paddymahoney> lovely! any particular modes you prefer?
00:40:54 <BadKitty> modes?
00:40:57 <shachaf> Command mode is pretty good.
00:41:44 <shachaf> paddymahoney: To be less unhelpful: Asking about editors in here won't get you very far (though it might start some flame wars if you're not careful).
00:41:53 <shachaf> paddymahoney: Whichever editor you're using should be just fine.
00:42:07 <shachaf> You don't really need special editor support for Haskell.
00:42:16 <Saizan> @where haskell-mode
00:42:16 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
00:42:17 * BadKitty fules the fire
00:42:18 <BadKitty> VIM!
00:42:38 <shachaf> BadKitty: Please don't.
00:43:00 <Saizan> http://www.haskell.org/haskellwiki/Editors <- this page has details, it seems
00:43:01 <BadKitty> shachaf: I'm not.
00:43:09 <Saizan> well, links mostly
00:43:27 <paddymahoney> thanks all! just curious, I like a pretty bare bones editor, I could use a reindent all, a few other small features.
00:43:28 <shachaf> Ah, emacs has a thing called haskell-mode specifically.
00:43:50 <shachaf> paddymahoney: "reindent all" isn't really a thing you can usually do because indentation is significant in Haskell code.
00:45:22 <Hermit> paddymahoney: but if you are so worried about indentation, emacs has 3 indentation modules
00:45:36 <Hermit> paddymahoney: I'm sure one of them will suit your tastes
00:46:10 <shachaf> If you're not already using emacs, you probably shouldn't start using it just for Haskell. Then you have two complicated things to learn at once.
00:47:23 <Hermit> a ghci commands crafting question: How can I use System.Process.std_in (or System.Process.Internals.std_in) without ghci bitching about invisible constructor? (note: they ARE exported)
00:48:00 <Hermit> (I already workarrounded it using  :m System.Process  in .ghci, but I'd like to use this directly, no imports)
00:51:03 <Hermit> (or any constructor from System.Process.Internals for that matter)
00:56:15 * BadKitty installs yi
00:56:53 <BadKitty> hackage yi is broken, git yi not. (With latest ghc)
01:02:30 <BadKitty> Naww
01:46:49 <kurkale6ka> Hi, in the following http://bpaste.net/show/85545/ I don't understand showNameQuestion (name knight). To me nae is a constant in the Knight data type, so why is it used as a function?
01:47:00 <kurkale6ka> nae
01:47:05 <kurkale6ka> name :)
01:51:37 <Saizan> name is a field of Knight, so it's also an accessor function getting out that field out of a Knight value
01:53:46 <kurkale6ka> Saizan: thanks
02:07:39 <nrgs1> ?
02:10:15 <jbu> hi all. what does it mean to see a constructor like data Blah a = Foo ()?  What does the () mean in this context?
02:10:27 * hackagebot binary-file 0.4 - read/write binary file  http://hackage.haskell.org/package/binary-file-0.4 (YoshikuniJujo)
02:10:53 <fumieval> :t ()
02:10:54 <lambdabot> ()
02:11:00 <fumieval> just type.
02:11:35 <jbu> I don't really follow
02:11:41 <Saizan> jbu: () is the type with only one defined value, also called ()
02:12:05 <jbu> Ah, ok
02:12:08 <quchen> jbu: () ("Unit") is like a no-type in Haskell. The concept behind it is similar to void in other languages.
02:12:26 <quchen> It's basically "data Unit = Unit".
02:12:46 <jbu> Saizan: so in my example, is that just syaing that Foo takes no parameters in its constructor?
02:13:45 <quchen> To take your example, "data Blah = Foo Int" would mean that you can put all possible Int values in a Foo, which means many different numbers.
02:13:57 <quchen> If you change that to "Foo ()", then Foo can take all possible values of type ().
02:14:11 <quchen> Type () however has only one value, which is also called ().
02:14:37 <jbu> quchen: so basically Foo always takes in the unit value, and nothing else? essentially it takes no parameters? is that the correct way to think of it?
02:14:42 <supki> type () has 2 values
02:14:56 <quchen> supki: not now.
02:15:37 <quchen> jbu: Well, Foo takes no type parameters.
02:15:58 <quchen> But note that "Foo :: () -> Blah a"
02:16:05 <arbn> supki: You're thinking of undefined, or what?
02:16:14 <supki> yes
02:16:14 <quchen> arbn: yes
02:16:36 <quchen> jbu: So in order to construct a Blah-typed value, you have to invoke the Foo data constructor with ().
02:16:46 <jbu> quchen: gotcha, thanks
02:17:12 <quchen> jbu: () often means you're not interested in the result of something. For example,
02:17:15 <jbu> quchen: I'm not quite sure why I'd have to even pass "()" to the constructor instead of just not passing anything
02:17:16 <quchen> :t putStrLn
02:17:17 <lambdabot> String -> IO ()
02:17:34 <jbu> oh, I see
02:17:47 <quchen> putStrLn shouldn't return any value. What it's supposed to do is some sort of side effect.
02:17:56 <quchen> The result of a computation here is not interesting.
02:18:05 <arbn> jbu: You do, because you need a kind of *, and not * -> *
02:18:18 <quchen> On the other hand, getLine has type "IO String", because you're interested in an actual value as a result, not just some side stuff.
02:18:22 <quchen> :t getLine
02:18:24 <lambdabot> IO String
02:18:34 <sss_> Can I pattern match against an empty Data.Text?
02:18:53 <arbn> jbu: () is sometimes used when you need a concrete type, but don't really care what it is.
02:19:00 <quchen> sss_: I don't think you can pattern match with Text at all. Guards might be the way to go.
02:19:15 <sss_> quchen: ok, thank you
02:19:52 <quchen> sss_: foo text | empty text = DO_IF_EMPTY | otherwise = ...
02:19:54 <quchen> Something like that
02:20:06 <quchen> Eh, "empty" should've been "null"
02:21:45 <sss_> thanks
02:22:27 <jbu> ok thanks all
02:22:33 <jbu> more clear now :)
02:30:27 * hackagebot parsec3 1.0.0.5 - Monadic parser combinators  http://hackage.haskell.org/package/parsec3-1.0.0.5 (ChristianMaeder)
02:55:31 <madjestic> hey hpc, I am trying to work through your suggestions from yesterday, I've got the following piece of code, and I am getting a conflict error: http://hpaste.org/84472 .  Does it require other dependencies to make it work?
02:56:07 <madjestic> *dependencies -> extensions
03:03:55 <swi> Hello. i have a function lineSum x = (Just . show . sum) (read <$> words x::[Int]).  How can i make it error proof for i.e. if user input not numbers but some chars ?
03:04:00 <sopvop> heh, ghc with -O2 hangs on my trifecta parser
03:05:21 <supki> swi: don't use read, use reads
03:05:30 <usr1328> Can someone give me a hint on where to begin learning about modeling computation with the more known haskell typeclasses (functors, applicatives, monads, arrows)? Although I understand what each typeclass brings to the table, I just can't wrap my head around where each one should be used while the others would be overkill.
03:06:18 <arkeet> usr1328: have you seen the typeclassopedia?
03:07:48 <arkeet> swi: there is also readMaybe and readEither in Text.Read with recent versions of ghc
03:08:45 <arkeet> :t readMaybe
03:08:47 <lambdabot> Not in scope: `readMaybe'
03:08:53 <arkeet> lambdabot isn't on a recent enough version I guess.
03:08:54 <arkeet> :t readEither
03:08:56 <lambdabot>     Not in scope: `readEither'
03:08:56 <lambdabot>     Perhaps you meant one of these:
03:08:56 <lambdabot>       `readLitChar' (imported from Data.Char),
03:09:08 <arkeet> er
03:09:14 <arkeet> :t Text.Read.readMaybe
03:09:15 <lambdabot> Not in scope: `Text.Read.readMaybe'
03:09:27 <arkeet> right.
03:09:29 <supki> lambdabot is on 7.4
03:09:47 <arkeet> right, and those were introduced in base 4.6
03:12:23 <swi> supki: it's seems i dont understand your point about reads
03:13:48 <supki> > read "M" :: Int
03:13:50 <lambdabot>   *Exception: Prelude.read: no parse
03:13:53 <supki> > reads "M" :: [(Int, String)]
03:13:55 <lambdabot>   []
03:13:59 <supki> > reads "123" :: [(Int, String)]
03:14:01 <lambdabot>   [(123,"")]
03:14:33 <swi> hm
03:14:39 <alang> edwardk: hello
03:14:40 <supki> swi: in other words, it does not fail in runtime if user provides incorrect input
03:16:42 <arkeet> @let readMaybe s = case reads s of [(x,"")] -> Just x; _ -> Nothing
03:16:45 <lambdabot>  Defined.
03:17:11 <arkeet> > readMaybe "123" :: Maybe Int
03:17:14 <lambdabot>   Just 123
03:17:16 <arkeet> > readMaybe "blah" :: Maybe Int
03:17:18 <lambdabot>   Nothing
03:19:46 <swi> and if i don need Just at this point ?
03:20:16 <arkeet> then you'll have to deal with an error.
03:20:19 <Palmik> Hmm, if I have (foo :: Ord a => a -> a -> Bool), it should hold that if (compare a b == compare x y) then (foo a b == foo x y) (if we ignore things like overlapping instances, etc.). I feel that it should somehow follow from Yoneda's Lemma.
03:20:28 <Palmik> Is that right?
03:21:10 <swi> arkeet: Yes. And that was what i asked, how to deal with error in that situation ?
03:21:35 <arkeet> swi: you can't catch errors outside IO.
03:22:10 <arkeet> so to read stuff safely, you'll need to use something like reads or readMaybe
03:22:42 <swi> arkeet: hm. or i can use something like brackets in my 'do' block where i call this function ?
03:26:11 <arkeet> Palmik: well, parametricity gives you this: if x <= y == f x <= f y forall x and y, then foo x y = foo (f x) (f y)
03:27:15 <arkeet> @free foo :: (a -> a -> Bool) -> (a -> a -> Bool)
03:27:15 <lambdabot> (forall x. g x = h (f x) . f) => foo g y = foo h (f y) . f
03:27:31 <arkeet> take g = h = (<=) there
03:28:12 <arkeet> since a lawful dictionary for Ord a is equivalent to (a -> a -> Bool)
03:28:32 <arkeet> given by (<=)
03:30:22 <arkeet> I guess you could probably generalize a little.
03:30:53 <arkeet> yeah,
03:31:17 <arkeet> if f x <= f y = g x <= g y for all f and g, then foo (f x) (f y) = foo (g x) (g y)
03:31:43 <arkeet> Palmik: which implies your statement
03:31:43 <arkeet> :)
03:32:01 <arkeet> er
03:32:07 <arkeet> that should say, for all x and y.
03:35:02 <swi> arkeet: i think i understand you. Am i right that in case of using reads i can't write that my function as one-liner ? :)
03:35:20 <arkeet> swi: well it'll be a longer one-liner :p
03:36:09 <swi> arkeet: with a lambda's i think :)
03:36:31 <arkeet> well, you need to pattern match, so a case.
03:36:47 <swi> btw, what i can use instead of case  there ?
03:37:12 <arkeet> with reads? you don't.
03:37:30 <arkeet> well, you could do some messier thing to deconstruct the list and so on but then that would really make for a long line.
03:37:48 <Palmik> arkeet, how does it imply that (forall x, y, a, b . if (x <= y) = (a <= b) then (foo x y == foo a b))?
03:38:36 <arkeet> Palmik: do you agree that if f x <= f y = g x <= g y for all f and g, then foo (f x) (f y) = foo (g x) (g y)?
03:39:02 <arkeet> uhhh.
03:39:04 <arkeet> let's rename things.
03:39:13 <arkeet> er.
03:39:17 <arkeet> that should again be for all x and y.
03:39:19 <arkeet> not f and g.
03:39:31 <arkeet> anyway
03:39:40 <Palmik> No, honestly I'm not sure.
03:39:58 <arkeet> well it follows from a free theorem.
03:40:24 <arkeet> @free foo' :: (a -> a -> Bool) -> (a -> a -> Bool)
03:40:24 <lambdabot> (forall x. g x = h (f x) . f) => foo' g y = foo' h (f y) . f
03:40:32 <arkeet> in other words
03:40:58 <arkeet> (forall x y. g x y = h (f x) (f y)) => foo' g x y = foo' h (f x) (f y)
03:41:13 <arkeet> ok, let's stick with those names.
03:41:34 <arkeet> let g x y = k x <= k y, and h = (<=)
03:41:35 <Palmik> Ah, OK, if I take lambdabod's word for it (since I'm not sure how I would derive the theorem myself), then yes.
03:41:37 <arkeet> so that specializes to
03:41:59 <arkeet> hmm
03:42:03 <arkeet> uhhh
03:42:12 <arkeet> no
03:42:19 <arkeet> h x y = l x <= l y, and f = id.
03:42:25 <arkeet> I think.
03:42:26 <arkeet> no that's worse.
03:42:43 <arkeet> I haven't thought it through.
03:42:57 <arkeet> the point is that foo' (<=) is your foo.
03:43:11 <arkeet> so, from (forall x y. g x y = h (f x) (f y)) => foo' g x y = foo' h (f x) (f y)
03:43:19 <arkeet> take g = h = (<=), and foo = foo' (<=)
03:43:32 <arkeet> so (forall x y. x <= y = f x <= f y) => foo x y = foo (f x) (f y)
03:43:50 <arkeet> ok.
03:43:51 <Palmik> Yep, OK.
03:45:01 <arkeet> now suppose f :: Bool -> X, where X is your favourite type, let a = f False, and b = f True.
03:45:17 <arkeet> then forall x y. x <= y = f x <= f y is the same as a < b.
03:45:41 <arkeet> (here x and y are in Bool)
03:45:49 <arkeet> so:
03:46:09 <arkeet> yeah.
03:46:13 <solirc> So similar question to what I asked a couple of days ago:
03:46:24 <arkeet> if a < b, then you get stuff like
03:46:27 <solirc> `data Foo = Foo | Bar` is called a sum type, data `Foo = Foo String Int` is a product type, so how do we call `data Foo = Foo Int`?
03:46:29 <arkeet> foo False True = foo a b
03:46:39 <arkeet> foo False False = foo a a
03:46:41 <arkeet> and so on.
03:46:42 <solirc> singleton or something?
03:47:08 <Palmik> arkeet: OK, I will think about it, thanks.
03:47:32 <ski> solirc : i'd say `data' introduces sum-of-product types
03:47:33 <arkeet> but wait.
03:47:35 <arkeet> in particular:
03:47:39 <arkeet> if a < b and a' < b'
03:47:45 <arkeet> then foo a b = foo False True = foo a' b'
03:47:51 <solirc> ski: In general yes
03:47:53 <ski> solirc : so that's a sum-of-product with only one term, with only one factor
03:48:29 <dEPY> what are singleton lists?
03:48:32 <ski> conceptually, `Foo' just "happens" to have one alternative, with just one argument
03:48:46 <ski> (as opposed to a `newtype')
03:48:55 <solirc> ski: but we can call something like `data Foo = Foo` a unit type
03:49:06 <ski> dEPY : usually a list with exactly one element is meant
03:49:10 <arkeet> I'm not sure what happens when a == b.
03:49:29 <solirc> so wonder if there is a commonly understood term for something like `data Foo = Foo Int`
03:49:44 <arkeet> I suppose if you assume all your orderings are antisymmetric, then the same thing holds again.
03:49:45 <solirc> or newtype for that matter
03:49:46 <dEPY> ski: Tnx.
03:49:49 <arkeet> er
03:49:53 <arkeet> total orderings
03:49:59 <ski> solirc : i suppose (if you care about bottoms atm) you can call it the lifting of `Int'
03:50:14 <arkeet> where a == b is not (a < b || b < a)
03:50:46 <arkeet> Palmik: so I think the answer is "yes, if your Ord instances actually are total orderings."
03:51:14 <arkeet> hmm.
03:51:44 <swi> am i right: if i want to use pattern matching in function i need to: define it like foo somepather = ...;foor otherpather = ...; or use case. And in where block i can use only case version ?
03:52:00 <ski> solirc : in the `newtype' case, the idea is usually (but not always) that all valid values of the "contained" type are valid (distinct) values of the new type (and vice versa) -- so, usually you do a `newtype' for abstractness, or to get a recursive type, or to make an instance for some type class
03:52:19 <arkeet> swi: in a where block you can write function declarations.
03:52:24 <arkeet> well, declarations.
03:52:39 <arkeet> well, definitions.
03:52:46 <arkeet> which can use case if you want.
03:53:32 <swi> em.. foo :: a -> a it declaration ?
03:53:43 <ski> (in the "abstract data type" case, sometimes you want only some values of the representation type to be valid as values for the abstract type (corresponding to a subset), and sometimes you want distinct representation values to represent the same abstract value (corresponding to a quotient/factor set))
03:53:56 <arkeet> swi: there needs to be a corresponding equation though.
03:54:02 <ski> solirc : .. not sure how much this helps
03:54:13 <Palmik> arkeet: OK, the reason I was asking is that I wanted to show that (Ord x => x -> x -> Bool) is iso with (Bool, Bool, Bool)... I think I have the right morphisms (functions), but I could not prove one of the identities (see here: http://hpaste.org/84475)
03:54:46 <solirc> ski: I'm really not puzzled about the use cases, but I'm just looking for a short descriptive name ;)
03:55:01 <yitz> swi: you can use pattern matching anywhere you define a function - top level, inside a where or let block, or in a lambda expression.
03:55:16 <arkeet> Palmik: sure, so this free theorem would help with that.
03:55:28 <ski> solirc : perhaps "lifting" or "wrapping", or something along that line
03:55:31 <arkeet> Palmik: also, in the definition of iso1, you don't need to compare things in Ordering :p
03:55:51 <solirc> ski: yeah, wrapping sounds good :)
03:56:06 <yitz> swi: you can also use pattern matching in a "pattern binding" in a let or where block, e.g.: x:xs = [1..]
03:56:30 <yitz> swi: and finally, of course, in a case expression.
03:56:55 <swi> yitz: so case kind of syntax version for per-line pat.match ?
03:57:02 <arkeet> Palmik: but I imagine that iso2 . iso1 = id might fail if our Ord instances aren't nice enough.
03:58:08 <dEPY> I made it trough 2 chapters of learn you a haskell. I'm actually proud of my self because I've been so unproductive lately. :)
03:58:10 <Palmik> arkeet: Yeah, I guess it would still work, but I wanted the morhisms to have the form iso1 : A -> B and iso2 : B -> A.
03:58:18 <arkeet> sure they do.
03:58:36 <yitz> swi: case can go anywhere inside any expression, regardless of lines. you could have as many case expressions as you want even on a single line (but you probably don't want that)
03:58:47 <Palmik> arkeet: I kind of assume that the definition of the Ord instance is not bogus.
03:58:50 <arkeet> :p
03:59:02 <arkeet> in that case I think you're safe.
03:59:25 <swi> yitz: but seems like in my example, as arkeet says and as i see, i can't drop case
04:00:06 <Palmik> arkeet: I probably misunderstood your comment on iso2, you probably meant that I could have used 0 1 2 instead of LT EQ GT (for example), right?
04:00:18 <yitz> swi: there was a period of time where i didn't like case, so i never used it, ever. i got over that, but anyway...
04:00:20 <arkeet> you could cmp 0 1, cmp () (), cmp 'b' 'a' if you wanted.
04:00:26 <Palmik> Even True False would do.
04:00:32 <Palmik> Yeah.
04:00:35 <arkeet> I would lean toward bool, yeah.
04:01:26 <hpaste> “Anonymous Coward” pasted “swi” at http://hpaste.org/84476
04:01:31 <yitz> swi: sorry i didnt see your example. did you paste something?
04:01:45 <swi> yitz: 15:01 < hpaste> “Anonymous Coward” pasted “swi” at http://hpaste.org/84476
04:02:16 <swi> this one right after arkeet explain me how to make function works even if user input not numbers
04:02:59 <arkeet> :t sum . catMaybes . map readMaybe . words
04:03:01 <lambdabot> (Num b, Read b) => String -> b
04:03:16 <arkeet> > sum . catMaybes . map readMaybe . words $ "a 1 hello 2 3"
04:03:19 <lambdabot>   6
04:03:36 <hpaste> yitz annotated “swi” with “swi (annotation)” at http://hpaste.org/84476#a84477
04:03:43 <yitz> for example
04:04:10 <swi> yitz: aaahh! i see
04:04:19 <arkeet> I prefer the original.
04:04:29 <swi> :t catMaybes
04:04:31 <lambdabot> [Maybe a] -> [a]
04:04:39 <arkeet> or at least we shouldn't call yitz's thing readInt.
04:04:44 <haskellhero> hi
04:04:48 <arkeet> hmm
04:05:00 <yitz> arkeet: indeed, readInt usually doesn't mean what i wrote, it would be a little confusing.
04:05:11 <arkeet> :t MaybeT
04:05:12 <lambdabot> Not in scope: data constructor `MaybeT'
04:05:16 <arkeet> oh great.
04:05:27 <arkeet> :t Control.Monad.Trans.Maybe.MaybeT
04:05:28 <lambdabot> m (Maybe a) -> Control.Monad.Trans.Maybe.MaybeT m a
04:05:30 <arkeet> :t Control.Monad.Trans.Maybe.runMaybeT
04:05:31 <lambdabot> Control.Monad.Trans.Maybe.MaybeT m a -> m (Maybe a)
04:05:38 <arkeet> @let maybeT = Control.Monad.Trans.Maybe.MaybeT
04:05:39 <lambdabot>  <local>:19:10:
04:05:39 <lambdabot>      Not in scope: data constructor `Control.Monad.Trans.Mayb...
04:05:43 <arkeet> uhh
04:06:03 <swi> arkeet: actualy i have ghc 7.4 too :)
04:07:01 <arkeet> MaybeT isn't what I wanted anyway.
04:08:36 <arkeet> :t foldr (maybe id (:))
04:08:37 <lambdabot> [a] -> [Maybe a] -> [a]
04:08:40 <arkeet> :t foldr (maybe id (:)) []
04:08:41 <lambdabot> [Maybe a] -> [a]
04:08:48 <arkeet> works.
04:09:04 <swi> another thing i dont like about my line is a brackets :) i dont line them :)
04:10:07 <yitz> lineSum x = Just . show . sum . map readInt $ words x
04:13:05 <swi> yitz: in that case reads must be in readInt (so case) ?
04:13:11 <yitz> in which case it might as well be: lineSum = Just . show . sum . map readInt . words
04:13:28 <yitz> swi: right i'm back to your original
04:14:50 <yitz> swi: well with that readInt you could get rid of the case by defining another function, but you might as well stick with case then.
04:15:45 <swi> yitz: map readInt . words ?? why there . ?
04:16:24 <yitz> swi: first divide into words, then make them ints, then sum them, then make them strings, then wrap them in Just.
04:16:41 <yitz> wrap *it
04:16:59 <swi> i mean map function get function to wrap and a list
04:17:06 <swi> list is ommited here
04:17:13 <swi> ahh
04:17:15 <swi> sorry :)
04:17:15 <yitz> swi: yep.
04:17:52 <yitz> currying
04:18:04 <arkeet> :t prism'
04:18:06 <lambdabot> (Applicative f, Choice p) => (a -> s) -> (s -> Maybe a) -> p a (f a) -> p s (f s)
04:18:14 <arkeet> :t prism' show readMaybe
04:18:15 <lambdabot> (Read a, Show a, Applicative f, Choice p) => p a (f a) -> p String (f String)
04:18:30 <ocharles> :i Choice
04:18:43 <ocharles> ok, guess lambdabot doesn't know what :i means
04:19:03 <swi> yitz: but i can't set reads in this line
04:19:06 <arkeet> @let blah = prism' show readMaybe
04:19:08 <lambdabot>  Defined.
04:19:11 <yitz> @info Choice
04:19:11 <lambdabot> Choice
04:19:20 <ocharles> heh
04:19:31 <yitz> ocharles: i guess it doesn't know much more about what @info means, either
04:19:54 <yitz> arkeet: that's a cool lens combinator
04:20:08 <arkeet> > "a 12 b 3" ^.. to words . traverse . blah
04:20:10 <lambdabot>   []
04:20:12 <arkeet> hmm
04:20:16 <ocharles> prisms are great
04:20:24 <arkeet> > "a 12 b 3" ^.. to words . traverse . blah :: [Int]
04:20:26 <lambdabot>   [12,3]
04:20:55 <arkeet> :t iso
04:20:57 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
04:21:11 <arkeet> @let _words = iso words unwords
04:21:13 <lambdabot>  Defined.
04:21:23 <arkeet> @let _read = prism' show readMaybe
04:21:25 <lambdabot>  Defined.
04:21:33 <arkeet> > "a 12 b 3" & to words . traverse . _read +~ 1
04:21:34 <lambdabot>   No instance for (Control.Lens.Internal.Getter.Gettable
04:21:34 <lambdabot>                     ...
04:21:41 <arkeet> > "a 12 b 3" & _words . traverse . _read +~ 1
04:21:43 <lambdabot>   can't find file: L.hs
04:21:45 <arkeet> > "a 12 b 3" & _words . traverse . _read +~ 1
04:21:47 <lambdabot>   "a 13 b 4"
04:21:59 <arkeet> help
04:22:11 <yitz> > let readMany = unfoldr $ listToMaybe . concatMap reads . tails in readMany "a 12 b 3" :: [Int]
04:22:13 <lambdabot>   [12,3]
04:23:02 <arkeet> :t from _read
04:23:04 <lambdabot> (Functor f, Read b, Show b, Profunctor p, Choice (Control.Lens.Internal.Iso.Exchange b b)) => p String (f String) -> p b (f b)
04:23:08 <arkeet> uhh
04:23:12 <yitz> lenses are cool, but life was good before them, too.
04:23:18 <arkeet> > 5 ^. from _read
04:23:19 <lambdabot>   No instance for (Data.Profunctor.Choice
04:23:19 <lambdabot>                     (Control.Lens.I...
04:23:22 <arkeet> figures.
04:23:24 <arkeet> :t re _read
04:23:26 <lambdabot> (Read b, Show b, Gettable f) => (String -> f String) -> b -> f b
04:23:27 <sipa> just a bit more vague
04:24:21 <yitz> sipa: vague? what's vague about i wrote? especially compared to the line-noise version in lenses
04:24:33 <arkeet> line-noise :(
04:25:03 <yitz> i know, there is some logic to this line noise, but there is definitely a learning curve.
04:25:10 <hpaste> swi pasted “new version” at http://hpaste.org/84479
04:25:20 <arkeet> @let _unsafeShow = iso show read
04:25:22 <lambdabot>  Defined.
04:25:25 <arkeet> > 5 ^. _unsafeShow
04:25:27 <lambdabot>   Ambiguous type variable `t0' in the constraint:
04:25:27 <lambdabot>    (GHC.Read.Read t0) arisi...
04:25:31 <arkeet> err
04:25:34 <arkeet> :t _unsafeShow
04:25:36 <lambdabot> (Functor f, Read t, Show s, Profunctor p) => p String (f String) -> p s (f t)
04:25:48 <arkeet> great.
04:25:52 <arkeet> :t iso'
04:25:53 <lambdabot>     Not in scope: iso'
04:25:53 <lambdabot>     Perhaps you meant `iso' (imported from Control.Lens)
04:26:14 <arkeet> @let _show = iso show read :: (Read s, Show s) =>  Iso' s String
04:26:17 <lambdabot>  Defined.
04:26:18 <arkeet> > 5 ^. _show
04:26:20 <lambdabot>   "5"
04:26:40 <arkeet> > 123 & _show %~ reverse I still think this is disgusting.
04:26:42 <lambdabot>   <hint>:1:57: parse error (possibly incorrect indentation)
04:26:42 <arkeet> > 123 & _show %~ reverse -- I still think this is disgusting.
04:26:44 <lambdabot>   321
04:26:52 <arkeet> :p
04:27:03 <ion> That should have been a prism.
04:27:15 <arkeet> I made a prism going the other way.
04:27:18 <arkeet> :t _read
04:27:19 <lambdabot> (Read a, Show a, Applicative f, Choice p) => p a (f a) -> p String (f String)
04:27:24 <arkeet> but we can't use it for that.
04:27:45 <arkeet> :t _read :: (Read a, Show a) => Prism' String a
04:27:47 <lambdabot> (Read a, Show a, Applicative f, Choice p) => p a (f a) -> p String (f String)
04:27:51 <arkeet> ..
04:28:49 <arkeet> I find it weird how the argument orders for iso and prism are not consistent.
04:28:59 <arkeet> prism puts the getter second, iso puts it first.
04:29:08 <arkeet> er
04:29:10 <arkeet> :t prism
04:29:11 <lambdabot> (Applicative f, Choice p) => (b -> t) -> (s -> Either t a) -> p a (f b) -> p s (f t)
04:29:21 <arkeet> not getter.
04:29:37 <arkeet> I mean prism puts the reviewer first, iso puts it second.
04:29:47 <arkeet> :t iso
04:29:49 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
04:29:53 <arkeet> the b -> t.
04:30:44 <arkeet> oh well
04:31:08 <arkeet> I need sleep.
04:31:35 <yitz> arkeet: in iso both of the first two arguments are reviewers, aren't they?
04:32:05 <swi> brr..
04:32:08 <swi> :t putStrLn
04:32:10 <lambdabot> String -> IO ()
04:32:16 <yitz> oh oh what's with preflex
04:32:39 <swi> @putStrLn "Foo" ++ "Bar"
04:32:39 <lambdabot> Unknown command, try @list
04:32:48 <swi> > putStrLn "Foo" ++ "Bar"
04:32:50 <lambdabot>   Couldn't match expected type `GHC.Types.IO ()'
04:32:50 <lambdabot>              with actual typ...
04:33:02 <swi> :t "Foo" ++ "Bar"
04:33:04 <lambdabot> [Char]
04:33:14 <arkeet> :t putStrLn ("Foo" ++ "Bar")
04:33:15 <lambdabot> IO ()
04:33:34 <swi> arkeet: but why ?
04:33:37 <arkeet> why what?
04:33:57 <swi> putStrLn get String as parameter and return IO()
04:34:07 <swi> why it' need (string) ?
04:34:20 <srhb> Because it needs that which it is supposed to print.
04:34:23 <arkeet> what you wrote parses as (putStrLn "Foo") ++ "Bar"
04:34:35 <arkeet> which makes no sense.
04:34:42 <swi> damn
04:34:45 <swi> silly me
04:34:52 <srhb> swi: Function application binds very tightly.
04:34:53 <swi> i forgot that ++ is a function
04:35:01 <srhb> Operators less so.
04:35:21 <swi> thanks a lot guys :)
04:47:53 <bobry> Hello, is there a way _not_ to write constraints for 'bar' explicitly, since they are fixed by the use of 'Foo"? example: http://paste.in.ua/8121
04:48:45 <Botje> bobry: yeah, haskell data constructors don't work nicely with type classes like that :/
04:52:32 <bobry> Botje: I hoped there's some magical GHC extension, I'm missing :)
04:53:30 <Botje> you'll have to wait for the DoWhatIMean extension :P
04:53:57 <Philonous> Botje:  Even then, ghc would have to invent the type class dictionary out of thin air
04:54:17 <Philonous> Botje:  So it would at least to be -XBlackMagic
04:58:16 <Philonous> bobry:  This extension can not exist. Your type for the function "bar" says it will accept any argument of type a and c whatsoever, but when you pattern match on Foo you get values back out that somehow have a class dictionary associated with them.
04:58:45 <bobry> Philonous: I see, thanks.
04:59:33 <Philonous> bobry:  It would be nice though if you could give a partial type (with type holes). Like bar :: (??) => a -> c -> Foo a c. Unfortunately that doesn't exist.
04:59:49 <bobry> Yup, that the syntax I was asking about :)
05:03:24 <Hermit> has anyone successfully built wxcore lately? (it's driving me nuts here: http://dpaste.com/1031212)
05:04:36 <Hermit> libwxc.so exists in ~/.cabal/lib/wxc-0.90.0.4/ghc-7.4.1/
05:04:51 <hpaste> Rob pasted “Rigid type varialbes with forall” at http://hpaste.org/84481
05:05:24 <robstewartuk> Hi, I'm unsure how to correctly use forall for data constructors. See http://hpaste.org/84481
05:05:44 <robstewartuk> That hpaste does not compile.
05:06:29 * robstewartuk has updated the hpaste http://hpaste.org/edit/84481
05:06:38 <robstewartuk> with the rigid type error.
05:07:32 <robstewartuk> My question boils down to a better need to understand forall a. before a data constructor. Help?
05:09:08 <srhb> What do you intend for that forall to mean?
05:11:01 <robstewartuk> I'm thinking of Foo to be a very simple API, with a field f that can have any time... hm... let me update with a better example.
05:11:08 <robstewartuk> one sec.
05:14:10 <hpaste> Rob revised “Rigid type varialbes with forall”: “forall rigid type” at http://hpaste.org/84481
05:15:16 <robstewartuk> srhb: In the revised hpaste, I am wanting Foo to be a simple API, that can be instantiated with f as a Data.Map with any types for its key nd its value.
05:15:22 <robstewartuk> s/nd/and/
05:18:05 <parcs> robstewartuk: why are you using existentials?
05:21:19 <hpaste> Rob revised “Rigid type varialbes with forall”: “fixed: bound rigid type variables with forall” at http://hpaste.org/84481
05:21:30 <robstewartuk> parcs: excellent question. Doh. This works http://hpaste.org/84481
05:21:37 <robstewartuk> thanks.
05:22:14 <srhb> It seems whenever people have a problem and decide to use Existential Quantification, they end up with two problems. :P
05:25:46 * hackagebot hen 0.0.0 - Haskell bindings to Xen hypervisor interface  http://hackage.haskell.org/package/hen-0.0.0 (FedorGogolev)
05:27:10 <hpaste> Rob revised “Rigid type varialbes with forall”: “wildcards in record patterns” at http://hpaste.org/84481
05:27:32 <swi> Can i compile my haskell programm on my machine so, that it run on another machine (i.e. another distro) ?
05:27:52 <robstewartuk> srhb: parcs: new problem. http://hpaste.org/84481 . I cannot use wildcards in a recod pattern, for MyFoo.
05:28:16 <swi> i'v learn about -optl-static but stack with 'kernel too old' on dest. machine
05:37:11 <hpaste> Rob revised “Rigid type varialbes with forall”: “fixed: Rigid type varialbes with forall” at http://hpaste.org/84481
05:39:37 <quchen> Is there a way I can make Djinn understand lists?
05:40:03 <quchen> It doesn't seem to know [a], and "List a = Nil | Cons a (List a)" is recursive and seems not to be allowed.
05:42:04 <srhb> No, it is indeed recursive, afaik.
05:42:58 <quchen> And Djinn doesn't have a special list hook in it somewhere? Arrrr :-(
05:43:52 <srhb> I don't think so. :/
05:44:12 <quchen> But I can't sell callCC to strangers!
05:44:22 <quchen> elem would make a much nicer example :-(
05:44:48 <srhb> :P
05:45:12 <quchen> Would you know some nice example I can give to an imperative person?
05:45:33 <quchen> Like "hey I don't need to know how to write this because it has a unique proof"
05:46:40 <srhb> Hum. Things like functor instances are almost unique, are they not?
05:46:55 <quchen> Yeah, but then Functors are already too haskelly
05:46:58 <srhb> Ah.
05:46:58 <elliott> a law-abiding Functor instance is unique
05:46:59 <quchen> Bind for Maybe also works
05:47:08 <elliott> if you ignore laws, very ununique :P
05:47:13 <srhb> Yeah.
05:47:28 <elliott> quchen: you may be able to model a list as ((a -> r -> r) -> r -> r)
05:47:31 <elliott> depending on the situation
05:47:33 <aleator_> Traversals?
05:47:40 <elliott> (you really want a "forall r." there, but djinn can't do that)
05:47:59 <quchen> elliott: I'm trying to find a good example of why Djinn/proofs are useful in programming to give to someone who knows only imperative languages.
05:48:09 <quchen> That constrains the possible functions a lot.
05:48:19 <srhb> Yeah, but really, do you find Djinn that useful?
05:48:24 <srhb> Aside from your own mental Djinn :-)
05:48:39 <quchen> srhb: It's not about Djinn per se, but about what makes types so useful.
05:48:49 <srhb> How about composition then
05:48:57 <quchen> You can't start giving explanations with type holes etc
05:49:18 <srhb> @djinn (b -> c) -> (a -> b) -> a -> c
05:49:18 <lambdabot> f a b c = a (b c)
05:50:06 <quchen> Alright, the backstory: I just told a colleague that I started reading this book about type theory, and tried explaining why it is relevant (background) knowledge. I then gave the examples of "id" and "const", but then he said he understands that, but would like to see a nontrivial example.
05:50:33 <quchen> So now I'm looking for some code that may be useful in an imperative setting, but that I can simply have Djinn write for me based on telling it "what I mean" instead of "how to".
05:50:52 <srhb> How about stateful computations
05:50:57 <srhb> Can't Djinn work some magic there?
05:51:13 <elliott> I mainly find Djinn useful for deriving highly abstract code.
05:51:13 <quchen> Yes. But imperative languages don't have "s -> (a, s)". ;-(
05:51:18 <elliott> like the monad instances for State and Cont.
05:51:28 <quchen> elliott: Cont is about as functional as it gets
05:51:28 <srhb> I'm not sure Djinn is very useful for imperative things. :/
05:51:40 <quchen> That will give me the "this is academic blabla" look
05:51:45 <elliott> and sometimes lens-related stuff (as in, when coming up with new representations for lenses, not when working with lenses as they exist themselves), which is even less relatable :P
05:51:49 <srhb> Or we'd have Djinn for C :P
05:51:53 <amyers> quchen: Which book?
05:52:00 <elliott> quchen: I don't think you'll be able to convince anyone of Djinn's utility unless they're sold on FP
05:52:01 <parcs> robstewartuk: you can't? what error are you getting?
05:52:10 <elliott> I'd say its main use is impressing beginners, honestly
05:52:11 <quchen> amyers: thompson - type theory and functional programming
05:52:24 <robstewartuk> I can now, I modifed the hpaste
05:52:26 <quchen> amyers: If you can recommend another one let me know
05:52:42 <quchen> amyers: (It's not bad so far, but comparison is always nice)
05:52:48 <amyers> quchen: I'm working my way through types and programming languages
05:53:06 <quchen> amyers: Is that a book title or a sentence? :-)
05:53:07 <amyers> quchen: It's the first book on type theory that I've read.  I was curious what else Haskell folks were reading
05:53:14 <parcs> robstewartuk: oh ok
05:53:27 <amyers> quchen: haha sorry,, title is "Types and Programming Languages"
05:53:51 <quchen> amyers: I'm just an amateur (in the classical sense), so I just picked the next best match that seemed decent. Nobody with actual knowledge recommended me this one (or any other).
05:53:55 <amyers> quchen: by Benjamin Pierce
05:54:04 <amyers> quchen: Ah, same here
05:54:04 <quchen> amyers: Thanks, I'll have a look at it
05:54:12 <amyers> quchen: Likewise
05:54:36 <quchen> amyers: thompson is available for free, just search for it
05:55:07 <amyers> quchen: Ah good, my search on amazon turned up a copy for $250 so I was a bit discouraged
05:55:25 <quchen> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
05:55:29 <quchen> "Out of print"
05:55:38 <quchen> So you're looking at an antique book at Amazon ;-)
05:55:52 <quchen> The link above includes a PDF version though
05:55:56 <amyers> Just found that page, odd the link color looks like I've visited here but I don't remember it
05:57:13 <quchen> amyers: Fun fact: I downloaded it yesterday only to find out that I already had it
05:57:18 <quchen> So basically the same thing :-)
05:57:50 <amyers> quchen: haha same here, I went to my downloads directory to mv the one I just downloaded and there are two copies
05:58:05 <aleator_> BTW. Does djinn intentionally try to use all function arguments. I was rather surprised that it got b -> Maybe b -> b correct
05:58:41 <elliott> it does, yes
05:59:03 <parcs> @djinn Maybe a -> Maybe a -> a -> a
05:59:03 <lambdabot> f a b c =
05:59:04 <lambdabot>     case a of
05:59:04 <lambdabot>     Nothing -> c
05:59:04 <lambdabot>     Just d -> case b of
05:59:04 <lambdabot>               Nothing -> d
05:59:05 <lambdabot>               Just e -> e
05:59:35 <aleator_> Thats almost scary :)
06:00:24 <quchen> Scary? I'll show you scary: bind for Cont
06:00:26 <quchen> @djinn ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
06:00:26 <lambdabot> f a b c = a (\ d -> b d c)
06:00:55 <aleator_> quchen: Isn't that pretty much unique solution for that type?
06:01:02 <quchen> aleator_: Exactly.
06:01:16 <quchen> aleator_: Ever tried writing that one yourself? It drove me mad one afternoon.
06:01:37 <aleator_> I did that. Then I made my students do it after I did and it drove them crazy :)
06:01:54 <quchen> Hehe, the teacher bonus :D
06:02:02 <aleator_> :)
06:02:09 <parcs> @djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
06:02:09 <lambdabot> f a b = a (\ c _ -> b c) b
06:02:09 <quchen> You're teaching Haskell?
06:02:14 <parcs> callCC ^
06:02:30 <quchen> parcs: Speaking of callCC: Can you explain to me what it does?
06:02:42 <quchen> I understand >>=, but callCC is a mystery
06:02:49 <aleator_> quchen: The maybe thing has many possible solutions and djinn gets the right one. Thats scary
06:03:14 <parcs> :t callCC
06:03:16 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
06:03:16 <quchen> aleator_: Yeah, but that's heuristics I guess
06:04:14 <elliott> quchen: I wrote a long rambly explanation of Cont/callCC which may or may not help you: http://stackoverflow.com/questions/9050725/call-cc-implementation/9050907#9050907
06:04:39 <parcs> quchen: it passes a function to its argument that contains the continuation of the outer scope so that when called, it effectively short circuits the inner continuation
06:04:49 <quchen> If it's on SO I've probably already read it ;-)
06:05:54 <quchen> parcs: Let me try to deconstruct that slowly.
06:06:29 <quchen> So "... -> m a" is clear, the result is a continuation.
06:06:29 <parcs> @src callCC
06:06:30 <lambdabot> Source not found.
06:06:42 <quchen> f a b = a (\ c _ -> b c) b
06:06:53 <quchen> Let's leave the newtypes away :-)
06:07:36 <quchen> Now callCC's argument, "((a -> b) -> a)", is what?
06:08:49 <parcs> it's a function whose first argument is a Cont action that contains the continuation for the thing after 'callCC'
06:10:00 <quchen> "a -> b" is a cont action? Isn't it just some generic function?
06:10:14 <quchen> Or by "cont action" do you mean the "a -> b" in "(a -> b) -> b"
06:10:16 <parcs> it's ((a -> Cont r b) -> Cont r a)
06:10:17 * elliott thinks the newtype helps here.
06:10:39 <elliott> note that an arguably more correct type is callCC :: ((forall b. a -> m b) -> m a) -> m a. that also may or may not help.
06:10:43 <quchen> Oh, right, I thought the m was a transformer m so I set it to Identity
06:10:45 <elliott> er, with the MonadCont m constraint.
06:11:48 <quchen> Well,
06:11:48 <quchen> callCC :: ((a -> ContT r m b) -> ContT r m a) -> ContT r m a
06:11:50 <quchen> callCC f = ContT $ \c -> runContT (f (\a -> ContT $ \_ -> c a)) c
06:12:12 <quchen> That just wipes the floor with my brain :-(
06:12:16 <parcs> in the implementation of callCC, notice which function parameter is ignored
06:13:04 <parcs> :t ContT
06:13:05 <lambdabot> ((a -> m r) -> m r) -> ContT r m a
06:13:25 <parcs> :t let callCC f = ContT $ \c -> runContT (f (\a -> ContT $ \_ -> c a)) c in callCC
06:13:26 <lambdabot> ((a -> ContT r m a1) -> ContT r m a) -> ContT r m a
06:13:29 <parcs> :t let callCC f = ContT $ \c -> runContT (f (\a -> ContT $ \k -> k a)) c in callCC
06:13:30 <lambdabot> ((a1 -> ContT r1 m1 a1) -> ContT r m a) -> ContT r m a
06:14:15 <quchen> I'll read elliott's SO answer again and see if that helps
06:14:27 <elliott> I wouldn't bet on it :P
06:14:56 <parcs> callCC is a tricky beast. it took me many months of frequent tinkering and staring at its definition to finally understand it
06:15:28 <quchen> parcs: Well great. I arguably don't really understand >>= either.
06:15:40 <quchen> I mean I know how to use it but I've given up numerous times trying to understand why
06:15:53 <quchen> ... it looks the way it does
06:16:00 <parcs> quchen: the special thing about the function that gets passed to 'f' is that it ignores its own continuation and instead calls the 'outer' continuation
06:16:46 <parcs> the 'outer' continuation is of course what the action that follows the call to 'callCC', i.e. callCC (\exit -> ...) >> action_that_follows
06:17:27 <quchen> parcs: So it basically inserts an "f" in your Cont chain, branching out its own version of it?
06:18:58 <parcs> it inserts a "subcontinuation" in your Cont chain that has a way to short circuit itself
06:19:57 <quchen> Okay. What do you mean by short circuit here though?
06:20:13 <quchen> Can callCC jump out of the entire continuation or something?
06:21:02 <parcs> it can jump out of the inner continuation or action at any time
06:22:13 <quchen> Oh, so it is like "Hold on original continuation, I'm making a subcontinuation here and then get back to you"?
06:22:33 <quchen> So callCC can short-circuit *without* terminating the outer continuation?
06:22:36 <parcs> yeah
06:22:40 <quchen> Aaaaaaaah!
06:23:09 <quchen> I see. If I put some ">>= continuation" thing in the middle of my continuation, if that short-circuited, my whole continuation would do.
06:23:23 <quchen> If I do the same with callCC, only the corresponding block short-circuits.
06:23:33 <quchen> ..?
06:24:50 <quchen> So in imperative speech: using callCC, I can do something like "continue" in imperative loops.
06:24:59 <quchen> The innermost thing is abandoned, but not the entire construct
06:25:08 <parcs> yeah, and you can also implement 'break'
06:25:18 <quchen> If I had used (imperative) return, the whole rest of the block would be discarded
06:25:45 <quchen> Wonderful!
06:25:53 <quchen> I think I'm a lot closer to getting it now :-D
06:25:56 <parcs> right, 'return' in imperative languages is like callCC as well
06:26:26 <johnw> how do you implement 'continue' with callCC?  break I get
06:26:41 <quchen> johnw: Right, I meant break above
06:26:46 <johnw> ah
06:26:58 <quchen> parcs: imperative return is more like no callCC I think.
06:27:07 <quchen> I mean if you reach return once, you're done with the procedure.
06:27:09 <parcs> johnw: callCC $ \break -> forM_ [1..100] $ \i -> callCC $ \continue -> ....
06:27:21 <johnw> parcs: ah, right on you
06:27:31 <johnw> it's just a break in the inner block
06:27:46 <parcs> quchen: right, and that's exactly what callCC helps you do
06:28:33 <quchen> Levelup! :-)
06:28:40 <parcs> let my_imperative_program = callCC $ \ret -> do a <- thing_a; b <- thing_b; if a == "hello" then ret b else do c <- thing_c; ret c
06:29:02 <parcs> well that's a bad example
06:29:18 <parcs> let my_imperative_program = callCC $ \ret -> do a <- thing_a; b <- thing_b; when (a == "hello") (do ret b); c <- thing_c; ret c
06:30:15 <johnw> I like ret =<< thing_c in those cases
06:30:16 <parcs> int my_imperative_program() { a = thing_a(); b = thing_b(); if (a == "hello") { return b }; c = thing_c(); return c; }
06:30:29 <quchen> Neat.
06:34:21 <t7> int my_imperative_program() { return thing_a() == "hello" ? return thing_b() : return thing_c(); }
06:34:52 <t7> idiot
06:34:57 <t7> dont need those returns
06:35:09 <parcs> three returns eh
06:35:31 <quchen> parcs: So let me sum this up: callCC takes the current continuation, and hides in its little own house. It then does ordinary continuation stuff, and when it's done, the result is a continuation that it brings back to the outside world.
06:35:35 <quchen> It's like a continuation sandbox.
06:35:49 * hackagebot bitset 1.2 - A compact functional set data structure.  http://hackage.haskell.org/package/bitset-1.2 (SergeiLebedev)
06:36:04 <quchen> (Yes, it's a little silly, but I'm still trying to find a nice way of picturing it.)
06:36:46 <parcs> kinda
06:38:24 <parcs> note that the implementation of the (a -> Cont r b) callback is almost identical to the implementation of 'return :: a -> Cont r a', except that it doesn't apply its argument to its own continuation, but rather to the continuation that corresponds to the stuff that comes after callCC.
06:39:33 <quchen> Riiight! callCC has its own full continuation stored, but it supplies it with the exterior continuation. It simply discards its own continuation starting point.
06:39:41 <parcs> :t let callCC f = ContT $ \c -> runContT (f return) c in callCC -- this definition is simple enough, isn't it?
06:39:43 <lambdabot> Monad m1 => ((a1 -> m1 a1) -> ContT r m a) -> ContT r m a
06:40:14 <parcs> :t {- now inline return -} let callCC f = ContT $ \c -> runContT (f (\a -> ContT $ \k -> k a) c in callCC
06:40:16 <lambdabot> parse error on input `in'
06:40:27 <parcs> :t {- now inline return -} let callCC f = ContT $ \c -> runContT (f (\a -> ContT $ \k -> k a)) c in callCC
06:40:28 <lambdabot> ((a1 -> ContT r1 m1 a1) -> ContT r m a) -> ContT r m a
06:40:47 <parcs> :t {- now instead of calling k, call the outer continuation, c -} let callCC f = ContT $ \c -> runContT (f (\a -> ContT $ \k -> c a)) c in callCC
06:40:48 <lambdabot> ((a -> ContT r m a1) -> ContT r m a) -> ContT r m a
06:40:53 <parcs> and there you have it
06:40:55 <quchen> I didn't see the inlined return there before, but it makes sense
06:41:02 <quchen> I wish I could send you flowers ;-)
06:42:07 <wuttf> Anyone knows how can I solve the "commitBuffer: invalid argument (invalid character)" problem with hakyll, on win?
06:42:23 <wuttf> faq only mentions nix solution
06:44:21 <wuttf> to be honest I can't even save unicode text in files, for example: main = writeFile "test11.txt" "óúűyőö" becomes ˘Łűy‹” in file
06:45:12 <quchen> parcs: And this "\_ -> c a" part also explains the "forall b. a -> Cont r b" in the type
06:45:46 <quchen> Is the forall necessary though? What kind of abuse does it prevent?
06:45:50 <parcs> quchen: right, since the inner continuation is ignored, the second argument to Cont doesn't unify with any type
06:45:57 <parcs> second type argument
06:46:14 <quchen> Right, otherwise callCC would depend on b
06:46:19 <parcs> quchen: oh, you mean ((forall b. a -> Cont r b) -> Cont r a) -> Cont r a ?
06:46:25 <quchen> Yes
06:47:11 <parcs> quchen: it lets you use callCC in multiple places within the inner continuation, specifically in places where the types may differ
06:47:35 <quchen> So the continuation I'm starting with has to be agnostic about its final value, as it is discarded anyway?
06:47:38 <srhb> wuttf: Are you sure you saved that source file in UTF8?
06:48:16 <parcs> quchen: well no, the final value of the continuation you're starting with is 'a'
06:48:30 <parcs> and the inner continuation ought to have the same final value
06:49:01 <wuttf> srhb: Yes UTF-8 without BOM, however, notepad says in right bottom corner "ANSI AS UTF-8"
06:49:12 <parcs> but since the callback (a -> m b) can short circuit the inner continuation from anywhere within the inner continuation, it ought to unify with any expected type
06:50:04 <parcs> > callCC $ \exit -> (if True then exit () else return 'a') >> (if True then exit () else return "hello") -- this should work but doesn't because callCC is not rank-3
06:50:06 <lambdabot>   Couldn't match expected type `()' with actual type `GHC.Types.Char'
06:50:22 <aCube> :t (<&>)
06:50:24 <lambdabot> Functor f => f a -> (a -> b) -> f b
06:50:31 <quchen> aCube: flip <$>
06:50:43 <aCube> quchen: I know, just wasn't sure :D
06:52:02 <parcs> note how the action to the left of >> has an inferred return type of Char but the action to the right has an inferred return type of String -- this means the value 'exit ()' must unify with Cont r Char and Cont r String, and the only way it could do that is if its type is forall b. Cont r b
06:52:55 <parcs> @let callCC_rank3 :: ((forall b. a -> Cont r b) -> Cont r a) -> Cont r a; callCC_rank3 f = ContT $ \c -> runContT (f (\a -> ContT $ \k -> c a)) c
06:52:55 <lambdabot>   TypeOperators is not enabled
06:53:43 <parcs> @let callCC_rank3 f = ContT $ \c -> runContT (f (\a -> ContT $ \k -> c a)) c :: ((forall b. a -> Cont r b) -> Cont r a) -> Cont r a
06:53:43 <lambdabot>   TypeOperators is not enabled
06:53:45 <parcs> :(
06:54:53 <parcs> :t let callCC_rank3 :: ((forall b. a -> Cont r b) -> Cont r a) -> Cont r a; callCC_rank3 f = ContT $ \c -> runContT (f (\a -> ContT $ \k -> c a)) c in callCC_rank3 $ \exit -> (if True then exit () else return 'a') >> (if True then exit () else return "hello")
06:54:55 <lambdabot>     Couldn't match expected type `()' with actual type `[Char]'
06:54:55 <lambdabot>     In the first argument of `return', namely `"hello"'
06:54:55 <lambdabot>     In the expression: return "hello"
06:55:09 <parcs> ahh, this is too unwiedly
06:55:49 * hackagebot hen 0.0.1 - Haskell bindings to Xen hypervisor interface  http://hackage.haskell.org/package/hen-0.0.1 (FedorGogolev)
06:56:29 <parcs> :t let callCC_rank3 :: ((forall b. a -> Cont r b) -> Cont r a) -> Cont r a; callCC_rank3 f = ContT $ \c -> runContT (f (\a -> ContT $ \k -> c a)) c in callCC_rank3 $ \exit -> (if True then exit () else return 'a') >> (if True then exit () else return "hello") >> return ()
06:56:30 <lambdabot> Cont r ()
06:59:24 <blueonyx> hi, is there a url for hackage to get the latest .cabal file for a given package name?
06:59:52 <blueonyx> eg http://hackage.haskell.org/packages/archive/word8/latest/ doesnt contain a .cabal file :(
07:00:06 <dcoutts> blueonyx: not in the old server, but the new one has that I think
07:00:10 * dcoutts double checks...
07:00:46 <dcoutts> blueonyx: e.g. http://new-hackage.haskell.org/package/acme-dont/acme-dont.cabal
07:01:14 <blueonyx> dcoutts: oh great!
07:01:27 <geekosaur> hm, I thought it did, just not in the sam eplace
07:01:57 <geekosaur> http://hackage.haskell.org/packages/archive/word8/0.0.3/word8.cabal
07:02:13 <dcoutts> but that's versioned
07:02:21 <blueonyx> geekosaur: yea, but to construct this url i need to know the version
07:02:23 <geekosaur> oh, right
07:02:27 <blueonyx> "Please don't post it to reddit just yet!" xD
07:02:43 <dcoutts> blueonyx: :-)
07:02:47 <geekosaur> maybe latest should just be a symlink
07:04:03 <dcoutts> geekosaur: given that that the new server already does it, I wouldn't bother
07:04:31 <geekosaur> depends. how many years has new-hackage been pending now?
07:05:46 <dcoutts> geekosaur: that's fair criticism, but the IHG has been funding it in the last few months, see the current front page for details
07:06:40 <dcoutts> ie myself and colleagues of mine have been working on it for several months now
07:07:06 <dcoutts> geekosaur: we're currently doing alpha testing, you're welcome to take part
07:08:45 <geekosaur> hmf. just loaded its master list in place of old hackage, already have some observations. where is this being discussed?
07:09:53 <dcoutts> geekosaur: cabal-devel
07:10:07 <dcoutts> geekosaur: what are your observations ooi?
07:11:03 <geekosaur> right at the top, (a) package list is artificially wrapped to other than my browser window width (b) and is justified, which is harder to read in general and *much* harder for anyone with some level of dyslexia
07:11:28 * geekosaur has been involved with a11y issues a bit of late and is starting to notice such things...
07:11:31 <dcoutts> oh the css
07:12:17 <dcoutts> geekosaur: yes, that width thing was my experiment. I'm open to suggestions and css patches. My intention was to make lines of text in paragraphs not too long.
07:12:22 <beaky> hello
07:12:25 <beaky> if sets can be implemented as functions a -> Bool, can associative arrays also be implemented in the same manner?
07:12:27 <pepijndevos> hi
07:13:05 <dcoutts> geekosaur: I understand there's some standard recommendation on number of words per line, because with really long lines that's also totally unreadable, even for people without dyslexia!
07:13:07 <geekosaur> beaky, I hope you mean dictionaries. actual associative arrays are evil.
07:13:13 <beaky> ah
07:13:16 <beaky> why are they evil?
07:13:19 <geekosaur> at the very least, don't justify the text
07:13:36 <beaky> my professor called them associative arrays
07:13:42 <dcoutts> geekosaur: really? that's also a standard typography recommendation, e.g. latex, newspapers etc
07:13:56 <dcoutts> geekosaur: but that max width is perhaps not appropriate for the packages page
07:14:31 <geekosaur> because they're trying to be both ordered stores (arrays) and keyed stores (dicts) at the same time, and you can't do both with the same structure without (a) performance issues (b) sometimes requiring odd circumlocutions in user code to avoid accidentially invoking the arrayish behavior in dictionary context or vice versa
07:14:33 <elliott> browsers are pretty bad at text justification
07:14:58 <dcoutts> elliott: I was just going to say that, perhaps that's why newspaper sites don't do it online, but do do it for their paper versions.
07:15:10 <geekosaur> dcoutts, newspapers use it for one reason: to maximize the amount of text on a page. it's severely frowned on for readability
07:15:17 <beaky> so I should say maps instead?
07:15:29 <elliott> geekosaur: well, novels and papers and such do it too...
07:15:59 <elliott> do you have a citation for good justification in print being bad for readability? generally, I mean; I can believe that it's bad specifically for dyslexic people
07:16:19 <dcoutts> geekosaur: that's interesting, I thought it was rather the reverse, e.g. latex defaults is not cramming in to save space but uses justification. But it does do justiifcation properly, unlike browsers.
07:16:50 <elliott> dcoutts: fwiw, I would appreciate a larger font size, especially on the package list.
07:17:07 <elliott> I prefer the size used by current Hackage on the package list etc.
07:17:14 <elliott> wouldn't hurt for package descriptions either
07:17:14 <dcoutts> lemme check I've got the latest version of the haddock css, since that's all I'm using here
07:17:27 <dcoutts> I didn't do any design myself :-)
07:17:47 <elliott> fair enough then; it *is* the same size as haddock text, that's true
07:18:02 <geekosaur> I can pull up lots of random google stuff right now but if you can wait a bit I can ask the a11y guru for some official refs
07:18:13 <geekosaur> (now if I can get the cabal-dev list page to load...)
07:18:45 <geekosaur> here's one collection of links to justification/a11y stuff
07:18:52 <geekosaur> http://blog.newmediadevelopment.net/2010/02/justifying-nonjustified-text.html
07:19:22 <dcoutts> geekosaur: similarly about the width issue. I'm sure we don't want the line length to be the full screen width, but I'm more than happy to delegate that to someone who knows about design etc
07:19:57 <elliott> geekosaur: hmm, ok. that post *is* from a web design, perspective, though (not to say its references are)
07:20:15 <geekosaur> I mostly noticed the width thing due to the justification... it's less of an issue
07:21:18 <elliott> perhaps centre the text, if using a smaller width?
07:21:20 <geekosaur> yes, that page is, but the a11y design stuff I've seen (but don't have handy links to, hence my waiting for the a11y guru to show up) usually has a discussion of its relevance to print as well
07:21:39 <srhb> @hoogle Read a => Text -> a
07:21:40 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
07:21:40 <lambdabot> Prelude id :: a -> a
07:21:40 <lambdabot> Data.Function id :: a -> a
07:21:47 <srhb> Is there no unsafe read for Text?
07:21:56 <srhb> @hoogle Read a => Text -> Maybe a
07:21:56 <lambdabot> Prelude Just :: a -> Maybe a
07:21:56 <lambdabot> Data.Maybe Just :: a -> Maybe a
07:21:56 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
07:22:08 <srhb> And where's the safe one anyway?
07:22:31 <ocharles> read . Text.unpack
07:22:42 <srhb> Yeah, okay
07:23:22 <geekosaur> my recollection is that, while it *is* less of a problem in a print context, it is still an issue --- but print media usually has to deal with other constraints as well, so makes a different trade-off. sometimes they have print versions specifically for various visual processing disabilities which among other things drop the justification
07:23:45 <joe9> any emacs users here? do you use capitalized-words-mode? I find that it is very finicky. It stops moving to the next word quite a few times?
07:24:10 <joe9> is there something better than capitalized-words-mode? is sub-words-mode better?
07:24:16 <dcoutts> geekosaur, elliott: I guess it's a corollary of the Waddler rule, that discussion of new server code focuses primarily on the css & visual design :-)
07:24:39 <dcoutts> geekosaur, elliott: when that's the bit I spent ~2hrs on just stealing the haddock design :-)
07:24:58 <dcoutts> but it is the thing people see first
07:25:47 <elliott> yeah :)
07:26:02 <elliott> where have the reverse dependencies gone?
07:26:58 <dcoutts> elliott: currently disabled, earlier they were taking too much memory
07:27:12 <dcoutts> we might be able to re-enable, but someone will have to look at the data structures
07:27:18 <dcoutts> not had time to do that yet
07:28:15 <dcoutts> elliott: we've been mainly working on stuff that's not so visible, so e.g. have not even touched the tags & search features yet
07:28:25 <dcoutts> both of which need some work
07:29:06 <dcoutts> we've been getting things up to feature parity, rather than hacking on the new features
07:29:26 <edwardk> arkeet: with regards to prism and iso. making the arg order inconsistent was actually deliberate. it mostly comes down to which one you would have to put parens around in most cases in the prism case. the prism constructor is easy, the match is hard.
07:30:03 <elliott> dcoutts: heh, I remember when cmccann was having memory use problems with hackage 2...
07:31:35 <dcoutts> elliott: aye, that's now solved, fully populated server is running in less than 1Gb
07:31:51 <edwardk> dcoutts++
07:31:58 <elliott> dcoutts: cool :)
07:32:10 <dcoutts> though I'd prefer to use more, keeping things in memory is a lot simpler
07:33:32 <dcoutts> hopefully we're getting a new server for hackage.haskell.org so we'll be able to use more like 4-8gb
07:34:39 <dcoutts> edwardk: which reminds me, we were going to chat about infrastructure funding, haskell.org etc :-)
07:35:22 <Igloo> dcoutts: My proposed memory split had 4G for the whole hackage VM - and that would have to cope with the packages added in teh next few years too
07:36:06 <dcoutts> Igloo: oh, where were you thinking of putting that vm? I thought we were talking about getting a second machine from hetzner
07:36:21 <Igloo> That would be a VM no the machine from Hetzner
07:36:23 <Igloo> s/no/on/
07:36:39 <dcoutts> you mean the existing haskell.org one, or a second?
07:36:47 <Igloo> The new one would replace the existing one
07:36:57 <dcoutts> ah, so we'd still have just one
07:37:02 <Igloo> yes
07:37:12 <Igloo> With at least 4 VMs
07:37:56 <dcoutts> what would those 4 be?
07:37:59 <dcoutts> I can think of 3
07:38:19 <Igloo> darcs, hackage, community, www
07:38:38 <dcoutts> Igloo: in that case, could we go up one level, €10 per month extra, and get the 32Gb machine rather than the 16
07:39:09 <Igloo> Well, that would be for the committee to decide
07:39:19 * Igloo still thinks H2 should use an SQL database backend
07:39:46 <dcoutts> the current hackage design is a mainly-in-memory design
07:40:02 <dcoutts> so could really do with a bigger memory budget
07:40:12 <geekosaur> sigh, still not online. would like an official-ish reference to the print justification being a holdover from the days of lead slugs. (briefly: sticking a big spring at the end of each line of slugs instead of small interstitial springs vastly increased the probability the slugs would pop out... hence justified became default for print and now mostly holds on out of "what we've always done")
07:40:43 <krzysz00> Is it possible in Haskell to define a function collect s.t. collect a0 a1 ... aN [Appropriate terminator value] = [a0, a1, ..., aN]?
07:41:00 <geekosaur> yes, in at least some simple cases, but the machinery required is NOT simple
07:41:07 <geekosaur> see the implementation of Text.Printf
07:42:11 <geekosaur> also, as a former xview programmer, mandatory terminating values are a lovely source of frustrating bugs (and would be more so in haskell because of the way it handles missing/extra parameters)
07:43:05 <krzysz00> Thanks for the pointer to Text.Printf. (I was just wondering wether n-ary functions were possible, and that seemed like a good example.)
07:44:00 <absence> i sometimes get error messages that say could not deduce blabla because something is a rigid type variable bound by something, and my usual tactic of poking at it until it somehow works is rather unsatisfactory. is there something i could read, exercises i could do, etc. to understand what's going on, and possibly even build some intuition for it?
07:44:49 <Eduard_Munteanu> absence: it's merely telling you the type of that thing doesn't match the expected type
07:46:00 <absence> Eduard_Munteanu: yes, it's this whole thing about rigid type variables that has me confused
07:46:23 <absence> i gather that there are two things that don't match, but i rarely understand why
07:46:34 <geekosaur> a rigid type variable is one that is fixed by a type signature somewhere, as opposed to ne that is inferred
07:47:12 <geekosaur> so it's telling you "your expression behaves like this thing is of type <x>, but I havw  a type signature telling me that it must be <y"... halp?"
07:49:40 <absence> hmm.. i'll dig out an actual example, just got to do something first, brb
07:49:57 <dcoutts> geekosaur, elliott: made a couple tweaks to the css, lemme know what you think
07:50:25 <fizbin> absence: I find that when that happens, I need to put lots of type signatures on other things, because it means I've gotten something else to have the wrong type.
07:50:28 <aCube> @show-poll (++)
07:50:28 <lambdabot> Unknown command, try @list
07:50:35 <aCube> @poll-result (++)
07:50:36 <lambdabot> Poll results for (++) (Open): (++)::Semigroup_m=>m->m->m=1, (++)::Monoid_m=>m->m->m=2, (++)::[a]->[a]->[a]=2
07:50:42 <elliott> dcoutts: looks better to me :)
07:50:54 <geekosaur> that's better, my eyes are no longer being drawn to things like the rigid column of (number) that the old one had
07:51:03 <geekosaur> (at the end of each line)
07:51:10 <elliott> could perhaps do with some more line/paragraph spacing or such, but I like it more than current hackage in general
07:51:14 <geekosaur> btw, what's with the orphan PortFusion package?
07:51:35 <elliott> the dependencies lists on package pages look uglier now, but I understand those are being redone anyway?
07:51:44 <elliott> not that they were pretty to start with
07:52:14 <dcoutts> elliott: oh those have (almost) always been silly
07:52:26 <dcoutts> geekosaur: oh that's because it's in a category called ""
07:53:20 <elliott> hehe, http://new-hackage.haskell.org/package/category-extras looks funny now.
07:53:55 <dcoutts> true, though it looked pretty silly before
07:54:12 <dcoutts> what I'd like to do is rewrite the tagging feature, make it subsume the existing categories, and allow hackage trustees to edit the tags, e.g. delete bogus ones and alias some together
07:55:34 <dcoutts> plus, we shouldn't fuss about the package list page, because we should not need to use that, we should be using search instead
08:03:15 <absence> ok, so if something is bound by a pattern with some constructor and something else is bound by a type signature, things generally don't work?
08:03:49 <Eduard_Munteanu> absence: the types have to match
08:04:52 <absence> Eduard_Munteanu: yes. ghc can't deduce that they match
08:06:15 <Eduard_Munteanu> absence: maybe you should paste some code
08:06:46 <Eduard_Munteanu> (and the error)
08:08:00 <absence> Eduard_Munteanu: it's a bit of a mess, i hope this is the relevant part: http://hpaste.org/84498
08:11:20 <Eduard_Munteanu> absence: 'testing' is too polymorphic, it seems
08:12:13 <Eduard_Munteanu> absence: testing :: forall e *n*. Exp Expr (Env e) -> Exp EVar n
08:13:36 <Eduard_Munteanu> It basically deduces some type for the return type, but it's less polymorphic than your signature's return type.
08:13:38 <absence> Eduard_Munteanu: it doesn't like the asterisks. without them it suggests i enable RankNTypes
08:14:09 <Eduard_Munteanu> absence: heh, no, that was something like *bold*
08:14:18 <Eduard_Munteanu> *emphasis*
08:15:06 <absence> right. "testing :: forall e n. Exp Expr (Env e) -> Exp EVar n" and RankNTypes gives the exact same error :)
08:15:51 <elliott> Eduard_Munteanu was pointing out that the "forall e n." is the error
08:16:04 <elliott> you're claiming its return value works as Exp EVar Int, Exp EVar String, whatever the *caller* wants
08:16:05 <Eduard_Munteanu> absence: I didn't suggest that as a fix, I merely meant to say the return type is polymorphic in 'n'.
08:16:51 <ski> saying that means that the caller gets to decide what `n' should be
08:16:56 <absence> oh, sorry. got confused since there was no forall in my code :)
08:17:15 <ski> perhaps you meant for the *callee* (i.e. `testing' itself) to decide what `n' should be ?
08:17:22 <ski> (in which case you'd want an existential)
08:17:53 <ski> (or, `testing' itself, or some operation it calls -- it's allowed to delegate the choice)
08:18:30 <absence> the idea was for testing's parameter to decide the type
08:18:58 <absence> i guess that means the caller?
08:19:25 <ski> ok, if `testing' is meant to decide (or recover) the type from the argument, then it's `testing's responsibility
08:20:55 <absence> ok
08:21:09 * hackagebot universe 0.2 - Classes for types where we know all the values  http://hackage.haskell.org/package/universe-0.2 (DanielWagner)
08:21:17 <Eduard_Munteanu> You have to relate the param and the return type somehow, you can't promise to return something that works for just about any 'n'.
08:22:25 <ski> perhaps relate through a type class (though i'd doubt it here, mind i know almost nothing about what you want), or wrap in an existential (of some kind), or use CPS to encode the existential
08:23:07 <absence> the argument is polymorphic and can be parameterised with any type, and i want to return something of that specific type
08:23:44 <ski> i don't see how the argument is polymorphic in your case ?
08:23:55 <absence> i.e. the n should be the argument's b
08:24:16 <srhb> How do I use views from lens with a value from a Reader?
08:24:20 <absence> ski: b can be anything
08:24:36 <ski> (a value being polymorphic means it has a universal type, a type looking like `forall a. ..a..' -- and i didn't see `testing :: ... -> (forall a. ..a..) -> ...' in your case)
08:25:05 <ski> absence : i see no `b' in `testing :: Exp Expr (Env e) -> Exp EVar n'
08:25:22 <Eduard_Munteanu> That 'b' doesn't occur in the type at all.
08:25:23 <edwardk> :t views _2 length
08:25:24 <lambdabot> (MonadReader s m, Field2 s t [a] b) => m Int
08:25:37 <srhb> Oh.
08:25:40 <srhb> Thanks
08:25:43 <edwardk> :t views _2 length ("hi","srhb")
08:25:45 <lambdabot> Int
08:25:49 <edwardk> > views _2 length ("hi","srhb")
08:25:51 <lambdabot>   4
08:26:05 <Eduard_Munteanu> Your Struct2' might be wrong.
08:26:22 <elliott> absence: do you really want an existential?
08:26:29 <elliott> if you want to get the type out then you can't use an existential.
08:26:41 <edwardk> > flip runReader (4,"srhb") $ do x <- views _2 length; y <- view _1; return (x + y)
08:26:43 <lambdabot>   8
08:27:14 <elliott> > flip runReader (4,"srhb") $ (+) <$> views _2 length <*> view _1
08:27:16 <lambdabot>   8
08:27:18 <Hermit> has anyone successfully built wxcore lately? I'm banging against a wall here
08:27:30 <ski> elliott : depends on what they mean by "get the type out", no ?
08:28:07 <elliott> ski: well, I mean the testing signature they're asking for
08:28:14 <srhb> :t view
08:28:16 <lambdabot> MonadReader s m => Getting a s t a b -> m a
08:28:21 <elliott> they might be able to achieve their goals with a "testing" that has a different type
08:28:26 <absence> ski: hmm.. would b have to be an additional parameter to Exp?
08:28:29 <ski> elliott : which is under question, no ?
08:28:42 <absence> ski: if it were to occur in testing's signature
08:28:49 <elliott> ski: well, I was suggesting that perhaps they might want a non-existential instead
08:28:50 <ski> absence : no idea. i don't know what your `b' is meant to represent
08:28:53 <elliott> if they really want their original form
08:29:12 <absence> elliott: i don't know if i want an existential, i'm not familiar with them
08:29:46 <elliott> well, Exp is an existential there
08:30:14 * ski notices absence has made a hpaste
08:31:31 <absence> i guess i should read about them :)
08:31:34 <ski> ok, as written, yes it is
08:32:30 <amatsu> What's the canonical comonad library? Is it just comonad?
08:32:41 <edwardk> amatsu: yep
08:32:51 <edwardk> comonad, comonad-transformers, comonads-fd
08:33:03 <edwardk> comonads-fd is the comonadic 'mtl'
08:33:12 <amatsu> edwardk: excellent, thanks!
08:35:04 <Sculptor> friday! hi!
08:35:31 <dmwit> I think my next project should be getting universe into lambdabot.
08:36:20 <dmwit> ?version
08:36:20 <lambdabot> lambdabot 4.2.2.1
08:36:20 <lambdabot> darcs get http://code.haskell.org/lambdabot
08:36:38 <edwardk> :t universe
08:36:40 <lambdabot> Plated a => a -> [a]
08:36:48 <dmwit> Yes, I discovered that, too. =)
08:36:48 <edwardk> =/
08:36:51 <dmwit> =(
08:36:53 <dmwit> I meant =(
08:37:34 <edwardk> it is also taken by uniplate
08:37:47 <edwardk> (which is how i got stuck with the name)
08:37:58 <miguel_> hello? can anyone help me out
08:38:10 <miguel_> anyone knows how to create a global hashtable
08:38:19 <edwardk> miguel_: without info on your problem that is hard to guess ;)
08:38:21 <miguel_> cant figure out the new syntax of http://www.haskell.org/ghc/docs/7.4.2/html/libraries/base/Data-HashTable.html
08:38:32 <Hermit> miguel_: you don't. Use a state monad and a hash table as state
08:38:47 <miguel_> im making a parser, and i want to create a global hashtable for the variables
08:39:15 <int-e> but is there a good reason for avoiding Data.Map and friends?
08:39:25 <dmwit> edwardk: I guess I'm open to suggestions, but I feel like "universe" is a pretty good name for what the package does...
08:39:41 <ocharles> dmwit: obviously have allTheThings
08:39:48 <edwardk> miguel_: in general this doesn't work well in a functional setting. Hermit's version is much better for parsing, because in a functional setting you really don't want to be setting and unsetting things in the variable list, you can work with a HashMap in your parser state, and do insertions as you see things
08:39:56 <ocharles> then you can map (+9000) allTheThings
08:40:06 <edwardk> dmwit: didn't copumpkin do an enumerable package?
08:40:15 <dmwit> Yep, he pointed that one out to me.
08:40:24 <edwardk> http://hackage.haskell.org/packages/archive/enumerable/0.0.3/doc/html/Data-Enumerable.html
08:40:34 <dmwit> It does a bit less in some ways and a bit more in others.
08:40:47 <miguel_> edwardk, so you suggesting i make a parameter in the main function with the hashtable, and passing it along the way?
08:40:50 <Hermit> \o/
08:41:07 <elliott> miguel_: you probablyd on't want to use Data.HashTable
08:41:17 <elliott> using Data.Map or Data.HashMap is likely better
08:41:18 <edwardk> miguel_: thats one way to do it. a better way is probably to use a state monad to plumb that arg for you
08:41:37 <edwardk> miguel_: because while you can do a few of these by hand it becomes tedious as you add more state
08:42:44 <miguel_> edwardk, thanks :)
08:43:17 <miguel_> another simple thing, using do inside a case of clause, i can have multiple 'instructions' and the return at the end, right?
08:43:26 <edwardk> miguel_: yes
08:43:34 <miguel_> thanks again :)
08:47:25 <zedchelon> Before I get started in here, I would like to point something out..
08:47:27 <zedchelon> http://www.krioma.net/articles/Bridge%20Theory/Einstein%20Rosen%20Bridge.htm <- this is just as much math as geometric polyhedra are.
08:48:27 <zedchelon> I'm sorry if you are too stubbon to know the difference.
08:49:01 <zedchelon> And won't admit that 50% of the axioms mathematics has been based on were proven wrong, then corrected.
08:50:06 <zedchelon> And I am really sorry you tried so hard to learn mathematics, that you no longer comprhend simple English or any other language.
08:50:16 <absence> elliott: is the code i pasted already an existential type?
08:50:21 <glguy> zedchelon: this might be the wrong channel fo ryou
08:50:26 <zedchelon> I am really sorry that you get emotional and can't control it either for that matter.
08:50:39 <tac> zedchelon: Yeah really.....
08:50:40 <int-e> @ops
08:50:40 <lambdabot> Maybe you meant: docs oeis pl
08:50:56 <geekosaur> @where ops
08:50:56 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconnor Saizan shapr sjanssen ski wli
08:50:56 <lambdabot> xerox
08:51:04 --- mode: ChanServ set +o glguy
08:51:11 --- mode: ChanServ set +o dcoutts
08:51:14 <zedchelon> sup glguy
08:51:15 <adnauseam> aaaaaand
08:51:24 <zedchelon> sup dcoutts
08:51:27 <glguy> zedchelon: This channel is for discussing the Haskell programming language
08:51:37 <zedchelon> my mistake
08:51:42 <zedchelon> #math redirected me here
08:51:58 <adnauseam> maybe they meant #haskell-blah
08:52:43 <elliott> I don't think zedchelon should join #haskell-blah.
08:52:50 <tgeeky> hehe
08:52:52 * geekosaur does get the impression #math sometimes treats #haskell as #math-blah
08:53:06 <dcoutts> zedchelon: or perhaps the people in #math were joking :-)
08:53:07 <adnauseam> #math has #notmath i think
08:53:19 <skp> any dude here knows OpenGL.Raw?
08:53:31 <shachaf> geekosaur: You're an op yourself, aren't you?
08:53:34 <adnauseam> #notmath doesn't exist, but i'm sure there's a a channel for that somewhere.
08:53:39 <geekosaur> not for a longish time
08:53:41 <skp> I have a GLbitfield, and I want to OR it with another
08:53:56 <skp> do I have to import Data.Binary?
08:54:07 <Clint> Data.Binary isn't what you think it is
08:54:08 <shachaf> Doesn't it go by account?
08:54:12 <dcoutts> skp: you mean Data.Bits
08:54:14 <skp> Data.Bits
08:54:16 <skp> yeah
08:54:17 <shachaf> Oh well, I don't know.
08:54:18 --- mode: glguy set -o glguy
08:54:18 <skp> .|.
08:54:22 --- mode: ChanServ set -o dcoutts
08:54:26 <elliott> geekosaur: btw, don't you have ops...? :P
08:54:34 <skp> @ppl (.|.)
08:54:34 <lambdabot> (.|.)
08:54:38 <skp> hm
08:54:41 <zedchelon> an event horizon is a mathematical form, just as acceptably mathematical in nature as much as a regular polyhedron.
08:54:41 <srhb> I'm confused, why can't I view (foo^.bar) ?
08:54:47 <skp> I can’t use lambdabot :D
08:54:59 <elliott> oh, shachaf said so.
08:55:04 <int-e> geekosaur: hrm really? there's a #not-math for things off topic on ##math.
08:55:26 <adnauseam> zedchelon: -> #not-math
08:55:43 <geekosaur> I'm just going by the number of times people have popped in here from ##math (not that it's *that* common but it has been noticeable)
08:55:47 <zedchelon> How would one download, install, and use Haskell. And does it come with a user-manual, or do I have to purchase one.
08:55:57 <tac> (The people in #math are typically kinda assholish)
08:56:04 * tac wishes that channel had active mods
08:56:17 <elliott> zedchelon:
08:56:19 <elliott> @where lyah
08:56:19 <dcoutts> zedchelon: see http://www.haskell.org/
08:56:19 <lambdabot> http://www.learnyouahaskell.com/
08:56:40 <elliott> for the "use" part. though I think it also covers "download" and "install"
08:58:14 <absence> Eduard_Munteanu: i tried replacing n with Double so the return type isn't polymorphic. it still can't deduce (b ~ Double) though (error message is identical otherwise)
09:01:08 * hackagebot computational-algebra 0.0.3.0 - Well-kinded computational algebra library, currently supporting Groebner basis.  http://hackage.haskell.org/package/computational-algebra-0.0.3.0 (HiromiIshii)
09:02:20 <Eduard_Munteanu> absence: you're still returning something that's not appropriate
09:02:32 <Eduard_Munteanu> absence: I mean, in the actual definition, rather than the signature
09:03:01 <supki> srhb: what's the error?
09:03:32 <supki> I'd guess ambiguous type
09:04:12 <fumieval> srhb: perhaps the `bar` is something like Traversal but not Getter
09:04:24 * tac wishes that the haddock wasn't broken on new packages at the time they were uploaded.
09:04:25 <Ornedan> Has the STM implementation been changed to work in a multi-processor environment? The Composable Memory Transactions paper mentions that such changes were planned
09:06:05 <srhb> > flip runReader (4,("srhb",2)) $ view (_2^._1)
09:06:07 <lambdabot>   Could not deduce (Control.Lens.Tuple.Field1
09:06:07 <lambdabot>                      (p0 a0 (f0...
09:06:15 <zedchelon> How would I use haskell to mass-parse logs?
09:06:23 <srhb> zedchelon: Parsec is nice.
09:06:27 <zedchelon> PHP and Perl are too damn slow
09:06:32 <supki> > flip runReader (4,("srhb",2)) $ view (_2._1)
09:06:35 <lambdabot>   "srhb"
09:06:37 <srhb> Derp.
09:06:40 <srhb> supki: Thanks
09:06:46 <edwardk> zedchelon: parsec or attoparsec
09:07:12 <zedchelon> I thought parsec was a computer game from the days of door games?
09:07:30 <glguy> In this context it's a parser combinator library
09:07:35 <ski> > (`runReader` ((3,"sections"),5)) $ view (_1._2)
09:07:37 <lambdabot>   "sections"
09:07:37 <edwardk> zedchelon: it is also the name of a more or less canonical parsing library for haskell
09:07:40 <glguy> http://hackage.haskell.org/package/parsec
09:07:59 <Clint> attoparsec is more fun
09:08:07 <srhb> Clint: Why? :P
09:08:10 <Clint> i don't know
09:08:15 * edwardk prefers trifecta but can't currently recommend it for log files
09:08:23 <srhb> I don't know, I miss quite a few combinators in attoparsec.
09:08:27 <zedchelon> I downloaded a door host program a while, well, long while back, and the damn thing had source code I remember having had written. What gives?
09:08:38 <srhb> Like, where's optional and optionMaybe. :P
09:09:17 <srhb> At least they're easy to write.
09:09:18 <bos> srhb: optional is in Control.Applicative
09:09:23 <srhb> True.
09:09:25 <edwardk> :t optional
09:09:27 <lambdabot> Alternative f => f a -> f (Maybe a)
09:09:30 <edwardk> done
09:09:39 <edwardk> :t many
09:09:40 <lambdabot> Alternative f => f a -> f [a]
09:09:45 <edwardk> also done ;)
09:09:47 <saml> > optional (+1)
09:09:49 <lambdabot>   No instance for (GHC.Show.Show (a0 -> Data.Maybe.Maybe a0))
09:09:49 <lambdabot>    arising from...
09:09:59 <bos> srhb: attoparsec does not reimplement combinators that already exist in base libraries, unless there's a significant speed improvement to be gained
09:10:16 <srhb> bos: Right. :)
09:10:34 <fizbin> :t optional
09:10:36 <lambdabot> Alternative f => f a -> f (Maybe a)
09:10:45 <zedchelon> Does the bot know how to handle fork bombs?
09:10:53 <srhb> zedchelon: The bot doesn't fork.
09:11:19 <zedchelon> What good is haskell if it doesn't fork?
09:11:29 <glguy> The *bot* doesn't let you fork
09:12:03 <ski> @help run
09:12:04 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
09:12:21 <tac> zedchelon: the bot launches evaluation in a separate process specifically so it can prevent abuse.
09:12:30 <tac> You can't run any IO, so you can't use forkIO, and you can't forkbomb
09:12:35 <tac> @type forkIO
09:12:37 <lambdabot> Not in scope: `forkIO'
09:12:44 <tac> (... damnit lambdabot)
09:12:54 <fumieval> :t unsafePerformIO
09:12:56 <lambdabot> Not in scope: `unsafePerformIO'
09:13:01 <tac> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html#v:forkIO
09:13:03 <c_wraith> > let x = 1 ; y = 2  in x `par` y `pseq` (x + y)
09:13:04 <ski> @index forkIO
09:13:04 <lambdabot> Control.Concurrent
09:13:05 <lambdabot>   3
09:13:15 <ski> @type Control.Concurrent.forkIO
09:13:17 <lambdabot> IO () -> IO GHC.Conc.Sync.ThreadId
09:13:20 <tac> thank you ski
09:13:38 <elliott> @hoogle forkIO
09:13:38 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
09:13:38 <lambdabot> GHC.Conc.Sync forkIO :: IO () -> IO ThreadId
09:13:38 <lambdabot> GHC.Conc forkIO :: IO () -> IO ThreadId
09:13:39 <elliott> works too
09:13:43 <c_wraith> heh. lambdabot does have par, though.  Though I'm assuming it doesn't use the threaded runtime, making it kind of pointless
09:13:47 <glguy> bos: Do you have a favorite summary of where parsec and attoparsec diverge / trade-offs attoparsec makes?
09:14:43 <srhb> glguy: Attoparsec does it well in the Haddocks
09:15:33 <glguy> srhb: Ah, looks like I didn't dive deep enough into them
09:15:36 <edwardk> c_wraith: doesn't matter even if it did. sparks are best effort. if the queue is full they do nothing
09:15:52 <edwardk> @hackage speculation
09:15:52 <lambdabot> http://hackage.haskell.org/package/speculation
09:15:58 <edwardk> i actually rely on that behavior in that package
09:17:35 <c_wraith> Well, not just that - GHC can't effectively forkbomb under any circumstances, unless it has syscalls to fork
09:17:50 <skp> hey
09:17:56 <skp> I install a lib with cabal-dev
09:17:59 <skp> a private one
09:18:07 <skp> can I find the code of the installed lib?
09:19:20 <edwardk> :t Control.Concurrent.forkOS
09:19:22 <lambdabot> IO () -> IO GHC.Conc.Sync.ThreadId
09:19:42 <tac> Does Haskell support both OS threads and greenthreads in the same application?
09:20:03 <c_wraith> forkOS doesn't actually create a new OS thread.
09:20:06 <c_wraith> It's terribly named.
09:20:29 <glguy> skp: The souce code won't be installed unless you explicitly enabled adding source code to the documentation and installed documentation
09:20:49 <srhb> c_wraith: Isn't its existence just terrible?
09:21:04 <skp> fuck then
09:21:07 <c_wraith> srhb: no, it's important when working with native libraries that use threadlocal storage
09:21:08 <edwardk> c_wraith: yes, but it is the closest we get
09:21:09 <glguy> srhb: it would be nice if it wasn't a necessary evil
09:21:13 <skp> I removed files I wanted to keep
09:21:18 <srhb> c_wraith: Really? I thought that was a myth.
09:21:26 <skp> through a git merge
09:21:28 <skp> dafuck
09:21:33 <edwardk> srhb: thread local storage exists ;)
09:21:40 <srhb> Yes. :P
09:21:46 <srhb> But in native libs.. As in foreign call stuff.
09:21:52 <srhb> Or am I misunderstanding?
09:21:57 <edwardk> yes
09:22:03 <edwardk> that is what forkOS is used for mostly
09:22:10 <srhb> But isn't that unnecessary?
09:22:12 <Philippa> 'lo
09:22:19 <edwardk> e.g. getting one thread to consistently talk to OpenGL
09:22:31 <edwardk> OpenGL is kinda nice to have access to
09:22:37 <edwardk> but its a very stateful API
09:22:38 <srhb> OK, I guess I don't understand the docs.
09:22:40 <Philippa> heh, yes
09:23:09 <c_wraith> srhb: you need to understand how ghc handles calls to native functions, too.
09:23:13 <edwardk> gotta run
09:23:17 <srhb> Yeah.
09:23:31 <c_wraith> srhb: and that's really complicated, with several different cases
09:24:27 <glguy> skp: git merge typically doesn't destroy data, perhaps you can find your old code in the reflog
09:25:17 <skp> glguy: how?
09:25:31 <skp> oh
09:25:35 <skp> I see my commits yes
09:25:43 <skp> how can I revert to them?
09:25:47 <skp> it’s about one month work :DD
09:26:07 * geekosaur knows the big hammer way, not so clear on more gentle ones
09:26:33 <glguy> You want to discard the merge commit and reset your branch to point back to where it was?
09:27:25 <glguy> git reset --hard OLDCOMMITID # will change the current branch to point back to OLDCOMMITID and discard the current working directory in favor of that commit's contents
09:27:26 <skp> exactly
09:27:45 <skp> ok
09:27:47 <skp> and now?
09:28:06 <skp> oh
09:28:06 <srhb> Now you're done.
09:28:07 <skp> :D
09:28:08 <skp> thanks
09:28:15 <dcoutts> c_wraith: hrm, forkOS does create a new OS thread
09:28:17 <skp> you’ve saved my work :D
09:28:20 <skp> thank you
09:28:32 <glguy> yw
09:28:58 <dcoutts> c_wraith: it doesn't add extra parallelism
09:29:02 <skp> I have to learn how to revert / reset head
09:29:44 <c_wraith> dcoutts: Does it do that even if you don't make foreign calls in the action?  I was under the impression that the OS thread bound to it was created lazily
09:29:46 <zedchelon> What is Haskell for?
09:29:51 <c_wraith> programming
09:30:02 <zedchelon> Programming what?
09:30:06 <c_wraith> everything
09:30:25 <zedchelon> No single language programs everything.
09:30:32 <srhb> Maybe not device drivers.
09:30:41 <srhb> Though you can createa a DSL for that I'm sure. :P
09:30:48 <dcoutts> c_wraith: oh, now that's a good question, my guess is that it does it proactively so that unsafe calls also work, but I'd have to check the code to be sure
09:30:56 <aCube> @faq Can haskell program everything?
09:30:56 <lambdabot> The answer is: Yes! Haskell can do that.
09:31:48 <Taneb> zedchelon, Haskell is a general purpose programming language. There are a few things it's especially good at and a handful of things it sucks at
09:31:49 <zedchelon> Can Haskell solve the travelling salesman problem?
09:32:01 <dcoutts> @faq Can Haskell solve the travelling salesman problem?
09:32:01 <lambdabot> The answer is: Yes! Haskell can do that.
09:32:02 <Taneb> Just as much as any other language, zedchelon
09:32:08 <lrojas> zedchelon: i guess if the programmer is any good ?
09:32:50 <c_wraith> Haskell *does* have issues solving the Post Correspondence Problem.  But so does everything else.
09:32:58 <zedchelon> PETBASIC cannot solve the travelling salesman problem due to a lack of exponent ability.
09:33:17 <aCube> > 3 ^ 4
09:33:19 <lambdabot>   81
09:34:10 <srhb> zedchelon: Your line of questioning is probably not very constructive. Haskell is a general purpose and as such can be used with ease for most(tm) problems most(tm) programmers tend to get confronted with.
09:34:31 <srhb> zedchelon: Which goes for just about any general purpose programming language.
09:35:14 <zedchelon> > 1.001 ^ .087
09:35:16 <lambdabot>   <hint>:1:9: parse error on input `.'
09:35:30 <aCube> > 1.001 ** 0.087
09:35:32 <lambdabot>   1.0000869603098068
09:36:13 <lrojas> > 1.001 ^ 0.087
09:36:15 <lambdabot>   Ambiguous type variable `b0' in the constraints:
09:36:15 <lambdabot>    (GHC.Real.Fractional b0...
09:36:27 <zedchelon> Btw, this morning i figured out how to immediately solve any specific digit of pi in base 19
09:36:29 <zedchelon> Btw, this morning i figured out how to immediately solve any specific digit of pi in base 10*
09:36:41 <zedchelon> Technically, it works for any base.
09:36:58 <aCube> > pi
09:37:00 <lambdabot>   3.141592653589793
09:37:10 <zedchelon> solving digits is a predictable limit series
09:37:23 <elliott> zedchelon: http://en.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula
09:37:35 <zedchelon> ...meaning pi is not random
09:37:51 <elliott> lol.
09:37:55 <srhb> trololo.
09:38:14 <no-n> if I have a list of numbers, what's the best way to print them all out in one line, with added space like printf "%2d" does?
09:38:15 <elliott> can you keep the math crankery to a channel where it's on-topic?
09:38:21 <zedchelon> i'd show the animation, but it doesn't work on x64 machines.
09:38:39 <zedchelon> Also, I don't know where the back-up of the program is. :/
09:38:50 <adnauseam> i think he'll keep this up till he gets banned
09:39:00 <aCube> > intercalate " " $ map show $ [1..10]
09:39:01 <lambdabot>   "1 2 3 4 5 6 7 8 9 10"
09:39:06 <aCube> @no-n
09:39:06 <lambdabot> Not enough privileges
09:39:11 <aCube> no-n: ^
09:40:06 <no-n> thanks. but I also wanted to know how I could space like "%2d" does for printf
09:40:31 <aCube> What does "%2d" do for printf? :P
09:41:01 <sipa> print an integer as a decimal, with width 2
09:41:11 <sipa> s/as a/in/
09:41:17 <shachaf> > intercalate " " . map (printf "%2d") $ [1..10]
09:41:19 <lambdabot>   " 1  2  3  4  5  6  7  8  9 10"
09:41:29 <no-n> ahh
09:41:34 <no-n> I thought printf only prints ;)
09:41:51 <geekosaur> f = format
09:42:04 <fizbin> :t printf
09:42:05 <lambdabot> PrintfType r => String -> r
09:42:06 <int-e> printf is a marvellous monstrosity of type hackery.
09:42:38 <no-n> if I had a list of numbers, how could I "unpack" them as args for printf?
09:42:50 <shachaf> You don't.
09:43:03 <no-n> ok
09:43:31 <sipa> here's what to do if you want to convert a list to varargs to printf: forget it
09:44:02 <no-n> :[
09:44:09 <aCube> Use some pretty printing library?
09:44:10 <elliott> well, you technically can...
09:44:12 <elliott> but it'd be very ugly.
09:44:46 <shachaf> no-n: When something is really awkward like that, it often means that you're asking the wrong question.
09:44:59 <no-n> yes
09:45:07 <no-n> that's true :p
09:45:28 <no-n> thought maybe there was an unawkward way though
09:46:49 <zedchelon> does Haskell compile as CIL?
09:47:05 <elliott> GHC does not have a CIL background.
09:47:18 <glguy> nor a backend
09:47:22 <elliott> er, yes
09:47:24 <elliott> I don't think there are any compilers (even toy) that do, but there is an old JVM backend for GHC (not in main GHC)
09:47:33 <elliott> Haskell compilers, that is
09:48:49 <Ingo2> hi
09:49:25 <Ingo2> Hi, i am new Haskell newbie and i´d like to know if someone knows this book and tell me if its any good to enter the haskell world:  http://t.co/YEoy7pyuKC
09:49:54 <elliott> that is a perfectly fine book for learning Haskell
09:50:06 <elliott> in fact, one of its authors is in the channel now :)
09:50:19 <elliott> (btw, please don't shorten links like that without a good reason... it makes it harder for people to see what they're clicking)
09:50:49 <no-n> I think I'll read that one after I'm done with learn you a haskell for great good
09:50:51 <geekosaur> it does assume a certain amount of programming experience, and it can be helpful to use it in conjunction with LYAH or other basic Haskell tutorial
09:51:10 * hackagebot computational-algebra 0.0.3.1 - Well-kinded computational algebra library, currently supporting Groebner basis.  http://hackage.haskell.org/package/computational-algebra-0.0.3.1 (HiromiIshii)
09:51:16 <elliott> Ingo2: as geekosaur says,
09:51:17 <elliott> @where lyah
09:51:17 <lambdabot> http://www.learnyouahaskell.com/
09:51:23 <elliott> is also a good tutorial (and available free online and in book form)
09:51:30 <elliott> RWH is available online, too, FWIW
09:51:42 <zedchelon> Why is Haskell called Haskell, and who invented it?
09:51:45 <Ingo2> hmm
09:52:04 <no-n> it was named after a man called Haskell Curry
09:52:13 <Philippa> zedchelon: it's named after Haskell Curry, it was designed by the Haskell Committee
09:52:13 <elliott> zedchelon: wikipedia knows.
09:52:18 <elliott> I think haskell.org probably has that info too
09:52:29 <Philippa> if you really want the history, there's even a History of Programming Languages paper about it
10:01:10 * hackagebot computational-algebra 0.0.3.2 - Well-kinded computational algebra library, currently supporting Groebner basis.  http://hackage.haskell.org/package/computational-algebra-0.0.3.2 (HiromiIshii)
10:12:03 <Pods> when I check the type of a function it gives me (say) factorial :: Num a => a -> a
10:12:38 <Pods> I understand that Num a => a represents a Number type but what does the subsequesnt -> a represent ??
10:12:57 <Pods> Okay got it , the result type
10:13:05 <geekosaur> "givden that the type a is an instance of num, take an a and produce an a
10:13:06 <sepp2k1> The Num a => applies to the whole thing.
10:13:14 <elliott> Pods: Num a => a -> a means "a -> a for any a that is an instance of Num".
10:13:15 <Taneb> Pods, "Num a =>" means all the a's areNums
10:13:20 <elliott> Pods: you can use it as Integer -> Integer
10:13:22 <aCube> (Num a) => (a -> a)
10:13:26 <elliott> which is probably how you should think of that type when learning
10:13:30 <Pods> oh got it now :)
10:13:32 <elliott> which simply means: takes an Integer, returns an Integer.
10:13:37 <sepp2k1> Pods: Num a says "a is a numeric type" and "a -> a" says "this function takes an a and produces an a"
10:13:45 <Pods> yes , makes sense
10:13:48 <Pods> thanks :)
10:14:32 <shachaf> Taneb: Well, it means that "a" is an instance of Num.
10:14:36 <shachaf> All the "a"s are the same.
10:15:06 <Taneb> shachaf, it's too cold to think, I'm gonna find a blanket
10:16:52 <c_wraith> Does anyone else find it awkward that conal calls foldr fold(subL) in the slides that were just posted to /r/haskell? I mean, clearly the L means list, but that's confusing
10:18:44 <dmwit> THERE IS ONLY ONE FOLD
10:19:05 <dmwit> (for each type)
10:19:33 <shachaf> Yes, foldl is a lie.
10:19:45 <Philonous> It is?
10:19:52 <c_wraith> in some sense, yes
10:20:14 <parcs> can foldl' be written in terms of foldr?
10:20:24 <Philippa> it's fold of a (re)traversal of the list
10:20:35 <Philippa> traversals happen to also be lists. Ho hum.
10:20:38 <c_wraith> foldl is more of a concession to optimizing operational properties than as a semantically interesting thing
10:20:58 <Philippa> well, it's also a syntactically useful thing
10:21:38 <Philippa> (sometimes you want to build a tree from a list in a left-associative manner, rather than a right-associative one)
10:22:08 <elliott> foldl has quite bad operational properties
10:22:13 <elliott> (re c_wraith)
10:22:22 <Philippa> right, foldl' is the operational concession
10:22:24 <elliott> (rather than foldl')
10:22:31 <shachaf> parcs: Everything can be written in terms of foldr.
10:22:40 <shachaf> In particular "foldr (:) []"
10:24:03 <parcs> but foldl' is special
10:24:06 <c_wraith> elliott: that's just a detail of non-strict evaluation.  foldl is about the pattern "use an accumulator and tail recursion"
10:24:37 <dmwit> parcs: The denotation of foldl' is not special, and can very well be written using foldr.
10:25:17 <Philippa> isn't it basically doable anyway with seq?
10:25:32 <shachaf> Philippa: Well, traversals are monoid-shaped.
10:25:43 <Philippa> (I mean, if you had an array or rope representation of lists the way you can with strict lists, that might be different)
10:25:48 <Philippa> shachaf: right, and lists are the free monoid
10:26:40 <kryft> Is fold really a good abstraction? What do you gain by writing something as a fold?
10:26:58 <shachaf> Philippa: Except infinite traversals exist.
10:27:22 <shachaf> (And they can be infinite in both directions, like FMList.)
10:27:24 <parcs> foldl' f a bs = foldr (\b g x -> g (f x b)) id bs a -- where to put the strictness annotations?
10:27:38 <quchen> parcs: x `seq` g (...)
10:27:47 <quchen> No?
10:27:50 <Philippa> shachaf: ah. Thanks, good point
10:27:56 <parcs> quchen: maybe
10:28:17 <dmwit> ?src foldl'
10:28:17 <lambdabot> foldl' f a []     = a
10:28:17 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
10:28:17 <elliott> shachaf: I think we need a term for the kind of existence infinite traversals endure
10:28:22 <elliott> "sortofexist"
10:28:25 <quchen> > let myfoldl' f z xs = foldr (\ x g a -> x `seq` g (f a x)) id xs z in myfoldl' (+) 0 [1..10^6]
10:28:27 <Philippa> kryft: a solid understanding of its performance characteristics, plus various laws you can apply to rewrite/transform terms involving it
10:28:27 <lambdabot>   *Exception: stack overflow
10:28:31 <srhb> kryft: It's an excellent abstraction for many things. What you get depends on what you're doing.
10:29:16 <quchen> > let myfoldl' f z xs = foldr (\ x g a -> let x' = f a x in x' `seq` g x) id xs z in myfoldl' (+) 0 [1..10^6]
10:29:18 <lambdabot>   1000000
10:29:22 <elliott> kryft: concat = foldr (++) []
10:29:30 <elliott> kryft: concat [] = []; concat (xs:xss) = xs ++ concat xss
10:29:33 <elliott> I'd rather write the former
10:29:35 <quchen> > let myfoldl' f z xs = foldr (\ x g a -> let x' = f a x in x' `seq` g x') id xs z in myfoldl' (+) 0 [1..10^6]
10:29:37 <lambdabot>   500000500000
10:29:39 <quchen> There we go.
10:29:58 <elliott> kryft: similarly, and = foldr (&&) True
10:29:59 <elliott> > and []
10:30:00 <edwardk> elliott: I'm sure there is an analogy like: An infinite traversals is like climate change. Just because you deny it exists doesn't mean it isn't happening.
10:30:01 <lambdabot>   True
10:30:08 <elliott> > or []
10:30:10 <lambdabot>   False
10:30:11 <elliott> kryft: or = foldr (||) False
10:30:18 <parcs> ah so g $! f x b
10:30:26 <zedchelon> > ;)
10:30:27 <elliott> maximum = foldr1 max
10:30:27 <lambdabot>   <hint>:1:1: parse error on input `;'
10:30:30 <elliott> minimum = foldr1 min
10:30:31 <elliott> etc.
10:30:40 <parcs> pretty gnarly
10:30:48 <elliott> edwardk: :(
10:30:50 <dmwit> > getAnd (mconcat [])
10:30:52 <lambdabot>   Not in scope: `getAnd'
10:30:52 <lambdabot>  Perhaps you meant one of these:
10:30:52 <lambdabot>    `getAny' (import...
10:31:01 <kryft> elliott, Philippa: Fair enough
10:31:19 <dmwit> > getAll (mconcat [])
10:31:21 <lambdabot>   True
10:32:42 <shachaf> > andOf folded []
10:32:44 <lambdabot>   True
10:34:29 <parcs> > let myfoldl' f z xs = foldr (\ x g a -> let x' = f a x in g x') id xs z in myfoldl' (+) 0 [1..10^6]
10:34:31 <lambdabot>   *Exception: stack overflow
10:34:58 <gwern> @wn ilk
10:34:58 <lambdabot> *** "ilk" wn "WordNet (r) 3.0 (2006)"
10:34:58 <lambdabot> ilk
10:34:59 <lambdabot>     n 1: a kind of person; "We'll not see his like again"; "I can't
10:34:59 <lambdabot>          tolerate people of his ilk" [syn: {like}, {ilk}]
10:35:15 <gwern> darn. I was hoping the geographic definition would be primary
10:36:43 * byorgey is not aware of any geographic definition for ilk
10:37:23 <c_wraith> Neither am I
10:39:47 <zedchelon> Haskell, does it have any actual usage, such as making a video game, or dubbing music?
10:40:02 <elliott> zedchelon: yes, of course. you asked whether Haskell had uses before and got a reply.
10:40:20 <zedchelon> I missed it because I had a visitor. :(
10:41:32 <elliott> actually you spoke two minutes after receiving several answers, with no conversation in-between. but ok.
10:42:47 <zedchelon> My log doesn't show that.
10:43:00 <zedchelon> nini zzz
10:47:31 <Pods> class Monad m where   (>>=) :: m a -> (a -> m b) -> m b
10:47:37 <Pods> What would this mean??
10:47:41 <sm> morning all
10:48:00 <shachaf> Pods: You shouldn't worry about Monad right now. Learn about other type classes first.
10:48:17 <Pods> shachaf : suggest few ??
10:48:30 <c_wraith> Eq, Ord, Show
10:48:44 <c_wraith> They're all good to start with, for learning about classes
10:49:22 <Pods> c_wraith : great thanks :)
10:49:28 <sm> GHC -cpp fails to compile #if MIN_VERSION_directory(1,2,0) , giving the CPP error: missing binary operator before token "(". It compiles ok via cabal, and I don't see why cabal's GHC command works. What's going on ?
10:49:56 <sm> s/GHC -cpp/ghc with cpp enabled/
10:51:30 <byorgey> sm: sounds like the MIN_VERSION_directory macro is not defined
10:51:33 <monochrom> MIN_VERSION_directory is provided by cabal
10:51:43 <byorgey> which makes sense because it's provided by cabal
10:51:45 <monochrom> raw GHC does not define it
10:52:06 <wuttf> I need something like this in parsec:  noneOf (myParser1 <|> myParser2)
10:52:19 <sm> ahhhh.. thank you
10:52:21 <wuttf> But noneOf only works on chars
10:52:43 <dcoutts> sm: ghci -optP-include -optPdist/build/autogen/cabal_macros.h
10:52:59 <monochrom> perhaps manyTill anyChar (myParser1 <|> myParser2) but I am not sure
10:53:09 <lrojas> as a n00b in haskell and functional lenguages... i am sorry if my next question is so obvious that can be constructed as trollin, it's not my intention...
10:53:10 <sm> dcoutts: awesome
10:53:30 <lrojas> A functional language is supposed to not have side effects...
10:53:40 <byorgey> wuttf: use  notFollowedBy (myParser1 <|> myParser2)
10:53:48 <lrojas> so how does a functional language acomplish anything?
10:53:51 <wuttf> byorgey: You are the man!
10:54:02 <elliott> lrojas: pure expressions don't have side effects.
10:54:13 <elliott> haskell lets you write *programs*, though, which can do output (and use pure computations).
10:54:19 <byorgey> lrojas: it's a good question =)
10:54:23 <elliott> it enforces a separation of code which can do IO and code which cannot.
10:54:56 <elliott> (in particular, programs that have effects are /first-class values/, which means things that would be basic imperative control structures in other languages can be defined in Haskell itself)
10:55:36 <elliott> you might find http://www.haskell.org/haskellwiki/Introduction_to_IO helpful, though it assumes some Haskell knowledge
10:55:44 <lrojas> hmm, i think i need to read a bit more to fully understand your explanation... it looks like it makes sense but kind of went over me
10:56:08 <elliott> yeah, it's not something you'll have to worrya bout just to write haskell programs that do something: that part's easy, and any haskell tutorial will show how
10:56:16 <elliott> it's just for when you care about what it all means :)
10:57:23 <xkcd> What is the difference between [x*2 | x <- [1..10], mod 2*x 4 /= 2] and [x*2 | x <- [1..10], mod (2*x) 4 /= 2] I just started learning haskell
10:58:06 <lrojas> xkcd: any relation to the web commic?
10:58:08 <barrucadu> xkcd: As far as I can see, one has some parentheses that you don't need
10:58:17 <byorgey> lrojas: you might find this helpful: http://www.cis.upenn.edu/~cis194/lectures/08-IO.html
10:58:27 <lrojas> byorgey: thanks
10:58:30 <byorgey> xkcd: mod 2*x 4  parses as  (mod 2) * (x 4)
10:58:33 <merijn> xkcd: The first is a type error because it parses as "(mod 2) * (x 4)"
10:58:34 <byorgey> which is presumably nonsense
10:58:46 <barrucadu> Oh, of course
10:58:48 <tgeeky> barrucadu: on the contrary
10:58:49 <silasm> xkcd: Haskell can take functions as arguments, so "mod" will read the (*) as an argument rather than passing its result.
10:58:51 * barrucadu hasn't written haskell for too long
10:59:08 <merijn> Function application always has higher precedence than operators
10:59:09 <byorgey> silasm: no, not in this case
10:59:29 <byorgey> silasm: if you wanted to pass * as an argument to mod you would have to write  (*)
10:59:47 <silasm> byorgey: ah.
10:59:54 <tgeeky> @type mod (*)
10:59:56 <lambdabot> (Integral (a -> a -> a), Num a) => (a -> a -> a) -> a -> a -> a
11:00:06 <xkcd> lrojas: yes
11:00:09 <ocharles> @info (*)
11:00:09 <lambdabot> (*)
11:00:15 <ocharles> bah, no fixity declaration
11:00:22 <xkcd> thanks byorgey barrucadu silasm
11:00:29 <elliott> > (0$0*)
11:00:31 <lambdabot>   The operator `GHC.Num.*' [infixl 7] of a section
11:00:31 <lambdabot>      must have lower prece...
11:00:33 <elliott> ocharles: helpful trick ^
11:00:34 <byorgey> > mod (*) (+) 17 4
11:00:36 <lambdabot>   No instance for (GHC.Real.Integral (a0 -> a0 -> a0))
11:00:36 <lambdabot>    arising from a use ...
11:00:40 <tgeeky> elliott: very nice trick.
11:00:42 <ocharles> elliott: ha, neat
11:00:48 <Pods> In general, given that x has type t1 and exp has type t2, then \x->exp has type t1->t2., why ?? (or more how ?? )
11:01:02 <byorgey> aww, I gues lambdabot doesn't have those instances anymore =)
11:01:31 <byorgey> Pods: what do you mean, "how"?
11:01:38 <elliott> not my trick :)
11:01:53 <elliott> I believe Ørjan Johansen came up with it.
11:01:54 <tgeeky> elliott: I credit you anyway!
11:02:01 <monochrom> Pods: do you agree that \x->exp is a function?
11:02:18 <Pods> monochrom : not yet
11:02:34 <monochrom> ok, first you have to agree it.
11:02:47 <Pods> Can I be talked into it here ??
11:02:58 <aristid> Pods: well that depends on you
11:02:59 <tgeeky> @type \x -> exp
11:03:00 <lambdabot> Floating a => t -> a -> a
11:03:08 <ocharles> heh
11:03:46 <Pods> what does /x mean here ??
11:03:47 <byorgey> Pods: it's just what the notiation \x -> exp  means.  It is a function which takes x as input and yields exp  as output
11:04:08 <monochrom> yes. I want to write a function. but it must not be named. therefore, "f x = exp" doesn't count, it uses up the name "f". I don't want "f" or anything. what notation do you suggest for me?
11:04:08 <Pods> byorgey : okay got it
11:04:10 <aCube> Pods: its more the other way around: given that \x -> y has the type t1 -> t2, then x has type t1 and y must have type t2
11:04:28 * elliott doesn't really think it's the other way around there.
11:04:34 <petrus>  I have been using xmonad for a while in a way that all related modules are globally installed. Now I wanted to change to using taffybar so I installed it (with dependencies) using cabal into ~/.cabal/.... But xmonad cannot find the needed modules there. How can I tell xmonad to look into ~/.cabal too?
11:04:36 <elliott> in particular, type inference decides the type of (\x -> y) based on the type of y
11:04:44 <byorgey> aCube: it goes both directions.
11:05:32 <fryguybob> Ornedan: I don't know if anyone answered your question or not, but yes.  GHC's STM has a multi-core implementation.
11:05:33 <monochrom> it is both ways
11:05:34 <Pods> okay so / in /x -> y is just to make it a nameless function
11:05:42 <aCube>  \
11:05:52 <Pods> sorry my bad
11:06:01 <byorgey> Pods: right
11:06:10 <monochrom> you can tell a one-way story. but after you have told it, it implies the two-way story.
11:07:08 <Pods> Looks like we are defying modes ponens here :)
11:11:12 * hackagebot fb 0.14.2 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.14.2 (FelipeLessa)
11:16:12 * hackagebot pcre-utils 0.1.0.0 - Perl-like substitute and split for PCRE regexps.  http://hackage.haskell.org/package/pcre-utils-0.1.0.0 (SimonMarechal)
11:26:49 <fizbin> Is there a variant of &&& that does triples?
11:27:42 <startling> not in Control.Arrow. It'd be trivial to write, though
11:28:09 <fizbin> You sure about that? Certainly it would be for functions.
11:28:19 <fizbin> But for arbitrary Arrows?
11:28:35 <elliott> fizbin: f &&& (g &&& h) >>> \ ~(a,(b,c)) -> (a,b,c)
11:28:36 <shachaf> Yes.
11:28:40 <elliott> maybe you need ~(a, ~(b,c)) not sure
11:28:54 <sproingie> @src (&&&)
11:28:54 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
11:29:36 <fizbin> Hrm.
11:29:36 <sproingie> bleh.  never did grok all those arrow ops
11:29:53 <sproingie> @src (***)
11:29:53 <lambdabot> f *** g = first f >>> second g
11:30:51 <fizbin> :t \f g h -> arr (\b -> (b, (b, b))) >>> f &&& g &&& h
11:30:53 <lambdabot> Arrow cat => cat (t, (t, t)) c -> cat (t, (t, t)) c1 -> cat (t, (t, t)) c' -> cat t (c, (c1, c'))
11:30:57 <startling> I feel like arrows are not really useful.
11:31:24 * geekosaur wonders if arrows are well defined for triples, as opposed to nested pairs
11:31:26 <johnw> is there a version of readProcess which returns an IO ByteString?
11:32:15 <c_wraith> That would make entirely too much sense
11:32:19 <c_wraith> so probably not
11:32:23 <johnw> :(
11:32:23 <typoclass> fizbin: afaik, 2-tuples show up quite a lot in the signatures of Control.Arrow functions. i don't see how you could change that. it will have to be stuff like (a, (b, c)), but that's more awkward
11:32:30 <johnw> i really need it
11:32:35 <geekosaur> doesn't look like one directly, but process-extras has ByteString versions of readProcessWithExitCode
11:32:37 <c_wraith> time to write it yourself!
11:32:46 <c_wraith> Oh, or use that
11:32:48 <johnw> the best I can do is get back IO Text, but calling decodeUtf8 on that makes no sense at all
11:32:55 <johnw> geekosaur: thanks
11:33:00 <shachaf> johnw: You can always get a Handle and do it yourself.
11:33:22 <johnw> shachaf: I suppose that is the other answer
11:33:58 <johnw> ah, geekosaur's answer gives me exactly the function I need
11:35:15 <otters> so this package is haskell-98 and it has the type declaration type WN a = (?wne :: WordNetEnv) => a
11:35:19 <otters> what's going on there
11:35:35 <elliott> it isn't haskell 98
11:35:41 <elliott> it is using implicit parameters
11:35:46 <fizbin> Screw it; I only actually need this for functions anyway, so the trivial \f g h a -> (f a, g a, h a) it is.
11:36:10 <elliott> fizbin: can you avoid the triple entirely?
11:36:10 <geekosaur> it may be h98 in the sense that it expects the haskell98 version of base
11:36:16 <elliott> I'd generally prefer that
11:36:48 <fizbin> elliot: No, I'm using the HXT pickle framework and trying to pickle a structure with three things in it already.
11:38:43 <otters> elliott: well, it won't compile under GHC 7.6
11:38:50 <otters> parse errors on "wne"
11:39:04 <elliott> otters: what is the package?
11:39:08 <otters> WordNet
11:39:21 <otters> trying to update it, it uses Control.OldException and stuff
11:39:41 <elliott> and it doesn't turn ImplicitParams on?
11:40:02 <elliott> oh, it turns -fglasgow-exts on in the cabal file.
11:40:09 <elliott> you'll want to add manual {-# LANGUAGE #-} pragmas instead.
11:40:29 <otters> right
11:40:30 <elliott> and I lose out on my edwardk bonus if I don't suggest that it could use the reflection package instead of ImplicitParams :p
11:40:40 <sproingie> -fglasgow-exts should really be called -fkitchen-sink
11:40:53 * edwardk gives elliott a 15% raise.
11:40:56 <elliott> or, um, even just a Reader monad?
11:41:01 <elliott> I'm not sure why this uses ImplicitParams at all.
11:41:13 <monochrom> it doesn't include template haskell, so it is ineligible for -fkitchen-sink
11:43:32 <otters> me neither
11:43:52 <otters> I used cabal-dev add-source on my patched copy of WordNet, but cabal-dev still breaks when trying to install my bot
11:43:56 <aristid> edwardk: hey i want a 15% rise too.
11:44:44 <edwardk> aristid: we'll have to talk about it at your next performance review, and set goals. Then we can see about getting your provisional raise through HR.
11:44:52 <otters> all it says is "could not resolve dependencies: trying: lexie 0.1"
11:45:00 <otters> lexie being the package name
11:45:08 <aristid> edwardk: hmm
11:45:26 <edwardk> Sorry, they came down on me hard after I unilaterally adjusted elliott's compensation just now.
11:45:29 <otters> oh nvm
11:45:37 <johnw> edwardk has clearly spent too much time in corporate America :)
11:46:02 <elliott> aristid: neener neener
11:46:08 <elliott> I got a raise and you didn't
11:46:16 <aristid> elliott: imma so jealous :(
11:50:25 <latro`a> ...is there really -fkitchen-sink?
11:50:31 <monochrom> no :)
11:50:40 <latro`a> aww
11:51:22 <geekosaur> -fglasgow-exts just feels like it
11:53:12 <monochrom> it is still missing out on template haskell
11:54:51 <fizbin> Okay, how do I turn an HXT XmlTree into a string of xml ?
11:55:05 <monochrom> writeDocument
11:55:44 <monochrom> generally anything in Text.XML.HXT.Arrow.WriteDocument
11:55:46 <merijn> hmm, is there a "(a -> b -> m c) -> m a -> m b -> mc" function?
11:55:58 <latro`a> zipWithM
11:56:01 <latro`a> :t zipWithM
11:56:02 <lambdabot> Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
11:56:04 <fizbin> Okay, I'll investigate that package.
11:56:07 <latro`a> oh wait
11:56:07 <latro`a> no
11:56:09 <latro`a> almost the same
11:56:33 <fizbin> I don't want to write it to a file, I just want to look at the xml in ghci to check that I'm doing what I think I am.
11:56:51 <supki> @ty  let (.::) = fmap . fmap . fmap in join .:: liftM2
11:56:52 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
11:56:53 <latro`a> :t \f m n -> join $ liftM2 f m n
11:56:55 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
11:57:00 <merijn> bah, I was hoping to get away with "f <$> foo <*> bar", but that doesn't work if f already returns a monadic value :\
11:57:23 <latro`a> no, that needs monadic to collapse the m (m a)
11:57:25 <latro`a> er
11:57:27 <latro`a> m (m c)
11:57:34 <monochrom> join
11:57:39 <latro`a> right
11:57:52 <latro`a> but applicative can't collapse the m (m c)
11:58:16 <monochrom> applicative has limitations
11:58:20 <fizbin> Ah. writeDocumentToString
11:58:30 <merijn> latro`a: No, the problem is that fmap lifts the return type too
11:58:32 <fizbin> with stupid runX all over it.
11:58:46 <merijn> I can't believe this combinator doesn't exist yet >.>
11:58:56 <latro`a> depends how you look at it I think
11:59:05 <monochrom> runX is not stupid. unless you say runStateT is stupid
12:00:27 <latro`a> when you "apply" the function via an fmap-like operation, you wind up with an m (m c), and then applicative can't reduce that down unless you have monad
12:00:52 <fizbin> Oh, foo. Stupid arrows. Stupid HXT.
12:00:53 <merijn> I have a monad
12:01:10 <latro`a> well, what you wrote only uses the applicative interface
12:01:27 <merijn> Well, yes, but I said "f already returns a monadic value"
12:02:02 <latro`a> ...yes? that's why you get an m (m c) with your code if f returns a monadic value
12:02:19 <latro`a> then you can join that if you have a monad
12:02:27 <fizbin> What's the arrow equivalent of "return" ?
12:02:49 <geekosaur> :t returnA
12:02:50 <lambdabot> Arrow a => a b b
12:03:01 <geekosaur> hm, maybe not
12:03:11 <geekosaur> (or maybe yes; I do not claim to grok arrows)
12:03:14 <johnw> could someone help me understand why formatTime defaultTimeLocale "%s %z" . fromJust $ (parseTime defaultTimeLocale "%s %z" "1347777046 -0500" :: Maybe UTCTime) doesn't print the -0500?
12:03:20 <johnw> the result is 1347777046 -0000
12:03:36 <merijn> latro`a: The problem was "this is ugly", not "I don't know how to do this" :)
12:04:17 <geekosaur> johnw, you;re passing a UTCTime, of course it has 0 for timezone
12:04:38 <johnw> but utcToLocalZonedTime . fromJust $ (parseTime defaultTimeLocale "%s %z" "1347777046 -0500" :: Maybe UTCTime) knows that the UTCTime has time zone information
12:04:46 <latro`a> ahh
12:04:48 <latro`a> sorry
12:04:55 <geekosaur> no
12:04:58 <johnw> or maybe it doesn't...
12:05:06 <johnw> hmm... so I have to use a ZonedTime
12:05:10 <typoclass> johnw: are you in zone -0500 yourself?
12:05:14 <johnw> ah, yes, that works just fine
12:05:15 <geekosaur> utcToLocalZonedTime does what its name says, it finds rthe local timezone and translates the UTC time to it
12:06:03 <aristid> johnw: UTCTime is called UTCTime because it's always in UTC :P
12:06:16 <johnw> i was confused by the docs for formatTime
12:06:25 <johnw> which says that %z has meaning for ZonedTime and UTCTime
12:06:30 <johnw> but I guess the meaning is "it's meaningless"
12:06:43 <aristid> johnw: if you want to know what's in UTCTime, then look in UTCTime, not in the docs for %z :P
12:06:49 <geekosaur> it's "meaningful" but for UTCTime it will always be zero because that's ewhat UTCTime *means*
12:07:10 <aristid> meanwhile for LocalTime the timezone is _unknown_
12:07:36 <aristid> however %z in parseTime for UTCTime is meaningless as well i guess
12:07:41 <merijn> Bah, when do we get type holes? I have a top level type of "Foo <can't be arsed to specify the rest because it's like 2 lines>" :<
12:07:44 <typoclass> i've noticed in the past that parseTime's handling of timezones is a bit dodgy. it doesn't throw exceptions on things, it just silently assumes the timezone is +0000 ...
12:07:49 <fizbin> I am rapidly coming to the conclusion that people who structure their libraries around arrows hate their users.
12:07:59 <aCube> Is there a way to show expanded type families in ghc?
12:08:00 <merijn> fizbin: How zso?
12:08:01 <fizbin> Or at the very least, like their users insufficiently.
12:08:13 <aristid> merijn: you mean you'd write like Foo _ and it would infer the rest?
12:08:23 <Shapeshifter> Hi. I would like to read from a named pipe (on linux), but if the writing end is not connected yet, hGetLine prints "/tmp/pipe1: hGetLine: end of file". If I do this in a forkIO, I get a "thread blocked indefinitely in an STM transaction" on top. How can I read from a named pipe like 'cat' does - blocking while the writer is not connected and only closing when having received EOF?
12:08:31 <fizbin> Okay, so, I have an HXT XmlTree, right?
12:08:45 <fizbin> I want to turn it into a string.
12:09:04 <fizbin> In theory, one can use writeDocumentToString for that.
12:09:18 <fizbin> Because it kinda turns XmlTrees into strings.
12:09:23 <fizbin> Excpet not really.
12:09:25 <merijn> aristid: Yeah, I', playing around with vty-ui and I'm returning a Widget which ends up having a type like
12:09:47 <fizbin> ghci> :t xdoc
12:09:47 <fizbin> xdoc :: XmlTree
12:09:48 <fizbin> ghci> xdoc
12:09:48 <fizbin> NTree (XTag "/" []) [NTree (XTag "beta" [NTree (XAttr "name") [NTree (XText "goo") []]]) [NTree (XTag "value" []) [NTree (XText "gaa") []]]]
12:09:48 <fizbin> ghci> :t writeDocumentToString []
12:09:48 <fizbin> writeDocumentToString [] :: ArrowXml a => a XmlTree String
12:10:04 <merijn> "Widget (Bordered (Box (Box (Box (Box FormattedText Edit) FormattedText) Edit) Padded)), Widget FocusGroup)"
12:10:10 <fizbin> (->) is not an instance of ArrowXml.
12:10:15 <aristid> merijn: but it can't infer the whole type?
12:10:26 <aristid> merijn: i mean you could write -- this is a Widget
12:10:39 <merijn> aristid: It could, but then I feel bad for not specifying all top level signatures >.>
12:10:39 <johnw> is there a good article for understanding where/when Haskell uses stack space, and when/where it does heap space?
12:10:54 <aristid> merijn: :P
12:11:40 <erasmas> is anyone working on an sbt-like tool for haskell? I'm mostly interested in triggered execution for building and testing
12:13:04 <aristid> erasmas: there's "shake"
12:13:08 <typoclass> Shapeshifter: hi, those named pipes can be a bit odd to use. if you do "ls -l thepipe", does it show "srwx..."?
12:13:08 <aristid> @hackage shake
12:13:08 <lambdabot> http://hackage.haskell.org/package/shake
12:13:55 <Shapeshifter> typoclass: prw-r--r-- . I made it using mkfifo /tmp/pipe1
12:14:25 <Shapeshifter> typoclass: I think I need to use System.Posix.openFd....
12:14:26 <erasmas> aristid: thanks. I read a little about it but couldn't find anything about watching for changes to the codebase and automatically running cabal test or other commands
12:14:26 <supki> fizbin:  runX $ xdoc >>> writeDocumentToString []  ?
12:14:39 <supki> oh, no
12:15:01 <aristid> erasmas: i'm not familiar with sbt, sorry:)
12:15:15 <monochrom> runX (arr (const xdoc) >>> ...)
12:15:28 <fizbin> supki: Indeed, no. I need some way to "lift" xdoc into the state part of the arrow, or something.
12:15:40 <fizbin> And there's nothing that tells me how to do that.
12:15:44 <supki> yeah, with arr it should work
12:16:00 <monochrom> but I don't understand why you have a ready-made xml tree at the top level. this doesn't happen in practice
12:16:21 <erasmas> aristid: np, thanks for the answer
12:16:34 <erasmas> basically I want a set up where every time I save a file in my text editor, the tests or build process get run again automatically
12:16:58 <erasmas> I found a one-liner on stackoverflow using inotifywait, but it's a pretty popular tool in scala so I wasn't sure if someone might be working on one for haskell already
12:17:07 <fizbin> monochrom: Thank you, very much.
12:17:14 <fizbin> Now what the hell did that mean?
12:17:31 <aristid> erasmas: i think most actual haskell projects are built with cabal.
12:17:40 <monochrom> in practice you build an xml tree based on some other input (another xml tree read from a file, or some parameter from the user). therefore, the HXT general type "a Input XmlTree" makes sense, naked "XmlTree" does not
12:17:42 <typoclass> Shapeshifter: oh, "p". i was working with sockets (s) the other day, but those are slightly different
12:17:44 <fizbin> And shouldn't (arr . const) be a standard primitive?
12:18:12 <fizbin> monochrom: Oh, but it does, if you're building picklers and testing what you have.
12:18:37 <erasmas> aristid: I know. it'd be adding a layer of automation on top of cabal. it sounds frivolous but in practice it's actually really nice
12:19:01 <erasmas> it might also be a good way to get people who come from an engineering background up and running with haskell
12:19:03 <aristid> erasmas: yeah just write that little script with inotifywait and be done ;)
12:19:27 <monochrom> ok, test suite is special. unfair to bitch about the library just because test suite is special
12:20:17 <erasmas> well, I'll ask around and hit up haskell-cafe before I start, but I do think it would be better if it was an actual program that people could use for development
12:20:31 <aristid> monochrom: i think HXT doesn't really take advantage of its arrowised API and could just as well be monadic.
12:20:39 <typoclass> erasmas: it's a good idea. i would use it :-)
12:20:58 <monochrom> perhaps just read my http://www.vex.net/~trebla/haskell/hxt-arrow/lesson-0.xhtml for arrow orientation
12:21:02 <fizbin> monochrom: I haven't even gotten to a test suite. I'm just trying to poke at what I've written interactively to see if I'm on the right track.
12:21:31 <typoclass> erasmas: there's 2-3 packages that provide access to inotify, some of them even more or less cross-platform
12:21:37 <fizbin> And from my perspective, arrows add necessary undocumented boilerplate without adding anything of value.
12:21:53 <geekosaur> er? inotify is not cross platform...
12:22:00 <monochrom> I agree that HXT is better off monadic. every instance in it is a Kleisli arrow. but arrow itself is not so hard.
12:22:08 <geekosaur> file monitoring can be but inotify is not
12:22:17 <hpaste> ozataman pasted “retainer profiling GHC bug error” at http://hpaste.org/84507
12:22:32 <typoclass> geekosaur: no, i mean, istr there's a haskell package that will use inotify on linux, fsevents on mac, etc.
12:23:01 <monochrom> I seldom use its ArrowApply or -<< actually
12:23:04 <erasmas> typoclass: ah, nice. that would be a lot smarter than writing that part from scratch
12:23:15 <fizbin> monochrom: I'll agree that Arrows are probably about as difficult to master, ultimately, as monads. I just don't see why someone would decide to throw that additional bit on.
12:23:16 <monochrom> IOW I seldom actually need it monadic
12:23:34 <ozataman> anybody have the GHC retainer profiling bug I pasted above?
12:24:04 <monochrom> to tell you the historical truth, it was a master thesis project to investigate "what if we use arrow for xml processing"
12:24:06 <fizbin> monochrom: Also, I'd like to see an introduction to arrows - the one paper I was referred to from here was unreadable without knowing a huge bunch of specialized PL notation.
12:24:20 <monochrom> I just gave you one
12:24:47 <fizbin> Ah, I'd missed that.
12:24:52 <fizbin> Okay, maybe. Reading...
12:25:54 <monochrom> before arrow, there were two haskell xml libraries. both of their combinators were all like "XmlTree -> [XmlTree]". this inspired one of them to try "ArrowType XmlTree XmlTree"
12:27:21 <danharaj> is there a way to turn off Hayoo's instant search
12:27:25 <danharaj> it eats my queries while I'm typing them
12:27:48 <aCube>  Can undecidableInstances cause runtime loops?
12:27:56 <danharaj> No.
12:29:54 <Pods> typing the same thing say : do i <- [1,2]    j <- [1..4]    return (i,j) in ghci doesnt work, confusing..
12:30:16 <simpson> Pods: GHCi is quirky.
12:30:23 <elliott> Pods: you need ;s
12:30:30 <elliott> possibly {}s too
12:30:36 <simpson> > do { i <- [1,2]; j <- [1..4]; return (i,j) }
12:30:38 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4)]
12:30:39 <elliott> do { i <- [1,2]; j <- [1..4]; return (i,j) }
12:30:41 <elliott> dammit
12:30:47 <simpson> SNIPED YO
12:31:09 <simpson> Hm. Maybe I should cut back on the caffeine.
12:31:10 <Pods> I was hoping it would give me a continued interpreter like python does :D
12:31:15 <supki> > do i <- [1,2]; j <- [1..4]; return (i,j)
12:31:17 <monochrom> whitespace is meaningful in haskell. some newlines cannot be replaced by spaces
12:31:17 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4)]
12:31:52 <monochrom> ghci is not python interpreter. please don't compare them.
12:32:07 <Pods> yes, just an analogy
12:32:22 <danharaj> edwardk: does makeLenses mark lenses as inlinable or do I have to add those pragmas myself?
12:32:25 <elliott> Pods: you can use :{ ... :} to do multiline in ghci
12:32:33 <elliott> you will need to indent, however
12:32:38 <edwardk> it does
12:32:40 <monochrom> for example, python interpreter does not have ghci's reload command
12:32:41 <danharaj> cheers
12:33:00 <edwardk> it is paranoid about a very small range of ghc versions where it can't do it safely but otherwise it puts them in
12:33:18 <danharaj> edwardk: fyi calling lens 'batteries included' would be an understatement. I haven't had to roll my own stuff in forever. :)
12:33:23 <edwardk> technically it uses INLINE not INLINEABLE because they perform better
12:33:27 <edwardk> danharaj: =)
12:33:32 <edwardk> they are some big batteries =)
12:33:36 <typoclass> danharaj: nuclear power plant included
12:33:46 <simpson> More importantly, Python's REPL is quite literally a line-at-a-time Python compiler; GHCi is not exactly Haskell. :3
12:34:26 <typoclass> Pods: overall, ghci is quite alright. it has some quirks, but it's all manageable. ask in here if you have any particular trouble
12:34:39 <danharaj> edwardk: The only possible issue is how lens has claimed a large portion of the operator space :P
12:34:39 <Pods> okay , thanks a lot :)
12:35:09 <edwardk> danharaj: you can always import it qualified and then import the parts of Control.Lens.Operators you want.
12:35:15 <danharaj> indeed
12:35:26 <danharaj> qualified imports are a bit of a pain though
12:37:46 <danharaj> edwardk: Is it a reasonable expectation that lenses will get unrolled into within a few percent of hand-written code?
12:37:54 <aCube> @src foldOf
12:37:55 <lambdabot> Source not found. There are some things that I just don't know.
12:38:00 <aCube> @src (^..)
12:38:00 <lambdabot> Source not found. There are some things that I just don't know.
12:38:35 <aCube> @src toListOf
12:38:35 <lambdabot> Source not found. You speak an infinite deal of nothing
12:38:38 <edwardk> danharaj: for most cases yes
12:38:45 <simpson> aCube: lambdabot's @src list is hand-curated.
12:38:52 <simpson> aCube: So she doesn't know about things like lens.
12:38:53 <edwardk> in some cases better, in some cases a fair bit worse if you are using a traversal when you don't need to, etc.
12:38:54 <fizbin> @pl \t -> runX (arr (const t) >>> writeDocumentToString [withIndent yes]) >>= putStr . head
12:38:55 <lambdabot> (putStr . head =<<) . runX . (>>> writeDocumentToString [withIndent yes]) . arr . const
12:39:16 <typoclass> aCube: you can always go into the haddock of a module and click the 'source' link on the right hand side
12:39:34 <fizbin> :t head =<<
12:39:36 <lambdabot> parse error (possibly incorrect indentation)
12:39:39 <typoclass> aCube: (or, of course, "cabal unpack lens")
12:39:53 <fizbin> :t (putStr . head =<<)
12:39:55 <lambdabot> IO [String] -> IO ()
12:40:28 <danharaj> edwardk: in particular how does running traversals one after another tend to compile?
12:40:31 <fizbin> Oh, right. . binds much tighter than =<<
12:40:50 <edwardk> danharaj: if you compose them with (.) quite well.
12:40:58 <edwardk> i don't do any fusion on traverse then traverse though
12:41:02 <monochrom> you have an XY Problem, fizbin. writeDocument [withIndent yet] "" goes to stdout just fine, you need no putStr of your own, much less head. this is documented.
12:41:19 <edwardk> so if you can use the traversal laws to reason about your code it behooves you to do so ;)
12:41:37 <danharaj> edwardk: ah ok. I need a new word for the extra dimension of traversal composition we have now.
12:43:09 <edwardk> basically it'll inline and compose traversals, but it won't do 'traversal fusion' for you, the laws for that are things you have to exercise yourself
12:43:52 <danharaj> edwardk: good to know. fortunately the traversal laws are so intuitive.
12:44:05 <edwardk> =)
12:44:10 <edwardk> at least the lens version is
12:44:16 <edwardk> er setter one
12:44:32 <danharaj> the one in the paper lens cites is a bit opaque to me but I didn't try very hard to read it.
12:44:52 <edwardk> yeah. its basically what you get if you rewrite the functor laws and add the applicatives in
12:45:25 <edwardk> traverse :: (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
12:45:37 <edwardk> when f = Identity, you have (a -> Identity b) -> t a -> Identity (t b)
12:45:49 <edwardk> that if you squint real hard (or remove the Identity's is fmap.
12:46:14 <edwardk> we want the functor laws to hold for that
12:46:36 <edwardk> the traversal laws are just a generalization where you can have separate f and g applicatives in the functor law 'outputs'.
12:46:43 <edwardk> thats why all the crazy fmapping, to get them composed right
12:47:20 <c_wraith> huh.
12:47:51 <c_wraith> You're getting better at explaining this.  That's the first time the explanation has made sense to me :)
12:48:00 <edwardk> heh
12:48:02 <edwardk> practice =)
12:49:21 <danharaj> edwardk: I just think of it as "traversals satisfy a fusion law"
12:49:40 <rmunroe> it is so disorienting to be in a channel where someone else is nicked to xkcd
12:50:04 <fizbin> monochrom: Oh. So the issue I solved quickly (writeDocumentToString instead of writeDocument) was an XY problem. The issue I was pounding my head against (How do I lift this thing into an arrow) was not.
12:50:10 <c_wraith> rmunroe: It's disorienting to see you actually say something in here
12:50:21 <danharaj> I am never oriented.
12:50:23 <rmunroe> c_wraith: for me, too
12:50:26 <rmunroe> I'm just permanently disoriented
12:50:28 <shachaf> @ask Cale Can you give me a copy of the latest quote file that you have? I can go through the logs and add the missing ones.
12:50:28 <lambdabot> Consider it noted.
12:50:30 <rmunroe> haha, what danharaj said.
12:50:39 <edwardk> rmunroe: hah
12:51:11 <rmunroe> anyway yeah I used the nick xkcd for like 10 years and I still hilight on it when it's used for a prefix/addressing ("xkcd: blah" or "xkcd, blah")
12:51:21 * hackagebot void 0.6 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.6 (EdwardKmett)
12:51:43 <simpson> rmunroe: Must be lots of spurious highlights. :c
12:51:47 <danharaj> oh come on what could you have changed about void to bump up a major version now I have to change all my .cabals :P
12:51:51 <fizbin> :t return
12:51:52 <lambdabot> Monad m => a -> m a
12:51:58 <fizbin> :t return ()
12:51:59 <lambdabot> Monad m => m ()
12:52:00 <edwardk> rmunroe: yeah. think how poor 'so' feels, though. =) Worst nick choice ever for random pings.
12:52:18 <rmunroe> simpson: Nah, this is actually the first time it's come up, I think!
12:52:33 <dmwit> Why did you stop using the nick xkcd?
12:52:34 <c_wraith> edwardk: this coming from a guy whose client notifies him on the word "lens"
12:52:49 <edwardk> c_wraith: yeah well, it was a much lower frequency ping until the last few months =)
12:53:01 <simpson> edwardk: I remember when I was still /nick'd to "MostAwesomeDude" and highlighted on "MAD". :c
12:53:05 <fizbin> @pl runX (arr (const t) >>> writeDocument [withIndent yes] "") >> return ()
12:53:05 <lambdabot> runX (arr (const t) >>> writeDocument [withIndent yes] []) >> return ()
12:53:17 <fizbin> @pl \t -> runX (arr (const t) >>> writeDocument [withIndent yes] "") >> return ()
12:53:18 <lambdabot> (>> return ()) . runX . (>>> writeDocument [withIndent yes] []) . arr . const
12:53:22 <xkcd> rmunroe: I just liked it (your comics) too much so started using I didn't know until recently that you used the nick xkcd on IRC
12:53:26 <rmunroe> dmwit: the name of my website gradually usurped the namespace and it was getting strange
12:53:42 <rmunroe> the whole point of xkcd was that it was a unique unambiguous identifier
12:53:47 <rmunroe> then I had to go and ambiguate it.
12:53:54 <dmwit> I see.
12:54:22 <rmunroe> so now I'm "Randall" on every service where that nick is free, and other similarly boring things where it's not.
12:55:13 <shachaf> Y'all should just be born with less common names.
12:55:27 <edwardk> yes sir mr. seagull
12:55:29 <Philippa> not all of us're using one we were born with, y'know
12:55:33 <simpson> rmunroe: I feel your pain. It took me *years* to secure this nick.
12:56:06 <aristid> shachaf: i agree.
12:56:08 <shachaf> Philippa: That is another solution.
12:56:15 <rmunroe> simpson: Fortunately, I think we're moving away from global namespaces for the names that actually show up in conversation.
12:56:32 <Philippa> Not that my name's that uncommon? Just less common on tech chans for predictable reasons
12:56:44 <elliott> the solution is to kill everyone else who has your first name. then you can get freenode to drop it.
12:56:44 <rmunroe> Since that scheme was obviously going to run into problems as it expanded from covering everyone in your neighborhood to covering everyone on Earth
12:56:51 <elliott> works every time.
12:56:54 <danharaj> The secret technique is to have a globally unique name.
12:57:19 <Philippa> it doesn't always work for everyone in your neighbourhood!
12:57:19 <fizbin> My real name is so amazingly non-unique it's not funny.
12:57:24 <aristid> haha we have two xkcds here *just noticed*
12:57:24 <monochrom> S11001001 has an awesome globally unique name :)
12:57:31 <Philippa> (or, say, your love life)
12:57:45 <shachaf> elliott: You forgot the step where people use your first name as their last name.
12:57:59 <fizbin> Like, I'll be watching TV or some random youtube video and they'll just introduce people with the name "Dan Martin" *all the time*.
12:58:00 <danharaj> Philippa: I hope my love life never has namespace issues :3
12:58:01 <elliott> shachaf: sometimes you need to take... special measures.
12:58:14 <aristid> Philippa: i've never personally met anybody with the same first name :P
12:58:20 <S11001001> monochrom: my real name also appears to be globally unique
12:58:22 <simpson> Philippa: I'm fortunate to have the relatively rare name "Corbin," but annoyingly, everybody else already has it as a nick. :c
12:58:25 <S11001001> which is helpful
12:58:26 <Chousuke> in my case, some random japanese people have managed to use my gmail address when registering on websites.
12:58:36 <shachaf> I've met several people with my first name. :-(
12:58:44 * shachaf suspects this is getting into #-blah territory.
12:58:46 <fizbin> One of the top hits for my name is some 70's novel with the title "Daniel Martin".
12:58:48 <Chousuke> one registration email even contained the person's password :/
12:58:57 * typoclass thinks you people just need to make something up for a name
12:59:01 <Chousuke> (I hate it when web services do that)
12:59:48 <dmwit> I was doing pretty well with dmwit, but there are still a few services where I was beat to the punch.
13:00:13 <fizbin> typoclass: On the other hand, being able to say "whatever embarrassing stuff you found on Google, it's not me" plausibly is quite useful.
13:00:29 * geekosaur remembers when his first name was rare...
13:00:39 <Philippa> yep. If you go to furmeets, "John Smith" might not be such a bad name
13:00:39 <Chousuke> in one particular case I got regustered on some online drug store selling hair growth medicine and such stuff
13:00:42 <typoclass> fizbin: heh
13:01:08 <Chousuke> and then I get lots of spam from them every week. I set email telling them to remove me from their mailing list and they said they did but I still get email...
13:01:10 <danharaj> In 2015 edwardk will have secured treaties with all nations of the world to reserve single letter names for his children.
13:01:31 <elliott> edwardk will just call them all "child"
13:01:39 <byorgey> > iterate ((\(n,y) -> recip (fromInteger n + 1 - y)) . properFraction) 1
13:01:42 <lambdabot>   mueval-core: Time limit exceeded
13:01:45 <danharaj> elliott: 5 letters? extravagant
13:01:47 <Chousuke> or maybe <.> or something
13:01:59 <byorgey> > iterate ((\(n,y) -> recip (fromInteger n + 1 - y)) . properFraction) 1
13:02:02 <lambdabot>   [1.0,0.5,2.0,0.3333333333333333,1.4999999999999998,0.6666666666666665,2.999...
13:02:03 <edwardk> rmunroe: fortunately 'Kmett' isn't a very common surname, so i can maintain the illusion of global uniqueness if i ignore the one other Edward A. Kmett on the other coast.
13:02:06 <elliott> then abandon them every few years for newer, better children.
13:02:13 <byorgey> > iterate ((\(n,y) -> recip (fromInteger n + 1 - y)) . properFraction) (1 :: Rational)
13:02:16 <lambdabot>   [1 % 1,1 % 2,2 % 1,1 % 3,3 % 2,2 % 3,3 % 1,1 % 4,4 % 3,3 % 5,5 % 2,2 % 5,5 ...
13:02:41 <shachaf> edwardk: So *that's* why you stay on that coast.
13:02:46 <Philippa> and hey, it beats having to ignore offers for your vanity domain because they're probably an attempt to "ease" recovering it for a company selling camping products
13:03:16 <Philippa> (their shit used to show up when you google image searched my full name, too)
13:03:17 <shachaf> I got my first name .net recently!
13:03:26 <shachaf> I just need to do something with it now.
13:03:35 <edwardk> shachaf: yeah otherwise me and uncle fester might meet. and i'm pretty sure from all the crap fiction out there that if you touch an alternate universe version of yourself you explode.
13:03:57 <elliott> I believe you already exploded when we told you about symmetric lenses, so it's ok
13:04:02 * dmwit waves at byorgey
13:04:06 <byorgey> =)
13:04:13 <edwardk> you mistake apathy for explosion ;)
13:04:19 <byorgey> just trying to inject some Haskell back into #haskell
13:04:21 <edwardk> profunctor lenses were fine though =)
13:04:24 <shachaf> byorgey++
13:04:31 <typoclass> byorgey has the best name :-/
13:05:11 <edwardk> needs more lens
13:05:13 <shachaf> > over (partsOf (traverse._2.traverse)) reverse [(5,"hello"),(8,"blah"),(14,"lens")]
13:05:14 <edwardk> > 1^..iterated ((\(n,y) -> recip (fromInteger n + 1 - y)) . properFraction) :: [Rational]
13:05:19 <lambdabot>   can't find file: L.hs
13:05:21 <lambdabot>   mueval-core: Time limit exceeded
13:05:23 <edwardk> > 1^..iterated ((\(n,y) -> recip (fromInteger n + 1 - y)) . properFraction) :: [Rational]
13:05:27 <lambdabot>   mueval-core: Time limit exceeded
13:05:41 * edwardk kicks lambdabot 
13:05:43 <edwardk> > 1^..iterated ((\(n,y) -> recip (fromInteger n + 1 - y)) . properFraction) :: [Rational]
13:05:47 <lambdabot>   mueval-core: Time limit exceeded
13:05:59 <edwardk> hrmmph.
13:06:03 <edwardk> > 1^..iterated ((\(n,y) -> recip (fromInteger n + 1 - y)) . properFraction)
13:06:05 <lambdabot>   [1.0,0.5,2.0,0.3333333333333333,1.4999999999999998,0.6666666666666665,2.999...
13:06:10 <dmwit> > let fracs = 1 : concat (transpose [[(numerator n + denominator n) / denominator n | n <- fracs],[numerator n / (numerator n + denominator n) | n <- fracs]]) in fracs :: [Rational]
13:06:12 <lambdabot>   Occurs check: cannot construct the infinite type:
13:06:12 <lambdabot>    t0 = GHC.Real.Ratio t0
13:06:38 <dmwit> oh
13:06:58 <byorgey> needs more %
13:07:35 <dmwit> > let n = numerator; d = denominator; fracs = 1 : concat (transpose [[(n v + d v) % d v | v <- fracs],[n v % (n v + d v) | v <- fracs]]) in fracs :: [Rational]
13:07:38 <lambdabot>   Not in scope: `%'
13:07:38 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)Not in...
13:07:54 <byorgey> hah, doh
13:08:25 <dmwit> > let n = numerator; d = denominator; fracs = 1 : concat (transpose [[(n v + d v) R.% d v | v <- fracs],[n v R.% (n v + d v) | v <- fracs]]) in fracs
13:08:27 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,2 % 3,3 % 2,1 % 3,4 % 1,3 % 4,5 % 3,2 % 5,5 % 2,3 ...
13:09:04 <byorgey> ah, those sublists should be switched I guess
13:09:12 <dmwit> seems fine
13:09:17 <eikke> is there any existing Haskell lexer for ML/SML/OCaml?
13:09:24 <byorgey> I mean you still get all the rationals, just not in the nice order =)
13:09:30 <dmwit> =)
13:09:53 <venkatark> Split window 1: win#1 - Status window, win#2 - Messages window
13:10:09 <hpc> eikke: lexing is mostly the same in all three languages, is it not?
13:10:37 <fizbin> Okay. Anyone around who's used HXT's picklers much? Care to tell me if http://hpaste.org/84510 is decent pickler-using style, or if I'm missing something obvious?
13:10:44 <eikke> hpc: sure, but writing a lexer manually is boring, so reusing an existing one could be nice :0
13:10:59 <dmwit> :t let strictify [] = []; strictify (x:xs) = x `seq` (x:strictify xs) in strictify
13:11:01 <lambdabot> [a] -> [a]
13:11:12 <hpc> eikke: i mean, find an existing ML/ML lexer and reuse it
13:11:29 <dmwit> byorgey: query: iterate' = strictify . iterate?
13:11:33 <eikke> ah, right, sure
13:11:47 <dmwit> (strictify .) . iterate
13:13:45 <dEPY> what's wrong with this?  max' :: (Int a) => a -> a -> a
13:13:54 <elliott> Int is a type, not a typeclass.
13:13:59 <elliott> max' :: Int -> Int -> Int
13:14:00 <eikke> dEPY: Int is not a constraint
13:14:03 <dEPY> ah, damn
13:14:20 <dmwit> Oh man.
13:14:37 <dmwit> I was just playing in ghci and thinking, "How is my computer SO FAST?".
13:14:42 <dEPY> am, and what does this mean:  Could not deduce (Ord a) arising from a use of `>' ?
13:14:44 <dmwit> > iterate (+1) 0 !! 10^32
13:14:46 <lambdabot>   100000000000000000000000000000000
13:15:26 <dEPY> in regards to this:  max' :: (Num a) => a -> a -> a
13:15:38 <typoclass> dmwit: that's impressive. i guess it's the 21st century
13:15:41 <dmwit> dEPY: This means you gave an explicit type signature which claimed a function could work over even things that haven't got a comparison operation defined.
13:15:46 <dmwit> typoclass: guess again =)
13:16:01 <monoidal> dEPY: Ord is not a superclass of Num (it used to be)
13:16:02 <dmwit> typoclass: hint:
13:16:08 <dmwit> > [0..10] !! 10^32
13:16:10 <lambdabot>   100000000000000000000000000000000
13:16:19 <dEPY> oh
13:16:23 <typoclass> wat is this ...
13:16:26 <dEPY> so not all Num's can be ordered?
13:16:26 <typoclass> OH
13:16:33 <dEPY> is haskell saying that?:)
13:16:35 <typoclass> i see. how sneaky :-)
13:16:36 <monoidal> dEPY: yes
13:16:37 <dmwit> dEPY: correct
13:16:45 <dmwit> dEPY: For example, complex numbers have no good ordering.
13:16:48 <monochrom> no, Ord has never been a superclass of Num. would have conflicted with Complex
13:16:49 <dEPY> I'm just trying things that are not in the book to see what happens :)
13:16:54 <monoidal> dEPY: um actually it never was, my error
13:16:55 <shachaf> monochrom: Ord never used to be a superclass of Num
13:17:02 <shachaf> s/chrom/idal/
13:17:02 <latro`a> wait wtf
13:17:07 <monoidal> that was Eq and Show
13:17:08 <latro`a> that [0..10] !! 10^32 thing
13:17:09 <latro`a> wtf is that
13:17:17 <c_wraith> latro`a: precedence
13:17:22 <dmwit> latro`a: A little Haskell puzzle for you. =)
13:17:30 <c_wraith> sorry dmwit, I ruined it
13:17:42 <latro`a> does [0..10] actually just macro-expand?
13:17:42 <typoclass> latro`a: it's got to be "([0..10] !! 10) ^ 32"
13:17:49 <latro`a> ahh
13:17:50 <latro`a> derp
13:17:54 <monochrom> @type max
13:17:55 <lambdabot> Ord a => a -> a -> a
13:18:13 <monochrom> this type is just right. and nothing says that only numbers can enjoy max
13:18:47 <dEPY> I know, that's how it is in the book, I was just messing around  trying things :D
13:21:44 <geekosaur> latro`a, effectively yes, it's a call to enumFromTo
13:22:04 <dEPY> lol... Repeating yourself (three times) while programming is about as desirable as getting kicked inna head.
13:22:11 <geekosaur> [0..] is enumFrom, [0, 1 .. 10] is enumFromThenTo
13:22:22 <dEPY> I know so many people that should be kicked in the head :D
13:25:10 <LambdaDusk> data Resource = forall a . Binary a => Resource a
13:25:10 <LambdaDusk> how bad of an idea would that be?
13:26:48 <fizbin> :t void
13:26:50 <lambdabot> Functor f => f a -> f ()
13:26:56 <twomashi> is it possible to enter interactive mode from a haskell binary?
13:26:58 <fizbin> @src void
13:26:58 <lambdabot> Source not found. You speak an infinite deal of nothing
13:27:05 <latro`a> void = fmap (const ())
13:28:19 <shachaf> LambdaDusk: Pretty bad.
13:28:29 <shachaf> By which I mean that it's pointless.
13:29:24 <LambdaDusk> shachaf: why so?
13:29:30 <jMCg> hvr: I'm building a buildbot for.. I suppose you. I'm trying to keep it sane and reproducable, but failing. (I was trying to coerce ghc and cabal-dev into /opt/rise, but that doesn't seem to work out as simple as I imagined: http://apaste.info/lWiC )
13:29:47 <shachaf> LambdaDusk: Because think about what you can do with it.
13:29:51 <shachaf> See also the FAQ
13:29:53 <shachaf> @where faq
13:29:53 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
13:30:24 <geekosaur> twomashi, no
13:30:55 --- mode: ChanServ set +o glguy
13:31:29 --- mode: glguy set -bb *amathew*!*@*$##fixyourconnection andreypopp!*@*$##fixyourconnection
13:31:34 <hvr> jMCg: hi...
13:32:23 <Pods> Any instance wherein using "newtype" is beneficial over "type"; why does haskell have both ??
13:32:30 <hvr> jMCg: I'm missing a bit of context right now...
13:32:48 <tgeeky> Pods: that doesn't sound correct.
13:33:03 <latro`a> they don't really compare
13:33:07 <geekosaur> Pods, type is just an alias, newtype lets you hide something so you can replace it (typically a typeclass of some kind)
13:33:10 <latro`a> data compares to newtype more than newtype to type
13:33:11 <tgeeky> Pods: but the answer is that newtype doesn't add any performance penalty whatsoever, it is simply a renaming of an existing type.
13:33:46 <latro`a> again relative to data, where data Foo a = Foo a adds the overhead of a Foo constructor at runtime
13:33:58 <LambdaDusk> Pods: Basically, you can't/shouldn't do class instances on "type"s but sometimes data does too much
13:34:19 <merijn> Pods: Passing a String to a function "f :: SafeString -> Foo" is ok if you have "type SafeString = String", but a type error when you have "newtype SafeString = SafeString String"
13:34:28 <Pods> tgeeky: point here is that if i say type "newtype FirstName = FirstName String", then i will have to create new functions which take FirstName as their signature while doing type i can simply use the functions which already have string as their signature
13:34:42 <elliott> it is newtype and data which are similar, not type and newtype.
13:34:57 <tgeeky> Pods: what elliott said.
13:35:06 <merijn> The difference between "newtype" and "data" is that, at runtime, the newtype's constructor doesn't exist
13:35:15 <tgeeky> and I am wrong, anyway.
13:35:27 <latro`a> why exactly can't data optimize away a constructor for a type with only one constructor anyway?
13:35:45 <c_wraith> Because that changes the meaning
13:35:52 <latro`a> oh?
13:35:57 <geekosaur> consider bottoms
13:36:03 <latro`a> ah yes
13:36:17 <geekosaur> or, looked at another way: the constructor introduces an opportunity for laziness
13:36:18 <merijn> Pods: "type" is for aliasing long types, for example "type Blah = Foo -> Bar -> Baz -> Xyzzy", so you don't have the constantly type the entire type signatures.
13:36:19 <latro`a> newtype Foo a = Foo a; Foo undefined is undefined
13:36:27 <latro`a> knew this ages ago
13:36:36 <geekosaur> if you optimize it away you may be introducing strictness where it is not wanted
13:36:49 <latro`a> yes, I remember now
13:36:57 <c_wraith> latro`a: consider: instance Monad Identity where return = Identity ; (Identity x) >>= f = f x
13:37:02 <latro`a> so is data Foo a = Foo !a just dumb?
13:37:20 <c_wraith> latro`a: the semantics of that monad instance vary greatly depending on whether Identity is defined as data or a newtype
13:37:27 <latro`a> yeah I see that
13:37:29 <Pods> could i merge multiple types in a newtype ??, say define a newtype which constitues of strings as well as integrals??
13:37:48 <LambdaDusk> Pods: Nope, that's what data is for
13:37:52 <monoidal> Pods: newtypes can have only one constructor
13:38:07 <Pods> okay
13:38:11 <LambdaDusk> Pods: one constructor with one parameter
13:38:12 <Pods> got it :)
13:38:57 * tgeeky finds the language on HaskellWiki's keywords page confusing with respect to these two. 'type' starts The newtype declaration is how one introduces a renaming for an algebraic data type into Haskell.
13:39:02 <tgeeky> ...
13:39:08 <tgeeky> newtype => The newtype declaration is how one introduces a renaming for an algebraic data type into Haskell.
13:39:15 <tgeeky> type => The type declaration is how one introduces an alias for an algebraic data type into Haskell.
13:39:45 <Pods> tgeeky : good to see the same emotion flooding :D
13:40:04 <tgeeky> I mean, I thought I understood them both, but I never use 'type', and have really only used 'data'.
13:40:09 <merijn> Pods: THe simplest answer is that you should just use type and data and when you finally need newtype it'll probably feel completely obvious (at least, that was my experience)
13:40:27 <tgeeky> From my perspective, OTHER people use newtype when they know what's best :o
13:41:11 <Pods> merijn : point noted :)
13:41:21 <merijn> tgeeky: type mostly makes sense if you have a function type that occurs frequently and thus needs to be repeated in all sorts of signatures
13:41:32 <merijn> It avoids annoying parenthesis, etc
13:41:41 <indrek> I have 3 lists. [1], [2, 4], [3]. What is the easiest way to get all possible combinations so that one element from each list is used? e.g [1, 2, 3], [1, 4, 3]
13:41:44 <sproingie> newtype seems most useful as a subtype mechanism
13:41:55 <tgeeky> merijn: and then I could just later use newtype when I want the same structure, but just under a different name
13:42:00 <tgeeky> ?
13:42:18 <sproingie> got two things taking an Int but want to differentiate them anyway?  wrap a newtype around it.  that sort of thing.
13:42:24 <merijn> tgeeky: "I want the same structure, but want to encode some operational difference in the type"
13:42:46 <monoidal> > sequence [[1], [2,4],[3]] --indrek
13:42:46 <merijn> tgeeky: I really like the String/SafeString example of strings that have dangerous characters escaped
13:42:47 <lambdabot>   [[1,2,3],[1,4,3]]
13:43:18 <LambdaDusk> Haskell is hard until you understood it then you wonder why you've been so stupid
13:43:19 <merijn> tgeeky: Clearly it's just a string, but using "type" would let you accidentally hand unescaped strings to something expecting escaped strings
13:43:21 <tgeeky> merijn: yes, that's alon the lines of my thought. I have a type already, but I want another which appears to be identical, but is (probably) internally different, and which *can not* be mixed.
13:43:56 <merijn> tgeeky: Yeah, that's the usualy case for newtypes, together with recursive types
13:44:16 <merijn> i.e. "newtype Interpeter a = a -> IO (Interpreter a)"
13:44:27 * tgeeky thinks he should look at the report to make sure he is thinking correctly.
13:44:32 <merijn> That type signature would otherwise report infinitely
13:45:16 <sproingie> i read something about fixpoint types that address that sort of thing
13:45:33 <sproingie> cant remember where i found it
13:45:34 <elliott> merijn: you're missing a constructor name there :)
13:45:48 <merijn> elliott: My bad
13:47:13 <elliott> sproingie: isorecursive vs. equirecursive?
13:48:53 <sproingie> elliott: might be some way, but it's beyond me
13:51:04 <sproingie> oddly the fix point type made a lot more sense to me than the fix function itself
13:51:27 <sproingie> the one time type level programming was actually clearer to me
13:51:41 <sproingie> unfortunately the concept was too slippery to stay in my head
13:52:15 <sproingie> i rememver monads were like that for years for me
13:53:12 <skyflash> Anyone here used the "plugins" library?  Trying to use 'eval' with the simple example included in the docs and getting "Warning: -fglasgow-exts is deprecated..." in the output (which apparently fails the whole eval)
13:54:41 <monoidal> skyflash: -fglasgow-exts is equivalent to several other flags
13:55:01 <monoidal> ah, I misunderstood
13:55:18 <parcs> @src Mu
13:55:18 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
13:55:36 <PuercoPop> One question, don't closures require a dynamic state? (Apparently not as haskell has them http://www.haskell.org/haskellwiki/Closure). How does that work?
13:56:48 <skyflash> yes, clearly the plugins library sends the source you present to 'eval' off to the compiler, and I imagine the current version of plugins also attaches the -fglasgow-exts flag.  I wonder if I can turn that off without amending the plugins library.
13:57:09 <merijn> PuercoPop: Why do closures require dynamic state?
13:57:28 <geekosaur> the preserved scope can be seen as a kind of dynamic state
13:57:31 <merijn> PuercoPop: All data is immutable in haskell, so after creating the closure the entire closure is immutable...
13:57:36 <tgeeky> skyflash: I'm looking at it now. That should only incur a warning, anyway... which shouldn't stop eval.
13:57:51 <PuercoPop> merijn don't they need keep a pointer to the current value of the variable?
13:58:06 <geekosaur> dynamic in the sense of created when needed, not in the sense of mutable
13:58:15 <merijn> PuercoPop: Sure, but that's an internal implementation detail
13:58:25 <sproingie> they could in fact copy it if they wished
13:58:28 <skyflash> tgeeky: Thanks!  That's what I thought too, but I clearly get "Nothing" back from eval (or strictly: IO Nothing).
13:58:35 <sproingie> (they don't, but you can imagine they do)
13:59:02 <PuercoPop> aren't you keeping 'state' in the variable? Doesn't that violate referential transparenty?
13:59:04 <merijn> PuercoPop: Internally the compiler can mutate whatever it likes
13:59:14 <sproingie> haskell variables don't vary
13:59:30 <merijn> PuercoPop: How does it violate referential transparency? Every time you call the closure it produces the same output, no?
13:59:42 <danharaj> Would anyone happen to know if there is a package that defines applicative operations on Vectors? Because the base package only has monadic operations and they can't be used to define a traversal. I would rather not convert to and from lists.
13:59:54 <PuercoPop> merijn: let me give you an example, sec
14:00:11 <edwardk> danharaj: are they not in vector or vector-instances?
14:00:24 <elliott> danharaj: do you mean like mapM?
14:00:27 <PuercoPop> merijn: sorry I just read the example I was thinking of and I was doing assignment
14:00:32 <elliott> lens has traversals for vectors, at least
14:00:34 <geekosaur> haskell doesn't really have variables, it has bindings. (the difference is, a variable is a container you can put things in, a binding is a bit of accounting information saying where to find something)
14:00:37 <PuercoPop> merijn: thanks for clearing it up
14:00:43 <danharaj> edwardk: Boxed vectors have traversals but unboxed do not because of the constraint.
14:01:10 <danharaj> elliott: pretty much
14:01:11 <merijn> PuercoPop: np :)
14:01:13 <edwardk> danharaj: try 'each'
14:01:25 <danharaj> :t each
14:01:27 <lambdabot> (Indexable (Index t) p, Each f s t a b) => p a (f b) -> s -> f t
14:01:40 <edwardk> > [1..10]^..each.filtered even
14:01:42 <lambdabot>   [2,4,6,8,10]
14:01:46 <danharaj> edwardk: has anyone told you how violent lens signatures are
14:01:48 <tgeeky> skyflash: can you try someting simpler, to see if the code you are trying is genuinely failing to typecheck?
14:01:51 <edwardk> =)
14:01:53 <edwardk> a few
14:02:16 <edwardk> i can no longer even hear their screams
14:02:35 <dEPY> how long does it take to memorize and get used to haskells syntax?  there's alot of variations of doing stuff :S
14:02:56 <danharaj> edwardk: one day you must teach me how to read those signatures.
14:02:57 <merijn> dEPY: The syntax not so long, the operators from common libraries? Slightly longer
14:03:12 <merijn> dEPY: But Hoogle and GHCi are usually quick ways to figure out what things are doing
14:03:21 <edwardk> danharaj: to a first approximation assume 'p' = (->)
14:03:22 <tgeeky> edwardk: fstab? Get your lenses out of my fstab!
14:03:48 <dEPY> merijn: I hope so.. :D
14:04:01 <edwardk> tgeeky: you get 'stab' 'pabst' and all sorts of fun combinations out of lens. i'm pretty sure i had it all but say 'i m a s t a b u'  and i walked away
14:04:48 <merijn> dEPY: There's a nice haskell cheat sheet on http://cheatsheet.codeslower.com/
14:05:38 <geekosaur> 2remember edwardk
14:05:39 <danharaj> edwardk: sometimes the errors you get for using indexed stuff explode into spectacular pages of unsolvable constraints.
14:08:10 <dEPY> merijn: thanks, that will be usefull. :)
14:08:18 <merijn> @hoogle Monad m => (a -> b -> m c) -> m a -> m b -> m c
14:08:19 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
14:08:19 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
14:08:19 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
14:08:24 <merijn> :(
14:08:57 <niteria> :t liftM
14:08:59 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
14:09:08 <niteria> :t liftM2
14:09:09 <merijn> niteria: liftM and fmap lift the result too
14:09:09 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:09:29 <danharaj> edwardk: and the best part is when I solve the type error and the code just works and I have no idea what I am doing still ;)
14:09:36 <merijn> I wanted <$> and <*> where the result is already a monad of itself :p
14:10:06 <edwardk> hah, we should sit down and do a crash course in what it all means at some point
14:11:10 <niteria> :t join . liftM2
14:11:11 <lambdabot> Monad m => (a1 -> a1 -> r) -> m a1 -> m r
14:11:23 * hackagebot bound 0.7 - Making de Bruijn Succ Less  http://hackage.haskell.org/package/bound-0.7 (EdwardKmett)
14:11:27 <merijn> edwardk: The two hour talk on lens/traversal/fold was nice, now I just need one for prisms and all the other new indexed stuff :p
14:11:29 <danharaj> edwardk: took a peak at the Each instance for unboxed vectors and it looks like it converts to and back from a list. I am not sure that is as performant as possible. I'll probably do a profile *eventually*.
14:11:37 <monoidal> :t \f x y -> join (liftM2 f x y)
14:11:38 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
14:11:50 <niteria> yeah, that's what I wanted
14:11:57 <danharaj> edwardk: I am afraid of the possibility that it actually creates the list instead of deforesting it.
14:12:06 <edwardk> danharaj: i don't think you can do anything better, because we don't get anything out of vector that works with applicatives
14:12:13 <edwardk> the streaming machinery is all monad-specific
14:12:32 <danharaj> edwardk: yes it is deeply unfortunate. I spent about 30 minutes seeing if I could do something by hand.
14:13:28 <edwardk> danharaj: maybe take a look at the Control.Lens.Internal.ByteString module which bends over backwards to make bytestrings perform
14:13:48 <edwardk> if we did the same thing for vectors you could get log time indexing to jump around in them like i give you in bytestrings
14:14:01 <edwardk> and you could get a slightly better story than the naive list
14:14:15 <edwardk> expect a very unsafe ratsnest though
14:14:54 <danharaj> edwardk: Sounds like the path of lesser resistance would be to just write mutable vector code when I need tighter performance.
14:15:22 <edwardk> danharaj: i still do
14:15:41 <danharaj> edwardk: that's the one area of code lens doesn't scratch for me.
14:15:43 <edwardk> the analytics code has a fair bit of mixed lens/traditional vector code
14:16:04 <danharaj> since it's not possible to write monadic loops as lenses.
14:16:05 <edwardk> take a look at say the HyperLogLog code in analytics for examples
14:16:28 <danharaj> edwardk: will do right now actually. I am rewriting my vector code as we speak.
14:16:45 <edwardk> also Data.Analytics.Numeric.Moments iirc
14:17:06 <edwardk> http://rebase.org/analytics/src/Data-Analytics-Numeric-Moments.html#Moments
14:17:11 <edwardk> not my prettiest code
14:18:14 <edwardk> and http://rebase.org/analytics/src/Data-Analytics-Approximate-HyperLogLog-Type.html#HyperLogLog
14:19:47 <danharaj> edwardk: when and why would one use the `inline` primitive instead of relying on pragmas?
14:20:52 <edwardk> if you have two occurrences of a value in a term, it isn't 'work safe' to inline it so, ghc won't typically unless it is trivial. so if you have two uses of a continuation that get used very differently inlining can copy the continuation like you'd duplicated the code by hand
14:21:31 <danharaj> edwardk: oh that's really good to know
14:44:44 <lww5064> would anyone have use for a WSDL library in Haskell? i don't have any code to offer, i'm afraid, but it could be a neat project
14:44:52 <lww5064> HAIFA was a previous attempt, but it's been stalled since 2006: http://staffwww.dcs.shef.ac.uk/people/S.Foster/HAIFA.html
14:55:44 <merijn> There's no way to silence a single "missing top-level signature" warning without actually writing said signature, right?
14:55:56 <otters> right
14:56:30 <hpaste> “Anonymous Coward” pasted “<<loop>>” at http://hpaste.org/84523
14:56:47 <shachaf> Is that supposed to <<loop>>?
14:56:47 <merijn> Bah :\
14:57:19 <mgsloan> There ought to be an "Undefined" type, or type holes.  That'd be sweet
14:57:30 <merijn> mgsloan: I know, right?
15:06:00 <skyflash> tgeeky: Thanks!  That's what I thought too, but I clearly get "Nothing" back from eval (or strictly: IO Nothing).
15:06:31 <skyflash> tgeeky:As it happens, the thing I tried was cut and pasted directly from docs.  But, we'll see...
15:06:36 <tac> skyflash: "IO Nothing" doesn't really make sense :)
15:06:56 <tac> Maybe you meant "return Nothing" which has type "IO (Maybe a)"
15:10:01 <skyflash> tac: No, I meant that the result of System.Eval.Haskell.eval is IO (Maybe a) and because something about the compilation, linking, loading or typechecking is failing, I am getting Nothing as the inner value.
15:11:31 <_g> can someone help me understand ***
15:11:40 <aCube> :t (***)
15:11:41 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
15:11:56 <_g> generally i am trying to understand https://github.com/cutsea110/yesod-csv-tutorial/blob/master/Csv.hs
15:12:04 <_g> i guess my problem is maybe not understanding what an Arrow is
15:12:24 <danharaj> instantiate a to (->) to get an intuition for that fundamental case
15:12:25 <aCube> Arrows are like functions. They have an input and an ouput
15:12:31 <mauke> _g: is your name really _g?
15:13:01 <_g> i read in the documentation that *** splits two inputs into two arrows and combines their output
15:13:02 <merijn> aCube: I think you mean "functions are like Arrows" :)
15:13:09 <_g> mauke: that is a weird question
15:13:10 <aCube> (+4) *** (*3) $ (2, 3)
15:13:12 <aCube> > (+4) *** (*3) $ (2, 3)
15:13:12 <_g> i don't know how to answer
15:13:14 <lambdabot>   (6,9)
15:13:26 <mauke> _g: you have passed the turing test
15:13:33 * cmccann suggests that Arrows are like Arrows, at least most of the time
15:13:42 <monoidal> _g: (f *** g) (x,y) = (f x, g y)
15:13:42 <mauke> named after alan test
15:14:08 <aCube> it applies the first arrow to the first element of the pair, the second one to the second :D
15:14:13 <_g> monoidal: oh.. okay that makes sense.
15:14:39 <_g> great.  demystified
15:15:00 <_g> mauke: i don't think ic an pass the turing test.. since i am not a program
15:15:01 <merijn> _g: Alternatively, as danharaj suggested, mentally replace a with "(->)" turning it into
15:15:04 <merijn> :t (***)
15:15:06 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
15:15:07 <monoidal> _g: (***) is bit more general than this (applies to arrows), but this case is the most intuitive and most used one
15:16:02 <merijn> "a b c -> a b' c' -> a (b, b') (c, c')" becomes "(->) b c -> (->) b' c' -> (->) (b, b') (c, c')" becomes "(b -> c) -> (b' -> c') -> (b, b') -> (c, c')"
15:16:27 * hackagebot linear 1.1.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.1.1 (EdwardKmett)
15:16:42 <_g> well that makes sense that they are called arrows then
15:17:05 <_g> for a language that "wants to avoid success at all costs" #haskell is ridiculously helpful
15:18:33 <merijn> @quote megahelpful
15:18:33 <lambdabot> MyCatVerbs says: [talking about #haskell] seriously, it's like the entire planet got mutant powers and many all the people here just happened to get Psychic MegaHelpFulness.
15:18:37 <cmccann> we're very good at not succeeding at helping other people avoid success
15:20:41 <cmccann> heh, nullary type classes
15:21:41 <crdueck> I want to do something like: let rep = typeOf 4 in read "4" `asTypeOf` rep. obviously this doesnt work, is it possible to use a TypeRep to tell GHC the type of (read x)?
15:22:17 <monochrom> read "4" `asTypeOf` 4
15:22:32 <crdueck> monochrom: that works, but i dont have a literal 4, i have a TypeRep
15:22:37 <shachaf> cmccann: I blame ddarius.
15:22:50 <skyflash> tgeeky: eval "1.0 :: Double" [] :: IO (Maybe Double) -- prints -fglasgow-exts warning and clearly returns IO (Nothing)
15:22:57 <cmccann> shachaf: you created the ticket, though.
15:23:14 <tgeeky> skyflash: that is simpler, certainly.
15:23:21 <shachaf> cmccann: But ddarius created me!
15:23:44 <tgeeky> skyflash: I lied a bit. I looked at the package for a few minutes, but then realized I don't have GHC installed right now, so I can't help much.
15:23:52 <cmccann> shachaf: is that so
15:24:05 <monochrom> then I don't see a way. try to not have a TypeRep
15:24:40 <mm_freak> does it make sense to use a Text Builder when building texts in the style of ShowS?
15:24:41 <skyflash> tgeeky:Oh, OK.  NP.  I'll just need to roll up my sleeves.  It's always worth asking first though in case someone just knows what you're doing wrong!
15:24:44 <parcs> crdueck: the type system is tooo weak
15:25:02 <mm_freak> like pretty :: (Pretty a) => Int -> a -> Builder -> Builder
15:25:18 <mm_freak> or could i just as well use Text here?
15:25:34 <_g> can i give an alias to Data.Text (or whatever) in the ghci prompt
15:25:44 <mm_freak> _g: since GHC 7 yes
15:25:55 <monochrom> yes, import Data.Text as MonochromModule
15:25:56 <mm_freak> just type MyType = Text
15:25:57 <_g> lucky me i have 7.4
15:26:08 <mm_freak> oh
15:26:15 <mm_freak> well, same answer
15:26:18 <mm_freak> since GHC 7 =)
15:26:24 <mm_freak> what monochrom said
15:31:14 <_g> so, https://github.com/cutsea110/yesod-csv-tutorial/blob/master/Csv.hs#L156  is where I am at in trying to understand this file.. and i have
15:31:25 <_g> (id *** (T.split (==',') . T.tail)) . T.break (==':') (pack "something:foo,bar")
15:31:44 <mauke> that looks pointless
15:32:02 <mauke> id *** is second
15:32:06 <ClaudiusMaximus> crdueck: afaik it's impossible, because 1. you'd need a primitive to get the type back out from a TypeRep (it could be 'withTypeRepType :: TypeRep -> (forall t . t -> r) -> r') and that primitive doesn't exist, and 2. then  'withTypeRepType tr (\t -> read "4" `asTypeOf` t)' allows the forall'd type to escape its scope (which is an error)
15:32:09 <monochrom> then you probably do not need to know Arrow in full generality, just need to know functions are a special case.
15:32:29 <monoidal> does GHC allow to reify non-equality? as in, define class A a b where f :: a ~ b => a -> b, and then I want to define instance A Int Bool
15:32:39 <_g> but am getting T.break is applied to too many arguments, which i believe.  but, am under the impression i am sending break two arguments, which is what i thought it wanted
15:33:03 <mauke> three, actually
15:33:14 <monoidal> where the implemention of f is vacuous
15:33:14 <monochrom> "f *** g" is a way to say "\(x,y) -> (f x, g y)" in this special case
15:33:17 <mauke> inline (.)
15:33:20 <_g> mauke: it is maybe pointless?  that line is me trying to "guess" that "something:foo,bar" will turn into ("something", ["foo", "bar"])
15:36:36 <crdueck> ClaudiusMaximus: thanks, its unfortunate that I cant get the behaviour I want, but thats a satisfying answer none the less
15:38:06 <_g> monoidal: i think i get that now.  i am using it with ID up there.. beause at first i had (T.split (==',') . T.tail) (pack "foo, bar")  and that seemed to do something not helpful for what i thought the function `records` was wanting to do
15:38:10 <cmccann> monoidal: you probably can't write any such "f"
15:38:29 <cmccann> monoidal: but you can write an instance with no "f"
15:38:31 <monoidal> cmccann: but it's a limitation of GHC, right?
15:38:46 <cmccann> monoidal: it's what ~ means
15:39:17 <elliott> monoidal: you can
15:39:20 <cmccann> if you have a constraint "a ~ b" and a and b are different types that's an error
15:39:20 <elliott> monoidal: with type families
15:39:24 <shachaf> cmccann: You should decide whether the thing is a bug or not.
15:39:35 <cmccann> shachaf: which thing
15:39:37 <shachaf> http://hpaste.org/84523
15:40:07 <elliott> monoidal: type family Choose a b; type instance Choose Int a = (); type instance Choose Bool a = a
15:40:17 <shachaf> cmccann: Also you should tell me what a minimal extension is that lets you write Is Char Bool -> Void
15:40:25 <cmccann> monoidal: the most you can do is sneak around and make sure GHC never tries to check anything where the types are known unequal
15:40:26 <elliott> monoidal: hmm :: a ~ b => Choose a r -> Choose b r; hmm x = x
15:40:27 <elliott> f = hmm ()
15:40:30 <elliott> or such
15:40:44 <monoidal> cmccann: but a value of type C => a, where C is unsatisfable, obviously exists. there's little access to it
15:40:47 <elliott> cmccann: no, you actually can derive contradiction from two concrete inequal types in GHC
15:40:57 <elliott> http://stackoverflow.com/questions/14273235/can-gadts-be-used-to-prove-type-inequalities-in-ghc
15:41:08 <shachaf> Only with GADTs or TypeFamilies.
15:41:18 <monoidal> elliott: thanks, very interesting
15:41:23 <elliott> right. but if (a ~ b) is in, then GADTs or TypeFamilies are in
15:42:26 <cmccann> elliott: it's one of those things where you can only do it indirectly
15:43:58 <cmccann> just like a lot of other crap you sneak through with GADTs or Constraint kinds or whatever else
15:47:10 <cmccann> shachaf: also that looks like a bug to me
15:47:56 <cmccann> shachaf: can you get the same thing to happen with code that is even halfway plausible?
15:49:08 <shachaf> cmccann: I reduced this from a real test case.
15:49:15 <cmccann> ok then.
15:49:22 <shachaf> aCube's paste from before.
15:49:39 <shachaf> cmccann: The nasty part is that there was a situation where hand-inlining a function turned a <<loop>> into undefined.
15:49:54 <cmccann> fun!
15:49:57 <shachaf> But I don't want to try to reproduce that if this is enough of a bug because it's really annoying.
15:57:01 <monoidal> here's a slightly crazy idea of using nullary type classes
15:57:21 <monoidal> define class Absurd where absurd :: a and instances like (Int ~ Bool) => Absurd
15:57:52 <monoidal> now each time the context is contradictory you can use 'absurd' and the constraint solver would find it, bit like unreachable in agda
16:00:15 <monoidal> I really like nullary type classes, but I think GHC needs even more extensions to leverage them
16:00:47 <cmccann> -XLanguageAgda
16:02:00 <x7a1c0b> Why is it that most function's type signature is like this: length :: [a] -> Int and not like this: length :: (Integral b) => [a] -> b
16:02:26 <monoidal> x7a1c0b: historical accident, Prelude is old. for length, you can use genericLength
16:02:45 <shachaf> Note that genericLength is pretty much only useful for lazy naturals.
16:02:54 <dmwit> > let x :: Int ~ Bool => a; x = 3 in "does this typecheck?"
16:02:56 <lambdabot>   Couldn't match type `GHC.Types.Int' with `GHC.Types.Bool'
16:02:56 <lambdabot>  Inaccessible cod...
16:02:56 <shachaf> Otherwise you probably want to use (fromIntegral . length) instead.
16:04:11 <monoidal> dmwit: IMO it should typecheck, but with a warning
16:05:53 <srhb> Why Int, though?
16:06:09 <srhb> What if I have an insane amount of RAM? :-)
16:06:26 <shachaf> > 2^64
16:06:28 <lambdabot>   18446744073709551616
16:06:36 <srhb> That much, yes!
16:06:51 <cmccann> who says the whole list needs to be in memory at once, anyhow?
16:06:55 <srhb> True.
16:07:00 <shachaf> The question isn't about how much RAM you have but how long it'll take.
16:07:04 <srhb> Yeah.
16:07:11 <srhb> I was just being silly. I don't see any real use cases :P
16:07:30 <cmccann> srhb: arguing with shachaf is a valid use case
16:07:35 <shachaf> Anyway, if you have a list that long, you *certainly* don't want genericLength.
16:07:40 <srhb> cmccann: Point.
16:07:42 <shachaf> @src genericLength
16:07:42 <lambdabot> genericLength []    = 0
16:07:42 <lambdabot> genericLength (_:l) = 1 + genericLength l
16:08:00 * shachaf vanishes.
16:08:44 <Hermit> what an idiotic implementation
16:09:01 <dmwit> What's wrong with it?
16:09:04 <srhb> Why?
16:09:08 <Hermit> it's not tail recursive
16:09:24 <Hermit> unless ghc optimizes that too...
16:09:34 <c_wraith> No, but there are cases it's the correct implementation for.
16:09:34 <aristid> Hermit: if it was, it would break for lazy naturals
16:09:39 <dmwit> Tail recursion doesn't work like that in GHC.
16:10:34 <Hermit> aristid: length collapses a list into a single value, so why should it be lazy?
16:11:04 <dmwit> Hermit: In case you want to do something like compare it to (say) 3.
16:11:19 <startling> is there a class like class IndexedWith f k | f -> k where enumerate :: f a -> [(k, a)] somewhere?
16:11:25 <dmwit> If the list is longer than 3, and the length value is lazy, it may not need to look at the real length of the list and can stop iterating at the third cons cell.
16:11:43 <Hermit> dmwit: are you saying it will sum the length until it goes beyond the other number?
16:11:53 <dmwit> startling: That looks vaguely like the Key type family from, I think, "keyed".
16:11:55 <aristid> i suppose the optimal implementation of length very much depends on the number type
16:12:07 <cmccann> Hermit: if your number type is lazy, length can be lazy
16:12:08 <dmwit> ?hackage keys
16:12:08 <lambdabot> http://hackage.haskell.org/package/keys
16:12:22 <Hermit> holly...
16:12:26 <dmwit> Hermit: Correct, you can write an implementation of numbers where genericLength does something useful even for infinite lists.
16:12:29 <cmccann> for example, [()] can be used to represent natural numbers
16:12:43 <dmwit> I think I just wrote a StackOverflow post about this, actually.
16:12:48 <cmccann> "length" would then be "map (const ())".
16:13:14 <srhb> cmccann: *brainmelt* -- how?
16:13:15 <dmwit> http://stackoverflow.com/a/15469985/791604 <- though I don't explicitly use genericLength in here
16:13:26 <roadfish> @src (,) fmap
16:13:26 <lambdabot> fmap f (x,y) = (x, f y)
16:13:29 <srhb> > map (const ()) [(), (), ()]
16:13:31 <lambdabot>   [(),(),()]
16:13:38 <dmwit> srhb: data Nat = Zero | Succ Nat; data [()] = [] | (:) () [()]
16:13:40 <startling> dmwit: oh, hm, I guess it just does need to be an indexed fold. I hadn't thought of that.
16:13:40 * srhb boggles
16:13:43 <dmwit> srhb: See the parallel?
16:13:51 <aristid> srhb: it's unary
16:13:52 <startling> Doesn't lens have some stuff to do that? I think so
16:13:53 <srhb> Yes, sure, ok.
16:14:07 <roadfish> is this correct? does fmap have this instance for (,)? ... fmap f (x,y) = (x, f y)
16:14:14 <Hermit> I didn't expect this, but I like it. Now I can write non tail-recursive algorithms without remorse
16:14:16 <dmwit> roadfish: correct
16:14:24 <startling> roadfish: I think it might not be imported by default
16:14:25 <srhb> I forgot that that's the number type we get out of it as well
16:14:26 <aristid> compare data List a = Nil | Cons a (List a) with data Nat = Zero | Succ Nat
16:14:28 <dmwit> > fmap (+1) (0, 10)
16:14:29 <srhb> Of course, it's also just id. :P
16:14:30 <lambdabot>   (0,11)
16:14:30 <monoidal> roadfish: yes
16:14:32 <roadfish> but why isn't it ... fmap f (x,y) = (f x, f y)
16:14:40 <startling> roadfish: never mind, it is imported.
16:14:54 <dmwit> roadfish: Try to write the type of the function "foo f (x, y) = (f x, f y)".
16:14:55 <startling> roadfish, that would require both types of the pair to be equal
16:15:28 <roadfish> my ghci says: No instance for (Functor ((,) t0))
16:15:31 <fizbin> roadfish: the Functor instance is defined as "instance Functor (,) a"
16:15:39 <monoidal> roadfish: which ghc?
16:15:48 <roadfish> 7.4.1
16:15:56 <monoidal> hm, 7.6 has it
16:16:20 <startling> my 7.4.2 has it
16:16:21 <fizbin> roadfish: import Control.Monad.Instances
16:16:22 <roadfish> I did import Data.Functor ... still get the error
16:16:41 <dmwit> My ghci says "instance Functor ((,) a) -- Defined in `GHC.Base'"
16:16:45 <startling> roadfish, what code says that?
16:16:48 <roadfish> fizbin: ok, thanks, I'm getting this now
16:16:51 <dmwit> Though there's undoubtedly other modules that re-export this instance.
16:16:55 <fizbin> Control.Monad.Instances is my go-to import when I'm missing an instance.
16:17:10 <startling> heh
16:17:44 <roadfish> startling: why do you ask my "what code says that"?
16:17:51 <roadfish> s/my/m.
16:17:54 <roadfish> s/my/me
16:18:38 <startling> roadfish, maybe you're doing something crazy with an ambiguous error message
16:19:37 <roadfish> startling: ok, I see what you're saying ... why I type "fmap (+1) (0, 10)" then I get: No instance for (Functor ((,) t0))
16:19:44 <roadfish> this is for 7.4.1
16:20:00 <roadfish> but then I import Control.Monad.Instances ... an the error goes away
16:20:09 <startling> roadfish: sounds right
16:21:08 <c_wraith> I guess that module wasn't empty until ghc 7.6
16:22:22 <monoidal> roadfish: note the type of fmap is (a -> b) -> f a ->  f b
16:22:45 <monoidal> now if you put f = (,) c you get (a -> b) -> (,) c a -> (,) c b - which is the same as (a -> b) -> (c,a) -> (c,b)
16:23:12 <monoidal> that's why fmap modifies the second coordinate
16:27:44 <arkeet> :t over both
16:27:45 <lambdabot> (a -> b) -> (a, a) -> (b, b)
16:28:29 <roadfish> actually, if my application, I wanted the behavior of your "both".
16:29:08 <monoidal> roadfish: you can use f *** f
16:29:13 <roadfish> that's why I expected (f x, f y)
16:29:44 <c_wraith> roadfish: you can actually tell it won't work that way from the kinds involved, if you look carefully
16:30:10 <c_wraith> data (,) a b = (,) a b  -- more or less
16:30:23 <c_wraith> The Functor instance needs the kind * -> *
16:30:37 <c_wraith> So it needs to be instance Functor ((,) a) where ...
16:30:55 <c_wraith> But that means that the functor instance has to be polymorphic over all types for a
16:31:16 <c_wraith> And because of that, it can't do anything with the first component of the tuple, no matter what type it is
16:31:36 <roadfish> my kind-fu is kind-of weak. ok, I think I'm getting it. My (fx,fy) would drop one of the types. Kind of information loss.
16:31:49 <roadfish> a typal-info-loss
16:31:52 <thorsten`> > :type (++"]" $ show)
16:31:53 <lambdabot>   <hint>:1:1: parse error on input `:'
16:31:56 <c_wraith> compare to a type like..
16:31:58 <monoidal> roadfish: if you define data Pair a = Pair a a, then the functor instance would change both components at once
16:32:10 <thorsten`> :type (++"]" $ show)
16:32:33 <monoidal> thorsten`: you might be wanting ((++"]") . show)
16:32:39 <Hermit> t (++"]") . show
16:32:44 <Hermit> damn
16:32:48 <c_wraith> also, to get the command right :)
16:33:00 <thorsten`> i thought . is identical to $, but $ has a lower precedence (0)
16:33:00 <Hermit> :t (++"]") . show
16:33:02 <lambdabot> Show a => a -> [Char]
16:33:27 <monoidal> thorsten`: no, (.) is composition, while $ is application. f $ x = f x and (f.g) x = f (g x)
16:33:34 <Hermit> thorsten`: $ is function application, while . is function composition
16:33:48 <Hermit> monoidal: ok, you answer :-)
16:33:51 <roadfish> :t over both
16:33:52 <lambdabot> (a -> b) -> (a, a) -> (b, b)
16:34:01 <roadfish> :t over
16:34:02 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
16:34:13 <thorsten`> ah ok, i see, thanks
16:34:13 <roadfish> :t both
16:34:15 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
16:34:25 <monoidal> > (++"]") $ show $ 1
16:34:27 <lambdabot>   "1]"
16:34:36 <monoidal> > ((++"]") . show) 1
16:34:38 <lambdabot>   "1]"
16:35:52 <thorsten`> ah ok. it has a different associativity
16:36:34 --- mode: ChanServ set -o glguy
16:37:17 <roadfish> arkeet: what is this ":t over both"? is it asking the type of "over both"? I see neither over nor both.
16:37:25 <arkeet> over and both are from lens.
16:37:54 <arkeet> @where lens
16:37:54 <lambdabot> http://lens.github.com/ https://github.com/ekmett/lens http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
16:39:02 <sipa> :t ($)
16:39:03 <lambdabot> (a -> b) -> a -> b
16:39:07 <sipa> :t (.)
16:39:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:39:21 <arkeet> cale :(
16:40:29 <roadfish> ouch, I just did "hoogle --info lens" and it gave a long 14K line ... Tag "http://i.imgur.com/FgfVW.png</a" [Char '>',Char...etc
16:41:10 <Kindaro> Hi. I remember stumbling on a [4-part, if I remember correctly] video on Youtube that explains and exemplifies using Haskell as a unix shell scripting language. I can't seem to find it now, could someone help?
16:41:42 <arkeet> haha
16:42:01 <roadfish> Kindaro: sounds good.
16:42:02 <arkeet> er, that was at roadfish.
16:43:21 <roadfish> arkeet: did you get tihs error too?
16:43:34 <arkeet> roadfish: I didn't try.
16:44:48 <parcs> dilbert on dongles (2005): http://i.imgur.com/vK1wQhs.png
16:45:07 <arkeet> roadfish: looks like a hoogle problem.
16:47:14 <haskell_noob> hey guys, how would i go about splitting a list into two smaller lists, and sorting each sub-list?
16:47:36 <_g> can i tell ghci to automatically treat "quoted strings" a Text rather than [Char]
16:47:51 <x7a1c0b> haskell_noob quicksort?
16:48:08 <donri> _g: no, but you can tell it to treat string literals as IsString a => a for which Text has an instance
16:48:19 <donri> _g: :set -XOverloadedStrings
16:48:30 <johnw> haskell_noob: you can use the function 'partition' and recursion, once you chosen your pivot element
16:48:31 <x7a1c0b> haskell_noob http://www.haskell.org/haskellwiki/Introduction#Quicksort_in_Haskell
16:48:46 <_g> donri: thanks.
16:48:55 <haskell_noob> thnx guys ill look into it :P
16:49:11 <roadfish> haskell_noob: there is also partition
16:49:19 <roadfish> but doesn't sort
16:49:37 <roadfish> :t partition
16:49:38 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
16:50:26 <haskell_noob> i created a halve function [a] -> ([a], [a]) just dont know where to go from there considering the syntax and the sort function
16:52:08 <lemao_> What is the best way to create an haskell package that wraps a shared library in C?
16:52:15 <arkeet> haskell_noob: well, once you have a pair of smaller lists, you can recursively sort them, and then merge them together to get a sorted big list.
16:52:39 <roadfish> haskell_noob: (sort x,sort y) where (x,y) = partition (<5) [3,7,4,6]
16:52:53 <roadfish> you have to import Data.List
16:54:02 <roadfish> and if fmap worked the way I wanted, then you could shorten the code
16:54:42 <roadfish> > (sort x,sort y) where (x,y) = partition (<5) [3,7,4,6]
16:54:44 <lambdabot>   <hint>:1:17: parse error on input `where'
16:55:12 <Thra11_> Suppose there is a module Foo, which exports two functions, x and y, and x calls y. If I import Foo hiding (y), then I define my own y, does x call my y or Foo.y?
16:55:44 <dmwit> Foo.y
16:55:49 <dmwit> What is this, elisp?
16:56:08 <dmwit> Lexical scoping is the only sane scoping.
16:56:33 <path[l]> haha
16:56:36 <roadfish> I read that emacs24 is introducing lexical scoping
16:56:37 <path[l]> I like that statement
16:57:12 <Hermit> dmwit: how about implicit parameters?
16:57:31 <dmwit> How about them!
16:57:32 <Thra11_> dmwit, ok. So to make a small modification to the behaviour of a module, I need to make a copy of Foo, and modify y in the copy?
16:57:54 <dmwit> Ew, no, let your function take y as a parameter if you need to change y a lot.
16:58:01 <Hermit> dmwit: I meant what do you think about them
16:58:10 <dmwit> I haven't found a use for them yet.
16:58:51 <arkeet> ImplicitParams is good for holes.
16:58:55 <path[l]> well if you have a ton of parameters then it might make sense. but named params solves that problem anyway
16:59:21 <Hermit> arkeet: what do you mean?
16:59:22 <haskell_noob> roadfish: sortEm :: ([a], [a]) -> [a]
16:59:37 <arkeet> Hermit:
16:59:43 <arkeet> :t foldr ?f ?z
16:59:44 <lambdabot> (?f::a -> b -> b, ?z::b) => [a] -> b
16:59:54 <haskell_noob> ok how do you copy and paste in here? :P
17:00:02 <arkeet> @hpaste -- haskell_noob
17:00:02 <lambdabot> Haskell pastebin: http://hpaste.org/
17:00:06 <path[l]> s
17:00:35 <haskell_noob> @hpaste
17:00:35 <lambdabot> Haskell pastebin: http://hpaste.org/
17:00:51 <arkeet> go to there if you want to paste some code.
17:01:57 <hpaste> haskell_noob pasted “idk” at http://hpaste.org/84535
17:02:22 <haskell_noob> ooh it worked :P
17:02:38 <Thra11_> dmwit, But if I want to modify a module written by someone else, there's no way to say, "import Foo, but ignore their definition of y and use mine instead?". In that instance I need to make my own copy of Foo?
17:02:58 <dmwit> Yes, or send them a patch.
17:03:06 <Thra11_> dmwit, Ok, thanks
17:03:12 <dmwit> Can you make this a bit more concrete? What are you trying to modify?
17:04:02 <monochrom> import Foo hiding (y); y = (); ...
17:04:36 <arkeet> monochrom: that won't replace Foo's internal uses of y with your own y.
17:04:49 <arkeet> which is what Thra11_ wants I think.
17:05:06 <monochrom> I see. also, it is useless for "use my instance code"
17:05:24 <Thra11_> arkeet, indeed. I believe I have the answer to my question
17:06:20 <haskell_noob> how do you whisper someone?
17:07:08 <path[l]>  /msg
17:07:42 <monochrom> I whisper to people all the time
17:08:16 <monochrom> by using "/msg #haskell hello" I whisper to everyone in #haskell
17:08:18 <path[l]> sure
17:08:32 <haskell_noob> thnx guys
17:08:35 <monochrom> it saves typing 900 similar lines :)
17:09:03 <roadfish> Thra11_: basically you want OO subclassing
17:09:21 <dmwit> That's quite a claim.
17:09:47 <monochrom> I haven't thought of subclassing. but it may help.
17:10:01 <roadfish> hello
17:10:22 <monochrom> o hai
17:21:05 <roadfish> weird. I did that /msg # haskell thing and then this channel when quiet.
17:21:14 <roadfish> s/when/went
17:22:48 <arkeet> roadfish: people just stopped talking.
17:23:57 <roadfish> ok, I thought I had been banned for life
17:26:54 <hpaste> krzysz00 pasted “"Parse error in pattern: comsumeTokens"” at http://hpaste.org/84536
17:27:22 <_g> does newtype CSV a = CSV { unCsv :: ([Text],[[a]]) } deriving Show  essentially mean "CSV a" is the the same thing as "([Text],[[a]]) and unCsv returns a CSV ?
17:28:10 <monochrom> roadfish: I replied "o hai" to you
17:28:18 <krzysz00> Could someone help me figure out why my pattern match isn't working? This is part of an RPN calculator attempt?
17:28:45 <geekosaur> krzysz00, you need parentheses around your list deconstructions
17:29:04 <dmwit> _g: yes
17:29:11 <hpaste> geekosaur annotated “"Parse error in pattern: comsumeTokens"” with “"Parse error in pattern: comsumeTokens" (annotation)” at http://hpaste.org/84536#a84537
17:29:23 <dmwit> _g: uh, wait, not quite
17:29:38 <_g> dmwit: i was gonna say.. wow.  i am surprised and ahave a new question
17:29:50 <geekosaur> and I think the ones around Left "+" are not needed, but not certain
17:30:13 <monochrom> that is right, (Left "+":is) is valid and same
17:30:17 <dmwit> _g: The first part was right, but unCsv returns a ([Text],[[a]]), not a CSV a.
17:30:47 <monochrom> but you can always add extra parentheses to your taste
17:31:06 <raek_> _g: CSV :: ([Text],[[a]]) -> CSV a    unCsv :: CSV a -> ([Text],[[a]])
17:31:08 <_g> oh.. unCsv takes a CSV a and returns a ([Text],[[a]])
17:31:13 <_g> okay, thanks
17:31:15 <parcs> oops wrong channel
17:31:25 <_g> ah gotcha
17:31:37 * hackagebot here 1.1 - Here docs & interpolated strings via quasiquotation  http://hackage.haskell.org/package/here-1.1 (TaylorHedberg)
17:31:54 <krzysz00> geekosaur: (Left "+":is) doesn't work. Left +:is doesn't either.
17:32:14 <krzysz00> Wait, sorry didn't try your solution.
17:32:58 <monochrom> you also need (b:a:ns)
17:33:52 <monochrom> > let f (Left "+":is) = True in f (Left "+":[])
17:33:54 <lambdabot>   True
17:33:59 <monochrom> works
17:34:10 <krzysz00> That works.
17:34:16 <krzysz00> Thanks, guys.
17:34:26 <krzysz00> Geekosaur's solution, that is.
17:35:00 <otters> Can someone reset my hackage password
17:36:37 * hackagebot csv-conduit 0.5.1 - A flexible, fast, conduit-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-conduit-0.5.1 (OzgunAtaman)
17:42:34 <bitonic> otters: Ross
18:26:57 <gdoteof> http://hpaste.org/84538  i think somehow I need to 'lift' the return from CSV into the Handler Monad (or something like that)..
18:27:13 <gdoteof> (error in annotation)
18:27:46 <gdoteof> ehh.. my formatting got messed up there as well
18:29:21 <latro`a> or just id?
18:29:27 <latro`a> nm
18:29:30 <latro`a> wasn't scrolling
18:30:11 <geekosaur> gdoteof, return, I think
18:30:36 <LazyParenthesis> when I have something like `xs@(x:rest_of_the_list)`, what is the best name for the list?
18:30:41 <hpaste> g annotated “creating csv” with “creating csv (fixed formatting) ” at http://hpaste.org/84538#a84540
18:30:43 <LazyParenthesis> is it xxs?
18:31:48 <joe9> emacs users, which do you use for haskell? tab-to-tab-stop vs indent-relative?
18:33:01 <LazyParenthesis> M-x vi-mode, or (even better) M-x shell vi
18:33:12 <latro`a> LazyParenthesis, ys@(x:xs) isn't that unusual if there aren't a bajillion lists around
18:33:26 <LazyParenthesis> ok, thanks
18:36:47 * hackagebot caledon 3.1.0.0 - a logic programming language based on the calculus of constructions  http://hackage.haskell.org/package/caledon-3.1.0.0 (MatthewMirman)
18:37:37 <hpaste> g annotated “creating csv” with “creating csv -- with return, much closer” at http://hpaste.org/84538#a84541
18:38:17 <hpaste> g annotated “creating csv” with “new error” at http://hpaste.org/84538#a84542
18:40:19 <geekosaur> don't you want to pass accountId and not userAccount?
18:42:17 <gdoteof> geekosaur: oh, yes i do indeed
18:42:40 <gdoteof> i actually get the same error though
18:44:20 <geekosaur> exact same error? seems wrong
18:48:31 <hpaste> g annotated “creating csv” with “current code” at http://hpaste.org/84538#a84543
18:48:43 <hpaste> g annotated “creating csv” with “current error” at http://hpaste.org/84538#a84544
18:49:08 <hpaste> g annotated “creating csv” with “actual current code” at http://hpaste.org/84538#a84545
18:50:33 <sjust> Hi.  I'm trying to implement a super simple network protocol for fun.  The message format is something along the lines of {fixed size header}{variable length payload}{fixed size footer} where the header includes the length of the payload.  If the header is essentially a record type consisting entirely of Int64 members with a Binary.Serialize instance, is there a good way to infer the length of the encoding without simply creating an inst
18:53:09 <thorsten`> how can i define a helper function within an instance declaration?
18:54:33 <dmwit> sjust: You got cut off at "simply creating an inst"
18:54:39 <sjust> ah
18:54:40 <sjust> thanks
18:54:41 <dmwit> thorsten`: with "where" attached to a definition, as usual
18:54:47 <sjust> Hi.  I'm trying to implement a super simple network protocol for fun.  The message format is something along the lines of {fixed size header}{variable length payload}{fixed size footer} where the header includes the length of the payload.
18:54:53 <sjust> If the header is essentially a record type consisting entirely of Int64 members with a Binary.Serialize instance, is there a good way to infer the length of the encoding without simply creating an instance of the header, encoding it, and checking the length?
18:54:56 <sjust> better?
18:55:25 <_g> sjust: yes
18:55:32 <dmwit> Surely if the header is fixed size, you don't need to create one.
18:55:37 <dmwit> It's a fixed size, so that's the size.
18:55:38 <dmwit> (?)
18:55:53 <sjust> dmwit: indeed, just seems brittle
18:56:32 <sjust> in C, I would cheat by converting the ints to network byte order and sending (char*)&header, sizeof(header)
19:06:53 * hackagebot mustache2hs 0.2.1.1 - Utility to generate Haskell code from Mustache templates  http://hackage.haskell.org/package/mustache2hs-0.2.1.1 (StephenWeber)
19:10:40 <rosslazer> What's the most well known haskell project?
19:10:46 <sipa> GHC
19:10:47 <elliott> probably xmonad. or darcs.
19:11:08 <sipa> or hedgewars-server
19:13:57 <byorgey> facebook
19:14:29 <rosslazer> Facebook is not built on haskell
19:15:57 <byorgey> I was half joking.  But seriously, Facebook has some real tools for refactoring their PHP codebase written in Haskell
19:16:07 <Mortchek> @type forever
19:16:08 <lambdabot> Monad m => m a -> m b
19:16:16 <byorgey> e.g. if they want to make a certain change to the codebase they write a little Haskell program to make the changes to the PHP code.
19:16:22 <Mortchek> ^ How can that possibly be true? How can you turn the a into a b?
19:16:31 <luite> i'm guessing they're doing more with it now, with bos and simon marlow on board
19:16:31 <byorgey> Mortchek: because you never get a b
19:16:54 <Mortchek> Ooh.
19:17:12 <byorgey> luite: right, that too.
19:17:21 <byorgey> so saying 'facebook' was a joke, but also not a joke.
19:18:12 <roconnor> @type exit
19:18:13 <byorgey> Mortchek: that function promises to give you a value of type b at the end of forever =)
19:18:14 <lambdabot> Not in scope: `exit'
19:18:18 <roconnor> @hoogle exit
19:18:19 <lambdabot> System.Exit data ExitCode
19:18:19 <lambdabot> Control.OldException ExitException :: ExitCode -> Exception
19:18:19 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
19:18:25 <roconnor> @hoogle systemexit
19:18:25 <lambdabot> No results found
19:18:26 <byorgey> roconnor: exitWith?
19:18:34 <roconnor> @hoogle exitWith
19:18:34 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
19:18:45 <sipa> :t undefined
19:18:47 <lambdabot> a
19:18:51 <roconnor> Mortchek: another example of returning a polymorphic value
19:19:07 <roconnor> Mortchek: also used in callCC, but it is a bit more obtuse there
19:19:13 <shachaf> Maybe values like that should be called "void"
19:19:21 <shachaf> exitWith :: ExitCode -> IO void
19:19:45 <sipa> why restrict the type of what they can return?
19:19:47 <roconnor> shachaf: void or Void?
19:19:53 <shachaf> void
19:19:55 <sipa> given that they don't return at all
19:20:05 <geekosaur> more descriptive type variable, in other words
19:20:07 <elliott> "void" restricts nothing
19:20:12 * geekosaur might suggest undefined
19:20:17 <shachaf> Like typeRep :: Typeable a => proxy a -> TypeRep
19:20:20 <sipa> owww, void, not Void!
19:20:35 * sipa needs sleep
19:20:52 <Mortchek> So then is (forever foo) effectively bottom?
19:21:10 <sipa> :t forever
19:21:11 <lambdabot> Monad m => m a -> m b
19:21:12 <shachaf> No, it has effects.
19:21:18 <geekosaur> modulo side effects; it can, for example, use exitWith
19:21:21 <shachaf> > forever Nothing
19:21:23 <lambdabot>   Nothing
19:21:28 <roconnor> Mortchek: not quite, more like an unending sequence of monadic actions that you can never bind to.
19:21:31 <geekosaur> (if its in IO)
19:21:46 <sipa> > forever Just
19:21:48 <lambdabot>   No instance for (GHC.Show.Show (a0 -> b0))
19:21:48 <lambdabot>    arising from a use of `M44102...
19:21:50 <roconnor> er
19:22:00 <parcs> i prefer 'p a -> TypeRep'
19:22:07 <sipa> > forever Just $ 0
19:22:07 <shachaf> > execWriter (forever (tell "beep"))
19:22:09 <lambdabot>   can't find file: L.hs
19:22:10 <lambdabot>   mueval-core: Time limit exceeded
19:22:12 <shachaf> > execWriter (forever (tell "beep"))
19:22:15 <lambdabot>   "beepbeepbeepbeepbeepbeepbeepbeepbeepbeepbeepbeepbeepbeepbeepbeepbeepbeepbe...
19:22:50 <Mortchek> Why doesn't it tell you the type is ambiguous if you don't give it a b?
19:23:01 <Mortchek> (i.e., tell it what b you want)
19:23:32 <shachaf> Why would it be ambiguous?
19:23:45 <shachaf> It isn't doing any type class resolution or anything like that.
19:24:06 <Mortchek> Ah, I see.
19:25:10 <jbu> hi all...in a do block, do all the statements need to be operating on the same type of monad
19:25:13 <jbu> ?
19:25:40 <shachaf> jbu: Yes, because of the type of >>=
19:25:44 <parcs> a do block is sugar for >>=. the types should tell you the rest
19:25:48 <shachaf> do { a; b; c } ----> a >> b >> c
19:25:53 <Mortchek> @type (>>=)
19:25:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:25:56 <shachaf> (>>) :: Monad m => m a -> m b -> m b
19:26:07 <Mortchek> The m needs to be the same, but the a and b can be different.
19:26:08 <jbu> I see thanks
19:50:22 <Kevin-_-> hello, what would give an error saying "parse error on input '(' "?
19:50:31 <shachaf> GHC.
19:51:34 <monochrom> you should paste verbatim uncensored
19:52:02 <Kevin-_-> monochrom: you mean for me?
19:52:08 <monochrom> yes
19:52:35 <Kevin-_-> ah ok
19:52:37 <Kevin-_-> one second
19:57:49 <hpaste> Kevin pasted “parse error on input '('” at http://hpaste.org/84546
19:58:14 <Kevin-_-> that's where I"m having issues, or did you want the entire code?
19:58:35 <shachaf> The code and the error would be good.
19:58:49 <Kevin-_-> it's line 9
19:58:55 <Kevin-_-> just giving me a parse error
19:58:59 <shachaf> Maybe the issue is that the tuples aren't indented to the same level as the "while"
19:59:25 <monochrom> misalignment. (s',a') should be right below "while", lined up. you're a few spaces behind
19:59:57 <monochrom> similarly (ss',a'')
20:00:03 <shachaf> Listen to monochrom.
20:00:29 <Kevin-_-> ah damn, I keep forgetting about the asignment thing.  That did it.  Thanks monochrom
20:00:42 <monochrom> alignment
20:01:12 <shachaf> I,I static single alignment
20:01:50 <Kevin-_-> I'm used to C/C++ :), so I keep forgetting that you can't tab/space differently, and alignment things like that
20:01:54 <tac> Is there a version of decodeUtf8 that doesn't throw an io exception if it can't decode the input?
20:01:54 <Kevin-_-> thanks for the help
20:02:10 * hackagebot microtimer 0.0.1.1 - A tiny library for benchmarking IO actions.  http://hackage.haskell.org/package/microtimer-0.0.1.1 (AustinSeipp)
20:02:12 * hackagebot microtimer 0.0.1.2 - A tiny library for benchmarking IO actions.  http://hackage.haskell.org/package/microtimer-0.0.1.2 (AustinSeipp)
20:03:41 <tac> @index decodeUtf8
20:03:41 <lambdabot> bzzt
20:03:49 <tac> @index forkIO
20:03:50 <lambdabot> Control.Concurrent
20:06:34 <BMeph> @index finger
20:06:34 <lambdabot> bzzt
20:06:47 <BMeph> Sorry, old joke. :)
20:07:06 <Kaidelong> finger actually sounds like a reasonable name for some function somewhere
20:07:48 <Kaidelong> card less do except if this were lisp
20:08:16 <Kaidelong> (headd?)
20:12:56 <otters> finger
20:12:59 <otters> gross
20:13:28 <Kaidelong> well there is a network tool by that name
20:30:19 <BMeph> So remember, you can tool your finger.... ;p
20:44:11 <cschneid> How do I noop my default parse implementation? https://gist.github.com/cschneid/5226348
20:45:02 <parcs> what?
20:45:22 <parcs> i think you want 'return ()'?
20:46:22 <otters> could use "undefined"
20:46:28 <otters> lol
20:47:10 <cschneid> parcs: undefined crashes out. I want 1) exaustive pattern matching to make the warning go away, and then 2) not to do anything if it isn't -v and -h
20:47:18 <cschneid> parcs: probably, ya, let me give it a go
20:47:57 <cschneid> cool, that did work. Thank you - this is my 50th "first-day" of haskell. Hopefully this time it sticks.
21:01:56 <Nomad__> Hello. I'm kinda curious, if I do a recursive list in haskell, does it reallocate the list each step, or does it do magic in the background to optimize that?
21:03:34 <ParahSail1n> what it needs to allocate, it will allocate
21:03:53 <shachaf> INSUFFICIENT DATA FOR MEANINGFUL ANSWER
21:04:16 <geekosaur> shachaf will someday evolve into universal-AC
21:05:11 * latro`a repeats the earlier gag
21:05:21 <latro`a> "Hey, I am Haskell; and this is lazy; so here's a function; I'll call it, maybe."
21:05:21 <Nomad__> I mean, in C, if you create say, a dynamic array with malloc, to make it bigger, you need to reallocate it... does haskell do magic to say, prevent 2:(2:[2]) from being reallocated 3 times?
21:05:50 <hiptobecubic> Nomad__, that is not an array
21:05:54 <hiptobecubic> Nomad__, it's a linked list
21:06:06 <latro`a> linked lists aren't arrays, but the exact implementation of haskell is...not really what you expect
21:06:21 <Nomad__> yeah but standard linked lists do not support direct indexing :\
21:06:22 <shachaf> Nomad__: Haskell is a higher-level language which is difficult to translate locally to the operational terms you're familiar with.
21:06:36 <latro`a> haskell's linked lists don't really either
21:06:37 <Nomad__> I understand that, im just curious if I should worry about that
21:06:51 <geekosaur> so in many cases we can get the compiler to do stream fusion and no allocations are done at all.
21:07:05 <shachaf> Nomad__: As I said: INSUFFICIENT DATA FOR MEANINGFUL ANSWER
21:07:11 <geekosaur> depends on the code though, and what you do with it
21:07:27 <geekosaur> laziness means that the code might not ever be executed at all, if nothing demands the data!
21:08:03 <shachaf> Or maybe your linked list will be optimized to a constant-space loop.
21:08:14 <Nomad__> Yeah, makes sense
21:08:29 <luite> Nomad__: assuming the list doesn't get optimized away and you force the whole list, GHC does some magic there, it will only allocate one (2::Int), small integers aren't preallocated, but the list cons cells will be allocated for each element (3 words for a (:)), [] will not be allocated since it's a constant
21:08:32 <shachaf> Laziness means that your "data structures" are often actually "control structures".
21:08:42 <luite> small integers are preallocated
21:08:46 <luite> is what i meant to say
21:09:27 <luite> so that list will have 3 cons cells (x3 words) dynamically allocated, the rest pointers to statically allocated stuffs
21:10:55 <Nomad__> from what I understand, all structures in haskell are either cons'd until an empty element, or created from existing structures... although i'm probably wrong
21:11:13 <Nomad__> or an infinite list...
21:11:20 <elliott> all *lists* sure.
21:11:25 <elliott> not everything is a list
21:11:39 <Nomad__> no but if I had say, a binary tree, wouldn't it be similar?
21:11:43 <joe9>  with emacs + haskell, haskell-indentation > haskell-indent or is it the other way round?
21:12:10 <Nomad__> im more of a vim guy
21:12:25 * hackagebot binary-file 0.6 - read/write binary file  http://hackage.haskell.org/package/binary-file-0.6 (YoshikuniJujo)
21:13:06 <joe9> Nomad__: check out evil mode of emacs. I was a vim guy till a few weeks ago.
21:13:25 <Nomad__> evil mode you say? I am intrigued but ... emacs :|
21:15:58 <jmcarthur> Nomad__: in most haskell implementations, if you have a list and want to cons an element to the front of it, that will only take constant time. it does not copy the original list.
21:16:03 <otters> vi mode for emacs?
21:16:05 <otters> wuh?
21:16:08 <jmcarthur> Nomad__: also, you can define binary trees just fine
21:16:15 <jmcarthur> otters: evil-mode is actually pretty nice
21:16:20 <Nomad__> yeah im not worried about defining, i am worried about copying
21:16:23 <otters> i mean, you could use vim
21:16:42 <jmcarthur> Nomad__: in a sense nothing is ever copied
21:16:51 <hiptobecubic> emacs has a few significant wins over vim, like managing asynchronous processes
21:17:05 <hiptobecubic> but it has a great many significant losses as well
21:17:07 <jmcarthur> Nomad__: changing a purely functional data structure only minimally reconstructs the parts that you change
21:17:26 <jmcarthur> Nomad__: since consing to the front of a list actually changes nothing, there is nothing to reconstruct in the first place
21:17:53 <jmcarthur> hiptobecubic: actually, emacs is all synchronous :\
21:18:19 <jmcarthur> hiptobecubic: most IPC type stuff in emacs is implemented via polling :\
21:18:37 <hiptobecubic> jmcarthur, well it handles it with much more success than vim
21:18:42 <jmcarthur> sure
21:19:03 <Nomad__> Im really surprised how people do algorithms in C now... with all the worrying about thread safety and null pointers, and magic side effects ...
21:19:25 <Nomad__> by the time you're done coding a data structure, its incomprehensible
21:19:28 <jmcarthur> a good C programmer will tend to find ways to avoid those things if he can
21:19:28 <Nomad__> >.>
21:19:43 <jmcarthur> except when there is a good reason to use them
21:19:52 <jmcarthur> (or break it, in the case of thread safety)
21:20:14 <jmcarthur> i don't think C is necessarily incomprehensible
21:20:24 <jmcarthur> i like C, despite liking haskell a lot more
21:20:37 <Nomad__> it isnt, but after putting all the null checks, and all the other evils, haskell can even become faster than C
21:21:07 <Nomad__> I mean I love C, at least compared to C++... STL... ughhh
21:21:12 <jmcarthur> well...
21:21:28 <jmcarthur> with a low amount of work, C tends to be faster
21:21:36 <jmcarthur> with a high amount of work, C also tends to be faster
21:21:42 <jmcarthur> somewhere in between, haskell can be faster
21:22:08 <jmcarthur> fortunately for me, i usually do the somewhere in between amount of work
21:22:15 <Nomad__> the way I see it, C is fast, but when you start tangling defensive logic around your code, you start tripping up
21:23:12 <Nomad__> it's also much harder to see flow of C program than haskell, but much easier than C++/Java
21:24:51 <jmcarthur> one can code "defensively" or one can code with very explicit assumptions so that other code doesn't violate them. the latter is still fast
21:24:51 <jmcarthur> by the way, how does one who doesn't understand haskell performance enough to understand when things are copied know enough to say that haskell can beat C at all?
21:24:51 <jmcarthur> err... i don't mean that to sound confrontational
21:30:08 <Nomad__> From what I understand, well expressed haskell should be fairly efficient. Although there are still getchas like '++' vs ':', but what I mean is "badly written haskell is probably better than badly written C"...
21:30:28 <hiptobecubic> evil mode looks nice
21:30:41 <Nomad__> all haskell code seems to have a flow of intent, badly written C is just a lot of instructions with no purpose...
21:30:48 <shachaf> Writing efficient Haskell code is not easy.
21:30:53 <hiptobecubic> Maybe it's worth switching, even. Feels dirty
21:30:55 <Nomad__> that's a good thing
21:30:59 <shachaf> (Writing efficient C code is also not easy, if for different reasons.)
21:31:14 <Nomad__> always nice to have compiler yell at you, it's really motivating, helps build better code
21:31:24 <amatsu> Is there any way to get automatic syntax checking for Haskell with Emacs?
21:31:32 <Nomad__> and not in the way C++ yells at you...
21:31:37 <shachaf> amatsu: Look into ghc-mod and/or hdevtools
21:32:44 <Nomad__> writing efficient C is hard, writing efficient C that is safe is very hard, making efficient C which is safe and portable is... quite a feat
21:33:04 <pharaun> bit off topic, but i'm amazed at how easy it is to get ghc + haskell platform to work in a local install
21:33:08 <pharaun> tho i had to hack out opengl/glut
21:33:22 <amatsu> shachaf: will do, thanks.
21:33:42 <pharaun> got used to *certain* languages having shitty local install support
21:33:55 <Nomad__> I tried setting up gtk... a task I decided not to take on again without sufficient tools
21:35:31 <Nomad__> I wonder if Tk for haskell is difficult to set up/exists
21:38:50 <startling> C wouldn't be so bad if the tools and the conventions weren't so bad.
21:39:38 <startling> like, passing a pointer to a place to store a potential error is a really cool idiom
21:40:40 <cschneid> I've tried for about an hour now... if I have a String with a hex value in it: "abc345fff", and I want to parse that, and ideally get it in a structure I can manipulate byte by byte. (bytestring presumably?)
21:40:45 <cschneid> what should I be looking at
21:41:01 <startling> cschneid: what's a byte in this case?
21:41:09 <Nomad__> well imma go fail trying setting up Arch linux yet again
21:41:18 <startling> cschneid: (half a hex digit?)
21:42:36 <cschneid> startling: ff => one byte. each hex digit represents 4 bits (one nibble)
21:42:39 <startling> er, two hex digits
21:42:43 <cschneid> so ffaa11 => 3 bytes
21:43:13 <cschneid> anyway, it seems like Data.Text.hexadecimal translates it to an Integral value.
21:43:15 <cschneid> which is ... closer.
21:43:21 <cschneid> but I can't actually get that to work either
21:43:24 <ParahSail1n> data.bits is helpful for bit twiddling on integral values
21:43:52 <startling> cschneid, I'd just split it into two-char chunks and thence into Data.Word.Word8
21:43:56 <cschneid> ParahSail1n: that is 100% what I need for my next steps.
21:44:35 <cschneid> startling: I'm new to all this. As I mentioned earlier, it's my 50th "fresh start" on attempting this. I finally have a good problem set to play with
21:45:05 <shachaf> cschneid: Probably you should parse it into a list of bytes and then use BS.pack
21:45:28 <ParahSail1n> @ty readhex
21:45:29 <lambdabot>     Not in scope: `readhex'
21:45:30 <lambdabot>     Perhaps you meant one of these:
21:45:30 <lambdabot>       `readHex' (imported from Numeric),
21:45:34 <ParahSail1n> @ty readHex
21:45:36 <lambdabot> (Eq a, Num a) => ReadS a
21:46:20 <shachaf> > BS.pack . map (^?! base 16) . splitEvery 2 $ "ffaa11"
21:46:23 <lambdabot>   "\255\170\DC1"
21:46:26 <shachaf> OK, no fair using lens.
21:46:40 <latro`a> :t (^?!)
21:46:42 <lambdabot> s -> Getting (Endo a) s t a b -> a
21:47:17 <cschneid> wtf is going on with ^?!
21:47:22 <shachaf> Sorry, ignore that.
21:47:23 <cschneid> nevermind, I don't care yet
21:47:42 <edwardk> the name of ^?! is designed to make you stop and go ^?! =P
21:47:51 <cschneid> ok, help me with reading docs.  How would I go from a string representing a byte:   "aa" into the byte it represents as a Word8
21:48:09 <ParahSail1n> > readHex "ffaa11"
21:48:11 <lambdabot>   can't find file: L.hs
21:48:33 <shachaf> > readHex "aa"
21:48:35 <lambdabot>   [(170,"")]
21:49:18 <shachaf> @let readHexMaybe :: Integral a => String -> Maybe a; readHexMaybe s = case readHex s of [(x,"")] -> Just x; _ -> Nothing
21:49:21 <lambdabot>  Defined.
21:49:34 <startling> cschneid: well, one way is `case x of "01" -> 1 :: Word8; "02" -> 2 :: Word8; ...`
21:49:54 <shachaf> > fmap BS.pack . mapM readHexMaybe . splitEvery 2 $ "ffaa11"
21:49:56 <lambdabot>   Just "\255\170\DC1"
21:50:01 <shachaf> > fmap BS.pack . mapM readHexMaybe . splitEvery 2 $ "ffaa115q"
21:50:03 <lambdabot>   Nothing
21:50:04 <startling> :t splitEvery
21:50:06 <lambdabot> Int -> [e] -> [[e]]
21:50:11 <startling> where's that from?
21:50:18 <ParahSail1n> splits
21:50:26 <startling> handy
21:50:29 <ParahSail1n> @ty chunksOf
21:50:31 <lambdabot> Int -> [e] -> [[e]]
21:50:39 <JoeyA> @hackage split
21:50:39 <lambdabot> http://hackage.haskell.org/package/split
21:56:20 <cschneid> ok, thank you everybody. I'm parsing all of the things you sent my way now... :)
21:57:23 <kanishka> where can i read in depth about Alternative and MonadPlus... a little hard to understand them
21:58:46 <TheCrownedFox> Howdy, is ghci available for arm based processors? I'm having difficulties with it.
22:14:38 <lispy> kanishka: http://www.haskell.org/haskellwiki/Typeclassopedia
22:16:35 <ParahSail1n> so STM retry is not a busy wait, correct?
22:16:58 <shachaf> Correct.
22:18:11 <Cale> It would be sort of correct to implement it as such, but pointlessly inefficient.
22:18:36 <ParahSail1n> how is it basically implemented in ghc rts?
22:19:28 <shachaf> ParahSail1n: Every time you read an STM variable, it gets added to the transaction log.
22:19:42 <cschneid> with additional parenthesis, help me parse this: parseHex = fmap BS.pack . mapM readHexMaybe . chunksOf 2   -- it takes the input, chunks it into two, monad-maps readHexMaybe across it, then maps BS.pack across that?
22:19:43 <shachaf> Then if you retry, the transaction waits on all the variables in the log.
22:19:49 <shachaf> When any of them changes it's retried.
22:20:09 <cschneid> ok - what's the difference between map and fmap.
22:20:18 <ParahSail1n> shachaf, ah thats pretty cool
22:20:20 <shachaf> cschneid: fmap is more general.
22:21:14 <cschneid> map :: (a -> b) -> [a] -> [b]  ---- vs. ---- fmap :: Functor f => (a -> b) -> f a -> f b
22:21:22 <cschneid> I suppose I don't know what a functor is...
22:21:26 <cschneid> ok, to the googles!
22:21:33 <shachaf> cschneid: It means "a thing you can map over".
22:21:46 <lispy> cschneid: http://www.haskell.org/haskellwiki/Typeclassopedia
22:21:48 <shachaf> It's more or less a type class designed to generalize map.
22:22:16 <cschneid> ok. So the whole thing is designed to be just more generic. So for instance, fmap would work over a tree structure where boring `map` might not.
22:22:22 <cschneid> (yes?)
22:22:22 <shachaf> Right.
22:22:26 <shachaf> It also works for other things.
22:22:27 * lispy just hands out links to typeclassopedia tonight
22:22:32 <cschneid> ok. I can accept this.
22:22:34 <cschneid> thank you lispy
22:22:39 <shachaf> For example, the value inside a Maybe (if it exists), or the result of a function.
22:22:42 <lispy> > fmap (+1) (Just 1)
22:22:43 <lambdabot>   Just 2
22:22:46 <shachaf> cschneid: Read lispy's link. It's good.
22:23:08 <shachaf> (So I hear.)
22:26:20 <cschneid> ok, parsing of haskell in my head: parseHex = fmap BS.pack . mapM readHexMaybe . chunksOf 2
22:26:28 <cschneid> can somebody add parenthesis to that
22:26:46 <cschneid> fmap takes two arguments, BS.pack . mapM
22:26:46 <shachaf> (fmap BS.pack) . (mapM readHexMaybe) . (chunksOf 2)
22:26:51 <cschneid> ohh
22:26:53 <cschneid> hmm
22:27:13 <cschneid> so the space binds tighter than the .
22:27:22 <latro`a> the space binds tighter than everything
22:27:32 <latro`a> precedence 11 I think is the actual number?
22:27:40 <cschneid> can I make ghci tell me how a line is parsed
22:27:41 <latro`a> and all other infix operators are 10 or below iirc
22:27:41 <lispy> cschneid: function application is the tightest thing. So "fmap BS.pack", "mapM readHexMaybe" and "chunksOf 2" are all tightly bound.
22:27:56 <cschneid> haskell has an annoying way of minimalism. (at least annoying for learning)
22:28:18 <cschneid> ok. and $ can be thought of as (...end of line) right?
22:28:26 <pharaun> is there any gotchas to be aware of when doing cabal-dev
22:28:27 <cschneid> paren until end of scope
22:28:28 <lispy> ?src ($)
22:28:28 <lambdabot> f $ x = f x
22:28:37 <shachaf> Sometimes. It's just a regular operator, though.
22:28:52 <lispy> pharaun: yes. Things that use the Paths_foo modules may not work as expected.
22:29:58 <lispy> pharaun: Paths_foo hardcodes the full path where the binary was installed. So if you want to use cabal-dev to install something in your path, you might call it like, cabal-dev install Foo --prefix=$HOME/.cabal and then it should stick the resulting binary in $HOME/.cabal/bin/Foo
22:30:47 <pharaun> lispy: any straight forward way of identifying those or is it just going to be based on hit/miss experience?
22:31:42 <lispy> pharaun: Unless I know I want the result of the build in my path I just use regular 'cabal-dev install' and run the binary from ./cabal-dev/bin/foo
22:32:24 <lispy> pharaun: basically, I just know from context and if I don't know I play around with it to find out. You can easily 'grep -r "Paths_" *' in the source to find out if it uses the paths modules
22:32:27 <mm_freak> given a monoid (G, (<>)) and a second closed identity-respecting operation (~~), is there a name for the compound object (G, (<>), (~~))?  if yes, is it defined in some library?
22:32:56 <latro`a> if the two operations don't satisfy any laws with one another, I doubt it
22:32:59 <lispy> mm_freak: you might cehck if that's a module
22:33:01 <pharaun> lispy: ahh k, thanks :) thanks for the warning, i was just going to start setting up cabal-dev for my at work ghc install and wanted to double check
22:33:14 <lispy> mm_freak: I can't recall the definition of module
22:33:23 <latro`a> module doesn't have two binary operators
22:33:31 <latro`a> (modules generalize vector spaces)
22:33:50 <mm_freak> hmm, ok
22:34:03 <latro`a> I think you can prove that such a collection is not a ring
22:34:12 <latro`a> or at least not a nontrivial ring
22:34:17 <latro`a> (in a nontrivial ring 1 != 0)
22:34:45 <mm_freak> background:  just like in vty i have a type for rectangular text regions that can be composed both horizontally and vertically
22:35:31 <mm_freak> right now i have, class (Monoid a) => Layout a, adding a composition operator orthogonal to (<>)
22:36:19 <cschneid> is there a built-in lib for base64? Or should I go install the http://hackage.haskell.org/package/base64-bytestring-1.0.0.1 package
22:36:43 <latro`a> wait, mm_freak, do they respect the same identity?
22:37:17 <mm_freak> latro`a: yes
22:37:40 <mm_freak> i can't make sense of a*(b + c) = a*b + a*c, so it's probably not a ring
22:38:00 <latro`a> it would be a trivial ring if 1=0
22:39:40 <BadKitty> Could anyone here please walk me through an example of a basic tcp server using tls. (Sending bytestring encoded records; I've got binary but I'm gonna switch to cereal)
22:40:47 <cschneid> ok - can somebody tell me what's going on here: https://github.com/bos/base64-bytestring/blob/master/Data/ByteString/Base64/Internal.hs -- why all the crazy withForeignPointer stuff for a base64 lib.
22:40:51 <cschneid> super-optimized code?
22:42:55 <BadKitty> ...
22:43:50 * BadKitty wonders why this isn't using a bytestring version of Numeric
22:44:01 <BadKitty> readInt/showIntAtBase etc
22:44:09 <BadKitty> then store the int as a bytestring
22:44:15 <BadKitty> encode *
22:44:16 <shachaf> cschneid: This is "C in Haskell", more or less.
22:44:31 <cschneid> shachaf: ok, figured. Just CRAZY.
22:44:34 <cschneid> :)
22:45:03 <cschneid> it does give me correct output. So whatever.  But still just weird code
22:56:13 <BadKitty> cschneid: Don't use it. Use Numeral's readInt and showIntAtBase
22:56:51 <BadKitty> (Get an integer, from there encode that to a bytestring)
22:56:52 <cschneid> BadKitty: it already works with this code, even if the underlying one is crazy
22:57:02 <BadKitty> CRAZY
22:57:04 <cschneid> can you example that up? I'm brand new.
22:57:16 <BadKitty> Sure.
22:57:21 <BadKitty> @hoogle showIntAtBase
22:57:22 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
22:58:11 <cschneid> what's a ReadS and ShowS, I've seen those a few times
22:58:14 <cschneid> what's the S mean
22:58:27 <shachaf> cschneid: Do you know about Hoogle?
22:58:28 <shachaf> @where hoogle
22:58:29 <lambdabot> http://haskell.org/hoogle
22:58:37 <shachaf> It's useful for answering those sorts of questions.
22:58:59 <cschneid> I know of it, but haven't integrated it into my workflow... since... I don't have a workflow
23:01:39 <ParahSail1n> one thing that's annoying is that sometimes when i use google to look for standard ghc libraries, the 6.x docs appear as the only result
23:02:34 <pharaun> rah that annoys the crap out of me
23:03:08 <BadKitty> cschneid: showIntAtBase 5 (\i -> case i of { 1 -> 'b'; 3 -> 'c'; 4 -> 'd'; 5 -> 'e' }) 1048 ""
23:03:13 <BadKitty> > showIntAtBase
23:03:15 <lambdabot>   No instance for (GHC.Show.Show
23:03:15 <lambdabot>                     (a0 -> (GHC.Types.Int ->...
23:03:18 <BadKitty> heh
23:03:24 <BadKitty> > showIntAtBase 5 (\i -> case i of { 1 -> 'b'; 3 -> 'c'; 4 -> 'd'; 5 -> 'e' }) 1048 ""
23:03:24 <cschneid> woo! CODE!
23:03:26 <lambdabot>   "bcbdc"
23:03:29 <cschneid> cool
23:03:35 <cschneid> presumably I'd need 'a' and such :)
23:03:35 <ParahSail1n> i think haskell.org should set http://www.haskell.org/ghc/docs/6.12.2 in the robots.txt
23:04:24 <BadKitty> > readHex "ace"
23:04:26 <lambdabot>   [(2766,"")]
23:04:37 <ParahSail1n> some sort of drastic measure to facilitate googling of standard library stuff, because it's really inconvenient
23:04:39 <shachaf> @let hex = base 16
23:04:41 <lambdabot>  Defined.
23:04:53 <shachaf> > "ace" ^? hex
23:04:55 <BadKitty> cschneid: Heh yea, I had zero insteasd of 1 before
23:04:55 <lambdabot>   Just 2766
23:05:05 <BadKitty> @where base
23:05:06 <lambdabot> http://darcs.haskell.org/packages/base/
23:05:15 <BadKitty> lol
23:05:19 <cschneid> shachaf: stop showing off with your worse-than-perl line noise!
23:05:23 <BadKitty> @hoogle base -- doubt this will go good
23:05:23 <lambdabot> Parse error:
23:05:23 <lambdabot>   base -- doubt this will go good
23:05:23 <lambdabot>        ^
23:05:30 <BadKitty> @hoogle base
23:05:30 <lambdabot> Control.Exception.Base module Control.Exception.Base
23:05:30 <lambdabot> Text.Html base :: String -> HtmlAttr
23:05:30 <lambdabot> Text.XHtml.Strict base :: String -> HtmlAttr
23:05:38 <BadKitty> Nope
23:06:02 <Pods> What exactly is haddop used for ?? I am already compiling haskell programs with ghc
23:06:10 <cschneid> shachaf: seriously though. Is that kind of multiple symbols stacked up common? It seems pretty undiscoverable
23:06:30 <BadKitty> haddop?
23:06:38 <shachaf> cschneid: This is part of a library that follows a particular pattern.
23:06:47 <xkcd> In Learn you a Haskell It is written that
23:06:49 <xkcd> Let's make a trivial function that tells us some of the first elements of the list in (in)convenient English form.
23:06:51 <xkcd> tell :: (Show a) => [a] -> String
23:06:53 <xkcd> tell [] = "The list is empty"
23:06:54 <xkcd> tell (x:[]) = "The list has one element: " ++ show x
23:06:56 <xkcd> tell (x:y:_) = "This list is long. The first two elements are: " ++ show x ++ " and " ++ show y  Why did they write (Show a)??
23:07:11 <shachaf> xkcd: Because they wrote "show x"
23:07:22 <shachaf> cschneid: It's not a standard library anyway.
23:07:33 <shachaf> > preview hex "ace"
23:07:36 <lambdabot>   Just 2766
23:08:12 <xkcd> Can't we directly use functions which already defined in other functions?? shachaf
23:08:42 <cschneid> shachaf: hah. No worries. But haskell seems to lean toward inventing operators pretty often. I swear I've seen |||> as something meaningful... like I can just glance at that and be like "yep, I know what that does"
23:08:48 <BadKitty> xkcd: Because a must have an instance for Show
23:08:53 <cschneid> do real sized programs get away from that?
23:09:13 <lispy> cschneid: I rarely define operators. It's a matter of style.
23:09:16 <Pods> BadKitty :  yeah one of the documentations says use hadoop to make haskell programs .
23:09:37 <lispy> cschneid: some people enjoy it. Others, not so much.
23:09:38 <shachaf> cschneid: I don't think an operator is significantly worse than any other function name you don't know, assuming it's easy to look it up.
23:09:40 <BadKitty> What is hadoop?
23:09:42 <shachaf> Sometimes infix is nice.
23:10:03 <Pods> Trying to figure that out myself
23:10:15 <BadKitty> shachaf: f <$> a <*> a1 <*> a3 ofc infix is useful :D
23:10:23 <BadKitty> nice *
23:10:32 <BadKitty> s/a1/a2/
23:10:35 <Pods> Looks like its nothing of significant to haskell now that you ask me the same
23:10:48 <cschneid> shachaf: the counter argument is that I speak english, but not symbol.  But yeah, I figure it's a limited thing, for common joining commands
23:11:01 <cschneid> and the actual work happens in better named functions
23:12:24 <BadKitty> Pods: By any chance did you mean haddock?
23:12:39 <BadKitty> (Source code documentation >> HTML docs)
23:12:45 <BadKitty> s/>>/->/
23:12:46 <c_wraith> cschneid: Well.  It's also useful to use symbolic names for classes that are so general that any english name with introduce misleading connotations.
23:13:07 <Pods> Badkitty : yes! sorry got confused there .. my bad :\
23:13:15 <BadKitty> Thank you :)
23:13:26 <c_wraith> cschneid: this, for instance, is why <> was added as a synonym for mappend. "append" implies semantics that not all monoids have. <> doesn't imply anything
23:13:28 <BadKitty> Makes much more sense now :D
23:13:39 <cschneid> c_wraith: sure. I am coming from ruby though, which is so clear with words, that haskell sorta scares me how mathy it is sometimes
23:13:41 <BadKitty> Pods: What's your question now?
23:14:02 <cschneid> different communities mostly
23:14:06 <BadKitty> Or did I answer with my (i -> o) ?
23:14:53 <Pods> I am a little confused as to why would I need it when i have ghc which is already compiling my haskell programs .
23:14:55 <c_wraith> And operating at a different level of abstraction. Ruby barely abstracts anything, in my experience. Haskell tries very hard to find new and interesting abstractions. (sometimes it even succeeds)
23:15:09 <BadKitty> Pods: Say you have -- | at the start of a line before a function, this defines documentation for that function.
23:15:12 <carter> cschneid is that who i think it is? :)
23:15:41 <cschneid> carter: hmm? probably not. I'm a ruby guy. but not famous.
23:15:54 <carter> oh, i know a data vis dude who's name looks like your handle
23:15:57 <carter> sorry
23:16:05 <BadKitty> -- ^ to add documentation to a record or anything, just for the current line. Often two spaces before the comment (As with any comments next to code)
23:16:05 <cschneid> nah, would be cool, but I'm 90% a web guy
23:16:23 <carter> well, haskell is pretty webscale these days I hear :)
23:16:33 <BadKitty> Pods: haddock doesn't compile your code. But instead, it's building documentation for your code
23:16:41 <BadKitty> Best suited for libraries.
23:17:11 <Pods> documentation for my code as in taking in all the comments I put to describe say the libraries ??
23:17:15 <BadKitty> Execuitables can benifit too, ideally for example code
23:18:00 <Pods> right , is its usage encouraged for development purposes ??
23:18:06 <BadKitty> Pods: Look at this.. Not a good example but shows enough.. http://archeydevil.hackerhaven.net/darcs/Tokens/dist/doc/html/tokens/src/Data-Token.html
23:18:09 <BadKitty> Source code
23:18:12 <BadKitty> http://archeydevil.hackerhaven.net/darcs/Tokens/dist/doc/html/tokens/Data-Token.html
23:18:15 <BadKitty> Documentation
23:19:03 <Pods> Oh this is neat :)
23:19:10 <Pods> thanks BadKitty :D
23:19:23 <BadKitty> Pods: ^_^
23:19:40 <BadKitty> Pods: Seen haddock documentation yet?
23:20:04 <Pods> Its in one of my tabs yes.
23:20:12 <Pods> Looking at it now ..
23:20:15 <BadKitty> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Numeric.html << All packages in hackage should have documentation.
23:20:29 <BadKitty> Well.. Libraries minimal.
23:20:47 <BadKitty> Execuitables, can have, but more just for examples.
23:20:55 <BadKitty> (Using the libraries)
23:21:33 <Pods> I am sort of looking into developing for haskell, not sure if i should get into hadock right away ..
23:22:15 <Pods> ^ BadKitty : Any suggestions for the same ??
23:22:54 <BadKitty> Pods: When writing your libraries, just have a basically explain what the functions do. You may even need to read them later on after your writing of it.
23:23:22 <Pods> Okay
23:23:25 <BadKitty> -- | This is a peice of documentation before a function.
23:23:32 <BadKitty> f :: IO ()
23:23:37 <BadKitty> f = putStrLn "Hello world!"
23:24:16 <Pods> Got it ..
23:24:21 * BadKitty would rather have f :: String; f = "Hello world!" -- But then use x instead of f.
23:25:14 <BadKitty> Pods: Another suggestion > Read as much of other people's real world libraries, reading the documentation helps you word your own.
23:25:26 <BadKitty> (Same with the code it's self)
23:25:29 <Pods> will do :)
23:25:47 <BadKitty> ^_^ Have fun. Enjoy your haskell future!
23:26:43 <BadKitty> Also, just a side note; If you'd like to contribute to the hackage database of packages.. You'll need to learn how to use cabal to package. cabal init will give you something basic, but you can extend from that.
23:26:47 <BadKitty> ^_^
23:26:47 <Pods> with the help this channel gives , it is super fun to learn haskell, cant wait to start contributing :D
23:26:58 <otters> tell that to zhivago
23:27:17 <BadKitty> otters: Why?
23:27:54 <otters> I'm sure he believes his strategy of personal insults to be equally effective
23:28:22 <BadKitty> Personal insults?
23:28:50 <otters> Have you never read any Zhivago quotes
23:28:58 <BadKitty> No
23:29:01 <shachaf> I'm not sure the goings-on of ##c are particularly relevant in this channel.
23:29:01 <otters> oh
23:29:19 <otters> #haskell-##c-discussion
23:29:29 * BadKitty doesn't join
23:45:20 <Ralith> oh man, Zhivago
23:46:09 <Ralith> if ever you want a precise and 100% correct, helpful, and informative answer founded in the formal standards, couched in a bombardment of personal attacks
23:46:12 <Ralith> he's your man
23:57:04 <kallisti> it would appear that the lens library cannot automatically derive lenses for existential types?
23:59:59 <supki> no
