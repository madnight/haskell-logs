00:01:31 <otters> is there any way to get around the memory being exhausted when I try to bootstrap cabal
00:04:20 <ivanm> otters: MOAR RAM!
00:04:42 <otters> such a thing is not possible
00:07:18 <otters> anything else
00:08:03 <otters> alternatively a cabal binary for debian 64 bit would be sick
00:10:36 <supki> otters: you can increase swap space
00:10:47 <otters> oh yeah
00:11:04 <Enigmagic> otters: how much ram do you have?
00:11:31 <osa1> I'm trying to debug a haskell program, is there a way to print stack trace at some point in program ?
00:11:42 <osa1> like with a function call like Debug.Trace
00:11:56 <shachaf> @where rts-xc
00:11:56 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
00:12:02 <otters> Enigmagic: 512MB
00:12:30 <shachaf> Why are you using "debian 64 bit"?
00:12:46 <shachaf> Well, OK, there are reasons.
00:13:05 <arkeet> shachaf: such as?
00:13:31 <osa1> shachaf: does evaluating `undefined` count as "unhandled exception" ?
00:13:40 <shachaf> osa1: Try it out!
00:13:44 <otters> schlumpi: many reasons
00:13:48 <otters> shachaf: ^
00:13:56 <shachaf> arkeet: All the reasons x32 exists.
00:14:04 <osa1> ok, another question, is there a way to trace a function call in ghci ? like OCaml's #trace directive
00:15:11 <Enigmagic> otters: i suggest purchasing more ram if you need a 64-bit os
00:20:48 <shachaf> ==Enigmagic
00:21:12 <ivanm> shachaf and Enigmagic are the same person? :o
00:21:12 <ivanm> ;-)
00:21:40 <Enigmagic> shh
00:21:58 <shachaf> Have you ever seen us in the same room together?
00:22:23 <shachaf> (People who don't live in Australia are disqualified from answering this question.)
00:23:10 <shachaf> Hey, RAM prices have gone way up.
00:23:31 <ivanm> well, this is referred to as an IRC chat room, is it not? :p
00:23:42 <osa1> so I'm passing "--ghc-options=-"prof -fprof-auto -rtsopts -osuf .p_o"" parameter to cabal to enable stack traces but then it can't find installed libraries like Parsec and throws "can't find module" error, any ideas ?
00:23:57 <otters> ovz doesn't have swap
00:24:06 <ivanm> osa1: you need to build your other libraries with profiling support
00:24:07 <luite> osa1: yeah unregister all those packages and reinstall
00:24:14 <osa1> uh
00:24:22 <ivanm> if you used cabal-install, edit ~/.cabal/config to enable profiling, and then "cabal install world" (I think)
00:24:23 <osa1> maybe I should go on with Debug.Trace o_O
00:24:42 <pharaun> any good place to go and ask for code feedback on my haskell project?
00:24:43 <shachaf> Wait, no they haven't.
00:24:45 <osa1> I have maybe a hundred cabal packages insalled
00:24:49 <pharaun> here? or should i go over to reddit or?
00:24:53 <luite> ivanm: hm i don't think that reinstalls, but i never use it so i might be wrong
00:25:00 <ivanm> luite: *nod*
00:25:04 <ivanm> might need a --reinstall as well
00:25:09 <ivanm> pharaun: depends how long it is
00:25:30 <shachaf> Note that reinstalls are always dangerous.
00:25:59 <mikeplus64> shachaf: i think i forgot to reply. my repl thing isn't going anywhere atm because of exams
00:26:02 <shachaf> osa1: --enable-executable-profiling; see the manual.
00:26:22 <mikeplus64> shachaf: in the next ghc when there is per thread memory limiting stuff it'll be more or less complete
00:26:23 <pharaun> ivanm: core is 100 line, supporting is another 100 line, io-stuff for pago is ~100 line, then there's 150-200 of supporting types/stuff for aeron
00:26:44 <pharaun> but if folks just want to look at the core its 1 file 100 line
00:26:44 <ivanm> what's pago and aeron?
00:26:46 <shachaf> mikeplus64: What about the rest of the bot?
00:26:56 <mikeplus64> the rest of it is fine and working
00:27:02 <mikeplus64> i think
00:27:04 <Guest74767> is elemIndex part of haskell platform?
00:27:11 <pharaun> ivanm: whoops, aeson - the json library, just huge block of type/parsing stuff
00:27:18 <ivanm> ahhh
00:27:21 <ivanm> makes more sense ;-)
00:27:39 <pharaun> then pago, sorry pango, its um font-rendering stuff, that i use to extract the length of a string in proportional fonts
00:27:41 <ivanm> *shrug* I'm stuck atm, so I can have a look
00:27:50 <mikeplus64> shachaf: want me to put it up somewhere? i don't remember if i did
00:27:54 <pharaun> but its mostly io/low level interface so kinda boring
00:27:57 <pharaun> ivanm: k i'll link the core
00:28:08 <shachaf> mikeplus64: I think you did. I mean a lambdabot replacement.
00:28:17 <shachaf> Wasn't that the plan?
00:28:26 <pharaun> ivanm: project - https://github.com/pharaun/firefox-bookmark  Core: https://github.com/pharaun/firefox-bookmark/blob/master/src/FirefoxBookmark/Sorter.hs
00:28:26 <mikeplus64> yeah
00:29:04 <mikeplus64> shachaf: oh, no i only seem to have put repl up
00:29:30 <pharaun> ivanm: in a nutshell it takes a json dump from firefox, and re-sort the bookmark according to "string" length for title/url
00:29:47 <pharaun> ivanm: it uses pango so it can sort via proportional length (AV vs MM for ex)
00:30:01 <Guest74767> is there anything like find/elemIndex in the standard haskell-platform
00:30:06 <ivanm> I'd use better variable names rather than "x" or "y"
00:30:12 <ivanm> Guest74767: for what, lists?
00:30:15 <ivanm> @hoogle find
00:30:16 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
00:30:16 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
00:30:16 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
00:30:30 <pharaun> ivanm: i thought one of the biggest point that i picked up from lots of libraries is they all used one letter var names
00:30:43 <pharaun> so i was under the impression that the shorter the name, the better
00:30:43 <ivanm> pharaun: yes, but _appropriate_ one letter variable names :)
00:30:56 <Guest74767> ivanm, yeah, I get not in scope for both :(
00:31:03 <pharaun> ivanm: i just got in habit of x y :) but i can probably try to tweak them a bit
00:31:15 <ivanm> pharaun: e.g. for updateIndex, I'd use "updateIndex p i = ... "
00:31:25 <ivanm> Guest74767: import Data.List
00:31:30 <pharaun> ivanm: ah
00:32:08 <ivanm> pharaun: three times x, y are appropriate: 1) mathematical formula, 2) dealing with co-ordinates, 3) polymorphic code (e.g. definition of foldr)
00:32:10 <ivanm> @src foldr
00:32:10 <lambdabot> foldr f z []     = z
00:32:10 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
00:32:20 <Guest74767> ivanm, I dont wanna :(
00:32:45 <ivanm> Guest74767: ummm, OK...
00:32:53 <ivanm> what are you trying to do?
00:32:55 <pharaun> ivanm: k
00:33:11 <ivanm> pharaun: I don't think `k' is a good variable name in that instance either :p
00:33:13 <pharaun> ivanm: i know i also need to improve and learn the haddock documentation style too
00:33:40 <ivanm> pharaun: for resortBookmarkMenu, you may want to consider using <*> from Control.Applicative rather than `ap`
00:33:59 <ivanm> pharaun: breakBySeparator looks like something you might already find in the split package
00:34:06 <Guest74767> ivanm, Split a string at the space using map & where
00:34:10 <ivanm> either way, you might as well use splitAt rather than take and drop
00:34:18 <ivanm> Guest74767: is this homework?
00:34:42 <latermuse> ivanm: isnt splitAt just sugar for take drop?
00:34:48 <ivanm> pharaun: also, it's usually not idiomatic to put type sigs in functions defined inside where
00:34:55 <ivanm> latermuse: yes, but it's a single pass rather than two passes
00:34:55 <Guest74767> ivanm, yeah
00:34:57 <ivanm> efficiency!
00:35:09 <ivanm> Guest74767: you really should have said so then
00:35:12 <latermuse> ivanm: makes sense!
00:35:16 <pharaun> ivanm: really?
00:35:19 <ivanm> Guest74767: but... having to split a string using map? :/
00:35:23 <Guest74767> if it wasnt i'd just splitOn
00:35:25 <pharaun> ivanm: i just got into the habit of type sig on everything
00:35:32 <pharaun> it goes a long way to make sure i keep things straight
00:35:38 <ivanm> pharaun: yeah, let the inferer work it out; top-level for documentation/double-checking
00:35:39 <Guest74767> ivanm, I know :(
00:36:00 <ivanm> pharaun: note that adding type sigs to sub-functions becomes more difficult if it's polymorphic (unless you use ScopedTypeVariables)
00:36:13 <pharaun> already ran into that one case
00:36:14 <ivanm> Guest74767: want to double-check what you need to do?
00:36:26 <pharaun> ivanm: https://github.com/pharaun/firefox-bookmark/blob/master/src/Main.hs
00:36:32 <pharaun> ivanm: iterChild
00:36:48 <pharaun> i cannot even have type sigs on the outtermost function either
00:38:02 <circle> You can mathematically verify Haskell programs (and programs in other languages). But has the Haskell compiler been verified?
00:38:11 <ivanm> pharaun: someone (shachaf?) pointed out to me a neat trick for your sorter function: sorter = mconcat [ flip (comparing pangoLength), comparing extract ]
00:38:13 <circle> If it hasn't then these verifications are useless, aren't they?
00:38:16 <ivanm> circle: don't think so
00:38:36 <circle> How do we know something as big and complex as the Haskell compiler doesn't have bugs?
00:38:40 <ivanm> but people that want such verifications to be stronger will use Coq, etc. and then generate Haskell from that
00:38:40 * hackagebot Ref 0.1.1.0 - Generic Mutable Ref Abstraction Layer  http://hackage.haskell.org/package/Ref-0.1.1.0 (CarterSchonwald)
00:38:43 <arkeet> circle: it does have bugs.
00:38:47 <ivanm> but I don't think the verifications are necessarily "useless"
00:38:58 <circle> People who write high-integrity systems seem to trust their compilers.
00:39:03 <circle> But why, is the question I ask.
00:39:17 <ivanm> because otherwise they'd never get anything done
00:39:22 <circle> Big, complex programs always have bugs, and compilers are big and complex.
00:39:24 <Ralith> a verified program on an unverified compiler is more reliable than an unverified program on an unverified compiler
00:39:30 <Ralith> this seems obvious
00:39:32 <circle> Why do compilers seem to be so utterly bug-free?
00:39:37 <pharaun> ivanm: ahh that's nifty i'll have to play with it
00:39:42 <ivanm> a subset of C was recently verified by the ex NICTA mob that does that phone kernel who's name I've forgotten
00:39:54 <ivanm> circle: because they're big, complex pieces of code
00:40:08 <Ralith> there's compcert
00:40:08 <pharaun> ivanm: any other major suggestion or is my code basically "ok"
00:40:26 <pharaun> i'm mainly wanting to make sure i'm not going down a wrong path :)
00:40:42 <circle> ivan`: Yes, a lecturer of mine who works at NICTA was telling me about that.
00:40:45 <Guest74767> ivanm, I gave a pretty bad description, I need to take a list of names and pull out the second name
00:41:21 <Guest74767> so i want to find where the space is and drop/take using that int
00:41:46 <Guest74767> I just cant find away to do it without importing something weird
00:41:58 <ivanm> pharaun: what does ":type iterChild" say the type of iterChild is?
00:42:05 <ivanm> because it _has_ to have a fixed type
00:42:08 <ivanm> this isn't Python! :p
00:42:12 <ivanm> Guest74767: come again?
00:42:29 <circle> Have there been serious bugs discovered in programming languages? Surely some things must sometimes happen which can't be explained by the program you've written, but by the compiler making an error.
00:42:43 <mauke> circle: compiler bugs aren't language bugs
00:42:58 <ivanm> pharaun: consider using nested fromMaybe for extract rather than isJust/fromJust
00:42:59 <arkeet> mauke: unless the compiler is the language spec ;)
00:43:18 <arkeet> never use fromJust.
00:43:24 <ivanm> Guest74767: if it's a list of names... you mean [Name] ?
00:43:30 <ivanm> if so, why do you need to find spaces?
00:43:40 <ivanm> arkeet: I beg to differ; I have perfectly legitimate uses of fromJust
00:43:49 <arkeet> never* use fromJust
00:43:50 <ivanm> circle: you mean PHP? :p
00:43:55 <ivanm> arkeet: that's better :)
00:44:06 <shachaf> I,I typeOf (fromJust x)
00:44:23 <pharaun> ivanm: i do use fromMaybe here and there, just not sure what a balancing point between the two :)
00:44:33 <pharaun> i suppose i can go and use more nested fromMaybe
00:44:41 <shachaf> fromMaybe is fine.
00:44:52 <circle> ivan`: What about PHP?
00:45:12 <arkeet> does PHP have a language spec?
00:45:17 <ivanm> fromMaybe n = maybe n id
00:45:24 <pharaun> arkeet: | isJust (title x) = fromJust $ title x
00:45:25 <ivanm> circle: isn't it one big bug?
00:45:31 <pharaun> arkeet: that's the only 2 place that i use fromJust
00:45:32 <Guest74767> ivanm, They're strings
00:45:32 <circle> I know the language sucks, but whatever.
00:45:33 <arkeet> pharaun: that's evil.
00:45:38 <shachaf> pharaun: Don't do that!
00:45:38 <elliott> pharaun: ugh.
00:45:39 <ivanm> circle: also, to avoid annoying ivan`, please note the differences in nicks ;-)
00:45:46 <Guest74767> --[[David Mudkip],[Graham Parker],[Emma Balls]] -> [[Mudkip],[Parker],[Balls]]
00:45:55 <circle> ivan`: Okay :P
00:45:56 <Guest74767> first list of lists in input, second is output
00:45:58 <arkeet> | Just y <- title x = y
00:46:00 <arkeet> pattern guards.
00:46:03 <ivanm> pharaun: fromMaybe (fromMaybe "" $ url x) $ title x
00:46:07 <shachaf> pharaun: People will now give you a bunch of alternatives for it.
00:46:13 <pharaun> shachaf: haha i noticed
00:46:21 <elliott> | Just s <- title x = s -- my contribution
00:46:22 <latermuse> @unpl ((.).(.)).(.)
00:46:23 <lambdabot> (\ l b c f i -> l (b c f i))
00:46:24 <pharaun> shachaf: that's why i'm here to ask
00:46:35 <shachaf> Please make sure you understand the main reason it's bad.
00:46:41 <shachaf> elliott would like to explain.
00:46:50 <elliott> here is my explanation: ask arkeet.
00:46:54 <pharaun> shachaf: even if i guard it with isJust ?
00:46:58 <elliott> yes.
00:47:02 <shachaf> pharaun: Yes.
00:47:19 <shachaf> @where boolean-blindness # good post, but maybe only if you already understand this point
00:47:19 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
00:47:49 <arkeet> pharaun: the problem with that is you can't locally check that your code is safe.
00:47:56 <arkeet> or works.
00:47:56 <shachaf> pharaun: The trouble is this: In | isJust x = ...fromJust x..., you are keeping a proof in your head that x isn't Just.
00:48:09 <shachaf> The compiler can't check your head, so it can't give you a warning if you make a mistake.
00:48:12 <arkeet> isn't Nothing, rather.
00:48:17 <shachaf> Yes. That.
00:48:24 <shachaf> See, I really need a compiler to check my head.
00:48:27 <shachaf> All I have is arkeet.
00:48:27 <arkeet> @let isn'tNothing = isJust
00:48:29 <lambdabot>  Defined.
00:48:58 <shachaf> pharaun: If you use pattern-matching and no unsafe functions, this just can't happen.
00:49:07 <shachaf> The compiler guarantees: Your program won't crash*.
00:49:14 <pharaun> isn't pattern checking in the compiler doing the same thing?
00:49:14 <arkeet> assuming your pattern matches are exhaustive.
00:49:17 <shachaf> * Unless you use unsafe functions or unsafe recursion or [..]
00:49:28 <shachaf> pharaun: Yes -- but look at this:
00:49:30 <pharaun> there's tools to test to make sure your pattern matches are exhaustive
00:49:34 <shachaf> | isJust x = ...fromJust x...
00:49:36 <arkeet> sure.
00:49:39 <shachaf> | otherwise = ...fromJust x...
00:49:44 <arkeet> but there aren't tools to make sure you only use fromJust safely.
00:49:50 <pharaun> yeah
00:49:54 <elliott> "the compiler does that" is generally a good argument not to do a thing.
00:49:59 <elliott> like, the compiler also writes assembly.
00:50:03 <pharaun> haha
00:50:14 <elliott> it's supposed to take care of those details for you
00:50:37 <pharaun> i don't know why i did the fromJust thing in that 2 line there >_<
00:50:53 <pharaun> guess i was just being dumb :p
00:51:27 <ivanm> you could even use the Alternative instance within the Maybe Monad...
00:51:30 <arkeet> I look up and see a link with fromJust in it.
00:51:33 <arkeet> I was thinking about that.
00:51:40 <arkeet> extract x = fromMaybe "" (title x <|> uri x)
00:51:45 <pharaun> oh yeah
00:51:47 <pharaun> alternative
00:51:57 <pharaun> i've used it before, i keep on forgetting all of these nifty stuff
00:52:09 <arkeet> @pl extract x = fromMaybe "" (title x <|> uri x)
00:52:09 <lambdabot> extract = fromMaybe [] . liftM2 (<|>) title uri
00:52:30 <pharaun> hm
00:52:35 <ivanm> since we're using Alternative, might as well use Applicative and have liftA2 rather than liftM2 :p
00:52:39 <pharaun> heh
00:52:47 <arkeet> I'd always use liftA2 there.
00:53:00 <shachaf> I,I fromMaybe "" . msum . sequence [title,uri]
00:53:10 <pharaun> any other big pointers about my core code?
00:53:40 <ivanm> shachaf: what do you mean by "I,I" ?
00:53:52 <shachaf> It's an owl face.
00:53:57 <pharaun> oh ha
00:54:01 <ivanm> if you say so... ;-)
00:54:02 <arkeet> shachaf: I don't believe you.
00:54:07 <arkeet> ;)
00:54:21 <shachaf> pharaun: It seems that my proof-arrying phrasing was a bit weird and unconvincing.
00:54:39 <ivanm> shachaf: _this_ is an owl face: http://www.examiner.com/images/blog/wysiwyg/image/prints_owls_great_horned_owl_face.jpg?dur=266#
00:54:48 <shachaf> pharaun: What I mean is just that it's unchecked by the compiler.
00:55:08 <pharaun> the isJust -> fromJust is something i did manually
00:55:12 <pharaun> vs letting the compiler do it for me
00:55:33 <arkeet> you should let the compiler do as much for you as it can.
00:55:44 <pharaun> i generally aim to do that or at least try
00:55:50 <pharaun> >_<
00:56:03 <shachaf> pharaun: A good way to get practice is to never use unsafe functions.
00:56:16 <shachaf> Unsafe in the sense of head, tail, fromJust, etc.
00:56:18 <arkeet> shachaf: but you use unsafeCoerce all the time!
00:57:00 <ivanm> shachaf: I believe that's in the "hacker koan" style that he knows what he's doing when he whacks the computer to get it to work ;-)
00:57:19 <pharaun> shachaf: yeah, point taken, is there a good way of identifying if a function is unsafe or shall i have to trust in the document and inspect the code if i am uncertain?
00:57:34 <pharaun> well unsafe* clearly is unsafe ;p
00:57:47 <shachaf> Usually they're unsafe in this sense if their type claims to do impossible things.
00:57:58 <mauke> (a -> a) -> a
00:58:03 <pharaun> ala "Just a -> a" ?
00:58:10 <mauke> [a] -> a
00:58:14 <shachaf> This isn't fool-proof: For example tail :: [a] -> [a] is unsafe.
00:58:22 <shachaf> But it's a good heuristic.
00:58:22 <pharaun> yeah that's the case i was wondering
00:58:37 <ivanm> shachaf: I wonder whether it would make sense to have tail [] = [], just to make it safe
00:58:41 * hackagebot VKHS 0.3.3 - Provides access to Vkontakte social network via public API  http://hackage.haskell.org/package/VKHS-0.3.3 (SergeyMironov)
00:58:42 <arkeet> :t drop 1
00:58:42 <mauke> tail = drop 1
00:58:44 <lambdabot> [a] -> [a]
00:58:58 <shachaf> Maybe there should be a rewrite rule, drop 1 = tail
00:59:14 <ivanm> yeah
00:59:26 <arkeet> drop 1 = tail would be a great rewrite rule.
00:59:48 <ivanm> though it would then confuse people when you tell them that tail is unsafe :p
01:00:03 <ivanm> also, don't rewrite rules only happen when optimising? that would thus give you different behaviour in ghci from ghc -O
01:00:03 <arkeet> tail = drop 1 would be a boring one.
01:00:22 <shachaf> ivanm: My rewrite rule works the other way.
01:00:49 <arkeet> ivanm: see what a horrible person shachaf is?
01:00:50 <ivanm> oh, you mean make drop 1 unsafe?
01:01:10 <ivanm> I thought that at first, then guessed that rewrite rules were the other way round for some reason :/
01:01:23 <pharaun> some people just like to play with fire
01:02:05 <pharaun> ivanm: outside of what we just spoke of, did my sorter.hs seems ok
01:02:10 <pharaun> or at least a start
01:02:17 <ivanm> yeah
01:02:38 <ivanm> no obvious "WTF?"s that I could see, apart from the fromJust bit
01:02:40 <arkeet> now rewrite it to use lens!
01:02:48 <pharaun> haha i'm kind of wary of lens
01:02:56 <pharaun> cos i don't really understand the math behind it
01:03:07 <pharaun> i've sat down a couple time so far and it makes me go crossy-eyed
01:03:33 <shachaf> I should go write my lenstroduction.
01:03:41 <arkeet> I'm wondering why your Primary type has fields with types like Maybe [Primary]
01:03:50 <pharaun> arkeet: parser
01:03:53 <edwardk> shachaf: sounds like a plan
01:04:02 <elliott> there's not really all that mathematics behind lens.
01:04:17 <elliott> well, there is a bit, but it's all stupid. mathematically.
01:04:23 <elliott> even shachaf and I understand it!
01:04:24 <arkeet> shachaf: any development on the pure profunctor lens side yet?
01:04:24 <pharaun> arkeet: basically i'm parsing a nested json, which is basically lists of primary nested into primaries and so on down the stack
01:04:34 <arkeet> er, lately.
01:04:36 <pharaun> so that's where the Maybe's comes from
01:04:41 <edwardk> arkeet: nada
01:04:41 <arkeet> pharaun: ok.
01:04:57 <edwardk> arkeet: we know how to do it, it just hasn't paid out enough dividends to justify the end user experience impact
01:05:04 <shachaf> arkeet: lens is dead.
01:05:07 <shachaf> So it goes.
01:05:09 <edwardk> shanse: =P
01:05:18 <pharaun> edwardk: what do you mean by dividends?
01:05:52 <shachaf> pharaun: There's no point to doing it.
01:05:54 <pharaun> arkeet: re rewriting it to use lens, i only really "update" my records in two fields
01:05:55 <shachaf> Or not enough point.
01:06:02 <pharaun> ah, heh
01:06:06 <edwardk> pharaun: "pure profunctor" lenses can be done but they come at an end-user cost. They are simpler in some ways, but they also mean that users then definitely need to incur a dependency on lens to use them, and it takes you outside of Haskell 98 earlier than the existing lens model
01:06:21 <pharaun> edwardk: ah
01:06:47 <shachaf> edwardk doesn't care about Haskell 98, except when he does.3
01:06:49 <edwardk> pharaun: one huge benefit of the existing model is it is easy to introduce through the existence of 'traverse' and existing combinators people already know how to use
01:06:59 <arkeet> .3
01:07:15 <edwardk> shachaf: i freely admit that my positions on each issue vary from library to library ;)
01:07:16 <pharaun> edwardk: so if i support 'traverse' and others, folks can use my code with lens?
01:07:23 <edwardk> pharaun: yes
01:07:29 <pharaun> that seems lovely
01:07:33 <edwardk> > [1..10]^..traverse.filtered even
01:07:37 <lambdabot>   [2,4,6,8,10]
01:08:13 <edwardk> > [[1..5],[6..10]]^..traverse.traverse.filtered even
01:08:16 <lambdabot>   [2,4,6,8,10]
01:08:45 <edwardk> pharaun: but more over even if you define your own function that 'looks kinda like traverse' it works
01:09:03 <edwardk> both f (a,b) = (,) <$> f a <*> f b  --isn't a valid 'traverse' definition, but its a perfectly cromulent traversal.
01:09:21 <edwardk> > (1,2) & both +~ 10
01:09:23 <lambdabot>   (11,12)
01:09:31 <latermuse> edwardk: thats a cool traversal
01:09:33 <edwardk> > (1,2)^..both
01:09:35 <lambdabot>   [1,2]
01:09:36 <pharaun> edwardk: cool
01:09:59 <edwardk> latermuse: it has 'big brother' versions of it in the main lens code base
01:10:09 <edwardk> > (1,2,3,4,5,6)^..each
01:10:09 <shachaf> imo that definition would be much prettier if it had a few names like "indexed" and "tabulatePro" sticking around somewhere.
01:10:11 <lambdabot>   [1,2,3,4,5,6]
01:10:18 <latermuse> edwardk: awesome!
01:10:19 <shachaf> s/.$//
01:10:20 <edwardk> shachaf: =P
01:10:49 <arkeet> > (1,2,3,4,5,6)^._1345
01:10:51 <lambdabot>   Not in scope: `_1345'
01:10:53 <arkeet> aw.
01:10:55 <edwardk> > (1,2,3,4,5,6) & each *~ 10
01:10:57 <lambdabot>   (10,20,30,40,50,60)
01:11:19 <edwardk> > (1,2,3,4,5,6) & each.filtered even *~ 10
01:11:21 <lambdabot>   (1,20,3,40,5,60)
01:11:34 <arkeet> > (1,2,3,4,5,6) & each.filtered odd *~ 2
01:11:35 <lambdabot>   (2,2,6,4,10,6)
01:11:47 <shachaf> (forall m. Monoid m => (a -> m) -> m) is an OK free monoid, but (forall g. Group g => (a -> g) -> g) is a pretty horrible free group. :-(
01:11:54 <edwardk> filtered is evil there, because it isn't a valid traversal but it lets you use it as such
01:12:01 <pharaun> shachaf: is this boolean blindness also the reason why we went for LT | EQ | GT data type for sort/compare
01:12:12 <arkeet> no
01:12:30 <pharaun> well its also easier to have stable sorts too?
01:12:51 <arkeet> shachaf: why so?
01:14:09 <shachaf> I,I data MightBe a b = a ~ b => Is | Isn't
01:16:29 <shachaf> arkeet: Because it doesn't "simplify", e.g. store "abb^-1" as "a"
01:16:35 <arkeet> sure.
01:16:44 <arkeet> not much you can do that without Eq.
01:16:47 <arkeet> about that.
01:16:56 <shachaf> Right.
01:17:15 <shachaf> It's a bigger deal with free commutative groups or something.
01:18:41 * hackagebot cake 1.0.0 - A build-system library and driver  http://hackage.haskell.org/package/cake-1.0.0 (JeanPhilippeBernardy)
01:18:42 <arkeet> the "free group" without simplification is still ok when viewed through an honest group.
01:18:49 <arkeet> same for the abelian one.
01:19:03 <shachaf> Sure.
01:19:10 <arkeet> you could also take FreeAbelianGroup a = a -> Integer
01:19:14 <shachaf> Just operationally.
01:19:17 <arkeet> except
01:19:26 <arkeet> we can't make that a functor.
01:19:35 <arkeet> and you'd have to restrict to functions with finite support somehow.
01:19:50 <arkeet> oh wait.
01:19:53 <arkeet> it just won't work.
01:19:59 <shachaf> ?
01:20:00 <arkeet> we have no way of putting an a in there.
01:20:05 <arkeet> without Eq.
01:20:39 <arkeet> well you could just take the free group for that.
01:21:31 <arkeet> no one would know the difference.
01:21:36 <arkeet> no abelian group would know, anyway.
01:21:55 <pharaun> nn all (thanks again!)
01:22:30 <shachaf> free groups more like expensive groups when you consider the total cost of ownership am i right
01:22:35 <arkeet> lol
01:23:15 <shachaf> Free monoids are only free if your time has no value.
01:23:28 <Cale> lol
01:32:43 <wi> hello, im using cabal-dev on a project and am wanting to use the locally installed bytestring-0.10.0.2 in my project instead of the globally installed bytestring-0.9.2.1 (from haskell-platform). i have tried adding bytestring >=0.10.0.2 as a build-dependency in the cabal-file, but when i 'cabal-dev ghci' i get the following error: "cabal: At least the following dependencies are missing: bytestring >=0.10.0.2 && ==0.9.2.1", does anyone know how i
01:32:43 <wi> could hide the older version of bytestring such that i can use the newer one? thanks in advance
01:33:15 <shachaf> Probably one of your dependencies depends on bytestring 0.9.2.1
01:33:30 <shachaf> If I remember correctly bytestring is one of those packages you're not supposed to upgrade.
01:33:46 <wi> but how am i to use the newest version then?
01:33:52 <shachaf> If all you want to do is convert between lazy and strict bytestrings, I recommend using toChunks and fromChunks instead.
01:33:52 <arkeet> get a newer ghc
01:34:22 <wi> alright, thanks, so no haskell-platform then
01:34:51 <shachaf> Alas.
01:36:58 <augur> is there any way in haskell to have a value that is partially mutability? for instance, lets say data MPair a b = MPair a b where the b argument is mutable?
01:37:26 <wi> MPair a (IORef b)
01:38:08 <augur> is it possible without using IORef?
01:38:14 <ivanm> STRef?
01:38:15 <augur> i mean, without something as powerful as IO stuff
01:38:18 <augur> STRef huh?
01:38:20 <augur> interesting!
01:43:00 <wi> does anybody know of a nicer way of installing the newest ghc on ubuntu other than from source?
01:43:21 <shachaf> Install from binaries.
01:43:28 <shachaf> Does "source" mean "source code" or "haskell.org"?
01:44:37 <ivanm> wi: see if there's a PPA?
01:44:42 <wi> with "from source" i meant "from the binary package" (http://www.haskell.org/ghc/download_ghc_7_6_2)
01:46:34 <shachaf> I recommend the binary package.
01:47:14 <arkeet> @hackage binary
01:47:14 <lambdabot> http://hackage.haskell.org/package/binary
01:47:36 <wi> ill install ghc's binary package then
01:56:44 <ivanm> wi: no-one has packaged GHC 7.6.2 in a ppa for ubuntu? :o
01:56:48 <ivanm> I figured _someone_ would have
01:57:38 <wi> ivanm: it seemed easier to just install the binary package
01:58:11 <ivanm> *shrug*
01:58:42 * hackagebot bytes 0.2 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.2 (EdwardKmett)
02:14:47 <wi> when installing a package with cabal-dev, the following 'conflicting' lines pop up: "Unknown fields: default-language (line 5)" and "Warning: Packages using 'cabal-version: >= 1.10' must specify the
02:14:47 <wi> 'default-language' field for each component (e.g. Haskell98 or Haskell2010).
02:14:47 <wi> ". could this be a bug, or an unimplemented feature, or just something silly i did? (ie specified Cabal-Version to be >= 1.14)
02:15:39 <supki> default-language field is meant to be placed in Library/Executable/etc sections
02:16:15 <supki> line 5 suggests you placed it at the top level
02:16:29 <wi> yep
02:18:06 <otters> if anyone can provide a debian amd64 cabal binary, that would be totally awesome
02:24:55 <quchen> What was the extension again that lets me add a type to a class?
02:25:17 <quchen> as in "class MyThing a where { data Foo :: * -> * }
02:25:18 <quchen> "
02:25:25 <supki> TypeFamilies
02:25:36 <quchen> Oh, that's type families?
02:25:46 <quchen> I thought that was something completely different.
02:25:49 <quchen> Thanks
02:27:17 <supki> yeah, TypeFamilies enables suprising amount of stuff
02:28:42 * hackagebot binary-file 0.13.1 - read/write binary file  http://hackage.haskell.org/package/binary-file-0.13.1 (YoshikuniJujo)
02:30:26 <kranius_> otters: I can do that
02:30:43 <otters> kranius_: nah, found a workraonud
02:30:47 <otters> workaround
02:30:49 <otters> but thanks
02:35:01 <otters> kranius: i spoke far too soon
02:37:22 <kranius> otters: :)
02:43:43 * hackagebot bytes 0.3 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.3 (EdwardKmett)
02:47:13 <quchen> Looking at type families raises the question how good it is to use them. As a language extension, they're potentially gone in a few releases.
02:47:33 <elliott> why would type families go?
02:47:39 <quchen> There are extensions that will probably stick around because they're small, BangPatterns for example
02:47:49 <elliott> they are very important and widely used. a lot of work has been done on them
02:47:52 <elliott> they're here to stay
02:48:04 <quchen> elliott: They're an experimental language feature.
02:48:38 <quchen> That's what I meant to ask: how do I decide whether I can use something in a future-proof way?
02:48:49 <elliott> depends how strictly you interpret "experimental" :)
02:49:07 <elliott> they're well-understood, used all over the place, and fairly old
02:49:12 <quchen> elliott: I am pretty unfamiliar with the entire process of GHC development
02:49:20 <quchen> (And pretty new to Haskell in general)
02:49:50 <quchen> So there's not going to be some note "Hey, GHC 7.10 won't have them. Told ya they're experimental"?
02:49:52 <elliott> it would break way too much code to drop them -- maybe in the very long term someone will think of some amazing thing that's 10x better than type families, but the idea is pretty simple, and even disfavoured stuff tends to stick around for billions of years in GHC (e.g. implicit parameters)
02:50:24 <quchen> Implicit parameters are bad? Oh.
02:50:33 * elliott can't imagine a situation in which GHC 7.x would drop support for type families for any x
02:50:41 <quchen> Well, I wouldn't use them in actual code, but in GHCi they're a blessing
02:50:56 <elliott> yeah, implicit parameters are useful for interactive stuff. just not their actual intended use...
02:52:21 <quchen> That's not their intended use?
02:52:28 <arkeet> haha
02:52:41 <elliott> their intended use is a dynamically-scoped variable sort of like the Reader monad.
02:52:49 <elliott> they're kind of bad at it.
02:52:58 <quchen> I thought of them as "you use ? when you can't be arsed to think about what you actually mean"
02:53:17 <arkeet> I want a type-level Map.
02:53:26 <quchen> ... because?
02:53:28 <arkeet> because.
02:53:36 <quchen> Map is pretty type-level already ;-)
02:54:20 <shachaf> ?hi
02:54:29 <shachaf> ?hi aaron
02:54:29 <lambdabot> *** "Aaron" hitchcock "Hitchcock's Bible Names Dictionary (late 1800's)"
02:54:29 <lambdabot> Aaron, a teacher; lofty; mountain of strength
02:54:30 <lambdabot>  
02:56:30 <quchen> elliott: Follow-up question to before: when things are here to stay, why are they still extensions?
02:56:36 <mami> heyho
02:56:37 <quchen> Is it a standardization problem?
02:56:42 <quchen> Hey mami
02:57:19 <mami> what do you think is a better idea to represent a cube made of 4x4x4 segments if i want to "unroll" it into a snake and back again
02:57:26 <mami> 3 dim array or a list of 3 tuples?
02:58:03 <quchen> mami: Lists are generally bad for random access.
02:58:17 <mami> yep thats what i thought too
02:58:32 <quchen> I'm not sure what you mean with unrolling, but it sounds like you want Array, where you can use 3-tuples as indices.
02:58:40 <elliott> quchen: the haskell standardisation process is not the fastest or most active of things
02:58:43 <bitonic> mami: with a 4x4x4 cube, it won’t matter anyway
02:58:56 <quchen> bitonic: That's true
02:59:01 <mami> bitonic: not for the speed
02:59:10 <elliott> in the 12 year gap between Haskell 98 and Haskell 2010, it only picked up a couple very minor language extensions, and one or two pedantic tweaks
02:59:11 <mami> but for code cleanness
02:59:18 <elliott> (plus incorporating the FFI, which was an addendum in 98)
02:59:28 <bitonic> mami: well, indexing is not that much cleaner with, say, ‘array’
02:59:34 <arkeet> I think pattern guards are a worthwhile language extension.
02:59:41 <mami> what do you mean with indexing?
02:59:49 <mami> bitonic
02:59:55 <quchen> elliott: Oh, so 2010 being only a minor update to 98 wasn't a design decision but the result of inactivity?
02:59:59 <elliott> basically the entire haskell infrastructure relies on quite a lot of things that are GHC extensions (but note: when other implementations were active (unfortunately not really now), they implemented some of GHC's extensions... they're not all totally GHC-only things)
03:00:09 <elliott> quchen: oh, it was probably an intentional decision.
03:00:14 <elliott> I don't know for sure.
03:00:15 <bitonic> quchen: it’s a good thing that the standard is very conservative—with time many extensions are subsumed by different ones and some are just debatable
03:00:29 <elliott> but it means that important things are extensions, and will be for the forseeable future
03:00:42 <bitonic> quchen: the standard, as I see it, aims at giving a very solid and well understood language, and GHC Haskell isn’t
03:00:46 <elliott> for something like type families or GADTs, I think that's probably a good thing; the basic ideas are known to be good, but that doesn't mean there's not possibility for refinement
03:00:55 <elliott> so they're not necessarily ready to shove into the standard, even if they're ready to use today
03:01:01 <bitonic> mami: I mean ‘pick the 2nd element of the 3rd list’ or whatever
03:01:12 <mami> ah, okay
03:01:18 <mami> yeah thats what we are doing
03:01:28 <bitonic> mami: well it is a bit better with ‘array’ since you can use a 3-tuple
03:01:38 <bitonic> but array is a annoying in many other ways
03:02:12 <quchen> elliott: So I guess I can see the often-discussesd extensions (GADT, ...) as de-facto standard extensions in terms of code; not being standard is a way of being able to specify them informally so they can be refined easier
03:02:29 <bitonic> quchen: I’m not sure what extensions you were referring to, but for the type system ones thing if you get even only RankNTypes inference is very poorly understood for example
03:02:35 <elliott> sure
03:02:50 <elliott> bitonic: I don't think "poorly-understood" is fair
03:03:12 <quchen> bitonic: I only recently discovered TypeFamilies, and wasn't sure how safe it would be to have a lib rely on them fundamentally
03:03:19 <quchen> That's where the initial question came from
03:03:36 * elliott thinks RankNTypes is probably the most well-understood type system extension by a very large margin
03:03:37 <bitonic> elliott: well, GHC algorithm contains some pretty arbitrary choices.  what’s understood is how to implement a partial inference with stuff like Agda but GHC does something different
03:04:12 <elliott> bitonic: oh, I interpreted you more generally: as in, saying that it wasn't understood how type inference interacts with rank-n in general at all, rather than in the context of Haskell
03:04:35 <bitonic> elliott: that’s why I picked RankNTyepes—it’s one of the most ‘basic’ one
03:04:50 <bitonic> elliott: yes I’m talking about RankNTypes + Haskell
03:05:28 <quchen> Speaking of RankN: what's a rank-3 type? Rank 2 for me is "something that has a forall somewhere on the inside"
03:05:41 <quchen> Rank 3 would be a quantifier in that quantifier block?
03:05:43 <arkeet> rank-2 is something that has a forall on the left of a ->
03:05:51 <arkeet> rank-3 is something that has a forall on the left of two ->s
03:05:52 <bitonic> my point is that it still happens that I’m puzzled by RankNTypes, see <http://www.haskell.org/pipermail/haskell-cafe/2013-January/105622.html> for example.  I’m never puzzled by basic HM
03:05:52 <ivanm> quchen: RankN is when you have foralls on the foralls :p
03:06:02 <arkeet> ((forall blah stuff -> a) -> b) -> c
03:06:14 <arkeet> that's rank 3.
03:06:20 <quchen> forall a. (a -> (forall b. b -> (forall c. c)))
03:06:22 <quchen> ^ not this?
03:06:29 <arkeet> that's rank 2.
03:06:34 <arkeet> you can float the forall c. outside
03:06:49 <arkeet> wait
03:06:51 <quchen> arkeet: Yours looks like a forall nested 3 parens deep
03:06:52 <arkeet> that's rank 2.
03:06:53 <arkeet> er 1.
03:07:00 <arkeet> quchen: yes, but the foralls appear on the left side of ->
03:07:01 <arkeet> not on the rigth.
03:07:07 <elliott> bitonic: right. there is some stuff I've read that makes higher-rank stuff behave more predictably
03:07:13 <arkeet> a -> forall b. b is the same as forall b. (a -> b)
03:07:14 <elliott> I agree that GHC's implementation is hard to guess
03:07:16 <quchen> Oh I see.
03:07:25 <quchen> 1: forall a. a -> a
03:07:31 <elliott> though I've mostly solidified my intuition for it by now.
03:07:47 <quchen> 2: (forall b. a -> b) -> a
03:08:08 <quicksilver> 2: (forall b . b) -> a
03:08:10 <arkeet> or (forall b. b) -> a
03:08:12 <arkeet> sure.
03:08:20 <quchen> I see.
03:08:38 <quchen> But what makes your example above rank 3?
03:08:47 <quchen> I.e. what is counted to reach the 3?
03:08:54 <quchen> "foralls left of ->"?
03:09:02 <arkeet> there's a forall in the left side of a -> which is itself in the left side of a ->
03:09:09 <bitonic> quchen: it’s how many -> you jump to get to a forall
03:09:24 <arkeet> ((forall a. a) -> b) -> c is rank 3.
03:09:56 <quchen> So it's related to nesting, but not the same (because there's the "has to be left of" clause)?
03:10:19 <quchen> ((b -> forall a. a) -> c      <=  Rank 2?
03:10:27 <arkeet> that is rank 2.
03:10:38 <arkeet> it's the same as (forall a. b -> a) -> c
03:10:39 <bitonic> elliott: what algorithms were you referring to anyway?  the annoying thing with RankNTypes and HM is that is screws up the type scheme/types distinction
03:11:07 <mreh> has cabal-dev's functionality been integrated into cabal yet?
03:11:26 <bitonic> mreh: no
03:11:28 <quchen> arkeet: Looks like some basic inference rule, it's probably the CurryHowarded version of "a => forall b. b   ==>  forall b. a => b"
03:11:42 <arkeet> indeed.
03:11:45 <bitonic> mreh: when it will, you’ll get a DEPRECATED sign in ‘cabal-dev’ :P
03:11:46 <elliott> bitonic: I was thinking of the MLF/HMF/HML stuff
03:11:47 <arkeet> and that's a <==>
03:12:12 <bitonic> elliott: cool, thanks
03:12:13 <mreh> bitonic: if you say so :)
03:13:25 <bitonic> elliott: thanks
03:13:44 <supki> bitonic: aren't sandboxes in HEAD now?
03:14:08 <bitonic> supki: HEAD of cabal?  maybe, I was referring to the released cabal
03:14:28 <quchen> arkeet: <==>   =>    ==>
03:14:29 <quchen> ;-)
03:14:30 <supki> oh, sure
03:14:44 <arkeet> but <==>  </=  ==>
03:14:44 <arkeet> :p
03:15:02 <arkeet> or rather
03:15:13 <quchen> We need a "not necessarily" symbol.
03:15:19 <arkeet> (<==> -> x)   =/>    (==> -> x)
03:15:20 <bitonic> supki: oh yes you are right the ‘cabal sandbox-*’ commands
03:15:20 <quchen> Or quantifiers.
03:15:38 <mreh> supki: I was reading that the implementation had started, but not finished
03:15:41 <bitonic> wonder when that will come out
03:16:19 <mreh> not long hopefully
03:19:51 <ramses_> quchen: if you look at (->) as logical implication, you see there is a big difference between the quantor being on the left or on the right of the implication, (a -> b  <=>  (not a) v b)
03:20:37 <m_hyperbolic> If I have a list of lists, shoudln't it be possible to map a zipWith function over that list ?
03:22:01 <quchen> ramses_: I don't understand. (I should re-read that chapter on logic.)
03:22:07 <ramses_> > map (zipWith (+) [2,3]) [[1,2],[2,3]]
03:22:09 <lambdabot>   [[3,5],[4,6]]
03:22:19 <ramses_> quchen: what part don't you understand?
03:22:27 <going_up> haskel sure looks popular on freenode
03:22:27 <ramses_> m_hyperbolic: like that? ^^
03:22:33 <quchen> The "you see there's a big difference ..." part.
03:22:37 <quchen> I don't see.
03:22:59 <ramses_> quchen: the not to start with, which flips the quantor if you pull it through
03:23:05 <m_hyperbolic> ramses_: Yes!
03:23:13 <quchen> You're saying that "forall b. a -> b" is not the same as "a -> forall b. b" right
03:23:28 <ramses_> quchen: one if existential, the other universal
03:23:34 <elliott> those two types are the same
03:23:44 <ramses_> quchen: ah, with parens that is
03:23:51 <elliott> what parens?
03:24:03 <quchen> I'm confused
03:24:33 <sipa> forall b. (a -> b)    is different from   a -> (forall b. b)
03:24:36 <ramses_> quchen: I say (forall a. a) -> b is different from a -> (forall b .b), one is existential, the other universal
03:24:50 <arkeet> sipa: how?
03:25:07 <sipa> hmm
03:25:11 <quchen> ramses_: Why is the first one existential?
03:25:17 <sipa> i'm wrong
03:25:24 <arkeet> quchen: (forall a. a) -> b = exists a. (a -> b)
03:25:46 <quchen> Ah. That's one of the inference rules for forall I assume
03:25:46 <ramses_> quchen: because of the negation hidden in the antecedent of the implication
03:26:04 <ramses_> quchen: a -> b  <=>  (not a) v b
03:26:11 <arkeet> ramses_: only classically!
03:26:25 <quchen> arkeet: Not so in intuitionistic logic?
03:26:59 <ramses_> arkeet: o.O care to elaborate?
03:27:14 <elliott> implication isn't defined like that in intuitionistic logic
03:27:46 <quchen> It's defined as "assuming A" .. B  |  A => B
03:27:49 <arkeet> ramses_: in intuitionistic logic, one has ((not a) v b) -> (a -> b), but not the other way.
03:27:49 <quchen> ... right?
03:27:50 <elliott> it's primitive, in fact.
03:27:50 <ramses_> how is it defined then? I always use that to reason about types with explicit quantors
03:27:55 <elliott> and you define ~p = p -> _|_
03:28:14 <elliott> ramses_: well, ~p \/ q would give evidence of either ~p, or q. you'd be able to tell which.
03:28:18 <quchen> elliott: What is ~ defined as in classical logic?
03:28:18 <elliott> p -> q just turns any p into a q.
03:28:25 <ramses_> ok, then I'll just shut up until I know more about that :)
03:28:46 <elliott> (as in, given evidence of p, it'll give you evidence of q)
03:28:52 <ramses_> quchen: in classical logic everything is either false or true, this ~true <=> false and vice versa
03:28:59 <ramses_> s/this/thus
03:29:02 <going_up> is this communism
03:29:08 <elliott> going_up: ?
03:29:45 <quchen> elliott: What did you mean with "~p \/ q would give evidence of either ~p, or q. *you'd be able to tell which*."?
03:29:47 <going_up> classical logic vs communism?
03:29:57 <elliott> going_up: are you trolling?
03:30:06 <elliott> quchen: like Either (p -> Void) q in Haskell.
03:30:15 <going_up> I am just trying to make sense of it.
03:30:17 <elliott> quchen: in classical logic, you have p \/ ~p for any proposition
03:30:29 <going_up> I thought progressives were communist
03:30:31 <quchen> elliott: Yep.
03:30:34 <elliott> which means that a proof of (p \/ q) doesn't necessarily give evidence for either p or q.
03:30:39 <elliott> because you could have invoked excluded middle along the way
03:30:55 <elliott> with intuitionistic logic, it does. just like how (Either p q) in Haskell is either a Left or a Right and you can case on it to find out which, and it's computable.
03:31:32 <arkeet> @djinn Either (a -> Void) a
03:31:33 <quchen> Eh, wait, in classical logic (p \/ q) doesn't mean one of p, q is true?
03:31:33 <lambdabot> -- f cannot be realized.
03:31:41 <quchen> Isn't that intuitionistic logic?
03:31:51 <elliott> quchen: it's not that simple :)
03:31:57 <elliott> they have different notions of "true", that's the whole point
03:31:58 <arkeet> quchen: intuitionistic logic isn't about truth.
03:32:04 <going_up> classical logic vs institutional logic?
03:32:07 <arkeet> not in the classical sense, anyway.
03:32:08 <elliott> in intuitionistic logic, a proof of p gives *evidence* for p
03:32:09 <ramses_> elliott: how then do you arrive at the conclusion that in "(forall a. a) -> b" a is existentially qualified in intuitionistic logic? I understand it in the classical case
03:32:14 <shachaf> No logic is about truth.
03:32:15 <going_up> what are you guys hacking the obama drone?
03:32:17 <elliott> ramses_: I never said that
03:32:19 --- mode: ChanServ set +o elliott
03:32:26 <quchen> Thanks.
03:32:27 --- mode: elliott set +b *!*one@*.dsl.stl2mo.sbcglobal.net
03:32:27 --- kick: going_up was kicked by elliott (trolling)
03:32:32 --- mode: elliott set -o elliott
03:32:39 <ramses_> elliott: are you now saying it isn't true then?
03:33:00 <elliott> oh, I see what you mean
03:33:15 <elliott> I think it depends entirely on how you define "existentially".
03:33:29 <quchen> elliott: I'm still not very sure I understand what truth means I guess. When people say "in intuitionistic logic it's providing a proof" I think of a tuple (true thing, proof to it)"
03:33:31 <ramses_> (is the word "quanatified" in english? as in "universally quantified"?)
03:33:51 <arkeet> sure, you can talk about a universally quantified *variable*
03:33:58 <elliott> quchen: consider this
03:34:10 <elliott> a proof of (RiemannHypothesis \/ ~RiemannHypothesis) in classical logic, doesn't tell you which of those is true.
03:34:13 <elliott> you can't tell from looking at the proof.
03:34:16 <elliott> in intuitionistic logic you can.
03:34:37 <ramses_> elliott: huh? I mean, given a formula "(forall a. a) -> b", how would you convert this to implicative normal form in intuitionistic logic? In classical logic that would be "exists a. b <- a"
03:34:55 <quchen> I see. In classical logic, knowing "Riemann || not Riemann" is a tautology.
03:35:13 <elliott> then compare: (RiemannHypothesis -> Foo) and Either (RiemannHypothesis -> Void) Foo
03:35:16 <quchen> In intuitionistic logic, knowing "Riemann" alone requires a proof for it, similar "not Riemann".
03:35:20 <elliott> (as in, p -> q vs. ~p \/ q)
03:35:20 <arkeet> another way to say it: an intuitionistic proof that something exists constructs such a thing.
03:35:30 <ramses_> arkeet: okay, I'm not a native english speaker, hence the question :)
03:35:37 <elliott> the former doesn't tell you anything about whether RiemannHypothesis is inhabited or not (intuitionistically)
03:35:44 <quchen> So intuitionistically, "Riemann \/ not Riemann" means you have proofs for both of them
03:35:50 <elliott> the latter either proves Foo or disproves RH, and you can tell which
03:35:57 <arkeet> quchen: just one of them.
03:36:03 <elliott> (note: we assume every type has either zero or one values when talking about propositions like this)
03:36:22 <quchen> Let's stay with logic, types confuse me right now :s
03:36:32 <arkeet> but types are propositions.
03:36:34 <ramses_> quchen: if you could prove both q and ~q the logic wpould be inconsistent!
03:36:45 <quchen> arkeet: No, types are CurryHoward(propositions).
03:36:47 <elliott> well, I think computability is a good way to understand this stuff, but fair enough :)
03:36:56 <arkeet> but isomorphisms are identities, up to isomorphism.
03:37:00 <elliott> by Either (RiemannHypothesis -> Void) Foo I just meant ~RH \/ Foo, intuitionistically
03:37:21 <quchen> arkeet: Just because it's true doesn't mean it's helpful as an explanation.
03:37:45 <arkeet> I think it's easier to think about intuitionistic logic on the computability side.
03:38:02 <quchen> I'm having problems with the logic part, and mapping them to something else that I don't understand adds two things: problems with the type part, and problems with the Curry-Howard part. In short: it makes things worse.
03:38:13 <elliott> fair enough
03:38:17 <ramses_> elliott: seen my question about INF above? I really don't see how that would go then
03:38:29 <quchen> It's like starting first grade with Galois Theory. It works, but hardly teaches you 2*3 very well.
03:39:11 <quchen> arkeet: That is not to say I don't appreciate your attempts to help me
03:39:22 <elliott> ramses_: well, (forall a. a) -> b isn't the same as (exists a. a -> b) in Haskell or Coq or whatever, in fact. I'm not sure what I'm missing here, actually (it's something I've wondered about before).
03:39:22 <arkeet> you don't have to think about types.
03:39:27 <elliott> ask arkeet :P
03:39:27 <quchen> arkeet: I just wanted to throw in that too much at once confuses me. :-)
03:39:28 <arkeet> you can think about constructive proofs if you want.
03:39:54 --- mode: ChanServ set +o elliott
03:39:58 --- mode: elliott set -b *!*one@*.dsl.stl2mo.sbcglobal.net
03:40:00 --- mode: elliott set -o eldariof
03:40:03 <elliott> er...
03:40:06 <ramses_> they are not the same?? Okay, I'll have to think about that..
03:40:07 --- mode: elliott set -o elliott
03:40:09 <elliott> good typo.
03:40:32 <elliott> ramses_: because you can use the argument at multiple types.
03:40:39 <elliott> e.g. (forall a. a) -> b can use its argument as an Int and a String.
03:40:48 <elliott> (exists a. a -> b) doesn't offer it that choice, it has to pick one.
03:40:56 <ivanm> OK, I'm really confused here
03:41:03 <elliott> I guess when you're working with propositions, you can always just pick (p /\ q) or something.
03:41:03 <ramses_> elliott: you mean it can unify the a with whatever it likes?
03:41:07 <elliott> sure
03:41:27 <arkeet> elliott: huh?
03:41:34 <quchen> So back to elliott's example of RH. I feel like that illustrates some important point, but I don't quite get it yet. Classically, RH \/ ~RH is always true because of exlucded middle.
03:41:35 <ivanm> I had some pure code; I then converted it into monadic form (gave my types a parameter to say which monad it operates under; for purposes of testing they're all using Identity)
03:41:43 <elliott> arkeet: don't worry. I'm at least twice as confused as you are.
03:41:48 <ivanm> the monadic code is indeed slower than the pure code... except for one function :/
03:41:51 <elliott> I'm just an amateur!!
03:42:10 <quchen> If you have RH \/ ~RH in the intuitionistic case, you're required to have a proof for either of them in order to introduce the \/?
03:42:29 <quchen> elliott: Is that what you meant with RH \/ ~RH asserts there's a proof for one of them?
03:42:44 <elliott> right
03:42:58 <quchen> Ah.
03:43:03 <quchen> Tiny problem solved! :D
03:43:07 <elliott> and it gives the idea of "evidence": to give evidence for (p \/ q) you have to either give evidence for p, or give evidence for q.
03:43:38 <elliott> classical logic doesn't care about evidence. (p \/ ~p) is considered true because propositions have truth values.
03:43:39 <ramses_> quchen: as I understand it, "truth" means "I have a proof", so to say "RH v ~RH" is true, means you have a proof for that proposition, which by definition of conjunction, means you have a proof of either RH or ~RH
03:43:59 <going_up> How come #c doesnt have learn as you go chat?
03:44:06 <arkeet> it's a disjunction. and the point is that intuitionistic logic and classical logic have different notions of "proof"
03:44:21 <ramses_> ah damn, indeed *faceplam*
03:44:22 <arkeet> how come going_up is back?
03:44:29 <quchen> So you could say in classical logic, a thing can be intrinsically "True", i.e. it *is* True. Intuitionistic, something cannot *be* True; you use "True" as a shortcut for "I could provide a proof for it"?
03:44:50 <ivanm> going_up: come again?
03:44:58 <quchen> ivanm: He's a troll, ignore him
03:45:12 <shachaf> going_up: You're acting in a pretty blatantly trolly way, after already being banned once.
03:45:17 <arkeet> quchen: well, if a thing is true in classical logic, you can provide a (classical) proof for it.
03:45:17 <going_up> ivanm: I was learning c but the channel is always dead.
03:45:27 <Saizan> quchen: that's a decent intuition for some restricted concept of "proof"
03:45:30 <arkeet> quchen: it's just that you have different rules of inference.
03:45:36 <ivanm> going_up: try ##c
03:45:40 <ivanm> but this isn't a C channel :)
03:45:56 <Saizan> quchen: as in a computational reading of the so-called BHK interpretation
03:46:08 <arkeet> I'll let Saizan take over.
03:46:09 <beaky> hello
03:46:27 <beaky> what are the challenges of implementing haskell?
03:46:32 <quchen> arkeet: Yes, I know. The thing is I know the inference rules, but I don't have the intuition (hahahaha.) yet about what makes it different from classical logic.
03:46:33 <going_up> I am not trolling but I do not chat uptight.
03:46:54 <quchen> I mean I know the different inference rules, but the "what is truth" thing isn't so obvious to me by just looking at them
03:47:10 <elliott> arkeet: I like this delegation process.
03:47:17 <ivanm> going_up: why ask here though about why ##c is quiet?
03:47:27 <ivanm> almost by definition, people here wouldn't want to be in #c
03:47:34 <elliott> you have to be careful not to say something that makes you look more qualified, or you'll get the burden.
03:47:39 <Saizan> quchen: http://en.wikipedia.org/wiki/Brouwer%E2%80%93Heyting%E2%80%93Kolmogorov_interpretation might help
03:47:43 <tdammers> ivanm: why not?
03:47:51 <going_up> Because I could just put this on festival and learn haskel but I cant do that in #c.
03:47:54 <going_up> brb
03:48:02 <going_up> going to install festival
03:48:14 <quchen> Saizan: The interpretation has a name? Neat. Reminds me of quantum mechanics.
03:48:18 <ivanm> tdammers: well, most people use Haskell because they want a better language, right? ;-)
03:48:35 <quchen> Saizan: It also means it's not trivial and others had the same problems as I do
03:48:37 <tdammers> ivanm: or because they have a general interest in programming languages
03:48:39 <Saizan> quchen: it comes out of a controversy too :)
03:48:42 <ivanm> true
03:48:55 <tdammers> also, there are scenarios where C is a better choice than Haskell
03:48:58 <beaky> Haskell is one of the neatest programming languages out there
03:49:05 <going_up> I thought haskel was better because it takes advantage of special memory hardware or was it cpu.
03:49:22 <arkeet> monoids are one of the easiest things.
03:49:24 <Saizan> quchen: between Hilbert and Brouwer in the early 1900
03:50:17 <shachaf> <kmc> summertime and the monoids are easy
03:50:20 <quchen> Saizan: What does your link mean with "0" in the interpretation of \/?
03:50:25 <quchen> (and "1")
03:50:43 <alexander__b> so what does map ($ 3) [(4+), (10*), (^2), sqrt]   really do?
03:50:52 <Saizan> quchen: just some distinguishable symbols
03:51:06 <alexander__b> I mean, I see the output, and can make sense of it sans that every other member is a 0, but IDK what's really going on.
03:51:14 <quchen> Saizan: So you could also have said "... where a is whatever and b is a proof or ..."?
03:51:19 <shachaf> alexander__b: ($ 3) is (\f -> f 3)
03:51:19 <beaky> alexander__b: it gives those functions in that list an argument of 4
03:51:24 <elliott> quchen: it means a is a boolean
03:51:36 <beaky> an argument of 3***
03:51:38 <elliott> it's C-style tagged unions :p
03:51:39 <alexander__b> scgilardi: ohh
03:51:39 <shachaf> I don't know "sans that every other member is a 0" means.
03:51:44 <alexander__b> errr shachaf ^
03:52:03 <shachaf> alexander__b: Actually it's (\f -> f $ 3)
03:52:06 <alexander__b> shachaf: I mean that I understand the output minus why every other member is a 0 in that list.
03:52:09 <Saizan> quchen: as elliott says, 'a' is a tag to tell the two cases apart
03:52:09 <shachaf> alexander__b: Just like (+ 3) is (\x -> x + 3)
03:52:14 <alexander__b> shachaf: but with your information it is more clear.
03:52:52 <arkeet> > map ($ 3) [(4+), (10*), (^2), sqrt]
03:52:53 <lambdabot>   [7.0,30.0,9.0,1.7320508075688772]
03:52:56 <quchen> Saizan: Oh, I see. The tuple notation was too suggestive for me, I somehow assiciated a with P and b with Q
03:52:57 <alexander__b> well, except, I still don't see why every other member is a 0.
03:53:02 <alexander__b> oh
03:53:02 <Saizan> quchen: so that you know of which proposition 'b' is supposed to be a proof of
03:53:09 <alexander__b> .0. rite. lol.
03:53:12 <arkeet> lol
03:53:15 <quchen> Saizan: It's more like a "<caseX, proof>" tuple
03:53:21 <quchen> Right
03:53:21 <Saizan> quchen: yeah
03:54:10 <quchen> So basically it says "P \/ Q means there is a (intuitionistic) proof for one of them"
03:54:34 <Saizan> and you can look at it and tell which
03:54:35 <quchen> Clasically, P \/ Q means "one of them is True (for whatever reason)"
03:55:10 <alexander__b> I love how most things in haskell thus far are confusing and weird for a moment. then I grok them. then I think they are genius and elegant beyond compare.
03:55:25 <quchen> It's really interesting how leaving an axiom away can lead to some expressions stating more rather than less
03:55:50 <Saizan> a classical proof of God \/ Not God can't be inspected to tell if God
03:56:15 <Saizan> yeah :)
03:56:28 <quchen> ... because there's an inference rule for "Got \/ not God"
03:56:44 <shachaf> quchen: Well, or for time travel, or something.
03:56:48 <quchen> i.e. True  |  God \/ not God"
03:56:58 <quchen> shachaf: God is a variable ;-)
03:57:12 <Saizan> quchen: and that rules doesn't include any more information
03:57:17 <Saizan> *rule
03:57:19 <shachaf> The standard classical way of proving it is to assume Not God until God gets upset and proves their existence to you.
03:57:30 <shachaf> Then you travel back in time and show everyone the proof.
03:57:47 <quchen> "Assume no god then god gets mad, therefore god"
03:57:53 <alexander__b> is it possible to print the source code of stuff? :t prints the type, but what about the src? e.g. the src for (.) or head or whatever.
03:57:54 <Saizan> that's how a constructivist would see it :)
03:58:06 <bitonic> alexander__b: not in ghci
03:58:13 <shachaf> Saizan: We're all constructivists in here, are we not?
03:58:17 <alexander__b> bitonic: kthnx
03:58:17 <elliott> shachaf: is the trick to use god to help you travel back in time?
03:58:24 <beaky> hehe
03:58:32 <Saizan> shachaf: Cale isn't!
03:58:41 <shachaf> elliott: It's much safer to invent a time machine *before* you start claiming anything about God.
03:59:11 <Saizan> just prove Time-Machine \/ Not Time-Machine
04:00:44 <quchen> So thanks to all of you for your time. I got a bit further understanding this stuff at least.
04:00:58 <mreh> so are free monads the next hip thing?
04:01:04 <quchen> Time to read the first chapters of Thompson again. (Or can you recommend some other book on the topic?)
04:01:08 <mreh> hearing a bit of a buzz about them
04:01:52 <shachaf> Maybe tomorrow I'll bug arkeet to tell me a thing about free monads.
04:01:55 <shachaf> Under threat of puns.
04:02:00 <quicksilver> I thought free monads were the last hip thing.
04:02:12 <Saizan> quchen: "classical mathematics for a constructive world" is a good read on how intuitionistic logic can be more than classical
04:02:21 <mreh> quicksilver, dang
04:02:21 <quchen> Comonads were cool a month ago
04:02:30 <mreh> lenses?
04:02:33 <mreh> are they still cool?
04:02:42 <Saizan> shachaf: oooh, which thing?
04:02:50 <edwardk> of course. we just released a new version
04:03:11 <quchen> I don't think Lens will be uncool anytime soon
04:03:14 <edwardk> now all i need to do is get the community interested in cache oblivious data structures
04:03:31 <shachaf> Saizan: I want to figure out the whole F-Alg thing way of making free monads and relate it to the category of monads/category of endofunctors way. Or something.
04:03:32 <wi> does anybody have an idea as to how i could parse an Int64 in big endian form from a bytestring with attoparsec?
04:03:42 <shachaf> I don't properly understand the former anyway.
04:03:44 <mreh> edwardk: do you have a notification set on "lens"?
04:03:50 <shachaf> @time for me to go to sleep.
04:03:51 <circle> I want to make my own library functions (like "concat"). How do I get the compiler error (ambiguous reference) to go away?
04:03:56 <edwardk> mreh: 'comonad' in this case.
04:04:00 <shachaf> Hmm.
04:04:00 <shachaf> @time
04:04:04 <lambdabot> Local time for shachaf is Thu Mar 28 04:03:49 2013
04:04:09 <edwardk> @time
04:04:10 <lambdabot> Local time for edwardk is Thursday, March 28, 2013 7:03:58 AM Eastern Daylight Time
04:04:11 <edwardk> wuss =)
04:04:22 <shachaf> @localtime elliott
04:04:23 <lambdabot> Local time for elliott is Thu Mar 28 11:04:11 2013
04:04:32 <arkeet> circle: hide them from the Prelude.
04:04:38 <quchen> elliott: British?
04:04:39 <circle> how?
04:04:44 <arkeet> circle: import Prelude hiding (concat)
04:04:48 <mreh> @time
04:04:49 <lambdabot> Local time for mreh is Thu Mar 28 11:04:37
04:04:51 <mreh> that's UK
04:04:54 <circle> eh too difficult
04:04:57 <arkeet> or, import Prelude () -- if you want to hide everything
04:05:04 <circle> I'll just tack an horribly ugly "1" on the end of them all
04:05:24 <arkeet> put them in your own module and import it qualified?
04:05:38 <arkeet> or whatever.
04:05:46 <circle> if I do import Prelude () will it mean I can't use library functions I haven't defined myself?
04:05:54 <arkeet> circle: you'd have to liste the ones you want.
04:05:55 <arkeet> list*
04:06:02 <circle> damn
04:06:10 <arkeet> circle: it's either that or hide the ones you don't want.
04:06:28 <arkeet> or use a qualified name for your own ones.
04:08:42 <quchen> Does Modus Ponens hold in intuitionistic logic?
04:08:48 <quchen> Tollens, pardon
04:08:53 <wi> dont think so
04:09:02 <quchen> a => b  ==>   not b => not a
04:09:02 <wi> you need pbc for that dont you?
04:09:04 <quchen> That one
04:09:30 <ivanm> so by adding Monad wrappers around all my typeclass methods (even though for benchmarking I'm only using Maybe), it now takes my benchmarks around 3x as long :/
04:09:58 <ocharles> ivanm: what do you mean by Monad wrapper?
04:10:07 <ocharles> adding a `Monad m` context?
04:10:11 <ivanm> yeah
04:10:16 <ocharles> Does SPECIALIZE help?
04:10:25 <arkeet> quchen: that's not modus ponens.
04:10:39 <ivanm> rather than just "Foo a", my data types are now "(Monad m) => Foo m a", and all functions are now in the specified monad
04:11:01 <ivanm> (reason being, I"m interested in adding in a variant that needs ST)
04:11:01 <ocharles> hum
04:11:08 <arkeet> quchen: modus ponens is a, a -> b |- b
04:11:26 <arkeet> er
04:11:27 <wi> he corrected himself
04:11:27 <quchen> arkeet: (a => b)  =>  (not b => not a)
04:11:30 <Ghoul__> You know, I'd be stabbing the dark, because I don't actually know haskell all that well - I'm a assembly guy
04:11:30 <arkeet> oh I should read further.
04:11:32 <quchen> That one, whatever it's called
04:11:40 <arkeet> quchen: read not b as b => _|_
04:11:47 <arkeet> quchen: and then yes, it's composition of implications.
04:12:12 <Ghoul__> But your performance degradation sounds like you may be dealing with an extra pointer that you weren't before
04:12:37 <Ghoul__> Did you compile with llvm?
04:12:50 <arkeet> (a -> b) -> (b -> Void) -> (a -> Void)
04:13:38 <ivanm> and for some reason I can't get cabal-install to build my benchmarking executable with profiling support :@
04:14:29 <ivanm> dcoutts: will "cabal configure --enable-executable-profiling --enable-benchmarks" let me have a benchmark with profiling support?
04:15:33 <Saizan> @djinn (a -> b) -> Not b -> Not a
04:15:34 <lambdabot> f a b c = b (a c)
04:15:51 <Saizan> quchen: ^^^
04:15:54 <mami> hey
04:16:03 <beaky> @djinn a -> b -> a -> b -> c -> c
04:16:03 <lambdabot> f _ _ _ _ a = a
04:16:12 <beaky> @djinn a -> b -> (a -> b -> c) -> c
04:16:12 <lambdabot> f a b c = c a b
04:16:14 <mami> is there a plugin for emacs that is good for code folding and function organization with haskell?
04:16:15 <beaky> what is the difference?
04:16:29 <arkeet> beaky: think about it.
04:16:42 * beaky thinks hard
04:16:49 <Saizan> beaky: -> is right associative
04:16:58 <beaky> ah
04:17:23 <arkeet> -> is not DWIM-associative.
04:17:31 <arkeet> sadly.
04:17:37 <beaky> :t DWIM
04:17:38 <lambdabot> Not in scope: data constructor `DWIM'
04:23:15 <byorgey> "Do What I Mean"
04:24:55 <hiptobecubic> :D
04:25:08 <alexander__b> is freenode drowning or something
04:26:55 <[1]papyrus> hi
04:27:42 <[1]papyrus> i am reading "learnyouahaskell" , chapter 7.
04:27:47 <byorgey> hi [1]papyrus
04:28:04 <Axman6> great!
04:28:45 <tlaine> gj
04:32:18 <[1]papyrus> because the Prelude module exports some functions from Data.List for convenience. You don't have to import Data.List via a qualified import because it doesn't clash with any Prelude names except for those that Prelude already steals from Data.List.
04:32:18 <[1]papyrus> Prelude steals "head" from Data.List.
04:32:18 <[1]papyrus> import Data.List
04:32:18 <[1]papyrus> test xs = head xs
04:32:18 <[1]papyrus> but, compiles ok. . does not crash.
04:32:19 <[1]papyrus> why not crash?
04:32:58 <elliott> why would it crash?
04:33:34 <beaky> how does haskell get implemented very efficiently?
04:33:48 <beaky> even if it is functional?
04:34:24 <[1]papyrus> at the book , "except for those that Prelude already steals from Data.List"
04:34:26 <nicoo> beaky: Why wouldn't it ?
04:35:02 <arkeet> [1]papyrus: Prelude simply re-exports it from Data.List; it doesn't define it
04:35:03 <[1]papyrus> it means, if it steals some function (like head) , i will crash
04:35:05 <beaky> because it needs a runtime, a gc, pointers, tagged unions, recursion
04:35:24 <[1]papyrus> ah..
04:35:30 <[1]papyrus> thanks.
04:35:44 <[1]papyrus> i understand it.
04:35:45 <[1]papyrus> but..
04:36:09 <[1]papyrus> what 's mean "except for those that Prelude already steams from Data.List" at the book.
04:36:15 <nicoo> beaky: Recursion isn't any more of a problem than loops
04:36:23 <edwardk> beaky: because the structure of the language is such that we give a lot of power to the compiler to move whole chunks of code around that no other language is quite as free about
04:36:41 <beaky> ah
04:36:43 <[1]papyrus> steams => steals
04:37:06 <nicoo> beaky: And *many* languages need GC, pointers and type tags
04:37:15 <edwardk> beaky: basically because of lack of side-effects once the compiler has determined something is needed it is free to move it to wherever it wants so long as it happens
04:37:39 <nicoo> edwardk: Yes, but even without doing lots of smart stuff, compiling functional programs isn't so bad ^^
04:37:44 <edwardk> thats a lot more wiggle room than when you care about when things happen, not just what happens
04:38:01 <edwardk> nicoo: sure. we have a compiler that does the dumbest thing possible and its pretty amazing
04:40:17 <beaky> I wouldn't think of using immutable data in a  language like C++ because it does a lot of copying when making changes and stuff
04:41:21 <mgsloan> immutable data actually works out pretty well with c++, since it has const references
04:41:34 <Axman6> > (++) <$> Just [1,2,3] <*> Nothing
04:41:34 <beaky> ah
04:41:36 <lambdabot>   Nothing
04:41:50 <mgsloan> I mean, there is still the issue of copying when changing
04:42:21 <mgsloan> So if you need to change your immutable vectors a lot, or something, yeah, you're better off using something else
04:42:25 <beaky> yep; maybe you can get smarter with purely-functional data with C++11's smart pointers/std::shared_ptr
04:42:32 <merijn> mgsloan: Yeah, but having to const every single thing is pretty annoying
04:42:56 <mgsloan> merijn: Agreed!  I didn't say that good C++ code was pretty ;)
04:43:13 <nicoo> beaky: Immutability also means you share lots of data between different data-structures, which is actually pretty good for memory usage & cache pressure
04:43:16 <mgsloan> (due to having all the wrong defaults)
04:44:52 <arkeet> and if you know a value isn't needed again, you can safely update it in-place too.
04:47:37 <edwardk> of course the problem with const in c++ is that it only provides the contract that you can't change it, not that someone can't change what you are looking at
04:48:08 <MySciThaMan> hello
04:48:15 <beaky> MySciThaMan: hi :D
04:48:23 <beaky> MySciThaMan: what's up? ^^
04:48:23 <edwardk> so any use of const to try to reduce reads, etc. is still hazardous =)
04:48:30 <MySciThaMan> looking into haskel
04:48:34 <MySciThaMan> ive never heard of it
04:49:01 <MySciThaMan> interesting
04:49:06 <beaky> Haskell is just another programming language
04:49:13 <MySciThaMan> what's the coolest ting some people here have done with haskell?
04:49:41 <mauke> lenses are pretty cool
04:49:42 <arkeet> if I say lens I'd be shot.
04:49:43 <arkeet> haha
04:49:56 * mauke eats, shoots and leaves
04:51:08 <Taneb> With constraint kinds, can you make a class class?
04:51:26 <alexander__b> &/b 2
04:51:30 <alexander__b> ups
04:51:42 <elliott> Taneb: yes
04:51:43 <byorgey> Taneb: yes, I think so
04:51:48 <beaky> MySciThaMan: I am still learning haskell, but I have implemented a turing machine (sans infinite tape :D) similar to this one: http://en.wikipedia.org/wiki/Turing_machine#Formal_definition
04:51:56 <arkeet> Taneb: have you seen the constraints package?
04:52:04 <Taneb> class Mappy (c :: Constraint) where map :: c f => (a -> b) -> f a -> f b; instance Mappy Functor where map = fmap; instamce Mappy Monad where map = liftM
04:52:09 <arkeet> I have no idea if that's what you're looking for.
04:52:11 <Taneb> arkeet: not while understanding it
04:52:33 <typoclass> MySciThaMan: the cool thing about haskell is, it's hard to get something to compile, but once it does, it usually doesn't have many bugs anymore. compare this with dynamic languages, where you spend much more time on debugging
04:53:30 <mgsloan> edwardk: Good point!  I hadn't realized that const doesn't help the compiler much (or at all).  It'd be interesting if there was a way to declare global immutability (has issues with object construction time though) - I think D has something along these lines
04:53:32 <elliott> Taneb: that will be awkward to use in practice
04:53:44 <arkeet> ambiguous variable errors everywhere.
04:53:45 <elliott> because it'll need to know which "c" to use
04:53:47 <Taneb> elliott: I'm in a messing with stuff mood
04:53:54 <elliott> just warning :P
04:53:55 <byorgey> Taneb: yes, you can do that, note it should be  (c :: (* -> *) -> Constraint)
04:54:03 <Taneb> Right
04:54:07 <arkeet> it's pretty handy to have a constraint as an associated type for another class.
04:54:19 <MySciThaMan> thanks typoclass and beaky
04:54:28 <aCube> is there a monad that is like Writer, but also allows to access to current "state"?
04:54:36 <MySciThaMan> beaky: what do you use your turing machine for?
04:54:41 <arkeet> aCube: sounds like you want State.
04:54:57 <ivanm> or a Writer/State stack
04:55:03 <typoclass> MySciThaMan: anyway, xmonad is pretty cool :-) it's a very good window manager written in haskell, and the language you use to write its configuration file is also haskell
04:55:09 <typoclass> @where xmonad
04:55:09 <lambdabot> http://xmonad.org/
04:55:18 <aCube> arkeet: Yeah, but then I could also use put to overwrite the current state. I want a state. but with put using (<>) to append something to the state
04:55:31 <arkeet> I used xmonad for a while, but decided I didn't like it.
04:55:39 <MySciThaMan> thankt typoclass
04:55:58 <typoclass> arkeet: what's your point?
04:56:04 <beaky> MySciThaMan: I just used it as a learning exercise for learning haskell, and as a brief introduction to computation theory :D
04:56:06 <arkeet> I guess I don't have one.
04:56:10 <arkeet> never mind then.
04:56:15 <beaky> other than that... yes a turing machine is pretty useless :(
04:56:25 <aCube> Ok, so I could just use State, and use tellS x = modify (<> x)
04:56:39 * typoclass purrs and walks around arkeet's legs
04:56:45 <arkeet> D:
04:56:55 <beaky> besides that, people have written useful programs using haskell: lambdabot is a useful haskell program
04:57:06 <arkeet> ghc is a pretty useful program.
04:57:19 <MySciThaMan> i love it when youtube videos dont have any audio. :/ <sarcsm https://www.youtube.com/watch?v=8jULGE0rq8M
04:59:50 <beaky> the world could use more of haskell
04:59:59 <aCube> Is there anything that I can do with a Env comonad that I can't do with a reader monad (or the other way) ?
05:02:13 <MySciThaMan> what is a manage hook?
05:03:01 <Iceland_jack> Can anyone link me to resources for writing GHC extensions?
05:06:17 <MySciThaMan> http://stackoverflow.com/questions/2998458/list-of-ghc-extensions Iceland_jack
05:06:28 <edwardk> aCube: you can always contort the code to serve either. in practice it is a lot easier to work with a lot of little environment comonads when you have a lot of bits of discardable metadata about a bunch of things
05:06:59 <MySciThaMan> hehe hoogleable
05:07:07 <Taneb> Am I allowed to do a GADT newtype?
05:07:15 <arkeet> try it!
05:07:16 <Iceland_jack> MySciThaMan: My question was about writing my own extension
05:07:17 <edwardk> MySciThaMan: i think thats a bit different than he meant
05:07:25 <MySciThaMan> oh ok
05:07:31 <MySciThaMan> just trying to help
05:07:42 <Iceland_jack> No harm taken MySciThaMan
05:07:45 <edwardk> Iceland_jack: there is some stuff in the code commentary iirc
05:07:51 <arkeet> GADT syntax seems to work for newtypes.
05:07:58 <Iceland_jack> Code commentary?
05:08:08 <typoclass> MySciThaMan: it's used when xmonad first sees a new window. you can use it for things like "whenever a video window shows up, make it full-screen" or "whenever a window of my instant messenger appears, put it on workspace #4"
05:08:09 <edwardk> http://www.cs.berkeley.edu/~megacz/garrows/ might be a good place to look too
05:08:17 <edwardk> since that is done as a custom ghc extension
05:08:27 <MySciThaMan> have you checked the guide Iceland_jack  https://www.fpcomplete.com/user/PthariensFlame/guide-to-ghc-extensions
05:08:32 <MySciThaMan> :)
05:08:38 <Taneb> arkeet: thanks
05:08:47 <arkeet> MySciThaMan: that's still about using GHC extensions, not creating new ones.
05:08:50 <Taneb> Darn, I want both GADTs and record syntax at the same time :(
05:08:54 <Iceland_jack> I have incidentally, but it doesn't seem to be what I want MySciThaMan
05:09:03 <Iceland_jack> It's possible that my question wasn't clear
05:09:05 <MySciThaMan> darnet, it douesnt help develop?
05:09:16 <Taneb> No I don't, I just want an extraction function
05:09:30 <arkeet> Taneb: just use regular ADT syntax?
05:09:42 <Taneb> arkeet: I need the G
05:09:53 <Iceland_jack> I will have a look at this edwardk, thanks: what did you mean by “code commentary” btw?
05:09:54 <arkeet> for a newtype?
05:10:03 <edwardk> MySciThaMan: there are two completely unrelated notions here. a GHC language pragma is what 99% of the users out there want, {-# LANGUAGE Foo #-} is that. What Iceland_jack wants to do is a much more involved thing.
05:10:16 <edwardk> Iceland_jackhttp://hackage.haskell.org/trac/ghc/wiki/Commentary
05:10:56 <Iceland_jack> Thank you
05:11:31 <edwardk> MySciThaMan: technically they aren't that unrelated since the extension that Iceland_jack would probably write will wind up exposed through that sort of flag, but turning on an extension and writing one are as different as flipping a switch in a GUI and going and writing a GUI.
05:12:09 <quchen> Can I not use "newtype" in a class definition with TypeFamilies?
05:12:17 <quchen> data works, but newtype gives me an error
05:12:24 <arkeet> no, but you can in an instance definition I think
05:12:26 <Iceland_jack> I can at least say that I'm familiar with enabling extensions :)
05:12:32 <MySciThaMan> thanks.  now it is crystal clear  lol
05:12:54 <edwardk> quchen: you use newtype for each instance, not for the definition in the class
05:12:54 <quchen> arkeet: So use data in the class, and newtype in the instance?
05:13:13 <edwardk> quchen: even if you instantiate it with all newtypes its still a data family.
05:13:19 <edwardk> quchen: yep
05:13:20 <arkeet> quchen: right
05:13:32 <quchen> Yes, that works, thanks. Looks odd though
05:14:35 <ivanm> my .cabal file specifies an executable
05:14:47 <ivanm> I do "cabal configure --enable-executable-profiling && cabal build"
05:14:50 <ivanm> everything is fine
05:14:56 <MySciThaMan> this may not be exactly what you are looking for, but i think i'm getting closer to finding it. Iceland_jack   http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/rewrite-rules.html
05:15:08 <ivanm> but when I try to run it with +RTS -p, it says that "the flag -p requires the program to be built with -prof" :s
05:15:12 <ivanm> wtf is going on?
05:15:24 <arkeet> ivanm: run it from the dist directory?
05:15:30 <ivanm> arkeet: that's what I'm doing
05:15:34 <arkeet> ok
05:15:41 * arkeet was just making sure you didn't cabal install
05:16:23 <ivanm> nope
05:16:26 <arkeet> :p
05:16:39 <ivanm> OK, even doing it with runhaskell Setup.hs doesn't work, so I can't blame cabal-install for it...
05:17:02 * ivanm wonders if it's an issue with Cabal...
05:17:15 <Iceland_jack> MySciThaMan: It doesn't appear so, I'm looking for references for /writing/ my own extension for GHC and not general documentation on extensions just so it's clear
05:17:53 <arkeet> ivanm: you have profiled versions of the dependencies installed right?
05:18:48 <ivanm> yes
05:19:15 <MySciThaMan> i found a building and porting GHC link for builders and hackers, it probably has soem info you are looking for, i havent been able to find anything writer specific, i think maybe it isn't made that way.  but i dont know anything so i wish you luck, let me know if you find it, this is hooking me in,, lol
05:19:38 <Iceland_jack> heh, will do MySciThaMan
05:19:48 <arkeet> ivanm: and if you use -v?
05:20:03 <ivanm> when building? hmmm
05:20:44 <arkeet> I have no idea, I'm just giving random suggestions.
05:21:24 <henk> Does anyone know if "Yann Esposito" is around in this channel?
05:22:26 <Iceland_jack> edwardk: Is it possible that you'll have to patch the compiler itself?
05:22:42 <alexander__b> in this example: head (dropWhile (\(val,y,m,d) -> val < 1000) stock) -- will haskell internally do dropWhile (<1000) on all the elements, or will it just stop at the first because of head?
05:22:47 <arkeet> Iceland_jack: yes, you'd need to modify ghc.
05:23:03 <ivanm> I think it's an issue with Cabal-1.16.0
05:23:10 <Iceland_jack> Shoot, that's too bad
05:23:20 <alexander__b> I know the output will of course be just the head of the list -- but is the list from dropWhile fully generated, or is ghc clever enough to just find the first element and leave it at that?
05:23:25 <arkeet> alexander__b: dropWhile would evaluate far enough to produce a single element of the list.
05:23:28 <ivanm> alexander__b: laziness means it will only produce one value
05:23:34 <arkeet> that's laziness.
05:23:37 <alexander__b> ivanm: that was what I thought/hoped.
05:23:44 <elliott> it's not really cleverness. you don't need to rely on any unreliable compiler optimisation
05:23:44 <arkeet> or rather
05:23:54 <arkeet> evaluating head evaluates the list far enough to see whether it has an element or not.
05:23:55 <elliott> this kind of reasoning is baked into the language's semantics
05:24:04 <elliott> (modulo speculative evaluation etc.)
05:24:15 <alexander__b> neat.
05:24:42 <ion> > (head . dropWhile (< 1000)) [0..]
05:24:43 <lambdabot>   1000
05:25:06 <arkeet> > let expensive = 1 + expensive in head (dropWhile (< 1000) [3, 1000, expensive])
05:25:07 <lambdabot>   1000
05:25:13 <ion> > head . dropWhile (< 1000) $ [0..1000] ++ [error "foo"]
05:25:15 <lambdabot>   1000
05:25:45 <Taneb> Bah, I have no way of testing this code
05:26:50 <arkeet> preflex: seen yogsototh
05:26:50 <preflex>  yogsototh was last seen on #haskell 22 days, 23 hours, 35 minutes and 37 seconds ago, saying: Taneb: thanks!
05:26:52 <arkeet> henk: ^
05:27:15 <ivanm> Taneb: sure you do... run it! :p
05:27:31 <Taneb> ivanm: you're making a lot of assumptions of what I have access to on this computer
05:28:14 <ivanm> heh, fair enough
05:30:13 <Taneb> http://hpaste.org/84754
05:30:37 <Taneb> And I've got title and author backwards again
05:32:09 <henk> arkeet: ok, thanks :)
05:32:45 <adimit> :t \op f g a b = f a b `op` g a b -- is there a shorter/more idiomatic way of expressing this combinator?
05:32:47 <lambdabot> parse error on input `='
05:32:59 <arkeet> Taneb: that's the kind of thing. but you probably want
05:33:00 <adimit> :t \op f g a b -> f a b `op` g a b -- me stupid
05:33:01 <lambdabot> (t1 -> t2 -> t) -> (t3 -> t4 -> t1) -> (t3 -> t4 -> t2) -> t3 -> t4 -> t
05:33:03 <arkeet> type KeyRestriction m k :: Constraint
05:33:38 <ivanm> @pl \ op f g a b -> op (f a b) (g a b)
05:33:38 <lambdabot> (liftM2 ap .) . (.) . (.)
05:33:48 * hackagebot split 0.2.1.3 - Combinator library for splitting lists.  http://hackage.haskell.org/package/split-0.2.1.3 (BrentYorgey)
05:33:57 <ivanm> arkeet: it looks vaguely like liftM2 for the function monad...
05:34:03 <adimit> that's very… readable. Thanks ivanm
05:34:07 <arkeet> it looks vaguely like ap as well.
05:34:09 <arkeet> I'd call it ap2.
05:34:13 <ivanm> you could possibly use op <$> f <*> g
05:34:20 <arkeet> er
05:34:21 <arkeet> oh wait.
05:34:27 <arkeet> I was apparently blind to op
05:34:33 <ivanm> @type \ op f g -> op <$> f <*> g
05:34:41 <arkeet> ap = liftM2 id
05:34:43 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
05:34:46 <arkeet> :t liftM2 id
05:34:48 <lambdabot> Monad m => m (a2 -> r) -> m a2 -> m r
05:35:02 <adimit> I had tried some lifting (using liftA2) but didn't get anywhere.
05:35:21 <adimit> didn't occur to me to use id as a function. Though I don't know if that does what I want.
05:35:43 <arkeet> honestly I'd just use the pointful version you wrote.
05:35:43 <ivanm> @type \ op f g -> (op .) <$> f <*> g
05:35:45 <lambdabot> Applicative f => (b1 -> b) -> f (a -> b1) -> f a -> f b
05:35:59 <ivanm> yeah, that's not right
05:36:03 <liyang> @pl \ op f g -> op <$> f <*> g
05:36:03 <lambdabot> (. (<*>)) . (.) . (<$>)
05:36:18 <liyang> (really…?)
05:36:19 <ivanm> liyang: that's actually liftA2/liftM2
05:36:20 <adimit> yeah, the pl version is *really* cryptic. I don't think I'd like that in my code. Nobody can understand it.
05:36:30 <liyang> ivanm: I know… I was hoping @pl knew that.
05:36:37 <ivanm> adimit: @pl usually isn't more readable :p
05:36:39 <Taneb> I could use Tagged Int instead of IM...
05:36:48 <ivanm> arkeet: if it's something that you use a lot, define the combinator
05:37:00 <alexander__b> dropWhile (==' ') $ sort "This is a long sentence with many words, and thus many different characters." -- how do I pass more things to dropWhile, e.g. '.' and ','?
05:37:15 <ivanm> alexander__b: use a smarter predicate function
05:37:22 <adimit> ivanm: well, I was not explicitly hoping for a pl version (except where that might be super-easy) but more for something using Applicative or so. :-\
05:37:28 <liyang> alexander__b: dropWhile (`elem` " .,")
05:37:45 <ivanm> > let p c = c `elem` [' ', '.', ','] in dropWhile p  $ sort "This is a long sentence with many words, and thus many different characters."
05:37:46 <lambdabot>   "Taaaaaacccdddeeeeeeffghhhhiiiilmmnnnnnnnoorrrrsssssstttttuwwyy"
05:37:48 <alexander__b> liyang: ohh you can pass several things to elem like that?
05:37:57 <elliott> :t elem
05:38:03 <lambdabot> Eq a => a -> [a] -> Bool
05:38:04 <elliott> it takes a list. " .," is a list
05:38:10 <ivanm> alexander__b: even if you couldn't, you just use ||, etc. ...
05:38:16 <liyang> alexander__b: I'm using the fact that " ,." :: [Char] :: String
05:38:19 <alexander__b> ivanm: right
05:38:37 <aCube> :t op
05:38:38 <lambdabot>     Ambiguous occurrence `op'
05:38:39 <lambdabot>     It could refer to either `Debug.SimpleReflect.op',
05:38:39 <lambdabot>                              imported from `Debug.SimpleReflect' at State/L.hs:76:1-39
05:38:42 <adimit> ivanm: and your bit with <$> and <*> did the trick. :-)
05:38:54 <ivanm> adimit: it did? :o
05:39:02 <ivanm> I didn't think it would work tbh
05:39:03 <dmwit> aCube: It was an argument to the lambda. =)
05:39:07 <adimit> I think so. lemme check if it's exactly what I want.
05:39:11 <ivanm> especially since that's actually just liftA2 == liftM2
05:39:33 <adimit> ah, right, it won't work because my g and f have more args.
05:39:37 <ivanm> @type (+) <$> (+) <*> (+)
05:39:38 <lambdabot> Num a => a -> a -> a
05:39:42 <ivanm> :o
05:39:46 <adimit> Num? lol.
05:39:47 <ivanm> it does work!
05:39:53 <adimit> yeah.
05:39:55 <adimit> right!
05:39:55 <ivanm> > ( (+) <$> (+) <*> (+) ) 3 4
05:39:57 <lambdabot>   14
05:40:02 <arkeet> > ((+) <$> (+) <*> (+)) x y
05:40:04 <lambdabot>   x + y + (x + y)
05:40:10 <ivanm> > ( subtract <$> (+) <*> (*) ) 3 4
05:40:12 <lambdabot>   5
05:40:26 <aCube> :t \op f g a -> op <$> f a <*> g a
05:40:27 <lambdabot> Applicative f => (a1 -> a -> b) -> (t -> f a1) -> (t -> f a) -> t -> f b
05:40:36 <arkeet> > ((+) <$> (*) <*> (-)) x y
05:40:37 <lambdabot>   x * y + (x - y)
05:41:16 <arkeet> > (f <$> g <*> h) x y :: Expr
05:41:18 <lambdabot>   Ambiguous type variable `a0' in the constraints:
05:41:18 <lambdabot>    (GHC.Show.Show a0)
05:41:19 <lambdabot>     ...
05:41:21 <arkeet> :(
05:41:32 <aCube> wow, applicative works for multiple parameter functions as you'd expect it? nice :)
05:41:39 <adimit> didn't know that!
05:42:01 <arkeet> :t (+) <$> (+)
05:42:02 <lambdabot> Num a => a -> (a -> a) -> a -> a
05:42:11 <arkeet> :t ((+) <$> (+)) <*> (+)
05:42:12 <lambdabot> Num a => a -> a -> a
05:42:46 <fizbin> :t ((+) <$> (*) <*> (-)) x y
05:42:47 <lambdabot> fd:9: commitBuffer: invalid argument (invalid character)
05:43:10 <fizbin> :t ((+) <$> (*) <*> (-)) x y
05:43:11 <lambdabot> Expr
05:43:36 <fizbin> :t x
05:43:37 <lambdabot> Expr
05:43:42 <latermuse> @unpl ((+) <$> (+)) <*> (+)
05:43:43 <lambdabot> (((+) <$> (+)) <*> (+))
05:43:44 <arkeet> (f <$> g <*> h) x y = f (g x) (h x) y
05:43:45 <arkeet> so...
05:44:04 <arkeet> @unpl ((+) . (+)) `ap` (+)
05:44:04 <lambdabot> ((\ c -> (+) ((+) c)) >>= \ e -> (+) >>= \ d -> return (e d))
05:44:10 <arkeet> :(
05:44:32 <arkeet> :t id + (+2)
05:44:33 <lambdabot> Num a => a -> a
05:44:37 <arkeet> ah, NumInstances.
05:44:51 <arkeet> that's why it "works"
05:44:55 <arkeet> could have just done
05:44:58 <arkeet> > (+) (+) (+) x y
05:44:59 <lambdabot>   x + y + (x + y)
05:46:39 <alexander__b> ivanm: sorry after looking over that a bit, I don't understand what/how c is.
05:47:14 <adimit> ah, #haskell. Where a funny little question can trigger so much interesting stuff :-)
05:47:35 <ivanm> alexander__b: I defined a new function...
05:47:51 <ivanm> @type let p c = c `elem` [' ', '.', ','] in p
05:47:52 <lambdabot> Char -> Bool
05:47:57 <alexander__b> oh right so c becomes the parameter of course
05:48:25 <alexander__b> still having a hard time reading that stuff, as I'm used to function (parameters) or similar.
05:49:01 <alexander__b> to me it kind of looks more like e.g. int foo, bar; than int foo (int bar), to take an example.
05:51:03 <fizbin> ivanm: You know that you can write your array of characters as " .," (that is, as a string), yes?
05:51:21 <aCube> @ty liftA2 . liftA2
05:51:22 <lambdabot> (Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
05:51:26 <ivanm> fizbin: my list of characters? yes
05:51:37 <ivanm> but I prefer emphasising that I'm looking at a list of Char values, rather than a String
05:52:09 <aCube> IanKelling: I think that's your function
05:52:16 <aCube> ivanm: : I think that's your function
05:52:32 <aCube> @ty liftA2 . liftA2 :: (t1 -> t2 -> t) -> (t3 -> t4 -> t1) -> (t3 -> t4 -> t2) -> t3 -> t4 -> t
05:52:33 <lambdabot> (t1 -> t2 -> t) -> (t3 -> t4 -> t1) -> (t3 -> t4 -> t2) -> t3 -> t4 -> t
05:52:41 <ivanm> aCube: oh, the one I was trying to help adimit with?
05:52:48 <ivanm> just liftA2 on its own would work I think
05:52:53 <aCube> really?
05:52:56 <ivanm> > liftA2 (+) (*) (-) x y
05:52:58 <lambdabot>   x * y + (x - y)
05:53:00 <aCube> @ty liftA2  :: (t1 -> t2 -> t) -> (t3 -> t4 -> t1) -> (t3 -> t4 -> t2) -> t3 -> t4 -> t
05:53:02 <lambdabot>     Couldn't match type `t1' with `t4 -> t1'
05:53:02 <lambdabot>       `t1' is a rigid type variable bound by
05:53:02 <lambdabot>            an expression type signature:
05:53:12 <ivanm> function monad where the value is the function monad! :p
05:53:23 <aCube> :D
05:53:29 <ivanm> aCube: your types are wrong; the second two should have the same type
05:53:46 <adimit> thanks :-D this is all pretty interesting.
05:53:49 <aCube> His type was
05:53:50 <ivanm> @type liftA2 :: (c -> c -> d) -> (a -> b -> c) -> (a -> b -> c) -> a -> b -> d
05:53:50 <aCube> @type \op f g a b -> f a b `op` g a b
05:53:51 <lambdabot>     Couldn't match type `c' with `b -> c'
05:53:51 <lambdabot>       `c' is a rigid type variable bound by
05:53:51 <lambdabot>           an expression type signature:
05:53:52 <lambdabot> (t1 -> t2 -> t) -> (t3 -> t4 -> t1) -> (t3 -> t4 -> t2) -> t3 -> t4 -> t
05:53:59 <aCube> My type is
05:54:01 <ivanm> :o
05:54:11 <aCube> @ty liftA2 . liftA2 :: (t1 -> t2 -> t) -> (t3 -> t4 -> t1) -> (t3 -> t4 -> t2) -> t3 -> t4 -> t -- ?
05:54:13 <lambdabot> (t1 -> t2 -> t) -> (t3 -> t4 -> t1) -> (t3 -> t4 -> t2) -> t3 -> t4 -> t
05:54:23 <aCube> works :D
05:54:25 <ivanm> oh, right
05:54:37 <ivanm> @type liftA2 :: (c -> d -> e) -> (a -> b -> c) -> (a -> b -> d) -> a -> b -> e
05:54:38 <lambdabot>     Couldn't match type `c' with `b -> c'
05:54:38 <lambdabot>       `c' is a rigid type variable bound by
05:54:38 <lambdabot>           an expression type signature:
05:54:50 <ivanm> OK, I'm confused by why that won't work...
05:55:06 <aCube> ivanm: lambdabot has Num instances for the (->) e monad i think
05:56:10 <arkeet> aCube: not monad! =(
05:56:21 <arkeet> that even has the wrong kind.
05:56:32 <ivanm> ahhh
05:56:34 <aCube> O right. How is the instance then?
05:56:40 <ivanm> damn Caleskell...
05:56:42 <arkeet> Num b => Num (a -> b)
05:56:48 <ivanm> or were we up to edwardkskell?
05:57:30 <arkeet> no monads, or higher-kinded things...
05:58:05 <fizbin> Still, a Num instance for a -> b where b is Num is just...
05:58:06 <arkeet> but sure, if one wanted to one could define Applicative f, Num a => Num (f a)
05:58:14 <elliott> it does not have such instances
05:58:18 <elliott> :t 3 + id
05:58:19 <lambdabot> Num a => a -> a
05:58:22 <elliott> what.
05:58:25 <arkeet> haha
05:58:25 <elliott> ok it does
05:58:25 <aCube> haha
05:58:34 <elliott> I thought those got removed along with the tuple instances!
05:58:38 <elliott> sigh.
05:58:40 <arkeet> > 1 + (2,3)
05:58:42 <aCube> Tuple instances?
05:58:42 <lambdabot>   (3,4)
05:58:46 <aCube> :o nice
05:58:49 <elliott> all I want for christmas is a boring lambdabot.
05:58:54 <arkeet> make one!
05:59:00 <arkeet> you've got 9 months still.
05:59:07 <fizbin> So it apparently has the full NumInstances package.
05:59:08 <adimit> > 1 + [1,2,3]
05:59:10 <lambdabot>   No instance for (GHC.Num.Num [t0])
05:59:10 <lambdabot>    arising from a use of `e_11123'
05:59:10 <lambdabot>  Poss...
05:59:16 <sipa> > (5 + (+3)) 2
05:59:18 <lambdabot>   10
05:59:18 <ivanm> @remember elliott all I want for christmas is a boring lambdabot.
05:59:19 <lambdabot> Nice!
05:59:58 <arkeet> > 2 "hello" (>>=) False
05:59:59 <lambdabot>   Ambiguous type variable `m0' in the constraint:
05:59:59 <lambdabot>    (GHC.Base.Monad m0) aris...
06:00:06 <arkeet> oh of all things.
06:00:10 <fizbin> :t sinh (+3.0)
06:00:11 <lambdabot> Floating a => a -> a
06:00:13 <arkeet> > 2 "hello" sin False
06:00:15 <lambdabot>   2
06:00:31 <aCube> > 2 id
06:00:32 <lambdabot>   2
06:00:41 <aCube> that's funny
06:00:42 <mauke> it's as easy as ...
06:00:42 <mauke> > 1 2 3
06:00:44 <lambdabot>   1
06:00:44 <aCube> > 2 3 4
06:00:46 <lambdabot>   2
06:00:51 <fizbin> Wat.
06:01:10 <quchen> "Num" 1 = const 1?
06:01:20 <arkeet> fromInteger = const . fromInteger
06:01:24 <quchen> yeah
06:01:24 <alexander__b> in this example, the book uses '@'. what's '@'? it hasn't mentioned it before. map (\l@(x:xs) -> (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
06:01:27 <sipa> > ((+3) * (*2)) 4
06:01:28 <lambdabot>   56
06:01:34 <aCube> quchen: 1 is of type :: Num a =>a
06:01:52 <aCube> so if we have an instance (Num a) => Num (b -> a), it chooses this instance
06:01:57 <quchen> alexander__b: l@(x:xs) binds x to the head of the list, xs to the rest of it, and l to the entire list.
06:02:00 <arkeet> alexander__b: it binds both l and (x:xs) to the argument.
06:02:05 <quchen> alexander__b: So l = (x:xs)
06:02:14 <adimit> I'm not sure *why* liftA2 . liftA2 does what I want, but it does do what I want. Weird.
06:02:16 <ivanm> alexander__b: it's called an @-pattern
06:02:21 <aCube> > 2 3 4 5 6 7 7 8 9
06:02:23 <lambdabot>   2
06:02:29 <elliott> alexander__b: most generally, x@p binds the value to x, and also deconstructs it with pattern p.
06:02:35 <ivanm> basically, `l' refers to the entire list, `x' refers to the head of the list and `xs' refers to the tail
06:02:36 <fizbin> > (+) 2 3 4 5 6 7
06:02:38 <lambdabot>   5
06:02:45 <arkeet> it's called an as-pattern.
06:02:45 <ivanm> l == x : xs
06:02:54 <arkeet> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
06:03:02 <fizbin> :t liftA2 . liftA2
06:03:04 <lambdabot> (Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
06:03:35 <arkeet> > sin sin sin 1
06:03:37 <lambdabot>   0.6784304773607402
06:03:44 <adimit> I guess I need two nested Applicatives, since I'm using two-argument functions.
06:03:48 * hackagebot monoid-extras 0.2.2.3 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.2.2.3 (BrentYorgey)
06:03:58 <adimit> and "normal" applicative won't do what I want.
06:04:03 <aCube> yes
06:04:16 <quchen> :t sin sin
06:04:17 <lambdabot> Floating a => a -> a
06:04:24 <fizbin> adimit: What is it you wanted to do?
06:04:25 * aCube wants do notation for monoids
06:04:42 <fizbin> :t iterate
06:04:43 <lambdabot> (a -> a) -> a -> [a]
06:04:48 <adimit> fizbin: \op f g = f a b `op` g a b
06:05:04 <adimit> :t ((<$>) . (<$>))
06:05:05 <quchen> adimit: that's `on`
06:05:05 <fizbin> > iterate sin 1.0
06:05:05 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
06:05:07 <lambdabot>   [1.0,0.8414709848078965,0.7456241416655579,0.6784304773607402,0.62757183204...
06:05:17 <aCube> @ty on
06:05:19 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
06:05:25 <quchen> Oh wait no it's not, nevermind
06:05:36 <adimit> quchen: it's barely not :)
06:05:45 <adimit> it goes in the right direction, but I need it more general.
06:05:48 <dmwit> :t liftM2 . liftM2
06:05:50 <lambdabot> (Monad m1, Monad m) => (a1 -> a2 -> r) -> m (m1 a1) -> m (m1 a2) -> m (m1 r)
06:05:56 <latro`a> > iterate cos 1.0
06:05:57 <lambdabot>   [1.0,0.5403023058681398,0.8575532158463934,0.6542897904977791,0.79348035874...
06:05:58 <dmwit> adimit: there you go =)
06:06:09 <fizbin> > cos cos cos 1
06:06:11 <lambdabot>   0.6542897904977791
06:06:13 <adimit> dmwit: same thing as liftA2 . liftA2 :-D
06:06:24 <dmwit> Yep, did I miss that that was already suggested?
06:06:25 <dmwit> sorry
06:06:43 <adimit> yeah, aCube kindly suggested it above. It's been going on for a while :-)
06:07:40 <fizbin> :t let f :: a-> b, g :: a -> b in f `liftA2` g
06:07:41 <lambdabot> parse error on input `,'
06:07:57 <fizbin> :t let f :: a-> b; g :: a -> b in f `liftA2` g
06:07:58 <lambdabot>     The type signature for `f' lacks an accompanying binding
06:07:58 <lambdabot>       (The type signature must be given where `f' is declared)
06:07:58 <lambdabot>     The type signature for `g' lacks an accompanying binding
06:08:20 <dmwit> It's a type error anyway. The first argument to liftA2 has to be a function of at least two arguments.
06:08:25 <quchen> > let f = undefined :: a-> b; g = undefined :: a -> b in f `liftA2` g
06:08:27 <lambdabot>   *Exception: show: No overloading for function
06:08:59 <dmwit> Oh, but b can specialize.
06:08:59 <quchen> liftA2 as infix is quite evil
06:09:00 <dmwit> whoops
06:09:23 <dmwit> `liftA2 f` wouldn't be evil, if it worked ;-)
06:09:29 <dmwit> `(liftA2 f)`
06:09:40 <elliott> «liftA2 f»
06:09:46 <adimit> alas, it doesn't… I've wanted something like that a couple of times already.
06:09:48 <fizbin> :t let f=undefined :: a-> b -> c, g=undefined :: a -> b -> c in (liftA2) f g
06:09:51 <lambdabot> parse error on input `,'
06:10:03 <fizbin> :t let f=undefined :: a-> b -> c; g=undefined :: a -> b -> c in (liftA2) f g
06:10:05 <lambdabot> (a -> b) -> a -> c
06:10:11 <adimit> though, for very weird values of "want." It's not even pretty. Just fancy.
06:10:19 <dmwit> elliott: That's not bad. Does it clash with the current syntax? (Can that kind of quote be part of an infix identifier or something crazy like that?)
06:10:31 <elliott> adimit: you can define two operators s.t. (a op1 liftA2 f op2 b) = liftA2 f a b
06:10:42 <elliott> but the choice of op1,op2 isn't very nice, best you can do is <| |> or something
06:11:03 <elliott> dmwit: I provide no answers, only mysteries
06:11:19 <elliott> but obviously the unnestability of backquotes is the #1 worst thing about haskell syntax ever.
06:11:26 <dmwit> > let a « b = a + b in 3 « 4
06:11:26 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
06:11:52 <elliott> lambdabot hasn't even heard of foreign languages.
06:11:59 <dmwit> Seems it's a lexical error.
06:12:02 <fizbin> mueval is pretty conservative about allowed characters.
06:12:05 <adimit> > let y = 2
06:12:07 <lambdabot>   not an expression: `let y = 2'
06:12:15 <adimit> > let y = 2 in y
06:12:16 <dmwit> ghci isn't as conservative, and it still doesn't work there
06:12:18 <lambdabot>   2
06:12:26 <adimit> it does Cyrillic just fine.
06:13:15 <adimit> it just doesn't like non-alphanumerical symbols. I wonder where it says which range of Unicode it accepts.
06:13:53 <mauke> > generalCategory '\xab'
06:13:54 <fizbin> I wonder if it would be possible to abuse the macro-like features Template Haskell brings to the table to allow something like that.
06:13:55 <lambdabot>   InitialQuote
06:14:15 <alexander__b> quchen: neat. thanks.
06:15:17 <alexander__b> quchen: so it would be the same as doing  map (\(x:xs) -> (x,length xs + 1)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
06:16:34 <int-e_> @type head &&& length
06:16:35 <lambdabot> [c] -> (c, Int)
06:17:38 * fizbin finds himself needing tuple equivalents of map. He wonders where he went wrong...
06:18:49 * hackagebot fst 0.10.0.0 - Finite state transducers  http://hackage.haskell.org/package/fst-0.10.0.0 (JohnCamilleri)
06:19:20 <quchen> alexander__b: That should work, yes. You could also use (\xs@(x:_) ->x -> length xs).
06:19:31 <quchen> alexander__b: That should work, yes. You could also use (\xs@(x:_) -> (x, length xs)).
06:19:34 <quchen> Pardon
06:21:52 <alexander__b> uhm how do I just take the third element of a list? for some reason I thought it was take, but found out that that was taking the first three members.
06:22:04 <aCube> :t (!!)
06:22:06 <lambdabot> [a] -> Int -> a
06:22:11 <quchen> alexander__b: [1..] !! 3
06:22:11 <aCube> > [1,2,3,4,5] !! 2
06:22:13 <lambdabot>   3
06:22:17 <aCube> 3rd element
06:22:18 <alexander__b> aCube: oh right that was it. thanks.
06:22:35 <mcstar> case drop 3 lst of [] -> ; x:_ ->
06:22:45 <aCube> :t listToMaybe
06:22:46 <lambdabot> [a] -> Maybe a
06:22:49 <ziman> alexander__b, note that accessing the n-th element of a list takes the time O(n)
06:22:56 <mcstar> 2
06:22:58 <quchen> :t head . tail . tail
06:23:00 <lambdabot> [c] -> c
06:23:01 <quchen> There you go
06:23:12 <ab9rf> i knew someone would offer that :)
06:23:12 <ramses_> :t listToMaybe . drop 2
06:23:13 <aCube> listToMaybe [1,2,3]
06:23:14 <lambdabot> [a] -> Maybe a
06:23:15 <quchen> ;-)
06:23:21 <aCube> > listToMaybe [1,2,3]
06:23:22 <lambdabot>   Just 1
06:23:40 <ab9rf> ramses_: that'll still except if the list has frewer than 3 elements
06:23:49 * hackagebot dual-tree 0.1.0.2 - Rose trees with cached and accumulating monoidal annotations  http://hackage.haskell.org/package/dual-tree-0.1.0.2 (BrentYorgey)
06:23:52 <ab9rf> > (listToMaybe . drop 2) [1,2]
06:23:54 <ramses_> > (listToMaybe . drop 2) []
06:23:54 <lambdabot>   Nothing
06:23:55 <lambdabot>   Nothing
06:24:00 <aCube> :D
06:24:07 <aCube> > drop 2 []
06:24:08 <quchen> (head . take . take) `catch` (const [])
06:24:08 <ab9rf> oh, right
06:24:08 <lambdabot>   []
06:24:08 <quchen> :D
06:24:12 <ramses_> ab9rf: it doesn't
06:24:15 <ab9rf> i need more coffee
06:24:22 <ramses_> drop is total
06:24:26 <ab9rf> yeah, forgot
06:25:07 <ramses_> :t (listToMaybe .) . drop
06:25:08 <lambdabot> Int -> [a] -> Maybe a
06:26:05 <ab9rf> heh i love pointless form :)
06:26:19 <aCube> :t preview . ix :: Int -> [a] -> Maybe a
06:26:20 <lambdabot> Int -> [a] -> Maybe a
06:26:42 <adimit> so, liftA2 can be generalised to apply to arbitrary arities of functions (or generally, arbitrary nestings of Applicatives) by just arbitrarily composing it with itself. Like (liftA2 . liftA2 . liftA2). Fascinating.
06:27:01 <ramses_> :t preview
06:27:03 <lambdabot> MonadReader s m => Getting (First a) s t a b -> m (Maybe a)
06:27:03 <ab9rf> :t liftA2 . liftA2
06:27:05 <lambdabot> (Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
06:27:12 <ramses_> ah, that's lens, right?
06:27:20 <aCube> ramses_: yes
06:27:33 <FireFly> It must be; it contains STAB
06:27:40 <ab9rf> heh
06:27:43 <ab9rf> stabby functions
06:28:58 <ab9rf> aw, hoogle doesn't have preview
06:29:04 <aCube> ab9rf: but hayoo has
06:30:27 <fizbin> I need a good infix op name for just one file that means "kind of like &&&, but for HXT picklers" (basically, an inline xpPair) - any suggestions?
06:30:40 <edwardk> i should collect a portfolio of the grumbles about lens missing from hoogle and send them to ndm ;)
06:31:12 <aleator> My day spent in futile attempt to compete with school of haskell: http://functional-programming.it.jyu.fi/TIES343/Chapters/00600_Recursion.html#example-8-queens (Press enter on the first console). Any thoughts the functionality?
06:31:40 <tdammers> lens in hoogle would indeed greatly simplify a lot of things
06:32:05 <edwardk> tdammers: you can always email the maintainer
06:32:09 <tdammers> if you need more grumbles, I'd be happy to grumble up some for you
06:33:49 * hackagebot DrIFT-cabalized 2.2.3.3 - Program to derive type class instances  http://hackage.haskell.org/package/DrIFT-cabalized-2.2.3.3 (KiwamuOkabe)
06:33:52 * hackagebot vector-space-points 0.1.2.1 - A type for points, as distinct from vectors.  http://hackage.haskell.org/package/vector-space-points-0.1.2.1 (BrentYorgey)
06:34:00 <aCube> aleator: (Nothing functionality) I think it would look nicer if you'd add a space after the >
06:35:07 <aleator> aCube: Done. Anything else, that is bad besides the hastily written text?
06:47:43 <fizbin> @hoogle Either a b -> Bool
06:47:43 <lambdabot> Data.Graph.Inductive.Basic hasLoop :: Graph gr => gr a b -> Bool
06:47:43 <lambdabot> Data.Graph.Inductive.Query.DFS isConnected :: Graph gr => gr a b -> Bool
06:47:43 <lambdabot> Data.Graph.Inductive.Graph isEmpty :: Graph gr => gr a b -> Bool
06:50:37 <ab9rf> hm, there's no isLeft or isRight?
06:51:18 <ab9rf> i suppose you could use either (const False) (const True)
06:51:45 <int-e> @type null . lefts . return -- scnr
06:51:46 <lambdabot> Either a b -> Bool
06:52:11 <supki> > Left 3 & isn't _Right
06:52:13 <lambdabot>   True
06:52:40 <int-e> (this is particularly evil since it encodes 'isRight')
06:52:57 <ab9rf> int-e: indeed
06:53:02 <quicksilver> ab9rf: with either, lefts, and rights you don't often need isLeft or isRight
06:53:13 <ab9rf> quicksilver: still :)
06:53:16 <quicksilver> their omission is a little strange but perhaps it encourages you to think higher order :)
06:53:29 <ab9rf> quicksilver: or use pattern matching
06:53:34 <quicksilver> right
06:53:56 <int-e> if it helps, I have missed those two predicates occasionally. but they're so easy to write that it's hard to justify their existence.
06:54:28 <int-e> maybe consistency with Data.Maybe would count for something.
06:54:40 <ab9rf> yeah, that's actuallyu why i expected them to exist
06:54:49 <ab9rf> because of isJust and isNothing
06:56:00 <quicksilver> isJust and isNothing are almost *always* code smell.
06:56:52 <aCube> @hoogle (a -> b) -> (c -> a -> d) -> (c -> b -> d)
06:56:53 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
06:56:53 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
06:56:53 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
06:57:03 <aCube> Is there a function like this?
06:57:31 <aCube> @pl \f g a b = f a (g b)
06:57:31 <lambdabot> (line 1, column 10):
06:57:32 <lambdabot> unexpected "="
06:57:32 <lambdabot> expecting pattern or "->"
06:57:34 <ab9rf> aCube: apparently not
06:57:36 <aCube> @pl \f g a b -> f a (g b)
06:57:36 <lambdabot> flip . ((.) .)
06:57:38 <aCube> :O
06:58:07 * aCube would think that this function exists in lens or some of the bifunctor/profunctor stuff
06:58:17 <ab9rf> aCube: hoogle doesn't have lens
06:58:20 <int-e> hmm, we just had a proposal about this ... http://www.haskell.org/pipermail/libraries/2012-November/018976.html ... anybody care enough to go through the thread, summarize and revive it?
06:58:23 <mcstar> ((. ) ( .))
06:58:32 <aCube> that's why I'm asking ab9rf
06:59:08 <quicksilver> int-e: it has +1 from edwardk and johnw.
06:59:13 <elliott> @unpl (f <*> g) a b
06:59:13 <lambdabot> (f <*> g) a b
06:59:16 <quicksilver> int-e: is that not a sufficiently complete summary?
06:59:16 <elliott> > (f <*> g) a b
06:59:18 <lambdabot>   Ambiguous type variable `a0' in the constraints:
06:59:18 <lambdabot>    (GHC.Show.Show a0)
06:59:18 <lambdabot>     ...
06:59:20 <elliott> > (f <*> g) a b :: Expr
06:59:22 <lambdabot>   Ambiguous type variable `a0' in the constraints:
06:59:22 <lambdabot>    (GHC.Show.Show a0)
06:59:22 <lambdabot>     ...
06:59:27 <elliott> never mind.
06:59:49 <elliott> it was wrong anyway
06:59:53 <ab9rf> heh
07:00:07 <exFalso1> aCube: \f g a b -> f a (g b) is in Data.Function.Pointless
07:00:13 <typoclass> int-e: that thread seems to be only the proposal and three people saying "+1"
07:00:24 <quicksilver> well the thread did continue into december.
07:00:29 <int-e> quicksilver: it continues the next month
07:00:38 <quicksilver> I was just suggesting that people stop reading after +1s from edwardk and johnw
07:00:40 <exFalso1> (.^) that is
07:00:56 <aCube> @ty \f g -> uncurry f . snd g
07:00:57 <lambdabot> (a1 -> b -> c) -> (a2, a -> (a1, b)) -> a -> c
07:01:05 <aCube> @ty \f g -> curry $ uncurry f . snd g
07:01:07 <lambdabot> (a1 -> b1 -> c) -> (a2, (a, b) -> (a1, b1)) -> a -> b -> c
07:01:10 <elliott> that thread got derailed by the endless bikeshedding that libraries@ loves iirc
07:01:11 <typoclass> oh great. thanks guys. outsmarted by the web interface
07:02:11 <aCube> pointless-fun looks fun :D
07:02:50 <quicksilver> well Henning makes an apparently valid point that when it is used, it's often not really what you want
07:03:18 <quicksilver> I don't think there is a clear consensus on how strongly we accept the argument "actually this normally isn't what you want so let's not add it to the API"
07:03:29 <quicksilver> do we want our APIs to be complete, or opinionated?
07:05:27 <elliott> I think if we have isJust/isNothing we should have isLeft/isRight
07:05:37 <elliott> but perhaps we should have none of those.
07:06:40 <Iceland_jack> I like hush (∷ Either a b → Maybe b) and note (∷ a → Maybe b → Either a b) from Control.Error.Util
07:07:06 <Iceland_jack> I wonder why those aren't in Data.Either or Control.Monad.Error
07:08:19 <tdammers> do people actually *use* unicode syntax?
07:08:31 <geekosaur> some do, yes
07:08:35 <tdammers> huh
07:08:49 * hackagebot soap 0.1.0.3 - SOAP client tools  http://hackage.haskell.org/package/soap-0.1.0.3 (AlexanderBondarenko)
07:08:50 <tdammers> I thought it was more like a "because we can" kind of quirk
07:08:53 <geekosaur> we prefer not to use it in e.g. released modules, because they should be readable and usable by people who don't have full unicode capability
07:10:00 <geekosaur> it can be clearer than the ascii approximations, especially if you're used to working with the notation
07:10:41 <geekosaur> for someone like me, it's all just syntax and I'm not too concerned about it, so I just stick to the basics; there are far weirder things than haskell on my plate, syntactically :)
07:11:24 <arbn> geekosaur programs in whitespace and APL professionally.
07:11:34 <geekosaur> perl :)
07:11:38 <arbn> Ah.
07:11:44 * quicksilver tries to keep weird syntactic things *off* his plate, they stick to the cakes.
07:12:04 * quicksilver is a perl programmer too, do you know a help group?
07:12:15 <arbn> I met a K programmer recently. I'm not sure how he stands it.
07:16:12 <hiptobecubic> i hate unicode syntax so much
07:16:24 <Clint> what's "unicode syntax"?
07:16:38 <hiptobecubic>  (∷ Either a b → Maybe b)
07:17:04 <meyersh> Would be awesome if I had keys for those.
07:17:18 <exFalso1> the first unicode character i used in haskell was two days ago:
07:17:18 <exFalso1> λ :: (TyVal a -> TyVal b) -> TyVal (a -> b)
07:17:24 <hiptobecubic> right. Or if it was readable.
07:17:25 <tdammers> meyersh: compose key and urxvt's keycap symbol insert mode get you a long way
07:18:13 <exFalso1> you can also use agda-mode in emacs for latex-style unicode input
07:18:41 <FireFly> You could also have altgr/ralt act as a shift-like modifier
07:18:52 <FireFly> and put letter keys on altgr+hjkl or whatever
07:19:02 <FireFly> er, put arrow characters*
07:19:20 <int-e> there are those useless windows keys that make great super- hyper- whatever keys ;)
07:19:28 <hiptobecubic> That's what I do, but for accented latin characters. Not Greek.
07:19:38 <hiptobecubic> Does anyone else use hyper?
07:19:47 <arbn> int-e: XMonad needs those.
07:19:56 <exFalso1> arbn:+
07:20:15 <exFalso1> windows key is for window management
07:20:15 * FireFly has the Menu button as a "greek modifier"
07:20:18 <meyersh> I don't have a windows key, so I mapped caps to super and thats my Xmonad mod, leaving ctrl/meta/alt for emacsen.
07:20:35 <arbn> Emacs needs meta and control, and XMonad needs the windows key, so I am all out of modifier keys.
07:20:46 <arbn> Oh. I guess I could use caps lock.
07:21:14 <FireFly> and right-alt, and menu
07:21:16 <tdammers> I have super for xmonad, menu key for compose, and caps lock is still caps lock, but I have "figure out how to remap capslock to escape" on my to do list
07:21:19 <hiptobecubic> caps lock is hyper here
07:21:59 <hiptobecubic> tdammers, http://vpaste.net/qEHdt replace with escape
07:22:07 <FireFly> tdammers: with some magic you could have caps lock do both ctrl and esc: https://github.com/alols/xcape
07:22:15 <FireFly> Which is handy as a vim-user :-)
07:22:26 <meyersh> TAB might make a good modifier key, if ctrl-n or whatever could replace it.
07:22:27 <tdammers> vim is why I'd want that, yes
07:22:39 <tdammers> I need tab for zsh
07:22:56 <typoclass> FireFly: oh, that tool looks excellent, thanks a lot
07:22:57 <arbn> Hmm. I wish chording among the four modifiers had caught on. Then, we'd have many more options.
07:23:48 <meyersh> arbn: as in, four mods + <shortcut_key>?
07:24:34 <exFalso1> i was expecting an emacs joke
07:24:41 <hiptobecubic> exFalso1, it's implied
07:24:58 <arbn> meyersh: Like... chords on the piano. So, all 1-4 key combinations as possible modifiers among the 4 keys.
07:25:22 <typoclass> arbn: i'd rather have chording between regular keys, j and r or whatever. it seems awkward to simultaneously press several far-from-center keys like ctrl and shift
07:25:54 <hiptobecubic> i regularly use super + shift + hyper (capslock) in various combinations
07:26:28 * geekosaur wonders if anyone's designed a computing key layout with the modifiers on (for qwerty) yghb
07:26:49 <hiptobecubic> it's annoying to find intuitive bindings for everything
07:26:57 <hiptobecubic> geekosaur, that would be terrible
07:27:09 <dmwit> geekosaur: Dunno, but my Kinesis has the modifiers under your thumbs, which is Pretty Good.
07:27:09 <typoclass> geekosaur: i'd want that!
07:27:14 <geekosaur> probably, but when has that stopped anyone?
07:27:34 <typoclass> dmwit: yeah, kinesis does a lot of good stuff
07:27:48 <hiptobecubic> dmwit, this is the nerdiest goddamn keyboard i have ever seen
07:27:57 <dmwit> very much so, yes
07:28:30 <dmwit> It is Enterprise. =)
07:29:39 <dmwit> Huh. One of Wikipedia's two pictures of this keyboard is dons' xmonad "screenshot".
07:29:50 <hiptobecubic> :D
07:32:05 <ramses_> @faq can Haskell be Enterprise?
07:32:06 <lambdabot> The answer is: Yes! Haskell can do that.
07:32:10 <ramses_> whew!
07:32:36 <kryft> I would love to use emacs, but I can't get over the need for modifiers. :P Having them under the thumbs would be nice, but then I'd be dependent on a particular keyboard. *grumble*
07:32:36 <FireFly> @faq can Haskell eat my soul?
07:32:37 <lambdabot> The answer is: Yes! Haskell can do that.
07:32:41 <FireFly> Hooray!
07:33:02 <kryft> I have yet to investigate how well I can avoid ctrl and alt by using evil mode
07:33:16 <eikke> @faq can Haskell or GHC convert my O(N^2) algorithm to O(1)?
07:33:17 <lambdabot> The answer is: Yes! Haskell can do that.
07:33:31 <arbn> kryft: What's wrong with alt and control?
07:33:35 <FireFly> Haskell's pretty sweet
07:33:45 <FireFly> Managing to perform such optimisations..
07:34:14 <meyersh> @faq can Haskell handle O(1/N) algorithms?
07:34:15 <lambdabot> The answer is: Yes! Haskell can do that.
07:34:16 <kryft> arbn: I find them quite unergonomic and slow
07:35:06 <ramses_> meyersh: now you're pushing it
07:35:23 <meyersh> :D
07:35:56 <hiptobecubic> dmwit, seriously. This keyboard.
07:36:00 <hiptobecubic> dmwit, what the hell
07:36:03 <arbn> kryft: You've been listening to too much vi propaganda. Free your mind, lad.
07:37:04 <hiptobecubic> evil mode looked *ok*
07:37:17 <hiptobecubic> Would take time to turn it into a proper editor though.
07:37:27 <kryft> arbn: Tell that to my wrists
07:37:54 <hiptobecubic> kryft, why don't you just drop $360 on a Kinesis keyboard?
07:37:59 <tdammers> whee, capslock is now escape
07:38:05 <tdammers> which leads me to the next question
07:38:10 <tdammers> what do I do with escape
07:38:16 <hiptobecubic> With all the dates you won't be getting, it will pay for itself in no time
07:38:28 <lispy> @tell ivanm Sorry, I have not. Thanks for the reminder. I won't be able to look at it till after the weekend.
07:38:28 <lambdabot> Consider it noted.
07:40:55 <hiptobecubic> I had this footswitch-as-modifier idea independently when I was playing with midi,  I guess kinesis has had it for awhile.
07:42:05 <kryft> hiptobecubic: As I mentioned above, that's a valid option, but then I would be dependent on a specific keyboard
07:42:34 <hiptobecubic> usb footswitch
07:44:22 <ab9rf> get a cyberjack already
07:44:28 <ab9rf> nobody uses keyboards anymore
07:46:39 <fizbin> :t either undefined id
07:46:40 <lambdabot> Either a c -> c
07:46:55 <fizbin> :t either id undefined
07:46:56 <lambdabot> Either c b -> c
07:47:08 <arkeet> kryft: just stay on the vim side =)
07:47:26 <arkeet> and remap capslock to esc perhaps
07:47:29 <ramses_> :t either undefined undefined
07:47:30 <lambdabot> Either a b -> c
07:47:38 <fizbin> @pl let f (Left x) = x in f
07:47:38 <lambdabot> (line 1, column 13):
07:47:39 <lambdabot> unexpected "x"
07:47:39 <lambdabot> expecting operator or ")"
07:48:08 <arkeet> @pl \(Left x) -> x
07:48:08 <lambdabot> (line 1, column 8):
07:48:08 <lambdabot> unexpected "x"
07:48:08 <lambdabot> expecting operator or ")"
07:48:10 <fizbin> :t let f (Left x) = x in f (Left 5)
07:48:11 <lambdabot> Num t => t
07:48:12 <ramses_> fizbin: that would crash as hard as the either with undefined
07:48:16 <arkeet> @pl f (Left x) = x
07:48:16 <lambdabot> (line 1, column 13):
07:48:16 <lambdabot> unexpected " "
07:48:16 <lambdabot> expecting operator
07:48:28 <arkeet> balls.
07:48:45 <ramses_> @pl (e -> case e of (Left x) -> x)
07:48:45 <lambdabot> (line 1, column 6):
07:48:45 <lambdabot> unexpected '>'
07:48:45 <lambdabot> expecting operator
07:48:48 <arkeet> ramses_: at least you'd get an ever so slightly more informative error message.
07:48:55 <fizbin> ramses_: Actually, I just had a good reason to use "either id undefined" in my code.
07:49:11 <fizbin> It bothers me, but I don't see a good way to do something else, so...
07:49:24 <arkeet> why not either id (error "fromLeft: not Left")
07:49:33 <fizbin> either id (const mzero)
07:49:46 <fizbin> :t either id (const mzero)
07:49:48 <lambdabot> MonadPlus m => Either (m a) b -> m a
07:50:02 <arkeet> :t either id (const mempty)
07:50:04 <lambdabot> Monoid c => Either c b -> c
07:50:05 <ramses_> fizbin: can't you somehow change the function that produces that Either then? If you somehow now it will _always_ be a Right
07:50:07 <arkeet> :t view _Left
07:50:08 <lambdabot> (Monoid a, MonadReader (Either a c) m) => m a
07:50:42 <fizbin> ramses_: Not really. Let me remove stuff specific to my employer and hpaste it.
07:51:54 <hpaste> fizbin pasted “Yeah, I really needed undefined” at http://hpaste.org/84760
07:52:16 <ramses_> fizbin: I'm not saying that something like can't be legitimate, if you thought about it, it probably will be
07:52:25 <ramses_> s/like/like that
07:52:55 <arkeet> looks avoidable.
07:53:31 <fizbin> I don't like using undefined, but the HXT xpickle combinators don't have an easy way to do it.
07:53:58 <fizbin> arkeet: Everything else got really, really ugly.
07:54:31 <arkeet> there ought to be a better way.
07:55:10 <arkeet> but I guess the hxt api you get isn't helping.
07:56:44 <hpaste> fizbin revised “Yeah, I really needed undefined”: “With one fewer undefined” at http://hpaste.org/84760
07:57:50 <fizbin> So I initially had that second version. And it kinda sucks too. However, maybe I can expand what xpChoice really is to eliminate the undefined bit.
07:58:32 <arkeet> this api is begging for lenses/prisms. :p
07:58:56 <fizbin> Maybe.
08:00:47 <centrinia> Hell Eduard_Munteanu
08:01:19 <Eduard_Munteanu> centrinia: hell to you too :)
08:01:31 <centrinia> :)
08:11:08 <fizbin> @pl \x -> liftM Right x
08:11:08 <lambdabot> fmap Right
08:12:28 <fizbin> What do I need to import to make fmap work on arbitrary Monads?
08:12:49 <Clint> what?
08:12:51 <Botje> Control.Monad.Instances, usually.
08:13:00 <Botje> that's my go-to
08:13:20 <geekosaur> if you want arbitrary monads, use liftM instead. that all monads are not automatically Functors is a difficult to fix historical wart
08:13:20 <quchen> fizbin: All decent monads are also functors.
08:13:38 <geekosaur> (difficult to fix because of breaking existing code)
08:14:10 <arkeet> how much existing code defines monad instances without corresponding functor instances?
08:14:15 <quchen> You would have to add 5 lines to all existing monads, which is too much of a burden for maintainers or something.
08:14:15 <fizbin> quchen: Sure, logically. But I've got a library that defines a monad but fails to define a Functor instance for the thing.
08:14:33 <arkeet> instance Functor blah where fmap = liftM
08:14:35 <arkeet> 1 line.
08:14:36 <elliott> you should complain to that library's author
08:14:38 <quchen> fizbin: Then make the functor instance yourself
08:15:07 <fizbin> I suppose. Not really worth it - I can type fmap instead of liftM where I need to
08:15:15 <quchen> When elliott says complain he means to put glue in his toothpaste
08:15:21 <quchen> That'll be appropriate
08:15:52 <fizbin> @hoogle mchoice
08:15:52 <lambdabot> No results found
08:16:25 <arkeet> I don't understand why Unpickler isn't defined as StateT St (Either UnpickleVal)
08:16:30 <arkeet> oh well
08:16:41 <arkeet> er
08:16:45 <arkeet> oh that's not quite what it is.
08:17:19 <arkeet> it's EitherT of State.
08:18:46 * fizbin may have a way with no undefined. He's not sure it's readable though.
08:19:29 <tdammers> arkeet: I read that as "it's either T or State" (but not both)
08:19:36 <arkeet> lol
08:20:19 <hpaste> fizbin revised “Yeah, I really needed undefined”: “Okay, no more undefined” at http://hpaste.org/84760
08:20:31 <tdammers> #define undefined
08:21:19 <fizbin> @pl f -> return . f
08:21:19 <lambdabot> (line 1, column 5):
08:21:19 <lambdabot> unexpected '>'
08:21:19 <lambdabot> expecting operator
08:21:33 <fizbin> @pl \f -> return . f
08:21:33 <lambdabot> (return .)
08:21:51 <fizbin> Hrm. I thought that'd be something standard.
08:23:20 <geekosaur> :t \f -> return . f
08:23:21 <lambdabot> Monad m => (a -> b) -> a -> m b
08:23:24 <arkeet> it is, it's called (return .)
08:23:33 <geekosaur> :t liftM f
08:23:35 <lambdabot> (Monad m, Show a1, FromExpr r) => m a1 -> m r
08:23:44 <arkeet> or would you like it to be called returnComposedWith
08:23:48 <geekosaur> hm, I should consider wakinhg up
08:32:32 <haskell-newb> hey guys, i have a very newbie question about haskell i need to ask - does anyone know a newbie channel i can go to?
08:32:50 <supki> try #haskell
08:33:04 <haskell-newb> ok :)
08:33:24 <arkeet> does anyone here ever refer anyone to beginners@ ?
08:33:26 <quicksilver> there are no newbie questions, only newbie answers, or something like that :-) Just ask away.
08:33:30 <haskell-newb> i was doing a simple haskell exercise on http://www.haskell.org/haskellwiki/99_questions/Solutions/8
08:33:38 <hpc> quicksilver: only monad tutorials? :P
08:33:52 <haskell-newb> it's a pretty simple problem
08:33:59 <haskell-newb> bit
08:34:01 <haskell-newb> but
08:34:02 <haskell-newb> compress :: (Eq a) => [a] -> [a] compress = foldr skipDups []     where skipDups x [] = [x]           skipDups x acc                 | x == head acc = acc                 | otherwise = x : acc
08:34:08 <hpc> @where hpaste
08:34:08 <lambdabot> http://hpaste.org/
08:34:46 <hpaste> haskell-newb pasted “compress” at http://hpaste.org/84765
08:34:54 <quicksilver> well in your two guards on the second case
08:34:59 <haskell-newb> yea
08:35:01 <haskell-newb> what i dont understand
08:35:06 <haskell-newb> is why the list wouldn't go backwards
08:35:13 <haskell-newb> cause in "otherwise = x:acc"
08:35:20 <haskell-newb> isn't that appending the next item in the front?
08:35:32 <haskell-newb> it's folding towards the right
08:35:35 <haskell-newb> and appending each new item in front?
08:35:45 <quicksilver> no, it's folding from the right
08:35:47 <Botje> haskell-newb: folding *from* the right
08:35:54 <haskell-newb> o...
08:36:00 <quicksilver> 'acc' has all the stuff already done from the list "to the right" of you
08:36:04 <hpc> > foldr (+) z [1..10]
08:36:06 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + z)))))))))
08:36:25 <haskell-newb> um... so if it folds from the right
08:36:35 <haskell-newb> then how could foldr work with infinite lists?
08:36:48 <arkeet> nothing starts from the right.
08:36:50 <merijn> haskell-newb: Could you try writing longer lines instead of using enter as a comma? It's a bit annoying to see 8 lines of 6 words scroll by
08:37:07 <Botje> haskell-newb: if your function is not strict in acc it is never computed
08:37:15 <merijn> haskell-newb: Notice how it is "1 + <rest of computation>"?
08:37:26 <arkeet> however, it is true that the reason foldr can exist is because of laziness.
08:37:44 <merijn> haskell-newb: Suppose we replace + with the function "foo", which never looks at its second argument and always returns the first
08:38:01 <merijn> haskell-newb: Now the rest of the fold never has to be done!
08:38:06 <hpc> > foldr const z [1..]
08:38:08 <lambdabot>   1
08:38:21 <merijn> For example, && returns false if the first value is false, right?
08:38:30 <merijn> > repeat True
08:38:31 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
08:38:41 <haskell-newb> but then with the previous example of compress, the list is built from the right hand side with foldr
08:38:43 <merijn> > foldr (&&) False (repeat True)
08:38:46 <lambdabot>   mueval-core: Time limit exceeded
08:39:02 <merijn> oh, duh
08:39:11 <merijn> > foldr (&&) True (False : repeat True)
08:39:12 <hpc> > foldr (&&) False (False : [True, True, ..])
08:39:13 <lambdabot>   False
08:39:14 <lambdabot>   <hint>:1:40: parse error on input `..'
08:39:34 <saep> @src foldr
08:39:34 <lambdabot> foldr f z []     = z
08:39:35 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:39:58 <arkeet> > foldr (&&) False (False : [True, True ..])
08:39:58 <haskell-newb> ah...
08:39:59 <lambdabot>   False
08:40:00 <quicksilver> it's a really good question.
08:40:32 <quicksilver> the fact that foldr folds from the right but stil (with a lazy function) starts from the left is the heart of what confused me for ages
08:40:34 <sproingie> it starts from the left like every other tail recursive function, it just accumulates the right first
08:40:52 <sproingie> if it doesn't have to accumulate the right, it doesn't, that's why it stops
08:41:07 <haskell-newb> ah i see, that's what confused me
08:41:10 <ramses_> sproingie: foldr is not tail-recursive
08:41:20 * merijn smells the smell of a mind being blown :)
08:41:23 <Tordek> is there a way to 'ask for types'with GHC? e.g.: I have some function (say, sortOn), and I want to know the type of another function (let's call it ||), so I want ask 'what's the type of || on `sortOn (a || b)`?'
08:41:41 <merijn> Tordek: asAppliedTo?
08:41:45 <sproingie> oh right it's not properly tail recursive, bad term
08:41:53 <merijn> > fmap `asAppliedTo` Just 1
08:41:54 <lambdabot>   Couldn't match expected type `a0 -> b0'
08:41:55 <lambdabot>              with actual type `Data...
08:41:58 <ramses_> sproingie: "tail-recursive modulo cons"
08:41:59 <merijn> awww
08:42:04 <merijn> > fmap `asAppliedTo` Just 'c'
08:42:05 <lambdabot>   Couldn't match expected type `a0 -> b0'
08:42:05 <lambdabot>              with actual type `Data...
08:42:08 <hpc> Tordek: there's :t in ghci
08:42:11 <merijn> oh, duh
08:42:15 <haskell-newb> ok i think i'm going to drill down into the definition of foldr more, thanks a lot for the help
08:42:30 <merijn> > fmap succ `asAppliedTo` (Just 'c')
08:42:32 <lambdabot>   *Exception: show: No overloading for function
08:42:32 <sproingie> for real mind==blown, define foldr in terms of foldl
08:42:33 <hpc> i can't imagine what benefit you could get from that feature other than as a human aid during coding
08:42:47 <arkeet> sproingie: you can't.
08:42:48 <hpc> otherwise i just see it encouraging uglier and uglier types
08:42:50 <ramses_> > foldr f z [i,j,k]
08:42:51 <merijn> hpc: Maybe that's all he wants?
08:42:52 <lambdabot>   f i (f j (f k z))
08:42:53 <arkeet> sproingie: but you can define foldl in terms of foldr
08:42:55 <ramses_> > foldl f z [i,j,k]
08:42:56 <lambdabot>   f (f (f z i) j) k
08:43:01 <merijn> My examples are all failing, though :\
08:43:03 <Tordek> hpc: yeah, I could open a file, write my definitions there, and thend do :t (||), but, I was wondering if I could do it straight from ghci
08:43:11 <ramses_> haskell-newb: compare those two, the difference lies solely in the associativity
08:44:06 <hpc> :t let (||) = undefined in (||)
08:44:06 <arkeet> Cale: where's your foldl/foldr picture.
08:44:07 <lambdabot> a
08:44:11 <hpc> voila! :P
08:44:36 <Tordek> nice, thanks!
08:45:43 <Tordek> hpc: er, no
08:59:11 <aforemny> I'm using Snap and trying to create AuthUsers automatically using Snap.Snaplet.Auth. However, I cannot find a way to create (or update) the backend upon initializsation, because withBackend runs in the Handler monad and not in the Initializer monad. How do I execute a Handler command every time the server starts (in contrast to every time a Request is served)?
09:00:05 <aforemny> I started deconstructing the serveSnaplet function. But I feel this is too hacky.
09:00:51 <mightybyte> aforemny: You might want to go to #snapframework to discuss that.
09:01:19 <aforemny> mightybyte: Thanks! I'll do that.
09:03:25 <tippenein> vim bindings for emacs project?
09:03:46 <roshan> Hi, I need some help choosing one of the free monad packages on Hackage
09:05:28 <supki> @hackage free
09:05:28 <lambdabot> http://hackage.haskell.org/package/free
09:06:15 <Sonarpulse> can somebody compile something for me?
09:06:23 <roshan> supki: I've been looking at that package, but it seems to be missing a lot of the utility functions in control-monad-free (which hasn't been updated in a while, though)
09:06:59 <Sonarpulse> I normally run linux, but I needed to make a windows build
09:07:12 <Sonarpulse> I got this weird linking error however I reported here: to make a windows build of
09:07:42 <Sonarpulse> whoops http://hackage.haskell.org/trac/ghc/ticket/7764
09:09:24 <Sonarpulse> the code is at https://github.com/Ericson2314/Codec.Archive.CnCMix
09:09:37 <Sonarpulse> despite my linking error, it doesn't use the FFI or anything like that
09:10:03 <Sonarpulse> and only one package not on the platform: cmdlib
09:13:18 <Sonarpulse> anybody?
09:37:06 <notdan> Hi!
09:37:28 <notdan> Does anyone have any sort of experience with working with .xsd data in Haskell?
09:37:42 <hpc> what is xsd?
09:40:04 <notdan> XML Schema Definition/XML Schema Language
09:40:04 <dgpratt> XML schema
09:55:04 <alexander__b> search needle haystack =
09:55:06 <alexander__b>   let nlen = length needle
09:55:08 <alexander__b>   in  foldl (\acc x -> if take nlen x == needle then True else acc) False (tails haystack)
09:55:10 <alexander__b> I don't really understand this.
09:55:21 <alexander__b> why is it using tails in this way? to what purpose?
09:55:40 <alexander__b> I am using "this is a test" and "test".
09:56:07 <alexander__b> > tails "this is a test"
09:56:09 <lambdabot>   ["this is a test","his is a test","is is a test","s is a test"," is a test"...
09:56:20 <alexander__b> > scanl (\acc x -> if take (length "test") x == "test" then True else acc) False (tails "this is a test")
09:56:21 <quicksilver> because if a string occurs, it will be the prefix of some member of 'tails'
09:56:21 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,True,Tru...
09:57:00 <quicksilver> the last few items of (tails "this is a test") are "a test", " test", "test", "est", "st", "t"
09:57:04 <alexander__b> it's True for the five last -- "test","est","st","t",""
09:57:18 <quicksilver> no it's not.
09:57:29 <quicksilver> take 4 "st" is "st"
09:57:30 <quicksilver> not "test"
09:57:39 <quicksilver> it's true only one, in your example.
09:57:48 <alexander__b> lambdabot disagrees
09:57:54 <alexander__b> > scanl (\acc x -> if take (length "test") x == "test" then True else acc) False (tails "this is a test")
09:57:55 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,True,Tru...
09:58:05 <quicksilver> sorry, disagreement about what "it" is ;)
09:58:08 <alexander__b> True, Tru... (and if it had more space it would spit out True five times)
09:58:10 <alexander__b> oh.
09:58:16 <quicksilver> take (length "test") x == "test"
09:58:19 <quicksilver> that part is true only once.
09:58:37 <quicksilver> the scanl part keeps being true after that
09:58:42 <quicksilver> because of the 'else acc' part
09:58:43 <alexander__b> I see.
09:58:50 <alexander__b> yes, of course.
09:58:57 <quicksilver> the else acc part means the scanl keeps being true once it's been true once.
09:58:57 <alexander__b> folds are still a bit scary to me. :-)
09:59:55 * qwr . o O ( search needle = any (isPrefixOf needle) . tails )
10:00:35 <glguy> :t isInfixOf
10:00:36 <lambdabot> Eq a => [a] -> [a] -> Bool
10:00:40 <hpc> alexander__b: start with foldr; the quick way to understand is to take a list, like
10:00:55 <hpc> 1 : (2 : (3 : []))
10:01:10 <alexander__b> i.e. [1..3]
10:01:17 <hpc> and if we apply (foldr (+) 0), we replace (:) with (+) and [] with 0
10:01:24 <hpc> 1 + (2 + (3 + 0))
10:01:43 <alexander__b> right. got that.
10:02:38 <hpc> every function that operates on lists can be written as foldr
10:02:48 <hpc> (modulo some weird stuff that doesn't count)
10:03:04 <hpc> so whenever you see a function that operates on lists, try and finagle it into a foldr
10:03:07 <byorgey> like Ackermann's function on numbers represented by [()]? =)
10:03:21 <hpc> and you'll slowly figure it out
10:03:35 <Mortchek> hpc, I'm really curious what doesn't count.
10:05:03 <hpc> i am fairly sure you can't write foldl' in terms of foldr
10:05:18 <mcstar> hpc: replicate this with foldr > head []
10:05:18 <hpc> and likely anything having to do with seq
10:05:29 <Mortchek> Ah, sure, adding strictness would be hard I guess
10:05:47 <hpc> > foldr const (error "cannot take head of empty list") [1..5]
10:05:49 <lambdabot>   1
10:05:50 <hpc> > foldr const (error "cannot take head of empty list") []
10:05:52 <lambdabot>   *Exception: cannot take head of empty list
10:05:59 <mcstar> :)
10:06:01 <mcstar> ty
10:06:53 <hpc> a mechanical translation that covers most list functions is to replace
10:07:08 <hpc> foo [] = z; foo (x:xs) = expr
10:07:19 <hpc> with foldr (\x xs -> expr) z
10:07:33 <mcstar> how hard would a zip be?
10:07:55 <mcstar> well, i guess not that hard, i take it back
10:08:24 <byorgey> foldr corresponds to primitive recursion for lists, and it's a curious fact that there exist recursive functions which are not primitive recursive.
10:08:31 <byorgey> but you are not likely to want to write any such functions
10:08:32 <parcs> hpc: isn't it more like foo (x:xs) = expr x (foo xs) ==> foldr (\x xs -> expr x xs)
10:08:45 <mjrosenb> now that there are more people awake
10:09:13 <mjrosenb> anyone have a recommendation for how to draw stuff with cairo to as close to a raw X window as I can get?
10:09:13 <hpc> oh yes, that
10:09:31 <ion> @type let foo [] = ?z; foo (x:xs) = ?expr0; bar = foldr (\x xs -> ?expr1) in ()
10:09:32 <lambdabot> ()
10:09:40 <ion> @type let foo [] = ?z; foo (x:xs) = ?expr0; bar = foldr (\x xs -> ?expr1) in (foo, bar)
10:09:42 <lambdabot> (?expr1::b, ?z::t1, ?expr0::t1) => ([t] -> t1, b -> [a] -> b)
10:10:01 <ion> @type let foo [] = ?z; foo (x:xs) = ?expr0; bar = foldr (\x xs -> ?expr1) in [foo, bar]
10:10:03 <lambdabot> (?expr1::[t], ?z::[a] -> [t], ?expr0::[a] -> [t]) => [[t] -> [a] -> [t]]
10:10:09 <tgeeky> ion: wat! are those implicit paramters?
10:10:18 <hpc> i blame the vapors of soothing and mental impairment that seem to permeate warm sunny beachfronts :P
10:10:55 <ion> @type let foo [] = ?z0; foo (x:xs) = ?expr0; bar = foldr (\x xs -> ?expr1) ?z1 in [foo, bar]
10:10:56 <lambdabot> (?expr1::t1, ?z1::t1, ?z0::t1, ?expr0::t1) => [[t] -> t1]
10:11:14 <ion> (Stupid mistake on my part, ignore the earlier @type commands.)
10:11:20 <ion> tgeeky: yeah
10:11:34 <tgeeky> ion: i thought lambdabot had them turned off. huh.
10:12:23 <geekosaur> no, they're useful for getting it to tell you the type of something you can't easily break out of a complex expression, for one
10:12:58 <tgeeky> geekosaur: our powers combined, we'd be technogeekosaur.
10:13:23 <tgeeky> yeah, I've used them (I'm waiting to check out holes, very soon), but I thought lambdabot had them turned off for some reason.
10:21:50 <mcstar> i guess you can draw with cairo into a buffer, and then write that buffer to an X region
10:22:13 <mcstar> it seems possible, dont have code though
10:22:24 <mcstar> mjrosenb: ^
10:22:48 <fizbin> @hoogle Either a b -> (Maybe a, Maybe b)
10:22:48 <lambdabot> No results found
10:23:06 <mjrosenb> mcstar: that sounds slow
10:23:16 <mcstar> it isnt
10:23:19 <mjrosenb> mcstar: doesn't cairo have the ability to speak directly with X?
10:23:29 <mcstar> what do you think happens in the background?
10:23:36 <mcstar> you need double buffering
10:23:37 <mjrosenb> mcstar: true.
10:24:14 <mjrosenb> mcstar: is there any code that does this? I've never done X/haskell before, and it seems like most things are geared towards gtk, and that whole stack.
10:24:45 <mcstar> i really havent checked if there is a pure X binding, but i'd guess there is
10:25:04 <mcstar> with gtk the whole stuff is only a couple of lines
10:25:19 <mcstar> there is code on the haskell wiki on how to initialize a window ready for drawing
10:26:08 <mcstar> mjrosenb: http://hackage.haskell.org/package/X11-1.6.0.2
10:26:30 <mcstar> mjrosenb: if you have problems ask dmwit_
10:27:59 <byorgey> so I'm calling  readProcessWithExitCode to run a shell command and get the stdout.  But I'd somehow like to get the stdout lazily.
10:28:04 <byorgey> What's the best way to do that?
10:28:33 <mcstar> what does that mean?
10:28:50 <byorgey> I mean I want to be able to start doing something with the stdout before the process completes
10:28:52 <mcstar> you consume as much stdout as you want, dont you>
10:29:27 <mcstar> you want to hold on to stdout, and start the process later?
10:29:45 <byorgey> yes, but if I just do   (_,out,_) <- readProcessWithExitCode ... ;  putStrLn out
10:29:56 <byorgey> it waits for the process to complete before anything gets printed
10:30:03 <mcstar> really?
10:30:10 <mcstar> it depends on buffering i think
10:30:16 <byorgey> oh?  hmm.
10:30:21 <mcstar> i surely see every line...
10:30:28 <byorgey> let me go play around a bit more I guess.
10:30:32 <luite> byorgey: that's not surprising since putStrLn forces the whole string
10:30:42 <mcstar> the process is an 'echo' in a loop, so it flushes after every invocation
10:31:07 <mcstar> 'out' can be a String?
10:31:13 <byorgey> out is a String, yes
10:31:25 <mcstar> byorgey: then use another function to call your script
10:31:36 <byorgey> mcstar: like what?
10:31:37 <mcstar> like runInteractiveCommand/Process
10:31:44 --- mode: ChanServ set +o edwardk
10:31:44 <mcstar> or the createProcess
10:31:59 <byorgey> aha! thanks
10:32:24 <Taneb> (edwardk is an op?)
10:32:35 <mcstar> OmniPotent? yes
10:32:42 <johnw> Taneb: yes
10:32:56 <johnw> so are byorgey and myself
10:32:57 <Taneb> I'm scared to think what he'll do with this power
10:33:08 <johnw> is there something you needed?
10:33:11 <Taneb> Give us all lens commit access
10:33:11 --- mode: edwardk set +b *!*@nl4x.mullvad.net
10:33:21 <Taneb> That'd be terrifying
10:33:26 <byorgey> hehe
10:33:46 <Taneb> It also might be a world record
10:33:48 --- kick: ClwFngr was kicked by edwardk (Your behavior is not conducive to the desired environment.)
10:34:03 --- mode: edwardk set -o edwardk
10:34:12 <quchen> (Another channel-hop-spammer or what?)
10:34:38 <edwardk> "[13:30] ClwFngr: Hey edwardk, http://adf.ly/KeX0D No popups, no popunders and no annoying ads. Only naked teen girls playing around for you! New this week, celebrity nudity and webcams! http://adf.ly/KeX0D :)"
10:34:48 <ab9rf> heh, this is why i have joins and parts silenced in here
10:34:58 <ab9rf> edwardk: spiffy
10:35:05 <ChongLi> probably a bot
10:35:09 <mcstar> edwardk: you really repeated his spam? thereby you becoming the spammer? wth
10:35:11 <mcstar> kick yourself
10:35:13 <edwardk> yeah
10:35:31 <quchen> I like how they advertise with spam that they're free of annoyances
10:35:31 <dgpratt> I have joins/parts hidden in here because there's just to darn many of them
10:35:36 <dgpratt> *too
10:36:08 <sproingie> know offhand how to silence join/part per-channel in irssi?
10:36:13 <edwardk> i was originally just going to repeat it to the ops channel, but it simplified the answer ;)
10:36:22 <sproingie> i have a couple channels where i'd rather keep the messages on
10:37:27 <mcstar> why?
10:37:40 <sproingie> ah nevermind teh googelz answered for me
10:37:54 <ChongLi> sproingie: irssi's window levels is nice
10:38:10 <quchen> ..?
10:38:21 <quchen> OT here, but I'd like to hear more about IRSSI in #-blah
10:38:21 <sproingie> ChongLi: window levels?  tell me more?
10:38:46 <ChongLi> sproingie: every window in irssi has levels
10:38:56 <ChongLi> which dicate what sort of messages show up
10:39:07 <ChongLi> use /help levels to see a list
10:39:35 <sproingie> oh hay interesting
10:39:44 <ChongLi> and /window level [-/+]WHATEVER to change them
10:39:45 <mcstar> i only see those that have my nick in them
10:42:13 <johnw> mcstar: that makes #haskell pretty quiet, no?
10:42:24 <mcstar> yes, i like that
10:48:42 <quchen> "ReaderT r IO" is safe to use with IORefs, right? Or am I in for some unexpected results
10:48:49 <ChongLi> hmm, rust seems like an interesting language
10:49:18 <byorgey> quchen: should be fine.
10:49:40 <donri> quchen: safe how? unsafe how?
10:49:59 <quchen> donri: Switching the order etc
10:50:12 <quchen> (Single process only, don't worry)
10:50:54 <donri> quchen: don't follow
10:50:59 <Ralith> what's the syntax for having both a pattern guard and a boolean guard on the same branch?
10:51:13 <Ralith> with the latter having the variables introduced by the former in scope
10:51:38 <newsham> f (Just x) | x < 25 = x * 2      ?
10:51:40 <quchen> Ralith: I'm not sure I understand the problem. Do you mean "f (x:xs) | x > 0 = "
10:51:43 <quchen> ?
10:51:45 <liyang> quchen: ReaderT r IO a ≅ r → IO a , so we're not sure what you'd mean by 'unsafe'...
10:51:46 <quchen> Yeah that should work
10:51:53 <byorgey> quchen: well it certainly can't switch the order of reads and writes to the IORef.  And even if it did switch the order of IORef operations and reads from the reader environment (which it won't), it wouldn't matter.
10:52:01 <byorgey> because the reader environment is constant.
10:52:39 <Ralith> quchen: I want 'f x y | Just z <- foo x, y == z ='
10:52:42 <quchen> byorgey: Not if the reader environment is an IORef though ..?
10:52:46 <Ralith> except , is probably wrong
10:52:58 <quchen> Ralith: "Pattern guards"
10:53:05 <byorgey> quchen: it's still constant.  It's always the same IORef.
10:53:14 <quchen> Ralith: http://www.haskell.org/haskellwiki/Pattern_guard
10:53:15 <Ralith> quchen: yes, I am using pattern guards
10:53:18 <liyang> quchen: you mean ReaderT (IORef r) IO ?
10:53:25 <Ralith> quchen: the question is how to combine those with a boolean guard
10:53:35 <Ralith> looks like , was correct though
10:53:38 <Ralith> yay vague memory
10:53:38 <quchen> liyang: Something like that, yes
10:54:19 <liyang> quchen: you'd still need to do IO to get the r out of the IORef. That's no different than juggling two IORefs...
10:54:27 <byorgey> quchen: sure, that will work just fine.  The whole point is that it's impossible to use IORefs in a way that is unsafe.
10:54:36 <byorgey> aside from the usual "unsafe"ness of mutable state.
10:55:06 <donri> the reader just gives you access to the ioref, not the value contained in it (not without reading it like normal)
10:55:25 <quchen> Right
10:55:44 <Ralith> quchen: (you can tell because I said 'pattern guard' in my question :p)
10:55:57 <quchen> Yeah I guess the question was pretty pointless then. But I wanted to be sure it's a solution for my problem before I rewrote all the code
10:56:08 <quchen> Now that I think of it maybe I should replace the IORef with a State anyway
10:56:17 <quchen> Oh well, thanks to all of you
10:56:19 <quchen> Ralith: Woops
10:57:38 <donri> instance MonadState (Reader IORef)  yay!
10:57:54 <quchen> donri: Pfff
10:58:07 <byorgey> kind error
10:58:17 <donri> pseudo code
10:58:35 <quchen> I'm relying on IORefs right now without a reader. I can now add something convenient with Reader. That's how I came up with the idea.
10:58:54 * hackagebot reflection 1.2.0.1 - Reifies arbitrary terms into types that can be reflected back into terms  http://hackage.haskell.org/package/reflection-1.2.0.1 (EdwardKmett)
11:03:54 * hackagebot profunctors 3.3.0.1 - Haskell 98 Profunctors  http://hackage.haskell.org/package/profunctors-3.3.0.1 (EdwardKmett)
11:05:58 <dmwit> donri: I've wondered several times why there wasn't a library with that in it. Same for s/IORef/MVar/
11:07:04 <donri> dmwit: isn't it kinda pointless if you use only the state api, and illegal if you don't?
11:07:35 <dmwit> No.
11:07:49 <dmwit> What if I want to write my Gtk callbacks as if they had access to a shared state?
11:08:00 <dmwit> (For example.)
11:08:54 <donri> but is it really a legal state monad if you writeIORef outside a state computation?
11:09:35 <dmwit> I'm confused. Maybe I don't understand the question yet.
11:09:40 <glguy_> instance MonadState (Reader IORef), perhaps this is closer to: instance MonadIO m => MonadState a (ReaderT (IORef a) m) ?
11:10:05 <dmwit> glguy_: Yes, something like that.
11:10:25 <donri> yeah that's what i meant with my lazy pseudo code :)
11:10:57 <donri> dmwit: i admit i don't actually know if there are such laws for the state monad... it just "feels" wrong :D
11:11:13 <donri> i'd expect if i "put" something, I "get" the same thing back
11:11:19 <dmwit> ah
11:11:26 <donri> but if you writeIORef from the outside that doesn't work any more
11:11:49 <dmwit> Even so, this law would be satisfied assuming there was only one thread (as there usually is in simple gtk apps).
11:11:50 * glguy_ suspects that the laws for MonadState are that they satisfy the type signature
11:12:13 <edwardk> glguy_: i would disagree
11:12:21 <edwardk> the you get back what you put is pretty fundamental to state
11:12:27 <glguy_> Great, let's document this
11:12:34 <glguy_> and add it to the class
11:12:44 <edwardk> its the same general set of laws as for store
11:13:05 <edwardk> all existing instances comply with the common sense laws
11:13:18 <glguy_> It's no good to have laws if they only exist in IRC logs
11:13:42 <monochrom> some laws don't even exist in IRC logs :)
11:13:47 <dmwit> edwardk: But I want my MonadState s (ReaderT (MVar s) m) instance. =(
11:15:04 <glguy_> and if we don't add them to the actual documentation they are just "good ideas"
11:15:44 <edwardk> i'm surprised they aren't in the docs actually
11:15:55 <liyang> :r
11:16:10 <glguy_> http://hackage.haskell.org/packages/archive/mtl/2.1.2/doc/html/Control-Monad-State-Lazy.html
11:16:24 <edwardk> yeah
11:16:28 <edwardk> i believe that they aren't there
11:16:34 <edwardk> adding an issue to remind myself to create them
11:16:44 <glguy_> I would have believed they were somewhere else is why I pasted that
11:16:55 <glguy_> just saying that link was why I thought they weren't laws
11:17:27 <edwardk> https://github.com/ekmett/mtl/issues/5
11:18:17 <hpaste> liyang pasted “MonadState r (ReaderT (IORef r) m)” at http://hpaste.org/84769
11:18:25 <alexander__b> findIndices (`elem` ['A'..'Z']) "Find the Caps!" -- how do I need to structure this code to use elem without infix?
11:19:05 <byorgey> alexander__b: you could write  (\c -> elem c ['A'..'Z'])
11:19:19 <byorgey> or  (flip elem ['A'..'Z'])
11:19:31 <edwardk> fwiw: when i can convince myself nobody else will edit my IORef but me, i've been known to make state-like monads out of things build on IO with an IORef
11:19:39 <alexander__b> byorgey: ah. thanks.
11:19:43 <edwardk> but not to put that horrible flexible instance in ;)
11:20:16 <donri> edwardk: but is it even useful if you can't really use it as an ioref anyway?
11:20:24 <merijn> I've been known to gleefully abuse "unsafePerformIO $ newMVar" at the top level, because I <3 state :p
11:20:29 <donri> is there a performance gain or something
11:20:29 <monochrom> I recommend http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.2560 for laws for MonadState etc. it states what you're already stating sure; my point is how to do it formally
11:20:39 <edwardk> donri: it can make a big performance difference
11:20:44 <edwardk> because you aren't constantly tupling
11:20:44 <donri> aha
11:21:08 <monochrom> of course, you could say, you don't want to do it formally
11:21:15 <edwardk> IORef b -> IO a     doesn't require you to keep making up and tearing down tuples
11:21:18 <donri> tight tupling is the performance version of tight coupling?
11:21:37 <luite> it does make (# #) tuples all the time though ;)
11:22:43 <edwardk> monochrom: I added those to the ticket
11:22:57 <edwardk> monochrom: they match what i'd expect
11:23:06 <donri> perhaps then we should have a package with a newtype for this with the constructor private
11:23:07 <monochrom> neato
11:23:27 <edwardk> luite: yeah but those are all but free =P
11:25:07 <alexander__b> zipWith3 (\x y z -> x + y + z) [1..3] [4..6] [7..9] -- is this possible to rewrite similar to sum' = foldr (+) 0 ?
11:25:15 <donri> if the ioref is hidden we could even unsafePerformIO safely?
11:25:42 <donri> or not? concurrency? :x
11:26:06 <liyang> donri: there's no guarantee that the underlying monad (assuming you're writing an IOStateT) runs things in sequence.
11:26:22 <donri> ah right
11:26:29 <dmwit> alexander__b: yep:
11:26:40 <dmwit> > map sum . transpose $ [[1..3], [4..6], [7..9]]
11:26:41 <lambdabot>   [12,15,18]
11:26:59 <alexander__b> dmwit: well... yes
11:27:06 <alexander__b> dmwit: but I meant more in general
11:27:24 <dmwit> The answer is still yes, but it's also: Oleg did it.
11:27:39 <donri> @faq Can Oleg do it?
11:27:40 <lambdabot> The answer is: Yes! Haskell can do that.
11:27:47 <dmwit> http://www.okmij.org/ftp/Haskell/zip-folds.lhs
11:27:50 <dmwit> I think
11:29:16 <ab9rf> oleg == haskell?
11:29:47 <dmwit> affirmative, Oleg == Haskell
11:30:07 <ab9rf> excellent
11:30:12 <donri> Iso' Oleg Haskell
11:31:15 <johnw> hmm.. but Should Oleg do it?
11:33:42 <mami> just having a discussion with a friend
11:34:05 <mami> his feeling is, that if you write good, well reviewed c code you can get it to be more secure than haskell
11:34:23 <ChongLi> mami: that's pretty silly
11:34:23 <mami> because with haskell you are just trusting the compiler to do the magic right
11:34:30 <sproingie> ahahaha
11:34:38 <sproingie> he's audited his C compiler line by line has he?
11:34:40 <mami> what is to say about the security review status compared to e.g. gcc?
11:34:48 <Taneb> Good, well reviewed C code will almost certainly be better than sloppy Haskell
11:34:55 <sproingie> you could argue with him, but what's the point?
11:34:56 <mami> sproingie: nope, but gcc has a much wider userbase
11:35:02 <edwardk> @remember dolio If you roll it back, though, you'll be the only person to ever use liftM7.
11:35:03 <lambdabot> I will never forget.
11:35:32 <mami> Taneb: well, lets say we have good, well reviewed c and good well reviewed haskell
11:35:52 <mami> we have a much bigger complexity in the compiler with haskell, but more complexity in the code with c
11:36:06 <alexander__b> dmwit: gcc is pretty complex, man
11:36:06 <mami> it probably does not much matter in the end?
11:36:12 <ChongLi> GHC is more complex than GCC?
11:36:13 <sproingie> watch for the moving goalposts on "good, well reviewed"
11:36:19 <alexander__b> sorry not dmwit. IDK how that got tab completed. :-)
11:36:20 <dmwit> alexander__b: Why are you telling me?
11:36:20 <ChongLi> that's news to me
11:36:24 <dmwit> ok =)
11:36:25 <mami> ChongLi: idk
11:36:25 <gspr> If I have a function that really needs Data.Vector.Storable.Vector, is it customary to provide an interface for any Data.Vector.Generic.Vector? Moreover, is convert :: (Vector v a, Vector w a) => v a -> w a   a no-op when v = w?
11:36:29 <mami> its just a gut feeling
11:36:35 <mami> did anyone ever research this?
11:36:38 <alexander__b> mami: I would guess it's the opposite
11:36:43 <edwardk> mami: arguably the compiler is the better place to concentrate the complications, because it can then get more eyeballs and more scenarios tested.
11:36:49 <ChongLi> GHC is written in Haskell
11:36:54 <ChongLi> making it easier to verify :)
11:37:08 <dmwit> What is this "testing" nonsense? Use CompCert and be done with that. ;-)
11:37:11 <mami> what was used to compile the first ghc?
11:37:18 <edwardk> mami: libraries written in languages with poor guarantees are great places for all sorts of crap code and bugs to hide. fewer eyeballs.
11:37:19 <sproingie> ghc of course
11:37:22 <monochrom> you need to see this regarding gcc: https://plus.google.com/102208456519922110915/posts/DZsZ6mvA4T6
11:37:23 <mami> reflections on trusting trust an such
11:37:48 <dmwit> mami: I wonder, has your friend heard of the Underhanded C Contest?
11:37:53 <dmwit> (Have you?)
11:38:18 <edwardk> mami: if you go back far enough for first working haskell compiler was written in LML by Lennart Augustsson.. the same guy who designed LML ;)
11:38:19 <ChongLi> or the ioccc
11:38:21 <ChongLi> I love that one
11:38:34 <dmwit> IOCCC is irrelevant because the winners are code that was never designed to pass inspection.
11:38:45 <ChongLi> http://www.ioccc.org/2012/deckmyn/deckmyn.c
11:38:49 <dmwit> UCC is devastating because the code is all transparent, well-written C that *does the wrong thing*.
11:38:57 <orzo> hi
11:39:02 <ChongLi> get your friend to do a security audit on that!
11:39:10 <edwardk> Now, it wouldn't surprise me to find out that Lennart stacked some hack in the earliest haskell compiler just to screw with us. He _has_ won the IOCCC at least 2-3 times and it'd be quite the coup.
11:39:12 <edwardk> =)
11:39:20 <orzo> I want to get some help working out an algorithm, is there a good irc channel for that?
11:40:00 <dockside1> You say that like it is an achievement
11:40:00 <dolio> 'C can be better/safer/etc. than Haskell if you have an unlimited budget of time and money to spend on the C, and not on the Haskell.'
11:40:00 <dolio> Whoop de doo.
11:40:25 <johnw> dolio: where is that quote from?
11:40:57 <sipa> dolio: or if you know C really well already, and don't know haskell at all?
11:41:03 <ChongLi> it's silly to make inductions about hypothetical scenarios comparing languages
11:41:06 <dolio> It's a paraphrasing of the argument people usually make in favor of C.
11:41:19 <mami> dmwit: yeah obfuscating and underhandind misses the point ;)
11:41:22 <sproingie> my favorite ioccc program was one that calculated pi based the ascii art circle that the source code was formed into
11:41:24 <ChongLi> better off looking at real world examples
11:41:26 <johnw> dolio: I could say the same thing about writing binary code by hand
11:41:32 <sproingie> it had a comment: "to get more precision, write a bigger program"
11:41:51 <ChongLi> Xmonad is one great example
11:42:14 <dolio> johnw: Yeah, it used to be used in favor of assembly over C.
11:42:15 <johnw> in fact, give me an unlimited budget and I'll write code by raising goats or sheep, depending on whether I need a 1 or a 0.  In time, I will get it done.
11:42:33 <lightquake> mami: i agree obfuscated does, but I don't think underhanded does
11:42:34 <orzo> I have a BSP tree representing a coloring of ℝⁿ with the set X and I want to reduce the dimension to generate a BSP tree that colors ℝⁿ⁻¹ with [X] where each color in the reduced tree is a list of colors ordered by their original position in the non-reduced tree.
11:42:46 <dmwit> mami: I disagree. Obfuscated code misses the point; underhanded code does not.
11:43:15 <mami> dmwit: sorry, mixed that up
11:43:19 <mami> i see your point
11:43:24 <mami> another question
11:43:39 <mami> how hard is it to correlate the haskell function to the machine code?
11:43:48 <ChongLi> depends on the function!
11:43:50 <ChongLi> next!
11:43:51 <dockside1> does it matter?
11:43:59 <mami> with c its pretty easy to just look at the intermediate assembly and find your function
11:44:15 <mami> dockside1: in case you want to audit what your compiler did, yes
11:44:15 <mcstar> easy with haskell too
11:44:21 <mcstar> you look at core, and see the function
11:44:22 <dockside1> Either you accept that you are writing high level code, or pick some macro assembler like C
11:44:26 <sproingie> probably not too hard for core.  for haskell source, probably harder, but the debugger manages.
11:44:31 <orzo> buggers
11:44:41 <mami> mcstar: how would i proceed there
11:44:43 <mami> ah k
11:44:50 <mcstar> ghc can dump core
11:44:53 <sproingie> do you trust 100% every optimization your C compiler does?
11:44:56 <mami> nope
11:44:57 <mcstar> there is even a highlighter for it
11:44:58 <dockside1> I don't  want that
11:45:05 <mami> this is all about gut feelings in the end
11:45:08 <dockside1> I want my compiler to optimize the AST
11:45:10 <dmwit> sproingie: Depends. Which C compiler is "mine"?
11:45:17 <mami> since we do not have anything with completely proven properties
11:45:18 <dmwit> sproingie: I trust 100% every optimization that CompCert does.
11:45:26 <mami> in the end the bare metal screws everything up
11:45:29 <sproingie> mami: yes it is.  which is probably why it's pointless to have the argument
11:45:29 <monochrom> I am all about denouncing gut feeling.
11:45:36 <mami> sproingie: i think so too
11:45:54 <mami> just needed some ammunition against it ;)
11:45:58 <glguy_> dmwit: because you've already reviewed the model of the hardware they run on?
11:46:42 <edwardk> mami: after a good c compiler has done its work, i'd argue that the control flow can be pretty obfuscated relative to the original source code
11:46:45 <dmwit> I don't need to trust the stages after the compiler to trust the compiler. =)
11:47:37 <thoughtpolice> glguy_: hardware models don't have so much to do with compcert's optimizations being semantics-preserving, although the processor can certainly screw up later
11:48:00 <edwardk> after multiple rounds of strength reduction, loop unrolling, smashing things together into simd opcodes, shuffling code around to make it not branch, etc. it usually bears little resemblance to the input. gcc often looks a lot like the output, but, well, thats gcc. ;)
11:48:27 <dockside1> don't forget inlining
11:48:35 <thoughtpolice> edwardk: locality rearrangements really mess things up more than anything, especially combined with inlining
11:48:40 <glguy_> thoughtpolice: I don't know much about how compcert actually works, I'm just thinking that the semantics-preservation is only as good as those semantics map to the actual environment the program runs on
11:48:45 <edwardk> that too
11:48:45 <thoughtpolice> at least IMO after deubgging some of the GHC runtime recently
11:50:17 <doomlord> in gamedev it was very common to check what the compiler was outputting when optimizing
11:50:34 <doomlord> nevermind GCC, microsoft tools struggled too
11:50:43 <sproingie> that's more to do with "is this busting the cache" than "is this producing correct code"
11:51:10 <doomlord> oh youre all talking about correctness rather than optimality
11:51:38 <glguy_> thoughtpolice: And wasn't it the case that the frontend wasn't verified, so while the semantics are being preserved they aren't necessarily the ones you asked for in the first place?
11:53:14 <thoughtpolice> glguy_: there were some bugs in the parser originally, which was written in ocaml. i think something like 10 bugs
11:53:37 <thoughtpolice> now, they actually have a parser written in Coq too i think. i don't think any other semantics-violating bugs have been found
11:54:08 <glguy_> ah cool, (and for the record I'm only balking at the 100% trust aspect)
11:54:58 <thoughtpolice> oh sure, i'd agree, but verified compilers are a nice move forward :) 10 years ago people would have probably thought it impossible, so it's always exciting to see stuff like CompCert
11:59:21 <cschneid> what is Coq? proof system, but is it a totally different language, or a haskell thing?
11:59:34 <ChongLi> totally different language
11:59:51 <cschneid> related in any way?
12:00:11 <ChongLi> it's related in that it's statically typed, strongly typed, functional
12:00:50 <ChongLi> it's also dependently typed, unlike Haskell
12:01:02 <seliopou> coq is great
12:01:21 <armlesshobo> i luv the Coq
12:01:22 <armlesshobo> teehee
12:01:57 <seliopou> and yes, it's dependently typed, and allows you to define and pass around propositions, and prove theorems about your programs
12:02:15 <cschneid> hmm, I'm sure that means something, but I'll stick with learning haskell first.
12:02:17 <cschneid> :)
12:02:24 <seliopou> haha, yeah it wasn't a great explanation either
12:03:11 <seliopou> do you know what it means for a language to be dependently typed?
12:03:20 <m_hyperbolic> Why isn't it possible to do : 1 + $ 2 + 3 but you have to to 1 + (2 +3) ? I understood $ to mean something like "Do the right side of this first" but maybe I'm wrong ?
12:03:42 <cschneid> seliopou: not a clue! And it sounds like something that would take up space in my head, and not be what I need right now.
12:04:01 <seliopou> everybody needs some dependent types in their lives
12:04:11 <edwardk> cschneid: it is much more verbose than haskell and feels rather ML'ish, but you can say more powerful things in it, so it is a trade-off. Coq is more about proving stuff than executing code. When you're done with a coq program you've usually proven something about a given domain. You rarely (unless your name is Adam Chlipala) actually run the resulting code though.
12:04:11 <aCube> > (1+) $  2 + 3
12:04:12 <lambdabot>   6
12:04:18 <seliopou> it just means that a type can depend on a value
12:04:26 <aCube> > (1+) $  2 + 3 -- m_hyperbolic
12:04:28 <lambdabot>   6
12:04:55 <cschneid> edwardk: right, proof system. Didn't it have some method to export resulting validated code to other lanugages (like haskell)
12:05:02 <edwardk> cschneid: There is a similar language with a more Haskellish feel called 'Agda', which is probably an easier thing to transition to from Haskell. There are reasons to understand both. Coq is more mature and has a bigger ecosystem around it
12:05:13 <edwardk> Agda is where the cool kids are, and is pleasant to use
12:05:13 <seliopou> So you could have a list type that takes a number that represents, say the length of the list
12:05:23 <seliopou> and then only lists with that length would have that type, for example
12:05:32 <cschneid> edwardk: honestly, I'm a software dev, not a research guy - so the right place to be is "making shit that works in haskell".  Mostly just curious around that
12:05:44 <tac> edwardk: The cool kids stopped using Agda last month. Now it's Idris ;D
12:05:56 <edwardk> cschneid: I'm somewhere in the middle, but yes, I like just making things that work. ;)
12:06:03 <seliopou> tac: the actor?
12:06:10 <m_hyperbolic> So the problem was the '+' not being applied correctly ?
12:06:11 <edwardk> hence why i code in haskell and not agda/idris/coq ;)
12:06:23 <cschneid> edwardk: it's been really interesting seeing how different the general feel of programming haskell has been from Ruby. Both get things done, but in such totally different manners
12:06:40 <cschneid> haskell function reuse is amazingly easy, but at least for me, getting the right function in the first place has been tricky
12:06:49 <edwardk> tac: I find that Haskell causes me to think almost entirely bottom up and just have faith that I'll get the right abstraction in the end
12:07:13 <edwardk> Nicely it has rewarded that behavior consistently enough that I can just trust in it to lead me to the right abstractions
12:07:37 <edwardk> It is hard to quantify that feeling of gentle guidance to an outsider
12:07:54 <cschneid> edwardk: do you mean bottom as "simple conversion functions and combinations" and then haskell continues pushing you toward the toplevel `calculateTheWorld` function
12:08:04 <quchen> ARGH! Could not deduce (Functor m) arising from a use of `void' from the context (MonadIO m)
12:08:09 <quchen> Where can I sign up for a lobby
12:08:15 <ChongLi> edwardk: I think one of the best ways to get that feeling is to just start hacking on some existing haskell code
12:08:35 <edwardk> cschneid: yes. i tend to start by just putting together little abstractions and soon enough i have something that can launch missiles.
12:08:41 <ChongLi> and see how the types generally force you to do the right thing
12:08:59 <edwardk> But if I start thinking about it from the missile design goal perspective in a top down oriented fashion the Haskell that results is inevitably crap
12:09:23 <ChongLi> top down design is crap in general
12:09:25 <cschneid> So, more general question: what testing framework should I be using to convince myself that functions work? So far I've been using 'eyeball the results', but something like hunit or quickcheck seem important to convince myself repeatedly that I didn't screw up
12:09:55 <edwardk> I use doctest a lot. hunit and quickcheck are good, but they are terrible at the kind of code i like to write which is heavily polymorphic
12:10:24 <edwardk> I wind up building a lot of scaffolding there
12:10:39 <cschneid> hmm, I've been writing extremely concrete code.  Does polymorphic code just expand out from better knowledge of the language and wanting to make nice APIs to your code?
12:10:52 <ChongLi> remember that testing doesn't tell you that there are no bugs
12:10:54 <edwardk> Are you familiar with the idea of a free theorem?
12:10:59 <ChongLi> only that your tests passed
12:11:11 <ChongLi> (or failed)
12:12:33 <edwardk> free theorems are little laws given to you by your type signatures. In essence every time you typecheck the compiler is proving these little theorems for you about your code. Think of them as laws you'd have to really screw up to break ;)
12:12:51 <edwardk> When your type signatures are more polymorphic there are fewer bad programs you can write that have those types
12:12:58 <edwardk> @djinn a -> b -> a
12:12:59 <lambdabot> f a _ = a
12:13:13 <edwardk> that is the only sane program with that type
12:13:20 <edwardk> on the other hand contrast that with Int -> Int -> Int
12:13:26 <hpaste> luisgabriel pasted “Data.Array error” at http://hpaste.org/84775
12:13:27 <edwardk> there are _lots_ of perfectly valid programs with that type
12:13:34 <cschneid> right. Int->Int->Int do lots of stuff. I have a few functions like that.
12:13:37 <edwardk> (i am ignoring blatant _|_'s here)
12:13:55 <sproingie> "blatant bottoms" sounds like a good band name
12:13:55 <cschneid> so you're general "feels right" idea is to make as few degrees of freedom for the actual implementation as possible?
12:13:56 <johnw> f a b = f a b
12:14:04 <edwardk> so if you can make the signature of your code polymorphic the compiler can do more to help you.
12:14:06 <johnw> that's a failing but valid definition for your function
12:14:09 <hpaste> luisgabriel pasted “Data.Array error” at http://hpaste.org/84776
12:14:15 <edwardk> johnw: blatant _|_ though
12:14:19 <johnw> true
12:14:33 <sproingie> @pl f a b = f a b
12:14:33 <lambdabot> f = fix id
12:14:33 <monochrom> polymorphic functions enjoy simple tests. "f :: a->a" can be tested by "f () == ()". parametericity extends this to all other types.
12:14:34 <S11001001> const a _ = factor 3910753893 `seq` a
12:14:39 <sproingie> nifty
12:14:45 <edwardk> cschneid: yes.
12:15:08 <edwardk> the more polymorphic your type signatures, the fewer valid programs can match them, so if you type one in and it typechecks the more likely it is to be correct ;)
12:15:11 <cschneid> edwardk: I like that idea. It's been weird trying to get a feel for code that does more than just work, but instead what the ideas around style and best practices
12:15:42 <monochrom> another example: if "g :: a -> [a]" and g () = [(), ()], then you also know g 5 = [5, 5]
12:15:45 <S11001001> constant factor
12:15:56 <edwardk> cschneid: i write some incredibly generic code with type signatures that without the free theorems to help me reason about them, i wouldn't be smart enough to write
12:16:15 <ChongLi> cschneid: if you get some time you may want to check out this talk:
12:16:17 <ChongLi> http://skillsmatter.com/podcast/home/keynote-3842/mh-6793
12:16:21 <edwardk> @type taking
12:16:22 <lambdabot> (Applicative f, Conjoined p) => Int -> Over p (Control.Lens.Internal.Bazaar.BazaarT p f a a) s t a a -> Over p f s t a a
12:16:29 <S11001001> @quote generic
12:16:30 <lambdabot> ghc says: More than one type pattern for a single generic type constructor
12:16:41 <cschneid> edwardk: do you have any open source I can look at?
12:16:47 <edwardk> if i went and replaced all those types with the moral equivalent of Int, i'd never have been able to write that function
12:17:06 <edwardk> cshneid: a few repositories: github.com/ekmett and github.com/analytics
12:17:08 <ChongLi> SPJ's enthusiasm for types is infectious!
12:19:45 <edwardk> cschneid: you can see a pretty long laundry list of build bot messages scroll by on #haskell-lens for them ;)
12:19:58 <cschneid> ok, I need to figure out custom types I think. That's my next big brick. (instance / class keywords)
12:21:43 <luisgabriel> I don't know why I'm getting the error "array (48,122) [(48,fromList *** Exception: (Array.!): undefined array element" for this code: http://hpaste.org/84778. Can anyone help me?
12:22:18 <cschneid> edwardk: for types, what should I go read? (ie, first the syntax of instance & such, then a reasonable tutorial/demo usage so I can get a feel for the why/when questions (as opposed to just how)
12:22:52 <edwardk> cschneid: have you read learn you a haskell or real world haskell?
12:23:05 <edwardk> both are good references to get started from
12:23:11 <cschneid> I have the books, but have gotten bogged down in reading them rather than doing. I figure I can go dive into the relevant sections
12:23:11 <johnw> cschneid: I don't recommend starting out by reading edwardk code
12:23:17 <cschneid> rather than reading them cover-to-cover
12:23:21 <int-e> luisgabriel: it means that the entry at index 48 was never defined.
12:23:25 <byorgey> luisgabriel: because that IMap has only one entry, so when you construct the array, only index 50 gets initialized
12:23:31 <luite> luisgabriel: print the IMap assocs first, no association for 49 probably
12:23:39 <edwardk> RWH moreso with prior programming experience, LYAH is more gradual, but may be frustratingly slow at points.
12:23:58 <byorgey> luite: the IMap assocs are listed in the line above, there is only one! =)
12:24:05 <luite> oh you're right
12:24:06 <cschneid> I have a paper copy of RWH, I wonder where I put that...
12:24:09 <luite> and i meant 48 not 49 :)
12:24:15 <edwardk> I find it is generally safer to just go cover to cover, since very little works in haskell like you'd expect from other languages
12:24:22 <carter> yeah
12:24:24 <monochrom> eventually you will find that 49 is bad too
12:24:25 <edwardk> at least with something like LYAH
12:24:42 <edwardk> RWH has some problems with using things out of order, etc. that make the cover to cover story a harder sell there
12:24:58 <cschneid> edwardk: it's been cool to dive in with enough knowledge to read in input, do calcs and see output. Now I'm wanting to expand outward from that core of working code.
12:24:58 <carter> thats a more tractible starting point than edwardk's voluminous set of handy pacakges
12:25:07 <cschneid> I've just gotten bogged down in the books before
12:25:12 <edwardk> yeah
12:25:31 <monochrom> I recommend: start humble and start LYAH
12:25:39 <edwardk> my recommendation is to actualy set up the REPL and do all the fiddly little coding exercises as they come up in the book and riff on them as you go to learn more
12:26:01 <edwardk> its easy to fool yourself into thinking you understand when just skimming the books
12:26:09 <luisgabriel> int-e, byorgey, luite: got it. thanks ;)
12:26:13 <edwardk> but the REPL is a harsh mistress
12:26:26 <carter> and it gives you immediate feedback
12:26:34 <carter> and science indicates that doing things
12:26:38 <carter> and getting immediate feedback
12:26:40 <carter> is the best way to learn
12:26:48 <int-e> @type accumArray (const id)
12:26:48 <monochrom> I overestimate the number of people who know to perform more experiments
12:26:49 <lambdabot> Ix i => e -> (i, i) -> [(i, e)] -> Array i e
12:27:01 <carter> monochrom i don't experiment enough
12:27:28 <carter> but edwardk's pushing me towards the experiment always approach from repeated exposure to watching the commit stream of his code :)
12:27:32 <int-e> luisgabriel: that's one way to get an array with default entries if you want them
12:27:53 <monochrom> I assume that people automatically invent and do experiments, because that's what I do. but apparently, people prefer to assume. (oh, the irony!)
12:28:31 <cschneid> I have certainly been experimenting.  Yeah, I'll have to give RWH another go. I bet it answers most the questions I've been using this channel for
12:28:38 <cschneid> (ya'll are amazing by the way... super awesome)
12:29:04 <ChongLi> this channel is like a REPL for english!
12:29:09 <edwardk> cschneid: the min reason i stuck around in #haskell was because of the community. The fact that the language is also amazing was a nice perk
12:29:19 <edwardk> er main
12:29:40 <carter> tropical rings edwardk ?
12:29:56 <edwardk> carter: what do you need to know?
12:30:03 <carter> i was riffing on the min reason
12:30:04 <carter> :)
12:30:08 <edwardk> ah =)
12:30:14 <edwardk> well, its a definite (+) =)
12:30:25 <carter> we do have good engineering weather in haskell land
12:30:40 <carter> unlike the languages near artic circles
12:30:40 <johnw> edwardk: I was at the London haskell user's group last night, and the presentation reminded me of one of your library
12:30:48 <edwardk> oh?
12:30:58 <johnw> there were cata, ana, histo, zygo and futu morphisms :)
12:31:04 <edwardk> oh
12:31:06 <edwardk> bah =P
12:31:14 <johnw> oh, and para of course
12:31:24 <edwardk> and 50 slides later they made it through fib?
12:31:25 <johnw> no prepromorphisms though!
12:31:25 <HugoDaniel> i like the school of haskell website
12:31:31 <edwardk> or was it factorial
12:31:33 <HugoDaniel> its possible to run examples and change them :)
12:31:33 <ChongLi> no hylomorphisms?
12:31:41 <johnw> edwardk: haha, that was about 30 slides in I think :)
12:31:54 <johnw> it was all about using fixed points of functors to generalize folds and unflods
12:31:58 <edwardk> let me guess functional treesort/pseudo-quicksort ;)
12:32:32 <ChongLi> Erik Meijer is quitting microsoft!
12:32:34 <edwardk> the treesort/quicksort example would be the stock hylo example
12:32:45 <luisgabriel> int-e: I'm using deepseq to force the evaluation of an array in a separate thread, I think I can't do that if I contruct the array using the array function, right?
12:32:45 <edwardk> ChongLi: wow
12:32:51 <cschneid> ok, the last 15 lines of scrollback or so is what terrifies me about haskell still.  How much does the mathy research side come into play to just make cool stuff?
12:32:58 <johnw> ChongLi: oh, there was hylo
12:33:05 <cschneid> I don't mind undergrad level CS... but.... :)
12:33:07 <johnw> and apo-
12:33:19 <ChongLi> I'll really miss all his great C9 vids
12:33:29 <ChongLi> he has a great rapport with Charles
12:33:32 <Ralith> performance advice!
12:33:33 <johnw> and he distinguished between Fix and Cofix, recursion and corecursion
12:33:44 <edwardk> cschneid: the hylo/etc. stuff is a bit of a disease. ;)
12:34:05 <johnw> it was a nice presentation, actually, but I still need to develop a keener sense of when such an approach would be *the* killer approach to a problem
12:34:28 <mcstar> ChongLi: where will he work now?
12:34:33 <edwardk> cschneid: i personally do not find it all that useful. At one point I used to think there was a lot of deep fundamental stuff there, but it turned out to be a couple of 'fundamental' bits of math, and a bunch of abuses of the same kind of distributive law.
12:34:41 <monochrom> johnw: is that Ralf Hinze's work and "just use a suitable left-adjoint functor" (right-adjoint if you're doing cofix)?
12:34:41 <Ralith> I have an AST walker that first tags certain (frequent, widely distributed) AST nodes with names and generates some constraints on those names, then solves the constraints, then replaces the names based on the constraint solution.
12:34:44 <edwardk> johnw: the trick is it never is
12:34:46 <ChongLi> mcstar: he's going back to academia
12:34:51 <int-e> luisgabriel: well, 'array' is really primarily for the case where you actually initialise all elements of the array. so 'no' to the question as asked
12:35:03 <johnw> Barclay's is apparently using them to good effect to reduce boilerplate
12:35:13 <int-e> luisgabriel: but in your case, yes, deepseq on that array with undeefined entries is going to fail.
12:35:14 <edwardk> johnw: spotting that something is a fold is very useful. spotting the rest is less so
12:35:18 <johnw> and it makes the recursion "scheme" apparent, they said, which helps reasoning
12:35:20 <Ralith> Should I use STRefs to be able to get the solution data to the names in-place, or is an IntMap from names (Ints) to solved value Good Enough?
12:35:37 <johnw> oh, but the best part
12:35:49 <edwardk> i buy it when the scheme is cata/fold.
12:35:49 <johnw> he had the best presentation on implementing foldl in terms of foldr that I've yet seen
12:36:10 <johnw> it's a "catamorphism that builds a function"
12:36:15 <Ralith> the effect being making the final AST walk linear (just a read from the STRefs annotating the AST nodes) or superlinear (an IntMap lookup)
12:36:21 * int-e thinks this discussion is heading towards fusion or co(n)fusion.
12:37:45 <luisgabriel> int-e: yes, in my case I don't have the guarantee that all elements will be initialized ;/
12:37:52 <ChongLi> deforestation!
12:38:26 <edwardk> johnw: yes. this is the part of it i like =)
12:38:38 <cschneid> yeah, question: what's 'list fusion' in some of the docs?  I assume that means intermediate lists won't get created when you ask for the answer
12:38:42 * fizbin needs an HXT channel.
12:39:09 <edwardk> johnw: the problem is when you start talking about generalized catamorphisms and are mixing in arbitrary comonads with distributive laws, its all the same thing, but you're cheating to fmap over the base functor to distribute anyways
12:39:18 <ChongLi> http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf
12:39:24 <ChongLi> relevant to both topics!
12:39:50 <monochrom> yes cschneid
12:40:21 <edwardk> cschneid: http://www.haskell.org/haskellwiki/Correctness_of_short_cut_fusion
12:40:45 <johnw> fusion is a very cool thing
12:41:08 <edwardk> cschneid: there are several forms of 'fusion' one can use. one is inspired by all this cata/fold stuff: cata-fusion, hylo-fusion, etc.    and then there is foldr/build fusion   and there is also destroy/unfoldr fusion.
12:41:16 <edwardk> the latter two are the most interesting from a pragmatic engineering perspective
12:41:25 <wouters> I have a SmallCheck question: suppose I have a test of the form 'exists $ \x -> px' -- is there a way to get SmallCheck to print the x for which the test passes?
12:41:38 <edwardk> because unfortunately converting to a form that permits hylo fusion is a big messy problem
12:41:52 <edwardk> and moreover once you have hylo you can do anything, so its already 'too big' in a deep fundamental sense
12:42:18 <cschneid> edwardk: I think we're working at different levels here :)
12:42:22 <edwardk> foldr/build fusion is pretty simple though
12:42:23 <edwardk> :t foldr
12:42:25 <lambdabot> (a -> b -> b) -> b -> [a] -> b
12:42:33 <johnw> cschneid: lol
12:42:37 <johnw> cschneid: don't I know exactly how you feel :)
12:42:40 <edwardk> build :: (forall b. (a -> b -> b) -> b -> b) -> [a]
12:42:54 <edwardk> then gives you: foldr c n (build g) = g c n
12:42:57 <johnw> I think edwardk forgets that people don't know things sometimes ;)
12:43:13 <edwardk> if you look at the signature there
12:43:31 * cschneid is years out of a pretty terrible undergrad CS program. I can program, but man, technicalities and math are just stuff I don't know
12:43:34 <edwardk> foldr is saying how to replace (:) and [] in a list with a function and a value respectively. and get a new answer
12:43:45 <johnw> but what's he saying about fusion is that some function applications can cancel each other out
12:43:54 <johnw> in this case, foldr and build can cancel out
12:44:00 <johnw> and unfoldr and destroy can cancel out
12:44:20 <edwardk> build is saying that if you give me something that knows how to build up a structure with any pair of those kinds of functions, I can give you back a list.
12:44:32 <cschneid> edwardk: that's a cool way to look at foldr. Obvious but haven't heard it stated that way
12:44:34 <edwardk> foldr build fusion then makes that intermediate list go away
12:44:53 <edwardk> by just handing the function you gave to build the foldr args directly
12:44:56 <cschneid> edwardk: cool.  As far as I'm concerned for now, it's magic that the compiler does?
12:45:04 <johnw> not the compiler
12:45:05 <cschneid> later on I may need to tweak code to let the compiler do its work
12:45:08 <johnw> the library writer
12:45:09 <luisgabriel> int-e: worked fine with accumArray. thanks!
12:45:12 <cschneid> ahh, I see
12:45:16 <edwardk> well, it turns out there are two styles of fusion you can use. foldr/build and destroy/unfoldr
12:45:19 <cschneid> same diff. For now I don't need to worry about it?
12:45:35 <johnw> GHC supports "rewrite rules", which can rewrite recurring patterns as taught to it by the library writer
12:45:47 <edwardk> you have to pick one, because the rewrite rules that the compiler can use to convert your code into a suitable form have to make decisions between one and the other that kind of make the other go in the wrong direction
12:45:50 <johnw> cschneid: you don't need to worry about this for a while yet
12:46:28 <edwardk> cschneid: the short answer is the compiler has some rewrite rules given to it by the authors of the standard library that let it take your code and turn it into equivalent faster code using this machinery
12:47:00 <edwardk> cschneid: the compiler itself just has hooks for the rewrite rules, this is all just enabled by library code with those rules in it
12:47:06 <cschneid> cool.  The pureness of haskell opening up options for the compiler/library writers is interesting.  Somebody give me a bunch of money to go to grad school plz.
12:47:22 <edwardk> Data.Vector, etc. use a form of 'destroy/unfoldr' fusion. the Prelude uses a limited form of foldr/build fusion.
12:47:23 <monochrom> some grad schools give you that money
12:47:51 <edwardk> It is important to note that neither are 'hylo-fusion', because that is crap ;)
12:48:07 <monochrom> in Canada, two levels of government also give you that money, but you have to perform well first
12:48:20 <edwardk> (actually it'd be kinda neat if it did work, its just the kind of thing you can't optimize well)
12:48:52 <andrewsw> edwardk: the type you've given for builder confuses me.
12:48:55 <cschneid> monochrom: none of them make up for opportunity costs though :)
12:49:12 <edwardk> http://metagraph.org/papers/stream_fusion.pdf talks about the form of destroy/unfoldr fusion
12:49:15 <edwardk> andrewsw: its a rank2 type
12:49:52 <andrewsw> I read it as "given a function that looks like fold, I'll return a list of arbitrary type"
12:50:06 <andrewsw> okay, not quite arbitrary.
12:50:08 <edwardk> andrewsw: notice the forall b.
12:50:16 <edwardk> build :: (forall b. (a -> b -> b) -> b -> b) -> [a]
12:50:23 <edwardk> you have to give me a function that doesn't care what b i give it
12:50:30 <monochrom> the "a" in [a] is the same "a" in (forall b. (a -> b -> b) -> b -> b)
12:50:34 <edwardk> so i could choose to give it (:) and [] by choosing b = [a]
12:50:44 <andrewsw> hmm...
12:51:02 <edwardk> then (:) :: a -> [a] -> [a]    and [] :: [a]  are perfectly good args
12:51:17 <edwardk> build f = f (:) []
12:51:20 <monochrom> you could say, (forall b. (a -> b -> b) -> b -> b) is an encoding of a list, and build decodes it back to a list
12:51:37 <andrewsw> okay, I think I follow. it's been a while.
12:51:49 <edwardk> the arg to build is a sort of cps transformed list. that will build something list like using the user supplied functions
12:52:05 <trolling> @pl \f -> f (:) []
12:52:05 <lambdabot> flip ($ (:)) []
12:52:34 <edwardk> build (\cons nil -> cons 1 nil)  -- represents the 'virtual' list [1]
12:52:47 <johnw> edwardk: are you just talking about DLists?
12:52:48 <andrewsw> I recognize the list encoded in (a -> b -> b) -> b -> b
12:53:10 <andrewsw> alright , let me stew on it a while.
12:53:11 <edwardk> foldr (+) 0 (build (\cons nil -> cons 1 nil))      = (\cons nil -> cons 1 nil) (+) 0    by foldr build fusion, so you get 1 + 0
12:53:31 <edwardk> johnw: different trick to get a similar goal
12:53:37 <andrewsw> thanks edwardk and monochrom
12:53:50 <johnw> defer list construction until the end, so it's O(n) overall
12:54:15 <edwardk> same goal. different way to do it
12:54:18 <johnw> i wonder why this hasn't been generalized for any monoids
12:54:42 <johnw> i guess it's too easy
12:54:44 <edwardk> if you take the same 'virtual list' you built up with the arg to build and deconstruct it twice you have to do all the work to build it twice
12:54:51 <johnw> a <> b <> c = (a <>) . (b <>) . c
12:54:57 <edwardk> basically if you will inspect something multiple times you want a real list
12:55:00 <johnw> a <> b <> c = (a <>) . (b <>) $ c
12:55:08 <edwardk> if you just do one pass over it, this sort of opens up more compiler optimizations
12:55:25 <johnw> ah
13:04:57 <fizruk> hey, guys! could you help me with some monad transformers?
13:05:47 <johnw> fizruk: sure!
13:05:51 <johnw> i love monad transformers
13:06:03 <fizbin> Bleah. I've just lost a whole day because the DTD generation in HXT's picklers sucks rocks.
13:06:17 <fizruk> suppose I have something like type T m a = StateT SomeState m a
13:06:35 <johnw> it is supposed
13:06:36 <shachaf> fizruk: Generally you should just ask your question rather than asking for someone to volunteer first. :-)
13:07:13 <fizruk> and then I have something like withSocketsDo :: IO a -> IO a
13:07:21 <fizbin> If I'd just known that HXT's picklers can't generate a DTD - and therefore should be ignored, along with anything that uses that DTD generation like checkPickler - I'd have finished this stuff hours ago.
13:07:59 <fizruk> and now I want to use that function within my transformed monad: T IO
13:08:15 <x7a1c0b> Say i have: data Time = Night | Day
13:08:17 <johnw> fizruk: liftIO
13:08:18 <snhmib> a whole day is nothing compared to the soul you lost by using xml in the first place
13:08:43 <shachaf> fizruk: It's trouble.
13:08:53 <x7a1c0b> is it legal to define succ and pred so that succ Day returns Night and succ Night returns Day ?
13:08:56 <shachaf> fizruk: You should probably just use withSocketsDo in the beginning of main or something.
13:08:59 <fizruk> johnw: liftIO is not sufficient, cause I need to get an argument
13:09:10 <johnw> fizruk: show me code where liftIO didn't work?
13:09:18 <shachaf> johnw: 13:07 <fizruk> and then I have something like withSocketsDo :: IO a -> IO a
13:09:19 <johnw> but that's kind of what liftIO means :)
13:09:30 <shachaf> johnw: It is not.
13:09:34 <johnw> a <- liftIO $ withSocketsDo someAction
13:09:57 <fizruk> the problem is that someAction is not of type IO a
13:10:05 <johnw> shachaf: It is in the sense of, how do I invoke some function in IO a in my tranformed monad T IO a
13:10:05 <fizruk> it's of type T IO a
13:10:07 <nooodl> x7a1c0b: sure, just add "deriving (Enum)"
13:10:09 <shachaf> johnw: fizruk wants T IO a -> T IO a, of course
13:10:13 <simpson> x7a1c0b: It's certainly something that you can do, but I bet that it will make things like [Day, ..] into an infinite list.
13:10:17 <johnw> fizruk: ah
13:10:23 <simpson> Or, uh, [Day..] in Haskell, sorry.
13:10:26 <johnw> this was no said
13:10:38 <nooodl> wait
13:10:41 <nooodl> i can't read
13:10:59 <johnw> fizruk: you can't route a T IO a through an IO a and keep the state
13:11:12 <x7a1c0b> nooodl the problem is (succ maxBound) which does not return minBound
13:11:18 <nooodl> yeah
13:11:18 <johnw> you'd have to strip the state to get down to an IO a
13:11:19 <shachaf> fizruk: As far as I know you're generally supposed to use withSocketsDo once around your entire program.
13:11:20 <monochrom> withSocketsDo is meant to be called once at the outermost level anyway
13:11:38 <shachaf> fizruk: So do main = withSocketsDo $ do { restOfProgram }
13:12:01 <shachaf> This is not a general-purpose answer to your question about transformers. It is only an answer about withSocketsDo.
13:12:01 <fizruk> shachaf, I understand the withSocketsDo case, but what if there are other things like preservingMatrix here: http://bit.ly/10dpKYh
13:12:09 <shachaf> As far as I know the general-purpose question doesn't have a good answer.
13:12:54 <shachaf> (Hmm. Probably you shouldn't use shortened URLs in here, either.)
13:13:09 <fizruk> so I need to get into internals of my concrete monad to do that
13:13:19 <johnw> shachaf: there might be a general answer
13:13:25 <shachaf> fizruk: Correct. It's pretty awful.
13:13:32 <shachaf> johnw: A good known answer.
13:13:41 <shachaf> Monad transformers are pretty awful.
13:13:43 <shachaf> Oh well.
13:13:46 * zachk wants a cement shoes monad
13:13:51 <johnw> shachaf: \a -> control $ \runInIO -> withSocketsDo (runInIO a)
13:14:03 <zachk> iirc, category theorist have barely explored monad transformers
13:14:17 <shachaf> johnw: That is sometimes feasible and sometimes not.
13:14:18 <johnw> by using monad-control
13:14:36 <sproingie> newtype CementShoes a = CementShoes { sleepWithDaFishes :: a }
13:14:36 <johnw> shachaf: when is it not feasible?
13:14:51 <shachaf> johnw: I bet it doesn't work for Cont?
13:15:12 <Philippa> zachk: I suspect mostly on grounds of "obviously bad idea unless you can't help it"
13:15:17 <johnw> also, that approach only carries the state unchanged through the operation, doesn't it
13:15:28 <johnw> and he may want to mutate state within the withSocketsDo
13:15:46 <johnw> so, whoever said to do main = withSocketsDo $ ... is the right answer
13:15:50 <shachaf> For instance.
13:15:53 <Philippa> shachaf: so I think in part it's our ability (or rather, Haskell's) to build infrastructure in terms of them that's lousy? I can look at Frank and piss-takingly show Conor where the transformers are...
13:16:31 <shachaf> There are many disadvantages to any practical solution/workaround to this problem. I don't know a good solution in general, or whether one exists.
13:17:00 <shachaf> Philippa: I don't know.
13:17:26 <Philippa> shachaf: so you've accidentally helped me realise that yes, the problem I'd been bitching about in chan for a few months does also apply meaningfully to monad transformers in a not-yet-solved way and give us all kinds of problems
13:17:39 <johnw> lifting IO a -> IO a to T IO a -> T IO a feels like a monad transformery fmap
13:18:05 <fizruk> johnw: exactly :)
13:18:06 <johnw> Philippa: which problem was that?
13:18:17 <Philippa> shachaf: I think part of my thinking is - the way we talk using them now is pretty much the asm for this stuff, which means waaaay too much book-keeping
13:18:39 <shachaf> I agree that there's way too much book-keeping.
13:18:44 <johnw> fizruk: but remember, fmap doesn't let you access the context, so you can use my monad-control trick if that's all you want wrt State
13:18:47 <Philippa> johnw: navigating through stacks of functors / a known decomposition of a composed functor
13:18:51 <shachaf> I don't know that a good solution will be based on monad transformers as we know them today.
13:19:16 <Philippa> shachaf: *nod*. I suspect it'll have somewhere you can point and say "that's where they ended up", but that's not the same thing
13:19:47 <johnw> fizruk: that line of code I pasted is from the lifted-based package, and is how it turns `catch' into a function that works for any MonadIO m
13:19:48 <shachaf> Sure, there are good ideas/goals in monad transformers. The general idea of building up monads from pieces is a nice one.
13:19:52 <sproingie> the transformer part is nice, it's the "stack" that's awful
13:20:26 <sproingie> "how many lifts was that?"
13:20:26 <shachaf> It's just that the implementation is full of things like n^2 instances and lifting and variance all sorts of ad-hoc details that I bet aren't really necessary.
13:20:48 <sproingie> to say nothing of error messages reminiscent of C++ STL
13:21:12 <Philippa> sproingie: 'xactly. Where's my row-kinded record of accessors I can compose appropriately?
13:21:42 <Philippa> shachaf: right, all the bits that are sort-of inflicted by Haskell not being as good at type-level programming as we'd like
13:21:53 <sproingie> mister owl, how many lifts does it take to get to the IO center of a monad transformer stack?
13:22:01 <johnw> fizruk: actually, the mmorph package has a "hoist" which is an fmap for monads
13:22:23 <sproingie> let's see, one, two, liftIO ...
13:22:47 <johnw> and there is a StateT instance...
13:22:54 <fizruk> johnw: sorry, my mind just exploded. Now have to rethink if fmap on monads is what I need…
13:22:58 <shachaf> Philippa: I'm not sure that's the only thing.
13:23:10 <shachaf> Philippa: But I don't know a good solution. All I know is that I don't like the current one. :-)
13:24:43 <Philippa> shachaf: so there's a major problem with typing 'callbacks' and the like inside a stack and how that interacts with control operations, too
13:25:10 <Philippa> if the exception layer doesn't know about state then exception handlers can't either, that sort of thing
13:25:34 <shachaf> Yes. Thinking about things like ContT, I'm not sure whether a solution that does everything you'd want it to exists at all.
13:26:55 <johnw> fizruk: heh, it works
13:27:18 <Philippa> well, the thing about that one is you suddenly want the option of a /recursive/ stack. Which I'm already playing around with in another context where the functor stack is (meta)syntax
13:27:25 <hpaste> johnw pasted “hoist.hs” at http://hpaste.org/84782
13:27:35 <johnw> fizruk: --^
13:27:40 <ramses_> have you guys seen that new laters package for monad transformers? It looked really nice at first sight but I haven't looked at it in detail yet
13:27:45 <ramses_> layers*
13:27:53 <johnw> i haven't looked at it either
13:27:55 <vikraman> hi, how do I traverse an aeson Value, without actually making a separate type for it?
13:27:56 <hpaste> implr pasted “ST” at http://hpaste.org/84783
13:28:07 <johnw> vikraman: using aeson-lens
13:28:37 <johnw> it gives you a "key NAME" lens that will let you drill down as you like
13:28:40 <ramses_> I think it is supposed to make usage of tranformers less of a burden, although it certainly wont be revolutionary
13:28:46 <fizruk> johnw: that's cool
13:28:54 <implr> hi everyone
13:29:10 <vikraman> i see, i don't know about lenses yet though :(
13:29:16 <fizruk> johnw: I just don't get this type signature: hoist :: Monad m => (forall a. m a -> n a) -> t m b -> t n b
13:29:20 <implr> I've been trying to code something with STUArray and ran across a strange problem
13:29:22 <implr> http://hpaste.org/84783
13:29:29 <implr> why does this behave this way?
13:29:31 <johnw> fizruk: for your case, m and n are both IO, and t is T
13:29:58 <fizruk> johnw: the problem is with a and b, actually =)
13:30:16 <fizruk> oh, i got that
13:30:34 <fizruk> johnw: thanks a lot for showing that stuff! :)
13:30:41 <johnw> sure thing
13:30:50 <johnw> much nicer to use than monad-control, actually
13:30:53 <johnw> glad you had me look into this
13:31:47 <johnw> shachaf: sure enough
13:31:54 <johnw> shachaf: hoist on ContT gives: No instance for (MFunctor (ContT ()))
13:32:13 <shachaf> johnw: Lots of things may not work "as expected" here, of course (and couldn't).
13:32:30 <johnw> at least it's a relatively clear "no" answer in this case
13:33:58 <shachaf> f k = do { k; k }; hoist f (do { modify (+1); get >>= liftIO print})
13:34:09 <shachaf> For instance.
13:34:24 <shachaf> What would you expect that'll do?
13:34:40 <hpc> shachaf: confuse me :P
13:34:43 <johnw> it should toss the state manipulation inside the second do block
13:34:55 <johnw> the hoist is a "barrier" through which effects may not pass
13:35:02 <x7a1c0b> Which type classes do i have to implement to use fancy features like [a..c] ?
13:35:05 <ramses_> is there an easy to use GUI framework/toolkit for haskell? preferably cross platform? I'd need to have some basic windows with buttons and such
13:35:07 <johnw> otherwise, this wouldn't be MFunctor, it would be MMOnad
13:35:08 <hpc> x7a1c0b: enum
13:35:12 <shachaf> johnw: ?
13:35:18 <otters> M-m-m-monad
13:35:25 <shachaf> I don't know what that means.
13:35:30 <johnw> see the function "embed"
13:35:34 <shachaf> The final state will be your initial state +1
13:35:37 <luite> ramses_: not really, wxHaskell and gtk2hs take some work to install
13:35:44 <johnw> so, hoist, like fmap, is ignorant of context
13:35:50 <x7a1c0b> hpc Should deriving Enum work? I get "A section must be enclosed in parentheses
13:35:50 <x7a1c0b>       thus: (February.. December)"
13:36:01 <ramses_> luite: yeah, I saw those and they seemed like a pain to get going, hence the question...
13:36:01 <johnw> and embed, like liftM, can mutate context
13:36:09 <johnw> hmm
13:36:13 <johnw> wait, liftM doesn't do that
13:36:26 <shachaf> Anyway I'll be back later.
13:36:40 <johnw> shachaf: i'm going to try your hoist code
13:36:41 <johnw> one sec
13:36:47 <ramses_> is it a matter of no one wanting to sped the effort or are there more serious reasons?
13:36:56 <ramses_> s/sped/spend
13:37:12 <shachaf> johnw: Here: http://slbkbs.org/beep.hs
13:37:13 <sproingie> layers looks really interesting
13:37:44 <luite> ramses_: nah it's just a lot of work to maintain, and their api's arent't terribly haskelly
13:37:49 <johnw> shachaf: huh, you're right
13:38:04 <johnw> shachaf: contrary to my expectations, the +1 modifies the state of the code calling hoist
13:38:06 <shachaf> It's the only reasonable thing that code could do.
13:38:15 <shachaf> Unfortunately it's only locally reasonable.
13:38:23 <ramses_> luite: and no one is doing any serious GUI stuff in haskell then?
13:38:29 <shachaf> Now imagine the IO action stores a callback in an IORef. What do you want *that* to do?
13:38:48 <shachaf> Anyway I need to go.
13:38:53 * shachaf vanishes in a puff of orange smoke.
13:38:53 <johnw> ok
13:38:54 <johnw> thanks
13:39:11 <`^_^v> what's the difference between a monoid and a MonadPlus?
13:39:22 <ramses_> sproingie: yeah it does, although the docs started to lose me towards the end
13:39:28 <luite> ramses_: dunno, i think many gui things are web based now, at least fpcomplete seems to be going that direction
13:39:39 <sproingie> they lost me much earlier but my attention sp--ooh shiny
13:40:06 <ramses_> luite: ah, and what do they use for graphics stuff then? That might be acceptable to me as well
13:40:07 <S11001001> `^_^v: consider Semigroup a => Monoid (Maybe a).  Can you write this behavior with MonadPlus Maybe?
13:40:19 <johnw> ok, queuing http://hackage.haskell.org/packages/archive/layers/0.1/doc/html/Documentation-Layers-Overview.html to read later
13:40:52 <johnw> since it mentions stuff like, "Can every type that is currently an instance of MonadTrans be made an instance of MFunctor too? The answer, unfortunately, is no. Once again, ContT proves too stubborn, and won't permit an instance of MFunctor. However, the idea behind MFunctor/hoist is "close", and it certainly seems to be on the right track."
13:41:23 * sproingie does the sideways-puppy-dog-head-cocked thing
13:41:25 <luite> ramses_: oh for simple graphics without much windowing requirement you can use gloss
13:41:28 <ramses_> `^_^v: the monad...
13:42:21 <Cale> `^_^v: The monad, and the fact that if we have (MonadPlus m) then m a is essentially a monoid for all types a, not just one particular type.
13:43:22 <hpaste> supki annotated “ST” with “ST (annotation)” at http://hpaste.org/84783#a84784
13:43:32 <supki> implr: I guess you meant something like that?
13:44:18 <saml> setup: Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with Cabal. Use the flag --package-db to specify a package database (it can be used multiple times).
13:44:21 <saml> what do I do?
13:45:00 <luite> upgrade your hsenv
13:45:09 <saml> not sure what that means
13:45:19 <luite> i'm just wildly guessing :p
13:45:20 <saml> bash: hsenv: command not found
13:45:48 <geekosaur> saml, what are you using, if anything?
13:45:50 <implr> supki: works, thanks
13:45:55 <luite> saml: ok, something has set GHC_PACKAGE_PATH, hsenv did that, how did you install ghc, what platform?
13:45:59 <saml> i'm tryin got do cabal install cabal-install
13:46:05 <implr> the whole forall thing is still confusing to me
13:46:08 <ramses_> luite: hmm, that doesn't seem to allow interactive GUIs, does it? For stuff in "the web direction" where you thinking haskell in the backend and some js in the frontend then?
13:46:17 <saml> i'm using justhub  http://justhub.org/overview   on centos 5.5
13:46:27 <ramses_> I have a hard time to believe no one is doing desktop application in haskell..
13:46:59 <`^_^v> that makes sense, thanks all
13:47:15 <luite> ramses_: gloss is not web based, it's an opengl based drawing thing (although there's a web version that uses canvas, communicates with a haskell backend)
13:47:40 <oio> complete remoce Haskell platform
13:47:45 <oio> *remove
13:47:55 <oio> for reinstall on mac os x ?
13:47:57 <ramses_> luite: yeah, I got that..
13:48:35 <ramses_> luite: I just want to somehow make an interactive GUI application, web based is fine but I don't want to spend half of my time writing js..
13:48:53 <luite> ramses_: well i just happen to be working on a haskell->js compiler ;)
13:49:11 <ramses_> luite: hehe, will it be finished soon? :)
13:49:11 <supki> implr: as I understand it, when you pattern match on Bar, you need to peek some s to type t, say s1; but now you can't pass t to runSTUArray, since it expects t to be fully polymorphic
13:49:40 <ChongLi> luite: oh yeah?
13:50:09 <luite> ramses_: finished as in 'done', not really, but we should have a user-usable release out before GHC 7.8.1
13:50:49 <ChongLi> is there any way for a haskell-js compiler to take advantage of asm.js optimizations?
13:51:01 <luite> ChongLi: argh why does everyone keep asking that question :p
13:51:07 <ChongLi> haha
13:51:27 <luite> ChongLi: the answer is probably not
13:51:47 <ChongLi> implement the haskell heap as a js typed array and bring the entire GHC runtime and GC into javascript?
13:52:13 <simpson> That sounds like a horrible plan.
13:52:22 <luite> yes I did that to some extent, but i didn't feel comfortable maintaining that
13:52:38 <luite> might revisit that when the rest of ghcjs works fine etc
13:52:45 <luite> but for now it's using javascript objects again
13:52:54 <ChongLi> ahh, damn
13:53:37 <ChongLi> is javascript the most hated language in the world?
13:53:38 <ChongLi> haha
13:54:01 <luite> haskell is relatively GC friendly, since there are not too many places that can mutate data, but still, writing a good GC with acceptable performance and pauses for interactive apps is not quite trivial :)
13:54:29 <ChongLi> hmm
13:54:36 <luite> asm.js is really ment for non-gc languages
13:54:38 <luite> meant
13:54:43 <sproingie> haskell generates vast amounts of garbage but sweeps it up just as quickly
13:54:57 <ChongLi> what about some radical whole-program optimization a la stalin scheme?
13:55:03 <simpson> asm.js is for people that have not learned the lessons of the past.
13:55:12 <sproingie> it's when you start dealing with large maps or arrays that things start to bog
13:55:13 <mcstar> haskell needs Lenin
13:55:31 <ChongLi> stalin scheme gets rid of GC entirely as far as I know
13:55:36 <ChongLi> uses region-based memory management
13:55:41 <mcstar> rust
13:55:53 <mcstar> friend of mine always talks about rust to me
13:55:57 <implr> supki: yeah, that makes sense
13:56:03 <sproingie> i'd like to see something actually written in rust
13:56:14 <mcstar> the compiler?
13:56:18 <sproingie> besides that
13:56:18 <mcstar> :)
13:56:24 <ChongLi> stalin scheme also eliminates closures
13:56:25 <luite> sproingie: fortunately some javascript engines have a reasonably efficient allocator, but firefox really suffers with its non-generational gc
13:56:33 <ChongLi> and other pretty radical transformations
13:56:34 <luite> often 4x slower than v8 with ghcjs produced programs
13:57:06 <ChongLi> yeah this is why you want to circumvent the browser gc
13:57:17 <luite> ChongLi: nah they're working on a new one
13:57:25 <luite> I'd rather have them do it than me
13:57:35 <simpson> ChongLi: So, there's at least one Haskell compiler that does full-program compilation and optimization. It's *slow* and runs out of memory easily.
13:57:57 <ChongLi> simpson: runs out of memory on big machines?
13:58:40 <luite> ChongLi: anyway the heap-in-an-array branch is still there, though a bit out of date. if you feel like hacking on a gc in js you're welcome :)
13:58:49 <sproingie> simpson: Supero?
13:58:56 <simpson> ChongLi: JHC.
13:59:02 <luite> but for acceptable performance you'll need to have at least a generational gc with incremental marking
13:59:12 <saml> https://gist.github.com/saml/c63c0f2c68be984ce2d6  what is this? how do you install cipher-aes   ?
13:59:17 <saml> is there c library dependency?
13:59:42 <ChongLi> luite: ideally wouldn't it just be the GHC gc compiled to js via emscripten?
14:00:07 <luite> ChongLi: yes that's the other thing everyone always suggests
14:00:22 <ChongLi> I'm just shooting from the hip here
14:00:24 <luite> also just used the GHC LLVM output, pipe it through emscripten and you're done
14:00:27 <ChongLi> I haven't actually investigated
14:00:39 <luite> hehe i'm not actually annoyed
14:00:43 <mcstar> sproingie: he showned me this https://github.com/pcwalton/sprocketnes
14:01:07 <sproingie> ah nice
14:01:13 <luite> but given that it's already quite hard to compile hugs and jhc things (ask ChrisDone) to js with emscripten, it's not going to be trivial
14:01:30 <ChongLi> I think what everybody wants is to be able to compile all of their fave languages through LLVM -> emscripten and get a nice, super-fast js that runs everywhere
14:01:36 <sproingie> can't say i'm a fan of rust's syntax, but it has some nice ideas anyway
14:01:49 <stephenjudkins> luite: from what I understand, emscripten can't compile arbitrary LLVM bytecode, only a subset that comes from certain C compilers
14:01:58 <stephenjudkins> at least last time I checked, it couldn't deal with C++
14:02:09 <luite> stephenjudkins: yes, the CPS stye that GHC emits wouldn't really work
14:02:12 <simpson> ChongLi: FSVO "everybody". Some of us want to kill JS.
14:02:28 <sproingie> BTW, anyone know of a greasemonkey script that gets rid of github's sliding animations?
14:02:28 <luite> stephenjudkins: i asked alon zakai lasth month
14:02:30 <ChongLi> yeah I'd love to kill js too
14:02:34 <ChongLi> but replace it with what?
14:02:39 <simpson> Don't replace it.
14:02:59 <luite> ChongLi: something like PNaCl sounds reasonable
14:02:59 <ChongLi> so just go back to static web pages?
14:03:01 <stephenjudkins> i had high hopes for pnacl, but google's not getting their act together on it.
14:03:20 <ChongLi> pnacl doesn't seem to have a chance
14:03:23 <simpson> History has shown us that, given the opportunity to script any kind of dynamic behavior into browsers, people will abuse it to create full applications.
14:03:37 <luite> and mozilla doesn't like it because they're working on asm.js with epic games
14:03:41 <oio> anyone know why haskell platform downloading is taking so long
14:03:50 <oio> 5 hours ETA
14:03:56 <ParahSailin> global internet ddos
14:03:57 <ChongLi> you call it abuse if you want
14:04:14 <ChongLi> most people just want to write some code that can run on anything without being installed
14:04:34 <ChongLi> and java applets failed in that regard
14:04:40 <oio> nope the last time was the same
14:04:42 <ChongLi> too slow to start up!
14:04:45 <simpson> ChongLi: Well, but then some people invented Offline Storage.
14:04:55 <simpson> So things are still being installed, but in a way that you can't easily manage.
14:05:02 <luite> anyway, install ghc 7.8.1 when its out, do cabal update; cabal install ghcjs, and you're good to go :p performance will be reasonable
14:05:10 <simpson> Also, nobody *actually* wants to run on every platform.
14:05:11 <oio> a buddy here downloaded himself uploaded to his dropbox account
14:05:17 <oio> a gave the link
14:05:17 <sproingie> at least nacl at least builds a new foundation rather than basing things on a tower of hacks like javascript + css + html + xmlhttprequest
14:05:19 <ChongLi> luite: I use firefix!
14:05:21 <ChongLi> firefox
14:05:22 <ChongLi> rather
14:05:28 <ChongLi> actually aurora
14:05:32 <luite> ChongLi: I hope they have the new garbage collector ready by then then
14:05:36 <ChongLi> I don't know if it has the new gc or not
14:05:38 <simpson> Because then somebody will message you and ask you why your thing doesn't work on AIX.
14:05:42 <luite> ChongLi: no it's still experimental
14:05:51 <simpson> And what will you say? "Oh, yes, I don't have AIX, but I'd love to help you out?" Not likely!
14:06:12 <ChongLi> sproingie: who says we have to have that?
14:06:19 <startling> is there a Num instance that will let me write a function like "\d -> 20 * d" and let me pretty-print it as "20x"?
14:06:37 <ChongLi> I envision a future where your "web page" is just an html wrapper around the real program
14:06:48 <newsham> > 20 * a
14:06:48 <sproingie> ChongLi: we don't, i just don't want the future of application development to be javascript
14:06:49 <lambdabot>   20 * a
14:06:50 <ChongLi> everything you see after it loads is dynamic
14:06:56 <newsham> > 2 * a * 10
14:06:57 <lambdabot>   2 * a * 10
14:07:19 <startling> newsham: yeah; I want a more mathy syntax
14:07:28 <simpson> ChongLi: I envision a future where applications stop wasting CPU time.
14:07:29 <ChongLi> the idea behind asm.js is so we don't code in js anymore
14:07:31 <startling> I know it'd be doable, I'm just wondering if it exists.
14:07:31 <sproingie> or dart for that matter
14:07:33 <ChongLi> but just compile to it
14:07:48 <newsham> startling: that is mathy
14:07:52 <startling> or even if there's a general framework for introspecting expressions with Num
14:07:53 <simpson> But it's such a shitty language to compile to!
14:08:00 <luite> ChongLi: yeah but you comple only to a very limited subset of javascript
14:08:02 <mast_> hey everyone
14:08:05 <ChongLi> simpson: what's a better alternative?
14:08:08 <mast_> i have a quick question
14:08:10 <startling> newsham, well, how you'd handwrite math
14:08:10 <newsham> www.funmath.be
14:08:12 <luite> ChongLi: i don't think asm.js allows object allocation, does it?
14:08:20 <luite> inside an asm.js function
14:08:24 <simpson> ChongLi: For starters, ignoring JS and the Web entirely.
14:08:35 <ChongLi> simpson: that's not an alternative
14:08:46 <newsham> ignorance is bliss, but the pay is not very good.
14:08:57 <simpson> ChongLi: Sure it is! XBoxes do it, Steam does it, and you could be doing it.
14:09:17 <startling> simpson, says the guy who survived writing a websockets implementation
14:09:17 <simpson> Do you think that iPhones boot to a web browser?
14:09:20 <sproingie> doesnt steam use flash?
14:09:33 <simpson> startling: Hey, I was paid and also I was cursing the entire time.
14:09:34 <mast_> Why would we have failure to visit all nodes in a tree if a variable arm aborts?
14:09:36 <ChongLi> all of those are different platforms
14:09:37 <luite> steam uses at least webkit in its interface
14:09:47 <luite> probably much of the steam store is scripted with javascript
14:09:48 <ChongLi> I don't want to port to them all
14:10:01 <startling> simpson: heh
14:10:14 <simpson> ChongLi: You *can't* port to them all! Surprise!
14:10:28 <ChongLi> I just want to write a program in plain haskell and push a button so it runs super fast on every device with a CPU in it!
14:10:37 <simpson> luite: How sad will you be to learn that it's C++ with a couple C# shims?
14:10:42 <ChongLi> and have users able to run it just by visiting a URL
14:11:00 <simpson> ChongLi: So, why does the Web have to be involved in URLs?
14:11:16 <mast_> can anyone please point me in the directtion for theory of haskell
14:11:20 <ChongLi> because URLs are an easy way to find and pass things around
14:11:22 <simpson> ChongLi: You are advocating working with broken infrastructure. I'm advocating tearing down the bad things and designing better things.
14:11:35 <luite> simpson: really? so they use the webkit API just to thisplay the pages?
14:11:35 <snhmib> http;//server.com/doit.exe
14:11:38 <simpson> mast_: Like, the report that talks about the design of Haskell and what it can do?
14:11:43 <mast_> I want to know about statefull programming
14:12:00 <ChongLi> simpson: how often in human history have we ever done that?
14:12:01 <simpson> luite: Yup. Or any other browser control; Steam in Wine uses Gecko.
14:12:09 <simpson> ChongLi: Clearly not often enough! >:3
14:12:34 <ChongLi> no, it's all about glomming on more things to an ever-expanding ball of mud!
14:12:37 <kylcarte> mast_: what's your question?
14:12:46 <luite> simpson: ah dunno if that makes me sad, a browser control is not a terrible way to do crosplatform layout of some text/images
14:12:48 <mast_> Why would we have failure to visit all nodes in a tree if a variable arm aborts?
14:12:53 <simpson> ChongLi: Anyway, to tie these two things together: Steam has steam:// URLs for manipulating and launching things from your library.
14:13:06 <sproingie> gecko has a thing that mimics IWebBrowse
14:13:11 <simpson> luite: Sure. But don't think for a second that Steam's games are done in JS, 'cause they're not.
14:13:13 <sproingie> steam thinks it's IE
14:13:14 <kylcarte> mast_: I'm not sure what you mean. Do you have an example?
14:13:32 <mast_> I know that "failure-atomicity mechanism" helps repair this issue
14:13:35 <luite> simpson: oh i didn't... though isn't that up to the game devs themselves?
14:13:41 <simpson> luite: Sure.
14:13:50 <ChongLi> yeah, steam even has flash games
14:13:53 <simpson> C++ still reigns supreme in game development.
14:13:57 <sproingie> steam's just a delivery system
14:14:07 <sproingie> well and an in-game library
14:14:23 <simpson> ChongLi: You've been able to make standalone executables that bundle the Flash runtime ever since Shockwave and Flash were separate programs.
14:14:24 <snhmib> and all that from boiling water
14:14:27 <snhmib> that's great
14:14:28 <mast_> it was posted by someone on paste bin : http://ja.pastebin.ca/2343768
14:14:50 <mast_> I am trying to get the answer for all those questions
14:15:00 <ChongLi> simpson: yeah, too bad for us linux users :(
14:15:12 <ChongLi> damn devs won't bother to bundle up for linux!
14:15:24 <simpson> ChongLi: Again, I believe in fixing problems when possible, and removing problems from existence when it benefits us to do so.
14:15:32 <simpson> mast_: Looks like homework. Have you asked your TA?
14:15:57 <ChongLi> wishful thinking!
14:16:12 <startling> snhmib: just wait till we get to internal combustion
14:16:13 <mast_> TA says can't help since he woud give out the answer. its all theory thats why
14:16:19 <ChongLi> that's the most important lesson to learn as a functional programmer!
14:16:24 <simpson> ChongLi: Not really. Ever used a language without NULL-terminated strings?
14:16:40 <startling> mast_: sounds like a lousy TA
14:16:46 <ChongLi> what, like pascal?
14:17:01 <simpson> Things like bounds checking, fixed-size numbers, illegal states... we *eliminated* these problems by altering the way that we think about computation.
14:17:12 <mast_> lol this is the class that everyone wants to avoid taking with this prof
14:19:17 <mast_> would u be able to help is i provide you with all the files?
14:19:41 <mast_> lectur notes, problems hints?
14:19:55 <mcstar> but i keep the grade, ok?
14:21:16 <mcstar> that pastebin seems to have the shittiest fonts ever, does it look like crap for you guys?
14:21:29 <mast_> please really stuck
14:22:42 <snhmib> mast maybe it helps if you're able to think a bit and type out what you're actually stuck with instead of dumping someone else's questions and say 'i need answers'
14:23:03 <ab9rf> i'll provide answers for you for a 'reasonable fee
14:23:15 <simpson> I left school and never want to go back.
14:23:26 <mcstar> dont tempt me..
14:23:33 <mcstar> i wanna finish
14:23:38 <ab9rf> simpson: my kids get enough homework to satisfy my need to do homework.
14:24:12 <simpson> ab9rf: Ha!
14:24:20 <mcstar> anyway, am i the only one who thinks that font looks crappy?
14:24:26 <ab9rf> simpson: not that it takes much to satisfy that need :)
14:24:42 <mast_> sure i'll pay if you want me to
14:24:53 <ab9rf> although honestly if you have some good introductor programming problems, i'll be glad to give them to my daughter :)
14:24:59 <mast_> i really need this done
14:25:12 <ab9rf> mast_: could you ask a more focused question?
14:25:47 <slack1256> mast_: is even your class about haskell or functional programming?
14:25:58 <ramses_> mcstar: looks terrible here as well
14:26:02 <mast_> hmm but those are the questions given
14:26:24 <mast_> its about programming languages.
14:26:39 <mast_> mainly haskell
14:26:44 <ab9rf> the font issue sare because that site is japanese
14:26:45 <ramses_> mast_: have you done any effort already? Do you have some partial answers yet?
14:26:47 <mast_> we never learned haskell
14:26:52 <ab9rf> for some reason japanese uses really ugly fonts
14:27:12 <mast_> I have partial answers for 1, 2, 3
14:27:16 <snhmib> is it just me or are those questions nonsense-ish
14:27:35 <ramses_> ab9rf: haha, that can't possibly be true? Don't japanese people ever visit sites with normal fonts?
14:27:39 <monochrom> it is not haskell, neither syntactically nor semantically
14:28:01 <ab9rf> ramses_: i don't understand it either, but i see it all the time
14:28:11 <monochrom> but the semantics seems to be some kind of transactional memory
14:28:23 <ab9rf> yeah, there's a type signature of Vertex -> Vertex -> (*)
14:28:29 <ab9rf> (*) is not a Haskell type
14:28:29 <slack1256> but japan has a lot of cool ascii art \(ºwº)/
14:28:34 <mast_> is there a way i can send you the lecture notes or hints?
14:28:39 <mast_> like email?
14:28:57 <ab9rf> slack1256: you should define an operator in haskell that looks like that :)
14:29:09 <slack1256> ab9rf: haven't you heard of 'data (*) = Iamreal | NoIamnot
14:29:20 <ab9rf> slack1256: haha
14:29:44 <ab9rf> this is a haskell-like language but it's not haskell
14:29:48 <monochrom> I have only heard of "data Me = Myself | MeToo"
14:30:10 <slack1256> ab9rf: Implying I am not already using it in my library, SuperLens(tm)
14:30:47 <slack1256> data You = Notme | AlsoNotHim
14:30:58 <slack1256> > data You = Notme | AlsoNotHim
14:30:59 <lambdabot>   <hint>:1:1: parse error on input `data'
14:31:35 <ramses_> mast_: seriously, no one is just going to solve your homework...
14:31:52 <ramses_> certainly not a list of graded questions
14:32:07 <ab9rf> indeed.
14:32:25 <monochrom> it is a lot of work, and I'm too lazy today
14:32:38 <slack1256> you could do what I did when needed linux answers
14:32:47 <slack1256> troll a CS channel until they responded
14:33:04 <slack1256> 'X is such bleh, because I can't to Y'
14:33:15 <implr> supki: meh, looks like I got another problem
14:33:15 <mast_> please if you can help
14:33:25 <implr> I can't figure out how to create that array
14:33:27 <slack1256> 'Oh no you didn't you obviously do Y here is how, you flamboyan hippy'
14:33:32 <mast_> i really need this done in a 30 min
14:33:36 <mast_> have to hand it
14:33:38 <ramses_> slack1256: haha :)
14:33:49 --- mode: ChanServ set +o glguy_
14:33:54 <ozataman_> anybody familiar with http-conduit? does the Manager become invalid after an exception and outside the same runResourceT block?
14:33:57 <implr> something like this http://hpaste.org/84785
14:34:03 <implr> but that is obviously incorrect
14:34:05 --- mode: glguy_ set +q *!*@gateway/web/freenode/ip.24.114.22.17
14:34:13 <ab9rf> heh
14:34:30 <monochrom> I don't like that tactic, but that's another story. my story today is: I don't know how to apply that tactic to this question, which is a semantics question rather than a write-a-program question.
14:34:42 <ab9rf> should i contact J. Bentahar at Concordia University and let him know aout this? :)
14:35:02 --- mode: glguy_ set -o glguy
14:35:25 <slack1256> ab9rf: that full blown trolling, not cool dude
14:35:40 <ab9rf> slack1256: i don't approve of cheating
14:35:57 <slack1256> don't for what other people do
14:36:04 <slack1256> if they want to cheat they will
14:36:09 <ab9rf> and it's fairly obvious that those assignments are from concordia
14:36:24 <mauke> slack1256: trolling?
14:36:35 <slack1256> **don't care for, sorry my engrish.
14:37:44 <dmwit> "Criminals do crime" is a terrible reason not to call the police.
14:38:09 <slack1256> true, I see is a bad argument, how about this
14:38:17 <mcstar> well, dont help, but to tell on someone, thats just ...
14:38:19 <mcstar> idk
14:38:23 <slack1256> That won't stop cheating, it will only do harm without benefit
14:38:26 <dmwit> I can imagine many reasonable reasons, like "well, he didn't actually cheat because nobody in here helped him".
14:38:27 <monochrom> implr: you're better off with "data Bar s = Bar Int (STUArray s Int Int)"
14:38:45 <mauke> mcstar: fair?
14:38:54 <mcstar> no, not that
14:39:02 <implr> monochrom: I tried that
14:39:10 <implr> but the earlier example didnt work then
14:39:15 <mcstar> mauke: kind of arrogant
14:39:20 <Clint> slack1256: not necessarily; the cheater might learn to be sneakier next time
14:39:23 <implr> monochrom: http://hpaste.org/84783#a84784 this one
14:39:28 <mcstar> the 'i know better' attitude
14:39:37 <slack1256> Clint: and be a better cheater, MUAHAHAHAHA!
14:39:37 <monochrom> thanks, I'll look
14:39:58 <Clint> everybody wins
14:40:01 <snhmib> you could ask for questions as the annoying guy in class
14:40:05 <mcstar> he cheats only himself...
14:40:06 <snhmib> on irc
14:40:28 <snhmib> that'd be fun ;]
14:40:47 <glguy_> The merits or otherwise of cheating in school isn't really the topic of #haskell
14:40:59 --- mode: glguy_ set -o glguy_
14:41:17 <slack1256> true, sorry guys for the offtopic.
14:41:29 <otters> @faq is learning Haskell a replacement for school?
14:41:30 <lambdabot> The answer is: Yes! Haskell can do that.
14:42:02 <ab9rf> otters: heh
14:42:04 <armlesshobo> lol
14:42:23 <armlesshobo> @faq can Haskell fix my failing marriage?
14:42:24 <lambdabot> The answer is: Yes! Haskell can do that.
14:42:33 <armlesshobo> :D
14:42:52 <dockside1> so can alt.suicide.holiday
14:42:55 <otters> fix (failing marriage)
14:43:14 <ab9rf> i'm too tired to care
14:43:18 <quchen> > fix error marriage
14:43:19 <lambdabot>   Not in scope: `marriage'
14:43:22 <otters> > fix fail marriage
14:43:23 <quchen> > fix error "marriage"
14:43:23 <hpc> :t failing -- i can totally see this being a function
14:43:24 <lambdabot>   Not in scope: `marriage'
14:43:25 <lambdabot>   can't find file: L.hs
14:43:26 <lambdabot>     Not in scope: `failing'
14:43:26 <lambdabot>     Perhaps you meant `ceiling' (imported from Prelude)
14:43:28 <otters> that'll just repeatedly cause the marriage to fail
14:43:58 <otters> haskell is the most pun-rich major language
14:44:34 <croikle> > fix (error "marriage")
14:44:36 <lambdabot>   *Exception: marriage
14:44:44 <otters> values keep leaking out of my Maybes, can anyone recommend a stronger functor?
14:44:57 <slack1256> we have marriage in a thunk.
14:45:09 <ab9rf> probably the best place to store marriage
14:45:11 <c_wraith> Data Nope a = Nope
14:45:15 <otters> slack1256: don't force it, it's considered illegal
14:45:27 <otters> except in some countries
14:45:28 <c_wraith> otters: that should be strong enough to prevent values from ever getting out
14:45:50 <ab9rf> definitely don't want any family values escaping
14:46:02 <armlesshobo> @faq can Haskell solve world poverty?
14:46:02 <lambdabot> The answer is: Yes! Haskell can do that.
14:46:04 <dockside1> family types
14:46:13 <mikeplus64> > fix error
14:46:15 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
14:46:45 <otters> is the mailing list group associative or is it closed?
14:47:04 <otters> ok I think it might be time for me to take a break
14:50:22 <Michae___> Is there any way to speed up the checking of equality, apart from removing it entirely? It's taking up almost half of my programs time
14:50:35 -armlesshobo(~ahobo@32.97.110.52)- what
14:50:47 <ab9rf> meep?
14:51:01 <mcstar> lol
14:51:05 <mcstar> sure
14:51:10 <hpaste> liyang pasted “instance MonadState s (IORefT s m)” at http://hpaste.org/84789
14:51:15 <mcstar> even faster, if you remove the program
14:51:17 <liyang> edwardk quchen donri: what do you think of the above?
14:51:46 <liyang> I'm contemplating using it in production. :3
14:52:18 <edwardk> i think with the atomicModifyIORef' and atomicWriteIORef you're locked into very current ghc's ;)
14:52:31 <liyang> OH NOES.
14:52:54 <edwardk> otherwise looks as sane as you can be given the IORef in there
14:52:58 <donri> liyang: i think you should hide the IORefT data constructor
14:53:40 <c_wraith> wait..  atomicWriteIORef? I need to check the docs on that one
14:54:20 <c_wraith> Oh, I see
14:54:20 <monochrom> implr: I would abandon foobar. it is not meant to be useful. ST is designed to disallow leaking an STUArray s (or STRef s) outside the ST s (with same s). and foobar precisely wants to take a leaked STUArray as parameter. no one can provide that parameter.
14:54:33 <liyang> donri: sure. But is there really much harm in it? You need to supply an IORef to run it in any case, and it's not like it changes, being in a ReaderT.
14:54:52 <liyang> (Much *more* harm, I should say.)
14:54:55 <edwardk> liyang: note: you _can_ safely do this with STRefs
14:55:02 <edwardk> the IORef is the dangerous part
14:55:14 <liyang> edwardk: good point.
14:55:37 <otters> lmap :: (a -> b) -> p b c -> p a c ?
14:55:39 <otters> wot
14:55:43 <liyang> edwardk: well, I was intending to share the IORef between threads... </troll>
14:56:02 <edwardk> :t flip (.)
14:56:03 <lambdabot> (a -> b) -> (b -> c) -> a -> c
14:56:08 <edwardk> otters: thats an example
14:56:18 <edwardk> when p = (->)
14:56:30 <otters> OH I see
14:56:41 <otters> I was associating the last two types in my head instead of the first two
14:57:10 <liyang> c_wraith: atomicWriteIORef is writeIORef with a barrier. Funny that there isn't an atomicWriteIORef'...
14:57:30 <ClaudiusMaximus> and i guess the name comes from lmap :: (l -> l') -> Either l r -> Either l' r
14:57:44 <ClaudiusMaximus> wait no
14:57:46 <danharaj> no
14:57:47 <danharaj> :P
14:57:54 <otters> l and l' are backwards there
14:57:57 * ClaudiusMaximus gives up thinking and watches donuts spin
14:58:32 <monochrom> implr: I suggest foobar3 :: (forall s. ST s (Bar s)) -> UArray Int Int; foobar3 program = runSTUArray (do { Bar n t <- program; return t })
14:58:42 <c_wraith> liyang: yeah, the "oh, I see" was after I looked up the docs. :)
14:58:43 <liyang> c_wraith: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-IORef.html#g:2
14:59:00 <liyang> c_wraith: OUC...
14:59:45 <danharaj> edwardk: can you explain to me how to use your graphs library in a way that is GC friendly, and why storing just a VertexMap and EdgeMap with the graph shape implicit is worse?
14:59:55 <otters> so what can you do with Profunctor
15:00:20 <liyang> otters: take over the world.
15:00:23 <edwardk> if you mix them together, when you mutate it both the shape and the data become 'new stuff' to the GC.
15:00:30 <liyang> otters: as edwardk seems to be doing.
15:00:35 <hpaste> “Anonymous Coward” pasted “aeson lens” at http://hpaste.org/84790
15:01:07 <otters> liyang I'm starting to think edwardk could take over the world using only unsafeCoerce and const
15:01:23 <edwardk> otters: thats pretty much how we power lens ;)
15:01:33 <otters> yeah that's what I thought
15:01:33 <edwardk> not so much with the const though
15:01:33 <vikraman> hi, i'm trying to read json from a http service and decode it using aeson
15:01:42 <vikraman> this is what I have now http://hpaste.org/84790
15:02:40 <danharaj> edwardk: 'new stuff' refers to how the GC sees the data w.r.t. generations I infer?
15:02:43 <liyang> otters: abstract over things other than (->). For example, if you had I a b c = a -> b -> c, then I a would be a profunctor... (This is how the indexed stuff works in lens, I believe.)
15:02:51 <vikraman> but the code feels unusually complex to me!
15:02:55 <vikraman> someone care to review?
15:02:55 <otters> functionalWebserver = unsafeCoerce ()
15:03:22 <edwardk> vikraman: i recommend looking at github.com/lens/aeson-traversal for a more lensy way to work with json
15:03:34 <edwardk> not sure if statusfailed ever shipped it
15:03:37 <otters> oh god
15:03:43 <otters> aeson-traversal, aeson-lens
15:04:49 <otters> edwardk would you recommend aeson-traversal over aeson-lens
15:04:55 <otters> it appears that you can do at least all the same things with it
15:05:02 <edwardk> yes.
15:05:35 <edwardk> aeson-traversal has the benefit of actually following the lens laws, etc.
15:05:43 <otters> fancy that
15:06:48 <donri> liyang: oh. i was thinking you'd create a newIORef when you run it.
15:07:31 <Ralith> when GHC detects an infinite loop, is there any way to get it to tell you anything at all about *where*?
15:07:33 <vikraman> aeson-traversal isn't on hackage yet!
15:07:45 <luite> Ralith: possibly if you run with -xc
15:07:51 <edwardk> vikraman: harass statusfailed =)
15:07:54 <dEPY> can "do" only be used in main?
15:08:00 <edwardk> dEPY: no
15:08:15 <dEPY> Ok then I need help :)
15:08:16 <Ralith> luite: unrecognized flag
15:08:30 <hpaste> dEPy pasted “random strings” at http://hpaste.org/84791
15:08:33 <luite> Ralith: compile with profiling, the start your program with ./x +RTS -xc
15:08:55 <liyang> donri: well, sometimes you *do* want to live dangerously and use the same IORef in multiple threads.
15:09:08 <liyang> (But not often.)
15:09:10 <dEPY> I have a function that produces list of random string, it takes in length of the string and number of the string u want
15:09:33 <liyang> (And often when you do, you really don't.)
15:09:40 <Ralith> luite: I don't have a profiling world set up; can't ghci do anything directly, being an interpreter?
15:10:05 <luite> Ralith: yes, it might not detect the loop :p
15:10:18 <Ralith> it does
15:10:25 <glguy_> Ralith: The <<loop>> exception is catchable, you can catch it, annotate it, and rethrow
15:10:37 <glguy_> You can also tell ghci to stop on exeception
15:10:42 <dmwit> dEPY: Perhaps you want something like "randStrs <- randomString len (pred num); return (randStr:randStrs)".
15:10:52 <luite> oh is it, i need to change that in ghcjs then :)
15:10:55 <dmwit> dEPY: But it ain't gonna do what you want.
15:10:56 <Ralith> glguy_: that sounds promising; how do I do that?
15:11:24 <Ralith> none of my code is in IO, so catching is tricky.
15:11:27 <glguy_> Ralith: Look at -fbreak-on-exception and -fbreak-on-error and see if they help
15:11:33 <Ralith> kk
15:11:57 <dEPY> dmwit: how do I fix it then? :/
15:12:45 <monochrom> "splitAt (num*10) $ drop len" seems incomplete. what is the list?
15:12:51 <dmwit> dEPY: If you're happy living in IO, why not use randomRIO?
15:13:20 <dEPY> dmwit: because I'm not that far in a book and don't know it exists :D
15:13:35 <Ralith> running with tracing seems to make the exception not occur >.<
15:13:41 <Ralith> just silently loops
15:13:42 <dmwit> :t \m n -> replicateM m (replicateM n (randomRIO ('a','z')))
15:13:44 <lambdabot> Int -> Int -> IO [[Char]]
15:13:49 <Ralith> oh, sweet, it catches ^C
15:14:01 <dEPY> oh I should probably say that this is the error:   Couldn't match expected type `[t0]' with actual type `IO StdGen'   (at line wit getStdGen)
15:15:39 <dmwit> dEPY: I'm kind of torn. On the one hand, I want to suggest you use randomRIO because it does the maintenance of the StdGen for you. On the other, I want you to learn how to do the maintenance of the StdGen...
15:15:52 <dmwit> dEPY: Anyway, the short answer is you should use functions that generate both an output and an updated StdGen.
15:15:59 <monochrom> the type error is not the only problem
15:16:15 <implr> monochrom: you have a point there
15:16:18 <dmwit> ...I will leave this in monochrom's very capable hands. =P
15:16:24 <implr> basically what I wanted to achieve
15:16:44 <ramses_> "cabal-dev init" fails on me with "./cabal-dev/lib/ghc-7.6.2/ObjectName-1.0.0.0:
15:16:48 <ramses_> does not exist"
15:16:52 <implr> was that you create a type Bar consisting of an Int (which never changes) and a STUArray
15:16:56 <ramses_> anyone know what that means?
15:17:15 <ramses_> the ghc-7.6.2 subdir is not there
15:17:27 <implr> then you make some changes to said array, and after you are done you convert it to a plain UArray
15:17:28 <dEPY> Hm.. :S
15:17:30 <johnw> ramses_: that's odd
15:17:38 <dEPY> Anyone else can tell me why this doesn't work? http://hpaste.org/84791
15:17:43 <implr> that's what foobar was supposed to do
15:17:44 <DanZimm> hey all i was wondering if someone could explain to me the issue I'm having with the following code: http://d.pr/n/YlJb
15:18:08 <DanZimm> pop pasted to wrong place
15:18:24 <implr> I wanted to have the int in the type because basically it is needed by all functions that will operate on that array
15:18:31 <hpaste> DanZimm pasted “Factorial test” at http://hpaste.org/84792
15:18:47 <DanZimm> yep there
15:18:47 <implr> and passing it to them every time seemed well... ugly
15:19:10 <geekosaur> and the issue is? (if you have an error message, please nopaste the whole message)
15:19:15 <Tordek> does anyone remember what the function for combining parameters for sortOn is? I tried hoogling '(a -> b) -> (a -> c) -> a -> (b, c)' but no cigar
15:19:18 <ramses_> johnw: nevermind, I must have done something woring, I just deleted the cabal-dev dir and started all over again
15:19:28 <ramses_> s/woring/wrong
15:19:55 <DanZimm> geekosaur aight sorry
15:19:56 <johnw> ramses_: yeah, that often works for me too in those cases :)
15:19:58 <monochrom> implr: I think foobar3 still fits that purpose. foobar3 (do { b@(Bar n t) <- create' 40; do whatever you like to t; return b })
15:20:29 <hpaste> DanZimm pasted “Factorial test - with error” at http://hpaste.org/84793
15:21:02 <DanZimm> its like the n isn't being assumed to be an integer… idk how to "force" it to be an int
15:21:12 <DanZimm> or integer for that matter
15:21:28 <croikle> DanZimm: so, subfact needs to produce an Integer, and you're multiplying n to get its result, so n is integer
15:21:47 <croikle> maybe you want fact :: Integer -> Integer
15:22:03 <croikle> or, you could add some fromIntegral
15:22:34 <implr> monochrom: oh, I didnt think of wrapping it like that
15:22:39 <implr> that should work, thanks
15:22:52 <cardamon> I'm learning haskell as I go through configuring xmonad and reading Learn you a Haskell, but I've gotten to one I don't quite get.
15:23:03 <DanZimm> if you do fact :: Integer -> Integer then it throws the error that the !! infix only accepts int not integer
15:23:23 <cardamon> What's the significance of nameing something PP?
15:24:06 <ChongLi> cardamon: you talking in reference to Xmonad?
15:24:11 <monochrom> dEPY: "splitAt (num*10) $ drop len" looks incomplete. where is the list?
15:24:32 <DanZimm> croikle ^
15:24:33 <johnw> cardamon: Pretty Printer?
15:24:36 <k00mi> cardamon: in XMonad, PP stands for PrettyPrinter
15:24:37 <ChongLi> cardamon: Xmonad has a PP type
15:24:41 <ChongLi> yes
15:24:41 <croikle> DanZimm: okay, then you need genericIndex, or fromIntegral
15:25:06 <cardamon> ChongLi: I wasn't sure where it came from.
15:25:10 <cardamon> Thanks.
15:25:31 <ChongLi> cardamon: http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Hooks-DynamicLog.html#g:3
15:25:32 <cardamon> johnw: k00mi: Thanks to you too.
15:25:49 <dEPY> monochrom: nice catch, still that's not the main problem :S
15:25:56 <niteria> haskell threads are preemptive? how is this done?
15:26:02 <dEPY> oh wait
15:26:11 <monochrom> ok, then you need "return (randStr : ...)"
15:26:22 <monochrom> no, that also is wrong
15:26:22 <DanZimm> croikle ah ok thanks
15:26:26 <ChongLi> niteria: haskell threads are distinct from OS threads
15:26:32 <dEPY> monochrom: Yes, just figured that out :D forgot it returns new generator
15:26:34 <croikle> DanZimm: probably easiest is to keep it at Int -> Integer, but make subfact n = fromIntegral n * fact (n-1)
15:26:52 <DanZimm> why is n considered an integral right there?
15:26:56 <DanZimm> erm Integer
15:27:00 <monochrom> you need "more <- randomString len (pred num)". now you can "return (randStr : more)"
15:27:24 <croikle> fromIntegral converts from any Integral type, like Int, Integer, Word8, etc
15:27:28 <monochrom> but this is just writing out replicateM by hand
15:27:30 <niteria> ChongLi: that's why I'm asking, I don't know a good way to have preemptive userspace threads
15:27:50 <ChongLi> niteria: oh, ok
15:27:53 <21WAADRCT> is there an easy way to show a double without e-notation. Example I want 0.04 printed as "0.04" instead of "4.0e-2"
15:28:05 <ChongLi> you'll have to investigate the details of the runtime
15:28:39 <ChongLi> I'm not up on the gory details
15:28:52 <dEPY> monochrom: I fixed that but still getting:  Couldn't match expected type `[t0]' with actual type `IO StdGen'
15:29:05 <DanZimm> croikle right but all n's should be integers anyways, why is it assuming otherwise?
15:29:10 <monochrom> ok show current code
15:29:25 <ChongLi> DanZimm: types are inferred from context
15:29:55 <ChongLi> Haskell doesn't go from a more specific type to a more general one
15:29:57 <croikle> n has to be Int if we call fact (n-1) when fact :: Int -> Integer
15:30:11 <hpaste> dEPy pasted “random string list” at http://hpaste.org/84795
15:30:24 <DanZimm> croikle right but why was haskell not assuming that?
15:30:58 <croikle> at the same time, n has to be Integer, since subfact n = n * stuff is an Integer
15:31:36 <DanZimm> croikle is that why haskell was complaining?
15:31:39 <dEPY> monochrom: http://hpaste.org/84795
15:31:57 <DanZimm> I'm trying to understand why it wasn't assuming that it was an int
15:32:08 <croikle> DanZimm: yeah, it couldn't find a type for n that satisfies both constraints
15:32:09 <monochrom> @type getStdGen
15:32:10 <lambdabot> IO StdGen
15:32:42 <monochrom> oh, um, [String]? IO [String]?
15:32:50 <DanZimm> croikle ah ok, so you have to do fromIntegral (or in theory could even do fromInteger) so that you convert it into Int?
15:32:50 <aCube> Where can I find the ghc 7.6 haddock documentation?
15:33:05 <merijn> DanZimm: Yeah
15:33:14 <croikle> multiplication doesn't do any coercion, so if n * k :: Integer, we have n, k :: Integer
15:33:15 <ChongLi> be advised that you may lose precision
15:33:20 <DanZimm> yay i have learned me a little good haskell :P
15:33:23 <dEPY> monochrom: hm now i fails at first 2 pattern matches for 0 _ and _ 0
15:33:34 <dEPY> cause they're not returning IO [String]
15:33:35 <ChongLi> since Integers have a lot more precision than Ints
15:33:37 <DanZimm> ChongLi ya i realize that
15:33:42 <monochrom> well then, it's "return []"
15:33:46 <aCube> ah nvm, found it
15:33:49 <dEPY> oh
15:33:50 <DanZimm> hrm
15:33:58 <monochrom> this code is full of conceptual problems
15:34:13 <croikle> DanZimm: yeah, fromIntegral is your general converter. Also used if you want to divide integers and get something floating
15:34:58 <DanZimm> very cool! thank you croikle ChongLi and merijn :D
15:35:14 <monochrom> to be fair, there would be no such conceptual problems in other languages. but I hate that.
15:35:53 <dEPY> monochrom: still some problems :D
15:35:54 <monochrom> "f (g x) (h y)" in other languages say: perform the effects of g, then the effect of h, then go back to perform the effect of f.
15:36:17 <monochrom> you see the disparity between code order and effect order?
15:36:24 <ChongLi> I'm much happier coercing with fromInteger than having javascript's equality operator coerce the crap out of everything
15:36:26 <monochrom> it's so hard to read
15:37:02 <monochrom> whereas haskell forces you to "a <- g x; b <- h y; f a b" code order is effect order. this is the only reasonable choice.
15:37:22 <dEPY> monochrom: it says: Couldn't match expected type `[a0]' with actual type `Char',  for second argument of drop (randomChars)
15:37:34 <monochrom> dEPY: what is with (randomChars:_)? why is it not simply randomChars?
15:37:35 <ChongLi> dont you just love how 0 equals the empty string in js?
15:37:52 <ChongLi> it's just madness!
15:37:56 <dEPY> monochrom: Hm. I guess I thought randomRs also returns generator
15:38:09 <monochrom> @type randomRs
15:38:09 <johnw> monochrom: effect order of arguments is not guaranteed in C++ either
15:38:10 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> [a]
15:38:19 <dEPY> I see
15:39:20 <monochrom> effect order of "f (h x) (g y)" is largely guaranteed in SML and Scheme, but I still hate it. why is it not consistently left-to-right or right-to-left?
15:39:34 <croikle> ChongLi: the difference between "2" + "2" and "2" - "2" is pretty funny too
15:40:10 <ChongLi> haha yeah
15:40:19 * DanZimm does what croikle says now
15:40:29 <monochrom> because of this I think Moggi is very right to say "use a monad" because it makes you use explicit >>= or equivalent
15:41:20 <DanZimm> wut
15:41:24 <DanZimm> lmao
15:41:36 <johnw> monochrom: in fact, the Eval monad in the "parallel" package exists partly just to solve sequencing issues
15:42:32 <croikle> DanZimm: you might enjoy https://www.destroyallsoftware.com/talks/wat if you liked that one
15:43:07 <DanZimm> oh lawd ruby
15:43:19 <dEPY> final touch I think: Couldn't match expected type `[t0]' with actual type `([Char], [Char])'    in:    let (randStr:_) = splitAt (1*10) $ drop 10 randomChars
15:43:47 <otters> (randStr,_)
15:44:14 <DanZimm> croikle you have made my week, thank you!
15:44:15 <monochrom> wait, why don't you use take instead of splitAt?
15:45:07 <dEPY> monochrom: how would I know :) I'm doing haskell for 4-5days now :D
15:45:17 <dEPY> monochrom: but ye, good idea
15:47:52 <johnw> dEPY: i've seen you here longer than 5 days, haven't i?
15:48:52 <dEPY> johnw: I've been around longer cause I like you guys :)
15:49:17 <johnw> we are crazy
15:49:32 <dEPY> johnw: Because everytime I asked you guys something about some programming concept even it was not haskell you guys gladly explained it :)
15:49:42 <dEPY> johnw: Me too O_ô
15:50:28 <dEPY> johnw: Otherwise I'd be learning some overhyped lang and some hipster framework now :)
15:51:27 <dEPY> I hope there's no RoR or node.js guys here :D
15:51:30 <croikle> some folks consider haskell overhyped
15:51:49 <otters> i'm a ruby on rails guy
15:51:52 <johnw> but none of us consider it overtyped
15:51:55 <otters> it's not really a niche framework at this point
15:52:11 <dEPY> otters: me too kinda
15:52:25 <Philippa> not when security holes in it are enough to create major work for IT security analysts, no :p
15:52:26 <otters> but nodejs guys, yeah, THOSE are the bastards
15:52:59 <johnw> let's just make a Node.js monad and assimilate them
15:55:41 <otters> will cabal ghci be in 1.18.x
15:57:49 <chrisirc_> Hm. I'm working with a monad that extracts stuff from XML files. Now when I get to the point where I've selected a certain tag, how do I do several different subqueries on that same tag?
15:57:59 <chrisirc_> I need something like a "fork" on the monad state.
15:58:48 <chrisirc_> Does such a thing exist? (i.e. first class monad state; bind to a variable, run submonads from that binding.)
15:59:21 <arkeet> you want to zoom.
15:59:24 <arkeet> from lens :p
15:59:41 <chrisirc_> Hm??
16:00:10 <chrisirc_> hu, Control.Lens.Zoom?
16:00:13 <dEPY> Anyone can explain why this http://hpaste.org/84796 is returning list of strings of length 5,4,3,2,1 instead of list of stringht of length 5 ?
16:00:16 <arkeet> > execState (zoom _1 $ modify (+1)) (3,"hi")
16:00:19 <lambdabot>   (4,"hi")
16:01:07 <ion> depy: Btw, use newStdGen instead of getStdGen.
16:01:39 <arkeet> dEPY: because you're using pred.
16:02:00 <arkeet> and taking num of them, not len.
16:02:14 <dEPY> arkeet: ah, I must take based on len not num
16:02:31 <dEPY> tnx
16:02:48 <dEPY> ion: I think I'm just about to read up on that in "learn you a haskell" not that far :)
16:03:11 <ion> LYAH recommends getStdGen?
16:03:34 <dEPY> it looks like it explains them goth
16:03:36 <dEPY> both*
16:03:54 <chrisirc_> Hm if I understand that correctly, that just selects the first slot of the tuple for the monad actions, arkeet. What I need is preserve the state and let me run from there multiple times.
16:04:24 <arkeet> chrisirc_: ok, then get the state and then run a new state action inside.
16:05:11 <chrisirc_> Hm, fair enough, need to check that (I'm feeling uncertain since I don't know what's inside the monad state, since I didn't write it).
16:06:24 <arkeet> :t let f m = get >>= runState m in f
16:06:26 <lambdabot> MonadState b ((,) a) => State b a -> (a, b)
16:06:31 <arkeet> hm
16:06:36 <arkeet> nope.
16:07:12 <cardamon> What's a =<< operator do?
16:07:22 <quchen> cardamon: flip >>=
16:07:25 <arkeet> same as >>=, just flipped
16:08:06 <shachaf> For bonus points: (*>) does the same thing as (>>). What does (<*) do?
16:08:39 <niteria> ok, no magic in ghc's preemptive threads, just memory allocation being a yield point
16:08:40 <johnw> do { x <- f; y; return x }
16:09:06 <arkeet> :t liftM2 const
16:09:07 <lambdabot> Monad m => m r -> m a2 -> m r
16:09:20 <Philippa> shachaf: funny thing - I don't think I'd want to lose either of those operators if I were to design the libs today, either
16:09:22 <ion> liftM2 kills kittens
16:09:46 <shachaf> Philippa: What would you call them?
16:09:50 <arkeet> whoever invented the typeclass hierarchy killed many, many kittens.
16:11:04 <arkeet> :t \m -> liftM (evalState m) get
16:11:06 <lambdabot> MonadState a1 m => State a1 r -> m r
16:11:14 <quchen> arkeet: British sense of humour
16:11:29 <arkeet> hrm
16:11:46 <shachaf> What?
16:11:54 <ion> humoure
16:12:20 <Philippa> ion: eh. Maybe these days - it's be nice if `liftM2 (+)` were valid though
16:12:48 <Philippa> shachaf: as in, how would I pronounce *> and >>?
16:12:48 <ion> philippa: Banana brackets would be nicer for that.
16:12:56 <shachaf> Philippa: For instance.
16:13:15 <shachaf> I assume you wouldn't actually have both.
16:13:34 <Philippa> ion: yeah, and I'd like an applicative let (have decided do is subtly wrong for it), but that's life
16:14:02 <Philippa> shachaf: no, that's my point: I probably would because >> is neatly mnemonic when thinking monadically. It's that or rename >>=
16:14:12 <Philippa> to be fair, I might consider that
16:14:18 <shachaf> You would have (*>) = (>>)?
16:14:20 <ion> Well, we don’t have `liftA2 (+)` either. So while we’re talking about hypothetical syntax… banana brackets would be nicer. :-P
16:14:41 <johnw> why don't we have banana brackets, when we have arrow syntax?
16:14:45 <Philippa> shachaf: I guess, so long as we're still allowing specialised implementations
16:14:49 <johnw> seems like banana brackets would be much lower impact
16:14:55 <Philippa> johnw: hysterical raisins plus nobody wrote the patch
16:15:03 <quchen> Banana brackets?
16:15:04 <shachaf> They'd be much higher-impact because people would use them.
16:15:13 <johnw> [| f x y |] = f <$> x <*> y
16:15:19 <johnw> shachaf: lol
16:15:20 <shachaf> quchen: I assume they mean idiom brackets.
16:15:23 <otters> :t (<<)
16:15:25 <lambdabot>     Not in scope: `<<'
16:15:25 <lambdabot>     Perhaps you meant one of these:
16:15:25 <lambdabot>       `=<<' (imported from Control.Monad.Writer),
16:15:27 <quchen> Idiom brackets?
16:15:33 <otters> why isn't (<<) defined?
16:15:39 <shachaf> @google idiom brackets
16:15:42 <lambdabot> http://www.haskell.org/haskellwiki/Idiom_brackets
16:15:43 <lambdabot> Title: Idiom brackets - HaskellWiki
16:15:52 <shachaf> Arrow syntax in GHC considered harmful.
16:15:53 <DanZimm> ok new question: lets say I have some function y where it is at first positive and then negative and I wanted to make a set of y(n) where n is an element of the natural numbers and y is always positive. I currently have  `[ n | n <- [1 ..] , ( y n ) > 0 ]` but haskell begins to hang once it gets to the last element, i am guessing this is because it doesn't realize that all elements beyond this won't be in the set, is there a way to specify almost like the
16:15:54 <DanZimm>  characteristics of the function or something?
16:16:04 <johnw> otters: you know, in all this time I've never reached for <<
16:16:14 <johnw> so it's probably not defined because no one else did either
16:16:15 <DanZimm> I realize you could just specify the interval of natural numbers but I want this to be really generic
16:16:19 <shachaf> DanZimm: No.
16:16:24 <shachaf> DanZimm: You can use something like takeWhile, though.
16:16:28 <otters> johnw: I've used <*
16:16:30 <shachaf> > takeWhile (<10) [1..]
16:16:31 <lambdabot>   [1,2,3,4,5,6,7,8,9]
16:16:41 <johnw> otters: yeah, me too
16:16:46 <otters> is it not the same thing as (<<)?
16:16:52 <otters> or what (<<) would be if it existed
16:16:52 <quchen> Well that Wiki article is crap
16:16:58 <shachaf> (<<) could have two meanings.
16:16:58 <johnw> otters: when you have do notation, x << y is easier to write as x; y
16:17:02 <DanZimm> shachaf thanks
16:17:07 <johnw> or y; x
16:17:09 <otters> shachaf: ?
16:17:10 <shachaf> Would you expect (<<) to behave like (<*) or like (=<<)?
16:17:16 <otters> like (=<<)
16:17:19 <otters> why?
16:17:21 <shachaf> OK, that's the opposite of (<*)
16:17:22 <johnw> right, like shachaf is saying
16:17:24 <otters> what's the difference
16:17:24 <shachaf> So there you go.
16:17:27 <johnw> x <* y evaluates x first
16:17:27 <shachaf> otters: Try it out!
16:17:30 <otters> oh
16:17:31 <Philippa> I've used <* seriously
16:17:32 <otters> why
16:17:33 <johnw> x << y would, if like =<<, evaluate y first
16:17:37 <shachaf> johnw: ?
16:17:45 <shachaf> johnw: I don't think order of evaluation really gets into this.
16:17:46 <otters> I see
16:17:48 <Philippa> with a local pronunciation of "given", because I was working in a logic programming applicative
16:17:58 <Philippa> "[yield] LHS given RHS"
16:18:02 <johnw> shachaf: no?  it would mean that <* and << are very different
16:18:18 <shachaf> No, that has nothing to do with evaluation.
16:18:25 <shachaf> Maybe you mean "executes".
16:18:28 <johnw> ah, yes
16:19:18 <DanZimm> shachaf perfect thank you
16:19:33 <DanZimm> now i would just rather get the indecies rather than the actual values heh
16:19:53 <shachaf> zip may help.
16:20:56 <chrisirc_> Well, I don't even know what kind of monad this is: Cursor -> DList Cursor
16:21:06 <chrisirc_> runCursor or runDList don't exist.
16:21:28 <shachaf> DList is pretty bad as a monad, isn't it?
16:21:43 <chrisirc_> Well, how do you mean?
16:21:45 <shachaf> chrisirc_: Something called "runCursor" would be irrelevant to any sort of monad being involved here. (Why?)
16:22:15 <shachaf> chrisirc_: DList is a "difference list" -- you should go and figure out how it works, if your goal is to be learning things.
16:23:04 <chrisirc_> Well, that's the type I have for an action; now as I described above, I need a way to capture the state, or "freeze" or "fork" the monad so I can run several subsequent actions starting from the same start point.
16:23:19 <chrisirc_> Ok I'll check the DList docs.
16:23:57 <nh2> I need a priority queue. What package is recommended?
16:23:58 <shachaf> It seems unlikely that DList is the monad you're thinking of here.
16:24:19 <shachaf> Also I don't understand whatever you want to do.
16:24:29 <c_wraith> DList's monad instance is going to be really slow, isn't it?
16:24:42 <shachaf> c_wraith: That's what I thought.
16:24:54 <chrisirc_> shachaf, maybe this is the monad type:  type Trans a b = a -> DList b
16:25:09 <chrisirc_> (Isnt' that the same thing actually?)
16:25:34 <chrisirc_> (Trans Cursor Cursor == Cursor -> DList Cursor)
16:25:35 <shachaf> chrisirc_: I have the feeling you don't completely understand what's going on. :-) I know I don't, anyway. Did you write this code?
16:25:42 <chrisirc_> no
16:26:23 <chrisirc_> That's existing code that queries XML documents, and I'm trying to change it for my purposes.
16:26:32 <ramses_> with doctest, how can I import a test module from within a doctest in a production module? I get an error that the test module could not be found
16:26:43 <chrisirc_> (or rather, just *use* the infrastructure there is)
16:28:42 <chrisirc_> shachaf, this is my starting point: https://github.com/petermarks/hoodlums-sessions/blob/master/xml.hs
16:29:39 <shachaf> I guess DList is the monad.
16:30:40 <niteria> :t (>=>)
16:30:41 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
16:31:21 <quchen> Is there a name for the transformation the "length" function uses - putting the return value in a parameter to become tail recursive? I.e. "length xs = 1 + length' xs" becomes "length = length' 0; length' n (_:xs) = length' (n+1) xs"
16:31:50 <ciaranm> "tail recursive" considered nonsense
16:31:55 <shachaf> quchen: Using an accumulator?
16:32:03 <shachaf> ciaranm: Why?
16:32:14 <ciaranm> shachaf: compilers do not work that way!
16:32:25 <shachaf> Who said anything about compilers?
16:33:40 <quchen> ... and even in the compiler case, why would it be nonsense?
16:34:35 <shachaf> I assume ciaranm means something like "evaluation, particularly non-strict evaluation, doesn't work the way you think".
16:35:06 <niteria> @src foldr
16:35:07 <lambdabot> foldr f z []     = z
16:35:07 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:35:47 <quchen> ... and he chose to say this because ...
16:35:52 <ciaranm> or more generally, mucking around with your code to get it into some arbitrary form you just made up in the hopes that doing so is what will make the compiler decide to rewrite out recursion is bad, because your compiler's notion of what it can and cannot do has little to do with what you think it does
16:36:32 <shachaf> You can get a pretty good model in your head of what GHC is going to compile your code into.
16:37:21 <shachaf> But it's not "push a stack frame on every function call, pop it on return, etc."
16:38:45 <niteria> it's g-machine somewhere below, right?
16:41:49 <monochrom> g-machine is too low-level, unnecessary for most needs
16:42:13 <monochrom> my http://www.vex.net/~trebla/haskell/lazy.xhtml is the right level for most purposes
16:42:34 <monochrom> (just work with expressions themselves, and care about sharing)
16:43:57 <monochrom> g-machine and down is just "what detailed data structures stand for expression nodes" and is beside the point unless you want to count "it's 30 bytes as opposed to 2 bytes"
16:44:19 <Philippa> which, to be fair, some people do
16:44:39 <monochrom> oh, when that happens, g-machine is too high
16:44:45 <Philippa> yep :-)
16:44:57 <Philippa> I figure Core's a reasonably nice level to think at
16:46:15 <hpaste> DanZimm pasted “projectile drag” at http://hpaste.org/84797
16:46:22 <johnw> common reaction to learning Haskell: https://i.chzbgr.com/maxW500/6629056768/hFEC05F8A/
16:46:47 <DanZimm> is there any witty way to make theta variable in that above code? i tried making it a variable but then it loses the caching stuff
16:46:50 <byorgey> that appears to be chemistry, not math!
16:47:06 <cmccann> yes, definitely chemistry
16:47:10 <johnw> haha
16:47:11 <fryguybob> That looks like my cat.
16:47:21 <monochrom> hmm reaction, chemistry...
16:47:29 <cmccann> must be a chemical burn, nothing to do with math!
16:51:18 <cmccann> DanZimm: you have rather a lot of unnecessary parentheses there
16:51:33 <DanZimm> :D
16:51:42 <glguy_> Does "MonoLocalBinds" do anything anymore? Is it supposed to?
16:52:06 <cmccann> DanZimm: what do you want to accomplish? memoizing intermediate expressions?
16:53:05 <monochrom> MonoLocalBinds still does something, since under normal conditions local binds are still polymorphic by default
16:53:52 <glguy_> Ah, I just read about how if the binding could have been lifted out of the local scope then it won't be considered
16:53:56 <cmccann> DanZimm: it looks like you're already doing some simple memoization there, why not do something similar for taking theta as a parameter?
16:54:11 <DanZimm> cmccann yes
16:55:09 <DanZimm> to first question that is
16:55:19 <cmccann> DanZimm: you just need some way to look things up by a non-integer key
16:55:21 <DanZimm> cmccann i tried and it became really slow
16:55:34 <cmccann> yeah I'm not sure you're going to gain anything here
16:55:36 <DanZimm> cmccann oh wow that gave me an idea
16:55:43 <cmccann> unless the computations are very expensive
16:55:50 <DanZimm> gotcha ok
16:56:01 <DanZimm> thank you
16:56:02 <cmccann> also depending on how many possible inputs you'll actually use and how many times you use them
16:57:43 <monochrom> consider: bundle_deal theta = (vx, vy, ax, ay, x, y) where { vx = your code; vy = your code; etc }
16:58:36 <augur> why okmij
16:59:33 <DanZimm> cmccann thanks for the insight :d
16:59:34 <DanZimm> :D
16:59:46 <nh2> I fond a priority queue implementation that looks good: pqueue
17:00:35 <Rotaerk> nh2, sounds like a reasonable name for such a thing
17:00:50 <nh2> Rotaerk: was still hard to find though
17:01:07 <nh2> "haskell priority queue" finds me mostly overly complicated or outdated pacakges
17:01:35 <Rotaerk> heh
17:05:22 <chrisirc_> I don't understand why DList would be a monad really; I'm trying to check by using >> or >>=, but that fails:
17:06:08 <otters> has anybody encountered "Can't parse --info output of GHC" with cabal-dev?
17:06:13 <chrisirc_> :t ((fromList [1,2,3]) :: DList Integer) >>= (cons (1 :: Integer))
17:06:15 <lambdabot>     Not in scope: `fromList'
17:06:15 <lambdabot>     Perhaps you meant one of these:
17:06:16 <lambdabot>       `IM.fromList' (imported from Data.IntMap),
17:06:45 <arkeet> chrisirc_: sure, that doesn't even work for ordinary lists.
17:06:49 <arkeet> > [1,2,3] >>= (1:)
17:06:51 <lambdabot>   No instance for (GHC.Num.Num [b0])
17:06:51 <lambdabot>    arising from a use of `e_11231'
17:06:51 <lambdabot>  Poss...
17:07:03 <arkeet> time to review what >>= does.
17:07:06 <arkeet> or at least what its type is.
17:07:14 <chrisirc_> (How does one import Data.DList into lambdabot?)
17:07:18 <arkeet> one doesn't.
17:07:24 <cmccann> :t (>>=)
17:07:26 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:07:27 <cmccann> :t concatMap
17:07:28 <lambdabot> (a -> [b]) -> [a] -> [b]
17:07:36 <cmccann> :t (=<<)
17:07:38 <lambdabot> Monad m => (a -> m b) -> m a -> m b
17:07:49 <arkeet> I guess it is there.
17:07:54 <arkeet> @type Data.DList.fromList
17:07:55 <lambdabot> [a] -> Data.DList.DList a
17:08:43 <monochrom> @type (1:)
17:08:45 <lambdabot> Num a => [a] -> [a]
17:08:52 <monochrom> oh, no wonder
17:09:19 <chrisirc_> :t Data.DList.cons
17:09:21 <lambdabot> a -> Data.DList.DList a -> Data.DList.DList a
17:09:24 <monochrom> you probably want instead (:[10,20,30])
17:10:08 <monochrom> therefore (flip cons (fromList [10,20,30]))
17:10:59 <cmccann> > (Data.DList.fromList [1,2,3] :: DList Integer) >>= flip cons (Data.DList.fromList [1])
17:11:01 <lambdabot>   Not in scope: type constructor or class `DList'Not in scope: `Data.DList.fr...
17:11:06 <cmccann> >:[
17:12:28 <monochrom> use Char instead of numbers so you can save some types
17:12:44 <cmccann> save the types!
17:13:38 <cmccann> hm, I seem to have tablet input with pressure sensitivity working with my slightly hacked up version of gtk2hs.
17:13:39 <monochrom> > Data.DList.fromList "abc"
17:13:41 <lambdabot>   Not in scope: `Data.DList.fromList'
17:13:53 <cmccann> monochrom: lambdabot is being contrary it seems
17:13:55 <monochrom> I see. oh well.
17:14:05 <monochrom> well, @type and > are different plugins
17:14:09 <cmccann> yep
17:14:48 <shachaf> Yes. @type allows values that aren't in scope; @run does not.
17:14:56 <shachaf> This is, I think, intended.
17:15:49 * monochrom thought up a suggestion, and then realized that Aesop's Fables already covered that
17:15:55 <otters> cabal-ghci and cabal-dev are both broken
17:16:02 <otters> is it because I'm using 1.17.*?
17:16:29 <otters> might
17:16:31 <otters> be
17:20:11 <otters> what the fuck is going on, cabal-install won't compile
17:20:44 <otters> somebody please explain what is going on https://gist.github.com/otters/6ff255bef2119c0f8cac
17:22:08 <lispy> otters: It's very hard to know what's going on with only the error message. From that it looks like the libraries you're using together are not compatible.
17:22:32 <monochrom> yeah, a version mismatch not caught by version bounds
17:24:29 <otters> oh, I should've compiled --global
17:24:33 <otters> Cabal, that is
17:24:44 <otters> I have Cabal 1.17 global and 1.16 local, that's the problem
17:25:04 <monochrom> that may or may not make a difference
17:26:58 <monochrom> very likely not make a difference
17:28:26 <lispy> I would advise against that
17:28:37 <monochrom> if, previously, the version bounds already erroneously allowed Cabal-1.17, then, even after Cabal-1.16 is present, the bounds will still allow Cabal-1.17
17:28:41 <lispy> Cabal comes with ghc and if something comes with ghc you should almost never upgrade it.
17:29:02 <otters> lispy: you're right, that didn't help
17:29:08 <otters> what's weird is that it looks like it's some kind of whitespace-related error
17:29:15 <monochrom> and cabal-install really loves to choose the newest version allowed
17:29:28 <otters> nvm, it worked
17:29:34 <otters> I removed Cabal-1.17.0 from global
17:29:39 <otters> ka blamo
17:29:51 <lispy> Is 1.17 on hackage yet?
17:30:08 <monochrom> seems no
17:30:18 <lispy> It's not listed, looks like 1.16.0.3 is the latest release
17:30:34 <otters> I think odd minor numbers are betas or whatever
17:30:43 <lispy> Unless you're trying to test something or need a specific unreleased feature, I recommend not upgrading beyond what you get on hackage :)
17:32:10 <black_joe> I am learning Haskell and I'm having trouble reading a declaration in Functor's definition.
17:32:13 <black_joe> https://www.refheap.com/paste/13062
17:32:27 <black_joe> Here, what is f? And what does -> f a mean?
17:32:36 <black_joe> I know they're type variables, but I can't understand why it's important.
17:32:50 <monochrom> concrete examples of "f" are [], Maybe, IO
17:32:54 <sw2wolf> black_joe: polymorhism
17:33:31 <monochrom> so, you have these variations: (a->b) -> [a]->[b], (a->b) -> Maybe a -> Maybe b, (a->b) -> IO a -> IO b
17:33:55 <black_joe> So then... Why isn't fmap defined as simply fmap :: (a -> b) -> [a] -> [b]?
17:34:01 <black_joe> I don't get what the f does in line two, rather.
17:34:13 <Axman6> because it works on more than lists
17:34:17 <monochrom> because some other times I want Maybe, not []
17:34:32 <Axman6> it's a generalised map for other structures (and functions, and other things)
17:34:44 <black_joe> Oh... That's what I was confused about. I thought it was specifically lists.
17:34:45 <Axman6> > fmap (+1) (Just 7)
17:34:47 <lambdabot>   Just 8
17:34:49 <black_joe> Thanks.
17:34:56 <sw2wolf> sorry! should be polymorphism
17:34:56 <Axman6> > fmap (+1) [1,2,3]
17:34:58 <lambdabot>   [2,3,4]
17:35:09 <Axman6> > fmap (+1) (Right 3)
17:35:10 <lambdabot>   Right 4
17:35:14 <Axman6> > fmap (+1) (Left 3)
17:35:16 <lambdabot>   Left 3
17:35:26 <Axman6> (confusing if you haven't seen Either yet)
17:35:33 <sw2wolf> (+1) (Right 3)
17:35:38 <sw2wolf> > (+1) (Right 3)
17:35:40 <lambdabot>   No instance for (GHC.Num.Num (Data.Either.Either a0 b0))
17:35:40 <lambdabot>    arising from a ...
17:35:50 <sw2wolf> it is right
17:35:56 <black_joe> I will go back and look at Either's definition. I've definitely used it before.
17:36:00 <sw2wolf> so fmap
17:36:03 <Axman6> src Either
17:36:05 <Axman6> @src Either
17:36:06 <lambdabot> Source not found. The more you drive -- the dumber you get.
17:36:08 <Axman6> urgh
17:36:17 <Axman6> data Either a b = Left a | Right b
17:36:34 <black_joe> Yeah, I found it in these notes. So that's kind of like Maybe.
17:36:50 <monochrom> black_joe: in the Either case, in concrete it's (a->b) -> Either x a -> Either x b. so, you could say, f = Either x
17:37:11 <oio> getting this on mac os x cabal: /Users/xxxxxx/Library/Haskell/bin: does not exist
17:37:27 <black_joe> Okay. What I thought originally was application, and I know that wasn't right.
17:39:03 * hackagebot diagrams-lib 0.6.0.2 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-0.6.0.2 (BrentYorgey)
17:41:26 * sw2wolf how does GHC find appropriate instances ? 
17:41:47 <monochrom> from imports, and their imports, ad infinitum
17:42:33 <monochrom> an instance exists iff the import graph happens to have it
17:43:06 <sw2wolf> monochrom: whether or not it uses Pattern Match as Prolog finds rules ?
17:43:39 <monochrom> it is a bit dumber than prolog. some hilarities ensue
17:44:12 <sw2wolf> what is "hilarities ensue" ?
17:45:10 <monochrom> I guess it is like this. you see "instance Show a => MonoClass [a]", and you want to know whether it's like prolog's MonoClass [a] :- Show a, right?
17:45:31 <monochrom> the answer is: it is like MonoClass [a] :- cut, Show a
17:45:48 <sw2wolf> yeah
17:47:14 <monochrom> therefore when you say "[Int -> Bool]" it already commits to "yes that's a MonoClass instance, but now, if you don't also have Show (Int -> Bool), that will be an irrecoverable error"
17:47:31 <sw2wolf> it seems haskell doesnot need cut, at least we donot need to use cut manually
17:48:26 <Tordek> does anyone remember what the function for combining parameters for sortOn is? I tried hoogling '(a -> b) -> (a -> c) -> a -> (b, c)' but no cigar
17:48:56 <shachaf> @ty (&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
17:48:57 <lambdabot> (a -> b) -> (a -> c) -> a -> (b, c)
17:49:11 <Tordek> thanks!
17:49:13 <shachaf> I don't know what sortOn is.
17:49:15 <shachaf> @hoogle sortOn
17:49:15 <lambdabot> No results found
17:49:28 <shachaf> See also: sortBy (comparing x <> comparing y <> comparing z)
17:49:30 <aCube> sortBy on
17:49:41 <aCube> :t on
17:49:42 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
17:51:48 <sw2wolf> monochrom: the context declaration is VERY helpful when searching appropriate instances
18:00:42 <CodeDmitry> Is a functor just the thing that associates two things together, like a Cartesian product/table?
18:03:07 <Rotaerk> CodeDmitry, no, a functor is something that a function can be mapped across
18:03:11 <arkeet> CodeDmitry: that's a function.
18:03:42 <arkeet> or relation
18:04:01 <Rotaerk> or map
18:04:45 <CodeDmitry> I mean isnt it something that accepts a function from a to b, and a structure constructor+object, and wraps the constructor on b and returns it?
18:05:33 <Rotaerk> no, and where are you getting "structure constructor+object" from
18:06:18 <CodeDmitry> (a->b)->F a -> F b, F a being structure wrapper and object a
18:06:32 <CodeDmitry> Its abuse of terminology
18:07:14 <Rotaerk> CodeDmitry, an example of a functor is a list, and an example of mapping a function across it is transforming [a, b, c, d] into [f a, f b, f c, f d]
18:07:49 <Rotaerk> that should illustrate the concept of a functor
18:09:47 <CodeDmitry> Yeah i was trying to understand the code but the fmap throws me off
18:10:02 <ChongLi> CodeDmitry: fmap is basically the same as map
18:10:11 <ChongLi> except instead of beign specialized to lists
18:10:18 <ChongLi> it works on any functor (including lists)
18:11:03 <ag90> CodeDmitry: For more on this, check http://www.haskell.org/haskellwiki/Typeclassopedia#Functor. It might help with the intuition.
18:11:20 <arkeet> it's important to remember that the notion of a functor is an abstraction.
18:11:27 <CodeDmitry> Yeah
18:12:27 <CodeDmitry> Crashed
18:13:57 <jmcarthur> CodeDmitry: in haskell, if you have  F :: * -> *  and  fmap :: (a -> b) -> (F a -> F b)  such that  fmap (f . g) = fmap f . fmap g, you have a functor. F can be any type constructor so long as you have fmap and it obeys the law. it's a bit less productive to think about what a functor "does" than simply what it "is"
18:14:19 <jmcarthur> that was a semi-formal explanation. depending on the way you think, it may or may not be helpful
18:15:46 <shachaf> jmcarthur: It is also necessary that fmap id = id
18:16:00 <shachaf> (In fact, it's sufficient in this case.)
18:16:01 <jmcarthur> shachaf: in hask that is implied by the law i gave
18:16:03 <jmcarthur> isn't it?
18:16:05 <arkeet> no
18:16:09 <shachaf> No, it goes the other way.
18:16:11 <jmcarthur> ah
18:16:18 <shachaf> For example: instance Functor [] where fmap _ _ = []
18:16:42 <jmcarthur> i actually had typed that one instead at first but convinced myself i was confused
18:16:44 <arkeet> with only the composition law, all you get is that fmap id is idempotent.
18:16:51 <jmcarthur> turns out i was confused, just not the way i thought i was :P
18:17:33 <jmcarthur> that would have been a better law for an explanation anyway since it's simpler :\
18:18:13 <jmcarthur> shachaf: yeah, not sure what i was thinking
18:18:18 <shachaf> I suspect it doesn't matter.
18:18:40 <jmcarthur> probably not immediately
18:19:08 <shachaf> I mean that person you're explaining to will be confused either way.
18:19:41 <jmcarthur> i am of the opinion that playing fast and loose with analogies tends to have negative effects in the long term even if they appear to help in the short term.
18:20:00 <shachaf> I agree.
18:20:06 <arkeet> so give correct and well-thought-out analogies instead.
18:20:09 <shachaf> The explanation is OK.
18:20:11 <ChongLi> it's hard to make an analogy of something so abstract
18:20:22 <ChongLi> it's the same problem with monads
18:20:24 <jmcarthur> so i like to give a somewhat formal explanation but then follow up with analogies if necessary
18:20:43 <jmcarthur> as long as you don't lose sight of the real explanation, analogies are probably okay
18:20:51 <ChongLi> using any real-world analogy is pretty much guaranteed to be too specific
18:20:55 <jmcarthur> yeah
18:21:05 <jmcarthur> arkeet: what is a "correct" analogy?
18:21:15 <jmcarthur> a model?
18:22:37 <ChongLi> honestly, for monads, I think a better way to explain is to forgo analogies or anything like that
18:23:07 <quchen> Boxes always worked well for my functors.
18:23:16 <quchen> For monads not so much though.
18:23:26 <shachaf> :-(
18:23:38 <arkeet> the only real way to get a handle on an abstraction is to have a good supply of examples.
18:23:41 <ChongLi> so in the case of the Maybe functor
18:23:46 <ChongLi> the box may or may not exist?
18:23:52 <cmccann> a monad is like a box full of burritos
18:23:56 <jmcarthur> examples and a precise, accurate explanation of the *actual* thing almost always works, if you're careful to not go too fast and make it too dense
18:24:37 <edwardk> its easy. just make the explanation too fast and dense, and if the person comes back 6 months later understanding it, then they are worth continuing to explain things too ;)
18:24:37 <quchen> ChongLi: Maybe is special. It's so easy the box analogy makes it more complicated. ;-)
18:24:41 <cmccann> I am convinced that analogies only make it harder to understand truly abstract concepts.
18:24:46 <arkeet> so you should have a bunch of things that share a common pattern, then recognize the pattern.
18:25:08 <johnw> edwardk: haha
18:25:11 <edwardk> er to
18:25:12 <johnw> edwardk: so that's why!
18:25:17 <ChongLi> just tell it straight up: a monad is an instance of the Monad class; it implements (>>=) and return and it satisfies the monad laws
18:25:20 <edwardk> i mean look at johnw.
18:25:30 <arkeet> this is how people come up with abstractions in the first place.
18:25:31 <quchen> ChongLi: Yeah that doesn't work.
18:25:36 <ChongLi> that's all there is to it
18:25:36 <cmccann> arkeet: a guided tour through reinventing the concept is sort of the logical conclusion of that approach
18:25:37 <jmcarthur> edwardk: is this the same kind of thing as the sorting algorithm where you check to see if the array is sorted and if it's not then you destroy the universe?
18:25:46 <ChongLi> just explain each of those things
18:25:47 <edwardk> i braindumped way too much on him, and now i've outsourced that portion of my explanation system ;)
18:25:47 <cmccann> arkeet: it works really well if it works at all
18:25:50 <arkeet> except for category theorists. they make abstractions just for the sake of abstracting.
18:25:52 <jmcarthur> edwardk: (therefore only universes in which the array is sorted can exist)
18:25:56 <ChongLi> and then give some examples
18:26:00 <edwardk> jmcarthur: yes, community by quantum bogosort
18:26:15 <cmccann> jmcarthur: quantum suicide bogosort is the best sorting algorithm
18:26:15 <quchen> Hello first grade. Sharpen your pencils, today we're talking about the Principia, because we don't want to give you false analogies
18:26:18 <quchen> Good idea.
18:26:40 <jmcarthur> quchen: nobody said it has to be so... boring
18:26:43 <johnw> a lot of my Haskell education now is realizing what edwardk meant six months ago
18:26:48 <arkeet> quchen: that's also the wrong way to go about it. :p
18:27:09 <arkeet> numbers are an abstraction too.
18:27:09 * sw2wolf thining whether or not it is possible to create a light wight haskell REPL. GHCi is too heavy ...
18:27:17 <quchen> arkeet: Well that's what "a monad is what fulfills the laws" feels like to a beginner. It's true, and it's completely useless.
18:27:22 <cmccann> arkeet: category theory originated from common abstractions in mathematics. I think people who just do category theory itself are at the point of creating generalized abstractions over other generalized abstractions, so it's kinda the same thing
18:27:25 <Philippa> sw2wolf: tried hugs?
18:27:28 <monochrom> I recommend http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#marktoberdorf
18:27:37 <arkeet> cmccann: my remark was supposed to be tongue-in-cheek. :p
18:27:53 <arkeet> oh crap, I forgot to mark it with a ":p"
18:28:14 <sw2wolf> Philippa: does hugs implement haskell standard completely ?
18:28:23 <jmcarthur> quchen: such an explanation is not a complete introduction. it's more of a reference to look at while going through the *actual* lesson
18:28:26 <monochrom> the p looks more like IO Tongue -> Tongue :)
18:28:31 <ChongLi> to understand the monad laws you just need to understand (>>=) and return
18:28:49 * cmccann thinks (<=<) is a better way to understand the monad laws
18:28:54 <cmccann> or join
18:28:56 <Philippa> sw2wolf: Bearing in mind that GHCi doesn't? No, it doesn't
18:28:56 <edwardk> cmccann: i agree
18:28:58 <cmccann> not (>>=)
18:28:58 * johnw agrees
18:28:58 * arkeet was about to say that.
18:29:01 <jmcarthur> quchen: since the reference can never be wrong, even though the lesson is very likely to contain errors and poor explanations. the reference makes it easy to fact check the conclusions you derive from the lesson
18:29:03 <arkeet> about <=<
18:29:06 <Philippa> you might want to go look up the list of infelicities, though
18:29:08 <cmccann> (>>=) is convenient for programming and desugaring do blocks
18:29:14 <edwardk> there is something fishy about that operator though
18:29:14 <cmccann> but it's conceptually obtuse
18:29:17 <quchen> cmccann: join is good for some monads, but for say State I find >>= easier.
18:29:18 <edwardk> i blame Cale
18:29:27 <ChongLi> cmccann: I disagree
18:29:29 <jmcarthur> (of course, the reference can be wrong if you aren't careful as my error earlier demonstrates...)
18:29:34 <arkeet> quchen: for State, >=>  is by far the easiest.
18:29:37 <jmcarthur> (which is really bad)
18:29:43 <arkeet> after all, a -> State s b ~ (a,s) -> (b,s)
18:29:45 <quchen> arkeet: I've never looked at >=> for state
18:29:48 <arkeet> and it's obvious how to compose such things.
18:29:49 <quchen> :s
18:29:50 <cmccann> yes, kleisli composition is always a good way to do it
18:29:57 <sw2wolf> :t (>=>)
18:29:57 <Philippa> cmccann: conceptually, you explain it exactly in terms of its role in do blocks - or rather, a generalised desugaring of (simple) let statements
18:29:59 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
18:29:59 <ab9rf> i stopped caring about whether i understood monads or not.  i just use them.
18:30:01 <cmccann> join is simple for container-ish functors like [] or Maybe
18:30:09 <cmccann> not so much when functions are involved
18:30:38 <Philippa> cmccann: sure it is. It's run<currentMonad>M
18:30:54 <arkeet> yeah, I have a hard time thinking about join for State.
18:31:10 <arkeet> it works well for a lot of monads though.
18:31:19 <cmccann> join for Reader is handy for pointless obfuscation
18:31:22 <quchen> For state, I think of join as >>= id ;-)
18:31:40 <jmcarthur> cmccann: oh? i find join for Reader to be quite intuitive...
18:31:44 <arkeet> :t id >=> id
18:31:45 <lambdabot> Monad m => m (m c) -> m c
18:31:52 <jmcarthur> it's just W
18:32:07 <quchen> jmcarthur: But you wouldn't use join for reader
18:32:18 <jmcarthur> quchen: i would for  ((->) a)
18:32:18 <cmccann> jmcarthur: yes. hence obfuscation via pointless, i.e. @pl
18:32:20 <quchen> join alone is fine, but I can't picture how it would be beneficial to think of it
18:32:20 <cmccann> :P
18:32:30 <quchen> (for Reader applications that is)
18:32:34 <jmcarthur> > join (*) 10
18:32:36 <lambdabot>   100
18:32:56 <ab9rf> :t join
18:32:57 <lambdabot> Monad m => m (m a) -> m a
18:33:00 <jmcarthur> > join (++) "foo"
18:33:03 <lambdabot>   "foofoo"
18:33:13 <arkeet> > join f x :: Expr
18:33:13 <ab9rf> ah
18:33:15 <lambdabot>   f x x
18:33:27 <cmccann> :t fmap fix return
18:33:28 <lambdabot> b -> b
18:33:32 <quchen> jmcarthur: sure. But when have you used that? How's that related to using 'ask'?
18:33:47 <jmcarthur> quchen: ((->) a)  is the implementation for Reader
18:33:51 <arkeet> ask = id
18:33:51 <jmcarthur> @unmtl Reader r a
18:33:52 <lambdabot> r -> a
18:33:57 <arkeet> asks = id, too
18:34:18 <arkeet> > ask 5
18:34:20 <lambdabot>   5
18:34:39 <jmcarthur> quchen: i use it when i have an operation that i want to put the same argument on both sides of
18:34:43 <sw2wolf> :t id
18:34:44 <lambdabot> a -> a
18:34:46 <cmccann> :t asks
18:34:48 <lambdabot> MonadReader r m => (r -> a) -> m a
18:34:50 <cmccann> :t reader
18:34:51 <lambdabot> MonadReader r m => (r -> a) -> m a
18:35:02 <quchen> jmcarthur: But then that's not really a Reader thing. join just happens to do the right thing.
18:35:16 <jmcarthur> quchen: i don't typically just say  "join foo bar"  when i could just say  "foo bar bar", but i do you "join foo" when the alternative is "\x -> foo x x"
18:35:17 <quchen> Like using <*> as S
18:35:24 <cmccann> no, duplicating inputs is exactly Reader's thing
18:35:28 <jmcarthur> quchen: it's not just a coincidence
18:35:40 <jmcarthur> quchen: nor is the (<*>) is S
18:35:43 <jmcarthur> *that
18:35:51 <monochrom> it is not so much wrong analogies but ambiguous natural language words
18:36:06 <jmcarthur> monochrom: yeah that happens a lot too :\
18:36:28 <jmcarthur> e.g. mempty/mappend  >:(
18:36:29 <ChongLi> join x = x >>= id
18:36:49 <arkeet> anyway, >>= is less intuitive than both join and >=>, I think.
18:36:51 <jmcarthur> class Appendable a   -- *shudder*
18:37:19 <quchen> Hmm. I don't think there's much of a difference between >=> and >>= understanding-wise
18:37:34 <jmcarthur> arkeet: it strikes a decent balance of usefulness, learnability, and typically clear implementation, though
18:37:39 <monochrom> >=> is a bit less expressive
18:37:48 <arkeet> no it isn't!
18:37:52 <arkeet> you can write >>= in terms of it.
18:37:56 <cmccann> quchen: try writing the monad laws using each and see which is clearer
18:38:09 <arkeet> :t (>=>)
18:38:11 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
18:38:13 <arkeet> >>= is just that where a = ()
18:38:38 <monochrom> I see
18:38:49 <quchen> cmccann: It has benefits, yes. Making this the only criterion is a little Texas sharpshooty.
18:40:14 <jmcarthur> i think it makes sense for Monad to have (>>=) and not (>=>), since implementing the latter directly is almost always slightly more complicated than implementing the former directly, even though i think (>=>) is more presentable
18:40:42 <copumpkin> "a monad is a thing that when you construct something that resembles the kleisli category, it actually is a category"
18:40:51 <cmccann> fmap, return, and join are orthogonal and sufficient, and (>=>) makes describing the laws and properties of monads easier
18:41:03 <ChongLi> newbies completely freeze up
18:41:07 <ChongLi> deer in the headlights
18:41:11 <jmcarthur> well, (>=>) makes the laws more concise, at least
18:41:13 <ChongLi> at the mere mention of categories
18:41:16 <monochrom> a wrong analogy could still be useful, for learning and for practice. the important point is that it is unambiguous, so that there is a clear "it is right on these points" and "it is wrong on these points", and you can learn from them.
18:41:21 <jmcarthur> the derivation of those laws is further obscured, though
18:41:23 <arkeet> I think the Kleisli arrows themselves are easier to think about.
18:41:30 <arkeet> how could it be any easier than   a -> State s b = (a,s) -> (b,s)
18:41:50 <ChongLi> soon thereafter you begin talking about morphisms and their eyes glaze over!
18:41:51 <cmccann> arkeet: that's what using (>=>) is doing, modulo newtype wrappers
18:41:59 <arkeet> yes, it's composing such things.
18:42:12 <jmcarthur> monochrom: sure. my only really strong claims is that the actual definition should usually be at the forefront even while using analogies in order to make sure things don't get out of control
18:42:16 <monochrom> ambiguous natural language wording is open to constantly moving the goalpost to make it "right", so that it is not refutable. you learn nothing from an irrefutable claim.
18:42:16 <jmcarthur> *claim
18:42:21 <arkeet> but looking it that way makes it really clear what composing State actions does.
18:42:40 <arkeet> IMO.
18:42:40 <cmccann> monochrom: possibly more important is that the analogy be wrong in ways that lead you in the direction of the right thing
18:43:04 <cmccann> getting a shove in the right direction and a "good luck, you're on your own now" is better than being led down a blind alley
18:44:03 <ChongLi> another analogy I tried to use with someone is that composing a bunch of monadic actions together is like building up a data structure which will later be executed like a shell script
18:44:15 <ChongLi> (in the case of IO)
18:44:19 <ChongLi> is that a good one?
18:44:20 <arkeet> and I think it helps that Kleisli arrows actually *do* things.
18:44:34 <Philippa> ChongLi: it's good enough that for any monad there is going to be a reasonable decomposition that way
18:44:57 <shachaf> Philippa: Even Cont?
18:44:58 <quchen> It's pretty good for "holds exactly one value" monads
18:45:09 <ChongLi> haha
18:45:18 <shachaf> quchen: What is a "holds exactly one value" monad?
18:45:30 <ChongLi> to understand the continuation monad just put your brain in a blender and press the puree button!
18:45:34 <jmcarthur> quchen: no, this works for other kinds of monads, too
18:45:41 <monochrom> when I said ">=> is a bit less expressive", I used an analogy. but it is an unambiguous, mathematical analogy. I was thinking Arrow. therefore, it was possible to see where the difference was.
18:45:43 <Philippa> shachaf: I reckon so. It's probably a somewhat amusing one though
18:45:45 <ab9rf> ChongLi: how would that change anything?
18:45:55 <quchen> shachaf: All but Maybe, List and Cont.
18:46:02 <quchen> Cont is just on that list because.
18:46:09 <arkeet> Either isn't on that list.
18:46:12 <jmcarthur> quchen: for example, a Maybe Int is a script that either returns a value of type Int or doesn't
18:46:15 <ChongLi> ab9rf: that way your mind can follow the strange flow of execution
18:46:24 <shachaf> quchen: I don't know what you mean but it doesn't sound right.
18:46:25 <Philippa> shachaf: one whose implementation always has exactly one continuation or analogue thereof in hand
18:46:37 <Philippa> (but it's easy for me to say that now I know how the concept works)
18:46:38 <shachaf> How many values does (x :: Bool -> Char) hold?
18:46:39 <arkeet> sounds pretty vague.
18:46:39 <arkeet> :p
18:46:46 <ChongLi> I guess you could say the same thing about laziness in general
18:46:47 <shachaf> (The monad here is (Bool ->), of course.)
18:46:50 <monochrom> whereas with popular natural language cliches such as "monad is about computation" and "arrow is about computation" you will go nowhere. you can keep moving the definition of "computation" to fit everything.
18:47:04 <ChongLi> that it may not be immediately obvious what order things will evaluate in
18:47:24 <monochrom> down with natural languages!
18:47:31 <Philippa> monochrom: that's what happens when people forget that "computation" was supposed to be a term of art that might as well have been 'program'
18:47:32 <arkeet> >=> is less expressive than >>= in the same way that (.) is less expressive than function application.
18:47:34 <cardamon> Up with skirts!
18:47:40 <cardamon> Wait..what?
18:47:42 <jmcarthur> shachaf: it holds  Char^2  of course (plus an extra for _|_) :P
18:47:48 <jmcarthur> cardamon: this isn't the place
18:47:58 <kfish> jmcarthur, +1
18:48:06 <Philippa> jmcarthur: cheers
18:48:12 <shachaf> jmcarthur: Right, so Reader should be in that list, right?
18:48:36 <jmcarthur> shachaf: i am neither a lover nor a hater of the container analogy
18:48:41 <cardamon> Sorry, crude humor bleeding over from other rooms.    I'm very unfocused tonight.
18:48:50 <ChongLi> another thing I find interesting to explain is sum types and product types
18:49:25 <shachaf> jmcarthur: But any analogy that applies to, say, Stream should also apply to (Nat ->), surely.
18:49:58 <jmcarthur> cardamon: it's all good. just be aware that we want to be as welcoming of a community as we can and that even if you don't mean anything overtly offensive that doesn't mean nobody will be uncomfortable about certain kinds of jokes
18:50:14 <shachaf> jmcarthur++
18:50:22 <cmccann> the container analogy works best on monads that aren't in the same room as shachaf.
18:50:53 <jmcarthur> shachaf: i have no intention of attacking or defending the container analogy
18:51:01 <jmcarthur> i'd rather just attack analogies ;)
18:52:04 <cardamon> Um...what's the =<< operator do?  It's not on the list I have.
18:52:12 <arkeet> it's a flipped >>=
18:52:13 <jmcarthur> it's flip (>>=)
18:52:16 <jmcarthur> :t (=<<)
18:52:17 <lambdabot> Monad m => (a -> m b) -> m a -> m b
18:52:21 <jmcarthur> it lives in Control.Monad
18:55:37 <cardamon> Oh, so you have two operators with the same function but different associativity?
18:55:49 <shachaf> cardamon: Useful tool:
18:55:51 <shachaf> @where hoogle
18:55:51 <lambdabot> http://haskell.org/hoogle
18:56:05 <shachaf> The associativity isn't the point. The arguments are flipped.
18:56:07 <shachaf> Look at the types.
18:56:22 <ChongLi> cardamon: it makes more sense when you're writing it out in code
18:56:28 <arkeet> f =<< x  =  x >>= f
18:56:33 <cmccann> that said, they do have opposite associativity as well
18:56:42 <ChongLi> if you imagine it as a pipeline you can think of it as reversing the direction
18:57:20 <cardamon> I'm doing a course in language concepts, so syntax, semantics, and bindings are fresh in my head.
18:57:42 <arkeet> the argument order for =<< is supposed to remind you of function application.
18:57:44 <cmccann> so that (x >>= f >>= g) and (g =<< f =<< x) mean the same thing
18:58:03 <ChongLi> a lot of the stuff we do in functional programming is so that composition is easier/possible
18:58:28 <cmccann> composition is more (>=>) or (<=<)
18:58:36 <jmcarthur> i wish there was a prefix version of (=<<) in the standard libs
18:58:46 <shachaf> @let dnib = (=<<)
18:58:48 <jmcarthur> it's nice to think of it as a function transformation
18:58:48 <lambdabot>  Defined.
18:59:04 <jmcarthur> i also like numbered variants, similar to liftA2, liftA3, etc.
18:59:25 <jmcarthur> @let dnib2 f x y = x >>= \a -> y >>= \b -> f x y
18:59:27 <lambdabot>  Defined.
18:59:30 <jmcarthur> :t dnib2
18:59:32 <lambdabot> Monad m => (m a -> m a1 -> m b) -> m a -> m a1 -> m b
18:59:36 <jmcarthur> err
18:59:36 <shachaf> @ty (.)
18:59:37 <lambdabot> (b -> c) -> (a -> b) -> a -> c
18:59:39 <jmcarthur> duh
18:59:39 <shachaf> whoa, dude
18:59:42 <jmcarthur> i'm wrong
18:59:48 <arkeet> jmcarthur: nice id.
19:00:05 <shachaf> jmcarthur: It's join (liftM2 f x y) and so on
19:00:10 <cmccann> jmcarthur: I have "bind" in my prelude replacement as a prefix (=<<)
19:00:22 <jmcarthur> oh i see what i did
19:00:26 <jmcarthur> derp
19:00:26 <cmccann> and I still like my (=<*) operator even if nobody else does
19:00:37 <arkeet> what does that do?
19:00:39 <jmcarthur> :t \f x y -> x >>= \a -> y >>= \b -> f a b
19:00:40 <lambdabot> Monad m => (a -> a1 -> m b) -> m a -> m a1 -> m b
19:01:19 <cmccann> it's (=<*) :: m (a -> m b) -> m a -> m b
19:01:22 <jmcarthur> arkeet: that wasn't id, actually
19:01:30 <cmccann> =<* does exactly what it looks like
19:01:30 <arkeet> true.
19:01:32 <jmcarthur> arkeet: it still performed the effects of x and y
19:02:04 <jmcarthur> cmccann: i'm trying to think of situations where i would have wanted that...
19:02:12 <cmccann> so I can write e.g. "f <$> x <*> y =<* z"
19:02:27 <cmccann> jmcarthur: it's like (<*>) except when the function ends with a monadic result
19:02:42 <jmcarthur> i see *what* it is, i just don't see why i want it :P
19:02:51 <quchen> Seconded
19:03:06 <quchen> Also =<* looks like it could be from Lens ;-)
19:03:12 <jmcarthur> i will be looking for this pattern now, though, of course
19:03:34 <jmcarthur> but i really don't think this comes up often for me...
19:03:36 <cmccann> jmcarthur: you were just trying out the type of something where you'd use it :P
19:04:28 <jmcarthur> i don't see it immediately
19:04:30 <linduxed> is there a substitute command for strings?
19:04:31 <cmccann> jmcarthur: e.g. "\f x y -> f <$> x =<* y :: (Monad m, Applicative m) => (a1 -> a -> m b) -> m a1 -> m a -> m b"
19:05:08 <jmcarthur> eh
19:05:11 <shachaf> @ty \f x y -> join (f <$> x <*> y)
19:05:12 <lambdabot> (Monad m, Applicative m) => (a2 -> a1 -> m a) -> m a2 -> m a1 -> m a
19:05:24 <cmccann> shachaf: yeah that's the same thing
19:05:29 <linduxed> so that for instance if i have "Hello there, mister linduxed, come in." id be able to say "replace the ", " with ";_"" for instance
19:05:58 <cmccann> jmcarthur: it's not that uncommon to have a function with a type that looks like "a -> b -> ... -> m c"  for some number of arguments
19:06:26 <cmccann> this is just so that I can use functions like that infix-y applicative style
19:06:32 <quchen> linduxed: The Regex libs will solve the problem for sure. Not beautiful but will do the trick
19:06:38 <shachaf> cmccann: Now make a trick that lets you do (a -> m b -> c -> m d) -> m a -> m b -> m c -> m d
19:06:49 <ChongLi> now you have two problems!
19:07:09 <jmcarthur> cmccann: right. i also prefer liftA* over a chain of (<*>) though, so maybe this is why i don't favor your style
19:07:21 <cmccann> jmcarthur: that might explain it yes!
19:07:44 <Philippa> jmcarthur: so I don't because it forces me to count
19:07:44 <arkeet> jmcarthur: finally, someone who agrees with me!
19:07:55 <shachaf> <lexande> sometimes i am confronted with a problem and i think "I know, I'll use Banach-Tarski"
19:07:56 <jmcarthur> Philippa: haha
19:07:57 * cmccann uses liftA* when lifting somepoint pointlessly, but (<*>)s when writing it out pointfully
19:07:59 <arkeet> Philippa: how often do you use liftAn for n >= 3?
19:08:02 <linduxed> quchen: hmmm, i'm starting to think that maybe i should work on my data structure instead...
19:08:19 <cmccann> ...somepoint?
19:08:20 <Philippa> arkeet: I don't. Pointedly.
19:08:36 <cmccann> I got a little carried away there it seems
19:08:48 <arkeet> I am a fan of liftA2.
19:09:07 <Philippa> 2 makes a fair idiom for things that we think of as binary operators, yeah
19:09:11 * hackagebot binary-file 0.13.2 - read/write binary file  http://hackage.haskell.org/package/binary-file-0.13.2 (YoshikuniJujo)
19:09:21 <Philippa> tasks like parsing can end up with n somewhat bigger than 2, though
19:09:29 <arkeet> sure.
19:09:35 <jmcarthur> i admit that it's a bit unsatisfying that liftA* doesn't scale the way (<*>) does
19:09:42 <jmcarthur> but for the common case i think it's nice
19:09:43 <monochrom> if you have an Applicative Functor f, plus somehow someone gives you (=<*) :: f (a -> f b) -> f a -> f b, then you can make f Monad.
19:09:55 <Philippa> as can anything which uses an intentionally more-applicative-than-average style
19:10:09 <quchen> cmccann: So I've been trying to figure out the rationale behind using "=<*" for 5 minutes now and don't understand how that name is canonical. Care to explain?
19:10:29 <cmccann> quchen: it's a cross between (=<<) and (<*>)
19:10:32 <jmcarthur> yeah parsing the best example i can think of to favor (<*>) over liftA* more frequently
19:10:32 <cmccann> a visual pun
19:10:38 <jmcarthur> *parsing is the
19:10:42 <quchen> cmccann: Aaaaah, <*>, not <*
19:10:57 <arkeet> =<*>
19:10:58 <quchen> I thought "why the hell does he have <* in there"
19:11:00 <quchen> Yeah
19:11:01 <cmccann> or perhaps a visual portmanteau
19:11:07 <arkeet> =<<*>
19:11:09 <Philippa> jmcarthur: logic programming's a good one, too
19:11:14 <jmcarthur> oh?
19:11:30 <Philippa> especially if you have a reason to avoid >>=
19:11:31 <jmcarthur> i've not had this come up with logic programming so much
19:11:45 <jmcarthur> (i do typically avoid (>>=) if i don't need it)
19:13:02 <cmccann> jmcarthur: anyway, hopefully you can at least see the value of something like (=<*) given the assumption of writing things in Applicative infix-y style
19:13:03 <jmcarthur> the main reason i like liftA* is the same reason i tend to like a lot of point free code, which is that it is more composable
19:13:46 <jmcarthur> i typically prefer transforming functions over transforming function applications
19:13:55 * cmccann does wish that Monad implied Applicative as it should and that liftM* meant "liftA* followed by join"
19:14:04 <jmcarthur> yeah
19:14:08 <cmccann> rather than having so many redundant functions
19:14:39 <jmcarthur> and we could also get rid of liftA and liftM!
19:14:56 <cmccann> liftA was gotten rid of preemptively
19:15:00 <jmcarthur> (or keep them around as defaults for fmap if we want)
19:15:01 <cmccann> because why would that even exist :P
19:15:06 <jmcarthur> yeah
19:15:14 <jmcarthur> didn't realize it's gone, actually
19:15:26 <cmccann> did it ever exist? that would be silly.
19:15:31 <jmcarthur> i thought it did
19:15:43 <cmccann> oh apparently it did
19:15:44 <cmccann> heh
19:15:46 <cmccann> that's hilarious
19:15:52 <jmcarthur> it still exists...
19:15:56 <jmcarthur> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
19:16:13 <cmccann> huh
19:16:28 <jmcarthur> i think it's reasonable since you can just implement Applicative and then use liftA as your implementation for fmap
19:16:29 <cmccann> I thought I had all of Control.Applicative imported
19:16:49 <jmcarthur> since as implementing Monad and then using return and ap for Applicative
19:16:52 <jmcarthur> *same as
19:17:02 <cmccann> I guess I must have excluded that ages ago because it's mostly useless and then forgotten it existed at all
19:18:13 <ludamad> Any advice for choosing packages on hackage ?
19:18:23 <ludamad> I search JSON and get an overwhelming amount of results
19:18:32 <jmcarthur> my favorite property of liftA*...    liftA2.liftA2.liftA2  does the most sensible thing possible
19:18:38 <ludamad> (well, using 'cabal list', anyway)
19:18:41 <johnw> ludamad: yeah, discoverability is not the highest
19:18:43 <johnw> ask here
19:19:26 <ludamad> OK, I'm looking to do a chat server after messing around with some stuff like sudoku solver in haskell etc
19:19:30 <jmcarthur> hmm, wonder if bind2 has the same nice property... i doubt it since monads don't compose in general
19:19:34 <jmcarthur> @undef
19:19:47 <monochrom> in the case of JSON, I recommend aeson
19:19:47 <jmcarthur> @let bind2 f a b = a >>= \x -> b >>= \y -> f x y
19:19:49 <lambdabot>  Defined.
19:19:53 <jmcarthur> :t bind2
19:19:54 <lambdabot> Monad m => (a -> a1 -> m b) -> m a -> m a1 -> m b
19:19:55 <jmcarthur> :t bind2.bind2
19:19:57 <lambdabot> Monad m => (a -> a1 -> m b) -> m (m a) -> m (m a1) -> m b
19:20:06 <ludamad> monochrom: TY
19:20:11 <jmcarthur> oh, still pretty sensible
19:20:17 <jmcarthur> just not the same
19:20:22 <cmccann> jmcarthur: all the liftA* functions compose nicely that way, don't they
19:20:33 <jmcarthur> yup!
19:20:42 <jmcarthur> :t liftA4.liftA4.liftA4
19:20:43 <lambdabot>     Not in scope: `liftA4'
19:20:44 <lambdabot>     Perhaps you meant one of these:
19:20:44 <lambdabot>       `liftA' (imported from Control.Applicative),
19:20:51 <jmcarthur> :t liftA3.liftA3.liftA3
19:20:53 <lambdabot> (Applicative f2, Applicative f1, Applicative f) => (a -> b -> c -> d) -> f (f1 (f2 a)) -> f (f1 (f2 b)) -> f (f1 (f2 c)) -> f (f1 (f2 d))
19:21:04 <shachaf> I.e., both liftA* functions.
19:21:15 <jmcarthur> :t foldMap.foldMap.foldMap
19:21:16 <lambdabot> (Foldable t2, Foldable t1, Foldable t, Monoid m) => (a -> m) -> t (t1 (t2 a)) -> m
19:21:23 <jmcarthur> :t traverse.traverse.traverse
19:21:24 <cmccann> jmcarthur: liftA0 would compose that way too if it existed!
19:21:25 <lambdabot> (Applicative f, Traversable t2, Traversable t1, Traversable t) => (a -> f b) -> t (t1 (t2 a)) -> f (t (t1 (t2 b)))
19:21:33 <cmccann> well, existed by that name
19:21:34 <jmcarthur> i love these things
19:21:41 <jmcarthur> :t fmap.fmap.fmap
19:21:42 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
19:22:08 <jmcarthur> what, pure?
19:22:10 <jmcarthur> :t pure.pure.pure
19:22:12 <lambdabot> (Applicative f2, Applicative f1, Applicative f) => a -> f (f1 (f2 a))
19:22:14 <cmccann> yes
19:23:20 <monochrom> soon, you will conceive liftA-1 and liftA1/2
19:23:54 <cmccann> jmcarthur: in fact, liftA0 and liftA2 would suffice to define Applicative, which makes a great deal of sense
19:23:57 <jmcarthur> i got so confused for a second because i've had negative and fractional types on my mind this evening
19:24:08 <jmcarthur> cmccann: yup!
19:24:13 <monochrom> haha
19:24:18 <jmcarthur> cmccann: and liftA for Functor
19:24:58 <cmccann> pity this doesn't generalized nicely to monads
19:25:07 <cmccann> or to comonads or contravariant functors or much of anything else
19:25:10 <jmcarthur> well that's kind of the point, really
19:25:28 <jmcarthur> monads can't be described with liftA<anything>
19:25:41 <cmccann> yeah
19:25:50 <cmccann> applicative is so much tidier
19:26:23 <jmcarthur> applicative is kind of "first order" in some way i can't find the words to describe
19:26:58 <monochrom> perhaps "a -> m b" is like exponentiation and so you need a infinite series of liftAn's to get >>=
19:26:59 <cmccann> jmcarthur: well it's kinda first order the same way Arrow without ArrowApply is
19:27:06 <jmcarthur> yeah
19:27:25 <jmcarthur> monochrom: hmm...
19:27:29 <jmcarthur> liftInf
19:27:31 <jmcarthur> :)
19:27:44 <cmccann> and when doing stuff with Applicative the functor structure and the parametric component can't influence each other causally
19:27:59 <cmccann> liftAω?
19:28:00 <monochrom> oh, on Applicatve, Arrow, and Monad, I recommend http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#arrows-and-idioms
19:29:17 <jmcarthur> oh, i've read about an alleged equivalence between Arrow and Category+Applicative, but i didn't realize wadler had some writing on arrows and idioms(/applicative-i-assume)
19:29:34 <monochrom> yes, idiom = applicative
19:29:48 <jmcarthur> oh i have seen this before
19:29:55 <jmcarthur> never read it, just the title
19:29:59 <monochrom> idiom was an old name when it was first invented
19:30:21 <jmcarthur> yeah
19:30:23 <slack1256> I cannot find a tutorial of generic programming with just Data.Data
19:30:31 <slack1256> or people don't use Data.Data directly?
19:30:41 <jmcarthur> depends on what you're trying to do
19:31:08 <slack1256> what would be the most popular option?
19:31:24 <jmcarthur> (i tend to avoid generic programming unless i have a great reason to use it, which is not crazy)
19:31:39 <jmcarthur> slack1256: i meant it. it depends on what you're trying to do
19:31:43 <slack1256> is the typical example of an enterprise and modifying salaries
19:31:59 <slack1256> oh, not this is just for learning
19:32:30 <jmcarthur> slack1256: i find generics are pretty great for generic typeclassy things. uniplate (and now lens) are good for kind of reaching into some random structure and manipulating things in a fairly ad hoc way
19:33:08 <cmccann> jmcarthur: also, keep in mind that the connection between Applicative and Monad is kind of a useful coincidence due to the nature of Hask
19:33:19 <cmccann> the more general versions of each in category theory don't have that relationship
19:33:22 <jmcarthur> cmccann: i was not actually aware of that
19:33:26 <slack1256> oh, I didn't know that uniplate and lens had that kind of relation.
19:33:35 <edwardk> slack1256: lens contains a port of uniplate
19:33:43 <jmcarthur> slack1256: lens kind of subsumes uniplate in a way
19:33:51 <jmcarthur> slack1256: (and it's faster, iirc)
19:33:55 <edwardk> > ("hello","world",["!!!"])^..biplate :: [String]
19:33:57 <lambdabot>   ["hello","world","!!!"]
19:34:15 <edwardk> > ("hello","world",["!!!"]) & partsOf biplate %~ (reverse :: String -> String)
19:34:18 <lambdabot>   ("!!!dl","rowol",["leh"])
19:34:33 <slack1256> mmm this is getting interesting.
19:34:33 <cmccann> jmcarthur: you might find my answer to http://cstheory.stackexchange.com/q/16241/53 interesting
19:34:38 <johnw> > (("hello","world"),"!!!", 2 :: Int, ()) % biplate._head %~ toUpper
19:34:40 <lambdabot>   Not in scope: `%'
19:34:40 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
19:34:48 <johnw> > (("hello","world"),"!!!", 2 :: Int, ()) & biplate._head %~ toUpper
19:34:49 <edwardk> & =)
19:34:49 <lambdabot>   No instance for (Control.Lens.Cons.Cons
19:34:50 <lambdabot>                     (->)
19:34:50 <lambdabot>           ...
19:34:58 <johnw> hmm.. that worked before
19:35:08 <edwardk> _head is more general than it used to be
19:35:13 <edwardk> doesn't know that should be a list
19:35:18 <slack1256> so generics for classical generic programming, then lenses for the new kid on the block and exploratory on structures.
19:35:22 <monochrom> I think I can summarize what Wadler says. Consider chaining two effectful actions. all 3 of Applicative, Arrow, Monad let you do that. and the difference is:
19:35:30 <slack1256> ok that will be then
19:35:36 <edwardk> i use lens for my generic programming mostly.
19:35:43 <monochrom> Applicative says: the "return value" of the first action cannot be fed into the second
19:36:05 <edwardk> being able to just say 'rewrite (\case Neg (Lit a) -> Just (Lit (-a)); _ -> Nothing)' and get a bottom up rewrite of a syntax tree is really nice
19:36:22 <monochrom> Arrow says: can be fed, with this restriction: must be through the >>> mechanism. for example, cannot use function application
19:37:13 <monochrom> Monad says: can use function application, the second action can have whatever dependency you like on the "return value" of the first action
19:37:31 <jmcarthur> cmccann: cozip looks useful at least. coap looks like lambda abstraction in HOAS, and i guess copure would be some sort of eval function
19:38:04 <cmccann> well, cozip is either trivial or underspecified
19:38:18 <jmcarthur> cmccann: oh, right
19:38:26 <shachaf> cmccann: Well, isn't everything?
19:38:31 <jmcarthur> ignore my remarks on cozip
19:40:21 <cmccann> jmcarthur: what cozip probably "wants" to be is something like partitionEithers, which goes from coproduct to product while doing something more meaningful with the functor structure
19:41:09 <cmccann> shachaf: nah, somethings are fully specified and non-trivial. we usually call those "programs".
19:41:32 <shachaf> Aren't all programs either trivial or impossible, by definition?
19:41:54 <cmccann> shachaf: sounds like you're thinking of rice's theorem
19:41:57 <jmcarthur> what definition of trivial is that?
19:42:10 <monochrom> haha, Rice's theorem yeah
19:42:14 <cmccann> which is about figuring out what programs do, not the thing they do itself
19:42:14 <Jello_Raptor> so i'm going to be looking for jobs soon, and i'd appreciate if anyone has any suggestions(haskelly jobs would be awesome), i'm keeping a list here http://goo.gl/SNrkL
19:42:50 <cmccann> so programs can do nontrivial things, you just can't be sure that they're doing what you think they're doing in general
19:43:02 <jmcarthur> Jello_Raptor: Jane Street Capital! (disclaimer, i work for JSC)
19:43:16 <jmcarthur> err
19:43:22 <jmcarthur> s/disclaimer/full disclosure/
19:43:50 <cmccann> jmcarthur: anyway, that's an interesting point about HOAS, hadn't occurred to me
19:44:36 <jmcarthur> cmccann: i in fact implement a lot of my hoas stuff with applicative + that lambda function, at least when i allow pure
19:44:40 <cmccann> that version of a "CoApplicative" doesn't work as such, but there might be something interesting with similar types
19:45:32 <cmccann> just wouldn't be dual to Applicative in any obvious way
19:45:39 <gienah> Jello_Raptor: a short list  here
19:45:47 <gienah> http://cufp.org/jobs
19:47:15 <cmccann> jmcarthur: anyway, the original point was that the post touches on how Applicative and Monad only relate the way they do in the context of Hask
19:47:20 <jmcarthur> yeah
19:47:28 <cmccann> which is why there's no dual Applicative with a similar relationship to Comonad
19:47:44 <jmcarthur> i admit that i only skimmed, but i saw mention of endofunctors, and i imagine that is the biggest thing relating them
19:48:30 <cmccann> yes, a generalized Applicative makes sense for a functor between monoidal closed categories that preserves that structure
19:48:37 <Jello_Raptor> jmcarthur: gienah: thanks :)
19:48:49 <cmccann> which includes non-endofunctors obviously
19:49:15 <cmccann> as well as categories that are monoidal closed but not cartesian closed
19:49:23 --- mode: ChanServ set +o glguy
19:49:32 --- mode: glguy set -qo *!*@gateway/web/freenode/ip.24.114.22.17 glguy
19:49:34 <cmccann> which sounds like a subtle distinction but actually makes quite a bit of difference
19:51:58 <cmccann> anyway the important thing is that I used the latex support on cstheory.se to make that answer look way more authoritative
19:52:14 <cmccann> just look at how "Hask" is written
19:52:19 <cmccann> very official-looking
19:56:10 <jmcarthur> yes, that was my takeaway, too
19:56:51 <shachaf> cmccann: I hate official-looking category theory things.
19:57:00 <shachaf> I can never tell which letters are which.
19:57:31 <monochrom> haha
19:57:42 <cmccann> most letters look like themselves unless they're written in fraktur
19:58:09 <monochrom> yeah, fraktur is the problem :)
19:59:45 <DarkFox> Does acid-state's tcp server support encryption or just raw anyone who can talk can manipulate?
19:59:46 * cmccann doesn't really see fraktur used that often
20:02:14 <monochrom> I just read Ralf Hinze's MPC 2010 paper, which used Fraktur letters
20:02:28 <cmccann> to indicate what?
20:02:30 <johnw> 𝔠𝔪𝔠𝔠𝔞𝔫𝔫
20:02:37 <DarkFox> How might one use acid-state with tls?
20:02:56 <cmccann> johnw: hahaha don't tempt me to start that
20:03:29 <johnw> i tempt thee, good sir
20:03:44 <monochrom> suppose you have "data List = Nil | Cons Int List". but he wants to talk about the open-recursion version of that. so he uses Fraktur...
20:03:53 <cmccann> monochrom: ...whyyyy
20:03:59 <cmccann> :[
20:04:05 <johnw> although, for whatever reason my new shiny Emacs doesn't display fraktur, even though it's the same font
20:04:06 <johnw> sigh
20:04:11 <monochrom> data FrakturList a = FrakturNil | FrakturCons Int a
20:04:44 <cmccann> johnw: I got bored with my unicode abuse program when someone wrote a better one, I forget who
20:04:48 <monochrom> well, changing font is easier than coining new names
20:05:47 <cmccann> monochrom: people should start using east asian characters for stuff
20:06:05 <cmccann> surely those are at least as common in unicode fonts as fraktur nonsense
20:06:10 <cmccann> and there's so many to pick from!
20:06:50 <monochrom> to a large extent, I like change fonts and keeping the same letters to indicate that two things are closely related
20:08:19 <cmccann> yeah but... fraktur
20:08:25 <cmccann> half the time they don't even look like the same letter
20:08:27 <cmccann> madness!
20:08:59 <monochrom> hehe
20:09:30 <cmccann> seriously I can read English transliterated in katakana almost as fast as I can read stuff written in some fraktur fonts
20:09:58 <Rants> katakana engrish can get pretty tough to parse
20:10:14 <Rants> it's easier for me to read straight japanese
20:10:25 <cmccann> it's phonetic and usually unambiguous what English word it should be
20:10:35 <monochrom> for this paper, you don't need to perfectly read Fraktur, since the normal version and the Fraktur version are given together
20:10:39 <cmccann> with a few obvious difficulties that are usually clear in context
20:10:51 <Rants> I just really have trouble with it
20:10:58 <Rants> like even just a couple of words
20:11:00 <cmccann> also I don't know enough Japanese to read it so that kind of puts me at a disadvantage there
20:11:27 <Rants> half the time something's in katakana it isn't English anyway
20:11:40 <cmccann> basic grammar and phonetic scripts? sure. building vocabulary and memorizing kanji? ehhhh attention span what's that
20:11:44 <Rants> which is easier to read
20:12:01 <Rants> kanji is infinitly easier to read than katakana english omg you have no idea
20:12:16 <cmccann> no, I agree
20:12:29 <cmccann> for all like ten kanji I can remember at least
20:12:31 <cmccann> sigh
20:13:05 <Rants> it's just an instantly recognizable thing
20:13:36 <Rants> but it can take me upwards of five minutes just to recognize an english word that's been transliterated into katakana
20:13:50 <Rants> and then I feel stupid when I realize what word it was
20:14:00 <cmccann> especially if it's a misused and abused loanword
20:14:02 <cmccann> those are always fun
20:14:29 <cmccann> or an English word shortened in a way that only makes phonetic sense in Japanese
20:15:07 <monochrom> whenever computer stuff written in Japanese comes up, it takes two persons --- me and my sister --- to read
20:15:23 <cmccann> google translate is surprisingly effective these days
20:15:36 <monochrom> she reads it aloud phonetically, and I try to distort it back to the English word :)
20:15:40 <cmccann> haha
20:16:15 <monochrom> because I know more English computer words (and more imaginative in distortions) and she knows more Japanese
20:17:32 <cmccann> one of these days I really should get back to studying Japanese. or some foreign language at least.
20:23:56 <Shin-LaC> why is a functor called a functor?
20:24:13 * hackagebot lens-aeson 0.1 - Law-abiding lenses for aeson  http://hackage.haskell.org/package/lens-aeson-0.1 (EdwardKmett)
20:24:25 <johnw> guess you'd have to ask Mac Lane that
20:24:50 <edwardk> johnw: you earlier asked how i would recommend talking to aeson. try that
20:25:03 <johnw> ohhoooo
20:25:25 <edwardk> http://lens.github.com/lens-aeson/Control-Lens-Aeson.html
20:25:29 <edwardk> if you want better docs. send patches
20:25:34 <johnw> hahah
20:25:39 <johnw> how is it that you read my mind!
20:25:41 <monochrom> perhaps "function operator"?
20:25:46 <johnw> i went into "tests" thinking, cool...
20:25:55 <johnw> to find only a doctests runner!
20:26:05 <edwardk> >>> "{\"a\": 1, \"b\": 3}" & key "a"._Integer *~ 100
20:26:05 <edwardk> {"a":100,"b":3}
20:26:25 <edwardk> most stuff can run directly on values strings or bytestrings
20:26:29 <johnw> but docs can be sent, this is great
20:26:30 <johnw> i like nth
20:26:42 <edwardk> statusfailed wrote the original library. i just overgeneralized it
20:26:55 <edwardk> also you get a Plated instance for Value. so you can do generic programming rewrites on it
20:27:06 <shachaf> So now there is aeson-lens and lens-aeson.
20:27:16 <hpaste> “Anonymous Coward” annotated “pseudo code” with “pseudo code (annotation) (annotation)” at http://hpaste.org/63565#a84799
20:27:16 <johnw> "[{\"a\": 1}, {\"a\": 2}]" ^. nth 1.key "a"
20:27:19 <johnw> > "[{\"a\": 1}, {\"a\": 2}]" ^. nth 1.key "a"
20:27:20 <lambdabot>   Not in scope: `nth'Not in scope: `key'
20:27:21 <lambdabot>  Perhaps you meant one of these:
20:27:21 <lambdabot>    ...
20:27:23 <edwardk> i didn't feel right asking to take his package name from him
20:27:31 <johnw> oh, you just pasted the answer
20:27:43 <edwardk> i should have just asked though
20:27:54 <edwardk> but it'd break the existing code that was using aeson-lens
20:28:01 <cmccann> shachaf: now we need lens-aeson-lens, lens-aeson-lens-lens, aeson-lens-eggs-baked-beans-and-lens...
20:28:05 <edwardk> so this provides some modicum of upgrade path
20:28:48 <shachaf> If we had aeson, we could have aeson-lens, if we had lens.
20:29:04 <edwardk> >>> "[{\"a\": 1}, {\"a\": 2}]" ^? nth 1.key "a"
20:29:04 <edwardk> Just (Number 2)
20:29:16 <shachaf> Naturally the package edwardk wrote is an upgrade from the package he didn't write.
20:29:21 <edwardk> >>> "[{\"a\": 1}, {\"a\": 2}]" ^? nth 1.key "a"._Integer
20:29:21 <edwardk> Just 2
20:29:28 <monochrom> please also consider ae-lens-son
20:29:38 <edwardk> monochrom: we came close to liaeson
20:29:49 <monochrom> that's really cool
20:29:57 <cmccann> hahaha
20:30:08 * cmccann would never be able to remember how to spell that
20:30:11 <applicative> Shin-LaC: famously Mac Lane took 'functor' from Carnap who used it in a much less grand way in his Logical Syntax, for functions that map 'real things' to numbers and the like
20:30:14 <edwardk> thats why i opted out
20:30:23 <shachaf> not enough æ
20:30:32 <Shin-LaC> applicative: ah
20:30:42 <cmccann> shæchæf
20:31:33 <edwardk> johnw: anyways consider that an alpha, since everyone kept asking me how you'd do it right
20:32:01 <johnw> ok, thanks edwardk!
20:32:06 <johnw> i shall noise it abroad
20:32:07 <applicative> Shin-LaC I think the core idea of a functor was sort of like that for mac lane, the other category you functor into is sort of measuring the things in the source category; certain kinds of order are being preserved
20:32:33 <edwardk> docs would probably be a good idea before it gets too wide a reception ;)
20:32:52 * cmccann remembers once a question on SO where someone asked "does a library like this exist" and then edwardk created a library to do it and posted an answer saying "sure"
20:33:05 <edwardk> cmccann: that was how 'rad' and 'ad' were born
20:33:06 <johnw> haha
20:33:24 <cmccann> edwardk: I think it was "rad" I'm remembering
20:33:30 <edwardk> http://stackoverflow.com/questions/2744973/is-there-any-working-implementation-of-reverse-mode-automatic-differentiation-fo
20:33:50 <shachaf> ad subsumes rad, doesn't it?
20:33:54 <edwardk> i responded in the negative. then went off and wrote the library
20:34:01 <edwardk> and then i went off and wrote a better one
20:34:09 <edwardk> it does
20:34:13 <edwardk> its faster and more general
20:34:26 <edwardk> rad was deprecated a few years back
20:36:18 <cmccann> probably for the best, nobody actually says rad anymore. that was like an 80s or 90s thing.
20:37:38 <edwardk> yeah its all about ad networks now
20:37:44 <cmccann> haha
20:40:07 <johnw> woohoo, gitlib can now push from any supported backend to any Git URI!  and with this I can finally sleep
20:48:18 <Moggle> Anyone have any recommendations for an image library? All I want is the ability to load/save images and access their pixels.
20:50:04 <lispy> Moggle: JuicyPixels
20:51:07 <Moggle> lispy: thanks, this looks perfect
20:52:12 <applicative> Juicy.Pixels now does something called 'Radiance' pictures; I was sorry to find out about that format
20:54:17 * hackagebot computational-algebra 0.1.2.0 - Well-kinded computational algebra library, currently supporting Groebner basis.  http://hackage.haskell.org/package/computational-algebra-0.1.2.0 (HiromiIshii)
21:05:28 <cmccann> applicative: why?
21:05:47 <applicative> oh the pictures?
21:05:53 <applicative> they freaked me out
21:06:28 <applicative> like these
21:06:29 <cmccann> it's a HDR thing, isn't it?
21:06:36 <applicative> yeah
21:06:51 <applicative> i just hadn't noticed them before
21:07:04 * cmccann is familiar with the basic idea of HDR
21:08:38 <applicative> Its kind of cool I guess, but I dont want to look at them ... http://www.smashingmagazine.com/2008/03/10/35-fantastic-hdr-pictures/
21:09:26 <applicative> has anyone else noticed that the topics of simplexes, simplicial complexes and simplicial sets and so on is fatally dull?
21:09:57 <arkeet> applicative: uh... ??
21:10:06 <arkeet> simplicial sets are pretty cool.
21:10:21 <applicative> the applications seem excellent.
21:11:01 <arkeet> ...but?
21:12:01 <ludamad> Can I print out unicode in utf8 using ByteString ?
21:12:30 <applicative> I'm trying to figure out the simplicial set concept again.  Maybe I shouldnt complain.  Somewhere I managed to defined the simplex category in Haskell + DataKinds
21:13:16 <applicative> ludamad: this question might be a little ambiguous. Have you looked at the Data.Text.Encoding functions?
21:13:30 <arkeet> applicative: the category \Delta?
21:13:39 <applicative> yes
21:13:51 <arkeet> k
21:14:21 <applicative> I cant find it at the moment, but it was comparatively trivial of course
21:14:53 <ludamad> ill look, thanks
21:15:14 <ludamad> applicative: I'm looking for something that doesnt require a hackage package for now, so as not to confuse the other haskell newcomer im working with
21:15:16 <ludamad> but thanks
21:15:51 <Moggle> can anyone recommend any textbooks on category theory?
21:16:08 <arkeet> I think a lot of people here like Awodey.
21:16:37 <applicative> me too, my sometime teacher!
21:17:04 <applicative> ludamad: I think the text package is in the haskell platform
21:17:21 <ludamad> ah
21:17:25 <arkeet> indeed it is
21:17:29 <ludamad> ok, thanks
21:19:16 <applicative> you want http://lambda.haskell.org/platform/doc/current/packages/text-0.11.2.3/doc/html/Data-Text-Encoding.html there are more direct ways with utf8 packages, but this is idiot simple
21:20:28 <applicative> ludamad: it might be that you should basically be thinking in terms of Text rather than Bytestring + String if it is text you are using
21:21:15 <ludamad> applicative: I guess the 'stability: experimental' is throwing me off.
21:21:22 <ludamad> I looked into Text at first
21:21:54 <applicative> does it say that for text?  I think people forget to erase that.  Its among the most widely used packages.
21:22:03 <ludamad> Ah.
21:22:10 <ludamad> And yes, it does
21:23:17 <circle> what's the library function to shop off "n" elements from the end of a list?
21:23:21 <circle> chop*
21:23:24 <arkeet> drop
21:23:27 <circle> thanks
21:23:38 <circle> what if I want those elements returned?
21:23:43 <arkeet> take
21:23:57 <circle> oh ok, I got them mixed up, thanks
21:24:07 <arkeet> oh wait
21:24:09 <arkeet> n elements from the end?
21:24:14 <circle> you're right
21:24:15 <circle> I tested it
21:24:33 <ludamad> Right, but isn't take for the beginning ?
21:24:42 <arkeet> there's no dropFromEnd in a standard library.
21:25:01 <arkeet> @where sneaky
21:25:01 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
21:25:29 <applicative> hah, thats pretty good
21:26:51 <applicative> even works for infinite lists ...
21:31:16 <hpaste> Haisheng revised “max-two-dim-array”: “max-two-dim-array” at http://hpaste.org/84590
21:38:25 <cmccann> applicative:  the power of lazy natural numbers! (think about it if it's not obvious why)
21:39:30 <shachaf> What was that one puzzle people had in here the other day?
21:39:41 <shachaf> Ah, lazy split-into-halves.
21:42:42 <arkeet> > transpose . Data.List.Split.chunksOf 2 $ [1..]
21:42:43 <lambdabot>   [[1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,...
21:42:50 <arkeet> > map (take 10) . transpose . Data.List.Split.chunksOf 2 $ [1..]
21:42:53 <lambdabot>   mueval-core: Time limit exceeded
21:43:04 <arkeet> hmm
21:43:10 <cmccann> > map (take 10) . transpose . Data.List.Split.chunksOf 2 $ [1..]
21:43:14 <lambdabot>   mueval-core: Time limit exceeded
21:43:24 <cmccann> ok not just lambdabot being contrary
21:43:28 <arkeet> > map (take 10) . transpose . Data.List.Split.chunksOf 2 $ [1..]
21:43:32 <lambdabot>   mueval-core: Time limit exceeded
21:43:35 <arkeet> hmm
21:54:18 * hackagebot constrained-normal 1.0.0 - Normalised Deep Embeddings for Constrained Type-Class Instances  http://hackage.haskell.org/package/constrained-normal-1.0.0 (NeilSculthorpe)
21:58:00 <david1991> Hello guys, I have a small question. Have anybody used the SBV package on hackage? So I was trying to install it on Windows 7 (https://github.com/LeventErkok/sbv/blob/master/INSTALL), so I followed everything that this thing said.
21:58:19 <david1991> However, after running the first 3 lines at (http://hackage.haskell.org/package/sbv)
21:58:33 <david1991> I get Failed to complete the call to z3
21:58:51 <david1991> it detects z3 and I can execute it from th command prompt, however I have no idea how to solve this problem.
22:01:40 <Shin-LaC> https://github.com/roman/HaskellKoans <- ok, this is complete bullshit
22:01:49 <Shin-LaC> it's nothing like the python or ruby koans
22:03:05 <Shin-LaC> the first four groups are trivial, and mostly just require you to choose the right function
22:03:17 <Shin-LaC> and they *tell* you what the right function is
22:03:25 <Shin-LaC> so you just copy and paste a word
22:03:43 <Shin-LaC> wow, I can feel the learning already
22:04:13 <m3ga> Shin-LaC: any reason you aren't reading learnyouahaskell.com?
22:04:20 <Shin-LaC> then it asks you to go straight from currification to parser combinators
22:05:13 <Shin-LaC> m3ga: the title and the website suggest that it's the sort of why_ (or _why or whatever)-style whimsical stuff that I hate
22:05:49 <Shin-LaC> I don't want to be entertained, I want information packaged in the most efficient format
22:05:58 <m3ga> Shin-LaC: it is widely regarded as an excellent resource for learning haskell.
22:07:01 <oio> how could out of this string "abcdef" this "a" "ab" "abc" "abcd" "abcde" "abcdef" ?
22:07:02 <Shin-LaC> I'll give it a chance, then
22:07:09 <Shin-LaC> I guess I'll skip the first five chapters
22:07:10 <applicative> Shin-LaC: theres plenty of silliness, but LYAH is pretty well thought out.
22:07:11 <m3ga> Shin-LaC: there are a bunch more here http://www.haskell.org/haskellwiki/Learning_Haskell
22:07:36 <mauke> > inits "abcdef"
22:07:38 <lambdabot>   ["","a","ab","abc","abcd","abcde","abcdef"]
22:07:44 <applicative> > inits "abcdef"
22:07:45 <lambdabot>   ["","a","ab","abc","abcd","abcde","abcdef"]
22:07:53 <Shin-LaC> but now I want to solve this parser combinators stuff
22:08:00 <applicative> mauke is too fast for me
22:08:10 <mauke> 2fast4u
22:08:25 <Shin-LaC> but I don't really understand how to combine two different applicatives
22:08:33 <oio> .... k
22:08:35 <Shin-LaC> I think I need to combine Parser and [] somehow
22:08:39 <Shin-LaC> basically
22:08:57 <Shin-LaC> I have "digit" which is a Parser Char
22:09:18 <Shin-LaC> and I need to get a Parser String that takes a sequence of digits
22:09:21 <applicative> and now you want "digits"?
22:09:25 <applicative> many1 digit
22:09:49 <mauke> some digit
22:10:11 <Saizan> :t some
22:10:12 <lambdabot> Alternative f => f a -> f [a]
22:10:24 <applicative> :t many
22:10:26 <lambdabot> Alternative f => f a -> f [a]
22:10:42 <applicative> :t many1
22:10:43 <lambdabot>     Not in scope: `many1'
22:10:43 <lambdabot>     Perhaps you meant `many' (imported from Control.Applicative)
22:10:43 <Shin-LaC> ok, but that doesn't really teach me anything
22:11:19 <mauke> write many/some yourself
22:11:29 <Shin-LaC> yes, that's what I want to do
22:11:34 <Shin-LaC> I wanted to use "map" at first
22:11:46 <Shin-LaC> but that gives me… I don't know what the hell that gives me
22:11:48 <mauke> over what input list?
22:12:05 <Shin-LaC> the input list would be the String
22:12:14 <Shin-LaC> except that a parser isn't really a function
22:12:30 <mauke> yeah, you can't do that
22:12:40 <Saizan> list combinators aren't going to help
22:12:49 <mauke> don't touch the String; combine existing parsers instead
22:13:04 <applicative> dont look at the implementation of some and many in Control.Applicative.
22:13:07 <lispy> dcoutts: pkg-config-depends (or whatever the field is called) can be a hassle on windows. Just FYI.
22:13:20 <mauke> knowing regexes may help :-)
22:13:22 <lispy> dcoutts: I have a package here I wanted to build but it uses the field (libffi)
22:14:27 <lispy> dcoutts: I installed a mingw version of pkg-config (find it was a pain) but that didn't realy solve my problem because now pkg-config just tells me that I don't have libffi installed :)
22:14:49 <lispy> dcoutts: I don't know if it's feasible, but having ghc ship pkg-config (since cabal could use it) would be nice.
22:26:06 <applicative> heres a dumb digits Shin-LaC , for criticism http://hpaste.org/84803
22:31:44 <oio> is there a name for this algorithm 123456 -> 1 12 123 1234 12345 123456 2 23 234 2345 2356 3 34 345 3456 4 45 456 5 56 6
22:32:25 <mauke> > subsets "123456"
22:32:25 <shachaf> > (\x -> inits x >>= tails) "123456"
22:32:27 <lambdabot>   Not in scope: `subsets'
22:32:28 <lambdabot>  Perhaps you meant `subst' (imported from Data.Numb...
22:32:28 <lambdabot>   mueval-core: L.hs: removeLink: does not exist (No such file or directory)
22:32:46 <mauke> :t (>=>)
22:32:48 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
22:32:49 <shachaf> I don't think subsequences is it.
22:32:54 <shachaf> > (inits >=> tails) "123456"
22:32:56 <lambdabot>   ["","1","","12","2","","123","23","3","","1234","234","34","4","","12345","...
22:33:00 <shachaf>  subsequences "123456"
22:33:13 <shachaf> > subsequences "123456"
22:33:14 <lambdabot>   ["","1","2","12","3","13","23","123","4","14","24","124","34","134","234","...
22:34:28 <oio> nope
22:34:50 <shachaf> > unwords . (tail . inits >=> init . tails) $ "123456"
22:34:51 <lambdabot>   "1 12 2 123 23 3 1234 234 34 4 12345 2345 345 45 5 123456 23456 3456 456 56...
22:34:54 <mikurubeam> @src subsequences
22:34:54 <lambdabot> Source not found. I've seen penguins that can type better than that.
22:37:06 <oio> :t (>=>)
22:37:08 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
22:38:15 <oio> f*** genius..
22:41:11 <ludamad> :t init
22:41:12 <lambdabot> [a] -> [a]
22:41:21 <ludamad> :t inits
22:41:22 <lambdabot> [a] -> [[a]]
22:42:41 <augur> :t innit
22:42:43 <lambdabot>     Not in scope: `innit'
22:42:43 <lambdabot>     Perhaps you meant one of these:
22:42:43 <lambdabot>       `init' (imported from Data.List),
22:42:52 <augur> i was hoping for `Chav' :(
22:44:42 <Saizan> > unwords . concat . map (drop 1 . inits) . tails $ "123456"
22:44:43 <lambdabot>   "1 12 123 1234 12345 123456 2 23 234 2345 23456 3 34 345 3456 4 45 456 5 56...
22:45:17 <shachaf> > unwords . (>>= drop 1 . inits) . tails $ "12345"
22:45:50 <lambdabot>   "1 12 123 1234 12345 2 23 234 2345 3 34 345 4 45 5"
22:51:56 <oio> > length . concat . map (drop 1 . inits) . tails $ "123456"
22:51:58 <lambdabot>   21
22:52:50 <oio> length . (>>= drop 1 . inits) . tails $ "123456"
22:53:05 <oio> >length . (>>= drop 1 . inits) . tails $ "123456"
22:55:56 <Saizan> you need the space
22:58:29 <oio> fine i need to know all those .. functions
23:00:18 <ab9rf> no, lambdabot knows them for you :)
23:03:15 <oio> haskell so high
23:05:06 <circle> how do I actually access the contents of a tuple?
23:05:20 <circle> say I have an object structured as such (technically a list)
23:05:32 <circle> [([a], [b])]
23:05:50 <circle> a list with one element, a tuple, containing two elements. how do I access a and b?
23:05:51 <mikurubeam> circle: If it is a pair, you could use the functions fst and snd.
23:06:01 <mauke> pattern matching
23:06:04 <mikurubeam> circle: For tuples of other arities, you could use pattern-matching or whatever.
23:06:32 <circle> example?
23:06:54 <mikurubeam> > (\(a,b,c) -> a + b + c) (1,2,3)
23:06:55 <lambdabot>   6
23:06:55 <Nisstyre-laptop> (a,b,c) = b
23:07:12 <Nisstyre-laptop> or rather "let (_,b_) = triple in b"
23:07:21 <Nisstyre-laptop> *(_,b,_)
23:07:36 <mikurubeam> :t (%)
23:07:37 <lambdabot>     Not in scope: `%'
23:07:37 <lambdabot>     Perhaps you meant `R.%' (imported from Data.Ratio)
23:08:49 <Nisstyre-laptop> > let (_,(b:_),_) = b + b in ([1],[2],[3])
23:08:50 <lambdabot>   Occurs check: cannot construct the infinite type:
23:08:50 <lambdabot>    t2 = (t0, [t2], t1)
23:09:11 <Nisstyre-laptop> > let (_,(b:[]),_) = b + b in ([1],[2],[3])
23:09:13 <lambdabot>   Occurs check: cannot construct the infinite type:
23:09:13 <lambdabot>    t2 = (t0, [t2], t1)
23:09:16 <Nisstyre-laptop> ugh
23:11:02 <Nisstyre-laptop> okay I'm an idiot right now
23:11:17 <Nisstyre-laptop> > let (_,(b:_),_) = ([1],[2],[3]) in b + b
23:11:19 <lambdabot>   4
23:12:38 <circle> thanks
23:28:16 <rohitkav> I got Ubuntu 12.04, need to install Haskell completely and Than yesod framework
23:28:20 <rohitkav> Kindly help
23:28:47 <mauke> haha
23:29:44 <rohitkav> ? mauke
23:30:10 <mauke> you're showing zero effort
23:30:23 <mauke> just "I want X. do it."
23:30:34 <mgsloan> rohitkav: "sudo apt-get install haskell-platform" followed by "cabal install yesod" should do it.  But yeah, google is your friend
23:30:55 <rohitkav> I did mgsloan , But i could set cabal path properly I guess
23:31:35 <mgsloan> rohitkav: Did you start a new terminal?  that might be necessary
23:31:52 <rohitkav> yes mgsloan
23:32:46 <mgsloan> Oh, I forgot about "cabal update"
23:32:54 <hpaste> rohit pasted “Error while trying to install yesod” at http://hpaste.org/84804
23:33:28 <rohitkav> I did update too mgsloan so I thought I needed full package of Ghci
23:33:37 <rohitkav> or somewhere I was going wrong
23:33:41 <mgsloan> you're overwriting your PATH variable so that it doesn't include the usual stuff like /usr/bin
23:33:50 <rohitkav> yes
23:33:58 <edwardk> shachaf: around?
23:34:20 <rohitkav> Actually I was trying to follow the yesod site reference on this
23:34:34 <shachaf> hi edwardk
23:34:56 <mgsloan> rohitkav: Try starting a new terminal, and do "export PATH=$PATH:$HOME/.cabal/bin"
23:35:25 <mgsloan> rohitkav: The yesod site reference probably assumes you have cabal install in your local cabal directory, unfortunately
23:36:05 <rohitkav> It shows me a list of things which needed to be installed , I belive
23:36:47 <mgsloan> rohitkav: sounds like it's working! enjoy!
23:37:33 <hpaste> rohit pasted “Error installing yesod” at http://hpaste.org/84805
23:37:52 <rohitkav> check the above mgsloan plz.
23:38:34 <mgsloan> Such things will happen.  Use "--force-reinstalls"
23:38:46 <rohitkav> ok
23:39:16 <rohitkav> so cabal install yesod-platform --force-reinstalls would work is it
23:39:44 <rohitkav> I was worried if some packages get broken so came to irc for help
23:39:58 <rohitkav> if in case i was doing some mistake
23:40:15 <sw2wolf> rohitkav: ghc-pkg check
23:40:36 <sw2wolf> irrc
23:40:50 <rohitkav> you want the out put sw2wolf
23:40:51 <sw2wolf> iirc
23:40:59 <rohitkav> of that
23:41:14 <sw2wolf> rohitkav: no
23:41:51 <hpaste> rohit pasted “Error installing yesod” at http://hpaste.org/84806
23:42:04 <rohitkav> oops sorry sw2wolf
23:42:41 <rohitkav> what was that sw2wolf
23:43:05 <sw2wolf> All those warnings seem to be NOT severe
23:43:37 <rohitkav> ok :)
23:43:55 <rohitkav> mgsloan, it seams installing
23:43:58 <rohitkav> thanks mgsloan
23:44:16 <mgsloan> welcome!
23:45:01 <yezariaely> I want to have the following point free: gen env exp = runState (gen' env exp) 0. Tried genPF = (flip runState) 0 gen' but this doesn't work. Anyone can give me a hint?
23:45:22 <shachaf> @pl gen env exp = runState (gen' env exp) 0
23:45:22 <lambdabot> gen = flip flip 0 . (runState .) . gen'
23:45:26 <shachaf> Ugh.
23:46:06 <yezariaely> magic!
23:46:08 <yezariaely> thx
23:46:11 <shachaf> yezariaely: (flip runState 0 .) . gen' -- ?
23:46:22 <mgsloan> o_0 "flip flip 0"
23:46:24 <yezariaely> looks much better...
23:46:31 <yezariaely> two flips is cool :)
23:46:40 <shachaf> @ty flip flip
23:46:42 <lambdabot> b -> (a -> b -> c) -> a -> c
23:46:53 <mgsloan> I get it, but it's still crazy!
23:47:11 <shachaf> Just use a concatenative language.
23:47:30 <mgsloan> I'd prefer not to, I like my composition explicit ;)
23:47:54 <Nisstyre-laptop> check out Joy
