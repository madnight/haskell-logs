00:03:22 * hackagebot lz4 0.2.1 - LZ4 compression for ByteStrings  http://hackage.haskell.org/package/lz4-0.2.1 (MarkWotton)
00:09:31 <adas> I have a pointer to a C function for which I am trying to write a haskell binding. The Foreign.Ptr seems to distinguish between pointers to 'C' data and pointers to 'C' functions. so i suppose i can use the pointer to 'C' functions feature of the Foreign.Ptr module..Or am i wrong?
00:09:51 <danr> srhb: don't is also a valid identifier
00:11:11 <arkeet> :t isn't
00:11:13 <lambdabot> APrism s t a b -> s -> Bool
00:11:15 <arkeet> :t hasn't
00:11:17 <lambdabot> Getting All s t a b -> s -> Bool
00:11:33 <Ralith> dammit lens
00:11:52 <adas> the reason i ask is because earlier i was told that the syntax "foreign import ccall "<c header> &" funcname :: Ptr ( Ptr (CInt -> CInt -> IO ()))...
00:12:01 <adas> ... can be used
00:12:20 <adas> i don't think im explaining myself well
00:13:37 <liyang> TravisD: http://www.haskell.org/haskellwiki/GHC/Type_families#An_associated_type_synonym_example
00:13:46 <mm_freak_> lens uses "don't"?  that's bad, because it clashes with the acme-dont package
00:14:02 <mm_freak_> main = don't do putStrLn "Hello World!"
00:15:18 <mm_freak_> adas: did you read the FunPtr documentation?
00:15:35 <ion> mm_freak: I wish that syntax worked. Ditto for lambdas.
00:16:22 <mm_freak_> ion: oh yes, i'm actually missing a $
00:16:28 <mm_freak_> don't $ do ‚Ä¶
00:17:14 <adas> mm_freak_: i did. ..
00:18:24 <mm_freak_> adas: then maybe you're not explaining yourself well, but in any case haskell can't dereference a function pointer directly
00:18:43 <mm_freak_> you can write a C function to do it and call that one with the function pointer and the arguments
00:19:45 <Ralith> @hoogle libffi
00:19:46 <adas> but Foreign.Ptr says that FunPtr can be a pointer to a foreign function .. that is imported with a static address..
00:19:46 <lambdabot> package libffi
00:19:46 <lambdabot> package bindings-libffi
00:19:51 <Ralith> er
00:19:54 <Ralith> @hackage libffi
00:19:54 <lambdabot> http://hackage.haskell.org/package/libffi
00:20:03 <Ralith> mm_freak_: ^
00:20:09 <mm_freak_> adas: that doesn't mean you can call it
00:20:30 <mm_freak_> i'm not familiar with libffi
00:20:59 <mm_freak_> but the base foreign modules offer no direct way to call a function via pointer
00:21:20 <mm_freak_> apparently libffi has a callFFI function that you can use
00:21:26 <killy9999> > print "abc"
00:21:28 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
00:21:28 <lambdabot>    arising from a use of ...
00:24:54 <adas> i believe mauke was the one that said earlier that i can call a pointer function that exists in C from haskell.... and he seem have done it without using FunPtr. Then i checked the docs and read that there is FunPtr exactly for these kind of calls.. so perplexed..
00:38:22 * hackagebot yesod 1.1.9.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.9.2 (MichaelSnoyman)
00:40:07 <Ralith> is there a function in base to replace the nth element of a list with a new value?
00:40:45 <shachaf> I can't quite hear you -- did you say "in lens"?
00:41:16 <elliott> > (ix 1 %~ 123) [1,2,3] -- absolutely base
00:41:18 <lambdabot>   Could not deduce (GHC.Num.Num (p0 t t))
00:41:18 <lambdabot>    arising from the ambiguity check...
00:41:20 <elliott> oops.
00:41:22 <elliott> what did i do.
00:41:29 <elliott> > (ix 1 .~ 123) [1,2,3] -- absolutely base
00:41:31 <lambdabot>   [1,123,3]
00:41:44 <Ralith> shachaf: that would be an awfully obvious answer.
00:41:48 <Ralith> have, rather
00:43:22 * hackagebot yesod-test 0.3.5 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-0.3.5 (MichaelSnoyman)
00:54:30 <epta> Trying to solve glib build error `setup: The program gtk2hsC2hs version >=0.13.5 is required but the version'. Came here http://www.98li.com/questions/10197712/haskell-how-to-upgrade-gtk2hsc2hs . Does it mean that gtk2hs-buildtools-0.12.4 produce gtk2hsC2hs-0.13.5?
00:56:00 <arkeet> epta: sounds like you need to install a newer gtk2hs-buildtools?
00:57:18 <arkeet> and yes, you get c2hs version 0.13.6
00:58:01 <epta> \> C->Haskell Compiler, version 0.16.3 Crystal Seed, 24 Jan 2009
00:58:23 * hackagebot yesod-platform 1.1.8 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.1.8 (MichaelSnoyman)
00:58:23 <Ralith> blah
00:58:35 <Ralith> GHC is warning me that I have an overlapping pattern match, but it doesn't tell me what with :/
00:58:54 <arkeet> maybe if you paste the code?
00:59:19 <Ralith> it's a bit bulky, but sure
00:59:29 <Ralith> http://sprunge.us/PcNK?hs
00:59:34 <arkeet> but doesn't it tell you which pattern overlaps?
00:59:40 <Ralith> it tells me that the final pattern overlaps
00:59:46 <Ralith> what with, who knows?
00:59:55 <arkeet> the x pattern?
01:00:16 <arkeet> did you already handle all constructors?
01:00:16 <Ralith> yes
01:00:24 <Ralith> I don't think so
01:00:47 <Ralith> maybe
01:00:48 <Ralith> if I did, would I get that error?
01:00:50 <arkeet> yes
01:01:01 <arkeet> warning, not error.
01:01:14 <Ralith> hm, looks like I do indeed
01:01:15 <Ralith> thanks
01:01:20 <Ralith> that's a really obtusely worded warning
01:01:31 <arkeet> seems clear to me.
01:01:31 <Ralith> though I guess I can see how it comes about
01:02:03 <Ralith> arkeet: when I read "overlapped" I read "multiple patterns match the same values equally well", not "some pattern is unreachable"
01:02:19 <arkeet> it always means the latter.
01:02:26 <Ralith> and this is the first time I've encountered it
01:02:37 * Ralith is fairly scrupulous :p
01:02:55 <Ralith> anyway, thanks
01:18:23 * hackagebot scyther-proof 0.6.0.0 - Automatic generation of Isabelle/HOL correctness proofs  for security protocols.  http://hackage.haskell.org/package/scyther-proof-0.6.0.0 (SimonMeier)
01:25:01 <hpaste> mbuf pasted ‚Äúlambdabot build failure‚Äù at http://hpaste.org/83441
01:25:09 <mbuf> Cale: ^^
01:25:28 <kartoffelbrei> is there a difference between virthualenv and hsenv?
01:26:46 <arkeet> kartoffelbrei: hsenv replaces the other.
01:26:57 <arkeet> I think.
01:26:58 <BlankVerse> kartoffelbrei: hsenv is active and works for me , not sure about the other
01:27:47 <arkeet> haha, look at their package descriptions
01:27:53 <arkeet> almost identical
01:28:05 <arkeet> ah yes.
01:28:12 <arkeet> hsenv used to be called virthualenv.
01:28:40 <kartoffelbrei> arkeet, BlankVerse: Thanks, i'm using hsenv right now, so i guess i'll stick with it.
01:29:21 <hpaste> adas pasted ‚ÄúValid?‚Äù at http://hpaste.org/83442
01:30:02 <BlankVerse> kartoffelbrei: I don't like the project specific isolation in same directory as the source code , I have setup a .hsenv at home and keep my isolated envs there kind of like virtualenv python,ruby rvm
01:30:07 <adas> can someone look at it ^^ and tell me if thats valid.. it compiles.. but i don't believe it
01:30:22 <danr> adas: it seems like you're working with the rasberry pi :) is that so?
01:31:12 <adas> danr: hi. yes. trying to write haskell bindings for the wiringPi library
01:31:30 <danr> adas: fun!
01:32:55 <adas> danr: yes it is. I hope it works. never writtne binding before - )
01:37:41 <Heffalump> anyone know where ICFP 2014 will b?
01:37:43 <Heffalump> be
01:38:25 <shachaf> Does anyone know, that far in advance?
01:39:21 <Heffalump> I'm not sure when it's decided - I remember Tokyo was advertised quite a while in advance.
01:39:55 <ion> It will probably be before 2020.
01:40:18 <ion> Oh, where. I‚Äôm too tired for IRC.
01:40:42 <mgsloan> looks like ICFP 2013 will be in boston
01:40:58 <mgsloan> (maybe that was already obvious :) )
01:41:17 <Heffalump> yes :-)
01:41:43 <liyang> It's likely that ICFP 2014 will be somewhere in Asia.
01:41:58 <frerich> Anybody here in the bay area? I'll stay in San Carlos for about three months, I'm wondering whether there are some regular meetings with talks about Haskell I could attend.
01:42:00 <liyang> Australia would be nice.
01:42:39 <Heffalump> liyang: really? I thought Tokyo was a one-off thing in the "standard" rotation
01:42:57 <Heffalump> at least it was stated at the time to be that, though perhaps that was just being careful.
01:43:23 <mgsloan> ICFP Hawaii!
01:43:31 <liyang> Oh, I thought it was expanded to {NA,EU,Asia}‚Ä¶
01:44:35 <Heffalump> liyang: I remember askign someone at the time and they said that it was a one-time thing, though obviously that doesn't preclude a policy change because it proved successful etc
01:44:38 <liyang> There are quite a few Australians. Wonder why it's never held there‚Ä¶
01:45:30 <liyang> (Other than it being about as far as possible from some of the areas with the highest concentration of FP academics.)
01:45:52 <Botje> drop bears.
01:49:35 <liyang> Botje: a dab of vegemite behind the ear solves that problem.
01:59:00 <crl> it's a pain whe you have string bytestrings text mixed
02:02:28 <arkeet> crl: why are they mixed?
02:02:56 <arkeet> text is for text (unicode strings). bytestring is for byte strings.
02:03:00 <crl> because for example I use getDirectoryContents that returns a list of strings
02:03:26 <crl> nah was exagerating, it's only a mix of String and ByteString
02:03:38 <soiamso> because it's no develop by CJK developer..
02:04:44 <kryft> Hmm, I accidentally left out the commas from a list (e.g. break odd [2 4 5 6 7]) and got a cryptic error message; what does this bracket notation mean?
02:04:59 <shachaf> It means a list with one item.
02:05:06 <tdammers> lots of arguments against australia... travel expenses, timezones, climate, local geography, flying spiders...
02:05:14 <shachaf> Which is (2 4 5 6 7), i.e., the function (2 4 5 6) applied to 7.
02:05:16 <arkeet> it's a list with one element, whichis the function 2 applied to 4, 5, 6, and 7.
02:05:25 <tdammers> saltwater crocodiles, sharks, killer jellyfish
02:05:28 <quchen> kryft: It means "apply 2 4 5 6 7 as arguments to 2"
02:05:52 <kryft> Oh, right, and this is a reasonable interpretation (i.e. not a syntax error) because numeric literals are actually functions
02:05:53 <arkeet> it gives a cryptic error message beacuse numeric literals are overloaded.
02:05:56 <crl> have I done something stupuid if I'm fresquently with [ByteString]?
02:06:02 <shachaf> kryft: No, numeric literals are not (usually) functions.
02:06:14 <shachaf> But they're overloaded, so if you really wanted to you could make them into functions.
02:06:26 <shachaf> In this case GHC is looking for such an overloading, and can't find it.
02:06:35 <arkeet> > 2 4 5 6 7
02:06:37 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> a1 -> a2 -> a3 -> t))
02:06:37 <lambdabot>    arising from ...
02:06:41 <quchen> kryft: Related: Num instance for functions http://stackoverflow.com/q/12133932/1106679
02:06:47 <quchen> Silly but interesting post :-)
02:06:51 <arkeet> don't do it!
02:07:15 <quchen> *Main> 1 2 3
02:07:19 <quchen> --> 18
02:07:22 <quchen> :-D
02:07:27 * shachaf wonders what "apply 2 4 5 6 7 as arguments to 2" means.
02:07:47 <quchen> shachaf: modulo currying etc bla
02:08:26 <shachaf> etc bla, indeed.
02:09:01 <quchen> YOUR FUN LACKS RIGOR QUCHEN oh thanks I almost overlooked that
02:09:06 <kryft> shachaf: Hmm, what exactly does overloading mean in general then?
02:09:33 <kryft> quchen: Only rigorous fun is allowed here
02:10:18 <kryft> I don't pretend to really understand numeric literals, much as I don't really understand most of haskell yet :P
02:10:36 <shachaf> kryft: Let's take another example.
02:10:41 <shachaf> data Bool = False | True
02:10:57 <shachaf> class Boolish a where fromBool :: Bool -> a -- note: don't actually do this
02:11:08 <shachaf> Now, what's the type of (fromBool False)?
02:12:10 <kryft> shachaf: a?
02:12:29 <shachaf> Well, not just any a.
02:12:41 <shachaf> instance Boolish Bool where fromBool x = x
02:12:59 <shachaf> instance Boolish Int where fromBool False = 0; fromBool True = 1
02:13:24 <shachaf> I haven't made an instance for Char, so you can't (necessarily use (fromBool False) as a Char.
02:13:36 <shachaf> Right?
02:15:43 <kryft> shachaf: Hmm, I don't remember what instance means (if I ever knew), and I have a fever so my brain isn't really working :)
02:16:30 <kryft> shachaf: I took a course a year ago that I think more or less covered LYAH and am now going through RWH, but haven't got that far yet
02:16:53 <quchen> Have you read the LYAH chapter on type classes? It talks about instance/class.
02:17:11 <quchen> Also it's written to be understandable even if you have 44 ¬∞C fever ;-)
02:17:43 <kryft> quchen: I'm pretty sure I've read that, but it was a year ago and I haven't done anything with haskell since
02:17:56 <shachaf> kryft: OK, you should read about type classes.
02:18:05 <frerich> kryft: It's only fever if the proteins are flocculating in your brain.
02:18:10 <kryft> frerich: Haha
02:18:20 <quchen> Basically, the type class says "here's this abstract thing with the following methods". shachaf's "Boolish" class says "this is a class of things that can be created from a bool"
02:18:37 <quchen> Instance then says "naaaamely this: you can make a Bool out of a Bool! Hooray."
02:18:48 <quchen> And "You can also make an Int out of a Bool! Hooray.
02:18:48 <quchen> "
02:18:56 * shachaf suspects that explanation is a bit misleading.
02:18:56 <jcp> kryft: If you're coming from a language like Java, think of it as meaning "implementation"
02:19:04 <shachaf> Then again, I think that about most type clsas explanations. :-(
02:19:09 <kryft> quchen: Oh, right, my flu-addled brain is fairly certain it knows this
02:19:15 <shachaf> The "Java interface" analogy, for instance.
02:19:26 <shachaf> Oh, well. I'll just go be a h8r here in my corner.
02:19:59 * jcp mentally went s/class/interface/ s/instance/implementation/ when first learninf Haskell, and then the world made sense
02:20:03 <kryft> shachaf: What exactly is misleading about it? (I've heard that before)
02:20:05 <jcp> * learning
02:20:25 <quchen> jcp: I think s/.*// is the better approach
02:20:38 <jcp> Haha
02:20:47 <shachaf> jcp: Then explain that Boolish class above.
02:20:52 <jcp> That results in Windows
02:20:56 <kryft> jcp: Technically I think I'm not really coming from anywhere in the sense that I haven't used any single language extensively
02:21:18 <jcp> kryft: Ah
02:21:32 <jcp> shachaf: You can't. The interface analogy only goes so far
02:21:49 <shachaf> The trouble is when it goes in the wrong direction.
02:21:54 <jcp> But it's helpful to get beginners into the water, before you push them in any deeper
02:22:09 * quchen is glad he has no idea about what interfaces are
02:22:21 <jcp> shachaf: You can do (almost) anything you can do with an interface with a type class. The reverse is not necessarily true
02:22:38 <shachaf> jcp: Not really -- or sometimes you're fighting the system by doing it.
02:22:49 <shachaf> For example, in Java, you can have a list of things that implement an interface, right?
02:22:56 <quchen> Is an interface something like an abstract basis class?
02:23:00 <Xaratas> hm, if this here is currently the "learning haskell" corner, could you give me a hint how to make my list fun working for all sizes? http://hpaste.org/83389
02:23:07 <jcp> But I've found that if you try to explain to imperative programmers how functions are universally quantified in their return types right off the bat, it's just an uphill battle
02:23:22 <jcp> quchen: More or less, yes
02:23:39 <kryft> jcp: (Well, depends on how one defines extensively of course; one man's noob is another man's guru)
02:23:53 <shachaf> jcp: This has nothing to do with functions or return types. :-(
02:23:56 <jcp> shachaf: What do you m... actually, crap, I have class in five hours, so I ought to sleep and continue this tomorrow
02:24:32 <quchen> Xaratas: A minimal example or a couple of comments would help, I don't see what the code is supposed to do
02:24:48 <`ramses_> Xaratas: what's the pattern?
02:25:14 <jcp> shachaf: I think it does (it's one of the many things that sets classes and interfaces apart in expressivityl
02:25:24 <jcp> ) but I need to go to bed
02:25:29 <jcp> 'night all
02:25:35 <shachaf> jcp: No, class Bounded a where minBound :: a has no function and no return type.
02:25:36 <hpaste> marekw2143 pasted ‚ÄúMaping‚Äù at http://hpaste.org/83443
02:25:41 <kryft> shachaf: Anyway, when you said 'not just any a' above, I assume that you meant that you have to define a specific instance?
02:25:56 <shachaf> kryft: Never mind what I said. You should learn about type classes first.
02:26:04 <marekw2143> hello, on paste: http://hpaste.org/83443 - then we're returning Leaf whose "conainign" a function?
02:26:22 <marekw2143> as f is of type: a -> State satate b
02:26:44 <kryft> shachaf: I think I know enough to understand what you said above, now that my flu-addled brain has managed to access its longterm memory
02:27:02 <Xaratas> quchen: it builds all valid lines of a magical square, on list does size 3 and one size 4. result could be [[1,5,9], [3,4,8], Ö] (as it must have the sum 15 for a magic square of size 3)
02:27:05 <arkeet> "state" is such a long name for a type variable :(
02:27:06 <shachaf> kryft: OK. I don't know enough to understand what you said.
02:27:49 <quchen> marekw2143: f has type "a -> State ...", therefore "f x" has type "state s a". If you use that as "y <- f x", then y has type "a".
02:27:58 <frerich> Xaratas: I guess your function would also need to know the magic values for all magical squares (i.e. 15 for size 3, 34 for size 4 etc.).
02:28:08 <Xaratas> quchen: https://en.wikipedia.org/wiki/Magic_square
02:28:32 <Xaratas> frerich: thats an easy part, the magic values are calculateable by formel
02:28:37 <frerich> Xaratas: Ah, I see there's a formula for that.
02:29:06 <kryft> shachaf: I'm not very good at communicating, especially when I'm ill.
02:30:04 <parcs> shachaf++ for cast :: (Typeable a, Typeable b) => Maybe (a :~: b)
02:30:06 <Xaratas> frerich: i have all other parts changed so the could work on arbitary sized squares, but i have no clue how to do that for the inital set of valid lines
02:30:49 <hpaste> quchen annotated ‚ÄúMaping‚Äù with ‚ÄúMaping (annotation)‚Äù at http://hpaste.org/83443#a83444
02:31:08 <arkeet> parcs: that can be written right now using gcast :: (...) => (a :~: a) -> Maybe (a :~: b)
02:31:08 <arkeet> :p
02:31:23 <parcs> yes but it's the principle of the matter
02:31:28 <arkeet> I agree.
02:31:41 <ion> cast :: (Typeable a, Typeable b) => a -> b; cast = unsafeCoerce
02:31:53 <elliott> it really shouldn't be called cast though.
02:31:55 <elliott> since it's not casting anything
02:32:14 <parcs> however if you define it in terms of gcast, you carry the superfluous Typeable b constraint
02:32:15 <frerich> Xaratas: Hmm
02:32:18 <parcs> (is it superfluous?)
02:32:22 <arkeet> it is not
02:32:26 <arkeet> you are trying to get a :~: b
02:32:26 <marekw2143> quchen: hmmm, y <- f x "translates to"              f x >>= (\y ....      ?
02:32:33 <arkeet> a and b both had better be Typeable
02:32:39 <quchen> marekw2143: Yes, exactly
02:32:43 <ion> gcast :: IO a -> b; gcast = unsafeCoerce . unsafePerformIO
02:32:47 <elliott> by the way, it should *really* be key :: Typeable a => Key RealWorld a.
02:32:57 <elliott> I think nobody but shachaf has any idea what I'm ranting abou when I say that.
02:33:00 <elliott> but boy is it true.
02:33:04 <arkeet> haha
02:33:06 <arkeet> what's Key?
02:33:12 <elliott> exactly!
02:33:22 <shachaf> According to Data.IntMap, type Key = Int
02:33:22 <arkeet> :Ôø•
02:33:24 <elliott> Key is where you have sameKey :: Key s a -> Key s b -> Maybe (Is a b)
02:33:29 <quchen> marekw2143: It doesn't "translate to", it *translates to*. :-)
02:33:43 <elliott> you can build e.g. ST (even a transformer version), Vault, and Typeable from this API.
02:33:45 <quchen> What you've written is what the compiler makes out of do notation.
02:33:47 <elliott> the problem is constructing the Keys.
02:33:51 <marekw2143> quchen: but evaluation of "f x" gives us "State state a"
02:34:04 <marekw2143> quchen: then we have Leav with "State" instance embedeed
02:34:05 <elliott> an instance of Typeable is *actually* just a global key the compiler makes up for you. that's why it's unsafe to be able to give custom Typeable instances.
02:34:12 <arkeet> marekw2143: do {y <- f x; ...} = f x >>= \y -> do {...}
02:34:19 <arkeet> this is honest equality.
02:34:20 <elliott> and you can make keys in a universally-quantified-world monad like ST.
02:34:23 <frerich> Xaratas: I think I might have something...
02:34:29 <kryft> shachaf: But thanks anyway.
02:34:30 <elliott> (so you can build ST as StateT + KeySupplyT)
02:34:33 <quchen> marekw2143: No. Remember, you're not putting "f x" into the leaf. You're "pulling out the value" using <- first.
02:34:39 <quchen> And then you put the pulled out value in the leaf.
02:34:43 <elliott> I get the feeling not even arkeet is listening.
02:34:52 <arkeet> elliott: sorry, let me look now. :p
02:35:18 <quchen> marekw2143: Putting in the State would look like "mapTreeM f (Leaf x) = Leaf (f x)"
02:35:21 <arkeet> e;;owjat
02:35:27 <arkeet> elliott: what's the role of s?
02:35:40 <shachaf> kryft: ?
02:35:44 <quchen> What you do is "mapTreeM f (Leaf x) = f x >>= return . Leaf
02:35:55 <arkeet> = Leaf <$> x
02:36:02 <arkeet> er
02:36:03 <arkeet> = Leaf <$> f x
02:36:09 <elliott> arkeet: for instance, in (ST s), you use (Key s)es
02:36:15 <kryft> shachaf: For trying to explain. :)
02:36:39 <elliott> arkeet: have I mentioned this solves the problem of global safe IO/STRefs?
02:36:44 <arkeet> no
02:36:54 <elliott> yes I have. I just did!
02:36:54 <arkeet> this sounds magical, do you have soemthing written up?
02:36:56 <shachaf> elliott: What's your solution?
02:37:03 <shachaf> elliott: Is it just ACIO or something else?
02:37:11 <shachaf> kryft: I'd be happy to clarify things but the example I gave probably isn't the best one to start with.
02:37:14 <elliott> shachaf: it's just newKey. all you can do at the top level is newKey.
02:37:22 <elliott> that's all you need for both Typeable and IORefs etc.
02:37:24 <quchen> arkeet: Wait, 'return . f =<< m' == 'f <$> m'?
02:37:24 <shachaf> Oh.
02:37:32 <arkeet> quchen: properly, liftM f m, but yes.
02:37:38 <hpaste> ‚ÄúAnonymous Coward‚Äù annotated ‚ÄúMaping‚Äù with ‚ÄúMaping (annotation) (annotation)‚Äù at http://hpaste.org/83443#a83445
02:37:38 <arkeet> @src liftM
02:37:39 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
02:37:43 <elliott> arkeet: I have something "written up" in about five .hs files in ~/tmp
02:37:50 <arkeet> heh
02:37:56 <quchen> I've never used liftM. (And I won't change that! :P)
02:37:57 <kryft> shachaf: Right, it's probably best that I refresh my memory a bit more first
02:37:59 <marekw2143> arkeet: but in State monad instance, >>= is defined as: http://hpaste.org/83445
02:38:02 <elliott> have I mentioned it's efficient???
02:38:14 <arkeet> marekw2143: yes,s o?
02:38:28 <elliott> class Typeable a where key :: Key RealWorld a -- the True Meaning of Typeable
02:38:56 <quchen> arkeet: And I thought I had tackled all antipatterns in my monadic/applicative notation. Oh well, add that one to the list :-)
02:38:57 <shachaf> elliott: How do you make IORefs from newKey efficiently?
02:38:58 <marekw2143> arkeet: ohh, I see
02:39:05 <ARCADIVS> Which makes more sense: The sum of the empty list is 0 or the sum of the empty list is undefined (like division by 0)?
02:39:13 <marekw2143> arkeet: it's very abstract
02:39:15 <quchen> ARCADIVS: 0.
02:39:17 <marekw2143> but logical
02:39:18 <parcs> elliott: how do you distinguish a :: IORef Int and b :: IORef Int
02:39:37 <ARCADIVS> quchen: but an empty list has no numbers. How can there be a sum?
02:39:41 <elliott> parcs: you can have multiple keys of the same type
02:39:45 <quchen> ARCADIVS: The sum of nothing should generally be the neutral element, which is 0 for addition.
02:39:51 <elliott> a Key is just a unique identifier that remembers a type (for giving you equality evidence for it later)
02:39:58 <elliott> shachaf: uh, define efficiently
02:40:06 <elliott> as in "HashMap efficient" or "actual real IORefs efficient"?
02:40:17 <arkeet> ARCADIVS: the sum of the empty list is defined to make things convenient for us as possible
02:40:21 <Xaratas> ARCADIVS: the number of elements in the empty set? (menge) is also well defined and its 0
02:40:26 <elliott> by efficient I mostly meant Typeable casting.
02:40:28 <arkeet> ARCADIVS: for instance, with that definition we get sum (xs ++ ys) = sum xs + sum ys
02:40:31 <quchen> ARCADIVS: It's a convenient definition in many ways. Maybe as a motivational example, you want sums to distribute properly, i.e. sum ([1,2,3] ++ []) == sum [1,2,3] ++ sum []
02:40:35 <shachaf> elliott: Actual real IORefs efficient.
02:40:40 <arkeet> for any xs and ys, empty or not.
02:40:49 <quchen> ARCADIVS: Similarly, product [] = 1
02:41:05 <ARCADIVS> arkeet: what's inconvenient about just using the traditional definition of sum as an inner helper function and leaving sum of the empty list undefined?
02:41:14 <arkeet> huh?
02:41:17 <quchen> ARCADIVS: See also this article: http://en.wikipedia.org/wiki/Empty_sum
02:41:22 <elliott> shachaf: well, let's say you have a "monomorphic ST"
02:41:31 <elliott> shachaf: that is, where you can make a bunch of refs but they all have to have the same type
02:41:36 <arkeet> ARCADIVS: the point is that there's a natural and convenient way to define it on the empty list.
02:41:38 <arkeet> so we do that.
02:41:39 <quchen> ARCADIVS: On a side note, leaving stuff undefined is baaad.
02:41:44 <arkeet> that too
02:41:53 <arkeet> foldr1/foldl1 are evil.
02:41:54 <elliott> then you can do the state part of your IO as MonoST RealWorld (Locker RealWorld)
02:42:08 <elliott> where data Locker s = forall a. Locker (Key s a) a
02:42:29 <quchen> arkeet: And head tail plus the rest of Prelude :-(
02:42:30 <elliott> (ok, you pay an extra level of indrection: no comparing the pointers directly any more. but gimme a break.)
02:42:33 <arkeet> quchen: yep
02:42:46 <arkeet> quchen: oh god, that article.
02:42:48 <arkeet> The value of any empty sum of numbers is conventionally taken to be zero, as is the average.
02:42:52 <arkeet> *as is the average*.
02:42:56 <arkeet> ???????????
02:42:59 <ARCADIVS> quchen: normally when you make any program of significant size you leave lots of things undefined. When you use a function with arguments having a type that don't match the function's type you have left the function undefined for certain types.
02:43:05 <quchen> arkeet: Oh. I didn't read that far. Haha
02:43:25 <quchen> arkeet: I just know there was an "empty product" article, looked for "empty sum" and linked that ;-)
02:43:40 <shachaf> ARCADIVS: That's why you don't do that. Have you noticed which channel you're in?
02:43:48 <arkeet> oh.
02:43:54 <arkeet> quchen: some vandal inserted it in there.
02:44:07 <ARCADIVS> Leaving things undefined is just fine as long as you get slapped in the face at compile time when a case you didn't consider occurs.
02:44:42 <quchen> ARCADIVS: You're confusing two things here. Of course, a function "Bool -> Bool" is not defined if you give it an Int argument. But that won't compile, so it's not even not defined. What we mean with "don't do undefined" is having a function that crashes at compile time (e.g. by calling error).
02:44:55 <quchen> Functions should generally map non-crashing values to non-crashing values.
02:45:05 <quchen> (Called "total functions").
02:45:07 <arkeet> quchen: you mean compiles, but crashes at run time.
02:45:31 <quchen> arkeet: Yes. An example would be Prelude.head.
02:45:34 <quchen> > head [1,2,3]
02:45:36 <lambdabot>   1
02:45:36 <hpaste> frerich annotated ‚Äúmagicsquare parts‚Äù with ‚Äúmagicsquare parts (annotation)‚Äù at http://hpaste.org/83389#a83446
02:45:39 <arkeet> you said crashesh at compile time
02:45:39 <arkeet> :p
02:45:40 <quchen> > head []
02:45:42 <lambdabot>   *Exception: Prelude.head: empty list
02:45:45 <arkeet> crashes.
02:45:45 <quchen> BOOOOO
02:46:04 <frerich> Xaratas: Check that annotation I did to your code at  http://hpaste.org/83389#a83446 -- it's a bit lame, but I think it deos what you wanted?
02:47:17 <quchen> (I wish there was a version of 'undefined' that issues a warning when compiling. Without TH, that is.
02:47:21 <quchen> )
02:47:43 <arkeet> where would the warning be produced?
02:48:02 <quchen> arkeet: Don't care. Somewhere during compilation. Just so I don't forget my undefineds.
02:48:08 <arkeet> ok.
02:48:21 <arkeet> doesn't ghc have a WARNING pragma?
02:48:26 <quchen> Does it?
02:48:30 <arkeet> it does.
02:48:32 <quchen> OH BOY!
02:48:34 <Xaratas> frerich: ok, i try to understand it, are the monads necesary or are they only a habbit?
02:49:37 <quchen> arkeet: Oh, that one! I even knew about it haha
02:49:54 <quchen> The "deprecated" if something's not deprecated
02:50:57 <frerich> Xaratas: They are not necessary here, but it's very convenient to treat the list as a monad.
02:51:14 <ARCADIVS> I'll grant there is a tradition of interpreting the sum of an empty list as 0 in mathematics and programming, but when you try to get sums/products from empty lists in a program (a practical situation) doesn't suddenly getting 0/1 when you had nothing in your list originally just ask for trouble in a bigger context?
02:51:27 <frerich> Xaratas: ...because then you can use 'replicateM' to get all sublists of length 'n' from your input list
02:52:15 <frerich> Xaratas: So all I did was to use that, and then filter by your two criteria (no two elements may be equal, sum of all elements must match magic sum). That gave me the candidates' function
02:52:31 <elliott> arkeet: I'm offended that you haven't devoted your life to understanding the mystery and beauty of Key.
02:52:37 <arkeet> it sounds cool.
02:52:42 <arkeet> you should write something.
02:52:46 <arkeet> about it.
02:52:50 <arkeet> in English.
02:53:02 <Xaratas> frerich: yes, the normal replicate function lacks this parameter, and the permutations function is no help either, as it has only one parameter
02:53:13 <arkeet> ARCADIVS: it really doesn't.
02:53:28 <arkeet> ARCADIVS: with an empty list, you don't have nothing; you have []
02:53:49 <arkeet> ARCADIVS: quite the contrary, actually. leaving things undefined on [] is just asking for trouble.
02:54:11 <quchen> ^ This.
02:54:45 <frerich> Xaratas: For what it's worth, you have been using the list monad in your own version already.
02:54:55 <frerich> Xaratas: Have a look at http://en.wikibooks.org/wiki/Haskell/Understanding_monads/List#List_comprehensions
02:55:08 <ARCADIVS> I don't advocate leaving things undefined except where it may cause failure at compile time.
02:55:27 <arkeet> uh
02:55:31 <arkeet> that doesn't cause failure at compile time.
02:55:45 <arkeet> it can cause failure at runtime. but if that's avoidable, why do it?
02:56:20 <ARCADIVS> arkeet: I think you are misunderstanding. The type system can cause failure at compile time. You can make a datatype that is a list containing at least one element.
02:56:35 <arkeet> you can.
02:56:38 <arkeet> such a thing has been defined.
02:57:00 <arkeet> but plenty of things that make sense for nonempty lists also make sense for the empty list.
02:57:10 <quchen> It's in one of edwardk's packages iirc.
02:57:14 <quchen> Comonad something.
02:57:18 <arkeet> semigroups?
02:57:47 <quchen> http://tinyurl.com/bpjk6z4
02:57:49 <quchen> Comonad.
02:57:57 <arkeet> that says semigroups.
02:57:57 <quchen> Nevermind.
02:58:01 <arkeet> :p
02:58:09 <quchen> Took the link from Comonad so I thought it's Comonad.
02:58:19 <quchen> Let's say it's from the Edwardverse.
02:58:34 <arkeet> frighteningly many things are from there.
02:58:35 <quchen> Where all the cool stuff is that's not in the platform
02:59:31 <ARCADIVS> I feel like blurring the line between "I started with []" and "I started with [0] is just a bad idea. It's just throwing away information that might be needed.
03:00:08 <shachaf> If you want this, use a non-empty list type.
03:00:16 <shachaf> If you're using an empty list, its sum is the identity.
03:01:04 <arkeet> ARCADIVS: lists are monoids.
03:01:09 <arkeet> er
03:01:13 <arkeet> lists are a monoid.
03:01:14 <ARCADIVS> I don't know what that means.
03:01:15 <arkeet> numbers under addition are a monoid.
03:01:38 <arkeet> monoids are easy. they have some identity element (say, [] or 0), and a way of composing two elements.
03:01:45 <arkeet> (say, concatenation or addition.)
03:02:14 <Taneb> On the topic of Monoids, does anyone know where there's a version of Endo that takes a Category as well as a type
03:02:16 <arkeet> satisfying some conditions that don't need mentioning right now.
03:02:27 <shachaf> It means "things work out really nicely if you do this, and really unnicely if you don't"
03:02:41 <Taneb> newtype Endo' k a = Endo' {appEndo' :: k a a}
03:02:43 <shachaf> You wouldn't have trouble with monoids, anyway.
03:02:46 <shachaf> They are easy.
03:02:59 <blueonyx> arkeet: ah best introduction "xyz are easy"
03:03:01 <blueonyx> :)
03:03:18 <arkeet> ARCADIVS: the point is that things like sum take things from one monoid to another monoid.
03:03:31 <arkeet> e.g. lists to numbers.
03:03:52 <arkeet> but they do this in such a way that it respects the monoid operations (in fancy terms it's a "monoid homomorphism").
03:03:59 <arkeet> all that means is
03:04:08 <arkeet> it takes the identity to the identity: sum [] = 0
03:04:18 <arkeet> and it preserves composition: sum (xs ++ ys) = sum xs + sum ys
03:04:32 <arkeet> it turns out that these rules, combined with sum [x] = x, is enough to uniquely define sum.
03:04:44 <quchen> It does the right thing‚Ñ¢
03:04:49 <arkeet> yep
03:05:12 <quchen> If you don't respect those laws, you will get what the fine Brit would call "clusterfuck".
03:06:04 <frerich> :-)
03:06:29 <arkeet> ARCADIVS: anyway, rules like these make reasing about things like sum easy.
03:06:39 <arkeet> you don't have to think hard about how sum is exactly implemented
03:06:40 <shachaf> i love reasing
03:06:42 <shachaf> it is so reasy
03:06:46 <arkeet> reasoning. haha
03:07:00 <ARCADIVS> Let's all agree that this makes wonderful sense mathematically. I think I assumed it made sense in some way or another to /someone/, I just really wanted to ask if my version of a sum function was more practical, and nobody seems to think so.
03:07:00 <arkeet> I'm doing these a lot today.
03:07:30 <arkeet> I would say no, because sum as it is is strictly more general than yours.
03:07:31 <arkeet> :p
03:07:46 <neutrino> arkeet: i think this kind of stuff is exactly what defines "functional programming" languages as opposed to others
03:07:46 <shachaf> Mathematically nice things have a tendency to be nice in other places too.
03:07:47 <ARCADIVS> Do we need generality?
03:07:59 <arkeet> generality is always nice.
03:08:06 <arkeet> but in this case it's really nice because it comes for free.
03:08:18 <quchen> ARCADIVS: Mathematics isn't some academic stuff that's useful to someone. It's the result of hundreds of years of smart people figuring out the right way to do things. If it's good in mathematics and can easily be programmed, do that. There's no "better practical solution".
03:08:20 <elliott> do we need this pointless argument?
03:08:30 <elliott> I'd say it's a lot less useful than generality.
03:08:39 <arkeet> haha
03:09:13 <elliott> in fact going by the statement ARCADIVS made when they joined the channel I'm not even remotely sure how it relates to Haskell.
03:09:14 <typoclass> ARCADIVS: what's being discussed? could you repeat the link? thanks
03:09:31 <ARCADIVS> typoclass: there was no link.
03:09:55 <shachaf> typoclass: No, it's a pointless discussion.
03:10:01 <arkeet> point-free*
03:10:10 <quchen> @pl \a b c -> [a,b,c]
03:10:11 <lambdabot> (. ((. return) . (:))) . (.) . (:)
03:10:36 <ARCADIVS> elliott: I had to ask you guys because I noticed the standard definition of sum in Haskell and you guys know your functions.
03:10:49 <typoclass> ARCADIVS: ok, i meant the sum function that is being discussed. never mind.
03:11:24 <typoclass> quchen: i think that's very exaggerated. it's a pretty self-congratulatory view
03:11:36 <ARCADIVS> typoclass: the sum function I proposed is just one that only accepts a list of at least one element.
03:12:17 <quchen> typoclass: Yes. :-)
03:13:17 <quchen> ARCADIVS: How would you write an imperative program to sum a list? for(i = 0, total = 0; i < n; ++i) { total += array[i]; }
03:13:24 <quchen> Feed that an empty list and you also get 0
03:13:24 <shachaf> ARCADIVS: sum :: NonEmpty Int -> Int is a fine function.
03:13:55 <typoclass> ARCADIVS: ah i see. doesn't sound unusual to me ...
03:13:57 <shachaf> If your type says you handle empty lists, then you should handle them, though.
03:14:33 <crl> @hoogle [Char] -> ByteString
03:14:34 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
03:14:34 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
03:14:34 <lambdabot> Prelude error :: [Char] -> a
03:14:58 <ARCADIVS> quchen: I would have initialized total with the first element of the array probably but n could be 0 here so maybe not?
03:15:36 <parcs> :t Refl
03:15:38 <lambdabot> Not in scope: data constructor `Refl'
03:16:26 <shachaf> @ty substEq
03:16:28 <lambdabot> AnEquality s t a b -> ((s ~ a, t ~ b) => r) -> r
03:16:50 <Sgeo> Even Template Haskell knows that Template Haskell is LamE ;)
03:17:04 <Sgeo> (Note: I don't actually hate template Haskell)
03:17:20 <shachaf> (I do)
03:17:59 <parcs> shachaf: example
03:18:19 <shachaf> Of whom?
03:18:23 <crl> blaze looks great
03:18:34 <parcs> shachaf: of substEq usage
03:18:45 <Sgeo> crl, Blaze pretends to be a monad. It is not a monad. It could easily have been a monad, but it is not.
03:19:26 <elliott> "blaze" is ambiguous
03:19:43 <crl> @hoogle blaze
03:19:44 <lambdabot> package blaze-builder
03:19:44 <lambdabot> package blaze-builder-enumerator
03:19:44 <lambdabot> package blaze-from-html
03:19:46 <elliott> but can't really blame blaze-html for wanting efficiency while our syntactic sugar for monoids is sorely lacking
03:20:47 <crl> Sgeo: oh bad
03:20:51 <eikke> elliott: what should it look like then? (<>) ain't so bad...
03:21:15 <elliott> eikke: something like blaze-html really wants layout
03:21:37 <parcs> could it have been a monad? or could it have been a Monad?
03:21:37 <shachaf> @ty Identical
03:21:39 <lambdabot> Identical a b a b
03:21:44 <shachaf> Hey, we have Identical!
03:21:52 <eikke> html <> (
03:21:55 <eikke>   body <> (
03:22:33 <b_jonas> "<html>" ++
03:22:37 <b_jonas>   "<body>" ++
03:22:47 <crl> if it's not a monad, what does the !balze 'do' stands for
03:22:49 <elliott> parcs: it is a Monad but not a monad
03:22:55 <crl> blaze*
03:22:57 <elliott> but it doesn't really matter, it's just ugly.
03:22:59 <shachaf> > let f :: a -> AnEquality' a Int -> Int; f x e = substEq e (x + 1) in f 5 id
03:23:01 <lambdabot>   6
03:23:09 <shachaf> > let f :: a -> AnEquality' a Int -> Int; f x e = x + 1 in f 5 id
03:23:11 <lambdabot>   Couldn't match type `a' with `GHC.Types.Int'
03:23:11 <lambdabot>    `a' is a rigid type variabl...
03:23:16 <shachaf> There you go, an example.
03:23:34 <Sgeo> parcs, it could have been a Writer something monad
03:23:48 <frerich> eikke: Makes me wonder whether there's something which can create such DSLs out of a Schema or the like, so that the type system avoids creating invalid documents.
03:24:27 <eikke> frerich: I guess that should be possible, but would introduce quite a bunch of typeclasses
03:25:13 <KneferilisHome> hello, how would you describe what a first class function and a higher order function are?
03:26:16 <Botje> the former enables the latter
03:26:30 <hpaste> ‚ÄúAnonymous Coward‚Äù annotated ‚Äúmagicsquare parts‚Äù with ‚Äúmagicsquare parts (annotation) (annotation)‚Äù at http://hpaste.org/83389#a83447
03:26:44 <shachaf> Blugh, Identical is annoying.
03:26:55 <eikke> KneferilisHome: first class function -> functions can be treated as values. higher-order-functions: functions can take functions (as values) as arguments
03:26:57 <Botje> first class functions in a language means that you can pass functions around and store them
03:27:09 <typoclass> KneferilisHome: hi. a first-class function can be passed around (into other functions). a higher-order function takes other functions. it's kind of symmetric when you put it like that
03:27:30 <tech2> > 6
03:27:32 <lambdabot>   6
03:27:38 <Xaratas> frerich: thanks, i have found a few easy performance tweaks http://hpaste.org/83389
03:27:46 <crl> > ()
03:27:48 <lambdabot>   ()
03:28:47 <frerich> Xaratas: 'nub' is better than 'group . sort'? I can hardly believe that. Maybe your lists are really short?
03:29:16 <crl> > () `(,)` ()
03:29:17 <lambdabot>   <hint>:1:5: parse error on input `('
03:29:40 <crl> > () , ()
03:29:42 <lambdabot>   <hint>:1:4: parse error on input `,'
03:29:51 <Iceland_jack> > (,) () ()
03:29:52 <Xaratas> frerich: you have given each element into the filter, so for the n = 5 i tested they are only 5 elems long
03:29:53 <lambdabot>   ((),())
03:30:00 <ARCADIVS> In order to evaluate a fully applied function a Haskell implementation generates/executes instructions (imperative programming). You can't hide your sins from me GHC!!!! I demand pure functions! How dare you make my functions _do_ something?!
03:30:08 <frerich> Xaratas: Did you build with optimizations for those benchmarks?
03:30:09 <crl> > (,) () ()
03:30:11 <lambdabot>   ((),())
03:30:29 <elliott> ARCADIVS: what's the point of saying this?
03:30:30 <Xaratas> frerich: nope, pure ghci
03:30:31 <crl> too late..
03:30:35 <shachaf> ARCADIVS: Did you come into this channel just start arguments?
03:30:51 <ARCADIVS> Arguments? That was my lame attempt at humor.
03:31:09 <parcs> haskell is a fine imperative language, though
03:31:40 <frerich> Xaratas: I think you should benchmark the code with optimizations enabled (you may find that the compiler does a really good job and your bottlenecks are somewhere else)
03:31:46 <Sgeo> I'm starting to worry that I may have been using Haskell imperatively.
03:32:03 <crl> OO-haskell
03:32:13 <Sgeo> imperative != OO
03:32:27 <crl> the base of OO often no?
03:32:42 <Ralith> Sgeo: why is that something to worry about?
03:32:54 <Sgeo> You can have imperative programming without OO, and you can have OO without imperative programming (although I haven't seen a language that does that)
03:33:00 <ARCADIVS> Sgeo: you should be worried if anything happens when you "run" your programs.
03:33:16 * Ralith wonders why ARCADIVS is (still) here
03:33:34 <Sgeo> I should sleep, I have a phone interview in a few hours
03:33:41 <crl> haskell with records is object oriented ;)?
03:34:20 <ARCADIVS> Ralith: I like haskell. I won't have much to say for a while, but can't I stay?
03:35:19 <Iceland_jack> crl: No?
03:35:22 <Ralith> ARCADIVS: if have little to say, say little.
03:36:21 <ARCADIVS> I was planning on having little to say eventually, just not when I first came.
03:37:43 <crl> Iceland_jack: no about hs being oo?
03:38:13 <Iceland_jack> Having records don't make Haskell object oriented
03:38:32 <KneferilisHome> I see. Thank you all.
03:47:17 <crl> lens makes it a bit OO imo
03:48:01 <arkeet> nah, lens makes things better.
03:59:01 <tdammers> \o/ space leak fixed
04:11:49 <tdammers> still uses 190 megs of RAM, but at least it's constant
04:12:30 <quchen> Aaaaand that's why O(1) isn't necessarily good
04:13:33 <quchen> tdammers: It's like your boat is sinking and you realized it too late, but now that you're aware you can use a bucket to take out the water fast enough to stop sinking more :D
04:15:09 <crl> I've seen import Text.Blaze.Html5 hiding (map, head); import qualified Text.Blaze.Html5 as H,.. .. qualified Text.Blaze.Html5 hiding (map, head) as H isn't valid?
04:15:40 <quicksilver> software engineer is all about making big enough/efficient enough buckets to keep your boat afloat despite the big holes in its hull.
04:15:49 <quicksilver> s/eer/eering/;
04:16:26 <tdammers> hehe yeah
04:16:54 <tdammers> tbh, I just threw in a few $!'s at more or less random places
04:23:49 <quchen> What does ~ stand for in type signatures by the way? For example, cast :: (Typeable a, Typeable b) => (a ~ b => r) -> Maybe r
04:24:06 <Sgeo> That relies on an extension, doesn't it?
04:24:21 <quchen> No idea
04:24:32 <parcs> quchen: it's a type equality constraint
04:24:45 <parcs> quchen: a ~ b means a and b must be the same type
04:25:10 <quchen> parcs: Why not use 'a' twice?
04:25:56 <quchen> The example above from Typeable has two types that are pinned to be equal.
04:26:10 <quchen> Is it because they don't have to be globally equal, but only for the function's parameter?
04:26:59 <Botje> speaking of which
04:26:59 <Botje> I saw 'silver linings playbook' yesterday
04:27:59 <quchen> A movie about Haskell type signatures?
04:28:59 <Botje> ah.
04:29:05 <Botje> my connection messed up, sorry.
04:29:18 <notdan> quchen: if I am correct, several types can be isomorphic without actually being the same. Like if you have type A a = Bool, A Int ~ A Char ~ Bool
04:29:20 <Botje> I blind-typed some stuff, looks like the channel switch didn't happen :(
04:30:09 <quchen> notdan: Is there a name or a page in the GHC manual about this?
04:31:31 <notdan> Not sure, I'll try to ook it up
04:31:32 <notdan> *look
04:31:55 <quchen> notdan: Problem is when I search for anything with tilde and Haskell everyone talks about irrefutable patterns :/
04:31:57 <Sgeo> report :: Bool -> String -> Q ()Source
04:31:57 <Sgeo> Report an error (True) or warning (False), but carry on; use fail to stop.
04:32:16 <Sgeo> That is a totally brilliant API design right there, boolean as an argument to something with semantic meaning
04:32:29 <Sgeo> report True "Blah" is perfectly understandable
04:32:46 <notdan> quchen: so, another example why this is useful (as opposed to just using 'a' twice): http://www.haskell.org/haskellwiki/GHC/Type_families#Equality_constraints
04:33:13 <prh>  /join #winswitch
04:33:31 <notdan> quchen: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/equality-constraints.html
04:33:35 <prh> clearly thats not what I intended. duh :)
04:34:03 <notdan> > 1
04:34:05 <lambdabot>   1
04:34:16 <parcs> /msg NickServ identify hunter2
04:34:24 <notdan> > type A a = Bool
04:34:26 <lambdabot>   <hint>:1:1: parse error on input `type'
04:34:34 <notdan> hm
04:35:15 <quchen> notdan: Thanks!
04:35:40 <notdan> yw
04:35:41 <notdan> g2g now
04:38:37 <Botje> I should probably take hunter2 as password.
04:38:40 <Botje> nobody would ever believe me.
04:40:02 <tdammers> people will still have it among the first 10 or so entries in their dictionary attacks
04:40:23 <tdammers> right along with '12345', 'password1' and 'secret'
04:40:42 <crl> for a f :: a -> a -> a, how do you simplify: f (f "a" "b") "c"
04:40:59 <crl> if possible
04:41:10 <Sgeo> > if | 5 < 0 -> 3 | otherwise -> 4
04:41:12 <lambdabot>   <hint>:1:4: parse error on input `|'
04:41:14 <Sgeo> hm.
04:43:13 <Radish> hey guys, I've got this huge pipeline style algorithm that filters based on several important qualities.  It's impossible to read or deal with.  Any advice as to how I should handle it?
04:43:19 <quchen> crl: You can't if you don't know f. For example, set 'f x y = y', then the result is "c". Set 'f = mappend', then the result is "abc".
04:43:30 <Radish> Its like, messy and long.
04:44:05 <Sgeo> Take out parts, give them names?
04:44:12 <Radish> how do people typically handle this kind of thing?  does anyone have any links for good formatting for haskell?  I can't find much for a single big function like this.
04:44:13 <tdammers> a.k.a. "refactoring"
04:44:31 <quchen> Radish: We don't know your function. Post some code so we don't have to guess.
04:44:52 <Radish> quechen: its just a bunch of lambda filters
04:45:11 <Botje> stick them together in a list comprehension or something?
04:45:16 <Botje> or are there non-filter steps inbetween
04:45:16 <Radish> quechen: I'm half way butchered it so I don't think it even runs right now, but I'll post it later
04:45:33 <Botje> giving the lambdas names is a good first step
04:45:47 <Radish> botje: okay I'll go for both
04:46:10 <Radish> sgeo: also will do sir
04:46:33 <Radish> sgeo: I dunno it's either going to be something long but still obscure or just step1 step2 lol
04:46:50 <Radish> sgeo: should I say postXFilter?
04:47:03 <Botje> something concrete
04:47:11 <Radish> its all kind of abstract, hard to get words for everything
04:47:12 <Botje> like isPowerOfTwo or isJpeg
04:47:26 <Radish> hasEvenPopCount?
04:47:36 <Radish> or correctedPopCount?
04:47:39 <Radish> like that?
04:47:56 <Botje> something like that.
04:48:05 <Radish> okay will do.
04:48:09 <Radish> thanks guys
04:48:09 <Botje> you can further split up your pipeline according to type changes
04:48:16 <Botje> or at logical places
04:48:18 <Radish> all polynomials
04:48:23 <Radish> the whole way down
04:48:31 <Radish> one single long filter of a bunch of steps.
04:48:44 <tdammers> how about you paste some code?
04:49:00 <Radish> tdammers: It'll have to be later on, it's all butchered right now
04:49:15 <Radish> thanks though I'll be back later to harass y'all some more lol
04:49:20 <Radish> :)\
04:49:56 <crl> quchen: right
04:50:43 <bmk> hi guys! I was reading the source-file for Data.List and I am wondering what the directiv '#ifdef USE_REPORT_PRELUDE' could mean... For example depending on this directive there are two alternative definitions of `all` and `or`... any hints? thx in advance
04:51:18 <shachaf> bmk: One of them is for the Prelude as specified in the Haskell Report.
04:51:22 <shachaf> The other is for the Prelude GHC uses.
04:53:30 <dario> bmk: do you know any C dialect? it's effectively C preprocessor macros..
04:53:42 <bmk> Ah i see... thank you! well, I was browsing the Data.List source-file, because I have a feeling that my code is faster when I write (and . map f) instead of (all f)...
04:53:49 <quchen> bmk: The Haskell report gives easy to understand definitions of Prelude functions. However, they aren't very performant in many cases.
04:54:27 <quchen> bmk: Writing "and . map f" just lengthens your code.
04:55:40 <bmk> yeah, thats what i thought... but look at here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-List.html#all... Could it be, that the second definition of `all` is slower than the variant of `USE_REPORT_PRELUDE'`
04:55:53 <quchen> bmk: In the best case, your version is as fast as using 'all'. However, 'all' has a rewrite rule attached to it, which isn't fired when you use 'and . map f'.
04:57:05 <quchen> No, I don't think it's slower.
04:57:08 <quchen> Why would it be?
04:57:58 <quchen> Typically, the REPORT_PRELUDE functions are easier to read, but perform worse.
04:58:31 <quchen> I'm not sure about this case, maybe performances are equal.
04:58:32 <bmk> Ok I see... well, I have to investigate this little bit further... maybe the problem is somewhere else...
05:00:32 <quchen> bmk: I don't think a simple function such as 'and' is the source of a problem. If your program is slow, it's probably some other reason, e.g. calculating the predicate is expensive.
05:00:32 <bmk> is the second variant of `all` tail recursive? or will it will be optimized into a loop by the compiler shortcircuting when first False is encountered?
05:01:12 <Botje> bmk: how big is the list you're feeding to all?
05:01:17 <quchen> bmk: No, it's not tail recursive.
05:01:31 <quchen> bmk: But it's short-circuiting.
05:02:03 <Botje> bmk: also, the compiler can probably fuse the 'all' part into the creation of your list.
05:02:05 <bmk> ok... the list quite large and the predicate f is expensive
05:03:00 <johnw> bmk: is there any way to reorder the list so that a negative result might be found sooner?
05:03:03 <Botje> the second definition will stop as soon as it encounters a False, yes.
05:03:21 <Botje> moreover, it has fusion rules attached to it, so no intermediate rule will be attached to it
05:03:41 <Botje> uh
05:03:47 <Botje> no intermediate list will be generated
05:04:33 <bmk> johnw: yes I am reordering the list heuristically, so that the "False"s can be found sooner if they exist
05:06:38 <bmk> well the issue is not critical for me anyway... the main bottleneck is much worse in my program ;)... but I was wondering, why my program would seem run faster when wrting (and . map f) instead of `all`
05:08:21 <bmk> maybe I will try to read core-dump of ghc to be sure, if the time allows :)
05:08:52 <bmk> thank you guys
05:09:38 <quchen> Botje: Speaking of fusion, how is stuff like "filter odd . filter (> 5) $ [1..]" fused?
05:10:09 <quchen> I can't find a rule for this, but it would naturally be better to write it as "filter (odd && >5)¬ß
05:10:19 <quchen> Argh, sausage fingers today
05:12:02 <fizbin> Isn't exactly that rule the example given on the page http://www.haskell.org/haskellwiki/Fusion ?
05:12:48 <fizbin> @pl \p q x -> p x && q x
05:12:48 <lambdabot> liftM2 (&&)
05:13:12 <quchen> fizbin: Yes, but in the code I can't find anything related: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-List.html#filter
05:13:23 <parcs> quchen: right underneath
05:13:28 <parcs> quchen: filterFB"        forall c p q. filterFB (filterFB c p) q = filterFB c (\x -> q x && p x)
05:14:11 <quchen> Ah, c = cons-like
05:14:51 <quchen> And all filters are rewritten by rule #1 to be filterFB, then by rule #2 to filter again, and in between #3 fuses
05:14:54 <quchen> ..?
05:15:20 <quchen> So RULE [1] stands for phase 1 (whatever that is), [~1] for up to phase 1, and "" for "anytime GHC likes"?
05:15:58 <parcs> RULE [1] is phase 1 or later
05:16:32 <parcs> there are three decreasing phases: 2,1,0
05:17:05 <quchen> I see. It starts at 2, and simplifies [2] or "" rules until it reaches a fixed point
05:17:21 <quchen> Then it starts again in phase 1, with possibly different rules
05:17:40 <parcs> [1] is "do it on phase 1 or 0", [~1] is "do it before phase 1 (i.e. do it in phase 2)" and nothing is "do it whenever", i think
05:18:15 <fizbin> :t (:)
05:18:16 <lambdabot> a -> [a] -> [a]
05:19:32 <fizbin> Can anyone explain to me what kind of argument might get passed to "build"? I'm having trouble figuring out that type.
05:19:33 <quchen> So filter is torn apart in phase 2 to filterFB (which can be fused), \
05:19:35 <quchen> and in phase 1 it' s put together again
05:20:17 <quchen> fizbin: You can express a list type as a Lambda: \nil cons -> 3 `cons` (4 `cons` nil)
05:20:25 <quchen> Looks like 3:4:[], right?
05:20:40 <quchen> Making that "\nil cons" type list into a proper list is done using build
05:20:40 <fizbin> That is, I think I know that something of type (a -> b -> b) -> b -> b might mean, but I don't know what something of type (forall b. (a->b->b) -> b ->b) is
05:21:12 <crl> @hoogle cons
05:21:13 <lambdabot> Prelude const :: a -> b -> a
05:21:13 <lambdabot> Data.Function const :: a -> b -> a
05:21:13 <lambdabot> Control.Applicative Const :: a -> Const a b
05:21:22 <fizbin> quchen: Okay, but build takes only one argument.
05:21:26 <quchen> crl: "cons" is how you pronounce (:)
05:22:02 <fizbin> Oh, wait, I think I see what you're saying...
05:22:05 <elliott> :t gcast1
05:22:06 <elliott> :t gcast2
05:22:07 <lambdabot> (Typeable1 t', Typeable1 t) => c (t a) -> Maybe (c (t' a))
05:22:08 <lambdabot> (Typeable2 t', Typeable2 t) => c (t a b) -> Maybe (c (t' a b))
05:22:44 <fizbin> Except that then what "build" takes is actually (flip nilcons), if nilcons is the lambda you had above.
05:23:09 <fizbin> But how do the "forall" parts in the type of build change things?
05:23:13 <fizbin> :t build
05:23:15 <lambdabot>     Not in scope: `build'
05:23:15 <lambdabot>     Perhaps you meant `buildG' (imported from Data.Graph)
05:23:25 <fizbin> :t GHC.Exts.build
05:23:26 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
05:24:57 <crl> yep but my problem is there are : Data.ByteString.Lazy.Char8.cons :: Char -> ByteString -> ByteString
05:25:12 <crl> and Data.ByteString.Lazy.cons :: Word8 -> ByteString -> ByteString
05:25:14 <fizbin> :t \conish nilish -> 3 `conish` ( 4 `conish` nilish)
05:25:16 <lambdabot> Num a => (a -> t -> t) -> t -> t
05:25:40 <fizbin> That doesn't have a 'forall' in it.
05:25:58 <elliott> it has an implicit one
05:26:07 <fizbin> > GHC.Exts.build (\conish nilish -> 3 `conish` ( 4 `conish` nilish))
05:26:09 <lambdabot>   Not in scope: `GHC.Exts.build'
05:26:57 <fizbin> elliott: But why does the type signature for build have an explicit forall in its first argument?
05:26:59 <parcs> fizbin: the inner forall says that the function you're passing in must be polymorphic in b.
05:27:17 <crl> and I would like cons :: Char ->  ByteString -> ByteString
05:27:47 <crl> cons :: ByteString ->  [ByteString] -> [ByteString]
05:27:57 <crl> ^ would like this one
05:28:02 <arkeet> :t (:)
05:28:04 <lambdabot> a -> [a] -> [a]
05:28:18 <arkeet> don't use Char8.
05:28:26 <elliott> fizbin: it's a matter of who picks the "a" and "b"
05:28:35 <elliott> er, just the b
05:28:38 <elliott> with GHC.Exts.build's type, build picks the b
05:28:44 <crl> arkeet:  holy % , ok thx
05:28:48 <elliott> if it said ((a -> b -> b) -> b -> b) -> [a]
05:28:51 <elliott> then you'd get to pick the b
05:28:55 <quchen> > let build g = g (:) [] in build $ \cons nil -> 3 `cons` (4 `cons` nil)
05:28:57 <elliott> you could give it ((Int -> () -> ()) -> () -> ())
05:28:57 <lambdabot>   [3,4]
05:29:03 <elliott> that wouldn't be very useful for it.
05:29:15 <elliott> it wants to be in control of the "b" (e.g. to set it to [a])
05:29:18 <fizbin> parcs: Okay, so you're saying that I can't pass build a function ((Int -> String ->string) -> String -> String)
05:29:19 <elliott> (which it does)
05:29:44 <elliott> hence your function must work for _all_ "b"
05:31:09 <arkeet> it's also not ((a -> [a] -> [a]) -> [a] -> [a]) -> [a]
05:31:48 <fizbin> Why does the hackage doc for http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-Exts.html#v:build have an extra "forall a ." that lambdabot didn't give?
05:31:55 <crl> in http://jaspervdj.be/blaze/tutorial.html they are saying import Text.Blaze.Html5;
05:32:02 <crl> import qualified Text.Blaze.Html5 as H
05:32:06 <arkeet> fizbin: because it's written in th esource.
05:32:09 <crl> isn't that redundant
05:32:26 <fizbin> arkeet: Okay, but that outer forall is redundant?
05:32:36 <arkeet> fizbin: yes
05:32:57 <arkeet> crl: not entirely, it lets you use certain names unqualified while using other names that may overlap qualified.
05:32:58 <fizbin> So I could give build a function that was ((Int -> b -> b) -> b -> b)
05:33:06 <arkeet> crl: it could be made shorter by saying import Text.Blaze.Html5 as H
05:33:07 <arkeet> (no qualified)
05:33:27 <crl> arkeet: fine thx
05:33:28 <tdammers> I wonder what the performance penalty is for using IORef
05:33:28 <arkeet> fizbin: yes, and you'd get a [Int] out
05:33:44 <arkeet> I thought IORef was supposed to be pretty fast
05:33:49 <tdammers> tjat
05:33:55 <tdammers> that's what I thought too
05:34:19 <tdammers> but now I have this audio processing chain, and whenever I add something that uses an IORef, it rains XRuns
05:34:44 <tdammers> i.e., my code can't keep up with jack anymore
05:34:46 <Botje> make sure you're not storing thunks in your IORef
05:34:57 <tdammers> oh dear, yeah...
05:35:03 <tdammers> that could very well be the problem
05:35:20 <tdammers> how would I do that? writeIORef ref $! value?
05:35:40 <arkeet> sure.
05:35:43 <Botje> for example
05:35:59 <tdammers> oh hey, I see... I'm using modifyIORef there
05:36:04 <tdammers> maybe that's not such a good idea then
05:36:15 <crl> @hoogle Html -> ByteString
05:36:15 <lambdabot> Data.ByteString.Lazy unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
05:36:16 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
05:36:16 <lambdabot> Data.ByteString.Lazy.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
05:36:20 <Botje> why not?
05:36:58 <Botje> can always use evaluate, worst case.
05:37:03 <tdammers> is modifyIORef a strict update? or does it store a thunk with the function I passed applied to the previous contents?
05:37:24 <supki> modifyIORef isn't strict
05:37:32 <supki> modifyIORef' is though
05:37:38 <Botje> "Be warned that modifyIORef does not apply the function strictly. This means if the program calls modifyIORef many times, but seldomly uses the value, thunks will pile up in memory resulting in a space leak."
05:37:51 <Botje> and then there's advice to use the strict version, indeed
05:37:58 <tdammers> let me try modifyIORef' then
05:43:26 <crl> Text.Blaze.Internal.MarkupM is a monad though
05:55:35 <McManiaC> is it possible to make this work? http://npaste.de/p/2G/
05:56:00 <McManiaC> i.e. i want to insert (a list of) statements into a quasi quote instead of just expressions with jmacro
05:56:35 <arkeet> it's up to jmacro whether you can do that.
05:57:54 <McManiaC> maybe someone knows? :)
06:02:55 <arkeet> McManiaC: my guess is you need to turn it into a JExpr somehow.
06:03:02 <arkeet> looks like JFunc might let you turn a JState into a JVal.
06:03:25 <arkeet> JStat*
06:06:45 <Saizan> McManiaC: try removing the braces
06:07:36 <McManiaC> Saizan: then I get 'unexpected "`"'
06:07:44 <McManiaC> "expecting statement"
06:08:06 <McManiaC> Saizan: you mean `go ...` instead of `(go ..)` right?
06:08:30 <Saizan> McManiaC: no, i mean the { } ones
06:09:01 <Saizan> fun linkLines codeOut `(go stmts)`
06:09:56 <McManiaC> oh cool
06:10:03 <McManiaC> thanks! now it works
06:10:14 <sclv> right. in an expr context you get an expr. in a block context you get a block of statements.
06:10:16 <arkeet> or thatl.
06:10:44 <McManiaC> yeah i think i got it
06:11:59 <Saizan> sclv: tbf the inside of { .. } feels like both an expr and a block context
06:12:18 <sclv> Saizan: yeah i was just contemplating that :-(
06:15:52 <quchen> Sorry, I had to leave previously when you talked about 'build'.
06:16:15 <quchen> What I meant to ask is what the "b" is for. Why doesn't build simply set b = [a]?
06:16:23 <Saizan> maybe you could turn the tables and have `{..}` for splicing blocks and keep `(..)` for expressions
06:16:48 <arkeet> quchen: it's to guarantee that the functions you pass to build can't actually inspect the list structure.
06:17:05 <sclv> interesting thought. that syntax is certainly free...
06:17:35 <quchen> arkeet: You mean to ensure that "build g" does only building, and not some other thing?
06:17:45 <arkeet> yeah something like that.
06:17:55 <Saizan> you'd allow silliness like this "fun foo { `{go stmts}` }" but i guess that's not too evil
06:18:02 <quchen> arkeet: Hm. Would you have an example for that?
06:18:11 <arkeet> @let build' g = g (:) []
06:18:13 <arkeet> :t build
06:18:14 <lambdabot>  Defined.
06:18:15 <lambdabot>     Not in scope: `build'
06:18:15 <lambdabot>     Perhaps you meant `buildG' (imported from Data.Graph)
06:18:16 <arkeet> :t build'
06:18:18 <lambdabot> ((a -> [a] -> [a]) -> [a1] -> t) -> t
06:18:22 <arkeet> ergh
06:18:24 <arkeet> @undefine
06:18:32 <Saizan> quchen: build could do whatever, but g is restricted that way because then foldr f z (build g) = g f z
06:18:47 <arkeet> @let build :: ((a -> [a] -> [a]) -> [a] -> [a]) -> [a]; build' g = g (:) []
06:18:49 <lambdabot>  <local>:1:1:
06:18:49 <lambdabot>      The type signature for `build' lacks an accompanying binding
06:18:53 <arkeet> @let build' :: ((a -> [a] -> [a]) -> [a] -> [a]) -> [a]; build' g = g (:) []
06:18:55 <lambdabot>  Defined.
06:19:02 <arkeet> :t build'
06:19:04 <lambdabot> ((a -> [a] -> [a]) -> [a] -> [a]) -> [a]
06:19:14 <quchen> Neat.
06:19:16 <arkeet> so
06:19:28 <arkeet> > build' (\c n -> 1 `c` (2 `c` n))
06:19:30 <lambdabot>   [1,2]
06:19:36 <arkeet> which is ok
06:19:41 <quchen> Agreed
06:20:16 <arkeet> > build' (\c n -> 1 `c` (reverse (2 `c` n)))
06:20:19 <lambdabot>   [1,2]
06:20:19 <arkeet> uh
06:20:22 <elliott> good reverse.
06:20:23 <arkeet> > build' (\c n -> 1 `c` (reverse (2 `c` (3 `c` n))))
06:20:26 <lambdabot>   [1,3,2]
06:20:36 <arkeet> or even
06:20:43 <elliott> it's mandating a kind of "linearity"/"streaming", basically.
06:20:43 <arkeet> > build' (\c n -> 1 `c` (map (+1) (2 `c` n))
06:20:46 <lambdabot>   <hint>:1:43: parse error (possibly incorrect indentation)
06:20:48 <arkeet> > build' (\c n -> 1 `c` (map (+1) (2 `c` n)))
06:20:51 <lambdabot>   [1,3]
06:20:54 <arkeet> we don't want to let it do that.
06:21:09 <quchen> Ah, I see.
06:21:34 <arkeet> @let build :: (forall r. (a -> r -> r) -> r -> r) -> [a]; build g = g (:) []
06:21:35 <lambdabot>   TypeOperators is not enabled
06:21:40 <arkeet> what?
06:22:01 <Botje> Caleskell is missing a feature?!
06:23:06 <quchen> AAaaaah I think I understand now.
06:23:33 <quchen> The forall is just a trick so that b is fully polymorphic, i.e. not just lists, so you can't intersperse list functions.
06:23:45 <typoclass> > let build :: (forall r. (a -> r -> r) -> r -> r) -> [a]; build g = g (:) [] in 42
06:23:46 <lambdabot>   42
06:23:59 <quchen> However, upon calling build, the typechecker infers b = [a], and everything's like in the naive case.
06:25:07 <crl> markups are monad in blaze, I think you can do cool things so
06:25:37 <fizbin> So the type signature is to keep you honest, and not call build with things that would invalidate the simplification rules?
06:26:27 <crl> > mapM_ show [1,2]
06:26:30 <lambdabot>   [()]
06:26:41 <crl> > mapM show [1,2]
06:26:43 <lambdabot>   ["12"]
06:27:01 <crl> > fmap show [1,2]
06:27:03 <lambdabot>   ["1","2"]
06:27:27 <latro`a> > fmap show $ sequence [1,2]
06:27:29 <lambdabot>   Could not deduce (GHC.Num.Num (f a0))
06:27:29 <lambdabot>    arising from the ambiguity check f...
06:27:33 <latro`a> bah
06:27:51 <latro`a> > sequence $ fmap show [1,2]
06:27:53 <lambdabot>   ["12"]
06:30:43 <quchen> crl: mapM show is not a very good idea usually.
06:30:49 <quchen> > mapM show [1,23]
06:30:50 <lambdabot>   ["12","13"]
06:31:12 <crl> quchen: k , that's his fault -> http://hackage.haskell.org/packages/archive/blaze-markup/0.5.1.4/doc/html/Text-Blaze.html
06:32:11 <quchen> Oh, Blaze. I heard it uses Monad syntax and doesn't implement the laws so I put it at the bottom of my todo list.
06:32:16 <crl> probably could be written better
06:32:28 <crl> quchen: lol
06:36:47 <crl> hoogle seems also angry at blaze, hard to get results
06:37:31 <dmwit> crl: He is not calling mapM show on that page (or mapM_ show either).
06:37:48 <dmwit> mapM (li . toMarkup . show) is very different from mapM show.
06:38:32 <Sgeo> What is the correct abstraction for things like deriveLenses, and when will GHC support it?
06:39:03 <edwardk> it supports it in the form of giving you template haskell
06:39:25 <Sgeo> I mean so that Template Haskell is not needed
06:39:40 <Sgeo> If the use of TH implies a missing abstraction
06:39:48 * dmwit looks into deriveLenses
06:39:59 <dmwit> Can deriveLenses be used in an instance body?
06:40:15 <dmwit> Maybe I can clean up the instances for, like, HasUsername and friends in https://github.com/dmwit/beeminder-api/blob/master/Network/Beeminder/Internal.hs
06:44:33 <edwardk> dmwit: makeFields would do that
06:47:36 <dmwit> thanks
06:50:19 <Sgeo> Be back later. Phone interview soon.
06:50:26 <crl> dmwit: yes and not sure to understand the difference between (toMarkup . show) :: Show a => a -> Markup  ...and (toMarkup ) :: ToMarkup a => a -> Markup
06:54:29 <hpaste> killy9999 pasted ‚Äúerrors with cabal bootstraping‚Äù at http://hpaste.org/83452
06:54:52 <killy9999> can anyone tell me why I get this errors when I try to bootstrap cabal ?
06:55:20 <killy9999> I have ghc 7.6.2 compiled from source
06:56:00 <supki> killy9999: do you have it in PATH? :)
06:56:20 <killy9999> yes
06:56:39 <killy9999> `which ghc` returns /home/killy/ghc-local/bin/ghc
06:58:10 <tdammers> whee, mystery half solved!
06:58:27 <tdammers> strict IORef updates didn't get rid of the xruns entirely
06:58:40 <tdammers> but compiling with -O2 did
06:58:58 <dmwit> killy9999: ...are you exporting PATH?
06:59:09 <tdammers> now I need to figure out how to get ghc to use the optimized code in interactive mode
06:59:25 <quicksilver> tdammers: if the compiled files exist, ghci will use them.
06:59:33 <dmwit> crl: One always uses the String instance for ToMarkup (after serializing) and the other doesn't.
06:59:51 <killy9999> dmwit: when I do `echo $PATH` the directory containing ghc is on the list. Is that enough?
06:59:55 <dmwit> no
07:00:14 <dmwit> You must also export PATH.
07:00:21 <quicksilver> also, killy9999, how did you invoke cabal?
07:00:24 <crl> :t show
07:00:25 <lambdabot> Show a => a -> String
07:00:26 <preflex>  lambdabot: you have 1 new message. '/msg preflex messages' to read it.
07:00:41 <quicksilver> dmwit: it is an unusual system in which PATH is not already exported.
07:00:45 <dmwit> killy9999: If you run 'getEnv "PATH"' from ghci and THAT shows the directory containing ghc, that is enough.
07:00:53 <dmwit> That's true.
07:00:56 <dmwit> Wait, is that true?
07:01:10 <crl> dmwit: yes one is a particular case of the other, (but show with a list if Strings is putting me extra "'s ;) )
07:01:21 <killy9999> dmwit: I added export PATh to my .bashrc and reloged, but that doesn't change anything
07:01:32 <dmwit> crl: No, neither is a particular case of the other, I think.
07:01:54 <dmwit> killy9999: It's a very strange problem! I'll admit freely I'm grasping at straws.
07:02:12 <dmwit> I wonder if -v (or -v2 or -v3) will say anything helpful?
07:02:16 <killy9999> dmwit: getEnv "PATH" returns the same path
07:02:36 <Saizan> killy9999: do you have '~' in there?
07:02:39 <killy9999> quicksilver: I'm running ./bootstrap.sh from cabal-install
07:02:43 <killy9999> Saizan:yes
07:02:46 <dmwit> aaaah
07:02:49 <Saizan> that's the problem
07:02:55 <killy9999> it doesn't get expanded?
07:03:00 <Saizan> right
07:03:08 <Saizan> you need $HOME
07:03:21 <killy9999> bingo!
07:03:22 <dmwit> I'm surprised the ~ didn't get expanded in the command that set the PATH.
07:03:28 <killy9999> it works
07:05:17 <quicksilver> dmwit: are you ? try 'echo ~'
07:05:33 <quicksilver> hmm, it did ;)
07:05:37 * quicksilver ponders
07:06:02 <dmwit> Perhaps it only gets expanded at the beginning of words or something...?
07:06:13 <quicksilver> that's it.
07:06:16 <quicksilver> echo bar:~
07:06:19 <dmwit> yeah
07:06:40 <quicksilver> expansion--
07:07:20 <crl> dmwit: instance ToMarkup String where ..toMarkup = string
07:07:37 <crl> this is the type used with . show
07:07:47 <dmwit> Yes, so?
07:09:38 <crl> Show a is always a String, don't really know why putting: Show a => a -> Markup, this equivalent to String -> Markup
07:10:13 <crl> certainly useful, but don't get why
07:10:21 <crl> :t show
07:10:23 <lambdabot> Show a => a -> String
07:10:39 <crl> oops Show a means an instance of Show
07:10:54 <crl> forget it ^^
07:12:15 <donri> it's equivalent to toMarkup . show
07:12:27 <donri> aka string . show
07:13:26 <crl> just to recall, the discussion was (toMarkup . show) ::  Show a => a -> Markup  ...and (toMarkup ) :: ToMarkup a => a -> Markup
07:13:39 <crl> (toMarkup . show) ::  Show a => a -> Markup   Vs   (toMarkup ) :: ToMarkup a => a -> Markup
07:15:33 <crl> I thought it would be  (toMarkup . show) ::  String -> Markup
07:15:34 <dmwit> I maintain my claim: neither is a special case of the other. They're just different functions.
07:15:55 <dmwit> Oh, well, that part at least is easily explained.
07:16:02 <crl> yes..
07:16:22 <dmwit> ok =)
07:18:56 <crl> o crap, I see now mixed start and end domains when composing functions
07:19:05 <crl> nvm
07:19:42 <dmwit> yes, f . g "runs g first" in a sense
07:19:54 <dmwit> (This is not intended to be an operational description of what happens, of course.)
07:20:28 <Kinnison> composition (tends to) reads right to left
07:22:55 <elliott> whenever I need to prove to myself I read composition left-to-right, I simply think of (1:) . const undefined
07:22:58 <elliott> or such
07:23:16 <arkeet> in a lazy language, f . g "runs f first"
07:23:18 <arkeet> :p
07:23:24 <feliperosa> Hi guys. I need a priority queue implementation, which do you recommend?
07:24:22 <arkeet> how about PSQueue?
07:24:46 <arkeet> hmm
07:26:39 <feliperosa> seems nice :)
07:27:21 <arkeet> http://stackoverflow.com/questions/6976559/comparison-of-priority-queue-implementations-in-haskell
07:27:24 <feliperosa> I was looking at Data.PriorityQueue.FingerTree
07:28:00 <EvanR> haha acid-state is now on nosql-database.org
07:28:07 <EvanR> haskell is now hip
07:28:14 <ion> hah
07:28:28 <Sculptor> hi
07:28:35 <tdammers> let the green-tea-sipping macbook-air-wielding hipsters come
07:28:44 <Kinnison> mmmm green tea
07:28:50 <EvanR> i resemble that remark >:(
07:29:00 <tdammers> :x
07:29:05 <arkeet> but I like relational algebra :(
07:29:41 <EvanR> 35?
07:29:50 <EvanR> meh undervalued
07:30:24 <donri> @hackage heaps how about an edwardk package, feliperosa?
07:30:24 <lambdabot> http://hackage.haskell.org/package/heaps how about an edwardk package, feliperosa?
07:30:48 <arkeet> why not
07:30:49 <arkeet> @hackage tables
07:30:50 <lambdabot> http://hackage.haskell.org/package/tables
07:31:12 <arkeet> hmm
07:31:38 <donri> EvanR: <GuestPuncher> i got acid-state added the nosql-database.org btw
07:31:45 <arkeet> tables isn't persistent
07:31:46 <donri> EvanR: that was the other day in here
07:31:55 <donri> arkeet: in what sense?
07:32:06 <arkeet> uh
07:32:11 <arkeet> can they be stored on disk?
07:33:00 <donri> sure, with acid-state for example
07:33:13 <arkeet> edwardk's tables?
07:33:15 <Taneb> There is currently no way to serialize a tables table
07:33:18 <donri> sure why not
07:33:22 <EvanR> donri: that was me
07:33:34 <donri> EvanR: oh :)
07:34:49 <donri> Taneb: there's a table iso to a list, easy to serialize
07:34:56 <crl> hmm how can I write with the least parenthsis, f and g::a->a->a, h::a->a ... f foo (g bar (h quux))
07:35:05 <Taneb> donri, yeah, but...
07:35:11 <donri> but what?
07:35:37 <donri> :t (.:)
07:35:38 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
07:35:41 <arkeet> f foo . g bar $ h quux
07:35:48 <arkeet> or  f foo $ g bar $ h quux
07:37:24 <crl> ah right
07:37:40 <Taneb> donri, it's ugly and I don't like it. Other than that, I have no objections.
07:38:11 <donri> Taneb: it's how you usually do it with any structure
07:38:33 <Taneb> donri, oh yeah
07:38:43 <Taneb> I'm an idiot.
07:38:58 <donri> https://github.com/kolmodin/binary/blob/master/src/Data/Binary/Class.hs#L461
07:40:20 <feliperosa> donri: The PSQueue meets my needs more closely. I need a way to bind a priority separated from the element, not just to have the Ord class.
07:40:52 <feliperosa> donri: Thanks for the sugestion anyway :), seems a nice package and I got it installed :P
07:44:21 <Taneb> instance (Serialize/Binary t, Tabular t) => Serialize/Binary (Table t) where put = reviews table put; get = view table <$> get
07:44:25 <crl> managed to have 5 $'s on 1 line http://hpaste.org/83455, smells bad
07:44:57 <crl> o well just 4
07:45:00 <Kinnison> crl: looks okay to me
07:45:07 <crl> Kinnison: eh thx
07:45:21 <Kinnison> crl: i.e. I wouldn't worry about the $s
07:45:27 <tdammers> crl: better than parentheses
07:45:29 <crl> hat's the downside of functinal programming maybe
07:45:47 <donri> don't hate on parenthesis
07:46:09 <crl> $ is just an opened parenthesis
07:46:18 <crl> *like*
07:46:50 <tdammers> donri: not per se, but an abundance of parentheses is harder read than an abundance of $'s imo
07:47:00 <tdammers> :w
07:47:11 <tdammers> hmm, irssi != vim
07:47:28 <donri> :set autowriteall
07:47:50 <CindyLinz> irssi /= vim (look for channel name :p)
07:47:54 <Botje> "#haskell" 1354592387L, 4597349684343C written
07:48:53 <tdammers> :set number o_O
07:49:15 <ion> :set notroll
07:49:37 <Taneb> Tempted to fork binary or cereal and fix what some people perceive as the problem with Put
07:49:49 <tdammers> ion: I think you're on to something
07:50:58 <donri> Taneb: what's that?
07:51:13 <donri> that it's a monad? :)
07:51:36 <Taneb> Precisely :)
07:51:56 <tsinnema> does anyone know of any blog post or article or such that would give you concrete examples of how some specific tasks are done in both conduits and pipes and iteratees and/or possibly other stream processing tools?
07:54:55 <crl> Precedence parsing error: cannot mix `.' [infixr 9] and `fmap' [infixl 9] in the same infix expression
07:55:13 <crl> then response "200 OK" ["Content-Type: text/html"] . renderHtml . dirs path . sort `fmap` getDirectoryContents absPath
07:55:23 <m0g> why does GHCI yells at me when I try to write sum . map ((- 64) . fromEnum) instead of sum . map (\x -> fromEnum x - 64) ? Shouldn't it be equivalent?
07:55:40 <int-e> m0g: - is also a unary operator
07:55:44 <simpson> m0g: Sections with - are tricky.
07:55:54 <crl> m0g: ( - 64 +)
07:55:56 <m0g> oh
07:56:01 <m0g> I see :)
07:56:02 <simpson> crl: What.
07:56:08 <m0g> thanks
07:56:10 <simpson> : (subtract 1)
07:56:14 <crl> (-64+) is a function
07:56:16 <kartoffelbrei_> What's the best way to generate TAGS files  for haskell?  I found several programs on hackage and can't decide which one to use. IIRC ghci is able to generate them too.
07:56:37 <simpson> > (subtract 1) 43
07:56:39 <lambdabot>   42
07:56:54 <simpson> It's not a proper section, but it's a lot easier to deal with.
07:57:01 <m0g> yup :)
07:57:23 <crl> try (- 64) . fromEnum -> (-64+) . fromEnum
07:57:27 <monsieurlu> hello hello ! does someone know if there is an equivalent to the `$` haskell's operator in ocaml? :)
07:57:36 <crl> simpson: ^
07:59:15 <simpson> crl: No, I get it, I just think that it's ugly and hax.
08:01:08 <donri> kartoffelbrei_: hasktags has worked best for me i think
08:01:10 <crl> improved my function http://hpaste.org/diff/83455/83457
08:01:15 <Sgeo> :t lamE
08:01:17 <lambdabot> Not in scope: `lamE'
08:01:19 <Sgeo> aww
08:01:40 <tdammers> kartoffelbrei_: I use hasktags
08:02:19 <tdammers> IIRC exuberant-ctags can do haskell but does a terrible job, and ghci is not always an option
08:03:19 <kartoffelbrei_> donri, tadammers: ok thanks, then i'll just use hasktags
08:04:47 <hseg> First time using Haddock. Got error: Warning: Main: could not find link destinations for:     GHC.Types.IO Main.getAbsoluteFiles Main.getInputFiles Main.prependLine Main.copy
08:04:59 <hseg> Main.* are all functions defined in my file
08:07:56 <donri> hseg: are they exported? are you using --haddock-executables?
08:08:05 <donri> actually how are you calling haddock
08:08:33 <hseg> haddock -h --pretty-html my_haskell_file.hs
08:09:35 <Taneb> Put is Writer (Endo (Buffer -> IO ByteString))
08:09:38 <Taneb> Which is ridiculous
08:11:40 <donri> hseg: you may have better luck using haddock via cabal. do you have a .cabal file?
08:11:53 <hseg> No.
08:12:07 <hseg> All I want is to generate some documentation for my code
08:12:20 <crl> :t it
08:12:22 <lambdabot>     Not in scope: `it'
08:12:22 <lambdabot>     Perhaps you meant one of these:
08:12:22 <lambdabot>       `id' (imported from Data.Function),
08:12:39 * edwardk highly recommends writing a cabal file for pretty much anything you do in haskell.
08:12:47 <crl> > Just $ do { return "it" }
08:12:49 <lambdabot>   No instance for (GHC.Show.Show (m0 [GHC.Types.Char]))
08:12:49 <lambdabot>    arising from a use...
08:12:52 <edwardk> it makes it easier to build, and makes it trivial to get haddocks, etc.
08:13:38 * hackagebot one-liner 0.2.1 - Constraint-based generics  http://hackage.haskell.org/package/one-liner-0.2.1 (SjoerdVisscher)
08:15:36 <hseg> Is it really necessary? All I'm writing is a ~50-line script. If generating documentation is complicated, then I'll forget about it.
08:16:26 <hseg> This is for homework, FYI. From what I've seen, the next exercise will probably be larger and more worthy of a .cabal file + version control.
08:16:53 <edwardk> http://www.haskell.org/haddock/doc/html/invoking.html
08:17:04 <edwardk> now you know as much as i do about running haddock by hand
08:18:13 <donri> hseg: what does your module declaration look like in your haskell source?
08:18:36 <hseg> Just the module body.
08:18:38 <hpaste> Nolrai pasted ‚Äúproblem‚Äù at http://hpaste.org/83458
08:18:48 <nolrai24> Okay is there anyway to tell the compiler that a ~ a1? http://hpaste.org/83458
08:18:48 * donri thinks everything is worthy of version control!
08:19:08 <hseg> i.e. comments, imports, function definitions, where one of the function definitions is main
08:19:15 <donri> hseg: ok i forgot what ghc does with that. maybe try adding: module Main where
08:19:29 <hseg> Already tried. didn't help
08:19:57 <hseg> Odd. Now it does change haddock output
08:20:09 <hseg> Warning: Main: could not find link destinations for:     GHC.IO.FilePath GHC.Types.IO GHC.Base.String
08:20:12 <donri> nolrai24: without looking at your code i'll say that you can tell it exactly a ~ a1 as a constraint with -XTypeFamilies
08:20:19 <donri> nolrai24: no idea if it'll help you though
08:20:22 <parcs> nolrai24: perhaps add a 'forall a.' to line 47
08:20:37 <edwardk> hseg: that warning is fairly typical
08:20:46 <parcs> nolrai24: wait a second, brain fart
08:21:00 <hseg> OK. Do I ignore it?
08:21:35 <donri> hseg: you could safely ignore that, but the fix might involve passing --use-index the path to your system docs in /usr
08:22:09 <edwardk> hseg: i tend to ignore it
08:22:13 <hseg> On windoze. Where are those docs?
08:22:22 <donri> no idea
08:26:35 <cariveri> Hi. Is there a name for the typevariables in a data definition?
08:26:44 <hseg> OK. Got Haddock to generate documentation. Now I'm looking for a way to make it spit the documentation in a separate dir
08:28:43 <Taneb> Okay, that's one way that could go wrong
08:34:09 <linduxed> is there some existing prelude function that does "head . dropWhile predicate"?
08:34:40 <linduxed> or well, something in Data.List maybe
08:35:05 <parcs> :t find
08:35:07 <lambdabot> (a -> Bool) -> [a] -> Maybe a
08:35:24 <parcs> :t find . not
08:35:25 <lambdabot>     Couldn't match expected type `a0 -> Bool' with actual type `Bool'
08:35:25 <lambdabot>     Expected type: Bool -> a0 -> Bool
08:35:25 <lambdabot>       Actual type: Bool -> Bool
08:35:39 <sclv> :t head . dropWhile
08:35:41 <lambdabot>     Couldn't match expected type `[b0]' with actual type `[a0] -> [a0]'
08:35:42 <lambdabot>     Expected type: (a0 -> Bool) -> [b0]
08:35:42 <lambdabot>       Actual type: (a0 -> Bool) -> [a0] -> [a0]
08:35:56 <sclv> :t \x -> head . dropWhile x
08:35:57 <lambdabot> (b -> Bool) -> [b] -> b
08:36:01 <parcs> :t find . fmap not
08:36:02 <Sgeo> Don
08:36:02 <linduxed> find is ok
08:36:02 <lambdabot> (a -> Bool) -> [a] -> Maybe a
08:36:05 <Sgeo> 'Don't use head
08:36:05 <linduxed> thx
08:36:12 <sclv> ?hoogle (b -> Bool) -> [b] -> b
08:36:13 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
08:36:13 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
08:36:13 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
08:36:29 <donri> :t head .: dropWhile
08:36:30 <lambdabot> (b -> Bool) -> [b] -> b
08:36:33 <sclv> ^^ wanted to demonstrate the power of hoogle :-)
08:36:40 <donri> :t fromJust . find
08:36:41 <lambdabot>     Couldn't match expected type `Maybe b0'
08:36:41 <lambdabot>                 with actual type `[a0] -> Maybe a0'
08:36:41 <lambdabot>     Expected type: (a0 -> Bool) -> Maybe b0
08:36:56 <donri> :t fromJust .: find
08:36:57 <lambdabot> (b -> Bool) -> [b] -> b
08:40:08 <crl> blaze is not pefect, but at least looks simple and no templateHaskell
08:46:30 <crl> > "foo"++'b':"ar"
08:46:32 <lambdabot>   "foobar"
08:47:13 <linduxed> what's the function that "unmaybies"?
08:47:21 <linduxed> say that i've got a Maybe Integer
08:47:29 <linduxed> how to i remove the Maybe
08:47:54 <crl> great, now with blaze , download speed rate is at 15 MB/s*
08:47:59 <piezoid> @src (.:)
08:47:59 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:48:16 <crl> (it uses bytestring)
08:48:37 <mroman_> Can ghci tell me where it was when I press ctrl+c?
08:49:19 <piezoid> :t (.:)
08:49:20 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
08:49:44 <crl> > fromMaybe "foo" Just 2
08:49:46 <lambdabot>   Couldn't match expected type `t0 -> t1'
08:49:46 <lambdabot>              with actual type `[GHC...
08:49:55 <crl> > fromMaybe "foo" Just "2"
08:49:57 <lambdabot>   Couldn't match expected type `t0 -> t1'
08:49:57 <lambdabot>              with actual type `[GHC...
08:50:06 <kennyd> > fromMaybe "foo" $ Just "2"
08:50:07 <crl> > fromMaybe "foo" $ Just 2
08:50:09 <lambdabot>   "2"
08:50:09 <lambdabot>   can't find file: L.hs
08:50:19 <crl> > fromMaybe "foo" $ Just 2
08:50:21 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
08:50:21 <lambdabot>    arising from the literal ...
08:50:21 <mroman_> Hm. -fbreak-on-error
08:50:24 <mroman_> Stopped at <exception thrown>
08:50:25 <mroman_> _exception :: e = _
08:50:33 <mauke> preflex: seen adas
08:50:34 <preflex>  adas was last seen on #haskell 7 hours, 17 minutes and 38 seconds ago, saying: danr: yes it is. I hope it works. never writtne binding before - )
08:50:37 <hseg> cabal update always notes that cabal-install is out-of-date. Why is this?
08:50:44 <mauke> because it is
08:51:54 <tac> No one can keep up with how innovating Cabal is
08:51:55 <sproingie> you have the old cabal coming first in your path
08:55:16 <hseg> OK. How do I fix that?
08:55:47 <sproingie> fix your PATH
08:56:41 <mauke> put ~/.cabal/bin in your PATH
08:57:08 <fizbin> crl: You can get readable type errors by telling lamdabot the type of "2"
08:57:28 <fizbin> > fromMaybe "foo" $ Just (2::Integer)
08:57:29 <sproingie> windows i think it's /users/foo/appdata/roaming/cabal/bin
08:57:29 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
08:57:30 <lambdabot>              with actual ty...
08:57:51 <fizbin> Well, okay, you could if lambdabot gave longer error messages.
08:58:16 <crl> > fromMaybe "foo" $ Just (2 :: Int)
08:58:18 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
08:58:18 <lambdabot>              with actual ty...
09:01:02 <crl> :t (=~)
09:01:04 <lambdabot>     Not in scope: `=~'
09:01:04 <lambdabot>     Perhaps you meant one of these:
09:01:04 <lambdabot>       `==' (imported from Data.Eq), `#~' (imported from Control.Lens),
09:03:24 <crl> @hoogle regex
09:03:24 <lambdabot> Text.Regex.Posix.Wrap data Regex
09:03:24 <lambdabot> Text.Regex.Posix.String data Regex
09:03:24 <lambdabot> Text.Regex.Posix.Sequence data Regex
09:03:40 * hackagebot flexible-defaults 0.0.1.1 - Generate default function implementations for complex type classes.  http://hackage.haskell.org/package/flexible-defaults-0.0.1.1 (JamesCook)
09:03:58 <geekosaur> :t (Text.Regex.Posix.=~)
09:04:00 <lambdabot> (Text.Regex.Base.RegexLike.RegexMaker Text.Regex.Posix.Wrap.Regex Text.Regex.Posix.Wrap.CompOption Text.Regex.Posix.Wrap.ExecOption source, Text.Regex.Base.RegexLike.RegexContext Text.Regex.Posix.
09:04:00 <lambdabot> Wrap.Regex source1 target) => source1 -> source -> target
09:04:08 <geekosaur> some things should not be asked :)
09:04:44 <crl> should I use  regex-posix
09:04:44 <mroman_> Ah seriously :(
09:05:05 <mroman_> let (Foobar a b) = doStuff 5 b
09:05:10 <crl> just need a simple regex lib
09:05:21 <mroman_> Neat how that loops forever.
09:06:30 <crl> regexchar it is
09:07:25 <crl> hmm no that's an extension of regex-posix
09:10:27 <k00mi> what do you want to do crl? most haskellers prefer writing a parser with something like Parsec over using regexps
09:11:09 <crl> Parsec? well I have it already installed at least
09:11:49 <crl> I'd like to match file names ending with .hs, or .txt;;;
09:12:12 <crl> it's easier to write it with regex than with isSuffixOf
09:12:41 <k00mi> what makes you think that?
09:13:03 <mauke> :t any (`isSuffixOf` ?file) (words ".hs .txt")
09:13:04 <lambdabot> (?file::[Char]) => Bool
09:13:15 <crl> is I have 10 possibilities, it's verbose I mean
09:13:42 <crl> mauke: oww was looking at this
09:13:45 <crl> great
09:24:10 <crl> > (`isSuffixOf` "foo") `any` ["oo","ii"]
09:24:15 <lambdabot>   True
09:24:19 <crl> how could I flip the order of args?
09:24:43 <mauke> :t flip
09:24:45 <lambdabot> (a -> b -> c) -> b -> a -> c
09:25:34 <crl> > (flip any) ["oo","ii"] (`isSuffixOf` "foo")
09:25:36 <lambdabot>   True
09:26:06 <crl> > ["oo","ii"] `(flip any)` (`isSuffixOf` "foo")
09:26:08 <lambdabot>   <hint>:1:14: parse error on input `('
09:27:01 <crl> not sure it's doable
09:28:00 <shanse> let fany = flip any
09:28:08 <crl> k
09:28:53 <mroman_> interesting.
09:31:35 <mauke> <Altreus> thrig: C programmers are always too busy making sure they're using memory properlyÔøΩÔøΩIÔøΩMwWN"ÔøΩÔøΩÔøΩ~
09:38:41 * hackagebot happstack-server 7.1.7 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.1.7 (JeremyShaw)
09:49:22 <haskellnoob> hi, when i use "import Monad" i get a compile error why is that?
09:49:35 <haskellnoob>     Could not find module `Monad'
09:49:42 <Taneb> import Control.Monad
09:49:58 <Taneb> It moved a few years ago
09:50:04 <haskellnoob> Taneb thanks man human
09:50:28 <haskellnoob> is Write Yourself a Scheme in 48 Hours out of date?
09:50:43 <crl> with sublime+hlint it suggested me that automatically ^^
09:51:13 <Taneb> haskellnoob, a little. It should be still fine to use it if you know that there are a handful of little bits that won't work
09:51:19 <crl> (the import Control.)
09:51:40 <haskellnoob> okey, well is it good tutorial for a beginner, i know that other one but it's like a boring manual
09:53:14 <mm_freak_> haskellnoob: most people seem to like LYAH
09:53:17 <mm_freak_> @where lyah
09:53:17 <lambdabot> http://www.learnyouahaskell.com/
09:53:20 <crl> infix doesn't like $s
09:53:34 <haskellnoob> mm_freak_: i know but it's boring :P
09:53:41 * hackagebot web-routes 0.27.3 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-0.27.3 (JeremyShaw)
09:53:44 <haskellnoob> i like more k&r style guides :P
09:53:45 <haskellnoob> i like more k&r style guides :P
09:53:46 <haskellnoob> i like more k&r style guides :P
09:53:56 <crl> > 2 + (+) 1 2
09:53:58 <lambdabot>   5
09:55:53 <crl> > 2 + (+) 1 $ 1+1
09:55:55 <lambdabot>   No instance for (GHC.Num.Num (a0 -> a0))
09:55:56 <lambdabot>    arising from a use of `e_12111'...
09:56:14 <crl> > 2 + (+) 1 (1+1)
09:56:16 <lambdabot>   5
09:57:24 <mauke> > 2 + ((+) 1 $ 1+1)
09:57:26 <lambdabot>   5
10:01:15 <edwardk> @tell ezyang i was playing around with fractional cascading today, and lo and behold your post popped up near the top of the list.
10:01:16 <lambdabot> Consider it noted.
10:01:17 <edwardk> ezyang++
10:06:29 <amiller> i can't figure out whether i should be trying to use generic programming or writing an interpreter/dsl
10:06:30 <amiller> i've come a long way by figuring out how to do the hfunctor and least-fixpoint approach to generically augment data structures written this way
10:06:33 <amiller> but how do i represent functions/computations using these data structures?
10:08:41 * hackagebot yarr 1.3.1 - Yet another array library  http://hackage.haskell.org/package/yarr-1.3.1 (RomanLeventov)
10:08:43 * hackagebot yarr-image-io 1.3.0 - Image IO for Yarr library  http://hackage.haskell.org/package/yarr-image-io-1.3.0 (RomanLeventov)
10:09:20 <amiller> the way i've been representing computations so far is with this strange monadified instance like Monad m => forall d. (forall a. ExprF d a -> m (d a)) -> (forall a. d a -> ExprF d a) -> d a -> m b  or something
10:10:02 <amiller> so either i need to a) generically derive such signatures for ordinary functions or some suitable metaformat for functions, or b) represent computations as source terms in some embedded language and then monadification like that is just part of the semantics
10:21:57 <levi> amiller: Have you read Oleg's work on tag-free final encodings of EDSL terms?
10:22:42 <levi> http://okmij.org/ftp/tagless-final/index.html
10:24:13 <Clint> how do i convert a list of delimited strings into a Tree?
10:24:55 <sproingie> what kind of tree?
10:25:30 <Clint> Data.Tree, i suppose
10:25:38 <levi> Without any more details, the most specific answer I can think of is "with a parser"
10:25:46 * Clint grumbles.
10:26:01 <mauke> const T.empty
10:26:01 <sproingie> still need more than that.  binary tree?  heap?  prefix tree?
10:28:01 <Clint> i want to take ["A:X:Y:Z", "A:P:Q:R", "B:K:L:M", "B:K:L:F"] and make a tree where i suppose the root node is "" and its two children are "A" and "B"
10:28:44 <sproingie> so each of those is a unique path of nodes?
10:28:55 <sproingie> sounds like a prefix tree then
10:29:10 <Sgeo> Do people use HaskellDB?
10:29:11 <Clint> yes
10:30:01 <sproingie> there's a fair number of trie implementations on hackage
10:30:14 <Clint> Sgeo: i did and then i switched to persistent
10:30:29 <sproingie> no idea which ones are good.  most people using tries in anger want them to be compact, so i'd imagine bytestring-trie is the most serious
10:31:06 <sproingie> if your node labels are always single letters then you can get away with that, otherwise you'll need something more generic
10:31:20 <sproingie> (single ascii letters i'd add)
10:31:30 <Clint> sproingie: no, they're strings
10:32:20 <sproingie> not sure then.  searching hackage for "trie" is about the best i can do ATM
10:33:02 <sproingie> tho if it's an assignment, you probably can't use that :)
10:33:03 <Clint> they all seem largely integer-focused
10:33:09 <Clint> no, it's not an assignment
10:33:25 <sproingie> the usual use case for tries is dictionaries and router ACLs, so yeah
10:34:40 <Clint> i guess i'll muck around with unfoldTree a bit
10:36:53 <skp> hey
10:37:07 <skp> I‚Äôm writting several libs in parallel
10:37:29 <skp> how can I cross-test them without release them on hackage db?
10:37:34 <skp> I use git
10:37:45 <skp> maybe git submodule can help me?
10:39:08 <shanse> have a look at cabal-dev maybe?
10:40:20 <amiller> thanks levi this looks pretty interesting but i haven't figured out ... how to read it yet
10:40:45 <amiller> maybe i can understand it as dual to the approach of generics for datatypes?
10:42:58 <levi> amiller: Well, it's using the dual to the initial algebra approach, which is the final coalgebra.
10:44:00 <levi> Initial algebras define the syntactic structure of a language, while final coalgebras define a stepwise operational semantics.
10:44:28 <fryguybob> skp: You can list several direcories at once as arguments to cabal and it will use those for dependencies.
10:44:56 <fryguybob> skp: I sometimes have some set of projects in one directory then do: cabal install a/ b/ c/
10:45:36 <levi> My understanding of this stuff is still fuzzy, and Oleg is never terribly easy to read, so I'm afraid I can't be of too much help.
10:46:44 <skp> I see
10:46:47 <skp> thanks
10:46:57 <skp> ok and hm
10:47:04 <skp> I have a type
10:47:10 <skp> over an EitherT monad
10:47:12 <levi> But this book helped me to understand a lot of the basic theory behind coalgebras, at least at a fairly informal level: http://www.cs.ru.nl/B.Jacobs/CLG/JacobsCoalgebraIntro.pdf
10:47:15 <skp> something like
10:47:25 <skp> type GL a = EitherT Foo IO a
10:47:48 <amiller> i've gotten the hang of the generic initial algebra approach by realizing that by pulling the single fixpoint knot-tying out on its own, i can once-and-for-all augment any of the recursive points with extra data
10:47:52 <skp> I‚Äôd like to be able to create a GL with a IO (Either‚Ä¶) with the GL ctor
10:47:53 <Fuco> is there some simple way to print "folds" in haskell? What I mean is: foldr (+) 0 [1,2,3] ~~> (+) 1 ((+) 2 ((+) 3 0))) ... something like that
10:47:57 <skp> how can I do that?
10:48:07 <amiller> i don't have as much of an intuitive understanding for what the equivalent notion in operational semantics woudl be
10:48:18 <amiller> doing something different at each operational step, maybe
10:48:38 <skp> hm maybe I can do an alias on the return value
10:48:43 <amiller> levi, thanks that's a cool link too i do have that one printed out on my desk and it helped me quite a bit too :) i'll revisit it with this question in mind
10:48:48 <Fuco> or in general catamorphisms, not necesarily folds from lists
10:49:23 <fryguybob> > foldl (+) 0 [a,b,c,d]
10:49:24 <simpson> skp: Well, your type is equivalent to: IO (Either Foo a)
10:49:25 <lambdabot>   0 + a + b + c + d
10:49:26 <fryguybob> > foldr (+) 0 [a,b,c,d]
10:49:28 <lambdabot>   a + (b + (c + (d + 0)))
10:50:11 <Fuco> fryguybob: what if I have catamorphisms in general, on "Fix f" types?
10:50:15 <simpson> skp: So you want something like: IO a -> GL a ?
10:50:23 <skp> yes
10:50:25 <skp> kinda
10:50:40 <levi> Well, the basic idea is that the final coalgebra makes state transitions and behaviors apparent, while hiding some of the structure of the actual state space.  So Oleg is hiding the typing of the computations behind expressions in the host language instead of stating them explicitly as part of an initial algebra-based data representation of the computations.
10:50:58 <Fuco> I guess what I want is to print the "thing" without haskell evaluating it first :P
10:51:19 <simpson> skp: Doesn't lift work for you?
10:51:34 <simpson> skp: You're using the EitherT from the "either" package, right?
10:51:37 <fryguybob> Fuco: I'm not sure what you want but the example I gave was making the computation itself just be the building of the expression.
10:51:53 <fryguybob> @hackage simple-reflect
10:51:53 <lambdabot> http://hackage.haskell.org/package/simple-reflect
10:52:18 <amiller> levi is there a simple explanation for what finality gets you, in the sense that i have a good understanding for 'initiality' as saying that fold h exists and is unique for any algebra h : F D -> D
10:53:42 <Fuco> amiller: final coalgebras give you anamorphisms (unfolds) that are unique
10:54:03 <Fuco> from every F-coalg there is unique morphisms to final F-coalgebra
10:54:18 <skp> simpson: yup
10:54:22 <skp> hm lift
10:54:23 <Fuco> morphism*, and that is the corresponding unfold
10:54:43 <simpson> skp: Yeah. EitherT is a MonadTrans, so it can lift things from its inner monad to itself.
10:55:25 <Fuco> fryguybob: well if I input "foldr (+) 0 [1,2,3]" in hgci it gives me "6" not the printout... to get the string with : replaced by the operation I'd need a fold that'd build a string from the list, right?
10:55:36 <Fuco> so what I want I guess is that :P Automaticly build the string
10:56:08 <fryguybob> > foldr (+) 0 [1,2,3] :: Expr
10:56:09 <lambdabot>   1 + (2 + (3 + 0))
10:57:10 <Fuco> I see :P I've just noticed you gave me a link... sorry :d
10:57:41 <skp> simpson: lift is nice but I‚Äôd rather like something more expressive
10:57:44 <skp> thanks
10:57:48 <skp> gonna alias lift :)
10:57:50 <simpson> skp: Uh? What do you mean?
10:58:29 <simpson> Like: liftGL :: IO a -> GL a; liftGL = lift -- ?
10:58:39 <simpson> I mean, it works, but that's just confusing to read.
10:59:27 <skp> hm
10:59:34 <skp> you think so
11:00:16 <simpson> Well, when using transformer stacks, one gets used to seeing lots of lifting.
11:02:58 <Fuco> so I've downloaded that package with 'cabal install simple-reflect', then restarted ghci, now I do ':m + Debug.SimpleReflect' and it tells me package is not found. So how do I load packages in ghci?
11:05:44 <fryguybob> Fuco: cabal install didn't give any errors?
11:05:51 <Fuco> nope
11:07:24 <Fuco> does cabal build binaries? I'm running it on two different machines, maybe that's incompatible
11:07:24 <bxc> hmm smallcheck/typeclass question
11:09:01 <fryguybob> Fuco: cabal install will install to your local cabal package based on the configuration in ~/.cabal/config
11:09:03 <levi> amiller: These slides might be helpful, too: http://cs.ioc.ee/ewscs/2011/jacobs/jacobs-slides.pdf
11:09:25 <fryguybob> Fuco: So if you are using two different users that would likely be a problem.
11:09:39 <Fuco> well the /home/me is shared (network drive)
11:09:52 <Fuco> but the architecture is different, i.e. binaries are incompatible
11:10:54 <bxc> http://hpaste.org/83464
11:10:58 <bxc> is my question
11:11:14 <bxc> about the newish monad parameter in Serial in smallcheck
11:11:16 <orospakr> what's the most favoured way to write bindings to C these days? still c2hs?
11:11:19 <fryguybob> Fuco: If you do  ghci -v3  it will list where it is getting packages from.
11:11:31 <bxc> and how i don't understand instance dependencies enough
11:13:12 <Fuco> fryguybob: oh I see, it has some cache file that hasn't been updated... anyhow, I guess I can specify a "load path" when I start ghci... I'll check the docs :P
11:15:10 <supki> bxc: did you try to enable -XFlexibleInstances?
11:15:22 <bxc> no
11:15:26 <bxc> is that a good thing to do?
11:15:41 <supki> that's perfectly fine extension
11:15:45 <bxc> ok
11:19:49 <bxc> ok FlexibleInstances make it compile
11:19:54 <bxc> lets ssee if the test spass
11:19:56 <bxc> probably?
11:23:36 <kennyd> bxc you can enable it per source file, {-# Language FlexibleInstances #-} at the top
11:24:26 <bxc> kennyd: yeah thats what i'm doing int his project
11:24:46 <bxc> luckily most of the code i have doesn't need much in the way of language extensions, but the test code does
11:26:12 <bxc> and its the test stuff i've been getting the most portability problems in
11:28:31 <levi> amiller: This could be useful as well: http://dl.dropbox.com/u/828035/Computing/fold.html
11:35:35 <uniquenick> is there a way to write this without the lambda?  (\x -> fmap bsToInt64 $ bsToMaybe x)  bsToMaybe is BS -> Maybe BS and bsToInt64 is BS -> Int64
11:37:34 <carter> uniquenick use the compose operator instead?
11:37:35 <lambdabot> carter: You have 1 new message. '/msg lambdabot @messages' to read it.
11:38:51 <piezoid> @pl  \x -> fmap bsToInt64 $ bsToMaybe x
11:38:52 <lambdabot> fmap bsToInt64 . bsToMaybe
11:39:44 <carter> @help pl
11:39:45 <lambdabot> pointless <expr>. Play with pointfree code.
11:39:54 <carter> cool
11:39:59 <carter> didn't know lambdabot could do that
11:41:03 <earthy> @pl \ a b c d e f g h i j k l m n o p q r s t u v w x y z -> l e t m e s e e i f i t w i l l m a n a g e t h i s
11:41:07 <lambdabot> const . const . const . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) .
11:41:07 <lambdabot>  ((((((((const .) .) .) .) .) .) .) .) . ((((((((((const .) .) .) .) .) .) .) .) .) .) . ((((((((((const .) .) .) .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .) .) . ((((((((((
11:41:07 <lambdabot> (const .) .) .) .) .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .)
11:41:07 <lambdabot>  . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((ap .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) .
11:41:07 <lambdabot> flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .)
11:41:09 <lambdabot> [14 @more lines]
11:41:11 <croikle> haha
11:41:11 <lambdabot> optimization suspended, use @pl-resume to continue.
11:41:13 <earthy> whee!
11:41:32 <earthy> okay, that one was mean
11:41:52 <earthy> (but it shows the point of the name pointless rather than pointfree)
11:42:54 <carter> and also why pointfree isn't alwasy good :)
11:43:34 <Taneb> Go for pretty rather than pointfree
11:45:47 <carter> does anyone have any experience using the Syntactic Lib on hackage? http://hackage.haskell.org/package/syntactic i'm working through the paper right now to understand if itd be helpful for me
11:57:32 <pmade> How do you write a function like `read'?  Something like `show' is easy because you can pattern match but I'm not sure how I "know" which data constructor I'm suppose to use in my function that is overloaded on the return type.
11:57:39 <tentimes> #join rvm
11:58:35 <Botje> tentimes: try /join #rvm
11:58:44 * hackagebot hp2any-core 0.11.2 - Heap profiling helper library  http://hackage.haskell.org/package/hp2any-core-0.11.2 (GergelyPatai)
11:58:49 <Botje> pmade: the compiler chooses the right Read instance for you already
11:58:52 <geekosaur> pmade, it's just as easy for read, the caller specifies the type they expect and the compiler calls the type-specific read instance
11:59:11 <koala_man> pmade: the type instance will be selected based on the inferred return type
12:00:06 <`ramses> if a function has a type (f :: a -> (forall b. b)), why can't it return just any value? Doesn't any value satisfy (forall b. b) ?
12:00:39 <pmade> I should have been clearer.  I have a ADT with several data constructors and a function *like* read (but isn't read).  I'm not sure how to write this function.  Say my ADT is `data X = A | B | C'.  How do I write an overloaded function that can return all three?
12:00:44 <mauke> `ramses: no, most values don't
12:01:05 <mauke> (forall b. b) is a value that has all types AT THE SAME TIME
12:01:12 <mauke> i.e. undefined
12:01:13 <pmade> Basically, I'm writing a function that does the same thing as read except it uses parsec.
12:01:31 <`ramses> mauke: ah, let ne think about that :)
12:01:31 <mauke> pmade: how is that overloaded?
12:01:39 <`ramses> me*
12:02:01 <pmade> mauke: via a class that I'm trying to write ;)
12:02:07 <mauke> `ramses: the central question is always: who gets to choose the b?
12:02:21 <geekosaur> pmade, that's still all type X
12:02:21 <mauke> `ramses: the function or the caller?
12:02:23 <croikle> pmade: they all have the same type. f "a" = A; f "b" = B; f "c" = C
12:02:28 <`ramses> mauke: well, I thought in this case it would have been the callee
12:02:44 <mauke> no, that would require an existential type
12:03:10 <mauke> because as far as the caller is concerned, there exists some type for the result, but we don't know what it is
12:03:17 <pmade> Right, which leads me to believe that I can't do what I want :(.  My type is more like `data X = A Int | B String | C Double'
12:03:29 <mauke> pmade: again, I don't see how this is a problem
12:03:44 <mauke> this is a straightforward function; no overloading required
12:03:45 * hackagebot hp2any-graph 0.5.4 - Real-time heap graphing utility and profile stream server with a reusable graphing module.  http://hackage.haskell.org/package/hp2any-graph-0.5.4 (GergelyPatai)
12:03:45 <geekosaur> it's still all type X
12:03:47 * hackagebot hp2any-manager 0.4.6 - A utility to visualise and compare heap profiles.  http://hackage.haskell.org/package/hp2any-manager-0.4.6 (GergelyPatai)
12:03:49 * hackagebot Decimal 0.3.1 - Decimal numbers with variable precision  http://hackage.haskell.org/package/Decimal-0.3.1 (PaulJohnson)
12:04:14 <donri> read ("A " : xs) = A (read xs) -- simplified
12:04:37 <Sgeo> Is StandaloneDeriving in the undocumented list of "good" extensions?
12:04:38 <`ramses> mauke: but "as far as the caller is concerned, there exists some type for the result" does sound like it's an existential type that the callee chooses, doesn't it?
12:05:07 <mauke> `ramses: yes, I was describing what you wanted, not what you wrote
12:05:09 <mauke> I think
12:05:09 <`ramses> mauke: also, ((forall a. a) -> b) would accept any input type then, as there a truly is existential
12:05:09 <geekosaur> if your question is how to do it without requiring a constructor, you need to solve the problem of whether something like "5" is an Int or a Double
12:05:28 <pmade> mauke: I must be thinking about this incorrectly.
12:05:44 <skp> hey
12:05:48 <geekosaur> you are. maybe describe the actual problem?
12:05:52 <skp> is it possible to make a class in instance of another class?
12:05:54 <croikle> try writing up some test cases
12:06:05 <`ramses> mauke: is there a way to write a function with an existential return type then? that would require an actual existential quantifier then?
12:06:09 <skp> in order to mention that any instances of a class is an instance of another?
12:06:22 <skp> s/instances/instance
12:06:40 <mauke> `ramses: you have to hide it in a custom type or CPS transform the function
12:06:51 <lispy> skp: this works: class A a => B a where ..., this means that given B a we know that A a must be satisfied as well.
12:07:05 <lispy> skp: think of the type class as a predicate over tyes
12:07:07 <lispy> types*
12:07:14 <skp> so here
12:07:15 <[swift]> anyone used msgpack-rpc?
12:07:20 <geekosaur> however, if you are trying to use typeclasses for OOP, you are paddling wrong way up a river
12:07:21 <skp> I have a class called ShaderStage
12:07:27 <mauke> `ramses: foo :: a -> (exists b. b)   ==>   foo' :: a -> (forall b. b -> r) -> r
12:07:42 <skp> I want any instance of the ShaderStage to be an instance of the GLObject class
12:07:43 <skp> so just
12:07:45 <pmade> geekosaur: I need to think about this more.  Thank you for the help.
12:07:59 <skp> just what:D
12:08:16 <skp> class (GLObject s) => ShaderStage s where‚Ä¶
12:08:17 <skp> ?
12:08:19 <`ramses> mauke: then it's again the caller choosing b, isn't it?
12:08:22 <lispy> skp: as close as you can get with type classes would be: class GLObject o => ShaderStage o where
12:08:23 <donri> class (GLObject a) => ShaderStage a
12:08:24 <donri> yea
12:08:28 <skp> it‚Äôs not really what I want
12:08:34 <skp> I want to write the instance
12:08:39 <[swift]> msgpack-rpc generates a parse error whenever a client closes a connection. i think it's a bug in the library - doesn't seem to handle EOF correctly. if anyone has fixed this problem before i'd be interested to hear about it. there IS a slightly newer version of msgpack but it requires updated libraries that cabal warns will break haskell-paltform =(
12:08:40 <mauke> `ramses: yes
12:08:52 <mauke> `ramses: wait, no. the callee
12:08:53 <skp> because it will be redundant in any instance of the ShaderStage class
12:09:09 <`ramses> mauke: how so? how can the callee construct that r?
12:09:19 <mauke> by calling the function
12:09:47 <`ramses> mauke: but as that function is passed by the caller, doesn't he decide what type that function returns?
12:09:53 <mauke> yes
12:10:02 <mauke> that's fine
12:10:07 <donri> skp: well i think you can do instance (GLObject a) => ShaderStage a ... but you might run into problems with duplicate instances without OverlappingInstances and you really don't want the latter
12:10:08 <notdan> If Haskell has type families and typeclesses, what are the advantages of ML modules over Haskell's type  system? Because the main argument I've heard is that you can incorporate tyep variable in modules
12:10:09 <fragamus> ok
12:10:17 <`ramses> mauke: but you said the callee decided the type?
12:10:23 <fragamus> im tired of not understanding comonoads
12:10:32 <skp> hm
12:10:36 <skp> so what should I do then?
12:10:38 <mauke> `ramses: the type of its own result, which is b
12:10:54 <fragamus> anyone up for comonad chat
12:11:30 <donri> skp: might be fine if you make sure this instance isn't orphaned and you never want to write special instances of that sort
12:11:39 <`ramses> mauke: wait, you said (f :: a -> (forall b. b -> r) -> r), and we just agreed that the caller decides on r, then the caller decides the return type of f, right?
12:11:57 <napping> notdan: it's still easier to define type members in modules. Also, multiple instances of a parameterized module at the same types
12:12:03 <skp> I see
12:12:34 <skp> I don‚Äôt really get what the a is in your example
12:13:01 <mauke> `ramses: we were talking about a pair of functions, foo and foo', actually
12:13:22 <donri> skp: same as your s
12:13:43 <fragamus> is edwardk in the house
12:13:54 <donri> skp: oh my instance example? it's any type implementing GLObject
12:13:56 <edwardk> pair programming at the moment. otherwise i would be
12:14:04 <fragamus> k
12:14:04 <skp> huh
12:14:07 <`ramses> mauke: what do you mean?
12:14:10 <sproingie> a comad is like a coburrito
12:14:14 <fragamus> lol
12:14:15 <skp> instance (GLObject a) => ShaderStage a where
12:14:21 <donri> corrito
12:14:24 <skp> for me it‚Äôs in instance of ShaderStage here
12:14:27 <skp> an*
12:14:44 <mauke> `ramses: do you know what CPS is?
12:14:55 <donri> skp: you might want the inverse, i'm not quite sure what you want
12:15:09 <donri> skp: instance (ShaderStage a) => GLObject a
12:15:25 <fragamus> well anyhow, I really get monads and I can stack monad transformers till the cows come home
12:15:41 <`ramses> mauke: vaguely..
12:15:58 <donri> comonads are easy, but i'm still not quite sure when they're applicable
12:16:07 <`ramses> mauke: you pass around callbacks?
12:16:10 <skp>     Illegal instance declaration for `GLObject s'
12:16:23 <donri> skp: does it suggest something like FlexibleInstances?
12:16:33 <mauke> `ramses: yes, and return values become arguments to the callbacks
12:16:38 <skp> yes donri
12:16:40 <fragamus> but anytime I have asked about comonads I get pointed vaguely to a celllular automaton example and then ‚Ä¶.
12:16:55 <skp> do I have to enable the GHC extension then?
12:17:02 <edwardk> fragamus: i'm happy to drill in in more detail when i don't have someone sitting over my shoulder =)
12:17:02 <donri> skp: then add that to the start of the file, {-# LANGUAGE FlexibleInstances #-}
12:17:43 <fragamus> edwardk: thanks edwardk
12:17:47 <donri> edwardk: why are you even on irc! :D
12:17:53 <notdan> napping: I see, thanks
12:18:03 <`ramses> mauke: I'm not sure what that means.. which return argument? Of the function you're rewriting in "CPS style"?
12:18:07 <edwardk> because sometimes 2% of my attention can alleviate a lot of misunderstanding
12:18:13 <donri> edwardk: (hi person sitting over edwardk shoulder)
12:18:33 <fragamus> edwardk: i used to have an invisible friend too
12:19:14 <edwardk> CPS style is like ATM machine
12:19:19 <fragamus> but he doesn't understand comonads so i kicked him out of my lifr
12:19:22 <fragamus> life even
12:19:28 <skp>     Constraint is no smaller than the instance head
12:19:37 <donri> CPS means child protective services right
12:19:39 <skp> hihi
12:20:12 <donri> skp: does it suggest another extension now? i thought you could do this without overlapping instances but not sure
12:21:25 <int-e> Sgeo: Standalone deriving seems harmless, as long as you don't use it to define orphan instances.
12:22:14 <Sgeo> deriving instance (Ord a) => Complex a
12:22:21 <skp> nope
12:22:30 <skp> no more sugg
12:22:58 <Sgeo> Hmm, that doesn't work
12:23:05 <Sgeo> Oh, derp
12:23:10 <donri> skp: try adding a LANGUAGE OverlappingInstances pragma to see if it works at all, but yea you don't want to use that :D
12:23:36 <dmj> Does anyone know a better way to parse statements recursively in Parsec? I have an ifelse parser than can contain embedded ifelse statements in a java-like language, but it is not recognizing the inner ifelse.
12:23:42 <hpaste> dmj pasted ‚ÄúNot parsing nested if else's‚Äù at http://hpaste.org/83465
12:23:43 <Sgeo> deriving instance (Ord a) => Ord (Complex a)
12:23:52 <skp> no I don‚Äôt
12:23:54 <skp> hm
12:24:04 <crl> @hoogle Complex
12:24:05 <lambdabot> Data.Complex data RealFloat a => Complex a
12:24:05 <lambdabot> Data.Complex module Data.Complex
12:24:05 <lambdabot> package complex-integrate
12:24:46 <crl> > i ^2 -- :)
12:24:48 <lambdabot>   i * i
12:25:04 <crl> > i ^2 == -1 -- :)
12:25:06 <lambdabot>   False
12:25:34 <arkeet> :t i
12:25:36 <lambdabot> Expr
12:25:40 <crl> :t j
12:25:42 <lambdabot> Expr
12:25:44 <skp> donri: Use -XUndecidableInstances to permit this
12:25:47 <Sgeo> :t (0 :+ 1)
12:25:49 <lambdabot> Num a => Complex a
12:25:51 <skp> that‚Äôs weird
12:25:56 <donri> skp: ah, try that then :D
12:26:00 <arkeet> @let ii = 0:+1
12:26:02 <lambdabot>  Defined.
12:26:07 <clahey> > (0 +: 1)^2 == -1
12:26:09 <lambdabot>   Not in scope: `+:'
12:26:09 <lambdabot>  Perhaps you meant one of these:
12:26:09 <lambdabot>    `++' (line 125), `P....
12:26:09 <Sgeo> > ii\
12:26:10 <lambdabot>   <hint>:1:3: parse error on input `\'
12:26:11 <Sgeo> > ii
12:26:13 <lambdabot>   0 :+ 1
12:26:13 <crl> hehe
12:26:14 <clahey> > (0 :+ 1)^2 == -1
12:26:16 <lambdabot>   True
12:26:18 <donri> skp: that extension is harmless compared to overlapping :)
12:26:42 <arkeet> Sgeo: please don't Ord (Complex a).
12:26:48 <skp> I think I‚Äôma just copy paste the instance implementation
12:26:53 <skp> there‚Äôre three instances
12:26:58 <skp> it‚Äôs annoying but hm‚Ä¶
12:27:26 <donri> skp: that's probably better yea. but i think it'll work with undecidable
12:27:34 <Sgeo> arkeet, please don't make Ord both mean "orderable for semantic purposes" and "orderable for efficient implementation of some data structures purposes"
12:27:43 <arkeet> :p
12:27:54 <skp> donri: https://github.com/skypers/ark-gl/blob/unstable/Graphics/Rendering/Ark/GL/Shader/Stage.hs
12:28:02 <skp> here‚Äôs the file, line 14
12:28:36 <t4nk987> @pl (\xs -> map snd . sort . (`zip` xs) <$> replicateM (length xs) (randomIO :: IO Int))
12:28:37 <lambdabot> ap ((<$>) . ((map snd . sort) .) . flip zip) (flip replicateM (randomIO :: IO Int) . length)
12:28:44 <crl> > (-1 :+ 0)^ 2
12:28:47 <lambdabot>   Precedence parsing error
12:28:47 <lambdabot>      cannot mix prefix `-' [infixl 6] and `Data.Co...
12:28:54 <Michae___> Why is my use of fold throwing an error here? https://gist.github.com/mfine15/0b13b42fea9b7c13eb6a I have a list of types, which I'm trying to get the two maximum value of an attribute of theirs, but when I'm trying to return a tuple it says I'm returning that type
12:29:05 <arkeet> > ((-1) :+ 0) ^ 2
12:29:07 <lambdabot>   1.0 :+ (-0.0)
12:29:16 <arkeet> wait
12:29:21 <arkeet> :t ii
12:29:22 <lambdabot> Num a => Complex a
12:29:30 <arkeet> :t ii :: Complex Integer
12:29:31 <lambdabot> Complex Integer
12:29:34 <arkeet> > ii :: Complex Integer
12:29:37 <crl> > ((-1) :+ 0)^2
12:29:37 <lambdabot>   0 :+ 1
12:29:39 <lambdabot>   1.0 :+ (-0.0)
12:29:49 <arkeet> > ((-1) :+ 0)^2 :: Complex Integer
12:29:49 <crl> > ((-1) :+ 0)**(1/2)
12:29:51 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Integer.Type.Integer)
12:29:52 <lambdabot>    arising f...
12:29:52 <lambdabot>   can't find file: L.hs
12:29:58 <arkeet> whaaaaat ?
12:30:04 <clahey> arkeet: Try again.
12:30:23 <`ramses> mauke: I think I see what you meant, for (f :: a -> (forall b. b -> r) -> r) I can implement f and in the implementation use b as the "existential return type" but I just have to immediately pass it to the callback, thus never actually "returning" it, as in it never appears as a return type
12:30:25 <arkeet> RealFloat a => Num (Complex a)? I guess it needs it for abs/signum.
12:30:32 <arkeet> that sucks.
12:30:51 <clahey>  > ((-1) :+ 0)^2 :: Complex Integer
12:30:59 <crl> :t (1 :+ 0)
12:31:01 <lambdabot> Num a => Complex a
12:31:02 <`ramses> mauke: that was what you were getting at?
12:31:02 <t4nk987> > product [1..10000]
12:31:04 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
12:31:08 <clahey> > ((-1) :+ 0)^2 :: Complex Integer
12:31:10 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Integer.Type.Integer)
12:31:10 <lambdabot>    arising f...
12:31:16 <clahey> Interesting.
12:31:27 <clahey> > (((-1) :+ 0):: Complex Integer)^2
12:31:29 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Integer.Type.Integer)
12:31:30 <lambdabot>    arising f...
12:31:43 <arkeet> no, it makes perfect sense.
12:31:56 <clahey> Because you can do ^ .5, for instance?
12:31:57 <arkeet> except the reason sucks.
12:32:00 <arkeet> no
12:32:04 <clahey> ((-1) :+ 0)^(0.5)
12:32:09 <clahey> > ((-1) :+ 0)^(0.5)
12:32:11 <lambdabot>   Ambiguous type variable `b0' in the constraints:
12:32:11 <lambdabot>    (GHC.Real.Fractional b0...
12:32:17 <arkeet> > ii + ii :: Complex Integer
12:32:18 <clahey> arkeet: Explain then?
12:32:19 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Integer.Type.Integer)
12:32:19 <lambdabot>    arising f...
12:32:32 <arkeet> clahey: I just did.
12:32:34 <arkeet> <arkeet> RealFloat a => Num (Complex a)? I guess it needs it for abs/signum.
12:32:43 <crl> > (1 :+ 1)^2
12:32:45 <lambdabot>   0.0 :+ 2.0
12:32:55 <crl> huh?
12:33:02 <arkeet> huh what
12:33:21 <clahey> Ah, yeah, I can see that.
12:33:21 <crl> I thouht it was (1+i) ^ 2
12:33:27 <arkeet> it is.
12:33:32 <arkeet> and it is 2i.
12:33:50 * hackagebot sandi 0.2.1 - Data encoding library  http://hackage.haskell.org/package/sandi-0.2.1 (MagnusTherning)
12:33:57 <crl> ow shit yes sorry
12:34:29 <croikle> Michae___: the part you get from the lower bit of the list needs to be (Int,Int) just like your return type
12:34:30 <crl> :t abs
12:34:31 <lambdabot> Num a => a -> a
12:34:32 <trescenzi> so I have want to reuse a bunch of code that does io and then returns a list. is there any way to ever use that list like a normal list again? (without doing unsafeperformio)
12:34:49 <crl> > abs (1 :+ 1)
12:34:51 <lambdabot>   1.4142135623730951 :+ 0.0
12:34:52 <Michae___> crocikle: Thank you, I see the problem now
12:34:54 <Botje> you can use it inside an IO block
12:34:56 <geekosaur> you have an incorrect model of working with IO
12:35:19 <arkeet> :t (>>=)
12:35:21 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:35:24 <crl> is there a function realPart / imgPart?
12:35:34 <arkeet> crl: have a look in Data.Complex.
12:35:50 <crl> arkeet: yes k, being lazy
12:35:51 <trescenzi> Well I wouldn't do this normally I'm just trying to save myself the time of rewriting a section of code a bunch of times in an HUnit test module
12:35:56 <Taneb> :t realPart
12:35:58 <lambdabot> RealFloat a => Complex a -> a
12:36:01 <arkeet> @hoogle Complex a -> a
12:36:02 <lambdabot> Data.Complex imagPart :: RealFloat a => Complex a -> a
12:36:02 <lambdabot> Data.Complex magnitude :: RealFloat a => Complex a -> a
12:36:02 <lambdabot> Data.Complex phase :: RealFloat a => Complex a -> a
12:36:03 <Taneb> :t imagPart
12:36:03 <trescenzi> I guess I'll just rewrite it since I know it'll work that way
12:36:04 <lambdabot> RealFloat a => Complex a -> a
12:36:35 <arkeet> trescenzi: you could lift the whole thing that takes the list into IO.
12:36:59 <crl> well too bad abs Complex returns a Comples ...
12:37:03 <crl> Complex*
12:37:05 <arkeet> quite
12:37:09 <arkeet> blame Num.
12:37:14 <crl> hehe
12:37:20 <trescenzi> arkeet: I guess that's my question. I can't seem to figure out how to do some stuff in a do block and then stick it into another do block
12:37:20 <Taneb> > abs (1 +: 7)
12:37:22 <lambdabot>   Not in scope: `+:'
12:37:22 <lambdabot>  Perhaps you meant one of these:
12:37:22 <lambdabot>    `++' (line 125), `P....
12:37:26 <Taneb> > abs (1 :+ 7)
12:37:28 <lambdabot>   7.0710678118654755 :+ 0.0
12:37:28 <trescenzi> wait it's just <- isn't it...
12:37:31 <arkeet> yes.
12:37:53 <crl> let absC = realPart . abs
12:38:08 <arkeet> :t (>>=) :: IO a -> (a -> IO b) -> IO b
12:38:10 <lambdabot> IO a -> (a -> IO b) -> IO b
12:38:16 <arkeet> :t fmap :: (a -> b) -> IO a -> IO b
12:38:18 <lambdabot> (a -> b) -> IO a -> IO b
12:38:24 <trescenzi> damnit I always spend all of this time trying to figure out how to do thing I already know how to do
12:38:30 <arkeet> ;)
12:42:29 <tdammers> I'm wondering why the Applicative instance for (,) is defined the way it is
12:42:45 <arkeet> how else should it be defined?
12:43:06 <arkeet> how else could it be defined?
12:43:11 <tdammers> I would have expected it to work more or less like the instance for []
12:43:26 <arkeet> first you need pure :: a -> (r,a)
12:43:52 <tieTYT2> why am i getting this error: http://hpaste.org/83466
12:44:02 <tdammers> I probably didn't think this through :D
12:44:10 <arkeet> tieTYT2: you can stick a $ in front of the do.
12:44:20 <tac_> tieTYT2: yeah, do when line /= "" $ do
12:44:23 <tac_> with the dollar sign
12:44:26 <arkeet> or put the entire do block in parentheses, but that is ugly.
12:44:36 <tac_> it's a weird parsing issue
12:45:07 <tieTYT2> i also need to wrap the function in parens
12:45:16 <arkeet> tieTYT2: no
12:45:17 <tieTYT2> k thanks
12:45:30 <arkeet> all you need is another $ on line 6
12:45:46 <tieTYT2>     Couldn't match expected type `Bool' with actual type `String'    In the first argument of `when', namely `line'    In the first argument of `(/=)', namely `when line'    In the expression: when line /= ""
12:46:10 <arkeet> tdammers: an Applicative instance is completely defined by pure () :: f () and liftA2 (,) :: f (a,b) -> f a -> f b
12:46:44 <arkeet> tdammers: when f = (r,), this means we have to have some (r,()) = r and some (r,((),())) -> (r,()) -> (r,()) = r -> r -> r
12:47:07 <arkeet> the Applicative laws require these to form a monoid.
12:47:52 <Taneb> arkeet, that also needs fmap
12:47:57 <arkeet> sure.
12:48:15 <Kinnison> JPohlman1: welcome :-)
12:49:10 <JPohlman1> Kinnison: Thanks :) Hi everyone
12:50:37 <tdammers> Taneb: isn't fmap defined in terms of pure and <*>?
12:50:52 <Taneb> tdammers, yes, bit not pure () and liftA2 (,)
12:51:01 <tdammers> arkeet: that's why I said I didn't think this through...
12:51:05 <arkeet> :p
12:51:14 <arkeet> well, you still should think it through.
12:51:18 <tdammers> I thought about it from an fmap point of view
12:51:19 <Taneb> It's like how monads can be return/bind or fmap/return/join
12:51:28 <Xaratas> i think my pc has not the required power to filter a list with 2064^4 elements in a near future, let allone the 167280^5
12:51:36 <arkeet> I agree.
12:52:05 <tdammers> as in, (+ 2) <$> (3, 5) = (5, 7)
12:52:18 <tdammers> just like (+ 2) <$> [3, 5]
12:52:27 <otters> yeah but tuples aren't homogeneous
12:52:31 <tdammers> but obviously that can't be done with tuples
12:52:33 <otters> not necessarily
12:52:38 <tdammers> because then pure would have to be ()
12:52:46 <tdammers> and that's a different type
12:52:53 <tdammers> so yeah
12:53:11 <fizbin> But tuples of fixed arity you might be able to do something with.
12:53:44 <arkeet> tdammers: nah, you could have pure a = (a,a)
12:54:07 <napping> Xaratas: you could do 2064^4 if you're a bit patient
12:54:24 <tdammers> hmm, yes
12:54:24 <arkeet> but we can't write such an instance without making a new type.
12:54:57 <tdammers> couldn't we have an instance for homogenous pairs?
12:55:01 <arkeet> we certainly could.
12:55:24 <Xaratas> napping: but i have no idea if it will be a near or a far distant future till which i need to be patient
12:55:27 <arkeet> (a,a) is isomorphic to (Bool -> a), and we *do* have an Applicative instance for (r ->)
12:56:05 <napping> Xaratas: back of the envelope, 1 item per cycle @ 4GHz that would be 4 hours or so
12:56:07 <tdammers> let me ponder that for a while
12:56:12 <arkeet> :P
12:56:25 <arkeet> you could also data Pair a = Pair a a, and write instances for Pair directly.
12:56:41 <simpson> @ djinn (Bool -> a) -> (a, a)
12:56:48 <simpson> Just to see if it can get it.
12:56:52 <simpson> @djinn (Bool -> a) -> (a, a)
12:56:52 <lambdabot> f a = (a True, a True)
12:56:56 <arkeet> ha
12:57:02 <simpson> Nearly!
12:57:11 <Taneb> Technically correct
12:57:24 <arkeet> @djinn (a,a) -> (Bool -> a)
12:57:25 <lambdabot> f (a, b) c =
12:57:26 <lambdabot>     case c of
12:57:26 <lambdabot>     False -> b
12:57:26 <lambdabot>     True -> a
12:57:27 <Taneb> :t ($ True) *** ($ False)
12:57:29 <lambdabot> (Bool -> c, Bool -> c') -> (c, c')
12:57:37 <arkeet> you want &&&
12:57:42 <Taneb> I, however, am miles off
12:57:47 <simpson> Presumably you meant to have: in (a, a') b = if b then a' else a; out f = (f False, f True)
12:57:50 <Taneb> :t ($ True) &&& ($ False)
12:57:52 <lambdabot> (Bool -> c') -> (c', c')
12:58:17 <tdammers> &&&, yeah, that sounds about right
12:58:41 <tdammers> and while we're at it...
12:58:43 <Xaratas> napping: the expected resultset should have 880*8 elements (and i have only 2,4ghz which haskell only uses to about 26% on one core -.- so your interpolation gets ~4*2*4 = 32 hours)
12:58:55 <tdammers> @hoogle (a -> m b) -> (a, a) -> m (b, b)
12:58:55 <lambdabot> No results found
12:59:12 <tdammers> I wonder if my need is really special here
12:59:23 <arkeet> :t both
12:59:25 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
12:59:27 <gustavnils> Suppose I want to apply a list of functions to the same value and get a list of the results, is there any more compact way to do this than:
12:59:32 <tdammers> ah, yeah
12:59:35 <arkeet> Lens ;)
12:59:49 <gustavnils> :t ((<*>) [toLower, toUpper] . pure)
12:59:50 <lambdabot> Char -> [Char]
12:59:50 <tdammers> coincidentally, the function I wrote to do exactly that ended up being called 'both', too
12:59:51 <napping> Xaratas: what was the problem again?
12:59:55 <tdammers> heh
12:59:56 <arkeet> :t zipWith ($)
12:59:58 <lambdabot> [b -> c] -> [b] -> [c]
13:00:06 <arkeet> oh
13:00:07 <arkeet> same value
13:00:19 <arkeet> :t (<$)
13:00:21 <lambdabot> Functor f => a -> f b -> f a
13:00:27 <arkeet> hm nope.
13:00:41 <arkeet> gustavnils: map ($x) fs, though.
13:00:59 <gustavnils> You mean like
13:00:59 <Xaratas> napping: calculating magical squares (simple implementation, exponential work)
13:01:06 <gustavnils> :t flip map [toLower, toUpper]
13:01:08 <lambdabot> ((Char -> Char) -> b) -> [b]
13:01:13 <arkeet> nope.
13:01:23 <gustavnils> Oooh
13:01:37 <gustavnils> :t \x -> map ($ x) [toLower, toUpper]
13:01:38 <lambdabot> Char -> [Char]
13:01:55 <tdammers> \funcs x -> [ f x | f <- funcs ] -- :o
13:02:06 <arkeet> :t ($>)
13:02:08 <lambdabot>     Not in scope: `$>'
13:02:08 <lambdabot>     Perhaps you meant one of these:
13:02:08 <lambdabot>       `$' (imported from Data.Function), `$!' (imported from Prelude),
13:02:16 <gustavnils> :t flip map [toLower, toUpper] . ($)
13:02:17 <lambdabot> ((Char -> Char) -> b) -> [b]
13:02:28 <EvilMachine> Hmm‚Ä¶ I have a feeling like MonadPlus should rather be called MonoidT. Am I wrong?
13:02:29 <arkeet> :t flip map [toLower, toUpper] . flip ($)
13:02:31 <lambdabot> Char -> [Char]
13:02:50 <gustavnils> Yes, that! Thanks!
13:03:04 <arkeet> EvilMachine: it's not even the same kind as a monad transformer so ??
13:03:09 <Taneb> @unmtl Compose [] [] a
13:03:10 <lambdabot> Compose [] [] a
13:03:12 <Taneb> :(
13:03:48 <sipa> :k MonadPlus
13:03:50 <lambdabot> (* -> *) -> Constraint
13:04:01 <gustavnils> arkeet: Hmm, I noticed there are two flip's, perhaps there is a way to even short that down?
13:04:03 <napping> Xaratas: are you doing the obvious pruning?
13:04:06 <arkeet> nope
13:04:07 <arkeet> ;)
13:04:26 <arkeet> unless you use <*> I guess.
13:04:32 <arkeet> @pl \fs x -> fs <*> pure x
13:04:33 <lambdabot> (. pure) . (<*>)
13:04:50 <EvilMachine> arkeet: I know, I know. But it has the same two operations, and it extends a Monad. Without requiring lifting, yes, but still‚Ä¶
13:04:51 <arkeet> @pl \fs x -> map ($x) fs
13:04:51 <lambdabot> flip (map . flip id)
13:04:54 <arkeet> oh heh.
13:05:12 <Taneb> :k MonadPlus m => m
13:05:14 <arkeet> oh that's still two flips
13:05:14 <lambdabot> *
13:05:19 <EvilMachine> :k Monoid
13:05:21 <lambdabot> * -> Constraint
13:05:23 <arkeet> :k MonadPlus
13:05:25 <lambdabot> (* -> *) -> Constraint
13:05:35 <gustavnils> arkeet: Yeah, that was my initial solution, it works. But I think Applicatives are so complicated if you compare it with the nice list comprehension solution by tdammers
13:06:06 <gustavnils> @help pl
13:06:06 <lambdabot> pointless <expr>. Play with pointfree code.
13:06:17 <gustavnils> Wow, that looks really cool
13:06:27 <EvilMachine> arkeet: data Func = Func a -> b. :D
13:06:28 <arkeet> gotta go.
13:06:34 <Xaratas> napping: for the list to start with yes (thats the 2064 in 2064^4 each element is a valid line for an order 4 magical square)
13:06:35 <EvilMachine> arkeet: data Func = Func (a -> b). :D
13:07:06 <gustavnils> @pl \funcs x -> [ f x | f <- funcs ]
13:07:06 <lambdabot> flip flip [] . ((:) .) . flip ((<-) . (| f) . f)
13:07:08 <arkeet> Xaratas: maybe start with the observation that the things in a square must be permutations of [1..n^2]
13:07:12 <arkeet> so first generate permutations
13:07:14 <arkeet> > permutations [1.3.]
13:07:16 <arkeet> > permutations [1..3]
13:07:16 <lambdabot>   A section must be enclosed in parentheses thus: (1.3 .)
13:07:18 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
13:07:51 <gustavnils> @pl flip map [toLower, toUpper] . flip ($)
13:07:52 <lambdabot> flip map [toLower, toUpper] . flip id
13:07:54 <EvilMachine> What? Since when do we have sections?
13:07:56 <arkeet> I don't really know what you're doing though.
13:08:02 <Xaratas> arkeet: they are, and the permutations must have the magical sum (34 at size 4, 15 at size 3)
13:08:20 <gustavnils> @pl ((<*>) [toLower, toUpper] . pure)
13:08:20 <lambdabot> ([toLower, toUpper] <*>) . pure
13:08:24 <arkeet> sure, but the key is how you generate them.
13:08:36 <gustavnils> :t ([toLower, toUpper] <*>) . pure
13:08:37 <lambdabot> Char -> [Char]
13:08:40 <arkeet> @where select
13:08:41 <lambdabot> I know nothing about select.
13:08:43 <arkeet> hm
13:09:32 <Xaratas> arkeet: that takes only 6 seconds for size 5 in compiled haskell code, the uncool part is building all permutations of the valid lines
13:09:59 <arkeet> 6 seconds sounds like a long time.
13:10:23 <Xaratas> for 167280 elements
13:10:24 <arkeet> @where+ select select [] = []; select (x:xs) = (x,xs) : (map.fmap) (x:) (select xs)
13:10:24 <lambdabot> I will remember.
13:10:28 <arkeet> @@ @let @where select
13:10:30 <lambdabot>  Defined.
13:12:58 <arkeet> @let perms xs = (evalStateT . replicateM (length xs) . StateT) select xs
13:13:01 <lambdabot>  Defined.
13:13:02 <arkeet> > perms [1..3]
13:13:05 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
13:14:26 * levi reads about open recursion in Haskell.
13:14:33 <arkeet> @let selects n = runStateT . replicateM n . StateT $ select
13:14:35 <lambdabot>  Defined.
13:14:39 <arkeet> > selects 2 [1..4]
13:14:41 <lambdabot>   [([1,2],[3,4]),([1,3],[2,4]),([1,4],[2,3]),([2,1],[3,4]),([2,3],[1,4]),([2,...
13:16:33 <beaky> hello
13:16:42 <Taneb> Hey, beaky
13:16:50 * jfischoff waves at beaky
13:16:58 <beaky> how do I make my data opauqe?
13:17:11 <beaky> so that nobody can pattern match into its implementation?
13:17:12 <Xaratas> arkeet: i use the candidatesb' of the last annotation at the moment http://hpaste.org/83389
13:17:29 <Taneb> beaky, put it in a module and don't export the constructors
13:17:32 <beaky> ah
13:22:13 <beaky> why are pure functions good?
13:22:33 <levi> Because they are easier to reason about.
13:23:02 <levi> Also easier to test in isolation, verify properties of via QuickCheck, etc.
13:23:33 <beaky> ah
13:23:46 <beaky> how do I write pure functions in other programming languages?
13:23:55 <beaky> (or at least emulate them)
13:24:02 <Taneb> Don't use IO
13:24:09 <Taneb> Don't change variables
13:24:19 <Taneb> Especially not global variables
13:24:40 <Taneb> (local variables are okay)
13:24:42 <levi> By writing functions that only depend on the value of their arguments and do not perform destructive modification of their inputs/outputs.
13:24:45 <jfischoff> only depend on arguments that have value semantics is an easy way
13:24:53 <jfischoff> if you have the choice
13:25:36 <beaky> ah
13:25:39 <geekosaur> but they won't help you much as most other languages don't have extensive optimization for pure functions because they're not that common. (they do help some, though. also see a gcc-ism involving "const" which tells it that the function is pure)
13:25:45 <lispy> beaky: http://www.haskell.org/haskellwiki/Functional_programming#Purity
13:26:27 <beaky> yeah maybe if I wrote immutable  data structures in C++ I would do a lot of copying :(
13:26:31 <lispy> pure basically means an abscence of side-effects. So, to program in a pure way you need to avoid side-effects.
13:27:24 <levi> It doesn't mean you can't pass pointers or references, just that you can't use them to modify the objects pointed to.
13:27:33 <Jeanne-Kamikaze> is it possible to make the GADT'd version of Expr in this tutorial an instance of Show ? http://en.wikibooks.org/wiki/Haskell/GADT
13:27:40 <beaky> right; I try to limit IO to selected functions
13:27:49 <beaky> in every programming language
13:27:55 <Jeanne-Kamikaze> I sense I'm being stupid
13:28:12 <arkeet> Jeanne-Kamikaze: deriving instance Show Int => Show Expr
13:28:37 <arkeet> or
13:28:44 <Jeanne-Kamikaze> why Int ? what about Bool ?
13:28:50 <levi> Generally you will use a different style of data structures, though, as the typical ones in impure languages depend on mutating the data structure instead of building a new structure that shares data from the old one.
13:28:53 <arkeet> ah, add that too if you keep going.
13:29:03 <arkeet> well maybe you don't need it, I forget.
13:29:06 <napping> making an instance should work fine, the only thing that doesn't work is a "deriving (Show)" clause, just cause GHC is silly about that
13:29:28 <Jeanne-Kamikaze> oh, ok
13:29:35 <arkeet> yeah, I guess you don't.
13:29:57 <arkeet> because the Show Int instance is already in scope.
13:30:10 <arkeet> but further down, you'd need
13:30:17 <napping> a standalone deriving clause basically just sticks in the code that would be generated, and that typechecks just fine. I'm not sure why an attached deriving clause doesn't work
13:30:26 <arkeet> yeah I guess it just works.
13:30:34 <arkeet> deriving instance Show (Expr a)
13:31:07 <Jeanne-Kamikaze> deriving instance ?
13:31:19 <arkeet> yes, you need to turn on the StandaloneDeriving extension.
13:31:32 <napping> or just write your own Show instance
13:31:40 <Jeanne-Kamikaze> I'd prefer deriving
13:31:47 <arkeet> writing Show instances is really annoying.
13:31:54 <beaky> will haskell let you deriving other things?
13:31:56 <beaky> like inheritance?
13:32:08 <DanBurton> you lost me at "like inheritance"
13:32:08 <arkeet> what is inheritance?
13:32:21 <beaky> inheritance is record extension
13:32:32 <arkeet> ??
13:32:33 <simpson> beaky: Just to clarify, we're familiar with the general idea of inheritance, but you gotta be more specific.
13:32:39 <napping> the definition of show will just be a usual function of type Expr a -> String, the pattern matching letting you narrow "a" in the GADT way
13:32:57 <arkeet> napping: writing that is hard.
13:32:58 <arkeet> :p
13:33:19 <beaky> ah
13:33:36 <DanBurton> GeneralizedNewtypeDeriving will let you derive a lot of things, since a newtype just seals an existing type.
13:33:46 <DanBurton> that's kindasorta like inheritance
13:33:53 <beaky> ah nice
13:33:54 <DanBurton> if you squint a bit
13:33:56 <napping> sure, I'm just saying there's no extra difficulty beyond "deriving" being somehow broken
13:34:05 <beaky> I like inheritance because it enables reuse
13:34:47 <levi> Inheritance is actually a poor vehicle for reuse in most cases.
13:34:49 <DanBurton> here in Haskell-land, reuse is usually accomplished via parametric polymorphism, or other scarily-named but actually-quite-mundane stuff
13:35:09 <levi> Modern object oriented design teaches to favor composition over inheritance for sharing implementation.
13:36:28 <beaky> ah
13:37:12 <beaky> why is inheritance bad?
13:37:21 <beaky> I use deriving all the time in haskell :D
13:37:47 <arkeet> what does that have to do with inheritance?
13:37:58 <tac_> deriving isn't inheritence, really...
13:38:07 <callenbot> What's the current state on Sinatra/Flask-esque lightweight web frameworks in Haskell right now? Last I saw, most of them were abandoned.
13:38:27 <napping> how about sharing structure? I've been translating a design that uses a class hierarchy to represent an AST, where every kind of node has some shared info (location), and the expressions all have more info (like type), and it's a bit annoying sharing stuff between constructors
13:39:39 <arkeet> napping: so share them in a type argument
13:40:14 <napping> in several type arguments?
13:41:00 <parcs> callenbot: if you mean a lightweight web framework, then i recommend snap and happstack
13:41:19 <arkeet> well it's hard to be more specific without you saying more? I dunno.
13:46:25 <callenbot> parcs: I don't know that I'd call either of those lightweight.
13:46:29 <callenbot> parcs: or at least, not happstack.
13:46:35 <callenbot> I'll look into Snap.
13:46:56 <callenbot> parcs: I'm really looking for something simple like Scotty but better maintained ideally.
13:47:01 <stepkut> callenbot: how is happstack not lightweight ?
13:47:08 <stepkut> callenbot: perhaps.. happstack-lite ?
13:48:14 <parcs> callenbot: what is not lightweight about happstack? a hello world is one line
13:48:58 * hackagebot poker-eval 0.2.0 - Binding to libpoker-eval  http://hackage.haskell.org/package/poker-eval-0.2.0 (DavidHimmelstrup)
13:48:59 <callenbot> parcs: that's being a bit dishonest. A framework that includes its own persistence layer is not lightweight.
13:49:05 <callenbot> parcs: have you used Flask or Sinatra before?
13:49:24 <parcs> yeah, briefly
13:49:42 <Taneb> (happstack contains its own persistence layer?)
13:49:59 <parcs> happstack's persistence layer is an optional, separate package
13:49:59 <srhb> Not afaik.
13:50:00 <stepkut> Taneb: acid-state is completely separate, you are not required to us eit
13:50:15 <callenbot> Still.
13:50:16 <Taneb> stepkut, didn't think so
13:50:29 <srhb> callenbot: Still what? :P
13:50:45 <Taneb> callenbot, with happstack, you are not even required to have acid-state installed
13:50:52 <callenbot> oh god, it's one of those libraries that puts the HTML in the server-side code
13:50:56 <stepkut> callenbot: happstack provides a lightweight core which can be extended via a large variety of addons.
13:50:59 * callenbot closes tab on happstack tutorial
13:51:04 <srhb> callenbot: What? You don't have to do that.
13:51:08 <callenbot> http://happstack.com/docs/crashcourse/Templates.html#helloblaze <--- bad.
13:51:13 <srhb> Then don't use blaze
13:51:17 <simpson> callenbot: Waaaaaait. Where would you put HTML besides the server side? :3
13:51:18 <srhb> It's not even included with Happstack
13:51:25 <tazjin> callenbot: The HTML templater is replacable with whatever you want?
13:51:44 <parcs> callenbot: you can refactor out the template code into a separate function if you're an MVC freak
13:51:46 <tazjin> callenbot: If you want reloadable external files look at something like Heist or just use plain HTML if you don't want things to be dynamic?
13:52:01 <srhb> callenbot: Seriously, you're making arguments up that are a) wrong b) provably so if only you actually read the crash course rather than skimming and then knee-jerk killing tabs.
13:52:06 <callenbot> https://github.com/bickfordb/text-press closest thing to what I want, but last commit was 4 years ago.
13:52:11 <callenbot> That is seriously ghetto.
13:52:24 <Taneb> callenbot, for pretty much any Haskell Web Framework, they're modular as hell and you can swap out pretty much all the components
13:52:27 <callenbot> Heist looks workable, maybe.
13:52:57 <tazjin> callenbot: How do you want templating to work? There's most likely a library for it and it's most likely compatible with Happstack
13:52:57 <callenbot> the extension model is loony though. Too much like mustache.
13:53:04 <callenbot> tazjin: Jinja2/Django templates.
13:53:17 <parcs> callenbot: you're getting less and less lightweight...
13:53:28 <callenbot> parcs: Flask+Jinja2 is perfectly lightweight
13:53:28 <stepkut> callenbot: not sure you are going to be happy as a web programmer
13:53:55 <callenbot> stepkut: I was able to find what I wanted in Clojure with Ring+Compojure+Clabango.
13:54:04 <stepkut> callenbot: then use that?
13:54:08 <simpson> Uh, gang, just to double-check, you're calling *Flask* not lightweight.
13:54:36 <simpson> I mean, yes, Django's derpy as hell, but Jinja2 and Flask are not bad tools.
13:54:38 <callenbot> http://flask.pocoo.org/ just so everybody remembers what we're talking about.
13:54:49 <hpaste> ‚ÄúOr is it?‚Äù pasted ‚ÄúMonadPlus is a Monoid.‚Äù at http://hpaste.org/83470
13:55:00 <simpson> callenbot: Anyway, happstack supports umpteen templaters and one of them should be sufficient for you.
13:55:16 <callenbot> simpson: I can't find a template lang in Haskell that's what i wanted except for that one with a commit from 4 years ago.
13:55:27 <simpson> callenbot: Well, maybe it's time to fix that old library up!
13:55:35 <callenbot> simpson: not a high-value use of my time
13:55:47 <simpson> callenbot: Also remember that Haskell's ecosystem is such that strong and reliable types are good.
13:55:50 <parcs> maybe expand your choices other than "i want it like what i'm already familiar to"
13:56:04 <callenbot> simpson: I'm productive in Python and Clojure *right* now, I'm seeking a way to become productive in Haskell.
13:56:06 <simpson> As such, things like Yesod+Hamlet are pretty awesome.
13:56:16 <callenbot> parcs: I'm familiar with many ways of doing things.
13:56:23 <callenbot> parcs: that's how i was able to compare Heist with Mustache.
13:56:23 <simpson> callenbot: Give up and go back to Python? That's what I did the first four or five times I tried to learn Haskell.
13:56:27 <callenbot> parcs: I know what works well for me.
13:56:32 <callenbot> simpson: been there, done that.
13:56:55 <simpson> callenbot: Are you getting paid to learn Haskell?
13:56:55 <callenbot> parcs: of course if you've only used one of way of doing something, it's easy to believe that someone is dimissing it because, "darn it, parents just don't understand"
13:56:58 <napping> sounds like you want a templating system, rather than a web framework
13:57:01 <callenbot> simpson: no.
13:57:05 <callenbot> napping: it's related.
13:57:09 <mdmkolbe> I've got some code that works on Template Haskell 2.7.0.0 but breaks on TH 2.8.0.0.  The fix is easy but I need the code to compile on both.  Is there a way I can use something like CPP to get the code to work on both?
13:57:12 <simpson> callenbot: Then take your time and expand your horizons.
13:57:27 <callenbot> simpson: I told you, I already know what works well
13:57:29 <mauke> mdmkolbe: what's the error?
13:57:33 <callenbot> simpson: I don't have time to fuck around.
13:57:37 <tazjin> mdmkolbe: There's pragmas for GHC versions, can you paste an example for your code?
13:58:03 <tazjin> mdmkolbe: (assuming that specific GHC versions ship with specific TH versions, which should be the case)
13:58:07 <simpson> callenbot: Have you ever worked with Nevow/Athena/twisted.web.template in Python?
13:58:16 <simpson> callenbot: They work almost exactly like Hamlet and Blaze.
13:58:25 <simpson> (Modulo static types.)
13:59:15 <callenbot> simpson: they're horrendous.
13:59:25 <callenbot> simpson: I'm never using a template library like that again
13:59:25 <simpson> callenbot: Oh, no, you're *too* kind. >:T
13:59:40 <mdmkolbe> I have "deriving instance Ord InlineSpec" but "InlineSpec" is no longer a defined type in 2.8.0.0.
13:59:49 <simpson> callenbot: The whole "I can reuse this chunk of templating code over and over again" thing is pretty damn cool.
13:59:57 <callenbot> simpson: I already have that in Jinja.
14:00:01 <callenbot> simpson: extends + includes
14:00:05 <simpson> You combine it with the whole "My objects know what they look like in HTML" thing, and you're set.
14:00:11 <simpson> callenbot: Ever unit-tested templates? >:3
14:00:18 <callenbot> yes, and views.
14:00:22 <mdmkolbe> I'm not sure I can use the version of GHC to determine the version of TH.
14:00:23 <callenbot> you should see how pyramid does it.
14:00:37 <simpson> callenbot: Pyramid's cool! But I never build things big enough to justify it.
14:00:43 <simpson> (Also BlueBream.)
14:00:48 <callenbot> it's okay. I prefer Flask, but there are good ideas to steal.
14:00:53 <callenbot> like testable views.
14:01:03 <simpson> callenbot: Anyway, come to #python if you want to talk about how awful the Python world is, instead of how awful the Haskell world is.
14:01:12 <callenbot> I have a "renderer" function in most of my flask projects that solves that problem.
14:01:26 <callenbot> simpson: ick @ channel.
14:01:32 <tazjin> mdmkolbe: afaik the TH version should be bundled with the GHC version, btu somebody on here should know?
14:01:35 <callenbot> simpson: I'm in #pocoo
14:01:43 <simpson> We can't really solve your problem. Your problem isn't really "Which Haskell Web libraries have good integration with templating libraries?"
14:01:56 <simpson> It appears to be more along the lines of "Haskell sucks because my opinions are set in stone."
14:02:01 <simpson> And that can't really be helped.
14:02:01 <Kinnison> heh
14:02:18 <simpson> callenbot: #pocoo's cool. mitsuhiko's pretty cool guy.
14:02:20 <Kinnison> I really need to get around to splitting my runtime template library out of the project I wrote it in, into its own library
14:02:23 <napping> or at least "Which Haskell template libraries are most like Flask"
14:02:35 <callenbot> simpson: I'm very fond of him. Very rational and productive individual.
14:02:43 <callenbot> napping: Flask isn't a template library.
14:02:57 <napping> callenbot: which library did you like again?
14:03:04 <srhb> Jinja2 was the template stuff.
14:03:05 <simpson> callenbot: Anyway, I view HTML templating as a subset of the pretty-printing problem.
14:03:06 <parcs> or "let's bikeshed about how we write templates, because template libraries are oh-so-different"
14:03:13 <Kinnison> :-)
14:03:15 <tazjin> napping: he said Django and jinja2
14:03:23 <simpson> And from that angle, many *many* libraries do horrible things.
14:03:26 <Kinnison> anyone know of a good tutorial on *writing* monad transformers?
14:03:41 <simpson> Kinnison: I'm pretty sure that edwardk is a walking tutorial on the subject. :3
14:03:42 <Kinnison> Or is it a case of read the mtl source and extrapolate?
14:03:56 <Kinnison> simpson: It's unfair on edwardk to expect him to be around when I wanna code though :-)
14:04:02 <edwardk> hah
14:04:03 <Kinnison> simpson: much though I worship the man
14:04:06 <Kinnison> gah he's here
14:04:08 * Kinnison faints
14:04:12 <Kinnison> (honest)
14:04:15 <simpson> Kinnison: The short version, AFAICT, is to write your transformer, demonstrate that it obeys the monad laws, and then write the MonadTrans instance.
14:04:37 <simpson> And, if the shoe fits, MonadState/etc. instances.
14:04:44 <Kinnison> Hmm
14:04:57 <simpson> Kinnison: Out of curiosity, what did your monad look like?
14:05:02 <beaky> I love partial function application
14:05:14 <Kinnison> simpson: I'm thinking ahead to when I split this template engine out a bit
14:05:16 <beaky> btw what is the mathematical basis of partial function application and currying?
14:05:39 <beaky> I thought math function can take multiple parameters so there was no need for currying
14:05:43 <beaky> functions*
14:05:44 <Kinnison> simpson: although tbh, the monad I was thinking of writing might devolve to a "hidden" StateT anyway
14:05:47 <danharaj> The adjunction between products and exponential fuctors.
14:05:49 <danharaj> functors*
14:05:50 <levi> beaky: Lambda calculus
14:05:51 <beaky> ah
14:05:56 <tsou> beaky: i guess the bijection between (A x B) -> C and A -> (B -> C)
14:06:15 <simpson> Kinnison: Many problems indeed can be solved with StateT.
14:06:26 <simpson> Kinnison: Sometimes your hammer can be a bit smaller and more specific, though. :3
14:06:37 <danharaj> Hom (A x B, C) <=> (A, B -> C) (naturally)
14:06:55 <parcs> (c^b)^a = c^(a*b)
14:08:32 <Kinnison> simpson: :-)
14:08:42 <Kinnison> simpson: I guess I was a tad leery about layering State upon state
14:09:10 <Kinnison> simpson: since I would expect my "users" to be stuffing something along the lines of StateT foobar IO underneath me
14:09:11 <simpson> Kinnison: Sure. Also don't forget about RWS, which might be what you want.
14:09:26 <Kinnison> Hmm, I shall look up RWS
14:09:40 <`nand`> RWS is just ReaderT, WriterT and State composed with eachother
14:09:50 <simpson> Kinnison: I did this in a library, BTW; I introduced a bunch of functions which work in StateT (b, MyLibraryState) IO a.
14:10:10 <Kinnison> I see
14:10:14 <simpson> Kinnison: And then you could focus onto StateT b IO a, whenever you felt like doing things that were not library-based.
14:10:24 * Kinnison nips to the loo while his latest youtube vid uploads :-)
14:10:32 <Kinnison> then I'll ponder this all some more
14:10:36 <simpson> RWS' main advantage is that it's not three entire newtypes on each other, but one single combined type.
14:11:17 <srhb> Kinnison: Where do we find your latest Youtube vid?
14:21:48 <sclv> what are the tradeoffs again between the vector and bytestring representations?
14:22:00 <sclv> the former being a mutablebytearray and the latter a foreignptr?
14:23:04 <Kinnison> Sorry, got distracted by comics
14:24:04 <Kinnison> srhb: on my youtube channel: https://www.youtube.com/user/KimballKinnison -- you'll want the adventures in haskell playlist for the latest crap :-)
14:24:26 <sclv> actually, wait, Vector is unpinned, right?
14:24:27 <sclv> crap
14:25:11 <hpc> actually, what is the difference between vector, array, and bytestring?
14:25:57 <hpc> or more specifically, between mutablebytearray and foreignptr
14:26:33 <Kinnison> srhb: Irritatingly it seems to have not uploaded in 720p so I may have to reupload later
14:27:57 <mauke> True is the one true boolean value
14:29:57 <Kinnison> srhb: Hmm, now it is available in 720p, enjoy :-)
14:34:35 <Mathnerd314> so I was looking at http://blog.golang.org/2011/04/introducing-gofix.html. Does Haskell have anything similar?
14:36:13 <simpson> Mathnerd314: Strange as it might sound, most Haskellers prefer to write code such that it never needs boring mechanical updates.
14:36:40 <Mathnerd314> the commit logs prove you wrong
14:36:52 <sclv> yeah it would be great to have for haskell.
14:37:03 <sclv> let the core apis grow a bit with less pain
14:37:20 <Leftmost> In Learn You a Haskell, there's an example line with "ghci> (+) <$> (+3) <*> (*100) $ 5" which results in 508. It's not clear to me why both (+3) and (*100) are both applied to 5 seperately. Can anyone clarify this?
14:37:25 <sclv> you can knock out a tool with haskell-src-exts but i wouldn't consider it reliable :-(
14:37:58 <sclv> the hard part is go is very one-way-only about formatting, but haskell isn't. so tossing your code through a parser/printer is less pleasant, even when it works.
14:38:23 <napping> Leftmost: that's how the Applicative ((->)r) instance works
14:38:29 <sclv> also that's still going to be basically a mechanical/lexical search/replace even with tree structure
14:38:39 <sclv> something more type driven is a bigger project.
14:38:40 <Mathnerd314> hmm: http://trac.haskell.org/haskell-src-exts/ticket/186
14:39:00 <mauke> Leftmost: <$> is .
14:39:16 <danharaj> indeed
14:39:19 <danharaj> :t (.)
14:39:20 <Mathnerd314> or rather http://trac.haskell.org/haskell-src-exts/ticket/13
14:39:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:39:36 <Mathnerd314> "The overall goal is to support a round-trip parser and pretty-printer so that pretty . parse == id."
14:40:06 <sclv> see this though: https://plus.google.com/u/0/communities/116266567145785623821
14:40:10 <sclv> very much a work in progress
14:41:21 <Leftmost> I may just be confused as to why the Applicative instance for (->) r is defined as f x (g x).
14:41:42 <mauke> Leftmost: well, look at the types
14:41:57 <sclv> Mathnerd314: try i and see! last i tried, it wasn't quite id (it didn't hurt semantics, but it did touch formatting). and the hardest part was fixing up the bits that necessarily _had_ to change because i'd actually modified the surrounding source.
14:42:04 <napping> it's Reader - every node can read the r
14:42:04 <Mathnerd314> sclv: hmm. I don't see anything on there
14:42:18 <Mathnerd314> HaRE != haskell-src-exts last time I checked
14:42:22 <sclv> right
14:42:27 <sclv> i was just suggesting anoher tool
14:42:30 <napping> f x (g x) is the only reasonable way to compibine f :: (r -> (a -> b)) and g :: (r -> a) to make a (r -> b)
14:42:36 <crl> > ii^4
14:42:39 <lambdabot>   1.0 :+ (-0.0)
14:42:53 <sclv> here's the repo-in-progress where they're rebuilding it off ghc: https://github.com/alanz/HaRe/tree/ghc-api
14:43:06 <hpc> > (f <*> g) x :: Expr
14:43:08 <lambdabot>   Ambiguous type variable `a0' in the constraints:
14:43:09 <lambdabot>    (GHC.Show.Show a0)
14:43:09 <lambdabot>     ...
14:43:11 <hpc> D:
14:43:19 <crl> > ii^5 == ii
14:43:22 <lambdabot>   True
14:43:24 <Mathnerd314> sclv: well, trying to use the GHC api is pretty pointless, GHC is worse than haskell-src-exts at pretty-printing... :p
14:44:00 <Leftmost> Okay, I suppose that makes sense to an extent. Thank you.
14:44:02 <mgsloan> well, you definitely wouldn't be using the pretty printer to do refactoring
14:44:34 <mgsloan> Anything that doesn't preserve the syntax around it is just a no-go for refactoring Haskell
14:45:04 <mgsloan> the important thing about using the GHC API is that you get scoping information / maybe have a chance of dealing with CPP
14:45:19 <Mathnerd314> mgsloan: that's why haskell-src-exts is interesting, the theory is that pretty . parse == id
14:45:23 <hpc> everyone knows the canonical approach to refactoring haskell is to just start over
14:46:05 <napping> that bug was talking about making parse . pretty == id
14:46:09 <mgsloan> Mathnerd314: right, but you need other things, like haskell-names (part of haskell-suite), to do scoping.  Then, you have to trust that it's working the same as GHC
14:46:09 <napping> which is much less ambitious
14:46:24 <mgsloan> napping: Ahh, right, that should definitely be true :)
14:46:31 <Mathnerd314> napping: #13 mentioned pretty . parse == id
14:46:42 <mgsloan> I wasn't following the conversation, just jumped in! :)
14:46:53 <byorgey> the "Annotated" part of the haskell-src-exts API is close to giving you pretty . parse == id
14:47:11 <byorgey> except it doesn't preserve *trailing* whitespace
14:47:17 <byorgey> (but it preserves all other whitespace)
14:47:37 <mgsloan> byorgey: Yup!  and roche has a nifty demo of using that to do renaming refactorings: https://github.com/feuerbach/hasfix
14:48:01 <byorgey> ah, cool!  Yeah, I saw roche's post about name resolution + open recursion
14:48:01 <mgsloan> the cool thing is that preserves all layout around the replacement, including block indentation
14:48:11 <Mathnerd314> hmm, if it can preserve trailing comments it should be able to preserve trailing whitespace...
14:48:38 <byorgey> Mathnerd314: not necessarily
14:48:58 <mgsloan> Yeah, unfortunately that repo is a little bit troublesome to build at the moment (need specific HEAD versions of some libraries - notably, you need ekmett's version of data-lens)
14:49:22 <byorgey> Mathnerd314: the way it works is by associating a precise line+column number with everything.  When you go to print a token out, check the current line + column, and add space if you need to get to where you're supposed to be first
14:49:41 <byorgey> the trouble is that nothing comes after the trailing whitespace, so there's nothing to trigger it getting emitted
14:49:45 <linduxed> in the following line
14:49:47 <linduxed> problem12 = fromMaybe 0 $ find ((>500) . fromIntegral . length . divisors) triangleNumbers
14:49:58 <linduxed> i'm getting the following warning:
14:50:09 <linduxed> Defaulting the following constraint(s) to type `Integer'
14:50:11 <mgsloan> Mathnerd314: You could append trailing comments that have something special in them, and them remove all instances of those trailing comments
14:50:18 <linduxed> pointing at the 500
14:50:19 <geekosaur> @where dmr
14:50:20 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
14:50:26 <geekosaur> linduxed, ^^
14:50:27 <mgsloan> Mathnerd314: Be sure to have a space before the "--", though, otherwise it might get mixed up in some operators
14:51:00 <linduxed> geekosaur: thx, will read
14:51:11 <edeast> comonad comprehensions; does an example exist? google gives me a little conversation in scala
14:51:11 <mgsloan> by "special", I mean gobbledeguk that you're pretty sure won't be in the code - or you could check that the string isn't in the code
14:51:12 <Mathnerd314> mgsloan: ah! so hasfix is what I was looking for (I started with gofix)
14:51:16 <byorgey> linduxed: you can add {-# LANGUAGE NoMonomorphismRestriction #-} to the top of your file to turn it off (recommended)
14:51:27 <mgsloan> Mathnerd314: Cool!!
14:51:31 <linduxed> byorgey: why is that recommended?
14:51:53 <mgsloan> Mathnerd314: If you just need the bits that do layout-preserving changes to haskell source code, I can send you a cut down version of has-fix
14:52:21 <byorgey> linduxed: because all the Monomorphism Restriction is trip people up, for a benefit that isn't very important in most cases
14:52:31 <byorgey> *all the MR does is...
14:52:41 <Mathnerd314> mgsloan: well, I think it might be an interesting exercise to run haskell-src-exts over all of HAckage and check if pretty . parse == id
14:53:09 <byorgey> Mathnerd314: I've been doing that on some large packages.  I've already filed three or four bugs =)
14:53:10 <linduxed> byorgey: but i feel that since i don't fully understand the implications of the monomorphism thing, i should go with the design of the language
14:53:14 <linduxed> or rather, the defaults
14:53:15 <mgsloan> Mathnerd314: Ahh, interesting.  Sure!  Then, for that, may as well just trim all trailing whitespace as a preprocessor
14:53:29 <Sgeo> I think special syntax for comonads would make it click in my mind
14:53:32 <byorgey> linduxed: no, you should go with what #haskell recommends =)
14:53:36 <Sgeo> I find syntax sugar helped me understand monads, I think
14:53:41 <linduxed> byorgey: ahahah
14:53:42 <byorgey> linduxed: the original language designers were not infallible.
14:53:44 <mgsloan> s/preprocessor/preprocess
14:53:49 <byorgey> linduxed: also, the MR is going to be taken out anyway.
14:53:58 <linduxed> byorgey: really?
14:54:08 <Kinnison> the use of fromIntegral there seems a little strange
14:54:10 <crl> > sequence [(1,5),(1,4)]
14:54:12 <lambdabot>   No instance for (GHC.Base.Monad ((,) t0))
14:54:12 <Kinnison> length already returns an integral
14:54:13 <lambdabot>    arising from a use of `e_11514...
14:54:22 <Mathnerd314> mgsloan: isn't it basically https://github.com/feuerbach/hasfix/blob/master/HasFix.hs ?
14:54:30 <Sgeo> length always returns a specific integral, an int
14:54:32 <Sgeo> Int
14:54:34 <`nand`> vanilla Haskell is such an awkward language
14:54:48 <Kinnison> Sgeo: Aye
14:55:47 <Kinnison> linduxed: Does your code operate without warning if you drop the fromIntegral?
14:55:58 <Mathnerd314> `nand`: and turning on all those extensions is so much work... I had to write a script that dumped them all so I could put them as my header
14:56:00 <mgsloan> Mathnerd314: Well, turns out there's a subset of has-fix that doesn't depend on the "haskell-modules" package.  Removing that dependency made it much more easy to send a little demo I made to other people
14:56:23 <linduxed> Kinnison: hmmm, it does
14:56:23 <Ralith> byorgey: wait, the MR has been officially decided against?
14:56:34 <`nand`> {-# LANGUAGE AllThePragmas #-}
14:56:39 <mgsloan> namely, the subset of has-fix that deals with substituting an interval of a line with some other AST
14:56:52 <crl> there should be a haskellscript to replace javascript
14:57:01 <linduxed> Kinnison: thx
14:57:04 <mgsloan> crl: See Fay, or GHCJS
14:57:05 <crl> simply haskell
14:57:11 <byorgey> hmm, I thought it was, but I'm having trouble finding info on it.  Looks like it's stalled in the Haskell Prime process, actually.
14:57:13 <crl> mgsloan: k
14:57:16 <byorgey> the MR is still in Haskell 2010
14:57:21 <Kinnison> linduxed: the issue was that you had (>500) (which was essentially Integral a => a -> Bool, and then you used fromIntegral on an int, making it "any old integral" and so the compiler had to pick an integral to use (and it picked Integer as being the widest option I imagine)
14:57:26 <Ralith> aw.
14:57:36 <mgsloan> crl: I think at this point Fay is more practical, but doesn't support typeclasses
14:57:40 <byorgey> http://hackage.haskell.org/trac/haskell-prime/wiki/NoMonomorphismRestriction
14:57:45 <linduxed> however, in this code https://gist.github.com/linduxed/5086426
14:57:46 <Sgeo> `nand`, including IncoherentInstances and OverlappingInstances?
14:57:57 <`nand`> Kinnison: to me it looks like it's defaulting Num, not Integral
14:57:57 <Mathnerd314> I think a GHC20xx would work, but I'm too lazy to implement it and it's not really portable :p
14:57:58 <`nand`> :t fromIntegral
14:57:58 <linduxed> i need the fromIntegral for it to even work
14:58:00 <lambdabot> (Integral a, Num b) => a -> b
14:58:00 <Sgeo> I think I used to understand OverlappingInstances
14:58:01 <`nand`> the ‚Äòb‚Äô
14:58:13 <Kinnison> `nand`: Even worse :-)
14:58:15 <linduxed> but i still get the Defaulting the following constraint(s) to type `Double`
14:58:59 <Kinnison> linduxed: in that context sqrt can operate on any Real IIRC
14:59:04 <Kinnison> or perhaps Rational
14:59:10 * Kinnison could get ghci out but is too lazy
14:59:17 <Kinnison> :t sqrt
14:59:18 <lambdabot> Floating a => a -> a
14:59:23 <Kinnison> Floatings then :-)
14:59:32 <`nand`> sqrt rational? :)
15:00:08 <Kinnison> `nand`: I'm really tired, I realised the moment I said it that I was utterly wrong
15:00:21 <Sgeo> imo it is perfectly reasonable to expect fix (0+) to return 0
15:00:38 * Kinnison should stop saying anything here, lest he make even worse mistakes
15:00:42 <Kinnison> time for bed and a book methinks
15:01:04 <Sgeo> a+b should be non-strict on b when a=0 and non-strict on a when b=0
15:01:08 <Mathnerd314> Sgeo: need a CAS for that, that sort of fix is pretty hard to implement
15:01:15 <`nand`> note that Real is sort of a nonsensical class, at least I can't see any real use case for it; its only function is -> Rational
15:01:28 <Sgeo> unamb!
15:02:04 <napping> Sgeo: even so, fix (0+) could only be undefined
15:02:04 <`nand`> Sgeo: do you mean (0*( ?
15:02:05 <Mathnerd314> Sgeo: what about sum (cycle [-1,1]) ?
15:02:18 <napping> unless you claim (fix id :: Integer) should also be 0
15:02:49 <Sgeo> Mathnerd314, dang you
15:02:51 <Mathnerd314> > fix id :: Integer
15:02:55 <lambdabot>   mueval-core: Time limit exceeded
15:03:25 <Mathnerd314> hmm, I think in mathematica it just returns "fix id" again
15:04:03 <Mathnerd314> Haskell doesn't really have that notion of "treat errors as unreducible expressions"
15:05:37 <mgsloan> Mathnerd314: Although, with -fdefer-type-errors, it does have the notion of "treat errors as runtime errors" ;)
15:06:22 <Mathnerd314> yeah, and I guess vacuum lets you look at runtime values
15:06:24 <crl> mgsloan: if it transforms haskell source code to javascript source code, it must have been hard and painful, what i was more about is a browser running with hs scripts, <script type="text/haskell>
15:06:37 <`nand`> -ftreat-errors-as-segfaults
15:06:54 <linduxed> erm
15:06:57 <linduxed> wtf
15:07:03 <mgsloan> crl: It was a bit of an undertaking, but no, I don't think it was too painful.
15:07:16 <mgsloan> crl: At that point, you may as well just support sandboxed execution of native code
15:07:21 <linduxed> i've got this file https://gist.github.com/linduxed/5086484
15:07:28 <`nand`> crl: you can conceptually reduce haskell to some very simple machines and implement those rather straightforwardly
15:07:32 <linduxed> even though i added the pragma, i still get this:
15:07:41 <linduxed> 12.hs|27 col 66 warning| Defaulting the following constraint(s) to type `Double'
15:07:51 <linduxed> that's right on top of sqrt
15:07:51 <crl> mgsloan: their code size is important
15:08:13 <Mathnerd314> hmm, I wonder how it would be to go from vacuum-graph to lambdas
15:08:24 <`nand`> :t truncate -- linduxed
15:08:26 <lambdabot> (Integral b, RealFrac a) => a -> b
15:08:34 <`nand`> the monomorphism restriction plays no role here
15:08:53 <mgsloan> crl: Generated Fay code compresses very well, and otherwise is essentially a syntactic rewrite of Haskell (so generated code size is linearly related to source code size)
15:09:02 <Mathnerd314> so then you could start evaluating (\x -> x x) (\x -> x x) (with suitable newtypes) and stop it after a few iterations, see what's there
15:09:17 <`nand`> you have a (Floating a, RealFrac a) floating around in the middle of that expression that gets defaulted to Double in lieu of throwing an unambiguous type error
15:10:03 <mgsloan> crl: On the other hand GHCJS reuses more of GHC, which can allow for faster generated code, at the cost of increased generated code size / runtime size
15:10:08 <`nand`> if you want to get rid of the warning, you could eg. give your ‚ÄòfromIntegral‚Äô a type
15:10:21 <crl> mgsloan: anyway thx, may try it, if it fits well
15:10:36 <crl> for generating js?
15:10:50 <mgsloan> crl: Fay works pretty well.  My only qualm is that there aren't sourcemaps for debugging yet.
15:11:44 <`nand`> isn't Fay a fairly small subset of Haskell also?
15:12:05 <`nand`> I'd imagine one of the advantages of using GHC is access to all of the voodoo language pragmas
15:12:24 <mgsloan> `nand`: Yes, since typeclasses are a pretty big omission.  But quite a few syntactic GHC extensions are supported
15:12:45 <`nand`> eg. I could imagine wanting ‚Äòlens‚Äô
15:13:06 <`nand`> for writing beautiful DOM code, perhaps
15:13:17 <mgsloan> Hahaha, yeah, I've been considering making a small data-lens-like for fay
15:13:19 <mgsloan> definitely
15:13:42 <`nand`> oh right, no type classes
15:13:51 <`nand`> meaning no twan lenses :(
15:14:09 * `nand` goes to sleep
15:15:07 <crl> yes you could use javascript in a functional way
15:15:21 <crl> not much now
15:15:31 <crl> becaue of language lacks
15:15:34 <crl> but in future..
15:17:03 <ab9rf> crl: i ran across a Haskell-to-Javascript compiler once, but haven't been able to find it since
15:17:25 <totimkopf> hmm, is there some sort of face recognition package in haskell? I want to accept only images that don't have human beings in them for upload
15:18:16 <crl> ab9rf: mgsloan talked about Fay, or GHCJS
15:19:01 <totimkopf> https://github.com/RaphaelJ/Face-recognition I found this!
15:19:01 <ab9rf> crl: might be the same thing.  i found it like three years ago
15:19:10 <ab9rf> crl: it looked pretty bitrotten at the time
15:19:43 <mgsloan> ab9rf: There have been many assaults on "The JavaScript Problem" http://www.haskell.org/haskellwiki/The_JavaScript_Problem
15:19:48 <ab9rf> mgsloan: ah
15:19:53 <luite> I wouldn't expect usable sourcemaps for ghcjs any time soon btw
15:19:56 <mgsloan> ab9rf: The more recent ones can actually be used, though :)
15:20:02 <luite> ghc messes up the source quite a bit
15:20:37 <ab9rf> mgsloan: the one i found worked only for extremely limited programs, and had other issues
15:21:23 <ab9rf> mgsloan: javascript is not my least favorite language but it comes close
15:21:24 <DanBurton> So I'm working on setting up emacs for Haskelling on my Mac. Trying to get ghc-mod working, but not quite good enough at emacs magic to get it going.
15:21:31 <mgsloan> ab9rf: GHCJS and Fay can handle large programs.  I think there's a demo of GHCJS running the Haskell diagrams library (which is fairly sizable)
15:22:03 <luite> http://ghcjs.github.com/bin/mloc-js.trampoline.jsexe/
15:22:34 <ab9rf> mgsloan: i've come to the conclusion that nobody should actually write javascript; it should instead be a write-only language like postscript :)
15:23:04 <DanBurton> here's my .emacs.el file: http://hpaste.org/83472 shouldn't this be magically making my haskell files syntax highlighted and stuff?
15:23:53 <mgsloan> luite: That's one interesting thing about Fay - debugging seems a little more possible.  Even then, though, supporting a debugger like firebug / chrome developer tools will be hard, in the presence of a separate runtime / lazy eval.
15:23:54 <DanBurton> (~/.emacs.d/ghc-mod/ is a symlink to ~/.cabal/share/ghc-mode-xx-xx-whatever/)
15:23:57 <ab9rf> mgsloan: i think the one i ran into was the YHC project
15:26:13 <mgsloan> luite: cool! The RTS is so small!
15:30:00 <luite> mgsloan: the new code generator wasn't quite ready yet for the mloc.js demo unfortunately
15:33:38 <mgsloan> luite: Well, that's the good thing about improving a compiler - can get improvements in older code / releases
15:34:24 <luite> mgsloan: yeah but this one is rather hard to install, would be better if we could've given people a few easy commands to install the thing
15:34:40 <luite> also the game of life thing is extremely slow :)
15:35:17 <DanBurton> bump, can any emacs gurus help me figure out how to get rolling with ghc-mod?
15:36:08 <alpounet> DanBurton, the ghc-mod installation page describes the process, that worked fine for me
15:36:35 <DanBurton> it's not working for me. it's not even complaining that I did something wrong :/
15:36:53 <luite> mgsloan: anyway watch for a cabal installable package after the ghc 7.8.1 release :)
15:37:01 <luite> should even work on 64 bit
15:37:37 <mgsloan> luite: saweet!  using GHC-plugins or something?
15:37:53 <luite> just the GHC API
15:38:02 <luite> but 7.6.1 doesn't support enough cross compilation yet
15:42:52 <Hail_Spacecake> I'm trying to write a haskell program to solve a programming problem involving adding prime numbers
15:43:07 <ab9rf> heh
15:43:11 <ab9rf> yay for prime numbers
15:43:17 <Hail_Spacecake> and I'd like to write it as a recursive function that gets the *next* unprocessed prime number
15:43:32 <Hail_Spacecake> but I don't know if there is a way to do that in haskell other than by keeping track of the index in the function and using !!
15:43:37 <Hail_Spacecake> which seems inelegent
15:43:45 <Hail_Spacecake> I already know about primes
15:43:56 <Hail_Spacecake> er, the function primes in Data.Numbers.Primes
15:44:36 <byorgey> Hail_Spacecake: you can write a function which takes a list of prime numbers, and pattern-match on it to get the first unprocessed prime
15:44:45 <byorgey> Hail_Spacecake: then make a recursive call with the tail of the list.
15:45:03 <byorgey> doPrimeStuff (p:ps) = ... p ... doPrimeStuff ps ...
15:45:24 <ab9rf> preferable without the second set of dots so it'l tail-recurse :)
15:45:38 <ab9rf> er, third set rather sorry
15:45:41 <byorgey> that really doesn't matter
15:45:54 <ab9rf> it doesn't expressively but it might impact performance
15:46:21 <byorgey> actually, tail recursion is usually irrelevant to performance in Haskell, because it's lazy
15:46:28 <ab9rf> wel, true enough
15:46:28 <byorgey> *because of laziness
15:46:49 <ab9rf> Hail_Spacecake: what are you trying to do with primes?
15:47:03 <ab9rf> can you just use the prime list as a generator?
15:47:11 <shachaf> Tail recursion is relevant but in a different way.
15:47:56 <Hail_Spacecake> ab9rf I want to see if the sum of all the primes seen so far is a function of the next prime
15:47:56 <shachaf> Certainly the knee-jerk "make it tail recursive" that you get in some languages doesn't apply.
15:48:03 <Hail_Spacecake> terminate when that function holds
15:48:13 <Hail_Spacecake> and get the next prime and recurse otherwise
15:48:27 <ab9rf> Hail_Spacecake: oh, then you can easily use the prime list as a generator
15:48:32 <shachaf> You should just use the prime number list like byorgey said.
15:48:37 <Hail_Spacecake> ab9rf I'm not sure what you mean when you say use a list as a generator
15:50:28 <ab9rf> i think that's actually doable as a one-liner
15:50:35 <ab9rf> maybe not, but it would be short
15:50:53 <Hail_Spacecake> I'm thinking, I'd start with [2], and do something like prime_computation seenPrimes = if bool_function (sum seenPrimes) nextPrime then seenPrimes else prime_computation (seenPrimes ++ [nextPrime])
15:51:01 <Hail_Spacecake> except I don't know how to get nextPrime
15:51:10 <ab9rf> no, you don't want to carry around the list of previouslyt seen primes
15:51:26 <Hail_Spacecake> because at least as stated, that's a stateful computation
15:51:35 <Hail_Spacecake> and I don't know how to make it unstateful in an idiomatic way
15:51:39 <ab9rf> f s tp:np:pl = if s+tp == np then tp else f s+tp np:pl
15:51:49 * shachaf sighs.
15:52:04 * shachaf goes away.
15:52:31 <ab9rf> the first argument tracks the sum of the primes so far, and the second is the list of the rest of the primes
15:53:07 <ab9rf> you probably need some parenthesis in there to make it syntatically valid
15:53:35 <ab9rf> basically each recursion shifts one prime from the right argument to the left
15:53:45 <ab9rf> the recursion aborts when the test is true
15:53:45 <Hail_Spacecake> how does haskell know how to pattern match someting like tp:np:pl against the endless list that primes outputs?
15:54:16 <ab9rf> Hail_Spacecake: you'd kick off the recusion with f 0 primes
15:54:49 <c_wraith> Hail_Spacecake: it breaks it down, bit by bit. match the first constructor against (:).  Match the second argument of the (:) constructor against the patter (np:pl)
15:55:02 <crl> @hoogle handle
15:55:02 <lambdabot> System.IO data Handle
15:55:03 <lambdabot> GHC.IO.Handle data Handle
15:55:03 <lambdabot> Control.OldException handle :: (Exception -> IO a) -> IO a -> IO a
15:55:09 <ab9rf> that def'n is nonexhaustive but it will never fail to match because primes is an endless list
15:55:13 <Hail_Spacecake> c_wraith so that will necessarily match tp = 2, np = 3, pl = the rest of the list?
15:55:23 <Hail_Spacecake> at least in the first recursive step?
15:55:33 <crl> :t  System.IO.handle
15:55:34 <lambdabot> Not in scope: `System.IO.handle'
15:55:37 <crl> :t  handle
15:55:38 <ab9rf> Hail_Spacecake: the first time, yes.  the next recurions it'll match tp->3, np->5, pl->[7,...]
15:55:39 <lambdabot> Not in scope: `handle'
15:55:59 <Hail_Spacecake> ah, okay
15:56:00 <Hail_Spacecake> thanks
15:56:13 <ab9rf> you could just match p:rest and use (head rest) in the body, but if i'm going to pattern match....
15:57:19 <ab9rf> Hail_Spacecake: using pattern matching on x:xs is a fairly standard idiom to walk a list
15:57:43 <ab9rf> obviously you dn't have ot use x or xs as the pattern variables
15:58:26 <Hail_Spacecake> right
15:58:29 <Hail_Spacecake> okay, that makes sense
15:58:30 <Hail_Spacecake> thanks
16:15:47 <DanBurton> sigh, oh well I guess I can settle for haskell-mode instead of ghc-mod :P
16:16:21 <kini> @seen gwern
16:16:22 <lambdabot> Unknown command, try @list
16:16:27 <kini> hm?
16:25:31 <crdueck> @let f (x:xs) = (:) <$> ?g x <*> f xs
16:25:31 <lambdabot>   Parse error in expression: (:) <$>
16:25:39 <crdueck> @let f (x:xs) = (:) <$> (g?) x <*> f xs
16:25:40 <lambdabot>  <local>:6:22: Not in scope: `?'
16:25:41 <lambdabot>  
16:25:41 <lambdabot>  <local>:6:31:
16:25:41 <lambdabot>      Ambiguous occurrence `...
16:25:49 <crdueck> @let f (x:xs) = (:) <$> (?g) x <*> f xs
16:25:50 <lambdabot>  <local>:6:21: Not in scope: `?'
16:25:50 <lambdabot>  
16:25:50 <lambdabot>  <local>:6:31:
16:25:50 <lambdabot>      Ambiguous occurrence `...
16:25:59 <crdueck> ...
16:27:42 <crdueck> @let f g (x:xs) = (:) <$> g x <*> f xs
16:27:44 <lambdabot>  <local>:6:30:
16:27:44 <lambdabot>      Ambiguous occurrence `f'
16:27:44 <lambdabot>      It could refer to either `L...
16:27:52 <crdueck> @let f g (x:xs) = (:) <$> g x <*> f g xs
16:27:53 <lambdabot>  <local>:6:30:
16:27:53 <lambdabot>      Ambiguous occurrence `f'
16:27:53 <lambdabot>      It could refer to either `L...
16:29:36 <crl> what do you try
16:31:39 <crdueck> crl: I just wanted to inspect the type, I think that recursion is a traverse in disguise
16:33:53 <crl> but I'm sure it has to do with types
16:34:05 <crl> i'm not sure*
16:34:32 <crdueck> :t let f (x:xs) = (:) <$> undefined x <*> f xs in f
16:34:34 <lambdabot> Applicative f => [t] -> f [a]
16:34:39 <crdueck> :t traverse
16:34:41 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:34:51 <crdueck> :t let f g (x:xs) = (:) <$> g x <*> f xs in f
16:34:52 <lambdabot>     Couldn't match expected type `[a0]' with actual type `[t0] -> [a0]'
16:34:52 <lambdabot>     Expected type: [t0] -> [a0]
16:34:52 <lambdabot>       Actual type: [t0] -> [t0] -> [a0]
16:34:56 <crdueck> :t let f g (x:xs) = (:) <$> g x <*> f g xs in f
16:34:57 <lambdabot> Applicative f => (t -> f a) -> [t] -> f [a]
16:35:31 <crl> i see
16:36:24 <crl> :t f where f x = x
16:36:25 <lambdabot> parse error on input `where'
16:36:48 <Philippa_> where's the sensible place to ask "I have a type-level programming task that's doing my head in, how do I fix it?" these days, anyway?
16:37:05 <byorgey> crl: yes, that's precisely the definition of traverse for []
16:37:40 <crdueck> :t traverse `asTypeOf` let f g (x:xs) = (:) <$> g x <*> f g xs
16:37:42 <lambdabot> parse error (possibly incorrect indentation)
16:37:44 <crdueck> :t traverse `asTypeOf` let f g (x:xs) = (:) <$> g x <*> f g xs in f
16:37:45 <lambdabot> Applicative f => (a -> f b) -> [a] -> f [b]
16:37:49 <crl> @hoogle traverse
16:37:50 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:37:50 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
16:37:50 <lambdabot> Control.Parallel.Strategies parTraverse :: Traversable t => Strategy a -> Strategy (t a)
16:38:12 <crl> isn't traverse redundant then?
16:39:24 <crl> you could use sequence maybe also
16:39:26 <byorgey> crl: redundant in what context?
16:40:46 <crl> forget it sequence is not recurrent at all
16:41:00 <crl> doesn't allow recurrence*
16:41:29 <crl> over the sequenced list
16:41:41 <crl> im saying shit
16:43:20 <byorgey> crl: traverse and sequenceA from Data.Traversable are equivalent, in that you can implement each in terms of the other
16:43:38 <byorgey> (sequenceA is a generalization of sequence)
16:47:54 <crl> :t let f g l@(x:xs) = fix $ \x -> g x <*> f g xs in f
16:47:56 <lambdabot> Applicative f => (f a -> f (a -> a)) -> [t] -> f a
16:48:11 <crl> (random)
16:48:42 <crl> not the right type at the end
16:49:20 <monochrom> perhaps "fix" is spurrious
16:49:44 <crl> fix is to avoid i know
16:49:57 <crl> except for obvious loop
16:51:11 <monochrom> no, I do not mean that. I mean you already have the recursive call "f g xs", so why do you add "fix"
16:51:36 <crl> indeed
16:52:56 <lispy> Philippa_: Perhaps stackoverflow?
16:54:19 <crl> :t let f g (x:xs) = fix $ \(x:xs) -> g xs  in f
16:54:21 <lambdabot> ([t1] -> [t1]) -> [t] -> [t1]
16:54:24 <Philippa_> lispy: *sigh* quite possibly, yeah
16:54:40 <Philippa_> I have a blatant case of "if I *actually* had type-level prolog this'd be just fine"
16:55:28 <Philippa_> it's also one that probably should've been written already, but that's always complicated
16:56:52 <lispy> Philippa_: Are you hoping to avoid stackoverflow? Haskell-Cafe might be a good alternative but I know I don't read it anymore. /r/haskell might work but it's not good for Q/A format.
16:57:09 <lispy> (haskell-cafe is too high volume to stay up on)
16:57:12 <Philippa_> *nod*
16:57:42 <Philippa_> yeah, basically I'm hoping for somewhere I can grab people with sufficient clue and describe the problem sometime I'm awake enough to put together the right 10-20 lines of code
16:58:01 <DanBurton> I hear #haskell irc is quite good >.>
16:59:38 <Philippa_> DanBurton: yeah. Am having problems getting myself and everyone else in sync, guess I should put those 10-20 lines together elsewhere
17:00:07 <DanBurton> School of Haskell?
17:00:23 <DanBurton> @where soh
17:00:23 <lambdabot> I know nothing about soh.
17:01:01 <DanBurton> @where+ soh School of Haskell https://haskell.fpcomplete.com/school
17:01:02 <lambdabot> Okay.
17:01:07 <Philippa_> heh. Well, the problem is basically: I want the equivalent of tagged monad transformers, for stacks of functors built using a type-level functor composition operator
17:01:12 <fragamus> as long as you don't ask about comonads
17:01:29 <Philippa_> writing the instances that deal with the composition operator is proving tricky
17:01:48 <Philippa_> (and I'm not entirely sure I have enough parms in the class for them to work)
17:01:55 <DanBurton> "tagged" monad transformers?
17:02:03 <Philippa_> hi edwardk. I'll give you one guess which set of instances I'm still having trouble with?
17:02:22 <edwardk> no idea
17:03:26 <Philippa_> edwardk: fair enough. I have a "Label" type that wraps functors, a functor composition type operator, a typeclass that's supposed to provide "map to labelled functor" and a disaster when the instances for :. (the type composition operator) come around
17:03:35 <crdueck> @pl \a b -> fmap (const b) a
17:03:35 <lambdabot> flip (fmap . const)
17:03:40 <Philippa_> also, the code's on another machine and this one doesn't dropbox properly :-(
17:03:47 <edwardk> wanting a traversal/setter/lens of some sort?
17:04:26 <Philippa_> I'm not thinking in terms of those operations, but they probably wouldn't do any harm
17:18:33 <feliperosa> hum.. could someone help me understanding memoization? I kinda get it, but not as I would like. I was trying to understand the memoized fibonacci in the wiki, but I don't get how it works...
17:22:47 <luca> Looking for a nice way to do eg: [1,2] and 2 goes to [[1,1], [1,2], [2,1], [2,2]]. [1,2,3] and 3 goes to [[1,1,1], [1,1,2], [1,1,3], [1,2,1], [1,2,2] .... ]
17:23:07 <ivanm> luca: you want combinations with duplicates?
17:23:11 <luca> permutations
17:23:23 <ivanm> oh, permutations of the given length?
17:23:33 * ivanm is trying to work out why the second argument
17:23:57 <luca> well i suppose its not even a permutation, it's like counting where the possible digits are in the first array, and number of digits is second argument :P
17:24:10 <luca> so [0,1] and N would give you all the N bit binary values
17:24:14 <yitz> how did 3 get in there?
17:24:15 <lazard> > replicateM 2 [1,2]
17:24:16 <lambdabot>   [[1,1],[1,2],[2,1],[2,2]]
17:24:20 <luca> [0,1,2] N would give all the N digit ternary values
17:24:35 <ivanm> > replicateM 3 [1,2,3]
17:24:37 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2...
17:24:42 <luca> thanks
17:31:21 <crl> are threads garbage collected? http://hpaste.org/83474 i have this code, where i can't killThread on line 19 of course, but i can't know when to kill it
17:32:09 <johnw> crl: after the hClose h, the thread should clean itself up
17:32:33 <nejucomo> :t replicateM
17:32:34 <lambdabot> Monad m => Int -> m a -> m [a]
17:33:13 <crl> johnw: k, i'll try possible memory leaks to see
17:34:35 <nejucomo> > replicateM 3 [0,1]
17:34:36 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
17:35:17 <johnw> so, replicateM 3 [0,1] is like: do { x <- [0,1]; y <- [0,1]; z <- [0,1]; return [x,y,z] }
17:36:15 <crl> the program's memory slowly leaks a little, but nothing bad
17:36:49 <crl> I should consider hacing a bounded thread pool maybe
17:37:03 <crl> but it's harder to do
17:37:26 <nejucomo> > sequence 3 [0,1]
17:37:28 <lambdabot>   Could not deduce (GHC.Num.Num [[t0] -> a])
17:37:28 <lambdabot>    arising from the ambiguity ch...
17:37:37 <nejucomo> :t sequence
17:37:38 <lambdabot> Monad m => [m a] -> m [a]
17:37:54 <nejucomo> :t sequence [[0,1],[2]]
17:37:54 <johnw> crl: if I understand correctly, your loop' function is infinitely recursive, where each level of the recursion has a catch handler; that is where your "leak" is coming from
17:37:55 <lambdabot> Num a => [[a]]
17:37:59 <nejucomo> > sequence [[0,1],[2]]
17:38:01 <lambdabot>   [[0,2],[1,2]]
17:38:29 <zebr> hey all. i've just installed lambdabot; how can i disable certain plugins? or else, where should i ask? :p
17:39:02 <nejucomo> > do { x <- [0,1]; y <- [2]; return [x,y]}
17:39:03 <lambdabot>   [[0,2],[1,2]]
17:39:25 <nejucomo> > do { x <- [0,1]; y <- [2]; [x,y]}
17:39:26 <lambdabot>   [0,2,1,2]
17:39:29 <crl> johnw: hmm will fill the catch to check if that's right
17:39:52 <notthemessiah> algebraic data types are blowing my mind. I just found for myself that -log(1-x) is a list with periodic boundary conditions for some data type x
17:40:16 <notthemessiah> cause if you take the series expansion around zero, terms like (x^3)/3 represent [a,b,c]=[b,c,a]=[c,a,b]
17:41:09 <JoeHazzers> i think Firefox's PDF viewer doesn't like Haskell
17:41:11 <JoeHazzers> http://i.imgur.com/gl1Ppne.png
17:41:53 <luite> hehe
17:42:02 <luite> i guess it's some issue with the font subsetting
17:42:18 <JoeHazzers> it looks like some sort of encoding error
17:42:19 <crl> johnw: actually it never enter it
17:42:33 <johnw> crl: but the thunk for it is created
17:42:47 <johnw> the second argument to catch is unevaluated, but is represented on the heap
17:43:29 <johnw> i'm not sure if the GC gets rid of it after the call to next `catch` ... is done and it moves to the next step of the iteration
17:43:35 <johnw> i'd do heap profiling at this point if I were you
17:43:45 <johnw> let it run for a few minutes, see where the allocations are coming from
17:44:14 <yitz> never had a chance to ask saunders mac lane before he passed away if he knew haskell curry. but i just found an article mac lane wrote where he mentions curry.
17:46:12 <yitz> he notes that curry was last previous american who studied mathematics at G√∂ttingen before him
17:46:23 <crl> you're certainly right, but ven removing it with
17:46:43 <crl> loop' s = (next s ) >> loop' s, leads to small leaks
17:48:37 <crl> johnw: but well i'll read the chapter on profiling
17:49:08 <amindfv> callenbot: i missed the conversation earlier, but Scotty isn't really bitrotted
17:49:28 <amindfv> changes have slowed, but in a way that's good for such a small framework
17:49:39 <amindfv> there's a commit from less than a month ago, on github
17:52:18 <yitz> the way that mac lane's category theory sprang directly from the philosophies of hilbert, emmy noether, and hermann weyl is well documented. it's not hard to see how curry's combinator theory came out of the same kind of thinking.
17:52:48 <yitz> so the connection between functional programming and category theory is no coincidence.
17:56:08 <EvanR> whats the working way to make your program only able run one at a time
17:56:16 <EvanR> one instance
17:56:31 <EvanR> "sorry the program is already running"
17:56:38 <croikle> lock file somewhere?
17:57:55 <crl> profile file
17:59:02 <EvanR> profile pro
17:59:06 <crl> .config/myprog
18:01:58 <cdntr> I understand correctly that haskellmode-vim does not support 'inline' error display?
18:03:18 <EvanR> croikle: ive done this kind of thing before with lock files, but i found it difficult to unlock the lock under abnormal program terimination of various kinds
18:04:34 <EvanR> oh i got it
18:04:41 <EvanR> listen on a given port
18:04:57 <croikle> hm, nice
18:05:01 <EvanR> so either the process is already running and you fail, or some other program is using that port, too bad
18:05:38 <EvanR> a crashed server (eventually) will not tie up that port
18:06:07 <EvanR> luckily my program was going to be using a server socket anyway
18:10:26 <cdntr> Is there some widely used/accepted/liked haskell code styleguide?
18:10:38 <johnw> yes
18:10:49 <johnw> https://github.com/tibbe/haskell-style-guide
18:11:24 <cdntr> That is the one that I found. So that is widely used?
18:13:07 <arkeet> @where style
18:13:08 <lambdabot> http://urchin.earth.li/~ian/style/haskell.html http://snapframework.com/docs/style-guide
18:13:10 <arkeet> cdntr: ^
18:13:12 <crl> dam, i've a line of 120 chars
18:13:34 <johnw> i don't know about "widely", but my company uses it
18:14:06 <cdntr> What's your company if I may ask?
18:16:46 <crl> a company working with haskell, the dream
18:17:32 <johnw> cdntr: FP Complete
18:17:56 <cdntr> Ah!
18:18:17 <liyang> johnw: how many hires have you now?
18:18:29 <johnw> liyang: i think we're around 10 people
18:18:35 <liyang> johnw: snap!
18:18:42 <arkeet> yesod!
18:19:03 <applicative_> thats awesome johnw
18:19:04 <liyang> snoyod!
18:19:11 <arkeet> lol
18:19:13 <EvanR> read that as "hi-rez"
18:21:17 <johnw> applicative_: thanks!  our School of Haskell had its official release today
18:21:21 <johnw> https://haskell.fpcomplete.com/school
18:21:33 <TravisD> johnw: Do you have any free Haskell resources?
18:21:39 <johnw> yep, at that link
18:21:40 <Mathnerd314> only 10?!! there are 991 people in this channel, so that's a <1% conversion rate
18:21:41 <TravisD> (perhaps they're all free)
18:21:46 <johnw> and it's just beginning
18:21:58 <johnw> Mathnerd314: Well-Typed is also on this channel, and Galois
18:22:08 <johnw> between the three of us that's more like 50 peopel
18:22:38 <Mathnerd314> hmm, why can't you three merge? different goals?
18:22:48 <TravisD> Great :) I understand the language basics and I'm on my way to understanding the category theoretic underpinnings, but I'm still finding it very difficult to write the code that I need to write in Haskell
18:23:32 <johnw> TravisD: I had a similar experience at the beginning
18:23:45 <johnw> but once it starts to flow, it flows quite enjoyably :)
18:24:07 <TravisD> johnw: Any tips for getting over the initial hurdle?
18:25:26 <crl> :t ((1+) .)
18:25:28 <lambdabot> (Functor f, Num b) => f b -> f b
18:25:30 <johnw> pick a fun project you want to do, rather than needing to start with something "meaningful" or "clever".  Even re-implementing something you've already done in another language, if the problem domain was enjoyable to you.  Having a fun project to hack on counter-balances the pain you encounter having to grapple with type errors, new concepts, foreign paradigms, etc.
18:25:46 <Mathnerd314> hmm: http://flyingfrogblog.blogspot.com/2008/08/haskells-virginity.html
18:26:04 <Mathnerd314> (not the post, but the stuff after)
18:26:05 <crl> :t ((1+) .) . (2+)
18:26:07 <lambdabot> (Functor f, Num (f b), Num b) => f b -> f b
18:26:32 <TravisD> johnw: I have some experiments to run whose results I'm very interested in and I want to implement them in Haskell. I keep second-guessing my design choices to the point of almost zero productivity, though :P
18:27:11 <sproingie> the more expressive the language, the higher the likelihood of analysis paralysis
18:27:52 <Mathnerd314> TravisD: jsut write the experiments, then write the code that implements them
18:28:08 <Mathnerd314> I find that sed is often a helpful tool
18:28:30 <TravisD> Mathnerd314: that sounds like some good advice
18:28:36 <Mathnerd314> depending on the problem I can s/// my way to working Haskell
18:29:24 <Mathnerd314> admittedly, the spec I started out with was not the greatest :p
18:30:38 <johnw> TravisD: writing bad designs and then finding out why is more valuable than writing good designs but not completely knowing why
18:30:58 <TravisD> johnw: Yeah, I've been trying to convince myself to just go with my first ideas and wait for them to break
18:31:04 <TravisD> johnw: It's just hard to /actually/ do that
18:31:37 <monochrom> new concepts and foreign paradigms are not painful to me. they are joyful.
18:32:20 <TravisD> I love new concepts and foreign paradigms. They are so easy.
18:32:26 <johnw> haha
18:32:36 <johnw> see, you are veteran of #haskell already :)
18:33:09 <TravisD> heh
18:33:13 <monochrom> type errors may be not joyful, but not painful either because I don't shoehorn crazy misguided ideas into a simple type system. and I don't mistake type class for type
18:34:06 * hackagebot xdot 0.2.3 - Parse Graphviz xdot files and interactively view them using GTK and Cairo  http://hackage.haskell.org/package/xdot-0.2.3 (DennisFelsing)
18:39:06 * hackagebot ghc-vis 0.6.1 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.6.1 (DennisFelsing)
18:42:58 <applicative_> the school of haskell site is looking pretty good.  It freaked me out a little when it announced the type of the expression my cursor was on.
18:43:02 <Sgeo> Is GeneralizedNewtypeDeriving safe without other extensions?
18:43:29 <TravisD> applicative_: Woah, I didn't notice that
18:43:49 <byorgey> Sgeo: you cannot write a crashing program without other extensions.  But you can mess up internal invariants of data structures, e.g. Map.
18:44:18 <applicative_> Sgeo: well, you cant use it together with {-#LANGUAGE Safe#-}
18:45:17 <danharaj> Is there really a performance penalty for writing a newtype instance by hand instead of deriving it?
18:45:33 <danharaj> Even if you {-# INLINE #-} everything?
18:46:01 <applicative_> that was the complaint one had heard before, that I can basically extract the hidden constructors by judicious deriving
18:47:05 <byorgey> danharaj: there may be.
18:47:08 <applicative_> danharaj do people say there is a 'performance penalty'?
18:47:42 <danharaj> applicative_: it's mentioned sorta in the GHC manual: http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#newtype-deriving
18:48:08 <applicative_> of course in other cases there can be a performance penalty for letting ghc derive instances, didn't this come of with DeriveFunctor I think
18:48:16 <m0g> anyone would have a simple example of how to memoize a function with data-memocombinators within a specific range? The basic Memo.integral usage is documented but not the rest, and I get nowhere
18:50:04 <danharaj> m0g: arrayRange?
18:50:38 <m0g> danharaj: yup, I don't get how to use it. It's certainly obvious but I get nowhere :(
18:50:55 <danharaj> arrayRange (lb, ub) foo
18:52:00 <m0g> yup that's it. I was trying to use the constructor RangeMemo directly. Thanks :)
18:57:20 <hpaste> lamefun pasted ‚ÄúHow to get rid of this ugliness?‚Äù at http://hpaste.org/83478
18:57:58 <ivanm> lamefun: what ugliness?
18:58:02 <danharaj> lamefun: Word ~ Either Verb Noun
18:58:13 <danharaj> Clause ~ (Noun, Verb)
18:58:54 <lamefun> I'll have adjectives, adverbs, etc. later
18:59:15 <ivanm> so which actual ugliness do you want to get rid of?
18:59:55 <lamefun> type Word = Noun ... | Verb ... --- can I do that and still be able to use Noun and Verb separately?
19:00:47 <ivanm> you can't
19:00:55 <danharaj> You can't do that because you are already using "Noun" as a data constructor.
19:00:55 <ivanm> not if you want to be able to distinguish between them
19:01:08 <ivanm> danharaj: he used type there
19:01:14 <danharaj> oh yes. that is also wrong.
19:01:24 <danharaj> However if you defined data Noun = N ..., then you could use Noun as a data constructor for Word.
19:01:35 <danharaj> So uh, try to come up with nice names?
19:01:39 <ivanm> lamefun: one possibility (which is probably not what you want) is to define a class, and then have an existential (maybe using GADTs) for Word
19:02:54 <mgsloan> one terrible possibility would be "type (||) a b = Either a b"
19:03:08 <ivanm> mgsloan: he wants to add more word types later on
19:03:15 <ivanm> which means he'd have nested Eithers
19:03:20 <ivanm> which is probably not what he wants :p
19:03:25 <mgsloan> right :)
19:04:25 <mgsloan> still, it does sound like he wants anonymous sums
19:04:40 <ivanm> yup
19:05:23 <applicative_> type Word = Either Verb Noun
19:05:32 <applicative_> oh I see
19:07:22 <liyang> You could make Verbs and Nouns (and Adjectives and Adverbs and Prepositionals) instances of a Word typeclass‚Ä¶
19:07:42 <cdntr> Haskell beginner: How can I express in a pattern match that I want something of the form (x:y:z), where I'm matching the whole thing against [a] and want x and z to be the first and last element, respectively, and y to be the element(s) in the middle?
19:07:59 <ivanm> liyang: except he has a function of type Word -> [Word]
19:08:05 <applicative_> cdntr: you can't
19:08:15 <ivanm> so assuming he doesn't want to restrict that to the same _type_ of word, you'd need an existential or something then
19:08:29 <applicative_> cdntr: I mean it isn't a pattern
19:08:39 <cdntr> applicative_: Mind elaborating?
19:08:57 <applicative_> cdntr: you could do case (xs,reverse xs) of (first:rest, last:others)
19:08:59 <ivanm> you could use PatternGuards: z <- last xs, y <- init $ tail xs
19:09:15 <applicative_> for example
19:09:18 <ivanm> applicative_: that doesn't get that "y" is all the rest
19:09:26 <Cale> cdntr: (x:y:z) means the list whose first two elements are x and y and where z is the rest of the list
19:09:47 <applicative_> right, it doesnt, I thought cdntr was just wanting to 'match' head and last
19:09:52 <Cale> cdntr: accessing the "end" of a list is not a natural thing to do -- even when there is an end
19:10:13 <ivanm> Data.Sequence sounds like a better fit
19:10:17 <Cale> (i.e. it will be costly, while everything you can do with pattern matching is O(1))
19:10:20 <TravisD> Is there a convention for ensuring that function names in record-style data types are unique?
19:10:24 <ivanm> (if you want access to the end)
19:10:26 <cdntr> hm, ok, I guess that makes sense, Cale
19:10:31 <ivanm> TravisD: not really
19:10:45 <Cale> cdntr: Some lists have no end, such as [1..]
19:11:03 <cdntr> Cale: Yeah
19:11:04 <Cale> (even though that has elements, it has no last element)
19:11:44 <applicative_> cdntr: basically if you write a function [a] -> Maybe (a,[a],a) you can use that to match, but how unpleasant.
19:12:14 <cdntr> OK :-)
19:12:51 <nh2> parsec really comes with a full lexer for Haskell but cannot parse me a Double?
19:13:20 <applicative_> that idea would give Nothing for singletons ; so maybe it's not so great
19:13:33 <cdntr> I was trying to implement an exercise function (isPalindrome :: [a] -> Bool) that way, but `isPalindrome xs = xs == reverse xs` also does the trick. Does that actually create a new list internally, or does that just traverse it backwards?
19:13:55 <ivanm> creates a new list
19:14:10 <byorgey> cdntr: lists are singly-linked, and hence cannot be traversed backwards.
19:14:31 <cdntr> byorgey: Ah!
19:18:42 <monochrom> put it in an array. then you can traverse one array both directions, and never compare an element twice. but now you have to create an array.
19:19:08 <monochrom> perhaps the original problem should start with an array, not a list
19:21:47 <monochrom> meanwhile, in a C course, an exercise asks to delete an element from a set, but the set is an array with no particular element order
19:22:46 <applicative_> nh2: attoparsec has some pre-cut parsers for that
19:23:32 <Sgeo> How does School of Haskell work
19:23:38 <Sgeo> Where does the code get executed?
19:23:39 <monochrom> why teachers think up clever ways to use data structures in the worst ways, I do not understand.
19:24:35 <applicative_> Sgeo: I don't think it's happening in your browser...
19:25:13 <Sgeo> @hoogle IO FilePath
19:25:14 <lambdabot> Did you mean: :: IO FilePath
19:25:14 <lambdabot> No results found
19:25:19 <Sgeo> @hoogle :: IO FilePath
19:25:19 <lambdabot> System.Posix.Terminal getControllingTerminalName :: IO FilePath
19:25:19 <lambdabot> System.Directory getCurrentDirectory :: IO FilePath
19:25:19 <lambdabot> System.Directory getHomeDirectory :: IO FilePath
19:25:38 <applicative_> though chris done did manage to get hugs converted to javascript ...
19:26:05 <Sgeo> @hoogle FilePath -> String
19:26:05 <lambdabot> System.FilePath.Windows takeBaseName :: FilePath -> String
19:26:05 <lambdabot> System.FilePath.Posix takeBaseName :: FilePath -> String
19:26:05 <lambdabot> System.FilePath.Windows takeExtension :: FilePath -> String
19:26:11 <Sgeo> :/
19:26:17 <Sgeo> Is FilePath a Show?
19:26:27 <monochrom> FilePath = String
19:26:41 <Sgeo> "/home/fpuser/isolation-runner-work/idesession/data.175"
19:27:02 <shachaf> preflex: seen johnw
19:27:03 <preflex>  johnw was last seen on #ghc 14 minutes and 26 seconds ago, saying: I saw that; we're just used a compiler that's a patched version of 7.4.2
19:27:04 <Sgeo> I could have written the code I used to find that better
19:29:20 <johnw> shachaf: Hi
19:31:47 <shachaf> hi
19:32:54 <shachaf> I want to try to make a schoolfohaskell thing with a lot of exercises.
19:33:02 <johnw> excellent, can I hope?
19:33:04 <johnw> help?
19:34:16 <shachaf> I'm wondering whether you can have code shared between code blocks (in particular code typed in from earlier blocks used in later blocks), and whether you can have shorter code blocks that aren't a full program.
19:34:32 <shachaf> E.g. without main, just for type-checking and maybe some simple tests.
19:34:50 <byorgey> +1 for code shared between code blocks.
19:35:01 <johnw> I don't think we do shared code blocks yet, but I will add a task for it now
19:35:04 <shachaf> I know about the thing with the partly-hidden code block but it doesn't seem to work very well for what I want.
19:35:07 <byorgey> one simple idea is to have a boolean flag on code blocks
19:35:24 <byorgey> if True, the code block must not have a main and will be in scope for all other code blocks
19:35:26 <shachaf> Really, the way I was thinking of this was like a .lhs file, except interactive.
19:35:32 <johnw> yeah
19:35:33 <byorgey> if False, it's a standalone code block (with main)
19:35:43 <johnw> we actually discussed something very similar to that about two days ago, shachaf
19:35:53 <shachaf> (In fact I started writing something as a .lhs file a while ago -- I just thought I'd try moving it to this format.)
19:36:47 <luite> hm
19:37:03 <johnw> yes, I think we should support something like this too; I've created an issue for the next version
19:37:42 <shachaf> hmuite
19:40:42 <shachaf> johnw: Also, the red X makes me think an error happened every time I see it.
19:40:57 <shachaf> eSome other colouur would be better, I think.
19:41:04 <shachaf> s/.//
19:41:05 <johnw> shachaf: use the Feedback link in the upper-right
19:41:10 <johnw> we do review them all
19:41:42 <TravisD> johnw: how many views do you get per day on average?
19:42:06 <johnw> TravisD: good question, I really have no idea
19:42:21 <shachaf> "Rate this page*", "What do you like?*", "What needs to be improved?*" doesn't lend itself to one-off reports of little things I come across.
19:42:32 <johnw> shachaf: ok, I'll enter reports for you
19:42:56 <johnw> i agree, the red X is disconcerting
19:45:06 <johnw> shachaf: I added: "Note that he is trying to port some real literate Haskell code to our tutorial format so that he can create some tutorials for us, so I consider his input very "real world", and indicative of things we might hear from existing authors who want to host their articles on our system."
19:45:45 <shachaf> FSVO "real"
19:45:59 <johnw> well, realer than just toying around :)
19:46:00 <shachaf> I just have some snippets.
19:46:20 <johnw> yeah, but I bet you're going to regale the world with exercises involving Profunctors any day now
19:46:29 <shachaf> Eh.
19:46:32 <shachaf> profunctors are so easy
19:46:57 <johnw> I want to write an Endo mondo for profunctors, so that you get invertible composition
19:47:04 <johnw> monoid*
19:47:16 <johnw> although I doubt what I said even makes sense
19:47:29 <byorgey> "Endo mondo", sounds like a dance
19:47:57 <shachaf> If that doesn't work, you should try for convertible imposition.
19:48:49 <shachaf> johnw: Also, if you have an explanation-thing containing multiple chapter-things, can you not re√∂rder them?
19:49:18 <johnw> you cannot?  I think byorgey is writing a multiple chapter-ting
19:49:29 <shachaf> Can you?
19:49:33 <byorgey> you can
19:49:39 <shachaf> I tried to and didn't figure it out.
19:49:51 <shachaf> Hmm, maybe I should log in so I can back up my claims.
19:50:05 <byorgey> shachaf: choose 'arrange' from the little gear-menu-thingy in the upper right
19:51:08 <shachaf> Oh, I see.
19:51:11 <johnw> shachaf: about this kind of stuff, btw, mgsloan is the man to talk to
19:51:17 <shachaf> I didn't see that little gear-menu-thingy.
19:51:25 <johnw> i'm more "in the trenches", while he handles the UI stuff
19:51:36 <mgsloan> Yeah, the red x is totally my fault :)
19:51:41 <shachaf> I saw the other one.
19:51:57 <shachaf> mgsloan is involved with this too now?
19:52:06 <johnw> he is!
19:52:07 <mgsloan> and the redundancy of the gear menu on every tutorial will be fixed soon
19:52:13 <byorgey> shachaf: everyone works for FP Complete now, didn't you get the memo?
19:52:42 <mgsloan> yup, for about a month.  This is why I haven't gotten around to the lens TH stuff yet!
19:52:51 <shachaf> byorgey: Don't tell me you are too!
19:53:03 <byorgey> shachaf: OK, I won't tell you
19:53:17 <shachaf> Oops.
19:53:20 <shachaf> Now I'll never find out.
19:53:59 <byorgey> no, I still have a PhD to finish =)
19:54:17 <adu> it there a common name for not$not?
19:54:21 <mgsloan> shachaf: But yeah, that's very good feedback, reworking the snippet buttons was something that kept on getting superseded by other priorities
19:54:28 <shachaf> adu: Type error?
19:54:29 <byorgey> I just passed my dissertation proposal today!  So I am celebrating by hacking on diagrams.
19:54:39 <mgsloan> byorgey: Congrats!!
19:54:53 <byorgey> mgsloan: thanks!
19:54:53 <mgsloan> what a productive way to celebrate!
19:55:01 <shachaf> Are you finally going to add commutativity support?
19:55:13 <johnw> mgsloan: it might be cool to allow screencasts that have "related' code down below for related time segments.  That is, the segments are paged, and the page flips as you get to that point in the video
19:55:16 <byorgey> yes, we have a very awesome super-secret project coming out soon
19:55:29 <byorgey> shachaf: hehe, I may work on arrows soon
19:55:31 <johnw> byorgey: congratulations!!!
19:55:40 <byorgey> thanks johnw!
19:56:19 <mgsloan> johnw: That would be cool!  But what if someone starts editing a snippet, and the video moves on, making it disappear?
19:56:24 <shachaf> OK, now I can bug mgsloan about things instead.
19:56:36 <mgsloan> shachaf: sounds good! :)
19:56:41 <johnw> they could click "prev" to go back a page.  Or, the page would not flip if the edit box had focus
19:56:52 <johnw> in that case, the video would automatically pause
19:57:02 <mgsloan> we definitely appreciate feedback, and I'm open to discussing design issues / possible features
20:06:53 <ivanm> so the documentation for Data.Vector.modify says that the operation will be performed in place if safe to do so
20:06:59 <ivanm> how can I verify if that's happening or not?
20:07:45 <ivanm> in one test I've got I'm doing a fold with the folding function using modify, but AFAICT from how long it takes it's re-allocating a new Vector each time :/
20:11:34 <johnw> isn't there an Unsafe Vector module?
20:12:17 <ivanm> johnw: nope, there was talk of one
20:12:34 <ivanm> but IIRC rl's opinion was that vector's "unsafe" /= GHC's "unsafe"
20:12:49 <johnw> ah, maybe I was thinking about Data.Array
20:13:02 <shachaf> "unsafe" means whatever you want it to.
20:13:30 <ivanm> I know there's unsafeFreeze, etc. but what I was trying to find out was if chained modify calls did indeed do it in-place
20:13:44 <ExternalReality> ivanm: have you looked at the code for modify in Data.Generic.Vector.Net
20:13:47 <ExternalReality> *New
20:13:53 <ivanm> nope
20:14:18 <ivanm> modify f (New p) = New (do { v <- p; f v; return v })
20:15:21 <ivanm> unless the RULES are doing something fancy, doesn't look in-place to me...
20:15:42 <ivanm> (as in, I can't find any checks to see if it's "safe to do so")
20:17:08 <ivanm> or is that what Data.Vector.Generic.clone tries to do?
20:18:25 <shachaf> Given newtype Is a b = Is (forall p. p a -> p b), can you write foo :: Is Char Bool -> a?
20:18:30 <ivanm> so unsafeCopy's documentation says that there's no check for whether the two vectors have the same length... yet there seems to be such a check in the source :p
20:19:20 <ivanm> shachaf: are you trying to write a new unsafeCoerce somehow? :p
20:19:40 <shachaf> ivanm: No.
20:19:56 <ivanm> then where does the a come from in your type for foo?
20:20:09 <shachaf> From the implicit forall.
20:20:22 <shachaf> I'm fine with Is Char Bool -> Void, if you prefer that.
20:20:43 <ivanm> ahhh, OK, gotcha
20:20:48 * ivanm has no idea though
20:25:48 <shachaf> preflex: seen luqui
20:25:48 <preflex>  luqui was last seen on #haskell 8 days, 7 hours, 20 minutes and 14 seconds ago, saying: What module do people use to get a standard functor vocabulary, like (f :+: g) a, Fix f a, etc.
20:29:28 <shachaf> When will Haskell support moving quantifiers all the way to the left?
20:29:36 <shachaf> I wnt "forall a. id :: a -> a"!
20:29:53 <ivanm> shachaf: make a suggestion to libraries@? :p
20:30:38 <shachaf> ivanm: Are you making fun of the suggestions I've been making to libraries@?
20:30:44 <ivanm> nope
20:31:03 * ivanm can't recall off the top of his head any suggestions shachaf has made to libraries@
20:34:01 <johnw> ivanm: he's been talking about gcast and type equality
20:34:08 <ivanm> ahhhh
20:34:10 <ivanm> forgot about that
20:36:51 <shachaf> I've made a few posts to libraries@, some of which have been silly.
20:40:49 <hpaste> byorgey pasted ‚Äúquodlibet with Is‚Äù at http://hpaste.org/83481
20:40:56 <byorgey> shachaf: ^^^
20:41:26 <carter> byorgey is that from today's / weeks email on libraries?
20:41:54 <byorgey> carter: shachaf was just asking about it
20:42:16 <carter> wait... does that type check?
20:42:17 <byorgey> though I assume it is related to the discussion on libraries@ about Typeable and gcast and so on
20:42:22 <byorgey> yes
20:42:37 <shachaf> Ah, type families.
20:42:49 <byorgey> I don't think you can do it without type families.
20:42:54 <shachaf> Is it possible with just rank-2 types?
20:43:02 <byorgey> I don't know.  I suspect not.
20:43:02 <shachaf> Ah. Hmm.
20:44:04 <carter> but that a is unconstrained....
20:44:38 <shachaf> carter: I think there's an implicit "forall a." in that type instance.
20:45:00 <byorgey> carter: which 'a' are you worried about?
20:45:02 <carter> shanse foo :: Is Char Bool -> a
20:45:15 <byorgey> what about it?
20:45:53 <byorgey> if you have a proof that Char equals Bool, then you get pizza on a blimp, or whatever the heck you want
20:45:55 <carter> so if i have the right x, i could write 7 + f x ?
20:45:59 <carter> ahhh
20:46:00 <carter> ok
20:46:12 <carter> ohhh
20:46:15 <carter> type families/
20:46:20 <carter> ?
20:46:36 <carter> so foo is a type level computation?
20:46:55 <carter> or am I just confusing myself
20:46:59 <byorgey> foo is just a normal Haskell function.
20:47:06 <carter> ohh
20:47:10 <byorgey> But most of the interesting stuff is going on at the type level.
20:47:12 <carter> assume absurd
20:47:15 <ExternalReality> >
20:48:10 <byorgey> An  Is Char Bool  value says you can substitute Bool for Char in any context
20:48:26 <carter> ok, i'm starting to parse it
20:48:51 <byorgey> maybe just go through and annotate everything in the program with its type =)
20:49:21 <carter> byorgey yeah doing that in my head first ... now
20:53:48 <carter> byorgey OH
20:53:56 <carter> you got an unsafe coerce!
20:54:18 <byorgey> carter: indeed.
20:54:32 <carter> so we cant have that Is function
20:54:38 <shachaf> carter: It's not unsafe.
20:54:55 <byorgey> carter: there's nothing wrong with Is.
20:55:16 <byorgey> carter: there's no way to create a value of type   Is Char Bool  in the first place, so foo could never be called.
20:55:23 <carter> byorgey ok
20:55:24 <carter> yeah
20:55:30 <carter> that true to
20:55:38 <carter> ok, so what is this meant to illustrate? :)
20:55:41 <arkeet> byorgey: I would love pizza on a blimp.
20:55:49 <shachaf> Well, it could be called with ‚ä•, or (const ‚ä•)
20:55:52 <byorgey> carter: I don't know, ask shachaf
20:56:01 <shachaf> But then it'll just crash.
20:56:04 <carter> shachaf?
20:56:17 <carter> shachaf so whats the origin of this little criter?
20:56:19 <shachaf> (I mean, ‚ä•-crash.)
20:56:25 <shachaf> carter: I don't remember.
20:56:28 <byorgey> arkeet: well my friend, have I got a deal for you!  Just provide me with a proof that Char equals Bool, and I will give you pizza on a blimp
20:56:42 <shachaf> carter: Hmm, I think the origin was trying to do GADT things with just rank-2 types.
20:57:03 <ivanm> if I have a RULES defined something like "foo (foo x ys1) ys2 = foo x (ys1 ++ ys2)", is there any way I can get that to fire/work when I'm doing "foldl foo x [ys1,ys2]" ?
20:57:14 <shachaf> Trying to replicate something like data Foo a where A :: Foo Int; B :: Foo Bool; blah :: Foo Int -> ...; blah A = ...; blah B = {- unnecessary -}
20:57:34 <shachaf> With GADTs GHC knows it's impossible to have a B
20:58:29 <shachaf> You can try to duplicate it with something like data Foo a = A (Is a Int) | B (Is a Bool), or something.
21:02:52 <augur> koninkje_away: ping
21:03:35 <augur> @tell koninkje_away this is my current outline for topics and order of discussion. lemme know what you think. https://workflowy.com/shared/2df48d92-6a75-5238-1c4f-333b3e077804/
21:03:36 <lambdabot> Consider it noted.
21:11:05 <Leftmost> Learn You a Haskell has an example `ghci> getZipList $ (,,) <$> ZipList "dog" <*> ZipList "cat" <*> ZipList "rat"'. How exactly this gets applied isn't clear to me. Do you basically end up with ZipList [('d',,),('o',,),('g',,)] <*> ZipList "cat" <*> ZipList "rat" after the first application?
21:11:28 <shachaf> Yep.
21:11:35 <shachaf> > getZipList $ (,,) <$> ZipList "dog" <*> ZipList "cat" <*> ZipList "rat"
21:11:37 <lambdabot>   [('d','c','r'),('o','a','a'),('g','t','t')]
21:11:59 <shachaf> > getZipList $ ZipList [(,,) 'd', (,,) 'o', (,,) 'g'] <*> ZipList "cat" <*> ZipList "rat"
21:12:01 <lambdabot>   [('d','c','r'),('o','a','a'),('g','t','t')]
21:12:05 <arkeet> > zipWith3 (,,) "dog" "cat" "rat"
21:12:07 <lambdabot>   [('d','c','r'),('o','a','a'),('g','t','t')]
21:12:20 <shachaf> arkeet: I'm not sure that particularly helps with understanding ZipList/Applicative...
21:12:24 <arkeet> indeed.
21:12:32 <arkeet> shachaf: generalize Applicative/Monad in a lensy way.
21:12:35 <Leftmost> Thanks, shachaf.
21:12:37 <shachaf> > zip3 "dog" "car" "rat"
21:12:39 <lambdabot>   [('d','c','r'),('o','a','a'),('g','r','t')]
21:12:47 <arkeet> I had that in my head.
21:12:50 <shachaf> arkeet: Leftmost is already named after a lens.
21:12:51 <arkeet> and then I wrote the dumb zipWith3 version.
21:12:56 <shachaf> Er, after a lens type.
21:13:14 <shachaf> (A horrible lens types. :-( )
21:13:32 <shachaf> You know how you pay 1000x in constant factors to get the right asymptotic behavior in obscure edge cases?
21:13:51 <shachaf> That's my favourite thing to do.
21:19:15 <TravisD> is the lens video introductory enough to watch as my first contact with Lenses?
21:19:30 <ivanm> TravisD: you mean edwardk's talk?
21:19:36 <TravisD> ivanm: yep
21:19:40 <shachaf> TravisD: Yes, it should be fine.
21:19:52 <edwardk> TravisD: i'd recommend at least skimming http://lens.github.com/tutorial.html first, but you could dive in
21:20:00 <edwardk> the tutorial helps motivate it a bit
21:20:23 <TravisD> Ah, alright. I'm planning to download the video tomorrow on campus, so I'll skim the tutorial tonight
21:20:53 <TravisD> Oops, didn't mean to leave the room
21:22:23 <shachaf> Is there a way to indicate to GHC that a particular let should be generalized?
21:22:25 <TravisD> Woah. The library has a very beautiful page and documentation
21:22:41 <thesalami> Thank you bootstrap
21:22:47 <arkeet> lens is great :>
21:23:56 <edwardk> thesalami: =) i'm not proud. i grabbed the bootstrap css and javascript and just banged away for a few hours. bam, website.
21:24:21 * shachaf prefers the "unstyled" style.
21:24:26 <edwardk> apparently they liked it enough to borrow it for http://haskell-distributed.github.com/
21:25:09 <edwardk> (which i'll probably borrow back for analytics.github.com
21:25:19 <ivanm> shachaf: you mean no-MMR?
21:25:27 <shachaf> ivanm: No, I mean http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/let-gen.pdf
21:25:33 <shachaf> MonoLocalBinds
21:25:39 <thesalami> edwardk: Be proud.  Bootstrap is awesome
21:26:18 <Coolicer> hi
21:28:16 <ivanm> shachaf: NoMonoLocalBinds (cf http://hackage.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7 ) ?
21:28:40 <liyang> edwardk: the bokeh on lens.github.com is just coincidental?
21:28:54 <ivanm> looks like the "solution" is to give explicit type sigs
21:29:59 <edwardk> liyang: deliberate =)
21:30:03 <shachaf> ivanm: That's global for the tnireentire file, though.
21:30:11 <shachaf> ivanm: I don't like that solution. :-(
21:30:17 <ivanm> *nod*
21:30:17 <shachaf> It defeats the purpose in my case.
21:30:18 <edwardk> liyang: i had to hunt for creative commons licensed bokeh images
21:31:03 <edwardk> i figured it was a stock-enough effect and it was a subtle reinforcement of the lens theme
21:32:20 <carter> edwardk you didn't have to take the picture yourself? :)
21:32:24 <liyang> Good job there's an obvious equivalent for Cloud Haskell.
21:33:10 <edwardk> yeah they just kept the bokeh images though without noticing their context
21:44:28 <hpaste> monochrom pasted ‚Äú(forall p. p Char -> p Bool) -> a‚Äù at http://hpaste.org/83483
21:45:10 <monochrom> shachaf: does my paste solve your question? I use data family.
21:45:23 <shachaf> monochrom: That's similar to byorgey's solution.
21:45:39 <shachaf> I was hoping to find one that uses only rank-n types, but I'm not sure whether it's possible.
22:07:17 <amiller> hey i have some questions now about lazy evaluation and church encoding
22:07:27 <amiller> consider a barebones untyped lambda calculus
22:08:30 <amiller> you can church encode true/false as Œªxy.x and Œªxy.y and then if statements as Œªxyz.xyz
22:08:51 <amiller> is lazy evaluation necessary to get the sort of shortcut performance one would expect this way?
22:09:06 <amiller> as in, strict evaluation would necessarily evaluate both branches?
22:09:17 <shachaf> Lazy evaluation as opposed to what, substitution?
22:09:24 <amiller> well ml has strict substitution
22:09:29 <amiller> er strict evaluation
22:09:30 <shachaf> Oh, you're comparing to strict evaluation, not to other types of non-strict evaluation.
22:09:35 <amiller> right
22:09:51 <amiller> are there non-lazy non-strict executions?
22:09:54 <shachaf> Sure.
22:10:00 <amiller> hm, interesting i'm not aware of those
22:10:12 <shachaf> Just direct substitution is the most obvious one.
22:10:17 <shachaf> No sharing. :-)
22:10:28 <amiller> ok then sure :)
22:10:42 <amiller> ok well so in comparison to strict evaluation
22:10:43 <shachaf> Anyway, yes, with strict evaluation you would do unnecessary work.
22:11:17 <shachaf> Since the call "False x y" would reduce x and y before doing anything else.
22:11:45 <amiller> something like ml which is both practical and strict then must have special lazy-sometimes semantics for if-then-else, is that right?
22:11:50 <shachaf> So "False (fix id) x" would be an infinite loop, for example.
22:12:00 <shachaf> I wouldn't call it lazy.
22:12:09 <shachaf> The usual way to get around this is eta-expansion, I think.
22:12:18 <shachaf> Use (() -> T) instead of (T)
22:12:53 <shachaf> But anyway "if" isn't a function if it can do magic things like this in a strict language.
22:12:59 <ivanm> how does one use the --benchmark-option[s] flag for cabal bench? whenever I specify one, my criterion benchmark doesn't do anything :s
22:13:33 <amiller> the point about eta expansion is compelling
22:14:39 <shachaf> amiller: It's perfectly reasonable for the syntax "if X then Y else Z" to compile into (realif (\_ -> Y) (\_ -> Z)), where realif False x y = y (); realif True x y = x
22:15:05 <shachaf> (Or the Church-encoding equivalent.)
22:15:12 <monochrom> I used to do that for python, when python did not have expression-level if-then-else
22:15:23 <shachaf> Strictness is ugly. :-(
22:15:26 <monochrom> and I cursed Guido. (I still do.)
22:15:31 <shachaf> Non-strictness is also ugly. :-(
22:16:01 <shachaf> Totality is the only way.
22:16:46 <amiller> well said, i'm basically interested in this because i'm trying to write data structures and operations in a total subset...
22:17:05 <amiller> for which the usual data Mu is frustrating in coq/agda
22:17:09 <monochrom> I am a total noob
22:17:21 <amiller> i'm hoping that by church-encoding-all-the-things i can get around this
22:17:41 <shachaf> I am a totalitarian.
22:18:52 <shachaf> monochrom: I thought you were lazy.
22:19:01 <shachaf> I suppose you can be lazily total. Or totally lazy.
22:19:16 * hackagebot vector-heterogenous 0.0.1 - A type-safe library for vectors whose elements can be of any type, or any type satisfying some constraints  http://hackage.haskell.org/package/vector-heterogenous-0.0.1 (MikeIzbicki)
22:19:20 <monochrom> I mean I am a noob to total things
22:23:04 <amiller> what are the ramifications of sharing vs non-sharing
22:23:22 <amiller> i'm trying to figure out what's the minimal subset of behaviors needed to get ordinary data structure performance like log n for binary trees and other simple/boring things like that
22:23:41 <amiller> the eta-expansion trick convinced me that's possible in either strict or lazy
22:24:13 <lispy> amiller: http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
22:26:31 <monochrom> sharing vs non-sharing affects time and space complexities only. does not affect answers.
22:27:03 <amiller> that's what i'm asking about though, also that's true for lazy/strict
22:27:06 <shachaf> Right.
22:27:18 <shachaf> I'd thought that's what amiller was asking about.
22:27:29 <monochrom> I misread
22:29:16 * hackagebot wordexp 0.1.0.0 - wordexp(3) wrappers  http://hackage.haskell.org/package/wordexp-0.1.0.0 (MatveyAksenov)
22:32:19 <BrianHV> is there some function that returns both the min and max of a list in a single pass? hoogle isn't giving me anything
22:35:21 <latro`a> I doubt it, but it wouldn't be hard to write
22:36:09 <BrianHV> yeah... but my lists are small enough that I don't really care yet.
22:36:30 <amiller> you could even do it calculationally using the fold rule :3
22:36:45 <amiller> banana-split
22:37:21 <amiller> http://www.cs.ox.ac.uk/ralf.hinze/SSGIP10/Slides.pdf
22:38:08 <latro`a> :t let minmax (x:xs) = foldl (\(y,z) w -> (min y w,max z w)) (x,x) xs in minmax
22:38:09 <lambdabot> Ord t => [t] -> (t, t)
22:38:39 <latro`a> (should be foldl', derp)
22:38:53 <johnw> even that will not be efficient, I don't think
22:38:59 <latro`a> oh?
22:39:04 <johnw> you need \!(y,z)
22:39:07 <latro`a> mm
22:39:09 <johnw> oh, never mind
22:39:12 <latro`a> well, foldl' does that anyways
22:39:16 <johnw> you are analyzing the (y,z), so I'm wrong
22:39:26 <latro`a> that too
22:39:32 <shachaf> You are?
22:39:36 <shachaf> I think you want to be strict in y and z.
22:39:38 <johnw> \(!y,!z)
22:39:45 <shachaf> That.
22:39:47 <johnw> i think you need that
22:39:53 <latro`a> hm
22:39:57 <latro`a> try it?
22:40:01 <latro`a> I'm curious now
22:40:12 <shachaf> Why don't you try it if you're curious? :-)
22:40:34 <shachaf> Ugh, people and their descriptive paper titles.
22:40:55 <shachaf> "_Let Should Not Be Generalised_ argues that let, uh, should not be generalised"
22:41:53 <latro`a> doesn't seem to make much difference, though I didn't actually time it per se
22:42:15 <shachaf> You should be able to get a stack overflow with a large list, I think.
22:42:19 <latro`a> but minmax [1..1e6] takes a few seconds on my machine in either form
22:42:22 <shachaf> (Note: Trying in ghci doesn't count.)
22:42:27 <latro`a> ah
22:44:09 <latro`a> should 1e9 be big enough?
22:44:24 <shachaf> 1000000 works fine for me.
22:44:27 <shachaf> (To demonstrate the problem.)
22:45:57 <hpaste> ‚ÄúAnonymous Coward‚Äù pasted ‚Äúfoldl' strictness‚Äù at http://hpaste.org/83487
22:46:01 <shachaf> latro`a: Try that.
22:46:16 <latro`a> nvm, I got it
22:46:40 <latro`a> that's a little bit frustrating
22:46:57 <latro`a> I understand it, seq isn't deepseq, but still
22:47:02 <shachaf> deepseq is the devil
22:47:09 <latro`a> quite
22:47:11 <shachaf> It's not the solution here.
22:47:20 <amiller> shachaf the discussion about eta expansion for church encodings i think is similar to the approach mentioned here http://www.cs.utexas.edu/~bendy/papers/MTC.pdf about mendler style algebras
22:47:24 <latro`a> I know, but the point was just that seq doesn't go further than the top
22:47:29 <latro`a> s/top/outermost
22:47:57 <amiller> basically a mendler style algebra is different from the typical church encoding in that it adds an extra paremtric function thing that prevents automatic case analysis
22:49:00 <amiller> normal fix is like:   type Fix f = forall a. (f a -> a) -> a
22:49:28 <shachaf> That's not Fix, that's Mu.
22:49:58 <amiller> mendler fix is like:   type FixM f = forall a. (forall r. (r -> a) -> f r -> a) -> a
22:50:11 <amiller> uh i'm meaning to use Mu and Fix interchangeably
22:52:54 <samm> hello. can I use fmap to print a Maybe if it is Just x, and do nothing if it is Nothing? I tried something like this but couldnt get it to work: sequence $ fmap print $ Just 10
22:53:59 <shachaf> sequence is for [], not Maybe.
22:54:11 <shachaf> However, Data.Foldable.sequence_ should work for you.
22:54:14 <BrianHV> samm: catMaybes may be of use
22:54:21 <shachaf> BrianHV: ?
22:54:28 <shachaf> But sequence_ + fmap = mapM_
22:54:45 <shachaf> So probably the asnwer you want is Data.Foldable.mapM_/forM_/for_/...
22:55:15 <BrianHV> oh, I see, nm.
22:55:26 <mauke> :t maybe (return ()) print
22:55:27 * BrianHV is tired.
22:55:28 <lambdabot> Show a => Maybe a -> IO ()
22:55:37 <mauke> :t maybe def print
22:55:38 <lambdabot>     Not in scope: `def'
22:55:38 <lambdabot>     Perhaps you meant `dff' (imported from Data.Graph)
22:55:48 <ExternalReality> In Data.Cereal when you call decode to decode a bytestring from (Maybe a) it always results in Nothing.
22:56:03 <shachaf> @ty Data.Foldable.mapM_ print
22:56:04 <lambdabot> (Show a, Foldable t) => t a -> IO ()
22:56:11 <ExternalReality> Which is confusing if the function you are writing return (Maybe a)
22:56:19 <ExternalReality> Lol
22:57:26 <ExternalReality> I made a mistake and had (return val) instead of (return $ Just val) and kept on getting Nothing.
22:57:39 <ExternalReality> That really sucked
22:58:16 <BrianHV> > mapM_ print $ maybeToList $ Just 10
22:58:18 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
22:58:18 <lambdabot>    arising from a use of ...
23:01:38 <ExternalReality> Polymorphic return type cost me an hour
23:02:00 <hpaste> monochrom annotated ‚Äú(forall p. p Char -> p Bool) -> a‚Äù with ‚Äú(forall p. p Char -> p Bool) -> a  improvement‚Äù at http://hpaste.org/83483#a83488
23:02:27 <monochrom> this paste uses GADTs instead. still not purely RankNTypes
23:02:49 <shachaf> Yes, GADTs gives you more or less the same thing as type families here.
23:04:14 <shachaf> monochrom: The type family version has the advantage of allowing you to write unsafeCoerce
23:04:24 <shachaf> Whereas in GHC the GADT version will just turn into a pattern match failure.
23:04:28 <shachaf> "advantage"
23:08:02 <Shane_> Hey #Haskell! Does anyone have any good examples of Data.Vector.Mutable in use? I'm still wrapping my head around things, and I'm having a bit of trouble making a data type of the form data Memory s = Memory (MVector s Word16), since I'm not really sure how to get the s in there for the ST monad
23:08:32 <shachaf> Shane_: You should rather look for examples of ST use.
23:08:42 <shachaf> ST use is all the same, and relies on that magic s.
23:09:03 <shachaf> You get s with runST.
23:09:07 <shachaf> @ty runST
23:09:09 <lambdabot> (forall s. ST s a) -> a
23:09:16 <shachaf> @ty newSTRef
23:09:17 <lambdabot> a -> ST s (STRef s a)
23:09:22 <Shane_> Oh, is it? A quick look around led me to believe this was different, but I'll take another look then. Thanks
23:09:41 <shachaf> > runST (do { x <- newSTRef 0; modifySTRef x (+1); readSTRef x })
23:09:43 <lambdabot>   1
23:10:41 <Shane_> I believe that's the best example of ST I've seen yet
23:10:43 <shachaf> The type of x is "ST s Integer", where the whole expression is polymorphic so it can work with any s.
23:10:52 <shachaf> Er, STRef s Integer
23:11:33 <mauke> actions in ST are combined with (>>=)
23:11:34 <Shane_> So is the s basically a tag type thing for the compiler, so that the type of the expression will be unique to its context, and stuff can't leak out?
23:11:47 <mauke> the type of (>>=) ensures that both actions use the same s
23:11:57 <Shane_> "tag type thing" probably isn't the best choice of wording though
23:11:58 <mauke> all allocation functions in ST tag their result with the same s
23:12:06 <shachaf> Shane_: Yes, more or less.
23:12:13 <shachaf> Notice how you can't return an STRef from your ST computation.
23:12:24 <shachaf> And even if you had one, you wouldn't be able to use it in any other ST computation.
23:12:27 <mauke> newSTRef :: a -> ST s (STRef s a) -- the same s appears in the ST context and in the STRef variable
23:13:00 <mauke> :t readSTRef
23:13:01 <lambdabot> STRef s a -> ST s a
23:13:28 <mauke> here the type again ensures that the s variables match
23:14:18 <mauke> finally, runST :: (forall s. ST s a) -> a  ensures that any action you can run is fully polymorphic in s
23:14:34 <mauke> so all your code can do with s is ignore it
23:15:16 <Shane_> I haven't seen a type using existential quantifiers like that before. Is that common?
23:15:23 <Shane_> Er universal
23:15:25 <shachaf> That's not existential.
23:15:31 <shachaf> Well, common for ST.
23:15:52 <shachaf> When you have a forall in that position, it restricts what you can do with runST.
23:16:02 <shachaf> In particular you have to promise that your code will work with any s at all.
23:16:36 <Shane_> Alright, thanks. I'll give this another try after reading up on ST some more then
23:18:09 <shachaf> monochrom: It seems that GADTs/TypeFamilies give you an important thing that I don't see how to get with rank-2 types.
23:26:22 <shachaf> monochrom: Hmm, the obvious encoding of Magic -- newtype Magic t = Magic { runMagic :: forall r. (t ~ Char => r) -> (t ~ Bool => (forall a. a) -> r) -> r } -- is really unusable.
23:48:48 <tcbe> good morning
23:49:37 <ExternalReality> top o' the morning to ya
23:50:40 <ExternalReality> well I need to be going to bed not. Hacking on haskell will have to wait till the morrow.
23:51:04 <ExternalReality> Off to the land of C# and well... Log4Net when I wake
23:51:23 <tcbe> I have the following problem: my numeric-block on the keyboard works in the terminal. But as soon as I try to use it in ghci, only the digits work, +,/,*,-  do not work anymore
23:51:29 <ExternalReality> Maybe I'll get to sneak in TPL Dataflow to try to modularize that mess.
23:53:53 <lightquake> am I the only one that uses . and $ in the same expression to 'chunk' the function pipeline?
23:54:05 <samm> does Gtk2Hs work with Glade?
23:54:17 <supki> tcbe: try different terminal?
23:54:27 <lightquake> so‚Ä¶ doOneThing . doOtherThing $ checkThing . checkOtherThing $ you . get . the . idea $ x
23:55:17 <tcbe> supki yes, from xterm over gnome-terminal ... but wait; konsole works.. oO
23:55:37 <ExternalReality> lightquake: I don't get it (.) is compostion ($) is application.
23:55:47 <lightquake> well, right
23:55:57 <lightquake> but f . g . h $ x is the same as f $ g $ h $ x
23:56:04 <samm> I am struggling to install libglade, so I am wondering if haskell can even read glade xml files and extract objects from them at runtime
23:56:54 <supki> samm: I worked last time I checked but you need older glade compatible with gtk2
23:57:04 <supki> maybe this changed
23:57:11 <ExternalReality> lightquake: until you want to eta-reduce x
23:57:40 <lightquake> what do you mean?
23:57:55 <samm> supki: older libglade, or Glade (the GUI builder) ?
23:59:09 <ExternalReality> fn x = f $ g $ h $ x = fn = f . g . h
23:59:37 <ExternalReality> I don't thing fn = f $ g $ h will work
23:59:53 <arkeet> it will not
