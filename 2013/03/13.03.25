00:15:28 <osa1> how can I throw a ParseError in a ParsecT function ?
00:20:14 <notdan> osa1: try 'newErrorMessage' or 'newErrorUnknown'
00:22:01 <osa1> notdan: I alredy have the ParseError, I want to throw it. to be precise, I'm calling `parse` again in a parser function, and I need to throw when `parse` throws an exception
00:24:47 <notdan> Well, if you have a ParseError, then 'parse' will return 'Left ...', won't it? And then you can do 'case (parse ..) of Right _ -> ... Left _ -> raise ...'
00:24:56 <notdan> Or maybe I've misunderstood you, sorry
00:30:46 <osa1> notdan: you're right except "raise ..." part doesn't work
00:31:02 <osa1> notdan: and by raise you mean "throwError", right ?
00:35:28 <notdan> osa1: well throwError works only in MonadError
00:35:46 <notdan> osa1: so your 'Right -> ..' part needs to return something of that type too
00:56:05 <SuperNoeMan> why am I unable to get more than 1 kb /s from the haskell platform? trying to download is taking way too long
01:00:22 <notdan> Hm.. people have been complaining about that yesterday too
01:00:58 <notdan> Maybe there are other mirrors?
01:01:10 <notdan> Is that a possibility to use your distro's package?
01:03:12 <SuperNoeMan> I'm on mac
01:03:17 <SuperNoeMan> the only mirror I know about is
01:03:20 <SuperNoeMan> !platform
01:03:26 <SuperNoeMan> ok...
01:03:28 <SuperNoeMan> ?
01:03:41 <SuperNoeMan> guess automated system thinks I'm its bitch...
01:03:57 <SuperNoeMan> this:
01:03:59 <SuperNoeMan> http://www.haskell.org/platform/
01:05:52 <osa1> is there a zipWithM function for IOVectors ?
01:25:17 <bobry> Is there a typeclass for bounded containers? i. e. Array?
01:25:33 <bobry> or it's okay to use Bounded for this?
01:26:21 <shachaf> What would that mean?
01:29:19 <bobry> probably Bounded isn't appropriate here, I want a typeclass with a function which allows to get the capacity of a given container
01:30:05 <circle> what does it mean when it says "The type signature for `xxx' lacks an accompanying binding?
01:30:27 <shachaf> Which part is unclear?
01:30:42 <shachaf> Do you know what a type signature is and what a binding is?
01:31:01 <circle> I typed an example out of the book and it didn't work
01:31:13 <shachaf> You probably misspelled something.
01:31:29 <shachaf> I recommend showing your actual code if you want actual advice. :-) Otherwise people can only guess.
01:31:33 <circle> the example was: fst :: (a, b) -> a
01:31:33 <circle> fst(x, _) = x
01:31:39 <circle> That's it. Two lines.
01:32:00 <shachaf> That's your file?
01:32:09 <elliott> if you typed that in you wouldn't get any complaint about "xxx".
01:32:23 <circle> well, it gave me a complaint about "fst"
01:32:53 <circle> hmm, nevermind, mistyped something
01:34:14 <hpaste> circle pasted “what” at http://hpaste.org/84625
01:34:21 <circle> What's wrong with that one ^?
01:34:34 <shachaf> Wht do you expect it to be?
01:34:50 <shachaf> It looks to GHC like you're trying to define a function called "True".
01:34:58 <shachaf> Well, actually, like you're trying to pattern-match.
01:35:02 <circle> I suppose you have to put the 'magic' in ` characters
01:35:12 <shachaf> If you want it to be infix, yes.
01:35:21 <circle> thanks
01:41:56 <Hermit> bobry: what do you need to do?
01:42:59 <Hermit> bobry: Bounded wouldn't be appropiate at all. But you can create your own typeclass though and make use of Data.Array.bounds to get what you need
01:44:38 <francoccc> hello haskellers, a probably naive question. I saw ( http://www.haskell.org/pipermail/libraries/2012-November/018832.html ) that the proposal to add '&' to Data.Function was not accepted. I was thinking of making a module (Data.Function.Forward maybe?) just with this operator, because if someone wants to use is better to have a 'standard' symbol, in my opinion. Is the idea silly or not?
01:44:53 <bobry> Hermit: so there's not default typeclass for that, right?
01:45:57 <Hermit> bobry: right, and Bounded wouldn't be appropiate because you need methods with a type signature like :: a -> Int, since the length of the array is not coded in the type
01:46:52 <bobry> I see, thanks!
01:48:44 <supki> francoccc: there is already reverse-apply package. I personally don't think it's useful in any way
01:49:12 <llumac> Hello
01:49:52 <francoccc> oh, thanks Su
01:49:57 <francoccc> * supki
01:51:20 <llumac> Hi all, I was wondering if I could get help with  a problem. I just have to divide a list in half and output both halves. I understand how to get the first half, but I'm a little stuck on the 2nd part
01:51:21 <francoccc> http://www.haskell.org/hoogle/?hoogle=%26 (not on hoogle though?)
01:51:50 <supki> no, hoogle does not index all of hackage
01:52:19 <notdan> francoccc: you should try Hayoo
01:52:29 <francoccc> thanks
01:52:44 <Hermit> llumac: halve = splitAt =<< (`div` 2) . length
01:53:27 <llumac> Huh, that's a much more compact way of doing it.
01:53:43 <Hermit> llumac: you'll need to import Control.Monad.State for that to work though
01:53:56 <llumac> Is there a way to do it without?
01:54:06 <llumac> I had halve [] =[]
01:54:18 <llumac> halve xs = take (n div 20 xs
01:54:19 <Hermit> llumac: no need to import any function though, it's just to get the Monad ((->) a) instance
01:54:26 <llumac> where n = length xs
01:54:43 <aleator> Hermit: Why does that need state?
01:55:02 <francoccc> http://www.haskell.org/ghc/docs/6.6.1/html/libraries/base/Data-List.html#v%3AsplitAt <-- llumac , start reading this
01:55:04 <elliott> you should import Control.Monad.Instances for that instead
01:55:17 <francoccc> I am sure you will come up with your own solution
01:55:23 <llumac> I wanted to create a function halve :: [a] -> ([a],[a])
01:55:23 <Hermit> elliott: nice one
01:55:27 <francoccc> (that is, without Control.Monad.State)
01:55:34 <Hermit> aleator: it's just to get the Monad ((->) a) instance
01:55:43 <Hermit> aleator: not that it needs the state monad at all
01:56:02 <Hermit> aleator: but as elliott just said, one can just import Control.Monad.Instances  (I wasn't aware of it)
01:56:31 <aleator> Hermit: I think that is in Base?
01:56:43 <supki> on 7.6.1 you don't need to import anything I think
01:57:00 <Hermit> aleator: no, it isn't. Try  :i Monad  and see if you find the  Monad ((->) r)  instance
01:57:22 <`ramses> Hermit: it is in 7.6 and beyond
01:57:58 <Hermit> `ramses: oh, thanks for pointing that out. I'm still at 7.4
01:58:09 <Hermit> should upgrade
02:01:52 <jfischoff> is there a bounded mutable queue on hackage somewhere?
02:02:11 <aleator> Hermit: Funnily, all I got was flip splitAt <*> (`div` 2) . length
02:03:46 <Hermit> aleator: you took a different path, through Applicative. Didn't think of that, but still, the monad version is shorter ;-)
02:04:30 <`ramses> I think this is more understandable though: splitAt <$> (`div` 2) . length <*> id
02:05:13 <shachaf> I think a solution that does not use length would be better.
02:05:15 <srkila> Who can do a FizzBuzz in haskell? :P i.e Every number evenly divisible by 3 should be replaced with Fizz. Every number evenly divisible by 5 should be replaced with Buzz. Every number evenly divisible by 3 and 5 should be replaced by FizzBuzz
02:05:57 <elliott> srkila: lots of people can.
02:06:03 <elliott> can you?
02:06:39 <srkila> Yes
02:08:26 <srkila> elliott: Let's see how you would do it
02:08:50 <elliott> is this homework or something? :P
02:09:30 <srkila> elliott: Nope.
02:09:42 <srkila> http://www.haskell.org/haskellwiki/Haskell_Quiz/FizzBuzz
02:35:40 <sordina3> Hey. What's a good abstract parser to use? I'm not working with strings.
02:36:23 <sordina3> I'm guessing parsec can do it, but it being listed under text makes me think it's woth asking.
02:38:44 <jfischoff> parsec can work with arbitrary streams, yes
02:39:45 <dmj> anyone have reactive-banana-wx installed on osx ?
02:39:48 <shachaf> Parsec doesn't really work with "streams" at all, does it?
02:40:18 <jfischoff> shachaf: not infinite streams no
02:40:20 * Hermit sadly I couldn't compile wxcore
02:40:42 <sordina3> Thanks guys.
02:40:59 <Hermit> dmj: btw, did you happen to come across some linking errors when building wxcore?
02:41:11 <jfischoff> but you can make it work with different Stream types besides String
02:41:47 <jfischoff> shachaf: nice work on the patch
02:41:55 <shachaf> Well, I suppose it can confuse a stream, just not produce one.
02:42:01 <shachaf> jfischoff: ?
02:42:06 <dmj> Hermit: The error message seemed pretty unintuitive. cabal: Error: some packages failed to install:
02:42:07 <dmj> reactive-banana-wx-0.7.1.0 failed during the building phase. The exception
02:42:07 <dmj> was:
02:42:14 <dmj> ExitFailure 1
02:42:33 <Hermit> dmj: try cabal install -v reactive-banana-wx
02:42:46 <Hermit> dmj: if that's unhelpful, try with --verbose=3
02:43:04 <jfischoff> shachaf: http://hackage.haskell.org/trac/ghc/attachment/ticket/7642/0001-Nullary-type-classes.patch
02:43:12 <shachaf> Oh, that.
02:43:16 <jfischoff> :)
02:43:21 <shachaf> monoidal wrote the actual accepted patch. :-)
02:43:36 <jfischoff> aye
02:43:52 <dmj> Hermit: k one sec
02:44:24 <no-n> :t no-n
02:44:26 <lambdabot>     Not in scope: `no'
02:44:26 <lambdabot>     Perhaps you meant one of these:
02:44:26 <lambdabot>       `not' (imported from Data.Bool),
02:44:32 <no-n> :]
02:45:05 <hpaste> dmj pasted “reactive-banana-fail-osx” at http://hpaste.org/84626
02:45:49 <dmj> Hermit: check the paste. I use virthualenv instead of cabal-dev
02:47:59 <dmj> Hermit: It does look like its failing during linking
02:49:00 <Hermit> dmj: yeah, linking wx is a total bitch. Btw, try with --verbose=3 but build reactive-banana-wx only, not the asteroid package
02:50:04 <dmj> Hermit: k one sec
02:53:45 <dmj> Hermit: I am able to create a .app following the instructions from here: http://www.haskell.org/haskellwiki/WxHaskell/Mac
02:53:55 <dmj> Hermit: It crashes on launch
02:55:40 <Hermit> dmj: I could check it in my macmini in a minute. So far I've only attempted to build wx on GNU/Linux, and it's failed miserably (haven't figured the problem out yet)
02:56:26 <hpaste> dmj revised “reactive-banana-fail-osx”: “--verbose=3 banana-wx” at http://hpaste.org/84626
02:56:42 <vlatkoB> For functions
02:56:42 <vlatkoB> go' acc ((y:_):xs) | otherwise = undefined
02:56:42 <vlatkoB> go' acc []     = undefined
02:56:42 <vlatkoB> I'm getting warning they are non-exhaustive fo match _ ([] : _)
02:56:42 <vlatkoB> How is this one different with the first one?
02:56:48 <dmj> Hermit: That'd be cool
02:57:58 <supki> vlatkoB: do you agree that [[1,2,3],[4,5,6]] is different from [[],[4,5,6]] ?
02:58:02 * Hermit got to the mac
02:58:07 <circle> what's the library function to remove an elememtn from a list again?
02:58:09 <Hermit> dmj: let's see what we can work out
02:58:13 <dmj> vlatkob: you have a [[a]]. You're checking if the whole thing is empty, [], but not the first element
02:58:55 <dmj> circle: delete 3 [1..5]
02:59:04 <dmj> == [1,2,4,5]
02:59:12 <dmj> Hermit: cool :)
02:59:19 <circle> dmj: thanks
02:59:24 <dmj> circle: :m + Data.List
02:59:26 <circle> dmj: what about an element at a specific location?
02:59:35 <dmj> circle: (!!)
02:59:40 <dmj> circle: gives you the index
02:59:44 <circle> thanks
03:00:34 <dmj> circle: np, also, http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
03:01:53 <vlatkoB> supki: Yes, it's easy to see now. Should learn to write it down like this myself. Thanks.
03:02:56 <circle> delete doesn't work
03:04:40 <dmj> circle: what are you trying?
03:04:56 <circle> delete 3 [1 .. 5]
03:05:01 <circle> not in scope delete
03:05:19 <dmj> ok, so you'll need to import Data.List at the top of your file
03:05:29 <dmj> below the module name
03:05:45 <dmj> circle: if you're using ghci, then :m + Data.List
03:05:50 <dmj> :m == import
03:06:09 <circle> works now, thanks mate
03:06:40 <dmj> circle: cool beans
03:11:13 <vlatkoB> Hm, not clear. If
03:11:14 <vlatkoB> ((y:_):_) covers [[1,2,3],[4,5,6]]-[[1,2,3]]-[[1]]
03:11:14 <vlatkoB> [] covers []
03:11:14 <vlatkoB> what does ([]:rest) cover?
03:11:46 <shachaf> A nonempty list whose first element is a list (which is empty).
03:12:30 <mauke> > case [[], ["A", "B"]] of [] : rest -> rest
03:12:32 <lambdabot>   [["A","B"]]
03:12:46 <mauke> > case [["A", "B"], []] of [] : rest -> rest
03:12:48 <lambdabot>   *Exception: <interactive>:3:1-42: Non-exhaustive patterns in case
03:13:24 <vlatkoB> Yes, I see, thanks.
03:21:22 <xpika> putChar (chr 55296) gives me *** Exception: <stdout>: hPutChar: invalid argument (invalid character)
03:21:42 <xpika> is there a more direct way to write a binary to stdout?
03:25:05 <tdammers> xpika: bytestrings?
03:29:14 <xraycat> Hello, I have a list of "work" which can be evaluated in parallel. If the evaluation of one of these element yield a certain result, I can finish, e.g. I need some sort of short circuiting. In addition I'd like to evaluate only as much work in parallel as I have OS Threads (-NX), for -N1 it should work like the sequential counter part. The List should be evaluated in order: if I have for example a list of 16 elements and -N8 is supplied, I
03:38:38 <ocharles> xraycat: you cut off
03:38:45 <ocharles> we only got you up to "is supplied, I"
03:38:56 <ocharles> but it sounds like you want the `async` package
03:38:59 <xraycat> is supplied, I want to evaluate the first 8 elements in parallel first. Is there something like this for the par monad or what would be the way to do it? I've been using STM thus far, but I'm unable to achieve the determinism I need.
03:39:06 <ocharles> and also, that you need concurrency, not parallelism
03:39:07 <xraycat> oh sorry, thanks for mentioning it
03:39:45 <ocharles> when my laptop is done indexing this database I'll have a look at async to see if that's what you need
03:39:53 <ocharles> but right now, I fear opening firefox might cause it to overheat :)
03:39:57 <ocharles> @hackage async
03:39:57 <lambdabot> http://hackage.haskell.org/package/async
03:40:02 <ocharles> but check that out
03:40:06 <xraycat> thanks, will do
03:40:11 * hackagebot VKHS 0.3.0 - Provides access to Vkontakte social network via public API  http://hackage.haskell.org/package/VKHS-0.3.0 (SergeyMironov)
03:40:34 <ocharles> there is somesort of 'race' function which will race a bunch of threads until one terminates
03:41:19 <ocharles> xpika: using a ByteString and the stdout file handle might be the way to go
03:41:59 <ocharles> dmj: btw, you can `import` in GHCI just fine
03:42:35 <xraycat> waitAny looks good
03:55:27 <circle> function :: something a -> something_else b
03:55:28 <circle> what
03:55:36 <circle> is the "something" and "something_else" in that?
03:57:37 <typoclass> circle: it's a type with a type variable, for example Maybe Int vs. Maybe String, etc.
03:57:52 <circle> hmm, thanks
04:05:12 * hackagebot hsndfile 0.7.0 - Haskell bindings for libsndfile  http://hackage.haskell.org/package/hsndfile-0.7.0 (StefanKersten)
04:10:44 <dmwit> circle: I don't believe you're being totally honest. What's the *real* type signature?
04:11:39 <typoclass> dmwit: haven't you heard? the newest versions of base have something_else :-)
04:11:50 <dmwit> (There's only one implementation of the type you gave, and it's a function that never returns -- for example, by infinite looping, throwing an exception, etc.)
04:13:48 <circle> dmwit: real type signature is some function defined not by haskell but a 3rd party library
04:13:54 <circle> It is made to loop forever I believe.
04:14:15 <dmwit> Go on. You'll get a better answer if you tell us the truth. Plus it feels good. ;-)
04:15:13 * hackagebot hsndfile 0.7.1 - Haskell bindings for libsndfile  http://hackage.haskell.org/package/hsndfile-0.7.1 (StefanKersten)
04:15:32 <typoclass> circle: the issue is, in haskell there's normally no way to convert "anything into anything", which is what the 'a' and 'b' in your signature stand for
04:18:52 <killy9999> can I pass unboxed values to return?
04:20:00 <bobry> killy9999: I think no, because they kave kind #, instead of *
04:20:02 <dmwit> killy9999: Let's do science! I have a hypothesis, can you concoct an experiment that tests it...?
04:20:30 <bobry> Is there a way to hide the value of type synonym in haddock? for instance I have type Foo = String, can I hide the String part somehow?
04:20:51 <dmwit> bobry: No, unless you also hide Foo from being exported at all.
04:21:22 <dmwit> bobry: And it's a good thing, too, because you'd only be fooling yourself if you hid it from the docs; people would still be able to discover it via :browse, :info, and half a dozen other ways.
04:21:44 <bobry> Okay, thanks!
04:21:47 <merijn> Or even just passing a String to it and not getting a type error :p
04:22:16 <robstewartuk> Reading http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/using-shared-libs.html , is there a way to turn on the --enable-shared flag within a .cabal file ?
04:22:16 <merijn> bobry: Are you trying to stop people from using Strings directly and making them convert them?
04:22:42 <merijn> robstewartuk: ghc-options?
04:22:51 <bobry> merijn: nope, I don't need a newtype wrapper, I just want an "abstract" type
04:22:54 <merijn> That let's you pass arbitrary options to GHC during compilation
04:23:01 <merijn> bobry: ok
04:25:13 <mushi> hello
04:25:29 <mushi> anyone around that is fimilar with BST
04:25:39 <mushi> and quickcheck for a few questions
04:26:47 <typoclass> mushi: hi :-) just ask
04:28:20 <mushi> ok here is my code
04:28:22 <mushi> http://pastebin.com/pDWumMtW
04:28:36 <mushi> i have to prove this
04:28:37 <mushi> prop_mysteryPred_1 integer = forAll searchTrees $ \tree -> mysteryPred integer (insert integer tree)
04:28:49 <mushi> i am struggling to figure out what this prop means
04:29:00 <mushi> anyone want to give me pointers/lead me on correct path?
04:30:14 * hackagebot bitset 1.3.0 - A space-efficient set data structure.  http://hackage.haskell.org/package/bitset-1.3.0 (SergeiLebedev)
04:34:39 <typoclass> mushi: have you checked the type of function mysteryPred? does this give any clues?
04:35:05 <mushi> the type is this "mysteryPred :: Integer -> BinaryTree ->Bool"
04:35:46 <dmwit> It almost reads like English.
04:36:23 <dmwit> It says that for all search trees (and integers), if you insert that integer into the tree, mysteryPred holds of that integer and the resulting tree.
04:36:26 <typoclass> mushi: right. so the code "mysteryPred integer (insert integer tree)" produces a tree that has the number 'integer' inserted, and then gives the tree and the number into mysteryPred
04:37:33 <dmwit> (The forAll seems a bit spurious, though. Why not prop_mysteryPred_1 integer tree = mysteryPred integer (insert integer tree)?)
04:37:40 <dmwit> ?hoogle forAll
04:37:41 <lambdabot> Test.QuickCheck.Property forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
04:37:41 <lambdabot> Test.QuickCheck forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
04:37:41 <lambdabot> keyword forall
04:38:08 <blueonyx> ?hoogle Arbitrary
04:38:08 <lambdabot> Test.QuickCheck.Arbitrary class Arbitrary a
04:38:09 <lambdabot> Test.QuickCheck class Arbitrary a
04:38:09 <lambdabot> Test.QuickCheck.Arbitrary arbitrary :: Arbitrary a => Gen a
04:38:37 <dmwit> Oh, I see, that's so BinaryTree doesn't have to be an instance of Arbitrary.
04:38:48 <blueonyx> think so too
04:39:00 <dmwit> That seems a bit silly, though, since searchTrees looks like it ought to be a perfectly good such instance.
04:41:10 <mushi> can someone explain to me like i m 3 on how to write mysteryPred?
04:43:18 <typoclass> mushi: i suspect that this is supposed to be a basic test that the 'insert' function works correctly. "we have a tree, we use 'insert' to put an integer into it, now, does the new tree contain the integer"
04:43:50 <mushi> so mysteryPred
04:44:00 <mushi> is supposed to test if integer is in the tree?
04:45:10 <Hannibal_Smith> Hi, is HDBC library dead?
04:45:14 <typoclass> mushi: i don't know, but yeah, that's my guess
04:45:53 <Hannibal_Smith> It's like the mantainer has abandoned the project
04:47:16 <Hannibal_Smith> https://github.com/hdbc/hdbc/commits/master <-There are some recent commits
04:47:41 <mushi> thanks typoclass i ll look into it
04:47:56 <Hannibal_Smith> https://github.com/hdbc/hdbc/issues <-But the bug tracker is abandoned
04:48:25 <notdan> How can I make cabal generate haddock documentation? Here's a part of my .cabal file: http://paste.lisp.org/display/136329
04:48:27 <notdan> I want cabal to generate haddock docs for PTTest and PetriNet modules
04:48:53 <typoclass> notdan: are you passing "--enable-documentation" to "cabal install"? (or, do you have that switch in your ~/.cabal/config
04:49:18 <typoclass> notdan: wait, or is the question about other-modules vs. exposed-modules
04:49:42 <dmwit> cabal will not generate documentation for executables, only libraries.
04:49:52 <notdan> typoclass: I have documentation: True in my cabal config file
04:50:07 <notdan> But I am using cabal-dev actually, that shouldn't matter should it?
04:50:15 * hackagebot hen 0.0.2 - Haskell bindings to Xen hypervisor interface  http://hackage.haskell.org/package/hen-0.0.2 (FedorGogolev)
04:50:26 <dmwit> So consider installing PTTest and PetriNet as a library, and having your program depend on that library.
04:50:31 <notdan> dmwit: so I'll need to add a Library field to my .cabal file?
04:50:45 <dmwit> Bonus points for putting them at an appropriate place in the module hierarchy first (instead of at the top level).
04:50:50 <dmwit> notdan: yes
04:51:21 <notdan> I see. But I want them for internal use only :S
04:51:24 <dmwit> notdan: Also, you'll need to read a tiny bit about how to do that correctly, as it can be a bit of a pain to get the executable to actually use your library instead of recompiling the modules, if compilation time is a concern for you.
04:51:40 <dmwit> notdan: In that case, you will need to run haddock yourself.
04:51:50 <notdan> Maybe I can just abandon cabal-dev for that purpose
04:51:56 <notdan> yeah dmwit I might actually do that
04:51:57 <notdan> thanks
05:02:58 <aleator> My brain froze. What is the common name for any (==True)?
05:03:15 <typoclass> aleator: 'or'?
05:03:28 <supki> any id
05:03:30 <typoclass> > or [False, False, True]
05:03:31 <lambdabot>   True
05:03:36 <supki> oh
05:04:14 <b_jonas> > or []
05:04:16 <lambdabot>   False
05:04:46 <aleator> > any (==True) []
05:04:47 <lambdabot>   False
05:04:52 <aleator> > or []
05:04:54 <lambdabot>   False
05:04:59 * typoclass purrs and rubs his kitty head on aleator, to unfreeze his brain
05:05:22 <aleator> Grief. How could I forgot that..
05:05:24 <typoclass> supki: for some reason, i like 'any id' better than 'or'
05:05:37 <ocharles> :t or
05:05:38 <lambdabot> [Bool] -> Bool
05:06:12 <b_jonas> or should be called any, and any should be called anyWith
05:06:18 <b_jonas> well no
05:06:26 <ocharles> bah, that could be generalized to a semiring!
05:06:35 <b_jonas> maybe it's okay this way, but zipWith should be called zip
05:06:45 <elliott> anyWith doesn't really need to exist.
05:06:51 <elliott> "any . map f" would be fine
05:07:17 <b_jonas> no, it's the opposite. any needn't exist, because (anyWith id) is fine
05:07:28 <b_jonas> and zip needn't exist either
05:08:45 <typoclass> b_jonas: oh, i'd support renaming zipWith to zip. you wouldn't need the former zip at all because "zip (,)" is so simple
05:10:00 <mushi> anyone have link to tree search algothrims for haskell
05:10:10 <mushi> e.g. depth search? google didnt help
05:13:42 <elliott> b_jonas: why should we bake map into every function?
05:13:47 <latro`a> elliott, "any . map f" would only really be fine with stream fusion
05:13:51 <elliott> for zip it's different. you need an uncurry step there or such
05:14:00 <latro`a> which probably wasn't in place at the time the library was written
05:14:23 <latro`a> without stream fusion it traverses twice
05:14:27 <b_jonas> elliott: because I'm an imperative programmer and can't put (any . map f) in my head
05:14:35 <b_jonas> consciously I know that it works in a lazy language
05:14:39 <b_jonas> but it's just strange
05:15:03 <latro`a> "are any of the values after application of f True?"
05:15:24 <mushi> typoclass: hey man you still around?
05:15:35 <alexander__b> so sum' = foldl (+) 0  pretty much blew my mind.
05:16:15 <typoclass> mushi: yes, but can just as well ask the channel :-)
05:17:03 <blueonyx> mushi: do you mean Tiefensuche aka depth first search? :>
05:17:31 <Pods> Would the parser which runs haskell be turing complete ??
05:17:57 <mushi> yeah
05:18:04 <dmwit> aleator: mconcat ;-)
05:18:09 <danr> Pods: the context sensitivity is only fixitiy information about operatiors, so no
05:18:16 <mushi> hold on i can show you all the code
05:18:20 <dmwit> > mconcat [Any False, Any False, Any True]
05:18:22 <lambdabot>   Any {getAny = True}
05:18:40 <blueonyx> mushi: this then depends on the data structure of your tree
05:19:00 <blueonyx> or maybe he has a Functor instance?
05:19:19 <mushi> http://pastebin.com/t67AcqXB
05:19:20 <Pods> danr : For us to make it a language that can handle semantics sont you think it should first become a language which approaches the completness ??
05:19:22 <typoclass> > getAny $ mconcat $ map Any [False, False, True]
05:19:24 <lambdabot>   True
05:19:48 <danr> Pods: I don't understand sorry
05:19:55 <mushi> thats my code i need to write mysteryPred which meets msyteryPred_1 and _2
05:20:12 <alexander__b> OK, I'm sorry, but "We can omit the xs as the parameter because calling foldl (+) 0 will return a function that takes a list" is not enough of an explanation to me. WTF is up with foldl (+) 0?
05:20:15 <mushi> i ve worked out (due to mostly this channel)
05:20:26 <mushi> msteryPred needs to be a search function
05:20:33 <Pods> I will rephrase it , Would you require (Say) haskell to be turing complete for it to execute (say) semantic searches ??
05:20:46 <danr> but I forgot about the indentation as well, that is also context sensitive
05:20:46 <mushi> i m thinking along the lines of depth search or breath serach?
05:21:24 <blueonyx> mushi: dont think it matters here
05:21:31 <blueonyx> dfs is easier though
05:21:37 <blueonyx> is this homework?
05:21:57 <mushi> yes
05:22:34 <`ramses> alexander__b: if you write f(x) == y(x), do you agree you could equally well have written f == y ?
05:22:54 <`ramses> (with an implicit universal quantor for x)
05:23:00 <ocharles> i was about to say..
05:23:15 <typoclass> alexander__b: don't worry :) it's partial application. ordinarily, foldl requires 3 arguments. you're giving it only 2 (the function (+) and the 0), and you have a function that needs 1 more argument
05:23:18 <typoclass> @type foldl
05:23:19 <lambdabot> (a -> b -> a) -> a -> [b] -> a
05:23:23 <alexander__b> `ramses: in maths, yes. in programming I haven't really done anything equivalent, so IDK, heh.
05:23:51 <alexander__b> typoclass: I realise that it's partial application and that foldl returns a list but I mean still WTF. I can't really grok it, heh.
05:23:54 <dmwit> Pods: Haskell is Turing complete. Haskell's parser is not. There are many stages of execution that come after parsing.
05:24:01 <`ramses> alexander__b: haskell functions are pretty close to mathematical functions
05:24:03 <alexander__b> the whole thing is sum' = foldl (+) 0
05:24:53 <dmwit> s/Haskell's parser/GHC's parser/
05:24:56 <`ramses> alexander__b: saying "sum' xs = foldl (+) 0 xs" is the same as saying "sum' = foldl (+) 0" in the same way as the f and y above
05:25:08 <`ramses> (why did I choose y for the second function?? :p)
05:25:43 <Pods> dmwit: yes, was wondering the same ..
05:26:15 <typoclass> alexander__b: oh, you'll get used to it :) it's just a bit alien at first. but you can work this out pretty directly from the type. you have (a -> b -> a) -> a -> [b] -> a, and you have the (a -> b -> a) covered and the 'a' covered, so you're left with a function [b] -> a
05:26:19 <alexander__b> `ramses: omg. that's clever. but so so so so painful to grok for my C-brain. :-D
05:26:21 <Pods> Thanks :)
05:27:21 <`ramses> alexander__b: it's because functions are regular values, so you can really say "this function I'm defining is equal to this other function" instead of saying what it does on all its parameters
05:27:22 <typoclass> alexander__b: also, it may help if you write down the type of sum', just to be clear
05:27:46 <alexander__b> typoclass: I did that but omitted it when pasting here.
05:28:22 <alexander__b> `ramses: I get it now. well, I can't say I feel comfortable *using* it yet, but I get this specific little code snippet and what is doing, heh. thanks.
05:28:48 <`ramses> alexander__b: also note the "right associativity" of (->): a -> b -> c == a -> (b -> c), which shows the same idea at the type level
05:29:32 <`ramses> alexander__b: it wont take long until you start to really miss this way of thinking in other languages :)
05:32:08 <alexander__b> `ramses: I don't follow what (->): is, but I get that it's right associative.
05:32:26 <dmwit> (->) is the function arrow
05:32:30 <dmwit> the : was just part of the sentence
05:32:43 <alexander__b> oh, heh.
05:33:06 <hamid> :t max
05:33:07 <lambdabot> Ord a => a -> a -> a
05:33:27 <alexander__b> well thank you haskell for blowing my mind, at least. :-)
05:33:45 <kennyd> alexander__b Int -> String is a function that takes an Int and returns String
05:35:19 <dates> Hi. I have an expression :  filter (\(x,y)->(distance (x,y)(0,0))<=5) [(1,1),(2,2),(2,3),(2,4),(2,5),(2,6)] . the function distance takes two tuples as points and calculates their distance. I want to write function version of this expression. I wrote this : giveinsideborder = distance ref_pt pt_list filter  (\(x,y)->(distance_calc (x,y) ref_pt)<=distance). This is supposed to list the points which are as far as distance at most. But 
05:36:13 <Botje_> dates: you got cut off after "But"
05:36:29 <Botje_> dates: might want to formulate your question as a paste on hpaste.org
05:38:47 <hpaste> “Anonymous Coward” pasted “distance” at http://hpaste.org/84630
05:39:25 <`ramses> dates: arguments go before the "="
05:39:25 <dates> Botje_ : http://hpaste.org/84630 better?
05:41:39 <Botje> dates: okay, and what do you want to do with that?
05:42:10 <hpaste> “`ramses” annotated “distance” with “distance (annotation)” at http://hpaste.org/84630#a84631
05:42:44 <`ramses> dates: it is a pure syntax issue, see my annotation
05:44:00 <dates> :ramses thanks, problem solved
05:44:12 <dates> thanks to you too Botje
05:44:28 <Botje> no problem, glad it was something silly :)
05:45:08 <dates> yeah it was :)
05:46:08 <ks07> Hey, is there a good tutorial for using STArray?
05:55:33 <mm_freak> edwardk: do you have an EitherT that is a Biapplicative somewhere?
05:55:58 <mm_freak> or rather:  is there a BiapplicativeTrans version?
05:57:07 <mm_freak> actually i wonder how this might work…  perhaps i didn't think this through enough =)
05:58:29 <hyperthunk> Does anyone know if there's an API (GHC specific is fine) to determine which +RTS options have been given at runtime?
05:59:15 <hyperthunk> I want to know when a program compiled with -eventlog is being run with `+RTS -v` (or equivalent flags)
06:03:43 <mm_freak> hyperthunk: you can get at some of the information at least…  check out modules below GHC.*
06:04:15 <hyperthunk> mm_freak: ok thanks, I'll take a look - just didn't want to dig through all the haddocks if it was a dead end, but if there's something there then I'll poke around a bit. Cheers!
06:05:06 <quchen> ks07: Are you familiar with ST in general? STArray is quite straightforward if that's the case.
06:05:48 <ks07> No, sadly, new to haskell. Done a tiny bit of IO
06:06:42 <quchen> Oh. Well then ST might be a long shot. Have you used normal arrays before in Haskell?
06:07:05 <quchen> STArrays don't do anything special, they're mostly for optimization of normal array operations.
06:09:02 <ks07> Ah okay - the reason I ask is I'm doing an assignment where one part asks us to use arrays to speed up an operation. Is it worth trying with standard arrays first to learn the ropes?
06:09:31 <quchen> ks07: Definitely.
06:09:46 <ks07> Alright ty, will look into it
06:09:54 <quchen> ks07: The problem with normal arrays in Haskell is that when you change a single element, you have to copy the entire array.
06:10:17 <quchen> So if you insert three numbers in an array of 10k entries, you have to make 30k copy operations.
06:10:33 <quchen> ST fixes that problem so that you can combine multiple operations like that into one.
06:10:34 <ks07> so similar to a list?
06:10:50 <quchen> No, to change an element in a list you don't have to copy the entire thing.
06:11:11 <ks07> Shows how much I know
06:11:16 <quchen> Lists are like linked lists in Haskell, they can be distributed over memory. When you update a single element in a list, not much has to be changed.
06:11:41 <quchen> Basically, the compiler has to create a new list consisting of a pointer to the "before", to the "after", and allocate a new element.
06:11:54 <mauke> quchen: that's wrong
06:11:58 <mauke> there is no "before"
06:12:07 <quchen> Oh, right.
06:12:44 <quchen> So you have to allocate a new "before" spine I guess.
06:13:11 <mm_freak> ks07: when people talk about arrays in haskell they don't necessarily mean Data.Array.* arrays…  in almost all cases you would prefer to use Data.Vector.* arrays
06:13:36 <ks07> How do they differ?
06:14:08 <quchen> Vector has a friendly API, array doesn't. ;-)
06:14:11 <mm_freak> ks07: vectors are designed for purely written code…  many operations that would be O(n) space/time with standard arrays are O(1) with vectors
06:14:41 <elliott> if it's an assignment I'm not so sure vector would be allowed
06:14:43 <ClaudiusMaximus> assignent for haskell newbie probably involves boxed arrays for memoization/dynamic programming?
06:15:04 <typoclass> ks07: i suggest that you implement things the simplest possible way (which probably means lists). then you can profile it and determine where the bottlenecks are. you can afterwards write another solution using arrays and compare the performance of the two solutions. this way you can be sure you're doing something meaningful
06:15:06 <ks07> haha, that sounds good, think I'll try the vector
06:15:06 <mm_freak> ks07: you only ever need destructive update if you really want to update individual elements separately, for example when you write a prime sieve or something like that
06:15:17 <copamp> does each socket has correspond to one separate physical connection or can several sockets listen to the same IP and port?
06:15:17 <mm_freak> ks07: however, make sure you are allowed to use vectors
06:15:31 <quchen> Vector is pretty much like C++'s vectors: zero-based int indexed etc. Arrays allow any Ix as index, but as a consequence they're a little harder to work with sometimes.
06:16:29 <typoclass> ks07: and as always, don't do premature optimization
06:17:02 <ks07> I don't think we're restricted on what we use - the task is an extension to write a better shuffle implementation, as the basic list version we started with is O(n^2)
06:17:41 <mm_freak> copamp: sockets, just like other file descriptors, can be duplicated…  to see what this means you should check out your operating system's manual
06:18:15 <mm_freak> ks07: you definitely want vectors for that…  specifically see the 'backpermute' function
06:18:20 <ks07> didn't think to search for haskell shuffle, totally missed the whole wiki page on shuffling
06:18:38 <elliott> ks07: well, the thing is that vector is not a totally standard library
06:18:46 <elliott> it's aprt of the Haskell Platform, but doesn't come with the GHC compiler itself
06:18:54 <elliott> which is why it might not be allowed
06:19:10 <ks07> Data.Vectr ?
06:19:13 <ks07> +o
06:19:43 <elliott> yes
06:19:54 <ks07> Not available on the lab machines, so looks like it'll be arrays after all
06:20:05 <blueonyx> @source otherwise
06:20:05 <lambdabot> otherwise not available
06:20:10 <blueonyx> O.o
06:20:15 <blueonyx> :t otherwise
06:20:17 <lambdabot> Bool
06:20:35 <typoclass> ks07: keep in mind that O(...) notation does not usually tell the whole story. i suggest you profile your solution to get some actual measurements
06:21:07 <quchen> blueonyx: otherwise = True, defined in GHC.Bool or something
06:21:16 <typoclass> blueonyx: it's (funnily) defined as "otherwise = True". this way, it always matches when you do "| otherwise = ..."
06:21:29 <blueonyx> i know, thx anyhow
06:21:40 <ks07> Ok,  will keep that in mind, thanks for all the suggestions
06:22:11 <typoclass> blueonyx: and @src afaik is just a text file where someone copy-pasted the most popular functions. the "source" links on haddock are more complete
06:22:27 <blueonyx> ah
06:23:09 <blueonyx> i just wanted to explain the | otherwise thing with lambdabot for mushi
06:25:29 * hackagebot yaml-config 0.0.1 - Configuration management  http://hackage.haskell.org/package/yaml-config-0.0.1 (FedorGogolev)
06:35:29 * hackagebot fclabels 1.1.5 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-1.1.5 (SebastiaanVisser)
06:50:29 * hackagebot safecopy 0.8.2 - Binary serialization with version control.  http://hackage.haskell.org/package/safecopy-0.8.2 (DavidHimmelstrup)
07:01:55 <mm_freak> instance (Monoid e) => Alternative (Either e)  -- this instance is missing
07:03:09 <johnw> i'd let libraries@ know
07:04:05 <mm_freak> johnw: i doubt that they will add it
07:04:20 <johnw> why wouldn't they?
07:08:18 <mm_freak> well, for one thing it clashes with this stupid, braindead, whoever-came-up-with-this-deserves-to-be-publicly-whipped Alternative instance from transformers' Control.Monad.Trans.Error
07:08:45 <johnw> that is really unfortunate :(
07:09:34 <mm_freak> MonadError really has PHP qualities…  must have been invented by a PHP programmer who never convalesced from it
07:09:38 * dcoutts wants to complain about the instance MonadError (Either e) 
07:09:51 <dcoutts> the unnecessary Error e =>  constraint
07:10:01 <dcoutts> makes all kinds of useful things impossible
07:10:14 <dcoutts> unnecessary/unused
07:10:32 <mm_freak> yeah, basically lets you newtype-wrap Either all the time
07:10:43 <johnw> s/lets/forces you to?
07:10:56 <mm_freak> yeah
07:11:10 * elliott wants to complain about the existence of Error, full stop
07:11:20 <dcoutts> elliott: yes
07:11:28 <mm_freak> to be honest i consider it an error to import anything that brings MonadError instances into scope
07:11:34 <glguy> "EitherT is a version of ErrorT that does not require a spurious Error instance for the Left case."
07:11:35 <dcoutts> though I can at least see a couple places where it's actually used
07:12:14 <mm_freak> dcoutts: a can see no place where a Monoid constraint on e would not be much more sensible
07:12:23 <mm_freak> i
07:12:38 <zenzike_> I must be missing something ... why is Error so evil? Is it that you'd rather leave Left alone?
07:13:02 <mm_freak> zenzike_: Error assumes that all error messages are strings
07:13:04 <typoclass> mm_freak: how do you mean? multiple errors are collected in a monoid?
07:13:13 <dcoutts> mm_freak: I've not looked at that, I just noted that it's unused in several places, and is a harmful requirement in those places
07:13:18 <mm_freak> typoclass: consider Last SomeException
07:13:25 <mm_freak> Error forces you to use String instead of that
07:13:32 <zenzike_> mm_freak: aha, yes, that is eil. I hadn't noticed the type of strMsg
07:14:04 <Saizan> the Error constraint on the MonadError instance is probably there from when it was needed for Monad (Either e)
07:14:17 <mm_freak> dcoutts: this is where the globalization of class instances bites you
07:14:35 <dcoutts> well, if we all agree it's wrong, lets propose it on the libs list
07:14:46 <mm_freak> Saizan: that was never required in the first place…  'fail' shouldn't exist
07:14:59 <mm_freak> after all you always fail with "pattern match failure"
07:15:17 <mm_freak> dcoutts: i think, we all agree
07:15:28 <johnw> I agree as well
07:15:29 <dcoutts> and the constraint was already dropped for Monad
07:15:38 <dcoutts> just need to follow through with the rest
07:16:20 <mm_freak> my proposal is to require Monoid on 'e' where necessary
07:16:38 <mm_freak> whenever you fail, fail with Left mempty
07:16:55 <glguy> Doesn't that create a circumstance where ap /= <*> ?
07:17:06 * glguy jumps in late
07:17:08 <mm_freak> and have:  Left e1 <|> Left e2 = Left (e1 <> e2)
07:17:16 <mm_freak> glguy: why?
07:17:28 <glguy> Ah, you're only doing the exception merge on Alternative
07:17:31 <glguy> and not Applicative?
07:17:47 <mm_freak> glguy: what do you mean?
07:18:11 <glguy> You can also have Monoid e => Applicative (Either e)
07:18:13 <mm_freak> similarly you get:  Left e1 <*> Left e2 = Left (e1 <> e2)
07:18:15 <mm_freak> yeah
07:18:26 <glguy> but then   f <*> x    isn't the same as   f `ap` x
07:18:32 <glguy> which some people consider a mistake
07:18:33 <mm_freak> i've checked the laws already for an Either-like type
07:18:40 <glguy> Are you revoking the Monad instance?
07:18:52 <mm_freak> glguy: it is when fail = const (Left mempty)
07:19:05 <Saizan> i think we should keep the Monad and Applicative instances as they are now, with no constraints
07:19:10 <mm_freak> glguy: oh, i see what you mean
07:19:40 <mm_freak> so leftmost error only?
07:20:02 <mm_freak> then of course no Monoid constraint is necessary
07:20:21 <glguy> I'm not advocating for either approach, just bringing up the issue
07:20:41 <Saizan> yeah, left-most only
07:20:45 <dcoutts> mm_freak: fewer constraints seems sensible as the default. It's easy enough to make a separate type (not Either) that does the "collecting multiple independent errors" thing
07:21:42 <mm_freak> yeah, unfortunately the applicative Either i'm proposing is not a Monad, as pointed out by glguy =/
07:22:40 <mm_freak> in any case MonadError needs to go
07:26:56 <plhk> what's the replacement, exception monad?
07:35:31 * hackagebot gdiff-th 0.1.0.5 - Generate gdiff GADTs and Instances.  http://hackage.haskell.org/package/gdiff-th-0.1.0.5 (JonathanFischoff)
07:39:54 <robstewartuk> Hi, could someone tell me what the error is that I am making, trying to call Haskell from C using FFI? http://hpaste.org/84638
07:40:04 <robstewartuk> "fatal error: HsFFI.h: No such file or directory"
07:40:34 * hackagebot gdiff-th 0.1.0.6 - Generate gdiff GADTs and Instances.  http://hackage.haskell.org/package/gdiff-th-0.1.0.6 (JonathanFischoff)
07:42:55 <hpaste> Rob pasted “HsFFI.h: No such file or directory” at http://hpaste.org/84638
07:42:56 <geekosaur> robstewartuk, you should normally not ever try to directly compile a .h file, wiether with gcc or ghc
07:43:04 <hpaste> amatsu pasted “Couldn't match expected type” at http://hpaste.org/84639
07:43:14 <geekosaur> it's an include file, it is only meaningful as part of some other compilation
07:43:27 <amatsu> I'm probably pattern matching wrong, but for some reason this doesn't seem to work
07:43:38 <geekosaur> (that is, only meaningful when #include-d by some C source fiule which may need to do other setup for it to work)
07:43:54 <amatsu> I'm trying to declare a functor instance for my newtype, which is a wrapper around a vector of vectors.
07:43:58 <armlesshobo> robstewartuk: make sure the include directories are valid and contain HsFFI.h?
07:44:09 <amatsu> Is there a better way to do this?
07:44:12 <geekosaur> likely the first ghc invocation did the setup,m the second has no idea about it and should not be passed the .h file at all
07:45:53 <Rotaerk> hmm, given that mutation is encapsulated by the State monad, *on top of* a purely functional framework, is GHC capable of optimizing how this is compiled, such that mutations within State correspond to physical mutations of memory locations?
07:46:04 <hpaste> Rob revised “HsFFI.h: No such file or directory”: “Updated: undefined reference to ZCMain_main_closure” at http://hpaste.org/84638
07:46:16 <Rotaerk> well, assuming you're in a context where the state being replaced is no longer needed
07:46:50 <robstewartuk> geekosaur: armlesshobo: thanks, I've updated. This time, I'm getting an error because my module does not export a main function http://hpaste.org/84638
07:47:03 <geekosaur> yes, because you do not have Main.main, you have Foo.main
07:47:12 <aCube> Can I compile a shared library from cbits sources in cabal?
07:47:12 <geekosaur> hm, wait, not quite
07:47:31 <geekosaur> oh, I see, you are using a C main. I think you're not quite doing it right
07:47:46 <robstewartuk> geekosaur: quite.
07:48:06 <robstewartuk> yes, I want to export foo in Foo as a library
07:48:11 <geekosaur> lemme check how that works; having a C main() is somewhat different to work with than using a Haskell Main.main
07:48:12 <robstewartuk> to be used by C
07:49:15 <dcoutts> aCube: sort-of, you can compile a haskell lib as a shared lib, and that will also work for c code in the lib
07:49:53 <geekosaur> robstewartuk, " If you do use GHC, then don't forget the flag -no-hs-main, otherwise GHC will try to link to the Main Haskell module."
07:50:11 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html#using-own-main
07:51:13 <robstewartuk> that's it.
07:51:17 <robstewartuk> thank you geekosaur
07:52:05 <aCube> I'm getting the following error when loading a simple library in C++ (with export "C") to be used by the Haskell FFI: final link ... ghc: ./libmain.a: unknown symbol `__dso_handle'
07:52:53 <aCube> It works if I compile my main library into a shared library and load that one
07:55:56 <geekosaur> http://wiki.osdev.org/C%2B%2B#GCC suggests you need to provide it; possibly you should actually be linking to some libstdc++ or other C++ runtime?
07:56:35 * geekosaur thinks that page is suggesting manual implementation of several chunks of C++ runtime that should be coming from its runtime support library
07:56:35 <aCube> I used this command to compile the static library: g++ -static -c -o main.o main.c && ar rcs libmain.a main.o
07:56:47 <mm_freak> aCube: you need more flags
07:56:49 <geekosaur> yes, so where's the C++ runtime library there?
07:57:01 <geekosaur> or more likely, where is it in the final link?
07:57:34 <aCube> The error message appears when I do: ghci ./main.hs -L. -lmain -lstdc++ -lgcc_s -lc
07:57:52 <geekosaur> ghci.
07:58:09 <aCube> Is it a problem with ghci?
07:58:20 <geekosaur> I think you may lose, unless you fake it as specified by that earlier link? ghci has its own builtin linker which doesn't always behave like the system linker
07:58:57 <geekosaur> alternately try including it in your first g++ line so it's built into main.o?
07:59:01 <mm_freak> aCube: it's a problem with C++ and the FFI's failure to support it…  you may will find yourself in a situation where you can compile C++ FFI programs, but not interpret them
07:59:21 <mm_freak> aCube: your best bet is to compile the C++ stuff into a shared object
07:59:36 <mm_freak> s/will/well/
07:59:52 <geekosaur> ^^ is basically what I'm getting at, from the other end...
08:01:40 <aCube> Can I build my haskell lib as a static lib, and only build the c++ lib as a shared lib with cabal?
08:02:39 <dcoutts> aCube: no, cabal's support for building C/C++ code is always as part of the same lib, so it'd be compiled the same way as the Haskell lib (static or dynamic)
08:03:12 <aCube> so I have to build my whole library as shared for this to work?
08:03:36 <dcoutts> aCube: so you can have C/C++ code in a Haskell lib and compile the Haskell lib as a static lib, or as a dynamic lib. If you want to compile the C/C++ code as a separate lib you can do that too (building that is then outside the scope of cabal) and then link to that external lib in the usual ways
08:04:46 <aCube> ok, thank you
08:04:49 <coppro> aCube: does adding "-lgcc" help?
08:04:51 <dcoutts> aCube: what are you really trying to do? are you trying to present a C/C++ interface for this lib?
08:05:12 <dcoutts> or is it just some C/C++ helper code that you need to link into your Haskell lib
08:05:25 <aCube> coppro: no
08:06:12 <aCube> dcoutts: I'm trying to access some stuff of QML2
08:07:07 <dcoutts> aCube: ok, so the C code is for interfacing to that external lib? I'm guessing QML2 is a C++ lib, and your code is to provide some C functions you can bind to directly with the ffi
08:07:57 <dcoutts> if that's the case, then I don't see that you need to worry about whether the Haskell lib is built static or dynamic
08:17:19 <johnw> what is the typical Haskell way of setting the executable bit on a file?
08:17:36 <johnw> setFileMode?
08:20:08 <glguy> johnw: Since that's a unix-specific bit, I'd think (setFileMode) would be the right way to go for existing files
08:21:13 <glguy> For new files it might be better to go with createFile :: FilePath -> FileMode -> IO Fd
08:21:39 <johnw> oh, yeah, this is a new file
08:21:51 <johnw> thanks!
08:25:41 <Rotaerk> "Tilda Swinton is Sleeping in a Box at the Museum of Modern Art. Really. ...  The actress puts herself on display by lying in a glass box for museum-goers to see. Check it out."
08:25:46 <Rotaerk> err, wrong channel
08:35:35 * hackagebot gloss-juicy 0.1 - Load any image supported by Juicy.Pixels in your gloss application  http://hackage.haskell.org/package/gloss-juicy-0.1 (AlpMestanogullari)
08:39:35 <sordina3> I've had a mental blank... How is it possible to short circut a monadic computation with a "exit" method if >> is >>= that ignores the result of the previous statement?
08:40:18 <donri> sordina3: because the circuiting is in the effects
08:40:35 * hackagebot caledon 3.2.1.0 - a logic programming language based on the calculus of constructions  http://hackage.haskell.org/package/caledon-3.2.1.0 (MatthewMirman)
08:40:39 <donri> for example in the maybe monad with (Just 3), 3 is the "result" and Just is the effect
08:41:06 <donri> in Nothing, there is no "result" and the effect is to short circuit
08:41:54 <donri> sordina3: remember that >>= are specific to each monad
08:42:09 <donri> it's a different function for every type
08:42:11 <joker_89> hi
08:42:40 <sordina3> I under stand the maybe I'm more confused by short circuiting a set of statements where effects from before the exit are preserved.
08:42:42 <joker_89> if i need to return somtehing like this Maybe ([Int],Int,Int) and i return ([1,2],3,4) why says error?
08:43:22 <S11001001> > return ([1,2],3,4) :: Maybe ([Int],Int,Int)
08:43:23 <lambdabot>   Just ([1,2],3,4)
08:43:29 <donri> joker_89: what's the error? may need a type signature for return to be Maybe
08:43:29 <S11001001> joker_89: ?
08:43:44 <S11001001> joker_89: hpaste.org
08:44:00 <joker_89> ok
08:44:03 <sordina3> For example you may have some kind of State, ContT stack where you can say "modify (+1) >> exit >> modify (+1)" and it effectively just adds 1 rather than 2...
08:44:12 <donri> sordina3: Just a >>= f = f a; Nothing >>= f = Nothing
08:44:22 <sordina3> I swear I understood how this works recently now it's all gone :/
08:44:52 <hpaste> joker_89 pasted “maybe” at http://hpaste.org/84641
08:45:03 <joker_89> http://hpaste.org/84641
08:45:15 <sordina3> Actually, that doesn't help due to the symetry...
08:45:34 <donri> joker_89: you're missing a return or a Just at the end
08:45:36 <sordina3>  "modify (+1) >> exit >> modify (+35)""
08:45:49 <joker_89> so i need to put return?
08:46:00 <S11001001> joker_89: line 10 has the type ([Int],Int,Int), not Maybe ([Int],Int,Int)
08:46:01 <ocharles> sordina3: A good exercise in these cases is to manually evaluate the expression
08:46:01 <danr> sordina3: why don't you use the maybe monad transformer?
08:46:02 <S11001001> @quote return
08:46:02 <lambdabot> tomasz says: After all, return is only a fancy name for liftM0 :-)
08:46:12 <donri> joker_89: in the else clause you need a Maybe value, you have a plain tuple
08:46:12 <ocharles> Expand >> into >>=, and then expand >>= into the definition of >>= for Cont
08:46:20 <danr> oops that won't work
08:46:30 <joker_89> so Just ....
08:46:32 <sordina3> danr: ocharles: Yep I'm going to have to I guess.
08:46:34 <ocharles> sordina3: and then continue to simplify it
08:46:36 <donri> joker_89: yeah
08:46:50 <ocharles> sordina3: Don't be ashamed or afraid of doing that, it's a *very* powerful learning aid
08:47:07 <joker_89> if i put Just says: " Couldn't match expected type `Int' with actual type `Maybe Int'"
08:47:09 <sordina3> It's just the law saying that >> = >>= \_ ->
08:47:14 <Tesseraction> another silly question, is it possible to figure out the index of list in a recursive definition, say, [1, b..] where b equals something depending on its index?
08:47:14 <Tesseraction> or should I just provide a recursive function providing its index?
08:47:33 <sordina3> that's throwing me
08:47:34 <joker_89> ouch
08:47:36 <joker_89> nothing...
08:47:38 <donri> sordina3: >> doesn't enter into it
08:47:39 <joker_89> ok solved!
08:48:03 <sordina3> donri, well it does when that's the entirity of what's confusing me.
08:48:15 <donri> sordina3: :)
08:48:54 <donri> sordina3: remember, for a monadic computation "m a", >> ignores the "a" but not the "m"
08:48:55 <joker_89> how can i convert a Maybe to not maybe?
08:49:04 <donri> sordina3: the circuiting is in the effects, in the "m"
08:49:06 <aCube> joker_89: ?
08:49:08 <ExternalReality> Tess: you want to determin index from b given only b?
08:49:13 <S11001001> joker_89: with the function called `maybe'
08:49:19 <aCube> :t maybe
08:49:21 <lambdabot> b -> (a -> b) -> Maybe a -> b
08:49:26 <donri> joker_89: what do you want to do if it's a Nothing?
08:49:34 <aCube> > maybe 3 id $ Just 4
08:49:35 <lambdabot>   4
08:49:38 <aCube> > maybe 3 id $ Nothing
08:49:39 <lambdabot>   3
08:49:40 <sordina3> donri: Hmmm that makes sense actually.
08:49:45 <joker_89> i chec if is nothing, and else i need only a Int not Maybe Int
08:49:55 <sordina3> Okay I'm going to manually run through some code.
08:50:21 <dolio> > maybe 3 4 $ Just 5
08:50:23 <sordina3> Thanks peeps
08:50:23 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> b))
08:50:23 <lambdabot>    arising from the ambiguity chec...
08:51:03 <donri> joker_89: with the 'maybe' function you don't need the check for Nothing
08:51:50 <joker_89> the code that i put, i have a function basaCorrecte that returns a Maybe Int
08:52:19 <joker_89> and in the function that i uploaded i want to return a Maybe ([Carta], Int , Int) which the last Int is the previous Maybe Int
08:52:41 <donri> joker_89: you could use the maybe monad
08:53:04 <aCube> @ty fromMaybe
08:53:06 <lambdabot> a -> Maybe a -> a
08:53:35 <donri> > do x <- Just 2; y <- Just 3; return (x,y)
08:53:36 <lambdabot>   Just (2,3)
08:53:54 <joker_89> ok fromMaybe
08:54:22 <ExternalReality> donri: "you don't need to check for Nothing" -- didn't anyone ever teach you not to use negatives :-)
08:54:46 <ExternalReality> double negatives
08:55:40 <aCube> Can I tell in a cabal file that I want to build a shared library?
08:56:06 <dcoutts> aCube: no, that's decided by the person building the package, not the author, so it doesn't go in the .cabal file
08:56:24 <dcoutts> aCube: I'm not sure I understand why it matters to you, shouldn't it work either way?
08:56:53 <aCube> dcoutts: when I build statically, i get: final link ... ghc: dist/build/libHShsqml2-0.1.0.0.a: unknown symbol `DW.ref.__gxx_personality_v0' when I try to use the library in ghci
08:57:15 <aCube> It works fine when I build a shared lib
08:57:34 <danharaj> edwardk: I just spent 5 minutes playing around with lensisms over Kleisli and it seems like the types check out. Is this a profitable area to investigate?
08:58:04 <edwardk> danharaj: the problem is the same as with traverse vs. mapM there are none that need the Monad that comply with the laws
08:58:44 <dcoutts> aCube: ah, loading code that uses c++ is a bit tricky with ghci
08:59:34 <aCube> dcoutts: so there is no solution to this?
08:59:37 <dcoutts> aCube: it'll also work fine when you compile a standalone exe, rather than loading it in ghci
09:00:34 <dcoutts> aCube: I think loading c++ code can work, if you link in the right c++ support libs and you're not using certain c++ features that make the ghci linker cry
09:00:59 <aCube> dcoutts: Can I specify some external libraries to be included in the linker flags when something uses my package?
09:00:59 <dcoutts> I know there are some packages, like the llvm bindings that just don't work with ghci, when llvm itself is using static libs
09:01:09 <dcoutts> aCube: sure, extra-libraries:
09:01:31 <joker_89> if i have a tuple , how can i apply a function in each element?
09:01:35 <danharaj> edwardk: that is a shame. I didn't work it out but it seemed like mutable array access satisfied the lens laws.
09:01:47 <Rotaerk> joker_89, there's the "both" function
09:02:10 <edwardk> danharaj: the main issue is it spams updates it doesn't need
09:02:16 <edwardk> even reading does a write
09:02:43 <joker_89> both function?
09:03:06 <aCube> :t \f -> uncurry $ join f
09:03:07 <lambdabot> (a -> a -> b -> c) -> (a, b) -> c
09:06:10 <aCube> @hoogle (a -> c) -> (a,a) -> c
09:06:10 <lambdabot> Data.Graph.Inductive.Query.Monad orP :: (a -> Bool) -> (b -> Bool) -> (a, b) -> Bool
09:07:12 <fizbin> @djinn (a -> c) -> (a,a) -> c
09:07:13 <lambdabot> f a (b, _) = a b
09:07:21 <aCube> @hoogle (a -> c) -> (a,a) -> (c,c)
09:07:22 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
09:07:22 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
09:07:22 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
09:07:33 <c_wraith> :t join (***)
09:07:35 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
09:08:10 <aCube> @ty \f -> uncurry $ Control.Comonad.duplicate f
09:08:12 <lambdabot> Monoid b => (b -> c) -> (b, b) -> c
09:08:41 <fizbin> @djinn (a -> c) -> (a,a) -> (c,c)
09:08:41 <lambdabot> f a (b, _) = (a b, a b)
09:08:49 <aCube> :O
09:09:02 <c_wraith> haha.
09:09:09 <ClaudiusMaximus> how might i use cabal-install to build/install a foreign executable?  so far my experiments give Error: No 'Main-Is' field found for executable
09:09:22 <c_wraith> djinn's attempts to use each argument apparently don't work recursively
09:09:55 <fizbin> > let f a (b, _) = (a b, a b) in f (+1) (3,3)
09:09:56 <lambdabot>   (4,4)
09:10:07 <donri> ExternalReality: i ain't not used no negative nothing no never!
09:10:10 <aCube> ha, it works :D
09:10:39 <fizbin> > let f = join (***) in f (+1) (3,3)
09:10:41 <lambdabot>   (4,4)
09:11:18 <fizbin> > let f a (b, _) = (a b, a b) in f (+1) (3,6)
09:11:19 <lambdabot>   (4,4)
09:11:28 <fizbin> > let f a (b, _) = join (***) in f (+1) (3,3)
09:11:30 <lambdabot>   No instance for (GHC.Show.Show (a0 b0 c0 -> a0 (b0, b0) (c0, c0)))
09:11:30 <lambdabot>    arisi...
09:11:33 <quchen> c_wraith: I don't think Djinn does recursion in the first place.
09:11:47 <johnw> i can't tell if Haskell exceptions are under-designed, over-designed, or I just haven't "gotten it" yet
09:11:54 <fizbin> Oh, duh.
09:12:01 <johnw> all the simple use cases seem much harder than I think they should be
09:12:14 <c_wraith> quchen: it doesn't do recursive types, but I was talking about things like trying to use every argument of a tuple.
09:12:28 <quchen> Oh, nevermind then.
09:12:30 <mauke> johnw: the core design seems OK but the libraries aren't using them right
09:13:13 <fizbin> johnw: I found that using ErrorT was okay, once I stopped explicitly supplying the monad to ErrorT in my type declaration.
09:14:12 <quchen> fizbin: I think he's talking about exceptions in the sense of Haskell's Exception module
09:14:23 <quchen> So no ErrorT there but catch and all that
09:14:40 <quchen> Also: damn you Haskell naming for "going wrong" libraries
09:14:46 <johnw> yes
09:14:49 <johnw> Control.Exception
09:14:51 <tac> mauke: I would agree with that.
09:15:01 <tac> Every library does errors differently for like no reason
09:15:12 <cschneid> when do I want to use the `type` command to alias things? for instance, `type Corpus = IO String`.  What does that give me?
09:15:31 <mauke> cschneid: nothing
09:15:39 <quchen> cschneid: "type" defines a synonym, just like "x = 3" defines x to be a synonym for 3.
09:15:46 <ocharles> cschneid: mostly useful for making your API easier to work with
09:15:48 <aCube> Documentation for free
09:15:52 <cschneid> sure. I was wondering about why/when to do it.
09:16:22 <c_wraith> cschneid: I almost never use type. I don't think it's used very often except by beginners.
09:16:23 <ocharles> cschneid: It also fits in with the whole Don't Repeat Yourself mantra
09:16:32 <quchen> cschneid: Well, consider "ErrorT MyError IO Int" - it may be more readable to give this a shorter name so the type signatures don't go over 80 chars every time
09:16:44 <c_wraith> There are times when it's useful - but not all that many.
09:16:47 <ocharles> for example, in my web applications, handlers might be of the type `Handler App App ()` - typing that out multiple times is repetition
09:16:57 <ocharles> so I use `type MyHandler = Handler App App ()`
09:16:58 <cschneid> quchen: good call. I do have a type `Map.Map Char Int`, which I could change to something meaningful
09:17:12 <c_wraith> Usually, if you have a complex type, it also has some meaning, in which case it's better to make it a newtype.
09:17:33 <quchen> type usually means you're too lazy to write instances for a newtype ;-)
09:18:06 <cschneid> quchen: woo! perhaps that's it.  Does newtype do anything useful if I have a Map type that I just want to give a useful name
09:18:17 <cschneid> ie, instances don't add much, since I just want it to behave like a map
09:19:02 <quchen> cschneid: newtype is an actual new type. "type" just defines a synonym. newtype can lead to safety ("newtype BankAccount = BA Int"), while type just alters notation.
09:19:04 <aCube> Can I tell cabal to use --enable-shared for only some packages by default?
09:19:30 <quchen> aCube: That's a problem when something depends on those packages.
09:19:36 <cschneid> quchen: right, I am looking to figure out which to use when. It sounds like `type` is rarely used. newtype forces me to thread that new data type through the rest of the program -- yes?
09:19:43 <cschneid> (or convert where appropriate before passing further)
09:19:48 <quchen> Yes.
09:20:05 <dcoutts> aCube: the simplest workaround is simply to test your package is to not use ghci, compile standalone progs instead
09:20:13 <quchen> "newtype" is much more similar to "data" than to "type" actually.
09:20:54 <aCube> dcoutts: But I like GHCi! :p
09:21:10 <quchen> Newtype is basically data yelling "Compiler, optimize me away after you've done your typechecking" :-)
09:24:06 <geekosaur> aCube, you're welcome to fix it not to require its own linker...
09:24:44 <geekosaur> (if it were easy, it would have been done already; nobody likes having to maintain a separate special linker)
09:28:44 <cschneid> I have Int -> Int -> Float as a method signature. How do I do the division of two whole number ints to a float?
09:29:09 <danharaj> :t \x y -> fromIntegral x / fromIntegral y
09:29:10 <lambdabot> (Fractional a, Integral a2, Integral a1) => a1 -> a2 -> a
09:29:15 <franco00> I have a signature like :: SomeState -> TypeA -> TypeB . How to 'translate' it to use a State monad? Is it even possible?
09:29:17 <aCube> > fromInteger (1 :: Int)  / fromInteger (2 :: Int)
09:29:18 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
09:29:18 <lambdabot>              with a...
09:29:22 <aCube> :O
09:29:37 <cschneid> danharaj: ahh, I have to explicitly cast them to a floating point type
09:29:43 <danharaj> cschneid: indeed
09:29:50 <cschneid> cool
09:29:53 <cschneid> stupid strict language :)
09:29:58 <cschneid> (smarter than I!)
09:30:00 <danharaj> no, haskell is nonstrict
09:30:08 <danharaj> (zing)
09:30:15 <cschneid> hah
09:30:16 <k00mi> aCube: fromInteger /= fromIntegral
09:30:33 <cschneid> stupid english being vague
09:30:40 <danharaj> franco00:
09:30:42 <danharaj> :t state
09:30:43 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
09:30:54 <danharaj> also
09:30:56 <danharaj> :t get
09:30:58 <danharaj> :t put
09:30:58 <lambdabot> MonadState s m => m s
09:30:59 <lambdabot> MonadState s m => s -> m ()
09:36:16 <franco00> thanks danharaj
09:53:01 <cschneid> https://gist.github.com/cschneid/478291f3fd7149dfb0a8 -- This works, but I'd like to turn my runner function (operationSolve) into a one or two liner. How can I avoid that placeholder name 'freq'?
09:54:29 <glguy> print . normalizeFrequencies . getFrequencies =<< readCorpus corpusFile -- if you just want it to be on one line
09:56:14 <cschneid> glguy: can you walk me through that? The IO monad's let vs. <- binding vs. =<< stuff is confusing for me
09:57:29 <glguy> cschneid: Perhaps you could read http://book.realworldhaskell.org/read/monads.html#monads.do and then come back with questions you have from it?
09:57:38 <cschneid> glguy: will do
09:58:37 <beaky> hello
09:59:06 <beaky> what is the difference between first-class functions and higher order functions?
09:59:43 <sipa> beaky: first-class functions: they can be assigned to variables, and passed around like other variables
09:59:51 <ion> A higher order function takes a function as a parameter, which is made possible by functions being first-class objects.
10:00:07 <sipa> beaky: higher order functions is just about functions taking other functions are arguments
10:00:12 <beaky> ah
10:00:22 <beaky> what does order mean?
10:00:34 <beaky> in that context*
10:01:25 <danharaj> draw the type as a tree where each branch is a ->
10:01:40 <danharaj> order is the max amount of left branches you can take
10:01:44 <beaky> ah
10:01:46 <danharaj> (or something like that)
10:03:32 <acowley> It is a bit confusing in that you can't very well have higher order functions without first-class functions.
10:04:23 <acowley> The thing about order is that a function of type (Int -> (Float -> (Char -> ()))) isn't higher order.
10:04:37 <beaky> ah :(
10:04:48 <beaky> i would think ut was since it returned a fuctiom
10:04:51 <beaky> function*
10:06:41 <beaky> so with automatic currying, all haskell functions are just first-order?
10:07:13 <beaky> or are they all higher order (except for single arg ones)? i am so confused :(
10:07:16 <danharaj> (a -> b) -> c is not first order
10:07:28 <danharaj> This isn't something worth being confused about.
10:07:34 <beaky> ah
10:07:50 <danharaj> "Higher-order" isn't a very interesting phrase.
10:07:50 <acowley> No it's not
10:08:08 <acowley> I'm probably not helping, and maybe someone might want to call every multi-argument function in Haskell higher order.
10:08:48 <cschneid> if I start getting used to IO monad, what's another generally useful one I should check out? List seems cool, State (?) perhaps?
10:08:52 <acowley> It's only interesting in so far as it reflects the ubiquity of first-class functions. Which, once you accept it, is also uninteresting! (Like all good ideas)
10:09:02 <cschneid> I know it's also just the problems I have that makes sense
10:09:14 <danharaj> cschneid: list comprehensions are the list monad so yeah
10:09:45 <cschneid> danharaj: so [stuff | otherstuff] is actually the list monad?
10:09:46 <sproingie> cschneid: Maybe is an easy one
10:10:04 <sproingie> State is actually a little tricky if you ask me
10:10:07 <danharaj> cschneid: yes. good exercise: rewrite list comprehensions in do notation
10:10:09 <cschneid> sproingie: good call, I need to figure out using Maybe better. So far I sorta have it working but is ugly
10:10:12 <sproingie> cschneid: Reader and Writer are good ones too
10:10:13 <Philippa> beaky: We treat to define "order" to respect currying, so that you don't have to be confused about it. That's why the "left branch" bit
10:10:17 <danharaj> (and then promptly rewrite them back because GHC optimizes list comprehensions more)
10:10:31 <beaky> ah
10:10:37 <sproingie> State's a little easier once you get Reader
10:10:57 <sproingie> since they both deal with functions as monads
10:12:14 <acowley> beaky: I parenthesized that multi-argument function the way I did because you really want to think about it as (Int -> X) rather than (Int -> (Float -> (Char -> ())))
10:12:32 <sproingie> you could also just go straight to Cont, after which you will have grasped the true Tao of Monads :)
10:12:43 * sproingie hasnt gotten that far yet
10:12:52 <beaky> even if i am confused by order, i understand that first-class functions are one of the most powerful things in programming
10:13:16 <acowley> beaky: that's the main thing to take away, so you're already streets ahead
10:13:31 <danharaj> Does anyone have experience with a graph data structure library like fgl?
10:13:40 <johnw> i do, but not in Haskell :)
10:13:44 <quchen> cschneid: Basic Haskell is IO, Maybe, Either, List, Reader, Writer, State. I'd rate the difficulty understanding them as Maybe = Either < IO < List < Reader = Writer < State.
10:14:12 <cschneid> cool. quchen, I just copied that down, I'll work my way through it
10:14:19 <cschneid> reading the top level docs on Reader seems pretty cool
10:14:37 <cschneid> useful.
10:14:59 <quchen> cschneid: They're all somewhat easy to understand on the practical side of things. The implementation difficulty order looks a lot different. (IO is off the scale in the right, for one)
10:15:12 <cschneid> yeah, but that's not my problem as a programmer.
10:15:50 <cschneid> general workflow is starting to click though, which is cool. implemented a new feature in just a few minutes, rather than the few hours last night..
10:15:54 <quchen> cschneid: Well, it's often useful to understand the stuff you have practical knowledge of. The monad instance for Maybe is very easy for example.
10:16:30 <cschneid> sure. I'll get to that point, I'm explicitly focusing on accomplishing working code. I've failed to learn in the past by diving into the mathy technical side
10:16:45 <cschneid> ya'll in here have been super helpful
10:16:46 <beaky> e.g. with first-class functions, i can have a function that maps environmental details into an AI function/algorithm best suited for that environment
10:16:50 <sproingie> i've never been good at the mathy parts either :)
10:17:17 <sproingie> any greek letters other than lambda and i start to cringe
10:17:22 <quchen> sproingie: The implementations of those monads aren't very mathy.
10:17:30 <cschneid> heh, I can't even name them beyond lambda.
10:17:34 <cschneid> "ohh, that's a SQUIGLY"
10:17:37 <johnw> you know alpha!
10:17:42 <beaky> why do mathematicians love greek and not roman
10:17:49 <sproingie> they ran out of roman letters
10:17:51 <johnw> beaky: roman is already over-used
10:17:54 <beaky> ah
10:17:56 <tromp> > 1920 % 1080
10:17:57 <ion> and omicron
10:17:58 <lambdabot>   Not in scope: `%'
10:17:58 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
10:18:02 <johnw> be glad they didn't all know armenian
10:18:08 <tromp> > 1920 R.% 1080
10:18:10 <lambdabot>   16 % 9
10:18:22 <sproingie> johnw: or chinese
10:18:47 <cschneid> just as inscrutable as greek...
10:18:49 <beaky> i always get nervous when i see greek letters besides pi and lambda too :(
10:18:50 <quchen> א: Sup guys can I play?
10:19:01 <quchen> NO we have enough letters already
10:19:05 <quchen> Go away Aleph
10:19:08 <sproingie> lot of gamma in type notation
10:19:31 <beaky> fortunately nobody uses unicode in haskell code :D
10:19:39 <mcstar> they do
10:19:47 <quchen> beaky: I've seen some nasty things on Hackage.
10:20:00 <sproingie> > let a ☠ b = a * b in 2 ☠ 3
10:20:01 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
10:20:05 <sproingie> bah
10:20:09 <quchen> Use (skull)
10:20:13 <sproingie> lambdabot has unicode issues
10:20:41 <beaky> haskell would look like APL :D
10:20:42 <ParahSailin> 甲乙丙丁戊己庚辛壬癸
10:20:44 <Hannibal_Smith> <beaky> fortunately nobody uses unicode in haskell code :D <-But it's so funny! http://unicodeemoticons.com
10:21:05 <Hannibal_Smith> ಠ_ಠ
10:21:13 <johnw> let ☕ x = x x x x x x x x
10:21:26 <FireFly> let (∘) = (.)
10:21:30 <FireFly> mmm unicode
10:21:34 <johnw> FireFly: that's built-in
10:21:39 <johnw> just enable UnicodeSyntax
10:21:43 <cschneid> lol, are most unicode chars valid?
10:21:48 <cschneid> valid identifiers
10:21:55 <Philippa> sproingie: a fair few tau, too
10:21:56 <johnw> some of them are operators
10:21:57 <quchen> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:%E2%84%A4
10:22:00 <quchen> AAAAA
10:22:21 <Taneb> johnw, I think UnicodeSyntax is just syntax
10:22:27 <FireFly> cschneid: all letter characters are valid in identifiers and operator characters in operators, basically
10:22:36 <Taneb> The replacement functions are mainly in base-unicode-symbols
10:22:37 <johnw> but it maps . to ∙, for example
10:22:45 <johnw> or, ∘ rather
10:22:47 <mcstar> it ❆ here
10:22:54 <johnw> and I mean the reverse of what I said
10:22:56 <cschneid> cool. I've seen some hilarious... ruby... I think ... code that uses non breaking space as an identifier.
10:22:59 <cschneid> that's confusing :)
10:23:02 <johnw> ∘ is taken as .
10:23:18 <glguy> GHC doesn't know about combining characters, so you can't use them when defining identifiers, for example
10:23:19 <johnw> Taneb: Ah, I see what you mean
10:28:01 <LambdaDusk> so when is the next haskell platform for windows coming out?
10:29:29 <quchen> LambdaDusk: May 6th is the scheduled date for final release candidates
10:29:38 <LambdaDusk> oh man
10:29:49 <quchen> Other than that I don't know much about when it's actually coming out.
10:29:55 <quchen> What's wrong with the last platform?
10:30:01 <LambdaDusk> it's outdated
10:30:15 <quchen> It's not even half a year old.
10:30:20 <mcstar> the new one will be outdated soon too
10:30:27 <quchen> Being old isn't bad. Being incompatible with something is bad.
10:30:35 <LambdaDusk> trying to install current cabal packages fails because they need to re-compile time and other built-in packages
10:30:38 <LambdaDusk> which fails
10:30:54 <quchen> Install older versions of the packages?
10:31:19 <quchen> Or you could install the libs manually, starting with a clean GHC copy
10:31:38 <quchen> The platform doesn't do anything fancy you couldn't do without it
10:31:54 <cschneid> ghci> let (a,b) = splitAt 3 "foobar" in b ++ a   ---- What's the `in` operator doing?
10:31:55 <quchen> It's basically "cabal install [long list of packages]"
10:32:12 <mcstar> cschneid: thats part of the binding
10:32:13 <quchen> cschneid: "in" doesn't exist on its own. It's always "let ... in ..."
10:32:18 <ion> It’s not an operator.
10:32:26 <mcstar> you need it except in do blocks and on the toplevel
10:32:31 <quchen> "let [this stuff be that] in [this code]
10:32:31 <LambdaDusk> under windows, it also makes sure the compiler is set up properly
10:32:49 <quchen> > let a = 3 in 2 * a -- replace the a in "2 * a" with 3
10:32:51 <lambdabot>   6
10:32:57 <cschneid> sorry for misusing 'operator' I meant language element thingy.
10:33:24 <quchen> cschneid: You can see it as a prefix version of "where" to some extent
10:34:00 <mcstar> i think 'in' is pretty straightforward
10:34:02 <cschneid> so that line swaps to "barfoo".  It does the split, then combines them back down with ++?
10:34:37 <cschneid> splitAt assigns to a,b and then combines down in the `in` section at the end of the line.
10:34:45 <mcstar> binds
10:34:48 <LambdaDusk> oh great now nothing works any more, no install or reinstall
10:34:48 <cschneid> fun. Just ran across syntax I hadn't seen.
10:35:29 <quchen> splitAt 3 "foobar" evaluates to ("foo", "bar"). This is then pattern matched against (a,b), which binds a to "foo" and b to "bar". After the "in" you're using "a ++ b", which then becomes '"foo" ++ "bar"'.
10:36:25 <quchen> > let (a,b) = ("hello", 3) in (b,a)
10:36:27 <lambdabot>   (3,"hello")
10:36:43 <quchen> > let (a,b) = ("hello", 3) in a ++ show b
10:36:44 <mcstar> quchen: i think you should start your evaluation from the implicit print, and carry forward
10:36:45 <lambdabot>   "hello3"
10:38:59 <quchen> cschneid: Here's the LYAH chapter on let...in: http://learnyouahaskell.com/syntax-in-functions#let-it-be
10:39:13 <cschneid> cool
10:39:17 <quchen> (Also: read the entire thing!)
10:39:30 <cschneid> yeah, I've sabotaged myself before by reading more than trying.
10:39:41 <cschneid> so I'm doing actual code, and then looping back to docs where needed.,
10:39:47 <cschneid> getting better at hoogle in the process too
10:40:24 <quchen> You can also sabotage yourself by not learning your alphabet before writing ;-)
10:40:42 <skp> hi
10:41:05 <supki> > ("hello", 3) & _2 %~ show & view both
10:41:07 <cschneid> quchen: back to greek letters!
10:41:07 <lambdabot>   "hello3"
10:41:54 <quchen> cschneid: I know them all but not their order. I use Greek letters because I think painting smileys is silly, and my prof complains when I use cyrillic in my Latex.
10:42:08 <quchen> That's about it. Also OT.
10:46:21 <LambdaDusk> according to my antivirus, haskell is very, very dangerous
10:46:33 <coppro> very ver?
10:46:34 <coppro> *very
10:46:52 <quchen> main = system "rm -rf /"
10:47:02 <quchen> main = $(system "rm -rf /") -- hihi
10:48:03 <c_wraith> you forgot a runIO
10:48:05 <newsham> > system "rm -rf /"
10:48:07 <lambdabot>   Not in scope: `system'
10:48:24 <quchen> newsham: You have to do it in your own GHCi.
10:48:33 <quchen> Also use ~ not /.
10:48:39 <newsham> oh.
10:48:41 <newsham> 1 sec.
10:48:45 <quchen> ;-)
10:48:52 <newsham> /sign virgo
10:49:08 <newsham> reading my horror scope first
10:49:13 <tgeeky> virgos are the ones who like destroying the world around them, that they built, right?
10:50:21 <newsham> freenode has a pretty horrible horoscope today
10:51:37 <beaky> "Unknown command 'sign'" :(
10:55:00 <parcs> does anybody have a preferred haskell actors library?
10:55:17 <johnw> there really should be a library called thespians
10:55:41 <jfischoff> what do people recommend for storing date-time these days? I need millisecond accuracy btw
10:55:55 <johnw> I use UTCTime
10:56:06 <johnw> i believe it has nonosecond accuracy
10:56:29 <johnw> 10^-12
10:56:36 <osfameron> nonoseconds are what Oliver wasn't allowed?
10:56:42 <johnw> i believe that's picoseconds
10:56:47 <jfischoff> johnw: in Data.Time?
10:56:50 <johnw> now, what your system will give you is another matter
10:56:51 <johnw> yes
10:56:56 <johnw> in the 'time' package
10:57:57 <mcstar> what are non-sql database like solutions that haskell supports well?
10:58:07 <jfischoff> johnw: yeah that is perfect
10:58:28 <uniquenick> is there a concise/simple way to make it so I can add types like "Foo Int Int Int" together?
10:58:38 <johnw> "add types"?
10:58:47 <johnw> you mean, you want to group them?
10:58:50 <mcstar> instance Num Foo where...
10:59:00 <aristid> johnw: nanoX is 10^-9 :)
10:59:03 <uniquenick> add Foos where Foos are just a wrapper around a bunch of Ints
10:59:21 <sproingie> ohnosecond: the unit of time between when you realize you fucked up and when you realize you really *really* fucked up
10:59:27 <beaky> liftM2 (+)?
10:59:40 <uniquenick> I figured Control.Lens would have something, but I couldn't figure it out
10:59:41 <mcstar> what?
10:59:57 <jfischoff> uniquenick: what mcstar and beaky are hinting at
11:00:08 <johnw> sproingie: :)
11:00:25 <ion> uniquenick: instance Num a => Num Foo a a a where …
11:00:39 <jfischoff> @remember sproingie ohnosecond: the unit of time between when you realize you fucked up and when you realize you really *really* fucked up
11:00:39 <lambdabot> Done.
11:00:40 <mcstar> it is Int already
11:01:56 <mcstar> (also, if you just need a tuple of Ints, there is probably some package that has vectors, and + is overloaded for them)
11:02:40 <uniquenick> well it is a ton of Ints really, not 3.  so having record syntax labels for them is rather helpful
11:02:44 <jfischoff> @hackage NumericInstances
11:02:45 <lambdabot> http://hackage.haskell.org/package/NumericInstances
11:03:41 <mcstar> so, anyone on databases?
11:04:01 <jfischoff> uniquenick: Just make a Num instance and you should be set
11:04:06 <mcstar> maybe i should check the wiki, if memory serves theres an 'applications' section
11:04:26 <jfischoff> mcstar: you mean working on a haskell database?
11:04:32 <mcstar> no
11:04:33 <uniquenick> making the actual addition function was what I was wondering about though, not the instance.
11:04:45 <mcstar> a database solution that is non-sql
11:05:01 <mcstar> some persistent and queryable storage
11:05:12 <mcstar> and 'native' to haskell
11:05:12 <uniquenick> was wondering if there was some magic thing like lensing "allOf (+) mything1 mything2" or something like that
11:05:25 <jfischoff> there is analytics, but it is still in progress
11:05:26 <uniquenick> rather than writing out a1+a2 b1+b2, etc, etc
11:05:57 <croikle> mcstar: acid-state?
11:06:15 <mcstar> coppro: i heard of that, but im unsure what does it do?
11:06:37 <uniquenick> gives you acid guarentees for haskell data
11:06:49 <croikle> store your haskell objects
11:06:56 <mcstar> does it have a daemon, or just i access some file from haskell?
11:07:01 <sproingie> there's various nosql clients for haskell
11:07:22 <tgeeky> mcstar: I was going to ask if you meant the buzzword "NoSQL", meaning the many non-SQL or non-relational databases, but it seems you want something more haskell native.
11:07:25 <sproingie> looks like there's even a cassandra client.  i should poke around at that sometime.
11:07:34 <uniquenick> it is a library you use in your app.  it deals with writing out files for you
11:07:51 <mcstar> tgeeky: i didnt mean NoSql, just something that is not a wrapper for sql databases
11:07:58 <uniquenick> all your data has to fit in RAM though
11:08:13 <tgeeky> ... unless you can persist it to a file
11:08:13 <mcstar> basically, i want to log things
11:08:26 <coppro> mcstar: ?
11:08:31 <ab9rf> do you want to unlog them too?
11:08:36 <mcstar> no
11:08:45 <mcstar> but i want to search it
11:08:48 <uniquenick> that is exactly acid-state.  it logs your state changes, and replays the log on startup
11:08:55 <uniquenick> and lets you do checkpoints
11:09:24 <ab9rf> uniquenick: i think he more means 'debugging/event log' rather than 'transactional log'
11:09:40 <mcstar> coppro: a question of a single question mark is rather ambiguous, dont ask me that again
11:09:42 <mcstar> or else...
11:10:10 <ab9rf> mcstar: usually if someone says a single question mark at you, it means something yo said was incoherent
11:10:15 <sproingie> mcstar: you misdirected a comment at him
11:10:36 <mcstar> i see
11:11:08 <tgeeky> ab9rf: I'm glad people don't often do that to me, since most of what I say is incoherent.
11:11:09 <ab9rf> mcstar: in this case, you acted inexplicably, and then you threatened him when he reacted predictably to your inexplicabnle behavior.  could you, perhaps, be a bit less hostile?
11:11:40 <mcstar> ab9rf: wth? are you serious with this?
11:11:50 <mcstar> or part of a joke, in which case, im okay with your comment
11:11:54 <jfischoff> uniquenick: If your type is polymorphic then you can make an Applicative instance and use liftA2 (+). Or if it is monomorphic … there might be a lens solution
11:12:23 <geekosaur> mcstar, that "or else..." was at best overreacting
11:12:31 <sproingie> the irony/sarcasm/facetiousness inference algorithm of the internet is not very robust
11:12:31 <jfischoff> i.e. instance Applicative Foo where pure a = Foo a a a; (Foo f g h) <*> (Foo a b c) = Test (f a) (g b) (h c);
11:12:34 <mcstar> ... j/k?
11:12:42 <Philippa> not a good way to kid in here
11:12:55 <mcstar> in that case, i gtfo
11:13:03 <tgeeky> Philippa: ah! speaking of which, are you going to unban me from #haskell-blah yet?
11:13:12 <LambdaDusk> the problem is that I can't install a new "network" on windows - ./configure script required
11:13:15 <sproingie> mmmkay then
11:13:51 <sproingie> more argument for hackage having compiled binaries
11:14:17 <tgeeky> can someone quote my last statement, in case I'm being /ignored by Philippa?
11:14:28 <glguy> tgeeky: This is not the right channel for that discussion
11:14:37 <tgeeky> glguy: there is no right channel for that discussion?
11:14:44 <ab9rf> tgeeky: that doesn't make this one right
11:14:52 <tgeeky> no, but the evasion itself isn't right.
11:15:05 <sproingie> yay drama
11:15:06 <ab9rf> tgeeky: i don't care
11:15:26 <tgeeky> ab9rf: noted
11:18:28 <monochrom> Haskell Platform has the network package pre-built for windows
11:20:40 * hackagebot unix-compat 0.4.1.1 - Portable POSIX-compatibility layer.  http://hackage.haskell.org/package/unix-compat-0.4.1.1 (JacobStanley)
11:26:39 <edwardk> uniquenick: in general lens doesn't offer any tools for zipping structures together
11:28:52 <tgeeky> edwardk: what high-level statement explains that? lenses are for set/getting in reusuable ways, but not for combining lenses?
11:30:13 <edwardk> we have lots of ways to combine lenses, but the thing is in general the lenses don't know how to compose the 'bokeh' worth of stuff not viewed by the lens.
11:31:00 <jfischoff> I like the bokeh imagery
11:31:10 <tgeeky> 1) cool word. 2) I see.
11:31:23 <edwardk> you would =)
11:31:32 <jfischoff> hehe
11:32:02 <jfischoff> when do think lens 3.9 is coming out?
11:32:09 <edwardk> todayish
11:32:27 <jfischoff> oh sweet! I wrote a little package to go along with it.
11:32:38 <monochrom> you're making me google for boken
11:32:42 <monochrom> err, bokeh
11:32:58 <tgeeky> monochrom: it's the out of focus part of a picture
11:32:59 <jfischoff> some TH code for creating Field lenses
11:33:09 <jfischoff> *err combining them
11:33:16 <monochrom> yikes, darn you puns
11:33:26 <monochrom> I mean hahaha
11:33:27 <tgeeky> jfischoff: Field like vector space Field?
11:33:33 <jfischoff> no
11:33:40 <tgeeky> jfischoff: like record field?
11:33:43 <lispy> What should I read for an introduction to refinement types (eg., what are they, what problems do they help solve, etc)
11:34:09 <jfischoff> yeah..let me put the code online and I'll show you…there also might already be a way to do this without TH
11:34:11 <tgeeky> lispy: I found the liquidhaskell blog to be pretty accessible
11:35:53 <lispy> tgeeky: ah, I thought their definition was a specialization, but it does seem to match the definition on wikipedia.
11:38:41 <lispy> Is it a stretch to say that type classes are refinement types?
11:39:32 <lispy> I guess that wording is akward. What I mean is, we can use type classes in type signatures as predicates on types. Thus, I think it follows that some uses of type classes in haskell provide type refinement.
11:40:50 <c_wraith> lispy: I think the fact that type classes are open prevents that from being of much practical use
11:45:00 <haskellhero> how can i efficiently serialize a strict hashmap ?
11:45:09 <haskellhero> im using toList which is not efficient
11:45:26 <Cale> lispy: Typeclasses provide predicates on types, not new types whose values satisfy a predicate
11:46:13 <Cale> haskellhero: Why is it not efficient?
11:46:16 <sproingie> i thought types were predicates?
11:46:56 <Cale> sproingie: Refinement types are for types what set comprehensions are for sets.
11:47:03 <alanz> mcstar: have you looked at TCache? It is on hackage
11:47:33 <haskellhero> Cale: it takes ages, my haskell hero skills are not yet high enough to allow me the power of correctly interpret why this happens
11:47:34 <Cale> haskellhero: Are you having a specific performance issue related to using toList, or are you just assuming that's inefficient without trying it? :)
11:47:43 <Cale> hmm
11:47:51 <haskellhero> i assume
11:48:21 <Taneb> haskellhero, isn't toList O(n)?
11:48:29 <sproingie> Cale: ah, so the difference is it's always in terms of a base type?
11:48:55 <Cale> haskellhero: The toList in unordered-containers is defined in terms of build, and so it should be fused into many things which might consume the list (especially foldr)
11:49:07 <Cale> (at least so long as optimisations are turned on)
11:49:16 <Cale> sproingie: yeah
11:50:13 <Cale> haskellhero: however, you should also be concerned about whether a lot of the time you're seeing is being spent on forcing the evaluation of the hashmap itself.
11:50:25 <monochrom> "non-negative integers" is a much sought refinement type of "integer"
11:50:44 <sproingie> "non-empty list" is one i'd love to have handy
11:50:45 <haskellhero> Cale: im actually reading this from this, in safe-copy
11:51:04 <haskellhero> s/this/disk
11:51:04 <monochrom> also "integers between 0 and 100" for array indexes
11:52:02 <Taneb> haskellhero, toList is O(n), which is as quick as it can be (because you need to look at all the elements), and you're stuck with that
11:52:06 <Cale> haskellhero: I'm still a little unclear on whether you have a program which runs and is too slow or not
11:52:16 <aristid> monochrom: i do wish there was an unlimited-size Word type in addition to Word64 et al
11:52:20 <Taneb> haskellhero, try deepseq'ing it first when timing it
11:53:15 <haskellhero> ok, thank you
11:53:22 <skuggi> aristid: a Wordeger?
11:53:49 <aristid> skuggi: *yawn* :P
11:53:50 <haskellhero> Cale, im not running with -O, im going to try with it turned on when im finished with this
11:54:06 <haskellhero> i can't have the luxury of high compile times right now
11:54:16 <Cale> haskellhero: It is pointless to measure the performance of haskell programs without optimisations turned on
11:54:52 <monochrom> -O doesn't take that much compile time in my shallow experience
11:55:14 <haskellhero> true, i was being naive and foolish by doing such measurements in such a non-deterministic way
11:55:16 <Cale> haskellhero: -O and -O2 will at times change the asymptotic complexity of programs, and even when it doesn't, it frequently changes the constant factors by huge margins
11:55:21 <monochrom> but it's up to you. just bear in mind what "fair comparison" means
11:55:25 <lispy> Cale: Ahhhh...
11:55:59 <lispy> Cale: It's a new type, but it can be used in the same places as the unrefined type, right?
11:58:17 <Cale> lispy: That would be the idea, yeah
11:58:55 <Cale> lispy: (I don't know whether there are systems which restrict the places where refinement types may be used -- it's interesting to think that they might be a different kind)
11:59:11 <haskellhero> Cale and Taneb, thank you :)
11:59:18 <haskellhero> i must go now
11:59:25 <Taneb> Cale deserves a lot more thanks than I do
11:59:29 <quchen> What does O2 add to O by the way? I keep hearing it's not worth the increase in compile time every now and then
12:01:40 <Taneb> quchen, on modern machined I don't think it matters either way
12:02:22 <quchen> Taneb: Yeah, that's what the manual says: Use O2 if you have the time, but it probably won't help much
12:02:56 <quchen> "At the moment, -O2 is unlikely to produce better code than -O."
12:06:09 <aristid> -fllvm can help a lot with some kinds of code.
12:06:25 <Taneb> But not all code!
12:06:37 <ParahSailin> im doing a Data.HashTable in the ST monad with runST and the hashtable does not seem to be garbage collected when it's done
12:06:42 <jfischoff> tgeeky, ekmett: https://github.com/jfischoff/tuple-lenses/blob/master/src/Data/Tuple/Lens.hs
12:06:46 <aristid> Taneb: i wouldn't dare claim so :)
12:07:06 <Taneb> aristid, just don't want to give the wrong impression :)
12:07:26 <aristid> just saying it might be worth trying :)
12:07:39 <edwardk> s/premute/permute
12:07:54 <dmwit> ParahSailin: If you want help, you're going to have to do better than that.
12:07:55 <jfischoff> oops
12:08:28 <tgeeky> jfischoff: looks vaguely like an index notation :o
12:08:32 <edwardk> jfischoff: be warned 'declareLenses' will probably be the name of the new operation going in in 4.0 for generating them with a top level data decl
12:08:35 <jfischoff> pretty pretty pretty ugly
12:08:46 <tgeeky> jfischoff: I wasn't going to say it
12:08:49 <tgeeky> jfischoff: but I agree :o
12:08:52 <jfischoff> ah I'll change it
12:08:52 <edwardk> so perhaps you want something like declareTuples, etc.
12:08:59 <jfischoff> there you go
12:09:14 <edwardk> or makeTuples to match the other naming convention
12:09:20 <edwardk> since declares will probably take splices
12:09:26 <edwardk> er i mean take quotations
12:09:50 <ParahSailin> dmwit: i allocate hashtable with "new" and do a bunch of lookups and insertions and then toList the hashtable as the return value of the ST computation
12:10:08 <edwardk> jfischoff: do you want to just add this to Control.Lens.TH ?
12:10:21 <ParahSailin> dmwit: and it seems as though the hashtable remains allocated after the runST
12:10:37 <jfischoff> edwardk: It really increasing the build time is my only worry
12:10:42 <edwardk> ah
12:10:46 <jfischoff> perhaps just the TH part
12:10:54 <edwardk> then perhaps i'd ask folks in the #haskell-lens channel and see what they think
12:10:59 <jfischoff> not the generated lenses
12:11:00 <jfischoff> sure
12:11:05 <edwardk> the TH part itself is easy enough
12:11:16 <edwardk> adding the actual invocation of it is somewhat worrisome
12:11:21 <jfischoff> yeah I could see adding that
12:11:43 <dmwit> ParahSailin: ST is lazy, so you've just created a thunk with toList inside.
12:11:48 <jfischoff> the > makeTuples . filter ((1<) . length) . subsequences $ [1..9] code be its own package
12:11:49 <dmwit> (and the hash table)
12:11:57 <edwardk> jfischoff: you've been cursed with lens access. may your inbox always be full
12:12:05 <jfischoff> haha
12:12:15 <dmwit> ParahSailin: Better guesses available pending actual code and evidence of a memory leak.
12:12:44 <danharaj> "A wizard casts a curse on you! You are now a lens maintainer."
12:12:52 <edwardk> danharaj: =)
12:13:21 <shachaf> oh no jfischoff now look at what you've done
12:13:30 <edwardk> i wonder if they should have the _'s between or should just be _234
12:13:54 <jfischoff> edwardk: then you can't go higher then 9 though right?
12:14:02 <edwardk> sure, but i like brevity ;)
12:14:10 <jfischoff> yeah … me too
12:14:27 <edwardk> and we already cap out at _9 partially for sanity reasons
12:14:33 <jfischoff> sure
12:14:42 <shachaf> "sanity" means "brevity"
12:14:45 <danharaj> wait are you adding swizzling
12:14:46 <shachaf> edwardk doesn't want a three-character identifier.
12:15:07 <jfischoff> danharaj: it is swizzling!
12:15:10 <edwardk> nah 3 chars is okay, its a 6 char identifier that causes me pain: _2_3_4
12:15:34 <dmwit> > length "_234" == 3
12:15:37 <lambdabot>   False
12:15:38 <edwardk> clearly we just need to base 64 encode it
12:15:43 <shachaf> dmwit: I was talking about _10
12:15:48 <danharaj> just like the babylonians :P
12:15:51 <tgeeky> dmwit: get ye and ye facts out of here!
12:15:53 <danharaj> (close enough anyway)
12:15:55 <byorgey> why would you ever want that no matter what it is called.
12:15:56 <edwardk> danharaj: that'd be 60
12:16:04 <shachaf> edwardk: imo unicode
12:16:06 <danharaj> edwardk: 64 is the programmer's 60
12:16:23 <jfischoff> I wonder if there is a way to make the TH input smaller, closer to _234?
12:16:24 <edwardk> byorgey: personally i don't really
12:16:35 <edwardk> dolio was ust regaling me with a tale of how he wanted it a few weeks ago though
12:16:47 <edwardk> er just
12:16:48 <danharaj> byorgey: it is common in shader code, at least
12:16:49 <shachaf> What's being discussed? A traversal of several elements of a tuple?
12:16:57 <jfischoff> byorgey: Arrow heavy programming
12:17:02 <byorgey> ugh
12:17:06 <edwardk> shachaf: its the lens that gets out those parts
12:17:17 <shachaf> Oh, a lens from a tuple to a tuple?
12:17:25 <monochrom> dolio gave you a value Just tale of type Maybe Tale
12:17:25 <edwardk> shachaf: appparently
12:18:03 <edwardk> shachaf: jfischoff wrote a TH generator for it. the question is if we should bundle that generator with lens itself
12:18:37 <danharaj> edwardk: imo lens should start trying to break up into smaller packages.
12:18:44 <shachaf> Maybe we should figure out how to compose lenses instead!
12:18:44 <edwardk> i'm thinking yes to the generator, no to the instances
12:18:51 <edwardk> danharaj: opinion noted and faq'd
12:19:00 <danharaj> edwardk: snap there is a faq now?
12:19:04 <danharaj> First documentation and now this!
12:19:20 <edwardk> https://github.com/ekmett/lens/wiki/FAQ
12:19:35 <jfischoff> shachaf: I saw this as a stop-gap
12:19:50 <edwardk> longer response https://github.com/ekmett/lens/issues/262
12:20:12 <shachaf> @where lens-faq
12:20:12 <lambdabot> I know nothing about lens-faq.
12:20:21 <shachaf> @where faq-lens
12:20:21 <lambdabot> I know nothing about faq-lens.
12:20:28 <eikke> has anyone ever written an ML compiler in Haskell going beyond paper-style things?
12:20:28 <shachaf> @where+ faq-lens https://github.com/ekmett/lens/wiki/FAQ
12:20:28 <lambdabot> I will never forget.
12:20:29 <Taneb> faq lens indeed
12:20:29 <edwardk> the short version is 'yes that'd be nice, but no its not all that possible'.
12:20:31 <danharaj> edwardk: good faq
12:21:01 <monochrom> when lens is split into many packages, the meta-package should be called: camara-bag
12:21:02 <edwardk> danharaj: we need most of the dependencies to build lens itself, and so you get no real reduction in the dependencies, just more pain for users
12:21:31 <Taneb> monochrom, lens would be difficult to split
12:21:44 <edwardk> danharaj: that said, we _have_ been making strides to make more of lens able to be used without incurring dependencies on lens itself.
12:21:52 <Taneb> You could probably filter out zipper?
12:22:06 <edwardk> danharaj: with 3.9 you can make Review and Getter and Fold values without depending on lens
12:22:20 <edwardk> Taneb: I could. That is also mentioned in the FAQ as the most splittable part
12:22:31 <danharaj> edwardk: my rationale wasn't really about build-depends but mostly the long module list. Breaking up the package into more thematic chunks means those chunks can grow independently and easier to search documentation for.
12:22:38 <edwardk> Taneb: but i'd rather encourage its adoption
12:22:38 <danharaj> It's probably not worth it anyway you slice it though.
12:22:51 <Taneb> edwardk, once it takes off, maybe
12:23:28 <edwardk> danharaj: the problem is the moment we split, lens development slows to a crawl. My experience is that if I take a big package apart the split out chunks become too painful to make big sweeping changes to
12:23:44 <danharaj> edwardk: In that case I am fully behind you on the decision.
12:23:53 <edwardk> its no longer something someone can just download and tweak they have to set up a bunch of dependencies first
12:24:01 <edwardk> and they all have to be grabbed from github, etc.
12:24:20 <edwardk> even a single second order package like analytics which depends on lens head suffers from that _one_ dependency
12:24:59 <edwardk> now that said, i'm happy to make incremental refinements that make it slightly more open and don't really make my life more complicated
12:25:21 <edwardk> we've taken to using Bifunctor + Profunctor to get Reviewable or Contravariant + Functor to get Gettable now
12:25:33 <edwardk> that way with just haskell 98 dependencies you can define values that work with most of the type lattice
12:25:39 <danharaj> Nice.
12:26:02 <danharaj> edwardk: how much can you define with haskell98 + rankNtypes?
12:26:19 <danharaj> I presume much more since most people don't need to touch the class infrastructure,.
12:26:22 <edwardk> well, the problem is you really want TH in almost anything you split out
12:26:28 <edwardk> which means you've already incurred GHC
12:26:30 <edwardk> so why bother?
12:26:37 <danharaj> indeed.
12:27:23 <edwardk> consider something like Data.HashSet.Lens
12:28:13 <edwardk> i might be able to say yeah i could make unordered-containers-lens  but then i have to either orphan all the instances over there, or i have to both depend on it in lens to put the instances in, and then put just a module with like 2 functions in another package
12:28:28 <edwardk> but on top of that we use that internally in all the plated machinery and in the template haskell code generator
12:29:11 <edwardk> so i win absolutely nothing, and just get another moving part and make every user have to depend on a separate package if they want Data.HashSet.Lens.setOf for instance.
12:29:18 <danharaj> indeed
12:29:39 <edwardk> poor 'so', he must get pinged a lot.
12:29:47 <edwardk> so: how is it going?
12:29:50 <danharaj> I suppose the extreme ideal would be if you had a time machine and could send lens back to the original haskell committee to make history play out correctly.
12:30:04 <edwardk> would work. needs rank 2 types to start with
12:30:08 <edwardk> at least to make much sense
12:30:37 <danharaj> also send back current spj
12:30:41 * hackagebot strings 1.0.0 - Functions for working with strings, including Text, ByteString, etc.  http://hackage.haskell.org/package/strings-1.0.0 (JulianFleischer)
12:30:51 <danharaj> so he can tell past spj about future GHC
12:30:52 <monochrom> there are a lot of special interest groups who want that same time machine
12:48:05 <NemesisD> hey guys. i'm writing a library that wraps a REST API. i'm trying to figure out the best interface for dealing with paginated resources. anyone know any libraries that do this well?
12:49:23 <NemesisD> one idea i had was to have optional parameters for starting page and then just expose the result as a lazy list somehow, don't know if that's the right way to do it
12:49:53 <sproingie> you're trying to unpaginate it in your client?
12:50:33 <NemesisD> sproingie: probably. id imagine most use cases would probably want to stream through all results, possibly starting at a certain page
12:50:56 <NemesisD> i have a hard time thinking of a use case where someone would want only page 17 and nothing else
12:51:36 <NemesisD> although that could be achieved with take perPageCount
12:52:35 <sproingie> so random access isn't a use case you're designing for.  i suppose lazy list then, tho i'm probably not the best one to give answers seeing's how i never groked iteratees
12:53:17 <sproingie> to say nothing of its cousins like machines
12:54:10 <NemesisD> i wrote a few libraries when i was newer to haskell that had an enumerator interface
12:54:28 <NemesisD> pretty much didn't understand my own implementation
12:55:12 <sproingie> i'm a fan of simple data structures, doesnt get much simpler than a list
12:55:54 <sipa> nothing beats Void
12:55:59 <sproingie> guess you could make it append to an arbitrary monoid
12:56:34 <shachaf> i love monoids
12:56:36 <shachaf> they are so easy
12:56:37 <sproingie> not sure if it gets more generic than that
12:56:52 <donri> i bet shachaf has that on an /alias
12:57:48 <sproingie> yah monoids rock.  got "this plus that"?  monoid!
12:58:28 * sproingie .oO( monorail! )
12:58:29 <Kaidelong> monoid morphisms are what really makes monoids awesome
12:59:52 <shachaf> sproingie: I think that's called a magma.
12:59:54 <NemesisD> hmm i wonder what the type would look like for that appending monoid approach
13:00:14 <monochrom> some magmas have an identity crisis
13:00:15 <sproingie> shachaf: yeah yeah, i'm just talking about what there's actually a convenient typeclass for
13:00:42 <NemesisD> getMetrics :: Monoid m => PaginationOptions -> m -> IO m ?
13:00:43 <sproingie> monochrom: ooh i see what you did there
13:00:48 <monochrom> hehehe
13:01:55 <shachaf> @quote identity
13:01:55 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
13:01:57 * shachaf sighs
13:02:03 <sproingie> monochrom: yeah magmas don't hang around with those zeros, they don't like to associate with them either
13:02:10 <Phonequer> Hi. Can I ask about cabal?
13:02:12 <otters> @quote magma
13:02:13 <lambdabot> ddarius says: In the spirit of that article on monoids, we should drop the term "tree" and replace it with the term "free pointed magma"
13:02:18 <monochrom> yes, please ask
13:02:41 <sproingie> goddam i just made an abstract math pun.  can i have my propeller beanie now?
13:03:21 <Phonequer> Ok. I uninstalled macports, and darcs now doesn't run because of: "dyld: Library not loaded: /opt/local/lib/libcurl.4.dylib". I have libcurl.4.dylib in /usr/lib though. Reinstalling (via cabal) the darcs package doesn't change the situation
13:04:00 <Phonequer> Like if for some misterious reason cabal decided to stick with /opt/local/lib, or something
13:04:09 <sproingie> 'which darcs'
13:04:57 <geekosaur> likely your shell did
13:05:07 <geekosaur> hash -r
13:05:11 <Phonequer> sproingie: /Users/phoneq/Library/Haskell/bin/darcs
13:05:20 <geekosaur> also check that ~/.cabal/bin is before /opt/local/bin in $PATH
13:05:38 <sproingie> hm that looks not exactly like the cabal installed version, but i dunno osx
13:05:40 <geekosaur> note that which is not a shell builtin and will not reflect what the current shell has
13:05:55 <geekosaur> sproingie, that's correct for haskell platform as installed by the ofifical platform instaler
13:06:13 <sproingie> ah you need to put ~/.cabal/bin early in your PATH
13:06:22 <monochrom> that reminds me. in bash, "which" may make mistakes. use "type" for accuracy. "type" also tells you: it's an alias, a shell-script function, or an exe
13:06:24 <geekosaur> so check that Library/Haskell/bin before /opt/local/bin in $PATH
13:06:28 <geekosaur> yes
13:06:43 <geekosaur> again, which is not a built-in, type is
13:06:44 <sproingie> i'm used to which because i often use it in backquotes
13:07:05 <geekosaur> also note that backquotes have been deprecated for something liek 10 years, use $() :)
13:07:20 <geekosaur> and I don't see what backquotes/$() have to do with type vs. which
13:07:56 <monochrom> I bet a use case is: rm `which ghc` :)
13:08:56 <monochrom> I promise to try to use $() more!
13:09:11 <Phonequer> I even removed /opt/local/bin from PATH, and it's still the same
13:09:15 <sproingie> i do use $(), just not always on the cli.  neither here nor there.
13:09:30 <sproingie> as type/which will tell you, that's not where it's finding it
13:09:46 <sproingie> ~/.cabal/bin needs to come before most everything else if you want the cabal versions to run
13:10:01 <sproingie> before your haskell platform install anyway
13:13:17 <jfischoff> pre flex seen pigworker
13:13:22 <jfischoff> :p
13:13:31 <jfischoff> preflex seen pigworker
13:13:31 <preflex>  pigworker was last seen on #haskell 336 days, 22 hours, 58 minutes and 45 seconds ago, saying: * pigworker hacked all day, hits the hay.
13:15:19 <Phonequer> sproingie: I have only ~/.cabal, no /bin in it. There is the /Users/phoneq/Library/Haskell/bin though
13:15:34 <cc> > let foo = 42; foo = 17 in foo + foo
13:15:36 <lambdabot>   <hint>:1:17: lexical error at character '\b'
13:16:02 <Phonequer> cabal-install version 0.14.0, using version 1.14.0 of the Cabal library
13:16:10 <otters> > let fo o = 10 in fo o
13:16:12 <lambdabot>   10
13:16:13 <Phonequer> oh, and it's osx
13:16:19 <cc> > let (foo,foo) = (17,42) in foo + foo
13:16:22 <lambdabot>   <hint>:1:12: lexical error at character '\b'
13:17:03 <cc> (trying to mimick https://ideone.com/vF6eSg)
13:17:27 <otters> heh, that's cool
13:17:37 <geekosaur> Phonequer, yes, on OS X with the official installer that would be correct
13:18:06 <geekosaur> this does tend to confuse people who expect the linux/unix behavior from the haskell platform
13:18:27 <geekosaur> (and just to make things more interesting, if you install the HP from macports or homebrew you do get the unix behavior)
13:18:56 <cc> > let foo = 17 in foo
13:18:58 <lambdabot>   <hint>:1:7: lexical error at character '\b'
13:19:25 <cc> > let foo = 42 in foo
13:19:27 <lambdabot>   42
13:27:15 <cc> doesn't haskell support unicode?
13:27:21 <cc> https://ideone.com/TCmdo7
13:28:04 <geekosaur> what does unicode have to do with it?
13:28:26 <sproingie> haskell does unicode fine, lambdabot less so
13:28:44 <geekosaur> backspace is not a legitimate identifier character
13:29:05 <geekosaur> this has nothing to do with unicode
13:29:10 <sproingie> indeed
13:29:26 <cc> 
13:29:28 <cc> 
13:29:38 <cc> ^
13:30:07 <sproingie> looks like a reverse H to me here
13:30:21 <sproingie> which i take to mean ctrl-H by irc convention
13:30:42 <geekosaur> I have a remapper that is showing it to be ^H
13:30:44 * hackagebot postgresql-simple 0.3.0.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.3.0.0 (LeonSmith)
13:30:44 <sproingie> identifiers do have to be printable chars
13:30:55 <cc> http://www.fileformat.info/info/unicode/char/200b/index.htm
13:31:04 <sproingie> and either entirely alphanumeric or punctuation
13:31:25 <geekosaur> cc, so why do you think that hsould be a valid identifier character?>
13:31:52 <cc> sproingle: which is a subpart of unicodes?
13:31:55 <glguy> cc, additionally you aren't able to use the newline character in a variable name
13:32:18 <geekosaur> cc, what does that have to do with it?
13:32:32 <geekosaur> * is a unicode character, that doe snot make foo*bar a valid identifier
13:32:36 <cc> oh sorry
13:32:40 <geekosaur> you seem confused about something
13:32:55 <cc> identifiers, but values have whatever unicodes
13:32:59 <geekosaur> wat
13:33:06 <quchen> ^ this
13:33:12 <geekosaur> you do not quite know what unicode is, do you?
13:33:13 <sproingie> I HAZ YER UNICODEZ
13:33:27 <cc> probably no
13:33:57 <cc> unicode nis probably a way to encode all chars
13:34:25 <cc> and just a subpart is accepted as haskell identifiers
13:35:12 <geekosaur> identifiers come from the set of Unicode characters which are identified as letters
13:35:22 <geekosaur> this is a set defined by the Unicode standard
13:35:40 <geekosaur> zero width space is not a letter character
13:35:49 <cc> okauy
13:38:36 <cc> and Java is funnily supporting them in variables
13:39:37 <sproingie> maybe with an obfuscator
13:39:51 <sproingie> obfuscators can use anything they want, the bytecode really doesn't care what a variable is named
13:48:00 <cc> are there bytecoded versions of Haskell? if the question makes sense
13:48:12 <sproingie> ghci runs bytecode
13:48:25 <sproingie> it's not intended to be portable bytecode in any sense
13:49:59 <geekosaur> there is not currently a haskell compiler targeting one of the standard bytecode-based VMs such as JVM or CLR
13:50:29 <Taneb> Isn't CLR Windows only?
13:50:33 <geekosaur> mono
13:51:08 <otters> common my bum
13:51:25 <aCube> There is some compiler for the jvm in a very early state afaik
13:51:34 <aCube> althought I don't remeber it's name
13:51:40 <sproingie> there was something targeting CLR a loooooong time back, i dont think it went anywhere
13:51:49 <geekosaur> and it claims common Language runtime, not common OS runtime
13:51:50 <sproingie> there's a haskell-ish language for the JVM called CAL
13:52:20 <sproingie> the JVM has fundamental architectural problems with running something like GHC on it
13:52:21 <geekosaur> since there are multiple languiages that compile to CLR, that seems satisfied
13:52:29 <sproingie> CLR too though probably one or two fewer
13:52:31 <c_wraith> The big problem with the JVM and CLR, for languages like haskell, is that they bake a calling convention in, and that calling convention isn't a natural match for implementing the STG
13:52:37 <geekosaur> ^^
13:53:08 <geekosaur> also some issues with foreign calls, since either you need to bake in something more specific than the existing FFI or you need to give up on supporting the existing ecosystem
13:53:16 <cc> erlang made their own VM right?
13:53:22 <sproingie> cc: yes, BEAM
13:53:22 <geekosaur> yes
13:53:51 <geekosaur> someone could conceivably do that for haskell (or even beef up the existing ghci bytecode) but it's not clear there's any interest
13:53:54 <geekosaur> in yet another VM
13:54:16 <geekosaur> erlang did it since it was useful for erlang's original purpose
13:54:49 <cc> which are long running servers?
13:55:11 <otters> what does STG stand for
13:55:15 <simpson> Vats of processes which are isolated.
13:55:22 <sproingie> otters: spinless tagless g-machine
13:55:24 <geekosaur> which are servers where theey could easily swap out running code without breaking things, yes.
13:55:24 <otters> oh
13:55:25 <simpson> otters: Spineless Tagless G-machine.
13:55:28 <sproingie> *spineless
13:55:45 <shachaf> What does "spineless" mean?
13:55:51 <geekosaur> which is something you can do relatively easily in BEAM, not so easily in JVM or CLR, and is much harder on an actual CPU in general
13:55:52 <cc> ah, yes the dynamic codechange saw that
13:56:05 <simpson> cc: Erlang's got this cool thing where consultation and loading of code is separate from running code, and so the VM lets you spawn processes inside it according to what's consulted.
13:56:38 <cc> ok
13:56:43 <simpson> It wouldn't be impossible to implement BEAM-compatible stuff in JVM. You wouldn't emit bytecode directly; you'd have a bytecode VM in Java.
13:56:50 <thoughtpolice> shachaf: i've never actually been sure. i think the original paper describing the 'spineless' aspect is ACM paywalled, of course
13:57:08 <otters> so it's Haskell -> Core -> STG -> C-- -> binary
13:57:19 <sproingie> the jvm has a lot of features that bring it pretty close to what BEAM does, just that BEAM does it specifically to meet 100% of erlang's needs
13:57:28 <simpson> There's a book on compiling Miranda-like languages. Can't remember its name. Free online.
13:57:28 <geekosaur> IIRC it's soemthing about older graph reduction algorithms required the graph be spine-strict, and spineless meant relaxing the strict part?
13:57:38 <geekosaur> something like that
13:57:39 <simpson> It talks about a tagged G-machine with spines.
13:58:11 <cc> g(arbage?)-machine
13:58:19 <sproingie> graph
13:58:26 <geekosaur> graph reduction machine
13:58:32 <thoughtpolice> simpson: i have that book in hard back :) IIRC, it doesn't really make the distinction, the G-machine as you deal with it in the book is already spineless IIRC
13:58:37 <cc> ok
13:58:41 <thoughtpolice> (and i got it for free too, what a deal!)
13:58:56 <simpson> thoughtpolice: ISTR that it talked about strictness of spines and different ways to deal with spines.
13:59:06 <simpson> But maybe I'm combining different things in my head.
13:59:18 <thoughtpolice> it's been at least 3+ years since I read it, so it's quite possible i'm wrong
14:02:08 <hpaste> roadfish pasted “what am I doing wrong when using the strictness operator?” at http://hpaste.org/84649
14:02:13 <geekosaur> so, the kind of evaluation (non-strict / "lazy") haskell does is technically done by a technique known as graph reduction. a G-machine evaluates by graph reduction. but there are various things that machine needs to do to keep track of what some value is (and inparticular whether that graph node has been reduced or not; this was originally done via pointer tagging, hence the "tagless" for STG which removed the requirement for pointer tagging)
14:02:25 <geekosaur> at least, as I understand it
14:02:53 <roadfish> geekosaur: is that an answer to my question?
14:02:59 <geekosaur> no
14:03:18 <roadfish> what is wrong with this command: f !x = True
14:03:18 <geekosaur> oddly enough, there was a discussion in progress already
14:03:27 <jfischoff> byorgey: I think I remember you saying at some point that species can only describe labeled structures, am I remembering correctly?
14:03:28 <otters> roadfish: nothing
14:03:42 <sipa> it's not really a command though
14:03:50 <otters> it's a function definition
14:03:53 <roadfish> otters: then why doesn't the program compile?
14:04:01 <otters> why don't you read the error message
14:04:03 <quchen> > let f !x = True in f "hello"
14:04:05 <lambdabot>   True
14:04:11 <quchen> Funny error message
14:04:18 <otters> > let f !x = True in f undefined
14:04:20 <lambdabot>   *Exception: Prelude.undefined
14:04:29 <quchen> Meet BangPatterns
14:04:39 <quchen> Apparently Lambdabot has them enabled by default
14:04:44 <otters> KapowPatterns
14:04:50 <geekosaur> the reasonis you didnt turn on bang patterns, so it's taken as defining an operator (!)
14:05:03 <quchen> In that case, "f !x = ... == f $! x"
14:07:58 <roadfish> I added {-# XBangPatterns #-} to x.hs but I still get the same error.
14:08:30 <sipa> drop the X
14:08:30 <otters> roadfish: {-# LANGUAGE BangPatterns #-}
14:08:34 <otters> i believe
14:08:39 <otters> correct me if i'm wrong
14:08:39 <geekosaur> that's not the right pragma, and I'm surprised it didnt complain that XBangpatterns is not a known pragma
14:08:47 <geekosaur> otters, that would be correct
14:08:56 <roadfish> otters: ok, thanks ... the final ingredient
14:09:05 <S11001001> geekosaur: parses as comment?
14:09:19 <roadfish> so some pragmas need "LANGUAGE"
14:09:19 <geekosaur> I would hope not
14:09:23 <geekosaur> but maybe it does
14:09:31 <geekosaur> roadfish, there is a well defined list of pragmas
14:10:16 <geekosaur> the -X option to ghc acts as a LANGUAGE pragma. there are other pragmas such as RULES and INLINE
14:10:28 <S11001001> geekosaur: from h2010 ch12: "An implementation is not required to respect any pragma, although pragmas that are not recognised by the implementation should be ignored."
14:10:48 <geekosaur> hm, that is kinda unfortunate. I'd like to see at least a warning
14:10:51 <roadfish> ok, for some reason I thought that LANGUAGE wasn't needed. It's always needed.
14:10:54 <cc> graph reduction in addition to lazyness can maybe give runtime optimzations?
14:11:09 <geekosaur> cc, no, graph reduction is the "how" of laziness
14:11:28 <cc> ok
14:44:09 <applicative> חג שמח
14:44:41 * geekosaur grumbles at broken irc client
14:45:45 * hackagebot repr-tree-syb 0.1.0 - Tree representation and pretty-printing of data structures based on SYB  http://hackage.haskell.org/package/repr-tree-syb-0.1.0 (NikitaVolkov)
14:45:47 <applicative> happy holiday geekosaur
14:45:47 <tdammers> irssi + urxvt + inconsolata + unifont \o/
14:46:06 <bitonic> misc-fixed <3
14:46:12 <geekosaur> yes, I got that --- after I realized it was rendered LTR and started over reading backwards
14:46:36 <applicative> oh funny
14:46:42 <geekosaur> "chamash gach" not so meaningful...
14:47:32 <tdammers> bitonic: you just out-unixed me.
14:47:42 <bitonic> tdammers: best font evar
14:48:07 * tdammers likes himself a nice subpixel-smooth font
14:48:55 <geekosaur> actually, minus the nikudot the better misreading of the LTR oneis probably chamesh gach
14:50:48 <applicative> it reversed order on the words?
14:51:11 <applicative> no I see
14:51:43 <applicative> mixing ltr and rtl alphabets is a chamber of horrors
14:52:42 <applicative> oh no another haskell book by a bright young person
14:54:57 <applicative> http://www.sthaskell.com is pretty preliminary -- no monads!
14:55:36 <applicative> he errs by not beginning with simple IO and compilation instructions
14:57:30 <applicative> it is only in the context of an IO () that a defined expression means anything
15:03:22 <BMeph> edwardk: ping... :)
15:04:11 <shachaf> BMeph: I'm afraid it isn't your day.
15:05:01 <BMeph> shachaf: I ping, and EK disconnects; maybe it isn't HIS day? ;)
15:07:59 <BMeph> Okay, I'll toss this out for general consumption, since it isn't Kmett-specific, just related to something he was talking about. Anyway, from a certain perspective, mapM and (Control.Monad.)sequence are over specific, true?
15:08:37 <hvr> is http://hackage.haskell.org/package/plugins-1.5.2.1 supposed to acutally work?
15:08:48 <BMeph> That is, neither of those functions uses a Monad-specific property for what they do.
15:08:51 <ocharles> BMeph: over specific in that there are other functions that work with more general structures, yes
15:09:56 <shachaf> BMeph: Yhey need Applicative, more or less.
15:10:16 <shachaf> Monad is asking for too much. Sadly there's no Applicative superclass.
15:13:22 <ocharles> boooooo
15:14:08 <lambdabot> eeeeeek!
15:15:35 <BMeph> Is there a Haskell version that allows such things, and if so, would it be a supertypeclass, or a typesuperclass? ;)
15:16:00 <shachaf> Haskell version?
15:16:09 <shachaf> The language allows it fine; it's a standard library issue.
15:16:20 <shachaf> class Applicative m => Monad m where ...
15:17:43 <BMeph> shachaf: As in, there have been and are now more, specifications of the language, as well as low-level discussions of "what the next version of Haskell - "Haskell'" - would be like."
15:18:12 <shachaf> Haskell' is not a version of the language, it's a process for making new versions of the language.
15:18:19 <S11001001> BMeph: neither of them use a []-specific property for what they do
15:18:41 <shachaf> The Haskell' committee seems to be pretty dead.
15:18:46 <dmwit> There have been discussions of rejiggering the Prelude. There may even be a Haskell' proposal.
15:19:08 <dmwit> It's unfortunately a lot of work, not from a specification perspective, but from a "amount of Hackage code that has to be inspected" perspective.
15:20:27 <BMeph> dmwit: We have gwern, so what's the problem? ;)
15:20:56 <dmwit> Having a gwern is nice, but this isn't a job for grep.
15:22:23 <BMeph> Well, TBH, by "we have gwern," I pretty much mean "gwern is active in the community, and we haven't yet found the proper combination of neglect, abuse and taking-for-granted to drive him out of being active in it." :)
15:23:35 * BMeph commits to NOT supporting a committee to find such a combination...Promise!
15:24:10 <k00mi> gwern:
15:24:12 <k00mi> woops
15:24:20 <k00mi> ignore :/
15:25:43 <gwern> BMeph: when I dropped the project, I was using haskell-src-exts to actually parse source code instead of relying on grep. but these days i'm more interested in statistics, which means R and not Haskell
15:26:28 <gwern> BMeph: hence my general inactivity over the past year
15:30:30 <tgeeky> gwern: as long as you R enjoying yourself
15:31:22 <gwern> tgeeky: to be honest, R is an awful language especially for a haskeller
15:32:05 <gwern> tgeeky: it just has tons of stats built in and a huge library ecosystem. the actual language itself ranges from OK to wretched
15:33:37 <tgeeky> gwern: I had a bad initial impression of it, but I'm glad to learn its ecosystem is a redeeming factor.
15:33:47 <tgeeky> I was just going for a pun so bad that I might be smited.
15:40:00 <bbloom> is there a good list somewhere of monads and their corresponding co-monadic duals with names for them?
15:41:19 <donri> @hackage comonad-transformers
15:41:20 <lambdabot> http://hackage.haskell.org/package/comonad-transformers
15:42:58 <shachaf> bbloom: What is a co-monadic dual?
15:43:15 <bbloom> shachaf: i'm not quite sure yet :-P
15:43:49 <ab9rf> gwern: i used R a bit for some numerical stuff i was doing a couple years ago.  as a programming language goes it's meh but the ecosystem for numerical and stats work is fairly decent.
15:44:10 <shachaf> Perhaps you mean a comonad W and a monad isomorphic to M a = forall r. W (a -> r) -> r
15:44:30 <bbloom> donri: thanks, digging in to some of those mention things, like Env being coreader and Store being costate, but i still haven't found names for the the standard haskell monads, like Maybe and Either
15:44:38 <shachaf> bbloom: But in general you shouldn't expect to find a Haskell comonad corresponding to every Haskell monad.
15:45:08 <shachaf> bbloom: "Coreader" and "Costate" are often considered bad names for those comonads.
15:45:18 <nabil_kadimi> Hi, I'm investigating haskell, cause I want to learn some really good language that I can be proud of using, what is Haskell used for.???
15:45:23 <shachaf> They're not really duals, at least not in any standard sense of the word "dual".
15:45:32 <shachaf> nabil_kadimi: See the FAQ:
15:45:34 <shachaf> @where faq
15:45:34 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
15:45:44 <nabil_kadimi> TY
15:45:46 <bbloom> shachaf: ok, so let's narrow my question down a bit then
15:47:43 <bbloom> shachaf: looking at just the type of the Maybe monad's bind function:    Maybe a -> (a -> Maybe b) -> Maybe b
15:48:03 <bbloom> shachaf: my understanding is that you turn the arrows around to get a some co-monad that does something (whether or not that something is itneresting)
15:48:32 <bbloom> so if you sub Maybe for "w" being a comonad, you get:      w a <- (a <- w b) <- w b
15:48:33 <shachaf> Those ->s aren't really the arrows that you turn around. :-)
15:48:52 <bbloom> well yeah not in any real haskell syntax lol
15:49:00 <ion> ↓
15:49:01 <shachaf> Every Haskell monad is a comonad, but not a Haskell comonad. It's a comonad in Hask^op.
15:49:33 <bbloom> but that gives you:   w b -> (w b -> a) -> w a     and isn't that the comonad "extract" signature?
15:49:39 <tgeeky> ion: I've seen a lot of use of "^" to direct to a good answer, but never a down arrow.
15:49:58 <otters> nabil_kadimi: anything
15:50:02 <shachaf> bbloom: Sure, that's extend.
15:50:06 <ion> ↻
15:50:17 <shachaf> bbloom: Well, the type you wrote is the type of extend.
15:50:28 <shachaf> But I'm not sure what you're getting at.
15:50:37 <bbloom> shachaf: my question is that if m is Maybe, what is w ?
15:50:47 <shachaf> bbloom: (You might have an easier time splitting this into three functions -- fmap, extract, duplicate -- rather than using extend.)
15:51:01 <shachaf> bbloom: I'm not sure your question makes sense.
15:51:33 <bbloom> shachaf: then my question is: why does my question not make sense? :-)
15:52:11 <shachaf> Well, most sequences of words don't make sense. :-)
15:52:24 <shachaf> What are you expecting w to be? Where did it come from? How should it behave?
15:53:27 <bbloom> shachaf: no idea. it just seems to me that if each monad has a comonad, then somebody would have figured out a corresponding comonad for the Maybe monad. is that not a reasonable assumption?
15:53:55 <shachaf> "each monad has a comonad" probably isn't true in the sense that you mean it.
15:54:02 <tgeeky> bbloom: This originally started when you said "co-monadic dual". You just want a list of all (regular,co-)monads in Haskell.
15:54:17 <shachaf> Like I said, <shachaf> Every Haskell monad is a comonad, but not a Haskell comonad. It's a comonad in Hask^op.
15:54:30 <shachaf> I don't know of a sense in which a Haskell monad "has" a Haskell comonad.
15:54:37 <shachaf> There's a sort of sense in which you can get the reverse:
15:54:40 <shachaf> @google monads from comonads
15:54:42 <lambdabot> http://comonad.com/reader/2011/monads-from-comonads/
15:54:43 <lambdabot> Title: The Comonad.Reader » Monads from Comonads
15:55:28 <shachaf> But that's an indirect sense, and not every monad can be expressed in terms of a comonad that way, and it's not really "dual" in any standard sense.
15:55:47 <bbloom> shachaf: i'm not necessarily looking for haskell-only, i'm curious about the idea of comonads in general
15:55:48 * hackagebot network-api-support 0.0.7 - Toolkit for building http client libraries over Network.Http.Conduit  http://hackage.haskell.org/package/network-api-support-0.0.7 (MarkHibberd)
15:56:26 <shachaf> bbloom: OK. But the comonad in Hask^op probably isn't what you're looking for.
15:57:02 <bbloom> shachaf: i dunno what Hask^op is, and it doesn't appear to be readily google-able with that ^ in there
15:57:17 <shachaf> @google opposite category
15:57:18 <lambdabot> http://en.wikipedia.org/wiki/Opposite_category
15:57:19 <lambdabot> Title: Opposite category - Wikipedia, the free encyclopedia
15:58:12 <shachaf> This is the sense in which a "dual" comes from "turning the arrows around".
15:59:13 <bbloom> shachaf: so this blog post says i can derive a monad from "any old comonad", but you're saying i can't derive a comonad from any old monad?
15:59:36 <shachaf> Not that I know of. :-)
16:00:08 <shachaf> It gives an argument that it couldn't work the same way, at least.
16:00:15 <johnw> bbloom: take the Maybe monad for example.  What would the Comonad's extract operation do for a Nothing value?
16:00:38 <johnw> or for [], an empty list
16:01:08 <shachaf> johnw: That isn't the question bbloom was asking.
16:01:20 <johnw> i was just giving counterexamples
16:01:40 <shachaf> Right, but they were looking for type related to Maybe, not for an extract operation on Maybe itself.
16:02:12 <johnw> you mean, a type you can derive from Maybe which is a Comonad?
16:02:15 <maurer> So, I'm looking to interact with an existing sql database dump. At the moment I have a copy in SQLite, but future copies may be in different forms, so I don't want to just use sqlite-simple. Do people have experience with any of the more generic haskell database libraries? Any preferences?
16:02:22 <shachaf> Yes.
16:02:34 <shachaf> However the relationship is not clear enough for this question to be well-formed, I think.
16:02:39 <johnw> ok
16:02:45 <bbloom> i'm imagining something that looks like an event callback that may or may not ever fire
16:02:56 <c_wraith> data OnePlusMaybe a = OnePlusNothing a | OnePlusJust a a
16:03:19 <shachaf> bbloom: It is true that this Co construction makes it so that Co . Env = Reader, Co . Traced = Writed, Co . Store = State
16:04:08 <shachaf> So in that sense they are related.
16:04:18 <shachaf> I'd like to know more about what this sense means but I don't. :-)
16:04:32 <shachaf> But it's not really "dual".
16:06:23 <parcs> > 1/999
16:06:25 <lambdabot>   1.001001001001001e-3
16:06:38 <parcs> > 37/999
16:06:40 <lambdabot>   3.7037037037037035e-2
16:07:21 <bbloom> ok thanks shachaf et al, i'll ponder on this more
16:08:12 <johnw> bbloom: Identity can support both Monad and Comonad interfaces
16:08:29 <johnw> because there are valid instances for both type classes
16:09:40 <shachaf> johnw: Yes, there are several types that can. Typically the monad and comonad instances aren't really related, I think?
16:09:48 <shachaf> At any rate that's not what the question was about. :-)
16:10:07 <johnw> i'm not sure in what sense they would not be related
16:10:15 <johnw> but i'm going into this halfway, so I should just stop
16:10:25 <johnw> sorry to add confusion
16:11:04 <shachaf> Go figure out what Co means.
16:11:22 <johnw> that I do know
16:11:38 <johnw> see http://blog.ezyang.com/2010/07/flipping-arrows-in-coburger-king/
16:11:59 <shachaf> No, Co as in Co w a = forall r. w (a -> r) -> r
16:12:15 <johnw> oh
16:12:18 <mauke> http://en.wikipedia.org/wiki/Coburg
16:12:19 <johnw> i must have missed that
16:12:35 <shachaf> Does there exist a W s.t. (forall r. W (a -> r) -> r) ~ Maybe a?
16:12:48 <shachaf> It looks like not.
16:13:09 <johnw> where is this Co type coming from?
16:13:30 <shachaf> The link Google linked to above.
16:13:35 <shachaf> edwardk's post
16:13:44 <johnw> ah
16:13:56 <johnw> i tried to read that once
16:13:58 <johnw> i should try again
16:14:21 <shachaf> Think of it as composition of adjunctions.
16:16:30 <johnw> i see, Co is all you need to make Monad instance for any type
16:16:38 <johnw> (which is a Comonad)
16:16:46 <johnw> and you're wondering if there's a Mo?
16:16:56 <shachaf> No.
16:17:10 <arkeet> he's asking if there is a w such that Co w is Maybe
16:17:22 <shachaf> Well, I've already decided there isn't.
16:17:25 <arkeet> okay.
16:17:37 <shachaf> I'm just wondering what interesting things I don't know about this.
16:18:17 <johnw> I don't see how Co w could ever be Maybe, since there cannot be a Maybe instance for Comonad.  I feel like I'm missing something
16:18:36 <arkeet> johnw: no no.
16:18:45 <arkeet> it's not the same thing that's both a monad and a comonad.
16:18:53 <arkeet> w is a comonad. Co w is a different monad.
16:19:08 <shachaf> Co Identity is Identity!
16:19:15 <arkeet> viewed as a monad.
16:19:32 <johnw> arkeet: ah, thank you for explaining that
16:19:41 <mietek> @botsnack
16:19:41 <lambdabot> :)
16:19:45 <mietek> lambdabot: @pl length $ filter (== head simplified) simplified
16:19:45 <lambdabot> length (filter (head simplified ==) simplified)
16:19:51 <mietek> Hmm.
16:19:55 <mietek> I was hoping for some arrow magic here.
16:20:07 <shachaf> mietek: The expression you gave was already @pled
16:20:09 <johnw> so, what is the adjunction that the Maybe monad comes from?
16:20:15 <arkeet> @pl \simplified -> length $ filter (== head simplified) simplified
16:20:15 <lambdabot> length . (filter =<< (==) . head)
16:20:21 <mietek> Right.
16:20:32 <arkeet> johnw: it's the "free pointed set" monad
16:20:46 <shachaf> It comes from the adjunction between Hask and Kleisli Maybe, obviously.
16:20:49 <shachaf> hth
16:20:49 <johnw> and what are the functors involved?
16:21:39 <arkeet> the right adjoint takes a pointed set and forgets the point.
16:21:51 <arkeet> by set I mean type.
16:21:51 <shachaf> For the Pointed adjunction, they're the forgetful functor and the free functor to Maybe.
16:21:53 <arkeet> or whatever.
16:22:01 <arkeet> "free functor to Maybe" doesn't mean anything
16:22:02 <shachaf> It's just like the adjunction to Mon that gives you lists, except without (++)
16:22:19 <shachaf> Er, not to Maybe.
16:22:21 <arkeet> list = free monoid.
16:22:24 <arkeet> maybe = free pointed set.
16:22:29 <shachaf> To the category of Pointed things.
16:22:50 <arkeet> where a pointed set is a thing with a distinguished element. maybe you can think of it as a monoid without the mappend (just mempty)
16:23:00 <johnw> so there is a forgetful function from Set* -> Set
16:23:04 <shachaf> That's what I mean.
16:23:05 <arkeet> yes
16:23:11 <johnw> functor*
16:23:12 <arkeet> and it has a left adjoint,
16:23:12 <johnw> ok
16:23:31 <arkeet> given a set, you can take its disjoint union with a point, and declare that point to be your point.
16:24:58 <shachaf> arkeet: To justify "free functor to Maybe", perhaps I meant the functor that maps every object O to the object (Maybe O, Nothing)
16:25:03 <johnw> i don't have a good intuition yet for adjunction involving a forgetful functor
16:25:28 <arkeet> but
16:25:38 <arkeet> many adjunctions are those.
16:25:44 <johnw> yeah, I know
16:25:56 <johnw> so, let me try to understand list
16:27:55 <johnw> is the list monad an adjunction of Mon->Set and Set->Mon?
16:28:05 <arkeet> it comes from one yes.
16:28:16 <johnw> oh, and maybe is Set*->Set and Set->Set*
16:28:21 <arkeet> yes
16:28:28 <johnw> it's kind of like a list that can only ever have one element
16:28:32 <johnw> or none
16:28:35 <arkeet> if you want.
16:28:38 <johnw> ok
16:28:52 <shachaf> Why does Set* mean "pointed set"?
16:29:01 <arkeet> shachaf: usually it's written with a subscript *
16:29:01 <johnw> shachaf: I got that from nLab
16:29:10 <shachaf> Ah.
16:29:12 <johnw> now, removing the "point" means what, that the Nothing constructor goes away?
16:29:14 <arkeet> and * means point
16:29:29 <arkeet> johnw: for forgetting? no, it just means you forget Nothing was special.
16:29:36 <johnw> ahh
16:29:39 <johnw> i see what you mean
16:29:40 <arkeet> remember what morphisms of pointed sets are.
16:29:56 <johnw> you drop down to just an inhabited set, right?
16:30:06 <arkeet> well you also forget that it's inhabited.
16:30:19 <arkeet> (although it happens to be.)
16:30:38 <johnw> ok, so the Monad instance deals with composition of these two functors
16:30:46 <arkeet> sure.
16:30:49 <arkeet> by the way, Maybe is a free monad.
16:30:52 <arkeet> Maybe = Free (Const ())
16:31:10 <johnw> so for Monad you end up with Set* after return, and with Comonad you take a Set and extract a member?
16:31:28 <arkeet> no no.
16:31:37 <arkeet> monads stay within one category.
16:31:41 <arkeet> the monad is Set -> Set
16:31:50 <johnw> it's Set->Set by way of Set*?
16:31:51 <arkeet> the comonad is a Set_* -> Set_*
16:31:56 <arkeet> sure, it factors through Set_*
16:31:58 <johnw> ok
16:32:01 <arkeet> but you forget that.
16:32:15 <johnw> then the Comonad definition for which Co w is Maybe will have to be a data type with no point
16:32:58 <c_wraith> isn't a point more or less required for a type to be a Comonad?
16:33:10 <arkeet> ??
16:33:15 <johnw> based on what arkeet just said, I wonder if I reversed that
16:33:36 <arkeet> johnw: no no
16:33:44 <johnw> c_wraith: you mean, for extract to have a meaning?
16:33:54 <johnw> arkeet: thanks for being patient
16:34:24 <c_wraith> johnw: yeah, that's what I meant
16:34:25 <arkeet> johnw: if you have a comonad w from an adjunction *in Hask*, then Co w gives you the corresponding monad.
16:34:32 <arkeet> johnw: but in this case, our comonad isn't in Hask
16:34:50 <johnw> because the forgetful functor isn't in Hask?
16:35:02 <arkeet> well, we can't really write the comonad.
16:36:05 <shachaf> c_wraith: "data Void1 a" is a comonad!
16:37:34 <arkeet> well yes
16:37:40 <arkeet> that's (,) Void, and (,) r is always a comonad.
16:37:51 <shachaf> Right.
16:38:10 <shachaf> "data Proxy a = Proxy" is (Void ->), and (r ->) is always a monad.
17:05:50 * hackagebot subtitleParser 0.5 - A parser for .srt and .sub files  http://hackage.haskell.org/package/subtitleParser-0.5 (RubenAstudillo)
17:47:27 <Itkovian> can I change the bounds of a random generator at runtime?
17:47:45 <Itkovian> or do I need to make a new generator based off the old one each time?
17:48:26 <monochrom> you can change bounds as often as you like
17:49:34 <Itkovian> monochrom: but now if I wrap it in a state, right?
17:49:56 <monochrom> that does not matter
17:50:04 <Itkovian> right
17:55:32 <jfischoff> Any recommendations for a pretty printing typeclass?
17:56:02 <monochrom> I recommend no type class and just go ahead choose one pretty printing lib to use
17:56:21 <jfischoff> equally good, what lib though?
17:56:33 <Cale> wl-pprint
17:56:44 <jfischoff> thanks
17:58:13 <Cale> Or there's pretty, which is older, but everyone is pretty much guaranteed to have it, because it comes with GHC
17:58:52 <jfischoff> not too worried about the deps
18:01:10 <Cale> I recommend the paper about wl-pprint actually
18:01:33 <Cale> http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf
18:10:56 * hackagebot hobbes 0.2 - A small file watcher for OSX  http://hackage.haskell.org/package/hobbes-0.2 (JasonHickner)
18:59:04 <monochrom> everyone has finished learning haskell! no further question. :)
18:59:44 <shachaf> How do I extract the O S from IO String?
19:00:05 <c_wraith> With a screwdriver?
19:00:33 <shachaf> Which phrase is more correct: "trapped inside the IO monad"; "trapped outside the IO monad"
19:01:04 <c_wraith> both can happen, from some viewpoint
19:01:43 <monochrom> usually, it's "locked outside" if it's outside
19:02:39 <croikle> R Kelly monad analogy: monad ~ closet
19:03:02 <c_wraith> I mean..  If you have something that's not an IO value by it's type signature, you're locked out of using IO in it.  If you have something that is an IO value by its type signature, you're locked into using it from IO.
19:03:11 <c_wraith> So they both describe the same restriction
19:03:17 <c_wraith> Just from opposite viewpoints
19:03:35 <monochrom> nice explanation
19:07:22 <monochrom> MacGyver uses swiss army knife, soap, barbed wire, and kitchen sink to extract O S from IO String :)
19:07:53 <TravisD> O S?
19:09:25 <croikle> > isInfixOf "O S" "IO String"
19:09:26 <lambdabot>   True
19:10:13 <TravisD> ah
19:12:18 * Eduard_Munteanu dares not think what knife, soap and kitchen sink mean in functional programming
19:12:45 <TravisD> Heh, but you already know what barbed wire is?
19:12:55 <Eduard_Munteanu> TravisD: yup
19:13:01 <TravisD> what is it?
19:13:03 <shachaf> @google lenses bananas barbed wire
19:13:08 <TravisD> ah
19:13:11 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.125
19:13:12 <TravisD> I've heard of that
19:13:12 <lambdabot> Title: CiteSeerX — Functional Programming with Bananas, Lenses, Envelopes and Barbed  ...
19:13:20 <Eduard_Munteanu> :)
19:14:37 <Eduard_Munteanu> MacMeijer
19:15:26 <byorgey> jfischoff: no, species can describe both labeled and unlabeled structures
19:17:44 <jfischoff> whoops passed on some bad information
19:39:45 <TravisD> A little while ago someone sent me some slides about scripting with Haskell. Is there a more complete reference (like a tutorial or paper or something)?
20:05:59 * hackagebot binary-file 0.12.6 - read/write binary file  http://hackage.haskell.org/package/binary-file-0.12.6 (YoshikuniJujo)
20:10:09 <cschneid>     Couldn't match expected type `ByteString'  with actual type `Data.ByteString.Internal.ByteString'
20:10:10 <cschneid> ok, confused again. Anybody seen this, and what do I go do to fix it:
20:10:26 <Clint> cschneid: is your "ByteString" lazy?
20:10:37 <cschneid> yes, I thought so.
20:10:39 <cschneid> ahh, is that the problem
20:10:42 <geekosaur> at a guess, you are using a lazy bytestring and a strict bytestring is wanted, or vice versa
20:10:43 <cschneid> lazy vs. strict
20:10:52 <cschneid> got it, I bet I know how that leaked in. Fixing :)
20:12:13 <cschneid> yeah, that was tripping me up. Next question - the difference between Char and Word8 is screwing me up. How do I go back & forth
20:12:23 <cschneid> Hoogle didn't give me much useful
20:17:40 <croikle> they're the same internally
20:17:54 <croikle> oh, the ByteString vs ByteString.Char8 are
20:18:22 <croikle> :t ord 'a'
20:18:23 <lambdabot> Int
20:18:52 <Clint> cschneid: with a character set codec
20:19:19 <croikle> if you want to convert individual Char <-> Word8, you can use fromIntegral . ord, chr . fromIntegral
20:19:28 <arkeet> please don't.
20:19:57 <arkeet> unless you live in a world with only 256 Char values.
20:20:18 <arkeet> the Char8 modules come from that world.
20:20:20 <cschneid> well, they're actually bits, ie, Word8 means exactly what I want.
20:20:22 <cschneid> err, bytes
20:20:34 <Ralith> so don't involve Char
20:20:35 <shachaf> if you want to convert individual Char <-> Word8, you can use const 'a', const 14
20:20:39 <shachaf> hth
20:20:53 <Ralith> shachaf: haha
20:20:55 <croikle> shachaf: thx
20:21:23 <cschneid> well, it's coming in off a user passed string, so I've gotta convert from String -> head of that, which is Char, which turns into Word8, and I don't have to think any more :)
20:21:36 <croikle> until you need unicode
20:21:41 <arkeet> what if someone passes in crazy unicodes?
20:21:48 <shachaf> A Char can be converted reasonably to a sequence of Word8s.
20:22:36 <cschneid> well, let me go think through this problem :) gotta figure out my types
20:23:24 <pharaun> what is this for? and why are you disregarding unicode? i'm honestly curious
20:23:50 <cschneid> pharaun: binary manipulation. An encryption puzzle/problem that I'm working on.
20:24:13 <pharaun> ah
20:24:16 <croikle> (I think most code I've written is brittle ascii-only -_-)
20:24:17 <cschneid> so unicode doesn't make any sense, since my input range is '0-f', but then I forgot that I don't want the char that represents, I want the byte.
20:24:59 <cschneid> so. next question presented: I need to enumerate all single character strings ['0'..'9'] ++ ['a'..'f'], except instead of chars, I want them as single char strings
20:25:04 <cschneid> (since I can then un-hex them myself)
20:25:14 <arkeet> > 'a':[]
20:25:16 <lambdabot>   "a"
20:25:36 <arkeet> > ['a']
20:25:38 <lambdabot>   "a"
20:25:50 <cschneid> map (\x -> x:[]) ['a'..'f']
20:25:53 <cschneid> quicker way to write that?
20:26:00 <arkeet> map (:[])
20:26:06 <arkeet> :[]
20:26:12 <arkeet> looks like a face.
20:26:17 <shachaf> @quote eat.a
20:26:17 <lambdabot> dforsyth says: "c++ can eat a dick imo"
20:26:28 <shachaf> @forget dforsyth "c++ can eat a dick imo"
20:26:28 <lambdabot> Done.
20:26:30 <shachaf> @quote eat.a
20:26:31 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
20:27:06 <cschneid> nomnom
20:28:40 <croikle> let ☺ = (:[]) in map ☺ ['a'..'f']
20:29:20 <tgeeky> croikle: careful, that'll give lambdabot food posioning.
20:38:12 <slack1256> @quote oleg
20:38:13 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
20:38:30 <slack1256> indeed oleg, indeed
20:38:32 <mm_freak> cschneid: if you import Control.Applicative:  map pure
20:38:48 <mm_freak> another option:  map return
21:06:54 <cschneid> Is there a better way to turn two chars into a string with: 'a' : ['b']
21:07:29 <arkeet> > ['a','b']
21:07:31 <lambdabot>   "ab"
21:07:33 <cschneid> I suppose strings are 'a' : 'b' : []
21:07:46 <cschneid> so the brackets are unavoidable either way, thanks
21:07:49 <cschneid> just where they end up
21:08:03 <arkeet> > return 'a' `mplus` return 'b'
21:08:05 <lambdabot>   No instance for (GHC.Show.Show (m0 GHC.Types.Char))
21:08:06 <lambdabot>    arising from a use o...
21:08:08 <arkeet> uh
21:08:11 <arkeet> > return 'a' `mplus` return 'b' :: String
21:08:13 <lambdabot>   "ab"
21:09:16 <cschneid> well this is just getting silly :)
21:09:19 <cschneid> thanks.
21:09:24 <cmears> > pure 'a' <> pure 'b' :: String
21:09:26 <lambdabot>   "ab"
21:09:28 <tgeeky> > pure 'a' `mplus` pure 'b' :: String
21:09:29 <lambdabot>   "ab"
21:09:42 <arkeet> > pure 'a' <|> pure 'b' :: String
21:09:44 <lambdabot>   "ab"
21:13:52 <tgeeky> we should just s/pure/a/, honestly.
21:27:51 <cschneid> So if I have an array of [(String, Double)] and want to sort those tuples on the double value, is there a simple way to do that?
21:28:26 <dolio> @type sortBy (comparing snd)
21:28:27 <lambdabot> Ord a => [(a1, a)] -> [(a1, a)]
21:28:31 <pharaun> comp... yeah ^
21:30:07 <cschneid> I figured it was sortby, but not sure how to use it
21:30:16 <cschneid> what's the comparing thing there
21:31:41 <centrinia> :t comparing
21:31:43 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
21:31:59 <centrinia> :t on compare
21:32:00 <lambdabot> Ord b => (a -> b) -> a -> a -> Ordering
21:32:46 <cschneid> ahh, so it's just a function hanging out that returns the Ordering thing. ok
21:33:03 <arkeet> :t compare
21:33:05 <lambdabot> Ord a => a -> a -> Ordering
21:33:31 <arkeet> :t on `asAppliedTo` compare
21:33:33 <lambdabot> Ord b => (b -> b -> Ordering) -> (a -> b) -> a -> a -> Ordering
21:33:38 <arkeet> er
21:33:45 <arkeet> :t on
21:33:47 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
21:36:27 <wavewave> @type sortBy (compare `on` snd)
21:36:28 <lambdabot> Ord b => [(a, b)] -> [(a, b)]
21:38:05 <wavewave> power of higher order function
21:39:46 <wavewave> how is haskell prime going on?
21:40:22 <arpunk> ?
21:40:28 <arpunk> sry, wrong window
21:41:04 <wavewave> I remember haskell2010 is just an intermediate step and we are supposed to keep updating the standard.. aren't we?
22:43:02 <adnap> Why can
22:43:56 <adnap> Why can't one have two functions with the same name and different type signatures in the same module? Can't the invocation of either function be determined by the argument types?
22:45:12 <leroux> adnap: It's called ad-hoc polymorphism in haskell.
22:45:19 <leroux> http://www.haskell.org/haskellwiki/Polymorphism#Ad-hoc_polymorphism
22:45:40 <leroux> "In Haskell, this is achieved via the system of type classes and class instances."
22:47:42 <adnap> I still don't understand why I can't have foo :: Int -> Int and foo :: String -> String in the same module.
22:49:19 <turiya> hi
22:50:06 <turiya> is it possible to use haskell-platform-2012.4 with ghc 7.6.1?
22:50:18 <leroux> adnap: http://stackoverflow.com/questions/6636107/polymorphism-in-haskell
22:55:10 <alpounet> turiya, well, ghc 7.6.1 comes with more recent versions of some libraries etc. but you can still use cabal (the one you got from HP) to build packages with 7.6.1 using --with-ghc=path/to/ghc (you can make this easier to use through some env variable or other things like that
22:56:47 <supki> turiya: you will need to recompile any package you need if it's not clear from alpounet's answer
22:57:06 <turiya> is there a way to install new libraries without using cabal?
22:57:54 <liyang> turiya: you could always do what cabal would have done by hand. Wouldn't recommend it though.
22:57:55 <leroux> adnap: Got it yet?
22:59:09 <turiya> i have installed ghc-7.6.1 from source but when installing cabal it complains about missing base (but ofcourse base is installed already)
22:59:33 <turiya> so i am not too sure how to install new libraries now
22:59:49 <adnap> leroux: Yes
23:05:41 <liyang> k
23:05:44 <liyang> Oops.
23:08:13 <turiya> cabal-install-1.16.0.2 seems to work with ghc-7.6.1
23:08:42 <turiya> i was using an older version of cabal-install
23:26:05 * hackagebot lens 3.9 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.9 (EdwardKmett)
23:33:46 <cads> hey guys, in a FB post, a friend asked about scala. A few friends responded, one suggesting oCaml. My friend does genomics, and is finding python is no longer cutting it in the days of big data. But he needs a mainstream language. I will not suggest haskell, but in fact am considering finding evidence to support his question about scala. You guys know me, I'm not here to ruffle feathers, so let me get to my point.
23:34:23 <cads> and I was wondering how us in the haskell community would rate between scala / F# / and oCaml
23:34:47 <ezyang_> OCaml is pretty fast if you know how to write code for it properly; it does very little optimization
23:35:01 <cads> based on friendliness of community, availability of libraries for hard science, and ease of use
23:35:07 <cads> and of course rated for elegance as well
23:35:18 <cads> since we love elegance :)
23:35:39 <cads> ezyang_: yeah, I also like that there is a lot of logic stuff written in ocaml
23:35:57 <ezyang_> But... genomics? I feel like C++ is more likely to have libraries
23:37:12 <cads> I sense that he's ready to move to a language that is well optimized, has strong abstraction and algebraic types, and has support for science
23:37:17 <cads> he's coming from Cython
23:37:30 <edwardk> I like Haskell mostly because there are libraries for doing all the things I want to do in it.
23:37:36 <cads> absolutely
23:37:38 <edwardk> That may be a self-fulfilling prophecy however.
23:37:59 <liyang> edwardk: you *wrote* all the libraries that do all the things you want to do in it.
23:38:04 <edwardk> =)
23:38:33 <edwardk> Now if only someone would get off their butt and finish analytics, I'd be all set
23:40:16 <cads> I'm going to continue the conversation in -blah
23:41:53 * applicative hasn't figured out what 'analytics' does
23:43:37 <edwardk> applicative: basically what analytics is slowly morphing into is a database engine for doing aggregate range queries of very large datasets
23:44:27 <applicative> I see .. sort of
23:44:41 <applicative> haskell is up to the task?
23:45:13 <edwardk> The goal is to be able to take as much data as you want to throw at it and degrade gracefully as it gets bigger and bigger without ever falling 'off the cliff' like you get when you take a mysql backend past where indices fit in memory
23:45:32 <applicative> ah
23:45:41 <edwardk> yeah. with a bit of help from judicious c bits, and a lot of cache oblivious structures to avoid that cliff-like performance profile
23:46:36 <edwardk> currently development is going fairly slowly since there are some deep structural issues to work through about how to "cache-obliviate" a couple of layers in the storage backend.
23:46:44 <edwardk> Once that is done it should start to cohere nicely.
23:47:36 <adnap> Why is there a foldl' in Data.List and Data.Map if both are Foldable?
23:48:08 <Ralith> for simpler type errors? Because Foldable didn't exist at the time?
23:48:12 <adnap> If I import Data.Foldable, I shouldn't need to hide foldl' from Data.Map and Data.List to unambiguously use foldl'.
23:48:47 <adnap> Also, is there a type class for things that can be filtered?
23:48:50 <applicative> it has a different type
23:49:50 <edwardk> applicative: anyways there are a few open source database projects out there, etc. but the emphasis is on structured data -- not like the nosql school generally, and on doing almost all of the work in compressed form -- I'm actually using data-compression fundamentally as part of the indexing scheme.
23:50:55 <applicative> it seems like a quite different project from other edwardk schemes I'm familiar with
23:51:18 <edwardk> It is more me putting on an old hat than a new one.
23:51:48 <edwardk> And I find that having a big overarching project helps me motivate new little ones.
23:52:06 <edwardk> Hence the release of log-domain, compensated, hashable-extras, etc. that I wound up needing as I went.
23:52:39 <applicative> ah
23:53:15 <edwardk> Also I have wanted a library for doing cache-oblivious data structures in Haskell since I realized we didn't have any, but they are painful to release in general, so I figured a scenario that let me work through them with a very focused goal would perhaps open the door to us getting more C-O algorithms used in haskell.
23:53:47 <edwardk> They don't feel very Haskelly, but they are probably the right path forward to get better asymptotic performance for bigger data sets. Sadly they and 'pure functional' don't play nice
23:55:30 <applicative> adnap, fwiw if foldr generally were the one from Data.Foldable it might impede optimizations specific to list foldr
23:56:19 <shachaf> I sometimes wish foldr wasn't in the Foldable class.
23:56:30 <shachaf> Or at least that foldMap wasn't implemented in terms of it?
23:57:06 <edwardk> shachaf: i just write foldMap by default, since foldr and foldMap are defined mutually
23:57:12 <shachaf> Right.
23:57:25 <shachaf> But not everyone does, and then you get libraries that are right-biased for no good reason.
23:58:34 <adnap> applicative: Data.Foldable exposes a type class, but isn't it the job of each type to implement efficient type-specific functions of the class?
23:59:30 <applicative> yes, but foldr is one of the focuses of ghc's miracle machine
23:59:46 <adnap> What is "ghc's miracle machine"?
