00:00:06 <arkeet> source1 and target are both parameters to the RegexContext class
00:00:22 <arkeet> (ever seen multi-parameter type classes before?)
00:00:33 <tieTYT> an Either is one right?
00:00:37 <arkeet> that's not a class
00:00:37 <tieTYT> oh no, that's a data type
00:00:41 <hpaste> turiya pasted “Simreggrow” at http://hpaste.org/83719
00:01:00 <tieTYT> i don't know too many type classes.  I know of like Monad, pplicative
00:01:12 <turiya> @johnw: http://hpaste.org/83719
00:01:13 <lambdabot> Unknown command, try @list
00:01:13 <ZFox> johnw: put $ fromEnum x2 ?
00:01:21 <tieTYT> Applicative, Eq, etc.
00:01:22 <johnw> turiya: have you used the heap profiler yet?
00:01:48 <tieTYT> i don't know if I've seen any with multiple parameters
00:02:26 <johnw> ZFox: you can use "fromIntegral x2 :: Int"
00:02:26 <turiya> johnw: no.. i think it requires building the libraries with profiling.. i have to remove everything first so i did not.. i wanted to think where these leaks are occuring..
00:02:50 <tieTYT> so what's Regex?
00:02:51 <johnw> ZFox: or maybe use Integer, yeah use Integer
00:02:53 <tieTYT> is that another typeclass?
00:02:59 <arkeet> tieTYT: no, it's a type.
00:03:08 <arkeet> RegexContext is a 3-parameter class.
00:03:09 <turiya> basically.. i have a bid data type which i keep passing around in a recursive manner
00:03:15 <turiya> big data type
00:03:23 <johnw> turiya: well, it's a lot of code to read, but you have a lot of tuples
00:03:33 <ZFox> put $ fromIntegral x2 :: Integer
00:03:34 <arkeet> tieTYT: and here, Regex, source1, and target are the parameters.
00:03:34 <ZFox> ?
00:03:39 <johnw> ZFox: correct
00:03:48 <arkeet> no
00:03:50 <ZFox> Okay. What about these gets?
00:03:53 <turiya> yes.. the main culprit is updateSeg
00:03:53 <arkeet> put (fromIntegral x2 :: Integer)
00:03:54 <johnw> ZFox: you may need: put (fromIntegral x2 :: Integer)
00:04:00 <arkeet> s/may/will/
00:04:01 <arkeet> :p
00:04:08 <ZFox> johnw: I was thinking about that
00:04:10 <ZFox> Okay :)
00:04:18 <arkeet> or
00:04:21 <tieTYT> so Eq has one parameter right?
00:04:23 <johnw> for the get, use secondsToDiffTime and ModifiedJulianDay
00:04:25 <arkeet> tieTYT: yes
00:04:28 <ZFox>     Possible fix: add an instance declaration for (Integral DiffTime)
00:04:30 <ZFox> Hehe
00:04:35 <tieTYT> ok, i don't think i've seen this before
00:04:35 <ZFox> Instances hell!
00:04:41 <arkeet> uh
00:04:49 <arkeet> tieTYT: the first examples that come to mind are things like MonadState
00:04:52 <ZFox> fromEnum seemed to work?
00:04:59 <tieTYT> i've seen the state monad
00:05:01 <tieTYT> same thing?
00:05:03 <arkeet> no
00:05:05 <johnw> ZFox: that just seems wrong
00:05:05 <arkeet> the MonadState class
00:05:13 <johnw> you need to convert the DiffTime to an Integer
00:05:19 <arkeet> :t get
00:05:21 <lambdabot> MonadState s m => m s
00:05:23 <ZFox> johnw: There is an Enum instance but no Integral
00:05:25 <turiya> how can enforce strictness on everything?
00:05:31 <arkeet> and there's an instance MonadState s (State s)
00:05:36 <johnw> hmm
00:05:42 <tieTYT> never seen it
00:05:45 <johnw> turiya: can you direct me to the most recursive part of your code?
00:05:52 <arkeet> tieTYT: well it's not some deep thing
00:05:56 <turiya> johnw: updateSeg
00:06:01 <turiya> line 153
00:06:13 <arkeet> it works just the same way as regular type classes, except it has multiple types.
00:06:24 <johnw> ok, change (m,n) to (!m,!n) and (p,q) to (!p,!q)
00:06:42 <tieTYT> ok
00:06:57 <ZFox> johnw: fromIntegral $ fromEnum x2
00:07:02 <tieTYT> thanks
00:07:14 <johnw> ZFox: you can always try, but that seems so wrong
00:07:21 <arkeet> what is ZFox doing?
00:07:21 <ZFox> Seems wrong indeed
00:07:23 <ZFox> But it works
00:07:39 <ZFox> arkeet: trying to get DateTime/UTCTime to encode in a Binary format
00:07:43 <turiya> johw: ok i will try that
00:08:38 <arkeet> ZFox: oh, I'm looking at http://ix.io/4Fl . what's wrong with what's in there?
00:08:48 <ZFox>    50         return (UTCTime (ModifiedJulianDay x1) x2)
00:08:50 <ZFox> Getting there
00:08:50 <turiya> johnw: the program consumes > 1gb :)
00:08:58 <johnw> ZFox: http://www.haskell.org/pipermail/haskell-cafe/2012-January/098740.html
00:09:10 <ZFox> arkeet: MkDiffTime isn't being exported
00:09:19 <johnw> ZFox: use (x2 :: Rational)
00:09:53 <johnw> turiya: after that change?
00:10:11 <arkeet> hmm
00:10:14 <turiya> johnw: the same
00:10:37 <arkeet> you could unsafeCoerce it to an integer.
00:10:38 <johnw> yeah, at this point I would need to profile it
00:10:40 <ZFox>     Couldn't match type `DiffTime' with `GHC.Real.Ratio Integer'
00:11:04 <arkeet> errr
00:11:10 <johnw> ZFox: CloudHaskell has a Binary instance for UTCTime
00:11:21 <arkeet> yes
00:11:24 <arkeet> :p
00:11:26 <ZFox> johnw: Where?
00:11:29 <turiya> johnw: i have not pasted the main data type .. it is in another module
00:11:31 <johnw> in Remote.Process
00:11:43 <arkeet> DiffTime is a newtype of Fixed E12, which is a newtype of Integer
00:12:28 <ZFox> So many lines
00:13:27 * hackagebot citeproc-hs 0.3.8 - A Citation Style Language implementation in Haskell  http://hackage.haskell.org/package/citeproc-hs-0.3.8 (AndreaRossato)
00:13:36 <johnw> ZFox: https://gist.github.com/5123446
00:13:40 <johnw> that's from Remote.Process
00:13:50 <arkeet> let d = unsafeCoerce t :: Integer
00:14:09 <johnw> it's exactly what you need
00:14:15 <johnw> but, it's not idempotent
00:14:19 <arkeet> err
00:14:22 <johnw> as reported here: http://hackage.haskell.org/trac/ghc/ticket/5175
00:14:36 <johnw> but maybe they fixed that
00:14:42 <johnw> make sure you test it
00:14:44 <arkeet> let d = unsafeCoerce (utctDayTime t) :: Integer
00:14:48 <ZFox> johnw: I've already got it working by looking at that.. Just .. Still using enum and yea
00:15:02 * shachaf peeks into #haskell
00:15:03 <arkeet> or ps.
00:15:04 <NemesisD> anyone know the proper way to wait for a port to be bound for listening? i'm trying to spin up a web server in a thread and use an mvar to wait for it to be ready
00:15:05 <arkeet> ugh.
00:15:13 <arkeet> my point is unsafeCoerce :: DiffTime -> Integer is safe.
00:15:22 <tieTYT> when you create a newtype, you can say deriving on any type class the original is an instance of to get that same implementation, right?  Is there a way to do this if you didn't create the newtype?
00:15:24 <NemesisD> and i'm thinking ready is probably defined as the os not refusing connections on that port
00:15:29 <johnw> don't say unsafeCoerce, shachaf is here!
00:15:39 <johnw> damn, you almost got away with it
00:15:41 <arkeet> tieTYT: yes, with standalone deriving. I think.
00:16:05 <shachaf> Why are people unsafeCoercing DiffTime to Integer?
00:16:27 <johnw> for the record, I never recommended that!
00:16:46 <arkeet> my name is arkeet and I support unsafeCoerce :: DiffTime -> Integer
00:17:14 <shachaf> arkeet: Why?
00:17:18 <arkeet> why not?
00:17:41 <shachaf> Because it's unsafe?
00:17:51 <shachaf> The Integer is three levels of implementation details deep.
00:17:52 <arkeet> not with that type
00:17:55 <arkeet> :p
00:18:05 <arkeet> three?
00:18:07 <arkeet> I only see two.
00:18:21 <arkeet> :p
00:18:39 <shachaf> Why not just convert the number directly?
00:18:51 <shachaf> toRational etc.
00:19:10 <johnw> ah, toRational, that's what I wanted
00:19:19 <arkeet> why not truncate (t * 10^12)?
00:19:25 <arkeet> for t :: DiffTime
00:19:30 <shachaf> Also, why does ZFox keep changing their nick?
00:19:39 <arkeet> :t truncate
00:19:41 <johnw> does he?  I don't see those messages
00:19:41 <lambdabot> (Integral b, RealFrac a) => a -> b
00:20:01 <arkeet> I just noticed.
00:20:01 <shachaf> johnw: I mean over the past few months.
00:20:11 <shachaf> It's hard to keep track of who's who when names keep changing.
00:20:15 <ZFox> shachaf: I'm sticking with this for now
00:20:17 <ZFox> shachaf: shhh
00:20:19 <arkeet> "for now"
00:20:35 <johnw> oh that's easy, I just don't keep track of who's who in that case :)
00:21:03 <ZFox> Wait
00:21:06 * ZFox is confused...
00:21:34 <ZFox> nvm
00:21:38 <arkeet> no really
00:21:43 <arkeet> truncate (t * 10^1`2)
00:21:50 <arkeet> or 1e12
00:22:05 <arkeet> no need to go through Rational
00:22:10 <arkeet> or Pico
00:22:51 <tieTYT> wow that =~ operator is amazing
00:22:54 <ZFox> arkeet: What change are you suggesting to .. http://ix.io/4Fm
00:22:59 <kryft> johnw: Very enlightened of you; personal identity is an illusion anyway, we're all one!
00:23:23 <arkeet> ZFox: instance Binary DiffTime where put t = put (truncate (t * 1e12) :: Integer)
00:23:29 <arkeet> uh
00:23:34 <arkeet> does Integer have a Binary instance even?
00:23:41 <ZFox> Ofc?
00:23:44 <arkeet> okay
00:23:50 <ZFox> defiend in Data.Binary
00:24:00 <turiya> can i enforce strict evaluation on a function?
00:24:55 <ZFox> arkeet: Now do you have a get to match it?
00:25:17 <arkeet> get n = fromInteger n * 1e-12
00:25:20 <arkeet> er
00:25:42 <ZFox> ?
00:25:47 <arkeet> get = do { n <- get; return $ fromInteger n * 1e-12 }
00:26:33 <ZFox>     Couldn't match type `Integer -> Integer'
00:26:33 <ZFox>                   with `Data.Binary.Get.Get DiffTime'
00:26:49 <arkeet> what?
00:26:59 <ZFox> Error :/
00:27:05 <arkeet> which one did you do?
00:27:06 <ZFox> the return
00:27:17 <tieTYT> re: (=~) "Another valid type of result is [String], which returns a list of all matching strings".  Isn't that only possible with a haskell extension because you can't have an instance of [String] otherwise?  You can only have an instance of [a]?
00:27:20 <ZFox> Forgot the $
00:27:45 <shachaf> tieTYT: (=~) uses lots of extensions.
00:27:56 <arkeet> the unsafe one would be to go with unsafeCoerce
00:28:00 <arkeet> but that's unsafeCoerce.
00:28:12 <tieTYT> from a language design perspective, what are extensions?
00:28:33 <tieTYT> why have official libraries use them but not have them automatically supported?
00:28:44 <arkeet> ?
00:28:47 <shachaf> What?
00:28:54 <ZFox> arkeet: Yay
00:29:20 <tieTYT> eh, nm
00:29:24 <tieTYT> as for my first question though
00:29:39 <tieTYT> am I right about that?  You need an extension to make [String] work differently from [Int] ?
00:29:53 <arkeet> differently how?
00:30:09 <tieTYT> i'll have to find the chapter
00:30:25 <arkeet> you can write [String] just fine.
00:30:34 <tieTYT> but i think RWH said you can't do something like "instance Eq [Char]", you can only do "instance Eq [a]"
00:30:46 <tieTYT> unless you use an extension
00:30:55 <arkeet> that's FlexibleInstances.
00:31:05 <tieTYT> language extension, right?
00:31:08 <arkeet> yes
00:31:18 <shachaf> There are often tricks you can do, though.
00:31:25 <shachaf> > show [1,2,3]
00:31:28 <lambdabot>   "[1,2,3]"
00:31:28 <shachaf> > show "abc"
00:31:30 <lambdabot>   "\"abc\""
00:31:32 <shachaf> Magic!
00:31:40 <ZFox> Yayayayay
00:31:42 <arkeet> that uses an overlapping instance doesn't it.
00:31:48 <arkeet> :c
00:32:05 <tieTYT> how's it doing that?
00:32:12 <arkeet> OverlappingInstances
00:32:35 <arkeet> i.e. there's an instance for both [a] and [Char]
00:33:07 <tieTYT> i should find the specific extension i'm referring to
00:33:16 <Iceland_jack> > show ['1', '2', '3']
00:33:18 <lambdabot>   "\"123\""
00:33:47 <tieTYT> TypeSynonymInstances
00:34:07 <arkeet> yes, that's if you use type synonyms.
00:34:14 <covi> Can I pattern match against Text?
00:34:26 <covi> Like 's':x
00:34:36 <arkeet> covi: : is not a constructor for Text
00:34:43 <tieTYT> "Recall that String is a synonym for [Char], which in turn is the type [a] where Char is substituted for the type parameter a. According to Haskell 98's rules, we are not allowed to supply a type in place of a type parameter when we write an instance. In other words, it would be legal for us to write an instance for [a], but not for [Char]."
00:35:04 <arkeet> tieTYT: yes, doing that needs FlexibleInstances.
00:35:20 <tieTYT> what do you mean by "needs"?
00:35:21 <arkeet> writing an instance for String instead of [Char] would need that in addition to TypeSynonymInstances.
00:35:39 <arkeet> tieTYT: to be able to write instance for [Char]
00:35:39 <covi> arkeet: I am writing a necessary function that manipulates each char. But Unpacking + Packing are too slow
00:35:48 <arkeet> covi: manipulates how?
00:35:52 <tieTYT> oh
00:36:11 <tieTYT> why is this called TypeSynonymInstances?
00:36:23 <arkeet> because you're writing an instance for a type synonym>?
00:36:31 <arkeet> String is a type synonym for [Char]
00:36:39 <tieTYT> "In other words, it would be legal for us to write an instance for [a], but not for [Char]."
00:36:46 <tieTYT> [a] isn't a synonym for [Char]
00:36:51 <arkeet> that has nothing to do with TypeSynonymInstances
00:36:52 <arkeet> like I said.
00:37:52 <tieTYT> uh so is this paragraph just misleading?
00:38:07 <arkeet> no
00:38:18 <arkeet> ok look.
00:38:26 <tieTYT> i don't get why that last sentence isn't say: In other words, it would be legal for us to write an instance for String, but not for [Char].
00:38:30 <arkeet> in standard haskell 98, you can't write an instance C [Char], where C is a class.
00:38:34 <arkeet> no
00:38:34 <arkeet> it isn't.
00:38:48 <tieTYT> shoot i meant this:
00:38:55 <tieTYT> In other words, it would be legal for us to write an instance for [Char], but not for String.
00:39:00 <arkeet> no
00:39:01 <arkeet> it isn't.
00:39:46 <tieTYT> ok so TypeSynonymInstances lets that be legal?
00:39:50 <arkeet> no.
00:39:51 <arkeet> listen.
00:40:07 <arkeet> in standard haskell 98, you can't write an instance C [Char], or C String.
00:40:14 <arkeet> if you turn on FlexibleInstances, you can instance C [Char]
00:40:22 <arkeet> but not C String, because String is a type synonym.
00:40:43 <arkeet> if you turn on TypeSynonymInstances but not FlexibleInstances, you can't instance C String, because that's the same as instance C [Char]
00:40:45 <ZFox> arkeet: Okay.. After transmiting over Network.Socket...
00:40:45 <ZFox> ah
00:40:52 <arkeet> so, to write instance C String, you need both extensions.
00:41:04 * ZFox need to use Network.Socket.ByteString?
00:41:38 <arkeet> tieTYT: get it?
00:41:59 <tieTYT> what can you do if you only have TypeSynonymInstances?
00:42:12 <tieTYT> that you couldn't before
00:42:31 <arkeet> type Foo = Bar
00:42:34 <arkeet> instance C Foo where ...
00:42:44 <arkeet> (but not instance C [Foo])
00:43:09 <arkeet> but writing instance C Foo is exactly the same as writing instance C Bar
00:43:13 <tieTYT> oh
00:43:18 <arkeet> so TypeSynonymInstances doesn't *really* let you do anything new.
00:43:23 <arkeet> since you could just expand out the type.
00:44:12 <arkeet> meanwhile, FlexibleInstances really does let you do something new.
00:44:50 <arkeet> i.e. write instances for more specific types.
00:45:28 <tieTYT> ok so with only FlexibleInstances, you can do instance C [Char] where before you could only do instance C [a] ?
00:45:34 <arkeet> yes
00:45:39 <tieTYT> ok I think i get it
00:45:57 <arkeet> if you read the report or error message,
00:46:00 <ZFox> ~ >> vim +'set ft=haskell' http://ix.io/4Fo+4Fp
00:46:05 <arkeet> you can only write instances for T a1 ... an
00:46:10 <arkeet> where a1 ... an are type variables
00:46:18 <arkeet> (with some more conditions)
00:46:21 <ZFox> Can anyone here help me get this working as expected using ByteString/Binary together?
00:46:25 <arkeet> so under this
00:46:40 <arkeet> you can write instance C Char, because Char is of that form (with 0 type variables)
00:46:43 <ZFox> Err.. Network/Socket with Binary
00:46:47 <arkeet> and you can with [a] = [] a
00:46:52 <arkeet> but not [Char] = [] Char
00:46:55 <arkeet> because Char isn't a type *variable*
00:48:59 <tieTYT> ok
00:49:14 <tieTYT> OverlappingInstances
00:49:14 <ZFox> arkeet: Any suggestions?
00:49:23 <arkeet> tieTYT: OverlappingInstances is generally unsafe.
00:49:37 <arkeet> and a bad idea.
00:49:49 <tieTYT> what do you think =~ is using to get it so that ::[String] has functionality?
00:50:14 <arkeet> evidently there are some instances involving [String]
00:50:36 <arkeet> ..bye
00:50:41 <tieTYT> so to do that you'd need flexible and type synonym instances?
00:51:09 <tieTYT> arkeet: you going?
00:51:47 <ZFox> D:
00:52:01 <NemesisD> could someone help me figure out how to catch connection refused errors?
00:52:15 <ZFox> NemesisD: Control.Exception
00:52:50 <ZFox> handle (myErrorHandler h) $ something
00:52:50 <NemesisD> ZFox: i'm looking at that but i don't know what i can do with the type target that specific exception
00:53:04 <ZFox> where myErrorHandler :: Handle -> SomeException -> IO ()
00:53:37 <ZFox>       myErrorHandler h e | isConnectionRefusedError e = hClose h
00:53:47 <c_wraith> NemesisD: catch will catch only a specific exception if the handler's type is specific to only a certain exception
00:53:53 <ZFox>                          | otherwise                  = ioError e
00:53:54 <NemesisD> is that some sort of typeable magic?
00:53:59 * ZFox is unsure what the function would be
00:54:06 <c_wraith> yes, Exception is heavily based on Typeable
00:54:38 <ZFox> I recommend doing isEOFError e = hClose h
00:54:47 <NemesisD> c_wraith: i can't find out where the exception comes from though. when it crashed my program all i saw was  Exception: connect: does not exist (Connection refused
00:55:16 <ZFox> Trace it back
00:55:32 <NemesisD> we have traces now in ghc(i)?
00:55:36 <ZFox> connectTo
00:55:38 <ZFox> ?
00:55:43 <ZFox> "connect" -> "connect"
00:55:51 <ZFox> conectTo wraps connect
00:55:55 <ZFox> Yuo have one of them?
00:56:26 <NemesisD> i'm using Network.Socket. i don't see a connectTo
00:56:35 <ZFox> then connect?
00:56:46 <NemesisD> yep, that's what im using and thats when iit goes wrong
00:57:14 <c_wraith> so, you're saying that the exception says it's coming from connect, and your call to connect is where it crashes, but you don't know where it's crashing?
00:57:17 <c_wraith> I'm a bit confused
00:57:48 <ZFox> c_wraith: +1
00:57:53 <NemesisD> no im saying i don't know how to pattern match that specific exception and no other
00:58:03 <NemesisD> without just catching SomeException
00:58:13 <c_wraith> Catch the actual type of that exception
00:58:21 <ZFox> Ask ghci for the type
00:58:23 <NemesisD> how do i find out what the type is though?
00:58:42 <c_wraith> The error message probably tells you
00:58:48 <ZFox> Go through your code, run that connect command with :t at the start
00:58:54 <NemesisD> how do i trap the type to inspect it in ghci?
00:59:06 <arkeet> :t typeOf
00:59:06 <ZFox> NemesisD: Stop asking after I answer -_-
00:59:08 <lambdabot> Typeable a => a -> TypeRep
00:59:10 <arkeet> :t typeOf 3
00:59:12 <lambdabot> TypeRep
00:59:12 <arkeet> > typeOf 3
00:59:13 <NemesisD> c_wraith: if it does, i'm guessing its Exception, since the error is *** Exception: connect: ...
00:59:15 <lambdabot>   Integer
01:00:06 <ZFox> Anyone have any suggestion for my Network/Binary issues?
01:00:54 <arkeet> ok, bedtime :p
01:00:57 <NemesisD> ZFox: running it with a :t at the start only will tell me that it gives me an IO (), not the exception
01:00:59 <ZFox> arkeet: D:
01:01:13 <ZFox> NemesisD: What exactly are you running?
01:01:47 <ZFox> IO You need to force it to run
01:01:48 <NemesisD> ZFox: connect socket $ addrAddress addressInfo
01:01:51 <ZFox> t <- connect ...
01:01:52 <ZFox> :t t
01:01:54 <lambdabot> Expr
01:01:57 <ZFox> lol
01:02:42 <NemesisD> ZFox: the exception prevents that t from getting bound
01:02:48 <ZFox> Ah ofc
01:04:01 <NemesisD> exceptions are sheer agony in haskell, i'm starting to discover
01:04:17 <ZFox> They are easy once you know what you're dealin with
01:05:00 <NemesisD> but it seems the only way to discover that is to write some broken code and run it against a live system and try to reverse engineer the exceptions if you want to write something safe
01:05:55 <ZFox> Not quite
01:06:31 <NemesisD> if there's an easier way for this situation i'd love to hear it :D
01:07:32 <ZFox> isConnected may help
01:07:35 <ZFox> http://hackage.haskell.org/packages/archive/network/2.4.1.2/doc/html/doc-index-I.html
01:07:57 <ZFox> Err no it won't.
01:07:58 <ZFox> :/
01:08:37 <ZFox> Your exception you bring to life... Not exactly something you want to catch so much because it's saying that you can't connect so... Your program aint even gonna do what it wants eitherway
01:09:04 <NemesisD> ZFox: i specifically want to handle this case because i'm triggering it
01:09:14 <ZFox> Ah
01:09:21 <NemesisD> im bringing a server online and waiting on the socket until it can accept requests
01:10:13 <NemesisD> in any other language this would be a one liner of: rescue Errno::ECONNREFUSED, but the docs provide me no hints as to what i need to catch
01:10:37 <ZFox> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO-Error.html#v:isEOFError
01:10:39 <ZFox> That should help
01:10:46 <ZFox> (The page not the isEOFError)
01:11:03 <ZFox> isDoesNotExistError
01:11:04 <ZFox> ?
01:11:15 <covi> I am working on a lightweight Yesod app. The app fetches input text and displays it onto the screen. However, the newlines '\n' in input text do not get translated to '<br>' in HTML. With a replace function (Text -> Text), '<br>' becomes '&lt;br&gt;'. What should I fix/do?
01:11:31 <NemesisD> hmm. so how do i determine which is_ function i should use?
01:11:43 <ZFox> NemesisD: Test em
01:11:51 <ZFox> isDoesNotExistError looks like it should be what you're after
01:13:02 <ZFox> :t ioeGetErrorType
01:13:03 <lambdabot> Not in scope: `ioeGetErrorType'
01:13:09 <ZFox> lol
01:13:28 * hackagebot ersatz 0.1 - A monad for expressing SAT or QSAT problems using observable sharing.  http://hackage.haskell.org/package/ersatz-0.1 (EdwardKmett)
01:14:29 <edwardk> only took 3 years for me to get around to releasing that. thanks ion!
01:14:33 <edwardk> ion++
01:14:36 <NemesisD> seems unlikely, an error indicating that one of its arguments doesn't exist, but ill give it a try
01:15:32 <ZFox> NemesisD: You didn't use it right then
01:15:45 <ZFox> my handler...
01:16:03 <NemesisD> ZFox: no i mean thats what the docs saay for isDoesNotExitError
01:16:30 <ZFox> where eL :: Handle -> IOException -> IO (); eL h e | isEOFError e = hClose h | otherwise = ioError e
01:18:28 * hackagebot ersatz 0.1.0.1 - A monad for expressing SAT or QSAT problems using observable sharing.  http://hackage.haskell.org/package/ersatz-0.1.0.1 (EdwardKmett)
01:19:07 <ZFox> Could anyone help me with getting my network daemon with bytestring/binary data being encoded/decoded?
01:21:36 <ZFox> http://ix.io/4Fp daemon. http://ix.io/4Fo client
01:22:04 <NemesisD> ZFox: by jove isDoesNotExistError actually works. i have no idea how i would have arrived at that without your suggestion though
01:22:24 <ZFox> NemesisD: It said the host didn't exist
01:22:26 <ZFox> :P
01:23:23 * ZFox adds such handlers to his own network hell
01:23:28 * hackagebot ersatz 0.1.0.2 - A monad for expressing SAT or QSAT problems using observable sharing.  http://hackage.haskell.org/package/ersatz-0.1.0.2 (EdwardKmett)
01:26:14 <NemesisD> yeah. at this point i view exceptions as poison in my haskell programs. when im not being lazy i trap them at the boundaries of my code and turn them into something the type checker can help me with
01:26:15 <NemesisD> i would not be sad if the haskell team just scrapped exceptions. they make me afraid of my haskell code where I would otherwise have no reason to be
01:27:35 <NemesisD> ZFox: also i can attempt to help you before i go to bed although i will probably get stumped
01:28:10 <ZFox> NemesisD: Yay
01:28:17 <ZFox> NemesisD: 20:21         ZFox | http://ix.io/4Fp daemon. http://ix.io/4Fo client
01:28:33 <ZFox> I need to get the communication between the daemon and client solid
01:28:39 <ZFox> Using Binary
01:29:16 <ZFox> Currently just using a socket file, but I intend to add ssl and hosting on a port.
01:29:35 <ZFox> At a latter date.
01:30:02 <NemesisD> i might have missed what you said. wireless dropped
01:30:13 <ZFox> ~/haskell/HackerHaven >> ./TokenD
01:30:14 <ZFox> Please remove the socket file!
01:30:15 <ZFox> Hehe
01:31:34 <ZFox> NemesisD: How many mesages did you get?
01:31:46 <ZFox> tcp should have fixed all dropped packets
01:32:15 <ZFox> Unless you're using a crappy bouncer
01:32:36 <NemesisD> just that you add such handlers to your network hell
01:32:47 <ZFox> Ugh
01:32:51 <NemesisD> im using irssi, and i had to reconnect to freenode, even after my net came back up
01:33:13 <ZFox> Ah didn't see you leave
01:33:17 <ZFox> ZFox | http://ix.io/4Fp daemon. http://ix.io/4Fo client
01:33:29 <ZFox> I need to get the communication between the daemon and client solid
01:33:29 <ZFox> Using Binary
01:33:29 <ZFox> Currently just using a socket file, but I intend to add ssl and hosting on a port.
01:34:42 <NemesisD> oh, instead of a socket file?
01:35:19 <NemesisD> so the code isn't working or it is but it doesn't have ssl support
01:35:51 <ZFox> neither
01:35:52 <ZFox> ssl will be later
01:36:13 <ZFox> I need to get the communication binary level working nicly
01:36:33 <ZFox> you can run them..
01:36:40 <ZFox> One sec and I'll get you access to a bit more..
01:36:45 <ZFox> NemesisD: you have darcs installed?
01:38:04 <NemesisD> ZFox: negative
01:38:23 <ZFox> NemesisD: Fine. I just give you an tar.gz
01:38:44 <ZFox> NemesisD: http://archeydevil.hackerhaven.net/HackerHaven.tar.gz
01:38:51 <NemesisD> ZFox: i'm getting somewhat dizzy sleepy. could you email it to michael@michaelxavier.net and i'll take a look tomorrow morning?
01:39:08 <NemesisD> haven't worked much with binary but i'm willing to give it a shot then
01:41:48 <ZFox> Sorry I catt'd a large binary file over ssh :/ XD
01:42:05 * ZFox is getting kicked off the computer too.. Good night NemesisD 
01:42:46 <NemesisD> ZFox: lol night
01:43:29 * hackagebot void 0.5.12 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.12 (EdwardKmett)
01:48:29 * hackagebot distributive 0.3.1 - Haskell 98 Distributive functors -- Dual to Traversable  http://hackage.haskell.org/package/distributive-0.3.1 (EdwardKmett)
01:53:34 <hpaste> johnw pasted “specialization question” at http://hpaste.org/83720
01:53:45 <johnw> wereHamster: there it is
01:55:09 <johnw> my use case is that I have multiple Git Repository instances, and I'm writing a "pushRef" function that can push a ref and all its commits/objects to another repository.  Well, there are some combinations (like, Git CmdLine -> Git CmdLine) where I can implement this very cheaply.  But for the "general case", it's rather expensive.
01:55:42 <johnw> so, I'd like to be able to specialize pushRef for certain combinations
01:55:54 <johnw> in Common Lisp, this would be trivial, but I'm not sure what the best approach is in HAskell
01:56:00 <wereHamster> johnw: keep in mind that I know very little about haskell. But I'd try this: class Eq a, b => Foo a b where .. and then make two instances, one Foo Int Int and another Foo Int Float
01:56:09 <johnw> yeah, that I can't really do
01:56:26 <johnw> because I may use the same Foo to call foo on multiple other Eq b's
01:56:40 <johnw> i can't "fix it in" at compile-time
01:56:47 <wereHamster> johnw: are you working on a git library in haskell?
01:56:50 <johnw> yes
01:57:12 <wereHamster> heh, I wrote an (incomplete) one a long time ago :)
01:57:18 <johnw> what was the name?
01:57:29 <wereHamster> yag, it's on github. I was just starting with haskell
01:57:39 <johnw> ah.  mine is actually an API library around other backends
01:57:46 <johnw> so, I support libgit2 and cmdline, for example
01:57:47 <wereHamster> around libgit2?
01:57:57 <johnw> libgit2 is SO much faster for all local operations
01:58:04 <wereHamster> faster than haskell?
01:58:10 <johnw> no, faster than cmdline
01:58:15 <johnw> I haven't yet written a "hit" backend
01:58:21 <johnw> that will provide a pure haskell alternative
01:58:26 <Kinnison> johnw: Is your library very complete yet?
01:58:32 <johnw> Kinnison: yes, it's being used in production
01:58:44 <Kinnison> johnw: Awesome.  I wrote something similar for Lua and have been looking for one for Haskell
01:58:46 <johnw> i'm just doing some final polishing, then we'll code review it and I'll announce on cafe
01:59:04 <johnw> we mainly use it for writing Git objects to S3 and GitHub
01:59:25 <Kinnison> I'll want it to write an app which uses a git repo as its backend, so it sounds perfect
01:59:33 <Kinnison> Is it visible on github?
01:59:36 <johnw> yes, I'd be happy to help
01:59:39 <johnw> https://github.com/fpco/gitlib
01:59:47 * Kinnison bookmarks
01:59:53 <johnw> just delete "gitlib-github" from sources.txt for now, as rest-client has yet to be released
02:00:13 <johnw> (you may have to delete rest-client too, and also from .gitmodules)
02:00:17 <johnw> that should happen in the next 1-2 weeks
02:00:30 <Kinnison> It'll be a week or two before I'm ready to start speccing this tool
02:00:34 <Kinnison> so much to do, so little time :-)
02:00:48 <johnw> nice, I'm very interested in any API-related comments
02:00:53 <Lethalman> are you using haskell at work johnw ?
02:00:57 <Kinnison> But it's nice to know I can review gitlib and with a bit of luck I'll have an architectural decision made for me already
02:01:01 <johnw> since the intention is not to implement Git, but to allow Haskellers to write "general" Git algorithms
02:01:06 <johnw> Lethalman: yes, exclusively
02:01:25 <Lethalman> johnw, so nice, in my country there are no haskell jobs :(
02:01:33 <johnw> Lethalman: which is your country?
02:01:36 <Lethalman> johnw, italy
02:01:46 <johnw> isn't chrisdone in Italy?
02:02:26 <Kinnison> johnw: In brief I need to keep a moderate number (a few tens of thousands) of objects in a filesystem-like arrangement with traceability on changes and the ability to merge changes between users.  It struck me that using a git repo as the storage backend was the right idea.
02:02:35 <johnw> wereHamster: ok, I need to do this with another type class, RepositoryLink
02:02:41 <Kinnison> johnw: So if gitlib will let me manipulate a git repo's objects directly then it'd be perfect
02:02:50 <Lethalman> johnw, he works on some haskell thing?
02:02:52 <johnw> Kinnison: yep, that's exactly what it's for
02:02:59 <johnw> Lethalman: yeah, he's a big Haskeller
02:04:09 <Lethalman> johnw, I was just looking around on the various sites offering jobs and didn't find anything about haskell
02:04:25 <Kinnison> johnw: That's fantastic, Hopefully I'll be able to start feeding back to you in a few weeks if I can get some specification time to myself :-)
02:04:38 <Lethalman> I'm very interested in using haskell but well, without a job it's hard to get deeper and actually use it
02:04:39 <johnw> Kinnison: nice, I'm johnw@fpcomplete.com
02:04:44 <wereHamster> Kinnison: once you complete your project, be sure to submit it to the UGFWIINI(F) contest :)
02:04:52 <johnw> Lethalman: can you use it for your personal tooling?
02:05:02 <johnw> Lethalman: my first step with Haskell was to replace my every use of Python with it
02:05:02 <wereHamster> we haven't had any submissions in years :(
02:05:12 <Lethalman> johnw, I mostly use hakyll and shake for pet projects
02:06:00 <johnw> nice
02:08:02 <Kinnison> wereHamster: I doubt any haskell I do in the next year or so will be worthy of entering into a contest :-)
02:09:06 <Lethalman> johnw, my problem is that I don't have something to contribute to, apart hakyll and shake which I don't use on a daily basis
02:09:22 <johnw> Lethalman: do you want to write gitlib-hit?
02:09:25 <wereHamster> Kinnison: it's not about haskell. UGFWIINI(F) == Using Git For What It Is Not Intended (For)
02:09:34 <Lethalman> johnw, that's another thing I wouldn't use on a daily basis :)
02:09:46 <johnw> ah, I understand
02:10:05 <johnw> Kinnison: have you seen the "filestore" package?
02:10:12 <Kinnison> wereHamster: oh right
02:10:15 <johnw> I want to write a gitlib module for that too
02:10:19 <Kinnison> johnw: No, whassat?
02:10:27 <johnw> it's a lot like Python shelve
02:10:39 <Kinnison> ooh
02:10:42 * Kinnison hoogles
02:10:55 <johnw> and it writes to Git, it just uses its own backend for using cmdline Git
02:11:06 <johnw> which, if you deal with thousands of tiny objects, will not be good
02:11:18 <johnw> (that's one usage pattern where libgit2 excels)
02:11:33 <Kinnison> Cute.  And yeah, Gall (my git library for lua) uses libgit2 where it can
02:11:40 <johnw> the author is interested in a gitlib backend, I just have to write it
02:12:25 <Kinnison> jgm's stuff tends to be pretty good; although he needs punching for his inability to maintain an API for very long
02:15:47 <kallisti> checking for path to top of build tree... utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory
02:15:59 <kallisti> what version of GMP is required for GHC 7.6.2?
02:18:24 <johnw> kallisti: doesn't it come with its own GMP?
02:19:03 <kallisti> johnw: I don't know.
02:21:33 <aCube> Is there a package on hackage that uses functions and a list of keys as a representation for maps?
02:22:28 <johnw> aCube: what would the type of that representation be?
02:22:46 <aCube> data Map k a = Map (k -> a, [k])
02:23:00 <johnw> that sounds a bit like a representable functor
02:23:13 <johnw> but in that case, it's not [k] but all inhabitants of a type
02:36:50 <aCube> johnw: I need the [k] because I want to iterate over all the values in the map
02:48:30 * hackagebot haskell-src-meta 0.6.0.2 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.6.0.2 (BenMillwood)
03:02:48 <mikeplus64> is there some way to magically coerce a haskell value into its Addr#?
03:47:53 <wuttf> Should the syntactic sugar case () of _ work in 7.4.2?
03:48:29 <`nand`> I don't see why it shouldn't
03:48:54 <wuttf> I get parse error ("incorrect indentation")
03:48:57 <wuttf> I use spaces, etc...
03:49:39 <`nand`> > case () of _ | 1 == 2 -> "huh?" | otherwise -> "okay"
03:49:40 <shachaf> wuttf: That's not really sugar, is it?
03:49:42 <lambdabot>   "okay"
03:49:59 <shachaf> wuttf: Anyway, getting a parse error without any code is pretty impressive. :-)
03:50:10 <shachaf> (If you have code, you should paste it.)
03:50:29 <wuttf> shachaf: http://www.haskell.org/haskellwiki/Case see  2.2.1
03:50:45 <shachaf> ?
03:50:52 <shachaf> I know how case () of _ works
03:51:00 <shachaf> Are you getting a parse error on that exact code?
03:51:19 <wuttf> You said it's not  "syntactic sugar"
03:51:33 <wuttf> But that construct uses guards
03:51:33 <`nand`> and it isn't
03:51:36 <wuttf> which is
03:51:37 <shachaf> Oh. Guards are syntactic sugar. case () of _ isn't.
03:51:45 <wuttf> Ahh I get it.
03:52:16 <wuttf> never mind I moved it to a function
03:52:21 <wuttf> and used guards there
03:52:48 <`nand`> I find that to be a less ‘hacky’ approach than “case () of _”
03:52:54 <`nand`> but ideally, I'd use “if | ...”
03:54:37 <wuttf> Yeah that if with guards looks nice
03:55:06 <wuttf> case () of _ kinda hurts my eyes too
04:06:27 <c_wraith> `nand`: that "ideally" case looks a lot like the new MultiwayIf extension
04:07:05 <`nand`> yes, but he doesn't have it (7.4.2)
04:13:41 <diag3> hello #haskell
04:15:29 <diag3> i want to get pcm data from my line-in using the  ALSA PCM bindings and i have not worked with the FFI before
04:15:42 <diag3> the thing is i need a pointer to write the data to
04:16:32 <diag3> and the Ptr datatye in Foreign.Ptr has no constructor, and i know i'm missing some concept of how haskell works here
04:16:48 <hpc> @hoogle a -> IO (Ptr a)
04:16:49 <lambdabot> Foreign.Marshal.Utils new :: Storable a => a -> IO (Ptr a)
04:16:49 <lambdabot> Foreign.Marshal.Alloc mallocBytes :: Int -> IO (Ptr a)
04:16:49 <lambdabot> Foreign.Marshal.Array newArray0 :: Storable a => a -> [a] -> IO (Ptr a)
04:17:08 <diag3> oh
04:17:16 <diag3> thank you very much hpc
04:17:36 <hpc> you'll find the same pattern holds for other mutable data types
04:18:28 <`nand`> http://hackage.haskell.org/packages/archive/alsa-pcm/0.6/doc/html/Sound-ALSA-PCM.html
04:18:56 <`nand`> oh
04:19:02 <`nand`> you were referencing that already, weren't you?
04:19:14 <`nand`> I see it now “soundSourceRead :: handle y -> Ptr y -> Size -> IO Size”
04:19:15 <diag3> i just needed to know how to request a pointer
04:19:34 <diag3> yap, that's the function
04:20:05 <`nand`> (note that if just copying from a source to a sink there's a helper to do it for you)
04:20:44 <diag3> well, i'm doing some fft so i can write me a guitar tuner
04:22:12 <`nand`> I wonder if there isn't some higher level sound library so you don't have to worry yourself about how exactly samples are represented in the buffer
04:26:26 <ClaudiusMaximus> > let step xs = xs ++ xs ++ "^" in (concat . drop 1 . iterate step) "."
04:26:29 <lambdabot>   "..^..^..^^..^..^^..^..^^^..^..^^..^..^^^..^..^^..^..^^^^..^..^^..^..^^^..^...
04:26:52 <ClaudiusMaximus> does that sequence have a name?
04:27:20 <hpc> @oeis 1 1 2 1 2 1 3 1 2 1 3
04:27:34 <lambdabot>  Triangle read by rows, based on the morphism f: 1->{1,2}, 2->{1,3}, 3->{1}. ...
04:27:34 <lambdabot>  [1,1,1,2,1,1,2,1,2,1,2,1,3,1,1,2,1,2,1,2,1,3,1,2,1,2,1,3,1,2,1,3,1,2,1,3,1,2...
04:27:44 <hpc> uh
04:28:08 <hpc> @oeis 1,1,2,1,2,1,3,1,2,1,3,1,2,1,4,1,2,1,3
04:28:21 <lambdabot>  In binary representation: number of editing steps (delete, insert, or substi...
04:28:21 <lambdabot>  [1,1,1,2,1,2,1,3,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2...
04:28:33 <hpc> no clue :P
04:28:48 <ClaudiusMaximus> hehe, ok
04:30:00 <cariveri> Hi there. how do I create an object(unified fields and methods) in haskell?
04:30:02 <ClaudiusMaximus> thanks - it's for constructing binary trees from the bottom up:  "." is "push new leaf to stack" and "^" is "pop two trees from stack, push new node"
04:34:34 <ClaudiusMaximus> cariveri: something like data Foo = Foo{ value :: Int, add :: Int -> Foo, multiply :: Int -> Foo }  with mkFoo :: Int -> Foo,  mkFoo x = Foo x (\y -> mkFoo (x + y)) (\y -> mkFoo (x * y))   with some kind of restricted exports so you can't create inconsistent Foo by modifying the record contents
04:37:31 <cariveri> ClaudiusMaximus: thanks looks cool. can the int be generic? like data Foo a = Foo{ value::a ...} ?
04:39:00 <hpaste> Skola pasted “Why does this typecheck?” at http://hpaste.org/83727
04:39:47 <shachaf> Skola: Why shouldn't it?
04:40:00 <shachaf> It's a recursive function with no base case, so it's not very useful.
04:40:03 <shachaf> But the types match.
04:40:14 <Iceland_jack> shachaf: Try checking other non-terminating functions
04:41:25 <Iceland_jack> @ty let fun x = fun x in fun
04:41:26 <lambdabot> t -> t1
04:41:55 <bitonic> you can do better than that
04:41:59 <bitonic> @ty let x = x in x
04:42:01 <lambdabot> t
04:42:02 <Skola> Because it doesn't terminate it can return any type
04:42:05 <bitonic> there you go, any type
04:42:16 <Skola> or is that phrased inaccurately?
04:42:47 <bitonic> @ty let x 0 = x 0 in x
04:42:48 <lambdabot> (Eq a, Num a) => a -> t
04:42:55 <`Jake`> Is there a reason which can be explained quickly why Tuple Sections are not naturally there?
04:42:58 <bitonic> Skola: non-terminating, but still less polymorphic
04:43:37 <`Jake`> It seems like it's just standard currying
04:43:45 <ClaudiusMaximus> hpc: actually i want the limit of the sequence, not the concatenation...
04:44:08 <bitonic> `Jake`: what do you mean ‘not naturally there’?  not in the standard?
04:44:13 <ClaudiusMaximus> > let step xs = xs ++ xs ++ "^" in iterate step "." !! 100
04:44:16 <lambdabot>   "..^..^^..^..^^^..^..^^..^..^^^^..^..^^..^..^^^..^..^^..^..^^^^^..^..^^..^....
04:44:27 <pricklypear> i
04:44:31 <pricklypear> damn, sorry
04:45:52 <qnikst> hello, can smb help we with writing correct lens code to modify a field base on the value of another?
04:45:54 <`Jake`> bitonic: I just realized that what I mean actually only applys to 2-tuples, but it seems like if you program the type for these, you should be able to use tuple sections for them by just partially applying the constructor
04:46:05 <ion> edwardk: Well, thanks for the guidance and the 0.1 release. edwardk++ :-)
04:46:16 <`Jake`> for which you don't need an extension, iirc
04:46:34 <bitonic> `Jake`: tuple syntax is an exception, they don’t behave like normal operators
04:47:42 <`Jake`> bitonic: Can you do it with standard haskell or is it compiler magic?
04:49:48 <bitonic> `Jake`: can you do what with standard Haskell?  tuple sections?  you can define `(^) = (,)' and then use sections with ^
04:49:58 <bitonic> but I’m not sure I’m understanding what you mean :P
04:50:32 <Iceland_jack> probably things like this (,'a')?
04:50:39 <`Jake`> bitonic: I was talking about tuple syntax now, not the sections
04:50:45 <pricklypear> i.e, flip (,)?
04:50:54 <bitonic> `Jake`: you can’t define the tuple syntax in haskell, no
04:51:00 <`Jake`> bitonic: ok, thanks
04:51:04 <bitonic> in the same way that you can’t define `-' and list sintax
04:51:10 <`Jake`> yeah, ok
04:51:11 <bitonic> -, the unary operator
04:51:38 <bitonic> Agda, on the other hand...
04:52:47 <bitonic> `data Tuple (A B : Set) : Set where ⟨_,_⟩ : A → B → Tuple A B'
04:53:28 <Iceland_jack> > printf "%d minutes since last Agda reference" 0
04:53:30 <lambdabot>   Ambiguous type variable `a0' in the constraints:
04:53:30 <lambdabot>    (GHC.Show.Show a0)
04:53:30 <lambdabot>     ...
04:53:35 <bitonic> syntax is the gateway drug to Agda
04:54:18 <`Jake`> I actually wanted to look into agda a few weeks ago, but I couldn't get the emacs plugin to work, and then I didn't have time because I was doing other stuff...
04:55:14 <bitonic> `Jake`: you can come on #agda and we’ll help you!
04:55:21 <hpaste> idntfy revised “Tridiagonal matrix algorithm”: “Tridiagonal matrix algorithm” at http://hpaste.org/83540
04:55:29 <`Jake`> bitonic: I will do that once I have time for it ;-)
04:55:34 <aCube> Is there a function  (Applicative f) => (b -> f a) -> f (b -> a) ?
04:56:13 <aCube> or maybe (Applicative f) => (b -> f a) -> [b] -> f (b -> a)?
04:57:09 <hpc> your first one doesn't exist
04:57:13 <arkeet> aCube: no
04:57:17 <hpc> and i am fairly sure the second one won't either
04:58:46 <hpc> aCube: IO is applicative; think about what happens when (b -> f a) is something like (String -> IO ())
04:58:49 <hpc> :t getLine
04:58:51 <lambdabot> IO String
04:58:54 <hpc> :t putStrLn -- rather
04:58:56 <lambdabot> String -> IO ()
05:00:20 <arkeet> aCube: but what is it that you really want?
05:00:27 <aCube> :t \f bs -> (!!) <$> sequenceA (map f bs)
05:00:29 <lambdabot>     Not in scope: `sequenceA'
05:00:29 <lambdabot>     Perhaps you meant one of these:
05:00:29 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
05:00:38 <aCube> :t \f bs -> (!!) <$> sequence (map f bs)
05:00:40 <lambdabot> (Monad f, Functor f) => (a1 -> f a) -> [a1] -> f (Int -> a)
05:00:40 <edwardk> ion: have a chance to look at the new generics-driven version?
05:01:13 <aCube> Is there a way to write this more efficiently, as (!!) is O(n) ?
05:01:28 <edwardk> aCube: switch to another container.
05:01:33 <Iceland_jack> another data structure
05:01:49 <edwardk> :t sequence . map
05:01:51 <lambdabot>     Couldn't match expected type `[m0 a0]'
05:01:51 <lambdabot>                 with actual type `[a1] -> [b0]'
05:01:51 <lambdabot>     Expected type: (a1 -> b0) -> [m0 a0]
05:01:59 <edwardk> :t sequenceA . map
05:02:00 <lambdabot>     Not in scope: `sequenceA'
05:02:00 <lambdabot>     Perhaps you meant one of these:
05:02:00 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
05:02:03 <edwardk> :t traverse
05:02:04 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
05:02:09 <edwardk> :t Data.Traversable.sequenceA . map
05:02:10 <lambdabot> Traversable ((->) [a1]) => (a1 -> a) -> [[a1] -> a]
05:02:13 <edwardk> :t Data.Traversable.sequenceA . fmap
05:02:15 <lambdabot> (Applicative f, Traversable ((->) (f a1))) => (a1 -> a) -> f (f a1 -> a)
05:02:30 <edwardk> :t \f -> Data.Traversable.sequenceA . fmap f
05:02:32 <lambdabot> (Applicative f, Traversable t) => (a1 -> f a) -> t a1 -> f (t a)
05:02:35 <edwardk> there
05:02:44 <hpaste> idntfy revised “Solution of Heat Equation by simply iteration method with GTK GUI”: “Solution of Heat Equation by simply iteration method with GTK GUI” at http://hpaste.org/82974
05:02:48 <edwardk> anyways sequenceA . fmap f = traverse f
05:02:59 <aCube> oh nice. Thanks
05:23:31 <`nand`> :t traverseOf traverse
05:23:33 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
05:29:17 <mcstar> hi all
05:30:02 <hpaste> mcstar pasted “truth table” at http://hpaste.org/83733
05:30:24 <mcstar> i was wondering if there was a better way to write this truthtable generator
05:31:06 <mcstar> i think it is possible to abstract the function type somehow and make a function that displays the truthtable of a general n-ary function
05:31:09 <mcstar> but idk how
05:32:59 <mcstar> (by general i dont mean 'any type
05:33:01 <edwardk> mcstar: you know you can use replicateM right?
05:33:04 <edwardk> :t replicateM
05:33:06 <lambdabot> Monad m => Int -> m a -> m [a]
05:33:07 <mcstar> 'ofc, jsut that general number of arguments)
05:33:17 <mcstar> edwardk: that doesnt concern me
05:33:40 <mcstar> edwardk: i mean, i dont care about how nice or not the code is
05:33:51 <edwardk> "	 i was wondering if there was a better way to write this truthtable generator"
05:33:51 <mcstar> im interested in the type system now
05:33:56 <edwardk> "i dont care about how nice or not the code is"
05:34:03 <edwardk> i'm having trouble correlating those statements =P
05:34:19 <mcstar> edwardk: do you see that i need an instance declaration for all the arities?
05:34:28 <mcstar> im wondering if that can be eliminated
05:34:33 <mcstar> "better way"
05:35:17 <edwardk> the answer is yes, it can
05:35:18 <mcstar> alternatively, dont look at the 'display' function if it bothers you eyes :)
05:35:25 <mcstar> r
05:35:53 <mcstar> edwardk: what are the keywords that would let me do it?
05:36:03 <mcstar> some extensions, or just plain old haskell 98?
05:36:13 <edwardk> you don't need any new keywords just to use the ones you already know more intelligently
05:36:48 <ion> edwardk: Re: README, minisat can’t solve verify_currying, though. It uses forall.
05:36:52 <mcstar> not keywords as in 'programming language keywords'
05:36:58 <edwardk> ion: ah true
05:37:09 <mcstar> but keywords as in words that define the topic that i am interested in
05:37:18 <mcstar> for example: 'recursice types' ...
05:37:22 <mcstar> recursive*
05:37:46 <edwardk> ion: /me isn't sure how youd find it using google =P
05:37:51 <edwardk> er mcstar
05:38:18 <mcstar> google aside, you could tell me
05:38:28 <mcstar> maybe im am using yahoo
05:38:29 <edwardk> but basically the trick is figuring how how to encode the base case for Bool   and then how to define a new case for Bool -> t  given an instance for t
05:38:31 <mcstar> XD
05:38:33 * hackagebot hF2 0.2 - F(2^e) math for cryptography  http://hackage.haskell.org/package/hF2-0.2 (MarcelFourne)
05:39:04 <edwardk> instance Foo Bool where;    instance Foo t => Foo (Bool -> t)
05:39:06 <mcstar> edwardk: i tried a recursive type definition but haskell bailed out, like: type A = Bool -> A
05:39:18 <edwardk> no recursive type definitions here
05:39:23 <edwardk> just two instances
05:39:34 <edwardk> Bool doesn't unify with (Boo -> t) so they are disjoint instances
05:39:49 <mcstar> edwardk: this is not a homework, btw, if thats why you are reluctant to give me straight anwers :)
05:40:04 <mcstar> im not associated with academia from a maths standpoint
05:40:11 <edwardk> no. i'm trying to give you a hint, while i'm in the middle of doing other things
05:40:21 <mcstar> ok
05:40:40 <edwardk> but the key is just what i just said
05:40:49 <edwardk> it'll involve two instances of that shape
05:40:50 <mcstar> ok, thanks
05:40:50 <fryguybob> mcstar: The goal is to be polymorfic enough in the return value that you can choose either another argument or the base case.
05:40:55 <mcstar> ill ponder on it
05:41:36 <edwardk> mcstar: if you look up oleg's printf stuff in haskell he does this
05:41:37 <mcstar> ok, thanks guys, ill get back to you if i cant figure it out till tomorrow
05:41:49 <edwardk> its the same idea
05:42:09 <mcstar> edwardk: is his printf type safe?
05:42:28 <edwardk> he has a type safe one. there is also an unsafe one
05:42:28 <mcstar> if i am correct, Text.Printf is not statically typesafe, right?
05:42:53 <ZFox> -Wall. What reasons are there for "Token/Types.hs:48:10: Warning Orphan instance: instance Binary DiffTime" ?
05:43:08 <Iceland_jack> mcstar: It can't depend on the input string like it could in a dependently typed language
05:43:14 <ZFox> What does it mean for an Orphan instance?
05:43:22 <mcstar> right
05:43:38 <ZFox> It's used...
05:43:50 <edwardk> ZFox: the only safe places you can put an instance are either in the module that defines the type or the module that defines the class
05:44:06 <edwardk> so in Token/Types.hs, neither Binary nor DiffTime are being defined for the first time
05:44:25 <edwardk> ZFox: the warning exists because someone else could have another module with an unrelated instance for Binary DiffTime
05:44:28 <ZFox> edwardk: Any {-# LANGUAGE flags? #-}
05:44:59 <mm_freak_> ZFox: this isn't about extensions…  this is about the possibility of getting instances wrong
05:45:01 <edwardk> ZFox: no, its a fundamental problem. you can {-# OPTIONS_GHC -fno-warn-orphans #-} to paper over the problem, but its just hiding it
05:45:13 <mm_freak_> what you wan't isn't forbidden, but it's unsafe
05:45:13 <edwardk> the potential issue will still be there
05:45:29 <mm_freak_> want
05:45:47 <ZFox> edwardk: Potential issue, overlapping instances I guess..
05:46:06 <edwardk> incoherent instances even
05:46:33 <`nand`> better question, how do I make this prettier? xs >>= \x -> map (x,) (f x)
05:46:50 <mm_freak_> ZFox: in haskell type class instances are considered to be globally unique…  i.e. it's wrong that two persons use different instances for the same class and type
05:47:07 <ZFox> http://hackage.haskell.org/packages/archive/text-binary/0.1.0/doc/html/src/Data-Text-Binary.html Heh
05:47:13 <edwardk> :t \xs -> xs >>= \x -> map (x,) (f x)
05:47:15 <lambdabot> Illegal tuple section: use -XTupleSections
05:47:25 <edwardk> :t \xs -> xs >>= \x -> map ((,) x) (f x)
05:47:26 <lambdabot> (Show a1, FromExpr [a]) => [a1] -> [(a1, a)]
05:47:29 <mm_freak_> `nand`: xs >>= liftA2 map (,) f
05:48:03 <mm_freak_> but i wouldn't call this "nicer"
05:48:09 <`nand`> no no, that's much nicer :)
05:48:10 <edwardk> xs >>= map <$> (,) <*> f   ?
05:48:12 <mm_freak_> i'd go with your original code
05:48:21 <`nand`> I was failing to see that (x,) is just “(,) x”
05:48:33 <danr> `nand`: are you in some specific monad here? (like list?)
05:48:39 <`nand`> danr: yes, in list
05:48:48 <mm_freak_> `nand`: well, you explicitly turned on TupleSections, so i wonder how you could miss that =P
05:48:51 <`nand`> danr: the ‘map’ sort of shows that
05:48:56 <ZFox> edwardk: How about if the instances are declared in say.. Data.Time.Binary ?
05:48:59 <danr> `nand`: right :)
05:49:13 <ZFox> (Cleaner to help prevent issues)
05:49:17 <`nand`> mm_freak_: that's in my ~/.ghci :)
05:49:24 <danr> `nand`: [ (x,fx) | x <- xs , fx <- f x ]
05:49:28 <edwardk> ZFox: trying to make a canonical place for them still relies on people spotting and following the convention
05:50:01 <edwardk> ZFox: i have about 12 orphan instances across several hundred modules of mine that i'm willing to deal with =P
05:50:13 <ZFox> Haha
05:50:22 <ZFox> You own half hackage!
05:50:24 <`nand`> orphans need love too
05:50:51 <edwardk> ZFox: just putting in perspective how often i feel the need for them
05:51:04 <edwardk> or rather that i give into the need
05:51:28 <mcstar> edwardk: when i was thinking about the problem, i thought to myself, 'e. kmett must know this...' and now, here you are helping me, sometimes dreams come true... :)
05:51:36 <edwardk> =)
05:51:41 <mcstar> (they just fixed my net a little earlier)
05:52:41 <mm_freak_> ZFox: in some rare cases it's impossible to get rid of orphans…  in those cases i define a separate module that i don't import anywhere
05:53:25 <mm_freak_> also defining orphan instances is much worse for libraries than it is for executables
05:54:02 <`nand`> edwardk: is there a way to avoid the usage of either associated type families or MPTCs with the truth table stuff?
05:54:04 <mm_freak_> but it's still a bad practice…  you may find your package facing overlapping instances later
05:54:10 <`nand`> also, when I used MPTCs, I needed to turn on UndecidableInstances
05:54:45 <edwardk> `nand`: you don't need either. an equality constraint can help inference though
05:55:07 <ZFox> mm_freak_: I may upload this to hackage... I have a known overlap. And this has a better instance.
05:55:16 <ZFox> (Mine is better and cleaner)
05:55:26 <ZFox> Also doesn't have a bug that the other has.
05:55:30 <edwardk> 'a better instance' is always a scary statement
05:55:58 <edwardk> because it implies that someone else who you may in the end wind up depending on may depend on that other instance transitively
05:56:09 <ZFox> edwardk: CloudHaskell << thousands of lines in the remote/process.hs and yea..
05:56:16 <`nand`> oh, perhaps I should have mentioned; I was generalizing to all functions of the form (Enum a, Bounded a, Truth b) => (a -> b)
05:56:29 <edwardk> if you really want the sane, safe solution is to just make a newtype wrapper
05:56:35 <ZFox> It has an instance of the same.
05:56:38 <`nand`> so I can't simply use a list for the ‘record’ type; but (a, TT b)
05:56:41 <ZFox> edwardk: Come again?
05:56:44 <edwardk> then you can make an instance for that
05:56:58 <edwardk> your problem is that you are making an instance Binary DiffTime, right?
05:57:04 <ZFox> so .. newtype UTCTime' = UTCTime ?
05:57:15 <edwardk> newtype ZFoxTime = ZFoxTime DiffTime
05:57:19 <ZFox> Well. that too
05:57:22 <edwardk> them make an instance on ZFoxTime
05:57:25 <`nand`> if I drop the generalization and stick to tt :: Truth a => a -> [[Bool]] like mcstar does then I don't need either TFs or MPTCs
05:57:29 <edwardk> instance Binary ZFoxTime
05:57:37 <edwardk> no orphans need die in the making of that instance
05:57:47 <ZFox> Okay
05:57:53 <edwardk> you can make a little combinator for the couple of fiddly binary parts that access it
05:58:06 * `nand` was puzzled for a moment about what time standard ‘ZFox’ referred to
05:58:10 <edwardk> and you can be sure that you don't have any issues if someone uses your code and the cloud haskell version
05:58:35 <edwardk> `nand`: oh, then since you made the problem harder you probably are stuck with _something_ extra
05:59:32 <`nand`> I could probably get away without either TFs or MPTCs by using a heterogeneous list
05:59:50 <ZFox> edwardk: Okay.. Suggestion for the file/module path?
05:59:57 <ZFox> Data.ZFoxTime?
06:00:04 * ZFox kept ZFox :P
06:00:11 <`nand`> never mind, that doesn't seem like it would work (without TFs) either
06:00:24 <mcstar> whats TF?
06:00:45 <mcstar> or MPTC for that matter
06:01:00 <aCube> type families and MultiParamTypeClasses I guess
06:01:06 <mcstar> thx
06:03:15 <aCube> How would an Applicative Instance for Map look like if it was possible (it's currently impossibly because of the Ord constraint?)
06:03:28 <ZFox> Oh god
06:03:50 <ZFox> edwardk: So now what.. I need to add instances for everything that I just wiped away by the newtype?
06:04:03 <edwardk> yes
06:04:08 <ZFox> Hmm
06:04:18 <Taneb> aCube, it isn't impossible because of the Ord constraint (that's Set)
06:04:21 <edwardk> or you just wrap it long enough to serialize it and unwrap it, etc.
06:04:26 <`nand`> aCube: before Ord, what would ‘pure’ look like?
06:04:36 <ZFox> Hmm
06:04:38 <`nand`> pure :: v -> Map k v -- what key?
06:05:33 <ZFox> edwardk: wrap how?
06:06:16 <edwardk> ZFox: you don't have to make ZFoxTime do everything DiffTime could do, it doesn't need to be used everywhere in your program you just need to be able to put it in when you need the instance in question
06:06:31 <edwardk> its a balancing act
06:07:03 <aCube> ZFox: GeneralizedNewtypeDeriving could help too
06:07:04 <ZFox> So I just need the fractional instance..
06:07:58 <ZFox> Also.. edwardk UTCTime takes two arguments.. Would that be newtype ZFoxUTime a b = ZFoxUTime (UTCTime a b) ?
06:08:01 * ZFox doesn't like that...
06:08:16 <edwardk> yes
06:08:24 <ZFox> a and b ? :/
06:09:32 <ZFox>     `UTCTime' is applied to too many type arguments
06:09:34 <ZFox> Hmm
06:10:08 * ZFox confused...
06:12:19 <aCube> data UTCTime = UTCTime {utctDay :: Day, utctDayTime :: DiffTime} No type argument? :O
06:13:00 <ZFox> So edwardk's newtype aint gonna work?
06:13:24 <aCube> ZFox: newtype ZFoxUTime = ZFoxUTime (UTCTime) ?
06:13:25 <edwardk> i have no idea where your bolting two args on that aren't there somehow became my newtype =P
06:14:20 <ZFox> http://ix.io/4Fy
06:14:22 <ZFox> Blahh
06:16:13 <ZFox> edwardk: aCube ^
06:17:29 * ZFox is heavily tempted to use {-# OPTIONS_GHC -fno-warn-orphans #-}
06:18:20 <ZFox> Would it really hurt to leave like this just like in the text-binary package.. Just the Time equiv
06:18:32 <ZFox> (And submit to hackage)
06:19:23 <pricklypear> in the Binary ZFoxUTime instance it looks like you're pattern matching on the wrong thing
06:19:32 <hpaste> edwardk pasted “for zfox” at http://hpaste.org/83739
06:19:36 <edwardk> there
06:19:53 <edwardk> you were just misunderstanding newtypes
06:20:02 <pricklypear> yep
06:20:05 <edwardk> that compiles and has all the instances
06:20:49 <edwardk> anyways, do whatever you want
06:22:01 <ZFox> Thanks edwardk
06:25:52 * ZFox believes he is missing something
06:26:41 <mcstar> edwardk: i think im getting closer, "Could not deduce (t ~ (Bool -> t))"
06:26:55 <ZFox> vim +'set ft=haskell' http://ix.io/4FA+4FB
06:27:02 <ZFox> edwardk: ^ :/
06:27:19 <mcstar> dont steal my personal instance of edwardk
06:27:25 <mcstar> XD
06:27:44 <ZFox> http://ix.io/4FC
06:28:05 * edwardk refers ZFox to mcstar and mcstar to ZFox for guidance, and then runs away.
06:28:14 <ZFox> NOOO!!
06:28:34 * hackagebot pqc 0.7.1.2 - Parallel batch driver for QuickCheck  http://hackage.haskell.org/package/pqc-0.7.1.2 (KidoTakahiro)
06:28:44 <edwardk> ZFox: your errors from here out are basic type errors
06:28:54 <aCube> Is a apply instance possible for maps?
06:29:03 <edwardk> aCube: its there
06:29:19 <ZFox> edwardk: http://ix.io/4FC << I understand the issue.. Just not the solution... :/
06:29:30 <ZFox> Ah
06:29:40 <edwardk> acube: 	
06:29:40 <edwardk> Ord k => Apply (Map k)
06:29:42 <haskell-new> Hello, is there any haskell rss parser?
06:29:44 <aCube> edwardk: oh, should have looked before asking :D
06:29:52 <edwardk> acube: there is also a Bind instance
06:31:25 <ZFox> http://ix.io/4FD hehehehe
06:32:44 <ZFox> edwardk: Suggestion?
06:32:47 <mcstar> OT: when i select a block in emacs and m-w copy it, the region becomes de-selected, but what if i want to use something else on that region, e.g. comment it out, whats the way to do it?
06:32:54 <ZFox> http://ix.io/4FE
06:33:08 <ZFox> ^ file with the errors http://ix.io/4FC
06:33:57 <ZFox> haskell-new: http://www.haskell.org/hoogle/?q=rss
06:34:19 <ZFox> @hoogle rss
06:34:20 <lambdabot> package rss
06:34:20 <lambdabot> package rss2irc
06:34:22 <ZFox> That works too
06:34:23 <applicative_>  fmap ZFoxUTime getCurrentTime :: IO ZFoxUTime
06:34:32 <ZFox> AH!
06:35:25 <ZFox> Hmm
06:35:34 <applicative_>  ZFoxUTime <$> getCurrentTime :: IO ZFoxUTime
06:35:36 <haskell-new> ZFox: "This library allows you to generate RSS 2.0 feeds"
06:35:51 <ZFox> Ah
06:36:08 <ZFox> haskell-new: rss2irc looks like it'll be doing some parsing :P
06:36:20 <ZFox> applicative_: Didn't work with either..
06:36:54 <ZFox> Expected type: Data.DateTime.DateTime Actual type: ZFoxUTime
06:36:54 <ZFox>     In the second argument of `addMinutes', namely `c'
06:37:15 <aCube> issued  = c --> issued = ZFoxUTime c
06:37:26 <aCube> fixes the first one
06:37:49 <aCube> expire  = addMinutes 3600 c --> expire  = ZFoxUTime $ addMinutes 3600 c
06:37:52 <aCube> should fix the 2nd one
06:38:05 <ZFox> Thanks aCube
06:38:29 <applicative_> ZFox: why are you newtyping UTCTime? I guess that has already been discussed...
06:38:34 * hackagebot tables 0.3 - In-memory storage with multiple keys using lenses and traversals  http://hackage.haskell.org/package/tables-0.3 (EdwardKmett)
06:39:01 <ZFox> applicative_: edwardk's suggestion to remove the fact of orphan instances. Fair enough point to do this.
06:39:11 <applicative_> oh
06:39:13 * ZFox is happy
06:39:24 <ZFox> applicative_: time has no binary instances
06:39:35 <applicative_> the isn't an official binary instance
06:39:37 <applicative_> right
06:39:56 * ZFox might replace time-binary with this technique too..
06:40:18 <applicative_> oh but there's a time-binary package?
06:40:59 * ZFox 's fav command for now.. rm **/*.{hi,o}
06:41:24 <mauke> 'make clean'
06:42:25 <applicative_> oh it looks like there's an instance in 'cloud haskell'...
06:42:34 <mcstar> edwardk: so, i think 'Bool doesnt unify with Bool -> t' is good, since this condition means, we can stop the type level recursion, i just dont understand what the type of 'tt' is going to be, since somehow, these types must unify....
06:42:44 <mcstar> dont tell me, im just reporting on my progress
06:44:18 <ZFox> applicative_: for time binary yes
06:44:36 <ZFox> applicative_: But it has A. a bug. B. is surrounded with thousands more lines of code :P
06:45:13 <applicative_> yes, I found out about it by the bug report
06:45:20 <ZFox> Yea
06:46:15 * ZFox extracts parts of his types into different files to fix instances of different things.
06:53:35 * hackagebot wl-pprint-terminfo 3.5 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-3.5 (EdwardKmett)
06:56:17 <mcstar> btw, i just realized, that the => in type segnatures is really like implication
06:56:25 <mcstar> :t show
06:56:27 <lambdabot> Show a => a -> String
06:56:46 <mcstar> if Show a (true) then the type of show is a->String
06:57:18 <bitonic> edwardk: since you are playing with wl-pprint: is it possible to specify a soft likebreak (e.g. with </> or ‘group’) which is ‘stronger’ than others, so that the pprinter will try to break other things first?  you can’t do this in the classic wl-pprint, but are there any related systems that do that?
06:57:39 <bitonic> I’m finding it very hard to have nice pretty printing without actually calculating the size of terms manually
06:58:33 <mcstar> the newest dance on the street: soft likebreak
06:58:51 <applicative_> ZFox, the one in 'cloud haskell' doesn't have a bug anymore.
06:59:23 <ZFox> applicative_: Anymore?
06:59:37 <ZFox> Meh. Which do you think has cleaner code? :P
06:59:56 <applicative_> man this is confusing. the package I found with the corrected instance is not obsoleted
07:00:47 <Foxboron> Helluw, Haskell people. Asking for a friend. He is looking for a Haskell book which is similare too the K&R book on C.
07:01:25 <bitonic> Foxboron: ‘Programming in Haskell’, Graham Hutton
07:01:31 <kennyd> Foxboron meaning terse and to the point?
07:01:48 <Foxboron> kennyd: sounds about right, yes.
07:02:22 <applicative_> ZFox: this has the corrected instance, thanking the bug reporter for it http://hackage.haskell.org/packages/archive/remote/0.1/doc/html/src/Remote-Process.html
07:05:19 <ZFox> applicative_: Meh
07:05:45 <ZFox> To install that is like installing lenses just for a single lense :P
07:06:25 <applicative_> ZFox yes I agree I'm just trying to figure out why there isn't a standard place to look
07:06:46 <ZFox> applicative_: It's a bit aweful aye :(
07:07:08 <ZFox> Text-binary uses the sugggested-against method with ignoring the orphans
07:07:13 <ZFox> The other package would do the same
07:07:31 <ZFox> (If even)
07:07:47 <applicative_> its because time is deeper in the standard ordering of the system than binary, but binary doesnt define it
07:08:23 <applicative_> yes, I am slowly retracing your steps...
07:09:42 <ZFox> :P
07:12:38 <ZFox> applicative_: Any idea for transmitting the data raw over a socket? (Use of the Binary instances!)
07:12:50 <ZFox> I don't think I'm sending nor recieving correctly :P
07:13:42 <ZFox> Must the protocol of communication be something like.. data TComm = CToken Token | CAction Action | etc
07:20:18 <LambdaDusk> how exactly does GHC optimize the "id" function away in arrows? Does it, even?
07:24:35 <ParahSail1n> how is stm stuff in ghc.conc implemented
07:24:41 <elliott> LambdaDusk: as in (id >>> x) etc.?
07:24:54 <elliott> unfortunately that's not equivalent to x in general, but for a specific instance it might get inlined away
07:25:11 <LambdaDusk> elliott: Yes... I mean not Prelude.id, but Control.Category.id
07:25:19 <elliott> yeah
07:25:41 <elliott> for (->), (id >>> x) is not the same as x in general, but if it is for a specific Category/Arrow instance it might get inlined away
07:26:25 <fryguybob> ParahSail1n: All the writes to TVars are kept private, then locks are acquired and the state of all the TVars involved in the transaction are check to ensure that nothing has changed.
07:27:02 * ZFox doesn't like the look of switching from network to network.socket/.bytestring/ :/
07:27:08 <fryguybob> ParahSail1n: Then if everything checks out (there is a moment where if all of the actions had happened in that moment it would be consistent) the writes are made public.
07:27:22 <ParahSail1n> are the locks themselves implemented in mvars/iorefs?
07:27:25 <fragamus> :t In
07:27:27 <lambdabot> f (Mu f) -> Mu f
07:27:34 <fragamus> :t Mu
07:27:35 <fryguybob> ParahSail1n: No spinlocks with CAS.
07:27:36 <lambdabot> Not in scope: data constructor `Mu'
07:27:53 <mikurubeam> :i Mu
07:28:12 <fryguybob> ParahSail1n: It is a combination of C and cmm code (mostly C).
07:28:42 <ParahSail1n> ah, cool
07:32:24 <aCube> @src Category.id :: a -> a
07:32:25 <lambdabot> Source not found. Sorry.
07:32:48 <`nand`> if I have something like ‘let xs = (foo, veryLargeObject)’ in memory and ‘veryLargeObject’ has been evaluated (and updated) in the past but from a certain point onwards will never be used in the code; can GHC automatically GC ‘veryLargeObject’?
07:33:08 <bitonic> @src id (->)
07:33:08 <lambdabot> Source not found. My pet ferret can type better than you!
07:33:16 <bitonic> @src Category.id (->)
07:33:16 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:33:26 <`nand`> @src Category (->)
07:33:26 <aCube> Why is id >>> x for (->) not the same as x ?
07:33:26 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:33:32 <`nand`> err
07:33:39 <`nand`> @where src
07:33:39 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
07:34:24 <`nand`> there's (->) (>>>) and (->) first and so forth, but no (->) id. Probably because it's trivial
07:35:38 <aCube> "for (->), (id >>> x) is not the same as x in general" why is this? Isn't id >>> x just x . id, which is x?
07:35:52 <elliott> aCube: (x . id) isn't x for some x
07:35:58 <elliott> consider x = undefined
07:36:07 <elliott> undefined `seq` x = undefined
07:36:14 <elliott> er, let's not reues x there
07:36:16 <elliott> undefined `seq` y = undefined
07:36:28 <elliott> (undefined . id) `seq` y = (\z -> undefined (id z)) `seq` y = y
07:36:36 <elliott> it's a nasty edge-case
07:37:03 <`nand`> is there terminology for “equal when ignoring ⊥” ?
07:37:08 <ZFox> Can someone please tell me the Network.Socket/Network.Socket.Bytestring alternative to Network alone?
07:37:39 <mcstar> `nand`: i know that equal equals iff :)
07:38:03 <mcstar> idk why would bottom equal bottom though
07:38:35 <mcstar> i would say bottoms are not distinguishable from each other, but they are still different, no?
07:39:27 <LambdaDusk> elliott: but then id could never be just plain optimised away?
07:39:33 <skuggi> I'm defining an ord instance for a fairly large ADT, and I'm not sure what to do when comparing different constructors.
07:39:54 <skuggi> I just want to put them in some arbitrary order. Is there an easy way to do that?
07:40:00 <`nand`> deriving Ord ?
07:40:08 <skuggi> no, i can't do that
07:41:13 <ParahSail1n> define compare?
07:41:13 <skuggi> I'm trying to compare syntax trees modulo alpha renaming
07:41:23 <`nand`> then there's no easy way out afaik
07:41:30 <`nand`> maybe something involving TH but that may turn out to be ugly
07:41:54 <fizbin> skuggi - why can't you derive Ord ?
07:41:55 <elliott> LambdaDusk: it could for an instance other than (->) which is strict
07:41:56 <skuggi> ParahSail1n: i mean wihtout having to pattern-match on every combination of constructors
07:42:04 <elliott> anyway you should just look at the Core GHC outputs if you want to know :P
07:42:10 <skuggi> fizbin: 16:39 < skuggi> I'm trying to compare syntax trees modulo alpha renaming
07:42:59 <`nand`> skuggi: you may be interested in http://hackage.haskell.org/package/bound-0.6.1
07:43:13 <LambdaDusk> elliott: I'm just interested if a long combination of id's is better than a complex case of
07:43:17 <`nand`> or otherwise just representing bound variables without using actual names
07:43:27 <`nand`> then you could live with the default Ord instance
07:44:09 <elliott> LambdaDusk: hm, what kind of case?
07:45:30 <skuggi> `nand`: you mean like HOAS?
07:45:31 <LambdaDusk> elliott: My idea is to write a load of arrow function like "\x -> if x then sth else id" and thus walk through the parameter returning an arrow that might be 60% id's
07:46:30 <`nand`> skuggi: yes
07:46:38 <skuggi> not an option either
07:46:53 <`nand`> what's the domain, if I may ask?
07:48:13 <elliott> LambdaDusk: ah
07:48:33 <elliott> LambdaDusk: you could instead write: \x -> if x then (sth >>>) else id
07:48:36 <elliott> or just
07:48:41 <elliott> \x f -> if x then sth >>> f else f
07:48:46 <skuggi> `nand`: it's the core language of a Repa-like DSL
07:49:03 <LambdaDusk> elliott: Ain't thought of that
07:53:15 <parcs> :t \x -> if x then +1 else id
07:53:17 <lambdabot> parse error on input `+'
07:55:58 <ozgura> :t \x -> if x then (+1) else id
07:56:00 <lambdabot> Num a => Bool -> a -> a
07:57:43 <Taneb> > 4 & prism absurd Left %~ (absurd :: Void -> Char)
07:57:45 <lambdabot>   Not in scope: `absurd'Not in scope: type constructor or class `Void'Not in ...
07:57:55 <Taneb> > 4 & prism absurd Left %~ (Data.Void.absurd :: Void -> Char)
07:57:56 <lambdabot>   Not in scope: `absurd'Not in scope: type constructor or class `Void'Not in ...
08:07:29 <luite> is there a test suite for integer-gmp somewhere?
08:07:36 <mjga> Anybody knows why don't we have basic tuple manipulation functions in the base? I mean things like: mapFst, mapSnd, tmap (a -> c, b -> d) -> (a, b) -> (c, d). There seem to be no instances of Applicative for tuples either. any ideas?
08:08:06 <mauke> mjga: you can't define pure for plain tuples
08:08:10 <Taneb> > ("Hello", (+1)) <*> (" world", 10)
08:08:12 <lambdabot>   ("Hello world",11)
08:08:22 <mauke> you need a Monoid constraint on the first part
08:08:24 <Taneb> Are you SURE there's no Applicative instance?
08:08:35 <Taneb> > fmap (+ 10) ("a", 10)
08:08:37 <lambdabot>   ("a",20)
08:08:44 <Taneb> There's map snd
08:09:02 <Taneb> > reverse *** (+ 10) $ ("hello", 3)
08:09:03 <lambdabot>   ("olleh",13)
08:09:05 <madjestic>  I am trying to grasp tree data structure.  The general definition is: data Tree a = Leaf a | Branch (Tree a) (Tree a).  Does it mean that there's either 1 leaf or 2 branches per tree node?  What if I need a possibility to allow indefinite number of leaves or an indefinite number of branches per node?  Whould that be possible?
08:09:06 <Taneb> There's tmap
08:09:15 <Taneb> :t first
08:09:16 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
08:09:26 <Taneb> > first reverse ("hello", 10)
08:09:27 <lambdabot>   ("olleh",10)
08:09:39 <Taneb> mjga, all the examples I've given are in base
08:10:06 <mauke> madjestic: that doesn't look like a "general definition" to me
08:10:06 <Taneb> madjestic, yes, and you can use lists
08:10:15 <mjga> Taneb: fmap is just mapSnd, thanks! is Arrow defined for (,)?
08:10:22 <Taneb> data Tree a = Leaf a | Branches [Tree a]
08:10:31 <Taneb> mjga, arrow is defined for (->) and uses tuples a lot
08:10:43 <mauke> :t Node
08:10:44 <lambdabot> a -> Forest a -> Tree a
08:10:47 <madjestic> mauke: that's a definition from LYAH and en.wikibooks.org on Haskell Data Structures
08:10:52 <mauke> madjestic: so?
08:10:57 <mauke> it's not a general tree
08:11:14 <Taneb> Basically, if you're using Control.Arrow as a utility, treat "a b c" as "b -> c", mjga
08:11:21 <madjestic> mauke: what would be a general definition then?
08:11:40 <mauke> depends on the kind of generality you want
08:11:53 <mauke> there's data Tree a = Node a [Tree a]
08:12:14 <mjga> Taneb: I didn't find Applicative for tuples.
08:12:39 <Taneb> mjga, look for "Monoid a => Applicative ((,) a)"
08:12:40 <madjestic> mauke: can you recommend a good reference on the topic?
08:12:43 <mjga> Taneb: so <*> for mapSnd, and Control.Arrow.first for mapFst, what about tmap?
08:12:59 <mauke> madjestic: I don't know if one exists
08:13:12 <mauke> I'm not even sure this is a useful question
08:13:30 <Taneb> mjga, fmap or Control.Arrow.second for mapSnd, Control.Arrow.first form mapFst, Control.Arrow.(***) for tmap
08:13:44 <mauke> did you mean: (Control.Arrow.***)
08:13:48 <Taneb> mjga, (<*>) is "mapSnd and append fst"
08:13:52 <Taneb> mauke, shh
08:13:57 <mjga> Taneb: thanks! :-)
08:13:59 <hpaste> mcstar pasted “predicates” at http://hpaste.org/83742
08:14:10 <mcstar> edwardk: can you check that ^ ?
08:14:18 <mcstar> im stuck with this
08:14:25 <mjga> Taneb: I must say that occasionally it is not easy to find an util method among these classes...
08:14:49 <mcstar> i think i sort of get why Could not deduce (t ~ (Bool -> t)) happens, but dont know how to go around that
08:14:50 <Taneb> mjga, that's because they were designed as a generalisations rather than utilities
08:15:02 <madjestic> mauke: what do you mean?
08:15:16 <Taneb> mjga, Arrow and its friends generalise (->)
08:15:20 <mauke> madjestic: just define the data structure you need
08:15:40 <applicative_> madjestic: say more about the trouble?  data Tree a = Leaf a | Node [Tree a] more immediately fits your description.
08:16:21 <applicative_> madjestic: but the Data.Tree definition is better.
08:16:25 <mjga> Taneb: I know, but I must say, that while Monad, or Functor classes are relatively easy to use, I am still getting lost with Applicative and Arrow. Any decent guides there?
08:16:40 <jmcarthur> mcstar: typically if you find yourself trying to write a recursive type and you know it's actually what you want then you should introduce a newtype wrapper somewhere to "break" the recursion
08:16:52 <Taneb> mjga, Applicatives are almost Monads, except you can't use join
08:16:54 <jmcarthur> mcstar: usually if you do it by accident, though, it's just a mistake
08:17:01 <mjga> Taneb: BTW type classes seem the best example of how knowing a library may be more complex than knowing the language
08:17:07 <mcstar> jmcarthur: edwardk said i wont need recursive types
08:17:36 <mjga> Taneb: I know their basic methods, it is just not always apparent what they are supposed to do :-).
08:17:36 <jmcarthur> not sure what you're doing. also i have to run :\
08:17:42 <jmcarthur> good luck
08:17:44 <mcstar> ok, thanks
08:18:14 <mcstar> for others, the paste tries to evaluate an n-ary function
08:18:29 <mcstar> the arguments are all Bools
08:19:00 <mcstar> the desired effect for 'tt (&&)' would be (&&) True True = True
08:19:20 <mcstar> or, 'tt not' not True = False
08:19:20 <mjga> Taneb: until today, I would only use Control.Arrow, if trying to define function-like objects, not as a utility at all :-).
08:19:45 <Taneb> mjga, pure is return, simple as that. (<*>) takes a thing full of functions, and a thing full of inputs to the function, and applies the functions and the inputs in some way, then combines the rest of the things together
08:20:06 <mjga> Taneb: thx
08:20:09 <Taneb> And some people say you shouldn't use Control.Arrow as a library
08:20:45 <Taneb> Utility, rather
08:21:34 <Taneb> Because most of the things in there can easily be expressed with lambdas if you just want the (->) instance
08:21:55 <Taneb> first f ~ \(a, b) -> (f a, b)
08:22:16 <Taneb> f *** g ~ \(a, b) -> (f a, g b)
08:22:18 <Taneb> etc
08:22:51 <Taneb> And most of the time this will be a lot simpler
08:24:18 <mjga> Taneb: but using a library of the same object is more readable than redundant lambdas.
08:24:51 <applicative_> mcstar: dont you want something like   tt p bool = tt (p bool)
08:24:55 <mjga> if one uses a lot of tuple juggling along a spaghetti of (.)
08:25:09 <Taneb> Yeah, use whatever feels good for you
08:25:16 <mcstar> applicative_: first, lets just evaluate all the arguments as True
08:25:17 <mjga> applicative_: tt $ pp bool
08:25:43 <mjga> applicative_: partial application: (tt . p)
08:26:26 <mcstar> so, the problem is just as i stated: tt is the evaluator, that takes an n-ary predicate and evaluates it at True.... 'pred True True True..'
08:27:51 <`nand`> mcstar: I can say that your type for ‘tt’ doesn't look like what I'd use
08:28:15 <mcstar> `nand`: you were here when edwardk suggested that, im following his lead
08:28:31 <madjestic> mauke: applicative_ thanks, I'll look deeper into GADT then
08:28:53 <`nand`> mcstar: well, if you want to do it the way I did; I'd suggest tt :: t -> Table; where Table = [[Bool] or whatever
08:28:57 <mcstar> i think the problem is, that haskell cant decide what the type of tt will be in the recursion, since it cant look into 't'
08:29:22 <mcstar> `nand`: lets just solve this reduced problem first, ok? all the arguments are True
08:29:25 <mauke> mcstar--  # pasting incomplete code
08:29:45 <mcstar> mcstar++ # funny guy
08:30:24 <mcstar> mauke: does it complain about flexibleinstances?
08:30:29 <mauke> yes
08:30:37 <`nand`> mcstar: then I'd use tt :: t -> Bool
08:30:38 <mcstar> thats the only omission
08:30:41 <mauke> yes
08:30:54 <`nand`> or [Bool] if you want to keep track of the arguments as well or w/e
08:31:20 <`nand`> (but using a list for that is hacky either way imo)
08:34:37 <invariant> What happened to shime?
08:35:08 <invariant> More abandonware?
08:35:28 <`nand`> the problem is your type seems to make no sense; at least to me
08:35:34 <mauke> yeah
08:35:42 <`nand`> why would you want to return a function again? you want a table
08:35:45 <mauke> tt p x = p x x  -- compiles
08:35:56 <mauke> but of course tt (&&) :: Bool -> Bool
08:36:18 <mcstar> can we just focus on the problem i stated?
08:36:24 <mauke> no
08:36:33 <mcstar> ok, mauke cant
08:36:35 <`nand`> what's the problem you stated?
08:36:36 <invariant> mcstar, state the problem again.
08:36:41 <mcstar> i hope that `nand` can
08:36:54 <mauke> <̈
08:37:03 <mcstar> "the problem is just as i stated: tt is the evaluator, that takes an n-ary predicate and evaluates it at True.... 'pred True True True..'"
08:37:25 <invariant> mcstar, and you want to define tt?
08:37:27 <`nand`> then the type makes no sense; you want tt :: t -> Bool
08:37:31 <mcstar> invariant: yes
08:37:44 <invariant> mcstar, use type-classes, see printf hack.
08:37:47 <invariant> mcstar, problem solved.
08:37:49 <mauke> ...
08:37:50 <mcstar> yes, thanks
08:37:51 <`nand`> (keep in mind ‘Bool’ is a 0-ary predicate too)
08:37:56 <invariant> Next question.
08:38:02 <mcstar> now the problem is that i dont want to look it up
08:38:05 <mcstar> and solve it myself
08:38:09 <mcstar> with a little help
08:38:42 <invariant> mcstar, you just do induction on n-ary predicates.
08:39:00 <mauke> oh, nice
08:39:09 <mcstar> i will work with what `nand` said, lets see where do i end up
08:39:24 <invariant> mcstar, you start with a one predicate type and you add function type constructors to the mix for the non-base case.
08:39:24 <mauke> mcstar: lines 4 and 5 are perfect
08:39:30 <mauke> mcstar: you just have to change the rest :-)
08:39:31 <invariant> mcstar, via type classes.
08:39:46 <`nand`> yes
08:39:48 <invariant> But I don't see the point in reinventing the wheel.
08:39:53 <mauke> (hint: line 8 should be 'tt p = p')
08:40:01 <`nand`> hey, that's not a hint!
08:40:03 <`nand`> that's a spoiler
08:40:12 <invariant> I mean, type-classes are just one particular way to express things, it's not necessarily the best way.
08:40:17 <mcstar> i tried that earlier, it somehow didnt work
08:40:19 <`nand`> now he effectively has the whole solution
08:40:26 <mcstar> (the last tt being equal to id)
08:40:32 <invariant> I think all such n-ary APIs are terrible.
08:40:38 <invariant> (to use, that is)
08:40:39 <mauke> `nand`: no, the class itself is still missing
08:40:47 <`nand`> mauke: I already gave the signature of tt
08:40:58 <mauke> oops, maybe I should have paid more attention to you
08:41:06 <mauke> well then
08:41:10 <`nand`> oh well
08:41:14 <invariant> If the compiler had pluggable error message, then it could be useful for DSLs, but since it doesn't it's nothing bug showing off how great you are.
08:41:15 <`nand`> it's still a challenge to expand it to the full table
08:41:20 <`nand`> rather then just evaluating at TYrue
08:41:22 <`nand`> True*
08:41:28 <invariant> In actual reality is it completely useless and a bad idea.
08:42:17 <mcstar> `nand`: i had a solution for that, if i can manage this
08:42:35 <mcstar> we'll see if i was correct though
08:43:00 <`nand`> then I guess the next challenge will be expanding it to arbitrary functions of listable domains, not just Bool ;)
08:43:23 <plat0> How do I cabal install profiling versions of libraries?
08:43:28 <mcstar> jesus
08:43:42 <mcstar> it works as you guys suggested
08:43:46 <Heffalump> plat0: cabal install --enable-library-profiling
08:43:56 <mcstar> all i had wrong, is the type of tt in class Predicate
08:43:56 <mauke> plat0: edit your ~/.cabal/config, put 'library-profiling: True' in it
08:44:27 <mcstar> (not wrt. the paste)
08:44:30 <Heffalump> plat0: only problem is it won't recurse over libraries you've already got installed
08:44:32 <plat0> Can I tell it then to automatically reinstall everything I have with profiling?
08:45:35 <Heffalump> unfortunaely no :-(
08:45:51 <plat0> Hmmm what should I do then for the packages I already have?
08:46:15 <mauke> I wonder how much 'cabal install `ghc-pkg list --simple-output --names-only`' would break
08:46:49 <Taneb> mauke, approximately everything
08:47:09 <mauke> yay
08:47:49 <Taneb> Actually
08:48:07 <Taneb> You could break even more by adding "--force-reinstalls" to the end
08:49:23 <`nand`> plat0: can't you just rebuild the world?
08:50:34 <plat0> `nand`: By deleting .ghc, or some other way?
08:50:51 <`nand`> I don't know
08:50:58 <`nand`> I thought cabal-install has a command to rebuild the world
08:51:10 <`nand`> I don't use cabal-install. you probably shouldn't listen to advice from me
08:51:25 <`nand`> `cabal-install world` or something
08:54:30 <mauke> cabal install --dry-run $(for i in $(ghc-pkg list --simple-output --names-only); do echo "$i"; done | egrep -v '^(bin-package-db|ghc-prim|integer-gmp|rts|ghc)$')
08:54:45 <plat0> wow
08:56:59 <`Jake`> can you load two scripts into ghci?
08:57:19 <`nand`> :l file1.hs file2.hs
08:57:23 <`Jake`> ah, thanks
08:57:33 <`Jake`> I tried :l + file2.hs
08:57:44 <applicative_> plat0: you know there is a field in your ~/.cabal/config file to compile everything also for profiling
08:57:51 <`nand`> (that aside; shouldn't just using :l file2.hs after having file1.hs already loaded work?)
08:58:06 <`Jake`> Nope, first file isn't loaded anymore if I do that
08:58:15 <`nand`> ah, okay
08:58:37 <mcstar> you can add if it is a module
08:58:49 <mcstar> but afaik you cant work at 2 modules at once
08:59:39 <invariant> Cabal install solves one problem and creates 200.
08:59:42 <mcstar> `nand`: how did you arrive at, that the type of tt is t -> Bool ?
08:59:48 <mcstar> is it that intuitive for you?
09:00:10 <`Jake`> yeah... looks like the second file isn't actually loaded with :l file1 file2
09:01:30 <`nand`> mcstar: “I want to take some predicate and evaluate it at True”; your predicate is ‘t’, because that's what we're trying to generalize over; and ‘Bool’ is the result of applying a predicate
09:01:56 <`nand`> so if your function takes a predicate and returns its result (at True); that's the only logical type that occurs to me
09:02:12 <plat0> When two packages provide the same functions, how does ghc choose between them?  e.g. sandi and dataenc both provide Codec.Binary.Base64.encode
09:02:12 <mcstar> somehow it was natural for me to put the tail of the type into the type variable t
09:02:13 <`nand`> `Jake`: ah, that's unfortunate
09:02:32 <`nand`> mcstar: plus, I've seen instances like PrintfType in the past
09:02:33 <`Jake`> I think they should add something like that
09:02:47 <mcstar> thanks you and mauke
09:02:55 <mcstar> and invariant ofc
09:02:57 <`ramses> what are the right commands to install a cabal package from a source directory instead of from hackage? Google is giving me contradicting answers..
09:03:09 <`nand`> mcstar: if you're interested, I can show you the version of ‘Predicate’ I came up with that isn't limited to Bool
09:03:37 * hackagebot hakyll 4.2.1.1 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.2.1.1 (JasperVanDerJeugt)
09:04:02 <mcstar> `nand`: ok, paste away
09:06:56 <hpaste> “`nand`” annotated “predicates” with “predicates (annotation)” at http://hpaste.org/83742#a83743
09:10:14 <`nand`> mcstar: ^
09:10:20 <mcstar> yes
09:10:29 <mcstar> in the meantime, i made it work with lists
09:10:34 <`nand`> you could also use MPTCs and FunDeps instead of the associated type but then it seems to require UndecidableInstances
09:10:56 <NougatRillettes> Hey guys, I'm having some issues with Vec package : http://paste.awesom.eu/NougatRillettes/XBe
09:10:56 <mcstar> i would rather stick to the basics :)
09:11:02 <`nand`> fair enough :)
09:11:29 <`nand`> mcstar: if your aim is to pretty-print this stuff, you could also just throw in a Show a and ‘show’ it before prepending to a [String] ;)
09:11:48 <NougatRillettes> it seems like the compiler is unable to decide wether it is a 1 element vector or not
09:11:49 <mcstar> Show is aimed to be Read-able back
09:11:54 <NougatRillettes> -not + more
09:11:58 <mcstar> but sure, i can do that
09:12:12 <NougatRillettes> as those two do not have the same instance
09:12:20 <NougatRillettes> How could I fix that ?
09:13:38 <`nand`> probably by adding a ZipWith ... constraint to your ‘trad’ signature
09:15:13 <`nand`> NougatRillettes: from the compilers point of view, ‘v’ in your type could be anything; even something that doesn't have ZipWith implemented at all
09:16:40 <NougatRillettes> hm, it actually worked
09:16:45 <NougatRillettes> ok thank you very much :)
09:17:43 <NougatRillettes> but, these instance mess is a bit of a shame
09:18:06 <NougatRillettes> I mean, couldn't I force GHC to arbitrary chose one of the two instances ?
09:18:47 <`nand`> not if your function is polymorphic
09:18:59 <ab9rf> NougatRillettes: do you really want a compiler that generates code stochastically?
09:19:11 <`nand`> :)
09:19:38 <NougatRillettes> aha, indeed
09:19:40 <NougatRillettes> thx :)
09:19:46 <Moggle> this is probably a dumb question, but I'm parsing HTTP headers and I'd like to store them in a nice associative array kind of thing. What data type should I be using? I'm kinda thinking a Tree would be fine.
09:20:23 <Moggle> is there an easy mutable data structure I could try using or something?
09:20:58 <sproingie> not sure why you'd need to mutate them, they're not going to change after reading them
09:21:34 <ab9rf> indeed
09:21:57 <ab9rf> why a tree?  http headers don't have a tree structure
09:22:28 <sproingie> anyway happstack or snap or yesod would have something
09:23:09 <sproingie> not sure which ones are ala-carte, i still do all my http stuff in python :)
09:23:34 <Moggle> they're static, obviously, which is why I suggested a tree
09:23:37 <danharaj> http://hackage.haskell.org/package/tagsoup-0.12.8
09:23:50 <Moggle> hashtables dont lend themselves well to being pure
09:24:00 <Moggle> so I was just curious if there's an easy solution I'm overlooking
09:24:19 <Moggle> I'll probably end up using Data.HashTable anyways, I'm already stuck in IO.
09:24:27 <pankajm> O(1) lookup in key:value pairs like Map?
09:24:30 <`nand`> associate array kind of thing -> Map k v?
09:24:35 <`nand`> but that has log n lookup
09:24:36 <sproingie> sure, you're reading it off the network so it's all in IO
09:25:09 <sproingie> but i'm sure one of the web frameworks out there has something
09:25:10 <Moggle> well yes nand
09:25:20 <danharaj> Moggle: Data.HashTable is deprecated. Use the unordered-containers package.
09:25:25 <Moggle> O(1) is ideal. I mean, it doesn't really matter because HTTP headers are so short
09:25:37 <sproingie> lookup may be log n but consider that there usually arent that many http headers
09:25:38 <`nand`> yes I wouldn't worry about the lookup overhead
09:25:46 <ab9rf> Moggle: there aren't enough headers on a request to really care about overhead
09:25:51 <Moggle> but yeah, I'm just kind of feeling awkward right now. I'd use a hash in any language that wasn't functional.
09:26:00 <Moggle> but kay, thanks! map it is
09:26:42 <ab9rf> you're probably going to have to spool all of the headers off the first time any header is needed anyway
09:28:18 <ab9rf> i hate computers
09:28:33 <pankajm> what would be an elegant way to memoize this :
09:28:43 <dmwit> Moggle: forall n, log n < 30
09:28:46 <pankajm> insertCoin 0 = 1
09:28:46 <pankajm> insertCoin n = insertCoin (n `div` 2) + insertCoin (n `div` 3) + insertCoin (n `div` 4)
09:28:46 <pankajm>  
09:29:25 <pankajm> elegance > efficiency ...
09:29:26 <dmwit> pankajm: There's half a dozen packages for memoization on Hackage.
09:31:29 <plat0> pankajm: http://stackoverflow.com/questions/3208258/memoization-in-haskell/3209189#3209189
09:32:05 <`nand`> heh, exact same function
09:32:22 <`nand`> well, nearly
09:34:30 <`nand`> “*Main> fastest_f' 12308918230918230182031231231293810923” wow
09:40:10 <dmwit> 12308918230918230182031231231293810923 is the canonical large number
09:40:23 <dmwit> this is because it can be represented as 10 in base 12308918230918230182031231231293810923
09:40:33 <sproingie> nonsense.  everyone knows really large numbers don't start with 1
09:40:49 <int-e> using Data.MemoTrie (MemoTrie package): let f = memo f'; f' 0 = 1; f' n = f (n `div` 2) + f (n `div` 3) + f (n `div` 4) in f 12308918230918230182031231231293810923 (in ghci) --> 26970533984249697025356282239947995350131 in 0.36 seconds.
09:40:49 <dmwit> Actually, most numbers (large or not) start with 1.
09:40:51 <sproingie> plus the most random number is 17
09:40:53 <mcstar> how much is 2 up up up 6?
09:41:09 <dmwit> https://en.wikipedia.org/wiki/Benford%27s_law
09:41:48 <mcstar> dmwit: thats wrong, most price tags have a lot of 9's in them
09:42:00 <dmwit> There are different laws than Benford's laws for later digits.
09:42:05 <dmwit> Benford's law is only about the *first* difit.
09:42:07 <dmwit> digit.
09:42:13 <sproingie> "lonelier than the 9 key on a microwave"
09:44:00 <`nand`> isn't that statement in particular referring to distributions of data spanning multiple orders of magnitude? And not ‘large numbers’ in general; though it could probably just be applied to some suitably defined arbitrary set of integers
09:44:08 <int-e> dmwit: I wonder, do you know of any comparison of those packages?
09:44:36 <dmwit> int-e: I don't. I ran a comparison by hand some time ago on a small problem I had (basically a microbenchmark) and they were all within 10-20% of each other.
09:44:56 <int-e> dmwit: thanks, that helps :)
09:45:56 <mcstar> `nand`: can (Predicate t) be made an instance of Show?
09:46:33 <plat0> Does someone know why Shelly uses Text instead of ByteString?
09:46:59 <`nand`> that's a kind error
09:47:00 <sproingie> isn't Text the new sexy thing?
09:47:14 <dmwit> Perhaps somebody is trying to drag 1980s technology into the 21st century?
09:47:17 <`nand`> “Predicate t” is a constraint
09:47:46 <dmwit> Hell, 1980s might be too late. Shells and terminals are OLD.
09:48:26 <int-e> yeah, many shells are fossils :)
09:48:50 <mcstar> `nand`: aham, and now i need undecidable instances
09:51:02 <mcstar> this is fun
09:51:08 <mcstar> i say 'not' and see the truthtable
09:51:12 <mcstar> or (&&)
09:51:19 <mcstar> lol
09:52:43 <`nand`> dmwit: hmm, now that I think about it, I'm sure there's a proof that numbers are more likely to start with a ‘1’ than any other digit (but not necessarily that most do); for a given range of integers below n as n progresses to infinity
09:53:00 <`nand`> err
09:53:31 <`nand`> most numbers start with 1 compared to any other digit; but not compared to not starting with 1
09:54:32 <hpaste> “mcstar & #haskell” pasted “truthtable” at http://hpaste.org/83746
09:54:51 <mcstar> `nand`: look at that :)
09:56:53 <`nand`> why so complicated?
09:57:09 <mcstar> `nand`: what is?
09:57:22 <`nand`> ‘Predicate’
09:57:33 <mcstar> is it?
09:57:34 <`nand`> [(t,[Bool])] -> [[Bool]] -- ??
09:57:36 <dmwit> `nand`: You are of course right that to be careful about it you have to specify a distribution on numbers, and that, generally speaking, Benford's law is about the particular distribution that looks flat on a log scale and spans many orders of magnitude.
09:57:42 <dmwit> Luckily, many real-world distributions look like that.
09:57:58 <mcstar> `nand`: im keeping all the truth values that a predicate was evaluated at
09:58:17 <`nand`> mcstar: try tt :: t -> [[Bool]]
09:59:00 <dmwit> mcstar: You might like something like class Universe a where universe :: [a]; instance (Universe a, Show b) => Show (a -> b)
09:59:02 <`nand`> I'll give you a hint: instance Predicate Bool where tt p = [[p]]
09:59:17 <`nand`> dmwit: I'd like a class Universe :)
09:59:27 <dmwit> `nand`: can't tell you how many times I've written it
09:59:27 <`nand`> though (Enum a, Bounded a) works as a hacky substitute
09:59:27 <sproingie> lesson apparently is, if you're going to commit accounting fraud, you should know statistics
09:59:36 <dmwit> freaking handy in so many situations
10:00:03 <`nand`> dmwit: but regardless, generalizing to arbitrary predicates here complicates the solution somewhat
10:00:26 <`nand`> eg. http://hpaste.org/83743
10:01:59 <parcs> @free concat
10:02:01 <lambdabot> $map f . concat = concat . $map ($map f)
10:02:22 <dmwit> I don't really understand the high-level goal, so you're probably right.
10:02:29 <parcs> g . concat = concatMap g?
10:03:27 <dmwit> only guaranteed to be true if g = map f
10:03:38 * hackagebot lagrangian 0.4.0.0 - Solve lagrange multiplier problems  http://hackage.haskell.org/package/lagrangian-0.4.0.0 (JonathanFischoff)
10:03:52 <parcs> oh right
10:04:11 <dmwit> It's less surprising if you read it as "if you apply f pointwise after concatting, that's the same as applying f pointwise before concatting"
10:04:32 <hpaste> irene-knapp pasted “!!!” at http://hpaste.org/83749
10:04:50 <irene-knapp1> so I don't understand why it's thinking I'm using the IO monad directly
10:04:58 <`nand`> dmwit: as I understood it, the high level goal is pretty-printing a truth table of functions (in particular ones only operating on Bool); with a Show instance like you mentioned you might lose too much information to pretty print effectively
10:04:59 <irene-knapp1> after I quite explicitly specified a stack of transformers in every possible place
10:05:28 <irene-knapp> (I doubt that the NoImplicitPrelude has anything to do with it, but I included it in the reduction just in case)
10:05:57 <dmwit> irene-knapp: without looking, you forgot liftIO somewhere
10:05:58 * dmwit now looks
10:06:04 <irene-knapp> sure, but I don't see where :)
10:06:50 <irene-knapp> note that there are actually instances for MonadProcessing m => MonadProcessing (ConduitM i o m) and similarly for MonadDiagnostic m
10:07:04 <irene-knapp> although I don't think that's relevant because the problem is happening before instance resolution, isn't it?
10:07:08 <irene-knapp> and thanks for looking :)
10:07:10 <parcs> is readFile from the prelude?
10:07:20 <irene-knapp> no, I wrote it elsewhere, but I gave a … hm
10:07:40 <irene-knapp> well, it's got NoImplicitPrelude so I'm pretty sure it's resolving to mine and not theirs
10:07:45 <irene-knapp> I did try putting a type signature around it
10:07:47 <crl> :t ($$)
10:07:49 <lambdabot> Doc -> Doc -> Doc
10:07:55 <crl> @src ($$)
10:07:56 <lambdabot> Source not found. You untyped fool!
10:08:05 <monochrom> what is the type of $$ ? also the type of readFile?
10:08:08 <irene-knapp> ($$) :: http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Monad m => http://hackage.haskell.org/packages/archive/conduit/1.0.2/doc/html/Data-Conduit.html#t:Source m a -> http://hackage.haskell.org/packages/archive/conduit/1.0.2/doc/html/Data-Conduit.html#t:Sink a m b -> m b
10:08:13 <irene-knapp> er
10:08:14 <irene-knapp> sorry
10:08:22 <irene-knapp> ($$) :: Monad m => Source m a -> Sink a m b -> m b
10:08:26 <irene-knapp> it's from conduit
10:08:31 <irene-knapp> readFile's type is given in the comment block below
10:08:40 <e98> is there a known build errow with ghc.git?
10:08:54 <e98> fails for me at libraries/vector/Data/Vector/Fusion/Stream/Monadic.hs:104:1
10:09:07 <e98>     Failed to load interface for `GHC.Desugar'
10:09:13 <dmwit> ?hoogle runResourceT
10:09:13 <lambdabot> No results found
10:09:23 <irene-knapp> that's from resourcet and the type is
10:09:34 <irene-knapp> runResourceT :: http://hackage.haskell.org/packages/archive/resourcet/0.4.5/doc/html/Control-Monad-Trans-Resource.html#t:MonadBaseControl http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/System-IO.html#t:IO m => http://hackage.haskell.org/packages/archive/resourcet/0.4.5/doc/html/Control-Monad-Trans-Resource.html#t:ResourceT m a -> m a
10:09:35 <irene-knapp> gah
10:09:37 <irene-knapp> bad paste, bad
10:09:47 <irene-knapp> runResourceT :: MonadBaseControl IO m => ResourceT m a -> m a
10:11:03 <dmwit> irene-knapp: Is it possible that ProcessingT, ResourceT, and DiagnosticT only have MonadProcessing instances when their underlying monad has a MonadProcessing instance?
10:11:11 <irene-knapp> hmm
10:11:16 <irene-knapp> it's conceivable
10:11:32 <irene-knapp> it's supposed to have (Monad m) => MonadProcessing (ProcessingT m)
10:11:35 <irene-knapp> but let me check
10:11:40 <irene-knapp> the other ones that's clearly true for
10:12:07 <irene-knapp> oh WOW
10:12:15 <irene-knapp> I forgot to write the base instance for MonadProcessing
10:12:18 <irene-knapp> thank you, preemptively!
10:12:20 <irene-knapp> trying that now
10:12:24 <dmwit> yaaaay
10:12:33 <irene-knapp> there were so many other instances that had to be written that I forgot all about that one, lol
10:12:52 <irene-knapp> (MonadResource implies Applicative, which was a veggie pita since I'm not used to it at all)
10:13:11 <irene-knapp> (and MonadBaseControl is just a carnivore pita all on its own)
10:13:33 <dmwit> I've written a few MonadBaseControl instances, but never by understanding MBC.
10:13:37 * irene-knapp nods
10:13:40 <irene-knapp> I understand it… mostly :)
10:13:47 <irene-knapp> but still
10:17:38 <mcstar> btw, im reading the haskell road to logic, if anyone was wondering
10:17:47 <irene-knapp> well, that worked and thank you dmwit :D
10:19:06 <dmwit> You have OverlappingInstances or IncoherentInstances or something silly like that on, don't you.
10:19:10 <dmwit> bad irene
10:19:12 <irene-knapp> I do, sorry
10:19:19 <irene-knapp> UndecidableInstances actually
10:19:24 <irene-knapp> which is the least-horrible of those, but
10:19:38 <danharaj> UndecidableInstances isn't really ever that bad.
10:19:41 <dmwit> Undecidable is mostly okay. I'm really surprised about the error it gave you, then.
10:19:41 <irene-knapp> I wrote that part last night and I don't remember why I needed it
10:19:52 <irene-knapp> but I was convinced at the time that I did need it, haha
10:20:03 <irene-knapp> yeah...
10:20:08 <irene-knapp> I was pretty surprised myself :)
10:20:14 <danharaj> {-# LANGUAGE StopBuggingMeAboutExtensions #-}
10:20:17 <irene-knapp> har
10:20:33 * irene-knapp has also been making an effort to wean herself off open imports
10:20:39 <dmwit> {-# LANGUAGE JustAddWhateverYou'reAboutToSuggestInYourErrorMessage #-}
10:20:46 * irene-knapp is using NoImplicitPrelude to that end :)
10:20:54 <danharaj> open imports?
10:21:09 <dmwit> I'm betting either unqualified or imports with no ().
10:21:09 <beaky> hello
10:21:16 <irene-knapp> that's when symbols from the module you're importing are now available unqualified in the one you use
10:21:23 <irene-knapp> it's an ML bit of terminology, I'm told
10:21:26 <beaky> what are some alternatives to using typeclasses?
10:21:28 * dmwit chalks up half a point for himself
10:21:34 <dmwit> beaky: make a record
10:21:39 <danharaj> beaky: carry around your dictionary.
10:21:43 <dmwit> and pass it around explicitly
10:21:46 <beaky> I read a blogpost somewhere that said 'scrap your typeclasses' or something
10:21:55 <danharaj> I don't think there's a problem with open imports then.
10:22:02 <danharaj> We have GHCi, hackage, hayoo, and hoogle.
10:22:07 <irene-knapp> so you enjoy having fifty definitions of concat?
10:22:17 <danharaj> I enjoy not using libraries that crowd up the name concat ;)
10:22:20 <irene-knapp> haha
10:22:23 <irene-knapp> yeah, that works :)
10:22:28 <danharaj> There's already a name for concat. It's (<>)!
10:22:31 <irene-knapp> haha
10:22:42 <beaky> > [1..3] <> [5..10]
10:22:44 <lambdabot>   [1,2,3,5,6,7,8,9,10]
10:22:49 <beaky> wow didn;t know that
10:22:55 <beaky> :t (<>)
10:22:56 <lambdabot> Monoid m => m -> m -> m
10:23:02 <elliott> :t concat
10:23:04 <lambdabot> [[a]] -> [a]
10:23:05 <beaky> that's awesome
10:23:07 <aCube> it's mconcat
10:23:11 <danharaj> Although I use the definition of (<>) in semigroups
10:23:13 <beaky> oh
10:23:20 <elliott> :t fold
10:23:21 <lambdabot> (Foldable t, Monoid m) => t m -> m
10:23:23 <aCube> <> is mappend, no?
10:23:24 <elliott> the one true concat
10:23:27 <elliott> (ok, or join)
10:23:29 <danharaj> oh, that's concat?
10:23:34 <danharaj> that also has a name: join
10:23:37 <beaky> concat is like mconcat
10:23:40 <elliott> danharaj: it's in Prelude :P
10:23:58 <aCube> join is concat?
10:24:08 <danharaj> concat is join for lists
10:24:20 <danharaj> :t join
10:24:22 <lambdabot> Monad m => m (m a) -> m a
10:24:39 <aCube> :t mconcat
10:24:40 <lambdabot> Monoid a => [a] -> a
10:24:46 <aCube> :t fold
10:24:47 <lambdabot> (Foldable t, Monoid m) => t m -> m
10:28:23 <crl> > [1..3] `mappend` [5..10]
10:28:25 <lambdabot>   [1,2,3,5,6,7,8,9,10]
10:31:43 <crl> > (Just(Just [1..3])) `mappend` (Just (Just [5..10]))
10:31:45 <lambdabot>   Just (Just [1,2,3,5,6,7,8,9,10])
10:32:41 <dmwit> =/
10:33:35 <dmwit> > 3 :: Product Int -- also =/
10:33:37 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Product GHC.Types.Int))
10:33:37 <lambdabot>    arisin...
10:34:41 <beaky> i love typeclasses
10:35:30 <beaky> they are so elegant
10:38:15 <Sgeo> Help SimpleIRC makes me tempted to use IORefs
10:38:41 <Sgeo> So that things that occur in one event handler can effect things in another
10:38:42 <Sgeo> :/
10:39:03 <Taneb> MVar?
10:39:08 <dmwit> Well, that's absurd. Clearly you should be using an Mvar.
10:39:10 <dmwit> dang, too slow
10:39:37 <Sgeo> My issue is with the fact that I'm even thinking of using mutability
10:39:45 <Sgeo> I seem to be stuck in a permanent mutability rut
10:40:20 <Sgeo> Actually, MVar might be better than IORef for this case, since I was thinking of using an IORef (Maybe String) anyway... actually, hmm
10:40:23 <mm_freak_> Sgeo: that's normal with callback-based frameworks
10:40:57 <mm_freak_> that's why i prefer SDL over GLUT
10:41:10 <Sgeo> mm_freak_, hmm, does Hackage have any non-callback-based IRC libraries?
10:41:22 <Sgeo> Although those would take me some time to learn
10:41:27 <Sgeo> I just want to write a simple bot, I think
10:41:28 <mm_freak_> not really
10:42:02 <Sgeo> So, I should NOT feel bad using mutability. Ok.
10:42:31 <kryft> Sgeo: Did you mean mutability rot?
10:43:22 <Sgeo> uh?
10:43:34 <Sgeo> mutability rut -> my mind keeps thinking in terms of mutability
10:43:35 <dmwit> It looks like you're trying to write a #haskell message!
10:43:38 <Sgeo> What does mutability rot mean?
10:43:38 <dmwit> Would you like help with that?
10:46:51 <geekosaur> it means someone's been playing crawl :p
10:49:20 <Taneb> Hmm
10:49:31 <Taneb> How hard would it be to write a not-callback-based IRC library in Haskell
10:49:46 <`nand`> mutability rot -> when your state starts decaying due to weird control flow caused by mutability
10:49:47 <Taneb> ...I think it would be useless
10:49:50 <typoclass> Sgeo: maybe try thinking of it this way? haskell lets you mutate things at defined points. in "f x = ...", the x may change from one call of f to the next. the x may not change otherwise
10:50:05 <typoclass> ... erm, i think i phrased that awkwardly :-/
10:50:19 <`nand`> when spaghetti goes bad, I guess
10:50:45 <jadatkins> good evening people
10:50:53 <jadatkins> or whatever, wherever you are
10:51:02 <Taneb> typoclass, "you may be given different x's, even you inside each incarnation of the function x will always be the same"
10:51:02 <Taneb> "This is sort of like mutability"
10:51:03 <typoclass> Taneb: like "x <- readIrcMessage ; case x of ..." ?
10:51:26 <typoclass> jadatkins: hello
10:51:50 <hpaste> aCube pasted “GHC panic ^^” at http://hpaste.org/83753
10:51:54 <Taneb> typoclass, I dunno, I haven't thought of it much
10:52:01 <jadatkins> is this the right place to ask for help with a particular package?
10:52:22 <Taneb> That depends on the package, most of the time, yes, the rest of the time we'll tell you where to ask
10:52:44 <jadatkins> i am trying to work out how to use Text.Parsec.Indent from the indents package
10:52:45 <otters> Is there any function in the time package to convert a NominalDiffTime to an Integer?
10:52:48 <typoclass> jadatkins: just try your question :-) worst thing that can happen is that you get no answers for one reason or another
10:53:18 <jadatkins> it may be some sort of successor to Text.ParserCombinators.Parsec.IndentParser
10:53:19 <typoclass> otters: iirc there's an instance that lets you do fromIntegral or some such?
10:53:30 <Taneb> jadatkins, yeah, apparently we're one of the nicest programming IRC channels out there
10:53:42 <otters> Well, it's a Num but not an Integral
10:53:49 <`nand`> Taneb: re: IRC library I guess maybe you could base something around T = IO (Message, T)
10:53:49 <jadatkins> does anybody know about parsing indent-style languages with Haskell?
10:53:50 <otters> :/
10:54:00 <`nand`> but then you'd ping timeout and stuff if the user doesn't request the next message in time
10:54:05 <supki> otters: fromIntegral . fromEnum ?
10:54:11 <`nand`> (unless you fork off a thread internally, I can see that working)
10:54:16 <otters> supki: ah, that's it
10:54:20 <otters> I totally forgot about fromEnum
10:54:22 <otters> thanks
10:54:47 <`nand`> Taneb: or perhaps more optimally, use one of the umpteen iteratee libraries out there to get a stream of messages
10:55:02 <Saizan> or a Chan?
10:55:14 <typoclass> otters: i assume the RealFrac NominalDiffTime instance will let you do "round" and such to get an Integral (i.e. Integer) http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Prelude.html#t%3ARealFrac
10:55:21 <`nand`> I've never looked into Chan. It's possible that would work well
10:55:34 <jadatkins> actually, you probably don't need to know much about parsing indent-style languages; knowing a lot about haskell would probably suffice
10:55:39 <Saizan> i guess you can get space leaks if they are not processed
10:55:50 <jadatkins> i will try to figure out how to phrase my question
10:56:00 <`nand`> Saizan: bounded sized chan or something?
10:56:05 <Saizan> jadatkins: yeah, specific questions work best
10:56:17 <`nand`> Saizan: well, at some point you're going to either have to process messages fast enough or drop them
10:56:21 <supki> otters: also since it's RealFrac there are truncate/round/...
10:56:29 <otters> oh yeah
10:56:48 <`nand`> the advantage of a callback would be forcing the user to process them
10:56:50 <Saizan> `nand`: yeah, a bounded variant might be best
10:57:21 <`nand`> I sort of want to write an IRC library based on ‘machines’ now
10:57:23 <`nand`> just because
10:57:56 <Saizan> tbf IRC is very much async, though i guess interaction with users is not
11:00:16 <Th0mas>  
11:00:16 <Th0mas>  
11:00:59 <Th0mas> Whoops excuse me if those empty messages came through, messing with my client
11:02:13 <byorgey> Th0mas: they did.  no worries =)
11:03:52 <otters> there doesn't seem to be any equivalent in the time package of old-time's CalendarTime
11:05:13 <typoclass> otters: there's Data.Time.Calendar http://hackage.haskell.org/packages/archive/time/1.4.0.1/doc/html/Data-Time-Calendar.html is that what you need?
11:05:14 <otters> oh, LocalTime sort of works, I guess
11:05:20 <otters> no it is not
11:05:20 <byorgey> otters: well, I think all the functionality is there but it's split up into multiple types across multiple packages.
11:05:27 <otters> LocalTime has hours/minutes which is what I need
11:05:56 <byorgey> otters: e.g. a UTCTime consists of a Day (which you can do calendar-y things with using Data.Time.Calendar) and also a DiffTime (which you can convert to hours/minutes/seconds etc.)
11:06:17 <otters> oh I see
11:07:05 <typoclass> otters: if you extract a lot of minutes and such, you may be interested in this package http://hackage.haskell.org/package/time-lens
11:07:42 <otters> well i think what I was trying to do in this module is have an IO action that runs from a certain start time for a certain number of minutes
11:09:02 <mcstar>  
11:09:08 <mcstar> thats a space ^
11:09:10 <typoclass> otters: you know about threadDelay, right?
11:09:19 <otters> yeah, that's what I'm using
11:09:25 <typoclass> mcstar: thanks for the information
11:09:27 <otters> working out the duration of the delay is the tricky part
11:09:37 <mcstar> hey, anytime :)
11:09:38 <otters> and I appear to have written this in a slightly brain-dead way the first time
11:09:43 <otters> I store the start time and the end time instead of the start time and the duration
11:09:45 <otters> how silly
11:11:19 <beaky> besides yesod, snap, happstack, pandoc, darcs, xmonad, nix, and ghc, what are some killer apps in Haskell?
11:11:39 <aristid> beaky: nix is not haskell.
11:11:45 <mcstar> beaky: your turing tape machines? XD
11:11:56 <beaky> haha
11:12:08 <elliott> nix is written in c++
11:12:37 <beaky> oh
11:13:07 <jadatkins> will some bot have a fit at me if i paste several messages at once?
11:13:20 <byorgey> jadatkins: no, but it's not polite
11:13:30 <beaky> nope, but best to paste multiple stuff in a site like http://hpaste.org
11:13:38 <jadatkins> it's not code, it's my messages
11:13:40 <byorgey> jadatkins: if you need to paste a multi-line example, use a paste site like hpaste.org, then share the link here
11:13:42 <beaky> ah
11:13:47 <k00mi> beaky: some parts of git annex IIRC
11:13:47 <jadatkins> it's what i want to say
11:13:57 <byorgey> jadatkins: oh, ok. that's fine then.
11:14:04 <covi> Yesod question: can I use selectList in a Handler RepHtml? I am getting type errors.
11:14:12 <sipa> beaky: hedgewars-server !
11:15:31 <aristid> beaky: nix is a functional, lazy language. but it's written in c++ (and some perl) :)
11:15:38 <beaky> oh
11:15:41 <aristid> (nix is also dynamically typed)
11:16:04 <aristid> still the bestest package manager, tho :)
11:16:06 <beaky> thought it was some purely-functional package manager and OS for linux or something :(
11:16:12 <beaky> ah
11:18:50 <mcstar> :t (~)
11:18:51 <lambdabot> parse error on input `)'
11:19:08 <mcstar> :k (~)
11:19:09 <lambdabot> AnyK -> AnyK -> Constraint
11:19:39 <mcstar> wth is this for?
11:19:50 <mcstar> "A data constructor used to box up all unlifted equalities"
11:19:59 <mcstar> is this only for type errors?
11:20:55 <typoclass> beaky: i heard the package manager is purely functional, but it has no direct connection to haskell
11:21:18 <elliott> mcstar: ~ is for equality constraints
11:21:38 <mcstar> so, it is used in normal code?
11:21:54 <elliott> sure
11:21:59 <elliott> e.g. in instance constraints
11:22:39 <latro`a> why would you need to say two type variables have the same value instead of just using the same symbol?
11:22:49 <mcstar> elliott: i think i saw ~ in type error messages, is it the same ~?
11:23:07 <elliott> yep
11:26:20 <hpaste> aCube revised “Anyone knows why this panics?”: “Does anyone have an idea why this makes GHC panic?” at http://hpaste.org/83755
11:26:22 <jadatkins> ok, here goes
11:26:30 <acowley> edwardk: You around?
11:26:31 <lambdabot> acowley: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:26:51 <jadatkins> Parsec is a parser combinator library, whatever that means. it comes with a load of modules. most of them export a bunch of useful parsers (e.g. newline from Text.Parsec.Char, which parses a new-line) or parser combinators (e.g. count n p from Text.Parsec.Combinator, which runs the parser p, n times)
11:26:51 <jadatkins> however, the module Text.Parsec.Token would like to export functions which are parametrized by the user with features of the language being parsed, so that, for example, the braces p function will run the parser p after parsing a '{' and before parsing a '}', ignoring things like comments, the syntax of which depends on your language
11:26:52 <jadatkins> the way that Text.Parsec.Token achieves this is that it exports a single function makeTokenParser, which you call, giving it the parameters of your specific language (like what a comment looks like) and it returns a record containing all of the functions in Text.Parsec.Token, adapted to your language as specified
11:26:52 <jadatkins> of course, in an indentation-style language, these would need to be adapted further (perhaps? here's where I'm not sure -- I'll explain in a moment) so I note that the (presumably obsolete) IndentParser package provides a module Text.ParserCombinators.Parsec.IndentParser.Token which looks to be a drop-in replacement for Text.Parsec.Token
11:26:52 <jadatkins> I should mention at some point that all the Parsec parsers are monadic functions, so they do magic things with state so that error messages can say at what line and column in the source file the error appeared
11:26:52 <jadatkins> for a couple of small reasons it appears to me that the indents package is more-or-less the current version of IntentParser, however it does not provide a module that looks like Text.ParserCombinators.Parsec.IndentParser.Token, it only provides Text.Parsec.Indent, so I am wondering how one goes about getting all the token parsers from Text.Parsec.Token (like reserved "something" which parses the reserved keyword
11:26:52 <jadatkins>  "something", or like braces which I mentioned earlier)
11:26:52 <jadatkins> it would appear to me that (the new) Text.Parsec.Indent works by some sort of monadic state magic to work out at what column bits of source code are, so that it doesn't need to modify the token parsers like whiteSpace from Text.Parsec.Token, which is probably why it doesn't provide a replacement module. but I am having a problem with types
11:26:53 <jadatkins> you see, without Text.Parsec.Indent, all my parsers are of type Parser Something (where Something is the return type) where Parser is a type alias defined in Text.Parsec.String as <code>type Parser = Parsec String ()</code>. but with Text.Parsec.Indent, instead of importing Text.Parsec.String, i use my own definition <code>type Parser a = IndentParser String () a</code> which makes all my parsers of type IndentParse
11:26:54 <jadatkins> r String () Something, where IndentParser is defined in Text.Parsec.Indent. but the token parsers that I'm getting from makeTokenParser in Text.Parsec.Token are of the wrong type
11:26:54 <jadatkins> if this isn't making much sense by now, it's because i'm a bit lost. the type issue is discussed a bit here: http://spin.atomicobject.com/2012/03/16/using-text-parsec-indent-to-parse-an-indentation-sensitive-language-with-haskells-parsec-library/
11:27:00 <pharaun> 0_o
11:27:03 <mcstar> ok, hpaste next time
11:27:04 <jadatkins> sorry about that
11:27:06 <jadatkins> ok
11:27:07 <pharaun> jadatkins: hpaste
11:27:21 <acowley> Yikes, I've been away from here for too long
11:27:46 <hpaste> aCube revised “The error message”: “The error message” at http://hpaste.org/83757
11:28:34 <hpaste> jadatkins pasted “parsing indent-style languages with Parsec question” at http://hpaste.org/83759
11:29:40 <hpaste> aCube annotated “Anyone knows why this panics?” with “With -dcore-lint” at http://hpaste.org/83755#a83760
11:32:49 <hpaste> jadatkins revised “parsing indent-style languages with Parsec question”: “parsing indent-style languages with Parsec question” at http://hpaste.org/83759
11:32:53 <aCube> Should I post this in #ghc too?
11:33:09 <mcstar> it says report it as a bug, so sure
11:33:11 <acowley> aCube: You should post it in #haskell-lens if you haven't already
11:34:20 <danharaj> edwardk: How do you deal with the fact that (.) doesn't like higher rank types?
11:35:36 <b_jonas> with explicit type annotations?
11:35:41 <jadatkins> i did say it wasn't code
11:35:52 <danharaj> b_jonas: that is not dealing :P
11:36:06 <c_wraith> b_jonas: adding explicit type annotations doesn't help unless you have the ImpredicativeTypes extension on
11:36:21 <b_jonas> really?
11:36:38 <danharaj> c_wraith: I am skeptical.
11:36:55 <c_wraith> Without that extension, you can't give (.) an impredicative type
11:37:05 <c_wraith> No matter how much you annotate it.
11:37:14 <danharaj> c_wraith: you don't have to give it an impredicative type.
11:37:58 <danharaj> c_wraith: I think b_jonas was suggesting a local type annotation that instantiates it to the right type, not giving (.) a type that works once and for all.
11:38:40 <c_wraith> but GHC still needs to be able to unify the type you annotate on it with the type it was declared as having
11:38:40 <dmwit> aCube: possibly http://hackage.haskell.org/trac/ghc/ticket/7729 ?
11:38:58 <danharaj> c_wraith: good point.
11:39:00 <typoclass> jadatkins: just tangentially, monads aren't really very magical. you can think of it as "there's a few extra arguments passed from function to function", e.g. line number and so on
11:39:33 <dmwit> aCube: (just searched for cgLookupPanic on the GHC trac)
11:39:43 <dmj> :t (***)
11:39:45 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
11:43:31 <Ralith> lennart_: you around?
11:43:38 <Sgeo> o....k.....
11:43:55 <Sgeo> Getting a topic on request seems to be processed differently from getting a topic because the topic changed
11:44:02 <jadatkins> what is the difference between 'Edit' and 'Annotate' on hpaste?
11:44:03 <c_wraith> danharaj: anyway, I'm not certain this is what the library actually does, but the common way to work around things like this is to hide the forall behind a newtype
11:44:41 <Ralith> jadatkins: I speculate that 'edit' just starts an annotation with the original content.
11:44:59 <jadatkins> 'Annotate' seems to do that too
11:45:08 <Ralith> huh.
11:45:10 <jadatkins> wait, what? what is an annotation?
11:46:01 <jadatkins> oh, i see
11:47:35 <typoclass> jadatkins: not sure, never noticed it :-/ i use "annotate" to put another paste below someone's paste. there will also be a "diff" link to color the lines that were changed between the two pastes
11:48:10 <jadatkins> is there a way of marking up a link in hpaste?
11:48:12 <hpaste> jadatkins annotated “parsing indent-style languages with Parsec question” with “some links” at http://hpaste.org/83759#a83763
11:48:42 <lennart_> Ralith: yeah, whats the matter?
11:48:46 <hpaste> jadatkins revised “parsing indent-style languages with Parsec question”: “question about parsing indent-style languages with Parsec” at http://hpaste.org/83759
11:48:58 <Ralith> lennart_: are you Lennart Augustsson?
11:49:17 <lennart_> Ralith: negative
11:49:20 <Ralith> dammit.
11:49:22 <Ralith> nevermind then
11:49:42 <jadatkins> typoclass: should i post on stackexchange?
11:52:15 <typoclass> jadatkins: that could be a good idea, since the question seems a bit long and intricate for irc :-) provide links to the 2 or 3 relevant haddock pages. try to give it a title that hits the nail on the head ("how do i combine parsec's TokenParser and indents's IndentParserT" or whatever)
11:52:21 <skp> hi
11:52:30 <skp> I have a problem with overlapping instances I don’t get
11:52:33 <dmwit> Ralith: /whois could have told you that much
11:52:39 <dmwit> lennart_: Nevertheless, I think you're pretty swell.
11:52:55 <Ralith> dmwit: not with much confidence :p
11:53:18 * Ralith is sure lennart_ is swell, but he probably doesn't have the authority to hand over maintainership of llvm-base.
11:53:35 <mcstar> +1 if you /whois'd lennart_
11:53:46 * typoclass authoritatively hands over cat pictures
11:54:46 * dmwit pictures Ralith sneaking up behind Lennart and demanding "Hand it over, or lambdas will roll!"
11:54:58 <Ralith> ^^
11:55:16 <dmwit> "I mean, uh, oh, sorry, wrong guy."
11:55:56 <jadatkins> the trouble is that if i could hit the nail on the head i could probably figure out the answer
11:56:00 <skp> https://github.com/skypers/ark-gl/blob/unstable/Graphics/Rendering/Ark/GL/Shader/Attribute.hs#L31, line 31, the glID is a class method of GLObject. ShaderProgram is a simple instance of GLObject, and the ShaderStage too (through both the GHC extensions FlexibleInstances and UndecidableInstances). ShaderProgram is not an instance of ShaderStage. The glID call on sp (so glID :: ShaderProgram -> GLuint) causes GHC to fail to match the instance’s impl
11:56:47 <jadatkins> typoclass: also i wondered if i should attempt to contact the package author
11:56:53 <Sgeo> Are there any good IRC libraries for any language?
11:57:26 <typoclass> jadatkins: i think stackoverflow is a good place to ask. another choice is the haskell-cafe mailing list
11:58:05 <jadatkins> really? you think there are enough people using these packages?
11:58:21 <dmwit> skp: 100% not an expert, but the terms sound a bit off, somehow. If ShaderStage is an instance of GLObject, it must be a type, so "ShaderProgram is not an instance of ShaderStage" doesn't make sense.
11:58:31 <Ralith> Sgeo: I wrote a decent one for common lisp a while ago.
11:58:44 <jadatkins> i mean, sure there are lots of people using Parsec, but there may not be very many using Text.Parsec.Indent http://hackage.haskell.org/package/indents-0.3.3
11:58:58 <typoclass> jadatkins: yeah, parsec and parsec-like packages are pretty common. and haskell-cafe is everyone talking about everything
11:59:16 <Ralith> Speaking of LLVM, is anyone around here interested in a ST-based LLVM binding? Looking for a code review.
11:59:25 <typoclass> jadatkins: i think the worst that can happen is that you get no replies
11:59:51 <dmwit> skp: It would help a lot if you could make a minimal example that didn't compile that we could try out on our own machines. Bonus points if the minimal example doesn't force us to install Haskell bindings to OpenGL.
12:00:34 <jadatkins> typoclass: ok, thanks
12:00:55 <jadatkins> which should i try first?
12:01:04 <typoclass> jadatkins: stackoverflow, if you ask me
12:01:11 <jadatkins> k
12:01:44 <jadatkins> aha, exciting! i've never posted a stackoverflow question before
12:02:33 <mcstar> why is => not parseable?
12:03:01 <Taneb> mcstar, because it's restricted syntax?
12:03:08 <mcstar> i mean, => in the type level would not be ambiguous with an ifix operator (=>)
12:03:29 <mcstar> i dont see why
12:03:34 <otters> has anybody had this problem in GHC 7.6? https://gist.github.com/otters/5125534
12:03:38 <mcstar> for example, -> works in all cases
12:03:47 <otters> I think it's being caused by threadDelay maxBound
12:04:29 <typoclass> otters: urgh. how strange. what about threadDelay (maxBound - 10) ?
12:04:55 <dmwit> ?hackage unbounded-delays
12:04:55 <lambdabot> http://hackage.haskell.org/package/unbounded-delays
12:04:57 <typoclass> > let (->) = 42 in 1 -- mcstar, this doesn't seem to work ...?
12:04:59 <lambdabot>   <hint>:1:6: parse error on input `->'
12:05:15 <dmwit> ...though that package probably also calls threadDelay maxBound
12:05:48 <otters> lol, it odes
12:05:49 <otters> does
12:05:54 <otters>  I copied my definition of delay from that package
12:06:10 <otters> same problem with maxBound - 10
12:06:13 <mcstar> typoclass: i just meant, it doesnt introduce an ambiguity, that it has several meanings, like in the typelevel, or in lambda syntax
12:06:25 <mcstar> i wonder why then the => operator is not allowed
12:07:05 * dmwit tries threadDelay maxBound in ghci
12:07:11 <augur> ski: syn
12:07:14 <dmwit> otters: How long do I have to wait to see that problem come up?
12:07:21 <dmwit> It doesn't immediately happen here.
12:07:42 <otters> dmwit: It happens immediately here
12:07:55 <typoclass> otters: does your threadDelay work with any value? also, does it work in a compiled program instead of ghci?
12:08:05 <dmwit> To be clear: it happens immediately if you just open up ghci, import Control.Concurrent, and threadDelay maxBound?
12:08:10 <dmwit> Or are you doing something more exciting?
12:08:11 <otters> dmwit: right
12:08:11 <edwardk> aCube: i get    Occurs check: cannot construct the infinite type: a3 = [(a3, a2)]
12:08:20 <otters> I'm on OSX Lion and GHC 7.6.2
12:08:22 <edwardk> aCube: so you just got a really ugly type error ;)
12:08:32 <dmwit> Oh, well, I'm on Linux and GHC 7.6.1.
12:08:51 <typoclass> mcstar: right ... i guess it could technically be allowed, but maybe they didn't want it to keep things clear for the human reader
12:09:09 <otters> https://gist.github.com/otters/38682b7ac1937cdecf7a
12:09:31 <dmwit> otters: pretty cool
12:09:44 <dmwit> otters: Maybe time to write a bug report (or search for one).
12:09:52 <otters> I did search for one
12:09:54 <otters> one sec
12:09:56 <aCube> http://hpaste.org/83755
12:10:00 <aCube> :O
12:10:03 <aCube>  http://hackage.haskell.org/trac/ghc/ticket/7729
12:10:05 <aCube> that one
12:10:20 <otters> http://hackage.haskell.org/trac/ghc/ticket/5544
12:10:36 <otters> can't reproduce with 7.4 or HEAD
12:10:44 <otters> "The fix will be in 7.6.2"
12:10:53 * typoclass . o O ( tangentially, i think the most correctestest way would be to put a delay function in the time-units package, so that you can do "delay (30 :: Hour)" )
12:10:57 <otters> no it won't
12:11:13 <otters> maybe I should try GHC 32-bit
12:11:51 <aristid> typoclass: would that be 30 calendar hours, or time hours?
12:12:16 <dmwit> 30 dog hours
12:13:37 * typoclass whacks aristid with a couple of leap seconds, the french 10-day weeks, and other ridiculous party tricks
12:14:25 <NemesisD> is it considered a bad idea/underhanded to put language extensions in the cabal file? i am going to use NoImplicitPrelude throughout my project
12:14:33 <aristid> typoclass: time is complicated, and we can only do so much to make it even more complicated.
12:14:39 <aristid> NemesisD: it makes invoking ghci harder.
12:14:48 <NemesisD> good point
12:15:42 <typoclass> aristid: i wish we could finally all agree on the discordian calendar
12:18:19 <typoclass> otters: i wonder if that's definitely fixed now. it's a bit confusing, apparently there's at least 3 trac tickets involved
12:18:45 <otters> heh
12:18:55 <otters> well I just installed this GHC like three days ago
12:19:53 <typoclass> otters: you should put a comment on trac reporting that it doesn't work for you. (there's a guest account, if you don't have one)
12:20:30 <aCube> Is GHC HEAD actually usable with hackage?
12:20:42 <otters> oh okay
12:21:22 <otters> what's the guest account?
12:21:55 <typoclass> otters: http://hackage.haskell.org/trac/ghc/ it's guest/guest
12:22:52 <otters> I'll try HEAD first
12:23:04 <otters> err, where's the repo
12:24:27 <otters> oh
12:28:39 <tac> Is Text.JSON the "standard" json parsing library in Haskell?
12:28:53 <Taneb> No
12:28:54 <tac> I'm having a noodle of a time trying to use it... it seems... kinda shitty
12:28:55 <Taneb> Data.Aeson
12:29:07 <Taneb> @hackage aeson
12:29:07 <lambdabot> http://hackage.haskell.org/package/aeson
12:29:14 <tac> ty ty Taneb
12:32:59 <supki> @hackage aeson-lens -- also this
12:32:59 <lambdabot> http://hackage.haskell.org/package/aeson-lens -- also this
12:35:21 <jadatkins> bleh http://stackoverflow.com/questions/15315624/how-to-create-indentation-aware-token-parsers-in-haskell-when-using-text-parsec
12:35:57 <Taneb> jadatkins, that... is one loquacious question
12:38:18 <Taneb> supki, that package feels a bit... ugh
12:39:03 <elliott> aeson-lens violates laws iirc
12:39:08 <edwardk> yes
12:39:23 <edwardk> there is github.com/lens/aeson-traversal  but its not bundled on hackage yet
12:41:30 <Taneb> For a start, asText should be :: Prism' Value Text
12:41:48 <edwardk> statusfailed++ # aeson-traversal
12:42:07 <supki> asText is older than prisms iirc
12:42:28 <edwardk> it may be older, but its still wrong ;)
12:42:42 <edwardk> actually projections were around back then
12:42:45 <edwardk> just not as nice to use
12:42:55 <Taneb> In fact, all those Maybes in Lens types are a bad sign
12:43:02 <supki> yeah
12:43:23 <supki> it's still pretty convenient though :[
12:44:24 <Taneb> I think in an ideal world there should be two lensy things mentioning "Maybe" at most
12:45:19 <Taneb> However, that's a very bold statement that could very easily be wrong
12:47:44 <skp> 20:59 < dmwit> skp: It would help a lot if you could make a minimal example that didn't compile that we could try out on our own machines. Bonus points if the minimal example doesn't force us to install Haskell bindings to OpenGL.
12:48:02 <skp> you can try the github link I gave you, but you’ll have to install the bindings tho
12:48:26 <skp> also you said «If ShaderStage is an instance of GLObject, it must be a type»
12:48:34 <skp> it’s actually defined that way :
12:48:49 <skp> instance (ShaderStage g) => GLObject g where
12:51:03 <skp> maybe it’s not the correct way to do
12:51:21 <skp> dmwit: maybe you know a better way to do what I wanna do
12:52:21 <dmwit> That's not a definition of ShaderStage.
12:52:31 <dmwit> Also, that doesn't say that ShaderStage is an instance of GLObject.
12:52:38 <dmwit> It says all instances of ShaderStage are also instances of GLObject.
12:52:44 <bytbox> is it just me, or is Codec.Archive.Zip horrifically slow?
12:54:09 <dmwit> Still no idea what the actual problem is, though. =)
12:54:13 <skp> dmwit: yes, and it’s what I want
12:54:15 <dmwit> Could you paste the error message somewhere?
12:54:45 <skp> I want to be able to « auto implement » each instances of ShaderStage (VertexShaderStage for instance) for the GLObject instance
12:54:50 <skp> yup
12:55:23 <skp> dmwit: https://gist.github.com/skypers/2e7f82e4e48ac48d3f44
12:56:15 <alien__> When I use getChar (from System.IO), how can I tell the difference between the different F keys. F1, F2, etc... They all appear to produce '\ESC'
12:56:23 <skp> I don’t understand why the ShaderStage instances would be a correct match here
12:56:39 <geekosaur> alien__, they produce multiple characters in a terminal
12:57:00 <dmwit> alien__: Might be time to step up to a real library like ncurses or similar.
12:57:18 <Clint> or vty
12:57:36 <typoclass> alien__: they produce \ESC followed by some other characters. i guess it'll be simpler if you use a library like vty for that
12:57:46 <alien__> Alright. Thanks for the sugestions. Ill look into the different libraries. Thanks
12:57:48 <geekosaur> if I press control-V F1 I get \ESCOP
12:57:50 <dmwit> skp: Ah, that's easy to explain. Instance resolution ignores contexts when choosing an instance.
12:57:59 <dmwit> skp: (Then checks after the fact whether the context can be satisfied.)
12:58:25 <dmwit> skp: So the "instance ShaderStage s => GLObject s" instance matches *all* types.
12:59:27 <skp> ah
12:59:39 <skp> so it tries to match the ShaderProgram
12:59:49 <skp> and find an overlap
12:59:54 <skp> finds*
13:00:07 <skp> huh
13:00:08 <skp> well no
13:00:11 <skp> I don’t get it
13:00:14 <skp> 21:58 < dmwit> skp: So the "instance ShaderStage s => GLObject s" instance matches *all* types.
13:00:17 <skp> all types?
13:00:24 <dmwit> Well, to be precise, it tries to match s, which succeeds, and it tries to match ShaderProgram, which succeeds, and *this* is when it finds an overlap.
13:00:27 <dmwit> Yes, all types.
13:00:33 <skp> not only all types which are instances of ShaderStage?
13:00:37 <dmwit> correct
13:00:58 <aristid> skp: constraints are checked after instance resolution
13:01:05 <skp> ah!
13:01:09 <skp> so the s
13:01:14 <skp> is forall
13:01:17 <skp> I see
13:01:22 <skp> that’s pretty odd
13:01:39 <dmwit> It's for efficiency: it means instance resolution never needs to backtrack.
13:01:52 <skp> yeah
13:01:57 <aristid> i think it also might have benefits for type inference, but i'm not sure
13:01:58 <skp> so am I screwed?
13:02:23 <skp> I don’t want to write all instances of GLObject for each type of ShaderStage
13:02:25 <skp> it’s boring
13:02:35 <dmwit> Well, you can delete the instance for ShaderProgram, or you can turn on IncoherentInstances, or you can use a newtype wrapper for the ShaderStage s => GLObject s instance.
13:02:35 <hpaste> mcstar pasted “truthtable” at http://hpaste.org/83767
13:02:37 <skp> the instances are *exactly* the same
13:02:58 <Saizan> above all it's for consistency
13:02:58 <skp> I can’t delete the ShaderProgram instance
13:03:03 <skp> the wrapper?
13:03:07 <dmwit> skp: There's one more suggestion which is quite good, and you'll probably like.
13:03:08 <skp> what do you mean?
13:03:10 <dmwit> One moment while I type.
13:03:16 <skp> I’m all ear
13:03:19 <mcstar> `nand`: now i understand why you said it was complicated, indeed it was
13:04:12 <mcstar> edwardk: you can look at the paste too (the problem you too helped with)
13:04:13 <dmwit> Suppose you have class GLObject s where glId :: s -> Int (say). You can define glIdDefault :: ShaderStage s => s -> Int and then for all your ShaderStages write instance GLObject Foo where glId = glIdDefault
13:04:17 <dmwit> saves some typing.
13:04:21 <`nand`> mcstar: tt p = [False, True] >>= liftA2 map (:) (tt . p) -- :)
13:04:33 <`nand`> that one generalizes better to larger input sets as well
13:04:45 <mcstar> well, ill save that line
13:05:00 <edwardk> mcstar: so now lets improve your type inference
13:05:07 <mcstar> o.O
13:05:08 <edwardk> instance Predicate t => Predicate (Bool -> t) where
13:05:12 <mcstar> i didnt know i had one
13:05:17 <skp> I see
13:05:22 <edwardk> that can become instance (s ~ Bool, Predicate t) => Predicate (s -> t) where
13:05:29 <edwardk> with a TypeFamilies Constraint.
13:05:31 <skp> so I’ll still have to write explicit instances
13:05:39 <edwardk> that way if you don't use that argument, it'll still infer correctly
13:05:39 <`nand`> then you shouldn't need UndecidableInstances or FlexibleInstances
13:05:44 <`nand`> also, that Show instance is bad
13:05:52 <dmwit> skp: right, but trivial ones
13:06:05 <skp> yeah
13:06:09 <skp> maybe you’re right
13:06:12 <skp> I don’t know
13:06:28 <`nand`> you should probably just drop the Show instance entirely and use a different name for display . tt
13:06:29 <skp> GLObject has some other methods
13:06:43 <skp> I still can repeat the same trick you mentionned
13:06:45 <skp> dunno
13:07:03 <mcstar> `nand`: yes, but this is handy, also, why is wrong?
13:07:13 <`nand`> because it collides with half the world
13:07:16 <mcstar> edwardk: i am making notes of that
13:07:37 <`nand`> it's now impossible for me to write a show instance /of any type/ without colliding with your predicates
13:07:59 <mcstar> thats bad
13:08:08 <`nand`> at the very least, give it a newtype wrapper
13:08:17 <mcstar> yes, i thought about that
13:08:31 <mcstar> can i still use Predicate ?
13:08:36 <mcstar> for the type name
13:08:49 <`nand`> no, that identifier is already taken for the class name
13:08:55 <dmwit> skp: As for the newtype wrapper suggestion, that looks like newtype UserShaderStageInstance s = USSI s; instance ShaderStage s => GLObject (UseShaderStageInstance s)
13:09:01 <mcstar> i wasnt sure if they were to collide
13:09:39 <dmwit> skp: You can also write instance ShaderStage s => ShaderStage (UseShaderStageInstance s), so this can be less painful than it might at first glance appear.
13:09:43 <mcstar> `nand`: i used undecidableinstances for Show
13:10:51 <tac> My applicative-fu is so weak :(
13:11:44 <tac> If I have "a -> Parser b" and a vector (from Data.Vector) of "Vector a", can I make a Parser (Vector b)?
13:12:18 <tac> (pigworker would be ashamed of me)
13:12:43 <mcstar> thanks all for the educational experience
13:12:46 <mcstar> bb
13:12:59 <Taneb> tac, try using Data.Traversable.traverse
13:13:04 <`nand`> tac: if your Parser is Applicative and your Vector is Traversable
13:13:29 <joshcheek> Is there a library that will provide a list of the currently running processes as data structures? (only needs to work in nix)
13:13:37 <tac> ty guys
13:14:15 <dmwit> ?quote ksf energy
13:14:15 <lambdabot> ksf says: duh, we can't run out of energy, as there's a fixed amount of it.
13:14:33 <typoclass> joshcheek: i guess on linux, you can always list the contents of /proc
13:14:39 <dmwit> joshcheek: If anything has it, I'd guess it would be shelly.
13:15:36 <typoclass> joshcheek: if it needs to run on unix-not-only-linux, i think the traditional advice is "run a ps process and parse the output" :-/
13:15:59 <joshcheek> typoclass: ouch! (I'm on osx)
13:27:11 <Taslem> I'm trying to use the SDL package and running into difficulties with it.
13:27:54 <Taslem> Namely, I don't see any way to access the pixels of surfaces in it. Anyone have experience with it?
13:46:24 <tac> erk... how do you actually RUN an Aeson parser?
13:46:31 <tac> Does it require Attosec?
13:47:33 <Taneb> Or you can use fromJSON
13:48:06 <c_wraith> tac: if you're using one of the Parser values, you need Attoparsec, yes.
13:48:25 <c_wraith> tac: but there's also decode
13:48:45 <c_wraith> tac: the parsers are really only useful if you want to embed them into a larger attoparsec construct
13:49:14 <tac> @hoogle decode
13:49:15 <lambdabot> Prelude decodeFloat :: RealFloat a => a -> (Integer, Int)
13:49:15 <lambdabot> Data.Text.Encoding decodeASCII :: ByteString -> Text
13:49:15 <lambdabot> Data.Text.Lazy.Encoding decodeASCII :: ByteString -> Text
13:49:25 <c_wraith> Data.Aeson.decode
13:49:35 <tac> Trying to navigate Haddocks is sooo frustrating :(
13:49:38 <c_wraith> decode :: FromJSON a => ByteString -> Maybe a
13:49:53 * geekosaur likes to let hayoo do it for him
13:50:13 <c_wraith> in the case of aeson, it's worth not ignoring the contents
13:50:29 <c_wraith> there's a link in the contents section labeled "Decoding to a Haskell value"
13:50:46 <c_wraith> also, don't ignore the examples included
13:50:53 <tac> gaaaaaah. I've been working with old docs this whole time
13:51:01 <tac> Why doesn't Hackage fix it's damn SEO information???
13:52:02 <crl> @src Cont
13:52:03 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
13:53:49 * hackagebot wl-pprint-extras 3.4 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-3.4 (EdwardKmett)
13:53:51 * hackagebot wl-pprint-terminfo 3.6 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-3.6 (EdwardKmett)
13:55:55 <jadatkins> made my question a bit better now http://stackoverflow.com/questions/15315624/haskell-parsec-how-do-i-use-text-parsec-token-with-text-parsec-indent-from-the
13:57:45 <tac> erk... how do I turn a String into a Data.ByteString.Lazy.Internal.ByteString?
13:58:06 <tac> The Internal part is throwing me off
13:58:24 <supki> that's just lazy ByteString
13:58:30 <elliott> tac: turn howso?
13:58:32 <elliott> UTF-8?
13:59:01 <tac> So what I need is Data.ByteString.Lazy.Char8's pack method, right?
13:59:08 <elliott> depends... but not necessarily
13:59:17 <elliott> Strings are lists of characters; ByteStrings are lists of bytes
13:59:28 <elliott> you need to encode them somehow -- what data is in your String?
14:01:44 <tac> ah, my problem was something different
14:01:48 <tac> thank you guys
14:02:35 <tac> sweet
14:02:47 <tac> two hours later and I have a working JSON config parser
14:09:52 <lispy> tac: is it possible that you want Data.Text instead of ByteString?
14:09:59 <tac> very possible
14:10:20 <tac> I'm just not experienced with the different libraries for converting things between Text, String, and ByteStrings
14:10:35 <lispy> ByteString ~ [Word8] and Text ~ [Char]
14:10:39 <lispy> where ~ means, roughly
14:10:41 <c_wraith> Text is the main conversion library between those three types
14:10:46 <twomashi> Anyone, a function that takes [Maybe a] and takes while is not None?
14:10:49 <tac> In the code I write, I just use String everywhere, and cry whenever I have to use a library :)
14:10:54 <twomashi> hoogle didnt turn it up...
14:11:12 <Mathnerd314> lispy: well, ByteString == Vector Word8
14:11:26 <c_wraith> twomashi: I don't think there's a standard function for that.
14:11:35 <Mathnerd314> lispy: at least according to http://hackage.haskell.org/package/vector-bytestring
14:11:37 <lispy> tac: if you use strings overwhere turn on the overloaded stings extension (OverleadedStrings ?) :)
14:11:57 <mikeplus64> twomashi: takeWhile isJust?
14:12:07 <lispy> Mathnerd314: I was being intentionally imprecise. Vector would be a closer match for sure.
14:12:07 <mikeplus64> (isJust is from Data.Maybe)
14:12:17 <tac> lispy: heh, yeah
14:12:25 <twomashi> mikeplus64: that'll do it, thanks
14:12:48 <Mathnerd314> lispy: the problem is that [] is not precise, people often use it when they don't really want a linked list
14:13:11 <lispy> tac: basically it comes down to: Do you want to restrict to ASCII-by-default (ByteString without explicit utf8 encode/decode) or do you want to support unicode (Text) ?
14:13:28 <brooksbp> hello
14:13:35 <brooksbp> what is this operator? <<=
14:13:36 <tac> for my (current) needs, I can do just fine without unicode
14:13:39 <tac> in time, though, shrug
14:13:45 <brooksbp> I mean =<<
14:13:45 <lispy> ?hoogle (<<=)
14:13:45 <tac> It's just a toy project I've been working on
14:13:45 <lambdabot> No results found
14:13:50 <lispy> ?hoogle (=<<)
14:13:51 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
14:13:51 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
14:13:52 <`nand`> brooksbp: extend
14:13:52 <dmwit> ?src (=<<)
14:13:53 <lambdabot> f =<< x = x >>= f
14:13:56 <`nand`> oh
14:14:09 <`nand`> (<<=) is extend. not (=<<) :)
14:14:34 <lispy> tac: That's reasonable. In this case, supporting unicode is so easy that I find it's worth it to just do it from the start.
14:15:08 <lispy> (whether windows users will be in the right codepage is another story...)
14:15:19 <tac> well.... I do have to contend with the fact I'm using simpleirc
14:15:23 <tac> @where simpleirc
14:15:24 <lambdabot> I know nothing about simpleirc.
14:15:31 <brooksbp> Okay.  Hoping someone can explain how to put these two functions together:
14:15:33 <tac> And simpleirc is entirely a bytestring thing
14:16:38 <brooksbp> f :: a -> IO (Result (Response a)) ... and ... g :: Result (Response a) -> IO a   ... how do I g(f(arg)) ?
14:17:26 <`nand`> g <=< f -- but you should probably read up on monads and IO in haskell
14:18:01 <lispy> :t \arg -> do x <- f arg; g x
14:18:03 <lambdabot> (Monad m, Show t1, Show t, FromExpr (m b), FromExpr (m t1)) => t -> m b
14:18:13 <lispy> :t \arg -> do x' <- f arg; g x'
14:18:15 <lambdabot> (Monad m, Show t1, Show t, FromExpr (m b), FromExpr (m t1)) => t -> m b
14:18:16 <`nand`> http://www.haskell.org/haskellwiki/Introduction_to_IO
14:18:24 <lispy> why am I getting that FromExpr constraint?
14:18:35 <`nand`> :t f
14:18:37 <lambdabot> FromExpr a => a
14:18:38 <`nand`> :t g
14:18:39 <lambdabot> FromExpr a => a
14:18:41 <lispy> oh right :)
14:18:48 <lispy> :t \arg -> do x' <- ?f arg; ?g x'
14:18:49 <lambdabot> (?f::t1 -> m t, ?g::t -> m b, Monad m) => t1 -> m b
14:19:58 * ClaudiusMaximus using STM in anger for the first time - it's made my code much less of a headache
14:21:20 <`nand`> STM in anger?
14:21:52 <ClaudiusMaximus> "seriously"
14:21:53 <`nand`> frustrated by deadlocks?
14:22:10 <ClaudiusMaximus> frustrated by impossibly-awkward invariants
14:22:27 <tac> @src (>==>)
14:22:27 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
14:22:30 <tac> @src (>=>)
14:22:30 <lambdabot> Source not found. You type like i drive.
14:23:44 <ClaudiusMaximus> now the part that needs to do something when the "current best thing" changes, and the part that needs to do something when the "top 10 best things" changes, and the part that judges things, and the part that generates things, are all nicely separate
14:24:02 <dmwit> (f >=> g) x = f x >>= g
14:24:26 <dmwit> ClaudiusMaximus: Ain't STM magical?
14:24:40 <dmwit> Now just wait for your first livelock and you'll be back out of love with it in no time.
14:25:09 <`nand`> what's a livelock? all threads failed or something like that?
14:25:53 <ClaudiusMaximus> are livelocks common?  my use-case isn't particularly pathological, <10 threads..
14:26:38 <dmwit> `nand`: All threads constantly retrying.
14:26:42 <`nand`> “A real-world example of livelock occurs when two people meet in a narrow corridor, and each tries to be polite by moving aside to let the other pass, but they end up swaying from side to side without making any progress because they both repeatedly move the same way at the same time.” <- apparently, livelocks happen all the time to me
14:26:48 <`nand`> dmwit: yeah, that's what I meant
14:26:51 <dmwit> ClaudiusMaximus: They're not that common. But they crop up every once in a while.
14:27:44 <c_wraith> I don't think GHC's STM implementation can fully livelock. Something has to commit to make other transactions rollback.
14:27:59 * applicative_ , studying the fancy async library, seems to have  gotten himself banned from project gutenberg :(
14:28:05 <c_wraith> (it can make the scheduler fall over though, if new transactions are being added faster than transactions are successfully committing)
14:31:00 * applicative_ should have read what he cant now: You don't have permission to access /wiki/Gutenberg:Information_About_Robot_Access_to_our_Pages on this server.
14:31:41 <donri> applicative_: google cache?
14:31:59 <donri> just add cache: to the url if google is your search engine
14:32:06 <applicative_> ah yeah
14:32:14 <donri> or tor
14:32:20 <Ralith> Is there any way to get a CArray or similar from an Integer, corresponding to its base-2^n representation suitable for efficient import into libgmp?
14:33:48 <`nand`> you can get a [Bool] easily
14:33:51 <`nand`> maybe you can go from there
14:33:57 <`nand`> > 12345^..bits
14:34:00 <lambdabot>   [True,False,False,True,True,True,False,False,False,False,False,False,True,T...
14:34:02 <applicative_> curses, this also does half the work I was doing while hammering them with requests
14:34:34 <ClaudiusMaximus> i think i'll be ok for livelock, using TBQueue so the producer blocks if the output isn't being consumed fast enough.  next step for this project is switching from GLUT to GTK so i can add widgets to control the weights for the "bestness metric"
14:37:18 <otters> :t bits
14:37:19 <lambdabot> (Applicative f, Bits b, Indexable Int p) => p Bool (f Bool) -> b -> f b
14:38:07 <crl> @pl f x >>= g
14:38:07 <lambdabot> g =<< f x
14:38:17 <`nand`> bits :: Bits b => Traversal' b Bool
14:38:24 <crl> @pl (f >=> g) x
14:38:24 <lambdabot> (f >=> g) x
14:38:26 <donri> why doesn't lambdabot show the type from the type signature?
14:38:28 <dmwit> Ralith: Uh, isn't Integer already a libgmp int?
14:38:34 <donri> why does it expand type synonyms
14:38:59 <`nand`> dmwit: depends on the haskell implementation obviously :P
14:39:17 <Ralith> dmwit: yes; I'm working on a compiler for a language which does the same, and source code may contain Integer constants. The compiler parses those Integer constants into Integers, and I want to generate efficient code representing them.
14:39:31 <dmwit> ?src Integer
14:39:32 <lambdabot> data Integer = S# Int#
14:39:32 <lambdabot>              | J# Int# ByteArray#
14:39:33 <`nand`> but you're right, for GHC Integer you might as well just coerce it to a pointer or something (depending on its internal representation) and pass that to GMP directly
14:39:36 <geekosaur> crl, if you want @pl to do something you need to tell it which names are to be regarded as local by using them in lambdas
14:39:36 <dmwit> enjoy
14:39:43 <Ralith> `nand`: see above
14:40:10 <`nand`> ah
14:40:26 <`nand`> well, I don't know anything about libgmp or how GHC compiles constants for it
14:40:37 <Ralith> basically I want something I can compile into a constant array and feed to http://gmplib.org/manual/Integer-Import-and-Export.html
14:40:46 <crl> @pl (\x ->f x >=> g) x
14:40:46 <lambdabot> f x >=> g
14:40:48 <Ralith> `nand`: how GHC compiles constants isn't relevant...
14:40:52 <dakaktak> Where can I get full list of ghc-versions since begin of the world?
14:41:04 <geekosaur> you used x outside the scope, that's a different x
14:41:22 <dmwit> dakaktak: From the GHC website, if anywhere.
14:41:29 <Taneb> Trying to install GHC 7.6.2 because it's late and this is what I do when it is late
14:41:40 <lispy> dakaktak: http://www.haskell.org/ghc/download
14:41:42 <dmwit> http://www.haskell.org/ghc/download
14:41:44 <Taneb> checking for path to top of build tree... utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory
14:42:06 <`nand`> Ralith: am I misunderstanding? You're compiling some language which has native GMP integers and want to find an efficient way to include constants?
14:42:17 <dakaktak> Gracios
14:42:18 <`nand`> isn't that the same thing GHC is doing for Haskell programs and integer constants?
14:42:21 <lispy> Taneb: are you on redhat or fedora?
14:42:27 <Ralith> `nand`: sure, but only incidentally.
14:42:28 <Taneb> lispy, no
14:42:31 <Taneb> I'm on Ubuntu
14:42:40 <`nand`> yes, but you can look at how GHC does it for inspiration
14:42:44 <lispy> Taneb: apt-get install libgmp-dev or something like that
14:42:49 <Ralith> ah.
14:42:59 <Taneb> lispy, already have
14:43:04 <Taneb> I'm gonna try the 32 bit versions too
14:43:12 <lispy> Taneb: Then you may need to create a symlink
14:43:23 <Taneb> Aww no, I hate doing that
14:43:29 <Taneb> From where to where and how
14:43:33 <lispy> Taneb: ldd  utils/ghc-pwd/dist-install/build/tmp/ghc-pwd
14:43:50 <lispy> Taneb: that will print a line that says where it expects to find libgmp.so.3
14:44:00 <lispy> Taneb: then look in that directory to see what your libgmp is really called.
14:44:15 <Taneb> 	libgmp.so.3 => not found
14:44:17 <crl> @pl (\x ->f x >=> g x)
14:44:17 <lambdabot> liftM2 (>=>) f g
14:44:17 <dakaktak> libgmp3-dev maybe?
14:44:20 <chrisdone> #haskell nick cloud =) http://ircbrowse.net/nick-cloud
14:44:54 <lispy> Taneb: I have to run now, but you're pretty close to the solution.
14:44:59 <`nand`> lambdabot is the greatest spammer in #haskell
14:45:05 <crl> @pl (\x ->f x >=> g y)
14:45:06 <lambdabot> (>=> g y) . f
14:45:10 <typoclass> chrisdone: oh heh :-) that's cute
14:45:29 <TravisD> I'm shocked that I'm on that nick-cloud
14:45:34 <`nand`> but the colors are all wrong!
14:45:38 <chrisdone> i like that it's using svg so you can search on it =)
14:45:47 <tsinnema> haskell newbie here -- is there an explanation somewhere on what the various 'portability' entries mean on the docs on the various modules on hackage? like here for instance: http://hackage.haskell.org/packages/archive/categories/1.0.5/doc/html/Control-Category-Monoidal.html
14:45:52 <chrisdone> `nand`: you don't like your blue? ;)
14:46:04 <crl> geekosaur: was just trying if bot could deduce (f >=> g) x = f x >>= g
14:46:21 <`nand`> chrisdone: I haven't found myself yet; but I don't like the fact that all of the colors are not the nick colors I see for people in my IRC client :P
14:46:24 <geekosaur> doubtful, @pl is kinda stupid
14:46:41 <typoclass> `nand`: just use your browser's search function
14:46:44 * geekosaur had no idea he was that active in here
14:47:07 <dakaktak> chrisdone: could you do the same for #haskell-lens?
14:47:09 <`nand`> typoclass: it doesn't seem to highlight anything in the graph
14:47:44 <chrisdone> `nand`: on chrome you might have to hit ESC for the highlight to show
14:47:48 <`nand`> oh, it's different every time?
14:47:53 <`nand`> that's neat
14:47:57 <donri> it only works in webkit
14:48:02 <chrisdone> dakaktak: err yeah if there's logs in maybe clog format or something
14:48:04 <`nand`> donri: gecko here
14:48:08 <donri> same
14:49:00 <typoclass> tsinnema: hello. i think that largely refers to which ghc extensions you need to compile the module. if you're using ghc (as almost everyone does these days), you're fine, it's just a matter of which extensions need to be on. it would be more relevant if there were more haskell compilers seriously competing with ghc
14:49:24 <TravisD> chrisdone: How far back does it check for contribution?
14:49:38 <chrisdone> `nand`: yeah it uses this: http://d3js.org/
14:49:50 <chrisdone> TravisD: ah, i should add that to the description. by default it's the past 31 days
14:50:02 <typoclass> `nand`: works for me :-/ your color is kind of a brown and you're fairly big (that doesn't seem to change between reloads)
14:50:07 <chrisdone> TravisD: more general stats: http://localhost:10001/
14:50:09 <chrisdone> woops
14:50:11 <TravisD> hehe
14:50:13 <tsinnema> typoclass, thanks!
14:50:16 <chrisdone> TravisD: http://ircbrowse.net
14:50:21 <dmwit> typoclass: It's a joke, I think. The colors are different than in his IRC client.
14:50:22 <typoclass> tsinnema: you're welcome
14:50:58 <TravisD> chrisdone: Very cool. Thanks for sharing
14:51:08 <typoclass> dmwit: i meant on http://ircbrowse.net/nick-cloud ... the layout changes with reloads, but i don't think the colors and sizes do
14:51:25 <`nand`> dmwit: only half a joke. I've stared at my IRC client long enough for me to associate people just as strongly with their colors as with their names; seeing them in the wrong color is unnerving to say the least
14:51:46 <geekosaur> but if the colors are right for yours, they're probably wrong for mine...
14:51:57 <chrisdone> typoclass: yeah i'm not sure how the colours are calculated, i'd imagine (and would hope as it's nice) it's generated from a computed hash of the nick
14:52:15 <chrisdone> `nand`: what colour is my name?
14:52:26 <typoclass> chrisdone: light green!
14:52:35 <`nand`> it doesn't have to be this way! we need a core JavaScript API to determine the user's IRC coloring function
14:52:39 <`nand`> chrisdone: no, no, dark blue!
14:52:48 <geekosaur> dark green :p
14:52:51 <`nand`> shachaf and edwardk are examples of light green people
14:52:53 <chrisdone> nice neutral colours
14:53:16 <chrisdone> `nand`: yeah there should be an RFC for calculating nick colours =p
14:53:22 <typoclass> `nand`: they both have nearly the same color, yes, but that color is a very bright blue-gray
14:54:09 <dmwit> irssi doesn't even use a hash.
14:54:13 <dmwit> It just stores some state.
14:54:20 <dmwit> When you restart irssi, people's colors change...
14:54:22 <dmwit> =(
14:54:24 <chrisdone> generated from an initial randomness?
14:54:27 <chrisdone> ah, that's lame
14:54:28 <Taslem> Hi. How do I access the pixel data in the SDL library?
14:54:28 <`nand`> that's not good :(
14:54:30 <typoclass> dmwit: that's terrible
14:54:51 <`nand`> weechat is quite smart about the thing, it recognizes and strips stuff like status suffixes or fallback nicks
14:55:16 <niteria> irssi has colored nicks?
14:55:20 <chrisdone> this is also pretty cool: http://bl.ocks.org/MoritzStefaner/1377729 -- i'm thinking of generating a graph of who speaks to who with the edges thicker depending on how often they interact and render it with that lib
14:55:51 <`nand`> chrisdone: do it
14:55:56 <`nand`> chrisdone: what data are you basing this on?
14:56:08 <chrisdone> there was some perl script that did it ages ago but i can't remember the name
14:56:31 <chrisdone> `nand`: the logs from tunes.org (about 12 years), imported into postgresql
14:56:44 <niteria> chrisdone: any plans for real time updates?
14:57:02 <chrisdone> niteria: was thinking about it, i could put a bot in here to do it
14:57:31 <ab9rf> irc has colors?
14:57:34 <`nand`> chrisdone: ah, nice
14:58:04 <`nand`> the tunes site updates in realtime, mind
14:58:07 <`nand`> more or less
14:58:26 <`nand`> but I don't know how much they'd like you spam refreshing their logs
14:58:27 <chrisdone> it does but i can't really poll it in real time without probably annoying them
14:58:35 <dmwit> ab9rf: Well, yes, though they're mostly unused. What we've been talking about has all been client-side stuff.
14:58:51 <niteria> I think it would make more sense if last page was default
14:59:09 <niteria> colors
14:59:11 <`nand`> which nick in here collects data for that site anyway?
14:59:12 <dmwit> niteria: I think I installed something.
14:59:19 <chrisdone> clog
14:59:26 <ab9rf> dmwit: ah, because my client only shows color when someone actually talks to me
14:59:27 <`nand`> ah
14:59:27 <dmwit> But I don't remember what or how, so good luck with that.
14:59:34 <ab9rf> dmwit: people don't get random colors or anything like that
14:59:37 <chrisdone> here's where it first joined =) http://ircbrowse.net/browse/freenode/haskell?id=1&timestamp=1008538891#t1008538891
14:59:42 <dmwit> ab9rf: You're missing out. =)
15:00:10 <ab9rf> dmwit: it's been like that for me since 1991, and it's worked out fine so far :)
15:00:35 <chrisdone> erc doesn't show colours either. i had them on xchat and it was indeed pretty funny how your mind associates the colours
15:00:42 <`nand`> dmwit: are colors actually part of any IRC RFC (or extension), or did that just arise as an ad-hoc client thing with everybody else following suit?
15:01:01 <chrisdone> sometimes i would rotate the colours to make people appear 'fresh' to me =)\
15:01:04 <ab9rf> i'm kinda pleased to have been able to keep my freenode account alive for 12 years now
15:01:11 <`nand`> chrisdone: I have the entire messages colored as well, not just the nicks. It significantly enhances readability, especially when following conversations
15:01:41 <chrisdone> `nand`: that's mental. all my messages are a deep blue? i are teh ocean smooth and lucious
15:01:55 <`nand`> chrisdone: technically, that one was light pink
15:01:58 * dmwit shrugs at `nand`
15:02:09 <ab9rf> i actually find that inadvertent cross-conversation pollination enhances value
15:02:15 <chrisdone> `nand`: so how are the messages coloured?
15:02:49 <`nand`> chrisdone: an example: http://sadpanda.us/images/1457990-0NRDQQX.png
15:03:22 <chrisdone> woah. have you got eye problems?
15:03:30 <donri> you call that readable? :D
15:03:43 <`nand`> I don't know why people keep asking me that when I paste a screenshot :(
15:04:07 <dakaktak> `nand`: could I have that hpaste css?
15:04:10 <ab9rf> now i gotta look
15:04:19 <dakaktak> donri: readable indeed
15:04:25 <typoclass> i think it could work if you dial the monitor's brightness to minimum
15:04:38 <`nand`> typoclass: my monitor's brightness is at the minimum setting, incidentally
15:04:42 <ab9rf> herp
15:04:43 <`nand`> it also has a very, very low contrast
15:04:49 <donri> pastel colors on dark background with a spindly font
15:05:07 <chrisdone> `nand`: i imagine that's why people ask. because it's all dark and low contrast. that's like the accessibility mode on windows
15:05:10 <ab9rf> the technicolor vomit makes my eyes hurt
15:05:31 <typoclass> `nand`: right. i guess then it can work
15:05:47 <supki> `nand`: I second css request
15:05:48 <`nand`> donri: sounds crazy but the longer I've been staring at terminus the ‘fuller’ my mind sees it. I remember back when I used proportional fonts people were linking me screenshots of aliased monospace fonts and I couldn't read a thing
15:05:52 <ab9rf> especially when incompatible colors are used proximate to one another
15:06:14 <dmwit> I like dark with low contrast!
15:06:16 <dmwit> You guys all suck.
15:06:22 <chrisdone> zenburn 4 lye
15:06:27 <`nand`> dakaktak/supki: I'm not sure what you're asking for. I don't use any special css for hpaste or anything
15:06:40 <twomashi> I have an infinite list [m (Maybe a)], I need to take until m (None) is encountered… but MapM hangs because m isnt lazy… anyone?
15:07:01 <dmwit> twomashi: explicit recursion time?
15:07:05 <`nand`> oh right, this is a channel about haskell
15:07:08 <dmwit> Unless monad-loops has something.
15:07:10 <dmwit> ?hackage monad-loops
15:07:11 <lambdabot> http://hackage.haskell.org/package/monad-loops
15:07:18 <chrisdone> yeah i thought of whileM
15:07:25 <twomashi> dmwit: mdo?
15:07:27 * niteria has colors now! yay
15:07:32 <supki> `nand`: uhm, I'm asking for a /thing/ that makes hpaste render in such a nice way
15:07:34 <chrisdone> :t whileM -- is it in lbot?
15:07:35 <lambdabot> Not in scope: `whileM'
15:07:37 <dakaktak> `nand`: how can I make my pentadactyl show hpaste like that?
15:07:37 <twomashi> well, would need some sort of recursive do no?
15:07:43 <dmwit> twomashi: No, I don't think you need recursive do.
15:07:44 * chrisdone psch's
15:07:51 <dmwit> twomashi: Unless I very misunderstood your request.
15:07:59 <donri> `nand`: i do use a monospace font for irc because most channels i'm in is about programming
15:08:00 <twomashi> dmwit: I need to get m [a] out.
15:08:11 * dmwit nods agreeably at twomashi
15:08:13 <ab9rf> donri: i can't imagine using irc with anything other than monospace
15:08:23 <twomashi> [m (Maybe a)] -> m [a]
15:08:26 <dmwit> You don't need recursive do for plain old recursion.
15:08:27 <chrisdone> the monad itself isn't strict, i think the problem is that mapM is strict
15:08:31 <`nand`> supki: the only change from stock hpaste is overriding colors and fonts, which are features built into the firefox web browser; browser.display.use_document_colors=false and browser.display.use_document_fonts=false
15:08:36 <dmwit> You only need recursive do for *recursive binds*, which are very unusual.
15:08:40 <chrisdone> at least in the sense that it demands the rest of the list before returning in the tail
15:08:41 <twomashi> dmwit: but I need it to unwrap the maybes dont i?
15:09:08 <donri> ab9rf: fixed width is a silly hack though.
15:09:30 <dmwit> :t let f (x:xs) = do { v <- x; case v of Nothing -> return []; Just a -> (a:) <$> f xs } in f
15:09:32 <ab9rf> donri: fixed width is the natural way of computers.  proportional fonts are a silly hack.
15:09:32 <lambdabot> (Monad m, Functor m) => [m (Maybe a)] -> m [a]
15:09:34 <donri> as programmers we're used to it but it's really cuh-razy
15:09:40 <dmwit> twomashi: look ma, no recursive do!
15:09:55 <twomashi> oh man
15:10:06 <twomashi> ok thanks! gonna take a look..
15:10:07 <dakaktak> `nand`: and where these colors came from?
15:10:40 * elliott thinks ab9rf has a strange definition of "natural". or perhaps, "computers", "hack"...
15:11:27 <dmwit> I would love to live in a world where we programmed in proportional fonts.
15:11:35 <`nand`> dakaktak: originally came from a terminal color scheme which I modified slightly and adopted into firefox; the palette can be found here: https://github.com/nandykins/gentoo-conf/blob/master/.Xdefaults
15:11:40 <chrisdone> monospace is only useful for moving across an alphabetical word
15:11:55 <`nand`> dakaktak: also https://github.com/nandykins/gentoo-conf/blob/master/.pentadactylrc for the pentadactyl colors
15:12:03 <dakaktak> `nand`: awesome
15:12:07 <ab9rf> i'd been using computers for well over a decade before i got one that could display things in proportional fonts at a point size smaller than bannertext
15:12:10 <donri> chrisdone: what do you mean?
15:12:11 <chrisdone> dmwit: i'm working on an in-browser editor with proportional fonts
15:13:24 <donri> someone should make a fixed width, fixed height font
15:13:51 <ab9rf> donri: there are lots of those already
15:14:03 <`nand`> some of the ‘wide’ fonts come pretty close, I think
15:14:18 <`nand`> though those might be wider than square
15:14:28 <donri> or maybe replace our orthography with one where every shape looks almost identical!
15:14:45 <chrisdone> donri: in the sense that moving the cursor with the arrow keys is distracting if the movement speed isn't consistent
15:14:55 <`nand`> terminus gives me problems with q and g looking similar when underlined
15:14:56 <donri> chrisdone: oh. i never do that :D :D
15:15:01 <`nand`> I've been meaning to do something about it, but too lazy
15:15:02 <ab9rf> donri: oh, you mean a square character cell
15:15:05 <chrisdone> i'm not really convinced it's a big deal because people do word processing with proportional fonts
15:15:20 <donri> chrisdone: i even have key repeats disabled in the OS
15:15:56 <chrisdone> donri: yeah i just jump with a search. it's kind of lazy :p
15:16:02 <dmwit> donri: Just set your font to the password font... ;-)
15:16:03 <`nand`> I have key repeats sped up significantly, because I find it easy to navigate that way, especially when not in an environment that has vim-like navigation commands like “go to start of word”
15:16:35 <donri> chrisdone: search is a motion in vim btw. does emacs do anything like that?
15:16:42 <`nand`> chrisdone: I think most people that do word processing use the mouse to click where they want their cursor to be rather than using arrow keys
15:17:08 <donri> `nand`: there are environments like that?
15:17:10 <chrisdone> `nand`: those kind of people aren't worth comparing with programmers
15:17:24 <Taneb> Oh man, there's nothing like a fresh Haskell install
15:17:32 <donri> most have either readline-like bindings or windows like with e.g. ctrl-arrow
15:17:34 <chrisdone> donri: dunno
15:17:38 <Taneb> Now to polute the doc index by installing lens
15:17:45 <skp> hey dmwit!
15:17:59 <twomashi> dmwit: worked, thanks!
15:18:37 <hiptobecubic> chrisdone, the fast majority of programmers *also* click around. Maybe not among haskellers because IDE usage isn't as high, but certainly if you pick a random programmer.
15:18:53 <skp> dmwit: https://github.com/skypers/ark-gl/blob/unstable/Graphics/Rendering/Ark/GL/Shader/Stage.hs#L105
15:19:00 <`nand`> donri: what's the readline-like binding for “go to start of word”?
15:19:01 <skp> the 3 instances are quite annoying to write
15:19:04 <skp> but it works
15:19:12 <chrisdone> donri: oh a motion is something that moves the cursor poisition?
15:19:16 <hiptobecubic> `nand`, alt+f i think
15:19:39 <donri> chrisdone: weelll. this is getting off topic
15:19:40 <hiptobecubic> chrisdone, it's higher level than that. it can also be used for yanking, deleting, rearranging text, etc
15:19:40 <`nand`> hiptobecubic: neat; though that seems more like “go to end of word”
15:19:43 <donri> are you in -blah
15:20:08 <hiptobecubic> `nand`, yes so it seems.
15:20:22 <dmwit> skp: great!
15:20:28 <donri> `nand`: meta-f i think
15:20:28 <hiptobecubic> I use a peculiar mixture of readline bindings and vim bindings day to day
15:20:45 <donri> `nand`: uh, meta-b
15:21:00 <`nand`> the only readline bindings I have muscle memory'd are ^u to clear and ^e to go to the end
15:21:01 <hiptobecubic> I have a lot of readline stuff replicated in my vimrc. <C-a> <C-e> being two major ones.
15:21:11 <`nand`> ooh, ^w deletes the last word. that's handy
15:21:17 <donri> hiptobecubic: https://github.com/tpope/vim-rsi
15:21:30 <hiptobecubic> `nand`, i use ^w a lot as well
15:21:31 <dmwit> It's really too bad that you can't use pattern-binding in instance blocks.
15:22:26 <dmwit> instance GLObject GeometryShaderStage where (glID, gens, deletes) = globjectInst -- would be just too cool
15:22:30 <hiptobecubic> donri, looks nice
15:23:01 <skp> 00:22 < dmwit> instance GLObject GeometryShaderStage where (glID, gens, deletes) = globjectInst -- would be just too cool
15:23:04 <skp> yes
15:23:25 <skp> or be able to make all instances of a class instances of another class
15:23:38 <skp> that’s what I was doing but…
15:23:40 <donri> chrisdone: remember, vim's operations are like a mini-language. a 'motion' is like an object you can apply a verb to
15:24:01 <dmwit> I also once tried instance (Monad m, Num a) => Num (m a) where [(+),(*),(-)] = map liftM2 [(+),(*),(-)]. =)
15:24:41 <skp> dmwit: that’s pretty weird
15:25:08 <skp> liftM2 is so nice
15:25:54 <donri> chrisdone: d?^instance<CR>}}p delete to previous '^instance' and paste it two 'paragraphs' below
15:25:56 <chrisdone> dmwit: here's a screenshot demonstrating spj's favourite proportional font https://dl.dropbox.com/u/62227452/Screenshots/Screenshot%20from%202013-01-06%2021:54:23.png
15:26:16 <chrisdone> dmwit: (it's an old one tho, back when the editor was less complete)
15:26:32 * dmwit cackles
15:26:55 <donri> chrisdone: (a paragraph is a chunk of lines surrounded by empty lines)
15:26:57 <`nand`> is that Comic Sans MS or is my brain just interpreting every awful font that way?
15:27:01 <donri> yay comic sans!
15:27:07 <dmwit> chrisdone: You're going to have elastic tabstops, right? Right?
15:27:24 <skp> hey
15:27:34 <skp> do you think it’s sane to write a function like
15:27:38 <skp> bear = liftIO
15:27:45 <skp> I mean, use bear instead of liftIO
15:27:49 <skp> it’s less abstract
15:27:52 <elliott> no because bear is a silly name for that
15:28:02 <skp> silly?
15:28:09 <danharaj> I bind io to liftIO
15:28:26 <elliott> skp: have you ever seen a bear lift an action through a monad stack?
15:28:45 <geekosaur> it could be bear(v)...
15:28:50 <skp> I have a monad where I want to be indulgent
15:28:53 <skp> I can use liftIO
15:28:55 <geekosaur> although it doesn't make much sense to me
15:29:05 <skp> to bear here is kinda straight-forward
15:29:20 <geekosaur> skp, it's not unusual for programs to locally define io = liftIO
15:29:25 <elliott> if you want to give a shorter name than liftIO like io or something that makes sense. "bear" is just confusing.
15:29:33 <elliott> do you have an example usage that shows why this is clearer than liftIO?
15:29:40 <skp> yes
15:29:49 <skp> the monad is a type
15:29:50 <dmwit> ?remember elliott have you ever seen a bear lift an action through a monad stack?
15:29:50 <lambdabot> It is forever etched in my memory.
15:29:51 <skp> like
15:30:14 <skp> type Foo a = EitherT ErrorType IO a
15:30:26 <skp> I have a function, called « safely »
15:30:44 <skp> that calls some IO action after each function you pass to it
15:31:02 <skp> safely :: String -> IO a -> Foo a
15:31:07 <skp> but
15:31:18 <skp> if I don’t want to check anything
15:31:28 <`nand`> elliott: that sounds like a promising new monad transformer tutorial
15:31:29 <skp> I just « bear »
15:31:45 <skp> safely $ getLine
15:31:47 * elliott wonders if skp is a native English speaker -- that meaning of "bear" seems very awkward in this context
15:32:02 <skp> nope I’m not
15:32:11 <donri> bear with me
15:32:13 <chrisdone> donri: that would be C-<space> C-r instance C-w C-S-} C-S-} C-y. so probably as usual. emacs commands look like vim except with C- in front
15:32:14 <`nand`> for clarity
15:32:14 <donri> lift with me!
15:32:14 * geekosaur thinking idiom "bear with it"?
15:32:17 <elliott> maybe something like "execute"?
15:32:17 <`nand`> this is a bear: https://en.wikipedia.org/wiki/File:Medved_mzoo.jpg
15:32:25 <elliott> but honestly I'd just use liftIO or io
15:32:33 <typoclass> or lioft
15:32:35 <geekosaur> which, well, that is idiom I would try not to use in a program for someone else's consumption
15:32:53 <chrisdone> dmwit: i can't remember what an elastic tabstop is but in my editor you can't control indentation or insert tabs or spaces, so probably it doesn't matter
15:33:00 <donri> chrisdone: heh yea. the vim one is repeatable though ;)
15:33:02 <dmwit> Independent of that idiom, "bear" is also a verb roughly synonymous with "carry".
15:33:04 <skp> to bear is to be tolerant, isn’t it?
15:33:10 <`nand`> chrisdone: http://nickgravgaard.com/elastictabstops/columnblocks_coloured.gif
15:33:18 <donri> chrisdone: well it's two repeatable actions
15:33:18 <dmwit> same root as "burden", I think?
15:33:30 <chrisdone> donri: in emacs i'd hit f3 before typing that and then hit f4 again to repeat it
15:33:35 <donri> yea
15:33:51 <typoclass> skp: can be, yes
15:33:53 <dmwit> chrisdone: elastic tabstops are a way to align things across lines (which is independent from indentation)
15:34:07 <chrisdone> dmwit: oh yeah. like
15:34:19 <chrisdone> case x of
15:34:19 <chrisdone>   y   -> y
15:34:19 <chrisdone>   zxf -> p
15:34:20 <skp> typoclass: so what’s the problem here?
15:34:23 <dmwit> chrisdone: right
15:34:25 <skp> to bear is like tolerate
15:34:33 <skp> or whatever has the same meaning
15:34:46 <chrisdone> dmwit: yeah i tried that using tables
15:35:07 <skp> here bear = liftIO is a shortcut not to run any checks after IO action
15:35:15 <skp> whereas « safely » does some checks
15:35:32 * dmwit feels he could be convinced that "bear" was an okay thing to define, provided it was documented/commented properly
15:35:34 <`nand`> unsafeBear
15:36:00 <skp> maybe the « safely » function already exists in Control.Monad
15:36:03 <chrisdone> `nand`: yeah you get that kind of thing for free in the browser
15:36:05 <typoclass> skp: right. i think people were reading "bear" as "carry" (bear a pistol = carry a pistol), and found it weird because lift plays a role, but "lift a pistol" is not the same as "carry a pistol"
15:36:06 <skp> a call like « after »
15:36:19 <typoclass> skp: anyway, it needs some explaining :-)
15:36:25 <skp> yeah, of course
15:36:31 <skp> for me it’s very clear
15:36:42 <`nand`> chrisdone: it use tables for rendering or something?
15:36:45 <skp> I should have named it « tolerate »
15:36:49 <skp> or unsafe
15:36:51 <skp> yeah
15:36:57 <skp> unsafely*
15:36:58 <chrisdone> `nand`: right
15:37:01 <Taneb> SPJ has a really nice voice
15:37:08 <donri> hoist!
15:37:09 <chrisdone> Taneb: oh, hello =)
15:37:18 <donri> Taneb: does that make sense?
15:37:25 <chrisdone> `nand`: <tr><td> code </td><td> comments </td></tr>
15:37:34 <chrisdone> `nand`: (more or less)
15:37:47 <Taneb> Does what make sense?
15:37:47 <donri> typoclass: the right to arm bears!
15:37:58 <donri> Taneb: spj always says that
15:38:05 <donri> great teacher :)
15:38:16 <`nand`> chrisdone: though note that elastic tabstops' boxes aren't vertically aligned as a table would be; unless you use multiple tables
15:38:19 <chrisdone> donri: the bear to right arms!
15:38:26 <skp> https://github.com/skypers/ark-gl/blob/unstable/Graphics/Rendering/Ark/GL/Monad.hs
15:38:31 <skp> here’s safely and bear
15:38:32 <donri> chrisdone: i can't bear my right arm
15:38:37 <Taneb> I think if I want to become a great Haskeller, I'm gonna need a great voice
15:38:38 <dakaktak> skp: skypers?
15:39:00 <skp> yes
15:39:01 <skp> why?
15:39:05 <chrisdone> Taneb: if morgan freeman was a haskeller we'd be successful tomorrow
15:39:08 <skp> do you know me?
15:39:09 <`nand`> I doubt ‘safely’ is gonna show up in Control.Monad :)
15:39:20 <Ericson2314> I have a simple Existential datatype like "data asdf forall a. CLASS => asdf a"
15:39:24 <skp> `nand`: why not!
15:39:27 <typoclass> skp: i think that safely function is extremely useful
15:39:36 <skp> yes it is
15:39:45 <skp> I use it everywhere in my binding
15:39:45 <Ericson2314> ghci wants me to create an instance of CLASS for asdf
15:39:47 <`nand`> that would imply ‘base’ having a dependency on OpenGL
15:39:51 <`nand`> to say the least
15:39:57 <skp> no no
15:39:59 <Ericson2314> what is the best way to do this without boilerplate?
15:40:11 <`nand`> oh
15:40:13 <skp> if it should end up in Control.Monad
15:40:14 <`nand`> you meant the general pattern?
15:40:21 <skp> it should be called « after »
15:40:21 <skp> yes
15:40:34 <skp> and don’t own the extra String parameter
15:40:35 <chrisdone> skp: are you french?
15:40:37 <sulaiman> Hello.
15:40:40 <skp> yes why?
15:40:50 <skp> doesn’t*
15:40:53 <chrisdone> skp: 'cause « french quotes » aren't they ?
15:40:54 <typoclass> sulaiman: hi
15:40:59 <skp> oh
15:41:01 <skp> yes
15:41:03 <skp> bépo
15:41:19 <skp> (that’s my keyboard layout, you know)
15:41:48 <dakaktak> В домодедово -19
15:41:52 <`nand`> the proper quotation marks for an english context “are these”. (Don't trust people who use ")
15:42:00 <chrisdone> yeah my colleague is french, his keyboard is funny
15:42:17 <elliott> `nand`: uh surely you mean Don’t
15:42:40 <`nand`> elliott: :)
15:43:00 <skp> dakaktak: btw who are you?
15:43:05 <chrisdone> the US layout has some useless keys that humans rarely use, but the french one even has µ
15:43:19 <chrisdone> and where ` is, the french one has ². lol
15:43:26 <chrisdone> and /only/ ²
15:43:27 <skp> chrisdone: you mean
15:43:29 <skp> azerty?
15:43:33 <chrisdone> azerty, yeah
15:43:36 <jmcarthur> chrisdone: so you're saying we need to recruit morgan freeman
15:43:39 <skp> it’s pretty a fucking bad layout, yes
15:43:42 <`nand`> I'm not entirely sure about that one actually, I remember reading that ’ was the proper symbol for this, but I also remember reading that there's a separate codepoint for for them; with yet another source saying ' was actually the correct symbol and should be rendered as ’
15:43:42 <applicative> Ericson2314: whats wrong with data F = forall a . Show a => F a; instance Show F where  show (F x) = show x
15:43:43 <skp> that’s why I use bépo
15:44:04 <chrisdone> skp: ah, it's more sane?
15:44:08 <skp> bépo is for writting french tho, but yes
15:44:12 <skp> it’s more sane :D
15:44:15 <tomoj> is `Monoidal f => (a -> f b) -> t a -> f (t b)` a suitable basis for Traversable or would it be different?
15:44:21 <Ericson2314> applicative: looks great
15:44:26 <skp> it’s the french equivalent for the dvorak us
15:44:35 <`nand`> I write french using US International
15:44:38 <Ericson2314> though it appears you gave F a type param when it doesn't ahve one
15:44:43 <chrisdone> jmcarthur: hmm. fund ten months of hackage development, or hire morgan freeman for a 5 minute voice over about haskell. decisions decisions
15:45:02 <applicative> Ericson2314: in that style the type F has no param; the constructor F does
15:45:05 <skp> writting english is sometimes annoying since the w letter is pretty far away from the center of the keyboard
15:45:06 <`nand`> applicative: how does that meaningfully differ from data F = F String
15:45:11 <skp> but it’s not a big deal
15:45:24 <applicative> `nand`: it doesnt
15:45:32 <chrisdone> skp: ah nice
15:45:41 <`nand`> oh
15:45:45 <applicative> `nand`: Ericson2314 was asking about general principles for making existential types, I thought
15:45:47 <`nand`> it was just an example for Ericson2314
15:45:48 <`nand`> I see now
15:45:54 <sulaiman> I am trying to convert a simple python code into haskell code, my python code has data stored in the following format: {"user one": {"book one": 3.5, "book two": 4.0}, "user two": {  }}. would this be the proper way to hold such data in haskell: [ ("user one", [ ("book one", 3.5), ("book two", 4.0) ] ), ("user two", [  ] ) ] ?
15:46:02 <Ericson2314> ok
15:46:14 <Ericson2314> at least the boilerplate is only for ever method
15:46:24 <Ericson2314> and not for every possible instance
15:46:24 <skp> dakaktak: may you please answer? where do you know me from?
15:46:26 <dakaktak> skp: skypers github sounds like a place where people from skype sharing their opensource code
15:46:29 <`nand`> applicative: that's why I always use names like ‘Foo’ and ‘Bar’ in these contexts, to avoid people like myself smart-pantsing me :)
15:46:40 <typoclass> sulaiman: yeah, that's a plausible format
15:46:41 <applicative> ah
15:46:52 <skp> whaat?
15:47:02 <skp> my name has nothing in common with skype
15:47:05 <skp> well my name
15:47:07 <skp> I meant
15:47:08 <skp> nick
15:47:11 <`nand`> all the consonants!
15:47:12 <chrisdone> skp: respect for contributing in the english channel. i know how much easier it would be to stay within the french communities. seems to me that most french people suffer english rather than embrace it =)
15:47:35 <`nand`> I know most german people suffer french rather than embracing it ;)
15:47:36 <skp> chrisdone: thank you
15:47:43 <skp> I like talking here
15:47:59 <skp> many french programers are just hm
15:48:09 <skp> selfish, and arogant
15:48:32 <skp> plus, I realy enjoy the english language
15:48:33 <Nisstyre-laptop> skp: the only French programmer I've encountered wrote the libcaca library
15:48:33 <`nand`> s/french//
15:48:40 <chrisdone> skp: are there big irc networks in french? i know there're big forums. i live in italy and i've been looking for italian geek communities, but it's been difficult
15:48:40 <skp> sam
15:48:44 <Nisstyre-laptop> skp: yes
15:48:45 <sulaiman> okay, thanks typoclass.
15:48:49 <skp> I know him :)
15:48:55 <Nisstyre-laptop> skp: anyway he's not arrogant or selfish
15:48:56 <skp> he’s in the demoscene
15:49:03 <skp> he’s cool
15:49:04 <skp> yes
15:49:07 <Nisstyre-laptop> but I'm not disagreeing with you in general
15:49:32 <skp> I meant casual developers
15:49:35 <Nisstyre-laptop> yeah
15:49:40 <skp> who think they’re god
15:49:41 <skp> 00:48 < chrisdone> skp: are there big irc networks in french? i know there're big forums. i live in italy and i've been looking for italian geek communities, but it's been difficult
15:49:45 <skp> not really
15:49:55 <skp> I know some chans
15:50:03 * typoclass thinks the french programmers probably don't show up here because they keep joining #askell, similar to how the germans keep going to #hasskell
15:50:04 <Ericson2314> OK, seems to be working but, It says it can't deduce that certain constraints in each method are satisfied
15:50:08 <skp> but there’re what
15:50:11 <skp> 20 peopele
15:50:14 <skp> people*
15:50:15 <chrisdone> lol
15:50:33 <skp> ahah typoclass
15:50:36 <skp> funny
15:50:38 <chrisdone> typoclass: heh, and the italians. 'askell
15:50:38 <typoclass> ;-)
15:50:47 <`nand`> tomoj: which Monoidal is that?
15:51:02 <chrisdone> pee acka pee and acka tee em elle
15:51:08 <Ericson2314> nevermind
15:51:55 <crl> #hazskell --germans
15:52:05 <`nand`> that doesn't look very german to me
15:52:16 <skp> Nisstyre-laptop: you can meet sam on #demo-fr
15:52:22 <skp> on the nerim server
15:52:26 <skp> if you want to :)
15:52:31 * `nand` has a german channel called #haaskell (on another network)
15:53:06 <crl> a right sounds better, i'm not german btw
15:53:31 <applicative> Ericson2314: obviously the way you can handle something closed up in an existential type is very limited!
15:53:56 <`nand`> “hasskell” would be the german misheard version; but #haaskell is just a pun on my and a friend's last names (both ‘Haas’)
15:54:16 <skp> the last time I asked some french dudes to tell me whether I was right about « morphisms are arrows », they insult me because I was right – math context – and wrong – haskell one.
15:54:20 <Ericson2314> I was defining an constantType -> instanceType method
15:54:31 <Ericson2314> as if it was an instanceType -> ConstantType method
15:54:44 <Ericson2314> Now I just need to derive show and eq
15:54:46 <Ericson2314> and I am done
15:54:50 <Ericson2314> so that example is perfect
15:55:06 <skp> well, I guess you don’t care and that’s ok, neither do I
15:55:55 <TravisD> Does this look like a sane set of types for doing n-armed bandit experiments? http://hpaste.org/83776
15:56:02 <Nisstyre-laptop> skp: is it just me, or did France stop contributing much to math after the beginning of the 20th century?
15:56:24 <skp> I guess you’re right
15:56:35 <skp> we still contribute to AI
15:56:36 <Nisstyre-laptop> why is that? because of the two world wars?
15:56:37 <skp> but math
15:56:43 <skp> what?
15:56:45 <chrisdone> hungarian chap hypothesized to me that that's why ocaml failed. it's a french product, but french stuff stays in france
15:56:51 <Nisstyre-laptop> why did they stop contributing to math much?
15:57:02 <Nisstyre-laptop> before the early 1900s there were tons of great French mathematicians
15:57:23 <ciaranm> because they still insist upon speaking french
15:57:34 <tomoj> `nand`: the one from 'applicative programming with effects'
15:57:36 <Nisstyre-laptop> ciaranm: idk, the German ones still spoke German
15:57:41 <applicative> all through the 20th century there were great French mathematicians
15:57:42 <skp> I don’t really know, there’re already a lot of math knowledge
15:57:47 <tomoj> (but if there is a better choice, I'd like to know)
15:57:52 <Nisstyre-laptop> applicative: not very well known ones though
15:57:52 <skp> is there anything left to search?
15:58:02 <ciaranm> the difference is, germans don't mind stealing english words
15:58:12 <chrisdone> skp: i think people have been asking 'is there anything left?' since forever =p
15:58:14 <tomoj> the answer to my question is clearly 'yes', since we can turn any monoidal into an applicative
15:58:18 <ciaranm> whereas before you're allowed to use a new term in published french, there has to be a government-approved non-english-sounding word for it
15:58:27 <skp> yeah :D
15:58:32 <tomoj> er, any applicative into a monoidal
15:58:33 <chrisdone> there was a guy in 1900 that declared everything worthwhile has been invented
15:58:35 <Nisstyre-laptop> ciaranm: yeah, that's silly prescriptivism
15:59:08 <skp> we still have physicians
15:59:26 <skp> Hubert Reeves
15:59:26 <applicative> ha, grothendieck is still alive you know
15:59:26 <chrisdone> Nisstyre-laptop: for me silly is part of the definition of prescriptivism =p
15:59:27 <skp> for instance
15:59:46 <skp> « contribute to math » is vague
15:59:50 <ciaranm> also, french academics inevitably get involved in politics, which rots the brain
16:00:16 <`nand`> tomoj: ah, I see it; yes, that's an equivalently valid formulation of Traversable
16:00:21 <applicative> grothendieck's school math teacher told him everything had already been done in math, dont go into it.
16:00:23 <skp> ciaranm: in french, research are cut because of money
16:00:28 <chrisdone> ciaranm: seems like anyone with power/money/influence eventually gets into politics?
16:00:31 <`nand`> Monoidal and Applicative are identical in both directions
16:00:35 <tomoj> right
16:00:46 <tomoj> I was wondering if you might change the interface of Traversable if you based it on Monoidal
16:01:04 <skp> you can search what you what but you won’t have money, it’s underestimated
16:01:36 <skp> politics don’t care about research
16:01:42 <ab9rf> for some reason i just read "Monoidal" as "suicidal"
16:01:44 <skp> I mean in France
16:01:58 <Nisstyre-laptop> skp: what about biological research?
16:02:03 <skp> they prefer economy over science
16:02:12 <aristid> skp: do you have actual numbers showing that france spends less money on research than other similar countries?
16:02:15 <skp> Nisstyre-laptop: I know a friend who does that
16:02:23 <skp> it looks like just *fucking great*
16:02:24 <ab9rf> grargh
16:02:27 <skp> but same issue
16:02:29 <skp> money
16:02:50 <skp> aristid: well, none
16:02:51 <chrisdone> gonna go read my scifi book
16:02:53 <skp> not official
16:02:56 <applicative> I don't believe France is any different from other places in this respect
16:02:59 <skp> but for instance
16:02:59 * aristid imagines skp spitting while saying the word "money" :D
16:03:09 <skp> ahah :D
16:03:13 <skp> spitting out
16:03:19 <skp> well for instance
16:03:29 <skp> at the end of university
16:03:42 <skp> you can do a « these » (I don’t know the english word)
16:03:48 <skp> for 2 or 3 years
16:03:50 <Nisstyre-laptop> thesis
16:03:54 <skp> of research
16:03:57 <skp> it’s paid
16:04:02 <skp> but not very much
16:04:14 <chrisdone> applicative: mmm, italy spends a lot on research and innovation, without really scrutinizing how it's spent and the results
16:04:16 <hiptobecubic> skp, leading to ? phd?
16:04:17 <skp> you can’t even live with
16:04:24 <skp> yeah
16:04:32 <Nisstyre-laptop> some research is motivated by political ideology
16:04:33 <hiptobecubic> lol
16:04:46 <ciaranm> i was under the impression that most of italy's research funding goes on prostitutes. my adviser may have given me a biased impression.
16:04:49 <skp> a friend of mine goes to canada for her thesis
16:05:08 <skp> she’s gonna « light neurons to simulate some brain electroactivities »
16:05:18 <skp> the thesis topic is just awesome
16:05:30 <skp> but she has difficults to gain money for the trip
16:05:32 <chrisdone> applicative: although that is changing, the european commission wants to start prefering a kind of loan rather than funding. e.g. if the project doesn't deliver (for some value, e.g. application in industry/a start-up or w/e), the money has to be paid back
16:05:49 <applicative> http://en.wikipedia.org/wiki/List_of_countries_by_research_and_development_spending presumably covers too much
16:06:12 <hiptobecubic> chrisdone, that would be pretty disastrous i think
16:06:12 <chrisdone> skp: nothing more fun than messing with brains? :p
16:06:14 <skp> sixth, hm…
16:06:20 <skp> ahah
16:06:28 <aristid> skp: all the things you said so far are not only not numbers, but also not relative. to compare countries, you cannot say "there is not enough money", you need to talk about how money availability DIFFERS BETWEEN COUNTRIES
16:06:30 <hiptobecubic> As if the problem of negative results is career destroying enough
16:06:35 <hiptobecubic> isn't*
16:06:35 <Taslem> Rank by % GDP PPP.
16:06:36 <TravisD> skp: Which Canadian university?
16:06:38 <applicative> israel is proportionately high, as one might have figured
16:06:43 <ciaranm> because it's only science if you know it's going to work!
16:06:50 <skp> it’s about to implant neurons into dudes who actually lack ’em :DD
16:07:03 <skp> I don’t know TravisD
16:07:13 <skp> she didn’t tell me
16:07:27 <TravisD> skp: Ah, well - no problem :) I was just a curious Canadian
16:07:27 <chrisdone> hiptobecubic: it depends on the application, i think. the kind of researchers whose main motivation is getting published in a prestigious institution are funded in different ways aiui
16:07:41 <Taslem> By %GDP PPP, France is #15. Still fairly high. Above UK, actually. Below US.
16:07:48 <skp> 01:06 < aristid> skp: all the things you said so far are not only not numbers, but also not relative. to compare countries, you cannot say "there is not enough money", you need to talk about how money availability DIFFERS BETWEEN COUNTRIES
16:07:49 <hiptobecubic> TravisD, royal canadian university of canada, i imagine
16:08:12 <TravisD> hiptobecubic: Why do you imagine that?
16:08:15 <skp> I don’t want to compare, I just said that France doesn’t really care about research
16:08:29 <hiptobecubic> TravisD, because I don't know anything about canadian universities.
16:08:32 <TravisD> oh :)
16:08:48 <skp> do you know our president?
16:08:50 <skp> I mean
16:08:53 <skp> who he is?
16:08:56 <TravisD> Except that they might be Royal like the canadian mounted police
16:09:03 <aristid> skp: but the whole discussion was about how france produces relatively less in terms of mathematical publications compared to other countries these days...
16:09:05 <chrisdone> aristid: i well you don't necessarily have to compare countries. you can still just consider how much money is being spent in a country versus how much it has done in the past, the results measured, etc.
16:09:17 <hiptobecubic> TravisD, a nobel order if I've ever seen one
16:09:50 <aristid> chrisdone: ok, you can compare with the past if that's the question you want to answer. ultimately to get useful answers, some reference level is pretty much always required i think.
16:09:51 <skp> 01:08 < aristid> skp: but the whole discussion was about how france produces relatively less in terms of mathematical publications compared to other countries these days...
16:09:54 <skp> to be honest
16:09:59 <skp> I don’t know
16:10:05 <aristid> skp: ok, nor do i.
16:10:12 <aristid> i don't even know if that statement is true.
16:10:15 <crl> because french research system is bad
16:10:20 <skp> which statement?
16:10:25 <skp> crl: yes
16:10:28 <skp> it is
16:10:29 <aristid> skp: the statement that france produces less.
16:10:38 <skp> no I think it is
16:10:50 <aristid> maybe it is. i don't know!
16:10:55 <crl> there are many public institution, desynchronized
16:10:57 <skp> or I don’t follow enough publications
16:11:18 <lispy> inria is french, right?
16:11:23 <skp> yes
16:11:25 <crl> yes
16:11:28 <TravisD> yes
16:11:37 <aristid> yes
16:11:43 <mgsloan> yes
16:12:02 <chrisdone> hah: http://www.iop.org/news/12/feb/page_53972.html: For the UK, however, its proportionate decrease in output – from 7.1% of the world’s physics research in 2001 to 6.4% in 2010 – has been accompanied by a celebratory increase in overall, average quality – with the average number of citations of UK research papers rising from 1.24 in 2001 to 1.72 in 2010.
16:12:08 <aristid> damn chrisdone broke the chain
16:12:11 <chrisdone> that's like, someone fired all the rubbish people
16:12:28 <chrisdone> to bring the average up
16:12:29 <skp> btw, isn’t Mandelbrot french?
16:12:54 <chrisdone> yep
16:12:54 <skp> oh also american, ok
16:12:59 <Saizan> or just other countries started publishing more?
16:13:21 <aristid> chrisdone: where rubbish is defined as "not enough citations", righto?:)
16:13:52 <chrisdone> aristid: not enough citations, or not published at respected places, i guess
16:14:33 <aristid> "publish or perish" i guess :)
16:14:34 <chrisdone> i work on an easychair-like product and a friend is from researchgate, the whole quality rating thing is a joke =)
16:14:56 <aristid> chrisdone: what is easychair?
16:15:18 <lispy> aristid: comfortable?
16:15:19 <skp> I chair you dont’t have to sit on to be sit
16:15:21 <chrisdone> it's a submission system with review, the step that decides whether papers are accepted or rejected for a conference
16:15:34 <chrisdone> ifcp uses it, iirc, and other confs like that
16:15:51 <Mathnerd314> hmm, this explains why SPJ is from the UK and not from somewhere else :p
16:15:59 <Taneb> Hmm
16:16:04 <aristid> chrisdone: hmm, no idea how this stuff works:)
16:16:04 <Taneb> JuicyPixels doesn't seem to like me
16:16:17 <skp> btw
16:16:26 <skp> do americans contribute to math?
16:16:32 <skp> I mean nowadays
16:16:51 <skp> what has been discovered recently?
16:16:52 <Taneb> RSA was done by Americans, I seem to recall
16:16:56 <applicative> we just import them
16:16:58 <skp> it’s old
16:17:02 <skp> and not math
16:17:03 <skp> not really
16:17:09 <skp> ahah :D
16:17:10 <chrisdone> aristid: a chair calls for papers, people submit, then a group of people invited by the chair are assigned papers, at least three people per paper. the chair then decides to accept/reject papers based on the reviews of a few people
16:17:14 <skp> importing math, nice
16:17:33 <Mathnerd314> skp: judging from http://www.aei.org/papers/education/k-12/solving-americas-mathematics-education-problem/ , I think not
16:17:40 <chrisdone> the reviewers may actually just ask one of their phd students to review the paper sometimes
16:17:40 <aristid> chrisdone: ah, i guess i know where the name easychair comes from... it's supposed to make a chair's life easier
16:17:48 <chrisdone> nod
16:18:12 <bxc> |00:16 < Taneb> RSA was done by Americans, I seem to recall
16:18:17 <skp> what a pity
16:18:23 <bxc> theres a story that GCHQ invented it first in the UK
16:18:27 <bxc> but all secret.
16:18:55 <Taneb> But I'm pretty sure that in the second half of the 20th century most maths was done by Europeans living in the US
16:19:08 <Saizan> bxc: that one was for numberwang, actually
16:19:24 <Taneb> Haskell's got a pretty cool Numberwang library
16:20:21 <chrisdone> aristid: ResearchGate is interesting as they want to do away with traditional institutions like ACM, IEEE, Springer and encourage open publication for which authors gain credibility by citations in the way web pages gain credibility on google by being linked to. the citation idea isn't /bad/, i think, IF it's easy to get cited. right now, it's not. if you don't get in a decent publication, less people see your stuff, and you don't have
16:20:22 <chrisdone> incentive to do anything else, if you want to keep your job or get a better one
16:20:56 <Mathnerd314> skp: I'm not certain how you actually measure productivity though, there's a lot of research that's done just because someone wants an academic job
16:21:43 <otters> @djinn [Maybe [a]] -> Maybe [a]
16:21:43 <lambdabot> Error: Undefined type []
16:21:48 <otters> rats
16:22:39 <applicative> yeah I think thats well beyond djin- powers
16:22:39 <chrisdone> :t sequence (undefined :: Maybe ())
16:22:41 <lambdabot>     Couldn't match expected type `[m0 a0]' with actual type `Maybe ()'
16:22:41 <lambdabot>     In the first argument of `sequence', namely
16:22:41 <lambdabot>       `(undefined :: Maybe ())'
16:22:48 <chrisdone> :t sequence (undefined :: [Maybe ()])
16:22:49 <lambdabot> Maybe [()]
16:23:27 <applicative> @type concat. catMaybes
16:23:28 <lambdabot> [Maybe [a]] -> [a]
16:23:32 <skp> 01:20 < Mathnerd314> skp: I'm not certain how you actually measure productivity though, there's a lot of research that's done just because someone wants an academic job
16:23:35 <skp> sure
16:23:37 <otters> :t fmap join . sequence
16:23:37 <skp> hm
16:23:38 <aristid> chrisdone: i guess there should also be... "rewards" for things that are considered useful but  don't result in a publication
16:23:38 <lambdabot> (Monad f, Functor f) => [f [a]] -> f [a]
16:23:42 <otters> isn't fmap join something else?
16:23:45 <applicative> ah
16:24:12 <applicative> join $ fmap f m is m >>= f
16:24:42 <Mathnerd314> skp: also see http://archive.sciencewatch.com/dr/cou/2011/11decALL/
16:24:47 <otters> join . fmap isn't fmap join
16:24:58 <applicative> right
16:25:07 <applicative> I was thinking fmap join was fmap join
16:25:27 <xpika> if I upgrade my GHC will I have to reinstall all my cabal libraries?
16:25:46 <applicative> xpika: yes emphatically
16:25:47 <byorgey> otters: well, it must be the case that  fmap join === join  when the types work out
16:25:52 <byorgey> (which they don't in this example)
16:26:09 <byorgey> err, not quite
16:26:16 <skp> ok I have something new about my latest issue (overlapping instances)
16:26:22 <byorgey> I guess it's  join . fmap join === join . join
16:26:22 <skp> dmwit: come back :D
16:26:30 <otters> fmap join . sequence typechecks for me
16:26:46 <xpika> applicative: is there any way to automate the reinstallation of these libraries?
16:26:49 <applicative> if its the same functor
16:26:50 <skp> I *have* to write (ShaderStage s) => GLObject s instance
16:27:12 <skp> because I use GLObject methods on generic shader type
16:27:16 <applicative> there is cabal install world, if you keep the world file, but I'm not sure it's such a great idea
16:27:21 <skp> I’ve fixed the proble
16:27:28 <byorgey> otters: what do you actually want your [Maybe [a]] -> Maybe [a]  function to do
16:27:31 <byorgey> ?
16:27:34 <skp> m with the extension IncoherentInstances
16:27:34 <applicative> xpika: ^^^
16:27:40 <byorgey> otters: I can imagine several reasonable functions of that type.
16:27:41 <skp> is it safe or error-prone?
16:27:52 <otters> byorgey: the actual monad I'm using is a StateT
16:28:02 <otters> I have a list of Foo [a]
16:28:04 <byorgey> otters: oh, instead of Maybe you mean?
16:28:07 <otters> [Foo [a]] -> Foo [a]
16:28:09 <otters> yeah
16:28:14 <otters> I used Maybe for djinn's benefit
16:28:18 <otters> but that was pointless
16:28:26 <applicative> @type traverse
16:28:28 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:28:46 <byorgey> ok, I see.   In that case, yes, I can only imagine one function with that type =)
16:28:57 <otters> yep
16:29:10 <chrisdone> :t liftM join . sequence -- ?
16:29:11 <lambdabot> Monad m => [m [a]] -> m [a]
16:29:21 <otters> fmap, liftM
16:29:34 <chrisdone> :t liftA join . sequence -- =p
16:29:36 <lambdabot> (Monad f, Applicative f) => [f [a]] -> f [a]
16:29:41 <danharaj> byorgey: Your imagination is total? :P
16:29:42 <otters> lol
16:29:47 <danharaj> My imagination likes to diverge a lot.
16:30:04 <chrisdone> my imagination runs in ContT
16:30:19 <byorgey> danharaj: yes, unfortunately, I am quite certain my imagination will eventually terminate =(
16:31:00 <typoclass> my imagination has warnings about partial functions
16:31:05 <chrisdone> hm. continuations in a total language. i like the idea
16:31:22 <chrisdone> the program finishes. but you can continue it a bit more
16:31:31 * chrisdone hits a zen-like gong
16:31:34 <aristid> byorgey: i think i have a solution for the halting problem in a similar vein: ultimately, every computer will break down, therefore all programs terminate ;) :P
16:31:41 <byorgey> hehe
16:31:52 <chrisdone> ( https://www.youtube.com/watch?v=nVZdCG5J34I )
16:31:56 <byorgey> solved!
16:32:06 <byorgey> so where's aristid'd Turing Award already
16:32:11 <xpika> applicative: cool!
16:33:45 <chrisdone> a desk gong would be a good gift for programmers, mathers and general people who sit and think stuff. whenever they have an epiphany they can strike the gong
16:34:01 <applicative> xpika: if you have a recent cabal-install you might expedite it with the flag for parallel installs
16:34:06 <Sifr> Hello, I am trying to write a function `f = let d = sum \n in (- (d^2) d)` but it doesn't work. I want the sum of a list and then I square it and subtract the sum.
16:34:08 <startling> chrisdone: oh man
16:34:13 <applicative> xpika: like -j2 or whatever
16:34:49 <fragamus> yeah we could harness edwardk's gong as a power source for con ed
16:34:50 <aristid> byorgey: i figure the program for delivering will terminate eventually, so no rush
16:35:16 <applicative> xpika you should also check your .cabal/config to see if its doing all you want, e.g haddocking docs or compiling for profiling if you want etc
16:35:56 <mspells> Sifr: why is there a \ in there?
16:35:57 <aristid> chrisdone: do you have a desk gong already, or is this a subtle hint as to what you want as a gift from people? ;)
16:36:07 <crl> @tu (Just even)
16:36:07 <lambdabot> Maybe you meant: . ? @ bf bug do ft id pl rc run thx v wn
16:36:13 <crl> @ty (Just even)
16:36:14 <Sifr> mspells: to show a newline is actually there in my file
16:36:15 <lambdabot> Integral a => Maybe (a -> Bool)
16:36:19 <chrisdone> Sifr: that's equivalent to writing f = (- (sum^2) sum)
16:36:22 <mspells> ah :P
16:36:27 <hpaste> “John Smith” pasted “Python to Haskell” at http://hpaste.org/83778
16:36:34 <chrisdone> Sifr: which you must see isn't properly typed
16:36:40 <crl> > traverse (Just even) [1..10]
16:36:41 <lambdabot>   Couldn't match expected type `a0 -> f0 b0'
16:36:42 <lambdabot>              with actual type `D...
16:36:47 <sulaiman> can anyone take some moments to review a function I converted from python code to haskell? http://hpaste.org/83778
16:36:58 <Sifr> chrisdone: ah I see that it isn't typed properly, is there a way to make it evaluate the let first?
16:37:02 <chrisdone> aristid: is it still a subtle hint if i explicitly acknolwedge it? =p
16:37:13 <applicative> > traverse (Just . even) [1..10]
16:37:16 <lambdabot>   Just [False,True,False,True,False,True,False,True,False,True]
16:37:17 <crl> how can i have (a -> Maybe Bool)
16:37:25 <crl> ok
16:37:34 <crl> @ty (Just .even)
16:37:36 <lambdabot> Integral a => a -> Maybe Bool
16:37:38 <aristid> chrisdone: being german, "subtle" is merely a theoretical concept for me anyways :P
16:37:46 <chrisdone> Sifr: i can't really tell what you want to do, tbh
16:38:14 <Sifr> chrisdone: I have a list, I want to sum it, then I want to solve the equation y = sum^2 - sum
16:38:41 <dmwit> sulaiman: Looks okay. The Haskell one is probably a bit less efficient, but perhaps that's okay.
16:38:53 <chrisdone> aristid: yeah =p
16:38:55 <dmwit> You also aren't doing the "signal if there were no matches" thing.
16:40:00 <chrisdone> Sifr: ah. f xs = (- (d^2) d) where d = sum xs
16:40:00 <chrisdone> Sifr: or f (sum -> d) = (- (d^2) d)   -- and enable ViewPatterns
16:40:37 <Sifr> chrisdone: is let, similar to declaring macros?
16:41:01 <chrisdone> Sifr: or: f xs = let d = sum xs in (- (d^2) d)
16:41:44 <chrisdone> Sifr: no, let is the way to declare normal bindings in an expression
16:41:58 <sulaiman> dmwit, yes, i decided to make an empty list to mean no matches. Is it inefficient because of the way I am comparing the names? actually, at this point I am just making it work. I have another question, currently I am using "rating1 = snd $ users !! 0", I tried to use "rating1 = lookup "Angelica" users" instead but it returns with "Just" type and doesn't work in my list comprehension.
16:42:25 <danharaj> lispy: I'm about to install freeglut/GLUT to get gloss working and I was wondering if you could give me a heads up about any issues that might ruin my night?
16:43:01 <lispy> danharaj: I'm not aware of any. Please submit a bug report if you run into trouble :)
16:43:18 <lispy> danharaj: I'll be afk for a bit, but I'll check back
16:43:31 <danharaj> lispy: alright. first I have to figure out how to build freeglut with mingw because they would rather have instructions for Watcom instead of the compiler people actually use.
16:43:44 <chrisdone> Sifr: a good way to understand haskell syntax is to look at a formal AST: http://hackage.haskell.org/packages/archive/haskell-src-exts/1.13.5/doc/html/Language-Haskell-Exts-Syntax.html#g:8
16:43:49 <typoclass> sulaiman: in my opinion, the inefficiency is not so important. you should worry about that when testing shows that something is too slow
16:45:10 <ab9rf> that was some fucking ugly code, but it works
16:45:14 <Sifr> I replaces - with subtract
16:45:18 <Sifr> and it compiles...
16:45:27 <Sifr> is - infix?
16:45:36 <ab9rf> yes
16:45:40 <hendiadys> Say I have a Vector of a, and a function (a -> a -> a -> b), and I want [b]
16:45:44 <chrisdone> oh i missed that
16:45:48 <chrisdone> Sifr: you're a lisper then?
16:45:50 <hendiadys> How would I do that?
16:46:23 <chrisdone> @djinn (a -> a -> a -> b) -> [a] -> [b]
16:46:23 <lambdabot> Error: Undefined type []
16:46:27 <Sifr> chrisdone: not really, I have configured emacs.
16:46:35 <chrisdone> bah, djinn totally needs lists
16:46:53 <hendiadys> @djinn (a -> a -> a -> b) -> ((a -> r -> r) -> r -> r) -> (b -> r -> r) -> r -> r
16:46:54 <lambdabot> f a b c d = b (\ e -> c (a e e e)) d
16:47:01 <hendiadys> Not helpful
16:47:04 <chrisdone> Sifr: oh ok. your asking about macros and prefix - looked lispy
16:47:10 <oio> tutorial on regex on haskell?
16:47:41 <chrisdone> hendiadys: what's that function supposed to do with the vector tho?
16:47:52 <Sifr> chrisdone: I have a more procedural train of thought than that lol
16:47:53 <hendiadys> Take elements three by three
16:48:03 <chrisdone> oio: last i checked the documentation on regex in haskell was a pile of ass
16:48:18 <hiptobecubic> flabby ass
16:48:23 <hpaste> ab9rf pasted “ugly” at http://hpaste.org/83780
16:48:25 <hiptobecubic> Not the good kind
16:48:30 <chrisdone> wrinkly ass
16:48:34 <ab9rf> that code works but it's ugly as fuck
16:48:47 <hendiadys> So... [1,2,3,4,5,6] => [f 1 2 3, f 4 5 6]
16:48:59 <hendiadys> Except the first list is a Vector
16:49:01 <chrisdone> ahh ok
16:49:19 <oio> haha ok
16:49:19 <ab9rf> who uses regexps in haskell? :)
16:49:54 <tsinnema> does there exist a non-mystery-meat table-of-contents for 'learn you a haskell'?
16:49:54 <chrisdone> hendiadys: i have a feeling lens can do that somehow. could ask in #haskell-lens
16:50:11 <chrisdone> ab9rf: me =p
16:50:13 <hendiadys> I'd have liked to do it with a fold :(
16:50:25 <chrisdone> i use Text.Regex (from regex-compat) or Text.Regex.Posix
16:50:36 <chrisdone> the whole =~ crap is more trouble than it's worth
16:52:22 <typoclass> oio: you could look into parsec. rwh has a chapter on that. the code is really not that complicated, and arguably it's easier to read than a regex
16:52:35 <ab9rf> anyhow, getting that bit to work means i've Made Progress today and can go back to sleep :)
16:52:47 <typoclass> oio: here's the chapter http://book.realworldhaskell.org/read/using-parsec.html
16:53:33 <chrisdone> regexes do have uses where parsec sucks tho
16:53:47 <oio> great going to take a look
16:53:54 <niteria> :t chunk
16:53:56 <lambdabot> Int -> [e] -> [[e]]
16:54:26 <typoclass> chrisdone: sure, but i still think they're overused in general. people come from some kind of perl and grep mindset and think they need a regex for everything
16:54:26 <ab9rf> chrisdone: i have a long-running pogrom against the indiscriminate use of regular expressions to do things that really ought to be done by bespoke parsers
16:54:44 <ab9rf> "I'll use a regexp to split this into words!"
16:56:03 <crl> > words "I'll use a regexp to split this into words!"
16:56:05 <lambdabot>   ["I'll","use","a","regexp","to","split","this","into","words!"]
16:56:06 <ab9rf> and some abomination involving the nonbinding grouping operator and lots of question marks and backslashes
16:57:09 <chrisdone> nod
16:57:13 <ab9rf> not to mention that PCREs have evaluation time that is hyperexponetial in the lenght of the input under certain pathological conditions
16:57:19 <chrisdone> haskellers are the reverse
16:57:38 <chrisdone> i started with parsec the other day and realised i needed a regex, deleted the code and replaced with regex
16:58:18 <chrisdone> yeah i think that's the backreferences that does it
16:58:24 <ab9rf> chrisdone: yes
16:58:44 <ab9rf> backreferences in PCRE can readily cause exponential time and can under some cases cause hyperexponential time
16:58:48 <chrisdone> it's tricky to parse something like this in parsec:
16:59:23 <chrisdone> username: 'can't_stop', password: ''allo 'allo!', age: 123
16:59:39 <ab9rf> chrisdone: it's tricky to parse that in anything.
17:00:17 <chrisdone> it's easy in regex because it does backtracking for free
17:00:48 <niteria> parsec does backtracking for free too
17:00:58 <ab9rf> i don't think that would be that hard in parsec
17:01:03 <niteria> just sprinkle some 'try's
17:01:12 <ab9rf> you might get a big-ass backtrack in places, but so what
17:01:14 <crl> why would you ever have to parse that
17:01:27 <Taslem> The SDL bindings seem to be pretty incomplete, and I'm running into issues with that.
17:01:57 <lispy> danharaj: a binary for freeglut exists
17:02:08 <chrisdone> ^username: '.+', password: '.*', age: [0-9]+$ something like is sufficient
17:02:53 <chrisdone> if we restrict the password field a bit
17:03:05 <ab9rf> chrisdone: and if the username is (', password: ')?
17:03:07 <chrisdone> because regex moves back and forward to make things fit
17:03:36 <ab9rf> chrisdone: whoever wrote that code needs to meet little bobby tables
17:03:56 <ab9rf> _never_ present, output, or use unsanitized user input
17:04:11 <chrisdone> ab9rf: if username is ', …' then it won't match username: '.+'
17:04:24 <ab9rf> chrisdone: yes, it will
17:04:26 <ab9rf> .+ matches anything
17:04:46 <niteria> I'm pretty sure language like that is ambiguous
17:04:48 <chrisdone> ab9rf: but the example details aren't so important, fact is if you want a moving slider, parsec is tricky
17:04:50 <mikeplus64> Taslem: perhaps file bug reports? (or implement what you need yourself, although that's not really a solution)
17:05:10 <ab9rf> chrisdone: still, someone pulled a bobby tables there
17:05:12 <mikeplus64> i agree, they need some love. last time i checked, they don't run on windows
17:05:39 <Taslem> Yeah, didn't work on Windows. Some weird little changes made and then they did. I found a tutorial for that.
17:05:42 <niteria> and if language is ambiguous, you don't need a parser, you need a guesser
17:06:05 <Taslem> They're plain missing functionality, though. There's no plain way to get or modify pixel lists on surfaces.
17:06:46 <chrisdone> niteria: if you have username and password restricted to be words but allow apostrophes, i don't think it's ambiguous
17:06:59 <chrisdone> (which is what it was in my case)
17:07:26 <niteria> you mean [a-zA-Z0-9']+ ?
17:07:28 <chrisdone> so ^username: '.+', password: '.*', age: [0-9]+$ actually will match just fine
17:08:46 <niteria> once you allow [a-zA-Z0-9' :,] it will be ambiguous
17:10:19 <niteria> I makes things a lot easier to escape things
17:10:24 <niteria> it*
17:10:33 <ab9rf> what if username or password contains a newline? :)
17:10:36 <chrisdone> hm, username: '', password: '', password: 'blah' ← this isn't ambiguous
17:10:43 <chrisdone> i'm trying to think of an example that is ambiguous
17:11:03 <ab9rf> what if password is ', age: 100\n :)
17:11:24 <ab9rf> admittely it's hard to imbed a newline in a password
17:11:46 <chrisdone> nah, no newlines are involved, not that newlines are any different to spaces for a given input
17:11:50 <ab9rf> but it ws possible on some systems i've used
17:12:27 <chrisdone> can you think of an example that is actually ambiguous?
17:12:45 <Sgeo> "Tcl parser" isn't a total contradiction, right?
17:12:52 <Sgeo> Actually, I just want to parse some dictionaries
17:12:53 <niteria> username: 'abc', password: '', password: 'blah' maybe
17:13:16 <chrisdone> niteria: that would parse fine because the end of input is ' and the , password: inbetween acts as an anchor
17:13:20 <ab9rf> niteria: that input rsults in an incorrect parse
17:13:42 <chrisdone> ab9rf: it shouldn't
17:13:45 <ab9rf> chrisdone: it will
17:13:52 <chrisdone> let me see
17:13:55 <ab9rf> chrisdone: it puts ', password' into the username
17:14:01 <ab9rf> because * is greedy
17:14:05 <niteria> ofc we're ignoring , age: part
17:14:14 <oio> try http://www.pythonchallenge.com/pc/def/0.html
17:15:09 <ab9rf> any time the actual password contains "', password: '", your regexp will attach the static text to the username, and elide it from the password
17:15:26 <ab9rf> you need to use .+? instead of .+ in the username match to avoid that
17:15:35 <ab9rf> nongreedy +
17:16:00 <oio> getMatches :: String -> [[String]] getMatches x = x =~ "[^A-Z][A-Z]{3}([a-z])[A-Z]{3}[^A-Z]"
17:16:07 <ab9rf> of course nongreedy + is dramatically more expensive
17:16:15 <niteria> well, I forgot about greedy behaviour of regexes
17:16:29 <niteria> but I don't like to rely on that
17:18:09 <chrisdone> match (compile "username: '(.+)', password: '(.+)'" []) "username: 'abc', password: '', password: 'blah'" []
17:18:10 <chrisdone> → Just ["username: 'abc', password: '', password: 'blah'","abc', password: '","blah"]
17:18:15 <chrisdone> that's correct
17:18:52 <chrisdone> (although i forgot the anchors, should be: "^username: '(.+)', password: '(.+)'$", but ja)
17:19:09 <niteria> well yeah, if regexes are greedy you'll always get at most one match
17:19:27 <niteria> in that sense it isn't ambiguous
17:19:30 <chrisdone> that was the point of my example. regexes backtrack until it fits
17:19:55 <chrisdone> in parsec it's possible, but trickier. i don't know a standard way to do it
17:20:04 <ab9rf> it's not ambiguous, it just yields the wrong match in that case
17:20:18 <chrisdone> ab9rf: it's the /correct/ match. what do you mean?
17:20:19 <niteria> but in CS you don't assume anything about greedines
17:20:20 <Ericson2314> I was in here early asking about existential datatypes
17:20:36 <Ericson2314> I ran into trouble when I had to instanciate Eq
17:20:46 <chrisdone> niteria: huh?
17:20:52 <Ericson2314> which doesn
17:20:54 <arkeet> Ericson2314: there's not much you can do about that.
17:21:02 <Ericson2314> well yes
17:21:09 <Ericson2314> I realized that meant my approach is wrong
17:21:20 <ab9rf> chrisdone: i'm tired of this dsicussion.  you're wrong, but i am going to do something more fun than spend the rest of the evening trying to convince you :)
17:21:31 <Ericson2314> I was doing [Type Existential] which meant I had to deal with heterogenous lists
17:21:41 <Ericson2314> and gave me my Eq problem
17:21:43 <arkeet> I suppose you could throw in some Typeable.
17:21:54 <Ericson2314> the thing is I don't want heterogenous lists!
17:21:58 <Ericson2314> thank goodness
17:22:01 <arkeet> :)
17:22:02 <carter> hey all: is there any way to have strict fields with a normal haskell record type?
17:22:14 <Ericson2314> however I do have do deal with homogenous lists of dynamics types
17:22:26 <arkeet> carter: put ! in front
17:22:53 <Ericson2314> so I changed my definition to Existential = forall a. MyClass a => [MyType a]
17:23:03 <Ericson2314> (oops forgot constructor)
17:23:20 <hpaste> carter pasted “strict records” at http://hpaste.org/83782
17:23:24 <carter> arkeet I get a syntax error when i do that ...
17:23:24 <arkeet> data X = X { foo :: !A }
17:23:28 <niteria> chrisdone: regexp defines some language, that language can be ambiguous
17:23:30 <carter> ohhh
17:23:36 <carter> foolish me
17:23:39 <carter> thanks
17:23:41 <carter> !! :)
17:23:42 <Ericson2314> I have a bunch of a functions that are defined for (myType any)
17:23:49 <Ericson2314> and [mytype any]
17:23:57 <niteria> anyway it's just easy to do in parsec, just more verbose
17:24:16 <chrisdone> ab9rf: oh hang about, you meant if the password contains that string. yeah, that would result in a wrong parse. good one
17:25:04 <Mathnerd314> is there a subset of Haskell that's guaranteed not to allocate memory?
17:25:26 <Ericson2314> I could do some sort of Existential -> (forall a. (Mytype a) -> (Mytype a)) -> Existential wrapper
17:25:32 <Ericson2314> but that would make composing harder
17:26:10 <Ericson2314> Or I could add an indidual wrapper around every function but that's a lot of boilerplate
17:26:11 <niteria> Mathnerd314: you can do a lot within runST without allocating memory I think
17:26:23 <Ericson2314> Both alternatives seem bad to me
17:26:33 <Ericson2314> for reference: https://github.com/Ericson2314/Codec.Archive.CnCMix my code fully functionall before rewrite
17:26:55 <Ericson2314> https://github.com/Ericson2314/Codec.Archive.CnCMix/tree/existential_types my first commit with me rewrite
17:26:58 <Ericson2314> my whole backend works
17:27:07 <Ericson2314> I just need to rewrite my rather big Main.hs
17:27:38 <Ericson2314> In real-word terms my problem is something like Tar
17:27:49 <Mathnerd314> niteria: I think mapM_ (const newSTRef) [1..1000] ends up allocating a lot of memory for each STRef, so probably not
17:27:54 <Ericson2314> It has Binary implemented for [File3 id]
17:28:12 <Ericson2314> where different types of ID (hash of filename used for this primitive format)
17:28:33 <ab9rf> chrisdone: yes, that's what i meant.  and actually you can't win; the parser that handles the password having that string breaks if the username contains it, and vice versa.
17:28:35 <Ericson2314> are used to dispatch between the various types of [File] serialization supported by the format
17:28:53 <chrisdone> ab9rf: yup
17:29:26 <niteria> Mathnerd314: well yeah, what's your goal?
17:29:29 <chrisdone> i convoluted the example with the double fields. oh well
17:29:45 <Mathnerd314> niteria: realtime Haskell :p
17:29:50 <`nand`> Mathnerd314: just modify the RTS to allocate an infinite amount of memory to begin with!
17:30:41 <niteria> realtime + laziness must be tricky
17:30:43 <`nand`> either way, I'm not sure what that question means in a haskell context. I thought Haskell itself doesn't even have a concept of memory (ignoring the Foreign stuff in base)
17:32:48 <chrisdone> Mathnerd314: hm. one idea: your newSTRefs are being held by the monad
17:33:35 <chrisdone> Mathnerd314: you're profiling that right?
17:33:37 <luite> chrisdone is back \o/ \o/ \o/
17:33:40 <Mathnerd314> `nand`: I write a program. I see it allocates a lot of memory in some places. What do I know /cannot/ be the cause of the allocation?
17:34:10 <chrisdone> hi luite ヽ (＾▽＾) ﾉ
17:35:10 <`nand`> Mathnerd314: I guess fundamentally every constructor application will allocate a new thunk?
17:35:16 <`nand`> can*
17:35:39 <chrisdone> most /expressions/ will be in a thunk
17:36:01 <Mathnerd314> yep - so let's, lambdas, etc. are all evil
17:36:38 <Mathnerd314> but they're optimized away 99% of the time, IIRC
17:36:42 <chrisdone> so bang patterns and strictness annotations, and unboxing are inexpendable tools
17:37:10 <chrisdone> mmm if it's obvious, yeah
17:37:12 <`nand`> strict evaluation can allocate more memory than lazy evaluation in certain cases
17:37:47 <chrisdone> Mathnerd314: paste your code? i want to see the heap profile
17:37:59 <Mathnerd314> chrisdone: I don't have any code, this is just hypothetical :p
17:38:20 <chrisdone> oh
17:39:09 <Mathnerd314> hmm, maybe I should wrtie some memory stress-tests though
17:39:37 <Mathnerd314> things like "this shouldn't result in o(n) memory usage"
17:39:51 <chrisdone> restricting to a subset helps, tho. when i have full control of operations in a real-time scenario, memory use remains constant with no gc hitches, ime
17:40:04 <luite> hm, i think i should start a business selling research quality optimization services to universities and researches, since the metric is so similar to pagerank :p
17:40:36 <Mathnerd314> luite: no, finish wolfgang first! :-)
17:40:40 <luite> oh hehe
17:40:48 <luite> meh fpcomplete is competing in this domain now
17:40:51 <chrisdone> luite: seems like there'll be a market for it! =p
17:40:53 <Mathnerd314> s/finish/release/
17:40:54 <luite> with mor moneys
17:41:07 <chrisdone> hmm yeah fp complete and wolfgang are similar
17:41:17 <Mathnerd314> open-source abandonware is 10x better than closed-source abandonware
17:41:20 <luite> yeah and they have the snoyman and lots of others
17:41:24 <chrisdone> lol
17:41:36 <chrisdone> THEY'VE ONLY GONE AND GOT THE SNOYBERG ON THEIR SIDE
17:41:42 * chrisdone shakes fist
17:42:23 <luite> Mathnerd314: i'm still working on ghcjs first, since it's kind of an important component :)
17:42:38 <Mathnerd314> but those screenshots...
17:42:47 <chrisdone> the hairest yak needs to be shaved
17:42:54 <luite> hehe yes it's quite hairy
17:43:29 <luite> though i can sell the wool
17:43:49 <chrisdone> lol yeah
17:43:50 <chrisdone> xD
17:44:21 <luite> I'm doign a mass-renaming operation now, prefixing every ghcjs variable and function with h$
17:44:31 <luite> i hope that's a good idea
17:44:36 <chrisdone> haha, exciting
17:44:53 <luite> (old situation was that some was prefixed with $hs_ and some was not prefixed)
17:45:48 <chrisdone> it'll be like in the movies when someone pulls a crystal from a rock in an old crypt and then they look around in silence waiting for booby traps to trigger
17:46:27 <luite> fay also uses some prefixing, right?
17:46:52 <chrisdone> yeah, Fay$$blah
17:47:03 <luite> oh h$ is a lot shorter :p
17:47:24 <chrisdone> ಠ_ಠ
17:47:51 <chrisdone> luite: check this! http://ircbrowse.net/nick-cloud
17:48:21 <luite> ooh i'm there
17:48:50 <danharaj> lispy: I'm not sure what to do with the freeglut binary since GLUT wants glut32.
17:48:57 <luite> not too big fortunately
17:49:45 <chrisdone> luite: yeah my irc'ing is inversely proportional to my productivity and general health =p
17:50:37 <jbu> hi all: I am having difficulty understanding the term "type operator" and "t m" in this statement without much help from the internet - help appreciated : "we will use monad transformers, which are type operators `t` that map a monad `m` to a monad `t m`"
17:50:39 <luite> Mathnerd314: i think an open source wolfgang could still be useful, but like i said, it would be hard to compete with fpcomplete's manpower, so i'm not quite sure what to do. there's a lot of overlap, but school of haskell is a bit more haskell focused, while wolfgang was supposed to be more general purpose demonstration/documentation with haskell
17:50:41 <lispy> danharaj: try renaming it?
17:51:27 <lispy> danharaj: honestly, this is part of why I think GLUT should be marked as deprecated. glfw-b is much easier to use but for whatever reason gloss needs GLUT even when configured to use the glfw-b backend
17:51:43 <chrisdone> jbu: people call them different things but it's all the same. type functions, type operators, type constructors. i prefer the last. in lamenese, it's a type that takes another type to be complete
17:52:12 <danharaj> lispy: oh, you can do that with gloss? Maybe I'll just configure it to use glfw-b and get rid of the glut dependency.
17:52:14 <luite> ghcjs seems to be a safer time investment now, since it's much wider usable
17:52:33 <lispy> danharaj: Sorry, you can tell it to  use glfw-b but it will STILL require GLUT
17:52:49 <danharaj> lispy: Right, I'll edit the source and .cabal.
17:52:53 <Ericson2314> sorry my connection crapped out
17:52:58 <danharaj> lispy: I just want to use gloss to make examples I can share with other people. If you know of another lightweight graphics library I could use to that end, it'd be nice.
17:52:59 <Ericson2314> anybody remeber my problem?
17:53:00 <chrisdone> jbu: in “m ()”, “m” is a type constructor. “m” has kind * -> *, () has kind *
17:53:17 <chrisdone> jbu: and “m ()” has kind *
17:53:23 <luite> chrisdone: well i can irc pretty well during simple programming things, like this renaming operation :)
17:53:25 <chrisdone> jbu: if it's not too confusing to talk about kinds
17:54:02 <luite> i rewrote all the ghcjs apply functions last week, which is always a source of endless bugs and frustration
17:54:18 <jbu> chrisdone, is "t m" a constructor? I'm having trouble understanding the syntax maybe?
17:54:19 <lispy> danharaj: gloss is nice it's just the usage of glut that bugs me (because glut bugs me)
17:54:38 <lispy> danharaj: IIRC gloss has some bugs when used with glfw-b
17:54:39 <luite> soon, webgloss with ghcjs!
17:54:42 <jbu> chrisdone: oh you're saying t is a function that converts m?
17:54:44 <danharaj> I don't recall ever getting glut to work for me so glut bugs me as well.
17:54:45 <chrisdone> luite: the bugs/frustration in fay is the name resolution. but i don't intend to hack on it. i would rather port it to haskell-suite  or something
17:54:51 <lispy> danharaj: I think glguy had an input duplication problem
17:55:05 <luite> chrisdone: do you have qualified imports now?
17:55:35 <danharaj> lispy: That would be fine, I want to hook up my own input/time library and just use gloss for output.
17:56:24 <luite> javascript unicode support is annoying btw
17:56:25 <chrisdone> jbu: no. to clarify: all these things being referred to are types. “t” is a type, “m” is a type, “t m” is a type. the terms “type operator”, “type function” and “type constructor” are all synonyms for the same thing: types like “t”
17:56:48 <lispy> danharaj: libraries like glfw and glut contribute relatively little to these programs. It's really jsut about doing platform indpendent input and getting an opengl context
17:56:49 <luite> if you want the same answers as ghci, you have to build large tables of upper/lower/alnum etc
17:56:56 <luite> because js is not complete
17:57:14 <lispy> danharaj: eg., you could do it in your own wrapper if you really wanted to have control over this stuff
17:57:30 <luite> hm, maybe doing surrogate pairs explicitly would do the trick
17:57:31 <lispy> danharaj: the downside is you'll eventually re-invent glfw or glut
17:57:32 <chrisdone> luite: yeah that sucks
17:57:41 <jbu> chrisdone: thanks, that helps
17:57:47 <koltar> lispy: "platform-independent input" is frustrating as hell :)
17:58:06 <luite> i need to steal more haskell test suites for ghcjs
17:58:23 <luite> the fay tests are usually the first ones i run after a big change
17:58:29 <luite> since they test fairly trivial features :)
17:58:36 <glguy> lispy: I had an input duplication problem if I tried using GLFW-b
17:58:40 <glguy> normal gloss worked fine
17:58:42 <luite> ghc test suite programs are usually more complicated, specific bugs
17:59:02 <koltar> is there a function like findIndex which returns the value found as well?
17:59:12 <chrisdone> nod, the ghc tests are results of 20+ years of battles
17:59:24 <koltar> something like (a -> Bool) -> [a] -> Maybe (Int, a)
17:59:42 <chrisdone> luite: after my test with hugs, i'm wondering if it's worth it to ressurect one of the haskell compilers that compile to c and whose runtimes are written in c
18:00:05 <luite> chrisdone: i can do real file io now through the base package System.IO etc, quite nice for tests :)
18:00:11 <luite> works on node and spidermonkey shell
18:00:21 <lispy> luite: awesome
18:00:30 <lispy> chrisdone: because you translate the C to js?
18:00:50 <chrisdone> luite: hmm yeah good point, on node i could define system.io
18:00:54 <lispy> glguy: Do you have any sense of whether the gloss author fixed that bug?
18:00:55 <chrisdone> lispy: yeah with emscripten, i mean
18:01:06 <glguy> lispy: no, I never bothered trying again
18:01:25 <glguy> To quote the great GW: Fool me once, you aren't going to fool me again
18:01:29 <luite> i talked to the emscripten authro and the ghc generated code would probably not work very well with it
18:01:33 * lispy thinks sending patches to gloss to remove the GLUT dependencies completely would be wise
18:01:59 * lispy thinks he doesn't want to do it :)
18:02:04 <chrisdone> lispy: yeah ghc as a whole is a problem for it
18:02:14 <glguy> glut is the only one that worked for me, why remove it?
18:02:41 <lispy> glguy: Presumably that glfw-b input duplication thing was just a bug in gloss.
18:02:44 <chrisdone> lispy: but maybe nhc/yhc?
18:03:06 <luite> hm someone forked jhc last week
18:03:08 <lispy> chrisdone: Sadly, I have no idea :(
18:03:28 <luite> doesn't that compile to c?
18:03:36 <lispy> chrisdone: I think nhc and yhc have both gone the way of hugs at this point
18:03:55 <chrisdone> lispy: but hugs works! http://tryhaskell.org/hugs/
18:04:13 <lispy> I think the utrechts compiler is actively developed
18:04:17 <chrisdone> it's just… interpreted and slow
18:04:35 <chrisdone> yeah UHC is, but it's not in c so can't be emscripten'd
18:04:38 <lispy> Sometime in the last year someone was making a .NET backend for the utrecht compiler
18:04:50 <luite> why don't you write an emscripten for haskell!
18:05:06 <Mathnerd314> luite: I think just building a better haddock is an interesting project, and you already have that AFAICT.
18:05:07 <luite> there's also a js backend for the utrecht compiler
18:05:18 <chrisdone> lol i read that in a “well why don't you MARRY emscripten!” tone
18:05:32 <luite> hehe
18:05:35 <chrisdone> luite: yep: http://chrisdone.com/posts/uhc-javascript
18:05:41 <danharaj> lispy: It looks like gloss uses GLUT to do text rendering.
18:06:04 <lispy> danharaj: ah, I couldn't remember why it needed glut but I thought there was something
18:06:07 <chrisdone> maybe it's worth returning to, i dunno
18:06:12 <luite> chrisdone: yeah i also did some tests last year
18:06:22 <luite> with uch
18:06:24 <luite> uhc
18:06:24 <Mathnerd314> luite: e.g. something like http://dxr.mozilla.org/mozilla-central/xpcom/io/nsStringStream.cpp would be pretty useful for GHC
18:06:28 <chrisdone> last i tried uhc it broke on a simple IORef test
18:06:31 <luite> and then i started working on ghcjs
18:06:32 <danharaj> lispy: In fact that is the only line of GLUT which can't be replaced by GLFW.
18:06:35 <lispy> danharaj: you can use my freetype2 bindings to load fonts and then piece together some code to display the glyphs. In fact, I think someone sent me some code to do that...
18:06:45 <luite> hah ghcjs does iorefs correctly!
18:06:50 <danharaj> lispy: I may have sent you that code many years ago :P
18:06:58 <luite> at least according to the tests included in the base package :)
18:07:15 <danharaj> I no longer have that code though.
18:07:42 <lispy> danharaj: http://code.atnnn.com/projects/degu/repository/entry/Degu/Font.hs
18:07:48 <lispy> http://code.atnnn.com/projects/degu/repository/entry/Degu/DrawingUtils.hs
18:07:59 <lispy> danharaj: that's the code someone sent me recently with the note that it's not thread safe
18:08:05 <lispy> But opengl stuff rarely is
18:08:25 <danharaj> lispy: ah ok. I must have not sent you my fork of the freetype2 bindings.
18:08:31 <danharaj> (Which is good. It was an abomination)
18:08:53 <lispy> danharaj: http://hackage.haskell.org/package/freetype2-0.1.1
18:09:20 <luite> Mathnerd314: oh i didn't have the crossrefs yet
18:09:32 <lispy> danharaj: I think all the pieces are there if you're willing to put them together
18:09:41 <luite> Mathnerd314: was stuck somewhere in the type and metadata extraction code when i started working on ghcjs
18:10:11 <danharaj> lispy:  I have my own opengl stuff but I wanted something other people could use so I could write sharable code against it. I'll just have to figure out glut tomorrow.
18:10:38 <danharaj> (glut really holds back gloss from being really lightweight, replacing it with freetype2 wouldn't exactly help :P)
18:11:05 <lispy> danharaj: the freetype2 binding installs the C code and builds it with ghc transparently.
18:11:17 <lispy> danharaj: So, as far as the user is concerned it's pretty lightweight
18:11:17 <danharaj> oh, that's nice.
18:12:42 <danharaj> lispy: anyway I just realized I had to rename the .dll to glut32, not just the lib. >_<
18:13:10 <lispy> I think that's in the freeglut FAQ
18:13:30 <danharaj> That assumes I was that competent.
18:14:06 <danharaj> (It baffles me that the make doesn't name the dll or libs properly to act as drop-ins for glut)
18:15:03 <koltar> danharaj: it works properly under *nix IIRC
18:16:06 <koltar> been a while since i last built freeglut, though
18:16:13 <danharaj> koltar: Yeah. Windows is kind of an impoverished platform I guess :(
18:16:35 <koltar> pretty sure "DLL hell" was coined there for a reason :P
18:16:50 <Ericson2314> In the Binary Class is there a way to get a value without incrementing the offset pointer?
18:17:28 <Ericson2314> I am writing a get method that needs to get some stuff
18:17:32 <Ericson2314> do some pattern matching
18:17:47 <Ericson2314> and dispatch to other gets on the rest of the file
18:19:36 <Mathnerd314> hmm: http://ipython.org/
18:19:54 <Mathnerd314> "designed in a language-agnostic way"
18:20:38 <luite> oh cool they got $1.15M funding
18:20:42 <luite> i should get that for wolfgang
18:21:07 <luite> i could work on the thing for a few months with that kind of monies!
18:21:10 <luite> full time
18:21:11 <luite> !
18:22:07 <Saizan> "a few"
18:22:17 <Mathnerd314> kickstarter...
18:22:57 <luite> kickstarter isn't available for non-unitedstatesians
18:23:13 <luite> only if you want to give them money
18:23:26 <Mathnerd314> there are a bunch of clones, IIRC
18:24:27 <Mathnerd314> http://www.gofundme.com/
18:24:56 <Mathnerd314> http://en.wikipedia.org/wiki/Comparison_of_crowd_funding_services
18:25:26 <luite> hm i don't believe it would work for this kind of project
18:25:55 <Mathnerd314> true, Haskell is not the kind of thing that gets a lot of funding... :p
18:25:58 <luite> needs a larger language user base
18:26:23 <luite> well fpcomplete got a few rounds of venture capital
18:27:05 <luite> dunno about other big haskell projects
18:40:34 <tac> How do you convert a ByteString encoded in UTF-8 to a Text?
18:40:57 <luite> Data.Text.Encoding
18:41:11 <tac> tyty
18:44:59 <Mathnerd314> luite: so, IIRC, you need ghcjs to work 100% to get wolfgang working the way you want, correct?
18:45:17 <Mathnerd314> because all the code gets compiled to JS before it's run?
18:45:58 <luite> Mathnerd314: that's the idea
18:46:32 <luite> though things like threads don't need to work perfectly
18:46:46 <Mathnerd314> so the ipython is a different project, basically "terminals suck, let's use a web browser instead!"
18:47:29 <Mathnerd314> i.e. they end up running server-side user code
18:47:56 <luite> Mathnerd314: yeah that's what the current wolfgang stuff does
18:48:17 <Mathnerd314> there's e.g. codepad which seems to allow that without too many issues
18:49:33 <Mathnerd314> although he has it sandboxed so much that I think it ends up running really slowly
18:49:34 <luite> oh yeah it's doable to make it safe enough
18:49:54 <luite> dunno if codepad uses geordi or some operating system stuff
18:50:41 <luite> wolfgang has selinux
18:50:56 <Mathnerd314> geordi: http://codepad.org/about
18:51:57 <luite> ah yeah geordi is relatively slow
18:52:05 <ddd112> hello
18:53:12 <ddd112> need help with a list comprehension that is type integer -> string and makes a pyramid shape
18:53:14 <ddd112> like this
18:53:16 <ddd112> x
18:53:17 <ddd112> xx
18:53:18 <ddd112> xxx
18:53:20 <ddd112> xxxx
18:53:21 <ddd112> xxxxx
18:53:35 <byorgey> ddd112: what do you have so far?
18:53:39 <ddd112> um
18:53:42 <byorgey> ddd112: you can paste it on hpaste.org
18:53:52 <ddd112> flock :: Integer -> String
18:54:05 <ddd112> flock k = concat ["sheep\n" | x <- [1..k]]
18:54:22 <ddd112> that just takes in an integer and prints out that amount of rows
18:54:24 <ddd112> with sheep
18:54:29 <byorgey> yep, looks good
18:54:46 <byorgey> ddd112: now you just have to figure out how to replace "sheep" with the right number of x's
18:55:05 <byorgey> ddd112: by the way, you can use 'unlines' instead of 'concat', that way you don't need the extra \n inside "sheep"
18:55:25 <ddd112> the homework brief said use concat, good to know though, thanks
18:55:48 <ddd112> really confused about this last question tbh'
18:56:04 <ddd112> I could do it with if statements but it says to use a list comprehension
18:56:33 <Mathnerd314> :t repeat
18:56:34 <lambdabot> a -> [a]
18:57:08 <luite> Mathnerd314: geordi is quite interesting actually (and written in haskell), i uses ptrace to trap every syscall and then allows only a few. built-in operating system sandboxing is safer and a lot faster though, but much harder to set up
18:57:26 <byorgey> ddd112: what are you confused about?
18:57:32 <Mathnerd314> luite: maybe automate it as a VM?
18:57:54 <ddd112> how to do it with a list comprehension
18:57:59 <ddd112> this is what the question is asking
18:57:59 <luite> Mathnerd314: that's hwat i did with wolfgang, a VM with some SELinux configuration for the haskell service
18:58:11 <Mathnerd314> luite: I've been hearing about http://www.vagrantup.com/, maybe write a script for that
18:58:25 <Mathnerd314> although it's ruby :-?
18:58:46 <luite> hehe i don't hate ruby (yet) :p
18:58:51 <luite> i've just never really used id
18:58:52 <luite> it
19:00:01 <ddd112> could someone help me with a haskell homework question
19:00:35 <byorgey> ddd112: do you understand how the code for 'flock' you pasted above works?
19:00:44 <ddd112> yes I do
19:01:31 <Mathnerd314> ddd112: take a look at http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#monad-comprehensions if you want to know exactly how comprehensions work
19:01:50 <Mathnerd314> (list comprehensions are a subset of monad comprehensions :-)
19:01:53 <byorgey> Mathnerd314: I'm guessing that is not very helpful at this point.
19:02:11 <byorgey> ddd112: and did you understand my statement above, "now you just have to figure out how to replace "sheep" with the right number of x's" ?
19:02:25 <byorgey> I mean did you understand what I meant, not do you understand how to accomplish it
19:02:40 <ddd112> Ohh it just clicked
19:02:56 <ddd112> So instead of sending one "sheep/n"
19:03:20 <ddd112> you send a string of sheep up to what list element you are up to?
19:03:42 <ddd112> Finding this language very confusing lol
19:03:49 <byorgey> I think you are on the right track.  What do you mean by "a string of sheep" ?
19:04:29 <ddd112> so instead of adding "Sheep" to the list by itself
19:04:38 <ddd112> you would add "sheep sheep sheep"
19:04:46 <ddd112> by concating a new string?
19:06:17 <Mathnerd314> @. pl undo concat (["sheep\n" | x <- [1..k]])
19:06:17 <lambdabot> join ([1..k] >> ["sheep\n"])
19:08:14 <ddd112> lol, I am confused
19:08:19 <ddd112> first week using this language
19:08:24 <Mathnerd314> @src join
19:08:24 <lambdabot> join x =  x >>= id
19:08:24 <ddd112> or any functional language
19:08:42 <yacks> ddd112: flock k = [ take x (repeat x) | x <- [1..k] ]
19:08:49 <yacks> is this helpful enouh
19:08:56 <yacks> enough*
19:08:57 <Mathnerd314> ddd112:  pay no attention to me, I am just playing around :p
19:09:10 <byorgey> yacks: don't solve people's homework for them.
19:09:19 <ddd112> Thankyou, let me try understand it now
19:09:30 <ddd112> so x is the head element of the list [1..k]
19:09:37 <byorgey> I guess that is not actually a solution.
19:09:51 <byorgey> ddd112: no, x will take on each value from the list [1..k] in turn
19:10:05 <ddd112> oh yep, sorry I knew that lol
19:10:18 <byorgey> > [ x * 3 | x <- [1..10] ]
19:10:19 <ddd112> Was thinking in terms of it takes the head element out
19:10:21 <lambdabot>   [3,6,9,12,15,18,21,24,27,30]
19:10:23 <yacks> aaha.. is it home qst.. looks like i missed this. btw, i understand byoegey
19:10:26 <ddd112> put's it into the new list
19:10:41 <yacks> byorgey*
19:11:27 <ddd112> sorry a basic question
19:11:29 <ddd112> again
19:11:32 <byorgey> ddd112: see if you can figure out how to create a string "sheep sheep sheep ..."  with "sheep" repeated a certain number of times
19:11:59 <ddd112> I wrote this byorgey, which is the same, just removes the new line
19:12:16 <ddd112> flock :: Integer -> String
19:12:23 <ddd112> flock k = concat $ replicate (fromIntegral k) "sheep\n"
19:12:27 <ddd112> oh and this also
19:12:35 <ddd112> a_row_of_sheep :: Integer -> String
19:12:43 <ddd112> a_row_of_sheep k = concat["sheep " | x <- [0..k-1]]
19:13:08 <Mathnerd314> @let a_row_of_sheep k = concat["sheep " | x <- [0..k-1]]
19:13:09 <lambdabot>  Defined.
19:13:20 <Mathnerd314> > a_row_of_sheep 0
19:13:23 <lambdabot>   ""
19:13:24 <Mathnerd314> > a_row_of_sheep 3
19:13:26 <lambdabot>   "sheep sheep sheep "
19:13:34 <byorgey> ddd112: looks good
19:13:50 <Mathnerd314> > putStrLn "*\n**\n***"
19:13:51 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
19:13:52 <lambdabot>    arising from a use of ...
19:14:06 <byorgey> ddd112: now, can you take your original flock function and replace "sheep" with a call to  a_row_of_sheep ?
19:14:16 <byorgey> because you don't just want one sheep, you want a whole row
19:14:30 <ddd112> ahhhh I see what you mean now
19:14:35 <ddd112> so something like this
19:15:20 <ddd112> flock k = [a_row_of_sheep (x) | x <- [1-k]]
19:16:02 <byorgey> right!
19:16:09 <ddd112> wooohoo
19:16:17 <byorgey> note you don't need the parentheses around x
19:16:17 <ddd112> thankyou so much for the help
19:16:23 <ddd112> ok
19:16:29 <byorgey> to call a function in haskell you just put a space in between the function and the argument
19:16:50 <ddd112> Oh yep, I remember now lol
19:16:55 <Axman6> > ler ros n = [s | _ <- [1..s], s <- "sheep "] in ros 3
19:16:56 <lambdabot>   <hint>:1:11: parse error on input `='
19:17:08 <byorgey> though you need parentheses if the argument is an expression like  x+1  :   a_row_of_sheep (x+1)  -- need the parens here
19:17:22 <ddd112> oh that makes sense
19:17:23 <ddd112> I see
19:17:31 <Mathnerd314> > text "*\n**\n***"
19:17:33 <lambdabot>   *
19:17:33 <lambdabot>  **
19:17:33 <lambdabot>  ***
19:17:38 <Axman6> > let ros n = [s | _ <- [1..s], s <- "sheep "] in ros 3
19:17:39 <lambdabot>   "*Exception: not a number
19:17:46 <Axman6> > let ros n = [s | _ <- [1..n], s <- "sheep "] in ros 3
19:17:48 <lambdabot>   "sheep sheep sheep "
19:17:49 <Axman6> urgh
19:18:22 <byorgey> > cycle "sheep "
19:18:24 <lambdabot>   "sheep sheep sheep sheep sheep sheep sheep sheep sheep sheep sheep sheep sh...
19:18:44 <Mathnerd314> @let flock k = [a_row_of_sheep (x) | x <- [1-k]]
19:18:46 <lambdabot>  Defined.
19:18:49 <ddd112> wow, it is quite a beautiful language
19:18:52 <ddd112> very precise
19:18:53 <Mathnerd314> > text $ flock 3
19:18:54 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
19:18:55 <lambdabot>              with actual type...
19:19:33 <Mathnerd314> @undefine
19:20:33 <ddd112> hmm another problem
19:20:37 <ddd112> ok so this works
19:20:38 <ddd112> big_flock k = concat[a_row_of_sheep x | x <- [1..k]]
19:20:40 <ddd112> except
19:20:55 <ddd112> I am not sure how to add in the /n in the right place
19:21:11 <Mathnerd314> :t (++)
19:21:13 <lambdabot> Monoid m => m -> m -> m
19:21:24 <indomitus> what do the parens after Maybe in "import Maybe ( fromMaybe )" do?
19:21:36 <Mathnerd314> @instances Monoid
19:21:37 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
19:22:13 <Mathnerd314> @src String
19:22:13 <lambdabot> type String = [Char]
19:22:47 <Mathnerd314> > "1" ++ "2"
19:22:49 <lambdabot>   "12"
19:23:26 <indomitus> nvm i got it
19:23:30 <byorgey> indomitus: that is an import list.  It states that you are only importing the function 'fromMaybe' from the 'Maybe' module.
19:23:59 <indomitus> byorgery, thanks
19:28:39 <tac> Is there a library for standard text manipulation functions (trim substr, tolower, and all those good guys you'd find in Python or Ruby?)
19:29:55 <tac> nvm
19:30:35 <danharaj> http://hackage.haskell.org/package/text-0.11.2.3
19:33:08 <tac> What is Char in GHC Haskell? Is it a Unicode charpoint?
19:33:40 <`nand`> codepoint, yes
19:33:44 <`nand`> and not just GHC Haskell
19:33:46 <`nand`> all Haskell
19:33:51 <tac> gotcha
19:33:52 <tac> ty
19:35:15 <tac> So Data.Text is preferred over String for most real programs in modern Haskell?
19:35:21 <tac> Is that an accurate statement?
19:35:26 <`nand`> Data.Text has a much more compact representation
19:35:34 <`nand`> if you're just moving around lots of texts, I'd use Text
19:35:43 <danharaj> Text is for Text.
19:35:43 <`nand`> String is mainly provided for convenience, because it's just a regular list
19:35:47 <danharaj> String is for programmer Strings.
19:36:18 <tac> Programmer strings?
19:36:21 <tac> what would be an example of one of those?
19:36:30 <danharaj> a key to a Map.
19:36:40 <tac> gotcha
19:36:42 <yacks> byorgey: is this ur blog http://byorgey.wordpress.com
19:36:47 <byorgey> yacks: yes
19:38:45 <`nand`> Text can be used as a key to a Map just fine
19:38:54 <elliott> pfft, that's clearly the _other_ byorgey
19:39:05 <`nand`> Brent Byorgey
19:39:25 <byorgey> ah yes, my evil half-twin.
19:39:33 <byorgey> don't listen to him.
19:39:34 <yacks> great... it worth to bookmark :) bookmarked it.
19:39:58 <yacks> byorgey: great... it worth to bookmark :) bookmarked it.
19:39:58 <ddd112> finally got it working =DDD
19:40:10 <ddd112> big_flock :: Integer -> String
19:40:12 <byorgey> ddd112: \o/
19:40:18 <ddd112> big_flock k = concat[concat[a_row_of_sheep (x-1),flock 1] | x <- [1..k]]
19:40:22 <ddd112> that works
19:40:23 <ddd112> =DDD
19:41:03 <ddd112> flock 1 is just = "flock/n"
19:41:17 <ddd112> but thought i would call the function to be cool
19:41:18 <ddd112> lol
19:41:32 <Mathnerd314> > text . unlines $ (concat . flip replicate "*") . [1..3]
19:41:34 <lambdabot>   *
19:41:35 <lambdabot>  **
19:41:35 <lambdabot>  ***
19:43:17 <Mathnerd314> I think that ends up being the same solution...
19:43:47 <tac> is there a way to set pragmas in your .ghci file?
19:44:32 <Mathnerd314> @google ghci pragma
19:44:34 <lambdabot> http://stackoverflow.com/questions/8638035/xtypeoperators-extension-doesnt-work-as-pragma
19:44:34 <lambdabot> Title: haskell - XTypeOperators extension doesn't work as pragma - Stack Overflow
19:45:21 <byorgey> tac: you can set LANGUAGE pragmas, but I don't know of a way to set other kinds
19:45:58 <Mathnerd314> seems like :set works, there are a lot of things you can do from :set
19:47:10 <Mathnerd314> everything "dynamic" here: http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/flag-reference.html
19:47:49 <tac> thanks guys
19:48:06 <tac> today has been a "learn some shit about actually *doing* haskell kind of day"
19:48:12 <tac> :)
19:49:01 <Mathnerd314> "doing haskell" <- haskell is purely functional, I don't think you "do" it
19:49:11 <otters> I feel like there should be a library function that converts seconds into a friendly years-months-weeks-days-hours-minutes-seconds datatype or something
19:49:17 <Mathnerd314> "explore", maybe
19:49:20 <tac> Well, in that case, I've spend all day "undoing" haskell
19:49:28 <tac> My IRC bot was written in a horribly imperative way
19:49:36 <tac> And I'm going through the painful-but-fun process of rewriting him
19:49:57 <tac> Also, applicative parsers aren't so bad
19:50:01 <Mathnerd314> @hackage friendly-time
19:50:01 <lambdabot> http://hackage.haskell.org/package/friendly-time
19:50:05 <Mathnerd314> ^ otters
19:50:17 <otters> oh christ
19:51:35 * Mathnerd314 is thinking about a time library GSOC, among other things
19:51:45 <mikeplus64> why doesn't UTCTime have an Enum instance? Day, and DiffTime do
19:54:24 <Mathnerd314> because nobody's added it yet... :p
19:59:57 <parcs> mikeplus64: convert it to POSIXTime
20:02:16 <liyanfeng> hi every body
20:03:55 <Sifr> Hm, I have a list of int's and I want to see all numbers that are 1 less than the number that follows them, is it possible to do that with a lambda expression and map
20:04:53 <Sifr> so if I have [1,2, 1, 3, 3,4,5] -> [1,2, 3, 4, 5]
20:05:26 <otters> heh
20:05:27 <otters> probably
20:06:14 <Mathnerd314> but 5 has no number following it...
20:06:23 <Sifr> ah oops
20:06:28 <Sifr> [1,2,3,4]
20:06:29 <Yeshua> > let xs = [1,2, 1, 3, 3,4,5] in  map fst $ filter (\(a,b) -> a == b-1) $ zip xs (tail xs)
20:06:30 <lambdabot>   [1,3,4]
20:07:01 <Yeshua> Well, 2 isn't 1-1
20:07:10 <Sifr> yeah oops again..
20:11:20 <Sifr> if I want \(a,b,c) such that a == b-1 and a == c-2
20:11:28 <Sifr> is it possible to do that?
20:12:28 <Sifr> oh
20:12:37 <Sifr> I can make a function that calls it self
20:14:16 <Skola> http://ircbrowse.net/browse/freenode/haskell?events_per_page=50&q=I%20love%20monoids
20:16:01 <Nisstyre-laptop> Sifr: is this what you want? http://ideone.com/9V2K8H
20:16:55 <Sifr> oh I will give this a run Nisstyre-laptop
20:17:04 <Nisstyre-laptop> or something like that
20:17:09 <Nisstyre-laptop> it may/may not be correct
20:22:54 <Yeshua> > let f n xs = map head $ filter (\a -> 1 == (length $ nub a)) $ transpose $ zipWith (\a bs -> map (\x -> x - a) bs) [0..n-1] (take n $ tails xs) in f 2 [1,2,1,3,3,4,5]
20:22:56 <lambdabot>   [1,3,4,5]
20:23:04 <Yeshua> > let f n xs = map head $ filter (\a -> 1 == (length $ nub a)) $ transpose $ zipWith (\a bs -> map (\x -> x - a) bs) [0..n-1] (take n $ tails xs) in f 3 [1,2,1,3,3,4,5]
20:23:05 <lambdabot>   [3,4,5]
20:23:14 <Yeshua> > let f n xs = map head $ filter (\a -> 1 == (length $ nub a)) $ transpose $ zipWith (\a bs -> map (\x -> x - a) bs) [0..n-1] (take n $ tails xs) in f 3 [1..10]
20:23:16 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
20:30:03 <Sifr> Yeshua: your original method worked
20:30:26 <Sifr> f $ f $ f ... $ f to get desired length of monotic consecutive sequence
20:51:03 <jbu> hi all: I'm having trouble understanding this bit of code and the signature for promote.  What is it saying and how can it know what "(t m)" means?  :  class Transformer t where    promote :: Monad m => m a -> (t m) a
20:51:03 <jbu> >   promote :: Monad m => m a -> (t m) a
20:51:05 <lambdabot>   Not in scope: `promote'
20:51:11 <jbu> whoops
20:51:39 <jbu> that should read " promote :: Monad m = > m a  - > (t m) a"
20:51:40 <otters> jbu: the "t" in there is an instance of Transformer
20:52:32 <Nisstyre-laptop> jbu: "class Transformer t" says that there is a type class Transformer with a parameter t which is an instance of Transformer (t is a type)
20:52:36 <jbu> otters: I don't understand the syntax...is it saying an instance of Transformer constructed with the m monad as a parameter?
20:52:46 <otters> right
20:53:03 <otters> they're just like normal functions, except on the type level
20:54:22 <jbu> Nisstyre-laptop: ohhh I did not know that "class transformer t" was indicating that t was a parameter
20:55:19 <Nisstyre-laptop> jbu: t is the type that will be/is an instance of the Transformer type class
20:55:45 <jbu> Nisstyre-laptop: actually I'm not sure how that makes sense because I did a ":t Transformer" and it's saying it's defined in my file, not a preexisting class
20:56:17 <jbu> Nisstyre-laptop: is Transformer defined in a haskell library?
20:56:32 <Nisstyre-laptop> it's not in the Prelude
20:56:36 <otters> :t Transformer would be information about the Transformer function, right?
20:56:37 <lambdabot> parse error on input `,'
20:56:41 <Nisstyre-laptop> also :t TypeClass won't work
20:56:46 <otters> it would have to be :i right
20:56:58 <Nisstyre-laptop> yes
20:57:01 <jbu> otters: oh, yes, that's what i did
20:58:11 <jbu> ohhh so t only defines the type of the transformer, it's not actually describing the transformer itself
20:58:32 <jbu> I think I must have a misunderstanding between "class" "data" "type" and "newtype"
20:58:41 <Nisstyre-laptop> yes
20:59:27 <Nisstyre-laptop> a data constructor is a function that gives you a data type that has been instantiated
20:59:36 <Nisstyre-laptop> although I dislike the word "instantiated"
20:59:56 <Nisstyre-laptop> a type constructor is something that lets you create new types at the type level
21:00:06 <jbu> Nisstyre-laptop: yeah...I feel like my problem is I'm brining java/c++ constructs and to haskell and trying to map everyhthing in haskell to preexisting knowledge
21:00:38 <jbu> Nisstyre-laptop: "at the type level" confuses me
21:02:47 <Sgeo> Why are IORefs called IORefs and TVars called TVars? Why not IOVars or TRefs?
21:03:16 <Nisstyre-laptop> jbu: http://ideone.com/Bjol8L
21:03:17 <c_wraith> I think their names came from different historical backgrounds
21:03:19 <Nisstyre-laptop> maybe that will help
21:03:29 <Nisstyre-laptop> also data constructors and type constructors can have the same names
21:03:39 <Nisstyre-laptop> since they don't ever appear in the same context
21:04:03 <c_wraith> IORefs and STRefs came out of the fact that they're basically what references in pre-existing languages offered.
21:04:43 <c_wraith> TVar, MVar, IVar, etc, come out of CS literature
21:05:15 <jbu> Nisstyre-laptop: this is useful but I'm still unclear what the diff. between "data" and "type" is, as you've used the words
21:05:37 <Nisstyre-laptop> jbu: well "data" means that we actually put "data" inside of our type
21:05:50 <Nisstyre-laptop> "type" means it's more abstract
21:05:56 <Sgeo> @hoogle IVar
21:05:56 <lambdabot> package ivar-simple
21:05:56 <lambdabot> Network.CGI.Protocol cgiVars :: CGIRequest -> Map String String
21:05:56 <lambdabot> Network.CGI.Monad cgiVars :: CGIRequest -> Map String String
21:05:58 <Nisstyre-laptop> it's something that could be data
21:06:05 <jbu> certainly is abstract...
21:06:25 <Nisstyre-laptop> and "type constructors" can be used to construct more complex types
21:06:33 <Nisstyre-laptop> they can have parameters (just like functions)
21:07:05 <Sgeo> o.O at IVars
21:07:18 <Sgeo> That's.... allowed? I assume it's unsafePerformIO inside
21:08:08 <Sgeo> But that does alleviate a concern I thought of with Haskell... how annoying it is that reading configuration at runtime is much more difficult than setting the values at compile-time
21:10:26 <Sgeo> Err... doesn't quite fix it, unless you used unsafePerformIO at top level
21:12:28 <Nisstyre-laptop> jbu: more complex example http://ideone.com/mnuCsT
21:14:15 <jbu> Nisstyre-laptop: I'm reading that the term "type class" kind of equates to templates in C, where they justs show an interface and "Transformer t" just says that it's dealing with any type, which we'll call t...is that somewhat accurate?
21:14:37 <Nisstyre-laptop> jbu: when we write "data Foo a b ..." a and b are the parameters to the type. When we write "data Bar = Foo Int String" we are "instantiating" Foo with two concrete types, Int and String
21:14:57 <jbu> Nisstyre-laptop: I see
21:14:58 <Nisstyre-laptop> jbu: they are more similar to what C++ was going to add to the language, "concepts"
21:15:16 <Nisstyre-laptop> so you might wanna look those up
21:15:35 <Nisstyre-laptop> there is a talk on youtube I think, where someone shows the similarities between type classes and concepts
21:15:40 <Nisstyre-laptop> geared to C++ programmers
21:17:57 <Nisstyre-laptop> jbu_: this "instantiating" business is actually used by the compiler when it figures out types for you
21:18:01 <Nisstyre-laptop> for example, take "data Foo a b = Foo a b"
21:18:06 <jbu__> Nisstyre-laptop: ah so when I do "instance TYPE_CLASS a", i'm actually instantiating the type class with a specific type?
21:18:14 <Nisstyre-laptop> now, what would the type of "foo a b = Foo (a+a) b" be?
21:18:23 <Nisstyre-laptop> jbu__: well, yeah
21:19:15 <jbu__> umm  I'm not even sure how to answer that question...it looks like you're just creating a Foo object
21:19:30 <jbu__> not sure about the diff. in capitalization of the foos
21:19:41 <Nisstyre-laptop> anyway, the compiler first assumes the type of foo is "a -> a1 -> a2" or something like that, but then it drills down into the function and looks at the return type, sees what functions you are using, and makes instances of the original type
21:19:50 <Nisstyre-laptop> or at least that's a very high level view of what it does
21:19:53 <jbu__> I think I understand that
21:22:06 <Nisstyre-laptop> jbu__: and the answer is "Num a => a -> a2 -> Foo a a2"
21:22:28 <Nisstyre-laptop> er, a1 there instead of a2
21:22:41 <jbu__> oh I see what you were doing
21:22:46 <Nisstyre-laptop> Foo a a2 = a2 in my original example
21:22:51 <Nisstyre-laptop> but I hope it's clear
21:22:58 <jbu__> the compiler just looks for something that can support the + operator and it decides it must be a Num?
21:23:10 <jbu__> most generally
21:23:17 <Nisstyre-laptop> jbu__: well, the type of + is Num a => a -> a -> a
21:23:27 <jbu__> oh ok
21:23:31 <Nisstyre-laptop> so, it "unifies" the two types
21:23:51 <Nisstyre-laptop> in the process of that, it will "instantiate" the original type
21:23:59 <Nisstyre-laptop> which is the same kind of instantiation I was talking about before
21:24:05 <Nisstyre-laptop> where you have stuff like "Maybe Int"
21:24:29 <Nisstyre-laptop> making sense?
21:24:52 <jbu__> to be honest, no, but I appreciate the effort
21:24:57 <Nisstyre-laptop> :P
21:24:58 <Nisstyre-laptop> fair enough
21:25:04 <jbu__> the webpage I'm reading right now is making sense though
21:25:05 <Nisstyre-laptop> it takes a while for it to make sense
21:25:23 <Nisstyre-laptop> which one is that?
21:25:30 <jbu__> http://en.wikibooks.org/wiki/Haskell/Type_declarations
21:26:05 <jbu__> oh sorry
21:26:06 <jbu__> not that
21:26:07 <jbu__> this: http://www.haskell.org/haskellwiki/OOP_vs_type_classes#Type_classes_is_a_sort_of_templates.2C_not_classes
21:26:48 <Nisstyre-laptop> jbu__: it's best to think of type classes as constraints
21:27:04 <Nisstyre-laptop> you can create an instance of a type class without defining any member functions
21:27:14 <jbu__> yeah, that's what was confusing me
21:27:27 <jbu__> I was like...how is it that we're implementing this class but I see no implementation?
21:27:44 <Nisstyre-laptop> yeah, the analogy between it and OOP classes is flawed imo
21:27:46 <jbu__> oh so you're saying it's a set of constraints, meaning it's like an interface
21:27:51 <Nisstyre-laptop> sort of yeah
21:27:54 <Nisstyre-laptop> that's a better analogy
21:28:03 <jbu__> a specification of what the type needs to fulfill
21:28:08 <Nisstyre-laptop> yeah
21:28:08 <jbu__> or rather implement
21:28:20 <jbu__> I still feel like I'm not using the terms "type" and "class" correctly
21:28:40 <jbu__> I will finish reading this
21:28:41 <Nisstyre-laptop> I can recommend a good paper on it that goes easy on the terminology
21:28:49 <jbu__> and come back if it still doesnt make sense
21:29:02 <jbu__> Nisstyre-laptop: sure, if it doesnt take too long to find the link
21:29:13 <jbu__> jbu__: otherwise dont worry about it
21:29:15 <Nisstyre-laptop> I think I have it on my  google docs thingy
21:30:21 <Nisstyre-laptop> jbu__: https://docs.google.com/file/d/1oTZkzY1MiQwUAdoW3E5Fsb7p6AYRU4ph9BrR17TC-Qrzh-6vHUS6mRatgZhL/edit?usp=sharing
21:30:59 <jbu__> Nisstyre-laptop: thx again
21:31:13 <Nisstyre-laptop> actually that paper might be too heavy for you still
21:32:48 <jbu__> Nisstyre-laptop: oh, I should have picked up that in "Transformer t" t is not capitalized and is therefore just a variable to mean some other type
21:33:38 <Nisstyre-laptop> yeah
21:52:46 <pdxleif> What would be some cool topics for the next PDXFunc?  What's hot these days?
21:56:03 <gar-asdf> ada is the new best thing in functional programming
21:59:21 <pdxleif> I think I prefer the variant spelled with an extra "g".
22:00:11 <pdxleif> Maybe we could just talk about "lambdas" or whatever.  I hear those are supposed to be cool in FP.
22:09:03 * hackagebot lagrangian 0.4.0.1 - Solve Lagrange multiplier problems  http://hackage.haskell.org/package/lagrangian-0.4.0.1 (JonathanFischoff)
22:34:28 <gar-asdf> @slap gar-asdf
22:34:29 * lambdabot orders her trained monkeys to punch gar-asdf
22:34:44 <gar-asdf> @slap gar-asdf
22:34:44 * lambdabot pushes gar-asdf from his chair
22:34:48 <gar-asdf> @slap gar-asdf
22:34:49 * lambdabot is overcome by a sudden desire to hurt gar-asdf
22:34:52 <gar-asdf> @slap gar-asdf
22:34:52 <lambdabot> why on earth would I slap gar-asdf?
22:36:48 <gar-asdf> @pf (\stuff morestuff -> zip $ stuff $ scanl stuff morestuff)
22:36:48 <lambdabot> Maybe you meant: bf pl
22:37:06 <gar-asdf> I am fail
22:37:39 <cmears> point-less, not point-free
22:37:47 <TravisD> wait, lambdabot bot is a woman?
22:38:05 <gar-asdf> @pl (\stuff morestuff -> zip $ stuff $ scanl stuff morestuff)
22:38:06 <lambdabot> (zip .) . ap (.) scanl
22:38:21 <TravisD> I always assumed asexuality
22:38:41 <gar-asdf> female pronouns though
22:39:01 <gar-asdf> also someone drew her a long time ago
22:39:37 <TravisD> link?
22:40:41 <gar-asdf> its in the wiki
22:40:52 <TravisD> heh
22:48:10 <Mortchek> Using Parsec, why is it that if I have a source text whose only declaration is foo = char '(' that I get "No instance for (Stream s0 m0 Char)" when trying to load it?
22:48:47 <Mortchek> -that
22:49:02 <ZFox> Hmm
22:49:52 <Mortchek> It works fine if I introduce main = print $ parse foo "" "(".
22:50:19 <Mortchek> I think the use of parse is somehow limiting its type, but I don't know why.
22:50:41 <ZFox> /home/archey/haskell/HackerHaven/dist/build/libHStokens-0.1.0.0.a(Token.o): In function `s5S7_info':
22:50:44 <ZFox> (.text+0xe49): undefined reference to `tokenszm0zi1zi0zi0_DataziTimeziZZFox_zdwa1_info'
22:50:49 <ZFox> Anyone have any idea what would call that ?
22:50:53 <ZFox> cause *
22:52:18 <lispy> preflex: zdecode tokenszm0zi1zi0zi0_DataziTimeziZZFox_zdwa1_info
22:52:24 <lispy> preflex: help
22:52:24 <preflex>  try 'help help' or see 'list' for available commands
22:52:27 <lispy> preflex: list
22:52:27 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; excuses: [excuse]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version];
22:52:28 <preflex>  XSeen: [xseen]; ZCode: [zdec, zenc]
22:52:35 <lispy> preflex: zdec tokenszm0zi1zi0zi0_DataziTimeziZZFox_zdwa1_info
22:52:36 <preflex>  tokens-0.1.0.0_Data.Time.ZFox_$wa1_info
22:52:43 <lispy> ZFox: does that help?
22:52:49 <ZFox> Heh
22:53:04 <cmears> Mortchek, perhaps calling parse fixes the inner monad's type (to Identity)?
22:53:07 <ZFox> Lets se
22:53:08 <ZFox> see 8
22:53:50 <lispy> ZFox: to be honest, something strange has happened. Normally you shouldn't see linker errors.
22:54:04 <ZFox> Yea
22:54:19 <ZFox> Didn't have this before I switched to using cabal for this little project
22:54:37 <TravisD> Is there a reason that hmatrix's Vector is not an instance of Functor?
22:55:29 <ZFox> And I don't see anything that cabal would have broken so I guess it has something to do with me moving files around but still even then.. The libraries compile perfecly just not when using them.
22:55:44 <arkeet> TravisD: because the elements must be Storable
22:55:52 <TravisD> ah
22:56:46 <ZFox> lispy: Could this be related to the use of undefined ?
22:57:07 <mgsloan> ZFox: Just a random guess, but maybe it's using an old / broken version of the time library?  So when you use ghc directly, it's the latest version.  Do you have upper bounds in your cabal file?
22:57:19 <Mortchek> cmears, I think you're right about that - parse accepts ParserT s () Identity a and char '(' is ParserT s u m Char. Why does just using it fix it though?
22:57:49 <ZFox> mgsloan: I just ran cabal init and started editing my cabal file
22:57:56 <ZFox> So no
22:58:10 <lispy> ZFox: post your cabal file to hpaste?
22:58:19 <kallisti1> I would like to use the plugins library to dynamically load modules. I would like to simply specify the module and have it loaded, but plugins reqires that I either have a) a filepath to the .o b) a package name and a module name
22:58:23 <lispy> ZFox: try using --verobse=3 when you build?
22:58:41 <ZFox>    35     time        == 1.4.*
22:58:44 <ZFox>    time-1.4.0.1
22:58:51 <kallisti1> is there a way I can either a) translate a module name into its path name on disk  b) find a "default" package for a given module name
22:59:14 <ZFox> Holly crap verbose :D
22:59:37 <ZFox> lispy: http://ix.io/4G4
23:00:15 <lispy> ZFox: examples/TokenD.hs:35:20: Not in scope: type constructor or class `Token'
23:00:19 <ZFox> http://ix.io/4G5
23:00:42 <TravisD> So this is actually something I've been wondering about - we can get a subcategory of Hask for each type class and there's nothing wrong with defining functors from that category to another, right? So this "not a functor because it requires _____" is a Haskell implementation detail?
23:01:00 <ZFox> lispy: Whoops that was a typo when commenting parts of imports.
23:01:07 <ZFox> http://ix.io/4G6
23:01:50 <cmears> Mortchek, hmm, that I don't know
23:02:45 <ZFox> I take it that ghc still uses haskell to c and gcc ?
23:02:54 * ZFox thought that was gone unless you had .hsc files..
23:03:20 <Mortchek> I guess I either need to use them or give them restrictive signatures. Well, thanks. Bedtime~
23:03:50 <lispy> ZFox: it's feeding gcc a .s file and then .o files
23:03:52 <elliott> ghc doesn't compile to C by default
23:04:00 <lispy> ZFox: so it's not using it to compile C
23:04:07 <ZFox> Ah
23:04:16 <ZFox> Just using it as a linker/wrapper
23:05:41 <ZFox> lispy: Any suggestions?
23:06:01 <lispy> ZFox: I can't tell what is wrong but here are some things I would try (maybe you alread have): a) rm -rf dist; b) Cabal-version: >= 1.16; c) removing everything except the library section and slowly adding stuff back
23:06:33 <ZFox> diff with rm -r dist and cabal clean?
23:06:45 <lispy> ZFox: oh, I think I know what is wrong
23:06:46 <ZFox> no
23:06:50 <ZFox> What?
23:07:06 <lispy> It's trying to find Data.Time.ZFox but that's not listed anywhere in the .cabal
23:07:09 * ZFox needs to clean up the build-depends btw
23:07:12 <ZFox> Ah
23:07:55 <ZFox> Yay
23:07:56 <lispy> I think that library section finds it by chasing dependencies (look in the verbose log)
23:08:06 <ZFox> Errors.. I'm happy for once to see them because they aren't linker errors :D
23:08:07 <lispy> but when you get to the executable section cabal no longer knows about it
23:08:41 <ZFox> Thanks lispy and yea it all made sense once you mentioned data.time.zfox and cabal :P
23:09:20 * ZFox added it to the other modules because it shouldn't be exposed.
23:10:21 <ZFox> Or atleast now doesn't need to be exposed.. I may export it through Data.Token if I need it anyhow.
23:10:42 <lispy> ZFox: cool. Glad we could get it diagnosed.
23:11:45 <ZFox> lispy: ^_^ Thanks again, and atleast it's something to refference if either of us see such linker issues again. :D
23:12:43 <ZFox> Is there any way without going one by one eliminating til errors to figure out which modules are required per library/execuitable ?
23:13:05 <ZFox> like cabal init but.. smarter as I've got a more complex cabal file than cabal creates.
23:16:00 <lispy> ZFox: I recommend listing everything in the library
23:20:47 <ZFox> the library doesn't depend on network
23:20:57 <ZFox> And other things
23:21:33 <ZFox> The libraries are in fact pure except the gen which makes two calls. randomrio and getcurrenttime
23:22:48 <ZFox> I could but for timming reasons I won't unless someone can recommend a better way use the time to get my 0-62^16 Integer
23:23:39 <ZFox> lispy:
23:27:58 <lispy> ZFox: sorry, I don't understand the question
23:28:29 <lispy> ZFox: My suggestion is to list all the modules that your library has in the library section.
23:28:40 <lispy> ZFox: for executables it's less important, as long as it compiles.
23:28:53 <ZFox> Securly is there any way using the time to get an integer between 0 and 62^16 (taking out one io call, down to just the 1)
23:28:56 <ZFox> eh nvm
23:29:02 <lispy> ZFox: but you don't need to list modules from other libraries
23:29:04 <ZFox> I'm using networking I'm gonna have more IO still
23:30:08 * ZFox patches his TokenC first.... :/
23:40:26 * ZFox has stripped down his cabal file yay
23:41:14 * ZFox wishes it were easy to get a cabal file for installing an xmonad configuration.. Acturally... It should be just could get a little messy?
23:54:05 * hackagebot yesod-json 1.1.2.2 - Generate content for Yesod using the aeson package.  http://hackage.haskell.org/package/yesod-json-1.1.2.2 (MichaelSnoyman)
