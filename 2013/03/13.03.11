00:02:02 <pharaun> what is the recommended command-line arg parser these days?
00:02:05 <pharaun> still CmdArg?
00:03:53 <edwardk> dcoutts: is there a reason why when i use a wildcard in cabal for data files it uses a non-greedy notion of * ?  strangely data/dimacs/blocksworld/bw_large.b.cnf isn't matched by data/dimacs/blocksworld/*.cnf in data-files
00:11:38 <mete__> hello, I have a question. I want to create a function which takes only a string. The funciton needs to use a stack during its process. Where and how should I define that stack?
00:12:24 <c_wraith> mete__: the standard approach is to define a second function that takes the stack as an argument, and call the second from the first.
00:12:38 <c_wraith> mete__: often times, the second function is declared in a where block attached to the first
00:12:56 <c_wraith> mete__: though that isn't necessary, and can make debugging from ghci tougher
00:14:58 <mete__> @c_wraith my function calls itself recursively is what you said still possible?
00:14:58 <lambdabot> Unknown command, try @list
00:15:31 <c_wraith> please don't use @ prefixes in IRC. It messes up the bot.
00:15:40 <arkeet> pharaun: optparse-applicative is good
00:15:49 <c_wraith> mete__: anyway, the usual approach is for the helper to be recursive, not the thing that calls it
00:17:01 <mete__> sorry for using that character, I didn't know that, I didn't understand what you said the last time, can you explain it a little bit?
00:18:35 <pharaun> arkeet: looking at it now to see how it stacks up vs cmdargs
00:23:44 <pharaun> arkeet: whoa this looks nice
00:28:04 <adnap> Has anyone made Vectors which use modular arithmatic and where the modulus is at the type level?
00:28:10 <adnap> *arithmetic
00:31:28 <Ralith> type-level stuff in haskell usually seems to be pretty hacky
00:37:57 <adnap> Is this channel usually dead now? There is something I want to talk about
00:39:12 <supki> adnap: I don't know what does it mean for Vector to use modular arithmetic but you probably want to read about reflection
00:39:36 <supki> @hackage reflection
00:39:36 <lambdabot> http://hackage.haskell.org/package/reflection
00:39:43 <supki> it has link to the paper
00:40:16 <Ericson2314> I've always wondered, is a (dynamically) unneeded varible in the IO monad still bound for it's potential monadic side affect? or does lazy eval prevent this from happening
00:40:46 <adnap> supki: i.e. (0, 7) == (3, 1) mod 3
00:41:09 <adnap> supki: Think of a field that wraps around on itself
00:43:21 <adnap> I'm starting to think this makes no sense
00:44:47 <Ericson2314> anybody know the answer?
00:45:50 <nejucomo> Ericson2314: It might help to clarify IO is a (special) type; it's Monad instance isn't particularly important for your question.
00:46:16 <nejucomo> I'm not quite clear on your question though.
00:47:32 <nejucomo> Consider this program: main = [getChar, getChar] ! 1
00:47:54 <nejucomo> Oh, I meant (!!)
00:48:16 <nejucomo> Only a single getChar (the second one) will actually execute.
00:48:22 <nejucomo> Does that answer your question?
00:49:40 <nejucomo> I imagine that (IO x) is like a 0 argument first order procedure in other languages; it can be stored or passed around.
00:50:02 <totimkopf> why doesn't Prelude> sum $ filter (> 10)  $ map (*2) [2..10]  work? :S
00:50:05 <nejucomo> Invoking the procedure is a special operation that can't be expressed directly in haskell.
00:50:17 <nejucomo> Ericson2314: Let me know if that helps or confuses.
00:50:18 <adnap> So, I think of Map a b as a -> Maybe b, but... I don't know if one can define a Data.Map as a function. What if I have a proper Data.Map A (B, C) and I want to make a Data.Map A B which just throws away C?
00:50:18 <totimkopf> this is actually a verbatim example from LYAH
00:50:31 <totimkopf> or am I omitting something?
00:50:47 <statusfailed> totimkopf: what's it supposed to do ?
00:50:48 <statusfailed> and what doesn't it do?
00:50:55 <statusfailed> I get "80" in ghci
00:50:56 <totimkopf> return 80
00:50:56 <adnap> > sum $ filter (> 10)  $ map (*2) [2..10]
00:50:58 <lambdabot>   80
00:51:15 <totimkopf> relude> sum $ filter (> 10)  $ map (*2) [2..10]
00:51:16 <totimkopf> <interactive>:44:7:
00:51:16 <totimkopf>     Couldn't match expected type `[t10 -> t0]'
00:51:16 <totimkopf>                 with actual type `[a0] -> [a0]'
00:51:16 <totimkopf>     In the return type of a call of `filter'
00:51:16 <totimkopf>     Probable cause: `filter' is applied to too few arguments
00:51:17 <statusfailed> totimkopf: what's it do for you?
00:51:18 <totimkopf>     In the second argument of `($)', namely `filter (> 10)'
00:51:20 <totimkopf>     In the first argument of `($)', namely `sum $ filter (> 10)'
00:51:27 <totimkopf> (sorry for spam!)
00:52:02 <statusfailed> totimkopf: are you typing relude> ?
00:52:11 <totimkopf> no :)
00:52:21 <statusfailed> what are you typing, and what are you getting?
00:52:51 <Sgeo> :t reify
00:52:52 <lambdabot> Not in scope: `reify'
00:52:53 <nejucomo> It seems like the filter in scope is not the standard prelude filter.
00:53:02 <Sgeo> :t filter
00:53:03 <lambdabot> (a -> Bool) -> [a] -> [a]
00:53:08 <nejucomo> totimkopf: Try :t filter
00:53:25 <nejucomo> (-or maybe one of those other identifiers is shadowing the Prelude?)
00:53:35 <statusfailed> ok I totally misunderstood that paste :p
00:53:37 <totimkopf> strange with ghci in verbose mode it works
00:53:42 <totimkopf> but when I switch back to non-verbose...
00:54:02 <totimkopf> wow, now it works, I swear it wasn't working before, though
00:54:09 <statusfailed> totimkopf: we've all been there :D
00:54:54 <nejucomo> totimkopf: If you had shadowed any of those symbols, then later reloaded the prelude to remove the shadowing binding, that might explain the behavioral change.
00:55:08 <Sgeo> > fmap id (M.fromList [])
00:55:10 <totimkopf> http://pastebin.com/J5XE7s24
00:55:10 <lambdabot>   fromList []
00:55:10 <nejucomo> Did you do something like :mod Prelude
00:55:15 <mauke> The paste J5XE7s24 has been copied to http://hpaste.org/83840
00:55:33 <adnap> Does Data.Map provide O(1) access?
00:55:45 <Sgeo> > fmap reverse (M.fromList [("Hi", "Hello"), ("Bye", "Goodbye")])
00:55:47 <lambdabot>   fromList [("Bye","eybdooG"),("Hi","olleH")]
00:56:18 <Sgeo> Wasn't entirely expecting it to be a Functor due to the Ord stuff
00:56:26 <adnap> Oh, looks like it's O(log n)
00:56:33 <totimkopf> nejucomo, shadowed? :S
00:56:40 <totimkopf> I'm sorry I don't follow
00:56:40 <nejucomo> adnap: All of the api documentation gives the bounds here: http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map.html
00:57:23 <nejucomo> totimkopf: If you say: let map = "bananas!", then leave the sesion open and forget, then later try: map (*2) [2..42]
00:57:42 <adnap> Okay, I want to recursively explore a 2-D grid and I need to keep track of where I have already traveled to. I was thinking about putting the 2-D points in a Map, but can I put them in something with O(1) access?
00:57:56 <nejucomo> -then the Prelude.map is shadowed with the bananas binding.
00:58:40 <nejucomo> adnap: Maybe Data.Array ?
00:58:51 <nejucomo> -or maybe you can be clever about your recursion.
00:58:58 <totimkopf> ahaaa, now I see, thank you very much!
00:59:40 <nejucomo> adnap: I meant "perhaps" Data.Array, not the Maybe type.  ;-)
00:59:57 <adnap> nejucomo: I thought so
01:00:38 <nejucomo> sleepy time.  g'night.
01:10:05 <indomitus> has anyone gotten RandomDotOrg from hack age to install?
01:12:43 <Sgeo> It uses a depreciated package
01:13:08 <indomitus> Network.HTTP.Simple
01:13:11 <indomitus> ?
01:13:17 <Sgeo> http://hackage.haskell.org/package/HTTP-Simple
01:13:24 <Sgeo> "This package is obsolete: use HTTP instead.
01:13:24 <Sgeo> DEPRECATED Enable simple wrappers to Network.HTTP
01:13:24 <Sgeo> "
01:13:33 <Sgeo> And with that, I must sleep
01:13:41 <indomitus> hmmm, is this something that would be difficult to update?
01:15:07 <Ericson2314> nejucomo oh sorry
01:16:06 <Ericson2314> I mean: do x <- read "FilePath"; when b printStrLn x
01:16:11 <Ericson2314> is x read regardless?
01:16:14 <Ericson2314> of b
01:16:33 <Ericson2314> whoops, just a bit too late
01:16:36 <Ericson2314> anybody else know?
01:17:08 <Sgeo> Most of the time yes
01:17:16 <Sgeo> Unless you're doing lazy I/O
01:17:24 <Sgeo> :t unsafeInterleaveIO
01:17:25 <lambdabot> Not in scope: `unsafeInterleaveIO'
01:17:30 <Ericson2314> is lazy IO a different Monad?
01:17:35 <Sgeo> unsafeInterleaveIO :: IO a -> IO a
01:17:58 <Sgeo> No. It just takes an IO a and turns it into one where the action will only execute when the resulting value is needed
01:18:02 <Sgeo> getContents uses it, for example
01:18:10 <Sgeo> But generally it's recommended against.
01:18:47 <Ericson2314> ok
01:18:51 <Ericson2314> I have too booleans
01:19:02 <Ericson2314> both attatched to when statements
01:19:15 <Ericson2314> I need to read 1 file when either of them is true
01:19:41 <Ericson2314> I am only reading, is it safe?
01:19:55 <Sgeo> Put the read in the action you're passing to when
01:20:03 <Sgeo> when (a || b) (read "Foobar")
01:20:11 <Sgeo> Wait, no
01:20:12 <Sgeo> :t when
01:20:13 <lambdabot> Monad m => Bool -> m () -> m ()
01:20:31 <Sgeo> Maybe if
01:20:35 <Sgeo> if (a || b)
01:20:38 <Ericson2314> the booleans are not monadic
01:20:43 <Sgeo>     then do
01:20:49 <Ericson2314> probly some trickery on cmdlib's part
01:20:49 <Sgeo>     x <- read
01:20:51 <Sgeo>     blah
01:20:55 <Sgeo> erm
01:21:03 <Ericson2314> (they corospound to command line flags)
01:21:07 <Sgeo> I shouldn't type long code into the channel
01:21:56 <Sgeo> x <- foo -- foo :: m a; x :: a
01:22:09 <Ericson2314> well it's highly unlikely anybody would run the command with both of them disabled
01:22:15 <Ericson2314> then it does nothing
01:22:22 <Sgeo> I need to go to sleep
01:22:25 <Ericson2314> sure
01:22:28 <Ericson2314> thanks for respounding
01:22:33 <Sgeo> yw
01:29:40 <statusfailed> Is there a fixed point package on Hackage?
01:29:48 <statusfailed> wait. my google fu failed
01:29:50 <statusfailed> nevermind.
01:36:05 <ofan> Hi, using conduits, is there any way to implement Server and Client that can both send and receive data, just like ones in Pipes?
01:36:45 <skp___> hey
01:36:53 <skp___> I wonder something
01:36:58 <skp___> the Functor class
01:37:01 <skp___> it owns fmap
01:37:15 <skp___> but it’s actually more for endofunctor
01:37:17 <skp___> isn’t it?
01:37:23 <skp___> true functors would be
01:37:31 <skp___> class TrueFunctor f where   truefmap :: (TrueFunctor g) => (a -> b) -> f a -> g b
01:37:34 <skp___> right?
01:38:43 <Ralith> how would you implement that?
01:38:52 <skp___> no idea
01:38:52 <ZFox> ofan: What are you asking *exactly*?
01:38:54 <Hermit> skp___: then how are you supposed to make fmap work?
01:38:57 <Ralith> it seems like needing to return a g b for arbitrary g would be insurmountable
01:39:02 <skp___> it’s a supposition
01:39:22 <skp___> I just wanna be sure that fmap is endo
01:39:25 <ZFox> ofan: client/server as in... Do you want them to talk to-way like a dual pipe? Or just one way?
01:39:32 <skp___> and I’m actually pretty sure
01:39:35 <ZFox> err
01:39:37 <skp___> since it’s f a ->f b
01:39:39 <`ramses> the instance would have a fixed g then? Doesn't seem too useful
01:39:42 <ZFox> can both.. Just a socket?
01:39:42 <statusfailed> skp___: I think you're right
01:39:47 <ZFox> ofan: Network
01:39:56 <statusfailed> skp___: it's endofunctors in Hask category or something, right?
01:40:08 <skp___> yep
01:40:14 <ZFox> ofan: You may be after a UnixSocket? (Often mistaken for pipes/fifos)
01:40:26 <skp___> in math, a functor transports a categorie into another
01:40:37 <skp___> so the correct definition would be f a -> g b
01:40:41 <skp___> if f = g
01:40:45 <skp___> that it’s endofunctors
01:40:45 <ofan> ZFox: yes a dual pipe
01:40:56 <statusfailed> skp___: wait, what's a natural transformation again then?
01:41:00 <ZFox> ofan: Define a dual pipe
01:41:08 <`ramses> skp___: wouldn't you want g to be an extra parameter to the typeclass then?
01:41:14 <ZFox> ofan: (Not the correct term but I used it :P)
01:41:18 <flake> m
01:41:30 <skp___> statusfailed: huh, dunno
01:41:33 <skp___> I’ve forgotten
01:41:36 <ZFox> Datagram is the correct term btw
01:41:44 <statusfailed> I think  natural transformation is a mapping from one functor to another?
01:41:45 <skp___> `ramses: what typeclass?
01:41:55 <`ramses> skp___: the TrueFunctor class
01:41:58 <skp___> yeah statusfailed
01:42:02 <skp___> `ramses: hmm
01:42:07 <skp___> why?
01:42:11 <flake> Anyone know what I should do if I need a zip with a signature of [a] -> [a] -> [(a,a)]   ??
01:42:20 <ZFox> ofan: Talk more often when you ask for help
01:42:31 <ofan> ZFox: a full-duplex pipe more correctly
01:42:35 <plat0> flake: use zip
01:42:38 <skp___> flake: zip
01:42:41 <`ramses> skp___: because otherwise there can be at most one g on which an instance for f can mao
01:42:43 <skp___> :t zip
01:42:43 <ZFox> ofan: Both are valid
01:42:44 <lambdabot> [a] -> [b] -> [(a, b)]
01:42:46 <`ramses> s/mao/map
01:42:53 <statusfailed> skp___: I seem to remember (and I could very well be wrong here) that it's not possible to write a "true" functor in Haskell?
01:43:02 <ZFox> ofan: That's the fancy way to say Datagram :P
01:43:10 <skp___> maybe statusfailed
01:43:12 <statusfailed> but take that with an entire mountain of salt
01:43:20 <statusfailed> because I have nothing to back that up except poor memory
01:43:23 <skp___> it’s just I’m testing my math skills
01:43:24 <flake> palt0: The issue is that I want to chain it a function which accepts [(a,a)] not [(a,b)]
01:43:28 <ZFox> ofan: Do you want to talk directly with types and all?
01:43:34 <ofan> ZFox: yeah, but how to imeplement, I created a Conduit but await is of type Consumer
01:43:34 <merijn> flake: a and b can be the same
01:43:41 <skp___> zipWith then
01:43:48 <plat0> flake: That's fine.  [(a, b)] means that a and b *can* be different, not that they are
01:43:56 <merijn> :t zip "abcd" "defg"
01:43:57 <lambdabot> [(Char, Char)]
01:44:14 <merijn> :t zip `asAppliedTo` "abc"
01:44:15 <skp___> no it won’t work if he keeps abstraction
01:44:15 <lambdabot> [Char] -> [b] -> [(Char, b)]
01:44:49 <ZFox> ofan: Use Network.Socket.ByteString, Data.Binary and encode your custom types etc to binary and send over the network.
01:44:55 <merijn> flake: Different type variables meas the choice of a and b are unrelated to eachother, it doesn't mean you're not allowed to pick the same type for both, though
01:45:02 <flake> plat0:  imagine this  funct = (\(x,y) -> [x,y]) . zip
01:45:06 <plat0> :t asAppliedTo
01:45:07 <lambdabot> (t -> b) -> t -> t -> b
01:45:09 <ZFox> Something I am working on in similar context.. http://archeydevil.hackerhaven.net/darcs/Tokens/
01:45:15 <ofan> ZFox: I name it as 'Tunnel' which awaits for data from downstream and yield data when there's input from other end of the tunnel, but await is of type Consumer not a Conduit
01:45:18 <ZFox> ofan: ^ Token server that I am working
01:45:19 <ZFox> on
01:45:29 <indomitus> whats the best alternative to httpGet?
01:45:34 <flake> plat0: I have a context which assumes that a and b are the same type.
01:45:42 <merijn> flake: That's fine
01:45:50 <ZFox> ofan: What is the client going to send? Are both the client and server written in haskell?
01:45:58 <plat0> :t (\(x,y) -> [x,y]) . zip
01:46:00 <lambdabot>     Couldn't match expected type `(t0, t0)'
01:46:00 <lambdabot>                 with actual type `[b0] -> [(a0, b0)]'
01:46:00 <lambdabot>     Expected type: [a0] -> (t0, t0)
01:46:20 <plat0> What are you trying to do exactly?
01:46:29 <plat0> Did you want
01:46:32 <merijn> :t let foo x y = [x,y] in map (curry foo) . zip
01:46:33 <plat0> :t (\(x,y) -> [x,y]) . zipWith
01:46:33 <lambdabot>     Couldn't match expected type `[a0]'
01:46:33 <lambdabot>                 with actual type `[b0] -> [(a1, b0)]'
01:46:34 <lambdabot>     Expected type: [a1] -> [a0]
01:46:35 <lambdabot>     Couldn't match expected type `(t0, t0)'
01:46:35 <lambdabot>                 with actual type `[a0] -> [b0] -> [c0]'
01:46:35 <lambdabot>     Expected type: (a0 -> b0 -> c0) -> (t0, t0)
01:46:44 <skp___> you mean zipWith maybe
01:46:54 <skp___> yeah, nvm
01:46:59 <plat0> I guess I mean
01:47:01 <merijn> flake: Can you pastebin an example off what you're trying to do? I don't really see a problem?
01:47:02 <plat0> :t (\x y -> [x,y]) . zipWith
01:47:04 <lambdabot> (a -> b -> c) -> ([a] -> [b] -> [c]) -> [[a] -> [b] -> [c]]
01:47:23 <ZFox> Everyone using lambdabot right now.... TEST IN GHC FIRST!
01:47:27 <ZFox> GHCI *
01:47:38 <merijn> ZFox: Sounds like work...
01:47:50 <ZFox> merijn: For me it's M-g
01:48:02 <ZFox> (XMonad, named scratchpad ghci) XD
01:48:10 <skp___> :t zipWith $ \x y -> (x,y)
01:48:12 <lambdabot> [t] -> [t1] -> [(t, t1)]
01:48:19 <skp___> it’s the same issue here
01:48:23 <ofan> ZFox: It has nothing to do with network, server can both send and receive String to the client, and client can do the same as well.
01:48:41 <ZFox> ofan: What do you want to do exactly?
01:48:45 <ZFox> How do you want to use it?
01:48:57 <ZFox> This server/client, is it tcp or a unix socket file?
01:49:03 <ZFox> (Eitherway still Network)
01:49:49 <ofan> let's say, I want to communicate with a forked process
01:50:00 <ZFox> That's not client/server
01:50:16 <ZFox> ofan: forked as in.. exec some other program
01:50:17 <merijn> ZFox: Why not?
01:50:20 <flake> http://hpaste.org/83841
01:50:22 <ofan> yeah, but they are abstractly the same
01:50:48 <ofan> and Pipes use 'Server' and 'Client' as well
01:50:50 <flake> merjin: http://hpaste.org/83841
01:51:03 <flake> merijn: http://hpaste.org/83841
01:51:11 <merijn> flake: The problem is that you're only giving one argument to zip, otherwise that should work
01:51:25 <ZFox> merijn: The following shell isn't a client/server.. exec 3<>; exec 4<>; proga <&3 >&4; progb <&4 >&3;
01:51:30 <ZFox> (Dual pipe)
01:51:45 <ZFox> (May be a typo there.. I also don't use exec for such often at all)
01:52:15 <merijn> ZFox: forked process communicating could easily be client server, the fact that you can think of an example where that's not the case is irrelevant
01:52:25 <yitz> ZFox: ok, whatever, we understood what ofan means.
01:52:34 <merijn> flake: composition with . only removes one argument
01:52:52 <ZFox> yitz: true
01:52:59 <merijn> The result of applying your function would be: "myfunction [1..] [5..]" -> "map (\(x,y) -> [x,y]) . zip
01:53:04 <merijn> eh, damn copy paste
01:53:27 <ZFox> You need the inout and output of the process
01:53:35 <merijn> "((map (\(x,y) -> [x,y]) . zip) [1..]) [5..])"
01:53:37 <ZFox> So .. You'll need a socket to the process
01:53:44 <flake> merijn: (map (\(x,y) -> [x,y]) . zip) $ ["a" "b"] ["1" "2"]
01:53:49 * ZFox is unsure how
01:54:01 <merijn> flake: No, let's look at the type of .
01:54:05 <merijn> :t (Prelude..)
01:54:05 <mauke> flake: ["a" "b"] ["1" "2"] is double malformed
01:54:06 <lambdabot> (b -> c) -> (a -> b) -> a -> c
01:54:15 <mauke> forget about map/zip
01:54:58 <ZFox> ofan: I recommend using a socket file :)
01:55:11 <merijn> flake: f . g $ x = f (g x)
01:55:13 <ZFox> (Kinda like two fifo's)
01:55:22 <yitz> > map (\(x,y) -> [x,y]) $ zip ["a" "b"] ["1" "2"]
01:55:24 <lambdabot>   The function `"a"' is applied to one argument,
01:55:24 <lambdabot>  but its type `[GHC.Types.Ch...
01:55:33 <yitz> > map (\(x,y) -> [x,y]) $ zip ["a", "b"] ["1", "2"]
01:55:35 <lambdabot>   [["a","1"],["b","2"]]
01:55:47 <yitz> > map (\(x,y) -> [x,y]) . zip ["a", "b"] $ ["1", "2"]
01:55:51 <lambdabot>   mueval-core: Time limit exceeded
01:55:56 <merijn> In your example: "map (\(x,y) -> [x,y]) . zip" $ [1..]" -> "map (\(x,y) -> [x,y]) (zip [1..])"
01:55:57 <yitz> > map (\(x,y) -> [x,y]) . zip ["a", "b"] $ ["1", "2"]
01:55:59 <lambdabot>   [["a","1"],["b","2"]]
01:56:17 <merijn> flake: Do you see how "zip [1..]" makes no sense as argument to map?
01:56:34 <merijn> :t zip [1..]
01:56:36 <lambdabot> (Enum a, Num a) => [b] -> [(a, b)]
01:56:39 <ZFox> > ["a","b"] `zip` ["1","2"]
01:56:41 <lambdabot>   [("a","1"),("b","2")]
01:56:46 <ZFox> Ah
01:56:47 <flake> I see it now.  Thanks all.
01:56:50 <merijn> map is expecting a list, not a function that returns a list
01:57:19 <statusfailed> Is there a library of useful natural transformations?
01:57:32 <ZFox> > map (\(a,b) -> [a,b]) $ ["a","b"] `zip` ["1","2"]
01:57:34 <lambdabot>   [["a","1"],["b","2"]]
01:58:16 <ZFox> > zipWith (\a b -> [a,b]) ["a","b"] ["1","2"]
01:58:18 <lambdabot>   [["a","1"],["b","2"]]
01:58:21 <stackingheapsoft> Is bitwise AND a constant time operation? can it be done i n haskell?
01:59:45 <Botje> > 123 .&. 567
01:59:47 <lambdabot>   51
01:59:52 <Botje> why wouldn't it be?
01:59:53 <merijn> stackingheapsoft: Depends what type you perform it on
02:00:11 <merijn> bitwise AND on Integer can't be constant time, for example
02:00:42 <ZFox> lolense
02:00:58 <yitz> @faq can Haskell do bitwise AND?
02:00:58 <lambdabot> The answer is: Yes! Haskell can do that.
02:01:46 <stackingheapsoft> merijn: whyy not?
02:02:01 <merijn> stackingheapsoft: Because Integer is not a constant size type?
02:10:59 <stackingheapsoft> solving in O(1) space, does that mena just constant space? it doesnt mean i cant have some extry variable as long as they dont vary with input size?
02:12:18 <Ke> any bounded amount of variables of bounded size
02:21:07 <vlatkoB> In a function that returns [[a]] a guard "| splitOn x  = []:imp' splitOn xs" works fine.
02:21:08 <vlatkoB>  Is there a way to write its return without the empty list in front?
02:21:08 <vlatkoB> This guard "| splitOn x  = i[ imp' splitOn xs ]" causes "Occurs check:..."
02:21:53 <vlatkoB> "i" in second guard is my typing error
02:24:22 <arkeet> [] : foo and [foo] are very different.
02:24:26 <arkeet> [foo] is foo : []
02:28:38 <vlatkoB> I made just an example of what I tried to try to explain what I want. It doesn't compile even.
02:29:47 <arkeet> I have no idea what you're actually trying to do.
02:34:48 <Botje> vlatkoB: show the full code for your splitOn function
02:34:52 <Botje> then we'll be able to help
02:37:00 <hpaste> vlatkoB pasted “"[]:foo" without "[]ˇ” at http://hpaste.org/83842
02:38:25 <vlatkoB> Here it is with some explanation. splitAt' (== 'a') "juraaaar"
02:40:15 <vlatkoB> I want to do it without "filter" so to use only basic haskell, no Prelude. Trying to learn to think the haskell way!? :-)
02:41:37 <mbuf> is there a command in lambdabot to ping a group of nicks?
02:42:52 <frerich2> vlatkoB: It appears that "imp'" returns a list and in the definition which causes the compile error you do "imp' ... : []'; did you maybe mean to use '++ []' instead?
02:45:07 <vlatkoB> Just correct. This is just one of my tries. That one should read "| splitOn x  = [imp' splitOn xs]".
02:46:12 <hpaste> vlatkoB revised “"[]:foo" without "[]ˇ”: “"[]:foo" without "[]” at http://hpaste.org/83842
02:47:15 <vlatkoB> The function as it is on hpaste works correctly.
02:47:15 <vlatkoB> I'm trying to get rid of empty lists, so I do not have to filter them.
02:47:27 <anicake> I'm a total newbie... I want to install hsenv. I tried "cabal install hsenv" and no errors were shown. But now if I simply head to the directory where I want to make an isolated env, and type "hsenv" it just doesnt work,... it says "Command not found"
02:47:30 <eikke> you become fat without realizing it?
02:47:55 <eikke> oops :$ please ignore :P
02:48:14 <merijn> anicake: Is hsenv in your path?
02:48:24 <anicake> nope :P
02:48:26 <merijn> Not sure where cabal installs binaries on your OS
02:48:33 <Kinnison> anicake: You need your cabal bin path in your shell's path
02:48:38 <anicake> thanks for responding @merjin
02:48:50 <Kinnison> anicake: On unix-like OS'en, it's likely to be ~/.cabal/bin
02:48:53 <Kinnison> No idea on Win/Mac
02:48:55 <merijn> There's a binary path where cabal leaves installed binaries, you should add that
02:49:07 <anicake> i am on ubuntu
02:49:27 <merijn> Kinnison: Mac is a unix-like, you heathen! (Although it's under ~/Library/haskell/bin there)
02:49:31 <anicake> ok ok.. so you mean to say I should export that PATH:etc?
02:49:36 <merijn> anicake: Yes
02:49:43 <anicake> ok!!!
02:49:49 <merijn> Or copy the binary somewhere else
02:49:53 <anicake> thanks a lot!!! @Merijn
02:50:12 <Kinnison> merijn: Given how much difference there tends to be between "default" behaviours under mac vs. bsd/linux/blablahblah, I don't tend to think of mac as 'unix-like' :-)
03:14:57 * hackagebot PandocAgda 2.3.3.0.2 - Pandoc support for literate Agda  http://hackage.haskell.org/package/PandocAgda-2.3.3.0.2 (PeterDivianszky)
03:57:57 <indomitus> can anyone direct me to a decent haskell http example? I'm having trouble getting just the response out (no headers)
03:58:11 <srhb> getResponseBody?
03:59:19 <Taneb> I think that it's funny that since they decided there'd be a new revision of Haskell every year (in 2006 if Wikipedia isn't lying), there's been one revision.
03:59:38 <Taneb> Almost 3 years ago
03:59:56 <typoclass> Taneb: you mean the haskell platform? i think that has had several releases
04:00:06 <Taneb> typoclass: I mean Haskell Prime
04:00:41 <typoclass> what, every year ...? :-o
04:00:55 <Taneb> http://hackage.haskell.org/trac/haskell-prime/ "New revisions of the language are expected once per year. The first revision ("Haskell 2010") was released in late 2009."
04:02:20 <srhb> Did anyone even get nominated last sunday? Or was it the week before?
04:02:21 <robde> hello, why doesn’t this work in hugs 98: let x = 1 ?
04:02:32 <srhb> OTherwise I guess the prime committee is disbanded.
04:02:42 <srhb> robde: hugs is really old, why not use ghci?
04:03:00 <robde> srhb: it’s on my ipad and there is no ghci in the repository
04:03:00 <typoclass> Taneb: what a weird plan *shrug* first time i've heard of it
04:03:27 <Taneb> I believe the Haskell 2011 committee is committee'ing
04:04:45 <typoclass> srhb: http://energysolutionsfoundation.org/wp-content/uploads/2012/05/Kittens.png <- itty bitty haskell prime committy
04:05:50 <Taneb> Don't forget the Glasgow Haskell Cat
04:06:04 <robde> srhb: so what would I have to do in hugs to do this?
04:06:16 <typoclass> robde: "let x = 1" is a haskell expression only if you're in a do block. the syntax that works always is this --
04:06:17 <srhb> robde: Sorry, I don't know hugs. Maybe without the let?
04:06:22 <typoclass> > let x = 10 in x*2
04:06:23 <lambdabot>   20
04:07:19 <robde> oh I see
04:07:24 <robde> thanks, bye
04:09:09 <typoclass> btw, there's a hugs on the "repository" of the ipad?
04:11:58 <indomitus> how can i run lines on (fmap (take 100) (getResponseBody response))?
04:12:16 <typoclass> indomitus: try "fmap (take 100 . lines)"
04:13:02 <indomitus> you are a BOSS
04:14:20 <Taneb> Or fmap (lines . take 100), depending on what specifically you want
04:14:54 <typoclass> indomitus: er, thanks :-) if you know pipes in the shell, it's a little like that but right to left. "cat | grep" in bash is comparable to "grep . cat" in haskell
04:14:58 * hackagebot http-conduit-downloader 1.0.3 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.3 (VladimirShabanov)
04:15:34 <Taneb> Any interesting stringy things that aren't Text, ByteString, or String?
04:16:04 <indomitus> Taneb, i'm not sure how the 2 differ to be honest. basically I'm receiving '\n' delimited plain-text numbers over HTTP and want a [String] of them
04:16:46 <Taneb> What typoclass said would give you the first 100 lines, what I said would give you the first 100 characters, line by line
04:17:23 <dmwit> Taneb: ropes?
04:18:08 <Taneb> Haven't seen that one... Hackage link?
04:18:15 <hpaste> “Ertugrul Söylemez” pasted “Finding modular inverses by hand” at http://hpaste.org/83845
04:18:45 <indomitus> Taneb, ah I see. probably typoclass's for me then
04:18:55 <dmwit> http://hackage.haskell.org/packages/archive/trifecta/1.0/doc/html/Text-Trifecta-Rope.html
04:19:15 <typoclass> > lines "lol\ncat\nmeow"
04:19:17 <lambdabot>   ["lol","cat","meow"]
04:19:26 <ion> > lines "lol\ncat\nmeow\n"
04:19:46 <typoclass> indomitus: just to be clear, the 'lines' function turns a String into a list of Strings ^^
04:20:14 <lambdabot>   ["lol","cat","meow"]
04:20:15 <Taneb> dmwit: I'm really looking for things you can use Parsec with
04:23:18 <indomitus> typo class, I'm pretty sure that is what i want. i know how many lines i'll need ahead of time too so i think fmap (take x . lines) is actually what i'll use
04:23:57 <dmwit> Well, you can use Trifecta with ropes. =)
04:30:34 <indomitus> typoclass could i take it a step further and make a [Int] by: fmap (take x . lines . read)
04:31:13 <typoclass> indomitus: have you tried fmap (map read . take x . lines)
04:31:43 <typoclass> indomitus: your solution would try to convert to Int first, then cut it into lines, then take 100
04:32:36 <indomitus> i think it's be necessary to cut into lines first tho no? say i'm receiving a string like: "2241\n5332\n5398"
04:33:01 <indomitus> ++"\n"
04:33:51 <typoclass> indomitus: yes exactly. remember that in "map read . take x . lines", lines is done first, then take, then map-read. in "take x . lines . read", it would try read, then lines, then take
04:35:34 <indomitus> typoclass: ohhh i misread you (thought you were describing your solution *thinking somethings not quite right*) haha thank you
04:36:02 <typoclass> indomitus: don't worry :-)
04:41:56 <indomitus> how do you get from IO String to String (as in: words <- lines . readFile defaultWords)?
04:42:35 <indomitus> fmap?
04:42:45 <merijn> indomitus: You don't, but you can get from "IO String" and "String -> Foo" to "IO Foo"
04:43:19 <merijn> :t fmap
04:43:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:43:35 <Kinnison> indomitus: You don't get to remove the IOness I'm afraid -- but you can "pass it along" :-)
04:43:40 <merijn> :t fmap (+1)
04:43:42 <lambdabot> (Functor f, Num b) => f b -> f b
04:43:57 <merijn> hmmm, bad example
04:44:08 <merijn> :t fmap (++"!")
04:44:09 <lambdabot> Functor f => f [Char] -> f [Char]
04:44:18 <merijn> :t fmap (++"!") `asAppliedTo` getLine
04:44:20 <lambdabot> IO [Char] -> IO [Char]
04:44:21 <indomitus> yeses! I'm getting the hang of it i think: fmap lines (readFile defaultWords)
04:44:38 <merijn> indomitus: That seems right, yeah
04:45:27 <Kinnison> or:  readFile defaultWords >>= return . lines
04:46:14 <merijn> I like fmap better
04:46:17 <typoclass> indomitus: if you get tired of the "fmap", there's some syntactic sugar available if you're inside a do block ("x <- ..."). if you put your code on hpaste, folks can demonstrate
04:46:26 <BlankVerse> I have build a cabal-dev sandbox, how to pass this sandbox to ghc while compiling?
04:46:42 <Kinnison> BlankVerse: I write a .cabal for my app and then use cabal-dev to build it
04:46:54 <Kinnison> merijn: I think it depends on my mood which I prefer :-)
04:47:04 <typoclass> BlankVerse: in the directory, you could always do "cabal-dev build" ...
04:47:05 <BlankVerse> Kinnison: its a blog written using hakyll
04:47:22 <Kinnison> BlankVerse: I've never used hakyll, sorry :-(
04:47:22 <BlankVerse> and I do : ghc --make site.hs
04:47:23 <hpaste> David pasted “so far” at http://hpaste.org/83847
04:47:35 <indomitus> typoclass: gladly
04:48:50 <typoclass> indomitus: ah, you already did that ("words <- ...")
04:49:26 <indomitus> i imagine it would be more difficult outside of a do block?
04:49:49 <hpaste> typoclass annotated “so far” with “save an fmap, if you want” at http://hpaste.org/83847#a83848
04:50:28 <BlankVerse> and I need to pass the environment to ghc as a flag maybe?
04:50:35 <typoclass> indomitus: so there's really not much to simplify in this case :-) but if you prefer, you can move the "lines" a little http://hpaste.org/diff/83847/83848
04:50:54 <typoclass> indomitus: yes, the "<-" syntax is only available inside of do
04:51:33 <supki> BlankVerse: ghc -package-db=cabal-dev/packages-<your-ghc-version>.conf site.hs
04:52:01 <indomitus> typoclass: good to know. i actually had your modification just before, but i need to use words later as [String] so fmap works well in this case
04:52:08 <hpaste> “Anonymous Coward” annotated “so far” with “Dollar signs, guys!” at http://hpaste.org/83847#a83849
04:53:18 <typoclass> indomitus: ok. i checked only if 'words' was used in that code block you pasted :-) i think you've got the hang of this already
04:53:56 * ZFox wnts to know what is wrong with his code... Binary encode/decode to wrong types :/
04:55:22 <ZFox> Ohhhh
04:56:12 <merijn> I always like the notation "when cond $ do {- new block on new line here -}" for multi action when's
04:56:50 <hpaste> merijn annotated “so far” with “Dollar signs, guys! (annotation)” at http://hpaste.org/83847#a83850
04:56:53 <ZFox> merijn: that reminds me of do {..} if/when/while/until in perl
04:57:10 <ZFox> unless even
04:57:31 <ZFox> Ughh
04:57:33 <merijn> Well, yes, block structures read nice, even in haskell
04:57:34 <ZFox> So many whens
04:57:40 <aforemny> Hi. Are there any examples that combine gloss and some FRP library?
04:58:21 <aforemny> I feel like gloss's model doesn't work well with FRP and wonder if there are implementations that work well.
04:59:17 <merijn> I dunno about gloss, but I still have a small FRP + SDL example that mm_freak pasted a few weeks back
04:59:48 <merijn> http://hpaste.org/83098
05:00:40 <aforemny> merijn: I consider it an issue that Gloss tries to arc rate. I'll take a look at your example though!
05:01:05 <aforemny> *tries to render with a fixed frame rate. (Don't know how that got missing. ^^)
05:02:21 <ZFox> aforemny: see /me
05:02:41 <ZFox> HAha see /help me
05:02:41 <ZFox> :D
05:05:21 <dmwit> ZFox: I think he was using * in the "correcting my previous line" sense, not in an attempt at /me.
05:05:43 <ZFox> Ah
05:06:07 * ZFox used to s/f/r/g?
05:13:07 <ion> Where did the * thing for correcting yourself originate from?
05:14:15 <arkeet> I have no idea. I've been using it for as long as I remember.
05:14:26 <arkeet> well, I put * at the end.
05:15:02 <ion> I don’t remember seeing it, say, in the 1990s.
05:15:55 <arkeet> you go further back than me, then.
05:16:22 <typoclass> ion: dunno, but i assumed it was to emulate a footnote*
05:16:27 <typoclass> *footnote in the sense of ...
05:16:39 <mauke> oh, I see¹
05:18:00 <typoclass> ion: linguists have a similar notation, but i bet it's unrelated
05:18:22 <mauke> "... using a notation borrowed from Kleene"
05:18:48 <typoclass> mauke: how do you mean?
05:18:57 <arkeet> typoclass: indeed, it means something entirely different. :p
05:19:11 <mauke> @google Haskell C programming char monoid
05:19:13 <lambdabot> http://hackage.haskell.org/packages/archive/cmu/1.2/doc/html/src/Algebra-CommutativeMonoid-Unification.html
05:19:13 <lambdabot> Title: src/Algebra/CommutativeMonoid/Unification.hs
05:19:18 <mauke> bad google
05:20:06 * hackagebot http-conduit-downloader 1.0.4 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.4 (VladimirShabanov)
05:20:13 <ZFox> When using Network.Socket.ByteString, is there any higher level method to getting bytestrings?
05:20:19 <ZFox> I.e get all available input
05:20:22 <mauke> typoclass: http://conal.net/blog/posts/the-c-language-is-purely-functional
05:21:37 <typoclass> arkeet: i wouldn't say entirely, but the star says "the following is wrong", not "the following is the correction" :-)
05:21:44 <arkeet> indeed.
05:21:55 <typoclass> it's kind of the inverse, in a sense
05:25:06 * hackagebot http-conduit-downloader 1.0.5 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.5 (VladimirShabanov)
05:26:03 * ZFox is puzzled to why low level networking seems so painful... :/
05:26:37 <ZFox> Ughh ofc
05:26:37 <zomg> words "low level" and "networking" should explain it
05:26:49 <Itkovian> I am looking for what is currently considered the state of the art configuration file parser … any pointers? ConfigFile, but I thought there were others, no?
05:27:30 <typoclass> Itkovian: a bunch of "lines" and "split ':'"
05:27:32 <typoclass> ;-)
05:27:40 <ZFox> zomg: ByteString
05:27:46 <ZFox> Bianry traffic
05:27:48 <ZFox> Enough said?
05:28:06 <aforemny> Itkovian: I'd vote for dyre if its a Haskell programm being configured.
05:28:17 <Itkovian> typoclass: awesome.
05:29:01 <jerng> Hi! Has anyone experienced multi-line string syntax behaving differently... with the -XOverloadedStrings language extension? It seems that line-opening backslashes become unnecessary.
05:29:29 <typoclass> aforemny: ooh interesting, thanks a lot
05:29:54 <elliott> Itkovian: http://hackage.haskell.org/package/configurator?
05:29:56 <aforemny> typoclass: youre welcome :)
05:30:07 <ZFox> Hmmmmmmm
05:32:23 <Itkovian> elliott: that looks nice.
05:32:40 <Itkovian> I am mainly looking for ideas on how to enhance our Python based shizzle :-p
05:33:14 <jerng> Whoops. Accidentally imported the CPP extension. That's where the problem is. Soory.
05:38:09 <gustavnils> Does anybody here have any experience representing mathematical expressions in Haskell and programmatically simplifying them?
05:38:18 <mauke> > x^4
05:38:18 <gustavnils>  / normalizing them
05:38:19 <lambdabot>   x * x * (x * x)
05:44:19 <linduxed> is there a deleteAll function?
05:44:43 <linduxed> basically delete, but for ALL instances of the deleted element
05:44:55 <linduxed> not just the first one
05:45:18 <typoclass> > filter (/= 'l') "lolcat" -- linduxed: this maybe?
05:45:20 <lambdabot>   "ocat"
05:45:32 <linduxed> typoclass: yes
05:45:52 * linduxed is surprised that's not available as deleteAll
05:46:30 <supki> > (length "deleteAll", length "filter.(/=)")
05:46:32 <lambdabot>   (9,11)
05:46:33 <linduxed> considering there are many Data.List functions that are basically another command passed through ONE other function, basically just doing one more step
05:48:00 <typoclass> linduxed: i'm not sure, but maybe they figured that processing an entire list is easy, only the partial thing was a little more awkward, hence they made it available as 'delete'
05:48:15 <typoclass> but who knows
05:49:10 <supki> @ty delete . all
05:49:11 <lambdabot> Eq ([a] -> Bool) => (a -> Bool) -> [[a] -> Bool] -> [[a] -> Bool]
05:49:19 <arkeet> :t concat . map
05:49:21 <lambdabot>     Couldn't match expected type `[[a0]]'
05:49:21 <lambdabot>                 with actual type `[a1] -> [b0]'
05:49:21 <lambdabot>     Expected type: (a1 -> b0) -> [[a0]]
05:51:35 <linduxed> hmmm
05:52:15 <linduxed> is there some nice function for substituting the first element which matches the first argument with the second argument?
05:52:25 <arkeet> :t delete .: all
05:52:27 <lambdabot> (a -> Bool) -> [a] -> [Bool] -> [Bool]
05:52:50 <arkeet> linduxed: you could use map
05:53:04 <linduxed> hmmm, true
05:53:14 <srhb``> arkeet: How?
05:53:18 <arkeet> how what?
05:53:24 <amyers> :t (.:)
05:53:25 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
05:53:28 <srhb``> How could you use map for that task?
05:53:44 <arkeet> > map (\x -> if x == 3 then 8) [1..5]
05:53:46 <arkeet> er
05:53:46 <lambdabot>   <hint>:1:28: parse error on input `)'
05:53:48 <arkeet> > map (\x -> if x == 3 then 8 else x) [1..5]
05:53:49 <lambdabot>   [1,2,8,4,5]
05:53:54 <srhb``> That replaces all occurrences of 3 with 8
05:53:54 <alpounet> it will replace ALL elements matching the argument
05:54:00 <arkeet> ah.
05:54:01 <arkeet> first element.
05:54:09 <amyers> :info (.:)
05:54:13 <srhb``> You need at least a fold.
05:54:20 <alpounet> you have to use an accumulator or smth like that to prevent this
05:54:41 <amyers> What module is .: from?
05:54:46 * ZFox has no idea what he is missing :|
05:54:48 <srhb``> @index (.:)
05:54:48 <arkeet> it's from lambdabot
05:54:48 <lambdabot> bzzt
05:54:58 <alpounet> amyers, you can define it yourself quite easily
05:55:01 <ZFox> Low level networking /= fun
05:55:02 <arkeet> but I bet it's also in some package somewhere
05:55:06 <alpounet> @src (.:)
05:55:06 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
05:55:11 <srhb``>  @index is probably the most worthless lambdabot command ever.
05:55:14 <srhb``> OK, src, too.
05:55:56 <amyers> alpounet: true
05:56:08 <bitonic> arkeet: (.:) is not that well established people use it for different things
05:56:24 <bitonic> see <http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=%28.:%29> for example
05:56:36 <arkeet> I'm not surprised.
05:57:20 <ZFox> http://ix.io/4GZ+4H0/ << Can anyone here see my mistake with my client/server here?
05:57:52 <ZFox> I want the server to send me tokens but it doesn't "seem" to be :/
05:58:29 <hseg> Hi. I'm trying to write a Parsec parser for a line-oriented programming language (basically assembly). I'd like to basically write a parser that parses one line, and then use some combinator to map that parser over each line in the contents of the file that I get.
05:58:38 <typoclass> linduxed: it's slightly awkward ...
05:58:39 <typoclass> > let (a, (_:b)) = break (== 'c') "lolcat lolcat" in a ++ "b" ++ b
05:58:41 <lambdabot>   "lolbat lolcat"
05:58:48 <hseg> So something like fmap parse contents ?
05:59:10 <quicksilver> ZFox: it looks like you try to recv 1024 bytes but you've only send 4?
05:59:16 <Kinnison> hseg: I go with mapM_
05:59:23 <Kinnison> hseg: But it depends on your approach
05:59:43 <linduxed> typoclass: yeah, i did it that way, then i realized that it would be prettier to just do the following, since i know there will only be one occurrence of the character i need to substitute:
05:59:51 <ZFox> quicksilver: Hehe
06:00:09 <linduxed> map (\x -> if x == ',' then '.' else x)
06:00:10 <ZFox> quicksilver: It's not an echo server
06:00:12 <arkeet> > [1,2,3,2] & partsOf (traverse . filtered (==2)) .~ [8] -- awful in multiple ways
06:00:15 <lambdabot>   [1,8,3,2]
06:00:16 <ZFox> Good morning world
06:00:17 <arkeet> someone please tell me there's a better one.
06:00:17 <Kinnison> hseg: If you want to see an example of taking a line-based parser/interpreter and extending it to operate across the entire input, see my latest haskell youtube vid
06:00:30 <linduxed> ZFox: hello there o/
06:00:38 <Kinnison> hseg: http://www.youtube.com/watch?v=oPhUwoh_aME
06:00:39 <hpaste> hseg pasted “Multiline parser from one-line parser” at http://hpaste.org/83853
06:00:44 <quicksilver> ZFox: Main sends four bytes ("test")
06:00:45 <hseg> So basically, I would get something like this?
06:00:55 <ZFox> quicksilver: to the server
06:01:01 <quicksilver> ZFox: second Main tries to receive 1024.
06:01:08 <quicksilver> ZFox: which is more than 4. No?
06:01:14 <arkeet> > [1,2,3,2] & partsOf (traverse . filtered (==2)) . ix 0 .~ 8 -- now only awful in one way.
06:01:14 <ZFox> Yea?
06:01:17 <lambdabot>   [1,8,3,2]
06:01:18 <dmwit> hseg: How about (many (lineParser >> string "\n"))?
06:01:24 <dmwit> or similar
06:01:25 <tdammers> parsec might be overkill for sth like an assembler... just my $0.02
06:01:26 <quicksilver> ZFox: that means it will block?
06:01:26 <ZFox> quicksilver: It's a max to get
06:01:32 <arkeet> I could have used _head instead of ix 0
06:01:41 <quicksilver> ZFox: yes, but it's TCP
06:01:42 <ZFox> "Maximum number of bytes to receive "
06:01:47 <alpounet> ZFox, yes but the receive will actually wait for these 1024 bytes
06:01:49 <quicksilver> ZFox: yes. It is the maximum you will get
06:01:54 <quicksilver> but it will normally wait for them.
06:01:56 <hseg> dmwit: But I want the data that lineParser returns
06:02:01 <ZFox> Ahh
06:02:09 <arkeet> > [1,2,3,2] & partsOf (traverse . filtered (==4)) . _head 0 .~ 8
06:02:11 <lambdabot>   Couldn't match expected type `Control.Lens.Internal.Setter.Mutator
06:02:11 <lambdabot>         ...
06:02:13 <arkeet> > [1,2,3,2] & partsOf (traverse . filtered (==4)) . _head .~ 8
06:02:15 <quicksilver> many network protocols send the length of the "chunk" first
06:02:16 <lambdabot>   [1,2,3,2]
06:02:21 <dmwit> hseg: Yes, yes, details. many (lineParser <* string "\n")
06:02:23 <quicksilver> so they know how much to receive.
06:02:35 <quicksilver> or they use line-based (receive up to newline char)
06:02:36 <ZFox> Okay.. How can I get it to get up until a null character or something (Then have to add null characters when sending)
06:02:39 <ZFox> OR SOEMTING
06:02:40 <ZFox> :|
06:03:08 <hseg> OK. And making the last newline optional?
06:03:16 <hseg> sepBy or something?
06:03:29 <ZFox> quicksilver: Also it's not "4" bytes, it's encoded
06:03:30 <dmwit> Sure. But files on *nix's always end with a newline.
06:03:38 <hseg> sepEndBy.
06:04:11 <dmwit> Chances are pretty good you'll want lineParser to be able to handle an empty line, anyway, in which case the whole question is moot.
06:04:42 <dmwit> ...that last sentence was just so, so wrong.
06:04:46 <ZFox> quicksilver: Suggestion?
06:04:59 <amyers> dmwit:  Always end with a newline?
06:05:06 <ZFox> quicksilver: Ahh, sending the chunk size first?
06:05:47 <dmwit> amyers: Text files, anyway.
06:06:18 <dmwit> amyers: Discovered this when I accidentally wrote a file without a terminating newline and wc gave me the wrong answer. =P
06:06:52 <typoclass> dmwit: don't see what's so wrong with it :-) removing one comma should be enough. or moving 'anyway' to the front. really quite small changes
06:06:58 <amyers> dmwit: huh, that's surprising.  I'm pretty sure emacs with 'delete-trailing-whitespace' deletes newlines at end of file
06:07:13 <dmwit> amyers: don't think so
06:07:18 <dmwit> just doesn't display the last newline
06:07:19 <amyers> dmwit: as a result git regularly complains at me :p
06:07:33 <dmwit> Check it out with xxd or something.
06:07:42 <amyers> dmwit: hmm, maybe not
06:08:01 <ZFox> quicksilver: Also.. This isn't TCP ? UnixSocket .. Or is it still TCP underlying?
06:08:02 <dmwit> typoclass: "being able to handle an empty line" does not imply "dealing with no terminating newline is moot"
06:08:07 <amyers> dmwit: Odd, git regularly complains at me about that ... hmm
06:08:14 <amyers> dmwit: but I'm not seeing it now.
06:08:15 <dmwit> typoclass: It was a semantic wrongness, not a syntactic wrongness. =)
06:08:18 * ZFox doesn't see why it would have tcp packets if it's just a unix socket...
06:08:35 <hseg> So something like either the lineParser or empty.
06:08:37 <typoclass> dmwit: oh i see :-) i wasn't following the semantics of your discussion
06:08:40 <hseg> Simple enough
06:08:41 <namor> suggestions an a library for cryptography? ECDSA would be awesome (couldn't find a single library on hackage with support), RSA/DSA would be an alternative (the intro text of hOpenSSL suggests not to use the library, so im confused). Any suggestions someone?
06:08:43 <quicksilver> ZFox: sorry, you're right. It's not TCP at all.
06:08:49 <quicksilver> ZFox: I actually meant "it isn't UDP"
06:08:51 <ZFox> Yea :)
06:09:03 <quicksilver> (UDP is message based and you receive whole messages, whatever size they might be)
06:09:12 <ZFox> Yea
06:09:12 <quicksilver> unix sockets are streams, like TCP.
06:09:20 <ZFox> like /=
06:09:33 <eikke> quicksilver: you sure udp guarantees 'complete' messages upon arrival?
06:09:34 <Kinnison> quicksilver: Unless you open a packet socket :-)
06:09:54 <Kinnison> eikke: IIRC, UDP packets either get there or they don't -- there's no halfway house on that
06:10:03 <Kinnison> eikke: given there's length and checksum fields
06:10:12 * dmwit just had the pleasure of typing .. && !!
06:10:15 <ZFox> quicksilver: Any suggestion for the code?
06:10:21 <ZFox> Cause I'm stumped
06:10:22 <dmwit> It's like I have a stutter!
06:10:27 <eikke> hmh. guess I should get back to the books :)
06:11:23 <ZFox> Kinnison: udp has no checking for arrival
06:11:26 <ZFox> Hence tcp exists
06:11:38 <ZFox> (Also udp has no integ checks)
06:11:55 <quicksilver> ZFox: send length first, or go line-based
06:12:01 <adas> is there a way to maintain state between successive function calls using the state monad or otherwise?
06:12:15 <quicksilver> if you go line-based, it's probably more convenient to use the Handle interface than the socket one
06:12:29 <quicksilver> (remember to turn off buffering or at least make it line buffered)
06:12:34 <alpounet> yeah the Handle-based IO API is really handy
06:12:41 <ZFox> quicksilver: I'm sending my types encoded as bytestrings/binary
06:12:49 <Jeanne-Kamikaze> adas, there's also Reader
06:12:56 <quicksilver> Or, devise a meta-protocol with fixed length chunks and continuation markers etc.
06:13:05 <adas> Jeanne-Kamikaze: Reader?
06:13:07 <frerich2> ZFox: If you go line-based, make sure to escape newline characters in the payload you send. If you go for an initial 'payload length' header, you impose a maximum package size (probably not an issue)
06:13:08 <quicksilver> but I think the other two options are preferable for simpler cases.
06:13:09 <ZFox> quicksilver: So I'm using socket.bytestring
06:13:21 <adas> the reader monad?
06:13:31 <dmwit> adas: That's what the State monad is for, but your callers will also have to be in the monad. (Your callers must preserve your state for you.)
06:13:33 <quicksilver> I'd send length first if I was encoding types into binary blobs.
06:13:36 <ZFox> frerich2: I think payload length
06:13:38 <dmwit> (This is what referential transparency means.)
06:13:51 <ZFox> frerich2: Any suggestions for how to implement this into my existing code?
06:13:59 <Jeanne-Kamikaze> adas, yes
06:14:15 <ZFox> (I want to pass the Types/Constructors to my use function
06:14:21 <ZFox> )
06:14:40 <ZFox> )))))))))))))))))))))))))))))))))))))))) -- for all those people who forgot to close their parens
06:14:58 <dmwit> ] -- in case we're in that dialect of lisp that allows this
06:15:21 <ZFox> dmac: :P
06:15:27 <ZFox> dmac: ignore that
06:15:28 <Kinnison> ZFox: I understand UDP quite well :-)
06:15:28 <frerich2> ZFox: Sorry, I didn't follow the chat too closely, so I missed your code; sending a length-prefixed datagram is easy, but I fear you'll have to do the buffering when *reading* yourself. I.e. if you decide to always send a 4-byte payload length first, your receiver side should first wait until 4 bytes are available, and then it needs to wait until n bytes (as given by the payload length) are available.
06:15:34 <eikke> > let f i = get >>= \j -> put (j + 1) >>= \() -> return (i + 2) in runState (f 1 >>= \k -> f 2 >>= \l -> return (k + l)) 0
06:15:35 <Kinnison> ZFox: UDP has as much integrity checking as TCP does
06:15:37 <lambdabot>   (7,2)
06:15:38 <eikke> adas: ^^
06:15:42 <Kinnison> ZFox: Just no arrival verification
06:15:50 <ZFox> Kinnison: Okay so I stand corrected
06:16:06 <frerich2> ZFox: I guess that's another downside (next to the imposed maximum package size) of the payload length approach, with a newline-based datagram you could just use hGetLine or so
06:16:12 <Kinnison> ZFox: I may have been involved with writing IP stacks at one point :-)
06:16:26 <Kinnison> (or at least working on them :-)
06:16:41 <ion> zfox: Parentheses: http://imgur.com/gallery/BJmIg
06:16:57 <ZFox> frerich2: 4 byte int is by far enough to specifiy the payload length
06:17:27 <ZFox> ion: Oh god left missing :( )
06:18:27 <ZFox> frerich2: If I were to use hGetLine then I'd have to be using Handlers and with the handlers I don't have access to the ByteString raw
06:18:56 <ZFox> frerich2: I've decided the payload length, but not 100% sure how to implement
06:20:03 <ZFox> I.e send, it doesn't give the option to send n bytes. so the integer needs to be encoded/padded?
06:20:56 <frerich2> Zfox: hGetLine gets you a String - since it doesn't perform any decoding/encoding (i.e. it's encoding agnostic) you could just turn that into a ByteStrng yourself, no?
06:21:18 <Radish> so can haskell tell if an infinite list is null?
06:21:30 <mauke> Radish, yes: no
06:21:54 <Radish> mauke: ?
06:21:55 <ZFox> frerich2: Yes, but I'd rather not touch strings for the networking. ByteString makes far more sense
06:21:59 <no-n> yes: no?
06:22:03 <typoclass> > null [0..] -- Radish
06:22:05 <lambdabot>   False
06:22:08 <ZFox> frerich2: Anyhow.. I want to do the payload length
06:22:35 <typoclass> Radish: 'null' only needs to look if there's one element, or no element
06:22:36 <Radish> typoclass: it only has to find at least one element, right?
06:22:56 <ZFox> Eh, it needs to be on both sides.
06:22:59 <frerich2> ZFox: For the payload length, you need to decide how to serialize your 32bit integer into raw bytes. In particular, the "byte order" is important.
06:23:03 <typoclass> Radish: right. that is not difficult for infinite lists :-)
06:23:07 * frerich2 wonders whether there's a ready-made htonl in Haskell....
06:23:41 <ZFox> :/
06:23:41 <Radish> typoclass: what about something like null (map (odd.(2 *)) [1..])?
06:24:08 <mauke> > null (map (odd.(2 *)) [1..])
06:24:10 <lambdabot>   False
06:24:30 <Radish> oh i did that wrong
06:24:43 <latro`a> I assume you meant "null (filter odd (map (2*) [1..]))
06:24:45 <Radish> > null (filter (odd.(2 *)) [1..])
06:24:46 <latro`a> which fails
06:24:49 <lambdabot>   mueval-core: Time limit exceeded
06:25:19 <Radish> in some cases, with other definitions, that might not fail righ
06:25:20 <Radish> t?
06:25:32 <ZFox> frerich2: Is it possible to have Data Payload = Payload Integer TComm  ?
06:25:42 <Radish> like provability and stuff?
06:25:55 <dmwit> Radish: Depends how different the other definitions are.
06:26:07 <Radish> dmwit: okay thank you.
06:26:09 <eikke> frerich2: there's Data.Binary.Get/Put which have get/putWord32Host/Network/...
06:26:14 <eikke> (or something along those lines)
06:26:17 <dmwit> > let allOddDoubles = [] in null allOddDoubles -- very different
06:26:19 <lambdabot>   True
06:26:19 <typoclass> Radish: if it takes a long time (or forever) to calculate the first element of the list, then null can't magically speed up that calculation :-)
06:26:26 <frerich2> eikke: Ah, that sounds perfect!
06:26:27 <eikke> blaze-builder/bytestring has them too (the put part)
06:26:54 <ZFox> frerich2: And I'm already using Data.Binary :)
06:27:00 <Radish> typoclass: I was just wondering what kinds of assumptions haskell could make about lists as a whole.
06:27:30 <dmwit> Radish: Has this line of inquiry helped understand what kinds of assumptions Haskell can make about lists as a whole?
06:27:40 * dmwit is wondering what new fact Radish is walking away with
06:27:45 <Radish> dmwit: a little bit
06:28:19 <Radish> dmwit: null is like && || any etc
06:28:32 <Radish> it shortcuts if it can
06:28:36 <Radish> otherwise it cannot
06:28:47 <Radish> and haskell doesn't know enough to know that 2* anything is even
06:28:52 <typoclass> dmwit: possibly "null will run infinitely long if given a funky list"
06:29:18 <dmwit> Those facts sound about right.
06:29:44 <ZFox> frerich2: eikke Suggestionss code-wise?
06:30:08 <Radish> > take 5 (reverse [1..])
06:30:19 <lambdabot>   mueval: Prelude.undefined
06:30:19 <lambdabot>  mueval: ExitFailure 1
06:30:22 <Radish> oi
06:30:35 <Radish> reverse (take 5 [1..])
06:30:47 <dmwit> > reverse (take 5 [1..])
06:30:48 <Radish> > reverse (take 5 [1..])
06:30:48 <typoclass> Radish: that's true, the code you had earlier will run at compile time, and in a dumb way check all even numbers if they're odd, and come up with 'no' for all of them, leaving nothing to be put in the list that comes out of 'filter'
06:30:51 <lambdabot>   mueval-core: Time limit exceeded
06:30:52 <lambdabot>   mueval-core: Time limit exceeded
06:31:05 <frerich2> ZFox: I think I don't the "Data Payload = Payload Integer TComm" question, but if you make that 'data' it doesn't look like a totally unreasonable definition to me.
06:31:14 <dmwit> ...what
06:31:18 <dmwit> > reverse (take 5 [1..])
06:31:21 <lambdabot>   [5,4,3,2,1]
06:31:24 <srhb> lambdabot bug :P
06:31:26 <dmwit> That's better!
06:31:39 <Radish> i break everything lol
06:31:58 <srhb> lambdabot is not hard to break. Well, it is if you really try to, but if you don't it will magically break on you.
06:31:59 <ZFox> instance Binary Payload where put (Payload i) = putWord8 i;get = Payload <$> getWord8
06:32:02 <ZFox> frerich2: ?
06:32:10 <ZFox> frerich2: (data Payload = Payload Integer)
06:32:38 <ZFox> or Word16 or 32?
06:33:19 * dmwit Payload (-3)
06:33:43 <ZFox> dmwit: Useful. Lets hope that doesn't mod to a large wait :)
06:35:32 * ZFox wonders why he has the Payload Constructor.. It's just an Integer
06:39:54 <ZFox> frerich2: eikke m <- recv s pl . getWord32host <$> recv s 4
06:39:56 <ZFox> ??
06:40:07 * hackagebot conduit 1.0.3 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.3 (MichaelSnoyman)
06:41:19 <ZFox> Also, how could I make the socket connection timeout after n seconds? (3)
06:41:42 <srhb> forkIO and kill the thread?
06:41:57 <ZFox> Hmm
06:42:18 <ZFox> Meh, I'll handle that another time
06:42:30 <ZFox> I need the payload length working first
06:42:50 <srhb> I don't know if that's The Right Way, maybe there's a timeout construct somewhere
06:42:56 <srhb> It's just the hammer I'd grab because I know it. :P
06:43:15 <ZFox> srhb: What forkio/kill? :P
06:43:19 <ZFox> Hammer indeed xD
06:43:19 <srhb> ZFox: Yeah
06:43:32 <srhb> I'm not sure it's actually bad. maybe someone else can weigh in.
06:43:57 <srhb> @hoogle System.Timeout.timeout
06:43:58 <lambdabot> System.Timeout module System.Timeout
06:43:58 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
06:43:58 <lambdabot> package control-timeout
06:44:00 <srhb> Nice.
06:44:22 <srhb> Problem solved. :-)
06:44:31 <ZFox> Haha
06:45:11 <srhb> And it's even in base.
06:45:41 <NucleOH> hi everyone; is there a way to tell which version of the Haskell Platform I have installed?
06:45:53 <srhb> uninstall-hs
06:45:58 <ZFox> srhb: Yea :)
06:46:03 <ZFox> srhb: I'll check it later
06:46:12 <srhb> Or is that Mac only? Hmm.
06:46:31 <NucleOH> oh, I'm on Mac.
06:46:33 <NucleOH> let me give it a try.
06:48:15 <ZFox> NucleOH: ghc --version?
06:48:34 <NucleOH> ZFox: is there a list of which version of ghc is packaged with a corresponding version of Haskell Platform?
06:48:52 <ZFox> I wouldn't know.. I don't use Haskell Platform
06:49:02 <ZFox> Just install cabal-install and let ghc be a dependancy :)
06:49:07 <ZFox> (What I do)
06:49:07 <NucleOH> heh :)
06:49:47 * ZFox sign, darcs still isn't in arch repos... :(
06:50:10 <ZFox> Heh, my cower is compiled against old libraries
06:50:13 <ZFox> Oh well
06:50:14 <NucleOH> uninstall-hs: Most RTS options are disabled. Link with -rtsopts to enable them.
06:50:25 <srhb> NucleOH: Did you pass it some weird argument?
06:50:32 <NucleOH> nope, just by itself.
06:50:39 <srhb> That's a bug.
06:50:42 <NucleOH> I didn't run it as root, though I don't see how that would matter...
06:50:52 <NucleOH> mreh, I'll just install the newest platform over what I have now, and call it good.
06:51:18 <ZFox> srhb: "weird arguments" +RTS -anything -RTS sure aint that weird :P
06:51:22 <srhb> It'll end in tears. :P
06:51:32 <srhb> ZFox: For uninstall-hs? I'd say so.
06:51:56 <ZFox> For the context I guess
06:51:56 <ZFox> :P
06:52:04 <NucleOH> I'd be happy if there was a mailing list that told me when new Platforms were released.
06:52:15 * ZFox wonders how to get payload length cleanly implemented
06:52:36 <srhb> NucleOH: It's not really that often, is it? Three per year? Two?
06:52:52 <NucleOH> that sounds right, srhb
06:53:06 <dmwit> darcs isn't in the Arch repos? Are you sure?
06:53:23 <merijn> srhb, NucleOH: I thought the schedule was 4 per year, one every quarter
06:53:36 <srhb> OK, I'm wrong. :-)
06:53:39 <dmwit> It was surely in the repos a year or two ago when I was using Arch.
06:53:40 <NucleOH> oh, okay -- I honestly have no firm idea. I'm just a lowly end-user.
06:53:44 <tippenein> it's in the gentoo repos, It must be in arch..
06:53:50 <ZFox> BLAH
06:53:53 <ZFox> frerich2: ping
06:54:29 <ZFox> Low level /= fun
06:55:08 * hackagebot free-game 0.3.2.5 - Create graphical applications for free.  http://hackage.haskell.org/package/free-game-0.3.2.5 (FumiakiKinoshita)
06:55:18 * ZFox attempts to sleep knowing his code doesn't compile..... OH the horror of going to school tomorrow knowing I can't touch / attempt to fix.
06:55:22 <ZFox> D:
06:55:56 <ZFox> Good night world. Thanks frerich2
07:00:08 * hackagebot http-conduit 1.9.2 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.9.2 (MichaelSnoyman)
07:10:18 <amyers> nucleOH: Last I was using Arch darcs was not in the official repo
07:11:54 <amyers> Maybe 6 - 8 months ago
07:12:43 <byorgey> yes, it looks like darcs is still in AUR only
07:13:38 <ZFox> byorgey: cabal install darcs
07:13:45 <ZFox> cabal-install is in repos
07:16:43 <byorgey> ZFox: I know, I was just confirming what amyers said
07:16:54 <ZFox> byorgey: i see.
07:17:16 <ZFox> byorgey: it would be nice if it were repomd tho
07:17:21 <ZFox> sadly not. :(
07:17:33 * ZFox may suggest to a few tu's tomorrow.
07:29:59 <amyers> zfox: googling "arch haskell darcs" turns up a lot of hits for problems building/maintaining the darcs package
07:30:18 <amyers> maybe it was problematic for some reason?
07:38:24 <cariveri> hey. did anyone experience cabal update to crash without notice? cant update anything.
07:38:59 <srhb> Crash without notice? How so?
07:39:53 <cariveri> well I just cabal  update and it seems to be running but nothing happens, then it returns to the shell wiout any output. I think it crashed.
07:40:02 <srhb> No "downloading latest" ?
07:40:06 <supki> first step to debug would be  cabal update -v3
07:40:08 <cariveri> when I then try to install something it tells me to udapte.
07:40:26 <cariveri> yes it says Downloading ...
07:40:51 <amyers> Is there anything in ~/.cabal ?
07:40:56 <amyers> After you run cabal update
07:41:05 <Radish> who agrees with the lack of "minus" as a standard function?
07:41:08 <srhb> cariveri: It's not supposed to give output afte rthat, though.
07:41:11 <supki> also what would  cabal --version  say?
07:41:30 <Radish> minus [1,2,3] [1,3] = [2]
07:41:38 <amyers> :t (-)
07:41:40 <lambdabot> Num a => a -> a -> a
07:42:09 <cariveri> 0.14.0 on a linux mint 14.
07:42:11 <srhb> Radish: I like prefix minus.
07:42:11 <srhb> Radish: For negative numbers.
07:42:11 <srhb> Radish: I'm assuming it's (-n) that bit you?
07:42:34 <Radish> srhb: not that minus the other one
07:42:46 <Radish> srhb: i was confused at first too lol
07:42:47 <srhb> Radish: "the other one"?
07:43:02 <Radish> srhb: it takes one list and "subtracts" it out of some other list
07:43:09 <srhb> // ?
07:43:15 <srhb> :t (//)
07:43:17 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
07:43:20 <srhb> almost.
07:43:26 <dario> :t (\\)
07:43:27 <lambdabot> Eq a => [a] -> [a] -> [a]
07:43:41 <Radish> oh it is implemented eh?
07:43:56 <srhb> Yes, it's in Data.List
07:43:58 <amyers> In Data.List
07:44:07 <cariveri> version: cabal install: 0.14.0, cabal library 1.14.0
07:44:24 <cariveri> Do I have to configure cabal with a specific mirror?
07:44:30 <Radish> interesting, I was reading an old article i guess
07:44:45 <srhb> Radish: Probably just someone bullshitting about Haskell without knowing anything?
07:44:50 <srhb> Radish: There are a lot of those articles out there.
07:45:21 <Radish> srhb: <3
07:45:23 <hiptobecubic> > [1,2,3] \\ [1,3]
07:45:25 <lambdabot>   [2]
07:45:30 <byorgey> cariveri: did you run  cabal update -v3?
07:45:33 <typoclass> > "lolcat" \\ "l" -- could have sworn it removes both l's ...?
07:45:35 <lambdabot>   "olcat"
07:45:39 <byorgey> nope
07:45:50 <byorgey> it's ordered multiset difference
07:45:52 <Radish> yes I was very surprised when it wasn't introduced as a standard!
07:46:05 <hiptobecubic> aka list difference
07:46:07 <Radish> I'm glad my instincts were right and double glad for the chatroom!
07:46:37 <osfameron> > "lolcat" \\ "ll"
07:46:39 <lambdabot>   "ocat"
07:47:00 * osfameron embraces the power of Welsh
07:47:14 <amyers> cariveri: What's in ~/.cabal after you run `cabal update`?
07:47:25 <Kinnison> argh, an osfameron
07:47:37 * osfameron tickles Kinnison 
07:48:24 <Skillsob> Hello, o mighty wizards of #Haskell
07:48:36 * typoclass purrs at Skillsob
07:48:38 <cariveri> byorgey. now I did and now cabal install worked again. but why? -v3 is verbose level 3 no?
07:48:51 <byorgey> cariveri: yes
07:49:04 <byorgey> cariveri: I didn't think it would fix it, I just wanted to get more info about what was wrong
07:49:12 <byorgey> cariveri: probably it was something like a network error
07:49:16 <Skillsob> I am having the same problem as this guy. http://hpaste.org/76710
07:49:24 <Skillsob> Does anybody know what the fuck?
07:49:26 <byorgey> so this time it happened to complete the download successfully
07:49:59 <supki> Skillsob: upgrade ghc / install older bmp version
07:50:44 <supki> assuming it exists
07:50:49 <cariveri> well ok it seems to be working. eventuelly I get to use cabal for hackaging.
07:50:52 <byorgey> supki: what? this isn't a problem with the version of ghc.
07:51:02 <Skillsob> It's a dependency for Data Parallel Haskell, which I want to use.
07:51:05 <simpson> Skillsob: Looks like that version of bmp is broken.
07:51:08 <byorgey> Skillsob: what version of ghc, cabal, and bytestring do you have?
07:51:09 <supki> byorgey: well, it's problem with Bytestring version I believe
07:51:23 <byorgey> supki: yes, so why downgrade ghc?
07:51:31 <byorgey> seems drastic
07:51:39 <supki> nobody said downgrade ghc
07:51:47 <byorgey> sorry, upgrade
07:51:53 <byorgey> that seems drastinc too.
07:51:55 <byorgey> *drastic
07:52:12 <supki> well, bytestring is bundled with ghc
07:52:43 <byorgey> ah, right, so it is
07:53:06 <Skillsob> cabal-install version 0.14.0, Cabal Library apparently 1.14.0. GHC 7.4.1
07:53:14 <Skillsob> How do I check Bytestring?
07:53:35 <byorgey> Skillsob: ghc-pkg list bytestring
07:54:04 <byorgey> wait a second. that error message is trying to install bmp-1.2.3.1.  The latest bmp is 1.2.4.1.
07:54:08 <Skillsob> Uh, apparently 0.9.2.1 and 0.10.0.2
07:54:40 <byorgey> Skillsob: can you run 'cabal install -v3 bmp' and put the output on hpaste?
07:55:03 <byorgey> Skillsob: also, when was the last time you ran 'cabal update'?
07:56:03 <Skillsob> byorgey: moments ago. I will do that
07:56:37 <byorgey> bmp should work with bytestring-0.10.0.2; it looks like 0.9 is getting chosen instead for some reason.  The -v3 output will hopefully tell us why.
07:58:04 <Skillsob> Wait, DPH wants bmp 1.2.3.1 and I have bmp 1.2.4.1
07:58:17 <Skillsob> It doesn't make any sense why it would want to install the old one...
07:58:34 <byorgey> Skillsob: this is why we need the -v3 output
07:58:50 <hpaste> Skillsob pasted “bpm -v3 output” at http://hpaste.org/83856
07:59:29 <byorgey> wait, so that says bmp-1.2.4.1 is installed.
07:59:45 <byorgey> Skillsob: so what command are you running that is actually failing?
07:59:59 <Skillsob> cabal install dph-examples
08:00:09 <byorgey> Skillsob: ok, so can you run that with -v3 and paste the output?
08:00:12 <Skillsob> Which supposedly installs everything you need to get going with DPH
08:00:14 <Skillsob> Ok.
08:01:56 <hpaste> Skillsob pasted “dph-examples -v3 output” at http://hpaste.org/83857
08:03:45 <supki> so gloss wants bytestring 0.9 and bmp wants bytestring 0.10
08:04:58 <supki> then it tries to install completely broken bmp version that thinks that it works with bytestring 0.9
08:05:09 * hackagebot http-conduit 1.9.2.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.9.2.1 (MichaelSnoyman)
08:05:24 <supki> the end
08:08:19 <byorgey> yes, supki is right.  Sorry for being thick-headed, I just like thoroughly understanding versioning problems before jumping to a recommendation.
08:08:31 <byorgey> Skillsob: so it looks like DPH really only works with GHC 7.6.
08:09:30 <Skillsob> byorgey: is my version outdated, or is that version some test version?
08:09:41 <byorgey> though I note that the latest gloss works with bytestring 0.10.
08:10:10 <byorgey> Skillsob: your version is outdated.  GHC 7.6 was released in September 2012.
08:10:59 <supki> I think another solution would be to unregister bytestring-0.10, rebuild everything that wil break, try again with  --constraint='bytestring installed'
08:11:39 <supki> or cabal-dev
08:12:29 <byorgey> it might work, but you will get old versions of everything
08:12:37 <supki> yes
08:15:07 <hpaste> statusfailed pasted “Converting between errors” at http://hpaste.org/83858
08:15:19 <statusfailed> sooo, I often find I need conversion functions like those ^
08:15:21 <Skillsob> I'm running Debian Wheezy, and supposedly apt-get says haskell-platform is up to date.
08:15:28 <statusfailed> is that a decent way to deal with them/
08:15:58 <statusfailed> I feel like all the "error-y" classes repeat a lot of functionality and I end up having to write boilerplate to convert stuff
08:17:18 <statusfailed> Skillsob: I think it means 'up to date' in the sense that it's the latest version in debian repos, right?
08:17:27 <statusfailed> what version of GHC are you running?
08:17:49 <Skillsob> 7.4.1, yes. I'd like to update GHC independently somehow.
08:18:17 <statusfailed> hm. I think you have to get a binary or source distribution
08:18:22 <statusfailed> someone might have packaged it actually
08:18:57 <amyers> skillsob: hsenv can install a different version of ghc in a manner similar to cabal-dev
08:19:20 <amyers> https://github.com/Paczesiowa/hsenv
08:20:41 <Taneb> emacs ghc-mod is playing up...
08:23:57 <srhb> Taneb: What's up?
08:24:12 <Taneb> It's not seeing half the modules I have installed
08:24:16 <Taneb> And saying they're not found
08:24:22 <srhb> cabal-dev'ized?
08:24:26 <Taneb> Nah
08:24:31 <Taneb> This happened after I reinstalled GHC
08:24:48 <srhb> Did you rebuild ghc-mod?
08:25:00 <typoclass> Taneb: it knows only about cabal packages, not the ones that come with ghc? (or vice versa)
08:25:09 <Taneb> Other way round
08:25:20 <Taneb> srhb, I apt-get removed than installed it again
08:25:28 <Taneb> Problem existed before and after
08:25:45 <srhb> Haven't the foggiest then.
08:25:50 <hpaste> Quchen pasted “Antipattern?” at http://hpaste.org/83859
08:26:16 <supki> statusfailed: I like  naturally :: Maybe a -> IO a
08:26:31 <quchen> Hey guys, mind having a look at the paste above? I hope I made my problem clear in the comment. (It's a few lines long so I didn't want to flood the channel with it)
08:27:38 <Taneb> quchen, data Foo = Terminal | GUIProgram; writeToFile :: Foo -> Filename -> Data .-> IO ()
08:27:38 <supki> quchen: why class?
08:28:48 <quchen> Taneb: That was my second thought, but implementationwise it kind of looks the same: an additional parameter chooses which interface to use. What's the advantage of your version?
08:29:09 <srhb> Not having to have classes littering everywhere.
08:29:15 <srhb> or instances, rather.
08:29:16 <supki> or data Foo = Foo { write :: -> IO (), read :: ... -> IO String }; terminal = Foo { ... }, guiprogram = Foo { ... }
08:29:17 <Taneb> quchen, less clutter, but it means that it is closed
08:29:22 <hpaste> hseg pasted “multiline Parsec parser” at http://hpaste.org/83860
08:29:40 <quchen> Taneb: what do you mean with "closed"?
08:30:05 <Taneb> People can't say "data MyOutput - MyOutput; instance DoesFileIO MyOutput where..."
08:30:06 <quchen> supki: Yours is the (G)ADT approach if I see that correctly
08:30:23 <tulsashrooms> Tulsa?
08:30:34 <Taneb> quaestor, supki's is just a normal data type which is a class dictionary thing
08:30:48 <quchen> Nick completion hijack! ;-)
08:31:07 <Taneb> Bah
08:31:31 <quchen> Taneb: So in your version I can choose not to export the data constructor, so people can't make their own versions?
08:31:35 <quchen> Makes sense
08:31:56 <Taneb> quchen, no, people can't make their own versions no matter what
08:32:46 <quchen> Hm.
08:32:57 <hseg> Taneb: WTF? I thought that once I define my datatype in a module, and only export some of its constructors, it can't be constructed without the constructors I export.
08:33:03 <quchen> So choosing data over class here is more a matter of taste?
08:33:24 <quchen> I agree that classes are probably worse if they don't have laws attached to them
08:33:25 <Taneb> hseg, yes, that's nothing to do with what I'm saying
08:33:26 <hseg> Unless you mean to say I can define a new datatype in the client module that has the same name as the expected datatyoe?
08:33:34 <Taneb> I'm saying that people can't add to the data type
08:33:42 <Taneb> People can't make their own constructor
08:33:48 <Taneb> They have to use yours
08:34:14 <hseg> Oh. Missed the negation.
08:34:36 <Radish> is haskell willing to break backwards compatability?
08:35:01 <hseg> But I *could* spoof the typesystem by, e.g. defining a type named, for example, Maybe, and passing it to all functions expecting a Maybe
08:35:05 <Radish> in general i mean
08:35:09 <Taneb> Radish, libraries? yes, sometimes. Language as a whole? no
08:35:09 <quchen> Radish: Haskell is not even willing to break forwards compatibility (Applicative => Monad) ;-(
08:35:09 <geekosaur> Radish: see the removal of Eq and Show for Num as a recent example, yes
08:35:16 <Taneb> hseg, no you can't
08:35:21 <hseg> No?
08:35:35 <geekosaur> hseg, types are not matched by name
08:35:36 <Radish> quchen: lol
08:35:48 <hseg> Oh. How are they matched, then?
08:36:02 <Taneb> It matches them so it gets them RIGHT
08:36:08 <Taneb> Name and module, I think
08:36:22 <Radish> if y'all could change one thing about haskell what would you change?
08:36:27 <hseg> OK.
08:36:28 <opqdonut> Taneb: and package, at least
08:36:40 <Taneb> Radish, I'd put Applicative into Prelude
08:36:42 <geekosaur> including package version
08:36:46 <Taneb> Yeah
08:36:47 <opqdonut> I remember having two different Data.Map.Maps and getting weird errors
08:36:55 <Taneb> Name, Module, Package, Package Version
08:37:12 <hseg> Anyone know why Parsec only parses the first line of my input with this code: http://hpaste.org/83860 ?
08:37:23 <geekosaur> hence strange errors like "expected Foo, got data.foo-0.10:My.Foo", yeh
08:37:36 <opqdonut> yep
08:37:40 <geekosaur> er, data-foo-0.10:...
08:37:48 <hpaste> Quchen annotated “Antipattern?” with “Better now?” at http://hpaste.org/83859#a83861
08:37:55 <Botje> hseg: try forcing it with multiline <* eof or something.
08:38:03 <quchen> Taneb: Just to double check: ^^ is the way to go, right?
08:38:05 <statusfailed> supki: how does that work?
08:38:15 <Botje> that should tell you why it's refusing to parse the rest.
08:38:16 <geekosaur> hseg: you'd have to show what statement is too, not just its type signature
08:38:23 <Taneb> quchen, yeah
08:38:25 <hiptobecubic> Radish, I'd make haddock strings available from inside ghc
08:38:25 <geekosaur> for eamp you parse the newline in there, you'd need two newlines
08:38:28 <supki> statusfailed: well, IO has MonadPlus instance
08:38:42 <geekosaur> ^eamp^example,^ (wtf?)
08:39:01 <statusfailed> supki: oh I see, haha
08:39:05 <quchen> Taneb: Wonderful. Thanks for your help! (Also thanks supki)
08:39:06 <hseg> It's mostly boring code that parses one line of text. I never parse a newline in it
08:39:15 <statusfailed> but that works, right?
08:39:52 <supki> statusfailed: well, mzero is bottom
08:40:03 <hseg> Found the culprit. I need to be able to parse newline-terminated comments.
08:40:45 <statusfailed> supki: weird, I get "No instance of MonadPlus" for IO
08:41:00 <statusfailed> oh wait
08:41:09 <statusfailed> you just mean the only possible instance is s.t. mzero is bottom
08:41:27 <statusfailed> well I guess that makes sense though
08:42:02 <hseg> Is there something like skipManyUntil that will skip instances of the first parser until the second parser matches, without actually reading the second parser's input?
08:42:54 <hseg> For example, when manyTill 's second parser matches, does it consume input
08:42:56 <hseg> ?
08:43:06 <supki> statusfailed: instance is defined in transformers
08:43:23 <supki> http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/src/Control-Monad-Trans-Error.html
08:43:45 <Radish> hiptobecubic: all i can find out about haddock strings is that haddock is a kind of fish. :\
08:44:04 <statusfailed> supki: ok I guess it's not so bad though
08:44:07 <hseg> Radish: Haddock is also the name of a fictional captain.
08:44:19 <statusfailed> supki: I mean it's reasonably consistent with what you expect, thinking about it?
08:44:21 <Radish> hseg: learn something new every day!
08:44:23 <hiptobecubic> Radish, the documentation on hackage is generated from haddock which are specially formatted comments in haskell code.
08:44:23 <srhb> You need to train your filter bubble for Haskell!
08:45:06 <hseg> http://en.wikipedia.org/wiki/Captain_Haddock
08:45:53 <hseg> Anyway, I think what I'll do re: the multiline parser is make the single-line parser also consume the newline, and then replace the multiline code by a manyTill single eof
08:48:13 <supki> statusfailed: personally I expect that instance to not exist :(
09:18:54 <petantik> I wish to remap caps lock to Escape. so, for console you can create a custom map.gz and use loadkeys, but i'm confused y the x instructions, i dumped the current keys to .Xmodmap
09:19:04 <petantik> wrong room
09:23:36 <statusfailed> supki: Yeah me too, but it does make sense really- Maybe a -> IO a is like calling fromJust- you risk the exception on Nothing
09:23:59 <statusfailed> I wouldn't expect toEnum to exist either :P
09:25:07 <hpaste> Valk pasted “Recursion fail” at http://hpaste.org/83863
09:26:06 <Valk> Hello, I'm apparently having a brainfart. How do I make it so the function returns the full lists in the quadruple, and not just the last value in xs? http://hpaste.org/83863
09:28:37 <srhb> Volk: I'm not sure what you're expecting your patterns in the case to do
09:28:58 <srhb> Valk: ^^^
09:29:21 <srhb> The first one, "as ->" will always match.
09:29:37 <srhb> Valk: I think you have have understood what patterns do?
09:33:03 <srhb> Eh, misunderstood*
09:33:26 <Valk> srhb: I have a list x:xs, which holds a few hundred values. The lists as, bs, and cs are initially empty (so (minimumBy (comparing sum') [as,bs,cs]) returns the first one). I want to put the x:xs elements into as, bs, or cs (depending on which of those lists has the minimal sum of its elements), so ideally the result would be as, bs, and cs of approximately equal sum'
09:34:00 <srhb> but as will always be the minimum list in the case. And it will always match
09:34:15 <Valk> Huh?
09:34:44 <srhb> To put it differently, when do you think the bs -> and cs -> cases will match?
09:35:52 <srhb> I think what you _mean_ is something like case blah of _ | minimalList == as -> .. | minimalList == bs -> .. | minimalList == cs -> ...
09:37:08 <srhb> you're not pattern matching the original as, bs, cs-lists with the result of minimumBy (comparing sum') -- you're binding the minimal list to the name as, always.
09:37:19 <Valk> Oh. I see. Thanks
09:37:47 <srhb> Put a trace statement in the first case to see that that is indeed what is happening.
09:38:28 <skuggi_> Valk: the case 'as -> ...' will introduce a new variable 'as' which will hide the other 'as', and will be bound to the expression 'minimumBy (comparing sum') [as,bs,cs]'
09:38:56 <Valk> Thanks, I think I get it
09:42:33 <hpaste> Beetle_jada annotated “parsing indent-style languages with Parsec question” with “hooray for stackoverflow” at http://hpaste.org/83759#a83864
09:43:12 <Beetle_jada> just to say that stackoverflow fixed my problem
10:03:40 <cariveri> hey. leksah does not find modules, no matter if installed with apt-get or cabal. perhaps I need to tell it about package paths. but those I dont know either.
10:05:11 * hackagebot cipher-aes128 0.2.2 - AES128 using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.2.2 (ThomasDuBuisson)
10:27:05 <LambdaDusk> i have a type [(Int, a)] and I need to find a function "find :: Int -> [(Int, a)] -> a" where "find n l" is the last member of the list, for which fst l < n
10:27:34 <LambdaDusk> but somehow I don't get it how I can make that
10:27:39 <LambdaDusk> anyone can help?
10:28:07 <merijn> What is it supposed to return if there is no element < n in the list?
10:28:37 <merijn> also, is the list sorted?
10:29:33 <crdueck_> I'm trying to work with a binary format. I recieve a ByteString of Char8s, convert those Char8s to Word8s and use the ByteString as a binary data stream. The problem is I might need to take 6 bits from the stream, but I can only access the bits in these Word8 chunks. Its even worse if I want to take a range of bits from [x..y] because I need to remember to divide the indexes by 8, but the indexes might not be even multiples of 8. 
10:30:39 <Nisstyre> crdueck_: such is the folly of using the ByteString type
10:31:17 <crdueck_> Nisstyre: what is a better option?
10:31:22 <Nisstyre> crdueck_: not sure
10:31:46 <merijn> :t (.&.)
10:31:48 <lambdabot> Bits a => a -> a -> a
10:31:59 <crdueck_> I need to be able to represent a bit stream, and have access to individual bits, or ranges of bits
10:33:36 <Nisstyre> crdueck_: perhaps this? http://www.haskell.org/haskellwiki/DealingWithBinaryData#The_BitGet_monad
10:34:37 <crdueck_> Nisstyre: that looks helpful, thanks
10:35:05 <LambdaDusk> merijn: If there is no element < n in the list, there should be an exception - as the data generated shouldn't have this
10:35:16 <crdueck_> ah, BitGet is part of binary-strict, and I'm using lazy bytestrings...
10:35:32 <Nisstyre> crdueck_: do you *need* lazy byte strings?
10:35:33 <LambdaDusk> merijn: And I could sort the list, too
10:36:47 <LambdaDusk> crdueck_: Also you don't have to convert the bytestrings at all - ByteString.Word8 and ByteString.Char8 are the same type, they just have a different interface
10:37:17 <crdueck_> Nisstyre: yes, I'm working with large bytestrings. They need to be lazy to keep memory usage down
10:38:18 <LambdaDusk> crdueck_: Be careful: Lazy Bytestring can be even worse in memory consumption, you should use Pipes or conduits when you don't need the entire string at once
10:39:00 <crdueck_> LambdaDusk: I've tested it, and I'm using constant memory (2mb). If its a problem I could switch to a streaming library, but it seems fine
10:39:29 <crdueck_> but, using pipes might let me use strict bytestrings, and then binary-strict would be an option
10:40:08 <Nisstyre> crdueck_: that sounds like a good solution
10:54:33 <klrr> hey, im interested in learning haskell, i got a tiny experience with C and scheme, written some VERY simple programs with them both, i consider myself as completely new to programming though, is "Programming in Haskell" good for me? or are there any other haskell book targeted at real beginners?
10:54:54 <bitonic> klrr: ‘Programming in Haskell’ is probably the best for beginners
10:56:10 <hiptobecubic> no LYAH?
10:56:22 <hiptobecubic> It starts out pretty slow i thought
10:56:54 <klrr> hiptobecubic: hmm well, it seems quite good but im not aviable to get a copy of it right now, and reading online is not really my thing
10:57:13 <hiptobecubic> klrr, ah ok. That's a shame. It's a good book.
10:57:34 <Hannibal_Smith> klrr, if you dont mind follow online university course, there is a great course that you can follow: http://www.youtube.com/watch?v=gx28Umd7ELA
10:57:41 <klrr> hiptobecubic: there's only 1 copy in the libraries where i live, and it got 5 reservations already
10:58:04 <klrr> Hannibal_Smith: nice, will check it out
10:59:15 <Hannibal_Smith> IMHO it's the best way to start with Haskell his course
10:59:37 <hiptobecubic> klrr, it's nice that the book is out there at all though. It's certainly not in my library back home.
11:00:47 <klrr> yeah , our libraries in my city (they have a index with all book) doesnt have classics like K&R and sicp though, so i bought them but now my parents wont allow me to order more books :P
11:02:08 <ChongLi> klrr: a lot of books are freely available online
11:02:20 <sproingie> SICP is free
11:02:22 <ChongLi> sicp and lyah are 2 that come to mind
11:02:29 <klrr> ChongLi: yeah i know, but it's so annoying to read online :P
11:02:44 <sproingie> you can get it as a pdf
11:03:05 <klrr> yes but it still on a computer screen
11:03:17 <sproingie> you're programming computers.  might want to get used to reading on one.
11:03:26 <ChongLi> don't you have an ereader?
11:03:32 <hiptobecubic> ChongLi, most people don't.
11:03:47 <ChongLi> hiptobecubic: haha I suppose you're right
11:04:07 <sproingie> if someone has an affectation for paper, they can pay money for it
11:04:11 <ChongLi> it's great for reading pdfs and epubs in a comfortable chair
11:04:26 <klrr> computer hardware is dated, still running amd64 and using unix-like OS:es no innovation :P
11:04:40 <hiptobecubic> great for epubs maybe. pdfs are miserable
11:04:49 <sproingie> there's plenty of innovation, the problem is they don't generally do anything new
11:04:51 <klrr> also i dont have a very good screen that's why i dont like to read on the screen
11:05:03 <sproingie> what would you do on a brand new architecture that you don't do now?
11:05:11 <ChongLi> hiptobecubic: perhaps, depends on the file and how you convert it
11:05:14 <hiptobecubic> pdf + kinkos + small donation to author :)
11:05:33 <ChongLi> you'd print a 200+ page book at kinkos?
11:05:55 <hiptobecubic> sproingie, there's certainly some room for innovation as far as UI is concerned in the *nix space.
11:06:15 <sproingie> i'd say + donation to sierra club is also in order
11:06:18 <hiptobecubic> ChongLi, well no. I'd just read it online.
11:06:28 <sproingie> hiptobecubic: i've had my fill of the "innovations" going on in gnome
11:07:12 <Hannibal_Smith> What Linux distro do you use?
11:07:19 <Hannibal_Smith> Fedora 18 in unstable
11:07:20 <ChongLi> arch here
11:07:40 <sproingie> want to invent a new UI paradigm, you've got a web browser.  that's more or less a blank canvas and zero deployment
11:07:41 <klrr> i use ubuntu , but i install minimal install and install sysV init scripts so i can uninstall dbus :P
11:07:43 <sproingie> go forth and invent
11:07:54 <Hannibal_Smith> Arch...I dont realy like that they removed the installer
11:08:06 <klrr> Hannibal_Smith: well, install once then forget ;)
11:09:56 <Hannibal_Smith> I'm using Ubuntu now...but I dont like Canotical
11:10:16 <sproingie> using kubuntu at home, alpha 2 of raring
11:10:46 <Hannibal_Smith> Searching online what do you digit on Unity? They are fools
11:11:08 <monochrom> I use Unity and like it
11:11:19 <klrr> i use ubuntu but i dislike ubuntu , so install minimal install and removes everything ubuntu'ish like upstart and dbus bs
11:11:22 <monochrom> but you can call me a fool
11:11:23 <hiptobecubic> I'm sure it's come a long way since the initial roll out
11:11:29 <sproingie> klrr: isn't that called debian sid?
11:11:44 <klrr> sproingie: no, it's called ubuntu 12.04
11:11:49 <monochrom> I like Unity since the initial roll out
11:11:49 <hiptobecubic> Yeah i'm not sure what the point of that approach is
11:11:51 <klrr> i still use ubuntu's software repos
11:12:03 <monochrom> but again, you can just call me a fool
11:12:07 <hiptobecubic> monochrom, to each his own
11:12:14 <sproingie> i hated unity at first, it's improved quite a bit.  still prefer kde once i deuglify the defaults
11:12:29 <sproingie> as it is, it's a way to pop open a few terminals, emacs, and a browser
11:12:32 <hiptobecubic> I've gone full ugly with xmonad :)
11:12:32 <klrr> isnt unity made so it can works on phones too? i use dwm
11:13:11 <sproingie> i dont even use any DE's terminal app, it's urxvt for me all the way
11:13:44 <Hannibal_Smith> Too much for me
11:13:46 <hiptobecubic> urxvt is great.
11:14:18 <klrr> OMG, do they teach/research with haskell at CHALMERS?
11:14:25 <hiptobecubic> yes
11:14:29 <klrr> OMFG!
11:14:35 <klrr> im in the same city
11:14:42 <klrr> now i will work even harder in school :)
11:14:53 <Hannibal_Smith> For example I use...Eclipse for Haskell, I think that there are few people that do that here
11:15:19 <sproingie> i beat emacs+flymake into submission
11:15:31 <sproingie> something i wouldnt consider for other languages, works pretty well for haskell
11:15:34 <hiptobecubic> I'm not sure how the university system works there, but I think finishing public school is enough to earn admittance to undergraduate no?
11:16:22 <hiptobecubic> sproingie, looks similar to vim+syntasic
11:16:25 <hiptobecubic> syntastic*
11:16:31 <klrr> well im in what's called elementary school i think, then next year high school and then i can go to university after 3 years in high school, i will work shit hard in high school :D
11:16:33 <hiptobecubic> except worse of course :)
11:17:12 <sproingie> hiptobecubic: possibly.  i of course use an editor from the civilized world and not of the poopypants variety ;)
11:17:59 <hiptobecubic> sproingie, odd. You said you used emacs earlier.
11:18:46 <hiptobecubic> There's a lot of wasted effort in editor plugins
11:19:02 <sproingie> hiptobecubic: i've recently learned emacs has a mode to edit text :)
11:19:23 <monochrom> once upon a time, it was rumoured that the emacs exe file size was almost 6e37. http://www.gnu.org/fun/jokes/ed.msg.html
11:19:42 <monochrom> although, the same rumoured claimed that ed was compiled in 1929
11:19:53 <hiptobecubic> sproingie, ah yes. It's called evil mode.
11:20:04 <hiptobecubic> It's a pretty good emulator
11:20:09 * edwardk was not.
11:20:31 <edwardk> they may have interpreted me back then though.
11:20:42 <monochrom> hahaha
11:22:56 <Hannibal_Smith> What library do you use for sql database in Haskell?
11:24:15 <Hannibal_Smith> I'm currently using postgresql-simple...but coming from .Net I dont find it so great
11:24:26 <preyalone> How do I define an infix function?
11:25:01 <preyalone> I tried (myfunc) :: Int -> Int -> Int, but GHC says Invalid type signature / Should be of form <variable> :: <type>
11:25:02 <c_wraith> preyalone: let x &% y = x * y + 1 in 5 &% 5
11:25:12 <c_wraith> > let x &% y = x * y + 1 in 5 &% 5
11:25:14 <lambdabot>   26
11:25:18 <preyalone> c_wraith: I'd like to reuse the function later, so let wouldn't help.
11:25:24 <thoughtpolice> preyalone: you don't need () for regular identifiers, only if your identifier is symbolic
11:25:26 <c_wraith> preyalone: so make it top-level
11:25:28 <thoughtpolice> preyalone: it works the same way
11:25:31 <thoughtpolice> as a top-level binding
11:26:12 <c_wraith> syntactically, there's no difference between a local declaration and a global declaration.
11:27:46 <monochrom> we add "let ... in" just for the sake of lambdabot
11:28:50 <sproingie> preyalone: your function has to contain nonalpha characters or you have to use backticks
11:29:05 <preyalone> sprongie: Thanks.
11:29:12 <sproingie> > let foo x y = x + y in 1 `foo` 2
11:29:14 <lambdabot>   3
11:29:17 <preyalone> ... and of course an apostrope doesn't count
11:30:00 <c_wraith> yeah, apostrophe is not an operator character
11:31:04 <monochrom> @let mono'apos 0 = 0; mono'apos n = mono'apos (n-1)
11:31:07 <lambdabot>  Defined.
11:31:13 <monochrom> > mono'apos 4
11:31:18 <lambdabot>   mueval-core: Time limit exceeded
11:31:33 <monochrom> that can't be right
11:31:39 <monochrom> > mono'apos 4
11:31:42 <lambdabot>   0
11:34:18 <donri> hey nice work by dcoutts, new hackage themed like haskellwiki and haddock http://new-hackage.haskell.org/
11:35:05 <carter> oh that is nice
11:35:05 <lambdabot> carter: You have 1 new message. '/msg lambdabot @messages' to read it.
11:35:43 <carter> edwardk i'll add that to the ersatz ticket for myself to do
11:38:47 <EvilMachine> Damn. I know that my code could have bugs. But if I write tests, I know that my test code could have bugs as well. I could write test-tests and so on, but… I want to make *sure* I have no bugs.
11:39:00 <EvilMachine> I think I realized that this is 100% impossible. (Or is it?)
11:39:47 <monochrom> you are right. you cannot reach 100%
11:39:49 <Hannibal_Smith> The world itself its imperfect, EvilMachine :-P
11:40:05 <monochrom> and I cannot either
11:40:19 <EvilMachine> Or how could I make sure my code is doing what I expect it to do, *without* introducing another piece of code that I’m not sure will do what I expect it to do either…?
11:40:39 <Hannibal_Smith> It's impossibile
11:40:41 <EvilMachine> Hmm… but that makes unit tests completely pointless for me.
11:41:31 <monochrom> but you are painting it too pessimistically. many tests and specifications are so simple that they obviously say what you want.
11:41:31 <EvilMachine> I could just as well formally verify my code manually, and mark every function that got edited as unverified again.
11:42:01 <EvilMachine> monochrom: Agreed. That’s what I mean with manual verification.
11:42:42 <sproingie> you could also put those manual verifications into a script that entered the expected input and checked it against the expected output
11:42:45 <sproingie> you could call them "tests"
11:43:08 <shergill> EvilMachine: that only works if in the 'test' for a function you're testing different call paths
11:43:13 <Chousuke> As far as I know formal verification is pretty much the only way to be certain that your program works. when it is not feasible, you're left with just collecting enough evidence to convince yourself.
11:43:25 <shergill> or call sequences rather
11:43:32 <monochrom> suppose I want to add two numbers. I could write this formal specification: z = x + y. I could write many tests: (3,1,2), (32,16,16), ...
11:44:04 <EvilMachine> sproingie: no. that’s a huge difference. manual verification has nothing to do wtih input/output, but with the code itself. so what i would do, is compare the function’s *source* (as a String) to another string in the DB, and mark it as unverified again, if it differs.
11:44:17 <monochrom> you could say: my specification and test cases are obviously correct. or you could say: how could I ever be 100% sure that z=x+y expresses what I mean.
11:44:29 <sproingie> EvilMachine: or you could just test it every time
11:44:37 <Chousuke> and generally when you generate such evidence in the form of tests, you keep your tests simple enough that you can convince yourself of their correcness without additional evidence
11:44:45 <sproingie> it's not like your manual checks "verified" anything
11:44:59 <EvilMachine> shergill: I’m not talking about call paths. I’m not talking about calling or even running it at all.
11:45:21 <sproingie> you could re-run all affected tests whenever the code changes, which test frameworks already do
11:45:24 <EvilMachine> monochrom: yes, exactly
11:45:42 <EvilMachine> monochrom: Mathematicians had that exact problem. :)
11:45:48 <sproingie> usually i just rerun failed tests til they pass, then re-run the whole suite
11:46:31 <carter> the problemw with formal verification: high energy radiation may flip the bits in the machine!
11:46:32 <Hannibal_Smith> EvilMachine, write your test, release you software to a group of selected people for QA, fix the reported problems and write new tests
11:47:04 <Chousuke> with software, at some point you're going to have to trust some component to be correct.
11:47:37 <sproingie> you're testing the algorithm, not the machine.  probabilistically speaking the machine will execute the algorithm as designed
11:47:37 <monochrom> basically I have stopped worrying about 100%
11:47:44 <sproingie> assuming you got it working once before
11:47:45 <Chousuke> unless you're programming a satellite I suppose :P
11:47:53 <sproingie> compiler bugs can be maddening
11:47:58 <EvilMachine> Damn, doesn’t anybody get it? This has *nothing* to do with running the function *at all*, to verify it. You have building blocks you assume are true (e.g. the behavior of “+”), and you verify the combination of them by reading it. If you trust it, you mark it as verified, and the function’s code gets stored in another file for later string comparison.
11:48:12 <monochrom> I get it. and I think you know.
11:48:16 <EvilMachine> Sorry. Please don’t confuse it with “tests” anymore.
11:48:21 <EvilMachine> monochrom: Yes, you do. :)
11:48:52 <Philippa> carter: There're multiple problems with that statement. There's a lambda calculus called... I think it's "lambda bang" or something close? That allows for cosmic rays and calculates tolerance
11:49:19 <sproingie> important satellites tend to use redundant processors and require a quorum
11:49:20 <EvilMachine> carter: Great point. So we’re back at square one, if it happens to flip the same bit in both the code string and the verification string.
11:49:23 <EvilMachine> Damn. ^^
11:49:27 <shergill> i don't get how what EvilMachine is saying is fundamentally any different than any testing mechanism. there's still the burden of proof. the point of automated testing is to reduce (not eliminate) the things you have accept on faith
11:50:21 <EvilMachine> monochrom: I’m more worried about “at all” than “100%”. In other words: I cannot be sure that any code is correct at all. Ever.
11:50:36 <shergill> EvilMachine: yes.
11:50:43 <sproingie> you cannot be sure you even exist
11:50:49 <Chousuke> EvilMachine: in the same way you can't be sure that you will fall down if you jump off a cliff :P
11:51:03 <sproingie> welcome to epistemology 101
11:51:36 <monochrom> there are some mathematical axioms and some computer programs that I consider correct by just "I say so". then the rest builds on them.
11:51:37 <EvilMachine> sproingie: redundant processors have, of course, the same problem as redundant code (= code + tests + test-tests + test-test-tests + … ;).
11:52:18 <sproingie> the chance that a cosmic ray will flip the bits of a quorum of processors is ... not generally considered worth guarding against.
11:52:32 <EvilMachine> Chousuke: I’m not sure that really is the same way.
11:52:41 <hiptobecubic> My preferred method of testing is assumption.
11:53:03 <hiptobecubic> As in, "this looks pretty good. I assume it's fine."
11:53:08 <EvilMachine> monochrom: If you *defined* them to be that way, then of course, they *by definition* do what you defined them to do. :)
11:53:24 <hiptobecubic> I have yet to destroy even a single satellite.
11:53:31 <monochrom> fortunately, those "I say so" correct things are pretty simple, and so other people tend to agree with me on them
11:53:40 <sproingie> hiptobecubic: you need more power in your death ray then
11:53:52 <Sgeo> monochrom, those are different. The "I say so" things don't need to have an independent truth or falsity
11:53:55 <shergill> EvilMachine: yes, but is what i defined them to do what i really wanted them to do?
11:53:58 <EvilMachine> With things of “outside” (of our mind) nature, it’s different. You can really *never ever* be sure. At best, you can trust it, after having seen enough observation that matches your predictions.
11:54:14 <Sgeo> With mathematical axioms, it's not "These seem correct", but "These are useful"
11:54:19 <sproingie> david hume, please /join #haskell
11:54:23 <hiptobecubic> sproingie, Oh. I thought we were programming satellites. I haven't tried death ray blasting them yet.
11:54:26 <shergill> heh
11:54:36 <hiptobecubic> sproingie, but I assume it would work fine. :)
11:54:39 <hiptobecubic> There. done.
11:54:52 <EvilMachine> shergill: By definition, yes.
11:55:14 <EvilMachine> Sgeo: Extremely good point. This is true for all of science.
11:55:23 <monochrom> ok, for those things about reality, we're back to the scientific method
11:55:27 <Hannibal_Smith> So...your answer is?
11:55:31 <Sgeo> EvilMachine, what I described is about mathematics, not science.
11:55:34 <EvilMachine> monochrom: Exactly.
11:55:45 <EvilMachine> Sgeo: I know. But it’s true for all of science too.
11:56:35 <Sgeo> Um, no? Any scientific statement can be false, even if all evidence points to it being true. And our bedrock assumptions that we rely on (such as "Induction is useful") could be fundamentally wrong, without us having a way to determine that.
11:56:36 <monochrom> so, basically I don't ask for more than what science can assure
11:56:52 <EvilMachine> So… Let’s start from there: I gain confidence in my code, by applying the scientific method. I can never be sure, but after a while, I have enough trust in it. Unless conflicting evidence comes up. But until then, everything is fine.
11:57:14 <Hannibal_Smith> EvilMachine, yes, but
11:57:14 <Hannibal_Smith> <Sgeo> Um, no? Any scientific statement can be false, even if all evidence points to it being true. And our bedrock assumptions that we rely on (such as "Induction is useful") could be fundamentally wrong, without us having a way to determine that.
11:57:23 <shergill> EvilMachine: no. it's only stated that you defined things to be so. and yes if there's no error in your thought process things are well and good. but when there's an error, as if often the case you're outta luck
11:57:41 <EvilMachine> Hannibal_Smith, Sgeo: Well, of course. That is what I said.
11:57:46 <shergill> /s/as if/as is/
11:58:36 <EvilMachine> shergill: I consider that to be just another conflicting evidence you will notice later. ^^
11:59:00 <shergill> EvilMachine: yep
11:59:26 <EvilMachine> Nice. This sounds like a much better model to approach the problem of having bugs.
11:59:35 <Hannibal_Smith> So EvilMachine all I can say is...good luck! :asd:
11:59:40 <EvilMachine> :D
11:59:41 <shergill> EvilMachine: my point was just that it's not just that things suddenly become different with external processes. there's uncertainty and things you take on trust even with internal thought processes
11:59:49 <EvilMachine> You guys are, again, awesome.
12:00:08 <EvilMachine> shergill: Yep. I understood that.
12:00:19 * hackagebot threads 0.5.0.2 - Fork threads and wait for their result  http://hackage.haskell.org/package/threads-0.5.0.2 (BasVanDijk)
12:00:33 <EvilMachine> shergill: Which is just another part of nature.
12:01:38 <shergill> EvilMachine: or it's all in your head :P
12:01:56 <EvilMachine> shergill: Then I must really hate myself. ;)
12:02:16 <carter> Philippa EvilMachine  yeah, but it only allows k faults or something
12:02:22 <EvilMachine> So wait… damn… *Is* “applying the scientific method to bug finding” *the same* as “(unit) testing”?
12:02:23 <shergill> we're all secret masochists. we just don't know it yet
12:02:37 <carter> i'm being pedantic though. Just run the machine in a lead shielded room. Problem sovled. :)
12:02:48 <sproingie> cosmic rays laugh at your puny lead shield
12:02:58 <carter> sproingie i Add more Lead
12:03:00 <EvilMachine> shergill: Kim Yong Un too? He seems to live a pretty kick-ass super-egocentric life…
12:03:11 <sproingie> carter: a useful maxim for many situations
12:03:25 <shergill> EvilMachine: i'd be in pain if i had that kinda hair
12:03:25 <carter> yes, like when fighting zombies!
12:03:37 <EvilMachine> carter: The quantum foam laughs art your lead shield too. ;)
12:03:44 <EvilMachine> s/art/at/
12:04:18 <carter> is it easy on the eyes shower quantum foam from Johnson and Johnson Baby Shampoo/?
12:04:20 <EvilMachine> shergill: Aaaand we’re officially off-topic. XD
12:04:23 <carter> yup
12:04:26 <carter> I win!
12:04:35 <carter> as does everyone else
12:05:18 <EvilMachine> carter: Have fun with your cancer from using those products. XD
12:05:28 <carter> eh?
12:05:33 <carter> thats weird humore
12:05:58 <carter> on an amusing note: check out the madness of Node's new streaming class http://blog.nodejs.org/2012/12/20/streams2/
12:06:17 <EvilMachine> Okay, about my question from before:  *Is* “applying the scientific method to bug finding” *the same* as “(unit) setting”?
12:07:28 <EvilMachine> carter: “Weird” is my middle name. And my title of nobility. And what I have a doctor in. ;)
12:08:01 <EvilMachine> Damn, gotta go. Thank you all very much! This helped a great deal.
12:08:21 * EvilMachine levels up.
12:12:46 <edwardk> EvilWeirdMachine
12:14:46 <carter> yeah
12:15:14 <carter> http://sandiego.toorcon.org/index.php?option=com_content&task=view&id=140&Itemid=9
12:15:22 <carter> relevant: weird machine zoo
12:15:49 <carter> http://www.cs.dartmouth.edu/~sergey/langsec/ a bunch of computer security people who've realized types + reasoning about code + power of apis = security
12:16:01 <fragamus> :t >>=
12:16:03 <lambdabot> parse error on input `>>='
12:16:07 <fragamus> :t (>>=)
12:16:08 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:16:13 <tac> carter: needs more PHP code reviews
12:16:22 <fragamus> :t (==>)
12:16:23 <lambdabot>     Not in scope: `==>'
12:16:23 <lambdabot>     Perhaps you meant one of these:
12:16:24 <lambdabot>       `==' (imported from Data.Eq),
12:16:32 <fragamus> :t (=>>)
12:16:34 <lambdabot>     Not in scope: `=>>'
12:16:34 <lambdabot>     Perhaps you meant one of these:
12:16:34 <lambdabot>       `>>' (imported from Control.Monad.Writer),
12:17:03 <fragamus> :t join
12:17:04 <lambdabot> Monad m => m (m a) -> m a
12:17:20 <fragamus> :t duplicate
12:17:21 <lambdabot>     Not in scope: `duplicate'
12:17:21 <lambdabot>     Perhaps you meant one of these:
12:17:21 <lambdabot>       `replicate' (imported from Data.List),
12:17:34 <fragamus> hmmmmm
12:17:46 <Hermit> /msg lambdabot :t replicate  -- fragamus
12:18:36 <Hermit> /msg lambdabot @ty replicate -- fragamus
12:21:02 <hpaste> smarter pasted “sim.hs” at http://hpaste.org/83869
12:21:12 <smarter> ^ any tip on making this less ugly?
12:29:05 <Hermit> smarter: to you, what's ugly about it?
12:29:37 <smarter> there's a lot of state passing
12:29:50 <smarter> and using the Reader monad seems to make things more complicated
12:30:55 <smarter> (for example, with the "unavail" parameter of the recover* functions)
12:33:00 <Hermit> smarter: first of all, why are you passing unavail to go as an explicit parameter? it's already in scope
12:33:23 <smarter> ah you're right, I forgot that when I made a go an inner function
12:33:40 <Hermit> same goes for bSeen
12:34:03 <smarter> yup
12:34:41 <k00mi> you also don't need the guards, just use || and &&
12:34:56 <k00mi> in the recover* functions
12:35:21 * Hermit seconds that
12:36:00 <joker_89> hi
12:36:07 <joker_89> is any channel of lambda-calcul?
12:36:18 <monochrom> not exactly
12:36:47 <tromp__> you wany to discuss lambda calculus?
12:36:57 <joker_89> about an expresion
12:36:59 <hiptobecubic> joker_89, this one probably has the highest density of people who would know enough to have a discussion about it.
12:37:18 <Hermit> an even if you want to do it with guards, don't go mixing definition patterns AND guards... for example in recoverBlock, just use a guard and  b@(Block id _) so you get the two necessary bindings
12:37:22 <Hermit> smarter: ^
12:38:27 <joker_89> onlly is about pharentesis, if i have lambdax(lambday(lambdaz( x z z y x z))) is the same as= lambdax(lambday(lambdaz( ((x z) z) (y (x z))))) ?
12:38:55 <tromp__> no
12:39:16 <tac> joker_89: application is not associative
12:39:16 <monochrom> no, ((((x z) z) y) x) z
12:39:21 <smarter> Hermit: you mean, use b@(Block id _) and || ?
12:39:21 <napping> Ah, looks like Uustalu and Vene might be the paper I need
12:39:23 <tac> (x y) z /= x (y z) in general
12:39:33 <joker_89> ok i see
12:39:39 <Hermit> smarter: totally
12:39:59 <joker_89> so, can i reduce something? lambdax(lambday(lambdaz( ((x z) z) (y (x z)))))
12:40:03 <joker_89> pharentesis
12:40:07 <sproingie> your syntax is confusing
12:40:14 <mauke> \x\y\z.x z z (y (x z))
12:40:14 <tromp__> you need an abstraction to reduce
12:40:15 <napping> I'm checking how generally futumorphisms are a valid corecursion scheme
12:40:27 <hiptobecubic> joker_89, the wikipedia page actually does ok at introducing this, i thought.
12:40:31 <monochrom> you can use "(x z z)" for "((x z) z)". that's about it
12:40:32 <Hermit> recoverBlock unavail b@(Block id _) = id `S.notMember` unavail || recoverBlock' unavail S.empty S.empty b
12:40:36 <tromp__> you need an applied abstraction
12:40:36 <Hermit> smarter: ^
12:40:37 <joker_89> i go to see wiki
12:41:09 <tac> joker_89: just to give you an example, take         plus1 (double 5)   vs     (plus1 double) 5         <--- the second one doesn't even "make sense" (it's not well-typed)
12:41:14 <Hermit> smarter: otherwise your patterns are redundant in that  id `S.notMember` unavail already returns true, but you are returning true manually
12:41:25 <smarter> Hermit: I kinda like pattern guards for getting things out of the way, but getting rid of them looks nice too
12:41:38 <hiptobecubic> tac, you're assuming that he's doing typed lambda calculus, no?
12:41:42 <tromp__> i made a new graphical notation for lambda terms
12:41:57 <tromp__> at http://homepages.cwi.nl/~tromp/cl/graphical.html
12:42:11 <tac> hiptobecubic: If you erase the types, you can an untyped version which doesn't make sense
12:42:19 <tac> but yeah... it's just an illustration
12:42:38 <hiptobecubic> tromp__, oh. You must be next door.
12:42:44 <Hermit> smarter: what I told you earlier, if you want to use a guard anyways (even though it becomes redundant), do it like this: recoverBlock unavail b@(Block id _) | id `S.notMember` unavail = True | otherwise = recoverBlock' unavail S.empty S.empty b
12:42:49 * hiptobecubic is at the main science park building
12:42:58 <GNUrants-fb82> well, OLPC has an irc client, but can I run GHC on it?
12:43:11 <Hermit> smarter: instead of having a left-alone guard there
12:43:11 <tromp__> i'm no longer at CWI
12:43:16 <smarter> Hermit: ah right, I forgot about that syntax
12:43:22 <sproingie> tromp__: you could probably turn that into some nifty art
12:44:05 <tromp__> yes, the diagram at http://homepages.cwi.nl/~tromp/cl/cl.html looks pretty artistic
12:44:28 <tromp__> like some modern art
12:44:35 <Hermit> smarter: but you got it right in sample...
12:44:55 * smarter spent too much time doing scala :p
12:44:59 <sproingie> tromp__: what's the y combinator look like?
12:45:18 <tromp__> i still have to add that one
12:45:26 <tromp__> you can figure it out yourself?!
12:45:59 <carter> lispy: i might be finally hacking on a ggplot2 like with diagrams lib starting later this week btw
12:46:34 <Hermit> GNUrants-fb82: has linux? is x86? sure
12:48:44 <hiptobecubic> tromp__, this is actually pretty intuitive once you've looked at it for a few minutes
12:49:11 <Hermit> smarter: line 60, you don't need to put parens there
12:49:14 <k00mi> carter: did you see the -cafe posts regarding plotting?
12:49:20 <hiptobecubic> I'm not sure if it's any easier than just typing \fx.f(f(f x)), but it's neat anyway.
12:49:22 <carter> k00mi yeah
12:49:30 <k00mi> ok
12:49:40 <carter> i think doing that well is beyond what you can sanely plan out as a group student project...
12:49:52 <k00mi> i see
12:50:17 <tromp__> agreed; hiptobecubic
12:50:33 <carter> i say this as someone who'd love it if someone else wrote that for me, but i've also spent a lot of the past year planning out / designing related tools
12:51:03 <carter> if the API isn't *right* and easy
12:51:07 <carter> its useless
12:51:26 <k00mi> i agree
12:51:46 <carter> and theres some problems with naive strategies for plotting when you have large point sets that need to be thought of very very carefully when you're targetting vector backends
12:52:18 <carter> If i'm getting an SVG of a scatter plot of 2B points, but i'm only going to be viewing it ever at a 2k x 2k resolution, I don't want a 1gb svg
12:52:39 <carter> so you need to have some machinery to a) simplifly the resulting rendering
12:52:55 <carter> b) mitigate object complexity
12:53:01 <carter> c) make that a natural part of the api
12:53:33 <carter> because the "oh, subsample before you plot" approach doesn't educate a user methodologically
12:53:47 <carter> and also is contingent on subsampling *correctly*
12:54:34 <carter> the plotting API and docs should not have such hidden external "gotchas"
12:55:05 <Hermit> smarter: so, not so ugly now?
12:55:07 <k00mi> you seem to have put quite some thought into this, i hope it pays of and we will have a neat plotting library soon :)
12:55:21 <joker_89> this \y. z \x. y x \y. x y == (\y. z) (\x. y x) (\y. x y) ?
12:55:22 <carter> k00mi i do too!
12:55:29 <smarter> Hermit: it's better :)
12:55:44 <augur> ski: syn
12:57:45 <smarter> I wonder if there is some abstraction for the pattern of "when going down the call stack, remember where you come from because the data structure is cyclic"
13:01:19 <GNUrants-fb82> hey, is there any haskell-ada project going on
13:01:27 <GNUrants-fb82> I want to compile Ada to Haskell
13:01:33 <GNUrants-fb82> because ADA
13:01:58 <tromp__> ok, Y added
13:02:29 <tromp__> oops; it has a bug
13:03:03 <carter> k00mi : i've been generally attacking this + related bits according to the metric "how can i design a set of libraries / APIs so nice that data analysis folks who don't use haskell will want to make the jump"
13:03:54 <GNUrants-fb82> I'm kidding about the Ada btw
13:04:14 <GNUrants-fb82> also yeah I'd like to see some migration from R to Haskell
13:04:16 <GNUrants-fb82> that would be great
13:04:26 <tromp__> fixed now
13:05:21 <Ralith> carter: how's that going?
13:05:35 <carter> Ralith slowly but well
13:05:49 <Ralith> good to hear
13:06:18 <carter> bootstrapping is hard work,
13:06:26 <GNUrants-fb82> carter: any good sequence analysis stuff?
13:06:27 <Ralith> I've been hagning out with some analysis types and you can really tell there's room for something better
13:06:38 <Ralith> R is just crap design-wise
13:06:43 <carter> GNUrants-fb82 what sort of sequence ?
13:06:55 <Ralith> and its users seem to know it
13:07:09 <GNUrants-fb82> I'm doing some genome analysis work and we're pretty much stuck in R
13:07:11 <GNUrants-fb82> which sucks
13:07:14 <carter> Ralith yes, and the maddening thing is that so many folks who use R don't understand how theres room for soemthing better aside from "its slow"
13:07:44 <carter> GNUrants-fb82 what sort of data set size and algorithms?
13:07:53 <Ralith> I'm sure they'll eagerly learn better, given opportunity and evidence
13:08:44 <GNUrants-fb82> actually I think Haskell already has the functionality that we were using
13:08:51 <Ralith> hah
13:09:27 <GNUrants-fb82> but the data set is a very long list of 'a's 'g's 'c's and 't's
13:09:36 <carter> Ralith: i've a nice list of potential business customers for the enterprise paying level once i get it working
13:09:56 <Ralith> they've indicated explicit interest?
13:09:58 <GNUrants-fb82> millions to billions long
13:10:07 <carter> right now just making sure i have enough part time consulting income pipelined for the next few months so that i can keep on monotonically working on bulding the tools with my time
13:11:36 <tromp__> sproingie, i just realized i also had Y in the middle of the primes diagram on my ~tromp/cl/cl.html page
13:13:19 <shanse> carter: i'd love to ditch r for haskell
13:13:31 <carter> GNUrants-fb82 so gb or tb?
13:14:49 <GNUrants-fb82> well, for what we were doing we were able to just look at small parts of bacterial genomes, so small enough to fit in memory
13:15:16 <sproingie> tromp__: ah yes the SK version of it.  wonder what that looks like.
13:15:27 <sproingie> probably a lot twistier than the straightforward version
13:17:32 <carter> shanse working on it
13:18:05 <carter> note: not all of it will be open source initially, i'm leaning towards basically having a haskell platform + my stuff baked in for like $20 for noncommercial use :)
13:18:46 <joker_89> in labmda calcus is equal \y. z \x. y x \y. x y == (\y. z) (\x. y x) (\y. x y) ?
13:18:54 <GNUrants-fb82> I'm sure there are people that would pay to not have to use R
13:19:15 <tromp__> well this notation is not so great for combinatory logic
13:19:20 <edwardk> GNUrants-fb82: thats kind of the idea behind building up github.com/analytics ;)
13:19:20 <carter> GNUrants-fb82 yes. LOTS.
13:20:21 * hackagebot penny-lib 0.8.0.0 - Extensible double-entry accounting system - library  http://hackage.haskell.org/package/penny-lib-0.8.0.0 (OmariNorman)
13:20:25 <tromp__> although you could write them in the form \S.\K. C
13:22:33 <tieTYT2> why can't I do this "I, B. Ionsonii, uurit a lift'd batch" =~ "(uu|ii)" :: [String]
13:22:43 <tieTYT2> No instance for (RegexContext Regex [Char] [String])      arising from a use of `=~' at <interactive>:1:0-50
13:22:58 <tieTYT2> apparently this used to be possible
13:23:30 <tieTYT2> now you've gotta do something like:  concat $  "I, B. Ionsonii, uurit a lift'd batch" =~ "(uu|ii)" :: [[String]]
13:23:31 <preyalone> How can I create a list containing every value of an enumerated data type?
13:23:55 <tieTYT2> preyalone: is it an Ord?
13:24:04 <preyalone> tieTYT2: It can be.
13:24:09 <tieTYT2> because then you could just do [First..] I think
13:24:16 <Sgeo> Needs to be enum, I think
13:24:17 <preyalone> Oh cool
13:24:19 <shanse> carter: if you have something open source, please share
13:24:21 <Sgeo> erm, Enum
13:24:22 <tieTYT2> oh yeah maybe enum
13:24:23 <mauke> preyalone: [minBound .. maxBound]
13:24:37 <carter> shanse some bits will be, but i need to also make sure i have income
13:24:41 <Sgeo> :t minBound
13:24:43 <lambdabot> Bounded a => a
13:24:47 <preyalone> I happen to be coding Poker cards for different games, so I wasn't sure if I wanted to introduce an inherent Order.
13:25:15 <tromp__> is that the same as [minBound..] ?
13:25:21 * hackagebot penny-bin 0.8.0.0 - Extensible double-entry accounting system - binary and documentation  http://hackage.haskell.org/package/penny-bin-0.8.0.0 (OmariNorman)
13:25:40 <Sgeo> Oh hey cards are a case where it would be nice to have multiple instances for the same class!
13:25:46 <GNUrants-fb82> hey, does anyone here think F# will go anywhere?
13:25:46 * Sgeo glares at Haskell
13:26:23 <GNUrants-fb82> microsoft keeps making new languages
13:26:31 <GNUrants-fb82> and I don't like any of them
13:26:35 <Heffalump> GNUrants-fb82: it's already going somewhere...
13:26:44 <mauke> microsoft makes haskell
13:27:02 <tromp__> more like funds
13:27:09 <carter> F# has some seriouse interest / use in the finance space. Because many shops are .net based
13:27:34 <hiptobecubic> carter, I'll politely disagree.
13:27:53 <hiptobecubic> carter, unless you mean "on the scale of functional languages", which is no where near "serious interest" in any other context
13:28:13 <tieTYT2> why can't I do this "I, B. Ionsonii, uurit a lift'd batch" =~ "(uu|ii)" :: [String]
13:28:20 <carter> hiptobecubic i'm just speaking from seeing interest in the NYC area in person
13:28:40 <carter> i do not claim to be a finance expert
13:28:42 <carter> at all
13:28:50 <Heffalump> hiptobecubic is right, it's small compared to "big" languages
13:29:00 <GNUrants-fb82> yeah I saw that it was getting some application in finance
13:29:09 <Heffalump> but I dunno how it would compare to e.g. R in scale of usage
13:29:21 <Cale> carter: I've seen more references to O'Caml and Haskell in that area than I have F#
13:29:27 <hiptobecubic> Heffalump, no where close to R or Matlab.
13:29:27 <carter> ah
13:29:55 <Cale> (But I can't claim to know what's really going on there :)
13:31:06 <hiptobecubic> Every person I've talked to working in the industry has said the same. C++ still runs the show with Java being used for everything else. If you find some nice little boutique places where developers make big decisions instead of managers, then you start to see more "fun" languages
13:31:20 <tieTYT2> i think F# has a good chance because you can leverage all the other libraries in the .NET ecosystem
13:31:22 <preyalone> Why can't Enum be derived for complex GADTs?
13:31:33 <Heffalump> there are big banks using F# and Haskell
13:31:50 <tieTYT2> and embed it into your code AFAIK.  EG: this backend snippet makes more sense if it was written functionally, let me just write some F# here
13:31:55 <tieTYT2> even though the rest of the system is C#
13:32:01 <Heffalump> preyalone: did you try StandaloneDeriving?
13:32:24 <Heffalump> tieTYT2: sadly the project system forces you to use a separate project for F# code
13:32:29 <Heffalump> thus making snippets harder
13:32:36 <hiptobecubic> But by "fun" I mean Python instead of Java. I have yet to meet anyone in person that gives two damns about F#, Haskell, or OCaml. Scala is creeping in as "nicer java".
13:32:37 <tieTYT2> i see
13:33:08 <Heffalump> I would be somewhat surprised if Scala is an order of magnitude more used than F#
13:33:24 <GNUrants-fb82> I think Scala needs to just overtake Java as "the" JVM language
13:33:25 <hiptobecubic> Among people doing financial research it's matlab or die
13:33:41 <preyalone> Heffalump: Could you give an example?
13:33:47 <tieTYT2> Heffalump: http://visual.ly/most-popular-programming-languages-2013
13:34:00 <Heffalump> preyalone: {-# LANGUAGE StandaloneDeriving #-} at the top of yuor source file
13:34:09 <Heffalump> then "deriving instance Enum Wibble"
13:34:16 <Heffalump> somewhere int he code
13:34:16 <GNUrants-fb82> if Scala gains in popularity then more people will be at least somewhat familiar with functional programming
13:34:20 <sproingie> if scala became the dominant mainstream language, it would be held back by the same conservative attitudes that have crippled java
13:34:25 <Heffalump> instead of "deriving Enum" after the definition of Wibble
13:34:27 <hiptobecubic> sproingie, ++
13:34:30 <simpson> hiptobecubic: So, uh, I'm sorry that you haven't had many adventures yet. I know *many* people that know of Haskell.
13:34:33 <tieTYT2> Heffalump: this agrees: http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html
13:34:41 <sproingie> mind you at least it'd be held back in a better state than java, but held back nonetheless
13:34:45 <monochrom> sproingie++
13:34:48 <S11001001> sproingie: just why I'm not eager to see scala adoption accelerate
13:34:49 <hiptobecubic> simpson, I mean at work. Not for fun on saturday.
13:35:01 <hiptobecubic> simpson, but even those people are few and far between. :/
13:35:03 <simpson> hiptobecubic: I'm Oregonian; Galois is in Portland, OR.
13:35:16 <sproingie> the number of languages i'd like to see achieve world domination is zero
13:35:18 <Heffalump> tieTYT2: so scala is 2x F#
13:35:19 <GNUrants-fb82> there's this "objects first" thing going on in education, and if Scala took over that would die
13:35:27 <simpson> And Portland State is a warm spot of Haskell research.
13:35:36 <tieTYT2> according to this site, yes
13:35:42 <hiptobecubic> simpson, well you're hardly going to be representative of the rest of the industry then
13:35:44 <sproingie> GNUrants-fb82: except scala is also object oriented and there's nothing that says that it wouldn't be taught that way
13:36:07 <simpson> hiptobecubic: Hm. Who do you consider to be "the industry?" :3
13:36:12 <hiptobecubic> sproingie, GNUrants-fb82 it's already taught that way.
13:36:15 <tieTYT2> isn't harder to have mutable state in scala than immutable?
13:36:15 <hiptobecubic> simpson, finance.
13:36:21 <GNUrants-fb82> aaaack
13:36:25 <simpson> hiptobecubic: Oh! Ask edwardk?
13:36:30 <preyalone> Heffalump: I need a little more guidance. I've added the directive to the top of my code file, but I'm not sure how to use the weird deriving instance syntax. I only know of the standard data... deriving (...) syntax.
13:36:36 <thoughtpolice> there are people using Haskell for finance
13:36:37 <edwardk> ?
13:36:41 <thoughtpolice> including alphaHeavy and Tsuru
13:36:45 <hiptobecubic> simpson, i think we all know that edwardk is not representative of normal anything. :D
13:36:45 <Heffalump> preyalone: just put it on a line on its own
13:36:46 <sproingie> i don't want to see any language get a leg up the way C and Java have.  i want people to actually choose from a wealth of options.
13:36:52 <thoughtpolice> jane street cares a lot about ocaml, too.
13:37:04 <Heffalump> I work in finance and I know lots of people who know about F# and Haskell :-)
13:42:19 --- topic: '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.2 http://v.gd/oXnqjU ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","If Hackage is down, try: http://hdiff.luite.com "]'
13:42:19 --- topic: set by monochrom on [Tue Jan 29 09:36:42 2013]
13:42:19 --- names: list (clog_ bogner_ _jmcarthur sordina2 phischu osa1_ tippenei1 elgot_ cognominal Natch_q motonarola cdidd HugoDaniel permagreen cmsmcq juxovec_ hattusili_III kylcarte eikke pantsman luksow preyalone tieTYT2 acharles ajhager cajla hrehf Lethalman schovi x7a1c0b Aune chidy AfC bos realnot s_quark fmapE TravisD message144 favonia nexx mindCrime madjestic fgomez hiroakip threesome bitonic sellout- shurikas miclorb xymox gridaphobe niklasb neju|AFK Amadiro Brando753)
13:42:19 --- names: list (tensorpudding Franciman_ augur GNUrants-fb82 IbnFirnas napping joker_89 niloc132 Ralith peterhil issimus1 sleepynate bezik ymasory ksf_ [swift] kcj hughfdjackson jedai|2 MoALTz shutdown_-h_now twopoint718 Zedrikov davidsd alszar enquora Tesseraction_z Sonderblade KaneTW fsvehla arpunk ChongLi rogovski squidz DanBurton Afish emmanuelux macrover DexterLB mikmik Pranz nighty^ jesnor _br_ kmels__ Thra11 basdirks mee Paprikac_ monqy edwardk ozgura conehead)
13:42:19 --- names: list (gentleben k0001 junsuijin Tharugrim solancile cads mjs2600 martint banjara Thomyho7 agr ivan____ sarfraz leroux ISF_ conal mrsolo joelb sepp2k1 redjohn donri morazow nus c_wraith vehk dmarker Starfire Reite silver chatsiri_ savonarola MrFahrenheit simon___2 Philippa Nisstyre natechan mceier PHO_ awestroke jmelesky collin_ dgvncsz0f tdammers osa1 dmac ecuderpam elliott whaletechno julmae Chaze jssanders _jwest tac anderse Jaak kaoskorobase Sculptor monique_)
13:42:19 --- names: list (eff dolio alanz tcsavage tsinnema erkin q66 meyersh kennyd levi stat_vi zoktar Swizec nonymousa sohum joeyh fotc jtalk Obfuscate kini shanse ryanakca djanatyn Jello_Raptor niko ortmage ivan` tridactyla PaksAway pxdr NougatRillettes xrl_ fergusnoble petantik ben_d hungryblank arkeet dju ]OLI[ leprauchan augustl theorbtwo jyyou vobi mokus neurocyte raek dlundy jtobin birkenfeld flux ibid fabjan formalcow osfameron paintcan uniquenick akamaus pricklypear saml)
13:42:19 --- names: list (`^_^v kmels ericmj pmade hiptobecubic janbanan MrFenix_ araujo heath derdon mapf mgile u_ dEPy dschoepe skuggi heruur guampa brisbin malkomalko Vq Fubar^ xinming einsof tanakh_ projedi k00mi ghorn_ gustavnils mephx jonke liyang doomlord koninkje_away SoupE tomboy64 gal_bolle [[zz]] asante azaq23 l0p3n AtomicStryker Icewing kmels_ canta rodlogic malthe|away psii copumpkin gwern jesyspa agumonkey Sebastien-L diagramed72 [mth] lennart_ yitz gdsx ctype_real)
13:42:19 --- names: list (`ramses milessabin mtahmed folone davean piotr Cale Alice3 LAMMJohnson thoughtpolice davorak DT` sh Rarrikins hamishmack kadoban_ CoverSlide wollw EarlGray DaDaDosPrompt zaltekk hiratara ivan\ wormphlegm kranius skp preflex Jesin mauke kerrick Igloo Mathnerd314 Rickasaurus tanakh shepheb AntiSpamMeta Derander jcp dfletcher KaiSforza predator117 delimax setmeaway apaku netj cmccann pcapriot1i Estrellas notthemessiah TheFuzzball DrCode niteria etabot)
13:42:19 --- names: list (techlife otters helgikrs wting boris`` drbean bytbox_ Gurragchaa hpc Jonte_ kennyp_ a11235 Nickeeh_ Ke blackmir1oxx Ornedan_ mirsal Draconx Varakh machisuji_ tromp__ dflemstr_ maksbotan_ MasterPuncher v0|d` plat0 mrkotfw mgsloan bartavelle raid thirsteh_ mimi_vx Bigcheese SeanTAllen HaltingState froztbyte kqr1 saep drewr Volstvok dreixel Sgeo tg Th0mas latro`a XMunkki liesen UziMonkey Vert albel727 abumirqaan Valodim arnihr_ perlite electrogeek torkjak)
13:42:19 --- names: list (mel- mmaruseacph2 isomorphic Pwngu bergey carlocci aajmakin sclv u_quark tippenein BlankVerse lazard cods az noam jliikka OlegYch2 ps-auxw merijn klugez filipe1 BMeph_ Fuuzetsu cwvh edwtjo ninzine Xorlev Maxdamantus obcode hiredman rfw fragamus Khisanth covi lenstr newsham tanakh___ Jonno_FTW trep saiam weie kith ByronJohnson numeral lusory ZFox jaimef LeninParty connelly majoh jlouis fireglow benzap dkasak em mspells ParahSail1n orospakr anona Chousuke)
13:42:19 --- names: list (luite wto rkj inr akosch dented42 IanKelling lpvb Nshag Dashkal tieTYT gbeshers ozataman Hermit gcmalloc otto_s tunixman simpson mietek zachk pettter MK_FG cdntr andrewsw Hafydd joe9 Baughn DarkAceZ johnw dropdrive igrekster osnr `nand` hive-mind parcs tew88 fogus|away ParahSailin brandonw Shane__ quuxman shergill tim2 rmarianski dan_johnsin plhk S11001001 cow-orker gienah mikeplus64 miasma mateu ccxCZ lahwran waterlaz frerich2 Erstarrung wtw freiksenet)
13:42:19 --- names: list (noj seats tavelram_ chirpsalot mattp_ jbauman Tarential mshroyer Ghoul_ armlesshobo colah quaestor fcr Guest22595 ent mullein kshannon fayden bxc Soft mrshoe JoshuaA `bps gbarboza clahey sm ousado PartyKat2e mpu alios_ iulian amiller CosmicRay etrepum PrO_OkI chrisbuchholz_ scgilardi tahu mornfall arkx sgronblo cyphase Tordek kaol alshain suiside_ s4msung_ Internet13 Nik_89 cmsd2 qwandor|quassel certainty nathanel_ pikhq knz paddymahoney tomku eacameron)
13:42:19 --- names: list (gthorslund museun tsou wilfredh charlesofarrell joachifm hvr matzo FireFly dario ab9rf marienz Bwild pharaun jlewis MasseR dixie Heffalump aleator_ Shozan dsantiago Eiam dakaktak Kuba dabradley ethercrow Scott_fi1ebeta Guest19871 melter Riussi robbert BrianHV schroedinbug alexander__b mlh MrMeh Entroacceptor nicoo leoncamel McManiaC rcj_ mixi peddie Razz henk aszlig ptrf Jaxan Will| int-e Martty SegFaultAX ernst byorgey ft ndngvr purefn magaio_ mapreduce)
13:42:19 --- names: list (__main__ Fuco snorble_ companion_cube Twey frio jayne tessier bobry puzza007 lopex tomh_ strax_ si14 akraut yumike jacobw LeaChim VZakharov dilinger yam tkd ocharles Rembane nanothief arun barrucadu Adios julmuri zz_nh2 xnyhps guy_ earthy OnionKnight morolin jaspervdj BigEndian dennda_ herself shachaf chr1s sbahra levitation_ xplat canvon chrisirc identity blooberr mimico__ FalkoPeters akahn warpy__ Daminvar dumbhat bcoppens kosmikus wolong gemelen)
13:42:19 --- names: list (The_third_man wereHamster zorzar jix whoops Nanar zebr ski SLi wei2912 kakos floatingman Excureo JPohlman1 alcz ninegrid stepcut tlaine comak mcint taruti lokydor crdueck TDJACR mahogny Gunni nimred flori hachiya Natch wchun k0ral krig_ jackhill mrdomino_ rmunroe_ jdhky sheerun AtnNn jrslepak jmcarthur mjr84 Gracenotes bgamari vmeson Enigmagic ahkurtz_ mechairoi d-snp zeiris TML jrockway Dodek eL_Bart0 ehamberg idnar steez frontendloader sproingie hyko)
13:42:19 --- names: list (wumpus dcoutts fxrh fionnan C-Keen DrSyzygy betawaffle Counter-Strike Axman6 hanDerPeder finnrobi cynick mm_freak_ zenoli maltin kmic trevize_ pdxleif def-lkb bd_ aforemny Liskni_si pfoetchen Botje aninhume1 stelleg_away sordina1 so- DigitalKiwi peltchu eyck b52 rainmaker tamiko opqdonut mike2 gseitz tswett fall_ Raynes guymann joar yeltzooo WhereIsMySpoon ziman Shapeshifter harrison reiddraper aristid adnap horlicks stephe sirchurchill bogner robbe- arbn)
13:42:19 --- names: list (jercos Fluky ixian monochrom mannyv h_chiro sunnavy eataix ktosiek dmwit Walther gbluma lucca milli Sagi f8_ chrra ion CindyLinz drmegahertz tafryn supki Draggor KitB_ joneshf mendez lulf koala_man knyppeldynan lispy ggreg cjay cross alnix lambdabot rcl clog hpd Boney malorie_ jaroslaw hackagebot ccasin solirc thetallguy1 mortberg quicksilver anachron_ kloeri `0660_ Nimatek Tene Dybber Saizan moonlite hirsch__ yano Boreeas dottedmag Gothmog_ _flow_ sunfun)
13:42:19 --- names: list (Athas Ptival bbee ClaudiusMaximus smarter Zariel r126l drek verrens mux faen kalven caligula__ ToRA rs0 endojelly wjlroe Mortchek tomprince nikolah alkabetz tweakism jml linduxed Deewiant jlamothe appamatto kniu statusfailed noplamodo celery_ tobiassjosten Polarina pnielsen rio tomaw dqd tgummerer integral prh voyd gdeest Tehnix nlogax \rs ofan alpounet geekosaur xcvii lpsmith rcfox danr schlumpi magicman Guest10329 luminous td123 Belgarion0 zomg acfoltzer)
13:42:19 --- names: list (Eridius honza mefisto moben ique Megant Vorpal joeytwiddle b_jonas lembaswafer thorkilnaur trolling vhz edenc brainproxy hiroyuki2 tmiw JoeHazzers alang otterdam tvaalen Cryovat myme Eliel_ deavidsedice petekaz qwr lightquake ahf elliottcable zenzike mami popz mollerstrand Zzompp elgot sipa saurik agundry Spockz hpaste _janne yan_ Ulrar pyykkis qz notdan Plex- bholst ormaaj petanqk Adeon solarus Kinnison mlinksva tazjin_ pyrtsa liszt pr wunki confound liff)
13:42:19 --- names: list (gereedy adimit wagle fryguybob sjl bens Laney jrib dyreshark Clint Canar ahihi @ChanServ kkris natte othiym23 threedaymonk simon__ jamwt Gilly brixen KitB brett xaimus so BlastHardcheese chance jabirali n_b Jean ricepuddin munro ciaranm `micro fuho idoru DustyDingo faheem jerojasro bstrie guerrilla mrd sully absence banjiewen pqmodn Iceland_jack dinox x7)
13:42:19 -moorcock(freenode.net)- [freenode-info] channel trolls and no channel staff around to help? please check with freenode support: http://freenode.net/faq.shtml#gettinghelp
13:42:39 <preyalone> Oh come on, Haskell!!! GHC says it can't derive Enum for tuples. (,) is not enumerable.
13:43:16 <Botje> sounds sensible.
13:43:38 <Botje> what is the result of succ (3,3) ?
13:43:46 <Botje> (3,4) ? (4,3)? (4,4)?
13:43:56 <sproingie> (3,3,3)
13:44:01 <Botje> heh :)
13:44:02 <c_wraith> you can diagonalize
13:44:04 <hiptobecubic> sproingie, :)
13:44:15 <mauke> ((3,3),(3,3))
13:44:59 <GNUrants-fb82> yeah if you want something that's a tuple to be a member of Enum you pretty much have to write that yourself
13:46:18 <mauke> > let flrb = join (,) in flrb (flrb 3)
13:46:20 <lambdabot>   ((3,3),(3,3))
13:47:53 <sproingie> yeargh way to not catch that netsplit, irssi
13:48:25 <Botje> eh, I ignore joins/parts/quits on large channels anyway
13:49:14 <Hermit> sproingie: I didn't get "netsplit" either. They all ping timeouted. (briefly turned join/part/quit ignore off just to check)
13:49:44 <preyalone> Heffalump: I included the proprocessor. I included "deriving instance...", but GHC still complains that it can't derive Enums for PokerCard.
13:49:50 <isturdy> @pl f c = g c >>= h c
13:49:51 <lambdabot> f = liftM2 (>>=) g h
13:50:02 <Heffalump> preyalone: what's the error?
13:50:06 <Heffalump> I guess it means it, though.
13:51:47 <geekosaur> @hpaste full code and full error
13:51:47 <lambdabot> Haskell pastebin: http://hpaste.org/
13:53:23 <preyalone> Code: https://github.com/mcandre/mcandre/blob/master/haskell/cards/Poker.hs
13:53:26 <preyalone> Trace: https://gist.github.com/mcandre/5137648
13:54:22 <GNUrants-fb82> I uh
13:54:44 <GNUrants-fb82> I haven't looked at the code but if you're trying to derive enum for something that has a card number and a suit
13:54:49 <GNUrants-fb82> that's definitely not going to work
13:55:41 <preyalone> Ord is able to be derived, why not Enum?
13:55:50 <hpaste> Leonid revised “Array count”: “Array inclusion count” at http://hpaste.org/83870
13:56:09 <Botje> preyalone: you haven't answered my question
13:56:38 <Hermit> preyalone: because Ord compares the data "slots", in order, according to the criterion so it's derivable, so long as those slots contain Ord instances
13:56:56 <Hermit> preyalone: but what would be the sequence for a PockerCard?
13:57:08 <Hermit> preyalone: should it increment both? just one field? and if so, which one?
13:57:33 <monochrom> oh, "deriving Enum" has restrictions (to make compiler's life simple)
13:57:34 <Hermit> preyalone: hence, can't be done automatically without adding some special notation that's just not worth it
13:57:45 <preyalone> Ah, so succ really must be defined by the user.
13:57:47 <Hermit> preyalone: so, make your own instance
13:57:58 <Hermit> preyalone: :i Enum
13:58:15 <GNUrants-fb82> the instant "deriving" doesn't just give you what you want
13:58:19 <GNUrants-fb82> make your own instance
13:58:24 <Hermit> preyalone: your data must be able to implement all that, or it won't be part of Enum
13:59:00 <tromp__> i added some pictures of the lambda calculus prime number sieve to www.cwi.nl/~tromp/cl/graphical.html
13:59:21 <Hermit> (you could have incomplete instances, but that's not recommended unless you won't export the constructor at all)
14:00:55 <preyalone> How can I programmatically get the number of constructors of a data type?
14:00:56 <monochrom> tromp__: I don't completely understand the graphical notation, but the end result is intuitively right :)
14:01:27 <Botje> preyalone: if it implements Bounded and Enum, fromEnum maxBound - fromEnum minBound
14:01:28 <Sgeo> preyalone, it probably needs to belong to a typeclass, like Data or Generic or Typeable. Not sure which though.
14:01:34 <monochrom> cannot, unless you use SYB or template haskell. I only know template haskell, but probably overkill
14:01:38 <tromp__> wait; i left 17 composite:9
14:01:54 <Sgeo> I should learn how to SYB
14:02:44 <monochrom> but another angle is that you probably don't need to programmatically get the number of constructors.
14:03:44 <preyalone> minBount of the data type name?
14:04:14 <Hermit> minBound
14:05:02 <Hermit> preyalone: [minBound YourType..maxBound YourType]
14:05:26 <Hermit> preyalone: would be like [Ace..King] for Rank
14:05:29 <preyalone> Hermit: Thanks. I just want the length of this range.
14:10:02 * dmwit wonders what preyalone is planning to do with the number of constructors once he has it
14:12:29 <monochrom> length [minBound .. maxBound] = fromEnum maxBound - fromEnum minBound + 1
14:12:39 <Hermit> he left
14:12:48 <monochrom> oh well
14:13:00 <Hermit> monochrom: you don't need the minBound part, it's always 0, right?
14:13:00 <dmwit> fromEnum maxBound - fromEnum minBound seems like a really bad idea.
14:13:17 <dmwit> No. And the enumerated values aren't always consecutive, either.
14:13:19 <Hermit> (for this case)
14:13:29 <c_wraith> > fromEnum 1.0
14:13:31 <lambdabot>   1
14:13:36 <c_wraith> heh.
14:13:37 <dmwit> Especially when modeling an imported enumeration from C.
14:13:40 <c_wraith> > fromEnum 1.5
14:13:41 <lambdabot>   1
14:13:52 <c_wraith> I still think the enum instance for Double is terrible!
14:14:13 <dmwit> Enum in general is just a bit of a weird class.
14:14:20 <dmwit> Sort of... necessary. But uglily so.
14:14:40 <monochrom> I am assuming a very restricted context in which length [minBound .. maxBound] = fromEnum maxBound - fromEnum minBound + 1 is correct.
14:18:31 <Hermit> for types Rank and Suit, just  fromEnum (maxBound :: type) + 1  does the job
14:23:45 <Xaratas> hi, i have a print in my main function and a long running method in this print. At the moment the print is delayed until some internal buffer is full (~8000 chars), is there a print which displays result as fast as they come available?
14:24:10 <mauke> are you printing to a file?
14:24:24 <Xaratas> no
14:24:42 <Xaratas> i calculate magical squares which results in a big list
14:24:47 <mauke> ah, no newline then
14:25:18 <mauke> hSetBuffering stdout NoBuffering
14:25:35 <Dodek> hSetBuffering?
14:26:20 <Hermit> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
14:28:13 <Saizan> Xaratas: hFlush stdout after the print would also help, as an alternative
14:28:33 <mauke> but not during the print
14:29:46 <Xaratas> the current code takes ~8hrs to finish, i have not timed a full run, only saw that the first output was visible after ~55 min
14:30:16 <Botje> Xaratas: a quick fix is mapM_ print list instead of print list
14:30:51 <Hermit> D:
14:30:59 <Hermit> 1 hour to check if it's doing right
14:31:01 <Hermit> damn
14:31:27 <Hermit> I get impatient when it takes more than 30 seconds
14:31:48 <Xaratas> the testcase for magical squares of size 3 is solved instantly, size 4 is a bit more complex ^^
14:32:36 <Saizan> ah, yeah, if you are just printing out a huge list in one go hFlush won't help
14:34:22 <Sgeo> What's wrong with the hSetBuffering solution?
14:34:24 <monochrom> if stdout is a terminal, buffering defaults to line-buffered. just putStrLn or insert \n somewhere.
14:35:22 * hackagebot liblastfm 0.1.1.0 - Lastfm API interface  http://hackage.haskell.org/package/liblastfm-0.1.1.0 (MatveyAksenov)
14:37:04 <Xaratas> Sgeo: nothing is wrong, it works great
14:40:21 <jbu> hi all: in the statements of the form "class Monad m => MonadExc m where..." is "MonadExc m" a constructor?
14:40:54 <monochrom> no. MonadExc is the newly created type class name, m is a type variable.
14:41:32 <jbu> monochrom: so how does one create a MonadExc?  is that defined in the "instance ______"?
14:41:39 <hpc> yes
14:41:49 <jbu> thx
14:42:03 <hpc> for instance, (haha) instance MonadExc IO where ...
14:42:14 <monochrom> haha pun
14:42:39 <hpc> and the other place MonadExc will appear is in polymorphic types
14:43:13 <hpc> so supposing you were in ghci doing :t exec (or something else)
14:43:30 <hpc> it could hypothetically come up with exec :: MonadExc m => Action -> m ()
14:43:39 <hpc> or something like that
14:43:48 <hpc> it depends on the "..." in your class definition
14:44:03 <jbu> okay
14:44:04 <jbu> thx
14:45:23 * hackagebot io-streams 1.0.1.0 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.0.1.0 (GregoryCollins)
14:45:43 <hpc> simple? composable? easy to use?
14:45:53 * hpc braces self for a comonad dependency
14:45:56 <c_wraith> hpc: also they make toast
14:54:18 <Ralith> another stream library, eh?
14:55:05 <Ralith> doesn't look like it brings anything new to the table
14:56:31 <Mathnerd314> so why are there two different syntaxes for functions, f x = y and f :: x -> y ? I don't see any semantic reason one couldn't write f Int = Int and f :: x -> (x+1)
14:57:08 <Mathnerd314> is this just more historical baggage from the 70's?
14:57:24 <Ralith> ...what?
14:57:27 <tsinnema> when i recently finally took up learning haskell seriously, it was because i had some of my own ideas for yet another yet another stream library :D
14:57:32 <Ralith> those aren't "different syntaxes for functions"
14:57:37 <Ralith> one of those is a type declaration.
14:57:40 <Ralith> the other defines a value.
14:57:49 <Ralith> those are distinct operations.
14:57:53 <Ralith> they have different meaning.
14:58:01 <hpc> Mathnerd314: where would it stop! soon we would have to support f(x) {y} and push x; push esi; xor eax eax; xor eax y; pop; ret;
14:58:27 <Mathnerd314> > let f (x) (y) = x+y in f 1 2
14:58:29 <lambdabot>   3
14:58:52 <Sgeo> "IO stream operations are not thread-safe by default for performance reasons. However, you can transform an existing IO stream into a thread-safe one using the provided locking functions:"
14:58:58 <tsinnema> stream libraries are the new monad tutorial
14:59:03 <hpc> haha
14:59:37 <hpc> streams are like a chicago style hotdog...
15:00:01 <Mathnerd314> > let push _ = return (); xor _ _ = return (); pop = return (); ret = return () in runIdentity $ do { push x; push esi; xor eax eax; xor eax y; pop; ret }
15:00:03 <lambdabot>   Not in scope: `esi'Not in scope: `eax'
15:00:03 <lambdabot>  Perhaps you meant `max' (imported f...
15:01:23 <Mathnerd314> oh, I need indexed monads to implement it properly
15:01:25 <hpc> relatedly: xor eax eax is about the goofiest optimization i have ever seen
15:01:39 <Sculptor> really
15:01:54 <Sculptor> i remember that from 6502 days
15:03:25 <Mathnerd314> IIRC it's not an optimization anymore, but just goes through the same pipeline
15:04:19 <Mathnerd314> hmm, actually, it's a code size optimization (one byte shorter)
15:04:41 <Mathnerd314> *3 bytes
15:04:49 <hpc> Mathnerd314: yeah, at university they teach it as a way of getting more crap into the instruction cache
15:05:06 <hpc> which i suppose matters if you're actually down at that level
15:05:15 <hpc> otherwise, save it for the higher-level compiler courses
15:05:50 <Mathnerd314> well, you end up being on that level if you do any programming - kernel is written in C, etc.
15:06:11 <simpson> Kernel programmers don't care about 90% of that stuff.
15:06:20 <hpc> yes, i often think about the 3-byte difference in instruction size when i am coding in C :P
15:06:26 <simpson> Readability trumps nearly every other concern at that level.\
15:06:56 <elliott> you should see some of the stuff linux does
15:07:58 <hseg> Is it considered good style to maintain an explicit import list? Or am I just being pedantic?
15:08:21 <simpson> hseg: It's good style but often far too much typing.
15:08:38 <Mathnerd314> aren't there a few tools to maintain such a list?
15:08:38 <simpson> It's certainly acceptable style to import entire modules unqualified.
15:09:02 <hseg> Even when the imports from some modules, e.g. System.IO are several lines long as a result of this?
15:09:31 <elliott> a lot of people waive their rule to qualify imports (if they have one) for modules in base
15:09:36 <elliott> or "modules that come with GHC"
15:10:14 <yitz> it's a lot easier to read your code if every non-Prelude function is either defined in that very module, qualified, or mentioned explicitly in the imports
15:10:14 <hseg> Yeah, I import some modules in System, Control and Data unqualified.
15:10:57 <yitz> when you import non-qualified, you are basically assuming that everyone who ever reads that code in the future must know that module as well as they know the Prelude.
15:11:18 <Mathnerd314> http://gbacon.blogspot.com/2009/06/cleaning-up-your-haskell-imports.html
15:11:47 <yitz> or will have to spend lots of time searching for function definitions
15:11:57 <Mathnerd314> http://hackage.haskell.org/package/fix-imports
15:13:12 <yitz> hseg: there are definitely some modules in base that are very well known, that's true.
15:13:25 <Mathnerd314> https://github.com/jaspervdj/stylish-haskell
15:13:30 <Mathnerd314> http://www.haskell.org/haskellwiki/Import_modules_properly
15:13:55 <Mathnerd314> "For these reasons amongst others, the GHC project decided to drop the use of explicit import lists. We recommend using explicit import lists when importing from other packages, but not when importing modules within the same package."
15:14:05 <yitz> Mathnerd314: wow. you should post that list on the wiki if it's not there already.
15:15:33 <hseg> Nice. Thanks for the links.
15:15:43 <yitz> at work, i try hard to use explicit imports even within the same package, especially for larger ones. because i have felt the pain of trying to understand the code of people who didn't.
15:15:58 <yitz> for my own personal stuff i more often cut corners though.
15:16:29 <Mathnerd314> yitz:  pretty certain I don't have a wiki account, and apparently account creation is disabled.
15:17:08 <yitz> hmm, really? i think it just became manual due to link spam. i'm sure you can get an account if you ask for one.
15:17:29 <hseg> But in the case you know the person reading it will read the entire codebase, and it is quite small, I don't think it's necessary to maintain an import list from modules in the same project.
15:17:49 <yitz> hseg: ok also makes sense.
15:18:42 <yitz> hseg: the common case in commercial environments is that someday someone will be trying to do a small bug fix or feature enhancement in minimal time.
15:21:13 <hseg> Right. I'm working on homework in haskell.
15:21:33 <hseg> Actually, it's pretty awesome that I get to use Haskell for my homework
15:22:07 <hseg> Also, it's made more fun by the fact that I have had prior exposure to haskell from before getting the homework
15:22:20 <Mathnerd314> yitz: hmm, I suppose. that note is from 2008 though. http://www.haskell.org/haskellwiki/index.php?title=Special%3ALog&type=rights suggests byorgey might be able to give me an account
15:24:29 <yitz> hseg: that is awesome
15:25:12 <jbu> hi all: what does the "| m- > s" mean in "class (Monad m) => MonadState s m | m - > s where"
15:25:29 <Kinnison> it's a functional dependency (fundep)
15:25:37 <Kinnison> it says that s can be determined from m (IIRC)
15:25:38 <Mathnerd314> @google functional dependency
15:25:39 <lambdabot> http://en.wikipedia.org/wiki/Functional_dependency
15:25:39 <lambdabot> Title: Functional dependency - Wikipedia, the free encyclopedia
15:25:43 <yitz> jbu: the type s is determined by m.
15:25:55 <hseg> We get "esoteric, non-mainstream" programming language and have to write a compiler for a Java-like language in it.
15:26:00 <Mathnerd314> ^ not that functional dependency
15:26:11 <yitz> jbu: i.e. you guarantee that for any type m there will only be an instance for a single type s.
15:26:18 <Mathnerd314> this functional dependency: http://www.haskell.org/haskellwiki/Functional_dependencies
15:26:44 <jbu> yitz: thanks.  got an example to make it a bit more concrete for me?
15:27:02 <yitz> hseg: oh. well, what esoteric non-mainstream language is that? certainly doesn't sound like haskell. ;)
15:27:18 <Mathnerd314> jbu: http://www.haskell.org/haskellwiki/Functional_dependencies has two examples
15:27:27 <jbu> Mathnerd314: thanks
15:27:42 <hseg> Ha. One friend got Racket. Another got Mozart. A third got Vala. I got lucky.
15:28:43 <Kinnison> hseg: Your course includes writing a Vala compiler? wow
15:28:45 <ehamberg> never heard about lucky
15:28:49 <yitz> jbu: well, in the class you mentioned, in means that if there is an instance for MonadState Int (State Int), it is then not possible also to define an instance for MonadState String (State Int).
15:28:53 <Mathnerd314> hseg: no Maude?
15:29:10 <hseg> 'No, a friend has to write a compiler *in* Vala.
15:29:17 <jbu> yitz: okey doke. thanks
15:29:19 <Kinnison> hseg: Oh right, heh
15:29:39 * Kinnison has patches in valac, I wonder if that'd count
15:29:56 <hseg> Maude looks *awesome* for logic tasks.
15:30:07 <yitz> jbu: the reason it is important to tell the compiler that you guarantee that is otherwise the class methods become unusable. the compiler can't figure out from the context which instance you mean.
15:30:09 <hseg> But for writing a compiler... Ugh
15:30:56 <yitz> hseg: really? just the luck of the draw? wow, that's great.
15:31:25 <hseg> Actually, I maneuvered my way into the line in order to be selected for Haskell
15:31:29 <Mathnerd314> hseg: yeah, you'd have the same problem in Prolog and Mercury. Vala / Mozart / Racket are pretty standard as languages go, TBH
15:31:43 <yitz> haha
15:31:51 <Kinnison> hseg: Well, enjoy.  I've been learning about writing compilers in Haskell recently and I have to say it's fun
15:32:07 <hseg> Mozart? Seriously? From what I can see from my friend's code, it's a nightmare.
15:32:13 <Kinnison> hseg: I managed a BF->LLVM compiler about a week ago :-)
15:32:20 <hseg> Thanks.
15:32:29 <hseg> That sounds like fun.
15:32:34 <hseg> :-)
15:32:42 <Kinnison> hseg: It was, and maybe it'll end up on my youtube channel
15:32:47 <Kinnison> hseg: the parser and interpreter did
15:32:59 * Kinnison is not happy with the compiler right now though
15:33:05 <Kinnison> the haskell llvm binding is hard to use IMO
15:33:06 <hseg> I'll keep my fingers crossed then.
15:33:16 <yitz> Kinnison: see 99-bottles-of-beer.net for more candidates
15:35:57 <Mathnerd314> hseg: http://rosettacode.org/wiki/99_Bottles_of_Beer#Oz doesn't look too bad. Are you writing an interpreter or an actual compiler?
15:36:03 <Kinnison> yitz: well, it can compile and run that :-)
15:36:12 <hseg> Compiler.
15:36:13 <Kinnison> yitz: (the BF one :-)
15:36:24 <yitz> Kinnison: i meant for more candidate languages :)
15:36:30 <Kinnison> yitz: pfeh :-)
15:37:00 * Kinnison heads to bed, ciau all
15:37:09 <hseg> Basically, we're writing TECS projects 7-12
15:37:21 --- topic: '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.2 http://v.gd/oXnqjU ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","If Hackage is down, try: http://hdiff.luite.com "]'
15:37:21 --- topic: set by monochrom on [Tue Jan 29 09:36:42 2013]
15:37:21 --- names: list (clog cmsmcq_ dawe Y_Less TravisD Itkovian skeet70 [mth] ymasory Kiryx Rarrikins_g zeus toekutr spion schlaftier Beetle_jada hseg samedhi heruur amyers tommd cmsmcq silver_ OlegYch2 popz hattusili_III_ piotr__ corruptmemory jrajav jbu nwf dschoepe hive-mind rsuniev123 tjohnson tenmilestereo feliperosa eacameron roconnor_ nejucomo xalei mrsolo Xaratas DrChaos rafsoaken pzuraq gusto xunatai synonymous eikke m3ga bos kadoban h_chiro techlife filipe Thra11_)
15:37:21 --- names: list (tensorpudding JoeHazzers monochrom tippenein kk` jpeeters ToRA_ vmesons arbn_ gseitz_ Claudius1aximus quuxman_ stat_vi_ zenoli_ r126l_ sipa saurik_ Riussi_ kloeri mortberg_ bogner_ _jmcarthur sordina2 osa1_ elgot_ Natch cdidd HugoDaniel permagreen kylcarte pantsman luksow tieTYT2 acharles ajhager cajla Lethalman AfC realnot s_quark fmapE message144 nexx mindCrime fgomez hiroakip threesome miclorb xymox gridaphobe niklasb Amadiro Brando753 IbnFirnas joker_89)
15:37:21 --- names: list (niloc132 peterhil bezik ksf_ [swift] kcj hughfdjackson jedai|2 MoALTz shutdown_-h_now twopoint718 davidsd alszar enquora Tesseraction_z Sonderblade KaneTW fsvehla ChongLi squidz DanBurton emmanuelux DexterLB mikmik Pranz nighty^ jesnor _br_ kmels__ mee Paprikac_ monqy ozgura conehead gentleben junsuijin solancile cads banjara ivan____ sarfraz leroux ISF_ conal joelb redjohn donri nus c_wraith vehk dmarker Starfire Reite chatsiri_ MrFahrenheit simon___2)
15:37:21 --- names: list (Philippa Nisstyre natechan mceier PHO_ awestroke jmelesky collin_ dgvncsz0f tdammers dmac ecuderpam elliott whaletechno julmae Chaze jssanders tac Jaak kaoskorobase Sculptor monique_ eff tcsavage tsinnema erkin q66 meyersh kennyd levi zoktar Swizec nonymousa sohum joeyh fotc jtalk Obfuscate kini shanse ryanakca djanatyn Jello_Raptor niko ortmage ivan` tridactyla PaksAway pxdr NougatRillettes xrl_ fergusnoble petantik ben_d hungryblank arkeet dju ]OLI[)
15:37:21 --- names: list (leprauchan augustl theorbtwo jyyou vobi mokus neurocyte raek dlundy jtobin birkenfeld flux ibid fabjan formalcow osfameron akamaus pricklypear kmels ericmj pmade hiptobecubic MrFenix_ araujo heath derdon mapf mgile u_ dEPy skuggi guampa brisbin malkomalko Vq Fubar^ xinming tanakh_ k00mi ghorn_ mephx jonke liyang doomlord koninkje_away SoupE tomboy64 gal_bolle [[zz]] asante azaq23 AtomicStryker Icewing kmels_ canta rodlogic malthe|away copumpkin gwern jesyspa)
15:37:21 --- names: list (agumonkey Sebastien-L diagramed72 lennart_ yitz gdsx ctype_real `ramses milessabin mtahmed folone davean Cale LAMMJohnson thoughtpolice davorak DT` sh hamishmack CoverSlide wollw EarlGray DaDaDosPrompt zaltekk hiratara ivan\ wormphlegm kranius skp preflex Jesin mauke kerrick Igloo Mathnerd314 Rickasaurus tanakh shepheb AntiSpamMeta Derander jcp dfletcher KaiSforza predator117 delimax setmeaway apaku netj cmccann pcapriot1i Estrellas notthemessiah TheFuzzball)
15:37:21 --- names: list (DrCode niteria etabot otters helgikrs wting boris`` drbean bytbox_ Gurragchaa hpc Jonte_ kennyp_ a11235 Nickeeh_ Ke blackmir1oxx Ornedan_ mirsal Draconx Varakh machisuji_ tromp__ dflemstr_ maksbotan_ MasterPuncher v0|d` plat0 mrkotfw mgsloan bartavelle raid thirsteh_ mimi_vx Bigcheese SeanTAllen HaltingState froztbyte kqr1 saep drewr Volstvok dreixel Sgeo tg Th0mas latro`a XMunkki liesen UziMonkey Vert albel727 abumirqaan Valodim arnihr_ perlite electrogeek)
15:37:21 --- names: list (torkjak mel- mmaruseacph2 isomorphic Pwngu bergey carlocci aajmakin sclv u_quark BlankVerse lazard cods az noam jliikka ps-auxw merijn klugez BMeph_ Fuuzetsu cwvh edwtjo ninzine Xorlev Maxdamantus obcode hiredman rfw fragamus Khisanth covi lenstr newsham tanakh___ Jonno_FTW trep saiam weie kith ByronJohnson numeral lusory ZFox jaimef LeninParty connelly majoh jlouis fireglow benzap dkasak mspells ParahSail1n orospakr anona Chousuke luite wto rkj inr akosch)
15:37:21 --- names: list (dented42 IanKelling lpvb Nshag Dashkal tieTYT gbeshers ozataman gcmalloc otto_s tunixman simpson mietek zachk pettter MK_FG cdntr andrewsw Hafydd joe9 Baughn DarkAceZ johnw dropdrive igrekster osnr `nand` parcs tew88 fogus|away ParahSailin brandonw Shane__ shergill tim2 rmarianski dan_johnsin plhk S11001001 cow-orker gienah mikeplus64 miasma mateu ccxCZ lahwran waterlaz frerich2 Erstarrung wtw freiksenet noj seats tavelram_ chirpsalot mattp_ jbauman Tarential)
15:37:21 --- names: list (mshroyer Ghoul_ armlesshobo colah quaestor fcr Guest22595 ent mullein kshannon fayden bxc Soft mrshoe JoshuaA `bps gbarboza cl_away sm ousado PartyKat2e mpu alios_ iulian amiller CosmicRay etrepum PrO_OkI chrisbuchholz_ scgilardi tahu mornfall arkx sgronblo cyphase Tordek kaol alshain suiside_ s4msung_ Internet13 Nik_89 cmsd2 qwandor|quassel certainty nathanel_ pikhq knz paddymahoney tomku gthorslund museun tsou wilfredh charlesofarrell joachifm hvr matzo)
15:37:21 --- names: list (FireFly dario ab9rf marienz Bwild pharaun jlewis MasseR dixie Heffalump aleator_ Shozan dsantiago Eiam dakaktak Kuba dabradley ethercrow Scott_fi1ebeta Guest19871 melter robbert BrianHV schroedinbug alexander__b mlh MrMeh Entroacceptor nicoo leoncamel McManiaC rcj_ mixi peddie Razz henk aszlig ptrf Jaxan Will| int-e Martty SegFaultAX ernst byorgey ft ndngvr purefn magaio_ mapreduce __main__ Fuco snorble_ companion_cube Twey frio jayne tessier bobry puzza007)
15:37:21 --- names: list (lopex tomh_ strax_ si14 akraut yumike jacobw LeaChim VZakharov dilinger yam tkd ocharles Rembane nanothief arun barrucadu Adios julmuri zz_nh2 xnyhps guy_ earthy OnionKnight morolin jaspervdj BigEndian dennda_ herself shachaf chr1s sbahra levitation_ xplat canvon chrisirc identity blooberr mimico__ FalkoPeters akahn warpy__ Daminvar dumbhat bcoppens kosmikus wolong gemelen The_third_man wereHamster zorzar jix whoops Nanar zebr ski SLi wei2912 kakos)
15:37:21 --- names: list (floatingman Excureo JPohlman1 alcz ninegrid stepcut tlaine comak mcint taruti lokydor crdueck TDJACR mahogny Gunni nimred flori hachiya wchun k0ral krig_ jackhill mrdomino_ rmunroe_ jdhky sheerun AtnNn jrslepak mjr84 Gracenotes bgamari Enigmagic ahkurtz_ mechairoi d-snp zeiris TML jrockway Dodek eL_Bart0 ehamberg idnar steez frontendloader sproingie hyko wumpus dcoutts fxrh fionnan C-Keen DrSyzygy betawaffle Counter-Strike Axman6 hanDerPeder finnrobi cynick)
15:37:21 --- names: list (mm_freak_ maltin kmic trevize_ pdxleif def-lkb bd_ aforemny Liskni_si pfoetchen Botje aninhume1 stelleg so- DigitalKiwi peltchu eyck b52 rainmaker tamiko opqdonut mike2 tswett fall_ Raynes guymann joar yeltzooo WhereIsMySpoon ziman Shapeshifter harrison reiddraper aristid adnap horlicks stephe sirchurchill robbe- jercos Fluky ixian mannyv sunnavy eataix ktosiek dmwit Walther gbluma lucca milli Sagi f8_ chrra ion CindyLinz drmegahertz tafryn supki Draggor)
15:37:21 --- names: list (KitB_ joneshf mendez lulf koala_man knyppeldynan lispy ggreg cjay cross alnix lambdabot rcl hpd Boney malorie_ jaroslaw dinox x7 Iceland_jack pqmodn banjiewen absence sully mrd guerrilla bstrie jerojasro faheem DustyDingo idoru fuho `micro ciaranm munro ricepuddin Jean n_b jabirali chance BlastHardcheese so xaimus brett KitB brixen Gilly jamwt simon__ threedaymonk othiym23 natte kkris @ChanServ ahihi Canar Clint dyreshark jrib Laney bens sjl fryguybob wagle)
15:37:21 --- names: list (adimit gereedy liff confound wunki pr liszt pyrtsa tazjin_ mlinksva Kinnison solarus Adeon petanqk ormaaj bholst Plex- notdan qz pyykkis Ulrar yan_ _janne hpaste Spockz agundry Zzompp mollerstrand mami zenzike elliottcable ahf lightquake qwr petekaz deavidsedice Eliel_ myme Cryovat tvaalen otterdam alang tmiw hiroyuki2 brainproxy edenc vhz trolling thorkilnaur lembaswafer b_jonas joeytwiddle Vorpal Megant ique moben mefisto Eridius acfoltzer zomg Belgarion0)
15:37:21 --- names: list (td123 luminous Guest10329 magicman schlumpi danr rcfox lpsmith xcvii geekosaur alpounet ofan \rs nlogax Tehnix gdeest voyd prh integral tgummerer dqd tomaw rio pnielsen Polarina tobiassjosten celery_ noplamodo statusfailed kniu appamatto jlamothe Deewiant linduxed jml tweakism alkabetz nikolah tomprince Mortchek wjlroe endojelly rs0 caligula__ kalven faen mux verrens drek Zariel smarter bbee Ptival Athas sunfun _flow_ Gothmog_ dottedmag Boreeas yano hirsch__)
15:37:21 --- names: list (moonlite Saizan Dybber Tene Nimatek `0660_ anachron_ quicksilver thetallguy1 solirc ccasin hackagebot)
15:39:09 <yitz> Mathnerd314: interesting, Oz is not one of the >1500 languages on http://99-bottles-of-beer.net
15:39:31 <hseg> But Mozart is.
15:41:11 <Mathnerd314> hseg: TECS == http://www.amazon.com/Elements-Computing-Systems-Building-Principles/dp/0262640686/ ?
15:41:21 <hseg> Yup.
15:41:38 <hseg> http://nand2tetris.com
15:44:54 <Mathnerd314> that's the wrong link I think http://www.nand2tetris.org/
15:45:26 <Xaratas> hmm, 17 mio function calls in 3100 ticks, i would ask how to speed it up, most time is used in the lambda (88%), only 3% in the map: checkNumbers a list = map (a ++) (filter (\b -> null(intersect a b)) list)
15:48:57 <Ralith> Xaratas: I'd try not using lists when you mean sets
15:50:35 <Xaratas> Ralith: sets are note allowed to have duplicate values in the first place, but gives this an advantage in runtime?
15:51:02 <geekosaur> Xaratas, lists are looping as a data type, they are very slow when used for things like this
15:51:17 <geekosaur> (they're singly linked lists, not vectors/arrays)
15:51:33 <Ralith> (not that vectors/arrays would be much better here)
15:51:37 <geekosaur> right
15:52:33 <zeus> whats wrong with this piece of code: flip execState () $ lift putStrLn "hello"
15:52:37 <zeus> it makes my ghc panic
15:52:58 <Ralith> aren't ghc panics a bug by definition?
15:53:14 <mauke> probably missing ( )
15:53:20 <zeus> i though so
15:53:27 <mauke> also, execStateT?
15:53:45 <zeus> same with execStateT
15:54:07 <mauke> define "same"
15:55:39 <hpaste> zeus pasted “GHC panic” at http://hpaste.org/83875
15:55:51 <Frostix> Can I do this in Haskell? A program that disables the Enter and Caps Lock button when a game is launched. [5:54:22 PM] Frostix: It runs silently in the background and disables itself when the game is closed. Also is run at computer startup.
15:55:56 <Xaratas> in my current application list is a list of lists, like [[1,2,3,4],[2,3,4,5],[3,4,5,6]], and you say lists are not really fitting, but arrays and vectors neither, what options have i then to try to improve runtime?
15:56:04 <zeus> oh, it announced itself, nice
15:56:15 <luite> Frostix: yes
15:56:36 <Frostix> Alright, thanks. Any suggestions for how to code it?
15:56:38 <arkeet> zeus: that's probably fixed in HEAD
15:56:41 <luite> uh at least if there's some operating system way to disable those keys :)
15:56:58 <arkeet> zeus: but yes, it's a type error, you probably want lift (putStrLn "hello")
15:57:02 <arkeet> or even liftIO (putStrLn "hello")
15:57:12 <mauke> zeus: sweet. did you report it as a bug?
15:57:51 <arkeet> well, first see if occurs in HEAD.
15:58:01 <luite> Frostix: well the hard part is figuring out how to disable those keys. then you'll probably have some calls into C functions. you import them with the FFI and all them from Haskell
15:58:26 <mauke> arkeet: takes too long
15:58:41 <Botje> Frostix: it's doable in haskell, but probably not easy or haskelly.
15:58:57 <arkeet> no, you do that before filing a bug report.
15:58:58 <Frostix> Ok
15:59:05 <zeus> mauke: no, ill do some research first if its not reported/fixed alredy
15:59:13 <mauke> arkeet: no, I don't
15:59:13 <arkeet> might be related http://hackage.haskell.org/trac/ghc/ticket/7368
15:59:37 <arkeet> :c
16:00:24 * hackagebot language-c-quote 0.7.1 - C/CUDA/OpenCL/Objective-C quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.7.1 (GeoffreyMainland)
16:02:06 <zeus> anyway thanks for the tip, with T and () it works nicely
16:02:14 <feliperosa> Hello guys, does anyone have a good article about dynamic programming in Haskell to share? I'm looking for some tutorials but haven't found anything interesting yet.
16:02:50 <arkeet> hmm
16:03:12 <arkeet> looks like that fix made it into 7.6.2
16:03:16 <arkeet> so maybe it's something else.
16:05:32 <feliperosa> If I understand it well, I should build some kind of lazy table?
16:07:08 <Botje> feliperosa: correct.
16:07:15 <byorgey> feliperosa: http://unspecified.wordpress.com/2011/11/04/lazy-dynamic-programming-with-arrays-in-haskell/ ?
16:07:28 <Botje> since DP is about reusing solutions to smaller problems, arrays are a good fit.
16:07:39 <Taslem> Hi. ghc suddenly stopped spitting out executables. Any idea why that may be?
16:07:45 <Taslem> Notably, only for a single file.
16:07:54 <feliperosa> byorgey: Thanks :)
16:08:04 <Taslem> Renaming it fixes the issue. Why on Earth?
16:08:08 <c_wraith> The funny thing is that the lazy array solution is actually memoization, rather than dynamic programming.
16:08:24 <byorgey> c_wraith: dynamic programming IS memoization.
16:08:29 <feliperosa> Botje: Yeah, I'm just having some trouble believing it'll keep the results there hehe. But I'm still experimenting with it to get some intuition of how it works.
16:08:56 <c_wraith> byorgey: all the literature I've seen makes a distinction between bottom-up exhaustive construction and top-down construction on demand.
16:09:27 <byorgey> c_wraith: oh, I see.  I didn't understand the distinction you were trying to make.
16:09:59 <byorgey> is there ever any case in which one would actually prefer bottom-up exhaustive construction?
16:10:10 <c_wraith> it's more efficient if you know you need all the values.
16:10:17 <byorgey> yeah, makes sense.
16:11:06 <armlesshobo> anyone here use a GUI lib other than gtk/qt with haskell?
16:11:21 <arkeet> I'm sure some people use wx.
16:16:19 <amyers> taselm: Have an example?
16:17:39 <joker_89> in lambda-calcul this is equal? \x.x \y.y x= (\x.x) (\y.y x) ?
16:21:08 <hiptobecubic> joker_89, i think that would be:   \x.(x (\y.y x))
16:21:11 <arkeet> joker_89: well that's a matter of inserting implicit parentheses correctly, but usually those are parsed as
16:21:13 <arkeet> yeah that
16:21:23 <arkeet> \x. (x (\y. (y x)))
16:21:30 <arkeet> and (\x. x) (\y. (y x))
16:22:00 <arkeet> so no, they aren't (the latter isn't even a closed term)
16:22:07 <hiptobecubic> the second doesn't make sense. x is free
16:22:15 <hiptobecubic> right
16:34:45 <ag90> So, with Conduits, how difficult is to combine multiple sources?
16:35:41 <ag90> By combine, I mean combine src1, src2, src3 :: Source m a into Source m [a].
16:36:09 <simpson> ag90: Like, with a zip?
16:36:12 <ag90> The closest the library seems to get with that is with Data.Conduit.Uti.lzip.
16:36:51 <ag90> Zip can combine two. Suppose I have an arbitrarily large list. So, I want [Source m a] -> Source m [a]
16:37:15 <simpson> ag90: Well, Source m is a Monad, right?
16:37:25 <ag90> Yes, but a is not the output
16:37:44 <ag90> Source m a = ConduitM () a m ()
16:38:01 <simpson> Huh.
16:38:09 <simpson> http://hackage.haskell.org/packages/archive/conduit/1.0.3/doc/html/src/Data-Conduit-Util.html#zip
16:38:32 <simpson> Well, considering *that* nastiness, I think that you'd be better off writing something on your own, but it's probably not gonna be easy.
16:38:41 <ag90> Hah
16:38:46 <ag90> Yeah, I saw the source and freaked out.
16:39:41 <pdxleif> machines is sposta be able to combine multiple sources.
16:48:55 <hammond> Is there a benifit in learning Haskell over C++, I mean are there things Haskell can do that C++ can't.
16:49:10 <simpson> hammond: Strictly speaking, they're equivalent in power.
16:49:29 <simpson> hammond: But Haskell's a lot easier to reason about and read than C++, at least in my opinion.
16:50:01 <hammond> but the one seems more difficult to learn and (in my non expert opinion) is less supported.
16:50:10 <elliott> sounds like you've made up your mind.
16:50:13 <hammond> oh
16:50:20 <elliott> if you'd rather learn C++ than Haskell, go ahead!
16:50:25 <elliott> I think you'll find it a lot more difficult to truly learn C++ though.
16:50:30 <elliott> it's a very complex language.
16:50:37 <sellout-> Yeah, C++ is way more complicated.
16:51:06 <byorgey> it also depends what you mean by "less supported".
16:51:15 <hammond> well I know C++.  but I don't see why people are converging towards hakshell actually.
16:51:25 <elliott> who is converging to haskell?
16:51:26 <byorgey> hammond: well, then learn it and find out =)
16:51:34 <byorgey> EVERYONE
16:51:35 * elliott would love for that to be true. but doubts it
16:51:57 <hammond> ok.
16:52:22 <hammond> I think I'm confused about something. thx anyways.
16:52:32 <Entroacceptor> hammond: I'm looking at C++ right now, and I see lots of stuff where I think "in Haskell that'd be way cleaner than this"
16:53:28 <hammond> For the closesure,  I think people should only know and use C++. all the others are a lie.
16:53:38 <hammond> :3
16:53:41 <hammond> bye
16:53:50 <ag90> What
16:55:32 * hackagebot hpasteit 0.3.3 - A command-line client for hpaste.org  http://hackage.haskell.org/package/hpasteit-0.3.3 (PatrickPalka)
16:55:44 <byorgey> too bad, at first I thought hammond was serious.
16:57:27 <simpson> I wonder if he knows what the tools he uses on a day-to-day basis are written in.
16:58:35 <ag90> Dude just did the equivalent of going into #git and screaming "git sucks; dropbox is better."
16:59:17 <simpson> PICO WAS HERE, EMACS IS A LOSER
17:02:19 <Sgeo> ag90, at least that makes more sense than going into a channel that's not related to either thing and shouting that.
17:06:15 <ksf_> do we have any parser combinators for tree parsing?
17:06:22 <ksf_> parsing trees, that is, not parsing *to* a tree.
17:08:10 <ksf_> the problem I see with just wrapping a small monad around SYB queries is that I don't get any feedback on what I ignore.
17:10:35 * hackagebot numbers 3000.1.0.2 - Various number types  http://hackage.haskell.org/package/numbers-3000.1.0.2 (DanBurton)
17:13:16 <[mth]> When implementing library functions for a monad transformer, are the MonadReader/MonadState style type classes in mtl considered useful, or are they considered a hack? (That is compared with just  with the preference being to just MonadTrans and lifting as required?
17:13:57 <[mth]> blerg, sorry about the last jumbled sentence: That is compared with just using MonadTrans and lifting as required.
17:14:25 <simpson> [mth]: You should definitely add MonadTrans. MonadReader, etc. are for if your transformer implements Reader-like functionality.
17:14:32 <simpson> If it doesn't, then don't worry about it.
17:15:56 <[mth]> simpson: I asking more about whether they are a good idea in the first place. If I was defining a new transformer, would it be useful to have a MonadMyTransformer (assuming there may be a number of things that can act like MyTransformer).
17:17:02 <simpson> [mth]: If you can think of a good purpose, then sure.
17:31:34 <augur> ski: syn
17:40:36 * hackagebot numbers 3000.1.0.3 - Various number types  http://hackage.haskell.org/package/numbers-3000.1.0.3 (DanBurton)
17:52:27 <rodlogic> what is the idiomatic way to handle Maybe parameters in a function? I want to do something only if Just
17:52:56 <tac> rodlogic: It depends.
17:53:03 <tac> If you want to convert a Maybe a to an a
17:53:05 <liyang> :t when
17:53:07 <lambdabot> Monad m => Bool -> m () -> m ()
17:53:17 <tac> You have to have a policy on what happens in that case you get a Nothing
17:53:37 <rodlogic> I am in a do block and want to do something if the param is Just blah
17:54:01 <tac> and otherwise, you just want to return ()?
17:54:10 <liyang> :t traverse_ print :: Show a => Maybe a -> IO ()
17:54:10 <arkeet> rodlogic: Data.Foldable.mapM_
17:54:11 <lambdabot>     Not in scope: `traverse_'
17:54:11 <lambdabot>     Perhaps you meant one of these:
17:54:11 <lambdabot>       `Data.Foldable.traverse_' (imported from Data.Foldable),
17:54:17 <tac> case foo of Just x -> doStuff x; Nothing -> return ()
17:54:20 <liyang> :t Data.Foldable.traverse_ print :: Show a => Maybe a -> IO ()
17:54:21 <lambdabot> Show a => Maybe a -> IO ()
17:54:30 <liyang> Use traverse_ or for_
17:54:34 <arkeet> or forM_
17:54:56 <rodlogic> :t forM_
17:54:57 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
17:55:04 <arkeet> no
17:55:07 <arkeet> :t Data.Foldable.forM_
17:55:09 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
17:55:13 <arkeet> where t = Maybe
17:55:27 <liyang> Think of Maybe as a 0- or 1-element container.
17:55:37 <arkeet> indeed
17:59:33 <rodlogic> :t for_
17:59:34 <lambdabot>     Not in scope: `for_'
17:59:34 <lambdabot>     Perhaps you meant one of these:
17:59:34 <lambdabot>       `Data.Foldable.for_' (imported from Data.Foldable),
17:59:49 <rodlogic> :t Data.Foldable.for_
17:59:50 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
18:00:02 <rodlogic> great. Thanks!
18:03:17 <feliperosa> Hello :). So I managed to do some memoization using Data.Array, but I expected a bigger speedup. Maybe I'm building too many thunks, I don't know..
18:03:34 <feliperosa> Or is there a better data structure I can use?
18:04:30 <ag90> Aw yeah! Figured out a way to combine multiple Conduit sources. http://hpaste.org/83882
18:04:36 <fryguybob> feliperosa: Can you paste the code on hpaste.org?  It is hard to say without more information.
18:05:07 <ag90> simpson: Did not have to go into that level of mess after all. The code is still not very pretty, though.
18:05:54 <ivanm> feliperosa: what are you doing that you were trying to use memoisation?
18:06:58 <feliperosa> ivanm: Project Euler problem 14, I'm doing it to learn more about dynamic programming in haskell.
18:07:52 <feliperosa> ivanm: It's not really necessary, but it's a problem that's simple enough (not so simple as fibonacci) to me to understand some of the workings of Haskell
18:09:32 * ivanm has never touched project euler
18:10:02 <hpaste> feliperosa pasted “Dynamic programming” at http://hpaste.org/83883
18:10:17 * feliperosa never gone too far either.
18:10:28 <joker_89> with lambda which is the result of b-reduction (\x. x(x)) (\x. x x) ?
18:10:53 <hammersbang> Hey guys! Is a course on operating systems useful ? I'm trying to learn programming.
18:11:07 <hiptobecubic> joker_89, isn't beta-reduction just application?
18:11:23 <joker_89> but it's recursive
18:11:25 <joker_89> in this case
18:11:28 <fryguybob> feliperosa: Shouldn't you be using memoArr in the else branch directly?
18:11:50 <feliperosa> fryguybob: The code is a bit dirty I made some changes along the way trying some things hehe.
18:11:53 <fryguybob> Also you don't have to pass the array as a parameter.
18:12:05 <hiptobecubic> joker_89, just substitute and go. plug and chug.
18:12:25 <joker_89> is not clear for me
18:12:27 <joker_89> this example
18:12:42 <joker_89> i am obtain the same
18:12:45 <feliperosa> fryguybob: True. About the else branch I can't do that because I don't remember every result (since it's not known from the begining).
18:13:15 <joker_89> (\x. x x) (\x. x x) ->(\x. x x) (\x. x x)->(\x. x x) (\x. x x)...
18:13:51 <arkeet> joker_89: welcome to the y combinator.
18:13:57 <joker_89> what?
18:14:27 <fryguybob> feliperosa: Oh, sorry I wasn't looking at what that was guarding.
18:14:28 <arkeet> joker_89: that corresponds to fix id in haskell
18:14:48 <XexonixXexillion> Is there a way I can safely compile code which may contain template haskell (i.e without allowing any IO actions during compilation)?
18:14:56 <arkeet> joker_89: it's the first example of a lambda term with no normal form.
18:15:03 <feliperosa> fryguybob: The same algorithm coded in C gives me a speedup of almost 10 with dynamic programming. The haskell version with dynamic programming gives a speedup of about 1.3
18:15:09 <joker_89> webpage?
18:15:13 <arkeet> google.com
18:15:20 <joker_89> search?
18:15:29 <arkeet> "y combinator"
18:15:42 <feliperosa> fryguybob: Guess that has to do with the array implementations, hence my question about a more efficient data structure
18:16:36 <elliott> joachifm: it's an infinite loop.
18:18:58 <monochrom> using an efficient array is crucial to dynamic programming. the vanilla Data.Array is not efficient enough.
18:19:22 <monochrom> the vector package (comes with Haskell Platform) is one of the efficient ones
18:19:48 <feliperosa> monochrom: I actually tested them both. No difference in performance though
18:20:05 <feliperosa> monochrom: Maybe I'm doing something wrong
18:20:24 <monochrom> use its unboxed variants since you don't need the non-strictness for dynamic programming.
18:20:30 <luite> you want a boxed array
18:20:37 <luite> hah ;p
18:20:48 <monochrom> well, there are two cases
18:21:16 <feliperosa> monochrom: I thought I needed the laziness
18:21:23 <monochrom> if you carefully code up "the right order" of writing to and reading from the array, you don't need the non-strictness, go unboxed
18:21:58 <luite> monochrom: i don't think that's really possible with a vector, unless you go the mutable vectors route
18:22:04 <luite> an unboxed vector
18:22:05 <feliperosa> monochrom: Alright like if I was to do fibonacci, I would be better using the unboxed version
18:22:06 <donri> XexonixXexillion: not with ghc alone i don't think. safehaskell disallows TH completely IIUC, but for unrelated reasons (compilation is not made safe by safehaskell)
18:22:07 <monochrom> if you instead just let lazy evaluation sort out the right order, you need the non-strictness, go boxed, but it is still going to be more overhead
18:22:59 <luite> definitely go for the latter
18:23:03 <donri> XexonixXexillion: there are more ways to compromise a system compiling haskell code than TH, for example OPTIONS_GHC can spawn arbitrary executables
18:23:06 <luite> much more interesting :)
18:23:14 <feliperosa> monochrom: Hum.. I see, I think I can't avoid non-stricness because the values are calculated like: if even x then x `div` 2 else 3 * x + 1. So I don't really know the order.
18:23:19 <donri> XexonixXexillion: http://hackage.haskell.org/trac/ghc/wiki/SafeHaskell/SafeCompilation
18:23:33 <luite> feliperosa: right, for the usual dynamic programming in haskell examples, you need a boxed oe
18:23:56 <luite> feliperosa: otherwise it will look just like your average imperative programming language building the table explicitly from the other side
18:25:08 <feliperosa> luite: It would evaluate every vector element before starting right (when I first accessed it)?
18:25:17 <XexonixXexillion> donri: It's probably sufficient for my needs
18:25:30 <luite> feliperosa: yeah
18:26:20 <feliperosa> luite: Guess I'm stuck then.
18:28:32 <luite> feliperosa: hm what do you mean? Just use a regular array, or a boxed Vector
18:29:02 <feliperosa> luite: Hehe, I meant it seems I can't do much better than this
18:29:25 <feliperosa> luite: Without getting too weird of course.
18:31:42 <luite> oh hmm collatz is a bit annoying since you don't know how big the array should be
18:33:25 <luite> feliperosa: is this too slow?
18:36:24 <feliperosa> luite: No. Fastest time was 0.272 s, while C version best time is 0.022 s. But I just wanted to learn hehe
18:36:59 <feliperosa> luite: Without dynamic programming both versions (Haskell and C) take about the same time
18:37:54 <luite> feliperosa: oh right, a lot of overhead is expected here. but often you already get the (exponential) speedup just by doing the dp, and expressing it through laziness makes it so easy! (also check out data-memocombinators for even more cleverness)
18:38:05 <feliperosa> luite: It's because I'm planning to write a article using Haskell as a continuation of some works of mine. And it's about high performance computing.
18:38:08 <luite> the required speedup, i mean
18:39:15 <feliperosa> luite: Yeah, I like how I don't have to check if I already computed a given value before.
18:39:55 <luite> feliperosa: ok, right, in that case, monochrom is right, for really high performance computing for large problems you probably don't want to use this. but if you just need dp for some smaller steps of your algorithm, perhaps to prepare something to send it to a solver then this is great
18:42:25 <feliperosa> luite: I understand... It was nice anyway, I learned some cool stuff. I'll take a look at data-memocombinators ('more cleverness' got my attention there haha). Thank you for helping :)
18:43:18 <elliott> luite: monoidal laziness?
18:46:09 <luite> elliott: data-memocombinators? nah it makes it even easier to do memoization of integral values becasue it secretly builds an int trie, so you don't have to work with arrays directly or specify any table size
18:47:34 <elliott> luite: that was re: "expressing it through laziness makes it so easy!" :)
18:47:47 <rodlogic> Assume I have a set of data types composed to form a somewhat complex tree. I can't change this tree representation since it is provided by another library. Is it possible to use indexed types/type families to provide a simplified view of this tree exposing a narrower set of the content?
18:48:06 <luite> elliott: oh, no dynamic programming
18:48:43 <XexonixXexillion> this is an off topic question, but if a captcha shows a word written with a long s, am I meant to write s, f or the unicode for long s?
18:48:46 <augur> ski iii iii
18:48:47 <augur> :(
18:51:12 <luite> elliott: don't really know what you mean by monoidal laziness though, like those clever monoidal incremental parsing things?
18:51:38 <YayMe> Say I want to use do notation, I can only have one monad at play unless I'm using a monad transformer, correct?
18:52:01 <elliott> luite: it was a silly reference to shachaf's favourite meme, nothing more :P
18:53:17 <luite> elliott: oh :(
18:53:21 <luite> oh i see now
18:53:40 <luite> bleh i need more coffee :p
18:53:44 <YayMe> augur: no, it's actually just sk, remember?
18:54:52 <elliott> monoidal memoisation sounds interesting though!
18:55:32 <augur> YayMe: no, i assure you, it's ski
18:56:04 <YayMe> augur: If you want to be sure, it's just skskk
18:56:06 <XexonixXexillion> augur: I think you mean sk(skk) :p
18:56:57 <YayMe> > newTVar ([]::[ThreadId])
18:56:59 <lambdabot>   Not in scope: `newTVar'Not in scope: type constructor or class `ThreadId'
18:57:12 <YayMe> ^--- is that valid syntax?
18:57:29 <tac> not really, no
18:57:35 <tac> err
18:57:36 <tac> wait
18:57:36 <tac> no that's legit
18:57:37 <tac> >__>
18:57:47 <tac> That's good syntax
18:58:02 <YayMe> heh thanks sort of :P
18:58:34 <tac> take my advice: ignore me
18:58:38 <tac> :P
18:59:11 <augur> YayMe no i assure you its ski
18:59:17 <YayMe> you're trying to assault me with recursion...damn you haskell, before you I wouldn't have even noticed..
18:59:40 <YayMe> augur: If he's named after the winter sport that's an awful big coincidence that he's in here
19:00:02 <augur> YayMe: haskellers cant be interested in skiing?
19:00:13 <augur> i mean, he IS swedish...
19:01:15 <YayMe> augur: the swedes have a good education system, all the more reason everyone should assume he's named after the maths and not the winter sport
19:01:38 <augur> and yet his name is ski!
19:02:28 <YayMe> augur: yes, my point exactly
19:02:34 <signalsea> Question.. which array library would you currently recommend for 2d square grids using (Int, Int) as an index type? I need not do anything too complicated with them, but being already Traversable and Foldable would be nice
19:02:59 <signalsea> rectangular**
19:04:42 <YayMe> is this a deadlock in STM? writeTVar someTVar [forkIO $ someFunc someTVar]
19:04:51 <YayMe> (or is it generally stupid?)
19:05:29 <geekosaur> you're sending an IO action. you aren't *evaluating* it
19:05:41 <geekosaur> ^send^writ^
19:05:55 <geekosaur> well, a list containing a IO action
19:05:59 <YayMe> geekosaur: wait, will that not actually fork it off?
19:06:04 <geekosaur> no
19:06:09 <YayMe> ah balls
19:06:45 <geekosaur> I think you'll get a type error trying to do actual I/O inside an STM action
19:07:11 <YayMe> geekosaur: Yeah I figure so as well, I asked earlier but didn't get an answer in here
19:08:08 <YayMe> I have to imagine that forkIO and STM are frequently mixed up... it should be straight forward to do somehow.. I'll toss something in a paste if you have a moment to tell me if it makes any sense or if I'm way off
19:08:30 <geekosaur> I'm not an expert on STM, but I know some of the basics
19:08:45 <YayMe> well I know none so you got me beat
19:08:51 <geekosaur> I couldn't tell you how to interleave IO and STM safely (I'm not sure it's possible)
19:09:13 <geekosaur> but I only need the standard rules of Haskell to know that won't actually evaluate an IO action
19:09:29 <YayMe> Yeah, that makes sense.
19:09:31 <luite> STM actions can be retried, so you need to be careful what IO things you do in there
19:09:36 <luite> +trans
19:09:48 <geekosaur> even if you used $!, it would evaluate the list to the first constructor (remember it's head:tail) but not evaluate the IO action
19:09:52 <YayMe> luite: ah good to know!
19:09:53 <luite> there is unsafeIOtoSTM
19:09:58 <luite> but it's unsafe for that reason
19:10:46 <YayMe> I think I know how I want to do this actually on second thought...
19:11:11 <YayMe> I don't really need stm for this me thinks
19:29:15 <hpaste> YayMe pasted “My forked server is not happy” at http://hpaste.org/83884
19:29:32 <YayMe> ^--- won't compile, any tips what I'm doing wrong?
19:29:56 <YayMe> trying to grab the threadId when I fork off my listener so I can accept console commands to kill the server later
19:29:58 <geekosaur> full source, full error text?
19:29:58 <elliott> YayMe: you should paste the error too
19:30:02 <elliott> but it looks like an indentation problem.
19:30:23 <YayMe>     Couldn't match expected type `()' with actual type `ThreadId'
19:30:24 <YayMe>     Expected type: IO ()
19:30:24 <YayMe>       Actual type: IO ThreadId
19:30:38 <elliott> on hpaste, preferably... and that isn't the full error
19:30:49 <elliott> :t forkIO
19:30:50 <lambdabot> Not in scope: `forkIO'
19:30:53 <elliott> @hoogle forkIO
19:30:53 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
19:30:53 <lambdabot> GHC.Conc.Sync forkIO :: IO () -> IO ThreadId
19:30:53 <lambdabot> GHC.Conc forkIO :: IO () -> IO ThreadId
19:30:57 <elliott> note that it expects an IO ()
19:31:24 <elliott> but as we haven't seen what echoServer is, or indeed where that type error is, there's not much more I can say
19:31:39 <lightquake> I wish haskell-mode for emacs supported quasiquoters :(
19:31:48 <dmwit> Your problem reporting is bad and you should feel bad!
19:33:40 * geekosaur wonders what part of "full source, full error text?" meant "that's enough source and post only a partial error"
19:34:48 <hpaste> YayMe revised “My forked server is not happy”: “My forked server is not happy” at http://hpaste.org/83884
19:35:20 <YayMe> I'm an idiot.
19:35:23 <YayMe> I know what I did wrong
19:35:30 <dmwit> accept s >>= blah >> return ()
19:35:35 <YayMe> yeah
19:35:49 <geekosaur> also, you should enclose the entire socket action in withSocketsDo
19:36:04 <geekosaur> it happens that on unix, what you did is probably good enough; no such promise for windows
19:36:17 <dmwit> Also, that killThread probably isn't doing what you think it's doing.
19:36:22 <geekosaur> (as written, only the ccept is under withSocketsDo)
19:36:22 <YayMe> geekosaur: I wasn't sure on that, thanks
19:36:30 <YayMe> that was something I was wondering about heh
20:57:30 <edwardk> jfischoff: around?
20:57:44 <jfischoff> yeah man saw your note
20:57:59 <jfischoff> auto is fine
20:58:44 <jfischoff> It I see how to solve my last remaining problem finally
20:58:55 <edwardk> oh?
20:59:13 <edwardk> call. i'm going afk
21:03:33 <tac> How do I get just a timestamp? System.Time (referenced from RWH) is depracated
21:03:33 <tac> :(
21:04:22 <elliott> @hackage time
21:04:23 <lambdabot> http://hackage.haskell.org/package/time
21:04:32 <geekosaur> "The standard time library from Haskell 98. This library is deprecated, please look at Data.Time in the time package instead."
21:04:47 <tac> :(
21:04:54 <tac> oh
21:04:55 <tac> er
21:05:13 <tac> The link was broken
21:05:22 <tac> I should have Googled harder...
21:07:21 <tac> Is there no linux-y Timestamp type?
21:07:37 <tac> ah
21:07:51 <Clint> UTCTime?
21:08:36 <tac> POSIXTime in Data.Time.Clock.POSIX looks like what I want
21:22:35 <ben22> what is denotational semantics in Haskell?
21:23:40 <tac> denotational semantics is the idea that you take any program (in any language, not just haskell) and you assign it a mathematical object
21:24:06 <tac> For example, you can take a Haskell function to a mathematical function (as you would learn about in set theory)
21:26:06 <ben22> hey thanks tac
21:26:18 <tac> npnp
21:26:21 <ben22> ok so is this denotation
21:26:30 <ben22> s :: whatever
21:26:47 <ben22> s = \n -> math here
21:28:09 <ben22> tac, i'm supposed to assign specific integers into True or False but not ALL of them
21:28:21 <ben22> how is this done using denotational semantics?
21:28:24 <tac> hmm
21:28:33 <tac> That doesn't sound quite right
21:28:47 <tac> Typically, denotation semantics relates programs to very similar things in set theory
21:28:58 <tac> Like, turning a Haskell function into a set function
21:29:04 <tac> Or a Haskell integer into a set integer
21:29:16 <tac> It's more of a translation from a language into the language of set theory
21:29:18 <ben22> tac, would you like to read this pdf file? i'm stuck on it
21:29:27 <tac> I can take a peek
21:29:41 <ben22> thanks tac
21:29:43 <ben22> hold on
21:30:29 <ben22> tac, http://pages.cpsc.ucalgary.ca/~pwlfong/449/Assignments/4/a4.pdf
21:30:42 <ben22> username: 449
21:30:49 <ben22> password: declaritive
21:31:02 <ben22> i'm stuck on 1b)
21:31:14 <hiptobecubic> "declarative" ?
21:31:27 <ben22> yea sorry for misspelling
21:31:30 <monochrom> this assignment is not denotational semantics
21:31:54 <ben22> 1b) says you gotta denote it though
21:32:26 <ben22> I even don't know if I even did 1a) right... cause I simply did if x==0 = True... x==1 = False... etc.
21:32:34 <tac> ah
21:32:47 <tac> yeah
21:32:52 <tac> In this case, I'm pretty sure what is meant
21:33:07 <tac> Is you need to write a simple evaluator
21:33:24 <tac> So, exactly what I said, except instead of translating Haskell into Set Theory...
21:33:24 <ben22> yea for a well-formed formula right
21:33:29 <monochrom> I should speak more precisely. you need no denotational semantics to do this assignment. after doing it, you will still have not learned much denotational semantics.
21:33:40 <tac> I think you're supposed to translate Formulas into Haskell
21:34:09 <ben22> right so here's what I got so far
21:34:13 <tac> more specifically, for this assignment
21:34:15 <tac> It's asking you
21:34:22 <ben22> yea?
21:34:25 <tac> (FOr (FSym 1) (FNot (FSym 0)))  <---- what "should" this thing mean?
21:34:37 <ben22> well I know what it means
21:34:44 <ben22> Or False False = False
21:35:29 <ben22> I got this so far: "g :: TruthAssignment -> Bool"
21:35:32 * dmwit wonders where False came from
21:35:35 <tac> So you know what FOr should mean
21:35:40 <ben22> yea
21:35:42 <tac> What about the FSym 0 and FSym 1?
21:35:48 <ben22> FSym 1 = False
21:35:59 <dmwit> don't think so =)
21:35:59 <ben22> Not (FSym 0) = Not (True) = False
21:36:11 <ben22> what o_O
21:36:20 <tac> (is that what FSym stands for? ... I should FSym might be variables or something)
21:36:35 <ben22> i'm not sure I follow..
21:36:41 <dmwit> Read carefully. The assignment says your function must work for any truth assignment, not just the one you built in 1a.
21:36:49 <tac> I think FSym 0 should mean a, FSym 1 should be b, FSym 2 should mean c
21:36:50 <tac> So if you wanted to say a || b
21:37:36 <ben22> well yea 0 = True and you not it, it's False
21:37:37 <monochrom> Integer is used for variables. other people usually use String.
21:38:31 <monochrom> g :: (Integer -> Bool) -> Bool. use the (Integer->Bool) parameter for FSym 0, FSym 1, etc
21:38:56 <ben22> but that's type Formula
21:39:03 <ben22> not type TruthAssignment
21:39:25 <ben22> ohhhhhhhhh
21:39:35 <monochrom> no, that is not type Formula, and the program code you write for 1(b) will not involve Formula whatsoever
21:39:46 <ben22> ok imma try this!!!
21:39:52 <ben22> thx monochrom
21:39:53 <dmwit> \o/
21:40:04 <ben22> hey, i'm bad at programming bear with me :)
21:40:14 * dmwit is optimistic that a light-bulb moment just happened
21:40:33 <dmwit> ben22: Those arms were raised in celebration, not exasperation. =)
21:40:49 <ben22> wait so what's the point of 1a)... shouldn't I use it in 1b)?
21:41:13 <dmwit> You could use it to test out 1b, but I don't expect your solution to 1a to be a part of the solution to 1b.
21:41:17 <tac> ben22: (In your defense, assignments like these are usually poorly worded)
21:41:30 <dmwit> I don't find this particularly grating, as I also don't expect any part of the solution to 1 will be part of teh solution to 2, etc.
21:41:39 <ben22> you guys are just so helpful thanks, i'm going to try this now
21:41:41 <ben22> I did this'
21:41:57 <ben22> g x = | FSym 0 = s 0
21:42:42 <ben22> oh I can't do that
21:42:58 <ben22> expected type `Bool' with actual type `Formula'
21:43:37 <dmwit> Banging your head on easy stuff like this is good for your character.
21:43:40 <dmwit> You'll get it.
21:43:52 <ben22> this is easy stuff? man i'm far behind in life
21:44:02 <dmwit> (Though more than, say, 10-15 minutes banging your head against the same problem isn't worth it.)
21:44:14 <dmwit> Syntax errors are easy stuff, yeah. =)
21:44:16 <ben22> i've been on this for an hour or two now
21:44:23 <monochrom> again, your code for 1(b) will have nothing to do with Formula whatsoever. and nothing to do with FSym
21:44:24 <ben22> this problem
21:44:31 <dmwit> I meant the same local problem, not the same assigned problem.
21:44:38 <ben22> I guess I misunderstood monochrom
21:44:40 <dmwit> If you know a way to make progress, you're OK.
21:44:56 <monochrom> Formula FSym etc is only for reading the question, not for appearing in the solution.
21:44:59 <ben22> is the solution 1 line of code??
21:45:04 <monochrom> yes
21:45:22 <ben22> ahhh it's so tempting
21:45:33 <ben22> like g x = "solution here"?
21:45:42 * hackagebot NumInstances 1.2 - Instances of numeric classes for functions and tuples  http://hackage.haskell.org/package/NumInstances-1.2 (ConalElliott)
21:45:59 <monochrom> how about this? I change the content of 1(b) and solve it
21:46:09 <conal> ^^ with some reorganization from byorgey
21:46:14 <ben22> why change the content, monochrom ?
21:46:41 <monochrom> you don't like it changed? you want me to solve the original? I can do that too
21:47:16 <monochrom> in any case this is certainly a case of an obfuscated question asking for a very simple thing
21:47:19 <ben22> monochrom, how could this possibly be a one-line solution?
21:47:34 <monochrom> because it is an obfuscated question asking for a very simple thing
21:47:37 <ben22> i don't understand what this question is trying to ask me
21:48:21 <monochrom> I know, and the only way to explain it is to solve it or solve a variant of it
21:48:29 <ben22> alright monochrom, i'll take your word for it and focus on a one-line
21:49:03 <ben22> well, good thing I start on assignments very early
21:51:21 <monochrom> it is a poorly written question. it brings up "denotation", and gives only a handwaving, ambiguous definition, and does not bother to give an example to clarify. the choice of the word "denotation" is technically correct but morally distracting.
21:51:42 <dmwit> They want Haskell code that "acts like" evaluating the formula somewhat awkwardly represented by "FOr (...) (...)" on a given truth assignment.
21:51:57 <dmwit> Also, I agree that the question is very awkwardly written.
21:52:16 <monochrom> the instructor could argue that "you have prerequisite PHIL 279 or 377, so you know the concept". however, that concept is definitely under a different name in 279 or 377.
21:52:35 <ben22> you from calgary?
21:52:55 <dmwit> I wonder whether the question would be easier or harder with a crisp definition of evaluation using denotational brackets.
21:52:56 <monochrom> no, I merely take your url, truncate some of it, and find the course web page
21:53:06 <lightquake> are there any proposals to change haddock syntax? it seems kind of clunky
21:53:28 <lightquake> like, IIRC, it mangles URLs pretty horribly
21:53:43 <ben22> would it just be "g x = ..."
21:53:46 <ben22> man I don't know
21:54:05 <dmwit> Haven't heard any proposals. You might like pandoc or lhs2tex or similar as a replacement for haddock.
21:54:07 <ben22> i spent a good portion of my time getting nowhere with this one unfortunately
21:54:27 <dmwit> Brent was telling me about his thing for blogging today that might be considered an alternative, if you stretch things a bit.
21:54:35 <monochrom> dmwit, at this point, notational choice is less important than spelling out "foo(FAnd x y) = foo x && foo y".
21:54:50 <dmwit> monochrom: Well, but that's question 1c.
21:55:13 <dmwit> It might actually be easier to do 1c first and make 1b an instance of it.
21:55:18 <ben22> 1c is 18% of my mark and I feel very frightened already
21:55:39 <dmwit> solutionTo1B = solutionTo1C (FOr (FSym 0) (FNot (FSym 1)))
21:55:53 <dmwit> But you didn't hear it from me.
21:56:03 <ben22> oh damn that is good advice
21:56:05 <ben22> thanks !
21:56:16 <ben22> but, one cannot go backwards to a problem?
21:56:18 <dmwit> I'm sure the idea was that solving 1b would be a good example to guide you when writing the more general solution.
21:56:32 <ben22> wait dmwit, that wouldn't work
21:56:41 <ben22> cause that's type Formula and we want TruthAssignment
21:56:51 <ben22> errrrr
21:56:58 <ben22> yea, I go tit
21:56:58 <lightquake> also, http://www.haskell.org/haddock/ doesn't appear to have been updated :(
21:57:10 <monochrom> solutionTo1C (FOr (FSym 0) (FNot (FSym 1))) has type (Integer->Bool)->Bool
21:57:11 <dmwit> ben22: Sure, sure, we can argue about details like argument order. =)
21:57:24 <ben22> yea I got it dmwit, I realize my stupidity
21:57:25 * dmwit isn't looking at the assignment any more
21:57:36 <monochrom> your argument order is right
21:58:03 <ben22> so would you guys suggest me do 1c then?
21:58:16 <dmwit> I think you must decide which order you think will be more helpful.
21:58:35 <dmwit> Solve the general problem, or a specific instance?
21:58:38 <dmwit> Which will be easier for you?
21:58:39 <ben22> alright well i'll try your way dmwit and see if i get it
21:58:42 <monochrom> do you understand what 1(c) asks for? do you know how to do it?
21:58:59 <dmwit> monochrom's questions are good ones, too.
21:59:03 <ben22> umm hold on let me read it
21:59:23 <ben22> yea well it does this
21:59:35 <ben22> it takes: (FOr (FSym 1) (FNot (FSym 0)))
21:59:41 <ben22> and evaluates it as true or false
22:00:28 <monochrom> also, nothing says that 1b code must call 1c code. the equation "1b = 1c (FOr ...)" is meant to be a specification. write code for 1b so that it behaves like 1c(FOr ...)
22:00:54 <ben22> well that's the thing, i'm trying to figure out 1b lol
22:01:54 <ben22> I know I should be using function "s"
22:02:17 <monochrom> yes
22:02:40 <ben22> so "g s = (something)"
22:03:25 <ben22> oh ok, so the solution is: g s = True
22:03:33 <monochrom> no
22:03:53 <dmwit> sanity check: if your solution does not use s, it is not correct
22:03:56 <dmwit> True does not mention s.
22:03:58 <ben22> there must be conditions like | s 0 | s 1 | s 10 ?
22:04:00 <dmwit> Therefore, True is not correct.
22:04:05 <monochrom> how about I craft up some test cases?
22:04:39 <ben22> alright monochrom
22:04:51 <ben22> missing an "e" in your name btw :)
22:05:10 <monochrom> g (\n -> if n==0 then False else False) = False
22:05:25 <monochrom> do you know why?
22:05:25 * BMeph_ hurries to register "monoechrom"
22:05:44 * hackagebot monad-logger 0.3.1.1 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.1.1 (MichaelSnoyman)
22:06:00 <ben22> umm what did you do there?
22:06:40 <monochrom> I am writing a test case. if you compute g (\n -> if n==0 then False else False), you should get False.
22:06:52 <dmwit> monochrom: (Are you sure?)
22:06:52 <monochrom> do you know why you should get False?
22:06:58 <ben22> shouldn't it be else True?
22:07:11 <monochrom> oh, darn my logic. yes it should be true.
22:07:27 <monochrom> g (\n -> if n==0 then True else False) = False
22:07:47 <ben22> what is this \n?
22:08:03 <ion> A lambda expression
22:08:07 <monochrom> "f x = x+1" is the same as "f = \x -> x+1"
22:08:28 <ben22> oh it's a "lamba expression"?
22:08:28 <monochrom> but to write "f x = x+1", I have to give it a name "f". I hate that. I want no name.
22:08:29 <ion> modulo monomorphism restriction
22:09:08 <ben22> ok so you get false because...
22:09:19 <ben22> n = 1
22:09:36 <ion> Hmm, or does the restriction do anything here… Perhaps not after all.
22:10:00 <monochrom> ion, don't worry about that detail, it's totally beside the point
22:10:15 <ion> (Yeah, it does.)
22:10:21 <ben22> so yea monochrom, you get false cause n = 1
22:10:28 <ben22> obviously
22:10:41 <monochrom> if you grill me enough on it, I'll just switch to "f x = x && x" and "f = \x -> x && x" and it is a total waste of my time
22:11:00 <monochrom> n is not always 1. it can also be 0.
22:12:22 <monochrom> g will call my function twice, once with 0 and once with 1. do you know why?
22:13:21 <ion> Grill?
22:13:28 <ben22> no, monochrom because I don't see any recursion
22:13:46 <monochrom> you don't need recursion to call my function twice
22:14:19 <ben22> i don't understand
22:14:22 <monochrom> if you write "g s = s 0 && s 1 || s 2" that will call my function 3 times, and still no recursion
22:14:58 <ben22> ah bon?
22:15:04 <ben22> i didn't know that at all!
22:15:24 <monochrom> you mean you haven't seen for example "sin 4 + sin 5"?
22:16:09 <ben22> i always thought recursive calls upon itself with the same function name
22:16:59 <monochrom> well, "sin x = sin 4 + sin 5" would be recursion. but suppose I merely have "h x = sin 4 + sin 5 + sin x"
22:17:42 <ben22> well yea no recursion to "h"
22:17:48 <ben22> so no looping
22:17:58 <monochrom> and it still calls sin 3 times
22:18:17 <ben22> oh yea, it will call sin 3 times but not h
22:18:19 <dmwit> Now generalize sin: "h f x = f 4 + f 5 + f x". Still no recursion.
22:18:21 <ben22> ok, I follow you
22:18:51 <ben22> oh so you mean: g s = s 1 || Not s 0
22:18:59 <ben22> but how do I represent not?
22:19:05 <dmwit> :t not
22:19:06 <monochrom> > not True
22:19:06 <lambdabot> Bool -> Bool
22:19:07 <lambdabot>   False
22:19:23 <ben22> oh so solutions is: g s = s 1 || s 1
22:19:46 <dmwit> getting closer
22:20:01 <monochrom> how come "Not s 0" becomes "s 1"?
22:20:11 <ben22> cause you just flip the numbers
22:20:32 <dmwit> What would "Not s 5" become under that logic? =P
22:20:40 <ben22> ok, you got me
22:20:51 <monochrom> no, the "not" is applied to "s 0", not "0"
22:21:18 <ben22> ohhhhhhhhhhh
22:21:33 <monochrom> you are not given any relationship between "s 0" and "s 1"
22:21:59 <ben22> g s =  s 1 || (s 1) && (s 0)
22:22:23 <ben22> if I did that right..
22:22:26 <monochrom> indeed I gave two test cases. in both test cases, s 1 = False. in one test case, s 0 = False; in another test case, s 0 = True
22:23:08 <dmwit> Well, the question now is the same as before. How come "Not s 0" becomes "(s 1) && (s 0)"?
22:23:18 <monochrom> you cannot just say "from s 1, I know what s 0 is". you don't know. you have to ask for s 0 itself.
22:23:32 <ben22> right.. you guys are good at this
22:23:45 <monochrom> in fact I can give you all 4 important test cases
22:23:57 <ben22> alright let me look at those test cases carefully
22:23:58 <monochrom> g (\n -> if n==0 then False else False) = True
22:24:09 <monochrom> g (\n -> if n==0 then False else True) = True
22:24:20 <monochrom> g (\n -> if n==0 then True else False) = False
22:24:30 <monochrom> g (\n -> if n==0 then True else True) = True
22:24:37 <alang> edwardk: hello
22:24:42 <ben22> how could this possibly be a one-line solution?
22:24:43 <edwardk> heya
22:24:58 <dmwit> ben22: All of your proposed solutions have been one line.
22:25:09 <alang> edwardk: can you tell me about Numeric.AD.Variadic?
22:25:17 <monochrom> because you have written a one-line solution and it is just 1 or 2 tokens away from the right one
22:25:24 <edwardk> :t vgrad
22:25:25 <ben22> ok so
22:25:26 <lambdabot>     Not in scope: `vgrad'
22:25:26 <lambdabot>     Perhaps you meant `grad' (imported from Numeric.AD)
22:25:30 <edwardk> shucks
22:25:34 <edwardk> not in scope
22:25:34 <ben22> g s =  s 1 || (something here)
22:25:52 <alang> vgrad :: Grad i o o' a => i -> o
22:25:58 <edwardk> >>> vgrad (*) 4 5
22:25:58 <edwardk> [5,4]
22:26:18 <edwardk> it avoids you having to set up an explicit functor to call a variadic function
22:26:26 <stepkut> hmm.. I think I now have a 'proof' that what I want to do is impossible :-/
22:26:43 <stepkut> I guess that means I can stop working on it ;)
22:26:53 <monochrom> look, you have been wrongly thinking, from s 1 you can deduce what is s 0, and so you strive to avoid mentioning s 0. I am saying, that's wrong, you have to ask s 0 yourself.
22:26:53 <edwardk> the consequence is you always get it back as a list for gradient purposes and that you don't get the nice safety from "perturbation confusion" that the rest of the API provides
22:26:56 <stepkut> but.. I'll need a new plan
22:27:41 <ben22> monochrom, yes you're right..
22:28:10 <monochrom> because the complete test suite consists of s 1 being 2 possibilities, s 0 being 2 possibilities, altogether 2*2=4 possibilities
22:28:33 <edwardk> alang: vgrads can be used like grads to get access to higher tensors
22:28:35 <edwardk> >>> headJet $ tailJet $ tailJet $ jet $ vgrads (*) 4 5
22:28:35 <edwardk> [[0,1],[1,0]]
22:28:43 <edwardk> for higher order derivatives
22:29:09 <edwardk> >>> headJet $ tailJet $ tailJet $ tailJet $ jet $ vgrads (*) 4 5
22:29:09 <edwardk> [[[0,0],[0,0]],[[0,0],[0,0]]]
22:30:11 <alang> i see
22:30:43 <ben22> monochrom, i think i'll get it one of these days
22:31:32 <monochrom> you should focus on g s = s 1 || Not s 0. it is just wrong haskell notation, but it is the right idea.
22:31:59 <ben22> just don't know how to read your test cases and apply it to that
22:32:12 <edwardk> what are you looking to know?
22:32:30 <monochrom> just enter "g (\n -> if n==0 then False else False)" at the ghci prompt
22:32:43 <ben22> ohhh ok
22:32:55 <alang> edwardk: It just wasn't clear to me what it was for, but I think I get it now
22:32:55 <edwardk> in general its fine to use unless you take the derivative of a function that also takes derivatives, then vgrad will let bad programs typecheck that the quantified form is able to rule out
22:33:01 <ben22> g s = (s 1) || not (s 0)
22:33:04 <ben22> from prelude !
22:33:05 <monochrom> yes
22:33:13 <ben22> is that it?! LOL
22:33:13 * alang nods
22:33:17 <monochrom> yes
22:33:30 <ben22> hahahahaha, i'm doomed for failure on the final exam :)
22:34:15 <ben22> oh man monochrom, this works ! thanks!
22:34:23 <monochrom> you're welcome
22:34:37 <ben22> ok 1 c is like 18% of my mark and probably another 4 hours to figure it out
22:35:22 <monochrom> 1c is where you do have to do pattern matching on Formula. "compileFormula (FAnd x y) s = ..." etc
22:35:48 <ben22> I have to use primitive recursion I guess
22:36:08 <monochrom> yes, all your earliest ideas are suitable for 1c
22:36:16 <ben22> compileFormula only takes one parameter!!! you put an s there!!
22:36:43 <monochrom> s is for the TruthAssignment there
22:36:56 <ben22> oh so for this one, I have to use g then
22:37:06 <edwardk> monochrom, ben22: what is this formula stuff?
22:37:15 <monochrom> to write a function of type "X -> Y -> Z", you could do one of three things:
22:37:23 <tac> edwardk: homework hotline
22:37:26 <monochrom> 1. foo = \x y -> ...
22:37:32 <edwardk> tac: fair enough =)
22:37:32 <monochrom> 2. foo x = \y -> ...
22:37:35 <ben22> edwardk, http://pages.cpsc.ucalgary.ca/~pwlfong/449/Assignments/4/a4.pdf
22:37:38 <monochrom> 3. foo x y = ...
22:37:45 <edwardk> needs a password
22:37:46 <ben22> username: 449 pass: declarative
22:37:49 <edwardk> ah
22:38:21 <monochrom> also, X->Y->Z is the same as X->(Y->Z)
22:38:21 <ben22> I think option 2. makes more sense to me monochrom
22:38:55 <monochrom> also, "\x y -> ..." is just shorthand for "\x -> \y -> ..."
22:39:58 <ben22> so ...
22:40:10 <ben22> compileFormula x = g (s 0) could be compiled..
22:40:29 <monochrom> 1c will not use g. g is not very useful
22:41:00 <ben22> but g is of same type so it's all good!
22:41:44 <monochrom> it gives the wrong answer if I test "compileFormula (FAnd (FSym 0) (FSym 1)) (\n -> whatever)"
22:42:07 <arkeet> ben22 is at ucalgary :o
22:42:23 <ben22> arkeet, that's right!
22:42:37 <arkeet> cool, I did my undergrad there. not in cs though
22:42:39 <ben22> ok so I need to compileFormula x = \y -> (something)
22:42:53 <monochrom> yes
22:43:01 <ben22> good thing you didn't major in CPSC cause it's a hard major for me
22:43:09 <ben22> monochrom is kind enough to help me :)
22:43:28 <monochrom> I think it is not hard. it is just poorly explained.
22:43:32 <NoContext> does anyone here have experience deploying a yesod app? preferably with directions a monkey could follow
22:43:33 <ben22> monochrom, what is this \y -> thing?
22:43:47 <arkeet> it's a lambda expression
22:43:55 <monochrom> a function that takes 1 parameter, call it y.
22:43:59 <arkeet> or anonymous function.
22:44:07 <ben22> anonymous function..
22:44:24 <ben22> oh the anonymous function taking type (TruthAssignment -> Bool)?
22:44:30 <monochrom> yes
22:44:49 <ben22> ok I understand that now I need to know what stuff to put in it..
22:45:31 <ben22> same thing.. (s 1) || not (s 0)
22:45:35 <ben22> err
22:46:15 <monochrom> it is not always 0 and 1. it now depends on what you see in FSym, no?
22:47:12 <ben22> what I see in FSym..
22:47:39 <monochrom> compileFormula (FSym n) = \s -> ?
22:47:53 <ben22> \s -> n
22:47:57 <joeyh> trying to remember the name of a package that added a debug web server to a haskell program, with profiling info
22:48:03 <ben22> I mean.. a truth value !
22:48:38 <monochrom> n is an integer, not a truth value. but who will map integer to truth value?
22:48:57 <ben22> :r
22:48:57 <ben22> oops
22:49:46 <ion> toEnum will. :-P
22:50:04 <monochrom> in this context, you don't want toEnum.
22:50:17 <ben22> who will map integer to...
22:50:19 <ben22> s function
22:50:26 <monochrom> yes, so use s.
22:51:21 <ben22> compileFormula (FSym n) = \s -> s n
22:51:28 <monochrom> yes
22:51:48 <ben22> ok I think I can apply it to this big formula..
22:56:33 <ben22> :r
22:59:36 <ben22> monochrom, it says "modules OK" but I don't know how to run: compileFormula (FSym n) = \s -> s n
22:59:57 <monochrom> that is not how to run it
23:00:22 <monochrom> and I am not sure what you mean
23:00:43 <monochrom> to enter code, enter in a file, then :load or :reload, but I thought you already know
23:00:55 <ben22> oh no that's not what I mean
23:00:56 <ben22> like
23:01:05 <ben22> in the GHCI.exe
23:01:06 <monochrom> to run, you just call the function with actual parameters
23:01:07 <ben22> I put this
23:01:16 <ben22> compileFormula (FSym 0)
23:01:21 <ben22> and displays an error for show
23:01:31 <ben22> err right
23:01:34 <monochrom> yes you need to give a TruthAssignment too
23:02:12 <monochrom> compileFormula (FSym 0) (\n -> if n==0 then False else True)
23:02:29 <ben22> oh right the \s part
23:03:05 <ben22> oh whoa it worked
23:03:26 <ben22> to be honest, monochrom, I don't these syntax very well
23:03:40 <ben22> sorry to be such a burden im still trying to grasp the concept
23:05:31 <ben22> monochrom, I believe the proposition of which I have to evaluate takes two of \x \y?
23:06:07 <monochrom> that depends on whether it's FNot or FAnd or FOr
23:06:29 <ben22> it's FOr
23:07:09 <monochrom> it is not always FOr. you have to handle all cases. But FOr has two parts, that much you're right.
23:13:51 <ben22> monochrome, I'm figuring it out what you're saying
23:13:57 <ben22> compileFormula (Not x) = \y -> not s x
23:14:04 <ben22> for another case
23:14:41 <monochrom> you need recursion on compileFormula for every case except FSym
23:16:05 <monochrom> this is because I may give you e.g. FNot (FAnd (FSym 10) (FSym 4)). now you have x = (FAnd (FSym 10) (FSym 4)), what can you do other than use recursion to process further
23:18:29 <ben22> monochrom, I tried
23:18:30 <ben22> compileFormula (FNot x) = \y -> FNot (compileFormula (s x))
23:18:39 <ben22> and it does not compile it should work
23:19:40 <ben22> hmm I think I know the prob..
23:20:15 <ben22> ack!!!
23:21:38 <ben22> :r
23:26:16 <ben22> hey monochrom, have you heard of a man named Daniel Tammet?
23:26:48 <alang> edwardk: https://github.com/alang9/ad/commit/d26a94e443f9e34e469e377e3f32303cb3a3fceb
23:27:08 <edwardk> alang: nice
23:27:15 <edwardk> did you get a noticeable performance change?
23:27:32 <edwardk> alang++
23:27:40 <alang> haven't benchmarked yet
23:28:02 <edwardk> i'd be curious to know if it helps or hurts, but i think we should probably merge anyways
23:28:23 <edwardk> i'll need to lobotomize more stuff that currently gives you too much stuff to violate safety guarantees, or just embrace it
23:28:41 <edwardk> i guess if you explicitly import an internal module you deserve what you get
23:28:48 <arkeet> I love seeing more type parameters.
23:28:59 <Ralith> woo
23:29:06 <Ralith> bos responded to my mail :D
23:29:09 <Ralith> sorta
23:29:26 <edwardk> arkeet: it makes a big difference to the inlineability of the ad primitives
23:29:38 <Ralith> the future of the llvm bindings is bright!
23:30:33 <arkeet> edwardk: how so?
23:31:25 <ben22> thank you for your time today, monochrom.
23:31:30 <johnw> Ralith: is it?
23:31:32 <ben22> see you folks
23:31:34 <edwardk> arkeet; right now it only works if you are parametric in the mode
23:31:43 <edwardk> which means we have to pass in the dictionary explicitly everywhere
23:31:45 <edwardk> it can't be inlined
23:31:48 <edwardk> this is good and bad
23:31:55 <arkeet> that would have been my guess.
23:32:09 <alang> edwardk: About Grad, I made the type pack :: i -> [AD Kahn () a] -> AD Kahn () a, but maybe that should be AD Kahn Void a?
23:32:09 <Ralith> johnw: indeed, see http://projects.haskell.org/pipermail/haskell-llvm/2013-March/000285.html
23:32:12 <edwardk> because it means we can safely rely on the origin of the dictionary being the outermost wrapping, which is abused by the reflection machinery in reverse.
23:32:17 <monochrom> ben22: you're welcome
23:32:17 <alang> if you want to depend on void
23:32:35 <edwardk> i have no objection to a Data.Void dependency. any type works there.
23:32:57 <johnw> i'm in London now, if anyone wants to chat about Haskell over fish and chips anytime :)
23:33:01 <edwardk> pushed to to the repo
23:33:22 <edwardk> johnw: sounds good. fly to boston. we'll have chips ;)
23:33:41 <johnw> ah, you have good cod there too!
23:33:54 <johnw> come to chicago, we can have deep-dish chips
23:34:07 <alang> woo
23:34:08 <edwardk> yeah, but its pretentious enough to wear a cape
23:36:06 <johnw> just ported my old git-monitor utility from C++ to Haskell
23:36:12 <johnw> a rather pleasant experience
23:36:49 <johnw> it's a resident daemon that efficiently snapshots changing to your working tree as you work
23:36:54 <johnw> changes*
23:39:47 <luite> how does it make snapshots?
23:40:58 <johnw> it keeps hold of a Libgit2 tree in memory, so that it can adjust it easily, then if the tree's Oid has changed, it makes a commit in .git/refs/snapshots/<name of ref HEAD refers to>.  Every time you run git-monitor it clobbers the old snapshot ref, so that old snapshots will naturally get cleaned up by git-gc
23:41:18 <johnw> it notices when you change branches too
23:41:48 <johnw> the idea is to have as minimal a CPU/disk overhead, while provide you with a full version history of your hacking session
23:43:47 <luite> hm interesting
23:44:35 <johnw> it polls the filesystem every 60 seconds; if no changes have been made, the minimum cost is one stat(3) call for each working tree file under Git
23:44:50 <johnw> which, if you have an SSD, is like no cost at all
23:46:22 <Heffalump> johnw: in London permanently, or visiting?
23:46:35 <johnw> maximum cost is if you keep changing a bunch of huge files, which causes it to be re-git-add'd every 60 seconds.  git-monitor isn't designed for that use case, but rather for snapshotting source code
23:46:41 <johnw> Heffalump: just visiting my Dad for 3 weeks
23:46:56 <Heffalump> there's a HUG on the 27th (I think)
23:47:11 <johnw> oh yeah?  do you have a link for that?  i will definitely come
23:47:22 * Heffalump is just on a train to London
23:47:30 <johnw> i'm going to gate crash after FPX at the pub too :)
23:47:44 <Heffalump> http://www.meetup.com/London-HUG/
23:47:55 <johnw> thanks, adding it to my calendar
23:52:01 <joeyh> johnw: feel free to grab my inotify stuff, it'd make it easy to inotify on the whole tree
23:52:12 <joeyh> (or kqueue, or fsevents)
23:53:55 <johnw> joeyh: thanks!  the thing is, I don't want to snapshot changes "as they occur"
23:54:00 <johnw> I think that would get too noisy
23:54:05 <joeyh> hmm
23:54:19 <johnw> I suppose I could use inotify to "gather up changes"
23:54:25 <johnw> and then process the batch at intervals
23:54:41 <joeyh> well, yes, quite easily, but then all you save is some overhead
23:55:01 <johnw> yeah, and it's not much overhead at all
23:55:20 <johnw> i suppose it would make a lot of sense if my working tree had thousands of files, though
23:55:43 <johnw> i'll put it on my further improvements list :)
23:56:24 <johnw> joeyh: i would love to see gitlib integrated into git-annex
23:56:35 <joeyh> libgit2?
23:56:40 <johnw> that's one of its backends
23:56:54 <joeyh> Joshtripplet and I have talked about it. The API is still a bit on the unstable side for my liking
23:56:54 <johnw> gitlib is an API for writing Git algorithms, and supports multiple backends
23:57:13 <johnw> gitlib-libgit2 happens to be the one git-monitor is using
23:57:20 <johnw> but there's also gitlib-cmdline, gitlib-github, etc.
23:57:29 <joeyh> also, libgit2 is quite a lot slower than the C git commands in several cases
23:57:40 <johnw> gitlib itself is unrelated to libgit2
23:58:04 <joeyh> I am interested in possibly using it in places where the C commands are suboptimal though
23:58:07 <johnw> in fact, it's just a bunch of type classes and data types, for which I provide you an implementation.  So I insulate you from libgit2 changes
23:58:20 <johnw> (I also maintain hlibgit2)
23:58:56 <johnw> joeyh: if you ever want me to give you an overview, let me know; it would help me at writing better documentation to have a specific audience in mind :)
