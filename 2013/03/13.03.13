00:00:10 <eflister> :t (%~)
00:00:11 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
00:00:22 <eflister> wow i've not seen these
00:00:36 <supki> > (10,20,30,40) & each %~ round . (* 0.5) . fromIntegral
00:00:38 <lambdabot>   (5,10,15,20)
00:01:24 <supki> > [10,20,30,40] & mapped %~ round . (* 0.5) . fromIntegral
00:01:26 <lambdabot>   [5,10,15,20]
00:01:37 <Ralith> programming with lenses: write out the operations involved, then intercalate them with random punctuation until you get the result you want
00:01:43 <eflister> where can i learn about these?  they don't show up in hoogle
00:02:18 <notdan> eflister: those are from the lenses library
00:02:34 <supki> eflister: https://github.com/ekmett/lens/#readme
00:02:46 <croikle> hayoo can find them
00:02:58 <eflister> wow i thought that just had to do with nested data structures
00:05:55 <hpaste> mzero annotated “why so ugly” with “why so ugly (annotation)” at http://hpaste.org/83967#a83968
00:06:05 <mzero> try that, eflister
00:06:51 <Ralith> eflister: it does, it's just that edwardk has been not-so-slowly widening the definition of 'data structure' ^^
00:09:02 <pharaun> mzero: i think i found the right command to get the fd number/etc in/out of the socket, so my main worry will be to make sure that it does not get closed by ghc when i exit/exec into the next one right?
00:14:13 <ruler2> anyone have a good textbook on category theory
00:17:07 <eflister> thanks mzero and supki - screaming baby now, but will study.  that's what i needed...
00:50:41 <hpaste> Powergiant pasted “Function name” at http://hpaste.org/83969
00:51:02 <powergiant> Can someone explain why .++ is ok as a custom function name but :++: isn't ?
00:51:04 <arkeet> powergiant: operator names can't begin with :
00:51:18 <powergiant> arkeet: Well that answers that
00:51:18 <arkeet> names beginning with : are reserved for constructors
00:51:25 <powergiant> Thanks
00:51:43 <arkeet> think of : as an "uppercase symbol"
00:52:42 <powergiant> arkeet: That makes sense
00:55:21 <supki> really?
00:57:27 <arkeet> really what?
00:58:48 <supki> thinking of ':' as an uppercase symbol making sense
00:59:06 <supki> I mean, you can remember that, sure
00:59:49 <arkeet> but it makes a connection with a similar condition for letter names
01:00:32 <pantsman> but you can have operators that start with uppercase letters
01:00:51 <arkeet> but those are constructors.
01:00:51 <pantsman> wait, wrong channel :)
01:00:55 <arkeet> ??
01:00:56 <arkeet> ok
01:00:59 <pantsman> haha
01:01:06 <pantsman> was thinking of different language ;)
01:01:11 * arkeet is curious which language
01:01:26 <pantsman> I thought I was looking at #scala
01:01:29 <arkeet> ah
01:01:35 <arkeet> anything goes in scala.
01:01:38 <powergiant> It think it also helps to make sense since ':' is typed as an uppercase on my keyboard, but that's maybe just me
01:01:44 <pantsman> scala has many weird syntax corner cases
01:01:56 <arkeet> but > is also typed with shift
01:02:44 <powergiant> Every rule has exceptions
01:03:30 <powergiant> "You can't use shift except for in the small set of exceptions".. Good rule
01:05:15 <turiya> it seems i cant use an unboxed array for an array containing a list of ints.. i.e. UArray Int [Int] is not possible. is it possible to add such an instance?
01:06:01 <arkeet> turiya: no, there is no such thing as an unboxed list.
01:06:41 <turiya> arkeet: oh, thanks..
01:27:02 <liyang> You seem to like: arrays. Why not try: boxed vectors of unboxed vectors?
01:27:52 <hpaste> Powergiant pasted “Types” at http://hpaste.org/83971
01:28:59 <powergiant> I don't understand why I have to do (1:Int) and the type isn't infered when I'm using a function that with Int in the signature
01:30:20 <srhb> powergiant: You're using the class method. It chooses the instance based on the type of the argument to yesno
01:30:47 <srhb> powergiant: However, 1 is Num a => a. So it doesn't know how to pick an instance without an explicit type signature (or some other hints)
01:32:05 <srhb> powergiant: I'm guessing you expect it to be able to pick the instance based on the fact that there only is one for Int, but that's just not how it works. It would also be weird, because consider if you added instance for, say, Float. Then code that previously worked would suddenly be ambiguous. That's not nice.
01:33:17 <turiya> liyang: i am just looking at Data.Vector. Can we have Vectors of Vectors?
01:33:23 <powergiant> srhb: Yes, that makes sense.
01:33:30 <srhb> powergiant: Great. :)
01:33:56 <powergiant> srhb: Is there somewhere aroud this, or do I need to make instances for all of the Num types to get the behaviour I want ?
01:34:15 <srhb> powergiant: That still wouldn't help, because number literals are overloaded
01:34:28 <srhb> powergiant: It still wouldn't know WHICH instance among the Nums to pick.
01:34:29 <powergiant> srhb: Ah right.. Of course
01:34:37 <srhb> powergiant: You can however overload the instance for all Nums, I think.
01:34:45 <srhb> I'm actually not sure of that.
01:35:20 <srhb> With FlexibleInstances perhaps
01:35:29 <powergiant> "overlord the instance for all Nums"... What does that mean? Making a type like 'Instance YesNo (Num a)' for something?
01:35:41 <powergiant> *or something
01:36:35 <srhb> powergiant: instance (Num a, Eq a) => YesNo a where ...
01:36:50 <srhb> powergiant: And you would need FlexibleInstances and UndecidableInstances to do that.
01:36:55 <mgsloan> How to get Oleg to solve your programming puzzle: email haskell-cafe with the words "impossible" near to "proof" ;)
01:37:04 <srhb> mgsloan: :P
01:37:37 <turiya> i am trying to understand Data.Vector. the main data type is "data Vector a" and there is an instance for "Vector Vector a", does it mean that it supports Vectors of Vectors?
01:38:03 <srhb> turiya: Yes
01:38:31 <turiya> srhb: thanks
01:38:46 <turiya> can the "a" be anything?
01:39:00 <arkeet> no no
01:39:07 <arkeet> one of them is a Vector *class*
01:39:48 <arkeet> unfortunately haddock isn't great at showing which modules a name is from
01:39:58 <turiya> arkeet: i dont understand what you mean.. can you explain?
01:40:12 <arkeet> there's a class called Vector, and several types called Vector.
01:40:19 <arkeet> they are different (they're from different modules)
01:41:00 <liyang> Best to import them qualified.
01:41:16 <arkeet> the class is from Data.Vector.Generic
01:41:44 <liyang> My convention is Data.Vector as V, Data.Vector.Unboxed as VU, Data.Vector.Storable as VS.
01:42:16 <liyang> You don't really need to deal with the Vector class unless you're doing something fancy.
01:42:23 <turiya> hmm.. "data Vector a" means that Vector is a data type.. right?
01:42:35 <hpaste> Powergiant pasted “Stil dosen't work” at http://hpaste.org/83972
01:43:02 <turiya> i am just following http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/Data-Vector.html
01:43:04 <arkeet> powergiant: what doesn't work about it?
01:43:04 <hpaste> srhb annotated “Stil dosen't work” with “Stil dosen't work (annotation)” at http://hpaste.org/83972#a83973
01:43:11 <liyang> turiya: it means *that* 'Vector' is a data type. There may be other things also named 'Vector'.
01:43:12 <powergiant> It's really the same problem, but I don't see why this wouldn't work? Is it "Just the way haskell is" or is there something im missing?
01:43:22 <srhb> powergiant: ^^^^ annotation
01:44:06 <arkeet> well, understand the consequences of that too.
01:44:15 <turiya> i see
01:44:17 <arkeet> you won't be able to write any other instances for YesNo without it complaining about overlapping instances.
01:44:20 <srhb> powergiant: I'm fairly sure GHC would have told you that you needed those language extensions in the wrror message.
01:44:43 <turiya> liyang: can you help me understand what does "Vector Vector a" mean?
01:44:54 <arkeet> turiya: the first Vector is the class.
01:44:59 <arkeet> from Data.Vector.Generic
01:45:04 <arkeet> the second Vector is your data type Vector
01:45:12 <turiya> is it a type class ?
01:45:16 <arkeet> the first one yes
01:45:46 <srhb> powergiant: It's not particularly useful though, as arkeet said.
01:45:51 <liyang> turiya: sure. Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo.
01:46:03 <arkeet> hehe
01:46:29 * hackagebot free 3.4 - Monads for free  http://hackage.haskell.org/package/free-3.4 (EdwardKmett)
01:46:35 <srhb> To extend it you'd need NoMonomorphismRestriction and IncoherentInstances as well. Not particularly nice.
01:46:45 <liyang> Those 'buffalo's look the same but some of them mean different things (or are different classes of words.)
01:46:56 <srhb> powergiant: But your example is also contrived. In a real application, the types of your numeric values would often be fixed by other constraints.
01:47:28 <srhb> powergiant: And if not, smacking a type signature on them isn't that horrible at all.
01:47:41 <powergiant> srhb: Ah yes this is just me trying to understand Haskell better
01:48:01 <srhb> powergiant: OK. :) I'm saying that you _can_ do this, but you probably should not.
01:48:12 <powergiant> srhb: I'm going through LYAH and trying to change all the examples a little bit to understand them better
01:48:12 <srhb> powergiant: Stick to your original code and fix the types of your numerics where needed.
01:48:20 <srhb> powergiant: Good idea. :)
01:49:16 <powergiant> srhb: And thanks for the help by the way! :)
01:49:40 <srhb> powergiant: anytime.
01:51:29 * hackagebot monomorphic 0.0.1.0 - Library to convert polymorphic datatypes to/from its monomorphic represetation  http://hackage.haskell.org/package/monomorphic-0.0.1.0 (HiromiIshii)
01:52:07 <liyang> turiya: I have to admit though, those different Vectors are named to be maximally confusing. On the other hand, it ostensibly allows you to switch between boxed/Unboxed/Storable with only minor changes in your code.
01:52:28 <liyang> The Vector class should have been named something different.
01:52:40 <srhb> Like.. VectorClass. :P
01:53:17 <liyang> Not my fault. Take it up with Roman. ;)
01:53:52 <turiya> liyang: i am still trying to understand the meaning of "Vector Vector a" and i did not understand your example..
01:54:09 <liyang> turiya: read it as VectorClass Vector a.
01:54:31 <liyang> It's a typeclass constraint or something.
01:54:39 <turiya> so that means some functions which are applicable on VectorClass are applicable for Vector a?
01:55:13 <liyang> Yup. But I don't know which (boxed/unboxed/storable) Vector that is in your instance…
01:55:30 <liyang> turiya: http://en.wikipedia.org/wiki/Buffalo_buffalo_Buffalo_buffalo_buffalo_buffalo_Buffalo_buffalo
01:57:56 <turiya> liyang: did not know that before..
02:00:54 <turiya> for both the "VectorClass v a" as well as "Vector a", the "a" seems to be unrestricted..
02:01:19 <turiya> does it mean i can choose "a" to be anything?
02:01:21 <liyang> Where exactly are you seeing this Vector Vector a?
02:01:43 <liyang> You can probably choose a to be anything as long as there's an instance Vector Vector a for that a.
02:02:03 <liyang> For boxed vectors, that really is any a.
02:02:40 <joker_89> hi
02:02:43 <srhb> joker_89: Hi.
02:03:01 <srhb> liyang: And for unboxed vectors it's any a that can be unboxed?
02:03:20 <liyang> srhb: anything that has an Unbox instance.
02:03:23 <srhb> Right.
02:04:27 <liyang> @hackage vector-th-unbox -- provides template haskell to derive Unbox instances for things in terms of existing things. Otherwise Unbox instances are kind of painful to write.
02:04:28 <lambdabot> http://hackage.haskell.org/package/vector-th-unbox -- provides template haskell to derive Unbox instances for things in terms of existing things. Otherwise Unbox instances are kind of painful to
02:04:28 <lambdabot> write.
02:04:43 <liyang> </plug>
02:04:45 <joker_89> i have a data union like data ME = M Type Subtype derving Show wich Type and Subtype are data's. Now i want with patterns to itarate a list of ME like MyFunction [M t s] p = [x | x<-M, x==p]
02:05:54 <srhb> joker_89: but...?
02:06:45 <turiya> oh, i see. the data.vector.unboxed gives some instances..
02:06:53 <joker_89> couldnt match expected type
02:07:10 <joker_89> eq instance?
02:07:30 <srhb> joker_89: Yeah, you're using ==
02:07:36 <srhb> joker_89: So your type needs an Eq instance..
02:08:22 <turiya> liyang: i think now i have to use boxed vectors of unboxed vectors as there is no instance for unboxing unboxed vectors.
02:08:33 <turiya> as u said earlier
02:08:41 <joker_89> but when i am refering in the elements of the list is correct the x<-M ?
02:08:47 <joker_89> in the comprension list before
02:08:50 <srhb> joker_89: No
02:08:55 <srhb> joker_89: M is a type or a constructor.
02:09:08 <joker_89> so how works?
02:09:13 <adnap> How can I define (a -> b -> c -> d) -> (c -> a -> b -> d)
02:09:16 <srhb> joker_89: Your list must be lowercase, for instance, m = [M 3 2] :: ME Int Float
02:10:30 <liyang> turiya: that's correct.
02:10:47 <Cale> adnap: (\f c a b -> f a b c)
02:11:10 <arkeet> :t flip . (flip.)
02:11:12 <lambdabot> (a -> a1 -> b -> c) -> b -> a -> a1 -> c
02:11:37 <liyang> turiya: although you could map (i,j) indices to a single k if you know what the maximum for one of the indices might be… like j * iMax + i.
02:11:45 <adnap> Cale: I'm already doing essentially that in my code
02:12:11 <arkeet> @pl \ f c a b -> f a b c
02:12:11 <lambdabot> flip . (flip .)
02:12:17 <adnap> I guess I will stick with what I have if "flip . (flip.)" is the alternative
02:12:22 <adnap> That is unreadable
02:12:24 <Cale> adnap: There's nothing much cleaner than a lambda for that kind of thing
02:12:28 <arkeet> nah, it makes sense ;)
02:12:33 * adnap laughs
02:12:48 <BadKitty> Can anyone here give me any suggestions for packaging an xmonad config set using cabal?
02:12:49 <adnap> 'Cause you probably had my problem and became comfortable with it
02:12:53 <arkeet> @map length ["flip.(flip.)" "\f c a b->f a b c"]
02:12:53 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
02:12:57 <arkeet> >map length ["flip.(flip.)", "\f c a b->f a b c"]
02:12:58 <arkeet> > map length ["flip.(flip.)", "\f c a b->f a b c"]
02:13:00 <lambdabot>   [12,16]
02:13:12 <adnap> I don't want to force every reader of my code to become comfortable with crazy flip composition
02:13:13 <BadKitty> (and icons directory; not library/code, to be statically moved into dir x)
02:13:18 <Cale> If you consider all the possible permutations, giving names to them just begins to get silly when you can directly write the permuatation you want as a lambda and the code then makes it clear.
02:13:23 <arkeet> adnap: nah, I'd use a lambda too.
02:13:41 <turiya> liyang: i did think of that.. but i would not know the maximum before hand..
02:13:43 <Cale> (In most cases you wouldn't even be taking f as a parameter even)
02:14:00 <joker_89> srhb if i need a data wich is the combination of to data's, i need to put a new constructor at the top left?
02:14:11 <joker_89> like Data MyNew =
02:14:38 <joker_89> like data MyNew = Data1 Data2 or data MyNew = MyConstruct Data1 Data2
02:15:01 <srhb> joker_89: first off, it's data, not data. Second, if you just want the types to be static, you use data MyData = MyConstructor Type1 Type2 Type3...
02:15:05 <srhb> data, not Data*
02:15:44 <joker_89> and for instance Eq only for MyData or also for Type1 Type2..
02:16:07 <srhb> joker_89: In order to derive an Eq instance for MyData, Type1, Type2, ... also need Eq instances, yes.
02:20:27 <joker_89> but if i want to compare my data elements, and only is true if are the same name, how can i do this in one line?
02:20:37 <srhb> joker_89: What do you mean "same name"?
02:21:09 <joker_89> if i have data Type1 = Item1 | Item2 | Item3 ...
02:21:25 <srhb> joker_89: Yes.. Do you mean same value?
02:21:38 <joker_89> in the instance Eq Type1 where Item1==Item1 = True Item2==Item2 = True..
02:21:39 <joker_89> yes
02:21:40 <srhb> Item1 is a value of type Type1
02:22:01 <srhb> joker_89: I think this would be easier with a more concrete example
02:22:57 <hpaste> srhb pasted “MyType” at http://hpaste.org/83975
02:23:10 <srhb> Oh, he logged. Derp.
02:23:30 <joker_89> Sorry my windows reboot
02:23:39 <srhb> joker_89: http://hpaste.org/83975 -- alternatively using filter (==M 2 3 True) foo
02:29:14 <beefcube> is possible to lift other monads (such as QuickCheck's Gen) into the IO monad, (the opposite process of liftIO) in a general way? liftM doesn't seem to do it
02:29:30 <joker_89> I see but without deriving Show? Using instance  Eq
02:29:45 <srhb> joker_89: You can use deriving (Eq, Show)
02:30:18 <joker_89> But i want to know how is usinh instance
02:30:21 <SwineFlu> I'm trying to use getStdRandom/RandomR but GHCI keeps telling me it is out of scope, I tried adding "import System.Random" to my program but that just gave me a new error, What am i doing wrong :(
02:30:28 <joker_89> For see diferences
02:30:43 <srhb> joker_89: You mean you want to write your own Eq instances?
02:31:15 <srhb> joker_89: Or Show?
02:31:23 <joker_89> Eq
02:31:58 <srhb> joker_89: Have you read up on how to define your own instance in eg. Learn You A Haskell?
02:32:29 <joker_89> Buy i need to compare one by one
02:33:52 <SwineFlu> Ok some googling tells me random is not part of the current haskell lib, only haskell98, is there a new version of random?
02:33:52 <srhb> joker_89: I'm not sure I follow. There's already an Eq instance for Eq a => [a]
02:34:11 <srhb> SwineFlu: System.Random is definitely in base.
02:34:18 <srhb> Or is it...
02:34:29 <SwineFlu> StackOverflow says its haskell98 only
02:34:36 <srhb> System.Random is definitely in HP :-)
02:34:43 <SwineFlu> however the haskell manual told me to use it
02:34:53 <SwineFlu> Hmm, Why won't my import work then :s
02:34:59 <srhb> SwineFlu: import System.Random?
02:35:12 <SwineFlu> yep
02:35:17 <srhb> SwineFlu: What's the error?
02:35:23 <SwineFlu>     Could not find module `System.Random'    Locations searched:      System/Random.hs     System/Random.lhs
02:35:36 <srhb> that looks a bit weird.
02:35:48 <srhb> SwineFlu: Have you tried "cabal install random"?
02:35:56 <srhb> SwineFlu: How did you install Haskell?
02:36:13 <SwineFlu> apt-get install ghci
02:36:30 * hackagebot monomorphic 0.0.1.1 - Library to convert polymorphic datatypes to/from its monomorphic represetation  http://hackage.haskell.org/package/monomorphic-0.0.1.1 (HiromiIshii)
02:36:36 <srhb> SwineFlu: That's probably not the way to go.
02:36:53 <srhb> SwineFlu: Try installing haskell-platform instead
02:37:18 <mbuf> I installed mueval using "cabal --ghc-options=-RTS install mueval" and also lambdabot. When trying to evaluate > 1 + 2, I get this response, " mueval: Using large values for -N is not allowed by default. Link with -rts..."
02:37:41 <mbuf> mueval --expression '1 + 2' works from CLI though
02:37:50 <SwineFlu> What is haskell-platform, is it the base libs + ghci?
02:37:55 <SwineFlu> or a whole new interperter
02:38:09 <srhb> SwineFlu: It's a more or less sanitized version of a lot of standard haskell libraries along with ghc and ghci and cabal
02:38:13 <joker_89> srhb in a comprension list how can i extract the types of my data?
02:38:30 <srhb> joker_89: You can't extract the types, you can extract the values though
02:38:33 <merijn_> SwineFlu: ghc + a bunch of important libraries standardised to work together
02:38:42 <joker_89> so the values
02:38:50 <srhb> joker_89: Pattern match on the left side of <-
02:38:53 <merijn_> oh, yeah and cabal
02:38:54 <joker_89> like (M x y)<-xs ?
02:38:58 <srhb> joker_89: Correct
02:39:17 <SwineFlu> ahh, Okay i'll use that package then, thanks :)
02:39:33 <srhb> SwineFlu: Afterwards, System.Random should definitely be available.
02:40:10 <merijn_> SwineFlu: Yeah, platform is always the right choice to begin with, doing things by hand should only be necessary if you already know what you're doing
02:40:51 <Nerioz> Hello, iam trying to make my own interpreter for a functinal language using haskell, and i have encountered something i do not quite understand how haskell behaves.
02:40:55 <Nerioz> let(x,y) = evalExp
02:40:58 <Nerioz> then let (z,w) = evalExp
02:40:59 <SwineFlu> Ahh, I was worried System.Random was decrepit
02:41:01 <Nerioz>   in show (x,w)     -- " (da, la) "
02:41:03 <Nerioz>   show(x)        -- " (x) "
02:41:10 <srhb> Nerioz: Use hpaste please
02:41:10 <Nerioz> me "nested" lets
02:41:17 <srhb> @where hpaste
02:41:18 <lambdabot> http://hpaste.org/
02:41:22 <hpaste> Nerioz pasted “wierd” at http://hpaste.org/83977
02:41:28 <srhb> SwineFlu: Random is Haskell98, System.Random is Haskell2010
02:41:28 <Nerioz> sorry
02:41:55 <Nerioz> my problem is that my show(x,w) does not show the same x as the line bellow
02:42:22 <srhb> I need more context than that. What is "then"?
02:42:55 <quicksilver> Nerioz: that's not haskell.
02:43:01 <quicksilver> Nerioz: you can't write let ... then ...
02:43:08 <Nerioz> i scaled down it so it would be easier for oyu to read.. i thought
02:43:13 <Nerioz> ill give you the haskell code then
02:43:13 <srhb> It's not. :D
02:43:16 <quicksilver> and that use of show isn't right
02:43:36 <srhb> It will probably make more sense once we see the actual code. :-)
02:43:49 <hpaste> Nerioz pasted “wa” at http://hpaste.org/83978
02:44:20 <Nerioz> my in error i made for debugging, to see why my evalExp does not behave as i expect it too
02:44:40 <Nerioz> and i encountered that i get diffrent error messages from show(id,exp') then what i get with show(id)
02:45:05 <SwineFlu> welll haskell platform is HUGE
02:45:20 <srhb> SwineFlu: Yup.
02:45:28 <srhb> Nerioz: Why does that puzzle you?
02:45:32 <turiya> does unboxed correspond to WHNF or NF?
02:45:50 <quicksilver> I assume Nerioz meands that id returned a different value each time
02:45:54 <Nerioz> yes
02:45:55 <quicksilver> which seems unlikely
02:46:02 <Nerioz> thats right quicksilver
02:46:18 <quicksilver> there is no haskell feature which would explain that
02:46:26 <quicksilver> you're confusing yourself and doing something else wrong :)
02:46:37 <liyang> turiya: NF. It actually stores the vector as contiguous bytes in memory.
02:46:39 <quicksilver> or misunderstanding the output
02:46:39 <Nerioz> ya, i thought so myself since it makes no sense at all
02:47:20 <turiya> liyang: i see
02:48:37 <liyang> Hence there are only limited numbers of Unbox instances: only those that you can figure out how to represent in terms of primitive types.
02:49:19 <Nerioz> I will try to figure it out my recurssive loops myself then, thanks for looking
02:51:19 <merijn_> SwineFlu: platform includes *a lot* of stuff, i.e. the idea is that "if almost any program requires library X to be written, X should be in platform"
02:51:28 <turiya> i see
02:52:22 <merijn_> SwineFlu: So it includes stuff like filesystem, networking, http, common data structures, etc.
03:06:30 * hackagebot hoauth2 0.3.0 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.3.0 (HaishengWu)
03:26:02 <ski> .. unboxed doesn't really correspond to NF
03:36:33 * hackagebot free-game 0.3.2.6 - Create graphical applications for free.  http://hackage.haskell.org/package/free-game-0.3.2.6 (FumiakiKinoshita)
03:41:33 * hackagebot Monaris 0.1.5 - A simple tetris clone  http://hackage.haskell.org/package/Monaris-0.1.5 (FumiakiKinoshita)
03:50:25 <alang> edwardk: hi
03:50:31 <edwardk> yo
03:50:52 <alang> edwardk: how do you feel about whether not we should hide some things in AD?
03:51:56 <edwardk> i generally feel free to load the gun and point it at your foot so long as the trigger is in a module named Foo.Internal.Bar
03:52:23 <edwardk> what do you want to hide?
03:52:46 <alang> I don't really want to hide anything, but https://github.com/ekmett/ad/issues/1#issuecomment-14791279
03:54:14 <edwardk> fair enough
03:54:31 <edwardk> i mostly just need to recheck my invariants
03:54:37 <edwardk> we're most likely okay
03:55:25 <alang> ah maybe my closing of the issue was a bit hasty
03:55:36 <sopvop> edwardk: I've managed to use your Trifecta.Rendering, even though it completely lacks documentation. Are you going to change it in near future? I'm thinking about adding some docs.
03:56:10 <edwardk> i've been leaning towards replacing it with something more like an initial encoding so it can be serialized
03:57:09 <edwardk> that way the rendering would encode the source line, any highlighting, and what has been drawn on top basically
03:57:52 <edwardk> but in a more defunctionalized way so we can serialize it
03:58:50 <edwardk> sopvop: trifecta could definitely stand a documentation pass though
03:59:13 <edwardk> i freely admit i've fallen down on that job ;)
03:59:32 <sopvop> Lens show what you can improve quite a bit
04:00:37 <edwardk> Lens's docs are my deliberate effort at figuring out what it takes to focus on community outreach
04:02:02 <edwardk> i love what i have of them, but they could suck another 2 months of time out of me easily
04:03:21 <edwardk> trifecta < 1.0 had a pretty craptastic API. lots of exposed wires because i was writing it because i needed it, so i never polished it up
04:04:11 <edwardk> the 1.0 release was more because i started needing to use it 'in anger' again, and i wanted to shrink the api down to something manageable after not looking at it for a year
04:04:38 <edwardk> now its small enough that it can probably be polished and documented nicely
04:05:14 <sopvop> before parsers split I was scared of its size :)
04:05:15 <edwardk> the rendering bits are probably the last bits of exposed wiring
04:05:20 <AfC> edwardk: any low hanging fruit that might improve its performance? I would _love_ to use it on the critical path, but...
04:05:55 <edwardk> AfC: sure. i just need to bang out another parser for it. the prim parser there is designed to get me all the bells and whistles, not for speed
04:06:42 <edwardk> another parser like the Prim parser that doesn't do the rope stuff, which doesn't track highlights etc. could be quite fast
04:06:50 <mgsloan> sopvop: when I tried to add something to the old trifecta, it turned out it already had it ;)
04:06:58 <edwardk> mgsloan: =)
04:08:00 <sopvop> I've converted my "peggy" parser to trifecta in two days of work. And that is for quite large c-like language with a bits of unfriendly syntax for LL(1). Much faster btw.
04:08:03 <sopvop> works
04:08:48 <edwardk> i'd like to get a couple of extra parsers in
04:08:49 * sopvop hopes he is using LL(1) appropriately.
04:08:59 <edwardk> one closer to just what parsec does and one closer to attoparsec
04:09:07 <edwardk> sopvop: yeah
04:11:31 <sopvop> Now I'm writing a type checker. That language has function overloading by return type and params types, and also implicit type casts. And the only way to understand how it should work - use closed source compiler and check results.
04:11:43 <edwardk> i also need to push out an update with a new shunting yard expression parser, etc.
04:12:22 <edwardk> sopvop: if it was a more lambda-calculus-like language i'd be selling you on bound now ;)
04:12:32 <edwardk> @hackage bound
04:12:32 <lambdabot> http://hackage.haskell.org/package/bound
04:13:03 <edwardk> http://www.slideshare.net/ekmett/bound-making-de-bruijn-succ-less
04:13:04 <sopvop> Maybe I'll make a haskell-like language with compiler to this language later :)
04:13:26 <sopvop> (but no laziness)
04:14:56 <miasma> what kind of haskell alternative would you recommend for embedded systems with very little ram and rom. garbage collection and functional paradigm would still be nice
04:15:19 <miasma> let's say the main problem with ghc generated binaries is that they're 90% too large
04:15:28 <miasma> even after stripping
04:15:42 <edwardk> miasma: jhc can generate pretty small executables
04:48:54 <bitonic> miasma: you can also use hugs
04:55:57 <mel-> hi
04:56:01 <srhb> mel-: Hi.
04:56:22 <snoyberg> edwardk: i'm guessing you know about the free/recursion-schemes dependency issue?
04:57:47 <mel-> I'm interested in trying out 'gitit'. In oder to reduce it's very huge memory footprint, the documentation tells me to use 'cabal install --reinstall -f-plugins gitit' (it disables plugin support). the problem is that I'm on FreeBSD and have used the ports systems to install the gitit port. so I am not using cabal. It's rather unclear to me how I can disable plugin support in this situation. anyone can help?
04:58:25 <merijn_> mel-: Depends on whether the port maintainer included options like that in the port
04:58:50 <mel-> well, it seems that it is not contained in 'make config' -- the usual way to configure ports before installation.
04:58:50 <merijn_> I suspect it uses cabal internally anyway, but not sure whether you can do it without just reinstalling gitit manually
04:59:05 <mel-> I just don't know much about ports internals. :-/
04:59:44 <merijn_> Gotta run though, so no time to troubleshoot. I suspect the peeople in ##freebsd are more able to help with ports
04:59:50 <mel-> i do have cabal related directories in /usr/local. but no exacutable by that name.
04:59:55 <mel-> merijn_: thanks
05:00:02 <mel-> but they are unfriendly ;-)
05:31:35 <hpaste> mcstar pasted “n-ary lifter generalization over monads” at http://hpaste.org/83979
05:32:00 <mcstar> so, i have this code ^^ and cant generalize it over any monad
05:32:12 <mcstar> it uses Maybe now
05:32:49 <mcstar> the problem is, in general there is no inverse of return
05:32:59 <mcstar> like patter matching on (Just x)
05:33:45 <mcstar> also, it would be nice, if the return type could be deduced automatically...
05:36:49 <nomeata> Hi. I see many blog posts about how to solve the cabal dependency hell. But is there a comprehensive overview of what the hell exactly is? I.e. what kind of error conditions are considered the dependency hell?
05:37:20 <dcoutts> nomeata: not really, it's turned into a catch all term for "it didn't do what I wanted!"
05:37:46 <dcoutts> nomeata: I started writing a blob post trying to sort it all out, classify things, havn't finished :-)
05:37:47 <nomeata> in that case, I am really looking forward to a working solution that preventes dependency hell.
05:39:04 <dcoutts> nomeata: I classify them into two kinds: one is where there is a solution so that you can install packages, but local packages end up getting broken
05:39:29 <dcoutts> nomeata: and the other kind is where there really is no solution, and packages have to be adjusted to allow a solution
05:39:50 <dcoutts> the solutions to them are different
05:40:02 <nomeata> great, thanks.
05:40:06 <dcoutts> sorry, the way to fix those problems are different
05:40:07 <typoclass> nomeata: googling "cabal hell" brings up 1-2 blog posts by snoyman and other links
05:40:30 <nomeata> (I’m writing an abstract on "Haskell and Debian" for HaL8.)
05:40:36 <dcoutts> btw, snoyman mainly talks about the second class of problem there
05:42:35 <dcoutts> nomeata: I'm not sure if debian's haskell tools do this yet, but it would make a lot of sense to use the cabal-install solver to help decide which set of versions to package for debian
05:43:50 <johnw> i love it when a new library comes out exactly when I need it :)
05:43:59 <johnw> i've been needing 'retry' for a couple days now
05:44:17 <aleator_> Just a sidenote: I haven't been bothered by cabal-hell for the last year. I'm beginning to wonder why everyone else is hit by it.
05:44:28 <nomeata> dcoutts: we just started to do that: http://anonscm.debian.org/darcs/pkg-haskell/tools/all-packages/all-packages.cabal
05:44:33 <aleator_> Just because of yesod?
05:44:38 <dcoutts> nomeata: ah good
05:45:07 <nomeata> dcoutts: but for us it wasn’t too bad anyways, as we could, for example, patch build dependencies in our packages (to solve problem 2)
05:45:16 <dcoutts> nomeata: right
05:45:31 <dcoutts> nomeata: and if you relax the deps, you can use it to find solutions, not just check them
05:45:42 <nomeata> dcoutts: also done before :-)
05:45:51 <nomeata> and problem 1 is also no problem as the binary packages enforce their constraints using virtual package names that include the ABI hash
05:45:53 <dcoutts> ok good good
05:46:26 <nomeata> This file was the reason for https://github.com/haskell/cabal/pull/1191
05:46:45 <dcoutts> nomeata: ah
05:46:57 <dcoutts> nomeata: right, I realise this is all solvable with a curated collection like a distro
05:47:20 <nomeata> I could imagine better tools with working with that file (e.g. „suggest me what can be safely upgraded“), but otherwise we do ok so far
05:47:24 <dcoutts> because then it eliminates the choice of which package to use, it's decided by someone else already
05:47:39 <nomeata> right, one my selling points in the talk :-)
05:47:58 <dcoutts> which is good, it's the service that distros provide
05:48:18 <sopvop> is there MonadState version of 'withState' hidden somewhere? (run action with modified state, then revert state)
05:49:23 <sopvop> hm, it's not what withState does :(
05:49:43 <supki> yeah, withState is useless
05:51:30 <sopvop> need something like local for reader, but for state.
05:52:14 <ghorn_> can someone help me write a list of ByteStrings to file in a way that I can read them in in python?
05:52:25 <sopvop> it's like 4 lines in do notation, but don't want to reinvent wheel
05:53:01 <sopvop> ghorn_: ByteString is like bytes (or str) in python.
05:53:07 <supki> sopvop: there is no wheel to reinvent unfortunately
05:53:10 <sopvop> str in <3.0
05:54:35 <ghorn_> sopvop: i was thinking of converting the list of bytestrings to one big String or Text using unlines . (map show), and then writing that to file
05:54:59 <ghorn_> i figured there was a better way to do it
05:55:01 <quchen> What's wrong with 'withState'?
05:55:12 <quchen> Or what's the difference to it you need?
05:56:12 <aleator_> Could anyone give me hints how to best structure gtk2hs programs? I'm ending up with a huge mess: https://gist.github.com/aleator/5151805
05:56:55 <project2501b> hey guys. i am trying to install pandoc via macports. unfortunatelly, it fails at this line: instance IsString Inlines where fromString = text . the error i get is  Use -XFlexibleInstances if you want to disable this. how do i fix the variable decleration, please?
05:57:42 <aleator_> project2501b: which pandoc and which ghc?
05:57:52 <project2501b> let me check, please.
05:58:27 <aleator_> project2501b: Though, I'm quite likely to just recommend you to install it with cabal :/
05:58:50 <project2501b> there is a status string "Building pandoc-types-1.8...". therefore i will assuem that pandoc version is 1.8 . ghc version is The Glorious Glasgow Haskell Compilation System, version 7.4.2
05:59:01 <project2501b> meh. it's a syntax error
05:59:25 <project2501b> it does not warrant for me to learn a (yet another) installation system
05:59:33 <project2501b> when i learn haskell...
06:00:14 <nomeata> ghorn_: "mapM_ (hPut handle) listOfBytestring" might be more efficient. Or do you need to quote them?
06:00:33 <ghorn_> i don't need to quote them
06:00:51 <ghorn_> that'll work, thanks
06:02:42 <sopvop> > runStateT (withStateT succ (get >>= lift . putStrLn . show) >> get >>= lift . putStrLn . show) 0
06:02:43 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ((), s0)))
06:02:43 <lambdabot>    arising from a u...
06:04:06 <sopvop> quechen: it prints  1 1, I want one which would print 1 0 :) like local in MonadReader
06:04:21 <sopvop> quchen
06:04:50 <hpaste> sopvop pasted “withLocalState” at http://hpaste.org/83980
06:22:00 <hseg> I have the following bit of Parsec code, which uses the monadic combinators. I have a hunch that some combination of liftA, <* and *> will allow me to rewrite it using Applicative combinators.
06:22:02 <hseg> string "push" *> spaces *> segment >>= \s ->spaces *> many digit >>= \n -> return . Just $ Push s (read n)
06:23:43 <Botje> at a guess .. string "push" >> liftM2 (\s n -> return . Just $ Push s (read n)) (spaces *> segment) (spaces *> many digit)
06:23:55 <Botje> or even
06:24:12 <Botje> oh blah, i forgot how to do that again :/
06:24:41 <supki> s/return \. //
06:25:03 <hseg> string "push" *> liftA2 (\s n -> pure . Just $ Push s (read n)) (spaces *> segment) (spaces *> many digit)  ? is that what you meant?
06:25:28 <hseg> string "push" *> liftA2 (\s n -> Just $ Push s (read n)) (spaces *> segment) (spaces *> many digit)  Oops. Forgot liftA2 already makes it pure
06:25:34 <johnw> :t msum
06:25:36 <lambdabot> MonadPlus m => [m a] -> m a
06:25:44 <Botje> something like that, yes
06:26:04 <hseg> Which can be rewritten using <$> and <*>.
06:26:06 <hseg> Nice
06:26:39 <Botje> I never got on the applicative train :)
06:26:55 <Botje> <* and *> are about the only combinators I use regularly
06:27:43 <hseg> Why? They are quite nice. Although I can't think of any really useful situations in which I've used them to the exclusion of monads
06:29:33 <Botje> that's my problem :)
06:30:02 <hseg> :-)
06:31:43 <johnw> you guys might like this article: http://comonad.com/reader/2012/abstracting-with-applicatives/
06:31:58 <johnw> applicative Writers, for example, have different semantics from monadic Writers
06:35:57 <quicksilver> johnw: you might say "may have"
06:36:08 <johnw> true
06:36:15 <quicksilver> afterall, the standard monadic writer is an applicative and that semantics could have been chosen
06:36:20 <Botje> thanks, i'll give it a spin
06:36:22 <quicksilver> btu there is another intresting choice.
06:36:39 <quicksilver> there is an applicative-only spin on the error monad
06:36:49 <quicksilver> the error applicative can execute all branches and collect all the errors
06:37:00 <quicksilver> whereas, the error monad is forced to terminate after the first.
06:42:06 <srhb> edwardk: In the example for tables, FooId is not a seperate newtype, but defined inside the instance of Tabular. How do I cross-reference to that in different datatypes then? Using IxSet I'd have, say data Post = Post { owner :: UserId, ... }
06:42:23 <srhb> Having it be Integer now seems like it would destroy some safety in my code.
06:48:48 <simukis_> why would pandoc binary not link to it's own library (libHSpandoc-1.11-ghc7.6.2.so => not found) when executable is linked dynamically? Compiling other binaries dependant on pandoc dymamically links them correctly.
07:03:52 <kurkale6ka> Hi, isn't this supposed to give me a random number between 1 and 6: randomR (1,6) (mkStdGen 359353)
07:04:16 <Botje> kurkale6ka: it does?
07:04:25 <Botje> kurkale6ka: of course it also give you back a new generator...
07:04:32 <geekosaur> not really random though as you used a fixed key
07:04:38 <Entroacceptor> > randomR (1,6) (mkStdGen 359353)
07:04:40 <lambdabot>   (6,1494289578 40692)
07:04:43 <Entroacceptor> > randomR (1,6) (mkStdGen 359353)
07:04:45 <lambdabot>   (6,1494289578 40692)
07:04:47 <kurkale6ka> it gives me 6,1494289578 > 6
07:05:44 <geekosaur> kurkale6ka, the comma is not a fraction separator; it returns a tuple of (random value, new seed)
07:06:07 <Botje> :t randomR
07:06:09 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
07:06:11 <kurkale6ka> ohh, the generator is 1494289578 40692
07:06:15 <geekosaur> yes
07:06:17 <Botje> kurkale6ka: note how randomR returns a tuple (a,g)
07:06:27 <kurkale6ka> ok, thx geekosaur and Botje
07:06:38 * hackagebot hstzaar 0.9.3 - A two player abstract strategy game.  http://hackage.haskell.org/package/hstzaar-0.9.3 (PedroVasconcelos)
07:14:45 <cariveri> HI. How do I construct a Graphics.UI.Gtk.Multiline.textiter for a call of textBufferGetText ?
07:18:54 <mcstar> dejavu
07:20:22 <inics> Maybe someone can help me a little bit with VBA(Visual Basic in excel) of course who understand it :))))
07:21:25 <saml> what's up?
07:21:37 <srhb> saml: Just spam, it was kicked.
07:21:47 <saml> ah
07:23:36 <cariveri> Why doesn this work?: eachsec (l:s:ls) = (l:ls)
07:24:05 <mcstar> why do you think it doesnt?
07:24:08 <quchen> > let eachsec (l:s:ls) = (l:ls) in eachsec [1..5]
07:24:09 <lambdabot>   [1,3,4,5]
07:24:11 <quchen> Works.
07:24:19 <quchen> But the name is misleading.
07:24:27 <cariveri> me itdiot. sorry. missed to write "let"
07:24:42 <quchen> What you're probably looking for is eachsec (l:_:ls) = l : eachsec ls
07:25:30 <mcstar> idk, id call that function every2nd
07:25:53 <saml> cariveri, what is this?
07:26:29 <cariveri> quchen: yes I was going to write " let eachsec (l:_:ls) = (l:(eachsec (ls)))"
07:26:43 <mcstar> cariveri: too many parens
07:26:54 <cariveri> saml: Im trying to get every second elem from the list.
07:27:05 <saml> cdar?
07:27:13 <cariveri> mcstar: yes sure. could be ommited.
07:27:30 <quchen> Should.
07:27:33 <saml> cariveri, what if the list is []  or [1] ?
07:27:38 <ski> not `cdar'
07:27:48 <cariveri> saml: those cases are in a seperate definition of course.
07:27:51 <mcstar> cdar gives the second of a list
07:27:54 <mcstar> not every second
07:28:06 <saml> map cdar
07:28:14 <saml> oh every second
07:28:14 <mcstar> rather, fold
07:28:16 * ski would call it "every odd" element
07:28:18 <mcstar> or reduce, no?
07:28:26 <quchen> > let cdar (x:_:xs) = x : cdar xs; cdar xs = xs in cdar [1..5]
07:28:28 <lambdabot>   [1,3,5]
07:28:29 <saml> unzip?
07:28:31 <quchen> Tadaa
07:28:41 <saml> i think groupBy
07:28:43 <mcstar> ski: right, it drops every 2nd
07:28:52 <ski> quchen : .. but that's not what `cdar' is supposed to do .. :/
07:29:14 <cariveri> ski: "odd" would require the elements to be nums, not?
07:29:19 <saml> how would you do this?
07:29:22 <quchen> ski: There is no cdar in Haskell. It's like arguing that 'return' does the wrong thing here.
07:29:35 <mcstar> quchen: you just defined cdar
07:29:44 <ski> quchen : yes
07:30:19 <ski> cariveri : no, i was thinking of the indices -- though on second thought, it ought to be evens
07:30:27 <ski> (the odds are the dropped ones)
07:30:45 <johnw> > map head . chunk 2 $ [1,2,3,4,5]
07:30:48 <lambdabot>   [1,3,5]
07:31:03 <mcstar> ski: no, evens are dropped, odds are kept
07:31:11 <mcstar> (l:_:ls) = l : eachsec ls
07:31:18 <Iceland_jack> filter odd [1..5] -- ;P
07:31:20 <saml> > map (\(_,x) -> x) $ filter (\(i,x) -> i `mod` 2 == 0) $ zip [1..] [1..]
07:31:22 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
07:31:33 <mcstar> Iceland_jack: odd or even position!
07:31:33 <saml> maybe that's too noob
07:31:34 <ski> mcstar : depends on where you start indices
07:31:44 <Iceland_jack> mcstar: T'was a joke!
07:31:50 <mcstar> Iceland_jack: i know!
07:31:53 <mcstar> :)
07:32:02 <Iceland_jack> also saml, Haskell has the functions even/odd
07:32:10 <Iceland_jack> so there's no need for i `mod` 2 == 0
07:32:21 <ski> > map ("abcdefgh" !!)  [0,2 ..]
07:32:23 <lambdabot>   "aceg*Exception: Prelude.(!!): index too large
07:32:29 <mcstar> ski: yeah, right, i dont like to index lists from 0
07:32:36 <mcstar> but indeed, !! does
07:33:04 <quchen> > let go x acc True = x : acc False; go x acc False = acc True; every2nd xs = foldr go (const []) xs True in every2nd [1..10]
07:33:06 <lambdabot>   [1,3,5,7,9]
07:33:25 <Iceland_jack> > [ c | c <- "This is just a test" | i <- [0..], even i ]
07:33:28 <lambdabot>   "This is just a test"
07:33:36 <mcstar> ski: i found a nice symmetric way to write liftMN in terms of liftM(N-1)
07:33:52 <Iceland_jack> > [ c | (c, i) <- zip "This is just a test" <- [0..], even i ]
07:33:53 <lambdabot>   <hint>:1:43: parse error on input `<-'
07:33:56 <mcstar> maybe i can now make one for the general case
07:33:57 <Iceland_jack> hah
07:33:59 <ski> mcstar : with `(=<<)' or `(<*>)' ?
07:34:01 <Iceland_jack> > [ c | (c, i) <- zip "This is just a test" [0..], even i ]
07:34:03 <lambdabot>   "Ti sjs  et"
07:34:15 <mcstar> ski: i use bind, ofc, but there was a trick
07:34:45 <ski> mcstar : in the algorithm, or in the type class trickery ?
07:35:13 <mcstar> so far, this is the algoritm
07:36:21 <mcstar> ski: lets have a modified liftM3, for example, call it liftM3M :: Monad m => m (a -> a -> a -> a) -> m a -> m a -> m a -> m a; now this can be expressed as: liftM3M mfun mv = liftM2M (mv >>= \v -> mfun >>= \f -> return (f v))
07:36:47 <mcstar> and liftM2M looks like this too
07:37:02 <mcstar> with the obvious change to liftM1M inside
07:37:25 <mcstar> now, ill see, if i can makes this function take an n-ary monadic function
07:37:45 <mcstar> liftMNM :: m (a -> ...) -> m a -> ....
07:38:30 <mcstar> and the real liftMN would just wrap its first argument with return, and start the hierarchy
07:38:49 <ski> mcstar : hm, when i pondered it a little yesterday, i was thinking of using `(=<<)' -- but i think it ought to work with `ap'/`(<*>)' (assuming the type class stuff works out)
07:40:27 <beaky> hello
07:40:35 <beaky> how do I invoke haskell from C++?
07:41:15 <mcstar> system("ghci");
07:41:39 <osfameron> hehe
07:41:58 <beaky> hah that's brilliant actually
07:42:11 * beaky tries it out
07:42:14 <cariveri> so guys.this did a good job :  let eachsec [] = []; eachsec (h:[]) = [h]; eachsec (h:_:ls) = h:(eachsec ls)
07:42:23 <cariveri> thank you for help.
07:42:27 <kurkale6ka> Is this clumsy: map ("web"++) $ map show $ [16..26] ++ [31..33]
07:43:10 <mauke> map (printf "web%d") $
07:44:02 <ski> cariveri : btw, `h:(eachsec ls)' can be written as `h : eachsec ls' and `(h:[])' as `[h]'
07:44:31 <supki> > [1..] ^.. ifolded . Lens.indices even
07:44:31 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
07:45:23 <kurkale6ka> mauke: ok, cool
07:45:30 <beaky> > [1,2,3,5,7,11..]
07:45:31 <lambdabot>   <hint>:1:14: parse error on input `..'
07:45:33 <beaky> :(
07:46:00 <beaky> is there a haskell 1-liner for primes?
07:46:08 <ski> (btw, `1' is not a prime)
07:46:10 <Botje> now you've done it :]
07:46:32 <typoclass> kurkale6ka: i would say it's ok. it's not very clumsy. you can combine "map f $ map g" into "map f . g". also, you could use a list comprehension, but it won't really buy you much ... ["web" ++ show x | x <- [16..26]++[31..33]]
07:46:59 <beaky> ah, [2,3,5,7..]
07:47:03 <beaky> > [2,3,5,7..]
07:47:05 <lambdabot>   <hint>:1:9: parse error on input `..'
07:47:13 <kurkale6ka> typoclass: great
07:47:30 <mauke> > nubBy(((>1).).gcd)[2..]
07:47:32 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:47:37 <beaky> :O wow
07:47:38 <armlesshobo> so, if f ~(a,b) = g a b, then Haskell won't pattern match in f, but in g?
07:47:46 <beaky> :t nubBy
07:47:47 <lambdabot> (a -> a -> Bool) -> [a] -> [a]
07:47:59 <Botje> armlesshobo: *when a or b is forced in g
07:47:59 <ski> @oeis 1 2 3 5 7 11 13
07:48:00 <lambdabot>  Prime numbers at the beginning of the 20th century (today 1 is no longer reg...
07:48:00 <lambdabot>  [1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,10...
07:48:06 <beaky> that is the most concise primes generator ever :(
07:48:15 <armlesshobo> Botje: right.
07:49:08 <saml> oh man you guys still working on cdar?
07:50:28 <kurkale6ka> typoclass: ("web"++).show wouldn't work though
07:50:40 <tromp__> that is not the most concise
07:50:45 <mauke> > map (("web" ++) . show) [1 .. 10]
07:50:47 <lambdabot>   ["web1","web2","web3","web4","web5","web6","web7","web8","web9","web10"]
07:51:53 <mcstar> @oeis 1 2 3 5
07:51:54 <kurkale6ka> ok, I hadn't put the () around the composition
07:52:08 <lambdabot> Plugin `oeis' failed with: thread killed
07:52:12 <mcstar> @oeis 1 2 3 5 7
07:52:12 <lambdabot>  a(n) = number of partitions of n (the partition numbers).
07:52:12 <lambdabot>  [1,1,2,3,5,7,11,15,22,30,42,56,77,101,135,176,231,297,385,490,627,792,1002,1...
07:52:24 <mcstar> @oeis 1 2 3 5 7 11
07:52:25 <lambdabot>  a(n) = number of partitions of n (the partition numbers).
07:52:25 <lambdabot>  [1,1,2,3,5,7,11,15,22,30,42,56,77,101,135,176,231,297,385,490,627,792,1002,1...
07:52:32 <mcstar> hm
07:52:49 <tromp__> http://en.wikipedia.org/wiki/Binary_lambda_calculus#Complexity_of_Sets has a prime sieve in 21 bytes :)
07:53:36 <Botje> probably there's some J or APL monstrosity in fewer
07:54:36 <tromp__> and it's in a language with no primitives for numbers or arithmetic:)
07:54:57 <mcstar> >length "@oeis 1 2 3 5 7 11 13" + 1
07:55:23 <mcstar> 22
07:59:43 <quchen> Botje: Is J used beyond golf at all?
07:59:58 <quchen> I've only seen it on the ProjectEuler forums, where it's very uhmmmm concise
08:00:27 <quchen> Looks like someone wanted to save code by gzipping it
08:01:00 <mcstar> ofc it is used
08:01:11 <mcstar> by statisticians, or actuarists
08:01:28 <mcstar> variants of apl still live on
08:01:39 <mcstar> friend of my programmed in one of those at MS
08:02:19 <icarus127> mauke: How does that work?  Since nubBy will leave one of the two in the list.
08:02:23 <mcstar> not M$
08:02:30 <icarus127> mauke: I see that it does work
08:02:50 <icarus127> mauke: But can't figure out why mathematically anything that's not prime is definitely removed
08:03:00 <mauke> icarus127: what two?
08:03:13 <quchen> icarus127: nub keeps the first element that occurs, and then discards further elements that are equivalent to it.
08:03:34 <icarus127> mauke: Right, so if two numbers have a gcd
08:03:42 <icarus127> mauke: Both are not prime, but one is retained
08:03:46 <mauke> no
08:03:54 <icarus127> mauke: well, unless the gcd is one of the numbers
08:03:55 <mauke> the first number is always prime
08:04:24 <icarus127> mauke: Ah I see now
08:04:29 <icarus127> mauke: Thanks
08:04:29 <mcstar> ski: is there a complement to the typelevel operator ~ ?
08:04:38 <ski> mcstar : i don't think so
08:05:18 <ski> mcstar : hm, `apA :: Applicative i => i (a -> b -> ... -> z) -> (i a -> i b -> ... -> i z)' works here
08:05:33 <mcstar> niiice
08:05:49 <ski> `liftA :: ApA i a ia => a -> ia' is ambiguous, though
08:08:57 <saml> where can i get haskell certificate?
08:09:06 <saml>  i want to have a wall of certificates
08:09:15 <johnw> saml: i think you can use LaTeX to make one and then print it ;)
08:09:28 <saml> is there a website for a wall of certificates?
08:09:33 <johnw> "I knows me a Haskell"
08:09:37 <Botje> saml: I think the typical haskell certificate is a monad tutorial you wrote yourself :)
08:09:43 <johnw> lol
08:09:51 <johnw> Botje: so true!
08:09:52 <Philippa> Botje: aaah, that's why nobody thinks I know my shit!
08:10:47 <mcstar> you get the certificate when it will be certain that you restrain yourself and not write a monad tutorial
08:10:55 <mcstar> unfortunately that cant happen until you die
08:11:15 <ski> mcstar : i suppose one basic ambiguity is, given `f :: a -> b -> c', how do we know whether `liftA f :: i a -> i b -> i c' or (e.g.) `liftA f :: i a -> i (b -> c)' was wanted ?
08:11:50 <johnw> indeed, it is in fact harder to explain monads than it is to understand them, so even after we understand them, we feel it a personal challenge to someday explain them "right" :)
08:12:46 <johnw> and the reason why it's hard to *learn* them is because we learn by hearing other's explanations, and then re-explaining it to ourselves
08:13:23 <cariveri> How do I construct a Graphics.UI.Gtk.Multiline.TextIter for a call of textBufferGetText ?
08:13:42 <Philippa> so I still think there are some explanations that are much more right than most of them. Not necessarily the easiest to learn a first pass from, but definitely useful for verifying against
08:14:46 <johnw> it reminds me of why it's better to not teach yourself how to play the piano
08:15:05 <johnw> because you can, it's not like it's impossible to do, but you will invariably teach yourself bad habits that you'll likely never outgrow
08:15:25 <johnw> bad monad tutorials are somewhat like that
08:15:39 <johnw> it's better to read a harder tutorial and put the time in, than try to shortcut the process with a clever analogy
08:16:46 <kqr1> i think that varies from person to person
08:16:55 <quchen> Learning about monads is mostly about not trying to make sense of them, because then they make sense.
08:16:58 <Philippa> it's usually good to've seen both
08:17:20 <kqr1> i made myself a collection of what felt like every monad tutorial ever
08:17:26 <kqr1> both good and bad
08:17:29 <mcstar> ski: liftMNM is working for me
08:17:38 <mcstar> having trouble with liftMN
08:17:45 <johnw> like, the tutorials that explain monads as containers are better left until later
08:17:49 <quchen> Punching the guy who wrote "All about monads" is still on my Haskell todo list ;-)
08:17:53 <kqr1> and ?fter reading one of them a day for a while i learned
08:17:59 <johnw> quchen: lol
08:18:29 <Philippa> johnw: hah. Mileage really varies on that: for me, "monads as containers" is just Not Useful (disclaimer: I was doing plenty of teaching others in here by the time Cale wrote that)
08:18:42 <ski> mcstar : your `liftMNM' is probably my `apA' (albeit more monomorphic)
08:18:44 <johnw> what I would like to see is people writing nice, long functor tutorials, and then at the last moment slipping in the natural transformations that allow you to make a monad
08:18:50 <mcstar> ski: yes
08:19:15 <johnw> Philippa: yeah, I still am rooting that idea of my brain whenever I find it
08:19:22 <johnw> out of*
08:19:24 <ski> mcstar : i suppose you get ambiguity problems with your `liftMN' as well ?
08:19:30 <quchen> johnw: [800 lines of Functor stuff] and now we'd like to create a functor from nothing and flatten funcors and bam monad. Now back to functors!
08:20:09 <mcstar> ski: im getting "Could not deduce" problems
08:20:37 <ski> quchen : how about "What the Hell are Monads ?" ?
08:21:14 <quchen> Subtitle: "Dunno, and can't explain it". git diff @ all about monads author
08:21:15 <matthew-> I don't suppose the author of hashring is here? Mike Craig?
08:22:53 <mcstar> ski: as i see it, ghc cant make sure the monad in liftMNM is the same as in liftMN
08:23:12 <quchen> matthew-: There are a lot of people in this channel, but most of them are idle. I think you're better off using emails if you need someone specific.
08:23:18 <ski> quchen : you read it ?
08:23:45 <quchen> ski: Oh wait, that wasn't a joke - "WTH are monads" *exists*?
08:24:03 <ski> quchen : yes, it's one of the first, if not the first, monad tutorial
08:24:37 <ski> "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html>
08:25:05 <fizbin> :t (((>1).).gcd)
08:25:07 <lambdabot> Integral a => a -> a -> Bool
08:25:09 <ski> (not counting the various wadler papers, moggi papers, &c. among the tutorials)
08:25:50 <mcstar> i really wonder what kind of indexing too ski uses
08:25:53 <mcstar> tool*
08:25:55 <ski> quchen : btw, sometimes people have known under which nick someone goes in here
08:26:14 <johnw> I use DEVONthink to do my indexing
08:26:27 <johnw> nowadays every single thing I read relating to Haskell gets snapshot to a PDF
08:26:31 <ski> mcstar : i have a big dump of URLs i've found interesting, which i `grep' through
08:26:41 <johnw> even if I don't want to read it again, I often want to refer people to it later
08:26:48 <mcstar> thanks, very old school
08:27:18 <quchen> ski: Oh, a piece of monad history. It resembles most of the later tutorials a lot. (Therefore I wonder why those exist.)
08:27:22 <mcstar> im trying to keep my stuff in .org files
08:32:05 * sm does that
08:32:49 <sm> I wish pandoc could read them
08:33:42 <Clint> shouldn't be too hard to just handle the bits that the output code handles already
08:34:49 * sm nods
08:35:28 <sm> getting it into pandoc is a fair bit of work. That thing has test! (brr)
08:35:33 <sm> s
08:44:29 <beaky> if there are higher-order functions, are there first-order functions in haskell?
08:44:43 <Philippa> of course
08:45:00 <Philippa> a first order function is one where -> doesn't appear on the LHS of an ->
08:45:03 * fizbin gives "succ" as the canonical first-order function.
08:45:16 <fizbin> Or maybe "id"
08:45:28 <Philippa> id is "take your pick" order
08:45:39 <Philippa> in that you can instantiate it to operate on an nth-order function
08:45:47 <fizbin> Fair enough.
08:45:53 <beaky> :t succ
08:45:55 <lambdabot> Enum a => a -> a
08:46:08 <beaky> so by default all haskell functions are higher-order? :D
08:46:35 <Philippa> until the parameter is constrained to a non-function type, yes
08:47:16 <fizbin> :t \x -> x + (1::Integer)
08:47:17 <lambdabot> Integer -> Integer
08:48:16 <beaky> ah
08:48:33 <beaky> so generic functions are also higher-order (unless they only take one argument)?
08:48:47 <beaky> :t \_ -> id
08:48:49 <lambdabot> t -> a -> a
08:48:56 <fizbin> :t id
08:48:57 <lambdabot> a -> a
08:49:20 <fizbin> And since that "a" could have any type...
08:49:54 <fizbin> :t let y f = f (y f) in y
08:49:55 <lambdabot> (t -> t) -> t
08:50:24 <beaky> the y combinator is a higher-order function?
08:50:29 <beaky> since it takes a function?
08:52:55 <Philippa> beaky: yep
08:53:15 <beaky> ah
08:53:18 <fizbin> > let y f = f (y f) in (y succ)::Integer
08:53:20 <lambdabot>   *Exception: stack overflow
08:53:38 <beaky> :t (+) :: Int -> Int
08:53:40 <lambdabot>     Couldn't match expected type `Int' with actual type `Int -> Int'
08:53:40 <lambdabot>     Expected type: Int -> Int
08:53:40 <lambdabot>       Actual type: Int -> Int -> Int
08:53:43 <beaky> :(
08:54:01 <bitonic> fizbin: Integer is not what you want if you want that to be productive
08:54:01 <beaky> :t (+) :: Int -> Int -> Int -- this is a second-order function?
08:54:02 <lambdabot> Int -> Int -> Int
08:55:19 <fizbin> :t fix
08:55:20 <lambdabot> (a -> a) -> a
08:55:54 <fizbin> @hoogle fix
08:55:55 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
08:55:55 <lambdabot> Data.Fixed module Data.Fixed
08:55:55 <lambdabot> Data.Function fix :: (a -> a) -> a
08:56:38 * fizbin isn't looking for "productive", per se.
08:56:57 <fizbin> > (fix succ) :: Integer
08:57:01 <lambdabot>   mueval-core: Time limit exceeded
08:57:39 <elliott> fizbin: that's a technical meaning of "productive"
09:01:07 <parcs> what is the point of 'swap ~(a,b) = (b,a)' ?
09:01:25 <parcs> i don't see how the irrefutable pattern affects anything
09:01:40 * hackagebot quickspec 0.9.1 - Equational laws for free  http://hackage.haskell.org/package/quickspec-0.9.1 (NickSmallbone)
09:01:44 <parcs> oh, never mind. i see
09:01:57 <parcs> > let swap ~(a,b) = (b,a) in swap undefined `seq` ()
09:01:59 <lambdabot>   ()
09:03:09 <beaky> :t seq
09:03:13 <lambdabot> a -> b -> b
09:03:32 <beaky> :t swap
09:03:33 <lambdabot> (a, b) -> (b, a)
09:03:36 <beaky> :t flip
09:03:38 <lambdabot> (a -> b -> c) -> b -> a -> c
09:03:58 <beaky> :t a -> b -> b
09:03:59 <lambdabot> parse error on input `->'
09:04:08 <beaky> @djinn a -> b -> b -> a
09:04:08 <lambdabot> f a _ _ = a
09:04:54 <beaky> @djinn a -> b -> (a -> b -> c) -> c
09:04:54 <lambdabot> f a b c = c a b
09:05:05 <beaky> wow djinn is smart
09:05:12 <fizbin> > let y f = f (y f) in take 500 $ y (\x -> [] : concatMap (\p -> map (:p) [1,2,3]) x)
09:05:14 <lambdabot>   [[],[1],[2],[3],[1,1],[2,1],[3,1],[1,2],[2,2],[3,2],[1,3],[2,3],[3,3],[1,1,...
09:06:41 * hackagebot hamlet 1.1.6.4 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.6.4 (MichaelSnoyman)
09:10:00 <quchen> beaky: That's nothing. Djinn can write Cont for you. http://permalink.gmane.org/gmane.comp.lang.haskell.general/12747
09:10:47 <quchen> This is what I use to excuse how I still don't understand the Cont instance: "well, it's unique anyway"
09:11:40 * hackagebot wai-routes 0.2.1 - Typesafe URLs for Wai applications.  http://hackage.haskell.org/package/wai-routes-0.2.1 (AnupamJain)
09:12:15 <beaky> let a => b = if a == True && b == False then False else True in let p = True in let q = False in p => q
09:12:20 <beaky> > let a => b = if a == True && b == False then False else True in let p = True in let q = False in p => q
09:12:22 <lambdabot>   <hint>:1:7: parse error on input `=>'
09:12:26 <beaky> :(
09:13:14 <quchen> > let a => b = a <= b in True => True
09:13:16 <lambdabot>   <hint>:1:7: parse error on input `=>'
09:13:25 <byorgey> => is already taken.
09:13:43 <quchen> => is not allowed.
09:14:00 <quchen> > let a `implies` b = a <= b in True `implies` True
09:14:02 <lambdabot>   True
09:14:15 <beaky> ah
09:14:17 <beaky> what does => do?
09:14:22 * beaky facepalm
09:14:31 <beaky> oh it's the typeclass thingy :D
09:14:33 <quchen> Start with a = and not be in a type signature ;-)
09:15:15 <quchen> > let a ==> b = a <= b in True ==> True   -- Slightly uglier.
09:15:18 <lambdabot>   True
09:15:29 <`ramses> anyone here has an opinion about Awodey's book on category theory? I'm thinking about buying it to get into the subject
09:16:36 <hiptobecubic> quchen, djinn still amazes me
09:16:36 <lambdabot> hiptobecubic: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:19:21 <hiptobecubic> Why is lambdabot telling me *today* about a message that was written over two months ago?
09:19:34 <hiptobecubic> It's not like I haven't been in here.
09:20:03 <elliott> quchen: that thread has some nice blasts from the past: "I just grabbed the darcs version and uploaded it to hackage, the Haskell Package Database (Beta): http://hackage.haskell.org/ModHackage/Hackage.hs?action=view"
09:20:12 <cariveri> how to call D2 <- f D1  from data D = D {.., f::D-> IO D,... } . ghci tells me it cant match "IO t0" with "D -> IO D"
09:20:51 <geekosaur> someone may have restarted it with fixed databases (which got hosed a week or so ago)
09:20:51 <quchen> elliott: I get a 404 when opening that :-(
09:21:16 <`ramses> cariveri: f becomes (D -> (D -> IO D)), doesn't it?
09:21:51 <`ramses> cariveri: as in "data T = { runT :: Int } where runT :: T -> Int
09:23:02 <cariveri> `ramses: yes it seems. So how do I call f ? ((f D1) D1) ?
09:23:15 <`ramses> cariveri: f D1 D2
09:24:30 <cariveri> `ramses: D2 being the result of f then ? thats what Im hoping to do. D2 is the result of f called on D1.
09:25:06 <geekosaur> cariveri, no. (f D1) is a function, which you are then calling with D2
09:25:10 <`ramses> cariveri: no, given a D, you can extract a function (D -> IO D), that's what your data definition says
09:25:14 <geekosaur> but you don;t need the parens
09:25:22 <geekosaur> so (f D1) D2 can be written f D1 D2
09:25:33 <cariveri> geekosaur: thats why I suggested D2 <- (f D1) D1
09:25:34 <`ramses> cariveri: so you specify first the D from which to extract the f, and then the D on which that f has to act
09:26:00 <HugoDaniel> hi
09:26:24 <`ramses> cariveri: you might actually want "data D = D { ..., f :: IO D, ... }"
09:26:36 <HugoDaniel> is there any recomended IDE for haskell ? or any tool that can automatically fill the import list of a module with the functions it uses ?
09:26:47 <`ramses> cariveri: then, f has type (D -> IO D) outside the data definition
09:27:16 <byorgey> HugoDaniel: there is ghc -ddump-minimal-imports
09:27:26 <byorgey> a bit low-level but it gives you the right info.
09:27:42 <byorgey> I don't know if any IDE can do this, EclipseFP might
09:28:07 <`ramses> HugoDaniel: there is Leksah, never used it though
09:28:40 <hiptobecubic> HugoDaniel, you have to be careful though, a lot of functions are present in more than one module.
09:29:12 <cariveri> `ramses: hmm. D2 <- f D1 would work then, but f needs to acces D1's other fields.
09:29:14 <hiptobecubic> HugoDaniel, unless you mean tighten your existing imports to specifically bring in only the functions you use
09:29:26 <hiptobecubic> HugoDaniel, there are at least two programs that attempt that
09:29:27 <`ramses> hiptobecubic: that's true for most languages, and many of them have IDEs for this feature. The type will probably fix which function to select
09:29:57 <cariveri> `ramses: Id thought of one self/this parameter, you know.
09:30:44 <`ramses> cariveri: are you sure this function belongs inside the data type, then? Sounds fishy
09:32:55 <cariveri> `ramses: the idea was to create an object = {fields + functions}. but it may be better to seperate them, as I have to creates outer functions as well to initialize the object functions. hmm.
09:33:08 <hiptobecubic> `ramses, can leksah do that?
09:33:38 <`ramses> hiptobecubic: not sure, never used it.. Seems like a feature I'd like to add if I'd write a haskell IDE :)
09:34:33 <hiptobecubic> `ramses, seems like a difficult problem really. You have a program that won't build because "fromList" isn't imported so now what? grep hackage and try them all until one works?
09:35:06 <`ramses> cariveri: ah, that'll be tricky without a self reference indeed. Maybe it could be done with some kind of wrapper outside the data type which passes in it's argument twice
09:35:27 <`ramses> hiptobecubic: oh, I wouldn't search hackage, only locally available modules
09:35:59 <`ramses> hiptobecubic: I'd scan for all modules available for import when the IDE is started
09:36:45 <hiptobecubic> `ramses, ok sure. but you're solving the wrong problem. How do know what type the 'hole' needs?
09:37:36 <`ramses> hiptobecubic: you don't if there is not enough static type info available, then you present the user with a list of possibilities. It's an IDE ;)
09:38:09 <hiptobecubic> `ramses, fair enough
09:38:27 <g3orge> hi I got this error when trying to install the hoohle tool: hoogle-4.2.16 depends on haskell-src-exts-1.13.5 which failed to install
09:38:47 <`ramses> hiptobecubic: I'm really thinking of the same functionality you get from most java etc. IDEs
09:42:18 <g3orge> *hoogle
09:52:40 <johnw> g3ogre: can you show us the haskell-src-exts build error?
09:57:10 <andyjgill> Does anyone know where I can propose a Google Summer of Code project for haskell.org? KU wants to mentor one.
09:58:08 <beaky> hello
09:58:12 <johnw> hi beaky!
09:58:23 <beaky> is there any downside to using parametric polymorphism?
09:58:40 <johnw> you wouldn't be able to use Haskell without it :)
09:58:45 <Hafydd> I can think of some downsides to not using parametric polymorphism.
09:58:53 <beaky> like having 'data a = Foo a | Bar a b'... or f :: a -> a -> a ?
09:58:54 <beaky> ah
09:59:22 <johnw> beaky: make your functions as generic as you can, I say
09:59:34 <johnw> it will not only aid in their reuse, but it helps clarify the actual problem they are solving
09:59:44 <c_wraith> What I like about parametric polymorphism is that it restricts what your functions can do. The more polymorphic you make it, the fewer possible implementations it can have.
09:59:48 <beaky> I read somewhere that the typesystem is very strong at proving correct generic functions
10:00:28 <johnw> yes, the type inference engine is excellent
10:00:39 <c_wraith> And fewer possible implementations means two good things. 1) Someone trying to figure out what it does has less work to do. 2) The type checker can catch more wrong implementations.
10:00:57 <johnw> yes, what c_wraith is saying expands on my point of being "clear about the problem you are solving"
10:01:20 <johnw> a function a -> a -> a can't know anything about it's argument, which means it can only pass them on to other polymorphic functions
10:01:27 <johnw> arguments*
10:01:51 <johnw> which, in the end, will have to be id, or a selection between the two
10:01:58 <edwardk> Has anyone here played with giraffe trees?
10:02:01 <elliott> (or seq :( )
10:02:05 <johnw> yeah, or seq
10:02:06 <c_wraith> edwardk: never even heard of them
10:02:12 <edwardk> =/
10:02:12 <johnw> edwardk: no, what are they?
10:02:25 <johnw> edwardk: how come [] isn't an instance of Additive?
10:02:29 <elliott> edwardk: i know what both giraffes and trees are. how can I help
10:02:36 <edwardk> http://www.cs.au.dk/~gerth/slides/bertinoro06.pdf
10:02:52 <edwardk> johnw: if it works, add it
10:03:21 <johnw> edwardk: i'm not sure if the theory is complete, I just expected [1,2,3] ^+^ [4,5,6] to have an unambiguous answer
10:03:55 <edwardk> johnw: it sounds sound.
10:04:00 <fizbin> @hoogle (^+^)
10:04:01 <lambdabot> No results found
10:04:02 <edwardk> since we don't use applicative any more
10:04:02 <johnw> ok, I'll add it
10:04:07 <edwardk> fizbin: in linear
10:04:09 <johnw> i'm pretty sure [] is already Indexable
10:04:09 <edwardk> @hackage linear
10:04:09 <lambdabot> http://hackage.haskell.org/package/linear
10:04:22 <Hafydd> I've got to use (^+^) as an emoticon some time.
10:05:23 <johnw> Hafydd: subtraction even has a lolcat: http://northierthanthou.files.wordpress.com/2012/09/happy_lolcat-s418x467-65924.jpg
10:05:37 <edwardk> anyways a giraffe tree is a way to store a cache oblivious search trie… which is basically the data structure i need for analytics
10:05:47 <fizbin> johnw: What would you make ^-^ on lists?
10:05:53 <Hafydd> Heheh.
10:06:10 <johnw> [4,5,6] ^-^ [1,2,3] => [3,3,3]
10:06:21 <johnw> mismatching positions are 0
10:06:41 * hackagebot recursion-schemes 3.0.0.2 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-3.0.0.2 (EdwardKmett)
10:06:43 <fizbin> johnw: Okay, that's the way you're going. So (zero :: [Integer]) is "repeat 0" ?
10:06:51 <johnw> yes
10:07:00 <johnw> that will be the behavior, at least
10:07:12 <johnw> perhaps not the actual representation of zero, which is more likely to be []
10:07:49 <c_wraith> repeat 0 is barely bigger in memory than []
10:07:50 <fizbin> johnw: Ok. It's a little bit odd that (x ^-^ x) will usually be something that isn't quite zero.
10:07:52 <edwardk> adding the []
10:08:04 <edwardk> fizbin: we already have this on other sparse reps
10:09:09 <yacks> @[4,5,6] ^-^ [1,2,3]
10:09:09 <lambdabot> Unknown command, try @list
10:09:16 <yacks> @list
10:09:16 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:10:11 <edwardk> this also indicates i should add instances for Vector ;)
10:10:25 <johnw> yes, and Array
10:10:32 <johnw> edwardk: I will add those two also
10:10:38 <fizbin> :t (+)
10:10:40 <lambdabot> Num a => a -> a -> a
10:10:41 <edwardk> array is harder because you need to widen the bounds to do it correctly
10:11:41 <johnw> ok, [] works
10:11:48 <johnw> https://gist.github.com/5154173
10:12:07 <edwardk> yeah its in the repo already. check #haskell-lens scrollback ;)
10:12:20 <johnw> dude, let me contribute something! haha
10:12:27 <johnw> i want to use my write bit
10:12:43 <johnw> are you doing Vector as we speak also?
10:12:46 <edwardk> =)
10:12:51 <edwardk> maybe ;)
10:12:52 <johnw> alright, back to work then
10:13:05 <edwardk> mostly because i wanted to make sure it was done the super-efficient way that vector allows
10:13:11 <johnw> the best I've done for linear so far is a branch that was deleted 5 minutes later :)
10:13:24 <edwardk> see you should have just done the [] thing ;)
10:13:36 <johnw> yeah, that does teach me
10:14:15 <johnw> tell edwardk thing via commits, not IRC
10:14:22 <edwardk> heh
10:14:31 <edwardk> not sure the right way to make the vector instance fast
10:15:25 <johnw> ok, on this one I want to ask to avoid going down a blind alley
10:15:36 <edwardk> sure
10:15:40 <johnw> it should be possible to make any representable functor over Nums an additive too, yes?
10:16:00 <edwardk> yes, but you can't do so generically =/
10:16:13 <johnw> it has to be specialized for the index type?
10:16:16 <edwardk> yeah
10:16:42 <johnw> what about any Indexable over Nums then?
10:16:56 <elliott> hm, doesn't the Additive instance for [] disagree with the Bind/Apply instance?
10:16:58 <elliott> and Bind is a superclass of Additive
10:17:23 <johnw> yes, Additive for [] is more akin to ZipList
10:17:34 <johnw> i noticed that too, when I first set liftU2 to liftA2
10:17:39 <edwardk> elliott: hrmm. the bind superclass may be eliminable
10:17:46 <mcstar> ski: holy christ, got it
10:18:05 <edwardk> index doesn't give you the ability to put the new stuff in, which you need for liftU2
10:18:06 <elliott> well, the ability to lift functions Apply-style over an additive thingy seems valuable
10:18:26 <edwardk> the Apply is liftU2
10:18:36 <edwardk> well, that works for the union-like stuff
10:19:10 <edwardk> liftU2 already disagrees with Apply, though because it unions rather than intersects
10:19:21 <edwardk> we use intersection for multiplication though
10:19:33 <edwardk> so i'm betting the [] instance breaks for matrices
10:19:51 <edwardk> ZipList works i guess
10:19:59 <johnw> that's acceptable
10:21:15 <edwardk> i could break it up a bit and remove the Apply superclass and switch to having a liftI2 as well as liftU2
10:22:29 <fizbin> edwardk: How would it break for matrices?
10:22:35 <hpaste> mcstar pasted “liftMN” at http://hpaste.org/83996
10:22:53 <mcstar> ski: this is it ^^
10:23:05 <mcstar> edwardk: you can take a look at it too ^^
10:23:06 <edwardk> matrices use the Apply instance during multiplication assuming that it means to intersect
10:25:33 <fizbin> Well, so here we get some extra 0 entries.
10:26:26 <fizbin> Or wait, where's the matrix code? What function are they using <.> on?
10:27:30 <johnw> monad-loops really has some handy functions in it
10:28:21 <hiptobecubic> forM is all you need :)
10:28:32 <mcstar> wrong, all you need is love
10:28:34 * hiptobecubic has no idea what's in monad-loops
10:28:37 <johnw> http://hackage.haskell.org/packages/archive/monad-loops/0.3.3.0/doc/html/Control-Monad-Loops.html
10:29:16 <mcstar> edwardk: do you think, there is a way, to write that thing with better type inference?
10:29:20 <mcstar> it is very fragile...
10:29:23 <johnw> I had a need today for: atomically $ untilM (readTChan chan) (emptyTChan chan), to empty out a channel if/when it has something in it
10:29:30 <edwardk> mcstar: bit distracted, sorry
10:29:36 <mcstar> np
10:30:08 <johnw> hiptobecubic: also, http://hackage.haskell.org/packages/archive/retry/0.1.0.1/doc/html/Control-Retry.html is my favorite package of the day :)
10:31:28 <hiptobecubic> johnw, was this a chan full of bools for some reason?
10:35:51 <mcstar> nice, with a tiny change, it can specialize the function's type
10:36:17 <mcstar> why is there such a difference between these two?
10:36:19 <mcstar> instance (a ~ a0, a ~ a1, m ~ m0, Monad m, NAry a0 m0 t1 t2, NAryM a0 m0 t1 t2) => NAry a0 m0 (a1 -> t1) (m a -> t2) where
10:36:21 <mcstar> and
10:36:40 <mcstar> instance (m ~ m0, Monad m, NAry a m0 t1 t2, NAryM a m0 t1 t2) => NAry a m0 (a -> t1) (m a -> t2) where
10:36:41 <skp> hi!
10:36:42 * hackagebot cipher-aes128 0.2.4 - AES128 using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.2.4 (ThomasDuBuisson)
10:37:03 <skp> is there a shortcut for the annoying following expression:
10:37:09 <fizbin> Is there a variant of Control.Monad.Loops.forkMapM that returns the computations in order of completion, so that you can then call filter and listToMaybe on the result list and get the first result (if any) that had no exception?
10:37:15 <skp> marshalFoo f = case f of …
10:37:19 <skp> some thing like
10:37:21 <elliott> skp: yes
10:37:23 <skp> marshalFoo = case of
10:37:26 <elliott> marshallFoo pattern1 = ...
10:37:29 <elliott> marhsalFoo pattern2 = ...
10:37:37 <skp> it’s boring as fuck too
10:37:54 <mcstar> yes, as you are
10:37:55 <johnw> fizbin: yes, it's called parallel-io
10:37:57 <elliott> you can also say marshalFoo = \case ... with LambdaCase and a very recent GHC, but that's pretty unidiomatic here. in general you should use multiple function clauses for this
10:38:01 <skp> mcstar: oh
10:38:07 <skp> you’re so mean
10:38:14 <johnw> fizbin: but I think it only works for IO
10:38:21 <elliott> mcstar: ?
10:38:28 <skp> I see elliott!
10:38:30 <skp> well
10:38:38 <johnw> oh, so does forkMapM, so there you are
10:38:38 <skp> it was just a simple question about case of
10:38:53 <elliott> yeah, "case of" section-type thing is what LambdaCase is for
10:38:53 <fizbin> skp: Or it's very likely that your function can already be written with some higher-order combinators, depending on the pattern.
10:38:57 <skp> the same way I asked a long time if {} could be a lambda
10:39:06 <elliott> but in general I'd only use it in an argument to a higher-order function, etc.
10:39:20 <elliott> if multiple function clauses are too noisy you can shorten your function name ;)
10:39:35 <skp> elliott: I’d rather like the case of syntax
10:39:45 <skp> but
10:39:50 <skp> foo x = case x of
10:39:50 <fizbin> skp: I've found @pl to be a useful way to get ideas about how something can be rewritten to use higher-order combinators.
10:39:52 <skp> foo = case of
10:40:02 <skp> wellI dunno
10:40:03 <elliott> well, "\case" is shorter :p it was bikeshedded extensively for a trillion years on the ghc trac, \case was eventually decided on in preference to case of and others
10:40:21 <elliott> I don't much like the \case syntax, but I don't really feel a need for the extension in the first place
10:40:33 <skp> yeah
10:40:34 <skp> I see
10:40:38 <johnw> is there a Functor type class which has a notion of an "empty" functor?
10:41:02 <skp> what would be an empty functor?
10:41:03 <elliott> empty howso?
10:41:09 <johnw> oh, n/m
10:41:11 <skp> :D
10:41:17 <fizbin> You mean something between Functor and Alternative?
10:41:30 <johnw> the way that MonadPlus has mzero for Monads
10:41:41 <elliott> Alternative is probably the closest standard thing
10:41:41 <shachaf> mzero is not "an empty monad".
10:41:57 <simpson> johnw: Like, bikeshedThisName :: Functor f => f () -- ??
10:42:13 <shachaf> It's not a monad at all. It's a value.
10:42:14 <johnw> shachaf is right
10:42:28 <johnw> what I want is not emptiness, but identity for a "plus" operation
10:42:52 <johnw> i want FunctorPlus ;)
10:43:00 <shachaf> Not FunctorZero?
10:43:09 <johnw> well, I also want to add
10:43:23 <johnw> but actually, I think this requires Applicative
10:43:28 <johnw> in order to add two such functor values
10:43:34 <fizbin> What other properties do you want? Something like: fmap _ johnwEmpty = johnwEmpty ?
10:43:52 <johnw> i have a feeling I'm pulling an XY...
10:44:14 <kqr1> so easy to do that with haskell
10:44:21 <kqr1> because there are tons of ways of accomplishing something
10:47:46 <skp> 18:43 < fizbin> What other properties do you want? Something like: fmap _ johnwEmpty = johnwEmpty ?
10:47:50 <skp> _ would be id here
10:49:16 <elliott> I don't think that's what fizbin meant
10:54:33 <fizbin> skp: What I meant is that johnwEmpty would be to fmap as 0 is to (*)
10:55:42 <fizbin> So for [], it's obvious that johnwEmpty is []. For Maybe, it's Nothing. For other Functors, not sure...
10:56:02 <shachaf> Does Alternative have laws?
10:56:19 <fizbin> Not that relate to fmap, I don't think.
10:56:22 <shachaf> What are they?
10:57:22 <Mortchek> I am guessing you already know it should be a monoid?
10:57:41 <fizbin> They basically just define "some" and "many".
10:57:58 <mm_freak_> shachaf: the haddocks require that (<|>) is associative
10:58:23 <mm_freak_> but a reasonable law would be:  x <|> empty = empty <|> x = x
10:59:04 <jbracker> empty <|> x = x is not true
10:59:05 <fizbin> mm_freak_: isn't that implied by saying that empty is "The identity of <|>" ?
10:59:16 <jbracker> think of parsers for example mm_freak_
10:59:48 <skp> yeah fizbin
10:59:49 <skp> got it
11:00:31 <Mortchek> jbracker, what's a counterexample to empty <|> x = x?
11:01:08 <Mortchek> If it's a monoid, that ought to be true.
11:01:40 <jbracker> I just thought of a parser and empty <|> x would except the empty string or that excepted by x, where x on its one does not necessarily accept the empty string Mortchek
11:02:17 <jbracker> even the order empty <|> x or x <|> empty can influence its behaviour
11:02:45 <fizbin> But those parsers don't use the Alternative class, do they?
11:03:17 <Mortchek> Parsec has its own (<|>) that isn't necessarily monoidal.
11:03:42 <Mortchek> @type (Text.Parsec.<|>)
11:03:44 <lambdabot> Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m a
11:04:06 <fizbin> @hoogle (<|>)
11:04:07 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
11:04:07 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
11:04:07 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
11:04:32 <fizbin> Right. We're talking about (Control.Applicative.<|>)
11:04:40 <jbracker> But ParsecT does implement Alternative and Attoparsec to also
11:05:00 <jbracker> they both implement Alternative
11:06:51 <fizbin> Yeah, but the definition for (Control.Applicative.<|>) for ParsecT is mplus on the wrapped monad, not (Text.Parsec.Prim.<|>)
11:07:25 <Philippa> ...huh
11:07:32 <Philippa> that does strike me as unhelpful, yeah
11:08:08 <fizbin> And "empty" in that instance is mempty on the wrapped monad, not a parser construct matching the empty string.
11:08:31 <Philippa> I'd expect it to be failure rather than empty string
11:08:35 <Philippa> empty *language*
11:08:50 <fizbin> Oh, wait.
11:09:13 <fizbin> So… Text.Parsec.Prim.<|> is also defined with mplus.
11:09:37 <Mortchek> On which monad?
11:09:42 <fizbin> Huh. So maybe the two <|> definitions are effectively identical, but what's being used for "empty" isn't.
11:09:57 <Mortchek> Oh, duh, never mind.
11:11:04 <fizbin> Ah, okay, so I have the solution to the objection jbacker brought up: indeed it is true that empty <|> x = x <|> empty = x, even in parsers.
11:11:16 <jbracker> yes right
11:11:27 <fizbin> It's just that for "empty" you have to use "the language that matches nothing, ever".
11:11:32 <Philippa> you'd bloody hope so, they're one of the canonical examples for it
11:11:41 <fizbin> Rather than "The language that matches the empty string"
11:11:46 <Philippa> (see "Kleene algebra")
11:11:49 <Philippa> (also, regular expressions)
11:11:55 <jbracker> yes my misconception
11:12:08 <Mortchek> So it does look like failure is the identity on ParsecT.
11:12:29 <jbracker> i looked in attoparsec there fail is empty
11:12:40 <jbracker> and therefore the identity of <|>
11:15:26 <hpaste> fizbin pasted “Snippet from http://hackage.haskell.org/packages/archive/parsec/3.0.1/doc/html/src/Text-Parsec-Prim.html” at http://hpaste.org/83998
11:16:01 <fizbin> How does that snippet of parsec compile?
11:16:49 <fizbin> Ah, nevermind. Got it.
11:17:32 <mm_freak_> jbracker: empty is the parser that always fails and never consumes
11:17:39 <mm_freak_> so empty <|> x = x
11:17:58 <mm_freak_> would be quite weird if a parser type would violate that
11:18:34 <jbracker> mm_freak_: Just what I said above. It was my misconception of empty being the always successful parser, which is not true.
11:18:54 <mm_freak_> jbracker: yeah, quite the opposite =)
11:19:00 <mm_freak_> it's a common pattern
11:19:21 <fizbin> So, back to finding that type class that requires Functor and has a terminal element for fmap...
11:20:00 <mm_freak_> empty is the web-server that always rejects, the optional value that is never there, the parser that always fails, the wire that always inhibits…
11:20:54 <elliott> jbracker: always successful parser is pure ()
11:20:57 <elliott> which is the opposite of empty
11:21:31 <jbracker> elliott: I noticed, my bad. My brain just connected empty with "" and went on.
11:21:44 <mm_freak_> that would be mempty =)
11:21:48 <mm_freak_> > mempty :: String
11:21:50 <lambdabot>   ""
11:21:50 <jbracker> yep
11:22:22 <fizbin> Anyone familiar enough with parsec to tell me what this would be: parsecMap (const 5) parserZero
11:22:40 <fizbin> :t parsecMap (const 5) parserZero
11:22:42 <lambdabot> Not in scope: `parsecMap'
11:22:42 <lambdabot> Not in scope: `parserZero'
11:23:13 <pmk> greetings
11:23:24 <mcstar> amusing: http://i.imgur.com/UQMnWXF.png
11:23:45 <mm_freak_> fizbin: parsecMap = fmap
11:23:53 <mm_freak_> parserZero is empty, i think
11:24:30 <mm_freak_> so parsecMap f parserZero really just casts parserZero's type
11:24:49 <mm_freak_> on the value level:  parsecMap f parserZero = parserZero
11:24:58 <mm_freak_> forall f.
11:25:07 <pmk> i have a terminological question, if anybody's interested
11:25:19 <mm_freak_> pmk: sure, just ask
11:26:00 <pmk> are "strictly typed" and "strongly typed" synonyms, or do they mean something distinct to you?
11:26:17 <Philippa> Haven't heard the former as a technical term
11:26:23 <mm_freak_> pmk: i'm not familiar with "strictly typed"
11:26:29 <c_wraith> And no one can agree on the meaning of "strongly typed" anyway
11:26:30 <srhb> I've never heard that either.
11:26:45 <Philippa> c_wraith: While true, I think Pierce's definition is pretty reasonable
11:26:50 <mm_freak_> pmk: perhaps you're confusing this with "strict"?
11:26:50 * elliott wonders what lazy typing would be...
11:26:59 <pmk> i've encountered "strict" in the context of "you can't reinterpret raw bits"
11:27:06 <mm_freak_> elliott: you can have strict/non-strict semantics on the type level
11:27:17 <Philippa> pmk: that's an informal use
11:27:21 <pmk> sure
11:27:30 <pmk> thanks
11:27:31 <fizbin> mm_freak_: Okay, if the value's the same then I think that parsec's parserZero is another example of this "terminal object for fmap" thing.
11:27:31 <pmk> ok
11:27:45 <elliott> mm_freak_: sure, but that's boring. :p
11:27:55 <elliott> especially since you want your type-level stuff to be total in which case it makes no difference.
11:28:22 <mm_freak_> elliott: not in a dependently typed language…  the semantics on the type level declare the termination characteristics of the type checker
11:29:03 <mm_freak_> elliott: even in a total language you can have infinite corecursion, also on the type level
11:29:23 <elliott> sure.
11:29:42 <Kazimuth> arrows are hard
11:30:03 <mm_freak_> Kazimuth: http://ertes.de/new/tutorials/arrows.html
11:30:31 <Kazimuth> mm_freak_: yeah, I've been using that, just a bit hard to grok :)
11:30:51 <mm_freak_> Kazimuth: oh, what part do you have difficulty with?
11:31:16 * fizbin only uses Control.Arrow for useful combinators with the (->) Arrow instance.
11:31:41 <Kazimuth> agh, wait, bbl
11:31:49 <mm_freak_> fizbin: i often prefer the reader monad for that case
11:31:49 <Philippa> Do we have Control.Arrow.JustForFunctions?
11:31:49 <Philippa> (specialised types for the same combinators)
11:31:55 <mm_freak_> > liftA2 (+) sin cos 15
11:31:56 <lambdabot>   -0.10940007270170449
11:32:25 <fizbin> mm_freak_: Yeah, but sometimes stuff like &&& or ||| is useful.
11:32:46 <mm_freak_> > map (id &&& length) ["this", "is", "a", "test"]
11:32:48 <lambdabot>   [("this",4),("is",2),("a",1),("test",4)]
11:32:54 <mm_freak_> i agree
11:32:58 <mm_freak_> sometimes =)
11:33:05 <fizbin> Even just with functions. Other arrow instances I stay away from, because they just seem annoying.
11:33:52 <mm_freak_> well, i use some non-monadic arrows
11:33:54 <mm_freak_> most notably Wire
11:34:17 <fizbin> > (*5) ||| (^2) $ [Right 1,Left 2,Right 3,Left 4]
11:34:18 <lambdabot>   Couldn't match expected type `Data.Either.Either d0 d0'
11:34:18 <lambdabot>              with a...
11:34:55 <mm_freak_> (strictly speaking Wire is a family of monads, but the Monad instance can be anything from useless to dangerous, so i don't write it)
11:35:06 <fizbin> > map ((*5) ||| (^2)) [Right 1,Left 2,Right 3,Left 4]
11:35:07 <lambdabot>   [1,10,9,20]
11:35:19 <ClojureIsBetter> hello
11:35:45 <fizbin> Um… are you sure you meant to come here wearing that nick?
11:35:54 <elliott> ClojureIsBetter: your nick doesn't bode well for the productivity of your time in this channel.
11:35:55 <mm_freak_> fizbin: don't feed the troll
11:36:00 <mm_freak_> elliott: don't feed the troll
11:36:14 <johnw> must.. resist...
11:36:47 <mm_freak_> after all we had people named "hitler" in here who actually had meaningful things to say and ask =)
11:37:01 <elliott> Philippa: the useful Arrow combinators for (->) are available spread out over edwardk packages :P
11:37:07 <elliott> bifunctors has some of them, e.g.
11:37:14 <Philippa> elliott: doesn't count :p
11:37:42 <mm_freak_> elliott: bifunctors is a generalization, too, just a different one
11:37:53 <elliott> a better one :P
11:38:00 <ClojureIsBetter> elliott: I am much more productive in Clojure ;)
11:38:00 <mm_freak_> no, a different one
11:38:15 <edwardk> well, for (->) profunctors are the closer analogue
11:38:16 * Philippa figures Clojure is better than, say, a rusty fork in the eye
11:38:16 <elliott> ClojureIsBetter: do you have a Haskell question?
11:38:25 <thoughtpolice> TIL about NoTraditionalRecordSyntax
11:38:28 <johnw> hey, don't know the value of a rusty fork in the eye
11:38:29 <Philippa> lurking's allowed, folks!
11:38:31 <johnw> s/know/knock
11:38:41 <johnw> it teaches you to cherish your other, remaining eye
11:38:41 <edwardk> i'd rather not know ;)
11:38:45 <Philippa> thoughtpolice: it's something that should've happened much sooner, no?
11:38:46 <mm_freak_> ClojureIsBetter: i'd be more productive with clojure, too, if my other option would be PHP =)
11:38:47 <elliott> (honest question, not an accusation)
11:39:05 <elliott> mm_freak_: well, a bifunctor at least means something, whereas arrows are a bit of a hodge-podge
11:39:15 <thoughtpolice> Philippa: i suppose! the ticket requesting it said the idea is to demote records to an extension so the syntax can be stolen for something else
11:39:16 <ClojureIsBetter> no
11:39:30 <ClojureIsBetter> comparing Clojure to PHP is too far
11:39:34 <mm_freak_> elliott: arrows solved a specific problem when they were invented and no more sensible abstraction was known
11:39:41 <elliott> sure.
11:39:42 <thoughtpolice> which is fairly reasonable. we're already pretty syntax heavy in terms of symbols-used
11:39:47 <mm_freak_> elliott: remember that when arrows first came to, we didn't even have Control.Category =)
11:39:50 <elliott> it's 2013 now though :)
11:39:53 <Philippa> thoughtpolice: or the wider syntactic space, yeah. Proper row type support for more-general row types would be awesome
11:39:56 <johnw> arrows still do one thing very well
11:40:02 <ClojureIsBetter> You can insult my mother, and beat up my dog, but don't compare a programming language to PHP
11:40:06 <mm_freak_> johnw: confuse people?
11:40:13 <pmk> just imagine how productive clojure would be with tail call elimination.  it could approach scheme circa 1980 or so. :-)
11:40:18 <shachaf> I think this discussion is getting way off-topic.
11:40:24 <johnw> they let you process meta-state when the arrow is built
11:40:33 <johnw> something that otherwise needs a Free Monad or somesuch
11:40:44 <mm_freak_> johnw: that's actually the job of Category and/or Applicative
11:40:48 <shachaf> Insulting programming languages, or even saying that some are better than others, is mostly off-topic in here.
11:41:02 <mm_freak_> johnw: a free monad can't process meta-state, if i have the same definition of that
11:41:08 <mm_freak_> a free monad is still a monad
11:41:11 <ClojureIsBetter> what's the other chanell for doing that?
11:41:17 <thoughtpolice> Philippa: I believe once I sat down and tried to think of all the symbols available on my keyboard that weren't obviously taken by the syntax already. it was pretty damn difficult
11:41:20 <ClojureIsBetter> haskellbla ?
11:41:22 <Philippa> ClojureIsBetter: #pissingcontest?
11:41:29 <monochrom> ##math
11:41:32 <mm_freak_> lol
11:41:44 <thoughtpolice> Philippa: i'm still not sure records will ever be fixed though. the design space is so huge, all discussions go nowhere because people endlessly bikeshed over what they want records to be
11:41:44 <applicative> Did people really compare clojure to php.  This is indeed obnoxious.
11:41:47 <johnw> yes, I suppose you could do that with Category.  But isn't that really the core of Arrow anyway?  Isn't the rest just plumbing to support arrow syntax?
11:41:48 * hackagebot hyphenation 0.2.1.8 - Configurable Knuth-Liang hyphenation  http://hackage.haskell.org/package/hyphenation-0.2.1.8 (EdwardKmett)
11:41:59 <thoughtpolice> i just started deleting those conversations out of my inbox, after edwardk said that's what he did I think
11:42:01 <pmk> Unicode is full of even more exciting symbols, many of which would be fun to use in Haskell.
11:42:02 <thoughtpolice> :P
11:42:14 <mm_freak_> applicative: i did…  i said, i'd be more productive with clojure than with PHP, and i'm quite serious about that =)
11:42:17 <johnw> mm_freak_: what I meant by free monad is that you can separate evaluation out and do a pre-pass to determine the meta state
11:42:21 <Philippa> thoughtpolice: yep, BTDT. It's hard enough to pick a general enough syntax to let people pick their own semantics
11:42:24 <edwardk> heh
11:42:32 <applicative> pmk pages full of unicode are somehow a strain on the human brain
11:42:46 <mm_freak_> johnw: even with Free you can't make a state monad that knows before evaluation whether 'put' is used somewhere
11:42:55 <Hafydd> Unless you happen to speak a language that is not US English.
11:43:08 <applicative> mm_freak_: ah well okay then.
11:43:26 <johnw> mm_freak_: I can make a meta-evaluator that accumulates knowledge about significant operations.  But I think Arrow's way of doing that is simpler
11:43:34 <monochrom> perhaps that's why COBOL was invented
11:43:38 <Philippa> Hafydd: agreed. Unicode's great for things like that, we're not ready to use it as a source of mathematical symbols for code yet though
11:43:51 <Rembane> APL!!!
11:44:05 <pmk> (sigh) i loved APL back in the day.
11:44:10 <elliott> the Unicode-as-typesetting thing is a bit misguided I think, since it's explicitly not intended for that sort of stuff
11:44:10 <Philippa> johnw: join makes your life fun there. >>= everywhere putting join everywhere even more so
11:44:11 <mm_freak_> johnw: not really…  it's basically the same thing (let's ignore extra laws for now)
11:44:25 * applicative has now forgotten the questions he was going to put to edwardk about what constructions would make a functor or monad from something gadtlike as a base
11:44:29 <elliott> Agda seems to really want to be using LaTeX syntax to me
11:44:29 <pmk> programming in Haskell is the only language that approaches the *fun* of APL
11:44:36 <Philippa> elliott: so there's an awkward difference between typesetting and naming? But yes
11:44:50 <mm_freak_> johnw: Applicative is exactly the design pattern for dynamic computations with a static structure
11:44:59 <mcstar> i spent a whole day writing 12 lines of haskell
11:45:03 <ClojureIsBetter> is there a modern APL compiler?
11:45:08 <mcstar> that does not happen with other languages
11:45:10 <johnw> mm_freak_: ok
11:45:17 <mm_freak_> johnw: Category adds the ability for subcomputations to communicate with each other
11:45:18 <shergill> mcstar: heh
11:45:24 <mm_freak_> johnw: and that's basically Arrow
11:45:26 * applicative sticks with mcbride's retro ascii-ism in agda
11:45:28 <fizbin> ClojureIsBetter: Some people consider K and J the rightful heirs to APL.
11:45:36 <ClojureIsBetter> with an easy way to enter stuff?
11:45:46 <johnw> mm_freak_: so Arrow is just repackaging Category+Applicative, you're saying?
11:45:58 <fizbin> ClojureIsBetter: http://www.jsoftware.com/
11:45:58 <elliott> + some laws
11:46:01 <mm_freak_> johnw: that's not the full story
11:46:03 <Philippa> johnw: not quite for historical reasons, but close enough
11:46:12 <applicative> there's an easy to use j implementation.  It's kind of cool in my limited experience
11:46:15 <mcstar> J is great, because it has built in boxes, the > operator if i am right
11:46:27 <johnw> then what's the real problem with it?
11:46:27 <ClojureIsBetter> ok, I will check it out
11:46:30 <Philippa> hmm. Somewhere we really need a "history of common Haskell generalisations"
11:46:40 <applicative> wow my first patch to a compiler has been applied
11:46:41 <Philippa> (that keeps track of all of these historical accidents, for example)
11:46:43 <elliott> johnw: it's a lot more awkward to use than Applicative :p
11:46:47 * applicative beams groundlessly
11:46:48 * hackagebot weighted-search 0.1.0.1 - A weighted nondeterministic search monad  http://hackage.haskell.org/package/weighted-search-0.1.0.1 (LukePalmer)
11:47:03 <Philippa> johnw: it forces you to carry an explicit environment about. Talk about PITA!
11:47:08 <mm_freak_> johnw: you can write total haskell functions that convert any Applicative+Category to an Arrow and vice versa, so technically they are equivalent, but then there is the story of laws
11:47:17 <Philippa> (and it doesn't even leave you room to do interesting things with it, IIRC :p)
11:47:28 <mm_freak_> applicative: congratulations…  GHC i'm hoping =)
11:47:47 <applicative> mm_freak_: no, idris; i'm warming up :)
11:47:56 <johnw> mm_freak_: ok, thanks for that clarification!
11:48:02 <elliott> johnw: witness how complex arrow "proc" notation is
11:48:02 <mm_freak_> applicative: i've just watched the video two hours ago =)
11:48:09 <johnw> yeah, proc notation is just painful
11:48:11 <elliott> spending all its time reducing everything to tuples and Either
11:48:15 <mm_freak_> applicative: and it's right on time, because i'm looking for a programming language for kernel development
11:48:17 <applicative> ah, have you tried it, mm_freak_ ?
11:48:24 <Philippa> sometimes something is just plain syntactically neater
11:48:27 <mm_freak_> applicative: long ago, but i'm still watching its progress
11:48:32 <johnw> i'm surprised that extension exists, when even applicative brackets didn't make it in
11:48:37 <Philippa> elliott: right. You only want to do that for stuff you give a shit about :p
11:48:58 <Philippa> johnw: historical reasons. Arrows looked like they'd be bigger than monads at the time
11:48:59 <mm_freak_> applicative: not quite because of its dependent types, but more because you can actually use it for kernels
11:49:05 <elliott> johnw: well, I'm pretty sure the arrow notation implementation is much older than applicatives
11:49:13 <Philippa> that too
11:49:14 <applicative> yeah I tried it way, but then again lately; its much more interesting. Still a bit of a mess I guess. Someone proved false yesterday, then edwin b. got rid of it....
11:49:24 <mm_freak_> johnw: proc notation could be less noisy, but otherwise it's the best you can get
11:49:26 <elliott> I get the impression arrows were regarded as a bit of a panacea early on
11:49:41 <Philippa> they forced a lot of people to do a lot of deep thinking, yeah
11:49:50 <mm_freak_> johnw: also proc notation has some very nice features to make your life easier…  those are often underappreciated
11:49:56 <Philippa> it's been weird seeing which conclusions were and weren't right
11:49:58 <johnw> mm_freak_: like?
11:49:59 <mm_freak_> johnw: for example banana brackets and case/if
11:50:08 <Philippa> (we still don't metaprogram as heavily as I was hoping back then!)
11:50:25 <mm_freak_> johnw: for the latter you need ArrowChoice
11:50:28 <applicative> mm_freak_: yeah, the simple dependent types are nice, but there are other things to admire. I don't know how well it's implemented but the data/codata distinction with termination/productivity checking is more interesting to me in a way
11:50:30 <elliott> Philippa: you never metaprogram you didn't like?
11:50:37 <johnw> lol
11:50:45 <tieTYT> if I google for an http client, this is the first result: http://hackage.haskell.org/package/http-wget  But I can't figure out what I'm supposed to type to get cabal install to install that
11:50:47 <Philippa> elliott: I'm definitely in the "many layered languages" crowd
11:50:58 <mm_freak_> applicative: of course…  i'm happy about any improvement over C =)
11:50:59 <elliott> never metalanguage you didn't like, then!
11:51:08 <tieTYT> i've been told I'm supposed to install modules, not packages, but I don't know how to find the module
11:51:09 <mm_freak_> applicative: even just the better syntax =)
11:51:11 <Philippa> mere effect typing is... good to have, but less than I was hoping we'd have as a regular tool by now
11:51:24 <elliott> tieTYT: that's backwards; you install packages, not modules
11:51:27 <elliott> try "cabal install http-wget"
11:51:27 <tieTYT> cabal install Network.HTTP.Wget gave me an error
11:51:35 <Philippa> edwardk: this is where you get to tell me off for not being pragmatic enough again :-)
11:51:40 <edwardk> tieTYT: thats because you can't do that
11:52:00 <Cale> tieTYT: If you really just want an HTTP client, the HTTP package is probably your best bet.
11:52:04 <tieTYT> elliott: ok that's as straightforward as I thought it should do
11:52:04 * geekosaur wonders if that was supposed to mean cabal-install vs. vendor packages
11:52:07 <Philippa> (also, this is where I give you a nod for doing a lot more of the shit I was hoping would happen than most people)
11:52:09 <Cale> http://hackage.haskell.org/package/HTTP-4000.2.8
11:52:10 <edwardk> Philippa: i thought i wasn't supposed to try to get you to change, just rib you about it occasionally ;)
11:52:16 <tieTYT> it should be
11:52:18 <applicative> mm_freak_: but you might start using it, in case you get some wild but potential fruitful idea that should be implemented sooner rather than later...
11:53:12 <mm_freak_> applicative: i have to check how easy it is to do standalone compilation with idris…  in particular if the RTS depends too much on libraries then i'm screwed
11:53:14 <elliott> edwardk: you can't change Philippa, but you can make a copied version that's more pragmatic and still reference the old one
11:53:30 <elliott> they'll even share in memory!
11:53:31 <applicative> tieTYT what was wrong with cabal install http-wget ?
11:53:33 <edwardk> ghuioihah
11:53:38 <edwardk> wow
11:53:46 <elliott> ghuioihah indeed.
11:53:47 <applicative> mm_freak_: yeah I don't know anything about that.
11:53:48 <edwardk> that came out more like a snort-chuckle than expected.
11:53:50 <Philippa> edwardk: I'm wondering if it isn't time for a "so you want to build a DSL..." article that's related to the typeclassopedia but covers a wider range of developments
11:54:03 <Philippa> I'm also wondering if that's the kind of thing I might actually get done :p
11:54:03 <tieTYT> applicative: actually I tried cabal install curl or something like that
11:54:21 <tieTYT> and it said there was a missing dependency and someoen told me that's because I need to install the module not the package
11:54:23 <mm_freak_> applicative: i really need to get a better language for kernel dev
11:54:32 <mm_freak_> even if that entails writing my own
11:54:54 <Philippa> mm_freak_: heh, yes. This is the sort of concern I was hoping would get much easier by now!
11:55:28 <shergill> mm_freak_: so for the most part you want Category+Applicative instead of Arrows?
11:55:33 <applicative> idris also has a little proof machinery annexed to it, which would be likely to be of use in that; but I don't know how robust it is yet.  I've just done simple things
11:55:47 <mm_freak_> shergill: for the most part i /use/ Category+Applicative rather than Arrow =)
11:56:17 <tieTYT> Cale: that looks pretty easy.  How would I have discovered this on my own?
11:56:29 * shergill makes a mental note to go over the Arrow papers with this new perspective
11:56:32 <applicative> tieTYT: hm, it seems likely that compilation failed because it couldn't find libcurl
11:56:39 <elliott> tieTYT: most likely you already have HTTP installed
11:56:47 <elliott> since cabal-install depends on it and it comes with the Haskell Platform
11:56:48 * hackagebot nbt 0.4 - A parser/serializer for Minecraft's Named Binary Tag (NBT)  data format.  http://hackage.haskell.org/package/nbt-0.4 (AdamFoltzer)
11:56:51 <tieTYT> applicative: yeah, isn't the whole point of cabal that it should have included that as a dependency?
11:57:02 <elliott> libcurl is a C library; cabal only handles Haskell libraries
11:57:02 <applicative> HTTP is in the haskell platform if you have that tieTYT
11:57:10 <elliott> you have to install native dependencies yourself
11:57:21 <mm_freak_> shergill: the arrow i use most frequently is Wire, which provides both interfaces…  mostly i use arrow style in the outermost wire that connects all the various subsystems and i write the subsystems in applicative style
11:57:26 <tieTYT> oh
11:57:33 <mm_freak_> the most common reason i use arrow style is ArrowLoop
11:57:41 <applicative> tieTYT: with C libs not much can be done, if you were using a proper package manager to install the haskell curl bindings, it would have grabbed curl too.
11:57:45 <tieTYT> so the curl thing was just an api to use the real command?
11:58:03 <applicative> what os are you using tieTYT ?
11:58:07 <tieTYT> windows
11:58:10 <tieTYT> 7
11:58:11 <Philippa> mm_freak_: makes sense
11:58:21 <geekosaur> tieTYT, the curl command line program is a wrapper for the curl library aka libcurl
11:58:28 <applicative> ah, do you have some simple way of installing c libraries like curl?
11:58:33 <Philippa> (though for some reason I'm reminded of... was it relative monads?)
11:58:35 <geekosaur> programs usually use libcurl rather than running the command
11:59:17 <mm_freak_> Philippa: relative monads?
11:59:34 <tieTYT> anyway it looks like I should just use this: http://hackage.haskell.org/package/HTTP-4000.2.8
12:00:02 <applicative> tieTYT: what were you going to use libcurl or wget for?  If it is limited you might be able to get a pure haskell version of what you need
12:00:09 <edwardk> @remember shachaf Did someone give edwardk a committee bit?
12:00:09 <lambdabot> It is forever etched in my memory.
12:00:17 <applicative> tieTYT: you already have it, though.
12:00:31 <applicative> tieTYT: what do you want to do exactly?
12:00:44 <tieTYT> just download the html to a url i pass in
12:00:45 <Philippa> mm_freak_: http://cs.ioc.ee/~james/papers/Relative_Monads.pdf
12:00:57 <Philippa> amongst other things, they let you have single-let for more types :-)
12:01:38 <monochrom> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#arrows-and-idioms is a very nice perspective on applicative, arrow, monad. (idiom = applicative)
12:02:31 <applicative> tieTYT: yeah, then simpleHTTP from the HTTP package will do.
12:02:32 <tieTYT> applicative: yeah I was going to do it through a lib
12:02:42 <tieTYT> but I guess this is straightforward enough
12:03:46 <hpaste> applicative pasted “getURL” at http://hpaste.org/83999
12:03:59 <applicative> there are nice variants in http-conduit and http-streams that also do https things, tieTYT .  Here's a simple use of just http ^^^
12:04:33 <amyers> tieTYT:  Saw this the other day http://blogs.operationaldynamics.com/andrew/software/haskell/http-streams-introduction
12:04:36 <amyers> Might be useful
12:04:47 <fizbin> Any category theory types on right now?
12:04:49 <applicative> tieTYT: the marlow code I pasted there uses bytestring, but you can convert it to other stringy things easily enough
12:04:52 <mm_freak_> Philippa: i see, didn't know about them before
12:04:55 <mm_freak_> interesting
12:05:06 <applicative> fizbin: all our types are in a category
12:05:07 <Vinz_> hi
12:05:14 <mm_freak_> so, well, Wire is a family relative monads =)
12:05:25 <applicative> Vinz hi!
12:06:00 <applicative> tieTYT: yeah the page amyers linked is nice and has a super simple http get thing at the end
12:06:13 <fizbin> So, I've worked out that the Functor typeclass does in fact mirror some of the endofunctors on Hask, the category of Haskell types when we pretend bottom doesn't exist.
12:06:29 <ski> mcstar : what happens if you remove the `a0' arguments and the `a ~ a0' constraints ?
12:06:42 <Vinz_> I don’t personnaly develop in haskell, I was just wondering if someone has a prebuilt binary of exmude :D
12:06:50 <mcstar> ski: type inference get worse
12:06:52 <amyers> IIRC it also supports https just as simply
12:06:56 <amyers> if that matters
12:07:08 <mcstar> ski: with a new type variable and a new ~ relation, i dont have to 'type' the function(the 1st parameter(
12:07:11 <fizbin> That is, every Functor is a Hask endofunctor, and the Functor laws are only what's needed to make the Functor an endofunctor.
12:07:22 <mcstar> ski: only the return type is needed
12:07:23 <applicative> exmude?
12:07:34 <fizbin> But what's the connection between Monad and the CT definition of "monad"?
12:07:45 <mcstar> ski: try this http://hpaste.org/83996
12:07:45 <Vinz_> http://freecode.com/projects/exmude this thing
12:07:49 <tieTYT> i just want the html you'd see if you view a webpage
12:07:58 <elliott> fizbin: our Monads are monads in Hask.
12:08:01 <elliott> well... plus fail.
12:08:04 <elliott> but we don't talk about fail.
12:08:07 <shachaf> A whole lot of fail.
12:08:14 <shachaf> "as they say on the internet"
12:08:14 <c_wraith> aptly named!
12:08:20 <elliott> all CT monads are endofunctors anyway, so the fact that we can only express endofunctors with Functor etc. isn't relevant
12:08:21 <Philippa> fizbin: much the same. Polymorphic functions on functors happen to correspond to natural transformations
12:08:38 <elliott> right, parametricity makes return/join work as natural transformations
12:08:41 <tac> fizbin: A Haskell monad is when one functor is Id : Hask -> Hask and the other functor is also Hask -> Hask (we call this an Endofunctor on Hask)
12:09:00 <elliott> there must be some deep meaning behind the connection between parametricity and naturality. probably it has been written up somewhere and I just don't know about it
12:09:08 <elliott> (well, I guess free theorems basically cover it)
12:09:24 <applicative> Vinz_: oh interesting its a really old haskell project.  Does it do anything interesting?
12:09:46 <fizbin> I see… so is there a type class that corresponds to monads on Hask where neither functor is necessarily Id ?
12:09:55 <Vinz_> well I don’t really know, I wanted to test it
12:10:01 <elliott> fizbin: that's not a monad :P
12:10:14 <Vinz_> But as I am unable to install wxHaskell here, I’m not able to
12:10:23 <Vinz_> +test it
12:10:26 <shachaf> "neither functor"?
12:10:41 <elliott> fizbin: if you look at http://en.wikipedia.org/wiki/Monad_(category_theory)#Introduction, "I" is Identity
12:10:55 <Vinz_> Basically, it outputs a sound based on mouse position
12:10:56 <applicative> oh it uses wxhaskell. what os are you using
12:11:03 <elliott> oh, "Formal definition" even says so
12:11:06 <fizbin> elliott: duh. Right. Okay.
12:11:11 <ski> tac : are you talking about an adjoint situation ?
12:11:12 <Vinz_> Manjaro (ArhcLinux derivative)
12:11:28 <elliott> oh, tac said that
12:11:50 <ski> hm, or perhaps `eta'
12:11:53 <elliott> tac: are you saying all haskell monads arise from an adjunction between 1 : Hask -> Hask and another endofunctor on Hask or something?
12:15:02 <tac_> elliott: I got disconnected and missed your question >_>
12:15:43 <elliott> <ski> tac : are you talking about an adjoint situation ?  <elliott> tac: are you saying all haskell monads arise from an adjunction between 1 : Hask -> Hask and another endofunctor on Hask or something?
12:16:28 <lazy_parenthesis> what is happening...?
12:16:41 <elliott> good question.
12:16:49 <applicative> Vinz it looks like it should build I cabalized it but dont have all of wx installed
12:17:16 <Vinz_> Oh
12:17:22 <Vinz_> Do you want the source package ?
12:17:27 <tac_> elliott: ah. I don't know much about adjunctions quite yet
12:17:31 <tac_> so I'm not saying anything like that
12:17:50 <Vinz_> (as the « official » link is not working)
12:17:57 <ski> elliott : perhaps tac_ was talking about `eta_A : I A >---> T A'
12:18:01 <applicative> Vinz_: i found the source somewhere
12:18:06 <Vinz_> Ok :)
12:18:25 <elliott> ski: well, that's not much of a monad :)
12:18:35 <elliott> tac_: I'm a bit confused as to what you are saying
12:19:09 <applicative> Vinz your packcage manager can install wx I take it? or youre trying to avoid that
12:19:35 <Vinz_> It is supposed to be able to, but it cannot
12:19:54 <Vinz_> It always fails due to other dependencies that are not found
12:20:23 <srhb> Vinz_: What package manager is that?
12:20:30 <Vinz_> yaourt
12:20:59 <mcstar> yo!
12:21:13 <mcstar> alias yo=yaourt i mean
12:22:13 <dmwit> heh: "milestone changed from 7.0.1 to 7.0.2. milestone changed from 7.0.2 to 7.2.1. milestone changed from 7.2.1 to 7.4.1. milestone changed from 7.4.1 to 7.6.1. priority changed from high to low. milestone changed from 7.6.1 to 7.6.2."
12:22:26 * dmwit decides not to hold his breath
12:22:41 <mcstar> dmwit: adding dependent types?
12:22:57 <dmwit> ha
12:24:59 <mcstar> mauke: lol@ undefinedResult = "the return value is a lie"
12:26:01 <amyers> tieTYT: Looks like that library is pretty finiky with urls.  It failed to parse the url without a trailing / when I tried it
12:26:11 <amyers> but it's really simply to just grab a page
12:30:31 <applicative> Vinz_: it also needs the alsa library, it seems.
12:30:48 <Vinz_> Yup
12:30:57 <Vinz_> Hm
12:31:25 <Vinz_> Well, your GNU/Linux distro needs ALSA to run it
12:31:39 <Vinz_> I don’t know if it’s also required for compiling it
12:35:28 <thelarry> Hi! Does haskell has it's own scheduler so that it can start many 'processes' to work concurrently without starting a new thread per request (thinking about a client/server architecture)? I mean some kind of scheduler like erlang uses...
12:36:06 <thelarry> or does it use threads or a threadpool or something like this?
12:36:28 <johnw> thelarry: it has its own notion of threads, which are mapped to OS threads as needed
12:36:37 <elliott> GHC has lightweight threads (but it also can use multiple OS threads to run them on, so it can do multi-core stuff)
12:36:56 <elliott> also, it has its own IO manager, so you can write blocking-style threaded programs that use efficient non-blocking IO underneath the hood.
12:38:00 <thelarry> ok thx!
12:40:45 <mcstar> time to switch from perl to haskell, eh larry?
12:41:04 <srhb> Not sure thelarry is ThatLarry.
12:41:25 <shachaf> mcstar: That seems pointlessly inflammatory.
12:41:42 <fizbin> So, sorry to jump people back to CT stuff, but: I'm having trouble figuring out what >>= corresponds to in the CT monad definition.
12:41:44 <mcstar> shachaf: im glad you found it funny too
12:42:07 <fizbin> There's a bit in the CT definition that looks like return, and another bit that I think might be join.
12:42:20 <fizbin> :t join
12:42:22 <lambdabot> Monad m => m (m a) -> m a
12:42:39 <applicative> Vinz_: still around?
12:42:56 <shachaf> mcstar: I'm saying you shouldn't do that.
12:43:02 <Vinz_> applicative: Yup :D
12:43:04 <tac> join a.k.a. "squish"
12:43:16 <applicative> Vinz_: I put it on github https://github.com/michaelt/exmude-alsa if you figure out how to get the raw materials in place: alsa, wx, ghc, cabal
12:43:28 <fizbin> But the Haskell definition of monad is built around >>= and I don't see where that is in the CT definition of what a monad is.
12:43:33 <johnw> fizbin: flip ((join .) . fmap)
12:43:54 <tac> fizbin: >>= is easier for programming with
12:44:01 <applicative> if you try it later, you can complain on the 'issues' thing and I'll see if I can figure it out.
12:44:04 <tac> join is easier to do category theory with
12:44:14 <applicative> Vinz_: ^^^^
12:44:15 <Vinz_> applicative: I’ll try it after eating !
12:44:22 <Vinz_> Thanks :)
12:44:30 <Philippa> join could be pronounced runMM. Sometimes that's what you want
12:44:44 <Philippa> for example: join (foo <$> a <*> b <*> c)
12:44:47 <mcstar> shachaf: it is not inflammatory if it comes from someone who cant even execute a line of perl
12:44:51 <Philippa> (n-ary bind!)
12:44:57 <fizbin> Ah, so you're saying that >>= can be defined in terms of join (and obviously vice-versa)
12:45:00 <mcstar> anyway, ease up a bit
12:45:03 <tac> fizbin: exactly
12:45:13 <applicative> how do you tell cabal install to use the local repos in a directory, just cabal install .this .that ??
12:45:17 <Cale> x >>= f = join (fmap f x), and join is usually called mu in the CT literature, and fmap is of course the functor acting on arrows.
12:45:21 <dmwit> Is it possible to turn off the overlapping patterns warning locally? (Just for one function, say?)
12:45:31 <shachaf> dmwit: I think that it is not possible.
12:45:34 <dcoutts> applicative: yes, you can just use the dir names
12:45:39 <dmwit> Right. Thanks.
12:45:46 <dmwit> (for confirmation)
12:45:50 <applicative> oh I see, the dot is the dir name, of course
12:46:08 <applicative> somehow I viewed as a cabal incantation
12:46:13 <dcoutts> applicative: right, ./this ./that
12:46:21 <dmwit> or this/ that/
12:46:26 <dcoutts>  ../the/other
12:46:45 <dmwit> But cabal won't go into those directories before it builds them! =(
12:46:50 <dcoutts> or you can use the .cabal files as targets
12:47:02 <dcoutts> dmwit: hmm?
12:47:08 <fizbin> Okay, and the reason that Monad m doesn't require that m first be a Functor is purely historical?
12:47:18 <Cale> right
12:47:28 <dmwit> dcoutts: Isn't this what you told me the other day when I was trying to figure out why I couldn't cabal install ./gtk?
12:47:29 <applicative> I was going to give instruction to be executed inside a directory with four updated cabalized dirs.  so cabal install ./this ./that ./this2 ./that2 seems right?
12:47:31 <johnw> fizbin: sadly so
12:47:44 <Cale> Well, there's a mild "convenience" rationalisation for it, but mostly it just creates inconvenience.
12:48:04 <fizbin> johnw: Not sadly. I was going to be sorely confused if there were other, non-historical reasons.
12:48:09 <dcoutts> applicative: yep, and --dry-run if you're cautious :-)
12:48:14 <Cale> It makes it slightly easier to write Monad instances, if you don't care about Functor, but most people care about Functor now.
12:48:23 <johnw> fizbin: I meant, sadly that it didn't get fixed ;)
12:48:30 <dcoutts> dmwit: oh you mean when building the Setup.hs files
12:48:31 <dmwit> dcoutts: I think the final conclusion was something like: gtk's Setup.hs looks for a file in the cwd, the cwd is foo and not foo/gtk, hence cabal install ./gtk from directory foo fails
12:48:38 <Cale> and you can always write  instance Functor MyMonad where fmap = liftM
12:48:41 <Cale> anyway
12:48:45 <dmwit> dcoutts: when running them, neither
12:49:11 <applicative> dcoutts: I take it cabal will be able to figure out the order of installation?
12:49:14 <Cale> so it's hard to argue that this is a real savings in any way
12:49:17 <dcoutts> applicative: right
12:49:44 <dcoutts> dmwit: mm, now that I come to think of it, that seems wrong, it should be launching the setup with the cwd set to the root of that package
12:49:55 <dcoutts> dmwit: that's what I thought it did
12:50:06 <dmwit> Oh, goodie!
12:50:21 <elliott> Oleg thinks Functor shouldn't be a superclass of Monad but his reasoning seems incoherent to me.
12:50:24 <Cale> I don't understand why Chrome likes to warn me that pdfs can "harm my computer"
12:50:24 <applicative> oh wait, but cabal configure refuses to enter the directories, should I makes some sort of meta-cabal file?
12:50:41 <dmwit> I was wondering how the heck I was supposed to deal with not being in the right directory from within Setup.hs, without knowing where the right directory *was*...
12:50:42 <dcoutts> applicative: enter? huh?
12:50:49 <dcoutts> dmwit: but then that means I don't understand why it would be failing
12:51:15 <dmwit> Well, let me double-check that I can reproduce the problem. I'll make a small test-case for you.
12:51:15 <applicative> I did       cabal configure  ./wx ./wxc ./wxdirect ./wxcore ./exmude in a directory that contained all those cabalized directories
12:51:44 <dcoutts> applicative: oh, no only install handles multiple targets. the configure/build etc only work on one package
12:51:58 <edwardk> The lack of Functor/Applicative as superclasses of Monad just means that whenever i have to work with a monad transformer stack i have to time travel back to 2002 and work with the Control.Monad combinators instead of the nice Applicative sugar.
12:52:02 <edwardk> It causes me to have to make my code just randomly less efficient on a fairly regular basis as I make it more generic.
12:52:09 <applicative> dcoutts: right just figured it out
12:52:25 <Cale> fizbin: anyway, the return/(>>=) approach to defining monads is paralleled in CT literature as "Kleisli triples"
12:52:51 <edwardk> elliott: i just figured he was having an off day that time
12:52:58 <Philippa> edwardk: yeah, there's nothing like fucking hysterical raisins to make a mess of your code
12:53:39 <elliott> edwardk: that's a good argument not to fix Monad: it would take away our powers of time travel
12:53:40 <simpson> We should run Typeclass Rework for Haskell 2018. He'll fix things.
12:53:49 <edwardk> true
12:55:30 <edwardk> anyone know what has been done for posix aio support for haskell? i can find an old posix-realtime binding from 2008 that has bitrotted away but thats it so far
12:55:33 <fizbin> So now I'm trying to trace through the monad laws in CT. One of them seems to say join . return = id, which okay, I think I've heard applies to proper Haskell Monad instances.
12:56:08 <fizbin> But the others don't look like anything I've seen before: join . liftM join = join . join
12:56:29 <Taneb> > liftM join . join $ "hello"
12:56:31 <lambdabot>   Couldn't match expected type `[m0 (m0 a0)]'
12:56:31 <lambdabot>              with actual type `...
12:56:33 <elliott> you can turn the laws in terms of (>>=) or (>=>) or whatever into laws in terms of liftM/join
12:56:33 <fizbin> And also join . liftM return = id
12:56:38 <elliott> /return
12:56:39 <elliott> it's just not how they're usually presented
12:56:45 <dcoutts> edwardk: I'd always assumed nobody uses aio, posix or linux, because they either have so many restrictions or the performance is no better than using multiple posix threads.
12:56:49 * hackagebot BerkeleyDB 0.8.7 - Berkeley DB binding  http://hackage.haskell.org/package/BerkeleyDB-0.8.7 (StephenBlackheath)
12:57:06 <dcoutts> edwardk: the apis to use aio are pretty horrid, the notification scheme is mad
12:57:43 <Cale> fizbin: A good trick to understanding what's going on is to focus on the types
12:57:44 <edwardk> dcoutts: i'm currently working on a fairly big database-like project where i'm willing to set up and tune a whole IO manager to maximize throughput at the expense of latency, which means setting up my own queueing more or less
12:58:28 <fizbin> Cale: That's a little hard though, because "join" and "liftM join" can have the same type.
12:58:37 <applicative> fizbin: the best formulation of the laws by far is the 'kleisli-ish' one. theres an exposition on the wiki let me see
12:59:00 <edwardk> i can do the whole aio thing if i set up O_DIRECT which i despise, or i can mmap and manually fadvise about when i'm going to need something, but then i risk blocking. at the loads i'm aiming for i really need to manage my intermediate working set sizes.
12:59:11 <dcoutts> edwardk: my guess is you'd get decent performance by using a smallish pool of OS threads doing normal blocking io, that's what's behind the glibc aio library
12:59:28 <edwardk> so just trying to cram that through posix threads basically means i'll just randomly fall off a cliff once my working set gets too big
12:59:28 <Cale> fizbin: If we're using CT notation, and we start out with T^3 X, there are two easy ways to get to T X: we can either apply the component of mu at TX to get to T^2 X, and then apply mu_T to get to TX
12:59:45 <applicative> fizbin: the last section -- 3 -- of this http://www.haskell.org/haskellwiki/Monad_Laws
13:00:18 <Cale> Or, we can apply T mu_X first. Since mu_X: T^2 X -> T X, we have T mu_X: T^3 X -> T^2 X
13:00:20 <fizbin> Cale: Right, I see that. I'm just trying to match CT with what I've seen given for Haskell Monads.
13:00:38 <fizbin> And trying to verify that it all matches.
13:00:52 <Cale> sorry mu_T above should be mu_X of course
13:00:56 <Cale> okay
13:01:03 <Cale> so mu becomes join
13:01:05 <edwardk> in my particular case i'm going to know with quite good accuracy hundreds of half meg blocks in advance for queuing purposes at a time, which is pretty much exactly the scenario all that stuff is designed for
13:01:17 <dcoutts> edwardk: I presume we're talking SSDs here, or something that can do lots of parallel/queued iops
13:01:28 <Cale> every component of mu is called join in Haskell, and we let polymorphism take care of which component of the natural transformation we're using
13:01:32 <fizbin> Cale: Right, and T mu_X becomes (liftM join)
13:01:44 <Cale> T on arrows becomes fmap (or liftM if you insist)
13:02:34 <hpaste> dmwit pasted “cabal install problems” at http://hpaste.org/84001
13:02:44 <Cale> So, yeah, the associativity law for monads says that if we join the outer two T's or the inner two T's first, and then join the remaining two T's, the result is the same.
13:02:49 <edwardk> ssd is one target, the other is just a spindle backend. the ssd target is the reason for the half meg chunks to optimize erase block throughput, on the traditional spindle backend its just a really really fat b-tree that i shadowpage leaves on so i can maximize sequential writes.
13:02:55 <dmwit> dcoutts: Instructions for making a very small project that can reproduce the problem I'm having with gtk.
13:03:27 <fizbin> Cale: Okay, in haskell that's join . join = join . liftM join
13:03:31 <edwardk> i can manage the queuing for traditional disks pretty easily, but for SSD those target queue sizes are needed to maximize sustained throughput
13:04:08 <dcoutts> edwardk: right, so e.g. if the ssd can queue 32 iops then you want to use a pool of 32+abit os threads (I think)
13:04:14 <Cale> fizbin: right
13:04:23 <Cale> fizbin: Which is one way the law is commonly presented in Haskell
13:04:35 <edwardk> dcoutts: now split this over a lot of them, and the queues get huge
13:04:36 <dmwit> dcoutts: Actually, maybe this should just go straight on cabal-install's bug tracker. (?)
13:04:46 <dcoutts> dmwit: probably
13:04:50 <dmwit> alright
13:05:01 <fizbin> Okay. I think I need to go through the exercise of reformulating the laws as given in terms of >>= in terms of join and fmap/liftM
13:05:04 <dcoutts> edwardk: you mean you're working with several ssds
13:05:07 <edwardk> yes
13:05:09 <applicative> @type let one = concat . concat ; two = concat . map concat in (one,two)
13:05:10 <lambdabot> ([[[a]]] -> [a], [[[a1]]] -> [a1])
13:05:17 <Cale> If you want to go from join/fmap/return laws to return/>>= laws, that's best carried out in Haskell notation.
13:05:22 <dcoutts> edwardk: yeah, then you have a bunch of threads for each
13:06:00 <edwardk> you've basically described my fallback option
13:06:10 <dcoutts> edwardk: you can achieve that using safe foreign calls, and the RTS will give you thread pooling for free, or you can do the posix thread stuff yourself in C
13:06:36 <dcoutts> edwardk: the fadvise sounds very tricky, precisely because you don't get notified sensibly when the io is done
13:07:43 <edwardk> thats why i was entertaining going back to the hell of aio
13:08:23 <edwardk> but having the region mmap'ed can make a huge difference at these scales for zero-copy purposes
13:08:39 <applicative> > let one = concat . concat ; two = concat . map concat ; lists = map (map show)  ["california", "uber", "alles"] in one lists == two lists
13:08:42 <lambdabot>   True
13:08:46 <dcoutts> edwardk: if your pattern really does fit linux aio then it's plausible, you have to be only reading/writing in existing open files (no aio open/close or other file ops) and if it is all block aligned and the access pattern means you don't benefit from the page cache...
13:09:45 <dcoutts> edwardk: it's also possible to use a os thread pool for the f/madvise approach, you get the OS thread to block by touching the memory pages in question
13:10:37 <edwardk> i'm basically stuck between giving up and doing the aio thing, going with the linus approach of mmap and fadvise or saying screw it all and going with the haskell io stuff here
13:11:06 <fragamus> hey is there a haskell back end that emits C or C++
13:11:28 <dcoutts> edwardk: I'd start with the simplest to code and see if it gives any improvement
13:11:31 <applicative> jhc
13:11:48 <edwardk> i may wind up having to use something where i basically fadvise to get the page cache primed a few steps before i get around to mmapping in the region, mmap in the region then have a thread go block on the stuff i need in it
13:12:21 <dcoutts> edwardk: you can mmap it in advance, and madvise
13:12:27 <dcoutts> address space is cheap
13:13:03 <applicative> fragamus: there is something called an unregistered build of ghc that still does it, I seem to remember reading
13:13:07 <dcoutts> edwardk: but to answer your original Q, I'm not aware of any existing solutions in haskell
13:13:17 <dcoutts> edwardk: good luck!
13:13:22 * dcoutts disappears
13:13:25 <fragamus> I really love it
13:14:36 <fragamus> I have a huge C++ code base and I am dealing with people who are neanderthals and I have convinced them that Haskell is the way but they need to hold on to their C++ blankey
13:14:53 <Taneb> Good luck
13:14:57 <fragamus> haha
13:15:34 <fragamus> I have identified a nice bite sized chunk of the code base that can be rewritten in haskell
13:15:47 <applicative> well it'd be awfully cool if you could figure it out...
13:16:08 <elliott> fragamus: you can bind to haskell code from C++ without compiling haskell to C++
13:16:27 <elliott> GHC has a pretty graet FFI
13:16:28 <applicative> fragamus: i was going to say, there is the FFI
13:16:41 <fragamus> yes but the neanderthals need to be able to see C++ or C code so they can feel like it is real
13:17:08 <elliott> fragamus: uhm, you may be disappointed with the human-readability of the outputted code then
13:17:09 <Taneb> I wonder what one of these people would do with a LISP machine
13:17:12 <elliott> haskell's semantics are very far away from C
13:17:12 <fragamus> I don't know why they think that makes them safer
13:17:21 <fragamus> I know of course it will read like martian
13:17:26 <elliott> though I think jhc's output isn't too bad considering, it's still not going to look like the kind of C a human would write
13:17:26 <Philippa> fragamus: in a pinch you can always embed a subset of C++ in haskell?
13:17:51 <applicative> fragamus: yeah, in the days of fvia-C or whatever, it was always said it was unreadable and compilation needed to be managed by ghc anyway -- or something.
13:18:10 <Philippa> fragamus: they might find seeing GHC Core helps some?
13:18:21 <Philippa> Core actually looks like something you can picture a back end for
13:18:31 <fragamus> I just love what I have learned in Haskell land and I am as excited as ever about updating this here code base
13:18:39 <applicative> fragamus: on the other hand the jhc outputs beautiful C, but good luck isolating which fragment of haskell and hackage it works for ....
13:19:57 <fragamus> I expect that the reduction in the number of lines from C++ to Haskell will make the cave men into believers
13:20:45 <Philippa> fragamus: in a pinch, Haskell makes an *awesome* macro language
13:20:52 <fragamus> applicative: that sounds ungood
13:21:20 <henk> How should I parse options and arguments on the command line? System.Console.GetOpt or is there anything "better"?
13:21:32 <fragamus> philippa: Oh you mean that I can write some haskell by hand to emit some C++
13:22:38 <Philippa> fragamus: right. And then you take that lib and write more useful haskell that emits more useful C++
13:22:50 <hpaste> “Sakari Bergen” pasted “8 queens problem” at http://hpaste.org/84002
13:23:00 <fragamus> nice...
13:23:19 <SaBer_> I'm new to haskell, and was wondering if that is doing true recursive backtracking
13:23:39 <SaBer_> I'm guessing all the lazy evaluations should result in it being so
13:23:52 * dilinger chuckles.  as a beekeeper, "8 queens problem" brings to mind something completely different
13:24:34 <applicative> SaBer_: it looks like it. You are missing a case in validate -- the empty list of pairs
13:25:10 <Philippa> dilinger: as a queer... :-)
13:25:28 <SaBer_> applicative: if it's never called with an empty list, it should never end up calling it with an empty list. It was a concious choice
13:26:21 <applicative> SaBer_: also instead of using head ps and tail ps, you should clarify that the pattern you are dealing with is not validate (p:ps) but validate (p: p1: ps) then you don't need head and tails
13:26:28 <applicative> SaBer_: both of which are unsafe
13:26:47 <applicative> SaBer_: I can call it with the empty list
13:27:32 <gspr> Does cabal not have an else-if syntax?
13:28:34 <dmwit> gspr: Oh, does just putting another if-else inside the else block not work?
13:28:39 * dmwit is mildly surprised
13:29:13 <gspr> dmwit: The nesting gets a bit nasty, that's all
13:29:20 <dmwit> ah
13:29:53 <dmwit> File an enhancement request. =)
13:30:01 <dmwit> In the meantime, you could always rebalance your conditions...
13:30:19 <gspr> What I really need to do is set c-sources differently depending on which OS we're compiling... is there another nicer way to do this?
13:30:31 <gspr> (in my case, the nesting isn't actually bad, it just feels wrong :P )
13:30:38 <SaBer_> applicative: I was going to do it as (p:p1:ps), but then somehow got confused and thought it wouldn't work. Got it to work with it now, it's cleaner :)
13:30:41 <gspr> *compiling on
13:31:25 <dilinger> Philippa: hah
13:31:52 <applicative> SaBer_: it probably doesnt matter here, but elsewhere, you should probably specialize Num a => to whatever you are using, here Int I guess, or else Integer
13:32:03 <dmwit> gspr: ...nicer than what?
13:32:31 <gspr> dmwit: Nested if's... I don't know, I'm not very familiar with cabal.. thought there might be something like "if you're on this OS, do this, if you're on that, do that..."
13:32:45 <gspr> the if's are fine, I just wanted to check I'm not doing something stupid :p
13:32:58 <applicative> SaBer_: I mean, you aren't writing nice high level combinators validate and validate one, but something specialize to your module
13:33:02 <dmwit> Well, flat if's can be nicer. But it's hard to tell whether they'll work for you if you don't show what we're trying to be nicer than...
13:33:08 <SaBer_> applicative: I got an error with Int a => ... and then changed it. I should still learn more about types and typeclasses.
13:33:32 <gspr> dmwit: Hehe, yeah I see. Nah, flat if's will be fine for me :)
13:33:44 <applicative> SaBer_: yeah, you kill the blah blah => business and just replace 'a' with 'Int'
13:33:58 <SaBer_> applicative: yep, thanks for the comments :)
13:34:20 * dmwit is thoroughly confused now
13:34:56 <newsham> I want to repeatedly generate and add together arrays of 256 integers.  would it be faster using an array or a list?  would it even matter?
13:35:09 <applicative> SaBer_: also fwiw putStrLn (show x) = print x
13:35:23 <SaBer_> applicative: yeah, the pastesite told me that also
13:35:32 <applicative> SaBer_: oh hlint notices that
13:35:56 <cariveri> type D a = X String a,  I cant do d = D "mystring" 1. It says not in scope contructor D. why?
13:36:16 <Cale> SaBer_: Type classes you can think of as being things which might be true or false of any given type, and you can use them to control which sets of types your type variables range over.
13:36:21 <dmwit> cariveri: ...because the constructor is named X?
13:36:30 <dmwit> er
13:36:38 <dmwit> cariveri: Because X doesn't have a D constructor?
13:36:45 <Cale> SaBer_: So when you write (Num a) => ... it means that the type variable a is allowed to be anything which is an instance of the typeclass Num
13:36:50 * hackagebot doctest 0.9.5.1 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.5.1 (SimonHengel)
13:36:59 <NemesisD> i've got a function that's something like foo :: SomeStateThing -> (x, SomeStateThing), i want to run that function 3 times and return the final state. should i be using a fold or is it Writer that I want?
13:37:19 <dmwit> :t replicateM 3 . state
13:37:20 <lambdabot> MonadState s m => (s -> (a, s)) -> m [a]
13:37:29 <dmwit> :t runState . replicateM 3 . state
13:37:30 <lambdabot> (s -> (a, s)) -> s -> ([a], s)
13:37:37 <dmwit> Oh, you want just the final state?
13:37:42 <dmwit> :t execState . replicateM 3 . state
13:37:43 <lambdabot> (s -> (a, s)) -> s -> s
13:37:54 <NemesisD> dmwit: yeah im going throw out the fst, this is for a test
13:38:09 <Cale> which will mean that certain functionality is implemented with respect to whatever type a is (in this case, things like addition and multiplication and so on)
13:38:40 <dmwit> Perhaps you even want replicateM_ instead of replicateM. But it's probably not going to matter with such a small argument.
13:39:27 <mbp> hello. is there a way to remove some of the commented boilerplate? http://hpaste.org/84003 (lines 8-13 and 21-27)
13:40:56 <Cale> SaBer_: Another good example is sorting. You might want to write a sorting function which will work on "any" type of list, suggesting that the type should look something like sort :: [a] -> [a]. But many types of elements don't necessarily support the comparison operations like <= which are needed to write a sorting algorithm, so you have a typeclass constraint to say that there must be an implementation of those thing
13:40:57 <Cale> s.
13:41:05 <dmwit> mbp: Perhaps you should define a new type data CommonAd = Ad { id :: Int, url :: String, ... }, and put a field "houseCommon :: CommonAd" in your houseAd type.
13:41:08 <Cale> So the actual type is sort :: (Ord a) => [a] -> [a]
13:41:27 <NemesisD> dmwit: thanks! that feeling where you do something complex like this and all the argument ordering works out well for partial application
13:42:04 <dmwit> mbp: (...and skip the typeclass entirely.)
13:43:37 <dmwit> In fact, I'd just call that type Ad; call the rest of the HouseAd record just House; call the rest of the ComputerAd type just Computer; and perhaps, if I'm feeling aliasy, add a "type WithAd a = (a, Ad); type HouseAd = WithAd House; type ComputerAd = WithAd Computer" or something.
13:43:54 <lazy_parenthesis> is Haskell whitespace sensative?
13:44:03 <dmwit> Yes.
13:44:09 <lazy_parenthesis> :(
13:44:20 <ciaranm> haskell hates blind people
13:44:20 <dmwit> You can choose to program in a non-sensitive subset of Haskell; all features are still available in this subset.
13:44:28 <mbp> dmwit thanks, trying to process your last suggestion
13:44:41 <dmwit> mbp: I'll annotate.
13:44:42 <lazy_parenthesis> why is it case-sensitive by default?
13:44:53 <Philippa> because most languages are
13:44:56 <lazy_parenthesis> and how are all features available if it is a "subset"
13:45:15 <Philippa> because it's a grammatical&lexical subset, not a semantic one
13:45:20 <lazy_parenthesis> Philippa: not really.
13:45:29 <geekosaur> lazy_parenthesis, really?
13:45:32 <Philippa> perhaps you didn't mean "case-sensitive" there
13:45:46 <lazy_parenthesis> did I say case-sensetive?
13:45:57 <Philippa> yeah
13:46:01 <lazy_parenthesis> > <lazy_parenthesis> is Haskell whitespace sensative?
13:46:02 <lambdabot>   <hint>:1:1: parse error on input `<'
13:46:05 <geekosaur> [13 16:44] <lazy_parenthesis> why is it case-sensitive by default?
13:46:13 <lazy_parenthesis> Oh
13:46:17 <lazy_parenthesis> I meant whitespace...
13:46:24 <lazy_parenthesis> like tabs and stuff
13:46:33 <Taneb> Because that looks cleaner
13:46:35 <Taneb> I think
13:46:35 <dmwit> lazy_parenthesis: All features are available even though it's a subset because the whitespace-sensitive bits get translated to whitespace-insensitive core.
13:46:41 <lazy_parenthesis> sorry
13:46:42 <Philippa> right. So tabs are a bad idea in Haskell? But it's that way by default because that's how it's intended to be used
13:46:49 <dmwit> You can always use explicit {;} instead of whitespace.
13:46:50 <geekosaur> because it's easier to read (and to write once you learn the rules) than using braces everywhere
13:46:51 <SaBer_> Cale: I understand the basic idea with typeclasses, but not all the details on how to use them (e.g. syntax). I'll keep reading, I'm in the middle of a tutorial currently...
13:46:52 <dmwit> And you lose nothing.
13:46:59 <Philippa> also, what dmwit just said. I've written the translation pass: it's a pain, but it's nice to have there
13:47:09 <Philippa> Haskell isn't Python: it has better-founded principles :-)
13:47:15 <dmwit> s/to whitespace-insensitive core/to *a* whitespace-insensitive core/
13:47:22 <ciaranm> haskell is non-well-founded!
13:47:24 <dmwit> (to avoid confusion with Core, GHC's intermediate language)
13:47:27 <Philippa> dmwit: aka the language's actual grammar :-)
13:47:32 <dmwit> right
13:47:51 <Philippa> for those surprised by this: read the Haskell Report and all will become surprisingly clear
13:48:06 <Philippa> the pass is pretty well-behaved, even if the parse-error case is a bastard to implement
13:48:17 <Philippa> (okay, "pass" is the wrong word!...)
13:48:49 <lazy_parenthesis> conv.hs:34:1: parse error (possibly incorrect indentation)
13:49:04 <lazy_parenthesis> so how do I turn this off?
13:49:09 <lazy_parenthesis> is there a ghci option?
13:49:14 <ciaranm> by getting your indentation correct
13:49:16 <mauke> lazy_parenthesis: fix your syntax error
13:49:26 <mbp> dmwit did you mean something like this?  data Ad = House { ... } | Computer { ... }. that is what I started with
13:49:50 <dmwit> mbp: http://hpaste.org/84003
13:50:02 <dmwit> ah, shit, ruined my own joke
13:50:13 <dmwit> That's supposed to say non-Enterprise
13:50:20 <mbp> :)
13:51:03 <dmwit> Hah! The funny thing is that error isn't even usually because of incorrect indentation.
13:51:13 <dmwit> Too bad he rage-quit.
13:51:18 <ML_is_better> no
13:51:23 <ML_is_better> I just switched my name
13:51:27 <ML_is_better> changed*
13:51:31 <dmwit> aha =)
13:51:37 <dmwit> Anyway, if you want help, use
13:51:38 <dmwit> ?hpaste
13:51:38 <lambdabot> Haskell pastebin: http://hpaste.org/
13:51:45 <ciaranm> like how the "add it to a typeclass" error isn't usually because something needs adding to a typeclass
13:51:50 * hackagebot snap-predicates 0.1.0 - Predicates for route definitions.  http://hackage.haskell.org/package/snap-predicates-0.1.0 (ToralfWittner)
13:52:40 <ML_is_better> no, the function I wrote is too embarrassing to put on hpaste
13:53:56 <dmwit> Well, look for mismatched parentheses/brackets/braces and turn on your editor's visual tabs, then.
13:54:11 <ML_is_better> ok, thank you for the tips :)
13:54:24 <dmwit> Tabs are okay, as long as you don't rely on them being any specific width in terms of spaces.
13:54:34 <dmwit> Despite what everybody else in here will say about them. =)
13:54:59 <ciaranm> dmwit hates blind people
13:55:07 <ML_is_better> where can I read the rules about correctly indenting in Haskell?
13:55:18 <elliott> the report
13:55:21 <elliott> @where report
13:55:21 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
13:55:30 <ML_is_better> whow
13:55:32 <ML_is_better> magic
13:55:36 <ML_is_better> @where
13:55:36 <lambdabot>  @where <key>, return element associated with key
13:55:37 <Philippa> ML_is_better: the Haskell Report is pretty definitive - if you can read grammars it'll also make sense pretty quick
13:55:42 <ML_is_better> @man where
13:55:43 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
13:56:02 <Philippa> (you also don't need to understand all of the intricacies of the layout algorithm!)
13:56:16 <dmwit> ?help where
13:56:16 <lambdabot> where <key>. Return element associated with key
13:56:34 <dmwit> I wonder what man is getting corrected to.
13:56:35 <ML_is_better> that's pretty cool
13:56:37 <dmwit> ?list
13:56:37 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:56:53 <ML_is_better> >[1..10]
13:57:17 <dmwit> ?map
13:57:17 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
13:57:17 <ML_is_better> isn't lambdabot supposed to evaluate that?
13:57:22 <mauke> ML_is_better: no
13:57:27 <dmwit> ML_is_better: Put another space after the >
13:57:30 <dmwit> > [1..10]
13:57:32 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
13:57:44 <dmwit> ML_is_better: Also, if you want a good answer, you must ask a good question. As mauke was cheekily demonstrating.
13:57:59 <ML_is_better> ok
13:58:12 <ML_is_better> I am sorry for what I am about to do, but it has to be done
13:58:14 <ML_is_better> [1..]
13:58:17 <ML_is_better> > [1..]
13:58:19 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:58:32 <dmwit> And that is why ML is not better. =)
13:58:59 <ML_is_better> at least it's not as picky about tabbing, and doesn't lie about error messages...
13:59:26 * dmwit doesn't see any lie in an error message
13:59:27 * mauke rolls eyes
13:59:37 <ML_is_better> > :!ls
13:59:39 <lambdabot>   <hint>:1:1: parse error on input `:!'
13:59:47 <srhb> ML_is_better: lambdabot is not ghci.
14:00:07 <ciaranm> there are ways to break lambdabot, but you're not going to find them
14:00:22 <dmwit> ?v
14:00:22 <lambdabot> Exception: <<loop>>
14:00:29 <ML_is_better> I will set it as my goal for learning Haskell
14:00:41 <dmwit> That seems like a pretty excellent goal!
14:01:10 <ML_is_better> hugs maybe?
14:01:12 <ML_is_better> > !ls
14:01:14 <lambdabot>   <hint>:1:4: parse error (possibly incorrect indentation)
14:01:19 <srhb> Neither nor.
14:01:27 <dmwit> No, hint. As it is saying in the very message you just saw.
14:01:34 <dmwit> via mueval
14:01:37 <dmwit> ?hackage mueval
14:01:37 <lambdabot> http://hackage.haskell.org/package/mueval
14:02:24 <fizbin> > fix (\f -> 0 : 1 : zipWith (+) f (tail f))
14:02:25 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:02:28 <aranea> Hi. I'd like to parallelize the following code to multiple cores: myfunc n = filter predicate [1..n]
14:02:30 <edwardk> back
14:02:38 <aranea> the order of the output doesn't matter
14:02:42 <edwardk> dcoutts: still around?
14:02:47 <dmwit> aranea: What output?
14:02:49 <oio_> Functional Reactive Programming for web development (Impressive) - http://elm-lang.org/try
14:03:19 <aranea> dmwit: the order of the returned list
14:03:20 <mbp> dmwit I am writing a program that scraps ads from a web page and displays them to the user for analysis. I had downloadAds function, which returned a list of different types of ads depending on the passed parameter. if I used your types I guess that function would return (Ad, <item in the ad>) tuple or something similar?
14:03:36 <dmwit> mbp: sure
14:03:48 <Lethalman> is there some tutorial for php programmers?
14:04:10 <srhb> What? PHP -> Haskell?
14:04:11 <mcstar> i prefer programs that scrap ads from a page period
14:04:21 <mcstar> :)
14:04:28 <srhb> Lethalman: "Forget everything, then read LYAH"
14:04:45 <mcstar> anyway, this was an educational day again, by all
14:04:45 <Lethalman> srhb, yes, any alternative?
14:05:02 <srhb> Lethalman: Not really. There's not much you gain from learning PHP that can be used in Haskell
14:05:07 <srhb> Lethalman: Almost quite the opposite.
14:05:07 <dmwit> aranea: If the output of your function is nondeterministic, you want concurrency, not parallelism.
14:05:17 <dmwit> aranea: And then you'll need to live in the IO monad. Is that okay with you?
14:05:28 <Lethalman> srhb, it's about how to do web programming like you did in php but in haskell
14:05:32 <aranea> it would be acceptable
14:05:37 <Lethalman> srhb, why and how... there's much to say
14:05:41 <srhb> Lethalman: Ah, any of the crash courses for the web frameworks would do
14:05:44 <Lethalman> from a pragmatic view point
14:05:53 <Lethalman> srhb, they wouldn't mention php
14:05:59 <Lethalman> srhb, if you don't know any, don't bother :)
14:06:03 <c_wraith> yes, and htat's for the best
14:06:04 <srhb> The happstack crash course does mention PHP
14:06:14 <c_wraith> teaching people to use anything other than PHP is best done without mentioning PHP
14:06:19 <srhb> I agree.
14:06:20 <dmwit> aranea: Fine. Then something like f xs = do { c <- newChan; mapM_ (\v -> forkIO (if predicate v then writeChan c v else return ())) xs; getChanContents c }
14:06:55 <Lethalman> yes yes
14:06:57 <Lethalman> thanks guys
14:07:01 <stepkut> srhb: only once!
14:07:05 <srhb> stepkut: ;)
14:07:42 <srhb> I wonder how many valid and true sentences go like X in PHP is like Y in Haskell
14:07:44 <stepkut> well.. twice, depending how you count it, "HSX is an XML-based templating system that allows you to embed XML in your Haskell source files. If you have ever had to use PHP, you may want to run screaming from this idea. However, the HSX solution is far saner than the PHP solution, so you may want to give it a chance."
14:08:16 <srhb> stepkut: I have yet to give it a chance for that exact reason, I'm afraid.,
14:08:37 <Lethalman> srhb, many of them
14:08:48 <stepkut> srhb: :)
14:08:49 <srhb> Lethalman: I can't think of any offhand.
14:08:54 <aranea> dmwit: predicate is quite cheap to evaluate, I don't think a separate thread for each evaluation is good
14:09:02 <aranea> but n will be quite large
14:09:10 <Lethalman> srhb, you're going straight on your idea, that's why... open your mind a little more
14:09:29 <Lethalman> you'll find
14:09:31 <dmwit> aranea: Hm, also, I just realized that getChanContents will never end the list. =P
14:09:58 <mbp> dmwit thanks I like your solution. by the way you named id just id, which is a function from prelude. is that a problem if I never use that function?
14:10:13 <dmwit> mbp: Oh, yeah, that can be annoying.
14:10:20 <dmwit> It's not a problem until you use id, as you say.
14:11:03 <srhb> Lethalman: Perhaps I really am mistaken, in which case I know either too little Haskell or little PHP. Anyway, we're veering off-topic, if you want to enlighten me (and I'd be delighted) come do it in -blah. :)
14:11:40 <dmwit> aranea: Okay, you'll probably have to chunk the list, then, and process chunks in a thread each.
14:11:47 <Lethalman> srhb, something as simple as displaying a web page, splitting a string, validating a number or a date, and so on
14:11:50 <Lethalman> want more?
14:11:58 <mbp> sorry I meant I never use Prelude.id, I would use Ad id. I could hide id from prelude, but not sure if that's considered a good style
14:12:05 <mauke> Lethalman: stop.
14:12:09 <dmwit> mbp: That seems fine to me.
14:13:08 <danharaj> Does anyone know how makeClassy works in lens? Can you automatically derive instances of the class it creates?
14:13:11 <dmwit> aranea: Keep in mind that threads are *much* cheaper in GHC than in most other languages.
14:13:29 <TravisD> So today my friend brought up the fact that Monads with lazy binding are actually not monads. Do people generally care about this?
14:13:31 <dmwit> You can easily run tens of thousands of threads on a boring old laptop.
14:13:33 <edwardk> danharaj: you need to make the instances, but if the other things you made also have lenses its easy to do usually a 1 liner
14:13:36 <shachaf> GHC HQ will pay you per thread.
14:13:46 <aranea> sure, I'm used to that, but in this case I'm sure it'd be to much overhead, dmwit
14:13:47 <danharaj> edwardk: cheers
14:13:51 <shachaf> TravisD: You mean the ones that don't obey the monad laws with ⊥?
14:13:55 <TravisD> yeah
14:13:55 <dmwit> aranea: Okay. I trust you. =)
14:14:03 <NemesisD> dmwit: quick question, i find i need to get the final result of applying the state function 3 times, but evalState . replicateM 3 . state :: (s -> (a, s)) -> s -> [a], really i wanted (s -> (a,s)) -> s -> a
14:14:16 <edwardk> data Foo = Foo { _fooId :: Int }; makeClasy ''Foo;      data Bar = Bar { _barId :: Int, _barFoo :: Bar }; makeClassy ''Bar; instance HasFoo Bar where foo  = barFoo
14:14:45 <dmwit> NemesisD: last . evalState?
14:15:24 <NemesisD> dmwit: yeah i thought that, the bummer part is that is partial if 3 is < 1
14:15:34 <dmwit> > 3 < 1
14:15:35 <lambdabot>   False
14:15:49 <NemesisD> lol, if 3 was a variable
14:15:53 <edwardk> danharaj: if you want to get extra fancy you can change out the second one for a makeLensesWith ?? ''Bar $ classyRules & createClass .~ False   and make a hand rolled class HasFoo t => HasBar t where … and get the makeLensesWith to still make your instance for you, but then HasBar will imply HasFoo
14:15:55 <dmwit> NemesisD: reverse + pattern match, then
14:16:00 <ciaranm> > let 3 = x in 3 + 3
14:16:02 <lambdabot>   6
14:16:17 <NemesisD> yeah i think ill just do that
14:16:19 <NemesisD> thanks
14:16:27 <NemesisD> it isn't production code anyways, its test code
14:16:42 <NemesisD> its my own damn fault if i hit an undefined in a test
14:17:11 <danharaj> edwardk: cool. It would be nice if there were also a way to turn a record Foo into a class "HasFoo" where the methods are each of its lenses instead of one big lens.
14:17:52 <edwardk> um, class HasFoo has a lens per field already
14:18:10 <arkeet> and a class per field
14:18:43 <danharaj> hm I forgot what I meant.
14:18:55 <edwardk> data Foo a = Foo { _bar :: Int, _baz :: Double, _quux :: a }; makes class HasFoo t a | t -> a where foo :: Lens' t (Foo a); bar :: Lens
14:18:57 <edwardk> er
14:19:20 <edwardk> bar :: Lens t Int; baz :: Lens t Int; quux :: Lens t a
14:19:33 <edwardk> (Lens' as needed)
14:20:02 <dmwit> aranea: To be honest, if predicate is cheap, I can't really imagine a way of making filter predicate efficiently use many cores. Following pointers is going to be one of the big costs, and that part can't be split across cores...
14:20:34 <dmwit> Amdahl's law and all that.
14:20:50 <danharaj> edwardk: ah yes. I think what I meant to say was a way to get an instance of HasFoo by specifying only the smaller lenses. Maybe. Shower thoughts don't always make sense.
14:21:14 <edwardk> danharaj: have you looked at makeFields?
14:21:19 <danharaj> I have not.
14:21:39 <edwardk> that makes all the fields into classes in their own right makes the class if it can't find it, and instantiates them all, etc.
14:22:22 <dmwit> List is just the wrong datatype.
14:22:27 <danharaj> edwardk: So if it finds the class then it will reuse it instead of making a new one.
14:22:35 <edwardk> yep
14:22:52 <edwardk> its a bit tricky to use correctly, and was included more as a user interface experiment
14:23:00 <edwardk> but some people really like it
14:23:07 <danharaj> edwardk: that's pretty much what I wanted. I have a vague foreboding about orphan instances but with a bit of discipline it shouldn't explode in my face.
14:23:46 <edwardk> yeah, you can avoid the orphans by putting the classes in the right place. so long as the class or the data type is being defined in the module the instances aren't orphans
14:24:54 <danharaj> edwardk: What I think I want exactly is if I have a class Foo that is only Lens methods then something like makeFields ''Foo ''Bar, which would instantiate Bar with Foo if it has the appropriate _lenses.
14:25:48 <edwardk> if you wanted to dive into Control.Lens.TH and hack on a makeFieldsFor or something i'd not object
14:26:08 <dmwit> Careful now. You're about to wind up with commit access...
14:26:37 <danharaj> edwardk: These are all preliminary thoughts. Usually what happens is I think about it for a while, decide "this is completely stupid" and then come up with something else... ad infinitum.
14:26:42 <Mathnerd314_> dmwit: it's git, all you get is push access IIRC
14:26:51 * hackagebot haggis 0.1.1.0 - A static site generator with blogging/comments support  http://hackage.haskell.org/package/haggis-0.1.1.0 (TychoAndersen)
14:27:16 <dmwit> I don't understand what the difference between commit access and push access is.
14:27:33 <arkeet> commits are local
14:27:58 <dmwit> Surely nobody thought "commit access" meant "write access to your own hard drive"?
14:28:01 <arkeet> :P
14:28:08 <srhb> I think they are used interchangeably and imprecisely wrt github?
14:28:10 <shachaf> Watch out, edwardk is going to revoke your commit access!
14:28:20 <srhb> I may be wrong.
14:28:39 <arkeet> well it's just "access"
14:28:43 <arkeet> you can do more than just push
14:28:49 <aristid> dmwit: and i thought edwardk did control who can access my hard drive.
14:29:00 * edwardk gives in and just gives him a kmett bit instead.
14:29:08 <dmwit> hehehe
14:29:24 <ciaranm> edwardk can take something out of an IO monad
14:29:24 <srhb> aristid: Only if you installed lens.
14:29:26 <edwardk> some people have managed to accumulate several
14:29:34 <aristid> srhb: i did! dang
14:29:34 <danharaj> edwardk: for example, I think I've written nearly a dozen different implementations of FRP in the last 6 months.
14:29:52 <aristid> edwardk: i believe i even have some unused kmett bits :P
14:29:53 <edwardk> danharaj: you need to start obsessing about functional hybrid modeling instead ;)
14:30:05 <danharaj> edwardk: Can I make silly chemistry puns? :P
14:30:14 <hpaste> ClaudiusMaximus pasted “sorted list thing” at http://hpaste.org/84006
14:30:18 <edwardk> danharaj: yes
14:30:40 <levi> What is functional hybrid modeling?
14:30:49 <srhb> danharaj: You failed a monadic titration and now your transformer became a cisformer?
14:30:52 <srhb> Sorry...
14:30:57 <ClaudiusMaximus> suggestions for a better name for my sorted list thing! also, does it already exist in some library?
14:31:01 <ciaranm> levi: it's an alternative to disfunctional gasoline modelling
14:32:00 <aristid> ClaudiusMaximus: SortedList
14:32:00 <dmwit> ?remember srhb You failed a monadic titration and now your transformer became a cisformer.
14:32:00 <lambdabot> I will remember.
14:33:03 <srhb> My quotes are so dumb. :<
14:33:33 <ciaranm> srhb: microsoft has a feature for fixing that
14:34:01 <srhb> ciaranm: Oh?
14:34:21 <ciaranm> http://en.wikipedia.org/wiki/Smart_quotes#Smart_quotes
14:34:33 <arkeet> "fixing"
14:34:51 <ClaudiusMaximus> aristid: make sense!  didn't find anything relevant on hackage so far..
14:35:15 <srhb> Aha :P
14:35:17 <dmwit> ?hackage data-ordlist
14:35:18 <lambdabot> http://hackage.haskell.org/package/data-ordlist
14:35:25 <dmwit> ClaudiusMaximus: ...but only for statically-known orderings.
14:36:05 <levi> Category theory should adopt the cis/trans terminology to replace the <foo> and co-<foo> terminology. :P
14:36:22 <ciaranm> not as many puns
14:37:08 <levi> transmonads sound cooler than comonads, though.
14:37:27 <edwardk> if you go with transmonad, then you better petition to change monad to cismonad.
14:37:31 <fizbin> Yeah, but then you couldn't do the joke about co-mathematicians and ffee.
14:37:47 <ciaranm> if you call them transmonads they'll start doing to haskell conferences what they're doing to ruby
14:37:50 <hpc> @hackage acme-comonad
14:37:51 <lambdabot> http://hackage.haskell.org/package/acme-comonad
14:37:51 <ClaudiusMaximus> dmwit: mm, the main point of my module was to be able to get the "current best few" without too much effort after inserting or changing scoring metric
14:38:09 <monochrom> haha trans and cis
14:38:49 <fizbin> "We know from Erdos that "A mathematician is a device for turning coffee into theorems". Therefore by duality a co-mathematician turns co-theorems into ffee."
14:39:10 <arkeet> indeed
14:39:10 <edwardk> Now, what i could do is see using class MonadCis t where cis :: (Monad m, Monad n) => (forall x. m x -> n x) -> t m a -> t n a for that other lifting operation
14:39:22 <Philippa> Folks? Just a reminder that those labels are also used of people and this might make some around you feel a little uncomfortable
14:39:34 <ciaranm> told you
14:39:45 <edwardk> but having "t n a" in there might offend someone
14:40:06 <srhb> Sorry. :)
14:40:06 <Philippa> edwardk: distinctly less likely
14:40:13 <edwardk> Philippa: true =)
14:40:32 <hpc> edwardk: it's one letter removed from "d n a", and mutation of dna is a core principle of evolution
14:40:36 <Philippa> ciaranm: I'll give you a hint - I've run Haskell events in the past and we didn't have a problem
14:40:41 <hpc> edwardk: my god, you've insulted the catholic church!
14:40:46 <dmwit> (Monad m, Moand n, a ~ i) => t m i -> t n a
14:40:55 <mauke> >Moand
14:42:58 <danharaj> I don't get the comments w.r.t. ruby conferences
14:43:40 <Philippa> danharaj: there is... controversy around how welcoming Ruby conferences are/aren't to members of various minorities
14:43:47 <danharaj> oh that's unfortunate
14:43:50 <ciaranm> they tend to get shut down or cause outrages for having too many white males or making sex jokes
14:44:14 <danharaj> unfortunate that they don't have a welcoming atmosphere that is.
14:44:17 <Philippa> the last one I saw chose to shut itself down, but hey
14:44:37 <ciaranm> the one that shut itself down was the one that shouldn't have...
14:44:47 <edwardk> hpc: your god indeed ;)
14:44:48 <hpc> they should be more like python and be unwelcoming for pointless technical reasons
14:45:04 <Philippa> so what ciaranm said in response to me? Was basically suggesting that the idea we not knowingly make each other uncomfortable is a problem
14:45:10 <Philippa> Which isn't how we run things around here
14:45:26 <srhb> OK, thanks for the translation, I was really having a problem parsing that.
14:45:55 <srhb> (As in, I didn't know whether to get out the rotten tomatoes or applaud)
14:46:22 <danharaj> I remember being disappointed in some of the reactions on /r/haskell to that one article about such issues.
14:46:43 <hpaste> aranea pasted “concurrent filter” at http://hpaste.org/84008
14:46:46 <ciaranm> Philippa: i am suggesting that the idea that "trans" should not be used in a way similar to one of the many ways it has been used for a very long time because it is also used in other ways is rather a long way down the path to banning IDE...
14:47:00 <aranea> what's wrong there?
14:47:04 <Philippa> ciaranm: with respect, that is far from the only thing you suggested
14:47:16 <Philippa> and yes, the Haskell community does have trans people in it
14:47:31 <danharaj> at least several that I am acquainted with.
14:47:32 <hpc> this channel does, even
14:47:59 <ciaranm> the word "trans" is used for lots of things, and this should not be a problem.
14:48:04 <Philippa> now, leaving aside that at least with co we admit that which construct is the dual is a historical accident?...
14:48:11 <Philippa> (whereas trans/cis means something specific)
14:48:15 <ciaranm> should "transformers" be renamed?
14:48:29 <Philippa> put the strawmen down, ciaranm
14:49:50 <dmwit> aranea: The first argument to ($) there is (mapM_ takeMVar =<< forM [1..4]), not (forM [1..4]) like you intended.
14:50:17 <danharaj> $ binds weakest of all.
14:50:25 <dmwit> You could either parenthesize or use (<=<) instead of (=<<).
14:50:48 <hpc> one ($) to rule them all, and at the top of the parse tree bind them
14:51:17 <elliott> Philippa: there should be a prefix for "not-co" that's also two letters long
14:51:30 <elliott> perhaps "oc"
14:51:44 <dmwit> fu
14:51:46 <elliott> and then we have to put "oc" in front of everything new.
14:52:01 <aranea> thanks, dmwit – I fear it's too late in the evening for programming properly...
14:52:10 <Philippa> elliott: heh. So what I'd like to know is whether there's any sense anywhere that "we got them the wrong way round" for some constructs
14:52:12 <elliott> or maybe you just replace the first two letters of whatever it is with "co" instead. conad
14:52:26 <Hafydd> :)
14:52:28 <Philippa> a sense that "co-" means anything other than "dualised"
14:52:39 <danharaj> Philippa: the co and contravariance of vector is backwards from categorical co- and contra-.
14:52:50 <danharaj> vectors/tensors/etc.
14:54:27 <aranea> dmwit: It still doesn't work: 1 \n 2 \n 3 \n 4 \n *** Exception: thread blocked indefinitely in an MVar operation
14:54:48 <aranea> (predicate is true for 1-4)
14:57:31 <Philippa> danharaj: *nod*. Figures there'd be a few occasions where historical accidents like that happen
14:58:28 <ag90> So, I have this file that is 8,100 bytes. If I use ByteString.hGetSome or IO.hGetBufSome to iterate through it in 90 byte blocks, when reading the last 90 bytes (bytes 8010 to 8100), it takes two reads, one returning 86 bytes and the other returning 4 bytes.
14:59:18 <hpc> > 2 ** 11
14:59:19 <lambdabot>   2048.0
14:59:26 <hpc> > 2 ** 13
14:59:27 <junkb0ndz> how can a type with a fixed range of ints be defined? say all values are in teh range [10..23] etc
14:59:28 <lambdabot>   8192.0
14:59:33 <hpc> hmm
14:59:37 <ag90> hpc: I thought something along those lines
14:59:43 <hpc> seems to not be that though
14:59:47 <ag90> Yeha
14:59:50 <junkb0ndz> i remember way back in pascal one could define types like that
15:00:27 <ag90> I thought hGetBufSome was equivalent to fread.
15:00:35 <Philippa> junkb0ndz: you'd have to do it the hard way, alas
15:00:41 <mightybyte> Can you set the fixity of a function parameter?
15:00:55 <Philippa> (and you'd have to put up with errors at runtime unless you're happy defining how things like addition should work on it or going without them)
15:00:55 <erasmas> is there a straight forward way to catch some IOError e in ErrorT and then throwError e instead? I'm in an ErrorT String IO a stack and want to translate hard errors (like file does not exist) to ErrorT exceptions
15:01:03 <junkb0ndz> Philippa:  how? could you link to or show an example please?
15:01:21 <Philippa> junkb0ndz: data Ranged = Ten | Eleven | ...
15:01:28 <Philippa> alternatively, build a wrapper with a newtype
15:01:36 <Philippa> (then write a Num instance etc)
15:02:05 <ag90> hGetBufSome claims to return whatever is available at the time. So, I'm not 100% sure if this is a bug or expected behaviour. IO.hGetBuf works fine.
15:02:51 <johnw> erasmas: can you lift a catch?
15:03:12 <junkb0ndz> thanks
15:03:49 <erasmas> johnw: I've tried using liftIO a few different ways but can never get the types to work out inside ErrorT
15:04:03 <johnw> can you show me?
15:06:19 <ag90> erasmas: I think you can use Control.Exception.try to catch hard exceptions and get an Either e a.
15:08:17 <hpaste> erasmas pasted “stuck in a monad” at http://hpaste.org/84010
15:08:39 <erasmas> johnw: something like that hpaste link (http://hpaste.org/84010)
15:08:43 <johnw> I think you need liftIO $
15:08:50 <johnw> otherwise, you are only lifting the first argument
15:10:07 <johnw> oh, and I meant to use catch
15:10:10 <johnw> not catchError
15:10:15 <johnw> catchError is specific to the ErrorT monad
15:10:38 <johnw> you want your lifted catch, on error, to return an ErrorT
15:12:57 <erasmas> johnw: sorry, I went through a few iterations and that got a little muddled. so here's a line that does work --
15:13:00 <erasmas> text <- liftIO $ readFile "not a file" `catch` \ (e :: IOException)  -> return "error"
15:13:11 <johnw> you need to return an ErrorT
15:13:12 <erasmas> but instead of returning the error string (resulting in Right "error") I want to throwError
15:13:31 <johnw> like, strMsg "error"
15:13:50 <johnw> ah, then just use throwError
15:14:51 <johnw> text <- liftIO $ readFile "not a file" `catch` throwError
15:15:08 <johnw> hmm
15:15:11 <johnw> no, that won't work
15:15:31 <erasmas> yeah I know it's close, just been staring at it too long and the types still aren't quite right
15:15:40 <johnw> one sec, let me play with this in ghci
15:16:52 * hackagebot pontarius-xmpp 0.2.0.0 - An incomplete implementation of RFC 6120 (XMPP: Core)  http://hackage.haskell.org/package/pontarius-xmpp-0.2.0.0 (JonKristensen)
15:19:13 <danharaj> If anyone wants to gag at the sight of my code, I just pushed my frp stuff to github. I was going to push it with examples but I couldn't get gloss to play nice.
15:19:17 <danharaj> https://github.com/dharaj/fluorine
15:19:31 <Taslem> GHC is not spitting out executables for some of my .hs files. Any idea why?
15:19:50 <danharaj> Taslem: Are they called Main.hs?
15:19:56 <newsham> can I make an array of lists?
15:20:12 <Taslem> danharaj: No
15:20:39 <ag90> erasmas: ErrorT . liftIO . try $ readFile "not a file" might work
15:20:47 <danharaj> newsham: type AraryOfLists i e = Array i [e]
15:20:50 <danharaj> (so yes)
15:20:56 <Taslem> Nevermind, I'm stupid.
15:21:10 <fryguybob> > array (0,1) [(0,[1,2,3]),(1,[42])]
15:21:11 <lambdabot>   array (0,1) [(0,[1,2,3]),(1,[42])]
15:21:27 <johnw> ok
15:21:31 <johnw> erasmas: runErrorT $ either throwError return =<< (liftIO $ ((Right <$> readFile "not a file") `catch` (return . Left)))
15:22:59 <elliott> danharaj: interesting; are there any example programs?
15:24:04 <danharaj> elliott: Only ones that I have that are coupled to my opengl stuff. I tried to make pong et al. earlier this week with gloss but couldn't get it to cooperate.
15:25:01 <erasmas> ag90: thanks, I'll try that
15:25:10 <erasmas> johnw: I still can't get that to work in my complete example but I think that's enough to go on. thank you
15:25:53 <johnw> i'm just wrapping the IO action in an Either, and then converting that to either an ErrorT
15:26:18 <johnw> or rather, I'm turning an IO (Either e a) into an ErrorT e IO a
15:26:20 <ag90> erasmas: I just checked in GHC. It works but I had to specify the exception type in the type signature.
15:26:40 <ag90> runErrorT $ ErrorT . liftIO . (try :: IO a -> IO (Either IOException a)) $ readFile "not a file"
15:26:55 <ag90> Unless the type system can resolve the exception type from the context, you will need to specify it.
15:27:03 <johnw> ah!
15:27:06 <johnw> try does what I was doing manually
15:27:11 <johnw> thanks, I hadn't used that function before
15:27:29 <erasmas> johnw, ag90: ok, thank you both. my real example has gotten over complicated so I need to simplify a few things and I'm sure I can make those ideas work
15:27:43 <newsham>     No instance for (IArray a0 [Double])
15:27:43 <ag90> np
15:28:43 <newsham> ahh, figured it out..
15:32:23 <crdueck> @pl (.|.) (i `shiftL` 6) . fromIntegral &&& id
15:32:23 <lambdabot> ((i `shiftL` 6) .|.) . fromIntegral &&& id
15:32:32 <crdueck> @pl \i -> (.|.) (i `shiftL` 6) . fromIntegral &&& id
15:32:32 <lambdabot> (&&& id) . (. fromIntegral) . (.|.) . (`shiftL` 6)
15:33:20 <johnw> erasmas: let captureIO :: IO a -> ErrorT IOError IO a; captureIO = ErrorT . liftIO . try :: IO a -> ErrorT IOError IO a
15:33:29 <johnw> erasmas: runErrorT $ captureIO $ readFile "foo"
15:33:40 <johnw> that's based on what ag90 wrote
15:33:54 <ag90> Which was based on the tryIO function in the errors library :)
15:34:13 <johnw> ah, sure enough!
15:35:43 <danharaj> elliott: If you know of a nice lightweight library for drawing stuff to the screen I could whip up pong for you.
15:35:46 <erasmas> nice, my goal was get to a point where I could abstract that out into a separate function. I'll look into the errors library too
15:36:00 <johnw> yeah, looks like tryIO is exactly what we wrote
15:36:11 <johnw> but even better because it's abstracted to MonadIO
15:36:22 <johnw> (which I tried to do, but got frustrated with ghci)
15:36:27 <ag90> danharaj: I believe gloss is a library that does just that (the drawing part, not the pong).
15:36:46 <ag90> Though I wouldn't call it lightweight since it depends on OpenGL.
15:36:46 <danharaj> ag90: yeah, gloss can't be used unfortunately.
16:06:53 * hackagebot maxent 0.6.0.1 - Compute Maximum Entropy Distributions  http://hackage.haskell.org/package/maxent-0.6.0.1 (JonathanFischoff)
17:23:27 <kvda> Is there a page the provides the names of symbols used in Haskell? i.e. <=<
17:24:05 <arkeet> such a page could never be exhaustive, since everyone is free to define their own
17:24:15 <arkeet> I don't know of a list of common ones, though.
17:25:13 <kvda> thanks arkeet
17:25:29 <kvda> in that case do you know the name for <=< ?
17:25:37 <zomg> kvda: some names are mentioned on the hackage pages for those
17:27:56 <erasmas> kvda: also you can search for them on hoogle -- http://www.haskell.org/hoogle/?hoogle=%3C=%3C
17:28:21 <kvda> Ah hayoo seems to have found, kiesli composition of monads
17:28:57 <kvda> thanks erasmas, zomg, should've thought of hoogle first. :)
17:29:14 <tippenein> How do I define a very long string over multiple lines
17:29:57 <tippenein> only option is to escape them all?
17:30:36 <DanBurton> I think there is a TH thing for this
17:30:48 <tippenein> n/m escaping doesn't work either
17:32:28 <DanBurton> I swear I've seen a quasiquoter something like [s|your multiline literal string here|] but it is hard to google for
17:33:20 <tippenein> is the "long string/  /over multi lines/" quoting deprecated?
17:33:28 <tippenein> or maybe something to import?
17:33:47 <monochrom> no deprecated
17:33:50 <monochrom> err
17:33:52 <monochrom> not deprecated
17:34:18 <liyang> kvda: <=< is just . in a Kleisli category!
17:34:25 <monochrom> but the quasiquoter is even nicer
17:34:28 <DanBurton> http://hackage.haskell.org/package/Interpolation -- not sure how good this is but there you go
17:35:08 <kvda> liyang, Kiesli category?
17:35:39 <monochrom> also interpolatedstring-perl6, interpolatedstring-qq
17:35:44 <liyang> kvda: like you said, it's Kleisli category composition.
17:35:59 <arkeet> tippenein: you need to put \ both at the end and start of lines
17:36:04 <arkeet> "foo\
17:36:05 <arkeet> \blah"
17:36:08 <monochrom> and string-qq, string-quote
17:36:14 <arkeet> for "fooblah"
17:36:16 <arkeet> I think.
17:36:31 <arkeet> yeah
17:36:42 <monochrom> > "foo\                 \blah"
17:36:44 <lambdabot>   "fooblah"
17:36:53 <tippenein> alright, I got it now
17:36:54 <arkeet> I guess you can put arbitrary whitespace then.
17:37:00 <arkeet> > "foo\   x   \blah"
17:37:02 <lambdabot>   <hint>:1:9:
17:37:02 <lambdabot>      lexical error in string/character literal at character 'x'
17:38:54 <hiptobecubic> Does anyone else get unsolicited emails from google headhunters? Should I treat this email as "broadcasted"?
17:39:41 <ab9rf> i've never gotten unsolicited email from a google headhunter
17:39:44 <tippenein> I get them sometimes. Just recruiters sending out mass emails
17:39:47 <ab9rf> or if i did it was captured by my spam filter
17:39:57 <tippenein> they'll respond if you want to work there
17:40:09 <Nisstyre> ab9rf: wouldn't it be ironic if gmail's spam filter caught it?
17:40:19 <ab9rf> i admit tht i use google's "priority email" functionality and rarely ever read anything that isn't in the priority box
17:40:26 <startling> Nisstyre: like rainiiing
17:40:26 <sproingie> i'd call it a gray area.  they are targeting the right people, at least i imagine so
17:40:44 <sproingie> if all my spam were legitimate recruiter interest, i'd be happy with that
17:40:46 <ab9rf> it's unlikely that google would wnt me
17:40:54 <hiptobecubic> sproingie, i wish.
17:41:17 <arkeet> I thought I was in -blah for a moment there.
17:41:18 <ab9rf> i'm in systems & network administration for the small business vertical, not an area google has much need for
17:41:37 <Nisstyre> all of my spam are those stupid "OMG let me give you 4 trillion trillion dollars with this legitimate business transaction!!"  emails
17:41:38 <monochrom> sometimes you think you're in a math channel
17:41:50 <ab9rf> monochrom: you mean this isn't a math channel?
17:41:51 <sproingie> if they crawled rec.hobbies.needlepoint and sent recruitment to them, that'd be spam
17:42:25 <ab9rf> sproingie: most of my spam lately has had to do with finding people for slutty dates
17:42:31 <hiptobecubic> Well I guess I'll email them back and tell them i'm unemployed and eating peanutbutter sandwiches every day for dinner.  For now back to this miserable C++  :(.  It's amazing how much fun haskell can be and how little fun some other languages are.
17:42:40 <sproingie> (that or they're looking for someone to make google doodles for the granny set)
17:42:48 <hiptobecubic> i would love that job
17:43:09 <ab9rf> hiptobecubic: finding people for slutty dates?
17:43:33 <ab9rf> hiptobecubic: peanut butter is expensive, you should cut back
17:43:36 <hiptobecubic> honestly, right now I don't care as long as it isn't in a grocery store or mail truck.
17:44:43 <ab9rf> sproingie: one of my little silly things is coming up with algorithms to make needlepoint patterns out of arbitrary images
17:44:55 <ab9rf> sproingie: it's not easy as it seems on first blush
17:45:00 <sproingie> i bet
17:45:16 <ab9rf> you can do a fairly naive effort by simply downscaling the image
17:45:20 <ab9rf> but you lose a lot of detail
17:45:55 <ab9rf> doing edge detection and using quarterstiches and outline stitches to enhance contrast goes a long way, but algorithmizing that is difficult
17:46:02 <sproingie> mipmap decimation algorithms might be handy there
17:46:15 <sproingie> photoshop has pretty good ones i'm told
17:46:29 <Philippa> do you get anything useful by running a high-pass filter over the image, if downscaling works?
17:46:43 <ab9rf> i haven't really looked at this in at least a decade
17:46:51 <ab9rf> for all i know it's a solved problem now :)
17:47:59 <Philippa> oh, wait, wrong direction
17:48:41 <sproingie> it's a similar story with textures, trying to keep detail in the mipmaps.  usually the pro shops fiddle with the source image to avoid the worst artifacts, then tweak the mipmaps if they absolutely have to
17:51:49 <startling> what's the syntax for two forall'd variables, again?
17:52:58 <ClaudiusMaximus> f :: forall a b . (A a, B b) => a -> b   -- i think, not tested..
17:55:23 <startling> ClaudiusMaximus: ah, thanks
18:11:26 <meditans> Hi, is there a way to print the Right side of an Either, without pattern matching it? Eg with a sort of fmap?
18:11:57 <jfischoff> > :t either
18:11:59 <lambdabot>   <hint>:1:1: parse error on input `:'
18:12:07 <jfischoff> @type either
18:12:09 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
18:12:44 <meditans> yes, you're right, I forgot :$.. thanks!!
18:12:56 <jfischoff> np
18:13:10 <jfischoff> or
18:13:19 <jfischoff> just use fmap
18:13:28 <meditans> :jfischoff how?
18:14:00 <meditans> there are two different monads.. Either and IO, I don't manage to write the code
18:14:30 <jfischoff> > show <$> Right 1
18:14:31 <lambdabot>   Right "1"
18:15:03 <jfischoff> @hpaste
18:15:03 <lambdabot> Haskell pastebin: http://hpaste.org/
18:15:16 <jfischoff> ^ you could put an example here
18:16:04 <meditans> I will at some point, but for now either works just fine.. thanks
18:16:10 <jfischoff> cool
18:17:44 <tac> Does anyone know, using the GHC module, how to take a binding in a module and evaluate it into an HValue or Dynamic?
18:18:21 <hpaste> meditans pasted “simplicity” at http://hpaste.org/84014
18:18:39 <meditans> ok let's try, I am too curious
18:19:01 <meditans> how could I make better this code?
18:19:48 <meditans> take for granted the formatAnswer . map solve part
18:21:39 <jfischoff> you could this  readFile . head =<< getArgs
18:21:53 <jfischoff> do that instead
18:23:00 <meditans> ah, thanks, this simplifies the first line! Any hint on the others?
18:23:20 <hpaste> “Jonathan Fischoff” revised “simplicity”: “slightly better” at http://hpaste.org/84014
18:26:01 <jfischoff> small improvement there, I think it looks pretty good
18:27:08 <meditans> yes, i saw the second line, also. Much better... would there be any way to eliminate the reference to "a"?
18:27:49 <jfischoff> not without making the line longer
18:27:58 <jfischoff> its already pretty long
18:28:06 <jfischoff> someone else might think of something
18:28:21 <meditans> ok, but just for fun, I should do it with another <$>
18:28:23 <meditans> right?
18:28:41 <jfischoff> I think what you is good
18:28:51 <jfischoff> I don't know personal preference
18:29:51 <chrisirc> Is there a way to inspect the field names in a record?
18:29:59 <meditans> ok, as a general question, where can I learn to do this kind of transformations? Is there a reference?
18:30:13 <chrisirc> (Just list the fields that are set)
18:30:45 <jfischoff> meditans: here or codereview.stackexchange.com works
18:31:15 <meditans> jfischoff: ok, thanks, i will post here more code in the future
18:31:19 <jfischoff> christic: generically get the field names of record?
18:31:23 <jfischoff> cool
18:31:32 <jfischoff> you can only ask question here
18:31:41 <jfischoff> s/only/always
18:40:04 <chrisirc> I've got a tree of various kinds of nodes (Text.HTML.TagSoup actually), and a predicate for nodes. What function do I use to get a list of matches from a search over the tree?
18:41:21 <chrisirc> Seems like something generic enough to warrant a standard function (or 'generic', whatever those are called in Haskell again?).
18:41:27 <hpaste> meditans pasted “simplicity #2” at http://hpaste.org/84016
18:41:56 <meditans> a followup of my rewriting exercises
18:45:02 <Rarrikins_l> chrisirc: With lists, it's called filter.
18:45:14 <BrianHV> chrisirc: I've never used it myself, but I think I've heard of uniplate being suggested for situations like that
18:46:42 <chrisirc> Thanks for the tip BrianHV. Rarrikins_l sure, but then the recursion is missing.
18:47:05 <tac> Trying to dynamically load Haskell code is a fucking PITA
18:47:08 <Sgeo> There's still recursion, it's just implicit
18:47:14 <Sgeo> Erm, done by the filter
18:47:25 <tac> Is there anything more sensible than using the GHC module?
18:47:43 <ion> @hackage plugins or something like that
18:47:43 <lambdabot> http://hackage.haskell.org/package/plugins or something like that
18:48:15 <tac> I was told that plugins should be considered deprecated by someone here a while back
18:48:20 <tac> is that true?
18:48:55 <ion> Dunno, perhaps. Did they say what replaced it?
18:49:08 <arkeet> @hackage hint
18:49:08 <lambdabot> http://hackage.haskell.org/package/hint
18:49:29 <arkeet> do you mean this? ^
18:49:30 <chrisirc> Well, hm, I guess what you were after is pointing out that a list is a tree; but then how does that help me further, esp. since filter only recurses one of the leaf pairs in each level (and using a datastructure that only allows two leafs in each node)?
18:57:39 <hpaste> meditans revised “simplicity #2”: “simplicity #2” at http://hpaste.org/84016
18:57:45 <meditans> any idea on how could I simplify this code?
19:03:01 <BrianHV> meditans: one possibility: formatAnswers xs = unlines $ map formatted $ zip [1..] xs where formatted (n, (a, b)) = "Case #" ++ show n ++ ": " ++ show a ++ " " ++ show b
19:03:21 <BrianHV> meditans: hlint suggests an additional possibility if you use that
19:05:44 <meditans> BrianHV: How have you obtained that suggestion from hlint? If I write hlint file it says "no suggestions"
19:05:58 <meditans> BrianHV: Yes, your version is much better
19:06:04 <BrianHV> maybe I have a different version of hlint...
19:06:16 <BrianHV> formatAnswers xs = unlines $ zipWith formatted [1..] xs where formatted n (a, b) = "Case #" ++ show n ++ ": " ++ show a ++ " " ++ show b
19:06:26 <meditans> i just did a cabal install hlint
19:06:30 <meditans> and it's the same
19:07:11 <meditans> BrianHV: this last version is better
19:09:25 <meditans> BrianHV: my version of hlint is 1.8.24 could you tell me yours, please?
19:09:31 <BrianHV> 1.8.31
19:25:17 <dmwit> ?tell aranea Indeed, as I warned you, getChanContents will never end the list. It's easy to fix, but a bit tedious -- send a sentinel when all the threads are done.
19:25:17 <lambdabot> Consider it noted.
19:43:26 <Nomad> Guys, is it difficult to make a Burrito Monad?
19:43:51 <Nomad> If not, where do I start?
19:44:22 <Ralith> with a good flour tortilla and plenty of salsa
19:44:45 <Nomad> can salsa and tortilla be identity data types?
19:45:02 <Nomad> identity monads*
19:45:05 <Ralith> that depends how much spicy they are.
19:45:19 <augur> do (tortilla, beans, salsa) <- ingredients ; return $ join tortilla $ join beans salsa
19:45:42 <Nomad> interesting
19:45:55 <latro`a> what monad is that supposed to be in
19:46:10 <augur> the MexicanFood monad
19:46:25 <latro`a> what are its semantics
19:46:26 <startling> augur: you mix the beans and salsa beforehand? wtf
19:46:41 <augur> startling: nah, just join. mix as you please!
19:46:42 <latro`a> also, you returned a join
19:46:50 <latro`a> double nested
19:46:51 <latro`a> why
19:47:12 <Nomad> *scratches head*
19:47:16 <augur> latro`a: well it'd be silly to wrap the salsa in the tortilla and put the beans on afterwards!
19:47:33 <latro`a> er
19:47:34 <latro`a> wot
19:47:48 <tac> @hoogle unsafePerformIO
19:47:49 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
19:47:49 <lambdabot> Foreign unsafePerformIO :: IO a -> a
19:47:51 <latro`a> (join tortilla $ join beans salsa) :: m a
19:48:08 <latro`a> (return $ join tortilla $ join beans salsa) :: m (m a)
19:48:22 <augur> stop overthinking things.
19:48:23 <latro`a> unless perhaps this is actually in IO, in which case that's interesting
19:48:30 <latro`a> IO (Burrito a)
19:49:38 <Nomad> >.> I don't know what questions to ask, i'm mixed between "how do I use this burrito", and "what does this all mean"
19:49:39 <Nomad> >.>
19:50:29 <Ralith> normally you pick it up with your hands and eat it
19:50:42 <Ralith> some people prefer to use knives and forks though, especially for larger, more complex burritos
19:50:47 <Nomad> But you can't eat it, that would modify its state
19:50:48 <luite> Ralith: hose are just the operational semantics
19:51:13 <Nomad> at best I can unwrap it
19:51:18 <Nomad> but then itll no longer be a burrito
19:51:23 <Nomad> How do I have my burrito and eat it too?
19:51:26 <Nomad> >.>
19:52:25 <Nomad> I mean even if I unwrap it, itll always be a tortilla, but that's the best part
19:52:55 <arkeet> unsafeUnwrapBurrito
19:52:55 <amindfv> unsafeUnwrap
19:53:07 <amindfv> jynx
19:53:08 <Nomad> hmm
19:53:16 <Nomad> interesting
19:53:36 <arkeet> you can eat it as long as you wrap the result in a new burrito
19:53:43 <amindfv> Nomad: I think actually the tortilla is the part you'd lose
19:54:00 <Nomad> But isn't everything wrapped in the tortilla?
19:54:11 <Nomad> I'd think i'd lose everything but tortilla by unwrapping it
19:54:18 <Nomad> but without a tortilla, it'll lose its identity
19:54:38 <Nomad> which would be illegal
19:55:40 <amindfv> i thought the analogy was the tortilla is the context, and the filling is the data/food in a context
19:56:22 <hiptobecubic> Wrote some tests to compare two supposedly equivalent functions. Consistently failed them all. Two hours later I realize that I'm using *different* random input and then comparing the output. :-|
19:57:15 <Nomad> I wanted to write a function which takes two (Num -> Num) functions and checks if they are identical for a particular Num
19:57:43 <Nomad> funcmp :: (Num a) => (a -> a) -> (a -> a) -> a -> a
19:57:44 <Nomad> I think
19:57:50 <Nomad> I didnt bother doing it yet :\
19:57:59 <Nomad> the compiler will yell at me
20:04:28 <hiptobecubic> @pl \f g n -> f n == g n
20:04:28 <lambdabot> liftM2 (==)
20:05:14 <hiptobecubic> > (==) <$> f <*> g <*> x
20:05:16 <lambdabot>   Couldn't match expected type `a0 -> b0'
20:05:16 <lambdabot>              with actual type `GHC....
20:05:20 <hiptobecubic> errr
20:05:24 <Nomad> ugh
20:05:27 <Nomad> I got this so far
20:05:32 <Nomad> funcmp :: (Int -> Int) -> (Int -> Int) -> Int -> Bool
20:05:42 <Nomad> funcmp f g n = ((f n) == (g n))
20:05:56 <arkeet> funcmp = liftA2 (==)
20:05:58 <Nomad> I dont know if its right, and each time i try to output a test, it doesnt work
20:06:03 <arkeet> but should work.
20:06:15 <arkeet> also all of those parenthese are unnecessary.
20:06:40 <Nomad> I overparanthesize before it works, then slowly remove them
20:06:43 <arkeet> :p
20:07:40 <Nomad> Also ak, I am trying to check f n to be equal to g n
20:07:44 <Nomad> not to check if the functions are equal
20:07:58 <Nomad> or whatever you category theorists call functions
20:07:58 <arkeet> indeed.
20:08:05 <arkeet> no, they're functions.
20:08:10 <Nomad> excellent.
20:08:40 <Nomad> so should `funcmp f g n = ((f n) == (g n)) ` work?
20:08:44 <arkeet> yes
20:08:46 <Nomad> because I have no idea how to test it
20:08:55 <arkeet> @type let funcmp f g n = ((f n) == (g n)) in funcmp
20:08:56 <lambdabot> Eq a => (t -> a) -> (t -> a) -> t -> Bool
20:08:58 <Nomad> I ended up doing silly things like (putStrLn . show . (((funcmp a) b) 2))
20:09:07 <Nomad> Int is eq
20:09:18 <Nomad> but yeah your answer is more generic
20:09:28 <arkeet> well, funcmp a b 2 is a Bool.
20:09:33 <arkeet> it doesn't make sense to compose functions with a Bool
20:09:46 <Nomad> Bool is return whether or not they are equal
20:09:49 <Nomad> :\
20:09:56 <arkeet> Bool is a type.
20:10:03 <arkeet> but it's not a type you can give to .
20:10:09 <arkeet> because . is for composing functions
20:10:23 <Nomad> I am not sure what you are referring to
20:10:29 <Nomad> I never composed anything with Bool
20:10:30 <Nomad> :\
20:10:32 <arkeet> putStrLn . show . True
20:10:35 <arkeet> it's like you wrote that.
20:10:36 <Nomad> yeah
20:10:41 <arkeet> . is function composition
20:10:43 <arkeet> True is not a function.
20:10:47 <Nomad> i did something more silly
20:10:48 <Nomad> main = (putStrLn . show . (((funcmp a) b) 2))
20:10:56 <arkeet> same problem
20:11:04 <hiptobecubic> > (==) <$> (+ 1) <*> succ $ 3
20:11:06 <lambdabot>   can't find file: L.hs
20:11:06 <arkeet> (((funcmp a) b) 2) is a Bool, like True.
20:11:07 <Nomad> Bool is not instance of show?
20:11:19 <copumpkin> > show True
20:11:21 <lambdabot>   "True"
20:11:28 <Nomad> so what's the problem :|
20:11:34 <BrianHV> > show . True
20:11:36 <lambdabot>   Couldn't match expected type `f0 a0'
20:11:36 <lambdabot>              with actual type `GHC.Typ...
20:11:38 <Nomad> I just want to compare whether 2 == 2 and show it
20:11:41 <hiptobecubic> > (==) <$> (+ 1) <*> succ $ 3
20:11:43 <lambdabot>   True
20:11:44 <Nomad> except by 2 i mean (a 2)
20:11:50 <Nomad> and second 2 to be (b 2)
20:11:53 <hiptobecubic> > (==) <$> (+ 1) <*> succ $ x
20:11:55 <lambdabot>   False
20:12:02 <arkeet> Nomad: then you want to apply show to it
20:12:04 <arkeet> not compose
20:12:12 <arkeet> show x, not show . x
20:12:19 <Nomad> hmm
20:12:43 <Nomad> nope still nothing
20:12:43 <Nomad> main = (putStrLn . show (((funcmp a) b) 2))
20:13:07 <arkeet> well yeah, now you're composing putStrLn with a string.
20:13:23 <Nomad> I mean I tried main = (putStrLn . show . funcmp) (a b 2)
20:13:28 <Nomad> :\
20:13:28 <arkeet> putStrLn (show (funcmp a b 2)). or maybe (putStrLn . show . funcmp a b) 2
20:13:40 <arkeet> or putStrLn . show $ funcmp a b 2
20:13:41 <arkeet> any of those
20:14:15 <Nomad> ugh
20:14:16 <Nomad> main = (putStrLn . show (funcmp a b 2))
20:14:17 <Nomad> :\
20:14:28 <Nomad> doesnt work
20:14:55 <hiptobecubic> > (==) <$> f <*> g $ x   -- How can one disambiguate this?
20:14:57 <lambdabot>   Ambiguous type variable `a0' in the constraints:
20:14:57 <lambdabot>    (GHC.Classes.Eq a0)
20:14:57 <lambdabot>    ...
20:16:13 <arkeet> again, that won't work.
20:16:18 <arkeet> look at types.
20:16:43 <arkeet> Nomad: show (funcmp a b 2) is a String.
20:16:50 <arkeet> :t (Prelude..)
20:16:52 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:16:56 <arkeet> String is not a -> b
20:17:33 <arkeet> you could apply putStrLn to show (funcmp a b 2)
20:17:41 <arkeet> i.e. putStrLn (show (funcmp a b 2))
20:17:45 <arkeet> or you could compose putStrLn with show
20:17:47 <arkeet> :t putStrLn . show
20:17:49 <lambdabot> Show a => a -> IO ()
20:17:51 <Nomad> but isnt . and () the same?
20:17:54 <arkeet> no
20:17:56 <arkeet> very not
20:18:11 <arkeet> . is function *composition*, not application.
20:18:17 <arkeet> f $ x = f x
20:18:21 <arkeet> (f . g) x = f (g x)
20:19:23 <Nomad> oh, so even if I compose it, I need brackets for calling it?
20:19:43 <Nomad> but yeah it works now
20:20:12 <hiptobecubic> Nomad, no. You need the types to be compatible. brackets are not required for application
20:20:27 <arkeet> Nomad: f . g x is f . (g x), not (f . g) x
20:21:23 <Nomad> hmm
20:22:23 <Nomad> so something like `main = (putStrLn . show) (funcmp a b 2)`
20:22:50 <Nomad> im curious why main = (putStrLn . show . funcmp) (a b 2) is ellegal
20:22:52 <Nomad> illegal*
20:23:24 <BrianHV> a isn't a function that takes two arguments
20:23:37 <fluffynukeit> hi.  I'd like to render a HTML page in a single window (don't need full browser).  I plan for this to be the interface to my Haskell app using snap and ji.  Needs to work on Win7.  What are my options?  Do I need to write FFI calls to QWebView or chromium embedded framework or something?  Looking for suggestion.  Thanks much.
20:24:49 <arkeet> Nomad: (f . g) x y is f (g x) y, not f (g x y)
20:25:04 <arkeet> and f (g x) y is (f (g x)) y
20:25:51 <Nomad> interesting
20:26:20 <BrianHV> btw, putStrLn . show == print. so you could do main = print $ funcmp a b 2
20:26:39 <fluffynukeit> any ideas on a GUI widget that can connect and render an HTML page?
20:27:46 <arkeet> yes, I should have mentioned print.
20:27:57 <arkeet> it's still good to know why what works works and what doesn't work doesn't.
20:28:01 <BrianHV> agreed
20:28:41 <Nomad> alright I figured it out, I even made a nice filter "[x | x <- [0..100], funcmp a b x]" :) it gave me 6 for a x = 2*x+3 b x = x+9
20:29:06 <BrianHV> Nomad: you're going to love quickcheck.
20:29:19 <Nomad> oh?
20:30:04 <BrianHV> you give quickcheck properties such as "these two functions should be the same" and it throws random data at your code to make sure those properties hold
20:30:44 <arkeet> btw, funcmp = liftA2 (==)
20:30:45 <Nomad> :) beats writing huge from 0 to 2^32 - 1 in C
20:30:55 <Nomad> huge loops*
20:32:45 <Nomad> I love haskell, I don't love ghc yelling at me, and I don't love hard-to-build libraries like... every gui library
20:33:07 <arkeet> btw
20:33:18 <arkeet> hiptobecubic: (==) on Expr doesn't do what I think you wanted it to do.
20:33:26 <arkeet> it compares to Exprs for syntactic equality.
20:33:29 <arkeet> > x == y
20:33:30 <lambdabot>   False
20:33:39 <arkeet> compares two*
20:33:40 <Nomad> 2>1
20:33:59 <Nomad> why lambda bot no answer?
20:34:13 <Nomad> > 2>1
20:34:14 <lambdabot>   True
20:34:16 <Nomad> :)
20:34:25 <Nomad> >2==9
20:34:31 <Nomad> > 2==9
20:34:33 <lambdabot>   False
20:34:41 <Nomad> pfft, everyone knows 2==9 is true
20:34:43 <BrianHV> arkeet: can you describe the inuition that allowed you to notice that it was liftA2 (==)? I just convinced myself that you're right, but I don't know how you got there
20:34:51 <BrianHV> intuition*
20:35:55 <Nomad> > [x|x<-[0..100], x*9/3+4 == 6]
20:35:56 <lambdabot>   []
20:36:03 <Mathnerd314_> > let 1 = 2 in 2 == 1
20:36:04 <lambdabot>   False
20:36:28 <Mathnerd314_> > let fromInteger 1 = 2 in 2 == 1
20:36:28 <arkeet> BrianHV: well, it's more like I already knew.
20:36:30 <lambdabot>   False
20:36:30 <Nomad> > nothing = ()
20:36:32 <lambdabot>   <hint>:1:9: parse error on input `='
20:36:39 <BrianHV> arkeet: fair answer :)
20:36:39 <Nomad> > n = ()
20:36:40 <arkeet> BrianHV: you look at the function instance for Applicative and there it is.
20:36:41 <lambdabot>   <hint>:1:3: parse error on input `='
20:36:59 * hackagebot monad-par 0.3.4.1 - A library for parallel programming based on a monad  http://hackage.haskell.org/package/monad-par-0.3.4.1 (SimonMarlow)
20:37:05 <arkeet> :t liftA2
20:37:06 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
20:37:13 <arkeet> now put (t -> ) for f
20:37:29 <hiptobecubic> arkeet, oh. I just wanted it to look nice.
20:37:32 <Nomad> > factorial 0 = 1
20:37:33 <lambdabot>   <hint>:1:13: parse error on input `='
20:37:35 <BrianHV> yeah... I just haven't reached the point where I can do that in my head
20:37:45 <Mathnerd314_> hmm, fromInteger 1 = 2 with rebindablesyntax is an infinite loop...
20:37:52 <BrianHV> well, maybe now that I've done it on paper I can
20:38:19 <Nomad> > [x | x <- [0..1000], x + 2 == 90 && x +4 == 92]
20:38:21 <lambdabot>   [88]
20:38:30 <Nomad> :') it's beautiful
20:39:18 <Nomad> I wish Calculus exams had lambda bots
20:39:57 <Mathnerd314_> Nomad: it's called a TI-xx
20:40:07 <Nomad> > (pi**pi)**3 == (pi)**(pi**3)
20:40:09 <lambdabot>   False
20:40:15 <Nomad> :') it's beautiful
20:41:03 <Nomad> > ln(2 + 3) == ln(2) + ln(3)
20:41:04 <lambdabot>   Not in scope: `ln'
20:41:04 <lambdabot>  Perhaps you meant one of these:
20:41:04 <lambdabot>    `n' (imported from D...
20:41:13 <Hermit> Nomad: if they let you have a phone for a calculator, then perhaps you could have ghci
20:41:28 <Nomad> yeah but they dont let me use any technology
20:41:32 <Nomad> have to memorize everything =[
20:41:37 <Hermit> =/
20:41:38 <Nomad> and do all the side effects and all
20:41:45 <Nomad> Calculus is so imperative
20:41:46 <Nomad> :(
20:41:52 <Hermit> damned study by rote
20:42:18 <Hermit> something that would totally kick ass is a J calculator
20:42:34 <arkeet> > pi ** 4 == pi ^ 4
20:42:35 <lambdabot>   False
20:42:51 <arkeet> > pi ** 4 - pi ^ 4
20:42:53 <lambdabot>   -1.4210854715202004e-14
20:44:19 <arkeet> btw.
20:44:21 <arkeet> if you like calculus
20:44:32 <Nomad> > [x | x<- map (/pi)([0..4]), sin(x)==1]
20:44:33 <lambdabot>   []
20:44:36 <arkeet> > diff (\x -> cos x + 3*x^2) x
20:44:37 <Nomad> > [x | x<- map (/pi)([0..40]), sin(x)==1]
20:44:37 <lambdabot>   negate (sin x) * 1 + (x * 1 + 1 * x) * 3
20:44:38 <lambdabot>   []
20:44:44 <Nomad> > [x | x<- map (/pi)([0..409]), sin(x)==1]
20:44:46 <lambdabot>   []
20:44:48 <Nomad> ugh
20:44:53 <Hermit> :t diff
20:44:54 <lambdabot> Num a => (forall (s :: * -> *). Numeric.AD.Types.Mode s => AD s a -> AD s a) -> a -> a
20:45:14 <arkeet> Nomad: you should know that floating point calculations are not exact.
20:45:23 <Nomad> what would be a nice lambda to find all sines on [0, 6pi] where sin(x) = 1
20:45:30 <Nomad> all x* of sine
20:45:44 <arkeet> you can do that, but never compare two floats for equality
20:46:03 <Hermit> Nomad: what interval?
20:46:08 <Nomad> [0, 6pi]
20:46:13 <Hermit> step?
20:46:32 <Nomad> do by (1/360)pi
20:47:28 <Nomad> I mean I know the unit circle, but it would be a powerful testing tool
20:47:33 <Nomad> is*
20:47:36 <Hermit> > map sin [0,pi/360..6*pi]
20:47:38 <lambdabot>   [0.0,8.726535498373935e-3,1.745240643728351e-2,2.6176948307873153e-2,3.4899...
20:47:43 <Nomad> floating :P
20:47:50 <arkeet> > sin pi
20:47:52 <lambdabot>   1.2246467991473532e-16
20:48:02 <arkeet> > sin (pi/2)
20:48:04 <lambdabot>   1.0
20:48:07 <Nomad> > floor 2.2
20:48:08 <arkeet> > sin (5*pi/2)
20:48:09 <lambdabot>   2
20:48:10 <lambdabot>   1.0
20:48:12 <arkeet> hm
20:48:16 <Nomad> > floor sin pi
20:48:18 <lambdabot>   No instance for (GHC.Real.RealFrac (a0 -> a0))
20:48:18 <lambdabot>    arising from a use of `GH...
20:48:35 <arkeet> note that thats (floor sin) pi
20:48:37 <arkeet> which makes no sense.
20:48:44 <Nomad> > floor sin . pi
20:48:46 <lambdabot>   No instance for (GHC.Real.RealFrac (a0 -> a0))
20:48:46 <lambdabot>    arising from a use of `GH...
20:48:53 <Nomad> > floor $ sin  pi
20:48:55 <lambdabot>   0
20:49:03 <arkeet> you should learn how types work instead of throwing in random punctuation until it typechecks
20:49:04 <arkeet> :p
20:49:09 <Nomad> ::)
20:49:26 <Nomad> I understand more or less how types work, I just do silly mistakes at times
20:49:54 <Nomad> At least theory, the rest ill learn by just googling the stuff ghc yells at me
20:49:59 <Nomad> which is oddly educationally valuable
20:50:09 <Nomad> unlike googling STL errors
20:50:33 <Nomad> I gave up on C++, C is cleaner :|
20:51:46 <tac> > Just (+) <$> Just 1 <*> Just 2
20:51:47 <lambdabot>   Couldn't match expected type `a1 -> a0 -> b0'
20:51:48 <lambdabot>              with actual type...
20:51:50 <arkeet> I feel like these are not merely silly mistakes. in any case, it'll get better with experience :p
20:51:55 <tac> > Just (+) <*> Just 1 <*> Just 2
20:51:56 <arkeet> > Just (+) <*> Just 1 <*> Just 2
20:51:57 <lambdabot>   Just 3
20:51:57 <Nomad> yep
20:51:58 <lambdabot>   Just 3
20:52:07 <tac> > Just (+) <*> Just 1 <*> Nothing
20:52:08 <lambdabot>   Nothing
20:52:24 <Nomad> Nothing is better than learning from things blowing up
20:52:39 <Nomad> unless your computer blows up
20:52:53 <Nomad> but luckily haskell has no side effects, other than launching missiles and making your computer hot
20:53:55 <shanse> > (+) <$> Just 1 <*> Nothing
20:53:56 <lambdabot>   Nothing
20:54:02 <BMeph> "Haskell has no side effects" /= "Haskell has no effects"
20:55:50 <tac> :t (+1) <$> fromDynamic undefined
20:55:51 <lambdabot> (Num b, Typeable b) => Maybe b
20:56:05 <tac> :t (+1) <$> fromDynamic undefined <*> fromDynamic undefined
20:56:07 <lambdabot> (Num (a -> b), Typeable a, Typeable b) => Maybe b
20:57:12 <tac> :t sum <$> fromDynamic undefined
20:57:14 <lambdabot> (Num b, Typeable b) => Maybe b
20:57:25 <Nomad> > [0]++[1]++[2]++[3]++[4..9]++[2]
20:57:27 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,2]
20:57:40 <Nomad> > [0]:[2]
20:57:41 <lambdabot>   No instance for (GHC.Num.Num [t0])
20:57:41 <lambdabot>    arising from a use of `e_102'
20:57:41 <lambdabot>  Possib...
20:57:57 <Nomad> > "a":"b"
20:57:59 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
20:57:59 <lambdabot>              with actual ty...
20:58:22 <Nomad> "a":'a'
20:58:26 <Nomad> > "a":'a'
20:58:28 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
20:58:28 <lambdabot>              with actual ...
20:58:33 <Nomad> > 'a':"a"
20:58:35 <lambdabot>   "aa"
20:58:37 <Nomad> :)
20:59:13 <Nomad> > putStrLn "I am lambda bot,  no Monads for you."
20:59:15 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
20:59:15 <lambdabot>    arising from a use of ...
20:59:20 <Nomad> :(
21:00:09 <arkeet> btw
21:00:12 <Nomad> btw, if I do `a <- putStrLn "HIES" ` what does a become?
21:00:14 <arkeet> you can use lambdabot in private.
21:00:19 <arkeet> :t putStrLn
21:00:21 <lambdabot> String -> IO ()
21:00:24 <arkeet> a will be ()
21:00:28 <Nomad> oh
21:00:58 <Nomad> () == ""/= Nothing?
21:01:09 <Nomad> > () == "" /= Nothing
21:01:11 <lambdabot>   Precedence parsing error
21:01:11 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
21:01:30 <Nomad> > () == ""
21:01:31 <lambdabot>   Couldn't match expected type `()'
21:01:31 <lambdabot>              with actual type `[GHC.Types...
21:01:38 <elliott> () and "" and Nothing are all distinct values. indeed they all have different types
21:01:43 <elliott> (so they could not possibly be equal)
21:01:55 <sellout-> Nomad: Don't you have a ghci of your own to play in?
21:02:17 <Nomad> I have it open now but I am terrible at multitasking
21:02:29 <Nomad> trying to focus on the chat at the same time
21:03:29 <Nomad> I dont think lambda bot is ghci
21:03:43 <Nomad> ghci is more powerful
21:04:11 <arkeet> it's also less spammy
21:04:27 <simpson> > [1..]
21:04:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
21:05:00 <Nomad> map (*2) l1..]
21:05:08 <Nomad> > map (*2) l1..]
21:05:10 <lambdabot>   <hint>:1:12: parse error on input `..'
21:05:20 <Nomad> > map (*2) [1..]
21:05:22 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
21:05:34 <Nomad> havent really used maps before i started haskell
21:05:42 <Nomad> but now i prefer them in perl over foreach loops
21:05:45 <Nomad> :O
21:06:20 <DanBurton> > iterate (*2) 1
21:06:22 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
21:06:58 <DanBurton> > 1 : iterate (+2) 2
21:06:59 <lambdabot>   [1,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
21:07:43 <latro`a> > fix $ \xs -> 1 : map (*2) xs
21:07:45 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
21:09:42 <arkeet> > fix $ (0:) . scanl (+) 1
21:09:44 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
21:10:23 <Nomad> I once tried doing `map (*(-1))[1..]) ++ [0] ++ [1..]`, got me nowhere
21:12:15 <hpaste> bardem pasted “fib State” at http://hpaste.org/84022
21:12:17 <bardem> can someone please llook at ^^^^? Its fibanocci using state monad. Just not sure how to write the last few lines
21:13:08 <arkeet> bardem: you could repeat fib a number of times.
21:13:09 <arkeet> :t replicateM_
21:13:11 <lambdabot> Monad m => Int -> m a -> m ()
21:13:20 <arkeet> bardem: however, that approach will never be able to produce an infinite list of fibs
21:13:56 <arkeet> bardem: not to mention, it'll be very slow; accessing the end of a list is very slow (remember it's a linked list)
21:19:05 <ab9rf> yeah, generally speaking anything that uses ++ is going to be slow in a recursive case
21:20:10 <Nomad> yeah ++ is not lazy right?
21:20:15 <danharaj> ++ is lazy
21:20:23 <ab9rf> it's lazy
21:20:29 <ab9rf> but you still have to get to the end of its left argument
21:20:38 <Nomad> idk i heard : is better than ++
21:20:59 <ab9rf> that's because : doesn't have to move to the end of its left argument
21:21:21 <ab9rf> [1,2,3]:[4] is [[1,2,3],4], not [1,2,3,4]
21:22:12 <Nomad> i told my linear algebra professor that I wanted to study category theory so I could understand haskell better, he seemed intrigued or confused, or both
21:22:20 <ab9rf> heh
21:22:27 <arkeet> I think that's backwards.
21:22:32 <ab9rf> i know nothing about category theory.  maybe should do something about that.
21:22:33 <Nomad> he never heard of functional programming
21:22:41 <arkeet> you kind of need some examples of categories before looking at category theory.
21:22:44 <Nomad> he was interested in the idea
21:22:56 <ab9rf> i assume it has something to do with categories
21:23:07 <ab9rf> but i have no idea what a mathematician means by a 'category'
21:23:13 <Nomad> even if it doesnt, when I study haskell, my will to study mathematics increases
21:23:24 <Nomad> and it feels like all concepts get integrated together
21:23:28 <ab9rf> i do know that mathematicians often imbue ordinary terms with meanings that a nonmathematician would not expect
21:23:58 <ab9rf> instead of making up nonsense words for their sui generis concepts :)
21:24:25 <Nomad> yeah category theory was generally known as "abstract nonsense" for a long time until modern times
21:24:33 <arkeet> it still is.
21:24:40 <arkeet> but not in a derogatory way.
21:24:41 <ab9rf> i was going to stay
21:24:42 <ab9rf> say
21:24:43 <arkeet> anyway
21:24:48 <Nomad> yeah but now it's "practical abstract nonsense"
21:24:51 <Nomad> :)
21:24:58 <arkeet> hardly anyone actually does pure category theory
21:25:01 <ab9rf> arkeet: the algebraists i know take pride in their mathematics being abstract nonsense
21:25:12 <Nomad> i mean lets be honest here, all programming is "abstract nonsense"
21:25:17 <danharaj> Derived functorial horseshit.
21:25:18 <ab9rf> and are vaguely offended when someone finds a practical use for any of it
21:25:31 <ab9rf> they are still very mad at the quantum theorists
21:25:59 <Nomad> Idk, i feel that just thinking of things differently is enough to make a huge difference
21:26:09 <Nomad> even if the way you think of it is nonsense to begin with
21:26:37 <ab9rf> Nomad: well, that's why i encourae people to learn haskell
21:26:57 <Nomad> yeah, I believe people should be able to think in haskell, it has huge benefits
21:27:03 <ab9rf> even if they never get good at it at least they'll have been exposed to a different way of writing software and thinking about computation
21:27:11 <Nomad> on the other side I think people should also be able to think in Perl
21:27:20 <Clint> and swedish
21:27:26 <Nomad> no not swedish thats silly
21:27:37 <ab9rf> Clint: i'm not sure perl is distinguishable from swedish
21:27:43 <Clint> fair
21:28:23 <Nomad> I believe Perl is amazing for quick resourceful tools, whereas Haskell is amazing for writing and thinking properly to begin with
21:28:47 <Nomad> That doesnt mean Id switch to C++ if it had haskell's features
21:28:51 <Nomad> Haskell is the only haskell
21:29:04 <Nomad> C++ is already worse than C in my eyes
21:29:14 <ab9rf> i'm not even sure what that would mean
21:29:24 <Nomad> that means im drinking beer
21:29:26 <Nomad> ignore me
21:29:28 <Nomad> >.>
21:29:35 <ab9rf> :t (>.>)
21:29:36 <lambdabot>     Not in scope: `>.>'
21:29:36 <lambdabot>     Perhaps you meant one of these:
21:29:36 <lambdabot>       `>>' (imported from Control.Monad.Writer),
21:29:40 <ab9rf> snerk
21:30:05 <Nomad> is it possible to define a (>.>) operator in haskell
21:30:06 <Nomad> ?
21:30:09 <ab9rf> Nomad: of course
21:30:28 <ab9rf> virtually any sequence of punctuation can be an operator
21:30:53 <Nomad> even (<-.->)?
21:30:59 <ab9rf> yes
21:31:12 <Nomad> awesome :)
21:31:52 <Nomad> Even the hovercraft operator? (<<+>>)?
21:32:15 <Nomad> + isnt really punctuation :\
21:32:33 <ab9rf> Nomad: it is in haskell
21:32:47 <Nomad> :O
21:33:16 <amiller> hey
21:33:19 <amiller> those things in haskell
21:33:28 <Nomad> there are many things in haskell
21:33:30 <amiller> like a monad, where you describe a type and a set of associated equational laws
21:33:34 <amiller> are those things "theories"
21:34:16 <Nomad> err I dont know what you're asking and if I was, i'd probably be underqualified to answer.
21:34:18 <amiller> i've heard people talk about "theories" before but wasn't sure precisely what they were, and i've learned about a lot of structures with extra laws before but i don't have the right name for them
21:34:26 <Nomad> Category Theory?
21:34:29 <ab9rf> the so-called monad laws?
21:35:01 <Nomad> I dont think monad laws are accurate, I'd say they're just monad properties
21:35:12 <amiller> "things with properties" seems obtuse but that's basically what i mean
21:35:13 <Nomad> without which it wouldn't be a monad
21:35:40 <Nomad> But don't trust what I say, I am still a Monad virgin
21:36:17 <simpson> They're laws which do not necessarily hold just because a data structure is a given shape.
21:36:44 <Nomad> all i know is 1) they are an abstraction with 3 properties, and 2) once you understand them, you'll never be able to explain them to anybody
21:36:56 <Hafydd> What is the act that loses one's Monad virginity?
21:37:09 <Nomad> You know it once you stop being a Monad virgin
21:37:15 <Nomad> your mind will change drastically
21:37:22 <Nomad> it will turn into a compact cubical form
21:37:34 <ab9rf> Nomad: considering that [a] is a instance of Monad....
21:37:49 <Nomad> List Nomad, I mean Monad yeah
21:38:07 <ab9rf> you've doubtlessly used them :)
21:38:16 <Nomad> using a monad doesn't mean understanding them
21:38:31 <Nomad> there are people who really understand how to use and make them, and there are cabbage people like me
21:38:55 <Nomad> the difference is how long you bang your head against the wall
21:40:19 <Nomad> ugh i shoulda kept that library book for fortran so i can translate the imperative algorithms into haskell
21:40:43 <Nomad> everyone knows you can write fortran in any language
21:41:09 <Nomad> not everyone knows what fortran is though
21:41:33 <Nomad> I leant it for lols
21:42:27 <Nomad> I miss fortran data declarations, otherwise I prefer C
21:43:06 <Nomad> it has nice primitive pattern matching for say, declaring 0..100, C doesnt
21:43:24 <Nomad> We need C with lambdas, not C++
21:43:37 <mapreduce> c I learned FORTRAN and there's nothing wrong with me.
21:43:41 <mapreduce> c Don't you agree?
21:44:07 <Nomad> FORTRAN has historical value
21:44:19 <Nomad> and it has conventions which are somewhat useful to understand
21:46:21 <Nomad> programming languages are like mental puzzles, the more you understand and question, the better you are as a person. Nothing is worse than a pure OOP programmer who doesn't know anything except what classes and objects are
21:46:42 <Nomad> A great programmer should be able to think in multiparadigm ways
21:47:17 <Nomad> then again, there isnt such a thing as a "great programmer"
21:47:18 <Nomad> but still
21:48:47 <Nomad> i just know programming is a necessary skill to any real worker, otherwise you cannot effectively process data
21:48:54 <Nomad> or simulate anything
21:53:55 <mapreduce> A pure OOP programmer who doesn't know anything except what classes and objects are doesn't really exist.
21:54:09 <mapreduce> because you can't know what classes and objects are without understanding other concepts.
21:55:14 <Nomad> there are workarounds, much like you don't need to know category theory to know haskell
21:55:16 <Nomad> it helps though
21:55:55 <mapreduce> almost worded like the phrase "you don't have to be mad to work here but it helps"
21:56:10 <Nomad> never heard that before, but that's about right
21:56:18 <Nomad> if you're not mad, you aren't experienced enough
21:56:22 <Nomad> and you need to work more
21:56:28 <mapreduce> witness: SPJ :)
21:57:06 <shachaf> SPJ is a good witness for "you don't need to know category theory"
21:57:28 <mapreduce> he doesn't know it?
21:57:36 <Nomad> Simon Payton Jones?
21:57:45 <mapreduce> the same
21:57:51 <Nomad> he needs to make more videos
21:58:00 <otters> why the hell does fromEnum return an Int
21:58:03 <shachaf> No, Simon Peyton Jones.
21:58:19 <Clint> peyton vs. payton in crab battle
21:58:19 <Nomad> the 'eh' is the same
21:59:02 <Clint> you win at trailer park phonology
21:59:10 <mapreduce> inn inglisch th pronunciation isn't nececerely how to spell the word
21:59:19 <BMeph> otters: For the same damn reason (!!) takes an Int for its second argument. :/
21:59:21 <otters> is there any fromEnum-type function that returns an Integer
21:59:26 <Nomad> yeah, its a goos  start though =]
21:59:34 <Nomad> from now on ill say "Peyton"
22:00:48 <ParahSail1n> im having a hard time tracking down where mask_ in http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Concurrent-MVar.html is defined
22:00:57 <otters> I need to convert a picosecond value to an Integer
22:01:05 <otters> without overflowing 30 times
22:01:22 <ParahSail1n> @hoogle mask_
22:01:23 <lambdabot> Control.Exception.Base mask_ :: IO a -> IO a
22:01:23 <lambdabot> Control.Exception mask_ :: IO a -> IO a
22:01:23 <lambdabot> Control.Exception.Base uninterruptibleMask_ :: IO a -> IO a
22:01:37 <ParahSail1n> well that works
22:04:45 <lightquake> one of my eternal frustrations is dealing with the fact that running ghc on a file inside a module hierarchy will break unless i explicitly pass an -i option
22:04:47 <otters> like, can I make http://hackage.haskell.org/packages/archive/time/1.4.0.2/doc/html/Data-Time-Clock.html#t:NominalDiffTime into an Integer
22:04:51 <otters> without going through Int first
22:06:30 <lightquake> otters: it looks like truncate, round, and ceiling will all do that
22:06:56 <lightquake> so pick whichever one does the thing that you want
22:07:11 <lightquake> (all of them are part of the RealFrac typeclass)
22:07:56 <otters> all of those return the second value, not the picosecond
22:08:33 <lightquake> ah
22:09:01 <lightquake> hm, not sure then
22:09:53 <lispy> Does the lambdabot quote database live anywhere publicly?
22:10:58 <otters> I'm on a 32-bit system so I can't actually do picoseconds
22:11:43 <BMeph> lispy: TUNES? ;þ
22:12:27 * Clint squints.
22:12:36 <lispy> BMeph: ah, well that's been replaced: http://ircbrowse.net/browse/haskell
22:12:51 <lispy> BMeph: I suppose I could just go read cale's $HOME
22:13:40 <lispy> the quote db is a binary file naturally
22:15:07 <Clint> naturally
22:20:37 <lispy> ^@remember on ircbrowse does a decent enough job of what Iw anted
22:21:06 <shachaf> lispy: Please remember all the details:
22:21:33 <shachaf>  @remember, ?remember, {@,?}forget, quotes that existed in the DB pre-wipe by virtue of being added from other channels...
22:21:42 <shachaf> Also, the quote db is a text file.
22:22:28 <lispy> $ file quote
22:22:29 <lispy> quote: gzip compressed data, from Unix
22:22:35 <lispy> zless to the rescue!
22:22:39 * Clint squints.
22:23:05 <lispy> @quote remember
22:23:05 <lambdabot> remember says: the 5th of november
22:23:08 <lispy> @quote @remember
22:23:08 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
22:23:30 <shachaf> lispy: Yes, true, a compressed text file.
22:23:37 <lispy> @quote (.)
22:23:37 <lambdabot> (.) says: I am the boob operator!
22:24:29 <shachaf> I move to @forget.
22:24:41 <shachaf> Not that it really matters in the messed up state of the quote file.
22:24:54 * Clint squints.
22:27:25 <dmwit> ?forget (.) I am the boob operator!
22:27:25 <lambdabot> Done.
22:27:28 * dmwit seconds
22:27:47 <lispy> @quote edwardkmett
22:27:47 <lambdabot> edwardkmett says: Most monad tutorials are written by people who barely understand monads, if at all, but unfortunately nothing can stop someone from writing a monad tutorial. We've tried, there was
22:27:47 <lambdabot> blood everywhere.
22:27:49 <dmwit> Although we probably have yet another getRandItem black hole now.
22:28:29 * dmwit vaguely wonders once again how hard it would be to fix ?forget to delete empty nicks and cleanse the db once and for all
22:28:43 <lispy> shachaf: good move
22:28:44 <shachaf> It would be easy, except for the part where you have to touch lambdabot.
22:29:21 <edwardk> she's right here. you'll give her a complex.
22:29:23 <lispy> dmwit: the file format for the quote db is a bit silly. A blank line is the separator between records.
22:30:05 <dmwit> Who's talking about touching the file? \bot must have it stored as a Map String [String] or something like that somewhere, muck about with that.
22:30:09 <dmwit> Much more fun.
22:30:11 <lispy> @quote everybody
22:30:11 <lambdabot> jmelesky says: I've figured out the problem. qwe1234 has different definitions of "functional programming", "compiler", "complexity theory", "math", and "optimization" than everybody else who deals
22:30:11 <lambdabot> with computers or computer science.
22:30:16 <shachaf> edwardk: I mean, not with a ten-foot pole.
22:30:19 <shachaf> Actually changing the code.
22:30:34 <lispy> @quote everbody
22:30:34 <lambdabot> everbody says: is hackage down?
22:30:44 <edwardk> @vixen is shachaf being mean to you?
22:30:44 <lambdabot> Your boys will be home for Christmas.
22:31:07 <dmwit> @vixen You're sounding awfully presidential.
22:31:07 <lambdabot> They're not like us. They smell different, they look different, they act different.  The trouble is, you can't find one that's honest.
22:31:38 <lispy> @quote greeting
22:31:38 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
22:32:02 <lispy> @nixon
22:32:02 <lambdabot> A man who has never lost himself in a cause bigger than himself has missed one of life's mountaintop experiences. Only in losing himself does he find himself. Only then does he discover all the
22:32:02 <lambdabot> latent strengths he never knew he had and which otherwise would have remained dormant.
22:32:49 <lispy> @quote jcreigh.floats
22:32:49 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
22:32:53 <lispy> @quote jcreigh floats
22:32:53 <lambdabot> jcreigh says: 99 times out of 100.0000000000000000032467823764876238476, you're better off without floats.
22:33:29 <lispy> @quote kmc
22:33:29 <lambdabot> kmc says: type constructors are "functions" that operate on types
22:34:25 <lispy> dmwit: type Key    = P.ByteString
22:34:26 <lispy> type Quotes = M.Map Key [P.ByteString]
22:34:34 <lispy> dmwit: close!
22:34:45 * dmwit pats himself on the back
22:35:08 <lightquake> why does Data.Text.Encoding use exceptions to abort encoding?
22:35:34 <shachaf> lambdabot's abuse of String and ByteString is horrible.
22:35:50 <dmwit> ?hackage encoding
22:35:50 <lambdabot> http://hackage.haskell.org/package/encoding
22:36:07 <dmwit> It's a bit heavyweight, but at least it has an Either return type. =)
22:36:17 <dmwit> no Text support yet, but patches welcome
22:36:24 <shachaf> Perhaps s/ab(\w+ ){5}/everything /
22:37:01 * hackagebot hstatistics 0.2.4.2 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.4.2 (VivianMcPhail)
22:37:16 * dmwit vaguely wonders once again how hard it would be to write a modern \bot replacement
22:38:17 <lispy> shachaf: but irc is just bytes, I thought
22:38:57 <shachaf> lispy: Yes, which lambdabot sometimes represents as String, if I remember correctly.
22:39:02 <shachaf> I might not be.
22:39:13 <lispy> I think this is the problem
22:39:14 <lispy> type Key    = P.ByteString
22:39:14 <lispy> type Quotes = M.Map Key [P.ByteString]
22:39:16 <lispy> oops
22:39:19 <lispy>     | P.null pat, Just qs <- mquotes =
22:39:19 <lispy>         box . display key  =<< random qs
22:39:40 <lispy> we need to replace Just qs with Just qs@(_:_)
22:40:53 <lispy> That would fix one aspect of the problem. The other thing to clean up is keys that map to the empty list
22:41:13 <arkeet> the solution is lens
22:41:26 <edwardk> yes, but usually so is the problem. ;)
22:41:30 <arkeet> :D
22:41:58 <shachaf> Fixing lambdabot is a rabbit hole few people dare go down.
22:42:01 * hackagebot hsignal 0.2.4.3 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.2.4.3 (VivianMcPhail)
22:42:23 <lispy> someone volunteered to do it on -cafe
22:42:29 <lispy> And then disappeared?
22:42:34 <c_wraith> I've tweaked lambdabot before.  Then it suddenly stopped working, and I couldn't figure out why
22:42:35 <edwardk> shapr went there once. i know for sure he didn't emerge entirely sane
22:42:51 * lispy submitted the bf plugin
22:42:58 <lispy> edwardk: and we all know the story of dons.
22:43:15 <lispy> sadly, bf has been totally nerfed
22:43:40 <edwardk> yeah, now all he can do is tweet pictures of sunsets while silently screaming inside his own head
22:44:20 <dmwit> I'm trying to imagine an even more impotent bf.
22:44:31 <shachaf> lispy: That was then.
22:44:45 <edwardk> there is a boyfriend joke in there somewhere
22:46:35 <sopvop> what is bf?
22:46:43 <lispy> sopvop: brainfuck interpreter
22:46:55 <edwardk> @google brainfuck
22:46:56 <lambdabot> http://en.wikipedia.org/wiki/Brainfuck
22:46:56 <lambdabot> Title: Brainfuck - Wikipedia, the free encyclopedia
22:47:01 * hackagebot hmatrix-gsl-stats 0.1.3.3 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.3.3 (VivianMcPhail)
22:47:35 <sopvop> isn't bf just a tape machine?
22:47:48 <dmwit> Basically, yes.
22:48:19 <lispy> sopvop: bf supports I/O. That's the main thing missing from lambdabot's bf.
22:48:26 <sopvop> hm, wikipedia says it has portability issues...
22:48:29 <lispy> it was commented out in the plugin directory
22:48:36 <shachaf> @bf +++++++++++++++++++++++++++++++++++++++++++++++++++++++.
22:48:36 <lambdabot>   7
22:48:41 <shachaf> Seems to support O
22:50:04 <lispy> http://code.haskell.org/lambdabot/brainfuck/Language/Brainfuck.hs
22:51:11 <sopvop> Isn't bf interpreter a bit boring? Lisp interpreter should not be much harder (or Tcl)
22:51:24 <dmwit> go for it
22:52:03 <lispy> sopvop: and here is my take on that: https://github.com/dagit/helisp
22:52:07 <sopvop> I have to build RenderMan Shading Language compiler (desugarer) first :(
22:52:15 <dmwit> lispy: I'm disappointed in your tape representation.
22:52:20 <shachaf> dmwit.spj.moed
22:52:37 <lispy> dmwit: do tell
22:52:45 <lispy> dmwit: but be quick, bedtime in 5 minutes
22:52:49 <dmwit> Where's your FP background! data BF = BF { jokers :: [Word8], point :: Word8, clowns :: [Word8] }
22:53:14 <sopvop> does anyone have links on type checking function overloading?
22:53:20 <lispy> dmwit: ah, this was before I had heard of those
22:53:35 <dmwit> =)
22:54:44 <lispy> dmwit: that bf interpreter is reasonably fast though. Hmm...I should do it again and generate ASM code :)
22:55:04 <lispy> It's fast because my machine cheats and has more instructions than the bf language has
22:55:18 <dmwit> I think I have an optimizing BF interpreter lying around here somewhere...
22:55:24 <lispy> it has ip relative jumps
22:56:49 <dmwit> Hm, this is cute, but it's not optimizing. I wonder where that code got to.
22:57:04 <lispy> if you find it @tell me.
22:57:11 <lispy> g'night ya'll
22:57:18 <dmwit> g'night
23:01:20 <dmwit> Oooo, your code does some optimization.
23:07:11 <ben22> how do I assign '1' = 1, '2' = 2, '3' = 3... '9' = 9 using: zip ['1'..'9'] [1..9]?
23:07:35 <arkeet> I don't understand the question.
23:07:39 <ben22> for example
23:07:56 <ben22> ('1', 1), ('2', 2), ('3', 3)... ('9', 9)
23:08:11 <arkeet> > zip ['1'..'9'] [1..9]
23:08:12 <ben22> now I want to assign '1' to 1, '2' = 2 etc
23:08:13 <lambdabot>   [('1',1),('2',2),('3',3),('4',4),('5',5),('6',6),('7',7),('8',8),('9',9)]
23:08:18 <arkeet> what do you mean by assign?
23:08:18 <ben22> yea
23:08:30 <ben22> I want to convert Char -> Int
23:08:31 <arkeet> you want a function?
23:08:37 <ben22> using that zip function
23:08:37 <arkeet> :t lookup
23:08:39 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
23:08:39 <dmwit> :t digitToInt
23:08:41 <lambdabot> Char -> Int
23:08:43 <arkeet> that too
23:08:46 <arkeet> > digitToInt 'q'
23:08:48 <lambdabot>   *Exception: Char.digitToInt: not a digit 'q'
23:08:59 <dmwit> Right, not as good as a Maybe.
23:09:02 <ben22> how can I use that zip ?
23:09:06 <arkeet> ben22: lookup
23:09:09 <arkeet> look up at lookup
23:09:16 <ben22> lookup is a haskell function?
23:09:21 <arkeet> yes, look up
23:09:28 <ben22> ok let me see this
23:09:48 <arkeet> I don't understand why lookup isn't flipped from how it is now.
23:10:10 <ben22> this is what i'm looking for, thanks arkeet
23:11:42 <elliott> :t lookup
23:11:43 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
23:12:21 <dmwit> > [x | (c, x) <- zip ['1'..'9'] [1..9], c == '3']
23:12:23 <lambdabot>   [3]
23:12:46 <dmwit> > [x | ('3', x) <- zip ['1'..'9'] [1..9]]
23:12:48 <lambdabot>   [3]
23:13:35 <dmwit> ?let ensure p x = guard (p x) >> return x
23:13:37 <lambdabot>  Defined.
23:14:01 <ben22> dmwit, i'm getting "coudn't match expected type Int with actual type "Maybe b0"
23:14:07 <ben22> charToInt :: Char -> Int
23:14:07 <ben22> charToInt x = lookup x lookupTable
23:14:13 <arkeet> of course
23:14:14 <arkeet> :t lookup
23:14:15 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
23:14:26 <ben22> how can I fix this?
23:14:39 <arkeet> first you think about what you want it to do for chars not in your table.
23:15:16 <ben22> I just want the chars to conver to int
23:15:17 <ben22> that's it
23:15:25 <arkeet> what should charToInt 'q' be?
23:15:36 <dmwit> > let x .- y = chr (ord x - ord y) in '3' .- '0'
23:15:38 <lambdabot>   '\ETX'
23:15:45 <ben22> it's the ascii int for it
23:15:47 <dmwit> -_-
23:15:55 <arkeet> ._.
23:16:03 <arkeet> ben22: you want charToInt '5' to be 5, right?
23:16:07 <arkeet> what if you give it a char that's not a digit?
23:16:09 <ben22> yea
23:16:15 <arkeet> what should it do?
23:16:24 <ben22> undefined
23:16:32 <arkeet> ok.
23:16:44 <arkeet> not the best idea but
23:16:46 <arkeet> :t fromJust
23:16:47 <lambdabot> Maybe a -> a
23:16:49 <dmwit> case ... of Just v -> v; Nothing -> undefined
23:16:54 <arkeet> actually, a pretty bad idea.
23:16:55 <ben22> no worries cause my lookupTable already handles all cases it should get
23:17:02 <arkeet> but it'll do what you say.
23:17:10 <arkeet> case ... of Just v -> v; Nothing -> error "charToInt: not a digit"
23:17:18 <arkeet> at least then if it blows up you'll know where.
23:17:30 <dmwit> Pfft, he didn't ask for 'error "charToInt: not a digit"', he asked for undefined.
23:17:33 <dmwit> lern2read
23:17:40 <arkeet> but they're both bottom
23:17:52 <dmwit> Pfft, he didn't ask for bottom, he asked for undefined.
23:17:53 <dmwit> ;-)
23:18:01 <ben22> um so I need a basecase in my charToInt function right
23:18:11 <dmwit> There's no recursion here. So no.
23:18:36 <dmwit> Unless you plan on implementing lookup yourself. Then you'll probably need recursion, and a base case.
23:18:38 <ben22> charToInt :: Char -> Int (I know the Int part is a problem)
23:19:14 <ben22> I don't get it
23:19:17 <ben22> charToInt x = lookup x lookupTable should work
23:19:20 <ben22> lookupTable = zip ['1'..'9'] [1..9]
23:19:24 <arkeet> your issue is that, say, lookup '5' lookupTable = Just 5
23:19:25 <arkeet> not 5
23:19:52 <ben22> well how do I convert Just 5 to just a plain ol' integer...
23:19:52 <arkeet> so you need to do something with that Maybe value
23:20:00 <arkeet> we've been saying how to do that.
23:20:04 <dmwit> ben22: Read what arkeet has been saying.
23:20:12 <ben22> i don't understand
23:20:18 <ben22> oh
23:20:22 <arkeet> > case Just 5 of Just x -> x; Nothing -> error "boo"
23:20:24 <lambdabot>   5
23:20:25 <arkeet> > case Nothing of Just x -> x; Nothing -> error "boo"
23:20:26 <lambdabot>   *Exception: boo
23:20:28 <ben22> helper function to conver Just x -> x?
23:20:49 <arkeet> it doesn't have to be a separate function.
23:20:54 <arkeet> > fromMaybe (error "boo") Just 5
23:20:56 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (t0 -> t1)'
23:20:56 <lambdabot>              wit...
23:20:58 <arkeet> > fromMaybe (error "boo") (Just 5)
23:20:59 <arkeet> > fromMaybe (error "boo") Nothing
23:21:00 <lambdabot>   5
23:21:02 <lambdabot>   *Exception: boo
23:21:08 <ben22> is "Just" constructor in the Prelude?
23:21:11 <arkeet> ...yes
23:21:14 <dmwit> Yes.
23:21:16 <ben22> o
23:21:17 <dmwit> ?src Maybe
23:21:17 <lambdabot> data Maybe a = Nothing | Just a
23:21:37 <arkeet> is fromMaybe in prelude? I forget.
23:21:40 <dmwit> It would be very hard for the Prelude function "lookup" to return a value not defined in the Prelude.
23:21:42 <arkeet> let's ask hoogle.
23:21:49 <arkeet> ah, it isn't.
23:22:01 <dmwit> maybe is in Prelude
23:22:05 <arkeet> sure.
23:22:28 <Ralith> @where lyah
23:22:28 <lambdabot> http://www.learnyouahaskell.com/
23:22:33 <dmwit> ?src maybe
23:22:33 <lambdabot> maybe n _ Nothing  = n
23:22:33 <lambdabot> maybe _ f (Just x) = f x
23:22:34 <ben22> convertMaybe :: Maybe a -> a
23:22:34 <ben22> convertMaybe x = x
23:22:40 <Ralith> ben22: you will save some pain if you just go through that link
23:22:52 <ben22> I know about this link since the first day
23:22:56 <arkeet> ben22: that doesn't work
23:23:03 <Ralith> then what are you waiting for?
23:23:37 <ben22> i should have just went to arts major
23:23:54 <startling> heh
23:24:20 <dmwit> ben22: A "Maybe a" is not an "a". "x" is a "Maybe a". Consequently, "x" is not an "a".
23:25:02 <ben22> would be more simple to make x == '1' = 1 !!!
23:25:14 <ben22> but noooo we gotta make a lookup table lol
23:25:24 <arkeet> you could.
23:25:27 <arkeet> f '1' = 1; f '2' = 2; ...
23:25:41 <ben22> no he wants us to zip it and then "look" for it
23:25:48 <arkeet> then do that
23:25:58 <ben22> i'm trying to conver this Maybe a to Int a
23:26:11 <dmwit> "Int a" is a kind error.
23:26:12 <arkeet> no, you're trying to convert a Maybe Int to an Int
23:26:51 <Ralith> ben22: why aren't you going through the material at that link?
23:27:26 <ben22> i'll just go through the material in that link
23:27:57 <Ralith> yes, that is what I advised you to do.
23:28:03 <ben22> ehh too much to read
23:28:04 <ben22> google time
23:28:14 <Ralith> this is why you are having a hard time.
23:28:21 <Ralith> learning things takes effort.
23:28:22 * dmwit feels that he no longer owes ben22 any effort
23:28:35 <Ralith> if you aren't willing to invest any effort, you will not learn.
23:28:44 <ben22> there's too many links
23:28:50 <ben22> it's impossible to find what im looking for
23:28:52 <arkeet> read it in order
23:29:21 <Ralith> it's a book. It goes from start to finish
23:29:31 <Ralith> you'd know this if you did more than glance at it.
23:29:38 <hpaste> turiya pasted “case exp” at http://hpaste.org/84023
23:29:48 <turiya> hi
23:29:51 <arkeet> turiya: "n-1" is not a valid pattern
23:30:12 <turiya> arkeet: thats exactly what i wanted to ask
23:30:17 <arkeet> maybe you want a guard with ==
23:30:21 <ben22> is it this hard just to convert Maybe Int -> Int?...
23:30:34 <dmwit> No, it's very easy.
23:30:38 <dmwit> So you should know how to do it.
23:30:39 <arkeet> ben22: it is easy, but you should read.
23:30:47 <arkeet> so that it will be easy for you too.
23:30:50 <ben22> haha, this is hilarious
23:31:14 <arkeet> quite
23:31:39 <turiya> why is n a valid pattern but not n-1
23:31:51 <Ralith> turiya: because n is a variable name, and n-1 is not.
23:31:52 <arkeet> turiya: patterns consist of variables or constructors.
23:31:53 <dmwit> turiya: Because - is not a constructor.
23:32:04 <arkeet> and what they said.
23:32:11 <lightquake> thank god for cabal install -j
23:32:17 <dmwit> turiya: (You can't match against arbitrary functions -- unless you want to run into halting problems!)
23:32:18 <turiya> oh, i see
23:32:37 <ben22> i see my colleagues at school... they don't read and they get it
23:32:51 <arkeet> I bet they do read something.
23:32:53 <Ralith> ben22: this is homework, I take it. Perhaps you should speak to your TA.
23:33:12 <dmwit> ben22: You don't know how much work your colleagues do. And it doesn't matter anyway. If you need to do work to get it, you just need to buckle down and do work, whether other people are breezing through or not.
23:33:16 <ben22> that piece of junk never helps with anything
23:33:28 <arkeet> regardless, you'll need to put in some effort of your own.
23:33:37 <Ralith> perhaps he's simply so impressed by your work ethic that he assumes you don't need any help
23:33:52 <ben22> I bet he is
23:35:08 <turiya> how can use guards in a case expression?
23:35:21 <dmwit> turiya: Just stick a | before the ->
23:35:35 <arkeet> > case 5 of x | even x -> "even" | otherwise = "odd"
23:35:37 <lambdabot>   <hint>:1:44: parse error on input `='
23:35:41 <arkeet> > case 5 of x | even x -> "even" | otherwise -> "odd"
23:35:42 <lambdabot>   "odd"
23:35:45 <dmwit> > case 3 of n | n == 5 -> "lol" | otherwise -> "yay"
23:35:47 <lambdabot>   "yay"
23:36:11 <arkeet> > case 5 of { x | even x -> "even"; _ -> "odd" }
23:36:12 <lightquake> this is how the old case () of idiom works
23:36:13 <lambdabot>   "odd"
23:36:54 <arkeet> of course this probably shouldn't all be on one line.
23:36:56 <turiya> if I use | for n-1, then i should use it for other cases as well
23:37:03 <dmwit> If you like.
23:37:04 <arkeet> you don't have to.
23:37:08 <dmwit> That's an aesthetic choice.
23:37:45 <lightquake> argh. the GHC API really doesn't seem to like template haskell
23:37:53 <arkeet> > let n = 5 in case 4 of { n' | n' == n-1 -> "blah"; 0 -> "zero"; _ -> "?" }
23:37:55 <lambdabot>   "blah"
23:37:56 <arkeet> > let n = 5 in case 0 of { n' | n' == n-1 -> "blah"; 0 -> "zero"; _ -> "?" }
23:37:58 <lambdabot>   "zero"
23:38:46 <arkeet> oh yeah, you can also match on numeric literals. but that expands to a guard
23:38:54 <arkeet> f 5 = ... is the same as f x | x == 5 = ...
23:39:00 <ben22> what's the diff between Int and Integer anyhow
23:39:17 <arkeet> I believe LYAH tells the difference. but Integer can hold arbitrary large numbers
23:39:24 <arkeet> > 2^100 :: Integer
23:39:25 <lightquake> Integer is arbitrary range, the width of an Int is compiler-dependent
23:39:25 <lambdabot>   1267650600228229401496703205376
23:39:26 <arkeet> > 2^100 :: Int
23:39:28 <lambdabot>   0
23:39:52 <turiya> what is the difference when guards are used?
23:40:04 <arkeet> difference between what?
23:40:15 <dmwit> turiya: Guards can perform arbitrary computations, but can't bind new variables.
23:40:22 <dmwit> (unless extensions are used)
23:40:28 <arkeet> pattern guards are haskell 2010
23:40:36 <turiya> difference with not using guards and using "n-1" as i have done
23:40:36 <dmwit> neat
23:40:51 <arkeet> turiya: one of them works.
23:40:53 <dmwit> Well, to start with, "n-1" doesn't work. =P
23:40:58 <arkeet> :p
23:41:00 * dmwit high fives arkeet
23:41:17 <turiya> :)
23:41:23 <arkeet> it seems like you're on top of things, so I'll go do stuff.
23:41:25 <ben22> ok I give, I don't know how to convert Maybe Int -> Int
23:41:34 <dmwit> Keep reading.
23:41:45 <ben22> this book does not have it
23:41:52 <dmwit> That is incorrect.
23:41:58 <dmwit> Assuming "this book" is LYAH.
23:42:11 <ben22> so under what title is it on?
23:42:23 <dmwit> I have no idea.
23:42:29 <ben22> yea then how would you know
23:42:37 <dmwit> ...and I wouldn't tell you if I did know which title it was on.
23:42:42 <ben22> why?
23:43:03 <dmwit> Because I like to be helpful, even when being helpful is a bit painful.
23:43:17 <ben22> so you like to bring me pain
23:43:19 <arkeet> teach a man to fish. or something.
23:43:54 <ben22> ignorance, i'm full of it. would you just tell me what to do
23:44:24 <dmwit> We've told you at least four or five times. But you ignored it, so now you get to read LYAH.
23:44:34 <ben22> yea 4 5 times to read that damn book
23:44:45 <ben22> yea I did, doesn't have it
23:44:52 <dmwit> You can pick a different tutorial, if you prefer.
23:44:59 <dmwit> The Gentle Intro was my favorite.
23:45:13 <dmwit> ?where gentle
23:45:14 <lambdabot> http://www.haskell.org/tutorial/
23:45:31 <ben22> these tutorials are a waste of my time
23:45:42 <DanBurton> ben22: something of type Maybe Int -> Int is unsafe. "Maybe Int" means there might not be an Int there! you wouldn't want your program exploding, now would you?
23:45:43 <startling> ben22: do you know what a Maybe Int is?
23:45:43 <dmwit> Yes, why bother learning the language you're trying to program in?
23:45:47 <elliott> ben22: refusing to read them is a waste of our time.
23:46:01 <startling> DanBurton: nah. Maybe Int -> Int is perfectly valid
23:46:19 <arkeet> DanBurton: fromJust is unsafe. there are plenty of functions of that type that are safe.
23:46:20 <ben22> i have a lookuptable, all my cases are already accounted for an they will always be integer type
23:46:21 <dmwit> Maybe Void -> Void is the dangerous one.
23:46:23 <lightquake> startling: because there's a bijection between values of type Maybe Int and Int?
23:46:26 <DanBurton> startling: shhh
23:46:44 <dmwit> lightquake: No there isn't.
23:46:48 <DanBurton> but does 0 map to Nothing or to Just 0?
23:46:48 <startling> lightquake: there doesn't need to be a bijection for a function to exist
23:46:50 <dmwit> lightquake: Int is finite. =)
23:46:53 <lightquake> dmwit: oh, right
23:46:55 <arkeet> haha
23:46:58 <ben22> k i'm just going with x == '1' = 1, x == '2' = 2
23:47:06 <lightquake> damn, my technicality got caught on a technicality
23:47:06 <ben22> none of this stuff
23:47:09 <arkeet> ben22: 0 points for not using the lookup table.
23:47:28 <ben22> ... I forgot
23:47:30 <DanBurton> ben22: but what if x does not equal any of those? Then you're left with Nothing.
23:47:30 <elliott> dmwit: hmm, is Int actually guaranteed to be finite in the report?
23:47:40 <dmwit> elliott: ...maybe not!
23:47:44 <DanBurton> It better be
23:47:50 <dmwit> Now that's a nice loophole if it's there.
23:47:51 <ben22> ok tell me something
23:47:55 <lightquake> "A fixed-precision integer type with at least the range [-2^29 .. 2^29-1]."
23:47:55 <DanBurton> unless you have infinite hardware
23:47:56 <elliott> I guess it's guaranteed to have a Bounded instance?
23:48:02 <elliott> but maybe your Int just has -inf and +inf.
23:48:02 <ben22> is converting Maybe Int -> Int a one-liner?
23:48:13 <elliott> "converting Maybe Int -> Int" doesn't really make sense.
23:48:20 <shachaf> There are many functions of that type.
23:48:27 <elliott> probably the "Maybe Int -> Int" you want here -- there are billions -- will be short.
23:48:30 <shachaf> Most of them can't be written in one line, but probably all the ones you care about can.
23:48:32 <DanBurton> ben22: sure. f :: Maybe Int -> Int; f _ = 3;
23:48:32 <elliott> but knowing how to write it is the important part.
23:48:39 <lightquake> ben22: do you know any other languages?
23:48:45 <arkeet> the report specifies that Int is an intsance of Bounded.
23:48:46 <arkeet> yeah
23:48:57 <elliott> arkeet: does it specify enough about what Int has to be to rule out just affixing -inf/+inf?
23:48:59 <ben22> I like Java this stuff is confusing me
23:49:11 <startling> ben22: do you know what Maybe Int means?
23:49:12 <arkeet> well, -inf/+inf aren't integers.
23:49:20 <ben22> it means Maybe it's an integer or not
23:49:25 <elliott> maybe it doesn't say Int has to be an integer type!
23:49:30 <startling> ben22: what is it if it's not an Int?
23:49:30 <lightquake> ben22: suppose i give you an object of type Integer. and I ask you to give me back an Integer that's not null.
23:49:32 <shachaf> Fortunately Maybe Integer ~ Integer, other than bottoms.
23:49:33 <elliott> just that it has to be able to store a certain range of integers.
23:49:35 <arkeet> "Fixed-precision integers"
23:49:38 <dmwit> class Maybe<T> {}; class Nothing<T> extends Maybe<T> {}; class Just<T> extends Maybe<T> { T value; }
23:49:41 <shachaf> Oh, someone said that.
23:49:57 <DanBurton> ben22: Precisely. So it is unwise to try to always get an Int out of Maybe Int, because you might not get one.
23:50:17 <DanBurton> ben22: instead you pattern match on Maybe's two constructors: (Just someInt) and Nothing.
23:50:20 <shachaf> dmwit: That's why I prefer Maybe (Maybe Void) -> Maybe Void
23:50:28 <ben22> but DanBurton, i'm using this constricted lookup table lookupTable = zip ['1'..'9'] [1..9]
23:50:33 <ben22> so it's OK
23:50:44 <lightquake> ben22: so what happens if i ask you to look up 'a' in the table?
23:50:54 <arkeet> ben22: honestly, if you just went through LYAH or some other material to learn the basics, you wouldn't have to go through this pain each time.
23:50:57 <DanBurton> > case Just (3 :: Int) of Just anInt -> show anInt; Nothing -> "nope"
23:50:59 <lambdabot>   "3"
23:51:11 <elliott> arkeet: I think you mean "we" :)
23:51:11 * dmwit notes (in the general direction of DanBurton and lightquake) that we have had this exact conversation about an hour ago
23:51:14 <shachaf> Can you convert a nint to an int?
23:51:20 <arkeet> elliott: fair.
23:51:28 <arkeet> an hour?
23:51:33 <ben22> look arkeet, buddy, i'm a busy guy. I work, do chores, go to school, and clubs
23:51:42 <dmwit> half an hour
23:51:42 <elliott> ben22: and we're volunteers, not slaves.
23:51:44 <arkeet> close enough.
23:51:53 <elliott> so go read a tutorial rather than having us run around in circles.
23:52:00 <DanBurton> you would still save yourself time by actually learning the Haskell way to think
23:52:11 <ben22> you know what ! i'm just gonna go with the old school way
23:52:18 <DanBurton> and you might (god forbid) learn something
23:52:18 <arkeet> read a book?
23:52:27 <dmwit> Excellent! assembly time
23:52:40 <ben22> not that oldschool, I mean x == '1' = 1
23:52:42 <ben22> end of story
23:52:46 <arkeet> 0 points for not using the lookup table.
23:52:58 <ben22> i'll get that 0 points, this is ridiculous
23:53:00 <ben22> what is this crap
23:53:01 <DanBurton> the lookup table was cuter
23:53:26 <ben22> look here's what I got
23:53:28 <ben22> charToInt :: Char -> Int
23:53:29 <ben22> charToInt x = convertMaybe (lookup x lookupTable)
23:53:41 <ben22> i don't know how to do convertMaybe
23:53:50 * dmwit nods agreeably
23:54:10 <arkeet> try pattern matching.
23:54:12 <dmwit> Perhaps you are expecting one of us to write it for you. If so, I dearly hope this expectation will be disappointed.
23:54:24 <arkeet> well, we already kind of did.
23:54:33 <ben22> no you didn't
23:54:35 * elliott isn't sure #haskell can resist the temptation to write something for someone...
23:54:38 <Ralith> we did, repeatedly
23:54:39 <ben22> i would have seen it
23:54:43 <Ralith> in several variations
23:54:44 * dmwit laughs aloud
23:54:53 <dmwit> This is just too rich.
23:54:56 <lightquake> convertMaybe = unsafeCoerce
23:55:00 <lightquake> there :)
23:55:01 <arkeet> haha
23:55:08 <Ralith> yes
23:55:09 <Ralith> do that
23:55:26 <ben22> putain putain putain
23:55:28 <DanBurton> > let lookupTable = zip ['1'..'9'] [1 .. 9]; charToInt x = convertMaybe (lookup x lookupTable); convertMaybe m = case m of Just c -> Just c; Nothing -> Nothing in charToInt 'a'
23:55:30 <lambdabot>   Nothing
23:55:30 <dmwit> The best thing about that suggestion is that it will sort of half-work if you only try it in ghci...
23:55:51 <ben22> what is this case m thing?
23:55:57 <ben22> I don't understand what you did there
23:56:06 <dmwit> Learn Haskell.
23:56:11 <lightquake> λ> unsafeCoerce (Just 1 :: Maybe Int) :: Int
23:56:11 <lightquake> 4611686018444661610
23:56:13 <lightquake> looks legit to me
23:56:26 <Ralith> A+ homework assignment right there
23:56:35 <DanBurton> ben22: (case m of Just c -> BLAH1; Nothing -> BLAH2) is called pattern matching
23:56:35 <dmwit> oh my goodness
23:56:37 <dmwit> I just realised.
23:56:46 <dmwit> charToInt = unsafeCoerce
23:57:07 <lightquake> … haha, oh god
23:57:08 <arkeet> too bad we can't write main = unsafeCoerce
23:57:09 <DanBurton> ben22: Maybe Int can be either (Just someInt) or Nothing, so you need to use a case statement to distinguish the two situations
23:57:11 <dmwit> subtract 49 . unsafeCoerce
23:57:14 <arkeet> I guess, main = unsafeCoerce ()
23:57:34 <elliott> arkeet: unsafeCoerce unsafeCoerce.
23:57:40 <arkeet> I like your style.
23:57:46 <simpson> Haha, what.
23:57:46 <elliott> in fact unsafeCoerce should just be defined that way. if you want to use it as (a -> b) you can just pass it an argument.
23:57:51 <ben22> convertMaybe :: Maybe Int -> Int
23:57:51 <ben22> convertMaybe x = case x of Just x -> x
23:58:01 <ben22> right
23:58:05 <DanBurton> ben22: you can do that, but you forgot the Nothing case
23:58:14 <dmwit> Hey, that's a start!
23:58:15 <ben22> I don't need such a thing
23:58:28 <DanBurton> you will never be given erroneous input?
23:58:43 <ben22> no, because my world will be ideal one
23:58:51 <arkeet> ben22: honestly, if you went through LYAH you'd know this stuff.
23:58:55 <DanBurton> that's nice. be sure to send a postcard
23:58:56 <arkeet> as well as a lot of other stuff.
23:59:27 <ben22> ok obviously i am kidding..
23:59:35 <DanBurton> > let lookupTable = zip ['1'..'9'] [1 .. 9]; charToInt x = convertMaybe (lookup x lookupTable); convertMaybe m = case m of Just c -> c in charToInt 'a'
23:59:36 <lambdabot>   *Exception: <interactive>:3:112-132: Non-exhaustive patterns in case
23:59:40 <arkeet> like how to bake a soufflé.
23:59:41 <DanBurton> ewww
23:59:59 <DanBurton> You could at least default to 0.
