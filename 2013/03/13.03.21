00:03:11 <edwardk> alang: i'm betting you have a whole pile of incorrect kinds in the template haskell machinery if its based on the old stuff
00:37:15 <comatose> @hoogle
00:37:15 <lambdabot> No query entered
00:37:15 <lambdabot> Try --help for command line options
00:37:27 <comatose> @hoogle [a] -> [a]
00:37:27 <lambdabot> Prelude cycle :: [a] -> [a]
00:37:27 <lambdabot> Data.List cycle :: [a] -> [a]
00:37:28 <lambdabot> Prelude init :: [a] -> [a]
00:37:52 <comatose> @ty cycle
00:37:53 <lambdabot> [a] -> [a]
00:39:46 <arkeet> @@ @free @type cycle
00:39:48 <lambdabot>  Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:21-35
00:39:52 <arkeet> uh
00:40:11 <arkeet> @free [a] -> [a]
00:40:11 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:21-35
00:40:14 <arkeet> @free cycle :: [a] -> [a]
00:40:14 <lambdabot> $map f . cycle = cycle . $map f
00:41:02 <arkeet> it would be nice to have more pointful command composition
00:41:18 <arkeet> i.e. put the outputs of commands anywhere in the input of another command.
00:42:28 <arkeet> maybe pointful isn't the word.
00:42:37 <comatose> @free map
00:42:39 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
00:42:46 <arkeet> @free cycle
00:42:48 <lambdabot> $map f . cycle = cycle . $map f
00:42:51 <arkeet> hmm.
00:43:08 <arkeet> @free head
00:43:09 <lambdabot> f . head = head . $map f
00:43:22 <comatose> @free (>>>)
00:43:22 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:21-35
00:43:24 <arkeet> @free seq
00:43:25 <lambdabot> g . seq x = seq (f x) . g
00:43:31 <arkeet> yeah right.
00:43:32 <arkeet> :P
00:44:49 <supki> what's f?
00:45:00 <arkeet> an arbitrary function of the appropriate type
00:45:33 <supki> @free const
00:45:35 <lambdabot> f . const x = const (f x) . g
00:45:40 <supki> aha
00:45:46 <arkeet> > id . seq undefined $ ()
00:45:49 <lambdabot>   *Exception: Prelude.undefined
00:45:57 <arkeet> > seq (const () undefined) . id $ ()
00:45:59 <lambdabot>   ()
00:46:08 <mm_freak> Ralith: currently i have no immediate plans to support ppc, simply because i'm not familiar with it and i have no hardware test system for it
00:46:16 <arkeet> where's that free theorem generator?
00:46:35 <mm_freak> Ralith: my main target is x86_64, although currently everything is 32 bits protected mode
00:46:49 <Ralith> mm_freak: pcc, as in proof carrying code
00:46:55 <arkeet> ah http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi
00:47:00 <mm_freak> oh =)
00:47:07 <mm_freak> Ralith: could you summarize what you mean by that?
00:49:18 <Ralith> mm_freak: it sounded a lot like what you're doing re verified security
00:49:21 <comatose> thanks for free-theorem
00:49:44 <mm_freak> Ralith: yes, that's exactly what i'm doing…  statically enforced security models
00:49:47 <arkeet> so the free theorem for seq is true if f and g are strict and total. obviously
00:49:59 <arkeet> I guess for seq we only need that f is strict and total.
00:50:07 <Ralith> mm_freak: to be clear--you're implementing a kernel that uses pcc?
00:50:08 <Axman6> like all the best functions are
00:50:21 <arkeet> the best functions are strict?
00:50:48 <mm_freak> Ralith: a kernel that /provides/ pcc (if i'm understanding that term properly) and ideally using pcc for its own implementation as well
00:50:52 <mm_freak> the main aim is the former
00:51:27 <Ralith> awesome
00:51:33 <Ralith> that's very exciting
00:52:12 <mm_freak> i'm hoping to have a first working prototype in a couple of months
00:54:57 <mm_freak> likely it will be powered by some functional language, most likely idris or haskell, but possibly also my own language
00:55:53 <mm_freak> i even considered agda, but the code base is too complicated
00:57:21 <mm_freak> my impression is that the agda code is mainly built with the emacs interface in mind and doesn't really support compilation well, even though it has some backends
00:59:39 <alang> edwardk: in the Forward constructor of Forward, only the first argument is strict. Why is that?
00:59:57 <edwardk> its strict to match the semantics of the primal value
01:00:11 <edwardk> e.g. if you calculated with newtype Id a = Id a
01:00:15 <edwardk> then the primal would be strict
01:00:27 <mm_freak> Ralith: since the most likely choice is idris i'd be happy to help you with the compiler backend =)
01:00:30 <alang> i mean why is the other one lazy?
01:01:11 <edwardk> its lazy because an undefined derivative shoudn't affect the definedness of the primal
01:01:47 <edwardk> basically the strictness on the primal is never a problem, but strictness on other stuff could be
01:01:57 <edwardk> we may want to introduce a mode with a strict derivative, etc.
01:02:04 <alang> right
01:02:06 <edwardk> but it does introduce semantic issues
01:02:26 <Ralith> mm_freak: that would be wonderful!
01:02:35 <edwardk> so even so we'd probably want the version that was properly lazy in the other derivatives around
01:03:17 <alang> ok, thanks!
01:03:46 <Ralith> mm_freak: something to bear in mind is that there's a lot of opportunity to shape/idris to your particular needs, particularly at its current stage
01:06:03 <`nand`> morning all
01:06:23 <srhb> `nand`: Morning.
01:09:09 <notdan> How one would go about representing binary relationships using Arrows?
01:10:05 <Ralith> mm_freak: if you want to get your feet wet, I could use a hand tracking down some UB arising from escape analysis...
01:12:30 <dgriffi> is anyone here familiar with Pandoc?
01:12:47 <dgriffi> I'm trying to make a simple modification and I'm not getting something basic
01:13:22 * hackagebot network-conduit-tls 1.0.0.1 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.0.0.1 (MichaelSnoyman)
01:13:24 * hackagebot warp-tls 1.4.0.1 - SSL support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.4.0.1 (MichaelSnoyman)
01:13:26 * hackagebot keter 0.3.5.4 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.3.5.4 (MichaelSnoyman)
01:15:38 <dgriffi> anyone here?
01:15:44 <elliott> no :)
01:16:30 <`nand`> I'm here and incredibly bored
01:16:49 <dgriffi> `nand`: well, hopefully I have something that'll make you un-bored
01:18:06 <`nand`> cobored
01:18:35 <`nand`> alas, I know nothing about pandoc
01:18:59 <hpaste> dgriffi pasted “pandoc mod” at http://hpaste.org/84413
01:19:32 <dgriffi> `nand`: well, could you at least look at what I put on hpaste and tell me if I did something stupid?
01:19:56 <dgriffi> it fails to compile, giving me "Not in scope: data constructor `NewPage'"
01:20:36 <srhb> dgriffi: Well there you go, you haven't imported that.
01:20:38 <`nand`> well, have you defined a data constructor NewPage?
01:20:40 <`nand`> oh
01:20:43 <`nand`> or imported
01:21:06 <srhb> dgriffi: There's also something weird with the number of arguments to blockToHtmk
01:21:11 <srhb> Html*
01:22:09 <dgriffi> I'm trying different ways of calling blockToHtml and I keep getting this error... not sure where I need to add something
01:22:32 <srhb> dgriffi: Do you know what data constructors are?
01:22:37 <dgriffi> srhb: no
01:22:41 <`nand`> oh
01:22:51 <`nand`> have you read an introduction to haskell?
01:22:55 <dgriffi> barely
01:23:06 <dgriffi> I'm trying to goad the maintainer of pandoc into adding a feature
01:23:19 <srhb> I think you'll find it an insurmountable task to try and jot random things into the file and have it compile :-)
01:23:58 <dgriffi> they're not quite random.. I was looking at the line below it (talking about HorizontalRule), copying it, and changing it slightly
01:24:31 <srhb> Well. It looks to me like the arguments to blockToHtml are html-y data constructors
01:24:49 <srhb> NewPage doesn't sound like it's one.
01:26:17 <latermuse> dgriffi: it will be hard to convince the maintainer of pandoc to add a feature when you dont even understand how haskell/pandoc work
01:27:33 <dgriffi> latermuse: I'm afraid of that.  he's added several other suggestions.. two remain
01:27:48 <latermuse> dgriffi: right on
01:28:10 <srhb> dgriffi: Another problem is that pure newPage doesn't mean anything without newPage defined
01:28:27 <srhb> dgriffi: horizontalRule is defined in Text.Pandon.Builder - perhaps you can glean some information there.
01:29:18 <srhb> And HorizontalRule in Text.Pandoc.Definition
01:29:29 <srhb> That's probably where you'd want the NewPage constructor to come from
01:29:35 <dgriffi> srhb: any hints on what file to rifle through?
01:29:46 <srhb> Yeah, those two
01:30:00 <srhb> Text.Pandoc.Builder and Text.Pandoc.Definition
01:30:12 <srhb> the first one should be define newPage, the second one should define NewPage
01:30:21 <dgriffi> Text/Pandoc/Builder doesn't exist
01:30:50 <srhb> http://hackage.haskell.org/packages/archive/pandoc-types/latest/doc/html/src/Text-Pandoc-Builder.html
01:31:41 <srhb> Start here, really: http://hackage.haskell.org/packages/archive/pandoc-types/latest/doc/html/Text-Pandoc-Definition.html#v:HorizontalRule
01:32:17 <srhb> dgriffi: Now, if you think NewPage deserved is a valid constructor for a Block-type-thing, you'll have to add that.
01:32:23 <dgriffi> so, I'm going to have to hack a library?
01:32:38 <srhb> Yes.
01:33:07 <srhb> Just cabal unpack pandoc-types -- if you have a working Haskell setup
01:33:26 <dgriffi> srhb: I have that much down
01:33:31 <srhb> Ok. :)
01:33:48 <srhb> Once you make the appropriate changes to those two files you should be more or less set.
01:34:15 <dgriffi> I wonder why he made a seperate library like this
01:34:31 <srhb> Probably because it can be reused without the rest of pandoc.
01:34:41 <elliott> licensing perhaps
01:34:44 <elliott> or because pandoc has 234892349823849 deps
01:34:52 <srhb> :-)
01:34:57 <dgriffi> <boggle>
01:35:30 <srhb> dgriffi: By the way, where's blockToHtml from?
01:36:03 <srhb> Nevermind, found it.
01:37:32 <srhb> dgriffi: When you have the rest done, you'll need blockToHtml _ NewPage = return yourHtmlThingy - remember that first argument.
01:37:43 <dgriffi> ah.. I think the more proper thing to do is clone pandoc-types straight from github
01:37:59 <srhb> It's not a big deal if you do one or the other right now
01:38:02 <dgriffi> because pandoc is up to version 1.11.1 and pandoc types is 1.10
01:38:12 <srhb> Unless there have been massive changes.
01:38:16 <dgriffi> somewhat
01:38:32 <dgriffi> one of the previous changes I requested required an API change
01:38:41 <srhb> Either way I think you have everything you need now, aside from some basic Haskell knowhow :P
01:39:03 <dgriffi> yeah.  thanks for the help
01:39:18 <srhb> No problem, lemme know if you get stuck.
01:40:03 <dgriffi> one other question... why are haskell binaries so big?
01:40:16 <srhb> They include an RTS and they're statically linked by default, afaik
01:41:01 <mikeplus64> dgriffi: protip: compile with -dynamic for dynamic linking
01:41:21 <srhb> But in my experience, all that gives you is smaller binaries at the cost of more headaches
01:41:28 <srhb> I don't find myself needing small binaries very often.
01:41:38 <mikeplus64> also you can have shared: True in your ~/.cabal/config file for twice the compilation and dynamic libs
01:41:46 <dgriffi> yes, I've heard the talk about abandoning dynamics in other languages
01:41:55 <mikeplus64> srhb: why?
01:42:02 <srhb> Harddisk space is cheap most of the time.
01:42:04 <mikeplus64> i mean, what headaches
01:42:13 <srhb> Not being able to share the binaries easily and so on.
01:43:18 <mikeplus64> i don't like having 50+MB binaries
01:43:29 <srhb> OK. :) That's fine. I just don't care if they're 50MB-
01:43:31 <srhb> +*
01:43:33 <mikeplus64> which is quite easily done using e.g. yesod and its accompanyment
01:43:38 <mikeplus64> or other web things
01:43:57 <srhb> Bottom line being, if you care for some reason, you can dynamically link.
01:44:16 <srhb> I think most people that do care care for no particular reason, but that's just religion. :P
01:44:48 <dgriffi> what's the best way to remove a package that was installed using cabal?
01:45:00 <latermuse> cant
01:45:03 <srhb> dgriffi: There's no good way, you can unregister it with ghc-pkg though
01:45:11 <srhb> dgriffi: cabal is not a package manager.
01:45:26 <srhb> ghc-pkg unregister foopackage
01:46:50 <tdammers> dgriffi: the best way is to not have it installed globally at all
01:46:54 <tdammers> use cabal-dev
01:47:14 <tdammers> and then if things go pear-shape, you can just zap the .cabal-dev directory and rebuild
01:47:35 <dgriffi> tdammers: that's how I'm using pandoc right now
01:47:43 <mikeplus64> i don't think that's the "best" way. building a cabal-dev environment can take a very long time, and use a lot of disk space if you're using it for every little project
01:47:59 <tdammers> there's not really an alternative though
01:48:08 <tdammers> except for packages that you can pull from your distro's repos
01:48:17 <srhb> Which is a bad idea most of the time anyway
01:48:28 <srhb> I think dgriffi doesn't need anything but ghc-pkg unregister right now
01:48:28 <mikeplus64> the "best" way is imo to use a package manager. arch linux has good haskell/haskell-web repos
01:48:34 <srhb> What.
01:48:50 <srhb> I completely disagree with that. There are so many people having headaches with distro packaged Haskell things.
01:48:59 <tdammers> srhb: like what?
01:49:19 <srhb> Incompatibilities and weird breakages.
01:49:20 <tuv> i heard there is a haskell virtualenv. isn't it any good?
01:49:22 <mikeplus64> srhb: yes, but when the packaging is given love, everything is roses
01:49:35 * srhb shrugs
01:49:36 <mikeplus64> srhb: (ie they actually test the packages work with eachother)
01:49:45 <srhb> All I found working is using cabal and cabal-dev
01:49:52 <srhb> Having only ghc and cabal installed globally.
01:50:06 <tdammers> I have haskell-platform installed from debian
01:50:15 <tdammers> and a few packages that I use regularly
01:50:18 <mikeplus64> i don't like waiting for compiles or downloads and definitely not manually updating packages with cabal
01:50:29 * srhb shrugs -- works for me
01:50:34 <srhb> I do have a fast computer though
01:50:39 <srhb> I can imagine it would be painful on something slower
01:51:05 <tuv> http://hackage.haskell.org/package/virthualenv
01:51:15 <srhb> tuv: I think that's the deprecated one
01:51:25 <srhb> tuv: I think you want hsenv
01:51:36 <mikeplus64> i have a fairly fast computer (phenom ii x4 955 or whatever, who knows what order that's supposed to be in) but haskell compiles are still quite slow, especially if you e.g. have dynamic enabled, and profiling
01:51:57 <srhb> Ah, another argument against dynamic ( O:-) )
01:52:15 <mikeplus64> my hdd thanks me later :)
01:52:18 <dgriffi> well, I think I have pandoc-types okay
01:52:41 <srhb> dgriffi: Cool. Then for the LaTeX-writer
01:52:45 <srhb> Or what was it...
01:52:50 <supki> srhb: distro packages are usable if distro is gentoo, where maintainers bump versions all day
01:52:57 <supki> probably also works for arch
01:53:01 <srhb> Er, HTML writer
01:53:03 <mikeplus64> supki: yep
01:53:04 <dgriffi> srhb: yeah.. now to see if I can get some results with the latex writer
01:53:31 <supki> debian unstable, on the other hand, still has ghc-7.4.1 => doesn't work
01:53:41 <dgriffi> here a fork, there a fork, everywhere a fork fork
01:54:14 <tlaine> EE-I-EE-I-O.
01:54:24 <srhb> dgriffi: For what it's worth, I have a compiling version with the changes I proposed to you. Whether it actually works is another case. :-)
01:54:30 <srhb> dgriffi: I don't know pandoc.
01:54:56 <srhb> The power of types. I have no idea what I'm doing, but the types have to match up. :P
01:55:05 <mikeplus64> supki: i think ideally haskell should get its own nix-like (or emerge-like) package manager, when conflicts occur, it shouldn't really matter, so long as you don't try to use the conflicting packages together
01:55:06 <dgriffi> srhb: I'd like to see it
01:55:30 <srhb> dgriffi: I think I did exactly what I suggested you do. I added NewPage, newPage and blockToHtml _ NewPage = return "I don't know what goes here!"
01:55:59 <srhb> In definition, builder and the html writer respectively.
01:56:16 <dgriffi> in pandoc-types, I found that I had to modify two files... Builder.hs and Definition.hs
01:56:24 <srhb> Yes.
01:56:24 <dgriffi> at least it looked like I should
01:56:31 <srhb> That's what I did.
01:56:54 <srhb> I don't know how to test it though
01:56:55 <tuv> debian is frozen in preparation for releasing wheezy. everything is getting old. after the release, unstable and testing will be much more recent
01:56:56 <dgriffi> I did cabal-dev install and that seemed to go fine.  so I did "cabal install"
01:57:05 <srhb> dgriffi: Good.
01:57:27 <dgriffi> tuv: I need to get on the ball with a brother printer goofup in wheezy.. I was asked to run some tests and I haven't done them yet.
01:57:42 <srhb> dgriffi: You just need that last change to change HTML.hs in the pandoc writer then
01:57:52 <srhb> (At least I think that's all you need :-))
01:58:09 <alang> edwardk: https://github.com/alang9/ad/tree/type-familize this seems to work
01:58:19 <dgriffi> pandoc is rebuilding...
01:58:52 <edwardk> hrmm
01:58:55 <edwardk> AD ForwardDouble s Double
01:59:04 <edwardk> could probably become AD s ForwardDouble
01:59:23 <edwardk> the actual type parameter to AD is redundant once you bake it into the type family
01:59:25 <dgriffi> tuv: what distro are you running?
01:59:48 <tuv> dgriffi: debian testing
02:00:01 <dgriffi> compile finished.  still I get "Not in scope: data constructor `NewPage'"
02:00:13 <edwardk> then i think we can kill almost if not all of the Lifted functionality
02:00:19 <dgriffi> tuv: have you ever used a Brother laser printer with testing?
02:00:49 <srhb> dgriffi: That doesn't sound right
02:00:57 <tuv> dgriffi: no. not with anything ;) - i used a canon printer for a while, then then driver stopped working, so i gave in to hp
02:00:58 <srhb> dgriffi: What did you add to definition?
02:01:10 <mikeplus64> srhb: out of curiosity, how long does it take to run "ghc -O2 something.hs" where something.hs is 'main = putStrLn "wow my computer is fast"' on your "fast computer"?
02:01:21 <srhb> mikeplus64: Let me check
02:01:25 <dgriffi>     | NewPage               -- ^ Explicit pagebreak
02:01:25 <dgriffi>     | HorizontalRule        -- ^ Horizontal rule
02:01:44 <edwardk> jacobian :: (Traversable f, Traversable g) => (forall s. f (AD s ForwardDouble) -> g (AD s ForwardDouble)) -> f Double -> g (f Double)
02:01:58 <mikeplus64> ghc -O2 Test.hs  0.40s user 0.07s system 88% cpu 0.538 total
02:02:05 <edwardk> a more radical thought might be that we don'e need the AD wrapper at all since we split the mode and the infinitesimal
02:02:07 <edwardk> then youd get
02:02:16 <srhb> mikeplus64: 0.335s
02:02:37 <edwardk> jacobian :: (Traversable f, Traversable g) => (forall s. f (ForwardDouble s) -> g (ForwardDouble s)) -> f Double -> g (f Double)
02:02:50 <edwardk> we could get there pretty easily
02:02:57 <srhb> mikeplus64: For comparison, building lens and all dependencies takes about 60 seconds.
02:03:11 <srhb> dgriffi: Did you unregister pandoc-types?
02:03:15 <edwardk> the old type signature format was more a product of how we had to share an AD class and all the lifting machinery
02:03:20 <edwardk> but we don't need to do that any more
02:03:21 <srhb> dgriffi: Before installing the new version
02:03:22 <mikeplus64> srhb: try add some "big" packages to it, maybe Control.Lens, Control.Monad.State, Snap?
02:03:38 <dgriffi> srhb: no, I did --force-reinstall
02:03:50 <alang> I'm not sure I understand how to get rid of the 'a' in 'AD f s a' though
02:04:04 <edwardk> alang: it becomes a fairly big refactoring
02:04:07 <srhb> dgriffi: Hmm. Try unregistering manually, then installing your pandoc-types with cabal-install
02:04:09 <srhb> dgriffi: It works for me.
02:04:22 <srhb> mikeplus64: 0.4s with Control.Lens
02:04:45 <mikeplus64> my disk IO i think is letting me down
02:04:48 <edwardk> alang: in particular the Lifted code just becomes the normal instances =)
02:04:55 <srhb> mikeplus64: I have a rather fast SSD.
02:05:00 <mikeplus64> aha
02:05:09 <srhb> mikeplus64: (even with 128GB I don't mind static linking. :P)
02:05:10 <edwardk>     showsPrec1          :: (Domain' t a, Num a, Show a) => Int -> t a -> ShowS
02:05:18 <edwardk> becomes just normal showsPrec
02:05:31 <edwardk> and you get the instance of Show for your mode
02:06:06 <edwardk> i may need to spend time on it this weekend, with the gsoc registration and some other stuff my bandwidth for the next day or two is shot
02:06:10 <dgriffi> is "cabal-dev clean" enough to get rid of leftover stuff?
02:06:18 <mikeplus64> srhb: i didn't for a long time but eventually found when my HDD was filling up i had some GB of executables
02:06:25 <srhb> dgriffi: Only in the sandbox
02:06:48 <srhb> mikeplus64: Ok. :) Well, like I said, it's just religion. It hasn't been a problem for me yet, so I just statically link.
02:06:54 <srhb> I mean, religion on my part.
02:07:02 <edwardk> alang: basically all the template haskell has to switch from instead of making one masive Lifted instance making instances for the normal classes
02:07:25 <edwardk> alang: and then the AD type basically becomes an accessory which is used for a few polymorphic functions but isn't a fixture of all of them
02:07:36 <skp_> hi
02:08:04 <skp_> do you know a way to wite he following function in dot notation?
02:08:17 <skp_> \acc x -> acc + x*x
02:08:17 <alang> edwardk: still don't really understand, but I'll think about it
02:08:24 <srhb> dgriffi: fwiw, all I did was make the aforementioned changes, cabal-install in the types directory, then cabal-install in the pandoc library
02:08:37 <edwardk> skp_: personally i find what you wrote there more clear than the point free equivalent
02:08:38 <skp_> (+) . (^2) ?
02:08:41 <mikurubeam> @pl (\acc x -> acc + x * x)
02:08:41 <lambdabot> (. join (*)) . (+)
02:08:43 <edwardk> @pl \acc x -> acc + x*x
02:08:43 <lambdabot> (. join (*)) . (+)
02:09:08 <skp_> hm
02:09:14 <skp_> a join ?
02:09:26 <mikurubeam> @pl (\acc x -> acc + x^2)
02:09:26 <lambdabot> (. (^ 2)) . (+)
02:09:34 <edwardk> skp_: that is in the  (->) e monad
02:09:36 <srhb> dgriffi: Oh, I forgot one change I made. Add newPage to the exports from Builder.hs
02:09:49 <edwardk> skip: it turns (e -> e -> a) -> e -> a by passing the arg twice
02:09:57 <mikurubeam> skp_: In conclusion, point-free is not always the best way to do it.
02:10:19 <skp_> yeah I see
02:10:23 <skp_> thnaks
02:10:30 <skp_> thanks
02:10:38 <edwardk> skp_: in general i use point free for single argument plumbing but i tend to stop and rethink it when i have more than one arg i want to plumb and/or when i have to section operators
02:11:00 <mikeplus64> skp_: i first misread it as "do notation", and so came up with:
02:11:01 <edwardk> when it is good it can be really good, when it is bad it can be really bad ;)
02:11:08 <mikeplus64> :t (do acc <- id; return (do x <- id; return (acc + x*x)))
02:11:09 <lambdabot> Num b => b -> b -> b
02:11:22 <dgriffi> srhb: I think I figured out that one.  Looks like "newPage :: Blocks \n newPage = singleton NewPage" right?
02:11:25 <mikeplus64> > (do acc <- id; return (do x <- id; return (acc + x*x))) 2 3
02:11:27 <lambdabot>   11
02:11:36 <srhb> dgriffi: Yes.
02:11:43 <edwardk> > 2 * do 3 + 4
02:11:44 <lambdabot>   14
02:12:58 <skp_> hm
02:13:00 <dgriffi> srhb: ugh.. I think that cabal-dev is ignoring the pandoc-types I build and installed in favor of the stock thing that can be installed with "cabal install pandoc-types"
02:13:08 <srhb> dgriffi: Yes, it is
02:13:12 <skp_> flip $ (+) . (^2)
02:13:17 <skp_> it works too
02:13:20 <srhb> dgriffi: If you just want to test this, don't use cabal-dev
02:13:31 <skp_> or I can foldr
02:13:40 <srhb> dgriffi: If you've cabal install'ed your pandoc-types and then cabal install pandoc, you should be set
02:13:43 <skp_> and then remove the flip
02:15:09 <dgriffi> srhb: okay.. trying that
02:15:28 <srhb> dgriffi: Note that it should warn you about inexhaustive patterns in all the other writers.
02:15:43 <dgriffi> srhb: I haven't seen anything like that so far
02:15:47 <srhb> dgriffi: (Meaning, blockToAscii _ NewPage will cause pandoc to crash)
02:16:44 <dgriffi> srhb: from what I gather... in order to use NewPage, the reader and writer must both explicitly use it
02:16:50 <srhb> dgriffi: Indeed.
02:16:58 <dgriffi> .... and the compile failed with the same error as before
02:17:20 <`nand`> I had to get into the habit of pronouncing Haskell with an emphasis on the ‘e’
02:17:21 <srhb> dgriffi: OK, I'm not sure why you're experiecing that. I'll msg you and we can try to sort it out one by one
02:17:24 <`nand`> so people don't confuse it with pascal
02:19:11 <alang> edwardk: I think I understand now
02:20:34 <edwardk> alang: k getting a few hours of sleep =)
02:20:39 <edwardk> later man
02:21:37 <alang> good night
02:29:42 <`nand`> edwardk: that's a neat little party trick
02:29:52 <`nand`> parentheses are too mainstream
02:34:42 <hpaste> Xaratas revised “tail recursive try”: “tail recursive more tries” at http://hpaste.org/84186
02:35:29 <Xaratas> ok, i have tried this and that and still have the stackoverflow :(
02:40:44 <c_wraith> Xaratas: the old version is lazy. It produces results as needed, before recursing. that's always going to mean less stack space used than making all the recursive calls before returning any value
02:41:30 <c_wraith> Xaratas: tail recursion should not be your goal in haskell.  laziness should be your goal, when it's possible.
02:43:39 <Xaratas> c_wraith: hm, but isn't tail recursion faster? an other function which i changed to tail recursion brought 20% better runtime
02:44:08 <c_wraith> tail recursion is better if you are accumulating a result that's meaningless before the process is done
02:44:14 <c_wraith> But you're not.
02:44:42 <c_wraith> You're generating the first few elements of the list, then recursing to generate the rest
02:45:04 <c_wraith> Those first few elements can be consumed without knowing what the rest of the list is
02:45:19 <c_wraith> So you're producing partial output
02:45:37 <`nand`> tail recursion is overrated in haskell
02:45:43 <c_wraith> also, that function is just a foldr
02:45:56 <c_wraith> Writing it out makes it look *really* complicated in comparison to using foldr
02:51:45 <Xaratas> ok, thanks for the explanation; that the function is 'just' a foldr i have not seen, in the beginning i wanted such thing, but the predicates are a list of boolean, so writing takeif was an easy step
02:53:07 <c_wraith> oh, I can explain why your attempts at strictness weren't working, too.  That's probably more useful
02:54:04 <c_wraith> In every case, you were generating an expression that attempted to force the list where the list is used
02:54:16 <c_wraith> That doesn't actually do anything
02:54:32 <c_wraith> it's a variant of the x `seq` x thing
02:55:10 <c_wraith> to actually force the list before recursing, you need to make the whole recursive call the second argument to seq
02:56:09 <c_wraith> or deepseq in this case.
02:56:20 <c_wraith> (eww, that's a *ton* of wasted work)
02:56:49 <c_wraith> line 19 is actually close
03:00:09 <c_wraith> Xaratas: http://hpaste.org/84416 should be sort of close. (I can't test without all your other definitions)
03:00:34 <`ramses> the layers package for modular monad transformers looks pretty interesting. Although the documentation is not the easiest to digest
03:01:00 <`ramses> anyone played with it already?
03:01:22 <c_wraith> Xaratas: the main thing is that ($!!) is the root of the parse tree for that expression. That means that it will actually cause its second argument to be rnf'd before the recursive call is made
03:04:09 * hackagebot stringlike 0.0.0 - Transformations to several string-like types  http://hackage.haskell.org/package/stringlike-0.0.0 (FedorGogolev)
03:05:26 <c_wraith> heh.  Even if that works, it's going to be *slow*.
03:05:39 <c_wraith> It's associating the (++) operations in the wrong direction
03:07:56 <Xaratas> hm, its taking ram in steps of 2 mb, at a solw rate, which looks like the normal working of the algorithm to spit out a new result every few seconds, but than it builds this gigantig intermediate result before the final filter stage on the stack, which could only be a bad thing
03:08:18 <c_wraith> Yeah, it's pretty much worse in every possible way
03:08:46 <c_wraith> It's adding an extra O(n) work factor, and it requires the whole thing be in memory at once
03:09:08 <c_wraith> Laziness should be your goal, not tail recursion
03:09:42 <Xaratas> an extra n, i have something between O(n^2) and O(n^4), this extra n does not do any good ;)
03:10:22 <c_wraith> sounds like it does a lot of bad, in fact :)
03:11:45 <c_wraith> Xaratas: the point about the direction of (++) is important, by the way. Its arguments are not treated the same way.
03:12:13 <c_wraith> Xaratas: The first argument is copied. The second one is used without copying
03:12:44 <c_wraith> Xaratas: In your second attempt, you keep making the first argument bigger and bigger, meaning it has to copy more and more every time
03:12:57 <c_wraith> Xaratas: that's where the extra O(n) work factor is coming from
03:13:46 <c_wraith> Xaratas: in your first version, the first argument to (++) was always the small one. That meant that the part it had to copy wasn't growing with each level of recursion
03:13:48 <Xaratas> yes, i got it faster, and i can make it a bit more fast if i move a filter more to the core, but it need a full rewrite and exploit of a few mathematical propreties
03:14:35 <hpaste> “David Griffith” pasted “ghc-pkg list” at http://hpaste.org/84417
03:16:03 <srhb> Do those {} mean things are broken?
03:16:34 <hpaste> “David Griffith” pasted “pandoc  build stuff” at http://hpaste.org/84418
03:16:49 <circle> Going through a Haskell book at the moment..
03:17:02 <circle> How would I replicate the 'and' function with conditional expressions?
03:17:03 <srhb> dgriffi: Hmm, mtl is broken.
03:17:07 <srhb> :t and
03:17:08 <lambdabot> [Bool] -> Bool
03:17:12 <circle> It's trivial in other programming languages, just nest if statements.
03:17:23 <circle> But I've tried to nest if statements in Haskell and it doesn't like it one bit.
03:17:30 <srhb> > foldr (&&) True [True, True, True]
03:17:32 <lambdabot>   True
03:17:35 <elliott> haskell supports nesting if statements just fine
03:17:35 <srhb> > foldr (&&) True [True, True, False]
03:17:37 <lambdabot>   False
03:17:46 <circle> elliott: How would I do that? I want to know if both a and b are true.
03:18:02 <circle> if a then if b ... doesn't work.
03:18:09 <srhb> Yes it does.
03:18:16 <elliott> perhaps you forgot "else" for both of them
03:18:18 <elliott> or have an indentation problem
03:18:19 <srhb> > if True then if True then True else False else False
03:18:20 <elliott> @hpaste
03:18:20 <lambdabot> Haskell pastebin: http://hpaste.org/
03:18:21 <lambdabot>   True
03:18:25 <elliott> paste the code and the error, please
03:18:30 <bxc> i often find indentation problems writing if.
03:18:42 <circle> I've deleted it now, but I'll write it up again. Sec.
03:18:56 <srhb> dgriffi: So the question is, how did you get a broken mtl now.
03:19:14 <srhb> dgriffi: Did you uninstall all things Haskell and install ghc + cabal install?
03:19:21 <dgriffi> srhb: probably by my recent monkeying around
03:19:22 * hackagebot snaplet-fay 0.3.2.0 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.3.2.0 (AdamBergmark)
03:19:24 <bxc> somehow its a bit of the indentation rules that doesn't lodge properly in my brain
03:19:45 <circle> Hmm, it works here now. But that seems to be because I've put it all on one line.
03:19:55 <srhb> circle: Then it was indeed an indentation error.
03:20:17 <circle> This book is great but it doesn't tell me enough about how the indentation should be structured.
03:20:30 <srhb> circle: http://en.wikibooks.org/wiki/Haskell/Indentation
03:21:24 <circle> srhb: Thanks.
03:21:36 <Xaratas> c_wraith: i have tried both dircetions, shortlist ++ result, and result ++ shortlist, the difference was the ram usage, one version takes small bits and broke with a stackoverflow, the other takes huge chunks and broke in a out of memory, but would also die stackoverflow if there where more memory in my system
03:21:48 <srhb> circle: They are actually really simple and very flexible. As long as you're not using tabs. :P
03:21:58 <circle> srhb: I'm using tabs.
03:22:06 <srhb> circle: Then that's probably your problem.
03:22:11 <circle> srhb: I don't usually though, just haven't bothered to configure this system yet.
03:22:16 <circle> srhb: Used to python indentation.
03:22:34 <srhb> You basically will get all kinds of funky errors if you indent with tabs in Haskell. I wish the compiler would just say "NO!"
03:23:10 <srhb> Oh, -fwarn-tabs. Nice. :-)
03:24:02 <twomashi> 2 spaces or 4 spaces?
03:24:13 <srhb> Either way.
03:24:21 <srhb> Just be consistent.
03:29:35 <circle> so if I have if a
03:31:46 <hpaste> “Anonymous Coward” pasted “indent” at http://hpaste.org/84419
03:31:59 <circle> that was me
03:32:10 <circle> I've read the indentation help thing
03:32:15 <circle> but this expression doesn't work
03:32:18 <circle> how would I indent so it does?
03:32:29 <srhb> It doesn't work?
03:32:47 <circle> yeah.
03:32:53 <srhb> What's the error?
03:33:54 <circle> indentation error
03:34:00 <srhb> circle: More context, please.
03:34:02 <srhb> It works fine for me.
03:34:02 <circle> nevermind, it was in a function and I hadn't indented the if statement
03:34:07 <hpaste> circle pasted “indent” at http://hpaste.org/84420
03:34:10 <circle> it was that ^
03:34:12 <circle> but I fixed it
03:34:18 <srhb> Right.
03:34:34 <srhb> Mind, this isn't how (&&) is defined at all.
03:34:51 <circle> Obviously, lol.
03:34:57 <srhb> :P
03:35:29 <srhb> let and True True = True; and _ _ = False in and True False
03:35:33 <srhb> > let and True True = True; and _ _ = False in and True False
03:35:35 <lambdabot>   False
03:35:39 <srhb> > let and True True = True; and _ _ = False in and True True
03:35:41 <lambdabot>   True
03:35:57 <srhb> > let and True True = True; and _ _ = False in and False undefined
03:35:59 <lambdabot>   False
03:36:15 <srhb> Though of course that expands to if-then-else
03:36:25 <elliott> well, it expands to case.
03:36:37 <srhb> Right.
03:40:18 <arkeet> @src (&&)
03:40:18 <lambdabot> True  && x = x
03:40:18 <lambdabot> False && _ = False
03:40:54 <arkeet> and x y | x, y = True | True = False
03:40:58 <arkeet> ?? :p
03:40:58 <lambdabot>  :p
03:41:02 <arkeet> haha
03:41:38 <srhb> @src (||)
03:41:40 <lambdabot> True  || _ =  True
03:41:43 <lambdabot> False || x =  x
03:41:47 <arkeet> is ?? the same as @@?
03:41:48 <arkeet> @@ :p
03:41:48 <lambdabot>  :p
03:41:57 <arkeet> ?? ?pl ?src id
03:41:57 <lambdabot>  (line 1, column 1):
03:41:57 <lambdabot> unexpected end of input
03:41:58 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
03:42:01 <arkeet> uh
03:42:07 <arkeet> @@ @pl @src id
03:42:07 <lambdabot>  (line 1, column 1):
03:42:07 <lambdabot> unexpected end of input
03:42:07 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
03:42:12 <srhb> Don't break the bot! :<
03:42:13 <arkeet> well I guess it does the same thing.
03:42:17 <hpaste> investinnest pasted “ Mahavir Kalpavruksha Mumbai” at http://hpaste.org/84421
03:42:23 <ziman> @. pl src id
03:42:23 <lambdabot> (line 1, column 1):
03:42:23 <lambdabot> unexpected end of input
03:42:23 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
03:42:33 <srhb> Oh dear.
03:42:38 <mgsloan> I don't think pl handles declaration syntax?
03:42:56 <arkeet> @pl id x = x
03:42:56 <lambdabot> id = id
03:42:59 <arkeet> sure it does.
03:43:03 <arkeet> @src id
03:43:03 <lambdabot> id x = x
03:43:05 <mgsloan> well there you go :)
03:43:07 <arkeet> so what's going on?
03:43:07 <mgsloan> huh
03:43:32 <mgsloan> maybe as it says, it needs a newline at the end
03:43:48 <arkeet> hmmm
03:45:17 <`nand`> what's that subset of haskell called that's supposed to be simple to learn?
03:45:43 <mgsloan> Haskell 95? ;)
03:46:06 <`nand`> hehe
03:46:10 <mgsloan> (Not that I really think that Haskell 98 isn't simple-ish to learn)
03:46:11 <`nand`> the one that doesn't have eg. typeclasses
03:46:17 <mgsloan> right
03:46:27 <mgsloan> Haskell 95 would be a good name for that
03:46:40 <mgsloan> Oh, Fay!
03:48:37 <Yuu-chan> Gofer
03:49:28 <mgsloan> Hmm, yeah, looks like Haskell had typeclasses from the start
03:49:46 * mgsloan just looked at Haskell 1.0 report
03:49:46 <`nand`> I found it
03:49:48 <`nand`> it's Helium
03:49:57 <mgsloan> Ahh, right.
03:56:52 <[swift]> sigh
03:57:08 <[swift]> something involving laziness is seriously wrong with my program =\
03:57:52 <[swift]> whether or not it crashes is determined by whether i have a putStrLn printing out the certain values
03:58:22 <[swift]> puzzlingly, though, judicious application of $! and force don't seem to solve the problem
03:59:07 <srhb> [swift]: Perhaps you should paste your program.
04:00:01 <srhb> "The presence of a prefix is indicated with a single leading ASCII colon character (':', 0x3b)"
04:00:02 <srhb> yet...
04:00:08 <srhb> > ord ':'
04:00:09 <lambdabot>   58
04:00:22 <srhb> > 0x3b == 58
04:00:24 <lambdabot>   False
04:00:26 <srhb> > 0x3a == 58
04:00:28 <lambdabot>   True
04:00:31 <srhb> What the hell?
04:00:44 <[swift]> srhb: it's a bit large for that but the relevant function is defsAnalysis here: https://github.com/sfowler/pygmalion/blob/go-to-definition/src/Pygmalion/Analyze/Source.hs
04:01:25 <[swift]> crashes without the putStrLn
04:01:38 <srhb> without?
04:01:45 <[swift]> srhb: right
04:02:00 <srhb> presumably normalise then?
04:02:14 <srhb> Or maybe not.
04:02:59 <[swift]> indeed, i've modified the lib clang bindings and i can see that it never actually performs "show $ XRef.getUSR cursor" and similar unless the putStrLn is there
04:03:17 <[swift]> the C marshaling code never gets called
04:03:40 <[swift]> i really don't get it. i've tried a lot of things...
04:04:07 <niteria> what would you use to parse large log files (that don't fit into memory)?
04:05:05 <Xaratas> random access reader, o, wrong language
04:05:54 <srhb> [swift]: Sorry, a bit above my level. Perhaps someone else can help.
04:06:10 <[swift]> srhb: no worries, it's a bit above my level too =)
04:06:37 <srhb> [swift]: Perhaps you would get more info by narrowing down the print to exactly what thing causes it
04:06:59 <srhb> [swift]: Like try just name, kind, file, ln, col by each by themselves.
04:07:05 <[swift]> srhb: so printing _any_ one thing is enough
04:07:11 <srhb> any one thing. OK
04:07:18 <[swift]> srhb: but just "putStrLn "blah"" doesn't work
04:08:33 <srhb> Hmm. Are you pretending these values are pure when they really aren't?
04:08:45 <[swift]> srhb: the lib clang bindings are
04:08:55 <[swift]> it uses unsafePerformIO under the hood
04:09:38 <srhb> Meh, I don't know...
04:12:25 <[swift]> it is a good point that unsafePerformIO is involved, though. maybe i will try modifying things to avoid that layer of the bindings..
04:15:46 <hpaste> circle pasted “why” at http://hpaste.org/84422
04:15:55 <circle> why does the above ^ not work?
04:16:16 <srhb> It does.
04:16:57 <circle> \prac2.hs:3:6: parse error on input `|'
04:16:58 <circle> Failed, modules loaded: none.
04:17:44 <circle> srhb: ?
04:17:45 <srhb> Oh sorry
04:17:48 <srhb> That first = is a mistake
04:17:53 <srhb> grade g | ...
04:17:57 <Xaratas> ja
04:18:13 <circle> oh ok
04:18:22 <Xaratas> no = after the function name if you use guards
04:18:39 <srhb> circle: Read it as grade g for which it is true that...
04:19:04 <circle> hmm, k
04:21:36 <`nand`> circle: you have a superfluous = in line 2
04:21:39 <`nand`> it's omitted in that syntax
04:22:21 <srhb> s/superfluous/wrong :-)
04:41:32 <hpaste> quchen pasted “Creating a TH Lift instance” at http://hpaste.org/84423
04:41:46 <quchen> Hello, Quchen's daily TH problem is here!
04:42:06 <srhb> quchen: :D
04:42:19 <quchen> I'm trying to find the easiest way of defining a Lift instance this time.
04:48:01 <quchen> Maybe this is something for SO
04:48:14 <quchen> Adding a line for each constructor seems unnecessary
04:49:09 <srhb> Yeah if the TH gurus aren't here I bet SO can figure it out.
04:52:32 <ski>   lift (Even x) = [| Even $(return (lift x)) |]  -- perhaps ?
04:55:43 <elliott> ski: re: your pattern ideas: have you considered: Just (fromJust x) = x?
04:58:02 <ski> elliott : hm, not this particular form, no
04:59:39 <ski> afaics, this would necessitate a partial match
04:59:42 <quchen> ski: What you're doing just makes the whole thing longer
04:59:51 <quchen> I'm trying to get rid of mentioning "Even"
05:00:05 <ski> quchen : i thought it madee the whole thing return a different result
05:00:33 <ski> quchen : it appears that you maybe wanted CSP ?
05:00:37 <elliott> ski: right. which is the desired behaviour for fromJust
05:00:48 <elliott> Identity (runIdentity x) = x -- is fine too
05:00:56 <ski> elliott : yes, so long as you're fine with that, i think it's ok
05:01:15 <elliott> I think you can generalise this to ever-weirder stuff, like (fst p, snd p) = p (to define fst and snd), \x -> f $ x = f (to define ($)), ...
05:01:40 <ski> (btw, was this re me having talked about "message-dispatching" for record syntax, or about other pattern-syntax extensions ?)
05:01:55 <quchen> ski: Have you seen my paste? http://hpaste.org/84423
05:02:16 <ski> yes, i've considered `(fst p, snd p)' long since
05:02:30 <ski> (cf. `f (x_0,x_1,...) = ..x..')
05:02:57 <ski> quchen : yes -- but i was doubting that the instance you gave had the intended behaviour
05:03:16 <elliott> ski: this was actually just me thinking about your lambda pattern stuff and such
05:03:26 <elliott> what is the record syntax thing? sounds interesting
05:03:50 <ski> quchen : .. which was why i was wondering whether you were perhaps subconsciously wanting CSP ..
05:03:57 <quchen> CSP?
05:04:01 <ski> elliott : hm, which lambda pattern stuff was that ?
05:04:02 <ski> Cross-Stage Persistence
05:04:13 <quchen> Oh. Well that sounds like I'm not quite there yet
05:04:58 <ski> quchen : the ability to mention a variable (*any* one) from one stage inside a quotation constructing code for the next stage, so that it generates code that when evalauted will just yield the original value
05:05:03 <elliott> ski: (\exp -> pat) patterns
05:05:24 <ski> quchen : e.g. what should happen when `x :: IORef Int', in `[| x |]' ?
05:05:30 <elliott> IIRC, { f (\x -> p) = e } = { f g = case g x of p -> e }
05:05:45 <elliott> or, well, { f g | p <- g x = e } I guess
05:06:26 <ski> elliott : ok (i have been thinking about various pattern-syntax things, so i wasn't sure which one you had seen)
05:06:35 <ski> elliott : the record stuff is basically :
05:06:46 <ski>   data Stream a = Head a & Tail (Stream a)
05:06:51 <ski>   repeat :: a -> Stream a
05:06:58 <ski>   Head (repeat a) = a
05:07:06 <ski>   Tail (repeat a) = repeat a
05:07:32 <ski>   from :: Enum a => a -> Stream a
05:07:39 <ski>   Head (from n) = n
05:07:45 <ski>   Tail (from n) = from (succ n)
05:07:47 <ski> &c.
05:07:53 <elliott> ski: ah, like agda's copatterns?
05:08:13 <ski> more or less, yes (though i have to look in more detail about how those works)
05:08:23 <ski> i got the idea for this from
05:08:27 <ski> @where ErikPoll
05:08:27 <lambdabot> "Subtyping and Inheritance for Inductive Types" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/durham97.pdf>,"Subtyping and Inheritance for Categorical Datatypes" in 1997 at <http://www.cs.ru.nl/E.
05:08:27 <lambdabot> Poll/papers/kyoto97.pdf>,"A Coalgebraic Semantics of Subtyping" in 2000 at <http://www.cs.ru.nl/E.Poll/papers/cmcs00.pdf>,later version of that in 2001 at <http://www.cs.ru.nl/E.Poll/papers/ita01.
05:08:27 <lambdabot> pdf>
05:08:37 * elliott thinks "Cons" naming for this is confusing, since they're destructors
05:08:40 <elliott> maybe heaD, taiL :)
05:08:50 <elliott> hEAD, tAIL
05:09:13 <ski> (and i was tentatively calling this "message-dispatching" syntax, because this is more or less what defining an object in terms of how it responds to messages is)
05:09:27 <ski> elliott : yes, i'm not married to the concrete syntax bit
05:10:19 <ski> (also, did i say i don't like the `data Foo = MkF {blah :: Blah}' vs. `blah :: Foo -> Blah' schizophrenia ?)
05:12:12 <ski> (in SML, it would be `#head' and `#tail')
05:12:38 * elliott mumbles something about lens.
05:13:55 * ski would prefer both abstract, lens-like, fields, *and* non-braindead concrete records
05:14:48 <ski> quchen : anyway, how would what you want work for other datatypes than `EvenOdd' ? e.g. abstract ones ..
05:15:31 * elliott thinks you can define a record system from scratch with sufficiently complex lens types
05:15:41 <elliott> supporting things like full type-changing, safe construction, etc.
05:16:13 <ski> (quchen : btw, if it was unclear, i think your "This doesn't work of course, as [|x|] is simply a VarE." applies equally well to the former instance)
05:20:41 <myky> hi guys i need help with my little program ...can somebody to check it and explain me what this program works?
05:20:44 <myky> http://pastebin.com/3iRd9gMK
05:20:53 <mauke> The paste 3iRd9gMK has been copied to http://hpaste.org/84424
05:23:17 <quchen> ski: Oh. Well, I haven't thought about it much in general.
05:23:24 <ski> instead of  48  please use  ord '0'
05:23:28 <quchen> I'm learning TH by trial and error basically :/
05:23:46 <quchen> Luckily I do it for no reason, so I don't damage anything with it
05:24:15 <ski> quchen : it doesn't work at all in general, without CSP -- and even then, it doesn't yield an analyzable expression, which is arguably what `lift' is supposed to yield
05:24:41 <quchen> So \x -> [| Just x |] is not in general a way of lifting something in a Maybe?
05:24:51 <ski> myky : also, you don't handle the empty case gracefully
05:25:42 <ski> quchen : the `x' in the quotation will just be a variable name (or maybe a CSP reference), not a data structure representing code that will evaluate to `x'
05:26:29 <ski> .. unless TH does some kind of autolifting of free variables in quotations -- which i'm unaware of, though i don't know TH that well
05:26:47 <quchen> I thought [| |] uses Lift
05:27:19 <quchen> If I write [| Even 1 |], then the compiler complains there's no Lift instance for EvenOdd
05:28:24 <arkeet> quchen: what's wrong with what you wrote?
05:29:23 <myky> ski: how i fix empty handle?
05:29:45 <BadKitty> myky: empty handle?
05:29:49 <quchen> arkeet: I'm not sure. TH quickly becomes too advanced for me so I have trouble understanding explanations about it
05:30:06 <quchen> Apparently it's not always the right thing
05:30:07 <ski> myky : simplest is to not match on `x:xs'
05:30:33 * BadKitty wonders why people and ghc do `code' ?
05:30:54 <BadKitty> ` open ' close O.o
05:31:00 <quchen> BadKitty: To troll typographers
05:31:16 <ski> because TeX, i think
05:31:18 <BadKitty> quchen: It gets annoying :P
05:31:36 <BadKitty> ski: Okay. Blame TeX :)
05:31:38 <quchen> Yeah it used to make me shiver too, but you get used to it
05:32:00 <quchen> In TeX, `` isn't an opening quote. `` is what when you compile it produces an opening quote.
05:32:00 <BadKitty> quchen: Yea, used to it, but when you notice it's just ughh. (Better when you know why)
05:32:03 <BadKitty> :)
05:32:24 <quchen> \emph isn't italics, it produces italics. Same argument.
05:32:49 <quchen> On the other hand, there are no quotation marks on a normal keyboard anyway, so I guess you have to abuse some other symbol
05:32:58 * BadKitty wonders if there is any haskell tls for dummies example :)
05:33:28 <yitz> BadKitty: maybe it's because of m4 </troll>
05:33:28 <quchen> TLS = Tumor Lysis Syndrome?
05:33:44 <BadKitty> yitz: IRC /= HTML
05:33:50 <BadKitty> yitz: IRC /= \HTML
05:33:57 <BadKitty> (escaped HTML)
05:34:11 <quchen> BadKitty: troll isn't HTML anyway
05:34:24 <yitz> BadKitty: invalid HTML, with missing open tag
05:34:26 <BadKitty> quchen: </troll> is impl..
05:34:29 <BadKitty> s/HTML/XML/
05:34:43 <BadKitty> implying XML :)
05:34:57 <yitz> BadKitty: ok, SGML derivatives
05:35:28 <BadKitty> WHY IS THERE NO SIMPLE TLS EXAMPLE D:
05:35:46 <applicative> Times Literary Supplement?
05:35:48 <quchen> TLS = Trinity Law School?
05:35:56 <BadKitty> @hoogle tls
05:35:56 <lambdabot> package tls
05:35:56 <lambdabot> package tls-extra
05:35:56 <lambdabot> package gnutls
05:35:58 <BadKitty> ^
05:36:06 <yitz> BadKitty: what do you want to do with tls?
05:37:22 <BadKitty> yitz: In short/development purpose, use it to be lazy instead of making my own payload length send/recv functions. But in practice/desired used, to encrypt traffic encoded to binary form.
05:39:40 <yitz> BadKitty: usually tls is used by integrating into some other system, to wrap some specific network protocol. which one do you have in mind?
05:40:23 * ski . o O ( Tow Lherzite Step )
05:41:01 <BadKitty> yitz: More or less in-development.. data TComm = TAction Action | TToken Token | IMayAdd MoreHere
05:41:17 <BadKitty> binary encode/decode.
05:41:58 <BadKitty> I may switch to cereal concidering that tls uses cereal it's self so dealing with just strict bytestrings instead of both strict and lazy seems more ideal.
05:42:25 <BadKitty> (For this case at least)
05:43:11 <turiya> hi
05:44:23 <turiya> i am compiling ghc-7.0.3 using ghc-6.10.4 but i get an error saying that hscolour could not be found. any way to fix it? i am installing ghc somewhere in my home directory as i dont have root access
05:44:35 <BadKitty> yitz: Any suggestions for where to start?
05:44:52 * BadKitty client/server currently over a unix socket but I'll be moving to a port for production. :)
05:45:02 <BadKitty> tcp/port *
05:45:21 <quchen> turiya: You don't need to compile GHC yourself if it's a supported OS. You can just download and extract the binaries
05:45:59 <turiya> quchen: i think this os is too old (rhel 5.6) and does not have the correct glibc
05:46:17 <BadKitty> turiya: shell server?
05:46:23 <BadKitty> (Ask admin to upgrade)
05:46:33 <applicative> turiya , can you turn of the documentation making? or you need that?
05:46:48 <turiya> BadKitty: it is a cluster and the admin said he wont upgrade :)
05:46:55 <BadKitty> (Or use a better shell/vps >> http://linode.com for example, major upgrades recently(yesterday))
05:46:58 <BadKitty> :D
05:47:01 <applicative> turn off rather
05:47:37 <quchen> turiya: Install a VM ;-D
05:48:08 <turiya> applicative: i don't know if it is a documentation issue
05:48:18 * BadKitty recommends arch on linode.com; ghc always up to date (well close to when not)
05:48:50 <applicative> turiya: oh, I thought thats all hscolour was used for?
05:49:18 <bitonic> turiya: you can just use the precompiled binaries available here anyway: <http://www.haskell.org/ghc/>.  and you should use the GHC shipped with the platform, if possible
05:49:31 * BadKitty doesn't mean to advertise... Just a great service that an irc friend works for and happens to host the server I am ssh'd into to get on IRC. :) >> In fact, I'm trying to make something for her shell service as it's invite only.. :)
05:49:53 <turiya> there seems to be a --with-hscolour option in configure
05:50:10 <BadKitty> Tokenizer, generating and managing tokens for all users. At first the idea was for just registration but the tokens will be used for more tasks.
05:50:30 <turiya> bitonic: i think the precompiled versions dont work because of old glibc
05:50:34 <quchen> linode.com looks like they're hosting on a RasPi
05:50:42 <quchen> Except for the CPU count
05:50:42 <turiya> quchen: i will try vm
05:50:47 <bitonic> turiya: that can be a problem, yes
05:50:51 <quchen> Maybe it's a Raspi cluster :D
05:50:56 <BadKitty> quchen: hehe, problem with the ram?
05:51:09 <BadKitty> quchen: You generally shouldn't need much ram..
05:51:21 * BadKitty 's desktop peek ram usage >> 700M
05:51:48 <quchen> I like having a lot of RAM so I can have memory leaks in GHCi without swapping.
05:51:59 <quchen> (I say that because I don't have a lot of RAM.)
05:52:38 <BadKitty> And that's with firefox with some evil websites (ram, ram, ram, ram, cpu D:)
05:52:49 <BadKitty> Close firefox and I'm < 300M :)
05:53:04 <quchen> Yeah same here
05:53:06 <BadKitty> (Could go much lower if I desire, but no need)
05:53:10 <quchen> Plus my window decorator is leaky too
05:53:29 <BadKitty> quchen: window decorator as in transparent terminals, shadows?
05:53:44 <quchen> Yes
05:53:56 <BadKitty> xorg/compositing window manages + NotMuchRam = ioError "Need moar ram"
05:54:10 <quchen> But I love mah Compiz
05:54:16 <BadKitty> compton here
05:54:27 <BadKitty> quchen: http://i.imgur.com/bOsg45K.jpg
05:54:34 <BadKitty> http://i.imgur.com/d3vYEeA.jpg
05:54:57 <myky> all thanks for help
05:55:14 <quchen> BadKitty: -> #haskell-blah
05:55:16 <BadKitty> quchen: first is more recent
05:55:18 <BadKitty> quchen: >>
05:55:38 <yitz> BadKitty: well snoyberg is using tls and tls-extra for current development of network-conduit-tls
05:56:48 <yitz> BadKitty: you can actually use network-conduit-tls, it might be a better approach than trying to control IO laziness yourself for a low-level network library
05:57:11 <tdammers> my window decorations are wasteful for xmonad standards
05:57:14 <BadKitty> yitz: I'm kinda after low-level to the type.
05:57:16 <tdammers> two whole pixels on each side
05:57:35 <yitz> BadKitty: but even if not, you'll certainly find practical use of the tls and tls-extra in the code for network-conduit-tls
05:57:43 <fizbin> :t (>.>)
05:57:45 <lambdabot>     Not in scope: `>.>'
05:57:45 <lambdabot>     Perhaps you meant one of these:
05:57:45 <lambdabot>       `>>' (imported from Control.Monad.Writer),
05:57:55 <fizbin> :t (>>)
05:57:56 <lambdabot> Monad m => m a -> m b -> m b
05:58:09 <BadKitty> yitz: Indeed
05:58:13 <fizbin> :t (Control.Monad.Writer.>>)
05:58:15 <lambdabot> Monad m => m a -> m b -> m b
05:58:54 <yitz> BadKitty: snoyberg's libraries tend to be focused on actually working in real life, so you might find out about tls gotchas by looking in there
06:00:30 <yitz> quchen: no, -> #xmonad ;)
06:00:59 <fizbin> Hey, why doesn't :t work in a /msg to lambdabot ?
06:01:54 <yitz> fizbin: yeah weird looks like the bot only wants @type now
06:01:57 <elliott> you have to say @type or ?type
06:02:00 <yitz> in pms
06:02:01 <elliott> nobody knows why. it's only for /msg
06:02:18 <fizbin> Weird.
06:02:48 <elliott> "@ty" IIRC works as a shortcut.
06:03:08 * Hermit usually reads that as "thank you"
06:03:40 <mikurubeam> Is there any way to check what modules have been imported in lambdabot?
06:04:44 <BadKitty> mikurubeam: see his source
06:04:45 <ski> @where L.hs
06:04:45 <lambdabot> What lambdabot has in scope is at <http://code.haskell.org/lambdabot/State/L.hs>
06:04:46 <BadKitty> !source
06:04:47 <ski> perhaps ?
06:04:55 <ski> (BadKitty : s/his/her/)
06:05:00 <BadKitty> ski: heh
06:05:09 <mikurubeam> BadKitty: ski: ty
06:05:18 * BadKitty wonders how ski knows lambdabot is a she O.o
06:05:36 <BadKitty> mikurubeam: Don't thank me, ski's lambdabot foo is better than mine. :)
06:05:56 <ski> BadKitty : <http://kejo.be/ELIS/haskell-blah_lambdabotContest.html>
06:06:07 <Chousuke> why is . defined as fmap?
06:06:33 <ski> Chousuke : because Cale
06:06:43 <arkeet> cale :(
06:06:49 <ski> `fmap' is a valid generalization of `(.)'
06:06:59 <BadKitty> ski: O.o
06:07:04 <BadKitty> \bot makes more sense :)
06:07:11 <ski>   fmap :: Functor f => (a -> b) -> (f a -> f b)
06:07:18 <arkeet> except (.) gets used pretty often with :t and then it's confusing when it's fmap
06:07:19 <beaky> hello
06:07:23 <ski> set `f' to `(rho ->)', which is a functor, then you get
06:07:32 <arkeet> why rho>?
06:07:35 <beaky> why are haskell data types "algebraic"?
06:07:39 <ski>   fmap :: (a -> b) -> (rho -> a) -> (rho -> b)
06:07:41 <ab9rf> because rho is a sexy letter
06:07:53 <arkeet> beaky: because we have sums and products.
06:08:01 <ski> which fits the type (and behaviour) of `(.)'
06:08:10 <beaky> sums and products?
06:08:19 <ski> arkeet : it's a traditional letter for the environment parameter
06:08:23 <ab9rf> beaky: yes, you can perform algebra on types
06:08:30 <arkeet> Either a b = Left a | Right b is a sum
06:08:43 <arkeet> (a,b) is a product
06:08:47 <ski>   Either a b  ~=  a + b
06:08:53 <ski>   (a,b)  ~=  a * b
06:08:58 <arkeet> () ~= 1
06:09:01 <arkeet> Void ~= 0
06:09:01 <arkeet> etc.
06:09:02 <ski>   [a]  ~=  1 + a * [a]
06:09:10 <arkeet> [a] = 1/(1 - a)
06:09:15 <arkeet> :p
06:09:18 <ski> (iow, .. what arkeet said)
06:09:21 <beaky> ah
06:09:28 <beaky> :t (~=)
06:09:29 <lambdabot>     Not in scope: `~='
06:09:29 <lambdabot>     Perhaps you meant one of these:
06:09:29 <lambdabot>       `/=' (imported from Data.Eq), `<=' (imported from Data.Ord),
06:09:45 <ski> `~=' meant to be read as "is isomorphic to"
06:09:48 <beaky> oh
06:10:03 <arkeet> or "corresponds to"
06:10:07 <beaky> so a sum is liek set union?
06:10:13 <arkeet> disjoint union
06:10:22 <beaky> ah
06:10:27 <ski> (or we probably want "naturally isomorphic to, in the parameters" ? or perhaps something even more restrictive ?)
06:10:29 <arkeet> and product is cartesian product of course.
06:10:44 <turiya> at the linking stage i get "recompile with -fPIC" : how do i do that?
06:10:45 <arkeet> or the product in the sense of category theory.
06:10:47 <fizbin> What do I import to get the Functor definition of (.) ?
06:10:50 <arkeet> (and sum is coproduct)
06:10:52 <beaky> are aleberaic data types related to the "abstract data types"?
06:10:54 <ski> set union (and set intersection) is only defined for *subsets*
06:11:04 <ski> beaky : not per se
06:11:08 <arkeet> fizbin: you don't; you define it yourself if you want.
06:11:17 <arkeet> beaky: yes, they both abbreviate as ADT
06:11:20 <beaky> heh
06:11:23 <arkeet> and that's it.
06:11:24 <turiya> any ideas
06:11:31 <ab9rf> hah
06:11:46 <fizbin> arkeet: I mean, when I ask ghci :t (.) it gives me (.) :: (b -> c) -> (a -> b) -> a -> c
06:11:49 <fizbin> But:
06:11:51 <fizbin> :t (.)
06:11:53 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:11:59 <arkeet> fizbin: yes, so you can redefine (.) if you want
06:12:02 <arkeet> hide the Prelude version and make your own.
06:12:20 <Hermit> fizbin: lambdabot has a few quirks like that, for it uses a custom prelude
06:12:32 <fizbin> :info (.)
06:12:46 <arkeet> lambdabot is also not ghci.
06:13:25 <beaky> are all haskel adts purely-functional?
06:13:38 <arkeet> I don't understand the question.
06:13:39 <Hermit> so far the feature I like the most is @src
06:13:43 <ski> beaky : what do you mean by "adt" and "purely-functional" ?
06:13:50 <srhb> Hermit: Unfortunately it almost never works. :P
06:13:51 <arkeet> Hermit: @src is pretty dumb, it just looks things up in a fixed database
06:13:54 <arkeet> @where src
06:13:54 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
06:14:04 <ab9rf> beaky: virtually everything in haskell is "purely functional", and the parts that aren't tend to be well-hidden or encapsulated
06:14:05 <beaky> like the data you declare with 'data Foo a = Bar a  | Baz a a
06:14:13 <srhb> But I'm totally working on a new lambdabot, so rejoice!
06:14:24 <arkeet> who isn't?
06:14:25 <yitz> beaky: they are immutable, if that's what you mean. the constructors are lazy functions by default, unless you override that with !
06:14:26 <srhb> :P
06:14:34 <srhb> arkeet: You're supposed to motivate me!
06:14:42 <ski> (beaky : note, "ADT" can expand to either of "Algebraic Data Type" or "Abstract Data Type" -- please disambiguate)
06:14:42 <fizbin> Ah, yes. @src (.) answered my question about lambdabot's (.) implementation.
06:14:51 <beaky> algebraic data types :D
06:14:59 <fizbin> > (+2) . [4,5,6,7]
06:15:00 <yitz> srhb: what do mean, why is a pithy insult called "not working"?
06:15:01 <lambdabot>   [6,7,8,9]
06:15:36 <arkeet> Cale: can we fix (.) ?
06:15:50 <arkeet> even Category's . would be better.
06:15:52 * ski liked when `flip' was fixed
06:16:03 <arkeet> but I'd like the prelude version.
06:16:04 <Pods> I am having issues installing ghc on my system . .can anyone help
06:16:05 <ski> (onlike now)
06:16:05 * arkeet too
06:16:15 <ski> (s/on/un/)
06:16:22 <elliott> arkeet: there's also (++).
06:16:26 <arkeet> oh yeah.
06:16:27 <elliott> I think that's the remaining Caleskellism.
06:16:30 <ski> @type flip  -- see, unfixed :/
06:16:30 <arkeet> no, that was fixed.
06:16:31 <lambdabot> (a -> b -> c) -> b -> a -> c
06:16:32 <arkeet> :t (++)
06:16:33 <lambdabot> Monoid m => m -> m -> m
06:16:36 <arkeet> no never mind.
06:16:39 <arkeet> ok, Cale.
06:16:40 <arkeet> fix it.
06:16:41 <arkeet> :(
06:16:47 <arkeet> :t (<>) -- we don't need ++ with this
06:16:49 <lambdabot> Monoid m => m -> m -> m
06:16:51 * Hermit votes in favor of (++) == mappend
06:16:55 <srhb> Pods: What's the problem?
06:16:57 <elliott> last I heard Cale doesn't want to budge on (.). which is a great shame because it means we have to studiously avoid lambdabot when teaching people about (.)
06:16:57 * arkeet votes against
06:17:01 <elliott> which is near impossible.
06:17:09 <arkeet> that's exactly why I want Prelude..
06:17:16 <arkeet> we already have <$> if we want an infix fmap
06:17:25 <elliott> and I don't buy the lambdabot isn't for pedagogy argument, because that's it's most useful and ubiquitous purpose...
06:17:27 <yitz> elliot: let (.) = (Prelude..) in ...
06:17:35 <arkeet> that's a lot of typing to do every time.
06:17:40 <arkeet> and a lot of noise to ignore.
06:17:46 <arkeet> or get confused by.
06:17:52 <yitz> i agree though, i never liked setting (.) = fmap in lambdabot
06:18:17 <elliott> yitz: sure, and then the newbie wonders why you do that, and says :t (.)...
06:18:47 <osfameron> presumably someone could host their own fork of lambdabot with the appropriate definition of (.)...
06:18:59 <yitz> but the pedagogical arguments are a little weak. Cale himself, at times, as been by far the most active and successful teacher on the channel.
06:19:10 <elliott> osfameron: how is that superior to just fixing it?
06:19:23 <elliott> it's not like anyone actually uses the generalisation when using lambdabot, perhaps outside of code golf
06:19:24 <Pods> srhb : this is what running make after config gives me http://dpaste.com/1030134/
06:19:30 * hackagebot neat-interpolation 0.1.1 - A quasiquoter for neat and simple multiline text interpolation  http://hackage.haskell.org/package/neat-interpolation-0.1.1 (NikitaVolkov)
06:19:34 <aCube> > (+3) . [1,2,3]
06:19:36 <lambdabot>   [4,5,6]
06:19:37 <ab9rf> you could be even more confusing and have lambdabot choose its environment based on who's talking to it
06:19:42 <arkeet> and even in golf it's cheating.
06:19:50 <osfameron> elliott: it's not.  but if whoever could fix it won't, then it has the advantage of being possible.
06:19:52 <srhb> Pods: Looks like you need the development libraries for curses
06:19:53 <yitz> osfameron: oh no that is way overkill. just unleash your own lambdabot. but i would suggest speaking to srhb first though...
06:20:31 <Pods> srhb: you mean seperate installation for them is needed ?
06:20:31 <srhb> I'm working on it. Don't expect it to be done tomorrow, though. :)
06:20:35 <srhb> Pods: Yes
06:20:40 <ski> @poll-add (++)
06:20:41 <lambdabot> Added new poll: "(++)"
06:20:47 <magicman> :t flip
06:20:49 <lambdabot> (a -> b -> c) -> b -> a -> c
06:20:52 <arkeet> :t (??)
06:20:53 <lambdabot> Functor f => f (a -> b) -> a -> f b
06:20:57 <Pods> okay will try . thanks srhb
06:20:57 <ski> @choice-add (++) :: [a] -> [a] -> [a]
06:20:57 <lambdabot> usage: @choice-add <poll> <choice>
06:21:11 <ski> @choice-add (++) "(++) :: [a] -> [a] -> [a]"
06:21:11 <lambdabot> usage: @choice-add <poll> <choice>
06:21:24 <arkeet> @choice-add "(++)" "(++) :: [a] -> [a] -> [a]"
06:21:24 <lambdabot> usage: @choice-add <poll> <choice>
06:21:27 <arkeet> great.
06:21:28 * ski shakes head
06:21:29 <aCube> @help poll
06:21:30 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
06:21:33 <ab9rf> arkeet: you made it unhappy
06:21:48 <Clint> i think it was already unhappy
06:21:49 <aCube> @vote "(++)"
06:21:50 <lambdabot> usage: @vote <poll> <choice>
06:22:03 <ab9rf> obviously "(++)" is not an acceptable name for a poll
06:22:06 <aCube> @vote "(++)" "(++) :: [a] -> [a] -> [a]"
06:22:06 <lambdabot> usage: @vote <poll> <choice>
06:22:09 <fizbin> @poll-show (++)
06:22:09 <lambdabot> []
06:22:15 <srhb> osfameron, yitz: I plan to allow several active environments
06:22:16 <yitz> @choice-add (++) (++)::[a]->[a]->[a]
06:22:16 <lambdabot> New candidate "(++)::[a]->[a]->[a]", added to poll "(++)".
06:22:33 <Kinnison> choices may not have whitespace?
06:22:40 <aCube> @vote (++) (++)::[a]->[a]->[a]
06:22:41 <lambdabot> voted on "(++)::[a]->[a]->[a]"
06:22:42 <srhb> osfameron, yitz: Right now it's a bit primitive, you name them before the >.. Like srhbs> :t (.)
06:22:50 <yitz> Kinnison: apparently not, or at least i don't know the quoting convention.
06:22:55 <ski> @choice-add (++) (++)::Monoid_m=>m->m->m
06:22:55 <lambdabot> New candidate "(++)::Monoid_m=>m->m->m", added to poll "(++)".
06:23:05 <srhb> I think I will end up having one global standard that follows closely to a barebones Haskell install
06:23:12 <srhb> and then optionally one defined for each registered user
06:23:12 <fizbin> @vote (++) (++)::[a]->[a]->[a]
06:23:13 <lambdabot> voted on "(++)::[a]->[a]->[a]"
06:23:22 <Kaidelong> @choice-add (++) (++)::Semigroup_m=>m->m->m
06:23:22 <lambdabot> New candidate "(++)::Semigroup_m=>m->m->m", added to poll "(++)".
06:23:26 <srhb> osfameron: How does that sound?
06:23:29 <fizbin> @poll-show (++)
06:23:29 <lambdabot> ["(++)::Semigroup_m=>m->m->m","(++)::Monoid_m=>m->m->m","(++)::[a]->[a]->[a]"]
06:23:49 <osfameron> srhb: sounds good, yeah
06:24:08 <ski> Hermit ^
06:24:26 <ski> @poll-result (++)
06:24:26 <lambdabot> Poll results for (++) (Open): (++)::Semigroup_m=>m->m->m=0, (++)::Monoid_m=>m->m->m=0, (++)::[a]->[a]->[a]=2
06:24:40 <Hermit> sorry ski, I'll vote for monoid :-)
06:25:05 <hpaste> “Weird Error” pasted “powergiant” at http://hpaste.org/84426
06:25:10 <ski> Hermit : just meant to direct your attention to the availability of the poll ..
06:25:17 <ski> (so, no need to be sorry ?)
06:25:38 <Hermit> @vote (++) (++)::Monoid_m=>m->m->m
06:25:38 <lambdabot> voted on "(++)::Monoid_m=>m->m->m"
06:26:10 <aCube> @help poll
06:26:11 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
06:26:13 <arkeet> Hermit: but we already have (<>)
06:26:17 <powergiant> Can someone explain that error to me? it seems very weird to me
06:26:22 <aCube> @poll-result (++)
06:26:23 <lambdabot> Poll results for (++) (Open): (++)::Semigroup_m=>m->m->m=0, (++)::Monoid_m=>m->m->m=2, (++)::[a]->[a]->[a]=2
06:26:24 <ab9rf> :t zip
06:26:26 <lambdabot> [a] -> [b] -> [(a, b)]
06:26:40 <powergiant> well that explains it..
06:26:42 <powergiant> thanks! :P
06:26:49 <Hermit> arkeet: hmm  /me reads about semigroups
06:26:51 <ab9rf> powergiant: could you post source, and not just the error?
06:26:53 <ski> arkeet : we already have `liftM' as well
06:27:20 <ski> powergiant : should perhaps be `... :: [(Double,Double)]' ?
06:27:27 <ab9rf> powergiant: i think the problem is that you're trying to bind the wrong type to the result of the zip
06:27:29 <arkeet> ski: but that at least has a (poor) reason for existing, as Functor isn't a superclass of Monad
06:27:29 <ion> @vote (++) (++)::Semigroup_m=>m->m->m
06:27:30 <lambdabot> voted on "(++)::Semigroup_m=>m->m->m"
06:27:36 <arkeet> ski: who knows why liftA exists, though...
06:27:38 <ski> powergiant : or maybe you wanted to use `zipWith' ?
06:27:52 <ion> arkeet: So you can easily define fmap in terms of your Applicative instance
06:27:57 <ab9rf> zip can't match a type of [Double], ever
06:28:01 <arkeet> ion: oh, fair
06:28:06 <ab9rf> zip is [(a,b)]
06:28:08 <powergiant> ab9rf: The :t call made my realize it.. I wanted [(Double,Double)]
06:29:00 <Pods> srhb : installed n curses , the error i am getting now is dpaste.com/1030145/
06:29:07 <Hermit> oh, so semigroups were monoids without mempty all along
06:29:40 <srhb> Pods: That's the output of ./configure?
06:29:48 <ab9rf> powergiant: i only did that to be certain i had the type of zip right :)
06:30:06 <Pods> srhb : no that is for make
06:30:10 <turiya> is ghc useful with --with-rts=no
06:30:16 <powergiant> ab9rf: Ahh ok. I took it to be a friendly hint about actually understanding what types I was using hehe
06:30:20 <srhb> Pods: What does configure say_
06:30:27 <ab9rf> powergiant: that was serendipity :)
06:30:41 <Hermit> arkeet: <> looks like "not equal" to me (greater or less)
06:31:03 <`nand`> it's somewhat surprising that one actually meets other haskell programmers at events like these
06:31:06 <ab9rf> Hermit: that's what it meant in old ROM Basic
06:31:08 <`nand`> wouldn't have expected it
06:31:54 <Hermit> ab9rf: it's not like basic was the only language to adopt that operator...
06:31:58 <ab9rf> Hermit: >< meant the same thing in some dialects; you could also use <= and =< interchangably
06:32:02 <Pods> srhb : http://dpaste.com/1030148/ this is my configure
06:32:32 <ab9rf> Hermit: i think SQL allows <> for not-equal
06:32:56 <srhb> Pods: I've no idea why you get that ld error.
06:33:09 <Hermit> ab9rf: yep, that's it
06:33:38 <ab9rf> Hermit: i saw one dialect that allowed <=>, =<>, etc., all mapping to an infix operator that was vacuously true
06:33:41 <Pods> srhb : Any ideas about how should I proceed hereon??
06:33:54 <srhb> Pods: Hope that someone else that knows more responds. :)
06:34:10 <Pods> same here!!
06:34:27 <Hermit> anyway, I still haven't heard of a good reason why (++) should be [a] -> [a] -> [a]  instead of mappend. After all, lists are monoids
06:34:35 <ab9rf> Hermit: which gave insight to how they implemented comparison operators :)
06:34:47 <arkeet> Hermit: by the same argument, (.) should be fmap
06:34:59 <Hermit> arkeet: prelude compliance?
06:35:48 <int-e> @type Control.Category.(.)
06:35:49 <lambdabot> Couldn't find qualified module.
06:35:54 <arkeet> @type (Control.Category..)
06:35:55 <int-e> @type (Control.Category..)
06:35:56 <lambdabot> Control.Category.Category cat => cat b c -> cat a b -> cat a c
06:35:57 <lambdabot> Control.Category.Category cat => cat b c -> cat a b -> cat a c
06:36:42 <Hermit> ab9rf: what was <=> suposed to mean anyway?
06:37:01 <saml> Hermit, equivalent
06:37:08 <Hermit> no kidding
06:37:13 <ab9rf> Hermit: in fact, i think in standard SQL only <> is allowed for not-equal, although many dialects allow != as a nonstandard extension
06:37:23 <ab9rf> Hermit: in BASIC?  it was not defined.
06:38:01 <Hermit> ab9rf: no, I meant the dialect (of, uh...) you mentioned above
06:38:18 <ab9rf> Hermit: that was in some versions of BASIC i've used in eons gone by
06:38:32 <ab9rf> Hermit: a <=> b was true for all a and b.
06:38:45 <arkeet> less than or equal or greater than.
06:38:46 <Hermit> pretty pointless if you ask me...
06:39:00 <ab9rf> Hermit: it's because of how they parsed the operator
06:39:00 <arkeet> ab9rf: was NaN <=> NaN true?
06:39:12 <ab9rf> arkeet: NaN?  what is that? :)
06:39:15 <arkeet> lol
06:39:20 <Hermit> ab9rf: not a number
06:39:22 <arkeet> ok, no floats.
06:39:29 <Hermit> oh
06:39:30 <ab9rf> arkeet: even if they had floats they didn't have NaN
06:39:46 <arkeet> what was 0/0 then?
06:39:49 <ab9rf> arkeet: we're talking stuff written in the 70s and early 80s
06:39:54 <arkeet> sure.
06:40:03 <ab9rf> arkeet: a program halt
06:40:09 <arkeet> sure.
06:40:18 <Hermit> well, even early 80s predates me so....
06:40:38 <Hermit> err, that didn't sound right now that I double check it...
06:40:54 <Hermit> s/predates/pre-dates
06:40:56 <Hermit> there
06:41:00 <ab9rf> these interpreters dealt with comparison operators by scanning the operator, if they saw < then it would be true if less than, = would be true if equal, > would be true if greater
06:41:03 <arkeet> Hermit: no, predates
06:41:10 <ab9rf> you could do a ========== b and the interpreter would not are
06:41:11 <ab9rf> care
06:41:34 <Hermit> arkeet: thought for a second 'predates' had something to do with predators or something
06:41:58 <arkeet> it may
06:42:07 <ab9rf> a <=> b was literally "a is less than, equal to, or greater than b" and would be true as long as a and b were comparable
06:42:07 <b__> is there a way to set a max execution time on a function?
06:42:10 <Hermit> that's why
06:42:17 <arkeet> except it doesn't.
06:42:19 <ab9rf> and an error if they weren;t
06:42:35 <FireFly> ab9rf: I wonder if that's where <> for "inequal" is from
06:42:37 <Hermit> arkeet: good to know.
06:43:49 <ab9rf> i remember that this was a hard thing for me to unlern when i started writing code in pascal
06:44:09 <beaky> how does data.map work
06:44:10 <int-e> b__: Have a look at System.Timeout.
06:44:21 <b__> alright, thanks
06:44:22 <ab9rf> the basic dialect i learned first allowed mushy comparison operators  and i had gotten into the habit of using <= and =>, and pascal didn't allow =>
06:44:50 <ab9rf> i don't remember what not-equal was in pascal
06:44:51 <numeral> in math <=> is iff
06:45:01 * numeral is just putting it out there
06:45:08 <arkeet> wow, I don't remember either.
06:45:14 <ab9rf> numeral: in perl <=> is the three-way comparison operator
06:45:32 <numeral> that's just wrong on so many levels
06:45:46 <arkeet> ah, in pascal it's <>
06:45:59 <ab9rf> arkeet: thought so but wasn't certain
06:46:09 <ab9rf> i haven't written any pascal since the late 80s
06:46:17 <ski> hm, isn't Pascal `<>' Haskell `/=' ?
06:46:21 <arkeet> yes
06:46:40 <Kinnison> Lua's is ~= just for funsies
06:46:40 <ab9rf> haskell is /= which is fairly unusual in modern languages, ost everyone has gone with != since C did so
06:47:02 <ski> in Prolog, the non-strict comparisions are `>=' and `=<'
06:47:19 <ab9rf> Kinnison: that drives me nuts about lua
06:47:21 <arkeet> on my ti-89 it's ≠
06:47:23 <arkeet> :p
06:47:27 <Kinnison> ab9rf: it does?  I like it
06:47:28 <Hermit> I find lambdas more unusual, with the scape syntax
06:47:40 <ab9rf> arkeet: it's the same in APL except you have to actualy overstrike the / over the = :)
06:47:49 <arkeet> whaaat?
06:48:06 <ab9rf> arkeet: APL used deliberate overstrikes
06:48:08 <FireFly> APL syntax is always fun
06:48:22 <ab9rf> insane language.  it was my fourth i think
06:48:49 <Hermit> to think there's people writing big pieces of software in K nowadays...
06:48:50 <ab9rf> i scored a tiny APL interpreter for the trash-80 in like 1984?
06:48:53 <Hermit> gives me shivers
06:49:00 <ab9rf> Hermit: K being the successor to J?
06:49:12 <Hermit> ab9rf: no, K and J are brothers
06:49:20 <ab9rf> i looked at J back in the early 90s. i knew a guy who was writing text processing apps in APL back then
06:49:29 <Hermit> ab9rf: or the heroes of the men in black...
06:50:06 <Hermit> ab9rf: J is used for number crunching, K is for... other things....
06:50:10 <ab9rf> J was iverson's attempt to pull APL into the "modern" era and not need overstriking :)
06:50:41 <FireFly> J looks rather ugly though, compared to APL :\
06:50:46 <ab9rf> FireFly: yes
06:50:52 * Hermit would definitely like a calculator that runs J
06:50:59 * FireFly too
06:51:12 <Hermit> for a couple of months J was my de-facto console calculator
06:51:14 <FireFly> (well, preferably using more APL-y characters)
06:51:19 <Hermit> until I forgot the syntax
06:51:56 <ab9rf> J uses . and : for a lot of things and the language looked like a pigeon shat all over your screen after a while
06:52:17 <Kinnison> ⍨ has to be one of the best characters I've ever seen in a programming language though
06:52:27 <ab9rf> Kinnison: not renderable in my terminal font :(
06:52:34 * Hermit can't see that char
06:52:46 <Kinnison> ab9rf: looks like a long ~ with two dots above it, like a confused face emoticon, only the right way up
06:52:53 <Hermit> terminus should expand it's unicode horizons
06:53:02 <arkeet> it's
06:53:07 <merijn> ab9rf: Get a better terminal font :p
06:53:08 <Hermit> its*
06:53:12 * Kinnison uses inconsolata for terminal font usage
06:53:18 * arkeet uses whatever
06:53:26 <ab9rf> Kinnison: what code page is that one?
06:53:27 <ab9rf> on
06:53:43 <Kinnison> U+2368 APL FUNCTIONAL SYMBOL TILDE DIAERESIS
06:53:43 <Kinnison> UTF-8: e2 8d a8  UTF-16BE: 2368  Decimal: &#9064;
06:54:01 <merijn> Adobe released an open source monospace font not too long ago, might be worth looking at if you want better unicode coverage
06:54:33 <ab9rf> i'm not even sure what font i'm using here anymore :)
06:54:52 <Kinnison> heh
06:54:53 * merijn uses Monaco, which is great, but not freely available AFAIK
06:54:59 <ab9rf> ah, ten point consolas
06:55:05 <merijn> ugh
06:55:12 <ab9rf> meh, i'm lazy
06:55:16 <Kinnison> After a long time fiddling with different options, I settled on Inconsolata as being the least dreadful of the free ones
06:55:20 <merijn> I switched to 14pt a longtime ago
06:55:30 <ab9rf> i'm still young enough to use small fonts :)
06:55:39 <Hermit> merijn: menlo ftw :D
06:55:42 <ab9rf> merijn: i used to use 8pt, though, i'm getting older
06:55:46 * Kinnison appears to use 10pt 
06:55:57 <ab9rf> 14pt would occupy way too much screen real estate
06:56:04 <Kinnison> I could make it smaller, but I like to sit back from my screen and the lighting in here makes smaller glyphs harder to read
06:56:11 <merijn> Hermit: Menlo is just small in width for me
06:56:25 * ski challenges "right way up"
06:56:29 <merijn> ab9rf: I have a 21 inch wide screen, I prefer not straining my eyes
06:56:38 <Kinnison> ski: :-P  (as it where)
06:56:41 <Kinnison> where? were!
06:56:43 <merijn> For the others: http://blogs.adobe.com/typblography/2012/09/source-code-pro.html
06:56:43 * Kinnison needs new fingers
06:56:48 <ab9rf> merijn: i'm using a laptop with a 15" screen, so real estate is liited
06:56:56 <ski> Kinnison : that's the right way around, yes
06:57:15 <Kinnison> merijn: I prefer the 0 to have a stroke not a dot
06:57:24 <merijn> That's Adobe's open source monospace font, looks pretty decent. It was designed for source code so the glyphs are nice and readable, like iIlL1 difference and oO0
06:57:55 <Kinnison> merijn: IIRC, there were a few other reasons I disliked it. (I tried SCP and went back to Inconsolata)
06:58:02 <FireFly> Otherwise DejaVu Sans Mono is pretty decent IMHO
06:58:35 <Kinnison> Well, while this has been fun -- I have another annoyingly open-ended question about Haskell libs
06:58:37 <merijn> I really like Monaco and Menlo, but they're not freely available except OSX, afaik
06:58:57 <Kinnison> What is the preferred method for sending email from within a Haskell app?  (doesn't have to work on Windows, but bonus points if it does)
06:59:10 <ab9rf> ugh
06:59:14 <ab9rf> i hate sending mail
06:59:26 <Kinnison> So do I -- but a project I'm about to embark on will need to
06:59:30 <merijn> Kinnison: Depends, do you have access to a proper mail serve?
06:59:50 <Kinnison> merijn: I'm prepared to say "Yes, I have non-SSL access to an SMTP server which will trust me and relay"
07:00:14 <merijn> Kinnison: Then just pluck some random SMTP library and point it at that? That's usually by far the easiest
07:00:25 <Kinnison> merijn: that gets me SMTP, but not email message construction
07:00:29 <Pods> can someone help me with getting my ghc geared up
07:00:34 <Kinnison> merijn: I'd rather not be gluing strings together myself if I can avoid it
07:00:36 <Pods> need to start developing for haskell
07:00:38 <ab9rf> Kinnison: ah
07:01:03 <ab9rf> Kinnison: it's the "how do i build an email" part you want dealt with, not the "how do i deliver it to a MTA"
07:01:10 <Kinnison> ab9rf: Both
07:01:29 <ab9rf> GAH! I HATE COMPUTES
07:01:30 <merijn> Kinnison: Most SMTP libraries in python have email datatype to work with, I'm not sure how it works in the haskell libraries, but considering the simplicity of SMTP I wouldn't be that worried...
07:01:32 <Kinnison> ab9rf: I'll get to the "And now I want to GPG encrypt it too" later :-)
07:01:45 <fizbin> @hackage mime-mail
07:01:45 <lambdabot> http://hackage.haskell.org/package/mime-mail
07:01:46 <merijn> Kinnison: Pipe it through GPG using fork() ;)
07:02:14 <Kinnison> fizbin: that looks plausible, ta.
07:02:18 <ab9rf> merijn: the problem with email is that it's not that simple anymore
07:03:26 <ab9rf> it's simple if you have non-SSL non-TLS access to an SMTP server that will relay for you without authentication, but if that's not the case then you have a massive stack of shit to pull in
07:03:36 <merijn> ab9rf: How so? The difficult part is sender trust, which is irrelevant if you have a proper mail server to relay over
07:03:49 <Kinnison> frankly I can assume a /usr/bin/sendmail too -- so I think mime-mail looks perfect
07:04:18 <ab9rf> Kinnison: if you can assume a sendmail, then just use that, it's far easier than doing network pootery
07:05:43 <Kinnison> ab9rf: Mmm, mime-mail supports running via sendmail so that's perfect
07:06:11 <Kinnison> For my next trick, I need to put all of this together into a terrifyingly fun web service.  yay Happstack
07:06:15 <Kinnison> thanks chaps
07:07:32 <b__> I want to set a timeout (System.Timeout) on a writeBS (from Snap) that's waiting for a result from a Parsec parser. Can I wrap the writeBS in an IO computation somehow?
07:08:06 <b__> unsafePerformIO? =}}
07:09:40 <arkeet> return?
07:09:53 <arkeet> (not really)
07:10:27 <ab9rf> wee
07:10:27 * ski wonders what the type of `writeBS' is
07:10:48 <notdan> How can I run cabal-dev ghci from haskell-mode?
07:11:03 <notdan> It appears that somehow I need to change the current directory to my project one
07:11:21 <ab9rf> i want somethig that will move the wet clothing from the washer to the dryer without me having to get up from my chair.
07:11:28 <b__> writeBS :: MonadSnap m => ByteString -> m ()
07:11:31 <powergiant> ab9rf: a wife ?
07:12:25 <ab9rf> powergiant: danger, will robinson
07:12:46 <earthy> ab9rf: a washer dryer combo?
07:12:56 <arkeet> MonadIO is a superclass of MonadSnap, no?
07:13:18 <arkeet> I guess that doesn't help.
07:13:22 <arkeet> liftIO goes the wrong way.
07:13:24 <ab9rf> i was thinking that i could enslave one or more of the children to do that
07:13:33 <ab9rf> but my daughter is at school and my son is still asleep
07:13:43 <Pods> I need someone to please install ghc for me !!
07:13:59 <b__> arkeet yeah, liftIO goes the wrong way
07:13:59 <Pods> or well just point out the issue
07:14:13 <ab9rf> Pods: you have odd errors
07:14:40 <Pods> ab9rf : nevertheless I am dying to contribute..what do we do ??
07:15:04 <ab9rf> Pods: use a different computer? :)
07:15:15 <arkeet> Pods: are you installing the haskell platform?
07:15:23 <Pods> arkeet : yes
07:15:42 <Pods> ab9rf : as much as I would like that , students here are allowed only 1
07:16:16 <notdan> Hm, also searching the haddock does not work for me in haskell-mode, I get funny urls like: http://www.haskell.org/ghc/docs/latest/html/libraries//%60GHC-List%27.html%23v:head
07:16:30 <Pods> arkeet : so to install haskell is why i needed ghc , which isnt working, is there any other way ??
07:17:09 <arkeet> ghc comes in the platform.
07:17:29 <arkeet> what's the problem?
07:18:15 <Pods> installing haskell gave me an error that it couldnt locate ghc
07:18:37 <Pods> are you saying that installing haskell directly should make it work ??
07:19:00 <arkeet> what?
07:19:06 <arkeet> what exactly are you installing?
07:19:24 <Pods> I want to develop in haskell
07:19:34 <Pods> so I am looking to install the haskell platform
07:19:46 <Clint> on what?
07:19:53 <Pods> on ubuntu
07:19:56 <Pods> 11.10
07:20:19 <Pods> and so I came across a documentation which says prerequisite for haskell is ghc
07:20:27 <arkeet> that comes with the platform.
07:20:31 <Clint> Pods: apt-get install haskell-platform
07:20:39 <Pods> and so i ended up installing ghc and then never getting through with it
07:20:40 <Pods> oh
07:20:47 <Pods> thanks Clint
07:20:50 <Pods> will try that
07:21:40 <ab9rf> i can't imagine only having one computer
07:21:55 <ab9rf> i mean, i remember back when i only had one computer
07:22:02 <ab9rf> but that was a _long_ time ago
07:22:14 <Pods> I hope contributing with gsoc resolves that part atleast :D
07:24:01 <geekosaur> note that if you installed a ghc that is not the one the haskell-platform metapackage expects, it may demand that you remove it first
07:24:02 <Pods> Thanks so much :D this was a command line away !! <mental-note : must not follow random documentations thoroughly :D >
07:26:20 <arkeet> ubuntu 11.10 is ancient no?
07:27:01 <arkeet> platform 2011.2.0.1.2 :s
07:27:23 <Clint> surprisingly, both are from 2011
07:37:22 <tlawson> New user question: Is there a more direct function for setting record fields than a lambda (e.g. \s -> record{field=s})?
07:39:10 <Pods> arkeet : the latest one 12.* version dont support development too well
07:39:21 <supki> tlawson: no
07:39:33 <Pods> I find 11.10 the best..mac culture is not much deep rooted here
07:40:37 <arkeet> what ghc does platform 2011.2 come with, anyway?
07:40:50 <arkeet> 7.0.x?
07:41:08 <tlawson> supki: thanks.
07:41:23 <ski> also see lenses
07:42:08 <arkeet> or rather, lens
07:42:22 <fizbin> Is it standard Haskell style when writing a tuple across several lines to write the comma at the beginning of the second (and later) lines, lined up with the open paren on the first line? I'm seeing that in this article and it took me a while to convince myself there wasn't any weird syntax I hadn't seen before going on.
07:42:45 <ski> fizbin : i do that. no idea about standard
07:42:46 <Pods> arkeet : yes 7.4
07:42:48 <supki> fizbin: I use it everywhere
07:42:53 <earthy> fizbin: it's quite common
07:43:25 <ski> (and similarly with literal lists and records)
07:43:26 <arkeet> I don't understand "yes 7.4", are you agreeing with me?
07:43:31 <arkeet> 7.4 wasn't released until 2012
07:43:40 <typoclass> fizbin: i guess it makes it harder to forget a comma by accident
07:43:58 <ski> also makes it easier to line up the commas
07:44:22 <fizbin> I guess? It's just such a radical departure from other languages that use vaguely-similar syntax.
07:44:23 <timtom> fizbin: i use it
07:44:35 <Pods> well i was struggling with installing the 7.4 tar
07:45:01 * ski is pro- lining-up stuff
07:45:27 <k00mi> I find it makes editing the list/tuple/record easier, since one can just comment out or add a line and the commas still match up
07:45:28 <fizbin> e.g., while one could write a json array exactly that way too, people would look at you weird.
07:45:29 <timtom> fizbin: it also allows you to easily comment out / delete every element except the first one
07:46:07 <aCube> The other style allows the same, except for the last one
07:46:21 <ski> but is ugly, or awkward
07:46:34 <ski> (ugly if you don't line up. awkward if you do line up)
07:46:43 * typoclass uses that too, but couldn't really say why. i guess it's to make the overall structure clear ... "tuple with three elements"
07:46:50 <fizbin> I guess what's weird is that when you write it on one line you always write (thingA, thingB) or (thingA,thingB) but never (thingA ,thingB)
07:46:54 <typoclass> fizbin: it's a style choice. either one is fine
07:47:14 <ski> fizbin : i've written the latter of those many times
07:47:47 <ski> (usually to line up with a `,' from a pair on another line)
07:48:05 <fizbin> Right, but when I see (thingA ,thingB) I think I'm back reading the innards of a lisp quasi-quote expression.
07:48:15 <aCube> How do you format the export lists of modules?
07:48:18 <aCube> a
07:48:52 <ski>   module Foo
07:48:57 <ski>     ( foo
07:49:02 <ski>     , bar
07:49:05 <ski>     ) where
07:49:10 <aCube> oh, I do
07:49:13 <aCube> module Foo (
07:49:18 <aCube>     
07:49:27 <aCube> module Foo (
07:49:29 <aCube>     A
07:49:32 <aCube>    , B
07:49:37 <ski> (and then the rest of the module indented two spaces, with possible exceptions for "commenting chunks of code out")
07:49:42 <aCube> lol I dodn't get it right in chat
07:49:55 <aCube> module Foo (
07:49:58 <mikurubeam> aCube: hpaste?
07:49:59 <aCube>     foo
07:50:06 <aCube>   , bar
07:50:16 <parcs> encapsulation is overrated. export everything!
07:50:16 <aCube>   ) where
07:50:18 <typoclass> aCube: please use hpaste for code > 1 line
07:50:23 <aCube> typoclass: ok
07:51:08 * ski . o O ( "please use <http://hpaste.org> for pasting code" ? )
07:51:29 <notdan> > :info head
07:51:30 <lambdabot>   <hint>:1:1: parse error on input `:'
07:51:33 <notdan> @info head
07:51:33 <lambdabot> head
07:51:35 <notdan> hm
07:51:42 <ski> @index head
07:51:42 <lambdabot> Data.List, Prelude
07:52:06 <ski> @undo head
07:52:06 <lambdabot> head
07:52:12 <ski> @help info
07:52:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:52:28 <notdan> Strange. It seems that in my build of GHC, 'head' is located in GHC.List
07:52:30 <ski> (i.e. "no such command")
07:52:47 <notdan> which breaks inferior-haskell-find-haddock
07:52:47 <ski> notdan : implementation details
07:52:54 <ski> hm, interesting
07:53:13 <aCube> head :: [a] -> a        -- Defined in `GHC.List'
07:53:39 <notdan> Yeah, and if you try to C-c C-d on it, it'll take you to a non-exiting .html doc
07:59:03 <int-e> notdan: well, that is where head is defined. The thing that breaks it is a haddock hack: GHC.List has -- #hide in its source code, so all haddocks from there are generated in modules reexporting functions from GHC.List instead, that is, Data.List.
08:01:03 <ski> so the broken thing is `inferior-haskell-find-haddock' still looking for `GHC.List' ?
08:01:25 <int-e> iow, :i in ghci is not a reliable way for finding out where haddock put the accompanying documentation.
08:03:22 <int-e> that said I don't know how to do it properly.
08:23:27 <amyers> chrisdone's haskell-docs seems to do pretty well
08:23:38 <amyers> I haven't really used it a lot though
08:26:03 <mm_freak> Ralith: as said, i'm happy to help, but please be patient for now =)
08:30:21 <beaky> hello
08:30:28 <beaky> how do i translate a class hierarchy to haskell
08:30:49 <srhb> You don't really do that. Have you read about the antipattern wrt class hierarchies?
08:31:59 <beaky> nope
08:32:43 <beaky> why are class hierarchies bad
08:34:05 <ski> afaiu, even object gurus discourage deep class hierarchies
08:35:34 <jrajav> Object gurus also encourage composition over inheritance
08:35:36 <jrajav> But then Java :/
08:35:54 <beaky> http://ideone.com/OdjstA atm I have this huge class hierarchy
08:36:11 <ab9rf> beaky: that sounds like a problem you need to deal with
08:36:16 <beaky> because I have several kinds of employees with different attributes related to payment policies
08:36:27 <beaky> but I don't know how to reduce it to a single type :(
08:36:47 <ab9rf> beaky: you owe me a fifth of bourbon just for looking at that code
08:37:07 <dario> type Employee = Intern | NonPaydEmployee | Paydemployee
08:37:33 <beaky> heh yeah object-oriented code can get very messy
08:37:47 <ab9rf> beaky: especially when it's a dumb model
08:38:05 <beaky> dario: but with that definition, how can I add/change new employee payment policiy definitions at runtime?
08:38:21 <ab9rf> beaky: you can't do that with this class hierarchy either
08:38:27 <beaky> ah
08:38:34 <beaky> how come?
08:38:44 <ab9rf> you can't add a new class to the hierarchy at run time
08:38:52 <beaky> oh
08:39:07 <yezariaely> I wondered if there is any multimap library? My cabal responds with "No matches found" on multimap.
08:39:30 <beaky> but it seems to make sense: every employee is a person, and every specialization of employee is an employee subtype, a bonus salary employee is a salaried employee, and employers are people
08:39:30 <ab9rf> beaky: i realize that tis is a a standard OO 'learning exercise' but it's phenomenally stupid
08:39:41 <beaky> what makes it terrible?
08:40:01 <ab9rf> beaky: the fact that if your company changes its pay policies you have to rewrite the application
08:40:11 <beaky> ah right;
08:40:27 <beaky> and serialization would be hard
08:41:09 <ab9rf> invariably you'll discover that there are endless 'special cases' in any organization
08:41:36 <ab9rf> and if you use a class model like this you end up having lots of classes that apply only to one person
08:41:45 <supki> yezariaely: Map k [v] or Map k (Set v) is not good enough?
08:41:50 <dcoutts> yezariaely: if you can't find a specific lib for it on hackage, you can of course use a Map k [v]
08:42:14 <ab9rf> it's a dumb example that only makes sense to people who have enver actually tried to write or use a payroll application :)
08:42:28 <beaky> hmm; so what kind of design will account for such variety in payment policies?
08:42:31 <beaky> hah
08:42:37 <tdammers> the reason why OOP is so insanely popular in the corporate world is that it looks as if it maps 1:1 on organisation structures and business processes
08:42:40 <hkBst_> ab9rf: so what does make sense? A compensation description DSL?
08:42:44 <tdammers> but the sad part is, it actually doesn't
08:42:57 <ab9rf> tdammers: that's a generl problem with OOP
08:43:16 <ab9rf> tdammers: OOP _seems_ to map onto conceptual objects, but when you dig into it it usually doesn't
08:43:34 <ab9rf> hkBst_: o
08:43:36 <ab9rf> gah
08:43:39 <ab9rf> damn keyboard
08:43:42 <tdammers> OOP does map onto something conceptual, but that something is just a bit more abstract than the real-world objects you're trying to model
08:43:47 <beaky> OOP objects end up being way more abstract than stuff
08:43:47 <simpson> Could you all just say "Java" instead of "OOP" please?
08:44:03 <tdammers> simpson: no. It applies to other OOP languages too
08:44:07 <beaky> maybe C++ too
08:44:15 <tdammers> C++, Java, C#, ...
08:44:18 <tdammers> PHP, even
08:44:21 <simpson> tdammers: Even those without classes?
08:44:33 <ab9rf> well PHP is just java with extra warts
08:44:48 <ab9rf> ruby's model is slightly different but not materially
08:44:48 <simpson> ab9rf: Uh, what. Not even close.
08:44:54 <jfischoff> are there any packages out there that help with tracking and restarting long running processes?
08:45:10 <Pods> does haskell have an interpreter like python ??
08:45:10 <tdammers> I'd rather say PHP is just half of misunderstood Perl with half of Java's OOP semantics tacked onto it
08:45:21 <srhb> daily PHP rant?
08:45:23 <Kinnison> jfischoff: I tend to leave that to something dedicated to the job like systemd
08:45:23 <tdammers> Pods: not quite, but there's runghc and ghci
08:45:25 <beaky> hmm maybe prototype-based oop can solve that kind of problem
08:45:29 <`ramses> Pods: ghci
08:45:33 <ab9rf> simpson: PHP's object model is java's viewed through a fairly crappy mirror and implemented by baboons
08:45:36 <yezariaely> supki: Well, yes, this would work fine. Just wondered if there is some which smoothly integrates all aux functions like map and such in the map. When using Map k [v] I always have to nest the maps, folds, ...
08:45:50 <Pods> can we try implementing one maybe as a part of (say) gsoc
08:45:55 <yezariaely> *map and such in MultiMap
08:46:12 <tdammers> yezariaely: I wouldn't be surprised if lens had an answer for you
08:46:28 <simpson> ab9rf: Well, no. For starters, classes are completely optional in PHP and you can write code that looks like Pascal without any extra effort.
08:46:31 <yezariaely> lol lens is like 42. The answer to everything, isn't it ;-)
08:46:50 <yezariaely> but thanks!
08:46:54 <tdammers> yezariaely: yes, that is my understanding ;)
08:46:54 <ab9rf> tdammers: PHP is a melange of features from varius languages, lumped together by vaguely incompetent developers.
08:46:55 <srhb> yezariaely: Except "which library should I read to understand Haskell?"
08:47:05 <edwardk> yezariaely: to work with traversals of sam the elements in a list contained in a map you can just use traverse a couple of times
08:47:13 <tdammers> hehe
08:47:16 <ab9rf> simpson: i was only talking about PHP's object model, not about the language more broadly
08:47:24 <tdammers> mention lens, and edwardk wakes up
08:47:26 <edwardk> > traverse (traverse (+1)) $ fromList [1,[2,3,4]]
08:47:27 <lambdabot>   Not in scope: `fromList'
08:47:27 <lambdabot>  Perhaps you meant one of these:
08:47:27 <lambdabot>    `IM.fromList' ...
08:47:31 <edwardk> > traverse (traverse (+1)) $ M.fromList [1,[2,3,4]]
08:47:33 <lambdabot>   Couldn't match expected type `(k0, t0 (f0 b0))'
08:47:33 <lambdabot>              with actual ty...
08:47:37 <edwardk> > traverse (traverse (+1)) $ M.fromList [(1,[2,3,4])]
08:47:39 <lambdabot>   No instance for (GHC.Num.Num (f0 b0))
08:47:39 <lambdabot>    arising from a use of `e_111234'
08:47:39 <lambdabot>  ...
08:47:40 <ab9rf> simpson: the non-object aspects of PHP are probably most informed by perl
08:47:55 <Pods> Is any prospect mentor for gsoc here ??
08:48:09 <supki> > M.fromList [("hello", [1,2,3]), ("world", [4,5,6])] & mapped . mapped +~ 1
08:48:11 <lambdabot>   fromList [("hello",[2,3,4]),("world",[5,6,7])]
08:48:16 <tdammers> ab9rf, simpson: hence, half of misunderstood Perl with half of Java's OOP semantics tacked onto it
08:48:36 <tdammers> IIRC, PHP started as a collection of Perl scripts
08:48:37 <johnw> Java OOPS semantics
08:48:44 <srhb> PHP is probably off-topic unless there's a concrete Haskelly thing in there :-)
08:48:49 <ab9rf> tdammers: that's a fairly accurate description, although it fails to convey the proper level of revulsion that one should have :)
08:48:54 <jfischoff> Kinnison: I like to be able to save out partial results and have them restarted from there
08:48:55 <edwardk> well, here i don't have any effects, so
08:48:58 <edwardk> > fmap (map (+1)) $ M.fromList [(1,[2,3,4])]
08:49:00 <lambdabot>   fromList [(1,[3,4,5])]
08:49:15 <edwardk> and this is equivalent to the lens solution
08:49:21 <jfischoff> edwardk is here!
08:49:32 <Kinnison> jfischoff: Some kind of persistable continuations?
08:49:33 <johnw> edwardk!
08:49:35 <dcoutts> Pods: I'm sure there's several people, but you should say what you're interested in
08:49:36 <ab9rf> as to the payroll thingy, i'd think you'd want some way to represent a payroll scheme, and each employee would be assigned to a payroll scheme
08:49:40 <ion> jfischoff is here!
08:49:42 <edwardk> heya jfischoff, watching your maxent video as i head out the door
08:49:45 <edwardk> nice talk
08:49:49 <Pods> Like just now I was using ghci
08:49:50 <quchen> srhb: PHP is OT. Reason:  is faster than C++, more concise than Perl, more regular than Python, more flexible than Ruby, more typeful than C#, more robust than Java, and has absolutely nothing in common with PHP. (By Audrey Tang)
08:49:55 <ion> What video?
08:49:55 <ab9rf> actually embedding the payroll logic into the employee is a bad move
08:49:59 <yezariaely> edwardk: thx, got it.
08:50:15 <Pods> and it seems to me that it is not as intuitive for haskell as say python's interpreter  is
08:50:18 <jfischoff> edwardk: I'm thinking of it as a work in progress …  the whole talking thing
08:50:24 <ab9rf> the payroll scheme assigned to an employee can change over time, either as the employee's status changes or as the company changes payroll schemes
08:50:29 <jfischoff> ion: http://www.reddit.com/r/haskell/comments/1aqem6/bahaskell_talk_on_maximum_entropy/
08:50:31 <Pods> So i was wondering if we have a project for gsoc in that domain
08:50:32 <ion> jfischoff: Thanks
08:50:35 <ab9rf> so making it an inherent property of the employee is doubly bad
08:51:43 <dcoutts> Pods: plausibly. So there's basically two approaches: 1. think of a cool project yourself and find someone who's interested to mentor you, 2. pick one of the projects that a mentor has already indicated they're interested in doing
08:51:52 <dcoutts> Pods: the latter is usually easier
08:52:27 <Pods> dcoutts : I totally agree, so i merely wondering if a project of this sort is available .
08:53:06 <Pods> Is there a list of any possible projects. I wanted to play around with some code and do some bug fixing
08:53:09 <dcoutts> Pods: so our org's trac hasn't been updated yet for 2013, but you can see the old ones http://hackage.haskell.org/trac/summer-of-code/
08:53:19 <jfischoff> Kinnison: I think that is probably closer to what I want, in the sense that I am looking for the right abstraction for restartable processes…and a library to help me work with them
08:53:24 <Kinnison> Pods: In what way is ghci less intuitive (for a haskell programmer) than python's REPL is (for a python programmer) ?
08:53:26 <ab9rf> beaky: i was working at a cmpany when they switched from paying payroll on friday to paying it on tuesday.  think about how your class-based system will cope with that.
08:54:05 <Kinnison> jfischoff: Seems to me that some kind of persistable continuation is the obvious approach.  Of course, obvious does not always equal easy :-(
08:54:28 <jfischoff> Kinnison: or natural
08:54:53 <Kinnison> jfischoff: I guess.  I need to play with the Cont monad at some point
08:55:03 <Kinnison> jfischoff: some combination of Cont and State and some magic might be a basis for you
08:55:03 <jfischoff> it could be awkward … but I think it is the right direction
08:55:04 <Pods> Kinnison : A very basic example will be like , in writing a haskell program I do not have to make a let x = [1..] statement , it is initialized directly , while in ghci I would need to follow the "let syntax"
08:55:18 <jfischoff> Kinnison: yeah I think that is good point
08:55:20 <Pods> Python on the other hand doesnt need a seperate documentation for its interpretor
08:55:40 <Kinnison> Pods: Hmm, I guess unless you realise ghci is effectively in a 'do' yeah, that could be confusing
08:55:52 * Kinnison wonders if changing the default prompt to 'do >' might be enough of a hint
08:56:07 <Pods> yes , might be better off for a beginner
08:56:15 <johnw> Kinnison: that's not a bad idea.  I use ">>> " so I can copy/paste into a docstring and use doctest.
08:56:29 <timtom> Kinnison: full ack
08:56:48 <beaky> so I shouldn't use OOP to implement a payroll system?
08:56:58 <simpson> beaky: What does that even *mean*?
08:57:00 <donri> or just make let-less bindings work as let?
08:57:18 <Kinnison> donri: I think that'd be more confusing (for me at least)
08:57:25 <ab9rf> beaky: you shouldn't use that object model
08:57:35 <Kinnison> donri: esp. once you start using foo <- bar in the repl
08:57:49 <ab9rf> beaky: youc an use OOP, but you probably shouldn't use classes to represent differences in employee payroll status.
08:57:54 <beaky> ah
08:57:54 <donri> Kinnison: you can already do other top-level declarations and they overwrite old ones
08:57:58 <ab9rf> beaky: or at least not use inheritance for that
08:58:03 <ab9rf> beaky: use composition instead
08:58:21 <ab9rf> beaky: this is offtopic for #haskell, though
08:59:09 <Kinnison> donri: I meant that once you use foo <- bar syntax in ghci, the fact that you say 'let foo = bar' makes sense, and confusing the issue with allowing 'foo = bar' in ghci would (I think) cause more problems for people learning do sugar in the first place.
08:59:24 <beaky> hmm maybe if I used haskell I could design a more effective payroll system
08:59:43 <beaky> one that is functional
09:00:21 <Pods> Kinnison : what would be the conceptual difference in saying foo < - bar and let foo = bar ??
09:00:34 <Kinnison> Pods: foo <- bar involves unwrapping the IOness
09:01:11 <tac> It's the difference between unwrapping a delicious candy bar and being the incarnated act of unwrapping a delicious candy bar
09:01:30 <Chousuke> let foo = bar literally means bar equals foo.
09:01:43 <lambdafoo> When an data structure is using records e.g. data Foo = Foo { a :: Int } , how do I refer to a explicitly in a function passed a Foo parameter. i.e. bar x@Foo{..} = a * 2
09:01:55 <johnw> i would say it means that foo is another name for bar
09:01:55 <johnw> "equality" is a slippery notion
09:02:02 <lambdafoo> how do I refer to a in the function bar ?
09:02:09 <timtom> whereas foo <- bar is desugared into bind and function application
09:02:10 <ab9rf> lambdafoo: bar Foo a = a * 2
09:02:22 <ab9rf> lambdafoo: sorry, need parens
09:02:28 <ab9rf> lambdafoo: bar (Foo a) = a * 2
09:02:37 <ski> lambdafoo : `bar Foo {a=blah} = blah*2' ?
09:02:37 <johnw> lambdafoo: since you're using RecordWildcards with {..}, just use "a"
09:02:43 <timtom> bar Foo{a=value} = value * 2
09:02:49 <ab9rf> lambdafoo: you can also do bar Foo {a=x} = x*2
09:02:50 <ski> also s/a=blah/a/ with punning
09:02:52 <johnw> bar Foo {..} = a * 2
09:02:53 <Chousuke> johnw: well, I suppose that's right. Though I don't think it is possible for bar not to equal foo if they're just different names for the same thing
09:02:56 <lambdafoo> ah! I don't have RecoveryWildcards turned on.
09:03:16 <ab9rf> recovery?
09:03:17 <danr> recovery wildcards?
09:03:29 <lambdafoo> RecordWildcards sorry.
09:03:39 * ski recovers some wildcards
09:03:39 <johnw> Chousuke: i think you're right, it's just that internally, there aren't two values, so that it's like saying that a thing is equal to itself
09:03:42 <danr> ah. I thought I had missed an interesting-sounding extension
09:03:55 <donri> Kinnison: so we should remove support for data declarations etc then? :)
09:04:34 <Kinnison> donri: Mmm, I get your point
09:04:44 <Kinnison> donri: not sure then.
09:05:14 <Pods> Chousuke : you mean they are the same contrary to all the above explanations ??
09:05:35 <ab9rf> buh
09:05:37 <Chousuke> Pods: foo <- bar is something completely different.
09:05:52 <donri> Kinnison: i think it's far more common that people type "x = y" and get confused at the error, than people typing "import" and getting confused at it working
09:05:59 <Pods> sorry there was suddenly too much to process
09:06:28 <ab9rf> donri: being confused by unexpectedly useful behavior is a serious problem :)
09:07:06 <donri> Kinnison: there are also other dissimilarities to 'do' in ghci, for example you can evaluate pure expressions without a 'return'
09:08:00 <Pods> Kinnison : what do you mean by IOness ??
09:09:33 <monochrom> prince : princess :: ion :: ioness
09:09:47 * ion
09:09:50 <Chousuke> :P
09:10:10 <timtom> :D
09:10:45 <timtom> her majesty, the ioness of glasgow
09:10:46 <Kinnison> donri: mmm
09:10:57 <Pods> oh :D
09:11:02 <Pods> I get it now :D
09:13:28 <Beetle_jada> hello people
09:14:09 <Taneb> Hey, Beetle_jada
09:14:21 <Beetle_jada> :)
09:15:24 <Beetle_jada> what is the best way for finding out how to use nonstandard packages on hackage? (such as http://hackage.haskell.org/package/indents-0.3.3)
09:15:36 <Beetle_jada> the haddock for it is quite brief
09:15:53 <monochrom> ask the authors
09:16:23 <monochrom> switch to a package that you understand
09:16:53 <typoclass> Beetle_jada: often, reading the source is helpful. you can click the 'source' link on the right hand side
09:16:54 <Beetle_jada> i could peruse these examples of people using it i suppose https://github.com/search?q=import+Text.Parsec.Indent&ref=simplesearch&type=Code
09:17:07 <Beetle_jada> typoclass: yes, i tried that. it was a little bit
09:17:32 <typoclass> Beetle_jada: oh, i like the idea with the github search, that's clever
09:17:48 <Beetle_jada> i also created a question on stackoverflow http://stackoverflow.com/q/15549050/952580
09:18:15 <Beetle_jada> i could email my stackoverflow question to the author
09:18:28 <Beetle_jada> or i could just peruse that stuff on github
09:18:40 <beaky> if CLRS is the book for imperative algorithms and data structures, is there a book for purely-functional algorithms and dat astructures?
09:18:45 <ab9rf> wee
09:18:46 <Beetle_jada> i think i will probably throw my brain at the stuff on github and see if it breaks
09:18:55 <ab9rf> don't break github :)
09:19:01 <Beetle_jada> no, breaks my brain i mean
09:19:07 <ab9rf> oh, we don't care about that
09:19:12 <Beetle_jada> :D
09:19:16 <Pods> So if a and b are 2 functions and i say a <- b means all the arguments passed to a will be same as b and the retuen values too will be same even if the function in itself is different right ??
09:19:28 <ab9rf> hm, the ncurses bindings dump core for me
09:20:02 <Beetle_jada> Pods: that doesn't look right but perhaps i missed something from earlier
09:20:06 <monochrom> if a and b are 2 functions, then "a <- b" is unlikely to make sense
09:20:08 <fizbin> Pods: Um, you've gotten confused. '<-' means slightly different things in different contexts. Where are you seeing it?
09:20:33 <donri> @where okasaki -- beaky
09:20:34 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
09:21:18 <Pods> fizbin : I am basically reading on some documentations for ghci and trying to make sense of the different usages of foo = bar and foo <- bar
09:21:51 <Beetle_jada> beaky: the two books for haskell that i like the best are: (book 1) http://learnyouahaskell.com/ and (book 2) http://book.realworldhaskell.org/ (in that order)
09:21:58 <ab9rf> <- has a number of different semantic meanings
09:22:07 <ab9rf> = is pretty consistent though
09:22:22 <fizbin> That is, '<-' in a list comprehension means something subtly different from '<-' in a "do" block.
09:22:29 <Pods> Beetle_jada : it was in reference to a statement made earlier saying that while foo = bar means equality , foo <- bar means transfer of IOness , where IOness for me was interpretable in the context of functions
09:22:33 <beaky> ah thanks
09:22:52 <Pods> fizbin : precisely what was confusing me
09:23:03 <fizbin> Pods: Ah, you're talking then about what '<-' means inside a "do" block.
09:23:08 <Pods> yes
09:23:20 <monochrom> you can type "x <- getLine" into ghci. getLine is not a function. and x will not be either.
09:23:21 <hiptobecubic> I don't really know how to describe '<-'. It's a just a *feeling* :)
09:23:51 <Mortchek> a <- b inside a do block binds the "result" of b to a. Whatever "result" means for the given monad
09:24:04 <fizbin> Okay, inside a "do" block, 'x <- y' means roughly 'y >>= \x ->'
09:24:13 <timtom> why does <- have a different meaning in a list comprehension than in a do block?
09:24:22 <donri> timtom: it dousn't
09:24:26 <Mortchek> So if you say line <- getLine, then line will hold the result of carrying out the getLine action
09:24:27 <Pods> ^ + 1 timtom
09:24:30 <hiptobecubic> fizbin, not roughly. precisely, i believe
09:24:42 <latro`a> up to pattern matching
09:25:01 <latro`a> the behavior under pattern matching is slightly different, because fail is terrible
09:25:04 <lrojas> hi all, i have a question regarding the ghci
09:25:09 <fumieval> Which library should I use to play sounds? ALUT is just crashing.
09:25:20 <timtom> latro`a: could you provide an example?
09:25:21 <lrojas> here is what i typed
09:25:28 <lrojas> h> [2,4..20]
09:25:28 <lrojas> [2,4,6,8,10,12,14,16,18,20]
09:25:28 <lrojas> h> [4,2..12]
09:25:29 <lrojas> []
09:25:35 <ab9rf> heh
09:25:39 <monochrom> the safest way to explain how "<-" means different things is referring to pattern guards, f x | Nothing <- listToMaybe x = ...
09:25:41 <lrojas> why does the second one fails?
09:25:45 <ab9rf> lrojas: it doesn't fil
09:25:48 <ab9rf> fail
09:25:49 <ski> > [a + b | a <- [0,1,2] , b <- [300,400]]
09:25:50 <lambdabot>   [300,400,301,401,302,402]
09:25:52 <ski> > do a <- [0,1,2]; b <- [300,400]; return (a + b)
09:25:53 <lambdabot>   [300,400,301,401,302,402]
09:25:57 <Iceland_jack> lrojas: Counting from 4, 2… up to 12?
09:25:57 <ab9rf> lrojas: 12 is greater than 2
09:26:00 <latro`a> > Nothing >>= (\(Just x) -> undefined)
09:26:02 <lambdabot>   Nothing
09:26:05 <latro`a> er
09:26:15 <ab9rf> you asked it to start at 4 and count downward by 2s until it got to 12
09:26:25 <latro`a> > (Just []) >>= (\(Just (x:xs)) -> x)
09:26:26 <fizbin> timtom: Well, unless you're using the relevant syntax extension, '<-' in a list comprehension is limited to pulling from lists. In a do block, it can "pull" from any Monad.
09:26:27 <lambdabot>   Couldn't match expected type `[a0]'
09:26:27 <lambdabot>              with actual type `Data.May...
09:26:28 <lrojas> ab9rf: wait, what? 4 is the step no? and starst at 2
09:26:31 <ab9rf> that's not going to happen, so it returned []
09:26:37 <timtom> yes
09:26:38 <geekosaur> no, backwards
09:26:42 <geekosaur> first, next .. last
09:26:45 <latro`a> :|, one more time
09:26:48 <Iceland_jack> > [4, 2 .. -12]
09:26:49 <timtom> but a list comprehension is just sugar over do blocks (or so i thought)
09:26:50 <lambdabot>   [4,2,0,-2,-4,-6,-8,-10,-12]
09:26:51 <geekosaur> not step, not, *next*
09:26:54 <latro`a> > (Just []) >>= (\(x:xs)) -> x)
09:26:54 <ab9rf> lrojas: no, -2 is the step, because the first element was 4 and the second was 2
09:26:56 <lambdabot>   <hint>:1:23: parse error on input `)'
09:26:59 <geekosaur> s/not,/note,/
09:27:07 <timtom> so the semantics of <- would be identical
09:27:14 <latro`a> > (Just []) >>= (\(x:xs) -> x)
09:27:16 <lambdabot>   *Exception: <interactive>:3:16-27: Non-exhaustive patterns in lambda
09:27:18 <latro`a> there we go
09:27:25 <timtom> just that list comprehensions only operate within the list monad
09:27:27 <ab9rf> fizbin: at least it is now.  you used to be able to use any monad n a list comprehension
09:27:27 <fizbin> timtom: Okay, fair point, but it's only sugar over []-based do blocks.
09:27:32 <donri> timtom: the semantics of <- for the list monad and list comprehension is the same
09:27:35 <geekosaur> it might help to know that that gets translated into a call to enumFromThenTo
09:27:50 <monochrom> don't forget monad comprehension. GHC has that.
09:27:51 <fizbin> ab9rf: There's a syntax extension you can pull in these days if you still want that.
09:27:54 <donri> timtom: the semantics of <- in do notation is not identical to >>=, though
09:27:55 <ski> > [a + b | a <- [0,1,2] | b <- [300,400]]
09:27:57 <latro`a> > (x:xs) <- Just []; return x
09:27:57 <lambdabot>   [300,401]
09:27:59 <lambdabot>   <hint>:1:18: parse error on input `;'
09:28:07 <latro`a> > do (x:xs) <- Just []; return x
09:28:07 <lrojas> ab9rf: ok, so what would be the correct expression for numbers from 2 to 12 in 4 steps increments...
09:28:09 <lambdabot>   Nothing
09:28:10 <timtom> donri: tell me more! :)
09:28:13 <latro`a> finally
09:28:20 <`ramses> don't you need a MonadPlus for a general monad comprehension?
09:28:23 <donri> timtom: i think latro`a has been telling you about it
09:28:24 <ski> @undo do Just x <- blah; bleh x
09:28:24 <lambdabot> blah >>= \ a -> case a of { Just x -> bleh x; _ -> fail ""}
09:28:34 <latro`a> (Just []) >>= (\(x:xs) -> x) errors; do (x:xs) <- Just []; return x calls fail
09:28:40 <fizbin> I have a feeling that none of this answers Pods's question.
09:28:43 <ski> `ramses : well, really `MonadZero' or `MonadFail', but ..
09:28:45 <ab9rf> lrojas: [2,6..12]
09:29:02 <`ramses> ski: you need to be able to write guard, right?
09:29:02 <ab9rf> > [2,6..12]
09:29:04 <lambdabot>   [2,6,10]
09:29:09 <donri> `ramses: yes
09:29:12 <lrojas> ps, i just started to read Learn me a haskell for greater good
09:29:29 <monochrom> that is good
09:29:35 <donri> `ramses: but it's only required by MonadComprehensions if you actually use guards
09:29:38 <timtom> thanks guys, very interesting :)
09:29:40 <donri> IIRC
09:30:09 <`ramses> donri: is the compiler smart enough to check that?
09:30:11 <johnw> Learn Me a Haskell for the Greatest Good Possible!!!
09:30:40 <fumieval> http://english.stackexchange.com/questions/165/what-does-great-good-mean-in-tutorial-title-learn-you-a-haskell-for-great-goo
09:30:43 <Pods> Mortcheck: yes this example was helpful, thanks a lot :)
09:30:45 <tlaine> Teach me a haskell
09:30:55 <donri> `ramses: well it just rewrites it to the monad operators and combinators, then type inference is enough to figure that out
09:31:10 <monochrom> do { Just x <- m; more } = m >>= \v -> case v of Just x -> more; _ -> fail "pattern matching error message here"
09:31:29 <donri> `ramses: if you don't write any guard, it won't rewrite it to call 'guard', and MonadPlus isn't inferred
09:32:01 <Pods> just a side comment: Out of all the places I have done any open source contributions and communities I have interacted with , haskell so far is becoming my best experience :D, everyone here is great :D
09:32:19 <donri> @undo [ x | foo ]
09:32:19 <lambdabot> if foo then [x] else []
09:32:24 <donri> heh
09:32:25 <Kinnison> Okay everyone, you can take the gloves off, Pods things we're great.
09:32:36 <ski> donri : that's occasionally handy to use
09:32:40 <`ramses> donri: ah, cool :) I'll probably never use it but it's good to know
09:32:53 <donri> ski: yep
09:32:55 <johnw> Pods: thanks!
09:33:02 <donri> ski: i was hoping for a translation to MonadPlus though
09:33:12 <ski> ah, i see
09:33:15 <johnw> Pods: you clearly have yet to ask us to explain monads to you, though
09:33:21 <ski> @undo [()|let]
09:33:21 <lambdabot> let { } in [()]
09:33:34 <monochrom> there is no monad or cabal
09:33:36 <donri> @undo [ x | x <- xs, foo ]
09:33:36 <lambdabot> concatMap (\ x -> if foo then [x] else []) xs
09:33:40 <donri> :(
09:34:04 <fizbin> Okay, then: Can someone explain WTF the point of arrows is?
09:34:07 <timtom> donri: neat
09:34:12 <Pods> johnw : i am getting there, I am trying to do my homework before I do the interogation :D
09:34:15 <johnw> fizbin: they abstract functions
09:34:22 <fumieval> > take 15 $ nubBy (((==0).).mod) $ 2 : [3, 5..]
09:34:24 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]
09:34:30 <Kinnison> primes!
09:34:31 <fizbin> As I see them (HXT), they just seem like extra cognitive baggage with no benefit.
09:34:36 <ski> donri : as per <http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11>
09:34:52 <monochrom> arrow is a bit more general than monad, and more special than applicative
09:35:10 <monochrom> HXT is not a good use of arrow
09:35:18 <ski> the original motivation of arrows was to be able to do static optimization
09:35:19 <fizbin> johnw: Right, so if I were wanting to prove theorems I suppose I might want to work with arrows instead of functions to make my proofs more general. But why use them in a library?
09:35:26 <donri> ski: i was hoping @undo knew about monad comprehensions is all
09:35:51 <monochrom> reactive programming and modeling circuits are good uses of arrow
09:35:54 <applicative> fizbin: why are you interested in arrows?
09:36:02 <donri> fizbin: hxt is basically a kleisli arrow so it could easily be monadic instead
09:36:09 <fizbin> HXT, because of HXT picklers.
09:36:14 <ab9rf> yeah, the reactive programming stuff i've read is nicely expressive using arrows
09:36:20 <applicative> fizbin: there are some cool uses but I think they haven't become must-know standard haskell
09:36:32 <applicative> damn hxt
09:36:59 <johnw> fizbin: basically, Arrow is just a step up from a regular Category
09:37:00 <donri> fizbin: but when you don't have ArrowApply you could usually get away with applicative+category just as well
09:37:01 <monochrom> I like HXT and I understand how to use it. but I agree it's better off monadic
09:37:11 <johnw> fizbin: the extra "step" it's providing is the ability to lift ordinary functions into the Arrow
09:37:25 <fizbin> At this point, hxt being based on arrows just seems to me that I need to wrap all calls to HXT stuff in some sort of run* call for no apparent reason.
09:37:28 <johnw> because Category already generalize the concept of composing functions
09:37:29 <fumieval> @where profunctors
09:37:29 <lambdabot> I know nothing about profunctors.
09:37:43 <donri> fizbin: you'd need that with a monad too
09:37:53 <ski> fumieval : apparently the new name for difunctors
09:38:06 <donri> fizbin: but normally you just run a complete arrow once, not every little arrow individually. are you using it wrong?
09:38:31 <johnw> Pods: I was reading about monads last night, and came across this little nugget: The Monad interface extends a type 'm' such that two functions, f : a -> m b, and g : b -> m c, can be composed without erasing the type in the middle (i.e., using some z : m b -> b).
09:39:06 <fizbin> donri: I have no idea. I'm not actually using it yet because trying to get my types right makes no sense.
09:39:15 <`ramses> johnw: that's a nice point of view
09:39:22 <timtom> johnw: :)
09:39:24 <monochrom> fizbin: good account of the relations between applicative, arrow, monad: http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#arrows-and-idioms
09:39:25 * ski . o O ( <http://lambdalounge.org.uk/assets/86/c4b5be1635dd1206c24b1e821dd8e4/doing-it-wrong.jpg> )
09:39:28 <fizbin> johnw:  z looks very much like an unlifted join.
09:39:35 <armlesshobo> johnw: wow, didn't think of it like that.
09:40:03 <ab9rf> johnw: hm.
09:40:21 <`ramses> johnw: although the omission of any reference to the fact that the ms are "merged" or "combined" makes it seem a bit too weak
09:40:23 <fumieval> ski: It's easy to confuse bifunctors and difunctors
09:40:30 <donri> fizbin: there are alternatives for xml pickling btw, like hexpat-pickle (duno if good or not)
09:40:51 <Pods> johnw: so the z there will be the extra data refered to in this definition " The essence of monad is thus separation of composition timeline from the composed computation's execution timeline, as well as the ability of computation to implicitly carry extra data, as pertaining to the computation itself, in addition to its one (hence the name) output, that it will produce when run (or queried, or called upon)."
09:40:53 <HugoDaniel> hi
09:40:55 <armlesshobo> `ramses: i think the 'z' part is what makes up for that.
09:41:02 <HugoDaniel> how can i transform a Text so that it becomes URL safe ?
09:41:16 <ski> fumieval : really ?
09:41:33 <ab9rf> fumieval: especially if you're dyslexic.
09:42:13 <`ramses> armlesshobo: how so? The described function could also just discard the context of the first monadic function, couldn't it?
09:42:51 <monochrom> I disagree with "the essence of monad is separation of composition time from execution time"
09:42:59 <fumieval> :P
09:43:20 <johnw> `ramses: when you work through how Monad makes this happen, you find that Monad must provide an operation which collapses m (m a) -> m a, and this is where the real magic happens.  (And when you look at Monads from the point of view of functor adjunctions, this one operation is in fact all that Monad brings to the table).  This operation is just fused into >>= in such a way that it may not seem obvious at first.
09:43:21 <Pods> monochrom : why is that ??
09:43:24 <fizbin> See, I'm not sure that it's proper to say that a monad composes through a function z: m b -> b, but rather that it composes through z: m m b -> m b
09:43:27 <monochrom> whenever you have laziness, you already have that. no monad necessary.
09:43:29 * ski isn't sure what "execution time" means in this context
09:43:34 <sipa> monochrom: i think that description is valid for IO (independent of whether that is a monad or not)
09:43:47 <ab9rf> yeah, that doesn't seem to apply to either the Maybe monad or the list monad...
09:43:53 <ski> (because what monochrom said)
09:43:57 <monochrom> and anally speaking, you always have that, laziness or not
09:44:02 <fizbin> But then what you've got is that a Monad is an Applicative with "join", which is one of the known ways to talk about Monad.
09:44:18 <`ramses> johnw: I know that, but the description you gave, does not seem to capture the essence of join to me, it doesn't seem to imply that the contexts are merged
09:44:28 <ab9rf> too many "what is a monad" tutorials confuse the IO monad with monads generally
09:44:36 <fumieval> just kidding, The diffference between covariant and contravariant is larger than hell and heaven is
09:44:36 <johnw> fizbin: Monad doesn't compose through z : m b -> b, I think I said that the purpose of Monad is allow a composition of those two functions *without* relying on such a z
09:44:45 * hackagebot mueval 0.9 - Safely evaluate pure Haskell expressions  http://hackage.haskell.org/package/mueval-0.9 (GwernBranwen)
09:44:53 <Taneb> "What is a Monad?" "It's an anagram of Nomad. Cool, huh?"
09:45:10 <ab9rf> for me it's a game piece in a game i used to have when i was a kid
09:45:15 <johnw> `ramses: here, let me try to get that into the sentence
09:45:16 <ab9rf> they were worth 80 points
09:45:22 <c_wraith> I like the occasional times people ask about nomadic code.
09:45:28 <fizbin> :t (>>=)
09:45:28 <Mortchek> I actually took advantage of that in a game of Crysis Wars. Since the default player name is Nomad, I named myself Monad. Groans were had all around once they started getting it
09:45:29 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:45:37 <c_wraith> It's often written at coffee shops
09:45:41 <ski> c_wraith : we should rename "mobile code" to that
09:45:53 <ab9rf> c_wraith: good ol' autocorrect
09:46:15 <monochrom> sipa, the separation is valid for IO because the language as a whole is lazy in practice. not an essence of monad. in an eager language you will have monads that do not have the separation
09:46:23 <fizbin> :t \x y -> join (liftM y x)
09:46:25 <lambdabot> Monad m => m a1 -> (a1 -> m a) -> m a
09:46:34 <ab9rf> http://boardgamegeek.com/boardgame/1520/monad <- the 'original' monad :)
09:46:56 <fizbin> @pl \x y -> join (liftM y x)
09:46:56 <lambdabot> (join .) . flip fmap
09:47:10 <Botje> c_wraith: wouldn't nomadic code be stuff like mobile agents?
09:47:22 <Botje> (or internet worms, if you're more malicious)
09:47:42 <fizbin> ab9rf: I think the title of 'original' monad goes to http://en.wikipedia.org/wiki/Monad_(philosophy)
09:48:06 * ski . o O ( the original monad <http://upload.wikimedia.org/wikipedia/commons/c/c2/Leibniz_Monadology_2.jpg> )
09:48:08 <sproingie> "The first player to accumulate a given number of Monads (which varies depending on the number of players in the game) is the winner."
09:48:10 <monochrom> Pods: in general, in my opinion, avoid wordy essays until you have done a ton of examples. Recall how to learn Chess. do you read a lot of essays first before you try your hand at the first game?
09:48:33 <sproingie> Haskell: He who dies with the most monad tutorials wins.
09:48:38 <armlesshobo> LOL
09:48:42 <johnw> `ramses: I don't like how long this is getting, but what about this: "The Monad interface extends a type 'm' such that two functions, f : a -> m b, and g : b -> m c, can be composed without erasing the type in the middle (i.e., without using some z : m b -> b).  It does this by lifting g into the Monad as g' : m b -> m (m c), composing, and then using an implied join : m (m c) -> m c to yield the expected m c at the end.  It is this
09:48:43 <johnw> merging in the final step which provides the functionality associated with Monads."
09:48:43 <ab9rf> fizbin: bah :)
09:48:54 <ab9rf> fizbin: i ran into the game long before i ran into the philsophy
09:49:10 <fizbin> :t fmap (fmap join) (flip fmap)
09:49:12 <lambdabot> (Monad m, Functor m) => m a1 -> (a1 -> m a) -> m a
09:49:26 <mcstar> i knew monads way before i met haskell from Ergo Proxy
09:49:29 <armlesshobo> fizbin: what is this witchcraft?
09:49:34 <armlesshobo> :P
09:49:43 <fizbin> Which is (since what Monad isn't a Functor?), exactly the type of >>=
09:50:01 <`ramses> @ty fmap join . fmap
09:50:02 <johnw> :t (join .) . flip fmap
09:50:03 <lambdabot> (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
09:50:04 <lambdabot> (Monad m, Functor m) => m a1 -> (a1 -> m a) -> m a
09:50:18 <Pods> Looks like I need another theory session for functors :P
09:50:26 <armlesshobo> Pods: you and me both :P
09:50:26 <`ramses> @ty flip (fmap join . fmap)
09:50:28 <lambdabot> (Monad m, Functor m) => m a1 -> (a1 -> m a) -> m a
09:50:34 <ab9rf> i actually understand functors better than monads
09:50:41 <applicative> the philosophy 'monad' is not really to the point, try Euclid VII Def. 1. A unit (monad) is that by virtue of which each of the things that exist is called one.
09:50:51 <byorgey> the confusing thing about fizbin's code is that two of the fmaps are for the monad in question, and one is for the ((->) e) monad, i.e. it is just composition.
09:51:00 <ski> > (fmap . fmap . fmap) (2 *) [Just [0,1,2],Nothing,Just [3,4]]
09:51:02 <lambdabot>   [Just [0,2,4],Nothing,Just [6,8]]
09:51:03 <`ramses> johnw: yeah, it kinda lost it succinctness :) But I do like that kind of explanation
09:51:10 <typoclass> monochrom: kudos, you have a very sensible position
09:51:11 <Pods> *retreating to get the theory right*
09:51:12 <Pods> bbl
09:51:18 <typoclass> monochrom: see also http://www.youtube.com/watch?v=MnKoQbFXemE
09:51:22 <fumieval> :t fmap fmap fmap fmap
09:51:24 <lambdabot> (Functor f2, Functor f1, Functor f) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
09:51:30 <mcstar> > fix fmap
09:51:32 <lambdabot>   Occurs check: cannot construct the infinite type: b0 = f0 b0Occurs check: c...
09:51:37 <joe9>  is there a haskell intersect that can take more than 2 lists? a list of lists?
09:51:49 <`ramses> johnw: I strongly feel a lot of the monad-confusion arises from too concrete explanations
09:51:51 <Iceland_jack> probably `intersects' if it exists
09:51:56 <applicative> foldr intersect
09:52:11 <ab9rf> applicative: what's the base case?
09:52:19 <applicative> @type intersect
09:52:21 <lambdabot> Eq a => [a] -> [a] -> [a]
09:52:33 <ski> @type foldr1 intersect
09:52:34 <lambdabot> Eq a => [[a]] -> [a]
09:52:42 <ab9rf> i think you need foldr1, not foldr
09:52:45 <applicative> ab9rf: right, this will be bad....
09:53:04 <ab9rf> as ski has already noted :)
09:53:05 <fizbin> `ramses: I think that monads can only be explained abstractly after you've used them concretely for a bit.
09:53:13 <ski> or `foldr intersect universe', as the case may be
09:53:17 <ab9rf> heh
09:53:26 <`ramses> fizbin: not sure... depends on the explainee probably
09:53:33 <ski> (`union' is easier)
09:53:38 <joe9> ski, applicatieve, thanks.
09:53:49 <applicative> ski, yes, thats what came to me with ab9rf 's question
09:53:55 <`ramses> fizbin: you certainly have to accompany the abstract explanation by examples, though
09:54:13 <sproingie> i think it's waaaaay easier to grok monads after fully internalizing functor and monoid
09:54:23 <ab9rf> joe9: did that answer your question?
09:54:30 <otters> I don't see what monoids have to do with monads
09:54:35 <otters> not on the learning front
09:54:36 <johnw> `ramses: yes, I agree.  concrete explanations must perforce "instantiate" the abstraction in a particular domain, but this distracts from how differently the other instantiations can behave from the one you've chosen, and then you are comparing apples to oranges, instead of understanding that the point was to talk about "fruit"
09:54:37 <`ramses> sproingie: absolutely, throw in Applicative as well :)
09:54:46 <ab9rf> sproingie: typeclassopedia's little dag of the different categories helped me immensely in that regard
09:54:56 <Taneb> otters, not so much in Haskell, but in category theory I gather they are conected
09:55:08 <ab9rf> otters rock
09:55:13 <otters> i know
09:55:16 <johnw> otters: ah, that one is actually easy
09:55:18 <sproingie> monoid makes you think in terms of composition.  functor is fundamental at any rate
09:55:27 <johnw> so, you know how a monad can combine two elements to make a new element of the same type?
09:55:31 <johnw> sorry, a monoid
09:55:43 <ab9rf> like numbers :)
09:55:49 <fumieval> :t mappend
09:55:50 <fizbin> There needs to be a "Counterexamples in typeclasses" paper along the lines of the excellent "Counterexamples in Topology" text.
09:55:51 <lambdabot> Monoid a => a -> a -> a
09:55:53 <sproingie> like some operations on numbers anyway
09:56:03 <ab9rf> yes
09:56:06 <johnw> well, a monad can compose two functors to make a another functor of the same kind
09:56:07 <typoclass> `ramses: i think it's perfectly alright to explain monads concretely in terms of Maybe and of IO and so on. explaining them concretely in terms of the proverbial space suits and burritos is a different matter. it's much more difficult to do well
09:56:09 <fumieval> :type mappend `on` Sum
09:56:21 <johnw> m (m a) is like saying (m `o` m) a
09:56:26 <fumieval> :t  mappend `on` Sum
09:56:26 <johnw> where `o` is the type-operator for functor composition
09:56:28 <lambdabot> Num a => a -> a -> Sum a
09:56:33 <ab9rf> hm, it took us until 11:56 to get to burritos
09:56:40 <johnw> now you can view monads as a monoid over functors
09:56:41 <`ramses> typoclass: those are perfect examples, but I doubt you will be really communicating the abstract idea then
09:56:42 <otters> :t (??)
09:56:43 <lambdabot> Functor f => f (a -> b) -> a -> f b
09:57:21 <ab9rf> i mainly use Maybe as a way to tet whether someone's explanation of monads makes sense.  so many of them don't make sense for Maybe (or for the list monad)
09:57:27 <johnw> (well, specifically it must be a monoid over endofunctors)
09:57:34 <johnw> (or, said more correctly, a monoid in the category of endofunctors)
09:57:43 * ski . o O ( "Counterexamples in Clifford algebras" by Pertti Lounesto at <http://users.tkk.fi/ppuska/mirror/Lounesto/counterexamples.htm> )
09:59:15 <`ramses> johnw: I tried to write that down a while ago: https://gist.github.com/RamsesDeNorre/d64bd27697325a1f75dd
09:59:15 <johnw> otters: so, while a monoid turns a <> a <> a into a, a monad turns F (F (F a)) into F a.  It's just a monoid at the functor level, rather than at the value level
10:00:20 <otters> oh i gotcha
10:00:30 <fizbin> :t join
10:00:31 <lambdabot> Monad m => m (m a) -> m a
10:00:34 <ski> johnw : i'm not sure that's a good way to think about it
10:00:46 <johnw> ski: how so?
10:01:11 <typoclass> `ramses: probably so, but then we get into the whole question of what you need this abstract understanding for ...
10:01:33 <johnw> `ramses: yeah, researching this stuff in Haskell is a great way to go
10:01:40 <ski> johnw : for monoids, `(<>)' come together with `mempty' -- what is the corresponding thing in the monad situation ?
10:01:59 <`ramses> ski: something with return probably?
10:02:10 <fizbin> > let enlist x = [x] in join (enlist . enlist . enlist) 5
10:02:12 <lambdabot>   Couldn't match expected type `t0 -> a0' with actual type `[a1]'
10:02:14 <johnw> ski: the true identity functor
10:02:17 <applicative> return turns an a into an F a
10:02:32 <applicative> oh i see where we are
10:02:38 <`ramses> typoclass: to see the big picture, not just instantiations of it? To not just see the shadows in the cave? ;)
10:02:46 <johnw> I (F a) = F a
10:02:47 <fizbin> Maybe we don't have a Monoid, but just a semigroup?
10:02:53 <johnw> F (I a) = F a
10:03:01 <djahandarie> I suspect johnw is just trying to give the "-oid" explanation.
10:03:07 <applicative> left and right unit
10:03:15 <johnw> it's maybe not a Monoid like this in Haskell
10:03:20 <ski> johnw : for monoids, i think `mempty : 1 -> M' and `uncurry (<>) : M * M -> M', while for monads we have `eta : id -> T' and `mu : T . T -> T' -- so `*' corresponds to `.' (and `1' to `id'). `mempty' corresponds to `return'/`eta' and `(<>)' to `join'/`mu'
10:03:21 <johnw> because we don't have a true identity functor
10:03:28 <`ramses> fizbin: it really is a monoid, in the endofunctor sense the identity is return
10:03:35 <applicative> djahandarie: whats wrong with that
10:03:50 <djahandarie> Nothing.
10:04:15 <ski> johnw : however, as you stated it, it appeared you wanted `(<>)' to correspond to `(.)'
10:04:44 <johnw> ski: if join is mappend, and join . return is a no-op, then return is mempty, is that what you're saying?
10:05:10 <applicative> <> corresponds to composition of functors
10:05:11 <ski> `ramses : byw, fyi `MonadicFun' is called `Kleisli'
10:05:15 <ski> @index Kleisli
10:05:15 <lambdabot> Control.Arrow, Control.Arrow
10:05:36 <ski> johnw : yes, more or less
10:05:47 <johnw> ski: ok.  I'm not sure how I implied that <> was ., but I didn't mean to
10:05:49 <ski> applicative : no, that's that i disagree with here
10:05:55 <ski> s/that i/what i/
10:06:19 * applicative reflects
10:06:29 <ski> johnw : by the comparision "a monoid turns a <> a <> a into a, a monad turns F (F (F a)) into F a"
10:06:53 <johnw> but if <> = join, aren't the two statements identical?
10:07:07 <ski> (note that `F (F (F a))' is `(F . F . F) a')
10:07:09 <timtom> does anybody know the flag to make GHC do a complete rebuild?
10:07:24 <johnw> ahh
10:07:28 <johnw> thanks for clarifying that!
10:07:38 <ski> johnw : `F (F (F a))' is a type, but `a <> a <> a' must be a value, since `(<>)' operates on the value-level
10:07:40 <johnw> i was performing my join after composition
10:07:42 <applicative> -force-recomp
10:07:46 <ski> and monoid vs. monad is nothing about value vs. type
10:07:51 <djahandarie> You know, I've always kind of wondered why monads aren't more interesting in category theory. It feels they should be more fundamental, because they are monoids (in the category of endofunctors), and monoids are rather core to things in category theory.
10:07:54 <applicative> timtom: ^^^ or did you mean more
10:08:07 <johnw> ski: i had meant value vs. functor
10:08:10 <fizbin> So, one problem with this view is that a given monad only works on one functor. But I guess that might work; after all, "Sum Nat" is certainly a monoid and...
10:08:17 <timtom> applicative: more?
10:08:27 <klrr> C got K&R, LISP got SICP, does Haskell got a bible too?
10:08:30 <fizbin> > join [[5]]
10:08:32 <lambdabot>   [5]
10:08:42 <ski> applicative : `(<>)' corresponds to `join', and *cartesian product* (curried in the case of `(<>)') is what corresponds to "composition of functors"
10:08:56 <johnw> klrr: and Coq has Software Foundaitns
10:08:56 <ski> johnw : same difference
10:08:56 <johnw> Foundations
10:08:57 <Taneb> klrr, LYAH?
10:09:20 <klrr> Taneb: hmm, LYAH is bible class?
10:09:26 <johnw> LYAH is introduction class
10:09:39 <Taneb> LYAH is like the book of Genesis
10:09:43 <applicative> timtom: I just wondered if that's what you were looking for, -fforce-recomp
10:09:49 <shergill> i have a directed graph G. is there a name for G' obtained by reversing all the edges in G?
10:09:51 <hiptobecubic> I don't think haskell has a K&R equivalent
10:09:53 <Taneb> RWH has got a bit of Exodus
10:09:54 <klrr> is, "Programming in Haskell" bible?
10:09:54 <fizbin> klrr: If you're thinking of a relatively short yet still thorough document, "A Gentle Introduction" is a bit dated now, but still pretty good.
10:10:03 <tharper> oh please
10:10:12 <tharper> it's an insult to LYAH to compare it to the Bible
10:10:13 <knz> shergill: transpose
10:10:20 <knz> shergill: transposed graph
10:10:21 <shergill> oh right. duh
10:10:25 <klrr> fizbin: no, i rather mean a state of the art, extremely excellent book by people who has iq 300
10:10:26 <shergill> thanks knz
10:10:29 <ab9rf> LYAH never claims that pi = 3, for example
10:10:29 <knz> yw
10:10:33 <`ramses> ski: I discovered that later on ;)
10:10:38 <applicative> 'a few monads more' kind of reminds me of Judges
10:10:44 <fizbin> klrr: But you compared it to K&R
10:10:46 <tharper> who has an IQ of 300?
10:10:57 <timtom> applicative: yeah, that was exactly it - thanks :)
10:10:58 <fizbin> K&R is far from state-of-the-art C.
10:10:58 * ski . o O ( "A Gentle Introduction (if you're a Functional Programmer who just doesn't know Haskell)" )
10:10:59 <sproingie> who let the dogs out?
10:11:01 <ab9rf> tharper: nobody does, it's not meaningful to claim that
10:11:06 <tharper> ah
10:11:10 <tharper> didn't think so
10:11:14 <tharper> that sounds...troubling as well
10:11:21 <tharper> The would would probably be so damn boring
10:11:25 <ab9rf> tharper: IQ is a normalized measure with z =100 and sigma = 15 (or 14 for some tests)
10:11:29 <klrr> fizbin: K&R is excellent
10:11:30 <sproingie> i had the start of a tutorial up a long time back, but i wiped it out in a depressed fit once
10:11:54 <sproingie> it was called Learn You Yet Another Real World Gentle Haskell (LYYARWGH)
10:12:02 <ab9rf> a claimed IQ of 300 would be plus-13 sigma
10:12:05 * ski grins
10:12:10 <fizbin> klrr: Oh, it's a classic. But contrary to popular belief, C has changed since then.
10:12:24 <sproingie> K&R is full of nuggets like the one-line strcpy
10:12:26 <ab9rf> tharper: in practice Stanford-Binet cannot yield a score higher than +3 sigma
10:12:38 <klrr> fizbin: a classic is a book which is relevant to read even if the language it teaches is dead or not
10:12:40 <fizbin> Which is why I'd compare it to "A Gentle Introduction"
10:12:53 <fizbin> Because it's still highly relevant.
10:12:56 <ab9rf> tharper: there are some tests that can give scores as high as 180, but those are questionable.  any score higher tha 180 is statistically unjustifiable.
10:13:03 <tharper> ha
10:13:44 <hiptobecubic> ski, it does say that it's for someone who has "experience with another functional language (even an 'almost functional' such as ML or Scheme)", HA!
10:14:11 <klrr> thanks for the answers, in 10 years i will write the classic im looking for, i will become programming master of masters guru
10:14:35 <klrr> (probably not i know, but i have dreams)
10:14:36 <sproingie> IQ is a measurement of your aptitude for IQ tests
10:14:41 <ab9rf> sproingie: tat too
10:14:47 <klrr> i got 105
10:15:10 <sproingie> i'd taken several of them as a kid, i thought they were pretty silly then
10:15:12 <applicative> djahandarie: I think monads arent expecially central in ordinary mathematical uses of categories because endofunctors arent central
10:15:17 <ab9rf> sproingie: and also how white you are
10:15:21 <klrr> tested me at mensa two years ago
10:15:24 <ab9rf> sproingie: the race bias on most IQ tests is 4-5 points
10:15:27 <klrr> i was 13 i think
10:15:29 <klrr> well bye
10:15:51 <fumieval> IQ is just IO with a thorn
10:16:22 <johnw> true, one reason Monads are so useful to Haskell are we live in a world of strong endofunctors
10:16:35 <johnw> and those noly
10:16:35 <johnw> only
10:16:41 <djahandarie> applicative, maybe. But endofunctors are one of the only categorical things you can make monoids out of. But I see your point.
10:16:44 <sproingie> we all live in a monad submarine
10:16:58 <simpson> A monad submarine!
10:16:58 <johnw> i think there is only one true question to ask concerning monads
10:17:06 <johnw> is it mAHnad, or mOEnad?
10:17:13 <sproingie> a monad submarine!  we all li*ahem* that's enough
10:17:13 <RenJuan> to say that IQ tests are racist is itself racist
10:17:29 <RenJuan> in an unintended way
10:17:49 <typoclass> johnw: m-oughäæeiu-nad
10:18:02 <sproingie> the bias is observable when other factors are controlled for
10:18:12 <applicative> IQ measures degree of assimilation to market society, as we left-wing Flynn Effect enthusiasts argue.
10:18:26 <sproingie> e.g. similar academic achievement ratings, other standardized tests
10:18:46 <djahandarie> Well, I suppose another interesting thing is a monoid in the category of monoids, which are commutative monoids, which are kind of used I suppose.
10:18:49 <johnw> perhaps we could take discussion of IQ tests to #haskell-blah
10:18:59 <djahandarie> Still. It feels like there should be something more interesting going on.
10:19:02 <applicative> yes
10:19:31 <RenJuan> for example my father was a black who's IQ was measured in a us federal prison as being 160
10:20:21 <applicative> RenJuan: as johnw haskell-blah for such things
10:20:33 <ab9rf> someone is going t have to write a "monads are like a submarine" tutorial now
10:20:50 <johnw> ab9fr: is the monad the submarine itself, or is it the water?
10:20:55 <RenJuan> applicative, missing verb
10:21:04 <ab9rf> johnw: it's not my metaphor, you figure it out :)
10:21:06 <RenJuan> or other part of speech
10:21:07 <johnw> haha
10:21:09 <johnw> fair enough
10:21:10 <djahandarie> Ah. I suppose something interesting is that a monoid in a bicategory B is the hom-object of a B-enriched category with a single object. Though that's kind of just the case due to just definitions.
10:21:12 <typoclass> johnw: which is to say, i think pronunciation variants are quite okay. i don't see a problem if some people say moenad and some say mahnad
10:21:22 <ab9rf> johnw: i'm sick of monad metaphors
10:21:31 <johnw> a monad is like a sickness
10:21:39 * sproingie cocks his head sideways at djahandarie and does his best confused puppy dog expression
10:21:53 <applicative> RenJuan: yes I mean, the topic belongs there, as johnw said it's off topic but tends to be incendiary
10:22:05 <sproingie> johnw: like the kind you get from a bad burrito
10:22:18 <ab9rf> 12:21 and we have TWO BURRITOS
10:22:24 <applicative> return is like getting sick; join is like getting better?
10:22:26 <ab9rf> keep this up and i'l hve to go to taco bell again
10:22:33 <Cale> djahandarie: Though to some extent, everything is just the case due to just definitions
10:22:38 <johnw> RenJuan: we use #haskell-blah as a way of keeping #haskell focused more on code and related subjects
10:22:48 <RenJuan> you what "monad" reminds me of? This department in IBM Research where I worked where they had this markup language who's compiler was called "demiurge"
10:22:49 <djahandarie> Cale, yeah. But this seems like it's really just due to the definitions more-so than other things.
10:23:03 <sproingie> ab9rf: i make it a habit to not eat meat extruded from a caulking gun
10:23:04 <ski> applicative : well, monads are related to adjunctions, which are ubiquous
10:23:11 <Cale> There's a lot of that in CT :P
10:23:26 <RenJuan> it ain't exacle lighting up haskell-blah right now
10:23:42 <johnw> RenJuan: that's the other reason we move those conversations there ;)
10:23:54 <ab9rf> "This monad left intentionally blank."
10:23:57 <applicative> ski oh yeah, but adjoint functors arent endofunctors, though their compositions are
10:24:03 <RenJuan> *whose
10:24:12 <ski> applicative : exactly
10:24:20 <applicative> I mean, in general
10:24:24 <johnw> applicative: that's a great point
10:25:20 <ski> (s/arent/doesn't have to be/)
10:26:34 <ab9rf> now i've lost track of what an endofunctor is
10:27:08 <johnw> ab9fr: a mapping from a category (like Hask) to itself
10:27:16 <ab9rf> johnw: thank you
10:27:25 <ab9rf> johnw: too much abstract math causes me to drop definitions
10:27:32 <johnw> yeah, tell me about it
10:27:43 <johnw> re-learning is as much a part of that game as understanding it the first time
10:28:06 <ab9rf> i only have so much conceptual space in short-term memory
10:28:14 <djahandarie> I think a lot of the naming in category theory is just really unfortunate
10:28:30 <ski> like "triples"
10:28:31 <djahandarie> Too many names, lack of reoccurring morphemes
10:28:39 <coppro> djahandarie: except "co"
10:29:06 <ab9rf> djahandarie: one of my grouses about abstract math is that there's a mix of ordinary words repurposed to mean something having nothing to do with the ordinary word, combined with meaningless terms
10:29:12 <johnw> and then you have to remember the mappings from CT into Haskell
10:29:21 <johnw> like return for unit, etc.
10:29:42 <djahandarie> ab9rf, ah, well, that's not just abstract math. That
10:29:47 <djahandarie> That's pretty much anything.
10:29:53 <ski> ab9rf : perhaps the alternative is to *only* use meaningless terms ?
10:30:01 <djahandarie> Like "speed" in physics.
10:30:37 <djahandarie> Plenty of technical fields redefine common words to either be more specific or more general.
10:30:40 <johnw> ab9fr: i find myself wading through terminology when I have to decode what a "strong lax monodoial functor" is, only to find that it's an applicative functor!  I guess the CT definition is more conceptually accurate, but it's a lot harder to grok
10:31:14 <johnw> though, I do suppose the merit of understanding the abstract math definition is that it decomposes the abstraction down to its building blocks
10:31:21 <sproingie> "strong lax" sounds like something you take for constipation
10:31:24 <johnw> like deriving monads from adjoint functors
10:31:32 <djahandarie> Ugh, "strong lax". Whoever said that needs to be punched.
10:31:45 * djahandarie would say "a lax monoidal endofunctor with a strength"
10:31:56 <johnw> djahandarie: or how about a "strict weak total order", which is not even a total order!
10:31:57 <typoclass> djahandarie: iirc it's in the haddock for Data.Monoid or thereabouts
10:32:47 <Cale> djahandarie: Is there some problem with monoidal functors having a strength being called strong?
10:33:16 <ocharles> Cale: yes, strong has another meaning
10:33:17 <ocharles> http://cstheory.stackexchange.com/questions/12412/explaining-applicative-functor-in-categorical-terms-monoidal-functors
10:33:35 <ocharles> at least, two meanings of strength, depending on how you read it
10:33:40 <johnw> there are two meanings for strength
10:33:41 <johnw> yeah
10:34:08 <typoclass> er no, it was Control.Applicative http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
10:34:17 <djahandarie> Cale, not a real problem, it's just confusing for someone who doesn't have every sharp and distinct in their mind.
10:34:25 <Cale> ocharles: What's the second sense?
10:34:49 <ab9rf> ski: the use of phrases instead perhaps
10:34:58 <ocharles> Cale: I can't explain more than point you at that link :)
10:35:03 <ab9rf> sorry, i got called away, didn't mean to leave in mid-argument :)
10:35:04 <typoclass> ... it's kind of sad they thought this was a good thing to bring up in the very first sentence (as opposed to a footnote or something)
10:35:12 <ocharles> but it suggests there are two interpretations from the ambiguous phrase "strong lax monoidal endofunctor"
10:35:24 <djahandarie> There aren't two interpretations
10:35:36 <johnw> Cale: I think it's a strong endofunctor, but a non-strong *monoidal* functor
10:35:43 <djahandarie> There is one interpretation, but "strong" in that context is just confusing
10:36:01 <djahandarie> (The context being with a monoidal functor)
10:37:22 <ski> ab9rf : perhaps. but then it's not as clear how those compose, i think
10:42:47 <sproingie> the explanation of lax monoidal functor reminds me of demorgans law
10:43:18 <sproingie> namely the F(A)⊕F(B)→F(A⊗B) bit
10:43:34 <sproingie> (hm those two ops look almost identical in this font)
10:45:35 <ab9rf> ski: it's probably just m egrousing
10:46:00 <ab9rf> ski: i haven't put enough effort into learning the domain specific language, and so statements in it are gibberish that sorta make sense but don't
10:46:41 <ab9rf> ski: there really is no wya to make the domain-specific language "better"
10:46:47 <mcstar> they are identical if we allow rotation around the center
10:47:15 <ab9rf> sproingie: they are identical in my font, they're both a substitution character :)
10:47:40 <ocharles> sproingie: isn't that just the distributative law?
10:47:55 <sproingie> ocharles: they're two different ops
10:48:15 <ocharles> so is distribution, no?
10:48:22 <sproingie> distribution distributes one op
10:48:27 <ocharles> multplication distributing over addition
10:48:30 <ocharles> for example
10:48:41 <mcstar> they are logic connectives
10:48:44 <mcstar> logical*
10:49:48 * hackagebot retry 0.2.0.0 - Retry combinators for monadic actions that may fail  http://hackage.haskell.org/package/retry-0.2.0.0 (OzgunAtaman)
10:49:48 <ab9rf> i thought de morgan's was just the statement of the distributive law in the ring of boolean algebra
10:49:55 <monochrom> we should create a game Logic the Gathering
10:50:01 <sproingie> hm maybe.  abstract math for me is a strange and new place.  keeps it fun, but i'm amused at the most trivial things
10:50:22 <ab9rf> but it's been nigh on twenty years since i've done any serious abstract algebra
10:50:31 <sproingie> always a child in the kindergarden of algebra
11:13:39 <madjestic> hey guys, I want to be able to call a function with an arument either [a] or a.  Is that possible?
11:14:16 <ski> > (:[]) 'a'
11:14:18 <lambdabot>   "a"
11:14:19 <monochrom> perhaps f :: Either [a] a -> Your_type
11:14:24 <ski> > (:[]) ['a','b']
11:14:26 <lambdabot>   ["ab"]
11:14:52 <ski> madjestic : so it's possible if your function doesn't need to analyze the argument it is given
11:14:57 <ski> ab9rf : perhaps
11:15:11 <c_wraith> > const 5 "a"
11:15:13 <lambdabot>   5
11:15:17 <c_wraith> > const 5 ["a"]
11:15:19 <lambdabot>   5
11:15:21 <c_wraith> sweet!
11:15:46 <monochrom> perhaps I don't understand the question
11:16:15 <madjestic> ski: interesting
11:16:18 <c_wraith> I suspect madjestic actually wants ad-hoc polymorphism, at a syntactic level
11:16:21 <sublimepua> Quick question, what is the <> operator? Symbols are fairly ungoogleable.
11:16:30 <c_wraith> sublimepua: they're very hoogleable, though
11:16:31 <shachaf> sublimepua: But they're Hoogle-able!
11:16:33 <shachaf> @where hoogle
11:16:33 <lambdabot> http://haskell.org/hoogle
11:16:42 <mcstar> cant type families do that?
11:16:52 <fizbin> madjestic, if you only want this for certain a you could also use a typeclass.
11:18:08 <monochrom> I object to using type class
11:18:23 <ski> @type (<>)
11:18:24 <lambdabot> Monoid m => m -> m -> m
11:19:10 <sublimepua> Hoogle calls it a beside. Is it for pretty printing?
11:19:17 <sproingie> so <> is mappend?
11:19:52 <ski> @hoogle (<>)
11:19:52 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
11:19:52 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
11:19:52 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
11:20:14 <Mortchek> Is Seq an ideal type to represent a checker board?
11:20:16 <fizbin> @src (<>)
11:20:16 <lambdabot> Source not found. That's something I cannot allow to happen.
11:20:56 <Mortchek> Or hrm, it has non-constant lookup. What would have constant lookup?
11:21:05 <sublimepua> Ah, it shows up as an infix mappend. Thanks. Someone might want to fix the hoogle links, all they say is that its 'besides'
11:21:24 <Mortchek> Err, not lookup, but rather, find the element at (x, y).
11:21:46 <ski> sublimepua : well, that's what it means in Hughes' Pretty-Printing lib
11:22:24 <monochrom> I would use an array for a checker board
11:22:26 <ski> Mortchek : perhaps you want arrays ? (not constant lookup there either, though)
11:22:45 <Mortchek> ski, is that what you might use if you wanted to represent a checker board?
11:24:17 <ab9rf> what are you putting o the checkerboard?
11:24:27 <ab9rf> it might be easier to represent the positions of the pieces
11:24:34 <Mortchek> Good point.
11:24:36 <ab9rf> instead of the squares themselves
11:25:17 <ab9rf> you can probably write a perfectly good checkers engine with two lists, specifying the positions of each of red's and black's pieces, respectively
11:25:25 <Mortchek> Though then "Is there a piece here?" is O(n) in the number of pieces.
11:25:40 <ab9rf> Mortchek: yes but there;s at most what, 24 pieces on the board?
11:25:46 <Mortchek> Yeah. That should work. Thanks.
11:26:06 <Mortchek> I realize I was probably prematurely optimizing. D:
11:26:38 <ab9rf> then againm there's only 32 live squares
11:26:51 <docksider> What kind of types has the least amount of boxing overhead
11:26:55 <docksider> ?
11:27:04 <ab9rf> you could store them in a tree and get O(lg n) lookup
11:27:21 <Mortchek> That's okay - I like the list idea because it's simple to implement.
11:27:41 <ab9rf> Mortchek: you do have to keep track of which pieces have been kinged
11:28:00 <Mortchek> Yeah. I figure that's a parameter in the checker value.
11:28:25 <docksider> And by boxing overhead i mean both execution time and space
11:28:30 <ab9rf> yeah, you could just use a data Piece = Pawn | King or something
11:29:50 <ab9rf> Mortchek: now, if you wanted to write checkers for arbitrary n boards... that might justify some optimization
11:31:03 <monochrom> unboxed types have the least amount of boxing overhead. but they are harder to use, and GHC-specific
11:32:14 <sproingie> newtypes have no overhead in the wrapper.  but seriously, premature optimization alert.
11:32:25 <docksider> I don't see how boxing is at all needed tho, is it for ABI stability?
11:32:44 <monochrom> for example, you can use GHC's Int# directly. many restrictions apply. it may be much pain for no gain.
11:32:59 <ab9rf> ABI?
11:33:03 <sproingie> boxing is simply how data is represented generically, same idea as java references
11:33:14 <docksider> http://en.wikipedia.org/wiki/Application_binary_interface
11:33:16 <madjestic> let foo = foldr1 (+).  I want to be able to call: foo 5; and get 5 translated into 5:[], so that foo works (so that foldr1 (+) inside foo works)
11:33:23 <sproingie> it has nothing to do with ABI
11:33:28 <RichyB> monochrom: yeah, I would strongly recommend using "ghc-core" (which you'll find on hackage) before trying unboxed types.
11:33:32 <madjestic> am I being very wrong on my thinking there?
11:33:43 <ab9rf> Mortchek: representing te board as a Data.Map with an integer key would give O(log n) for most operations
11:34:02 <docksider> Well, since im compiling the code, why do i need more boxing than C structs?
11:34:16 <docksider> The compiler must be sure of what it has built anyway
11:34:29 <Mortchek> ab9rf, an integer key? Not (Integer, Integer)?
11:34:36 <ab9rf> Mortchek: why use a tuple?
11:34:37 <RichyB> monochrom: rewriting a large subroutine to use all unboxed types is painful, so you want to always use ghc-core first to check that the optimiser hasn't already figured out how to do that transformation for you.
11:34:55 <RichyB> I have done that once and regretted not checking first. :)
11:34:59 <Mortchek> Because the location on the board is (how many down, how many left) or something.
11:35:01 <ab9rf> Mortchek: you can just number the squares across the board, it's not like you're going to increase the number of squares during the game
11:35:08 <adek> In monad transformers tutorial we read: "Map.lookup is defined to work in any monad by calling its fail function". Does type signature include this information? Do I need to check implementation to check if some function which returns Maybe can work within other monad by calling its fail function?
11:35:21 <docksider> RichyB: How do you do that?
11:35:52 <Mortchek> ab9rf, but a pair would enter into that anyway, no? Why not just keep that pair as the key so I don't need to transform it into an integer?
11:35:53 <monochrom> boxing is one way to help implement laziness. but I guess you don't want laziness, and boxing is not the only way anyway
11:36:02 <ab9rf> Mortchek: you can use tuples (since there's an Ord instance for (a,a) where a in Ord) if you want
11:36:02 <RichyB> docksider: do which bit? Convert to using unboxed types is, manually use Int# instead of Int everywhere, and so on, and use unboxed tuples for most things.
11:36:20 <monochrom> boxing is also one way to help implement polymorphism. but it is also not the only way. code duplication is another way.
11:36:25 <Mortchek> ab9rf, I'm just curious what your rationale for using an integer is rather than a pair of integers.
11:36:31 <docksider> Checking if the compiler figured it out
11:36:31 <ski> docksider : boxing for uniform polymorphism implementation (an alternative would be to pass type-infos at run-time to polymorphic code)
11:36:36 <ab9rf> Mortchek: porbably just my prejudice against complex keys :)
11:36:39 <monochrom> do you not need boxing, if you write your own compiler and not use GHC.
11:36:41 <Mortchek> I see :P
11:36:50 <monochrom> s/do you/you do/
11:37:00 <docksider> Why is the code polymorphic at runtime?
11:37:22 <RichyB> docksider: use ghc-core to check is very easy - you pretty much run "ghc-core Foo.hs" and it compiles Foo.hs with the optimiser turned on, then spits out a syntax-highlighted annotated version of your code, showing the GHC core that the optimiser managed to turn it into, and below that the assembly code that the core got changed to in the end.
11:37:40 <monochrom> like I said, it does not have to be. write your own compiler to eliminate polymorphism at run time
11:37:44 <docksider> Im not saying it is a bad decision to box everyting, I'm saying that I can't understand it
11:37:52 <RichyB> It also prepends a little report about which code simplification rules were activated how many times.
11:38:03 <docksider> cool
11:38:08 <ab9rf> Mortchek: i'm probably prematurely optimizing :)
11:38:17 <ski> monochrom : .. except polymorphic recursion (unless you intend RTCG ;)
11:38:48 <Mortchek> ab9rf, that temptation is too strong :)
11:39:10 <ski> docksider : it makes it simple to implement e.g. `length' -- it doesn't need to know the size of the elements of the list
11:39:26 <ab9rf> Mortchek: my main concerns about the list-of-pieces strategy is that building the list of possible moves for a given piece in a given position is O(n), where n is the number of pieces.  with the map implementation it's O(lg n)
11:39:40 <RichyB> docksider: if you start playing with ghc-core, you'll find that GHC is pretty good at this. For example, I once wrote a barrier implementation in terms of MVar and it completely unboxed everything.
11:40:07 <ski> docksider : so, there can be a single `length', rather than one version for every element type you use `length' on in your program (which may be infinite, in case of polymorphic recursion)
11:40:11 <ab9rf> well, O(lg n) where n in the number of _squares_
11:40:24 <ab9rf> which is a lose in the endgame, i suppose
11:40:28 <ab9rf> but a win in the foregame
11:40:35 <docksider> Imo that should be solved just before linking, recompile all the imported code for your types. It would probably increase the time needed to compile large projects a lot
11:40:37 <Mortchek> ab9rf, oh I wouldn't call using a map instead of a [(Position, Piece)] premature optimization. That's just leveraging abstraction to simplify code.
11:41:06 <ski> docksider : doesn't solve the polymorphic recursion case; you'd need RTCG for that
11:41:14 <ab9rf> Mortchek: on the other hand, the list of pieces strategy makes "is the game over" test fairly quick :)
11:41:57 <docksider> ski: I don't understand why I need RTCG for taht
11:41:57 <ab9rf> Mortchek: i suspect that it's a tradeoff, you'll gain performance in some places and lose it elsewhere. :)
11:42:01 <docksider> that*
11:42:25 <monochrom> do you know polymorphic recursion?
11:42:30 <ab9rf> Mortchek: pick the representation that makes your algorithm easier to express and make it faster later :)
11:42:32 <docksider> no
11:42:38 <Mortchek> ab9rf, indeed \o/
11:42:51 <docksider> I guess that is what im missing then :)
11:43:04 <ab9rf> Mortchek: i can't decide whether one list of pieces, or two, makes more sense
11:43:12 <supki> adek: if something returns Maybe it always returns Maybe, a tutorial is probably outdated
11:43:14 <ab9rf> Mortchek: i mean, yeah, you could just have one list and use filter i guess
11:43:33 <ab9rf> black = (filter . isBlack) pieces
11:43:56 <docksider> I was about to say what would you need that for
11:44:02 <docksider> then I realized
11:44:04 <docksider> Yes
11:44:08 <docksider> that might be a problem
11:44:13 <Mortchek> ab9rf, I think a Map Position Piece mixing both colors would be all right.
11:44:48 <docksider> Well generic polymorphic reursion might be a problem
11:45:07 <ab9rf> Mortchek: it's probably a god place to start
11:45:09 <ab9rf> er, good
11:45:31 <ski> > let foo :: Show a => [a] -> [String]; foo [    ] = []; foo (a:as) = show a : foo (map (:[]) as) in foo [0,1,2,3]
11:45:32 <docksider> But i can't imagine any complex usecases for it
11:45:33 <lambdabot>   ["0","[1]","[[2]]","[[[3]]]"]
11:45:38 <ab9rf> Mortchek: plus that is a fairly general presentation, you could easily generalize it to 3d checkers or chinese checkers
11:45:53 <Mortchek> Or even many-team checkers :)
11:45:55 <ab9rf> Mortchek: just by changing the "Position" type and "Piece" types
11:46:13 <ab9rf> Mortchek: chinese checkers can be played by up to six players or with teams of two or three
11:46:20 <ski> docksider : consider this function ^. you can't know until run-time how many monomorphic version of it you'll need
11:46:21 <Mortchek> Ah, neat.
11:46:37 <docksider> If it depends on IO atleast
11:46:47 <ab9rf> Mortchek: it's a triangular grid board so representing the squares would be more interesting but the basic structure would be the same
11:47:01 <ab9rf> Mortchek: oh, there's a hakcage library for this sort of thig
11:47:04 <ab9rf> just remembered it
11:47:04 <docksider> But yes, it very much justifies boxing
11:47:06 <Mortchek> As long as you can establish a coordinate system and a sense of adjacency, you can do it.
11:47:17 <ab9rf> @hackage grid
11:47:17 <lambdabot> http://hackage.haskell.org/package/grid
11:47:33 <Mortchek> :0 That is neat.
11:47:33 <docksider> ski: Thanks I understand the problem now :)
11:47:38 <ab9rf> Mortchek: it was mentioned in one of the "games in haskell" articles i read the other day
11:47:51 <ab9rf> Mortchek: might work for you,
11:47:51 <docksider> Also gained a bit of respect for cons-cells
11:47:53 <Mortchek> Got the link to the article? I wanna get into that stuff.
11:48:00 <ab9rf> Mortchek: lemme see if i can fnd it
11:48:30 <ski> docksider : also, potential for code explosion
11:48:48 <adek> adek: Indeed. It fails to compile, thank you.
11:49:00 <adek> s/adek/supki :-)
11:50:32 <ab9rf> Mortchek: the obvious starting point is http://www.haskell.org/haskellwiki/Game_Development
11:52:25 <ab9rf> Mortchek: unfortunately i read the article on my phone which doesn't stash browser history as well, i can't find it
11:53:35 <chrisirc> To resolve "Ambiguous module name `Data.Vector': it was found in multiple packages: vector-0.10.0.1 AC-Vector-Fancy-2.4.0" it works to pass ghci the -hide-package option;
11:53:56 <chrisirc> but, for better comfort, location, etc., could I say the same thing in the source file?
11:54:12 <johnw> import "vector" Data.Vector works
11:54:15 <chrisirc> i.e. change "import Data.Vector" to something that qualifies it?
11:54:18 <chrisirc> ah
11:54:39 <johnw> it'll want an extension, but it should name it in the error message
11:55:17 <ab9rf> Mortchek: "haskell game development" as a google search found several decent articles for me
11:57:03 <Mortchek> ab9rf, yeah, I've checked out some of those, but was curious about this one in particular. Thanks though.
12:00:05 <ab9rf> Mortchek: i'm not sure which one it was that mentioned grid
12:02:10 <ab9rf> i dunno how grid performs
12:02:35 <ab9rf> but it seems that it might be a nice basis to build on, especially ince it also would allow for some fun modifications
12:02:43 <ab9rf> checkers on a hex grid could be fu
12:02:46 <ab9rf> fu
12:02:47 <ab9rf> n
12:03:03 <Mortchek> No that's right too, checkers on a hex grid could also be fuuuuu
12:03:12 <chrisirc> should I use Data.Array.Repa or some of the other (newer) parallel array libraries if I'm starting out in high performance computing?
12:03:31 <monochrom> yes
12:03:40 <chrisirc> Trying that one currently, but finding it hard to get my first program to run (getting type error over my head right now).
12:04:42 <chrisirc> monochrom, whas that a yes towards me?
12:05:15 <monochrom> yes
12:05:24 <chrisirc> k
12:05:39 <ab9rf> Mortchek: the one thing grid doesn't do is give you a easy way to enumerate jump moves
12:05:44 <monochrom> repa is a good place to start
12:06:12 <ab9rf> Mortchek: i'm also tempted to extend it to allow joining two bounded grids along a given edge
12:08:20 <ab9rf> Mortchek: with self joins you can make the double mobius board, which is freaky weird to play on
12:11:09 <chrisdone> so i'm messing around with aeson and i don't quite follow how to use the takeWhile of Data.Attoparsec.Text:
12:11:09 <chrisdone> λ> eitherResult (parse (takeWhile (const True)) "look ma, no hands!") →  Left "Result: incomplete input"
12:11:09 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
12:11:09 <chrisdone> whereas λ> eitherResult (parse (takeWhile (/= '!')) "look ma, no hands!") → Right "look ma, no hands"
12:11:09 <chrisdone> based on my experience of Parsec, i'd expect EOF to count as a 'False' which is triggered on the ! here, but it ain't, and it don't. it makes writing some parsers rather tricky or impossible. what's the deal?
12:12:04 <chrisdone> i'm writing a parser now, so i can produce an example of where this makes things hard, maybe you have some suggestions for alternative ways to write the code
12:13:14 <napping> eitherResult flattens "Partial" to an error
12:13:19 <Mortchek> ab9rf, what's that?
12:13:56 <ab9rf> Mortchek: the double mobius board?  it's a square board, where the north edge is connected to the south edge with a half twist, amd the east edge is connected to the west edge also with a half twist
12:14:18 <chrisdone> napping: ah, so i could use parseWith, perhaps
12:14:21 <Mortchek> Half-twist?
12:14:43 <luite> chrisdone: hey I want to submit a "foreign import javascript" patch to GHC HQ? would something like that also be useful fay? if so, any requests or suggestions?
12:14:52 <ab9rf> Mortchek: (0,0) is adajcent to (0,1), (1,0), and (n-1,n-1)
12:14:54 <johnw> chrisdone: what about using endOfInput?
12:15:03 <johnw> or atEnd?
12:15:34 <napping> or parseOnly, if you want something simple
12:15:37 <ab9rf> Mortchek: (0,1) is adajcent to (0,0), (0,2), (1,1), and (n-1,n-2)
12:16:30 <ab9rf> Mortchek: basically (0,k) and (n-1,n-1-k) are adjacent
12:16:32 <chrisdone> ah, parseOnly does the trick
12:16:41 <Iceland_jack> hugs!
12:16:48 <luite> chrisdone: i have a patch ready that supports this: http://hpaste.org/84429
12:16:55 <ab9rf> Mortchek: the toroidal map has (0,k) and (n-1,k) adjacent (no twist)
12:17:16 <ab9rf> Mortchek: and also (k,0) and (k,n-1); if you only do one dimension you have a cylinder instead
12:17:41 <ab9rf> with a twist in one dimension only it's a simple mobius strip
12:18:28 <Mortchek> ab9rf, I'm having trouble visualizing that to the point that it can be called a half-twist. Got a diagram?
12:18:33 * sproingie tries to visualize it and fails.  guessing it's impossible in three dimensions?
12:18:46 <chrisdone> johnw: i think those don't help. e.g. λ> eitherResult (parse (do takeWhile (const True); endOfInput → Left "Result: incomplete input"
12:18:53 <sproingie> the double möbius that is
12:19:04 <ab9rf> sproingie: it's an imbedding in a manifold of some sort but yeah, it's not possible to exist.  probably a klein bottle.
12:19:12 <chrisdone> johnw: whereas λ> parseOnly (takeWhile (const True)) "look ma, no hands!" → Right "look ma, no hands!"
12:19:23 <napping> why are you using eitherResult?
12:19:35 <ab9rf> sproingie: but i won't attest to that, i'm not an algebraic topologist.
12:19:57 <chrisdone> napping: so i can look at the error or get the value. what do you mean?
12:20:11 <napping> there's a Show instance for Result
12:20:15 <chrisdone> napping: just the typical parsec use-case. parse some stuff
12:20:19 <ab9rf> er, possible in three dimensions alone.
12:20:29 <chrisdone> napping: i don't mean inspect with my eyes, i mean with the code
12:20:31 <chrisdone> luite: hmm
12:20:39 <ab9rf> Mortchek: the single half twist (in one direction only) is a mobius strip
12:20:42 <napping> seems like getting Partial _ vs. Left <error> would make these situations a bit clearer
12:20:44 * chrisdone reads
12:21:11 <ab9rf> i don't think parsec supports partial parsing
12:21:21 <napping> 0.
12:21:39 <chrisdone> ab9rf: pretty sure it does? you can consume as much as you want. maybe that's not what you mean?
12:21:56 <luite> chrisdone: it's just a foreign import declaration that accepts any string (but will throw an error if you use it when generating native code)
12:21:56 <alexander__b> the book I'm following tells me to make scripts, do :l script -- and reload it when I change it. is there a way to get vim bound to the interpreter like you can with BASH and Python (and others)?
12:22:09 <ab9rf> chrisdone: partial parsing means that when you fail, you leave the input at the fail point and return what you successfully parse
12:22:25 <chrisdone> ahh, ok
12:22:28 <napping> The problem is that without using something like parseOnly to tell it input is over, you can't tell the difference between the cases where the string so far is valid but more input might also be accepted, and the case where the current input is invalid, but more might finish the parse
12:22:39 <alexander__b> e.g. in BASH ("everyone" has this), you may run fc -- or if you are using standard keybinds do ^X ^E to get a vim instance.
12:22:40 <ab9rf> chrisdone: useful when you have one language that contains self-bounding constructs within it that are in a different language
12:22:41 <luite> chrisdone: the rest is the same as ccall, but that could be changed, it could allow unboxed tuple returns, or perhaps more types that can be automatically marshalled, things like that
12:23:22 <chrisdone> luite: hmm. what about passing Strings to it?
12:23:26 <ab9rf> chrisdone: it's hard to do in parsec because of how parsec works
12:23:33 <supki> alexander__b: you probably want :e
12:23:45 <ab9rf> chrisdone: LR parsers can do partial parsing fairly easily
12:23:48 <alexander__b> supki: glorious! thanks.
12:23:59 <luite> chrisdone: would the callee get a javascript string? or a reference to some list element?
12:24:29 <chrisdone> luite: the callee would get a javascript string
12:25:13 <chrisdone> String -> String (at least in fay) is unserialize_back_to_fay_list(the_js_fun(serialize_to_js_string(x))
12:25:48 <luite> chrisdone: I'll check if that's easily doable there
12:26:05 <byorgey> cm
12:26:14 <chrisdone> luite: i guess it's just a white list in ghc's ffi code right?
12:26:57 <mjrosenb> morning everyone.  is there a generic frp libary that isn't tied to a particular gui/other means of inputting data?
12:27:22 <chrisdone> luite: the name 'CString' doesn't even make sense for javascript, thinking about it. it should be JSString or something. but i guess that doesn't fit well with your existing ghcjs stuff
12:27:24 <luite> chrisdone: for things like Int, there is already code to unbox and rebox the primitive Int# inside, in core
12:28:01 <chrisdone> luite: ah right. cool. so that kind of convenient serialization is justifiable if it already exists
12:28:32 <jfischoff> mjrosenb: netwire? (could be wrong…)
12:28:39 <alexander__b> supki: kind of wish :wq would do :r, but I think that might be the kind of thing that would bite me in the ass some day.
12:29:00 <supki> alexander__b: it does :r in newer versions
12:29:06 <chrisdone> luite: thinking aloud, kinda weird that this kind of thing isn't done for Strings, i suppose. it's not like it would be a performance hit if you're going to be using withCString anyway…
12:29:08 <supki> starting from 7.6.1 I think
12:29:19 <luite> chrisdone: I'm not too worried about names, CString is just an pointer, those will still be supported for all the other things that depend on them. but hopefully more convenient alternatives are possible for real strings
12:29:51 <alexander__b> supki: I only have 6.12.3-r2, as I was told this was the most OK one to start out with. it's the only one that's in Gentoo stable as well. (testing has up to 7.6.2.)
12:30:06 <mjrosenb> jfischoff: neat, I'll look into it.
12:30:12 <chrisdone> luite: sure
12:30:36 <luite> chrisdone: hmm, i don't know, i think a problem might be that converting the string also depends on the system encoding
12:31:48 <chrisdone> luite: yeah if that's do-able, that would be proper cool. it's tricky as fay's ffi is a lot more magic and people kind of expect these things of it now. well, people even want polymorphic types to be serialized automatically
12:32:43 <ski> `fay' ?
12:32:54 <chrisdone> @google fay lang
12:32:56 <lambdabot> https://github.com/faylang/fay/wiki
12:33:23 <ski> (hm, empty page to me)
12:34:13 <chrisdone> ski: well it's a compiler from a subset of haskell to javascript
12:34:35 <chrisdone> (based on haskell-src-exts)
12:35:37 <luite> ski: Fay has substituted typeclasses with magic!
12:35:55 <alexander__b> can someone point me to the most accepted code styles? some dos and donts? e.g. when to use linebreaks, how many spaces, soft or hard tabs, etc.
12:36:09 <Botje> haskell and tabs = sadness
12:36:32 <chrisdone> luite: i actually tried to use some of the haskell-suite packages the other day but couldn't get the things to compile on my ghc version. kind of ironic that the libraries made to make non-GHC-dependent haskell compilers are dependent upon GHC's latest gubbins
12:36:40 <luite> hehe
12:37:03 <alexander__b> Botje: hard tabs in general make me cringe
12:37:16 <luite> chrisdone: are they almost ready for general use though?
12:37:44 <Botje> alexander__b: i'm usually a tabs+spaces person, but haskell is spaces only.
12:38:17 <alexander__b> I set up https://github.com/wlangstroth/vim-haskell -- but obviously this doesn't enforce some dos and donts. such as when (if ever) to break if/then/else into several lines and so on.
12:38:41 <chrisdone> luite: lots of TODOs, i think still in alpha stage. it's hard to follow, info's scattered all around
12:38:55 <chrisdone> luite: (i mean it's hard to follow the development of the 'suite' as a whole)
12:39:35 <luite> chrisdone: but they're still working on it, right?
12:39:53 <alexander__b> also despite not starting haskell yet (starting Monday), please tell me it's one of them neat languages where statements and expressions aren't two entirely differnt things, making things like "a = if b then c else d" possible.
12:39:55 <jMCg> Hello happy people o/~
12:40:03 <alexander__b> (or equivalent)
12:40:28 <geekosaur> you could say that... there isn't really a concept of statements in haskell
12:40:30 <sproingie> alexander__b: it's exactly one of those languages.  in fact it's hard to say haskell has "statements" at all
12:40:33 <shachaf> alexander__b: There are no statements.
12:40:48 <sproingie> top-level bindings are about as close as it gets to discrete containers of expressions
12:40:54 <alexander__b> thank god^wthe language designers.
12:40:57 <geekosaur> (do expressions can *look* like statements, but in fact are expressions)
12:41:02 <shachaf> alexander__b: (But there are things that behave a lot like statements. But they're actually expressions.)
12:41:05 <jMCg> One of my devs is asking me to setup a buildslave with haskel platform in the latest version, and with cabal in the latest version. Stuipid question time: Can I install/update cabal (packages) globally? Are there Debuntu packages for the latest haskel/caball?
12:41:30 <napping> jMCg: there are rarely packages for the latest version
12:41:44 <chrisdone> luite: mm last push was a month ago
12:41:58 <sproingie> i couldn't make eclipseFP play nice with the haskell platform, so i built 7.6 ... we'll see how it goes
12:42:00 <alexander__b> I made a thread on reddit on how to learn haskell in a week. most people just told me that I couldn't, hehe. I'll try, and see how far I get.
12:42:10 <sproingie> you can learn the basics in a week
12:42:23 <luite> chrisdone: hmm, so you might need to push some Fayians their way to help
12:42:29 <chrisdone> jMCg: yeah there are debian packages for both. you can also install globally or per user. there's a flag to pass to cabal to choose
12:42:30 <sproingie> haskell is one of those "easy to learn, hard to master" things
12:42:31 <napping> but the Haskell platform installer should work fine. You can install packages globally, but you have to be careful about dependencies. Might be better just to leat users install
12:42:54 <chrisdone> luite: yeah i guess that's one way to answer people demanding type-classes =p "send patches to niklas!"
12:43:31 <luite> i tried compiling haskell-src-exts with ghcjs this weekend... took 20GB RAM at first :/
12:43:38 <luite> i optimized it later
12:43:51 <alexander__b> sproingie: I usually spend three days to get the basics, but since I haven't yet entirely groked functional programming (to my great shame), I thought I'd give it a week. I only know basic common lisp and some scala.
12:44:18 <shachaf> Shame is not a good mindset for lerning things.
12:44:23 <jMCg> chrisdone: AAaah.. ACK. (My assumption was, if I do it as root, it will automagickally install globally)
12:44:24 <chrisdone> luite: lol. fay also hogs memory. 1.2gb or so reported by johnw
12:44:28 <alexander__b> sproingie: I know enough common lisp to be annoyed when I found out that * 6 7 returned an error. =/
12:44:45 <sproingie> eh?  (* 6 7) works for me
12:44:58 <alexander__b> shachaf: my mindset is mostly "functional programming is the future for game programming".
12:45:01 <sproingie> the parens are kinda part of the syntax there
12:45:13 <napping> There's quite a range in how functional scala and common lisp can be
12:45:14 <chrisdone> jMCg: istr global used to be the default, then it was changed to user. maybe i'm misremembering
12:45:16 <shachaf> Oh, you're the person who posted that post on Reddit. I second those people's recommendations to spend more than a week.
12:45:19 <hiptobecubic> has anyone tried tying eclipsefp into vim with eclim yet?
12:45:22 <alexander__b> sproingie: I get a bunch of errors.
12:45:29 <luite> chrisdone: GHC also uses 1.3GB on these files, and produces an 8MB .o file (ghcjs now uses 5GB or so, still some optimization needed, and produces 70MB javascript files (before minification))
12:45:41 <shachaf> The primary benefit you'll see is most likely changes in how you think about things.
12:45:42 <alexander__b> sproingie: well just the one about no instance for(num t -> a))
12:45:52 * geekosaur hopes you are not trying to use clisp with ghci... haskell is not clisp
12:46:05 <monoidal> alexander__b: in haskell, it is (*) 6 7
12:46:05 <chrisdone> luite: haha, yeah that's pretty massive. stretching the limits of what google closure can handle
12:46:11 <alexander__b> monoidal: ah
12:46:12 <luite> chrisdone: (that can all be reduced a lot by disabling -O)
12:46:20 <sproingie> ohhhh i thought you were getting that in common lisp
12:46:39 <sproingie> in haskell it can be (*) 6 7 but you can just do 6 * 7
12:46:40 <jMCg> oookay, so what am I doing wrong here: http://apaste.info/llUz ?
12:46:41 <monoidal> alexander__b: also note that unlike in lisps operators such as (*), (+) are binary
12:46:41 <alexander__b> monoidal: that is delicious. how do I nest though?
12:46:42 <sproingie> it even has precedence
12:46:44 <alexander__b> sproingie: sorry heh
12:46:50 <shachaf> Haskell is not Lisp -- you won't get that far by expecting it to be Lisp.
12:46:53 <monoidal> alexander__b: 6 * 7 * 8 or product [6,7,8]
12:47:05 <shachaf> * is an infix operator.
12:47:20 <alexander__b> monoidal: I meant can I nest it with Polish notation?
12:47:23 <sproingie> it should take you less than a week to get through LYAH
12:47:32 <monoidal> alexander__b: (*) 6 ((*) 7 8)
12:47:33 <alexander__b> shachaf: I really don't. I just like Polish notation for maths.
12:47:35 <sproingie> after which you'll know the basics and then some
12:48:05 <S11001001> @remember sproingie it should take you less than a week to get through LYAH
12:48:05 <lambdabot> Done.
12:48:07 <sproingie> this does assume that you spend time reading it and not here or reddit :)
12:48:08 <alexander__b> monoidal: that's kind of ugly but hey at least it's doable. worst case, I can write my own functions for it.
12:48:41 <alexander__b> sproingie: I use a stopwatch for work. it's off ATM. ;-)
12:48:44 <sproingie> with my poor attention span it would take me about 2-3 weeks but that's just me
12:49:01 <chrisdone> my one recommendation for learning haskell most efficiently: properly understand how types, kinds and type-classes work and properly grok laziness and how it's implemented in the trivial case. those are the two _really_ foreign things that will trip you up later on. everything else is so-so imo
12:49:05 <shachaf> alexander__b: There are no varargs functions in Haskell (generally). Each function takes a aprticular number of arguments.
12:49:13 <shachaf> Well, in particular each function takes one argument.
12:49:13 <sproingie> namely one
12:49:19 * sproingie loses
12:49:39 <shachaf> But you can pretend a function takes N arguments; but then it's always the same N.
12:49:39 <sproingie> i had that explained really well in LYYARWGH if i say so myself
12:49:43 <sproingie> i really regret erasing it
12:50:09 <sproingie> i even had exercises and everything
12:50:12 <alexander__b> scgilardi: aww. I wanted a min/max that takes vararg.
12:50:16 <napping> jMCg: cabal-install is the package with the "cabal" executable
12:50:22 <alexander__b> sorry shachaf ^
12:50:40 <geekosaur> alexander__b, in that case you may want the version that operates on lists
12:50:41 <shachaf> alexander__b: But there is a good reason for this, which you will find out in due time.
12:50:44 <monoidal> alexander__b: instead of vararg functions, haskell uses functions that take lists. for example, maximum/minimum
12:50:54 <alexander__b> shachaf: I don't doubt that. :-)
12:51:02 <alexander__b> monoidal: lists of arbitrary sizes?
12:51:05 <monoidal> alexander__b: you can convert a "binary" function to a function taking a list using fold
12:51:08 <geekosaur> (in some sense, everything in lisp is a list; haskell doesn't work that way, but there is a list type with useful operations)
12:51:12 <mikurubeam> alexander__b: Varargs are evil, how do you even give it a type?
12:51:16 <sproingie> alexander__b: all lists are arbitrary size
12:51:17 <monoidal> alexander__b: yes
12:51:24 <shachaf> mikurubeam: Using a list!
12:51:30 <napping> jMCg: Cabal is a Haskell library for doing package/build stuff that cabal uses
12:51:30 <monoidal> foldl (+) 0 [3,4,5]
12:51:32 <mikurubeam> shachaf: A list is not varargs.
12:51:37 <monoidal> > foldl (+) 0 [3,4,5]
12:51:38 <lambdabot>   12
12:51:40 <alexander__b> so can I uhm min makeThisIntoAList(3 4 5 6 18 24)?
12:51:54 <monoidal> > minimum [3,4,5,6]
12:51:55 <lambdabot>   3
12:52:01 <shachaf> mikurubeam: int foo(char x, int* vararg) { ... }
12:52:02 <sproingie> you'll learn a lot more reading LYAH than random Q&A here
12:52:06 <shachaf> Not in Haskell, though. :-)
12:52:10 <alexander__b> monoidal: I'm just wondering whether there is a "makethisintoalist"
12:52:11 <shachaf> ==sproingie
12:52:17 <shachaf> alexander__b: See also the FAQ:
12:52:18 <shachaf> @where faq
12:52:18 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
12:52:26 <monoidal> alexander__b: list notation is used for this
12:52:26 <alexander__b> cool
12:52:42 <mikurubeam> shachaf: C types do not really mean anything.
12:52:57 <monoidal> alexander__b: I really recommend LYAH http://learnyouahaskell.com/chapters in case you haven't seen it yet
12:53:07 <shachaf> mikurubeam: That's not a C type, just C-ish notation.
12:53:11 <alexander__b> monoidal: I have that up, yes
12:53:13 <shachaf> mikurubeam: * means "zero or more", not "pointer"
12:53:22 <geekosaur> alexander__b, not in the sense of something built in that takes a lisp-notation thing and turns it into a haskell list; haskell is not lisp, it does not use lisp syntax. haskell syntax is [thing,another thing,..]
12:53:23 <shachaf> The point is that varargs are just notation for a list.
12:53:29 <alexander__b> monoidal: I'm going this route: http://stackoverflow.com/questions/1012573/getting-started-with-haskell -- well as much of it I can get through in a week's time.
12:53:59 <amyers> alexander__b: Why only a week?
12:54:01 <shachaf> I don't recommend "projecteuler" problems. In fact I recommend against them.
12:54:02 <mikurubeam> shachaf: I thought varargs, unlike list elements, were allowed to have heterogeneous types.
12:54:12 <alexander__b> amyers: that's when my easter break is over.
12:54:18 <amyers> ah
12:54:19 <alexander__b> amyers: well, the time of it I have for haskell at least.
12:54:26 <shachaf> mikurubeam: If you restrict it to that then it becomes more complicated.
12:54:28 <alexander__b> amyers: I will still keep using it, if I like it.
12:54:29 <monoidal> alexander__b: I think it's a good list, but as shachaf I recommend against doing project euler
12:54:32 <mikurubeam> shachaf: When I think varargs, I think the abomination printf is.
12:54:53 <shachaf> mikurubeam: You can make a type-safe dependently-typed printf, surely.
12:55:13 <alexander__b> amyers: I'm a game programmer, so I'll use it for games if I can grok it.
12:55:35 <shachaf> alexander__b: You'll benefit a lot more from allowing more than a week for a language, if what you're trying is the "one week per language" thing.
12:55:38 <alexander__b> monoidal: they don't look appealing to me, so that's nice to hear. as mentioned ^ I'm a game programmer. I want immediately useful things. project euler is a bit... meh.
12:55:51 <shachaf> I don't care whether the language is Haskell. Whichever one it is, more time is better than more languages.
12:55:54 <alexander__b> shachaf: I have one week. I thought, hey, I need to learn haskell.
12:56:12 <shachaf> OK.
12:56:29 <shachaf> I think the "I want immediately useful things" mindset will be harmful, but I suppose we'll see.
12:56:31 <sproingie> haskell for games, sure, doable and been done for a couple reasonably polished games
12:56:45 <sproingie> it's certainly a different world though
12:56:53 <alexander__b> sproingie: if not haskell for games, then at least groking functional programming will be endlessly useful.
12:57:04 <sproingie> it will help you write better code in any language, yes
12:57:04 <chrisdone> my colleague learned haskell from LYAH and was writing a multithreaded server within a week
12:57:06 <jMCg> napping: but it says it's using the library version 1.14.0 too..
12:57:24 <napping> jMCg: you didn't compile a new 'cabal', you're still running one build against 1.14.0
12:57:25 <alexander__b> jcarmack at id software for instance is veering towards functional programming, albeit in C -- and he really likes haskell.
12:57:25 <ski> luite,chrisdone : hm, ok
12:57:26 <chrisdone> (but he did have help from me regarding cabal friction)
12:57:31 <shachaf> chrisdone: You can write a multithreaded server within a day -- servers are not complicated, and threads are not complicated.
12:57:42 <sproingie> carmack mentioned haskell specifically did he?  interesting.
12:57:45 <amyers> http://norvig.com/21-days.html
12:57:49 <napping> jMCg: cabal install cabal-install should fix that
12:57:49 <otters> quick, trivialize his achievements
12:57:51 <jMCg> napping: I'm confused. Please unconfuse me.
12:57:59 <alexander__b> sproingie: he has mentioned it sometimes. he wants to teach his kid haskell, heh.
12:58:00 <amyers> sproingie: Yeah, I've seen him mention it in several different places.  It seems he really likes it
12:58:17 <alexander__b> sproingie: and yes, haskell specifically when talking about languages.
12:58:26 <sproingie> interesting.  i want to get into OpenGLRaw, but i'm a total FFI noob
12:58:27 <chrisdone> shachaf: depends on the 'you' and what the server is doing, ja
12:58:29 <jfischoff> alexander__b: but it doesn't sound like he knows it that well.
12:58:41 <sproingie> and there aren't any examples for OpenGLRaw i can find
12:58:48 <armlesshobo> why not just drop C and do functional programming Haskell? it'll save him the time and (unnecessary) effort.
12:58:49 <shachaf> chrisdone: Sure, servers can be arbitrarily complicated.
12:58:55 <armlesshobo> in Haskell*
12:59:13 <sproingie> oh pfft i forgot about the nehe tuts, i think those are using it.  man i'm a ditz
12:59:19 <alexander__b> jfischoff: I lolled a lot when he talked about duck-typing languages and said "my god, how can you write a real program where you're just assigning random shit to other shit and expecting it to work?"
12:59:28 <napping> jMCg: Maybe the biggest point is that compiled programs/libraries pretty much cannot pick up different versions of libraries than what they were built against (cross module inlining and stuff)
12:59:48 <sproingie> alexander__b: i've found that if i can manage to make my program compile, it just works the first time
12:59:53 <sproingie> might blow up the heap, but it works
13:00:07 <[swift]> can anyone recommend a project that uses greencard for FFI that works really well? (my intention is to look at the source code and learn from what they do)
13:00:11 <napping> jMCg: the other point is that a "package database" can only have one build of a particular version of a package at once
13:00:15 <ski> alexander__b : actually, neither declarations nor "statements" (as found in `do') support conditionals -- however, you don't tend to miss this that often in practice (though i have missed it), because usually the interesting stuff happens in expressions
13:01:03 <alexander__b> I can't fathom how duck-typing would work if you have several hundreds of thousands of lines of game code.
13:01:16 <Kinnison> alexander__b: 'carefully'
13:01:20 <alexander__b> but I might just be inexperienced. :-)
13:01:32 <alexander__b> Kinnison: I don't even know a real life example of anyone attempting this.
13:01:43 <hiptobecubic> alexander__b, there are plenty of enormous examples of codebases in python that work fine
13:01:49 <shachaf> Game code is not, as far as I know, magic.
13:01:53 <napping> jMCg: in particular, if one program needs foo-1.2.3 and bar-2, and another needs foo-1.2.3 and bar-3, it's impossible to have things set up at once, so it's generally better to have most things installed per-user or even sandboxed per-build
13:01:59 <alexander__b> Kinnison: but yes, "carefully" and "with great difficulty" would be my assumption.
13:02:18 <jfischoff> alexander__b: its a bad idea, but many great games are pretty terrible examples of programming.
13:02:21 <alexander__b> hiptobecubic: games are commonly not very modular.
13:02:35 <ab9rf> sproingie: about the only times i've had programs that compile fail to work s when they have infinite loops or they invoke FFI code that is broken :)
13:02:46 <alexander__b> hiptobecubic: so a Web stack is not very comparable to a FPS IMO. but again, I'm not very experienced.
13:02:48 <mcstar> obviously, duck typers are smarter than ppl using statically typed languages - or they have a unit test for most things, idk
13:02:48 <wires> alexander__b: you can actually do it with extensible records, that works
13:02:56 <[swift]> ab9rf: heh, that's exactly the problem i have been faced with lately. i wish everything was written natively in haskell =)
13:03:01 <alexander__b> but hey, enough procrastination. I'm turning on my stopwatch and working on.
13:03:05 <alexander__b> mcstar: haha
13:03:10 <wires> alexander__b: it gives you type checking and when scoping things in modules it's actually nice
13:03:35 <jMCg> napping: ACK.
13:03:41 <sproingie> i'd only turn on that stopwatch when the irc window is closed, lest its siren song tempt you back :)
13:03:42 <hiptobecubic> alexander__b, names become much more important
13:03:42 <hiptobecubic> alexander__b, you stop naming things "a m p" and start naming them "monster.attack(player)"
13:03:46 <ski> sproingie : possibly alexander__b was thinking about "Functional Programming in C++" by John Carmack at <http://www.altdevblogaday.com/2012/04/26/functional-programming-in-c/>
13:05:15 <ab9rf> i can't stand 'duck typing'
13:05:32 <hiptobecubic> it's pretty antithetical here
13:05:38 <Beetle_jada> how do i find out if Sam Anklesaria is in chat?
13:05:38 <ab9rf> it's sloppy
13:05:47 <ab9rf> if yu don't know what you're doing, why are you doing it?
13:05:52 <sproingie> i've always thought "duck typing" described type inference better than the dynamic typing of scripty languages
13:05:55 <ski> is "duck typing" meant to be structural object/record typing, sans the static typing ?
13:06:03 <Beetle_jada> Sam Anklesaria's nick is bogiebro
13:06:09 <ski> (iow, being all in your head)
13:06:12 <sproingie> "if it walks like a duck and quacks like a duck then you tell it to bray like a donkey, then you don't have a duck or a donkey so COMPILE ERROR"
13:06:16 <ab9rf> sproingie: dynamic typing in scripty languages is just a form of duck typing
13:06:27 <hiptobecubic> it's more like, you assume every object is in every typeclass
13:06:36 <sproingie> whereas python will quite happily accept your duck-donkey chimera
13:06:37 <ski> Beetle_jada : try `/whois bogiebro'
13:06:37 <ab9rf> sproingie: the insane type juggling of many scripty languages
13:06:38 <hiptobecubic> or implements it, rather
13:06:44 <napping> ski: I think that's how we would think about it "If we had a proper structural record system, this would typecheck"
13:06:52 <ab9rf> the ability to add methods to individual objects on the fly
13:06:59 <napping> jMCg: anyway, got cabal installed?
13:07:02 <jMCg> I think I'm gonna write a puppet module for this.
13:07:07 <ab9rf> if you want a duck-submarine-employee-tomato, you can do that
13:07:16 <Beetle_jada> ski: it says 'No such server'
13:07:18 <hiptobecubic> sure
13:07:24 <Beetle_jada> is there some sort of bot about this or something?
13:07:35 <sproingie> @remember ab9rf (on duck typing) if you want a duck-submarine-employee-tomato, you can do that
13:07:35 <lambdabot> Done.
13:07:36 <jMCg> napping: yesno. I wanted it in /usr/bin, but that seems to be a no-no. (works out fine in /usr/local/bin, though)
13:07:37 <ski> Beetle_jada : here it says "-!- There is no such nick bogiebro"
13:07:56 <Beetle_jada> preflex: seen bogiebro
13:07:56 <preflex>  bogiebro was last seen on #ghc 1 year, 207 days, 1 hour, 31 minutes and 40 seconds ago, saying: dcoutts: did you get my email?
13:07:58 <jMCg> napping: but I think I'll follow your advise and do it on a per-user base.
13:08:05 <ab9rf> sproingie: oddly eough, duck typing also imposes fairly serious performance penalties in those languages and makes assisted refactoring in them nearly impossible.
13:08:11 <Beetle_jada> preflex: xseen bogiebro
13:08:12 <preflex>  bogiebro was last seen on freenode/#ghc 1 year, 207 days, 1 hour, 31 minutes and 56 seconds ago, saying: dcoutts: did you get my email?
13:08:14 <napping> jMCg: you might want to ask a bit more how they are planning to run builds. if it's cabal-dev or something you don't need to worry about installing too many packages (though you may need to install C libraries packages requires, distribution packages work great for those)
13:08:19 <hiptobecubic> ab9rf, it's just implicit instead of explicitly passing around functions to work on the data. Not that it isn't dangerous
13:08:27 <ski> (Beetle_jada : meaning that there is no one using that nick online at this IRC network atm)
13:08:28 <sproingie> ab9rf: yep, the tools that actually do refactoring on python code ... use type inference
13:08:32 <hiptobecubic> ab9rf, that's rarely a strong goal of the language though
13:08:35 <jMCg> napping: it is cabal-dev, yes.
13:08:43 <Beetle_jada> but he/she was online nearly two years ago
13:08:50 <Beetle_jada> it is probably the same person
13:08:55 <ab9rf> sproingie: and type inference in python, php, perl, etc. is _hard_
13:09:14 <hiptobecubic> I've been really happy with Cython's restricted subset of python
13:09:24 <jMCg> napping: is there any documentation I may want to read on the subject? (i.e.: Java has Maven, Perl has CPAN, Ruby has Gems, Python has.. many things...)
13:09:42 <ab9rf> sproingie: not because their type systems are complex, but because the tool has to look in so many places to determine a type
13:09:43 <ski> Beetle_jada : `/msg NickServ info bogiebro' says "Last seen  : May 16 22:58:45 2012 (44 weeks, 0 days, 21:10:01 ago)"
13:10:08 <Beetle_jada> ah
13:10:12 <hiptobecubic> Then you get strong typing when you specify it, duck typing if you'd rather not, and it can still literally be as fast as C because it compiles to unadulterated C anyway
13:10:28 <Beetle_jada> ski: can you not see my messages with the preflex bot?
13:10:53 <sproingie> lisp has classically done pretty well with type hints alone
13:11:00 <napping> jMCg: monochrom's overview might be a good place to start http://www.vex.net/~trebla/haskell/sicp.xhtml
13:11:00 <ski> i can
13:11:39 <jMCg> napping: thank you very much!
13:11:42 <napping> jMCg: I think if you only install the platform and cabal, and leave everything else per user or with cabal-dev it should work out
13:12:12 <ab9rf> sproingie: honestly i think lisp does better because lisp programmers are more likely to be disciplined programmers than are perl or python or (dear lord) PHP programmers
13:12:13 <jMCg> *nod*
13:12:25 <ab9rf> lisp has never been "popular"
13:12:33 <hiptobecubic> also true
13:12:40 <jMCg> napping: but what about deployment and management of cabal libs/programs?
13:12:40 <wires> ab9rf: it is pretty popular with clojure nowadays
13:12:46 <hiptobecubic> Although i think the feel in those three communities varies pretty wildly
13:13:04 <armlesshobo> ab9rf: i know AI that would disagree with you :P
13:13:56 <ski> (Beetle_jada : .. i just thought you'd maybe find it interesting to know that the nick `bogiebro' has been used more recently than "1 year, 207 days, 1 hour, 31 minutes and 56 seconds ago")
13:14:06 <Beetle_jada> i see, yes
13:14:09 <Beetle_jada> thankyou
13:14:34 <ab9rf> wires: i haven't looked at clojure yet.  i have a strict "one new language at a time" rule and right now haskell is in that spot
13:14:57 <hiptobecubic> perl embraces its "model your problem as a violently chaotic whirlwind" approach. python actively abhors that and tries really hard to austere and disciplined but is overwhelmed with brand-spanking-new first-time-ever programmers and php converts. php is mostly just ridiculous.
13:15:32 <hiptobecubic> the lisps have enjoyed safety in (small) numbers
13:17:00 <napping> jMCg: I don't know much about that, but ghc-compiled programs by default don't link dynamically to haskell libraries
13:17:20 <monoidal> time for a pet peeve
13:17:25 <jMCg> napping: okay.
13:17:36 <monoidal> what is a better term for "main function", since it's not a function? "main action"? "main value"? "main identifier"?
13:18:04 <ab9rf> hm, true, main is an IO (), isn't it?
13:18:15 <shachaf> "main"
13:18:17 <monoidal> it is commonly used misnomer, inherited from other languages, yet I would like to see a change
13:18:26 <monoidal> for example, ghc uses "main function" in error messages
13:18:41 <shachaf> The Report specifies that e.g. getLine is a function.
13:18:48 <shachaf> The Report is wrong.
13:18:57 <ab9rf> but it returns things, it must be a function! :)
13:19:06 <shachaf> It does not return things.
13:19:06 <ion> getLine 42
13:19:12 <ab9rf> shachaf: i know that
13:19:21 <ab9rf> shachaf: but it's _really_ hard to break that mentality
13:19:41 <shachaf> Perhaps you should help other with that by not saying wrong things. :-)
13:20:04 <ab9rf> shachaf: that's why i used an emoticon!  anything said with an emoticon is presumptively untrue.
13:20:18 <Iceland_jack> ab9rf is right :)
13:21:31 <monoidal> anyway I feel tempted to make a patch and change the messages in ghc
13:21:55 <Kinnison> main is a function
13:22:02 <Kinnison> it's a function which returns an IO ()
13:22:09 <ski> monoidal : "main action" or "main entry point" perhaps ?
13:22:15 <ab9rf> Kinnison: a niladic function?
13:22:16 <shachaf> Kinnison: No, it's not.
13:22:18 <Kinnison> ab9rf: yeah
13:22:19 <ski> Kinnison : no, functions must have a `->' in their type
13:22:23 * Kinnison bahs
13:22:24 <monoidal> ski: main entry point, really nice
13:22:29 * Kinnison gives up trying to be Devil's advocate
13:22:36 * Kinnison clearly didn't believe in it enough
13:22:42 <monoidal> Kinnison: http://conal.net/blog/posts/everything-is-a-function-in-haskell
13:22:45 <ab9rf> haskell makes no distinction between "niladic functions" and instance values
13:22:58 <ab9rf> you can argue that 2 is a "function" of no arguments that returns 2
13:23:00 <Mortchek> Essentially all functions are unary in Haskell.
13:23:01 <shachaf> ab9rf: No, there's a clear distinction.
13:23:22 <shachaf> ab9rf: "niladic functions" don't exist; instance values have to do with type classes.
13:24:02 <shachaf> I'm not quite sure what they are, really.
13:24:06 <mm_freak> ab9rf: 2 can be a function, if there is a suitable instance, but 2 :: Integer is definitely not a function and it's wrong to call it one
13:24:07 <ski> you may argue that `2' can be implemented as a procedure of no arguments -- but that's implementation details
13:24:11 <shachaf> I suppose fmap :: (a -> b) -> [a] -> [b] is an instance value.
13:24:37 <shachaf> No, that's bad terminology.
13:24:45 <shachaf> Ignore it.
13:24:47 <mm_freak> one of the basic properties of a function in haskell is that it can be applied
13:24:50 <ab9rf> well, my terminiology sucks
13:25:51 <Iceland_jack> imo it's fine to call procedures “nullary” functions in others languages, which basically correspond to actions in Haskell
13:26:03 <ab9rf> they're both kind *
13:26:37 <mm_freak> :k Int -> Int
13:26:38 <lambdabot> *
13:26:39 <mm_freak> :k Int
13:26:41 <lambdabot> *
13:26:42 <shachaf> Iceland_jack: No, it's not.
13:26:50 <Iceland_jack> shachaf: OK
13:27:02 <shachaf> Iceland_jack: Also, an action isn't a thing on its own. It's only meaningful with an interpreter.
13:27:06 <monoidal> Iceland_jack: that's fine in languages other than haskell; like void f(void) is a nullary function. in haskell, no
13:27:16 <Iceland_jack> monoidal: That's why I said other languages
13:27:25 <ab9rf> in imperative languages niladic functions typically do things that cause side effectrs or gather information from the environment.
13:27:37 <mm_freak> that's because other languages have a broken notion of "function"
13:27:45 <ab9rf> they have implicit parameters
13:28:01 <shachaf> Iceland_jack: If you decide that "action" means "something :: M A for a monad M", then [1,2,3] and id are both actions.
13:28:20 * ski is happy to call `[1,2,3]' a list-action
13:28:20 <ab9rf> heh
13:28:27 <Iceland_jack> shachaf: I believe that “IO a” may fairly be called an action
13:28:30 <shachaf> ski: I am too.
13:28:40 <shachaf> Iceland_jack: OK, and how about [1,2,3] and id?
13:28:45 <monoidal> shachaf: IMO "action" is an ellision of "IO action"
13:28:50 <shachaf> monoidal: ?
13:28:54 <ab9rf> but there are actions that are not IO actions
13:28:55 <shachaf> I certainly don't use it like that.
13:29:01 <Iceland_jack> What shachaf said, I assume it was obvious from context
13:29:08 <shachaf> [1,2,3] is a []-action, and ask is a (r ->)-action
13:29:10 <ab9rf> you can make a monad that encapsulates actions but that aren't applied to an IO context
13:29:11 <ski> monoidal : no, it's elision for `m'-action, where `m' is to be determined from the context
13:29:19 <ion> Ellision?
13:29:20 <monoidal> ski: agreed
13:29:22 <Iceland_jack> Since nullary functions are generally run for side-effects in imperative languages
13:29:24 <ab9rf> elision :)
13:29:36 <ski> @wn ellision
13:29:42 <lambdabot> No match for "ellision".
13:29:47 <monoidal> @wn elision
13:29:48 <lambdabot> *** "elision" wn "WordNet (r) 3.0 (2006)"
13:29:48 <lambdabot> elision
13:29:48 <lambdabot>     n 1: omission of a sound between two words (usually a vowel and
13:29:48 <lambdabot>          the end of one word or the beginning of the next)
13:29:48 <lambdabot>     2: a deliberate act of omission; "with the exception of the
13:29:50 <ab9rf> one 'l' only
13:29:50 <lambdabot>        children, everyone was told the news" [syn: {exception},
13:29:52 <lambdabot>        {exclusion}, {elision}]
13:29:54 <ion> TIL a new word
13:29:58 <Iceland_jack> RealWorld Haskell>  Anything that is type IO something is an I/O action.
13:30:02 <ocharles> ion: me too
13:30:02 <ski> ("TIL" ?)
13:30:08 <ion> Today i learned
13:30:11 <ocharles> ski: so tyl!
13:30:15 <ab9rf> truth in litigation
13:30:41 * ski . o O ( "Towniness Interparenthetically Lutestring" )
13:31:01 <ab9rf> always with the lutestrings
13:31:03 <Iceland_jack> shachaf: Is there still any misunderstanding?
13:32:05 <shachaf> Iceland_jack: Between whom?
13:32:13 <ab9rf> i misunderstand myself
13:32:24 <ab9rf> but i fear that's an irreducible conflict
13:32:45 <Iceland_jack> You mentioned non-IO actions, I used ‘action’ to refer only to IO actions via elision as shachaf pointed out
13:32:52 * Kinnison shifts ab9rf in an attempt to reduce him a little more
13:33:16 <ab9rf> Kinnison: shift me back so i can have my rightful gender again :\
13:33:25 <shachaf> Iceland_jack: Oh, then your use of "action" is too limited. IO is too ugly to get such a great word all to itself.
13:33:29 <Kinnison> ab9rf: oops, sorry :-)  *yoink*
13:33:40 <Iceland_jack> shachaf: Polysemy
13:33:43 <Iceland_jack> fix'd.
13:33:50 <Iceland_jack> @wn polysemy
13:33:50 <lambdabot> *** "polysemy" wn "WordNet (r) 3.0 (2006)"
13:33:50 <lambdabot> polysemy
13:33:50 <lambdabot>     n 1: the ambiguity of an individual word or phrase that can be
13:33:50 <lambdabot>          used (in different contexts) to express two or more
13:33:50 <lambdabot>          different meanings [syn: {polysemy}, {lexical ambiguity}]
13:33:52 <lambdabot>          [ant: {monosemy}]
13:33:54 <lispy> I thought IO () denoted an I/O action, but isn't one itself (oh, do I get points for being nitpicky?!)
13:34:02 <mm_freak> i think action is too specific to a certain interpretation
13:34:08 <mm_freak> i prefer computation
13:34:09 <shachaf> lispy: What?
13:34:25 <ski> lispy : a value of type `IO Foo' is an I/O action
13:34:27 * lispy is being silly
13:34:46 <lispy> IO Foo is a type
13:34:56 <mm_freak> but in general "monadic value" is probably the most appropriate term
13:35:04 * ski . o O ( type level CPS )
13:35:07 <sipa> no, it is just a sequence of ascii characters
13:35:18 <sipa> though it refers to a type
13:35:24 <shachaf> "action" is a great shorthand for "value of type M A for some monad M and type A"
13:35:26 <sipa> values of which are IO actions
13:35:57 <Iceland_jack> shachaf: So you might say ‘identity’ action for the identity monad?
13:36:05 <shachaf> You can also use it to mean "value to be interpreted"
13:36:08 <Iceland_jack> Not saying it's wrong, certainly interesting
13:36:15 <ski> Iceland_jack : or at least `Identity'-action
13:36:25 <shachaf> Iceland_jack: (Identity 5 :: Identity Int) is an Identity-action.
13:36:31 <shachaf> Those are very boring actions, though.
13:37:01 <ski> (just like actions of type `forall m. Monad m => m Int')
13:37:29 <hpc> Identity is a bit more interesting than that, in that runIdentity exists
13:37:57 <ski> you can use `runIdentity' on actions of my type, as well ..
13:37:58 <Iceland_jack> also runEval
13:38:02 * Iceland_jack hides
13:38:07 <hiptobecubic> why does gui programming feel so uniquely alien in haskell
13:38:24 <mm_freak> shachaf: i have a hard time calling "Branch (Leaf 3) (Leaf 5)" an "action" =)
13:38:26 <ab9rf> hiptobecubic: gui programming has always felt alien to me in all languages.
13:38:39 <ski> mm_freak : c'mon, it's fun :)
13:38:50 <mm_freak> =)
13:38:52 <hiptobecubic> ab9rf, it feels pretty normal in these abhorrent "duck typed" languages :)
13:39:07 <ski> mm_freak : you can call it a non-associative nondeterminism action, if you prefer
13:39:07 <mm_freak> hiptobecubic: did you try reactive-banana?
13:39:19 <hiptobecubic> mm_freak, I haven't.
13:39:19 <mm_freak> ski: true
13:39:21 <ocharles> ab9rf: +1
13:39:49 <ocharles> I wish I had a project realtime enough to want to learn netwire
13:39:52 <ocharles> it looks fun
13:40:09 <mm_freak> ocharles: netwire can be used in non-realtime scenarios
13:40:20 <mm_freak> for example networking
13:40:31 <ocharles> hmm, yes, I guess it can
13:40:36 <k00mi> is there a scenario where netwire can't be used?
13:40:38 <ocharles> maybe I mean a project with enough interdependent moving parts
13:40:39 <mm_freak> ocharles: ask yourself:  is my project a combination of components with local state?
13:40:43 <mm_freak> if yes, you can use netwire
13:40:52 <ab9rf> hiptobecubic: although languages with fairly concise ways to express closures are easier to deal with than those that don't have them
13:41:02 <ocharles> mm_freak: so basically what your telling me is "go learn netwire, and you'll see there are plenty of places where you'll find uses"
13:41:06 <ocharles> I like that suggestion :)
13:41:13 <mm_freak> k00mi: non-continuous applications
13:41:23 <mm_freak> ocharles: yeah =)
13:42:00 <ab9rf> hiptobecubic: otherwise you end up with tons of tiny stupid functions littering your namespace, or the Java technique of a polycephalous bag class that is just a container for a bunch of really-unrelated closures
13:42:14 <shachaf> mm_freak: I don't!
13:42:38 <shachaf> mm_freak: You just have to understand what its effects are.
13:42:51 <mm_freak> shachaf: substitution
13:42:59 <mm_freak> but it's declarative
13:43:08 <hiptobecubic> ab9rf, i haven't tried gui programming in java. I'm sure it's as terrible as everything else in java.
13:43:19 <shachaf> mm_freak: Do you object to calling [1,2,3] an action?
13:43:32 <mm_freak> shachaf: good question
13:43:36 <docksider> hiptobecubic: worse
13:44:23 <shachaf> mm_freak: How about a Free F for various Fs?
13:46:10 <mm_freak> shachaf: again good question
13:46:39 <hiptobecubic> mm_freak, this looks kind of like a synchronous programming language.
13:47:05 <mm_freak> hiptobecubic: counterexample: x <- integral_ 0 -< x
13:47:17 <mm_freak> =)
13:47:25 <mm_freak> oh, you're talking about reactive-banana?
13:47:34 <hiptobecubic> mm_freak, ok sure :) I'm only 17% done with the first page of the introduction
13:47:38 <hiptobecubic> mm_freak, yes
13:48:21 <ab9rf> hiptobecubic: it's really not any worse than any other imperative language, but the use of anonymous interface instances (that being Java's closest approximation to a closure) makes for a lot of tedious verbosity.
13:49:30 <hiptobecubic> ab9rf, that sounds significantly worse than many other imperative languages, granted the only language I use that doesn't have proper closures is C(++).
13:50:13 <ab9rf> hiptobecubic: well, it's better than C, which has no closures at all :)
13:50:32 <mm_freak> hiptobecubic: reactive-banana is FRP and comes with a ready-made WX layer
13:50:49 <ab9rf> reactive-banana is on my near-term reading list
13:51:06 <mm_freak> FRP is about time-varying values…  i would recommend netwire, but it has no GUI layer yet
13:51:10 <ab9rf> in part because i am seriously considering writing games in haskell and reactive-banana appears very useful for that
13:51:38 <hiptobecubic> I think C gets an unfair rap. If it were a new language there would be no question that it's "niche" and not supposed to be used for everything. Just because it's been around since before all of these nice languages were invented means it got used for things it wasn't any good for and was judged accordingly.
13:51:42 <mm_freak> ab9rf: if this is about realtime games, i recommend netwire instead of reactive-banana…  there are a few examples right on the FRP wiki page
13:51:57 <ab9rf> mm_freak: noted, i'll put netwire on the reading list too
13:52:23 <lispy> mm_freak: why is thta?
13:52:30 <mm_freak> lispy: what?
13:52:33 <hiptobecubic> what makes netwire more appropriate than banananana?
13:52:37 <lispy> yeah
13:52:40 <mm_freak> hiptobecubic: i don't see any use case at all for C…  i write even my current kernel project in C++
13:53:18 <ab9rf> i haven't used C since the late 90s
13:53:26 <ab9rf> no, wait i wrote a small project in C in 2003
13:53:33 <mm_freak> hiptobecubic: technically netwire is a thin layer around regular functions, so it's very efficient and flexible…  it makes development of custom components easy
13:53:34 <__books__> what is the negative thing about C really? It is an abstraction layer over the hardware. gives you good expressive power without loss of control(almost)...
13:53:49 <shachaf> This sounds a bit off-topic.
13:54:05 <hiptobecubic> a little
13:54:11 <mm_freak> __books__: because C++ gives you a few goodies from haskell land for low level projects that C lacks
13:54:28 <ab9rf> mm_freak: have you a suggestion for reading up on netwire?  the hackage page lacks any documention or links to documentation
13:54:34 <mm_freak> you even get a form of dependent types in C++
13:54:35 <ski> __books__ : no tail recursion, e.g.
13:54:48 <mm_freak> ab9rf: open the Control.Wire module
13:55:04 <mm_freak> ski: actually gcc has TCO
13:55:05 <ab9rf> mm_freak: thank you
13:55:06 <ski> (and returning multiple things is clumsy)
13:55:27 <dgriffi> Is there something in Text.Blaze.Html that creates a pagebreak?
13:55:42 <ski> mm_freak : well, yes. if you don't take address of `auto'-variables or something like that
13:56:07 <ski> (but if we're talking GCC, then we also have "downward FUNARGs")
13:56:16 <mm_freak> __books__: as a serious language even for low level development i demand at least:  some kind of encapsulation, some type-level features like parametric polymorphism, exceptions
13:56:33 <ab9rf> mm_freak: exceptions are a pain
13:56:41 <hiptobecubic> C++ exceptions are the worst
13:56:43 <ski> __books__ : oh yes, apart from parametric polymorphism, i also want existentials
13:56:57 <mm_freak> ab9rf: what do you suggest instead?  null?  -1?  ""?  some other PHP pain?
13:57:12 <ski> .. and an inst system wouldn't be half bad
13:57:24 <Cale> __books__: The thing about C is that it's sort of awkward -- it's too high level for a lot of low-level uses (where LLVM for example outshines it), and too low-level to really be worth struggling with for most everyday programming.
13:57:32 <ab9rf> mm_freak: not having exceptions is also a pain :)
13:57:42 <mm_freak> Cale++
13:57:53 <mm_freak> it's too high level where it should be lower level and too low level where it should be high level
13:57:55 <ab9rf> Cale: yeah, i think that about nails it
13:57:56 <Cale> There are very few applications where C is really the right thing anymore, but it's still popular because there are still a lot of people who know it.
13:58:23 <johnw> C is very easy source code to read, because there are so few magical things that can happen
13:58:24 <ocharles> heyyyy, I think I could use netwire for my hobby bitcoin trading thing
13:58:27 <mm_freak> ab9rf: that's my point…  i demand exception support
13:58:29 <ocharles> that I've not yet even started
13:58:33 <johnw> except when people get into pointer trickery
13:58:39 <ocharles> but for computing the moving averages of the market data, netwire seems ideal
13:58:46 <ab9rf> mm_freak: then get off the hardware stack :)
13:58:53 <Cale> ocharles: Do you have any idea what's been going on with the price of bitcoins recently? Why is it skyrocketing?
13:58:54 <ski> johnw : except when you UB and demons fly out of your nose :P
13:59:01 <johnw> BU?
13:59:07 <mm_freak> ab9rf: dunno if you overread it, but i'm writing a kernel in C++ ;)
13:59:08 <ski> Undefined Behaviour
13:59:15 <hiptobecubic> ocharles, I had the same idea. Are you making a bot ?
13:59:29 <ab9rf> mm_freak: have fun with that!
13:59:35 <ocharles> Cale: wish I knew
13:59:35 <ab9rf> mm_freak: i wouldn't use exceptions in that
13:59:41 <mm_freak> ab9rf: why not?
13:59:44 <ab9rf> especially nt C++ exceptions
13:59:51 <ocharles> hiptobecubic: yes, I'd like to make something that just buys and sells at "sensible" times
13:59:55 <ocharles> which seems like never, right now :p
14:00:09 <hiptobecubic> Cale, people are jumping on because people are jumping on. It's your standard 'bubble'
14:00:09 <mm_freak> ocharles: no problem:  'empty' =)
14:00:15 <ocharles> :D
14:00:19 <ski> johnw : e.g. "C Compilers Disprove Fermat’s Last Theorem" by John Regehr in 2010-04-28 at <http://blog.regehr.org/archives/140>
14:00:23 <ab9rf> hiptobecubic: bitcoin's market is almost entirely noise
14:00:30 <Cale> hiptobecubic: But there's something really strange going on in the last couple days
14:00:31 <mm_freak> ocharles: in netwire 3 there was even a wire called 'never', but it's equivalent to 'empty', so i removed it =)
14:00:38 <hiptobecubic> Cale, yes, it's exploding
14:00:42 <ocharles> mm_freak: oh, you are the author of netwire?
14:00:44 <dgriffi> Can anyone here answer a question about Text.Blaze.Html?
14:00:49 <mm_freak> ocharles: yeah
14:00:50 <ocharles> dgriffi: fire away
14:00:52 <hiptobecubic> But that's what bubbles do.
14:01:01 <ab9rf> mm_freak: there's an ACM paper around somewhere about why TiVo elected to remove exceptions from C++ in their product.
14:01:01 <ocharles> mm_freak: in that case, have one "you rock" token
14:01:02 <ocharles> :)
14:01:08 <dgriffi> ocharles: I'm wondering if there's anything in there that will generate a page break.
14:01:21 <ocharles> dgriffi: a "page break"? what's that as a html element?
14:01:29 <mm_freak> ocharles: thanks…  if you have any questions, just ask
14:01:41 <__books__> Cale: for most everyday programming, sure if that means webapps, games etc. i dont know about LLVM.  Im into embedded systems and C is pretty much the norm even if some C++ is used at the application level. Dont see much wrong with it. Type safety is missing ofc. Maybe im satisfied because im too unimaginative... :)
14:01:47 <dgriffi> ocharles: <div style=\"page-break-before:always;\"></div>
14:01:56 <ab9rf> mm_freak: you might find it informative :)
14:02:04 <ocharles> dgriffi: then H.div ! A.style "page-break-before: always"
14:02:05 <mm_freak> ab9rf: if you know a good alternative, i'm very open for suggestions
14:02:12 <hiptobecubic> Many large organizations have a flat no exceptions policy
14:02:15 <ocharles> dgriffi: which you're welcome to package up as your own function
14:02:16 <mm_freak> ab9rf: error return values are not an alternative
14:02:20 <dates> hello. I have a tuple like this : (3,5,"String1","String2","String3","String4","String5","String6","String7","String8","String9","String10",). Can you tell me how can I retrieve nth element?
14:02:28 <paintcan> mm_freak: global variables?
14:02:36 <ab9rf> mm_freak: tivo disagrees with you
14:02:37 <mm_freak> dates: pattern matching, a custom function or lenses
14:03:11 <ocharles> ab9rf: tbf, I don't exactly consider TiVo authority on programming practices :)
14:03:13 <Cale> dates: (\(_,_,_,_,x,_,_,_,_,_,_,_) -> x)
14:03:18 <ocharles> though I should still probably look at that paper
14:03:22 <mm_freak> ab9rf: a large portion of the programmer community also disagrees with functional programmers…  i'll stay unbiased and form my own conclusions
14:03:23 <Cale> dates: (but don't use large tuples like that)
14:03:28 <dgriffi> ocharles: so, there's nothing already available for this?
14:03:32 <mm_freak> ab9rf: but i'll read their paper…  at least skim through it
14:03:34 <ski> mm_freak : hm, doesn't Fortran have multiple returns ?
14:03:40 <ocharles> dgriffi: not built in to the library itself, no
14:03:48 <ab9rf> mm_freak, ocharles: http://queue.acm.org/detail.cfm?id=1127867
14:03:49 <mm_freak> ski: fortran is awfully low level
14:04:00 <hiptobecubic> mm_freak, no it isn't.
14:04:04 <ocharles> dgriffi: that's not really its goal - the goal of blaze-html is to provide a general interface to generating html
14:04:09 <ab9rf> fortran is not low-level
14:04:17 <Cale> dates: You'll rarely see anything much longer than a pair or the occasional triple in real Haskell code.
14:04:18 <hiptobecubic> This is what i'm talknig about. These languages are being used for things that they were not intended to solve
14:04:21 <ocharles> also, I want to rewrite blaze-html (or write my own blaze-html) that has a valid Monad instance
14:04:24 <ab9rf> and actually fortran has some really strong points for certain purposes
14:04:26 <dgriffi> ocharles: would it be a good idea to get that into the official codebase?
14:04:29 <Cale> dates: anything more, and you're better off using something more structured.
14:04:33 <ocharles> dgriffi: not for blaze-html, no
14:04:36 <mm_freak> ski: C++' class and template system actually comes in handy for kernel dev, but my ultimate goal is to use a functional language…  my current aim is to add a standalone target to idris, but that's going to take a while
14:04:47 <ocharles> dgriffi: but as I said - you can make your own library and release that on hackage, no problem
14:04:50 <hiptobecubic> so people are like "You can't even write a webserver in FORTRAN. It's terrible", which is stupid
14:04:52 <dates> I am afraid I have to deal with larger tuples, like at least 10 tuple
14:04:58 <ab9rf> fortran is especially easy to parallelize, and its semantics for numerical evaluation ensure stability of order of evaluation, so the programmer can control precision loss
14:05:06 <Cale> dates: Why is that?
14:05:23 <__books__> So let's talk realtime. How would an improvement on C or C++ look? Could you design a good functional alternative with out GC?
14:05:23 <dgriffi> ocharles: I'm trying to modify Pandoc to do pagebreaks in html.  adding yet another library doesn't seem like a good idea
14:05:45 <mm_freak> __books__: i don't aim to go without GC
14:06:03 <dates> Cale : because I have such an input
14:06:03 <Cale> hiptobecubic: I guess in log scale it doesn't look so unreasonable ;) http://bitcoincharts.com/charts/mtgoxUSD#tgOzbgDzm1g10zm2g25zvzl
14:06:18 <dgriffi> bitcoin is heading for a big crash
14:06:24 <hiptobecubic> Cale, haha. Jesus christ
14:06:49 <ocharles> dgriffi: add it to pandoc then
14:06:51 <mm_freak> does fortran have a template system like C++?
14:06:52 <dgriffi> ocharles: I'll just use preEscapedString for my substitution and hope the maintainer likes what I'm doing
14:07:01 <mm_freak> or even actual parametric polymorphism?
14:07:06 <ski> __books__ : "Retrospective Thoughts on BitC" by Jonathan S. Shapiro in 2012-03-23 at <http://www.coyotos.org/pipermail/bitc-dev/2012-March/003300.html> seems interesting, though i don't know that much about this system
14:07:15 <ab9rf> mm_freak: does fortran need those things?
14:07:16 <ocharles> dgriffi: I don't think pandoc would object to you adding 'pageBreak = H.div ! A.style "..." mempty'
14:07:23 <mm_freak> ab9rf: i need those things
14:07:32 <ab9rf> mm_freak: then don't use fortran :)
14:07:36 <mm_freak> ok =)
14:07:38 <hiptobecubic> FORTRAN is not for systems programming.
14:07:48 <ab9rf> although i questin whtehr yuo really _need_ those things
14:07:52 <ab9rf> you just _think_ you need them :)
14:07:59 <ski> __books__ : for "good functional alternative with out GC", <http://en.wikipedia.org/wiki/Region-based_memory_management> might perhaps be interesting
14:08:06 <ab9rf> hiptobecubic: i used to write text processing software in fortran :)
14:08:13 <sproingie> drbean: a "big crash" for those left who care about bitcoin.  there are probably more people trading pogs.
14:08:18 <dgriffi> ocharles: look here:  https://github.com/DavidGriffith/pandoc/commit/ef7f867e323ecf9a9bad25c27721338228f11f2d
14:08:20 <mm_freak> ab9rf: i'm a haskell programmer, so practically i need them =)
14:08:51 <dgriffi> ocharles: those are the changes that would enable pagebreaks.  The string "fart fart fart" is just a placeholder.  I haven't pushed anything more sensible yet
14:08:58 <mm_freak> ab9rf: i'm using (in C++!) a form of dependent types to prevent things like buffer overflows
14:08:59 <hiptobecubic> Everytime I use templates, I end up realizing that I only actually needed it to work with maybe two or three different types and hardcoding them in would have saved assloads of time in the debugging stage
14:09:11 <Cale> http://bitcoincharts.com/charts/mtgoxUSD#rg360ztgOzbgDzm1g10zm2g25zv -- non-log-scale, this year ;)
14:09:36 <ocharles> Cale: do you have any bitcoins, or do you just watch as an interested observer?
14:09:40 <hiptobecubic> Cale, i wasn't aware of the last few days. It's really out of control. It's going to crash *hard*
14:09:42 <Cale> I'm just watching
14:09:44 <mm_freak> ab9rf: template <int size> class ByteString { protected: const Word8 str[size]; … }
14:09:49 <mm_freak> that's why i want them
14:09:52 <dgriffi> ocharles: could you take a look at what I did and tell me if I'm going about it the right way?
14:10:00 * dgriffi owns around .02 bitcoins
14:10:13 <ab9rf> Cale: holy crap
14:10:20 <hiptobecubic> I have a friend with some, although he just uses them to make illicit purchases :(
14:10:26 <__books__> ski: ty
14:11:42 <ocharles> dgriffi: I had 1BTC and sold it for $12 :(
14:11:50 <ocharles> dgriffi: and I don't know how pandoc is structured, but your approach looks ok
14:11:50 <k00mi> I know a couple people with bitcoins and they all insist it's not going to crash
14:11:51 <ab9rf> Cale: still way short of what bitcoin needs to be trading to be a legitimate currency, mind you
14:11:56 <ocharles> that's about as much advice as I can give you
14:12:12 <dgriffi> ocharles: I had 20 ounces of silver and sold it for $16/oz
14:12:16 <mm_freak> ab9rf: their reasoning is:  "We did not use exception handling, which generates a great deal more code—code that should be rarely executed in a well-designed application. Exceptions can be thrown for many reasons, and the proper path for recovery from them is not always obvious at different abstraction levels. This makes designing a predictable application difficult."
14:12:24 <ocharles> dgriffi: I'm assuming silver has gone up?
14:12:26 <ab9rf> mm_freak: yes, i read that
14:12:35 <mm_freak> i can't agree with that, because exceptions are thrown at spots where run-time errors are actually possible
14:12:40 <dgriffi> ocharles: it most certainly has.  it's hovering around $33 or so
14:12:44 <mm_freak> for everything else i have k_assert(…)
14:13:05 <mm_freak> and that's #define-d to disappear when -DDEBUG is not there
14:13:10 <ab9rf> mm_freak: well, you're free to disagree :)
14:13:20 <ab9rf> C++ exceptions are a botch, regardless
14:13:42 <mm_freak> i don't see much difference between C++ exceptions and haskell exceptions, tbh, except that haskell has GC
14:13:58 <ab9rf> mm_freak: you don't say
14:14:06 <sproingie> ab9rf: my "favorite" part about C++ exceptions is how throwing in a handle causes an immediate abort
14:14:11 <sproingie> *handler
14:14:44 <hiptobecubic> haskell exceptions feel pretty inappropriate too most of the time
14:14:59 <ski> it's interesting how in some Lisps you can restart (some) exceptions (called "conditions")
14:15:00 <sproingie> yes but haskell actually has other mechanisms for communicating exceptional status
14:15:07 <Cale> The extensibility of exceptions in the new Haskell exception library is really nice though.
14:15:13 <mm_freak> hiptobecubic: really?  see Maybe used all over the base library ;)
14:15:22 <ocharles> Cale: new as in forthcoming, or current?
14:15:26 <Cale> Current.
14:15:29 <hiptobecubic> Cale, elaborate?
14:15:40 <mm_freak> hiptobecubic: see SomeException and the Exception class
14:15:50 <mm_freak> they use some magic to allow to match against specific exception types
14:15:52 <thoughtpolice> well, "new" in the sense it was put into base like, 3-4 years ago
14:15:55 <mm_freak> much like in other languages
14:16:15 <mm_freak> the old exception system was awkward to use
14:16:32 <hiptobecubic> mm_freak, is this an argument for or against them? I'm saying that I *don't* like exceptions in Haskell and they feel totally out of place.
14:16:36 <Cale> You can construct a new instance of Exception which is an arbitrary superset of existing exception types.
14:16:39 <mm_freak> hiptobecubic: for them
14:17:00 <mm_freak> i just wanted to explain the "new" exception system =)
14:18:26 <mm_freak> hiptobecubic: but let's consider a practical example:  you have a fileServer :: Handle -> FilePath -> IO ()
14:18:28 <Cale> You can create nice hierarchies of exceptions and then insert new things into them in future modules, by implementing toException and fromException appropriately.
14:18:31 <mm_freak> how would you write it?
14:18:36 <ski> .. i don't really like how you can throw a `FooException' and catch it as a `SomeException' (and vice versa)
14:18:53 <dgriffi> ocharles: does this line make sense?
14:18:56 <dgriffi> ocharles: blockToHtml opts (NewPage) = return $ H.div ! A.style "page-break-before:always;"
14:19:08 <mm_freak> ski: it's one ugly necessity of the exception system, but i can live with it
14:19:12 <hiptobecubic> I guess usually what I don't like is how they feel 'out of band'. If that is mitigated by using the new features correctly then perhaps it isn't so terrible. My Haskell is far from Exceptional.
14:19:16 <ski> imo, if you want to catch a `FooException' as a `SomeException' you should use some kind of `handleAny' (or equivalent) operation
14:19:16 <mm_freak> ski: i know, special cases suck
14:19:17 <hiptobecubic> HEYOOOOO
14:19:21 <ocharles> dgriffi: I guess
14:19:28 <ski> and a `throwAny' for the other direction
14:19:34 <beaky> hello
14:19:36 <ocharles> dgriffi: ask the compiler if it makes sense, I can't help you with pandoc stuff
14:19:44 <dgriffi> ocharles: I'm getting "Couldn't match expected type `Html' with actual type `Html -> Html'"
14:19:50 <ski> (or just open the `SomeException' and use `throw' on the `e' with `Exception e')
14:19:56 <ocharles> dgriffi: H.div expects some contents
14:20:03 <ski> mm_freak : afaics, it's not a necessity
14:20:06 <ocharles> so use `mempty` if you want "empty" contents
14:20:17 <ocharles> dgriffi: and `import Data.Monoid (mempty)`
14:20:21 <Cale> ski: Well, you shouldn't often be catching SomeException, though it's obviously the laziest way to go about things (not in the sense of lazy evaluation)
14:20:24 <mm_freak> ski: well, how would you design Exception?
14:20:48 <mm_freak> hiptobecubic: could you give me an example of how you would write the fileServer function?  it should only send the contents of the given file to the given handle…  lazy I/O is fine
14:21:06 <dgriffi> ocharles: mempty is already imported
14:21:21 <mm_freak> hiptobecubic: assume that there is no predefined withFile function
14:21:30 <ski> mm_freak : a `handle (\(e :: FooException) -> ..e..) (...)' would only handle `FooException's thrown from `...', not `throw'n `SomeException's which happen (in one or more layers) to contain a `FooException'
14:21:34 <ocharles> dgriffi: ok
14:21:43 <hiptobecubic> mm_freak, I suppose that's not a great type to use *unless* you are planning on exploding out the middle of the function when you have an error.
14:21:59 <Cale> One thing which I'm a little surprised about is the silly way that IOException is poorly reflected in the Control.Exception library, when there's no need for that. At one point I wrote a module to reflect the insides of IOExceptions as new exception types.
14:22:00 <mm_freak> hiptobecubic: why?  the type is fine
14:22:15 <mm_freak> hiptobecubic: if you have a better alternative, propose it
14:22:31 <ski> mm_freak : and a `handle (\(e :: SomeException) -> ..e..) (...)' would only handle `SomeException's thrown from `...', not `throw'n `FooException's, for `FooException' distinct from `SomeException'
14:22:55 <hpaste> Cale pasted “IOError as Control.Exception types” at http://hpaste.org/84433
14:23:02 <hiptobecubic> Well suppose the file path isn't valid for example, you'd like the return value to include something about failure
14:23:16 <Cale> ^^ the fact that you can do stuff like that in a future module is really nice imo
14:23:24 <beaky> are exceptions good to use in my code?
14:23:37 <Cale> beaky: I think they're all right for IO code
14:23:40 <ski> mm_freak : this would mean that we need a `handleAny' to catch a `FooException' (for unknown at catch site `Foo') as a `SomeException' -- and perhaps a `throwAny' for convenience
14:23:51 <johnw> beaky: exceptions solve certain problems, but I prefer writing total functions if I can
14:24:02 <Cale> For pure code, that's another thing
14:24:04 <mm_freak> hiptobecubic: that's a minor matter…  let's disregard security and assume that failure is handled by not sending anything
14:24:20 <mm_freak> hiptobecubic: for the sake of making my point
14:24:33 <beaky> ah
14:24:35 <ski> and also `catchAny',`tryAny'
14:24:54 <ski> not sure how useful `catchAnyJust' would be
14:24:57 <beaky> sometimes I put a case in my pure code that does 'error "DomainError"'
14:25:03 <hiptobecubic> Well what's the issue then? You either silently do something or you don't. Why is anyone raising an exception?
14:25:08 <johnw> beaky: that is certainly to be avoided :)
14:25:22 <johnw> partial functions are like coding bombs
14:25:25 <beaky> how do I constrain it so that the type system can catch those kind of error?
14:25:29 <mm_freak> hiptobecubic: give me an implementation and i point out why you either did it wrong or you used exceptions =)
14:25:35 <johnw> you can't
14:25:38 <johnw> error always has the right type
14:25:39 <beaky> ah :(
14:25:52 <Cale> I might've been able to do an even better job of that module, in fact, by applying various functions in System.IO.Error to extract the relevant bits of information about each exception type.
14:25:56 <ski> mm_freak : any comment ?
14:26:01 <johnw> i use a linter I call hlint++ to point out if I'm creating partial functions
14:26:05 <mm_freak> ski: i agree
14:26:06 <Cale> (and realise those as fields of the datastructure)
14:26:46 <ski> mm_freak : doing this would remove the special magic status that `SomeException' has with `throw',`handle',`catch'
14:27:09 <mm_freak> ski: yeah, that's true
14:27:23 <ski> mm_freak : the cost is some duplication of API, though arguably the intent in the two families is somewhat different
14:27:45 <mm_freak> catchAll :: IO a -> (forall e. (Exception e) -> e -> IO a) -> IO a
14:27:58 <ski> *nod*, if you prefer that name
14:28:16 <mm_freak> yeah, any/all…  something like that
14:28:30 <beaky> what is the difference between having state and passing data through a recursive function?
14:28:40 <mm_freak> beaky: nothing
14:28:41 <johnw> beaky: I'm not sure I follow your question
14:28:42 <ski> beaky : is there a difference ?
14:28:45 <beaky> ah
14:28:51 <sproingie> the second is one means of implementing the first
14:28:55 <Enigmagic> johnw: turn it into a GHC plugin
14:28:57 <ski> conceptually, it's basically the same
14:29:05 <mm_freak> the second is the only way to implement the first in haskell =)
14:29:07 <beaky> I wanna code up an FSM and I thought the recursive way is one way to do it
14:29:17 <johnw> ah, i see, yeah, there is no difference
14:29:22 <sproingie> mm_freak: naw, iorefs are pretty darn variableish
14:29:22 <johnw> guess how the State monad works :)
14:29:36 <ski> beaky : though with state, we usually also allow state to flow outwards from a function, into the "next" call -- if you don't need that, then an accumulator is quite enough
14:29:37 <mm_freak> sproingie: IORefs don't act like mutable variables unless you use recursion
14:29:51 <sproingie> i suppose you still do have to pass the ref around
14:30:14 <ski> @type random
14:30:15 <mm_freak> sproingie: if you don't recurse, then IORefs are just shadowing
14:30:16 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
14:30:20 <ski> beaky : e.g. that ^
14:30:21 <ab9rf> ski: you can flow state outwards as well by returning it from the function....
14:30:33 <ski> ab9rf : which is what i meant, yes
14:30:45 <beaky> so returning a pair containing the result and the next state is another way to do it?
14:30:51 <ab9rf> beaky: yes
14:30:54 <dgriffi> what's wrong with this line? return $ H.div ! A.style "page-break-before:always;" mempty
14:30:56 <beaky> wow cool
14:30:57 <sproingie> that's what State does
14:30:59 <mm_freak> beaky: that's just State in disguise =)
14:31:11 <ab9rf> that's what State is doing, it's just easier to read (and code) using State
14:31:16 <beaky> hmm maybe I can write finite state machines elegantly
14:31:17 <mm_freak> dgriffi: remove the "mempty"
14:31:25 <ski> beaky : you need both passing the "before" state in, and returning the "after" state as result (or part of the result, if you want also a separate result) to get the full picture of "state"
14:31:32 <mm_freak> dgriffi: or do this:  A.style "page-break-before: always;" <> mempty
14:31:40 <ski> beaky : in some specific cases, you only need one of these two ingredients, though
14:31:46 <mm_freak> but by the monoid laws that's equivalent to leaving out the mempty
14:31:46 <beaky> ah
14:32:24 <dgriffi> mm_freak: still doesn't work: Couldn't match expected type `Html' with actual type `Html -> Html'
14:33:03 <mm_freak> dgriffi: you need inner HTML for 'div'
14:33:09 <ski> beaky : see how `random' both takes the "before" (pseudo-) random generator state `g' as input, and returns the "after" pRNG state `g' as output
14:33:21 <mm_freak> dgriffi: H.div someHtml ! A.style "style"
14:33:26 <ski> (also returning the randomly generated value of type `a')
14:33:33 <mm_freak> dgriffi: in other words H.div is a function Html -> Html
14:33:33 <hpaste> dgriffi pasted “blaze error” at http://hpaste.org/84434
14:34:01 <ocharles> mm_freak: the inner html is at the end
14:34:03 <kludgy> Hi all, can anyone help me discover why this simple web server code does only sends a response on a subsequent request? I feel like there's a lazy evaluation bug somewhere here in a do block, but I'm having problems identifying it: http://pastebin.com/a4PPpx5V
14:34:09 <mm_freak> ocharles: no
14:34:12 <mauke> The paste a4PPpx5V has been copied to http://hpaste.org/84435
14:34:13 <ocharles> it's H.div ! A.style ".." $ mempty
14:34:20 <ocharles> mm_freak: yes, because that's why do notation works :)
14:34:32 <mm_freak> dgriffi: example:  H.div (return ()) ! A.style "blah"
14:34:42 <mm_freak> ocharles: that's a type error
14:34:49 <mm_freak> ocharles: (!) :: Html -> Attribute -> Html
14:35:15 <mm_freak> and you have this:  H.div :: Html -> Html
14:35:24 <beaky> is there a special name for functions that have a type like (a -> IO b) ?
14:35:26 <Cale> Okay, who created the syntax colouring for Haskell which is being used by pastebin? I want to tell them that it's bad and they should feel bad.
14:35:47 <mm_freak> beaky: we call them monadic functions or IO functions, but no, it's just a function that results in an IO action
14:35:49 <ocharles> mm_freak: i'm sorry, you are mistaken
14:35:50 <ski> Cale : yeah. my complaint is really with the special magic status of `SomeException'
14:35:53 <ocharles> it's type checking in ghci just fine
14:35:57 <beaky> ah
14:36:03 <ab9rf> Cale: ugh, that is unpleasant
14:36:04 <ocharles> H.div ! A.style "foo" $ mempty :: H.html
14:36:35 <alpounet> mm_freak, I always put the inner html at the end -- has always worked
14:36:54 <ski> beaky : if you squint a little, it's a map from `a' to `b' in the kleisli category for `IO'
14:37:20 <johnw> Cale: you mean like the palette of two colors that you almost can't tell apart?
14:37:27 <hiptobecubic> mm_freak, anyway. what's wrong with the most obvious one? "fileServer h f = readFile f >>= hPutStr h"
14:37:47 <ski> beaky : meaning : you can think of it as an `IO'-effectful function from `a' to `b' -- or even secretly as an `IO'-side-effectful function from `a' to `b', in some hypothetical language with `IO'-side-effects
14:37:56 <mm_freak> indeed, (!) is polymorphic
14:38:09 <Cale> kludgy: If you apply hGetContents to a handle, you are *not* allowed to hClose that handle.
14:38:10 <ski> beaky : if what i said made no sense, you can safely ignore it
14:38:35 <mm_freak> my version works, too
14:38:42 <Cale> kludgy: You're essentially giving up the right to hClose the handle to the implementation of hGetContents
14:38:43 <mm_freak> > renderHtml $ H.div "x" ! A.style "x"
14:38:45 <lambdabot>   Not in scope: `renderHtml'
14:38:45 <lambdabot>  Perhaps you meant `renderStyle' (imported from ...
14:38:46 <mm_freak> "<div style=\"x\">x</div>"
14:38:58 <hpaste> beaky pasted “Why does A get printed twice when I do not enter a?” at http://hpaste.org/84436
14:39:01 <kludgy> Cale: Thanks for the heads up on this! I'm going to check out further documentation now
14:39:09 <Cale> kludgy: But this is magic and lazy, so you don't know when the handle will be closed, which sucks for a network application.
14:39:11 <ocharles> mm_freak: oh, interesting
14:39:20 <ocharles> didn't know that
14:39:24 <mm_freak> hehe
14:39:55 <Cale> kludgy: You might prefer to use something like Strict Data.Text or Data.ByteString whose hGetContents will slurp the entire contents immediately
14:39:55 <glguy> ski: There is no special allowance made for SomeException
14:40:11 * glguy has been half-following the conversation and might have missed an important bit
14:40:16 <ski> kludgy : passing a `Handle' to `hGetContents' renders it "semi-closed", meaning "it's closed, but lazily", meaning it will be closed later, by `hGetContents' (or GC); in particular, you should not close it yourself, since you have relinguished that responsibility to `hGetContents'
14:40:23 <kludgy> Cale: Excellent, thanks for the lead on this.
14:40:32 <Cale> glguy: Well, it is somewhat blessed in that the definition of the Exception class uses it.
14:40:35 <mm_freak> ocharles: polymorphism fooled both of us =P
14:40:41 <mm_freak> dgriffi: could you paste the full code?
14:40:46 <ocharles> mm_freak: indeed
14:41:00 <ocharles> mm_freak: that's some pretty bizzare polymorphism, too
14:41:10 <mm_freak> ocharles: it's actually reasonable
14:41:15 <ocharles> somewhat
14:41:19 <ski> glguy : how come `handle (\e -> print (e :: SomeException)) (throw (ErrorCall "apa"))' and `handle (\e -> print (e :: ErrorCall)) (throw (SomeException (ErrorCall "apa")))' catch the exceptions, then ?
14:42:21 <Ralith> @hoogle [a] -> [(b,c)] -> [(a,b,c)]
14:42:21 <lambdabot> Data.Graph.Inductive.Graph inn :: Graph gr => gr a b -> Node -> [LEdge b]
14:42:21 <lambdabot> Data.Graph.Inductive.Graph out :: Graph gr => gr a b -> Node -> [LEdge b]
14:42:28 <mm_freak> ocharles: it's about the same kind of polymorphism that allows you to use strings as functions
14:42:39 <glguy> Because of how SomeException's instance was written
14:43:02 <glguy> You could do the same thing and make SkisException, no?
14:43:02 <kludgy> Cale: Looking here: http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hGetContents "Any operation that fails because a handle is closed, also fails if a handle is semi-closed. The only exception is hClose. A semi-closed handle becomes closed:
14:43:03 <kludgy> 	•	if hClose is applied to it;"
14:43:29 <ski> glguy : yes, which is what i object to, i suppose
14:43:41 <glguy> I'm saying its not magic because you can implement it yourself
14:43:48 <ski> imo, `toException e' should never be just `e'
14:43:51 <glguy> not trying to say antying more than that :)
14:44:30 <ski> or, i suppose i want `toException' to always be `SomeException'
14:45:20 <Cale> kludgy: Right, well, when that happens, weird stuff happens to the String that was the result of hGetContents
14:45:33 <ski> kludgy : yes, but i don't think it's very useful to do that (i don't know of a sensible use case)
14:45:33 <Cale> i.e. usually it's truncated
14:45:58 <Cale> In fact, though it's not a hard error, I think it really ought to be a runtime error to do that.
14:46:08 <Cale> (I can't think of a good use case either)
14:46:46 <kludgy> Cale: Aha ok
14:49:00 <Cale> I really wish that there were a strict version of hGetContents in System.IO. It's easy enough to write one via Data.ByteString or Data.Text, but that's often a little daunting for people starting out.
14:49:18 <hiptobecubic> isn't there System.IO.Strict?
14:49:40 <hiptobecubic> i thought i saw someone mention that on -beginners
14:49:53 <Cale> hiptobecubic: er, if there is, it's not in base
14:50:01 <hiptobecubic> Cale, perhaps not.
14:50:11 <typoclass> hiptobecubic: heh, not a bad idea
14:51:19 <typoclass> apparently there's two packages: http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/System-IO-Strict.html -- http://hackage.haskell.org/packages/archive/strict-io/0.2.0/doc/html/System-IO-Strict.html
14:52:20 <kludgy> Cale: I find myself wishing that haskell was just strict by default :) This is tempting: http://www.haskell.org/haskellwiki/DDC
14:52:34 <ski> (also, `fromException' should never be just `Just')
14:53:54 <Cale> kludgy: I would disagree, though lazy IO is much more questionable than lazy everything else.
14:54:04 <pharaun> lazy io is questionable imho
14:54:11 <pharaun> lazy everything else is great imho
14:54:16 <Cale> Yes
14:54:24 <Cale> Lazy IO *can* be nice too
14:54:28 <pharaun> yes it can be
14:54:34 <pharaun> but it can bite you in the arse really badly
14:54:45 <pharaun> i think i've spent more time fixing io than forcing eval with lazy eval
14:54:53 <pharaun> *waymore*
14:54:55 <typoclass> kludgy: i think laziness is quite alright :-) it's just that a handful of functions in System.IO are not that easy to use, in particular hGetContents
14:55:04 <Cale> Mainly for small programs, it's really good, but once you get to a certain level of seriousness, just switching to strict IO saves a lot of headaches.
14:55:10 <pharaun> yup
14:55:20 <pharaun> Cale: now days i just default to strict io unless i have a need for lazy io
14:55:28 <pharaun> Cale: strict buffered/chunked io that is i mean
14:55:40 <kludgy> Good to know. I have to defer to those wiser than I, as I'm so inexperienced with haskell
14:56:11 <pharaun> again kludgy it can depend on your needs
14:56:14 <pharaun> its a ymmv
14:56:42 <Cale> Also, careful use of lazy IO, such as with lazy ByteString or lazy Text can allow for really convenient processing of single very large files.
14:57:11 <dEPY> how can I decide on which lang to learn? I want to learn so many of them :S
14:57:32 <Cale> dEPY: Just pick one, learn that, and then pick another.
14:57:32 <dEPY> or would a simple test run of most of them be enough to choose?:)
14:57:43 <hiptobecubic> dEPY, find an intersting problem. Reimplement in all the languages you want to learn.
14:58:03 <dEPY> ye but learning something like haskell or clojure is not a matter of few months probably :)
14:58:14 <dEPY> hiptobecubic: I was thinking exactly that :)
14:58:23 <pharaun> dEPY: but those are probably teaching you some higher level concept
14:58:36 <pharaun> that a vanilla reimplement of half of ruby/python won't
14:59:14 <pharaun> dEPY: i find you can generally classify languages in rough groups, sure each languages in a group may have difference and so on but nothing like the difference between C and say haskell or lisp for ex
14:59:15 <Cale> I will happily mention that the people who I've started out on Haskell have had less difficulty learning other languages and writing nice code in them.
14:59:44 <pharaun> Cale: i wished i learned haskell first!
14:59:49 <ab9rf> Cale: i've been arguing for Haskell as a first language whenever i get the chance
14:59:50 <dEPY> pharaun, yes you're probably right, teaching FP concepts will take time but they don't differ from language to language that much
14:59:53 <pharaun> i'm finding myself having to undo my bad habits
15:00:07 <dEPY> pharaun really?:D
15:00:08 <pharaun> dEPY: its the high level concept that matters, all the rest tends to be implementation details
15:00:23 <pharaun> dEPY: so go for haskell or whatever, then latter on a oop language, logical language, etc..
15:01:10 <pharaun> after i feel happy with my level of expertness with haskell i'll probably go pick up something like prolog or something
15:01:19 <dEPY> I know java, javascript and ruby kinda, I want something FP now
15:01:48 <dEPY> And I still have Prolog nightmares from college :D
15:02:00 <dEPY> But I'm a totally different person now... So maybe ye.. :)
15:02:16 <kludgy> javascript makes me sad :(  I'm glad there are attempts to improve it for production development
15:02:30 <dEPY> I have mixed feelings about javascript...
15:02:43 <dEPY> I reaaaly reaaaly love that it has first class functions
15:02:53 <ski> Prolog is great fun ! :)
15:02:56 <hiptobecubic> if it didn't it would be seriously worthless
15:03:08 <kludgy> Elm was kind of cool but limited in scope, and fay looks promising, but things like coffeescript I feel bring too little to the table for the overhead they impose.
15:03:25 <dEPY> I have mixed feelings about coffee script also
15:03:32 <dEPY> I'd rather see javascript fixed
15:04:57 * hackagebot network-bitcoin 1.1.0 - An interface to bitcoind.  http://hackage.haskell.org/package/network-bitcoin-1.1.0 (ClarkGaebel)
15:05:04 <arbn> kludgy: Do you find that CoffeeScript imposes a lot of overhead? Just a translation step, and debugging coffeescript from javascript is fairly straightforward, in my experience.
15:05:17 <johnw> dEPY: a lot of languages are a bit like glorified assembly languages: they're various ways of abstracting an operational model of computation.  Haskell is a glorified lambda calculus, which means it abstracts a denotational semantics.  You end up programming in terms of what things mean, rather than what needs to happen to accomplishes those statements of meaning (like, how 1+1 becomes 2).  The compiler's job is to translate between
15:05:17 <johnw> those models, whereas in operational languages, it partly the compiler's job, and partly the programmer's job.
15:06:13 <kludgy> arbn: it imposes enough debugging hassle day-to-day in combination with the poor formalism of node.js that I'd still rather work straight in js.
15:06:16 <johnw> this difference is HUGE in many ways that can seem subtle at first
15:06:41 <dEPY> johnw I'm kinda looking for something like that yes.. I want to shift my problem solving ability a bit :)
15:06:46 <arbn> johnw: Yes. In a lot of languages, the model of computation is that of the machine. In Haskell, the model of computation is that of the lambda calculus.
15:06:55 <johnw> dEPY: i would say start with Haskell
15:07:04 <pharaun> that's why i suggest people to learn *actual* different model fo computation
15:07:12 <pharaun> not just say oh python then ruby then perl
15:07:17 <pharaun> they're kinda same-ish :)
15:07:21 <dEPY> I said so many times i'll do it and I just can't get into it :)
15:07:23 <kludgy> With Haskell I find myself doing actualy production much less, but doing thinking a lot more :)
15:07:49 <dEPY> What's the good approach to get into it without loosing interest?:)
15:07:57 <johnw> @lyah
15:07:57 <lambdabot> Unknown command, try @list
15:08:01 <johnw> @where lyah
15:08:01 <lambdabot> http://www.learnyouahaskell.com/
15:08:03 <dEPY> learn you a haskell is kinda cool I think
15:08:03 <johnw> read that book
15:08:09 <dEPY> :)
15:08:11 <johnw> and play along in ghci as you read it
15:08:19 <johnw> it's a good start, and it's amusing
15:08:27 <johnw> pharaun: I agree
15:08:43 <kludgy> Lipovaca actually came to give a talk at the last polyglot unconference here in vancouver. He's the reason I started on haskell!
15:08:59 <dEPY> pharaun ye, I came from java to javascript now to ruby, it kinda feels the same
15:09:15 <pharaun> that's because they are kinda mostly in the same subset of computation model
15:09:22 <pharaun> there are difference here and there sure
15:09:30 <ab9rf> dEPY: all imperative languages are essentially the same
15:09:41 <dEPY> ye, that's why I want functional language next
15:09:50 <dEPY> and I hate ruby's blocks :)
15:09:56 <hiptobecubic> ha really?
15:09:57 <ab9rf> heh
15:10:01 <hiptobecubic> That's the best part of the language
15:10:05 <ab9rf> i kinda like ruby
15:10:12 <ab9rf> i hated it at first but i've grown to like it
15:10:17 <dEPY> as cool as they are, it feels like a dirty patch for first class functions :D
15:10:31 <otters> it's not dirty D:
15:10:34 <dEPY> I do like ruby but there's some things I dislike :D
15:10:40 <otters> it's just magic like everything else in ruby
15:10:47 <ab9rf> ruby does have some excessive complexity around blocks
15:10:56 <otters> but i'll take blocks over type constructors with 8 type variables ;d
15:10:56 <dEPY> don't even get me started with rails magic :D
15:10:58 <ab9rf> there's four distinct types in the language for what amount to the same thing
15:11:10 <ab9rf> because of the evolution of those types over the life of the language
15:11:23 <pharaun> logical, functional, oop/procedural, what else?
15:11:24 <dEPY> otters true :)
15:11:38 <arbn> ab9rf: All imperative languages are not the same...
15:11:38 <johnw> pharaun: logical
15:11:43 <johnw> pharaun: oh :)
15:11:46 <ab9rf> pharaun: i'm not sure where prolog falls in that typology
15:11:47 <johnw> pharaun: data-flow
15:11:54 <ab9rf> pharaun: or, for that matter, SQL
15:11:59 <pharaun> johnw: hm? can't claim to be familiar with data-flow
15:12:05 <ab9rf> pharaun: XSLT
15:12:07 <pharaun> ab9rf: relational alegbra/sets theory
15:12:08 <ion> pharaun: esoteric
15:12:32 <johnw> pharaun: http://en.wikipedia.org/wiki/Dataflow_programming
15:12:36 <dEPY> pharaun: prototypal (don't know how to spell it), or is that not it?
15:12:44 <pharaun> isn't esoteric kinda a catch-all bucket
15:13:02 <johnw> that page claims it to be a "programming paradigm", though I haven't used it
15:13:05 <ab9rf> pharaun: a non-clade grouping, to borrow from linnaeologists
15:13:13 <ion> pharaun: As opposed to the other ones listed so far? :-P
15:13:20 <ab9rf> johnw: i'm not sure what a 'programming paradigm' is
15:13:25 <arbn> "Programming paradigm" is a stupid, useless concept. This taxonomy makes almost no sense.
15:13:28 <johnw> he was giving a list of them
15:13:35 <johnw> imperative, oo, logical,...
15:13:58 <ab9rf> hm, VHDL is a good point
15:14:01 <tdammers> arbn: the concept is alright, it's just wrong to categorize programming languages by it
15:14:03 <RichyB> arbn: is it really? Programming in Prolog is such a violently different experience to programming in Haskell for instance.
15:14:06 <pharaun> i was trying to give a rough grouping of concept
15:14:15 <RichyB> or VHDL or Verilog.
15:14:16 <ab9rf> i never got the hang of prolog
15:14:25 <arbn> RichyB: I'm not saying that there isn't a good taxonomy. I'm saying that this is a bad one.
15:14:27 <RichyB> tdammers: I like that way of characterising it, yes.
15:14:28 <pharaun> it might not exactly be correct but certain language/concept *are* different
15:14:34 <pharaun> there are cross-over/blending of course
15:14:34 <kludgy> ab9rf: Ruby, a language with implicit coercion from anything to anything. What could go wrong? ;)
15:14:35 <ab9rf> and verilog and vhdl are quite alien
15:14:42 <arbn> tdammers: The purpose of the concept is to categorize programming languages...
15:14:43 <ab9rf> kludgy: quack
15:14:57 * hackagebot template-default 0.1.1 - declaring Default instances just got even easier  http://hackage.haskell.org/package/template-default-0.1.1 (GregoryCollins)
15:15:04 <pharaun> i just want to give a quick in a nutshell broad groups, and if you care you can learn the implementation and more in depth detail
15:15:28 <pharaun> johnw: interesting, i don't know about that
15:15:55 <pharaun> johnw: i've heard claims/discussion about "dataflow" programming in C and c++ (iD software)
15:16:08 <MOMI> Hi.I want to learn programming but haskell is kinda hard for me, is there any book I can read "How to think like a programmer" i would greatlly appreciate it.Thanks
15:16:13 <ab9rf> pharaun: 'programming paradigms' are indeendent of language
15:16:29 <RichyB> arbn: I think that it's reasonable to say that there exist wildly different sets-of-semantics, that some programming languages support only a few, and that every programming language supports at least one by default.
15:16:32 <ab9rf> you can write object-oriented assmebly or structured ROM basic
15:16:34 <dEPY> MOMI did you try any other languages ?
15:16:51 <MOMI> No its my first
15:17:01 <pharaun> ab9rf: ab9rf well yeah, that would be more precise way of def it, i learned majority of my experience via learning languages so its a bit tangled up for me unfortunately
15:17:03 <arbn> MOMI: "The Structure and Interpretation of Computer Programs"
15:17:08 <MOMI> I have read allot about it but never trully programmed
15:17:10 <RichyB> You can't really write OO VHDL or Verilog, unless you write a CPU and then write an OO program on that, though.
15:17:15 <arbn> MOMI: Or "How to Design Programs"
15:17:16 <pharaun> ab9rf: which is one thing i'm trying to break away from with haskell via external non-language related study/learning
15:17:17 <ab9rf> a paradigm is how you approach the task; some paradigms may be easier to express in some languages than others but if the languages are TE then they can all express the same concept
15:17:29 <arbn> MOMI: They both use Scheme, which I think is a better place to start than Haskell, personally.
15:17:34 <pharaun> ab9rf: but yeah you're right
15:17:44 <arbn> MOMI: Both books are free online.
15:17:53 <ab9rf> RichyB: i don't know enough about verilog to comment
15:17:57 <arbn> MOMI: They show you how to think like a programmer.
15:18:20 <MOMI> Ok i will try.Thank you.:)
15:18:45 <RichyB> ab9rf: HDLs like Verilog and VHDL (I'll lump them together, the differences don't matter to this conversation) are languages for specifying nets of transistors and wires.
15:18:49 <dEPY> MOMI I agree, SICP book is amazing. But can be challenging. :)
15:19:00 <ab9rf> RichyB: i know that much.  but that's about all i know :)
15:19:10 <arbn> MOMI: "How to Design Programs" is easier, so if SICP is too tough, try that one.
15:19:18 <RichyB> *together with okay-ish mechanisms for composing them.
15:19:30 <johnw> MOMI: another free resource that's extremely good: http://www.cis.upenn.edu/~bcpierce/sf/
15:19:36 <ab9rf> RichyB: the largest gap in my knowledge of the technology stack of computing is in that area
15:20:10 <ab9rf> RichyB: i actually know more about the quantum physics of semiconductors than i do about the technologies involved in designing modern microprocessors :)
15:20:27 <hiptobecubic> mm_freak, I'm still not clear on why ReactiveBanana will not be suitable for realtime systems like games?
15:20:43 <MOMI> I will thank you all for help, I hope I can become a haskeller one day. ^__^
15:20:46 <arbn> johnw: What the hell? He wants to learn programming for the first time ever, and you recommend him *that*?!? Seriously?
15:21:05 <johnw> arbn: i assume if it's not his cup of tea, he'll ignore it pretty quickly
15:21:10 <ab9rf> heh
15:21:14 <johnw> but it does start with the fundamentals
15:21:16 <arbn> johnw: OK. Just a bit unconventional.
15:21:25 <johnw> yeah, I grant you it was a stretch
15:21:29 <johnw> but you never know!
15:21:37 <ab9rf> arbn: he's looking at haskell first, so he's already proven he's unconventional :)
15:22:11 <johnw> however, if you do start there, Haskell will seem like a shorthand for concepts you now know extremely well
15:22:22 <beaky> why does folds correspond to pattern matching?
15:22:36 <arbn> ab9rf: Fair enough. I just usually resort to Scheme for the people who find the jump to Haskell too daunting. But, I started with Scheme, so I'm biased. :P
15:22:53 <johnw> beaky: why do you ask that?
15:23:18 <ab9rf> arbn: scheme is one of my usual "first language" recommendations as well
15:23:21 <RichyB> ab9rf: hah. Okay, short version: you can define named registers, you update each register's state once per clock cycle, every register's new state is a bit-wise function of some subset of all of the other registers in the system. There are no conditional branches of any kind. Every register updates itself from its inputs every clock cycle.
15:23:26 <beaky> http://stackoverflow.com/questions/2527153/are-design-patterns-specific-to-language-or-technology
15:23:35 <beaky> it says that visitor pattern is like folds
15:23:36 <dEPY> scheme is awesome to get you started
15:23:44 <johnw> oh, THAT kind of pattern
15:23:47 <dEPY> and the most awesome thing is almost no syntax
15:23:58 <hiptobecubic> honestly i found that difficult
15:24:02 <johnw> that is a completely different use of the word than Haskell's "pattern matching"
15:24:06 <ab9rf> beaky: hm there's merit to that
15:24:06 <dEPY> which imo kinda speeds things up
15:24:17 <beaky> how does haskell pattern matching work?
15:24:18 <ab9rf> johnw: yeah, 'design pattern'
15:24:20 <hiptobecubic> I was constantly looking at things like '('() 3 5 '9 )''00r32900()()()like "wtf is this"
15:24:23 <johnw> the visitor pattern is just a traversal
15:24:26 <beaky> ah
15:24:41 <RichyB> ab9rf: so you can't have if statements or branches or anything. If you want to compute, say, x = if y then z else q, then what you have to do is compute both z and q in parallel and use a multiplexer to select which of z or q you want.
15:24:53 <ab9rf> folds are traversals over sequences; traversals are a bit more general
15:24:56 <arbn> hiptobecubic: That's not valid Scheme.
15:25:04 <ab9rf> RichyB: yeah, i get that
15:25:06 <RichyB> That's not *all* there is to HDLs, but that's a basic idea of what *an* HDL's semantics might work like.
15:25:19 <ab9rf> RichyB: reminds me of some of the stuff i've read about vectorizing computation actually
15:25:27 <hiptobecubic> arbn, no, but until you learn scheme and the nuances of "'", it was hard to tell.
15:25:43 <RichyB> Yes. All of the parallel computation systems that work resemble each other a bit.
15:25:57 <johnw> beaky: when you askhow haskell's pattern matching works, I'm not sure how deep an answer you want
15:26:03 <ab9rf> haha
15:26:07 <arbn> hiptobecubic: SICP and HtDP make the learning pretty smooth. SICP doesn't introduce quotation or side-effects until rather late.
15:26:13 <mm_freak> hiptobecubic: reactive-banana uses a complicated representation of signal networks internally, and it's not very flexible either
15:26:53 <hiptobecubic> mm_freak, but does the programmer have to care? How does that affect what we're interested in, which is reacting to events?
15:27:05 <ab9rf> someone has to care :)
15:27:09 <mm_freak> hiptobecubic: let me give you a simple example
15:27:29 <mm_freak> hiptobecubic: "you are holding space" . keyDown space <|> "hold space"
15:27:40 <mm_freak> this is realtimy netwire code
15:27:53 <mm_freak> the equivalent code in reactive-banana involves a recursive switcher
15:28:55 <mm_freak> let's say you want to have "seconds since program start", but you want to slow down this clock while the spacebar is held down
15:29:12 <mm_freak> integral_ 0 . (0.5 . keyDown space <|> 1)
15:29:26 <mm_freak> this is comparatively complicated to express in reactive-banana
15:29:31 <hiptobecubic> i see
15:29:49 <hiptobecubic> So what does rb give you in exchange?
15:30:16 <hiptobecubic> also what on the right of that alternative? just a 1? is that representing something like time here?
15:30:32 <mm_freak> it gives you a the classic notion of FRP without the ugliness of the numerous monadic approaches
15:30:59 <mm_freak> RB is fine for what it does and you can take advantage of its WX layer
15:31:19 <mm_freak> hiptobecubic: 1 = pure 1 in netwire
15:31:38 <hiptobecubic> ah ok
15:31:43 <mm_freak> 1 :: (Monad m, Num b) => Wire e m a b
15:31:44 <hiptobecubic> so 0.5 if keydown space else 1
15:31:50 <mm_freak> yeah
15:32:06 <mm_freak> read (<|>) as "or"
15:32:12 <hiptobecubic> yes
15:32:14 <mm_freak> regarding events you can read (.) as "and"
15:32:25 <mm_freak> 0.5 . for 10 . keyDown space
15:32:42 <mm_freak> 0.5 for 10 seconds, then 1
15:34:40 <hiptobecubic> Has anyone used netwire for gui programming?
15:34:54 <hiptobecubic> Or better, has anyone used both rb and netwire in a single application?
15:35:02 <mm_freak> i've seen a few projects on reddit and apparently HGamer3D now uses netwire
15:36:10 <hiptobecubic> Windows only :(
15:40:00 <mm_freak> hiptobecubic: i few weeks ago i've written an OpenGL example for netwire
15:40:04 <mm_freak> http://hpaste.org/83098
15:40:07 <mm_freak> works on linux
15:40:48 <mm_freak> it allows you to move around and will change the background color, if you leave the circle
15:41:38 <opamp> is there an alternative to sockets? or everything above the OS uses sockets for netwroking?
15:41:58 <dates> hi, how can I write my own Show instance for tuples larger than 7 components?
15:42:29 <RichyB> opamp: on Unix, everything above the OS uses a variant of the sockets API for networking.
15:42:54 <RichyB> 90% of the time you're writing anything networked, you just want TCP sockets.
15:43:02 <mm_freak> opamp: in haskell you use sockets + concurrency, typically combined with some streaming abstraction like pipes
15:43:08 <RichyB> Most of the rest of the time, you are writing video games and you want UDP.
15:43:29 <mm_freak> opamp: so the way you use sockets in haskell is very different from how you do it in most other languages
15:43:58 <mm_freak> dates: instance (Show a, Show b, Show c, …) => Show (a, b, c, …)?
15:44:11 <RichyB> Very occasionally you're doing something weird and you might want to use SOCK_RAW, which gives you direct access to the IP layer at least, and maybe ethernet too.
15:44:36 <RichyB> Pretty much the only exception to that is in things like OpenMPI.
15:47:10 <sproingie> linux has oddball sockets like netlink, not sure if those are actually usable from haskell tho
15:47:18 <ski> ab9rf : i'm not sure if "if the languages are TE then they can all express the same concept" is right .. except in the trivial sense of writing an implementation of the one language in the other
15:47:23 <dEPY> just out of curiousity... Can you define infix functions in haskell in same maner as *, +, ... ?
15:47:33 <dEPY> Or are those just special ?
15:47:48 <sproingie> dEPY: any function can be used infix, but if it isn't made of nonalpha chars, you have to surround it with backticks
15:48:00 <ski> > let infixr 3 >--<; (>--<) = (-) in 2 >--< 3 >--< 4
15:48:01 <lambdabot>   3
15:48:10 <sproingie> > 1 `max` 2
15:48:11 <lambdabot>   2
15:48:17 <dEPY> oh
15:48:21 <dEPY> cool :) tnx
15:48:58 <ski> dEPY : does that answer your question ? :)
15:49:03 <dEPY> yep :D
15:50:10 <dates> <mm_freak> yes, kind of that
15:51:28 <latro`a> > 2 - 3 - 4
15:51:30 <lambdabot>   -5
15:51:40 <latro`a> > @info (-)
15:51:42 <lambdabot>   <hint>:1:1: parse error on input `@'
15:51:54 <latro`a> what's the lambdabot analogue of :i?
15:52:56 <twomashi> data A = A Int; let foo = A 11; — How to get 11 back out of foo?
15:53:28 <johnw> case foo of A x
15:53:50 <johnw> or, make a function like: bar (A x)
15:54:08 <latro`a> or records
15:54:14 <johnw> yeah, or records
15:54:14 <twomashi> Have to pattern match it then
15:54:17 <latro`a> (though that's shorthand really)
15:54:36 <latro`a> but yes, any extraction from a constructor is ultimately via a pattern match
15:54:45 <latro`a> albeit not necessarily an explicit one
15:54:53 <johnw> twomashi: that's really what pattern matching is all about
15:55:04 <ski>   instance (Show a,Show b,Show c,Show d,Show e,Show f,Show g,Show h) => Show (a,b,c,d,e,f,g,h) where showsPrec _ (a,b,c,d,e,f,g,h) = showParen True $ shows a . showChar ',' . shows b . showChar ',' . shows c . showChar ',' . shows d . showChar ',' . shows e . showChar ',' . shows f . showChar ',' . shows g
15:55:07 <johnw> data constructors build up data, and pattern matching breaks down data
15:55:09 <ski> dates : &c.
15:55:34 <ski> latro`a : no direct analogue
15:55:38 <dEPY> any1 here uses emacs?
15:55:41 * ski
15:55:45 <johnw> dEPY: you bet
15:55:51 <dEPY> what's the difference between haskell-mode and ghc ?
15:55:52 <twomashi> I thought there might be another way since you get field getters if you do data { _foo :: Int } etc
15:55:59 <johnw> I don't just use Emacs, it's a lifestyle choice
15:56:06 <johnw> dEPY: you mean, ghc-mod?
15:56:06 <dEPY> lol
15:56:11 <latro`a> ski: aw, oh well, ty anyways
15:56:23 <johnw> twomashi: that's what we meant by "records"
15:56:30 <twomashi> Ah, right
15:56:30 <dEPY> it just says ghc in package list
15:56:36 <johnw> twomashi: but that's just syntactic sugar for writing a function called "_foo" that does pattern matching :)
15:56:50 <johnw> dEPY: huh, don't really know what that is then
15:57:02 <twomashi> johnw: you may be amused to hear that I am now using mapAccumR, and rolled my own graph, and I am still getting the stack space overflow
15:57:13 <johnw> twomashi: show me?
15:57:16 <twomashi> ok
15:57:53 <hpaste> “Anonymous Coward” pasted “Stack space overflow returns” at http://hpaste.org/84446
15:57:57 <edwardk> @remember johnw Stealing lens from the gods, and then having my liver eaten out daily.
15:57:57 <lambdabot> It is forever etched in my memory.
15:58:10 <johnw> haha
15:58:17 <ski> dates : btw, IRC custom is not to refer to a person by "<nickname> message", but to start with just the nickname, usually followed by a ":" or a ",", and then the message
15:58:25 * edwardk returns his attention to hashable-extras
15:58:37 <dEPY> johnw: seems to be ghc-mod. It says "Happy haskell programming"
15:58:46 <dates> ski : like this?
15:58:50 <ski> e.g., yes
15:59:00 <dates> ski, thanks :)
15:59:10 <ski> (some people prefer it with no space before the ":"/",")
15:59:44 <dates> I see, I am kind of new to this, so sorry for breaking rules.
15:59:52 <sproingie> most irc clients will expand it for you if you start typing the name and hit TAB
15:59:52 <ski> (dates : btw, if you say "<nickname> message", then it appears that you're claiming that *"nickname"* said "message")
16:00:12 <twomashi> johnw: the stack gets blown in deserialization of the Mixes, but that still doesnt explain to me why its happening… I've tried profiling and viewing the heap statistics but wasnt able to decipher the cause.
16:00:16 <dates> oh thanks, I didn't know that either. Thank you
16:00:22 <twomashi> johnw ( http://hpaste.org/84446 )
16:00:38 <johnw> reading...
16:00:56 <ski> (.. because many IRC clients display messages that "nickname" as said as "<nickname> message", or something close to that)
16:01:55 <dates> I see
16:02:05 <ski> dates : also, if you plan on staying here, it might be nice to look into getting a proper IRC client ;)
16:02:37 <ski> (which usually has ways to tell you if someone are talking to you, unlike a tab in a browser, which can easily be forgotten)
16:02:40 <eikke> has anyone ever done an ML compiler in Haskell?
16:02:55 <ski> (eikke : as in SML and O'Caml ?)
16:03:04 <eikke> yup
16:03:07 <dates> ski: do you have any recommendations?
16:03:23 <ski> hm. HBC was written in LazyML, iirc; so the other way around
16:04:13 <dates> btw I wrote Instance (Show a,Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j) => Show (a, b, c, d, e, f, g, h, i, j) and I got : <interactive>:1:89: parse error on input `=>' Can you tell why is that?
16:04:43 <johnw> twomashi: can you try importing Data.Map.Strict as Map, instead of Data.Map?
16:05:10 <ski> dates : on windows, X-Chat (please use <http://www.silverex.org/download/> for no nagware) or maybe mIRC. on *nices, there's also X-Chat; though i use the terminal-based irssi; there's also more. on Mac OS X, i dunno (Colloquy ?)
16:05:18 <twomashi> johnw: Have done. Didnt fix.
16:05:20 <hiptobecubic> mm_freak, it "works" in the sense that I managed to cabal-dev around it and build. But nothing rendered. Just black and massive system-wide lag. I imagine this is more related to my system than your program though :)
16:05:45 <johnw> twomashi: is there any easy way for me to run this code here?
16:05:50 <ski> dates : perhaps s/Instance/instance/
16:06:13 <hiptobecubic> mm_freak, although glxgears renders smooth and nice so who knows
16:07:03 <mm_freak> hiptobecubic: weird, because it has worked for multiple people in here
16:07:50 <johnw> twomashi: oh, and why are you using mapAccumR if you don't use the final value of idx?
16:08:07 <hiptobecubic> mm_freak, I don't know what to test really.
16:08:19 <twomashi> johnw: I will use it, when I have it working
16:08:28 <twomashi> I'm making a small mix generator so you can reproduce
16:08:31 <mm_freak> hiptobecubic: if you find a way to resolve it, i'd be happy to know…  i could help you later, when i've got some more time
16:08:41 <monoidal> dates: in general, it's better to write instances in a file
16:08:49 <johnw> twomashi: let me try some changes
16:08:58 <monoidal> dates: not in interactive mode
16:09:18 <ski> dates : btw, one of the most important things to realize about IRC is that people commonly are logged in to IRC all day and night, even though they aren't physically at the computer all that time. this way, they can catch up later if they want to
16:10:12 <dates> oh I see
16:10:29 <ski> dates : this means that if noone appears to be present who can help you, you should (a) not quit within a few minutes or half an hour; but rather (b) wait *at least* a few hours, and come back later days if you haven't got an answer
16:11:12 <ski> dates : however, doing this is more important on more quiet channels than #haskell (which is usually pretty active), and where questions can get lost in the noise (so try asking again later)
16:11:13 <dates> okey, I will keep them in mind - thanks also monodial
16:11:18 <lispy> ircbrowse.net is now a nice way to search the log here asa well
16:12:14 <connelly> is there a module for implementing a LLVM backend in haskell?
16:12:22 <ski> dates : it is quite frustrating for someone who can answer to see that the querent has already left the channel
16:13:51 <ski> dates : also, it's usually considered impolite to ask "is anyone here ?" or "can anyone help me with <topic> ?" -- many people don't like to commit themselves into trying to help until they know at least somewhat what the question is about -- so be bold, and ask your question :)
16:14:17 <ski> (dates : i think #haskell is more forgiving of this than some other channels, though)
16:14:36 <hiptobecubic> most channels have it in the /topic
16:15:32 <dates> okey, I'll keep these in mind :)
16:15:46 <xkcd> hiptobecubic: Can you make a comment on this http://pyvideo.org/video/1799/functional-programming-with-python
16:16:12 <xkcd> may be after watching for a few min
16:16:21 <ski> dates : i'm just mentioning this because these seems to be the most common misunderstandings newbies have with IRC culture -- not saying you in particular did any of this ;)
16:17:41 <dEPY> someone explain this:
16:17:43 <dEPY> > [3,2,1] > [2,10,100]
16:17:44 <lambdabot>   True
16:18:03 <hiptobecubic> @src [] (>)
16:18:03 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
16:18:11 <hiptobecubic> @src (>) []
16:18:11 <lambdabot> Source not found.
16:18:13 <hiptobecubic> oh well
16:18:38 <dEPY> Book says first heads are compared then second elements ....
16:18:44 <smarter__> 3 > 2
16:18:45 <monoidal> dEPY: indeed, and 3 > 2
16:18:47 <alpounet> dEPY, lexicographic ordering
16:19:13 <dEPY> doesn't it compare second elements then after that?
16:19:30 <monoidal> dEPY: no, first place where it's different decides the result
16:19:31 <sproingie> dEPY: it works for any list of Ord elements.  this is how strings compare.
16:19:40 <alpounet> only if the first elements are equal dEPY
16:20:01 <dEPY> oh I see
16:20:04 <dEPY> cool tnx
16:20:10 <kludgy> Cale: I switched to the strict version of hGetContents.. that seems to work, but appears to be unrelated to the program not responding to requests when one would expect by looking at code :( http://pastebin.com/6bGWTdrN
16:20:15 <mauke> The paste 6bGWTdrN has been copied to http://hpaste.org/84447
16:21:01 <hiptobecubic> I suppose it's reasonable, but I still find it annoying when people talk about the disadvantages of functional programming as "not OO. Hard to understand compared to OO. Loops are easier than recursion for everyone"
16:21:19 <dates> ski: thanks for warning, now I can behave better here :)
16:21:21 <hiptobecubic> it's reasonable because almost everyone is taught OO, mind you. Not because I agree with any of it necessarily.
16:21:28 <sproingie> actually lists of Ord are themselves Ord ... the derivation of that is somewhat magical
16:21:34 <hpaste> johnw annotated “Stack space overflow returns” with “Stack space overflow returns (annotation)” at http://hpaste.org/84446#a84448
16:21:34 <Cale> kludgy: hmm
16:21:41 <johnw> twomashi: see if that helps at all
16:21:48 <Cale> kludgy: Hang on, I'll try to run it myself
16:21:57 <sproingie> > [[1]] > [[2]]
16:21:58 <lambdabot>   False
16:22:13 <kludgy> Cale: Something is still nagging at me that I'm missing a subtlety of chaining/binding in the do notation
16:22:48 <dEPY> hiptobecubic: about loops... I used map and filter in php in my last job and my boss (CTO) was angry at me cause it's too complicated to read and understand altough the code was like 3 times shorter and more compact.
16:23:07 <Saizan> kludgy: how are you sending the requests?
16:23:13 <hiptobecubic> dEPY, it's not really about being shorter and compact. I jsut don't agree that loops are easier than composing map and filter
16:23:30 <kludgy> Saizan: From chrome, connecting to localhost:9000
16:23:46 <hiptobecubic> map and filter are both easy concepts to understand. it's just less to keep in your short term memory when you are trying to understand a larger problem
16:23:52 <dEPY> hiptobecubic: I don't agree either. But I had to revert that code back to like 3 or 4 times nested loops :D
16:24:36 <Saizan> kludgy: maybe chrome is trying to keep the connection alive? if it doesn't close it hGetContents won't return
16:24:40 <dEPY> hiptobecubic: exactly. I told him that and I said other programmers will surely undestand after first read of the documentation if they don't know the concepts already... but... meh :)
16:25:45 <hiptobecubic> dEPY, it's just an example of what I was talking about. Even simple funtional programming concepts are frowned upon because most programmers are already familiar with the (often worse) imperative way and that becomes the basis of all comparison
16:26:02 <hiptobecubic> So it's not enough that it works. You have to justify having used it in place of the "normal" way
16:26:16 <Cale> kludgy: There're type errors in your pasted code
16:26:57 <hiptobecubic> and then you have talks like this video where he opens with advantages and disadvantages of the paradigm and the disadvantages are basically "you didn't have a bunch of mandatory classes involving this stuff so it's hard"
16:27:32 <Cale> actually, it was just the PortID parameter
16:28:15 <hiptobecubic> It's funny really. Before I knew that "functional programming" was thing, I used a lot of these features in python and just assumed that it was normal to have them. I was rudely awakened by my first experience with C.
16:28:23 <hiptobecubic> was a thing*
16:29:38 <dEPy_> O_o weird disconnect...
16:29:45 <twomashi> johnw: tried your changes, didnt compile.. having dinner now but am preparing a version you can run, i'll ping you. thanks for your help
16:31:39 <Cale> oh
16:31:50 <Cale> kludgy: the reason is that hGetContents is waiting for the socket to close
16:32:22 <Cale> and of course, you probably don't want to wait that long to do anything because then it's too late to respond
16:32:46 <monoidal> indeed. with netcat, the parsing starts after Ctrl-D
16:33:44 <dEPy> hiptobecubic: forgot to mention, when my boss saw I was passing functions as parameters to other functions, he called that "programming masturbation" because it only feels good for the person who wrote it cause he's showing off... :D
16:34:04 <dEPy> I didn't know if I should laugh or cry honestly.. :)
16:34:14 <monoidal> so during refreshing, the browser only then closes old socket and that's why it's seen
16:34:16 <kludgy> Cale: apologies for the type error.. ad hoc editing in pastebin
16:34:27 <kludgy> Cale: and good call on waiting for the socket to close
16:34:59 * hackagebot hash 0.1 - Hashing tools  http://hackage.haskell.org/package/hash-0.1 (EdwardKmett)
16:35:01 <hiptobecubic> dEPy, that's straight out of K&R C. Go look at qsort.
16:35:49 <johnw> twomashi: i will likely be asleep, but i'll see the ping tomorrow
16:36:54 <hpc> hiptobecubic: imagine going from any other language to "you can't have assignments in a lambda" python ;)
16:36:54 <lcfrs> jfischoff: i'm thinking of using maxent for a small project
16:37:36 <hiptobecubic> hpc, that was one of the first programming language complaints I ever had :D  I'm kind of proud of myself now :)
16:37:46 <hpc> i got bit by that my first day of python, and i didn't even know what lambda was
16:37:58 <hpc> i copy-pasted some code from somewhere else to solve a PE problem
16:38:11 <hpc> replaced the interesting part with an increment of some kind
16:38:12 <hpc> and it borked
16:38:29 <hiptobecubic> although, it's one of the few times I'll say that python seemed arbitrarily stupid. Normally I was pleasantly surprised when I wanted to do something "ugly"
16:38:43 <hpc> indeed
16:39:02 <hpc> it was that lambda issue and python's weird handling of numeric types, for me
16:39:36 <hpc> doing PE problems in a "duck-typed" anything-goes language, only to get a runtime error when you give it an int instead of a float
16:39:46 <hpc> was quite frustrating
16:39:59 <hiptobecubic> PE?
16:39:59 * hackagebot hash 0.1.1 - Hashing tools  http://hackage.haskell.org/package/hash-0.1.1 (EdwardKmett)
16:40:01 * hackagebot log-domain 0.4 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.4 (EdwardKmett)
16:41:33 <hiptobecubic> hpc, I've had a lot of bugs like that in the last few days. I'm always bitten by numpy.arange() defaulting to int.
16:43:23 <madjestic> hey guys, how do I check, if an argument is a list?
16:44:01 <monoidal> madjestic: simply speaking, you can't
16:44:05 <hiptobecubic> xkcd, what did you want to talk about?
16:44:11 <opamp> madjestic: static typing doesnt allow that
16:44:32 <hiptobecubic> madjestic, it's determined at compile time what the type will be.
16:44:36 <rmunroe> hiptobecubic: Hmm?
16:44:43 <rmunroe> oh, never mind
16:44:46 <monoidal> madjestic: if a function is polymorphic, then it has to behave uniformly for lists and nonlists
16:44:59 * hackagebot compensated 0.2 - Compensated floating-point arithmetic  http://hackage.haskell.org/package/compensated-0.2 (EdwardKmett)
16:45:01 * hackagebot hash 0.1.2 - Hashing tools  http://hackage.haskell.org/package/hash-0.1.2 (EdwardKmett)
16:45:26 <opamp> PE=Price/Earnings?
16:45:41 <madjestic> right, but if it's of type foo::a->a.  'a' can be a list, but then foo must return a list too, right?
16:45:49 <monoidal> madjestic: yes
16:45:54 <hiptobecubic> opamp, ah, perhaps
16:46:25 <monoidal> madjestic: the only foo of type a -> a is identity, i.e. returning what you got (excluding some pathological values like exceptions)
16:47:32 <johnw> edwardk: cool, just "hash", I like it
16:48:17 <heath> is there a method in cabal for showing when a package was last updated?
16:49:15 <hpc> get the info from hackage?
16:49:21 <edwardk> johnw: well it merged the hashable-extras code i had lying around here with a bunch of stuff from Data.Analytics.Hash.*
16:49:34 <edwardk> and i'll probably wind up putting a murmurhash impl in there, etc.
16:49:35 <hpc> there isn't really a clear notion of "last updated" for packages
16:49:52 <johnw> although it could be a package for combining anonymous meat products with tiny potatoes...
16:49:58 <edwardk> johnw: true
16:49:59 <madjestic> hmm, I am trying to right a function like this: http://hpaste.org/84450
16:50:16 <edwardk> hen you can release add-on modules corned-beef-hash, etc.
16:50:23 <madjestic> what direction should I take?
16:50:23 <johnw> exactly
16:50:38 <hpc> madjestic: step back from the implementation; what type do you want it to have?
16:50:42 <hiptobecubic> edwardk, broken link for travis|buildstatus in hash readme
16:50:47 <edwardk> hiptobecubic: woops
16:50:59 <hpc> (this is only partially a trick question)
16:51:25 <edwardk> thanks =)
16:51:36 <madjestic> hpc it should output a sum of vlues, whether it is a list of values, or a singlton value, not in a list
16:51:59 <hpc> i mean, what actual type
16:52:11 <madjestic> float or an integer
16:52:16 <hpc> "add is a function from X to Y"
16:52:18 <madjestic> a numeric valaue
16:53:08 <madjestic> k, I meant the product of X.  a fold, not addition per se
16:53:55 <hpc> so afaict, you want it to be something like
16:54:15 <hpc> add :: Num a => (either one value of 'a' or a list [a]) -> a
16:54:21 <madjestic> yes
16:54:36 <madjestic> I very much want that
16:54:57 <hpc> the way you do that is... not pleasant
16:55:28 <hpc> and it's honestly better to just call it with single numbers as (add [x]) and move on
16:55:41 <hpc> but for the sake of exercise
16:55:50 <hpc> the way i would do it is
16:55:52 <madjestic> hpc if by doing so I wil learn a thing or two and have a laughe in between - I am very much willing to try such unpleasant way
16:56:37 <hpc> class AddClass a b | a -> b where add :: a -> b -- you need functional dependencies or something similar to express that the return type depends on the input; you'll see why
16:57:12 <hpc> instance Num a => AddClass a a where add = id -- you need some other extensions to make this work too, i forget exactly which
16:57:47 <hpc> instance Num a => AddClass [a] a where add = foldl' (+) 0
16:58:08 <hpc> that lets you write both (add 5) and (add [1, 2, 3, 4, 5])
16:58:20 <madjestic> aha, so they are add functions, belonging to different type classes?
16:58:31 <hpc> belonging to a single type class
16:58:45 <hpc> 'add' is a single function with a single type
16:58:47 <hpc> and that type is
16:58:56 <hpc> add :: AddClass a b => a -> b
16:59:17 <hpc> it has a different implementation for each (AddClass a b) instance you give it
16:59:36 <madjestic> interesting
16:59:42 <hpc> now there's some places this can fall apart
16:59:45 <hpc> namely
17:00:01 <hpc> instance Num a => Num [a] where fromInteger x = repeat x
17:00:10 <hpc> now we can do something like
17:00:26 <hpc> (1 :: [Int]) = [1, 1, ...]
17:00:32 <heath> hpc: okay, that works
17:00:37 <heath> thank you
17:00:46 <hpc> and so now if we call (add (1 :: [Int])), what does it equal?
17:00:51 <hpc> there's two instances it can use
17:01:03 <hpc> because [Int] matches (Num a) => [a]
17:01:14 <hpc> but [Int] is also a Num, so it matches the first instance too
17:01:44 <hpc> ghc has rules that it uses to attempt to resolve the confusion, and i haven't bothered to waste braincells on knowing if those work here
17:02:56 <hpc> i also mentioned that this class requires a functional dependency
17:03:09 <hpc> so, that "| a -> b" part means, a determines what b is
17:03:44 <hpc> if we know that 'a' is '[Int]', we can immediately deduce from just that information that 'b' is 'Int'
17:04:17 <hpc> a nice consequence of this is that you can't have a third instance
17:04:30 <hpc> uh
17:04:35 <hpc> well you probably can actually
17:04:43 <hpc> but that's because we're doing weird stuff
17:05:14 <hpc> supposing we wrote our instance like "instance Add [Int] Int where"
17:05:30 <hpc> we couldn't add a conflicting "instance Add [Int] Double where"
17:05:50 <hpc> or instance Add [Int] (IO ()) where add _ = unsafeLaunchMissiles
17:06:22 <hpc> without that functional dependency, we also have to specify what exact result we want
17:06:53 <hpc> without that little bit of magic, 'a' and 'b' are totally independent, and the compiler can't infer that you mean to add that [Int] to an Int
17:07:09 <hpc> there could be another instance like the evil i just mentioned, but in a totally different module
17:07:35 <hpc> or some other kind of wrongness
17:08:09 <madjestic> hehe
17:08:30 <hpc> at this point, i would pull back and say, "how about a data structure"
17:08:48 <hpc> data Add a = Single a | List [a]
17:08:53 <hpc> add (Single a) = a
17:09:03 <hpc> add (List as) = foldl' (+) as
17:09:09 <genisage> I've been trying to get that to work
17:09:19 <hpc> but now we have to say
17:09:22 <hpc> add (Single 5)
17:09:27 <hpc> add (List [1..5])
17:09:39 <genisage> But I can't figure out how to work (Num a) into it.
17:09:46 <hpc> and at that point, we might as well dispense with any illusion of polymorphism and say add [1..5] and add [5]
17:10:14 <hpc> that Num constraint comes into the type of add
17:10:24 <hpc> data-structured add would be of type
17:10:31 <hpc> add :: Num a => Add a -> a
17:11:45 <genisage> But how would you prevent somebody from using those data constructors on values that can't be added?
17:12:22 <madjestic> hpc ehh, wait, what?  How did you get from add (Single 5) to add (List [1..5]) ?
17:12:44 <hpc> madjestic: those are two pattern matches
17:12:52 <genisage> It's a pattern match of the constructor
17:13:02 <madjestic> dang
17:13:06 <hpc> it's like
17:13:12 <hpc> frobnicate False = 15
17:13:19 <hpc> frobnicate True = 33.16
17:13:30 <hpc> except more complicated
17:14:49 <madjestic> I am pretty sure that I read about that in LYAH, but my mind is blown anyways
17:17:21 <dncr> If f operates on arbitrarily large ByteStrings, how should I memoize it? Can I use a trie (like Data.MemoCombinators.bits does on integers)? Is Data.Trie too strict for this purpose?
17:22:47 <genisage> can somebody explain why XDatatypeContexts is bad?
17:23:27 <c_wraith> the X isn't part of the name, it's just the command-line flag to specify a language extension
17:23:36 <c_wraith> DatatypeContexts is bad because it more or less does nothing.
17:23:43 <dmwit> genisage: It's not bad. It's just not good.
17:23:57 <dolio> There is no longer a reason to put contexts on a datatype, given how it works.
17:24:05 <monoidal> unlike GADT syntax, it's broken
17:24:24 <genisage> Why isn't it good to be able to o something like data Ord a => Tree a = stuff
17:24:38 <dmwit> Because it doesn't do what the syntax would suggest it ought to do.
17:24:39 <c_wraith> Two reasons: the first is that it doesn't make anything easier
17:25:04 <c_wraith> The second is because it prevents creating trees for non-ord types of a, which still makes sense in some cases. (singleton trees, for instance)
17:25:58 <dmwit> Okay, so the real answer is like this: it doesn't let you omit "Ord a" from the context of things that munge "Tree a"s. Which is what you'd want it to do.
17:26:29 <c_wraith> @ty M.singleton
17:26:30 <lambdabot> k -> a -> M.Map k a
17:26:44 <c_wraith> Notice how there's no Ord constraint on k in that function
17:26:47 <dmwit> That is, if you have a value of type "Tree a" and you pattern match on it to get some values of type "a", you *still* can't call compare or (<) or (>) on them.
17:26:48 <c_wraith> because it's not needed
17:26:50 <dmwit> So what's the point?
17:27:37 <monoidal> if you match on data Tree a where Node :: Ord a => a -> Tree a, you get the Ord instance
17:27:59 <genisage> What I thought it would be useful for was making sure you couldn't create a piece of data that wouldn't with the functions you had written.
17:28:00 <monoidal> i.e. you don't need to supply it in the type signature
17:28:15 <c_wraith> genisage: you don't need it to do that, though
17:28:17 <jcowan> I have some n00b questions; I'm about halfway through LYAH, and these are things that have come up in mind, more  "Why?" than "How?"  Is this the right place for them?
17:28:26 <monoidal> if you match on data Ord a => Tree a = Node a then you have to put Ord in the signature
17:28:26 <c_wraith> genisage: look at the type of singleton in Data.Map
17:28:38 <shachaf> jcowan: Go ahead and ask your questions.
17:28:46 <c_wraith> genisage: it doesn't interfere with all the functions that put an Ord k constraint in
17:28:54 <c_wraith> genisage: instead, each function specifies what it needs
17:29:40 <dmwit> genisage: I sympathize with wanting to prevent the user from making Tree a values unless a is orderable. Unfortunately, the reason I sympathize is because later I want to assume that my Tree only contains orderable things.
17:29:49 <dmwit> genisage: The first part you get. The second part you don't.
17:29:57 <dmwit> The first part is useless on its own.
17:31:33 <dmwit> genisage: Another way to say this is: go ahead and use DatatypeContexts in an old build of GHC for a while and see if you still like it. =P
17:31:37 <genisage> I do get the second part. It just seemed like it would be easier to debug if you got an error as soon as the data was created, instead of waiting until a function tries to operate on it.
17:32:01 <dolio> The errors are always at compile time.
17:32:15 <dmwit> genisage: Oh, by "get" I didn't mean "understand". I literally meant "get", as in, "DatatypeContexts guarantees the first but not the second".
17:32:27 <genisage> But the part of the program that generated it would be different
17:32:43 <jcowan> 1) Either has symmetrically named constructors, yet is used asymmetrically. What's the story there?
17:32:59 <c_wraith> genisage: wait, runtime? No. Either way, the problem is caught at compile time.
17:33:05 * timtom is happy because he just wrote his first working happstack+acid-state program
17:33:08 <shachaf> jcowan: What do you mean? That Right usually means success, and Left usually means failure?
17:33:18 <monoidal> genisage: essentially what datatype context does is require the context every time the type appears, that's all
17:33:26 <genisage> Yes, I know type errors are caught at compile time, but the line number would be different.
17:33:52 <c_wraith> So? The error message is still going to be "no instance (Blah Blah)"
17:34:20 <jcowan> I would have expected something like "data Either a b = Wrong a | Right b", or something with equally polarized names.
17:34:40 <monoidal> genisage: if you have a function that depends on the methods in the context, its type will be the same with and without DatatypeContexts
17:34:48 <shachaf> jcowan: Well, Either has a lot of uses.
17:34:58 <monoidal> genisage: if you have a function that does not depend on the methods, it will behave in the same way with or without the context
17:35:00 * hackagebot hash 0.2 - Hashing tools  http://hackage.haskell.org/package/hash-0.2 (EdwardKmett)
17:35:00 <shachaf> Some of them are symmetric and some of them aren't. Left and Right don't assume anything.
17:35:06 <monoidal> genisage: so there is completely no difference in behavior
17:35:14 <dmwit> jcowan: Sometimes, I use Either as a basic sum type, not as a Wrong or Right.
17:35:18 <jcowan> 2) Is the quicksort algorithm presented in LYAH really a quicksort?  I cannot convince myself that it really has n log n time complexity when lazily implemented.
17:35:28 <jcowan> dmwit: Thanks
17:35:36 <genisage> Thanks for the explanations everybody.
17:35:42 <shachaf> jcowan: Is it the foo (x:xs) = filter (<= x) xs ++ [x] ++ filter (> x) xs?
17:35:45 <dmwit> jcowan: Most "quicksorts" in Haskell are not quicksort in the traditional sense.
17:35:48 <jcowan> Yes.
17:35:57 <shachaf> jcowan: That is not really quicksort. I wish people would stop spreading that rumour.
17:36:15 <dmwit> jcowan: However, it does have the usual n log n complexity.
17:36:21 <shachaf> jcowan: Er, I fortgot the recursive sort calls. :-)
17:36:29 <monoidal> dmwit: sort [1..n]?
17:36:36 <dmwit> average time
17:36:44 <shachaf> dmwit: Does it really?
17:36:52 <c_wraith> yeah, it does
17:36:57 <c_wraith> just *terrible* constant factors
17:37:23 <c_wraith> also, you really should use partition instead of a pair of filters
17:37:27 <dmwit> https://en.wikipedia.org/wiki/Tree_sort
17:37:30 <c_wraith> that saves you one O(n) pass right up front
17:37:34 <dmwit> O(n^2) worst case, O(n log n) average case
17:37:39 <madjestic> http://hpaste.org/84450 I get an error, if I call add [1..5], instead of add (List [1..5]), as ghc suggested.  What am I missing?
17:37:49 <c_wraith> Which is a good constant factor
17:37:53 <jcowan> Also, the choice of pivot is known to suck, but lots of quicksorts have that problem.
17:38:06 <jcowan> I would have expected a mergesort as optimal for linked lists.
17:38:15 <shachaf> jcowan: Choosing the first element is more justified with linked lists. :-)
17:38:19 <dmwit> jcowan: I believe GHC's Data.List.sort is mergesort.
17:38:28 <hiptobecubic> yes
17:38:29 <dmwit> This is also good for laziness in a way that quicksort is not.
17:38:43 <monoidal> madjestic: your function takes a value of type Add a, while you give it [a]. they are different types
17:38:44 <c_wraith> yeah, mergesort is nicely lazy, assume your merge is head-biased
17:38:47 <ab9rf> merge sort is usually the best general sort for large data sets.
17:38:49 <monoidal> madjestic: therefore the function cannot be used
17:39:27 <jcowan> 3) How does "deriving" work?  It seems like magic.
17:39:39 <c_wraith> Data.List.sort is also bottom-up. I suspect all performance-oriented mergesorts are, but it's not all that publicized
17:39:48 <ab9rf> i have to admit that i think stack-sort is fairly amusing
17:40:00 * hackagebot hashable-extras 0.1 - Higher-rank Hashable  http://hackage.haskell.org/package/hashable-extras-0.1 (EdwardKmett)
17:40:06 <ab9rf> but so far the only known working implementation is in javascript
17:40:12 <monoidal> jcowan: it has special cases for several (7?) classes, built-in into the compiler
17:40:35 <dmwit> jcowan: Can you say what about it seems magical?
17:41:08 <dmwit> "How does the compiler {know,do,guess,implement} X?" or something like that
17:41:24 <jcowan> Just so.
17:41:43 <dmwit> That was supposed to be a mad-lib. =)
17:41:55 <monoidal> jcowan: it has a fixed template. say, you derive Eq and your datatype is data A = X Int | Y | Z Bool
17:42:32 <geekosaur> the basic derivable types are fully documented in the haskell language report
17:42:37 <monoidal> jcowan: then it generates code (X a == X b) = (a == b); (Y == Y) = True; (Z a == Z b) = (a == b); (_ == _) = False
17:42:48 <monoidal> it's mechanical and hardwired
17:42:48 <geekosaur> it's a "mechanical" operation, no magic about it
17:42:58 <madjestic> monoidal: http://hpaste.org/84453  What could hpc mean than?
17:43:08 <geekosaur> newtype deriving is not documented there but is equally mechanical
17:43:46 * geekosaur does not understand the question
17:44:06 <dmwit> Perhaps it seems magical that GHC can derive any class. This is because GHC can not derive any class.
17:44:17 <geekosaur> there is a type there, defined in terms of two patterns:  data Add a = Single a | List [a]
17:44:24 <dmwit> It can only derive Eq, Ord, Show, Read and a handful of others in special cases.
17:44:26 <monoidal> madjestic: I don't know
17:44:35 <jcowan> 4) Why are guards thought to be better style than if-then-else chains?
17:44:47 <dmwit> jcowan: There's no accounting for taste.
17:44:52 <dmwit> next question
17:45:02 * jcowan snorks
17:45:11 <geekosaur> given these patterns, you can now create values of the type by dupicating the pattern (someA = Single 5; anotherA = List [3..6])
17:45:26 <monoidal> jcowan: they're more compact
17:45:49 <genisage> I find guard more readable and easier to organize.
17:45:53 <jcowan> 5) How can pure (i.e. non-IO) functions call "error", when it doesn't return a proper value?
17:46:01 <geekosaur> or you can recognize these values by their patterns: add (Single a) = a; add (List as) = foldl' (+) as
17:46:12 <dmwit> jcowan: That's a bit awkward, isn't it?
17:46:13 <arkeet> jcowan: the same way pure functions can loop indefinitely.
17:46:28 <ski> "In Haskell 98, the only classes that may appear in the deriving clause are the standard classes `Eq', `Ord', `Enum', `Ix', `Bounded', `Read', and `Show'." <http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#deriving-typeable>
17:46:33 <dmwit> ?google tackling the awkward squad
17:46:35 <lambdabot> http://research.microsoft.com/~simonpj/Papers/marktoberdorf/mark.pdf.gz
17:46:36 <monoidal> jcowan: usually error means programming error
17:46:38 <dmwit> jcowan: Might like that paper.
17:47:08 <dmwit> ...specifically the section on exceptions
17:47:11 <ski> "Specification of Derived Instances" <http://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18200011>,"Deriving Instances of Ix" <http://www.haskell.org/onlinereport/haskell2010/haskellch19.html#x27-22700019.2>
17:48:09 <jcowan> I tried it but found it too hairy for me at this stage.
17:48:31 <geekosaur> madjestic, did you follow what I said above?
17:48:32 <timtom> How do you guys organize your code when you have lots of record types? Do you create a separate module for each record type?
17:48:47 <madjestic> hpc, I don't think I fully understand you, when you said: "we might as well dispense with any illusion of polymorphism and say  add [1..5] and add [5]
17:48:48 <dmwit> jcowan: That's a shame, as it has several pages outlining a very clear, concise argument for Haskell's exception mechanism.
17:49:03 <jcowan> 6) I don't understand what minBound and maxBound really are.
17:49:05 * dmwit encourages a second attempt
17:49:13 <jcowan> dmwit: I will tackle it a gain then
17:49:22 <dmwit> jcowan: minBound and maxBound are constants of polymorphic type corresponding to the minimal and maximal elements of that type.
17:49:30 <monoidal> jcowan: there's a class called Bounded and it contains two members, minBound and maxBound
17:49:37 <ski> also <http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-programming.html> may be interesting
17:49:49 <ski> jcowan : see above links for "deriving"
17:49:54 <dmwit> jcowan: Alternately: minBound is a mapping from types that implement the Bounded typeclass to a value of that type.
17:49:57 <monoidal> jcowan: you can declare any type to be an instance of Bounded by giving values for minBound and maxBound
17:49:59 <geekosaur> madjestic, hpc meant there is no real justification for handling the case of a single item separately from a list; just pass a single-element list
17:50:07 <dmwit> (and likewise for maxBound)
17:50:22 <hiptobecubic> > minBound :: Float
17:50:24 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
17:50:24 <lambdabot>    arising from a use of...
17:50:32 <hiptobecubic> > minBound :: Char
17:50:34 <geekosaur> so now add always takes a list
17:50:34 <lambdabot>   '\NUL'
17:50:47 <geekosaur> it doesn't have to have a special variant that takes a non-list
17:51:25 <ski> jcowan : if all guards of a defining equation fail, the next defining equation is tried. with `if'-`then'-`else', you have already committed to the current defining equation
17:51:51 <dmwit> ski++ for this juicy tidbit that I always somehow manage to forget
17:51:52 <madjestic> geekosaur: yes, I did.  However my question was concerning that line: we might as well dispense with any illusion of polymorphism and say add [1..5] and add [5].  That is I understood it as:  instead of add (List [1..5]) - it should be possible to say: add [1..5]
17:52:03 <geekosaur> no
17:52:08 <monoidal> madjestic: note that foldl' (+) [x] == x
17:52:19 <geekosaur> he was talking about the one where we can say add 5 or add [1..5]
17:53:05 <geekosaur> the add (List xs) vs. add (Single x) is not polymorphic; it always has the same type, but values can take different forms indicated by the constructor used
17:53:24 <geekosaur> nevertheless all such values are still of type Add a
17:54:13 <madjestic> geekosaur: so how can I get to being able to do: add 5 -- or -- add [1..5]?
17:54:51 <ski> jcowan : it may or may not confuse you that `minBound' and `maxBound' are overloaded on the "return type" (in this case, they are not functions, so that's the whole type)
17:55:00 * hackagebot log-domain 0.5 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.5 (EdwardKmett)
17:55:01 <ski> > read "123" :: Int
17:55:03 <lambdabot>   123
17:55:04 <ski> > read "123" :: Bool
17:55:06 <lambdabot>   *Exception: Prelude.read: no parse
17:55:24 <ski> `read' is another operation overloaded on the return type (only)
17:56:04 <ski> > 1 + read "123"
17:56:05 <lambdabot>   124
17:56:10 <ski> > not (read "123")
17:56:12 <lambdabot>   *Exception: Prelude.read: no parse
17:56:20 <geekosaur> madjestic, you were told that already? go read your backlog starting at "class AddClass"
17:56:57 <geekosaur> you were also told why it's a really bad idea, but I get the impression you are too wedded to this little hack to care just how badly you can shoot yourself in the foot with it, you just want that hole in your foot
17:57:03 <dmwit> > not (read "True")
17:57:04 <lambdabot>   False
17:57:26 <jcowan> ski: Yes, I think that's what confused me.
17:57:57 <ski> jcowan : btw, `error' doesn't return a value at all (just like an infinite loop doesn't return any value)
17:58:38 <madjestic> geekosaur: I did not ralise that the last bit concerned the part, related to that.  I percieved that the data stracture was a preferable alternative to the inital sollution
17:59:00 <jcowan> Right.  So my mental model is that there is a reduction machine, and "error" jams the machine, and this is safe because there is no way back, so it is always deterministic.  But this breaks down because there might be more than one call to error, and depending on the  exact implementation of laziness you might get any (all?) of them.
17:59:01 <ski> however, `error', as well as pattern-match failure (or last guard failing, with no more equation to try) results in aborting computation
17:59:42 <dmwit> jcowan: That is correct, and in fact the compiler is allowed to choose at will between any exceptions it could throw in a lazy evaluation.
17:59:42 * jcowan nods.
17:59:46 <monoidal> jcowan: indeed, it's called imprecise exception
18:00:02 <dmwit> jcowan: My most famous StackOverflow question is the result of exactly this, you might like it.
18:00:05 * dmwit goes hunting
18:00:10 <ski> jcowan : yes, the idea there is to claim that we get the set of all errors the code could possibly raise -- and then demonic nondeterminism at the I/O level indeterministically picks one of them
18:00:15 <monoidal> jcowan: for example, error "X" + error "Y" can give you error "X" or "Y", semantics does not precise which one
18:00:21 <dmwit> http://stackoverflow.com/q/11070690/791604
18:00:40 <jcowan> Does that even make sense?  What is the type of error "X"?
18:00:47 <dmwit> :t error "X"
18:00:48 <lambdabot> a
18:00:51 <ski> (in practice, implementation details such as which order things happened to evaluate will determine which one you get -- however, optimizations are free to change which one you get)
18:01:16 <jcowan> So a does not implement Num (as such), so there should be no way to even get that past the compiler.
18:01:29 <jcowan> Or am I confused?
18:01:34 <dmwit> Integer implements Num, and a can unify with Integer.
18:01:36 <monoidal> the type of error "X" + errory "Y" is Num a => a
18:01:48 <cmccann_> the type will default to Integer, yes
18:01:49 <monoidal> numeric typeclasses usually default to Int
18:01:55 <monoidal> or Integer
18:01:56 <dmwit> (Indeed, "a" unifies with "Num a => a".)
18:02:03 <jcowan> Mm, yes, I see that now
18:02:03 <dmwit> :t error "X" :: Num a => a
18:02:05 <lambdabot> Num a => a
18:02:26 <ski> this is known as "imprecise exceptions". see "A semantics for imprecise exceptions" by Simon Peyton Jones,Alastair Reid,Tony Hoare,Simon Marlow,Fergus Henderson in 1999 at <http://research.microsoft.com/en-us/um/people/simonpj/papers/imprecise-exn.htm>
18:02:32 <jcowan> So if a function never returns a value, its type signature can have variables on the right that don't appear on the left?
18:02:41 <dmwit> correct
18:02:56 <dmwit> assuming "right" and "left" refers to the sides of "->" they appear on
18:03:00 <jcowan> Yes
18:03:14 <cmccann> :t const undefined
18:03:15 <lambdabot> b -> a
18:03:32 <dmwit> :t let neverReturns n = neverReturns (n+1) in neverReturns -- for example
18:03:34 <lambdabot> Num a => a -> t
18:03:42 <dmwit> :t let neverReturns = neverReturns in neverReturns -- for another
18:03:43 <lambdabot> t
18:04:09 <ski> jcowan : occasionally, you can catch infinite loops in code by noticing the inferred type has type variables in the return type not occuring otherwise in the type
18:04:23 <monoidal> jcowan: conversely, if the RHS of "->" is some variable that is not on the left hand side, it would have to arise from nothing; so the function must hang or give error
18:04:26 <ski> @type forever
18:04:27 <lambdabot> Monad m => m a -> m b
18:04:37 <jcowan> Umph.
18:04:52 <fizbin> :t lmap
18:04:53 <lambdabot> Profunctor p => (a -> b) -> p b c -> p a c
18:05:02 * hackagebot pipes 3.2.0 - Compositional pipelines  http://hackage.haskell.org/package/pipes-3.2.0 (GabrielGonzalez)
18:05:15 <cmccann> similarly, a type like "a -> [b]" only has one non-errory result possible
18:05:26 <ski> the `b' here in the return type indicates that the resulting action doesn't yield a final value (but the effects of the input action are done repeatedly, ignoring *its* result (of type `a'))
18:05:37 <niteria> @hoogle TimeoutManager
18:05:37 <lambdabot> No results found
18:05:48 <monoidal> jcowan: also note that the definition "let x = x" gives x :: a
18:06:22 <ski> e.g. if you have `forever (print 945)', then `print 945' has type `IO ()', and the whole action will have type `IO a', for any type `a' that you prefer/like
18:06:36 <dmwit> ?free a -> [b]
18:06:36 <lambdabot> Extra stuff at end of line
18:06:42 <dmwit> ?free foo :: a -> [b]
18:06:43 <lambdabot> $map g . foo = foo . f
18:07:54 <dmwit> This says: the output of foo is exactly the same, no matter what function you map over it.
18:08:29 <dmwit> And in particular this means foo outputs [], by choosing a function like (+1) that never outputs exactly the same thing it gets as input.
18:08:48 <niteria> ?free i :: a -> a
18:08:48 <lambdabot> f . i = i . f
18:08:55 <ski> @free foo :: Int -> a
18:08:55 <lambdabot> f . foo = foo
18:09:08 <arkeet> @free x ::
18:09:08 <lambdabot> Extra stuff at end of line
18:09:10 <arkeet> @free x :: a
18:09:10 <lambdabot> f x = x
18:09:26 <arkeet> heh
18:09:40 <arkeet> only if x is strict.
18:09:44 <arkeet> er, f.
18:10:13 <dmwit> If the equation is well-typed, f need not be strict.
18:10:29 <dmwit> um
18:10:30 <niteria> ? g :: [a] -> (a -> [b]) -> [b]
18:10:30 <dmwit> j/k
18:10:39 <niteria> ?free g :: [a] -> (a -> [b]) -> [b]
18:10:39 <lambdabot> $map h . k = p . f => $map h (g xs k) = g ($map f xs) p
18:10:47 * ski . o O ( "All conversations eventually degenerate to bot abuse." )
18:11:12 <monoidal> good night
18:11:20 <ski> night, monoidal
18:13:22 <fizbin> When I was complaining here n what use arrows are, and why one actually wants them someone suggested I go read http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#arrows-and-idioms
18:13:24 <ski> jcowan : any more comment, question or request for clarification ?
18:13:57 <genisage> what are you asking lambdabot with free?
18:14:04 <ski> @help free
18:14:04 <lambdabot> free <ident>. Generate theorems for free
18:14:15 <dmwit> genisage: free takes a type and generates a theorem about all inhabitants of that type
18:14:25 <genisage> Thanks
18:14:26 <fizbin> Unfortunately, I clearly don't have the background for that paper - is there anyone here who's read it who can point me at something that will give me the proper background for section 2 ?
18:15:26 <fizbin> Section 2 is glossing over what must be standard notation in PL papers, but as I don't read PL papers on a regular basis, I don't know what that notation means.
18:16:04 <ski> genisage : "Theorems for free!" by Philip Wadler in 1989-09 at <http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html#free>
18:16:29 <madjestic> geekosaur: I read your explanation, however I do not understand why is it such a bad thing to do in the context that I demonstrated (computing a product of a value, which may be either a list of elements or a single element that's not a list)
18:16:34 <ski> genisage : the generated theorem holds because of parametric morphism, can be derived from the type alone
18:16:46 <ski> @free listFun :: [a] -> [a]
18:16:46 <lambdabot> $map f . listFun = listFun . $map f
18:16:59 <geekosaur> madjestic, because you're giving the compiler license to do unexpected things with type inference
18:17:14 <geekosaur> the compiler is much more clever than you are, and this can lead to unpleasant surprises
18:17:23 <ski> this says that it doesn't matter if you apply `listFun' to a list, and then `map' a function `f' on each of the elements, or do it in the other order : the result will be the same
18:17:46 <dmwit> geekosaur: That is a great way to put it.
18:18:00 <ski> so, it's saying that any function with the type of `listFun' must be "agnostic" in the list elements : it can't look at them, it can't do something special if their type is `Int', &c.
18:18:23 <ski> it may just pass the elements around, and perhaps duplicate and/or discard references to them
18:19:18 <ski> this is a great boon to reasoning about code, especially higher-order code
18:20:04 <jcowan> nope, done, thanks all.
18:20:11 <ski> if you have `map :: (a -> b) -> [a] -> [b]', then you already know from the type alone that the only way `map' may actually use the elements of type `a' is by passing them to the argument function -- and that's the only way it may get the `b' elements from
18:22:07 <madjestic> geekosaur: I still want to do that for the sake of the excercise
18:22:49 <geekosaur> madjestic, specifically, if it sees something which was actually a typo or mistake, but it can use AddClass to make it make some weird kind of sense, it will do so. and the result is likely to be either an unexpected error somewhere else when it can't make that work elsewhere, or possibly a program which compiles but produces bizarre results. I've had both happen when I wasn't careful with typeclasses
18:23:03 <madjestic> it's not like a giant lazer will scorch the Earth if I do that wrong
18:23:06 <ski> madjestic : hm, how do you know the list isn't actually a list of lists ?
18:23:21 <no-n> what's the prefix for base 2?
18:23:52 <dmwit> no-n: "bi"?
18:23:56 <madjestic> ski: because I control the context, for the sake of the excercise
18:24:03 <dmwit> or, what does prefix mean?
18:24:18 <no-n> 0x is for base 16
18:24:25 <dmwit> Ah, there isn't one, sadly.
18:24:29 <no-n> ah
18:24:43 <cmccann> 0b would make sense
18:24:43 <dmwit> You should make a Haskell' proposal, I'd love to see binary-literal syntax and it should be a harmless addition.
18:24:47 <dmwit> yes
18:24:52 <dmwit> gcc allows 0b sometimes, I think
18:24:55 <no-n> ya, 0b is in python
18:24:55 <dmwit> with appropriate flags
18:24:57 <no-n> but not C
18:25:06 <cmccann> yeah, I thought I'd seen it elsewhere
18:25:20 <madjestic> geekosaur: right.  I see that there are good reasons to do certain things in a certain way
18:25:20 <cmccann> I also endorse it as a proposal
18:25:29 <no-n> indeed
18:26:06 <tromp> i'm all for binary
18:26:09 <no-n> we could start an online petition :)
18:26:23 <ski> @hoogle Num a => ReadS a
18:26:23 <lambdabot> Numeric readDec :: Num a => ReadS a
18:26:23 <lambdabot> Numeric readHex :: Num a => ReadS a
18:26:23 <lambdabot> Numeric readOct :: Num a => ReadS a
18:26:27 <ski> @type readInt
18:26:28 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
18:26:31 <ski> > readInt 2 (`elem` "01") digitToInt "1011"
18:26:33 <lambdabot>   [(11,"")]
18:26:33 <no-n> http://www.change.org
18:26:41 <aavogt> http://hackage.haskell.org/package/binary-literal-qq
18:26:43 <ski> no-n ^
18:26:48 <dmwit> > readBin "23423"
18:26:50 <lambdabot>   Not in scope: `readBin'
18:26:50 <lambdabot>  Perhaps you meant `readLn' (imported from Prelude)
18:27:04 <no-n> thanks
18:27:04 <dmwit> no-n: Haskell' proposals *are* online petitions.
18:27:09 <dmwit> Except with a chance of actually doing something.
18:27:15 <no-n> dmwit: ah. where are they?
18:27:35 <dmwit> Google for "haskell prime proposal"?
18:28:09 <dmwit> http://hackage.haskell.org/trac/haskell-prime/wiki/Process
18:28:21 <ski> > chr 0o033  -- octal
18:28:22 <lambdabot>   '\ESC'
18:29:06 <ski> > 0o33
18:29:08 <lambdabot>   27
18:29:15 <geekosaur> > 0b10101
18:29:16 <lambdabot>   Not in scope: `b10101'
18:29:21 <geekosaur> oh well
18:29:41 <dmwit> Maybe in Haskell 2022!
18:30:17 <ski> dmwit,cmccann : how about something like <http://www.erlang.org/doc/programming_examples/bit_syntax.html> ?
18:31:05 <cmccann> ski: sounds potentially useful but a bit elaborate
18:31:49 <dmwit> Am I missing something?
18:32:01 <dmwit> Does this discuss a facility for base-2 numbers somewhere?
18:32:28 <ski> @hackage BitSyntax
18:32:28 <lambdabot> http://hackage.haskell.org/package/BitSyntax
18:32:39 <tromp> but if you have base 2, 4, 8, and 16, shouldnt you do base 4 as well?
18:32:54 <dmwit> 0q3302
18:32:58 <tromp> (uhm, meant leave out 4 in first list)
18:33:16 <tromp> ah yes, quaternary
18:33:41 <geekosaur> nybbles!
18:34:02 <ab9rf> why not do base 32 as well?
18:34:58 <ski> hm, both Prolog and Erlang allow number literals in bases between `2' and `36'
18:35:11 * cmccann votes for base 91
18:35:31 <ab9rf> why only 91?
18:35:40 <cmccann> why not?
18:35:43 <cmccann> it's a good number.
18:35:49 <geekosaur> thing is, binary and hex are very well established, octal is still useful for working with unix constants from the minicomputer era, but the last nybble-based cpu I recall seeing was only used in hand calculators
18:36:00 <ab9rf> there's 94 printable nonblank characters in 7-bit ascii :)
18:36:44 <cmccann> 94 has entirely too many factors. not awkward enough.
18:36:47 <geekosaur> but if you really want to be silly, at least some versions of 'dc' let you use arbitrary integral bases >= 2
18:36:47 <tromp> yeah, but you need to be self delimiting too
18:37:11 <cmccann> actually, wait. I can't arithmetic in my head.
18:37:16 <cmccann> I guess 94 would be ok.
18:37:26 <geekosaur> cmccann, we can go back to babylonia, base 60
18:37:40 <tromp> base 4 would make geneticists happy
18:38:01 <tromp> although they'd want to use ACGT as digits
18:38:17 * ski . o O ( <http://en.wikipedia.org/wiki/Golden_ratio_base>,<http://en.wikipedia.org/wiki/Fibonacci_coding> )
18:39:58 <ski> 0dnaACGT
18:40:20 <hpaste> heath pasted “failure to install cabal-dev” at http://hpaste.org/84454
18:40:31 <ski> (of course also a `0rnaACGU')
18:40:59 <cmccann> pf, uracil.
18:41:40 <geekosaur> .oO (ur cilly too)
18:41:53 <cmccann> heh
18:47:40 <hiptobecubic> . o O ( When did this get so popular? )
18:49:32 <tgeeky> . o O 0 <-- the smallest thought bubble
18:54:03 <lightquake> how can I tell what part of my haskell code is causing a stack overflow in ghc 7.4?
18:54:09 <lightquake> (i.e., I don't have the 7.6 stack stuff)
18:54:35 <tgeeky> man, that's hard to search for given the site "stack overflow"
18:54:50 <lightquake> yeah :(
18:55:20 <tgeeky> you can do -site:stackoverflow.com, but then you might miss the answer!
18:56:09 <amatsu> surely you can search stackoverflow for stack overflows directly.
18:56:40 <tgeeky> lightquake: I'm just going to be pasting links, I don't know if they will help or not. Sorry: http://blog.ezyang.com/2011/05/anatomy-of-a-thunk-leak/
18:57:24 <tgeeky> lightquake: http://stackoverflow.com/questions/6429085/haskell-heap-issues-with-parameter-passing-style/6429888#6429888
18:57:40 <tgeeky> lightquake: http://comments.gmane.org/gmane.comp.lang.haskell.cafe/90803
18:58:35 <tgeeky> lightquake: though the solution, once the problem is found, is to add strictness. (!)
18:58:38 <ski> hiptobecubic : dunno
18:59:06 <tgeeky> ski: FYI, there is a phinary module for Haskell
19:00:17 <tgeeky> ski: http://devrand.org:8080/cgi-bin/cgit/phinary <-- it is there, if that site works again in the future.
19:19:54 <hpaste> heath pasted “missing-files” at http://hpaste.org/84456
19:20:05 <heath> could use some help
19:22:59 <dmwit> heath: ghc-pkg check ?
19:23:09 <dmwit> heath: And then cabal install --reinstall the broken packages?
19:23:34 <dmwit> heath: (...what did you DO?)
19:23:57 <dmwit> Oh, I see this *is* the output of ghc-pkg check and I just hadn't gotten far enough.
19:24:05 <dmwit> My goodness. What DID you do?
19:24:31 <dmwit> ...you might consider just "rm -r ~/.cabal" and starting over. =P
19:24:49 <dmwit> rm -r ~/.cabal ~/.ghc
19:24:50 <applicative> heath: or are you meaning to use a later ghc but still have ghc-7.4 around, having meant to get rid of it
19:25:54 <heath> so on this particular machine i installed snap after installing yesod, yesod complained, and i reacted by doing the stupid: sudo apt-get remove #something like lib-ghc and the haskell-platform# then rm -rf ~/.cabal
19:26:19 <heath> and a apt-get purge for good measure then apt-get install libghc and haskell platform
19:26:28 <applicative> wait is it just a .ghc dir thats still around
19:26:29 <heath> cabal install cabal-dev
19:26:32 <dmwit> rm -r ~/.ghc
19:26:32 <heath> and foobar!
19:26:48 <heath> oh
19:26:49 <applicative> right like dimwit says
19:26:53 <Clint> yesod complained about snap?
19:27:06 <applicative> woops called dmwit dimwit
19:27:26 <dmwit> iit happens
19:27:36 <heath> yesod just complained
19:27:37 <heath> $ yesod devel
19:27:37 <heath> yesod: initINotify: resource exhausted (Too many open files)
19:27:56 <dmwit> You had too many open files and your reaction was to reinstall GHC?
19:28:14 <applicative> my kind of guy
19:28:14 <heath> and somewhere during all this i realized i needed to sandbox these apps
19:29:04 <heath> i was under a lot of stress picking a web framework, take it easy on me :P
19:29:41 <YayMe> in any language (generally speaking) if you: Only use function application, or other functions that only use function application, do you get guaranteed purity? I think so, but then I might not be able to think up the way of wiggling impurity into that..
19:30:20 <heath> rm -rf ~/.ghc worked
19:33:14 <hiptobecubic> YayMe, what is your question? If you build an entire expression out of pure functions then it will also be pure.
19:33:37 <YayMe> hiptobecubic: can function application be impure is my question
19:34:10 <hiptobecubic> YayMe, "function application" meaning what? Calling an arbitrary function in an arbitrary programming language?
19:34:13 <YayMe> if you apply impure functions, yes, but if you only apply functions which only use function application inside of them, is there any way with which function application can be pure?
19:34:34 <YayMe> or rather any way it can be impure I mean
19:35:13 <hiptobecubic> YayMe, if the function itself does not mutate data and does not call any functions which mutate data then it is pure
19:35:50 <YayMe> a combinator is defined as "only using function application or previously defined combinators" I'm staking the claim that if the *only* tool you use is function application or functions which only use that, you have guaranteed purity, but I don't want to say that without running it past you folks since y'all know a lot more than I
19:35:53 <hiptobecubic> if the function calls pure functions, but is not pure itself, then of course the entire thing will be impure
19:37:24 <hiptobecubic> Well like I said, if the function does no mutation and only calls other pure functions, then the expression will be pure
19:38:07 <hiptobecubic> The compiler proves this for you when you build a huge a expression tree with no IO in it
19:38:12 <YayMe> I know that.. that doesn't say if it only uses function application it will be pure though. I can't imagine only using function application and having that mutate data
19:38:28 <YayMe> but maybe it's possible
19:38:33 <hiptobecubic> YayMe, if you aren't using assignment, I don't see how.
19:38:42 <YayMe> That's my thought as well
19:38:42 <hiptobecubic> unless you are doing some fishy IO
19:38:53 <YayMe> but fishy IO would require assignment
19:39:18 <YayMe> unsafePerformIO does assignment underneath so calling it would be calling something that doesn't *only* use function application
19:39:35 <YayMe> I'm satisfied with my logic. It's pure (until someone tells me otherwise)
19:40:13 <hiptobecubic> puresin x = unsafePerformIO $ print "ERMAHGERRRDD" >> return . Prelude.sin x
19:40:38 <hiptobecubic> err, ignore that . and replace with ()
19:40:58 <YayMe> I have no idea what that would do
19:41:17 <YayMe> :t sin
19:41:17 <hiptobecubic> prints some garbage and then returns sin
19:41:18 <lambdabot> Floating a => a -> a
19:41:38 <hiptobecubic> the point is that you have to cheat
19:41:49 <hiptobecubic> if you dno't cheat then the type tells you that it's pure
19:42:24 <lightquake> I can't get ghc to allow profiling options, even though I'm using cabal configure --enable-executable-profiling
19:42:44 <hiptobecubic> since there is no (permissible) function f :: IO a -> a, then you are all set
19:42:59 <hiptobecubic> lightquake, error message?
19:43:07 <lightquake> decafc: the flag -xc requires the program to be built with -prof
19:43:16 <YayMe> hiptobecubic: Good enough for me.
19:43:28 <hiptobecubic> also you probably need library profiling as well. and if you didn't enable that before you started then everything is probably doomed.
19:44:26 <lightquake> no, i made sure to enable that
19:54:14 <Cale> https://www.youtube.com/watch?v=rRbY3TMUcgQ -- lol
19:54:28 <shachaf> kfish: I don't think either use of hash is for actual cryptographic hash functions as in sha1 etc., is it?
19:55:31 <shachaf> kfish: As far as I can tell both versions are meant to be "fast keys for balanced containers". The question is whether you can come up with patterns to DoS a hash table with.
19:56:16 <kfish> shachaf, oh ok, i misinterpreted the reasoning for siphash
19:56:37 <kfish> is it related to having persistency?
19:57:25 <shachaf> I think that's also an issue. I haven't been keeping close track of it, but I think the current version picks a random salt for every run of the program or something like that.
19:57:39 <shachaf> (Of course you can always pick a salt yourself.)
19:58:06 <shachaf> (But when a package like unordered-containers uses a hash function directly it can be trickier.)
20:17:31 <tgeeky> lol. seriously?
20:19:02 <parcs> tgeeky: seriously :(
20:19:30 <luite> :)
20:19:40 <parcs> i wish to petition tgeeky's ban
20:20:26 <Clint> aren't you doing that in the wrong channel?
20:20:33 <parcs> yes
20:20:36 <tgeeky> is there a right channel?
20:20:51 <shachaf> #haskell-ops is the channel for that.
20:21:08 <shachaf> Philippa isn't in there, though.
20:21:28 <Philippa> shachaf: it isn't. -blah is not under the jurisdiction of -ops
20:22:30 <shachaf> OK.
20:23:25 <shachaf> At any rate this channel is not the place for it.
20:23:38 <hiptobecubic> tgeeky, doesn't look very banned
20:24:12 <tgeeky> hiptobecubic: Cannot join to channel #haskell-blah (You are banned)
20:25:29 <hiptobecubic> ah
20:25:31 <parcs> perhaps it's time to start a new #-blah with 100% less power-hungry, trigger-happy ops
20:26:16 <Philippa> could be. Feel free to talk to boegel about it
20:26:35 <Philippa> maybe it's time to start /another/ one with less sexist bullshit, too
20:28:44 <hiptobecubic> Well it shouldn't be in here.
20:29:04 <chrisdotcode_> hello everyone :)
20:29:34 <tgeeky> who the hell is boegel, anyway?
20:30:06 <parcs> he's the creator of #-blah who is now 100% irrelevant to the daily functioning of #-blah
20:31:25 <Rogach> Hello! I've got a cabal problem - I'm trying to reinstall package arithmoi with profiling enabled, but it complains: "Could not find module `Control.Monad.State.Strict' Perhaps you haven't installed the profiling libraries for package `mtl-2.0.1.0'?". I did install "libghc-mtl-prof" package on my machine. What could be wrong?
20:31:59 <tgeeky> parcs (who is not here): I've never heard of him/her, so that at least makes sense.
20:32:13 <dmwit> Rogach: Perhaps you have an installation of mtl in your local package repository that is overriding the global one.
20:32:17 <dmwit> Rogach: Try ghc-pkg list mtl
20:32:30 <hpaste> tgeeky pasted “(no longer) private messages between tgeeky and Philippa” at http://hpaste.org/84457
20:32:59 <monochrom> this is why possessing multiple versions is confusing.
20:33:11 <Rogach> dmwit: No, there's only one - in global.
20:34:07 <monochrom> may I see the output of "ghc-pkg list -v"? and also "ghc -v"?
20:34:35 <dmwit> also also ghc-pkg check
20:35:02 <Philippa> tgeeky has just posted that without my consent
20:35:10 <hpaste> Rogach pasted “ghc-pkg list -v” at http://hpaste.org/84458
20:35:42 <Philippa> and FWIW, that does *not* belong in this chan
20:35:43 <hpaste> Rogach pasted “ghc -v” at http://hpaste.org/84459
20:35:51 <dmwit> Philippa: For an abuse of power like that, followed by a refusal to justify the abuse, I think he damn well ought to.
20:36:00 <tgeeky> Philippa: yeah, to that I agree. #haskell-blah is not listed as a channel to paste it in.
20:36:25 <hpaste> Rogach pasted “ghc-pkg check” at http://hpaste.org/84460
20:37:03 <Philippa> dmwit: Wrong. Channel.
20:37:49 <Rogach> dmwit: Seems I indeed have a problem (as shown by ghc-pkg check), but it's unrelated to mtl and arithmoi.
20:39:16 <hiptobecubic> how dramatic
20:40:33 <tgeeky> hiptobecubic: I just had a vision of you being Hedonism Bot from Futurama.
20:40:39 <monochrom> Rogach: may I see "ghc-pkg describe mtl"?
20:40:48 <hiptobecubic> tgeeky, I wish. That guy's got it good.
20:43:07 <hpaste> Rogach pasted “ghc-pkg describe mtl” at http://hpaste.org/84461
20:43:11 <Rogach> monochrom: Sure
20:46:34 <monochrom> I can't figure out what's going on
20:47:49 <Rogach> monochrom: Neither can I :(
20:50:09 * hackagebot bytestring-lexing 0.4.3 - Parse and produce literals efficiently from strict or lazy bytestrings.  http://hackage.haskell.org/package/bytestring-lexing-0.4.3 (WrenThornton)
20:51:27 * lispy wonders what wren is up to
20:53:54 <lispy> I would have expected mtl to be a trusted lib
20:54:04 <lispy> I don't have it installed to check if it is here
20:54:14 <lispy> If you're trying to compile safe haskell that could be an issue?
21:01:09 <Rogach> lispy: Sorry, I'm a newbie. What's "safe haskell"?
21:02:56 <Rogach> Btw, I needed to nuke several global packages that were doubling the user packages (as shown by ghc-pkg check), and now I can't install them back, because cabal now wants profiling by default.
21:04:42 <Rogach> Now that's sad, because in particular, I can't install my xmonad back, and that means that if I would need to restart, I'll lose my WM.
21:04:50 <lispy> Rogach: you may need to reinstall your ghc.
21:05:22 <lispy> Rogach: You pretty much never want to remove/upgrade things in your global package db due to the way ghc works.
21:05:37 <lispy> Unfortunately, this is not obvious :(
21:05:59 <lispy> Rogach: can you simply ask your package manager to reinstall the OS packages for those libraries?
21:07:46 <Rogach> lispy: Those reinstallation were needed because I screwed up my earlier xmonad install.
21:07:55 <Rogach> lispy: Yes, I'll try.
21:08:48 <Rogach> Well, seems the root of the problem was in me, after all. Why is ghc-prof not dependent on libghc-mtl-prof?
21:09:41 <dmwit> What does ghc-prof provide?
21:09:52 <dmwit> (Is there a reason to expect that ghc-prof should depend on libghc-mtl-prof?)
21:12:20 <Rogach> dmwit: I'm a bit confused (because of all that reinstall stuff), but my idea is as follows - if package "ghc" resulted in mtl library on my system, then "ghc-prof" should also contain the mtl files.
21:12:45 <Rogach> dmwit: Maybe I'm wrong, and mtl ended up being on my system for some other reason.
21:12:54 <dmwit> Hm. Did ghc result in mtl on your system?
21:13:33 <dmwit> I bet it didn't. =)
21:13:53 <Rogach> dmwit: Is there a way to see what packages depend on certain package?
21:14:10 <Rogach> dmwit: Because there's one thing I'm sure of - I didn't install mtl package by hand.
21:14:23 <dmwit> huh
21:14:50 <dmwit> I don't really know the answer to your most recent direct question.
21:15:55 <Rogach> dmwit: Sorry, it's deb-specific. I'll ask elsewhere.
21:17:57 <Clint> Rogach: libghc-mtl-dev goes with libghc-mtl-prof and libghc-mtl-doc
21:18:26 <lispy> Rogach: ghc doesn't ship with mtl so it would be odd for your OS package to provide mtl as part of ghc. On the other hand, they might have marked it as a 'recommended' package and your system automatically added it to the "install plan"?
21:18:56 <Clint> no, something else caused libghc-mtl-dev to be installed
21:19:14 * hiptobecubic thinks -dev packages are stupid
21:22:15 <Rogach> Ok, seems my problem is now solved. Thanks a lot!
21:22:23 <Rogach> hiptobecubic: What's wrong with them?
21:22:40 <hiptobecubic> There's no good reason not to include them by default
21:22:46 <hiptobecubic> They always lead to headaches
21:23:00 <hiptobecubic> Someone is missing some headers for some obscure library
21:23:53 <hiptobecubic> and they weren't installed with the library for what? to save 16k on disk in exchange for doubling the number of packages you have to sort through every time your run the package manager
21:24:45 <Clint> well, in the haskell case, the -dev package IS the library
21:30:09 * hackagebot sbv 2.10 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-2.10 (LeventErkok)
21:32:42 <Sgeo> @hoogle (Applicative f) => (a -> f b) -> (b -> f c) -> a -> f c
21:32:42 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
21:32:43 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
21:32:43 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:33:35 <Sgeo> Hmm. Arrow has that operation too, I guess Applicative doesn't?
21:34:00 <latro`a> that's composition of Kleisli arrows
21:34:05 <latro`a> the exact signature of it
21:34:20 <latro`a> pretty sure there's no way to have a non-Monad Applicative with that, because it's only a tiny step away from >>=
21:34:44 <latro`a> (all you need is a notion of function application, so that you can have "const m")
21:34:45 <Sgeo> I'm trying to get some intuition for what Arrows provide over Applicatives
21:35:09 <latro`a> m >>= f = (const m >=> f) ()
21:35:32 <dario> :t (>=>)
21:35:34 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
21:35:39 <shachaf> m >>= f = (id >=> id) (fmap f m)
21:36:00 <Sgeo> :t (id >=> id)
21:36:01 <lambdabot> Monad m => m (m c) -> m c
21:36:02 <latro`a> that's sorta indirect by comparison
21:36:12 <latro`a> since that's how you get join then >>=
21:36:44 <shachaf> Yep.
21:36:51 <shachaf> But I don't like const and ()
22:19:25 <JoeyA> > show (userError "didn't work")
22:19:26 <lambdabot>   "user error (didn't work)"
22:20:01 <JoeyA> Does anybody else but me wish that (show . userError) would just print the string directly, without "user error" ?
22:20:36 <JoeyA> Since a "user error" usually isn't the end user's fault.
22:21:57 <newsham> > show $ text "stuff here"
22:21:59 <lambdabot>   "stuff here"
22:23:10 <JoeyA> :t text
22:23:11 <lambdabot> String -> Doc
22:24:57 <monochrom> perhaps don't use userError. it was invented in an old era when the only exception type was IOError, trying to provide a custom-made exception but not very successfully as you see why.
22:25:26 <monochrom> today, you can completely write your own exception type and use it, including what it is called.
22:27:54 <adnap> #yesod is so dead...
22:28:51 <JoeyA> monochrom: sure, but fail "My.Module.foo: whoops" is extremely convenient for reporting API misuse.
22:30:50 <JoeyA> Meh, I guess it's not too inconvenient to just define a custom exception type.
22:32:27 <arbn> adnap: Ask your Yesod question in here and ignore the haters. :)
22:39:13 <adnap> arbn: I don't know what haters you're referring to.
22:39:28 <adnap> My question is: I want to use reactive-banana with yesod to define things like "Event t GetPageR". In reactive-banana, newAddHandler produces a callback function "a -> IO ()" which fires an event. How can I give my yesod getPageR handler access to this callback?
22:45:16 * hackagebot pipes-network 0.1.0.1 - Use network sockets together with the pipes library.  http://hackage.haskell.org/package/pipes-network-0.1.0.1 (RenzoCarbonara)
23:45:22 * hackagebot cabal-rpm 0.7.1 - RPM package creator for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.7.1 (JensPetersen)
23:57:47 <BadKitty> "all encrypted ciphers supported ordered from strong to weak." -> [ cipher_AES128_SHA256, cipher_AES256_SHA256, ... ]
23:58:03 <BadKitty> How can aes256 be weaker than aes128? O.o
23:58:13 <shachaf> As explained on the Wikipedia page.
23:58:27 <shachaf> Are you still changing your nick every few hours?
23:58:41 <BadKitty> shachaf: Sorry
23:58:53 <BadKitty> Not hours... Occasionally (Soemtimes often)
