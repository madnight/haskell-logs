00:00:38 <covi> srhb: /usr/local/bin/runghc. Also FYI, I am on Mac OS X
00:00:53 <srhb> Did you uninstall haskell before reinstalling Haskell platform?
00:01:23 <srhb> Also are you installing the 32 bit version? 64 bit has a lot of bugs on OS X afaik
00:01:58 <covi> srhb: I didn't know how to remove haskell so I didn't. I did use 64bit because my processor is 64 bit; can I use 32 bit on my laptop?
00:02:12 <srhb> covi: Yes
00:02:16 <srhb> covi: sudo uninstall-hs
00:02:24 <srhb> And nuke ~/.ghc and ~/.cabal
00:02:35 <srhb> Come to think of it, those are probably called something different on OS X
00:02:52 <srhb> ~/Library/Haskell/ghc and ./cabal ? Not sure. try to locate them.
00:02:58 <covi> srhb: there are two versions of ghc installed on my machine...
00:03:08 <srhb> covi: Nuke them both
00:03:46 <srhb> When you're done, you should have no runghc, ghc, runhaskell, ghci commands.
00:04:51 <covi> Should I also remove /usr/local/bin/ghc*?
00:05:21 <srhb> covi: uninstall-hs oought to do that for you
00:05:28 <srhb> covi: Unless you've installed ghc by some other mean
00:06:27 <srhb> sudo uninstall-hs --remove all ?
00:09:08 * srhb is afk
00:17:46 * hackagebot poker-eval 0.3.0 - Binding to libpoker-eval  http://hackage.haskell.org/package/poker-eval-0.3.0 (DavidHimmelstrup)
00:32:47 * hackagebot hit 0.5.0 - Git operations in haskell  http://hackage.haskell.org/package/hit-0.5.0 (VincentHanquez)
00:48:46 <srhb> covi: Did you fix it? :)
00:56:39 <ion> Does {-# SPECIALIZE INLINE foo :: [Bool] -> Word8 #-} do anything {-# INLINE foo #-} doesn’t?
00:57:25 <nicoo> ion: What is the type of foo ?
00:58:04 <ion> Integral a => [Bool] -> a
00:58:56 <mysticc> I have a datatype say data A = A Int Int Int, Now I am writing a function onA :: ExpQ -> (Int -> Int -> ExpQ) -> ExpQ, so onA $(A 5 5 5) f = [| A $(f 1 5) $(f 2 5) $(f 3 5) |]. To write such a function I need to pattern match on A which is in ExpQ form. Is there a better way than doing onA aQ fQ = [| case $(aQ) of ... |] ?
00:59:53 <mysticc> the example should be onA [| A 5 5 5 |] f = [| A $(f 1 5) $(f 2 5) $(f 3 5) |]
01:07:45 <Shane__> So I'm not sure if this function is useful to anyone, but here's liftM4019: http://pastebin.com/6bDU7xGm
01:08:16 <chrisdone> has anyone got a Text -> [Either URI Text] function that splits a string containing uris?
01:08:26 <mauke> The paste 6bDU7xGm has been copied to http://hpaste.org/83669
01:09:28 <Kinnison> chrisdone: splits it into what?
01:09:44 <chrisdone> Kinnison: either uris or just text
01:10:46 <Kinnison> So, given a lump of text with no embedded URIs, you get the text back, but given text with 1 or more embedded URIs you get the first URI back?
01:10:57 <chrisdone> no look at the type
01:11:09 <Kinnison> bleh, I can read, oh yes
01:11:16 <Kinnison> In my defence, I've not had any coffee yet
01:11:57 <Kinnison> Presumably you could start to go about it with a regexp
01:12:16 <chrisdone> i don't have a problem implementing it other than time, hence asking if anyone has got one
01:12:31 <chrisdone> nevermind
01:12:49 <johnw> chrisdone: hey there!  I see you here a lot less than I see you on twitter (jwiegley) :)
01:13:10 <mgsloan> 4 seconds too late :/
01:13:14 <johnw> argh
01:13:21 <mgsloan> I guess he likes to keep productive ;)
01:14:25 <mgsloan> though I'm surprised he didn't stick around for an answer, I feel like there are many delayed responses on IRC
01:15:12 <johnw> and I think http-types or Network.URI both have what he's looking for
01:16:45 <mgsloan> Maybe email him? haha
01:17:03 <mgsloan> I'd be more likely to worry about correctness than time
01:17:12 <mgsloan> then again who knows what his application is
01:18:28 <johnw> i tweeted him
01:19:44 <quicksilver> johnw: but that's not what he meant.
01:19:49 <johnw> ah
01:19:54 <quicksilver> Text -> [Either URI Text]
01:20:11 <johnw> oh, to extract all links from a text block?
01:20:34 <quicksilver> I.e. "I like this site http://foo.com but I hate this one http://bar.com" ---> [ Right "I like this site", Left (URI...), Right "but....]
01:20:40 <mgsloan> whoops, yeah, I'm guessing he's looking for something faster than (map parseURI . words)
01:20:53 <mgsloan> actually, wouldn't "map parseURI . words" be the way to go?
01:21:05 <mgsloan> well, not exactly that, you get the idea
01:21:11 <quicksilver> I'm pretty sure what he wants doesn't exist as a single function.
01:21:42 <mgsloan> sure, but if URIs can't have spaces in them, then that ought to work
01:22:00 <johnw> but what about URLs in text that end with "."
01:22:07 <johnw> where the . is a period, not part of the URL...
01:22:26 <mgsloan> Right, he'd probably want to use Data.List.Split if it's processing user inputed data or something like that (sounds like it)
01:22:51 <mgsloan> just split on all non-url characters
01:23:07 <mgsloan> it was inevitable that #haskell would discuss a solution after he left :D
01:23:41 <mgsloan> oh, well that doesn't handle the dot thing
01:23:59 <mgsloan> anyway, back to work..
01:48:53 <mbuf> what can cause this error "~/.cabal/share/lambdabot-4.3/State/system: copyFile: does not exist (No such file or directory)" https://github.com/mokus0/lambdabot/issues/38
01:49:10 <mbuf> or what provides "system"?
01:52:48 * hackagebot poker-eval 0.3.1 - Binding to libpoker-eval  http://hackage.haskell.org/package/poker-eval-0.3.1 (DavidHimmelstrup)
01:52:55 <mbuf> never mind, created system file with https://bitbucket.org/zeekay/lambdabot/src/57d60f44340bccdee2b61f7523e6a74aad91ca9e/State/system?at=default
02:22:49 * hackagebot pure-cdb 0.1 - Another pure-haskell CDB (Constant Database) implementation  http://hackage.haskell.org/package/pure-cdb-0.1 (BorisSukholitko)
02:37:49 * hackagebot hscope 0.3 - cscope like browser for Haskell code  http://hackage.haskell.org/package/hscope-0.3 (BorisSukholitko)
03:38:24 <akamaus> greetings
03:40:05 <akamaus> if I have an applicative F a, is there a way to somehow transform it, say, into F [a] ?
03:43:42 <arkeet> akamaus: transform what?
03:44:05 <augur> i think he means is it possible to define
03:44:06 <epta> > liftA (\x -> [x]) (Just 1)
03:44:09 <lambdabot>   Just [1]
03:44:19 <arkeet> liftA = fmap
03:44:23 <augur> instance Applicative f => Applicative (f . [])
03:44:32 <arkeet> augur: I have no idea what he means.
03:44:44 <akamaus> augur, yeah, something like that
03:44:52 <arkeet> ok.
03:45:01 <arkeet> yes, you can compose two Applicatives to get an Applicative.
03:45:05 <augur> akamaus: f . [] will be an applicative already since f is
03:45:06 <arkeet> see Data.Functor.Compose
03:45:09 <augur> but probably not the way you want
03:45:33 <augur> since f is an applicative, you can use applicative ops on f a for any a
03:45:36 <augur> so take a to be [b]
03:45:47 <arkeet> augur: no, that's not it.
03:45:57 <arkeet> augur: you can't "take a to be [b]"
03:45:59 <augur> the question is, akamaus, is that the kind of behavior you want
03:46:07 <akamaus> I'm writing a yesod form to edit a data type of form Foo Int [Text], so number of text fields must depend on length of a list.
03:46:10 <augur> arkeet: yes you cant.
03:46:23 <arkeet> because you want pure :: b -> f [b], not pure :: [b] -> f [b]
03:46:44 <augur> arkeet: well, for Applicative (f . []) yes
03:47:14 <augur> arkeet: i was not referring to that, however. i was refering to the fact that if f is an applicative, then you already have applicative ops for f [a]
03:47:28 <augur> just probably not the ones akamaus is looking for -- ie the ones you're describing
03:47:29 <arkeet> "applicative ops for f [a]"?
03:47:47 <augur> arkeet: yes, as in, pure :: [a] -> f [a]
03:48:06 <arkeet> that's not "for f [a]"
03:48:21 <arkeet> well whatever.
03:48:24 <augur> arkeet: yes yes i know but theres no better way to say it, stop being pointlessly pedantic.
03:48:49 <augur> well, in some very real sense, it IS for [a] but thats irrelevant :P
03:48:53 <arkeet> and <*> works even less.
03:49:02 <augur> this is going to be interestingly problematic, because you'll have overlapping instances
03:49:17 <augur> suppose x :: a and both f and f.[] are applicatives
03:49:21 <augur> what is pure x?
03:49:32 <arkeet> pure x :: Applicative f => f a
03:49:44 <arkeet> forall f
03:49:57 <augur> i should come up with a better example!
03:50:10 <augur> what is pure [x]
03:50:21 <arkeet> forall f. Applicative f => f [a]
03:50:38 <augur> mm.. yes thats probably true too!
03:50:41 <augur> well anyway
03:50:48 <arkeet> in any case, we don't have strict composition of type constructors in haskell
03:50:50 <augur> you might have overlapping instance problems, i dont know.
03:51:09 <augur> yeah, fortunately this wont be a problem without real composition
03:51:13 <arkeet> we won't, because we can't write (f.g) a = f (g a) and write instances for f.g
03:51:38 <augur> unless maybe you have type operators enabled
03:51:41 <arkeet> no, even then.
03:51:46 <arkeet> by = I mean actual equality.
03:51:51 <arkeet> not isomorphism (via newtype or whatever.)
03:52:11 <augur> yeah but cant you do   type (f :. g) a = f (g a)
03:52:14 <augur> with type ops
03:52:22 <arkeet> you can, but you can't partially apply (:.)
03:52:30 <augur> no?
03:52:32 <arkeet> ...no
03:52:34 <augur> why not?
03:52:37 <arkeet> you can't partially apply type synonyms
03:52:38 <arkeet> ever
03:52:43 <augur> well
03:52:50 <augur> ok enable the other extensions that let you :)
03:52:54 <arkeet> no, you just can't.
03:53:02 <augur> im pretty sure you can
03:53:06 <arkeet> I'm pretty sure you can't.
03:53:08 <arkeet> you're welcome to try.
03:53:17 <augur> im doing so as we speek!
03:53:19 <augur> speak even
03:53:51 <arkeet> and no extension will save you.
03:54:55 <arkeet> you can write instances for type synonyms, but those have to be fully applied type synonyms.
03:55:17 <arkeet> (because type synonyms always have to be fully applied.)
03:55:51 <arkeet> anyway
03:56:04 <arkeet> yes, you can write type (f :. g) a = f (g a). or even (f . g) a = f (g a) in 7.6
03:56:11 <arkeet> but you can't write just f :. g
03:56:19 <augur> you are incorrect sir.
03:56:24 <augur> you need 4 extensions
03:56:32 <augur> {-# LANGUAGE TypeOperators #-} {-# LANGUAGE FlexibleInstances #-} {-# LANGUAGE FlexibleContexts #-} {-# LANGUAGE UndecidableInstances #-}
03:56:37 <arkeet> show me your code.
03:56:50 <augur> at least for applicative, because you need a functor constraint on (f :. [])
03:57:22 <hpaste> augur pasted “4arkeet” at http://hpaste.org/83670
03:58:28 <arkeet> uh
03:58:34 <arkeet> no.
03:58:37 <augur> works fine for me.
03:58:39 <arkeet> you wrote .: in line 10
03:58:41 <arkeet> not :.
03:59:17 <augur> oh, sorry, i didnt catch that. how interesting.
03:59:26 <arkeet> I wonder what it thinks .: is
03:59:34 <arkeet> oh wait.
03:59:38 <arkeet> it's just another type operator variable.
03:59:51 <arkeet> (which won't work in 7.6)
04:00:43 <augur> ok, you're correct. with typeops, typesyn instances, and flex instances it still complains.
04:00:57 <arkeet> as I said, type synonyms must always be fully applied.
04:01:04 <augur> so it seems!
04:01:12 <arkeet> else a lot of things would break.
04:01:17 <arkeet> someone else can tell you more about what would break.
04:01:22 <shachaf> You can't use . -- not in GHC, anyway, because of forall or something.
04:01:42 <arkeet> shachaf: I think you can, it just gives you a cryptic error if you don't have -XTypeOperators on
04:02:14 <arkeet> shachaf: what would break if we could partially apply type synonyms?
04:02:19 <shachaf> arkeet: In GHC 7.6.2 you get a rather cryptic error message, telling you to turn on RankNTypes
04:02:24 <arkeet> yes, that's what I'm saying.
04:02:33 <shachaf> So you can't use .
04:02:40 <shachaf> arkeet: Partially apply them where?
04:02:42 <arkeet> even with -XTypeOperators on?
04:02:45 <arkeet> shachaf: anywhere. say, instances.
04:02:46 <augur> shachaf: not bare . probably
04:02:51 * hackagebot cabal2nix 1.46 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.46 (PeterSimons)
04:03:04 <arkeet> I don't have a machine with 7.6 handy right now so I can't check.
04:03:17 <arkeet> I guess I could grab my laptop from 5 feet away.
04:03:31 <shachaf> 5 feet? You might as well give up now.
04:03:39 <arkeet> too late.
04:03:42 <typoclass> arkeet: sounds like a lot of work
04:04:00 <arkeet> oh huh.
04:04:07 <arkeet> I guess it just doesn't?
04:04:37 <arkeet> I could have sworn.
04:04:38 <arkeet> :p
04:05:47 <arkeet> what if , was a type operator? :(
04:05:55 <arkeet> instead of special syntax
04:06:10 <arkeet> it could be infixl too
04:06:13 <shachaf> Let's start with making it a value operator
04:06:22 <arkeet> sure, that could be infixr then.
04:06:32 <arkeet> (,) :: a -> b -> a,b
04:06:59 <augur> arkeet: better question: generalize (,) to produce an Vec type of appropriate length in agda!
04:07:00 <shachaf> arkeet: I think there are probably some very limited places where it could be OK to partially apply type synonyms?
04:07:02 <arkeet> maybe I meant both should be infixr.
04:07:03 <augur> can it be done? who knows!
04:07:05 <shachaf> LiberalTypeSynonyms-style
04:07:21 <augur> shachaf: I prefer AnarchistTypeSynonyms, myself
04:07:44 <shachaf> But in general it doesn't make much sense in the context of instance resolution.
04:07:55 <arkeet> indeed.
04:08:03 <miasma> what would you suggest as a solution with haskell if one wants to write a video player and the non-deterministic runtime due to heap allocation and gc causes some issues
04:08:25 <miasma> also the framebuffer sync needs high precision timers
04:09:00 <miasma> is it better to do the task in C ?
04:10:00 <srhb> miasma: Is it really causing that big issues?
04:11:50 <miasma> srhb: not necessarily. and you can mitigate the issues by using async multi-threading
04:12:25 <miasma> srhb: this is just something a guy associated with linux video codecs asked. he wants to rewrite some codecs in haskell
04:12:33 <miasma> just to see how well it performs
04:13:19 <typoclass> miasma: sounds like an excellent project!
04:13:31 <Botje> sounds like a good case for an incremental GC!
04:13:42 <miasma> it's funny how bitrot affects that kind of C code. they noticed some codec routines are now faster in C vs asm cause the C compiler can make use of new simd instructions
04:14:34 <miasma> and in general the codecs were already fast enough in pure c so a pure functional approach might also work just fine
04:16:19 * liyang started an H.264 decoder in Haskell back in 2004 but never got further than a basic bitstream parser. :-/
04:16:52 <miasma> i personally don't like the idea of implementing
04:17:02 <miasma> multimedia codecs on non-deterministic hardware
04:17:08 * arkeet hadn't heard of haskell in 2004.
04:17:43 <miasma> non-deterministic thread scheduling and execution speed causes all sorts of issues and performance problems
04:18:01 <liyang> miasma: do you know this for a fact?
04:18:17 <akamaus> if f and g are applicatives, can we have something like (a -> f a) -> g a -> f g a?
04:18:35 <miasma> liyang: it's a well known fact that e.g. synchronization in very expensive if you have pre-emptive multi-threading and x86 style NUMA
04:18:36 <liyang> akamaus: f g a doesn't make sense.
04:18:51 <arkeet> akahn: you can have g a -> f (g a) regardless of what g is, because that's pure for f
04:18:55 <arkeet> akamaus*
04:19:20 <liyang> miasma: why would you do explicit synchronisation?
04:20:05 <miasma> liyang: any kind of synchronization is expensive in that case. there's no implicit synchronicity given those assumptions
04:20:16 <miasma> e.g. compared to stuff like deterministic DSP programming
04:22:09 <liyang> You can write C (or Asm) in Haskell, sure. I wouldn't recommend it though.
04:22:42 <liyang> :t Data.Traversable.traverse
04:22:44 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
04:22:52 <liyang> akamaus: ^ might be what you want.
04:23:11 <arkeet> :t traverse
04:23:13 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
04:24:34 <arkeet> :t foldMap
04:24:36 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
04:28:09 <liyang> miasma: anyway, I've done a bit (~9 months) of DSP work with H.264, and quite a few years of Haskell, and I don't see why Haskell would not be suited for video codec implementations.
04:30:21 <arkeet> a video codec isn't exactly a realtime application.
04:30:31 <arkeet> if you're actually displaying video, that is a different matter.
04:32:25 <liyang> I mean, I don't think it'd be impossible to implement a codec that performs on par with one written in one of the usual languages if you knew what you were doing with Haskell.
04:32:33 <arkeet> sure.
04:32:55 <Philippa> #lo
04:33:07 <Philippa> liyang: not now we're getting proper SIMD primitives, anyway!
04:33:25 <typoclass> liyang: right, but "know what you're doing" is an advantage in c as well
04:33:57 <Philippa> yeah, but it's not as easy to write "please evaluate this skeletal stuff at compile time" in C
04:34:14 <liyang> You'd have to resort to some low-level optimisation, but no worse than what you'd already do in C &c. And since we can abstract things so much more easily in Haskell, such trickery should be a lot less tedious.
04:35:01 <Philippa> quite. Let's see what happens when lens meets SIMD
04:35:04 <liyang> typoclass: "knowing what your doing" is an advantage in any circumstance. :)
04:35:19 <liyang> KILL ME NOW.
04:35:28 <liyang> *you're. >_<;;
04:36:23 <quchen> liyang: Your punishment is implementing ByteString in PHP within a week.
04:37:41 <liyang> quchen: ByteString is just a ForeignPtr and an Int. Vector with fusion on the other hand…
04:37:52 * hackagebot cabal2nix 1.47 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.47 (PeterSimons)
04:38:06 <quchen> Oh you thought the punishment part was ByteString? ;-D
04:38:57 <arkeet> liyang: well, there are a couple Ints.
04:39:00 <arkeet> offset and length
04:39:12 <liyang> My mistake. ^^;;
04:39:13 <akamaus> liyang, looks so, thanks. Will try
04:39:21 <akamaus> bye
04:39:31 <arkeet> me too bye
04:39:54 <liyang> akamaus: have fun!
04:51:51 <chrisirc> Why are modules like Control.Parallel not in a package containing the name "Control"?
04:52:21 <chrisirc> *And*, unless I missed how, cabal doesn't know how to resolve module names to package names?
04:52:54 <chrisirc> This way it's hopeless guesswork and I tend to end up using Google to resolve module names to package names.
04:53:24 <Heffalump> one difficulty would be that there might be multiple packages. It could tell you what they are and let you choose, though.
04:54:16 <chrisirc> What do you mean? Control.Parallel being in a package called control-parallel would create *less* risk for conflict than when it is in a package called parallel.
04:55:17 <danharaj> http://holumbus.fh-wedel.de/hayoo/hayoo.html
04:55:23 <miasma> liyang: agreed the problem isn't related to decoding the stream, it's more about the timing when displaying stuff. if the decoding is insanely fast there's hardly any issue. the difference in systems programming languages is that you can explicitly control when to allocate. that's even possible in java, to some extent
04:55:29 <chrisirc> CPAN got these things much better >15 years ago.
04:56:33 <bartavelle> am I the only one with troubles about ghc-mod when there are "module haddocks" on top of the file ?
04:56:45 <bartavelle> or perhaps it is the vim integration that is at fault
04:57:14 <connelly> if a module exports a enum type without the "(..)" after the type name, how do I refer to the elements in the type?
04:57:40 <bartavelle> I believe you can't, and that is the point of not exporting them
04:58:06 <danharaj> connelly: You can't.
04:58:32 <connelly> ugh.., but I can convert them to strings and compare the strings? that seems like a nasty hack
04:58:43 <bartavelle> what is this module ?
04:59:08 <connelly> Text.Disassembler.X86Disassembler a.k.a. disassembler
04:59:12 <liyang> miasma: if it's just about displaying the video without jitter… well you can write C in Haskell. Just invoke the same sequence of system calls.
04:59:16 <connelly> I'm looking at the opcodes
04:59:36 <bartavelle> ah this sounds like it sucks
05:00:56 <danharaj> connelly: Why do you want access to the data constructors?
05:01:07 <bartavelle> pattern matching on the opcode
05:01:19 <bartavelle> looks like a very valid use case
05:01:21 <connelly> I want to check if an opcode is in a large set of opcodes
05:02:36 <bartavelle> well, you can still cabal unpack, vi, cabal install --reinstall
05:02:38 <danharaj> connelly: Looks like a defect in the library. I would patch my own local version and notify the maintainer of your difficulty.
05:02:56 <liyang> miasma: I guess the downside is that you have to understand the Haskell RTS, whereas for C it's much easier.
05:03:05 <connelly> ok.. I mean the opcodes likely collide with function names somewhere
05:03:23 <danharaj> That's not really a problem since you can qualify them.
05:03:32 <bartavelle> and they can't collide with a function name
05:03:39 <bartavelle> constructors start with a capital letter
05:03:52 <connelly> but then you have to qualify all of the functions you'd want to use
05:04:08 <danharaj> It is doubtful that there are many conflicts.
05:04:34 <bartavelle> connelly, there is a trick where you import twice a module, once qualified, and once unqualified with hiding
05:04:47 <connelly> ah ok
05:05:09 <bartavelle> I have seen it done the other way around, import Data.Text (Text), import qualified Data.Text as T
05:05:16 <bartavelle> to have nicer type signatures
05:05:36 <miasma> liyang: yep
05:13:17 <liyang> miasma: were I interested in writing a video player where jitter-free playback is critical (and had no time contraints), I'd factor the display component out and implement just that in a low-level language, feeding it a buffered stream of frames.
05:15:31 <chrisirc> Sigh. Where is Control.Concurrent.Async? Google brings up http://hackage.haskell.org/packages/archive/async/2.0.0.0/doc/html/Control-Concurrent-Async.html
05:15:49 <chrisirc> but cabal install async  will install async-1.4 which does not have it.
05:15:55 <chrisirc> Why??.
05:16:07 <liyang> chrisirc: because of reasons.
05:16:28 <liyang> chrisirc: what version of GHC (or Haskell Platform) are you using?
05:16:40 <chrisirc> current master HEAD
05:16:43 <nus> @where hoogle
05:16:43 <lambdabot> http://haskell.org/hoogle
05:16:46 <nus> @where hayoo
05:16:47 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
05:16:49 <chrisirc> as of 2 days ago~
05:17:13 <liyang> chrisirc: either you haven't done cabal update, or that version of async has dependencies that can't be satisfied.
05:17:32 <liyang> chrisirc: why on earth are you running HEAD…?
05:18:19 <chrisirc> Because I need the simd branch.
05:18:55 <chrisirc> ok, running current master head + simd merged in.
05:19:02 <liyang> You don't sound too familiar with the Haskell ecosystem. :-/
05:19:16 <chrisirc> I'm not.
05:20:08 <supki> async has explicit upper bound on base
05:20:12 <chrisirc> cabal install async-2.0.1.4 says "rejecting: base-3.0.3.2, 3.0.3.1 (global constraint requires installed instance)"
05:20:18 <supki> apparently HEAD does not satisfy them
05:20:41 <liyang> chrisirc: I'm curious why you need the simd branch now.
05:20:41 <supki> them as in async >= 2.0
05:21:20 <chrisirc> liyang, I'm trying to do high-performance computing with GHC.
05:21:22 <fryguybob> chrisirc: By the way, you can use hayoo or hoogle to find which packages have which modules.
05:21:38 <chrisirc> ok, trying that, thanks
05:21:40 <liyang> chrisirc: you can get around that issue by doing cabal unpack async (which will unpack the latest one), editing the async.cabal to remove the upper bound on base, then cabal install.
05:21:59 <chrisirc> k, trying that too
05:22:02 <danharaj> and hope the dependency upper bound was not tight.
05:22:10 <chrisirc> yes
05:22:28 <danharaj> Such is life on the razor's HEAD
05:22:29 <shachaf> hayoo is better than Hoogle for package->module search
05:22:40 <shachaf> All the information is available locally, though.
05:22:48 <shachaf> I don't know whether there's a tool for searching it.
05:23:20 <johnw> shachaf: what's an example of package->module search?
05:23:29 <shachaf> Er, I meant module->package earch
05:23:45 <johnw> you mean, searching for a module to find what package it's in?
05:23:48 <shachaf> Yes.
05:23:59 <shachaf> One approach: less ~/.cabal/packages/hackage.haskell.org/00-index.tar , use / to search for your module name
05:24:07 <shachaf> It's a bit ad-hoc but it works.
05:24:13 <liyang> chrisirc: am wondering, is this your own code that needs async?
05:24:38 <chrisirc> liyang, yes
05:26:47 <franco00> let's say I have a function like "a -> SomeTransformerStack b". Is there a way to make this "a -> SomeTransformerStack (IO b)" ? (or generally, to add "things to the bottom of the stack")?
05:26:53 <shachaf> If you're going to be using HEAD, you should "know what you're doing".
05:26:55 <shachaf> Well, you don't have to, but you can expect things not to be compatible/working. :-)
05:27:33 <shachaf> franco00: Does the "a ->" have anything to do with it?
05:27:40 <shachaf> What is SomeTransformerStack here?
05:27:55 <fryguybob> Using HEAD is full of wonderful learning opportunities.
05:28:06 <chrisirc> Yeah, fair enough. Still I'm surprised by a number of things that I expected would be present to make the experience easier.
05:28:10 <franco00> shachaf: is ErrWriMonad { runErrWriM :: EitherT HexError (Writer Log) a }
05:28:21 <chrisirc> Will see how it's going on.
05:29:21 <franco00> I find myself writing stacks, but then I am clumsy using them in the IO monad
05:30:14 <liyang> franco00: if you write e.g. TransformerStack t = ReaderT R (StateT S t), sure.
05:31:16 <liyang> Then 'TransformerStack Identity a' would be a pure action returning 'a', while 'TransformerStack IO a' would let you do IO.
05:31:58 <franco00> mhhh and I could use, say, liftIO to access it, right?
05:32:06 <franco00> (access that layer)
05:32:13 <srhb> Yes.
05:32:33 <franco00> thanks. That's pretty handy to know.
05:32:42 <liyang> Yes. And had you been working in the TransformerStack Identity monad, that'd be a type error.
05:33:29 <beaky> hello
05:33:37 <franco00> of course, of course. Thanks again! (I am trying to write some stacks and do stuff with them just in case)
05:33:41 <beaky> does haskell have dtors like C++?
05:35:09 <dmwit> "dtors" = "destructors"?
05:35:10 <liyang> beaky: we have Control.Exception.bracket! (I love brackets. They're so easy.)
05:35:19 <beaky> ah
05:35:23 <dmwit> There are ForeignPointers, which can have garbage collection actions associated with them.
05:35:48 <beaky> :t bracket
05:35:49 <lambdabot>     Not in scope: `bracket'
05:35:49 <lambdabot>     Perhaps you meant one of these:
05:35:49 <lambdabot>       `brackets' (imported from Text.PrettyPrint.HughesPJ),
05:35:58 <dmwit> :t Control.Exception.bracket
05:35:59 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:03:11 <Dodek> hey
06:03:14 <Dodek> liftM (takeWhile (/= "haskell")) . sequence . repeat $ getLine
06:03:18 <Dodek> why isn't it lazy?
06:03:32 <franco00> liftM
06:03:45 <shachaf> franco00: ?
06:03:46 <Dodek> but why?
06:04:11 <shachaf> Dodek: Because sequence (repeat getLine) :: IO [a] will try to run an infinite number of times before returning the list
06:04:19 <franco00> shachaf: sorry, was thinking out lout
06:04:40 <shachaf> @src sequence
06:04:41 <lambdabot> sequence []     = return []
06:04:41 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:04:41 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
06:04:58 <shachaf> That won't yield any results until it runs all the actions.
06:06:38 <Dodek> shachaf: ah, i get it.
06:06:57 <Dodek> is there any change i could make to make it work?
06:07:13 <shachaf> You could use a function whose name starts with unsafe
06:07:19 <Radish> :t any
06:07:21 <lambdabot> (a -> Bool) -> [a] -> Bool
06:07:21 <Lethalman> Dodek, use do notation
06:07:33 <Lethalman> don't sequence
06:07:35 <shachaf> Lethalman: ?
06:07:46 <Lethalman> shachaf, ?
06:07:47 <shachaf> Dodek is asking for a reasonable thing, and there's no really good answer to it, sadly.
06:07:54 * hackagebot esqueleto 1.0.5 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.0.5 (FelipeLessa)
06:07:56 <shachaf> Lethalman: What does do notation have to do with anything?
06:08:23 <Dodek> shachaf: ah, so it's like with unsafePerformIO inside getContents
06:08:26 <Lethalman> shachaf, he can do a recursion of getLine plus checking if it's "haskell" without doing sequence
06:08:28 <shachaf> The annoying part is that you have to write the recursion out yourself rather than composing it from functions like takeWhile.
06:08:32 <shachaf> Dodek: unsafeInterleaveIO, but yes.
06:08:45 <Dodek> Lethalman: i obviously know how to write it using recursion.
06:08:59 <Lethalman> Dodek, well you asked how to make it work :P
06:09:15 <shachaf> Lethalman: That has nothing to do with do notation, though.
06:09:30 <Lethalman> shachaf, yes yes sure
06:13:36 <chrisirc> When installing ghc from source, it says in the README.md to do "make install"; but that didn't seem to install the vector package, why? What do I need to do for that?
06:13:47 <franco00> liyang: sorry to bother you again. But now that I have MyStack a = (some stack here), fa :: Int -> Stack Int, what is the function to "promote it to " fb :: Int -> Stack (IO Int)
06:14:02 <chrisirc> ghc/libraries/vector$ runhaskell Setup configure --user; runhaskell Setup install  ->  dependencies are missing: primitive >=0.4.0.1 && <0.5
06:14:29 <chrisirc> so, do I need to go through all of the sub-repositories and install them in the right order or what?
06:14:58 <`ramses> franco00: MyStack has already fixed the base monad at the bottom, hasn't it?
06:15:09 <liyang> franco00: could you hpaste.org?
06:15:19 <franco00> ok ok, just one sec
06:16:23 <franco00> yes, `ramses , base monad is fixed
06:17:41 <`ramses> franco00: wait, I may have read your code wrong, you use both MyStack and Stack?
06:18:27 <franco00> no, I just miswrote `ramses . Both should be MyStack
06:19:38 <`ramses> franco00: then I'm not sure "MyStack (IO a)" makes much sense, monads don't compose, that's the point of transformers
06:19:51 <quicksilver> franco00: I doubt MyStack (IO Int) is ever what you want.
06:19:55 <ExternalReality> Does anyone know if it is safe to call unsafeIOToSTM $ deRefWeak myPointer
06:20:08 <quicksilver> if you want to sometimes have IO at the bottom then you want to write MyStack as a transformer
06:20:15 <quicksilver> and then it would be MyStackT IO Int
06:20:18 <quicksilver> (no parens)
06:20:20 <liyang> franco00: it's not MyStack (IO a), it's MyStackT IO a, assuming you defined MyStackT correctly.
06:20:37 <franco00> there, liyang and `ramses
06:20:40 <franco00> http://hpaste.org/83671
06:20:47 <franco00> oh
06:20:48 <shachaf> ExternalReality: Probably not?
06:20:51 <chrisdone> hey ma, check this out: http://ircbrowse.net/browse/freenode/haskell
06:20:52 <shachaf> What does "safe" mean here?
06:20:52 <fryguybob> ExternalReality: I can try to find out.  I don't know anything about deRefWeak
06:20:55 <franco00> what do I want, then?
06:21:19 <danharaj> ExternalReality: It depends on what you mean by safe.
06:21:39 <franco00> ohh I see, I should make MyStackT an instance of Transformer and then apply it to the IO monad, right?
06:21:39 <danharaj> ExternalReality: If a transaction is retried several times, a Weak might become dead in between retries.
06:21:53 <`ramses> franco00: use WriterT to have ErrWriMonad be a transformer, I think
06:22:46 <franco00> `ramses: I appreciate, but what if I have to apply replaceCols to a non monadic value?
06:22:57 <amyers> chrisdone: saw that on G+ this morning, really responsive!
06:23:18 <franco00> a answer could be :  "don't  be silly and think about your stack in advance", really
06:23:48 <danharaj> ExternalReality: I would be very wary of using Weak by the way. The semantics of your program can change with -O levels.
06:24:07 <ExternalReality> The docs do say that inside of a transaction you have this inconsistent view of memory so I would want to deref a weak pointer and be told "yes" when the answer is really "no"
06:24:16 <`ramses> franco00: then use Identity as the bottom? I'm not entirely sure what your goal is exactly though
06:24:25 <ExternalReality> :danharaj thanks for the heads up I didn't know that
06:24:32 <danharaj> ExternalReality: In a multithreaded environment, that is bound to happen.
06:24:37 <fryguybob> ExternalReality: You do not have an inconsistent view in that regard.
06:24:47 <danharaj> oh, is that true?
06:25:14 <fryguybob> In general it is only inconsistent with respect to TVars.
06:25:55 <fryguybob> (which inside STM is all you really have access to anyway).
06:27:06 <franco00> `ramses: do you know when you have a nice pure function and you want to use it in monadic code? You probably will use liftM, and that's it. Now I have a monad stack, and I would like to be able to use it in IO monad.
06:27:44 <franco00> (it seems the solution is: make it a transformer and apply it to the IO monad, or to the identity monad if needed)
06:29:17 <fryguybob> ExternalReality: I don't see any reason that  deRefWeak  would cause a problem directly.  It doesn't appear to have any side-effects, it is just non-deterministic.
06:30:42 <franco00> am I wrong, `ramses ?
06:31:14 <hpaste> liyang annotated “monad stack” with “monad stack (for franco00)” at http://hpaste.org/83671#a83672
06:31:59 <chrisdone> amyers: \o/
06:32:37 <franco00> I. Get. It. Now. Thanks liyang. Never got what that Identity monad was there for
06:32:54 * hackagebot grid 4.0 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-4.0 (AmyDeBuitleir)
06:33:02 <`ramses> I was writing up something similar :)
06:33:24 <liyang> `ramses: I won!
06:33:30 <franco00> well, viva la identidad!
06:33:40 <`ramses> liyang: I was fighting with the MonadTrans instance :)
06:34:55 <liyang> franco00: glad to have been of help. Viva la identidad!
06:35:13 <iwanttolearntoco> Hi guys, I want to make a RAT, Remote Administration Tool, in Haskell. Is this possible?
06:36:08 <chrisdone> iwanttolearntoco: sure
06:36:17 <chrisdone> depends on the os, of course
06:36:22 <Radish> whats a good habit for naming booleans?
06:36:28 <Hafydd> @faq Can Haskell create a RAT?
06:36:28 <lambdabot> The answer is: Yes! Haskell can do that.
06:36:41 <iwanttolearntoco> Is Haskell compatible in OS/Linux. Windows would be the default.
06:36:44 <Radish> I need to name a boolean "fullsize" or "not fullsize"
06:36:54 <Radish> isFullSize?
06:37:01 <chrisdone> Radish: isX doY, etc. but another option is data Size = FullSize | OtherSize
06:37:39 <Radish> chrisdone: thanks, I might just name it that.
06:37:50 <chrisdone> often encoding booleans as proper types with constructors clarifies things in the long run, and can handle extension to ternary and so on cases
06:39:19 <Hail_Spacecake> I'm looking at the code for the haskell opengl bindings
06:39:49 <Hail_Spacecake> and it looks like a lot of source files import from the package namespace Graphics.Rendering.OpenGL.Raw.*
06:39:55 <Hail_Spacecake> ex https://github.com/haskell-opengl/OpenGL/blob/master/Graphics/Rendering/OpenGL/GL/BlendingFactor.hs
06:40:07 <Hail_Spacecake> but I can't figure out where that OpenGL.Raw package data comes from
06:40:37 <amyers> iwanttolearn: ghc is compatible with Windows but I've never used it there.  I think most libraries are developed on Linux and are not always tested on Windows
06:41:23 <chrisdone> Hail_Spacecake: comes from OpenGLRaw. check the .cabal
06:41:37 <hpaste> idntfy revised “Tridiagonal matrix algorithm”: “Tridiagonal matrix algorithm” at http://hpaste.org/83540
06:48:18 <`ramses> what's the difference between ErrorT and EitherT? I can't seem to find an explanation
06:48:48 <srhb> Mostly the name i think.
06:48:57 <shachaf> ErrorT is evil
06:49:10 <`ramses> it is? how come?
06:49:12 <shachaf> Look at its instance: (Monad m, Error e) => Monad (ErrorT e m)
06:49:22 <shachaf> EitherT's instance: Monad m => Monad (EitherT e m)
06:49:49 <`ramses> ah, so the only difference is the extra constraint?
06:49:52 <shachaf> ErrorT tries to do clever things with the error type. It shouldn't. EitherT works for any type.
06:50:00 <shachaf> "the only difference"
06:50:19 <`ramses> ok, and all implied consequences :)
06:50:27 <shachaf> The only difference between (id :: a -> a) and ((\x -> x * 100 + 5) :: Num a => a -> a) is the constraint!
06:51:14 <shachaf> Just look at the class Error:
06:51:15 <shachaf> @src Error
06:51:16 <lambdabot> class Error a where
06:51:16 <lambdabot>     noMsg  :: a
06:51:16 <lambdabot>     strMsg :: String -> a
06:52:28 <`ramses> it seems EitherT is not in the standard transformer packages though
06:52:49 <shachaf> That is correct, for the moment.
06:52:55 <shachaf> @hackage either has it
06:52:55 <lambdabot> http://hackage.haskell.org/package/either has it
06:53:14 <`ramses> ah, ok, I see multiple packages on hackage with an implementation
06:54:01 <shachaf> But you should just use either.
06:54:37 <`ramses> ok, thanks :)
07:03:14 <Philippa> re
07:03:20 <Philippa> I'm on the train! Yet again!
07:03:37 <Taneb> Where to/from?
07:03:46 <Philippa> nottingham to brum this time
07:04:08 <Philippa> and at least I've done all my being rude to judges for the day
07:04:27 <Philippa> ...heh, crap, forgot the other device is in range of my hotspot too :-) That's embarrassing!
07:05:55 <Philippa> so yeah. I guess I should try to be helpful to others until edwardk's in a position to tell me my entire current project's the Wrong Thing
07:06:49 <amyers> Philippa: What's your current project?
07:07:02 <saep> 7quit
07:07:33 <Kinnison> saep: finnish?
07:08:29 <shachaf> Half the channel is Finnish.
07:09:02 <ion> I like Finnish. It is so easy.
07:09:05 <Kinnison> :-)
07:09:26 <strebe> ion: it's lovely, but not easy
07:09:27 <shachaf> I love ion. He is so predictable.
07:09:42 <shachaf> strebe: Come on, even 3-year-olds can speak Finnish.
07:09:45 <shachaf> How hard could it be?
07:09:51 <arcatan> Finnish has been mentioned!
07:10:20 <shachaf> Younger people can also speak it, I assume. But I'm not sure I have personal experience with that.
07:10:22 * srhb flees
07:11:32 <shachaf> srhb: Danish is completely incomprehensible, I understand.
07:12:13 <strebe> shachaf: 3 year olds can speak it like three year olds
07:12:20 <srhb> shachaf: Even amongst danes, yes.
07:18:49 <jfischoff> Is there a way, perhaps using a GHC plugin that use a unboxed vector in a fast way
07:19:07 <jfischoff> instead of having it round trip through list?
07:26:16 <Sculptor> hi!
07:27:43 <saml> hi Sculptor
07:27:49 <saml> welcome to internet
07:27:57 <Sculptor> i thank you
07:33:10 <Philippa> amyers: so the real project is about (typed) constraint programming, but I got bogged down in (meta)syntax considerations
07:33:33 <Philippa> agundry: if you're around, this is probably your cue to smirk :-)
07:33:56 <chrisdone> Philippa: all the yaks must be shaved!
07:34:25 <Philippa> chrisdone: the entire damn yaktal, yeah
07:34:47 <Philippa> btw, did you read the Newsflesh prequel as well?
07:35:13 <chrisdone> i didn't, would you recommend it?
07:35:14 <Philippa> ("the" - Countdown rather than Last Stand of the Browncoats)
07:35:34 <chrisdone> i read feed, countdown and blackout
07:35:47 <Philippa> I... would be interested to hear what you make of it? I recommend it *more* if you're not just taking a direct reading, and if "when will you rise?" punches you right in the gut
07:37:31 <chrisdone> i'll grab it =)
07:37:47 <Philippa> (if "when will you rise?" *doesn't* punch you in the gut, you have no sense for puns...)
07:37:56 <Philippa> (...especially given the /whole/ trilogy)
07:38:18 <Philippa> cool :-)
07:39:08 <chrisdone> the only pun that occured to me with that was the zombie rising metaphor for the general public basically being dead and needing to rise. if there was other punnage, what am i missing? :p
07:39:48 <Philippa> more the web of implications around that
07:39:49 <statusfailed> are these available in ebook format?
07:39:53 <Philippa> but *spoiler*
07:39:56 <statusfailed> sorry to butt in :)
07:39:58 <Philippa> statusfailed: yeah, I got 'em on Amazon
07:40:03 <chrisdone> NO SPOILERS I COMMAND THEE!
07:40:06 <Philippa> (for Kindle)
07:40:37 <chrisdone> i accidentally read a spoiler about shaun somewhere and ruined a big reveal =p
07:40:51 <Philippa> ouch
07:41:05 <osfameron> shaun of the dead?
07:42:25 <chrisdone> osfameron: there's a character in newsflesh named shaun
07:42:51 * osfameron googles newsflesh
07:42:59 <blackorchid> hi there, need some newbie help getting started with a module in ghci
07:45:00 <blackorchid> more specifically, i want to build a simple interval map to verify its interval search, because in my own implementation of this structure i have a strange corner case, and i would like to see the search results using http://hackage.haskell.org/packages/archive/fingertree/0.0.1.0/doc/html/Data-IntervalMap-FingerTree.html
07:45:43 <blackorchid> i have run `cabal install fingertree` and now I entered the REPL with ghci. A naive ":module + fingertree" doesn't work
07:46:41 <Hafydd> blackorchid: module names are capitalised.
07:47:16 <blackorchid> ah alright. yes, now i got it `:module +Data.IntervalMap.FingerTree` seems fine. thanks, will try out further things now
07:49:39 <ski> blackorchid : `:module' can be abbreviated as `:m'
07:55:55 <amyers> Is there any difference between :m +Module and import Module in ghci?
07:56:02 <amyers> aside from saving a few characters
07:56:30 <shachaf> I think there is not.
07:56:44 <shachaf> However, "import Module" lets you use qualified/hiding/parentheses.
07:56:51 <shachaf> ":m + Module" lets you specify multiple modules.
07:56:59 <shachaf> (But you probably knew that already.)
07:57:42 <amyers> I did not, that's good to know
07:58:08 <jfischoff> shachaf: can you use import's in the .ghci file?
07:58:11 <amyers> I usually import qualified though, or the prompt gets way to long
07:58:25 <jfischoff> :set prompt >
07:58:29 <`ramses> jfischoff: you can
07:58:31 <shachaf> jfischoff: Yes.
07:58:36 <jfischoff> cool
07:58:58 <jfischoff> even better :set prompt λ>
07:59:17 <amyers> cool, I think I used that once and then forgot about it
07:59:30 <jfischoff> story of my life :)
07:59:34 <shachaf> Even better: :set prompt "λ> "
07:59:38 <shachaf> That way you get a space.
07:59:45 <jfischoff> ooh
08:00:19 <jfischoff> I almost copied your prompt correctly ;)
08:02:30 <jfischoff> So it seems the Traversable and Foldable are at odds with fast arrays
08:02:59 <amyers> How so?
08:04:08 <jfischoff> well you want your arrays to be unboxed primitives in a contiguous array of memory
08:04:40 <jfischoff> and that is difficult because for one the polymorphism implies boxing
08:05:20 <shachaf> Yes. However, Traversal and Fold from lens are generalizations that allow monomorphism.
08:05:36 <shachaf> So there are Traversals for ByteString and Text, for example.
08:06:04 <jfischoff> right so maybe ad needs to be updated to include a data structure and its traversal
08:06:27 <jfischoff> so I can pass an storable vector in
08:06:34 <jfischoff> I don't
08:07:06 <jfischoff> know it seems like I would rather the compiler could just choose a better representation for me
08:07:16 <jfischoff> but perhaps that is impossible
08:10:36 <ski> amyers : `:m + *Module' makes even unexported things in scope (given source files), while `import' doesn't
08:10:59 <amyers> ski: ah, didn't know that
08:11:20 <amyers> so it behaves like load if the module has source?
08:11:49 <amyers> Or is it actually a :load and checks for a source file in the current directory?
08:11:57 <amyers> So if I :m +Data.Foo
08:12:09 <amyers> Does it look for Data/Foo.hs?
08:12:24 <amyers> and :load it if it exists?
08:12:56 * hackagebot stylish-haskell 0.5.6.1 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.6.1 (JasperVanDerJeugt)
08:13:52 <ski> amyers : "2.4.5.1. :module and :load" <http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#id484445>
08:14:10 <ski> amyers : no, `:m' doesn't load
08:14:18 <ski> it only controls what's in scope
08:14:46 <amyers> I see
08:14:51 <amyers> Thanks
08:22:57 * hackagebot blaze-markup 0.5.1.5 - A blazingly fast markup combinator library for Haskell  http://hackage.haskell.org/package/blaze-markup-0.5.1.5 (JasperVanDerJeugt)
08:27:57 * hackagebot blaze-html 0.6.1.1 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.6.1.1 (JasperVanDerJeugt)
08:43:42 <`ramses> why is the Profunctor instance for (->) in Data.Profunctor.Unsafe? Is it unsafe then?
08:43:54 <hpaste> David pasted “Pattern Matching” at http://hpaste.org/83678
08:44:12 <shachaf> `ramses: The instance is reëxported from Data.Profunctor, of course.
08:44:24 <shachaf> It has to be defined in that module so as not to be orphan.
08:44:40 <`ramses> shachaf: I know, just wondering whether there was something unsafe about it, because of where the definition actually comes from
08:44:53 <indomitus> why does this throw an overlap? http://hpaste.org/83678
08:45:24 <`ramses> shachaf: ah, right, that makes sense
08:45:41 <shachaf> `ramses: The instance *also* uses an unsafe function.
08:45:58 <shachaf> Which you can figure out by looking at the source. :-)
08:46:34 <`ramses> maybe that should've been my first reaction, indeed
08:47:58 <liyang> `ramses: the .Unsafe gives you .# and #. , which the `safe' version hides from you.
08:48:32 <`ramses> shachaf: the unsafeCoerce is purely for performance reasons to get rid of "newtype unpacking", right?
08:48:47 <liyang> `ramses: something like that.
08:48:49 <shachaf> `ramses: To get rid of eta-expansion, actually, but yes.
08:49:33 <`ramses> eta-expansion? could you elaborate?
08:49:48 <shachaf> Newtypes constructors get optimized into id
08:50:01 <shachaf> So (Foo . f) get optimized into (id . f)
08:50:08 <shachaf> But (id . f) isn't the same as (f).
08:50:23 <kqr> indomitus, i would guess because the type of the two last arguments are always IntVal a
08:51:01 * `ramses thinks hard about how they can differ
08:51:58 <shachaf> `ramses: In particular, (id . f) is (\x -> f x)
08:52:07 <shachaf> And that's not the same as f, because of `seq`.
08:52:52 <`ramses> ok, but when is that a problem?
08:53:30 <shachaf> Well, it means you get an extra function.
08:53:34 <shachaf> Which does pretty much nothing.
08:54:40 <amyers> shachaf: Will that also change how far `seq` forces a thunk?
08:54:59 <shachaf> ?
08:55:02 <amyers> or not since both would get forced to the same constructor
08:55:07 <amyers> ?
08:55:12 <amyers> nvm, stupid question :p
08:55:19 <shachaf> I don't understand the question.
08:55:22 <`ramses> ah, right, and the compiler cannot eliminate that because of the difference in semantics with regard to seq and bottom
08:55:23 <indomitus> kqr: those IntVals could technically be BoolVals so I want a case where the operator doesn't match, but the operands do and another case for when nothing matches
08:55:29 <shachaf> There is no constructor (well, no newtype constructor) involved.
08:55:32 <kqr> amyers, i guess seq will evaluate the "outer" function and leave the inner thunk intact
08:55:36 <kqr> amyers, but i could be wrong
08:55:39 <shachaf> > (\x -> undefined x) `seq` ()
08:55:40 <kallisti> what would be the most sensible way to go about hotswapping Haskell code?
08:55:41 <lambdabot>   ()
08:55:42 <amyers> That's what i was wondering
08:55:44 <shachaf> > undefined `seq` ()
08:55:46 <lambdabot>   *Exception: Prelude.undefined
08:56:01 <shachaf> I think in the next version of GHC these will become irrelevant.
08:56:27 <amyers> shachaf: Thanks, that's exactly what I was trying to ask
08:56:39 <amyers> but I don't know the terms all that well
08:56:50 <kqr> indomitus, that's odd. what is the type of the function?
08:58:15 <hpaste> David revised “Pattern Matching”: “Pattern Matching” at http://hpaste.org/83678
08:58:41 <`ramses> shachaf: ah, so the compiler will eliminate the extra lambda then?
08:58:47 <indomitus> kqr i edited the paste to include that
08:59:13 <shachaf> `ramses: Well, it will if it knows that f is not ⊥.
08:59:33 <`ramses> what's "?"?
08:59:39 <amyers> kqr: isn't it because '_' also matches '(Intval l)' ?
08:59:41 <`ramses> some kind?
08:59:43 <armlesshobo> f and upside-down T are two separate letters
09:00:17 <shachaf> `ramses: It's _|_
09:00:26 <shachaf> Get an IRC client that works with Unicode!
09:00:33 <indomitus> a myers, do you mean in line 11 or 12?
09:00:42 <`ramses> shachaf: that used to work! strange..
09:01:32 <indomitus> * amyers, do you mean in line 11 or 12?
09:01:37 <amyers> indomitus: Never mind, was thinking something else.
09:01:49 <indomitus> ohh ok
09:01:51 <`ramses> shachaf: so I guess GHC will try to deduce non-bottomness then, but will probably be forced to be rather conservative
09:02:49 <shachaf> `ramses: Well, it means you can write: foo !f = ... (NewtypeConstructor . f)
09:02:52 <nwf> oin #haskell-lens
09:03:02 <edwardk> heya
09:03:18 <supki> indomitus: line 11 is redundant
09:03:20 <shachaf> #haskell is pretty much #haskell-lens right now.
09:03:29 <teb_> Hey, has anyone here tried to implement context-sensitive autocomplete using Parsec?
09:04:35 <`ramses> shachaf: okay, that makes sense :)
09:04:35 <edwardk> i have, but with trifecta, not parsec
09:04:55 <edwardk> ou need more access to the guts of the parser than parsec gives
09:04:59 <indomitus> supki, but isn't it more specific than 12?
09:05:05 <edwardk> well, you could probably still do it
09:05:20 <teb_> edwardk: I was starting to reach the same conclusion
09:05:23 <supki> indomitus: yes
09:05:23 <indomitus> supki, does pattern matching only work on the first argument?
09:05:34 <supki> indomitus: ? no
09:06:03 <supki> indomitus: you already matched all possible operator cases in lines 1-10, so line 11 can match nothing
09:06:16 <kqr> indomitus, yeah, it's what supki says
09:06:30 <kqr> indomitus, there is no Op that you haven't already matched against
09:06:31 <edwardk> in my case i was exposing an 'completion' hook, that you could wrap a sub-parser in, then when a parse ends, i take into account all the currently 'open' completion hooks, and collect all their answers.
09:06:51 <kqr> indomitus, Bop*
09:07:08 <kqr> indomitus, you match against all possible Bops on lines 2–10
09:07:17 <kqr> indomitus, so line 11 will not match against anything you haven't already matched against
09:07:42 <teb_> edwardk: that's pretty much exactly what I'm looking for
09:08:16 <indomitus> kqr, supki, i get that, but suppose i were to use the function & not pass a valid Bop but do pass 2 valid IntVals, the error message would read different without line 11 right?
09:08:30 <kallisti> "Note: in GHC, if you have a ThreadId, you essentially have a pointer to the thread itself. This means the thread itself can't be garbage collected until you drop the ThreadId. This misfeature will hopefully be corrected at a later date."
09:08:34 <kallisti> is there a workaround for this?
09:08:36 <kqr> indomitus, you can't pass an invalid Bop
09:08:44 <kqr> indomitus, since the type system will stop you from even creating it
09:09:43 <kqr> indomitus, you can only create either Plus, Minus, Times Divide, etc. down to Le
09:09:50 <kqr> indomitus, if you try something else the type system will stop you
09:10:51 <indomitus> kqr, oooooo duh! ok so then the only thing that would make sense (/make it through the type system) other than "_ _ _" would be BoolVal second and third arguments
09:11:12 <kqr> indomitus, yeah sure
09:12:12 <indomitus> but since none of them take BoolVals, i can use _ as the first argument too. thanks!
09:13:42 <kallisti> ah looks like base 4.6 has a mkWeakThreadId
09:13:44 <kallisti> that will be useful
09:14:01 <kallisti> I need to manage threads but I don't want the reference to the ThreadId to prevent garbage collection
09:16:34 <kallisti> the difficult part is getting my system to install the latest version of base
09:17:02 <kallisti> that requires a GHC upgrade yeah?
09:17:41 <geekosaur> yes
09:18:58 <Hannibal_Smith> Hi
09:22:19 <kqr> hello
09:23:32 <kallisti> actually
09:23:59 <kallisti> I might be able to use forkFinally. A reference to the ThreadId doesn't prevent the thread from "terminating" it just prevents garbage collection
09:24:24 <kallisti> so a finalizer passed to forkFinally can remove specific ThreadId references that I use when managing threads
09:24:44 <Hannibal_Smith> Someone can examplain me how pipeling/function composion works? I don't understand why this dont work: functionb . functionA parameterA
09:24:58 <kallisti> operator precedence
09:25:09 <kqr> Hannibal_Smith, (functionb . functionA) parameterA
09:25:10 <kallisti> function application binds more tighly than operators
09:25:11 <kqr> Hannibal_Smith, works
09:25:17 <kallisti> you mean what kqr said
09:25:20 <Hannibal_Smith> Thank you
09:25:21 <kallisti> but what you're actually writing is
09:25:27 <kallisti> functionb . (functionA parameterA)
09:25:33 <kallisti> which is not what you want
09:26:14 <Hannibal_Smith> I simply want to pileline the result of functionA parameterA to functionb
09:26:47 <kallisti> yes, so that's (fB . fA) pA
09:26:52 <Hannibal_Smith> Ok
09:26:56 <kallisti> or fB (fA pA)
09:27:48 <Hannibal_Smith> Another question, can I refactor this
09:27:52 <Hannibal_Smith> values = (pEmail person, pNickname person, (globalGroupToInt . pGlobalGroup) person) <-
09:28:01 <Hannibal_Smith> Moving person outside?
09:28:57 <Hannibal_Smith> Uhm...applicative functions?
09:30:43 <kqr> @pl \person -> (pEmail person, pNickname person, (globalGroupToInt . pGlobalGroup) person)
09:30:43 <lambdabot> ap (liftM2 (,,) pEmail pNickname) (globalGroupToInt . pGlobalGroup)
09:30:52 <kqr> that's not nearly as nice as I had hoped
09:30:57 <kqr> maybe you can write it more neatly
09:32:10 <Hannibal_Smith> That's better than nothing, thank you
09:32:32 <Hannibal_Smith> For now I have only basic understanding of the language/its patterns
09:32:53 <Hannibal_Smith> So it's good enought
09:32:59 <supki> > (succ, pred, const 0) & each %~ ($ 7)
09:33:01 <lambdabot>   (8,6,0)
09:33:03 <kqr> i think i'll always only have a basic understanding
09:33:13 <kqr> there's so much to learn
09:33:31 <kqr> Hannibal_Smith, supkis version is much nicer
09:33:36 <kqr> i should learn lenses...
09:35:36 <Hannibal_Smith> What I dont realy like, its the database ecosystem, maybe because I dont understand the language patterns
09:35:49 <Hannibal_Smith> What do you use in this channel for passing code?
09:36:06 <shachaf> @paste
09:36:06 <lambdabot> Haskell pastebin: http://hpaste.org/
09:36:14 <Hannibal_Smith> Ok
09:36:50 <hpaste> “Anonymous Coward” pasted “Testing insert with postgresql-simple” at http://hpaste.org/83681
09:37:23 <Hannibal_Smith> Was the code I was "hacking"
09:37:54 <Hannibal_Smith> Compared to .Net for example it's already pretty good
09:40:16 <Hannibal_Smith> I dont realy like library like HaskellDB or persistent
09:41:37 <Hannibal_Smith> For me its more naturale define my own data types, and than map manualy to sql
09:42:14 <Hannibal_Smith> *natural
09:43:56 <hpaste> “Anonymous Coward” pasted “Mapping SQL to data” at http://hpaste.org/83682
09:44:53 <Hannibal_Smith> http://hpaste.org/83682 <-Works for simple data types...but I dont thking this works with complex sql relations
09:46:47 <Hannibal_Smith> persistent works with complex data...but uses template meta programming
09:47:12 <Hannibal_Smith> I want to write my data types without persistent doing it for me
09:49:14 <Hannibal_Smith> Ahahaha I'm a novice of this language and programming style, but I already want to change how library like postgresql-simple works
09:49:39 <Hannibal_Smith> Someone here has worked with complex sql tables with Haskell?
09:50:19 <Hannibal_Smith> Whithout using template metaprogramming
09:50:26 <Hannibal_Smith> *whitout
09:51:17 <Hannibal_Smith> *without, sorry
09:56:55 <Hannibal_Smith> Honestly I dont think that the pattern used in postgresql-simple its good
09:57:57 <ncs> i have a file which in every line it contains something of type A. I have written a parser for this type A. How can I read this file such that I end up with a [A] where every line is an element in the list?
09:58:55 <kqr> ncs, aList <- lines <$> readFile "yourfile.txt"
09:58:58 <kqr> ncs, something like that perhaps?
09:59:04 <ParahSailin> whats the difference between Text.ParserCombinators.Parsec and Text.Parsec
09:59:34 <kqr> ncs, whoops.
09:59:37 <ion> The former is just a deprecated alias for the latter.
10:01:12 <ncs> kqr ????
10:02:12 <kqr> ncs, aList <- yourparser . lines <$> readFile "yourfile.txt"
10:02:37 <kqr> ncs, aList <- map yourparser . lines <$> readFile "yourfile.txt"
10:02:38 <kqr> ncs, even
10:02:46 <kqr> ncs, i shouldn't be manually copy pasting code
10:03:12 <kqr> ncs, anyway, readFile reads an entire file, lines splits a string intoa list of lines, and map yourparser will parse each line
10:03:53 <smarter> how do I generate n _distinct_ random numbers in the interval [a, b] ?
10:03:54 <ncs> ok,i'll play with it a bit! thanks
10:06:28 <kqr> ncs, http://hpaste.org/83683
10:06:37 <kqr> ncs, that's an example program which reads from stdin instead of a file
10:06:45 <kqr> ncs, and naturally doesn't have your parser in it, but uses read instead
10:08:28 <ncs> kqr, what you suggest now has type  :: IO [IO ()] instead of [A]..
10:09:04 <kqr> ncs, it shouldn't
10:09:27 <ncs> kqr, so the problem lies in my parser (or how i run it) ?
10:09:36 <kqr> smarter, what i would do is I would generate an infinite list of random numbers
10:09:50 <kqr> smarter, pull it through nub and then take the n first ones
10:09:53 <smarter> tried that, but it doesn't seem to play nice with the IO monad
10:10:30 <smarter> fmap (take 4 . nub) $ sequence $ repeat $ randomRIO (0, 10)
10:10:37 <smarter> never returns
10:10:38 <Saizan> don't use the IO version
10:10:48 <Saizan> split a generator and use the pure one
10:11:38 <Saizan> the other option is to write a specific look in the IO monad
10:12:02 <Saizan> something like replicateM but checking unicity
10:15:02 <kqr> smarter, http://hpaste.org/83685
10:15:05 <kqr> smarter, that's what i'd do
10:15:18 <kqr> smarter, or something like it at least
10:15:27 <kqr> smarter, i'm not very well versed with the pitfalls of the standard generator
10:15:53 <joeyh> can anyone think of a valid reason for matchRegex (mkRegex "^.*$") "" to return Nothing?
10:18:06 <kqr> smarter, and perhaps you want to check my math in the conditional...
10:19:20 <kqr> smarter, http://hpaste.org/83685
10:19:23 <kqr> smarter, that's a little more compact
10:19:44 <smarter> thanks, that seems to work fine :)
10:23:00 * hackagebot reverse-apply 1.0.1 - Standard version of the reverse apply operator.  http://hackage.haskell.org/package/reverse-apply-1.0.1 (HansHoglund)
10:23:29 <ion> I thought it was in lens. :-P
10:23:39 <kqr> ncs, what is the type of `map yourparser . lines <$> readFile "yourfile"'?
10:24:34 <ion> “Category: Music” ಠ_ಠ
10:24:35 * Lethalman feels that in that case parenthesis help in understanding operator precedence :S
10:24:57 <Lethalman> I always do it wrong with . <$> <*> ecc.
10:25:00 <Lethalman> I only get right $ :P
10:25:26 <kqr> i always just write what seems to make sense in my head
10:25:31 <kqr> and it happens to work
10:31:27 <kqr> smarter, you probably want newStdGen instead of getStdGen
10:31:49 <kqr> smarter, since getStdGen doesn't update the generator, i.e. the sequence will be the same all the time
10:32:30 <kqr> smarter, (you should probably /really/ use getStdRandom or something, but I don't know how that works with randomRs so eh.)
10:32:43 <smarter> I'll look into it
10:37:13 <fragamus> withSocketsDo gagMe
10:42:08 <fragamus> :t withSocketsDo
10:42:09 <lambdabot> Not in scope: `withSocketsDo'
10:53:15 <megajosh2> Has anybody ever had an instance where cabal complains about a library not being in a certain directory when it is?
10:53:25 <megajosh2> I'm trying to install something that uses the readline package
10:53:33 <megajosh2> and it says /usr/lib/gcc/i686-pc-linux-gnu/4.7.2/../../../libncurses.so doesn't exist, but it does
10:53:41 <megajosh2> after checking myself
10:54:09 <bscarlet> megajosh2: any chance it's there, but as a soft link to something that isn't?
10:54:14 <geekosaur> it exists but is it a dangling symlink? try ls -lL
10:54:53 <megajosh2> Hmm... I didn't make sure of that
10:55:49 <megajosh2> It's not a symlink, no
10:56:22 <geekosaur> oh
10:56:27 <geekosaur> linux
10:56:46 <amyers> Is it the right platform?
10:56:49 <geekosaur> guess: it's a text file containing a linker script, and the linker script points to a nonexistent file
10:57:02 <amyers> i.e. are you compiling with 32bit and have 64bit library or vice versa?
10:59:18 <megajosh2> this is a 32 bit system, don't see anytihng indicating that this package is for a 64bit one
10:59:58 <megajosh2> geekosaur: and actually the contents of the file is just "INPUT(-lncursesw)"
11:00:04 <megajosh2> so perhaps
11:00:26 <geekosaur> yep, so now you are looking for /usr/lib/libncursesw.so
11:00:59 <megajosh2> Which doesn't exist
11:01:07 <megajosh2> ... wait, yes it does
11:01:09 <megajosh2> symlink to...
11:01:34 <megajosh2> another symlink... which is to...
11:01:42 <megajosh2> Something that does exist
11:01:54 <megajosh2> which is the actual library
11:07:41 <amyers> megajosh2: whats the output of `gcc -lncursesw`?
11:09:08 <megajosh2> amyers: just this
11:09:09 <megajosh2> > gcc -lncursesw
11:09:09 <megajosh2> /usr/lib/gcc/i686-pc-linux-gnu/4.7.2/../../../crt1.o: In function `_start':
11:09:09 <megajosh2> (.text+0x18): undefined reference to `main'
11:09:09 <megajosh2> collect2: error: ld returned 1 exit status
11:09:10 <lambdabot>   Not in scope: `gcc'
11:09:10 <lambdabot>  Perhaps you meant one of these:
11:09:10 <lambdabot>    `gcd' (imported fro...
11:09:14 <megajosh2> ... whoops
11:09:25 <megajosh2> I forgot about that triggering lambdabot
11:09:49 <geekosaur> how about if you use -lncurses instead of -lncursesw?
11:09:59 * bxc trying to find randomRs for PArray in DPH - it doens't seem to be where the wikipage says it would be
11:10:00 <geekosaur> but it's possible that whatever check cabal is doing does not cope with linker scripts
11:10:17 <megajosh2> geekosaur: Same exact output
11:13:57 <ParahSailin> is MultiParamTypeClasses dangerous?
11:14:04 <geekosaur> no
11:15:27 <geekosaur> it's not a standard yet because you really need either functional dependencies or type families to make it usable without having to annotate most-to-all uses with full types; fundeps are somewhat strange, and type families are as yet misisng some functionality needed for them to replace fundeps fully
11:15:55 <geekosaur> (fundeps are not dangerous, but they are kinda un-haskell-y; it's sort of prolog in the type system)
11:16:12 <danharaj> It would be nice if fundeps were elaborated into something more coherent and prology.
11:16:17 <danharaj> Instead of being ad-hoc and prology.
11:16:33 <simpson> Wasn't that the entire point of constraint kinds and the new constraint algebra?
11:17:06 <simpson> Also can you really do everything with type families that you could do with fundeps?
11:17:29 <megajosh2> I'll continue messing with the package myself and see if I can get it to work
11:17:32 <geekosaur> not with the current implementation (unless you run HEAD, and then you may get to discover new and fun bugs)
11:17:36 <megajosh2> thanks for the help, though
11:18:42 <geekosaur> ghc hq seems pretty clear that they would like fundeps to go away someday and are working to beef up type families
11:19:11 <simpson> That seems kind of odd, considering that fundeps are *really* simple compared to type families.
11:19:23 <danharaj> really?
11:19:36 <danharaj> logical relations between type variables is simpler than open partial type functions?
11:20:03 <simpson> I've yet to grok any description of type families. They seem really subtly complex.
11:20:30 <simpson> Fundeps are straightforward. One type fixes another.
11:31:16 <Hafydd> @pl flip (.)
11:31:16 <lambdabot> flip (.)
11:31:37 <Hafydd> :t flip (.)
11:31:38 <lambdabot> Functor f => f a -> (a -> b) -> f b
11:32:56 <Hafydd> @hoogle (a -> b) -> (b -> c) -> (a -> c)
11:32:56 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
11:32:56 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
11:32:56 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> (a -> c)
11:33:35 <clahey> :t flip
11:33:36 <lambdabot> (a -> b -> c) -> b -> a -> c
11:33:38 <clahey> :t (.)
11:33:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:33:49 <S11001001> :t (>>>)
11:33:51 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
11:34:06 <S11001001> Hafydd: ^^^
11:34:36 <clahey> Why does lambdabot give a different result for :t (.) from ghci's?
11:34:56 <Hafydd> @hoogle >>>
11:34:57 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
11:34:57 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
11:35:14 <geekosaur> clahey, because Cale likes his (.) to be different
11:35:51 <Hafydd> > ((+1) >>> (*2)) 0
11:35:52 <lambdabot>   2
11:35:57 <adityam> What is a good way to convert a list of integers "12,32,213,56" into an array of [Word8] or [Int]? I tried "readLine s = read ('[' : s ++ "]")" but then parsing is taking 80% of the time.
11:36:50 <otters> I mean, you could maybe split by "," and then read each
11:37:21 <Hafydd> An Array of [Int]?
11:37:36 <Hafydd> So that's something similar to an [[Int]]
11:37:39 <adityam> Sorry, I meant [Int]
11:37:46 <monochrom> I would split by "," too
11:37:57 <adityam> readline "1,2,3"  should give [1,2,3] :: [Int]
11:38:03 <Hafydd> @hoogle splitting
11:38:04 <lambdabot> No results found
11:38:30 <adityam> @hoogle splitAt
11:38:30 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
11:38:30 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
11:38:30 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
11:38:34 <monochrom> I see what you mean
11:38:36 <Hafydd> http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
11:38:36 <otters> there's something in Data.List.Split for splitting on strings
11:38:52 <Hafydd> Well, that might be an old page.
11:39:04 <monochrom> I don't know why it is slow, or what is a faster way
11:39:21 <byorgey> Hafydd: it is, latest version is 0.2.1.2
11:39:25 <byorgey> @package split
11:39:25 <lambdabot> http://hackage.haskell.org/package/split
11:39:50 <byorgey> however, if what adityam really wants is speed, I don't know whether splitting on commas using the split package will be faster.
11:40:10 <byorgey> the speedy solution would probably be to use attoparsec.
11:40:52 <adityam> Never user attoparsec before.
11:41:13 <adityam> Let me quickly profile splitOn and see how it works
11:41:44 <adityam> Ah, the split package does not come with profiling options :(
11:42:43 <adityam> But it does give a three fold speedup over my previous solution!
11:42:47 <byorgey> adityam: by default, nothing comes with profiling.
11:42:49 <byorgey> yay!
11:43:15 <adityam> So how do I enable profiling for a package. I simply install packages using "cabal install <name>"
11:45:17 <parcs> cabal install --enable-library-profiling
11:45:38 <monochrom> or set it in a line in $HOME/.cabal/config
11:45:57 <monochrom> the setting affects only packages built after, not before
11:46:11 <monochrom> http://www.vex.net/~trebla/haskell/haskell-platform.xhtml#correction
11:46:23 <adityam> Thanks, so I reinstall the packages with profiling enabled.
11:47:28 <monochrom> more people need to know that cabal defaults are wrong
11:47:37 <adityam> :)
11:47:51 <monochrom> the day of "90% of cabal users just use it for xmonad" is gone
11:48:17 <monochrom> like, documentation:False?! give me a break
11:48:51 <sm> I guess there was a reason.. like most people just want to use haskell software, not develop it, and haddock was/is slow/fragile
11:49:12 <byorgey> since when do only developers need documentation?
11:49:14 <monochrom> yes sm, exactly what I said, the days of "90% of cabal users just use it for xmonad"
11:50:07 <sm> byorgey: maybe you put your user docs in haddock ? I don't
11:50:34 <monochrom> the "documentation" refers to haddock, lib only, not for executable, so yes, non-developers may safely skip it
11:51:22 <monochrom> or, how about: you're perfectly right, all the more reason cabal default is absurd
11:51:34 <byorgey> oh, I was misunderstanding the distinction before.  Yes, I agree
11:52:11 <monochrom> anyone who edits xmonad config file actually needs library haddock too
11:52:43 <adityam> hmm...after profiling, converting String to [Int] is still taking 60% of time. (This is a program for k-nearest neighbors over a record of 40,000 data points; so I did not expect reading to be the speed bottleneck)
11:52:44 <sm> I'm not quite following all this, but we probably agree that building docs by default is the ideal, is that cost-free nowadays ?
11:52:50 <monochrom> it's a bloody haskell module that bloody calls xmonad lib functions
11:53:22 <byorgey> adityam: as I said, if you really want blazing fast reading, use a proper parsing library optimized for speed such as attoparsec
11:53:49 <phaul> greetings. I am struggling to get my type signatures right. If I don't give anything my code compiles fine, except the warning for missing top level signatures. If I copy what ghc said it's good. But the context to the signature is ~ 10 lines nonsense. Is there a way to transform it to something more sensible? Otherwise what is ~ in type signature context? Thanks.
11:53:58 <byorgey> writing a parser for stuff of the form   34,45,62,...  should just be a few lines of code
11:54:08 <monochrom> building doc is likely 1% time and 1% disk space of building code
11:54:29 <adityam> byorgey: Thanks. I'll go read the autoparsec docs
11:54:39 <monochrom> and likely has always been
11:54:42 <byorgey> phaul: ~ in a type signature context is type equality.  i.e.   a ~ Int  means that the type 'a' is constrained to be equal to Int.
11:55:18 <byorgey> phaul: clearly it isn't nonsense, since it typechecks =)
11:55:25 <sm> monochrom: I guess the hackage operators will be in the best position to know, and could say if it's time to turn it on for all users
11:55:32 <monochrom> profiling, you can say it clearly doubles the cost, and even some programmers won't use it (such as me)
11:55:40 <sm> (since they build all the haddocks)
11:56:02 <sm> yes profiling on by default is less clear (to me)
11:56:36 <byorgey> phaul: and no, there is no general method for simplifying types.  Depending on what the type is there may be a wa way to make it less polymorphic, if you do not need the generality
11:56:54 <byorgey> phaul: but that will depend on your specific use case, there is no automatic way to do it.
11:56:59 <monochrom> clearly, as code optimization becomes more aggressive, more time-consuming, and more inlining (therefore more disk space), doc cost can only diminish in comparison
11:57:08 <byorgey> phaul: what librar(ies) are you using?
11:57:13 <phaul> thanks byorgey , that was helpful
11:57:16 <phaul> Yesod
11:57:31 <byorgey> OK, unfortunately I am not familiar with yesod
11:57:36 <byorgey> but you could also ask in #yesod
11:57:54 <phaul> cheers, appreciated
11:59:59 <monochrom> beginners should really start with profiling on because to change it retrospectively is confusing. "cabal install --enable-library-profiling --reinstall text" --> the following packages will likely be broken by reinstall
12:00:31 * Lethalman also builds shared and executable-dynamic
12:00:33 <sm> it's just "enable it in ~/.cabal/config and do a package reset", eh ?
12:01:03 <monochrom> yes, but some beginners shed tears when asked to rebuild almost everything
12:01:25 <danharaj> I've been bitten more than once when setting up an environment on a fresh system by forgetting to enable profiling in config.
12:01:28 <danharaj> :3
12:01:31 <monochrom> and you have to explain why, etc etc
12:01:34 <sm> I think that's something that has to change, since current cabal/ghc requires it eventually
12:01:48 <sm> I made a how-to for it
12:02:47 <sm> on another topic, do we have anything similar to racket's custodians ( http://en.wikipedia.org/wiki/Racket_features#Resource_Management_and_Sandboxing ) ? I really like that you can enforce memory limits on subthreads within the language
12:03:30 <monochrom> I don't know how to sandbox a thread to the point of limiting memory
12:04:34 <sm> darcs hub needs it, and I guess it's going to be some cobbled-together shell command polling with ps
12:05:39 <bscarlet> What would it mean for memory to belong to a thread in haskell? It doesn't seem too well defined.
12:05:51 <sm> staying in haskell would be much better. I suppose it needs RTS/GC support
12:06:06 <sm> bscarlet: I'm using "thread" loosely there, perhaps subprocess is more correct
12:06:11 <danharaj> sm: I *think* there ought to be a way to limit the stack size of subthreads but only with +RTS options.
12:06:58 <danharaj> sm: and of course if you're spawning subprocesses you can put a hard cap on their heap space too.
12:07:47 <sm> here are two cases from darcs hub: first, the (snap) web app spawns a thread (I guess) to handle a request, which calls libdarcs and could grow large. Second, the darcs hub ssh server spawns an external darcs apply process, which can grow large. I'd like to be able to enforce limits in both cases
12:08:28 <sm> danharaj: with ulimit or something ?
12:08:57 <ExternalReality> > 1
12:08:59 <lambdabot>   1
12:09:19 <danharaj> sm: -Msize hard-caps the heap.
12:09:48 <sm> for each thread, right ?
12:10:04 <sm> that sounds good for case 1, indeed
12:10:17 <danharaj> That one is the entire heap of the process.
12:10:23 <sm> ah
12:10:32 <sm> oh heap, not stack
12:10:48 <danharaj> -Ksize is the max stack per thread
12:10:52 <danharaj> and it is by default 8M
12:11:35 <danharaj> However, thread stacks live on the heap anyway so whatever.
12:19:45 <sm> nod
12:20:03 <sm> thanks for the reminder
12:25:19 <sm> monochrom: here's that how-to, do you see any major problems with https://www.fpcomplete.com/user/simonmichael/how-to-cabal-install#the-easy-solution--reset-your-packages ?
12:27:44 <monochrom> no
12:28:05 <sm> \o/
12:31:25 <Taneb> import Control.Concurrent;import Control.Monad;import Data.Function;main=fix(forever.forkIO)
12:31:53 <gwern> @quote cabal
12:31:53 <lambdabot> mtnviewmark says: cabal install puppet-president
12:32:22 <c_wraith> Taneb: that'll just kill GHC's scheduler, not your operating system's
12:33:35 <monochrom> @type fix (forever . forkIO)
12:33:37 <lambdabot> Not in scope: `forkIO'
12:34:02 <monochrom> @type fix (forever . Control.Concurrent.forkIO)
12:34:04 <lambdabot> IO ()
12:34:35 <crdueck_> why isnt there a dropEnd for ByteStrings? as in "abcdef" `dropEnd` 2 == "abcd". Its so trivial to write, I would assume it be part of the library, unless it exists in some form and I'm just not finding it.
12:36:08 <c_wraith> crdueck_: just not assumed to be a sufficiently common use case to create an optimized code path for it. (It can be written slightly more efficiently with access to the library internals, actually)
12:37:15 <c_wraith> crdueck_: as a followup to the addendum, the internals are actually available to anyone who doesn't mind the fact that they might change at any time, in the .Internal modules
12:38:04 * hackagebot aws 0.7.6.2 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.7.6.2 (AristidBreitkreuz)
12:38:24 <crdueck_> c_wraith: i used the internals, unsafeDropEnd n (PS x s l) = PS x s (l-n)
12:38:49 <c_wraith> crdueck_: that's not safe, though. You should at least do better than that. :)
12:39:11 <c_wraith> crdueck_: you need to make sure l - n >= 0
12:39:24 <crdueck_> well, i have some guarantees on the bytestrings I'm working with
12:39:36 <crdueck_> i see that even the unsafe* versions use an assert
12:39:49 <crdueck_> but this isnt library code, just something for myself.
12:41:12 <monochrom> assert is deleted by -O
12:41:26 <parcs> i wonder why bytestrings even keep an offset
12:41:28 <crdueck_> in this case I dont think I could even write it without using the internals. The whole reason I needed it was I wanted a slice of a BS, but I didnt know how long the slice would be, only the offsets from the beginning and end
12:41:40 <crdueck_> monochrom: interesting, I didnt know that
12:41:45 <c_wraith> parcs: to implement substring efficiently
12:42:08 <parcs> c_wraith: can't you just increment the underlying pointer?
12:42:09 <monochrom> bytestring keeps an offset so that substring (or whatever it's called) is O(1)
12:42:23 <monochrom> hrm, I don't know
12:42:25 <c_wraith> parcs: not without messing with garbage collection
12:42:50 <monochrom> ah, no wonder
12:43:37 <parcs> data ForeignPtr a = ForeignPtr (Ptr a) ForeignPtrContents -- it's the ForeignPtrContents that used in garbage collection, not the Ptr. but i guess that's implementation dependent
12:44:02 <c_wraith> it depends on what heap the bytestring was allocated in
12:44:26 <c_wraith> I'm pretty sure you can have them allocated in the GHC heap, such that the Ptr is actually the important part
12:44:59 <parcs> oh, ok
12:46:59 <monochrom> someone has to know the original beginning of the memory chunk, for the sake of deallocation later, be it GC or finalizer or whatever
12:48:11 <monochrom> so suppose the original bytestring is x, and then y = substring x blahblah, and then x is completely forgotten. now the burden of knowledge is on y
12:50:13 <parcs> if the underlying pointer of two bytestrings is the same, but their offsets are different, is it the case that the two bytestrings are not equivalent?
12:50:31 <parcs> is it always the case*
12:50:52 <Heffalump> parcs: no, because the lengths might be the same and the content pointed to the same
12:51:23 <monochrom> hmm, what is equivalent?
12:51:26 <Heffalump> e.g. the whole buffer contains "foofoo" - first bytestring points to the start and the second three characters in, both length 3
12:51:33 <parcs> monochrom: byte-by-byte
12:51:51 <monochrom> then what Heffalump says
12:52:26 <parcs> makes sense.
12:53:50 <parcs> i thought that bytestrings were zero-terminated for a second
12:56:52 <tdammers> parcs: then they wouldn't really be *byte*strings anymore, but integer-in-1-to-255-inclusive-range-strings
12:59:59 <parcs> that is true
13:02:10 <megajosh2> QUIT
13:02:12 <megajosh2> whoops
13:02:22 <afarmer> didn't see that coming
13:02:45 <monochrom> do people still enter "/QUIT" by hand?
13:03:16 <friend> I do sometimes
13:03:17 <afarmer> monochrom: maybe a terminal-based chat client?
13:03:36 <adityam> byorgey: Thanks a ton. The attoparsec based solution is 100 times faster (so no time wasted on parsing and all the time spent on hard calculations, as desired)
13:03:43 <byorgey> adityam: awesome!
13:04:35 <monochrom> now I wonder what makes read slow
13:05:07 <monochrom> which attoparsec combinator did you use for individual numbers?
13:08:04 * hackagebot tremulous-query 1.0.7 - Library for polling Tremulous servers  http://hackage.haskell.org/package/tremulous-query-1.0.7 (ChristofferOjeling)
13:08:06 * hackagebot apelsin 1.2.2 - Server and community browser for the game Tremulous  http://hackage.haskell.org/package/apelsin-1.2.2 (ChristofferOjeling)
13:12:34 <adityam> monochrom: decimal
13:13:20 <adityam> I used "record = decimal `sepBy1` char '1'" to parse each line, and lines to split the file into lines
13:20:12 <root___> quit
13:20:14 <root___> quit
13:21:00 <edwardk> logging into irc as root doesn't seem like a great idea
13:21:58 <wereHamster> links to source on this webpage are broken: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html
13:23:01 <locomoko> hello
13:26:32 <lispy> edwardk: I did that once; granted I changed the uid of root so that it wasn't 0 first...
13:27:59 <lispy> Basically, superuser was named wizzle (after wizzle the chaotic of angband fame) and root was my 'user' account. It basically had the effect of trolling anyone who tried to help me and in the end I gave up on my attempted 'security through obscurity' :)
13:29:23 <locomoko> quit
13:30:52 <pantsman> part
13:31:14 <pantsman> msg nickserv id i_love_the_cock
13:32:04 <pantsman> -NickServ- `nand`!~nand@2a01:4f8:d13:5245::2 failed to login to pantsman.  There has been 1 failed login attempt since your last successful login.
13:32:05 <pantsman> haha
13:32:09 <`nand`> :)
13:32:19 <`nand`> I tried a GHOST
13:33:11 <danharaj> edwardk et al. : what do you think of this kludge? http://hpaste.org/83696
13:34:39 <edwardk> not grokking the motivation
13:36:12 <danharaj> edwardk: I have objects that have continuations that are modeled on a type constructor f. They're state machines. I have combinators like container that make state machines out of aggregates of smaller ones. Currently I've been using Compose to write "The continuations of this are modeled on Compose f g", but that's annoying.
13:36:34 <Taneb> Foo f a feels equivalent to (a, f a), but I'm not sure
13:36:47 <danharaj> Taneb: My real type has hideous layers of monadery.
13:37:06 <Taneb> Oh dear
13:38:48 <danharaj> edwardk: I have reservations that this doesn't actually work :(
13:40:07 <edwardk> i'm not really following the motivation very well
13:41:04 <danharaj> edwardk: Maybe in a few days I'll be able to motivate this. :3 Oh well, thanks for the time.
13:41:31 <covi> Hi all. yesod devel gave me: yesod: devel port unavailable
13:41:37 <covi> What's wrong and how can I fix it?
13:42:05 <hpc> covi: is something else using the port?
13:42:24 <covi> hpc: I don't know
13:42:30 <jfischoff> mostly likely a left over ghc process
13:42:47 <jfischoff> covi: what's your os?
13:42:50 <covi> Right, I think I used c-z to kill it
13:42:53 <covi> Mac OS X.
13:43:05 * hackagebot lz4 0.2.2 - LZ4 compression for ByteStrings  http://hackage.haskell.org/package/lz4-0.2.2 (MarkWotton)
13:43:07 <armlesshobo> what was the name of that new ide someone at somepoint was working on a while back?
13:43:14 <[swift]> i see some papers on the web on fixing the orphan instance problem (giving instances names or scopes, etc.) but i can't seem to find anything about the state of community consensus on the issue
13:43:19 <armlesshobo> they had a blog and would post some updates.
13:43:24 <covi> Alright. I have killed it. Thanks
13:43:27 <danharaj> armlesshobo: are you thinking of leksah, eclipseFP or the FPComplete ide?
13:43:29 <[swift]> is there a plan in the works?
13:43:33 <jfischoff> np
13:43:38 <armlesshobo> danharaj: not Leksah.
13:43:47 <armlesshobo> danharaj: let me check FPComplete.
13:45:15 <dmwit> [swift]: What's the problem, exactly?
13:45:39 <dmwit> covi: ctrl-z doesn't kill things =)
13:46:04 <hpc> dmwit: it does on windows ;)
13:46:07 <[swift]> dmwit: that you can't control the import or export of instances, which makes orphan instances bad
13:46:14 <armlesshobo> danharaj: it was FPComplete IDE :) thank you
13:46:21 <dmwit> [swift]: What is bad about them?
13:47:01 <[swift]> dmwit: http://www.haskell.org/haskellwiki/Orphan_instance
13:47:57 <dmwit> [swift]: I am familiar with the term. I am not familiar with the problem.
13:48:10 <[swift]> dmwit: it's explained on that page
13:48:40 <dmwit> I'm reading the page, and don't see anything that is obviously bad. Will you say what *you* don't like about the existence of orphan instances?
13:49:16 <[swift]> dmwit: paragraphs 2 and 3 on that page
13:49:53 <dmwit> [swift]: So the real thing you don't like is that it's not possible to have two instances for a given class/type pair?
13:50:59 <dmwit> In such cases, it is often (though not always!) the case that you are using classes in a way they weren't meant to be used, and you should use a record or similar instead.
13:51:02 <[swift]> dmwit: well, that'd be fine if you had control over importing/exporting them or could otherwise scope them
13:51:06 <lispy> fg
13:51:11 <lispy> heh, sorry wrong window!
13:51:41 <lispy> (and now everyone knows my secret shame, I background jobs...)
13:51:41 <dmwit> [swift]: Can you describe the particular class and type you are running into this problem with? We may be able to give some pointers on another way to approach the problem.
13:52:03 <[swift]> dmwit: we are moving far afield from my original question
13:52:12 <dmwit> I don't feel that we are.
13:52:26 <dmwit> Or rather, I feel your original question was the wrong one to ask. =)
13:52:32 <[swift]> dmwit: well i disagree.
13:52:48 <dmwit> If you are having a problem, you should tell us about it. If you are not having a problem, what are we talking about?
13:53:00 <[swift]> all i wanted to know was whether any of the research papers on this topic were being looked at for inclusion in the language
13:53:11 <dmwit> Not that I know of.
13:53:33 <[swift]> dmwit: thanks =p
13:53:36 <dmwit> The official way for things to be included in the language is via the Haskell' (note the "prime") process outlined on the wiki.
13:53:47 <dmwit> You can check the proposals and see if any look relevant.
13:53:50 <[swift]> yes, i looked there, and could not find it, but there's a lot of material there
13:54:20 <dmwit> But the open-world assumption is nice in a lot of ways and I feel it's very unlikely that it will be subverted in any revision in the next decade or so.
13:54:54 <dmwit> And, as I've been trying to point out above, it's pretty uncommon that it's actually a problem.
13:55:13 <dmwit> Even for you. =)
13:55:54 <[swift]> <shrug> i'm just interested in programming language research
13:56:01 <[swift]> i'm aware of the practical workarounds
14:20:20 <`nand`> for some meaning of “workaround”
14:31:53 <covi> @hoogle `<>`
14:31:53 <lambdabot> Parse error:
14:31:54 <lambdabot>   `<>`
14:31:54 <lambdabot>   ^
14:32:16 <crl> @hoogle (<>)
14:32:16 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
14:32:16 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
14:32:16 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
14:32:32 <crl> has anyone here put hands in OpenFlow?
14:33:40 <crl> @hoogle nettle
14:33:41 <lambdabot> package nettle-frp
14:33:41 <lambdabot> package nettle-openflow
14:34:38 <crl> I like the idea to define flow rules dynamically, even if i'm trying to learn openflow..
14:35:08 <crl> forward* rules
14:39:18 <lightquake> what's the associativity of an operator like `f`?
14:39:45 <arkeet> > a `f` b `g` c :: Expr
14:39:47 <lambdabot>   Ambiguous type variable `t0' in the constraints:
14:39:47 <lambdabot>    (GHC.Show.Show t0)
14:39:47 <lambdabot>     ...
14:39:48 <lightquake> it looks like it's left-associative
14:39:57 <arkeet> > a `f` a `f` a :: Expr
14:39:59 <lambdabot>   Ambiguous type variable `t0' in the constraints:
14:39:59 <lambdabot>    (GHC.Show.Show t0)
14:39:59 <lambdabot>     ...
14:40:02 <arkeet> guhrgfdg
14:40:22 <arkeet> > let g = f :: Expr -> Expr -> Expr in a `g` b `g` c
14:40:24 <lambdabot>   f (f a b) c
14:40:28 <arkeet> left.
14:40:30 <arkeet> :p
14:41:10 <arkeet> actually, infixl 9.
14:43:40 <arkeet> "If no fixity declaration is given for ` op ` then it defaults to highest precedence and left associativity (see Section 4.4.2). "
14:44:12 <arkeet> same as operator symbols
14:44:41 <monochrom> @unmtl ErrorT X (State S a)
14:44:42 <lambdabot> Plugin `unmtl' failed with: `ErrorT X (S -> (a, S))' is not applied to enough arguments.
14:44:48 <monochrom> @unmtl ErrorT X (State S) a
14:44:49 <lambdabot> S -> (Either X a, S)
14:45:28 <monochrom> @unmtl StateT S (Either X) a
14:45:29 <lambdabot> S -> Either X (a, S)
14:45:54 <monochrom> ordering the transformer stack is tricky business!
14:46:51 <crl> > let g = f :: Expr -> Expr -> Expr in a `g` (b `g` c)
14:46:53 <lambdabot>   f a (f b c)
14:46:57 <Taneb> I think I use StateT Integer (MaybeT (StateT Integer IO))
14:47:22 <Taneb> @unmtl StateT Integer (MaybeT (StateT Integer IO)) a
14:47:23 <lambdabot> Integer -> Integer -> IO (Maybe (a, Integer), Integer)
14:51:26 <otters> :t f
14:51:27 <lambdabot> FromExpr a => a
14:56:37 <niteria> :t f a
14:56:38 <lambdabot> FromExpr t => t
14:57:56 <arkeet> :t a
14:57:57 <lambdabot> Expr
14:58:56 <crl> :t z
14:58:57 <lambdabot> Expr
14:59:05 <niteria> :t f f
14:59:07 <lambdabot>     Ambiguous type variable `a0' in the constraints:
14:59:07 <lambdabot>       (Show a0) arising from a use of `f' at <interactive>:1:1
14:59:07 <lambdabot>       (FromExpr a0) arising from a use of `f' at <interactive>:1:3
14:59:22 <crl> :t f. f
14:59:23 <lambdabot> (Functor f, Show a, FromExpr (f a), FromExpr b) => f b
15:00:27 <crl> :t g
15:00:29 <lambdabot> FromExpr a => a
15:00:34 <crl> :t h
15:00:36 <lambdabot> FromExpr a => a
15:00:39 <arkeet> :t f `asTypeIn` \f -> f.f
15:00:40 <lambdabot> (Show a, FromExpr a) => a -> a
15:01:35 <crl> :t i
15:01:37 <lambdabot> Expr
15:08:26 <NougatRillettes> @pl \a b c -> a && b && c
15:08:26 <lambdabot> (. (&&)) . (.) . (&&)
15:08:35 <NougatRillettes> huh
15:08:37 <NougatRillettes> jizz
15:08:56 <crl> ouch
15:10:18 <crl> > and [True,False]
15:10:20 <lambdabot>   False
15:18:13 <crl> > [True,False,..]
15:18:16 <lambdabot>   <hint>:1:13: parse error on input `..'
15:18:21 <crl> > [True,False..]
15:18:23 <lambdabot>   <hint>:1:14: parse error on input `]'
15:19:14 <c_wraith> crl: you need a space before the ..
15:19:22 <crl> > [True,False ..]
15:19:24 <lambdabot>   [True,False]
15:19:25 <c_wraith> crl: it's parsing it as the module False, the operator .
15:19:28 <NougatRillettes> @pl f | Just False -> const $ Just False | _ -> id
15:19:29 <lambdabot> (line 1, column 18):
15:19:29 <lambdabot> unexpected '>'
15:19:29 <lambdabot> expecting operator
15:19:33 <crl> > [True ..]
15:19:35 <lambdabot>   can't find file: L.hs
15:19:56 <letrec> I'm looking for something like: IO a -> b -> IO (a,b)
15:21:02 <crl> > [False ..]
15:21:04 <lambdabot>   [False,True]
15:21:09 <c_wraith> :t fmap . flip (,)
15:21:11 <lambdabot> Functor f => b -> f a -> f (a, b)
15:21:12 <crl> > [True ..]
15:21:14 <lambdabot>   [True]
15:21:22 <NougatRillettes> @pl f x = case x of | Just False -> const $ Just False | _ -> id
15:21:22 <lambdabot> (line 1, column 32):
15:21:22 <lambdabot> unexpected '>'
15:21:22 <lambdabot> expecting operator
15:21:27 <crl> lambdabot is not deterministic
15:21:48 <crl> can't find file: L.hs is io error i guess
15:21:50 <c_wraith> lambdabot depends on several files on the hard drive of the machine it's using, that are sometimes overwritten
15:21:59 <crl> yep ;)
15:22:03 <c_wraith> :t flip $ fmap . flip (,)
15:22:05 <lambdabot> Functor f => f a1 -> a -> f (a1, a)
15:22:25 <c_wraith> letrec: that fits your type, and is terrible. don't use it. :)
15:22:40 <letrec> :t flip $ fmap . flip (,)
15:22:42 <lambdabot> Functor f => f a1 -> a -> f (a1, a)
15:23:09 <letrec> c_wraith: Thanks :)
15:23:13 * hackagebot hothasktags 0.3.1 - Generates ctags for Haskell, incorporating import lists and qualified imports  http://hackage.haskell.org/package/hothasktags-0.3.1 (LukePalmer)
15:23:54 <letrec> :t flip
15:23:56 <lambdabot> (a -> b -> c) -> b -> a -> c
15:25:17 <Sgeo_> :t (<$)
15:25:19 <lambdabot> Functor f => a -> f b -> f a
15:25:33 <Sgeo_> So applicative parsers usually use <$ a lot?
15:29:45 <NougatRillettes> is there any typeclass with an oeprator, for exemple >!> that would either give its left argument or drop it and give the second ?
15:30:34 <elliott> NougatRillettes: perhaps you want (<|>)?
15:30:46 <Sgeo_> > Just 5 <|> Just 6
15:30:47 <lambdabot>   Just 5
15:30:50 <Sgeo_> > Nothing <|> Just 6
15:30:52 <lambdabot>   Just 6
15:30:59 <Sgeo_> > Nothing <|> Nothing
15:31:00 <lambdabot>   Nothing
15:32:45 <NougatRillettes> hm, yes it seems :)
15:32:53 <aCube> Is it possible to have infinite Data.Maps in haskell?
15:33:05 <`Jake`> @type <|>
15:33:07 <lambdabot> parse error on input `<|>'
15:33:11 <`Jake`> @type (<|>)
15:33:13 <lambdabot> Alternative f => f a -> f a -> f a
15:33:13 <aCube> > M.fromList $ zip [1..] [1..] -- Doesn't work
15:33:17 <lambdabot>   mueval-core: Time limit exceeded
15:33:44 <aCube> > M.lookup 1 $ M.fromList $ zip [1..] [1..]
15:33:47 <geekosaur> I believe maps are spine strict
15:33:48 <lambdabot>   mueval-core: Time limit exceeded
15:34:14 <crl> maps need to parse the whole list
15:34:22 <crl> probably
15:34:27 <aCube> Yes, i guessed that
15:34:39 <NougatRillettes> hm, in fact I d'ont have any neutral element
15:35:07 <crl> > M.fromList [(1,4),(2,3),(1.2)]
15:35:09 <lambdabot>   No instance for (GHC.Real.Fractional (k0, a0))
15:35:09 <lambdabot>    arising from a use of `e_...
15:35:16 <crl> > M.fromList [(1,4),(2,3),(1,2)]
15:35:18 <lambdabot>   fromList [(1,2),(2,3)]
15:35:39 <crl> 1st elt is overwritten
15:36:25 <aCube> Is there an other map-like data structure that supports this?
15:36:42 <NougatRillettes> I just need it to do this : http://paste.awesom.eu/aXB
15:37:37 <lispy> aCube: functions :)
15:37:40 <`nand`> aCube: association lists?
15:37:44 <c_wraith> aCube: there are some infinite trees in some packages.  What exactly do you want to do?
15:38:16 <aCube> Well, i could just use association lists. But are there lenses for assocation lists? :D
15:39:06 <geekosaur> NougatRillettes, "Just" is not a value, so what you pasted is not valid
15:39:29 <elliott> geekosaur: ? sure it is
15:39:31 <elliott> :t Just
15:39:33 <lambdabot> a -> Maybe a
15:39:33 <geekosaur> "Just <something>" is a value, if <something>" is a value
15:40:02 <elliott> well, sure, that's because "f x" is a value, if f is a value of type a -> b and x is a value of type a
15:40:03 <NougatRillettes> there is a false following each of my Just anyway
15:40:12 <geekosaur> elliott, so you think they're doing function comparison there?
15:40:22 <hpaste> “Jonathan Fischoff” pasted “More Rank2 Issues” at http://hpaste.org/83701
15:40:30 <geekosaur> NougatRillettes, but f Just x is not the same as f (Just x)
15:40:40 <elliott> I agree there's an obvious error but I don't think falsehoods will correct errors :P
15:40:48 <jfischoff> ^ can anyone see a way to get test to compile?
15:41:52 <jfischoff> I get Expected type: [forall a. Show a => a -> a] | Actual type: [a0 -> a0]
15:41:57 <crl> > [ l2 | l2<-transpose [[1,2][3,4]]]
15:41:59 <lambdabot>   The function `[1, 2]' is applied to one argument,
15:41:59 <lambdabot>  but its type `[t0]' has ...
15:43:30 <jfischoff> interesting ImpredicativeTypes seems to help
15:44:33 <NougatRillettes> hm, yep, parenthesis have been forgotten back there :D
15:45:21 <`Jake`> NougatRillettes: Is this supposed to be pattern matching or an example of what it should return?
15:45:26 <geekosaur> in any case I am still unclear about what you are trying to do there.
15:46:22 <`Jake`> I guess pattern matching
15:46:40 <mapf> what is good introduction to tactic based theorem proving?
15:46:49 <crl> > let m1 `mult` m2 = [ [x1*x2 |x1<-l1, x2<-l2] | l1<-m1, l2<-transpose m2] in [[1,0],[0,1]] `mult` [[1,1],[1,1]]
15:46:51 <lambdabot>   [[1,1,0,0],[1,1,0,0],[0,0,1,1],[0,0,1,1]]
15:46:56 <crl> hmm fail
15:47:38 <NougatRillettes> I'm just trying to find a typeclass that would need one operator, for example >!> which would either return its left or right argument
15:47:41 <crl> (matrix mult)
15:48:13 * hackagebot alloy 1.2.0 - Generic programming library  http://hackage.haskell.org/package/alloy-1.2.0 (MattGlazar)
15:48:31 <`Jake`> Man, I hate it when I function I wrote two weeks ago is fundamentally flawed...
15:48:57 <sellout-> `Jake`: Yeah, I usually discover that about my functions within a day or two ;)
15:49:14 <crl> > let a `mult` b= [ [ sum $ zipWith (*) ar bc | bc <- (transpose b) ] | ar <- a ] in [[1,0],[0,1]] `mult` [[1,1],[1,1]]
15:49:17 <lambdabot>   [[1,1],[1,1]]
15:49:19 <`Jake`> sellout-: I didn't get to work on the program for the last two weeks...
15:49:36 <lispy> mapf: I think it depends on the theorem prover
15:49:38 <covi> I want to build a simple haskell app that allows me to store, load, sort some data (like a bunch of strings, say). Should I use a database for this purpose? If so, what packages should I look at / use ?
15:49:48 <lispy> mapf: Are you talking about Coq or Isabelle perhaps?
15:50:41 <lispy> mapf: Are you already familiar with the basic idea behind tatics and tacticals?
15:50:45 <mapf> lispy: I want to Coq, yes.
15:51:22 <mapf> lispy: No, it's that i'm asking actually.
15:52:47 <lispy> mapf: Milner conceived of tactics as higher order proofs and tacticals as higher order tactics
15:53:04 <lispy> mapf: if you're serious about learning Coq, this is _the_ book: http://www.labri.fr/perso/casteran/CoqArt/index.html
15:53:19 <lispy> mapf: Sadly it's quite expensive so you might look around for cheaper ways to get a copy
15:53:32 <crl> @hoogle sqlite3
15:53:33 <lambdabot> package bindings-sqlite3
15:53:33 <lambdabot> package haskelldb-hdbc-sqlite3
15:53:33 <lambdabot> package haskelldb-hsql-sqlite3
15:54:08 <lispy> mapf: the idea is that a tactic manipulates the proof search. In a dependently typed setting that means one thing and in a HOL setting that means another.
15:54:51 <geekosaur> NougatRillettes, you keep saying that but you keep leaving out the critical part: return under what conditions?
15:54:58 <lispy> mapf: tactics are often implemented in a "meta" language
15:55:09 <NougatRillettes> geekosaur: depending on the instance
15:55:52 <geekosaur> "left argument or right argument depending on the instance" so "instance" means whiat/which? or is it some third thing?
15:56:08 <NougatRillettes> huh
15:56:18 <NougatRillettes> it's instance ... where
15:56:36 <geekosaur> also do you mean you think you wnant something that inmtrospects a type and decides what to return based on that?
15:56:44 <geekosaur> (because Haksell does not want to give you that)
15:57:19 <mapf> lispy: I'll try that book, thanks.
15:58:21 <NougatRillettes> geekosaur: not at all
15:58:22 <geekosaur> also, if you want something that is "depending on the instance" then you define a typeclass and define appropriate instances
15:58:39 <geekosaur> pretty much every typeclass function does what you specified, but I bet you don;t actually mean any of them...
15:59:08 <geekosaur> well, no, I shouldn't say that. but Monoid and MonadPlus come to mind
15:59:31 <NougatRillettes> Monoid requires a neutral element
15:59:39 <NougatRillettes> I want the mappend wihtout the mepmty
15:59:48 <NougatRillettes> (mayeb i should have said it firts)
15:59:50 <geekosaur> and Alternative
15:59:56 <NougatRillettes> same thing
16:00:28 <otters> mappend without mempty?
16:00:30 <otters> sounds like a semigroup
16:00:32 <lispy> mapf: This is about idris instead of coq, but it's a paper describing how the idris tactics work: http://www.cs.st-andrews.ac.uk/~eb/writings/ivor.pdf
16:00:49 <geekosaur> yeh, so you want a semigroup? several of them on hackage
16:01:48 <jfischoff> ski: simple question. How do I get test to compile? http://hpaste.org/83701
16:02:13 <geekosaur> jfischoff, if that's the same one you pasted earlier, your foralls do not match
16:02:24 <jfischoff> yes same one
16:02:25 <`nand`> ‘mappend’ doesn't necessarily return either its left or its right argument
16:02:39 <geekosaur> one is outer level, one is inner (covariant vs. contravariant)
16:03:09 <jfischoff> I can change it, but then I get different issues
16:03:47 <NougatRillettes> `nand`: yes, you're right but it can be used to
16:04:03 <jfischoff> for instance [forall a. Show a => ( a -> a, a)] means I can't use unzip
16:04:47 <jfischoff> in that case would it need to be [(forall a. Show a => (a -> a, forall a. Show a => a)] ?
16:04:56 <mapf> lispy: Thanks, as I understand Idris has a similar proof system?
16:05:48 <lispy> mapf: I think it might, yeah but I'm not certain
16:06:11 <lispy> mapf: if you're serious about this stuff, I would highly recommend implementing the stuff in this tutorial paper: http://www.andres-loeh.de/LambdaPi/LambdaPi.pdf
16:06:33 <lispy> mapf: my learning style is such that implementing things from the ground up gives me a much stronger understanding
16:09:36 <Ralith> lispy: is anyone's not?
16:09:44 <Ralith> it has a wonderful way of forcing you to fully understand it.
16:10:51 <mapf> lispy: I'm too. I think I'll try to do it right now, thanks. :)
16:11:29 * slack1256 loves that there is always a lhs with the correct length & density of information
16:11:33 <hpc> does anyone know if this already exists?
16:11:40 <hpc> i want a pool of threads all performing the same action
16:11:49 <hpc> and over time i want to change the number of threads running at a time
16:11:55 <slack1256> haskell blogging is on of the human wonders
16:16:27 <bitonic> hpc: not that I know of
16:16:41 <hpc> hmm
16:16:54 <bitonic> what’s an ‘action’ here anyway?
16:16:58 <bitonic> ‘IO ()’?
16:17:06 <bitonic> because in that case it’s really not that complicated
16:17:24 <hpc> not particularly
16:17:30 <hpc> just don't feel like writing it ;)
16:17:54 <hpc> in my specific case, the action is visiting a webpage
16:17:55 <bitonic> hpc: MVar [ThreadId]?
16:18:04 <hpc> i am making a site profiler
16:18:15 <hpc> that steadily increases load until it finds a steady state
16:18:42 <hpc> it slowly adds threads until it is finishing them as fast as it makes them
16:19:28 <bitonic> hpc: I’d simply keep a set of ThreadIds, or a set of Chans if you need to talk
16:21:06 <bitonic> it all depends how you need to communicate with the threads really.  if you just want to kill them at some point then it’s trivial, but I suppose you want to do more
16:21:42 <hpc> my ultimate output is going to be the average number of threads over an interval, i think
16:21:56 <hpc> or possibly total requests/s
16:23:35 <`nand`> possibly http://hackage.haskell.org/packages/archive/threads/0.5.0.1/doc/html/Control-Concurrent-Thread-Group.html or something could be of use
16:24:20 <bitonic> oh right, threads
16:24:21 <`nand`> it has ‘nrOfRunning’; and the ability to fork new threads into it; though nothing about actually killing them (unless you keep track of the ThreadIds yourself, in which case the library becomes useless again)
16:24:47 <lispy> mapf: Looks like Adam Chlipala is working on a book about Coq and it's currently freely available on his website: http://adam.chlipala.net/cpdt/
16:24:55 <hpc> yeah, that's not going to help, on two counts
16:25:04 <hpc> my threads run forever, then i kill them as i ramp down
16:25:23 <bitonic> mapf: if it hasn’t been mentioned, there’s also software foundations
16:25:45 <hpc> i'll probably just have an mvar counter shared between all threads
16:26:08 <bitonic> mapf: but that and CPDT have quite a non-functional approach.  not that it’s necessarily bad
16:26:13 <hpc> the main thread watches it and calls it "hits per interval" or something
16:26:35 <hpc> and keeps a rolling track of that number
16:26:54 <hpc> if it stays steady, increase number of threads
16:27:00 <hpc> if it goes down, reduce number of threads
16:27:27 <bitonic> hpc: that sounds fine, so (MVar Int, MVar (Set ThreadId)) is enough
16:27:32 <hpc> and somehow i will make sure it doesn't go widly out of control
16:27:50 <hpc> bitonic: i don't need Set, just []
16:27:54 <bitonic> well the Set ThreadId doesn’t even need to be in a MVar, if there is only one thread controlling
16:27:57 <hpc> i can push and pop threads
16:28:46 <bitonic> mapf: ah, you asked for tactics explicitly.  then you should really check out CPDT :)
16:39:03 <NougatRillettes> Any clue about whan will Vectors be available in haskell ?
16:39:29 <Clint> Vectors?
16:40:04 <c_wraith> several years ago?
16:40:07 <geekosaur> isn't Vector already in the Platform?
16:41:55 <NougatRillettes> hm, the name i'm looking for may not be vector, I meant tuples whith dependant types
16:42:06 <NougatRillettes> like Tuple 3
16:42:37 <NougatRillettes> hm, Tuple n a is (a,a,..,a) (n times)
16:43:38 <bitonic> NougatRillettes: DataKinds
16:43:51 <bitonic> or GADTs for that matter
16:43:57 <NougatRillettes> yep but they are not developped enough yet
16:44:00 <NougatRillettes> are they ?
16:44:15 <bitonic> NougatRillettes: they’re ‘developed’ enough to express what you want
16:45:07 <bitonic> Vec is the first example for any of these systems.  if you can’t do Vec you’re bust!
16:45:58 <NougatRillettes> yes, there is actually a hackage package, thanks a lot ! :)
16:46:06 <bitonic> NougatRillettes: you can even index it by a list of types, so that each element can have a different type, just like tuples
16:46:50 <NougatRillettes> ouh, nice !
16:47:02 <NougatRillettes> but I only need it with one type, thx :)
16:47:22 <NougatRillettes> (I'll use it for a SAT solver, so my type will be Keene's logic values)
16:48:16 <bitonic> NougatRillettes: well, I’d use some caution with DataKinds.  it is still quite at the edge, and you’ll make your program incompatible with the Haskell platform, so they better be useful
16:48:53 <bitonic> also, don’t get the impression that the `n' in `Vec n' is a value.  you still can’t have value parameters to data types, which is a very useful thing
16:49:04 <bitonic> and you probably will never be able to :P
16:49:25 <Nisstyre-laptop> bitonic: wouldn't that make Haskell dependently typed?
16:49:41 <bitonic> Nisstyre-laptop: it would
16:49:58 <NougatRillettes> It's only forp ersonal fun
16:50:01 <Nisstyre-laptop> yeah, I somehow doubt that will happen as well
16:51:18 <NougatRillettes> hm, kleene logic is also already provided by a package
16:51:20 <bitonic> well that has profound consequences that Haskell probably can’t afford :P
16:52:52 <Nisstyre-laptop> bitonic: well it doesn't make sense because perfectly good dependent languages already exist
16:53:26 <bitonic> Nisstyre-laptop: well... if there was a switch that would make Haskell dep. typed I/we’d turn it on
16:53:41 <Nisstyre-laptop> bitonic: doesn't Agda have Haskell as an optional target language?
16:53:43 <bitonic> and there is one dep. typed PL that is usable for real software right now (Coq)
16:54:01 <bitonic> Nisstyre-laptop: yes, but it’s very early and experimental
16:54:05 <Nisstyre-laptop> oh ok
16:54:11 <bitonic> say Haskell circa 1998 or whatever :P
16:54:24 <Nisstyre-laptop> makes sense
16:54:36 <Nisstyre-laptop> maybe it should just target the core language
16:54:53 <bitonic> the compiler is just one piece
16:54:55 <Nisstyre-laptop> avoid all that desugaring
16:55:04 <bitonic> Agda as a whole is experimental
16:56:21 <NougatRillettes> is there any language pragma to hide a module ?
16:56:34 <c_wraith> hide from what?
16:56:55 <piezoid> Idris look good too ( http://idris-lang.org/ ) , but its a young project...
16:56:56 <NougatRillettes> to prevent clashes
16:57:07 <c_wraith> clashes of what?
16:57:12 <c_wraith> modules, or names defined by the modules?
16:57:19 <geekosaur> import qualified Foo [as Bar] -- ?
16:57:41 <NougatRillettes> http://hackage.haskell.org/packages/archive/AC-Boolean/1.1.0/doc/html/Data-Boolean.html
16:58:02 <NougatRillettes> I want to prevent the clash beteween the package and the prelude bool operators
16:58:15 <geekosaur> see what I just said, then
16:58:32 <danharaj> import Prelude hiding (whatever, you, want)
16:58:38 <danharaj> although that library looks dreadful :3
16:58:47 <ezyang> Hey folks. On the poking of simonpj and afarmer, I'm going to write up some docs about http://hackage.haskell.org/trac/ghc/ticket/5129
16:59:01 <geekosaur> import qualified Data.Boolean as B -- now the things in Data.Boolean are available as B.whatever
16:59:07 <ezyang> I was wondering if anyone had opinions on the matter. It's all pretty subtle, and I may make sweeping generalizations for the sake of clarity
16:59:13 <geekosaur> and the bare names remain whatever if anything they were
16:59:30 <NougatRillettes> I will rather use danharaj solution
16:59:40 <NougatRillettes> operators are painful when qualified
17:03:01 <danharaj> NougatRillettes: I do not like my solution because I do not like the use of that library, but whatever works for you.
17:03:47 <danharaj> ezyang: After reading the notes from what I gather the subtlety is the interaction between imprecise exceptions and various forms of strictness/evaluation. Is that correct?
17:04:12 <ezyang> danharaj: Mmmmm sort of?
17:04:26 <ezyang> The way I think of it is that 'strictness' != 'when something is evaluated'
17:04:47 <quchen> How expensive is opening-writing-closing a file computationally? Suppose I want to write multiple times to a file per second, each time a small string (~ 10 characters max). Is there a large disadvantage compared to leaving the stream open between the writes compared to opening/closing once per write?
17:05:09 <ezyang> quchen: You might as well keep it open.
17:05:19 <mapreduce> Computationally inexpensive, but with non-computational delays.
17:05:21 <NougatRillettes> danharaj: this library seems very hideous but it allow me to write little code, so
17:05:23 <ezyang> But it's entirely an OS concern, plus overhead of the Haskell runtime for setting up relevant state
17:05:27 <danharaj> ezyang: That is a better way of saying it. Strictness and evaluation are distinct. Strictness is seq, evaluation is something more complicated. I am going to make a first guess that it is when the IO state token is consumed.
17:05:55 <quchen> ezyang: Leaving it open is harder. I'm talking to the GPIO pins on my RasPi using a pretty low-level interface.
17:06:01 <Nisstyre-laptop> quchen: what advantage would closing and reopening it provide you vs. writing it all "at once" ?
17:06:43 <ezyang> So, the problem is, I'm going to go and write a very theoretical explanation, and it won't help the newbie who is pressed for time and just wants to know "the right way to do it"
17:06:45 <quchen> Nisstyre-laptop: Well, I basically write something like 1 or 0 to different individual files I know the names of when the data becomes available.
17:07:07 <Nisstyre-laptop> quchen: okay, but why does that prevent you from leaving it open?
17:07:42 <quchen> Nisstyre-laptop: Nothing prevents me from doing that, but then I have to create an environment that threads the "open" state through, which should not be part of a low-level interface.
17:07:51 <monochrom> you can say: increasing strictness increases the chance of earlier evaluation, there are corner cases because the optimizer has its opinion too
17:08:11 <quchen> Anyway, thanks guys
17:08:34 <ezyang> monochrom: Well, it's well defined how "late" the optimizer is allowed to push it
17:08:44 <ezyang> (e.g. the denotation of the expression must always be respected)
17:08:45 <Nisstyre-laptop> quchen: why would you need concurrency?
17:08:54 <ezyang> "Use strict returns ( return $! ...) unless you absolutely need them lazy." <-- who wrote that?!
17:09:08 <Nisstyre-laptop> I guess you might want non-blocking I/O?
17:09:27 <ezyang> Gosh, and the second bullet-point in additional tips is totally wrong; -hc does NOT give you retainer profiling
17:09:40 <danharaj> that would be -hr :<
17:09:53 <danharaj> (P.S.... where are you reading this?)
17:10:03 <ezyang> http://www.haskell.org/haskellwiki/Performance
17:10:06 <ezyang> (bottom)
17:10:13 <monochrom> a strictness or eagerness bigot wrote "use return$!...", clearly :)
17:10:38 <c_wraith> I'm pretty sure I've seen that in stuff tibbe or bos have written on performance
17:10:54 <monochrom> otoh, "writeIORef v (x+1)" has a known problem
17:10:56 <ezyang> I mean, it is not obviously wrong
17:11:06 <ezyang> but the correct way to fix it is to use a strict monad
17:11:17 <ezyang> rather than try to remember to use return $! rather than return everywhere
17:11:22 <ezyang> ditto with the IORef problem
17:11:23 <c_wraith> uh.  what do you mean by "strict"?
17:11:29 <tibbe> c_wraith: likely
17:12:00 <ezyang> Or maybe I'm wrong?
17:12:01 <tibbe> ezyang: does the strict monad obey the monad laws?
17:12:03 <c_wraith> because Control.Monad.State.Strict won't change anything there
17:12:04 <ezyang> This is all too subtle for me.
17:12:10 <ezyang> OK, I'm wrong.
17:12:23 <monochrom> Control.Monad.State.Strict is not a strict monad anyway
17:12:33 <ezyang> But I still don't see why 'return $!' is going to help you in most cases.
17:12:37 <tibbe> no, it's confusinglyy named
17:12:43 <tibbe> it's not strict in the state
17:12:57 <tibbe> ezyang: because return usually pushes something behind a data constructor
17:13:14 <tibbe> ezyang: e.g. look at return $ 1 + 2 and return $! 1 + 2 for the State monad
17:13:19 <monochrom> ok, strictness means: f ⊥ = ⊥. but read on
17:13:29 <c_wraith> heck, State doesn't even have a data constructor
17:13:35 <tibbe> ezyang: in one case you get (1 + 2, state)
17:13:39 <tibbe> in the other eval first
17:13:43 <ezyang> tibbe: Yes, but it'll get destructed real quick soon.
17:13:43 <tibbe> gotta get off shutttle
17:13:48 <tibbe> maybe
17:14:07 <ezyang> afk for a moment
17:14:30 <monochrom> this definition is totally cool when the function arity is 1. what if g :: X -> Y -> Z? "g is strict" is ambiguous and completely uninformative.
17:14:45 <danharaj> I am rather curious about this statement by spj: " If you want exception ordering, or space-leak squashing, then evaluate is better."
17:14:52 <danharaj> (better than seq, that is)
17:15:14 <danharaj> The exception ordering I understand. The space-leak part, I am not sure what the semantics of evaluate are.
17:15:24 <monochrom> the State monad is even more complex than 2-ary functions. Control.Monad.State.Strict is strict, but not in what you think
17:16:11 <danharaj> monochrom: A function is 'strict in an argument'.
17:16:12 <monochrom> you have to look at its >>= details to see what it is strict in
17:16:37 <danharaj> monochrom: but that is still rather murky since things can be returned in WHNF but still have secret strictness.
17:16:41 <monochrom> yes yes yes, and do you have a better name for Control.Monad.State.Strict?
17:16:53 <danharaj> No :<
17:17:01 <monochrom> Control.Monad.State.Strict_in_______ fill in the blanks?
17:17:02 <danharaj> I don't know what it is strict in.
17:17:54 <monochrom> so, allow me to write in terms of the mtl-1.* State monad, it's less clutter
17:19:15 <monochrom> State t >>= f = State (\s0 -> case t s0 of (a, s1) -> runState (f a) s1)  does that look right?
17:19:27 <monochrom> it is strict in "t s0"
17:19:54 <monochrom> Control.Monad.State.Nonstrict can be defined by: State t >>= f = State (\s0 -> case t s0 of ~(a, s1) -> runState (f a) s1)  does that look right?
17:20:18 <monochrom> although in reality they use "let" instead of "case ... ~".
17:20:28 <danharaj> mm
17:21:04 <joeyh> are there ever places where it makes sense to use the lazy State monad rather than strict? (Having been burned by this space leak once myself.)
17:21:18 <monochrom> also, they call it Lazy, which is clearly a cognitive dissonance. Strict vs Lazy? see the problem?
17:21:23 <danharaj> monochrom: but State t is (a -> (a,s)) more or less, so it just means that the tuple is put in WHNF between binds?
17:21:57 <monochrom> yes
17:22:07 <c_wraith> joeyh: When you're doing calculations that depend on future state.
17:22:20 <joeyh> hmm, interesting
17:22:25 <c_wraith> joeyh: so long as you can knot-tie appropriately
17:22:56 <danharaj> State.Strict has a MonadFix instance.
17:23:08 <danharaj> Or do you mean something else c_wraith?
17:23:31 <monochrom> I have an example of Lazy
17:23:46 <monochrom> http://hpaste.org/41790/
17:24:32 <monochrom> but I also have a surprise answer. did you know: Control.Monad.State defaults to Lazy
17:24:45 <danharaj> yes
17:25:00 <monochrom> YES! all the past 10 years you have been using Lazy without knowing!
17:25:02 <joeyh> I do. After having been burned by it and getting to learn all about profiling ;)
17:25:08 <danharaj> monochrom: know I haven't :P
17:25:09 <joeyh> it seems to beg for such newbie mistakes..
17:25:11 <danharaj> no*
17:26:22 <monochrom> in any case, my example shows applications where it must be absolutely Lazy. although, perhaps you don't need such applications
17:27:07 <monochrom> most people treat State as "I'm back in imperative programming again", and so State.Strict is right
17:27:43 <NougatRillettes> when trying this : http://paste.awesom.eu/VKr I got this : http://paste.awesom.eu/bFK
17:27:59 <NougatRillettes> Am I trying things too complicated at type-level ?
17:28:00 <c_wraith> I just find State to rarely be what I actually want, so I don't end up using it much.
17:28:55 <danharaj> monochrom: I do very like your examples.
17:29:15 <monochrom> thank you! they're fun :)
17:29:22 <danharaj> monochrom: they are anamorphism flavored
17:32:09 <joeyh> oh wow. I refreshed my memory on the space leak I had run into, and it's actually in mtl's Control.Monad.State.Strict
17:32:11 <joeyh> modify f = state (\s -> ((), f s))
17:33:30 <joeyh> so repeatedly modifying state can give you a nice tower of thunks, even in the strict one
17:33:36 <monochrom> yeah, modify won't bother hastening f s, Strict or Lazy. you have to write your own modify_strict
17:33:46 <joeyh> which I did. surely that's a bug though
17:34:24 <danharaj> send a patch to edwardk
17:35:06 <danharaj> https://github.com/ekmett/mtl/issues/2
17:50:27 <lispy> is this enough to make it sufficiently strict? modify f = state (\s -> ((), f $! s))
17:52:23 <c_wraith> lispy: no.
17:52:37 <c_wraith> that does exactly nothing unless the state value is forced
17:55:23 <ezyang> back
17:56:18 <ezyang> I'm not a big fan of the state monad; let's talk about writer instead
17:57:45 <lispy> c_wraith: ah, I see. A bang pattern on s would actually be more to the point
17:58:52 <ezyang> Actually, this is all a big tangent to the issue of #5129
17:59:01 <c_wraith> lispy: indeed it would
17:59:07 <lispy> ezyang: in which bug tracker?
17:59:15 <ezyang> http://hackage.haskell.org/trac/ghc/ticket/5129
18:08:59 <lispy> ezyang: I find that commentary interesting but unsatisfying
18:09:30 <ezyang> Yeah, we want to figure out what the distilled lesson is
18:10:35 <wollw> is there a more elegant way to bind two monadic values to the inputs of a function that takes two values than something like this? "getLine >>= (\s -> getLine >>= foo s)"
18:11:01 <ezyang> foo <$> getLine <*> getLine
18:11:09 <wollw> ah
18:11:12 <ezyang> oh, but foo is monadic
18:11:17 <wollw> yeah
18:12:14 <wollw> i'm not actually using getLine in my code either, that's just a contrived example
18:12:16 <khanzor> hi all, i have a problem with a cabal install (althought the question is more general), is this the right place to ask it?
18:12:48 <lispy> khanzor: definitely
18:12:52 <ezyang> join (foo <$> getLine <*> getLine)
18:12:57 <khanzor> lispy: :)
18:13:54 <khanzor> i'm on osx, and i'm trying to build SDL-ttf. I have it installed via homebrew, but the configure step that cabal is taking doesn't find the paths that brew uses
18:14:16 <khanzor> even though i'm using --extra-lib-dirs and --extra-include-dirs
18:14:17 <lispy> ezyang: that thread makes me think that we've been using seq incorrectly all these years and we really wanted a different abstraction.
18:14:21 <wollw> ezyang: thanks, i'll take a look at this
18:15:08 <Taslem> Anyone have any experience using Haskell with SDL?
18:15:10 <khanzor> is there someway i can find out the options i need to pass through? sorry if that question doesn't make sense...
18:15:11 <lispy> khanzor: a common trick for debugging this is to say --verbose=n (where n = 2 or 3, depending on your ability to stomach verbosity)
18:15:49 <ezyang> OK, I think I will start a ghc-devs thread instead.
18:16:19 <khanzor> lispy: hmm
18:16:33 <khanzor> lispy: it's the configure step of the actual build
18:16:48 <khanzor> lispy: but i gave it a shot, and it looks like my sdl-config might be the culprit :)
18:16:48 <lispy> ezyang: seq links evaluation (which can certainly be useful) but we often use seq where what we want is, "whnf please"
18:16:53 <khanzor> lispy: thank you!
18:17:21 <lispy> khanzor: you're welcome. Glad I could pointyou in the right direction
18:44:25 <ezyang> I kind of suspect that if we were really pedantic, we'd have a variant of seq which guarantees the 'evaluatedness' of its arguments
18:45:12 <ezyang> as it stands, it's OK for 'evaluate (a `seq` bottom)' to not actually end up carrying out 'evaluate a'
18:46:14 <danharaj> ezyang: is the documentation for evaluate in Control.Exception.Base completely characteristic of evaluate?
18:46:26 <ZFox> How would you make a default value for DateTime / UTCTime ?
18:46:32 <ZFox> i.e epoc 0
18:46:44 <danharaj> ZFox: what do you mean?
18:46:56 <ezyang> I don't know. The docs could be wrong.
18:47:24 <danharaj> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception-Base.html#v:evaluate
18:47:57 <ZFox> DateTime package. data A = A DateTime String let a = A something "somedefaultstring"
18:48:19 <ezyang> Hm! The semantics end up being OK, though in a not very satisfying way.
18:48:49 <ZFox> DateTime package. data A = A { c :: DateTime, d :: String } let a = A something "somedefaultstring"
18:48:53 <danharaj> ZFox: So do you want a toplevel binding called, perhaps, defaultDateTime and bind it to whatever you like?
18:49:06 <ZFox> so one could do let b = a { d = "test" }
18:49:16 <ZFox> danharaj: Yea more or less.
18:49:23 <danharaj> well, that's how you would do it :P
18:49:37 <danharaj> defaultDateTime = ...
18:49:54 <danharaj> ezyang: The first equation is rather striking. I bet you could write a lot about how it is implemented.
18:49:54 <ZFox> Problem >> How to define a dateTime as zero epoc
18:49:59 <ZFox> Or to just satisy the
18:50:00 <ZFox> ugh
18:50:04 <ZFox> undefined maybe?
18:50:11 <danharaj> you do not want that
18:50:38 <ezyang> Actually, the first equation is the one that makes perfect sense to me.
18:50:54 <ZFox> danharaj: Why can't undefined be valid?
18:51:16 <danharaj> ZFox: well undefined is valid in the sense that it would compile, but I don't think it has the semantics you want?
18:51:37 <ZFox> Placeholder before I really define it
18:51:56 <danharaj> oh, yes! you can do that.
18:52:10 <danharaj> however you ought to be careful with those, you might forget them :)
18:52:34 <danharaj> ezyang: I am not sure how (evaluate undefined) `seq` 1 would work.
18:52:55 <ZFox> danharaj: Hehe
18:54:16 <danharaj> (of course that isn't well typed but you get what I mean? :3)
18:54:42 <ZFox> danharaj: In the sense for a default.. Does it really matter?
18:54:51 <elliott> danharaj: that is well-typed, I think?
18:54:52 <danharaj> ZFox: sorry that was to ezyang
18:54:55 <ZFox> Ah
18:55:03 <danharaj> elliott: evaluate :: a -> IO a
18:55:06 <danharaj> ohh
18:55:08 <danharaj> ohhhhh
18:55:10 <danharaj> yes. very yes.
18:55:21 <danharaj> I get it now.
18:55:22 <ezyang> danharaj: It's obvious
18:55:39 <danharaj> I had a weird idea in my head.
18:55:50 <ezyang> But soooo not obvious at the same time.
18:56:34 <ezyang> Can someone point me to an explication of why "strict" monads fail the monad laws?
18:57:23 <danharaj> ezyang: (return $! undefined) >>= k
18:57:42 <danharaj> == k a
18:57:56 <hpaste> mikeplus64 pasted “heteromorphisms?” at http://hpaste.org/83708
18:58:00 <danharaj> (rather, it is *supposed* to.)
18:58:13 <danharaj> ezyang: I may be wrong. I am very bad at seq's semantics.
18:58:16 <ezyang> I think you have a typo
18:58:31 * ZFox laughs at undefined's definition
18:58:58 <cdntr> chrisdone: An option to reverse the reading direction for the IRC logs would be nice. :-)
18:59:02 <danharaj> ezyang: hm?
18:59:10 <ezyang> a looks unbound
18:59:18 <danharaj> oh yeah
18:59:22 <danharaj> sorry. k undefined
18:59:39 <danharaj> I wrote out the monad law and then replaced a with undefined on one side :3
19:02:13 <alyx_> I know this is a big ask, but is anyone interested in checking out my first haskell project and offering any advice on my newbie code?
19:02:15 <alyx_> https://github.com/0x20/fembot/tree/master/src
19:02:21 <alyx_> it's an IRC bot, 440~ lines
19:05:37 <ZFox> alyx_: Nice job for a first
19:05:52 <wollw> certainly cleaner than my haskell irc bot was
19:06:04 <alyx_> :) thanks
19:06:35 <wollw> or my current project for that matter... heh
19:06:51 <ZFox> alyx_: I suggest typing the irc protocol.
19:06:53 <ZFox> Like this..
19:07:14 <ZFox> http://ix.io/4q9
19:07:17 <ZFox> Fun fun fun
19:07:41 <danharaj> which fragment of IRC is that.
19:07:43 <danharaj> ;)
19:07:52 * ZFox hasn't gotten that far on that little bit of code... Intended to get a full irc protocol binding into haskell.
19:07:57 <ezyang> Hmm, I bet data Foo a = Foo is a monad.
19:08:00 <ZFox> danharaj: Fragment? ALL :D
19:08:03 <ZFox> Well almost
19:08:32 <ZFox> ezyang: That reminds me of Maybe a = Nothing
19:08:34 <danharaj> ezyang: You would be correct, perhaps trivially ;)
19:08:54 <ezyang> The unusual thing about this monad is that >>= does not need to be strict in the first argument.
19:09:02 <geekosaur> if you're really doig it right, you don't just encode the protocol messages in the type system, you encode the protocol
19:09:07 <geekosaur> state machine
19:09:27 <geekosaur> so the type system won't let you make an invalid response/state transition
19:09:38 <elliott> ezyang: Proxy is a monad, yes
19:09:39 <ZFox> Yea
19:09:40 <elliott> (it's in the tagged package)
19:09:44 <elliott> discarding bottoms, of course
19:09:57 <ZFox> Lots of work but sure worth it geekosaur
19:10:21 <ezyang> elliott:Arr! And here I was hoping that I could assume >>= must be strict in the first argument
19:10:21 <danharaj> alyx_: illegalCharacters could be defined more succinctly using find and isJust
19:10:22 <ZFox> geekosaur: Was kinda the plan but never got around to doing much more than that
19:10:39 <danharaj> alyx_: (In Commands.hs)
19:11:18 <elliott> ezyang: that doesn't even hold for Reader
19:11:41 <ezyang> ah, so it seems
19:12:35 <elliott> (which means Reader violates (m >>= return) = m if you allow bottoms and seq)
19:12:57 <alyx_> danharaj: thanks! just changed it
19:14:42 <gertc> https://github.com/eagletmt/ghcmod-vim the screenshot of ghcmpdexpand what does this splicing stuff mean? [Database....
19:14:45 <danharaj> alyx_: sorry, I didn't give you the whole story. Your new version finds a legal character. You need to negate things.
19:15:25 <alyx_> oh, wups :P
19:15:27 * alyx_ changes again
19:16:04 * ZFox wonders why print is defined like this... print x         =  putStrLn (show x)
19:16:05 <gertc> s/GhcModExpand
19:16:11 <ZFox> Why not print = putStrLn . show ?
19:16:54 <parcs> ZFox: where is it defined like that?
19:17:00 <Raynes> Yo.
19:17:07 <ZFox> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/System-IO.html#print
19:17:57 <geekosaur> probably just to avoid the DMR?
19:18:32 <ZFox> hPrint hdl      =  hPutStrLn hdl . show
19:18:44 <ZFox> Same file, no dependancy issues with . in import loops
19:19:05 <ZFox> hPrint is defined better than print :P
19:19:11 <danharaj> alyx_: I am bad at this helping business. You need to negate inside the find function too! Sorry :P
19:19:35 <danharaj> Then your code reads roughly: "I cannot find an illegal character"
19:19:51 <parcs> ZFox: i doubt there's any real reason to it. looking at the revision history, the definition of 'print' has stayed the same for 12 years.
19:20:09 <ZFox> parcs: So.. Due an update :P
19:20:17 <danharaj> alyx_: also I just realized there is an isNothing function so you can use that instead of `not . isJust` because they are exactly the same.
19:20:56 <danharaj> alyx_: Can you tell I've never suggested improvements to someone else's code before? :3
19:21:25 <parcs> ZFox: don't fix what ain't broken
19:21:27 <parcs> :)
19:21:38 <ZFox> Not point free!
19:21:54 <alyx_> danharaj: hehe :3 np
19:22:47 <danharaj> alyx_: this version is going to be nicer to read and also conceptually simpler. In fact, this version does less work than the other. You should work this out: the first version has to examine every character. This version will stop as soon as it finds an illegal character if there is one.
19:22:52 <jmcarthur> ezyang: Cont isn't strict in its first argument either, iirc
19:23:09 <jmcarthur> err, Cont's (>>=), that is
19:26:51 <danharaj> alyx_: replaceAll is well written, but you can replace the conditional in your second case with "find `isPrefixOf` xs" if you want. I feel this would be a bit nicer.
19:28:46 <alyx_> danharaj: oh, I just found that function on google, I was amazed there was nothing like it in the standard library
19:28:49 <alyx_> changing it though, ty
19:29:20 <danharaj> alyx_: The Prelude itself is missing a lot of nice functions, but you can often find what you want in one of the libraries that comes in the base package.
19:32:19 <danharaj> alyx_: This is purely preference but in listDictionary I would replace (++) "Available words: " with ("Available words: " ++), that is, a section. I bet if you're from Lisp then you like what you've written though. :P
19:33:18 * hackagebot lagrangian 0.3.0.0 - Solve lagrange multiplier problems  http://hackage.haskell.org/package/lagrangian-0.3.0.0 (JonathanFischoff)
19:33:34 <alyx_> danharaj: oh, that definitely makes it more readable
19:35:13 <ZFox> genToken >>= \t -> putStr . show $ t { comment = T.pack "test" }
19:35:20 <ZFox> Can anyone see any way that could be cleaned up?
19:35:37 <ZFox> Eh nvm. I can pass getToken the comment meh
19:35:39 <ZFox> ^_^
19:35:47 <danharaj> alyx_: in listInbuilt, you do not have to give names to the variables f and h in your map. It would be clearer if you wrote (map (\(k, _, _) -> k) inbuilt) to leave no doubt that you don't care about the other elements of the tuple.
19:37:27 <danharaj> alyx_: also, have you heard of HLint? It is a tool that will probably make way better minor fiddling suggestions than I will.
19:37:55 <alyx_> danharaj: yup :) I've been using it
19:38:09 <danharaj> tsk on HLint for not picking up dummy variables!
19:40:44 <alyx_> mmhmm, I know about them, haven't quite managed to get it into "muscle memory" yet though
19:40:49 <alyx_> just something that takes time, I suppose
19:40:53 <ParahSail1n> hm, im not so good with haskell on windows-- im trying to install network using cabal, but it requires me to use cygwin/mingw to run a configure script
19:41:17 <ParahSail1n> having a hard time running runhaskell Setup.hs configure manually, because its not detecting any packages
19:41:47 <ParahSail1n> where is that environment info encoded
19:41:48 <parcs> anybody familiar with core? what is the point of coercions in core?
19:41:49 <danharaj> alyx_: eventually you realize every letter is a precious resource and the latin alphabet is much too small for Haskell programmers.
19:42:38 <alyx_> heh
19:43:09 <danharaj> alyx_: bear with me on the next two modules, I have to go learn what Conduit actually does.
19:43:19 <danharaj> (I knew this day would come.)
19:45:19 <alyx_> just realised conduit is needlessly imported as qualified
19:45:59 <alyx_> and other modules, hmm
19:46:02 <alyx_> wonder how that happened...
19:46:10 <danharaj> alyx_: on line 38 I would add a space so it is more obvious that that line is part of the parentheses grouping started on the previous line.
19:47:15 <alyx_> danharaj: done :)
19:49:01 <Saizan> ParahSail1n: pass --user to it
19:49:22 <ZFox> alyx_: For your { from  :: String, contents :: String } etc.. Format them downwards
19:50:01 <Saizan> parcs: it's to implement newtypes, type families and gadts
19:50:27 <elliott> unsafeCoerce too :p
19:50:38 <Saizan> heh, yeah
19:51:18 <ParahSail1n> Saizan, runhaskell.exe Setup.hs --user configure results in Setup.hs: At least the following dependencies are missing:
19:51:18 <ParahSail1n> base >=3 && <4.4
19:51:22 <danharaj> alyx_: you will notice a lot of code duplication in getHTMLFromURL. Indeed you can factor out (>> getHTMLFromURL url (retry - 1)) and map it over your list of Handlers.
19:51:25 <Saizan> ParahSail1n: btw, network is in the haskell platform i believe, which has a binary distrubution for windows
19:51:37 <danharaj> alyx_: that is up to you though. I think it looks fine the way it is, although perhaps error prone?
19:51:55 <danharaj> it is actually more complicated than what I just said.
19:52:03 <ParahSail1n> Saizan, hm, not for me
19:52:35 <Saizan> ParahSail1n: what do you mean?
19:52:53 <danharaj> alyx_: ah, how about this simple solution: you could name getHTMLFromURL ... to, perhaps tryAgain or something like that?
19:53:10 <ParahSail1n> oh, hm, it is, so i wonder why trying to install io-streams cabal thought it needed network
19:53:16 <wollw> I'm writing some bindings that work with a few different libraries and I'm finding myself using (read . show) to pass values to functions with a different type alias for (in this case) CInt...  I get the feeling using (read . show) isn't exactly the best solution.
19:53:43 <geekosaur> toEnum . fromEnum
19:53:45 <Saizan> maybe it needs a different version
19:53:47 <danharaj> wollw: type synonyms can be interchanged. newtypes cannot.
19:53:49 <geekosaur> which will usually be optimized away
19:54:00 <geekosaur> fromIntegral may also be sufficient
19:54:04 <wollw> ah
19:54:10 <wollw> thanks
19:54:54 <wollw> Ah, it's a CUInt and CInt, that's why it wasn't working
19:54:55 <geekosaur> (should be sufficient but occasionally I run into things that are Enum but not Integral. thankfully that's rare these days)
19:56:10 <wollw> yeah, fromIntegral fits the bill
19:56:32 <ParahSail1n> Saizan, i have two different package.conf.d's showing up in ghc-pkg list
19:56:48 <ParahSail1n> one seems to be the original Platform one, the second is stuff i installed
19:57:42 <ParahSail1n> Saizan, oh, yeah its a version thing-- needs 2.4 and platform provides 2.3
19:58:18 * hackagebot lagrangian 0.3.0.1 - Solve lagrange multiplier problems  http://hackage.haskell.org/package/lagrangian-0.3.0.1 (JonathanFischoff)
19:58:25 <danharaj> alyx_: I hope that the password in main.hs is a dummy!
19:58:45 <alyx_> danharaj: yes :P
20:00:37 <danharaj> alyx_: splitWhen f == span (not . f)
20:00:51 <danharaj> (yes it is silly that it is named differently from split*)
20:01:00 <alyx_> danharaj: do you mean like this? http://codepad.org/ly8NhFxl
20:02:03 <arkeet> danharaj: = break f
20:02:05 <alyx_> aaaaahhh... span
20:02:19 <danharaj> arkeet: touche
20:02:40 <alyx_> break, even :P
20:02:53 <danharaj> alyx_: http://hpaste.org/83710
20:02:57 <danharaj> something like that
20:03:12 <arkeet> > break even [1,3,4,7,8]
20:03:14 <lambdabot>   ([1,3],[4,7,8])
20:03:29 <danharaj> It is annoying that your elements are identical save for a type, but I am not sure what would be slicker. Perhaps arkeet has an idea? ;)
20:03:35 <arkeet> you should try to profit, not just break even, though
20:03:48 <arkeet> danharaj: ?
20:04:04 <arkeet> ahh
20:04:08 <arkeet> use Control.Exception.Lens
20:04:08 <arkeet> :p
20:04:12 <arkeet> or not
20:06:04 <danharaj> alyx_: on line 100 you define an operator +~ which is the monoid operation for bytestring. Instead, import Data.Monoid and use (<>)
20:06:05 <arkeet> see http://hackage.haskell.org/packages/archive/lens/latest/doc/html/Control-Exception-Lens.html#g:5
20:06:13 <arkeet> for an example with catches and multiple handlers.
20:06:15 <arkeet> :p
20:06:31 <danharaj> arkeet: I am not sure how much I condone encouraging people to drink the lens kool-aid :P
20:06:35 <arkeet> :p
20:07:25 <arkeet> hmm, I found a typo in the docs
20:07:34 <danharaj> "-- Either I'm doing something wrong, or Freenode is dropping messages before the 510 characters are up..." It's IRC. Is there ever a conforming implementation?
20:08:13 <alyx_> I'm not sure I understand Control.Exception.Lens at all
20:08:18 * hackagebot vector-heterogenous 0.0.2 - A type-safe library for vectors whose elements can be of any type, or any type satisfying some constraints  http://hackage.haskell.org/package/vector-heterogenous-0.0.2 (MikeIzbicki)
20:08:30 <danharaj> alyx_: there are like 3 people who do
20:08:43 <danharaj> anywho, you also use append on line 135, that can be replaced with (<>)
20:08:43 <alyx_> haha
20:08:50 <danharaj> @quote lens
20:08:50 <lambdabot> No quotes match. My pet ferret can type better than you!
20:08:50 <alyx_> danharaj: yep, just changed that :)
20:09:01 <danharaj> @quote edwardk
20:09:01 <lambdabot> edwardk says: the gf obeys a paraconsistent logic, so given a contradiction you can't actually go an really prove everything like you can in classical logic, which always makes it hard to refute a
20:09:01 <lambdabot> claim via contradiction.
20:09:25 <arkeet> oh what do you know, it's already been fixed.
20:09:58 <arkeet> alyx_: it's easy, just look at the example for the handler function
20:10:23 <arkeet> or handler_
20:10:28 <danharaj> There is one particular quote I want. Give it to me lambdabot.
20:10:34 <danharaj> @quote shachaf lens
20:10:35 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
20:10:39 <danharaj> @quote shachaf
20:10:39 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
20:10:44 <danharaj> oh well.
20:10:49 * danharaj throws his hands up
20:11:11 <arkeet> the point is that you can just hand it a prism (= first-class pattern) like _IOException
20:11:58 <danharaj> "shachaf says: The trouble with the lens rabbit hole is that there are a few of us here at the bottom, digging."
20:12:25 <arkeet> heh
20:12:44 <alyx_> "A Prism l is a 0-or-1 target Traversal that can also be turned around with re to obtain a Getter in the opposite direction."
20:12:47 <alyx_> wat
20:13:10 <arkeet> "0-or-1 target traversal" means you can match on it and it may or may not succeed.
20:13:19 <arkeet> "turn around to obtain a getter" means you can construct things.
20:13:21 <danharaj> alyx_: lens is a highly experimental library that is populated by extremely sophisticated versions of record accessors.
20:13:34 <danharaj> and by extremely sophisticated I mean they are rank 2.
20:13:52 <arkeet> you make it sound scary.
20:14:00 <arkeet> ...it is scary.
20:14:01 <arkeet> :p
20:14:04 <danharaj> it is 12 scary.
20:14:08 <arkeet> but in a different way.
20:14:34 <arkeet> it's easy to use, but not so easy to understand. :p
20:14:46 <danharaj> alyx_: anyhow, provided all my terrible suggestions compile, this code is better written than what I produce. brd be with you.
20:14:53 <ZFox> @pl x a = run a b c
20:14:53 <lambdabot> x = flip (flip run b) c
20:15:08 <arkeet> :t preview _Just -- for matching
20:15:10 <lambdabot> MonadReader (Maybe a) m => m (Maybe a)
20:15:13 <arkeet> ugh
20:15:24 <arkeet> :t preview _Just :: Maybe a -> Maybe a
20:15:25 <lambdabot> Maybe a -> Maybe a
20:15:26 <alyx_> hehe
20:15:28 <alyx_> brd be with you
20:15:32 <arkeet> ugh, silly.
20:15:38 * danharaj once used the term \f x -> (<*>) <$> (((:<<) <$>) <$> x) <*> f with a straight face.
20:15:39 <arkeet> :t preview _Left :: Either a b -> Maybe a
20:15:41 <lambdabot> Either a b -> Maybe a
20:15:44 <arkeet> :t review _Left :: a -> Either a b
20:15:45 <lambdabot> a -> Either a b
20:16:03 <arkeet> :t preview (_Left . _Just) :: Either (Maybe a) b -> Maybe a
20:16:05 <lambdabot> Either (Maybe a) b -> Maybe a
20:16:11 <arkeet> :t review (_Left . _Just) :: a -> Either (Maybe a) b
20:16:13 <lambdabot> a -> Either (Maybe a) b
20:16:47 <arkeet> so I guess you could call them first-class composable patterns.
20:17:32 <arkeet> like how lenses are first-class composable record accessors.
20:18:22 <arkeet> > 5 ^. re (_Left . _Just)
20:18:25 <lambdabot>   Left (Just 5)
20:18:31 <arkeet> > Right () ^? _Left . _Just
20:18:33 <lambdabot>   Nothing
20:18:35 <arkeet> > Left Nothing ^? _Left . _Just
20:18:38 <lambdabot>   Nothing
20:18:39 <arkeet> > Left (Just 5) ^? _Left . _Just
20:18:41 <lambdabot>   Just 5
20:19:35 <arkeet> > _Left . _Just # 5
20:19:37 <lambdabot>   Not in scope: `#'
20:19:39 <arkeet> bah
20:19:43 <arkeet> > _Left . _Just Lens.# 5
20:19:44 <lambdabot>   Not in scope: `Lens.#'
20:19:45 <lambdabot>  Perhaps you meant one of these:
20:19:45 <lambdabot>    `Lens.&' (import...
20:19:56 <arkeet> @let (#) = review
20:19:59 <lambdabot>  Defined.
20:20:01 <arkeet> > _Left . _Just # 5
20:20:02 <lambdabot>   <local>:2:3: parse error on input `)'<local>:2:3: parse error on input `)'
20:20:04 <arkeet> great.
20:20:08 <arkeet> @undefine
20:20:11 <arkeet> @let ( # ) = review
20:20:14 <lambdabot>  Defined.
20:20:14 <arkeet> > _Left . _Just # 5
20:20:16 <lambdabot>   Precedence parsing error
20:20:17 <lambdabot>      cannot mix `L..' [infixr 9] and `L.#' [infixl...
20:20:21 <arkeet> @undefine
20:20:38 <parcs> is every sub expression in core given a type annotation?
20:20:40 <arkeet> @let ( # ) = review; infixr 9 #
20:20:42 <lambdabot>  Defined.
20:20:43 <arkeet> > _Left . _Just # 5
20:20:46 <lambdabot>   No instance for (GHC.Num.Num (p0 a0 (f0 b0)))
20:20:46 <lambdabot>    arising from a use of `e_1...
20:20:54 <arkeet> :t ( # )
20:20:55 <lambdabot> MonadReader b m => AReview s t a b -> m t
20:21:04 <arkeet> > _Left . _Just # "hi"
20:21:06 <lambdabot>   Couldn't match type `GHC.Types.Char' with `f0 b0'Couldn't match type `[]' w...
20:21:11 <arkeet> I am confused.
20:21:26 <arkeet> > (#) (_Left . _Just) "hi"
20:21:29 <lambdabot>   <hint>:1:3: parse error on input `)'
20:21:30 <arkeet> > ( # ) (_Left . _Just) "hi"
20:21:32 <lambdabot>   Left (Just "hi")
20:21:44 <arkeet> I blame elliott.
20:21:53 <danharaj> Cale: why does lambdabot hate #
20:22:17 <arkeet> MagicHash
20:22:32 <danharaj> lambdabot shouldn't do MagicHash it'll mess with her mind.
20:22:32 <elliott> arkeet: you mean *shachaf*
20:22:39 <parcs> :t (# #)
20:22:41 <lambdabot> a -> (# a #)
20:22:42 <arkeet> > _Left . _Just `review` "hi"
20:22:44 <lambdabot>   Precedence parsing error
20:22:44 <lambdabot>      cannot mix `L..' [infixr 9] and `Control.Lens...
20:22:55 <arkeet> @let rev = review; infixr 9 `rev`
20:22:58 <lambdabot>  Defined.
20:23:00 <arkeet> > _Left . _Just `rev` "hi"
20:23:02 <lambdabot>   Couldn't match type `GHC.Types.Char' with `f0 b0'Couldn't match type `[]' w...
20:23:10 <arkeet> ohhh.
20:23:14 <arkeet> > (_Left . _Just) # "hi"
20:23:17 <lambdabot>   Left (Just "hi")
20:23:19 <elliott> i tried to stop edwardk using (#), by the way
20:23:29 <arkeet> why is # infixr 9?
20:24:00 <lightquake> what's the portable way to get the parent directory of a directory?
20:24:40 <danharaj> lightquake: hahahahahaha yeaahhh
20:24:59 <lightquake> is there nothing better than dir </> ".."?
20:24:59 <danharaj> # is backwards $
20:25:07 <arkeet> </> ".." should work on unix+windows
20:25:07 <danharaj> lightquake: does that even work in windows
20:25:14 <lightquake> i don't know, actually
20:25:20 <danharaj> I believe arkeet.
20:25:28 <danharaj> Despite the fact that he's one of the Lens people.
20:25:33 <lightquake> it looks like system-filepath is the new hotness
20:25:34 <elliott> no, backwards ($) is (&)
20:25:45 <arkeet> (#) is review.
20:26:03 <danharaj> elliott: oh I was confused because other people use # where you guys use &. I don't know what # is.
20:26:24 <arkeet> it's review.
20:26:26 <arkeet> it's for reviewing.
20:26:30 <arkeet> > _Just # 3
20:26:32 <lambdabot>   Just 3
20:26:33 <arkeet> > _Right # 3
20:26:36 <lambdabot>   Right 3
20:26:52 <arkeet> > _Cons # ('h', "ello")
20:26:54 <lambdabot>   "hello"
20:27:51 <arkeet> > "abc" ^? _Cons
20:27:53 <lambdabot>   Just ('a',"bc")
20:27:54 <arkeet> > "" ^? _Cons
20:27:56 <lambdabot>   Nothing
20:28:19 * hackagebot publicsuffixlist 0.0.4 - Is a given string a domain suffix?  http://hackage.haskell.org/package/publicsuffixlist-0.0.4 (MylesMaxfield)
20:29:13 <danharaj> That package that just got uploaded has a type called DataStructure.
20:36:05 <ZFox> Ahh this again -_- Does anyone here know of any examples using Network.Socket to listen on a unixsocket ?
20:36:19 <ZFox> Listen as in server/daemon, not client.
20:38:49 <zachk> @pl \x y -> pure (,) <*> x <*> y
20:38:49 <lambdabot> (<*>) . (pure (,) <*>)
20:38:53 <zachk> mmmm
20:38:55 <zachk> :D
20:39:33 <zachk> interesting its almost "seems" like reverse polish notation stacks using parentheses for recursive depth...
20:39:35 <zachk> anyways
20:40:19 <danharaj> @pl \x y -> (,) <$> x <*> y
20:40:19 <lambdabot> (((,) <$>) .) . (<*>)
20:40:26 <newsham> http://www.thenewsh.com/~newsham/x/postfix.hs
20:40:35 <c_wraith> I'd rather write that as liftA2 (,)
20:40:48 <zachk> personally, I have been getting way from $ overall alot in my code for some reason except for like the
20:40:59 <ZFox> @unpl (<*>) . (pure (,) <*>)
20:40:59 <lambdabot> (\ d -> (<*>) ((pure (,)) <*> d))
20:41:02 <ZFox> zachk: :)
20:41:30 <newsham> zachk: conserving your cash?
20:41:40 <danharaj> c_wraith: but haskell line noise has so much potential
20:42:02 <zachk> > nub . sort . reverse . enumFrom to 0 . ([1..10] ++) $ [1..10]
20:42:04 <lambdabot>   The function `GHC.Enum.enumFrom' is applied to two arguments,
20:42:04 <lambdabot>  but its type...
20:42:58 <zachk> > nub . sort . reverse $ ([1..10] ++ [1..10])
20:43:01 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
20:43:11 <zachk> I like that notational pattern, alot...
20:43:13 <zachk> way way too much
20:43:21 <zachk> its tricky to write at first
20:43:28 <zachk> but oh so easy to read in a hurry and get the general idea
20:43:45 <ZFox> > nub $ 4:[0..5]
20:43:47 <lambdabot>   [4,0,1,2,3,5]
20:43:56 <ZFox> Neat
20:44:16 <zachk> has Idris been going anywhere?
20:44:42 * zachk just stumled on julia the other day
20:44:53 <ZFox> > nub $ ([1..10] ++ [0..19])
20:44:55 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,0,11,12,13,14,15,16,17,18,19]
20:45:00 <ZFox> :)
20:45:03 <zachk> looks interesting, but have not really checked out, being too busy with school lately
20:45:22 * ZFox wonders why zachk would sort . reverse
20:45:23 <ZFox> O.o
20:45:58 <zachk> it was pedalogical -_-
20:46:04 <zachk> so sort would actually do something
20:46:13 <zachk> wanted to "mess" up the lists '
20:46:13 <ZFox> > sort . nub $ [1..10] ++ [1..10]
20:46:15 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
20:46:22 <hpaste> Frostix pasted “initials” at http://hpaste.org/83711
20:46:34 <ZFox> zachk: sort was gonna do something eitherway
20:46:36 <Frostix> Hey guys, I'm having issues running this code. I'm pretty sure it's set up correctly but when I type in *initials (John, Doe)* in GHCi - it returns not in scope. http://hpaste.org/83711
20:46:38 <zachk> well I thought of the sort first, sort of, then wanted the (nub . sort)
20:46:51 <ZFox> > [1..10] ++ [1..10] -- 1-10  1-10
20:46:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10]
20:47:06 <zachk> bbia5
20:47:18 <ZFox> > sort "bbia5"
20:47:20 <lambdabot>   "5abbi"
20:47:30 <geekosaur> Frostix, first obvious question is, did you quote your strings?
20:47:49 <Frostix> Nope, should I be :3?
20:47:52 <geekosaur> initials (John, Doe) <-- sends one parameter instead of two, a tuple of constructors)
20:48:28 <geekosaur> this is not perl, barewords do not stringify
20:48:45 <geekosaur> ```initials "John" "Doe"```
20:48:59 <Frostix> Can you explain that better, Haskell is actually my first language, what's barewords and stringify mean?
20:49:17 <ZFox> > let ini (f:_) (s:_) = f:s in ini "John" "Doe"
20:49:19 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
20:49:19 <lambdabot>              with actual ty...
20:49:27 <ZFox> eh
20:49:35 <Frostix> Should I have not put them in tuples?
20:50:15 <Clint> not unless you want your function to take a pair of Strings instead of two Strings
20:50:23 <geekosaur> most languages call a function with parameters as f(x,y,z), haskell says f x y z
20:50:48 <geekosaur> as for barewords, don't worry about it. just remember that a string in haskell is (almost) always in double quotes
20:50:51 <geekosaur> "String"
20:50:58 <danharaj> :t "String"
20:50:59 <lambdabot> [Char]
20:51:06 <danharaj> :t "John"
20:51:07 <geekosaur> (the ecception is that a string is actualy a list of Char, so you could use a different list representation)
20:51:08 <lambdabot> [Char]
20:51:16 <MaybeCallMe> My aeson encode returns a Chunk instead of a IsString, why? examples say it ought to return IsString
20:51:20 <ParahSail1n> ouch, * Missing (or bad) header file: HsNet.h -- trying to build network-2.4.1.2 on windows
20:51:29 <hpaste> Frostix pasted “initials2” at http://hpaste.org/83712
20:51:30 <geekosaur> :t 'J':'o':'h':'n':[]
20:51:31 <lambdabot> [Char]
20:52:05 <danharaj> Frostix: your code is fine either way, although this revision is cleaner.
20:52:16 <ZFox> > let ini (f:_) (s:_) = f:'.':[s] in ini "John" "Doe"
20:52:17 <danharaj> Frostix: now, how would you use this function?
20:52:18 <lambdabot>   "J.D"
20:52:19 <ZFox> Messy but idc :D
20:52:37 <Frostix> initials "John" "Doe"
20:52:38 <Frostix> ?
20:52:42 <danharaj> Frostix: indeed.
20:52:46 <Frostix> Yay :D
20:53:04 <danharaj> Frostix: bonus round: take only one string. Use a function from the module Data.List to break it apart.
20:53:26 <Frostix> Uh. module Data.List?
20:53:26 <geekosaur> MaybeCallMe, IsString is not a type
20:53:32 <ZFox> @data Initials = Char char
20:53:32 <lambdabot> Unknown command, try @list
20:53:35 <danharaj> Frostix: import Data.List
20:53:45 <MaybeCallMe> geekosaur: yes..
20:53:50 <ZFox> > data Initials = Char Char; Initials 'c' 'c'
20:53:51 <danharaj> Frostix: I'm sorry. I am assuming you know things that you may not already know!
20:53:52 <lambdabot>   <hint>:1:1: parse error on input `data'
20:53:53 <Frostix> Ok what's Data.list (not this far into LYAH)
20:53:55 <ZFox> Blah
20:54:00 <Frostix> ^^
20:54:11 <MaybeCallMe> geekosaur: but why Chunk? examples show some sort of overloaded string
20:54:18 <zachk> is there a really flash and html5 browser for linux in general yet?
20:54:22 <danharaj> Frostix: Data.List is a module. A module is a body of code. Data.List is included with your distribution of GHC.
20:54:42 <ZFox> preflex: vodik
20:54:48 <ZFox> preflex: seen vodik
20:54:51 <ZFox> meh
20:55:03 <preflex>  vodik was last seen on #xmonad 188 days, 18 hours, 39 minutes and 37 seconds ago, saying: seperate from the processes that run on it
20:55:10 <danharaj> Frostix: LYAH is a good guide. You'll do fine. GL!
20:55:12 <Frostix> Alright, what's inside of Data.List- cause I know in Java when you import things such as .MATH you get predefined things
20:55:16 <Frostix> Thank you
20:55:34 <danharaj> Frostix: Yes it's the same idea. Here is a webpage that documents what is in Data.List: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-List.html
20:55:36 <ZFox> delay lol
20:55:43 <geekosaur> I dont even see what a Chunk is in Aeson (neither does hayoo)
20:55:47 <Frostix> Gotcha.
20:55:57 <MaybeCallMe> :t Data.Aeson.encode
20:55:59 <lambdabot> Couldn't find qualified module.
20:56:16 <zachk> "Chunk"?
20:56:28 <geekosaur> ohh, I get it
20:56:37 <geekosaur> it's an internal type of Data.Text
20:57:02 <ZFox> Is there any functional difference with hayoo and hoogle?
20:57:18 <danharaj> yes
20:57:19 <geekosaur> which is an efficient packed Unicode string, as distinct from inefficient linked lists (String) or efficient byte vectors (ByteString)
20:57:22 <danharaj> (don't ask me what it is)
20:57:22 <khanzor> hi all, i'm having some problems with homebrew, sdl and cabal
20:57:38 <khanzor> i've installed the SDL_ttf recipe in homebrew
20:57:39 <zachk> <- uses :! hoogle alot from a ghci command prompt
20:57:48 <khanzor> but when i try to install SDL-ttf in cabal
20:57:48 <MaybeCallMe> geekosaur: thanks
20:57:57 <geekosaur> khanzor, make sure the C sdl libs are installed before building the haskell bindings or you get a broken "C compiler cannot create executables"
20:58:13 <khanzor> the configure step complains about not finding the lib
20:58:18 <ZFox> zachk: hoogle command?
20:58:41 <danharaj> khanzor: you need to build the C library and then put it in a place where cabal can find it for building the Haskell binding library.
20:58:48 <khanzor> geekosaur: yeah, they are all there, SDL installs fine
20:58:57 <geekosaur> then you presumably need to tell it to look in /usr/local/include and /usr/local/lib
20:59:16 <khanzor> geekosaur: that's the part i'm stuck on :(
20:59:31 <danharaj> the flag you are looking for is --extra-lib-dirs
20:59:33 <khanzor> geekosaur: --extra-include-dirs etc doesn't seem to help
21:01:03 <khanzor> is there anyway i can run that configure step manually? i'm a complete novice when it comes to compiling c code
21:01:07 <geekosaur> I don't know, then. possibly the configure scripts with the haskell sdl bindings ignore those coming in; as you might have inferred from my first comment, they are somewhat broken
21:01:12 <khanzor> (to see what's missing)
21:02:12 <khanzor> geekosaur: yeah, i'm stumped, it's bizarre that SDL should find the libs ok, but SDL-ttf etc don't...
21:03:19 * hackagebot gitit 0.10.3 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.10.3 (JohnMacFarlane)
21:03:55 <napping> Does anyone understand the type error here: http://augustss.blogspot.com/2011/07/impredicative-polymorphism-use-case-in.html
21:04:36 <napping> I don't see why `LValue a0' wouldn't match `forall (lr :: * -> *). LR lr => lr a1'
21:04:49 <napping> Is ImpredicativePolymorphism just busted?
21:05:04 <geekosaur> somewhat regularly, as I understand it
21:05:35 <danharaj> ImpredicativePolymorphism is the definition of busted.
21:05:41 <geekosaur> (thst is, it's usually got bugs somewhere, and those bugs tend to move around between ghc versions)
21:05:45 <danharaj> It will pretend to work until it doesn't want to.
21:06:00 <lispy> napping: I'm no expert, but my impression has always been that something is conceptually wrong with impredicative polymorphism
21:06:44 <lispy> I tried to learn what it was a few years ago but ran aground somewhere in the theoretical aspects
21:07:13 <geekosaur> the impression I've gotten is that there are type systems other than the one GHC uses in which impredicative polymorphism can make some kind of sense, but it's a very poor fit with ghc's current type system and replacing that type system would cause more problems than it would solve
21:07:18 <heatsink> Is there something wrong with newtype wrappers for polymorphic functions?
21:07:45 <covi> @hoogle YesodJquery
21:07:46 <lambdabot> No results found
21:07:56 <danharaj> heatsink: they have wrappers.
21:08:19 * hackagebot yst 0.3.1.1 - Builds a static website from templates and data in YAML or  CSV files.  http://hackage.haskell.org/package/yst-0.3.1.1 (JohnMacFarlane)
21:09:10 <danharaj> On the other hand newtypes are the best way to handle polymorphic values in an environment like Haskell because their constructors and destructors act as explicit annotations of what is in them.
21:11:59 <heatsink> Newtypes require explicit wrapping and unwrapping.  But there's no expressiveness limitation compared to impredicative types?
21:12:48 <napping> no, there shouldn't be
21:13:20 <heatsink> alright.
21:15:42 <Frostix> What's a '(RealFloat a)'?
21:16:10 <ZFox> Are you asking what 'a' means?
21:16:18 <Frostix> What does RealFloat mean
21:16:21 <ZFox> In a type sig context, it's anything
21:16:22 <ZFox> oh
21:16:37 <Frostix> I know what Floating numbers are though
21:16:41 <plhk> > map (liftM2 (+) fst snd) $ zip [1,2] [3]
21:16:42 <lambdabot>  Terminated
21:16:58 <sclv> ?hoogle RealFloat
21:16:59 <lambdabot> Prelude class (RealFrac a, Floating a) => RealFloat a
21:16:59 <lambdabot> Data.Text.Lazy.Builder.RealFloat module Data.Text.Lazy.Builder.RealFloat
21:16:59 <lambdabot> Data.Text.Lazy.Builder.RealFloat realFloat :: RealFloat a => a -> Builder
21:17:25 <sclv> so real float is a class that is a subclass of realfrac and floating
21:17:52 <sclv> if we hoogle from the website it gives a link to the class definition: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:RealFloat
21:17:53 <Frostix> What's realfrac and floating (like numbers?)
21:18:06 <Frostix> Oh, gotcha
21:18:20 * hackagebot pandoc 1.11 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.11 (JohnMacFarlane)
21:18:28 <sclv> at the bottom of that documentation are the instances
21:18:55 <sclv> which tell you that basically Double and Float (and the C wrapped versions) are the only out-of-the box things implementing this
21:19:13 <sclv> from the ghci prompt you can use :info to get lots of similar information
21:19:20 <napping> lispy: what's conceptually difficult? It's certainly odd in logic, but System F is already impredicative in that sense
21:19:33 <Nisstyre-laptop> I'm looking to build a fairly narrow web app that is basically CRUD. Do people recommend Yesod or Snap, or something else? Yesod looks a little bit too complicated, and I'm not a fan of Template Haskell. Is Snap more lightweight?
21:20:39 <ParahSail1n> snap seems like its getting popular
21:20:51 <Nisstyre-laptop> ParahSail1n: yeah. Have you used it for anything?
21:20:59 <ParahSail1n> nope
21:21:10 <Nisstyre-laptop> fair enough
21:21:12 <ozataman> Nisstyre-laptop: we use snap at my company to serve 1M+ hits/day
21:21:37 <Nisstyre-laptop> ozataman: nice
21:21:49 <Nisstyre-laptop> ozataman: so you use Snap's server?
21:21:56 <covi> Is there anyone familiar with yesod here?
21:22:16 <ozataman> Nisstyre-laptop: well, snap expects you to use its stack.. we use snap-core, snap-server and snap and a bunch of snaplets, etc.
21:22:18 <ozataman> the project is quite large
21:22:25 <lispy> napping: I think I've had too much whiskey to answer that question. Perhaps another time :)
21:22:32 <Nisstyre-laptop> ozataman: does Snap come with libraries for doing templating stuff?
21:22:39 <sclv> yep
21:22:40 <ozataman> Nisstyre-laptop: yep, heist
21:22:42 <Nisstyre-laptop> sweet
21:22:54 <sclv> note that all the template stuff is interchangable between all the frameworks
21:23:06 <sclv> everything is pretty pick and mix in haskell
21:23:13 <Nisstyre-laptop> yeah good point
21:23:25 <sclv> but the three major frameworks all have different default choices, reflecting their approaches
21:24:38 <hpaste> plhk pasted “dumb lens question” at http://hpaste.org/83713
21:25:05 <plhk> ^ anyone?
21:26:07 <lispy> ozataman: What company is that? (If you don't feel comfortable disclosing that, I understand)
21:27:12 <lispy> plhk: I'm not certain, but I think _1 and _2 are for tuples
21:27:23 <parcs> lispy: ozataman is gone :)
21:28:01 <lispy> parcs: ah. my client hides parts/joins.
21:29:16 <parcs> my client hides parts/joins only if the person hasn't spoken for a while
21:31:43 <lispy> I wouldn't be able to handle #haskell without hiding them :
21:31:45 <lispy> :)
21:31:46 <Cale> plhk: y u no use lenses for the fields of the Animal type? I presume that's why the field names are named with an initial _
21:31:59 <Cale> parcs: That's a nice feature
21:32:18 * lispy uses irssi
21:32:44 <plhk> Cale: but i do
21:32:51 <Hafydd> I am trying to get a version of GHC that supports OverloadedLists. I tried building the latest nightly release, but it failed with "doc comment parse failed". Could this just be because I didn't choose a stable enough release?
21:33:57 <lispy> Hafydd: maybe? Have you asked in #ghc?
21:34:35 <plhk> view hunger $ Animal 5 Male 100
21:34:36 <plhk> 100
21:35:08 <Hafydd> lispy: good point. I'll ask there instead.
21:35:49 <Hafydd> Oh, but the topic says "Please ask user questions in #haskell."
21:36:15 <lispy> Hafydd: I think "Why doesn't git HEAD build?" is not a simple user question
21:36:59 <Hafydd> Well, I feel too ignorant about GHC to defend that notion.
21:37:31 <lispy> Hafydd: In that case, what have you tried?
21:37:45 <lispy> Hafydd: have you followed the ghc wiki's build instructions?
21:38:01 <lispy> http://hackage.haskell.org/trac/ghc/wiki/Building
21:38:30 <Hafydd> I tried looking at the cvs-ghc mailing list, as suggested on the website. I didn't follow the instructions there, I just used ./configure and make; but I will look at those.
21:41:26 <heatsink> The problem is haddock-related, so you could just delete the offending comment.
21:44:02 <lispy> The level of documentation for ghc is astounding. It's just amazing compared to other projects of that size and breadth.
21:52:48 <TravisD> Is it good style to create type synonyms as a form of documentation? For example, to use "type Prob = Double" to represent numbers that ought to be probabilities?
21:53:51 <lispy> TravisD: Opinions go both ways. I dislike it, but others think it's fine.
21:54:16 <TravisD> Ah, do you have a reason for disliking it?
21:54:25 <TravisD> I'm having a hard time deciding what I think
21:55:04 <Cale> TravisD: The reason for disliking it is that it makes understanding which operations can be applied to things just a little more difficult without actually adding type safety
21:55:27 <ParahSail1n> a lot of libraries do that TravisD
21:55:37 <TravisD> That makes sense. It also occurred to me that you could /actually/ make a new type so that you couldn't mix probabilities with other numbers
21:55:45 <Cale> right
21:55:45 <TravisD> but that seemed like it might be too restrictive
21:55:56 <TravisD> at least in this case
21:56:09 <napping> why?
21:56:29 <TravisD> napping: it's not unreasonable to have expressions that depend on probabilities but are not themselves probabilities
21:56:45 <TravisD> maybe you could make it work - I didn't think about it too hard
21:57:02 <lispy> TravisD: my reason is exactly what Cale said.
21:57:08 <napping> using the results rather than providing inputs then?
21:57:26 <TravisD> napping: I'm not sure I understand
21:57:45 <napping> you would never want to call functions taking a Prob with -1.7
21:58:01 <napping> but you might want to scale an arbitrary Double by a result
21:58:26 <TravisD> a result being a Prob?
21:59:47 <lispy> TravisD: Chances are, a newtype wrapper with a smart constructor is what you really want.
22:00:14 <lispy> TravisD: and in the cases where that seems like too much work for the benefit, directly using the type is probably clearer
22:00:36 <heatsink> IMO, having a newtype makes it easier to maintain invariants
22:00:43 <heatsink> such as all probabilities being between 0 and 1
22:00:54 <fragamus> hey is edwardk around here
22:00:58 <fragamus> hey is edwardk around here
22:00:59 <edwardk> nope
22:00:59 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
22:01:01 <heatsink> @seen edwardk
22:01:01 <lambdabot> Unknown command, try @list
22:01:06 <edwardk> @messages
22:01:06 <lambdabot> ozataman said 6h 24m 18s ago: sorry, was away from computer for a bit. Unfortunately, no :( I had to avoid using snappy or use ghc directly to compile. Interestingly, I remembering something about
22:01:06 <lambdabot> compiling with ghc directly working where cabal failed…
22:01:06 <lispy> edwardk: bummer :(
22:01:25 <TravisD> Hmm, I'll think about it some more
22:01:34 <fragamus> @messages
22:01:34 <lambdabot> You don't have any new messages.
22:01:50 <fragamus> I have been pondering the comonad
22:02:11 <lispy> edwardk: It's a shame because I hear he's a cool guy
22:02:12 <fragamus> you say that the one you walked through with me was the Env comonad right
22:02:48 <heatsink> In what situations is the dual of something spelled by reversing its name?
22:03:02 <lispy> edwardk: did you see that domonic orchard wrote a paper trying to address the issue of when a monad is desirable, when a comonad is desirable, and when they overlap?
22:03:07 <edwardk> fragamus: yeah
22:03:15 <edwardk> lispy: i might have. link?
22:03:17 <fragamus> I am most comfortable with the cokliesli notation.
22:03:30 <fragamus> I think I get it a little bit
22:03:45 <lispy> edwardk: I'll see if I can find it
22:04:07 * edwardk tends to avoid the cokleisli notation because rarely do i take enough 'steps' in a comonad in one go that i need it. hence extend
22:04:11 <fragamus> I can compose a bunch of functions (e,a) -> a together
22:04:15 <edwardk> yeah
22:04:27 <lispy> edwardk: http://www.cl.cam.ac.uk/~dao29/drafts/monad-or-comonad-orchard11-draft.pdf
22:04:38 <fragamus> oh interesting… so it's not typically used for a lot of steps
22:05:00 <edwardk> lispy: i've never read that. neat. i'll read through it
22:05:14 <lispy> edwardk: I recently found a slide deck you made (was it titled "all about comonads") that was handy because you show that it's really about reversing the arrows, but you were careful to show which arrows
22:05:30 <edwardk> lispy: yeah, that was for the first boston haskell session
22:05:34 <edwardk> way back in the day
22:05:46 * lispy is behind times clearly
22:05:53 <edwardk> the all about comonads title was a dig at the fact that the guy who wrote 'all about monads' was in the audience
22:06:14 <lispy> ah
22:06:24 <lispy> all about monads was how I learned monads back in the day
22:06:31 <lispy> so, fitting
22:06:34 <fragamus> so extract is the dual of return right
22:07:31 <TravisD> Is "All about monads" still a worthwhile read?
22:07:41 <lispy> TravisD: if you ask me, yes :)
22:07:46 <TravisD> :)
22:07:49 <plhk> > over mapped (_1 %~ (+1)) $ [(10, 5)]
22:07:52 <lambdabot>   [(11,5)]
22:08:12 <lispy> TravisD: I've heard some people say that it's all about the Nth monad tutorial you read.
22:08:19 <TravisD> heh
22:08:58 <TravisD> Is there anything about monads that's more difficult to understand than the other category theoretic ideas in Haskell?
22:09:05 <TravisD> It seems like there's a way bigger effort to explain them
22:12:19 <lispy> TravisD: groking monads is all about accepting an abstract mathematical definition and then playing with 4 or 5 different instantiations of that definition.
22:12:26 <ZFox> How would one effeciently encode and transmit a blob of data in a way to keep the structure and not send in plain text. (To even optionally be encrypted)
22:12:49 <lispy> TravisD: as much as I wish it was something deeper, that's really all there is to it. Accept the definition then see it play out in lots of different ways.
22:13:54 <TravisD> hmm, so did people come up with the idea of using them in the first place just by recognizing the same pattern occuring?
22:14:16 <lispy> TravisD: it came out of Mogoi(sp?) applying them to PL semantics
22:14:28 <lispy> then folks like Wadler showed that you could use them directly in haskell
22:15:10 <TravisD> hmm, I see
22:18:20 <ZFox> http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/Data-Binary.html links to dead page >> http://darcs.haskell.org/binary/tools/derive/BinaryDerive.hs
22:18:23 <ZFox> :/
22:19:22 <TravisD> thanks for the advice :)
22:20:02 <covi> Yesod question: I _have_ to add some lines in <head> section of my templates (that is, addScript and addScriptRemote, etc do not suit my need). How can I do that?
22:21:04 <ZFox> covi: /j #yesod
22:29:47 <mikeplus64> ZFox: that's binary 0.4.1, current binary is 0.7.0.1
22:33:26 <ZFox> Ah
22:33:45 <ZFox> Blame google XD
22:35:16 <hpaste> noob pasted “flattening simple nested list” at http://hpaste.org/83714
22:35:28 <lispy> TravisD: there is a history of haskell paper that I bet you would find interesting: http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf
22:36:16 <haskell_noob> http://hpaste.org/83714 : anyone know why this gives a non-exhaustive patterns error?
22:37:13 <Iceland_jack> haskell_noob: it only matches singleton lists of lists
22:37:44 <slack1256> what is the de facto generic programming solution in haskell?
22:37:53 <slack1256> syb, data.data, uniplate?
22:37:59 <lispy> slack1256: I'm not sure but someone wrote a paper comparing them
22:38:22 <slack1256> Oh I remember reading about that
22:38:28 <slack1256> but I would like to know about popularity
22:38:38 <slack1256> or should I wait for hackage2?
22:38:39 <lispy> lens's verses of uniplate?
22:38:39 <Iceland_jack> > let { a [[]] = 0; a [[x]] = 1; a [x:xs] = 2; } in a [[1,2], [3]]
22:38:40 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
22:38:47 <Iceland_jack> hm
22:38:48 <lispy> it's about 30% faster than actual uniplate
22:38:58 <lispy> don't wait for hackage2
22:39:06 <lispy> Or as I call it, "hackage forever"
22:39:23 <slack1256> come on, even duke nukem forever got released
22:39:24 <Iceland_jack> haskell_noob: Anyway, there is no case for something like [[1, 2], [3]]
22:39:33 <slack1256> also the repo has commit now and then
22:39:39 <lispy> slack1256: and I think that dcoutts will eventually see hackage2 released :)
22:40:01 <slack1256> heh
22:46:33 <turiya> is there a strict version of mapAccumL?
22:49:01 <lispy> @tell Cale we need to get that recoverEncode failure fixed. do you know if the discussion about lambdabot maintainership went anywhere?
22:49:01 <lambdabot> Consider it noted.
22:50:43 <covi> ZFox: nobody is there in #yesod :(
22:51:33 <TravisD> lispy, thanks for the paper :) I'll read that!
22:52:08 <ZFox> covi: :(
22:52:24 * ZFox doesn't use yesod
22:52:54 <ZFox> covi: By any chance is everything you have there static? Maybe Hakyll is more suited if so.
22:58:56 <haskell_noob> Iceland_jack: i give up, how do i pattern match for a nested list?
22:59:54 <Iceland_jack> haskell_noob: do you know how patten matching on a regular list works?
23:00:33 <haskell_noob> if i want to match to a list, (x:xs)?
23:00:45 <Iceland_jack> right, so you can only match on the “head” of a list
23:01:08 <Iceland_jack> (a:b:c:rest) matches a list of length three or more
23:01:23 <Iceland_jack> so it stands to reason that pattern matching a “nested” list follows the same rules
23:02:55 * ZFox hates making binary derivitaves for lots of things D:
23:10:25 <ZFox> Time package </3
23:11:19 <ZFox> Could not find module `Data.Time.Clock.Scale' it is a hidden module in the package `time-1.4.0.1'
23:11:51 <ZFox> >_<
23:15:18 <ZFox> Should I fork time to have all the instances for Binary there or.. Report this to the author because it's impossible to create instances of MkDiffTime as it's A. A hidden module and B. it doesn't even get exported.
23:22:38 <ZFox> Hmm. Should I convert the time to and from epoch?
23:23:18 <haskell_noob> Iceland_jack: thanks! that helped
23:23:41 <Iceland_jack> haskell_noob: :)
23:23:41 <ZFox> How? O.o
23:26:46 <lispy> ZFox: I feel like an overwhelming lesson of haskell package is to expose your "internal hidden" modules and simply document them as "don't use this unless you mind update your package at each version bump and you don't mind understanding the invariants"
23:27:30 <lispy> making them fully inaccessible reads to needlessly forked packages
23:27:39 <lispy> s/reads/leads
23:27:51 <haskell_noob> why does pattern matching ([x:xz]:xs) give an error but ((x:xz):xs) works?
23:28:09 <otters> because
23:28:12 <ZFox> haskell_noob: Because in a patern [x:xs] isn't valid
23:28:27 <ZFox> x:xs joins
23:28:29 <arkeet> well, it is valid, but it probably doesn't have the right type.
23:29:06 <fragamus> :t In
23:29:08 <lambdabot> f (Mu f) -> Mu f
23:29:14 <ZFox> > (\[x:xs] -> (x,xs)) ["test"] -- ('t',"est")
23:29:16 <lambdabot>   ('t',"est")
23:29:18 <ZFox> :)
23:29:42 <ZFox> arkeet: I meant not valid for what he's after
23:29:47 <arkeet> :p
23:31:02 <ZFox> lispy: What do you suggest for getting a UTCTime value to and from binary?
23:31:21 <lispy> ZFox: I can't suggest much; I've never looked into it.
23:31:37 <ZFox> show/read? :P
23:31:53 <lispy> ZFox: there must be an ISO standard?
23:32:30 <ZFox> For what?
23:33:12 <ZFox> there are no to nor from integer instances :/
23:35:09 <haskell_noob> so ([1:2]:1) would really mean [[[1,2]],1]?
23:35:25 <Iceland_jack> haskell_noob: no
23:35:43 <Iceland_jack> You may want to check the type of (:)
23:35:46 <Iceland_jack> @ty (:)
23:35:48 <lambdabot> a -> [a] -> [a]
23:36:34 <lispy> ZFox: I guess you could do ISO 8601 in hex or base64 or ...
23:37:02 <Iceland_jack> something like 1:2 wouldn't be allowed then
23:37:35 <Iceland_jack> haskell_noob: 1:2:[] ≡ [1,2]
23:37:58 <Iceland_jack> (1:2:[]):[] ≡ [[1,2]]
23:40:34 <ab9rf> [x:xz]:xs can match some lists, but not many
23:40:45 <ab9rf> you'd have to have a list of lists
23:40:48 <ZFox> lispy: How so?
23:42:03 <ab9rf> haskell_noob: ([1:2]:1) would be a type error
23:47:23 <haskell_noob> ab9rf: what lists would it match?
23:47:46 <ZFox> lispy: parseTime and readTime maybe?
23:48:11 <ZFox> err formatTime and parseTime *
23:48:45 <johnw> a UTCTime is just a 64-bit integer, I believe
23:48:46 <ZFox> (Using a string, maybe export to an epoch as I suggested before
23:49:01 <johnw> oh, it's two Ints
23:49:02 <ab9rf> haskell_noob: if t is a type, it'll match any list of type [[[t]]] in which the first element of the list contains a list that containts at least one element
23:49:19 <ZFox> johnw: How to extract the exact required parts?
23:49:20 <johnw> ZFox: the cereal library would make it trivial to convert UTCTime to binary and back
23:49:28 <johnw> ZFox: http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Clock.html#v:UTCTime
23:49:40 <ab9rf> haskell_noob: x will match that element, xs will match the rest of that list, and xz will match the rest of the outermost list
23:49:53 <ZFox> cereal?
23:50:01 <ab9rf> the first element of the list has to be a list with exactly one element, which is itself a list of at least one element
23:50:10 <ZFox> serialize :)
23:50:14 <johnw> http://hackage.haskell.org/package/cereal
23:50:17 <Raynes> Bah.
23:50:30 <ab9rf> haskell_noob: i doubt this would be useful in any noncontrived situation
23:50:37 <johnw> you just make a Serialize instance for UTCTime
23:50:42 <johnw> and then get/put the two Ints
23:50:44 <ZFox> johnw: BLAH
23:50:47 <ZFox> Same problem
23:50:52 <johnw> what is the problem exactly?
23:50:55 <ZFox> Just using serialize instead of Binary
23:51:04 <ZFox> (Instances)
23:51:14 <johnw> i don't get it
23:51:24 <ZFox> johnw: vim +set' 'ft=haskell http://ix.io/4Fl
23:51:41 <haskell_noob> ab9rf: i was stuck trying to match a nested list and ended up using ((x:y):z), and was just wondering what the one I tried before meant
23:51:41 <johnw> ah, I see
23:51:44 <johnw> yeah, the binary lib does the same thing
23:51:49 <johnw> so what's wrong with that code?
23:51:53 <ZFox> MkDiffTime << THIS DOES NOT EXPORT
23:51:53 <ZFox> :(
23:52:20 <johnw> also, just: UTCTime <$> get <*> get
23:52:25 <ab9rf> haskell_noob: (x:y):z does generate a nested list
23:52:42 <johnw> and: put x1 >> put x2
23:52:49 <ab9rf> :t \x y z -> (x:y):z
23:52:50 <lambdabot> a -> [a] -> [[a]] -> [[a]]
23:53:01 <ZFox> wait
23:53:22 <haskell_noob> yeah i found that out after being stuck on ([x:y]:z)
23:53:44 <ab9rf> haskell_noob: the :t command in ghci (or hugs) is your friend
23:54:43 <ZFox> johnw: I still need instances for Binary DiffTime and Binary Day
23:55:01 <johnw> toModifiedJulianDay will extract the Int from the Day
23:55:06 <johnw> you don't really new a new instance
23:55:21 <ZFox> I know
23:55:33 <ZFox> Wait..
23:55:41 <johnw> so... what is really your issue then?
23:55:47 <johnw> you don't like the actual lines of code?
23:56:14 <ZFox> The problem is I need the UTCTime encoded into the binary stream
23:56:21 <johnw> and you're doing that now
23:56:26 <ZFox> Yea
23:56:33 <johnw> ok, then i don't get it
23:56:34 <ZFox> But, UTCTime, I haven't got this done
23:56:49 <ZFox> You suggest toModifiedJulianDay
23:57:03 <johnw> or make more instances, either one
23:57:36 <ZFox> So.. put $ toModifiedJulianDay x1
23:57:45 <johnw> yep
23:57:46 <ZFox> And for x2?
23:57:52 <johnw> check out the docs
23:58:03 <turiya> hi
23:58:05 <ZFox> I have
23:58:05 <johnw> they show the constructors and accessors you need
23:58:07 <johnw> turiya: hi
23:58:09 <ZFox> But really lost too many things
23:58:39 <turiya> my program takes far more memory than it should take..
23:58:49 <turiya> i dont know how to improve its performance
23:58:50 <tieTYT> (=~)  :: (RegexMaker Regex CompOption ExecOption source,      RegexContext Regex source1 target) =>     source1 -> source -> target
23:59:00 <johnw> turiya: can you use hpaste.org to show me your code?
23:59:01 <tieTYT> I've never seen a type signature like this.  What is this saying?
23:59:26 <tieTYT> is it saying "source" is all those typeclasses?
23:59:38 <tieTYT> and source1 and target are all those others?
23:59:39 <arkeet> there are multiple types there, source1 and source.
23:59:48 <arkeet> there's one class, RegexMaker.
23:59:51 <arkeet> and another class, RegexContext.
