00:01:10 <wavewave> yeah.. last time edwin's talk in boston was great.
00:18:33 <Sonarpulse> so there is a Data.Map both with ghc and hackage, and neither is on the platform>
00:19:02 <Sonarpulse> I guess Data.Map is standard
00:19:37 <shachaf> Data.Map comes from the package "containers"
00:20:07 <Sonarpulse> Data.Map.Lazy says it's also from containers
00:20:18 <Sonarpulse> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map-Lazy.html
00:20:18 <shachaf> Yes.
00:20:35 <shachaf> containers comes with GHC. You probably shouldn't upgrade it.
00:20:48 <Sonarpulse> why don't I have data.map.lazy then?
00:20:56 <Sonarpulse> I can't imagine they would split the package
00:21:53 <shachaf> Probably you aren't looking at documentation for the version of containers that you have.
00:22:08 <Sonarpulse> that would make the most sense
00:22:39 <Sonarpulse> I have ubuntu 12.04 repo's GHC
00:22:44 <Sonarpulse> which isn't too bad
00:22:52 <Sonarpulse> sorry 12.10
00:22:58 <Sonarpulse> something  could have changed
00:23:06 <Sonarpulse> :info Data.Map
00:23:14 <Sonarpulse> whoops that wasn't ghci
00:23:26 <shachaf> I recommend finding out which version of containers you have -- maybe with ghc-pkg -- and then looking at the documentation for that version.
00:24:35 <Sonarpulse> sounds like a plan
00:24:36 <Sonarpulse>  
00:24:36 <Sonarpulse>  
00:24:36 <Sonarpulse>  
00:26:38 <Sonarpulse> oh wow
00:26:40 <Sonarpulse> 4.2
00:26:55 <Sonarpulse> guess top level number bump for big API change
00:27:10 <shachaf> Probably the API change involved .Lazy!
00:27:47 <Sonarpulse> yup
00:28:09 <Sonarpulse> what exactly is the relationship between cabal and ghc-pkg?
00:28:51 <shachaf> Perhaps http://www.vex.net/~trebla/haskell/sicp.xhtml will help
00:31:07 <Sonarpulse> ok so it's vagly like dpkg vs apt
00:31:24 <shachaf> Not exactly.
00:31:43 <shachaf> Also keep in mind: Cabal is different from cabal-install (the command line program `cabal` is cabal-install).
00:32:55 <Sonarpulse> what do you mean?
00:33:06 <Sonarpulse> I assumed cabal-install is just one of many utilities
00:33:11 <Sonarpulse> and Cabal is the otherall system
00:33:27 <Sonarpulse> I ask in part because I am probably going to switch to NixOS soon
00:33:47 <shachaf> Nix has a whole different system.
00:34:05 <Kaidelong> but there are people working on porting hackage to nix I think
00:34:20 <Kaidelong> so if you want to bypass cabal altogether it might be possible
00:35:08 <Sonarpulse> I mean then I have Nix package manager instead of cabal
00:35:14 <Sonarpulse> but still ghc-pkg?
00:35:24 <Sonarpulse> that would be my assumption
00:35:57 <Sonarpulse> also, back to map, my keys are 32-bit unsigned integers
00:36:05 <randomclown> How do you use ByteString.Builder, I want to concatenate a lot of bytestrings together
00:36:24 <Sonarpulse> I assume IntMap WON'T work then as Int is only guaranteed 28-bits?
00:36:36 <luite> randomclown: mostly through the Monoid instance
00:36:39 <Sonarpulse> or something like that
00:36:47 <luite> randomclown: mconcat a much together, or a <> b <> c
00:36:51 <luite> a bunch
00:37:46 <randomclown> On the builders?
00:37:50 <luite> yeah
00:38:01 <randomclown> right ok
00:41:53 <luite> randomclown: if it doesn't work, ask shachaf for help
00:42:09 <shachaf> help
00:42:19 <shachaf> what did i do this time??
00:42:28 <luite> he needs monoids
00:42:43 <randomclown> nah I got them
00:43:02 <shachaf> Sonarpulse: I think Int is guaranteed by the report to be 30 bits.
00:43:19 <shachaf> Sonarpulse: But in practice with IntMap it's going to be 32 or 64.
00:43:40 <Sonarpulse> should I take the risk? :)
00:44:05 <Sonarpulse> there are the reserved bits for metadata
00:44:12 <Sonarpulse> or is that only pointers
00:44:37 <shachaf> GHC gives you the full 32 bits.
00:44:45 <Sonarpulse> OK
00:44:47 <shachaf> Hypothetical other implementations might use 2 bits for other things.
00:45:03 <Sonarpulse> I'll try both ways
00:45:22 <Sonarpulse> my program is IO bound so it probably doesn't matter
00:45:40 <shachaf> copumpkin: Do you have a good toy monad that has a more efficient Applicative instance?
00:46:00 <shachaf> By more efficient I actually mean observably different.
01:02:25 <optimight> #chemistry
01:02:47 <optimight> #join chemistry
01:03:26 <arbn> optimight: So, I heard you like Chemistry?
01:03:55 <Kaidelong> you are probably after the forward slash
01:03:55 <optimight> Nope...     I like haskell
01:04:07 <optimight> Was here few months back
01:41:06 * hackagebot shake 0.10.2 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.10.2 (NeilMitchell)
01:46:23 <rs234> hi
01:49:29 <rs234> i was just reading about RankNTypes and in the context of how i was used to haskell polymorphism so far, it was not immediately evident to me that foo:: forall a . (a -> a) -> (Char,Int) is not the same as bar:: ( forall a . a -> a) -> (Char,Int), should it have been that obviouse?
01:50:03 <cwraith> rs234: no, most people need to learn the difference between them.
01:50:47 <c_wraith> rs234: heck, sometimes I still write one when I mean the other. I have to get the compile error, go "wait, what?" then "oh!" and fix it. :)
01:50:47 <rs234> thank you cwraith, that makes me feel better
02:21:07 * hackagebot xml-conduit-writer 0.1.0.0 - Warm and fuzzy creation of XML documents.  http://hackage.haskell.org/package/xml-conduit-writer-0.1.0.0 (AlexanderBondarenko)
02:32:59 <gavri> I'm about a third of the way through "the haskell school of expression" when I heard about hudak's new book available for free online "school of music"
02:33:27 <gavri> should I start reading "school of music". is it a better and/or more-up-to-date book than "school of expression" is?
02:33:52 <Spockz> If I have an GADT A a b with constructors that have no Typeable constraints, can I transform a value of that type to a value of type B a b that has constructors with Typeable constraints?
02:42:46 <Heffalump> Spockz: no, because you would have to invent a Typeable dictionary from somewhere
02:43:10 <Spockz> Heffalump: indeed, but suppose the instances/dictionaries are out there
02:43:15 <Heffalump> it's pretty much equivalen to saying can I call a function f with Typeable constraints from a function g without
02:43:33 <Heffalump> you can't write something polymorphic in a and b
02:43:55 <Heffalump> yuo can write (Typeable a, Typeable b) => A a b -> B a b
02:44:06 <Spockz> Heffalump: the reason I'm asking is this: I'm building a deep embedding of Category and Arrow, but for the more interesting things I want to do with the DSL I'm finding I need Typeable constraints on the constructors
02:45:32 <Spockz> I then use the Arrow syntax to write my code which ends up in the AST
02:45:50 <Spockz> But since the functions in Category and Arrow don't have the Typeable constraints I can't just add the Typeable constraints to the constructors
02:46:40 <Heffalump> so you can write the transformation if you declare the constraint at that point, as bove
02:48:48 <Spockz> Heffalump: I'm writing down why this didn't work for me, bear with me
02:53:37 <Spockz> Heffalump: all right: https://gist.github.com/spockz/282c342ce8934a8498e2 The error you get there is quite reasonable of course. But I want a way to circumvent it
02:55:16 <Feuerbach> Does anyone have LaTeX commands for nice typesetting of <$> and <*>?
02:58:45 <Spockz> \mathbin{<\$>}?
02:59:58 <Spockz> Feuerbach: %format <$> = "\mathbin{\lhsCHsyntax{\mathord<\$\mathord>}}"
03:00:33 <Spockz> Feuerbach: the \mathord are there because < and > are already are binary operators in late
03:03:35 <Feuerbach> not quite - they still look like three separate symbols. I'm trying to find a paper where I liked them
03:06:02 <Feuerbach> http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-044.pdf — here they are ok
03:06:03 <tsou> Feuerbach: any chance you prefer a \left<\$\right> ?  or \mathtt'ing them?
03:08:25 <Feuerbach> tsou, no, I think the brackets are ok — but I wish they were closer to the dollar sign
03:10:03 <tsou> Feuerbach: the \mathord that Spockz suggested would make them look nice
03:10:12 <Feuerbach> also, the dollar's vertical center is a bit higher than the brackets' one
03:10:28 <Feuerbach> tsou: yes, I have \mathord. Still not enough :)
03:10:49 <Spockz> there is also a command to reduce space let me look it up Feuerbach
03:10:58 <tsou> Feuerbach: try \kern'ing them
03:11:06 <Spockz> %format +++ = "\mathbin{\lhsCHkeyword{\mathord+\!\!\mathord+\!\!\mathord+}}"
03:11:17 <Spockz> the \! removes a bit of space
03:11:45 <tsou> Feuerbach: if you need more precision than \!, use \kern-.32em (for example..)
03:12:19 <Feuerbach> cool, that should do!
03:12:47 <Feuerbach> any way to adjust the vertical position of the dollar sign?
03:13:01 <liyang> Anyone from FP Complete around? mgsloan ?
03:13:08 <Feuerbach> (sorry I'm turning #haskell into #tex)
03:13:38 <Spockz> Feuerbach: something with boxes, I fiddled around with it but it didn't end up nice so I reverted back to above
03:13:50 <Spockz> Feuerbach: will you let me know when you find something you like? :)
03:14:23 <Feuerbach> Spockz: sure!
03:16:28 <tsou> Feuerbach: play with \raisebox, but I don't see something wrong with the default position of $..
03:19:12 <tsou> Feuerbach: how does this look like?  http://lyon.sians.org/feuer/hs.pdf
03:24:22 <Spockz> tsou: it looks squished :P
03:26:28 * hackagebot Octree 0.5.1 - Simple unbalanced Octree for storing data about 3D points  http://hackage.haskell.org/package/Octree-0.5.1 (MichalGajda)
03:26:31 <Spockz> Heffalump: my question is now here: http://stackoverflow.com/q/15717462/682376
03:27:03 <Feuerbach> I settled on \mathbin{{<}\kern-1pt\raisebox{-0.7pt}{\$}\kern-1pt{>}}. Spockz, tsou, thanks for your help!
03:33:46 <Heffalump> Spockz: I think you're screwed, unfortunately (I answered the SO question)
03:36:49 <Spockz> Heffalump: I read it, but I do not really understand it. Are you referring to the first version of |from| or the second with the class?
03:41:30 <mgsloan> liyang: 'lo!
03:43:06 <Feuerbach> Spockz: it doesn't matter. Your 'b' is existentially quantified. You don't know anything about it, so there's no way to recover any of its instances.
03:43:42 <Feuerbach> I mean, any of the instances of the original type. Because 'c' is a fresh type when you introduce it by pattern matching.
03:44:37 <Spockz> but the 'b' is known in its child nodes
03:45:06 <borkdude> I was reading about functors and the either type constructor
03:45:17 <borkdude> and I'm asking myself, why doesn't this work?
03:45:20 <borkdude> let b = Right "foo"
03:45:25 <tsou> Spockz: hehe it does, i thought squished was what he was aiming for :P
03:45:26 <borkdude> fmap (++ "foo") b
03:46:00 <`ramses> borkdude: works here
03:46:03 <Spockz> Feuerbach: the information about 'b' is around somewhere isn't it?
03:46:19 <borkdude> `ramses I get: No instance for (Functor (Either a0))
03:46:19 <borkdude>       arising from a use of `fmap'
03:46:19 <`ramses> > let b = Right "foo" in fmap (++ "foo") b
03:46:19 <arkeet> > let b = Right "foo" in fmap (++ "foo") b
03:46:21 <lambdabot>   can't find file: L.hs
03:46:22 <lambdabot>   Right "foofoo"
03:46:32 <Spockz> Feuerbach: it is contained in the arguments, but you can't `name' it in the class
03:46:40 <arkeet> borkdude: what version of ghc?
03:46:44 <Spockz> (because it existentially quantified)
03:47:01 <arkeet> borkdude: if you have an old one, you may need to import Control.Monad.Instances
03:47:11 <borkdude> ghci 7.4.2
03:47:32 <arkeet> I guess that's old enough.
03:48:16 <borkdude> ah with the import it works (I just installed the Mac version of the Haskell platform)
03:50:31 <borkdude> well thanks
03:52:28 <Feuerbach> Spockz: not really. When you unpack the Comp constructor, 'b' doesn't refer to the original datatype. It has no identity. If you packed it with a Typeable dictionary in the first place, then there would be an association — but only thanks to the Typeable dictionary.
03:53:10 <Spockz> Feuerbach: yes because it is existential
03:53:27 <c_wraith> even without existentials, types are erased at compile time in GHC>
03:53:41 <c_wraith> You just get "constructor number 0" or "constructor number 1", etc
03:53:55 <c_wraith> The names of the constructors are erased along with their type
03:55:32 <c_wraith> The more interesting part of existentials is that types are erased at type-checking time.
03:55:42 <c_wraith> Which is earlier than non-existentials are erased.
03:56:37 <bitonic> c_wraith: what do you mean?  that a monomorphic type gets converted to a quantified thing?
03:57:00 <bitonic> I mean in the end existentials can be expressed with RankNTypes
03:57:09 <bitonic> so there is nothing too special about them
03:57:38 <arkeet> I don't know if it makes sense to say that anything gets erased at type-checking time.
03:57:49 <arkeet> except to say that types are erased at that point.
03:59:11 <c_wraith> right.  I mean that you lose the type information when something is quantified existentially, and you later work with the quantified value.
04:00:14 <bitonic> c_wraith: well, you ‘lose’ the information in the same sense that ‘id :: a -> a’ loses the information—parametricity
04:04:58 <bitonic> c_wraith: in fact, ‘data Exists1 = forall a. Exists1 a’ is isomorphic to ‘data Exists2 = Exists2 (forall r. (forall a. a -> r) -> r)’
04:05:36 <bitonic> you can have Exists1 -> Exists2 and Exists2 -> Exists1 just fine, which I always found neat
04:11:55 <Saizan> id never quite gets the information the same way a value of an existential type never gives it back
04:12:58 <Saizan> if we could type-case it'd be different
04:13:29 <bitonic> Saizan: if we could type-case Haskell would be very different :)
04:13:32 <Saizan> but, there are systems where you can existentially quantify over inductives which you can pattern match against
04:13:57 <Saizan> and then to get something much like haskell's exists you do bring up type-checking-time erasure
04:14:54 <bitonic> Saizan: what systems were you thinking of?
04:15:50 <bitonic> I thought is was well accepted that pattern matching on types was not a good ideas, and instead some reflection mechanism is better
04:16:15 <Saizan> bitonic: reread
04:17:25 <bitonic> Saizan: then I’m not sure what you mean by ‘existentially quantify over inductives’
04:18:03 <Saizan> s/inductives/elements of inductive types/
04:21:47 <bitonic> Saizan: oh, OK, so the ‘usual’ dependent product would work for what you are saying, since you can pattern match on the first element of the tuple
04:23:24 <bitonic> Saizan: so aren’t you saying that you can erase constructors during type checking if you need to do evaluation at type checking?
04:23:49 <no-1> how do I check whether a given value is a key of a given map?
04:24:21 <bitonic> no-1: Data.Map.member?
04:24:35 <Spockz> would it be an idea to add constraint kinds to classes such as Category and Arrow so that they are more extendable?
04:24:41 <no-1> yep. thanks.
04:25:24 <Saizan> bitonic: no, because you'd introduce a modality or a special quantifier to go along with this erasure, like agda's "." irrelevance
04:27:16 <bitonic> Saizan: ‘.’ = dotted patterns?  so the fact that you don’t have to force the constructor for a dotted match?
04:29:41 <Saizan> bitonic: no, the other use of dot
04:30:11 <Saizan> bitonic: f : .A -> B means f x = f y for any x and y
04:34:28 <bitonic> Saizan: oh, I didn’t know that, neat.  does the type checker derive laws to use with def. equality when you declare it like that?  in any case c_wraith was talking about something else, afaict
04:38:16 <Saizan> bitonic: i went on a tanget but the concepts are interestingly related
04:38:38 <Saizan> bitonic: and yeah, the equation above holds definitionally
04:40:00 <bitonic> Saizan: my main point was that in Haskell existentials don’t have a ‘privileged’ position in terms of irrelevance/type erasure
04:40:12 <Saizan> bitonic: https://github.com/copumpkin/categories/blob/master/Categories/Category.agda#L16 <- here it's used so that the proofs don't matter with equality
04:40:15 <bitonic> Saizan: does it do the same for collapsible types automatically?
04:40:23 <bitonic> no sorry
04:40:24 <bitonic> for Props
04:40:48 <Saizan> nope
04:41:30 <bitonic> Saizan: are there any barriers to do that?  it seems easily doable, with Coq it’s a bit easier because they have a Prop to begin with
04:42:36 <Saizan> bitonic: Coq's Prop has disjunctions in it btw
04:43:09 <bitonic> (I meant contractible before btw :P)
04:43:17 <Saizan> bitonic: anyhow i wasn't trying to go against your point but to refine it
04:43:26 <augur> bitonic: proof irrelevance is supposed to make Prop irrelevant
04:43:27 <augur> :)
04:43:39 <bitonic> Saizan: refinement accepted you brought interesting points :)
04:44:59 <bitonic> Saizan: disjunctions?  isn’t Prop irrelevant?
04:45:28 <augur> i dont follow this disjunction talk
04:46:39 <Saizan> bitonic: Coq's Prop is runtime irrelevant because the elimination rules are restricted so that the value of a Prop never matters for things in Set in closed computation, iiuc
04:47:24 <Saizan> bitonic: but it's not typechecking-irrelevant like epigram2's Prop is
04:47:44 <bitonic> Saizan: I guess that works.  but the convenient thing related to what we were saying is that if you have an inductive definition with one constructor, if you have only Prop arguments to the constructor the resulting type is Prop as well
04:48:08 <bitonic> Saizan: yes that definitely matters with OTT
04:48:13 <Saizan> bitonic: pigworker tweeted recently on an hacked Coq with a typechecking-irrelevant universe though
04:48:34 <bitonic> Saizan: ‘hacked’ as in embedding or as in they changed Coq’s source code :P?
04:48:38 <augur> how does type-checking irrelevant Prop work?
04:48:41 <augur> whats an example of this?
04:48:44 <Saizan> bitonic: both i think
04:49:01 <bitonic> augur: if you have only ⊥ ⊤ ∀ ∧
04:49:23 <Saizan> bitonic: anyhow you don't get x = y definitionally for x : A, y : A, A : Prop
04:49:23 <bitonic> so ‘no data’
04:49:28 <Saizan> bitonic: in Coq
04:49:42 <augur> bitonic: right but i mean, thats just Prop. how does type-checking irrelevance figure into the picture
04:49:43 <Eotane> Hey would I be able to get help with a haskell error
04:49:45 <Eotane> ?
04:49:55 <Saizan> Eotane: sure
04:50:19 <Eotane> I think its an indentation error
04:50:34 <Saizan> Eotane: put the code and the error on hpaste.org
04:50:55 <bitonic> Saizan: weird, although I can imagine them wanting disjunctions in propositions
04:50:58 <hpaste> Eotane pasted “indentation error” at http://hpaste.org/84858
04:52:00 <Saizan> Eotane: you can't have where in the middle of an expression
04:52:28 <bitonic> augur: as Saizan says you have definitional laws that tell you that all Props are equal when typechecking, while with Coq you can erase them when compiling basically
04:52:31 <bitonic> in closed terms
04:52:57 <Eotane> where can I put it then?
04:53:14 <hpaste> Saizan annotated “indentation error” with “indentation error (annotation)” at http://hpaste.org/84858#a84859
04:53:22 <Eotane> or do i have to re write the code in a different way?
04:53:25 <Eotane> like restructure it
04:53:48 <Saizan> Eotane: http://hpaste.org/84859 <- that should work
04:54:01 <Eotane> awesome I'll try it now
04:54:04 <augur> bitonic: all PROPS are equal?
04:54:05 <augur> no no
04:54:09 <augur> all MEMBERS are equal
04:54:11 <bitonic> augur: although I don’t understand how Coq Prop’s works given what saizan says
04:54:13 <bitonic> augur: yes, sorry
04:54:13 <augur> but not all PROPS certainly not
04:54:36 <bitonic> yeah that’s what I meant
04:54:48 <augur> but what i mean is, whats an example of type-checking irrelevance. because certainly props are relevant for type checking in SOME settings
04:55:09 <augur> so im curious what epigram's irrelevance/props are like that distinguish them. or their elements or whatever
04:55:10 <Eotane> Saizan: That worked! thanks!
04:55:21 <Saizan> Eotane: cheers :)
04:55:46 <bitonic> augur: well for example what we were saying before, that if you have a ‘foo : Prop -> A’ you get for free ‘∀ x y. foo x = foo y’ for definitional equality
04:56:04 <bitonic> so that influences type checking
04:56:32 <bitonic> since your = is larger (where = is definitional equality)
04:58:22 <augur> bitonic: i meant, whats an example of something concrete that epigram can/cant do as a consequence
05:00:36 <bitonic> augur: I think that the fact that you can remove the ‘coe’s at the end requires that, that, if you are familiar with OTT, but it’s all very subtle.  you can also surely manufacture some example where the definitional law I cited helps
05:01:01 <augur> subtlety :(
05:01:40 <bitonic> I know right
05:03:32 <bitonic> (remove ‘coe’s if the coercees are def. equal)
05:07:30 <Heffalump> Spockz: I mean that there's no way you can write it, whether with or without the class
05:08:23 <nicoo> While looking at Data.Data, I wondered why Constr (the type representing constructors) isn't parametric, since there are no guarantees when you mix constructors from different types
05:08:28 <nicoo> Any ideas ?
05:13:10 <bitonic> nicoo: if you want to work on them generically you’re going to have to get rid of the parameter eventually anyway
05:13:30 <bitonic> I suppose it might have been helpful to parametrise them...
05:17:11 <bitonic> but then you’d eventually have some generic representation anyway, the classic thing that you need to do is to get the name of the constructor, e.g. if you want to generate JSON
05:20:02 <Heffalump> Spockz: I added some more explanation
05:21:32 * hackagebot approx-rand-test 0.1.1 - Approximate randomization test  http://hackage.haskell.org/package/approx-rand-test-0.1.1 (DanielDeKok)
05:21:35 <nicoo> bitonic: true, but parametrisation doesn't change anything in these usecases, yet prevents us from accidentaly mixing stuff from separate types ; there might be cases where you mix Constr from different datatypes in a common datastructure, then pull them back (and hope you don't match Constr from different types), but I'ld rather lug aroung GADT equality witnesses so that the compiler checks I didn't mess up :)
05:41:33 * hackagebot hangman 1.0 - Hangman implementation in Haskell written in two hours.  http://hackage.haskell.org/package/hangman-1.0 (HokShunPoon)
05:45:58 <Spockz> Heffalump: I see I made a mistake in the type of Id, that should be DSL a a
05:46:02 <Spockz> Heffalump: thank you for your more thorough explanation
06:00:08 <simukis_> is there a function to test if one FilePath is in another FilePath. (accounting for possible directory links and things like that)
06:00:41 <simukis_> s/./?/
06:01:18 <bitonic> nicoo: it’s a judgement between simplicity of the interface and type-safeness.  it’s easy to have a newtype that does what you want
06:05:29 <bitonic> nicoo: it might be that in this case the additional type safety comes at a little cost, in which case it should be parametrised
06:10:23 <Spockz> simukis_: I think you can normalize file paths, so normalizing and then performing an equality check could work
06:19:28 <ab9rf> Spockz: normalizing file paths can be expensive
06:20:23 <ab9rf> and doesn't work in the general case
06:20:46 <ab9rf> on a unix-like platform you can reduce a local path to a (device,inode) pair and compare those
06:21:09 <ab9rf> but that doesn't work for resources on remote devices
06:21:50 <ab9rf> the same remote filesystem might be addressable by multiple different paths, and it's basically impossible to test for that without having direct access to the remote server
06:21:54 <bss03> I don't think simukis_ wanted an equality test, anyway.
06:22:43 <bss03> simukis_ wanted an "is in" test.
06:23:25 <bss03> Normalizing and finding if one is the prefix of the other could work, but normalizing isn't always well founded even on all-local filesystems.
06:24:15 <bss03> For example, /home/user/.wine/z:: is often a symlink to /, forming a nice link loop.
06:25:09 <simukis_> bss03: I don't really care about such evil schemes like link loops.
06:25:51 <bss03> That particular case isn't troublesome, but in general following synlinks (normalization) is going to be equivalent to evaluating _|_.
06:27:55 <simukis_> ok, let me rephrase a bit as I feel I described too general case here.
06:28:03 <ab9rf> bss03: which is why in a unix environment one nromally just runs stat on the file and compares the blkdev and inode fields.  but that doesn't work for comparing paths to objects that do not yet exist.
06:28:23 <bss03> If you are fine with normalizing, do that first and then check (container `isPrefixOf` element) && ('/' `elem` drop (length container) element.) or something like that.
06:29:30 <quchen> So I have these two modules, and I want both of them to implement the same API. What's a good way of accomplishing this? If I use a typeclass, I have to create a dummy type for each of them, but this would enforce the API.
06:29:56 <quchen> I could also just write two modules with the same API by hand, but then I'd lose the compile time safety.
06:30:16 <simukis_> I have a one absolute path, given by system, it is always accessible by normal means and is already normalized. Another path comes from user and it might be anything really. I need to check if path by system is inside a path of user given directory. So normalizing user path and checking if it is a prefix of system path is sufficient?
06:30:18 <bss03> ab9rf: Technically, I'm pretty sure POSIX requires (dev, ino) to be a unique identifier.  I know older NFS broke that assumption; I'm not sure if it works on modern systems.
06:30:26 <quchen> (One of the modules does some stuff, and the other one just prints what it would do to the console for debugging)
06:30:45 <ab9rf> bss03: it works modulo network mount points and filesystems that don't have inodes (like fat)
06:32:50 <bss03> simukis_: That should be very close to what you want.  "/home/.cabal" doesn't contain "/home/.cabal-private-saved-do-not-delete-really" so you want to check for a directory separator in there too, I think.
06:33:08 <ab9rf> simukis_: it depends on whether you consider using a symlink to escape from the "jail" a violation or not
06:34:06 <ab9rf> if the jail path is, say, /jail and /jail/a/b/c is a symlink to /etc, is /jail/a/b/c/passwd permitted or not?
06:34:34 <Spockz> ab9rf: sure, but what other option does he have?
06:34:48 <ab9rf> that's "in" /jail for a simple textual normalization, but "out" if you use normalization + symlink parsing
06:34:56 <bss03> quchen: You could have the "API" be an (G)ADT and have each of the modules export a value of that type.
06:35:02 <ab9rf> Spockz: it depends on the purpose here
06:35:08 <simukis_> ab9rf, yes it is :) Thanks.
06:35:11 <ab9rf> if the purpose is operational security, it's clearly _not_ sufficient
06:35:49 <bss03> quchen: Most TCs have a corresponding (G)ADT, for when you want to pass things around explicitly or have two instances or other reasons.
06:36:52 <geekosaur> (1) general case, network filesystems *can't* guarantee unique dev/ino --- you might overflow either or both values, conceivably; (2) the only "safe" way to canonicalize is to cd to the target directory and then compute the path to the root, but it can get you into permissions issues (can't cd back) so you need to do it in a subshell
06:37:05 <geekosaur> in short, canonicalization is quite nasty
06:37:22 <Spockz> can't you ask it to the OS?
06:37:41 <geekosaur> what makes you think the OS has it?
06:37:58 <ab9rf> geekosaur: it's impossible in the general case in the sense that for network mount points there can be multiple "canonical" names with no reason to prefer one over the other
06:38:14 <geekosaur> ab9rf, that is *one* possibility
06:38:20 <geekosaur> there are others.
06:38:26 <bss03> geekosaur: (1) Isn't true.  The OS VFS layer can intercept the remote values and provide a mapping, and fail the stat call when it runs out of mappings.
06:38:28 <ab9rf> geekosaur: if you use an arbitrary rule to break the tie, then you have a canonicalization process that is stochastic :)
06:38:51 <geekosaur> bss03, if the stat call fails the file is "not there" and your network filesystem is fail
06:39:06 <geekosaur> Spockz, unixlikes do in the kernel, but it's not in a form you can use directly; the way you ask the OS to do it is chroot()
06:39:07 <bss03> geekosaur: Network file system fail all the time.
06:40:03 <Spockz> geekosaur: I would have assumed so :)
06:40:35 <ab9rf> chroot in posixlikes can help with this, but it doesn't solve all problems and introduces a whole bunch more :)
06:40:44 <geekosaur> also note that any such path checking is potentially subject to timing symlink attacks
06:41:17 <geekosaur> which is why chroot() is how the OS exposes this functionality, since it's done as part of the actual file access and doesn't permit races
06:46:35 * hackagebot names 0.2.2 - Type level names.  http://hackage.haskell.org/package/names-0.2.2 (JulianFleischer)
06:48:07 <quchen> bss03: So my GADT would basically be a huge tuple
06:48:32 <hpaste> rifki pasted “error” at http://hpaste.org/84865
06:48:48 <rifki> hi, how can I solve the error in the paste?
06:49:12 <geekosaur> people sill use hugs? *sigh*
06:49:26 <bss03> quchen: You would use the record syntax, but yes.
06:49:31 <geekosaur> but, not seeing any code there, I don't think anyone can answer other than generally
06:49:47 <Botje> rifki: you could stick fromIntegrals in there, but you should standardize on one of the two types.
06:50:35 <Botje> (Int is probably the best choice for most algorithms)
06:51:03 <bss03> rifki: You (maybe) need some fromInteger / toInteger conversions in there.
06:51:43 <quchen> bss03: Hmpf. I keep switching between GADT and class haha
06:51:50 <bss03> rifki: Int /= Integer.  Integer is slower but can store numbers like one googol, Int is roughly your machine word.
06:52:01 <quchen> bss03: But thanks, I'll look into that
06:52:42 <rifki> I have tried to change the type of my function but at this time I got : ERROR "play.hs":64 - Type error in explicitly typed binding
06:52:52 <rifki> I guess I'm doing it in the wrong way
06:53:24 <bss03> quchen: I think classes is more "common", but some people consider that use of classes as a bit of an anti-pattern.  GADTs aren't Haskell2012, though, so the class-y way might be more "portable" (?)
06:53:50 <bss03> rifki: It would be much easier to help if we could see the code.
06:54:00 <quchen> bss03: Well, classes would require some dummy type for me, and classes without laws feel like an antipattern, yes.
06:54:08 <bss03> rifki: I'm mostly just guessing / reading the error.
06:54:22 <quchen> bss03: The main thing that makes my problem more complicated is that I need a different container type in the two modules.
06:54:28 <quchen> In the class case, I can use TypeFamilies
06:54:43 <quchen> With GADTs I'm not sure how to do it
06:54:47 <rifki> is it ok if I send the types only?
06:55:57 <bss03> quchen: Ah, I'm pretty usre you can use type families with GADTs, but I only really got my head around type families (I think) this week.
06:57:08 <bss03> rifki: ... maybe.
06:57:45 <bss03> rifki: It will certainly help, but I can't guarantee I'll have your answer.
06:58:04 <rifki> bss03: okey
07:00:44 <rifki> I'm pasting some functions and some type definitons
07:00:50 <hpaste> rifki pasted “types” at http://hpaste.org/84868
07:01:48 <hpaste> rifki revised “types”: “types” at http://hpaste.org/84868
07:03:11 <geekosaur> so, very likely, you want to decide which of Int or Integer you are using and use it everywhere. certainly, all of the tuples should be one or the other; without seeing code, can't reliably say if the standalone ones should match
07:04:47 <rifki> I'd be happy if  giveNearestCorrect returns  (Int,Int)
07:05:49 <geekosaur> wait, so you're not proviing any actual types in your code?
07:06:32 <rifki> I'm not, I have tried but it gave me another error :/
07:06:35 * hackagebot named-records 0.2.2 - Flexible records with named fields.  http://hackage.haskell.org/package/named-records-0.2.2 (JulianFleischer)
07:12:54 <quchen> bss03: looks like I'm going to learn more about this stuff than I had thought initially
07:12:57 <quchen> ... by accident
07:17:22 <bss03> quchen: ... sorry?
07:17:47 <quchen> bss03: Combining GADTs with TypeFamilies
07:18:06 <quchen> ... and from what I've read there are a couple more extensions that come along when you're using those
07:18:53 <bss03> No, I mean... sorry about that... sometimes I mean I get off on a learning tangent like that I don't get what I wanted to accomplish done. So sorry if you didn't want to know more about type families and gadts today. :P
07:29:18 <gspr> A vague question, perhaps, but am I correct in thinking that if Prelude were written today, most functions that use Int to signify lengths of or positions in lists would instead use (Integral a) => a?
07:30:07 <Philippa> probably
07:34:08 <gspr> OK. Should I then draw the conclusion that whenever one writes a function whose value is an integer (in the mathematical sense), one ought really to let the value be (Integral a) => a? I repeatedly find myself thinking: "This is a function into the integers. Integer models the integers nicely, but for practical purposes we'll probably want Int. Let's just make the function return Int."
07:34:15 <bitonic> gspr, Philippa: I’m not sure there is much agreement on that, many people maintain that mono types are clearer and make for better error messages
07:35:00 <gspr> bitonic: Interesting...
07:36:04 <eikke> gspr: don't forget polymorphism can at times limit efficiency/optimizations
07:36:45 <gspr> eikke: Yeah, that always bites me :/
07:37:00 <gspr> s/always/often/
07:38:17 <Philippa> you can always request specialisations on Int and Integer
07:38:45 <kryft> mono types?
07:39:42 <eikke> kryft: monomorphic
07:40:45 <jedai|2> Specializations makes that pretty moot for Integral
07:42:03 <kryft> eikke: Ah, as opposed to polymorphic
07:42:18 <eikke> yeah
07:45:12 <gspr> I guess I've probably always forced the wrong picture of the relationshio between mathematical structures and data types... maybe I shouldn't (as I long have) think of, say, Integer as "the set of integers", but rather of each (Integral a) => a as "a representation of the set of integers". (All of this is pretty moot since Num and friends so badly mimick mathematical structure anyway, but I like to pretend that someday there'll be an agreed-upo
07:45:17 <amyers> eikke: If for a polymorphic return value your return type must be Int (for example) ghc will eliminate the dictonary and call the Int version directly right?
07:47:11 <Philippa> gspr: somewhere in-between, as fromIntegral's allowed to fail
07:51:03 <Philippa> amyers: yes, but it's trickier to make sure that the Int version always calls the Int version
07:51:04 <Philippa> (directly, that is)
07:51:39 <amyers> Philippa: What do you mean "the Int version always calls the Int version"?  Do you mean it's trickier to ensure that the call site is not also polymorphic and would allow, say, either Int or Integer?
07:52:06 <Philippa> amyers: I mean specialisation's a PITA, basically
07:53:25 <amyers> Philippa: Forgive my ignorance.  I'm not sure what you mean :p
07:53:37 <amyers> Philippa: Specialization of type classes?  For the programmer of the compiler?
07:53:47 <arkeet> specialization of functions.
07:53:53 <arkeet> polymorphic functions.
07:54:05 <amyers> Ah, right
07:54:17 <amyers> So talking about the compiler's ability to specialize at a call site?
07:54:26 <arkeet> sure
07:54:29 <arkeet> well
07:54:36 <arkeet> you have to give it a directive to do that.
07:54:42 <bitonic> there are compilers that do whole program optimisation and depolymorphise everything, like mlton.  with GHC you do it manually
07:56:11 <amyers> hmm, are we talking about 'specialize' as in this specialize?
07:56:11 <amyers> http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/pragmas.html#specialize-pragma
07:56:16 <arkeet> yes
07:56:21 <amyers> Okay, that was my confusion
07:56:25 <Philippa> amyers: so you've got a polymorphic function f that's not actually in the dictionary, and it's (monomorphically) recursive. You call it at a known type. That's when the fun and games start
07:58:22 <amyers> Philippa: How could a function like 'length :: Integral a => [t] -> a' not be in the dictionary?
07:58:58 <Philippa> why *would* it be?
07:59:24 <amyers> hmm, good point
07:59:36 <amyers> why would length be in the integral dictionary?  obvious once you point it out
07:59:39 <Philippa> Everything before the => is effectively "please pass me this dictionary to call me". You only see the methods in the class definition show up in the dictionary
07:59:42 <amyers> I think I see what you're saying now
08:00:10 <Philippa> remember, our dictionaries *aren't* dictionaries in the python sense, it's just a name someone gave to what are essentially records representing instances
08:02:00 <amyers> Philippa: So in order to do what I was thinking length would have to be a function in the Integral typeclass
08:02:02 <amyers> which doesn't make sense
08:02:03 <amyers> right?
08:02:28 <Philippa> right. Or you can ask to specialise it for Int or Integer
08:03:02 <amyers> Which is harder for the compiler because there might not be sufficient information about the concrete type
08:03:09 <amyers> ?
08:03:17 <arthurmaciel> good afternoon!
08:03:18 <cmccann> amyers: note that many type classes do include strictly unnecessary functions for the sake of performance
08:03:43 <cmccann> though that's as much about optimizing the implementation for specific instances as anything else
08:04:04 <cmccann> an obvious example being (>>)
08:04:21 <amyers> cmccann: That's what I've always seen in documentation.  I hadn't thought of it being also useful for this specialization case
08:04:30 <amyers> But it makes sense
08:05:10 <amyers> Thanks for clearing up my confusion :)
08:08:51 <gspr> I heard someone say once that if all the relevant code is in the same module, then GHC can specialize everything (if concrete types are supplied at some point, that is). Is this correct?
08:09:42 <jmcarthur> gspr: i wouldn't put it that strongly. ghc does do some more aggressive optimizations intra-module
08:10:07 <jmcarthur> gspr: e.g. if a nonrecursive function is only used once and not exported, it is unconditionally inlined
08:10:49 <gspr> ah
08:10:59 <cmccann> GHC does a lot of clever things when it can, but few reliably enough to assume unless the performance is non-critical or you understand GHC very well
08:11:48 <bitonic> gspr: if you have all the code available you obviously *can* specialise everything, this doesn’t mean that GHC will necessarily do that
08:12:00 <Philippa> or that you want to, for that matter
08:12:00 <cmccann> the strictness analyzer may turn foldl into foldl' sometimes but I'd still use the latter if the former would probably crash
08:12:17 <gspr> Would it be interesting, if only for benchmarking purposes, to have a program that takes a collection of modules and mangles names to place everything in a single module to measure how much better GHC specializes then?
08:12:21 <bitonic> gspr: again it might be interesting to look at MLton if you are interested in that, they do specialise *everything* iirc
08:12:30 <gspr> bitonic: Interesting!
08:12:49 <jmcarthur> yeah MLton is pretty impressive
08:12:51 <ChongLi> isn't it the case that Haskell only builds up laziness on constructors?
08:13:03 <ChongLi> that is, builds thunks
08:13:19 <geekosaur> I think jhc also does that kind of thing? (although it doesn't support anything like as many extensions as ghc)
08:13:30 <bitonic> ChongLi: well, constructors are only the only way to build data in Haskell (apart from some primitive types)
08:14:13 <ChongLi> but this is something to keep in mind for when considering to add strictness annotations?
08:14:17 <cmccann> it's more that every expression creates a thunk but a handful of things force them
08:14:28 <bitonic> ChongLi: I’m not sure what you mean
08:14:47 <ChongLi> well if you add strictness annotations to the fields of your data types
08:15:02 <ChongLi> it'll evaluate those instead of storing a thunk there?
08:16:00 <jmcarthur> yes, if you evaluate the constructor they are under (but of course those strict fields could themselves have nonstrict fields in their representations, so there is no guarantee that the evaluation will be performed deeply)
08:16:01 <bitonic> ChongLi: it’ll force the first constructor of those fields, yes (whnf)
08:17:00 <ChongLi> so with good discipline you can avoid unwanted thunks :)
08:17:01 <jmcarthur> ChongLi: also, we should distinguish data constructors from newtype constructors since the latter do *not* change laziness or strictness
08:17:13 <tsou> #ifdef USE_REPORT_PRELUDE <- what exactly is this USE_REPORT_PRELUDE?
08:17:31 <ChongLi> a newtype goes away at compile time, right?
08:17:35 <cmccann> tsou: use the Haskell Report's version of the Prelude definitions
08:17:35 <bitonic> ChongLi: well, some argue that you should always put !s unless you explicitly want lazy data, it depends
08:17:45 <jmcarthur> tsou: ghc has changes to the standard library that are not in the spec
08:17:47 <cmccann> vs. GHC's optimized versions of some
08:17:49 <geekosaur> tsou: ghc's customized prelude has some optimizations over the one specified in the haskell libraries report
08:17:56 <cmccann> the Prelude versions are much nicer to read
08:17:59 <bitonic> ChongLi: there’s also the fact that functions and lets will still be non-strict
08:18:05 <Philippa> Haskell per se doesn't know WTF a thunk is
08:18:06 <bitonic> so that’s another form of lazyness
08:18:22 <ChongLi> right, but functions are less of a problem I think
08:18:25 <Philippa> (nor are we guaranteed lazy evaluation just because we're using a Haskell implementation :p Non-strictness is not the same thing)
08:18:56 <ChongLi> although it can be funny to have laziness mixed with asynchronous code
08:19:03 <bitonic> ChongLi: yeah most people think of it that way.  one common use case for strict functions is things with accumulators
08:19:03 <tsou> hmmm
08:19:08 <jmcarthur> ChongLi: what do you mean?
08:19:19 <ChongLi> where you end up with every callback just glomming more thunks on
08:19:25 <ChongLi> and nothing getting done
08:19:25 <jmcarthur> ChongLi: our IO *is* (internally) asynchronous
08:19:33 <jmcarthur> (in GHC)
08:19:37 <tsou> i was looking at the definition of nub, and I don't see why it should matter (this #ifdef I mean)
08:19:41 <cmccann> also, despite "strict fields" being a thing, strictness is really a property of expressions in context
08:19:49 <ChongLi> and then you finally reach the consumer and he ends up doing all the work
08:19:58 <cmccann> you can't just make a value "strict" and expect it to be evaluated
08:20:02 <bitonic> ChongLi: that’s not how most IO works in Haskell nowadays
08:20:09 <jmcarthur> ChongLi: i don't see what that has to do with IO
08:20:17 <cmccann> you can only make certain expressions force other expressions when they're forced themselves
08:20:19 <bitonic> jmcarthur: I think he’s referring to lazy IO
08:20:21 <jmcarthur> ChongLi: maybe with lazy IO that could be interesting
08:20:25 <ramile> quit
08:20:36 <ChongLi> yeah, lazy IO
08:20:53 <bitonic> ChongLi: in the IO monad various considerations about strictness apply
08:20:55 <jmcarthur> yeah that not the same thing as asynchronous IO
08:21:04 <jmcarthur> bitonic: ?
08:21:11 <jmcarthur> bitonic: that sounds kind of misleading
08:22:06 <cmccann> many functions that do IO are very strict in their arguments, but that's not because of the IO as such
08:22:06 <ChongLi> so where does forcing happen?
08:22:12 <Philippa> case
08:22:21 <Philippa> and some primitive operations
08:22:21 <cmccann> pattern matches, mostly.
08:22:33 <ChongLi> since pattern matches are just sugar for cases?
08:22:36 <cmccann> yes
08:22:43 <bitonic> jmcarthur: well right, I was more referring about most of the primitive operations in IO
08:23:03 <ChongLi> yeah this is pretty elegant
08:23:14 <cmccann> ChongLi: function application also forces the function being applied
08:23:38 <dockside1> Did you say that pattern matching is sugar for switch case?
08:23:41 <ChongLi> I think it's interesting how you approach everything from the opposite side
08:23:51 <bitonic> ChongLi: the unelegant exception is ‘seq’
08:24:04 <cmccann> but simply applying a function does not force anything about the argument or the result of the application, which seems to trip people up in understanding strictness
08:24:11 <Philippa> dockside1: no. All pattern-matches that aren't in a case statement desugar to case statements
08:24:22 <Philippa> "switch case" doesn't exist in Haskell
08:24:28 <Philippa> "compiles to" is not the same thing
08:24:54 <cmccann> well, GHC does use the term desugaring for a lot of stuff
08:24:57 <ChongLi> a lot of people criticize Haskell for how you have to reason about laziness
08:25:08 <cmccann> it tends to talk about Haskell itself as syntactic sugar over GHC Core, heh
08:25:12 <ChongLi> but they just take for granted that you have to reason about strictness in strict languages
08:25:15 <dockside1> Good, because I read it as that, and even if there are not switch cases in haskell it is "well" defined and I wouldn't agree
08:25:23 <jmcarthur> i think most, but not all, of those criticisms of laziness are way overblown
08:25:24 <ChongLi> otherwise you end up doing a lot of unnecessary work
08:25:35 <jmcarthur> some objections are still reasonable
08:25:40 <bitonic> ChongLi: in terms of reasoning about the semantics of a program lazyness actually helps.  most of the laments are about space leaks, and some are justified
08:25:49 <bitonic> (denotational semantics :)
08:25:54 <cmccann> the one way that strictness is more intuitive is that you can reason forwards step by step
08:26:12 <dockside1> And it definitly does not compile to the same thing, they are not even functionally equivalent
08:26:14 <jmcarthur> e.g. it kind of sucks that i can't assume that just because i'm holding some variable in hand that it's already evaluated and won't cause my function to fail to terminate
08:26:17 <joaopizani> hello everyone, does any of you have some experience using the SBV library from Hackage, binding with the z3 theorem prover?
08:26:20 <Philippa> bitonic: right. We leak space, they leak time
08:26:27 <cmccann> whereas laziness requires reasoning backwards along the flow of dependencies, not the forward flow of strict execution
08:26:30 <ChongLi> it's really nice how laziness frees you from the annoying task of worry about what order everything appears on screen
08:26:47 <bitonic> Philippa: we amortise.
08:26:48 <dockside1> We are not the only ones to leak speace
08:26:55 <ChongLi> of having to write silly "forward declarations"
08:26:55 <fryguybob> ChongLi: Yes, the leads to really nice refactoring.
08:26:57 <dockside1> Most C/C++ does it
08:27:00 <dockside1> Java
08:27:07 <Philippa> dockside1: "simple case" can be implemented fairly easily in terms of a switch statement if you've implemented your algebraic datatypes that way
08:27:16 <Philippa> dockside1: yeah, I was alluding to a fundamental duality though
08:27:22 <Philippa> (we leak time, too...)
08:27:31 <dockside1> Yeah :)
08:28:20 <ChongLi> is there ever a situation where a case over Ints will get transformed into a jump table?
08:28:37 <ChongLi> that's a nice optimization in C
08:28:50 <Philippa> ChongLi: the compiler is entirely free to implement case however it wants
08:29:13 <cmccann> ChongLi: does this help? http://stackoverflow.com/q/9027384/157360
08:29:31 <bitonic> see the Augusston paper
08:29:40 <ChongLi> very nice
08:29:55 <cmccann> that said, "pattern matches" on Int literals translate to if expressions and equality checks
08:30:23 <cmccann> though I'm sure GHC does other obvious optimizations for common stuff like that
08:30:30 <ChongLi> yeah, so if you want a jump table make sure to explicitly use a case of Ints
08:30:33 * bitonic finds out that ‘Compiling pattern matching’ is paywalled
08:31:02 <ChongLi> or some Enum type?
08:31:29 <dockside1> Well if it becomes Int in Core I'm sure ghc wont know the difference
08:31:29 <cmccann> ChongLi: case expressions involving literals are done with equality checks in general
08:31:34 <bitonic> ChongLi: what cmccann says is that with GHC it’s safer to use data types if you want constant time ‘case’
08:32:01 <cmccann> a custom type with nullary constructors like in that SO question is different
08:32:11 <dockside1> Constant vs Linear 5?
08:32:47 <bitonic> dockside1: Ints in Haskell are special because they are machine integers instead that data types, so Core knows the difference
08:32:49 <dockside1> Unless the code is generated from a meta language i have a hard time seeing you can get optimizations that are worth your time
08:33:12 <bitonic> every Haskell implementation must know the difference
08:33:13 <ChongLi> if your type is a bunch of nullary constructors and it's an instance of Enum it gets turned into primitive Ints?
08:33:24 <cmccann> the Enum class has nothing to do with it
08:33:31 <ChongLi> oh
08:33:41 <cmccann> and the representation of data types is its own question
08:33:59 <jmcarthur> ghc doesn't always do the smart thing with  data Foo = A | B | C | D
08:34:05 <cmccann> I seem to recall that enumeration-style types like that are handled specially by GHC though
08:34:10 <cmccann> but I'm not sure
08:34:27 <ChongLi> hmm
08:34:37 <jmcarthur> if you *really* care about speed, it's sometimes worth doing this:   newtype Foo = Foo Int; a = Foo 0; b = Foo 1; c = Foo 2; d = Foo 3
08:34:56 <bitonic> well but Foo is even better than an Int in terms of ‘case’
08:35:21 <ChongLi> but that doesn't give meaningful names
08:35:21 <bitonic> because implementing a constant ‘case’ is much easier
08:35:21 <dockside1> tbh, if you really care about speed, highlevel languages are not your cup of tea 2013
08:35:22 <cmccann> really though this is all fiddly details of GHC and may not even be consistent between versions
08:35:48 <cmccann> it's not worth worrying about, all of this stuff will be "fast enough" 99% of the time
08:36:02 <ChongLi> dockside1: I don't accept that dichotomy; I've seen plenty of examples of really fast Haskell :)
08:36:10 <dockside1> So have I
08:36:20 <jmcarthur> bitonic: the main issue is that enum types aren't unpackable
08:36:23 <cmccann> and when it needs to be faster you'll be optimizing a specific use, not worrying about generalities
08:36:24 <jmcarthur> bitonic: http://www.haskell.org/haskellwiki/Performance/Data_types#Enumerations
08:36:38 * hackagebot names 0.2.3 - Type level names.  http://hackage.haskell.org/package/names-0.2.3 (JulianFleischer)
08:36:41 * hackagebot named-records 0.2.3 - Flexible records with named fields.  http://hackage.haskell.org/package/named-records-0.2.3 (JulianFleischer)
08:36:41 <ChongLi> I'm not really worrying about it, just considering what areas might be worth investigating down the road
08:36:56 <dockside1> but I can't write performance oblivious Haskell or even without GHC extentions, and expect C performance
08:37:07 <jmcarthur> bitonic: also note that the wiki claims there is not performance penalty for pattern matching with that, but i haven't seen any other claims about it
08:37:40 <tsinnema> hey -- any recommendations for tools for haskell programming? i'm used to writing scala with vim, ctags, and some scala-specific syntax and ctags configuration.
08:37:51 <jmcarthur> ChongLi: i promise most of this stuff is not worth investigating unless your particular program demands it
08:37:57 <bitonic> jmcarthur: sure, but in terms of implementing ‘case’ you’re in a better position—as I said, you can easily implement constant ‘case’
08:38:05 <bitonic> with Ints is trickier
08:38:09 <cmccann> you can't really write performance oblivious C and expect it to be fast either
08:38:13 <bitonic> although it doesn’t matter in reality anyway
08:38:23 <jmcarthur> bitonic: isn't that what I just said the wiki page says doesn't make a difference?
08:38:24 <bitonic> checking for equality 5 numbers is not going to be the bottleneck ehe
08:38:33 <dockside1> It's more true tho for C
08:38:36 <ChongLi> jmcarthur: what about games?
08:38:37 <Rotaerk> can you get C-like performance with haskell without turning it into C-in-haskell
08:38:42 <jmcarthur> ChongLi: depends on the game
08:38:49 <johnw> Rotaerk: certainly
08:38:49 <jmcarthur> Rotaerk: define "C-like"
08:38:51 <bitonic> jmcarthur: I’m not sure I believe that wiki.  those guards are going to be checked linearly
08:38:53 <Rotaerk> i.e. can you keep the functional style
08:38:54 <ChongLi> games that create a lot of garbage!
08:38:55 <dockside1> If we don't account for algorithmic blunders
08:39:02 <jmcarthur> bitonic: i'm not certain that is true
08:39:09 <jmcarthur> (either way)
08:39:10 <johnw> Rotaerk: sometimes, writing the algorithm in a simpler, functional style can allow compiler optimizations which are not possible for the corresponding C code
08:39:19 <ChongLi> that's probably the biggest concern, right?
08:39:20 <Rotaerk> ah
08:39:23 <bitonic> jmcarthur: but anyway, my whole point is that Foo is more manageable, a type with just 5 inhabitants
08:39:32 <bitonic> and the compiler knows that
08:39:32 <coppro> win 29
08:39:43 <johnw> not trying to outthink the compiler can pay off big with GHC, as it will totally rewrite your program behind the scenes to achieve better performance
08:39:43 <dockside1> johnw: that is very true
08:39:45 <cmccann> johnw: if memory serves me OCaml does even better there
08:40:02 <Rotaerk> johnw, good to hear
08:40:10 <Rotaerk> I wasn't sure how smart GHC is about optimization
08:40:17 <jmcarthur> bitonic: one nice thing ghc does that the wiki page might not be taking into account is that pointer tagging allows the runtime to propagate information about what the constructor is into the pointers to it so that it can eliminate some indirections
08:40:25 <johnw> cmccann: I know SPJ is working on a new kind of optimization right now which sounded exciting to me
08:40:33 <jmcarthur> cmccann: what?
08:40:50 * Philippa would like to remind people using games as an example that most games aren't AAA nth-generation optimisation fests
08:40:51 * RenJuan fixed a break in an app yesterday purely do to optimization
08:40:59 <RenJuan> *due
08:41:09 <jmcarthur> cmccann: the ocaml compiler is basically the dumbest (in both good and bad ways) compiler i know of
08:41:16 <Hafydd> What is an AAA nth-generation optimisation fest?
08:41:21 <cmccann> maybe I'm thinking of something else then
08:41:28 <bitonic> jmcarthur: in the end they’re probably going to be both fast enough, I guess the point that I was trying to get across is that having ‘newtype Foo = Foo Int’ is totally not worth it
08:41:37 <Philippa> for many, many games it's good enough to not be pathologically slow and pick your data structures sensibly these days. Even your phone goes pretty fast
08:41:38 <johnw> cmccann: he called it "cardinality"; from what i understood, it's about lambdas which are known by static analysis to be used only once, and which refer to a given variable once, it allows complete elision of the variable
08:41:39 * hackagebot hspec 1.5.0 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.5.0 (SimonHengel)
08:41:39 <cmccann> another ML-style language
08:41:43 <jmcarthur> cmccann: it just happens that the code you write in ocaml can be mapped quite straightforwardly to the vm
08:42:17 <cmccann> johnw: interesting
08:42:30 <Philippa> Hafydd: AAA means the biggest budgets going in the industry. Nth-generation as in "this is our nth game like this, we're not starting from scratch" - observe the changes over time in the Assassin's Creed series, for example
08:42:36 <dockside1> johnw: only lambdas?
08:43:09 <johnw> dockside1: you need visibility of how the variable is 'included' within a code block.  I think functions in 'where' definitions would count too
08:43:18 <jmcarthur> johnw: you mean it makes the closure smaller?
08:43:21 <Hafydd> Philippa: does "no starting from scratch" entail more or less optimisation than otherwise?
08:43:27 <johnw> jmcarthur: yes
08:43:33 <dockside1> As suspected, that is a nice optimization
08:43:34 <gavri> I'm about a third of the way through "the haskell school of expression" when I heard about hudak's new book available for free online "school of music". should I start reading "school of music". is it a better and/or more-up-to-date book than "school of expression" is?
08:43:45 <Philippa> Hafydd: In games? More, or at least that you're optimising over a larger codebase
08:44:01 <Hafydd> I see.
08:44:45 <Rotaerk> hmm generally, I would expect  immutability to have performance costs, since modifications of some complex data structure involve creating new data structures (perhaps not WHOLE ones since they can refer back to pieces of the original)... whereas mutability allows you to just change it in-place; does GHC ever optimize the former into the latter?
08:45:00 <jmcarthur> Rotaerk: that can be done as a library-level optimization
08:45:10 <Rotaerk> hmm
08:45:46 <jmcarthur> Rotaerk: it's probably not exactly what you meant, but look up "array recycling"
08:45:52 <Rotaerk> k
08:45:59 <jmcarthur> it's used in the vector library
08:46:12 <Philippa> Hafydd: each year, console titles are expected to do more on the same hardware. So work on how to do it accumulates and you end up with monstrous codebases I'm sure as hell glad I don't work on. That's one industry that could really use a Good Enough higher-level language and doesn't know enough to work out what it'd look like yet
08:46:25 <bitonic> jmcarthur: is that about reusing slices of vector/bytestring?
08:46:31 <Philippa> (anyone about to cite Tim Sweeney at me is welcome to bear in mind that Tim's mostly been targetting a subproblem)
08:46:39 * hackagebot hspec-meta 1.5.0 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.5.0 (SimonHengel)
08:46:41 <bitonic> jmcarthur: e.g. how ByteString.split works
08:46:47 <jmcarthur> bitonic: what do you mean "reusing slices"?
08:46:55 <jmcarthur> bitonic: you mean just pointing to different parts of the same array?
08:47:04 <jmcarthur> bitonic: no, that's just typical purely functions stuff
08:47:13 <jmcarthur> bitonic: array recycling is related to stream fusion
08:47:20 <bitonic> jmcarthur: yeah, but you have to do it manually with unpacked stuff like that
08:47:24 <bitonic> jmcarthur: oh, OK.
08:47:25 <jmcarthur> bitonic: allows you to eliminate intermediate mutable arrays in pipelines
08:48:06 <jmcarthur> bitonic: manually? all you have to do to implement slice is carry around the same buffer with different offsets and lengths
08:48:26 <bitonic> jmcarthur: yes, but it’s not the sharing that comes for free with ADTs
08:48:34 <jmcarthur> sure it is
08:48:49 <jmcarthur> i use the same buffer. it's shared. this is exactly the same thing
08:49:30 <bitonic> jmcarthur: ? I’m talking about the fact that consing shares the tail.  if you are implementing ByteString you are manually going through memory
08:49:41 <jmcarthur> ?
08:50:02 <jmcarthur> bitonic: if you are using ByteString, there is a buffer in memory that the bytestring points to along with an offset and a length
08:50:15 <jmcarthur> bitonic: when you slice it, you just point to the same buffer with a new offset and length
08:50:19 <jmcarthur> it's a normal ADT
08:50:57 <Philippa> that offset and length're probably what bitonic means by "manually going through memory"?
08:51:04 <dockside1> imo we should avoid optimizing our code, as this is a high level language and if the performance is bad we should be working on the compiler not our code
08:51:08 <bitonic> jmcarthur: I know that.  I was talking about the fact that setting up the buffer is not ‘normal ADT’
08:51:09 <tsinnema> any recommendations for tools or configuration files for writing haskell in vim ?
08:51:31 <dockside1> that applies to array recycling aswell
08:51:38 <Philippa> the thing about high-level languages is they're also supposed to help move optimisation work *out* of the compiler
08:51:44 <Heffalump> Spockz: ok, I was wondering about the Id constructor. In that case how do you get any non-identity terms in yuor GADT?
08:51:48 <jmcarthur> bitonic: sure the buffer is a primitive, but so are constructors and other things we use all the time
08:51:51 <Heffalump> I'm assuming you do have a way :-)
08:51:57 <jmcarthur> bitonic: but i wouldn't call it all that special
08:52:10 <jmcarthur> bitonic: and the sharing is completely unrelated to the buffer
08:52:19 <jmcarthur> except that it's the (entire) buffer that is shared
08:52:21 <bitonic> jmcarthur: I’m not sure what you mean, bytestring & vector & company need plentyful of inlinePerformIO to achieve those things
08:52:31 <bitonic> I’d definitely call that ‘special’
08:52:39 <jmcarthur> in terms of sharing it's not special
08:52:39 <bitonic> e.g. this is split: <http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/src/Data-ByteString.html#split>
08:52:42 <gspr> Is convert :: (Vector v a, Vector w a) => v a -> w a  from Data.Vector.Generic a no-op when v = w?
08:52:58 <jmcarthur> bitonic: the inlinePerformIO is not responsible for the sharing though
08:53:03 <dockside1> Philippa: I don't agree that is generally true, high level languages tend to be for humans to read first and machines strictly second
08:53:10 <jmcarthur> bitonic: it's just a part of the implementation for inspecting the buffer
08:53:26 <Rotaerk> Philippa, how? the higher the level the language, the bigger a gap between the language's abstractions and binary, and the more freedom for mapping between the two
08:53:36 <Philippa> dockside1: And humans want to understand which optimisations can be applied - so that is a relevant detail, it meets Perlis' notion of high-level
08:54:00 <bitonic> jmcarthur: of course the pointer to the buffer will be passed around.  but the fact that you are peeking into memory makes it so that you have to implement stuff like ‘drop’ ‘manually’, where with ‘manually’ I mean that you are updating information about the memory, instead with working with constructors.  we are having a terminology argument :P
08:54:07 <dockside1> Actually, I don't care how the code is optimized, just that it is
08:54:34 <dockside1> Would be nice with a compiler that complained when i wrote code it had a hard time optimizing
08:54:35 <Rotaerk> and as a result, there's less power in the hands of the user of that high level language for controlling the binary generated
08:54:40 <Rc43> Hi, guys.
08:54:41 <dockside1> so i could improve the compiler
08:54:54 * esap wrote a function with type bind_matrix :: Stream (Stream a) -> (a -> Stream a -> Stream a -> Stream b) -> Stream b
08:54:57 <Philippa> dockside1: we improve the compiler in part by feeding it libraries that explain optimisations to it
08:55:08 <Rc43> class Monad m => MonadPlus (m : Type -> Type) where
08:55:15 <Rc43> mplus : m a -> m a -> m a
08:55:16 <Rc43> mzero : m a
08:55:21 <jmcarthur> bitonic: your claim was that you have to "reuse slices" manually with unpacked stuff, no?
08:55:33 <Philippa> Rotaerk: that freedom actually makes it easier, so long as the language knows how to talk about the lower-level [abstraction hierarchy sense] details when needed
08:55:38 <jmcarthur> bitonic: but really it's just the observing that requires any manual work
08:55:41 <hpc> does anyone here know how to add a handler for sigint on windows?
08:55:44 <bitonic> jmcarthur: yep, which amounts to updating offsets and stuff like that
08:55:51 <Rc43> Why not something about (Monad m, Monoid (m a)) => MonadPlus where <empty>?
08:56:13 <bitonic> I never said that ‘not copying’ the buffer of a BS required work
08:56:15 <Philippa> Rc43: because we want to allow MonadPlus to be a different monoid
08:56:39 * hackagebot fluent-logger-conduit 0.2.0.0 - Conduit interface for fluent-logger  http://hackage.haskell.org/package/fluent-logger-conduit-0.2.0.0 (NoriyukiOhkawa)
08:56:44 <Rotaerk> wouldn't that be a leaky abstraction?
08:56:52 <bitonic> jmcarthur: but making sure that the offsetts & co are well formed definitely require much more work than simply adding constructors
08:56:56 <Philonous> Is there a memset in base?
08:57:04 <Philippa> Rotaerk: What, because it has an implementation?
08:57:23 <Philippa> or because it re-exposes its own lower levels?
08:57:24 <Rotaerk> no because it exposes the lower level details
08:57:48 <Philippa> you got that the moment you got peek and poke in the IO monad
08:57:49 <jmcarthur> bitonic: the sharing doesn't have anything to do with how you observe it though, is all i'm saying. it would be slower, but if all you have was a purely functional primitive to observe the buffer at some index, the structure of the code still wouldn't change in order to accomodate the sharing
08:57:53 <hpc> oh nvm, UserInterrupt does it properly
08:58:22 <Philippa> nothing wrong with having a tower of abstractions and being allowed to start from the top instead of the bottom
08:58:34 <Philippa> "leaky" is when you can't *not* care
08:59:26 <Spockz> Heffalump: Yes, in fact the full definition includes constructors for the Arrow(&Co) class methods
08:59:29 <Spockz> Heffalump: as well as two others
09:00:24 <bitonic> jmcarthur: OK.  my comment was on the nature of working with ADTs and with ByteString.  the sharing you do with ByteStrings would be the same in C, with ADTs the sharing is always implicit
09:00:56 <jmcarthur> i don't understand the distinction you are drawing here
09:01:02 <jmcarthur> the sharing is the same in both cases
09:02:22 <jmcarthur> bitonic: in haskell, i can bump the offset like so:   tail (ByteString fptr offset len) = ByteString fptr (offset+1) (len-1)
09:02:23 <Philippa> possibly: with an ADT you don't have to keep any position info in relation to the source ADT's spine
09:02:34 <jmcarthur> bitonic: that is only lacking bounds checking and such
09:03:47 <mlpfim_> I can't understand an error I'm getting. It says "Lacks accompanying binding" on Line 13 of this code: http://pastebin.com/hYtZBeir
09:03:50 <mlpfim_> What more does it need?
09:03:53 <mauke> The paste hYtZBeir has been copied to http://hpaste.org/84875
09:05:51 <mlpfim_> Also, I know that pos should use Maybe. I will switch that later.
09:06:29 <bitonic> jmcarthur: all I’m saying is that with functional structures you can add constructors or pass parts around with sharing for free.  the fact that in ByteString you can update the offset while keeping the same buffer is all well and good but much more clumsy, but people often see this kind of devices (pointers to things that get passed around) as necessary to share data
09:06:46 <jmcarthur> bitonic: more clumsy than what?
09:06:58 <jmcarthur> bitonic: how would you do it in C?
09:07:03 <bitonic> jmcarthur: more clumsy than inductively building things up or taking parts of the inductive structure
09:07:06 <jmcarthur> slice, that is
09:07:09 <jmcarthur> oh
09:07:28 <bitonic> jmcarthur: exactly the same as in ByteString, which is precisely my point—it doesn’t buy you much compared to C
09:07:35 <Philippa> bitonic: AIUI, you want slice as a (safer/nestable) (near-)primitive?
09:07:37 <jmcarthur> i don't see how working with a buffer is any different from working with an Int
09:08:02 <Philippa> I don't see how an Int is the appropriate point of comparison
09:08:05 <bitonic> jmcarthur: oh Int sucks in the same way
09:08:13 <bitonic> it’s a primitive (non inductive) type
09:08:46 <bitonic> Philippa: well I prefer to express things with ADTs—that’s all I’m saying :)
09:09:02 <bitonic> but those kind of libraries are necessary eh
09:09:07 <jmcarthur> at least i understand the objections now, although i can't say i necessarily agree that ADTs are always nicer
09:09:36 <jmcarthur> i just think of primitives as having hidden implementations, as with many normal haskell libraries
09:09:58 <bitonic> jmcarthur: I didn’t say that ADTs are always nicer, I wanted to highlight the difference.  I’m very happy we have bytestring/vector :)
09:09:59 <jmcarthur> it may be nice to have an ADT representation for them, at least if it could be done without a performance cost, sure
09:10:16 <Philippa> jmcarthur: oh for proper views, eh?
09:10:20 <jmcarthur> yeah
09:10:20 <Philippa> (from the left?)
09:10:45 <bitonic> jmcarthur: what kind of view were you thinking of?
09:11:01 <jmcarthur> it also would be nice if there was a way to take an ADT and optimize it as a primitive in certain ways
09:11:15 <bitonic> well, you can have pragmas like in Agda
09:11:34 <jmcarthur> e.g. peano numerals could have an increasing lower bound as they are evaluated and pattern matching transparently checks the lower bound before evaluating any more, also allowing constructors to be GCed and such
09:11:47 <bitonic> with data types mapping to some other primitive types
09:11:48 <jmcarthur> i'm not sure how Agda does it internally
09:12:00 <jmcarthur> e.g. does it do the lower bound trick for naturals?
09:12:16 <jmcarthur> or is it just a machine int?
09:12:29 <bitonic> me neither.  it’s more about MAlonzo than Agda.  I’m not sure how they handle pattern matching—e.g. if they have ad-hoc rules for numbers or if it’s something more general
09:12:33 <jmcarthur> i would imagine all it does is turn it into a machine int and evaluate strictly
09:12:49 <bitonic> jmcarthur: the evaluation strategy doesn’t matter with Agda
09:12:53 <jmcarthur> i'm talking about a way to preserve laziness and still get some benefits
09:13:00 <jmcarthur> it matters if i don't want to evaluate the whole thing:P
09:13:14 <jmcarthur> e.g.   length xs < 100
09:13:25 <bitonic> jmcarthur: well then you can use CoNat :)
09:13:28 <jmcarthur> right
09:13:33 <jmcarthur> which doesn't benefit from the optimization
09:13:41 <bitonic> and that might be optimised differently (I’m not sure it does currently)
09:13:42 <jmcarthur> but my lower bound trick would work for that in theory
09:14:43 <bitonic> jmcarthur: I think a lot of CoNat uses can be optimised away anyway, like the length you cited
09:14:46 <Betal>  :D
09:14:52 <Philippa> should do in practice: if you ever try to put the glb on omega, you have bigger problems
09:15:01 <jmcarthur> bitonic: you mean by fusion?
09:15:41 <bitonic> jmcarthur: yes
09:15:45 <jmcarthur> sure
09:15:52 <jmcarthur> but then you can't reuse the result! :(
09:16:09 <ludamad> Does anyone know a good tutorial on using Database.MongoDB ?
09:16:11 <jmcarthur> let n = length xs in (n < 10, n < 100, n < 1000)
09:16:21 <ludamad> I can't wrap my head around the right way to reuse connections
09:16:39 <bitonic> jmcarthur: yep it breaks down there, ‘a lot’ is not ‘always’ :)
09:17:22 <bitonic> I guess your ‘partially lazy’ CoNat could work
09:17:29 <jmcarthur> it's precisely this kind of scenario when we tend to fall back to machine primitives and sacrifice laziness or manually optimize everything
09:17:31 <jmcarthur> yeah
09:17:41 <jmcarthur> well, it's not partially lazy, it's completely lazy!
09:18:01 <jmcarthur> err... "completely lazy" has a specific meaning that i don't intend to imply
09:18:12 <bitonic> jmcarthur: don’t worry I see what you mean
09:18:21 <bitonic> it’s just the right amount of computation :P
09:18:25 <jmcarthur> right
09:18:39 * bitonic goes to make coffee
09:21:54 <Philippa> jmcarthur: yeah, that's the sort of thing I meant talking to Rotaerk earlier - it's important to be able to build abstractions on top of those things such that they don't leak
09:54:54 <neutrality> Lol, my ISP disabled the wifi portion of the router they installed and want me to pay an extra monthly fee to have them turn it on.
09:55:34 <neutrality> They won't give me the password to the thing either -- so no wireless haskell in my crib.
09:56:36 <Botje> neutrality: I have the reverse problem
09:56:50 <Botje> they enabled wireless without my authorization
09:58:20 <neutrality> ha ha ha
09:58:29 <simpson> neutrality: Is it also the modem?
09:58:35 * Kinnison wonders how one allows one's ISP control over the AP/router
09:58:42 <simpson> neutrality: Try searching online; many ISPs have backdoor passwords.
09:58:44 <neutrality> simpson: yes
09:58:59 <u_> my old router randomly broke our normal phone service
09:59:33 <latermuse> where do you guys live to have such an awful ISP?
10:00:37 <Clint> #haskell-blah
10:00:57 <Philippa> Kinnison: bundling. Especially mandatory
10:01:00 <Philippa> (and -blah)
10:13:00 <neutrality> simpson: good call
10:25:26 <Spockz> Heffalump: I updated my question a bit with my ultimate goal. Do you have any ideas on how to achieve it?
10:25:29 <Spockz> *them
10:31:44 * hackagebot highlight-versions 0.1.3.1 - Highlight package versions which differ from the latest  version on Hackage  http://hackage.haskell.org/package/highlight-versions-0.1.3.1 (BrentYorgey)
10:37:30 <latermuse> ghci keeps giving me a Segmentation fault: 11 error. what does the 11 stand for?
10:39:02 <sipa> latermuse: it's the number of the signal (SIGSEGV)
10:39:36 <geekosaur> what are you doing that causes the segfault? what platform?
10:44:25 <Radish> I've been trying to run a .hs that uses a cabal installed package in ghci
10:45:00 <Radish> the internet says i can use ghci -package foobar
10:45:18 <Radish> but how would i run my .hs with that setting?
10:45:33 <Radish> ghci foo.hs -package bar?
10:45:37 <Radish> or what?
10:45:55 <monochrom> yes
10:46:16 <monochrom> but I don't see why omitting "-package bar" matters
10:47:26 <Radish> it says it can't find the module
10:47:41 <Radish> http://stackoverflow.com/questions/3102164/how-do-i-get-ghci-to-see-packages-i-installed-from-cabal
10:47:50 <Radish> that's someone else's question there
10:48:06 <geekosaur> ghci should see it, unless you have multiple matching packages or something misconfigured
10:48:21 <Radish> how do i back out of ghci and go back into the command prompt?
10:48:35 <monochrom> ok, but someone else's question has someone else's setup and context, and probably his/her setup is broken in the first place.
10:49:08 <Radish> I used cabal install
10:49:08 <monochrom> :quit
10:49:24 <Radish> it builds but it throws an error when you use main
10:50:33 <monochrom> ok, what you're describing is completely abnormal. there is no "general rule of thumb incantation" for this.
10:51:28 <Radish> hmm
10:51:43 <Radish> well either way it can't find my .dll
10:52:00 <Radish> how do i point it in the direction of my .dll?
10:52:23 <Radish> is there like a --command for that?
10:52:27 <monochrom> cabal install already points it to the dll
10:52:43 <Radish> so this is very abnormal then?
10:52:47 <monochrom> yes
10:53:10 <Radish> well ****
10:53:20 <monochrom> also, if the problem is "can't find dll", I would say "can't find <filename here>", not "can't find module"
10:53:34 <Radish> it depends on how i try to run it lol
10:53:41 <monochrom> s/I would/it would/
10:54:15 <Radish> so should i try to use cabal install again?
10:54:22 <monochrom> ok, I'm just using what you said, you said "can't find the module", your own words
10:54:27 <monochrom> (should I trust you?)
10:54:41 <Radish> no that was a different test.hs
10:54:49 <Radish> i don't know if i can recreate that bug
10:55:06 <Radish> when i use cabal install x does it put x in the location i'm in?
10:55:20 <Radish> and if so do i need to be in that location to include x?
10:55:30 <monochrom> no and no
10:55:44 <Radish> should i --reinstall?
10:55:54 <Radish> probably won't change anything then, eh?
10:55:57 <monochrom> I don't know. insufficient information.
10:56:06 <Radish> could it hurt?
10:56:18 <monochrom> I still don't know.
10:56:20 <Radish> and how can i help you help me lol
10:57:39 <Radish> Loading package portaudio-0.2.3 ... <interactive>: portaudio: The specified modu le could not be found. can't load .so/.DLL for: portaudio.dll (addDLL: could not load DLL)
10:58:09 <Radish> thats when i just run the test.hs which compiles just fine, but then i use "main"
10:58:20 <monochrom> is portaudio even meant for windows?
10:58:27 <Radish> i hear ghci can't use libraries that easily - that's why i expected to reroute this way
10:58:40 <Radish> i used minGW and MSys to install it on windows
10:58:43 <bss03> Radish: Sounds like an error coming from the module itself.
10:59:14 <Radish> portaudio for windows yes, but it's not haskell by default, it's C
10:59:25 <bss03> Radish: Is portaudio.dll in the current directory? Or wherever the winnt dynamical linker expects to find it?
10:59:27 <Radish> portaudio isn't windows by default either but it works
10:59:48 <Radish> bss03: no its somewhere else, shouldn't cabal know where it is?
11:00:13 <Botje> Radish: cabal has nothing to do with this, this is the windows runtime looking for that .dll.
11:00:35 <Radish> bss03: i asked if that was what i needed to do,i see.
11:00:40 <bss03> Radish: Cabal yes, but that information could be lost / wrong when the application is used.
11:00:40 <Radish> oops
11:00:44 <Radish> i see*
11:01:25 <Radish> okay so i used this method: http://stackoverflow.com/questions/3102164/how-do-i-get-ghci-to-see-packages-i-installed-from-cabal
11:01:37 <Radish> but it still can't find the .dll
11:01:55 <Botje> because it's not cabal looking for it. it's the windows runtime.
11:01:56 <Radish> i don't need to do that but i need the .dll either way?
11:02:07 <bss03> Yeah... I don't think your problem is the same as theirs.
11:02:23 <monochrom> I am sorry I said "cabal install already points it to the dll". the statement is true for dll's produced by ghc, not for C dll's. but you didn't say it was C dll
11:02:23 <Botje> windows looks in 1) the current directory 2) something something something 3) a couple of directories under C:\windows
11:02:38 <Radish> monochrom: ok that makes sense
11:02:48 <Radish> botje: how do i add a directory?
11:03:07 <Botje> hell if i know.
11:03:13 <Radish> botje: okay.
11:03:16 <bss03> ghci is finding the haskell module fine, but during load it encounters an error because it can't find the portaudio.dll (C library).
11:03:17 <Botje> easier to just stick it in the current directory or C:\windows\system
11:03:34 <Radish> i'd really like to use folders if possible lol
11:03:46 <Radish> let's just get it working then
11:04:11 <Radish> alright i'll be back in a few minutes when i dig up the .dll then!
11:04:15 <Radish> thank you all so very much.
11:04:25 <Botje> you can probably set an environment variable for that, but get it working first
11:04:38 <bss03> Radish: Thank you for visiting #haskell.  Come back soon, ya hear?
11:04:55 <Radish> bss03: i come by all the time lol
11:05:02 <monochrom> ghci -lportaudio. may be insufficient
11:05:22 <Radish> bss03: i'm here pretty much every time i try to code lol
11:05:32 <Radish> monochrom: should i try it?
11:05:44 <Radish> monochrom: i still need the dll either way, right?
11:05:46 <monochrom> ghci -Ldirectory -lportaudio . may or may not work
11:07:15 <monochrom> basically http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-invocation.html#id486751 "2.6.2 Extra libraries"
11:08:39 <Radish> monochrom: i'll check that out
11:08:48 <Radish> anyone familiar with minGW and MSys?
11:09:33 <Radish> i used it to build the .dll but i don't know where it would've put the damn thing
11:10:38 <shachaf> Perhaps there should be a #haskell-windows channel.
11:11:31 <monochrom> I don't think it matters. it will not increase the number of people who know how to troubleshoot windows
11:11:43 <Radish> shachaf: it would be like two dudes lol
11:11:45 <Botje> Radish: where did you point cabal to when compiling the portaudio package?
11:12:00 <Botje> i vaguely recall a .libs directory somewhere.
11:12:09 <Radish> botje: nowhere but what's cabal got to do with the C based .dll?
11:12:26 <shachaf> Or maybe a #haskell-lol channel, where all the "lol"s can go.
11:12:48 <Radish> botje: oh that's right!
11:13:05 <Radish> i vaguely remember that too i found it but there's no portaudio.dll in there
11:13:11 <Radish> just a libportaudio.dll
11:13:18 <Radish> and some other stuff
11:13:35 <monochrom> interesting. perhaps make a copy and call it portaudio.dll
11:13:46 <Radish> shachaf: you're never gonna let me live that down are you?
11:13:59 <Botje> (or you could have downloaded a pre-built ubuntu VM and had this stuff running last week)
11:13:59 <Radish> monochrom: why not?  sure.  1 sec.
11:14:31 <Radish> botje: nah man.  windows is *sooooo* well designed
11:14:49 <Radish> botje: :D
11:15:08 <monochrom> I just hate the "C:" business
11:15:12 <Radish> botje: to be quite frank, I'm not sure I won't have this running next week instead lol
11:15:29 <Radish> monochrom: you're computer is just happy to see you monochrom.
11:15:44 <Radish> monochrom: and D: is sad because no one ever loves him.
11:15:57 <monochrom> haha
11:17:26 <Radish> i have libportaudio-2.dll, libportaudio.dll.a, and libportaudio.dll.def
11:17:39 <Radish> i'm thinking rename -2?
11:18:09 <monochrom> I don't really know. but don't rename. make copies and give them names.
11:18:18 <Radish> right that's what i meant
11:18:58 <Radish> dude your a genius.
11:19:33 <Radish> botje: and botje, you nailed that .libs business thank you
11:35:58 <Radish> i wanna thank you guys as well! you really helped me out early on.
11:36:03 <Radish> bss03: ^
11:36:15 <Radish> geekosaur: ^
11:36:27 <Radish> hopefully that's everyone i owe thanks to lol :)
11:39:16 <bss03> Radish: :)
11:41:57 <hpaste> m_hyperbolic pasted “Program” at http://hpaste.org/84882
11:43:48 <m_hyperbolic> Hey, I've writte a small program, and would be very happy if any of you guys could take a lot at it, and tell me if I made any glearing mistakes, or really bad code ect. Anything would be helpful :)
11:49:37 <quchen> m_hyperbolic: hpaste automatically runs HLint over all pastes.
11:49:49 <m_hyperbolic> HLit ?
11:49:51 <quchen> Look at the bottom of your paste for some auto-improvements :-)
11:50:09 <quchen> HLint is a program that scans Haskell source files and suggests improvements
11:50:29 <quchen> For example "\(x,y) -> x == y" is better written "uncurry (==)"
11:51:43 <bitonic> quchen: I’m not sure that’s an improvement, or ‘don’t believe everything that HLint says’ :P
11:51:55 <quchen> Basically before you want to release code it's a good idea to let HLint run over it, followed by compilation with -Wall
11:51:59 <bitonic> or ‘use the code you and the people around you understand better’
11:52:15 <m_hyperbolic> Yes I saw those. That is pretty cool :). But there might be some "coded correctly, but really stupid" code in there, and maybe someone could catch those.. But I'll fix the HLint things :)
11:52:21 <m_hyperbolic> what does -Wall do ?
11:52:24 <skyflash> Any attoparsec experts here?  I need to parse blocks from a file with a variable sized last field, which I need to read until the beginning of the next block.  Consequently I need to parse up to a matching introducer for the next block but _not_ consume this.  Having difficulty with this.
11:52:42 <bitonic> m_hyperbolic: turns all the warnings on
11:52:49 <quchen> m_hyperbolic: -Wall switches on all compiler warnings. It'll tell you things like redundant imports and bindings that are never used.
11:53:02 <shachaf> quchen: There are much more important warnings that -Wall turns on.
11:53:26 <quchen> Maybe. And?
11:53:29 <bitonic> unused/shadowing variables, missing type signatures
11:53:36 <shachaf> I.e. ones that catch actual bugs.
11:53:38 <m_hyperbolic> Ah ok. But right now HLint say "Use fewer imports" but that can be difficult if you actually have to use the things you import ?
11:53:57 <shachaf> m_hyperbolic: Click on the error for more information.
11:54:24 <m_hyperbolic> Oh yes. Thanks!
11:54:25 <quchen> You're importing a module and then the same module qualified again
11:54:31 <shachaf> quchen: That's not qualified.
11:54:48 <quchen> Then I remembered it wrong. Didn't look at the source again.
11:54:54 <quchen> There's some double import with an "as" in there.
11:54:59 <shachaf> Yes.
11:55:02 <Sonarpulse> is there a recursive replicate?
11:55:15 <quchen> Sonarpulse: iterate?
11:55:25 <Sonarpulse> I'll check
11:55:31 <Sonarpulse> no luck on hoogle but haven't seen that
11:55:32 <quchen> (Not sure what a recursive replicate would be)
11:55:41 <shachaf> m_hyperbolic: Instead of foldr (+) you should probably use foldl' (+) (or just "sum").
11:55:46 <quchen> > iterate (*2) 1
11:55:48 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
11:56:09 <Sonarpulse> I mean something more like
11:56:25 <Sonarpulse> Int -> (b -> b) -> b
11:56:41 <shachaf> Which behaves how?
11:56:47 <m_hyperbolic> shachaf: is foldl' the tailrecursive fold?
11:57:07 <shachaf> m_hyperbolic: foldl' is tail-recursive, which is related to the reason that you should use it.
11:57:28 <quchen> m_hyperbolic: It's a strict left fold. The accumulator won't build up a thunk a la "1+1+1+1+1+1" as an intermediate result.
11:57:29 <shachaf> foldr is a good fold, though. You should spend some time at one point understanding when to use which one.
11:57:32 <Sonarpulse> Int -> (b -> b) -> b -> b
11:57:39 <Sonarpulse> update a value n times
11:57:46 <Sonarpulse> maybe that is iterate
11:57:50 <Sonarpulse> but types don't match
11:57:51 <monochrom> both foldl and foldl' are tail recursive. but that alone doesn't help you. foldl' is also eager. the combination helps you.
11:57:52 <shachaf> Sonarpulse: When you ask a question like that it helps to give an example. :-)
11:58:01 <quchen> Sonarpulse: an example would be helpful. Right now what you're saying sounds like "take n . iterate f"
11:58:07 <monochrom> see my http://www.vex.net/~trebla/haskell/lazy.xhtml
11:58:09 <shachaf> quchen is probably right.
11:58:22 <shachaf> But I think learning to ask good questions is valuable so I'm not going to guess.
11:58:25 <shachaf> (Hmm, too late.)
11:58:27 <Sonarpulse> ok sure an example
11:58:44 <Sonarpulse> I am reding strings from a bytestring
11:58:47 <Sonarpulse> null terminated
11:58:54 <Sonarpulse> I need to put them in a hash table
11:58:59 <Sonarpulse> before I just had a list of strings
11:59:04 <m_hyperbolic> monochrom: thanks for link :)
11:59:12 <Sonarpulse> I could do a map and then fromAssotiationList
11:59:15 <shachaf> This example sounds way too complicated for the simple function that you were asking for. :-) But OK.
11:59:34 <blithe> Has anyone else experienced missing / broken packages after a fresh Haskell Platform install on OS X? https://gist.github.com/blakesmith/5234714
11:59:41 <Sonarpulse> and maybe the compile would deforest the initial list
11:59:43 <blithe> Missing quickcheck and what looks like a bunch of stuff. :-(
12:00:15 <m_hyperbolic> Btw, why is head better then !! 0 ?
12:00:16 <Sonarpulse> but I rather just recursively insert the new string n times
12:00:22 <monochrom> it is a mystery to me that it is a mystery to many programmers how to illustrate their specifications at the right level of details and omissions.
12:00:25 <hpc> blithe: seems to be a problem with your path?
12:00:26 <Sonarpulse> I have replicateM now
12:00:59 <blithe> hpc: Hrm, it might be. I've never configured a path.
12:01:04 <monochrom> but you could have easily said "myfunc f 0 x = x, myfunc f 3 x = f (f (f x)), etc"
12:01:12 <Sonarpulse> now my Int (a -> a) -> a -> a would actually work
12:01:23 <hpc> blithe: i don't use osx so i am not sure what to look for or how to fix it
12:01:24 <Sonarpulse> since this is within the monad
12:01:30 <Sonarpulse> get takes no arguments
12:01:40 <Sonarpulse> b -> b would just be something like
12:02:13 <quchen> Sonarpulse: A *minimal* example would be more helpful.
12:02:26 <Sonarpulse> well that is the actual problem
12:02:33 <quchen> (No ByteString, no hashes, one line)
12:02:47 <Sonarpulse> oh sure
12:03:09 <Sonarpulse> you mean abitrary use of my recurr-n-times?
12:03:15 <quchen> "Hey, I'm looking for a function that applies f to a value n times and puts the intermediate results in a list"
12:03:18 <blithe> hpc: I can import modules like Data.Char, but that seems like it's probably stdlib.
12:03:22 <quchen> "Oh, you're looking for take n . iterate f"
12:03:29 <hpc> hmm
12:03:34 <Sonarpulse> well right now I have the list
12:03:42 <hpc> that's in base, which is included with ghc
12:03:43 <Sonarpulse> but I DON'T want the intermediate list
12:03:51 <blithe> What ENV variables should I look at?
12:03:52 <Sonarpulse> I'll just write what I ant
12:03:56 <Sonarpulse> and then link it
12:04:12 <Sonarpulse> and you guys can tell me if I an do it short with std lib
12:06:02 <quchen> Tell us what you have and what you want to get out of it.
12:06:08 <quchen> Using words.
12:06:11 <geekosaur> blithe, what's in ~/.cabal/config?
12:06:16 <monochrom> recurr-n-times f 0 x = x
12:06:33 <monochrom> recurr-n-times f n x = f (recurr-n-times f (n-1) x)
12:06:54 <monochrom> this is not valid haskell, but close
12:07:00 <hpaste> “Anonymous Coward” pasted “Cabal config” at http://hpaste.org/84885
12:07:02 <hpaste> Sonarpulse pasted “updateNTimes” at http://hpaste.org/84886
12:07:06 <blithe> geekosaur: http://hpaste.org/84885
12:07:19 <quchen> recurr-n-times f n x = iterate f x !! n
12:07:54 <Sonarpulse> is that a lightning fast response to my paste?
12:08:07 <geekosaur> you can have something like this happen if you've installed the official HP package (which uses ~/Library/Haskell) and then later remove it and install from macports or homebrew (which both expect a Linux-like configuration). although actually I'd expect both the latter to install packages in the global db which is built into ghc... unless you still have the older HP installed and you have conflicting ghc and ghc-pkg now, or something
12:08:27 <quchen> Now here's how one would word the question: "I want to apply a function n times something"
12:08:45 <blithe> geekosaur: I did mess around with the homebrew packages before switching to haskell platform..
12:08:58 <geekosaur> you apparently still have them installed
12:09:20 <blithe> blake@Blake-Smiths-MacBook-Pro:~/haskell » brew uninstall haskell-platform
12:09:21 <blithe> Error: No such keg: /usr/local/Cellar/haskell-platform
12:09:22 <geekosaur> if you're using the platform installer, remove all of the homebrew haskell packages
12:09:40 <Sonarpulse> sorry, that is a million times clearer
12:09:56 <geekosaur> you still have a config file somewhere pointing at it, though
12:10:11 <geekosaur> because it's checking for all those packages in homebrew's paths
12:10:26 <blithe> geekosaur: Gotcha, should I try removing ~/.cabal/config ?
12:10:32 <geekosaur> won;t help in this case, no
12:10:36 <geekosaur> it's ghc's config
12:10:39 * blithe hrms
12:10:52 <geekosaur> also, hm. what does "type ghc-pkg" return?
12:11:06 <blithe> blake@Blake-Smiths-MacBook-Pro:~/haskell » type ghc-pkg
12:11:06 <blithe> ghc-pkg is /usr/local/bin/ghc-pkg
12:11:19 <geekosaur> ok, that's from homebrew
12:11:31 <geekosaur> you may have removed haskell-platform but you still have homebrew's ghc
12:11:47 <blithe> Fwah, that's silly. ;-)
12:11:54 <geekosaur> HP installer installs under /Library/Haskell and puts symlinks in /usr/bin (not /usr/local/bin)
12:12:12 <blithe> Gotcha.
12:12:20 <blithe> Let me try doing some cleanup.
12:12:29 <blithe> Not sure why the homebrew package doesn't clean up after itself.
12:12:39 <Sonarpulse> let me see how this jives with the Binary mond
12:12:46 <Sonarpulse> and then I'll link the whole file
12:12:54 <Sonarpulse> or ask another question
12:14:06 <Sonarpulse> the other simple way of looking at my problem is if M.replicate creates a list
12:14:14 <Sonarpulse> what I want creates a Map
12:14:25 <Sonarpulse> but otherwise exactly the same
12:14:55 <blithe> geekosaur: Removed all the homebrew binaries, that fixed it!
12:15:05 <blithe> Thanks so much for the help, I really appreciate it.
12:15:20 <m_hyperbolic> can someone explain to me what it mean for a binding to shadow an existing binding (from a package) ?
12:15:40 <monochrom> I think I know now. because we're talking about programmers brainwashed to be imperative. they cannot state specifications, they can only state implementation steps. they can only say, "*do* this update, *do* this read, *do this write", they cannot say "the answer *is* ___"
12:16:27 <geekosaur> m_hyperbolic, you named something the same as some name you imported from a package. for a simple example: if you use "let map = 5 in ..." somewhere in your program, you are shadowing the "map" imported from the Prelude
12:17:05 <geekosaur> you could still get at the Prelude's version as Prelude.map, but you can also get surprises if you forget to qualify it while your local binding is in scope
12:17:24 <m_hyperbolic> geekosaur: Aah ok. I this a problem if I don't use what I'm shadowing, or it is more a 'Good practice' question ?
12:18:30 <geekosaur> good practice, per what I just said. it's a good way to confuse yourself later when the code has been sitting for 6 months and you've forgotten you did that
12:19:00 <m_hyperbolic> I see. Thnaks for the answer!
12:19:19 <monochrom> I recommend striving for unique names
12:20:11 <monochrom> humans are extremely fallible when it comes to name clashes
12:21:19 <m_hyperbolic> unqiue names meaning something like "meanVector" instead of "a" ?
12:21:21 <Sonarpulse> Ok, this is _exactly_ what I want Monad m => Int -> m (k, v) -> m (Map k v)
12:21:34 <Sonarpulse> yeah updateNTimes is not helping to much
12:21:44 <monochrom> not necessarily meaningful names :)
12:22:14 <Sonarpulse> because all the lifts and klegilsi are making it verbose again
12:22:17 <quchen> m_hyperbolic: Unique in the sense "when someone reads a Prelude name, nobody thinks it could be something else"
12:22:40 <m_hyperbolic> Yeah ok, Makes sende
12:22:45 <m_hyperbolic> sense*
12:23:20 <quchen> For similar reasons, using "+" should always be addition conceptually
12:23:41 <quchen> The types may be matrices or whatever, but you shouldn't make something with a suggestive name that does something different
12:23:53 <quchen> Like overloading << as ostream composition in C++ ;-)
12:24:07 <BMeph_> Sonarpulse: I object to your use of "_exactly_" - what should your function do when your first argument is -2? ;)
12:25:22 <quchen> Sonarpulse: that's a type.
12:25:42 * quchen backs out of that question now.
12:25:50 <Sonarpulse> hmm?
12:26:13 <Sonarpulse> well the same flaw is in replicate in prelude
12:26:27 <monochrom> try_this 0 _ = return empty
12:26:47 * hackagebot quickcheck-io 0.1.0 - Use HUnit assertions as QuickCheck properties  http://hackage.haskell.org/package/quickcheck-io-0.1.0 (SimonHengel)
12:26:49 * hackagebot hspec 1.5.1 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.5.1 (SimonHengel)
12:26:51 * hackagebot literals 1.0 - Non-overloaded functions for concrete literals.  http://hackage.haskell.org/package/literals-1.0 (JulianFleischer)
12:27:01 <Sonarpulse> ok my updateNTimes did not handle that
12:27:17 <Sonarpulse> but that doesn't mean "Monad m => Int -> m (k, v) -> m (Map k v)" is wrong
12:27:21 <monochrom> try_this n prog = do { (k,v) <- prog; m <- try_this (n-1) prog; return (insert k v m) }
12:27:43 <Sonarpulse> sure, and thanks
12:27:45 <monochrom> it may use a lot of memory
12:27:57 <Sonarpulse> well I am going to profile this after
12:28:09 <Sonarpulse> I started to with it working but all in lists
12:28:24 <Sonarpulse> this specific instance was ok in that I was merging two sorted lists
12:28:38 <Sonarpulse> but later I had these nasty O(n^2) list merges
12:28:45 <Sonarpulse> so I am doing it right with hash tables
12:28:49 <Sonarpulse> *maps
12:28:55 <Sonarpulse> seeing that I do insert and remove
12:29:28 <Sonarpulse> so after I cut the LOC in half with maps, I'm going to profile it
12:29:43 <Sonarpulse> and so don't worry about memory usage right now
12:31:36 * BMeph_ wishes subtratcion issues were not such an impediment to the idea of using a Natural type for things that are conceptually of that type. :/
12:31:47 * hackagebot hspec-meta 1.5.1 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.5.1 (SimonHengel)
12:32:00 <Sonarpulse> BMaph_ isn't there some bounded type?
12:32:13 <Sonarpulse> I agree, but since that haskell98 doesn't do subtypes
12:32:27 <Sonarpulse> I can see why they did it as is
12:33:37 <Sonarpulse> *BMeph
12:33:58 <BMeph_> Sonarpulse: There are many bounded types, including Int. Sometimes, though, Int is used for a function which should "really" be using another type, but chose Int to be more "efficient" and to get a product "out the door," so-to-speak.
12:34:46 <Sonarpulse> Yeah, the efficiency, and extra toIntegerS
12:34:53 <BMeph_> I don't think any forms of Haskell do subtypes. I don't think many forms of ML do subtypes, although many seem to claim they do. ;)
12:35:08 <Sonarpulse> the OHaskell?
12:35:31 <parcs> > let i = 0 :+ i in (-1)**(-i)
12:35:33 <lambdabot>   Occurs check: cannot construct the infinite type:
12:35:33 <lambdabot>    a0 = Data.Complex.Comp...
12:35:33 <Sonarpulse> I am interest in how scala does Algebraic Data Types with "sealed" classes
12:35:36 <parcs> > let i = 0 :+ 1 in (-1)**(-i)
12:35:37 <lambdabot>   4.321391826377226e-2 :+ 0.0
12:35:46 <BMeph_> Sonarpulse: Color me "OHorrified"... ;)
12:35:50 <parcs> > exp 1 ^ pi
12:35:51 <lambdabot>   Ambiguous type variable `b0' in the constraints:
12:35:52 <lambdabot>    (GHC.Float.Floating b0)...
12:36:11 <Sonarpulse> Also, I beleive you could acceive the same thing if you ONLY used abstract datatypes
12:36:39 <Sonarpulse> and dispatch with typeclasses
12:36:55 <Sonarpulse> I am suprise there isn't more abstract data type stuff
12:37:15 <Sonarpulse> as far as I can tell abstract datatypes and typeclasses work very well together
12:37:17 <monochrom> there are also several kinds of subtypes
12:37:43 <cmccann> BMeph_: pf, "exists a. a" and "forall a. a" are totally legit top and bottom types in Haskell.
12:37:48 <cmccann> that's a valid sort of subtyping.
12:37:48 <Sonarpulse> also, can a GADT present a "virtual" constructor for pattern matching?
12:37:52 <Philippa> Sonarpulse: yep. Qualified types are a nice way to bound polymorphism
12:38:12 <Philippa> and no, they don't. You'd have to write a function to whatever type held that constructor instead
12:38:30 <Sonarpulse> I think that would make them easier to use
12:38:44 <Eduard_Munteanu> Virtual? :O
12:38:44 <Philippa> views would be nice for a lot of things
12:38:50 <Sonarpulse> though it does border on getters and setter territory
12:39:03 <Sonarpulse> views and lenses, yes I need to try those out
12:39:09 <Philippa> otherwise you're dipping into the sort of gadgetry you see in dependently-typed languages: we'd love to have it, but it's lots of complication to how the language itself works
12:39:35 <cmccann> and we all know how much Haskell avoids complicated things
12:39:48 <Sonarpulse> haha
12:40:14 * BMeph_ laughs out loud at cmccann's remark...then looks around embarrassedly to see who looked
12:40:20 <Philippa> cmccann: at the language level? Well, it used to try
12:40:22 <liyang> Dear Interwebs: Functor is to Monad as Contravariant is to ???
12:40:26 <Sonarpulse> well I think you can avoid the dependant types where you don't need it without much to fancy
12:40:28 <Philippa> now it just avoids some kinds of complicated in favour of others
12:40:42 <cmccann> well, as far as the Haskell Report goes things are pretty simple
12:41:36 <Philippa> Sonarpulse: you're still hoping to get type refinement from potentially-arbitrary pattern-matching, no? You might not be dealing with dependent types, but you *are* thinking more seriously about proofs than Haskell was intended to
12:42:01 <BMeph_> Are refinement types a subset of dependent types, or can they just be used in similar ways?
12:42:19 <Sonarpulse> hmm, first time somebody told me I was more serious than haskell
12:42:26 <Sonarpulse> I'll take it as a compliment :D
12:42:37 <Philippa> BMeph_: the latter. They're also a confusing thing to bring into the picture because they're not what I meant by type refinement :p
12:43:01 <Sonarpulse> instance Real a => Natural a where...
12:43:04 <Philippa> (to be fair: they do involve a lot of punning that may as well be emulated by dependent types)
12:43:30 <Philippa> that might not be a good idea, mathematically speaking?
12:44:01 <Sonarpulse> I am not sure, please enlighten me?
12:45:45 <elliott> not a particularly good idea instance resolution speaking, either :P
12:47:09 <BMeph_> Philippa: Pardon me, then - what did you mean by type refinement? :)
12:47:21 <Sonarpulse> well with the instance resolution, you can do "pick higher" thing
12:47:59 <Sonarpulse> though I am not betting that works in all cases
12:48:29 <Sonarpulse> In general I think i resounded out while types + typeclasses seem flat
12:48:35 <Sonarpulse> they imply a full DAG
12:49:27 <Sonarpulse> then with stuff like that you can save some extrac instance deriving at the expense of of making the DAG more rigid
12:51:22 <Sonarpulse> also is there a natural number type defined on the platform with bounded?
12:51:39 <Sonarpulse> the number I use here comes from an unsigned integer
12:51:42 <Sonarpulse> so it would work
12:51:49 <monochrom> there is not.
12:52:18 <Sonarpulse> typeclass would be good
12:52:33 <Sonarpulse> but no bounded typeclass
12:52:48 <cmccann> I still think Real is the worst type class name in the standard library
12:53:10 <cmccann> since all it has is toRational
12:53:13 <cmccann> that's just
12:53:15 <cmccann> what
12:53:31 <quchen> I don't think standard classes can be ordered in terms of sillyness
12:53:56 <davean> quchen: I'll agree there isn't a total order.
12:53:58 <Sonarpulse> well if you want a common interface for bignums used for precision and floats
12:54:34 <monochrom> http://3.bp.blogspot.com/-NwzsX7x56mM/UCLeWmikFVI/AAAAAAAAEsE/YCbPmfTl2kE/s1600/be-rational-get-real.png
12:55:01 <cmccann> I would rather that the type classes that exist primarily for converting between numeric types had names that matched the conversions
12:55:31 <cmccann> "IsString" is much more sensible
12:55:50 <Philippa> BMeph_: type refinement is the thing that's interesting about pattern matching on GADTs
12:56:17 <Sonarpulse> that makes the most sense assume all your functions are NOT generic
12:56:26 <Sonarpulse> (cmccann) I think
12:59:03 <Sonarpulse> Also I wonder of the language could differetiate between those conversions that are injective and those that aren't
12:59:22 <BMeph_> Philippa: Had to think on that a bit; nice summary, though! :)
12:59:35 <Sonarpulse> toRational, why not toInteger too?
12:59:54 <Sonarpulse> mathematically they are both not injective
13:00:15 <cmccann> Sonarpulse: that's in the Integral class
13:00:28 <BMeph_> Sonarpulse: "toInteger" is part of the Integral t-class.
13:00:45 * BMeph_ cyber high-fives cmccann!
13:00:46 <Sonarpulse> well then if Real goes to Rational
13:00:49 <cmccann> and then Num and Rational give the "from" conversions
13:00:54 <cmccann> er
13:00:55 <cmccann> Fractional
13:01:21 <Sonarpulse> didn't you say Real just had toRational?
13:01:30 <cmccann> yes
13:01:51 <cmccann> :t (toRational, fromRational, toInteger, fromInteger)
13:01:52 <lambdabot> (Fractional a1, Integral a2, Num a3, Real a) => (a -> Rational, Rational -> a1, a2 -> Integer, Integer -> a3)
13:02:05 <Sonarpulse> does Real also implement Rational?
13:02:22 <cmccann> Rational is a type, Fractional is the type class with fromRational
13:02:41 <Sonarpulse> oh ok
13:02:42 <cmccann> and no, Real only requires Num and Ord for... unknown reasons
13:03:12 <cmccann> Integral requires Real, which actually makes sense
13:03:19 <cmccann> just like Fractional requires Num
13:04:26 <Sonarpulse> is rational -> real just fromIntegral then?
13:04:55 <Philippa> to jump back to one of Sonarpulse's earlier questions: what's the best machinery we have on hackage for reifying and applying coercions?
13:04:56 <cmccann> if there were conversions for natural number types, toNatural's class would require Integral and Num would require fromNatural's class
13:04:59 <Sonarpulse> oh so framS are safe and toS are unsafe
13:05:14 <cmccann> not necessarily
13:05:14 <Philippa> (for System FCish values of coercion - ~ constraints, if you prefer)
13:05:28 <cmccann> some instances don't actually handle the conversions they claim to though
13:06:05 <cmccann> if you can convert something to Integer, you can also convert it to Rational, which is why Integral requires Real
13:06:19 <cmccann> contravariance yo
13:06:56 <Sonarpulse> ok
13:06:56 <elliott> Philippa: lens has some of that :p
13:07:15 <cmccann> forall x. lens has some of x
13:07:24 <Sonarpulse> Philippa, never looked at System FC, very intersting
13:09:01 <Philippa> Sonarpulse: funny thing about FC - it's what was once a holy grail for, say, disgruntled C++ers? Then when you know enough about dependently-typed programming, it's a bit "eh"
13:09:02 <Sonarpulse> Integral requires Real, vs Real implements Integral
13:09:08 <skyflash> Hmm, doesn't look like it's easy to build look-ahead/non-consuming parsers in attoparsec.
13:09:30 <Philippa> skyflash: IIRC attoparsec is designed for LL(1) cases? (but I could be wrong)
13:09:49 <Philippa> parsec makes it doable, there are other libraries where you don't have to specify where lookahead happens
13:10:09 <Philippa> (FC is *still* a good intermediate language for the job it's meant for!)
13:11:16 <skyflash> Philippa: tnx.  Maybe I'll go back to parsec then.  Tried attoparsec on a whim, as it's supposed to be fast and I haven't used it before.
13:12:59 <Sonarpulse> Philippa: speaking disgruntled C++ers, have you heard of http://claylabs.com/clay/
13:13:19 <Philippa> yeah
13:13:28 <Philippa> haven't looked at it in detail though
13:13:39 <Philippa> (I've not got as much time for PLT stuff as I once had)
13:13:56 <Sonarpulse> I just hope it doesn't burn out like Bit C
13:14:06 <Sonarpulse> that's fine
13:14:56 <Philippa> BitC had... problems, including some subtle dead ends in the design, yeah
13:16:07 <Sonarpulse> then there's rust
13:16:41 <Sonarpulse> which I guess avoid the problems in a somewhat hodge podge manner
13:16:43 <Philippa> *nod*. Got a friend on the dev team there
13:17:03 <Sonarpulse> Cool!
13:19:02 <Sonarpulse> I have to reconcile it's "optional vtables" with theory of existential qualification than then I'll feel better
13:24:22 <Sonarpulse> see yall
13:42:21 <tomejaguar> Is it possible to have multi-level guards?
13:42:34 <tomejaguar> Something like "f x y | x == 1 | y == 2 = 3"?
13:42:41 <quchen> tomejaguar: Use &&?
13:42:52 <quchen> f x y | x == 1 && y == 2 = 3
13:43:01 <tomejaguar> Sure, but what if I want x == 1 to scope over many y guards?
13:43:11 <tomejaguar> | x == 1 | y == 2 = ...
13:43:16 <tomejaguar>          | y ==3 = ...b
13:43:25 <tomejaguar> | x == 2 | y == k = ...
13:43:46 <quchen> I see and don't know.
13:43:49 <quchen> Did you try it out?
13:44:31 <quchen> I mean it won't work like this
13:44:32 <Hafydd> x == 1 && (y == 2 || y == 3)
13:44:47 <Hafydd> Oh, never mind.
13:45:10 <Hafydd> There is a GHC extension which might be useful, I think.
13:45:10 <tomejaguar> I did try it out and got an error
13:45:13 <quchen> Hafydd: The most important thing here is that if no guard matches the whole thing goes on to the next guard
13:45:18 <tomejaguar> Seems like a natural thing to want
13:45:23 <quchen> Eh, not guard, but definition
13:45:33 <quchen> Otherwise you could just use a 'case'
13:46:14 <quchen> tomejaguar: You may have to spell it out explcitly.
13:46:33 <quchen> But you can of course use a 'where' binding to unify common expressions manually.
13:47:41 <hpaste> quchen pasted “multiguard” at http://hpaste.org/84890
13:47:49 <mm_freak> tomejaguar: in general you need nested pattern matches for that, but if you really need that either you do in fact have a complicated business logic or your approach may be too naive
13:47:51 <quchen> Not as pretty as your suggestion
13:48:03 <mm_freak> in any case there is the MultiWayIf extension
13:48:24 <mm_freak> if | guard, guard -> … | guard, guard -> … | …
13:49:34 <luite> :r
13:49:45 <mm_freak> tomejaguar: my general advice is:  try to find a type that encodes your logic as closely as possible
13:49:53 <mm_freak> then you don't need all those guards
13:54:41 <tomejaguar> Fair enough
13:54:42 <tomejaguar> Thanks
13:56:38 <ludamad> How can I work with an algebraic data type that has a bunch of record constructors ?
13:56:47 <ludamad> I figured out how to define/ return it, but how can I pattern match it ?
13:57:41 <geekosaur> foo MyRecord {} = ... -- ?
13:57:59 <quchen> ludamad: Two ways. Let's say Data Foo = { Bar :: A, Baz :: B }
13:58:14 <quchen> ludamad: Two ways. Let's say Data Foo = Foo { Bar :: A, Baz :: B }
13:58:15 <quchen> ^ pardon
13:58:30 <geekosaur> bar and baz should be lowercase
13:58:32 <mm_freak> quchen: still wrong =)
13:58:51 <quchen> mm_freak: but now it's isomorphic to the real thing ;-)
13:59:00 <ludamad> data Message = LoginMessage { username :: T.Text, password :: T.Text }
13:59:00 <ludamad>             | CreateUserMessage { username :: T.Text, password :: T.Text }
13:59:02 <quchen> Now you can use "f (Foo x y)" directly, where x/y match the first/second record
13:59:02 <ab9rf> ludamad: lenses :)
13:59:03 <ludamad> lets say i have that
13:59:09 <mm_freak> quchen: it isn't anything, it's a syntax error ;)
13:59:26 <ludamad> ok
13:59:32 <quchen> mm_freak: This is IRC, IRC doesn't compile my stuff.
13:59:46 <quchen> I'm afraid my IRC linter is broken.
14:00:09 <mm_freak> ludamad: there are many ways
14:00:19 <mm_freak> 1. f (LoginMessage u p) = …
14:00:36 <mm_freak> 2. f (LoginMessage { username = u, password = p }) = …
14:00:43 <ludamad> mm_freak, cool
14:00:59 <mm_freak> the advantage of 2. is that you don't have to mention all fields
14:01:08 <mm_freak> you can keep your records extensible that way
14:01:56 <ion> f LoginMessage{ username = u, password = p } = …  -- look, mom, no parens!
14:02:10 <mm_freak> ludamad: if the constructor doesn't matter you can use a pattern guard:
14:02:17 <ion> f LoginMessage{..} = something username something password
14:02:26 <mm_freak> f msg | u <- username msg, p <- password msg = …
14:02:33 <mm_freak> that's 3.
14:02:35 <cmccann> record syntax binds tighter than like everything else
14:02:38 <cmccann> including function application
14:02:49 <mm_freak> ion: i know, but still prefer the parentheses there
14:04:25 <mm_freak> ion: also i think your second syntax requires the wildcards extension
14:04:45 <mm_freak> and it's problematic, too…  you shadow the field functions
14:35:10 <kdridi> hi
14:36:03 <luite> hello
14:36:51 <kdridi> where can i find a simple example that return an array of string in C that is build in haskell. I find many examples that call c language from Haskell but it's difficult to find example of haskell calls from C (that returns char**)
14:40:09 <cmccann> kdridi: maybe look at how FFI bindings pass string arguments to C functions?
14:40:36 <cmccann> then just make sure you know who's in charge of freeing the memory
14:40:40 <sw2wolf> How to specify the different GHC version for cabal ?
14:40:49 <kdridi> cmccann: good idea but where ? in the source code ?
14:40:57 <facepalm> hello I am new to Haskell and I am trying to write a function that will take a list a parameter and return every other number -- basically the equivalent of doing [1,3..20] what is the best approach to this?
14:41:10 <cmccann> kdridi: find an FFI binding library and look at its source code, yeah
14:41:14 <ParahSail1n> bytestring package has a bunch of relevant source code
14:41:19 <cmccann> use "cabal unpack" to get the code
14:41:25 <kdridi> cmccann: thx ;-)
14:41:48 <quchen> facepalm: Use pattern matching. Think of what the function should do if you give it an empty list, a list with one element, and a list with many elements.
14:42:31 <ParahSail1n> @ty filter even [1..]
14:42:32 <lambdabot> Integral a => [a]
14:42:49 <quchen> everyOther [] should be []. everyOther [x] should be [x]. What should everyOther [x,y] be? What about everyOther (x:y:xs)?
14:43:04 <facepalm> I did this http://pastebin.com/THXvMfrG
14:43:09 <mauke> The paste THXvMfrG has been copied to http://hpaste.org/84892
14:43:59 <quchen> facepalm: [x,y] matches only a list with two elements. If you want to match any list, use (x:y:xs). x will be element #0, y will be #1, xs the rest.
14:44:47 <facepalm> so then will I be able to type everyOther[3..25] and have it match from that?
14:44:50 <quchen> Second, [n+2..m] doesn't know about your original list. It'll generate a list from n+2 to m, regardless of how your oringal list looked like.
14:45:43 <quchen> Think about what "everyOther (x:y:xs)" should be.
14:45:59 <quchen> The result should be a list of course. What's the first element of that list?
14:46:29 <facepalm> first is x
14:46:51 <sipa> and after that?
14:46:51 <quchen> Right, so your resulting list should start with x. So we've got "everyOther (x:y:xs) = x : something" now.
14:46:58 * hackagebot discrete-space-map 0.0.1 - A discrete space map.  http://hackage.haskell.org/package/discrete-space-map-0.0.1 (SjoerdVisscher)
14:47:01 <quchen> Where should y, the list's second element go?
14:47:12 <facepalm> y+2
14:47:37 <quchen> That would increase y by two. You don't want to add things. You want to pick every other element.
14:47:57 <quchen> Picking every other element can also mean dropping every other element, hint hint :-)
14:48:05 <facepalm> y = x +2
14:48:25 <sipa> quchen: i think facepalm assumes he's restricted to an input of consecutive numbers
14:48:37 <sipa> facepalm: and x:y:... are the input; not the output
14:48:42 <facepalm> I just started to learn this today so I dont know a lot about it yet
14:48:55 <quchen> Have you read the LYAH chapter on pattern matching?
14:49:47 <quchen> @where lyah
14:49:47 <lambdabot> http://www.learnyouahaskell.com/
14:50:02 <quchen> It's a very nice introduction to the basics of Haskell.
14:50:20 <quchen> Pattern matching is chapter 4, but I would recommend reading the chapters before as well.
14:51:25 <Taneb> The OpenGL library could use some better documentation...
14:51:46 <ParahSail1n> @let everyOther q = case q of {(x0:x1:xs) -> x0 : everyOther xs; _ -> []}
14:51:49 <lambdabot>  Defined.
14:56:18 <facepalm> I will read this thank you.
15:00:44 <quchen> There's a better solution based on a similar concept.
15:02:52 <liyang> Ack. Head not working anymore. What do you call the property where a function with a polymorphic type cannot possibly depend on values of said type?
15:03:10 <monochrom> parametericity
15:03:16 <liyang> Thank you!
15:03:19 <monochrom> or parametricity
15:03:19 <liyang> monochrom++
15:03:44 <liyang> Good god I should get some sleep in before the talk. :<
15:03:50 <quchen> Parametricity?
15:04:06 <quchen> Oh I misread the question, nevermind
15:04:07 <liyang> Parametricity. Repeat after me...
15:04:22 <monochrom> in retrospect, it's strange
15:04:53 <quchen> In retrospect I don't get the question :s
15:04:54 <monochrom> parametricity is when "f x" does not depend on... x the parameter!
15:05:14 <quchen> When f x doesn't depend on x that's called constant ;-)
15:05:55 <genisage> @run flip id 5 succ
15:05:56 <lambdabot>   6
15:06:21 <liyang> Ack. Now I've forgotten why I wanted to mention parametricity.
15:07:22 <monochrom> quchen: the question means: an example is when f :: a->a, then f x = x or ⊥, there is no other choice, in particular there is no "if x::Int, return x+1 instead"
15:07:55 <liyang> Functor is parametric in its argument yes?
15:08:19 <quchen> Hm. Well a polymorphic type can't really have values can it
15:08:23 <liyang> (I mean, is that what one would say...)
15:09:06 <genisage> It wouldn't be possible to have f :: a -> b, would it?
15:09:12 <quchen> No.
15:09:18 <quchen> Yes, it's not possible, that is.
15:09:28 <liyang> I guess I really mean type constructors where the arguments have no extra constraints.
15:10:01 <Ruud> Hello, I am trying to install packages using cabal on Windows, using the default Haskell Platform 2012.4.0.0, and packages keep getting installed to C:\Program Files (x86)\Haskell, which is not the directory I want. Where can I change it?
15:10:07 <quchen> genisage: There are functions in GHC that let you do that, but they're very usafe (and probably also called "unsafe*").
15:10:46 <Breadmonster> Guys?
15:10:52 <Breadmonster> I just started Haskell yesterday.
15:11:01 <Breadmonster> Can someone tell me how to do merge sort?
15:11:04 <quchen> Brilliant decision :-)
15:11:07 <Breadmonster> http://pastebin.com/DS602Jcb
15:11:09 <mauke> The paste DS602Jcb has been copied to http://hpaste.org/84893
15:11:11 <Breadmonster> That's what I go.
15:11:33 <monochrom> liyang: do you mean like "Maybe is parametric in its type parameter"? then I would say yes
15:11:54 <liyang> monochrom: yes.
15:11:57 <Breadmonster> quchen: is my code idiomatic enough?
15:12:02 <quchen> Breadmonster: merge looks alright, mergesort needs some improvement.
15:12:11 <liyang> monochrom: exactly that.
15:12:18 <monochrom> although, I don't actually have parametricity defined at the type level or functor level
15:12:28 <Breadmonster> quchen: I don't like the hack with the lists.
15:12:37 <Breadmonster> But I can't think of any other way to partition them.
15:12:43 <mm_freak> quchen: a polymorphic type can have all values, which means:  you can observe no values
15:12:47 <quchen> Breadmonster: mergesort is supposed to split an element in two halfs. There's a better way to do this. The easiest version is using split from Data.List.
15:12:54 <luite> Breadmonster: splitAt
15:13:04 <liyang> monochrom: oh, type families...
15:13:07 <quchen> Oh, splitAt it's called, right
15:13:12 <Breadmonster> quchen luite: Sorry, was doing Learn You a Haskell.
15:13:21 <Breadmonster> they haven't reached that part, I'm just doing chapter 5.
15:13:24 <quchen> mm_freak: Oh so I got the term wrong in my head then.
15:13:28 <monochrom> ha, type families is how to break it, yes :)
15:13:31 <liyang> monochrom: so I should say parametric rather than 'sans constraints'.
15:13:35 <Breadmonster> It's pretty easy to work with, I think I'm born for FP.
15:13:45 <ParahSail1n> @src sort
15:13:45 <lambdabot> sort = sortBy compare
15:14:02 <quchen> Breadmonster: So brute force "divide in half" could be done using drop/take.
15:14:05 <Breadmonster> @src sortBy
15:14:05 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
15:14:21 <quchen> Calculate the length of the list; first half = take (half length), second half = drop (half length)
15:14:27 <Spockz> Breadmonster: hold on to that thought
15:14:28 <Breadmonster> quchen: Oh, okay, yeah, that's way better. Imperative sorta messes with your head.
15:14:28 <ParahSail1n> @src insertBy
15:14:29 <lambdabot> insertBy _   x [] = [x]
15:14:29 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
15:14:29 <lambdabot>                                  GT -> y : insertBy cmp x ys'
15:14:29 <lambdabot>                                  _  -> x : ys
15:14:47 <quchen> Breadmonster: The idea I just mentioned is basically what splitAt does.
15:14:52 <quchen> > splitAt 3 [1..10]
15:14:54 <lambdabot>   ([1,2,3],[4,5,6,7,8,9,10])
15:14:59 <monochrom> http://hpaste.org/83483
15:17:11 <quchen> Breadmonster: I annotated your code so it's clearer to read. What's left for you is to fill in the GAPS.
15:17:34 <hpaste> quchen annotated “Merge sort” with “Merge sort (annotation)” at http://hpaste.org/84893#a84895
15:17:52 <Breadmonster> quchenL done.
15:18:12 <quchen> Click on "annotate" and paste it :-)
15:19:19 <quchen> Oh I messed up the annotation and added it to the wrong code. Anyway, the last paste in the link above is what I mean.
15:19:23 <hpaste> “Anonymous Coward” annotated “Merge sort” with “Merge sort (annotation) (annotation)” at http://hpaste.org/84893#a84896
15:19:31 <Breadmonster> quchen: http://hpaste.org/84893
15:19:35 <Breadmonster> Thanks a lot :)
15:20:12 <Breadmonster> I better go to bed; it's nearly half past one in the morning here.
15:20:15 <Breadmonster> Night.
15:20:17 <quchen> Breadmonster: That won't compile. The "drop (left half)" I used above was just pseudocode
15:20:29 <quchen> Alright, good night then
15:20:41 <Breadmonster> quchen: Look up, I defined half.
15:20:41 <quchen> PS: Look at slowsort if you wanna have a nice laugh ;-)
15:20:41 <Breadmonster> :)
15:21:35 <quchen> It still wouldn't work
15:21:36 <hpaste> “Anonymous Coward” revised “Merge sort (annotation) (annotation)”: “Merge sort (annotation) (annotation)” at http://hpaste.org/84896
15:21:47 <Breadmonster> quchen: http://hpaste.org/84896
15:21:53 <quchen> Still some parentheses missing.
15:22:03 <Breadmonster> Alright.
15:22:05 <quchen> Right now you're mergesorting "take" and "drop", which is a type error.
15:22:11 <Breadmonster> Oh, okay.
15:22:21 <quchen> But modulo parentheses this is a solution.
15:22:24 <Breadmonster> Fine.
15:22:29 <Breadmonster> I got how to do it.
15:22:30 <Breadmonster> Thank you :)
15:22:48 <quchen> You're welcome
15:31:59 * hackagebot ref 0.1.1.1 - Generic Mutable Ref Abstraction Layer  http://hackage.haskell.org/package/ref-0.1.1.1 (CarterSchonwald)
16:05:35 <beaky> hello
16:05:39 <beaky> how do I invoke a C function from haskell?
16:06:16 <Taneb> @where FFI
16:06:16 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/haskellch8.html
16:06:20 <beaky> ah thanks
16:06:29 <Taneb> Good luck
16:13:08 <connelly> do you guys have any tips for generating minimal executable size from haskell code (on windows)?
16:13:30 <connelly> I tried -dynamic and it broke, and I don't want to have to lug around DLLs
16:13:33 <Taneb> connelly, any particular reason why you need that?
16:14:12 <connelly> Taneb: ease of distribution, curiosity
16:14:23 <Taneb> Official GHC documentation is http://www.haskell.org/ghc/docs/latest/html/users_guide/smaller.html
16:14:30 <Taneb> Although it is very stubby
16:14:39 <beaky> if functors are good for modeling boxes, and monoids are excellent for modeling other stuff... what are monads good at modeling?
16:14:53 <Taneb> Analogies and tutorials
16:14:54 <ludamad> connelly: theres always UPX
16:15:23 <Taneb> beaky, it will probably be a good idea to stop thinging about it like that
16:15:27 <beaky> ah
16:15:33 <connelly> was wondering if you could use a smaller runtime if you didn't want to lug around the profiling stuff for example
16:15:34 <sw2wolf> Anybody here used xmonad-extras successfully ?
16:15:39 <jmcarthur> yup
16:15:43 <Taneb> Identity is good for modelling a box
16:15:47 <Taneb> It's a Functor
16:15:49 <Taneb> It's also a Monad
16:15:51 <Taneb> And a Comonad
16:16:15 <Taneb> The archetypal monoid is probably [a]
16:16:24 <edwardk> it slices, it dices, it juliennes fries.. into precisely the fry you started with
16:16:42 <Taneb> (although for reasons I prefer Sum a)
16:16:56 <quchen> I'm trying to think of things identity is not
16:17:32 <sw2wolf> :t liftIO
16:17:33 <lambdabot> MonadIO m => IO a -> m a
16:17:34 <quchen> I guess it's polymorphic in typeclasses ;-)
16:17:42 <Taneb> quchen, it's not a MonadPlus
16:17:53 <Taneb> Or an Alternative
16:18:18 <jmcarthur> data Thing a = Thing  is also a Functor, but not a very useful box
16:19:14 <Taneb> newtype What r a = What ((a -> r) -> r) is somehow a Functor
16:19:32 <jmcarthur> that's the Cont monad
16:19:34 <Taneb> Although you have to squint when you first see it
16:19:44 <Taneb> and your thing is the Proxy functor
16:19:56 <elliott> Proxy is a monad too
16:19:57 <Taneb> Most of these functors have names
16:20:03 <jmcarthur> sorry i misinterpreted your "somehow" as genuine mystification
16:20:25 <Taneb> jmcarthur, merely the remnants thereof
16:20:53 <jmcarthur> it's easy to spot the functor in What by recognizing that the 'a' variable is in a positive position
16:21:28 <Taneb> Only once you've got the hang of control passing style
16:21:46 <jmcarthur> i mean this can be done mechanically without having to come up with some definition for fmap
16:22:35 <Taneb> @djinn (a -> b) -> ((a -> r) -> r) -> (b -> r) -> r
16:22:35 <lambdabot> f a b c = b (\ d -> c (a d))
16:22:36 <jmcarthur> (-(-a -> +r) -> +r)
16:22:39 <liyang> Could someone check over https://www.fpcomplete.com/user/liyang/profunctors and /msg me any comments? Going to take a nap now.
16:23:45 <jmcarthur> lol @ the quote
16:25:14 <sw2wolf> @hoogle xmonad-extras
16:25:15 <lambdabot> package xmonad-extras
16:25:29 <sw2wolf> @where xmonad-extras
16:25:29 <lambdabot> I know nothing about xmonad-extras.
16:25:36 <jmcarthur> @hackage xmonad-extras
16:25:37 <lambdabot> http://hackage.haskell.org/package/xmonad-extras
16:25:59 <beaky> yes I compiled my first C ffi program :D
16:26:05 <jmcarthur> yay!
16:26:12 <jmcarthur> i find the FFI oddly satisfying
16:26:18 <beaky> why is ffi useful?
16:26:35 <jmcarthur> err... why did you use it if you have no need for it?
16:26:50 <jmcarthur> it's useful so that you can use C libraries from Haskell or Haskell libraries from C
16:26:53 <beaky> ah
16:50:49 <twomashi> I'm a bit confused about lenses… Whats a good place to start to compose a lens with control.monad.state.modify ?
16:51:18 <edwardk> twomashi: you can use %= directly rather than modify
16:51:25 <edwardk> l += 10   -- works directly in state
16:51:36 <edwardk> l %= f   -- applies the function to the target of the lens in state
16:51:43 <edwardk> l .= 10  -- sets
16:51:48 <edwardk> use l  -- reads
16:52:35 <edwardk> equivalently: modify (l +~ 10); modify (l %~ f); modify (l .~ 10); gets (view l)
16:52:43 <edwardk> shows how they relate to the basic lens operations
16:55:04 <Taneb> lens is a big ball of ridiculous
16:55:23 <Cale> Taneb: What are you referring to?
16:55:24 <edwardk> ?
16:55:43 <Taneb> (when I say ridiculous, it's generally a compliment)
16:55:46 <edwardk> =)
16:56:15 <Cale> Personally, I think the %= operator and its variants are the ones you really need to pay attention to and the others are a bit questionable :)
16:56:40 <Taneb> Is there a list of GHC extensions lens doesn't use
16:56:44 <Taneb> QuasiQuotes
16:56:49 <Taneb> Um...
16:57:14 <Botje_> WhicheverExtensionEnablesMdo ?
16:57:30 <Cale> Well, the basic components of lens are mostly Haskell 98
16:57:50 <sw2wolf> :t (<%=>)
16:57:52 <lambdabot>     Not in scope: `<%=>'
16:57:52 <crdueck> whats the name of the functor data F = F a?
16:57:52 <lambdabot>     Perhaps you meant `<%=' (imported from Control.Lens)
16:58:04 <twomashi> edwardk: thanks; missed the docs on github somehow. they're clearer than most of the lens introductory material about
16:58:10 <sw2wolf> :t (<%=)
16:58:13 <lambdabot> (MonadState s m, Profunctor p) => Overloading p (->) ((,) b) s s a b -> p a b -> m b
16:58:26 <Cale> crdueck: You mean  data F a = F a ?
16:58:30 <Taneb> Haskell 98 + Rank2Types and you've got 80% of lens
16:58:47 <Cale> crdueck: Or maybe you meant  data F a = F ?
16:59:36 <crdueck> Cale: no I guess it would be data F = forall a. F a, but then thats not a functor, nevermind. I know data F a = F is Proxy
17:01:29 <Taneb> data F = forall a. F a is probably Void
17:02:39 <Cale> Well, ()
17:02:48 <arkeet> no, Void
17:02:58 <arkeet> ?
17:03:01 <Cale> no
17:03:05 <Cale> It's not Void
17:03:09 <Cale> It has a non-bottom value
17:03:21 <otters> which is what
17:03:24 <Cale> Any two of its non-bottom values are indistinguishable though
17:03:25 <Taneb> F undefined
17:03:44 <Cale> Oh, weird, actually, seq can tell them apart, slightly
17:03:54 <Cale> F undefined is a little different from F () in that regard
17:03:57 <arkeet> it has a non-bottom value in the same way data X = X Void has a non-bottom value.
17:04:16 <Cale> F () is a non-bottom value of type F there
17:04:35 <Cale> (note the placement of the forall)
17:04:50 <arkeet> but I still wouldn't call that X ()
17:04:57 <Cale> also, F 7, but it's impossible to tell F 7 and F () apart
17:05:18 <arkeet> not only that
17:05:23 <arkeet> it's impossible to tell them apart from F undefined
17:05:26 <Cale> But it is possible to tell F undefined and F () apart
17:05:29 <arkeet> it is?
17:05:36 <arkeet> oh, with seq. :/
17:05:39 <Cale> right
17:05:55 <arkeet> and yet you still can't do anything with it.
17:06:05 <Cale> It's not a particularly *useful* type
17:06:15 <elliott> arkeet: huh? it's () not Void.
17:06:19 <elliott> it's (exists a. a)
17:06:19 <Cale> It's not even ()
17:06:23 <elliott> even without _|_
17:06:25 <Cale> It has three values
17:06:37 <Cale> undefined, F undefined, and F ()
17:06:40 <arkeet> elliott: fine.
17:06:58 <elliott> it's data F = F (), to be precise
17:06:58 <Cale> You can only tell the last two apart using seq
17:07:03 <elliott> I think that handles all the _|_s
17:07:05 <Cale> yeah
17:08:40 <otters> so Void only has _|_?
17:08:59 <beaky> @src Ord
17:09:00 <lambdabot> class  (Eq a) => Ord a  where
17:09:00 <lambdabot>     compare      :: a -> a -> Ordering
17:09:00 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
17:09:00 <lambdabot>     max, min         :: a -> a -> a
17:09:29 <beaky> for Ord do I just need to define compare?
17:09:36 <otters> isn't that what happens if you use EmptyDataDecls?
17:09:58 <quchen> beaky: <= or compare I think
17:10:19 <quchen> beaky: "Minimal complete definition: either compare or <=. Using compare can be more efficient for complex types. "
17:10:25 <quchen> See docs on Data.Ord
17:10:50 <beaky> ah
17:11:09 <beaky> I want to implement ord for a complex data type
17:11:23 <beaky> @src compare
17:11:23 <lambdabot> compare x y | x == y    = EQ
17:11:23 <lambdabot>             | x <= y    = LT
17:11:23 <lambdabot>             | otherwise = GT
17:11:29 <quchen> The reason to prefer compare to <= is if == is expensive
17:11:35 <beaky> ah
17:11:52 <quchen> compare basically unifies <, ==, > in one function
17:12:10 <quchen> On the other hand, to get < out of <=, you have to add a == comparison
17:12:52 <quchen> ... or something along these lines.
17:13:10 <edwardk> twomashi: there should be a session on lens in a few hours in japan, there'll at least be a google hangout, not sure how accessible the content will be though ;)
17:13:28 <beaky> how often do haskellers worry about efficiency stuff?
17:13:33 <edwardk> http://partake.in/events/1698f7f8-4151-4048-b317-03a8c3f1a7ab
17:13:44 <edwardk> beaky: i do fairly regularly. can't speak for the general population
17:13:45 <quchen> beaky: Each time the profiler says "nah"
17:13:50 <beaky> ah
17:14:01 <sw2wolf> beaky: often especially since lazy
17:14:10 <Cale> beaky: Often? But we tend to write things first and worry about performance after.
17:14:25 <edwardk> beaky: i tend to just implement compare unless i'm going nuts with features for an Ord instance.
17:14:34 <quchen> edwardk writes libraries, so performance is a big concern there. On the other hand, if you're writing a program to convert file formats, it doesn't matter much whether it takes 3 or 8 seconds.
17:14:37 <edwardk> cale does. i tend to get lost micro-optimizing ;)
17:14:53 <quchen> If you're running your program 10^12 times, you may want to profile though. ;-)
17:14:54 <ludamad> argh I wish I could find better examples of the mongodb haskell driver
17:15:07 <edwardk> github.com/analytics has been frozen more or less for 2 weeks while i benchmark and test various approaches
17:15:11 <ludamad> its really hard to learn mongodb stuff & understand how to use the API
17:16:19 * sw2wolf in fact i will want to improve GHC's linking speed. 
17:16:29 <edwardk> My usual rule of thumb is to first implement all the things, then go through and make as many of them as i can easily do so fast, and then rewrite everything if i find a faster way
17:17:02 <edwardk> I'm still on the 'implement all the things' phase. For some reason there are a lot of things out there.
17:17:07 <quchen> Linking is awfully slow on my RasPi! :-(
17:19:10 <sw2wolf> poor linking performance causes building haskell project not fun ...
17:20:49 <geekosaur> I thought the best thing you could do for linking performance was build ghc without split-objs, but the price is bigger executables?
17:21:41 <parcs> you have it backwards
17:22:22 <sw2wolf> geekosaur: split-objs needs rebuild GHC ?
17:23:14 <geekosaur> ghc can be built so that it automatically split-objs everything; if it's off you can pass -split-objs to turn it on for a particular compile
17:23:41 <geekosaur> I usppose whether lots of tiny objects vs. a few larger ones is faster to link depends on the linker (and linker version)
17:24:26 <geekosaur> there was certainly a time when split-objs caused gnu ld to choke but I think that was fixed some time ago
17:25:08 <sw2wolf> then the default GHC is using split-objs ?
17:25:48 <geekosaur> depends on the platform, I think
17:26:26 <sw2wolf> For special project, split-objs can be configured through *.cabal ?
17:27:07 <oio> list of lists comprehension ?
17:28:58 <piezoid> ld.gold should be faster than binutils's ld, but it seems it doesn't like ghc objects
17:29:29 <tom4939> Is there any consensus on HTF vs test-framework?
17:29:55 <tom4939> I like HTF's test discovery features, which test-framework seems to lack.
17:29:58 <sw2wolf> geekosaur: in ~/.cabal/config, split-objs is turned off default
17:30:01 <geekosaur> oio: what are you trying to ask?
17:31:07 <geekosaur> sw2wolf, in general, ghc has it enabled on platforms where it works, so specifying -split-objs would be unnecessary on those platforms; and on platforms where it doesn't work, obviously you don't want it enabled
17:31:20 <geekosaur> (which summarizes what I said earlier...)
17:31:24 <oio> > [ x | x <- ["aa","bb"], elem x ["bb","aa"]]
17:31:25 <lambdabot>   ["aa","bb"]
17:31:36 <oio> it works..
17:32:00 <sw2wolf> geekosaur: thx, maybe freebsd cannot use split-objs
17:32:58 <geekosaur> I do not know. might check the ghc port to see if it has a build.mk
17:33:59 <sw2wolf> no build.mk in /usr/ports/lang/ghc
17:43:00 <sw2wolf> $ghc --info | egrep 'split|Host'
17:43:00 <sw2wolf>  ,("Host platform","i386-unknown-freebsd")
17:43:00 <sw2wolf>  ,("Object splitting supported","YES")
17:48:41 <beaky> are finite state macines monads?
17:51:03 <sw2wolf> see if it implements >>=  and return ?
17:56:10 <cmccann> beaky: I'm not sure it makes sense to say that FSMs are monads in general, they're not the same kind of thing
17:56:23 <cmccann> some FSM implementations in Haskell might have a Monad instance though
17:56:34 <beaky> ah
17:56:59 <cmccann> seems like something that would lend itself to an operational monad style implementation
17:59:36 <pharaun> hows haskell on freebsd?
18:00:22 <pharaun> seems like it does have the haskell-platform so that's good
18:00:36 <sw2wolf> pharaun: i am using GHC-7.4.x and GHC-7.6.x on FB, all works great
18:00:50 <pharaun> sw2wolf: that's excellent to hear :)
18:01:08 <cmccann> beaky: more popular in Haskell are FSMs that accept a sequence of inputs and produce a sequence of outputs, i.e. a transducer
18:01:10 <`nand`> pharaun: x86/amd64 FreeBSD is a Tier 1 GHC platform
18:01:23 <beaky> :t transducer
18:01:25 <lambdabot> Not in scope: `transducer'
18:01:48 <`nand`> which means they get paid to make sure GHC always works on it when they release
18:02:38 <ab9rf> i need to stop parsing 'FSM' as 'flying spaghetti monster'
18:02:39 <cmccann> beaky: iteratee-style stream libraries and Arrow-style FRP are both based on things that are essentially finite state transducers
18:03:12 <cmccann> ab9rf: finite state machine is entirely too much typing but I admit the acronym collision amuses me
18:03:22 <pharaun> `nand`: that's good to hear :)
18:03:38 <cmccann> for extra fun try reading FSM as some mixture of the two acronyms
18:03:51 * cmccann wonders what a "finite state monster" would be
18:04:03 <cmccann> a flying spaghetti machine sounds awesome though
18:04:08 <sw2wolf> `nand`: glad to hear that
18:04:10 <ab9rf> cmccann: i'm sure i've run into those in children's stories
18:06:56 <`nand`> I don't know what a finite state monster is, but the canonical example of an infinite state monster is known as ‘lens’
18:08:11 <sw2wolf> i first hear of 'lens' is an infinite state monster !
18:08:52 <beaky> ah
18:12:07 <beaky> so a fsm is just a function that takes an event and returns a new fsm/
18:13:32 <cmccann> technically it's a mapping from a current state and input to a new state (with an output if it's a transducer)
18:14:27 <cmccann> with the transducer stuff in Haskell, the state is usually implicit
18:15:24 <sw2wolf> cmccann: transducer means Monad Transformer ?
18:15:31 <cmccann> no
18:15:50 <cmccann> a finite state transducer is a finite state machine that produces an output at each step, not just when it halts
18:15:52 * sw2wolf what's transducer in Haskell ?
18:16:18 <`nand`> newtype Transducer i o = i -> (o, Transducer i o) -- ?
18:16:27 <`nand`> ugh, been a while since I wrote Haskell
18:16:29 <`nand`> forgot the actual constructor
18:16:38 <cmccann> with explicit state, a finite state transducer would be a single function "(State, Input) -> (State, Output)"
18:17:00 <cmccann> with the state being implicit you get something like what `nand` wrote except with valid syntax
18:17:04 <cmccann> :P
18:18:04 <sw2wolf> :t evalStateT
18:18:05 <lambdabot> Monad m => StateT s m a -> s -> m a
18:18:08 <cmccann> though it can be either "Transducer (i -> (o, Transducer i o))" or "Transducer o (i -> Transducer i o)" depending on how you want to look at it
18:19:31 <newsham> > evalState (put 5) (1,2)
18:19:33 <lambdabot>   ()
18:19:39 <newsham> > runState (put 5) (1,2)
18:19:40 <lambdabot>   ((),(5,5))
18:19:51 <newsham> > runState (put 5) 1
18:19:52 <lambdabot>   ((),5)
18:20:17 <newsham> > runState get 1
18:20:19 <lambdabot>   (1,1)
18:20:43 <newsham> > runState (gets (+3)) 1
18:20:44 <lambdabot>   (4,1)
18:20:49 <beaky> ah
18:21:41 <newsham> ?let incr n = gets (+n) >>= put
18:21:43 <lambdabot>  Defined.
18:21:48 <newsham> > runState (incr 3) 1
18:21:51 <lambdabot>   ((),4)
18:22:23 <newsham> > runState (incr 3 >> gets (*2)) 1
18:22:25 <lambdabot>   (8,4)
18:23:16 <`nand`> gets (+n) >>= put   =   modify (+n)
18:23:29 <newsham> > runState (modify (+3)) 4
18:23:30 <lambdabot>   ((),7)
18:25:14 <newsham> > runState (do { x <- gets fst; modify (\(a,b) -> a+5); y <- gets snd; return (x+y+1) } (5,20)
18:25:16 <lambdabot>   <hint>:1:87: parse error on input `('
18:25:40 <newsham> > runState (do { x <- gets fst; modify (\(a,b) -> a+5); y <- gets snd; return (x+y+1) }) (5,20)
18:25:41 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = (t0, t0)
18:25:56 <newsham> > runState (do { x <- gets fst; modify (\(a,b) -> (a+5,b)); y <- gets snd; return (x+y+1) }) (5,20)
18:25:58 <lambdabot>   (26,(10,20))
18:27:16 <facepalm> http://pastebin.com/iYCQ5X3s I am working on my everyOther list again and this runs but it throws exception..also it is printing in sequential order I cant figure out how to "drop" every other element with out it crashing
18:27:23 <mauke> The paste iYCQ5X3s has been copied to http://hpaste.org/84900
18:27:53 <beaky> :t gets
18:27:55 <lambdabot> MonadState s m => (s -> a) -> m a
18:28:49 <newsham> get the state value, apply function to it
18:28:52 <newsham> ?src gets
18:28:52 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:29:50 <newsham> > runState (gets show) 5
18:29:51 <lambdabot>   ("5",5)
18:30:50 <cmccann> facepalm: your pattern matching is missing some possible patterns
18:31:17 <cmccann> also you're not actually doing anything, since you're including both x and y in the result list
18:31:28 <cmccann> you don't need that semicolon, not sure what that's supposed to be for
18:31:56 <cmccann> and why over-specialize the type signature? just "[a] -> [a]" would work.
18:32:41 <cmccann> facepalm: the non-exhaustive pattern is why it crashes, though. you need to add patterns for shorter lists.
18:35:12 <facepalm> hmmm okay. and how can I make it alternate so is not every number but everyother
18:35:45 <dmwit> > [1,3..]
18:35:46 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
18:36:01 <facepalm> this is my first day with Haskell
18:36:06 <cmccann> facepalm: by not including the items you don't want in the result list?
18:36:15 <dmwit> facepalm: Oh, I didn't see your paste. Apologies.
18:36:24 <facepalm> oh I dmwit I know how to do it if Im not doing it in a function
18:36:36 <dmwit> facepalm: Well, if you have a list starting with "x" and "y", I guess you only want "x" to be in the result.
18:36:40 <dmwit> facepalm: So this is probably your bug.
18:36:45 <cmccann> when you match (x:y:xs) and then the result is (x:y:whatever) then your result is going to include x and y
18:36:54 <cmccann> because that's how you defined the result
18:37:03 <facepalm> oh so drop y
18:37:33 <cmccann> facepalm: you're matching a list with at least two elements. creating a list that only includes one of those elements is your goal, right?
18:37:42 <cmccann> so pick one to keep and discard the other.
18:38:45 <oio> is there outersect?
18:38:51 <facepalm> my goal is to call the function like this everyOther[1..20] for example and have it start at 1 and give me every other number instead of in order like it normally would
18:40:34 <facepalm> dropping the y just did that for me but I still get the non-exhaustive pattern so I just have to figure that out now :)
18:41:41 <newsham> > (\(x:y:xs) -> (x:y:"more")) "hello"
18:41:43 <lambdabot>   "hemore"
18:41:47 <newsham> > (\(x:y:xs) -> (x:"more")) "hello"
18:41:48 <lambdabot>   "hmore"
18:41:49 <ab9rf> facepalm: what do you do when the list has less than two elements?
18:42:06 <newsham> > (\(x:y:xs) -> (x:"more")) "h"
18:42:08 <lambdabot>   "*Exception: <interactive>:3:2-24: Non-exhaustive patterns in lambda
18:42:36 <cmccann> oio: what is "outersect"? you mean the symmetric difference?
18:43:13 <ParahSail1n> is there a way to do guards on one line with {}s and semicolons?
18:43:44 <Cale> ParahSail1n: no braces or semicolons required
18:43:46 <beaky> git clone $(xclip -o)
18:43:48 <Cale> Just put another |
18:44:03 <beaky> oops worng window
18:44:04 <ParahSail1n> cale, ah thanks
18:44:17 <Cale> > let f x | x < 0 = -1 | x == 0 = 0 | x > 0 = 1 in map f [-5..5]
18:44:19 <lambdabot>   [-1,-1,-1,-1,-1,0,1,1,1,1,1]
18:44:31 <facepalm> ab9 im not sure to be honest, as I said I am just learning this today so I will do some more reading
18:44:52 <ab9rf> facepalm: that's my point.  you haven't told it wha tto do in that case.
18:45:25 <Cale> facepalm: It's worth noting that the pattern (x:y:xs) will only match a list with at least two elements in it
18:45:48 <Cale> (the first two elements matching with x and y, and the remainder of the list matching with xs)
18:45:56 <newsham> also (x:y:xs) means (x:(y:xs))
18:47:22 <newsham> > (\(x:y:ys) -> (x,y,ys)) "Testing 1 2 3"
18:47:24 <lambdabot>   ('T','e',"sting 1 2 3")
18:47:52 <Cale> facepalm: So your problem is simply that once the function recursively applies itself to a list with 0 or 1 elements, you're missing a definition of what the result should be in that case.
18:48:11 <newsham> > (\(x:y:ys) -> (x,y,ys)) ""
18:48:12 <lambdabot>   *Exception: <interactive>:3:2-22: Non-exhaustive patterns in lambda
18:48:14 <newsham> > (\(x:y:ys) -> (x,y,ys)) "x"
18:48:16 <lambdabot>   *Exception: <interactive>:3:2-22: Non-exhaustive patterns in lambda
18:48:18 <newsham> > (\(x:y:ys) -> (x,y,ys)) "xy"
18:48:20 <lambdabot>   ('x','y',"")
18:49:04 <facepalm> I think I understand what you are saying
18:54:09 <ludamad> I'm trying to think how I can efficiently relay a message in Haskell
18:54:16 <ludamad> I have a server with one connection / client
18:54:38 <ludamad> I want to relay the message to all clients, but they're on different threads
18:54:52 <newsham> forever (read h1 >> write h2) ?
18:55:09 <`nand`> ludamad: something like channels?
18:55:11 <newsham> read in on one channel write out to a channel per thread
18:55:32 <ludamad> `nand`: its like a chat server thing, if thats what you mean
18:55:41 <`nand`> there's probably a higher level abstraction you could use also
18:55:56 <ParahSail1n> @hoogle Chan
18:55:56 <lambdabot> Control.Concurrent.Chan data Chan a
18:55:56 <lambdabot> Control.Concurrent.Chan module Control.Concurrent.Chan
18:55:56 <lambdabot> package chan-split
18:55:58 <`nand`> ludamad: I mean like channels as in actual software
18:56:06 <`nand`> that came out badly
18:56:11 <`nand`> what ParahSail1n searched for
18:56:30 <`nand`> I wonder if cloud-haskell could do something like this
18:56:55 <mikeplus64> ludamad: you could just give each client a Chan Message (where Message is your message type)
18:57:43 <ludamad> ok
18:58:09 <ludamad> I'd need some global list of users, right ?
18:58:24 <mikeplus64> you should maybe keep track of all your clients, and then you could just in the main thread, to send all clients something, e.g. do forM_ clients (sendMessage someMessage)
18:58:45 <ParahSail1n> @hoogle TMVar
18:58:45 <lambdabot> Control.Concurrent.STM.TMVar module Control.Concurrent.STM.TMVar
18:58:46 <lambdabot> Control.Concurrent.STM.TMVar data TMVar a
18:58:46 <lambdabot> Control.Concurrent.MVar putMVar :: MVar a -> a -> IO ()
18:59:02 <ludamad> mikeplus64: ok, cool
18:59:21 <mikeplus64> or forM_ clients (forkIO . sendMessage someMessage) depending on whether sendMessage is expensive i guess
19:00:30 <ludamad> Whats a good representation of the client list ?
19:00:42 <ludamad> a set of some sort ?
19:02:13 <mikeplus64> dunno, depends on how you use it. if all you do is go through it linearly and you don't need to e.g. lookup things then you might get away with just IORef [Client]
19:02:58 <mikeplus64> @hoogle vector-buffer
19:02:58 <lambdabot> package vector-buffer
19:03:51 <mikeplus64> that package gives you "growing" vector buffers, ie it'll allocate in advance a vector for maybe 1000 clients, and "grow" up to that
19:04:33 <edwardk> That reminds me, I should bundle up the PMA stuff i'm working on as a hackage package.
19:04:55 <mikeplus64> edwardk: hm?
19:05:26 <edwardk> (growable vectors that support O(log n) repeated inserts to any place in them but use contiguous storage) O(log^2 n) insert time if you jump around.
19:06:46 <edwardk> I have a standard version and one that lets you do inserts/deletes/replacement at a bit level granularity, so long as you give me some epsilon worth of wasted space.
19:07:18 <mikeplus64> neat
19:07:27 <edwardk> The bounds are amortized but you can deamortize them either partially or totally
19:09:13 <connelly> how do I compile via LLVM on windows? I added -fllvm to the ghc command line and it didn't do anything different
19:09:45 <Axman6> do you have LLVM installed?
19:10:05 <connelly> nope, but it doesn't even give me a warning
19:10:24 <connelly> wasn't sure if it was packaged with the windows haskell environment or not
19:10:42 <connelly> I'm installing clang and LLVM now
19:11:04 <Axman6> -fllvm is just ignored if it can't find LLVM installed from memory
19:11:30 <connelly> how do you get it to just compile to llvm IR?
19:12:25 <Axman6> there are flags to pass arguments along to llvm. check the GHC man page
19:12:41 <Axman6> also, not entirely sure if LLVM is supported on windows with GHC
19:13:05 <connelly> -fvia-c certainly doesn't work on windows
19:13:38 <Axman6> i'm not sure it works anywhere anymore
19:14:02 <connelly> the native path is the preferred method these days?
19:14:18 <Axman6> it has been for quite some time
19:15:31 <connelly> I read old docs I guess
19:17:36 <oio> how to finish a haskell program?
19:19:23 <ab9rf> remove all the parts that aren't needed?
19:26:43 <BMeph_> oio: Take smaller bites until it's all gone? ;)
19:39:24 <kini> beginner question - from what I can see, any kind of file IO traps you in the IO monad and so it should be done at a high level in your program, right?
19:39:49 <oio> lol
19:39:53 <kini> but what if you want to implement, say, a dictionary lookup function, which looks up things from a file the disk (read only)?
19:39:59 <kini> *file on the disk
19:40:07 <edwardk> kini: fmap can call a 'pure' function inside IO. so while the top level of your function is in IO, etc. it can still call pure functions
19:40:28 <kini> I'm more wondering about how I could call such a dictionary lookup function from inside pure code
19:40:37 <kini> is there no way to wrap that up?
19:40:45 <oio> outersect unique from two lists
19:40:50 <connelly> I have a stupid-ish question.  Is it possible to cross compile haskel (e.g. generate windows PE files from a linux box)?
19:40:57 <edwardk> in that sense if its causing the disk to seek around its not really a pure function. What happens if someone moves the file?
19:41:20 <kini> hmm... :(
19:41:24 <edwardk> You can use things like bytestring-mmap to give you a 'pure' version of a file that is just mmap'ed into memory
19:41:36 <edwardk> but you have to be very careful about what you do to that file
19:41:47 <edwardk> if you can or will mutate its contents then what you want isn't safe
19:41:59 <kini> I guess not
19:42:44 <hpaste> oio pasted “Could someone try this in code chef” at http://hpaste.org/84902
19:51:30 <tomberek> is there a way to fully static compile a Haskell program. (GLUT, et. al. is being a pain)
19:53:31 <`nand`> tomberek: yeah, though I don't know off-hand how
19:53:51 <`nand`> GHC can statically link with some options
19:54:02 <tomberek> `nand`   I've tried the -static and -optl-static etc
19:54:35 <`nand`> tomberek: did you get errors, or did it produce a dynamic executable?
19:55:14 <tomberek> `nand` it is still dynamic
19:55:33 <tomberek> I tried this: http://www.haskell.org/haskellwiki/Web/Literature/Static_linking
19:55:40 <tomberek> and a few other things on Google
19:56:26 <`nand`> hang on, let me try and dig up a relevant log
19:57:59 <tomberek> i've been looking for a while, i tried most of the results I've found
19:58:10 <`nand`> ghc -static -optl-static -threaded HelloWorld.hs -- produces a static executable for me, maybe it's something particular to GLUT that's causing it to be dynamic?
19:58:50 <kini> `nand`: well, is HelloWorld.hs pure Haskell?
19:59:24 <tomberek> i think so
19:59:37 <`nand`> kini: yes, but it still links in stuff like libgmp and libffi this way
19:59:48 <kini> hmm
19:59:51 <tomberek> i tried freeglut as well
20:00:15 <tomberek> but then couldn't get it installed and i got lost inside the gcc toolchain tried to brute-force my way
20:01:02 <tomberek> i'm pretty sure GLUT is the problem
20:01:07 <lightquake> argh. why is hdevtools so inactive :(
20:02:50 <tomberek> btw: i'm on windows
20:11:07 <kini> edwardk: I guess it seems a bit odd to me that, say, if a data structure is small enough to fit into memory, then code that reads it is naturally expressed as pure code, but if the data structure is large enough, suddenly all the code for reading it needs to be completely different because now it's stored on disk and requires IO...
20:11:13 <kini> is that really how it is in haskell world?
20:12:21 <Philippa> kini: putting pure stuff in IO is easy. The 'issue' is when you realise you have to talk about IO - which isn't so different from other languages
20:12:21 <edwardk> It is the way it is in all code, really. Here its just easier to capture references to something and call out the fact that you had race conditions you may not have thought of before
20:12:27 <Nisstyre-laptop> kini: what about things like Redis?
20:12:36 <Nisstyre-laptop> surely there is an advantage to using that over a pure data structure
20:12:42 <Nisstyre-laptop> and it exists all in memory (more or less)
20:14:08 <thoughtpolice> tomberek: what you're asking for, generally, can't be done. there is no way to go from a DLL into a statically linkable .a file without recompiling everything as a static library.
20:14:11 <Nisstyre-laptop> or is your point that accessing something in memory is no more "pure" than doing IO?
20:14:16 <`nand`> I've never understood the distinction between storing in RAM and storing on disk; from a programming language point of view, they're both memory
20:14:20 <tomberek> edwardk: do you have a prism explanation or tutorial sitting around?
20:14:27 <`nand`> presumably swap should be able to handle large structures in an ideal world
20:14:30 <edwardk> tomberek: not really
20:14:34 <kini> Philippa: well, in C, for example, the code would look almost the same - you'd just have to modify the deepest functions to make them access the disk instead of access a memory location, and all the rest of the code structure would remain the same
20:14:39 <Nisstyre-laptop> `nand`: different methods of writing to them though...
20:14:44 <edwardk> tomberek: you should put an issue in reminding me to write one ;)
20:14:52 <thoughtpolice> tomberek: so even if you try and force -static, external libraries may still be referenced by DLL. this is unavoidable and the same happens on linux: you may statically link haskell libraries, but it's generally possible to statically link things like say, libc
20:14:52 <tomberek> thoughtpolice: yeah, I was hoping that GLUT had static .a file somewhere... then I found one for freeglut, then I got lost in the toolchain
20:14:56 <parcs> kini: the code would look almost the same in haskell too
20:14:57 <Philippa> `nand`: so that's been a long-term research project. It turns out that at the moment we want to talk about expected volatility amongst other characteristics
20:14:58 <kini> Nisstyre-laptop: well, I certainly understand that a line must be drawn somewhere, and that it's reasonable to assume that you don't have race conditions in accessing your own process's memory
20:15:02 <thoughtpolice> (OK, libc is special on linux, but you get the drift)
20:15:02 <`nand`> Nisstyre-laptop: what I'm saying is that should be the OS/implementation's job, not the programmer's
20:15:16 <kini> parcs: would it?
20:15:24 <parcs> yes
20:15:26 <Nisstyre-laptop> `nand`: so like a uniform system interface for accessing both?
20:15:34 <Philippa> kini: yeah. So that's one reason a lot of haskellers write substantial amounts of code monadically - though not necessarily in the IO monad by default
20:15:35 <sproingie> it's not a disk/ram distinction, it's process space and non
20:15:50 <kini> Philippa: ah
20:15:53 <Philippa> sproingie: that too
20:15:54 <`nand`> Nisstyre-laptop: something like virtual memory aka swap, I guess; except perhaps not implemented in a way that makes your system unusable
20:15:55 <sproingie> files on disk outlive any process, so they are external to them
20:16:08 <sproingie> you'd have the same issue with a pipe or a shared memory segment
20:16:08 <Nisstyre-laptop> `nand`: some people don't use swap
20:16:31 <`nand`> Philippa: ah, I meant specifically for short term storage
20:16:36 <sproingie> or in fact the network and keyboard buffers
20:16:46 <Nisstyre-laptop> although I guess that doesn't matter with what you're talking about
20:16:55 <Philippa> `nand`: that's what virtual memory is for
20:17:08 <Philippa> (subject to cross-process concerns)
20:17:21 <`nand`> yes, but somehow nothing seems to use it, or maybe everything does and I just don't realize
20:17:33 <Philippa> mmap exists
20:19:00 <parcs> kini: depending on how your code is written, all it would take is changing 'doStuffWith myDataStructure' to 'doStuffWith =<< myDataStructure'
20:19:03 <`nand`> if my implementation could automatically write out large data structures to disk and mmap them or something that would be cool, I guess
20:20:00 <Nisstyre-laptop> `nand`: actually I was looking for a way to do this efficiently recently
20:20:14 <Philippa> `nand`: 'swhat 64-bit address spaces are *really* for
20:20:15 <parcs> kini: of course you can write your program in such a way that it would require an extensive rewrite to perform such a change, but the same thing could be said about C too
20:20:16 <Nisstyre-laptop> I'm writing an application that takes all of the tracks in my MPD database and builds a huge markov chain graph
20:20:23 <Nisstyre-laptop> but it's going to be massive
20:20:28 <sproingie> i once tinkered with a persistent heap for C, it wrote out an ELF symbol table to expose itself like a .so
20:21:02 <sproingie> was a pretty neat project, got some chat MUD codebases running on it
20:21:07 <Nisstyre-laptop> there's around 20,000 tracks, each with a bunch of metadata
20:22:11 <slack1256> what is the relationship between MTL and Transformers? I thought MTL was for bare monads (ex: (State s) == (StateT s Identity)) and transformers for transformers
20:22:30 <slack1256> but things like MonadState (the class) to me do more sense in 'transformers'
20:22:38 <`nand`> mtl = monad transformer library
20:22:39 <Nisstyre-laptop> sproingie: how did you serialize the heap?
20:22:43 <parcs> mtl provides convenient type classes for dealing with transformers
20:23:01 <`nand`> slack1256: mtl is just a collection of MPTCs for automating the lifting process, but the underlying monad transformers come from ‘transformers’
20:23:03 <devth> hi, haskell newbie here. i'm trying to `cabal install ghc-mod` but it fails with ExitFailure 1. above that: "ghc-mod-1.12.3 depends on transformers-base-0.4.1 which failed to install". any tips on tracking down the cause? already tried googling around.
20:24:01 <Nisstyre-laptop> devth: did you do a cabal update first?
20:24:02 <slack1256> Mmm but I have been using transformers directly and got the benefit of mtl without importing it.
20:24:04 <slack1256> or maybe not
20:24:13 <`nand`> with ‘transformers’ you'd have to write something like lift (lift get) whereas with mtl you'd (usually) just have to write ‘get’, because the ‘lift’ comes from the MonadState instances of whatever other transformers are on top of it in this example
20:24:15 * slack1256 goes to check what did he import.
20:24:24 <devth> Nisstyre-laptop: i did. i also did a cabal install cabal-install
20:24:39 <sproingie> Nisstyre-laptop: mmap'd file and custom malloc
20:24:46 <`nand`> compare the type signatures of transformers' ‘get’ with mtl's ‘get’
20:24:56 <Nisstyre-laptop> sproingie: I mean what format was the file in
20:25:03 <Nisstyre-laptop> like, how did you structure the heap
20:25:25 <Nisstyre-laptop> or is that not a valid question?
20:25:29 <Nisstyre-laptop> I'm not a C guru
20:25:35 <sproingie> Nisstyre-laptop: whatever format the app wanted, it was just a heap that persisted in a file.  you could locate named objects for bootstrapping by storing it in the ELF symbol table
20:26:00 <slack1256> oh. you are right nand, the get(s) are different
20:26:27 <devth> Nisstyre-laptop: if it helps, this is what i get from manually trying to install transformers-base: https://gist.github.com/devth/5279409
20:26:40 <slack1256> Mmm so the essence of MTL are the Monad.*.Class, cool
20:26:54 <sproingie> Nisstyre-laptop: heck the page is still there: http://coldstore.sourceforge.net/
20:27:37 <Nisstyre-laptop> sproingie: okay I get it
20:27:50 <Nisstyre-laptop> so you're literally taking whatever you want that's in memory and writing it to a file
20:27:56 <dolio> MTL was the original monad library.
20:28:22 <sproingie> Nisstyre-laptop: basically.  with some goofy symbol table munging to allow for bootstrapping it in a new process
20:28:29 <Nisstyre-laptop> yeah, neat
20:28:29 <dolio> Then someone wrote transformers, monads-fd and monads-tf, to split up the classes from the data types.
20:28:43 <dolio> So that you could pick between fundeps and families.
20:28:55 <sproingie> Nisstyre-laptop: all told the whole idea is raving bonkers but it was pretty fun nonetheless
20:28:56 <dolio> Then mtl got reworked to depend on transformers.
20:29:04 <edwardk> MTL came first, then the maintainer Ross went and tried to make a more flexible framework involving 'transformers' and two packages 'monads-fd' and 'monads-tf' but there was a flaw in the design. that is that they used the same module names
20:29:10 <Nisstyre-laptop> sproingie: I might do something like that with Redis in my Haskell program.
20:29:40 <edwardk> In the meantime the modules from mtl and transformers+monads-fd and transformers+monads-tf were incompatible
20:29:41 <slack1256> I suppose that was in the middle of the debate fd vs tf
20:29:52 <edwardk> so you had an ecosystem that split in thirds
20:29:54 <sproingie> Nisstyre-laptop: i think mongodb still pretty much does that, just drops bson-serialized objects into a giant mmap'd chunk
20:29:55 <edwardk> not equally
20:30:09 <Nisstyre-laptop> sproingie: yeah, well I was going to use couchdb maybe
20:30:18 <Nisstyre-laptop> I've never used mongodb
20:30:25 <edwardk> So there was a call in mtl 2.0 to replace mtl with the newer monads-fd internally, and make that depend on transformers, but to try to maintain as much of the old API as possible.
20:30:44 <edwardk> so now we have transformers and mtl. where transformers is entirely haskell 98/haskell 2010 and portable
20:30:49 <edwardk> and the mtl is usable ;)
20:30:55 <slack1256> heh
20:30:58 <sproingie> only nosql i make a lot of use of is cassandra
20:31:23 <edwardk> well, in all honesty, transformers are all that many users of the library need, especially if they are defining classes over them, etc.
20:31:32 <sproingie> we've got a beastly mysql server that's serving up a big nosql-ish EAV schema but having sql is still handy for ad hoc queries
20:31:59 <edwardk> then about a year or so ago i wound up taking over maintainership of mtl. currently ross still maintains transformers though, so its hard to make big changes
20:32:35 <slack1256> you maintain a lot of packages!.
20:32:42 <slack1256> well at least this one isn't change much
20:32:48 <tomberek> edwardk: i was messing around with Control.Lens and was trying to see what would happen to iso (+1) (-1) when viewed as a prism, it didn't make much sense or do anything useful.  In fact, I couldn't figure out a useful Prism application for a valid Iso
20:32:48 <slack1256> *isn't gonna change
20:33:12 <edwardk> > iso (+1) (subtract 1) # 2
20:33:13 <tomberek> i think I'm missing something
20:33:14 <lambdabot>   Not in scope: `#'
20:33:29 <edwardk> @let ( # ) = review
20:33:29 <edwardk> > iso (+1) (subtract 1) # 2
20:33:31 <lambdabot>   Not in scope: `#'
20:33:32 <lambdabot>  Defined.
20:33:36 <edwardk> > iso (+1) (subtract 1) # 2
20:33:40 <lambdabot>   1
20:33:50 <edwardk> > 2 ^. iso (+1) (subtract 1)
20:33:52 <lambdabot>   3
20:34:05 <tomberek> yes, that's an Iso application, forward and backward
20:34:10 <edwardk> yes
20:34:17 <edwardk> every iso is a valid prism, it just can't fail
20:34:22 <tomberek> but neither of them are prism applications
20:34:31 <edwardk> > 2 ^. re (iso (+1) (subtract 1))
20:34:33 <lambdabot>   1
20:34:37 <edwardk> > 2 ^. from (iso (+1) (subtract 1))
20:34:39 <lambdabot>   1
20:34:59 <tomberek> what i mean is this: iso is awesome and makes sense... but I can't figure out what prism does
20:35:08 <edwardk> > _Left # 4
20:35:10 <lambdabot>   Left 4
20:35:16 <edwardk> > Left 4 ^? _Left
20:35:18 <lambdabot>   Just 4
20:35:22 <edwardk> > Right 4 ^? _Left
20:35:24 <lambdabot>   Nothing
20:35:42 <edwardk> its a traversal you can run backwards to construct, or a smart constructor.
20:35:45 <lightquake> tomberek: a prism is essentially a way to look at something that might just turn up Nothing
20:35:53 <edwardk> note _Left isn't the only prism for an Either
20:35:59 <tomberek> aren't those Fold applications?
20:36:11 <edwardk> try to use ( # ) with a Fold.
20:36:20 <edwardk> > _Left # 4
20:36:22 <lambdabot>   Left 4
20:36:42 <edwardk> you can use a prism to both deconstruct like a traversal (or fold) and you can also use it to build
20:36:55 <edwardk> the ability to build with it is how its like an isomorphism.
20:37:13 * hackagebot ref 0.1.1.2 - Generic Mutable Ref Abstraction Layer  http://hackage.haskell.org/package/ref-0.1.1.2 (CarterSchonwald)
20:37:14 <edwardk> you can turn an iso around and use it to build something out of whole cloth. you can do the same with a prism.
20:37:52 <carter> so my build of cabal install is successfully uploading to hackage, but it seems to hang and not return afterwards..
20:38:03 <carter> sounds like a bug
20:38:20 <carter> and a weird one
20:39:55 <edwardk> that is a common issue
20:40:10 <edwardk> basically you get hung up while the server does some crap after it gets done uploading
20:40:20 <edwardk> i generally upload, wait a while and kill it
20:40:33 <edwardk> sometimes i let it go through
20:40:36 <edwardk> it does eventually
20:41:29 <coppro> snoyman doesn't hang around here, does he?
20:41:56 <carter> ahh
20:41:57 <carter> ok,
20:42:21 <carter> well, good thing i filed and issue ticket on it anyways :)
20:42:52 <edwardk> coppro: usually just #yesod
20:43:22 <edwardk> carter: i'd love to have it fixed, it is actually a good portion of my build ritual's overall timeline ;)
20:43:34 <edwardk> i've gotten to where i switch windows and continue with another project ;)
20:43:41 <carter> remind me in a few months
20:43:42 <edwardk> its a good task switching moment =)
20:43:44 <carter> haha
20:43:53 <carter> hehe, me having time a few months
20:43:55 <edwardk> a natural thread quantum
20:44:02 <carter> cool
20:44:24 <edwardk> btw- i've made some headway on the indexing scheme. wavelet trees are the new hotness
20:44:28 <carter> well, either way, theres now an IORef and STRef api on hackage for using the ghc CAS primop
20:44:29 <carter> oh?
20:44:33 <carter> should I read some papers?
20:44:38 <edwardk> there are some in the papers list
20:44:48 <carter> i'm too exhausted to load up on new info in high bandwidth for a day or so
20:44:58 <edwardk> in particular dynamically extensible rank/select structures are becoming important to me
20:45:01 <carter> ooo
20:45:12 <carter> btw: have you ever seen the Chazelle soft heap?
20:45:28 <sproingie> that sounds like a brand of toilet paper
20:45:32 <edwardk> yeah
20:45:43 <carter> http://www.siam.org/proceedings/soda/2009/SODA09_053_kaplanh.pdf a newer exposition i've not read year
20:45:45 <carter> *yet
20:45:49 <carter> was just reading the older paper
20:45:57 <edwardk> https://github.com/ekmett/heaps/issues/1
20:46:17 <edwardk> =)
20:46:25 <edwardk> you can see i'm eagerly trying to clear out that issue
20:46:34 <carter> heh
20:46:47 <carter> i think that it might be good for the visual binnning stuff maybe
20:47:07 <carter> i've a few crazy ideas for sparse lin alg also in the wings
20:47:22 <carter> that may use intmap etc for doing sparse work sometimes
20:47:26 <carter> ish
20:47:28 <edwardk> running out to grab caffeine before trying to figure out how to get on google hangout for that japanese thing
20:47:37 <carter> i couldn't read the japanes
20:47:38 <carter> ok
20:47:41 <carter> hang on a sec
20:47:44 <edwardk> let google translate it
20:48:26 <carter> edwardk ring at wil
20:48:33 <edwardk> my japanese is terrible. i learned it from watching anime. when i _am_ willing to speak i always sound like a terrified japanese school girl
20:48:41 <edwardk> kk
20:48:46 <djahandarie> Hahaha.
20:48:51 <liyang> edwardk: This is true.
20:48:57 <liyang> Crap I'm late.
20:48:57 <djahandarie> I need to get you to talk Japanese sometime edwardk.
20:49:03 <xunatai> is there a shorthand for: (\x -> x {record = value}) ?
20:49:04 <carter> liyang what is true?
20:49:15 <djahandarie> Because that sounds like it'd be pretty hilarious.
20:49:37 <liyang> That when anyone learns Japanese from anime they end up sounding like a schoolgirl.
20:50:10 * djahandarie learned his Japanese from anime!
20:50:18 <djahandarie> I don't think I sound like a school girl at least.
20:50:49 <djahandarie> BTW, is this meetup being broadcasted or something? I think it'd be fun to listen in.
20:52:42 <liyang> (Which is fine if you are a schoolgirl, but I'd wager that edwardk is not.)
20:53:14 <liyang> Off. See y'all there.
20:55:48 <otters> i've seen some of edwardk's talks
20:55:57 <otters> the only thing less like a schoolgirl is a tentacle monster
20:56:09 <djahandarie> Hahahahaha
20:56:23 <BMeph_> I've heard some of them. NOT A SCHOOLGIRL!! :?
20:56:29 <jmcarthur> soft heaps sound cool
20:56:52 <lightquake> xunatai: i don't believe so
20:59:13 <djahandarie> 柔らかい山
20:59:27 <xunatai> i'm trying to figure out how to easily modify a single record in a state, basically amounting to:  "modify (\x -> x {record = value})"
20:59:40 <connelly> so I'm trying to install a package (HTTP) on a system that isn't network connected.  I un-tgz the file, cd into the directory and run "runhaskell Setup configure" but a get the error "Could not find module Distribution.Simple"
21:00:04 <connelly> where do I download the offline tgz for Distribution.Simple?
21:00:13 <connelly> this is on windows
21:02:01 <arkeet> xunatai: lens is for you =)
21:02:16 <arkeet> lens .= value
21:02:19 <arkeet> easy.
21:02:35 <jmcarthur> connelly: that sounds like something in the Cabal library, which i would expect you to have already...
21:02:49 <xunatai> how much baggage comes with lens? is it just syntatic sugar?
21:03:18 <jmcarthur> lens is a big library, but it restricts its dependencies to things in the haskell platform, iirc
21:03:19 <arkeet> lens is a lot of cool stuff.
21:03:35 <arkeet> jmcarthur: it depends on a couple things outside.
21:03:39 <xunatai> ok
21:04:05 <jmcarthur> arkeet: ah, well then scratch what i said
21:04:08 <arkeet> > execState (_1 .= "blah") ("hello","world")
21:04:10 <lambdabot>   ("blah","world")
21:04:49 <arkeet> > _1 .~ "blah" $ ("hello","world")
21:04:51 <lambdabot>   ("blah","world")
21:07:08 <xunatai> is lens a separate package?
21:07:13 <arkeet> yes
21:07:15 <edwardk> yes
21:07:16 <xunatai> darn
21:07:49 <edwardk> jmcarthur: what you said is substantially correct. it limits its scope to the haskell platform + a couple of libraries of mine and others' that are needed for its internals
21:08:11 <edwardk> e.g. unordered-containers isn't in the platform, but it makes the plated combinators 5x faster
21:08:12 <jmcarthur> @tell bitonic see the comment on "Order of constructors" here http://hackage.haskell.org/packages/archive/containers/0.5.2.1/doc/html/src/Data-IntMap-Base.html#IntMap
21:08:12 <lambdabot> Consider it noted.
21:10:51 <cmccann> I figured that the haskell platform would be deprecated these days in favor of just "install lens and its dependencies"
21:11:09 <edwardk> its a good way to get a solid subset of hackage installed ;)
21:14:03 <Mortchek> I actually didn't know how much of the stuff I regularly use was part of the platform until I tried using Cabal to compile my project and it kept complaining of missing packages.
21:15:19 <xunatai> i'll just keep fiddling with records for now, i only just today learned how to use the state monad
21:16:05 <carter> jmcarthur they are cool
21:16:12 <carter> i'm on a slow motion data structure writign bender
21:16:31 <carter> where at least some small constant fraction of the data structures i look at get writen up by me
21:16:35 <edwardk> i tend to avoid slow motion data structures
21:16:43 <carter> me too
21:16:46 <carter> i'm the slow part
21:16:59 <carter> jmcarthur still in nyc? i've not run into you in a hwile!
21:17:14 <jmcarthur> yeah i'm still around
21:17:17 <carter> cool
21:17:24 <carter> lets catchup soon
21:17:29 <jmcarthur> i meant to go to the last haskell meetup but something came up
21:17:38 <jmcarthur> yeah we should
21:18:28 <omtinez> new to haskell here, I am trying to implement a function like join for a list but keep getting Prelude.tail: empty list...
21:18:51 <carter> jmcarthur yes!
21:19:04 <mapf> what if I want to import two modules with the same name? Is it possible?
21:20:22 <carter> mapf nope
21:20:41 <carter> why do they have the same name?
21:21:34 <shachaf> Yes, I think, with a GHC extension.
21:21:52 <mapf> which one?
21:22:07 <shachaf> If they come from different packages.
21:22:18 <carter> shachaf yeah.. but thats fragile
21:22:21 <shachaf> PackageImports?
21:22:28 <carter> lets first find out why they have the same name
21:22:50 <shachaf> Yes, I don't recommend it.
21:23:13 <omtinez> new to haskell here, I am trying to implement a function like join for a list but keep getting Prelude.tail: empty list...
21:23:27 <carter> omtinez paste your code to hpaste please
21:23:46 <carter> if we can't see the code, we can't see how to help you understand!
21:23:51 <carter> :)
21:24:02 * carter laughs in a benign maniacal manner
21:24:49 <cmccann> > join [[1,2,3],[],[4,5]]
21:24:51 <lambdabot>   [1,2,3,4,5]
21:25:10 <carter> or that works
21:25:14 <carter> ohh
21:25:17 <mapf> shachaf: nice, thanks
21:25:19 <carter> you mean that sort of join
21:25:50 <hpaste> omtinez pasted “join” at http://hpaste.org/84903
21:25:52 <mapf> carter: well actually i just want to bench two module with the same name. it's just a bench.
21:25:52 <carter> i was thinking relational join
21:26:05 <carter> mapf why do they ahve the same name?
21:26:07 <omtinez> http://hpaste.org/84903
21:26:32 <mapf> because they do the same thing.
21:26:38 <omtinez> sorry, maybe concat would have been a more appropriate word
21:26:49 <carter> omtinez you could jsut use show! :)
21:26:49 <cmccann> omtinez: why do you have "tail" there?
21:26:56 <carter> oh yeah that too
21:27:05 <carter> if you remove tail, it shoudl be correct
21:27:23 <omtinez> I know that I can use show, but I am trying to learn how the language works
21:27:35 <carter> mapf if they're different algorithms, you should name the modules to reflect that! :)
21:27:36 <cmccann> > intercalate "," ["foo", "bar", "baz"]
21:27:38 <lambdabot>   "foo,bar,baz"
21:27:42 <applicative_> omtinez: xs is already the tail
21:28:05 <omtinez> oh! I feel pretty stupid now...
21:28:08 <hpaste> Sonarpulse pasted “Weirdly successful type inference” at http://hpaste.org/84904
21:28:21 <cmccann> @src intercalate
21:28:22 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
21:28:28 <cmccann> @src intersperse
21:28:28 <lambdabot> intersperse _   []     = []
21:28:29 <lambdabot> intersperse _   [x]    = [x]
21:28:29 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
21:28:38 <cmccann> do you see how that works?
21:28:46 <Sonarpulse> I doubt this code does what I am trying to make it do
21:29:17 <Sonarpulse> but that makes it all the more puzzling
21:29:36 <omtinez> thank you for the help, I really embarrassed myself there
21:29:47 <applicative_> omtinez: so without the explicit tail function you've handled both cases, list with a tail and list with no tail i.e. []
21:29:56 <carter> omtinez i make stupid mistakes even in my (relative) experience,
21:29:59 <cmccann> nah, we've all made silly mistakes. especially as a beginner. :]
21:30:00 <applicative_> oh not at all omtimez
21:30:04 <carter> doing stuff and seeing what happens ishow learning works!
21:30:26 <carter> i make silly mistakes even in production haskell code sometimes
21:30:38 <carter> thankfully not too much
21:30:48 <applicative_> I don't make mistakes anymore, haven't seen an error message in months...
21:30:59 <cmccann> sometimes SPJ makes mistakes in GHC's code
21:31:50 <omtinez> applicative_: thanks for explaining that, I get it now
21:32:17 <carter> haskell is one of those languages where theres always even awesomer ways to do stuff,
21:32:27 <carter> well
21:32:28 <omtinez> carter: how common is it for companies to use haskell in actual production code? may I ask what type of business is it?
21:32:48 <carter> omtinez far fewer than do ruby on rails :)
21:32:58 <carter> i do some consulting things mostly
21:33:25 <latermuse> i build *nix tools with haskell
21:33:30 <carter> though theres a growing number of FP shops out there
21:33:30 <Sonarpulse> Haskell #18 on github, assembly is #17. What more proof is needed that you shouldn't follow the masses? :)
21:33:36 <cmccann> omtinez: there's some use in the financial industry I think, and a few startups have used HaSkell
21:33:46 <carter> yup
21:33:54 <cmccann> ...how did that S get capitalized
21:34:04 <carter> HaSKUL :)
21:34:11 <latermuse> Skol
21:34:15 <carter> skolemization
21:34:44 <omtinez> I thought that the financial industry is plagued with C*BOL
21:34:59 <carter> omtinez i do some random neat engineering things, but a lot fo my time right now is building some data analysis / numerical computation tools
21:35:00 <Sonarpulse> Jane street capital does OCaml
21:35:03 <carter> omtinez depends
21:35:14 <carter> theres also alpha heavy
21:35:49 <carter> plus a few others
21:35:52 <carter> tsuru
21:36:09 <carter> some big banksi'm blanking on because i'm tired
21:36:21 <omtinez> that is cool, I would love to see some stats in the productivity
21:36:29 <carter> omtinez that hard to measure :)
21:36:32 <djahandarie> tanakh_, すみませんが、放送はないのでしょうか…と思ったので…（勉強会について）
21:36:42 <carter> people use tools to solve problems
21:37:01 <carter> if they're making money, that validates the tools work for them, at least in businesses
21:37:12 <carter> or at least thats how many biz folks think
21:37:34 <carter> haskell tends to validate itself pretty well when used thoughtfully in a tech biz
21:37:34 <gienah> Standard Chartered Bank: http://neilmitchell.blogspot.com.au/2012/08/standard-chartered-bank-where-i-work-is.html
21:37:42 <carter> yes, i was blanking on that one
21:37:58 <carter> i really need to play with shake, esp since he's working on it again
21:38:04 <cmccann> is it standard chartered that has augustss as well?
21:38:09 <carter> i think so
21:38:23 <omtinez> what is the coolest thing that you have seen being done with haskell?
21:38:25 <gienah> and don stewart
21:38:37 <carter> omtinez my stuff :)
21:38:38 <cmccann> yeah they really cleaned up with recruiting :O
21:38:46 <carter> omtinez just scroll through hackage
21:38:54 <carter> theres lots of astounding tools
21:39:06 <newsham> cobol is clearly the best tool evar
21:39:18 <newsham> at least in business
21:39:35 <carter> omtinez what topic is exciting for you, theres probably some neat package on hackage that does something in that domain
21:39:56 <cmccann> newsham: because I still find this site hilarious: www.coboloncogs.org/
21:40:03 <omtinez> newsham: how can you say that? I still get the shivers when I only hear the name of "cobol"...
21:40:14 <tomberek> is there anything in Haskell Platform (ie. available without any cabal install) that can read information from a mouse? (Win/*nix)?
21:40:28 <omtinez> carter: I am particularly interested in AI & robotics
21:40:47 <carter> as in you do stuff in that domain?
21:40:56 <carter> or working on learnign stuff in that domain?
21:41:05 <copumpkin> cmccann: they're hiring another 40 in china
21:41:09 <carter> thats a pretty huge area
21:41:16 <carter> copumpkin yeah, i heard that
21:41:19 <arkeet> tomberek: haskell platform doesn't really include anything of that sort
21:41:30 <arkeet> err
21:41:31 <carter> its kinda awesome
21:41:34 <arkeet> I suppose it has GLUT.
21:41:38 <carter> that they're hiring that muhc
21:41:39 <cmccann> haha
21:41:49 <carter> though it isn't in the western hemisphere :(
21:41:55 <carter> (cause that'd be awesome )
21:42:00 <cmccann> actually I don't think it has GLUT
21:42:06 <omtinez> carter: I just landed a job right out of college, so I am not so interested in terms of careers, it is just curiosity
21:42:08 <arkeet> sure it does.
21:42:11 <arkeet> I'm looking at the list rightn ow.
21:42:19 <cmccann> arkeet: ok then
21:42:27 <carter> learning is fun and healthy
21:42:29 <carter> cool
21:42:30 <tomberek> arkeet: I didn't think so, I didn't know if Posix or Win32 had something hidden in them
21:42:46 <arkeet> oh, maybe it does.
21:43:25 <tomberek> I'm aware of the GLUT,Gloss,wx bindings... I was looking for something where there isn't a huge library installation headache
21:43:55 <cmccann> arkeet: actually, where are you finding this? all I see is the OpenGL and GLU stuff
21:43:56 <arkeet> so sure, maybe Win32 has something that will let you do that, but there's no corresponding thing for X.
21:43:59 <arkeet> cmccann: http://www.haskell.org/platform/changelog.html
21:44:00 <omtinez> mccann newsham: I made this while working at a mainframe shop: http://rssatwork.com/
21:44:34 <cmccann> huh, ok.
21:44:42 <omtinez> carter: not only that, but in this field there is always new stuff coming out so the learning is potentially unlimited
21:44:58 <carter> as in most fields of comp scie everrrr
21:46:10 <cmccann> well if you're doing AI surely you can just have the machine do the learning for you
21:46:14 <cmccann> that's how it works, right
21:47:19 <omtinez> cmccann: yep pretty much :)
21:49:37 <cmccann> wavewave: hey, did you ever get actual pressure sensitivity in hoodle? I can't recall. I know you get tablet input because I tried it but it didn't seem to do anything with the pressure
21:49:46 <cmccann> wavewave: but maybe I had something configured wrong, not sure
21:53:59 <xunatai> where exactly do where clauses fit in do-blocks?
21:54:18 <xunatai> if it makes sense to do so..
21:54:22 <c_wraith> They don't
21:54:25 <cmccann> no where (ha, ha)
21:54:32 <monochrom> haha
21:54:41 <monochrom> "where" is not attached to do
21:54:42 <c_wraith> where clauses attach to pattern matches.
21:55:12 <c_wraith> case statements, or their sugar in the form of multiple equations for a function
21:55:15 <lightquake> where clauses attach to statements, don't they?
21:55:23 <monochrom> no
21:55:25 <xunatai> so, what happens if have some expression that i don't want evaluated multiple times?
21:55:30 <c_wraith> well, case expressions, to be accurate.
21:55:33 <xunatai> in a do-block
21:55:45 <lightquake> ah
21:55:46 <monochrom> use "let"
21:56:07 <lightquake> you can also do, like
21:56:19 <lightquake> x = do { … ; … ; … } where y = 7
21:56:35 <xunatai> does it only need to evaluate let expressions in a do-block once?
21:56:38 <monochrom> that is because "where y=7" is attached to "x="
21:56:41 <lightquake> yes
21:56:52 <xunatai> why's that?
21:57:28 <lightquake> xunatai: yes, it also only evaluates the let expression once
21:58:54 <lightquake> the difference between let and where is fundamentally that let attaches to an expression, where attaches to a statement
21:59:08 <monochrom> not statement
21:59:20 <monochrom> at least, not called statement
21:59:31 <lightquake> er, right
21:59:33 <lightquake> to a pattern match
22:00:01 <lightquake> so you can do x = (let y = 2 in y) + 2, but not x = (y where y = 2) + 2
22:00:20 <cmccann> you can also attach where clauses to the equation in a let expression
22:00:44 <lightquake> > let y = z where z = 3 in y
22:00:46 <lambdabot>   3
22:02:19 * hackagebot named-records 0.3 - Flexible records with named fields.  http://hackage.haskell.org/package/named-records-0.3 (JulianFleischer)
22:03:02 <monochrom> http://www.hck.sk/users/peter/HaskellEx.htm is very useful. do not assume. use the rules.
22:03:46 <xunatai> so, this really only will evaluate 'herp' once? http://vpaste.net/tEp18
22:04:11 <monochrom> yes
22:04:36 <xunatai> but not in pure functions?
22:05:14 <monochrom> in pure functions too
22:05:38 <xunatai> i was under the impression that it would evaluate it multiple times, and you used where in order to prevent that
22:06:05 <monochrom> how did you know? experimental evidence?
22:06:29 <monochrom> do not assume. do not think. find experimental evidence
22:06:30 <xunatai> my memory from reading various sources
22:07:14 * applicative_ notice oleg's iteratee type is FreeT (WriterT (Maybe ErrMsg) (StateT (Stream el) m)) a   no wonder one flees in terror 
22:07:19 <monochrom> don't just read and believe. validate. refute.
22:07:49 <monochrom> design experiments to test claims on the internet
22:08:16 <applicative_> that would be exhausting
22:08:17 <monochrom> neglect and condemn claims that cannot be tested
22:08:46 <monochrom> well, then read less
22:10:12 <monochrom> learning a programming language is hard. learning programming is hard. don't tell me you never test anything you read about a programming language.
22:10:58 <monochrom> make it stronger: don't tell me there is something you read and believe about a programming language that you don't test.
22:11:20 <BMeph_> More importantly, don't tell monochrom you never test anything you read on the Internet! =8*O
22:11:41 <applicative_> maybe we should have #haskell-boot-camp with Sgt Monochrom
22:12:00 <cmccann> Full Metal Lambda
22:12:02 <monochrom> I mean, if you read some quantum mechanics, of course you won't be testing it. not your specialty
22:13:17 <xunatai> well, i'm still a massive beginner at haskell, so it's honestly easier to appeal to authority for now, i can ridicule the details later
22:14:53 <monochrom> but you're a programmer and you just believe "main = getLine >> putChar 'x'  skips the getLine because haskell does lazy IO!" from the internet without testing? please don't kid me. that is not learning. that is being scammed.
22:14:55 <xunatai> and i haven't yet written a program whose performance would depend on that detail, i'm just passively curious
22:15:13 <xunatai> what?
22:15:50 <Mortchek> On that topic, I use a probably kind of bad but experimentally effective way to test evaluation - unsafePerformIO. What do you guys do?
22:16:01 <applicative_> xunatai: writing let in that simple case is basically writing (\x -> print x >> print x ) <computationally expensive>
22:16:44 <xunatai> thank you applicative_, that makes a lot of sense
22:16:50 <monochrom> I completely disagree with and must object to "beginner, therefore appeal to authority"
22:17:00 <cmccann> Mortchek: Debug.Trace?
22:17:14 <applicative_> xunatai: so its the same if it's pure (\x -> x + x) <expensive>
22:17:37 <monochrom> screw haskell. I was once an absolute beginner in programming whatsoever. and at the very first minute, I already tested everything I read.
22:17:58 <applicative_> that explains a lot ;)
22:18:09 <cmccann> monochrom: I bet you were one of those kids who spent half an hour poking at your food and demanding to know what was in it before you tasted anything
22:18:18 <monochrom> when the BASIC book said "enter 1+1 at the BASIC prompt, you'll get 2", I actually tested it.
22:18:18 <Mortchek> cmccann, neat, looks like that's basically a function already defined to do what I do. Thanks.
22:18:26 <Mortchek> set of functions*
22:18:32 <cmccann> Mortchek: yep
22:18:45 <applicative_> he demanded an analysis of the digestive system even as a newborn
22:19:18 <monochrom> that is not true and unfair, cmccann. also, tasting is part of testing.
22:19:39 <cmccann> heh
22:19:45 <monochrom> I feel offended
22:19:54 <monochrom> screw you all
22:20:02 <cmccann> :[
22:20:06 <xunatai> :|
22:20:41 <cmccann> I think he took that a lot more seriously than it was intended to be :[
22:21:46 <Mortchek> I am all with him about "test things before you believe them". But I didn't say anything because it seemed obvious to me. :|
22:25:52 <pharaun> :[
22:27:19 <sw2wolf> ping
22:29:30 <pharaun> I'm having trouble finding the right api but i have - several numbers - year, month, day, hour, min, sec and i want to put it into a datetime value, i can't seem to find a unified one, only a time or a calendar
22:30:04 <xunatai> i understood his point, and it's ovious, i just don't bother testing unless i have production code where i need to be certain of some particular behavior
22:30:28 <xunatai> too many high level concepts that i need to learn first, before i even think about performance
22:31:20 <xunatai> and all those high level concepts appeal to authority intrinsically..
22:35:20 <ikeg> i'm watching now a video stream on web for introduction to Edward Kmett's libraries in Haskell
22:35:29 <pharaun> aha nvm i think i tracked down date.time
22:35:41 <edwardk> ikeg: likewise =)
22:35:54 <ikeg> edwardk: oh, you are here
22:36:22 <edwardk> i can invite you directly to the google hangout if you want to see if thats lower latency than the stream
22:36:31 <edwardk> probably would have better video quality
22:36:42 <arkeet> I found ustream had the better video quality.
22:36:49 <edwardk> fair enough
22:37:18 <ikeg> edwardk: your last comment of the version of the lens is recognized. thanks.
22:38:21 <ikeg> edwardk: i'm afraid the limit of members of Google Hangout
22:38:23 <edwardk> arkeet: how much latency is there between the ustream and the hangout?
22:38:30 <arkeet> a couple of seconds
22:38:36 <edwardk> k
22:41:01 <roshan> edwardk: I just wrote a church-encoded free monad transformer for the "free" package and attached it to a github issue. I'm new at this, so let me know what you think when you've had a chance to take a look.
22:41:13 <edwardk> will do
22:41:19 <edwardk> i've been meaning to add one
22:41:49 <roshan> edwardk: Thanks!
22:41:58 <arkeet> ikeg: if you'd like, we're discussing in #haskell-lens
22:43:01 <tomberek> arkeet: getCurosPos is in Graphics.Win32.Misc
22:44:56 <applicative_> roshan: newtype FT f m a = FT { runFT :: forall r. (a -> m r) -> (f (m r) -> m r) -> m r } is too hard for me.  I'll try it with something...
22:46:12 <djahandarie> edwardk, think you could invite me? The ustream keeps on cutting out for me.
22:46:19 <edwardk> sure
22:46:29 <djahandarie> I need to figure out how to use Google Hangout though.
22:47:23 <edwardk> djahandarie: we're also talking about the presentations as they go in #haskell-lens
22:47:41 <roshan> applicative_: I tried a few different variations, and that's the one that let me make an isomorphism between FreeT and FT. I think of it as taking the church-encoded free monad (forall r. (a -> r) -> (f r -> r) -> r) and replacing all the arrows with monadic arrows
22:47:46 <tomberek> where is the hangout? or is it invite only?
22:48:23 <djahandarie> The talk is in Japanese so I'm not sure it will be of interest to most people
22:48:48 <tomberek> ah
22:49:00 <arkeet> well, at least you can read the code :)
22:49:16 <roshan> applicative_: And the meaning is that (a -> m r) is an action to take when you see a pure value, and (f (m r) -> m r) is an action to take when you see an impure value
22:56:53 <edwardk> djahandarie: actually the first one was in english
22:57:02 <edwardk> they'll probably vary
22:57:17 <edwardk> tomberek: sent an invite
23:00:08 <Sonarpulse> is there any function to split a list of FilePaths into those pointing to directors and those pointing to files?
23:00:54 <mauke> what about those who are neither?
23:01:16 <Sonarpulse> um trim them I guess
23:01:26 <Sonarpulse> I was using doesDirectoryExist
23:01:30 <Sonarpulse> and partition
23:01:58 <Sonarpulse> but no matter what combination of kligilsies and liftMs I tried, I couldn't get it to type check
23:03:45 <mauke> sequence?
23:04:07 <Sonarpulse> as in the datatype or function?
23:04:19 <mauke> function
23:05:03 <Sonarpulse> on an unrelated note, is there a way to make ghci load the prereqs of the file it failed to interpret?
23:05:16 <Sonarpulse> that would make trying things in the repl SO much easier
23:05:32 <Sonarpulse> using a flip and LiftM I can get
23:05:52 <Sonarpulse> m (a -> b) -> m ([a], [a])
23:05:56 <Sonarpulse> which is pretty close
23:06:19 <Sonarpulse> but then I need to get m a -> m b -> m (a, b)
23:06:39 <Sonarpulse> sorry  m a -> m b -> m (a -> b)
23:06:51 <Sonarpulse> whoops again wrong
23:07:08 <Sonarpulse> sorry (a -> m b) -> m (a -> b)
23:09:00 <Sonarpulse> :t flip (flip partition [])
23:09:01 <lambdabot>     Couldn't match expected type `b0 -> c0'
23:09:02 <lambdabot>                 with actual type `([a0], [a0])'
23:09:02 <lambdabot>     Expected type: (a0 -> Bool) -> [a0] -> b0 -> c0
23:09:18 <Sonarpulse> :t (flip partition [])
23:09:20 <lambdabot> (a -> Bool) -> ([a], [a])
23:12:42 <Sonarpulse> holly shit http://www.haskell.org/pipermail/beginners/2009-December/002880.html
23:12:45 <Sonarpulse> history repeats itself
23:14:35 <circle> what's partial application?
23:15:15 <Sonarpulse> circle:  myfunc :: a -> b -> c
23:15:35 <Sonarpulse> (myfunc value) :: b -> c
23:18:52 <mauke> circle: when you call a function without giving it all of the arguments it wants
23:19:06 <circle> yeah that sounds right
23:52:28 * hackagebot packer 0.1.1 - Fast byte serializer and unserializer  http://hackage.haskell.org/package/packer-0.1.1 (VincentHanquez)
