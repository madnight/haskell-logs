00:00:05 <blueonyx> and what i really wanted was assertFailure from testpack xD
00:00:29 <ski_> hm, oh
00:01:19 * hackagebot cereal-conduit 0.7 - Turn Data.Serialize Gets and Puts into Sources, Sinks, and Conduits  http://hackage.haskell.org/package/cereal-conduit-0.7 (MylesMaxfield)
00:11:59 <blueonyx> what Exception does error throw?
00:12:11 <blueonyx> assertRaises :: (Show a, Exception e, Show e, Eq e) => String -> e -> IO a -> IO ()
00:12:17 <blueonyx> i want to check that error is used
00:12:22 <blueonyx> *assert
00:12:51 <shachaf> I think the documentation says.
00:13:07 <shachaf> Hmm, maybe not.
00:13:19 <blueonyx> which documentation?
00:13:27 <shachaf> But the Control.Exception documentation does. :-)
00:19:37 <AfC> Is there a way to HUnit test a piece of code raises a specific type of Exception without it being an instance of Eq and having visible constructors?
00:20:20 <arkeet> by type do you actually mean type?
00:20:24 <ivanm> AfC: check if the result of showing the exception matches what that exception does?
00:21:04 <levi> Hmm, there seem to have been a few implementations of communicating processes with session types, but then a lack of activity in the last couple of years.  Were they just a passing fad?
00:25:12 <AfC> ivanm: yeah
00:25:43 <ivanm> rather weird that there's no Eq instance though
00:26:04 <AfC> arkeet: right now I have code like
00:26:04 <AfC>         assertException (HttpClientError 404 "Not Found") (get url concatHandler')
00:26:31 <AfC> which is using and `assertException` I found on stack overflow (oh, yeay)
00:26:48 <AfC> which requires a) that the HttpClientError constructor be visible, and b) that it be an instance of Eq
00:26:55 <blueonyx> from http://stackoverflow.com/questions/13350164/how-do-i-test-for-an-error-in-haskell?
00:27:10 <AfC> I'd prefer something that just says (psuedo):
00:27:29 <AfC>         assertException (isa HttpClientError) (get url concatHandler')
00:27:53 <AfC> which isn't legal; I have to get they type to the other side of a case statement, or an x :: HttpClientError, or... somehow, right?
00:28:29 <AfC> blueonyx: yeah, that one or one identical to it
00:28:50 <blueonyx> yea my problem is now too, that ErrorCall has no Eq instance
00:29:20 <AfC> in Java I would have done try { code; fail("Wrong!"); } catch (HttpClientError e) { // good! }
00:30:27 <ivanm> AfC: where is this error from?
00:30:30 <ivanm> hayoo can't find it :/
00:30:32 <AfC> blueonyx: my problem is that the Exceptions being raised are from foreign libraries and don't have visible constructors (and, in any case, the Eq is useless on SomeException msg)
00:30:32 <supki> AfC: did you see hspec?
00:30:39 <supki> shouldThrow looks promising
00:31:01 <supki> (also hspec is much nicer than HUnit)
00:31:04 <AfC> supki: I'm using hspec, actually. Didn't know about shouldThrow. That new? Looking.
00:31:21 * hackagebot clckwrks-plugin-page 0.1.3 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.1.3 (JeremyShaw)
00:31:35 <supki> AfC: shouldThrow specifically is from hspec-expectations
00:31:36 <AfC> ivanm: the Exception in question is from _my_ library, but there are other cases I'm trying to prove.
00:31:49 <ivanm> AfC: well, I would argue that you should export the constructors ;-)
00:32:17 <ivanm> if nothing else so that people can customise how to deal with said error when using catch, handle, etc.
00:33:26 <AfC> ivanm: *I* did, which is how I could write that code fragment. But for the next text case, I'm looking for TooManyBytesReadException out of io-streams, and that (for perfectly sane reasons) does not have a public constructor. So EDOESNTWORK
00:33:44 <AfC> supki: Thanks! I'll try some of the code form hspec-expectations
00:34:04 <ivanm> oh? what's the rationale for io-streams not exporting the constructors?
00:34:11 <blueonyx> hm i'm using test-framework atm :/
00:34:17 <AfC> ivanm: because you don't need them?
00:34:27 <ivanm> but this is _why_ you need them
00:34:39 <AfC> ivanm: (why pollute namespace?)
00:34:53 <ivanm> well, you don't import them if you don't need them
00:35:00 <ivanm> have a separate module exporting them if need by
00:35:28 <AfC> ivanm: so now you're polluting the module and package namespace. Just as bad.
00:35:39 <ivanm> how is it polluting?
00:35:45 <AfC> noise
00:36:21 * hackagebot ez-couch 0.6.1 - A high level static library for working with CouchDB  http://hackage.haskell.org/package/ez-couch-0.6.1 (NikitaVolkov)
00:37:06 <ivanm> *shrug* I prefer the option to having access to such things if need be
00:38:13 <ivanm> this is the io-streams by snapframework, right?
00:38:20 <ivanm> I can't even find where these exceptiosn are in there...
00:41:56 <AfC> ivanm: you got it installed? If so, file:///home/andrew/.cabal/share/doc/io-streams-0.1/html/System-IO-Streams-ByteString.html#v:readExactly (for an appropriate value of $USER back there)
00:42:07 <AfC> hm. 1.0.0.0, but anyway
00:42:15 <ivanm> I'm looking at the github version actually :)
00:43:08 <ivanm> Yeah, I don't see why you wouldn't export those constructors
00:44:00 <AfC> ivanm: I'll ask Greg, but I'm sure he'll say what I just told you
00:44:09 <ivanm> *shrug*
00:44:56 <ivanm> well, if you ever want to manage the result of getting that exception (as in know how many bytes are missing, etc.) you need the constructor, or at least a function that returns the Int
00:45:16 <ivanm> also for cases like you've found, when you want to test whether you get that exception or not
00:50:14 <AfC> ivanm: sure, the constructor is useful, but an Eq instance wouldn't be that meaningful, and its requirement for that assertException hack was a show stopper in cases where you have SomeException error_msg. Anyway, supki's suggestion works great.
00:51:53 <ivanm> the Eq instance isn't what I was talking about ;-)
00:52:03 * ivanm wonders how shouldThrow works then
00:53:05 <ivanm> well, ultimately shouldThrow just gets back down to using Eq AFAICT :s
00:55:22 <AfC> ivanm: there's no Eq constraint?
00:55:51 <ivanm> AfC: right, but you still need some kind of Bool result
00:56:02 <ivanm> and how else do you get it? by hackily comparing the outputs of show?
00:56:10 <ivanm> (which IMO is rather fragile)
00:56:58 <AfC> ivanm: At the moment I'm just stealing the implementation in Test.Hspec.Expectations which is declaring a signature and then returning a const. Pretty cool:
00:57:11 <AfC> ourException :: Selector HttpClientError
00:57:11 <AfC> ourException = const True
00:57:30 <ivanm> so how does that work with SomeException?
00:57:34 <AfC> That works. Now I'm trying a few variations for fun.
00:58:08 <AfC> ivanm: oh, that's what I stole: that library ships with "anyException" which is :: Selector SomeException
00:58:32 <ivanm> so, are you using SomeException, or not?
00:58:51 <ivanm> I thought your problem was that you were using SomeException, and wanted to see if the Exception inside was what you wanted
01:07:10 <NetBat> > Pi
01:07:26 <NetBat> Hi folks, any idea what's happened to lambdabot?
01:09:32 <ivanm> NetBat: she's having a nap
01:09:39 <ivanm> preflex: seen lambdabot
01:09:39 <preflex>  lambdabot was last seen on #haskell 3 hours, 56 minutes and 10 seconds ago, saying:   144
01:10:03 <typoclass> Cale: lambdabot is out, hunting grandmas again
01:12:51 <astor> does fpco hang out here?
01:13:00 <johnw> astor: yes
01:16:37 <astor> I'm trying to build fpco/gitlib but fpco/rest-client and fpco/data-vendor are gone.  I couldn't find anything else on fpco so I thought it was a bit strange.
01:17:14 <johnw> astor: fpco/rest-client is pending release; just drop gitlib-github from your sources.txt file.  I think you meant data-marshal instead of data-vendor?
01:17:33 <johnw> drop that one too
01:17:40 <astor> data-marshal yes
01:17:44 <astor> ok, thanks
01:20:26 <johnw> i'm working on getting rest-client released, it just needs to go through a review and some documentation
01:21:42 <astor> ok, cool.
01:29:13 <johnw> astor: what are you using gitlib for?
01:32:36 <Jeanne-Kamikaze> is there float exponentiation ?
01:32:58 <Jeanne-Kamikaze> ah
01:33:12 <Jeanne-Kamikaze> **, there it is
01:46:23 * hackagebot binary 0.7.0.0 - Binary serialisation for Haskell values using lazy ByteStrings  http://hackage.haskell.org/package/binary-0.7.0.0 (LennartKolmodin)
02:09:22 <quchen> What's the difference between TVar and TMVar?
02:10:29 <arkeet> TMVar can be empty
02:11:13 <mauke> it's like the difference between IORef and MVar (sort of)
02:11:57 <quchen> Aaaah right, reading a TVar won't empty it
02:12:35 <arkeet> well, you can read a (T)MVar without emptying it.
02:12:45 <ski_> (hm, `SampleVar' ?)
02:13:05 <arkeet> isn't that just a TMVar with slightly different behaviour?
02:13:16 <arkeet> er, MVar
02:13:37 <quchen> arkeet: An MVar?
02:13:46 <quchen> Isn't that non-atomic?
02:13:52 <feliperosa> @hackage Data.Map.Strict
02:13:53 <arkeet> yes, this isn't a STM thing.
02:15:42 <quchen> feliperosa: Lambdabot packed its bags 3 hours ago
02:15:52 <c-ab> I'll try to do equivalent of http://en.wikipedia.org/wiki/Concurrent_Haskell in MVar
02:15:56 <c-ab> and benchmark them
02:15:59 <arkeet> the command wouldn't have worked anyway.
02:16:19 <c-ab> #final example
02:17:22 <c-ab> do you think it is possible to model a bank transfer with Chan/TChan?
02:17:45 <feliperosa> quchen: Oh, why?
02:17:57 <intelInquiery> Does anyone here have some experience with liquidhaskell
02:19:23 <nimish> c-ab: probably. I suspect tchan does something similar to double entry bookkeeping internally
02:20:16 <c-ab> nimish: maybe, but then, I don't where I'd store the bank account
02:20:31 <c-ab> that was store in a newTVarIO
02:22:07 <nimish> c-ab: you could store the accounts in separate tvars and modify them in a single atomic block
02:23:46 <quchen> feliperosa: No idea. It's just not here right no.
02:24:20 <feliperosa> quchen: :(
02:24:31 <feliperosa> Damn I can't get rid of a memory leak
02:26:00 <c-ab> nimish: isn't that what's done at the end of http://en.wikipedia.org/wiki/Concurrent_Haskell?
02:26:39 <nimish> c-ab: pretty much
02:31:23 * hackagebot xsd 0.3.4.1 - XML Schema data structures  http://hackage.haskell.org/package/xsd-0.3.4.1 (StefanWehr)
02:41:44 <mm_freak> what's a semigroup with inverses called?
02:41:58 <mm_freak> (no identity required)
02:42:43 <mm_freak> in other words, what do you call a structure, which, when identity added, becomes a group?
02:43:23 <shachaf> What's an inverse?
02:44:07 <ski_> mm_freak : quasigroup ?
02:44:16 <mm_freak> ski_: associativity required
02:44:26 <ski_> hm
02:44:27 <Dodek> mm_freak: there's no such object
02:44:32 <quicksilver> what does it mean to have inverses without an identity?
02:44:40 <quicksilver> what is the value of a . a^-1 then ?
02:44:51 <quicksilver> perhaps you mean left + right cancellation but not inverses.
02:44:51 <Dodek> mm_freak: well, only empty set satisfies your condition.
02:44:53 <shachaf> My question was meant to be an abbreviated version of quicksilver's. :-)
02:45:07 <mm_freak> you could define them like this:  x + (-x) + y = y
02:45:15 <ski_> quicksilver : inverse properties, `forall a. exists b. forall c. a * (b * c) = c', &c.
02:45:28 <quicksilver> mm_freak: yes, but x + (-x) must exist.
02:45:32 <shachaf> mm_freak: Doesn't that make x + (-x) an identity?
02:45:33 <mm_freak> you could define them like this:  x + (-x) + y = (-x) + x + y = y + x + (-x) = y + (-x) + x = … = y
02:45:36 <quicksilver> mm_freak: and you will find it must be an identity ;)
02:45:45 <shachaf> When you don't have identities, you can still sometimes talk about "division" rather than inverses.
02:45:46 <mm_freak> hmm
02:45:48 <ski_> (iow that `(a *)' has inverse `(b *)', &c.)
02:45:51 <shachaf> That's what you do with quasigroups, after all.
02:46:11 <mm_freak> yes, you're right, it doesn't really make sense…
02:46:33 * ski_ thinks mm_freak really want Moufang laws or something, instead of associativity
02:46:33 <shachaf> But at any rate you need to explain what you mean by inverse before the question can be answered.
02:46:37 <mm_freak> my point is:  i want two classes, one with everything from Group except identity and a second class Group that adds the missing identity
02:47:06 <mm_freak> currently i'm calling the first one Semigroup, but that's not really sensible, because it has 'invert'
02:47:36 <shachaf> Why do you want those classes?
02:47:51 * ski_ . o O ( <http://en.wikipedia.org/wiki/Moufang_loop> )
02:48:11 <mm_freak> for technical/efficiency reasons…  identity is very difficult and requires a runtime dictionary, while the other class can be optimized easily
02:48:27 <ski_> shachaf : how about the inverse properties ?
02:48:57 <mm_freak> Quasigroup may be misleading, because i do in fact require associtativty
02:49:00 <mm_freak> +i
02:49:27 <shachaf> ski_: Sure. If you take a Moufang quasigroup or something, that could be reasonable.
02:49:36 <ski_> mm_freak : do you need general associativity ?
02:49:41 <shachaf> But this was the reason I originally asked mm_freak what an inverse is.
02:49:44 <intelInquiery> mm_freak: What is wrong with defining the identity element to be x + (-x) ?
02:50:26 <mm_freak> intelInquiery: i already said, i asked for something that doesn't exist =)
02:50:34 <mm_freak> what i really need is AlmostGroup for technical reasons
02:50:39 <mm_freak> that's Group without identity
02:50:59 <intelInquiery> mm_freak: ahh ok
02:51:01 <shachaf> What if you used a weakened identity, like data-category does?
02:51:21 <shachaf> Something like class Foo a where identity :: a -> a
02:51:29 <mm_freak> ski_: not sure…  i can't assess the consequence of not having full associativity right now
02:51:30 <shachaf> I guess that doesn't really make sense in that context.
02:51:34 * ski_ . o O ( <http://en.wikipedia.org/wiki/Quasigroup#Inverse_properties> )
02:51:56 <mm_freak> shachaf: it's not necessary…  once the identity is there, it's certainly a group
02:52:24 <mm_freak> well, it's there all the time, but you know what i mean
02:52:36 <mm_freak> i guess i'll call this Group'
02:52:46 * ski_ . o O ( <http://en.wikipedia.org/wiki/Cancellation_property#Examples_of_cancellative_monoids_and_semigroups> )
02:52:46 <mm_freak> it's a group after all =)
02:53:37 <shachaf> mm_freak: The function I suggested makes more sense in data-category's use.
02:53:52 <shachaf> It has class Category p where dom :: p a b -> p a a; cod :: p a b -> p b b; (.) :: ...
02:53:53 * ski_ . o O ( "Regroup" )
02:54:06 <shachaf> So that you can't get an identity out of nowhere -- you have to have a morphism that involves it, first.
02:54:31 <ski_> hm, partial identities
02:54:51 <shachaf> ski_: id :: p a a is too strong, since it requires you to have an object for every possible Haskell type.
02:55:32 <feliperosa> does "map id" forces the evaluation of list contructors (:)?
02:55:33 <ski_> shachaf : ooi, why is it too strong ?
02:55:55 <mm_freak> interesting, but it doesn't really make sense for my use case
02:56:00 <ski_> feliperosa : only when the list constructors of the resulting list are forced
02:56:02 <shachaf> ski_: Well, you might have a category with only one object.
02:56:19 <mm_freak> i'll go with Group' and Group for now…  until release i have enough time to come up with a better name =)
02:56:38 <ski_> mm_freak : "Regroup"
02:57:22 <feliperosa> ski_: What do you mean?
02:57:33 <feliperosa> ski_: Ohhh, I think I get it
02:57:51 <ski_> feliperosa : when the constructors of `map if as' are forced, the constructors of `as' will also be forced
02:57:58 <shachaf> feliperosa: map id x = x
02:58:18 <shachaf> Even strictness-wise. :-)
02:58:35 <ski_> feliperosa : try `foldr (\a !as -> a:as) []'
02:59:22 <shachaf> foldr may not be the best function when you do that, though.
03:00:04 <feliperosa> well, is there a right way?
03:00:07 <feliperosa> seq?
03:00:24 <ski_> i suppose not building a new list could be nicer
03:00:39 <frihd> hi, has anyone an idea of what it would take to cross-compile to ARM with GHC? compiling on the raspberry pi is slow :'(
03:00:50 <shachaf> feliperosa: What are you actually trying to do here?
03:01:24 * hackagebot xsd 0.3.7 - XML Schema data structures  http://hackage.haskell.org/package/xsd-0.3.7 (StefanWehr)
03:01:40 --- topic: '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.2 http://v.gd/oXnqjU ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","If Hackage is down, try: http://hdiff.luite.com "]'
03:01:40 --- topic: set by monochrom on [Tue Jan 29 09:36:42 2013]
03:01:40 --- names: list (clog milessabin peterhil` Itkovian dcoutts_ Rarrikins_k janinge neutrino hpd boegel Jaxan dschoepe end3rW yewton tanakh_ m0g gehmehgeh Icewing janbanan morazow lennart_ arpunk intelInquiery nimish jesyspa av hiptobecubic [[zz]] trevize aCube feliperosa hamilyon Thomyho3 xunatai plcplc schlicht_ pakchoi2 c-ab ozgura hamid `ramses bitonic gienah owst hesselink HugoDaniel juhp mokus heruur charliesome yacks MrWoohoo duosrx shanem Lethalman Jeanne-Kamikaze guampa)
03:01:40 --- names: list (ptrf doomlord pilf Paprikachu mugenken ramkrsna sh hkBst quchen schovi niklasb hamishmack randomclown ninegrid k00mi msuszczy Chousuke dawe typoclass piotr_ basdirks raichoo ctype_real snoyberg frihd phischu ccxCZ silver apaku edon edsko itemad mceier JaRoel|4d shurikas _just otend m3ga bmk OlegYch eldariof blueonyx EarlGray^ Beetny mikeplus64 ajhager SeanTAllen krzysz00 mflamer jang dreixel ThomasLocke path[l] killy9999 AfC xinming croys srhb sprang osa1)
03:01:40 --- names: list (savonarola Sebastien-L shintah odi cdidd RayNbow`TU issimus1 sopvop fizbin2 dan_johnsin kerrick Hermit Cale Psycho_pr folone` jaimef_ ivan\ geisthaus Boney_ travitch Raynes iulian_ affixator codertux_ malorie_ etrepum mauke perlite Jesin edwardk cads fgomez tvynr nexx jaroslaw joneshf-laptop gwern TheInfosphere preflex mdhopkins gentleben otto_s_ helgikrs ivanm anona Nickeeh kennyd jonaias weie niloc132 c_wraith Necrophrenic s_quark sclv warpy__ mattrepl parcs)
03:01:40 --- names: list (brisbin qcfbxlduowfbp aoeu2code sanemat sepp2k bergey hattusili_III ISF pxdr Gunni yc4891 mikurubeam hajimeho_ copumpkin predator117 Twisol azaq23 chemist bbloom dolio augur accelas peterhil wei2912 Bwild waterlaz tim1 tomboy64 ericmj glguy sm cl_away hackagebot saep whoops ccasin stepkut identity frio jedai Targen akosch ktosiek bradleyayers Counter-Strike sellout- Eiam merijn Swizec pauser jdhky gbeshers carlocci KorriX vmeson u_quark xplat alnix kadoban)
03:01:40 --- names: list (madhatte1 _br_ threesome Drutten lemao rodlogic perspectival otters ndngvr Ornedan sShintah DrCode junsuijin aavogt amiller rmarianski Amadiro bytbox nwf astor Guest90064 hiato FalkoPeters Luke ski_ jaspervdj dmarker julmae techlife solirc kqr thetallguy1 jdoliner vehk raek MK_FG mortberg quicksilver anachron_ tdammers kloeri dmwit DrSyzygy matzo_ `0660_ wto_ Nimatek C-Keen LAMMJohn1on Tene Botje Martty_ Ke lokydor_ Dybber alios sabalaba1 nighty-_ tg)
03:01:40 --- names: list (Internet13 jacobw DexterLB Estrellas blooberr fionnan imeredith Saizan ChongLi bartavelle ceii moonlite tensorpudding peltchu jonke stianhj ivan` julmuri tromp_ totte machisuji hirsch__ jtalk ketil yano Igloo davorak alshain reiddraper gthorslund smilefreak lazard hiratara dsantiago Boreeas dottedmag mike2 raid Gothmog_ adnauseam tamiko _flow_ luite mm_freak BMeph ps-auxw wollw dented42 alexander__b canta fran Baughn rsimoes Twey monochrom araujo Ralith sunfun)
03:01:40 --- names: list (Tesseraction_p Athas dennda_ b52 Ptival tavelram_ arlinius bapa_ _so gbarboza lpvb latro`a bbee sykora kryft oitnelis mike_pizza benzap bcoppens ernst ParahSailin ClaudiusMaximus harrison joe9 smarter nilg fxrh nicoo melter lusory ptek bentham stelleg_away tanakh Jello_Raptor gcmalloc DigitalKiwi niko Sgeo def-lkb gal_bolle DT` aib inr dogmaT birkenfeld hvr VZakharov CoverSlide theorbtwo xymox Sagi f8_ chrra ion CindyLinz drmegahertz tafryn noj mateu supki)
03:01:40 --- names: list (Draggor KitB_ mimico__ sixohsix joneshf mcsmash chirpsalot mendez jix arun lulf koala_man arnihr_ charlesofarrell rcl Starfire bobry knyppeldynan eacameron thirsteh bgamari mirsal purefn hayashi cyphase shanse mtao mrdomino franny jackhill ]OLI[ qwandor dcoutts heath numeral obcode mlh Fuuzetsu Zariel shergill kith HaltingState vili flux KaiSforza thetallguy lispy fattrat k0ral ggreg tessier Excureo myf Nanar cjay davean smithburg16 Jonno_FTW cross Khisanth)
03:01:40 --- names: list (r126l pikhq eyck brandonw Xorlev Will| cow-orker setmeaway flebron_ asante dju ParahSailin_ tswett krig tgeeky zxq9 ab9rf Nisstyre BrianHV tieTYT2 albel727 anders^^ drek joar fergusnoble mimi_vx Fuco mattp_ noam tew88 zenoli Fubar^ betawaffle aszlig verrens mux redjohn kalizga jssanders faybot Brando753 shachaf faen ZWolf kalven LeninParty caligula__ isenmann colah tomh hungryblank si14 lopex strax akraut wilfredh Adios Tarential ToRA Volstvok whaletechno)
03:01:40 --- names: list (muqayil UziMonkey chrisbuchholz_ rs0 arkx pfoetchen elliott endojelly mietek aninhumer descender stepcut leroux wjlroe mel- herself MrMeh Mortchek Mathnerd314 Cerise `bps tomprince AntiSpamMeta WhereIsMySpoon nikolah alkabetz henk tweakism jml dfletcher fireglow andrewsw koninkje_away SolidResolve levitation[A] em linduxed tsinnema jbauman Deewiant saati tomku jlamothe mrkotfw dabradley appamatto mpu gdsx schroedinbug kniu PartyKatze Gurragchaa plhk majoh)
03:01:40 --- names: list (CosmicRay statusfailed barrucadu JoshuaA liyang mrshoe TDJACR `nand` Soft fabjan snorble_ wolong thoughtpolice bxc kaol noplamodo_ celery_ listofoptions tobiassjosten tridactyla Yolarina maksbotan pnielsen rio tomaw Maxdamantus dqd earthy tgummerer ziman certainty canvon integral Obfuscate ousado arthur_honeynet prh Xeross jcp tahu s4msung lenstr McManiaC zorzar mahrz kennyp justdit KaneTW arkeet dougransom2 wting acharles __main__ jyyou sordina Kuba FireFly)
03:01:40 --- names: list (dixie voyd hive-mind gdeest Derander puzza007 Tehnix formalcow Nanuq nlogax ido \rs ofan drewr Guest34021 arbn EvanR xrl jodaro PrO_OkI Ghoul_ liesen akahn wumpus augustl OnionKnight int-e wereHamster Valodim pharaun hyko gemelen kosmikus Entroacceptor rcj_ Razz froztbyte dflemstr peddie ghorn pettter sohum alpounet joeyh tunixman minsa Tordek LeaChim Nik_89 geekosaur levi xcvii SLi lpsmith Gracenotes wchun robbert Guest22595 bezik ent mullein kshannon fayden)
03:01:40 --- names: list (crdueck rcfox cpa ezyang danr SegFaultAX pdxleif_away drbean hpc d0rc yezariaely schlumpi magicman Guest10329 luminous newsham sproingie td123 mixi jtobin eataix Axman6 aforemny aleator jrslepak nimred jmcarthur frontendloader monique_ Belgarion0 dario zomg kini kakos acfoltzer nonymousa steez Eridius matthavener idnar honza mmaruseacph2 mefisto moben ique hiredman ehamberg Megant tkd Vorpal eL_Bart0 finnrobi joeytwiddle b_jonas Eelis etabot Dodek edwtjo)
03:01:40 --- names: list (lembaswafer magaio thorkilnaur prophile sajith vhz ibid Javafant edenc Draconx brainproxy sheerun_ jlewis hiroyuki2 yumike_ tmiw shrimpx knz bogner JoeHazzers alang fotc otterdam flori PHO_ tvaalen ortmage Cryovat neurocyte ft myme1 Eliel_ shepheb Bigcheese deavidsedice SHODAN Jaak freiksenet guymann petekaz maltin vobi AtnNn adnap jercos qwr lightquake alcz saiam jimki netj simpson ahf Urchin norm2782 mjr84 elliottcable zenzike deggis companion_cube mami)
03:01:40 --- names: list (XMunkki sunnavy popx_ mollerstrand Zzompp ninzine wtw cmsd2 nathanel_ felipe_ jrib dyreshark klugez plat0 cajla Laney bens sjl fryguybob wagle adimit gereedy zerowidth liff mjrosenb confound wunki pr liszt pyrtsa Clint lahwran cods mornfall Canar jayne skp aristid ahihi sirchurchill robbe- @ChanServ kkris petantik natte ethercrow hanDerPeder marienz othiym23 threedaymonk simon__ zaphar_ps johnw jamwt Fluky stephe rmunroe sgronblo Shapeshifter yeltzooo)
03:01:40 --- names: list (ByronJohnson horlicks rfw boyscared sulaco Gilly bd_ brixen KitB brett xaimus so sgso mdf MetaCosm BlastHardcheese Dashkal chance arcatan jabirali n_b jrockway Jean chr1s ricepuddin TML ahkurtz seats munro ciaranm yam `micro fuho mzarella pigoz zeiris simply-chris rntz idoru DustyDingo suiside byorgey Rembane faheem jerojasro d-snp dilinger The_third_man mechairoi kmicu MasseR mvj4_ cynick bstrie guerrill1 mrd sully absence banjiewen pqmodn Iceland_jack)
03:01:40 --- names: list (scgilardi x7 smash dinox gseitz rainmaker mahogny Liskni_si fall_ opqdonut kobsu tazjin_ mlinksva Kinnison milli solarus Vq Adeon dumbhat petanqk shutdown_-h_now ormaaj electrogeek bholst Plex- notdan qz pyykkis Ulrar epta kranius yan_ Nshag edwinb _janne xnyhps hpaste Spockz ocharles agundry Varakh blackmirroxx osfameron jlouis a11235_ Jonte saurik rhodesd jliikka Natch taruti sipa elgot Erstarrung)
03:01:41 <feliperosa> shachaf: I'm trying to remove a memory leak that I think (by doing some profiling) comes from unevaluated list constructors
03:02:18 <ski_> shachaf : you saw the proof of `mapM return as = return as', for finite lists `as' ?
03:03:16 <frihd> I've installed ghc via haskell platform, so i don't know how much effort it takes to just compile a ghc. on a scale from 0 (easy) to 10 (hell), how hard is it to compile build GHC for a first time?
03:03:17 <shachaf> feliperosa: I suspect you're hunting the problem in the wrong place.
03:03:46 <shachaf> At least, that's usually my conclusion by the time people trying to force a structure. :-)
03:04:08 <shachaf> ski_: No, but it sounds straightforward enough, I think?
03:04:10 <kranius> frihd: it's kinda straightforward, takes a while though
03:04:15 <shachaf> What's the context?
03:04:48 <ski_> shachaf : now consider `as <- hGetContents h' (for `h' referring to a finite file)
03:05:18 <feliperosa> shachaf: Why do you say that? What would be the alternative way?
03:05:21 <hpaste> pauser pasted “title” at http://hpaste.org/83278
03:05:39 <shachaf> Sure, hGetContents can cause problems.
03:06:01 <pauser> hi, how do i make my function a->Bool work for Trees ?
03:06:07 <shachaf> feliperosa: I recommend adding an ! before the "x" on line 119.
03:06:15 <shachaf> feliperosa: (I have no idea. :-) )
03:06:39 <ski_> i just thought it an interesting illumination of `hGetContents'
03:07:03 <frihd> thanks kranius i'll have a look when I find a large-enough time slot then :)
03:10:01 <shachaf> ski_: Well, which monad are you talking about for the mapM?
03:10:10 <shachaf> (Is this new _ permanent?)
03:10:58 <pauser> sry for the bad question. Here http://hpaste.org/83278 i have a function filter what filters the Tree elements , but i does not what i want to . f.e. filtert (<2) (Node 1 (Node 2 Leer Leer) Leer) gives me [Node 1 (Node 2 Leer Leer) Leer]. And how do i make (a-> Bool) work for my tree ?
03:12:17 <shachaf> pauser: You've said what it does, and that it doesn't do what you want to.
03:12:21 <shachaf> You haven't said what you want to.
03:13:15 <pauser> shachaf: what do you mean ?
03:13:17 <neurocyte> frihd, check out http://hackage.haskell.org/trac/ghc/wiki/Building/Preparation/RaspberryPi
03:13:41 <beaky> hello
03:13:44 <shachaf> pauser: You haven't said what's wrong.
03:13:50 <neurocyte> frihd, it takes about 20 minutes to build a GHC cross compiler here
03:14:11 <frihd> great neurocyte, thanks I'll check that
03:14:12 <neurocyte> that is build time though, not the time it takes to figure out *how* to build a cross compiler :)
03:14:33 <pauser> shachaf: filtert (<2) should give me just [Node 1 Leer Leer] and not the tree with nr 2 !
03:14:40 <frihd> ah , damn, it looked *too* easy
03:14:56 <shachaf> pauser: Oh. Why?
03:15:11 <shachaf> What is filtert (<2) (Node 1 (Node 0 Leer Leer) Leer)?
03:15:28 <frihd> I've done some embedded dev before, but that was 4years ago :o, and I have had bad experience with building a toolchain
03:15:32 <neurocyte> frihd, you might want to look around to see if someone has published a script to do it automatically
03:15:53 <neurocyte> I’ve made a build script for android cross compilers, but not rpi
03:15:54 <frihd> neurocyte: I know how I'll spend my WE :)
03:16:04 <pauser> shachaf: [Node 1 (Node 0 Leer Leer) Leer,Node 0 Leer Leer]
03:16:08 <frihd> then if it works, i'll publish the script
03:16:08 <c-ab> > getNumProcessors
03:16:12 <ski_> shachaf : for the law, any monad. for the `hGetContents' case, just `IO'
03:16:24 * hackagebot hscope 0.2.2 - cscope like browser for Haskell code  http://hackage.haskell.org/package/hscope-0.2.2 (BorisSukholitko)
03:16:29 <neurocyte> here is the android one https://github.com/neurocyte/ghc-android
03:16:39 <neurocyte> rpi is quite a bit simpler though
03:16:42 <shachaf> pauser: How about filter (<2) (Node 1 (Node 0 Leer Leer) (Node 2 Leer Leer))?
03:16:54 <c-ab> > print "you there?"
03:17:01 <beaky> anyone wanna help me debug my program? I tried to implement minimax but it is not working :(
03:17:38 <ski_> c-ab : lambdabot is on a picnic
03:17:40 <beaky> also, it is quite inefficient
03:17:51 <hpaste> pauser annotated “title” with “title (annotation)” at http://hpaste.org/83278#a83279
03:18:04 <frihd> thanks neurocyte i'll watch that, I've just starred it
03:18:11 <pauser> shachaf: i pasted it !
03:18:46 <shachaf> ski_: hGetContents surely violates even simpler laws.
03:18:50 <beaky> http://ideone.com/sViEiC here is my program :D
03:18:55 <shachaf> pauser: You seem confused.
03:18:58 <ski_> shachaf : which do you have in mind ?
03:19:14 <shachaf> pauser: Oh well, I don't know.
03:19:23 <mm_freak> instance (D x A) => C (T x)  -- why is this undecidable?!
03:20:04 <shachaf> Not in scope: D, A, C, T
03:20:11 <mm_freak> instance (D x a, a ~ A) => C (T x a)  -- this one works
03:20:16 <ski_> mm_freak : how is it supposed to know you don't have (effectively) `instance C (T x) => D x A' (or something similar) ?
03:20:25 <pauser> shachaf: well i know why , but i dont know how to solve it. its because a type is not defined !
03:20:42 <mm_freak> ski_: i see
03:21:11 <mm_freak> if i certainly don't have that, is this safe?
03:21:33 <beaky> why is haskell more powerful than other programming languages in the hands of the right programmer?
03:22:05 <ski_> afaiu, `UndecidableInstances' can only ever be unsafe in the sense of the instance resolution (at compile-time) not terminating
03:22:20 <ski_> if you're sure it'll not run into loops, go ahead ?
03:22:30 <mm_freak> fair enough
03:22:48 <mm_freak> still having to use UndecidableInstances feels ugly =/
03:22:55 <bitonic> you won’t have GHC loop forever anyway.  if it loops you’ll realise because of the boredom check
03:23:05 <bitonic> but yes it’s ugly to have a turing complete typeclass resolution
03:23:06 <ski_> probably better to restrict `UndecidableInstances' to a small module
03:23:23 <sordina> Hey. Has anyone been having issues with httpSimple in http-conduit? I try to run the example, but I get a FailedConnectionException:
03:23:25 <sordina> [*Main] λ simpleHttp "http://www.haskell.org/"
03:23:26 <bitonic> I usually do what ski_ said
03:23:27 <mm_freak> ski_: i do that anyway…  i might also just add the type variable
03:23:27 <sordina> *** Exception: FailedConnectionException "www.haskell.org" 80
03:23:30 <mm_freak> but the hack feels even worse
03:23:46 <mm_freak> instance (D x a) => C (T x a)
03:23:52 <mm_freak> no
03:23:58 <mm_freak> instance (D x a, a ~ Integer) => C (T x a)
03:24:00 <mm_freak> in this case
03:24:12 <mm_freak> and as you might have guessed D = Reifies =)
03:25:02 <mm_freak> it feels so stupid to introduce a type variable when you know that it's only ever going to be Integer
03:25:31 <shachaf> Well, it happens in lots of other places too.
03:28:58 <HugoDaniel> i like bazqux reader
03:29:20 <HugoDaniel> they have some haskell stuff running in there
03:29:38 <HugoDaniel> its a commercial rss feed reader in haskell
03:32:06 <av> Hi, I'm stuck and need some help
03:32:17 <srhb> av: Ask your question.
03:33:31 <av> I have a type:    newtype Command m r = Command { run :: M -> (r -> m r) -> m M }
03:33:58 <av> M is a container I use for storing a state
03:34:21 <av> this all works very well, but I'm now trying to make "Command" an instance of Monad
03:34:38 <av> and I can't figure out how to define ">>="
03:34:46 <av> the closest I've come is this:
03:34:49 <arkeet> you can't, at least not for arbitrary m.
03:34:58 <shachaf> m would have to be contravariant.
03:35:03 <arkeet> indeed.
03:35:03 <av> bindC c g = Command $ \m f -> run c m $ \r -> run (g r) m f
03:35:32 <arkeet> start by defining return.
03:36:02 <shachaf> No, start by defining fmap. :-)
03:36:09 <arkeet> both.
03:36:22 <shachaf> fmap is the best because there's only one definition.
03:37:01 <arkeet> well, at most one.
03:37:09 * av 's head is smoking
03:37:35 <arkeet> every Monad is (can be made) a Functor, so you should try making it a Functor first
03:37:41 <av> arkeet: so by replacing m by IO I would be OK?
03:37:51 <shachaf> No.
03:37:53 <arkeet> no.
03:37:56 <arkeet> that definitely won't work.
03:38:01 <shachaf> It is impossible.
03:38:11 <shachaf> I suggest taking a step back and figuring out what you're actually trying to do.
03:38:23 <shachaf> Alternatively: Learn about covariant and contravariance and why this is definitely impossible.
03:38:35 <shachaf> It'd be good and educational but may not directly help you solve your problem. :-)
03:38:46 <supki> (you can't define fmap for that type?)
03:39:03 <av> shachaf: I'm trying to learn, do you have any pointers to literature?
03:39:18 * shachaf points at arkeet's pointer finger.
03:39:45 <beaky> there are some good haskell books out there
03:40:10 <srhb> On this topic? Really?
03:40:10 <shachaf> Unfortunately there are not.
03:40:17 <teneen> In a a cabal project hierarchy, how can you load a file which imports another file, in another folder, into ghci?
03:40:18 <srhb> No, I didn't think so.
03:40:38 <shachaf> srhb: are there any good papers out there
03:40:51 <srhb> shachaf: Maybe. You'll have to look to find out!
03:41:10 <hpaste> Peaker pasted “Why is inTree's result not fully evaluated?” at http://hpaste.org/83280
03:41:37 <Peaker> strictNode should be returning fully (deeply) evaluated values
03:41:48 <Peaker> and inTree only returns what strictNode does
03:41:49 <srhb> The spine is evaluated, but why the values?
03:41:55 <srhb> Oh, there's a bang there
03:42:00 <av> shachaf, arkeet: so you're saying that I should read up on covariance and contravariance but say that there is nowhere to look that up? :)
03:42:01 <teneen> Is there a way for ghci to recognize the project's hierarchy?
03:42:19 <srhb> av: Welcome to #haskell!
03:42:21 <srhb> ;p
03:42:30 <shachaf> av: No, there are places. I just don't know what they are.
03:42:41 <dcoutts_> teneen: you can use the -i flag to ghc/ghci to set the source search path
03:42:44 <av> shachaf: OK, will take a look
03:43:05 <teneen> dcoutts_: and it will search recursively?
03:43:19 <dcoutts_> teneen: no, it's a simple search path
03:43:30 <shachaf> av: In general, when you have "F a", that might be a type of things that "produce" a, or "consume" a.
03:43:46 <shachaf> For example, [a], IO a, Maybe a, Cont r a, etc. all "produce" a.
03:44:02 <shachaf> data Predicate a = Predicate (a -> Bool) "consumes" a
03:44:04 <dcoutts_> teneen: e.g. if you have module Foo.Bar, and a search path of -i.:a then it will look in ./Foo/Bar.hs and a/Foo/Bar.hs
03:44:18 <srhb> Peaker: I'm not an expert here, but is the problem not that you're only evaluating up until the Node constructor?
03:44:47 <srhb> Peaker: And does forcelist even work?
03:45:04 <Stephanie_> hi
03:45:12 <srhb> The x is forced, but the tail isn't, is it?
03:45:16 <teneen> dcoutts_: For example, I'm using a module Control.W.X which imports Data.Y.Z, where W and Y are separate folders, can I specify a parent folder to search in recursively?
03:45:22 <Peaker> srhb, I found the problem and I think its a GHC bug
03:45:33 <srhb> Peaker: I see. Care to share?
03:45:40 <Peaker> forceList (x:xs) = x `seq` (x : forceList xs)  <-- this works.        forceList (!x:xs) = x : forceList xs <-- this is a stack overflow
03:45:58 <ski_> lo Stephanie_
03:45:58 <srhb> Weird.
03:45:58 <Peaker> Or maybe ! is parsed with lower precedence than (:) ?
03:46:17 <srhb> Easy to test that one at least
03:46:25 <Stephanie_> I can't understand a piece of code, can you help me?
03:46:27 <Peaker> ah, yeah!
03:46:28 <av> shachaf: so a type that both consumes and generates "a" is a bad idea?
03:46:30 <Peaker> (!x):...  works
03:46:39 <shachaf> av: It's fine. It's just not a Functor, or a Monad.
03:46:44 <srhb> Peaker: Funky :)
03:46:50 <shachaf> av: Every Functor/Monad/Comonad/etc. only "produces"
03:46:56 <Peaker> srhb, I burned many minutes on this one... heh
03:47:12 <av> shachaf: ah
03:47:23 <shachaf> Wait, so foo (!x:xs) means foo (!(x:xs))?
03:47:36 * ski_ thinks av's `Command' looks slightly lensy
03:47:42 <teneen> dcoutts_: should I use multiple '-i's ?
03:47:59 <srhb> shachaf: Apparently.
03:48:01 * arkeet thinks it looks vaguely like (>>=)
03:48:11 <dcoutts_> teneen: you can use -ifoo -ibar or -ifoo:bar, it's the same thing
03:48:14 <shachaf> av: If "F a" produces "a", then you can write: (a -> b) -> F a -> F b
03:48:22 <shachaf> av: If "F a" consumes "a", then you can write: (a -> b) -> F b -> F a
03:48:31 <teneen> dcoutts_: Ok, I see, thanks!
03:48:46 <ski_> if `F a' neither produces or consumes `a', then you can write `F a -> F b'
03:48:54 <ski_> s/or/nor/
03:49:06 <shachaf> If it does both, then you can write (a -> b) -> (b -> a) -> F a -> F b
03:49:11 <arkeet> I don't like this "produces/consumes" wording.
03:49:13 <dcoutts_> teneen: don't you have folders Control and Data? that's where ghc will be looking
03:49:27 <shachaf> arkeet: No?
03:49:45 <dcoutts_> teneen: if you module is called Control.W.X, then ghc will look for Control/W/X.hs (in some dir in the search path)
03:49:56 <ski_> arkeet : better to talk about opposite categories ?
03:50:03 <av> shachaf: I think my mistake was to take attoparsec as an example -- I was looking at the definition of Parser there
03:50:58 <shachaf> Note that some Fs are so magic that you can't even write (a -> b) -> (b -> a) -> F a -> F b
03:51:23 <shachaf> But only weird types.
03:51:24 <teneen> dcoutts_: Ok, this is what I was looking for.
03:51:29 <Kinnison> attoparsec is pretty special
03:51:37 <ski_> `CoYoneda' ftw !
03:51:52 <shachaf> Hmm, what's CoYoneda (Is A)?
03:52:11 <Peaker> shachaf, surprising precedence, isn't it?
03:52:38 <av> shachaf: so my goal is to get rid of the "consumed" M in the type, and make it a parameter to the definition I use for constructing a Command -- does that sound right?
03:52:44 <Peaker> Should issue a warning "strictness annotation on pattern matched constructor has no effect"
03:52:56 <srhb> I honestly still don't understand why it works.
03:53:10 <srhb> When head is evaluated it looks to me like the rhs of : is still left unevaluated
03:53:18 <shachaf> Why what works?
03:53:22 <ski_> `CoYoneda f b' is `exists a. (f a,a -> b)', so `CoYoneda (Is A)' presumably is `exists a. (Is A a,a -> A)'
03:53:35 <srhb> forceList ((!x):xs) = x : forcelist xs
03:53:38 <ski_> (what's `Is' ?)
03:53:44 <shachaf> ski_: Type equality.
03:53:51 <shachaf> So it's Endo, I guess.
03:53:55 <ski_> leibniz or refl ?
03:54:10 <shachaf> data Is a b where Refl :: Is a a
03:54:29 <shachaf> (Does it make a difference?)
03:54:30 <ski_> ok, so then it's apparently `A -> A'
03:54:33 <shachaf> Yes.
03:55:12 <ski_> shachaf : iirc, it's hard to write `Leibniz (a0,b0) (a1,b1) -> (Leibniz a0 a1,Leibniz b0 b1)'
03:55:23 <srhb> let forceList (x:xs) = x `seq` (x : forceList xs); forceList [] = [] in head $ forceList [1,undefined]
03:55:28 <srhb> > let forceList (x:xs) = x `seq` (x : forceList xs); forceList [] = [] in head $ forceList [1,undefined]
03:55:35 <shachaf> lambdabot's dead anyway
03:55:36 <Peaker> srhb, the rhs is evaluated via the "forceList"
03:55:39 <srhb> Oh. :<
03:55:52 <srhb> For good?
03:55:57 <shachaf> For now.
03:56:01 <shachaf> Anyway, that doesn't force the entire list.
03:56:05 <ski_> she went for a picnic, she'll be back
03:56:08 <srhb> I didn't think so
03:56:19 <Peaker> why not? it does force the entire list?
03:56:20 * ski_ . o O ( at Hanging Rock )
03:56:21 <arkeet> let f (x:xs) = x `seq` f xs `seq` x:xs
03:56:21 <srhb> Hence: I do not understand why it works
03:56:43 <shachaf> Peaker: Maybe we mean different things here.
03:56:47 <Peaker> the pattern matches force the spine, and the seq's force the values
03:56:48 <av> shachaf: so my goal is to get rid of the "consumed" M in the type, and make it a parameter to the definition I use for constructing a Command -- does that sound right?
03:57:03 <shachaf> Forcing (forceList l) will only force one element and a cons cell.
03:57:05 <srhb> Why would the spine be forced?
03:57:07 <srhb> Yeah indeed
03:57:18 <shachaf> Forcing (length (forceList l)) will force the entire list, spine and (WHNF) values.
03:57:21 <shachaf> av: I don't know. :-)
03:57:32 <shachaf> av: Maybe I'm just giving you misleading intuition.
03:57:35 <srhb> Hurray, I'm getting smartser.
03:57:39 <av> shachaf: OK, I'll play around a bit more
03:57:49 <shachaf> srhb: I bet it's from reading that STG paper!
03:57:55 <av> shachaf: I think you've been of great help
03:57:57 <srhb> That's probably not even a lie.
03:58:03 <Peaker> srhb, shachaf oops, yeah, the (:) hides the forcing of the rest of the list there
03:58:22 <ski_> hmm .. if `m' is contravariant, then `Command m' is actually covariant
03:58:27 <av> Thanks blokes (and gals?)
03:58:47 <ski_> you're welcome
03:58:48 <srhb> Peaker: yeah :)
03:58:49 <Peaker> forceList ((!x):xs) = (x :) $! forceList xs
03:58:58 <srhb> Doesn't help, does it?
03:58:59 <shachaf> You might want something like force (x:xs) = y:ys where !y = !x; !ys = force ys
03:59:07 <shachaf> Er.
03:59:09 <shachaf> !y = x
03:59:24 <arkeet> didn't I write that?
03:59:39 <arkeet> (with seq)
03:59:40 <shachaf> Maybe.
03:59:47 <arkeet> f (x:xs) = x `seq` f xs `seq` x:xs
03:59:47 <shachaf> arkeet: What you wrote just forces xs
03:59:51 <shachaf> You want to force f xs
04:00:11 <arkeet> this doesn't?
04:00:13 <Peaker> what isn't forced in the last one I wrote?
04:00:29 <shachaf> Peaker: The last one you wrote looks OK to me.
04:00:36 <Peaker> the result (:) has a forced x and a forced list in it
04:01:00 <shachaf> I think Control.Seq has a function for this anyway.
04:01:04 <Peaker> arkeet, I hate "seq" :)
04:01:11 <shachaf> seqList :: Strategy a -> Strategy [a]Source
04:01:11 <shachaf> Evaluate each element of a list according to the given strategy. This function is a specialisation of seqFoldable to lists.
04:01:17 <arkeet> spoiler: using ! is the same as using seq
04:01:32 <shachaf> arkeet: ?
04:02:53 <shachaf> blah `using` evalList rseq
04:02:55 <shachaf> Or something.
04:03:13 <arkeet> f !p = e  is the same as  f x = x `seq` let p = x in e
04:03:17 <arkeet> no?
04:03:18 * shachaf mumbles the usual disclaimer about forcing things at the right time.
04:03:30 <arkeet> er
04:03:32 <arkeet> sort of
04:03:49 <shachaf> I meant 03:59 <arkeet> this doesn't?
04:03:53 <shachaf> Ugh, 03:59?
04:03:59 <arkeet> 04:03?
04:04:08 <shachaf> goto sleep;
04:04:11 <arkeet> you need to come to the future.
04:04:13 <arkeet> and also to bed.
04:04:16 <arkeet> I mean go to bed.
04:04:48 <shachaf> arkeet: The past is better.
04:04:53 <shachaf> I could sleep 4 minutes and get to the future.
04:05:08 <shachaf> Whereas you're just stuck there.
04:05:14 <mm_freak>     showsPrec 0 (FG n x) = showsPrec 11 x . (" mod " ++) . showsPrec 11 n
04:05:15 <mm_freak>     showsPrec _ fg = ("(" ++) . showsPrec 0 fg . (")" ++)
04:05:19 <mm_freak> is this the correct way to do it?
04:05:28 <mm_freak> i'm having doubts about my application of (++)
04:06:01 <shachaf> That's the right use of (++) for DList/ShowS
04:06:02 <akamaus> hi, I'm in situation where module name collision between two packages took place. Namely, "Ambiguous module name `Data.Tree': it was found in multiple packages:  generic-tree-15329.2 containers-0.5.0.0" Is there a cure?
04:06:08 <danr> mm_freak: use showString
04:06:10 <shachaf> Text.Show has showString/showChar if you prefer to use those.
04:06:13 <shachaf> They do the same thing.
04:06:23 <mm_freak> ah, ok…  thanks
04:06:24 <arkeet> showString "(" . showsPrec 0 fg . showString ")"
04:06:33 <arkeet> ...or showChar
04:06:34 <shachaf> akamaus: Yes.
04:06:59 <ski_> mm_freak : precedence and fixity of `mod' ?
04:07:04 <akamaus> shachaf, any hints?
04:07:12 <mm_freak> ski_: no, it's actually "mod", not "`mod`"
04:07:19 <mm_freak> hence 11
04:07:29 <ski_> "hence" ?
04:07:45 <shachaf> akamaus: There's an extension. I don't know the exact syntax but https://encrypted.google.com/search?q=ghc+ambiguous+module+names seems to have it. :-)
04:07:49 <ski_> `10' is the (effective) precedence of function application
04:08:01 <shachaf> akamaus: (There are multiple solutions, in fact, depending on what you want to do.)
04:08:25 <ski_> mm_freak : what is the effective precedence and fixity you want for your `mod' ?
04:08:26 <shachaf> (I would prefer: Get rid of the non-containers package that takes Data.Tree. Because come on, Data.Tree?)
04:08:27 <mm_freak> ski_: it's not function application…  if you were to mix that, you would see rubbish like:  "Just 3 mod 4"
04:08:42 <mm_freak> ski_: the highest possible, because it's not haskell syntax
04:08:42 <ski_> (i didn't claim it's function application)
04:08:48 <shachaf> mm_freak: Oh, and you shouldn't add parentehses yourself.
04:09:04 <shachaf> I think. I don't even, like, know, and stuff, man.
04:09:25 <blueonyx> akamaus: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/syntax-extns.html#package-imports maybe?
04:09:32 <mm_freak> oh, there is showParen
04:09:34 <ski_> mm_freak : ok, so precedence at least `10' ? or `11' ?
04:09:37 <quicksilver> (parentheses are more (dangerous than people realise (some lisp programmers (have been (lost (for (years))))))
04:09:43 <mm_freak> actually quite useful, because then i don't need two clauses =)
04:10:06 <akamaus> shachaf, yeah, I've just looked at Data.Tree provided by containers, it would suit my needs. So I'll go that way.
04:10:27 <akamaus> blueonyx, thanks! WIll use it next time
04:11:11 * `nand` .oO( showString :: String -> String )
04:12:02 <ski_>   showsPrec p (FG n x) = showParen (p > 10) $ showsPrec 11 x . showString " mod " . showsPrec 11 n
04:12:16 <shachaf> `nand`: are you a super mega comics character!!
04:12:17 <ski_> corresponds to `mod' having precedence `10' and fixity `infix'
04:12:27 <mm_freak> showsPrec d (FG n x) = showParen (d > 0) (showsPrec 11 x . showString " mod " . showsPrec 11 n)
04:12:30 <mm_freak> great
04:12:35 * `nand` is confused
04:12:40 <mm_freak> didn't expect that writing proper Show instances is that easy =)
04:12:57 <ski_> mm_freak : if you want `infixl', use `11' on the left of `mod' -- if you want other precedence than `10', change accordingly
04:13:11 <shachaf> Next up: Read intances.
04:13:49 <mm_freak> ski_: yeah, i might need that for other instances i'm going to write
04:14:19 <mm_freak> although i doubt that fixity will be relevant
04:14:35 <ski_>   readsPrec p = readParen (p > 10) $ \s0 -> [ (FG n x,s) | (x,s1) <- readsPrec 11 s0 , ("mod",s2) <- lex s1 , (n,s) <- readsPrec 11 s2]
04:14:59 <ski_> mm_freak : sorry, s/if you want `infixl', use `11' on the left of `mod'/if you want `infixl', use `10' on the left of `mod'/
04:15:10 <ski_> (iow, the same as the precedence of the operator)
04:16:30 <ski_> mm_freak : anyway, i have to leave now
04:16:32 <ski_> hth
04:17:07 <mm_freak> thanks and see you
04:24:41 <hpaste> beaky pasted “is there a more elegant way to do the same thing?” at http://hpaste.org/83284
04:38:13 <hpaste> “Anonymous Coward” annotated “is there a more elegant way to do the same thing?” with “is there a more elegant way to do the same thing? (annotation)” at http://hpaste.org/83284#a83285
04:38:18 <beaky> is Data.Maybe a monoid?
04:38:30 <beaky> > mempty :: Maybe a
04:38:43 <beaky> oh lambdabot is on vacation :(
04:38:46 <Peaker> beaky, I'd extract common parts (return and application to symbol) out of the case
04:38:56 <beaky> ah ok
04:39:27 <Peaker> beaky, if you use 'h', 'c', 'e' or such instead of 1,2,3 you won't need any type annotation
04:39:30 <Botje> beaky: yes, it is.
04:39:51 <Peaker> it is, but only if "a" is a Monoid as well
04:39:59 <Botje> mempty is Nothing, mappend takes the first non-Nothing value
04:40:04 <beaky> ah
04:40:32 <Peaker> mappend recursively mappends when two Justs
04:41:05 <Botje> oh, hmm.
04:41:20 <Peaker> the MonadPlus instance does the "first non-Nothing" value thing
04:41:30 <Peaker> and the "Data.Monoid.First" newtype of Maybe
04:42:05 <quchen> Peaker: Wat? MonadPlus /= Monoid instance!?
04:42:32 <Peaker> quchen, yeah, there are no laws binding those two
04:42:51 <latro`a> there's significant ambiguity in the MonadPlus laws in general
04:43:09 <Peaker> quchen, Haskell is restricted, cannot express the Monoid semantics in the MonadPlus instance, I think
04:43:27 <quchen> Peaker: Well there are no laws relating Applicative and Monad either
04:43:34 <Peaker> quchen, I think there are...
04:43:40 <Peaker> (<*>) = ap  is a law, afaik
04:43:41 <beaky> should I use GADTs in my code?
04:44:32 <Peaker> You'd need something like:  instance MonadPlus Maybe where  -- means mplus must work for all "Maybe a", so it cannot recursively do anything with the contents of the Just
04:45:06 <Peaker> quchen, so it's not arbitrary, the only MonadPlus instance for Maybe possible is either left-biased Just or right-biased Just
04:45:20 <quchen> Peaker: I haven't seen anything relating ap to <*> in the docs yet.
04:45:25 <quchen> It's the sane thing to do of course.
04:45:46 <Peaker> quchen, Everyone relies on Applicative/Monad being interchangeable for the intersection
04:46:07 <Peaker> quchen, with Monoid/MonadPlus the classes have no intersection
04:47:53 <beaky> :t liftM2
04:48:23 <quchen> Quchenbot: liftM2 :: (a -> b -> c) -> m a -> m b -> m c
04:48:24 <beaky> <lambdabot> liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:48:37 <beaky> :D
04:48:52 <Peaker> beaky, Use GADTs if you need to enforce some invariants that you can't with ordinary parameteric polymorphism
04:49:57 <`nand`> No lambdabot!?
04:50:22 <quchen> `nand`: Young padawan, it's time you stand on your own feet!
04:50:35 <quchen> Lambdabot left us for we are prepared now
04:50:38 <`nand`> :(
04:50:43 <`nand`> I wanted to show the @src of scanl
04:50:48 <`nand`> during my presentation
04:50:53 <`nand`> you guys ruined it
04:50:55 <`nand`> screw you all
04:51:06 <quchen> I wish there was a website showing it
04:52:05 <beaky> heh
04:52:42 <arkeet> there's always http://code.haskell.org/lambdabot/State/source
04:53:54 <tsinnema> again a haskell newbie question: when you have a {-# RULES section like here: http://hackage.haskell.org/packages/archive/category-extras/0.52.1/doc/html/src/Control-Category-Associative.html#Associative , is it up to the writer of an instance to make sure those rules hold, or is there some magic that makes sure of it?
04:54:00 <arkeet> the former
04:54:12 <arkeet> or rather
04:54:13 <arkeet> no no.
04:54:20 <arkeet> RULES is rewrite rules used by the compiler.
04:55:11 <arkeet> the first one, for instance, tells ghc to replace "bimap coassociate id . coassociate . bimap id coassociate" with "coassociate . coassociate" everywhere.
04:56:08 <quchen> tsinnema: Rules are just plain rewrite rules. The compiler will eat anything. For example, "f x y = f y x" is a valid rule that makes the compiler crash, as it will keep swapping x and y forever.
04:56:29 <arkeet> but yes, if the instance doesn't satisfy those equations, then the compiler may change the meaning of your code.
04:56:29 <quchen> "map f (x ++ y) = map f y ++ map f x" is a valid rule the compiler will happily use.
04:56:56 <tsinnema> arkeet, ok thanks, i think that that was what i was after
04:57:23 <quchen> By the way, why does Lambdabot have cake in it? http://code.haskell.org/lambdabot/State/Pristine.hs
04:57:30 <arkeet> because.
04:57:47 <Lethalman> > head cake
04:57:52 <quchen> For demonstrational purposes, I suppose.
04:58:04 <quchen>  > An entry called 'how to kill someone with your bare hands.'
04:58:06 <quchen> Interesting
05:07:07 <c-ab> is readChan blocking if the chan is empty, like readMVar is blocking when it's empty
05:07:41 <Saizan> c-ab: yes
05:08:18 <c-ab> and what's te difference with readTChan
05:08:27 <c-ab> and tryReadTChan
05:08:49 <c-ab> readTChan will do succesive retries untill the chan is feed up
05:10:03 <c-ab> tryReadTChan returns immediately if it's empty
05:10:53 <c-ab> how is the 'retry' of TChans different from the blocking of Chans
05:14:58 <arkeet> c-ab: retry is from STM.
05:15:04 <arkeet> you should read about STM. :p
05:16:10 <c-ab> retry :: STM a   Retry execution of the current memory transaction because it has seen values in TVars which mean that it should not continue (e.g. the TVars represent a shared buffer that is now empty). The implementation may block the thread until one of the TVars that it has read from has been udpated. (GHC only)
05:17:11 <arkeet> you should read about STM. :p
05:17:49 <c-ab> I read what I found, the difference holds in the atomic operations
05:17:59 <arkeet> that's not all.
05:18:53 <arkeet> I found this helpful. http://channel9.msdn.com/Shows/Going+Deep/Programming-in-the-Age-of-Concurrency-Software-Transactional-Memory
05:19:03 <hpaste> chrisdone annotated “is there a more elegant way to do the same thing?” with “use a lookup” at http://hpaste.org/83284#a83301
05:19:31 <c-ab> thx
05:20:13 <c-ab> o crap microsoft silverlight :(
05:20:53 <quchen> I would rather suggest reading the RWH chapter on STM.
05:21:09 <arkeet> or that.
05:21:13 <arkeet> or anything.
05:23:29 <ivanm> c-ab: you could download it...
05:23:38 <c-ab> yes seen that
05:29:21 <c-ab> funny that microsoft do researches on haskell
05:30:29 <neutrino> their only hope as a technology provider is to become a hipster for something good
05:33:08 <merijn> c-ab: Not just haskell, they have some pretty hardcore theoretical research at MSR
05:33:21 <merijn> F*, for one
05:33:33 <c-ab> #
05:33:44 <merijn> No, F*, not F#
05:33:58 <merijn> F# is their ML look-alike language
05:34:00 <c-ab> ok
05:34:28 <merijn> F* is dependently typed with machine checkable proofs for third-party code :)
05:34:45 <merijn> c-ab: btw, as for how retry is different from blocking: orElse
05:34:57 <merijn> :t orElse
05:35:04 <c-ab> bot is sleeping
05:35:09 <merijn> oh, lambdabot still down
05:35:19 <merijn> c-ab: orElse :: STM a -> STM a -> STM a
05:35:40 <merijn> If the first STM action retries, the second is run, if both retry the entire orElse retries
05:36:04 <merijn> So you can do "readTChan chan1 `orElse readTChan chan2" and it will read from the first completing operation
05:36:50 <c-ab> different from the broadcast
05:43:37 <neutrino> merijn: it's probably a good idea to mention "first in time"
05:53:58 <blueonyx> regarding quickcheck, orderedList :: (Ord a, Arbitrary a) => Gen [a] "Generates an ordered list of a given length."
05:54:02 <blueonyx> how to give the length?
05:54:38 <dmwit> via the "size" part of Gen
05:54:50 <dmwit> ...but normally you don't need to muck about with that stuff.
05:54:59 <blueonyx> ah resize
05:55:05 <dmwit> right
05:55:09 <quchen> blueonyx: If you specify test parameters, you can also give a max size for the entire test.
05:55:14 <blueonyx> when i have a Gen for my own type?
05:55:27 <blueonyx> i have a Position Gen
05:55:36 <blueonyx> now i want 2 Positions but already ordered
05:56:08 <dmwit> blueonyx: do { a <- whatever; b <- whatever; return (min a b, max a b) } -- ;-)
05:56:25 <blueonyx> or this, kthx
05:56:36 <dmwit> or return (sort [a,b]) if comparisons are super-duper expensive and using one instead of two matters somehow
05:59:36 <blueonyx> ah, both Positions need not to be equal
06:00:06 <frerich> Hi, anybody using the Haskell platform on Windows here? I just installed it on a Windows 8 machine; 'cabal update' told me that there's a new cabal-install version available, but trying to install it gave this error message: http://hpaste.org/83303 <-- does that ring a bell for anybody?
06:01:06 <dmwit> uniques 0 gen _ = return []; uniques n gen vs = do { a <- gen; if a `elem` vs then uniques n gen vs else uniques (n-1) gen (a:vs) }
06:01:59 <dmwit> I guess uniques 0 gen vs = return vs would be a bit better. =P
06:06:11 <frerich> For the record: I was able to get rid of that 'cabal install' error by just deleting %APPDATA%\ghc
06:06:48 <dcoutts> frerich: it looks like you had deleted the files for the local Cabal package, but it was still registered
06:07:26 <dcoutts> frerich: so unregistering it was the right solution (which you did by deleting the registraion for all your local packages)
06:07:58 <frerich> dcoutts: I think it was my mistake, yes. I deinstalled the Haskell platform a while ago and IIRC I also deleted %APPDATA%\cabal (to get rid of the packages) but apparently I forgot to also remove the ghc directory.
06:08:12 <dcoutts> frerich: ok, that makes sense then
06:08:26 <frerich> dcoutts: But thanks for the confirmation that deleting the directory was not as bad a workaround as I thought it is :)
06:08:53 <blueonyx> dmwit: thx, but quite a mess, i go with suchThat positionPair (\(x,z) -> x < z) :)
06:09:21 <dmwit> seems like a good plan
06:10:16 <quchen> blueonyx: uncurry (<) == \(x,z) -> x < z
06:10:33 <frerich> blueonyx: I think that's unc... yes, what quchen said :)
06:11:05 <dmwit> > map length ["uncurry (<)", "\\(x,z) -> x < z"]
06:11:11 <arkeet> no bot :c
06:11:26 <dmwit> [11, 15]
06:11:47 <arkeet> 10, 11 if you remove spaces
06:11:49 <ski_> Peaker : arguably (due to OWA), there can't be any laws relating e.g. `Applicative' and `Monad', without there being a common subclass of them (possibly being one of them) -- morally, `pure = return',`(<*>) = ap',`fmap = liftA = liftM' are of course expected
06:11:53 <quchen> I guess we should also use (a,w) then instead of Writer w a because it's shorter?
06:12:06 <dmwit> yes, I think so =)
06:12:44 <quchen> That's not a bad idea for the unmaintainable Haskell list
06:12:54 <dmwit> (More realistically: I think you should use what's clearer. It's not obvious to me that uncurry (<) is clearer than the lambda.)
06:13:04 <blueonyx> i dont care for characters, but this uncurry (<) thing is nice to know, thx :)
06:13:05 <dmwit> (Even though it is shorter.)
06:14:32 <blueonyx> @pf \(x,z) -> ordered [x,x`between`z,z]
06:15:07 <quchen> "uncurry" means "put the following between the tuple elements". It's fold for tuples if you wanna see it like that ;-)
06:15:59 <blueonyx> i know uncurry, but it's not in my active haskell "vocabular"
06:20:05 <adek> I have some data fields which I make intances of ToJSON or FromJSON. Some of them are autogenerated by TH some are written by hand. When I moved all the 'by hand' at the end of the file GHC states that my methods are not visible some lines above. I thought that it doesn't matter in Haskell where in file method is defined. Why then it complains?
06:20:55 <blueonyx> adek: i have this problem too, i just put the $(deriveJSON ...) lines at the end of my files :/
06:21:16 <adek> blueonyx: so this is entirely TH fault?
06:21:46 <blueonyx> from what i can see yea
06:22:11 <adek> Weird, anyway thanks, I just thought that I am missing something
06:22:18 <blueonyx> but i have no real clue about TH
06:24:37 <supki> Template Haskell isn't part of Haskell though :)
06:25:58 <cariveri> Hey guys. what IDE do you prefer ?anyone using vim or is it too much walking by foot?
06:26:21 <k00mi> cariveri: many are using vim/emacs
06:26:26 <quicksilver> adek: TH haskell cares about order unlike haskell which, as you said, does not.
06:26:39 <arbn> cariveri: Lots of Haskell programmers use vim. I use emacs, personally.
06:27:17 <adek> cariveri: Vim + haskellmode which you can find on github serves me well.
06:27:23 <cariveri> ok. I dont feel alon anymore then :)
06:27:27 <arbn> cariveri: The people using an IDE or fancy tools are in the minority, I think. So, don't worry. Writing Haskell isn't hard. You can do it with a plain editor.
06:27:38 <c-ab> if you're less a fan of keyboard based editors, you could use sublime
06:28:05 <ski_> blueonyx :  ((ordered . ($ [])) .) . liftM2 (.) ((.) . (:)) ((liftM2 (.) `flip` (:)) . ((:) .) . between)
06:28:35 <blueonyx> ah thanks ski_ xD
06:28:44 <ski_> (i hope you're happy now)
06:28:55 <blueonyx> kind of
06:29:03 <adek> quicksilver: So what actually happens when I compile with TH. Is whole file compiled by TH?
06:29:48 <blueonyx> quicksilver: so thats also why function used in a splice must be defined in a different module?
06:29:59 <frerich> dcoutts: Hmm, actually - it seems there are still some issues with my installation. I tried installing snap via 'cabal install snap' and eventually it failed with http://hpaste.org/83306 -- does that ring a bell? I don't understand why it tries to install directory in the first place, I have that already :-}
06:30:26 <quicksilver> adek: 'TH' isn't a program, 'TH' can't compile a file.
06:30:40 <quicksilver> adek: TH is a facility of GHC which lets you hook into the process of compilation
06:31:00 <quicksilver> but because of the way it works, it can 'see' the contents of the file being compiled form top to bottom.
06:31:36 <quicksilver> blueonyx: yes, that's why. But I thought it was OK as long as it was defined above the splice. I could well be wrong, I don't use TH very often and not for years.
06:32:04 <adek> quicksilver: I am asking because the fact that TH cares about order doesn't relate to the problem, I thinks so. TH macro which I am calling doesn't use any function defined by me.
06:33:24 <ski_> hm .. `(f . g .) = (f .) . (g .)' , `(. f . g) = (. g) . (. f)'
06:34:36 <hpaste> adek pasted “TH breaks myParse” at http://hpaste.org/83307
06:35:08 <adek> quicksilver: myParse is not visible when $(deriveJSON ...) is used.
06:36:29 <quchen> Oh wait, so TH is sequential?
06:36:34 <quchen> As in top-to-bottom-evaluation?
06:36:40 <sopvop> If I want asynchronous network thingies, should I just forkIO twice (receive, send) or there are better approaches?
06:37:30 <quchen> sopvop: Depends. If that's all your program does you might as well use the main thread for one of the tasks.
06:37:38 <adek> quchen: It looks like it makes whole the file sequential, not only the parts that it uses.
06:37:42 <quchen> The more general solution would be explicitly forking twice.
06:38:11 <quchen> adek: Oh, I understand. (And that's weird behavior)
06:38:38 <sopvop> I'm thinking about toy message broker. Like rabitmq or something.
06:38:54 <k00mi> sopvop: there is an async library, dunno if that does what you want
06:39:02 <quchen> sopvop: I don't know what that is. A chat program?
06:39:23 <sopvop> Pretty much
06:40:56 <quchen> Well then I think Async is a good place to start, as k00mi said. The problem with forking in Haskell is that it won't wait until all threads finish. main = do { forkIO ...; forkIO ...; return () } will most likely do nothing.
06:41:06 <quchen> If main finishes, the program is over.
06:41:24 <sopvop> there still is main loop which accepts connections
06:41:26 <quchen> Async is a nice abstraction that solves that problem (along with others)
06:41:41 <adek> I think that if some chat programs are considered as a good reference may serve Hulk Irc server.
06:42:12 <sopvop> adek: Thanks, I forgot about it
06:45:25 <Cale> > 1
06:45:31 <lambdabot>   1
06:45:31 <preflex>  lambdabot: you have 1 new message. '/msg preflex messages' to read it.
06:45:56 <blueonyx> wb lambdabot
06:45:56 <fizbin> Heh. Lambdabot can't really check its messages, can it?
06:46:14 <fizbin> > :t (.).(.).(.).(.).(.)
06:46:16 <Cale> It doesn't.
06:46:23 <lambdabot>   <hint>:1:1: parse error on input `:'
06:46:36 <fizbin> :t (.).(.).(.).(.).(.)
06:46:40 <quchen> Lambdabot! Welcome back
06:46:45 <lambdabot> (Functor f4, Functor f3, Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 (f4 a)))) -> f (f1 (f2 (f3 (f4 b))))
06:47:02 <quchen> @pl \a b c d -> a == b && b == c && c == d
06:47:11 <lambdabot> (`ap` ((`ap` (==)) . (((.) . (&&)) .) . (==))) . (((.) . (.) . (&&)) .) . (==)
06:48:13 <fizbin> @pl \a b c d -> all $ map (== a) [b,c,d]
06:48:21 <lambdabot> (((all .) .) .) . (. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . map . (==)
06:48:28 <quchen> :P
06:49:30 <blueonyx> :t all . map (==a)
06:49:31 <lambdabot>     Couldn't match expected type `a0 -> Bool' with actual type `[b0]'
06:49:31 <lambdabot>     Expected type: [a1] -> a0 -> Bool
06:49:31 <lambdabot>       Actual type: [a1] -> [b0]
06:49:41 <blueonyx> :t and
06:49:42 <lambdabot> [Bool] -> Bool
06:49:47 <blueonyx> :t all
06:49:49 <lambdabot> (a -> Bool) -> [a] -> Bool
06:49:59 <fizbin> Oh, right.
06:50:20 <fizbin> @pl \a b c d -> all  (== a) [b,c,d]
06:50:21 <lambdabot> (. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . all . (==)
06:51:06 <fizbin> @pl \a b c -> [a,b,c]
06:51:06 <lambdabot> (. ((. return) . (:))) . (.) . (:)
06:56:18 <ski_> @botsnack
06:56:18 <lambdabot> :)
06:57:03 <fizbin> > fix (\s -> [] : concatMap (\t -> map (:t) [1,2,3]) s)
06:57:04 <lambdabot>   [[],[1],[2],[3],[1,1],[2,1],[3,1],[1,2],[2,2],[3,2],[1,3],[2,3],[3,3],[1,1,...
06:58:21 <fizbin> > (fix (\s -> [] : concatMap (\t -> map (:t) [1,2,3]) s)) !! 28
06:58:23 <lambdabot>   [1,3,2]
06:59:11 <fizbin> > (fix (\s -> [] : concatMap (\t -> map (:t) [1,2,3]) s)) !! (1 + 3 + 9 + 27)
06:59:13 <lambdabot>   [1,1,1,1]
06:59:56 <fizbin> @pl \x -> fix (\s -> [] : concatMap (\t -> map (:t) x) s)
06:59:56 <lambdabot> fix . (([] :) .) . (=<<) . flip (map . flip (:))
07:00:23 <quchen> fizbin: Maybe /q lambdabot :-)
07:00:43 <fizbin> Oh, fine.
07:00:44 <ski_> > fix $ \nss -> [] : [n:ns | ns <- nss , n <- "ab"]
07:00:46 <lambdabot>   ["","a","b","aa","ba","ab","bb","aaa","baa","aba","bba","aab","bab","abb","...
07:01:31 * hackagebot PBKDF2 0.3.1.3 - Make password-based security schemes more secure.  http://hackage.haskell.org/package/PBKDF2-0.3.1.3 (ErikHesselink)
07:07:13 <fizbin> > (\x -> [3:nx | nx <- x]) [[4],[5,5]]
07:07:15 <lambdabot>   [[3,4],[3,5,5]]
07:07:21 <fizbin> @pl (\x -> [3:nx | nx <- x])
07:07:22 <lambdabot> return . (3 :) . ((nx | nx) <-)
07:07:31 <fizbin> Go home, @pl, you're drunk.
07:08:14 <wires> fizbin: wtf.. lol
07:08:32 <fizbin> Yeah, apparently @pl can't handle list comprehensions.
07:09:15 <wires> hehe
07:11:11 <chemist> hello
07:11:32 <arbn> Hello, chemist. We are the people of #haskell.
07:12:06 <chemist> how add binary file to package (cabal)
07:12:08 <chemist> ?
07:13:13 <ski_> fizbin : surely `map (3 :)'
07:14:32 <parcs> chemist: extra-source-files field
07:14:43 <fizbin> ski_:	With that example, sure. But I started out trying to figure out why @pl made such a hash out of your fix expression above, reducing it to the simplest case @pl screwed up.
07:15:45 <beaky> hello
07:15:57 <chemist> parcs: thanks
07:17:58 <fizbin> @hoogle void
07:17:59 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
07:17:59 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
07:17:59 <lambdabot> package void
07:19:58 <fizbin> @hoogle absurd
07:19:58 <lambdabot> No results found
07:20:19 <Taneb> Data.Generics looks really useful but I can't think of anything I'd actually use it for
07:20:27 <fizbin> Can someone explain the package "void"? http://hackage.haskell.org/packages/archive/void/0.5.8/doc/html/Data-Void.html
07:20:57 <quchen> fizbin: It's useful for type-level programming.
07:20:58 <Taneb> fizbin, it's a type with no values
07:21:04 <quchen> Void is a zero in some sense.
07:21:21 <Taneb> So, if you have something with type [Void], you know it must be []
07:21:32 <Taneb> And if you have something with type "Maybe Void", you know it must be Nothing
07:22:25 <fizbin> Taneb: Have you looked at http://www.cs.uu.nl/wiki/GenericProgramming/SYB , and the links under "Documentation" there?
07:22:35 <Taneb> fizbin, I have not
07:22:54 <fizbin> That explains why one might want bits of Data.Generics.
07:23:09 <aphury> For any small game at MacOS with Haskell, which lib should I use? SDL seems to have some problems.
07:23:31 <fizbin> quchen: Is there an example of using Void for this "type-level" programming somewhere?
07:24:54 <ketil> I don't suppose anybody has printf for bytestrings?
07:25:03 <fizbin> Taneb: Okay, I'll buy that if you have Void in a type, then the possible values you can have are constrained. But what then?
07:26:25 <Taneb> fizbin, conduit, for example, uses it to say "This conduit does not produce any output"
07:27:02 <fizbin> What's the advantage of a type like "IO Void" over "IO ()"
07:27:17 <Taneb> IO Void doesn't halt
07:27:28 <Taneb> IO () may or may not halt
07:27:46 <Taneb> However, in practice you'd very rarely use "IO Void"
07:28:01 <Taneb> Because "forall a. IO a" means roughly the same
07:28:43 <Taneb> :t forever
07:28:45 <lambdabot> Monad m => m a -> m b
07:29:01 <Taneb> Because b can be anything, you know it doesn't halt, because it could be Void
07:29:33 <supki> > forever Nothing
07:29:35 <lambdabot>   Nothing
07:29:46 <fizbin> :t forever Nothing
07:29:48 <lambdabot> Maybe b
07:30:17 <fizbin> @info forever
07:30:18 <lambdabot> forever
07:30:20 <Taneb> I'm using "doesn't halt" quite incorrectly
07:30:27 <fizbin> @hoogle forever
07:30:27 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
07:31:04 <Taneb> But Void is useful to show "We don't have a value here"
07:32:02 <fizbin> @src forever
07:32:03 <lambdabot> Source not found. :(
07:32:23 <quicksilver> forever x = x >> forever x
07:32:31 <fryguybob> @type const . fromJust . forever $ Nothing
07:32:33 <lambdabot> b -> a
07:34:05 <fizbin> Okay, so Void differs from () in that there is exactly one value of type () written as (), but there are no values of type Void.
07:34:11 <fizbin> :t ()
07:34:13 <lambdabot> ()
07:35:11 <Taneb> Yes
07:35:12 <fryguybob> fizbin: Right.  Anything claiming to be a value of Void is a lie and is bottom (nontermination)
07:36:32 * hackagebot tagset-positional 0.3.0 - Positional tags and tagsets  http://hackage.haskell.org/package/tagset-positional-0.3.0 (JakubWaszczuk)
07:37:01 <fizbin> So there's some category in which it makes sense to say that Void is an initial object, and () a terminal object.
07:39:53 <aphury> I've just found a problem with my cabal. Whenever I run "cabal update" if finds a new version of cabal-install. So I run "cabal install cabal-install", but after this has finished, I still get the some note when running "cabal update"
07:40:33 <fryguybob> aphury: Perhaps the new cabal installed somewhere further along in your path so it is shaddowed by the old cabal.
07:41:15 <aphury> fryguybob, is there a chance to recognize this?
07:41:22 <fizbin> aphury: Do you need to run "sudo cabal install cabal-install" ?
07:41:25 <fryguybob> aphury: What os?
07:41:36 <aphury> fizbin, oh! That may be the point.
07:41:39 <aphury> fryguybob, MacOs
07:41:59 <timthelion> is there any way to send SIGKILL to a process when I have it's ProcessHandle(from System.Process) but not it's ProcessID(from System.Posix)?
07:42:35 <Saizan> never sudo cabal
07:42:42 <fryguybob> aphury: I don't know much about MacOS, but in my shell it happens to define `where` that will tell you all the places in the path that match the command
07:43:03 <fryguybob> aphury: And on Windows you can use get-command in powershell to do the same.
07:43:04 <aphury> Saizan, why not?
07:43:07 <Saizan> cabal install --root-cmd=sudo --global if you must
07:43:37 <fryguybob> aphury: It is much better to fix your path then mess with the globally installed packages.
07:43:45 <fizbin> Saizan: Ah, you're saying make it so that cabal only has root privs for the things it needs.
07:43:58 <timthelion> aphury: because sudo runs as root, but with ENV-VARS based on the user that called sudo.  That confuses cabal.
07:44:09 <aphury> fryguybob, it says /usr/bin/cabal
07:44:14 <aphury> okay
07:44:31 <Saizan> aphury: because sudo cabal is still going to use your user's $HOME and mess with it with root privileges
07:44:35 <timthelion> aphury: I haven't tried it, but I presume it might end up installing to the calling users $HOME, but with root owned files.
07:44:46 <aphury> So I'll try cabal install --root-cmd=sudo --global cabal-install ?
07:44:59 <Saizan> i wouldn't
07:45:30 <aphury> hm..
07:45:39 <Saizan> aphury: you should rather put $HOME/.cabal/bin in front of /usr/bin in your $PATH
07:46:31 <fizbin> Saizan: Why? This is a MacOS machine - it isn't as though there are other users on it.
07:47:17 <Saizan> fizbin: because it won't solve the $PATH problem and can just screw with your globally installed packages
07:47:25 <fryguybob> fizbin: I think this answers that question: http://www.vex.net/~trebla/haskell/sicp.xhtml
07:48:13 <Saizan> well, i don't know the default global install paths on OSX, i doubt it's /usr/bin though
07:48:35 <aphury> Saizan: yes, it is.
07:48:46 <geekosaur> the reason is that cabal still has a tendency to $#!+ its pants; when it does, you want to be able to recover without wiping and reinstalling ghc, so user installs should be to the user package dir and exeutable dir
07:49:01 <Saizan> but still you'll need $HOME/.cabal/bin for other tools you are going to install with cabal
07:49:27 <Saizan> aphury: i mean the ones in ~/.cabal/config
07:49:38 * timthelion doesn't see why haskell tries to support OSX, it would be easier to just link to a linux distro...
07:49:57 <beaky> :D
07:50:01 <fryguybob> OSX users are people too.
07:50:14 <aphury> -.-'
07:50:27 <geekosaur> um, you can hit this issue on linux as well
07:50:33 <beaky> yes, would be nice if haskell was as ubiquitous as C :D
07:50:57 <Saizan> fryguybob: i didn't notice
07:51:04 <timthelion> fryguybob: yes, but there is nothing to say people matter...  As a vegitarian, I have a morality that seperates the world into "things that move" and "very smart things that move"... Being people too doesn't mean nothing!
07:51:49 <aphury> timthelion, supporting different OS helps spreading haskell, no?
07:52:34 <timthelion> aphury: not always.  I see a lot of haskellers have moved to OSX, and then they make false claims about guis being hard to create in haskell(when it's just OSX being weird)
07:53:24 <fizbin> timthelion: That sounds to me like a complaint that Haskell OSX gui libraries aren't up to snuff.
07:53:46 <fizbin> Though I'll admit I've heard a similar complaint about trying to use gtk from within HAskell.
07:54:40 <aphury> timthelion: well, it does complicate some things (even the GUI thingie), but I would say it helps spreading. Don't know if I will matter once, but I wouldn't have used haskell, if there weren't such easy to use MacOS Bins.
07:54:41 <beaky> someday haskell will have an amazing GUI framework using FRP
07:54:55 <geekosaur> if you're not using macports or homebrew, getting usable gtk libs on os x is somewhat difficult; this is mostly because the gtk folks don't have a package, they provide a shell script to build from source, with a lot of caveats
07:55:09 <geekosaur> the correct answer is to use one of the package managers
07:55:37 <timthelion> beaky: but even now, using gtk2hs on linux with haskell is easy as pie.  no need to wait for some FRP package!
07:55:47 <fizbin> The issue I've heard people complain about with gtk is that it's so thoroughly object-oriented, it just assumes at a very basic level that you can have a function named "foo" on two different types that return two radically different things, and that's fine.
07:56:12 <geekosaur> uh? gtk+ is written in C, it can't overload function names
07:56:53 <fizbin> No, but you can have record fields in two different record types that are named the same thing, but refer to different types of values.
07:56:54 <timthelion> fizbin: it might not be pretty, but it's perfectly easy to use(once you get around the caviets to do with threading.
07:57:17 <fizbin> And those different record fields can be function pointers.
07:58:26 <fizbin> So, in effect, you can perfectly well have the case in C where x.foo is a function with signature int *(int, int) but y.foo is a function with signature void(int)
07:59:01 <Sculptor> hi
07:59:07 <geekosaur> yes, that's true, every struct is a separate namespace
07:59:12 <timthelion> fizbin: but does that actually make it harder to use?  Or is it just not very haskelly?  You can write perfectly good imperitive code with gtk2hs, and wire it into a declarative backend with ease.
07:59:59 <timthelion> Sculptor: welkome to #haskell, please take a seat and enjoy the netsplit messages!
08:00:24 <ab9rf> there'sa  reason i disabled join and part in this channel :)
08:00:25 <c-ab> :t replicateM_
08:00:27 <lambdabot> Monad m => Int -> m a -> m ()
08:00:32 <ab9rf> well, muted
08:00:35 <fizbin> timthelion: It means that every time you look up a field in the gtk docs, you have to remember how that field name is qualified in the place you want to use it.
08:00:58 <Sculptor> timthelion, thanks
08:01:13 <timthelion> fizbin: I don't code much from memory. I usually just put the docs on the left monitor and the code on the right.
08:01:48 <fizbin> Whereas with object-oriented languages that break up their namespace the way gtk expects, the names match. (And, depending on your IDE, can be autocompleted)
08:02:26 <c-ab> :t act
08:02:27 <lambdabot> (Conjoined p, Effective m r f) => (s -> m a) -> p a (f a) -> p s (f s)
08:04:17 <ab9rf> huh, i used to be a gtk developer... i don't remember it being like that when i worked on it
08:04:21 <fizbin> Anyway, that's the complaint I've heard for why "GUIs are hard in haskell" - it's because gui toolkits, like gtk, assume a namespace hierarchy where each structure is its own new namespace. This means that the interface to haskell is always rougher than in some other language.
08:04:45 <ab9rf> but it's been 15 years i guess
08:05:44 <c-ab> :t (`finally` (atomically $ writeTVar foo (subtract 1)))
08:05:46 <lambdabot> Not in scope: `finally'
08:05:46 <lambdabot> Not in scope: `atomically'
08:05:46 <lambdabot> Not in scope: `writeTVar'
08:08:11 <qwr> fizbin: it's kind of stupid idea to provide direct wrapper to some C gui library
08:08:37 <kqr> fizbin, that, and the imperative design is a nuisance (spelling?) amidst the pure haskell code
08:08:42 <qwr> fizbin: there might be some good sides, but you probably won't end up with good API
08:09:11 <quicksilver> I don't think the namespace is a huge obstacle
08:09:20 <quicksilver> you just prefix everything in haskell at worst
08:09:27 <quicksilver> gtkButtonCloseCallback
08:09:30 <quicksilver> (or whatever)
08:09:49 <quicksilver> in practice, they use typeclass overloading to smooth it out.
08:10:15 <quicksilver> I think the 'guis are hard in haskell' complain is actually mostly about how hard it is to install fiddly native libraries.
08:10:27 <quicksilver> (if this is off the back of that blog post)
08:10:50 <fizbin> Plus, GUIs in general are less easy than it seems they ought to be.
08:10:57 <ab9rf> fizbin: yes
08:11:27 <ab9rf> guis are devilishly hard
08:11:50 <ski_> @type \foo -> (`Control.Exception.finally` (Control.Monad.STM.atomically $ Control.Concurrent.STM.TVar.writeTVar foo (subtract 1)))
08:11:51 <lambdabot> Couldn't find qualified module.
08:11:58 <ski_> @type \foo -> (`Control.Exception.finally` (GHC.Conc.atomically $ GHC.Conc.writeTVar foo (subtract 1)))  -- c-ab ?
08:12:00 <lambdabot> Num a1 => GHC.Conc.Sync.TVar (a1 -> a1) -> IO a -> IO a
08:12:33 <quicksilver> I quite disagree with the suggestion that imperative design is a nuisance.
08:12:42 <quicksilver> haskell is easily the best imperative language I've ever used.
08:12:51 <quicksilver> (ML is probably the second best)
08:13:11 <ski_> (which ML ?)
08:13:14 <fryguybob> c-ab: Do you want modifyTVar?
08:13:33 <quicksilver> ski_: most of my imperative GUI work was in a dialect of SML called MLj or
08:13:40 <quicksilver> I did a little ocaml.
08:13:56 <ski_> (hm, not SML/NJ, then ?)
08:13:59 <quicksilver> mixing ML and java was instructive
08:14:04 <ski_> oh
08:14:17 <quicksilver> because it was literally the case that every time you moved code over the boundary to ML, it got better
08:14:27 <quicksilver> even the bits you naively (as a grad student) expected Java to be better at.
08:15:08 <quicksilver> ski_: this - http://www.dcs.ed.ac.uk/home/mlj/ - although I think I was using a later unreleased version which Ian gave me.
08:15:44 <quicksilver> the worst case I can see for haskell/ML would be an OO GUI library designed so that the normal mode of operation was to subclass to make your own components.
08:15:55 <quicksilver> implementation inheritance/overriding is nasty
08:15:59 <beaky> why is haskell less popular than languages like javascript, PHP, C#, Java, Ruby, Perl, Python, C, C++, Objective-C, and others?
08:16:03 <quicksilver> (and the ABI for that would be a practical pain)
08:16:39 <timthelion> beaky: because haskellers are too "pure" to get their hands dirty making code that actually does things that are usefull.
08:16:55 <quicksilver> timthelion: FUD.
08:17:15 <beaky> timthelion: but there seems to be a lot of useful haskell frameworks for things like Parsing, Webapp development, etc
08:17:27 <kqr> quicksilver, haskell is a great imperative language. i just don't like imperative programming at all, regardless of language ;)
08:17:56 <timthelion> quicksilver: well, I have found some usefull haskell programs, but most of them use IORefs ;)
08:18:15 <timthelion> quicksilver: por exemplar ghc.
08:18:43 <quicksilver> sure.
08:18:44 <quchen> And? Some C++ programs use callback functions. That doesn't mean they're unclean.
08:18:46 <quicksilver> how is that a problem?
08:19:00 <aphury> So, I've set the $PATH as said before (even after reinstalling haskell) but it keeps on updating and updating.
08:19:02 <quicksilver> useful haskell programs tend to use IORefs doesn't stop useful haskell programs.
08:19:30 <timthelion> quicksilver: I don't think it's a problem.  But I do think that a lot of the reason haskell is less popular, is that haskell programmers are afraid to do things if they can't find a beautiful way of doing them.
08:19:52 <quicksilver> maybe. I'm not convinced.
08:19:57 <quicksilver> but I don't know what the actual answer is.
08:20:08 <timthelion> quicksilver: if IORefs were less shuned then more people would realise that usefull things can be done with them.
08:20:19 <quchen> timthelion: That's because Haskell is my hobby. Ever seen someone who likes to build model airplanes make something out of mud using nothing but a hammer as a tool?
08:20:20 <quicksilver> I don't know what makes you think IORefs are shunned.
08:20:37 <quicksilver> they're just part of the IO monad. They're perfectly reasonable.
08:20:39 <beaky> there's always a need for things like IORef and STRef
08:20:44 <quicksilver> top-level global IORefs are shunned, sure.
08:20:44 <beaky> somewhere
08:20:49 <quicksilver> but you don't need these to write useful programs.
08:21:43 * quchen thinks "everything in IO is evil" is a somewhat poor agenda against Haskell.
08:21:55 <quicksilver> Factors I would list are (1) relative scareness of haskell in programming courses (2) relative scarceness in industry [which is a chicken-and-egg thing] (3) momentum - lots of the really useful haskell libraries are actually quite new.
08:22:12 <quicksilver> 6/7 years ago haskell didn't have a web framework at all.
08:22:15 <quicksilver> now it has several.
08:22:16 <timthelion> quicksilver: well, looking at the lense libraries, a lot of the examples are bad attempts to replace mutability in places where mutability leads to actually better code.  There is a hatred of mutability coming from some in this comunity that leads to really rediculous code.
08:22:33 <beaky> ah
08:22:33 <jimki> I read that as "relative scaryness", which fit quite nicely to the sentence
08:22:37 <aphury> restarting the shell solved the problem -.-'
08:23:00 <quicksilver> timthelion: that's a curious claim. lense libraries are basically a way to reason about mutability, not replace it.
08:23:06 <timthelion> quicksilver: I would agree with the scariness.
08:23:19 <quchen> timthelion: Talking about rEdiciulous code, have you seen unit test libraries in other languages? In the best case, they're implemented as a program as opposed to programmers.
08:23:33 <quicksilver> I actually meant scarceness, not scariness. THe correct word is 'scarcity' though ;)
08:23:39 <timthelion> quicksilver: but look at the types in edwardk's lens libs.  They don't help you reason, they make things really ugly for no reason.
08:23:54 <quicksilver> timthelion: you just haven't made the effort to understand them.
08:24:01 <quicksilver> and it isn't "for no reason"
08:24:09 <quicksilver> abstraction is always a cost - that's a universal lesson.
08:24:17 <quicksilver> more abstract code is harder to understand, but it's more general.
08:24:30 <quicksilver> lens's types are very abstract indeed, and therefore hard to understand.
08:24:36 <quicksilver> they're not sinister, or magic, or ugly.
08:24:36 <quchen> They help edwardk et al reason. They may be ugly, but it's very unlikely the lib does something entirely unexpected.
08:24:49 <quicksilver> they're just abstract and it requires effort to understand them.
08:24:50 <donri> uhm, lens's types are scary because of high polymorphism which is more powerful than mutation syntax in most languages
08:25:15 <quicksilver> I was thinking of listing scary-ness as a disadvantage for haskell but I don't really buy the argument.
08:25:31 <quicksilver> C++ is scary and succesful. php is terrifying. many programmers are scared of perl.
08:25:35 <timthelion> quicksilver: but their end result is a less eficient implemenation of what would be in an oo language trivial mutablilty.
08:25:47 <quicksilver> timthelion: no, that is exactly not their result.
08:25:49 <edwardk> timthelion: actually they compile away to exactly what you'd want them to.
08:26:03 <edwardk> timthelion: that is a large portion of their complexity
08:27:01 <timthelion> edwardk: I guess my point is, that "if you want mutability, why not mutate?"
08:27:16 <donri> because you probably don't want mutability ;)
08:27:19 <timthelion> mutation is the most direct way of modeling mutability.
08:27:19 <edwardk> timthelion: because now add non-determinism to your program. your way you are immediately fucked
08:27:19 <quchen> We don't want mutability in general.
08:27:38 <edwardk> timthelion: drop a 'ListT'  on top. oops your entire control flow changes
08:27:49 <edwardk> timthelion: you have to rewrite your program then. I do not
08:28:03 * Kinnison very much likes pure data structures
08:28:23 <Kinnison> it's taking me a while to wrap my head around them, but they're so much safer/nicer than the common mutated bleh I deal with in my work day
08:28:26 <donri> but maybe you'd feel more at home with ocaml or something
08:28:37 <quchen> Lisp!
08:28:52 <kqr> yay dynamic type system
08:29:01 <quchen> Lisp has a type system? ;-)
08:29:10 <kqr> er
08:29:15 <Kinnison> it's a kind of a type system :-)
08:29:31 <timthelion> When I started trying to write more complex transformations on tree structures by hand, such as node replacment, I found that I often rebuilt the trees wrong.  Node replacement in a language that uses mutability never risks rebuilding things wrong since it requires no rebuilding.
08:29:42 <simpson> timthelion: Is this just another "rawr I am angry at programming and want to vent?"
08:29:48 <Kinnison> timthelion: sounds like you needed lenses :-)
08:29:49 <donri> sure, it has several types: lists, atoms, numbers, strings and quoted code.
08:30:07 <simpson> timthelion: Did you know about SYB, Uniplate, etc.? (Or maybe just Functor and Applicative?)
08:30:29 <edwardk> timthelion: no instead you risk racing between two different threads, seeing multiple versions of the structure, dropping off with iterator invariants.
08:30:34 <edwardk> all of those strike me as so much nicer.
08:30:37 <typoclass> timthelion: seems like a job for Functor? it leaves the structure intact by definition (mostly)
08:30:56 * Kinnison wonders why someone is turning up on #haskell and then whinging about pure data
08:31:07 <edwardk> if you want to use that style you can live with IO and do everything through IORefs
08:31:22 <ski_> (s/pure data/immutable data/)
08:31:37 <Kinnison> ski_: yeah, that's what I mean, ta :-)
08:31:47 * Kinnison is still learning :-)
08:31:59 * ski_ is still learning
08:32:00 <timthelion> edwardk: that was my point initially, is that haskell's popularity is harmed by the lack of people saying "you can just use IORefs here and not have to worry about purity when it doesn't seem nice.)
08:32:07 <simpson> Kinnison: This is not Tim's first time doing this. :3
08:32:18 <Kinnison> aah, I see
08:32:24 <simpson> timthelion: Are you sure it's not harmed more by people simply not wanting nice things?
08:32:28 * Kinnison thinks that haskell's popularity is right where it needs to be for now
08:32:34 <simpson> Have you *seen* people defending PHP and JS?
08:32:37 <quchen> simpson: Wait, what?
08:32:43 <timthelion> edwardk: but people assumed I was ranting against haskell, when I was really just trying to say, "a lot of people are afraid of using the IO easy out, even when it is the easiest way to do something."
08:32:49 <quchen> simpson: And again on ^^^: wait what?
08:32:53 <simpson> quchen: For some curious reason, even if you build nice things, people don't want them.
08:32:55 <Kinnison> One problem with really popular language is you get PHP/Ruby/Python's ecosystems -- less "batteries included" and more "OMG, how do I choose?!?!"
08:33:05 <donri> timthelion: lots of things use iorefs[/strefs/mvars/tvars] though. not sure where you're getting this impression
08:33:10 <simpson> quchen: I posit that Haskell is a nice thing, and as such, people will turn it down in favor of worse things.
08:33:27 <timthelion> donri: lots of code uses it, but almost no books recomend it.
08:34:01 <donri> timthelion: there's an upcoming book on mvars and tvars :()
08:34:03 <donri> :)
08:34:05 <timthelion> donri: find me a blog post that is about "here is a place where IORefs are a trivial way to avoid an abstract and hard to understand solution."
08:34:11 * ski_ . o O ( "I have SEEN the CONSING!!" )
08:34:36 <quchen> timthelion: Well, it takes some time to get used to them. If from the very beginning you learn Haskell using IORefs a lot, I don't think that would be very fruitful. For the same reason books don't mention unsafePerformIO.
08:34:56 <timthelion> quchen: but unsafePerformIO really IS bad ;)
08:35:01 <beaky> if I want to represent tictactoe board symbols, should I specify a Blank symbol, or should I make my board hold Maybe BoardSymbols ?
08:35:03 <quicksilver> there aren't enough good haskell books for it to be very interesting to generalise about them.
08:35:08 <quchen> timthelion: Debug.Trace.trace <- questions?
08:35:12 <Kinnison> beaky: Depends on how you want to think about things
08:35:21 <timthelion> quchen: that is a very unusual example ;)
08:35:30 <Kinnison> beaky: You could represent your board as a Map (Int,Int) Bool
08:35:30 <wossname> learning how to program is hard enough that the mistakes you make in consistent languages seem to be caused by rules just as arbitrary as the ones you make in weaker languages
08:35:34 <donri> it seems a bit like teaching python by starting out writing classes that implement __call__, skipping teaching functions
08:35:42 <Kinnison> beaky: where True was X False was O and absent was blank
08:35:44 <quchen> timthelion: FFI algorithms returning pointers are in IO, the memory address is given by the OS. However, the result is pure. -> unsafePerformIO
08:35:45 <beaky> ah
08:35:52 <quicksilver> but since haskell is a niche language it wouldn't be surprising that the books that do exist tend to focus on the cool functional stuff rather than the boring the-same-as-other-language bits
08:35:53 <Kinnison> beaky: Depends on how you want to reason about it IMO
08:36:00 <beaky> I wish I knew the best way to represent tictactoe boards in my game :(
08:36:09 <Kinnison> beaky: If I were you, I'd have a go at various ways and see what feels nicest to you
08:36:13 <beaky> I'm having a hard time coming up with a correct and efficient minimax implementation :D
08:36:24 <quchen> beaky: 9-tuples, clearly
08:36:33 <beaky> quchen: hahaha
08:36:46 <ski_> beaky : i'd go with `Maybe'
08:36:46 <beaky> my current implementation is not so far from that
08:37:14 <timthelion> quchen: that is true, but most of the FFI libs that work with data processing are better replaced with native haskell code.  I mean, there is haskell regex FFI, and haskell graph processing FFI, but native haskell implemenations would be better.
08:37:24 <beaky> yes; if only I used Maybe, I coudl elverage the power of monads in my code
08:37:24 <donri> Kinnison: if you have a map to bools, just use a set
08:37:29 <donri> beaky: ^
08:37:30 <Kinnison> donri: true enough
08:37:43 <Kinnison> donri: No
08:37:47 <Kinnison> donri: set won't help
08:37:48 <quchen> timthelion: I wouldn't say that. If you have a well-functioning giant C lib, why reimplement it in Haskell? That's what the FFI is for, after all.
08:37:51 <Kinnison> donri: set gives you A/B
08:37:55 <Kinnison> donri: map gives you A/B/absent
08:38:11 <Kinnison> donri: set is more Map a ()
08:38:22 <quchen> Of course you can reimplement it, but that'll most likely take much longer than writing C bindings.
08:38:25 <donri> i guess, if you want a tristate
08:38:35 <Kinnison> donri: well tictactoe is tristate
08:38:45 <donri> true
08:38:57 <donri> not sure i'd use bool though
08:38:59 <klugez> Using a separate data Mark = X | O probably is better than assigning meanings to Bools.
08:39:14 <beaky> my minimax tree looks like this: data GameTree = Terminal Board | Node Board [GameTree]
08:39:17 <donri> data Player = X | O
08:39:26 <donri> yea
08:39:45 <beaky> donri: my symbols looks like that too: 'data BoardSymbol = Blank | X | O' :D
08:39:56 <donri> beaky: ah, then you can use a Set
08:40:07 <donri> beaky: as Kinnison notes with a Map you don't need Blank
08:40:23 <beaky> ah
08:40:26 <donri> because lookup is isomorphic to Maybe Bool here
08:40:40 <donri> which is tristate
08:41:16 <quchen> What's this tristate you keep talking about?
08:41:20 <donri> uh, ignore everything i just said
08:41:33 <beaky> having three states?
08:41:50 <quchen> For a tic tac toe game?
08:41:54 <ski_> beaky : `Board' being `BoardSymbol' ?
08:41:58 <Kinnison> """I absolutely love your Haskell videos! Great voice, great flow and great content. Thanks man﻿ and keep it up! :)"""
08:42:02 * Kinnison melts
08:42:10 <Kinnison> at least one person likes my screencasks :-)
08:42:13 <quchen> Kinnison: Oh wait, are you the hole guy?
08:42:15 <ski_> beaky : why a `Board' in the `Node' constructor ?
08:42:22 <Kinnison> quchen: the hole guy?
08:42:25 * Kinnison checks himself for leaks
08:42:30 <edwardk> timthelion: i happen to believe that in general doing things the pure way lets you make more easily extended code. Your 'use IO and everything you could do before works in Haskell' solution works, but is limited to precisely what you could do before in imperative languages. I know how to do that stuff. I have lots of code that works that way when the domain I have is restricted enough that I know I'll never add parallelism or
08:42:30 <edwardk>  non-determinism, or transactions, or .. but honestly i tend to build code bottom up, where i don't have omniscience about how it will be used, so this is a small fraction of what i write
08:42:36 <edwardk> lenses are for that remaining 95%
08:42:46 <quchen> Kinnison: ah no there was a vid on Reddit about type holes, and he had a really nice voice :-)
08:42:49 <beaky> ski_: well, it's to hold the current board :D
08:42:53 <Kinnison> quchen: Oh not me, no
08:43:02 <ski_> beaky : oh, i just realized
08:43:23 <ski_> (beaky : i was confusing `GameTree' with the game state :)
08:43:30 <beaky> ah
08:43:53 <ski_> (i was thinking you wanted to represent the game state in a tree for some reason)
08:44:08 <beaky> it's meant o represent all possible configurations that can follow from the different choices the players make
08:44:20 <beaky> ski_: the game state is in a Data.Sequence :D kind of like a tree
08:45:07 <ski_> beaky : would `Data.Tree' work ?
08:45:17 <beaky> I thought of using Data.Tree
08:45:20 <timthelion> edwardk: Well you write data processing applications.  There, 90% of what you do, can be pure and should be pure.  But I write interactive GUI applications.  90% of what I write is in the IO monad.  But that doesn't meant the 10% that is data processing isn't helped by the fact that haskell is good at data processing.  People have just misunderstood what I meant.  I was initially replying to a guy who said GUI would be easy once a good FRP 
08:45:31 <ski_> (iow, do you need a separate `Terminal' ?)
08:45:32 <quchen> beaky: http://xkcd.com/832/
08:45:36 <beaky> I think Data.Tree would be the way to go :D
08:45:40 <GuestPuncher> i got acid-state added the nosql-database.org btw
08:45:46 <beaky> no need to reinvent trees
08:45:46 <GuestPuncher> haha
08:45:50 <edwardk> timthelion: i happen to largely disbelieve the FRP vision, so there we at least have a common ground ;)
08:46:34 <edwardk> i only popped up once you started saying how lenses wouldn't be necessary when you become willing to do everything with pointers and mutation. i can mutate any one pointer easily.
08:46:58 <edwardk> but reasoning about those edits is not compositional. i can compose lenses, traversals, folds, etc.
08:47:00 <ski_> timthelion : suspected cut off near "... would be easy one a good FRP"
08:47:11 <timthelion> edwardk: I got that impression, only from the ping pon example, which really is cleaner when done with mutability ;)
08:47:19 <ski_> (s/one/once/)
08:47:34 <timthelion> ski_:  lib exists.  But you can do
08:47:35 <timthelion>                     imperative GUI in haskell today with ease.
08:47:46 <edwardk> timthelion: sure, due to linear control flow. move to a bigger game with more world state and let the AI think farther ahead.
08:47:58 <edwardk> and all of a sudden it starts becoming a more lens like problem
08:48:57 <timthelion> edwardk: that is true.  Though if you have a well designed reference based(not pointer based) langauge with deap object copying, the same effect can be created(you can look ahead in a deap copied state).
08:49:47 <timthelion> edwardk: that's not possible in C, since deap copying in a pointer based language is tricky,  but in python and java, you can make it work well.
08:49:54 <edwardk> at which point you've built something pseudo immutable and have access to the past, but now have a painfully complicated interface
08:50:10 <ski_> timthelion : which is the difference between "reference based" and "pointer based" you're suggesting here ?
08:50:19 <timthelion> edwardk: I don't like python or java either, I was just saying that it works.
08:50:35 <edwardk> and i'm just saying that i rarely am editing a single target with a lens combinator.
08:50:36 <simpson> timthelion: Sorry, what. I have never seen this sort of thing in Python.
08:51:11 <edwardk> > [[(1,2),(3,4)],[(5,6)]] & traverse.traverse.both +~ 1
08:51:12 <beaky> I love trees
08:51:14 <lambdabot>   [[(2,3),(4,5)],[(6,7)]]
08:51:16 <beaky> trees are so easy :D
08:51:30 <monochrom> what has shachaf done!
08:51:37 <timthelion> ski_: if I have a struct foo{ int * i}.  Copying the object will leave you with a copy to a pointer to i, but with the same actual i that is pointed to.  In a reference based language, i will be copied itself, thus not having that problem.
08:51:43 <quchen> beaky: Trees are monoids, so of course
08:51:47 <donri> > [[(1,2),(3,4)],[(5,6)]] & each.each.each +~ 1
08:51:50 <lambdabot>   [[(2,3),(4,5)],[(6,7)]]
08:51:52 <beaky> Data.Tree even has a nice function to pretty print your trees
08:52:06 <edwardk> > [[(1,2),(3,4)],[(5,6)]] & biplate +~ 1
08:52:08 <lambdabot>   [[(2,3),(4,5)],[(6,7)]]
08:52:10 <donri> ;)
08:52:32 <ski_> timthelion : hm, so deep copying by default ?
08:52:33 <quchen> :t biplate
08:52:35 <lambdabot> (Data.Data.Data s, Typeable a, Applicative f) => (a -> f a) -> s -> f s
08:52:35 <donri> beaky: you get that with map too (and set i think?)
08:52:57 <edwardk> donri: except for the tuple part
08:52:57 <timthelion> simpson: simply copy an object.  I don't remember the function name, maybe "duplicate"?  f' = duplicate(f).  move=lookahead(f'), applymove (f,move)
08:53:04 <edwardk> then you have to do something peculiar to the type
08:53:10 <edwardk> the point is to make them more compositional
08:53:15 <donri> edwardk: ?
08:53:23 <ski_> (perhaps with some kind of lazy copying / copy-on-write or something, and with "stealing" if the old one is discarded ..)
08:53:35 <simpson> timthelion: I have a sneaking suspicion that you don't know Python.
08:53:36 <edwardk> donri: oh sorry got confused about who was saying what to who
08:53:41 <donri> :)
08:53:57 <timthelion> simpson: I don't know it well, no.  But I think my pseudo code gets the point across.
08:54:15 <simpson> timthelion: In Python, ints are immutable, so you wouldn't do this trickery at all. :T
08:55:09 <edwardk> so let me get this straight to avoid copying the structure you're going to make the structure copy itself entirely
08:55:15 <timthelion> simpson: m?  i = 1 \n i=i+1 works in python. doesn't seem very imutable to me.
08:55:30 <edwardk> so where before i could have my old map and my new map share most of their nodes you want me to copy the entire map
08:55:31 <simpson> timthelion: i is a *name*, not a *variable*. It's an object-based language.
08:55:31 <timthelion> edwardk: but only once.  Only when you want to preserve the old state.
08:55:47 <donri> python has deep and shallow copies. not sure which timthelion means
08:56:00 <timthelion> edwardk: in haskell, we copy every time we mutate, in a mutable oo language we copy every time we want to preserve.
08:56:01 <simpson> timthelion: i = 1; j = i; assert i is j; i += 1; assert i is not j
08:56:22 <simpson> timthelion: Oftentimes we don't copy, period. WTF?
08:56:34 <timthelion> simpson: hm?
08:56:52 <edwardk> timthelion: consider what it costs me to do that copy for the map
08:57:03 <edwardk> i have to walk down to the node in either the immutable or the mutable version
08:57:07 <edwardk> so i already pay the log n cost
08:57:14 <quchen> timthelion: Waitwaitwait. Modifying a value inside some object doesn't copy the whole object in Haskell. It updates a single value, all the other pointers stay the way they are.
08:57:15 <simpson> timthelion: By definition, mutation is non-copying. What you mean to say is that we rebuild structures when we wish to express a change, returning the new structure and perhaps discarding the old one.
08:57:19 <edwardk> now reassembling as i walk out is asymptotically free
08:57:35 <edwardk> the gc over that space is also 'effectively free'
08:57:45 <simpson> timthelion: But most of the structure's contents haven't changed, so the end result is largely the same structure, including memory addresses.
08:57:48 <edwardk> so you get immutability for zero additional asymptotic complexity over the original algorithm
08:58:03 <edwardk> you just get full persistence, not snapshotting
08:58:16 <edwardk> that isn't to say this holds for every algorithm
08:58:52 <edwardk> when i need union find i have to choose between upgrading my O(n log n) to O(n alpha n) and the pure solution, but many times you get persistence for free.
08:59:46 <timthelion> edwardk: Well, if you are using a linked structure than the mutation is O(n). but if you are using a staticly sized structure(such as a struct, or array) then the mutable mutation is O(1) and the copy based mutation is O(n)
09:00:14 <timthelion> edwardk: aka, arrays are faster to mutate then copy.
09:00:52 <simpson> An O(1) mutation implies that you're modifying a constant amount of data.
09:01:04 <edwardk> sure, and when i absolutely need that extra bit of packing, i pay for it in all my reasoning through the rest of my code or i switch to vectors and let fusion try to make both of those costs disappear
09:01:09 <timthelion> simpson: which is what a lense does, no?
09:01:12 <simpson> And thus the data *not* modified is also constant. (You said that the structure was of constant size.)
09:01:15 <simpson> timthelion: Lemme finish.
09:01:50 <edwardk> timthelion: lens is about more than just 'lenses'. a traversal can edit a large number of targets in a whole.
09:01:55 <simpson> So not modifying the surrounding data, creating a new cell of constant size and filling it, and generating a new data structure which points to the old data *except* where it points to the new data, is also all constant.
09:02:05 <edwardk> and they are just as compositional as lenses
09:02:17 <simpson> timthelion: You keep forgetting that old data in a GC'd world can still be pointed to, if it didn't change!
09:02:19 <beaky> Data.Tree even has a nice function to pretty print your trees
09:02:24 <beaky> oops misclick
09:03:17 * edwardk hands the torch to quicksilver.
09:03:53 <edwardk> I have to go to work ;)
09:04:00 <timthelion> simpson: does ghc actually do this for you?
09:04:10 <quicksilver> yes, always, timthelion
09:04:26 <simpson> timthelion: Of course! f (x,y) = (x + 1, y)
09:04:26 <quicksilver> pointers to old data just stay there
09:04:29 <simpson> y is reused.
09:04:33 <quicksilver> that's the 'point' of this data model.
09:04:33 <simpson> Why wouldn't it be?
09:05:09 <timthelion> quicksilver: well if I have a vector of ints, and I replace one of them.  Is it O(1) or O(n)?
09:05:27 <ski_> (`n' being the length of the vector, presumably)
09:05:36 <timthelion> quicksilver: or perhaps O(index-of-changed-value)
09:05:47 <timthelion> ski_: yes.
09:05:52 <simpson> timthelion: Is the vector's size constant?
09:05:52 <quicksilver> a vector is not typical, timthelion
09:06:14 <quicksilver> and there are Vectors and MVectors not to mention UVectors
09:06:25 <quicksilver> I find your question underspecified :)
09:06:40 <c_wraith> if you're often updating a single element, the immutable versions of vector and array are approximately the worst data structures you can choose.
09:06:49 <timthelion> simpson: In this case yes, since comparing non constant sizes makes no sense, since malloc memcopy is going to be slow in C as well so compairing would be pointless.
09:07:15 <simpson> timthelion: Then it's O(1), obviously.
09:07:26 <timthelion> simpson: not if its an imutable vector.
09:07:44 <timthelion> simpson: without the ST monad you are incorrect.
09:07:44 * ski_ . o O ( "Typical for Annotated Prolog" <http://www.fernuni-hagen.de/pi8/typical>,<http://www.fernuni-hagen.de/wbs/typical-0.6/tap_examples/Demo/index.html> )
09:07:51 <simpson> timthelion: You just said that its size was constant. Even if I had to copy the entire thing (which I don't), it's a constant-size copy.
09:08:22 <simpson> And constant-size copies are O(your_constant), which is O(1).
09:08:23 <timthelion> simpson: which is O(n).  a constant-size copy is O(n) . at least on x86
09:08:41 <quicksilver> timthelion: O(n) apparently doesn't mean what you think it means.
09:08:44 <quicksilver> or 'constant' doesn't.
09:08:58 <kqr> beaky, if you don't need anything in particular from Maybe, i would probably use data Cell = Empty | Cross | Circle
09:08:59 <quicksilver> but let's not get too tangled up in notation.
09:08:59 <c_wraith> ok, if the two of you were working to communicate instead of miscommunicate, that'd move things along more quickly
09:09:02 <quchen> It's O(N), where N is a constant, namely the size of your vector.
09:09:09 <ski_> (simpson : i don't think it makes much sense to (effectively) rely on that the vector size not being larger than the address space ..)
09:09:10 <timthelion> quicksilver: O(n) means the operation(copying) times n(the length of the vector)
09:09:42 <ski_> (.. timthelion specified `n' as a parameter of the problem, and the size of the vector depends on this parameter)
09:09:50 <quicksilver> timthelion: no, it doesn't. It means that asymptotically the time the operation takes bounded by k1 . n, as n increases, for some fixed k1.
09:09:59 <simpson> ski_: (Today, we are pedants. Let us be pedantic.)
09:10:10 * ski_ nods
09:11:34 * hackagebot monad-primitive 0.1 - Type class for monad transformers stack with pirimitive base monad.  http://hackage.haskell.org/package/monad-primitive-0.1 (AlexeyKhudyakov)
09:11:36 * hackagebot mwc-random-monad 0.6 - Monadic interface for mwc-random  http://hackage.haskell.org/package/mwc-random-monad-0.6 (AlexeyKhudyakov)
09:11:38 * hackagebot histogram-fill 0.8.0.0 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.8.0.0 (AlexeyKhudyakov)
09:11:40 * hackagebot named-formlet 0.2 - A simple formlet library with named formlets.  http://hackage.haskell.org/package/named-formlet-0.2 (ChrisDone)
09:11:42 * hackagebot pgsql-simple 0.1.1 - A mid-level PostgreSQL client library.  http://hackage.haskell.org/package/pgsql-simple-0.1.1 (ChrisDone)
09:11:58 <timthelion> quicksilver: well, yes. so as the length of the vector increases, then it will take more time to copy :) goodbye
09:12:35 <ski_> :/
09:12:52 <trescenzi> in lists is there a better way to get to an index than !!? I'm looking for a way to get the contents in O(1) and it seems like you can't do this in haskell, at least with lists
09:13:21 <ski_> trescenzi : if you want to do random-access, don't use (linked) lists, right
09:13:32 <Eduard_Munteanu> trescenzi: right, you can't do it with lists, just like in any other language
09:13:35 <trescenzi> is there a random access data type in haskell?
09:13:43 <ski_> there's arrays
09:13:47 <ski_> and `Map's
09:13:53 <ski_> and more
09:14:15 <Eduard_Munteanu> Maps are O(log n), reasonable.
09:14:16 <trescenzi> oh ok I guess I'm just a total noob then. for some reason i assumed lists were the only array like structure in haskell
09:14:32 <trescenzi> Maps are just binary trees right?
09:14:35 <donri> trescenzi: there's vectors, which have other trade offs
09:14:45 <trescenzi> (in haskell)
09:14:50 <ski_> trescenzi : though, perhaps what you're wanting to do doesn't really require random-access, but can be done adequately with linear-access ?
09:15:08 <ski_> trescenzi : some kind of trees, iirc
09:15:11 <Eduard_Munteanu> Yeah, they're implemented as trees.
09:15:12 <donri> trescenzi: Map is, yes
09:15:20 <kqr> 17:48:45 timthelion | edwardk: that is true.  Though if you have a well designed reference based(not pointer based) langauge with deap object copying,
09:15:22 <kqr>                     | the same effect can be created(you can look ahead in a deap copied state).
09:15:22 <trescenzi> well i'm hoping to build my own hash map for a symbol table
09:15:37 <kqr> that almost sounds like a buggy, badly documented implementation of half of lenses
09:15:44 <trescenzi> and I didn't want to use lists because that kinda kills the O(1) goal
09:15:50 <donri> trescenzi: why, is it for fun? there are existing hash maps and tables for haskell
09:16:12 * ski_ was interested in hearing what timthelion's idea and reasoning amounted to
09:16:31 <trescenzi> It's for a compilers class I'm taking. I wanted to make it specilized for the data types i'm working with
09:16:36 <donri> trescenzi: typically hash maps are O(log n). hash tables are O(1)
09:16:42 <trescenzi> I don't really have to but I thought it might be a good excercise
09:16:54 <ski_> (modulo memory hierarchy)
09:17:20 <quicksilver> there are several reason to disagree with 'hash tables are O(1)'.
09:17:34 <quicksilver> one reason is that *calculating* a good hash (from a key) is not normally O(1).
09:17:39 <quicksilver> it's normally O(log n).
09:17:55 <kqr> quicksilver, where n is the size of the hash table??
09:18:07 <quicksilver> kqr: n is the number of distinct keys
09:18:08 <kqr> quicksilver, i think the point is that hash tables are O(1) with respect to the size of the hash table
09:18:19 <quicksilver> which is normally the szie of the table.
09:18:27 <quicksilver> kqr: I know. And that point is wrong.
09:18:31 <donri> yea, sorry i was talking about lookup and 'typically'
09:18:33 <quicksilver> there is no way to calculate the hash that fast ;)
09:19:02 <quicksilver> how are you going to calculate a good hash without looking at the data in the key?
09:19:10 <quicksilver> and if there are n distinct keys, each key must be log n bits long
09:19:11 <kqr> quicksilver, you're basically saying "a single asymptotic complexity value is a bad way to measure the effectiveness of data structures/algorithms"
09:19:13 <kqr> quicksilver, and yes, i agree
09:19:16 <donri> my understanding is that you normally don't count hashing cost for hash structures. maybe we should
09:19:29 <quicksilver> donri: you're right, but it's a very strange normally :)
09:19:42 <quicksilver> why on earth woudl you not count the cost of calculating the hash? it's part of the operation.
09:19:49 <donri> i agree
09:20:01 <kqr> quicksilver, you *do* count it, but it's a constant factor
09:20:02 <quicksilver> kqr: actually that wasn't my point (although it's a good point)
09:20:04 <kqr> quicksilver, thus, O(1)
09:20:06 <quicksilver> kqr: no, it's not constant.
09:20:13 <quicksilver> calculating a hash must be O(log n)
09:20:13 <trescenzi> the idea though is that it's just a single math function and from there you "have" the answer.
09:20:14 <kqr> quicksilver, (constant relative to the size of the table)
09:20:23 <trescenzi> but when you have collisions you have to keep looking
09:20:26 <quicksilver> kqr: no, it isn't. The bigger th table, the more different keys you must have.
09:20:37 <quicksilver> the more different keys you must have, the longer is must take to calculate a hash
09:20:42 <kqr> quicksilver, i guess O(1) refers to hash tables of fixed key size
09:20:43 <trescenzi> and that's where the extra time you might have
09:20:47 <quicksilver> if you have any hope of getting a different result for (most) keys.
09:20:55 <donri> although surely calculating the hash is linear to the key not the map/table
09:20:57 <quicksilver> kqr: yes. And if you have fixed key size, you have fixed table size :)
09:21:12 <kqr> quicksilver, ...true.
09:21:20 <quicksilver> if your key size is fixed to, say, 'n', then you have a table of size at most 2^n
09:21:23 <quicksilver> so your table size was constant
09:21:27 <trescenzi> quicksilver:  so you're saying we should take into account the time required to have a good enough of a hash function?
09:21:30 <quicksilver> and your analysis is no longer asymptotic.
09:21:32 <quicksilver> trescenzi: yes, I am.
09:22:04 <quicksilver> there is second argument, that ski alludes to, about memory hierarchies not being uniform and pointer access also being O(log n)
09:22:13 <kqr> quicksilver, i still think the general problem is that we're trying to mash too much information into a single number
09:22:23 <monochrom> you should not use aysmptotic complexity in practice
09:22:25 <quicksilver> and a third argument that kqr alluded to about asymptotic analysis not being that useful
09:22:29 <kqr> +1 monochrom
09:22:30 <sm> sordina: yes, I'm getting that error several times a day with http-conduit. Are you reusing your connection manager ? That made it much less frequent for me
09:22:41 <quicksilver> so, really, there are three entirely different reasons to dislike the 'hashing is O(1)' argument.
09:22:42 <c_wraith> yeah, hash tables have really good constant factors, even though they're not O(1)
09:22:59 <quicksilver> c_wraith: well coded tries can have pretty good constant factors too.
09:23:31 <aCube> tries? Do you mean trees or is tries another data structure?
09:23:35 <c_wraith> really, it's more like "binary trees have the worst constant factors of any structure people like to talk about"
09:23:43 <c_wraith> tries are not trees
09:23:50 <c_wraith> despite being pronounced the same :)
09:23:58 <kqr> aCube, tries is trees where the key decides the route to the node you're interested in
09:24:11 <monochrom> I am willing to agree that, sometimes, hash table insertion is 3 * log n and BST insertion is 30 * log n. Even then, some other times, it's the other way round. I am not willing to accept that hash table insertion is 3.
09:24:21 <kqr> aCube, so for a binary trie, the key could be LRLLRRL and you're supposed to go left, right, left, left right right left to get to the node of interest
09:24:34 <donri> originally trie was not pronounced the same as tree though :(
09:24:44 <donri> wait, other way around?
09:24:49 <aCube> tries is also the plural of try :D
09:25:09 <quicksilver> however, trie is the singular of tries.
09:25:15 <aCube> :)
09:25:18 <monochrom> any line of argument that says "hash table insertion is 3" must also lead to "BST insertion is 30" if you are honest
09:25:21 <quicksilver> and a different word from try which is also the singular of tries.
09:25:43 <donri> trie comes from retrieval, originally pronounced 'tree' but often pronounced 'try' these days?
09:26:10 <kqr> i pronounce trie pretty much like tree
09:26:16 <kqr> but then again, i'm not a native english speaker
09:26:22 <beaky> I get a kind mismatch error, what does that mean?
09:26:55 <typoclass> donri: i thought both pronunciations were very common *shrug*
09:27:06 <Clint> beaky: you're probably mismatching kinds
09:27:08 <monochrom> mywhee :: IO (Maybe)  would be a kind error
09:27:19 <beaky> oh
09:27:23 <monochrom> or mybad :: Int IO
09:27:29 <quicksilver> on memory-bandwitdh constrained machines (which is common these days) any operation which stays in cache is free compared to one which doesn't
09:27:38 <quicksilver> so an in-cache tree or trie will be faster than an out-of-cache hash
09:27:45 <beaky> I am fmaping into a functor of functors
09:27:46 <monochrom> (how do I convert Int IO to IO?)
09:27:51 <quicksilver> GHC is pretty good at keeping stuff in cache.
09:27:52 <beaky> so that's why I am getting it
09:28:09 <donri> i think i like 'try' because it's distinct from 'tree' and evocative of being a 'search' structure
09:28:10 <tac> unsafeNonsense :: Int IO -> IO
09:28:18 <kryft> monochrom: Heh, I read that as "a friendly error"
09:28:18 <kqr> beaky, kinds are types of types... sort of. Maybe is of kind `* -> *' (concrete type to concrete type -- takes a concrete type as an argument to produce a new concrete type) while Int is of kind `*' (concrete type)
09:28:37 <beaky> ah
09:28:39 <monochrom> the error is so kind!
09:29:31 <beaky> is there a double fmap?
09:29:38 <int-e> monochrom: You need to use unsafeCoerceKind#, obviously.
09:29:40 <donri> there's profunctors
09:29:44 <beaky> ah
09:30:12 <int-e> monochrom: (it's almost the same as unsafeCoerce, except that it may already segfault at compile time)
09:31:03 <donri> :t dimap
09:31:06 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
09:31:17 <donri> :t fmap
09:31:20 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:31:43 <donri> beaky: is that what you wanted?
09:31:48 <beaky> yes :D
09:32:08 <beaky> :t <$> . <$>
09:32:10 <lambdabot> parse error on input `<$>'
09:32:12 <donri> used extensively in lens
09:32:21 <beaky> :t fmap . fmap
09:32:22 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:32:27 <kqr> beaky, parentheses around <$>
09:32:30 <beaky> ah
09:32:48 <mhr_> I asked a question on #yi, but it seems like no one's on there, so I figured I'd ask here... I'm having trouble installing yi.  I'm following the directions located at http://www.haskell.org/haskellwiki/Gtk2Hs/Installation#Windows, but my terminal/command prompt just gives this errors: http://pastebin.com/tBrQ9r03.  Can you help me?
09:32:52 <mauke> The paste tBrQ9r03 has been copied to http://hpaste.org/83312
09:33:10 <donri> > (fmap.fmap) (+1) (Just (Just 2))
09:33:13 <lambdabot>   Just (Just 3)
09:33:23 <donri> not the same as dimap
09:34:03 <kqr> > dimap (+1) (*2) $ Either 4 7
09:34:06 <lambdabot>   Not in scope: data constructor `Either'
09:34:06 <lambdabot>  Perhaps you meant `Other' (importe...
09:34:12 <kqr> oh
09:34:15 <kqr> i'm stupid
09:34:16 <kqr> never mind me :D
09:34:21 <beaky> ah
09:34:28 * kqr still trying to come up with an example of a profunctor
09:34:41 <beaky> profunctors are monoids in the category of functors?
09:36:03 <glguy> kqr: (->) ?
09:37:12 <kqr> glguy, possibly, but the abstraction there is way over my head
09:37:48 <kqr> i still have trouble thinking of function types as actual types which can be composed and all
09:39:33 <beaky> functions are just boxes
09:39:42 <beaky> that contain something
09:40:15 <beaky> so given a function a -> b, if you fit in a key of type a, it opens up to give you a thingy of type b :D
09:40:16 <donri> > dimap (+1) (*2) (+3) 4
09:40:19 <lambdabot>   16
09:41:19 <donri> i guess + and * are bad examples here
09:41:44 <kqr> by the way
09:41:50 <kqr> :t dimap
09:41:51 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
09:42:05 <kqr> is it going backwards from b to a?
09:42:08 <kqr> or am I missing something?
09:42:24 <`ramses> kqr: that's contravariance
09:42:31 <kqr> i would have understood if p f g :: p a c -> p b d
09:42:54 <kqr> woops dimap f g*
09:43:35 <glguy> kqr: bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
09:43:47 <kqr> right
09:43:53 <kqr> that sort of makes sense
09:44:03 <unK_> :i dimap
09:44:13 <glguy> kqr: If you want to understand dimap better, maybe start with
09:44:14 <glguy> contramap :: Contravariant f => (a -> b) -> f b -> f a
09:44:24 <kqr> that just blows my mind
09:44:25 <unK_> what package defines that?
09:44:41 <glguy> "contravariant"
09:45:03 <glguy> newtype MakesInt a = MakesInt (a -> Int)
09:45:21 <monochrom> "box" is really ambiguous. "functions are boxes" decreases information and understanding.
09:45:31 <glguy> if you have a   (b -> a), you can turn a MakesInt a -> MakesInt b
09:47:10 <Philippa> monochrom: "functions are black boxes" can be useful, though
09:47:42 <kqr> glguy, how would you do that?
09:48:06 <monochrom> I agree that "black box" is less ambiguous than "box"
09:48:45 <beaky> that contain something
09:48:47 <kqr> monochrom, you always decrease information with analogies
09:48:48 <donri> i suspect that thinking of functions as pitch black is part of what leads people to having a hard time reasoning about them as first class values that you can do things like dimap over
09:48:52 <kqr> monochrom, not necessarily understanding though
09:49:05 <glguy> kqr: contramap f (MakesInt m) = MakesInt (\a -> m (f a))
09:49:06 <kqr> monochrom, it depends a little on what you're trying to understand
09:50:28 <kqr> glguy, i suspect i'm a little too distraught to understand this right now
09:50:31 <kqr> glguy, thanks for the effort anyway
09:50:51 <glguy> kqr: type it into a source file and play with it a bit when you have time
09:50:58 <glguy> see if you can make sense of the types
09:51:30 <`ramses> kqr: if you have a function that turns as into Ints, you can turn that into a function that turns bs into Ints using a function that turns bs into as. It's just composition
09:51:38 <kqr> glguy, i have made a note about reading and playing a little
09:51:42 <kqr> `ramses, that sort of makes sense yeah
09:52:31 <hpaste> glguy pasted “MakeInt contramap” at http://hpaste.org/83315
09:53:03 <`ramses> kqr: it looks pretty strange at first, but actually it is quite simple once you see what's going on. Somehow we appear to be biased towards viewing things as covariant :)
09:53:42 <kqr> `ramses, ...i'm afraid to ask, but... covariant?
09:54:09 <kqr> glguy, thanks, i see it now!
09:54:09 <Philippa> kqr: the other way round to contravariant
09:54:38 <`ramses> kqr: basically, a type is covariant in a type if it "produces" values of that type, and contravariant if it "consumes" instead. (a -> b) is covariant in b and contravariant in a
09:54:56 <`ramses> kqr: that's my intuitionistic understanding
09:55:17 <`ramses> (is that a word? :) intuitive is what I meant I guess)
09:55:33 <Philippa> it's a word with a technical meaning
09:55:45 <kqr> i don't intuit :(
09:55:50 <`ramses> yeah, not what I meant to say probably :)
09:56:34 <kqr> oh
09:56:36 <kqr> maybe i do see it now
09:57:53 * Philippa wishes the Duplicate Instances error message was just subtly more informative. Like, say, telling you which bit of the instance it's actually complaining about being duplicated
09:57:53 <beaky> :t (<$>) <$> (<$>)
09:57:55 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:58:07 <beaky> :t (.) . (.)
09:58:09 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:58:20 <`ramses> beaky: (.) == fmap
09:58:24 <beaky> oh
09:58:36 <`ramses> (in lambdabot, that is)
09:58:39 <beaky> I wish . was fmap on my thing; it's more concise than a dollar sign
09:58:44 * geekosaur just got caleskelled over in #xmonad too :)
09:59:09 <`ramses> beaky: import Prelude hiding ((.)); (.) = fmap
09:59:17 <beaky> wow nice
10:00:21 <beaky> :t (<$>) &&& (<$>)
10:00:23 <lambdabot> (Functor f1, Functor f) => (a -> b) -> (f a -> f b, f1 a -> f1 b)
10:01:27 <beaky> :t (***) &&& (&&&)
10:01:28 <lambdabot> Arrow a => a b c -> (a b' c' -> a (b, b') (c, c'), a b c'1 -> a b (c, c'1))
10:01:44 <beaky> crazy type signature
10:07:37 <beaky> :t (***) . (&&&) . (<$>) . (&&&) . (***)
10:07:39 <lambdabot> (Functor f, Arrow a) => a b c -> (b' -> c') -> (f (a b'1 c'3 -> c'2) -> c'1, b') -> (f (a b'1 c'3 -> c'2) -> (f (a b'1 c'3 -> (a (b, b'1) (c, c'3), c'2)), c'1), c')
10:07:44 <c-ab> :t (>>---->)
10:07:46 <lambdabot> parse error (possibly incorrect indentation)
10:08:15 <beaky> :t (***) . (&&&) . (<$>) . (>>=) . (<$>) . (&&&) . (***)
10:08:16 <lambdabot> (Functor f1, Functor f, Arrow a) => a b1 c -> (b' -> c') -> (f (f1 (a b'1 c'3 -> (a (b1, b'1) (c, c'3), c'2)) -> f1 (a b'1 c'3 -> c'2) -> b) -> c'1, b') -> (f (f1 (a b'1 c'3 -> (a (b1, b'1) (c, c'3),
10:08:16 <lambdabot>  c'2)) -> f1 (a b'1 c'3 -> c'2) -> b) -> (f (f1 (a b'1 c'3 -> c'2) -> b), c'1), c')
10:08:34 <beaky> . is very powerful
10:11:45 <kqr> and very simple.
10:14:02 <ski_> int-e : where's `unsafeCoerceType#' ?
10:14:20 <elliott> ski_: UnsafeCoerce :: k -> j?
10:14:34 <elliott> umm :: UnsafeCoerce (->); umm = undefined
10:15:09 <ski_> well, apparently `unSafeCoerceKind#' could be used to effect `Int IO -> IO'
10:15:12 <luite> has anyone here been able to build GHC HEAD on OS X in the past 4 weeks?
10:16:02 <elliott> hehe, unSafe
10:16:06 <elliott> extreme camelcase
10:16:23 <ski_> a happenstance mishap
10:18:58 <ski_> hm, `Profunctor's are just difunctors ?
10:19:19 <ski_> @type dimap
10:19:21 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
10:19:41 <int-e> ski_: It's a work of fiction, I hope.
10:20:45 <glguy> ski_: http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html , When I wrote about coends a while back I made up a term 'difunctor'. More recently it was pointed out to me that the correct word for this concept is 'profunctor', but unfortunately my knowledge came from MacLane which mentions that word nowhere.
10:20:46 <ski_> i'd surmise so
10:20:58 <elliott> ski_: yes
10:21:26 <ski_> hm, doesn't MacLane mention "difunctors" ?
10:22:53 <danharaj> ski_: it's not in the index.
10:23:14 <ski_> hmm
10:23:29 <ski_> i'm all but certain i've seen the word "difunctor" in some paper
10:24:16 <ique> I'm trying to create an `instance FromJSON Day` in Aeson, anyone have any experience with this? I know how to produce a Maybe Day, but I don't know how to go from Maybe Day to Parser Day
10:24:31 <ski_> (`F' being a difunctor from `C' and `D' to `E' in case it is a functor from `C^op * D' to `E')
10:25:24 <ski_> (so if dpiponi made it up, i don't think he's alone in that)
10:25:54 <danharaj> ski_: just looked at the section on dinaturality in Maclane and he just refers to such functors as bifunctors on C^Op x D -> E
10:26:46 <ski_> ok
10:27:26 <elliott> ski_: googling difunctor finds haddocks that cite a paper
10:27:33 <elliott> This module defines difunctors (Meijer, Hutton, FPCA '95), i.e. binary type constructors that are contravariant in the first argument and covariant in the second argument.
10:28:28 <Taneb> (difunctor = profunctor?)
10:30:40 <ski_> ah, Bananas in Space :)
10:31:26 * ski_ recalls reading that long ago
10:31:59 <ski_> Taneb : apparently
10:32:57 <ski_> (i wonder why nobody told me .. here i was thinking all the time these "profunctors" must be something slightly different (perhaps more laws ?), since otherwise they'd obviously not have needed a new name)
10:38:43 <ParahSailin> does 'instance Monad ((->) r)' mean function with result r is instance of Monad?
10:38:54 <Taneb> No
10:39:17 <Taneb> It means functions with domain r is an instance of Monad
10:39:29 <Taneb> Because ((->) r) is roughly (r ->)
10:40:27 <fizbin> Just as ((-) 5) is the same as (5 -)
10:40:27 <applicative_> ParahSailin: sometimes people call it the Reader or Environment monad
10:40:46 <ParahSailin> so a function :: r -> a -> r could be an instance of Monad?
10:41:22 <applicative_> no, there r appears both before and after an arrow
10:41:36 <fizbin> No, such a function would be data of type  m (a -> r)
10:41:51 <applicative_> if you wrote newtype P a r = P (r -> a -> r) you couldnt a monad
10:41:59 <fizbin> Also, "instance" means something in Haskell that I think is not what you mean.
10:42:06 <applicative_> I mean, instance Monad (P a)
10:42:38 <elliott> ParahSailin: it depends what you mean by "an instance of Monad"
10:42:47 <applicative_> yes of course
10:42:55 <elliott> values, such as functions, can't be instances of typeclasses; only types can. this might seem like pedantry but I think it may be the source of this confusion
10:43:05 <elliott> (or rather, only type constructors can)
10:43:10 <ParahSailin> will be pattern matched if for example, i msum a list of them
10:43:32 <elliott> ((->) r) is a Monad; since (r -> a -> r) matches the pattern ((->) r) -- rewrite as ((->) r (a -> r)) -- you can use the operations of the ((->) r) Monad instance on values of that type
10:43:39 <elliott> but maybe it will not do what you expect
10:43:41 * applicative_ is getting a little confuste
10:43:45 <fizbin> > (join +) 15
10:43:46 <applicative_> confused too
10:43:47 <lambdabot>   No instance for (GHC.Num.Num (m0 (m0 a0) -> m0 a0))
10:43:47 <lambdabot>    arising from a use o...
10:44:07 <applicative_> > join (+) 15
10:44:09 <lambdabot>   30
10:44:14 <geekosaur> fizbin, without parens around the + that is not what you think it is
10:44:16 <danharaj> :t join (+)
10:44:16 <elliott> similarly: (State s) is a monad.
10:44:17 <lambdabot> Num a => a -> a
10:44:29 <bitonic> elliott: what do you mean ‘only type constructors can’?  are you talking about std Haskell only?
10:44:35 <elliott> since (State s (State a s)) matches the pattern of the instance, you can use the operations on it
10:44:46 <elliott> bitonic: I mean that in Monad m, m is of kind * -> *
10:44:55 <beaky> hello
10:44:55 <elliott> people often use "type" to mean things of kind *, so I wanted to disambiguate
10:45:05 <fizbin> geekosaur: Oh, right. I meant (join (+)) but what I wrote was equivalent to ((+) join)
10:45:33 <bitonic> elliott: oh OK, never heard ‘type constructor’ used to mean * and t -> t.  if anything the opposite :P
10:45:38 <applicative_> yeah, type constructor is a lame word for it; too bad there isn't a short intuitive way of saying 'thing of kind * -> *'
10:45:53 <applicative_> hey beaky
10:45:56 <elliott> bitonic: hm?
10:46:35 <elliott> bitonic: I don't quite understand what you mean, I was explicitly avoiding implying m was of kind * there
10:46:47 <applicative_> a type constructor is whatever word you put next after newtype ... or data ...
10:46:49 <bitonic> elliott: oh you were talking about Monad specifically
10:46:52 <fizbin> > join (^) 5
10:46:54 <lambdabot>   3125
10:47:08 <applicative_> "Int" is a type constructor
10:47:22 <elliott> applicative_: perhaps "type of one argument", though that's perhaps misleading, since we say "factorial is a function of one argument", not "factorial is an Integer of one argument"
10:47:23 <ski_> bitonic : i only use "type constructor" for stuff like `Int',`Maybe',`IO',`(->)',`Either',`StateT', but some people use it for stuff like `IO',`Either [Int -> Bool]', but not for `Int' (i.e. for what i would call functional/parametric types)
10:47:59 <elliott> ski_: yeah, excluding the base case is ugly, but it seems to be the most standard terminology here :/
10:47:59 <beaky> :t join
10:48:00 <lambdabot> Monad m => m (m a) -> m a
10:48:05 <ski_> (those people then tend to use "type" for types (in my sense) of kind `*')
10:48:18 <bitonic> ski_: yes, I use it in the same way, with `type function' meaning something of kind `k -> *'
10:48:22 <elliott> hm, so you equate "type" and "type constructor"?
10:48:23 <fizbin> ParahSailin: The examples with "join" are taking advantage of the fact that ((->) r) is  a monad. "join" takes something of type m (m a), where m is a monad.
10:48:30 <bitonic> sorry, `* -> k'
10:48:35 <elliott> when I hear "type function" I expect to hear about type families, not regular data types, I think
10:48:41 <danharaj> join for ((->) r) is diagonalization
10:48:41 <applicative_> elliott: yeah, every expedient seems to have something wrong with it; only the appeal to the kind system is really precise, but it seems it shouldn't be necessary to grasp the kind system's symbolism
10:48:42 <bitonic> or even `k -> k'
10:48:51 <ski_> elliott : in my mind, it makes sense to have "type constructor" consistent with "data constructor"
10:49:03 <applicative_> elliott: yeah type function has been taken unfortunately.
10:49:06 <danharaj> Which is probably my favorite instance of join.
10:49:12 <danharaj> It's so nice. :3
10:49:16 <elliott> applicative_: yeah. though, you have to understand it in the end, so maybe the Functor/Monad/etc. hierarchy is the best place to start bringing kinds up :)
10:49:19 <fizbin> ParahSailin: So if ((->) Int) is a monad, then join can take something of type (Int -> Int -> x) and return a thing of type (Int -> x)
10:49:25 <ski_> (e.g. `Node Int' (of type `Forest Int -> Tree Int') is not a data constructor. `Node' is one)
10:49:38 <elliott> awkward to have to give a mini kind tutorial on IRC just to resolve ambiguities about what "a monad" means, though :(
10:50:05 <danharaj> What is awkward is how few languages have polymorphism over kinds other than *
10:50:13 <elliott> ski_: by "Node Int", do you mean "Node 123"?
10:50:28 <ski_> sorry, yes
10:50:31 <applicative_> elliott: yes, I know that some people have had the 'aha' experience with functor/monad when they were introduced to the * , * -> * , * -> * -> * symbolism, so maybe I'm wrong to count it as too esorteric
10:50:41 <applicative_> esoteric rather
10:50:45 <fizbin> elliott: It gets worse when you have a philosopher who keeps trying to turn "Monad" as used in Haskell of category theory into the concept from Greek philosophy.
10:51:08 <elliott> ski_: ah, I see. you exclude "Either ()" from being a type constructor
10:51:13 <ski_> yes
10:51:14 <elliott> but not from being a type
10:51:33 <applicative_> maybe for tutorial purposes we should throw in the kind business sooner than we do.
10:51:48 <ski_> elliott : i call the types of kind `*' (perhaps kinds `#',`(#)' should be counted as well) "concrete types#
10:51:58 <applicative_> yeah, that seems to be the only correct way to use 'type constructor
10:52:10 <ski_> elliott : a synonym is "inhabitable types" :)
10:52:21 <fizbin> What's the difference between kind * and kind # ?
10:52:38 <c_wraith> * is the kind of normal types
10:52:44 <monochrom> recall that the Haskell 2010 Report itself writes like "the Maybe type", "the IO type"
10:52:45 <danharaj> # is GHC only
10:52:49 <applicative_> I call things of kind * types, following c. mcbride
10:52:50 <c_wraith> # is the kind of special internal types in GHC
10:53:03 <ski_> fizbin : values of type `#' are strictly computed (no bottoms can be passed around), there's syntactic restrictions on how you can treat such values
10:53:06 <fizbin> Okay, and kind (#) ?
10:53:20 <geekosaur> "concrete type" is a bit confusing too; "abstract type" to my mind means something like a or Foo a => a, not IO (although "IO a" works, so I can see it)
10:53:23 <ski_> fizbin : implementations tend to have values of types of kind `#' unboxed
10:53:23 <elliott> # means unboxed types, broadly
10:53:31 <elliott> like Int# or (# String, Int #)
10:53:48 <elliott> where Int is represented (in GHC) as a pointer, Int# is represented as the integer directly
10:54:16 <elliott> and where (a,b) is a pointer to two pointers (one to a, one to b), (# a, b #) is directly represented as those two pointers (or if a and b are unboxed themselves, directly as those two values)
10:54:16 <ski_> fizbin : e.g., polymorphic operations can't be instantiated at an unboxed type
10:54:34 <elliott> (e.g. (# Int#, Int# #) -- assuming I'm remembering correctly and you can do unboxed tuples of unboxed types, which I think you can -- is just represented as two integers)
10:54:41 <elliott> internally Int is implemented in terms of Int#, etc.
10:54:56 <ski_> fizbin : `(#)' is the kind of unboxed tuples
10:55:04 <elliott> oh, hm, they have a different kind?
10:55:06 <applicative_> newtype Int = Int Int#
10:55:07 <ski_> (unboxed tuple types)
10:55:22 <ski_> @kind (# Int# , Int #)
10:55:24 <lambdabot>     Not in scope: type constructor or class `Int#'
10:55:24 <lambdabot>     Perhaps you meant one of these:
10:55:24 <lambdabot>       `Int' (imported from Data.Int), `Int8' (imported from Data.Int)
10:55:31 <elliott> I think a lot of these kinds got renamed to be words instead recently too. ambiguity abounds
10:55:36 <fizbin> @kind Int#
10:55:37 <lambdabot>     Not in scope: type constructor or class `Int#'
10:55:38 <lambdabot>     Perhaps you meant one of these:
10:55:38 <lambdabot>       `Int' (imported from Data.Int), `Int8' (imported from Data.Int)
10:55:43 <ski_> @kind (# GHC.Prim.Int# , Int #)
10:55:44 <lambdabot> (#)
10:56:09 <fizbin> @kind (# Int, Int #)
10:56:11 <lambdabot> (#)
10:56:43 <ski_> @kind (# Int , (# Int , Int #) #)
10:56:45 <lambdabot>     Kind mis-match
10:56:45 <lambdabot>     The second argument of an unboxed tuple should have kind `ArgKind',
10:56:45 <lambdabot>     but `(# Int, Int #)' has kind `(#)'
10:56:51 <ski_> @kind (# , #)
10:56:53 <lambdabot> ArgKind -> ArgKind -> (#)
10:58:33 <ski_> i'm not sure why it displays it with `AnyKind', rather than `??', as it used to
10:58:58 <elliott> ArgKind, there
10:59:23 <applicative_> my ghci says 'OpenKind'
10:59:30 <lispy> http://stackoverflow.com/questions/3034264/haskell-weird-kinds-kind-of-is
10:59:32 <applicative_> (# , #) :: OpenKind -> OpenKind -> #
10:59:33 <ski_> see <http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes#KindsareTypes> for the subkinding system
10:59:45 <lispy> I think graph in that answer explains GHC's unboxed kinds really well
11:00:18 <monochrom> subkinding
11:00:23 <ski_>  @kind (->)
11:00:25 <ski_>  (->) :: ?? -> ? -> *
11:00:54 <applicative_> funny, I cant get my ghci to say that anymore
11:01:00 <applicative_> (->) :: * -> * -> *
11:01:22 <ski_> i suspect either some kind of kind defaulting, or a hack
11:01:50 <lispy> With all the recent work to expand kinds in GHC, does that info I linked to still hold?
11:01:52 <ski_> (to make people less anxious about seeing `(->) :: ?? -> ? -> *', which it used to say)
11:01:55 <byorgey> the kind system has changed a bit, and the display of the kind of (->) has been improved
11:02:21 <byorgey> lispy: I don't think it holds in exactly that form.  though it is probably still close.
11:02:36 * ski_ also vaguely recall seeing a `!' kind somewhere, but it has probably disappeared
11:03:03 <byorgey> for one thing the names of the kinds have changed to things like 'ArgKind' to make them more readable.
11:03:04 <lispy> byorgey: I'm not up on the terminology, the new 'things' are called constraint kinds?
11:03:09 <applicative_> if I define let f x = I# x , I get f :: Int# -> Int
11:03:10 <byorgey> now you don't have to remember what ?? means, etc.
11:03:19 <byorgey> lispy: that's one new thing.
11:03:30 <lispy> byorgey: Ah, are there more?
11:03:31 <ski_> byorgey : oh, i thought that was an omission/bug (showing "internal name")
11:03:44 <byorgey> lispy: yes
11:04:01 <ski_> is there more than one constraint kind ?
11:04:04 <lispy> byorgey: do you know them well enough to give a brief description or otherwise enumerate them?
11:04:10 <byorgey> lispy: no
11:04:13 <lispy> :)
11:04:14 <applicative_> I see, but the claim (->) :: * -> * is surely just plain wrong
11:04:21 <ski_> lispy : `Eq :: * -> Constraint'
11:04:32 <byorgey> ski_: no.  The name of the extension is silly.
11:04:37 <applicative_> or is (Int# -> Int) using a different -> so to speak
11:04:50 <ski_> byorgey : which extension name ?
11:04:52 <byorgey> applicative_: indeed,  (->) :: * -> *  is quite wrong =)
11:04:58 <byorgey> ski_: 'ConstraintKinds'
11:05:03 <int-e> applicative_: where'd you see that claim?
11:05:13 <applicative_> int-e: ghci just told me
11:05:18 * danharaj wonders about KindConstraints
11:05:20 <byorgey> I think applicative_ probably meant  (->) :: * -> * -> *
11:05:24 <applicative_> even with every extension I could think of
11:05:28 <byorgey> which is only slightly wrong.
11:05:35 <byorgey> but wrong in a convenient way.
11:05:37 <applicative_> oh sorry, like byorgey said, thats what I mean
11:05:39 <applicative_> meant
11:05:59 <byorgey> danharaj: we're getting those soon.
11:06:03 <lispy> byorgey: that way is wrong in a very Haskell98-would-say-it-like-that way right?
11:06:33 <byorgey> lispy: indeed. =)  So in that sense it's not wrong.  It just doesn't tell you the whole story re: the way GHC works.
11:06:40 <lispy> My understanding is that the language definition only mentions * as a kind not all the ghc specific kinds
11:06:46 <ski_> byorgey : i've been bothered by the `PolyKinds' name -- afaiu, there's no polymorphic kinds involved (though indeed polymorphic types, and some more stuff)
11:06:55 <applicative_> can it be that * is now a genus covering # ?
11:06:58 <elliott> byorgey: we are?
11:07:02 <danharaj> byorgey: weird. I would much rather have quantified constraints and implications between constraints. :3
11:07:04 <geekosaur> most of the ghc specific ones are gone now, no?
11:07:06 <danharaj> iirc both are already ghc tickets.
11:07:09 <elliott> class Foo (k :: Kind) (t :: k) or something?
11:07:12 <geekosaur> (as of 7.6 at least?)
11:07:21 <lispy> applicative_: I don't think it can be the case because * is always boxed, IIRC
11:07:25 <byorgey> elliott: we already have that.
11:07:31 <byorgey> I mean equality constraints on kinds.
11:07:50 <elliott> well, the quantification is explicit there... but bad example
11:07:56 <byorgey> ski_: there are actually polymorphic kinds involved.
11:08:04 <ski_> lispy : well, `k0 -> k1' is also a kind, for any kinds `k0',`k1' (which is more than you get in the MLs e.g.)
11:08:29 <ski_> byorgey : there's kinds `k' involved with `k :: forall s. ..s..' ?
11:08:36 <applicative_> lispy: yeah thats what I thought, its just that the kind query for (->) tells me (->) :: * -> * -> * though it reconizes e.g. the Int wrapper as having type I# :: Int# -> Int
11:08:58 <byorgey> ski_: what? a polymorphic type isn't a type t with  t :: forall ...
11:08:58 <ski_> (note that `reverse' is a polymorphic value. `forall a. [a] -> [a]' is not a polymorphic type)
11:09:14 <sproingie> there any good haskell opengl example apps out there not using glut?
11:09:15 <byorgey> ski_: oh, I see what you're saying.
11:09:39 <applicative_> byorgey: what is ski saying
11:09:40 <ski_> one could say `forall a. [a] -> [a]' is a universal type, if one wanted to
11:09:55 <sproingie> the whole mainloop thing of glut is dictating a lot more about my design than i care for
11:10:00 <byorgey> ski_: it's just an issue of terminology then.  Some would call  forall a. [a] -> [a] a polymorphic type.
11:10:20 <ski_> if we had `Flip :: forall k0 k1. (k0 -> k1 -> *) -> k1 -> k0 -> *', then `Flip' would be a polymorphic type
11:10:20 <byorgey> ski_: you might disagree that is correct terminology (and I would tend to agree) but in fact it is used that way.
11:10:31 <byorgey> and that is the sense in which we now have polymorphic kinds.
11:10:31 <elliott> perhaps the extension should have been named KindPoly to satisfy both factions :)
11:10:33 <int-e> applicative_: funny. this was already changed in ghc 7.4.1 (or .2) -- since then it says * -> * -> * for :k (->) and doesn't accept :k (->) Int#
11:10:38 <elliott> (as in, polymorphism over kinds)
11:10:42 <ski_> byorgey : *nod*, as i suspected
11:11:05 <byorgey> ski_: however, once the paper "down with kinds" gets implemented we can have true polymorphic kinds =)
11:11:22 <ski_> (afaiu, calling `reverse' polymorphic was prior to some calling `forall a. [a] -> [a]' polymorphic)
11:11:28 <byorgey> (the implementation is in fact almost done, AIUI)
11:11:35 <ski_> byorgey : *nod*
11:11:55 <applicative_> int-e: yes I see.  It seems that the kind querying machinery isn't telling us the whole story...
11:11:58 <lispy> sproingie: yes I have some example code that avoids glut
11:12:04 <Sgeo> o.O
11:12:08 <lispy> BTW, where do FP programmers look for jobs listings these days?
11:12:14 <elliott> byorgey: ah, is that paper's stuff getting into GHC?
11:12:17 <elliott> interesting
11:12:18 <Sgeo> Write Yourself A Scheme in 48 Hours seems to start off with a monad tutorial
11:12:23 <Sgeo> For people who don't know Haskell
11:12:25 <ski_> byorgey : e.g. i know some people call `Maybe' (with kind `* -> *') polymorphic, but i want to call it parametric, or a type function
11:12:25 <lispy> I thought I might spam haskell-cafe saying we're hiring, but is there a better place?
11:12:27 <byorgey> elliott: yes
11:12:44 <elliott> lispy: comonad.com has job listings from some FP site at the top, at least
11:12:44 <byorgey> ski_: sure, that makes sense to me
11:12:51 <sproingie> lispy: nice, got a link to it?
11:12:53 <lispy> sproingie: https://github.com/dagit/nehe-tuts
11:12:57 <lispy> sproingie: also look on hackage
11:12:58 <elliott> perhaps there would be reasonable (though IIRC it didn't have any haskell jobs when I clicked out of curiosity)
11:13:03 <sproingie> thanks :)
11:13:03 <elliott> oh hmm. it no longer does?
11:13:10 <lispy> sproingie: the current version use OpenGLRaw and glfw-b
11:13:12 <elliott> oh, it does: http://comonad.com/reader/2013/algebras-of-applicatives/
11:13:25 <elliott> doesn't haskellers.com have something too?
11:14:10 <ski_> byorgey : ideally, i'd like to be able to have `Flip :: forall k0 k1 k2. (k0 -> k1 -> k2) -> k1 -> k0 -> k2'  -- but i'm not sure how that'd work with data constructors
11:14:28 <byorgey> ski_: hmm, right, I don't know
11:14:47 <applicative_> lispy: there's this one http://functionaljobs.com/ which seems reputable
11:14:52 <ski_> byorgey : one possibility is `newtype k (Flip f b a) = MkFlip (k (f a b))' -- but this would require some checks on the body, to ensure soundness
11:14:53 <elliott> yeah, that is the comonad.com one
11:14:54 <lemao> byorgey: is there a specific branch where "down with kinds" paper is being implemented?
11:14:57 <elliott> (re applicative_)
11:15:22 <sproingie> lispy: excellent, OpenGLRaw is what i was hoping to use
11:15:34 <sproingie> looks like it has a lot more support for modern stuff
11:15:36 <elliott> oh, hah. I click on http://www.haskellers.com/jobs and see lispy is ahead of me
11:15:48 <byorgey> lemao: I don't know, I can ask Richard once he gets back
11:15:53 <elliott> and also links to the site me / applicative_ mentioned, and another
11:16:06 <lispy> sproingie: it does although my examples do not take advantage of it
11:16:11 <sproingie> nice, lots of callbacks but no mandatory mainloop
11:16:15 <ski_> so then we get `MkFlip :: forall_kind k0 k1 k2. forall (k :: k2 -> *) (f :: k0 -> k1 -> k2) (a :: k0) (b :: k1) -> k (f a b) -> k (Flip f b a)'
11:16:18 <applicative_> oh yeah, it's the same as the comonad.com one; I dimly remember e.g. jane street using it, but also places that wanted php but with an interest in ....
11:16:31 <lispy> sproingie: please file bug reports if the code gives you any troubles :)
11:16:35 <sproingie> lispy: yah the nehe stuff is ancient but it works for showing how to use the api anyway
11:16:52 <lispy> sproingie: exactly. That stuff is meant to get people up and running.
11:17:07 <lispy> Thanks everyone for pointers as to where you look for jobs
11:17:32 <applicative_> lispy: I dont think there's any reason not to spam haskell cafe and link on reddit/r/haskell others have done it
11:18:57 <Sgeo> o.O at Rank2Types being meaningless now
11:19:02 <Sgeo> (It's just RankNTypes)
11:27:40 <lispy> applicative_: spammed it, I have!
11:29:53 <applicative_> looks good.  it's at least as interesting as an esoteric conference announcement or post doc
11:37:08 <ski_> @type dimap . fmap
11:37:09 <lambdabot> (Functor f, Profunctor p) => (a -> b) -> (c -> d) -> p (f b) c -> p (f a) d
11:37:15 <ski_> @type fmap . dimap
11:37:17 <lambdabot> (Functor f, Profunctor p) => (a -> b) -> f (c -> d) -> f (p b c -> p a d)
11:37:24 <ski_> @type fmap .: dimap
11:37:26 <lambdabot> (Functor f, Profunctor p) => (a -> b) -> (c -> d) -> f (p b c) -> f (p a d)
11:37:39 <ski_> @type dimap . dimap
11:37:40 <lambdabot> (Profunctor p1, Profunctor p) => (a -> b) -> (c -> d) -> p (p1 b c1 -> p1 a d1) c -> p (c1 -> d1) d
11:37:49 <ski_> @type dimap .: dimap
11:37:51 <lambdabot> (Profunctor p1, Profunctor p) => (a -> b) -> (c1 -> d1) -> (c -> d) -> p (p1 a d1) c -> p (p1 b c1) d
11:42:23 <dennda_> I am a haskell beginner and was watching this talk the other day, which is a few years old: http://www.youtube.com/watch?v=NWSZ4c9yqW8
11:42:44 <dennda_> What has happened since then? Have those improvements made their way into GHC, or has it been a failed experiment?
11:44:26 <ski_> <http://www.haskell.org/ghc/docs/latest/html/users_guide/lang-parallel.html#id653742>,<http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell>
11:44:39 <dennda_> gracias
11:48:29 <Cale> dennda_: It's still somewhat embryonic, but it hasn't been given up on, as far as I know.
11:49:41 <notdan> what's the difference between 'type family' and 'data family'?
11:50:12 <ski_> the latter are injective
11:50:13 <Cale> notdan: It's similar to the difference between type and data. A data family is forced to be injective.
11:50:35 <Cale> When you write instances for a data family, you define new data constructors.
11:50:45 <notdan> Hm, sorry, I don't think I understand what 'injective' means in the context of types?
11:50:56 <notdan> Ah, you mean.. like tagged?
11:51:06 <notdan> Altho tagged is probably the wrong word here
11:51:39 <ski_> notdan : if you define `type Foo a = Int', then `Foo Int' and `Foo String' is the same type
11:51:52 <Cale> If you have a data family DF :: * -> *, and it has instances for types A, B, then DF A and DF B cannot be the same type
11:52:02 <ski_> (even though `Int' and `String' are different types)
11:52:21 <Cale> (given that A and B are not the same type)
11:52:25 <ski_> notdan : for an injective type `Foo', if you know that `Foo A' is equal to `Foo B' (same type), then you also know that `A' is equal to `B'
11:52:54 <aCube> Is there some library that provides fixed-size (size known at compile time) arrays? Something like a tuple, but providing a nice array-like interface?
11:53:09 <ski_> or, as Cale says, if you know `A' is not equal to `B', then you know `Foo A' is not equal to `Foo B'
11:53:41 <notdan> Ah
11:53:49 <notdan> Thanks ski_ , Cale
11:54:27 <notdan> But I am not sure how it's similar to type vs data. Surely, you can have a datatype declared with data which is not injective?
11:55:42 <ski_> nope
11:56:34 <notdan> Hm.. okay, what about 'data A b = C'
11:56:44 <notdan> Oh wait, sorry
11:56:47 <notdan> I got it now
11:57:29 <ski_> Main> [C :: A Int,C :: A Bool]
11:57:49 <ski_> Couldn't match expected type `Int' with actual type `Bool'  Expected type: A Int  Actual type: A Bool
11:59:19 <notdan> Yeah, thanks for clarifying, ski_
12:14:15 <za3k> Any recommendations for a Schemer / other dynamically typed language guy picking up haskell? Finding standard tutorials boring, more interested in picking up style and details of type systems / monads and other more unique classes.
12:14:36 <earthy> RWH?
12:15:03 <earthy> The Haskell Road to Logic, Maths and Programming?
12:15:09 <byorgey> za3k: the Typeclassopedia, perhaps?
12:15:38 <lispy> za3k: write a type checker. Have you seen the "implementing haskell in lisp" blog series?
12:15:59 <lispy> za3k: http://gergo.erdi.hu/blog/2013-02-17-write_yourself_a_haskell..._in_lisp/
12:16:31 <za3k> Typeclassopedia seems cool and hadn't seen it, found RWH cool, type checker seems like *really* good idea to get types down.  Will check out Haskell Road to Logic...
12:16:44 <lispy> za3k: http://www.grabmueller.de/martin/www/pub/Transformers.en.html
12:17:23 <za3k> Awesome, I haven't found almost any of these by googling.
12:18:11 <lispy> za3k: http://web.cecs.pdx.edu/~mpj/thih/
12:18:41 <lispy> za3k: I think that last one is probably what you're looking for. It does a tutorial style explanation of how haskell's type system works...using haskell to implement it.
12:20:01 <lispy> za3k: if you want to understand more about how haskell implements the magic, checkout SPJ's paper list: http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html
12:21:07 <lispy> za3k: Last link for now. Dan Piponi is good at introducing deep concepts. You can find his blog here: http://blog.sigfpe.com/
12:37:45 <beaky> why is haskell faster than java
12:40:02 <tac> that asserts it is faster than java in the first place
12:41:10 <johnw> beaky: java's JIT should not be underestimated
12:47:26 <beaky> ah
12:47:36 <beaky> yeah java is lightning fast these days
12:47:57 <beaky> also I hear javascript is as fast as the speed of sound these days too
12:48:04 <beaky> how did haskell become so fast btw?
12:48:59 * ski_ quietly notes that languages aren't really fast nor slow
12:49:00 <johnw> it's a compiled language that is able to use functional programming principles to optimize code in some ways that imperative languages cannot do as well
12:49:23 <johnw> but ski_ is right.  You don't mean Haskell, you mean GHC
12:49:32 <johnw> Hugs is Haskell, and it's plenty slow
12:49:53 <geekosaur> also, ghci/runhaskell is a lot slower than compiled ghc
12:50:13 <carter> beaky lots of hard work
12:50:26 <tac> johnw: No one ever talks about "Haskell" :/
12:50:28 <geekosaur> mostly because nobody has ever put any real effort into bytecode optimization or tuning
12:50:42 <lispy> beaky: Because Haskell is a very high level language (also purity), compilers can apply many amazing optimizations.
12:50:57 <beaky> ah
12:50:57 <robonerd> hello. i found a channel via this channel but cannot recall its name. it was about processor operation, assembl... ah maybe #asm?
12:51:09 <ryanakca> I'm trying to implement gcd, which imho should be quite straight forward, but my implementation seems to run forever with even "gcd' 2 1'. Any suggestions? Do I need to "force" the execution of rem b a? http://paste.debian.net/239201/
12:51:38 <robonerd> yea nice, ty
12:51:41 <lispy> beaky: ghc does rewriting and other tricks to generate good core. Then the runtime support for evaluating the core is also very clever (read up on the spineless tagless g machine (or STG))
12:51:53 <ski_> ##asm,#asm,#assembler,##assembler apparently all exist
12:52:09 <neutrino> ghc is not an STG machine.
12:52:41 <lispy> neutrino: oh?
12:53:06 <neutrino> that's well known
12:53:08 <croikle> ryanakca: maybe you want rem a b
12:53:31 <ski_> robonerd : you seem to generally divide a lesser number by a greater number ?
12:53:34 <ski_> er
12:53:36 <croikle> a is larger, so rem b a = b, and things don't change
12:53:38 <ski_> ryanakca ^
12:53:47 <carter> also: a lot fo compiler optimization tricks are much easier when you have an internal rep that is essentially a functional program
12:53:49 <lispy> neutrino: What do you call the machine GHC uses?
12:53:59 <neutrino> "the machine ghc uses"
12:54:05 <carter> neutrino: compiled assembly :)
12:54:14 <carter> i kid
12:54:15 <carter> ish
12:54:24 <neutrino> haha "ish"
12:54:39 <beaky> ghc must be very difficult to implement
12:54:41 <ryanakca> ski_: Sorry, you're completely right. Silly mistake on my part, thanks :)
12:54:42 <robonerd> ghc?
12:54:43 <beaky> haskell*
12:55:02 <neutrino> lispy: since ghc implements monads, i'd take the stg paper with about as much salt as any monad tutorial.
12:55:10 <lispy> neutrino: so if ghc's runtime support doesn't follow the evaluation mode of the STG, what does it follow?
12:55:23 <neutrino> it follows something vaguely similar
12:55:33 <neutrino> for more details ask someone who's fluent in stg guts
12:55:34 * lispy has to run
12:55:39 <neutrino> cya
12:55:41 <johnw> lispy: what platform are you running on?
12:56:12 <johnw> ;)
12:59:58 <mm_freak> reify 101 $ \(_ :: Proxy n) -> show ((-1/2 :: Mod n)^2) = "1/4 mod 101"
13:00:02 <mm_freak> yeehaa =)
13:01:23 <neutrino> mm_freak: i never understood how reify works :\
13:01:41 <johnw> :t reify
13:01:42 <lambdabot> Not in scope: `reify'
13:01:57 <neutrino> johnw: reify is something oleg made
13:02:02 <neutrino> johnw: here be dragons
13:02:43 <johnw> oleg should be a synonym for dragon
13:02:54 <neutrino> here be olegs
13:03:31 <johnw> exactly
13:03:37 <johnw> i always think that when I see his name on a paper
13:03:46 <thoughtpolice> well, you need to be totally clear. 'reify' *originally* came from a large paper from oleg, about implicit configurations.
13:03:57 * johnw recently read OOHaskell, was sufficient shocked
13:04:02 <thoughtpolice> 'reflection', the package on hackage, is what happens when you let edwardk read those kinds of papers
13:04:16 <c-ab> which package you advise for http requests?
13:04:16 <thoughtpolice> because to date i think he's the only person who can be credited in compressing an oleg paper into about 6 lines of code
13:04:22 <c-ab> Netwokr.HTTP?
13:04:31 <johnw> i wonder, if we did a mashup of oleg and edwardk, if anyone would be able to fathom such code at all
13:04:33 <thoughtpolice> (ignoring the slow version of reflection, that is)
13:04:57 <neutrino> johnw: no
13:05:06 <neutrino> johnw: you must be stopped
13:05:11 <mgsloan> here be chieh-shans!
13:05:40 <thoughtpolice> either way, reflection is a nice library and the implicit configurations trick is pretty cool. i found the original paper rather readable
13:05:43 <johnw> i can imagine olegwardk writing a paper in Chinese, and then telling me, "That's not Chinese".  And me turning white.
13:06:16 <thoughtpolice> (it's also worth nothing that i think Oleg's solution to reflection did not depend on unsafePerformIO, while edwardk's version does. the original reflection only required upto Storable, I believe)
13:06:35 <monochrom> (fortunately, I can read Chinese too)
13:06:37 <thoughtpolice> obviously a lot of people have varying standards on when to make such choices :)
13:06:55 <elliott> thoughtpolice: it did require unsafePerformIO.
13:07:09 <elliott> we have something that is essentially that implementaiton as the slow fallback version in the current package
13:07:10 <thoughtpolice> oh, i couldn't remember. it's been a long time since i read it
13:07:27 <elliott> we use an unsafeCoerce trick with dictionaries that works on GHC and Hugs that's a lot faster by default
13:07:30 <elliott> but the fallback is still there
13:07:36 <thoughtpolice> i may have only remembered up to the 'part 2' of the paper where he talks about reifying lists, before he gets to reifying anything
13:07:49 <elliott> it gets to reifiying stableptrs
13:07:54 <elliott> but you can still only do value -> ptr, ptr -> value in IO
13:08:02 <elliott> so you need unsafePerformIO to complete the trick
13:08:05 <c-ab> parsec is huge
13:08:07 <thoughtpolice> ah right
13:09:22 <mm_freak> neutrino: reify x (\(_ :: Proxy n) -> …)
13:09:33 <mm_freak> within the parentheses 'n' is the type-level representation of x
13:09:49 <mm_freak> you can reflect it using 'reflect (Proxy :: Proxy n)'
13:09:51 <mm_freak> that's about it
13:09:57 <mm_freak> reflection = type to value
13:10:05 <mm_freak> reification = value to type
13:10:49 <johnw> that seems odd to me, since doesn't "reify" mean "to make more real", or something like that?
13:10:51 <c-ab> > getRequest "http://www.google.com"
13:10:52 <lambdabot>   Not in scope: `getRequest'
13:10:56 <ski_> @quote olegs
13:10:56 <lambdabot> Pseudonym says: Olegs can be warded off by adding a note claiming that it's impossible to implement in the type system.
13:11:08 <c-ab> I just get GET http://www.google.com/ HTTP/1.1
13:11:08 <c-ab> Content-Length: 0
13:11:09 <c-ab> User-Agent: haskell-HTTP/4000.2.8
13:12:57 <johnw> olegification = type into another type, by means of magic
13:13:13 <ski_> johnw : yeah, it somehow seems backwards ..
13:13:33 <beaky> does ghc do whole-program optimization?
13:13:33 <ski_> .. i suppose to olegwardk, types are more real than values
13:14:05 <ski_> beaky : istr JHC does
13:14:08 <mgsloan> even edwardk's tests are abstract values!
13:16:50 <johnw> I can summarize most olegwardk papers thus:
13:16:56 <johnw> "You are in a twisty maze of passages, all alike."
13:17:47 <aphury> is there a chance to integrate into "map" some sort of a counter?  I would like to code a function which does ["a","b","c"] -> ["1: a", "2: b", "3: c"]
13:18:04 <shachaf> @ty mapAccumL
13:18:05 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
13:18:09 <ousado> what's a scrutinee?
13:18:26 <shachaf> ousado: The thing that is being case ... of-ed.
13:18:36 <ousado> thanks :)
13:19:35 <aphury> thanks
13:21:12 <ski_> ousado : the thing being scrutinized
13:21:49 <ski_> aphury : also `mapM' in `State Integer' monad
13:22:37 <shachaf> Sure.
13:22:41 <shachaf> In fact, https://github.com/ekmett/lens/blob/master/src/Control/Lens/Traversal.hs#L394
13:23:14 <aphury> thx again; I'll look it up
13:24:08 <applicative_> c-ab: here's a typical GET request I just happened to have been importing https://github.com/simonmar/parconc-examples/blob/master/GetURL.hs
13:28:20 <monochrom> correction: s/what has shachaf done/what has beaky done/
13:28:39 <c-ab> applicative_: yep thx
13:28:43 <c-ab> simpleHTTP (getRequest "http://www.google.com") >>= getResponseBody
13:29:16 <c-ab> applicative_: is there a way to pass a proxy for the requests?
13:29:20 <c-ab> like in curl
13:29:27 <applicative_> yeah. conduit has a pretty nice api for this sort of thing too
13:30:49 <applicative_> c-ab: there's setProxy :: Proxy -> BrowserAction t ()
13:32:10 <c-ab> @hoogle setProxy
13:32:10 <lambdabot> Network.Browser setProxy :: Proxy -> BrowserAction t ()
13:32:50 <c-ab> this is not Conduit?
13:33:43 <applicative_> http://hackage.haskell.org/packages/archive/http-conduit-browser/1.9.0/doc/html/Network-HTTP-Conduit-Browser.html#g:8
13:34:24 <c-ab> well I've the choice then
13:34:38 <applicative_> c-ab I don't know much about either, but I remember conduit at least used to be the only way to use https
13:36:17 <`nand`> aphury: you could also use a variation of ‘zipWith f [1..]’ for that
13:36:29 <`nand`> or a fold
13:36:46 <aphury> `nand`, this is, what I've finally came up with
13:37:01 <aphury> fold? how?
13:37:27 <c-ab> applicative_: ok
13:38:00 <`nand`> well, conceptually, by folding up a new list + a counter; though you may get one or the other in the wrong order that way
13:38:33 <shachaf> Well, everything is a fold.
13:38:41 <ski_> > foldl (\(i,ns) n -> (i+1,n+i:ns)) (0,[]) [10,30,60,100]
13:38:44 <lambdabot>   (4,[103,62,31,10])
13:38:58 <ski_> > foldr (\n (i,ns) -> (i+1,n+i:ns)) (0,[]) [10,30,60,100]
13:39:00 <lambdabot>   (4,[13,32,61,100])
13:39:15 <aphury> yeh, one has to reverse the list then.
13:39:15 <aphury> May I ask some more generel question?
13:39:45 <`nand`> shachaf: can you implement ‘zip‘ as a fold?
13:39:56 <ski_> > foldr (\n i_ns i -> n+i : i_ns (i+1)) [] [10,30,60,100] 0
13:39:58 <lambdabot>   Couldn't match expected type `a0 -> [a0]' with actual type `[a1]'
13:40:05 <ski_> > foldr (\n i_ns i -> n+i : i_ns (i+1)) (\_ -> []) [10,30,60,100] 0
13:40:08 <lambdabot>   [10,31,62,103]
13:40:14 <`nand`> ah, hmm, probably
13:40:19 <shachaf> `nand`: As a pair of folds, sure.
13:40:19 <aphury> Updating state variables isn't an IO () action, so it won't happen in main = ... . But where then?
13:40:21 <byorgey> aphury: don't ask to ask, just ask =)
13:40:22 <`nand`> yeah
13:40:36 <ski_> aphury : probably more variants
13:40:50 <ski_> `nand` : yes
13:41:06 <byorgey> aphury: state variables? as in, the State monad?
13:41:08 <ski_> `nand` : doing so is interesting
13:41:20 <byorgey> there is really no such thing as "state variables"
13:41:32 <byorgey> unless you mean IORef, but updating those IS an IO () action.
13:42:00 <`nand`> at least one possibility is to fold through one list, inserting each element into the ‘right position’ of the other list (again using a fold) and positional counters where appropriate
13:42:15 <applicative_> > scanl (+) 0 [1,2,3,4,5]
13:42:17 <lambdabot>   [0,1,3,6,10,15]
13:42:28 <aphury> ... link down?
13:42:33 <applicative_> aphury: ^^^ is that 'updating a state variable'?
13:42:56 <`nand`> variables are updated?
13:43:42 <ski_> `nand` : tru doing it, using only a single `foldr' per list to traverse it, not pattern-matching or passing it to any other function that pattern-matches -- also no explicit recursion and no `fix' tricks, only recursion via `foldr'
13:43:50 <ski_> s/tru/try/
13:45:20 <ski_> @quote no.state
13:45:20 <lambdabot> MonadState says: Do not try to change the state; that's impossible. Instead only try to realize the truth: There is no state.
13:45:39 <applicative_> > scanl (+) a [b,c,d,e,f,g]
13:45:41 <lambdabot>   [a,a + b,a + b + c,a + b + c + d,a + b + c + d + e,a + b + c + d + e + f,a ...
13:45:52 <applicative_> ^^^ check it out, I mutated 'a'
13:46:03 <aphury_> got a ld  : /
13:46:05 <ski_> re aphury_
13:46:10 <aphury_> thanks.
13:46:37 <aphury_> My room mates keep messing with the router
13:46:46 <ski_> aphury : see bottom of <http://tunes.org/~nef/logs/haskell/13.03.01> for what you missed
13:47:00 <ski_> aphury_ ^
13:47:40 <aphury_> .. reading
13:48:56 <aphury_> uhm, okay. I guess I've used the wrong vocab
13:48:57 <ski_> aphury_ : perhaps you have a more specific question about state, or about how to compute something ?
13:49:05 <aphury_> about how to compute
13:49:20 <aphury_> wait, I'll post a bit
13:50:05 * ski_ wrestles a bit with `Show' for a GADT
13:50:24 <hpaste> aphury pasted “How to update boss,player and tell things?” at http://hpaste.org/83318
13:50:33 <aphury_> It might be a bit too much.
13:50:41 <vlatkoB> Why it "Couldn't match expected type `[Char]' with actual type `Char'" in
13:50:48 <vlatkoB> fun2 :: [[Char]]
13:50:52 <aphury_> And please don't blame me. I've just started with Haskell  ; )
13:50:55 <vlatkoB> fun2 = [ y:x | y <- ['a','b','c'], x <- ['x']]
13:51:31 <Iceland_jack> vlatkoB: because (:) expects (in this case) a Char and a [Char]
13:51:52 <Iceland_jack> > [ [y,x] | y <- ['a','b','c'], x <- ['x']]
13:51:54 <lambdabot>   ["ax","bx","cx"]
13:51:56 <aphury_> brb
13:52:39 <ski_> aphury_ : hm, i'd prefer it if you didn't redefine `show' for your custom (non-Haskell-expressiony) display function
13:53:04 <`nand`> ski_: I got as far as zip' [1..3] [4..6] = [([1..3],4), ([1..3],5), ([1..3],6)] -- but I'm stumped on how to diagonalize the inner list properly using only a single fold
13:54:02 <c-ab> http-conduit = 80 dependancies
13:54:48 <vlatkoB> Iceland_jack: Thanks, that did it. Can please you tell me what is wrong with this one:
13:54:49 <vlatkoB> fun2 = [ [y,x] | y <- [1..3], x <- [4..6]]
13:55:00 <aphury_> re
13:55:14 <vlatkoB> Type is fun2 :: [[a]]
13:55:32 <Iceland_jack> well the type is not fun2
13:55:52 <Iceland_jack> sorry, *[[a]]
13:56:10 <Iceland_jack> Try it yourself in ghci
13:56:13 <ski_> `nand` : two `foldr's, one for each list
13:58:54 <vlatkoB> What do you mean? I'm writing it in Eclipse and it shows "No instance for (Enum a)     arising from the arithmetic sequence `1 .. 3'"
13:59:30 <ski_> vlatkoB : perhaps you need to add an `Enum a' constraint to your type signature (or comment it out) ?
14:00:10 <vlatkoB> Tried "fun2 :: Enum a => [[a]]" and the same error
14:00:16 <`nand`> ski_: well, the obvious approach would be to try to reduce ‘z (x:xs) (y:ys) = (x,y) : z xs ys’ into something of the form ‘z (x:xs) (y:ys) = f y (z (x:xs) ys)’ but I can't seem to do it
14:00:45 <`nand`> if I could do that, I could start with z (x:xs) = foldr f []
14:00:52 <ski_> vlatkoB : what if you comment it out, does it load into your interactor, and what does `:t fun2' say ?
14:01:28 <ski_> `nand` : i'm not saying it's necessarily that easy to do this ..
14:01:53 <ski_> `nand` : .. but it's possible (i did it) (and i thought it was interesting)
14:02:24 <ski_> `nand` : if you'd like to, you could ponder it over a few days
14:02:31 <`nand`> I could do it for finite lists only, but that's not very good
14:02:58 <ski_> `nand` : if you prefer, i could show/tell one way to do it
14:03:16 <`nand`> maybe I'll think about it when I'm not tired to the point of falling asleep tomorrow
14:03:43 <`nand`> falling asleep, tomorrow*
14:04:22 <vlatkoB> Hm, yes it does work with commented type signature.  Type say    fun2 :: [[Integer]], so I changed it and now works as expected. :-)
14:04:24 * ski_ nods
14:05:24 <ski_> vlatkoB : how about `fun2 :: Integral i => [[i]]' ?
14:07:30 <vlatkoB> I tried it and "fun2 :: Integer s => [[a]]" doesn't work, but "fun2 :: [[Integer]]" does. I thought it is the same.
14:08:09 <aphury> ski_: re. Sorry.
14:08:13 <vlatkoB> Ups, you said Integral, not Integer. Sorry, yes Integral produces no error. All ok.
14:08:58 <elliott> what about Num?
14:09:11 <elliott> Integral doesn't give you any more power for producing things, so using it like that is a bit suspect generally, I think
14:09:23 <elliott> oh, wait
14:09:29 <elliott> I guess you probably use division or such
14:09:38 <ski_> vlatkoB : ok
14:09:40 <elliott> forgot that was bundled in Integral
14:10:31 <hpaste> beaky pasted “Why does my hard player keep losing? :(” at http://hpaste.org/83319
14:11:03 <vlatkoB> No, Num gives Could not deduce (Enum a) in [1..3]
14:11:46 <elliott> ah, fair enough
14:13:36 <aphury> ski_:  why shouldn't I overwrite show?
14:15:07 <ski_> aphury : `show' is mostly meant as a aid in debugging/testing, and for outputting a readable representation of a value, to be read back in later -- and normally this representation is in the form of a valid haskell expression which if evaluated would yield an equivalent value
14:15:39 <ski_> aphury : it's usually better to define your own display functions if you want custom (non-expression) portrayal of data
14:15:59 <aphury> hm… so better write a own type class?
14:16:03 <ski_> (not necessarily using any type class at all, though in some cases, that might help)
14:16:10 <aphury> okay
14:16:47 <aphury> and… how to update "player", "boss" and output some status? I mean, this is a design question, but I can't wrap my mind around it.
14:20:03 <hpaste> ski annotated “How to update boss,player and tell things?” with “tidying up somewhat” at http://hpaste.org/83318#a83320
14:21:05 <ski_> aphury : in `idList', do you mean to reverse the list as you process it, or should really the result be in the original order ?
14:21:11 <ski_> (or maybe the order doesn't matter ?)
14:21:47 <aphury> well, it should not be reversed. Uhm.
14:22:07 <ski_> aphury : in `main' when you use `read' on the result from `getContents', perhaps you meant to only read one line, and parse an `Int' from that line (so that you can continue reading from the rest of the lines) ?
14:22:21 <aphury> thanks for cleaning up the code!
14:22:33 <aphury> yep
14:23:02 <ski_> (you could use `getContents' for reading first one `Int' from the first line, but then you can't use plain `read', since this will comsume the *whole* input, *all* lines)
14:23:12 <ski_> so, you wanted `getLine' ?
14:23:34 <ski_> @type readLine
14:23:36 <lambdabot>     Not in scope: `readLine'
14:23:36 <lambdabot>     Perhaps you meant one of these:
14:23:36 <lambdabot>       `readFile' (imported from Prelude),
14:23:38 <ski_> @type readLn
14:23:40 <lambdabot> Read a => IO a
14:23:43 <ski_> @type readIO
14:23:45 <lambdabot> Read a => String -> IO a
14:23:50 <aphury> this is about laziness, right? Oh man ...
14:23:57 <ski_> well, slightly
14:24:02 <aphury> yeh, better take getLine then
14:24:10 <arkeet> lazy IO is kind of fragile
14:24:14 <ski_> but mostly my question was about your *intension*
14:24:22 <arkeet> not intention?
14:24:31 <ski_> er, right
14:24:33 <arkeet> :p
14:24:39 <sipa> pretty intense
14:24:50 <gks> quick question (i hope). If I write a program and it uses an SQLite database (it reads from one that already exists) and I compile it. What exactly would I need in order to run this on another computer with no haskell tools? Is it just a native Unix app that can run, or do i need libraries?
14:25:10 * ski_ first wrote "intension", then changed to "intention", then changed back to "intension" -- obviously bad decision
14:25:12 <johnw> gks: if you build your app with all static libraries, you need nothing
14:25:21 <aphury> yeh, you're right on this. My intention is as you said
14:25:22 <johnw> gks: but it depends on your platform; OS X doesn't support fully static executables
14:25:25 <arkeet> haskell programs are generally statically linked
14:25:38 <johnw> arkeet: yes, but not all platforms generally provide static libs
14:25:39 <arkeet> you can always check what it links against with ldd
14:25:40 <gks> johnw: OS X would be the target platform. is there any gotchas?
14:25:46 <ski_> aphury : anyway, `readLn' will do a `getLine' and a `read', but will raise an exception in `IO' in case the `read' fails (so is slightly nicer in that way)
14:25:49 <johnw> arkeet: on CentOS, my git-annex build uses about 20 shared libraries
14:26:26 <johnw> gks: if you use homebrew, you stand the greatest chance of not relying on libraries which don't exist on the target system
14:26:36 <johnw> gks: use otool -L <exe> to determine which extra libraries you are requiring
14:26:38 <gks> using homebrew
14:26:43 <ski_> aphury : btw, any reason for reversing in `idList' ?
14:26:58 <ski_> hmm
14:27:15 <ski_> ah, you have counting numbers
14:27:15 <aphury> na, it's just my inability
14:27:28 <aphury> it should not be reversed
14:28:00 <ski_> so you want to annotate the first element with `0: ', the next with `1: ', and so on ?
14:28:08 <aphury> yes
14:28:46 <fpqc> hey
14:29:00 <fpqc> I'm trying to load a makefile in ghci and i can't figure out the syntax
14:29:30 <fpqc> also, what's the command to show the current working directory
14:32:07 <trevize> hello, is there a reason that I can't alias tuple types? For example: newtype Point = (Integer, Integer)
14:32:22 <`nand`> did you mean
14:32:27 <eikke> trevize: that's not how newtype works
14:32:27 <`nand`> type Point = (Integer, Integer)
14:32:43 <eikke> trevize: type POint = (Integer, Integer), or newtype Point = Point (Integer, Integer)
14:32:57 <trevize> `nand`: I'm not sure. What's the difference between them?
14:33:07 <`nand`> newtype introduces a new type, with a new constructor
14:33:20 <eikke> trevize: 'type' is a type alias, 'newtype' is a new type
14:33:20 <`nand`> a type synonym is just a more convenient way to write something
14:33:48 <`nand`> think of ‘newtype’ as almost the same as ‘data’
14:34:01 <`nand`> they only differ in strictness (and in that newtypes can only have one constructor/field)
14:34:20 <eikke> and a newtype isn't tagged
14:34:21 <trevize> I see, so tuples are not like []. () is not a constructor?
14:34:26 <beaky> what is the first approach to optimizing a haskell program? I finally made my tictactoe game correct :D
14:34:30 <eikke> trevize: (,) is the constructor
14:34:32 <ski_> > unlines ["a","b"]
14:34:32 <trevize> eikke: what's tagging?
14:34:34 <lambdabot>   "a\nb\n"
14:34:34 <beaky> but it is dog slow when I choose the brute-force ai
14:35:13 <`nand`> that's an implementation irrelevance, surely
14:35:13 <ski_> aphury : `unlines' will add a newline after the last line, and `putStrLn' will add yet another one -- do you want two of them at the end ?
14:35:31 <aphury> putStr would be okay
14:35:59 <trevize> `nand`, eikke, thanks for your help!
14:36:12 <hpaste> ski annotated “How to update boss,player and tell things?” with “some changes” at http://hpaste.org/83318#a83321
14:36:29 <hpaste> dmj pasted “Parse error in pattern k” at http://hpaste.org/83322
14:36:40 <ski_> aphury : i removed the `Show' instances, and instead defined `displayFigure' and `displayAbility'
14:36:53 <dmj> can someone help me with the above code? Just a simple pattern matching error that has me stuck
14:37:08 <ski_> aphury : i used `readLn' instead of `getContents'^W`getLine' and `read'
14:37:11 <hpaste> applicative annotated “How to update boss,player and tell things?” with “How to update boss,player and tell things? with cheesy StateT annotation for aphury” at http://hpaste.org/83318#a83323
14:37:20 <aphury> ski_: thank you so much  : )
14:37:39 <ski_> aphury : instead of the manual counting loop, i used `zipWith counter [0 ..]', for a `counter' helper function
14:38:09 <aphury> applicative: thanks also. Whoa. New stuff
14:38:15 <ski_> aphury : instead of `putStr . unlines', i used `mapM_ putStrLn', which will output the string directly, instead of bothering with concatenating the lines into a single string first
14:38:25 <aphury> okay
14:38:36 <ski_> aphury : i also added `deriving Show' for testing purposes
14:39:01 <dmj> anyone?
14:39:07 <aphury> okay, I see
14:39:45 <ski_> @index mapM_
14:39:46 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:40:10 <ski_> aphury : now, you asked about "How to update boss,player and tell things?"
14:40:17 <ski_> aphury : what did you want to do ?
14:40:21 <applicative_> aphury: i was just wanting to show how you get and put state in a quasi standard way.  In my player gets to increment his health until it's bigger than the  boss's
14:40:30 <applicative_> in my game
14:40:54 <aphury> whoa … will took this night to go through all the chances  : )
14:41:33 <ski_> heh
14:42:13 <ski_> aphury : sorry, i see i have one space too little in `boss' : `="TehBohs"'
14:42:14 <thetallguy1> dmj: remove the parens, I think
14:42:36 <aphury> so, what I want to do is: one may choose between either healing himself or damage the boss. This means 1) the boss variable has to get updated and 2) the program has to tell what it does
14:42:37 <thetallguy1> dmj: hard to tell the exact solution without the declaration
14:42:52 <aphury> applicative_, thanks! I will go through it
14:43:13 <aphury> 1) the boss or the player var. has to get updated
14:43:46 <dmj> thetallguy: in the parseCVD pattern match?
14:44:00 <thetallguy1> dmj: (ClassVarDec key type [])
14:44:19 <thetallguy1> dmj: I assume ClassVarDec has three components?
14:44:34 <ski_> aphury : instead of "the boss variable", you could think "the boss state"
14:44:42 <aphury> yep
14:45:05 <ski_> aphury : and "the boss state" will be a sequence of values, possibly passed on in an argument in recursive calls
14:45:14 <dmj> thetallguy: yes, data Declaration = ClassVarDec Keyword Type [VarName]
14:45:25 <ski_> (aphury : like how you "updated" `buf' in your earlier  idList'  )
14:45:26 <aphury> ski_: yeh
14:45:38 <thetallguy1> dmj: then the pattern that matches it should be (ClassVarDec x y zs)
14:46:14 <thetallguy1> dmj: what you currently have looks like C code
14:46:28 <ski_> aphury : so, your `player' and `boss' that you have defined clearly only holds the *initial* state (value) of those two respective states in the game
14:46:37 <epta> Is there some option parser that could initialize all getters and default value from help message, like "tool file [(-o|--output) OUTPUT]" ?
14:46:43 <dmj> thetallguy1: I have a massive AST from the result of a parsec expression
14:46:59 <dmj> thetallguy1: I did have a C class before trying to write a compiler in haskell
14:47:07 <aphury> ski_: yes. I would apply useOn … on them
14:47:07 <ski_> aphury : your whole game state will consist of the current "boss" values, and the current "player" value (and perhaps some extra things ?)
14:47:11 <ski_> yes
14:47:32 <aphury> ski_: well, to keep things easy, it's just the player and boss states
14:47:38 <dmj> thetallguy1: how would I make this operation more functional? Not sure how else to wade through the tree
14:47:49 <ski_> aphury : now, `main' starts by asking `It's your turn. What do you wanna do?' -- which sounds like something it should ask over and over again
14:48:25 <ski_> aphury : so, you'd better move this out of `main', into some kind of `gameLoop' function (that takes the current game stete as argument(s))
14:48:38 <hpaste> applicative annotated “Parse error in pattern k” with “Parse error in pattern k (annotation)” at http://hpaste.org/83322#a83324
14:48:41 <aphury> ski_: !
14:48:58 <ski_> aphury : and the job of `main' is to call `gameLoop' with the initial state -- and maybe do some other stuff before ior after calling `gameLoop'
14:49:14 <ski_> aphury : do you get the idea ?
14:49:16 <thetallguy1> dmj: It doesn't look like a bad start.  Fix the pattern and get it to compile
14:49:44 <ski_> (`gameLoop' will of course also be defined using `do')
14:49:49 <dmj> thetallguy1: works now, thanks
14:50:40 <aphury> ski_: yep. I'll try to implement it.
14:51:18 <ski_> aphury : now, you'll have to decide what to do when the game ends
14:51:26 <ski_> presumably you can both win and lose
14:51:48 <ski_> so `gameLoop' perhaps itself will print whether you win or lose (and score, perhaps)
14:52:25 <ski_> or maybe `gameLoop' just yields some final indication of success/failure, and leaves to the caller (here `main') to decide how to communicate the result with the user
14:52:30 <ski_> aphury : this is all your choice
14:52:50 <ski_> perhaps you have some yet other idea you want to try
14:52:58 <aphury> hm… so the gameLoop function prints out some status?
14:53:13 <aphury> I'm going to implement it .. may I paste it again then?
14:53:56 <ski_> sure
14:54:09 <aphury> GameState would be like
14:54:22 <ski_> aphury : if you come with updates, you can use the "Annotate" button on the paste site to add an annotation to the same page
14:54:28 <aphury> data GameState = GameState { playerState :: Figure , bossState :: Figure }   ?
14:54:37 <ski_> you could define a `GameState' type if you wanted to, yes
14:54:40 <aphury> okay. Thanks a lot, ski_
14:55:02 <ski_> an alternative is just keeping the boss and player state in two arguments or in a pair argument
14:55:40 <ski_> the `GameState' is possibly nicer, in that it's easier to add new pieces of state without having to modify as much of the "passing state around"-code
14:55:52 <aphury> yeh, so I thought.
15:06:09 <beaky> what happens when I use unsafePerformIO?
15:06:26 <eikke> hell breaks loose
15:06:36 <epta> kitten die
15:06:47 <eikke> missiles are launched
15:07:01 <eikke> all IO becomes pure!
15:07:12 <simpson> *Maybe* hell-kittens are killed by missiles.
15:07:17 * stepcut kicks network 2.4.1.1 in the nuts
15:07:19 <no-n> cthulhu
15:07:50 <beaky> so bad thigns may happen? what if I just want to do something equivalent to printf logging without launching missiles? :D
15:07:53 <c_wraith> pretty much everything about unsafePerformIO is captured by the combination of its type, and a close examination of how pure values are handled
15:07:59 <c_wraith> beaky: then use Debug.Trace
15:08:03 <simpson> beaky: Oh, use Debug.Trace.
15:08:10 <simpson> beaky: Already -- dammit
15:08:19 <beaky> :t unsafePerformIO
15:08:20 * simpson is always sniped
15:08:21 <lambdabot> Not in scope: `unsafePerformIO'
15:08:54 <beaky> wow debug.trace is just what I need
15:10:01 <beaky> there's always a haskell library function that does exactly what I need, and if not then it's just a few fmaps away from what I need :D
15:10:41 <eikke> beaky: hoogle is your friend
15:11:05 <simpson> beaky: Debug.Trace came into being precisely because people kept using unsafePerformIO on their own to do this.
15:11:50 <beaky> ah
15:11:57 <c_wraith> Yeah, the implementation is exactly what you'd end up with if you went to do it using unsafePerformIO (and fixed all the bugs you ran into along the way)
15:12:25 <beaky> so what do you use for asserts? also how do you test haskell code?
15:12:41 <shachaf> Often the operation I want is \x -> traceShow x x
15:13:20 <simpson> beaky: Typically one will not write any kind of inner assertion.
15:13:22 <lightquake> I'm having an mtl problem: I want to have access to a Writer [String] and a Reader Foo, and I want to be able to fail, but I don't want failure to stop the rest of the computations in case they write something
15:13:24 <sproingie> you can unit test haskell code like anything else.  quickcheck is also good at generating tests
15:13:25 <beaky> ah
15:13:35 <sproingie> quickcheck is property-based so it's also a lot like asserts
15:13:39 <lightquake> so I tried MaybeT (ReaderT Scope (Writer [String])), but that causes the first failure to stop the computation entirely
15:13:43 <simpson> beaky: QuickCheck is the way to make that kind of pattern, and the assertions are *outside* your functions.
15:13:51 <sproingie> @quote quickcheck
15:13:51 <lambdabot> blackdog says:  <kristnjov> QuickCheck is god * earthy thinks kristnjov has a *weird* religion <kristnjov> it's called hughes-ism <kristnjov> a bit new age <blackdog> this y combinator, which was
15:13:51 <lambdabot> given to you for the recursion of sins <earthy> lead me not into global state <blackdog> yea, though I should walk in the valley of imperative code, I shall fear no evil, for your monad comforts me
15:13:51 <lambdabot> still
15:14:01 <elliott> lightquake: what semantics is failure meant to have?
15:14:06 <elliott> just a Bool at the end telling you whether you failed or not?
15:14:14 <sproingie> goodness that's a long quote
15:14:21 <lightquake> failure means you get Nothing, success means you get a Just something
15:14:41 <lightquake> but there are multiple parts that can fail 'independently'
15:14:43 <simpson> @unmtl MaybeT (ReaderT e (Writer w) a)
15:14:44 <lambdabot> Plugin `unmtl' failed with: `MaybeT (e -> (a, w))' is not applied to enough arguments.
15:14:46 <jfischoff> is there a simple way to fill a foreign pointer with a list of values?
15:14:50 <simpson> Oh derp.
15:14:52 <lightquake> and i'd like to know the failure messages for all of them
15:14:54 <simpson> @unmtl MaybeT (ReaderT e (Writer w)) a
15:14:54 <lambdabot> e -> (Maybe a, w)
15:15:11 <applicative_> what happened to @check?
15:15:13 <sproingie> what exactly does @unmtl do?
15:15:18 <applicative_> @check \x -> x > 0
15:15:20 <lambdabot>   Not in scope: `myquickcheck'
15:15:28 <ski_> beaky : if you say `unsafePerformIO foo' where `foo' is declaratively equivalent to `return x' for some `x', i think it's ok (and you'll get "the" `x' value) -- otherwise, i think it's undefined behaviour
15:15:41 <simpson> sproingie: It takes an MTLish signature, plugs in the common definitions for common transformer newtypes, and gives you the resulting type.
15:16:01 <geekosaur> jfischoff, http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Foreign-Marshal-Array.html#v:pokeArray ?
15:16:02 * ski_ sometimes thinks it ought to be called `promiseIOPure'
15:16:11 <applicative_> sproingie: it tells you what the isomorphic newtype-wrapped type is , crudely
15:16:17 <sproingie> oh cool
15:16:21 <jfischoff> geekosaur: thanks
15:16:36 <simpson> lightquake: Where would the failure messages be sent? To the Writer?
15:16:41 <ski_> ("(If you lie to the compiler, the compiler will get its revenge!)")
15:16:44 <lightquake> simpson: yeah
15:16:59 <beaky> ah
15:17:13 <simpson> lightquake: I think you might have to explicitly write them to the writer.
15:18:20 <simpson> lightquake: Also there's not really much information that you can get back from a Maybe.
15:18:31 <lightquake> right, which is why i'm dumping error messages to the Maybe
15:18:33 <lightquake> er, to the writer
15:18:47 <simpson> Oh, you're explicitly doing this already?
15:18:51 <lightquake> yes
15:18:57 <applicative_> ski_: I remember conal saying it should be called  proveSafeIO
15:19:02 <simpson> Note that you could also stash the error messages and then have a generic function to pull them out...
15:19:17 <simpson> @unmtl ReaderT e (EitherT l (Writer w)) a -- this?
15:19:18 <lambdabot> e -> EitherT l (Writer w) a
15:19:21 <elliott> applicative_: but it proves nothing?
15:19:28 <simpson> Aw, EitherT isn't known to unmtl.
15:19:34 <elliott> well, I guess you can take it as a "trust me" proof
15:19:39 <sproingie> if you strike down my typechecking, i shall come back with segfaults more powerful than ever
15:19:49 <simpson> But basically: e -> (Either l a, w)
15:19:49 <elliott> maybe assumePureIO, or something
15:20:04 <applicative_> the thought being that you are informed that you undertake a 'proof obligation' I think
15:22:20 <ski_> applicative_ : hm, not bad, but i like the sound of "promise" better :)
15:23:08 <ski_> (i think it better communicates that the burden of ensuring the condition, and the place of blame in case of failure, lies in the invoker)
15:23:56 <geekosaur> iSolemnlySwearThatThisActuallyPure ...
15:24:24 <applicative_> ski_: yeah I suppose.  maybe he meant something like 'provePure' in any case.  The idea being that the IO that gets done should be of the kind that gets done whenever there is calculation in fact.
15:25:01 <ski_> though it's possibly better to have language constructs (some flavour of pragmas, perhaps), than just an operation, where if we only look at the type, we note no extra specialness
15:25:46 <ski_> applicative_ : *nod* as long as it's behaviour is "pure", it should be ok
15:25:54 <ski_> s/'//
15:26:44 <c-ab> > Data.ByteString.pack "foo"
15:26:46 <lambdabot>   Not in scope: `Data.ByteString.pack'
15:27:59 <elliott> ski_: I wonder if you can, in a dependently-typed or such language, construct a rich enough model of IO that you can make a safePerformIO which takes a proof of the purity property
15:28:11 <elliott> such that you can use it to implement actually useful unsafePerformIO things like memoisation
15:28:49 <ski_> i suspect you'll have to muck with an explicit "representation equivalence-relation", then
15:28:58 <elliott> yeah
15:28:59 <lightquake> can I make type Foo a = ReaderT a (Writer [String]) (Maybe a) a Monad?
15:29:14 <elliott> lightquake: no, "a" is used contravariantly there
15:29:18 <elliott> as an argument to the ReaderT
15:29:22 <lightquake> er
15:29:22 * ski_ . o O ( `unsafeReifyRepresentation :: a -> Representation a' )
15:29:30 <lightquake> that first a should be Int
15:29:36 <elliott> ski_: or you could formulate the property as something other than (exists a, m ~= return a)
15:29:42 <lightquake> so type Foo a = ReaderT Int (Writer [String]) (Maybe a)
15:29:54 <ski_> elliott : perhaps, but i'm not sure what it would be
15:30:01 <elliott> (especially since such an "exists" proof would require giving an "a" = possibly writing your algorithm all over again, in a constructive setting)
15:30:11 <lightquake> in general, if m and n are monads, is their composition a monad
15:30:25 <elliott> ski_: perhaps have some notion of "running" an IO action in some world environment producing a result of some kind. then forall e e', run e m = run e' m
15:30:32 <elliott> lightquake: no
15:30:34 <ski_> well, for inefficiently-computable stuff, it should work
15:30:40 <elliott> lightquake: but it is if you have a distributive law
15:30:46 <elliott> m (n a) -> n (m a) (maybe the other way around too?)
15:30:47 <lightquake> what law?
15:30:49 <simpson> lightquake: For all m and n? No, not necessarily; ListT is not guaranteed to hold the laws.
15:31:07 <elliott> the composition of two applicatives is an applicative, though
15:31:08 <ski_> the question is whether there's any interesting non-in-Haskell-computable things
15:31:29 <elliott> ski_: yeah, just thinking from a convenience POV there
15:31:49 <ski_> lightquake : a function of type `m (n a) -> n (m a)' is sometimes itself knowns as a "commutative law"
15:32:04 <simpson> lightquake: Anyway, it's starting to sound like you might want to just RWS up, and then build a couple helper functions to write from the current state into the log.
15:32:23 <simpson> @unmtl RWS e w s a
15:32:23 <lambdabot> e -> s -> (a, s, w)
15:32:25 <ski_> lightquake : sorry, s/commutative/distributive/, it should have been
15:32:37 <ski_> elliott : *nod*
15:32:44 <lightquake> simpson: well, I don't need state, i just need to fail somehow
15:32:56 <applicative_> c-ab I think that would be Data.ByteString.Char8.pack "foo"; Data.ByteString.pack [1,2,3]
15:33:20 <lightquake> so right now i have ReaderT Int (Writer [String]) (Maybe a)
15:33:51 <c-ab> applicative_: yesni've made it work thx
15:34:01 <applicative_> lightquake: awesome, take it higher!
15:34:09 <lightquake> applicative_: ?
15:34:29 <applicative_> lightquake: you say the omnibus RWS monad, I take it
15:34:31 <elliott> ski_: I also wonder if maybe most benign uses of unsafePerformIO don't instead want unsafePerformST (e.g. memoisation would work with "just" that)
15:34:35 <lightquake> yes
15:35:16 <shachaf> I wonder whether unsafePerformST is "worse" than unsafePerformIO.
15:35:22 <lightquake> actually I think pulling the monad 'outside' the stack is the right thing here, anyway
15:35:33 <shachaf> Actually, no, never mind.
15:35:42 <simpson> lightquake: Well, I'm still confused on how you've got Strings coming from your Maybe a.
15:35:43 <elliott> shachaf: howso?
15:35:49 <elliott> you still get unsafeCoerce
15:36:18 <applicative_> @unmtl RWS Int () [String]  Identity (Maybe a)
15:36:18 <lambdabot> Plugin `unmtl' failed with: `Identity' is not applied to enough arguments, giving `/\A. A'
15:36:25 <applicative_> oh
15:36:26 <shachaf> elliott: Never mind.
15:36:39 <applicative_> @unmtl RWS Int () [String]  m a
15:36:39 <lambdabot> Plugin `unmtl' failed with: `Int -> [String] -> (m, [String], ())' is not a type function.
15:36:42 <lightquake> simpson: what i'm *actually* doing is writing a transformation over ASTs, including type checking and such
15:36:51 <simpson> applicative_: RWS already has Identity built in.
15:37:01 <simpson> @unmtl RWS Int () [String] a
15:37:02 <lambdabot> Int -> [String] -> (a, [String], ())
15:37:07 <simpson> lightquake: Ah.
15:37:29 <elliott> hmm, is the operation r -> (forall s. STRef s r -> a -> ST s b) -> (a -> b) safe?
15:37:33 <lightquake> and i want to make it so that it doesn't stop on the first monad
15:37:35 <elliott> because that's essentially what's going on in memoisation
15:37:36 <lightquake> er, first error
15:37:37 <applicative_> thank you simpson, too many capitals in RWS to remember T
15:37:50 <elliott> thatOp emptyMemoTable (\memoRef a -> ...retrieve from memo table or insert and return...)
15:38:04 <simpson> applicative_: No worries. I personally never used RWS until I needed it, for actually much the same thing that lightquake is doing now.
15:38:06 <applicative_> @unmtl RWST Int () [String] Maybe a
15:38:06 <lambdabot> Int -> [String] -> Maybe (a, [String], ())
15:38:19 <lightquake> applicative_: that doesn't work, since failing kills the entire error log
15:38:21 <applicative_> ^^^ lightquake check it out...
15:38:38 <applicative_> oh dear.
15:38:39 <simpson> lightquake: Ah. Well, accepting this this is *hard*, then it seems like you don't want to Maybe anything at all.
15:39:05 <simpson> lightquake: You could always just check the log at the end of each pass. If it's got *anything* inside, if it's not [], then that's the time to fail out.
15:40:15 <lightquake> simpson: but there are values that have values that can potentially be undefined
15:40:35 <lightquake> so I do need Maybe, sometimes
15:41:47 * hackagebot poker-eval 0.1 - Binding to libpoker-eval  http://hackage.haskell.org/package/poker-eval-0.1 (DavidHimmelstrup)
15:41:49 <ski_> shachaf : `unsafeInterleaveST' is in any case worse than `unsafeInterleaveIO'
15:43:06 <simpson> lightquake: So put Maybe in there, sometimes.
15:43:20 <ski_> @type let scramble as = runST (do ref <- newSTRef as; mapM (Control.Monad.ST.unsafeInterleaveST . \_ -> do a:as <- readSTRef ref; writeSTRef ref as; return a) as) in scramble
15:43:22 <lambdabot> [a] -> [a]
15:44:21 <ski_> @hoogle atomicModifyIORef
15:44:22 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
15:44:27 <ski_> @hoogle atomicModifySTRef
15:44:27 <lambdabot> No results found
15:44:43 <ski_> is there a reason `atomicModifySTRef' doesn't exists ?
15:45:21 <elliott> because it'd be modifySTRef for all safe usecases, presumably?
15:45:21 <shachaf> Why would it?
15:45:27 <ski_> hm, i suppose atomicity would mostly be useful for (true) concurrency, which you're not supposed to do in `ST s' anyway
15:45:34 <shachaf> Right.
15:46:07 <sproingie> lispy: quick question, do i want GLFW or GLFW-b?
15:46:16 <ski_> (benign cases of `unsafeInterleaveST' not counting as "true concurrency")
15:47:35 <lispy> sproingie: you want the -b version
15:47:48 <sproingie> k, thanks :)
15:47:57 <lispy> sproingie: If you forget, you can figure out which one you want by looking at the package dependencies.
15:48:13 <lispy> sproingie: the regular GLFW depends on OpenGL
15:48:39 <shachaf> ski_: I'm not sure I understand "scramble" there.
15:48:53 <sproingie> lispy: ah, right, i forgot about looking at the .cabal file
15:49:00 <ski_> shachaf : try it ?
15:49:05 <sproingie> i was just installing stuff til the red lines in flymake went away
15:49:08 <shachaf> It seems to behave like id?
15:50:13 <ski_>  > scramble "abcd"
15:50:13 <ski_> "abcd"
15:50:19 <ski_>  > reverse (scramble "abcd")
15:50:19 <ski_> "abcd"
15:50:31 <shachaf> Oh, I see.
15:50:56 <shachaf> That's pretty evil, yes.
15:51:48 * hackagebot poker-eval 0.1.1 - Binding to libpoker-eval  http://hackage.haskell.org/package/poker-eval-0.1.1 (DavidHimmelstrup)
15:52:31 <ski_> shachaf : someone invented (i think) it here on #haskell, some years ago (when `unsafeInterleaveST' was still available in lambdabot)
15:52:48 <ski_> (i forget who, and what the operation was called)
15:54:29 <shachaf> elliott: Does your ST model let you do *that*?!
15:54:49 * elliott doesn't quite see how that works.
15:55:52 <shachaf> As each element is forced it takes the next value from an STRef.
15:55:59 <shachaf> It's the same as it would be with unsafeInterleaveIO.
15:56:18 <lispy> sproingie: I usually few the deps on hackage before installing things
15:56:39 <crdueck> :t over
15:56:41 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
15:56:44 <crdueck> :t over both
15:56:46 <lambdabot> (a -> b) -> (a, a) -> (b, b)
15:58:08 <elliott> shachaf: ah
15:58:24 <shachaf> ah
15:58:32 <shachaf> Oops, that was extraneous.
16:41:48 * hackagebot netpbm 0.3.0 - Loading PBM, PGM, PPM image files  http://hackage.haskell.org/package/netpbm-0.3.0 (NiklasHambuechen)
16:44:10 <ski_>   instance (forall ast. (forall sc u. Show u => Show (     ast sc u))
16:44:16 <ski_>                      => (forall sc u. Show u => Show (   f ast sc u)))
16:44:20 <ski_>         =>              (forall sc u. Show u => Show (Mu f     sc u))
16:45:55 <elliott> ski_: yikes
16:46:18 <ski_> it's a rank-`3' instance ;)
16:47:24 <ski_> but i think i only actually need the rank-`2' antecedent as an instance (for a specific `f')
16:51:24 <ski_> (unfortunately, i get `malformed class assertion: forall sc u. Show u => Show (ast sc u)', so i'll have to rephrase, kludging around it)
16:56:21 <elliott> ski_: could use edwardk's forall constraints :P
16:56:26 <elliott> oh it has implies too I think
16:56:28 <edwardk> heh
16:57:30 <ski_> hm, and now i lose my `deriving instance (...) => Show (...)', i see
16:58:16 <ski_> elliwarttk : how would those "forall constraints" work ?
16:59:19 <elliott> ConstraintKinds + (sound) unsafeCoerce, AIUI :P
16:59:22 <elliott> @hackage constraints
16:59:22 <lambdabot> http://hackage.haskell.org/package/constraints
17:02:14 <Sgeo> > (\id => x -> x) (Just 5)
17:02:16 <lambdabot>   <hint>:1:6: parse error on input `=>'
17:02:23 <Sgeo> > (\id -> x -> x) (Just 5)
17:02:24 <lambdabot>   Pattern syntax in expression context: \ id -> x -> x
17:02:32 <Sgeo> > (\(id -> x) -> x) (Just 5)
17:02:34 <lambdabot>   Just 5
17:02:37 <Sgeo> > (\(id => x) -> x) (Just 5)
17:02:38 <lambdabot>   <hint>:1:7: parse error on input `=>'
17:02:41 <Sgeo> :(
17:02:49 <mm_freak> Sgeo: the identity function is \x -> x
17:03:16 <Sgeo> And mm_freak guesses incorrectly what I'm trying to do
17:03:31 <Sgeo> I vaguely thought I saw something on the View Patterns page about => meaning something
17:03:48 <Sgeo> To do with not needing to explictly use Just
17:03:49 <mm_freak> it doesn't
17:04:05 <mm_freak> > (\(id -> Just x) -> x) (Just 5)
17:04:07 <lambdabot>   5
17:10:19 <simpson> So, I know I've asked before, but this is just a rule-of-three thing: Is there a viable virtual filesystem package right now for doing things like treating ZIP files or FTP remotes as directories?
17:16:34 <hpc> in haskell, or in general?
17:16:58 <hpc> i think you'd have better luck asking in #arch or #debian or whatever other linux channel
17:17:00 <simpson> In Haskell.
17:17:16 <hpc> ah
17:17:27 <ivanm> @hoofle findIndex
17:17:28 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
17:17:28 <lambdabot> Data.ByteString.Char8 findIndex :: (Char -> Bool) -> ByteString -> Maybe Int
17:17:28 <lambdabot> Data.ByteString.Lazy.Char8 findIndex :: (Char -> Bool) -> ByteString -> Maybe Int64
17:17:47 <pnielsen> simpson: http://hackage.haskell.org/packages/archive/HFuse/0.2.4.1/doc/html/System-Fuse.html + e.g. https://code.google.com/p/fuse-zip/ is probably your best/easiesst bet
17:17:51 <hpc> so you mean, a package that treats a zip archive, ftp remote, and directory as the same abstraction
17:17:55 <pnielsen> s/easiesst/easiest/
17:18:02 <ivanm> well, my benchmarking suite helped me find a bug in my implementation just because it was too damn fast :p
17:18:06 <hpc> and that would probably be some kind of zipper-based package
17:18:15 <hpc> i bet edwardk already wrote it ;)
17:18:17 <simpson> pnielsen: Pretend, for hypothetical (read: non-hypothetical) reasons, that I need to work on Win32.
17:18:45 <geekosaur> the IFS stuff for win32 is reportedly annoying
17:18:49 <geekosaur> "good luck"
17:19:06 <simpson> Well, see, I know this sounds silly, but I was thinking of a non-FUSEy solution.
17:19:19 <ExternalReality> Anyone want to pair on some code involving the pipes package and zeromq3-haskell?
17:19:22 <simpson> Y'know, something for just my application, so that one single app could mount a ZIP file for its own personal use.
17:21:11 <ExternalReality> Oh come on now. There's got to be someone who wants to write some Haskell code here in #haskell land.
17:21:34 <simpson> ExternalReality: Well, I'll trade you a VFS for some networking code.
17:21:45 <simpson> Actually, no, I take that back. I don't know pipes well enough.
17:22:24 <aphury> gnight
17:22:31 <AfC> ExternalReality: well, you're looking for a fairly narrow intersection :) Gotta be pipes (I'm working in io-streams) and xMQ (I prefer stateless RESTful architectures than queue ones)
17:22:56 <AfC> ExternalReality: otherwise I'd be all over it :)
17:24:03 <nolrai_25> Yo is there a name for "return ()"?
17:24:42 <AfC> ExternalReality: verging on off-topic for #haskell, but what are you working on? Sounds like something consuming data off an enterprise service bus of some kind.
17:24:54 <ExternalReality> Afc: ah but the code is but a library. That takes pipes talk to each other over zeromq. Much like the conduit-stm.
17:25:14 <simpson> nolrai_25: That's it.
17:25:27 <ExternalReality> Too easy
17:25:28 <AfC> nolrai_25: "return unit"? It is such a common construct that sometimes I wish there was a syntactic shortcut for it. Of course, there is; an action that implicitly is already of type m ()
17:25:54 <simpson> :t void -- if you just want to discard the last thing in a do-block...
17:25:56 <lambdabot> Functor f => f a -> f ()
17:26:11 <ExternalReality> Also gonna implement some of the combinators found in the TPL dataflow library should be fun.
17:27:00 <AfC> ExternalReality: I don't have any evidence for this yet, but I'm evolving the hypothesis that pipes/conduits/streams and not to mention STM and and and aren't much help at the distributed data level.
17:27:35 <ski_> nolrai_25 : i have sometimes called it `done'
17:27:37 <nolrai_25> simpson: ah that is one thing I was using it for.
17:27:44 <AfC> ExternalReality: great for managing consistency within a process, of course. But between systems? Messy.
17:28:35 <simpson> nolrai_25: Yeah, that's pretty much why somebody wrote up void.
17:28:37 <ExternalReality> Afc: Isn't that where the zeromq part comes in.
17:28:42 <simpson> :t unit -- does lambdabot have unit?
17:28:44 <lambdabot>     Not in scope: `unit'
17:28:44 <lambdabot>     Perhaps you meant one of these:
17:28:44 <lambdabot>       `init' (imported from Data.List),
17:28:46 <simpson> Ah.
17:28:55 * ski_ thinks `void' should be renamed to `unit' or `ignore'
17:29:08 <ski_> (or else moved into an FFI module)
17:29:23 <simpson> :t pure () -- this is 'unit', but it's not likely to ever show up anywhere
17:29:25 <lambdabot> Applicative f => f ()
17:29:41 <simpson> Or at least not without fixing the Applicative-Monad overlap.
17:29:52 <AfC> ExternalReality: it is if you want a message queue architecture to be how you do distributed systems communication. Lots of prior art. But not the only way to do things.
17:30:29 <ski_> simpson : that being `unit' doesn't fit the pattern with `void' above, no ?
17:30:53 <simpson> ski_: The Typeclassopedia lists it as an alternative definition of Applicative.
17:31:02 * ski_ nods
17:31:12 <simpson> And yeah, void's probably poorly-named.
17:31:24 <ski_> simpson : ok, i thought you were responding to what nolrai_25 was saying about `void'
17:31:31 <simpson> Ah!
17:31:51 <ski_>   instance (           Show_1  f
17:31:55 <ski_>           ,Show u) => Show   (f i u)
17:32:01 <ski_>     where
17:32:02 <ski_>     showsPrec = showsPrec_1
17:32:04 <simpson> No, I'm actually kind of in agreement with the people that want to rename a vast number of the things in and around Monad to make them simpler and more obvious.
17:32:08 <ski_> this is a bad idea, yes ?
17:33:23 * ski_ realizes it's worse than he realized
17:33:43 <JoeyA> I wonder if there's an extension or something that would let me use $ in a pattern match.
17:34:32 <JoeyA> e.g. Just $ Thing 1 2 3 <- ...
17:34:33 <ski_> i wonder whether elliott's suggestion to use `:-' and `:=>' could' maybe work
17:34:47 <JoeyA> (I'm writing tests.  That's why I'm using partial do matches so gratuitously.)
17:34:51 <simpson> JoeyA: Nope, just use more parens.
17:34:52 <ski_> JoeyA : `MaybeT' ?
17:35:19 <JoeyA> Meh, no big deal.  Just wondering.
17:35:41 <JoeyA> It would be nice if you could define your own pattern matching functions, though.
17:35:48 <JoeyA> e.g. define (:) to be uncons.
17:35:55 <JoeyA> (possibly overloaded)
17:36:09 <elliott> ski_: edwardk has a Show1 class too :p
17:37:55 <ExternalReality> Afc: I think the reason why zeromq/queue patterns and pipes/conduit/... go well is because they both are good for attacking streaming data problems. zeromq especially allows me to scale from threads, to processes, to services quite easily and in a light-weight kinda way.
17:38:01 <JoeyA> > let f ((==) Just $ Left 5 -> True) = "yes" in f (Just $ Left 5)
17:38:02 <lambdabot>   Couldn't match expected type `a0 -> Data.Maybe.Maybe a0'
17:38:02 <lambdabot>              with ...
17:38:09 <ExternalReality> Afc: like milk and cookies
17:39:17 <JoeyA> > let f ((==) (Just $ Left 5) -> True) = "yes" in f (Just $ Left 5)
17:39:19 <lambdabot>   "yes"
17:39:59 <JoeyA> Now all we need is exhaustiveness checking.  That shouldn't be too much to ask.
17:41:16 <ski_> elliott : note mine above (application-specific) assumes `f :: * -> * -> *'
17:41:24 <elliott> right
17:41:45 <ski_> elliott : where, btw ?
17:41:52 <elliott> ski_: i might just make a new typeclass for your "ast", honestly
17:42:13 <elliott> oh hmm
17:42:15 <elliott> it'd be for the "f"
17:42:24 <elliott> instance (C f, Show u) => Show (Mu f sc u)
17:43:21 <ski_> elliott : for `Mu' i can cheat with `instance Show (f (Mu f) sc u) => Show (Mu f sc u)', though
17:43:48 <ski_> currently i'm pondering the instance for `ASTF' (my `f')
17:44:01 <ski_> (well, that instance, and instance i need to make it)
17:44:09 <ski_> elliott : where `edwardk:Show1' ? i mean
17:47:28 <elliott> ski_: prelude-extras I think
17:47:31 <elliott> @hackage prelude-extras
17:47:32 <lambdabot> http://hackage.haskell.org/package/prelude-extras
17:47:43 <elliott> possibly the vaguest package name on hackage :)
17:48:11 <ski_> elliott : btw, if i didn't use that trick, i'd of course had defined a `Show_1_1' class (your `C') for `f'
17:48:24 <elliott> yeah
17:48:38 <nolrai_25> Does it ever matter where in a monadTrans stack ReaderT is?
17:48:43 * elliott is wary of the need for abstraction over constraints. it feels like it duplicates machinery we already have (and hence points to a problem with constraints themselves)
17:49:03 <elliott> nolrai_25: ReaderT should distribute over everything but it matters for whether you need to use "lift" if you have multiple in a stack
17:49:09 <ski_> elliott : heh, `Show1' looks exactly like mine :)
17:49:30 <ski_> (perhaps not that surprising, perhaps :)
17:49:34 <elliott> ski_: not much room for creativity :)
17:49:39 * ski_ nods
17:49:43 <elliott> I wonder why it omits show1 etc. when Prelude doesn't, though
17:49:54 <simpson> nolrai_25: Only in that you might want to have it at a certain depth depending on how often you lift to it or zoom from it.
17:50:06 <nolrai_25> elliott: Right! thanks.
17:50:15 <elliott> ski_: incidentally, you can do something like "class One c f where witness1 :: (c (f a) => r) -> r" with ConstraintKinds
17:50:24 <elliott> but I suspect the CPS style it forces you into is unpleasant
17:50:28 <elliott> nolrai_25: :)
17:50:34 <nolrai_25> simpson: zoom from?
17:51:19 <simpson> nolrai_25: Oh, sorry. In lens (and its predecessors), it's possible to "zoom in" on a piece of state in your current monad.
17:51:29 <simpson> :t zoom _2
17:51:30 <lambdabot> (Functor (Control.Lens.Internal.Zoom.Zoomed n c), Zoom m n b t, Field2 t t b b) => m c -> n c
17:51:31 <ski_> elliott : anyway, the problem atm is that i have `Show_1 ast' (expressing `forall sc u. Show u => Show (ast sc u)') in context, and i need to show an `[ast sc u]' (yes, i know `Show u')
17:51:39 <simpson> Oh, wow, that's obtuse.
17:52:05 <simpson> Anyway, you could take something that does State x () and put it into State (x, y) ().
17:52:08 <simpson> Or something like that.
17:52:20 <nolrai_25> Useful.
17:52:23 <simpson> And there's a similar thing for readers.
17:52:58 <simpson> nolrai_25: http://hackage.haskell.org/packages/archive/lens/3.8.7.3/doc/html/Control-Lens-Zoom.html
17:53:19 <nolrai_25> Makes sense.
17:53:25 <simpson> Ah, it's called "magnify" in lens.
17:53:43 <simpson> (In data-lens it was called "focus". The transition still hasn't made it through all of my brain.)
17:54:00 <nolrai_25> Looks like it handles the lifting for me..
17:54:08 <shachaf> simpson: Isn't it zoom?
17:54:43 <nolrai_25> Unless I misunderstand what it means by "Unlike zoom this can change the environment of a deeply nested Monad transformer."
17:54:55 <nolrai_25> Zoom is for state.
17:55:14 <shachaf> Yes, and so is data-lens's "focus".
17:55:24 <shachaf> Anyway I probably missed some context.
17:55:59 <nolrai_25> thasnks all!
17:56:28 <simpson> shachaf: Just how data-lens was cool and I feel like a hipster for having used it.
18:01:29 <ski_> elliott : but since `ast' is fully abstract, there seems little i can do but `instance (Show_1 f,Show u) => Show (f sc u)' (even though it's gratious overlap), apart from duplicating `showsPrec :: Show a => Int -> [a] -> ShowS' from `instance Show a => Show [a]'
18:01:34 <ski_> hmm
18:01:58 <elliott> <ski_> elliott : anyway, the problem atm is that i have `Show_1 ast' (expressing `forall sc u. Show u => Show (ast sc u)') in context, and i need to show an `[ast sc u]' (yes, i  know `Show u')
18:02:09 <elliott> re that: show in what context?
18:02:11 <elliott> can you use showList1?
18:03:09 <ski_> elliott : hm, perhaps that one, or `showsPrec1' from `instance Show1 []'
18:03:38 <elliott> well, with showList1 you shouldn't need any extra instances or such
18:04:02 <gwern> @quote instances
18:04:02 <lambdabot> RossPaterson says: I'm afraid you voided the warranty when you used UndecidableInstances.
18:04:43 <ivanm> wait, there's a warranty? :o
18:11:41 <shachaf> Is Either (a -> b) (b -> a) equivalent to LEM?
18:15:57 <shachaf> ski_ apparently talked about this once?
18:16:10 <ski_> could be
18:16:30 <ski_> one direction is obvious, at least
18:16:36 <edwardk> simpson: magnify zooms in on the environment in a reader, zoom zooms in on the state in a state monad
18:19:19 <shachaf> ski_: I can't see how to derive LEM from it.
18:19:35 <shachaf> So I would guess that it's weaker? What is it?
18:20:20 <ski_> maybe it's equivalent to `forall a. Either (Not a) (NotNot a)' ?
18:24:23 <ivanm> @ask edwardk for your graphs library, did it allow modifying the graph (adding nodes/edges, etc.)?
18:24:24 <lambdabot> Consider it noted.
18:36:52 <lightquake> this is something, but I forgot what it is: case x of Nothing -> return Nothing; Just x' -> f x'
18:37:43 <shachaf> @ty maybe (return Nothing)
18:37:45 <lambdabot> Monad m => (a -> m (Maybe a1)) -> Maybe a -> m (Maybe a1)
18:39:02 <geekosaur> :t fromMaybeT
18:39:04 <lambdabot>     Not in scope: `fromMaybeT'
18:39:04 <lambdabot>     Perhaps you meant `fromMaybe' (imported from Data.Maybe)
18:39:15 <elliott> shachaf: whoa, it's a lens
18:39:54 <ivanm> elliott: what _isn't_ a lens nowadays? :p
18:40:27 <shachaf> @ty maybe (pure Nothing)
18:40:28 <lambdabot> Applicative f => (a -> f (Maybe a1)) -> Maybe a -> f (Maybe a1)
18:40:45 <shachaf> Only a weird one.
18:41:04 <shachaf> Lens (Maybe a) (Maybe b) a (Maybe b)
18:41:29 <lightquake> elliott: what is it?
18:41:55 <shachaf> Lens (Maybe (Maybe b)) (Maybe b) (Maybe b) (Maybe b)
18:42:05 <shachaf> That's no lens!
18:43:53 <shachaf> elliott: This is a serious non-lens.
18:44:02 <shachaf> @let elliott = maybe (pure Nothing)
18:44:05 <lambdabot>  Defined.
18:44:21 <shachaf> > map (toListOf elliott) [Just 5, Nothing]
18:44:24 <lambdabot>   [[5],[]]
18:44:30 <shachaf> > over elliott id (Just Nothing)
18:44:32 <lambdabot>   Nothing
18:46:08 <ski_> @type liftA join .: Data.Traversable.traverse
18:46:09 <lambdabot> (Monad m, Applicative f, Traversable m) => (a1 -> f (m a)) -> m a1 -> f (m a)
18:46:32 <shachaf> Better.
18:46:37 <ski_> @hoogle concatMapM
18:46:38 <lambdabot> No results found
18:46:42 <shachaf> Still not a lens.
18:59:28 <oio> maybe + guards?
19:02:31 <tgeeky> http://arxiv.org/abs/1302.6946 <-- Category Theory for Scientists. 250p textbook from MIT
19:08:02 <ion> Thanks, i’ll check it out.
19:08:20 <LordBrain> looks fun
19:10:20 <latermuse> that book is quite easy reading
19:11:49 <tgeeky> are you calling the book a floozie?
19:12:10 <LordBrain> i think he meant it as a compliment
19:12:29 <ZWolf> Can anyone here see any way to make `putStr . cycle . (++ "\n) $ unwords a` any better/faster?
19:13:48 <LordBrain> Did you intend for that to loop endlessly?
19:13:56 <ZWolf> LordBrain: Yes
19:13:59 <ZWolf> Literally yes.
19:14:04 <ZWolf> http://ix.io/4zZ/
19:14:33 <ion> putStr . unlines . repeat . unwords $ a
19:14:55 * ZWolf had a feeling that there was a function like repeat :)
19:16:24 <ZWolf> Seems faster
19:16:25 <ZWolf> :)
19:16:30 <ZWolf> Thanks ion
19:17:37 <ZWolf> Is it worth telling it to use LineBuffering?
19:20:05 <ivanm> is there an easier way of doing custom Ord instances than: compare (Foo x1 y1 z1) (Foo x2 y2 z2) = case compare x1 x2 of EQ -> (case compare y1 y2 of EQ -> compare z1 x2; ordy -> ordy); ordx -> ordx ?
19:20:20 <LordBrain> i think you should tell it linebuffering, some terminals might need that
19:20:28 <ion> Eh, i’d be very surprised if that had a difference in speed noticeable to a human.
19:20:45 <LordBrain> shrugs
19:21:01 <shachaf> ion: I would expect the one that used cycle to be slightly better, maybe.
19:21:08 <shachaf> Who really knows/cares.
19:22:05 <shachaf> ivanm: compare (x1,y1,z1) (x2,y2,z2) ?
19:22:24 <ivanm> shachaf: yeah, I suppose so :p
19:22:29 <c_wraith> shachaf: except it should be pairs :)
19:22:37 <ivanm> (specifically, I want to apply a function to both the z's first, but that's doable as well
19:22:39 <ivanm> )
19:22:40 <c_wraith> on, no, it's triples
19:22:49 <ivanm> the other alternative is to use mconcat
19:22:56 * ivanm just remembered the Monoid instance
19:23:12 <ZWolf> ivanm: Speed seems identical with gnu yes now
19:23:21 <ivanm> ZWolf: hmmm?
19:23:26 <ZWolf> ivanm: Err sorry
19:23:29 <ZWolf> ion:  ^^
19:23:40 <ivanm> heh
19:24:41 <ion> ivanm: Doesn’t the derived instance of Ord do exactly that?
19:25:12 <ivanm> ion: I actually want to apply a function to the z values before comparing them
19:25:22 <ivanm> (to remove trivial differences in implementation that might arise)
19:28:18 <ParahSailin_> so what do i need to use the llvm backend?
19:28:32 <ivanm> llvm
19:28:33 <ivanm> :p
19:29:11 <ion> ivanm: instance Ord Foo where compare = mconcat [ compare `on` x, compare `on` y, compare `on` f . z ]
19:29:23 <ivanm> ion: yup, already figured that out :)
19:29:29 <ivanm> thanks anyway though
19:29:36 <shachaf> comparing = compare `on`
19:30:00 <ivanm> @hoogle comparing
19:30:01 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
19:30:48 <ivanm> oh, wait, yours is even nicer as you don't need the actual values...
19:32:24 <ivanm> that doesn't work for defining (==) though :(
19:33:46 <shachaf> Well, you can define a function like it.
19:34:04 <shachaf> In fact one probably already exists.
19:35:18 <ivanm> oh?
19:35:39 <ivanm> @hoogle [a -> a -> Bool] -> a -> a -> Bool
19:35:40 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
19:35:40 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
19:35:40 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
19:35:49 <shachaf> Well, there is the All monoid
19:36:20 <ivanm> huh, never really touched any of the newtypes in Data.Monoid
19:37:28 <shachaf> Feel free to write "all (\x y -> f x y)" or something.
19:37:48 <ivanm> yeah, (All .) . (==) `on` f
19:38:05 <shachaf> I mean something like
19:38:16 <shachaf> Er, \f ->, not \x y ->
19:38:36 <shachaf> @ty \x y -> all (\f -> f x y) [(==) `on` fst, (==) `on` snd]
19:38:38 <lambdabot> (Eq b1, Eq b) => (b, b1) -> (b, b1) -> Bool
19:38:52 <ivanm> @type \ f -> (All .) . (==) `on` f
19:38:54 <lambdabot> Eq b => (a -> b) -> a -> a -> All
19:38:57 <ivanm> and then mconcat on that
19:39:01 <shachaf> Sure, you can do that.
19:39:04 <shachaf> Maybe you can use ala.
19:39:11 <ivanm> is that in lens?
19:39:17 <shachaf> Yes.
19:39:29 <ivanm> might pass on that for now
19:39:49 <shachaf> OK.
19:39:59 <shachaf> I think the explicit "all" is clearer than the monoid. :-)
19:40:06 <ivanm> yeah
19:40:32 <shachaf> monoids are pretty easy though
19:40:38 <ivanm> but by this stage, I might as well manually pull the values apart, since I don't need these functions anywhere else :p
19:41:08 <ivanm> @type \ x y -> all ($y) . map ($x)
19:41:10 <lambdabot> a1 -> a -> [a1 -> a -> Bool] -> Bool
19:41:32 <shachaf> @ty \x y -> all (($ y) . ($ x)) [(==) `on` fst, (==) `on` snd]
19:41:34 <lambdabot> (Eq b1, Eq b) => (b, b1) -> (b, b1) -> Bool
19:42:01 * shachaf :☹( at newtype noise
19:42:18 <ivanm> where's the newtypes there?
19:42:25 <shachaf> All
19:42:35 <shachaf> I mean, the monoid version is nicer.
19:42:40 <shachaf> Except for the whole wrapping business.
19:42:45 <ivanm> yeah
19:43:12 <shachaf> ivanm: x == y = compare x y == EQ :-)
19:43:16 <ivanm> @pl \ x y -> all (\ f -> f x y)
19:43:16 <lambdabot> (all .) . flip . flip id
19:43:21 <ivanm> shachaf: I am tempted to do that :p
19:44:36 <elliott> compare (compare x y) EQ == EQ
19:44:48 * ivanm glares at elliott 
19:44:50 <shachaf> elliott: ?
19:45:17 <elliott> compare (compare (compare x y) EQ) EQ == EQ
19:45:55 <ZWolf> Is there a way to compile a haskell program to the bare minimal execuitable?
19:46:00 <shachaf> @ty (==EQ).:compare
19:46:01 <lambdabot> Ord a => a -> a -> Bool
19:46:14 <ivanm> ZWolf: as in no dynamic linking?
19:46:29 <ZWolf> I.e gnu/yes -> 28K, c version by woddf2 -> 8K, my haskell yes -> 1.3M
19:46:31 <ivanm> IIUC, on *nix you still need to dynamically link to glibc and possibly gmp
19:46:37 <shachaf> No. Your executable will always be just above minimal.
19:46:37 <ZWolf> ivanm: Not quite
19:46:38 <ivanm> strip it?
19:46:38 <shachaf> Minimalism within your grasp -- you can see it, almost touch it -- but always just out of reach.
19:47:02 <ivanm> ZWolf: strip?
19:47:06 <ZWolf> 32K -dynamic
19:47:21 <ZWolf> ivanm: Strip how?
19:47:22 <ivanm> remember, the haskell version has the RTS in there
19:47:27 <ivanm> ZWolf: man strip
19:47:31 <ZWolf> Yea I know it's there
19:47:32 <ivanm> might help
19:47:51 <ZWolf> 20K even
19:47:53 <ivanm> but the RTS overhead is rather constant, so for larger programs its less of an overhead
19:48:14 <ZWolf> ivanm: How to remove RTS?
19:48:19 <ivanm> you can't
19:48:24 <elliott> ZWolf: unfortunately whther an executable is minimal for a given program or not is undecidable :P
19:48:26 <ivanm> RTS == Run Time System
19:48:48 <shachaf> You can surely make a version even smaller than 8K!
19:48:50 <shachaf> Who cares?
19:49:50 <ZWolf> yes2: Most RTS options are disabled. Link with -rtsopts to enable them.
19:49:58 <ZWolf> Heh
19:50:14 <ivanm> that's more for security, etc. reasons than for minimalism
19:50:14 * ZWolf wants to remove those +RTS messages junk.
19:50:23 <ivanm> IIUC they're still there, just not enabled
19:50:26 <Frostix> Hey guys
19:50:36 <Frostix> Can anyone help me out with a simple error?
19:50:36 * ivanm waves idly in Frostix's general direction
19:50:44 <ivanm> depends on the error
19:50:58 <shachaf> Frostix: Not if you don't say what it is.
19:51:08 <shachaf> We have a no-mindreading policy.
19:51:28 <ZWolf> ivanm: Any way to minimize what gets compiled in for the RTS? I.e only what is enabled (no not enabled messages/code etc)
19:51:37 <ivanm> I doubt it
19:51:39 <ivanm> why?
19:51:45 <ZWolf> Moar tinier!
19:51:50 <Frostix> Here it is
19:51:50 <Frostix> http://prntscr.com/uoolr
19:51:56 <ivanm> are you trying to put this onto something with minimal memory?
19:52:14 <ivanm> Frostix: are you trying to define a function?
19:52:21 <ivanm> if you're doing it in ghci, you need to use let
19:52:22 <Frostix> Yes?
19:52:25 <Frostix> oh ok
19:52:27 * ZWolf packed it down to 8K! Ty upx :)
19:52:47 <ivanm> > let boomBangs xs = [if x < 10 then "Boom!" else "Bang" | x <- xs, odd x] in boomBangs [1..4]
19:52:49 <lambdabot>   ["Boom!","Boom!"]
19:53:03 <Frostix> Gave me parse error except for 'then'
19:53:12 <Frostix> Let me try your code
19:53:13 <geekosaur> ghci is not a top level, it is something like the inside of a do block
19:54:21 <Frostix> http://prntscr.com/uooux
19:54:22 <shachaf> ZWolf: Now make it smaller than 8K!
19:54:28 <shachaf> I bet you can do under 1K pretty easily.
19:54:43 <ivanm> Frostix: check the end...
19:54:48 <ivanm> and read the error message
19:54:53 <Frostix> lol gotcha
19:54:56 <ivanm> it's telling you it's something to do with "odd"
19:55:25 <ZWolf> shachaf: How? D:
19:55:37 <shachaf> Exercise.
19:56:02 <ZWolf> shachaf: woddf2's C version compiles to 8K. ghc -dynamic, strip, upx gets it down to 8K!
19:56:16 <Frostix> tells me xs isn't in scope
19:56:17 * ZWolf doesn't want to switch to ulibc yet so can't get smaller can I ?
19:56:29 <Frostix> oops
19:56:58 <ivanm> ZWolf: I doubt ulibc would do anything, as it's dynamically linked
19:57:07 <Frostix> got it working
19:57:10 <ZWolf> Eh true
19:57:19 <Frostix> how come i have to use the let command in ghci?
19:57:36 <ZWolf> Frostix: Because it's interactive
19:57:56 <Frostix> also I'm using - "Learn You a Haskell for Great Good" for a learning resource. Does anyone have any other good ones?
19:58:08 <ZWolf> Frostix: That is one of the best
19:58:14 <ivanm> @where tutorials
19:58:15 <lambdabot> http://haskell.org/haskellwiki/Tutorials
19:58:21 <ZWolf> @where rwh
19:58:21 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:58:39 <Frostix> Thank you. Also is Leksah a good tool?
19:58:41 <ZWolf> ivanm: Heh. Noted to remember that one ^_^
20:05:57 <nolrai_25> I found Leksah flaky and slow, but that was almost a year ago.
20:06:40 <[swift]> so i turned on "-Wall" and realized i was doing something stupid
20:06:57 <ivanm> [swift]: apart from not using -Wall earlier you mean? :p
20:07:02 <sproingie> i never got leksah to play nice, i use emacs and flymake
20:07:05 <[swift]> ivanm: yeah, it's even worse than that!
20:07:37 <[swift]> here's what i tried: checkVersion ("MajorVersion", majorVersion) = True
20:08:03 <[swift]> the intention was that i'd pass something into checkVersion and that pattern would match if the second element of the tuple was the same as the majorVersion binding i defined elsewhere
20:08:10 <[swift]> obviously in retrospect, that doesn't work
20:08:21 <[swift]> it just creates a new binding that shadows the existing majorVersion
20:08:31 <[swift]> but my question is: can i do that somehow?
20:08:41 <[swift]> how can i match against the _value_ of majorVersion, instead of creating a binding?
20:08:42 <ivanm> [swift]: guards? if statement?
20:09:01 <[swift]> ivanm: hmm well those would work, true
20:09:19 <[swift]> ivanm: but i thought it would be cool to use pattern matching =) i guess you can't tho
20:09:26 <ivanm> nope
20:09:34 <ivanm> pattern matching is against constructors and literals
20:09:54 <[swift]> aha! i could use template haskell for this, right?
20:09:58 <[swift]> (not that i'm going to.)
20:10:01 <[swift]> but in theory...
20:10:52 * [swift] rubs his hands together gleefully
20:23:10 <ZWolf> Is there any way that one might store a string of [a-zA-Z0-9] into a data structure/type ?
20:23:14 <ZWolf> bytestring?
20:23:42 <ivanm> if you want to ensure you can only have that subset of Char, you either need to create a custom data type or have a smart constructor
20:24:01 <ZWolf> subset of char yes
20:24:06 <ivanm> otherwise, you can use String, ByteString (but be careful) or Text
20:24:37 * BMeph would've just gone with a "tl;dr - now ask the REAL question now..." ;)
20:24:37 <ZWolf> Yes I know those 3 would work. I didn't know how to ask til you said "subset of char" :P
20:24:41 <ivanm> specifically, you'd probably want one of the .Char8 variants of ByteString
20:25:25 <ivanm> ZWolf: to ensure you only have that subset, you probably want smart functions/constructors that ensure any input matches what's required (e.g. returns a Maybe)
20:25:40 <ZWolf> Gonna use parsec
20:26:29 <ivanm> oh, to parse it?
20:26:33 <ivanm> that's even easier then
20:26:33 <ZWolf> ivanm: Yea
20:26:44 <shachaf> ZWolf: Here, a 424 byte "yes".
20:26:59 <shachaf> By just writing it out without any special cleverness.
20:27:06 <ivanm> but unless you want to define your own data type, there's no way of guaranteeing that given an actual value it doesn't have any illegal characters
20:27:38 <ivanm> can't you just have a small "yes" program by having: #!/bin/sh echo "${@}" ? :p
20:27:42 <ZWolf> I want the data type to only have the specific chars.
20:28:06 * ZWolf not playing with yes anymore btw.
20:28:09 <ivanm> ZWolf: then you need to create a new data type with all 62 possible values
20:29:16 <ZWolf> ivanm: Well.. TChar=/[a-zA-Z0-9]/ Token=[TChar
20:29:18 <ZWolf> ]
20:30:03 <ivanm> ZWolf: OK, 63 constructors
20:30:16 <ivanm> because there's no way of saying at the data type level "only allow these characters"
20:30:22 <ivanm> the best you can do is smart constructors
20:30:39 <ivanm> (and if the internals of the data type aren't exported then users can't construct dodgy values)
20:30:40 <ZWolf> Example implementation?
20:31:22 <ivanm> data AllowedChars = LowerA | LowerB | LowerC | ... | UpperA | UpperB | ... | Zero | One | ... | ListOfChars [AllowedChars]
20:32:08 <ZWolf> Holly crap
20:32:31 <ZWolf> Easier way? like.. ['a'..'z'] ++ ['A'..'Z'] ++ [0..9] ??
20:32:33 <ivanm> alternatively: newtype AllowedChars = AllowedChars { toString :: String }; onlyAllowed :: String -> Maybe AllowedChars; onlyAllowed str | all validChars str = Just $ AllowedChars str; | otherwise = Nothing
20:32:48 <ivanm> ZWolf: you could write a generator that would generate it for you
20:33:13 <ivanm> but, as I said, if you want to say at the data type level "here are all the possible values", you need to explicitly list them all
20:33:48 <ZWolf> Integer isn't defined in this way. Nor is char.. ?
20:33:58 <ivanm> no, they're special cases
20:34:01 <ivanm> but done in the compiler
20:34:12 <ZWolf> Crap. :|
20:34:27 <ivanm> ZWolf: let's go back a step: what are you wanting to do?
20:35:28 <ivanm> preflex_: seen preflex
20:36:11 <ZWolf> Token server where Tokens = [Token], Token = [TChar], TChar=/[a-zA-Z0-9]/
20:36:21 <ivanm> no, what are you wanting to do
20:36:26 <ivanm> as in a textual description
20:36:30 <preflex>  Sorry, I haven't seen preflex
20:36:33 <ivanm> what's your end goal here?
20:36:44 <ivanm> preflex: you obviously haven't looked into a mirror lately!
20:36:44 <ZWolf> Currently tcp but intended to use a socket file
20:36:49 <ivanm> to do _what_ ?
20:36:57 <ZWolf> Sorry.. Token server, generate tokens, use them etc.
20:37:02 <ivanm> and why not use an existing library (as we do have networking libraries)
20:37:08 <ivanm> tokens as in authentification?
20:37:23 <ZWolf> (For an invite only registration for a shell service)
20:37:27 <ivanm> OK
20:37:28 <ZWolf> Kinda
20:37:33 <ZWolf> ssh newuser@host
20:37:37 <ZWolf> Token >
20:37:39 <ZWolf> Invite only. ^
20:37:49 <ivanm> so, why does your code need to guarantee at the _type level_ that the characters are in the range [a-zA-Z0-9] ?
20:38:02 <ivanm> I mean, yes, it would be nice if you could make as many guarantees as possible about this
20:38:15 <ivanm> but if you're only constructing these internally, is it really necessary?
20:38:26 <ZWolf> Hmm
20:38:29 <ivanm> won't the smart constructor solution suffice?
20:38:33 <ZWolf> Less ram footprint ^_^ ?
20:38:41 <ivanm> e.g. newtype AllowedChars = AllowedChars { toString :: String }; onlyAllowed :: String -> Maybe AllowedChars; onlyAllowed str | all validChars str = Just $ AllowedChars str; | otherwise = Nothing
20:38:52 <ivanm> ummm, the difference would probably be minimal
20:39:14 <ZWolf> Yea bits/bytes worth but still :P
20:39:21 <ivanm> in that example, you would export the AllowedChars type (but not the constructor!), the smart constructor onlyAllowed and the toString function
20:39:24 <ZWolf> In a way it's like comparint String with ByteString
20:39:27 <ZWolf> comparing *
20:39:35 <arkeet> > allowDigit c = guard (isDigit c) >> Just c in [sequence (map allowDigit "1234"), sequence (map allowDigit "123a")]
20:39:37 <lambdabot>   <hint>:1:14: parse error on input `='
20:39:37 <ivanm> ZWolf: if you're worrying about transmitting it over the wire, then use an appropriate encoding
20:39:40 <arkeet> > elt allowDigit c = guard (isDigit c) >> Just c in [sequence (map allowDigit "1234"), sequence (map allowDigit "123a")]
20:39:42 <lambdabot>   <hint>:1:18: parse error on input `='
20:39:42 <arkeet> >let  allowDigit c = guard (isDigit c) >> Just c in [sequence (map allowDigit "1234"), sequence (map allowDigit "123a")]
20:39:46 <arkeet> argh.
20:39:54 <arkeet> > let allowDigit c = guard (isDigit c) >> Just c in [sequence (map allowDigit "1234"), sequence (map allowDigit "123a")]
20:39:56 <lambdabot>   [Just "1234",Nothing]
20:40:05 <ivanm> ZWolf: stop prematurely optimising! :p
20:40:07 <arkeet> wait.
20:40:11 <arkeet> :t mapM
20:40:12 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
20:40:16 <arkeet> heh.
20:40:19 <ZWolf> ivanm: Hehe
20:40:30 <arkeet> > map (mapM allowDigit) ["1234","123a"]
20:40:32 <lambdabot>   Not in scope: `allowDigit'
20:40:36 <arkeet> oh right.
20:40:37 * arkeet quits
20:40:45 <ZWolf> arkeet: ghci maybe? :P
20:40:58 <arkeet> nah, I know it works.
20:41:08 <arkeet> just need to type it right.
20:42:16 <shachaf> ZWolf: Did you beat 408 bytes yet?
20:42:22 <arkeet> > let f x = guard (all isDigit x) >> Just x in map f ["123", "12a"]
20:42:24 <lambdabot>   [Just "123",Nothing]
20:42:28 <ZWolf> shachaf: 8K
20:42:34 * ZWolf not playing with that anymore..
20:42:39 <arkeet> what are we playing?
20:42:57 <ZWolf> gnu/yes replacement
20:43:03 <ZWolf> Well were
20:43:16 <arkeet> main = forever (putStrLn "y")
20:43:24 <ZWolf> lol
20:43:31 <shachaf> arkeet: I think we're looking at Linux ELF executable size or something.
20:43:35 <arkeet> ah.
20:43:44 <ZWolf> arkeet: http://ix.io/4A5
20:43:45 <ZWolf> ;)
20:43:54 <arkeet> no asm allowed?
20:44:00 <ZWolf> arkeet: haskell!
20:44:02 <arkeet> :(
20:44:11 <ivanm> ZWolf: that doesn't look fully compatible with GNU yes
20:44:12 <ZWolf> And has to have html/version
20:44:14 <ZWolf> s/html/selp
20:44:19 <ZWolf> s/selp/help/
20:44:40 <ivanm> isn't that part of the whole "ZOMG, why is GNU yes so big?" complaints?
20:44:47 <ivanm> or was that for echo?
20:44:48 <arkeet> why do you printf with constant arguments?
20:45:03 <ZWolf> arkeet: No idea :|
20:45:34 <ivanm> even for the --version one, I would just use putStrLn $ "yes " ++ show 0.1 ++ etc.
20:45:40 * ZWolf was writing it while looking at woddf's C version and he all printf :P
20:45:48 <ivanm> well, yes, because that's _C_
20:46:24 <ZWolf> ivanm: Heh, even then. I'd use unwords ["xx",show 0.1,"..."]
20:46:43 <ivanm> depends whether you want spaces or not
20:46:48 <ivanm> I suppose you could use concat though
20:46:54 <ZWolf> Yea
20:47:04 <ZWolf> or ["whatever"] >>= id
20:47:17 <arkeet> or join ["whatever"]
20:47:28 <ZWolf> import Control.Monad (join) much?
20:47:31 <arkeet> yes.
20:47:34 <ZWolf> :(
20:48:30 <oio> use XParallelListComp on ghci
20:48:34 <arkeet> surely not worse than import Text.Printf (printf)
20:48:43 <ZWolf> Indeed
20:48:52 <oio> ?
20:48:57 <ZWolf> oio: What?
20:49:33 <oio> like runghc -XParallelListComp xxx.hs
20:49:58 <arkeet> is there supposed to be a question?
20:49:58 <ZWolf> Yes, but what xxx.hs are you on about?
20:50:46 <oio> >[x*z|x<-[1..10]|z<-[1..10]]
20:50:57 <arkeet> > join (zipWith (*)) [1..10]
20:50:58 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
20:51:24 <arkeet> > map (join (*)) [1..10]
20:51:26 <lambdabot>  Terminated
20:51:28 <arkeet> > map (join (*)) [1..10]
20:51:30 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
20:51:34 <oio> i know that isnt the problem..
20:51:36 <arkeet> :p
20:51:55 <oio> just want to use XParallelListComp on ghci
20:52:06 <arkeet> so use it.
20:52:09 <ZWolf> oio: Oh I think you are after ghci -fXParallelListcomp
20:52:30 <arkeet> no
20:52:34 <arkeet> ghci -XParallelListComp works for me.
20:52:50 <ZWolf> ef
20:52:57 <ZWolf> Where that f come from? D:
20:53:20 <oio> yep f flags
20:53:32 <arkeet> -flags
20:56:48 <ZWolf> ivanm: Okay.. How to generate a random token to that format? :)
20:57:44 <ZWolf> genToken = randomRIO (0,62) >>= \case ... ?
20:57:56 <ZWolf> per each piece
20:58:15 <ZWolf> wait.
20:58:19 <LordBrain> don't use case that's a keyword
20:58:42 <arkeet> LordBrain: no, it's LambdaCase.
20:59:07 * ZWolf ♥ lambdacase
20:59:36 <shachaf> If only its syntax wasn't awful.
20:59:48 <arkeet> would you rather have of?
20:59:57 <arkeet> (with no \)
21:00:07 <ZWolf> shachaf: after using it, it's nice.
21:00:16 <ZWolf> shachaf: It is a bit awful but it's sure nice. :)
21:21:27 <dennda_> My first foray into the fine world of Haskell: https://gist.github.com/dennda/27a1c1d6afcca8b3db0e -- Anything particularly dumb?
21:22:02 <dennda_> I'd also be interested to know if my 'style' (if I may) is terrible, e.g. the indentation and such
21:23:06 <amiller> your indentiation dennda_  is pretty weird like line 26 has a tab character and also several spaces
21:23:46 <mgsloan> Most people indent with 2 or 4 spaces
21:23:53 <dennda_> ah damn, well yes, that is this new editor I'm trying.
21:23:59 <shachaf> You should indent with spaces.
21:24:10 <robonerd> does haskell have "the array"?
21:24:17 <robonerd> array type of data
21:24:25 <ZWolf> :t Array
21:24:27 <lambdabot> Not in scope: data constructor `Array'
21:24:29 <ZWolf> :)
21:24:34 <robonerd> i don't knwo what that means
21:24:36 <robonerd> english please
21:24:44 <ZWolf> http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text-Array.html#t:Array
21:24:47 <shachaf> robonerd: Yes, there are arrays in Haskell.
21:24:49 <shachaf> @google haskell array
21:24:51 <lambdabot> http://www.haskell.org/haskellwiki/Modern_array_libraries
21:24:51 <lambdabot> Title: Arrays - HaskellWiki
21:24:54 <shachaf> For example.
21:24:56 <dennda_> OK, of course spaces for indentation. Would you guys put the where at the end like that and then just indent by one level (i.e. 2 or 4 spaces) on the next line?
21:25:05 <robonerd> ok and in haskell array, is insert order of elements guaranteed?
21:25:15 <shachaf> dennda_: You should probably not write your own sorting function, and if you do, probably not write it like that. :-)
21:25:20 <shachaf> Data.List has sortBy
21:25:42 <robonerd> shachaf what does sortBy get you?
21:25:52 <shachaf> What?
21:25:56 <ZWolf> :t sortBy
21:25:56 <dennda_> shachaf: Well this is just for practice/educational purposes. What's the big problem with that implementation?
21:25:57 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
21:26:00 <shachaf> robonerd: Oh, you're FYCouch?
21:26:17 <robonerd> ZWolf i don't understand what lambdabot said
21:26:28 <ZWolf> robonerd: Type for the sortBy function
21:26:43 <robonerd> k let me back up
21:26:48 <robonerd> ok and in haskell array, is insert order of elements guaranteed?
21:26:49 <shachaf> dennda_: It's just rather inefficient. Some people confuse it with quicksort because it looks sort of similar.
21:27:05 <ZWolf> It takes a function that orders a against a. a list and it returnes the ordered list
21:27:09 <shachaf> robonerd: (Are you?)
21:28:02 <ZWolf> (a -> a -> Ordering) for example.. 'a' LT 'b' so..
21:28:04 <ZWolf> :t comparing
21:28:05 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
21:28:18 <ZWolf> hm
21:28:45 <robonerd> c'mon, i've tried to make this clear. i don't understand the stuff lambabot says. regarding sortBy, you said it takes a function?
21:29:14 <dennda_> That is apparent from the type signature
21:29:20 <robonerd> every time i come in here 95% of the help is spoken through lambdabot. i can tell everyone is very proud of it, but it doesn't make sense to just show off
21:29:24 <dennda_> (I mean function signature)
21:29:29 <robonerd> yea, gee stupid me to not just know that
21:29:30 <ZWolf> robonerd: (something) in a type sig is another function
21:29:37 <shachaf> sortBy wasn't an answer to your question. It was an answer to dennda_'s question. It doesn't have anything to do with arrays.
21:29:47 <robonerd> dangit
21:29:56 <ZWolf> Ah
21:29:59 <robonerd> all this just to find out if haskell arrays have a fucking order?
21:30:12 <ZWolf> Even I got a little confused following..
21:30:18 * ZWolf afk going for a walk with a friend.
21:30:32 <shachaf> The reason no one is answering your question is that no one has any idea what you're asking.
21:30:47 <shachaf> And in my case haskell/13.01.15:21:05:10 <shachaf> In my experience FYCouch is so unpleasant that I've lost any desire to answer their questions.
21:30:54 <shachaf> So please try being more pleasant about it. :-)
21:31:59 <dennda_> Is it just me, or is vim's haskell lexer not the most exciting?
21:32:14 <mgsloan> robonerd: people use lambdabot so that you can learn to help yourself.  People are happy to help you out, but not if you're putting in a minimal effort
21:32:17 <robonerd> my apology for receiving no help
21:32:17 <lispy> dennda_: how so?
21:32:34 <shachaf> dennda_: All vim needs to do is syntax-highlight, isn't it?
21:32:38 <shachaf> It works well enough for that.
21:33:00 <dennda_> Well yes. I was comparing it to this other editor that seems to pick up some more elements of the language
21:33:18 <mgsloan> robonerd: lambdabot's interface is very similar to ghci's.  You can answer many of your questions by learning how to ask it questions and understand the results
21:33:56 <dennda_> To illustrate the difference: http://d.pr/i/asW
21:34:27 <shachaf> dennda_: I don't understand what's going on there.
21:34:40 <shachaf> Why are "words" and "show" highlighted, but not "sumCount"?
21:34:50 <lispy> dennda_: is the RHS sublime?
21:34:54 <shachaf> Yes.
21:34:57 <dennda_> lispy: Yeah
21:35:09 <dennda_> I was just trying that one.
21:35:21 <shachaf> If it highlights standard library functions better than your own functions, I don't like it.
21:35:30 <dennda_> shachaf: My guess is it has a list of built-ins/well-knowns
21:35:32 <lispy> dennda_: I kind of like that. I wonder what it would take to implement that in emacs or vim
21:35:32 <shachaf> My functions should be equal citizens.
21:35:55 <dennda_> Yeah, that part is a little funky
21:36:08 <lispy> shachaf: So yeah that part is not so amazing, but I like the way it makes type signatures stand out
21:36:58 * lispy has no idea how to write vim plugins and hopes to keep it that way
21:37:19 <lispy> Not having a draw to hack on the editor was part of the charm in learning vim recently
21:37:34 <shachaf> The vim syntax highlighting is fine for me. I don't ask for much.
21:37:40 <lispy> With emacs it's just too tempting to waste time hacking elisp.
21:37:41 <shachaf> I would like "forall" to be highlighed, though!
21:37:58 <mgsloan> sublime text has a pretty excellent vim mode, and decent haskell highlighting
21:38:19 <shachaf> dennda_: Anyway, those where-bindings are way too indented.
21:38:25 <shachaf> They even spill off your own screen.
21:38:27 <dennda_> Regarding that code shown there... Would it make sense to define some sort of data type for the [(Int, a)] part?
21:38:41 <shachaf> They should just be a few spaces off from the left.
21:38:42 <lispy> I typically work from a virtual machine though. So I doubt I would be able to integrate a typical graphical editor into my workflow. This is where vim/emacs really shine for me.
21:38:44 <dennda_> shachaf: Yeah, agreed
21:39:13 <shachaf> dennda_: This code is too small to care about things like that.
21:39:16 <dennda_> mgsloan: I wasn't aware that a vim mode existed for that editor
21:39:32 <MFHask> I also think Sublime Text is pretty good for Haskell
21:39:33 <lispy> dennda_: [(Int, a)] a perfectly fine type but if you're attaching some meaning to some data it's always a good idea to consider making a type
21:39:42 <shachaf> Probably [(a,Int)] is better than [(Int,a)]
21:39:44 <shachaf> More standard.
21:39:47 <mgsloan> dennda_: Oh yeah, it's quite a complete vim emulation, extensions are written in python
21:39:55 <shachaf> There are various key-value data types like the one in Data.Map
21:40:22 <dennda_> shachaf: Right, but educational purposes, so bare with me. I tried that, but I failed at expressing that the `a` of the Data type should mean "all instances of the Eq typeclass"
21:40:28 <mgsloan> overall, sublime text is pretty and fast
21:40:29 <shachaf> Oh, you have duplicates too?
21:40:40 <mgsloan> I've heard Sublime Haskell is good, but I don't use it myself
21:40:42 <shachaf> dennda_: No, every function there has an Eq constraint. You expressed it fine.
21:41:14 <shachaf> dennda_: I would say this code is too small to give you serious advice on.
21:41:16 <lispy> if duplicates are not allowed then a Data.Map is probably better.
21:41:19 <dennda_> shachaf: That was assuming I were to define a data type for the [(Int, a)] part (if it became sufficiently big for it to matter)
21:41:23 <dennda_> shachaf: OK
21:41:30 <shachaf> dennda_: Make a bigger task, and don't restrict yourself to not using standard library functions.
21:41:43 <shachaf> If you want to keep the spirit of the exercise, make yourself implement standard library functions before you use them. :-)
21:42:04 <dennda_> That was the idea
21:42:16 <shachaf> No, sortCounts isn't sortBy.
21:42:20 <shachaf> It's hard-wired to use fst.
21:43:48 <lispy> dennda_: is this the haskell mode that you use? https://github.com/SublimeHaskell/SublimeHaskell
21:44:41 <dennda_> lispy: That screenshot is showing the straight editor. I have not configured it much
21:45:47 <dennda_> lispy: I'll try that one, though
21:46:07 <lispy> dennda_: ah, okay. I was actually just hoping to find the code that does the highlighting.
21:53:05 <lispy> I think I found it
21:53:11 <lispy> https://github.com/joshourisman/Sublime-Text-2-Packages/blob/master/Haskell/Haskell.tmLanguage
21:53:19 <jfischoff> Is there much use in a higher ranked value arguments (as opposed to higher ranked functions arguments)?
21:54:05 <geekosaur> encapsulation. see ST for an example
21:57:10 <dennda_> mgsloan: That is pretty cool. Do you know of a way to make that caret become a block in command mode?
21:58:00 <mgsloan> dennda_: You can make a line of cursor with alt+cursors
21:58:19 <mgsloan> dennda_: then you can switch to visual mode and select
21:58:36 <mgsloan> it probably supports normal vim block mode, but I don't have that under my fingers :)
21:58:39 <dennda_> mgsloan: Sorry, I meant how the caret is actually drawn; I wasn't talking about selection
21:58:48 <mgsloan> ohh
21:58:55 <mgsloan> Hmm, probably possible
21:59:12 <mgsloan> I meant alt+arrows - you should try that.  It's pretty neat
21:59:29 <mgsloan> err, alt+shift+arrows
22:00:20 <jfischoff> geekosaur: I need to construct a polymorphic function using polymorphic values, for the input to a higher rank argument of another function.
22:01:18 <jfischoff> I want to expose this to client code, and have them pass in say Doubles and have it work, but … I don't think this is really possible
22:01:36 <jfischoff> also it probably doesn't really make any sense
22:01:44 <jfischoff> with out the seeing the code :)
22:05:13 <jfischoff> I am assuming there is no way to write this: toInterface :: Floating a => Double -> a ?
22:05:34 <jfischoff> which is the straightforward solution
22:10:30 <dennda_> mgsloan: Not properly it seems: http://www.sublimetext.com/forum/viewtopic.php?f=4&t=3282
22:11:11 <mgsloan> well, there is that plugin
22:11:29 <mgsloan> if you install package control, installing such stuff gets really streamlined
22:12:03 <dennda_> Already did. I need to get familiar with this editor. I really like it so far, but I've been using vim for the past 10 years or so
22:22:06 <lispy> ?hoogle Floating a => Double -> a
22:22:06 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
22:22:07 <lambdabot> Prelude acos :: Floating a => a -> a
22:22:07 <lambdabot> Prelude acosh :: Floating a => a -> a
22:24:43 <arkeet> :t fromRational
22:24:45 <lambdabot> Fractional a => Rational -> a
22:24:46 <arkeet> :t toRational
22:24:48 <lambdabot> Real a => a -> Rational
22:25:34 <Sgeo> Maybe unsafeCoerce should be excluded from Hoogle most of the time?
22:25:41 <Sgeo> It can answer for almost any function...
22:25:51 <Sgeo> Well, any function, I guess
22:25:56 <Sgeo> @hoogle a->a
22:25:57 <lambdabot> Prelude id :: a -> a
22:25:57 <lambdabot> Data.Function id :: a -> a
22:25:57 <lambdabot> GHC.Exts breakpoint :: a -> a
22:26:16 <Sgeo> Although I guess it doesn't when there are better choices
22:28:07 <ChongLi> hmmm nvi is even cooler
22:29:02 <arkeet> Sgeo: it lists most general types first
22:29:35 <arkeet> or
22:30:00 <arkeet> no, most specific types first.
22:30:06 <arkeet> but only types that are more general than you give it.
22:45:18 <letrec> I've got a function :: (a -> k -> v -> a) -> a -> http://hackage.haskell.org/packages/archive/unordered-containers/0.2.1.0/doc/html/Data-HashMap-Strict.html#t:HashMap k v -> a    But what I really need would be ::   (a -> k -> v -> IO a) -> a -> http://hackage.haskell.org/packages/archive/unordered-containers/0.2.1.0/doc/html/Data-HashMap-Strict.html#t:HashMap k v -> IO a
22:45:25 <letrec> Is it hopeless :) ?
22:49:54 <liyang> letrec: you can have  (IO a -> k -> v -> IO a) -> IO a -> HashMap k v -> IO a
22:49:58 <mgsloan> letrec: Doesn't look very hopeless.  Try "yourFunc (\x k v -> x >>= (\x' -> f x k v)) (return startValue) mp"
22:50:07 <mgsloan> yeah, as liyang is saying
22:50:53 <mgsloan> erp, ... (\x' -> f x' ...
22:51:56 <uwjesd> Hello. On debian 6 what is the name of the binary of the haskell interpreter?
22:52:04 <shachaf> letrec: What is the "a"?
22:52:12 <shachaf> Oh, an accumulator.
22:52:50 <liyang> shachaf: I think he's looking at HashMap.foldlWithKey'
22:52:53 <shachaf> I think you can probably get something like that with something in lens.
22:53:16 <liyang> shachaf: that's a vacuously true statement.
22:53:17 <mgsloan> shachaf: well that's always true ;)
22:53:25 <shachaf> imapAccumLOf or something along those lines.
22:53:53 <edwardk> letrec: you can always take the HashMap apart into a list and foldr or foldl with that
22:54:06 <edwardk> letrec: laziness makes that cheaper than you'd think
22:54:06 <shachaf> Or that, actually. Since you're not really mapping.
22:54:16 <shachaf> That's probably the simplest way.
22:54:18 <mgsloan> shachaf / edwardk: have actions changed much in the recent months of lens?
22:54:22 <edwardk> letrec: then you can use foldrM or foldlM
22:54:24 <edwardk> :t foldrM
22:54:26 <lambdabot>     Not in scope: `foldrM'
22:54:27 <lambdabot>     Perhaps you meant one of these:
22:54:27 <lambdabot>       `Data.Foldable.foldrM' (imported from Data.Foldable),
22:54:27 <edwardk> mgsloan: nope
22:54:32 <edwardk> :t Data.Foldable.foldrM
22:54:34 <shachaf> You mean changed from "being not so great" to "being so great"?
22:54:34 <lambdabot> (Monad m, Foldable t) => (a -> b -> m b) -> b -> t a -> m b
22:54:44 <edwardk> :t foldrMOf
22:54:46 <lambdabot> Monad m => Getting (Dual (Endo (r -> m r))) s t a b -> (a -> r -> m r) -> r -> s -> m r
22:54:48 <edwardk> :t ifoldrMOf
22:54:49 <lambdabot> Monad m => IndexedGetting i (Dual (Endo (r -> m r))) s t a b -> (i -> a -> r -> m r) -> r -> s -> m r
22:54:56 <edwardk> :t ifoldlMOf
22:54:58 <lambdabot> Monad m => IndexedGetting i (Endo (r -> m r)) s t a b -> (i -> r -> a -> m r) -> r -> s -> m r
22:55:03 <edwardk> :t ifoldlMOf traversed
22:55:05 <lambdabot> (Monad m, Traversable f) => (Int -> r -> a -> m r) -> r -> f a -> m r
22:55:11 <mgsloan> edwardk: figured not, they're pretty straightforward
22:55:12 <edwardk> :t ifoldlMOf itraversed
22:55:13 <shachaf> edwardk: Dual (Endo (Kleisli m r))
22:55:14 <lambdabot> (Monad m, TraversableWithIndex i t) => (i -> r -> a -> m r) -> r -> t a -> m r
22:55:22 <shachaf> Er, not really
22:55:25 <edwardk> :t ifoldlM
22:55:27 <lambdabot> (Monad m, FoldableWithIndex i f) => (i -> b -> a -> m b) -> b -> f a -> m b
22:55:29 <edwardk> there we go
22:55:37 <edwardk> straight out of the box with lens
22:56:16 <edwardk> letrec: Control.Lens.Indexed provides ifoldlM and ifoldrM which give you the indexed fold of the values of a HashMap, etc. that you want
22:56:31 <edwardk> letrec: you have to swap the first and second arg to your function
22:56:38 <edwardk> (we have combinators for that too)
22:56:54 <shachaf> I,I lens = concatMap (\n -> replicateM n ['\0'..]) [0..] -- straight out of the box, you just have to find it
22:57:02 <edwardk> shanse: =)
22:57:26 <edwardk> its a pretty cluttered box. =)
22:57:41 <mgsloan> I would like to see a nice lens-ey FRP library.  I know that some FRPish stuff is going into analytics, but I mean something where somehow isomorphisms would be able to do partial updates.  It kinda seems like having incremental updates is somewhat what FRP is about (not having your entire state be a pure function of the previous state and input)
22:58:34 <edwardk> the analytics approach is kind of the anti-FRP
22:59:30 <mgsloan> ah, yeah, from a glance it looks like publish / subscribe
23:01:03 <shachaf> How do you talk about unions categorically?
23:04:42 <edwardk> yeah its entirely pub/sub/spawn-tasks-that-happen-eventually and the ability to enqueue yourself waiting for particular resources to all come fully available in a way visible to the io manager (not yet complete)
23:16:13 <ExternalReality> I've been hacking all night. Has anyone ever tried pair programming? Does anyone like to remote pair? I've never pair programmed using Haskell before. I'd like to try.
23:20:41 <ExternalReality> It seems most people rather sleep than Haskell. Shame on all of you!
23:20:51 <`nand`> I try to sleep /and/ Haskell
23:20:55 <`nand`> it doesn't always work out
23:21:14 <Hafydd> ExternalReality: what are you working on?
23:21:19 <liyang> I had a nightmare where my code wouldn't typecheck recently.
23:21:29 <`nand`> liyang: ah, the lens nightmare
23:22:18 <edwardk> liyang: i had that dream too. i called it 'Tuesday'
23:22:32 <liyang> `nand`: It wasn't lens... that'd be normal. :)
23:22:51 <`nand`> normal for lens is to type-check no matter what
23:22:57 <edwardk> yeah
23:23:04 <shachaf> What about a nightmare where your code segfaults the typechecker?
23:23:08 <edwardk> the trick is then going back through the laws and figuring out what what you wrote means
23:23:12 <shachaf> (That's pretty easy to do with Hugs, actually.)
23:23:23 <edwardk> shachaf: Wednesday. (Scala code)
23:23:51 <liyang> I've had plenty of "The impossible happened" with ghci 7.6.2 recently.
23:23:53 <`nand`> the most I've achieved is segfaulting Microsoft's C# compiler
23:23:58 <shachaf> You segfault the Scala typechecker?
23:24:07 <`nand`> with a one-line example
23:25:10 <edwardk> shachaf: i regularly get it to do the microsoft equivalent
23:25:20 <ExternalReality> Hafydd: I'm just using pipes and zeromq to emulate some of the stuff tpl-dataflow does. Having a good ol' time too.
23:26:36 <shachaf> edwardk: Isn't it supposed to be all JVM-memory-safey or something?
23:26:56 <edwardk> lol
23:27:55 <`nand`> are those compilers even written using their own platform?
23:28:24 <simpson> Sometimes.
23:28:32 <simpson> JDK is, at least.
23:32:41 <CindyLinz> Hi~~ ^^
23:33:19 <CindyLinz> How should I do to transfer Data.ByteString.ByteString and Data.ByteString.Char8.ByteString back and forth?
23:34:00 <ion> They are the same thing, aren’t they?
23:34:52 <CindyLinz> I noticed there are packCStringLen / useAsCStringLen
23:35:13 <kwos> hi all!
23:35:20 <CindyLinz> ion: yes, but the functions they provide are different
23:35:41 <CindyLinz> From Network.Socket.ByteString, I will get Data.ByteString.ByteString
23:35:58 <CindyLinz> And I want to Read numbers from it
23:36:38 <CindyLinz> The unpack for Data.ByteString.ByteString.Char8 is ByteString -> [Char], that I can use Read Word16 on it.
23:36:57 <CindyLinz> But the Data.ByteString.ByteString is ByteString -> [Word8]
23:37:58 <shachaf> CindyLinz: They are the same type.
23:38:10 <CindyLinz> The packCStringLen / useAsCStringLen are all O(n), it seems expensive :|
23:39:00 <shachaf> You sound confused.
23:39:04 <shachaf> What are you actually trying to do?
23:39:20 <CindyLinz> shachaf: Read some digit from Network Socket
23:40:09 <CindyLinz> Or should I map a Word8 -> Char to [Word8], then I can read the String?
23:55:42 <uwjesd> Hello. On debian 6 what is the name of the binary of the haskell interpreter?
23:56:31 <ion> Do you mean ghci? Or runghc/runhaskell?
23:56:56 * hackagebot binary 0.7.0.1 - Binary serialisation for Haskell values using lazy ByteStrings  http://hackage.haskell.org/package/binary-0.7.0.1 (LennartKolmodin)
