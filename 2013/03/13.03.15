00:07:44 * hackagebot resourcet 0.4.6 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.4.6 (MichaelSnoyman)
00:42:44 * hackagebot monomorphic 0.0.2.0 - Library to convert polymorphic datatypes to/from its monomorphic represetation  http://hackage.haskell.org/package/monomorphic-0.0.2.0 (HiromiIshii)
00:44:43 <adnap> > filter (\m -> isJust m && fromJust m > 0) [(Just (-1)), Nothing, (Just 3)]
00:44:45 <lambdabot>   [Just 3]
00:45:45 <adnap> Is there a way to remove "m"?
00:45:58 <otters> @pl \m -> isJust m && fromJust m > 0
00:45:58 <lambdabot> liftM2 (&&) isJust ((> 0) . fromJust)
00:46:22 <adnap> otters: Thanks. What does "pl" stand for?
00:46:27 <otters> pointless
00:46:50 <adnap> @pf \m -> isJust m && fromJust m > 0
00:46:50 <lambdabot> Maybe you meant: bf pl
00:47:57 <adnap> How can I do @pl offline?
00:48:12 <otters> cabal install pointless possibly
00:48:16 <otters> I don't remember what it's called
00:48:34 <otters> No, it's pointfree
00:48:36 <otters> cabal install pointfree
00:52:22 <adnap> I don't understand how "liftM2 (&&) isJust ((> 0) . fromJust)" works. ":t liftM2 (&&)" should be "Maybe Bool -> Maybe Bool -> Maybe Bool"
00:54:40 <supki> @ty liftA2 (&&) `asAppliedTo` ((> 0) . fromJust)
00:54:42 <lambdabot> (Num a, Ord a) => (Maybe a -> Bool) -> (Maybe a -> Bool) -> Maybe a -> Bool
00:55:39 <supki> adnap: it uses reader monad
00:55:46 <supki> :t liftM2 (&&)
00:55:47 <lambdabot> Monad m => m Bool -> m Bool -> m Bool
00:56:22 <supki> adnap: in your case  m  is  (Maybe a ->)
00:56:28 <supki> (with constraints)
00:58:33 <adnap> I'm still confused.
01:00:16 <adnap> So... "liftM2 (&&) isJust" is then "(Maybe a ->) Bool -> (Maybe a ->) Bool"
01:00:30 <adnap> Ah, now I understand
01:30:04 <supki> adnap: note that you could write it as  maybe False (> 0)
01:30:11 <supki> probably that's better
01:30:24 <adnap> Is there a function "\f g -> map f . filter g" that iterates over a list once?
01:32:17 <adnap> supki: Cool idea!
01:36:31 <Fubar^> adnap: are you sure that iterates over the list twice? I'm thinking stream fusion might have kicked in
01:36:54 <adnap> Fubar^: What is that?
01:37:24 <Fubar^> http://stackoverflow.com/questions/578063/what-is-haskells-stream-fusion
01:37:52 <adnap> I am reading that now!
01:39:46 <adnap> Fubar^: I can't tell if stream fusion would be used from reading that page.
01:40:35 <Fubar^> me neither. I usually just assume that GHC will make my stuff fast :)
01:51:30 <adnap> @pl \x y -> (*) 2 ((+) x y)
01:51:30 <lambdabot> ((2 *) .) . (+)
02:05:27 <srhb> adnap: Don't use explicit recursion.
02:05:31 <srhb> adnap: You should be fine.
02:11:13 <killy9999> how do I subtract a number from every number in a list?
02:11:27 <Hermit> > map (-1) [1..10]
02:11:29 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> b))
02:11:29 <lambdabot>    arising from the ambiguity chec...
02:11:32 <t7> map (-1) mylist
02:11:50 <t7> map (- 1) ?
02:11:51 <Hermit> > map (-1) [1..10] :: [Int]
02:11:52 <lambdabot>   No instance for (GHC.Num.Num (a0 -> GHC.Types.Int))
02:11:53 <lambdabot>    arising from a use o...
02:11:55 <Hermit> wtf
02:11:56 <killy9999> nope
02:12:00 <killy9999> that' the problem
02:12:04 <`ramses> > map (1-) [1..10]
02:12:04 <supki> @ty map . subtract
02:12:05 <t7> > map (- 1) [1..10]
02:12:05 <lambdabot>   [0,-1,-2,-3,-4,-5,-6,-7,-8,-9]
02:12:06 <lambdabot> Num b => b -> [b] -> [b]
02:12:06 <killy9999> (-1) is not a section
02:12:07 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> b))
02:12:07 <lambdabot>    arising from the ambiguity chec...
02:12:17 <Hermit> oh, the space...
02:12:29 <`ramses> no, the space doesn't help
02:12:34 <mauke> no, not the space
02:12:34 <`ramses> use (1-) instead
02:12:40 <t7> nah you want (1-)
02:12:42 <mauke> what
02:12:51 <killy9999> nope
02:12:51 <Hermit> > map (- 1) [1..10]
02:12:52 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> b))
02:12:52 <lambdabot>    arising from the ambiguity chec...
02:12:56 <killy9999> that does the oposite thing :p
02:13:02 <t7> haha
02:13:04 <`ramses> ah wait, that's totally not the same! :D
02:13:05 <Hermit> > map (1-) [1..10]
02:13:07 <lambdabot>   [0,-1,-2,-3,-4,-5,-6,-7,-8,-9]
02:13:13 <t7> :t subtract 1
02:13:13 <Hermit> geez..
02:13:15 <lambdabot> Num a => a -> a
02:13:16 <supki> > [1..10] & mapped -~ 3
02:13:17 <`ramses> *facepalm*
02:13:18 <lambdabot>   [-2,-1,0,1,2,3,4,5,6,7]
02:13:37 <killy9999> I want to subtract a number from everything in a list, not subtract every number in a list from a number
02:13:47 <t7> map (subtract 1) [1..10]
02:13:48 <ion> @hoogle [f :*: g] -> ([f], [g])
02:13:48 <lambdabot> Warning: Unknown type :*:
02:13:48 <lambdabot> No results found
02:13:52 <t7> > map (subtract 1) [1..10]
02:13:53 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
02:13:56 <killy9999> subtract does the job
02:13:57 <killy9999> thanks!
02:14:08 <killy9999> that was a bit tricky :)
02:14:35 * t7 shouldn't answer questions before 10am
02:15:00 <srhb> Haha.
02:15:28 <srhb> killy9999: If it wasn't clear, the issue is that we want to be able to write negative numbers easily, so (-1) is just negative one, not an operator section. That's why we have subtract.
02:15:44 <srhb> It's one of the few "remember-this-is-special"-pitfalls.
02:15:49 <Hermit> well, being 6am I shouldn't even be reading IRC
02:16:19 <ion> @hoogle [(f :*: g) a] -> ([f a], [g a])
02:16:20 <lambdabot> Warning: Unknown type :*:
02:16:20 <lambdabot> No results found
02:16:36 <ion> @hoogle [(GHC.Generics.:*:) f g a] -> ([f a], [g a])
02:16:36 <lambdabot> Parse error:
02:16:36 <lambdabot>   [(GHC.Generics.:*:) f g a] -> ([f a], [g a])
02:16:36 <lambdabot>        ^
02:17:01 <killy9999> srnb: I know that it's treated as a negation operator
02:17:30 <srhb> Ok. :)
02:17:49 <killy9999> that's why I asked - I didn't know how to do subtraction if I can;t create a section with -
02:17:54 <srhb> *nods*
02:18:23 <srhb> The solution if you didn't know of subtract would be to just use (\x -> x - 1)
02:20:52 <hpaste> Quchen pasted “Basic TH” at http://hpaste.org/84082
02:20:53 <supki> I like how the core of  xs & mapped -~ n  and  map (subtract n) xs  is actually the same
02:21:03 <hpaste> eflister pasted “binary dependency hell” at http://hpaste.org/84083
02:21:20 <eflister> hi - first time in dependency hell.  i need a package that needs a max version of binary higher than what other packages i am using allow.  the cabal output seems to blame pureMD5, but its cabal file only puts a lower bound on binary, so that can't be it.  why does cabal blame
02:21:41 <quchen> Why does my paste above not pre-calculate the X-th Fibonacci number? The calculation is done at runtime.
02:21:56 <eflister> the wrong package, and how do i figure out the culprit?
02:21:56 <quchen> Is it just building up a huge AST and then compiles that?
02:22:17 <arkeet> quchen: indeed
02:22:50 <quchen> arkeet: Well then I need a TH-level seq function. :-)
02:23:06 <supki> eflister: ghc-pkg list binary ?
02:23:57 <supki> eflister: seems like you have binary-0.5.1.0 installed
02:24:17 <eflister> supki: i'm using cabal-dev, does that matter?  ghc-pkg seems to say it came from haskell platform
02:25:01 <supki> that depends on where is it installed, in --global or --user
02:25:18 <eflister> supki: but i can install juicypixels, which requires binary > 0.6.4
02:25:21 <arkeet> quchen: I think you'll just have to make your Exp differently.
02:25:24 <srhb> eflister: It it's installed with cabal-dev, you want cabal-dev ghc-pkg list, right?
02:25:42 <eflister> srhb: oh i didn't know i could do that, hold on...
02:25:55 <srhb> eflister: Generally you can pop cabal-dev in front of all the global commands.
02:26:01 <srhb> To make them work in your sandboc.
02:26:04 <srhb> x*
02:26:33 <arkeet> fiboTH = return . LitE . IntegerL . length . show $ fibo (5*10^5)
02:26:34 <arkeet> or whatever
02:26:49 <eflister> ok that shows both 0.5.1 from haskell platform and 0.6.4 in my sandbox
02:27:48 <quchen> arkeet: I see. You're explicitly building one LitE, with contents precalculated.
02:27:53 <arkeet> yes
02:28:00 <eflister> so why isn't pureMD5 using the one in my sandbox?
02:28:08 <quchen> I'm building a syntax tree that's identical to what non-TH would be.
02:28:24 <arkeet> that is what [| |] does.
02:28:59 <quchen> I thought $() would evaluate something.
02:29:10 <quchen> It's more like a "write whatever the Q in my argument has inside here"
02:29:14 <srhb> eflister: Is it in your cabal file?
02:29:17 <arkeet> that's exactly what it is.
02:29:24 <srhb> Hm I guess that might not be necessary.
02:29:29 <arkeet> "splice this expression into here"
02:29:34 <quchen> Alright, that helped a lot, thanks.
02:29:49 <quchen> I know all websites say that, but it didn't make it through to me ;-)
02:29:54 <arkeet> :P
02:30:15 <supki> eflister: could you try  cabal install yesod JuicyPixels widefield.cabal  and paste the output
02:30:18 <supki> ?
02:30:28 <eflister> srhb: no, neither binary nor pureMD5 are -- it's a yesod scaffolded cabal file, so the dependencies go on forever
02:31:22 <arkeet> quchen: -ddump-splices is handy.
02:31:25 <supki> cabal-dev *
02:31:27 <eflister> supki: not cabal-dev?  yesod has a million dependencies and its easy to get really lost in them...
02:31:32 <quchen> arkeet: Ahaaa! Fibo takes forever to compile now thanks to you.
02:31:35 <supki> eflister: yes, sorry
02:31:38 <arkeet> hehe
02:31:51 <quchen> arkeet: -ddump-splices? I used runQ X >>= putStrLn . pprint
02:32:15 <arkeet> quchen: shows exactly what's spliced when you compile.
02:32:38 <quchen> arkeet: Like auto-all for TH then
02:33:06 <quchen> Neat!
02:33:33 <turiya> hi
02:33:41 <quchen> Hello!
02:34:04 <turiya> there don't seem to be any set operations in Vector..
02:34:50 <quchen> turiya: That's because vectors aren't very suitable for storing sets.
02:34:59 <quchen> What kind of set operations do you mean? Unions etc?
02:35:13 <turiya> quchen: yes, unions and intersections
02:36:19 <quchen> turiya: The problem with those is that they typically change a vector's length. In Haskell, that means you have to copy the entire thing, because it's in one memory block.
02:36:47 <quchen> Vectors are a particularly bad type for insertion and changing length.
02:36:55 <quchen> Have you looked at Data.Set?
02:37:02 <quchen> Or Data.Map
02:37:08 <turiya> i had used lists (after much help from people in this channel) but they consume too much memory
02:37:36 <srhb> If what you have is abstractly a Set, you should probably use Set. :)
02:37:44 <quchen> turiya: Well, that's a design problem: you have to choose your container to be suitable for your problem.
02:38:28 <quchen> vectors are good for fixed-size algorithms that need lots of reading. For example, they can be used for memoization very well.
02:38:47 <quchen> Sets/Maps have reasonably fast access to elements, both in insertion and deletion.
02:39:12 <turiya> i see, i will look up data.set and data.map
02:39:13 <quchen> Lists have very cheap insertion, but traversal is costly.
02:39:55 <quchen> arkeet: Another thing I don't understand about TH: I have to define the "Q Exp" stuff in another module than where I would like to $() it.
02:40:19 <quchen> However, I can use $() in the "Q Exp" module to build recursive TH things.
02:40:19 <srhb> quchen: That's a rather arbitrary limit that you must just accept.
02:40:48 <quchen> Oh.
02:41:58 <srhb> Presumably, you can do the other thing (I've never managed that) because the caller is really in the other module.
02:42:19 <quchen> Hm.
02:42:27 <eflister> supki: that worked!  thanks so much!  so issuing them together makes them use the same packages?
02:42:48 <quchen> So it's not that the $() has to evaluate in a different module. It's just that at the top level, you have to have module separation; reason: trololol?
02:43:22 <srhb> quchen: Reason: Type checking
02:43:40 <supki> eflister: well, you give cabal-install more information, so it could figure out dependencies better
02:43:40 <srhb> I'm fairly sure it could actually be resolved even in the same module, but it would make the whole process much more complicated.
02:45:06 <quchen> srhb: Alright then, thanks. I was just wondering whether the inconsistency was in my head maybe.
02:45:17 <quchen> Like when I misunderstood $().
02:45:42 <supki> eflister: cabal-dev install  basically tries to install widefield into existing set of packages without reinstalls, cabal-dev install ... allows for reinstalls
02:45:45 <srhb> I'm not sure, like I said I haven't actually made it work. Presumably we could explore it more.
02:45:57 <srhb> quchen: Can you show your example of the recursive call?
02:46:14 <beaky> hello
02:46:52 <eflister> supki: i have been trying manual reinstalls all day and they kept breaking everything -- aren't they dangerous?
02:47:47 <quchen> srhb: Let me try to make one up again
02:47:53 <eflister> supki: btw, yesod and JuicyPixels are both in my widefield.cabal -- why isn't that enough to say "these should work together"?
02:49:00 <beaky> how do I use haskell for a programming competition?
02:49:17 <srhb> beaky: Er.. JUst use it?
02:49:21 <srhb> beaky: That's a strange question.
02:49:28 <supki> eflister: yeah, manual reinstalls are dangerous (unless you now what you are doing)
02:49:44 <beaky> how do I do like digjkstra's algorithm in ahskell
02:49:46 <supki> eflister: to me it seems that JuicyPixels dependency was added later?
02:50:02 <srhb> beaky: You can transliterate the one at Wikipedia to Haskell pretty directly. :)
02:50:14 <eflister> supki: yeah i had a thing working without it and then tried to add it
02:50:44 <beaky> also how do I do knuth shuffle in haskell
02:51:02 <eflister> supki: but i'm sure i tried in a fresh sandbox once it was added...  i'll try now...
02:51:38 <quchen> srhb: Can't come up with something now. I'll redraw my question until further notice. :-)
02:51:41 <srhb> beaky: try to Google knuth shuffle Haskell, if you just want the solution rather than implementing it yourself
02:51:55 <srhb> quchen: Aw, ok. @tell me if you come up with something.
02:52:14 <beaky> I'll try to figure out it in haskell :D
02:52:23 <srhb> beaky: Bet you you'll learn more from that.
02:52:24 <supki> eflister: well, then cabal-install tries its best to add JuicyPixels into existing sandbox and fails, you didn't say to try to reinstall yesod and so it doesn't try
02:53:05 <beaky> a purely-functional shuffle...
02:54:06 <beaky> shuffle :: IOUArray -> IOUArray
02:55:43 <beaky> ah I need to learn how to use the State monad
02:55:45 <eflister> supki: well i tried manually.  :)  it should work in a fresh sandbox, right?  i remember now that when i try that, it immediately fails complaining that directory, unix-compat, and ghc all conflict.  my solution was to first install haskell-platform, which works.
02:56:02 <srhb> beaky: That's also a good idea.
02:56:47 <hpaste> Quchen pasted “Nested TH” at http://hpaste.org/84084
02:56:53 <quchen> srhb: ^
02:57:11 <quchen> It won't pre-calculate anything and just build a large syntax tree, but that's not the point.
02:57:17 <eflister> supki: whoops, i mean yesod-platform.  i guess then when i add JuicyPixels, stuff is already pointed to the older haskell-platform version of binary.
02:57:28 <srhb> quchen: Presumably that works because the argument is known at compile-time
02:57:59 <quchen> I'll just put it in my "quirky Haskell" folder ;-)
02:58:00 <supki> eflister: if you install them one by one then yes
02:58:12 <srhb> And I think my interpretation is correct - it works because the splicing really does occur from the other module.
02:58:27 <srhb> BUt we need an expert to tell us for sure :P
02:59:09 <quchen> srhb: edwardk's going to storm in here soon and tell us the truth
02:59:14 <quchen> You sure you want that? ;-)
02:59:17 <srhb> lens
02:59:21 <srhb> Let's see if it works...
02:59:25 <edwardk> ?
02:59:27 <srhb> Haha
02:59:30 <supki> eflister: btw, directory and ghc conflicting with something is actually a bad sign
02:59:56 <srhb> Actually we're just wondering why recursive TH splicing is ever allowed due to the stage restriction
03:00:01 <srhb> despite the stage restriction*
03:00:12 <eflister> supki: i don't get how installing yesod-platform works, allowing the rest of my stuff to work, if just installing from my cabal file doesn't work.
03:00:18 <quchen> Yes, precisely, I guess. (Staging restriction?)
03:01:03 <edwardk> well, honestly, i was just happy when it started working to reference stuff above the splice in a splice in the same source file
03:01:07 * supki lookups yesod-platform
03:01:31 <srhb> Yes, okay :P
03:01:41 <srhb> Who's the resident TH oracle anyway?
03:02:07 <quchen> Please not Simon Marlow (or I'll have to join Facebook too to talk to him)
03:02:48 <supki> eflister: ugh, no idea. what's the error when you try to install it in fresh sandbox?
03:02:53 <eikke> dons mentioned the 'local GC' paper in an SO thread lined to from this weeks HWN
03:02:58 <eikke> has that been integrated in GHC?
03:03:32 <srhb> eikke: Which SO-question is that?
03:04:00 <eikke> Haskell/GHC in a soft-realtime app
03:04:38 <srhb> Well, according to dons answer, yes?
03:04:50 <srhb> "GHC now uses a multicore garbage collector with per-thread local heaps. Originally developed to improve multcore performance (each core can collect independently) by reducing the cost of frequent stop-the-world synchronisation, this happens to also benefit soft-real time for the same reason."
03:05:49 <eikke> well, IIRC that paper mentioned they didnt intend to integrate the work due to too much slowdowns vs the speedups
03:06:13 <hpaste> “Anonymous Coward” annotated “binary dependency hell” with “binary dependency hell (annotation)” at http://hpaste.org/84083#a84085
03:06:21 <srhb> No idea then. I wouldn't dare contradicting dons. :-)
03:06:57 <eflister> supki: ^
03:07:47 * hackagebot classy-prelude 0.5.4 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.5.4 (MichaelSnoyman)
03:07:52 <srhb> eflister: Ugh...
03:08:15 <srhb> eflister: I think the answer here is just get GHC 7.6 and your worries will be gone.
03:08:30 <srhb> It appears Yesod has been bumping the dependencies up there anyway.
03:09:05 <srhb> Also that old-time dependency looks weird.
03:09:21 <eflister> srhb: ok...  what indicates that?
03:09:49 <srhb> Which part?
03:10:12 <eflister> srhb: that 7.6 is the answer
03:11:10 <srhb> My gut feeling? <_<
03:11:11 <eflister> srhb: for yesod stuff, i try to stick to haskell platform cuz that's what yesod recommends...
03:11:50 <srhb> It ought to work, I agree.
03:12:00 <srhb> Something quirky must be going on in your cabal file, really.
03:12:23 <supki> I don't understand that line;  unix-compat-0.4.1.0:old-time => directory>=1.2 && <1.3
03:12:30 <supki> perhaps you should paste .cabal file
03:12:36 <srhb> Yeah.
03:13:38 <hpaste> eflister annotated “binary dependency hell” with “binary dependency hell (annotation) (annotation)” at http://hpaste.org/84083#a84088
03:14:53 <eflister> it's generated by yesod init -- i just added JuicyPixels and filepath, and the Thumb module
03:16:32 <eflister> could be caused by a cabal file from one of the many dependencies, right?
03:16:53 <supki> eflister: wait, and how did you get  yesod init?
03:17:33 <srhb> yesod-platform presumably?
03:18:22 <eflister> supki: erm... yeah, possibly i copied the cabal file from another attempt where i had installed yesod-platform...
03:18:49 <eflister> btw, anyone ever have any luck installing gd or imagemagick on windows/mingw?
03:19:00 <srhb> eflister: Someone has, but it's not really easy.
03:19:34 <srhb> I have no idea how your problem has arisen. Dependency hell sucks.
03:19:40 <eflister> srhb: any more info?  i'm not desperate for them...
03:20:04 <eflister> srhb: yeah i'm cool with supki's solution, i just wish i understood...
03:20:12 <srhb> Me, too.
03:20:19 <quchen> Why is runQ mapping to IO? Seems arbitrary to me. Q is sort of a state monad after all, why is its result inherently impure?
03:20:56 <supki> eflister: could you try  cabal-dev install -v3  ?
03:21:13 <eflister> supki: in a fresh sandbox, eh?
03:21:19 <srhb> Yes.
03:22:18 <beaky> @pl \a b c -> c a b
03:22:18 <lambdabot> flip . flip id
03:23:46 <eflister> supki: too much output to post...
03:24:11 * robstewartuk is trying to figure out how to make backspace mean "backspace one character" in emacs haskell-mode, and failing.
03:24:11 <Xaratas> half serius question: is such a thing overkill or normal for haskellprograms? checkNumbers' (a,b) list = map (\(y,z) -> (a++y,zipWith (+) b z)) (filter(\(_,x) -> null $ intersect a x) list)
03:24:16 <robstewartuk> any hints?
03:25:27 <beaky> haskell
03:25:28 <srhb> eflister: To post on hpaste? There's a limit?
03:25:46 <srhb> robstewartuk: It works like that for me out of the box.
03:26:27 <robstewartuk> hm, if I hit backspace, the cursor goes to the end of the line above.
03:27:12 <srhb> robstewartuk: What does C-h k <backspace> give you?
03:27:48 * hackagebot snaplet-mongodb-minimalistic 0.0.6.8 - Minimalistic MongoDB Snaplet.  http://hackage.haskell.org/package/snaplet-mongodb-minimalistic-0.0.6.8 (PetrPilar)
03:28:25 <robstewartuk> "<backspace> runs the command haskell-indentation-delete-backward-char,
03:28:26 <robstewartuk> which is an interactive compiled Lisp function."
03:28:33 <robstewartuk> It is bound to <backspace>.
03:28:37 <robstewartuk> (haskell-indentation-delete-backward-char N)
03:28:54 <srhb> Mine says that too, and it deletes one char backwards
03:28:59 <mbp> hello. how close can haskell come to this C++ code?  I came up with this code, but it is far more verbose than I would have liked. http://hpaste.org/84089
03:29:04 <srhb> It only goes back to the previous line if I'm on column 0
03:29:25 <robstewartuk> hm, I'm on column 19
03:29:40 <srhb> robstewartuk: Something sounds broken! Are you using the newest version of haskell-mode?
03:29:56 * robstewartuk is cloning from github as we speak....
03:31:07 <srhb> I just updated and it still works for me. Presumably you have something else messing it up if it persists on the newest version.
03:31:32 <hpaste> eflister annotated “binary dependency hell” with “binary dependency hell (annotation) (annotation) (annotation)” at http://hpaste.org/84083#a84090
03:31:49 <srhb> eflister: That is rather amazing :P
03:33:21 <supki> apparently that's not fresh sandbox?
03:33:32 <supki> eflister: do you have HP installed in --global?
03:33:54 <srhb> Looks like some versions are fixed globally as well
03:33:58 <eflister> supki: i thought it was a fresh sandbox, what makes it look not?
03:34:03 <srhb> Perhaps you should fry .cabal and .ghc
03:34:28 <eflister> ok, those live in appdata/roaming or something?
03:34:41 <srhb> Uhhhh.
03:34:45 <srhb> I have no clue. :-)
03:34:51 <srhb> ~/.ghc and ~/.cabal here
03:35:20 <eflister> how do i see what i have in global?  i didn't think i had installed anything since installing haskell platform last, but i have like 4 old haskell platforms with stuff in them...  does --global keep those separate?
03:35:46 <joker_89> if i have a type Me= (Int,Float) and i have a function that recive a list of ME, a Int and then filter the Me with that Int and finally return the Me wich have the maximum float value of the Me filtered and the position in the list: [ME]->Int->(ME,Int)
03:37:16 <supki> hm
03:37:20 <supki> http://hackage.haskell.org/packages/archive/unix-compat/0.4.1.0/unix-compat.cabal
03:37:23 <supki> I guess problem is here
03:38:07 <supki> os(windows) is true, flag(old-time) is false, so wrong directory dependency is chosen here
03:39:34 <eflister> supki: how'd you track it down?  and what indicates that's the wrong directory version?
03:39:53 <beaky> is garbage collection good?
03:40:00 <Rembane> beaky: Yes :D
03:40:38 <beaky> but I heard if you have big problem sizes then you get 'pauses'
03:40:45 <beaky> or is that a solved problem?
03:41:17 <supki> eflister: on line 178 it tries unix-compat, then lists flags
03:42:07 <supki> eflister: then you can check what that flag means for unix-compat
03:42:34 <supki> eflister: then you see it adds  build-depends: directory >= 1.2 && < 1.3
03:42:44 <supki> which is wrong for ghc-7.4
03:43:38 <srhb> beaky: You basically can't avoid pauses with a GC, but you're probably already used to those, and for well-designed code they're not a big problem
03:43:43 <srhb> Unless you're doing hard-realtime or something.
03:44:07 <supki> eflister: and the actual error will tell that there are conflicting directory versions
03:45:14 <supki> I don't really understand how yesod-platform helps here
03:45:52 <Kinnison> no matter, found it
03:46:01 <Kinnison> oops w/w
03:46:29 <beaky> ah
03:47:45 <eflister> supki/srhb: does that mean i should leave ghc/cabal directories? is it generally safe to toss those?  should i file a bug report for unix-compat?
03:48:52 <srhb> eflister: You should probably leave them and it's probably safe to toss them as long as you have a global version of cabal somewhere
03:49:07 <srhb> eflister: I do it a lot when I run into problems because often it's conflicts between sandbox and global for me.
03:49:16 <srhb> eflister: Just means I have to reinstall whatever global things I need.
03:50:16 <eflister> srhb: seems cabal.exe lives under program files, not these dirs, is that what you mean?
03:50:21 <srhb> Indeed.
03:50:38 <srhb> Means you can toss your user-installed things safely.
03:50:53 <srhb> And then basically all you need to reinstall is cabal-dev if you sandbox everything.
03:51:03 <srhb> ie. cabal install cabal-dev
03:51:23 <eflister> srhb: what about stuff from the platform?
03:51:23 <srhb> BUt yeah, as supki said, that's not your problem in this case.
03:51:30 <mbp> I am trying to emulate subtyping/inheritance in haskell, but the code I ended up with is extremely verbose, it has 3x as many lines as C++. am I missing some extension or feature that could make this nicer? http://hpaste.org/84089
03:51:31 <srhb> eflister: It's not user-specific.
03:51:40 <srhb> Or I assume it isn't, it's not on UNIX platforms.
03:52:43 <mbp> .
03:52:46 <mbp> I am trying to emulate subtyping/inheritance in haskell, but the code I ended up with is extremely verbose, it has 3x as many lines as C++. am I missing some extension or feature that could make this nicer? http://hpaste.org/84089
03:52:52 <srhb> mbp: Whoa.
03:53:10 <srhb> No need to repeat your question that often. :P
03:53:41 <mbp> yeah, sorry, thought it didn't come through for some reason
03:54:05 <eflister> cool, thanks a lot srhb and supki!  i filed it here: https://github.com/jystic/unix-compat/issues/8
03:54:09 <srhb> mbp: I remember something about this OOP pattern with existential quantification being a code smell.
03:54:31 <hiptobecubic> eflister, this is a pretty widely recognized antipattern
03:54:35 <srhb> There's a blog post out there that I think refers to what you're doing.
03:54:46 <hiptobecubic> by widely recognized i mean, some guy said it once i think
03:54:54 <srhb> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
03:54:55 <hiptobecubic> But it was a well defended argument
03:55:04 <srhb> I think that's the one.
03:55:08 <eflister> what are we referring to?  i think you mean mbp?
03:55:09 <hiptobecubic> that is probably it, although i think there's a second somewhere
03:55:14 <srhb> Yes, he meant mbp.
03:55:17 <hiptobecubic> eflister, AnyA....
03:56:27 <mbp> AnyA isn't even that relevant part of my code. subtyping is.
03:56:37 <mbp> B having the same fields as A, and C as B
03:57:33 <hiptobecubic> eflister, sorry :) :D
03:58:44 <typoclass> mbp: hello, haskell's typeclasses are unlike classes known from object-oriented languages. typeclasses are basically groups of functions (no implementation, just the signatures) and mainly are used for overloading
03:59:47 <supki> eflister: could you try  cabal-dev install widefield.cabal binary ?
03:59:51 <supki> in fresh sandbox that is
04:02:21 <mbp> typoclass so no way to make this nicer? maybe I could by switching to algebraic types? or should I just give up on subtyping
04:02:37 <srhb> mbp: Did you read the blog post I linked?
04:03:25 <mbp> srhb I have read it before posting the code. I still want to do this, despite being thought as antipattern by some
04:03:37 <eflister> supki: same result as cabal-dev install
04:04:05 <srhb> mbp: OK, I guess you're screwed then. :-)
04:04:06 <typoclass> mbp: the short answer on "subtyping" is "you'd probably design it differently in haskell" ... could you tell us more what you're trying to do? what are A, B, C in real life?
04:05:29 <supki> =(
04:05:58 <typoclass> mbp: (as far as i know, the compiler people's opinion on subtyping is that the advantages it offers are small, and the complexity in brings into the type system are large)
04:06:13 <typoclass> s/complexity/complexities
04:07:41 <typoclass> ... typing accuracy fail. time for a nap ...
04:07:50 <mbp> typoclass I am writing little throw away projects while learning haskell in the process. don't have any problem in particular that I am solving
04:09:07 <mbp> seems without the subtyping though, you lose the ability to writing generic code (operating on different types with similar behavior) to the same extent as in languages that support it. but perhaps I am wrong
04:11:09 <mbp> that is unless you want to do everything manually, as I did in the pasted code
04:11:39 <srhb> I think the problem with writing "aimless code" is that you can never determine what the right feature in Haskell is the solution to it
04:11:43 <srhb> Because you don't have a problem to solve.
04:12:07 <srhb> As you've probably noticed, the solution to a lot of problems are different in Haskell, but without actually having a problem to solve, you're not going to find it.
04:15:07 <eflister> mbp: definitely you write far more generic code in haskell than in any oop.  study the typeclassopedia.
04:16:41 <typoclass> mbp: well, just the regular polymorphism is already pretty powerful. e.g., "map :: (a -> b) -> [a] -> [b]" basically means "this function can process lists of 'a' (= absolutely everything) for the programmer, as long as the programmer can supply a function that processes one 'a'"
04:17:13 * RenJuan doesn't see it. Especially relative to stuff like lisp MOP
04:17:57 <typoclass> mbp: arguably, that's very generic. it's just centered on the map function, where in object-oriented languages you would focus on objects instead of functions
04:18:12 <typoclass> ... hm, i think i didn't explain that very clearly
04:18:20 <srhb> I understood it!
04:18:41 * typoclass purrs and meows a little, then walks a figure-8 around srhb's legs
04:19:04 <mcstar> i joined at the wrong time...
04:19:12 <srhb> mcstar: >_>
04:20:29 <typoclass> RenJuan: hm not sure. what can the meta-object thingy do? things like override object creation ...?
04:21:05 <RenJuan> no, it allows you to create your own OOP
04:22:02 <Chousuke> Haskell code is at its best when it's so generic there's no need for you to even write the function
04:22:26 <Chousuke> :P
04:22:56 <RenJuan> Oz the great and powerful
04:23:03 <RenJuan> Haskell, the helium filled
04:24:58 <typoclass> RenJuan: hm, it sounds intriguing, but i also have my doubts. wouldn't it get terribly difficult to reason about code ...
04:25:10 <Chousuke> typoclass: the amusing thing is that map isn't even very generic. I mean, it's specialized for lists!
04:25:22 <srhb> Well, fmap then.
04:25:55 <srhb> Anything with an unconstrained type variable in the type is arguably extremely generic.
04:26:29 <RenJuan> typoclass, yes, but in practice people only use CLOS rather than the full generality and quite a few CL people just ignore OOP entirely
04:29:29 <typoclass> Chousuke: in haskell, map's signature is the most basic thing, but in java, you'd either have to use a relatively advanced feature like generics, or you'd have to write the equivalent of "mapObj :: (Object -> Object) -> [Object] -> [Object]", "mapInt :: (Object -> Int) -> [Object] -> [Int]", etc. and that creates its own mountain of problems
04:29:33 <henk> I’m trying to learn haskell properly and I’m looking for some intro using exercises and giving solutions to these exercises too. Can anyone recommend something?
04:30:56 <RenJuan> hank you know about LYAH?
04:31:29 <srhb> There's also the new school of haskell things.
04:31:39 <srhb> https://www.fpcomplete.com/school
04:32:13 <srhb> henk: Make LYAH your reading material and go to fpcomplete for the small exercises
04:32:13 <typoclass> henk: how about the "99 haskell problems"
04:32:54 <henk> RenJuan: "henk" ;) Yes, I know about that, and read into it, but without doing anything of the stuff explained there, I won’t get it into my head :-/
04:33:09 <henk> srhb: Sounds good, will take a look at it, thank you :)
04:33:33 <henk> typoclass: Sounds good too, thank you!
04:33:55 <Chousuke> typoclass: yeah. Haskell has lots of abstractions that are pretty much pointless in Java because you can't express them without kludgy workarounds :/
04:34:39 <mcstar> python has MOP too
04:35:19 <typoclass> henk: also, if you have exercises and are looking for solutions, i bet this channel can come up with stuff :-)
04:35:45 <henk> typoclass: hehe, good point :)
04:35:49 <mcstar> or if you have solutions, we can formulate questions for you...
04:35:55 <henk> lol
04:35:56 <Chousuke> heh
04:37:47 <mcstar> MOP analogue for haskell would be like a system to monkey-patch the typechecker, i guess
04:40:20 <Chousuke> so is that like dependent typing, except the types are not actually checked?
04:42:10 <mcstar> im thinking more like a user extensible typechecker
04:42:31 <Chousuke> well, that's pretty much what dependent typing looks like to me.
04:42:36 <mcstar> (but frankly, we can be glad that someone made a working one at all, and not mess with it)
04:43:10 <Chousuke> since you can program with types just like they are values, you can programmatically generate types
04:43:23 <mcstar> Chousuke: i dont know dependent type systems, just heard of them, cant comment
04:43:34 <Chousuke> and do crazy things that I can't really understand.
04:44:03 <henk> hm, how do I define functions in ghci?
04:44:10 <mcstar> let f x = ...
04:44:33 <mcstar> you cant have top level bindings in an interactive session
04:45:03 <henk> hm, let … Where/how do I get information about "let"?
04:45:28 <mcstar> lyah?
04:45:56 <mcstar> idk... it introduces lazy recursive bindings and/or pattern matching
04:46:15 <henk> mcstar: heh ok, thank you :)
04:46:39 <amyers> http://learnyouahaskell.com/starting-out#ready-set-go
04:46:51 <amyers> henk: That chapter is a good place to start
04:47:19 <amyers> it's from lyah, it describes the basics of ghci and loading files into ghci etc.
04:49:32 <henk> amyers: IIRC somewhere on this page I stopped reading because it was too much for my brain ;)
04:49:44 <amyers> haha
04:50:28 <skp_> hi
04:50:31 <henk> amyers: Thank you, I’ll see how far I can get with that :)
04:50:34 <mcstar> someone told me, he read LYAH in 2 dayas
04:50:36 <mcstar> days*
04:51:06 <amyers> henk: This is a bit more concise then :p
04:51:09 <amyers> henk: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-440003.12
04:51:17 <amyers> henk: but maybe not easier to understand
04:51:32 <mcstar> (i have to day, that i didnt believe him)
04:51:36 <mcstar> say*
04:51:37 <arbn> mcstar: Reading is one thing. But, when I revisited the Applicative chapter in LYAH after a year of using Haskell, I realized I didn't really understand it when I was a beginner. :P
04:51:39 <henk> mcstar: I guess it’s possible if you are a programmer or even already learned a simicar language … I’m just a stupid sysadmin and programming noob though …
04:52:10 <henk> oh ok, maybe it isn’t then :) It certainly isn’t for me …
04:52:10 <amyers> arbn: That was my experience as well
04:52:13 <mcstar> arbn: maybe he thought he got it but in fact he didnt...
04:52:30 <mcstar> still, it is not that short book
04:52:33 <amyers> I'm pretty sure I still don't understand that chapter fully
04:52:59 <srhb> I finally got it recently
04:53:10 <mcstar> henk: you shouldnt belittle yourself though
04:53:11 <srhb> I think I literally headdesked because of how simple it ended up being.
04:53:21 <srhb> I really don't understand why I didn't get it. Ah well. Such is perspective.
04:53:27 <amyers> yeah
04:53:53 <srhb> henk: Also, if no one said so yet, please feel free to hang out here and ask questions.
04:54:04 <srhb> henk: In my experience it's a very friendly channel.
04:54:22 <mcstar> srhb: could you pass that suggestion on to ppl not in here?
04:54:31 * typoclass purrs at henk
04:54:31 <mcstar> id be more effective :)
04:54:33 <henk> mcstar: I’m working on it …
04:54:36 <srhb> mcstar: Definitely, let me activate my superpsychic poewrs.
04:54:56 <mcstar> it'd*
04:55:14 <arbn> For instance, I had no recollection of the Functor, Applicative, or Monad instances of ((->) r) in LYAH. So, as a newbie, I must have just zoned those bits out.
04:55:14 <henk> srhb: I’m already hanging out here since a few weeks :) And I can only agree, so far people have been really friendly and helpful!
04:55:26 <srhb> arbn: I did, too.
04:55:32 <srhb> henk: Ah, I never realized, sorry. :P
04:56:14 <mcstar> i didnt skip over (->) i found it fascinating...
04:56:33 <mcstar> but i have to add, i finished the book in exactly 1 year
04:56:42 * typoclass sits down on henk's keyboard and yawns
04:56:48 <arbn> mcstar: I'm not sure if I skipped over it, or just forgot because I didn't see the usefulness right away.
04:57:26 <mcstar> i read half of it when i wanted to learn haskell, 2011 christmas, and then i put it down, i sort of learned haskell then, and i felt bad about not finishing the book, so 2012 christmas i just finished it
04:57:31 <henk> srhb: I didn’t talk too much yet … 1. I’m a noob, so I try not to bother people in here with noob questions but read up on things and solve my problems using google mostly. 2. I haven’t had much time to learn haskell so I didn’t have much to ask yet :(
04:57:52 <henk> typoclass: Polly want a cracker?
04:57:57 <henk> No, wait, wrong animal …
04:57:58 <srhb> henk: OK. Researching first is always good, of course, but really don't hesitate if something is bugging you.
04:58:08 <srhb> kitty want a cheezburgr?
04:58:41 <typoclass> henk: some milk please. and well, a bird (polly or someone else) wouldn't be a bad idea
04:58:42 <henk> ah, right, that was the one :)
04:58:49 <typoclass> srhb: meow! :-)
04:58:51 <henk> srhb: ok, I will, thank you.
04:59:42 <mcstar> typoclass: can i ask you to bring your toxoplasma gondii elsewhere?
05:00:16 <amyers> ugh, writing Lisp always makes me sad.  "setf is an unknown type specifier" ....
05:00:29 <tlaine> ((((())))))))(((((((((((()())))))
05:00:38 <srhb> mcstar: As long as you're not pregnant, you'll be fine.
05:00:51 * typoclass has a nap on mcstar's laptop, leaving some beautiful hair and mind control viruses
05:00:53 <mcstar> i am pregnant with ideas!
05:01:20 <tlaine> There's an idea growing in you and it will take 9 months to come out?
05:01:40 <mcstar> i hope ideas have shorter gestation periods...
05:02:26 <arbn> tlaine: This is why no soul dare brave the writing of Lisp without the trusty Emacs at hand.
05:02:36 <tlaine> :)
05:02:45 <tlaine> I just said everything I know about lisp.
05:03:01 <amyers> haha
05:03:24 <mcstar> tlaine: well, thats not lisp, you just demonstrated you skills with parentheses
05:03:30 <mcstar> also, i think they dont match up
05:03:32 <tlaine> Oh gee.
05:03:33 <RenJuan> henk, sorry so like barendregt not williams :)
05:03:40 <tlaine> yeah it was mid-code, not a full program
05:03:44 <srhb> The idea of Emacs written and extensible is still extremely exciting, I think, but I've no idea how to write it.
05:03:51 <srhb> I guess that's where Lisp makes things easy.
05:04:02 <srhb> extensible in Haskell*
05:04:09 <srhb> I accidentally a word.
05:04:26 <mcstar> yes, the one that gives the meaning to your sentence...
05:04:31 <srhb> Indeed.
05:04:32 <Chousuke> extending things in haskell sounds a bit cumbersome due to the need of a compiler.
05:04:38 <srhb> Indeed.
05:04:45 <srhb> There are things to help, but... Not quite there yet, I think.
05:04:46 <typoclass> Chousuke: bah, who hasn't ghc ...
05:04:46 <typoclass> ;-)
05:04:56 <arbn> I'd be happy once I can extend Emacs in _Scheme_. Never mind Haskell.
05:05:06 <srhb> typoclass: You only need ghc-src-extensions, though, right?
05:05:11 <srhb> BAsically embedding GHC, I think.
05:05:34 <mcstar> i dont think i'd be that easay
05:05:38 <typoclass> srhb: i was thinking of an xmonadish kind of thing, but yeah
05:05:42 <srhb> mcstar: I can buy you a drink first.
05:05:53 <mcstar> o.O
05:05:53 <srhb> typoclass: Yeah..
05:06:01 <mcstar> ok..., im in
05:06:19 <Chousuke> I guess you could bundle a haskell interpreter or something
05:06:40 <mcstar> anyway, i meant, that either you communicate with lisp in an untyped way, for example through strings... or you have to write a lot of types and data structures to represent the internals of emacs...
05:06:51 <arbn> I mean, I don't understand the motivation of rewriting something in Haskell for no reason other than a language preference.
05:06:52 <srhb> mcstar: I don't think that's  bad idea though
05:06:59 <srhb> That's exactly what Haskell brings to the table that would be nice.
05:07:01 <henk> RenJuan: hehe, yeah, actually pretty much like barendregt, henk is also short for Hendrik in my case :)
05:07:02 <mcstar> srhb: wehich one?
05:07:04 <mcstar> which*
05:07:15 <srhb> mcstar: Typed Emacs in Haskell
05:07:22 <henk> RenJuan: To be honest: I had never heard of him before ;)
05:07:34 <mcstar> srhb: but isnt that what yi is supposed to be, and got abandoned?
05:07:44 <srhb> I actually don't know.
05:08:05 <srhb> I guess it is.
05:08:22 <mcstar> they wrote it from scratch, but they wanted extensibility like emacs powered by haskell, thats what i know
05:08:40 <mcstar> so they had free hand in design, and couldnt pull it off
05:08:58 <srhb> I doubt it's impossible. It may be hard. :)
05:09:11 <mcstar> (also, they just might have needed money to buy food, idk)
05:09:12 <amyers> yi actually works fairly well, though you do have to restart when you make changes
05:09:41 <amyers> It just doesn't have all the fancy addons that make emacs and vim as powerful as they are
05:09:48 <srhb> I guess I will notice all these changes when I get my hIM working
05:09:52 <srhb> (I really hate that name)
05:09:58 <srhb> Haim..
05:10:20 <mcstar> haskell needs his own shuttleworth
05:10:20 <typoclass> srhb: what is that?
05:10:29 <srhb> An IM in Haskell, extensible through Haskell.
05:10:33 <srhb> IM client*
05:10:39 <srhb> Because Pidgin makes me furious.
05:10:49 <mcstar> i dont use instant messangers at all
05:10:54 <typoclass> srhb: ooh interesting. i've long thought about similar stuff
05:11:06 <arbn> mcstar: Good idea. It's now officially your job to go become a billionaire and then give us the money, OK?
05:11:07 <Ke> haskell needs stable abi and diligent use of deprecated and backwards compatibility
05:11:07 <typoclass> srhb: can we start a pidgin-hate club?
05:11:19 <srhb> Ke: Ugh, no
05:11:23 <srhb> Ke: For the love of all that is holy.
05:11:24 <Ke> also a compatible C-like language
05:11:34 <mcstar> arbn: i promise, if i become one, ill shove money at haskell
05:11:59 <srhb> Ke: That would just make Haskell the new Java. It's a horrible idea. The type system allows us to break things easily, to get new and shinies in. We should use that to make sure the language never stagnates
05:12:16 <srhb> Break things (and subsequently fix them) easily
05:12:21 <johnw> hehe
05:12:25 <Ke> srhb: stagnates as in can work also the next day
05:12:33 <Ke> and I really mean next day
05:12:45 <johnw> Ke: don't upgrade as often!
05:12:51 <srhb> You're clearly overreacting. :P
05:12:53 <Ke> even a month of compat time would be awesome
05:13:19 <Ke> also standard compliant compiler
05:13:26 <srhb> JUst constrain your versions if you don't want to move forward.
05:13:28 <Chousuke> but the standard is boring
05:13:30 <arbn> srhb: What about the Enterprise and their business suits and business profits? Not everyone is just playing around, you know! :P
05:13:32 <srhb> And --use-report or whatever
05:13:54 <srhb> arbn: as long as we don't have that problem, let's not have that problem.
05:14:00 <Chousuke> why would you constrain yourself to the standard when everyone uses GHC and the extensions make life easier :P
05:14:09 <amyers> Ke: how do you mean a standard compliant compiler?  Even C compilers implement many extensions
05:14:14 <Ke> I guess you can see, why haskell can't ever be used in anything serious
05:14:27 <srhb> Except it does and it is.
05:14:28 <srhb> *shrugs*
05:14:30 <Ke> amyers: but ghc is not even trying
05:14:42 <johnw> Ke: you can stop trolling now
05:14:49 <Ke> even the latest standard 2010 is now extension package
05:14:52 <trolling> nobody can stop me
05:14:54 <Ke> how is that trolling
05:14:55 <trolling> I am eternal
05:14:59 <mcstar> lol
05:15:10 <mcstar> creep
05:15:13 <srhb> You're basically spewing the exact opposite of the general Haskell philosophy.
05:15:27 <johnw> Ke: you are not saying anything constructive, but just stirring things up; if you want to contribute to the betterment of Haskell, do so, otherwise leave us to get our work done
05:15:38 <typoclass> srhb: i don't agree that backwards compatibility always has to mean stagnation (there can easily be a coexisting Control.Doodle and Control.NewDoodle, or time and old-time, etc.). but i totally agree with "the type system allows us to easily break things", it's an excellent way to phrase it
05:16:00 <srhb> typoclass: very true, and that's entirely possible to do.
05:16:11 <Ke> if encouraging the use of deprecated is not constructive, I don't know what is
05:16:30 <srhb> I just don't get what people think being enterprisy is or would or can ever be a good thing for Haskell.
05:16:35 <srhb> why people*
05:16:49 <Ke> or standards compliancy
05:17:01 <Chousuke> what standards?
05:17:08 <Ke> haskell 2010
05:17:16 <Chousuke> okay. and why does that matter?
05:17:18 <typoclass> ke: what exactly is your criticism?
05:17:41 <Ke> typoclass: I often run updates an my code breaks without warning
05:17:56 <Chousuke> so... don't update?
05:17:58 <srhb> _without_ warning?
05:18:06 <mcstar> breaks how?
05:18:13 <srhb> That sounds like a serious bug that someone introduced. Your code should not compile if it's broken on newer versions, preferably.
05:18:19 <srhb> I've never experienced that myself.
05:18:30 <arbn> Ke: cabal-dev. The cool kids are doing it.
05:18:30 <amyers> Neither have I
05:18:38 <amyers> Ke: or hsenv
05:18:59 <typoclass> ke: that's true, i've noticed similar things. i think it's a weakness of haskell and i'm glad they're working on getting better at that kind of thing. but the solution is clear, only update when there's an actual need
05:19:01 <Ke> srhb: proper use of deprecated will show you warnings in a version previous to the one that drops the support of the api
05:19:18 <srhb> I'm not saying deprecated is bad.
05:19:30 <amyers> Ke: So you're talking about packages from hackage, not the compiler?
05:19:40 <johnw> Ke: have you tried using stackage?
05:19:50 <srhb> I've also never experienced a problem where my code would break on GHC but should work in Haskell2010
05:20:23 <typoclass> i think pointless updating (just for the pride, "i've got the newest stuff" etc.) is fixing things that ain't broke
05:20:39 <Ke> typoclass: it's rolling release default
05:20:55 <typoclass> ke: what is?
05:20:58 <srhb> Are you considering Hackage a release?
05:21:03 <Ke> frequent updates
05:21:33 <amyers> Ke: Now you're talking about your Linux distro?  If you're on rolling release you're supposed to expect breakage regularly
05:21:41 <typoclass> ke: i don't know what you mean. anyway, don't update so much and you'll get less breakage
05:21:57 <Ke> o_O
05:22:16 <Ke> "I can't get security updates because I use haskell"
05:22:23 <srhb> Nonsense.
05:22:25 <srhb> OK
05:22:25 <Ke> have it your way
05:22:40 <Ke> not runnign updates is never an option
05:22:52 <srhb> I don't think anyone knows what updates you're talking abou.
05:22:53 <srhb> t*
05:23:06 <srhb> When does updating your kernel, say, affect Haskell?
05:23:08 <mcstar> yes, we dont know
05:23:25 <mcstar> dont install haskell packages through the package manager of your distro, only ghc
05:23:34 <amyers> Ke: Or pin your ghc version
05:23:44 <amyers> Ke: so it doesn't update, if that's your problem
05:24:31 <Ke> srhb: if you wan't something that's haskell2010 and not hgc haskell, try exceptions
05:24:37 <Ke> ghc haskell
05:24:43 <srhb> Ke: That's ooold though.
05:24:50 <typoclass> ke: security updates are 99% a matter of "1.1.x" updates. those are not supposed to break things. it should only happen when a maintainer made a serious mistake. when i said "don't update so much", i meant updates of the "1.x.x" or "x.x.x" kind
05:25:08 <srhb> If Haskell' hadn't stagnated (because of Enterprisy ambitions?) the new exceptions would definitely be in the standard.
05:25:31 <dmwit> Dudes and dudettes: Ke has two perfectly reasonable points: Haskell package versioning is a mess, and deprecating things before removing them from an API is a good idea.
05:25:32 <srhb> Also, we still don't know what updates you're doing that break your Haskell programs every day.
05:25:41 <srhb> dmwit: I think we all agreed with that.
05:26:21 <amyers> dmwit: Yeah, we are all agreed on that.
05:26:35 <dmwit> Okay, then! =D
05:27:31 <srhb> Having your Haskell programs break every day, though, that probably means you're doing something wrong. But we don't know what it is.
05:28:00 <mcstar> dmwit: i didnt say, but i dont know if i agreed on that.
05:28:18 <amyers> srhb: Exactly.  Also, not being able to get kernel updates without updating ghc probably means you're doing something wrong.
05:28:19 <typoclass> dmwit: agreed on your points. however, he did phrase things in overreaching combative ways ("haskell can never be used in anything serious"), which is why people are predictably not very inclined to dig for any truth at the core of his statements
05:29:02 <mcstar> very original: 'dudettes'
05:29:15 <amyers> I should say definitely means you're doing something wrong :p
05:29:49 <srhb> typoclass: I feel like I'm digging and digging.
05:30:18 <typoclass> srhb: same here. i'd be interested what he meant with "rolling release default", but he didn't explain when asked
05:30:35 <mcstar> must have meant his distro, what else?
05:30:40 <amyers> typoclass: I think he started talking about hist distro
05:30:48 <Ke> typoclass: rolling release default is "all packages are of latest version"
05:30:49 <amyers> *his distro
05:30:49 <srhb> Anyway, as johnw pointed out, this discussion is probably not constructive because of the very way it started out. So I'm bailing from it,.
05:31:39 <amyers> Ke: Are you on Arch?
05:31:42 <Ke> gentoo
05:32:12 <typoclass> amyers, mcstar: yes probably. which probably means he's using arch linux, which is a whole different topic. (my opinion is that around 2008, arch was pretty good for 1-2 years, but it really deteriorated)
05:32:16 <Ke> all packages are of latest version is no problem, if you have nonzero time to update -> use deprecated
05:32:16 <amyers> If rolling release updates of ghc are a problem I would head over to #gentoo and ask them out to pin a package so it doesn't update.
05:32:26 <mcstar> why arch?
05:32:44 <mcstar> accidentally im on arch too, but thats not the only rolling release distro
05:32:46 <amyers> mcstar: Probably the most popular rolling release distro.
05:32:57 <Ke> amyers: there is no way a delay is going to help here
05:32:58 <srhb> arch' Haskell packages are also notoriously broken notoriously often.
05:33:05 <mbp> the thing I did notice, is that ghc liberally makes breaking changes in new versions. that is why I am afraid to update, most of my code would probably stop working
05:33:10 <srhb> I don't know about Gentoo.
05:33:12 <Ke> amyers: then the breakage will just happen later
05:33:47 <Ke> amyers: the point is, I am maintaining some of the code and it will never be updated before I see the warnings or the breakage
05:34:09 <Ke> and I would like to see the warnings instead of the breakage
05:34:34 <amyers> Ke: Okay, I'm done :p  people here have given you suggestions on how to deal with that.  It's arguably a problem but not an insurmountable one
05:34:37 <mbp> in python for example, people still complain about the breaking changes in python 3.xx vs python 2.xx. in haskell, there seem to be some breaking change in almost every new version of ghc
05:35:18 <tdammers> mbp: they're not usually as fundamental as those between python 2 and 3
05:35:20 <supki> mbp: the good thing is you often get pull requests with fixes before ghc is released
05:35:27 <johnw> i hear COBOL is stable
05:35:32 <supki> or shortly after
05:35:41 <typoclass> mbp: my vague feeling is that ghc itself is seldom the issue. it's more likely that new versions of the base package are the problem
05:35:41 <mcstar> or common lisp, thats a good stable target too
05:35:50 <mcstar> Ke: you have options...
05:35:55 <johnw> oh yeah, they hate extending that!
05:36:41 <Ke> mcstar: only option I see is using following git master of every package I use
05:37:22 <mbp> typoclass still, the end result is that your old code doesn't compile
05:37:30 <mcstar> we acknowledge that you have a problem, with it seems that is not only ghc's fault
05:37:40 <mcstar> with->but
05:37:43 <Ke> what I would like, would be to follow latest version of all packages I use and fix warnings as they appear
05:38:10 <typoclass> mbp: that's true, and i do think that's a weakness of haskell. i think that the sandbox feature that cabal is introducing may help with some of it
05:38:10 <mcstar> Ke: if you have a strong point, i suggest you write it up on a haskell mailing list
05:38:15 <mcstar> i think thats haskell-cafe
05:38:47 <typoclass> ke: i think following git repositories is going to cause even more breakage
05:39:14 <mcstar> how can be sure if the other package developers use the latest versions too?
05:39:19 <mcstar> you be*
05:39:25 <Ke> typoclass: yes, but I will have time to fix breakage before it hits "production"
05:39:42 <Ke> where production is "any distro repo"
05:40:01 <Ke> mcstar: gentoo patches a lot of the packages
05:40:14 <Ke> but the overlay is huge and the workforce limited
05:40:30 <Ke> that's why relying on upstream releases would be nice
05:41:58 <amyers> Ke: I really don't understand this.  If you're on a rolling release things are going to break.  I had an Arch Kernel update brick my desktop because of a kernel bug
05:42:19 <amyers> Ke: I didn't complain about the Kernel team, i chose a rolling release :p
05:42:26 <mcstar> call me crazy, but thats why i'd do: keep my distro up to date, fix ghc version, and use packages from haskell platform..
05:42:31 <mcstar> why->what
05:42:59 <typoclass> ke: it's all a bit hard to understand. you're now talking about problems with gentoo's haskell packages? (not hackage packages)
05:43:11 <Ke> amyers: kernel has backwards compatibility for years?
05:43:26 <amyers> ke: yes, but when you're on a rolling release distro you get bugs sometimes
05:43:43 <amyers> Ke: my point is, if rapid upgrades are a problem don't use a distro with rapid upgrades
05:43:44 <Ke> amyers: api change is not a bug
05:43:48 <mcstar> maybe a messed up mkinitrd scipt...
05:43:57 <mcstar> and boom, you cant boot into your system
05:44:12 <Ke> mcstar: that stuff is easy to deal with
05:44:19 <mcstar> yeah..
05:44:31 <mcstar> but you took the risk, when choosing a rolling r distro
05:44:46 <Ke> typoclass: I am talking about being a package maintainer that provides packages that work for all the distros
05:44:51 <Ke> typoclass: all the time
05:45:19 <mcstar> flame: isnt gentoo deprecated, btw?
05:45:22 <Ke> typoclass: so that you could work with eg. one month latency before breakage hits you
05:45:42 <Ke> mcstar: that flame is boring already ;o)
05:46:19 <mcstar> i dont want to start a flame, just emphasized that the next sentence can be interpreted as flame
05:46:54 <mcstar> everyone i know and used gentoo use something else, ubuntu or arch for example
05:47:06 <parcs> haha "deprecated"
05:47:07 <Ke> ok, then gentoo is still very much alive and has features that are not found in any other distro
05:47:11 <arbn> Are we still talking about the Haskell language standard?
05:47:19 <Ke> like installing all debug symbols for all packages
05:47:27 <amyers> arbn: It's not really clear
05:47:31 <parcs> how can you deprecate a linux distribution?
05:47:52 <mcstar> parcs: 'fell out of favor'
05:47:58 <Ke> arbn: I had no complaint about the standard, only that it was "too old" for mainstream compilers
05:48:41 <arbn> Ke: So, is your complaint about the GHC development philosophy?
05:49:14 <Chousuke> You can't tell GHC to treat your code as Haskell2010?
05:49:26 <Ke> I would like to have a standard compliant compiler whether it is by changing the compiler or the standard
05:49:45 <Chousuke> I mean, if you're using GHC extensions then of course things are going to break
05:50:27 <Ke> Chousuke: I was trying to use haskell2010 exactly
05:50:38 <arbn> Ke: In what way does GHC not conform to the latest Haskell standard?
05:50:45 <Ke> exceptions
05:51:35 <arkeet> how so?
05:51:54 <quicksilver> there is a delta between haskel2010 and GHC in the manual, I think
05:51:57 <Ke> haskell 2010 specifies oldexceptions or something like that
05:52:05 <arkeet> the report only specifies the existence of IOError
05:52:11 <arkeet> and userError, ioError, catch
05:52:28 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs-and-infelicities.html#haskell-standards-divergence
05:52:34 <johnw> there is a river effluent in the manual?  who knew
05:52:46 <arkeet> and the System.IO.Error module hm
05:52:53 * hackagebot computational-algebra 0.0.1.0 - Well-kinded computational algebra library, currently supporting Groebner basis.  http://hackage.haskell.org/package/computational-algebra-0.0.1.0 (HiromiIshii)
05:53:06 <aleator_> I find myself needing a typelevel set. Does any library already have one?
05:53:39 <johnw> aleator_: you mean, like a tuple but unordered?
05:53:49 <aleator_> johnw: Yeah. Just like that
05:53:59 <johnw> i don't see how that could work
05:54:16 <latro`a> how does one access that
05:54:20 <ab9rf> a typelevel set?
05:54:38 <aleator_> Kinda like a HList but accessed by proxy of desired type instead of a nat?
05:54:41 <latro`a> I think he means a heterogeneously typed unordered collection
05:54:47 <ab9rf> ah
05:55:04 <mcstar> aleator_: cant you keep it sorted?
05:55:24 <ab9rf> do you need it to be fully polymorphic?
05:56:04 * arbn idly wonders about aleator_'s operational definition of "need".
05:56:08 <ab9rf> heh
05:56:21 <quicksilver> you don't mean typelevel set
05:56:22 <ab9rf> indeed, i'm unclear on the utility of such an amorphous bag
05:56:28 <quicksilver> you mean heterogenous list
05:56:42 <quicksilver> well heterogenous set.
05:56:45 <aleator_> I'd like to. I have two use cases. 1) I would like to have a collection of phantom types to describe properties of stuff and 2) I'd like an unordered :+: from Swiestras Data types ala carte :)
05:56:46 <mcstar> heterogoenous set
05:56:58 <mcstar> heterogeneous
05:57:07 <quicksilver> you can hack together something quick and dirty with Dynamic.
05:57:27 <arkeet> it sounds like aleator_ wants a type-level set.
05:57:38 <quicksilver> Map TypeRep Dynamic
05:57:40 <henk> I defined a function in ghci using 'let'. Can I see how it was defined?
05:57:54 <ab9rf> henk: backscroll?
05:57:55 <mcstar> henk: scroll up
05:58:22 <ab9rf> functions don't derive show
05:58:32 <arbn> henk: Define it again to be what you think it is.
05:59:02 <henk> ab9rf, mcstar: Well, yeah, in that case that works … I’m just interested if it is possible in principal
05:59:07 <aleator_> Hmm.. I think Vinyl does something like this..
05:59:10 <arkeet> henk: nope
05:59:10 <mcstar> i dont think it is
05:59:16 <henk> ok, thank you
05:59:18 <quicksilver> it would be a nice feature for ghci
05:59:22 <ab9rf> henk: there is no way to see how a function is defined
05:59:24 <mcstar> arkeet: -1 sec consistently, youre good
05:59:27 <quicksilver> to be able to recall the source of definitions.
05:59:35 <quicksilver> but, it does not have it.
05:59:37 <amyers> henk: If you're ina terminal Ctrl-R will search the command history
05:59:44 <amyers> which is easier than scrolling up
05:59:50 <mcstar> (i am sorry, arkeet is not ab9rf , no pattern...)
06:00:28 <arkeet> quicksilver: it would also be nice if it could also look in library sources too.
06:00:28 <amyers> henk: but you probably already knew that, being a sysadmin :p
06:00:33 <typoclass> henk: you may be interested in the file ~/.ghc/ghci_history
06:00:34 <arkeet> also also too.
06:00:56 <mcstar> i wonder if ghci cen be set to scroll whole blocks, and not lines
06:00:58 <henk> amyers: I’d have tried eventually I guess ;)
06:01:01 <ab9rf> arkeet: i'm sure there's a package for that
06:01:03 <quicksilver> arkeet: yes, it would.
06:01:04 <mcstar> i htink readline can be configured to do that
06:01:16 <quicksilver> arkeet: the recommended way to look in library sources is to use haddock
06:01:27 <arkeet> indeed.
06:01:37 <quicksilver> arkeet: which produces, as well as lirbary documentation, full syntax highlighted source with hyperlinks.
06:01:43 <quicksilver> (if you give it right options it does)
06:01:47 <arkeet> indeed.
06:02:08 <quicksilver> but then it would be handy to have a ghci command to 'bring up the haddock docs at the right page for this identifier"
06:02:09 <arkeet> so maybe ghci should open a haddock page.
06:02:09 <arkeet> :p
06:02:12 <arkeet> yeah
06:02:28 <quicksilver> since ghci is in the position to know 'which' lookup the lookup currently in scope is.
06:02:29 <ab9rf> no runtime environment is complete without an imbedded browser
06:02:34 <arkeet> is there something like that for vim?
06:04:01 <mcstar> is ghci extensible?
06:04:04 <mcstar> well it is
06:04:12 <mcstar> you can write code that gets executed on startup
06:05:00 <mcstar> is that enough to write an io action that goes to the right place on the net?
06:05:17 <mcstar> what kind of reflection is possible?
06:05:46 <ab9rf> nerp
06:05:59 <mcstar> is that an acronym?
06:06:00 <ab9rf> i hate fridays
06:06:03 <ab9rf> i really do
06:06:08 <arbn> Honestly, I think this feature belongs in an editor and not the interpreter.
06:06:19 <ab9rf> ghci is already insanely heavy
06:06:19 <mcstar> it is an editor...
06:06:29 <mcstar> line editor
06:07:43 <Saizan> hoogle --info gets close, but you have to maintain the index and name resolution won't be very accurate unless you specify modules
06:08:16 <Saizan> (could cabal maintain the hoogle index?)
06:08:51 <arkeet> it's not like it has to be built in to ghci.
06:09:03 <arkeet> ghci macros can do IO.
06:09:14 <johnw> Saizan: I've recently fixed that
06:09:26 <johnw> you can now say: hoogle --info --exact head
06:09:50 <johnw> i'm not sure if it's been released yet, however
06:09:59 <arkeet> I guess maybe we'd want there to be a way to get a fully qualified name of something, though.
06:10:22 <henk> I’m working on #1 of 99 haskell problems and I’m either doing something wrong or the solution given is not really working. Could anyone tell me what might be the problems cause please? ghci session is on http://paste.debian.net/241887/
06:11:07 <mcstar> henk: use only 1 let
06:11:09 <Botje> henk: that effectively redeclares myLast several times.
06:11:10 <johnw> henk: you need to match the empty case
06:11:28 <johnw> let myLast [] = error "Partial function, bad bad"
06:11:37 <arkeet> johnw: that's not the most immediate problem.
06:11:38 <mcstar> (and indent the other equations ofc)
06:12:01 <arkeet> on one line:
06:12:01 <arkeet> let myLast :: [a] -> a; myLast (_:xs) = myLast xs; myLast [x] = x
06:12:33 <arkeet> but it's probably better to write all that in a separate .hs file and load that into ghci
06:12:41 <mcstar> or cram it up on one line..
06:12:48 * Kinnison is intending to do some vids about testing in haskell -- I'd really appreciate people's input on what test frameworks / techniques / styles they favour for Haskell code.
06:12:52 <Saizan> johnw: what happens when there's more than one head in the index?
06:12:56 <arkeet> or you could use multi-line input.
06:12:58 <johnw> Kinnison: i really like hspec
06:12:58 <Kinnison> So far I've seen test-framework, and its associated hunit and quickcheck support
06:13:03 <mcstar> +1 for multiline
06:13:08 <kamatsu> Kinnison, quickcheck is wonderful
06:13:08 <Kinnison> johnw: I shall add hspec to my list
06:13:10 <johnw> Saizan: in that case you do need to qualify by module/package
06:13:21 <amyers> Kinnison: instructions for integration with cabal would be great
06:13:22 <arkeet> mcstar: it's kind of a pain though
06:13:34 <Kinnison> amyers: Mmm, I definitely need to think of that
06:13:36 <mcstar> arkeet: why? just set multi line scrollback too
06:13:36 <johnw> Saizan: but an --exact query with a qualified module should always have 0 or 1 answers
06:13:45 <arkeet> that exists?
06:13:48 <mcstar> idk
06:13:50 <typoclass> henk: it's easiest if you write your code into file.hs, then do ":l file.hs" in ghci. you can do ":r" to reload after you changed and saved the file
06:13:51 <arkeet> lol
06:13:53 <Kinnison> amyers: Also I want to cover unit testing library internals, versus black-box testing library APIs, versus cmdline testing
06:14:05 <Kinnison> amyers: although the latter can be done with cmdtest if I can work out how to integrate that into cabal
06:14:39 <amyers> Kinnison: Sounds like an interesting series
06:14:51 <amyers> Kinnison: Do you have a blog I could subscribe to?
06:14:53 <Kinnison> amyers: It'll be spread out
06:15:11 <Kinnison> amyers: All my vids go to my youtube channel, and I tend to tweet when new vids turn up
06:15:22 <Kinnison> amyers: I sometimes blog the vids at blog.digital-scurf.org, but not always
06:15:27 <henk> Ok, putting it in a file works fine, but I’d like to understand how it can work in ghci. Yes, I’m curious and like to know the limits of anything I’m working with. Using "let myLast (_:xs) = myLast xs; myLast [x] = x" I get this error: Warning: Pattern match(es) are overlapped
06:15:29 <Kinnison> amyers: my twitter is twitter.com/dsilverstone
06:15:29 <amyers> Kinnison: okay
06:15:51 <Kinnison> amyers: Ditto I tend to G+ the announces: https://plus.google.com/u/0/109098675742430569483/posts
06:16:05 <Kinnison> amyers: And the youtube channel is https://www.youtube.com/user/KimballKinnison
06:16:08 <Botje> henk: correct. [x] is the same as (x:[]), which is also matched by (_:xs)
06:16:11 * Kinnison stops spamming and starts reading about hspec
06:16:19 <amyers> Kinnison: cool, thanks
06:16:28 <typoclass> Kinnison: you should absolutely try out doctest. it's dead simple to use and the tests double as code examples in documentation. you just add two lines ">>> head [1,2,3]" and "1" to a haddock comment, and do "doctest file.hs".
06:16:41 <Kinnison> typoclass: oooh interesting, ta
06:16:44 <Botje> henk: if you put the myLast [x] case first it won't complain.
06:16:46 * Kinnison adds doctest to the list
06:17:11 <henk> Botje: ah, interesting, thank you :)
06:17:46 <Botje> (it will actually work the way you meant it, too)
06:18:29 <Guest62624> Hi haskellers ! Could someone explain to me this list comprehesion : [(s,t+1) | _ <- [0..t+1]]. I don't understand the "_" character here. Thank you !
06:18:34 <johnw> Kinnison: you'll want to include mention of HPC as well
06:18:51 <Kinnison> johnw: oooh more and more, excellent thanks
06:18:54 <Botje> Guest62624: it's a pattern match. _ matches everything.
06:19:14 <johnw> Kinnison: and HTF and test-framework
06:19:24 <johnw> (the major competitors to hspec)
06:19:29 <Guest62624> does it match both s and t here ?
06:19:35 <johnw> all three of those work with HUnit+QuickTest
06:19:41 <johnw> QuickCheck, I mean
06:19:45 <Botje> Guest62624: no, it is matched against an element in the [0..t+1] range.
06:19:46 <johnw> and there is also SmallCheck
06:20:03 <Kinnison> johnw: test-framework I already hve on my list, what's HTF?
06:20:11 <johnw> Haskell Test Framework ;)
06:20:13 <Botje> Guest62624: in effect, that code generates a list of size t+2 of (s,t+1) tuples.
06:20:25 <Kinnison> johnw: heh
06:20:33 <Botje> Guest62624: so you could also rewrite it as replicate (t+2) (s,t+1)
06:20:40 <Guest62624> Botje thank you
06:20:42 <Kinnison> This is all so exciting \o/
06:20:54 <typoclass> Guest62624: hm, that's written a little strangely. i think it'll produce a list of t+1 elements, containing a lot of tuples, each being (s,t+1). effectively it repeats the same tuple
06:21:00 <johnw> Kinnison: ah, and Cabal's support for benchmarking tests, and Criterian
06:21:02 <johnw> Criterion
06:21:22 <typoclass> Guest62624: yes, if you use replicate (as Botje suggests) it'll be much clearer
06:22:20 <johnw> Kinnison: are you interested in Web testing in Haskell?
06:22:31 <johnw> i.e., for testing web apps written in haskell?
06:22:35 <Kinnison> johnw: is HTF just test-framework, or are they different?
06:22:38 <Kinnison> johnw: And not yet, no
06:22:43 <johnw> they are different
06:22:55 <typoclass> > [toUpper x | x <- "lolcat"] -- Guest62624, this is how a list comprehension basically looks. here, "toUpper x" will be run 6 times because the input string has length 6
06:22:56 <lambdabot>   "LOLCAT"
06:23:14 <Kinnison> johnw: can you provide me with a link to HTF?
06:23:24 <Kinnison> johnw: also, when you said "Criterion" did you mean http://hackage.haskell.org/package/criterion ?
06:23:27 <johnw> @hoogle HTF
06:23:27 <lambdabot> package HTF
06:23:34 <johnw> Kinnison: yes
06:23:41 <johnw> http://hackage.haskell.org/package/HTF
06:23:57 <Kinnison> doh :-)
06:24:01 * typoclass . o O ( wow, we really seem to have eleventy dozen test thingies ... )
06:24:02 <ab9rf> ugh
06:24:07 <ab9rf> character set insanity
06:24:12 <ab9rf> i *hate* character sets
06:24:32 <Kinnison> Thanks everyone, that's an awesome set of things for me to learn about
06:24:36 * Kinnison is excited
06:25:25 <johnw> our best testing tool is called the type system ;)
06:25:36 <Kinnison> Indeed, and I intend to talk about that
06:26:26 <ab9rf> i need to write unit tests for this parser
06:26:29 <johnw> where are you giving this talk?
06:26:47 <hpaste> aleator pasted “A type level bag” at http://hpaste.org/84094
06:26:53 <Kinnison> johnw: It'll be a series of 10-15m youtube vids
06:27:02 <johnw> nice!
06:27:03 <Kinnison> johnw: Along similar lines to my current series
06:27:13 <ab9rf> i found a bug in the lexer just a bit ago
06:27:25 <ab9rf> it didn't handle non-ascii text
06:27:36 <Kinnison> johnw: All way too basic for you, I'm sure
06:27:46 * Kinnison needs to poke ghc-mod, it's not giving me full error messages :-(
06:27:58 <aleator_> ab9rf, quicksilver: See the above paste for what I meant with the type-level set if you're still interested. It contains a toy example.
06:28:03 <johnw> Kinnison: i used to have that problem too, then I switched to hdevtools
06:28:59 <ab9rf> aleator_: fun
06:29:41 <aleator_> ab9rf: Now I'd just need to make it store values. But I guess I can just weave a hlist there..
06:29:56 <Kinnison> johnw: Mmm, hdevtools isn't packaged in Debian (yet, joeyh is threatening to get it done) so I'm not feeling the love there
06:30:04 <johnw> git is your friend
06:30:13 <ab9rf> aleator_: that code is giving me a headache
06:30:35 <aleator_> ab9rf: Try an agda pill for that? ;)
06:30:55 <ab9rf> aleator_: i haven't gotten around to using polykinds yet
06:30:57 <Kinnison> johnw: git is my minion -- it's more that I find cabal generally unpleasant, esp. if it starts trying to override system-provided packages
06:31:12 * Kinnison has yet to develop enough stockholm syndrome regarding cabal
06:31:20 <ab9rf> Kinnison: cabal usually knows what it's doing
06:31:24 <aleator_> ab9rf: I have occasionally toyed with them, but that code is stolen mostly from the vinyl package
06:31:28 <ab9rf> Kinnison: the system-provided packages are usually crap
06:31:38 <Kinnison> ab9rf: Unfortunately they're what I have to target for a bnch of stuff I do
06:32:07 <ab9rf> Kinnison: unfortunately none of the linux distros seem to be able to reliably package haskell
06:32:31 <Kinnison> ab9rf: Part of that is the Haskell community's blasé approach to API stability :-)
06:32:44 <Kinnison> But this is not the discussion I wanted to have today
06:32:56 <johnw> Kinnison: i'd clone from git and use cabal-dev to make yourself an hdevtools binary
06:33:05 <johnw> it's *blazingly* fast
06:33:08 <Kinnison> johnw: Mmm, that might be sufficient I guess.  I don't mind local builds
06:33:18 <johnw> like, type updates in a few milliseconds fast
06:33:18 <ab9rf> Kinnison: the old API was bad, the new one is better.  why make people keep using the bad one? :)
06:33:45 <Kinnison> ab9rf: I'm going to assume you're trolling me now :-)
06:33:51 <Kinnison> johnw: Mmm, what's the emacs integration like?
06:33:59 <ab9rf> Kinnison: haskell devs are computer scientists, not software engineers.
06:34:34 <ab9rf> Kinnison: and it's hard enough to get software engineers to maintain API stability
06:34:40 <johnw> Kinnison: it's awesome, I use flycheck to integrate it
06:34:42 <johnw> want my config?
06:35:00 <johnw> https://gist.github.com/5169897
06:35:32 <ab9rf> this stupid grammar makes me angry
06:35:47 <Kinnison> johnw: Do you then not bother with ghc-mod at all?
06:35:59 <Jello_Raptor> http://boingboing.net/2013/03/15/weird-probabilities-of-non-tra.html?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+boingboing%2FiBag+%28Boing+Boing%29&utm_content=Google+Reader
06:36:00 <johnw> i use ghc-mod for just a few things
06:36:04 <Jello_Raptor> d'oh wrong chan
06:36:12 <Kinnison> johnw: How do you disable ghc-mod's flymake stuff then?
06:36:23 * Kinnison installed ghc-mod and it all just started happening :-)
06:37:49 <johnw> Kinnison: don't turn on flymake
06:38:03 <Kinnison> I think it auto-started
06:38:05 * Kinnison pokes about
06:38:13 <johnw> Kinnison: also, use https://github.com/jwiegley/flyparse
06:38:21 <johnw> i haven't updated my config to the latest flycheck
06:38:24 <ab9rf> can i be satisfied with myself with making today's commit a simple fix to handle non-ASCII characters in comments, or do i need to do more before i go and finish my tax returns?
06:38:32 <johnw> so i can't vouch for it
06:38:43 <johnw> the author of that project and I don't really see eye to eye, so I stopped following his changes
06:38:51 <Kinnison> heh
06:39:09 <johnw> oh, and one last thing
06:39:19 <johnw> you'll need to make a patch to hdevtools :)
06:39:35 <johnw> https://gist.github.com/5169918
06:39:53 <johnw> otherwise, flyparse won't know where one error ends and another begins
06:40:29 <hiptobecubic> hdevtools is good
06:40:40 <hiptobecubic> if we hadn't come to that concensus already
06:41:20 <hiptobecubic> I only ghc-mod now when I want some quirk. I think hdevtools doesn't return typeclass info sometimes? Or something? There was some reason which might or might not still be relevant
06:41:55 <johnw> ghc-mod also can give you type info
06:42:05 <johnw> C-c C-t on an identifier will show its type (if the file compiles, that is)
06:42:18 <johnw> sometimes that can be quite handy, but it's slow as molasses
06:42:39 <johnw> oh, and ghc-mod can toggle over to using hlint
06:42:56 <johnw> hdevtools itself doesn't do that, but you can make a flycheck rule to use hlint (which I've done)
06:43:31 <johnw> in fact, here are the three flycheckers I use: https://gist.github.com/5169945
06:43:40 <johnw> just rename hlint++ to hlint and you'll be good to go
06:43:53 <johnw> this makes hdevtools the default, but gives you the option of falling back on plain ghc
06:43:58 <`ramses> is cabal-dev from hackage usable these days or is it still recommended to use the git version?
06:44:06 <johnw> hdevtools doesn't like to work for cabal projects that you've never installed before, for example
06:44:16 <johnw> `ramses: a new release of cabal-dev happened like 4 days ago
06:44:21 <johnw> it's good to go now
06:44:25 <johnw> (even with 7.6
06:44:36 <`ramses> johnw: ah, perfect, thanks :)
06:46:20 <amyers> johnw: How do I tell if hdevtools is running?  The readme says just install it and it will automagically work with vim syntastic, but I don't see a daemon running with any obvious name.
06:51:19 <shanse> amyers: it's not a daemon
06:52:08 <amyers> shanse: Well, okay, persistent background process :p  At least that's what the readme on github says
06:52:29 <shanse> just start up vim, open a haskell file, make an error and see if it complains
06:53:23 <shanse> and see if you have the hdevtools binary in your $PATH
06:53:32 <amyers> shanse: It does, but it always did since I have ghc-mod installed.  I'm just not sure how to tell if it's using hdevtools now
06:53:43 <amyers> shanse: Hoping it will be faster
06:53:53 <shanse> do you have a haskell file open in vim?
06:54:04 <amyers> shanse: yep, and hdevtools on the path
06:54:11 <amyers> I manually started a server
06:54:14 <shanse> then you should see hdevtools running
06:54:56 <amyers> I do see the one I started manually
06:55:05 <amyers> But I don't see vim starting one
06:55:18 <johnw> amyers: you should see a daemon :)
06:55:27 <johnw> once you run hdevtools check, it will spawn a daemon process
06:55:44 <johnw> "hdevtools check Foo.hs" will work from command-line as a test
06:56:41 <hpaste> “Anonymous Coward” pasted “bound rigid type variables” at http://hpaste.org/84095
06:56:57 <Kinnison> johnw: Hmm, I'm going to have to install a lot of extra emacs deps to make this work :-(
06:57:05 <Kinnison> johnw: Not sometihng to hack up right now
06:57:14 <johnw> Kinnison: yeah, but it's worth it
06:57:27 <johnw> see: http://ftp.newartisans.com/pub/hdevtools.png
06:57:32 <amyers> johnw: hmm, I'll have to play with it more
06:57:42 <robstewartuk> hm, could someone explain why http://hpaste.org/84095 doesn't compile? the typical bound rigid type variable error.
06:57:42 <johnw> getting that kind of info practically instantaneously is super helpful
06:57:45 <amyers> johnw: At the command line it just exits silently with no output
06:58:04 <johnw> amyers: does the file have an error in it?
06:58:38 <amyers> no, some warnings  from syntastic in vim though
06:58:46 <johnw> hmm
06:59:45 <johnw> i don't use vim, so I can't really help there
07:00:07 <amyers> johnw: I'll investigate some more.  Thanks for the tip, I hadn't heard of hdevtools
07:02:26 <mcstar> Foo is pretty useless, Bar a and Baz b are totally opaque
07:03:23 <robstewartuk> Foo isn't supposed to be useful for anything..
07:03:37 <mcstar> thats what ghc detects
07:04:05 <robstewartuk> the code was enough to generate the "bound rigid type variable" error, my question is more about that.
07:06:28 <mcstar> do they disappear when you provide a typeclass constraint on types 'a' and 'b'?
07:07:17 <robstewartuk> hm, in all definitions i.e. Foo, Bar and Baz?
07:07:20 <robstewartuk> let me try.
07:10:41 <mcstar> robstewartuk: this works for me http://sprunge.us/EeUh?haskell
07:11:06 <robstewartuk> ah!
07:11:33 <robstewartuk> so the important piece is to pull "forall a b." out before Foo ?
07:12:55 * hackagebot computational-algebra 0.0.1.1 - Well-kinded computational algebra library, currently supporting Groebner basis.  http://hackage.haskell.org/package/computational-algebra-0.0.1.1 (HiromiIshii)
07:14:10 <mcstar> robstewartuk: bar :: forall a. Bar a is the same as bar :: Bar a, forall is implied there
07:15:23 <mcstar> well, maybe not exactly..., but it doesnt need the existentialquantification extension
07:17:26 <mcstar> also, i dont know why the universal quantifier needs the existential quantification extension, can someone explain it to me?
07:17:39 <hpaste> “Anonymous Coward” revised “bound rigid type variables”: “fixed: bound rigid type variables” at http://hpaste.org/84095
07:17:49 <mcstar> is it a misnomer, or there is a deep reason?
07:18:34 <robstewartuk> mcstar: I haved edited http://hpaste.org/84095 . The Foo defintion commented out does not work, with the forall before the Foo does so.
07:18:36 <robstewartuk> thank you :-)
07:18:54 <mcstar> yes, i checked
07:19:13 <dmwit> mcstar: There are several extensions you can choose from to allow adding a forall.
07:19:45 <dmwit> However, putting a forall before a constructor needs ExistentialQuantification because it is just a funny syntax for existential quantification.
07:20:33 <mcstar> dmwit: does this mean, there is a counterpart for flip E ?
07:20:52 <dmwit> I'm not sure I understand your question.
07:21:23 <dmwit> But you should read "data Foo = forall a. Bar a" as "for all types a, there is a constructor Bar :: a -> Foo", that is, "Bar :: exists a. a -> Foo".
07:21:37 <mcstar> forall is the universal quantifier, for all x(satisfying something) P(x) while E is there is an x for which P(x)
07:21:41 <dmwit> "Bar :: (exists a. a) -> Foo"
07:22:10 <mcstar> hm
07:22:25 <mcstar> dmwit: so is there an 'exists' in haskell>
07:22:45 <dmwit> There is no "exists" keyword. But the syntax I put above is the syntax you use for creating existentials.
07:22:55 <mcstar> ok
07:23:02 <shachaf> There is an "exists" keyword in UHC.
07:23:22 <dmwit> Ah, yes, all of the above comments should be s/haskell/GHC/ig, of course.
07:24:29 <mcstar> also, the . is not too consistent with =>, is it?
07:24:45 <dgpratt> is there a way to 'query' the package database to determine what packages depend on another package/version? e.g. what packages depend on base <4.6?
07:25:31 <dgpratt> I should have said 'Hackage' not the package database
07:25:40 * mcstar deletes his last comment
07:25:57 <notdan> Hi. I know this is probably a misdirecting and a wrong question to ask, but nevertheless, what is the "best" Haskell library for working with XML?
07:26:12 <notdan> and XSD
07:26:15 <dmwit> dgpratt: There's a tool out there for checking packages for stale dependencies...
07:26:16 <Taneb> Depends what you want to do with it, notdan
07:26:28 <dmwit> dgpratt: And there's another tool for reverse dependencies.
07:26:33 <dmwit> Not sure the latter is version-specific, though.
07:26:46 <Taneb> notdan, probably xml-types/xm-conduit?
07:26:47 <dmwit> Neither of these two tools does *exactly* what you asked.
07:26:51 <dgpratt> dmwit: I found the latter, didn't seem to be what I'm looking for
07:27:10 <dgpratt> dmwit: haven't seen the former, though (that I recall)
07:27:18 <dmwit> Okay, let me see if I can find it for you.
07:27:27 <dgpratt> dmwit: thanks
07:27:40 <Taneb> notdan, but there's also hxt
07:28:07 <dmwit> dgpratt: http://packdeps.haskellers.com/ and
07:28:10 <dmwit> ?hackage packdeps
07:28:10 <lambdabot> http://hackage.haskell.org/package/packdeps
07:28:18 <dgpratt> dmwit: I'll check it out, thanks
07:28:39 <mcstar> dmwit: im sorry, but i dont see the equivalence of forall a. Bar a; and Bar :: (exists a. a) -> Foo
07:28:57 <Taneb> I'm having trouble getting syntax highlighting working in Eclipse FP
07:29:04 <dmwit> mcstar: There's no equivalence. The former is just syntax for the latter.
07:29:52 <dmwit> dgpratt: See also https://byorgey.wordpress.com/2012/08/25/identifying-outdated-packages-in-cabal-install-plans/
07:29:53 <notdan> thanks Taneb , i'll check those out
07:30:10 <dmwit> notdan: tagsoup is quite lightweight
07:30:10 <mcstar> dmwit: but it seems to me the latter only states, there are types, (one or more) that Bar can turn into a Foo, but that what ghc does, is that it gives you a Bar that can turn ANY type into a Foo
07:30:10 <notdan> I am not familiar with conduit so I guess i wont touch the Snoyberg's library fornow
07:30:11 <shachaf> dmwit: I wouldn't say *syntax* for the latter exactly.
07:30:15 <shachaf> But it means the same thing in this case.
07:30:21 <notdan> and xml-types is 'experimental'
07:30:30 <shachaf> dmwit: What do you say to Bar :: forall a. a -> (a -> Int) -> Bar?
07:31:20 <dmwit> mcstar: Oh, bugger. You thought I was writing GADT syntax or something for the latter.
07:32:28 <notdan> What about HaXML?
07:32:37 <notdan> How is it compared to HXT?
07:32:39 <dmwit> mcstar: Do you agree that "forall a. (a -> Foo)" and "(exists a. a) -> Foo" would be equivalent if we had both existentials and foralls?
07:33:19 <dmwit> ...and explicit type application, say. =)
07:33:59 <dmwit> shachaf: I guess I'm not following your point.
07:34:31 <beaky> hello
07:34:36 <beaky> deos haskell ahve real number built in?
07:34:58 <shachaf> dmwit: Never mind, it wasn't much of a point to begin with.
07:35:08 <Philippa> it's got single and double precision floats. No programming language actually has real numbers
07:35:09 <liyang> beaky: no, the best we have is Double.
07:35:25 <dmwit> beaky: There are several libraries for various brands of real numbers.
07:35:33 <beaky> ah
07:35:38 <RenJuan> beaky, computers can only approximate general real numbers
07:35:39 <dmwit> Computable reals, rationals, fixed-point arithmetic, etc.
07:35:41 <typoclass> liyang: (fsvo "best" ...)
07:35:57 <dmwit> You need to know what operations you need on the things before you can pick a best library.
07:35:57 <beaky> which one is good for writing a CAS engine? :D
07:36:08 <liyang> typoclass: he said built-in...
07:36:17 <liyang> Actually Ratio Integer is even better. It actually is the rationals.
07:36:21 <beaky> aah
07:36:22 <dmwit> Oh yes, and there's the cyclotomic numbers package, too.
07:36:25 <Philippa> beaky: if you need to ask, assume you're writing a toy and be willing to make some mistakes :-)
07:36:31 <beaky> yes
07:36:33 <beaky> :(
07:36:46 <geekosaur> beaky, maybe you asked the wrong question. what are you trying to do?
07:36:50 <typoclass> liyang: i agree, imho Data.Fixed and Rational are underused, compared with the weird sneaky floating point stuff
07:36:51 <Philippa> don't get me wrong: I've written a lot of toys
07:37:01 <geekosaur> (around here, you ask about reals, you get mathematical reals...)
07:37:09 <liyang> typoclass: that's because they're *slow*.
07:37:14 <beaky> I want to write a function that differentiates a function
07:37:31 <Philippa> liyang: that and often actually inappropriate
07:37:50 <geekosaur> (which is oto say the hairy ones that can't be represented exactly in all cases by any computer)
07:37:53 <mcstar> you dont need numbers for CAS
07:37:57 <beaky> ah
07:38:00 <liyang> beaky: edwardk has already done it: http://hackage.haskell.org/package/ad
07:38:05 <beaky> ah nice
07:38:41 <hiptobecubic> beaky, it's a nice package https://gist.github.com/johntyree/3956381
07:38:57 <typoclass> liyang: i think the problem is rather that everyone has heard of floats, but not so much of the others
07:38:58 <beaky> haskell always has lots fo cool libraries
07:39:25 <aleator_> Can you index HList by type?
07:39:28 <hiptobecubic> beaky, most that is is just error checking, the only cool part is "getGreeks"
07:40:13 <mcstar> dmwit: im having a hard time interpreting "(exists a. a) -> Foo"
07:41:04 <dmwit> mcstar: aha
07:41:24 <dmwit> mcstar: This is a function which takes a value of some undeclared type (any type the caller likes) and returns a Foo.
07:41:47 <mcstar> so 'a' escapes the quantification after all
07:42:04 <dmwit> mcstar: Similarly, "forall a. a -> Foo" is a function type where you get to pick any type you like, and call the function with a value of that type to get a Foo.
07:42:15 <elliott> no escaping there
07:42:41 <dmwit> mcstar: Define "escapes"?
07:43:03 <mcstar> dmwit: are you talking about something like monomorphism?
07:43:09 <johnw> where is the 'exists' keyword from?
07:43:26 <dmwit> johnw: Let's say System F extended with existential quantification.
07:43:32 <liyang> johnw: it doesn't exist.
07:43:40 <beaky> also, how do I parse a formula into something to be solved? e.g I want haskell to solve for x when I type in " 1 + x = 3"
07:43:44 <dmwit> mcstar: I don't think I'm talking about monomorphism.
07:43:50 <johnw> liyang: ok, thought my parallel universe switcher was on the blink
07:43:56 <dmwit> mcstar: Although again it's kind of hard to answer that question. Define "monomorphism". =P
07:44:05 <elliott> johnw: UHC :P
07:44:28 <elliott> beaky: Haskell isn't a computer algebra system; you'll have to code solving yourself
07:44:29 <dmwit> beaky: You might look into Parsec.
07:44:49 <dmwit> There are other good parsing libraries, but parsec is a good place to start.
07:45:03 <dmwit> There's a (somewhat dated) tutorial that's quite nice lying around here somewhere...
07:45:15 * dmwit hunts through his bookmarks
07:45:15 <beaky> ah
07:45:16 <liyang> What about trifecta?
07:45:24 * johnw likes trifecta a lot
07:45:41 <mcstar> dmwit: i was trying to make sense of the formula "(exists a. a) -> Foo" as a propositional logic formula, maybe thats the problem
07:45:44 <dmwit> liyang: I didn't suggest trifecta because I felt the documentation and google-help-ness of Parsec would be better for a beginner.
07:45:58 <beaky> maybe I can handroll shutning yard
07:46:08 * liyang usually jumps to attoparsec when he needs a fast ByteString parser, which is most of the time for him.
07:46:24 <ion> mcstar: I find it easy to intuit like this: ((exists a. Bar a => a) -> Foo) ~ ((BarDictionary, a) -> Foo), curried ~ (BarDictionary -> a -> Foo) ~ (forall a. Bar a => a -> Foo). (Someone please confirm i’m not talking out of my ass.)
07:46:33 <mcstar> beaky: you surely have crossed DoCon the haskell domain constructor
07:46:37 <ParahSailin_> is there a parser that has a faster "atoi" than attoparsec's "decimal"
07:47:04 <dmwit> beaky: http://legacy.cs.uu.nl/daan/parsec.html
07:47:24 <dmwit> The reference guide is actually a tutorial, and I thought it was pretty good.
07:47:33 <liyang> ParahSailin_: Zeptoparsec?
07:47:35 <dmwit> You'll have to translate a bit to use it with modern parsec, but it shouldn't be too too hard.
07:47:51 <mcstar> ion: im not sure if thats a joke or i should really make sense of it
07:49:05 <beaky> how do I copy out the elements in a Data.Set into a Data.List or Data.Vector?
07:49:11 <shachaf> ion: You're talking sense, mostly, though I'd use a different notation.
07:49:31 <barrucadu> beaky: http://www.haskell.org/ghc/docs/6.4.1/html/libraries/base/Data-Set.html#11
07:49:36 <liyang> beaky: Data.Set.toList and Data.Vector.fromList
07:49:37 <shachaf> ion: For one (exists a. Bar a => a) doesn't really make sense -- => is like a function; you want a thing that's like a tuple.
07:49:42 <shachaf> ski uses the notation *> for that.
07:49:48 <beaky> ah thanks
07:49:54 <ion> shachaf: Ah, indeed.
07:50:30 <beaky> if haskell is a statically-typed language, how come there are lots of interpreters for it? O.o
07:50:54 <mcstar> they statically typecheck your code
07:51:02 <shachaf> ion: But the general idea of seeing it as currying is reasonable. I think it's even simpler if you get rid of the type class business.
07:51:35 <Eduard_Munteanu> shachaf: isn't that more like a (a, Bar a) => a ?
07:51:52 <shachaf> Eduard_Munteanu: I don't know what that notation means. Is "a" a constraint?
07:51:57 <ion> shachaf: Hmm. “exists a. a” can be thought of as a tuple of what and a?
07:52:08 <shachaf> ion: A type and a value of that type.
07:52:09 <Eduard_Munteanu> shachaf: no, I mean a tuple
07:52:20 <elliott> (?t::Type) *> t  -- clearly.
07:52:24 <elliott> Er, *?t
07:52:25 <shachaf> Eduard_Munteanu: I'm not sure I follow.
07:52:28 <elliott> (?t::*)?
07:52:31 <ion> shachaf: Alright, thanks
07:52:50 <shachaf> ion: (exists a. Foo a) -> Bar  ~  ((a::*), Foo a) -> Bar  ~  (a::*) -> Foo a -> Bar  ~  forall a. Foo a -> Bar
07:53:17 <Eduard_Munteanu> shachaf: a pair of a type and a typeclass constraint on it. In Agda, Bar would be a predicate.
07:53:25 <mcstar> (exists a. Foo a) /= (exists a. a) -> Foo
07:53:38 <shachaf> Eduard_Munteanu: I'm not sure how the syntax => makes sense there.
07:53:57 <shachaf> mcstar: I am aware. Hence 07:50 <shachaf> ion: But the general idea of seeing it as currying is reasonable. I think it's even simpler if you get rid of the type class business.
07:55:28 <Eduard_Munteanu> shachaf: well, it's still more like a function arrow. So it basically says "given an element of ∃ Bar, I can give you an element of that type"
07:58:18 <Eduard_Munteanu> Though that interpretation imbues ∃ and => with binding properties.
07:59:05 <shachaf> Eduard_Munteanu: OK, so that's a binder.
07:59:13 <shachaf> Seems strange to me.
08:01:30 <Eduard_Munteanu> Actually I'm not sure if I mean ∃ (λ a -> Bar a -> a) or something else.
08:01:58 <Eduard_Munteanu> I guess I do.
08:02:06 <mcstar> ill finish the haskell road to logic, before i start this topic up again
08:07:56 * hackagebot http-conduit 1.9.2.2 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.9.2.2 (MichaelSnoyman)
08:07:58 * hackagebot parsec-parsers 0.1.1 - Parsing instances for Parsec  http://hackage.haskell.org/package/parsec-parsers-0.1.1 (EdwardKmett)
08:12:04 <mcstar> ohoho, you can say a /= b, where a, b are type variables
08:12:19 <srhb> What?
08:12:33 <mcstar> i guess thats the inverse of a ~ b
08:12:39 <Taneb> How?
08:12:46 <srhb> Indeed, how?
08:12:47 <johnw> it's not /~?
08:13:06 <mcstar> isnt a ~ b basically type equality?
08:14:07 <mcstar> srhb: http://www.haskell.org/haskellwiki/GADTs_for_dummies chapter 4 down
08:14:15 <mcstar> section, not chapter
08:14:59 <srhb> Ah.
08:15:27 <srhb> Instance priorities, never heard of that before.
08:15:41 <srhb> Nor of /=-constraints.
08:16:25 <johnw> huh
08:16:47 <typoclass> er ... holy cow?
08:17:01 <elliott> mcstar: erm... you can't say that?
08:17:06 <elliott> unlses you defined (/=) yourself
08:17:18 <dmwit> This is a proposal, not available now in any implementation.
08:17:20 <srhb> According to that page, that extension provides it.
08:17:21 <srhb> Ah.
08:17:27 <elliott> "The two most well-known language extensions proposed to solve such problems are instance priorities, which allow us to explicitly specify instance selection order, and '/=' constraints"
08:17:32 <elliott> right, "proposed"
08:17:33 <dmwit> And as far as I know, nobody has fleshed out the proposal with enough details to implement it.
08:17:33 <mcstar> dmwit: that is not clear from the text
08:17:49 <dmwit> Yes it is. "The two most well-known language extensions proposed to solve such problems..."
08:17:49 <mcstar> wasnt for me....
08:17:55 <typoclass> "The two most well-known language extensions proposed to solve such problems are ... '/=' constraints"
08:18:03 <elliott> it could mean existing language extensions that are proposed as a solution to such problems
08:18:07 <elliott> anyway this is "for dummies"?
08:18:14 * elliott suspects this page of being terrible.
08:18:24 <srhb> I'm afraid of that too.
08:18:31 <mcstar> "The two most well-known language extensions proposed to solve such problems are instance priorities" means for me, they proposed those extensions, to solve these problems...
08:18:37 <elliott> it starts off talking about type functions, which have nothing much to do with GADTs...
08:18:45 <typoclass> ... but you do wish that people marked non-compiling code clearly. "-- Error"
08:18:51 <Eduard_Munteanu> Of course, in the same vein as "the Gentle Introduction" :)
08:18:55 <elliott> mcstar: which doesn't imply the extensions are in GHC
08:19:08 <parcs> with overlapping type families you can implement /=
08:19:36 <parcs> type family NotEq a b :: Bool; type instance where NotEq a a = False; NotEq a b = True
08:19:55 <parcs> they are in ghc 7.8
08:20:51 <dmwit> I guess you mean they're in HEAD?
08:21:35 <parcs> yeah
08:21:46 <mcstar> whose head?
08:21:53 <parcs> master's head
08:22:09 <dmwit> We're all mad here!
08:26:23 <srhb> How do I get a list of channels on freenode again?
08:26:34 <mcstar>  /list?
08:26:49 <srhb> Thanks
08:26:51 <shachaf> srhb: /msg alis help
08:27:32 <typoclass> srhb: in my pidgin, it's in the værktøjer menu
08:27:34 <mcstar> hm, a shachaf never ceases to be handy/useful
08:27:50 <mauke> (probably "Tools")
08:29:37 <mcstar> to be honest, it is rather funny, that typeclasses were proposed 'to solve the overloading of numerical operators' only
08:29:55 <mcstar> they turned out to be quite useful :)
08:31:02 <mcstar> in a sense similar to nuclear fission, they just wanted a weapon, but now it solves our energy problem..
08:31:09 <ecuderpam> That's still the easiest example to use to explain them.
08:31:31 <mcstar> oh, i didnt know the used this analogy to explain typeclasses
08:31:43 <mcstar> they*
08:36:20 <dmwit> mcstar: funny =)
08:47:04 <feliperosa> hey guys, could someone help me get motivated about parallel haskell? I'm trying to, but I'm finding it too hard to get significants speedups (and sometimes speedups at all). Is there a tutorial on sparks, or the parallel part of the rts?
08:47:41 <shachaf> @google simonmar community slides
08:47:43 <lambdabot> http://community.haskell.org/~simonmar/slides/cadarache2012/
08:47:43 <lambdabot> Title: Index of /~simonmar/slides/cadarache2012
08:47:49 <shachaf> Those slides are good.
08:47:57 <shachaf> @google concurrent and parallel haskell o'reilly
08:47:58 <lambdabot> http://www.haskell.org/pipermail/haskell/2012-May/023328.html
08:47:59 <lambdabot> Title: [Haskell] ANNOUNCE: forthcoming O'Reilly book on Parallel and Concurrent Haskell
08:48:09 <shachaf> There's a draft of the book online somewhere. That's good too.
08:48:45 <feliperosa> shachaf: Thank you, I'll read them all :)
08:54:04 <bourbaki> Greetings
08:54:49 <bourbaki> Does anyone of you happen to know if you can share a device context using Accelerate, calling it through a dll in C++? And write a result in a shared resource.
08:57:39 <mcstar> i had it open
08:57:41 <mcstar> http://ofps.oreilly.com/titles/9781449335946/draft_00000002.html
08:59:15 <tomejaguar> Can I get ghc to allow me to access a hidden module?
09:02:12 <geekosaur> tomejaguar, usually hidden means you are using cabal and your cabal file is wrong
09:03:11 <geekosaur> (that is, cabal insists that if you are using a module, you should say so; using a module without declaring it in the cabal file is a bug looking for a chance to happen)
09:04:56 <tomejaguar> Well I'm not using cabal
09:05:08 <tomejaguar> I'm trying to run -ddump-simpl on one of the source files from Haste
09:05:20 <tomejaguar> but it won't let me reference other stuff in Haste
09:05:23 <tomejaguar> since it's apparently hidden
09:40:41 <ParahSailin> `Could not find module `Data.ByteString.Builder' Perhaps you meant Data.ByteString.Lazy.Builder (from bytestring-0.10.0.2)'
09:48:13 <elliott> ParahSailin: http://hackage.haskell.org/package/bytestring-0.10.0.2 has no Data.ByteString.Builder, only the latter
09:48:13 <magneticduck> I has a bit of a problem
09:48:19 <magneticduck> let's say I have an infinite list
09:48:24 <magneticduck> and I have a finite, but very long list
09:48:26 <elliott> http://hackage.haskell.org/package/bytestring has Data.ByteString.Builder, so it sounds like your bytestring ist oo old
09:48:33 <elliott> perhaps you should just use the Lazy version?
09:48:34 <magneticduck> I have two kinds of elements, a and b
09:48:53 <elliott> it looks like Data.ByteString.Builder works with the lazy form anyway
09:48:58 <magneticduck> I want to have a quick check that tells me if a list is all a's, or if it has a b in it
09:49:01 <magneticduck> does that make a bit of sense?
09:49:04 <elliott> ah, Data.ByteString.Lazy.Builder says "We decided to rename the Builder modules. Sorry about that."
09:49:08 <magneticduck> is there any way of doing that?
09:49:10 <elliott> so you should just import the Lazy module
09:49:29 <magneticduck> or should I just change my algorithm
09:49:31 <elliott> magneticduck: that sounds like a question about one list; where does the other list come in?
09:49:45 <magneticduck> err, I want to distinguish between the two
09:49:50 <magneticduck> errr
09:49:52 <magneticduck> xD
09:49:58 <magneticduck> there's no check that says if a list is infinite or not, is there
09:50:12 <mcstar> you can reason about your code
09:50:20 <magneticduck> I'm just fishing for ideas here; I'm probably going to have to do something completely different
09:50:36 <geekosaur> that sounds like the halting problem to me
09:50:40 <magneticduck> I could fix the problem by not using infinite lists, but I want to know if there's a way to do this
09:50:43 <magneticduck> yeah, it seems a bit like it
09:51:01 <magneticduck> my actual problem is a bit like this: I'm making a maze, made up of a bunch of tiles
09:51:20 <magneticduck> for some operations, it's helpful if the limits of the maze are filled up with "UntouchedTiles"
09:51:36 <tieTYT> need some help with windows.  I installed http-wget, and then installed wget on windows.  I can only get the wget functions to run if I cd into the directory of the cygwin binary, but when I run them, the console just hangs and doesn't do anything.
09:51:42 <magneticduck> however, I often want to cut the maze back into a minimal form after doing those operations
09:51:51 <tieTYT> let me reword that:
09:51:52 <tieTYT> need some help with windows.  I installed http-wget, and then installed wget on cygwin.  I can only get the wget functions to run if I cd into the directory of the cygwin binary, but when I run them, the console just hangs and doesn't do anything.
09:52:04 <magneticduck> so I need to find the last row with non-untouched tiles.. however, it seems to be impossible
09:52:09 <magneticduck> using the tools I have now at least
09:52:15 <philipdexter> to get them to run outside of the directory you have to add the cygwin/bin to your path variable
09:52:29 <tieTYT> philipdexter: ah ok.  But why does it hang?
09:52:57 <philipdexter> tieTYT: i'm not exactly sure... do you know how to add to your path variable? it should be somewhere in the control panel, if you just search for `path' perhaps
09:53:05 <tieTYT> yes
09:53:12 <tieTYT> but, I doubt this will fix the hanging problem
09:53:21 <mcstar> halting problem
09:53:24 <philipdexter> tieTYT: yeah, I doubt it as well
09:53:25 <mcstar> :)
09:53:30 <magneticduck> mcstar: yeah, I guess so
09:53:33 <magneticduck> back to the drawing board
09:53:35 <magneticduck> :P
09:53:38 <mcstar> tieTYT: how do you invoke wget?
09:53:55 <magneticduck> I was just wondering if there was some tricky haskell backdoor magic that could do that kind of thing
09:54:00 <mcstar> magneticduck: no, im just saying one man has halting the other hanging problem..
09:54:02 <tieTYT> mcstar: I called the wget function here: http://hackage.haskell.org/packages/archive/http-wget/0.6.2.3/doc/html/Network-HTTP-Wget.html
09:54:03 <magneticduck> depending on how infinite lists are actually stored in memory
09:54:11 <magneticduck> ah, yeah
09:54:13 <magneticduck> :D
09:54:51 <mcstar> tieTYT: what are the parameters?
09:55:10 <tieTYT> hrm I dunno.  I tried it at home and now I'm at work
09:55:12 <tieTYT> let me try again
09:55:21 <ParahSailin> elliott: ah, misread 10.0.2 as 10.2.0
09:55:23 <tieTYT> give me a few minutes
09:56:33 <ParahSailin> now i feel completely retarded-- i just did cabal update and i still cant cabal install bytestring-0.10.2.0
09:56:40 <c_wraith> magneticduck: if you want to determine if a thunk has been evaluated, there are horrible dirty tools you can use to do so. see the vacuum package
09:56:51 <magneticduck> c_wraith: ahah, that's what I was looking for
09:56:54 <donri> ParahSailin: you shouldn't cabal install bytestring
09:56:56 <magneticduck> however, I'm not going to actually use them
09:57:01 <magneticduck> :P
09:57:11 <c_wraith> vacuum is really nice for debugging
09:57:13 <ParahSailin> donri: wut
09:57:31 <donri> ParahSailin: it comes with ghc and shit hits the fan if you install another by the side
09:57:39 <dcoutts> ParahSailin: unless you really really need that later version. Having two versions can cause confusion.
09:58:05 <ParahSailin> donri: i've already rebuilt everything several times around
09:58:48 <magneticduck> huh, so that means that a function like (f xs = xs ++ repeat a) has no viable inverse
09:58:56 <magneticduck> that is, it cannot be undone in finite time
09:59:05 <magneticduck> awesome
09:59:16 <magneticduck> more uninversible functions to add to the list
09:59:27 <magneticduck> correct me if I'm wrong
09:59:55 <ParahSailin> i forget how to rebuild cabal -- the first step is moving .ghc?
10:00:16 <ParahSailin> rebuild all packages i mean
10:00:25 <donri> cabal install world
10:01:08 <ParahSailin> donri: i've tried that one before, it always dies horribly
10:01:28 <tieTYT> ok I have now installed wget
10:02:01 <mcstar> i cant
10:02:10 <mcstar> transformers doesnt build...
10:02:16 <mcstar> Control/Monad/Trans/Error.hs:55:21: Not in scope: `catch'
10:02:40 <tieTYT> mcstar: http://hpaste.org/84109
10:02:57 <tieTYT> it's just halting on that
10:03:24 * mcstar scratches head
10:03:35 <tieTYT> at least it's consistent between work and home
10:03:49 <tieTYT> i'm running this on winghci
10:04:24 <mcstar> tieTYT: if wget is not in the path, and the lib is not written right, i can imagine causing this
10:05:03 <mcstar> tieTYT: you can try just updating PATH for this one time, and running ghci again
10:05:12 <tieTYT> mcstar: but it is in the path now
10:05:24 <mcstar> are you sure?
10:05:26 <tieTYT> before, it used to give me an exception
10:05:30 <tieTYT> but this time it halts
10:05:31 <mcstar> ok
10:05:35 <tieTYT> that's my evidence at least
10:05:51 <tieTYT> i modified the path before I tried to include C:\cygwin\bin
10:05:56 <tieTYT> as the last thing in there
10:06:01 <mcstar> id test it myself, but transformers doesnt build...
10:06:28 <mcstar> tieTYT: you can call wget directly, without that library though
10:06:53 <tieTYT> mcstar: to see if it halts?
10:07:12 <tieTYT> it works
10:07:55 <mcstar> not to see if it halts, (i guess it is never started) but to just get your job done..
10:08:12 <mcstar> tieTYT: so now it is working? how?
10:08:18 <tieTYT> through the command line
10:08:23 <tieTYT> still halted from winghci
10:08:40 <mcstar> 'halted'?
10:08:49 <tieTYT> it hangs
10:08:51 <mcstar> ok
10:09:04 <mcstar> so, just call wget directly from ghci
10:09:11 <tieTYT> how?
10:09:15 <tieTYT> with that :! thing?
10:09:31 <mcstar> there is an interface in System.IO for calling system commands
10:09:44 <tieTYT> :( kinda lame
10:10:10 <mcstar> why?
10:10:13 <magneticduck> gah
10:10:15 <mcstar> thats what http-wget does
10:10:26 <magneticduck> your names have the same number of letters, and my client picked close colors to represent them
10:10:28 <magneticduck> my eyes hurt
10:10:30 <magneticduck> :D
10:11:12 <ab9rf> heh
10:11:20 <mcstar> tieTYT: look up System.Process in the docs
10:11:47 <bgamari> How does one get emacs to rewrap comments correctly?
10:12:06 <bgamari> It currently doesn't delete/insert --s correctly
10:12:32 <tieTYT> ok thanks
10:12:41 <mcstar> bgamari: does for me?
10:12:51 <bgamari> hmm, perhaps it's evil's fault
10:14:04 <bgamari> mcstar, You are using haskell-mode?
10:14:20 <mcstar> i think yes
10:15:18 <tieTYT> i created this: http://stackoverflow.com/questions/15438353/hastkell-http-wget-hangs-my-program-in-windows
10:17:18 <absence> has anyone used pipes-attoparsec? i'm having some trouble with this code: http://hpaste.org/84112
10:17:29 <mcstar> tieTYT:
10:17:31 <mcstar> let getGoogle = do (_, Just hout, _, _) <- createProcess (proc "wget" ["-q", "www.google.com", "-O", "-"]){ std_out = CreatePipe }; hGetContents hout
10:18:29 <tieTYT> mcstar: that works
10:18:35 <mcstar> yes, i know...
10:18:37 <tieTYT> i mean i'll use that if I have to
10:18:41 <mcstar> ok
10:18:46 <tieTYT> but I'd rather the library work, it's much more elegant
10:18:56 <mcstar> uhm, how so?
10:19:18 <mcstar> (ofc it has more options, but i dont see the elegance)
10:19:38 <tieTYT> the api is more obvious
10:20:00 <mcstar> tieTYT: your real name is quite funny
10:20:07 <mcstar> no offence, dudebot
10:20:31 <tieTYT> mcstar: thansk
10:23:08 <donri> absence: why are you running a parser inside a parser
10:23:35 <donri> oic alt. 2
10:24:30 <donri> absence: why not pass in size to blockParser
10:27:31 <bgamari> mcstar: How do you rewrap?
10:27:53 <mcstar> i comment/uncomment with m-;
10:28:31 <bgamari> mcstar, ahh, I see
10:30:39 <beaky> is there a jit for haskell
10:31:55 <luite> there are some experiments, but no production ready jit compiler
10:32:08 <beaky> ah
10:32:44 <donri> beaky: http://youtu.be/PtEcLs2t9Ws
10:33:34 <luite> beaky: https://github.com/nominolo/lambdachine
10:34:40 <beaky> wwwow
10:34:48 <donri> i love jits, but they're not easy
10:35:13 <simpson> beaky: Easy mode: Implement Haskell in RPython and run it through PyPy. Bam, free JIT.
10:35:30 <parcs> jit is overrated
10:35:48 <mcstar> overrating is underrated
10:36:08 <Philippa> I suspect some Haskell idioms will do rather nicely with JIT
10:36:35 <beaky> yes like higher order functions
10:36:49 <beaky> i.e. half of haskell :D
10:37:17 <parcs> a sufficiently smart compiler can optimize away higher order functions
10:37:22 <parcs> i don't see how a jit can make this easier
10:37:36 <Philippa> by not having to guess as much
10:38:11 <Philippa> in general, "sufficiently smart" means psychic
10:38:19 <Philippa> or rather, means "solves undecidable problems"
10:38:54 <absence> donri: that was alternative 1, in order to avoid tracking how many bytes are consumed. passing size to blockParser is similar to alternative 2, i still have to track consumption unless i'm missing something
10:39:06 <parcs> well just inlining things takes you a long way
10:39:21 <donri> absence: point being you could move the tracking to a single place, in blockParser itself
10:39:49 <parcs> i.e. you inline 'map f' into its call site, and now you have a non-higher order function
10:39:57 <simpson> A tracing JIT can make things faster at runtime, if you do those things often.
10:40:12 <simpson> It doesn't have to prove things; instead, it can dynamically guard.
10:40:31 <absence> donri: won't all the subcomponents of blockParser have to track as well? (assuming blockParser is non-trivial)
10:40:53 <Philippa> parcs: how do you decide when to inline?
10:41:33 <donri> we need -finline-all-the-things
10:41:33 <Philippa> simpson: yep, and ain't branch prediction wonderful in those situations?
10:41:35 <parcs> oh right jits can help with that
10:41:54 <Philippa> donri: yeah. If nothing else, it'd make people realise what Sufficiently Smart really means
10:42:00 <simpson> Philippa: I'm now tempted to spend my Pycon sprint time adding Haskell to PyPy.
10:42:10 <simpson> I have other things to do, though... Ugh. :T
10:42:24 <Philippa> simpson: yeah. Plus it'd be better to add one of the GHC ILs than Haskell itself, anyway
10:42:56 <absence> donri: i mean, each of the parsers blockParser is composed of would have to return the number of bytes consumed, and they would have to be summed, and so on for their subparsers. it would "infest" all the code
10:43:45 <donri> absence: you might prefer binary for binary parsing
10:44:46 <Philippa> parcs: I suspect JIT can let you get what would otherwise be very hard parser optimisations, for example
10:44:59 <Philippa> (by spotting bits of a language that're well-behaved)
10:45:07 <simpson> Philippa: Hm, maybe. ILs don't carry as much information as full Haskell though.
10:45:29 <Philippa> simpson: they carry it a lot more explicitly. Core is much nicer for a back end to work with than Haskell is
10:45:54 <absence> donri: won't the same problem exist with binary?
10:46:04 <donri> absence: duno :)
10:46:25 <Philippa> you lose some possible stylistic hints, sure. The dictionary-passing transformation nominally loses you some info
10:46:58 <Rogach> Hello! I got a simple question: does (a -> b) have instance of Arrow? There seems to be "arr" function to convert (a -> b) into an arrow, but "&&&" is still able to take unconverted function.
10:47:04 <Philippa> (for those about to ask what info, you no longer have a separate sort for instances so it's harder to analyse whether they behave differently)
10:47:25 <Philippa> Rogach: there is. In this case, arr is id
10:47:39 <parcs> Rogach: arr is simply the identity function
10:47:43 <parcs> oops
10:47:49 <Philippa> (you need it because you might not know which arrow you're working with)
10:47:59 <bourbaki> Is there a Haskell to OpenCL code generator around?
10:48:06 <Rogach> Philippa: Thanks!
10:48:26 <kqr1> what should i do to print doubles with a higher precision than show does?
10:49:22 <parcs> @hoogle showFFloat
10:49:23 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
10:49:42 <parcs> > Numeric.showFFloat (Just 100) (1/9) ""
10:49:44 <lambdabot>   "0.111111111111111100000000000000000000000000000000000000000000000000000000...
10:50:39 <kqr1> okay thanks
10:50:47 <kqr1> it seems as though doubles are more limited than I thought anyway
10:51:10 <parcs> > Numeric.showFFloat (Just 100) (22/7) ""
10:51:12 <lambdabot>   "3.142857142857143000000000000000000000000000000000000000000000000000000000...
10:53:06 <byorgey> kqr1: if you need higher precision, you can use CReal
10:54:24 <kqr1> byorgey, thanks, that's what i was looking for
10:55:35 <mcstar> > Numeric.showFFloat (Just 30) (2 * arcsin 1) ""
10:55:37 <lambdabot>   Not in scope: `arcsin'
10:55:37 <lambdabot>  Perhaps you meant `asin' (imported from Prelude)
10:55:42 <mcstar> > Numeric.showFFloat (Just 30) (2 * asin 1) ""
10:55:44 <lambdabot>   "3.141592653589793000000000000000"
10:55:48 <mcstar> hm
10:56:49 <parcs> > Numeric.showFFloat (Just 100) (22/7 :: CReal) ""
10:56:50 <mcstar> i can never remember the digits of pi beyond the 9th digit
10:56:51 <lambdabot>   "*Exception: CCeal.floatRadix
10:58:20 <kqr1> i can never remember the digits of pi beyong the 28th digit
10:58:34 <kqr1> i can't spell either
10:58:37 <amyers> > pi
10:58:38 <lambdabot>   3.141592653589793
11:01:03 <tdammers> > drop 29 $ show pi
11:01:05 <lambdabot>   ""
11:01:19 <tdammers> > drop 29 $ show (pi :: Double)
11:01:20 <byorgey> > pi :: CReal
11:01:21 <lambdabot>   ""
11:01:21 <lambdabot>   can't find file: L.hs
11:01:58 <dmwit> > length "3.141592653589793238462643383279502884197169399375105"
11:02:00 <lambdabot>   53
11:02:01 <ParahSailin> @hoogle w2c
11:02:01 <lambdabot> No results found
11:02:11 <dmwit> I sometimes have trouble remembering the digits of pi beyond the 52nd digit.
11:02:29 <tdammers> > length
11:02:30 <lambdabot>   No instance for (GHC.Show.Show ([a0] -> GHC.Types.Int))
11:02:30 <lambdabot>    arising from a u...
11:02:33 <tdammers> eh
11:02:43 <tdammers> > length "3.14159"
11:02:45 <lambdabot>   7
11:02:48 <tdammers> wow
11:05:15 <mcstar> i am jelous of those savants with crazy good memory...
11:05:42 <mcstar> on the other hand, i am annoyed by, that they cant really do anything useful with it
11:05:47 <Sculptor> eidetic memory
11:05:51 <parcs> 3.14592653589
11:05:57 <mcstar> 1
11:05:59 <Sculptor> mcstar, just like sheldon
11:06:08 <mcstar> i meant real ppl
11:06:09 <Sculptor> parcs, : 79323846264
11:06:17 <Sculptor> 33832795028841950
11:06:18 <Sculptor> etc
11:06:40 <dmwit> Sculptor: last bit isn't right
11:06:46 <dmwit> 1950 -> 1971
11:06:52 <Sculptor> could be
11:07:19 <Eduard_Munteanu> Idea: memorize pi-with-error-correction-codes
11:07:28 <Sculptor> i calculated it in head. last two digits could be wrong
11:07:58 <mcstar> i just have to use the technique, replace numbers with gnomes, or something, and place them by the road i run, in my imagination
11:08:11 <Ke> error correction has to be easier thanre computation
11:09:16 <mcstar> hm, does the required memory to compute the n+1th digit of pi grow with n?
11:10:04 <mcstar> maybe all these guys do, that can recite Pi is just apply a simple algorithm on the last m digits on pi..
11:10:26 <mcstar> of pi*
11:10:32 <Eduard_Munteanu> Then you'd complain about those crazy human calculators. :P
11:11:21 <mcstar> nah, thats not like me
11:11:21 <Ke> I guess trivial parity is easy enough for a human weaklings
11:11:24 <mcstar> XD
11:11:59 <Heffalump> mcstar: have a look at "spigot algorithms" for pi, but I'm not quite sure if they are constant memory or not.
11:12:24 <Ke> well storing the result is not constant memory
11:12:25 <mcstar> ok
11:12:33 <mcstar> Ke: you dont store it
11:12:40 <mcstar> you just announce the next digit
11:22:07 <ParahSailin> @hoogle ListS
11:22:08 <lambdabot> Graphics.Rendering.OpenGL.GL.DisplayLists callLists :: GLsizei -> DataType -> Ptr a -> IO ()
11:22:08 <lambdabot> Graphics.Rendering.OpenGL.GL.DisplayLists deleteLists :: [DisplayList] -> IO ()
11:22:08 <lambdabot> Control.Parallel.Strategies evalListSplitAt :: Int -> Strategy [a] -> Strategy [a] -> Strategy [a]
11:27:11 <mcstar> let me put forward a little puzzle: there is a non-negative integer coefficient polynomial, of arbitrary order. you have to guess what the coefficients are, by asking the value of the polynomial from me, at at most 2 values of its variable
11:27:32 <elliott> in Haskell?
11:32:05 <mcstar> elliott: or haskell-blah
11:32:11 <Eduard_Munteanu> mcstar: is it a special polynomial, or does it work for any polynomial you pick?
11:32:28 <elliott> mcstar: I mean, is this a Haskell question?
11:32:36 <mcstar> Eduard_Munteanu: "a non-negative integer coefficient polynomial, of arbitrary order"
11:32:49 <mcstar> elliott: no, but if you want to keep it on topic..
11:33:00 * hackagebot posix-acl 0.1.0.0 - Support for Posix ACL  http://hackage.haskell.org/package/posix-acl-0.1.0.0 (NicolaSquartini)
11:34:41 <Eduard_Munteanu> Oh, I have an idea.
11:35:01 <Eduard_Munteanu> But it requires the coefficients to be bounded.
11:35:05 <parcs> > 1 / (0 :+ 1)
11:35:07 <lambdabot>   0.0 :+ (-1.0)
11:35:14 <parcs> nice!
11:35:48 <mcstar> Eduard_Munteanu: hm, i didnt phrase the question, right, you dont have to 'guess', you have to tell me exactly what are the coefficients..
11:35:49 <Eduard_Munteanu> Actually hm, that requires only one value if there's an upper bound. Perhaps I can build on that.
11:36:09 <Eduard_Munteanu> Yeah.
11:36:26 <Ralith> mcstar: there are infinitely many polynomials that will match any given pattern there, no?
11:36:39 <mcstar> i cant say
11:36:47 <Ralith> I'm fairly certain that's the case.
11:36:56 <mcstar> if i think of one such polynomial, you can tell me what the coefficients are
11:37:00 <Eduard_Munteanu> Oh, I know.
11:37:03 <Ralith> if I cared enough I could probably come up with a proof
11:37:12 <mcstar> and i think Eduard_Munteanu has a solution :)
11:37:15 <tromp__> what's the value at e ?
11:37:23 <Ralith> Eduard_Munteanu's solution imposes additional constraints.
11:37:29 <Ralith> thus it's not strictly a solution.
11:37:35 <mcstar> Ralith: you dont know his newest solution
11:37:41 <Ralith> Eduard_Munteanu: am I wrong?
11:38:14 <Eduard_Munteanu> Ralith: I think I got it figured
11:38:29 <Ralith> do tell
11:38:48 <mcstar> Ralith: keep thinking a bit, it will feel good when you figure it out on your won
11:38:54 <Ralith> mcstar: no.
11:39:06 <Ralith> as I said, I don't believe there exists a solution.
11:39:19 <tromp__> and what's the value at 0?
11:39:47 <tromp__> hmm, that doesn't help
11:40:14 <elliott> maybe move this to -blah?
11:45:31 <armlesshobo> i think i finally understand monads.
11:46:05 <srhb> Do parsec parsers exist for Text instead of Strings? Like, say, spaces.
11:46:11 <srhb> It seems there's only a char module for all this.
11:46:45 <monochrom> yes, import Text.Parsec.Text
11:46:49 <srhb> Derp.
11:47:08 <monochrom> the Char module works for Text and generally any Stream m Char
11:47:37 <monochrom> err, Stream m Char t (or Stream m t Char, I forgot the order)
11:48:15 <srhb> What if I wanted my parsers to work for either String or Text? I'd need to jump through some hoops to parameterize things?
11:48:16 <monochrom> see my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#input
11:48:17 <Saizan> Stream s m Char
11:48:33 <Saizan> srhb: things are already parametrized
11:48:39 <srhb> Hum.
11:48:43 <srhb> monochrom: Thanks
11:49:20 <Saizan> 's' is going to be String or Text or something else from which you can get a Char
11:49:43 <monochrom> in Stream s m Char, s could be [Char] or Text. if you write your own instance, it can be anything. I know how to write one for Vector Char
11:50:08 <Saizan> i guess the string parser is the questionable one, since it has String in the output
11:50:23 <srhb> OK, I was getting a type error I assumed was because spaces wanted a String, not Text, so I guess I was just confused
11:50:26 <hpaste> Rob pasted “Data.Binary: "No explicit method nor default method"” at http://hpaste.org/84117
11:51:02 <Philippa> Saizan: huh, yeah, is it time for a 'parsec facelift project'?
11:51:05 <robstewartuk> hello. Any clues as to why I am unable to derive Generic successfully in http://hpaste.org/84117 ?
11:51:14 <Philippa> (who's the current maintainer, anyway?)
11:51:14 <donri> <armlesshobo> i think i finally understand monads. -- most common phrase in #haskell (tightly followed by "i love monoids")
11:51:45 <Saizan> Philippa: i guess that'd be something else you'd want to discuss with edwardk, because of his parsers package
11:52:02 <monochrom> spaces :: Stream s m Char => ParsecT s u m ()  does not insist on String
11:52:28 <srhb> Yeah, all I needed was to import Text.Parsec.Text
11:52:58 <edwardk> @hackage parsec-parsers
11:52:58 <lambdabot> http://hackage.haskell.org/package/parsec-parsers
11:53:58 <Saizan> the parsers API keeps the String there
11:54:03 <Philippa> Saizan: heh. Me talking to edwardk about something actually useful to others?! :p
11:54:10 <Philippa> but good call
11:54:28 <edwardk> i'm not averse to generalizing the types in parsers
11:54:38 <edwardk> in particular if someone wanted to put together a concrete proposal
11:54:52 <edwardk> its kinda nice that parsers is 'near-98' but i'm okay with giving that up
11:56:16 <Philippa> *nod*. So, I can probably get behind doing such a thing this year if someone's willing to cheerload and people're willing to help me collect a list of warts
11:57:06 <edwardk> what is it you want to add to parsec that isn't in, say, parsers?
11:57:09 <croikle> robstewartuk: do you have the right version of Binary? I have 0.5, which doesn't list that GBinary stuff
11:57:18 * robstewartuk looks
11:57:33 <Philippa> edwardk: it might be I just want to propose moving things over :-)
11:58:00 <robstewartuk> binary-0.5.1.0
11:58:09 <Saizan> edwardk: we were discussing ways in which parsec forces you to String, and the only one i found was the string parser
11:58:24 <Saizan> edwardk: i don't even know if that's bad, honestly
11:58:40 <Philippa> I think it's bad now we have overloaded string literals
11:58:49 <edwardk> Saizan: i tend to use slicing rather than have a string parser return bytestring fragments, but thats more a function of knowing how it all gets implemented
11:59:16 <edwardk> overloaded string literals always make me queasy when i have to use them
11:59:28 <edwardk> giving up on > length "foo"   working makes me sad
11:59:35 <Philippa> I cheerfully abuse them for identifiers in terms
11:59:42 <edwardk> me too
11:59:47 <monochrom> I dislike overloaded string literals too
11:59:49 <Saizan> edwardk: yeah, i thought parsers had slicing actually
11:59:53 <edwardk> but every time i turn them on, it breaks doctests everywhere in all my modules
12:00:11 <croikle> robstewartuk: yeah, it looks like the GBinary stuff was added in 0.6.3.0, at least in the help
12:00:17 <robstewartuk> oohh
12:00:18 <Philippa> *nod*. I'm too sloppy a coder to be running into such things
12:00:28 <edwardk> trifecta has slicing, i don't offer it in 'parsers' because i can't do it portably
12:00:32 <Philippa> I mean, realistically I shouldn't be let near a production codebase unsupervised?
12:01:09 <edwardk> Philippa: that is what having multiple copies of the central repository is for ;)
12:01:13 <robstewartuk> where's the release notes?
12:01:24 <robstewartuk> croikle ?
12:01:34 <Philippa> edwardk: right, supervision keeps on getting easier :-)
12:01:37 <elliott> edwardk: it's surprising we don't have defaulting for strings
12:01:52 <elliott> though I guess you might as well implement defaulting for arbitrary typeclasses if you go that far
12:02:00 <Philippa> elliott: in the Least Surprise sense, I agree
12:02:10 <Philippa> right. It's easy to smell the hysterical raisins there
12:02:11 <edwardk> elliott: we do, but it isn't string being defaulted there basically its Char.
12:02:25 <elliott> edwardk: well, right
12:02:36 <elliott> is it instance IsString String and not instance c ~ Char => IsString [c]?
12:02:40 <elliott> former smells like a bug to me
12:02:47 <edwardk> elliott: yeah i've wanted the latter for a while
12:02:57 <edwardk> if someone else proposed it to libraries i'd back it wholeheartedly =P
12:03:01 <Philippa> former is more portable, but yes
12:03:08 <robstewartuk> croikle: however, it all now works nicely, thank you.
12:03:10 <elliott> Philippa: well, OverloadedStrings isn't portable :)
12:03:16 <edwardk> the former still relies on FlexibleInstances
12:03:19 * elliott imagines defaulting for arbitrary constraints...
12:03:36 <edwardk> and OverloadedStrings isn't exactly something every other compiler implementor has beaten down the door to implement
12:03:42 <Philippa> elliott: welcome to my world :p
12:04:25 <elliott> Philippa: it's ok, I am protected by the layer of hypotheticality
12:04:26 <Saizan> if you think ~ is weird to require you could add an IsChar class with defaulting there
12:04:38 <Philippa> (ironically? That's probably not so hard to implement so long as you don't mind it being an impossible-to-debug clusterfuck)
12:04:44 <davorak> Cin: I may not have the right handle you rcently put up ircbrowse right?  Would you be willing to add the #nixos logs to your web site as well? If not I can set one up for my personal use. By the way thanks for making it open source.
12:04:46 <srhb> Am I also supposed to preserve the Text type when using char 'a' ?
12:04:46 <edwardk> elliott: i really just want nicer ExtendedDefaultingRules. e.g. if there was just a class for 'Defaultable' (and if the dispatch for those constraints was smarter about chasing super-class dependencies) then a lot more stuff could work
12:04:57 <Philippa> (each default clause becomes a new, lowest-priority CHR)
12:05:14 <edwardk> right now to 'trick' defaulting into running i have to throw in crap unused Show instances for all sorts of things, and add an unused Show constraint
12:05:19 <Philippa> edwardk: *nod*
12:05:27 <elliott> edwardk: it seems like the really basic case of "default SingleParamTypeClass (A,B,C)" where that gets exported if you're the module that defines the class would be easy to do, at least
12:05:35 <edwardk> because it is the least offensive 'EDR-triggering' single parameter type class
12:05:39 <Philippa> "if we're going to have type-level prolog, can we at least think like prolog programmers?"
12:05:41 <croikle> robstewartuk: I just looked at different versions on hackage. http://hackage.haskell.org/package/binary
12:06:06 <edwardk> well, we still don't have (and shouldn't have) backtracking
12:06:12 <hpaste> duairc_ pasted “RankNTypes in type family instance” at http://hpaste.org/84119
12:06:35 <Philippa> I disagree on the latter, but I suspect you consider how I'd do it almost as appalling as just implementing backtracking
12:06:46 <edwardk> duairc_: sadly that doesn't and can't work for technical reasons
12:07:07 <edwardk> duairc_: spj summarized the problem at one point about not knowing where to instantiate the forall with a few examples
12:07:42 <edwardk> well, i care about confluence of typeclass resolution and separate compilation a lot.
12:07:55 <Philippa> *nod*
12:08:09 <edwardk> having used scala where these things are but fond memories i'll fight tooth and nail to keep them here ;)
12:08:20 <Philippa> so my approach would involve closed constraints and what amounts to explicit choice points?
12:08:52 <elliott> why is there no funArray :: (i,i) -> (i -> e) -> a i e in Data.Array?!
12:08:59 <elliott> I find myself wanting it basically every time...
12:09:00 <edwardk> closed constraints are fine, and you can backtrack in them all you want, but they are boring and closed ;)
12:09:12 <Philippa> (and to be fair, I gather that's how people tend to hack it? Just, you pull dirty tricks to close that fuck readability)
12:09:14 <duairc_> edwardk: That is very sad. Was this in a mailing list somewhere that spj said this? Do you have a link?
12:09:40 <Philippa> heh. They may be boring, but they make some pretty useful things sensible at least
12:09:56 <Philippa> shit, has anyone ever put together a moderately solid proposal for such a thing?
12:10:01 <edwardk> duairc_: i did a quick search and wasn't able to dig it up. it was a mailing list post iirc, at least i can't find it in an email from him to me at least if that helps narrow it down ;)
12:10:29 <Heffalump> duairc_/edwardk: isn't it a simple impredicativity issue?
12:10:36 <edwardk> Philippa: Richard Eisenberg has been working on a bunch of ordered type family stuff
12:10:46 <Heffalump> presumably a newtype would be fine
12:11:09 <edwardk> Philippa: in many ways that at least addresses the closed universe problem
12:11:21 <Philippa> *nod*
12:11:44 <Philippa> *sigh*. Should I try writing up the obvious-and-stupid way to do it?
12:11:48 <duairc_> Heffalump: A newtype does work, but unfortunately it's no good for what I really want to do
12:11:50 <edwardk> Heffalump: it is, but i found the pair of examples compelling, just can't find them ;)
12:13:23 <hpaste> duairc_ pasted “RankNTypes in type family instance” at http://hpaste.org/84120
12:16:27 <Heffalump> duairc_: because you want Homo m n to always appear to be a function?
12:16:43 <duairc_> Heffalump: Yeah, exactly.
12:17:28 <Heffalump> operationally that strikes me as hard to implement
12:17:50 <Heffalump> though maybe nothing is ever passed at runtime for the 'forall'
12:18:00 <Heffalump> could you live with an 'apply' function?
12:18:22 <Heffalump> i.e. apply :: Homo m n -> m -> n
12:18:28 <clahey> Does anyone here know libsigc++?
12:18:49 <clahey> (I know I'm asking in #haskell, and that's cause I'm looking for someone who knows both.)
12:19:08 <Heffalump> actually, i don't understand how you can use Homo. I didn't realise you could write case analyses on kinds like that :-)
12:19:29 <duairc_> Heffalump: :)
12:19:43 <duairc_> Yeah, if there was an apply function, I don't think that's the type that it would have
12:20:04 <clahey> @pl f p a b = \x -> if p x then a else b
12:20:04 <lambdabot> f = (flip .) . flip . (if' .)
12:20:17 <Heffalump> in any case, Homo would only ever be a function for specific instantiations
12:20:38 <Heffalump> you couldn't write something that was kind-polymorphic
12:22:04 <duairc_> Well I mean you can write "type Homo a b = a -> b" and "type Homo m n = forall a. m a -> n a", and so on, I just wondered if you could automatically generalise that pattern for all kinds
12:22:34 <duairc_> (well, all kinds that "end" in * anyway)
12:22:43 <elliott> duairc_: the second "Homo" there is a natural transformation
12:23:07 <elliott> higher than that you just get natural transformations on bifunctors etc. :P
12:23:22 <elliott> I guess the first one is technically a natural transformation too
12:51:07 * chrisdone slaps everyone with a large trout
12:53:01 * hackagebot views 1.0 - Views allow you to run a State monad on part of a state.  http://hackage.haskell.org/package/views-1.0 (MarcCoiffier)
12:57:18 <davorak> chrisdone:  Would you be willing to add the #nixos logs to ircbrowse as well? If not I can set one up for my personal use. By the way thanks for making it open source.
13:08:01 * hackagebot uu-parsinglib 2.7.4.3 - Fast, online, error-correcting, monadic, applicative, merging, permuting, idiomatic parser combinators.  http://hackage.haskell.org/package/uu-parsinglib-2.7.4.3 (DoaitseSwierstra)
13:14:49 <slack1256> does collecting the young generation (on the garbage collection) stop the world?
13:15:03 <slack1256> I've never experienced any stop with it, so It would be surprising.
13:17:22 <thoughtpolice> yes, it does. the mutator is stopped, and GC for the minor collection is done in parallel on multiple threads. the old generation requires a full stop as well, and isn't parallel in its collection IIRC
13:17:58 <thoughtpolice> there was some work to make is so the young generation was per core (like it is now,) but to also do GC for young-gen concurrently on multiple cores. old generation collections would still require a global stop
13:18:38 <thoughtpolice> in practice the benefit was something on the order of 15% performance increase, but with a massive amount of complexity added. it hasn't been merged as a result
13:21:13 <slack1256> Mmm I think I understand.
13:21:33 <slack1256> thanks thoughtpolice
13:41:56 <chrisdone> davorak: yeah
13:42:52 <chrisdone> davorak: need a way to get access to the logs. is there already a channel log online and is the channel supportive of public logs?
13:43:16 <davorak> chrisdone: yeah I will get the link one moment.
13:44:23 <davorak> chrisdone: The log history is currently at nixos.org/irc/logs
13:45:40 <davorak> thanks
13:46:11 <chrisdone> davorak: how often are these updated?
13:46:39 <chrisdone> it looks like once a day and the most recent log is updated in real time -- right?
13:48:19 <davorak> looks like not quite real time but close.
13:49:49 <chrisdone> davorak: format looks like i'll have to write a custom parser for it. looks like the time zone is UTC, that's ok
13:50:50 <chrisdone> yeah. leave it with me
13:51:27 <davorak> Cool thanks again.
14:00:26 <eacameron> to sing among the choir of "record syntax improvements" I wish it were Foo {a :: Int, b :: Int} accessed with Foo.a and Foo.b (or some other delimiter besides .)
14:02:17 <Philippa> eacameron: you can write the delimiter yourself, at least. It's flip ($)
14:02:48 <eacameron> Philippa: really? I've never tried that
14:03:58 <eacameron> Philippa: I mean instead of generating "a" and "b" functions, I would prefer generating "Foo.a" and "Foo.b"
14:04:26 <Philippa> as opposed to foo where foo is some application of Foo? Huh
14:06:15 <armlesshobo> i think i understand monads now.
14:08:04 * hackagebot hs-GeoIP 0.3 - Haskell bindings to the MaxMind GeoIPCity database via the C library  http://hackage.haskell.org/package/hs-GeoIP-0.3 (OzgunAtaman)
14:10:26 <alkabetz> ecacameron: I think you want Control.Lens
14:10:33 <alkabetz> er, eacameron
14:23:53 <no-n> anybody know any good articles comparing haskell and scheme?
14:24:57 <chrisdone> they're chalk and cheese
14:25:07 <tdammers> which one is cheese?
14:25:32 <chrisdone> my english supports bottom so they're defined in terms of eachother
14:25:43 <luite> \o/ \o/ chrisdone
14:25:56 <chrisdone> luite!!!
14:26:04 <no-n> I think I want to learn both :3
14:26:04 <chrisdone> are you coming to odhac?
14:26:14 <luite> chrisdone: are you going? wanted to ask you the same
14:26:27 <chrisdone> luite: yeah i'm going to book it this weekend
14:26:48 <luite> oh cool, i was thinking of going, but not sure yet, connection is not great and flight not terribly cheap
14:26:48 <chrisdone> wasn't sure about accommodation yet =o
14:26:59 <shachaf> chrisdone: Is there a broken JavaScript link on hpaste.org?
14:27:07 <chrisdone> luite: connection?
14:27:14 <chrisdone> shachaf: i'll check =]
14:27:18 <luite> chrisdone: well, no direct flight
14:28:18 <chrisdone> luite: gotcha
14:28:33 <luite> chrisdone: do you have big plans for fay at odhac?
14:31:30 <luite> chrisdone: i'm preparing some big commits to push now for ghcjs, with threading, mvars, async exceptions, black holes all implemented. async incremental file loading from the interwebs coming next
14:31:46 <chrisdone> luite: here's what i wrote up for fay http://www.haskell.org/haskellwiki/OdHac/Projects#Fay
14:32:09 <chrisdone> luite: maybe we could combine forces and make it a "haskell→js"-athon
14:32:48 <luite> yeah certainly some foreign lib binding stuff could benefit both
14:33:05 <luite> and i'm stealing all your testcases anyway ;p
14:33:42 <chrisdone> there's always the case in which we abandon fay and migrate to ghcjs, so it will be good to evaluate that
14:33:53 <mcstar> "Write some web apps with Fay. Consider this part of the ‘Getting Shit Done’ mantra."
14:34:21 <luite> chrisdone: i'm not sure it's ready enough because of code heaviness, but most of the functionality is now implemented in the new code generator
14:34:26 <luite> STM is still missing
14:34:35 <luite> but i'm quite happy about the preemptive threading support :)
14:34:45 <chrisdone> mcstar: yeah, you got a problem with getting shit done? =p
14:35:02 <mcstar> sir, no sir!
14:35:19 <chrisdone> luite: hmm yeah it's cool. what's the performance and debugging like tho? many people i've spoken to have been concerned about the re-implementing threads in ghcjs approach
14:35:39 <chrisdone> mcstar: are you coming to odhac?
14:36:38 <luite> chrisdone: performance overhead over non-threaded code is quite low. it also works nicely with other javascript since the haskell thread scheduler yields back to the system (and suspends itself when there is no work)
14:37:02 <chrisdone> but yeah my focus is *PRODUCE THINGS*. i demand lots of haskell web apps
14:37:23 <mcstar> chrisdone: noo, but i am sort of close
14:37:24 <chrisdone> luite: hmm okay i can see why that yielding might be nice
14:37:41 <chrisdone> mcstar: hungary? why aren't you coming?
14:37:51 <mcstar> im a beginner?
14:38:01 <luite> chrisdone: debugging is perhaps harder, no stack traces, but you can implement call tracing, so you still get the last n calls (and then a short stack trace for the real exception)
14:38:04 <chrisdone> beginner shminner
14:38:16 <chrisdone> mcstar: hackathons are a great way to learn!
14:38:17 <luite> implement -> enable
14:38:23 <luite> it's already in there
14:39:02 <luite> chrisdone: also function arguments are passed through global vars, which can be a bit annoying
14:39:50 <luite> and the whole tailcall optimization makes things a bit harder. nontailcalls push a stack frame on a manually managed stack
14:40:00 <chrisdone> luite: i suspect the simplicity of fay is why people are using it. but maybe we can alleviate ghcjs fear by good 'this is what's going on' tooling
14:40:38 <luite> chrisdone: sure, ghcjs is far from simple, but "easy to use" might be enough for most users :)
14:40:40 <chrisdone> technically i don't have backtraces in *normal* ghc and i don't care! so… *i'm* personally ok without backtraces
14:40:46 <luite> right
14:41:18 <luite> and you can debug your code in ghci, if it works there and not in ghcjs, then it's probably a bug
14:41:38 <luite> there are a few wacky things that are unsupported
14:41:47 <luite> converting pointers to ints
14:42:38 <chrisdone> luite: i guess you can have a set of 'totally safe and not weird' packages?
14:42:46 <luite> one problem (?) is that the standard handle based IO is very heavy, it makes an ArrayBuffer, then the base package encodes any text output to UTF-8 (the locale encoding) in that array
14:42:51 <luite> to print it, javascript decodes it back
14:42:57 <chrisdone> (people are somehow ok with fay having zero modules to start with apart from Prelude)
14:43:08 <chrisdone> oh yeah i forgot about that
14:43:17 <chrisdone> where would you do IO tho?
14:43:17 <luite> it works well (and performs reasonably ok), but it would be nice to make an alternative
14:43:32 <chrisdone> if i'm, e.g. manipulating the DOM or making an AJAX call -- what's happening under the hood?
14:43:37 <luite> the ghc testsuite uses print for results
14:43:43 <luite> and nofib benchmark suite too
14:43:46 <donri> chrisdone: i think fay is used differently from how i imagine using ghcjs, though
14:43:48 <luite> nofib also requires getArgs to work
14:44:01 <luite> which does work, in node.js and spidermonkey jsshell!
14:44:16 <luite> so i imported half of nofib this week in the test suite
14:44:21 <donri> being able to use existing libraries is like half the point of ghcjs
14:44:25 <luite> right
14:44:52 <chrisdone> mm but other points are (1) full haskell incl. type-classes (2) speed (3) probably reasonable compression
14:45:12 <donri> well (1) is kinda the same point :)
14:45:13 <luite> hehe hopefully
14:45:18 <luite> (compression)
14:45:21 <luite> code is huge atm
14:45:47 <chrisdone> even after closure?
14:45:50 <luite> many things can probably be done in much shorter code, calling short functions that the js engine inlines, instead of inlining everything
14:46:14 <luite> chrisdone: haven't tested advanced optimization, but i think it would still be pretty big
14:46:58 <luite> one reason is that code is longer than it needs to be, but also much of the base library is included in very simple programs
14:47:08 <luite> because of dependencies on exception handling
14:47:12 <luite> which pulls in a lot more
14:47:23 <chrisdone> shachaf: ok, removed the reference to that .js file
14:47:47 <chrisdone> luite: mm ok
14:47:49 <shachaf> chrisdone: Oh, I thought that's what was causing the JavaScript to be broken.
14:47:50 <luite> i think that perhaps with the splittage of the base package we might improve on this a lot
14:48:36 <shachaf> Maybe you just changed it.
14:48:54 <chrisdone> shachaf: no, i mean that was the problem, so i removed the reference, now it's ok
14:49:03 <chrisdone> ヽ (＾▽＾) ﾉ
14:49:14 <chrisdone> luite: so are you gonna come to odhac?
14:50:00 <chrisdone> donri: are you coming to odhac?
14:50:21 <donri> probably not! when and where is that?
14:50:33 <luite> chrisdone: dependencies for the rts and base package are JSBN, google closure library (md5, long, queue, heap), a typedarray shim (for DataView in older browsers), harmony-collections shim (for WeakMap, Map), and all the code written for ghcjs itself, currently about 2200 lines)
14:50:41 <shachaf> chrisdone: Yes, but I thought that was breaking other things.
14:50:46 <shachaf> But maybe those other things are on purpose.
14:51:26 <chrisdone> mcstar: seriously you should come. it's a great way to remove friction from your development process. i helped a guy who'd been reading LYAH for one week write a multithreaded socket server in a couple days. the help he needed was with the tools, not the language
14:51:31 <luite> chrisdone: don't know yet, but it would be fun i think :)
14:51:46 <chrisdone> shachaf: what other things were breaking?
14:51:55 <chrisdone> donri: http://www.haskell.org/haskellwiki/OdHac/Projects
14:52:19 <chrisdone> luite: haha yeah that's a metric snorlax tonne of dependencies
14:52:55 <mcstar> chrisdone: im going to make myself more familiar with the advanced aspects of the typesystem, also im interested in logic, thats where i got next, also, i dont have that much free time in this semester, i plan to finish university at last, but thanks :)
14:53:08 <mcstar> got->go
14:53:23 <chrisdone> mcstar: next time then =)
14:53:26 <luite> chrisdone: unminified it's about 380kB combined, i think it would be ~60kB after minify and gzip
14:53:33 <luite> perhaps less
14:53:47 <chrisdone> luite: ah that's okay
14:53:54 <chrisdone> ≖‿≖ not bad
14:54:55 <shachaf> chrisdone: E.g. it's taking up the entire page now, rather than being narrow, and the hlint warnings are fully expanded.
14:55:01 <shachaf> Maybe that's on purpose. Who knows.
14:55:41 <luite> chrisdone: hehe, but far from the situation where the minified code fits on one page, like you showed a few times for fay :)
14:56:26 <chrisdone> shachaf: ah, yeah, that was intentional. the simplest way to do that was just remove the script file rule. thanks for noticing, though
14:56:47 * shachaf is not sure this is an improvement, but doesn't really care.
14:57:36 <chrisdone> luite: you mean LIKE THIS? （ｖ＾＿＾）/ https://github.com/faylang/fay/wiki/Reducing-output-size#final-output
14:58:01 <luite> yeah, i'm jealous :p
14:59:09 <luite> hm i just realized that i'm doing async exceptions a bit wrong
14:59:25 <chrisdone> shachaf: which part? the page width or the expanding? i think the expanding can probably be kept. the width i'm indifferent about. i can set it with css. it was resized with js and i didn't like how one could see it resizing on page load
15:00:02 <shachaf> I don't care to care about it.
15:00:12 <shachaf> Maybe someone else here will.
15:00:30 <chrisdone> (゜。゜)
15:02:54 <chrisdone> donri: so are you coming to odhac?
15:03:14 <donri> chrisdone: that'd be unlikely!
15:03:28 <chrisdone> donri: ma perchè?
15:03:34 <chrisdone> jaspervdj: are you coming to odhac?
15:03:42 <chrisdone> in fact: who's *not* coming to odhac?
15:03:53 <luite> hehe
15:03:54 <chrisdone> all europeans: represent
15:05:22 <aristid> represent!
15:05:32 <chrisdone> aristid: are you coming?
15:05:44 <aristid> chrisdone: when is it again? :/
15:05:47 <chrisdone> may
15:05:54 <chrisdone> When:	Friday, May 3rd – Sunday, May 5th, 2013
15:05:54 <aristid> mmm
15:05:54 <chrisdone> Hours:	9am ~ 8pm
15:05:54 <chrisdone> Where:	Odessa, Ukraine
15:06:42 <chrisdone> announcement and register link: http://www.haskell.org/pipermail/haskell-cafe/2013-February/106216.html
15:06:55 <aristid> chrisdone: i'd have to take days off work for that, and i'm not sure if i'm prepared to do that :P
15:07:36 <luite> chrisdone: btw was it the threading that people were worried about, for ghcjs? or the cps transformation required for threading (but also for not blowing the js stack in many instances)
15:09:07 <chrisdone> luite: mm i think it's just general FUD that it's one more level away from js that can break and leave someone waiting on your support for their product
15:09:33 <aristid> chrisdone: holy shit, odessa is really far east :P
15:09:33 <chrisdone> aristid :(
15:10:47 * aristid wonders if he would need a visa to get into ukraine :D
15:10:59 <chrisdone> apparently it's easy if you're from the eu
15:11:14 <chrisdone> http://www.haskell.org/haskellwiki/OdHac#Visa_information
15:11:19 * aristid likes his eu passport.
15:12:00 <chrisdone> i'm british so i can stay for 90 days
15:12:06 <aristid> same for germany
15:12:20 <chrisdone> \o/
15:14:41 <aristid> chrisdone: how much do you pay for the flight?
15:15:23 <croikle> 90 day hackathon wow :)
15:15:42 <chrisdone> croikle: that's how i roll =p
15:15:50 <chrisdone> aristid: i'm checking now
15:15:53 <aristid> everything for the haskells
15:17:44 <chrisdone> all the haskells!
15:18:11 <mcstar> do you guys pay in currency?
15:18:43 <mcstar> that didnt come out as funny as i hoped
15:18:56 <mcstar> curryncy?
15:19:07 <aristid> mcstar: i still don't get it :/
15:19:28 <mcstar> haskellers pay in curryncy, dont they?
15:19:34 <aristid> ooh.
15:19:40 <mcstar> yeah, sry..
15:19:41 <ciaranm> I SEE WHAT YOU DID THERE
15:20:23 <adnap> :t Prelude.foldl (Data.Map.delete)
15:20:25 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = M.Map a0 a1
15:20:25 <lambdabot>     Expected type: a0 -> M.Map a0 a1 -> a0
15:20:25 <lambdabot>       Actual type: a0 -> M.Map a0 a1 -> M.Map a0 a1
15:20:26 <chrisdone> (    ￣__￣） i see it too
15:20:31 <adnap> Why is this happening?
15:20:33 <arkeet> :t delete
15:20:34 <lambdabot> Eq a => a -> [a] -> [a]
15:20:38 <arkeet> :t Data.Map.delete
15:20:40 <lambdabot> Ord k => k -> M.Map k a -> M.Map k a
15:20:46 <chrisdone> :t foldl
15:20:48 <lambdabot> (a -> b -> a) -> a -> [b] -> a
15:20:51 <arkeet> ^
15:20:55 <adnap> Oh
15:21:01 <adnap> :t Prelude.foldl (flip Data.Map.delete)
15:21:03 <lambdabot> Ord b => M.Map b a -> [b] -> M.Map b a
15:21:24 <chrisdone> ≖‿≖
15:21:40 <arkeet> please don't use foldl
15:21:57 <arkeet> foldl' is better.
15:22:05 <adnap> Someone always says "don't use foldx" and I always forget what x is
15:22:21 <luite> chrisdone: i'll gladly sell them priority support ;p
15:22:27 <arkeet> adnap: well, x never changes.
15:22:46 <adnap> arkeet: That's not the problem. It's that there are two possibilities for x
15:22:58 <chrisdone> aristid: i can get flights for 350. what about you?
15:22:59 <arkeet> well, foldr doesn't have a replacement.
15:23:15 <adnap> is foldl' lazy?
15:23:20 <arkeet> no
15:23:25 <arkeet> which is precisely the point
15:23:26 <mcstar> there is no chrisdone pounds?
15:23:27 <arkeet> foldl is too lazy
15:23:33 <mcstar> ...
15:23:35 <luite> i'll let aristid find the cheap flights
15:23:40 <mcstar> sry, the buffer wasnt empty
15:23:41 <adnap> chrisdone: Is your last name Done?
15:23:44 <aristid> chrisdone: yes seems like that would be about right
15:23:46 <mcstar> chrisdone: in punds?
15:23:52 <mcstar> pounds
15:24:00 <aristid> luite: :P
15:24:00 <chrisdone> adnap: yeah. YOU GOT A PROBLEM WITH THAT?
15:24:20 <chrisdone> ლ(ಠ益ಠლ)
15:24:24 <adnap> chrisdone: No. Are you done, Chris?
15:24:30 <chrisdone> mcstar: in euro
15:24:42 <chrisdone> adnap: are you napping, ad?
15:24:49 <adnap> chrisdone: Obviously not!
15:24:57 <mcstar> chrisdone: thats quite expensive....
15:24:59 <chrisdone> could be. you're dreaming of me ^_^
15:25:04 <aristid> luite: schiphol is AMS, right?:)
15:25:08 <adnap> I guess I could be sleep-IRC'ing
15:25:12 <luite> aristid: yes
15:25:51 <chrisdone> mcstar: it's not cheap
15:26:05 <luite> chrisdone: i'm thinking of writing a paper to submit to ICFP about ghcjs, but it's all rather practical and non-researchy stuff, dunno if they like that kind of things
15:26:07 <chrisdone> who's writing a haskell app at the moment?
15:26:24 <chrisdone> luite: did you do any innovation? =p
15:26:29 <luite> chrisdone: no
15:26:32 <luite> :p
15:26:40 <chrisdone> luite: get out and take your paper with you!
15:26:46 <chrisdone> :p
15:27:25 <chrisdone> i think there *has* been some practical things submitted before right?
15:27:25 <luite> there are no proofs of type systems etc in it
15:27:25 <mcstar> chrisdone: it would be the same for me, from budapest, wtf o.O
15:27:30 <adnap> (@益@ .:;)ﾉｼ
15:27:34 <chrisdone> like i saw a haskelldb paper which was basically 'we took the normal haskelldb concept which was done in hugs and just re-did it in ghc with a hlist style record thing'
15:27:42 <mcstar> so, ive got another reason not to attend :)
15:27:42 <luite> mcstar: did i meet you in budapest?
15:27:48 <chrisdone> mcstar: i'm in italy
15:28:05 <mcstar> luite: i dont think you did? what do you mean?
15:28:13 <luite> :)
15:28:44 <chrisdone> luite's namedropping that he went to budapest =p
15:28:50 <luite> hehe
15:28:54 <aristid> apparently odessa has more people than amsterdam.
15:29:01 <luite> chrisdone: nah i went to a small haskell meetup there
15:29:05 <chrisdone> oh, did i happen to meet you during my world tour of everything?  ヘ(^_^ヘ)
15:29:12 <aristid> and i didn't even know it's in ukraine before i heard about odhac
15:29:18 <chrisdone> luite: i think i saw the pics, right?
15:29:22 <luite> dunno
15:29:29 <aCube> Are there polymorphic type families in haskell? like type instance F A = b -> can be anything
15:29:33 <mcstar> aristid: nah, amsterdam is not in ukrain
15:29:46 <aristid> mcstar: yes it is! all the people talk weird there.
15:29:56 <Koterpillar> In the rain or in the UK?
15:30:06 <chrisdone> aristid: they talk in Foreign don't they?
15:30:14 <aristid> chrisdone: Foreign Pointer, yes
15:30:16 <mcstar> ForeignPtr
15:30:19 <sproingie> the rain in ukraine falls mostly on ukraine
15:30:26 <chrisdone> lol
15:30:47 <mcstar> and they say, nerds are no fun...
15:31:20 <Koterpillar> I realized I've implemented a lens library. I want to replace it with some that
15:31:27 <Koterpillar> (sorry, Enter)
15:31:46 <Koterpillar> ...I want to replace it with some that's already there, but how come none of them have a lens for lists?
15:31:47 <aristid> Koterpillar: 'lens' is the best lens library.
15:31:58 <aristid> Koterpillar: and 'lens' does have lenses for lists.
15:32:20 <Koterpillar> aristid, my searching fails me... where is that list lens?
15:32:21 <arkeet> they're just a bit hard to find.
15:32:26 <arkeet> > "abcd" ^? ix 3
15:32:27 <Taneb> > "hello" ^. ix 3
15:32:28 <lambdabot>   can't find file: L.hs
15:32:29 <lambdabot>   Just 'd'
15:32:33 <aristid> @hackage lens
15:32:33 <arkeet> > "abcd" ^? ix 5
15:32:33 <lambdabot> http://hackage.haskell.org/package/lens
15:32:35 <lambdabot>   Nothing
15:32:52 <arkeet> > "abcd" ^? _head
15:32:52 <mcstar> wait.... wth
15:32:54 <lambdabot>   Just 'a'
15:33:14 <mcstar> i hope lenses cant do what my super collection library im hoping to construct?
15:33:14 <arkeet> > "abcd" & _head %~ toUpper
15:33:17 <lambdabot>   "Abcd"
15:33:22 <aristid> Koterpillar: well, i suppose these prisms are not precisely what you want: http://hackage.haskell.org/packages/archive/lens/3.8.7.3/doc/html/Data-List-Lens.html
15:33:31 <aristid> mcstar: i fear you might be disappointed
15:33:34 <Taneb> > "hello" & traverse %~ toUpper
15:33:36 <lambdabot>   "HELLO"
15:33:45 <Koterpillar> Oh. I have no idea why I'm looking at lens-1.2...
15:34:28 <aristid> :t traverse
15:34:29 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
15:34:41 <mcstar> aristid: i wanted an approach to collections, that behave like functions, to which you provide the operation with possible data as parameters, (to the operation) and encode the supported interface of the colleciton in the types
15:34:53 <Taneb> The best thing about traverse is that it's defined in base
15:36:37 <Koterpillar> Ha, that gets me almost all the way there... they're all wrapping stuff in Just though
15:37:07 <mcstar> aristid: does that sounds like something lens does?
15:37:11 <aristid> :t (^?!)
15:37:12 <aCube> Koterpillar:
15:37:13 <lambdabot> s -> Getting (Endo a) s t a b -> a
15:37:23 <aCube> > [1,2,3] ^?! ix 1
15:37:24 <lambdabot>   2
15:37:28 <aristid> > "abcd" ^?! _head
15:37:30 <lambdabot>   'a'
15:37:45 <Taneb> > "foo" ^?! ignored
15:37:47 <lambdabot>   *Exception: (^?!): empty Fold
15:37:54 <Taneb> ^?! can go wrong sometimes
15:38:02 <Taneb> > 1 & id +~ 3
15:38:04 <lambdabot>   4
15:38:10 <Taneb> The thing about lens is,
15:38:13 <Taneb> id is a lens
15:38:17 <Taneb> That's Prelude's id
15:38:28 <Koterpillar> "abcd" ^?! id
15:38:37 <Koterpillar> > "abcd" ^?! id
15:38:38 <lambdabot>   "abcd"
15:38:43 <Koterpillar> > "abcd" ^? id
15:38:44 <lambdabot>   Just "abcd"
15:39:00 <Taneb> > "abcd" ^. id
15:39:02 <lambdabot>   "abcd"
15:39:16 <Koterpillar> > [1,2,3] ^. ix 1
15:39:16 <Taneb> Also there's a crapton of operators but you soon figure them out
15:39:17 <lambdabot>   Ambiguous type variable `a0' in the constraints:
15:39:17 <lambdabot>    (GHC.Num.Num a0)
15:39:17 <lambdabot>      a...
15:39:23 <donri> > "abcd" & upon (!!2).mapped %~ toUpper
15:39:24 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
15:39:24 <lambdabot>              with actual type...
15:39:26 <donri> :(
15:39:31 <Koterpillar> :(
15:39:49 <donri> > "abcd" & upon (!!2) %~ toUpper
15:39:51 <lambdabot>   "abCd"
15:40:18 <Taneb> Koterpillar, that failed because it's trying to find something that's a Num and a Monoid
15:40:21 <Taneb> Weird, huh?
15:40:30 <Taneb> > [Sum 1, Sum 2, Sum 3] ^. ix 1
15:40:32 <lambdabot>   Sum {getSum = 2}
15:40:36 <Taneb> > [Sum 1, Sum 2, Sum 3] ^. ix 5
15:40:38 <lambdabot>   Sum {getSum = 0}
15:40:41 <donri> > "abcd" & indices odd %~ toUpper
15:40:42 <lambdabot>   Ambiguous occurrence `indices'
15:40:42 <lambdabot>  It could refer to either `GHC.Arr.indices',...
15:41:01 <donri> @more
15:41:19 <Taneb> > "abcd" & Control.Lens.indices odd %~ toUpper
15:41:21 <lambdabot>   Not in scope: `Control.Lens.indices'
15:41:25 <Koterpillar> Oh! Then I don't want it.
15:41:52 <Taneb> Koterpillar, that's because "ix n" isn't per se a lens
15:41:55 <Taneb> But a traversal
15:42:01 <donri> > "abcd" & Lens.indices odd %~ toUpper
15:42:03 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]
15:42:03 <lambdabot>                             ...
15:42:07 <Taneb> Which is like a lens but weaker, and can fail or get multiple results
15:42:11 <Sgeo> Is this legal?
15:42:19 <Sgeo> import qualified Foo.Bar as Baz.Blah
15:43:03 <Taneb> Sgeo, GHC allows it
15:43:07 <mcstar>  /everyone's checking in ghci
15:44:00 <Taneb> Works in Hugs too
15:46:05 <shachaf> Checking in ghci won't tell you whether it's legal Haskell.
15:46:07 <shachaf> (It is.)
15:46:27 <aCube> Are there polymorphic type families in haskell? like type instance F A = b -> can be anything
15:46:35 <mcstar> it tells if its legal ghc-haskell
15:49:00 <otters> :t (^. ix 3)
15:49:01 <lambdabot> (Num (Index t), Ixed (Accessor (IxValue t)) t) => t -> IxValue t
15:49:32 <otters> :t ix
15:49:33 <lambdabot> (Indexable (Index m) p, Ixed f m) => Index m -> p (IxValue m) (f (IxValue m)) -> m -> f m
15:49:41 <Taneb> :t ix 3 . both . to Sum
15:49:42 <lambdabot> (Num (Index m), Applicative f, Gettable f, Ixed f m, IxValue m ~ (b, b)) => (Sum b -> f (Sum b)) -> m -> f m
15:50:00 <Taneb> > [(1, 2), (4, 5), (6, 7)] ^. ix 3 . both . to Sum
15:50:02 <lambdabot>   Sum {getSum = 0}
15:50:08 <Taneb> > [(1, 2), (4, 5), (6, 7)] ^. ix 2 . both . to Sum
15:50:11 <lambdabot>   Sum {getSum = 13}
15:51:13 <Taneb> > [(1, 2), (4, 5), (6, 7)] ^. ix 2 . both . to (Sum . negate)
15:51:16 <lambdabot>   Sum {getSum = -13}
15:51:29 <Taneb> > [(1, 2), (4, 5), (6, 7)] ^. traverse . both . to Sum
15:51:31 <lambdabot>   Sum {getSum = 25}
15:51:54 <chrisdone> who's making an app in haskel right now!? ヽ (＾▽＾) ﾉ
15:52:35 <otters> :t to
15:52:35 <lambdabot> (Conjoined p, Gettable f) => (s -> a) -> p a (f a) -> p s (f s)
15:52:50 <otters> what does that do
15:52:50 <Koterpillar> chrisdone, I am
15:52:50 <chrisdone> Koterpillar: what's your app?
15:52:56 <Koterpillar> https://github.com/koterpillar/labyrinth
15:52:58 <ParahSailin> @let (＾▽＾= undefined
15:52:58 <lambdabot>   Parse error: ;
15:53:21 <Koterpillar> I hope you don't mean something different by "app"
15:53:29 <Taneb> Sgeo, it also works on UHC
15:53:33 <otters> @let (＾▽＾) = undefined
15:53:34 <lambdabot>  <local>:9:1:
15:53:34 <lambdabot>      Multiple declarations of `<stderr>: hPutChar: invalid argu...
15:53:45 <Taneb> I think I just wanted the excuse to install another Haskell compiler
15:53:51 <chrisdone> Koterpillar: is that a web game? =o
15:53:56 <Koterpillar> yes
15:54:07 <chrisdone> Koterpillar: what's the url?
15:54:15 <Koterpillar> http://labyrinth-hs.herokuapp.com/
15:54:36 <Koterpillar> UI is horrible...
15:55:28 <chrisdone> is it a WIP?
15:55:51 <Koterpillar> yeah, otherwise I wouldn't have said "making"
15:55:52 <aristid> looks like it's happstack-based?:)
15:55:54 <Koterpillar> yes
15:56:02 <fragamus> no workie on my mac
15:56:06 <chrisdone> Koterpillar: cool!!
15:56:09 <fragamus> chrome
15:56:11 <mcstar> is it supposed to do something?
15:56:30 <chrisdone> that *does* sound complicated =p
15:57:02 <mcstar> doesnt work for me either
15:57:09 <fragamus> it does not create game on safari either
15:57:24 <Koterpillar> I blame Heroku :P 503 on me somehow
15:57:26 <chrisdone> i think that's why it's work-in-progress =)
15:59:30 <Koterpillar> don't torture it anymore, I'm back to lenses...
15:59:48 * chrisdone pokes it with a stick a bit more, to check for sure it's dead
16:00:07 <chrisdone> ----(゜。゜) *poke*
16:01:07 <fragamus> im guessing that game uses the IO monad
16:01:21 <srhb> Uh oh!
16:01:24 <srhb> :P
16:02:25 <Koterpillar> fragamus, as does acid-state
16:09:42 <Koterpillar> :t ix 1
16:09:44 <lambdabot> (Num (Index m), Indexable (Index m) p, Ixed f m) => p (IxValue m) (f (IxValue m)) -> m -> f m
16:09:49 <Koterpillar> :t (ix 1 . ix 2)
16:09:50 <lambdabot> (Num (Index (IxValue m)), Num (Index m), Indexable (Index (IxValue m)) p, Ixed f (IxValue m), Ixed f m) => p (IxValue (IxValue m)) (f (IxValue (IxValue m))) -> m -> f m
16:10:17 <Koterpillar> [1,2,3] ^?! ix 1
16:10:20 <Koterpillar> > [1,2,3] ^?! ix 1
16:10:23 <lambdabot>   2
16:10:34 <Koterpillar> > [[1],[2],[3]] ^?! ix 1 . ix 0
16:10:37 <lambdabot>   2
16:12:15 <Mathnerd314> so CInt has a Num instance... does this mean that going from Int to CInt is as simple as import Prelude hiding Int, import Foreign.C(CInt) ?
16:13:09 * hackagebot linux-xattr 0.1.0.0 - Read, set and list extended attributes  http://hackage.haskell.org/package/linux-xattr-0.1.0.0 (NicolaSquartini)
16:14:01 <otters> :t (^?!)
16:14:03 <lambdabot> s -> Getting (Endo a) s t a b -> a
16:14:12 <otters> :t (^?)
16:14:13 <lambdabot> s -> Getting (First a) s t a b -> Maybe a
16:15:26 <supki> :t (^)
16:15:27 <lambdabot> (Integral b, Num a) => a -> b -> a
16:18:09 * hackagebot XAttr 0.1.1 - Read, set, and list extended attributes  http://hackage.haskell.org/package/XAttr-0.1.1 (NicolaSquartini)
16:18:11 * hackagebot antigate 0.5 - Haskell interface for antigate.com captcha recognition service and services supporting its API  http://hackage.haskell.org/package/antigate-0.5 (MikhailKuddah)
16:19:20 <beaky> > product [1..7]
16:19:21 <lambdabot>   5040
16:32:02 <ab9rf> ugh and poo
16:36:16 <Koterpillar> my lenses supported Control.Monad.Reader :(
16:37:04 <Taneb> :t view _1
16:37:06 <lambdabot> (MonadReader s m, Field1 s t a b) => m a
16:38:42 <Taneb> > runReaderT (view _1 >>= lift) ("hello", true)
16:38:44 <lambdabot>   Not in scope: `true'
16:38:47 <Taneb> > runReaderT (view _1 >>= lift) ("hello", True)
16:38:49 <lambdabot>   "hello"
16:40:02 <Koterpillar> Just for clarity, what's the opposite (for Writer)? I think I've seen "whisper", but...
16:40:04 <Koterpillar> :t whisper
16:40:05 <lambdabot> Not in scope: `whisper'
16:41:43 <OscarZ> hi ... if someone would put a gun to your head and forced you to use another language for your current project, what would it be? (serious question :) im interested what would be the next choice for hardcode Haskell users)
16:42:14 <sproingie> the people with the guns are usually the ones dictating the language
16:42:19 <OscarZ> and maybe.. what would you be missing in that language ?
16:42:19 <tac> Python, Ocaml, Idris, F#.... any of these are decent
16:42:22 <OscarZ> hehe
16:42:47 <sproingie> frankly i could tolerate nearly anything but PHP
16:43:16 <Taneb> I'd probably use C, although a few months ago I'd have said Python
16:43:19 <BMeph> Mythryl! ;þ
16:44:01 <Koterpillar> This might not go nice with the gun person, but I'll say anything and later point out that he/she missed "exclusively"
16:44:32 <sproingie> i suppose MUMPS, COBOL, or ABAP would be worse, but i don't know any of those, so i'd get shot for failing to code in them anyway
16:44:36 <parcs> OscarZ: c++
16:44:50 * OscarZ pulls the trigger
16:45:03 <parcs> lol
16:45:09 <OscarZ> thats a bit too much :D
16:45:57 <mcstar> noone said pure
16:46:01 <mcstar> or clean
16:46:49 <tac> (or lisp)
16:47:00 <OscarZ> seriously.. I was thinking of something that people maybe have to choose because of practical reasons, maybe JVM compatibility or something
16:47:05 <OscarZ> and yeah LISP
16:47:08 <mcstar> scala
16:47:37 <parcs> it's amazing how clean and consistent c++ is given its history and origins
16:47:59 <elliott> OscarZ: if someone put a gun to my head I would call the police.
16:48:04 <mcstar> is consistent c++ a variation of c++?
16:48:13 <mcstar> CC++?
16:48:18 <sproingie> when you have a gun in your mouth you speak only in vowels
16:48:20 <elliott> (ok, i probably wouldn't, that doesn't sound like a good solution.)
16:48:36 <elliott> (but: your question doesn't have useful answers. it's way too context-dependent and more likely to inspire flamewars than anything else.)
16:48:48 <mcstar> i'd look into a barrel for a bullet, no need to change languages for an empty threat
16:49:04 <sproingie> that confident of your vision eh?
16:49:16 <parcs> i would stick my finger in the barrel to disable the gun
16:49:19 <parcs> that works right?
16:49:25 <mcstar> all the time every time
16:49:33 <Koterpillar> What language is the gun written in?
16:49:39 <OscarZ> elliott: I dont mean to instigate one :) I have been studying Haskell a long time and I think its a beautiful language..
16:49:40 <sproingie> yep, and when they shoot, the gun blows up and peels like a banana and they get all burnt looking
16:50:19 <petantik> i think haskell has made me think about two thing; immutability and orthogonality of functions.
16:50:35 <petantik> that's helped me a lot in coding for other languages.
16:50:41 <sacundim> what programming language requires the least fine muscle control
16:50:43 <harrison> what language would be best to code a realtime voxel raytracer?
16:50:50 <petantik> harrison: fortran
16:50:51 <sproingie> sacundim: whitespace
16:50:55 <sacundim> that's the one to pick when a gun is pointed at your head
16:52:17 <petantik> OscarZ: Ever taken a look at rust?
16:52:27 <sacundim> does anybody know of something like Control.Monad.Operational, but for applicatives only?  I've seen a couple of free applicative packages, but I just find operational easier...
16:52:39 <vooor> best harlem shake from morocco https://www.youtube.com/watch?v=9uHV23DeQC0
16:52:47 <elliott> sacundim: you can use Codensity to turn any operational-style thing into something you can plug into a free thing
16:52:50 <OscarZ> petantik: no, im checking it out
16:53:02 <elliott> sacundim: but it's really easy to do by hand: instead of ... -> Thing Result, you do ... -> (Result -> a) -> Thing a
16:53:08 <elliott> (gets shorter if you use regular ADT syntax)
16:53:13 <sacundim> elliott, i have something like that
16:53:17 <elliott> and you can "derive Functor"
16:53:23 <sacundim> but i figure that i've done something wrong that i don't even understand
16:53:33 * sacundim goes for the hpaste
16:53:36 <parcs> vooor: harlem shake is supposed to be exactly 30 seconds long
16:53:58 <shanse> I hope rust gets somewhere
16:54:07 <OscarZ> mostly i was just curious if there is anything that the Haskell community likes even a bit...
16:54:14 <hpaste> sacundim pasted “operational applicative?” at http://hpaste.org/84133
16:57:20 <edwardk> sacundim: there is one in the free package
16:57:30 <sacundim> yeah, i've aped that a bit
16:57:31 <elliott> sacundim: I was referring to a transformation you'd do on your instruction type to make it an acceptable input to free stuff
16:57:39 <sacundim> but this is all confusing
16:57:42 <elliott> redefining all the machinery is overkill
16:57:46 <edwardk> sacundim: http://hackage.haskell.org/packages/archive/free/3.4/doc/html/Control-Applicative-Free.html
16:57:52 <sacundim> oh, right, elliott.  i tried that and got confused as well
16:58:02 <elliott> well, worst case you can just use Codensity
16:58:05 <elliott> but it's a pretty simple transformation
16:58:15 <sacundim> edwardk: the paste i did was born out of me not understanding your link well enough :-(
16:58:46 <sacundim> i guess i'll have to give it another shot.
16:58:49 <edwardk> sacundim: its basically flipped around so that you always have access to the 'next' f directly
16:59:07 <sacundim> right.
16:59:10 <edwardk> you could get a more 'natural' argument order if you read the functors from right to left
16:59:18 <edwardk> but that rarely mirrors what you want
16:59:26 <bgamari> If I have a type of kind Nat -> * -> *, is there any way to get a Typeable instance for it?
16:59:32 <sacundim> so the trick is to always have the "continuation" thing on the outside?
16:59:46 <OscarZ> that came out wrong: Haskell irc channel is one of the most helpful and friendly channels ive been in ..
16:59:48 <bgamari> Not even entirely sure whether this question makes sense
17:00:11 <elliott> bgamari: you can in ghc HED
17:00:13 <elliott> *HEAD
17:00:18 <bgamari> ahh
17:00:24 <bgamari> alright, so "no" ;)
17:00:27 <elliott> you can give Typeable1 (YourType n) for all nats n
17:00:33 <elliott> I guess
17:00:36 <elliott> maybe not
17:01:07 <edwardk> sacundim: In http://www.reddit.com/r/haskell/comments/zlr0l/towards_free_applicatives/ http://www.reddit.com/r/haskell/comments/zlr0l/towards_free_applicatives/c65s0zj describes the construction.
17:01:33 <edwardk> sacundim: yeah it basically smashes the 'extra' (<*>)'s into the right hand side of the Ap constructor
17:01:45 <edwardk> the rest of it is just shuffling args around
17:02:07 <sacundim> I tried that and the order of effects came out wrong somehow, but I suspect it's the stuff I added to support the instructions...
17:02:43 <sacundim> so yeah, i guess the next step is to try and figure how to layer the instructions on top of the Ap type
17:02:51 <sacundim> well, thanks
17:02:52 <bgamari> elliott, Yeah, it seems not
17:02:58 <luite> async exceptions work in ghcjs \o/ party!
17:13:32 <bgamari> How have I gone wrong here?
17:13:33 <bgamari> https://gist.github.com/bgamari/5174213
17:13:39 <Saizan> luite++ #!!
17:17:00 <hpaste> tac pasted “Applicative Parser help?” at http://hpaste.org/84134
17:17:13 <tac> ^ Does anyone know how I could convert this definition to a purely applicative version?
17:17:42 <tac> I'm guessing it's possible, but I figured I'd ask if it is or isn't before trying it
17:18:46 <tac> actually, I take that back, I have no clue whether it should be possible
17:18:59 <OscarZ> what do you think of Clojure as a language? in perspective of a Haskell user?
17:19:53 <liyang> tac: intuition: if you need to observe the result of running the monad and follow different computation paths depending thereon, it's not applicative.
17:20:00 <shachaf> OscarZ: These sorts of questions rarely lead to useful discussions in here.
17:20:45 <shachaf> (I second what elliott said.)
17:20:51 <tac> liyang: That was my feeling
17:20:59 <tac> So, in this case, it's not possible, right?
17:21:05 <tac> just to be explicit
17:21:20 <OscarZ> shachaf: my question is sincere.. im looking at many languages.. and I feel that Haskell users at the very end of pure functional and strong typed languages..
17:21:20 <elliott> tac: technically, it's possible in all cases in Haskell
17:21:32 <elliott> http://byorgey.wordpress.com/2012/01/05/parsing-context-sensitive-languages-with-applicative/
17:21:49 <OscarZ> shachaf: not trying to instigate flame war
17:21:55 <elliott> but yes, you can't usefully write that parser without (>>=).
17:22:12 <quchen> OscarZ: There's always something purer and stronger.
17:22:33 <liyang> @faq Can you parse context sensitive languages using only Applicative?
17:22:33 <lambdabot> The answer is: Yes! Haskell can do that.
17:22:37 <tac> elliott: ehhhh. Interesting, but resorting to infinite regress to parse a JSON file isn't in the cards tonight :P
17:22:50 <tac> But thank you guys :)
17:22:58 <elliott> OscarZ: well, whether you intend it sincerely or not, it can still cause unproductive discussions
17:23:08 <tac> I guess a style question: is it bad juju to mix applicative and monadic syntax?
17:23:31 <quchen> tac: I find that highly awkward.
17:23:52 <elliott> tac: I often do foo <- ... <$> ... <*> ...
17:24:01 <elliott> it depends on the situation, really
17:24:05 <liyang> tac: I use a mixture.
17:24:08 <tac> I would agree with quchen on principle, but in this case, <$> and <*> feel natural to me
17:24:14 <tac> thanks a bunch guys :)
17:24:45 <OscarZ> elliott: ok, fair enough.. I just to ask the opinion of the "pure academic functional" school, if there is such thing...
17:24:55 * liyang prefers to write say, do fieldA <- foo; fieldB <- bar; return Fields {..}.
17:25:15 <elliott> OscarZ: you won't find a unified opinion, or it wouldn't be very academic :P
17:25:17 <liyang> That way you're not implicitly depending on what order the fields are in Fields.
17:25:34 <OscarZ> elliott: but I myself appreciate it :)
17:25:46 <liyang> But if it's obvious then I use Applicative, like say for (,).
17:26:07 <sacundim> mixing applicative and monadic operators: depends on whether you are using a concrete monad like Reader, or a Monad-restricted type variable
17:26:40 <sacundim> when i tried writing some code mixing operators in the latter case, i found myself having to do (Applicative m, Monad m) => all over the place
17:26:53 <dmwit> byorgey: I'd like to use species to define "trees = linOrd `o` trees". Obviously this won't work. I'm trying to understand how to use "rec", but I'm having trouble tracking through the documentation...
17:27:26 <quchen> tac: I guess mixing >>= and <*> is odd. I'm fine with do notation plus <*>, but chains with *> >>= >> <*> would confuse me.
17:27:37 <tac> yeah
17:27:39 <OscarZ> elliott: actually, I wouldnt have asked such question on any other programming language channel..
17:27:56 <dmwit> (...and your paper doesn't discuss the recursive side of the library at all.)
17:28:04 * liyang mostly concurs with quchen 
17:29:15 <hpaste> ClaudiusMaximus pasted “granularity statistics” at http://hpaste.org/84135
17:30:15 <ClaudiusMaximus> is that a known technique in my paste?
17:31:18 <quchen> No idea. Comments? Docs?
17:32:04 <mcstar> ClaudiusMaximus: wavelets sample at multiple scales
17:32:50 <ClaudiusMaximus> mcstar: yeah, seems related (though i don't have much clue about them)
17:33:06 <mcstar> i dont have much clue abuot centroids :)
17:34:05 <ClaudiusMaximus> intuitively centroid is "center of gravity"
17:34:31 <Koterpillar> ...do I need Rank2Types or RankNTypes for lens?
17:34:52 <liyang> Koterpillar: why stop at 2?
17:34:57 <Koterpillar> > type AmmoLocation = Simple Traversal Labyrinth Int
17:34:58 <lambdabot>   <hint>:1:1: parse error on input `type'
17:35:15 <liyang> (Yes.)
17:35:23 <Koterpillar> mmmkay
17:36:26 * liyang reads "parsing context-sensitive languages with applicative". Good point, but seems like an awful idea in practice.
17:37:03 <edwardk> Koterpillar: yes
17:37:06 <tac> So many things are "true" in Haskell
17:37:45 <tac> :t fix id :: [[[[[(String, Int, Char, Char)]]]]]
17:37:47 <lambdabot> [[[[[(String, Int, Char, Char)]]]]]
17:38:04 <Koterpillar> :t use
17:38:05 <lambdabot> MonadState s m => Getting a s t a b -> m a
17:38:08 <Koterpillar> :t use (ix 2)
17:38:09 <tac> Is there any way to get reporting on Aeson of why something didn't parse?
17:38:10 <lambdabot> (Num (Index t), MonadState t m, Ixed (Accessor (IxValue t)) t) => m (IxValue t)
17:38:16 <tac> Like Aeson debugging or something?
17:38:39 <mcstar> doesnt it says you where the problem is?
17:38:48 <mcstar> i vaguely remember something like that
17:38:55 <mcstar> say*
17:38:59 <mcstar> tell
17:39:07 <tac> decode just returns a Nothing on failure
17:39:08 <shanse> I dont think so
17:39:15 <tac> it's kinda frustrating
17:39:48 <mcstar> then maybe it was the other json library
17:40:01 <shanse> tac: oh, try eitherDecode
17:40:57 <tac> omg
17:40:59 <tac> ty!
17:44:36 <mcstar> J.decode "{3}" :: J.Result Int
17:44:37 <mcstar> Error "Malformed JSON: expecting string: 3}"
17:44:46 <mcstar> Text.JSON tells you the problem
17:45:08 <mcstar> perhaps this is a worse approach, to use error...
17:45:45 <tac> last question before I wrap this up, I think
17:45:52 <tac> Is there a way to chain together parsers in JSON
17:46:00 <tac> like, I have an object {"foo" : {"bar" : 1}}
17:46:12 <tac> I can use o .: "foo" to parse foo
17:46:25 <tac> but can I do o .: "foo" *something* "bar" to grab that 1
17:46:26 <tac> ?
17:47:56 <ClaudiusMaximus> tac: o .: "foo" .: "bar" is my really wild guess, not having used json ever
17:48:32 <tac> ClaudiusMaximus: naturally, that was my first guess
17:48:48 <mcstar> no, .: is for toplevel forms
17:48:55 <mcstar> it doesnt compose
17:49:10 <tac> but again, it looks like I need >>= here
17:49:24 <mcstar> the Parser looks powerful
17:49:26 <tac> But it doesn't feel like I ought to need to use full monadic parsing
17:49:50 <mcstar> i think you just have to apply some applicative style parsin wizardry
17:50:11 <tac> mcstar: I'm trying to learn that wizardry with this project :)
17:50:59 <mcstar> parse :: (a -> Parser b) -> a -> Result b
17:51:05 <mcstar> i think you will need this
17:51:21 <mcstar> and parseJSON :: Value -> Parser a with the appropriate type
17:52:37 <mcstar> gn
17:53:19 <tac> hm
17:53:24 <tac> Well, monads did it for now
17:53:37 <tac> But I'll probably change it to use parseJSON later
17:53:39 <tac> Thanks again everyone
17:53:45 <tac> My dealy now parses
17:54:01 <sw2wolf> morning
17:54:35 <Koterpillar> :t currentTurn
17:54:36 <lambdabot> Not in scope: `currentTurn'
17:55:40 <Koterpillar> I have to admit I don't get the distinction between a Traversal and a Lens, and that's biting me.
17:55:51 <edwardk> A traversal can have more than one target
17:55:55 <edwardk> > (1,2)^._2
17:55:57 <lambdabot>   2
17:55:59 <edwardk> that is a lens
17:56:03 <edwardk> > (1,2)^..both
17:56:05 <lambdabot>   [1,2]
17:56:08 <edwardk> that is a traversal
17:56:13 <edwardk> every lens is a valid traversal
17:56:23 <Koterpillar> Why is ix not a lens?
17:56:36 <edwardk> > []^?ix 11
17:56:38 <lambdabot>   Nothing
17:56:48 <edwardk> > "hello"^?ix 3
17:56:50 <lambdabot>   Just 'l'
17:56:59 <edwardk> what happens when you index into something that isn't there?
17:57:14 <edwardk> ix can't create an entry 50 entries past the end of a list for example
17:57:19 <edwardk> the target of 'ix' isn't always there
17:57:32 <copumpkin> @hackage spoon
17:57:33 <lambdabot> http://hackage.haskell.org/package/spoon
17:57:34 <copumpkin> WhereIsMySpoon: ^
17:57:37 <edwardk> it uses a traversal to represent rhe partiality of the mapping
17:57:56 <hpc> copumpkin: lol
17:58:07 <Koterpillar> hmm...
17:58:10 <Koterpillar> :t use (ix 1)
17:58:11 <lambdabot> (Num (Index t), MonadState t m, Ixed (Accessor (IxValue t)) t) => m (IxValue t)
17:59:26 <arkeet> a traversal can also have 0 targets.
17:59:50 <Koterpillar> How do I wrap a traversal into a State monad then?
17:59:52 <edwardk> Koterpillar: if you _know_ in your heart of hearts the element is there you can use 'singular
18:00:00 <edwardk> otherwise you can 'preuse'
18:00:03 <edwardk> :t preuse
18:00:04 <lambdabot> MonadState s m => Getting (First a) s t a b -> m (Maybe a)
18:00:09 <edwardk> :t preuse (ix 1)
18:00:11 <lambdabot> (Num (Index t), MonadState t m, Ixed (Accessor (First (IxValue t))) t) => m (Maybe (IxValue t))
18:00:45 <Koterpillar> runState (preuse (ix 1)) ([1, 2, 3] :: [Int])
18:00:48 <Koterpillar> > runState (preuse (ix 1)) ([1, 2, 3] :: [Int])
18:00:50 <lambdabot>   (Just 2,[1,2,3])
18:01:03 <arkeet> > preview (ix 1) [1,2,3]
18:01:05 <lambdabot>   Just 2
18:01:35 <arkeet> preuse l = gets (preview l), I take it.
18:01:50 <edwardk> arkeet: basically
18:01:57 <arkeet> not exactly?
18:02:07 <Koterpillar> where do I import this 'singular' from?
18:02:13 <arkeet> Koterpillar: it's in lens
18:02:20 <arkeet> > [1,2,3] ^. singular _head
18:02:23 <lambdabot>   1
18:02:31 <edwardk> exactly actually
18:02:38 <arkeet> oh, ok ;)
18:02:53 <edwardk> singular is a way you can assert that a traversal won't fail. its a way to say 'trust me' to lens
18:03:00 <edwardk> when in doubt, don't do it ;)
18:03:09 <Koterpillar> Well, I am actually
18:03:24 <edwardk> then you can use use $ singular $ ix 1
18:03:24 <arkeet> > [] ^. singular _head
18:03:27 <lambdabot>   *Exception: singular: empty traversal
18:03:38 <edwardk> > [1,2]^. unsafeSingular _head
18:03:40 <lambdabot>   1
18:03:52 <Koterpillar> On one side, ix' = singular . ix will let me seamlessly convert all my stuff
18:03:52 <edwardk> > [1,2]^. unsafeSingular traverse
18:03:53 <lambdabot>  Terminated
18:03:59 <arkeet> > [1,2]^. unsafeSingular traverse
18:04:02 <lambdabot>   *Exception: unsafeSingular: traversing multiple results
18:04:34 <Koterpillar> On the other side, I'm quite tired of seeing "Prelude.!!: Index too large"
18:04:45 <edwardk> heh
18:04:46 <shachaf> singular should give you a traversal, and unsafeSingular should give you a lens.
18:05:04 <arkeet> shachaf: but what would the point of singular be?
18:05:15 <edwardk> arkeet: it'd be the same as taking 1
18:05:16 <hpc> the obnoxious answer would be to write so you don't have to be doing indexing anyway
18:05:22 <arkeet> hm
18:05:30 <shachaf> ?
18:05:37 <shachaf> Oh, I just meant it safeFromJust-style
18:05:46 <edwardk> > [1..10] & taking 2 traverse .~ 100
18:05:47 <arkeet> indeed
18:05:48 <lambdabot>   [100,100,3,4,5,6,7,8,9,10]
18:06:13 <arkeet> shachaf: I wasn't quite sure how serious you were.
18:06:50 <arkeet> is there any reason we have to write taking n l, instead of l . taking n?
18:06:59 <arkeet> like how we have l . filtered p
18:26:31 <Koterpillar> what's (flip ^.) ?
18:27:12 <Koterpillar> ...view
18:27:17 <Koterpillar> (but it's strange)
18:27:32 <srhb> :t (flip ^.)
18:27:33 <lambdabot> Getting a ((a1 -> b1 -> c) -> b1 -> a1 -> c) t a b -> a
18:27:35 <srhb> :t view
18:27:36 <lambdabot> MonadReader s m => Getting a s t a b -> m a
18:28:09 <srhb> Doesn't look quite the same.
18:29:20 <Koterpillar> that's why I'm saying it's strange, but docs say it is, and it works when I invoke it without the monad
18:31:17 <geekosaur> remember, Reader is ((->) e)
18:32:14 <Koterpillar> ah, yes, that's what I actually thought
18:34:51 <Koterpillar> how nice of TH-generated accessors to be Traversals when the record has multiple constructors!
18:35:04 <edwardk> they downgrade to traversals as needed
18:35:25 <sw2wolf> :t ((->) e)
18:35:26 <lambdabot> parse error on input `->'
18:36:05 <Koterpillar> edwardk, what I mean is, for data T = A { _x :: Int } | B, generated 'x' will be a Traversal, not a Lens
18:36:13 <edwardk> yep
18:36:26 <edwardk> if you had _x in both, then it'd stay a lens
18:36:29 <arkeet> would it be a prism?
18:36:38 <Koterpillar> edwardk, can I even do that?!
18:36:39 <sw2wolf> @wn traversal
18:36:40 <lambdabot> *** "traversal" wn "WordNet (r) 3.0 (2006)"
18:36:40 <lambdabot> traversal
18:36:40 <lambdabot>     n 1: taking a zigzag path on skis [syn: {traversal}, {traverse}]
18:36:40 <lambdabot>     2: travel across [syn: {traversal}, {traverse}]
18:36:50 <edwardk> Koterpillar: so long as they are constructors in the same data type, yes
18:37:56 <sw2wolf> @wn lens
18:37:56 <lambdabot> *** "lens" wn "WordNet (r) 3.0 (2006)"
18:37:56 <lambdabot> lens
18:37:56 <lambdabot>     n 1: a transparent optical device used to converge or diverge
18:37:56 <lambdabot>          transmitted light and to form images [syn: {lens}, {lense},
18:37:56 <lambdabot>          {lens system}]
18:37:58 <lambdabot> [13 @more lines]
18:39:47 <sw2wolf> Koterpillar: why do you think 'x' is a Traversal not a Lens in data = T A {_x::Int} | B
18:39:59 <Koterpillar> because it did not typecheck
18:40:29 <Koterpillar> what I had was, let's say, t :: T, then t ^. x
18:40:58 <sw2wolf> no typecheck in t ^. x ?
18:41:14 <Koterpillar> yes
18:42:07 <Koterpillar> just checked it with this exact example:
18:42:13 <sw2wolf> How about t = A 100.0 ?
18:42:16 <Koterpillar> *Main> :t x
18:42:16 <Koterpillar> x :: Control.Applicative.Applicative f =>
18:42:16 <Koterpillar>      (Int -> f Int) -> T -> f T
18:42:54 <hpaste> Koterpillar pasted “alternate constructors” at http://hpaste.org/84137
18:43:26 <Koterpillar> A 100 ^. x complains that Int is not a monoid
18:43:28 <edwardk> sw2wolf: he's correct
18:43:47 <Koterpillar> for once
18:43:50 <edwardk> Koterpillar: note you can use ^? to 'try' to read from a traversal
18:44:05 <Koterpillar> edwardk, that's what I'm doing already, thanks!
18:44:08 <edwardk> and ^?! will assert it better work (like singular)
18:44:09 * sw2wolf i need to study Lens ...
18:45:01 <deech> Hi all, what does the `_` mean in `where _ = ...`?
18:45:23 <Koterpillar> deech, most likely you don't care what it is but you want it to typecheck
18:45:25 <Koterpillar> htfpp warning: Parsing of testsuite/TestLabyrinth/Generate.hs failed at line 0: Ambiguous infix expression - this is annoying
18:46:16 <deech> Koterpillar: Ah, that makes sense.
18:46:17 <deech> Thanks
18:58:33 <JoeyA> Just curious, has anyone implemented a decent channel library that has two separate types for reader and writer, unlike Chan/TChan?
19:01:14 <JoeyA> Advantages include: 1) Type system prevents readers from writing and writers from reading.  2) If no receivers, items are GCed instead of piling up in memory.
19:02:05 <JoeyA> Hmm, split-channel looks pretty good.
19:03:05 <JoeyA> It even has pictures :-)
19:04:57 <DanBurton> sounds like io-streams to me
19:05:59 <DanBurton> InputStream and OutputStream, aka Reader and Writer
19:07:53 <JoeyA> DanBurton: Interesting parallel.  Thanks for pointing that out.
19:10:01 <JoeyA> Though channel libraries can provide a couple extra operations, such as duplicating a ReceivePort.
19:10:54 <JoeyA> So if a module needs to share a stream of values with multiple threads, it would have to ask for a ReceivePort, rather than an OutputStream whose implementation reads the receive port.
19:16:39 <augur> ski: syn
19:16:53 <JoeyA> Heh, the advantages I listed are exactly the ones listed in the split-channel documentation.
19:18:18 <Koterpillar> Is it just me or is haskell.org.down?
19:18:35 <sacundim> not for me
19:18:44 <Koterpillar> heh
19:19:29 <JoeyA> Ping haskell.org from the command line, and google the URL to make sure it's legit.
19:19:30 <sacundim> i think you asked the wrong question, because we are now no closer to knowing the answer
19:19:42 <sacundim> yet you seem satisfied
19:20:01 <sacundim> ok, that was a bad joke
19:20:10 <sacundim> ...about disjunction
19:20:18 <geekosaur> I was going to point you to split-channel specifically because I remember that from when it was released, but you found it first
19:21:07 <scoles_> I know I can add ~/.cabal/bin to my $path for executables that cabal may install, but what about the libraries?  I added ~/.cabal/lib, but when I try to build it still says it can't find the library?  Do I just have to use the --global flag?
19:24:11 <YayMe> Anybody got time to do a quick code review of my ~60 lines of code which tries to just do graceful network connection handling?
19:24:20 <Koterpillar> scoles_, are you building your own package, and what's the error?
19:24:33 <sproingie> cabal should find the libs on its own
19:24:51 <YayMe> It works (in my limited testing) but it does more IO than anything I've ever done before, curious if I'm doing things really stupid
19:24:51 <Koterpillar> unless they are not in build-depends of the cabal file...
19:25:27 <YayMe> http://codereview.stackexchange.com/questions/23963/
19:25:56 <scoles_> well, i was trying to build xmobar, but you reminded me it was on hackage as well.  worked fine doing a cabal install instead of from a tarball
19:25:58 <YayMe> any critique would be much appreciated. I finally see why do notation is great at times, doing enough IO it really wins.
19:30:06 <YayMe> Is the ST monad specifically for performance?
19:31:01 <copumpkin> sometimes you just want something to be mutable
19:31:23 <edwardk> YayMe: its mostly for it. its also just a cool hack
19:31:26 <YayMe> Isn't that what TVars and MVars are for?
19:31:26 <copumpkin> the disjoint set datastructure is sort of inherently mutable, although you can obviously simulate it with an intermediate balanced map
19:31:38 <copumpkin> YayMe: well, it gives you restricted mutability
19:31:51 <YayMe> copumpkin: all mutability in haskell is restricted mutability
19:32:09 <copumpkin> clearly I don't mean what you mean
19:32:12 <copumpkin> or I wouldn't have said that :)
19:32:17 <edwardk> YayMe: TVars and MVars can't be used locally without letting STM or IO infect the result signature or doing bad things
19:32:29 <edwardk> the ST operations are deterministic because they only acccess stuff they made up internally
19:32:43 <Koterpillar> Last thing I don't know how to refactor: what would give me Simple Lens A B -> State B C -> State A C?
19:32:46 <edwardk> and once you leave the ST action that created them the quantification trick keeps anyone else from accessing them again
19:32:48 <YayMe> copumpkin: I know, my point is you're definition of restricted isn't clear to me, because we're both right in a way
19:32:56 <edwardk> Koterpillar: 'zoom'
19:33:04 <copumpkin> YayMe: well, the distinguishing characteristic of ST is that you can escape it back into purity
19:33:11 <copumpkin> and its safety is guarded by clever types
19:33:20 <copumpkin> which isn't true of IORefs/MVars/TVars
19:33:27 <YayMe> makes sense
19:34:02 <YayMe> edwardk: Similar to the state monad?
19:34:28 <YayMe> it pretends to be stateful but is really just a trick, unlike IO/STM which are literally stateful
19:34:41 <edwardk> YayMe: similar, but even with State you need to know kind of the 'set of all types of things you'll be making and stuffing in State' whereas with ST i can just make up a ref for any type i want
19:35:20 <edwardk> if you have perfect ability to predict all the types you'll need then yes you can get by with State, by making maps for each of those types, etc.
19:35:30 <edwardk> but if you don't, ST is a pretty powerful tool
19:35:50 <edwardk> and even if you do, the State version with the maps will be asymptotically slower
19:36:22 <edwardk> ST enables you to use algorithms that are known to be a logarithmic factor better than anything (strictly) functional
19:36:24 <hpaste> sacundim pasted “Free Applicative + FreeFunctor” at http://hpaste.org/84140
19:36:27 <YayMe> edwardk: but it's not *actually* mutable state, right? it just..behaves like it
19:36:34 <elliott> ST uses real mutable state under the hood
19:36:42 <elliott> that's the whole point: letting you use mutable state to write pure computations
19:36:42 <edwardk> ST is real mutable state. with the State version of it, you just fake it
19:36:54 <sacundim> re my paste right now: I've figured out how to "operationalize" the free applicative with FreeFunctor, but not the Codensity stuff...
19:37:01 <edwardk> ST is basically IO under the hood restricted to a small pool of operations that can only touch things it created
19:37:08 <YayMe> oh ok so it is IO
19:37:37 <edwardk> the set of operations permitted to ST are te ones that it doesn't matter when or how many times you run them, they'll always return a deterministic result.
19:37:47 <elliott> sacundim: FreeFunctor *is* Codensity.
19:37:51 <edwardk> this means that they are indistinguishable from equivalent pure code, morally.
19:38:19 <edwardk> elliott: (CoYoneda)
19:38:23 <sacundim> elliott: glad to hear that, but I still can't figure out Control.Monad.Codensity...
19:38:26 <elliott> edwardk: whoops...
19:38:43 <elliott> sacundim: ok, if you pretend i hadn't mixed up codensity and coyoneda for the past however many hours, it *is* coyoneda :P
19:38:53 <elliott> this is why only edwardk should be allowed to answer questions.
19:39:10 <edwardk> sacundim: check out https://github.com/ekmett/kan-extensions/blob/master/src/Data/Functor/Yoneda/Contravariant.hs
19:39:20 <edwardk> sacundim: and compare it to yours ;)
19:39:43 <sacundim> if by check out you mean "Stare at it and understand it two years later," sure...
19:39:51 <sacundim> :-P
19:39:54 <edwardk> sacundim: um, take your type and flip the args
19:39:58 <edwardk> it matches mine
19:40:01 <elliott> it's literally identical to your code :)
19:40:06 <elliott> (for loose definitions of literal)
19:40:07 <sacundim> that was a joke, I'm having a look
19:41:40 <sacundim> yeah, i see it.  I took mine from here anyway: http://www.reddit.com/r/haskell/comments/17a33g/free_functors_the_reason_free_and_operational_are/
19:42:08 <sacundim> though i guess the top comment is relevant to this
19:43:16 <YayMe> edwardk: Thread local IO basically?
19:43:31 <edwardk> YayMe: yeah its IO without any observable side-effects.
19:43:38 <edwardk> its all IO you _could_ have implemented purely
19:43:51 <edwardk> so it uses sleight of hand and just uses IO and makes it fast
19:44:53 <elliott> too bad you can't actually implement ST in pure haskell 2010.
19:44:57 <elliott> (+ rank 2 types etc.)
19:44:58 <elliott> :(
19:45:00 <edwardk> yeah
19:45:15 <edwardk> though Saizan has a version in agda which is pure gold
19:46:22 <edwardk> there he is able to work in such a way that he can do everyting he needs in an explicit heap (in a slightly restricted universe for technical reasons)
19:47:57 <YayMe> edwardk: that's a little confusing because it's mutable state so it's mutable memory, which is as impure as it gets unless you cordon it off by thread bounds, so that's all that comes to mind to me that makes sense for it to actually do? Is that more or less right? is it bounded by function as well; a function you call on the same thread can't mutate that local variable?
19:49:55 <elliott> YayMe: all the state has to be "internal".
19:50:01 <elliott> you have to create it within the runST "block".
19:50:44 <YayMe> elliott: so if a mutable variable inside that block could be mutated by a function called inside that block?
19:50:59 <edwardk> runST :: (forall s. ST s a) -> a   since the function you pass has to work 'regardless of the choice of 's', and all the combinators for accessing STRef's etc. look like readSTRef :: STRef s a -> ST s a       you can't access any variables you've built from a 'different ST monad' in a later runST action
19:50:59 <edwardk> so what happens is sure, you set up a little "mini-IO-like-context" and do a bunch of stuff with mutable variables, etc. but when you're done, you build up all pure data structures
19:50:59 <edwardk> and nobody can ever catch you doing it, the result is deterministic and replayable
19:50:59 <edwardk> so it doesn't matter that it was originally done with IO
19:51:01 <YayMe> or does it have to be explicitly inside that function in that block, not in any other functions called in that block
19:51:03 <elliott> not a function but an ST actiont o which you pass the reference, sure
19:51:12 <elliott> or what edwardk said.
19:51:30 <edwardk> YayMe: it has to be within the same runST block. after you exit that block nothing that can access the variables you created inside the block will type check
19:51:48 <edwardk> you can call things transitively so long as the 's's agree
19:51:53 <edwardk> but when you return from runST you're done
19:52:02 <edwardk> you'll never see _that_ choice of 's' again
19:52:27 <edwardk> so even if you smuggle out a bunch of STRefs out in the result, you can never use them again.
19:53:09 <YayMe> edwardk: I get that, but if inside that runST block it calls to another function; can that other function mutate the variables of the runST block because it's technically inside that runST block?
19:54:03 <edwardk> one way to think of the 's' in ST s is as a 'region parameter'. It'd be perfectly okay for runST to allocate a bunch of memory put them into buffers, allocate stuff from the buffers, and when runST finished, it could throw away the buffers, and nobody could even look at any references that were dangling pointing into the buffers
19:54:11 <jmcarthur> if that function is in ST and is not itself calling another runST, yes. if this was not so then you wouldn't be able to decompose your code
19:54:22 <edwardk> YayMe: sure, so long as it calls something in the ST monad.
19:54:26 <YayMe> arr x = writeSTRef x 4; bla = runST $ do x <- newSTRef 0; arr x; return x;
19:54:30 <edwardk> you can chain calls in ST with (>>=) just fine
19:54:52 <YayMe> edwardk: in this example, arr would cause side effects in bla's local state, is that a correct concept of ST?
19:54:56 <edwardk> (>>=) is being used there to explicitly sequence those
19:54:59 <edwardk> sure
19:55:05 <hpaste> sacundim pasted “Woot!!! thanks elliott & edwardk” at http://hpaste.org/84141
19:55:42 <edwardk> that is the same as if you'd written: runST (newSTRef 0 >>= \x -> writeSTRef x 4 >>= \_ ->  return x)   no problems at all
19:55:58 <edwardk> sacundim++
19:56:04 <elliott> sacundim: \o/
19:57:03 <sacundim> alright, gotta go now... thanks!
19:57:06 <otters> sacundim: what does it do
19:57:09 <otters> oh rats
19:57:22 <edwardk> YayMe: you can even runST while in another ST action, but the 's' parameters will differ so there is no danger/ambiguity
19:57:23 <YayMe> ok. I don't think I like it. heh, one of the nicest things about haskell is any given function, you know everything that is changed in that function is clearly dictated by being defined, you don't have to walk down the paths of other functions called (and the functinos they call and so on) to find out that 6 functions away somebody added a "feature" which is now decrementing at the end of your loop causing an off-by-one error without it
19:57:23 <YayMe> being explicit at the stop of the stack
19:57:45 <edwardk> YayMe: the ST monad is your clue someone can touch your references
19:57:57 <edwardk> and they can only touch the references you explicitly passed down to them somehow
19:58:01 <YayMe> edwardk: when you put it that way, I definitely don't like it ;P
19:58:20 <elliott> YayMe: you can write a computation using ST as just recursion.
19:58:30 <elliott> or such.
19:58:36 <elliott> it'll just be a lot uglier and slower.
19:58:37 <YayMe> right, just like what I deal with in C# at work every day, I have to chase the references all across the system whenever I want to change how one of them behaves to make sure I'm not breaking an edge case 6 frames away
19:58:40 <elliott> ST isn't magic
19:58:43 <edwardk> ou can transform anything you can write with ST into code without it, just potentially slower
19:58:46 <jmcarthur> i don't see what the big deal is. it's mutation. you're getting what's advertized. it's more controlled than mutation normally is, even.
19:58:56 <elliott> if you have a function that was written using ST then you don't have to be worried that it's written using ST
19:58:59 <elliott> because it's guaranteed pure.
19:59:05 <elliott> the state is a pure optimisation, nothing more
19:59:22 <YayMe> fair enough
19:59:30 <YayMe> it's for performance reasons, which makes sense
19:59:47 <edwardk> YayMe: i'm not saying you should use it a lot, but what it does do is provide you with a straightjacket in which you can have a limited set of effects that are safe. they are as hard to reason about as any other I/O. maybe a little easier because you never have to worry about other threads, etc and there is a single completely deterministic control flow, but they are safe.
19:59:52 <jmcarthur> it's also easier to deal with in some cases
20:00:00 <Koterpillar> http://hpaste.org/84142 - what am I doing wrong?
20:00:06 <Koterpillar> (still zoom)
20:00:28 <YayMe> edwardk: good point about the thread local, that does give a considerably better guarantee than what I get in C# at work
20:01:36 <edwardk> Koterpillar: Update is missing Zoom instances
20:01:38 <jmcarthur> i thought the region-like constraints were already much nicer than in C#
20:01:54 <Koterpillar> edwardk, it is MonadState, what else is needed?
20:02:08 <edwardk> Koterpillar: zoom can change the _type_ of your state.
20:02:12 <YayMe> jmcarthur: that's a good point as well
20:02:12 <edwardk> try writing it with get and put
20:02:27 <edwardk> Koterpillar: i'll be here when you're done ;)
20:04:04 <Koterpillar> It's not nice that way :( I have functions like: fun x y z = zoom (somewhere x y) $ do {a lot of code}
20:06:37 <edwardk> Koterpillar: fortunately Data.Acid.Common exports a constructor for Update, so one can get under there and either write a zoom instance or write a zoomUpdate combinator
20:08:20 <edwardk> Koterpillar: zoomUpdate l (Update s) = Update (zoom l s)
20:08:38 <YayMe> Ok. I think I feel comfortable I know what the ST monad is. This stuff is clicking faster and faster lately.
20:08:56 * Koterpillar Geiger counter comes to mind
20:09:21 <edwardk> Koterpillar: =)
20:10:12 <YayMe> The quasiquotes/template haskell I'm still not touching though.
20:11:20 <Koterpillar> edwardk, Data.Acid.Common is a hidden module - seems I'll have to rewrite the combinator
20:11:36 <edwardk> Koterpillar: if you can't get at the Update constructor you may have a problem
20:11:43 <Koterpillar> I can't
20:12:01 <Koterpillar> going via runState :(
20:13:13 * hackagebot ghc-mod 1.12.3 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.12.3 (KazuYamamoto)
20:13:17 <edwardk> i don't see how to run Update at all
20:13:28 <edwardk> i view this as an API design flaw
20:13:46 <edwardk> thank you for reminding me why i don't use Data.Acid ;)
20:14:24 <Koterpillar> edwardk, you don't run it directly...
20:14:30 <Koterpillar> that is the point, actually
20:14:41 <edwardk> Koterpillar: if you want to turn one Update into another, you have to be able to reconstruct one
20:14:43 <edwardk> its a State monad
20:15:00 <edwardk> its not magic
20:15:08 <Koterpillar> The reason why you can't is, Acid needs to make a record of you doing that
20:15:55 <Koterpillar> they made it magic :)
20:16:09 <edwardk> um, there is no difference from me providing a function from Lens x y -> Update x a -> Update y a   than there is from Lens x y -> State x a -> State y a  -- the end Update action is being run by them.
20:16:14 <edwardk> they get their record
20:16:23 <edwardk> er Lens' y x -> ...
20:16:31 <edwardk> so i call bullshit =P
20:16:56 <edwardk> its just an non-exported constructor that is needed for cases the original author(s) didn't forsee
20:17:03 <edwardk> this is one of those cases.
20:17:27 <Koterpillar> I worked around that anyway. Now, I apparently can't zoom into Traversals :(
20:17:33 <edwardk> his is one of those reasons why i tend to err on the side of exporting too much.
20:17:37 <edwardk> you can zoom into a traversal
20:17:47 <edwardk> it just needs a monoid on the result, because it zooms into _all_ targets
20:17:59 <edwardk> and then has to stitch together your state results with the monoid
20:18:17 <Koterpillar> yes, my types are not monoids
20:18:54 <edwardk> i'd rather have users complain at me that I give them an Internal module that is documented as breaking invariants and that i'm a bad man than have them hit something where they simply cannot proceed because i hid an implementation detail for a 'cleaner' API that isn't necessary to preserve my invariants
20:19:11 <edwardk> you are running a state action of some sort in a larger state
20:19:20 <edwardk> what is that action doing?
20:19:24 <edwardk> and what is the result?
20:19:29 <YayMe> what does ST stand for?
20:19:30 <edwardk> and how many targets do you have?
20:19:35 <edwardk> YayMe: state transformer
20:19:53 <YayMe> I was guessing state transition, yours makes more sense
20:23:07 <edwardk> I get users complaining at me all the time because i don't have parsers instances for attoparsec. i can't write them because bos hid too much of the attoparsec internals for me to give an instance that doesn't randomly cause inference problems. Lens performs less well than it could with Text because I can't participate in its hidden fusion subsystem, etc.
20:24:59 <Koterpillar> 22 files changed, 505 insertions(+), 739 deletions(-)
20:25:24 <lispy> edwardk: is the same true of bytestring?
20:25:39 <edwardk> lispy: no. i can get down and dirty with enough bytestring internals that i have zero objections there
20:25:51 <edwardk> in fact lens outperforms bytestring on some ops… on bytestrings
20:25:56 <lispy> edwardk: So it really is an API issue
20:26:02 <edwardk> yes
20:26:13 <lispy> expose all the modules!
20:26:14 <edwardk> yes
20:26:42 <Koterpillar> Fortunately, I don't know how to make modules hidden :)
20:26:58 <edwardk> i just want them in some kind of Internal module. in the attoparsec case i can't write anything generic in the input type to the parser, so any instances I have are necessarily Flexible and therefore will fail under some conditions.
20:27:11 <lispy> edwardk: I like to expose all my internal modules (and mark them as such in the module heirarchy, FWIW)
20:27:21 <edwardk> lispy: i appreciate that =)
20:27:39 <edwardk> i do hide a few internals, but when someone contacts me and makes a case for them. i'm happy to talk about it ;)
20:28:12 <lispy> Hmm...so I take it you asked bos to expose them and he said, "no thanks"?
20:28:32 <YayMe> edwardk: Isn't it all open source on hackage anyway?
20:28:50 <ag90> I agree. I was working on something recently that required doing some imperative stuff for performance (re-use a buffer instead of re-allocating it for each bytestring), and I was grateful that ByteString.Internal was exposed for that.
20:29:29 <edwardk> i haven't had a chance to talk to him about the attoparsec issue. i did have a go around with him on some of the text stuff back before jaspervdj took on the utf-8 text gsoc project under me a couple years back though. fortunately we were able to get some of the internals, if not the full fusion api, exposed
20:29:53 <edwardk> but not enough to actually make text usable for me =(
20:30:06 <edwardk> this is why trifecta is stuck working with its horrible bytestring bits
20:30:25 <lispy> Perhaps it's time to ask again? :)
20:31:02 <lispy> (I mean that in a "use your judgement" not a pushy "just do it" sort of way)
20:31:28 <edwardk> actually. let me rephrase that. i think i can make trifecta work now by sticking my hands in up to the elbows in text's exposed guts. i can't get the fusion stuff to work though
20:31:54 * lispy nods
20:32:42 <edwardk> anyways i may take it back up with him, just because i really get sad that such a key library is dead to me when i need performance and its outside of a code path that he happened to consider =(
20:35:02 <lispy> yeah. text is hugely important
20:35:43 <lispy> Speaking of which, it would be wonderful if someone (maybe I should do it) contributed a text wrapper to alex
20:36:03 <lispy> it has bytestring and String wrappers but no text
20:48:23 <lispy> is anyone here familiar with the Charity programming language?
20:48:49 <lispy> I found it via reddit the other day but it looks like they didn't update since the 90's and I couldn't actually get the code snippets to load
20:49:04 <lispy> My interest in it, is that it's supposedly a category theory based language
20:58:00 <edwardk> lispy: i used to be interested in it a few years ago, but i kind of lost interest in thinking about programming using that vocabulary
20:58:55 <edwardk> no way to findIndex or elemIndex on Lazy.text?
20:59:09 * edwardk stops and goes to write his own
20:59:39 <lispy> edwardk: I could see that happening. I'm interested in what they learned but remain skeptical.
21:00:32 <arkeet> robin cockett is a cool guy.
21:00:55 <edwardk> lens to the rescue
21:01:21 <lispy> None of these load for me: http://pll.cpsc.ucalgary.ca/charity1/www/examples.html
21:02:47 <arkeet> let's program with operads.
21:02:56 <arkeet> I don't know what that would mean but let's do it.
21:03:22 * sw2wolf time for lunch
21:03:56 <arkeet> @localtime sw2wolf
21:03:58 <lambdabot> Local time for sw2wolf is Sat Mar 16 12:03:19 2013
21:04:10 <Koterpillar> @localtime Koterpillar
21:04:11 <lambdabot> Local time for Koterpillar is Sat Mar 16 15:03:59
21:04:19 <lispy> you all are living in the future
21:04:21 <lispy> @localtime lispy
21:04:25 <lambdabot> Local time for lispy is Fri Mar 15 21:10:55 2013
21:04:38 <arkeet> sw2wolf is in china?
21:05:04 <geekosaur> or the phillippines
21:05:09 <lispy> it seems like maybe the ftp server that houses charity has gone away
21:05:11 <arkeet> geoip says china
21:05:13 <otters> @localtime
21:05:15 <lambdabot> Local time for otters is Sat, 16 Mar 2013 08:05:02 +0400
21:05:23 <otters> not likely
21:05:26 <otters> how do you set localtime
21:05:27 <arkeet> @localtime
21:05:28 <lambdabot> Local time for arkeet is 金 3月 15 21:05:19 2013
21:05:32 <arkeet> hm.
21:05:49 <arkeet> otters: lambdabot just queries you with CTCP TIME
21:05:53 <otters> oh yeah
21:06:19 <arkeet> I have my computer on japanese locale for some reason.
21:06:41 <otters> This VPS is on Moscow time
21:09:49 <Koterpillar> Speaking of locales... http://hackage.haskell.org/package/current-locale - is there a better way of getting the locale?
21:11:31 <arkeet> TimeLocale?
21:12:36 <Koterpillar> arkeet, yes, I'm getting a TimeLocale
21:14:04 <Koterpillar> actually, I'll rephrase: is there _any_ other way of showing your 3月?
21:14:13 <Koterpillar> (in Haskell)
21:14:43 <taesoo> do you know any TH printf library?
21:15:11 <arkeet> Koterpillar: setlocale?
21:16:55 <arkeet> setlocale to whatever you want, print the time, and then set it back if you want?
21:17:48 <Koterpillar> can you elaborate on "print the time"?
21:18:57 <SrPx> What's haskell equivalent to javascript/python object literals? {a:1, b:2, c:3...}
21:19:16 <arkeet> SrPx: there are Maps
21:19:20 <elliott> SrPx: there isn't really one. you use the constructor for the type
21:19:27 <elliott> or Map if you really want an association, yes
21:19:35 <elliott> *a constructor, I shoulds ay.
21:19:49 <arkeet> but to construct them you still need stuff like fromList [("a",1), ("b",2)]
21:19:53 <Koterpillar> beware, all the values have to be of the same type
21:19:53 <SrPx> constructor for the type? map? ill google those ok, thanks elliott
21:20:14 <elliott> SrPx: have you read an introduction to Haskell, like Learn You a Haskell?
21:20:15 <Koterpillar> :t getZonedTime
21:20:16 <elliott> @where lyah
21:20:16 <lambdabot> http://www.learnyouahaskell.com/
21:20:17 <lambdabot> Not in scope: `getZonedTime'
21:20:22 <elliott> it goes over these things pretty thoroughly.
21:20:47 <SrPx> Okay thaanks guys! This was just a research question
21:21:39 <SrPx> I love you guys, #haskell is the overattached programming community
21:21:42 <arkeet> Koterpillar: I'm not sure, actually.
21:21:44 <Koterpillar> arkeet: import Data.Time; import System.Locale; getZonedTime >>= return . formatTime defaultTimeLocale "%b"
21:22:06 <arkeet> defaultTimeLocale isn't it.
21:22:29 <arkeet> current-locale would indeed work but it seems like a roundabout way of doing it.
21:22:37 <arkeet> or would it.
21:22:38 <Koterpillar> That's why I'm asking
21:22:52 <Koterpillar> It does work... but well
21:27:39 <arkeet> Koterpillar: because basically we're looking for the equivalent of strftime, right?
21:28:43 <jmcarthur> Koterpillar: "beware, all the values have to be of the same type"  <-- true of dynamically typed langauges anyway ;)
21:31:52 <arkeet> I don't understand why old-locale is called what it is, since I don't see a new locale.
21:35:09 <elliott> arkeet: I've had that same wonder, I think.
21:35:17 <elliott> perhaps there was meant to be one but it never materialised
21:37:11 <lispy> this is functional programming we can't change the locale package once it's created so we just called it old-locale from the start
21:43:16 * hackagebot parsers 0.5.2 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.5.2 (EdwardKmett)
21:43:32 <edwardk> lispy: =)
21:43:56 <edwardk> clearly i should release a bunch of my gettext machinery and stuff under locale ;)
21:44:21 <mikeplus64> edwardk: is that a parser combinator combinator library
21:44:41 <edwardk> i appreciate the community's restraint in reserving it for me
21:44:44 <edwardk> mikeplus64 yep
21:45:08 <edwardk> mikeplus64: a couple of people have teased me that 'parsers' doesn't actually have any parsers in it. just parser combinators.
21:45:24 <mikeplus64> maybe it should be in like Control.Parser ;)
21:45:53 <edwardk> i figured i'd save that for when i build the gll parsers and they wind up incompatible with all these
21:46:53 <edwardk> I banged out enough toy parser libraries that having 'parsers' there really simplified my life. now 'trifecta' just cares about error reporting, etc.
21:47:27 <mikeplus64> what's in parsers that's not in e.g. Control.Applicative+parsec/attoparsec?
21:47:42 <Koterpillar> arkeet, yes (given that formatTime only does half of the job)
21:47:45 <edwardk> well, it gives you classes that work with parsec but can also be transformed with monad transformers, etc.
21:47:57 <edwardk> so if you want to bolt more transformers onto your stack, you can
21:48:07 <chord> since C has the aliasing problem why in hell doesn't C lose in all the benchmarks to Haskell?
21:48:16 * hackagebot Boolean 0.2 - Generalized booleans and numbers  http://hackage.haskell.org/package/Boolean-0.2 (ConalElliott)
21:48:29 <edwardk> and parsec-parsers provides a Parsec instance, so you can use them with parsec as a base monad.
21:49:12 <edwardk> the tokenized API is a lot easier to use, rather than having to open some record in a rather ad hoc manner, it exposes more of the guts, which is useful when you need a custom whitespace notion, e.g. every haskell parser ever
21:49:16 <mikeplus64> so i can write a parser with 'parsers', and it will work for attoparsec, parsec, etc?
21:49:49 <edwardk> parsec and trifecta currently. you can write a one-off instance for attoparsec, but currently bos doesn't give me enough in the attoparsec public API to release a 'good' binding for attoparsec.
21:50:13 <edwardk> i have to pick between supporting ByteString or Text parsers from attoparsec or supporting both with terrible inference at the moment
21:50:16 <edwardk> so I don't.
21:51:33 <elliott> chord: erm, haskell has a lot of "aliasing" type stuff too :P
21:52:00 <chord> why can't haskell beat C in speed all the time
21:52:38 <elliott> you'd generally expect C to beat haskell considering the latter is a high-level, garbage-collected language with non-strict semantics...
21:53:02 <arkeet> isn't ghc amazing
21:53:09 <elliott> the wonder is more that haskell is often competitive (though the shootout code is unnecessarily hideous to get there since GHC wasn't as good back when they were written)
21:54:01 <mikeplus64> it can certainly beat C a lot of the time, but if you're at the point where you're writing C code to use with the FFI, or even a ghc primop, or even using unboxed stuff explicitly, then that's more "ghc" than haskell
21:54:17 <chord> elliot come on you're killing me here there needs to be a functional language that beats C speed ALL THE TIME
21:54:36 * elliott wonders if this is trolling.
21:54:47 <chord> i want to see haskell DFT rape C in speed
21:54:58 <elliott> wait, weren't you that guy who got banned from asking edwardk lots of pointless questions?
21:55:03 <arkeet> I think so.
21:55:07 <mikeplus64> chord: where can C performance be improved?
21:55:08 <chord> uh no
21:55:11 <arkeet> uh yes
21:55:18 <elliott> chord: please don't use "rape" in that manner.
21:55:19 <chord> that was someone else probably
21:55:20 * edwardk guesses yes, because he can't see him.
21:55:24 <arkeet> haha
21:55:25 <elliott> no, it was actually you
21:56:03 <elliott> you should consider changing your behaviour, like, several minutes ago.
21:56:31 <chord> what would be needed to create a functional language thats designed to blow away C
21:56:39 --- mode: ChanServ set +o elliott
21:56:53 --- mode: elliott set +b *!*322f5c1b@*.50.47.92.27
21:56:53 --- kick: chord was kicked by elliott (repeating past unproductive behaviour)
21:56:56 <mikeplus64> a sufficiently large fan
21:57:01 --- mode: elliott set -o elliott
21:57:05 <edwardk> elliott++
21:57:19 <no-n> my name is edward too
21:57:56 <lispy> no-n: yes, but the rule of thumb is that edwardk gets to claim all the common (and good) names
21:58:05 <no-n> *nod*
21:58:20 * lispy is also named edward but not as a first name
21:58:25 <edwardk> =)
21:58:37 <dolio> edwardk's name is actually Emmet Dwardk.
21:58:44 <edwardk> dolio: =)
21:58:49 <no-n> :>
21:59:14 <edwardk> So sayeth Don Olio.
21:59:21 <Koterpillar> What's my name?
21:59:22 <ion> Emmiott
22:01:08 <TravisD> His ban length should double for each offence
22:01:08 <Hafydd> Kloosterstraat Oterpillar
22:06:51 <edwardk> he's on his 4th ban or so
22:06:57 <edwardk> i'm done with him
22:07:16 <elliott> at least he gets straight to the (no) point so you can be efficient about it
22:07:23 <edwardk> =)
22:13:16 * hackagebot mmorph 1.0.0 - Monad morphisms  http://hackage.haskell.org/package/mmorph-1.0.0 (GabrielGonzalez)
22:15:10 <lightquake> … ok, what. hitting tab in emacs is showing me the definition of haskell-mode-hook
22:19:50 <zeta-> I'm trying to install the platform with ./configure --prefix=... but It can't autodetect ghc or anything else even though it's in the path & prefix/bin
22:20:10 <zeta-> alex needs to find happy
22:20:34 <zeta-> anyone know how to help autodetect?
22:23:35 <lispy> zeta-: um, autodetect? Normally configure uses whatever is in your path
22:23:50 <lispy> zeta-: so, my first question would be: is happy and ghc in your path?
22:24:41 <zeta-> lispy: yes, they're all in path
22:26:42 <zeta-> I have to use --with-ghc= etc.  All in <prefix>/bin
22:28:19 * hackagebot ersatz 0.2 - A monad for expressing SAT or QSAT problems using observable sharing.  http://hackage.haskell.org/package/ersatz-0.2 (EdwardKmett)
22:28:29 <edwardk> now with 100% more lens!
22:28:48 <edwardk> and … *gasp* examples
22:31:23 <lispy> zeta-: --prefix doesn't bring anything into scope
22:31:36 <lispy> zeta-: --prefix determines where things will be installed
22:31:59 <luite> if a thread that's blocked on delivering an async exception receives an async exception itself, would the first exception still be delivered?
22:32:00 <lispy> (maybe you understand that, I can't tell)
22:32:37 <lispy> luite: please rephrase your question in terms of mimes, forests, and trees ;)
22:33:21 <luite> lispy: would haskell code do?
22:34:21 <lispy> luite: <sigh> I guess...
22:34:33 <luite> i wonder if anyone cares if i implement async exceptions correctly :p
22:34:46 <lispy> luite: But, I should tell you. I don't know the answer to your question or how to figure it out.
22:35:04 <lispy> luite: IIRC, there is a paper by SPJ that touches on the semantics of these exceptions.
22:35:29 <luite> yeah and the base lib says that the implementation is different from that paper :p
22:35:39 <lispy> That was my next comment :)
22:35:57 <lispy> (John Launchbury figured this out when he was working on the Orc library on hackage)
22:36:14 <lispy> http://hackage.haskell.org/package/orc
22:36:27 <luite> i'll just halfass something, call it original research and write a paper about it ;p
22:36:55 <zeta-> lispy: Yes, but autodetect should guess <prefix>/bin, yet it complains that it can't find ghc etc.
22:37:17 <luite> Orc Orc Orc, you eat soup with a...
22:37:20 <lispy> zeta-: perhaps mzero could help you
22:37:32 <lispy> (but he doesn't seem to be here)
22:38:43 <lispy> luite: I think you need to figure out how the masking works in your case
22:38:55 <TravisD> I think I'm missing some reference, but I find it very hard not to mentally say "Orc Orc Orc, you seat soup with a ... fork"
22:38:59 <lispy> luite: and you should be able to figure that out by reading the source (which source? I can't remember)
22:39:00 <TravisD> eat*
22:39:09 <luite> TravisD: the answer is forkIO
22:39:16 <luite> almost correct ;p
22:39:24 <zeta-> lispy: thanks, I need to find out where configure is actually looking
22:39:36 <lispy> zeta-: config.log is where I would start
22:39:47 <TravisD> spoonIO?
22:39:48 <lispy> zeta-: and if it's not there, configure.ac or whatever they called it
22:40:09 <zeta-> Good Idea :)
22:40:18 <luite> TravisD: was just some silly remark, i'm implementing some concurrency stuff (forkIO and async threads) and lispy mentioned Orc
22:40:28 <luite> async exceptions that is
22:40:45 <TravisD> luite: Hehe, I was just goofing around
22:40:52 <lispy> Orc is short for orchestration. It's based on an abstraction in java.
22:41:06 <lispy> It's about doing concurrent things that may never get back to you.
22:41:52 <TravisD> lispy: I guess to be useful they'd have to be side-effecting?
22:42:11 <TravisD> oh, no, maybe not
22:42:30 <lispy> TravisD: In general they can be. You might query 5 websites and take the first answer.
22:50:46 <zeta-> config.log insists that PATH: is different to my environment -- I think I know what's wrong -- su env is different :(
22:51:11 <edwardk> lispy: thanks for reminding me about Orc. it serves as a good counterpoint to a design i was considering for something in analytics
22:55:15 <lispy> zeta-: oh yeah, try sudo
22:55:26 <lispy> zeta-: wait, that's silly.
22:55:35 <lispy> zeta-: but hey, at least you know the problem now
22:55:55 <lispy> edwardk: heh, np. Everyone else deserves the credit :)
22:56:08 <zeta-> lispy: t'other way 'round
22:56:24 <lispy> I want lookupOp :: (a -> Bool) -> Set a -> Maybe a
22:56:25 <zeta-> 8) thanks
22:56:51 <lispy> er, lookupOn
22:57:01 <lispy> ?hoogle (a -> Bool) -> Set a -> Maybe a
22:57:02 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
22:57:02 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
22:57:02 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
22:57:17 <lispy> oh, does Data.Foldable work on Data.Set?
22:57:20 <edwardk> lispy: i may spend some time seeing if i want to switch Data.Analytics.Task.* over to something more orcish
22:57:26 <edwardk> lispy: yes
22:57:38 <edwardk> > Data.Foldable.toList $ Set.fromList [1,2,3]
22:57:40 <lambdabot>   Not in scope: `Set.fromList'
22:57:40 <lambdabot>  Perhaps you meant one of these:
22:57:40 <lambdabot>    `Seq.fromL...
22:57:44 <edwardk> > Data.Foldable.toList $ S.fromList [1,2,3]
22:57:46 <lambdabot>   [1,2,3]
22:57:52 <lispy> perfect
22:58:38 <edwardk> :t Data.Foldable.find
22:58:39 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
22:58:50 <edwardk> oh it was shown above
23:01:03 <lispy> Everytime I try to make any progress on reimplementing the mixfix paper I discover a subtly that I thought the paper didn't cover and then I discover they mention it
23:08:51 <aviraldg> Hey there. Experienced Python programmer trying to pick up Haskell (by reading http://book.realworldhaskell.org) here.
23:09:19 <aviraldg> Why doesn't something like: add a b = a + b work in ghci without a `let`?
23:12:03 <lispy> aviraldg: that's just a side effect of ghci
23:12:10 <lispy> aviraldg: ghci is expecting expressions
23:12:14 <arbn> aviraldg: GHCi is in the IO monad, sort of...
23:12:35 <aviraldg> Just starting out (so no monads and stuff yet)
23:12:49 <aviraldg> lispy, thanks, makes sense
23:12:55 <lispy> aviraldg: I think they were actually trying to fixup ghci so that more of the haskell grammar is supported directly
23:13:28 <arbn> Yeah, because you can do data declrations now, and that's not an expression...
23:13:48 <lispy> aviraldg: for example, you can still use :m to import modules, but you can also just say, import Data.Set in newer versions and it does the right thing
23:14:26 <arbn> aviraldg: I came from Python, too, and I just had to learn not expect GHCi's shell to be as full-featured as Python's.
23:14:49 <Vertue> Question about "duplicate symbols", I googled and got the FAQ instruction "you should use the -x option to ld" but I have no idea what it means, can anyone help?
23:14:50 <lispy> > (,) 1 2 -- aviraldg you might appreciate this coming from python
23:14:52 <lambdabot>   (1,2)
23:14:56 <arbn> For instance, multi-line input is trickier in GHCi.
23:15:30 <lispy> Vertue: are you having a problem with duplicate symbols?
23:15:32 <aviraldg> lispy, yeah, saw that :)
23:15:38 <Vertue> yep
23:15:48 <lispy> Vertue: are you using cabal?
23:15:50 <aviraldg> Although I'm not sure I appreciate the lack of parens in function calls.
23:15:56 <Vertue> lispy: Data.UUID and Directory
23:16:08 <Vertue> lispy: I am using cabal
23:16:44 <lispy> Vertue: I recommend posting your error to hpaste.org and sharing that with us. Maybe we'll spot the problem?
23:16:44 <arkeet> aviraldg: it's not hard to get used to, and is very handy given that we have curring/partial application
23:16:56 <Vertue> sure thing
23:17:20 <hpaste> “Anonymous Coward” pasted “duplicate symbol” at http://hpaste.org/84144
23:17:49 <Vertue> lispy: done, http://hpaste.org/84144
23:18:09 <arbn> Vertue: Hello, Anonymous Coward.
23:18:16 <aviraldg> Another question, can you do mixed lists in Haskell? (weird question, I know, given Haskell's type system)
23:18:32 <arbn> aviraldg: Yes... but it's not natural.
23:18:45 <Vertue> arbn: Hello :-/
23:18:47 <arbn> aviraldg: You will soon see that you very rarely will want to do that.
23:18:48 <ion> aviraldg: Why do you want them? There’s probably a better way to do it.
23:19:16 <lispy> aviraldg: Yes you can but the solution is quite advanced
23:19:17 <aviraldg> General question -- learning :)
23:19:42 <arbn> aviraldg: Actually, you can do full-on dynamic typing in Haskell, but most people don't.
23:20:04 <lispy> Vertue: hpaste is slow to load :(
23:20:10 <arbn> aviraldg: And I suggest you wait until you're more familiar with Haskell before you try it. ;)
23:20:38 <Vertue> lispy: Yeah just noticed when I tried to change Author
23:20:58 <lispy> aviraldg: using a sum type is probably closer to what you're used to. Plus it's easy to do in Haskell and quite type safe.
23:21:35 <lispy> Vertue: try running: ghc-pkg check
23:22:21 <Vertue> lispy: Just some haddock warnings
23:23:26 <lispy> aviraldg: The first two solutions on this page should be easy to understand. Beyond that, I would say wait until you know more about Haskell: http://www.haskell.org/haskellwiki/Heterogenous_collections
23:23:48 <hpaste> Vertue pasted “duplicate symbol” at http://hpaste.org/84145
23:23:57 <hpaste> Vertue revised “duplicate symbol”: “duplicate symbol” at http://hpaste.org/84144
23:24:47 <aviraldg> arbn, trying out longer function definitions and I can see where your comment about GHCi is coming from :)
23:25:19 <johnw> Vertue: I've run into that exact problem before
23:25:30 <arbn> aviraldg: Yeah. Most people write their code in a file, and then load that into GHCi with ":l file.hs". It's an easier workflow.
23:25:45 <Vertue> johnw: Did you get it solved?
23:25:54 <lispy> Vertue: the problem is that directory is loaded twice
23:26:12 <lispy> Vertue: at different versions even
23:26:16 <johnw> Vertue: yes, I'm trying to remember what the problem here is
23:26:28 <lispy> Loading package directory-1.1.0.2 ... linking ... done.
23:26:29 <johnw> ah yes
23:26:32 <pharaun> woo that was kind of needlessly hard to do but i think i just got dyn-code loading to work
23:26:34 <lispy> Loading package directory-1.2.0.1 ...
23:26:37 <johnw> you are indirectly loading multiple versions of the directory package
23:26:46 <johnw> you have mismatched dependencies in your dep tree
23:26:54 <Vertue> johnw: makes sense...
23:27:04 <johnw> try manually deleting the older version of directory, and see who then complains, and you'll know which package to update
23:27:17 <johnw> often all you need to do is force-reinstall that package
23:27:21 <lispy> aviraldg: and you can set $EDITOR and then :e in ghci will do the rigth thing
23:27:24 <johnw> (and anyone else who was depending on the older version)
23:27:44 <Vertue> I'll give it a shot, how do I manually delete the older version?
23:27:55 <lispy> ghc-pkg list --user directory
23:28:06 <lispy> that will tell you which one is safe to delete
23:28:48 <Vertue> directory-1.2.0.1
23:28:59 <Vertue> which is the newer one <confused>
23:29:48 <lispy> Vertue: You've run into a subtle problem.
23:30:00 <lispy> Vertue: there are certain libraries that ship with ghc that should not be upgrade
23:30:12 <lispy> Vertue: but sometimes cabal upgrades them anyway.
23:30:17 <Vertue> lispy: lucky me...
23:30:29 <lispy> Vertue: we often call these libraries "boot libraries"
23:30:41 <arbn> It's not always a problem to have two versions of directory. You just need to make sure you don't statically compile both.
23:30:48 <lispy> Vertue: I think newer cabal might be smarter about this. Are you running 1.16.x?
23:30:51 <arbn> Tweak the cabal build file.
23:31:16 <johnw> Vertue: oh, you know when I used to get that error the most?
23:31:28 <Vertue> lispy: it is 1.16.0.2
23:31:28 <johnw> Vertue: when I had Haskell Platform installed, and also had installed my own packages via cabal
23:31:54 <lispy> Vertue: It might not solve _this_ particular problem, but in general I recommend folks to use cabal-dev: http://www.reddit.com/r/haskell/related/f3ykj/psa_use_cabaldev_to_solve_dependency_problems/
23:32:20 <Vertue> johnw: same here I have Haskell Platform via homebrew installed
23:32:29 <johnw> yeah, that's your issue
23:32:35 <johnw> drop it, and just use cabal directly
23:32:47 <johnw> after you drop it, rm -fr ~/.ghc ~/.cabal/lib
23:32:54 <johnw> then start from the beginning with: cabal install Cabal cabal-install
23:33:20 <Vertue> lispy: Thanks for the tip but you say it might not solve my issue?
23:33:34 <johnw> cabal-dev should solve the problem too
23:33:43 <Vertue> johnw: Not sure if I am brave enough for that...
23:33:52 <johnw> it requires no braveness
23:33:53 <lispy> Vertue: it kind of would in that cabal-dev ignores things in --user
23:33:58 <johnw> even the craven use cabal-dev to great effect
23:34:15 <Vertue> ah ok, will give it a go then
23:34:30 * arbn is a coward and uses cabal-dev.
23:34:39 <Vertue> johnw: so how do you bootstrap haskell without haskell platform?
23:34:49 <Vertue> what do you download?
23:34:54 <arbn> Vertue: Install ghc with homebrew.
23:34:55 <johnw> Vertue: i install ghc, and then I install cabal-install from its distro tarball
23:35:01 <johnw> from that point on, I just cabal install stuff
23:35:03 <ion> vertue: What i do: https://gist.github.com/ion1/2815423
23:35:23 <lispy> Vertue: You really only need to install ghc and then install cabal-install. Everything else can be bootstrapped from that. But...it would be better to make haskell platform better.
23:35:49 <Vertue> lispy: agreed, specially for noobs like me
23:36:10 <Vertue> but will give those instructions form ion a go
23:36:20 <lispy> ion: wow, yeah that's almost exactly what I do.
23:36:24 <johnw> lispy: but, HP doesn't move quickly, so it will always have old dependencies that will break people  who install directly via cabal
23:36:37 <pharaun> hp?
23:36:38 <johnw> what would be nice is if HP has a separate cabal which targeted a separate Hackage, meant only for upgrades to HP
23:36:43 <johnw> Haskell Platform
23:37:03 <pharaun> aha k
23:37:08 <johnw> stackage is like halfway between HP and raw Hackage
23:37:33 * lispy declares martial law on hackage
23:37:44 <[swift]> ion: super cool instructions, thanks for posting them!
23:37:59 <ion> np
23:38:37 <lispy> I think that ghc hq should modify their scripts so that you can install the cabal-install built during your ghc build.
23:38:53 <ion> That would be neat.
23:39:09 <lispy> The Haskell Platform could use that cabal-install or not. I don't care, but at least you would get cabal-install (if you wanted it) with each ghc install.
23:39:52 <arbn> lispy: Wasn't there also recent talk on the mailing list about splitting up cabal so that GHC could depend on less of it?
23:40:17 <lispy> arbn: yes although I didn't follow the therad
23:41:23 <lispy> arbn: I was more interested in using happy as the parser generator than in parsec
23:41:54 <lispy> That's something I feel I've learned the hard way; parser combinators are "neat" but not really very good for real-world use
23:42:06 <johnw> lispy: why do you say that?
23:42:17 <johnw> lispy: attoparsec is quite capable for real-world use, as is trifecta
23:42:28 <johnw> trifecta for cabal files would give great error messages for free
23:42:53 <lispy> johnw: Read what Levent has to say: https://plus.google.com/u/0/115503434720929428968/posts/MD8yAWJDBYJ
23:43:41 <lispy> johnw: it really comes down to a correctness argument
23:44:00 <lispy> with happy (and other parser generators) it can do some (or full) static analysis
23:44:03 <johnw> ah, this is not a combinator vs. generator argument
23:44:17 <lispy> applicative parsers (at least in theory) would also allow this but I'm not aware of any applicative library that does it.
23:44:19 <johnw> this is a recursive descent vs. proper LL(1)/LALR(1) argument
23:44:35 <johnw> if you write a manual RD parser, you can always introduce ambiguities which no one will discover but your users
23:45:23 <edwardk> "Case in point: We had a parsing bug in Cryptol when a new feature was added, which we did not realize for a good 6 months" this is a problem with parsing with something that has biased choice in the first place. happy can do glr, i have some gll code, each can handle an arbitrary context-free grammar, which is what you get when you can take any language extension and just bolt it into the language. but they come at the cost of a
23:45:23 <edwardk>  lot of the freedom of the monadic syntax.
23:45:23 <johnw> so he's arguing that the happy tool will give you a heads up on ambiguities, which is true, yacc does the same thing
23:46:07 <edwardk> lispy: i have some code for it, but i haven't shipped gll parsers yet. mostly just not sure how to get any reuse across them and my 'parsers' machinery, etc.
23:46:15 <johnw> yeah, so I wouldn't ding trifecta/parsec for this kind of error, I'd ding lack of testing and bolt-on hacks
23:46:36 <aviraldg> What does `=>` indicate in a type signature?
23:46:50 <lispy> aviraldg: it separates type class constraints from the rest of the type signature
23:46:58 <lispy> aviraldg: type class constraints on the left
23:47:25 <lispy> johnw: sorry, what is a "bolt on" hack?
23:47:41 <kryft> Hmm, I'm finding parts of chapter 10 of RWH a bit dense; should I keep studying it or move forward?
23:48:00 <aviraldg> For instance, given: let fib n = if n == 0 then 0 else if n == 1 then 1 else (fib (n-1)) + (fib (n-2))
23:48:06 <aviraldg> Why does ::type fib give me
23:48:07 <aviraldg> fib :: (Eq a1, Num a1, Num a) => a1 -> a
23:48:25 <lispy> kryft: make note that chpt 10 was tedious, skip it, and if you get stuck look at it again to see if it discusses what you missed
23:48:28 <lispy> kryft: ?
23:48:38 <edwardk> lispy: extending a grammar with trifecta/parsec/any combinator library that doesn't do list of successes with unbiased choice in some fashion means that you wind up with cases where your language extensions don't commute
23:48:45 <arbn> aviraldg: It's ingerred that a1 has to be a member of the Eq and Num typeclasses. You can look those up if you're curious.
23:48:50 <arbn> inferred*
23:48:56 <no-n> if I've written some functions in foo.hs and want to use them in bar.hs, what do I write in bar.hs?
23:48:58 <edwardk> reasoning about the extension you added becomes a global thing.
23:49:09 <lispy> no-n: import foo
23:49:19 <elliott> no-n: import Foo but you have to rename it to Foo.hs.
23:49:41 <no-n> ahh
23:49:42 <arbn> aviraldg: Eq is a typeclass for things that support equality, and Num is for number-like things. These are both reasonable constraints on the first argument of fib, right?
23:49:58 <johnw> lispy: what edwardk said :)
23:50:26 <edwardk> this is why tooks like elsa/elkhound exist in the c++ world. it gives a nice parser for c++ with ambiguity as a context-free grammar then they proceed to refine the parse using type info later. but by staying inside a context-free core, extensions can add new productions to any rule without invalidating the ability of other extensions to parse.
23:50:38 <aviraldg> arbn, ah, thanks! So GHC's figuring that out from the operations carried out on `n` - cool.
23:50:40 <edwardk> once you introduce biased choice you require global reasoning
23:50:51 <arbn> aviraldg: Yep.
23:51:09 <kryft> lispy: Fair enough. :)
23:51:30 <lispy> aviraldg: put this on your "To read later" list :) http://web.cecs.pdx.edu/~mpj/thih/thih.pdf
23:52:27 <no-n> Foo.hs:1:1: File name does not match module name: Saw: `Main' Expected: `Foo'
23:52:43 <ion> module Foo where
23:52:44 <lispy> kryft: a friend recently introduced me to the idea that for some books it can be a very effective strategy to read the book until you get stuck and then simply start over. I've been finding that it works way better than i would have guessed :)
23:52:46 <aviraldg> lispy, uh thanks :) I guess that goes on the "to read *much* later" list
23:52:59 <johnw> edwardk: have you seen Boost.Spirit?
23:53:03 <edwardk> yep
23:53:16 <no-n> ion: thanks!
23:53:18 <johnw> the main author of that was one of my sub-contractors at BoostPro
23:53:21 <lispy> aviraldg: perhaps? When I finally read it I regretted waiting so long. I recommend implementing it as you read it.
23:53:52 <arbn> lispy: That's my approach with Awodey's "Category Theory" at least with someone who's an idiot at math, like me. :)
23:54:06 <kryft> lispy: I think it's a pretty general concept, but I've always had trouble implementing it for psychological reasons. ;)
23:54:30 <aviraldg> Still in chapter 2 of RWH -- I guess I'll get a better grip on the syntax and some of the basic concepts of the language before trying anything else
23:54:52 <ion> aviraldg: Check out LYAH as well.
23:55:01 <lispy> aviraldg: sure, and you can supplement with chapters from LYAH
23:55:16 <arbn> aviraldg: You should probably know that RWH is suggested usually as a "second book" on Haskell. Read it if you want, but I found LYAH *much* easier as a beginner.
23:56:09 <lispy> arbn: I have that book now but I haven't found enough time to make it far enough to get stuck.
23:56:15 <lispy> arbn: seems like a great book so far
23:56:38 * lispy has been too busy implementing a toy gmachine and a Core -> gmachine compiler
23:56:40 <arbn> lispy: Hehe. I'm *really* bad at math, and tried to prove a lot of the "exercises for the reader".
23:56:55 <aviraldg> The design of LYAH's webpage (and its name) gave me the impression that it was intended for people new to programming in general, so I started with RWH. Is that not the case?
23:57:02 <lispy> arbn: awesome. That's the way to do it :)
23:57:30 <arbn> aviraldg: It's intended for those new to functional programming, but it assumes that you've programmed before.
23:57:35 <ion> aviraldg: If you don’t happen to be familiar with languages like Haskell you might as well be new to programming in general. :-P
23:57:46 <lispy> arbn: in that case, you might prefer a classic like this one: http://www.haskell.org/tutorial/
23:57:51 <lispy> arbn: or Bird's book
23:58:08 <lispy> oops
23:58:10 <lispy> aviraldg: ^^
23:58:13 <lispy> aviraldg: http://www.amazon.com/Introduction-Functional-Programming-using-Haskell/dp/0134843460
23:58:19 <aviraldg> Well, Python isn't really considered a "true" functional language, so...
23:58:37 <arbn> aviraldg: When I use Python, I feel handicapped by its lack of functional features.
23:58:45 <arbn> aviraldg: I think LYAH would be at your level, personally.
23:59:13 * lispy thinks if someone can program proficiently is a language as difficult as python that haskell should be a walk in the part
23:59:14 <arbn> aviraldg: Also, LYAH has chapters that I still re-read and find interesting. It's really good.
23:59:16 <lispy> park*
23:59:42 <lispy> I learned a long time ago that I'm simply not smart enough to program in python. There are so many moving parts to keep track of.
23:59:50 <aviraldg> I'll check that out when I'm stuck with RWH :)
23:59:54 <aviraldg> lispy, difficult?
