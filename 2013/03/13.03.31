00:07:44 <xpika> how do i input a lambda in OSX? λ
00:08:19 <bss03> λ
00:09:17 <otters> like that
00:12:26 <xpika> im looking for a shortcut
00:12:41 * hackagebot cryptohash 0.8.4 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.8.4 (VincentHanquez)
00:14:51 <sw2wolf> xpika: (global-set-key (kbd "<f5>") '(lambda () (interactive) (insert #x3bb)))
00:22:45 <Nisstyre-laptop> So, uh, any ideas on how to make this cleaner? http://ideone.com/5296Wr
00:22:54 <Nisstyre-laptop> would using the Either transformer help?
00:23:11 <mapf> is there something like attoparsec but without backtracking? for string bytestring parsing.
00:23:46 <mikeplus64> mapf: cereal or binary?
00:25:31 <mapf> ok, I'll try cereal.
01:39:21 <BIGBOOMBA> I'm confused about the explanation of monads given here: http://en.wikibooks.org/wiki/Haskell/Category_theory#cite_ref-2
01:39:53 <BIGBOOMBA> join and >>= are defined as mutually recursive functions
01:40:06 <shachaf> They're not actually mutually recursive.
01:40:17 <shachaf> They're default definitions -- you define one of them in the instance and the other one gets defined for you automatically.
01:41:01 <BIGBOOMBA> Oh, that has to make more sense, because if they were mutually recursive you'd get an infinite loop.
01:41:14 <shachaf> Yep.
01:41:48 <BIGBOOMBA> Whoever maintains that might want to make that clear, because it's not.
01:42:00 <shachaf> It's a wiki!
01:42:28 <Radish> is there an easy way to do fmod in haskell?
01:42:31 <BIGBOOMBA> Well, I'm not going to go and change it myself, since I'm far from an expert.
01:42:36 <shachaf> It got seven edits in 2012 and none so far in 2013.
01:42:47 <shachaf> OK, true, I suppose.
01:42:53 <shachaf> Maybe make a note about it in the talk page.
01:42:59 <shachaf> I don't know how the wikibook works.
01:43:03 <EarlGray> Hello
01:43:13 <Radish> EarlGray: hi
01:45:04 <EarlGray> Is there a function for altering immmutable arrays like (STUArray s i e -> STUArray s i e) -> UArray i e -> UArray i e
01:45:44 <EarlGray> I know that it's just a wrapper for thaw and freeze, but I want a standard one
01:45:57 <EarlGray> Quick hoogling produced no results
01:49:54 <Radish> I dunno and hardly anyone is on I guess sorry
01:55:47 <EarlGray> Yep, I even can't write a generic function for this
01:57:01 <hpaste> EarlGray pasted “alterUArray” at http://hpaste.org/84906
01:57:21 <EarlGray> why this does not work?
01:57:33 <EarlGray> Can I fix it?
01:57:36 <EarlGray> *or
02:07:46 <matthiasgoergens> EarlGray, let me have a look.
02:08:16 <matthiasgoergens> EarlGray: How does it not work?
02:10:21 <EarlGray> When I specify some types like UArray Int Int this works: it takes an immutable array, thaws it, applies a function :: STUArray s Int Int -> ST s () and freezes it back
02:10:48 <EarlGray> When I try to make this polymorhic, I have a bunch of crazy error messages from GHC
02:10:49 <matthiasgoergens> EarlGray: sorry, lost connection.  did you write anything in the mean time?
02:11:05 <EarlGray> [12:10:09] <EarlGray> When I specify some types like UArray Int Int this works: it takes an immutable array, thaws it, applies a function :: STUArray s Int Int -> ST s () and freezes it back
02:11:08 <matthiasgoergens> could you paste them?
02:11:24 <matthiasgoergens> them = the crazy error messages.
02:11:26 <Cale> EarlGray: you'll need to turn on ScopedTypeVariables and explicitly quantify the type variables you want to scope over the whole definition
02:11:58 <EarlGray> Cale: thanks, I'll try that
02:13:19 <matthiasgoergens> Cale, I was going for the socratic approach. ;o)
02:15:34 <Cale> Actually, there are several other things you'll run into here...
02:16:07 <Cale> alter needs to be polymorphic in a certain way
02:16:09 <hpaste> EarlGray pasted “alterUArray+errors” at http://hpaste.org/84907
02:16:17 <Cale> which means that you need higher rank polymorphism
02:17:15 <EarlGray> I'm a newbie with arrays in particular and multi-param classes in general (
02:17:42 <Ralith> the tricky bit there is actually ST.
02:18:01 <Cale> Trying to write higher order polymorphic things which act on ST actions can be tricky
02:18:15 <Cale> Because of the way that the s parameter needs to remain polymorphic
02:18:24 <EarlGray> That's the incentive to learn :)
02:18:44 <EarlGray> I just want to know what do I need to understand this
02:19:13 <EarlGray> And right now, how it can be fixed
02:22:45 <Cale> Well, this works:
02:22:56 <hpaste> Cale annotated “alterUArray” with “alterUArray (annotation)” at http://hpaste.org/84906#a84909
02:23:10 <Cale> sorry, that's with {-# LANGUAGE ScopedTypeVariables, RankNTypes, FlexibleContexts #-}
02:26:57 <Cale> However, you'll have a tricky time applying that in most cases, I bet.
02:27:37 <Cale> Because you'll need to have defined the argument you're passing as alter within the ST action that you're applying the thing in, so that the s will match.
02:28:49 <joaopizani> save
02:50:50 <circle> f = \x -> x
03:15:12 <EarlGray> Cale: thank you very much, I'll try wrap my head around all of these `forall`s
03:16:02 <EarlGray> Another strange thing is that it runs fine without runST
03:16:29 <EarlGray> but with runST it still fails to compile
03:16:33 <Wizek> In the terminal using haskell, can I grab a keypress? e.g. when the user presses 'k', instead of outputting the character k, I'd like to scroll the output.
03:18:40 <merijn> Wizek: You want to put the terminal input in raw mode (no buffering, etc), instead of cooked. But I forgot how to do that in haskell
03:19:50 <arkeet> Wizek: turn off input buffering, and then use getChar.
03:20:20 <arkeet> also turn off echoing, I suppose.
03:20:31 <arkeet> see hSetBuffering and hSetEcho
03:20:32 * Wizek looks into how to turn those off
03:20:52 <arkeet> maybe you'll want to use something like curses, though
03:21:43 <merijn> arkeet: vty + vty-ui are the superior way to do terminal UI's in haskell
03:24:22 <arkeet> I was trying to be safe by saying "something like".
03:25:31 <merijn> Anyone here that has worked with ghc + cygwin? (i.e. I want to compile some stuff relying on the unix package on windows...)
03:52:16 <Wizek> arkeet: I've set stdout to NoBuffering, and set echo to False, but getChar still waits for enter. Can I make getChar consume only one character and not wait for enter?
03:52:38 <arkeet> you want to set stdin to NoBuffering, not stdout.
03:59:02 <Wizek> arkeet: will this one `sequence_ $ cycle [do y <- getChar; putChar 'a']` work if I set the correct stream settings?
03:59:11 <ChongLi> arkeet: thinking of writing a roguelike in Haskell?
03:59:18 <arkeet> ChongLi: not I.
03:59:37 <arkeet> Wizek: it should, but note that you can use `forever` instead.
03:59:40 <arkeet> :t forever
03:59:42 <lambdabot> Monad m => m a -> m b
04:00:01 <ChongLi> oh, yeah
04:00:07 <ChongLi> I need to pay more attention :)
04:00:33 <ChongLi> still early (just woke up)
04:00:56 <quchen> Using bind may be clearer there.
04:00:56 <ChongLi> for Roguelikes it's probably preferable to use something like libtcod
04:01:00 <quchen> forever $ getChar >>= putChar
04:01:43 <quchen> (Thinking about that again, in the game there will probably be something between those Char commands.)
04:02:06 <dudlite> having problems understanding function composition
04:02:25 <ChongLi> dudlite: okay
04:02:34 <ChongLi> dudlite: the composition operator? (.)
04:02:38 <dudlite> Yep
04:02:48 <dudlite> Any general example or something you could show me?
04:02:53 <ChongLi> foo = bar . baz
04:02:54 <dudlite> found google search a little confusing
04:03:00 <arkeet> (f . g) x = f (g x)  -- the most general example.
04:03:03 <ChongLi> so in this case
04:03:21 <ChongLi> think of this function as a snake
04:03:28 <ChongLi> baz is the mouth of the snake and bar is the tail
04:03:35 <dudlite> ok
04:03:42 <Wizek> Let's make the buffering issue go away first :) I've tried `hSetEcho stdout False; hSetBuffering stdout NoBuffering; hSetEcho stdin False; hSetBuffering stdin NoBuffering;` and other combinations as well, but non if those resulted in putting out 'a's when I pressed keys
04:03:49 <ChongLi> baz consumes the input and returns it to bar
04:04:08 <arkeet> Wizek: you probably don't want hSetEcho stdout False.
04:04:12 <arkeet> I have no idea what that would do.
04:04:14 <ChongLi> thus foo is the entire snake
04:04:22 <ChongLi> it does the work of baz and bar
04:04:33 <arkeet> I guess it does nothing.
04:04:34 <dudlite> hmm
04:04:39 <ChongLi> dudlite: are you familiar with shell scripting (in particular pipes)?
04:04:40 <arkeet> Wizek: what OS?
04:04:47 <Wizek> arkeet: Ubuntu 12.10
04:04:52 <arkeet> so, linux.
04:05:00 <ChongLi> something like:
04:05:08 <dudlite> ermm chong did it in second year uni, but very little
04:05:19 <dudlite> but i see what you mean
04:05:27 <Wizek> arkeet: correct.
04:05:27 <ChongLi> ls -al | grep foo
04:05:37 <arkeet> Wizek: I don't know then.
04:05:43 <arkeet> could you paste the entire code?
04:05:48 <arkeet> @hpaste
04:05:48 <lambdabot> Haskell pastebin: http://hpaste.org/
04:05:57 <ChongLi> in this case, you are listing all files in the current directory and then piping that to grep
04:06:14 <ChongLi> which filters the lines so that only those matching foo are returned
04:06:17 <dudlite> could I paste the question for my homework assignment?
04:06:22 <dudlite> don't need an answer, just help
04:06:26 <ChongLi> okay
04:06:29 <dudlite> thanks
04:07:18 <dudlite> 5.Show how [f x | x <- xs, p x] can be expressed using only map, filter and (.)
04:07:33 <Wizek> arkeet: sure, moments
04:07:40 <dudlite> I can write it without the composition, but that is the whole point of the question lol
04:07:53 <ChongLi> what have you written so far?
04:08:11 <arkeet> oh my, @pl gives a mess for that.
04:08:13 <dudlite> um well nothing using composition, this without it myfunction f1 f2 xs = map f1 (filter f2 xs)
04:09:03 <ChongLi> are you familiar with currying in haskell?
04:09:04 <dudlite> so i know map applys a function to every item in a list
04:09:05 <arkeet> dudlite: with composition, you would be able to write that in the form  myfunction f1 f2 = ...
04:09:07 <arkeet> without the xs.
04:09:14 <hpaste> Wizek pasted “For arkeet” at http://hpaste.org/84914
04:10:12 <dudlite> so something like myfunction f1 f2 = map f1 . filter f2
04:10:18 <ChongLi> exactly
04:10:29 <ChongLi> you see
04:10:36 <ChongLi> map f1 returns a function
04:10:41 <ChongLi> which maps f1 over something
04:10:59 <ChongLi> filter f2 likewise returns a function which filters something with f2
04:11:13 <arkeet> Wizek: hmm, it works in ghci but not when compiled. uhh
04:11:25 <ChongLi> so in this case you're merely composing these two returned functions
04:11:37 <ChongLi> and the result is another function
04:11:43 <dudlite> ahhh i see
04:11:47 <dudlite> that actually makes sense
04:11:51 <dudlite> thanks alot.
04:11:55 <tsinnema> can someone help this haskell newbie read what HLeftUnion does here?: http://hackage.haskell.org/packages/archive/HList/0.2.3/doc/html/src/Data-HList-Record.html
04:11:56 <ChongLi> no problem
04:12:27 <ChongLi> @pl myfunction f1 f2 = map f1 . filter f2
04:12:27 <lambdabot> myfunction = (. filter) . (.) . map
04:12:32 <ChongLi> and there you go
04:12:47 <ChongLi> a fully point free version :)
04:12:51 <dudlite> awesome
04:12:52 <dudlite> thanks dude
04:13:03 <ChongLi> don't submit that unless you aren't expected to explain it
04:13:03 <quchen> Yeah, don't use the pointfree version.
04:13:42 <dudlite> hmm one more question
04:14:01 <ChongLi> sure
04:14:35 <dudlite> oh wait
04:14:41 <dudlite> as I was typing it out
04:14:44 <dudlite> answered my own question
04:14:46 <dudlite> lol
04:14:55 <ChongLi> rubber duck strikes again!
04:15:03 <tsinnema> :)
04:15:08 <dudlite> haha
04:15:13 <arkeet> uh
04:15:16 <ChongLi> http://en.wikipedia.org/wiki/Rubber_duck_debugging
04:15:17 <dudlite> anyway, thanks for the help.  Cya!
04:15:27 <arkeet> Wizek: it's working here.
04:15:29 <merijn> dudlite: . is really just a shell pipe with the argument order reversed ;)
04:15:29 <arkeet> ??
04:15:31 <ChongLi> no problem, come back any time!
04:15:41 <dudlite> thanks =D
04:16:06 <xQuasar> HASKELL IS FOR FUCKIN FAGGOTS. YOU'RE ALL A BUNCH OF FUCKIN PUSSIES
04:16:09 <xQuasar> JAVASCRIPT FOR LIFE FAGS
04:16:36 <luite> hello
04:16:48 <ChongLi> somebody has a mental illness!
04:16:52 <merijn> Wow...I suddenly see the error of my ways and feel compelled to write Node.js!
04:16:53 <luite> you might be pleased to learn that you can compile haskell to javascript now
04:16:54 <genisage> hi
04:17:11 <sipa> @where ops
04:17:12 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconnor Saizan shapr sjanssen ski wli
04:17:12 <lambdabot> xerox
04:18:25 <xQuasar> FUCK YOU AND YOUR HUSSY OPS
04:18:28 <xQuasar> THEY CAN'T DO SHIT TO ME CUNTS
04:18:44 <quchen> xQuasar: While I don't think anything is wrong with faggots to the point where "faggot" isn't insulting anymore, I assure you we have heterosexuals in our language as well.
04:18:52 <quchen> Haskell is invariant under gender. Really!
04:19:01 <Iceland_jack> quchen++
04:19:04 <merijn> I don't blame him, I'd be this angry to if I had to write javascript all day too
04:19:22 <xQuasar> FUCK YOU STRAIGHT CUNTS
04:19:24 <xQuasar> BESTIALITY IS THE BEST
04:19:31 <quchen> merijn: Lol. And when I write that I mean it :D
04:20:01 <quchen> xQuasar: Do you have any specific questions?
04:20:12 <merijn> This is sort of like a puppy trying to be angry with you...it's just kinda adorable to see him think he has any effect :)
04:20:22 <quchen> xQuasar: You're offtopic right now. This is a Haskell help channel. Do you have Haskell questions?
04:20:37 <quchen> xQuasar: We'd love to help you make your first steps.
04:20:55 <tsinnema> hey -- is there a proper way to whine about no one having responded to a question? :)
04:20:59 <xQuasar> i just want to get kicked out of a bunch of channels for fun
04:21:05 <quchen> Have you seen LYAH? It's a very enjoyable book on Haskell. It also has a reputation of being very uplifting.
04:21:07 <xQuasar> why is no one cooperating with me
04:21:08 <quchen> @where lyah
04:21:08 <lambdabot> http://www.learnyouahaskell.com/
04:21:17 <tsinnema> in soviet russia, haskell learns a you
04:21:20 <merijn> tsinnema: Yeah, wait 30 minutes or more and try again :)
04:21:23 <Iceland_jack> xQuasar: We are cooperating with you, you're just not aware that your goal is learning Haskell
04:21:26 <ChongLi> xQuasar: why not learn some Haskell instead?
04:21:41 <xQuasar> alright i'll admit i lose
04:21:46 <merijn> Ha, sometimes I forget how hard it is to troll haskell :)
04:21:49 <nxorg8> #haskell is awesome :-)
04:21:52 <xQuasar> what's haskell good for though
04:21:53 <quchen> xQuasar: But there is so much to win here!
04:22:02 <xQuasar> i'm more into gamedev
04:22:09 <Iceland_jack> figures
04:22:11 <arkeet> it's good for writing programs.
04:22:17 <xQuasar> what kind of programs?
04:22:21 <ChongLi> xQuasar: any kind
04:22:23 <arkeet> "what's C++ good for?"
04:22:28 <Iceland_jack> xQuasar: The ones that run on comput-ars.
04:22:28 <ChongLi> it's a general purpose language
04:22:43 <luite> xQuasar: frp can be useful for writing games, and with ghcjs you can compile them to javascript to make web games
04:23:00 <tsinnema> merijn, yeah, seems reasonable :)
04:23:01 <ChongLi> seriously though, if you learn it you may completely change your perspective on programming
04:23:08 <snowylike> and there's HGamer3D....
04:23:09 <xQuasar> i have absolutely no idea what frp and ghcjs are
04:23:09 <luite> i tested reactive-banana with ghcjs last week, works now, and sodium was already supported
04:23:16 <ChongLi> that's okay
04:23:29 <xQuasar> I'm assuming haskell is nothing like c++, php and java? because that's all i know so far
04:23:34 <luite> xQuasar: functional reactive progarmming, and a haskell->javascript compiler based on ghc
04:23:40 <Iceland_jack> Haskell is very different from C++ and PHP
04:23:49 <Iceland_jack> (and Java…)
04:23:52 <merijn> tsinnema: As far as left union goes, I assume (I'm not 100% sure) that it does union and inn case a label is in both lists it keeps the value from the label in the left list
04:24:06 <xQuasar> it looks difficult
04:24:07 <tsinnema> merijn, thanks -- that
04:24:09 <tsinnema> afaef
04:24:20 <ChongLi> xQuasar: even if you decide not to use Haskell in the future, having learnt it you may find new things to apply in your other languages
04:24:29 <ChongLi> learning concepts such as immutability
04:24:39 <merijn> tsinnema: That'd be the most usual definition of left and right unions
04:24:40 <tsinnema> that's what i'm hoping it is -- but it's not documented and i'm not fluent enough yet to easily see whether that's what's going on
04:24:41 <Iceland_jack> xQuasar: C is difficult in a non-rewarding way while Haskell is difficult in very rewarding ways, imo.
04:24:42 <ChongLi> and bottom-up design
04:24:52 <Iceland_jack> Give it a go
04:25:09 <ChongLi> this is the first I've heard of sodium
04:25:17 <ChongLi> how does it compare to reactive-banana?
04:25:22 <quchen> xQuasar: It's a little about relearning how to program. Like learning a language from the other side of the planet that turns out to work well in your homecountry ;-)
04:26:09 <xQuasar> i can't believe my attempt to troll has actually got me convinced that i should give haskell a go
04:26:11 <luite> ChongLi: I haven't personally used sodium yet, but the goals are similar, being a practical non-arrow frp lib with a clean interface
04:26:26 <ChongLi> luite: I'm browsing the docs now
04:26:31 <ChongLi> it seems very clean inded
04:26:53 <xQuasar> i shall be back later
04:26:54 * Iceland_jack . o O ( feels like Haskellers would invite Jehova's witnesses in for tea just to proselatize Haskell to them )
04:26:57 <xQuasar> to actually learn some haskell
04:27:04 <ChongLi> xQuasar: haha, okay
04:27:08 <xQuasar> but now i must rest my weary head and recover from my cold o/
04:27:15 <Hafydd> Iceland_jack: that's a marvellous idea.
04:27:25 <luite> ChongLi: i heard from Stephen (sodium) last week, he said that he talked to Heinrich (banana) and they discovered that they did many things the same way
04:27:38 <xQuasar> Iceland_jack: you know, I wouldn't be surprised if you were able to.
04:28:04 <Iceland_jack> “Have you heard about our lord J…” — No actually, first I'd want to discuss this marvelous statically-typed purely functional programming language: Have you heard of Haskell?
04:28:09 <xQuasar> Man, I tried to troll like 10 channels and I only got kicked from #bitcoin-dev
04:28:25 <xQuasar> I'm probably the biggest failure of a troll ever.
04:28:30 <ChongLi> xQuasar: you may have had more success at a different time of day
04:28:34 <luite> ChongLi: i don't really know if one is better, reactive-banana felt a bit messy, and it relies on some unspecified behaviour in GHC that made it harder to support with ghcjs
04:28:40 <ChongLi> say, when north americans are on
04:28:42 <luite> but maybe it's not that much work to clean it up
04:28:47 <Iceland_jack> xQuasar: You'll make up for it by kicking ass in Haskell
04:29:38 <ChongLi> luite: yeah, FRP is still pretty young
04:29:51 <ChongLi> I think we'll see quite a few more libraries popping up
04:30:01 <ChongLi> before we all figure out what the hell we're doing with it :)
04:30:17 <xQuasar> Alright thanks guys, I'll be back later to actually learn some haskell for real
04:30:19 <luite> ChongLi: yeah I just wanted something to test the new threading and event handling implementation int he ghcjs runtime
04:30:19 <xQuasar> bye
04:30:22 <ChongLi> bye
04:30:31 <ChongLi> threading?!
04:30:46 <luite> I'll explore building more extensive frp web interfaces later
04:30:51 <luite> yeah it has green threads
04:31:00 <ChongLi> how well does threading work in the js code?
04:31:03 <ChongLi> is there a lot of overhead?
04:31:07 <luite> with a preemptive scheduler
04:31:09 <luite> not really
04:31:17 <ChongLi> that's totally sweet
04:31:39 <Hafydd> The trick is to agree with everythign they say, but by drawing a ridiculous analogy to Haskell programming.
04:31:40 <ChongLi> Haskell's threads are so much easier to reason about than callback hell
04:31:44 <luite> most of the overhead is because we have to do tail call optimization, threading is cheap after that
04:31:47 <luite> yes
04:31:53 <quchen> So yeah, I couldn't resist: http://www.reddit.com/r/haskell/comments/1bcqvw/trolling_haskell/
04:32:04 <luite> i added async exceptions two weeks ago
04:32:27 <luite> now you can do something like: maybeResult <- timeout 1000000 (doXHR "someurl")
04:32:29 <ChongLi> quchen: ahh, that's great
04:32:46 <luite> the doXHR will suspend the current thread, the result wakes it up again
04:32:54 <ChongLi> wow
04:32:55 <luite> and the timeout will just send an async exception to that thread
04:33:38 <ChongLi> hopefully javascript will eventually add real tail call support
04:33:46 <ChongLi> so we don't have to transform everything into trampolines
04:33:46 <luite> it's planned for ES6
04:34:14 <luite> a transformation is still required since it's still inherently single threaded, so we manage our own stacks
04:34:46 <ChongLi> ahh
04:34:53 <ChongLi> yeah, of course :)
04:35:06 <ChongLi> continuations for the win!
04:35:09 <luite> but doing direct calls that the js engine can optimize, inline etc, will probably already help a lot
04:35:59 <luite> i tested doing deeper calls and then throwing exceptions to the trampoline, but that didn't help so far
04:36:49 <luite> ChongLi: the xhr thing is supported with "foreign import javascript safe", safe imports get a callback function, which wakes up the haskell thread if oyu call it
04:37:01 <luite> unsafe calls have to produce the result immediately
04:37:09 <ChongLi> that's pretty cool
04:37:37 <luite> it's a better fit for javascript than the waitRead# and waitWrite# primops
04:37:39 <ChongLi> it's nice to see you're using the Closure compiler
04:38:05 <luite> yeah the new code generator doesn't quite work with it yet, some stuff breaks, but that's on the list of things to fix
04:38:43 <ChongLi> I did a bunch of dabbling in ClojureScript and that was one of the big selling points of it
04:38:43 <luite> I'm also doing some basic javascript optimization and minification to make the code before closure compiler a bit smaller and easier to read
04:39:05 <ChongLi> but I got really frustrated dealing with cryptic errors
04:39:31 <ChongLi> I think Haskell's types will go a long way to avoid that problem
04:39:45 <luite> yeah debugging with ghcjs is not terribly easy, one haskell function usually gets translated into dozens of javascript functions
04:40:00 <luite> but if it works in ghci, and not with ghcjs, it's probably a bug in the compiler
04:40:06 <luite> unless you messed up your foreign functions
04:40:10 <ChongLi> sure, but you have a lot more confidence that the Haskell code is correct
04:40:19 <ChongLi> thanks to the types :)
04:40:24 <luite> right
04:40:59 <ChongLi> in cljs everyone is basically in limbo until source maps are added
04:41:49 <ChongLi> hopefully they will eventually make it to ghcjs as well
04:42:25 <ChongLi> just to get a line and column number in your Haskell source file
04:42:38 <luite> ChrisDone has written some source-maps impl
04:42:47 <luite> but it will probably be quite imperfect
04:43:02 <luite> not because of the source maps, but because of all the inlining and specialization
04:43:07 <ChongLi> yeah
04:43:40 <ChongLi> perhaps we'll need debug builds to avoid some of that
04:44:13 <ChongLi> although it could be really frustrating to have bugs that only show up in optimized builds
04:44:21 <luite> ghcjs has a debug setting which adds more runtime information to the haskell heap objects
04:44:33 <ChongLi> oh nice
04:44:36 <luite> which i also want to abuse to animate realtime reduction of haskell things to whnf
04:45:56 <ChongLi> FFI is not supported?
04:45:58 <hiptobecubic> turnaround time is fast here, http://www.reddit.com/r/haskell/comments/1bcqvw/trolling_haskell/
04:46:20 <ChongLi> hmm, you mentioned foreign import javascript safe
04:46:40 <ChongLi> I guess this part of the README.markdown is old
04:49:28 <arkeet> whoever maintains snap should be aware that snap 0.11.2 builds with lens 3.9.0.2.
04:51:04 <merijn> arkeet: Doesn't hackage show a maintainer email for it?
04:51:09 <merijn> @hackage snap
04:51:09 <lambdabot> http://hackage.haskell.org/package/snap
04:51:16 <arkeet> sure.
04:51:36 <merijn> Might be more efficient to email that instead of mentioning it here ;)
04:51:53 <arkeet> they've already bumped the lens dependency on git so I guess they know.
04:52:57 <tdammers> hehe... in sovjet russia, #haskell troll YOU!
04:55:14 <quchen> Trolling? We might have changed his life there.
04:55:58 <luite> ChongLi: FFI is supported
04:56:22 <luite> ChongLi: there's a patch to add the "foreign import javascript" calling convention that will hopefully be in 7.8.1
04:56:33 <ChongLi> luite: nice
04:56:45 <quchen> luite: Wait what? A Javascript FFI?
04:56:50 <`cc`> the trolls get trolled
04:57:20 <luite> ChongLi: and "foreign import ccall" also works, for compatibility, but you don't get nice things like async and things like: foreign import javascript "console.log($1)" js_log :: JSString -> IO ()
04:57:51 <ChongLi> luite: wait, you mean the C library gets compiled into the js file?
04:59:22 <luite> ChongLi: no the call gets translated to a javascript call, where you're responsible for the implementation. sometimes it might make sense to compile the real C file to javascript (with emscripten), but usually you just want to make your own, for example the cbits from text: https://github.com/ghcjs/shims/blob/master/pkg/text.js , or integer-gmp: https://github.com/ghcjs/shims/blob/master/src/integer.js
05:00:16 <ChongLi> luite: ahh, that would be really cool
05:00:34 * hackagebot fluent-logger 0.1.1.1 - A structured logger for Fluentd (Haskell)  http://hackage.haskell.org/package/fluent-logger-0.1.1.1 (NoriyukiOhkawa)
05:00:36 * hackagebot fluent-logger-conduit 0.2.0.1 - Conduit interface for fluent-logger  http://hackage.haskell.org/package/fluent-logger-conduit-0.2.0.1 (NoriyukiOhkawa)
05:00:47 <luite> conversion between Text to JSString (a real javascript string) is pretty fast because it calls some ffi that converts the underlying (typed array) buffer that text uses directly
05:00:47 <merijn> luite: Are you getting paid to work on this JS stuff or are you doing it in your free time?
05:01:02 <ChongLi> compile a high-performance mutation-based library with emscripten and then access it through FFI
05:01:24 <quchen> Constructors for GADTs always have to return the data type I'm construcing, right? Or is there some way to do "data Foo a where Qux :: Foo a -> a"
05:01:37 <luite> merijn: it's not all free time ;p
05:01:43 <merijn> quchen: The former
05:01:59 <merijn> quchen: They're called constructors for a reason
05:02:20 <merijn> quchen: How would "Qux :: Foo a -> a" make sense? What would that do?
05:02:47 <quchen> merijn: I don't know, but I'm also fairly new to GADTs. That's why I'm asking.
05:03:11 <quchen> I just wanted to avoid that "oh if only someone had told me before" moment in case "Foo a -> a" worked. :-)
05:03:41 <`cc`> :t (2^)
05:03:42 <lambdabot> (Integral b, Num a) => b -> a
05:04:04 <merijn> quchen: "data Foo a where Qux :: a -> Foo Int" is the type of stuff you use GADTs for
05:04:26 <quchen> merijn: Yes, of that I know.
05:04:54 <`cc`> is there a big difference between  Qux :: Foo a -> a  and  Qux :: (Foo a) => a -> a
05:04:59 <quchen> merijn: I've basically got a design problem right now and I'm trying to figure out the best way of solving it.
05:05:02 <merijn> The point is that you get to enforce types in the constructor, but being constructors they're still expect to construct the type they're consturctors of
05:05:05 <arkeet> `cc`: very
05:05:08 <merijn> quchen: What's the problem?
05:05:46 <`cc`> arkeet,  ah yes I see
05:05:47 <merijn> `cc`: The former says "given a 'Foo a' I can return an a", the latter says "if a is an instance of Foo, then given an a I can return an a"
05:05:54 <`cc`> Foo a is a type constructor
05:06:07 <k0ral> Hello, I have a question for gtk2hs maintainers/users: when registering a callback on a gtk signal, is it necessary to use postGUISync inside the callback ? put it differently: are gtk callbacks run in a different thread ?
05:06:24 <merijn> Foo is a type constructor, "Foo a" applies that constructor to a to return a type :)
05:06:37 <quchen> merijn: I've got a library that does some file system manipulations. Due to the nature of that, debugging may be hard when using it. For that reason, I want a module implementing an identical API that does nothing but print "would have done XY now" to the terminal. In a program, switching from one to the other would merely be a change in imports.
05:06:52 <`cc`> yes right
05:07:05 <`cc`> Foo a is a type
05:07:07 <quchen> merijn: Enforcing the same API is easily done with classes and dummy types, but it's a little smelly.
05:07:15 <quchen> (That's what I have right now.)
05:07:39 <merijn> Use DataKinds! ;)
05:07:47 <merijn> (that only works in >7.6)
05:07:49 <quchen> ;) <-- ?
05:08:00 <quchen> Is that a "just kidding" smiley?
05:08:17 <arkeet> so the ghc binary packages require libgmp.so.3
05:08:19 <arkeet> where do I get one? :(
05:08:21 <merijn> It's a "little bit kidding" smiley, DataKinds are nice, but 7.6 only and don't get you all that much
05:08:27 <quchen> I'm on the platform right now so no data kinds anyway. But I should have a look at them I guess
05:08:28 <arkeet> I have a libgmp.so.10 on my system.
05:09:34 <merijn> quchen: Right now I have some code where I have records, which are either Data or Control records and I enforce that using GADT and DataKinds, see: https://github.com/merijn/SNet2.0/blob/master/SNet/Types.hs
05:10:12 <merijn> Not sure if that helps with your API issue
05:10:33 <merijn> The advantage of that code is that "Record Int" is a kind error
05:10:50 <quchen> merijn: Where's the DataKinds part in that code?
05:10:55 <merijn> Since "Record :: RecType -> *"
05:11:17 <merijn> quchen: I'm using the RecType constructors as types and the RecType type as a kind
05:11:50 <merijn> DataKinds lets you write data types with kinds other than * and ->
05:12:00 <quchen> Oh, so "data Record (t :: RecType) where" means "t has whatever kind RecType has"?
05:12:08 <quchen> So that would be * here
05:12:09 <luite> merijn: so far development has been mostly under the radar, other than that i mention it occasionally on irc, since we had to completely redo the stacks and heaps to get better performance and support for some features (like async exceptions and black holes), so it's not been really usable for end users. it's looking better now though, a cabal installable version works decently now, but requires GHC HEAD, so a real release will still have to wait a bit
05:12:33 <merijn> quchen: No, it means "t :: RecType", i.e. the kind of t is "RecType", rather than * as it usually for most data types
05:12:38 <arkeet> never mind, I know what to do now.
05:13:09 <merijn> quchen: The only types of kind RecType are the constructors Control and Data. Any other type is a kind error, since all other types have kind * (or something else if they're DataKinds types too)
05:13:43 <merijn> quchen: DataKinds lets you use value constructors as type constructors and types/type constructors as kind/kind constructors
05:14:15 <quchen> merijn: I see.
05:14:28 <merijn> brb
05:14:33 <quchen> Sounds a little like "could be useful but I wouldn't recognize the pattern in practice" though ;-(
05:16:03 <quchen> Once you open the door to those extensions there's a huge pile of unknown falling on you haha
05:20:05 <chrisdone> https://dl.dropboxusercontent.com/u/62227452/Internets/trollinghaskell.html
05:21:24 <mauke> "your language bad" ?
05:21:28 <Kinnison> If you just made that, then your 'Your language..." needs an 'is'
05:21:30 <Kinnison> snappish
05:32:33 <ChongLi> that perfectly sums it up!
05:33:54 <arkeet> switched to 7.6.2. decided to actually install each library with profiling support now.
05:45:24 <jpcooper> hello
05:45:45 <jpcooper> I have a src/ folder which I would like to include in the source path when compiling. How can this be done?
05:46:00 <quchen> ghc -i:path I think
05:46:05 <geekosaur> -isrc
05:46:19 <quchen> Oh, ":" is the separator for multiple ones right
05:47:53 <jpcooper> quchen: I'm trying to compile a module from ghci within Emacs
05:49:35 <quchen> I don't use Emacs, assuming that's related
05:50:20 <jpcooper> I suppose not, but do you know how to do this once ghci has started, at least?
05:50:57 <quchen> :set -iPATH
05:51:14 <quchen> Using :set you can specify many compiler flags during runtime
05:51:18 <quchen> I'm not sure :i works though
05:51:37 <quchen> I mostly use it for extensions
05:51:45 <jpcooper> okay, I'll have a look at that
05:52:08 <richard> hi
05:52:38 <matthijs_> Is there a Control Flow Graph library available for Haskell?
05:52:52 <Guest26164> hi, confused on homework question: Using foldl, deﬁne a function d2i :: [Int] -> Int that converts a list of decimal digits into an integer. For example: d2i [1,2,3,4] = 1234
05:53:10 <Guest26164> No idea how to do it with foldl
05:53:17 <mauke> Guest26164: how would you do it without foldl?
05:53:20 <jmcarthur> how would you do it without foldl?
05:53:28 <ChongLi> haha
05:53:30 <ChongLi> JINX
05:53:38 <jmcarthur> i was three seconds too slow
05:53:45 <jmcarthur> not worth a jinx
05:53:46 <Guest26164> from what I have seen
05:53:54 <Guest26164> concatmap
05:53:54 <ChongLi> latency made them show up at the same time for me :)
05:53:58 <Taneb> :t foldl
05:54:00 <lambdabot> (a -> b -> a) -> a -> [b] -> a
05:54:01 <k0ral> Hello, I have a question for gtk2hs maintainers/users: when registering a callback on a gtk signal, is it necessary to use postGUISync inside the callback ? put it differently: are gtk callbacks run in a different thread ?
05:54:03 <mauke> Guest26164: show me the code
05:54:08 <ChongLi> let the types guide you
05:54:14 <ChongLi> it's like using the froce!
05:54:15 <Taneb> :t foldl (\accum dig -> 10 * accum + dig) 0
05:54:16 <lambdabot> Num a => [a] -> a
05:54:18 <Guest26164> joiner :: [Integer] -> Integer
05:54:24 <Guest26164> joiner = read . concatMap show
05:54:26 <Taneb> > foldl (\accum dig -> 10 * accum + dig) 0 [1,2,3,4]
05:54:28 <lambdabot>   1234
05:54:37 <mauke> Guest26164: new rule: you're not allowed to use read/show
05:54:38 <ChongLi> hey don't just solve the problem for him :)
05:54:42 --- mode: ChanServ set +o mauke
05:54:42 --- kick: Taneb was kicked by mauke (stop it)
05:54:44 <merijn> Taneb: Giving the entire solution to homework is rather counter productive...
05:54:51 <Taneb> Sorry
05:55:14 <Taneb> Guest26164, ignore what I've said
05:55:18 <jmcarthur> lol
05:55:22 <arkeet> uhhhh
05:55:23 <Taneb> It doesn't help you improve as a person
05:55:26 <jmcarthur> unsee!
05:55:27 <ChongLi> the proper way to teach is to work through the thought processes so that the student understands :)
05:55:47 <Guest26164> hmm
05:55:52 <Guest26164> i came up with a way
05:55:57 <Guest26164> to do it for single digit numbers
05:56:11 <Guest26164> 10 * previous number + new number
05:56:13 <arkeet> how come OpenGL-2.8.0.0 removes the dependency on StateVar and internalizes it?
05:56:29 <mauke> Guest26164: good
05:56:42 --- mode: mauke set -o mauke
05:56:43 <Guest26164> But pretty lost on larger numbers
05:56:54 <mauke> Guest26164: you don't have to deal with larger numbers
05:57:00 <Taneb> Guest26164, read the question again
05:57:02 <mauke> the question says you can assume digits
05:58:10 <Guest26164> ummm
05:58:19 <Guest26164> question doesn't say only single digit numbers
05:58:20 <borkdude> anyone has a pointer for matthijs_ : control flow graph lib for Haskell?
05:58:25 <Guest26164> not sure if i have to or not
05:58:35 <Taneb> "converts a list of decimal digits into an integer"
05:58:35 <ChongLi> Guest26164: it says a list of decimal digits
05:59:52 <ChongLi> matthijs_: http://stackoverflow.com/questions/3431225/tools-for-generating-haskell-function-dependency-control-flow-graph
06:00:43 <matthijs_> Thanks for the pointer
06:01:01 <ChongLi> as always, dons is the master of answering questions on so
06:01:19 <Guest26164> something like this?
06:01:38 <Guest26164> numb = foldl add 0
06:01:47 <Guest26164>   where add num d = 10*num + d
06:01:52 <Guest26164> wait hang on
06:01:54 <Guest26164> not right
06:02:18 <Guest26164> found an example online i will take a look at
06:02:21 <Guest26164> confused still
06:02:45 <mauke> > let { numb = foldl add 0 where add num d = 10*num + d } in numb [1,3,5]
06:02:47 <lambdabot>   135
06:02:50 <mauke> works fine here
06:03:10 <Guest26164> oh wow it does lol
06:03:15 <Guest26164> that 0 looks ugly
06:03:21 <Guest26164> but only way i can see to do it
06:03:26 <ChongLi> why is it ugly?
06:03:28 <matthijs_> Its for a simple procedural language containing while loops, which need to be verified by Z3 without an invariant, so using bounded verification, but I have to somehow determine how many iterations a loop may iterate, depending on some max N instructions
06:03:55 <mauke> > let { numb = foldl add 0 where add num d = 10*num + d } in numb [0,1,0,1]
06:03:56 <Philonous> Is there a compelling reason to prefer if then else over case of True -> ... False -> ... ?
06:03:57 <lambdabot>   101
06:04:01 <arkeet> > read . concat . map show $ [1,3,5] :: Int
06:04:03 <lambdabot>   135
06:04:27 <mauke> arkeet: concatMap
06:04:32 <arkeet> Philonous: between those two? style preference?
06:04:37 <arkeet> mauke: I realized that after I hit enter.
06:04:44 <mauke> and Guest26164 already said that
06:04:46 <Philonous> (or maybe and either over case, for that matter)
06:04:47 <arkeet> :P
06:05:02 <ChongLi> there's more than just those
06:05:05 <arkeet> > read (show =<< [1,3,5]) :: Int
06:05:06 <lambdabot>   135
06:05:18 <ChongLi> no reason not to define your own control operators for different situations
06:05:46 <ChongLi> such as when
06:05:52 <ChongLi> from Control.Monad
06:06:06 <ChongLi> and unless
06:06:10 <quchen> arkeet: PHP style type safety? :s
06:06:14 <arkeet> :P
06:06:53 <arkeet> > foldl' (\a x -> 10*a + x) 0 [1,3,5]
06:06:54 <mauke> it is time
06:06:55 <lambdabot>   135
06:07:13 <Guest26164> could i show you guys another question and could tell me if you think my answer is ok?
06:07:26 <mauke> @let a === b = cast a == Just b
06:07:29 <lambdabot>  Defined.
06:07:37 <mauke> > "a" === 42
06:07:41 <lambdabot>   False
06:07:51 <mauke> Guest26164: sure
06:07:55 <quchen> > zipWith (+) (map (10^) [0..]) [1,3,5]
06:07:56 <Taneb> > 42.0 === 42
06:07:58 <lambdabot>   [2,13,105]
06:07:58 <lambdabot>   can't find file: L.hs
06:08:07 <arkeet> > 42.0 === 42
06:08:12 <lambdabot>   False
06:08:19 <arkeet> > 42.0 === (42 :: Double)
06:08:22 <lambdabot>   True
06:08:33 <Guest26164> here is the question: Use the function mix from question two to deﬁne a function sortints :: [Int] -> [Int] which sorts a list of integers. The empty list and a singleton list are already sorted, and any other list should be sorted by mixing together the two lists that result from sorting the two halves of the list separately.
06:08:44 <Guest26164> here is my answer:
06:08:46 <arkeet> nice ligature =)
06:09:00 <mauke> ﬁne ligature
06:09:27 <Guest26164>  halve :: [a] -> ([a],[a])
06:09:32 <Guest26164> halve k = splitAt (length k `div` 2) k
06:09:36 <Guest26164> mix :: [Int] -> [Int] -> [Int]
06:09:40 <Guest26164> mix [] [] = []
06:09:41 <Philonous> @where paste
06:09:41 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
06:09:47 <Guest26164> oh
06:09:48 <Guest26164> ok
06:10:04 <Guest26164> way to open hyperlinks?
06:10:07 <Guest26164> on this chat?
06:10:11 <mauke> what is "this chat"?
06:10:18 <arkeet> that is client-dependent.
06:10:29 <Guest26164> ooh
06:10:38 <sipa> if clicking doesn't work, copy-paste them into a browser
06:10:45 <sipa> or get another client in which you can click on them :)
06:11:44 <hpaste> dudlite pasted “myanswer” at http://hpaste.org/84915
06:11:53 <Guest26164> there
06:12:15 <Guest26164> it is a merge sort solution
06:12:23 <Guest26164> I am thinking that is what the question is asking
06:12:27 <Philonous> Guest26164:  Line 5 is superfluous (but not wrong)
06:13:04 <arkeet> looks correct.
06:13:29 <mauke> length is slightly inefficient
06:13:35 <Guest26164> oh
06:13:37 <arkeet> I would probably implement halve differently though, yes.
06:13:59 <Guest26164> What i did at the start was
06:14:00 <arkeet> well, I suppose it depends on how much its behaviour is specified.
06:14:15 <Guest26164> cut the list into seperate lists bottom up
06:14:25 <Guest26164> is that a better idea?
06:14:31 <arkeet> I don't know what that means.
06:14:46 <Guest26164> hang on
06:14:50 <Guest26164> i will try find my code
06:15:10 <Guest26164> damn it lol, deleted it.
06:15:15 <Guest26164> it was something like this tho
06:15:35 <Guest26164> split :: [list] [[list]]
06:16:03 <Guest26164> went through every item in the list and put it into it's own list
06:16:05 <Guest26164> inside a list
06:16:28 <Guest26164> using a list comprehension
06:16:34 <mauke> map (: [])
06:16:41 <arkeet> map pure
06:16:58 <arkeet> Guest26164: and then what?
06:17:10 <Guest26164> well that was just my other version of halve lol
06:17:17 <arkeet> I don't see how that halves anything.
06:17:18 <Guest26164> to remove the n runtime
06:17:18 <arkeet> :p
06:17:43 <Guest26164> ok there is a chance I may have been on the complete wrong track =D
06:17:48 <Guest26164> high chance
06:19:05 <Philonous> I would split the list by putting the even-numbered element in one list and the odd-numbered ones in another. You can do that in O(n). Those might not be considered "halves of the list" though
06:19:50 <Philonous> But it doesn't matter for the correctness of merge sort
06:19:56 <Guest26164> ahh i see
06:20:00 <arkeet> I'd do that too.
06:20:14 <Guest26164> so according to merge sort right, a list is sorted when it has no elemenents or 1 element
06:20:16 <Guest26164> in the list
06:20:19 <Guest26164> and my mix method
06:20:22 <Guest26164> function*
06:20:25 <Philonous> It's a nice little exercise in using foldr
06:20:29 <Guest26164> sorts sorted lists
06:20:44 <arkeet> :t foldr (\x (a,b) -> (x:b,a)) ([],[])
06:20:45 <lambdabot> [a] -> ([a], [a])
06:20:48 <arkeet> oops.
06:21:17 <mauke> > foldr (\x (a,b) -> (x:b,a)) ([],[]) [0 ..]
06:21:18 <lambdabot>   *Exception: stack overflow
06:21:21 <mauke> terrible
06:21:27 <arkeet> sure.
06:21:40 <arkeet> > foldr (\x ~(a,b) -> (x:b,a)) ([],[]) [0..]
06:21:41 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,...
06:21:49 <arkeet> > foldr (\x ~(a,b) -> (x:b,a)) ([],[]) [0..10]
06:21:51 <lambdabot>   ([0,2,4,6,8,10],[1,3,5,7,9])
06:22:42 <Philonous> And there I was biting my lip, avoiding spoiling the fun
06:22:43 <quchen> It still amazes me that the above doesn't keep flipping the tuple on each application.
06:22:52 <quchen> I understand why it doesn't, but I just don't understand it.
06:23:11 <mauke> quchen: it doesn't?
06:23:24 <quchen> mauke: Well, if it did, it wouldn't work on infinite lists
06:23:32 <mauke> @pl \x -> swap . fmap (x :)
06:23:32 <lambdabot> (swap .) . fmap . (:)
06:23:35 <mauke> quchen: why not?
06:23:45 <arkeet> look at one step:
06:23:51 <arkeet> let f x ~(a,b) = (x:b,a)
06:23:58 <quchen> arkeet: I get how the code works.
06:24:00 <arkeet> sure.
06:24:21 <quchen> But when I see it I'm still always like "wow"
06:24:31 <citizen93> Hey, I have a small question. Can I compose functions that take arbitrary arguments in Haskell?
06:24:37 <Guest26164> on a scale of 1 - 10, how hard will it be to write a parser for the programming language "Tiny" in Haskell?
06:24:39 <mauke> citizen93: yes
06:24:41 <citizen93> (i.e. \a b c -> .... composed by a program)?
06:24:43 <arkeet> f 0 blah = (0:_,_)
06:24:43 <citizen93> if yes how?
06:24:51 <arkeet> one doesn't need to inspect blah to know that much.
06:24:53 <mauke> citizen93: f . g
06:24:54 <quchen> mauke: Naively, I'd expect the final result swapping around every time a "x" gets prepended.
06:25:05 <mauke> quchen: so?
06:25:06 <quchen> But foldr and laziness etc pp.
06:25:07 <Taneb> Guest26164, about 3
06:25:09 <citizen93> uhm I didn't meant it like that
06:25:20 <citizen93> Let me restate my question
06:25:38 <quchen> mauke: Well, *if* the final result was swapped all the time, you wouldn't get a result for infinite lists, as the fst/snd are undecidable
06:25:39 <merijn> Guest26164: I don't know Tiny's grammar, but haskell parsers are actually pretty easy to write
06:25:43 <arkeet> > foldr (\x ~(a,b,c) -> (x:b,c,a)) ([],[]) [0..20]
06:25:45 <lambdabot>   Couldn't match expected type `([a0], [a0], [a0])'
06:25:45 <lambdabot>              with actual ...
06:25:49 <arkeet> > foldr (\x ~(a,b,c) -> (x:b,c,a)) ([],[],[]) [0..20]
06:25:50 <lambdabot>   ([0,3,6,9,12,15,18],[2,5,8,11,14,17,20],[1,4,7,10,13,16,19])
06:25:55 <Guest26164> thank goodness lol
06:25:59 <mauke> quchen: no, the swaps are intermixed with the elements
06:26:18 <mauke> so the first element has no swaps before it
06:26:45 <typoclass> quchen: it's a sequence of "one more element known, one swap"
06:26:55 <merijn> Guest26164: If this is homework, are you allowed to use libraries? If yes, then you probably want to look at Parsec
06:27:02 <quchen> Yes, I know. That's why I said I understand how it works.
06:27:05 <arkeet> or trifecta :>
06:27:07 <quchen> I think this describes my problem: http://abstrusegoose.com/73
06:27:28 <typoclass> quchen: so it does need to do infinitely many swaps, but only if you want infinitely many elements :-) if you need only 20 elements, it's not that many swaps to do
06:27:29 <Guest26164> merijn: it is for our next assignment
06:27:51 <citizen93> I am using this package (http://hackage.haskell.org/package/sbv-2.10), and you can see clearly that the function forAll ["x"] $ \(x :: SWord8) -> x `siftL`2 .== 4*x. Now instead of typing this manually to get it proven by Z3, my Haskell program should be able to create something like forAll ["x", "y"] $ \(x :: SWord8) y -> x .> 0
06:28:07 <citizen93> I have no problem generating the list with arguments
06:28:16 <citizen93> I have also no problem generating the "expression"
06:28:29 <citizen93> however I have a problem with generating \x y z ... ->  part
06:28:39 <nulloid> would TemplateHaskell be an overreaction?
06:28:59 <citizen93> I have no experience with TemplateHaskell
06:29:25 <arkeet> citizen93: you could do it in a type-unsafe way with some silly overloading (printf-style).
06:29:35 <Taneb> In my mind I'd use parsec for human-written data, and attoparsec for computer-written data
06:29:49 <citizen93> I prefer to keep it type-safe
06:29:49 <arkeet> citizen93: typeclass trickery, that is. but there's no clean way to do it
06:30:03 <citizen93> :(
06:30:05 <arkeet> simply because the type of the argument of forall blah must depend on the length of blah.
06:30:32 <arkeet> I suppose you could make it type-safe by using something other than a list.
06:30:49 * typoclass . o O ( how does it know that forAll ["x"] needs to refer to the same thing as \x -> ...? )
06:30:54 <citizen93> ... like what?
06:31:01 <ndonaldson> amatsu, you around?
06:31:05 <arkeet> like something that carries length information in the type level.
06:31:18 <citizen93> ... hmmm
06:31:51 <citizen93> like this: http://en.wikibooks.org/wiki/Haskell/GADT?
06:32:01 <arkeet> sure.
06:32:17 <citizen93> so this is possible with GADT's?
06:32:31 <arkeet> yes
06:32:48 <__sg__> i'm just starting my way up the steep learning curve of haskell and i have a question
06:32:51 <citizen93> alright, but how to create a function that can apparently accept x elements?
06:32:59 <arkeet> with some typeclass trickery again.
06:33:03 <arkeet> but this time it'll be type-safe.
06:33:10 <__sg__> does the recursive and lazy nature of the language mean i can get rid of some very nasty/nested "for" loops?
06:33:37 <citizen93> can you give me an example of what kind of class tricks? (or maybe a reference?)
06:33:43 <arkeet> uh
06:33:59 <arkeet> I just have the unsafe Text.Printf stuff in mind right now.
06:34:08 <arkeet> I'm sure someone has written something.
06:34:09 <typoclass> citizen93: have you thought about a lambda that takes a list, instead of taking a number of arguments?
06:34:12 <Guest26164> sg I am new too, and yes you can
06:34:20 <nulloid> __sg__, there are no "for" loops in haskell, or, more specifically, they are replaced with recursion, AFAIK
06:34:26 <citizen93> I am not going to edit the SBV package
06:34:26 <arkeet> typoclass makes a point.
06:34:29 <arkeet> heh.
06:34:33 <Guest26164> check out "list comprehensions" they are awesome lol
06:34:39 <__sg__> thank you
06:35:05 <citizen93> Maybe I'm not looking good enough, but I couldn't find another way to "define" the lambda expression with a list yet...
06:37:07 <arkeet> you'd define it in some instances for a new typeclass.
06:37:13 <__sg__> and another one: when i read that haskell is a strongly typed language, this means that no automatic type conversions occur, no matter what?
06:37:24 <Taneb> Yes
06:37:30 <arkeet> somewhat analogously to the Provable class, I suppose.
06:37:40 <Taneb> Although some things can sort of be more than one type
06:37:43 <Taneb> Sometimes
06:38:11 <arkeet> sure, so there are automatic type conversions in the sense that you can take some polymorphic thing and view it as something less polymorphic.
06:38:15 <Taneb> > let x = 2 :: Num a => a in (x :: Double, x :: Complex Double, x :: Rational, x :: Integer)
06:38:17 <lambdabot>   (2.0,2.0 :+ 0.0,2 % 1,2)
06:38:27 <arkeet> but that's it.
06:38:33 <citizen93> hmm....
06:39:10 <__sg__> arkeet: but in this case, as i understand it, _you_ are the initiator of the conversion, not the language
06:39:14 <__sg__> am i correct?
06:39:16 <citizen93> I am seeing here something with Arrays... maybe this can work.
06:39:24 <arkeet> __sg__: I don't know what that means.
06:39:38 <typoclass> citizen93: i'm not familiar with the sbv package, but if i'm reading http://hackage.haskell.org/packages/archive/sbv/2.10/doc/html/Data-SBV.html#t:Provable correctly, those instances will allow single values (like \x -> ...), tuples up to length 7, and SymArrays (whatever that is). have you looked into SymArrays?
06:39:58 <citizen93> Yes, I am now looking at it =)
06:39:59 <__sg__> you make it happen, the language does not enforce the conversion
06:40:02 <__sg__> for you
06:40:07 <citizen93> But I'm not sure yet, what it does
06:40:11 <citizen93> or how it works
06:40:19 <quchen> __sg__: Arkeet meant that if you have a function of the type "a", using it as a "(Eq a) => a" is something like a type conversion-y thing.
06:40:30 <quchen> An implicit one, that is.
06:40:42 <quchen> Explicit type conversions are things like "Int --> Integer".
06:40:49 <quchen> And that you have to specify manually.
06:40:54 * hackagebot liblastfm 0.1.1.2 - Lastfm API interface  http://hackage.haskell.org/package/liblastfm-0.1.1.2 (MatveyAksenov)
06:40:56 <arkeet> right, I'm talking about converting from a more general (polymorphic) type to a more specific type
06:41:13 <liyang> __sg__: you can have pretend that Haskell has something like automatic upcasting.
06:41:16 <typoclass> > map toLower "LOLcats"
06:41:17 <arkeet> Int and Integer is not a case of this: neither is more general than the other.
06:41:18 <lambdabot>   "lolcats"
06:41:43 <arkeet> however, both can be explicitly converted to any other Num type using fromIntegral.
06:41:46 <liyang> (Or down. It doesn't completely make sense either way I think about it.)
06:41:47 <arkeet> (for instance.)
06:41:51 <typoclass> __sg__: above is an example that in another language might be done with a for loop. in haskell you use the 'map' function, which takes a function that can process one element of the list (here: toLower, which converts one Char), and a list (here: String "LOLcats")
06:42:20 <__sg__> thanks a lot!
06:42:30 <typoclass> __sg__: the 'map' function is not special, it's a beginner-level exercise to reimplement it
06:43:26 <__sg__> elegant and powerful, thanks
06:43:59 <typoclass> __sg__: oh, just to be clear -- when i say String, it means 'list of Char' :-) those are synonyms
06:44:44 <typoclass> @src map
06:44:44 <lambdabot> map _ []     = []
06:44:44 <lambdabot> map f (x:xs) = f x : map f xs
06:45:53 <typoclass> __sg__: here is the source code of the 'map' function. details aside, but you can see it's short and not complicated. also you can see that it's recursive, because in line 2, 'map' appears on the right-hand side of the "=", meaning we call the 'map' function
06:48:15 <__sg__> typoclass: i'm coming from python and trying really hard to "refactor" my programming skills and to think like a haskell programmer
06:48:24 <__sg__> it's not easy
06:49:14 <nulloid> __sg__, there are other functions, which work on lists, and those would be implemented using a for loop in imperative languages. Such functnios are folds, scans, maps. IIRC these are the mostly used. But they all just recursions in disguise.
06:49:23 <nulloid> I came from python to haskell, too ^
06:49:27 <nulloid> ^^
06:50:24 <nulloid> also, it's not easy really. It took me about a year to get a grasp on the haskell way
06:50:49 <nulloid> (Am I frightening away people with this sentence?)
06:50:56 <merijn> __sg__: Did you use list comprehensions/generators a lot?
06:51:15 <__sg__> merijn: yes
06:51:41 <typoclass> __sg__: right, there's a clear difference :-) but the good news is, you can always ask in here. and getting the hang of the first few haskell idioms isn't difficult
06:51:57 <__sg__> generators are good but they don't seem as classy a solution as lazy evaluation
06:52:31 <__sg__> typoclass: thanks again
06:52:53 <quchen> __sg__: Generators solve a small subclass of problems you can tackle with lazy evaluation.
06:52:59 <quchen> They're not the same.
06:53:12 <nulloid> tht's what i wanted to ask. :D
06:53:25 <nulloid> +1 for mind-reading :D
06:53:25 <merijn> __sg__: Well, that's a good start already, list comprehensions and generators in python map pretty closely to list comprehensions in haskell. Although many people prefer to use map/filter instead of comprehensions
06:53:29 <quchen> Generators are pretty much lazy infinite lists.
06:53:40 <merijn> The translation from comprehension to straight map/filter/etc is pretty easy too
06:54:38 <nulloid> (also, comprehension-like things work in haskell, too)
06:54:45 <__sg__> so the gains in speed must be significant, plus the compiler thing of course
06:56:41 <typoclass> > [toLower x | x <- "LOLcats"] -- here is the earlier line rewritten as a list comprehension. the basic form is [... | ...]
06:56:43 <lambdabot>   "lolcats"
06:57:39 <merijn> __sg__: I personally think the best benefit is the type system, tbh
06:58:30 <arkeet> > map toLower "LOLcats"
06:58:32 <lambdabot>   "lolcats"
07:02:07 <typoclass> merijn: i suspect 'the compiler thing' == 'the type system' ;-)
07:04:44 <nulloid> i suspect"thecompiler thing" == "being a compiled language, rather than interpreted"
07:05:15 <nulloid> sorry for my lack of spaces :)
07:14:40 <`nand`> a compiler is an interpreter
07:16:00 <kurkale6ka> Hi, in this example I don't understand why we can pattern match with Left x: http://bpaste.net/show/87952/. Since Either a b is Left a | Right b, Shouldn't Either a be like b -> Right b only
07:16:29 <mauke> no, 'Either a' is not a type
07:16:40 <arkeet> :t fmap
07:16:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:16:46 <arkeet> replace f with "Either a", and you get
07:16:52 <mauke> name conflict
07:16:53 <arkeet> uh
07:16:55 <arkeet> :)
07:16:58 <mauke> let's alpha
07:16:59 <nulloid> 'nand', is it? o.o
07:17:01 <arkeet> after alpha-renaming,
07:17:07 <arkeet> (b -> c) -> Either a b -> Either a c
07:17:35 <mauke> kurkale6ka: fmap :: Functor f (x -> y) -> f x -> f y
07:17:41 <mauke> kurkale6ka: the argument in question has type f x
07:17:46 <mauke> kurkale6ka: f = Either a
07:17:53 <mauke> kurkale6ka: thus its type is Either a x
07:18:54 <arkeet> I guess x,y is better than b,c.
07:19:11 <mauke> heh
07:19:15 <mauke> except I forgot the =>
07:19:25 <mauke> fmap :: (Functor f) => (x -> y) -> f x -> f y
07:19:53 <`nand`> not starting nondescript single-letter variable names at the beginning of the alphabet? blasphemy!
07:20:53 <quchen> :t fmap :: (Functor eats) => (rabbit -> mouse) -> eats rabbit -> eats mouse
07:20:54 <lambdabot> Functor eats => (rabbit -> mouse) -> eats rabbit -> eats mouse
07:21:13 <typoclass> kurkale6ka: keep in mind that the instance is Functor (Either a). it isn't Functor (Either a b) or something like that, because that would be impossible
07:21:40 <mauke> `nand`: Functor f => (α -> β) -> f α -> f β
07:21:51 <typoclass> kurkale6ka: it's similar to the instance Functor Maybe: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Data-Maybe.html#Maybe note how it's Functor Maybe, and not Functor (Maybe a)
07:21:56 <mauke> >implying there's only one alphabet
07:22:27 <parcs> there's only one real alphabet
07:22:34 <arkeet> mauke: you're not doing it enough.
07:22:37 <`nand`> mauke: my statement was polymorphic in which alphabet you actually use
07:22:43 <arkeet> Functor φ => (α -> β) -> φ α -> φ β
07:23:06 <`nand`> transliterate ‘Functor’
07:23:07 <parcs> ascii arrows are for chumps
07:23:49 <mauke> don't make me use 'a', 'l', 'p', 'h'
07:24:11 <kurkale6ka> Not sure to follow, isn't Either a b a type constructor taking two types? Then isn't Either a a type constructor taking only one type and from Either's definition shouldn't the result be Right b. My question is more about pattern mathing than trying to understand funcors
07:24:16 <kurkale6ka> functors
07:24:36 <arkeet> kurkale6ka: no, Either is a type constructor taking two types.
07:24:40 <`nand`> id :: א → א -- and I don't know any others
07:24:44 <arkeet> Either a b is what you get after you've already given it two types.
07:24:58 <latro`a> Foo a = Either a a is a functor, but a silly one
07:25:05 <latro`a> (that's a type equality)
07:25:30 <arkeet> ??
07:25:40 <latro`a> well rather, the specialization of the usual functor is one, and the "treat Left and Right the same" is also one
07:25:50 <arkeet> it's (Bool,a)
07:27:29 <`nand`> Bar a b = Either b a -- is also a functor
07:27:38 <`nand`> Bar a is
07:28:01 <mauke> kurkale6ka: your question seems to be about type definitions
07:28:22 <mauke> kurkale6ka: "Right b" can't be the result of anything
07:28:39 <typoclass> kurkale6ka: well, in the definition of class Functor, you have stuff like "class Functor f where fmap :: ... -> f a -> f b". this means that f (for which your instance used (Either a)) needs to be kind * -> *, meaning it takes one type argument. compare with Maybe, which also has the right kind, so you can define an "instance Functor Maybe"
07:29:25 <mauke> oh, good idea
07:29:38 <mauke> let's switch from Either a to Maybe
07:29:50 <mauke> 'Maybe' is not a type, and it does not have a value called 'Nothing'
07:30:23 <Philonous> mauke:  Apparently there's some disagreement about whether "Maybe" is a type or not.
07:30:38 <mauke> heh
07:30:45 <arkeet> well the disagreement is about what "type" means.
07:30:48 <mauke> "'Maybe' does not have kind *" then
07:31:25 <ab9rf> i thought that Maybe was an instance constructor
07:31:43 <Philonous> ab9rf:  It's a type constructor
07:31:46 <`nand`> I have no idea what an instance constructor is
07:31:57 <ab9rf> Philonous: Either is a type constructor
07:32:06 <`nand`> so is Maybe
07:32:07 <geekosaur> type constructor. it is of kind * -> *, it takes a type and produces a type
07:32:28 <geekosaur> Either is also a type constructor, it has a different kind, indicating it takes *two* types
07:32:34 <geekosaur> and produces a type
07:32:34 <ab9rf> Sorry, yes, Maybe is a type cosntructor
07:32:39 <ab9rf> Just and Nothing are the data constructors
07:32:40 <`nand`> I would refer to as ‘type constructor’ anything of kind ‘a -> b’, not necessarily just *
07:32:42 <typoclass> Philonous: who is disagreeing ...? did i make a typo?
07:32:52 <ab9rf> i had a senior moment there
07:33:24 <ab9rf> had Maybe confused with Just
07:36:07 <Philonous> typoclass:  I'm not sure what you mean, I was just saying that there have been discussions in here about whether type means "Thing with with kind *" or "Things in the type level"
07:36:47 <typoclass> Philonous: oh i see :-) i thought i had made a typo and written that Maybe is a type
07:37:50 <`nand`> “things in the type level” includes stuff of kind :: * -> Constraint -- or similar as well, I'm not sure I'd be comfortable calling that a ‘type’ mainly for clarity concerns
07:38:04 <Philonous> typoclass:  Oh, then my reply must have seemed terribly sarcastic.
07:38:17 <arkeet> it's a "constraint constructor:
07:38:18 <arkeet> "
07:38:38 <Philonous> `nand`:  I'm afraid I'm not representing the other side of the argument faithfully.
07:38:49 <`nand`> arkeet: following that line of thought, a type constructor would be anything of kind ‘... → ... → ... → *’ ?
07:38:58 <typoclass> Philonous: no, didn't seem sarcastic, i was just worried i'm making an ass of myself again :-)
07:39:07 <arkeet> `nand`: of course.
07:39:17 <`nand`> I think I could live with that
07:39:25 <typoclass> `nand`: the whole Constraint stuff is a fairly new addition, isn't it
07:39:30 <Philonous> typoclass:  Even if you did write that it would be a defensible position.
07:39:31 <`nand`> typoclass: yes
07:39:41 <`nand`> typoclass: and not part of Haskell either
07:41:57 <typoclass> `nand`: how do you mean 'not part of haskell'? i thought it was the ConstraintKinds extension that arrived with ghc 7.6 (or 7.4?)
07:42:10 <arkeet> it's not part of any haskell standard.
07:42:20 <`nand`> typoclass: GHC extensions are not Haskell :)
07:43:42 <typoclass> `nand`: oh ok. fine. i'll count that under 'just trying to be confusing for public amusement' :-)
07:43:48 <Philonous> I wonder how many packages on hackage actually contain Haskell.
07:44:31 <`nand`> typoclass: well, nomenclature stuff like this is probably best to consider in terms of the actual Haskell standard without fancy extensions
07:45:39 <typoclass> Philonous: absolutely none! it's all written in c# and javascript and udev config files
07:46:30 <Philonous> typoclass:  You mean it's all Perl and a todo-list containing one item: "rewrite in Haskell"?
07:49:54 <kutta> j@help
07:49:58 <kutta> @help
07:49:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:50:13 <kutta> @help list
07:50:14 <lambdabot> list [module|command]
07:50:14 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
07:56:37 <iggypop> Hello all
07:56:42 <jeff_s2> Happy Easter! http://www.reddit.com/r/haskell/comments/1bcycs/the_true_spirit_of_lambda_easter/
08:01:10 <`nand`> what's easter?
08:01:28 <arcatan> Japan is easter than China
08:02:34 <`nand`> but is it really?
08:02:57 <arcatan> depends on your viewpoint
08:02:59 <`nand`> Japan is also wester than China
08:03:17 <`nand`> everything is east of everything
08:03:30 <`nand`> hence, ‘east’ and ‘west’ are meaningless words and should be abandoned
08:03:35 <`nand`> </infallible-logic>
08:04:33 <arkeet> I suppose it's april 1 in some parts of the world now.
08:04:55 <Philonous> `nand`:  And by "everything" you mean "some things, but not others"
08:04:56 <iggypop> I have a test about Haskell tomorow and I'm not very good at it. While working I found this exercice  I can't solve : http://pastebin.com/u2eWMSzs
08:05:05 <mauke> The paste u2eWMSzs has been copied to http://hpaste.org/84918
08:05:08 <`nand`> Philonous: okay, everything on the surface of earth, at least
08:05:27 <iggypop> I don't understand the way foo fucntion work, neither the lol function
08:05:30 <Philonous> `nand`:  What's west of the north pole?
08:05:35 <iggypop> could someone help me please ?
08:06:11 <`nand`> Philonous: everything!
08:06:14 <arkeet> iggypop: well, "foo 0" is a type error.
08:06:23 <arkeet> foo isn't a function.
08:06:31 <typoclass> `nand`: 'what is easter' <- here's an explanatory video http://vimeo.com/60009458
08:06:37 <`nand`> Philonous: one approach would be to say the north pole is present on all longitudes
08:06:59 <`nand`> because you can draw a line on each longitude that goes through it
08:07:09 <iggypop> arkeet: Yes i see it now, because it doesn't take argument
08:07:28 <arkeet> iggypop: but you should be able to say what foo is.
08:07:50 <arkeet> or, at least, what it isn't.
08:07:54 <iggypop> actually as haskell is a lazy language I guess it's a trick to do something cool
08:08:36 <arkeet> it's not really a trick, and it doesn't really do something cool. unless your idea of cool is "be unproductive forever".
08:08:54 <arkeet> "bar 0 foo" is a good one.
08:09:14 <arkeet> but you need to be able to say what foo is before answering that.
08:09:15 <iggypop> I though it was like infinite list on haskell :x
08:09:25 <iggypop> foo is a float
08:09:45 <iggypop> but I don't see how it can exist as a float as it's self-recursivly with no end
08:09:46 <arkeet> it is. which float is it?
08:09:57 <arkeet> indeed, so what happens when I try to print it?
08:10:06 <iggypop> infinite recursion ?
08:10:11 <arkeet> correct.
08:10:49 <arkeet> in other words, evaluating foo will never terminate.
08:11:15 <`nand`> iggypop: do you want spoilers?
08:11:17 <iggypop> hmm I strat to feel something
08:11:35 <markov_twain> TIL "hoge fuga piyo" is japanese for "foo bar baz"
08:11:43 <arkeet> yup
08:11:48 <parcs> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
08:11:50 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:11:52 <iggypop> `nand`: as it's for a test no I prefer to understand ^^
08:12:24 <iggypop> so bar will force foo to terminate when one of the float is 0 ?
08:12:48 <typoclass> markov_twain: nyan nyan nyan!
08:12:59 <arkeet> iggypop: not really
08:13:11 <arkeet> hint: the order of the equations for bar matters.
08:14:30 <parcs> *sigh* the person on reddit who's complaining about the performance of 'fib' didn't ever bother to compare asm
08:15:21 <iggypop> arkeet: I don't see it. For me it will match the second line and return 0 :x
08:15:29 <iggypop> and I suspect it's not the good answer :p
08:15:39 <arkeet> iggypop: what happened to the first line?
08:15:59 <Palmik> Hmm, I'm trying to use MIN_VERSION macros, but when I do something like this: http://hpaste.org/84921 I get "warning: extra tokens at end of #ifdef directive [enabled by default]". Is that normal?
08:16:15 <iggypop> if Haskell evaluate foo at this time, infinite rercursion
08:16:20 <arkeet> Palmik: not ifdef.
08:16:48 <arkeet> iggypop: so the question is: does evaluating "bar 0 foo" force evaluation of foo?
08:16:58 <`nand`> iggypop: matches are evaluated from top to bottom
08:17:13 <arkeet> and to answer that, you check the equations from top to bottom.
08:17:30 <iggypop> arkeet: Yes but I feel he as to do it for pattern matching
08:17:31 <arkeet> does bar 0 foo match bar x 0?
08:17:49 <`nand`> the first match is ‘bar x 0’, so when running ‘bar 0 foo’ it matches ‘0’ against ‘x’, which succeds, and ‘foo’ against ‘0’, which causes evaluation of ‘foo’
08:18:03 <`nand`> s/running/evaluating/
08:18:23 <iggypop> yes, until this everything is clear
08:18:24 <Palmik> arkeet: Ah, I guess it should be just #if.
08:18:35 <iggypop> then foo goes in infinite recursion
08:19:53 <iggypop> then it just doesn work and go until stack broke ?
08:21:16 <arkeet> iggypop: in the first equation, it tests if foo is equal to 0.
08:21:25 <arkeet> which means foo is evaluated.
08:22:39 <iggypop> yes, but when foo is evaluated we said realrier that it goes in infinite recursion
08:22:47 <arkeet> indeed.
08:23:00 <iggypop> so the function never return anything and segfault ?
08:23:05 <arkeet> not segfault.
08:23:25 <iggypop> heap overflow sorry
08:23:32 <arkeet> not the heap. :p
08:24:31 <arkeet> hmm, why doesn't it blow the stack?
08:24:38 <iggypop> yes the stack, sorry, it's what I mean't I'm not very fluent in english ^^
08:24:41 <parcs> should i be condescending in my reply to the person who's spreading FUD about ghc on reddit?
08:24:57 <arkeet> iggypop: but if I try running it, it doesn't.
08:25:01 <arkeet> it uses constant memory.
08:25:31 <arkeet> in any case, it doesn't terminate. :p
08:25:39 <iggypop> (If you're really running it please let me know how as ghci and ghc drove me crazy trying to test this)
08:26:02 * hackagebot names 0.3 - Type level names.  http://hackage.haskell.org/package/names-0.3 (JulianFleischer)
08:26:04 * hackagebot named-records 0.3.1 - Flexible records with named fields.  http://hackage.haskell.org/package/named-records-0.3.1 (JulianFleischer)
08:26:21 <ludamad> Not directly related to haskell, but I have a server that forks for each client, would it make sense to have a thread for reading from client and a separate one for writing to the client ?
08:26:24 <iggypop> arkeet> So it doesn't stack overflow ? it just never finish
08:27:20 <arkeet> well, how exactly fails isn't really relevant to semantics.
08:27:28 <arkeet> but I'm wondering why it doesn't stack overflow.
08:28:05 <arkeet> in fact it detects a loop.
08:28:39 <dolio> What code are you discussing?
08:28:48 <arkeet> foo :: Float; foo = 2 * foo
08:28:52 <iggypop> arkeet: can you please pastbin me the code your using to compile it (obviously I had stupid problem setting up a correct main) so i can test it with ghc ?
08:28:59 <arkeet> I'm just typing that in ghci.
08:29:01 <`nand`> yeah, in GHC it would run into a black hole and terminate immediately
08:29:04 <iggypop> dolio: http://pastebin.com/u2eWMSzs
08:29:04 <mauke> The paste u2eWMSzs has been copied to http://hpaste.org/84918
08:29:07 <arkeet> why?
08:29:18 <arkeet> oh, never mind.
08:29:28 <arkeet> I think I get it.
08:29:29 <arkeet> :p
08:29:46 <`nand`> not in GHCi, though :)
08:29:47 <arkeet> foo is shared there.
08:29:56 <arkeet> sure, in ghci it terminates after a few seconds.
08:30:20 <`nand`> really? in GHCi it just halts for me, no memory usage, no CPU, nothing
08:30:26 <`nand`> no output, no exception
08:30:32 <FireFly> Same for me
08:30:47 <`nand`> but when compiling via ghc and running I get Foo: <<loop>>, indicating a black hole
08:31:09 <geekosaur> try with -threaded
08:31:22 <arkeet> 7.6.2, ends after 5 seconds.
08:31:23 <arkeet> >>> let f :: Float; f = 2*f in f
08:31:23 <arkeet> *** Exception: <<loop>>
08:31:28 <dolio> Ah, well, that would stack overflow if GHC were dumb.
08:31:41 <`nand`> 7.6.2 here too
08:31:46 <dolio> But it isn't, so it just gets caught on a black or white hole.
08:31:55 <jeyb_> exit
08:32:03 <geekosaur> (blackhole detection is, IIRC, difficult in the presence of threads because multiple threads can reasonably fall into the same thunk)
08:32:11 <arkeet> I have a dozen extensions enabled too but I don't think they'd affect this.
08:32:18 <dolio> Black hole gets you the exception, white hole just blocks forever.
08:32:22 <`nand`> geekosaur: even with -threaded it <<loop>>s, maybe it needs to actually be running multiple threads?
08:32:36 <`nand`> and yes, if it hit a black hole with threading active I think it would just halt the way GHCi does
08:32:39 <arkeet> -threaded wouldn't affect it in ghci I think?
08:32:39 <geekosaur> maybe. in that case you might try ghci -no-ghci-sandbox
08:32:44 <`nand`> forever blocking on the evaluation of foo
08:32:44 <arkeet> unless that
08:32:47 <geekosaur> arkeet, ghci is always threaded
08:32:55 <`nand`> ghci ignores -threaded yes
08:33:00 <geekosaur> and has multiple threads if you dont disable the sandbox
08:33:19 <`nand`> Warning: -debug, -threaded and -ticky are ignored by GHCi
08:33:36 <arkeet> sure, it runs forever with no sandbox.
08:34:00 <geekosaur> there's also such things as ghc optimizes and ghci (really the bytecode backend) does not
08:34:12 <iggypop> bar 0 foo never terminate in GHCi so it mean's it just a beauty of functionnal programmation that is able to see the problem ?
08:34:20 <geekosaur> and the bytecode evaluator is generally not very smart
08:34:32 <markov_twain> parcs: fwiw, I'm amazed by the level of discussion on /r/haskell.. /r/ruby is a wasteland
08:34:37 <arkeet> sleep.
08:36:46 <dolio> iggypop: The way that lazy evaluation works is that when you go to evaluate foo, you mark it so that either 1) if you get back to having to evaluate foo as part of its own body, you blow up or 2) any other evaluation of foo waits for your initial evaluation to finish.
08:37:14 <ramses_> if I have a data type "data Num' = forall a. (Show a, Num a) => Num' a", or the dictionaries for Show and Num stored inside the Num' value when created? Or how does GHC find them otherwise?
08:37:29 <ramses_> s/or/are
08:37:43 <dolio> Or at least, that's a sensible thing to do.
08:37:52 <iggypop> dolio: yes, but in this case it doesn't "blow up" (as I understand it as throw exception)
08:38:58 <dolio> Then perhaps it's case 2).
08:39:13 <dolio> Where it's blocking waiting for its own evaluation to complete.
08:39:17 <dolio> Which will never happen.
08:39:23 <iggypop> oO, smart ! :p
08:39:35 <markov_twain> is there any way to run ghc/ghci on iphone? (web apps are fine)
08:40:06 <iggypop> markov_twain: ideone or any others ?
08:40:12 <merijn> markov_twain: ghc-live? Lets you access a remote ghci/ghc session over the web
08:40:24 <dolio> I think they've discussed adding thread ids to white holes so they could fail even during threaded evaluation, but I can't remember if they've actually done that.
08:40:45 <dolio> It might not be worth the excess space.
08:40:59 <markov_twain> iggypop: I'll try it, I don't have much luck with codemirror-based stuff though (no keyboard usually)
08:41:28 <iggypop> then i would say ssh
08:41:51 <Shin-LaC> ok, I finished this thing: https://github.com/roman/HaskellKoans
08:41:53 <Shin-LaC> it was bad
08:42:12 <markov_twain> merijn: is ghclive hosted somewhere? i could figure out how to run it on heroku or similar, but it'd be nice if there's already one available
08:44:46 <markov_twain> Shin-LaC: [lang]-koans are such a good idea, but all the ones I've done were pretty terrible (ruby, js, python)
08:45:23 <Shin-LaC> unfortunately, this was bad compared to the ruby ones
08:45:28 <Shin-LaC> so you'd find it terrible
08:45:41 <iggypop> Thank you all for your help !
08:45:43 <iggypop> Good bye !
08:45:47 <luite> markov_twain: it's not really suitable for that yet, since it has no security. hosting your own privately can be an option
08:45:47 <Halite> If any of the admins were deserving of such a good community here, they would let me discuss my behaviour and autism in #haskell-ops
08:47:16 <jmcarthur> was there some incident i'm not aware of?
08:47:40 <markov_twain> luite: ah, i see. would you recommend something over heroku for free cloud-hosted haskell apps?
08:47:54 <`nand`> What's a [lang]-koan?
08:48:54 <markov_twain> Shin-LaC: have you found any koans-like things for haskell that are good?
08:50:04 <markov_twain> `nand`: a family of github repositories that aim to teach a PL through small challenges
08:51:27 <`nand`> I see
08:51:46 <markov_twain> Shin-LaC: I seem to remember some "99 problems in prolog" thing that was adapted for scala... wonder if there's a haskell version
08:51:49 <`nand`> so basically like most other teaching resources, except with less actual text and explanations?
08:51:54 <luite> markov_twain: oh if you host your own on heroku that could work
08:52:03 <Shin-LaC> markov_twain: there is, in fact
08:52:04 <luite> markov_twain: if you add a password or something
08:52:07 <`nand`> markov_twain: there's a 99 problems in haskell, not sure if that's what you mean
08:52:11 <Shin-LaC> someone was telling me about it before
08:52:32 <Shin-LaC> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
08:52:36 <luite> markov_twain: don't know any other options, i just use a regular server because it's easier to deploy
08:52:43 <ramses_> no one here knows about type class dictionaries with existentials? Google is not making me any wiser
08:52:45 <luite> other free optiosn that is
08:52:55 <`nand`> ramses_: I must have missed your question
08:52:55 <markov_twain> Shin-LaC: oh nice! thanks!
08:53:17 <ramses_> `nand`: if I have a data type "data Num' = forall a. (Show a, Num a) => Num' a", or the dictionaries for Show and Num stored inside the Num' value when created? Or how does GHC find them otherwise?
08:53:31 <`nand`> ramses_: yes, they are
08:53:55 <ramses_> ah, ok, I didn't suspect that
08:53:57 <`nand`> that's how one usually reifies dictionaries, see eg. http://hackage.haskell.org/packages/archive/constraints/0.3.2/doc/html/Data-Constraint.html
08:54:19 <markov_twain> luite: my free year if amazon ec2 ran out a month ago. now i just see what i can get away with on heroku :)
08:55:44 <`nand`> (though that one's slightly different in that the only existential is the dictionary itself, the type parameter isn't hidden away)
08:55:44 <markov_twain> luite: i feel like all these $5/mo/instance hosts are probably garbage
08:55:45 <ramses_> `nand`: that's interesting, for my master thesis I'm looking at first-class dictionaries as a GHC extension
08:56:16 <`nand`> ramses_: you might be interesting in stuff like https://github.com/ekmett/reflection/blob/master/examples/Constraints.hs then
08:57:18 <`nand`> ramses_: also, forall a. Show a => Num' a -- isn't usually very useful, one would generally prefer to just use String instead
08:57:57 <ramses_> `nand`: that was just a toy example to see whether that would work :)
08:58:00 <`nand`> sure :)
08:58:15 <`nand`> just making sure you're aware of the alternatives to existential dictionaries
08:58:37 <ramses_> I had a Num constraint as well, I just checked whether I could use normal Num operations and then print the results
08:58:44 <markov_twain> luite: btw shapr (of ghclive) is my cousin-in-law, was hoping he'd be around this morning--he's always trying to get me in here :)
08:58:47 <`nand`> then yes, you can
08:59:30 <`nand`> @get-shapr
08:59:30 <lambdabot> shapr!!
08:59:36 <`nand`> looks like he isn't :(
09:00:39 <`nand`> markov_twain: I'm very satisfied with my VPS provider, 7.5€/mo for the most minimal machine
09:00:56 <jmcarthur> i don't understand why people insist on using distro package managers for haskell packages, especially in cutting edge distros like arch
09:01:15 <markov_twain> `nand`: link?
09:01:18 <`nand`> jmcarthur: I think it's a blessing to be using portage for haskell packages
09:01:21 <jmcarthur> whenever a major dependency is upgraded it just breaks everything that depends on it because the package manager will typically just replace the old with the new
09:01:47 <`nand`> jmcarthur: for example, what do you do about distro packages that depend on haskell packages and vice versa otherwise?
09:02:05 <jmcarthur> no, i agree there that there isn't much choice
09:02:16 <jmcarthur> but that doesn't make it such a great situation in the face of upgrades
09:02:20 <`nand`> jmcarthur: fortunately portage automatically rebuilds reverse deps when upgrading haskell packages
09:02:24 <markov_twain> jmcarthur: the same problem exists for ruby packages
09:02:25 <jmcarthur> that's good
09:02:52 <ramses_> `nand`: thanks for the links, I'll have to go through some hackage libs to fully understand edwardk's code there. Although I think I've already seen a blog post once that did something similar
09:03:05 <bgamari>  pcapriotti, have you considered failing more gracefully in optparse-applicative when passed an unrecognized argument?
09:03:06 <`nand`> ramses_: it's pretty hefty stuff, I'll admit. I need a while to understand parts of it as well
09:03:11 <jmcarthur> markov_twain: at least with ruby packages there isn't necessarily a fundamental incompatibility between versions, no? with ghc packages, there *always* is
09:03:39 <`nand`> but still, just looking at the use examples is intriguing: with (Monoid (+) 0) $ mempty <> Lift 2
09:04:06 <`nand`> or “using (Monoid (+) 0) $ mappend mempty 12”
09:04:46 <`nand`> ramses_: there's a significantly simpler example of the same concept here: https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs
09:04:51 <pcapriotti> bgamari: like how?
09:04:52 <markov_twain> jmcarthur: there is to some degree. the ruby 1.8-series is end-of-life in 90 days or so, but osx (and apt last time i used it) are still on 1.8.7
09:05:01 <ramses_> `nand`: that Lift type is specific to the Monoid example, right?
09:05:10 <bgamari> pcapriotti, tell the user precisely which argument wasn't understood
09:05:24 <`nand`> ramses_: ‘Lift’ is not specific to monoids here
09:05:56 <bgamari> pcapriotti, actually, never mind. It seems the error messages is sufficient after all
09:06:28 <jmcarthur> markov_twain: yeah that's not the same thing. if you replace a haskell library then it automatically becomes fundamentally incompatible with anything that was built against the older version, even if it should be API compatible
09:06:29 <ramses_> `nand`: but the fact that it takes two arguments besides the constraint stems from the Monoid class having two fields, or is the resemblance a coincidence?
09:06:33 <pcapriotti> bgamari: the new argument parsing code I'm working on should give better error messages
09:07:11 <`nand`> ramses_: careful, ‘Monoid’ here is not a constraint, it's a data constructor (defined as part of the data family Def in the class ReifiableConstraint)
09:07:12 <bgamari> pcapriotti, alright, good to know. That being said, they are better than I recall them being
09:07:16 <pcapriotti> bgamari: and it incorporates your suggestion of parsing arguments by position by default
09:07:22 <`nand`> ramses_: eg. see data def Eq a = Eq { eq_ :: a -> a -> Bool }
09:07:32 <`nand`> using (Eq (/=)) $ 2 == 3 -- True
09:07:32 <markov_twain> jmcarthur: ah, ouch.
09:07:54 <ramses_> `nand`: maybe I should give it a thorough read before trying to guess what it does :)
09:10:45 <markov_twain> jmcarthur: so what's the solution to that problem? just don't use apt/portage/etc.?
09:11:03 * hackagebot multiarg 0.12.0.2 - Combinators to build command line parsers  http://hackage.haskell.org/package/multiarg-0.12.0.2 (OmariNorman)
09:12:20 <Shin-LaC> hm
09:12:33 <bitonic> markov_twain: I always suggest a recipe of GHC from your distro and everything else cabal
09:12:33 <lambdabot> bitonic: You have 1 new message. '/msg lambdabot @messages' to read it.
09:12:49 <Shin-LaC> let's say I implement the "last" function with pattern matching
09:13:06 <Shin-LaC> if you then do "last []" you get a "non-exhaustive pattern" exception
09:13:09 <bitonic> markov_twain: if you need recent/multiple GHC versions, pre-compiled binaries work fine—at least with linux
09:13:22 <Shin-LaC> should I raise a different exception? or should it be an error?
09:13:58 <bitonic> jmcarthur: the order of constructor thing is peculiar.  it’s definitely possible to implement ‘case’ in constant time as I’m sure you know
09:14:13 <bitonic> well
09:14:42 <bitonic> I guess the linear implementation is simpler in many respects
09:15:03 <markov_twain> bitonic: thanks. my least favorite part of getting into a new language is getting all the tools playing nicely together.
09:15:16 <bitonic> markov_twain: agreed, if the language is nice :)
09:15:23 <bitonic> some languages have very nice tools but are crap ehe
09:16:33 <bitonic> jmcarthur: I’m also surprised that with 3 constructors that has a measurable impact in performance actually.  but I guess it costs nothing to do it that way
09:16:47 <bitonic> I vaguely remember reading that and being surprised actually :P
09:18:08 <jmcarthur> markov_twain: i normally just install ghc from my package manager and everything else using cabal-install
09:19:13 <jmcarthur> bitonic: well, it should be possible to implement case for the head of a data structure in constant time anyway
09:19:20 <jmcarthur> (after evaluation, that is)
09:19:36 <jmcarthur> i believe the stg machine does something unusual here though
09:19:36 <bitonic> jmcarthur: yeah
09:19:42 <markov_twain> jmcarthur: lately i've been on osx (work laptop) and homebrew has been good
09:20:07 <bitonic> markov_twain: another thing: try to stick to the platform.  the bleeding edge is probably not worth it
09:20:17 <jmcarthur> my knowledge may be outdated, but i recall something about passing multiple continuations on the stack when evaluating the constructor and then just calling the continuation corresponding to that case
09:20:25 <jmcarthur> s/case/pattern/
09:20:30 <markov_twain> bitonic: ah, good advice, thanks
09:21:03 <jmcarthur> i can't live without the bleeding edge. i always want the new goodies
09:21:19 <bitonic> jmcarthur: my type thirst is quenched by other things now anyway :P
09:21:27 <jmcarthur> by what?
09:21:42 <bitonic> Agda!
09:21:46 <jmcarthur> yay agda!
09:21:56 <bitonic> it’s so much fun
09:22:00 <jmcarthur> i've been curious about idris, admittedly. haven't tried it out yet
09:22:05 <jmcarthur> i do love me some agda
09:22:52 <bitonic> Idris has a good mindset imo.  edwinb is pushing loads of stuff into it which is good and bad
09:22:58 <markov_twain> bitonic: is there a summary of the tools/resources most haskellers use day-to-day? for example, git/github? tools like "rvm" or "virtualenv"? make-like-tools? etc.
09:23:23 <thoughtpolice> markov_twain: git/github are to be used as you expect. for virtualenv equivalents, check 'hsenv'
09:23:26 <bitonic> markov_twain: well, I don’t need many tools: GHC, Cabal, cabal-install, cabal-dev, emas
09:23:29 <bitonic> *emacs
09:23:32 <thoughtpolice> which operates extremely similarly (it's one of my favorite tools)
09:23:50 <markov_twain> thoughtpolice: i will check it out, thanks!
09:24:12 <bitonic> cabal-dev has served me decently for what concerns sandboxing
09:24:15 <bitonic> markov_twain: oh, ghc-mod
09:24:16 <thoughtpolice> i guess the caveat is if you use windows. cabal-dev works there at least i'm sure, but hsenv requires modifying your shell
09:24:17 <jmcarthur> markov_twain: i usually start with ghc, cabal-install, darcs, emacs (haskell-mode + ghc-mod), hlint, ghc-core, hoogle
09:24:33 <jmcarthur> markov_twain: and threadscope
09:24:35 <thoughtpolice> so it's unix-only. i find it a lot better than cabal-dev
09:24:35 <markov_twain> bitonic: is there better support for vim/emacs or are they comparable? (eg. lisp support is way nicer in emacs)
09:24:52 <thoughtpolice> i should probably try out the new sandboxing stuff in cabal proper
09:24:58 <thoughtpolice> markov_twain: they're fairly comparable IMO
09:25:09 <bitonic> markov_twain: I’m tremendously biased towards emacs in general.  ghc-mod is the best ‘interactive’ mode for Haskell afaik and it’s meant to be with emacs, but vim frontends exist as well
09:25:13 <jmcarthur> bitonic: emacs tends to have better "support" for everything, but the reason to use vim isn't support for some language but the basic text editing facilities
09:25:14 <thoughtpolice> markov_twain: if you're a vim user, i find this to be really nice: https://github.com/jejansse/Haskim
09:25:23 <markov_twain> jmcarthur: all good links i need to read about, thanks!
09:25:30 <thoughtpolice> if you're an emacs user, it takes only a few minutes to set up haskell-mode + ghc-mod
09:25:40 <thoughtpolice> (unfortunately no nice automated provising script)
09:25:48 <jmcarthur> i can't wait for holes support in emacs
09:26:07 <bitonic> yeah holes rocks.  I miss ‘C-c C-r’
09:26:20 <bitonic> and then some djinn/agsy-like integration
09:26:21 <jmcarthur> i even use C-c C-a a lot
09:26:26 <jmcarthur> yeah
09:26:41 <jmcarthur> agsy is a lot better than djinn
09:26:59 <jmcarthur> (it has more to work with)
09:27:03 <bitonic> jmcarthur: well agsy is actually aware of the context
09:27:07 <bitonic> but djinn does recursion for example
09:27:10 <bitonic> (iirc)
09:27:12 <jmcarthur> nope
09:27:13 <bitonic> agsy doesn’t
09:27:18 <jmcarthur> agsy does!
09:27:19 <bitonic> ah
09:27:19 <markov_twain> i've been doing ruby for ~2 years, and there's a strong preference for vim in that community, so I'm more comfortable in vim, but I've grown to love emacs for scheme-learnin'
09:27:22 <bitonic> ok
09:27:30 <bitonic> jmcarthur: I can never get agsy to infer recursive calls
09:27:39 <jmcarthur> it's not very good at it, but it does
09:27:51 <thoughtpolice> markov_twain: you won't have anything quite as amazing as paredit of course. i'd say you're pretty safe with whichever you choose, both are fairly well supported
09:27:59 <jmcarthur> bitonic: the easiest off-the-top-of-my-head example is list concatenation. it can infer the entire implementation
09:28:03 <thoughtpolice> (paredit is a godsend since i've been writing emacs lisp recently)
09:28:19 <bitonic> jmcarthur: oh.  then it’s very bad at it, I can’t remember a time when it worked, but maybe I’m just used to write recursive calls myself now
09:28:22 <thoughtpolice> even if it's only a minor mode; SLIME is of course its own amazing world
09:28:30 <jmcarthur> bitonic: you just give the type, then  xs ++ ys = ?, then go into the hole and type -c and then hit C-c C-a
09:29:03 <markov_twain> thoughtpolice: i don't really mind any editor anymore since i've been using my phone to do most of my outside-of-work programming for about a year. (it's hell)
09:29:12 <jmcarthur> :o
09:29:17 <bitonic> jmcarthur: how can that work?
09:29:25 <bitonic> eh I get ‘xs ++ ys = ys’.
09:29:39 <bitonic> which typechecks but is useless
09:29:42 <jmcarthur> bitonic: oh, i must be thinking a stronger type like with static lengths
09:29:44 <bitonic> maybe you mean Vec?
09:29:45 <bitonic> yeah
09:30:05 <markov_twain> thoughtpolice: but it is interesting how the inability to write a lot forces me to think a problem over more carefully
09:30:32 <madjestic> hey guys, is there a more elegant way to express the same thing as in: http://hpaste.org/84925 ?  leaves' and subleaves are doing essentially the same thing, the only difference is that leaves' argument is Tree [Char], while subleaves argument is [Tree [Char]].  I am interested in a generic answer for such case
09:30:33 <`nand`> I believe not using an IDE/code generation promotes shorter, more elegant code
09:30:53 <`nand`> if I look back at the kind of C#.NET code I was writing with Visual Studio's assistance, it makes me shudder
09:31:00 <`nand`> so much boilerplate, mainly because it was easy to generate
09:31:01 <bitonic> jmcarthur: it works for Vec!  what’s ‘-c’?
09:31:21 <thoughtpolice> markov_twain: indeed!
09:31:35 <jmcarthur> bitonic: -c tells it to try pattern matching
09:31:40 <bitonic> oh ok, thanks
09:31:43 <bitonic> neat
09:31:57 <jmcarthur> bitonic: -m encourages it to look at other things you have defined, like at the top level
09:32:02 <thoughtpolice> `nand`: agda's interactive features are quite a bit more valuable than VS's assist features
09:32:15 <thoughtpolice> i'd say they're not even in the same league or ballpark
09:32:15 * bitonic finds out that his agsy knowledge is outdated
09:32:30 <`nand`> thoughtpolice: indeed
09:32:32 <jmcarthur> bitonic: -l lists multiple possible implementations
09:32:33 <thoughtpolice> (they're also quite a bit different, perhaps 'valuable' isn't the right word)
09:32:46 <markov_twain> thoughtpolice: not that i write good (or even interesting) code :) -- usually it's short things like this https://gist.github.com/benolee/31180733dd09cccbccbe
09:32:51 <jmcarthur> bitonic: -s <n> chooses one of them. combined with -l it is like scrolling through more possibilities
09:33:03 <bitonic> jmcarthur: it’s like shopping for proofs
09:33:06 <jmcarthur> yup!
09:33:34 <bitonic> what I’d like is a ‘_’ that uses agsy with a low timeout
09:33:45 <jmcarthur> eh, i wouldn't want that
09:33:49 <markov_twain> btw, thanks for all the good links everyone
09:33:57 <jmcarthur> since depending on system load it means that my typechecking may or may not actually work
09:34:12 <bitonic> jmcarthur: typechecking would fill everything in
09:34:39 <bitonic> I just don’t want to type ‘C-c C-a’ :P
09:34:56 <jmcarthur> oh you just mean a hole that gets filled in non-interactively, but still only once?
09:34:59 <ludamad> how can I catch  "illegal operation (handle is closed)", this should be an IOException, right ?
09:35:00 <bitonic> yes
09:35:10 <jmcarthur> eh, i usually find myself cleaning up anyway
09:36:12 <bitonic> jmcarthur: actually I’d like even more a ‘C-c C-r’ that tries to fill in the new holes with agsy automatically even more
09:36:16 <bitonic> maybe that exists already
09:36:29 <bitonic> so it’s agsy with an initial push
09:37:02 <jmcarthur> what i don't understand is why agsy would ever fail to start with refine in the first place
09:38:10 <bitonic> jmcarthur: well, it happens all the time
09:38:20 <bitonic> I’m not an expert in proof search so I don’t really know what’s going on ehe
09:38:45 <bitonic> there’s the issue that for many proofs there are many paths
09:38:45 <jmcarthur> yeah it just seems like the obvious way to shrink the search space early, to me
09:39:00 <jmcarthur> since refine is basically an unambiguous step
09:39:00 <bitonic> especially with certain things like equality, and the space just explodes
09:39:13 <bitonic> jmcarthur: refine with what function?
09:39:30 <jmcarthur> ?
09:39:40 <jmcarthur> perhaps i am about to learn something about refine
09:39:48 <jmcarthur> i only ever use C-c C-r by itself
09:40:11 <bitonic> jmcarthur: I type the function I want to use to proceed, and then C-c C-r, and Agda puts the right holes for the arguments
09:40:16 <jmcarthur> oh
09:40:21 <jmcarthur> i do that too
09:40:28 <jmcarthur> i just always forget that it's the same refine
09:41:05 * hackagebot hois 0.1.0.0 - OIS bindings  http://hackage.haskell.org/package/hois-0.1.0.0 (DavidEichmann)
09:41:12 <jmcarthur> i have found often that agsy will succeed if i, say, start a lambda using C-c C-r, whereas it might not if i don't
09:41:20 <jmcarthur> that's the thing i find weird
09:42:16 <bitonic> jmcarthur: well refine has lambda as the only constructor for pi types, agsy simply looks for matching types
09:42:26 <bitonic> refine does a much more specialised search
09:42:27 <hpaste> DanZimm pasted “Help with Memoization” at http://hpaste.org/84926
09:42:43 <DanZimm> So who is a memorization expert? :P
09:42:46 <jmcarthur> bitonic: in the absense of -m, it should be just as unambiguous for agsy, no?
09:42:54 <jmcarthur> DanZimm: memoization, you mean?
09:43:04 <DanZimm> yes
09:43:12 <DanZimm> that would be macs autocorrect :P
09:43:28 <`nand`> I know a few memorization experts. Memoization, not so much :)
09:43:35 <bitonic> jmcarthur: what do you mean?  there’s still the rest of the context.  but yes I would expect agsy to have heuristics to choose constructors early over definitions
09:43:47 <DanZimm> `nand` :P
09:44:14 <bitonic> jmcarthur: what’s likely happening there is agsy going down some rabbit hole using some other definition in the local context
09:44:20 <bitonic> before it chooses the constructor
09:44:49 <jmcarthur> bitonic: i would have thought that it would start at the head and that it would find the unambiguous constructor immediately for that and the forget about it
09:44:55 <jmcarthur> *and then forget
09:45:16 <jmcarthur> and so it would be unlikely to cause it to time out
09:45:36 <bitonic> jmcarthur: why?  sometimes applying constructors does not lead to a proof.  refine simply looks for a matching constructor, but that doesn’t mean that it’ll help
09:46:09 <jmcarthur> bitonic: right, but i'm saying there are times when supplying that constructor *does* help, and i would think that at those times it would have already chosen that constructor early on anyway
09:46:41 <bitonic> jmcarthur: it’s a heuristic, and it looks like agsy doesn’t have it.  maybe it’s not as helpful as you’d expect, or maybe it’s an unpicked low hanging fruit that you discovered :P
09:46:48 <jmcarthur> bitonic: e.g. if the hole is a function i would expect it to first generate a lambda and then work on the body
09:46:57 <jmcarthur> no, i mean i don't think it's even a heuristic
09:47:00 <jmcarthur> it's unambiguous
09:47:18 <jmcarthur> (unless you use -m)
09:47:22 <bitonic> jmcarthur: why not?  agsy has definitions in scope, including constructors, and it tries to compose them.  refine searches for matching constructors
09:47:29 <DanZimm> in all seriousness though, I don't exactly understand memoization fully but I do understand that the map function combined with !! operator seems to memoize (or from what I understand, cache) the result speeding up the return of a function when its called with the same arguments multiple times. What I don't seem to understand is why when I add an additional argument the caching no longer seems to exist (considering it takes much
09:47:29 <DanZimm>  longer to iterate through different arguments of the function)
09:47:40 <bitonic> jmcarthur: -m doesn’t imply that there is *no* context (afaik about -m...)
09:48:16 <jmcarthur> bitonic: i'm just saying that when you say -m it's more likely that a lot of other functions could be used as the head
09:48:26 <jmcarthur> bitonic: but when there is only one possible head, that's when i'm confused
09:48:43 <bitonic> jmcarthur: wait are you saying that agsy does not put the constructors even when they are the only matching thing?
09:48:56 <jmcarthur> maybe it's just that there are candidates that i am not aware of...
09:49:20 <bitonic> jmcarthur: consider that with polymorphic types you can go a long way to fit them ehe
09:49:55 <jmcarthur> yeah if you are using higher rank types things get more interesting
09:50:03 <jmcarthur> err
09:50:10 <jmcarthur> right
09:50:17 <jmcarthur> for a second i mixed up rank and kind in my head
09:50:23 <no-n> how would I sort a list of strings by length?
09:50:28 <bitonic> and I’m not sure that preferring lambdas for function types would be a good heuristic, I rarely type lambdas.  but it should definitely try before going too deep in other directions
09:50:52 <jmcarthur> i'm only speaking of the cases when i believe there are *no* other directions to go in
09:50:53 <bitonic> no-n: sortBy (comparing length)
09:50:59 <bitonic> @ty sortBy (comparing length)
09:51:01 <lambdabot> [[a]] -> [[a]]
09:51:10 <no-n> what is comparing?
09:51:11 <bitonic> jmcarthur: oh, then it definitely should.
09:51:23 <jmcarthur> bitonic: sortBy (comparing length) is so unfortunate :(
09:51:35 <bitonic> @ty comparing -- no-n it compares after applying a function to both sides
09:51:36 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
09:51:38 <jmcarthur> bitonic: i wish our go-to sorting function was sortOn rather than sortBy
09:51:54 <no-n> ok
09:51:56 <jmcarthur> bitonic: sortBy (comparing length) will recompute length a lot
09:52:02 <bitonic> true
09:52:04 <DanZimm> shoulda known better than to ask on a christian holiday :P
09:52:17 <bitonic> DanZimm: I’m bursting with food right now, still on #haskell!
09:52:24 <DanZimm> bitonic :D
09:52:26 <jmcarthur> :t map head . sortBy (comparing snd) . map (id &&& length)
09:52:27 <lambdabot>     Couldn't match expected type `[b0]' with actual type `(a0, b1)'
09:52:28 <lambdabot>     Expected type: [b0] -> a1
09:52:28 <lambdabot>       Actual type: (a0, b1) -> b1
09:52:38 <jmcarthur> :t map fst . sortBy (comparing snd) . map (id &&& length)
09:52:40 <lambdabot> [[a]] -> [[a]]
09:52:50 <jmcarthur> that should be the fast way
09:53:18 <bitonic> DanZimm: and I’m like 2 or 3 kms from the pope.  maybe some of the holiness will come through IRC.
09:53:19 <trolling> the fast way would be to write it in C
09:53:29 <bitonic> you do your nickname justice
09:53:32 <jmcarthur> in fact, we could improve that further with a lazy length, at least if we had the improving naturals thing i was talking about yesterday...
09:53:35 * trolling bows
09:53:43 <bitonic> jmcarthur: you love those lazy nats don’t you
09:53:48 <jmcarthur> :)
09:53:53 <DanZimm> trolling talking to me?
09:54:06 <DanZimm> jmcarthur was that directed towards me?
09:54:23 <jmcarthur> DanZimm: no, but i'm about to address your question
09:54:36 <DanZimm> okey dome cuz i was asking about speed xD
09:55:30 <jmcarthur> DanZimm: your problem is that by introducing theta you have turned your top-level values into functions, so the list is going to be regenerated each time you apply theta (unless you get lucky and ghc inlines the function)
09:55:44 <jmcarthur> (and even then if it is used in more than one place you're still screwed)
09:56:20 <DanZimm> ah right (I'm still pretty new at haskell and keep forgetting the whole 'completely functional language' thing :P)
09:56:52 <jmcarthur> DanZimm: the goal with memoization in haskell is to try to keep your memo table outside of the function definition
09:57:02 <jmcarthur> (actually, this applies in any language)
09:57:30 <DanZimm> i guess my goal was to have multiple memo tables, one for each theta i input
09:57:34 <jmcarthur> DanZimm: frankly, i recommend using one of the memoization libraries instead of using list indexing like this unless you have a good reason for doing it this way
09:57:45 <jmcarthur> yeah you can definitely do that
09:57:49 * DanZimm didn't realize theres libraries
09:58:09 <DanZimm> (again new to haskell)
09:58:30 <DanZimm> do you have any recommended libraries?
09:58:31 <jmcarthur> DanZimm: http://hackage.haskell.org/package/MemoTrie http://hackage.haskell.org/package/data-memocombinators
09:58:43 <jmcarthur> i kind of like the first one of those more
09:58:47 <DanZimm> sweet thanks jmcarthur  :D
09:59:01 <DanZimm> all have a nice day!
09:59:05 <bitonic> DanZimm: this is a nice post about memo in Haskell as well: <http://stackoverflow.com/questions/3208258/memoization-in-haskell>
09:59:08 <jmcarthur> DanZimm: i also have my own http://hackage.haskell.org/package/stable-memo but it's a different kind of memoization which you probably shouldn't use unless you know you need it
09:59:27 <bitonic> DanZimm: didn’t read your question so forgive me if it’s not that relevant
09:59:32 <DanZimm> jmcarthur aight, ill take a look
09:59:48 <DanZimm> bitonic learning new things is always a good thing :D
09:59:58 <bitonic> DanZimm: yeah that post is neat
10:01:08 * DanZimm sneaks into the abyss
10:18:52 <osfameron> one does not simply sneak into the abyss
10:20:06 <amindfv> anyone know which version of GHC was the first to have a version of base with catchIOError in System.IO.Error?
10:23:13 <amindfv> ok, looks like i'm looking for a version of GHC with base >= 4.4
10:23:41 <amindfv> how can i find which version of base ships with a ghc release?
10:27:18 <JoeyA> Just binary search on http://hackage.haskell.org/packages/archive/base/<version>/doc/html/System-IO-Error.html
10:27:34 <JoeyA> Hackage is slow right now, so each request will take about 10 seconds, but at least you can find it in log time :-)
10:27:47 * JoeyA looks
10:27:50 <amindfv> JoeyA: haha yeah, that's was i did, and with similar time results
10:27:55 <amindfv> *what
10:28:08 <JoeyA> Hackage has been slow for several days.  What gives?
10:28:23 <amindfv> base 4.4+ is what i'm looking for, but i don't know which GHCs ship with it
10:28:28 <amindfv> yeah, i've noticed that too
10:28:57 <JoeyA> base 4.3 is GHC 7.0, base 4.4 is GHC 7.2, base 4.5 is GHC 7.4, base 4.6 is GHC 7.6
10:29:43 <amindfv> nice! thanks.
10:29:47 <amindfv> how did you find that?
10:29:54 <JoeyA> Memory
10:30:02 <JoeyA> amindfv: base 4.4 introduced catchIOError
10:32:45 <amindfv> crap, looks like it's an upgrade-my-OS kind of day...
10:32:47 <amindfv> thanks
10:32:56 <ab9rf> amindfv: i hate toolchain update day.
10:34:58 <ab9rf> it seems whenever i sit down to do some project or another i inevitably spend a half day updating toolchains before i can actually get started
10:37:28 <amindfv> ab9rf: it's always something little, too, that cascades into needing to upgrade everything
10:38:12 <JoeyA> I'm still on Ubuntu 10.04.  Get off my lawn.
10:38:27 <kurkale6ka> Regarding my previous question, just to confirm: in instance Functor (Either a) where, Either a has nothing to do with currying, is that right?
10:38:29 <amindfv> oh, one function in cabal-dev needs uses a function from base 4.4+, which needs ghc 4.2+, which needs fedora 18… well, there goes the afternoon
10:38:35 <JoeyA> (but I'm not using GHC 6.12, thank goodness)
10:39:05 <JoeyA> amindfv: I just download the platform tarball and install it that way.
10:40:37 <amindfv> JoeyA: the platform needs ghc7.4 to install, and fedora17 (because of a libgmp.so version problem) maxes out at ghc 7.0-ish
10:40:43 <amindfv> (so far as i can tell)
10:41:06 * hackagebot bogre-banana 0.0.1 -   http://hackage.haskell.org/package/bogre-banana-0.0.1 (DavidEichmann)
10:41:46 <amindfv> (the platform tarball, i mean)
10:42:27 <JoeyA> amindfv: you can download and install the GHC tarball, too: http://www.haskell.org/ghc/download
10:42:28 <JoeyA> warning: it unpacks to 900MB
10:42:52 <JoeyA> You don't even need to update haskell-platform.  Just cabal install foo, and it'll bring in whatever platform dependencies you need.
10:45:50 <amindfv> JoeyA: do you mean e.g. http://www.haskell.org/ghc/download_ghc_7_6_2#x86_64linux ?
10:47:02 <JoeyA> amindfv: right
10:47:16 <amindfv> yeah, that's got the libgmp.so.3 dependency problem
10:47:24 <JoeyA> hmm
10:48:07 <JoeyA> Works for me (I'm on Ubuntu 10.04).  Maybe it's having trouble finding the 64-bit libs.
10:48:50 <JoeyA> Though I have /usr/lib/libgmp.so.3, so maybe your distro is older.
10:48:57 <JoeyA> I rest my case.
10:50:41 <amindfv> hm, weird - i have libgmp.so.10
10:50:55 <amindfv> so upgrading my OS probably won't do anything
10:51:31 <amindfv> maybe i can just (gasp!) symlink the older version to the new version
10:52:18 <TravisD> Is there a good library for writing shell scripts in Haskell?
10:52:36 <TravisD> or, shell-like scripts :P
10:53:14 <bitonic> TravisD: there is shelly but I haven’t tried it
10:53:14 <amindfv> TravisD: i sometimes use http://hackage.haskell.org/package/HSH
10:53:58 <TravisD> Ah, thanks. I was looking at Shelly but I wanted to make sure there wasn't another library that most people use
11:05:58 <Palmik> Hmm, I use ghcmod-vim and when I use #if MIN_VERSION_<pkg>(...) macro, I get "Error:ghc-mod: phase `C pre-processor' failed (exitcode = 1)". Does anyone have an idea how to solve this problem?
11:08:22 <Nafai> Kinnison: I've been enjoying your Haskell coding videos
11:37:12 <gspr> Is uploading packages to Hackage that do almost exactly, but not quite, the same as other packages frowned upon?
11:39:08 <dario> wouldn't think so, if the "but not quite" part earns its name
11:39:58 <Eduard_Munteanu> I don't think anyone minds diversity. Even a slightly different implementation sounds worthy.
11:41:27 <Eduard_Munteanu> However, do you wish to maintain such alternative packages? It might be easier to work with stuff that exists already.
11:48:25 <oio> haskell substrings?
11:48:45 <oio> find substrings fastest way
11:49:07 <elliott> do you have a question? :P
11:49:58 <oio> find substrings fastest way ?
11:50:55 <oio> > nub . concat . map (drop 1 . inits) . tails $ "qwertyy"
11:50:57 <lambdabot>   ["q","qw","qwe","qwer","qwert","qwerty","qwertyy","w","we","wer","wert","we...
11:51:21 <oio> works but slow... with 999 + strings
11:52:19 <gspr> dario, Eduard_Munteanu: Yeah, I guess... so, specifically, this is about interfacing with POSIX' clock_gettime(2). In particular, I need its monotonic clock facilities. For this use, there's already at least, (1)posix-timer and (2)clock. I certainly don't want to criticize any of them (they were probably written by smarter people than me), but they're not perfect for my needs. (1) Doesn't emulate the clock on windows, and seems to assume that c
11:53:14 <gspr> dario, Eduard_Munteanu: So I wrote my own package, which tries to correct these issues - but I'm a bit doubtful as to whether I should upload it and just pollute the hackage namespace even more :)
11:53:42 <danr> oio: nub is n^2
11:54:13 <bh> Speaking of clocks and time. I'm trying to get an RFC2822 time as DateTime, but the extant library seems to produce EpochTime which I don't grok converting because it has no instance for Integral
11:55:20 <oio> danr: yes my algorithm isn't right and put some duplicates adding nubs makes the whole thinks slower but works
11:55:57 <danr> oio: you can use map head . group . sort, which is nlogn
11:58:21 <rifki> hi, I have a function makeTuple [(a,b)] = (a,b) which turns a list of tuple (the list has one tuple) to tuple. How can I handle the empty list case? I wrote makeTuple [] = [] or makeTuple [] = ()  but it didn't work
11:59:09 <oio> danr: yeah i could but the problem, is that my (poor) algorithm shouldn't create duplicates so i dont have make another pass to find them
11:59:38 <Botje_> rifki: that's for you to decide.
11:59:41 <oio> concat . map (drop 1 . inits) . tails $ "qeyy"
11:59:50 <oio> > concat . map (drop 1 . inits) . tails $ "qeyy"
11:59:52 <lambdabot>   ["q","qe","qey","qeyy","e","ey","eyy","y","yy","y"]
12:00:02 <Botje_> rifki: if you're _certain_ you will never see an empty list, write something like makeTuple [] = error "makeTuple called with empty list"
12:00:08 <Botje_> or leave out the [] case altogether.
12:00:17 <oio> danr: see there two Y
12:01:00 <sepp2k> Why does GHC refer to main as a function when it complains about the Main module not defining main ("The function `main' is not defined in module `Main'")? That plainly contradicts the "There's no such thing as a nullary function in Haskell" mantra I keep spouting :-(
12:01:17 <ab9rf> rifki: () is not type-conformant with (a,b)
12:01:56 <ab9rf> sepp2k: main isn't really a function
12:02:08 <ab9rf> sepp2k: which is irritating
12:02:31 <sepp2k> ab9rf: I would agree with you on that, but the error message I just quoted apparently does not.
12:02:48 <dario> gspr: your first line got cut off after "seems to assume that c", but as i see it it behaves differently in a way significant at least to your current project, so it's probably worth uploading
12:02:51 <rifki> thank you people!
12:04:36 <dario> gspr: that's a problem with a lot of haskell packages though, i usually only find them after i reimplemented the part i could have used myself..
12:04:38 <parcs> sepp2k: what do you propose to call main?
12:04:47 <gspr> dario: ah, sorry, it continued "... seems to assume that clockid_t is  always an Int32. (2) Incorrectly mirrors struct timespec.
12:05:33 <gspr> dario: Yep, I've experienced that too
12:06:06 <sepp2k> parcs: IO action? Or just "`main' is not defined in module `Main'."
12:07:12 <kennyd> rifki you could return Maybe (a,b)
12:09:46 <rifki> I gave (-1)
12:09:51 <parcs> sepp2k: what about "the binding"?
12:10:10 <rifki> I gave (-1,-1)  and it worked fine, thanks :)
12:11:02 <sepp2k> parcs: Maybe.
12:17:40 <jmcarthur> what's wrong with "value"?
12:18:10 <parcs> terminology sucks in this area
12:18:22 <parcs> i think 'function', while imprecise, is fine
12:19:24 <jmcarthur> i believe "value" is precise and is unlikely to be confusing
12:19:45 <jmcarthur> The value `main' is not defined in module `Main'
12:20:11 <parcs> that sounds off
12:20:30 <jmcarthur> we don't have to call it anything, really
12:20:35 <jmcarthur> `main' is not defined in module `Main'
12:21:10 <ab9rf> jmcarthur: except that means you start a sentence with a miniscule letter.
12:21:21 <Philippa> so precise would be that the variable 'main' is not bound in the module 'Main'
12:21:26 <parcs> i prefer "the binding" if i had to choose
12:21:34 <Philippa> but "main isn't defined in Main" works fine
12:21:42 <ab9rf> "No binding found for 'main' in the module 'Main'."
12:22:04 <parcs> this is major bikeshedding :P
12:22:08 <ab9rf> parcs: yes
12:22:54 <sepp2k> ab9rf: Don't you usually use lower case after a colon anyway? That is, isn't "foo.hs:1:1: blabla" actually more correct than "foo.hs:1:1: Blabla"? Or am I confusing English and German?
12:23:22 <ab9rf> sepp2k: it depends on what "foo.hs:1:1:" is
12:23:39 <ab9rf> sepp2k: you use lower case after a colon when the colon is preceded by sentential material, but in this case it is not.
12:23:56 <sepp2k> I see. Thanks.
12:24:27 <ab9rf> sepp2k: of course, i have a fairly low respect for majuscules to begin with :)
12:24:46 <TheRedMood> Does anyone here know "The Haskell Road to Logic, Maths and Programming" ?
12:24:56 <TheRedMood> https://gist.github.com/TheRedMood/5281628
12:25:25 <TheRedMood> I solved some of the tasks, but i think that I solved them like an imperial programmer.
12:25:51 <TheRedMood> Can someone take a look and tell me if something should be corrected or if I have butchered some parts of it completly? Except for the identation :O
12:28:50 <ab9rf> 'imperial programmer'?
12:29:03 <ab9rf> like, you used the dark side of the force?
12:30:03 <TheRedMood> I have only dealt with languages like C, python and go.
12:30:12 <Philippa> ab9rf: shot lots, hit nothing?
12:30:15 <Hafydd> TheRedMood: you might want to review the definition of "proper divisor".
12:31:10 <TheRedMood> ?
12:31:10 <ludamad> oh man. Got my threaded server working passing JSON \o/
12:31:13 <TheRedMood> What line?
12:31:18 <TheRedMood> ludamad, Good going :D
12:31:29 <ludamad> my head hurts now
12:31:37 <Hafydd> The single line containing the phrase "proper divisor".
12:31:38 <ludamad> time for a break
12:31:54 <TheRedMood> Oh okay :)
12:32:47 <TheRedMood> That was just me paraphrasing the book. Seems I messed up that too. I mean that it has no divisors that gives no reminder other than itself and 1
12:33:18 <dmwit> TheRedMood: Okay, so, ld/ldf is definitely the straightforward translation of an imperative-style for-loop into Haskell.
12:33:31 <Hafydd> It happens that "no proper divisors" is equivalent to "no divisors other than 1 and itself".
12:33:50 <dmwit> TheRedMood: But it's definitely more idiomatic to use (lazy) lists to represent your loop, and then use things like "map", "filter", "foldr", "any", "maximum", and friends to modify the list.
12:34:20 <TheRedMood> dmwit, Thanks :D Luckly for me both of them are taken straight from the book.
12:34:23 <TheRedMood> XD
12:34:58 <TheRedMood> and I will try to see how I could do it using map and friends.
12:35:26 <ab9rf> dmwit: or to recast the iteration as a recursion
12:35:28 <TheRedMood> But ld?
12:35:33 <dmwit> TheRedMood: I'd make similar comments about {mnm,max}{Int,String}, as well.
12:35:50 <dmwit> :t foldr1
12:35:51 <lambdabot> (a -> a -> a) -> [a] -> a
12:35:59 <ab9rf> dmwit: since nearly any iteration can be restructred as a (tail) recursion
12:36:03 <dmwit> ^^ the Haskell style: abstract the recursive pattern and reuse it
12:36:08 <dmwit> :t foldr1 max
12:36:09 <lambdabot> Ord a => [a] -> a
12:36:17 <dmwit> ?src maximum
12:36:17 <lambdabot> maximum [] = undefined
12:36:18 <lambdabot> maximum xs = foldl1 max xs
12:36:19 <TheRedMood> Yeah, it applies a function to a list
12:36:36 <dmwit> Okay, so maximum uses foldl1 instead of foldr1, but hopefully you take my point. =)
12:36:46 <TheRedMood> Yes, I know those functions, on the surface atleast, but I was asking how ld should have been replaced
12:36:51 <dmwit> ab9rf: Yes, that is the approach TheRedMood took.
12:36:53 <TheRedMood> Sorry to disappoint you, but I don't :(
12:36:57 <elliott> maximum [] should totally be minBound.
12:37:03 <ab9rf> dmwit: foldr is more efficient thatn foldl typically, and max being symmetric it doesnt matter which you use
12:37:19 <plates> hello fucking cunt nigger shit whores, what is up?
12:37:22 <plates> fucking cunts!
12:37:24 --- mode: ChanServ set +o elliott
12:37:25 --- mode: elliott set +b *!*plates@gateway/tor-sasl/plates
12:37:26 --- kick: plates was kicked by elliott (plates)
12:37:29 --- mode: elliott set -o elliott
12:37:34 <quchen> Plates! Welcome to our community!
12:37:36 <quchen> Oh.
12:37:53 <TheRedMood> elliott, did he harrass you too?
12:37:57 <dmwit> TheRedMood: If you rewrite ldf to use lists, its interface will change a little bit, and as a result its callers (like ld here, or possibly prime0 instead) will have to change to accomodate.
12:37:59 <Mortchek> elliott, you lose the ability to apply maximum to Integer
12:38:04 <Mortchek> [Integer] I mean
12:38:05 <ab9rf> TheRedMood: i got a weird message from him but i ignored it
12:38:13 <TheRedMood> Yeah, I just ignored him
12:38:16 <elliott> TheRedMood: no private messages, but they harrassed #haskell
12:38:29 <TheRedMood> Oh okay.
12:38:35 <TheRedMood> I got him ignored so I guess that is why.
12:38:36 <Philippa> which is usually the better reason for a response /in/ #haskell
12:38:37 <jfischoff> quchen: that log you posted was hilarious
12:38:39 <ab9rf> i was kinda expecting that
12:38:55 <elliott> Mortchek: well, you can make a data WithBounds a = MinBound | Unbounded a | MaxBound.
12:38:58 <dmwit> Whoa, what's up with RichiH's NOTICE?
12:39:09 <elliott> and then use "ala" or such to use maximum with it to get a Maybe result.
12:39:10 <TheRedMood> dmwit, Would you mind explaining it to me?
12:39:11 <TheRedMood> Or?
12:39:21 <dmwit> TheRedMood: Explaining what to you?
12:39:23 <elliott> admittedly not the lowest-effort solution.
12:39:24 <TheRedMood> Oh!
12:39:27 <dmwit> Ask a question and I'll gladly try to answer.
12:39:29 <TheRedMood> You sent me a second message.
12:39:46 <TheRedMood> Yes, I didn't see the reply about ldf because of the plates thing.
12:39:56 <ciaranm> dmwit: it's 1st april
12:40:00 <dmwit> elliott: There's such a type in monoids-extra
12:40:08 <dmwit> ciaranm: aha
12:40:19 <dmwit> It isn't, here, yet, so I reserve the right to be surprised. =P
12:40:27 <ciaranm> it isn't in the URL either
12:40:37 <TheRedMood> ?
12:40:39 <TheRedMood> What notice?
12:41:06 <roshan> That reminds me, I was watching the lens video and edwardk mentioned uniplate. Some googling revealed biplate and multiplate as well. What do they do?
12:41:10 <dmwit> elliott: Whoops, it's called monoid-extras, not monoids-extra.
12:41:20 <elliott> monoids-extras
12:41:31 <ab9rf> dmwit: and why is he posting code in brainfuck?
12:41:34 <Mortchek> elliott, going with the theme already existing with certain functions (e.g., read versus readMaybe), I'd say have a separate total version that does have the Bounded constraint
12:41:54 <dmwit> roshan: There's papers about them! =)
12:41:59 <dmwit> roshan: (They're for generic programming.)
12:42:10 <elliott> Mortchek: well, read shouldn't even exist, just like head and so on. in an ideal world.
12:42:15 <TheRedMood> dmwit, okay, I will try to work out how I should have done ldf. Can I come back and post the "new" version for you later?
12:42:23 <ciaranm> it is rather worrying how many people on this network immediately realise that that's brainfuck code
12:42:37 <ab9rf> ciaranm: haha
12:42:38 <roshan> dmwit: They reference the Scrap Your Boilerplate paper. Should I try reading that?
12:42:38 <TheRedMood> What is brainfuck code?
12:42:52 <dmwit> TheRedMood: Try wikipedia.
12:42:56 <ab9rf> ciaranm: what's even scarier is how many can figure out its output WITHOUT running it
12:42:59 <TheRedMood> Yeah I know what brainfuck is
12:43:00 <Mortchek> elliott, that gives me an idea – how about maybeMaximum :: (Ord a) => [a] -> Maybe a ?
12:43:05 <TheRedMood> But I wonder what you are all talking about
12:43:28 <dmwit> TheRedMood: You should find out how your IRC client shows NOTICEs, and then look for one at about 15:37 today.
12:43:31 <elliott> Mortchek: that would work, but it's what you get from such a WithBounds wrapper anywayg
12:43:32 <dmwit> current time 15:43
12:43:33 <Mortchek> Agreed though, read is ugly
12:43:34 <TheRedMood> AH!
12:43:36 <dmwit> in case we're in different time zones.
12:43:38 <TheRedMood> Okay, then I was not here :D
12:43:39 <elliott> Mortchek: the nice thing about maximum [] being minBound is that it's an identity element
12:43:43 <TheRedMood> Oh, okay.
12:43:45 <elliott> in lines with sum [] and product []
12:44:46 <dmwit> Mortchek: Why not maximum :: [a] -> PosInf a, as in monoid-extras:Data.Monoid.PosInf (soon to be monoid-extras:Data.Monoid.Inf)? ;-)
12:45:31 <Mortchek> I can't find that on Hoogle – How do I find the docs on that?
12:45:36 --- mode: ChanServ set +o mauke
12:45:36 <ab9rf> maximum [] is undefined, isn't it?
12:45:37 --- mode: mauke set -b+b *!*plates@gateway/tor-sasl/plates $a:plates
12:45:40 <dmwit> http://hackage.haskell.org/packages/archive/monoid-extras/0.2.2.3/doc/html/Data-Monoid-PosInf.html
12:45:45 <ab9rf> > maximum []
12:45:46 <lambdabot>   *Exception: Prelude.maximum: empty list
12:45:49 <Mortchek> ab9rf, that's the idea, we're discussing alternative definitions so it's not
12:45:50 <ab9rf> yeah, though so
12:46:09 <elliott> mauke: hmm, is there a way to get irssi to set $a bans like that by default if the user is logged in?
12:46:10 <ab9rf> Mortchek: sure, makes sense
12:46:27 <elliott> Mortchek: oh, and ideally minBound and maxBound would be in separate classes
12:46:34 <elliott> since minimum/maximum only need the opposite bound
12:46:45 <ab9rf> Mortchek: since maximum is only defined over Ord a, so you can rely on other Ord requirements
12:46:58 <ab9rf> elliott: ugh!
12:47:04 <Mortchek> dmwit, that is pretty elegant.
12:47:05 <elliott> Data.Monoid.PosInf needs runPosInf :: Bounded a => PosInf a -> a
12:47:08 <elliott> or such.
12:47:36 <dmwit> That's not a bad idea.
12:47:36 --- mode: mauke set -o mauke
12:47:42 <Mortchek> elliott, you mean Ord instead of Bounded?
12:47:48 <dmwit> No, Bounded.
12:48:15 <Mortchek> Doesn't Bounded defeat the purpose of PosInf?
12:48:28 <ab9rf> not all ordered types have bounds
12:48:33 <ab9rf> and not all bounded types have orders
12:48:42 <ab9rf> (or at least have total orders)
12:48:56 <elliott> Mortchek: what would runPosInf PosInfy be if you only had Ord?
12:49:27 <dmwit> Yes, if you have Bounded, you might as well use the Min monoid, which must exist somewhere.
12:49:29 <Mortchek> I don't know, I was thinking based on the logic that you don't need Bounded a if you have PosInf a. I guess I was wrong.
12:50:10 <mauke> elliott: I use /xban from https://raw.github.com/mauke/irssi-scripts/master/tmpban.pl
12:50:12 <dmwit> You can make an instance of Bounded for PosInf (NegInf a). =)
12:50:25 <dmwit> (and likewise for NegInf (PosInf a))
12:50:51 <ab9rf> heh
12:51:04 <elliott> mauke: oh, nice. I'll take a closer look at that later, thanks
12:51:25 <gwern> https://gist.github.com/quchen/5280339 https://news.ycombinator.com/item?id=5469421 hm
12:54:16 <ab9rf> heh
12:56:53 <Kinnison> Nafai: Nice of you to say so
13:04:25 <oio> Get the uncommon elements of two list
13:05:03 <otters> heh, I just saw the xQuasar thing on reddit
13:05:07 <otters> i love you all
13:05:18 <quchen> :-)
13:05:34 <quchen> Tried repeating it earlier, but Elliott was too fast :-(
13:05:36 <oio> ["a","b","cc"]  ["d","b","a"] -> ["d","cc"]
13:05:51 <oio> Get the uncommon elements of two list?
13:06:00 <mauke> symmetric difference
13:06:15 <elliott> it's not good to feed trolls for extended amounts of time. especially when they are being offensive and massively lowering the standards of the channel.
13:06:22 <danharaj> ^
13:07:07 <elliott> IMO that gist is just a troll managing to clog up the channel for ten minutes that could have been spent on people who don't enter the channel deliberately trying to be kicked and saying things that are almost certainly going to upset some members of the channel.
13:08:12 <quchen> If the things he said upset someone I'm not sure the internet is for them
13:08:17 <ag90> In addition to that, I think that the conversation making to reddit means that at least one troll will come here and attempt to duplicate it.
13:09:17 <ag90> Which, I guess, is what the guy who was kicked a few minutes ago was trying to do.
13:09:47 <danharaj> Yes, anyone who doesn't like being denigrated should not use the most powerful means of human communication available to them. The Internet is only for the most calloused and socially privileged individuals.
13:09:54 <danharaj> No on is entitled to their dignity.
13:10:06 <otters> well, you might want to be careful, then
13:10:08 <elliott> quchen: I am glad #haskell has higher standards than the internet at large
13:10:09 <otters> because people can say anything on the internet
13:10:21 <elliott> ag90: yeah, that looked like a copycat to me
13:10:30 <danharaj> otters: And communities have the ability to police themselves and expel such elements from their midst without humoring them.
13:12:56 <dayom> hello
13:13:04 <dayom> can someone point me to a starting point w/ haskell
13:13:07 <Eduard_Munteanu> dayom: hi
13:13:15 <Eduard_Munteanu> @where lyah
13:13:15 <lambdabot> http://www.learnyouahaskell.com/
13:13:31 <dayom> great, thanks
13:13:32 <Eduard_Munteanu> dayom: you can use that ^^, but do you have something more specific in mind?
13:13:47 <dayom> I've read a bit of that site before
13:13:58 <dayom> more interested in getting into FP in general
13:14:09 <dayom> I'm an SE by profession
13:14:20 <dayom> mostly experience w/ PHP, Java, JS
13:14:21 <Eduard_Munteanu> Software engineer?
13:14:25 <dayom> yep
13:14:51 <dayom> more experience with object oriented paradigm
13:14:54 <quchen> Well, you need to learn the alphabet before you can get into writing in general too. The first steps will always be small, and your actual goal will be on the horizon.
13:14:59 <Eduard_Munteanu> Haskell is definitely going to be different.
13:15:37 <Sonarpulse> I am doing some IO. Put/Get is FiFo, Lists are LiFo, and while trying to get all that right I want to optomize the IO for constant memory
13:15:52 <Sonarpulse> I am making a tar-like utility (but different format)
13:16:18 <Sonarpulse> does foldl' make a strict list of thunks
13:16:25 <Sonarpulse> or strict list of actual values?
13:17:11 <quchen> foldl' has a strict accumulator.
13:17:28 <quchen> It doesn't build up a list, unless your combinator function explicitly does so.
13:17:37 <dayom> kinda curious about memory efficiency with safe functions
13:17:51 <dayom> you're passing around everything by value, right?
13:18:18 <quchen> dayom: I'm not sure. Since everything's mutable, passing by value or reference doesn't make a difference anyway.
13:18:27 <quchen> Internally I guess everything is by reference.
13:18:36 <Sonarpulse> oh duh, what am I saying
13:18:38 <quchen> Eh, immutable.
13:18:41 <dayom> yeah
13:18:44 <dayom> was gonna say
13:18:46 <quchen> Silly typo :-)
13:18:49 <dayom> isn't the point to be safe
13:19:10 <dayom> so if you pass a list of 10 billion ints
13:19:17 <Sonarpulse> I guess start at the begining, right now I have S.replicate <number> get
13:19:18 <dayom> and want to change the middle index
13:19:26 <dayom> you have to copy over the entire list?
13:19:32 <Sonarpulse>  sorry replicateM get
13:19:43 <quchen> dayom: You have to allocate the spine of the list up to that element again
13:20:09 <quchen> The values before the element you're updating won't change, so those elements can still point to the same values
13:20:11 <Sonarpulse> is replicate tail-recursive?
13:20:37 <quchen> The list after the element won't change so you can use a pointer to the rest of the list in both cases, i.e. share the rest
13:20:59 <Eduard_Munteanu> I hope not.
13:21:08 <NemesisD> anyone familiar with io-streams. i'm trying to figure out a strategy for lazily depaginating API results. something like getAllResults :: IO (InputStream Result). it'll get results N at a time from the API, performing no more requests than required from the consumer
13:21:39 <quchen> Replicate isn't tail recursive.
13:21:41 <Eduard_Munteanu> Sonarpulse: that's not quite necessary or desirable... but why are you asking?
13:21:59 <Sonarpulse> what i am writing is like tar
13:22:14 <Sonarpulse> the format works like this
13:22:27 <Eduard_Munteanu> foldr isn't tail-recursive, yet conceptually it's the "best(tm)" (FSVO best) way to fold.
13:22:42 <Sonarpulse> numfiles,total-size,[hash,offset,len],files
13:22:45 <Eduard_Munteanu> (assuming you have a choice)
13:23:18 <Sonarpulse> it was working last revision, but I did a big rewrite
13:23:36 <Sonarpulse> I am trying to decide do it "right" without tail recursion and foldr as you say
13:23:48 <Sonarpulse> or fix and optomize at the same time :D
13:24:17 <Sonarpulse> ok so replicate get and map put works
13:24:32 <Sonarpulse> because niether reverses the things gotten
13:24:33 <Eduard_Munteanu> That depends a lot on your folding operator.
13:24:39 <g3orge> hey guys, how can I see what a particular module exports in ghci?
13:24:51 <quchen> :browse?
13:25:01 <quchen> I think it lists all the exported things
13:25:01 <Sonarpulse> well even though put is more conceptualy like a fold, mapM put works fine
13:25:10 <Sonarpulse> like a foldr
13:25:57 <g3orge> thanks quchen
13:26:43 <Eduard_Munteanu> Sonarpulse: I'm not sure I understand what you're trying to do
13:26:56 <Sonarpulse> have you used Binary monad?
13:27:00 <quchen> g3orge: :h says ":browse[!] [[*]<mod>] -- display the names defined by module <mod> (!: more details; *: all top-level names)"
13:27:17 <Eduard_Munteanu> Yeah, I guess so.
13:27:33 <quchen> So I'm guessing no "*" means "only exported top-level names are shown". "!" I've never used.
13:27:41 <Sonarpulse> so it's FiFo
13:27:50 <Sonarpulse> if I have bytestring a,b,c,d
13:28:13 <Sonarpulse> i do replicateM 4 get
13:28:13 <Duffers> Hey, i'm wondering if anyone can give me insight into why my program won't compile, i'm gettign an error saying it can't match expected type with the actual type, but im not sure why.
13:28:17 <Sonarpulse> and get [a,b,c,d]
13:28:33 <mauke> Duffers: what's the complete error message?
13:28:39 <elliott> Duffers: can you hpaste your program and the error?
13:28:40 <elliott> @hpaste
13:28:40 <lambdabot> Haskell pastebin: http://hpaste.org/
13:28:42 <Sonarpulse> then mapM_ put and get back a,b,c,d bytestring in state
13:29:06 <Duffers> the program is here: pastebin.com/uvTR7wf7
13:29:06 <Sonarpulse> (acutall return type is Put ())
13:29:20 <mauke> Duffers: hahaha. no.
13:29:22 * elliott invokes the power of mauke's bot: http://pastebin.com/uvTR7wf7
13:29:25 <mauke> The paste uvTR7wf7 has been copied to http://hpaste.org/84931
13:29:26 <Duffers> ?
13:29:47 <mauke> Duffers: I'm not going to visit pastebin.com, and you didn't even make it clickable by including the "http://"
13:29:48 <Eduard_Munteanu> Heh.
13:29:49 <elliott> mauke: can you hpaste the error message too?
13:29:55 <elliott> .
13:29:57 <elliott> er.
13:29:59 <elliott> Duffers. not mauke.
13:30:06 <quchen> What's so bad about Pasebin?
13:30:12 <simpson> quchen: Ads and routing.
13:30:14 <Eduard_Munteanu> Sonarpulse: ok...
13:30:19 <elliott> mauke: you should tweak your script to handle the missing http:// :P
13:30:24 <quchen> And what's *so* bad about pastebin for that reaction? :s
13:30:33 <Sonarpulse> none of that is tail recursive though
13:30:40 <mauke> quchen: ugly, ads, may modify text you paste
13:30:50 <Duffers> Sorry i didnt realise pastebin was not liked
13:30:56 <shachaf> And no hlint.
13:31:08 <mauke> shachaf: :-)
13:31:31 <Eduard_Munteanu> Sonarpulse: you don't really care about that
13:31:34 <Sonarpulse> actually not! mapM_ IS tail recursive
13:31:37 <hpaste> Duffers pasted “Duffers” at http://hpaste.org/84932
13:31:46 <Sonarpulse> because I've tested it
13:31:47 <elliott> if you do {-# LANGUAGE CPP #-} and put your whole program in #ifndef HLINT, can you avoid hpaste's hlint warnings?
13:31:58 <Eduard_Munteanu> Sonarpulse: you tested it how?
13:31:59 <Duffers> Theres it on hpaste with the error message i receive at the bottom
13:32:17 <shachaf> @src mapM_
13:32:17 <lambdabot> mapM_ f as = sequence_ (map f as)
13:32:26 <shachaf> @src sequence_
13:32:27 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
13:32:27 <elliott> Duffers: so, (results x) has the type [(Int,Party)]
13:32:27 <Sonarpulse> you know how you can do reverse with foldL?
13:32:32 <elliott> so (reverse (results x)) has the type [(Int,Party)]
13:32:37 <Sonarpulse> but map has to be foldr?
13:32:38 <elliott> so head (reverse (results x)) has the type (Int,Party)
13:32:42 <quchen> Duffers: The "errors" at the bottoms are HLint errors. "error" basically means "*do* write this differently, it's weird code"; it's not a program error per se.
13:32:45 <elliott> and then you do map snd on it
13:32:48 <shachaf> That's not exactly tail recursive.
13:32:53 <elliott> but (map snd) takes a list
13:32:56 <elliott> and (Int,Party) isn't a list
13:33:05 <elliott> perhaps you just want "snd"?
13:33:24 <quchen> Duffers: Click the messages and it'll tell you what went wrong (i.e. weird) and what it suggests as an improvement
13:33:25 <Sonarpulse> sorry, well not exactly tail recursive
13:33:26 <mauke> quchen: ?
13:33:29 <Duffers> Thank you!
13:33:30 <Sonarpulse> mapM is weird
13:33:34 <elliott> there are no hlint errors on that paste
13:33:36 <Duffers> it was just snd i needed
13:33:39 <skyflash> Arg.  Coming from a functional language that generalises tuples (e.g. fst can get the first element of any tuple type), I find Haskell ugly... unless... is there a GHC extension that can do some magic?
13:33:48 <Eduard_Munteanu> Sonarpulse: you don't need to worry about mapM_
13:33:50 <elliott> Duffers: :)
13:33:58 <mauke> skyflash: why are you using tuples with more than 2 elements?
13:34:02 <Eduard_Munteanu> Or tail-recursivity, as much as in C.
13:34:08 <Sonarpulse> ok now I am getting confused
13:34:19 <skyflash> mauke: convenience of course ;-)
13:34:29 <mauke> skyflash: did you mean: inconvenience
13:34:38 <Duffers> Haskell is the first programming language im learning and i kind of suck at it so far haha
13:34:38 <Sonarpulse> with normal m you don't care what order the mapping is doen with as long as the end result is the same
13:34:59 <parcs> > ((1,2,3) ^. _1) + ((1,2,3,4) ^. _1)
13:35:01 <lambdabot>   2
13:35:02 <Sonarpulse> * pure map
13:35:20 <Sonarpulse> but with mapM_ you most certainly do!
13:35:23 <elliott> Duffers: eh, your code is pretty good for a beginner
13:35:26 <quchen> mauke: (1,(2,(3,4))) is hardly convenient.
13:35:33 <skyflash> ...but also if you use 'record' syntax (named data fields), you get your namespace polluted with extractor function.  Ho hum... having an irritated few minutes ;-)
13:35:36 <byorgey> Duffers: everyone sucks at the first programming language they learn, at first.
13:35:40 <quchen> And even less so is "fst . snd . snd"
13:35:41 <Sonarpulse> now a foldr map would evalutate which element of the list first?
13:35:48 <elliott> Duffers: you're probably at an advantage learning it as your first language, since you don't have the imperative baggage that learning most other languages would have given you
13:35:55 <Sonarpulse> (map implemented with foldr that is)
13:36:01 <Eduard_Munteanu> Sonarpulse: evaluation doesn't matter
13:36:27 <Sonarpulse> mapM_ ! side effects!
13:37:14 <quchen> mapM_ is as side-effect free as the rest of Haskell.
13:37:22 <qzr> Is there a way to sneak in a debug trace that shows a variables inferred type?
13:37:26 <Eduard_Munteanu> Sonarpulse: look at sequence's definition
13:37:38 <Sonarpulse> yes that will help
13:37:39 <Eduard_Munteanu> If you expand that you get something like...
13:37:47 <qzr> if I'd like to know the inferred type of a variable in the middle of some code?
13:37:53 <Eduard_Munteanu> foo >> (bar >> (baz ...   ))
13:38:25 <quchen> qzr: Dirty way: add "data Hole = Hole" in your source file, and replace whatever you want to investigate with "Hole" and compile. The error will tell you "found Hole, expected XY".
13:38:35 <Eduard_Munteanu> (>>) imposes the ordering
13:39:20 <qzr> quchen: Thanks!
13:39:48 <quchen> qzr: Maybe there's a cleaner way, but this one will do the trick
13:40:39 <quchen> Particle physics approach. Smash it and it'll tell you what's inside ;-)
13:41:06 <skyflash> mauke: also libraries often still use tuples (like the return from Data.Time.toGregorian)
13:41:24 <mauke> skyflash: hmm. pattern matching?
13:41:41 <skyflash> mauke: of course.
13:43:53 <Sonarpulse> ok
13:44:11 <Sonarpulse> out of curiosity, you could write a lousy foldr that strictly recurred to the end of the list
13:44:34 <Guest54517> can someone point in in the direction to understanding th different between mapM and mapM_
13:44:54 <copumpkin> mapM_ might be called foreach in another language
13:44:56 <Eduard_Munteanu> Guest54517: mapM_ simply ignores the result, it just executes the actions.
13:45:02 <copumpkin> mapM might be called map in another language
13:45:05 <Sonarpulse> or sorry map in scheme let's say
13:45:10 <bh> I'm running into a build issue with Date.Time.LocalTime from the package`time`. Here are my build-deps and the error I'm getting: https://gist.github.com/bhickey/5281926
13:45:23 <Sonarpulse> that applied the maping function either left to right or right to left
13:45:28 <quchen> Guest54517: mapM_ = "mapM_ >> return ()". Throw the end value away, that's it.
13:45:42 <quchen> Guest54517: mapM_ = "mapM >> return ()". Throw the end value away, that's it.
13:45:44 <quchen> This way, pardon.
13:45:49 <copumpkin> it's more efficient, though
13:45:52 <copumpkin> but yeah
13:46:01 <_g> okay; that makes sense
13:46:08 <nooodl_> copumpkin: wouldn't other languages' "map" correspond to haskell's "map", instead of mapM?
13:46:25 <copumpkin> nooodl_: most other languages allow unrestricted effects
13:46:42 <Sonarpulse> maybe if you CPSed it?
13:46:50 <nooodl_> oh, gotcha
13:47:03 <copumpkin> so if you have scala
13:47:07 <copumpkin> .foreach = mapM_, and .map = mapM
13:47:16 <copumpkin> roughly
13:47:32 <quchen> Eh? I wouldn't say that.
13:48:04 <quchen> For me it helped understanding sequence/sequence_ first, and then thinking of mapM as sequence.map
13:48:42 <hpaste> quchen pasted “sequence/mapM written in a readable way” at http://hpaste.org/84933
13:49:07 <Sonarpulse> OK, next question, does sequence actually evaluate each operation with seq or something? or just arrange the IO operation left to right
13:49:24 <copumpkin> no seq involved
13:49:24 <ion> sequence doesn’t use seq.
13:49:25 <quchen> Oh, typo in line 12 above. It should be "mapM f = sequence . map f".
13:49:32 <copumpkin> quchen: why wouldn't you say that?
13:49:43 <_g> i think it makes sense.  a monad is essentially a computation contained in a context.  so if i mapM over a list of monads, I get, in return a list of monads that hve been acted upon.  if i use mapM_ then those monads get acted upon, but I get nothing in return
13:49:57 <elliott> Sonarpulse: sequence has nothing to do with evaluation
13:50:06 <Sonarpulse> oh good
13:50:06 <elliott> and evaluating an IO action doesn't execute it
13:50:12 <quchen> copumpkin: Oh, sorry, I didn't see the "if you have Scala" line.
13:50:22 <ion> g: There’s no such thing as a list of monads in Haskell.
13:50:30 <_g> ion: i knew there must be a flaw
13:50:36 <quchen> copumpkin: I thought you talked about foreachs as in imperative standard languages.
13:50:39 <Sonarpulse> on fortunately, the description says "Evaluate each action in the sequence from left to right, and collect the results."
13:51:06 <_g> sorry a list inide a monad, i guess would be correct
13:51:09 <elliott> ion: you can do '[IO, Maybe] nowadays
13:51:13 <elliott> _g: "a list of monadic actions"
13:51:28 <ion> g: Some examples of things that are monads in Haskell: IO, Maybe, [], Parser, STM. These are not monads: IO String, [Integer], "hello", Just 42
13:51:44 <ion> elliott: Neat. What’s the name of the extension?
13:51:57 <_g> ion: okay, thanks.  that does add some clarity
13:52:05 <Sonarpulse> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#g:4
13:52:07 <elliott> ion: DataKinds
13:52:11 <ion> elliott: thanks
13:52:18 <Sonarpulse> ion: no you can't have a list of typeclasses :)
13:52:24 <Sonarpulse> you are right
13:52:58 <qzr> ion: well isn't technically "Maybe" etc. no monad since it's only the type constructor part of a monad
13:53:42 <quchen> Maybe is the monad.
13:53:46 <quchen> Maybe Int is a type.
13:54:05 <qzr> Maybe its bind and its return form the Monad
13:54:06 <elliott> qzr: Maybe is a Monad, i.e. there is an instance Monad Maybe
13:54:18 <elliott> from a category theory perspective you'd say it differently
13:54:25 <elliott> but this is haskell :p
13:54:33 <elliott> (hence the difference between "Monad" and "monad")
13:54:54 <qzr> elliott: ok fair enough :)
13:55:07 <Taneb> In category theory, are all monads functors?
13:55:16 <Sonarpulse> yes
13:55:32 <elliott> Taneb: a monad is an endofunctor with blah blah blah
13:55:38 <cmccann> ion: I disagree, you can have a list of monads
13:55:46 <quchen> Taneb: for all monads, "instance Functor Foo where fmap = liftM" is a valid functor instance.
13:55:47 <hpaste> “C. McCann” pasted “list of monads” at http://hpaste.org/84935
13:55:59 <Taneb> quchen, I said category theory, not Haskell :P
13:56:07 <ion> cmccann: Yeah, elliott already pointed out DataKinds.
13:56:13 <elliott> cmccann: that's a list of Monad!
13:56:17 <cmccann> oh, I missed that
13:56:18 <cmccann> heh
13:56:20 <quchen> In category theory too, yes.
13:56:24 <elliott> cmccann: by the way your prompt is awful.
13:56:34 <cmccann> actually my GHCi prompt is awesome.
13:56:37 <ion> cmccann: Yes. Your prompt is awful.
13:56:41 <quchen> In Haskell monads are functors by coincidence, in category theory it's by design.
13:56:41 <elliott> cmccann: you should :set prompt "{--} ", like sensible people do.
13:56:59 <elliott> quchen: I have no idea what you mean by that
13:57:08 <cmccann> anyway I've had that GHCi prompt for like years or something now
13:57:29 <elliott> cmccann: with {--} you can copy previous lines and paste them into GHCi and they still work!
13:57:39 <Duffers> Real World Haskell or Learn You a haskell, which should i read as a beginner?
13:57:44 <quchen> LYAH
13:57:49 <ion> duffers: Read the latter first.
13:58:04 <cmccann> pf, copy and paste
13:58:14 <quchen> Is {--} special in some way?
13:58:15 <Duffers> k cheers, is the online version the same as a the physical?
13:58:20 <elliott> {--} is a comment.
13:58:21 <qzr> RWH is ok until he starts with Monads, then it gets bad imo
13:58:22 <cmccann> quchen: it's an empty comment
13:58:23 <ion> > {--} 42
13:58:24 <lambdabot>   42
13:58:37 <Sonarpulse> is there a away to make ghci load the prerequisites of modules that fail to compile?
13:58:39 <cmccann> having a blank prompt would also work I assume
13:58:50 <Sonarpulse> I like to coppy my broken code in and mess with it
13:59:03 <quchen> cmccann: And what's the benefit of that as a command line beginning?
13:59:09 <otters> :t {--}
13:59:10 <lambdabot> <no location info>: not an expression: `'
13:59:16 <nooodl_> :set prompt "    "
13:59:28 <Sonarpulse> but if the previously compiled file does not have the same imports that won't work
13:59:30 <cmccann> quchen: see what elliott said
13:59:53 <ion> :set prompt "H̡́̄ͪͣͦ̽ͤ̊̂͊ͮ̿̅ͭ̓҉̥͓̖̮͇̞̭̜̕͠ͅÄͭͥ̿̾͒̌̾̑ͯ͐͝͡҉̳̮̞̳̖̜̦̫͖͕͎͔̞͉̙͖̜Ş̪͍̺̝͋̈͆̀͘͡͞K̷̨̥͍̻̺̮͎̮̻̱̪̰͓̮̻̙̬̽̔͗̔̆́́͢E̸̵̷͓͍̖͉͓͔̍̀ͣ̅̍͆ͦ͞͡L̇̊̅҉̢̺̳̩͍͚͉͔̻ͅͅL̵̨̗̻̞̼̠͎͐̊͌͌͋ͥ̓͘ͅ
13:59:55 <ion> ̴̡̢̳̻̦̳̠̠̣̦̩̭̬͇̫̫̻͕̰̙̼ͣ͋ͯ͊ͬͫ̀͊ͭ̐͋ͤͧH̨̠͚͈̤̲̦͓͇̞̬̲͍͔̜͔ͨͪ͗̓̓̂ͨ̅́͘Ė͐ͫ̏͋͌ͬ͌ͭ͛ͯ̑ͥ҉̨̖̭͇̩͍̳̹̭
13:59:57 <ion> ̸̵̵ͫ̊͗ͤ̈̔̿ͧͭ̋͗̓̀ͭ͑͛͊͊̚͠͏͎̭̬̝̭̹͕̫͖̙Ç̧̘̬̭̮̏̉ͥͫͤ͗̂͒̒̂̿ͬ̊̌̑̽̚O̵̝̪̗͖̖̠̙̠̭͈̳̘̺̺̫̭̹̾̓̊ͨ̂͗̉ͥ̚M̨̡̪̬̻̱̟͎͉̯̤̜̰̜̩͓ͪͮ̋̿ͤͫ͂̏͐ͫ͗ͬ̽̏ͩ́͘E̶̶̻̗̩̪͙̠͕̝̠̎ͭ̈́͗͂̆̑͌͂ͭ̕͡S̾̄̈́ͩ̑ͭͨ̓ͮͨ̅̋̆̾̐̆̈́̈́̃͏̪̝̺̻̮͇̥͘"
13:59:59 <elliott> um.
14:00:05 <cmccann> ion: good idea
14:00:07 <elliott> you got dirt in my irssi status bar!
14:00:09 <ion> whoops, that wasn’t meant to go to multiple lines.
14:00:09 <quchen> cmccann: Oh, so you don't have to pay attention when to stop the markings. I see.
14:00:23 <elliott> cmccann: I stole this idea from Plan 9's rc, which uses ; as a prompt
14:00:29 <elliott> J does it too, it uses three spaces or something
14:00:32 <Sonarpulse> I am supprised emacs/erc can render that
14:00:44 <qzr> Sonarpulse: I somewhere saw "$ cabal-dev ghci" for experimenting with code. Not sure if it does what you want though
14:00:50 <cmccann> elliott: it's a cute idea but entirely too practical for my tastes
14:00:51 <pharaun> ion: zalog?
14:00:59 <Sonarpulse> interesting
14:01:13 <elliott> cmccann: oh I never use it.
14:01:22 <elliott> cmccann: I just figured I should have my special own prompt.
14:01:43 <elliott> I mean I use it. but I don't use the copying thing
14:01:45 <oio> Why Data.Vector isnt default?
14:01:59 <cmccann> elliott: hm ok that's better I guess
14:02:15 <quchen> oio: Default?
14:02:34 <oio> uncluded on the platform
14:02:42 <quchen> It is included in the platform
14:02:58 <quchen> http://www.haskell.org/platform/changelog.html
14:03:00 <Taneb> oio, [] works better for cons-heavy code and infinite lists, and it is in the platform
14:04:47 <oio>     Could not find module `Data.Vector'     Perhaps you meant Data.Functor (from base)
14:05:04 <oio> >:m +Data.Vector
14:05:07 <Sonarpulse> does foldrWithKey (data.map) fold the keys in any particular order?
14:05:18 <ion> http://heh.fi/tmp/ghci-prompt
14:05:21 <Taneb> cabal install vector --enable-documentation --haddock-hyperlink-source
14:05:23 <Taneb> oio, ^
14:05:25 <elliott> oio: if you installed the haskell platform you'd have vector
14:05:31 <jmcarthur> Sonarpulse: i think it's unspecified, but it probably does it in ascending order, in practice
14:06:01 <Sonarpulse> based on my testing cod
14:06:16 <Sonarpulse> it actaully seems to be based on the the order in which things were inserted
14:06:19 <jmcarthur> Sonarpulse: if you want it to be ascending your would probably use toAscList
14:06:25 <Sonarpulse> I don
14:06:26 <jmcarthur> *you would
14:06:33 <jmcarthur> wha-?
14:06:35 <Sonarpulse> I don't actually care too mcuh
14:06:37 <jmcarthur> that's a weird order
14:06:38 <oio> *Main> :m +Data.Vector  <no location info>:     Could not find module `Data.Vector'     Perhaps you meant Data.Functor (from base)
14:06:48 <Sonarpulse> but yes, it is a very werid order
14:06:51 <jmcarthur> i am surprised if that is the actual order
14:06:55 <jmcarthur> code?
14:07:01 <Sonarpulse> sure
14:07:15 <oio> Taneb: but why it says it is when it isnt
14:07:18 <Sonarpulse> https://github.com/Ericson2314/CnC-Red-Alert
14:07:22 <Sonarpulse> I need to commit one thing
14:07:30 <Sonarpulse> so give me about 30 seconds
14:07:36 <Sonarpulse> sorry not a very clean test
14:07:40 <Sonarpulse> but it's my exampple
14:07:47 <jmcarthur> Sonarpulse: it specifies the order
14:07:51 <jmcarthur> Sonarpulse: foldrWithKey f z == foldr (uncurry f) z . toAscList
14:08:24 <Sonarpulse> ok
14:08:34 <Taneb> oio, what do you mean?
14:08:40 <Sonarpulse> ok
14:09:13 <Sonarpulse> i guess the list i converted was in order to begin with
14:09:13 <oio> Taneb: in change log, but i cant imported it has to be installed from cabal
14:09:16 <Sonarpulse> hmm interesting
14:09:33 <Taneb> oio, because you haven't actually installed the Platform, most likely
14:09:42 <Taneb> It sounds like you've just got the bare minimum
14:10:24 <oio> i did 2012 4
14:11:40 <Taneb> Can you paste the output of "ghc-pkg list" somewhere for me?
14:13:57 <hpaste> oio pasted “ghc-pkg list” at http://hpaste.org/84936
14:14:23 <Taneb> Huh
14:14:29 <Taneb> You do have vector installed
14:14:56 <Taneb> Try again in GHCi for me?
14:15:37 <oio> Prelude> :m  +Data.Vector  <no location info>:     Could not find module `Data.Vector'     Perhaps you meant Data.Functor (from base
14:15:54 <elliott> there may be multiple ghcs at play
14:16:04 <Taneb> "ghci --version"?
14:16:12 <jmcarthur> that would be weird for there to be one ghc-pkg but a different ghci
14:17:01 <lightquake> what's a good library for generating animated gifs?
14:17:09 <lightquake> JuicyPixels appears to only be able to read them
14:17:16 <oio> The Glorious Glasgow Haskell Compilation System, version 7.4.2
14:17:19 <ludamad> why might I be getting  hPutBuf: resource vanished (Broken pipe) when a client disconnects ?
14:17:36 <Taneb> Most odd indeed
14:17:36 <ludamad> (or rather, how can I correctly handle it)
14:17:44 <mauke> catch the exception
14:17:50 <thirsteh> is there anything like updateLookWithKey or updateLookup for HashMap?
14:18:02 <ludamad> hmm. ok
14:18:19 <ludamad> mauke: this is an IOException, right ?
14:18:29 <mauke> yes
14:19:20 <Sonarpulse> how to you get ghci to do a stack trace from an exception?
14:19:20 <shachaf> lightquake: You can always use Imagemagick.
14:20:16 <lightquake> true
14:24:11 <dmwit> Sonarpulse: The stack will surprise you. But you can use the ghci debugger to get some information. Read about it in the fine manual.
14:24:36 <dmwit> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
14:25:00 <Sonarpulse> Will do, how about function that it failed in at least? yeah i know laziness complicates things
14:25:09 <Sonarpulse> but some sort of context would still help
14:25:16 <dmwit> You can set breakpoints on particular functions.
14:27:12 <Sonarpulse> i guess context could either by where the failing thunk was generated
14:27:20 <Sonarpulse> or the line that triggered evaluation
14:27:32 <Sonarpulse> no way to get at those directly? (reading debugger man now)
14:27:58 <dmwit> oio: I'm a bit late to the party, but does ghc-pkg check have any problems to report? (Was this already asked?)
14:28:46 <oio> <hpaste> oio pasted “ghc-pkg list” at http://hpaste.org/84936
14:29:03 <dmwit> I want check, not list.
14:32:33 <hpaste> oio pasted “check” at http://hpaste.org/84937
14:33:13 <dmwit> Those seem fairly benign.
14:35:15 <oio> mac os x
14:35:17 <dmwit> oio: Okay. How are you starting ghci?
14:35:31 <dmwit> Also, do you have any funny stuff in a .ghci file either at $HOME or $PWD?
14:36:38 <oio> dont think so..
14:36:57 <oio> Loading package ghc-prim ... linking ... done. Loading package integer-gmp ... linking ... done. Loading package base ... linking ... done.
14:42:21 <oio> ?..
14:42:21 <lambdabot> Not enough arguments to @.
14:44:03 <dmwit> Just to make sure there's no funny stuff (since I'm running out of unfunny ideas), how are you starting ghci?
14:44:24 <dmwit> I know it sounds like a stupid question. But you're just typing "ghci", right?
14:44:29 <dmwit> If so, what does "which ghci" say?
14:49:14 <oio> yes
14:49:50 <Sonarpulse> what testing framework do you all recommend?
14:50:28 <sm> test-framework is good. HTF may be good.
14:51:08 <Sonarpulse> HTF is wrapper around test.framework and quick=check?
14:51:13 <sm> yes
14:51:41 <sm> it has nice features but seems a bit boilerplatey/intrusive, but I haven't used it for long
14:52:15 <sm> hspec is another one
14:52:43 <Sonarpulse> if it makes a difference I'd like to use either hard-coded values or something read from a file system an "input" for a bunch of unit tests
14:53:24 <Sonarpulse> also most of my functions consist of f -- f-inverted pairs
14:55:30 <slack1256> is better having a big monad-transformer stack and use it in the whole project or use diferent subset of the monad-stack and lift them from the Main-stack?
14:55:41 <slack1256> or does my question not make any sense?
14:57:52 <oio> Karissa Shannon
14:58:16 <slack1256> the two approaches I've seen them on the big monad-stack used everywhere with XMonad and thei X monad
14:58:48 <slack1256> the second one, subset of the main monad-stack is in ghc, also they have predefined boundaries.
14:59:20 <Sonarpulse> ok I think i am goign with quick-check
14:59:38 <Sonarpulse> if I eventually want to get my code up on hackage
15:00:00 <Sonarpulse> what best practices should I be aware of?
15:01:55 <quchen> Write good docs.
15:02:05 <quchen> List ends here.
15:02:19 <Sonarpulse> I mean with regards to testing?
15:02:32 <Sonarpulse> and quick-check
15:03:28 <emanuele1> hi guys, anyone skilled in java here?
15:03:38 <elliott> no, this is #haskell
15:03:41 <elliott> perhaps try #java? :P
15:04:06 <elliott> though if your question is "how do I do this Java thing in Haskell?" or such, then just ask it.
15:04:34 <Sonarpulse> fixed: skilled inspite of java
15:06:57 <emanuele1> i'm looking for a partner for a software project... so I'm asking around... anyone interested? I'll give you the details
15:07:26 <quchen> Does it involve Haskell?
15:08:11 <emanuele1> no it doesn't... but I thought someone who knows haskell might know java as well... sorry
15:08:38 <Sonarpulse> well then you are in the wrong channel
15:08:50 <Sonarpulse> but maybe it should involve haskell :)
15:08:55 <emanuele1> lol
15:09:15 <emanuele1> that would be a real challenge
15:10:51 <slack1256> emanuele1: but why somebody that knows haskell should know java?, I could see it if they were the same paradigm, but :S
15:12:03 <emanuele1> well programmers usually know several languages... also haskhell is something you have fun with... not much suitable for work I guess
15:12:20 <emanuele1> sorry I've never done anything in haskhell
15:12:28 <quchen> I'd say the same thing about Java. Except for the fun part.
15:12:39 <quchen> Anyway, this is OT, there's no Java developer here.
15:13:00 <emanuele1> ok sorry
15:13:09 <slack1256> #java
15:13:20 <elliott> I doubt that request is on-topic for #java either
15:14:19 <slack1256> #startups?
15:14:39 <ciaranm> #businessguywantsprogrammertomakefacebookclone
15:14:41 <Sonarpulse> is it an open source project?
15:14:42 <emanuele1> thx I'll check that out
15:14:50 <emanuele1> no it is not
15:14:53 <cmccann> ew, people still use java? crazy.
15:15:06 <elliott> emanuele1: you might want to try another irc network or something
15:15:13 <slack1256> well not java per sé, but the JVM is cool
15:15:19 <Sonarpulse> scala
15:15:23 <emanuele1> what do u suggest for a business application?
15:15:30 <shachaf> cmccann: How's that book going?
15:15:34 <logicbuffer> clojure*
15:15:35 <emanuele1> I'm planning to move to it someday
15:15:47 <ludamad> +1 on JVM's being cool
15:16:01 <Sonarpulse> JVM: type erasure and no TCO tough
15:16:02 <ludamad> language is ok just sooo borring
15:16:23 <shachaf> This all seems pretty off-topic for this channel.
15:16:26 <emanuele1> yeah... a lot of boilerplate
15:16:29 <slack1256> yes
15:16:32 <slack1256> sorry shachaf
15:16:32 <cmccann> the JVM would be better if it stopped worrying about java and focused on supporting better languages :O
15:16:47 <ludamad> cmccann: Well its supporting javascript now :-)
15:16:48 <cmccann> and a JVM haskell would still be nice.
15:16:51 <Sonarpulse> if scala replaced java
15:16:57 <Sonarpulse> and clojure target scala
15:16:58 <logicbuffer> JHaskell would be neat
15:16:59 <ludamad> project nashorn
15:17:00 <tomoj> cmccann: frege?
15:17:02 <Sonarpulse> that would be nice
15:17:10 <companion_cube> tail-call and more lightweight objects would be nice
15:17:11 <slack1256> there is various haskell-y languages for JVM
15:17:13 <cmccann> tomoj: sounds just close enough that the differences would aggravate me
15:17:17 <slack1256> *there are
15:17:43 <cmccann> I don't deal well with things that are 95% the same as something I already know well because that 5% drives me crazy :[
15:17:53 <Sonarpulse> I like the idea of common run times for multiple languages
15:18:08 <cmccann> shachaf: same as last time you asked btw
15:18:17 <shachaf> #haskell is 95% #java but I deal with it for the sake of the other 5%
15:18:25 <emanuele1> thank you for your help guys
15:18:40 <emanuele1> bye
15:19:33 <cmccann> shachaf: on the other hand I'm making progress on a simple drawing application
15:20:31 <cmccann> though it would be nice if the GTK bindings included the stuff I need :[
15:22:17 <ab9rf> the JVM is going to have some rough times in the near future, i think
15:22:25 <cmccann> why?
15:22:39 <ab9rf> because oracle is run by larry ellison :)
15:23:35 <dayom> does haskell do cpu optimization under the covers?
15:23:37 <dayom> for ex...
15:23:46 <dayom> if I write some fn
15:23:59 <dayom> will it take advantage of all cores on the processor if it's written as a parallel fn
15:24:05 <cmccann> yeah but where would oracle be without legions of enterprisey J2EE development
15:24:49 <Sonarpulse> dayom: it's more possible than most langugs due to purity
15:24:58 <Sonarpulse> look up paralell map
15:25:09 <ab9rf> haskell's purity makes it easier to parallelize
15:25:13 <cmccann> it won't do it automatically afaik
15:25:16 <jmcarthur> dayom: what do you mean by "cpu optimization under the covers"?
15:25:25 <dayom> see the statement below that
15:25:26 <Sonarpulse> I thoght there was some experiemental thing
15:25:35 <Sonarpulse> maybe
15:25:36 <dayom> if I write some concurrent procedure
15:25:42 <dayom> will it take advantage of n cores on the cpu
15:25:43 <cmccann> I'm sure there's experimental stuff that tries to
15:25:50 <ab9rf> although i don't think anyone has automated it to any significant degree, and certainly not assignment of computation to GPU cores or anything
15:25:53 <cmccann> dayom: it will if you tell it to
15:25:54 <jmcarthur> Sonarpulse: you might be thinking of nested data parallelism, but that still requires you to use "parallel arrays"
15:26:13 <jmcarthur> Sonarpulse: that said, it does do some amazing transformations
15:26:16 <dayom> my main concern is around hardcoding what n is
15:26:22 <dayom> if my cpu has 4 cores
15:26:25 <jmcarthur> dayom: no, n is not hardcoded typically
15:26:31 <dayom> ok great
15:26:34 <jmcarthur> dayom: it's typically given as a runtime flag
15:26:55 <dayom> i see
15:26:55 <dayom> thanks
15:27:04 <jmcarthur> dayom: ./MyProgram +RTS -N<numcores>   (or just +RTS -N will use however many cores your machine has automatically)
15:27:08 <Sonarpulse> maybe
15:27:28 <quchen> dayom: You can also increase the number of capabilities (the N runtime flag) during runtime as ofa couple of versions ago.
15:27:41 <jmcarthur> dayom: but you still have to write your program in to take advantage of it, which requires less effort than most languages but more effort than plain sequential code
15:27:42 <ab9rf> but you still have to annotate your code with parallelization hints (par, pseq)
15:27:51 <quchen> dayom: see http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-Conc-Sync.html#v:numCapabilities
15:28:01 <jmcarthur> well, par and pseq aren't the only ways, but the gist applies
15:29:00 <quchen> Oh, can you decrease N with setNumCapabilities now? I didn't know that changed
15:30:38 <dayom> I thought one of the main advantages was that you no longer need to write code for a specific chip
15:30:58 <dayom> I guess you can do it with the runtime flag like mentioned
15:31:05 <dayom> always thought it would just detect automatically
15:31:52 <quchen> dayom: Concurrency and parallelism are always available, regardless of your N setting. However, if multiple processes are available, the runtime will map things you declared as parallel onto different ones, that's where the speedup comes from.
15:32:08 <quchen> Parallelism isn't automatic, but fairly easy to accomplish.
15:32:17 <cmccann> it seems he left.
15:32:30 <quchen> Oh. The downside of hiding join/part
15:32:37 <ab9rf> quchen: yeah, i have that too
15:32:48 <quchen> Thanks for telling me before I finished my novel ;-)
15:32:54 <ab9rf> i've talked at people's backsides more than once as a result
15:32:59 <cmccann> that's why I mentioned it :]
15:33:10 <cmccann> I know quite a few people do that in here
15:33:18 <cmccann> given the size of the channel I can see why you'd want to
15:33:21 <quchen> Is there some way to tell irssi to monitor only recent talkers like this?
15:33:24 <Sonarpulse> wait, do you not write do quickCheck tests, only use them in the repl?
15:33:49 <quchen> We write QuickCheck tests outside the REPL too.
15:34:00 <pharaun> this channel is too big for not hiding join/parts :\
15:34:08 <quchen> Typically I use the REPL to check my QuickCheck code, and then write a testing module that does 10k tests per issue.
15:34:56 <cmccann> pharaun: I've used IRC for so long I've gotten used to tuning them out
15:34:56 <Sonarpulse> quick check seems to be lots of IO ()
15:35:10 <cmccann> netsplits are HORRIFYING in here though
15:35:11 <Sonarpulse> do you just write some IO () functions with it and call them as you please>
15:35:14 <cmccann> like holy crap
15:35:25 <thoughtpolice> yeah netsplits here get pretty bad
15:35:27 <Sonarpulse> also if you put them in another module, you have to export mroe
15:35:46 <pharaun> cmccann: :) i can see that, *shrugs*
15:36:16 <quchen> Netsplits? I guess I'm hiding more than I thought
15:36:25 <quchen> Or is it just a massive amount of joins
15:36:47 <cmccann> quchen: massive amount of joins or parts, yes
15:36:50 <thoughtpolice> it's a massive amount of parts (during the split) and joins when they come back
15:36:57 <cmccann> several screens full depending on which servers
15:37:13 <thoughtpolice> you may see a little 'Netsplit' notification, but if you ignore parts/joins you otherwise won't notice
15:37:20 <thoughtpolice> (irssi shows this, at least)
15:37:24 <cmccann> at least once I was on a server that ended up isolated and saw 90% of the channel "part"
15:37:58 <thoughtpolice> once i got split on a small server here, maybe 25-30 people? long time ago before i had a VPS
15:38:55 <hpc> can someone confirm for me that ^C always throws UserInterrupt to the main thread?
15:39:07 <hpc> i am too tired to search through docs
15:39:22 <quchen> hpc: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception-Base.html#v:UserInterrupt
15:39:39 <quchen> Maybe try the docs on UserInterrupt ;-)
15:39:42 <hpc> lol i was just looking at that
15:39:55 <hpc> i am waaaay too tired to search through docs ;)
15:40:02 <quchen> Hoogle?
15:40:14 <quchen> I'm way too tired as well, that's why I'm using a search engine :P
15:40:21 <hpc> i mean, i literally just had that open
15:40:30 <quchen> Anyway, Ctrl+C -> UserInterrupe.
15:40:39 <hpc> and my eyes totally glossed over where it says to the main thread by default
15:41:00 <quchen> Happy to be your private Hoogle
15:41:35 <hpc> your magic has made me literate again
15:41:53 <dayom> are there any good arguments for why haskell isn't used more compared to python, ruby, etc?
15:42:15 <dayom> from what I've seen so far it's amazing
15:42:19 <dayom> truly elegant
15:42:22 <cmccann> because fewer people know it
15:42:58 <quchen> I've read a few articles about Lisp concerning the issue, let me see whether I can find them again.
15:43:12 <cmccann> there are rarely "good arguments" for choice of programming language. it's not like the whole industry gets together and has a formal debate before agreeing on what the most popular language should be.
15:43:13 <hpc> there's a SO post describing that particular catch-22 in great detail
15:43:15 <quchen> (Spoiler: it boils down to inertia)
15:43:31 <quchen> hpc: Got the URL?
15:43:32 <pharaun> catch-22 is a pain for about any new or less known language
15:43:34 <hpc> nobody uses it because it's an obscure language because nobody uses it
15:44:00 <pharaun> <- is sneaking it into his workplace, one app at a time
15:44:06 <hpc> relatedly, that's a damn good book and everyone should read it
15:44:13 <hpc> pharaun: heh, same
15:44:18 <hpc> by way of imagemagick bindings
15:44:37 <quchen> I once read the brilliant quote "Just give your #/runhaskell files a .py extension and nobody will notice"
15:45:07 <hpc> quchen: they would notice the slow startup time...
15:45:12 <hpc> wait no they wouldn't ;)
15:45:19 <quchen> :P
15:45:26 <ciaranm> they might notice the less horrific runtimes
15:45:27 <pharaun> :D
15:45:44 <pharaun> amusingly my workplace is a py shop
15:45:59 <pharaun> i mean py aint a too bad of a language, but i'm always finding myself missing the static/strong typing
15:46:07 <jmcarthur> dayom: i think haskell kind of got off to a bad start in terms of mass adoption, given its origins as a pretty much entirely academic language with, at the time, some really major flaws, like not having a good story for I/O. it got a reputation. i think the reputation has changed by now, but not necessarily in the direction we have wanted it to
15:46:12 <quchen> We should also think of the QA departments that would have to let half of their workforce go
15:46:23 <jmcarthur> dayom: it is hard to control a reputation since most of it is due to hearsay and bad assumptions
15:46:35 <pharaun> jmcarthur: what do you mean by "not in the direction we wanted it to" ?
15:46:44 <ciaranm> the thing that gets me about python... is how amazingly slow it is for anything not IO-bound
15:46:45 <dayom> is there somewhere I can checkout performance
15:46:46 <Moggle> pharaun: I know that feeling
15:46:53 <quchen> dayom: I think most people in this channel can tell you the story of trying to tell a friend/coworker about Haskell. The results are usually the same.
15:47:06 <jmcarthur> pharaun: many still consider it academic or useless. the new negative reputation is that it is also hard to use
15:47:16 <quchen> Ivory tower language, nobody uses it, I can do that in my language too etc.
15:47:18 <pharaun> jmcarthur: i've ran into that too much :(
15:47:20 <cmccann> ciaranm: on the other hand, there are a LOT of programs to be written which are inherently IO-bound on modern systems
15:47:27 <pharaun> ^
15:47:46 <pharaun> lots of my work is back-end or batch-processing types of app so we are certainly io-bound for lots of stuff
15:47:57 <pharaun> and for this python works fast enough
15:48:38 <dayom> what's the story on I/O performance for haskell today?
15:48:42 <dayom> are there some benchmarks i can look at?
15:49:11 <ciaranm> it's fairly hard to have performance problems for I/O-bound code... although PHP certainly tries.
15:50:19 <cmccann> dayom: benchmarks like that aren't really very interesting, haskell is capable of being as fast as anything else
15:50:20 <ab9rf> hah
15:50:36 <dayom> haha
15:50:56 <dayom> ok so there's no reason why I can't use this for my next web app
15:50:58 <cmccann> there are some ways you can shoot yourself in the foot that don't exist in other languages but benchmarks by definition don't show that
15:51:06 <dayom> instead of RoR / Django etc
15:51:15 <cmccann> there are several web app frameworks in haskell comparable to those, yes
15:51:17 <ab9rf> I/O performance is almost always dictated by the operating system and the hardware, not the programming language
15:51:35 <Sonarpulse> so I am deriving Arbitrary for my datatypes
15:51:37 <dayom> I'm assuming there are some good libraries out there for common stuff like dbs
15:51:38 <cmccann> and the raw web server performance of some of the haskell stuff is excellent from what I hear
15:51:55 <ciaranm> if you're doing lots of I/Os, it also comes down to quality of either select or threads in your language
15:52:08 <Sonarpulse> does Gen implement functor?
15:52:31 <ag90> Sonarpulse: Yes. http://hackage.haskell.org/packages/archive/QuickCheck/latest/doc/html/Test-QuickCheck.html#t:Gen
15:52:44 <cmccann> or worse yet, sometimes I/O performance is dictated by a network or other things being communicated with
15:52:57 <Sonarpulse> oh good
15:53:51 <thoughtpolice> like your slow hard drive :(
15:54:19 <ab9rf> ciaranm: also whether the IO libraries of your language effectively leverage any features exposed in the OS's low-level interfaces.  some languages have really stupid runtimes.
15:54:32 <Sonarpulse> uh oh
15:54:41 <Sonarpulse> I need Arbitrary ByteString
15:54:58 <Philippa> <cmccann> ciaranm: on the other hand, there are a LOT of programs to be written which are inherently IO-bound on modern systems <- one wonders how much power IO is consuming compared to processing, as opposed to how fast we can do each
15:55:19 <cmccann> yeah, in a lot of the code I've worked on the only way to optimize it was to find the network or HD use and do less of it
15:55:40 <ciaranm> optimising for power management is a lost cause, since there's no sane way of measuring it
15:56:01 <ciaranm> CPUs are too frickin' clever
15:56:16 <ab9rf> cmccann: i've had some data-bound apps that the onl way i was able to make them fast was to suck as much of the data into the app's main memory and minimize round trips to the database server
15:56:26 <thoughtpolice> cmccann: yeah, i used to work on data backup software, so i particularly hate hard drives of course
15:56:29 <ag90> Sonarpulse: There is an Arbitrary Word8. Use that to generate a list and pack that into a bytestring.
15:56:42 <Sonarpulse> ok
15:56:43 <thoughtpolice> luckily speed is also useful too in these instances, because you may be able to trade off IO for CPU, say, compression
15:56:55 <thoughtpolice> (granted you're just going to use a crazy-optimized C library to do that, probably)
15:56:55 <xj54y> Anyone like number theory, graph theory? I have a huge mess and am not really sure where to begin..
15:57:02 <cmccann> ab9rf: I've spent the last three works at my day job essentially bolting caching for DB calls onto a bunch of legacy code
15:57:08 <ciaranm> xj54y: start by putting it in a matrix
15:57:34 <ab9rf> cmccann: basically what i did in this app
15:57:45 <xj54y> ciaranm: I did, but they're all colors.. Fortunately, they're commutative
15:57:47 <cmccann> ab9rf: stuff in the DB that changes once a month at most was being reloaded several times every minute :[
15:57:59 <cmccann> and via a bunch of row-at-a-time queries, too
15:58:03 <cmccann> it was horrifying
15:58:03 <ab9rf> cmccann: ugh
15:58:33 <Philippa> ciaranm: going hard on it is, sure. But significant time savings that aren't about CPU-internal IO concerns have a way of saving power too
15:58:50 <cmccann> ab9rf: from a tiny table, too, it could sit 100% in client memory without even noticing
15:59:10 <Sonarpulse> oh good it does exist!
15:59:32 <logicbuffer> is there anything in ghc that will prevent an infinite list from being evaluated in a stupid way?
15:59:43 <ab9rf> xj54y: you can put colors in matrices :)
15:59:45 <logicbuffer> like if i told ghci last [1..], would it stop that?
15:59:46 <Eduard_Munteanu> logicbuffer: no
15:59:52 <cmccann> > last [1..]
15:59:54 <xj54y> ab9rf: and I did.. :p
15:59:56 <lambdabot>   mueval-core: Time limit exceeded
16:00:03 <Eduard_Munteanu> logicbuffer: you can stop it
16:00:04 <ab9rf> heh
16:00:05 <parcs> that's not a stupid way
16:01:18 <logicbuffer> was just wondering if it would eventually time out or something
16:01:32 <ab9rf> logicbuffer: not without guards of sme sourt
16:01:39 <ab9rf> ghci is happy to spew at you endlessly
16:01:43 <Eduard_Munteanu> Well, that wouldn't be quite appropriate in certain cases.
16:02:01 <ab9rf> or at least until you interrupt it
16:02:10 <Sonarpulse> ok, now I need to collect all my tests and run them at once
16:02:15 <ab9rf> since [1..] is produced tail-recursively printing it doesn't consume memory
16:02:18 <Sonarpulse> is this where Data.Test comes in handy/
16:02:29 <Sonarpulse> * Test.framework
16:02:41 <Eduard_Munteanu> ab9rf: er, that's unrelated to tail-recursion
16:02:47 <ab9rf> so it will not run out of memory, and will gladly print numbers until it dies
16:02:56 <dayom> what do most people use for their web framework?
16:03:07 <ab9rf> dayom: PHP.  why did you ask?
16:03:09 <Eduard_Munteanu> Yesod, Snap or Happstack.
16:03:11 <elliott> snap, yesod and happstack are the main haskell ones
16:03:22 <dayom> yeah I mean haskell framework
16:03:43 <dayom> and those are all pretty much trying to accomplish the same thing?
16:03:50 <dayom> one isn't a micro framework, etc.?
16:03:59 <elliott> well, they have different design philosophies. but they're all more or less full-featured web frameworks
16:04:01 <cmccann> logicbuffer: although if you try to evaluate an expression that depends on its own evaluation being completed, GHC will catch that and throw an infinite loop exception
16:04:08 <elliott> there are some smaller things, like that scotty thing I don't know anything about.
16:04:30 <ag90> IIRC, Scotty is inspired by Sinatra (for Ruby)
16:04:38 <ab9rf> it's virtually a guarantee that for anything one might want to do in haskell, there are either no community libraries for it, or multiple community libraries.  there is never one way to do something.
16:05:51 <xj54y> ab9rf: http://i.imgur.com/Wjudlfh.jpg
16:06:09 <cmccann> yesod is full of metaprogramming and magic so might appeal to people who know rails :P
16:06:57 <ab9rf> xj54y: what am i looking at? :)
16:07:15 <xj54y> ab9rf: a puzzle I'm trying to figure out
16:07:41 <xj54y> ab9rf: looks as though we're dealing with integers though :-)
16:07:42 <ab9rf> xj54y: it looks more like someone who has a webcam that needs to be cleaned
16:07:50 <xj54y> well, kind of..
16:08:09 <xj54y> ab9rf: basically, I took some LSD yesterday then went crazy..
16:08:17 <logicbuffer> ^this is the appropriate way to go about life
16:08:45 <cmccann> xj54y: the problem appears to be that you have too many java and PHP books
16:09:00 <xj54y> cmccann: things are rarely as they appear..
16:09:10 <cmccann> also, is that euclid's elements on a shelf below wolfram's new kind of science? that's hilarious.
16:09:20 <xj54y> Yes
16:09:51 <xj54y> wow, wtf.. That's the wrong picture entirely
16:09:58 <cmccann> hahahaha
16:10:01 * cmccann was wondering
16:10:03 <xj54y> http://i.imgur.com/YFtHgxQ.jpg
16:10:14 <ab9rf> xj54y: heh
16:10:40 <ab9rf> xj54y: that image does not exist or is no longer available.
16:11:57 <ciaranm> wolfram should be next to the PHP book
16:12:04 <ab9rf> my computer hates me
16:12:40 <xj54y> No, you guys don't understand how I organize things :p
16:12:44 <xj54y> http://i.imgur.com/K82zsLA.jpg <-- fixed
16:13:29 <ciaranm> your laptop is flying
16:14:20 <xj54y> hmm
16:14:37 <xj54y> That's probably not very asfe
16:14:38 <xj54y> safe *
16:14:42 <int-e> I like that use of the term "organize"
16:16:43 * hackagebot cloudyfs 0.0.1 - A cloud in the file system.  http://hackage.haskell.org/package/cloudyfs-0.0.1 (BrendanHickey)
16:16:45 * hackagebot cloudyfs 0.0.2 - A cloud in the file system.  http://hackage.haskell.org/package/cloudyfs-0.0.2 (BrendanHickey)
16:17:31 <xj54y> int-e: what do you mean? I'm not sure I understand
16:17:50 <xj54y> does any of that mess look at all like something that COULD make sense?
16:17:59 <xj54y> anything that looks familiar?
16:31:12 <int-e> xj54y: honestly it doesn't look disorganized to me. I don't know what the graphs represent, but you even arranged the sheets of paper quite carefully.
16:31:54 <xj54y> meh.. I feel that I was very much so on to something but... I don't know what so much of it means now :(
16:47:49 <dayom> wait
16:47:55 <dayom> functions memoize automatically?
16:47:59 <arkeet> no
16:48:22 <dayom> if I run
16:48:23 <dayom> let rightTriangles' = [ (a,b,c) | c <- [1..], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2]
16:48:28 <eikke> is there anything like "STRef s a -> STRef s a -> Bool" which says whether 2 given refs are 'the same thing'
16:48:32 <dayom> it gives a list
16:48:34 <dayom> if i kill it
16:48:36 <dayom> then run it again
16:48:37 <arkeet> dayom: that's not a function.
16:48:39 <int-e> constants (functions without arguments) are memoized automatically.
16:48:40 <dayom> it starts from where it left off
16:48:42 <quchen> eikke: liftA (==)?
16:48:45 <quchen> eikke: liftA2 (==)?
16:48:46 <shachaf> rightTriangles' is not a function
16:48:50 <dayom> ok cool
16:48:50 <arkeet> quchen: no
16:48:56 <arkeet> eikke: no.
16:49:02 <quchen> Oh, checking pointers so to speak?
16:49:08 <shachaf> int-e: I don't think that's exactly "memoization"
16:49:12 <eikke> quchen: yeah. been reading too much ML & its late. thanks
16:49:18 <int-e> although it's strange to talk of it as memoization. They are values that are being evaluated.
16:49:24 <arkeet> eikke: you can test whether they have equal contents, but that's different.
16:49:31 <Eduard_Munteanu> eikke: I think there's an instance of Eq, no?
16:49:33 <shachaf> eikke: There is an instance Eq (STRef s a)
16:49:36 <eikke> arkeet: I dont care about content equality here :)
16:49:42 <arkeet> hmm.
16:49:42 <dayom> this is awesome
16:49:46 <eikke> shachaf, Eduard_Munteanu: yup. Feel stupid now.
16:49:55 <arkeet> what was the issue before, then.
16:50:07 <arkeet> oh, it was something else. never mind.
16:50:30 <quchen> So Eq for STRef does what?
16:50:31 <int-e> It's really the very nature of lazy evaluation that values exist in an unevaluated form.
16:50:35 <tootooroo> Eduard_Munteanu: That would be an analog of 'a ref being an eqtype even if 'a is not, right?
16:51:03 <Eduard_Munteanu> tootooroo: what do you mean "eqtype"?
16:51:08 <cmccann> if there's an Eq instance for (STRef s a) that doesn't need an Eq instance for "a" there's really only one thing it can be doing
16:51:19 <Eduard_Munteanu> quchen: it's like comparing pointers
16:51:27 <tootooroo> Eduard_Munteanu: Sorry, ML concept. eqtypes are types whose instances can be tested for equality.
16:51:47 <Eduard_Munteanu> tootooroo: yeah, there's no (Eq a) requirement for that
16:51:49 <shachaf> cmccann: reallyUnsafePtrEquality# ?
16:51:49 <quchen> Eduard_Munteanu: Oh, and it's possible because it's ST (contrary to normal Haskell where you can't access memory locations)
16:52:04 <shachaf> instance Eq a => Eq (STRef s a) doesn't even make sense.
16:52:06 <cmccann> shachaf: haha no
16:52:35 <cmccann> and yeah, you couldn't check equality of the contents without producing something in ST anyhow
16:58:50 <quchen> Suppose I have a transformer stack type that I would like to hide behind a newtype. Question a) would be whether this makes sense.
16:59:10 <Eduard_Munteanu> Yes.
16:59:30 <quchen> b) would be how to derive all the instances 1. manually and 2. in practice the easiest way.
16:59:49 <quchen> (Instances like Monad, Functor, Applicative etc.)
16:59:56 <Eduard_Munteanu> Just use GeneralizedNewtypeDeriving and derive what you need.
17:01:21 <quchen> Eduard_Munteanu: I suspected that. How would I do it manually though?
17:01:32 <Eduard_Munteanu> (don't forget stuff like MonadReader and such if you use e.g. Reader)
17:01:32 <hpaste> quchen pasted “Monad wrapper” at http://hpaste.org/84942
17:01:42 <quchen> ^ Typechecks and feels right at least.
17:01:49 <Eduard_Munteanu> quchen: it's pretty straightforward to write it yourself
17:01:55 <quchen> Is that basically what GeneralizedNewtypeDeriving creates?
17:01:56 <Eduard_Munteanu> But messy.
17:02:20 <Eduard_Munteanu> Yeah, that seems right.
17:02:30 <lgas> It appears I can use "cabal-dev install --only-dependencies" to install the dependencies of my executable as defined in my .cabal file, but is there a way to do the same thing for the test-suite defined in the same file (which has extra dependencies)?
17:02:49 <quchen> Eduard_Munteanu: That was easier than I thought then. Wonderful, thanks :-)
17:05:38 <byorgey> lgas: cabal-dev install --only-dependencies --enable-tests ?
17:10:48 <lgas> thanks byorgey
17:11:06 <tomoj> can you write a sumI for relative improving times which propagates comparison info just as well as maxI for absolute?
17:14:53 <tomoj> the asAgree trick seems to fail
17:19:00 <sw2wolf> what's the recommended way between cabal and cabal-dev ?
17:30:48 <quchen> I'm beginning to suspect GADTs don't go well with monads in some way.
17:31:14 <quchen> Maybe I should just write a brief ten page essay to describe my problem and post it on SO ;(
17:34:17 <Philippa> quchen: I'm not sure how they'd interact
17:34:39 <quchen> Philippa: In the sense that it's rarely encountered or you find what I said weird?
17:34:50 <Philippa> I mean, I've implemented monads whose back end consisted of a GADT representing the monadic language and an interpreter, and that worked just fine?
17:35:37 <Philippa> I've past values belonging to GADTs around in computations all day long
17:35:40 <Philippa> *passed
17:35:42 <quchen> In brief: I have this monad transformer stack, along with a handful of functions to create it. Think of "addFile :: Filename -> Contents -> RWST IO a"
17:35:53 <quchen> And then removeFile, readFile etc.
17:36:09 <Philippa> so you've got some actions in your stack, sure
17:36:12 <quchen> RWST is easily chainable due to its monad nature and everything is fine.
17:36:37 <quchen> I would now like to write two sub-modules that implement the same interface - addFile, removeFile, ...
17:37:15 <quchen> One that actually does the stuff, and one that prints what it would do ("would delete file XY now") to the terminal, as due to the file system nature it's much easier to look at what the program is doing this way.
17:37:33 <quchen> The problem is now how to enforce this common interface.
17:38:05 <quchen> My weird but working solutoin defined the interface as a type class; each of the sub-modules then defines a dummy type that is an instance.
17:38:20 <quchen> It works, but feels wrong.
17:38:26 <Philippa> that's not weird, that's pretty normal
17:38:26 <Eduard_Munteanu> Hide the newtype constructor?
17:38:33 <quchen> I've been looking for the right way to do things for days now.
17:38:43 <Eduard_Munteanu> Actually that probably doesn't help you.
17:39:09 <elliott> you can often replace that with simply a record.
17:39:15 <Philippa> typeclass-defining-interface is so normal that eventually we realised classes are equivalent to signatures in ML modules and instances are equivalent to structures and/or functors
17:39:17 <elliott> (a typeclass where you have to make dummy types whose sole purpose is to be an instance)
17:39:17 <eikke> OK, looks like writing a monad transformer on top of ST equals making life difficult
17:39:23 <quchen> elliott: That would be the GADT approach then, I assume?
17:39:32 <elliott> I don't really see what it has to do with GADTs
17:39:50 <Philippa> elliott: true, although you probably want to locally rebind that record too
17:40:07 <Eduard_Munteanu> eikke: transformers are rather oblivious of the precise monad you apply them to
17:40:20 <elliott> Philippa: well, the record usually goes where you'd have dummy values of that type, so you can just use field accessors directly
17:41:02 <quchen> So basically you're telling me interface-defining classes and dummy types are fine?
17:41:02 <eikke> Eduard_Munteanu: yeah, but ST's state token makes things more difficult, so it seems
17:41:03 <Philippa> elliott: yeah, I'm not sure that works so well for monadic actions though
17:41:09 <quchen> Oo
17:41:16 <elliott> well, I'm not sure I understand the problem in the first place :P
17:41:24 <Philippa> (you can use the monad as your inference cue for which instance to use)
17:41:32 <elliott> eikke: FooT (ST s) a should work just fine
17:41:48 <beaky> hello
17:41:55 <Eduard_Munteanu> beaky: hi
17:42:08 <beaky> what is functional programming?
17:42:21 <Eduard_Munteanu> ...
17:42:31 <quchen> elliott: What did you mean by "replacing the class with a record"?
17:42:31 <beaky> yeah sounds like a silly question :(
17:42:33 <eikke> elliott: sure, but other things are complicating, so it seems
17:42:43 <elliott> quchen: I think I retract that answer, since I don't understand the question
17:42:58 <Eduard_Munteanu> beaky: not in itself, but you've been here before... I thought you knew that.
17:43:18 <quchen> Hmm. I'll just keep writing it up and post it as bulk then
17:43:51 <Philippa> quchen: I find your solution pretty natural, if I've understood it correctly. Haskell is just not as good at this kind of thing as we might hope sometimes
17:44:00 <dmwit> beaky: If functions can be created, modified, and generally treated as data at runtime, then you are doing functional programming.
17:44:23 * geekosaur thinks beaky keeps recycing the same questions every few days, tbh
17:44:28 <beaky> ah
17:44:56 <beaky> C++ can do that, so is it a functional programming language?
17:45:05 <Philippa> yes: a shitty one :p
17:45:10 <dmwit> Sure, why not?
17:45:14 <beaky> ah
17:45:40 <beaky> what is a function?
17:45:47 <Eduard_Munteanu> @protontorpedo
17:45:47 <lambdabot> how does haskell compare to say java?
17:46:04 <cmccann> dmwit: hey, hackage says you uploaded the current version of the gtk bindings, so I'll ask you whether there's any chance of getting some missing stuff added or if I should make a separate library or whatever
17:46:08 <beaky> lambdabot: they are very different languages
17:46:21 <dmwit> cmccann: What's missing?
17:46:24 <arkeet> beaky: you do realize who you're talking to.
17:46:28 <cmccann> extended input device stuff
17:46:31 <beaky> ah oops lol
17:46:32 <dmwit> cmccann: (And yes, I'm the current de facto maintainer.)
17:46:38 <cmccann> i.e. pressure sensitivity for a tablet
17:46:58 <cmccann> I hacked the basics into my local copy but I have no idea how to do it "right"
17:47:00 <dmwit> That sounds like stuff we should bind to, at least in an #if GTK_CHECK_VERSION.
17:47:15 <cmccann> I think it's mostly event stuff that's missing
17:47:22 <cmccann> and a few data structures
17:47:37 <ion> All devices are pressure-sensitive, you just have to apply enough pressure.
17:47:43 <cmccann> I added some enums and some junk to pull fields from an event
17:48:03 <dmwit> To be honest, I probably don't know much more than you about how to do it "right".
17:48:06 <cmccann> but it would be nice to have all of it, not just the bits I wanted immediately
17:48:13 <cmccann> heh
17:48:37 <Cale> beaky: If A and B are any sets, then a function f: A -> B consists of a triple of sets, (A,B,G), where G is a set of pairs (a,b) with a in A and b in B such that for any a in A, there is exactly one b in B such that (a,b) is in G.
17:48:41 <cmccann> I spent an evening figuring out why it was segfaulting THIS time until the parts I wanted were working
17:48:51 * Eduard_Munteanu wonders if beaky has a left adjoint :P
17:48:58 <Cale> beaky: A is called the domain of f, while B is called the codomain of f, and G is called the graph of f
17:49:10 <Cale> When (a,b) is in G, we write f(a) = b
17:49:33 <beaky> so A and B are like types?
17:49:37 <Cale> yes
17:49:39 <beaky> ah
17:50:02 <cmccann> dmwit: anyway I think most of http://www.gtk.org/api/2.6/gdk/gdk-Input-Devices.html is missing from the bindings
17:50:04 <Cale> beaky: C++ doesn't have a particularly good representation of functions between its types built in -- it has things which it calls functions, but they are not particularly faithful representations of the mathematical concept.
17:50:15 <cmccann> as well as any support for extracting the relevant information from an event
17:50:20 <Cale> (because they include many other computations which are not functions)
17:50:58 <quchen> Philippa, elliott: I hope this explains things a bit better. https://gist.github.com/quchen/5282658
17:51:02 <cmccann> dmwit: http://www.gtk.org/api/2.6/gdk/gdk-Events.html#gdk-event-get-axis for example
17:51:25 <dmwit> So, yes, send some patches to the mailing list and we'll see what we can do to support you.
17:51:36 <cmccann> ok
17:52:01 <Cale> beaky: In Haskell, if A and B are types, then a value of type A -> B is a pretty decent model of a mathematical function between the sets of values of types A and B.
17:52:02 <Philippa> quchen: okay, so what elliott said in general? What I'm saying when the interface is monadic :-)
17:52:03 <cmccann> just wanted to make sure there'd be interest in including it before I went to the effort
17:52:08 <dmwit> Be sure to set upper and lower bounds on the versions if that's relevant (i.e. in the repository is some rudimentary support for gtk3, so please check whether your thing builds with -f-gtk3 and with -fgtk3).
17:52:37 <dmwit> Also, I have a history of taking a long time to respond to things to do with gtk, so fair warning up front.
17:52:47 <Cale> beaky: (Not all such functions are in general computable, but everything which you can represent in plain Haskell without using low-level hooks will correspond to a proper mathematical function)
17:52:52 <quchen> Philippa: And elliott said "replace it with records"?
17:53:18 <dmwit> cmccann: Though you can pretty well predict when I will hit my next batch of responses by watching when https://www.beeminder.com/dmwit/goals/maintain-gtk2hs goes red. =)
17:53:21 <beaky> ah
17:53:23 <Philippa> yeah. Which is equivalent to dictionary-passing-transforming away the typeclass
17:53:30 <cmccann> dmwit: thing is I know fuck-all about GTK in general, this is pretty much my first attempt at doing anything with it, in Haskell or otherwise
17:53:47 <dmwit> Okay.
17:53:56 <cmccann> hence the "doing it right" concern :[
17:54:32 <dmwit> Well, my policy so far has been "do it first and wait for complaints". Anybody who doesn't like this policy can damn well volunteer to be the next maintainer. ;-)
17:54:51 <cmccann> hahaha
17:54:55 <Eduard_Munteanu> So how goes gtk3hs?
17:54:57 * Eduard_Munteanu hides
17:55:06 <dmwit> Eduard_Munteanu: pull from the repository and build with -fgtk3
17:55:16 <quchen> Philippa: So I define this huge tuple (using records), and then have every interface implementing module create a value of that type, the records filled with the appropriate functions. Calling those functions would then look like "doStuff terminal ..."?
17:55:22 <Eduard_Munteanu> Oh, cool.
17:55:28 <cmccann> anyway, everything I want bindings for at least seems to exist in gtk3 if memory serves me
17:55:37 <dmwit> cool
17:55:42 <Philippa> quchen: yeah
17:55:45 <cmccann> so hopefully that won't add additional headaches
17:56:18 <Eduard_Munteanu> dmwit: btw, are there major changes from 2 to 3, as far as gtk2hs is concerned? Or do you get away with simple fixes?
17:56:31 <dmwit> There's some pretty major changes.
17:56:39 <dmwit> Things are still not really... *right*... with the support.
17:56:40 <Philippa> quchen: if you just want to rebind which module you're using fast, there's an extra trick you can use - locally rebind all the names in your own module!
17:56:44 <cmccann> dmwit: oh and the other thing, I have no idea how to use darcs either :P
17:56:50 <dmwit> (e.g. there's no way to draw your own widgets with Cairo, currently)
17:56:55 <Eduard_Munteanu> Ah, I see.
17:57:00 <quchen> Philippa: Hm. Can I still use different data types *inside* each sub-module? Say one uses Ints, the other one Data.Map for some intermediate state?
17:57:02 <dmwit> cmccann: Haha, really?
17:57:05 <cmccann> yeah
17:57:19 <dmwit> cmccann: Do you want a crash course, or... what?
17:57:26 <quchen> Philippa: Right now I'm using DataKinds to have each instance use its own version of a lookup table
17:57:28 <cmccann> not right now
17:57:36 <quchen> Philippa: Eh, not DataKinds, TypeFamilies
17:57:53 <Philippa> quchen: You can do that, yeah. TypeFamilies will just be helping you do the type inference for it, too
17:57:59 <Philippa> (which is still a good thing!)
17:58:19 <cmccann> dmwit: but I'll probably poke you on IRC in the near-ish future about this, since I'd rather work on my application right now instead of muck with the gtk bindings
17:58:31 <quchen> Philippa: What did you mean with your trick above? I didn't quite understand that.
17:58:46 <dmwit> cmccann: Sounds good! And I know the traditional response to poke...
17:58:56 * dmwit pukes
17:59:12 <cmccann> I'm happy to do all the actual coding for this but I'll probably need help with the whole "contributing acceptable code" part :P
17:59:46 <Philippa> quchen: suppose your modules export M.f or (f M.terminal) - you can locally have f = M.f
18:00:19 <cmccann> currently I've moved on to using opengl to render blank screens in increasingly complicated ways
18:00:46 <quchen> Philippa: Still unclear to me. What problem does this solve?
18:00:56 <dmwit> cmccann: Oh, one of my favorite blog posts is titled "40 ways to render a blank screen" or something like that.
18:00:59 <quchen> Philippa: What's "locally"?
18:01:11 <cmccann> dmwit: pretty sure I've seen that
18:01:27 <dmwit> pretty hilarious =)
18:01:46 <cmccann> there are a rather large number of small mistakes you can make in setting things up in OpenGL that result in getting a blank screen and no indication of why :[
18:01:56 <dmwit> It's just, you can feel the pain of debugging oozing out of every sentence...
18:02:09 <cmccann> yep
18:02:55 <Philippa> quchen: pick a scope, any scope
18:02:56 <cmccann> and I'm trying to force myself away from legacy opengl stuff so I can't even fall back on things I already know work :T
18:03:10 <Philippa> it mostly lets you ditch the record lookup
18:03:30 <quchen> Philippa: Oh, you mean omit the "terminal" in "doStuff terminal"?
18:03:39 <Philippa> quchen: yeah
18:03:46 <quchen> Philippa: That was kind of my main issue now - adding a Reader would be somewhat ugly
18:03:56 <quchen> Anyway, I got a scope.
18:03:58 <quchen> Now what? :-)
18:04:14 * elliott mumbles something about reflection
18:04:18 <Philippa> manually bind names for the fields in the record
18:04:35 <quchen> ..?
18:04:38 <Philippa> elliott: mmm, if you have a reflective way to do that, feel free to fill in the blanks
18:04:53 <Philippa> it's 2am here and I'm exhausted for additional reasons as well
18:04:56 <elliott> I meant the reflection package as a tactic for avoiding the syntactic overhead of Reader
18:05:13 <elliott> though I don't know if it applies to this problem in general, hence the mumbling
18:05:17 <Philippa> elliott: ah
18:05:34 <quchen> Suppose we don't want to use reflection. Go on Philippa :-)
18:05:43 <quchen> (I'll have a look at it anyway, thanks.)
18:07:03 <Philippa> quchen: doStuff = doStuff M.terminal, etc etc
18:07:46 <hpaste> mikeplus64 pasted “ghc impresses me” at http://hpaste.org/84949
18:08:47 <quchen> Philippa: Oh, I see. And if I make those definitions in the Terminal module and export those only, the interface is nice and clean from the outside.
18:09:13 <Philippa> quchen: you can do that too, yeah - proxy module
18:09:37 <quchen> Proxy module? Do I need another one between?
18:10:03 <quchen> i.e. a "nice record access function name module"?
18:10:46 <quchen> Well, that's details now anyway that I can figure out once I've rewritten the interface for the 10th time
18:10:51 <Philippa> yeah
18:10:53 <quchen> Thanks a lot for your help!
18:10:55 <Philippa> (re the latter)
18:10:57 <Philippa> np!
18:11:22 <quchen> Let's see how far I get with it this time ;-)
18:11:31 <quchen> Funny how much time you can waste on something that already works
18:12:37 * DanZimm is back 
18:12:39 <DanZimm> :P
18:12:40 <quchen> Well then, I'm tired, coding this tomorrow. Have a good night
18:15:30 <kdridi> hi
18:16:20 <kdridi> how do i compile a previous version of ghc ? I try to compile ghc-6.12.1 with ghc-7.4.2 but it doesn't work
18:16:33 <kdridi> in fact i try to compile jhc but i can't either
18:20:23 <ludamad> Can anyone explain the { } usage in eg 'allTeams' here ? I don't get what {} does in this context. http://hackage.haskell.org/packages/archive/mongoDB/1.3.2/doc/html/Database-MongoDB.html
18:20:29 <ludamad> I've only seen it used in the case of records
18:21:22 <elliott> ludamad: looks like it is using a record there
18:21:35 <elliott> in particular, (select [] "team") is a record value
18:21:37 <ludamad> elliott: So the constructor is implied ?
18:21:41 <elliott> and you can update records by doing rec{field = value}
18:21:46 <ludamad> Ooh.
18:21:47 <elliott> it's actually ((select [] "team") {sort = ["home.city" =: 1]})
18:21:49 <ludamad> Its an update. gotcha
18:21:57 <elliott> pretty confusing spacing for it there, though
18:22:08 <ludamad> I wish that example had explicit types
18:22:14 <ludamad> and well, another example past that one
18:24:36 <ludamad> I feel like a lot of the package examples try to show terseness but hurt understandability
18:34:26 * sw2wolf working now
19:37:48 <cschneid> I have [a] and want to turn it into [(a, f(a))] (ie, basically zip, where second arg is a function of a). Is there built-in for that?
19:39:15 <shachaf> zip x (map f x)?
19:39:19 <shachaf> I don't think so.
19:39:26 <shachaf> There is always (zip <*> map f)
19:39:48 <Saizan> map (id &&& f)
19:39:57 <shachaf> That too.
19:43:47 <shachaf> @ty ap zip . map
19:43:48 <lambdabot> (a -> b) -> [a] -> [(a, b)]
19:44:03 <shachaf> @ty map . (id &&&)
19:44:04 <lambdabot> (c -> c') -> [c] -> [(c, c')]
19:53:04 <sw2wolf> :t id &&&
19:53:05 <lambdabot> parse error (possibly incorrect indentation)
19:53:18 <sw2wolf> :t &&&
19:53:19 <lambdabot> parse error on input `&&&'
19:53:35 <sw2wolf> :t (<&&&>)
19:53:37 <lambdabot> Not in scope: `<&&&>'
19:53:45 <Saizan> :t (&&&)
19:53:46 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
19:53:55 <sw2wolf> thx
19:53:56 <Saizan> :t (id &&&)
19:53:57 <lambdabot> (c -> c') -> c -> (c, c')
19:54:37 <sw2wolf> :t id
19:54:39 <lambdabot> a -> a
19:54:41 <tootooroo> :t (Control.Category.id &&&)
19:54:42 <lambdabot> Arrow a => a c c' -> a c (c, c')
19:58:01 <sw2wolf> i donot understand (id &&&)
19:58:10 <sw2wolf> :t (id &&&)
19:58:12 <lambdabot> (c -> c') -> c -> (c, c')
19:58:23 <elliott> sw2wolf: (a -> b) -> a -> (a, b)
19:58:25 <elliott> \f x -> (x, f x)
19:58:52 <shachaf> @@ @djinn @type (id &&&)
19:58:53 <lambdabot>  f a b = (b, a b)
19:58:56 <shachaf> @@ @pl @djinn @type (id &&&)
19:58:58 <lambdabot>  f = ap (,)
20:01:58 * sw2wolf thinking how does id changes &&& ?
20:02:28 <shachaf> @ty (&&&) id
20:02:30 <lambdabot> (c -> c') -> c -> (c, c')
20:02:35 <shachaf> It's an argument.
20:02:40 <sw2wolf> clear, thx
20:08:38 <mitch> hi
20:10:07 <Guest55152> hi, confused about a homework question.
20:10:18 <Guest55152> Why do the following expressions not type-check?
20:10:25 <Guest55152> [`a`,1,2]
20:10:39 <tootooroo> Guest55152: That one does not even parse. :-|
20:11:12 <Guest55152> I am confused about what they want me to say lol
20:11:15 <c_wraith> Guest55152: but assuming you meant ['a', 1, 2], what type would it have if it *did* type check?
20:11:34 <tootooroo> Oh! 'a'
20:11:52 <c_wraith> ...  actually, that one could type check easily enough...  If you didn't mind writing some evil instances
20:12:01 <tootooroo> Guest55152: In Haskell, lists are homogeneous. All the elements must have the same type.
20:12:24 <c_wraith> But your homework probably is not actually crediting numeric constants with being polymorphic
20:12:42 <tootooroo> Guest55152: And there is no type that could have 'a', 1, 2 as its instances simultaneously.
20:12:53 <Guest55152> ohhhhhh
20:12:58 <Guest55152> Wow i see now lol
20:13:04 <c_wraith> that's really not true, though.  >_>
20:13:10 <c_wraith> instance Num Char where ...
20:13:17 <tootooroo> c_wraith: Weeeeeeeeeeeell...
20:13:19 <jfischoff> c_wraith: shh ;)
20:13:20 <c_wraith> It'd be evil, but it would make that typecheck!
20:13:47 <c_wraith> But pretend your homework has disabled polymorphic numeric constants. :)
20:14:02 <Guest55152> I will write something like, every element in a list has to be of the same type
20:14:04 <Guest55152> should be ok i guess
20:14:14 <Guest55152> was confused as to what they were asking
20:14:27 <c_wraith> yeah, I think that's the answer it's looking for.
20:14:46 <tootooroo> Guest55152: Well, the type of numerical constants such as 1 and 2 is "(Num a) => a". In order for your list to type check, all you would have to do is provide a Num instance for Char, as c_wraith said.
20:15:10 <Guest55152> ohh i see
20:15:15 <djahandarie> You could write a more sophisticated answer, where you desugar the list notation and show exactly where the type checking fails (on the cons).
20:15:26 <djahandarie> That's what I'd do at least.
20:15:50 <Guest55152> Yeah, I would say I should.
20:15:53 <shachaf> hi geheimdienst
20:16:04 <Guest55152> seems a little simple just to say list elements need to be of the same type
20:16:15 <c_wraith> I don't think that is too simple
20:16:27 <c_wraith> It's actually intended to be a simple question, as far as I can tell
20:16:37 <Guest55152> hmm
20:16:38 <djahandarie> I think it's a bad question if that's the answer it's looking for.
20:16:57 <Guest55152> here is the next 1
20:16:59 <Guest55152> [(*), 0, (+)]
20:17:02 <c_wraith> Most introductory homework questions I've seen on haskell have been terrible.
20:17:21 <c_wraith> Heh. Once again, that could be made to type check with the right instance. >_>
20:17:45 <Mortchek> The idea that they might want you to acknowledge that is growing in probability in my mind
20:17:46 <djahandarie> Haha. It would be kind of funny if you wrote out the instances and said the question is wrong.
20:18:02 <djahandarie> Mortchek, my impression is they haven't even gotten to type classes yet, so I doubt that.
20:18:10 <Mortchek> It really depends on what the class has covered so far
20:18:28 <tootooroo> Guest55152: Again, the elements have to have the same type.
20:18:38 <djahandarie> Polymorphic numeric literals isn't exactly a well-known or particularly important fact anyways.
20:18:38 <Guest55152> yeah
20:18:53 <ParahSail1n> c_wraith, what instance would that be?
20:19:03 <Mortchek> Num
20:19:06 <c_wraith> heck, lambdabot used to have that instance
20:19:07 <c_wraith> > 0 0
20:19:09 <lambdabot>   0
20:19:11 <c_wraith> still does
20:19:14 <Guest55152> Yeah, I am confused
20:19:15 <shachaf> It's back, rather.
20:19:15 <Guest55152> lol
20:19:16 <Mortchek> > 5 5
20:19:17 <lambdabot>   5
20:19:17 <Guest55152> all seem to be the same
20:19:21 <Guest55152> look at the next one
20:19:21 <Guest55152> [(1,True),(`2`,False)]
20:19:26 <c_wraith> shachaf: ah
20:19:37 <djahandarie> Guest55152, it's single quotes, not backquotes.
20:19:41 <djahandarie> ' vs `
20:19:47 <ParahSail1n> @ty 5 5
20:19:48 <lambdabot> Num t => t
20:20:06 <tootooroo> What exactly was the Num instance for functions?
20:20:12 <c_wraith> const
20:20:13 <djahandarie> const, essentially.
20:20:18 <shachaf> 5 = const 5
20:20:19 <Guest55152> so that is a list of tuples right?
20:20:23 <shachaf> I,I 5 = fix const
20:20:26 <tootooroo> c_wraith: djahandarie: Ah!
20:20:33 <Mortchek> Guest55152, yep.
20:20:42 <andrewsw> Guest55152: yes it is. what are the types of the tuples?
20:20:45 <Mortchek> But "tuple" is not just one type
20:20:48 <djahandarie> Guest55152, yes, but once you try to type the tuples it goes wrong.
20:21:34 <Guest55152> hmm
20:21:37 <Guest55152> so it would have
20:21:40 <Guest55152> (Int, Bool)
20:21:48 <Guest55152> (char, Bool)
20:21:51 <Guest55152> or am I confused
20:22:17 <djahandarie> Yes, those would be the types of the two values, but once you try to unify the values (which is what the cons constructor causes), the type checking fails.
20:22:18 <c_wraith> djahandarie: I'm the kind of jerk who'd actually answer by defining instances that make them typecheck, and submitting that as my solution. But teachers quickly learned to consider me a nuisance.
20:22:37 <djahandarie> :t (1, True)
20:22:38 <lambdabot> Num t => (t, Bool)
20:22:39 <c_wraith> at least I wouldn't usually do that in class
20:22:45 <djahandarie> :t ('2', False)
20:22:46 <lambdabot> (Char, Bool)
20:22:48 <djahandarie> :t ('2', False):[]
20:22:50 <lambdabot> [(Char, Bool)]
20:22:59 <djahandarie> :t (1,True):(('2', False):[])
20:23:01 <lambdabot>     No instance for (Num Char)
20:23:01 <lambdabot>       arising from the literal `1'
20:23:01 <lambdabot>     Possible fix: add an instance declaration for (Num Char)
20:23:04 <djahandarie> Boom!
20:23:23 <ParahSail1n> @ty [(*), 0, (+)]
20:23:24 <lambdabot> Num a => [a -> a -> a]
20:23:36 <otters> :t 0
20:23:37 <lambdabot> Num a => a
20:23:49 * djahandarie renames lambdabot to 'bad for explaining haskell' bot
20:24:09 <tootooroo> djahandarie: At least the Num instance for functions does not help!
20:24:09 <Guest55152> hmmm
20:24:09 <elliott> djahandarie: those instances were even removed fairly recently.
20:24:12 <elliott> but they are back somehow.
20:24:27 <Guest55152> length is a prelude defined function, right?
20:24:35 <djahandarie> @hoogle length
20:24:36 <lambdabot> Prelude length :: [a] -> Int
20:24:36 <lambdabot> Data.List length :: [a] -> Int
20:24:36 <lambdabot> Foreign.Marshal.Array lengthArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO Int
20:24:46 <djahandarie> Yes!
20:25:10 <Guest55152> ahhh i see what is wrong with the next question lol
20:25:12 <Guest55152> it was this
20:25:12 <Guest55152> length (1,2,3,4)
20:25:16 <Guest55152> not even inside a list
20:25:18 <Guest55152> []
20:25:31 <djahandarie> They're probably just trying to syntactically confuse people.
20:25:52 <djahandarie> People who haven't programmed before often get confused by ( vs { vs [ and such
20:26:11 <Guest55152> but this is a third year university paper =\
20:26:22 <Guest55152> that is why I can't see why it is so simple
20:27:08 <c_wraith> What language does the university use for its lower-level courses?
20:27:23 * djahandarie guesses Java
20:27:25 <c_wraith> If it's a language like python, there's some point in repeating the concept
20:27:35 <Guest55152> c# first year java second
20:27:57 <c_wraith> because in a language like python, ['a', 2, Foo()] is just fine
20:29:09 <djahandarie> Guest55152, though if were really so simple, would you be in here asking questions?
20:29:16 <djahandarie> Not that asking questions is bad.
20:29:33 <Guest55152> well I was asking because I thought there would be something more to it lol
20:29:39 <Guest55152> like I will post the next question
20:29:42 <Guest55152> which I am sure you will agree
20:29:46 <Guest55152> is alot harder lol
20:29:49 <Guest55152> have a look
20:29:53 <Guest55152> don't answer it though, please =D
20:30:11 <Guest55152> Using the deﬁnition of trees given by
20:30:19 <Guest55152> data Tree a = Node (Tree a) (Tree a) | Leaf a
20:30:26 <Guest55152> deﬁne tree versions of the list functions zip and zipWith
20:30:42 <c_wraith> Oh, man.  Someone asked that on Stackoverflow recently.
20:30:57 <c_wraith> Never did answer the questions people asked about what it's supposed to actually *do*
20:31:13 <cmccann> c_wraith: what a remarkable coincidence!
20:31:16 <c_wraith> Because being a tree is actually quite different, as far as those functions go.
20:31:29 <cmccann> just like the entirely coincidental times when the same question gets asked three times on SO within a week or so.
20:31:42 <djahandarie> Does anyone remember that MapReduce thing?
20:31:42 <c_wraith> This is really striking me as an incredibly poorly-written homework assignment.
20:31:53 <c_wraith> vaguely
20:32:03 <cmccann> c_wraith: that's been my opinion of most of the Haskell homework questions that end on SO
20:32:03 <c_wraith> I certainly remember tons of questions about it suddenly
20:32:18 <cmccann> though obviously I'm getting a biased sample since people are asking for help!
20:32:27 <c_wraith> And thinking it was a very odd thing to base a homework assignment on.
20:32:29 <djahandarie> Some doped up professor released the most incoherent Haskell assignment and like 20 of his students showed up here and other places on the web asking for him.
20:32:36 <djahandarie> for help*
20:32:39 <cmccann> hahaha
20:33:02 <cmccann> what I hate is when two or three reasonable answers on SO get shot down because of arbitrary restrictions on the assignment
20:33:13 <cmccann> and inevitably it turns out the professor wants something really stupid
20:33:20 <cmccann> sigh
20:34:01 <djahandarie> I think this is from what I'm talking about: http://stackoverflow.com/questions/4099627/haskell-define-merge-using-mapreduce
20:34:40 <c_wraith> heh.  amusing that a professor quits in the middle of this conversation
20:34:54 <c_wraith> (andy gill is a CS professor at the university of Kansas)
20:35:00 <Guest55152> is that tree question a bad one?
20:35:08 <djahandarie> I think it's okay.
20:35:17 <c_wraith> Guest55152: it's underdefined, a bit.
20:36:09 <c_wraith> like, what's the result of zipping Node (Leaf 0) (Node (Leaf 1) (Leaf 2)) with Node (Node (Leaf 0) (Leaf 1)) (Leaf 2)
20:36:18 <cmccann> figuring out what the tree versions should do would be a reasonable assignment, to my mind
20:36:32 <c_wraith> if you assume the input trees are the same shape, it's a good question.
20:36:41 <c_wraith> If you don't make that assumption, you have some real headaches.
20:36:47 <cmccann> but not as a "figure out what this means, then implement it"
20:36:59 <c_wraith> especially since that tree definition doesn't allow you to have an empty leaf
20:37:29 <cmccann> a better way would be: "figure this out" -> get response to answer and correct version if necessary -> "implement it"
20:37:45 <Guest55152> It is one of the more difficult questions he gave us
20:38:02 <c_wraith> Like, I can't think of any sane way to answer that question for the two input values I provided, with that particular Tree type.
20:38:03 <Guest55152> first one was implementing a merge sort function
20:38:24 <c_wraith> They have no Leaf nodes in the same place.
20:38:33 <c_wraith> But it's impossible to return an empty tree as a result
20:38:40 <cmccann> yeah, that seems fishy to me
20:39:08 <djahandarie> He obviously should have enforced a same-shape invariant in his type.
20:39:58 <Mortchek> c_wraith, the most obvious answer I came up with when I thought about that question was to overlap the trees and default to a Leaf wherever there is a Node on one tree and a Leaf on the other.
20:40:21 <Mortchek> And then the identity of that operation is an infinite tree
20:40:47 <c_wraith> Mortchek: That sorta works for zip, since you can implement it by passing the same arg twice to (,)
20:41:13 <c_wraith> Mortchek: but it doesn't work for zipwith, unless you restrict it to taking functions with a type like (a -> a -> a)
20:41:54 <Mortchek> Hrm, can you give an example why not?
20:42:18 <c_wraith> what would you do in my example if the function passed in was of type (Int -> Double -> String)?
20:42:46 <c_wraith> You would have either an Int or a Double, and no way to apply the function to one arg of that type and get a string
20:42:53 <Mortchek> Oh woops, I was using a different representation.
20:43:06 <Mortchek> data Tree a = Node a (Tree a) (Tree a) | Leaf a
20:43:18 <c_wraith> Yeah, your approach works for that type.
20:44:25 <Mortchek> pure x :: Tree Foo = Node x (Node x …) (Node x …)
20:45:09 <c_wraith> that's some crazy (read, it really confused me) shorthand there for putting the type in the middle of the function definition. :)
20:45:16 <Mortchek> Assuming you wanted to make it a zip tree I mean
20:45:38 <Mortchek> Oh, sorry, didn't mean for that to be proper Haskell syntax
20:46:00 <c_wraith> That definition doesn't tie the knot, though! it's inefficient! (Ok, now I'm really off picking nits for no reason)
20:46:14 <Mortchek> Inefficient how?
20:46:34 * Mortchek has had OCaml on the mind lately for class, so has been sort of thinking in a mixture of Haskell and OCaml syntax.
20:46:36 <c_wraith> actually, you leave it vague.  You may have meant the knot-tying version.
20:47:04 <c_wraith> But the difference between pure x = Node x (pure x) (pure x)  and  pure x = let n = Node x n n in n
20:47:08 <hpaste> fsef pasted “last question” at http://hpaste.org/84956
20:47:18 <Guest55152> if you guys are interested, here is the last question of the example, again not looking for the answer
20:47:19 <c_wraith> that actually makes a relatively big difference for efficiency
20:47:30 <Mortchek> Right, I just got what you meant when you said "knot-tying version"
20:48:27 <c_wraith> Guest55152: I actually like that question. Interpreters are good demonstrations of pattern matching.
20:48:40 <Guest55152> cool =)
20:48:43 <Guest55152> I haven't started it yet
20:48:56 <Guest55152> not sure if I will do it or not, worth extra credit
20:50:15 <Guest55152> oh, and second part to it here
20:50:18 <Guest55152> (ii) Extend the deﬁnition of evaluate above to work on this extended type of expression. For
20:50:33 <c_wraith> yeah, I assumed as much
20:50:34 <Guest55152> example: evaluate (Let "n" (C 42) (V "n" :+ C 2))
20:50:43 <Guest55152> reduces to the value 44. I.e. the expression is saying: "let n be 42 in n+2"
20:50:45 <c_wraith> part (i) isn't all that interesting without the part (ii) there. :)
20:50:56 <Guest55152> =D
20:51:33 <Guest55152> anyway, I have to go
20:51:36 <Guest55152> thankyou for the help
20:51:45 <Guest55152> cya, sure I will be back eventually lol
20:51:46 <elliott> I love the ﬁs you get copying from pdfs.
20:52:20 * Mortchek wondered if somehow his font had turned proportional on him.
20:53:06 <c_wraith> I..  don't fully understand why PDFs should result in ligature characters.  Shouldn't rendering the ligature be the font's responsibility?  (I know, I'm far too naive)
20:53:35 <DanZimm> c_wraith example?
20:53:51 <Mortchek> Everything should just be written in Markdown. Problem solved
20:54:23 <c_wraith> elliott's ﬁ character up there. That's a ligature character that should be the problem of a font to draw properly. In fact, I don't even know why it's in unicode.
20:54:35 <DanZimm> pop just googled ligature characters lmao I'm silly dumb (a far dumber dude than just "dumb")
20:55:02 <c_wraith> But I'm too much of a naïve idealist.
20:55:17 <djahandarie> c_wraith, they are in there for compatibility reasons.
20:55:46 <djahandarie> http://www.unicode.org/faq/ligature_digraph.html
20:56:01 <elliott> c_wraith: it might be latex or something that does it
20:56:20 <elliott> c_wraith: it's just ﬁne, really.
20:56:29 <c_wraith> interesting...  "No more will be encoded in any circumstances."
20:56:35 <c_wraith> it seems latex is not just any circumstance!
20:57:20 <elliott> it means no additional codepoints will be added for it
20:57:27 <c_wraith> Oh, it meant "no more will be added to unicode", not "it's an error to put them in unicode output"
20:58:16 <shachaf> @quote FOREIGN
20:58:17 <lambdabot> pumpkin says: we should throw it [CReal] in with Foreign.C.Types to confuse people
20:58:21 <shachaf> @quote FOREIGN.FUNCTION
20:58:21 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
20:58:41 <c_wraith> that would be the most evil thing ever.
21:43:24 <NemesisD> i think i may have painted myself into a corner (with flexible instances), and I think i may need to existentially quantify something
21:44:26 <NemesisD> i've got a: data PaginatedResponse a; i'm selectively definining instances like instance FromJSON (PaginatedResponse SpecificType) where ...
21:45:29 <djahandarie> Anyone know of a red-black tree implementation in Haskell which enforces the asymptotics in its types (essentially)?
21:45:35 <NemesisD> but now i need to define a type sig and what I want to say is foo :: PaginatedResponse typethathasafromjsoninstancewithpaginatedresponse
21:45:40 <NemesisD> possible?
21:47:03 * hackagebot free-game 0.3.2.7 - Create graphical applications for free.  http://hackage.haskell.org/package/free-game-0.3.2.7 (FumiakiKinoshita)
21:47:33 <Saizan> NemesisD: foo :: FromJSON (PaginatedResponse t) => PaginatedResponse t is possible
21:47:50 <Saizan> NemesisD: but that means that the caller of foo gets to decide t
21:48:15 <Saizan> NemesisD: if the body of foo is meant to decide t instead you want an existential wrapper
21:48:37 <NemesisD> Saizan: i don't think i necessarily wanted an existential wrapper, just thought i may need one. i've never actually used one
21:49:54 <sw2wolf> :r (const $ return ())
21:50:00 <sw2wolf> :t (const $ return ())
21:50:01 <lambdabot> Monad m => b -> m ()
21:50:24 <sw2wolf> (const $ return ()) 100
21:50:27 <arkeet> :t return . const ()
21:50:29 <lambdabot> Monad m => a -> m ()
21:50:37 <sw2wolf> > (const $ return ()) 100
21:50:38 <lambdabot>   No instance for (GHC.Show.Show (m0 ()))
21:50:38 <lambdabot>    arising from a use of `M20095762...
21:50:49 <arkeet> @free const
21:50:51 <lambdabot> f . const x = const (f x) . g
21:51:00 <Saizan> NemesisD: it all depends on the role you want for t, as i've described, other than that you need FlexibleContexts
21:53:20 <NemesisD> Saizan: thanks, that works out well. i can actually alias foo now like: fooPaginated :: FromJSON (PaginatedResponse t) => PaginatedResponse a; fooPaginated = fooGeneral; fooGeneral :: FromJSON a => a
21:53:34 <NemesisD> this library is layering really nicely
21:58:17 <shachaf> Cale: Is NumInstances back on purpose?
22:17:16 <nimish> is there a haskell equivalent to sqlalchemy's non ORM bits?
22:17:24 <nimish> like a decent DSL for working with a sql database
22:17:38 <nimish> and type safe querying
22:17:52 <NemesisD> nimish: i heard persistent is good
22:18:06 <NemesisD> i don't know how good it is at mapping to existing schemas though
22:18:12 <sw2wolf> @hoogle Language.Haskell.Interpreter
22:18:13 <lambdabot> package CSPM-Interpreter
22:18:30 <NemesisD> there's also esquelito, but i think that's a bit lower level
22:18:30 <nimish> NemesisD: that's my problem really: I have an existing schema I need to work with
22:18:52 <pharaun> i think i'm going to be playing with esquelito
22:18:56 <nimish> is there a way to reflect a datatype from the schema?
22:19:00 <sw2wolf> @package Language.Haskell.Interpreter
22:19:00 <lambdabot> http://hackage.haskell.org/package/Language.Haskell.Interpreter
22:19:03 <pharaun> my problem with persistent is that it does not really do join/complicated queries
22:19:08 <c_wraith> sw2wolf: that's probably in hint, despite what the @hoogle plugin tells you
22:19:14 <pharaun> esquelito i think is a layer on top of persistent
22:20:05 <c_wraith> @hackage hint
22:20:05 <lambdabot> http://hackage.haskell.org/package/hint
22:20:05 <sw2wolf> c_wraith: it is hard for me to make eval in xmonad.extras work
22:20:49 <napping> nimish: how about HaskellDB?
22:20:50 <NemesisD> it seems like there needs to be an intermediate library between persistent and the drivers
22:21:13 <NemesisD> i'd expect it to have a lot of fancy TH to define a mapping to the database
22:21:16 <napping> If you really want typesafety
22:22:08 <nimish> napping: haskelldb uses its own funky relation algebra thing rather than esquelito's sql like dsl
22:22:17 <nimish> plus the docs are really lacking
22:22:40 <nimish> my main issue i think is getting persistent or whatever to work nicely with my existing schema
22:23:27 <napping> esqueleto?
22:24:01 <nimish> basically a nice way of querying persistent databases
22:24:21 <napping> or esquelito?
22:24:21 <nimish> @hackage esqueleto
22:24:22 <lambdabot> http://hackage.haskell.org/package/esqueleto
22:52:00 <augur> is there any way to make a type inherently depend on a type class?
22:52:01 <augur> like
22:52:11 <augur> say
22:52:22 <augur> type C a => F a = ...
22:52:35 <augur> so that if i have a function   f :: F a -> ...
22:52:59 <augur> i know i can use C's methods on the a's without having to have a C a constraint on f?
22:53:13 <elliott> you can do that with a data type (not type synonym) using the GADTs or ExistentialQuantification extensions
22:53:21 <elliott> it is usually considered better practice not to unless you absolutely have to
22:53:36 <augur> ok
23:00:24 <jozefg> Hello
23:07:05 <sw2wolf> How can i add an instance for (Show (X String)) in ghci ?
23:07:50 <mikeplus64> instance Show (X String) where ...
23:07:59 <mikeplus64> works i think in ghci 7.4+
23:08:22 <mikeplus64> if you're lucky, you might be able to :set -XStandaloneDeriving, and just type "deriving instance Show (X String)"
23:08:25 <mikeplus64> depending on what X is
23:08:42 <jozefg> Hello
23:08:49 <mikeplus64> if you mean X as in the xmonad thing, i doubt you can make a sensical instance for Show (X String)
23:08:51 <sw2wolf> mikeplus64: thx,
23:08:52 <mikeplus64> sw2wolf:
23:09:52 <sw2wolf> just want to print the String in (X String) first
23:12:37 <mikeplus64> sw2wolf: do you mean X from xmonad?
23:12:46 <sw2wolf> yeah
23:13:26 <latro`a> I don't think X String contains a String in the way you think it does
23:14:37 <sw2wolf> XMonad XMonad.Actions.Eval> evalExpression defaultEvalConfig "sqrt 100"
23:14:37 <sw2wolf> <interactive>:4:1:
23:14:37 <sw2wolf>     No instance for (Show (X ()))
23:14:37 <sw2wolf>       arising from a use of `print'
23:14:40 <sw2wolf>     Possible fix: add an instance declaration for (Show (X ()))
23:14:43 <sw2wolf>     In a stmt of an interactive GHCi command: print it
23:14:48 <mikeplus64> sw2wolf: you can't make a sensical Show instance for it, you'll need to use runX or similar to "turn X String into an IO String"
23:15:06 <mikeplus64> like i said, you need to use runX
23:15:09 <shachaf> It's unlikely that you want to use runX yourself.
23:15:10 <mikeplus64> X is like IO
23:15:34 <cmccann> I would expect it to be a monad transformer stack on top of IO, in fact
23:15:41 <mikeplus64> yeah, it is
23:18:08 <sw2wolf> X is so complicated:
23:18:13 <sw2wolf>  :i X
23:18:13 <sw2wolf> newtype X a
23:18:14 <sw2wolf>   = XMonad.Core.X (Control.Monad.Trans.Reader.ReaderT
23:18:14 <sw2wolf>                      XConf (Control.Monad.Trans.State.Lazy.StateT XState IO) a)
23:18:16 <sw2wolf>   	-- Defined in `XMonad.Core'
23:18:19 <sw2wolf> instance Monad X -- Defined in `XMonad.Core'
23:18:24 <sw2wolf> instance Functor X -- Defined in `XMonad.Core'
23:18:28 <sw2wolf> instance Applicative X -- Defined in `XMonad.Core'
23:18:31 <sw2wolf> instance MonadIO X -- Defined in `XMonad.Core'
23:18:31 <sw2wolf> instance MonadState XState X -- Defined in `XMonad.Core'
23:18:34 <sw2wolf> instance MonadReader XConf X -- Defined in `XMonad.Core'
23:18:37 <shachaf> sw2wolf: Please don't paste more than a couple of lines into the channel.
23:18:48 <sw2wolf> sorry !
23:19:07 <mikeplus64> sw2wolf: yes, it might seem a bit scary. its internals aren't really meant to be peeked at
23:21:01 <sw2wolf> then it is hard to run evalExpression defaultEvalConfig "sqrt 100" in GHCi ?
23:21:04 <mikeplus64> sw2wolf: but, ReaderT r m a is analogous to r -> m a, and StateT s m a to s -> m (a, s), so ReaderT XConf (StateT XState IO) a is equivalent to just "XConf -> XState -> IO (a, XState)"
23:22:49 <sw2wolf> yeah
23:23:00 <mikeplus64> sw2wolf: so given a XState and XConf, with runX (:: XConf -> XState -> IO (a, XState)) you can run your thing in ghci
23:23:18 <mikeplus64> i don't know how you can "get" an XState or XConf alone
23:24:51 <sw2wolf> XConf can use the default one, but XState ?
23:25:19 <simpson> sw2wolf: Why do you want a Show instance, specifically? Are you debugging something?
23:25:31 <simpson> Perhaps what you wanted was to lift print or something similar into X.
23:25:37 <mikeplus64> sw2wolf: try something like xmonad defaultXConfig{ startupHook = liftIO . print =<< evalExpression defaultEvalConfig "sqrt 100" }
23:25:39 <sw2wolf> yes, debugging xmonad.extras
23:25:48 <mikeplus64> but that will start all of xmonad
23:27:23 <sw2wolf> i donot want to start another xmonad as i am using xmonad now
23:27:52 <sw2wolf> maybe  i can use dzen to show it ?
23:29:58 <c_wraith> tootooroo: your alternate name has ruined my ability to read "localhost"
23:30:58 <tootooroo> c_wraith: Sorry! Sorry! I actually did not even mean to spam my nick change in channels other than ##programming.
23:31:29 <c_wraith> tootooroo: oh.  It did it weeks ago.  Fortunately, I think it's a better reading of the term anyway :)
23:31:56 <jozefg> has anyone here tried to write behinds for a heavily OOP C++ library? I'm wondering if SWIG -> C FFI is the best way to go
23:33:23 <tootooroo> jozefg: Behinds?
23:33:39 <jozefg> tootooroo: Sorry?
23:33:59 <tootooroo> jozefg: What do you mean by "behinds"?
23:34:15 <tootooroo> jozefg: "has anyone here tried to write *behinds* for a heavily OOP..."
23:34:45 <simpson> tootooroo: Either he got a wrong autocorrect on "bindings," or he meant "butts."
23:35:03 <c_wraith> I'm going with "bindings"
23:35:14 <jozefg> Sorry it would be bindings... thats irritating
23:35:26 <simpson> I would totally write butts for C++. :3
23:35:55 <jozefg> Im inclined to agree :P Thus the haskell wrapper
23:36:15 <jozefg> Plus writing robots in haskell sounds cool
23:42:41 <jozefg> Seems like the only alternative is messing with the raw mangled names.. which seems gross
23:44:46 <c_wraith> You pretty much always need to make a C wrapper to talk to C++ code from haskell.
23:44:53 <tootooroo> jozefg: What about using extern "C"?
23:44:58 <c_wraith> The only question is how to make that C wrapper.
23:46:19 <jozefg> tootooroo: Its a large library.. a bit too large to fix with a couple extern-C's
23:46:47 <jozefg> c_wraith: Yep, seems like Swig is the best choice for that but what do I know
