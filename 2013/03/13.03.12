00:00:35 <luite> use fsnotify (last year gsoc project) to have a cross platform thingie
00:00:36 <joeyh> look at us trying to shove each other's libraries down respective throats ;)
00:00:54 <joeyh> I'd not mind some better git data types than mine, surely
00:00:57 <johnw> joeyh: I'm quite interested in inotify, actually
00:01:32 <johnw> joeyh: have a peek: https://github.com/fpco/gitlib/blob/cleanup/gitlib/Git.hs
00:01:35 <joeyh> I'm not sure if fsnotify does recursive trees. (Which inotify makes hard and kqueue stupidly annoying) I need to look at it again.
00:01:42 <luite> joeyh: it does
00:01:57 <luite> and it doesn't use kqueue as a backend
00:02:09 <joeyh> what then?
00:02:26 <luite> fsevents for OS X, freebsd is only supported with polling
00:02:28 <joeyh> that's all the non-OSX bsds have
00:02:31 <joeyh> yugh
00:02:43 <luite> well for those two users ;p
00:02:51 <joeyh> not that I blame them, having written the necessary crud to make kqueue work
00:03:14 <luite> kqueue requires a file descriptor per watched file, doesn't it?
00:03:17 <joeyh> yep
00:03:35 <joeyh> except, you can finnesse it, down to one per directory
00:03:37 <luite> yeah then freebsd deserves to be punished :p
00:03:45 <luite> oh realli
00:03:47 <joeyh> if you keep track of every file you've seen
00:03:54 <joeyh> and don't care about certian types of changes
00:03:59 <luite> ugh...
00:22:13 <QinGW> @hoogle paeserc
00:22:13 <lambdabot> No results found
00:25:01 <tac> insanity check: where clauses are scoped over all pattern branches, right?
00:28:36 <tac> hmm
00:28:39 <tac> I must be going crazy
00:29:12 <supki> no, only current equation
00:29:23 <supki> (if I understand the question correctly)
00:29:33 <tac> yeah
00:29:39 <tac> I don't know why I thought otherwise
00:42:02 <adas> an interrupt from a pin on the raspberry pi makes a call to a certain haskell function which *TOGGLES* the on, off state of another pin on the raspberry pi. But i can't *TOGGLE* cos i can't store the previous *TOGGLE* state..The state monad is not helpful here..
00:42:31 <adas> how may i solve the problem?
00:42:56 <srhb> Why is the state monad not helpful here?
00:43:04 <Kinnison> rather than store, why not read back?
00:43:17 <aleator_> adas: ioref?
00:43:17 * Kinnison heads to work
00:44:07 <adas> Kinnison: can't read, cos the pin is configured as output
00:44:15 <arkeet> adas: can you put some IORef in the function's closure or something?
00:44:31 <adas> srhb: because in the state monad an initial state must be passed in
00:45:03 <arkeet> or (ugly) create a top-level IORef
00:45:04 <adas> arkeet: IORef is a monad? can't i use MVar here or something similar?
00:45:06 <srhb> adas: If you're saying "I can never read what state it's in" you have a problem. :)
00:45:13 <arkeet> adas: IORef is a thing in the IO monad.
00:45:19 <srhb> Yes, you can use MVar instead of IORef if you want.
00:45:24 <arkeet> sure.
00:45:38 <adas> srhb: I thought i already mentioned that i have a problem : )
00:45:52 <srhb> Yes but it doesn't appear to be a Haskell problem.
00:45:55 <adas> srhb: IORef and MVar seem promising.. perhaps i can try that
00:46:25 <sproingie> ioref is not itself a monad, but all the things that deal with iorefs are actions in  IO
00:46:42 <adas> it's never a haskell problem..
00:46:53 <arkeet> how does the code look like? you have some setInterrupt that takes an IO ()?
00:46:59 <arkeet> or similar
00:47:04 <arkeet> interrupt handler
00:47:15 <adas> i can hpaste the code.. uno moment
00:47:24 <arkeet> sure.
00:48:53 <adas> word of warning... code is in a state that won't compile..
00:48:58 <arkeet> :p
00:49:46 <hpaste> adas pasted “interrupt” at http://hpaste.org/83894
00:50:19 <adas> ill explain..
00:50:36 * arkeet looks for HasberryPi
00:51:04 <adas> arkeet: HasberryPi are bindings I wrote for the C wiringPi lib
00:51:11 <arkeet> found it on github.
00:51:11 <arkeet> :p
00:51:17 <adas> good : )
00:51:38 <adas> arkeet: just so you know.. the bindings are experimental
00:51:48 <adas> everythong works except the delay
00:51:49 <adas> donno why
00:51:50 <arkeet> I don't have a pi myself, so I can't use it heh.
00:52:06 <adas> the delay not working is a bug ghc
00:52:17 <arkeet> anyway
00:52:51 <arkeet> something like
00:53:55 <hpaste> arkeet annotated “interrupt” with “interrupt (annotation)” at http://hpaste.org/83894#a83895
00:54:13 <arkeet> hlint has a good suggestion I guess.
00:54:22 <arkeet> oops.
00:54:31 <arkeet> you're also supposed to modify the var too.
00:54:56 <arkeet> writeIORef var (not b) or something
00:55:14 <arkeet> inside the ISR
00:56:45 <adas> is it instaed possible to simply have IORef inside the raise0? i would like to avoid mixing setup functions with the functions that actually do the majority of the work
00:57:08 <arkeet> adas: not if you want to maintain state across multiple calls to the isr
00:58:33 <adas> arkeet: in the annotated code, the value of var is always False even in subsequent calls to raise0..
00:58:43 <adas> so i should use a writeIORef somewhere in there?
00:58:47 <arkeet> yes, I did say afterwards that you need to.
00:58:51 <arkeet> I forgot to put it in.
01:01:11 <no-n> how do I make ghci :set +m by default?
01:01:20 <arkeet> put it in your ghci.conf
01:01:21 <arkeet> in .ghc
01:01:47 <arkeet> just a line  :set +m
01:01:53 <adas> arkeet: thanks for the clarifications. I'll try getting it to work
01:02:08 <arkeet> adas: yw :)
01:02:12 <no-n> thanks
01:19:27 <Shane__> So I've been bashing my head against the wall trying to figure out how to use the ST monad. Could someone take a look at my "new" function in here, and tell me how I can get it to typecheck? https://github.com/ShaneWilton/YADCPUE/blob/master/src/Memory.hs
01:20:39 <c_wraith> Shane__: if you could add the error message in an annotation, it'd *really* help
01:21:22 <Shane__> Oh, sorry about that. Does lambdabot support annotations or something? Or do I just paste it in a gist
01:21:40 <arkeet> just paste it together with the gist.
01:22:05 <c_wraith> throwing it in a comment at the end is the most common
01:22:06 <arkeet> but I see that store takes a Memory, while you're giving it a Vector.
01:22:14 <hpaste> Shabe pasted “Memory.hs” at http://hpaste.org/83896
01:22:18 <arkeet> so far nothing here is specific to ST
01:22:48 <c_wraith> yeah, you just left out the Memory constructor
01:23:01 <BadKitty> shachaf: Don't kill me ♥.
01:23:01 <lambdabot> BadKitty: You have 1 new message. '/msg lambdabot @messages' to read it.
01:23:06 <BadKitty> @messages
01:23:06 <lambdabot> M30W said 2m 11d 22h 45m 54s ago: you have homework to do.
01:23:16 <Shane__> Wow, that's seriousyl the problem? Thanks so much.
01:23:16 <arkeet> except load and store look like they have some type issues too.
01:23:17 <BadKitty> Oh yea, thanks me in the past
01:23:25 <Shane__> Yeah, load and store are wrong, I was just trying to fix new
01:23:26 <arkeet> a >>= ... where a is a Vector?
01:23:31 <arkeet> :p
01:23:32 <arkeet> ok
01:23:38 <Shane__> Thanks a ton
01:24:03 <arkeet> Shane__: do you see how the type error you get says this?
01:24:41 <Shane__> Not yet, lookng at i now
01:25:56 <arkeet> MV.replicate whatever returns a MVector s0 Word16, for some s. but store is expecting something of type Memory s
01:26:01 <arkeet> or wait.
01:26:19 <Shane__> The type error is on the following line though, so I'm not seeing the connection
01:26:29 * arkeet rereads the error.
01:26:33 <Shane__> I see how the line you corrected is wrong though
01:27:08 <arkeet> right. so on line 28, it's inferring that memory has type Memory s, for some s. but then on line 29 you're passing it to the Memory constructor, which expects a different type.
01:28:01 <Shane__> Ooh, yeah that makes sense. Thanks again
01:28:25 <Shane__> I was spending forever thinking my use of ST in the type signature was wrong :(
01:28:37 <arkeet> nah, that part's right so far. :p
01:54:03 <joeyh> wow, hdevtools is really nice in vim. how did I live w/o this
02:20:33 <johnw> joeyh: it's great in Emacs too :)
02:20:44 <johnw> I really can't imagine developing without it anymore
02:21:00 <johnw> the concept of waiting to find out where your type errors are is becoming foreign...
02:48:47 <killy9999> @djinn Maybe a -> (a -> Maybe b) -> Maybe (a,b)
02:48:47 <lambdabot> f a b =
02:48:47 <lambdabot>     case a of
02:48:47 <lambdabot>     Nothing -> Nothing
02:48:47 <lambdabot>     Just c -> case b c of
02:48:47 <lambdabot>               Nothing -> Nothing
02:48:49 <lambdabot>               Just d -> Just (c, d)
02:48:53 <hseg> I have two functions with signatures [Foo] -> [Bar] and Foo -> State Integer Bar , respectively. I need to lift them into the Reader monad, since a case got added to the second function that needs a read-only environment. Function bodies availalbe upon demand.
02:49:13 <hseg> How do I translate the usage of the State monad?
02:51:06 <hseg> Note for those who will complain that I'm deliberately hiding information regarding my code: it's lengthy and voluminous, and I therefore translate it into a minimal working example.
02:54:44 <Saizan> you can add a ReaderT on top o State there
02:54:52 <rodlogic> johnw: how do you get hdevtools in emacs?
02:56:18 <Hermit> killy9999: I hope you aren't planning to use that code... It's unnecessarily verbose
02:59:30 <hkBst> I want to try FRP and netwire was recommended, but I cannot seem to find any GUI part to netwire... Any help?
02:59:44 <startling> killy9999: \ma fn -> do { a <- ma; b <- fn b; return (a, b); }
02:59:56 <hseg> Do I not have to lift code into the Reader monad? Most of my State code doesn't use state, and consists of definitions starting with "return $"
03:01:19 <startling> hseg, then you can use those in any monad, since return is defined for all monads.
03:02:13 <hseg> Won't just using return place it in Reader instead of ReaderT String (State Integer) ?
03:02:54 <tdammers> return moves its argument one level up the monad stack
03:02:59 <tdammers> :t return
03:03:01 <lambdabot> Monad m => a -> m a
03:03:08 <hpaste> hseg pasted “Original code in State” at http://hpaste.org/83897
03:04:26 <hseg> Right. So just naively changing the signature of translate' to String -> ReaderT String (State Integer) [String] will break the function for the case where the parameter is "Add", for example.
03:06:01 <hseg> Do I not need to lift the return or something?
03:06:18 <Saizan> nono
03:06:26 <Saizan> return works for the whole monad
03:06:56 <Saizan> ?type return :: a -> ReaderT String (State Integer) a
03:06:58 <lambdabot> a -> ReaderT String (State Integer) a
03:07:10 <hseg> OK. So just changing the signature won't break these two cases? Most of my code looks like these two cases.
03:07:37 <adas> is there a way to make a function continue execution from where it returned in the previous call to the function? something like *yield* in python?
03:07:42 <Saizan> hseg: right
03:08:19 <Saizan> hseg: get and modify will work in the transformed monad too because of MonadState
03:09:03 <wuttf> How can I check with parsec of a token matches a predicate? something like  t <- try pred
03:09:06 <hseg> Because instance MonadTrans t => MonadState t State ?
03:09:23 <hseg> wuttf: satisfy
03:09:29 <wuttf> hseg: Ty.
03:09:43 <hseg> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#satisfy
03:10:33 <Philippa> that's what the most primitive parsers in the library do
03:11:13 <wuttf> hseg: Damn I don't work on chars :S
03:11:28 <Philippa> hseg: yep. Also things like token in http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Prim.html
03:11:41 <wuttf> This maybe? http://hackage.haskell.org/packages/archive/MissingH/latest/doc/html/Text-ParserCombinators-Parsec-Utils.html#v:satisfyg
03:12:30 <Philippa> wuttf: yeah, or the ones I'm pointing you at which'll also let you set error messages and the like
03:12:35 <wuttf> Philippa: Thanks I will go with token
03:12:37 <Saizan> hseg: because of instance MonadState s m => MonadState s (ReaderT r m)
03:13:32 <hseg> Fair enough. Luckily for me, the Reader code and the State code don't interact, so I don't need to worry about this.
03:13:46 <adas> say im in the state monad and call another function. I understand that the state is automatically sent to the called function. Now if I change the state in the called function... will the state change be reflected it in the calling function?
03:14:36 <hseg> adas: No. State changes are only preserved across binds
03:15:13 <hseg> i.e. If from f I call g and h, then g and h will get the same state.
03:16:07 <adas> then doesn't that mean the state monad is useless?
03:16:56 <Philippa> I think adas is talking at 'object' level (within the monad's language or at least a do block) and hseg is talking at meta level (raw haskell)
03:17:27 <Philippa> adas: so >>= does the piping behind the scenes in a do block. Do that calling within a do block, in sequence? Yeah, you get what you want
03:17:35 <Kinnison> adas: providing you make the call in a 'do' sense, yes it will
03:17:50 <hseg> No. Suppose you want to pass g's new state to h, then manipulate the results from g and h, what you would do is something like g >>= \(gval, _) -> h >>= \(hval, _) -> return f gval hval
03:18:22 <hseg> Sorry. The no referred to adas 's question from 2m ago, not the more recent comments
03:18:42 <Philippa> hseg: I'd note that you're the one who's introduced "passing" into this conversation
03:18:50 <Philippa> but hey, it's up to adas to tell us what they mean
03:19:12 <hseg> Me? Where?
03:19:25 <adas> im talking about the state monad. say.. from f i call g and modify state in g and then return changed state back to f ... then the new state is available in f .. yes?
03:19:52 <arkeet> adas: sure. it helps to understand how State works.
03:20:44 <arkeet> I guess you could say that's the point of the State monad though.
03:20:48 <Kinnison> adas: If you look at http://cgit.gitano.org.uk/youtube/calculator.git/tree/calculator.hs
03:20:58 <Kinnison> adas: The 'Calculator a' type is a simple State
03:21:01 <arkeet> to be able to nicely compose passing state around.
03:21:16 <Kinnison> adas: And the calculator operates by calling interpretStatement repeatedly, each call modifies state
03:21:26 <Kinnison> adas: is that the sort of thing you're wanting?
03:21:48 <Philippa> adas: {f = do {g; get}; g = put someNewState} will lead to f returning someNewState
03:22:25 <Philippa> > let f = do {g; get}; g = put 42 in runState f 0
03:22:28 <lambdabot>   (42,42)
03:23:35 <adas> i think im a bit confused .. ill go sip some tea
03:23:51 <Philippa> (this is where I make manylots embarrassing errors at once)
03:23:51 <Philippa> hah, like losing my 'net connection :-)
03:24:00 <arkeet> adas: well, think about how you'd pass state along explicitly.
03:24:32 * Kinnison found State a damned sight easier to understand with basic do syntax first, and then later by unsugaring it and reading through
03:24:44 <hseg> If I want to verify that my code is as clean as possible, with nothing GHC can warn about at all, is -Wall sufficient?
03:24:46 <arkeet> a "state-changing function from a to b" is a function a -> s -> (b,s)
03:24:54 <arkeet> where it's given some a, and the old state, and returns some b and a new state.
03:24:56 <Philippa> adas: can you see why my example returns (42,42)?
03:25:01 <Kinnison> hseg: I use hlint
03:25:14 <Philippa> > let f = do {g; (+1) <$> get}; g = put 42 in runState f 0
03:25:16 <lambdabot>  Terminated
03:25:19 <arkeet> maybe you could think of it as (a,s) -> (b,s)
03:25:23 <Kinnison> hseg: or rather, emacs uses hlint on my behalf via ghc-mod :-)
03:25:32 <arkeet> it's clear how to compose these things, and also how to lift pure functions
03:26:10 <arkeet> adas: now we set State s b = s -> (b,s)
03:26:15 <hseg> OK. Also, where can I find the syntax of .cabal files? It was mentioned to me that in non-trivial projects, it is easier to build stuff using cabal.
03:26:24 <arkeet> so that instead of a -> s -> (b,s), we're instead writing a -> State s b
03:26:39 <merijn> hseg: You can auto-generate a default one using "cabal init" and answering the questions
03:26:51 <merijn> hseg: You can pretty much guess the format from that and the manual
03:26:57 <Kinnison> hseg: When I was learning, I cribbed a few examples from things like pandoc (for an app and lib combo) and then googled around for help.  There is a reasonable set of docs for cabal online too
03:26:58 <arkeet> hseg: you should look at cabal user's guide.
03:27:06 * Kinnison goes to have a teleconf.  Sigh
03:27:23 <hseg> Thanks.
03:27:35 <arkeet> adas: exercise:
03:27:39 <arkeet> given State s a = s -> (a,s),
03:27:48 <adas> Philippa: still trying to understand syntax
03:28:12 <arkeet> write (a -> b) -> (a -> State s b) -- this lets us lift pure functions into state-changing functions that do nothing to the state.
03:28:17 <tufan> Hello, I'm trying to find a pop function for this data type : data Stack = Empty | Element Char Stack deriving Show. I want the function to give the head of the stack. I wrote "pophead :: Stack -> Char pophead Empty = Empty pophead (Element x stack) = x" But it gives this error :"Not in scope: data constructor `Stack' ". What should I do to fix it?
03:28:25 <arkeet> then write (a -> State s b) -> (b -> State s c) -> (a -> State s c) -- this tells us how to compose state actions.
03:28:27 <Philippa> adas: yeah, cramming it into one line didn't help any
03:28:41 <arkeet> adas: turns out that this is exactly what you need for State s to be a monad.
03:28:42 <Philippa> you can remove the {} and insert a new line where ; is and line things up, if that helps?
03:29:02 <Philippa> (I'd pastebin it, but I'm on a mobile connection on a train...)
03:29:23 <Philippa> if someone else wants to, that'd be good: it's pretty much a code translation of adas' original question
03:29:27 <arkeet> well, the actual Monad operations are slightly different, but it's equivalent
03:30:30 <Philippa> arkeet: you really, really don't want to get into a nitpicking contest with me about Monads :-) Nothing wrong with talking in terms of do, and it gives a clearer mapping to the original question
03:30:39 <arkeet> sure
03:30:50 <arkeet> I just think that understanding the State monad is a really good exercise for everyone.
03:32:07 <Philippa> yeah, it's worth actually implementing sometime too, sure
03:33:10 <arkeet> my personal opinion is also that it's best to understand monads through their Kleisli arrows
03:33:11 <arkeet> but who knows
03:33:46 <Philippa> well, I've been teaching them around here for a hell of a long time? Never did get round to writing up my own tutorial, admittedly
03:43:08 <arkeet> @let arrr f = return . f
03:43:14 <lambdabot>  Defined.
03:43:20 <arkeet> @let bind m f = (const m >=> f) ()
03:43:23 <lambdabot>  Defined.
03:43:26 <arkeet> :t arrr
03:43:28 <lambdabot> (Monad m, Functor f) => f a -> f (m a)
03:43:31 <arkeet> ugh.
03:43:36 <bartavelle> I wrote a "TextLike" typeclass for things that can be serialized to Text. I can't say "instance TextLike a => FromJSON a where ...", but what is the reason for this ?
03:43:38 <arkeet> @let arrrr f = return Prelude.. f
03:43:39 <lambdabot>  <local>:8:18:
03:43:39 <lambdabot>      Not in scope: `Prelude..'
03:43:39 <lambdabot>      Perhaps you meant one of t...
03:43:46 <arkeet> @undefine
03:43:56 <arkeet> @let arrr f a = return (f a)
03:43:58 <lambdabot>  Defined.
03:44:01 <arkeet> @let bind m f = (const m >=> f) ()
03:44:03 <lambdabot>  Defined.
03:44:05 <arkeet> @type arrr
03:44:07 <lambdabot> Monad m => (t -> a) -> t -> m a
03:44:10 <arkeet> @type bind
03:44:11 <lambdabot> Monad m => m b -> (b -> m c) -> m c
03:44:22 <arkeet> @type arrr id
03:44:23 <lambdabot> Monad m => a -> m a
03:44:36 <arkeet> so yes, monads can be defined in terms of arrr and >=>
03:44:49 <arkeet> @arrr
03:44:49 <lambdabot> Smartly me lass
03:45:36 <arkeet> and the monad laws are obvious.
03:45:42 <supki> bartavelle: surely with enough extensions you can?
03:45:43 <arkeet> (>=>) is associative, and has identity arrr id
03:45:54 <arkeet> @type arrr ?f . ?g
03:45:56 <lambdabot> (?f::a -> a1, ?g::f a, Monad m, Functor f) => f (m a1)
03:45:58 <arkeet> @type arrr (?f . ?g)
03:45:59 <lambdabot> (?f::a1 -> a, ?g::t -> a1, Monad m) => t -> m a
03:46:30 <arkeet> yeah, one wants those to be equal.
03:46:30 <bartavelle> supki, I didn't think of that. But I wondered why it was forbidden by default ?
03:46:37 <danr> I guess the identity is also fmap id
03:46:37 <arkeet> @type arrr ?f Prelude.. ?g
03:46:39 <lambdabot> (?f::b -> a1, ?g::a -> b, Monad m) => a -> m a1
03:46:44 <bartavelle> also if someone knows the list of extensions that would let me do this ...
03:46:50 <bartavelle> or a starting point
03:47:17 <arkeet> so it follows that arrr f = arrr id . f
03:47:24 <arkeet> @arrr
03:47:24 <lambdabot> Drink up, me 'earties
03:47:28 <danr> bartavelle: what error message do you get? they usually suggest what extensions you need to add
03:47:48 <bartavelle> danr, don't remember, tried that a fews days ago, will check right now
03:48:15 <arkeet> bartavelle: the message will tell you what extension you need. I think it's UndecidableInstances in that case.
03:48:25 <arkeet> but beware:
03:48:36 <arkeet> that instance will overlap with every other FromJSON instance
03:48:50 <bartavelle> yes, but this is ok with me
03:48:57 <bartavelle> because it will be defined only for my own types
03:49:06 <supki> bartavelle: http://stackoverflow.com/questions/3213490/how-do-i-write-if-typeclass-a-then-a-is-also-an-instance-of-b-by-this-definit
03:49:06 <arkeet> well, if you really are, you'll also need OverlappingInstances.
03:49:17 <supki> that's a good ending point
03:49:25 <bartavelle> ah thanks a lot
03:49:51 <arkeet> but this is a scary extension.
03:50:19 <hseg> Question: When using cabal to build a program, how do I specify that the binaries and documentation are to be installed relative to the current directory?
03:50:49 <bartavelle> alternative question
03:51:13 <arkeet> hseg: build it, and then cabal copy --destdir=...
03:51:18 <bartavelle> is there a way to automatically make instances ? I suppose with TH or something
03:51:20 <arkeet> where ... is wherever you want it
03:51:39 <bartavelle> or that Generic thingie which somehow seems related
03:51:44 <arkeet> hseg: note: by build I mean configure/build, not install. also, read the user's gude
03:52:00 <arkeet> er
03:52:06 <arkeet> does copy --destdir do what I think?
03:52:12 <arkeet> (I'll let you investigate.)
03:52:38 <hseg> so cabal configure with defaults, or whatever suits my tastes, then cabal build, then cabal copy --destdir=. ?
03:52:47 <hseg> Is that what you're suggesting?
03:53:00 <arkeet> I think so. I've never tried it.
03:53:14 <supki> actually for FromJSON OverlappingInstances doesn't seems very bad since aeson is already deep into IncoherentInstances
03:53:56 <bartavelle> supki, the stackoverflow thread is extremely informative
03:54:23 <bartavelle> I suppose I will just keep the code as it is, I am now scared of all those extensions
03:55:02 <arkeet> hmm
03:55:09 <arkeet> how did I ever live without hdevtools, I wonder.
04:05:00 <hseg> I have a function f of type String -> ReaderT String (State Integer) String . My equation is a do-block. I also have a function g of type State Integer [String] . What I need is something like: f = do { gval <- g; return $ ["foo"] ++ gval ++ ["bar"]; }
04:05:18 <hseg> But it doesn't typecheck because gval <- g isn't in ReaderT
04:05:22 <hseg> So what do I do?
04:05:42 <hseg> Embed a do-block inside that?
04:06:51 <arkeet> lift g instead of g
04:07:23 <arkeet> hmm
04:07:46 <arkeet> is there any way to specify an associated kind with a class?
04:07:58 <arkeet> :s
04:08:02 <hseg> ?
04:08:07 <arkeet> ?
04:08:26 <arkeet> hseg: where you have "g", write "lift g"
04:08:50 <hseg> Can I use liftM $ g instead? g is a complex expression.
04:09:01 <arkeet> no, that is entirely different.
04:09:03 <arkeet> :t lift
04:09:04 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
04:09:18 <arkeet> here, m = State Integer, and t = ReaderT String
04:09:31 <hseg> Ok, ok. Got it.
04:09:49 <hseg> Much better. Only two errors to fix
04:13:35 <hseg> Does lift satisfy (lift f) . (lift g) == lift (f . g) ?
04:13:43 <hseg> Like map?
04:14:31 <tdammers> :t (lift show) . (lift (+1))
04:14:33 <lambdabot>     Couldn't match kind `* -> *' against `*'
04:14:33 <lambdabot>     Kind incompatibility when matching types:
04:14:33 <lambdabot>       t0 :: (* -> *) -> * -> *
04:14:42 <tdammers> :t lift (show . (+1))
04:14:43 <lambdabot> (Num a, Show a, MonadTrans t) => t ((->) a) String
04:14:47 <byorgey> hseg: that does not type check
04:15:06 <byorgey> hseg: lift does satisfy some laws, listed here: http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Class.html#v:lift
04:15:36 <byorgey> in particular  lift (m >>= f) = lift m >>= (lift . f) ,  which is in the same spirit as the law for map that you refer to
04:15:50 <hseg> Makes sense.
04:18:33 <hpaste> hseg pasted “Code transform into ReaderT” at http://hpaste.org/83899
04:37:54 <hseg> Please? can someone help me figure out how to move my code from State to ReaderT String (State Integer) ?
04:38:18 <mauke> you just change the types
04:39:00 <hseg> What?
04:39:43 <hseg> Why would that work?
04:39:49 <mauke> why not?
04:39:53 <mauke> did you try?
04:39:59 <hseg> Yes.
04:40:04 <mauke> what happened?
04:40:06 <hseg> Type error
04:40:14 <mauke> what type error?
04:40:42 <hseg> Couldn't match Reader String HackProgram with a -> c or something like that
04:40:50 <hseg> precise error available on demand
04:40:53 <mauke> and what's the actual error message?
04:41:19 <hpaste> hseg pasted “Error message” at http://hpaste.org/83900
04:41:20 <byorgey> the precise error is ALWAYS in demand.
04:42:00 <hseg> Seriously? Even when there is much unneccessary context?
04:42:08 <byorgey> yes, seriously.
04:42:09 <mauke> what's unnecessary there?
04:42:25 <byorgey> hseg: well, if you have a ReaderT String (State ...)  you will have to call  runReaderT  in addition to  evalState
04:42:44 <hseg> I am running runReader in the caller, not here.
04:42:57 <mauke> runReader is not involved
04:43:04 <byorgey> oh, ok, sorry.
04:43:04 <mauke> you need to call runReaderT
04:43:15 <hseg> runReaderT ?
04:44:34 <hseg> Why? translate is in Reader, not ReaderT .
04:44:50 <hseg> translate :: VMProgram -> Reader String HackProgram
04:45:05 <hseg> translate code = concat . flip evalState 0 . mapM translate' code
04:45:10 <hseg> translate' :: VMInst -> ReaderT String Counter HackProgram
04:48:47 <supki> hseg: well, the error is clear? Result is in form  a -> b  where you said it would be  Reader String HackProgram
04:49:00 <supki> not sure what are you trying to do though
04:51:00 <hseg> Basically, I get a VMProgram = [VMInst]. I then map it through translate', which generates a HackProgram = [HackInst] for each VMInst, dependent on RO context and global state. Then, I give it an initial state, and concatenate all the HackPrograms. In the caller, I get the RO context.
04:54:20 <adas> how advisable is unsafePerformIO?
04:54:34 <arkeet> avoid it if you can
04:55:04 <adas>  i used it with the Pi and the interrupts work half the time and half the time the interrupts don't occur
04:55:14 <ion> If you have to ask, the answer is “don’t”. :-P
04:55:31 <arkeet> there's a reason it's called unsafe.
04:56:26 <arkeet> "don't use it unless you really know what you're doing. don't use it even if you think you really know what you're doing."
04:56:50 <adas> who said that?
04:56:54 <arkeet> "I have no idea why I put that in quote marks."
04:57:12 <ion> “This sentence is worth quoting.” –me, right now
04:57:50 <typoclass> “This sentence is worth quoting.” –“me”, right now
05:02:52 <wuttf> I am using parsec, is there anything like  Parser a -> Parser b
05:03:01 <wuttf> Can't find it in hayoo
05:04:17 <donri> wuttf: uh, what'd that do?
05:05:09 <wuttf> donri: Never mind I think I am just being retarded, I will just simply transform the parsed result
05:05:55 <donri> wuttf: you should be able to fmap on a parser
05:06:28 <donri> fmap :: (a -> b) -> Parser a -> Parser b
05:07:01 <wuttf> donri: Ty
05:07:35 <wuttf> donri: Yeah that's what I wanted, I just gave a wrong signature :S
05:07:36 <hseg> Damn. This type error is driving me insane. Not good.
05:07:51 <donri> :)
05:09:12 <hseg> Wait. I have code that uses f :: String -> State Integer String and removes the state part (i.e. it executes runState). So if I put that code in ReaderT, do I then get a Reader a or a ReaderT a Identity ?
05:11:01 <twomashi> anyone know why `seq` is a binary function? seems like usually you'd want it to evaluate and return a single input
05:11:27 <donri> hseg: neither, you need a monad for ReaderT
05:11:43 <mauke> twomashi: how would that work?
05:12:24 <twomashi> well in seq a b, b is returned independently of a
05:12:25 <donri> twomashi: but then you'd need to evaluate the seq
05:12:38 <mauke> twomashi: no, it's returned dependently
05:12:42 <mauke> that's the whole point of seq
05:12:54 <twomashi> I missed the whole point of seq then, hah..
05:13:02 <mauke> there is no "now"
05:13:06 <twomashi> thought it forced evaluation of a and returned b
05:13:10 <amyers> twomashi: This always confuses me too
05:13:13 <mauke> seq ties the evaluation of one expression to another
05:13:41 <amyers> mauke: So seq doesn't evaluate a until b is evaluated at some later time?
05:13:42 <twomashi> ah mauke: right, i read it creates an artificial dependency
05:13:42 <donri> if it was just 'seq a', the seq itself would be but in a thunk that would evaluate at the same time as just an 'a' would
05:13:43 <mauke> when 'seq a b' is evaluated, it will evaluate b and a (but only return the result of b)
05:13:59 <hseg> Right. But I have code like this:
05:14:01 <hpaste> hseg pasted “Code transform” at http://hpaste.org/83901
05:14:18 <mauke> amyers: how could it evaluate a before its own result is needed?
05:14:23 <mauke> it doesn't even run earlier
05:14:36 <donri> hseg: you might want RWST for that
05:15:17 <amyers> mauke: Makes sense now, I've never heard it explained this way
05:15:44 <hseg> No, no. I have two pieces of state that I'm using in my internal function: one that is read-write, and the other which is read-only. Only the read-only state is exposed to the caller
05:15:52 <donri> hseg: also wat, your runState is recursive?
05:17:23 <donri> hseg: concat $ runState (runReaderT f' env) 0
05:17:25 <hseg> ? No. I have three functions: translate, translate', and ifExpr. ifExpr consumes a RW state that is initialized in translate and threaded through translate'. translate threads RO state that translate' consumes
05:17:37 <donri> or evalState
05:18:07 <hseg> But in g' I don't have the environment yet.
05:18:12 <supki> @ty \g -> concat . evalState g 0
05:18:13 <lambdabot> (Functor f, Num s) => State s (f [[a]]) -> f [a]
05:18:26 <supki> oh
05:18:48 <donri> :t let g = concat . evalState g 0 in g
05:18:49 <lambdabot>     Couldn't match expected type `StateT s0 Identity [[a0]]'
05:18:49 <lambdabot>                 with actual type `[a0]'
05:18:49 <lambdabot>     Expected type: State s0 (StateT s0 Identity [[a0]])
05:19:20 <supki> I guess second g is f
05:19:33 <donri> oh
05:20:46 <donri> hseg: well you can't evaluate a reader computation without the environment, that's nonsensical
05:22:15 <supki> actually no, even with  f  that does not make sense
05:23:01 <donri> :t concat . evalState ?f 0
05:23:02 <lambdabot> (?f::State s (f [[a]]), Functor f, Num s) => f [a]
05:23:08 <donri> :t concat . evalState ?f $ 0
05:23:09 <lambdabot> (?f::State s [[a]], Num s) => [a]
05:23:15 <hseg> Right. What I'm trying to do is the following: Main calls runReader on translate. translate calls evalState on translate', passing it the Reader environment that it got. translate' consumes the Reader environment and passes on the State to ifExpr. ifExpr consumes the State.
05:23:24 <donri> hseg: may need a $ there
05:24:17 <donri> hseg: also maybe you want to invert your monad stack
05:24:51 <hseg> Can't invert it. Calling semantics require this stack.
05:25:12 <donri> no, i think the exact opposite?
05:25:55 <donri> if translate is to evalState before main runReader, State needs to be the outer monad
05:27:23 <hpaste> hseg pasted “Code sketch” at http://hpaste.org/83902
05:29:13 <mauke> ok, so StateT X (Reader Y) Z
05:29:18 <donri> translate' :: StateT Integer (Reader String) [String]
05:30:04 <hpaste> donri annotated “Code sketch” with “types” at http://hpaste.org/83902#a83903
05:32:28 <hseg> OK. Trying it out. Need to see whether some things need to be changed.
05:33:08 <adas> i tried using lift to do an IO inside a state monad but I get not found error?
05:33:44 <donri> adas: import Control.Monad.Trans
05:33:45 <hseg> Question: I don't need to do weird stuff to get the state of Reader from the StateT, right?
05:33:50 <donri> @hoogle lift
05:33:51 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
05:33:51 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
05:33:51 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
05:33:58 <donri> pft.
05:34:01 <adas> oh.. thanks
05:36:40 <donri> hseg: don't follow
05:37:18 <Kinnison> adas: If you are doing IO and you know your monad is a MonadIO instance, then you can use one liftIO to lift the IO up all the way
05:37:48 <hseg> As in, in functions within StateT Integer (Reader String), I can run ask without jumping through hoops, in the same way as I can do it in a function within Reader String
05:39:06 <donri> hseg: if you're using mtl that should work. with transformers you need "lift ask"
05:39:12 <Kinnison> indeed
05:39:15 * Kinnison recommends mtl
05:39:18 <hseg> Ok.
05:39:28 <Kinnison> hseg: There's a MonadReader instance for the State stuff IIRC
05:39:48 <hseg> How do I make sure I'm using mtl and not transformers
05:40:08 <donri> hseg: import Control.Monad.Reader
05:40:24 <arkeet> Control.Monad.Trans.State is transformers. Control.Monad.State is mtl
05:40:26 <hseg> OK. That's what I was doing anyway.
05:40:36 <arkeet> or Reader
05:40:58 <hpaste> “Anonymous Coward” annotated “Code sketch” with “types (annotation)” at http://hpaste.org/83902#a83904
05:46:25 <feliperosa> Hi :). I'm having some trouble working with parallel haskell. I'm getting a productivity o f 16.7%, GC is taking much of the execution time.
05:47:13 <feliperosa> ps: that using parList
05:50:03 <amyers> feliperosa: What evaluation Strategy?
05:50:43 <amyers> rseq, rdeepseq?
05:50:47 <feliperosa> rseq
05:50:47 <amyers> etc.
05:50:56 <amyers> Have you tried rdeepseq?
05:51:27 <feliperosa> ps: that using parList
05:51:28 <feliperosa> ops
05:51:36 <amyers> Maybe rseq is not fully evaluating the argument
05:51:51 <amyers> Then the main thread gets a thunk back which still needs significant work to be fully evaulated
05:52:07 <amyers> That tripped me up the first time I tried to use parallel Haskell.
05:52:55 <hseg> Apparently my internet dropped.
05:53:26 <hseg> How do I convert a State Integer [String] to a StateT Integer (Reader String) [String]
05:53:29 <hseg> ?
05:53:56 <mauke> @unmtl State Integer [String]
05:53:57 <lambdabot> Integer -> ([String], Integer)
05:53:59 <feliperosa> amyers: Nope, still does a lot of garbage collection
05:54:03 <mauke> @unmtl StateT Integer (Reader String) [String]
05:54:03 <lambdabot> Integer -> String -> ([String], Integer)
05:54:24 <feliperosa> amyers: The list has a lot of elements, is that a problem?
05:54:49 <amyers> Shouldn't be in and of itself
05:54:53 <hseg> I have the feeling the solution involves return in some fashion.
05:55:35 <quicksilver> hseg: you can use 'state' to run a simple state action in any MonadState.
05:55:48 <quicksilver> and fortunately you StateT construction is a MonadState
05:55:48 <mauke> :t state
05:55:50 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
05:55:56 <quicksilver> :t runState
05:55:57 <lambdabot> State s a -> s -> (a, s)
05:56:03 <mauke> :t \m -> state (\n s -> runState m n)
05:56:04 <lambdabot>     The lambda expression `\ n s -> runState m n' has two arguments,
05:56:04 <lambdabot>     but its type `s0 -> (a0, s0)' has only one
05:56:04 <lambdabot>     In the first argument of `state', namely `(\ n s -> runState m n)'
05:56:15 <quicksilver> :t state . runState
05:56:17 <lambdabot> MonadState s m => State s a -> m a
05:56:36 <hseg> Can't find documentation for state
05:57:08 <mauke> http://www.haskell.org/hoogle/?q=state
05:57:11 <mauke> do you even lift
05:58:10 <hseg> ? Also, IIRC, that's in transformers, not mtl
05:59:17 * juhp wonders if Agda can be persuaded to build with newer hashable
05:59:28 <feliperosa> amyers: Oh, parList with rdeepseq runs in the same time as the sequential algorithm (productivity 14.3%). Using parListChunk gives me a slow down of about 3x.
05:59:28 <juhp> maybe someone tried?
05:59:46 <hseg> WTF? Couldn't match expected type `s0 -> (a0, s0)'             with actual type `State Integer HackProgram'
05:59:49 <mauke> hseg: http://mauke.hopto.org/tmp/screenshot.png
06:00:49 <amyers> feliperosa:  Have/Can you run generate an eventlog for threadscope
06:00:52 <amyers> as here: http://www.haskell.org/haskellwiki/ThreadScope
06:00:58 <amyers> ?
06:01:05 <hseg> Oh. I was looking at an old version of mtl
06:01:24 <feliperosa> amyers: No, I was using the -s rtsopt
06:01:58 <hseg> OK. I'm getting the following: Couldn't match expected type `s0 -> (a0, s0)'             with actual type `State Integer HackProgram'
06:02:09 <hseg> Quite odd, considering that
06:02:13 <mauke> did you forget the runState part?
06:02:21 <hseg> @unmtl State Integer String
06:02:21 <lambdabot> Integer -> (String, Integer)
06:02:27 <hseg> runState?
06:02:40 <mauke> <quicksilver> :t state . runState
06:02:41 <hseg> I execute runState in this function's caller
06:04:30 <amyers> feliperosa: Using threadscope would be my next step
06:04:51 <hseg> Odd. Why does that work, as opposed to just applying it to state?
06:04:53 <amyers> feliperosa: That will tell you if your sparks from parList are actually doing anything or not
06:05:08 <mauke> because state takes a function
06:05:10 <amyers> feliperosa: Actually, Do you see sparks being reaped?
06:05:20 <mauke> State Integer HackProgram is not a function
06:05:52 <feliperosa> amyers: what do you mean by reaped?
06:06:25 <amyers> feliperosa: err, looks like the -s rtsopts has converted/pruned
06:06:34 <amyers> pruned sparks did not do any work in parallel
06:06:39 <amyers> converted sparks did
06:07:03 <amyers> feliperosa: Do you see a like like this when you run with -s?
06:07:10 <amyers> feliperosa: SPARKS: 359207 (557 converted, 149591 pruned)
06:07:22 <feliperosa> amyers: Oh, right. All of them were converted. One thing is that I didn't see but rdeepseq with parList gives me a stackoverflow.
06:07:39 <feliperosa> amyers: Using parList with rseq makes all the get converted.
06:08:00 <amyers> feliperosa: That's odd
06:08:41 <hseg> Ah. That makes sense.
06:09:09 <feliperosa> amyers: Maybe it's too fine grained?
06:10:59 * hackagebot wai-extra 1.3.3 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.3 (MichaelSnoyman)
06:11:05 <amyers> feliperosa: Are you using the results of parList rseq anywhere?  i.e. are they ever fully evaluated?
06:13:19 <amyers> feliperosa: It might still be a good idea to use threadscope
06:13:36 <amyers> feliperosa: To see how much parallel work those converted sparks are actually doing
06:13:36 <feliperosa> amyers: I think so, actually the algorithm uses dynamic programming. I didn't think it would be a problem, I'll try simplifying it. (I'm using threadscope now)
06:14:33 <qraly_> hi. I know this isn't the right place for this question, but it can't be that wrong considering the number of smart people:)
06:14:43 <qraly_> I was learning about SAT solvers and how many other difficult problems are translated to SAT, but I don't get how that is feasible.. I know that SAT solvers are really fast but assuming we are translating a planning or scheduling problem we must translate the whole domain. Traverse the whole space and create a clause in CNF for every move. Isn't this then twice the work?
06:15:58 <`ramses> qraly_: it's not because it's possible in theory that it's also feasible in practice
06:15:58 <feliperosa> amyers: So, in threadscope activity should have much of that green graphics right?
06:17:03 <`ramses> qraly_: the conversion can be done in polynomial time, but the constant factors and exponents can be quite large
06:18:16 <adas> i think it is impossible to use haskell for low level hardware
06:18:35 <adas> state monad does not help
06:18:56 <amyers> feliperosa: Yeah, in the top line that's labeled activity you want to see green as high as possible
06:18:59 <adas> im afraid the language has some deficiency after all
06:19:30 <amyers> feliperosa: Each dotted line is one core so if the green is under the first dotted line you're not really achieving any parallelism
06:19:52 <adas> well.. i wasn't trolling. either way im gonna see how to fix it
06:20:12 <amyers> feliperosa: Then each HEC line is a "Haskell Execution Context" the number of which you set with the -N RTS option
06:20:32 <kqr1> is there any particular reason Data.Yaml doesn't like yaml files with more relaxed syntax, such as excluding single quotes around keys and values?
06:20:35 <amyers> feliperosa: So if you run with -N 4 you should see 4 HEC lines and 4 dotted lines in the activity line
06:20:54 <amyers> feliperosa: Mispoke at first, the activity line is one dotted line per HEC, not per core
06:22:01 <feliperosa> amyers: Wow, I think it's pretty bad then. Is there anywhere I can show you the threadscope graphs?
06:22:44 <kqr1> never mind, i had a syntax error without realising it
06:23:02 <feliperosa> amyers: If it's not so much work hehe. Don't want to bother you much.
06:25:34 <kurkale6ka> Hi, is dispatch a variable or a function: http://bpaste.net/show/83191/
06:25:59 * hackagebot wai-extra 1.3.3.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.3.1 (MichaelSnoyman)
06:26:53 <`ramses> kurkale6ka: a constant, I'd say
06:27:37 <kurkale6ka> `ramses: a constant function?
06:28:17 <arkeet> it's a value.
06:28:45 <wuttf> Is there any way to tell Parsec.Expr.buildExpressionParser to apply a default operator between adjacent terms?
06:29:25 <`ramses> kurkale6ka: not a function in the strict sense as it doesn't map values to values. It has no (->) in it's type
06:29:40 <amyers> feliperosa: I forget, does threadscope allow exporting as an image?  You could put it on imgur then
06:29:53 <kurkale6ka> `ramses: all right, thx
06:29:58 <amyers> feliperosa: Or maybe put the eventlog file on hpaste, is it very big?
06:33:41 <feliperosa> amyers: It can export as image.
06:34:04 <feliperosa> amyers: http://imgur.com/LELqY8k
06:41:50 <Ericson2314> I am trying to make a windows build of my haskell program and i am getting two weird linking errors  I can't find an information about
06:41:55 <hpaste> “Link Errors” pasted “Ericson2314” at http://hpaste.org/83909
06:43:17 <turiya> hi
06:44:04 <armlesshobo> anyone here use NetBSD?
06:44:08 <malthe> this isn't very elegant: https://github.com/chrisdone/pgsql-simple/blob/master/Database/PostgreSQL/Simple/QueryParams.hs
06:44:14 <turiya> tail recursion does not seem to give any speed up to my code.. is it important at all?
06:45:26 <geekosaur> it's not especially relevant because of "laziness" (that is, data-driven evaluation order)
06:45:44 <hkBst> how to use netwire for GUI programming?
06:46:44 <turiya> is it possible to enforce strictness on functions
06:46:45 <johnw> hkBst: I think your question may be a bit too general
06:47:28 <turiya> geekosaur: ok.. i have been reading a blog that says it makes a difference but when i implement it i observe no difference
06:47:29 <geekosaur> tail recursion is an optimization for imperative programming, where you need to tell the compiler exactly what to execute and when. haskell generally can recognize that it can fuse away an entire sequence, rather than needing you to do it manually with tail recursion
06:47:34 <hkBst> johnw: I ask because I can't find anything GUI-related in the netwire documentation
06:48:09 <amyers> feliperosa: Yeah, that's not much parallelism :p
06:48:32 <feliperosa> amyers: Yeah, I'm trying to change some GC settings.
06:48:39 <amyers> feliperosa: My guess is, rseq doesn't evaluate sufficiently deep
06:48:46 <Ericson2314> anybody have any idea what to do about my linking errors?
06:48:55 <amyers> feliperosa: rdeepseq does, but there's something else going on causing a stackoverflow
06:49:06 <feliperosa> amyers: I'll try that too.
06:49:08 <amyers> feliperosa: That's not normally evaluated
06:49:12 <amyers> fully
06:49:18 <turiya> geekosaur: ok, i see, thanks
06:49:40 <hpaste> adas revised “interrupt”: “back to state from unsafePerformIO” at http://hpaste.org/83894
06:49:43 <johnw> hkBst: I think you may want to step back, and read some tutorials on how functional-reactive programming in general can be used to write GUIs in Haskell
06:49:47 <geekosaur> (basicaly haskell is already primed to recognize recursion as looping, whereas imperative languages are not and need hints like tail calls)
06:49:50 <amyers> feliperosa: Maybe building up huge thunks with foldl or something
06:49:53 <adas> can someone tell me how to proceed from here? ^^^ or if that even makes sense?
06:49:54 <johnw> after that, the Netwire documentation should make a lot more sense to you
06:50:57 <turiya> is there anyway to tell haskell to compile a particular module strictly?
06:50:57 <johnw> amyers: rseq only evaluates to WHNF
06:51:13 <johnw> turiya: what do you mean?  make the arguments to all functions strict?
06:51:23 <johnw> you could stick bang patterns on all the arguments to every function in that module
06:52:40 <hkBst> johnw: should I interpret your answer to mean that I have to do my own toolkit bindings?
06:53:51 <johnw> hkBst: I have not yet done what you want to do, but my guess is that you would use netwire on top of another library, like gtk2hs
06:54:06 <johnw> netwire simply provides the FRP framework, it doesn't actually make widgets and such
06:55:20 <frerich2> Hm, thanks to whoever mentioned hdevtools earlier; I never heard of that before, but it seems really nice!
06:55:35 <johnw> hdevtools is *fantastic*
06:55:38 <johnw> don't leave home without it
06:56:16 <Kinnison> joeyh mentioned hdevtools to me earlier
06:56:35 <johnw> if anyone is an Emacs user, I use hdevtools with flycheck
06:56:46 <johnw> even highlights the column of each error
06:57:21 * Kinnison uses ghc-mod for emacs
06:57:22 <turiya> is there anyway to enforce strictness always in haskell when one finds laziness is not much of a use
06:58:02 <johnw> Kinnison: flycheck+hdevtools is vastly quicker, and a bit more functional (due to the column-based highlighting)
06:58:13 <srhb> turiya: Aside from sprinkling ! everywhere, I doubt it.
06:58:30 <Kinnison> johnw: I find the red/yellow underlines which ghc-mod produces to be quite acceptable, and I'm very happy that it only does it when I stop typing for a bit
06:58:39 <Kinnison> johnw: but I'll try hdevtools when they hit Debian
06:58:47 <srhb> I'm waiting for an actual Emacs package.
06:58:52 <srhb> But then I'lll definitely give it a shot.
06:59:03 <BadKitty> For a network protocol. How would one send/recieve payloads via a payload length first? send a word32 or something first then get 4 bytes?
06:59:08 <Kinnison> In the meantime, ghc-mod is grand
06:59:13 <turiya> srhb: ok ..
06:59:43 * frerich2 wonders whether there's something like hdevtools for C++...
07:00:22 <arkeet> Kinnison: why wait? :p
07:00:40 <turiya> also i assume that one cannot force strictness on a function as the domain can be infinite.. is this true?
07:01:21 <srhb> turiya: If you have a function that deals with infinite lists, forcing the spine of the list will cause you to burn CPU cycles for a long time and then crash.
07:01:25 <johnw> turiya: do you mean, enforce that the function is total?
07:02:14 <aCube> Are there any different use cases for Env and Reader? isn't it the same? I can do: runEnv $ env 3 3 =>> (+3) . ask     or  runReader (ask >>= return . (+3)) 3
07:02:21 <turiya> i mean a simple function f :: Int -> Int, what does !f mean..
07:02:38 <johnw> aCube: I believe they are indeed isomorphic
07:03:05 <johnw> turiya: !f has no meaning there in Haskell
07:03:28 <aCube> Btw, is there any comonad do syntax?
07:03:45 <johnw> turiya: my intuition tells me that you are seeking something that Agda can do
07:03:59 <johnw> aCube: it has been proposed, but there is no co-do syntax in GHC
07:04:01 <geekosaur> johnw, it does, in the right context
07:04:09 <turiya> johnw: oh, thanks . does it mean that it is better to use arrays in the place of functions (like the above) as one can enforce strictness on arrays
07:04:23 <geekosaur> but the f would not bedirectly related to a top level binding named f
07:04:25 <srhb> You can force lists too.
07:06:34 <turiya> geekosaur: g (!f ) = ... does "evaluate" f before proceeding?
07:08:52 * BadKitty wonders what he is doing wrong :|
07:09:04 <`ramses> turiya: what are you actually trying to do? What would you expect to happen when f is forced? What would it mean to "evaluate" a function?
07:09:52 <hpaste> adas pasted “right stateT monad” at http://hpaste.org/83913
07:09:58 <adas> can someone please take a look at that ^^^^?
07:10:20 <adas> i think im getting closer to the solutin.. but not sure if im corect..
07:10:22 <geekosaur> turiya, it does not declare that any application of f would be evaluated strictly; it would attempt to evaluate f itself as part of the pattern match. what exactly does that mean?
07:10:24 <turiya> `ramses: i have been reading that haskell does not evaluate until needed and maintain thunks everywhere, what i mean when f is evaluated is haskell gets rid of these thunks and gets the value..
07:11:09 <Philippa-> turiya: sort of. You get rid of the term that was evaluated, in favour of the value
07:11:21 <Philippa-> the thunk tells you which of the two you're holding
07:11:28 <`ramses> turiya: then you need to force the thunk created by f, not f itself. btw, when you really don't want laziness, maybe haskell is not the right tool for the task at hand
07:11:59 <Philippa-> `ramses: plenty of people using Haskell as an effect-typed ML, though
07:12:21 <johnw> Kinnison: a screenshot of hdevtools in Emacs: http://ftp.newartisans.com/pub/hdevtools.png
07:12:26 <adas> anyone?
07:13:06 <johnw> adas: can you give more context?
07:13:12 <turiya> `ramses: hmm.. i can program much easily in Haskell when compared to C, but laziness makes my programs slow
07:13:26 <johnw> adas: also, if you have multiple lift statement, can you use a "lift $ do ..." to join them up
07:13:31 <`ramses> Philippa-: sure, but it wont be straightforward I assume
07:13:47 <geekosaur> *if* tht's true, then you probably need selective control over strictness, not a strict dialect of haskell
07:14:27 <Philippa-> `ramses: it's exactly as straightforward as monadic programming and scope delimiters
07:14:33 <ZFox> In an attempt to get a payload length prepended to my payloads.. sendP s p = sendAll s $ (putWord32Host $ B.length p) <> p -- putWord32Host isn't the function that I am after by the looks of things... Anyone have any idea what I need? (4 byte bytestring integer/Word32/4 bytes)
07:14:42 <Philippa-> geekosaur: mmm. It's almost as if we don't have that already
07:14:57 <adas> johnw: basically this is what the code does. when pin 7 generates an interrupt it calls a function iofn.. the functions iofn toggles the state of pin 0
07:15:04 <adas> yes .. ill change that sry
07:15:11 <`ramses> Philippa-: ah, is there some strictness monad then?
07:15:29 <johnw> adas: I mean, there is not enough context in your paste to know what the problem could be
07:15:34 <johnw> there are not even any types
07:15:41 <adas> ill add the types..
07:15:49 <Philippa-> `ramses: Strictly speaking it's not a monad, but yes - you seq on >>=
07:16:17 <Philippa-> But I meant more than you can do things like eg make all your datatypes strict and then use monads et al to do your effect typing
07:17:18 <`ramses> Philippa-: okay, that could work :)
07:17:36 <turiya> is there a way to see all the thunks that are generated in a program using ghc?
07:17:59 <turiya> so that i can reason about the performance of my program better
07:19:18 <ZFox> Anyone?
07:20:02 <hpaste> adas pasted “interrupt state” at http://hpaste.org/83914
07:20:06 <adas> i think now is ok ^^^?
07:20:36 <johnw> adas: you need 'lift $ do'
07:20:42 <johnw> but i still don't know what problem you're having
07:21:06 <johnw> also, you want StateT Bool IO ()
07:21:11 <johnw> not StateT Bool (IO ())
07:21:17 <johnw> the latter will not type check
07:21:22 <johnw> it won't even kind check!
07:21:37 <applicative> turiya: the debugger has some capacities that can help
07:21:49 <adas> thanks
07:21:52 <applicative> turiya: or do you know about those?
07:22:16 <ZFox> :|
07:22:50 <turiya> applicative: no .. but thanks i will see how to use that
07:23:38 <applicative> where is the website for the marlow's book on parallel/concurrent haskell
07:24:07 <applicative> oh found it
07:24:08 <adas> johnw: the way it works is once there is an interrupt on pin 7 function iofn gets called. i would just like to know whether subsequent calls to iofn will really be alternate between setting the state to True or False..
07:24:33 <adas> hope im not confusing
07:24:42 <applicative> turiya: http://ofps.oreilly.com/titles/9781449335946/sec_par-eval.html
07:25:02 <applicative> gives some simple demonstrations of :sprint in the debugger
07:25:26 <turiya> applicative: nice, thanks
07:25:29 <applicative> you need to make sure you dont have -XNoMonomorphismRestriction on
07:25:55 <turiya> ok..
07:26:03 <kqr1> what library is recommended for hashing in haskell? i need the hash only as a kind of identifier, so there's nothing cryptographic about the purpose
07:26:15 <johnw> adas: it's the problem I need to know about, but rather the error GHC is giving you that led you here!
07:26:17 <applicative> it impedes sharing so you dont see the changes in the thunks from evaluation
07:27:10 <turiya> ok.. i dont understand what that means but i might get a better idea after reading that chapter
07:27:27 <johnw> kqr1: hashable
07:27:46 <kqr1> johnw, thanks a bunch
07:28:00 <applicative> turiya: there is also http://hackage.haskell.org/package/ghc-vis I havent used it though
07:28:00 <ZFox> Hmm
07:28:33 <ZFox> sendP s p = sendAll s $ (B.length p :: Word32) <> p  --  Okay... Now I've got a Word32 and a ByteString... How am I meant to concat these? O.o
07:29:18 <turiya> applicative: ok, i will surely look at both of those.. thanks much for the help
07:29:27 <hkBst> I would like to see a simple netwire GUI example program, but am not having much luck googling. Anybody know of any?
07:30:46 <johnw> hkBst: http://stackoverflow.com/questions/14787797/full-example-for-netwire
07:32:03 <turiya> applicative++
07:32:28 <johnw> ZFox: http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString-Builder.html
07:32:41 <johnw> you can use a ByteString Builder to turn a Word32 + another ByteString into a ByteString
07:32:43 <hkBst> johnw: I just read that, but it doesn't deliver... :(
07:33:07 <ZFox> "import           Data.Monoid" defined <>  -- .... <> is defined in Data.Monoid
07:34:06 <ZFox> What's the diff with BE/LE/Host???
07:34:16 <johnw> ZFox: I do not know
07:34:23 <johnw> big-endian, little-endian
07:34:27 <johnw> host-determined
07:35:18 <parcs> hkBst: there is none. i doubt it ever has been done. feel free to be the first :P
07:35:21 <ZFox> Yea I know what they expand to but bit confused to what they do
07:35:45 <johnw> ZFox: well, if you are transporting numbers between machine A and B, you need to decide what the endianness of the data will be
07:36:01 * hackagebot hissmetrics 0.5 - Unofficial API bindings to KISSmetrics.  http://hackage.haskell.org/package/hissmetrics-0.5 (FelipeLessa)
07:36:04 <johnw> it doesn't matter really if you pick LE or BE, as long as its consistent, but you probably want to pick the format natural to the machine type you will be using most
07:36:45 <johnw> you don't want Host for network transport; that's for processing integers originated from, and local to, a single machine environment
07:37:03 <johnw> (in which case it's the only sane choice actually)
07:37:29 * ZFox using network transport
07:37:32 <ZFox> :)
07:37:58 <ZFox> Now question... big/little, what diffs? unix/dos ?
07:38:11 <johnw> well, you could put a starter byte in the stream that indicates endianness
07:38:13 <merijn> No, processor design
07:38:16 <johnw> and let the sending platform decide
07:38:27 <merijn> Go look up "On Holy Wars and a Plea for Peace"
07:38:42 <johnw> Intel CPUs are little-endian
07:38:51 <johnw> Motorola CPUs are big-endian, for example
07:38:52 <merijn> https://www.ietf.org/rfc/ien/ien137.txt
07:38:59 <geekosaur> ZFox, x86 and x86-64 are little endian; powerpc and sparc are big-endian. also network byte order is by convention big-endian
07:39:12 <ZFox> So... I just ...
07:39:15 <ZFox> Thanks geekosaur
07:39:19 <johnw> ZFox: http://software.intel.com/en-us/articles/endianness-whitepaper
07:39:19 <ZFox> So big it is
07:40:04 <ZFox> johnw: Any example for using a ByteString Buildter to concat a Word32 with a ByteString? :/
07:40:16 <johnw> sorry, don't have a tasty example
07:40:25 <johnw> @google haskell ByteString Builder concat Word32
07:40:27 <lambdabot> http://hackage.haskell.org/packages/archive/blaze-builder/0.2.0.1/doc/html/Blaze-ByteString-Builder.html
07:40:27 <lambdabot> Title: Blaze.ByteString.Builder
07:40:37 <johnw> heh
07:40:43 <parcs> ZFox: http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/src/Data-ByteString-Builder.html#word32BE
07:40:53 <parcs> or perhaps you want LE
07:40:58 <johnw> parcs: that the link I gave him earlier
07:41:06 <parcs> oh
07:42:50 <parcs> toLazyByteString (bytestring the_bytestring <> word32BE the_word32) -- append a word32 to the end of a bytestring
07:42:59 * ZFox is confused :|
07:43:05 <ZFox> Oh code
07:43:08 <ZFox> yay
07:43:22 <ZFox> parcs: Need the Word32 at the start
07:43:28 <ZFox> But I see the diff :)
07:44:44 <ZFox> Wait .. what?
07:44:53 <ZFox> Looks like that I suggested..
07:46:01 * hackagebot fb 0.14 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.14 (FelipeLessa)
07:47:44 <ZFox> Could not find module `Data.ByteString.Builder' O.o
07:49:53 <ZFox> io locked up :|
07:50:31 <ZFox> Updates :|
07:51:01 * hackagebot yesod-recaptcha 1.1.0.4 - Dead simple support for reCAPTCHA on Yesod applications.  http://hackage.haskell.org/package/yesod-recaptcha-1.1.0.4 (FelipeLessa)
07:51:11 <armlesshobo> > msum [Just 1, Just 2, Just 3]
07:51:12 <lambdabot>   Just 1
07:51:18 <armlesshobo> why does it return Just 1?
07:51:23 <armlesshobo> shouldn't it be Just 6?
07:52:05 <johnw> :t msum
07:52:06 <lambdabot> MonadPlus m => [m a] -> m a
07:52:31 <wuttf> How could I parse the next expression with Parsec.Expr :   "3 3 + 4", where two consecutive ints would mean a multiplication: "3 * 3 + 4"
07:52:37 <sleepynate> armlesshobo: for the maybe monad, msum returns the first non-Nothing item
07:52:41 <wuttf> Any ideas?
07:52:44 <sleepynate> armlesshobo: for a list it returns the sum
07:52:58 <armlesshobo> sleepynate: is there a special reason why it does that for the former?
07:53:35 <johnw> armlesshobo: think about what it means to add two Maybes
07:53:39 <johnw> it's like a logical And
07:54:01 <johnw> if either is Nothing, the answer is nothing; if neither is Nothing, it's the first result (so, not quite like a short-circuiting and)
07:54:10 <sleepynate> > msum [Nothing, Just True, Just False]
07:54:10 <johnw> the fact that your Maybes are Maybe Ints has no bearing on this
07:54:11 <lambdabot>   Just True
07:54:37 <sleepynate> > msum [Nothing, Just EQ, Nothing , Just GT]
07:54:39 <lambdabot>   Just EQ
07:54:40 <armlesshobo> johnw: ahh, i gotcha. had the wrong idea, then.
07:54:45 <johnw> > mplus Nothing (Just 1)
07:54:47 <lambdabot>   Just 1
07:54:52 <johnw> huh, that's not what I understand
07:54:56 <johnw> it's a logical or
07:55:00 <johnw> mappend is the logical and
07:55:17 <johnw> so in effect, msum of a list of Maybes is a monoidal "or" on that list
07:55:27 <`ramses> wuttf: try to parse two numbers, if it succeeds you return an (Mult a b), otherwise, backtrack and try to parse an addition
07:55:31 <johnw> where truth is determined as non-Nothingness
07:55:40 <`ramses> wuttf: "try" as in use the try combinator
07:55:46 <armlesshobo> > liftM (+10) (Just 4)
07:55:47 <lambdabot>   Just 14
07:55:57 <wuttf> `ramses: Going with that, thanks
07:56:01 <armlesshobo> johnw: when i saw that above, it got me thinking about it all wrong.
07:56:01 * hackagebot yesod-fb 0.2.3 - Useful glue functions between the fb library and Yesod.  http://hackage.haskell.org/package/yesod-fb-0.2.3 (FelipeLessa)
07:56:03 * hackagebot yesod-auth-fb 1.4 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.4 (FelipeLessa)
07:56:39 <`ramses> wuttf: if you have a common prefix for two possibilities, you need to backtrack if a parse does not succeed
07:56:42 <johnw> armlesshobo: ah, I see.  Yes, leftM is mapping a function *into* the Monad, while msum is operating *on* the monadic values (without reference to the underlying type)
07:56:45 <armlesshobo> johnw: so then I immediately assumed that msum would behave like a sum for Num
07:56:52 <tippenein> do people ever use virtual environments for projects? or is it not necessary with haskell
07:56:55 <armlesshobo> johnw: right.
07:57:11 <EvilMachine> Hmm… Data.Map seems to miss the function to update a value of an existing key and fail if the key doesn’t exist.
07:57:32 <armlesshobo> tippenein: virtual environments?
07:57:35 <wuttf> `ramses: I know that, thanks.
07:57:45 <tippenein> armlesshobo: like python's virtualenv
07:57:54 <`ramses> tippenein: look at hsenv
07:58:13 <tippenein> ok, thanks. I saw virthualenv, but it looks unmaintained
07:58:14 <`ramses> it's the haskell equivalent for virtualenv, no idea whether it is good
07:58:31 <johnw> > foldl (liftM2 (+)) (Just 0) [Just 1, Just 2, Just 3]
07:58:33 <lambdabot>   Just 6
07:58:42 <ZFox> Hmm
07:58:55 <ZFox> How can you check all packages / libraries for updates??
07:59:00 <johnw> tippenein: it's now called hsenv
07:59:09 <johnw> and hsenv is being maintained (just had a new release a few days ago)
07:59:10 <ZFox> And go and compile all those that are available.
07:59:16 <johnw> ZFox: use the utility "cab"
07:59:17 <ZFox> Prefently without breaking things
07:59:38 <johnw> "cab outdated" will show you what's old
07:59:53 <ZFox> Thanks
07:59:55 * ZFox installs cab
08:00:04 <ZFox> Shakespeare O.o
08:00:48 <hkBst> parcs: does that mean no-one has used netwire for GUI programming?
08:00:52 <armlesshobo> johnw: so foldM doesn't fold on a the wrapped value, but the monadic value
08:01:05 <armlesshobo> you'd have to do what you did above to get the former effect
08:02:04 <ZFox> johnw: What about getting a list of all packages that could use those update? :P
08:02:24 <ZFox> (Or get them all to recursivly recompile due to thier dependencies changing
08:02:25 <johnw> ZFox: this is what I do every day:
08:02:29 <johnw> https://gist.github.com/5143627
08:02:34 <geekosaur> hkBst, no, it means netwire is more general than just GUI programming and you want to look for arrowized FRP resources, not netwire resources
08:04:46 <ZFox> Meh it told me some packages that would break.
08:05:35 <johnw> armlesshobo: to use foldM you'd need:
08:05:38 <johnw> > runIdentity $ foldM ((Identity .) . liftM2 (+)) (Just 0) [Just 1, Just 2, Just 3]
08:05:40 <lambdabot>   Just 6
08:05:48 <ZFox> johnw: Is this cabal saying that it'll become incompatable?
08:05:53 <ZFox> cabal: The following packages are likely to be broken by the reinstalls:
08:06:00 <johnw> foldM just let you deal with the computation in a monad, like applying a print to a list of values
08:06:07 <ZFox> Or safe to --force-reinstalls and reinstall the two packages listed underneith
08:06:15 <hkBst> geekosaur: why if it is more general does it not seem too support the GUI part?
08:06:20 <johnw> ZFox: yes
08:06:30 <mm_freak_> hkBst: netwire is a generic FRP library…  to use it for GUI programming you first have to write a GUI layer around it…  if you want to use something ready-made, you can use reactive-banana, which has a predefined GUI layer
08:06:40 <ZFox> yay
08:06:45 <johnw> ZFox: you want to know what i do?  rm -fr ~/.ghc ~/.cabal/lib/*, and then I reinstall a set of packages that I always want, and then I rebuild my project :)
08:06:49 <mm_freak_> hkBst: netwire's main target is high performance applications like networking, simulations and games
08:06:51 <geekosaur> hkBst, this is not C++, a general package does not mean it has a GUI part and a web part and an audio part and a ... p;art, it means a GUI can use it *as mis*
08:06:56 <geekosaur> "as is"
08:07:01 <ZFox> johnw: Haha nice
08:07:05 <johnw> the script I pasted you before works most of the time, but sometimes it doesn't
08:07:09 <ZFox> johnw: got the computing power I gues?
08:07:13 <ZFox> s/s/ss/
08:07:15 <johnw> it takes 7 mins
08:07:25 <ZFox> So yes
08:07:28 <hpaste> hseg pasted “Backtrace” at http://hpaste.org/83917
08:07:28 <johnw> which is shorter than the time is takes to claw my way out of cabal hell
08:07:38 <ZFox> xD
08:07:39 <srhb> I do much the same. And cabal-dev everywhere.
08:07:47 <johnw> yes, I cabal-dev like an addict
08:07:49 <hseg> Some help in finding out WTF is going on, please?
08:08:06 <johnw> hseg: you are evaluating an undefined value :)
08:08:06 <johnw> next!
08:08:11 <ZFox> Ughh hundred C checks that are slow...
08:08:28 <hseg> It looks like Data.Text is doing the evaluation
08:08:42 <johnw> hseg: no, that was an earlier exception
08:08:47 <johnw> (an exception that was handled)
08:08:50 * ZFox likes the idea of unregistering everything and just rebuilding projects
08:08:53 <ZFox> :)
08:09:04 <srhb> cabal-dev keeps me sane.
08:09:12 <srhb> (Mostly)
08:09:14 <johnw> i'm going to give the new hsenv another try today
08:09:17 <ZFox> What's the diff?
08:09:22 <hseg> ? So what is unhandled
08:09:31 <geekosaur> hkBst, maybe I can find you some library that fits your one-library-one-function way of thinking. I doubt it though as the netwire author thinks like haskell
08:09:36 <johnw> hseg: you will need to use Debug.Trace.trace to track it down, most likely
08:09:41 <ZFox> Oh god, sandboxing :)
08:09:54 <tippenein> johnw: it seems alright from initial inspection ;) thanks
08:10:24 <hseg> Damn. How do I use Debug.Trace.trace in pure functions? AFAICT, it moves the function into IO
08:10:26 <ZFox> Neat
08:10:43 <johnw> hseg: no, that's the whole point of trace
08:10:45 <ZFox> Yay multiple cabals running at once... This can't be too good
08:10:47 <twomashi> thunkBook book = foldl' book [_author book, _title book] — this look like a vaguely correct way to force strict evaluation of a data record?
08:10:51 <johnw> :t trace "Hello" 2
08:10:53 <lambdabot> Not in scope: `trace'
08:10:57 <ZFox> No race conditions yay
08:11:03 <johnw> well, the type of that would be Num a => a
08:11:03 <Philippa-> hseg: it's a compiler hack, it does IO while pretending to be pure
08:11:18 <alpounet> johnw, let's just patiently wait for the next version of Cabal/cabal-install
08:11:21 <hseg> Oookay.
08:11:55 <Philippa-> (see also: unsafePerformIO, which primarily exists to let you declare that something you imported via the FFI is actually pure)
08:12:11 <hseg> Nice.
08:13:05 <hkBst> mm_freak_: why has no-one yet written a GUI layer for netwire?
08:13:19 <johnw> hkBst: be the first!
08:13:33 <mm_freak_> hkBst: i'd be happy to welcome you as the first one to do it =)
08:13:33 <johnw> i'd love to see a well-documented GUI framework built using Netwire :)
08:13:33 <ZFox> Yay/nay to first haha
08:13:45 <`ramses> EvilMachine: seen Data.Map.alter ?
08:13:54 <ZFox> johnw: "see" /= "make"
08:13:55 <ZFox> :P
08:13:59 <armlesshobo> hkBst: be the dev that #haskell needs!
08:14:11 <mm_freak_> i could probably build a GTK/WX layer around netwire some day, but right now i have more interesting applications (to me)
08:14:22 <ZFox> armlesshobo: That's edwardk haha. (HE OWNES HALF OF HACKAGE)
08:14:23 <ZFox> :)
08:16:02 * hackagebot persistent-template 1.1.2.5 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.1.2.5 (FelipeLessa)
08:16:04 * hackagebot esqueleto 1.0.6 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.0.6 (FelipeLessa)
08:16:22 <armlesshobo> ZFox: somebody, quick, send him an email!
08:16:28 * armlesshobo sounds the alarm
08:16:51 <ZFox> armlesshobo: What?
08:17:05 <ZFox> (Used to trolling people and messing around on IRC but a little out atm)
08:17:33 <ZFox> armlesshobo: You seem a little energetic atm
08:17:35 <ZFox> :)
08:17:57 <ZFox> armlesshobo: Join #archlinux-offtopic or #haskell-blah. Either would appreciate the energ!
08:18:26 <EvilMachine> `ramses: Well, that gives the info if it exists to the function inside. But I need the code outside of the call (of “alter”) to know this, so it can return the failure state to calling functions.
08:19:45 <EvilMachine> `ramses: the whole library seems to be built on quiet failure (it just doesn’t change the map, if such a condition is detected), which is a really bad design decision, IMHO. (Unless I miss something big. *hopes*)
08:21:02 * hackagebot yesod-eventsource 1.0.1 - Server-sent events support for Yesod apps.  http://hackage.haskell.org/package/yesod-eventsource-1.0.1 (FelipeLessa)
08:21:02 <EvilMachine> Of course I could use a “lookup” before doing anything. But I feel like that would be slower because of the double traversal.
08:21:04 <`ramses> EvilMachine: yeah, it could have returned an Either..
08:21:10 * ZFox wishes that there were a way to compile ONLY the parts of each module / package /library that is needed in the binaries
08:21:11 <EvilMachine> Exactly.
08:21:20 <ZFox> Would go great for cabal-dev at least :D
08:21:23 <EvilMachine> ZFox: seconded
08:21:34 <`ramses> EvilMachine: add it and send in a patch :)
08:21:38 <EvilMachine> ZFox: and only include that stuff in the final binary.
08:22:01 <EvilMachine> `ramses: I’m far from being confident enough in Haskell, to do this. ;)
08:24:47 <ZFox> Okay... cabal-dev will keep me sane :)
08:26:02 <armlesshobo> i'm probably searching for it wrong, but how do I rebuild all packages in "world" so that i can dynamically link into them
08:26:11 <armlesshobo> i don't want my binary being like 4MB after stripping
08:26:51 * ZFox lets cabal install everything again
08:27:02 <Botje> whee!
08:27:39 <ZFox> Is there a neat way to easily merge a cabal-dev area into the ~/.ghc ?:D
08:27:39 <johnw> hsenv actually seems to be working nicely
08:27:49 <ZFox> Build sandbox'd and deploy up :D
08:27:54 <johnw> and it needs less awareness from other tools
08:28:11 <EvilMachine> armlesshobo: -dynamic?
08:28:29 <kqr1> johnw, how does hashable work? it seems to generate different hashes for the same values each time it is run
08:28:30 <EvilMachine> armlesshobo: I want that too.
08:28:35 <ZFox> Blahh. I'll fix my libraries tomorrow
08:28:46 <ZFox> Good night world. Have a good life all ^_^
08:29:02 <johnw> > hash "Hello"
08:29:02 <EvilMachine> armlesshobo: Here on Gentoo, there’s always that one package that isn’t available in dynamic form. I should ban all non-dynamic ones, and report them as errors.
08:29:03 <lambdabot>   Not in scope: `hash'
08:29:03 <lambdabot>  Perhaps you meant `has' (imported from Control.Lens)
08:29:36 <armlesshobo> EvilMachine: agreed
08:29:55 <armlesshobo> i don't understand that
08:30:56 <EvilMachine> By the way: Why do they all need the whole runtime anyway? It should just fuse everything down to only the parts it needs.
08:31:02 * hackagebot hint 0.3.3.6 - Runtime Haskell interpreter (GHC API wrapper)  http://hackage.haskell.org/package/hint-0.3.3.6 (DanielGorin)
08:31:05 <kqr1> johnw, it's not a big problem, but it would be nice if it could be avoided
08:31:18 <johnw> kqr1: yeah, kind of defeats the whole purpose of hashable if that's true
08:32:56 <kqr1> johnw, http://hpaste.org/83921
08:33:02 <hseg> Found the culprit. Due to a large degree of similarity between parts of my code, I copy-pasted some code. Meaning I forgot to rename a data constructor I was pattern-matching against. D'oh!
08:33:16 <kqr1> johnw, according to the documentation, the contract for hash is that
08:33:18 <kqr1> johnw, This integer need not remain consistent from one execution of an application to another execution of the same application.
08:33:29 <johnw> ah, you are reloading Main.hs
08:33:36 <johnw> what if you hash multiple times without reloading?
08:33:37 <hseg> And unfortunately, my code does *not* display enough similarity to be able to extract this into functions.
08:33:57 <johnw> hseg: congrats on finding it!
08:34:09 <kqr1> johnw, then it works fine
08:34:12 <hseg> Thanks.
08:34:30 <johnw> kqr1: yeah, it probably does this for some reason that tibbe would know :)
08:34:57 <kqr1> johnw, however, i use it to generate file names, and it would be brilliant if it generated the same file names for the same things so that i don't have to blindly rm * before generating a new set of files
08:36:34 <johnw> aha
08:36:40 <quicksilver> kqr1: use a different hash
08:36:46 <quicksilver> there are repeatable ones available :)
08:36:55 <quicksilver> I think that hash cheats in ways which make it faster.
08:37:03 <quicksilver> but repeatability is more important, use a repeatable one
08:37:07 <johnw> i think Crypto is pretty commmon
08:37:12 <johnw> you could use MD5
08:37:21 <kqr1> okay
08:37:30 <johnw> CryptoHash
08:37:45 <johnw> http://hackage.haskell.org/package/cryptohash
08:38:00 <kqr1> i have to run now (literally, i'm going running) but i'll bookmark your link and look into it later. thanks a bunch!
08:41:13 <bartavelle> hash uses a salt
08:41:18 <bartavelle> that is the reason it is not repeatable
08:41:55 <crdueck_> @pl \a b -> (undefined :: b -> c) b $ (undefined :: a -> b) a
08:41:55 <lambdabot> (line 1, column 27):
08:41:55 <lambdabot> unexpected '>'
08:41:55 <lambdabot> expecting operator
08:42:19 <crdueck_> @pl \a b -> ?g b $ ?f a
08:42:20 <lambdabot> (line 1, column 9):
08:42:20 <lambdabot> unexpected "?"
08:42:20 <lambdabot> expecting lambda abstraction or expression
08:42:34 <crdueck_> @pl \a b -> f b $ g a
08:42:34 <lambdabot> flip f . g
08:43:27 <crdueck_> @pl \a b -> f a $ g b
08:43:27 <lambdabot> (. g) . f
08:44:35 <hpaste> “Ertugrul Söylemez” pasted “Modular arithmetic puzzle” at http://hpaste.org/83922
08:46:08 <Baughn> Prelude> 50000 ^ 50000
08:46:08 <Baughn> Bus error: 10
08:46:12 <Baughn> Whut.
08:46:26 <Baughn> > 50000 ^ 50000 -- Well, let's try that
08:46:28 <lambdabot>   316385667153032418592792242669720938976277592416410376450726130210328003694...
08:46:38 <parcs> osx?
08:46:41 <Baughn> Yes
08:46:51 <Baughn> > log (50000 ^ 50000) / log 10
08:46:53 <lambdabot>   Infinity
08:47:07 <geekosaur> Baughn, sadly it's a known bug
08:47:51 <Baughn> > (log 50000 * 50000) / log 10
08:47:53 <lambdabot>   234948.5002168009
08:48:22 <Baughn> geekosaur: Don't suppose you have a number?
08:48:43 <geekosaur> not off the top of my head but people run into it often enough
08:48:50 <geekosaur> I think it's fixed in 7.6+
08:48:58 <Baughn> I can live with that.
08:49:18 <Baughn> ..anyway, I should probably not actually take the 50,000th power.
08:49:48 <geekosaur> srry, not fixed in 7.6 :/
08:49:53 <geekosaur> http://hackage.haskell.org/trac/ghc/ticket/7655
08:49:59 <geekosaur> says it was just reopened under 7.6.2
08:50:27 <geekosaur> "just" - 5 weeks ago?
08:51:41 <quchen> Baughn: It's kind of the purpose of log to avoid large^large after all. :-)
08:51:53 <augur> ski: syn
08:54:40 <Baughn> quchen: Well, yes, but logarithms were supposed to be obsoleted by computers. :P
08:55:01 <Baughn> quchen: In practice it takes me a second to remember the correct transformation.
09:01:03 * hackagebot fb 0.14.1 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.14.1 (FelipeLessa)
09:02:46 <ngw> hi *
09:03:14 <ngw> I just installed haskell-platform on OS X using homebrew but for some reasons backspace doesn't work in ghci
09:04:51 <armlesshobo> johnw: to make sure i got the line of thinking right, msum would sum the list of monadic actions, not the value?
09:06:31 <merijn_> ngw: Your terminal settings are probably wrong
09:06:31 <Baughn> armlesshobo: It will do whatever it's defined as doing in the MonadPlus instance.
09:06:43 <merijn_> ngw: What's the value of $TERM in your environment?
09:07:06 <ngw> merijn_: xterm-256color
09:07:09 <armlesshobo> Baughn: I see. So, the behavior is dependent upon each type.
09:07:15 <johnw> armlesshobo: correct, for whatever "sum" means to that monad
09:07:40 <Baughn> armlesshobo: Yes. That's the deep secret of monads: Almost all of their behaviour is type-specific.
09:07:41 <armlesshobo> the applying msum to a list of IO would be different than Maybe
09:07:47 <merijn_> ngw: Try setting it to xterm-color or even xterm
09:07:52 <Baughn> Yep
09:08:16 <armlesshobo> Baughn: that principle alone makes things a LOT clearer.
09:08:43 <Baughn> armlesshobo: Huh. If you're the sort who finds that helpful, you should read the Typeclassopedia.
09:08:52 <Baughn> http://www.haskell.org/haskellwiki/Typeclassopedia
09:09:39 <armlesshobo> Baughn: :O i wish i found this sooner. thank you!
09:09:40 <arkeet> it's more like a lot of different types have some pattern in common, so the notion of a "monad" is just an abstraction of that pattern.
09:09:54 * Baughn nods. The typeclassopedia takes that approach.
09:10:02 <ngw> ha!
09:10:08 <ngw> merijn_: xterm works
09:10:13 <ngw> merijn_: thanks a lot
09:10:55 <aCube> Does anyone know how I can get flycheck (emacs) to check the file after a given idle time, not just after pressing enter? (This misses the last line)
09:11:34 <Baughn> aCube: All files should end with a newline. :X
09:12:44 <fragamus_> howdy what are adjoint functors
09:14:16 <bgamari> edwardk, I'll admit I didn't try chasing down the semigroups instance
09:14:27 <bgamari> that is very unfortunate
09:14:37 <merijn_> ngw: Terminal.app doesn't really support the newer xterm-256color/xterm-color stuff
09:14:42 <parcs> adjoint functors are functors that have the adjointness property
09:14:56 <bgamari> edwardk, I'm beginning to see why you are so pessimistic about this moving forward
09:15:01 <fragamus_> what is the adjointness property
09:15:12 <arkeet> fragamus_: have you tried looking on google or wikipedia?
09:15:28 <fragamus_> well it was unclear
09:15:34 <arkeet> ok, so let's start there.
09:15:36 <arkeet> what was unclear?
09:16:23 <edwardk> bgamari: yeah
09:16:31 <arkeet> note: as with many things in category theory, the definitions are rather abstract
09:16:36 <edwardk> i figured your assessment was wildly optimistic ;)
09:16:42 <bgamari> edwardk, as usual
09:17:12 <arkeet> so maybe you want some examples of such things to get a handle on them?
09:17:19 <arkeet> or just want to know why anyone cares about them?
09:18:30 <bgamari> edwardk, You agree that just moving ahead with a semantic change without a release dropping the instance is too reckless?
09:19:16 <Baughn> (Can I have Applicative as a superclass of Monad?)
09:20:17 <hiptobecubic> Baughn, as I understand it, the only reason it's not already like that is that no one saw it coming.
09:20:36 <Baughn> Yes, but it *could* be changed. :X
09:20:43 <Baughn> Admittedly that would be hard
09:21:15 <hiptobecubic> there are a few ongoing efforts to rework the prelude and important typeclasses. Take your pick.
09:21:34 <tsinnema> fragamus_, note that there is also a channel ##categorytheory -- it's not always very active but i've gotten some very excellent advice there a couple of times
09:21:57 <Baughn> At some point I'll get back into haskell, and maybe have time for that. RIght now, unfortunately.. :/
09:22:13 <fragamus_> arkeet: I am having a very hard time catching on
09:22:24 <fragamus_> tsinnema: thanks I'll check it out
09:22:46 <arkeet> fragamus: it's kind of hard to answer. kind of like "what are monads?"
09:22:50 <tac> hiptobecubic: other way around. Monad would be a superclass of Applicative
09:23:04 <fragamus_> tsinnema: I simply must get to the bottom of this functional programming mystery
09:23:12 <arkeet> at best you can give a definition, and some examples of such animals, and why they matter/why anyone cares.
09:23:20 <tsinnema> if you get advice on your question either here or there i'd be interested in reading it as well -- a somewhat puzzling subject for me as well
09:23:50 <arkeet> (adjoint functors are closely related to monads...)
09:23:53 <`ramses> tac: ? every monad is an applicative but not vice versa, hence applicative is a super class o monad, isn't it?
09:23:53 <fragamus_> I understand monads from a practical perspective. Also once I worked through the category theory of them on wikipedia
09:23:59 <hiptobecubic> tac, i always forget how the super and sub relate.
09:24:12 <fragamus_> I use monad transformers all the live long day
09:24:20 <hiptobecubic> `ramses, that what I thought.
09:24:22 <hiptobecubic> that's *
09:24:35 <tac> `ramses: errk... maybe?
09:24:54 <tac> yeah monad would be a subclass
09:25:14 <tac> because monads are a subset of applicatives
09:25:15 <twomashi> anyone know of an implementation of a parMapM conduit?
09:25:20 * tac vanishes
09:25:51 <`ramses> tac: phew, it would have been terribly confusing if the super/sub relation was the opposite of what it is in an OO setting
09:27:24 <jeltsch> What version of GHC will be in the Haskell Platform 2013.2.0.0?
09:27:25 <Philippa-> `ramses: it is for algebraic datatypes, FWIW
09:27:40 <Philippa-> (but we don't /have/ that subtyping relationship in Haskell)
09:27:47 <arkeet> jeltsch: probably 7.6.2
09:28:02 <jeltsch> arkeet: Great!
09:28:10 <`ramses> Philippa-: how do you mean?
09:28:19 <donri> twomashi: if it's for IO see parallel-io
09:28:43 <arkeet> even if 7.8 is out by then, it would be too new. they're aiming for may 6 release
09:29:05 <Philippa-> `ramses: more constructors = bigger language = superlanguage
09:30:47 <`ramses> Philippa-: why is a bigger language a superlanguage? That's just a matter of definition, isn't it?
09:31:45 <`ramses> Philippa-: (btw, the combination of the dash and the colon when referencing your nick makes me think of prolog all the time, although it's the other way around)
09:31:53 <ion> http://www.coinheist.com/rubik/a_regular_crossword/ https://github.com/ekmett/ersatz/commit/9e16d70986ad4169160d3e5647dc1c1ca05b49f0
09:32:01 <Philippa-> `ramses: no, you can write Sub -> Super but not (totally) the other way round
09:33:15 <`ramses> Philippa-: sure, the bigger ADT has more inhabitants, but why does that make it the super language? I'm just not too sure of the semantics of the word "super" here
09:35:06 <Philippa-> `ramses: try those of the prefix "sub-", then. I reckon they're that you can write a total function :: Sub -> Super such that all funcs on Super respect a meaningful equivalence across that function that I'm too tired to spec formally right now
09:37:35 <Philippa-> `ramses: that sound like the relationship you expect in OO (except with such calls all managed for you)?
09:39:05 <Philippa-> (but FWIW, "sub-" and "super-" really do effectively mean "smaller [than]" and "bigger [than]")
09:40:28 <`ramses> Philippa-: it does, I'm struggling trying to convert the notion of different constructors for an ADT to an OO context, that's hindering my understanding
09:40:58 <Philippa-> constructors are equivalent to fields
09:41:15 <Philippa-> (and/or methods, depending on how we're defining our OO setting)
09:42:12 <`ramses> Philippa-: then in the OO setting the class with more fields is the subclass, isn't it? As otherwise they would be inherited anyway
09:43:08 <Philippa-> `ramses: right. Thing is, the equivalence is a duality
09:43:21 <Philippa-> specifically, that between sum ("or") types and product ("and") types
09:43:22 <bscarlet> I'm just jumping in here, but in some contexts at least I would have said that different constructors for an ADT were more like different subclasses of a parent class.
09:43:39 <Philippa-> (the former are roughly Haskell's Either, the latter are 2-tuples. Both have n-ary generalisations)
09:43:43 <`ramses> bscarlet: that's the scala approach
09:43:58 <bscarlet> ramses: yes, that's an example.
09:44:41 <`ramses> Philippa-: hah, and the super/sub relation is inverted by the duality then?
09:45:02 <`ramses> that actually makes sense, but I have to think about how they are dual concepts for a bit
09:46:12 <`ramses> bscarlet: that analogy wont work well in this discussion though..
09:46:46 <bscarlet> `ramses: that's what I get for jumping into the middle
09:47:20 <`ramses> Philippa-: so in fact sub and super should be called cosub and sosuper for ADTs then, to comfortable be compared with the sub and super of OO classes
09:47:32 <`ramses> s/sosuper/cosuper
09:48:35 <Philippa-> `ramses: *shrug* the definition of the property doesn't invert
09:50:08 <`ramses> Philippa-: but then for ADTs "sub" doesn't correspond to "smaller [than]"
09:50:55 <Philippa-> `ramses: the *definition* doesn't. The direction it holds in does
09:51:36 <`ramses> Philippa-: I have to give this some thought, I have the feeling I'm mixing things up
09:51:40 <`ramses> Philippa-: thanks for bearing with me ;)
09:52:09 <Philippa-> 'sokay. You might find it helps to stick to set theory rather than category theory for this one for now?
09:52:16 <Philippa-> They're fairly primitive operations on sets
09:53:45 <`ramses> how would you express that duality on sets, then? something with intersections and unions for the "and" and "or"?
09:54:22 <klrr> what happen if you cant finish an exercise, should i cheat or should i give up? (or sth else?)
09:54:50 <srhb> klrr: What exercises? You could ask for hints here.
09:55:00 <klrr> i mean exercises in general
09:55:20 <Philippa-> `ramses: would love to answer. You'd be amazed how a) tired b) out of practice I am at this stuff! Like, I cared about the fiddly details a decade ago when I was first learning this :-)
09:55:29 <klrr> how do you solve them, i suck at problem sovling should i give up programming or can you learn problem solving?
09:56:10 <Chousuke> you can learn anything if you practice enough :P
09:56:16 <merijn_> klrr: Try to split them into smaller subproblems until you hit a problem you can solve
09:56:27 <`ramses> Philippa-: np, I'll try to work it out on my own then, that's probably a better way to learn it then to just keep asking anyway :)
09:57:15 <`ramses> klrr: I don't think a general approach to the problem of "being stuck with an exercise" exists :)
09:57:22 <ab9rf> klrr: at least half of programming _is_ problem solving
09:57:30 <frerich2> klrr: Not sure that's on topic in #haskell.
09:57:53 <ab9rf> `ramses: well, there is a solution to that problem, but it has side effects that are often problematic
09:58:13 <`ramses> ab9rf: depends on what you call a "solution" as well
10:06:33 <marekw2143> hello, does (,) (f) (g) evaluates to:     z x  = (f x, g x)     when      f a = undefined,  g b = undefined ?
10:06:49 <marekw2143> I mean both 'f' and 'g' are functions of one variable
10:07:05 <mauke> z x = (f x, g x) isn't an expression
10:07:53 <marekw2143> mauke: it's function definition, right?
10:08:04 <geekosaur> (,) f g  -->  (f,g)  which is not a function, but a tuple containing (in your case) functions
10:08:34 <`ramses> marekw2143: that would be  (,) <$> f <*> g
10:08:38 <geekosaur> > ((1+),(1-)) 5 -- not a function
10:08:39 <lambdabot>   The function `((1 GHC.Num.+), (1 GHC.Num.-))'
10:08:39 <lambdabot>  is applied to one argument,
10:08:39 <lambdabot> ...
10:09:10 <geekosaur> ok, is this caleskell or is this the ->e instance?
10:09:11 <marekw2143> I'm asking in context of code: http://book.realworldhaskell.org/read/monads.html#monads.state.random
10:09:28 <mauke> geekosaur: no
10:09:34 <marekw2143> there is code: getTwoRandoms = liftM2 (,) getRandom getRandom
10:09:39 <marekw2143> getRandom :: Random a => RandomState a
10:09:39 <marekw2143> getRandom =
10:09:39 <marekw2143>   get >>= \gen ->
10:09:39 <marekw2143>   let (val, gen') = random gen in
10:09:39 <marekw2143>   put gen' >>
10:09:39 <marekw2143>   return val
10:09:59 <augur> marekw2143:
10:10:02 <`ramses> > liftA2 (,) (+1) (+5) $ 6
10:10:03 <lambdabot>   (7,11)
10:10:22 <augur> getRandom = do gen <- get ; let (val,ven') = random gen ; put gen' ; return val
10:10:41 <hpaste> marekw2143 pasted “random” at http://hpaste.org/83926
10:10:55 <`ramses> marekw2143: (liftA2 (,) f g $ x) it applies f and g to x and uses (,) to combine the results into a tuple
10:10:58 <geekosaur> oh, I see. you just ignored the liftM2 there and assumed everything else was the real expression
10:11:04 * hackagebot music-pitch-literal 1.1 - Overloaded pitch literals.  http://hackage.haskell.org/package/music-pitch-literal-1.1 (HansHoglund)
10:12:11 <marekw2143> geekosaur: I unpacked value in "getRandom" monad in mind and assumed that it's what haskell would do :)
10:12:37 <irene-knapp> what am I doing here?
10:12:47 <irene-knapp> take this question at any level of abstraction you desire
10:13:23 <geekosaur> marekw2143, you showed us a series of function parameters minus the function they are parameters to. why do you assume they have some meaning by themselves?
10:13:47 <marekw2143> geekosaur: ok, I'll ask once again
10:13:59 <bxc> hmm upgraded smallcheck and test-framework-smallcheck and moved ot the smallcheck Series typeclass that needs a monad paramter, and now i find that test depth seems to be either being ignored or set ridiculously high
10:14:39 <marekw2143> how does it happens that in call to 'getTwoRandoms' it returns tuple of (State, (RandomNumber1, RandomNumber2))  -- code at: http://hpaste.org/83926
10:14:42 <geekosaur> basically the question you asked makes sense if you include the liftM2, but is not so sensible without
10:15:35 <irene-knapp> oh so THAT's what the (,) monad does!
10:15:43 <klrr> ab9rf: well then how do i solve programming if it's programming?
10:16:04 * hackagebot reverse-apply 1.0.3 - Standard version of the reverse apply operator.  http://hackage.haskell.org/package/reverse-apply-1.0.3 (HansHoglund)
10:16:09 <hiptobecubic> klrr, what does that mean?
10:16:15 <`ramses> marekw2143: do you understand what "liftM2 (,)" does?
10:16:22 <sproingie> (,) is not a monad
10:16:28 <`ramses> @ty liftM2 (,)
10:16:29 <lambdabot> Monad m => m a1 -> m a2 -> m (a1, a2)
10:16:33 <hiptobecubic> hah
10:16:40 <hiptobecubic> new award for most useless package
10:16:51 <marekw2143> `ramses: now I think that it takes two monads, extracts values from them, and put result of some function applied to those extracted values to monad
10:17:26 * frerich2 thinks reverse-apply must have been a cabal/hackage exercise.
10:17:55 <`ramses> marekw2143: yes, also that's not formulated very precisely :)
10:18:04 <`ramses> s/also/although
10:18:19 <`ramses> marekw2143: then, any idea which monad is at play here?
10:18:38 <`ramses> (it's not State)
10:18:40 <marekw2143> `ramses: something like thtat:  liftM2 fct m1 m2 = m1 >>= (\a -> m2 >>= ( \b -> return $ fct a b ))  ?
10:19:08 <`ramses> @src liftM2
10:19:09 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
10:19:10 <hiptobecubic> > let fid = flip id in 1 `fid` succ
10:19:12 <lambdabot>   2
10:19:30 <`ramses> marekw2143: so, yes :)
10:19:30 <marekw2143> `ramses: same I defined
10:19:38 <sproingie> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
10:19:38 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
10:20:00 <marekw2143> `ramses: so we have RandomState here as a monad, right?
10:20:06 <`ramses> marekw2143: the confusing part here is figuring out which monad is used in that expression
10:21:05 <`ramses> marekw2143: ah, yes, I still had your function example in mind
10:21:44 <marekw2143> `ramses: but in getTwoRandoms, monad used is RandomState, rigth? (http://hpaste.org/83926)
10:21:58 <`ramses> marekw2143: so, is it clear what happens now?
10:22:19 <`ramses> marekw2143: yes it is, I had your previous example in mind
10:23:29 <mcstar> i read the paper where haskell typeclasses and ml functors are compared, but i feel disappointed
10:24:19 <mcstar> the guy managed to translate typeclasses to excplicit dictionary passing as functors
10:24:26 <mcstar> wtf
10:25:39 <ski> marekw2143 : s/it takes two monads/it takes two monadic actions/
10:25:56 <kurkale6ka> Hi, how do I use cabal, I just installed it on my distro and ow I wana cabal install hdevtools, no cabal executable though
10:26:16 <mcstar> so, i consulted with #ocaml, and they said, there is no way to translate that n-ary evaluator to ocaml
10:26:54 <ski> "n-ary evaluator" ?
10:26:55 <marekw2143> ski: s/it ?
10:26:57 <geekosaur> kurkale6ka, "cabal" is two things. there is a library "Cabal" (which should really be part of the compiler) and there is "cabal-install" which provides the cabal command
10:27:05 <geekosaur> make sure youy instaleld the latter
10:27:23 <ski> marekw2143 : it doesn't take two monads, it takes two monadic *actions*
10:27:32 <mcstar> ski: a function that takes an n-ary propositional formula, and determines if it is valid, thats one use case, for example
10:27:46 <marekw2143> ski: so those actions aren't evaluated until explicity stated, right/
10:27:47 <marekw2143> ?
10:27:56 <kurkale6ka> geekosaur: ok, thx
10:28:25 <ski> marekw2143 : they aren't *executed* until `liftM2' says so, no
10:29:07 <ski> @type state random
10:29:09 <lambdabot> (MonadState s m, RandomGen s, Random a) => m a
10:29:30 <mcstar> (what do you call the 'thing' that happens when the code reaches such an action at runtime?)
10:29:35 <ski> @type state random :: Random a => State StdGen a
10:29:37 <lambdabot> Random a => State StdGen a
10:29:45 <klrr> 18:15 < hiptobecubic> klrr, what does that mean?
10:30:05 <klrr> hiptobecubic: it means that , is problem solving something IQ-dependent or can it be learned?
10:30:08 <ski> marekw2143 : my point is that the things that are passed to `liftM2', and the thing that it resurns, are *not* monads -- they are monadic *actions*
10:31:05 <marekw2143> ski: hmm, so monad is "definition" of monadic action, while "monadic action" is some instance of monad?
10:31:05 <hiptobecubic> klrr, many people argue that IQ is also learned
10:31:06 <ski> marekw2143 : `State StdGen' (which is what your `RandomState' means) is a monad. *values* of type `State StdGen Foo' (for some type `Foo') are *not* monads, they are monadic actions (specifically `RandomState'-actions, in this case)
10:31:30 <klrr> hiptobecubic: that's sounds hopefull :D i think i got 105 really wanna increase that
10:31:35 <hiptobecubic> klrr, solving problems takes practice and experience. Very rarely is anything actually "new".
10:31:39 <ski> marekw2143 : a monad is a *type* (together with two functions, `return' and `(>>=)', that follow a couple of laws)
10:31:40 <mcstar> hopeful*
10:31:44 <hiptobecubic> 100 is supposed to be average isn't it?
10:31:57 <arkeet> "monad" is an abstraction.
10:32:09 <arkeet> as soon as you understand this, you are well on the way.
10:32:22 <ski> marekw2143 : do you know what a priority queue is ?
10:32:28 <marekw2143> ski: of course
10:32:41 <TravisD> ski: eh, not a *type constructor*?
10:33:08 <ski> marekw2143 : well, the abstract concept of monad corresponds to the abstract concept of a priority queue : a type and some operations pertaining to it following to some laws
10:33:15 <arkeet> yes, a type constructor.
10:33:24 <klrr> hiptobecubic: okey, so you basically solve a problem by learning how to solve it? someone who invent something new then, is he slowely adding a new idea ontop of old ones or are there actually people who invented completely new ideas from nothing ?
10:33:34 <mcstar> ski: if you could say whether or not it is possible in ocaml, id really appreciate it, i dont remember if you know ocaml or not
10:33:39 <hiptobecubic> klrr, almost 100% the former.
10:33:44 <arkeet> ski: except that various implementations of priority queues are basically interchangable.
10:33:45 <ski> marekw2143 : a particular monad corresponds to a particular kind of implementation of a priority queue, e.g. `State StdGen',`Maybe',`Either MyError'
10:34:17 <klrr> hiptobecubic: okey :)
10:34:17 <hiptobecubic> klrr, you take something that works and improve it a bit or find a new context to reuse it in. That's how most discoveries boil down.
10:34:24 <ski> marekw2143 : and a monadic action corresponds to a particular instance value of such an implementation of a PQ
10:34:33 <marekw2143> ski: ok, I see
10:34:43 <klrr> hiptobecubic: is that why many is so much against software patents? (sry for thriving away from the topic=
10:34:55 <ski> arkeet : yes, an implementation of a queue is possibly a better example (since one implementation may also implement the dequeue interface, &c.)
10:35:05 <marekw2143> ski: so in our case, liftM2 just extracts value from first monadict action, and uses that value to feed 2'nd monadic action , right?
10:35:19 <hiptobecubic> klrr, not really. But this belongs in a different channel.
10:35:26 <arkeet> ski: I think it's on a different level of abstraction though, so it's hard to make a good analogy.
10:35:35 <mcstar> TravisD: you meant typeclass, probably, why would a monad be a type constructor?
10:36:00 <ski> marekw2143 : `liftM2 f ma mb' returns a monadic action that when executed, first executes `ma', yielding result `a', then executes `mb', yielding result `b', then itself yielding `f a b' as a result
10:36:00 <arkeet> mcstar: Monad is a type class. monads are type constructors.
10:36:28 <ski> arkeet : perhaps -- but i think the data structure analogy is better than nothing, at least
10:36:34 <arkeet> perhaps.
10:36:38 <marekw2143> ski: and it all happens with usage >>= for given monad, right?
10:36:44 <ski> marekw2143 : also note that "execute" is different from "evaluate"
10:37:01 <TravisD> mcstar: Monads are also functors, and the natural way to encode a functor within haskell is as a type constructor, I guess
10:37:11 <arkeet> mcstar: [], Maybe, and IO are all monads; they are type constructors.
10:37:12 <ski> marekw2143 : yes, what "executes" means will depend on what `(>>=)' actually does in the specific monad
10:38:01 <mcstar> well, they are something, thats for sure, but until i dress them up in a Monad instance, they are not monads
10:38:03 <ski> marekw2143 : in the case of the `Maybe' monad, "execute" means : check if the monadic action evalautes to `Nothing'
10:38:25 <mcstar> but im trying to see your points
10:38:27 <TravisD> mcstar: Sure they are - haskell just doesn't know about it
10:38:42 <Philippa-> "execute" really means "take a look at the interpreter that's fused into >>= and return" :-)
10:38:48 <ski> marekw2143 : .. in that case abort the rest of the computatation -- otherwise, it yields `Just x', so that monadic action yielded `x' as result when executed, and `x' is fed to the rest of the monadic computation
10:39:30 <marekw2143> so generally monad is a way of combining actions in some temporary logic
10:39:34 <igstan> TravisD: if Haskell doesn't know about them, then they can't be type constructors I guess. A type constructor is related to Haskell. You're going from the Haskell representation of monads to the concept there.
10:40:15 <ski> (yeah, "execute" is sortof like evaluating potentially side-effectful expressions in an internal language of the kleisli category of the monad in question)
10:40:40 <TravisD> Alright, well - all I meant before is that every instance of Monad is going to be a type constructor
10:40:47 <TravisD> (I think - I don't actually know)
10:41:07 <marekw2143> ski: should I learn Kleisli category to understand haskell ?
10:41:21 <ski> marekw2143 : it can be thought of as a way of sequencing "computation", yes. for a very general idea of what "computation" means (and where in some cases the "sequencing" in actuality doesn't matter at all)
10:41:30 <TravisD> and the second comment was that I can talk about Monads independently of Haskell. And I might actually have a monad, even if I don't make it an instance of Monad - so being an instance of "Monad" shouldn't be the defining property
10:41:39 <Philippa-> marekw2143: I'd say language rather than logic, but same difference :-)
10:41:46 <ski> marekw2143 : only if you want to -- e.g. if you enjoy math or denotational semantics
10:41:49 <Philippa-> (o hai thar Curry-Howard)
10:42:07 <marekw2143> sometimes I think that haskell is productive only for mathematicans with PhD in area of theory category
10:42:26 <ski> marekw2143 : you should learn what "monad","functor",&c. mean in the context of Haskell
10:42:31 <mcstar> @i Monad
10:42:31 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
10:42:38 <Philippa-> marekw2143: I could teach my 10 y/o self to code well in it
10:42:44 <Philippa-> you don't need the CT
10:42:58 <Philippa-> you just need to know how it specialises to Haskell's usages
10:43:07 <marekw2143> Philippa-: CT ?
10:43:12 <Philippa-> Category Theory
10:43:12 <ski> Category Theory
10:43:25 <Philippa-> (sorry, the abbreviation's so common it's in muscle memory for me - my bad)
10:43:46 <mcstar> TravisD: well, from the definition of the Monad typeclass, an 'm' of 'Monad m' must take another type argument, so yes, it must be a type constructor
10:43:57 <sproingie> i think a 10 year old has an easier time of it.  we grownups tend to overthink it
10:44:09 <TravisD> mcstar: That's all I was saying before. In particular, it is /not/ a type
10:44:50 <marekw2143> wow, so LiftM2 don't put results of "executing" two monadic actions into some function, but rather "chains" two monadic actions, and puts result of them (processed by 1st argument passed to liftM2)  in "resulting" monad, right?
10:45:22 <klrr> may i just ask, is monads basically a "simulation" for imperetive programming sinec you cant really program in funcitonal programming language?
10:45:31 <applicative> > liftM2 (+) (Just 1) (Just 2)
10:45:32 <lambdabot>   Just 3
10:45:41 <ski> marekw2143 : .. puts them in resulting monadic action, yes
10:45:43 <Zouppen> What is the equivalent Haskell type for C99 bool when using FFI?
10:45:50 <applicative> > liftM2 (+) {1] [2]
10:45:51 <lambdabot>   <hint>:1:13: parse error on input `1'
10:45:53 <sproingie> liftM and company make non-monadic functions monadic
10:45:53 <applicative> > liftM2 (+) [1] [2]
10:45:55 <Philippa-> marekw2143: liftM2 is just "call a binary function with these two terms as parameters" in the monad's language
10:45:55 <lambdabot>   [3]
10:45:59 <ski> klrr : yes
10:46:18 <Philippa-> (and the equivalent for liftM* and the equivalent using <$> and <*> )
10:46:29 <ski> klrr : it's also a simulation of imperative effects that you'd like your favourite imperative language to have, but which it doesn't have
10:46:31 <applicative> liftM/fmap makes a non-functory/monadic function monad; liftM2 does it for two place functions
10:46:36 <mcstar> hm, i have a new problem for me
10:46:51 <applicative> @type liftM3
10:46:53 <mcstar> write a liftM* that takes an n-ary function and lifts it
10:46:53 <lambdabot> Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
10:46:59 <marekw2143> what was important to me is that result of 1'st monadic action is passed to 2nd monadic action by >>= function
10:47:13 <ski> klrr : iow, with monads, you can "brew your own" mix of side-effects
10:47:22 <applicative> liftM3 (\x y z -> x + y + z) [1] [2] [3]
10:47:22 <sproingie> by the time you get into liftM3 you probably want to start chaining ap
10:47:34 <applicative> > liftM3 (\x y z -> x + y + z) [1] [2] [3]
10:47:36 <lambdabot>   [6]
10:47:46 <applicative> > liftM3 (\x y z -> x + y + z) [1] [2] [3,4]
10:47:47 <lambdabot>   [6,7]
10:47:50 * Sgeo wishes it was possible to write liftMn in Haskell
10:47:59 <mcstar> it isnt??
10:48:10 <ski> dependent types ?
10:48:15 <Sgeo> Of course, people in languages where it _is_ possible to write that function don't seem to notice sometimes, and go ahead and write a macro
10:48:16 <mcstar> you spared my time, thank you
10:48:34 <Sgeo> mcstar, well, there is a way to do it if you have a terminator, I think
10:48:45 <mcstar> i dont, im not connor
10:49:07 <Sgeo> Someone who understands idiom brackets decently please explain to mcstar?
10:49:23 <mcstar> ski maybe
10:49:26 * ski doesn't like idiom brackets
10:49:41 * applicative loves idiom brackets
10:49:47 <mcstar> ski: so, do you know ocaml or not? i dont remember what you told before
10:49:50 <ski> they are too local
10:50:03 * applicative agrees they don't exactly 'scale'
10:50:04 <ski> mcstar : i know a little OCaml (more SML)
10:50:26 <mcstar> ski: can you write that function i was talkin about in either one?
10:50:42 <ski> which function was this ?
10:50:44 <kqr1> i'm doing a let binding inside of the IO monad. i want to catch the exception that's thrown if the deconstruction fails. how would I go about this?
10:50:45 <mcstar> (not this liftMn)
10:50:55 * Philippa- isn't entirely sure about idiom brackets as such, but it's complicated?
10:51:05 <mcstar> ski: http://hpaste.org/83876
10:51:10 <mcstar> validp
10:51:22 <monochrom> firstly, liftM3 f3 x y z = ((f3 `liftM` x) `ap` y) `ap` z
10:51:25 <ski> kqr1 : `case' ?
10:51:32 <Philippa-> I do like the idea that inside the bracket is "a function call" within the idiom/applicative - that being the language feature that an applicative is enough to support
10:51:42 <kqr1> ski, that could be an even better solution
10:51:52 <TravisD> Idiom brackets are just sugar for replacing [[f x y z]] with f <$> x <*> y <*> z, right?
10:51:55 <TravisD> or is there more to it?
10:52:00 <monochrom> then, if you also have Functor and Applicative (idiom = Applicative), = f3 <$> x <*> y <*> z
10:52:18 <kqr1> ski, my initial thought was that I wanted to separate the error handling from the other code
10:52:26 <monochrom> lastly, what TravisD says, = [[f x y z]]  or similar notation
10:52:28 <ski> kqr1 : with an apprpriate encoding of natural numbers, i think it could be done
10:52:34 <ski> er
10:52:36 <ski> mcstar ^
10:52:48 <mcstar> hm
10:53:03 <monochrom> this generalizes to f5 <$> a <*> b <*> c <*> d <*> e = [[f5 a b c d e]] etc
10:53:09 <mcstar> ok, thanks, it is a little vague
10:53:13 <monochrom> so that's your liftMn
10:53:51 <kqr1> ski, a case…of doesn't make the code neater, but thanks for the suggestion anyway
10:53:53 <mcstar> ski: i dont understand, how can you do it, if you dont have a mechanism, that associates values with types, like a built in typeclass system
10:54:10 <ski> mcstar : iow, instead of the system automagically creating an appropriate instance, you have to say something like `s (s (s z)) (fun x y z -> ..x..y..z)'
10:54:12 <monochrom> I think someone wrote a pair of functions/combinators/whatever il, li such that f3 <$> x <*> y <*> z = il f3 x y z li
10:54:20 <Sgeo> Mon_Ouie, that's what I was thinking of
10:54:34 <ski> (for some definition of `s' and `z')
10:54:37 <mcstar> ski: ok, i dont consider that an appropriate solution
10:54:54 <ski> mcstar : *nod*
10:55:05 <mcstar> the whole point is to not provide any more information than a native function
10:55:42 <ski> mcstar : otherwise i think this probably goes against parametricity
10:55:46 <applicative> monochrom: someone put that trick on the wiki http://www.haskell.org/haskellwiki/Idiom_brackets
10:56:01 <fizbin> Haskell module gurus: is the following scheme a valid thing to do in Haskell?
10:56:10 <monochrom> nice
10:56:28 <fizbin> I have a bunch of data structures, and separately functions which build them up and tear them down.
10:56:55 <applicative> fizbin: yes, valid scheme
10:56:57 <mcstar> ski: my 'solution' goes against parametricity? and what does it mean?
10:57:15 <fizbin> I want to make a module which exports the data structures and the lenses that manipulate them, and also defines a few other things for export.
10:57:16 <ski> mcstar : sorry, what is your 'solution' ?
10:57:25 <mcstar> ski: the paste
10:57:46 <ski> oh -- in ML, i mean
10:58:00 <ski> (which doesn't have type classes)
10:58:23 <fizbin> I was planning on putting the definitions of the structures and their lenses in one module, and then making a larger module which imports that definition one and then exports everything in the definition one, and also some (but not all) symbols of its own.
10:58:34 <fizbin> Can I do that? If so, how?
10:58:36 <mcstar> is 'parametricity' a good or a bad thing? is it what ML endorses?
10:58:48 <ski> i think parametricity is a good thing
10:59:02 <ski> (at least in most cases)
10:59:13 <applicative> module Big (module Small, newcombinator) where <-- fizbin ??
10:59:26 <applicative> module Big (module Small, newcombinator) where import module Small
10:59:35 <fizbin> Okay.
11:00:11 <ski> mcstar : consider `foo :: forall a. Int -> [a] -> Maybe [a]' -- parametricity tells us this function can do nothing with the elements of the given list, apart from passing them around
11:01:30 <Zouppen> I should not ever ask anything on a busy channel :D well, hope someone founds it on stackoverflow. http://stackoverflow.com/questions/15368658/what-is-the-equivalent-haskell-type-for-c99-bool-when-using-ffi
11:01:44 <Zouppen> err, finds
11:01:57 <mcstar> c99 has bool?
11:02:10 <bxc> http://hpaste.org/edit/83927
11:02:12 <mauke> _Bool
11:02:12 <mcstar> i thought only c++ had that, my mistake
11:02:14 <applicative> > let lengthCheck n xs = if length xs == n then Just xs else Nothing in lengthCheck 3 "abc"
11:02:15 <lambdabot>   Just "abc"
11:02:17 <bxc> thats a problem i have with smallcheck that i mentioned earlier
11:03:04 <bxc> i think its a behaviour change from previous versions of smallcheck - at least the code its abstracted ut of behaves differently on this version of smallcheck compared to before
11:03:29 <bxc> sorry http://hpaste.org/83927 without the /edit/
11:03:42 <klrr> how do i change ghci to use haskell2010 instead of 98 so i can use ord and chr functions?
11:03:49 <mauke> klrr: what
11:04:03 <mauke> H98 had ord and chr
11:04:15 <srhb> klrr: Instead, import Data.Char
11:04:19 <arkeet> ghci uses ghc, not haskell 2010 or 98.
11:04:21 <arkeet> :p
11:04:26 <arkeet> but yeah, those are in Data.Char
11:04:53 <ski> @index chr
11:04:53 <lambdabot> Data.Char
11:04:57 <arkeet> (if this was h98, they'd be in Char)
11:05:19 <dcoutts> klrr: it would be "ghci -XHaskell2010" except that that's the default already. You can switch to 98 similarly.
11:05:37 <klrr> okey, why does nothing happens if i do "import Char" then?
11:05:52 <arkeet> don't do that.
11:05:54 <srhb> klrr: "Nothing happens" meaning you still can't use chr or ord?
11:06:03 <dcoutts> klrr: it's not called Char anymore, it's Data.Char
11:06:06 <arkeet> import Data.Char
11:06:14 <srhb> Ah, misread.
11:06:27 <mauke> if I "import Char", I get an error message
11:06:29 <klrr> okey thanks sry for stupid questions
11:06:47 <dcoutts> klrr: no probs, no need to apologise
11:06:52 <ski> not a stupid question
11:07:02 <mcstar> mauke: there was a time when importing a module didnt procude error messages, and didnt import the module either
11:07:02 <Zouppen> mcstar: yes, http://en.wikipedia.org/wiki/C_data_types#Boolean_type
11:07:04 <arkeet> the only stupid question is "can I ask a question?"
11:07:09 <mcstar> i remember that distinctly
11:07:13 <mauke> it was a stupid question
11:07:20 <arkeet> mcstar: 7.4.1, right?
11:07:29 <mcstar> idk, i have 7.6.2 now
11:07:35 <mcstar> it errors out now :)
11:07:43 <arkeet> I think it was 7.4.1.
11:07:48 <srhb> arkeet: Yes. "was a time" is there for most users of HP.
11:08:06 <klrr> http://hpaste.org/83928 <- can someone help me implement ceasar cipher? i stole that from a hint but i have no idea how to do this, it's easy in C but since i cant compare and int and a char it gets messy in my head
11:08:07 <arkeet> they should upgrade!
11:08:32 <arkeet> klrr: well, you have to convert between Char and Int using chr/ord
11:08:34 <applicative> > ord 'c'
11:08:36 <lambdabot>   99
11:08:37 <monochrom> HP has been 7.4.2 for some time already
11:08:44 <srhb> 7.4.2 does throw warnings?
11:08:46 <mauke> > chr (ord 'c' + 1)
11:08:47 <applicative> > map ord "caesar"
11:08:48 <lambdabot>   'd'
11:08:48 <lambdabot>   [99,97,101,115,97,114]
11:08:55 <klrr> arkeet: ok
11:09:14 <monochrom> I don't use "import" in ghci, so I don't know
11:09:27 <mcstar> i did substitutional cyper on my mother's computer in the browser in javascript, to demonstrate to her
11:09:43 <arkeet> klrr: also, if you swap your arguments around, you can use map to implement cipher
11:09:48 <arkeet> rotate :: Int -> Char -> Char
11:10:01 <arkeet> cipher :: Int -> [Char] -> [Char]; cipher n = map (rotate n)
11:10:16 <arkeet> oh, make sure you fix "chipher"
11:10:20 <arkeet> that'll cause you trouble. :p
11:13:02 <monochrom> "import" in ghci seems to work. even "import qualified Data.Char as X(chr)".
11:13:26 <klrr> cipher.hs:5:36:
11:13:26 <klrr>     Not in scope: `cipher'
11:13:26 <klrr>     Perhaps you meant one of these:
11:13:27 <klrr>       `chipher' (line 4), `either' (imported from Prelude
11:13:34 <klrr> i get that when i try to import my code
11:13:35 <c_wraith> There was some issue with import in GHCI and transitive instances.
11:13:36 <klrr> to ghci
11:13:42 <mauke> klrr: so fix the typo
11:14:03 <c_wraith> err, transitively-imported instances
11:14:10 <klrr> okey
11:14:15 <applicative> > "cipher" == "chipher"
11:14:17 <lambdabot>   False
11:14:24 <klrr> mauke: how did you know it was a typo?
11:14:33 <mcstar> it was mentioned before
11:14:37 <mauke> klrr: what else would it be?
11:14:40 * applicative thinks it was the extra 'h'
11:14:41 <mcstar> and you can catch it if you read the paste
11:14:42 <mauke> klrr: "chipher" isn't even a word
11:14:46 <mcstar> and the error message is clear
11:14:49 <monochrom> "Perhaps you meant one of these: `chipher' (line 4)"
11:15:15 <applicative> mauke: but klrr had just defined "chipher"
11:15:26 <applicative> why he gave a signature for "cipher" we don't know
11:15:48 <klrr> mauke: okey sry for being stupid
11:15:59 <mcstar> most names dont make sense as words
11:16:08 <monochrom> someone is performing the Turing test on the #haskell chinese room. input a GHC error message. see if the output looks intelligent :)
11:16:11 <mcstar> so when you name something, why shold it be a 'word'
11:16:20 <hpaste> klrr pasted “idontknow” at http://hpaste.org/83929
11:16:43 <c_wraith> klrr: don't worry about it. Just remember the compiler is there to help you. If it's telling you it found an error, read the message. It's trying to tell you what it found.
11:16:51 <mcstar> monochrom: who's failing?
11:17:23 <klrr> http://hpaste.org/83929 <- that's my code, but it doesnt work as you might understand, how do i fix so it works, on wikipedia it said ceasar cipher was using some "mod" function in its formula to solve it but i dont know?
11:17:33 <applicative> klrr: you will get past these troubles in no time :)
11:17:57 <mcstar> klrr: do you know what modulo or remainder is?
11:18:07 <klrr> no
11:18:14 <mcstar> ok, then look them up on wiki
11:18:35 <mcstar> the point is, you dont want your encoding to over or underflow
11:19:11 <klrr> http://upload.wikimedia.org/math/3/c/8/3c8c79012aeebb48b9128a4011e231ad.png <- what's that symbol in between a and b?
11:19:11 <mcstar> (you want information content to remain intact, in other words)
11:19:28 <mcstar> equivalence
11:19:39 <monochrom> C99 _Bool type may be any one of char, int, long, unsigned, etc etc. So it is hard to figure out whether that's GHC's Bool, Int8, Int32, etc
11:19:44 <ski> klrr : "`a' and `b' are equivalent/congruent modulo `n'"
11:20:08 <mcstar> also, that formula is bad
11:20:14 <mcstar> could use some \!
11:20:47 <ski> klrr : on the clock, "two o'clock" and "fourteen o'clock" shows the same, because `2 ≡ 14 (mod 12)'
11:20:48 <klrr> okey , so in haskell that is a == b (mod n) ?
11:20:59 <mcstar> no
11:21:02 <mcstar> b is not a function
11:21:02 <klrr> ok
11:21:09 <monochrom> "x ≡ y (mod n)" means: x-y is divisible by n
11:21:21 <klrr> what's divisible?
11:21:26 <klrr> is it so it can be divided?
11:21:31 <ski> > let (a,b) = (2,14); n = 12 in (a `mod` n) == (b `mod` n)
11:21:33 <lambdabot>   True
11:21:40 <mcstar> a | b means a divides b, that is, there exists a c such that b = a * c
11:22:02 <klrr> when do you learn this in school, we only learn simple algebra at the most advanced
11:22:11 <mcstar> (the variables are qualified over the integers)
11:22:22 <ski> klrr : ...,`-4',`2',`0',`2',`4',`6',... are all divisible by two
11:22:25 <monochrom> my school taught this several years before simple algebra
11:22:26 <mcstar> elementary school?
11:22:33 <ski> klrr : ...,`-6',`3',`0',`3',`6',`9',... are all divisible by three
11:23:06 <monochrom> well, not "x ≡ y (mod n)", but "6 is divisible by 3" and "7 is not divisible by 3" etc
11:23:07 <Zouppen> monochrom: yeah. the C99 specs only say it should be "large enough" to store 0 and 1... so, should the base library be patched to support it?
11:23:37 <mcstar> i am asking, klrr what shool you had in mind, elementary, or high school?
11:23:55 <applicative> klrr: 24 hours from now it's be the same time as it is now, mod 24
11:24:02 <Zouppen> on my architecture (x86_64) sizeof tells it's 1 byte
11:24:21 <klrr> mcstar: wtf, is sweden the most idiotic country or what? ive never learned that and im starting high school next year :/ fucking soscialistic bastards wanna kill em
11:25:06 <mcstar> honestly i dont remember, but it is possible they only teach you divisibility in the beginning of high school
11:25:32 <applicative> dont worry klrr you are the perfect student of haskell
11:25:36 <mcstar> (i attended a 6 year high school, from grade 7 and up, thats why m confusino)
11:25:47 <indomitus> how can I tell if a package is from the default Haskell system or is from Hackage?
11:25:55 * ski was taught it around age 10 .. though not in school
11:26:02 <arkeet> indomitus: ghc-pkg list it
11:26:03 <kqr1> is there anywhere I can read about how one splits a haskell program into more than one file?
11:26:11 <applicative> indomitus: ghc-pkg will tell you about two package lists probably
11:26:32 <arkeet> kqr1: read about modules, in your favourite haskell resource.
11:26:39 <Philippa-> klrr: That seems about normal to me, FWIW. Don't worry, you'll be fine with Haskell - just expect to learn a lot and have fun with it
11:26:40 <applicative> study the results of a simple 'ghc-pkg list' indomitus
11:26:43 <mcstar> indomitus: ghc-pkg list
11:26:52 <mcstar> oh
11:27:00 <klrr> sry for being aggressive
11:27:21 <kqr1> arkeet, i think i know how they work. what is the top level module of my project supposed to be named? "Main" or the name of the program?
11:27:35 <mcstar> i think you are too young to worry about math or haskell
11:27:45 <Philippa-> klrr: thanks. We appreciate it
11:27:45 <mauke> kqr1: Main
11:27:56 <arkeet> kqr1: Main is a common name, I suppose, although there isn't really a strict requirement for it to be called anything.
11:27:57 <klrr> okey, so how do i use modulo 26 (for all english letters) with "chr ((ord x) - n)" , do i use "(chr ((ord x) - n)) ´mod´ 26"?
11:28:00 <Philippa-> mcstar: you're never too young, just too young to *have* to
11:28:04 <kqr1> mauke, so any submodule that needs something from main is supposed to import Main?
11:28:05 <ski> kqr1 : the file can be named `MyProgram.hs', but the module should be named `Main', iirc
11:28:06 <mauke> arkeet: Main.main is the entry point
11:28:08 <Philippa-> and, well, life doesn't exactly obey that
11:28:10 <mauke> kqr1: no
11:28:14 <mauke> kqr1: nothing is supposed to import Main
11:28:28 <arkeet> mauke: well, main defined in the module referred to by main-is: is the entry point.
11:28:35 <arkeet> (if cabal)
11:28:42 <kqr1> mauke, that's what struck me. i have a couple of data types which need to be shared over the entire program. am i supposed to put them in a separate module?
11:28:58 <monochrom> if you do not say "module Whatever", it defaults to "module Main(main)". note the default is not "module Main".
11:28:59 <indomitus> thank you! applicative, indeed i do have 2 lists (one system and one user list) i take it the user list is full of hackages?
11:29:00 <mauke> kqr1: depends
11:30:01 <kqr1> mauke, essentially, my program consists of three parts: one yaml bit, one HTML bit and the main module which glues them together with common data types and all
11:30:14 <mauke> that sounds backwards
11:30:18 <kqr1> haha
11:30:23 <kqr1> i'm all ears
11:30:40 <mauke> common stuff should be in the lower-level modules, not at the top
11:30:54 <mcstar> klrr: you dont want to underflow, before you change the number back to character representation
11:31:02 <monochrom> it may be not backwards if so-called "main module" refers to a library rather than an executable.
11:31:18 <klrr> mcstar: what's underflow?
11:31:25 <kqr1> mauke, so basically, i should have a separate low-level module for the data types, which is imported by all the other things?
11:31:26 <monochrom> "users should just import the 'main' module"!
11:31:33 <mcstar> > chr (-1)
11:31:35 <lambdabot>   *Exception: Prelude.chr: bad argument: (-1)
11:31:41 <mcstar> > chr (0)
11:31:42 <lambdabot>   '\NUL'
11:31:45 <mauke> kqr1: not necessarily
11:32:00 <mauke> the types could be part of another module
11:32:07 <kqr1> oh sure
11:32:14 <kqr1> it just doesn't quite make sense in this case
11:32:38 <klrr> mcstar: yes but how do i use this modulo, is modulo "mod" in haskell?
11:32:59 <kqr1> klrr, yes
11:33:05 <kqr1> > mod 17 5
11:33:06 <lambdabot>   2
11:33:10 <arkeet> > 17 `mod` 5
11:33:12 <lambdabot>   2
11:33:13 <kqr1> or that
11:33:17 <signalsea> what's a concise way to take a traversable t => t ((i :: Int, j :: Int), a) and get an [[a]] where each inner list previously all had the same value for i?
11:33:40 <signalsea> or a foldable
11:34:19 <klrr> i thought you used modulo after the expression like in this forumula = http://upload.wikimedia.org/math/b/b/b/bbb819c72cda43180d98e6ade5cadb04.png
11:34:31 <klrr> how do i use it that way?
11:34:32 <mcstar> also, i would just do whole ascii to whole ascii encryption, and not worry about how the encoded text looked like
11:34:46 <c_wraith> signalsea: the simplest is probably converting to a list, then using sortBy and groupBy
11:35:05 <klrr> mcstar: yes but then ive already done, and it wont impress anyone
11:35:41 <mcstar> > ['A'..'Z']
11:35:42 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
11:35:46 <mcstar> > ['A'..'z']
11:35:48 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
11:36:06 <mcstar> so, there are some characters that can pop up:
11:36:16 <mcstar> ['['..'`']
11:36:16 <indomitus> if something is listed under base in Hoogle, does that mean it runs out of the box w ghc (or the basic haskell system i.e. w/o using cabal)?
11:36:20 <mcstar> > ['['..'`']
11:36:21 <lambdabot>   "[\\]^_`"
11:36:28 <mcstar> that are not letters per say
11:36:33 <mcstar> not from the english abs
11:36:35 <mcstar> abc*
11:36:47 <klrr> mcstar: okey, how do i solve this problem?
11:36:51 <klrr> in a functional way
11:36:53 <mcstar> idk, i wouldnt
11:36:55 <mauke> *per se
11:36:59 <ski> klrr : the "mod" in `x ≡ y (mod n)' isn't quite the same as the `mod' in Haskell, no
11:37:01 <c_wraith> @ty map (map snd) . groupBy ((==) `on` fst . fst) . sortBy (comparing (fst . fst)) . Data.Foldable.toList -- signalsea
11:37:02 <lambdabot> (Ord a, Foldable t) => t ((a, b1), b) -> [[b]]
11:37:47 <mcstar> mauke: thanks
11:38:23 <mcstar> klrr: anyway, you definitely want to take the modulo of the expression before you translate back to characters, as i said before
11:38:42 <monochrom> indomitus: yes, base comes with GHC
11:38:46 <klrr> okey first i need to find if it's a upper case or lower case, then i also need a way to by pass the problem with so that 'a' - 1 becomes 'z' instead of '´'
11:39:33 <ecuderpam> > 'a' - 1
11:39:35 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
11:39:35 <lambdabot>    arising from a use of `GHC....
11:39:51 <ecuderpam> > ord 'a' - 1
11:39:53 <lambdabot>   96
11:40:00 <ski> > map (chr . subtract 1 . ord) ['a' .. 'z']
11:40:02 <lambdabot>   "`abcdefghijklmnopqrstuvwxy"
11:40:10 <indomitus> monochrome, simple enough, thank you for clarifying
11:40:21 <klrr> ski: what's the "."?
11:40:27 <ski> function composition
11:40:34 <klrr> ski: is it same as $?
11:40:37 <ski> no
11:40:47 <klrr> what is it then ?
11:40:55 <luqui> you can think of it like a backwards pipe
11:41:09 <ski> > map words (lines "This is\nseveral lines\nof text.\n")
11:41:11 <lambdabot>   [["This","is"],["several","lines"],["of","text."]]
11:41:20 <ski> > (map words . lines) "This is\nseveral lines\nof text.\n"
11:41:21 <klrr> grep "penis" . cat file is same as cat file | grep "penis"?
11:41:22 <lambdabot>   [["This","is"],["several","lines"],["of","text."]]
11:41:37 <ski> klrr : basically, yes
11:41:41 <klrr> okey
11:41:50 <klrr> sry for using sexual words instead of foobar
11:41:55 <mcstar> there is no . in sh afaik
11:41:59 <tsinnema> just curious, of whether i've actually made a correct observation: are HLists a free monoidal category?
11:42:03 <klrr> mcstar: yes it was just example
11:42:04 <fizbin> What instances of Control.Arrow exist besides (->) ?
11:42:11 <luqui> wait, foobar isn't sexual?
11:42:16 <ski> fizbin : `Kleisli m'
11:42:29 <fizbin> Is that it?
11:42:32 <luqui> :info Arrow
11:42:37 <luqui> does that not work
11:42:41 <arkeet> not in lambdabot
11:42:44 <ski> @instances Arrow
11:42:45 <lambdabot> (->), Kleisli m
11:42:59 <arkeet> isn't @instances some dumb thing like @src?
11:43:22 <luqui> fizbin: in the standard library at least.  but there's more on hackage.
11:43:46 <geekosaur> arkeet, no, but it does only look at a restricted set of modules by default
11:43:48 <ski> @instances-importing Data.Map Eq
11:43:48 <luqui> fizbin: FRP stuff, quantum entanglement (for fun), ...
11:43:49 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Map k a, Maybe a, Ordering, Product a, Sum a, [a]
11:43:51 <geekosaur> @help instances-importing
11:43:51 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
11:44:15 <geekosaur> just as with ghci you need to import a module for :info to show instances from that module
11:45:36 <ski> tsinnema : hm, what would morphisms be ?
11:46:14 <mcstar> klrr: what i'd do is convert the text to hexadecimal representation, do the encoding there, (only 16 characters)
11:47:09 <mcstar> so the encoded text and the shift also look nicely
11:47:25 <mcstar> and you can keep the whole ascii range too
11:47:38 <ecuderpam> > chr . (+ (ord 'a')) . (flip mod) 26 . (+26) . subtract 1 . subtract (ord 'a') $ ord 'a'
11:47:40 <lambdabot>   'z'
11:47:45 <ecuderpam> klrr: ^^
11:51:37 <tsinnema> ski, i'm too noob to have had an answer to that myself but http://en.wikipedia.org/wiki/Monoidal_category gave me the clue -- i suppose they'd be lists of functions from each type in an HList to the corresponding type in another HList
11:51:54 <arkeet> I don't see the "category" in HList.
11:52:04 <luqui> tsinnema: I think HLists are just products in Hask
11:56:09 <tsinnema> makes sense, no?
11:56:10 <tsinnema> :)
11:57:16 <luqui> tsinnema: so the operation (x) is?
11:57:38 <arkeet> I'm more interested to know what the arrows are.
11:58:08 <luqui> I'm guessing it's a subcategory of Hask, which would make them functions
11:58:20 <luqui> but maybe i'm looking from the wrong angle
11:59:50 <tsinnema> luqui, that'd be the concatenation of two HLists, right?
12:00:34 <arkeet> I agree that it's a monoid of some sort.
12:00:44 <arkeet> but I fail to see how it could be a category.
12:00:45 <arkeet> :p
12:01:41 <tsinnema> arkeet, did you look at the monoidal category wikipedia page? and there's this: http://hackage.haskell.org/packages/archive/categories/1.0.5/doc/html/Control-Category-Monoidal.html
12:02:10 <arkeet> I know what a monoidal category is.
12:02:21 <tsinnema> anyway, i'm not really going anywhere with this, just doing a sanity check
12:02:56 <arkeet> I don't see any arrows or composition with hlists.
12:02:58 <mcstar> if you do an insanity check and negate the result, do you get a sanity check?
12:04:41 <tsinnema> arkeet, wouldn't just lists of functions of the appropriate type work? with composition being the composition of those functions?
12:04:48 <tsinnema> appropriate types
12:05:41 <arkeet> hmm, maybe.
12:07:22 <hpaste> basdirks pasted “Collatz sequence lengths” at http://hpaste.org/83934
12:07:43 <basdirks> could anyone bored enough have a look to see if the above contains any obvious inefficiencies?
12:08:07 <mcstar> yes, the whole thing is inefficient
12:08:16 <mcstar> in that, theres no point in running it
12:08:26 <mcstar> believe me, i tried...
12:08:41 <basdirks> I know
12:08:45 <mcstar> XD
12:08:51 <basdirks> I have your mathematica notes on the subject
12:08:57 <mcstar> oh
12:09:14 <mcstar> i didnt recognize your nick
12:09:15 <basdirks> but my question is more about the actual function than about any deep truths about the conjecture =[]
12:09:56 <simpson> basdirks: For all ints, if a number is not divisible by three, none of its Collatz successors are, either.
12:10:09 <simpson> Which is a deep truth and not about the actual function, sorry. :3
12:10:30 <basdirks> deep truths are always welcome =p
12:10:43 <mcstar> also it should be fast already:
12:10:46 <mcstar> f a s t | a == n = t
12:10:56 <ski> tsinnema : how would that work with lists of different length ?
12:11:02 <basdirks> exactly, but that optimization didn't work mcstar
12:11:32 <mcstar> basdirks: i meant the naming of the variables, if you meant the same, you are funny
12:11:40 <basdirks> I did mean that
12:11:43 <basdirks> =p
12:11:48 <mcstar> you are funny :)
12:11:57 <tsinnema> ski, again just picking up from the wikipedia page, there wouldn't be morphisms between lists of different length
12:12:16 <arkeet> simpson: doesn't seem particularly deep.
12:12:53 <simpson> arkeet: If all ints not divisible by three are in a single Collatz graph, then so are all ints divisible by three. :3
12:13:00 <mcstar> basdirks: one optimization is to always compute (3*n+1)/2, since 3*n+1 is always even
12:13:04 <simpson> arkeet: It might not be especially deep, but it's not obvious either.
12:13:07 <basdirks> mcstar yeah
12:13:24 <ski> tsinnema : hm, ok. doesn't sound particularly interesting to study as a single thing, then
12:13:39 <arkeet> simpson: "obvious" is subjective. :p
12:13:43 <monochrom> I think "deep" is tongue in cheek :)
12:14:00 <monochrom> and "obvious" is too :)
12:14:00 <simpson> arkeet: Yes, fine, you're better at numbers than me. Whatever.
12:14:29 * monochrom always says "x=x is deep truth, fermat's last theorem is obvious" :)
12:14:41 <sproingie> worked for ayn rand
12:15:06 * ski . o O ( you did ? )
12:15:14 <sproingie> no /me in there
12:15:32 <sproingie> "A = A therefore taxes bad"
12:16:00 <tsinnema> ski, yeah, may well be. but i'm at fairly early stages of learning both CT and haskell so even uninteresting things are often interesting :)
12:16:07 <simpson> "...therefore, be a huge ass to everybody."
12:16:16 <mcstar> sproingie: what is A = bottom?
12:16:25 <mcstar> i aked this before, is bottom equal to bottom?
12:16:27 <mcstar> s
12:16:34 <ski> yes
12:16:40 <aCube> > undefined == undefined
12:16:41 <lambdabot>   *Exception: Prelude.undefined
12:16:46 <arkeet> == is not equality
12:16:49 <mcstar> i dont mean haskell
12:16:55 <arkeet> are all bottoms equal?
12:16:57 <mcstar> but yeah, since you cant evaluate it...
12:17:23 <sproingie> consider the bottoms of jessica alba and rosanne barr.  so i'd say, uh, no
12:17:31 <arkeet> I was waiting for that.
12:17:35 <mcstar> thats bottocks
12:17:36 <sipa> arkeet: i'd say that whether they are equal or not is bottom :)
12:17:44 <tsinnema> the bigger the cushion, the sweeter the pushin'
12:18:08 <arkeet> sipa: I'd say that whether I agree with you depends on whether the equailty is internal or external.
12:18:15 <mcstar> nice one
12:18:42 <mcstar> so, things might not be undecidable externally
12:19:10 <bla123> is something like this possible in Haskell:
12:19:11 <bla123> curCont = callCC $ \cc -> return cc
12:19:35 <sipa> :t callCC
12:19:36 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
12:19:52 <mauke> bla123: yes, I remember seeing it somewhere
12:19:58 <ski> bla123 : yes, with `newtype's
12:19:58 <mauke> it may have involved mfix
12:20:19 <bla123> i did not yet come up with a type that would work
12:20:55 <bla123> ski: which part of the type would i have to put in a newtype?
12:21:19 <mauke> http://www.haskell.org/haskellwiki/Compose#Using_Cont
12:21:28 <arkeet> ((a -> m b) -> m a) looks nothing like the type of return
12:23:16 <ski> bla123 : try `newtype SelfCC m b = MkSCC {runSCC :: SelfCC m b -> m b}' and `curCont = callCC (return . MkSCC)'
12:26:06 <bla123> thank you mauke for the link and ski for the newtype version
12:26:06 <ski> bla123 : though, if you used `callCC :: forall m a. MonadCont m => ((forall b. a -> m b) -> m a) -> m a', that might be more fun
12:26:35 <mauke> bla123: http://stackoverflow.com/questions/5193876/goto-in-haskell-can-anyone-explain-this-seemingly-insane-effect-of-continuation
12:26:58 <bla123> ski: ok, i'll have a very close look at both, and then decide which one goes easier on me ;)
12:27:10 <armlesshobo> how do i find out how instances are defined for different type constructors?
12:27:22 <ski> monochrom's <http://www.vex.net/~trebla/haskell/cont-monad.xhtml> might also be interesting
12:27:23 <mauke> armlesshobo: instances of what?
12:27:30 <armlesshobo> well
12:27:45 <armlesshobo> like how instance Monad Maybe is defined?
12:27:56 <ski> @src Maybe return
12:27:56 <lambdabot> return              = Just
12:28:01 <ski> @src Maybe (>>=)
12:28:02 <lambdabot> (Just x) >>= k      = k x
12:28:02 <lambdabot> Nothing  >>= _      = Nothing
12:28:10 <armlesshobo> :O
12:28:15 <armlesshobo> thank you for this wizardry
12:28:34 <ski> more like a very incomplete dictionary that happened to contain this item
12:29:10 <armlesshobo> ski: is there anything else like this somewhere?
12:30:04 <bla123> ski: thank you for the read, this fun will definitely keep me awake this night
12:30:15 <ski> @wiki All About Monads
12:30:16 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
12:30:16 <ski> iirc
12:31:44 <bla123> armlesshobo: if the type class is in scope, ghci will give you a list of instances (that are in scope):  :i classname
12:32:06 <bla123> it will tell you where it is defined
12:32:21 <bla123> then you can find that package at hackage and look at its source
12:34:26 <armlesshobo> bla123: ahh, thank you :)
12:35:32 <bla123> armlesshobo: if you do not know the package name to which a module belongs, you can use one of the search engines, hayoo and hoogle
12:36:07 * hackagebot web-fpco 0.1.0.0 - Wrappers for web frameworks to ease usage with the FP Complete environment.  http://hackage.haskell.org/package/web-fpco-0.1.0.0 (MichaelSnoyman)
12:36:42 <armlesshobo> bla123: that was very helpful, thank you :)
12:49:04 <s_kilk> hi all, does anyone know where I could find full documentation for Persistent attributes?
12:52:07 <srhb> s_kilk: "Attributes"?
12:53:38 <bla123> s_kilk: "Persistent"?
12:53:51 <srhb> Persistent, presumably the database persistency thingy of Snoyman origin.
12:53:59 <s_kilk> yes, this page the Yesod book (http://www.yesodweb.com/book/persistent) mentions that persistent entity declarations can have attributes, as simple example would be `age Int Maybe`, where Maybe is an attribute of the age column.
12:54:23 <s_kilk> however there seems to be zero documentation on what the legal attribute values are, or what they do
12:55:10 <srhb> Ah, so it refers to which Haskell types can be serialized.
12:57:14 <mcstar> s_kilk: it is well documented
12:57:39 <s_kilk> mcstar, care to point out to this lowly noob ? :)
12:57:55 <mcstar> i just read the hackage documentation, and it worked
12:58:12 <bla123> s_kilk: i've never used Persistent, but this is special syntax specific to persist. i would be surprised if it supported other values than maybe. how would Either for example bes tored in a sql db?
12:58:12 <mcstar> pulled things from a postgresql database
12:59:35 <mcstar> "you can assign an arbitrary list of attributes after the first two words on a line."
12:59:38 <srhb> s_kilk: I think the PersistField instances are what you are looking for
12:59:38 <s_kilk> bla123, for example here is one seen in the wild: `email Text Maybe toFormField=maybeEmailField Update Eq`
12:59:46 <srhb> Perhaps mcstar can confirm that.
13:00:06 <mcstar> that has to do with representing values for sql
13:00:22 <mcstar> i didnt work with these attributes though
13:01:24 <srhb> s_kilk: http://hackage.haskell.org/packages/archive/persistent/1.1.5.1/doc/html/Database-Persist-Store.html#t:PersistField -- scroll down to the first instances section from there
13:01:44 <srhb> Ergh, no, wrong link.
13:02:05 <s_kilk> Thanks, that may be what I'm looking for.
13:02:18 <mcstar> i dont think so
13:02:32 <srhb> Oh, wait, no, the link was right :P
13:02:58 <mcstar> you want a record that you can provide additional fields through the 'persist' quasiquoter
13:03:21 <mcstar> at least, thats how i understand it
13:04:16 <pepijndevos> what does this type mean? ((->) a)
13:04:16 <srhb> Then I don't know. And it doesn't seem that well-documented then. :)
13:04:18 <s_kilk> mcstar, thank, I think that does cover most of it. :) I'm still a bit baffled by the `Update` attribute though
13:04:26 <mcstar> s_kilk: ok, the way i understand it, you can just keep adding attributes, i.e. lines to a 'record'
13:04:29 <srhb> pepijndevos: Function from a to ...
13:04:35 <mcstar> for example. to Person
13:04:50 <srhb> pepijndevos: It's partial application of the function construction operator, so to speak. Very loosely.
13:04:57 <mcstar> a maybe means, it is nullable, for most of them you need to provide a  default
13:05:28 <pepijndevos> srhb: what kind of function would have such a type? Does it mean the function is incomplete?
13:05:41 <toorisugari> none would, because it isn't a complete type
13:05:51 <toorisugari> the type ((->) a b) is just another way to write (a -> b)
13:06:34 <toorisugari> (->) a isn't fully applied, it's like Maybe. You can't have Maybe values but you can have Maybe Ints or Maybe [Char]
13:06:50 <s_kilk> I think I get the notion of using Maybe as a nullable column, what's got me confused is that I've seen quite a few odd looking declarations in the wild and I wanted to find a set of documentation that outlines what can be done with those attribute declarations. in fact, i may just write such a document myself :)
13:07:13 <srhb> s_kilk: Sounds good. You can often catch Snoyman in here as well, that might be helpful.
13:07:30 <mcstar> or see the source of 'persist'
13:07:40 <s_kilk> aye, it would. I reckon it would be a good resource for newcomers.
13:08:22 <s_kilk> mcstar, in fairness, the source is not the easiest read in the world :)
13:08:37 <mcstar> but at least, that is 'complete'
13:09:00 <mcstar> maybe you can find out what other things are possible beyond 'default' for example
13:09:13 <s_kilk> complete indeed :) I'll dig in and try to understand it, and maybe write up a "noobs guide to persist" document
13:09:19 <mcstar> also, i suspect, there is not much to know about it
13:09:31 <mcstar> s_kilk: what else did you find so far?
13:10:36 <mcstar> also, this is just the persist quasiquoter, there is a whole side of persist beyond this
13:11:09 <pepijndevos> toorisugari: (>>=) (*) ($) :: (Monad ((->) b), Num b) => b -> b
13:12:12 <toorisugari> yes?
13:12:25 <pepijndevos> toorisugari: there it has this type I just described
13:12:45 <toorisugari> ((->) a) is monadic, but it's still a type constructor, like monads are
13:13:12 <pepijndevos> oh...
13:14:00 <toorisugari> the type you gave is (b -> b) (where ((->) b) is monadic and b is numeric)
13:16:49 <e98> anyone else fail to build ghc from git master for the last week?
13:17:03 <e98> libraries/vector/Data/Vector/Fusion/Stream/Monadic.hs:104:1: Failed to load interface for `GHC.Desugar'
13:19:36 <toorisugari> the monad over functions iirc is: return = const, fmap = (.), join f x = f x x
13:24:08 <hiptobecubic> > 3 >>= (+)
13:24:10 <lambdabot>   No instance for (GHC.Num.Num (b0 -> b0))
13:24:10 <lambdabot>    arising from a use of `e_13'
13:24:10 <lambdabot>  P...
13:24:53 <hiptobecubic> > join (+) 3
13:24:54 <lambdabot>   6
13:25:31 <toorisugari> > (>>=) (*) ($) 3
13:25:33 <lambdabot>   9
13:25:56 <fizbin> > ap (*) id 3
13:25:57 <lambdabot>   9
13:27:06 <samertm> hey guys
13:27:09 <samertm> I'm new at haskell
13:27:26 <Philippa-> cool, we like newbies
13:27:29 <samertm> but lets say I wanted to make an infinite list of fibonacci numbers
13:27:30 <levi> Sweet, welcome to the club.
13:27:48 <samertm> and I've already defined a function fib n which gives the nth fibonacci number
13:28:05 <samertm> would the list comprehension be:
13:28:31 <samertm> wait
13:28:31 <samertm> xD
13:28:40 <samertm> I messed up, 1 sec
13:29:17 <parcs> > fix $ \fibs -> 0 : 1 : zipWith (+) fibs (tail fibs)
13:29:19 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:29:48 <hiptobecubic> ahhh. everyone's favorite game
13:30:21 <fizbin> Now compute fib(n) in O(log(n))
13:30:48 <samertm> okay my wrong code was:
13:30:50 <samertm> [x | n <- [1,2..], x = fib n]
13:31:03 <permagreen> I think the Fibonacci sequence is the real Hello, World of functional programming
13:31:13 <samertm> but how do I use the n's sequentially in order to get x's?
13:31:35 <levi> permagreen: That or factorial
13:31:36 <toorisugari> [fib n | n <- ...]
13:32:29 <toorisugari> or maybe [... | ..., let x = ...]? I don't use comprehensions so I honestly do not know
13:32:43 <samertm> ah toorisugari, that works
13:32:44 <parcs> fizbin: you can do that?
13:32:56 <samertm> [fib n | n <- [1,2..]]
13:33:23 <samertm> thx lol
13:33:42 <latro`a_> if you solve the recurrence you can get floating point estimates rather fast
13:33:44 <hiptobecubic> [1,2..] == [1..]
13:34:16 <parcs> surely that's not O(log n) though
13:34:26 <latro`a_> sure it is, you can do an exponent to the n in logn time
13:34:26 <parcs> also it's subject to floating point errors
13:34:31 <latro`a_> but yes, it is
13:34:37 <fizbin> parcs: Yep. If you define where 0 is properly there's a formula for fib that works out to something like fib(2n) = fib(n)*fib(n+1) + fib(n)*fib(n-1). I don't remember exactly, but it's something like that.
13:34:49 <latro`a_> ahh
13:34:57 <latro`a_> forgot about that trickery
13:35:07 <fizbin> parcs: Basically, you work with the matrix-multiplication definition of fib(n).
13:35:07 <parcs> is floating point multiplication constant time?
13:35:19 <latro`a_> well, it doesn't really make asymptotic sense
13:35:31 <latro`a_> since floating point multiplication acts on a finite (but large) collection
13:35:56 <latro`a_> but yes, the time to multiply any two floats should be the same independent of the floats
13:36:05 <latro`a_> (at a fixed floating point precision)
13:36:33 <fizbin> Hold on, I did this some time long ago in a livejournal comment. Let me go find it...
13:37:27 <latro`a_>  fibonacci(2n)   = 2*fibonacci(n)*fibonacci(n+1)-fibonacci(n)*fibonacci(n)
13:37:31 <parcs> fizbin: are you referring to http://upload.wikimedia.org/math/9/7/3/9732ee6e87d31947ad30188817128cbe.png ?
13:38:12 <parcs> fizbin: i think that algorithm is still O(n)
13:38:31 <mcstar> newbie gone, nice job
13:39:03 <fizbin> parcs: See http://mirrorlynx.livejournal.com/990.html?thread=3806#t3806
13:39:18 <fizbin> That's O(log(n))
13:40:01 <fizbin> (Well, my fibP version is)
13:40:44 <fizbin> mcstar: He got what he came for, and left on a lol. He'll be back.
13:41:01 <mcstar> yes, nice job...
13:41:21 <mcstar> j/k
13:42:15 <levi> See http://hackage.haskell.org/packages/archive/pointless-haskell/0.0.8/doc/html/src/Generics-Pointless-Examples-Examples.html#fib for some 'pointless' versions of fib.
13:42:26 <levi> Oops, missed.
13:44:31 <NougatRillettes> @pl fix $ \fibs -> 0 : 1 : zipWith (+) fibs (tail fibs)
13:44:31 <lambdabot> fix ((0 :) . (1 :) . ap (zipWith (+)) tail)
13:44:51 <bitonic> NougatRillettes: that’s not pointless
13:45:01 <NougatRillettes> hm ?
13:45:05 <levi> Yeah, but that doesn't use the fun recursion combinators.
13:45:09 <NougatRillettes> I didn't follow what your were saying
13:45:12 <bitonic> NougatRillettes: sorry.  I’m braindead lol
13:45:36 <NougatRillettes> I just wanted to see how bad whould this look ! :D
13:45:50 <fizbin> > fix ((0 :) . (1 :) . ap (zipWith (+)) tail)
13:45:50 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
13:46:17 <fizbin> > fix ((0 :) . (1 :) . ap (zipWith (+)) tail)
13:46:19 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:53:34 <samertm> so I just wrote a recursive function and it ate up all of my ram lol
13:53:55 <samertm> 2.6/2.84 GiB
13:53:55 <Rembane> om nom nom
13:53:58 <samertm> haha
13:54:00 <Rembane> :D
13:54:06 <samertm> oh god
13:54:32 <samertm> ok it finally crashed
13:54:36 <Rembane> What does it do? Except for eating all memory?
13:54:47 <samertm> back todwn to 239MiB / 2.84GiB
13:54:53 <dmwit> fizbin: I believe your O(log n) claim is making a faulty assumption that Integer arithmetic is constant-time...
13:55:03 <samertm> well
13:55:21 <NougatRillettes> @pl \f -> fmap f . swap . fmap f
13:55:22 <lambdabot> liftM2 (.) fmap ((swap .) . fmap)
13:55:28 <johnw> samertm: what it's not doing is evaluating all your expressions :)
13:55:59 <fizbin> No, it's assuming that Integer arithmetic is O(log(log(n))), which is close enough to true, I think. (modulo time for allocating the relevant memory)
13:56:01 <samertm> it was supposed to find the index of biggest fibonacci number smaller than 4 mil, and foldl (+) up to and including that index
13:56:06 <mcstar> ram is cheap these days, you should upgrade
13:56:15 <mcstar> '
13:56:16 <johnw> samertm: try foldl'
13:56:25 <johnw> foldl is almost never what you want
13:56:46 <samertm> oh really?
13:56:55 <johnw> not where math is concerned
13:57:18 <samertm> okay take 2
13:57:55 <miniBill> I'm trying [as an excercise] to come up with a way to represent vector spaces over finite fields
13:57:57 <mcstar> nope, drop 4mil
13:57:58 <toorisugari> > take 2 [1..]
13:58:00 <lambdabot>   [1,2]
13:58:08 <miniBill> but I'm an haskell noob, and I'm confused
13:58:14 <dmwit> fizbin: Wikipedia claims the fastest integer multiplication algorithm is slower than O(n log n) for an n-digit number.
13:58:15 <fizbin> dmwit: If Integer arithmetic is O(log(log(n))), then the algorithm itself is O(log(n)), or at worst O(log(n)^2) since you end up doing O(log(n)) operations on numbers that are O(golden_ratio^n)
13:58:28 <dmwit> *two n-digit numbers
13:58:31 <miniBill> I'd like to define what a vector space is regardless of the field
13:58:52 <dmwit> ?hackage vector-space
13:58:52 <lambdabot> http://hackage.haskell.org/package/vector-space
13:58:57 <johnw> miniBill: any map which uses numbers as the "value" can be taken as a vector space
13:59:00 <miniBill> so I'm probably going for something like this: class (Field a) => VectorSpace a where ....
13:59:04 <johnw> edwardk's linear package will do this for you
13:59:23 <miniBill> dmwit: lemme look ^^
13:59:36 <miniBill> johnw: I'm looking for a learning experience, not for ready-made code ^^
13:59:37 <fizbin> dmwit: Ah, but that's for an n-digit number. If arithmetic is O(n log n) where n is the digits, then it's O(log n loglog n) where n is the number.
13:59:42 <johnw> given x,y :: Map String Int, you can x ^+^ y, x ^* 10, etc.
14:00:02 <johnw> miniBill: oh trust me, learning to use that library will be a definite learning experience
14:00:11 <clahey> dmwit: n log n steps on what machine?
14:00:13 <johnw> in fact, if you are a Haskell noob, you may want to put off trying for a little bit
14:00:25 <edwardk> johnw: hahaha
14:00:30 <miniBill> johnw: I'll look into it then
14:00:36 <parcs> how can integer addition be faster than O(n) ?
14:00:53 <miniBill> johnw: I'm getting my math bachelor in 7 days, might it help? :P
14:00:55 <johnw> edwardk: :)
14:01:01 <johnw> miniBill: sweet!!  you bet
14:01:58 <johnw> miniBill: which field of math?  linear algebra?
14:02:36 <dmwit> fizbin: Surely O(log n loglog n) is not O(log n). =)
14:02:44 <dmwit> (I agree it's a pretty dang small difference.)
14:02:59 <miniBill> johnw: oh, just three years of math, with many different basic courses
14:03:19 <miniBill> parcs: n is the number, not it's size in digits
14:03:22 <johnw> miniBill: my current wish is to really grok what a free object is
14:03:46 <miniBill> johnw: so I got a lot of good linear algebra background :)
14:03:49 <parcs> miniBill: oh, right. i mean when n is the number of digits
14:03:58 <miniBill> johnw: I have never heard of free objects before :)
14:04:02 <miniBill> parcs: it isn't
14:04:05 <fizbin> dmwit: Indeed, fairly small.
14:04:07 <mcstar> ghc is soo limited
14:04:15 <miniBill> parcs: it's O(n log n) if n is number of digits
14:04:16 <johnw> miniBill: did you take any universal algebra?
14:04:28 <miniBill> parcs: which is O(long n log log n) for n number itself
14:04:31 <miniBill> mcstar: orly?
14:04:33 <johnw> miniBill: http://en.wikipedia.org/wiki/Free_object
14:04:34 <mcstar> it either cant construct the infinite type, or cant deduce a type constraint
14:04:36 <miniBill> johnw: nope
14:04:55 <fizbin> miniBill: dmwit's reference said it was slower than O(n log n), though.
14:05:09 <miniBill> johnw: I completely miss category theory, sadly
14:05:27 <dmwit> miniBill, johnw: A "free X" is the X you get when you formally close a set under the operations and equations associated with Xs.
14:05:27 <miniBill> fizbin: w/e, I wasn't debating speed, rather, what n is
14:05:28 <johnw> yeah, but now you have the proper background to understand the examples ;)
14:05:43 <parcs> fizbin: fib(n) has ~n digits, so a bignum algorithm that calculates fib(n) would take at least O(n) time by virtue of you having to allocate an array to hold n digits
14:06:14 <fizbin> parcs: I'll debate the ~n bit, but I will agree that fib(n) has O(n) digits.
14:06:18 <dmwit> miniBill, johnw: Plus a lot of technical details to couch it in category theory in a way that's pleasing to people who don't believe in sets.
14:06:24 * miniBill has category theory in his todo list
14:06:36 <johnw> i don't understand your sentence, but it's a good summary to gnaw on
14:06:38 <miniBill> dmwit: "people who don't believe in sets" lol
14:06:40 <latro`a_> fizbin, it looks like 1.7^n or so, so it has almost n bits
14:06:57 <parcs> fizbin: is this guy wrong, then? http://stackoverflow.com/a/1550208
14:07:09 <mcstar> i dont believe cantor's diagonal argument
14:07:28 <mcstar> infinite sets are a thing of imagination (the wrong kind)
14:07:32 <ab9rf> mcstar: you're not alone
14:07:35 <miniBill> mcstar: you don't?
14:07:44 <miniBill> mcstar: what do you mean by "I don't believe"?
14:07:53 <fizbin> parcs: No. He said fib(n) had O(n) digits. That I agree with. it's just that 0.1 * n is also O(n), but I wouldn't call it "~ n"
14:07:56 <mcstar> im my view, there is no place for that
14:08:04 <miniBill> mcstar: you refuse the existance of sets greater than N?
14:08:18 <johnw> miniBill: is there a larger Bill out there I should be on the lookout for?
14:08:20 <ab9rf> as i recall, cantor's diagonal argument requires the Axiom of Choice
14:08:25 <miniBill> johnw: nope :D
14:08:31 <mcstar> i refuse to call a set that has an ever increasing number of elements
14:08:34 <dmwit> mcstar: You are an ultrafinitist?
14:08:38 <miniBill> ab9rf: iirc it does
14:08:40 <mcstar> yeah
14:08:49 <mcstar> actually, it might not be ultra
14:08:49 <dmwit> I never thought I'd meet one IRL.
14:08:52 <srhb> TIL: Untrafinitists exist
14:08:56 * dmwit makes a note in his calendar about this day
14:09:05 <johnw> mcstar: an intensionally defined set (a -> Bool) cannot be considered a set?
14:09:07 <ab9rf> i kniew they existed but never actually talked to one
14:09:09 <parcs> fizbin: oh ok. but is the claim that no bignum algorithm to calculate fib(n) in O(n) time exists?
14:09:23 <miniBill> mcstar: wow
14:09:25 <parcs> is the claim correct*
14:09:38 <fizbin> parcs: Looks like fib(n) has, when n gets large, about (n / 4.78) digits
14:09:40 * dmwit notes that the people still discussing the fibonacci algorithm are being a bit cagey about what it means to calculate fib(n)
14:10:04 <mcstar> johnw: good question, but that depends on what set 'a' is the element of
14:10:10 <dmwit> data FibNum = FibNum { index :: Integer }; fib :: Integer -> FibNum; fib = FibNum -- look, ma, constant-time!
14:10:11 <johnw> Integer
14:10:23 <ab9rf> hm, i'm finding sources that say that cantor's diagonal proof is independent of AC
14:10:30 <dmwit> I can even do addition. Sometimes.
14:10:38 <parcs> i essentially don't know what i'm talking about, since i never formally understood big O notation
14:10:41 <miniBill> ab9rf: I guess it is because it requires infinite but numerable choices
14:10:53 <mcstar> if i dont accept the notion of there being a set that contains all the integers, ofc, i wont accept a set of functions mapping from them
14:10:56 <miniBill> parcs: big O means "no bigger than, minus constants"
14:11:01 <fizbin> ab9rf: Cantor's diagonalization is in fact independent of the Axiom of Choice.
14:11:04 <parcs> miniBill: that's not formal :P
14:11:11 <ab9rf> yeah, the arguments i just read make that clear
14:11:12 <srhb> parcs: It totally is!
14:11:12 <miniBill> mcstar: do you accept peano algebra?
14:11:18 <mcstar> yes
14:11:28 <mcstar> miniBill: but i like presburger arithmetic better
14:11:41 <ab9rf> now i want a hamburger
14:11:53 <fizbin> Don't the peano axioms depend on this set of things called "Integers"?
14:12:08 <miniBill> parcs: O(f(n)) = {g(n) | \exists b \in \N, c \in \R: g(n) <= c f(n) \forall n > b}
14:12:12 <c_wraith> fizbin: nah, they define natural numbers, not depend on them
14:12:28 <miniBill> fizbin: strictly speaking, no
14:12:31 <parcs> bah, inline latex
14:12:39 <miniBill> parcs: it's not latex
14:12:47 <miniBill> parcs: I didn't \{, nor \mid :P
14:12:52 <miniBill> also, LaTeX
14:13:05 <ab9rf> yeah. that's plain TeX
14:13:40 <miniBill> mcstar: how can you accept peano math and refute N, I'm confused
14:13:48 <srhb> This conversation is derailing faster than the participants can think up new topics on purpose - that's interesting. :P
14:14:06 <fizbin> parcs: Okay, yeah. If you need to account for the costs of bignum arithmetic, then I think the best you can do for fibonacci is O(log(n) * (cost of multiplying two n-digit numbers))
14:14:19 <armlesshobo> what's ~ in  f . g ~(x,y)?
14:14:20 <mcstar> i dont remember peano arithmetic depending on the notion of sets
14:14:27 <mcstar> it is not defined using set theory
14:14:30 <c_wraith> armlesshobo: irrefutable pattern match
14:14:31 <dmwit> ?wiki lazy pattern match
14:14:31 <lambdabot> http://www.haskell.org/haskellwiki/lazy_pattern_match
14:14:37 <miniBill> mcstar: you got a point
14:14:52 <mcstar> or that fancy argument of hilbert maybe, when he uses sets of empty sets to encode them
14:14:55 <mcstar> was that hilbert?
14:15:01 <c_wraith> armlesshobo: it means that it doesn't actually check that the pattern matches - it just assumes it does, until you use one of the values from it
14:15:09 <fizbin> If we take dmwit's reference as given, that means that the fastest fib algorithm is slower than O(n * (log n)^2)
14:15:11 <johnw> armlesshobo: ~(x,y) -> x is equivalent to having written z -> fst z
14:15:38 <latro`a_> mcstar, do you mean von neumann?
14:15:41 <miniBill> mcstar: can't remember. so you're basically saying that math can talk about unbounded but not infinite objects?
14:15:45 <srhb> > let foo (x,y) = 0 in foo undefined
14:15:46 <lambdabot>   *Exception: Prelude.undefined
14:15:50 <srhb> > let foo ~(x,y) = 0 in foo undefined
14:15:52 <lambdabot>   0
14:16:07 <ab9rf> fizbin: i assume you're not counting the constant-time (or nearly so) way of computing fibonacci numbers? :)
14:16:16 <mcstar> latro`a_: maybe, if you are sure, then yes neumann
14:16:27 <latro`a_> as for the truly infinite object, we have a separate axiom that gives an actual infinite set
14:16:36 <latro`a_> the usual axiomatic formulation makes this axiom not redundant to any of the others
14:16:43 <johnw> that is, it doesn't force evaluation of the type the way normal pattern matching does, but rather yields an expression that accesses the desired data at the time you (lazily) need the result
14:16:55 <fizbin> parcs: Though I'll note that for any positive integer k, you can comput the bottom k digits of fib(n) in about O(log(n) * (k log(k)))
14:17:08 <parcs> irrefutable pattern matching is useful for higher order functions, among other things. e.g. compare 'curry g (x,y) = g x y' vs 'curry g ~(x,y) = g x y'
14:17:11 <latro`a_> (that object is the set of all natural numbers, essentially, or more precisely the set of all finite ordinals)
14:17:26 <dmwit> ab9rf: Perhaps you also believe that integer arithmetic is constant time (or, worse, that exponentiation on real numbers is constant time!).
14:17:44 <parcs> fizbin: the bottom k digits are obviously the most useful digits
14:17:46 <latro`a_> > let foo (x,y) = const x y in foo (1,undefined)
14:17:47 <lambdabot>   1
14:17:52 <miniBill> latro`a_: so finitism is not accepting the axiom of infinity?
14:17:56 <ab9rf> dmwit: of course not, but it is very close
14:18:04 <mcstar> miniBill: it doesnt really matter what i believe, but id like to get this sob type right
14:18:10 <fizbin> ab9rf: Either floating point errors make that inaccurate before you reach really interesting n, or you need to account for the costs of your expandable float representation.
14:18:10 <latro`a_> whatever the strictest kind of finitist is, they don't believe in the axiom of infinity
14:18:18 <johnw> armlesshobo: like, ~((x,y),(z,w)) -> if x then y else z, will only cause evaluation of the (z,w) pair when x is true, and only then when the value of that expression is required, whereas ((x,y),(z,w)) will evaluate both the outer tuple and the two inner tuples in order to satisfy the pattern match
14:18:22 <ab9rf> fizbin: now that's a decent point
14:18:47 <fizbin> And once you account for that, you get the same problem I had with my bignum costs.
14:18:59 <miniBill> latro`a_: don't they basically lose everything except algebra and logic that way? :P
14:19:07 <ab9rf> fizbin: what was the lower bound you've come up with?
14:19:23 <latro`a_> miniBill, sort of; you can *describe* how N works without actually having it as an object
14:19:33 <mcstar> also, let us drop proof by contradiction too
14:19:40 <latro`a_> similar to how in ordinary set theory you can *describe* the von Neumann universe even though it's not a set
14:19:43 <parcs> there are only 97 fibonacci numbers that can fit in 64 bits
14:20:22 <mcstar> and probably intiutionistic logic should be taught in schools for children
14:20:25 <mcstar> final word
14:20:52 <latro`a_> the fact that classical logic is not absolute law, at least, should probably be taught sooner
14:21:09 <yitz> parcs: i think i'm going to dump all those fancy memoization algorithms for computing the fibs more quickly.
14:21:12 <latro`a_> perhaps not the details of how other logics work, but just "there's a choice inherent in doing things this way"
14:21:22 <fizbin> ab9rf: Based on the fibP solution in  http://mirrorlynx.livejournal.com/990.html?thread=3806#t3806, if we assume that multiply two n-digit numbers costs O(n log n), we get the limits I talked about ( O((log n)(k log k)) for computing the bottom k digits of fib(n))
14:21:46 <samertm> I don't know why my function loops infinitely
14:22:00 <samertm> if anyone wants to help out
14:22:02 <johnw> samertm: how about showing us?
14:22:02 <fizbin> @hpaste
14:22:03 <lambdabot> Haskell pastebin: http://hpaste.org/
14:22:11 <ab9rf> fizbin: i have no objection
14:22:41 <fizbin> samertm: Put your function on hpaste.
14:22:44 <Taneb> Is there any way to see all the publicly available School of Haskell tutorials?
14:22:51 <johnw> my friend's birthday is on 11/23, and my first thought was about fib
14:22:56 <hpaste> samer pasted “fibonacci” at http://hpaste.org/83940
14:22:58 <Taneb> Aha, just found it
14:23:17 <johnw> samertm: your function has no "base case"
14:23:23 <miniBill> mcstar: I agree that intuitionistic logic should be taught as an alternative
14:23:27 <Cale> samertm: Because it applies fibnotex to the exact same parameters
14:23:29 <miniBill> mcstar: but classical logic is handy :P
14:23:31 <yitz> mcstar: let us assume that we prove a theorem by contradiction. then there is no concrete example of what we are trying to prove, so the proof is neither sufficient nor satisfying; a contradiction. therefore, let us drop proof by contradiction.
14:23:50 <samertm> should I do: then fibnotex x (n+1)?
14:23:54 <Cale> yes
14:23:54 <toorisugari> (fibnotex x n+1) == ((fibnotex x n)+1)
14:23:59 <johnw> fib n just keeps increasing, so if it's not < x on the first round, it never will be
14:24:08 <toorisugari> function application binds tighter than all operators
14:24:12 <samertm> ah
14:24:16 <miniBill> mcstar: my logic course introduced classical logic just when it was absolutely necessary :)
14:24:18 <samertm> so I got my order of operations wrong
14:24:19 <samertm> thanks
14:24:20 <miniBill> mcstar: and I loved it for that
14:24:40 <johnw> Cale: ah, I actually missed that!
14:24:46 <mcstar> great, logic that is
14:25:03 <Taneb> Are there any cool parsing libraries other than parsec, attoparsec and trifecta?
14:25:05 <johnw> Cale: there are days when I wish a lack of whitespace would affect precedence rules
14:25:15 <fizbin> johnw++
14:25:30 <johnw> it would help with lens tremenoudsly
14:25:37 <mcstar> yitz: im trying to convert your proof into Cog, we'll see if it checks out
14:25:48 <yitz> heh
14:25:50 <johnw> how many times i have written f x^.foo x^.bar and then been surprised
14:25:53 <mcstar> j/k
14:25:54 <Cale> Yeah, sometimes that seems like it would be cool, but it would also be quite difficult to spot sometimes as well.
14:26:02 <johnw> Cale true
14:27:02 <ab9rf> every langauge needs a construct that behaves unintuitively
14:27:13 <miniBill> mcstar: btw, my teacher always referred to intuistionistic logic simply as "logic"
14:27:24 <miniBill> mcstar: I think this gives away his thoughts on the matter ^^
14:27:32 <johnw> miniBill: what did s/he call classical logic?
14:27:36 <johnw> ye olde logic?
14:28:15 <mcstar> senior, not old
14:28:17 <mcstar> thats rude
14:28:45 <edwardk> Taneb: frisby is a peg parser, happy gives you a classic lalr. i had a parsimony until someone released parsimony and i stopped working on parsers for 2 years that was me working towards doing parallel parsing
14:29:13 <ab9rf> i'm currently working on a project with a happy parser
14:29:24 <ab9rf> mainly because it's parsing a language for which a yacc parser already exists
14:30:00 <ab9rf> so taking the yacc parser, hacking out its C++ guts, and replacing with haskell was a lot easier than writing a whole new parser in parsec
14:30:25 <Taneb> Huh
14:30:40 <Taneb> Frisby's PM monad isn't an Applicative, even though that module re-exports Control.Applicative!
14:31:26 <miniBill> johnw: simply "classical logic"
14:36:09 * hackagebot smallcheck 1.0.2 - A property-based testing library  http://hackage.haskell.org/package/smallcheck-1.0.2 (RomanCheplyaka)
14:39:34 <tac> "classical" can be used in a somewhat snoody way
14:39:51 <augur> ski: syn
14:40:23 <Philippa-> tac: true, perhaps we should say "counter-intuitionistic" :p
14:40:34 <elliott> "unintuitive logic"
14:40:41 <lispy> I found that this article gave me all manner of relevant context in understanding classical vs. constructive: http://www.andrew.cmu.edu/user/avigad/Teaching/classical.pdf
14:40:46 <tac> maybe "philosophical logic"
14:41:04 <lispy> They're really for different things
14:41:09 <tieTYT> in ghci, how do I get the type of a module's operator?  This gives me an error: :t System.FilePath.(</>)
14:41:11 <tac> "Sure, there.... everything is either 'true' or 'false'... you just can't tell me which. Of COURSE that must be it...."
14:42:05 <lispy> Prelude λ> :t (System.FilePath.</>)
14:42:06 <lispy> (System.FilePath.</>) :: FilePath -> FilePath -> FilePath
14:42:10 <lispy> tieTYT: ^^
14:42:14 <tieTYT> ah ok
14:42:28 <tieTYT> so if my :t has a module name I need the whole thing in parens? or is that just because it's an operator?
14:42:38 <lispy> tieTYT: I suppose the lesson is that the "." in a module name doesn't split up the identifier
14:43:51 <tieTYT> ok
14:50:54 <alpounet> tieTYT, you just need the parens when it's an operator. Actually, if System.FilePath was imported, you would still have to type :t (</>) and not :t </>, to get that function/operator's type
14:56:14 <kylcarte> I have a little module with a series of combinators. Can anyone lend me a hand in spotting/generalizing the pattern? http://hpaste.org/83942
14:58:26 <miniBill> lispy: nice article
14:59:47 <kylcarte> also a short usage example: http://hpaste.org/83945
15:02:28 <wuttf> Is it considered okay to use unsafePerformIO when generating UUIDs
15:02:28 <wuttf> ?
15:03:38 <mauke> wuttf: I don't see how it would be
15:04:01 <wuttf> mauke: How it would be okay or a problem?
15:04:11 <mauke> how it would be okay
15:04:19 <parcs> i would prefer an infinite list of UUIDs, using unsafeInterleaveIO
15:04:19 <mauke> how would you even do that?
15:05:53 <wuttf> I mean I have a graph and I want to give the nodes ids but I obviously don't want  IO in my types, since it is an internal thingie, only used for identity comparison
15:07:03 <mauke> what if ghc decides to inline your functions and all nodes end up with the same id?
15:07:35 <parcs> you would want inlining
15:07:51 <parcs> the thing is GHC tries hard _not_ to inline unsafePerformIO'd things
15:07:59 <wuttf> mauke: Indeed that sounds like a problem
15:08:28 <wuttf> So what is the general consensus in my case?
15:09:08 <wuttf> How can I implement an identity comparison?
15:09:31 * miniBill is puzzled
15:10:14 <miniBill> wuttf: creating a node -> id map?
15:10:17 <c_wraith> why not just use sequential IDs?
15:10:32 <miniBill> wuttf: what c_wraith said ^^
15:10:35 <c_wraith> why does your node ID need to be globally unique across all programs ever run?
15:11:36 <otters> haha yeah, qualified operator names are weird
15:12:12 <wuttf> c_wraith: It must not. Sequential IDs? That would involve IO too, wouldn't it?
15:12:35 <c_wraith> wuttf: nah, you just need to keep track of them where you're creating nodes. I assume that's just in a loop somewhere.
15:13:06 <wuttf> c_wraith: You are so right. Damn, I need to stop coding, started like 16 hours ago
15:13:13 <kylcarte> wuttf: not IO, but some sort of state
15:13:17 <wuttf> My brain is melting.
15:13:34 <c_wraith> wuttf: take a break. It'll feel good. :)
15:18:45 <wuttf> Off to sleep, ty for help, cheers
15:21:07 <danr> I'm a bit curious about the HValue newtype in GHC. It's a wrapper around Any, can I just unsafeCoerce it to the type I expect it to have?
15:21:53 <danr> well I guess I'll have to try
15:38:29 <tgeeky> public ping
15:39:16 <tgeeky> ping
15:39:21 <tgeeky> someone will pong that, surely
15:39:24 <Rembane> pong
15:39:30 <tgeeky> yay
15:40:05 <Rembane> :D
15:41:16 <public`> what?
15:41:38 <tgeeky> mcstar: cute, almost
15:41:46 <mcstar> yeah, little late
15:46:11 * hackagebot retry 0.1.0.0 - Retry combinators for monadic actions that may fail  http://hackage.haskell.org/package/retry-0.1.0.0 (OzgunAtaman)
15:49:33 <miniBill> number param types are hard
15:51:29 <hpaste> miniBill pasted “Question” at http://hpaste.org/83946
15:52:01 <miniBill> my question is: how can I define zeroV in the
15:52:07 <miniBill> instance (Card a) => AdditiveGroup (FiniteElement a)
15:53:10 <miniBill> any ideas?
15:55:39 <geekosaur> not that way, certainly. a is not a value, it's a type
15:55:49 <geekosaur> what were you trying to accomplish there?
15:56:21 <ski> why isn't `field y' used in `lift2' ?
15:58:54 <mcstar> ski: is a general liftM possible, if the function to be lifted is homogeneous in its types?
15:59:27 * geekosaur wonders if "field" is just a type witness, in which case it should be omitted?
15:59:47 <ski> or maybe GADT ?
16:01:11 * hackagebot cipher-aes128 0.2.3 - AES128 using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.2.3 (ThomasDuBuisson)
16:02:49 <ski> mcstar : i suppose if you define `data Op a b = Op b | Arg (Op a (a -> b))', you can probably define `Applicative i => Op a b -> Op (i a) (i b)'
16:03:19 <ski> mcstar : perhaps you could alternatively do some `Printf'-like type class tricks
16:03:40 <mcstar> the 2nd is what id lke
16:03:59 <mcstar> im trying for quite some time now, and cant get it right
16:04:39 <sipa> LOL http://i.imgur.com/NncJ5fI.jpg
16:04:45 <sipa> eh, wrong channel
16:04:57 <mcstar> dr brown
16:05:00 <mcstar> never wrong
16:05:06 <miniBill> geekosaur, ski: it's a type witness
16:05:14 <c_wraith> sipa: I figured you were describing one of the time travel monads.
16:05:22 <miniBill> geekosaur, ski: it's used to make sure that I only add elements of the same field
16:05:34 <geekosaur> miniBill, if you need it, you want to use undefined as the value probably. with that code, all you need is a phantom type, though
16:05:40 <miniBill> geekosaur, ski: I think zeroV = FiniteElement 0 undefined would do
16:05:52 <miniBill> geekosaur: how would I use a phantom type?
16:05:57 <geekosaur> the type signatures are sufficient
16:06:09 <sipa> c_wraith: you'd need mfix to resolve the paradoxal loops
16:06:30 <miniBill> geekosaur: consider that I somehow need the field "number" to make caluclations
16:06:33 <geekosaur> just leave off the field type; even though you don't refer to the type parameter, it is still there (hence "phantom") and the type signatures will force it to match even without a value using it
16:06:46 <miniBill> geekosaur: but I also need to call c2num
16:06:53 <miniBill> geekosaur: which needs a value
16:07:03 <geekosaur> right, but if youre not using field for anything but the type matching, you can omit it so it becomes a phantom type parameter which will still be checked
16:07:19 <geekosaur> but you donbt need to figure out a value for it
16:08:05 <connelly> question: I have a (Float, String) tuple, how do I apply a printf to it correctly?
16:08:20 <geekosaur> so you have data FiniteElement a = FiniteElement Int -- or: data FiniteElement a = FiniteElement { value :: Int }
16:08:26 <miniBill> geekosaur: I've fixed lift2 [and lift]: lift2 f x y = FiniteElement (f (value x) (value y) `mod` (c2num $ field x)) (field x)
16:08:32 <geekosaur> you still have value, but field goes away and the phantim type parameter does it
16:08:36 <mauke> connelly: define "apply a printf"
16:08:43 <miniBill> geekosaur: I actually need the field to call c2num on it
16:10:59 <geekosaur> connelly, there is no printf spec for tuples
16:11:15 <geekosaur> what do you actually want to do?
16:11:50 <geekosaur> miniBill, sorry, I'm not seeing it, maybe someone else can help. (looks to me like phantom type would still work but we're out at the edges of my understanding now...)
16:12:13 <miniBill> geekosaur: I need to somehow extract the field, so I'm unsure if phantom types could be enough
16:12:48 <miniBill> IT WERKS!
16:13:16 <geekosaur> do you actually use it though? if setting it to undefined is sufficient then I'd think just type signatures would handle propagating a phantoom type
16:13:31 <geekosaur> but as I said, my understanding starts getting iffy somewhere around there...
16:14:06 <miniBill> I do use it now
16:14:12 <miniBill> lift2 f x y = FiniteElement (f (value x) (value y) `mod` (c2num $ field x)) (field x)
16:14:17 <miniBill> you see that c2num?
16:14:23 <geekosaur> oh, sorry, missed that one
16:14:37 <geekosaur> I was looking for uses of field but only saw one which seemed to just be propagating it
16:14:40 <miniBill> it wasn't in the original paste tbh
16:14:44 <geekosaur> oh
16:14:58 <miniBill> but yes, I need to use it
16:15:04 <miniBill> even if it's always undefined
16:15:12 <miniBill> oh, the irony
16:15:19 <connelly> how do you do type annotations in let statements? do I put parens around the whole thing?
16:17:37 <tomejaguar> Is there a mailing list for Fay?
16:17:45 <tomejaguar> Or an IRC channel?
16:17:49 <connelly> let prettify x = (printf "%.2f : %s" (fst x) (snd x)):: (Float, String) -> String in
16:18:15 <connelly> thinks I'm returning a (Float, String) -> String, not a String
16:18:42 <parcs> connelly: let prettify :: (Float,String) -> String; prettify (x,y) = printf "%.2f : %s" x y
16:19:42 <latro`a_> you had the typesig on the output, not the function
16:19:50 <latro`a_> @ con
16:19:52 <latro`a_> ...
16:19:53 <latro`a_> connelly,
16:19:59 <latro`a_> too many people in this channel, can't autocomplete anything
16:20:12 <connelly> parcs: thanks!
16:20:23 <geekosaur> miniBill, used but always undefined is normal for a type witness; I just didn't see why you needed one vs. a phantom type
16:20:59 <miniBill> geekosaur: it feels... awkward
16:21:00 <shachaf> Proxy is better!
16:21:11 * hackagebot retry 0.1.0.1 - Retry combinators for monadic actions that may fail  http://hackage.haskell.org/package/retry-0.1.0.1 (OzgunAtaman)
16:21:40 <geekosaur> it is awkward. see what shachaf just said, though; Proxy is still somewhat new but seems to be catching on as a better way to do things
16:22:22 <shachaf> Note that when you use a proxy you usually don't need to name a proxy type explicitly.
16:23:21 <shachaf> @ty let typeRep :: forall proxy a. proxy a -> TypeRep; typeRep _ = typeOf (undefined :: a) in typeRep
16:23:23 <lambdabot>     No instance for (Typeable a1)
16:23:23 <lambdabot>       arising from a use of `typeOf'
16:23:23 <lambdabot>     In the expression: typeOf (undefined :: a)
16:23:34 <shachaf> Cale: Does lambdabot not have ScopedTypeVariables?
16:24:04 <shachaf> @ty let typeRep :: proxy a -> TypeRep; typeRep px = typeOf (unp px) where unp :: proxy a -> a; unp = undefined in typeRep
16:24:06 <lambdabot>     No instance for (Typeable a1)
16:24:06 <lambdabot>       arising from a use of `typeOf'
16:24:06 <lambdabot>     In the expression: typeOf (unp px)
16:24:13 <shachaf> Hmm.
16:24:39 <Cale> shachaf: I'm not sure off hand
16:24:47 <Cale> I can check, I guess
16:24:58 <shachaf> I think a bunch of extensions were lost in the upgrade.
16:25:13 <shachaf> It doesn't print explicit foralls either. And a few other things I can't remember.
16:25:14 <Cale> Oh, that's quite possible
16:25:46 <Cale> One of the few things I did change about the code was to add extensions that people requested at various points.
16:25:47 <shachaf> Oh, wait.
16:25:51 <shachaf> I just missed the constraint.
16:26:02 <shachaf> @ty let typeRep :: forall proxy a. Typeable a => proxy a -> TypeRep; typeRep _ = typeOf (undefined :: a) in typeRep
16:26:03 <lambdabot> Typeable a => proxy a -> TypeRep
16:26:08 <shachaf> So that extension is there.
16:26:13 <shachaf> But I think some other extensions isn't.
16:26:16 * miniBill can't read that...
16:26:39 <shachaf> Cale: I'll mention it if I come across it again. :-)
16:26:43 <latro`a_> that's a variable type constructor?
16:26:54 <shachaf> Yep.
16:27:00 <shachaf> @let typeRep :: forall proxy a. Typeable a => proxy a -> TypeRep; typeRep _ = typeOf (undefined :: a)
16:27:01 <lambdabot>   TypeOperators is not enabled
16:27:03 <latro`a_> neat
16:27:12 <shachaf> Hmm.
16:27:27 <shachaf> Cale: I think @let doesn't allow forall, or something.
16:27:37 <shachaf> Since it uses a different mechanism from @ty
16:28:01 <Cale> ah, yeah
16:28:15 <shachaf> miniBill: Never mind the implementation -- the type is the interesting thing.
16:28:22 <shachaf> First you should understand regular Proxy.
16:28:25 <shachaf> data Proxy a = Proxy
16:28:44 <shachaf> @let typeRep :: Typeable a => proxy a -> TypeRep; typeRep px = typeOf (unp px) where unp :: proxy a -> a; unp = undefined
16:28:46 <lambdabot>  Defined.
16:29:36 <miniBill> shachaf: I need to go, sadly
16:29:41 <miniBill> shachaf: I'll look at Proxy
16:29:48 <shachaf> I recommend going happily instead.
16:32:34 <twomashi> is it possible to free memory in ghci?
16:32:55 <twomashi> ie i want to release one half of a list
16:33:00 <twomashi> cos its using 5gb
16:33:04 <shachaf> I doubt it.
16:33:28 <twomashi> haha me too… Kind of goes against the spirit doesnt it
16:35:33 <dario> twomashi: why is it using 5G? can you make it so that the gc can free that stuff earlier?
16:36:00 <applicative> twomashi: what is in the list?
16:36:07 <shachaf> Perhaps it should first be clarified what is meant by "free".
16:36:26 <Cale> twomashi: make sure there are no references to the list
16:36:32 <applicative> shachaf: it's clear enough what is meant by 'takes too much memory' no?
16:36:52 <shachaf> applicative: No.
16:36:53 <Cale> and then you can performGC if you want to force the GC to happen immediately
16:37:19 <applicative> surely problem is about the organization of the program
16:37:19 <shachaf> Is the question about GCing memory, or is it about returning GCed memory to the operating system?
16:37:24 <Cale> (which is in System.Mem)
16:37:39 <shachaf> Or is it about something else? I can think of a few other things too.
16:38:12 <shachaf> applicative: "the program" is in ghci here, which isn't really meant for serious things anyway.
16:38:24 <twomashi> dario, applicative: just loads of data. would like to know how to free half of it for future reference (as in, no longer reference so that GC releases the memory associated)
16:38:46 <applicative> oh I was about to ask you to hpaste it
16:39:43 * applicative finds the idea of using System.Mem inside ghci a little strange, but what does he know
16:40:57 <twomashi> shachaf: well the first problem would be dereferencing the referenced list
16:41:41 <shachaf> The first problem is to understand the second problem.
16:42:59 <twomashi> i want to reduce the amount of data i am referencing in ghci and have GC kick in to release the memory back to the OS
16:45:29 * applicative wonders what better use twomashi has for this memory than running ghci
16:47:05 <yitz> twomashi: if you bound something huge to a name using let, bind something else to that name.
16:48:02 <hpc> another quick way is to :r
16:48:10 <hpc> which should unbind every non-module name
16:48:39 <yitz> hpc: that's pretty drastic though. :q is the next step
16:48:52 <mcstar> id recommend :D
16:48:57 <hpc> eh, you should be constantly doing :r anyway
16:49:09 <hpc> and doing your development in a file
16:50:01 <hpc> (hilarious thought: release a package as a memory snapshot of ghci; it runs in gdb)
16:50:48 <ski> (it's called an "image")
16:51:05 <shachaf> (What if I called it an `image'?)
16:51:07 <hpc> (my musing have no time for such trifles as correctness!)
16:51:57 <ski> (how about your amusings ?)
16:53:44 <shachaf> I,I apolitically acorrect
16:53:50 <hpaste> benjo pasted “hello” at http://hpaste.org/83954
16:55:15 <darkben> \?
16:55:56 * ski . o O ( <http://www.c64-wiki.com/index.php/I,_Ball> )
16:56:45 <ski> darkben : what about it ?
16:57:47 <darkben> I sorry, only I test hpaste
17:00:20 <darkben> how work hpaste whit irc?
17:00:25 <levi> hpc: Lisp and Smalltalk systems often work that way. To release an application, you load all the code into memory and then serialize your address space to disk and distribute that.
17:01:16 <levi> Thus the amusingly-named (save-lisp-and-die) function.
17:03:12 <darkben> :help
17:03:18 <ski> @wn whit
17:03:19 <lambdabot> *** "whit" wn "WordNet (r) 3.0 (2006)"
17:03:19 <lambdabot> whit
17:03:19 <lambdabot>     n 1: a tiny or scarcely detectable amount [syn: {shred},
17:03:19 <lambdabot>          {scintilla}, {whit}, {iota}, {tittle}, {smidgen},
17:03:19 <lambdabot>          {smidgeon}, {smidgin}, {smidge}]
17:03:37 <ski> darkben : do you have a question ?
17:04:35 <darkben> no no sorry I was trying to test  a few things, I need to read some of irc docs. I dont remember the commands
17:04:37 <darkben> :(
17:04:49 <ski> what are you wanting to do, then ?
17:04:58 <mcstar> there is a command for each character
17:05:06 <mcstar> each character stand for itself
17:05:41 <darkben> well I am trying to see what can do with irc and hpaste
17:06:14 <ski> you can type messages
17:06:35 <ski> and paste things, which hpaste will announce (assuming you have the channel field filled in)
17:06:42 <ski> and you can annotate earlier pastes
17:07:05 <darkben> how I can comment annotate a hpaste script from irc
17:07:09 <darkben> ?
17:07:45 <ski> you annotate in your browser (or an editor)
17:08:06 <darkben> ok, ok not from the irc channel
17:08:29 <mcstar> ski: did you have this in mind? http://okmij.org/ftp/typed-formatting/PrintScan.hs
17:11:41 <ski> mcstar : hm, doesn't look like the `Printf' hack i was thinking of, no
17:11:46 <ski> (though interesting)
17:15:42 <mcstar> nite
17:27:00 <mdmkolbe> Where did Data.HashTable (formerly part of "base") get moved to?  (I'm assuming it was factored into some other package.)
17:28:04 <ion> unordered-containers
17:28:21 <ion> Oh, wait. That was HashMap.
17:28:38 <ion> Anyway, that’s what everyone is using. :-P
17:28:48 <byorgey> Data.HashTable died a slow, inglorious death.  It is gone.
17:29:04 <byorgey> but now there is unordered-containers or hashtables
17:29:48 <alpounet> http://hackage.haskell.org/package/unordered-containers has HashMap
17:29:57 <mdmkolbe> eh, I'm having to port some other code, so I'd like to keep changes minimal
17:30:22 <mdmkolbe> s/some other/someone else's/
17:30:28 <byorgey> well, too bad for you =(
17:35:01 <Shimizoki> I have a homework assignment in which a newtype is defined in one file, and I am trying to access it from another. However it states that the data contructor is not in scope. Why would this be?
17:35:06 <hpaste> Shimizoki pasted “HW 6” at http://hpaste.org/83955
17:38:33 <geekosaur> Shimizoki, exporting the type just exports the type. if you want to export constructors, you need to list them after the type in parentheses (or (..) for all constructors)
17:39:05 <ski> Shimizoki : `Mat' is not exported from module `Matrix'
17:39:53 <Shimizoki>  So how would I export it without breaking the rule in the MatrixAdd.hs file where I cannot change anything above that comment?
17:40:16 <geekosaur> you aren;t changing MatrixAdd.hs
17:40:27 <geekosaur> you change the export list in Matrix.hs
17:40:43 <geekosaur> module Foo (Mytype(..), ...) where ...
17:40:50 <Shimizoki> geekosaur: sorry, but I am not allowed to change that module line either.
17:41:17 <ski>   module Matrix (Matrix (Mat),fillWith,fromRule,numRows,numColumns,at,mtranspose,mmap)
17:41:21 <geekosaur> really?
17:41:39 <Shimizoki> that file also has a "Do not change the above" clause.
17:41:50 <ski> Shimizoki : but that's not "above" that comment line in `MatrixAdd.hs' ..
17:41:54 <ski> mhm
17:43:03 <Shimizoki> ski: my apologies I didn't display the whole file of matrix.hs because it was long and I felt everything else didnt need to be displayed, I should have shown that line too. It is in both files.
17:43:51 <ski> then perhaps you can make do with the provided exported operations ..
17:44:47 <Shimizoki> I am thinking that must be the case, however I do not see how I can get the values in the datatype without the use of constructors.
17:45:11 <ski> presumably `numRows' and `numColumns' can be used to implement `sameShape' ?
17:45:43 <ski> .. and `at' for accessing elements of input matrices in `pointwiseApply'
17:46:04 <ski> perhaps `fillWith' or `fromRule' can be used to create new matrices ?
17:46:35 <Shimizoki> ski: I see... I wasn't expecting to have to use all those functions. thats something the professor has not made us do yet.
17:47:41 <ski> btw, tell your laboration creator that `sameShape :: (Matrix a) -> (Matrix a) -> Bool' can be simplified to `sameShape :: Matrix a -> Matrix a -> Bool' (and similarly for the other type signatures)
17:48:23 <Shimizoki> ski: you mean that the () can be dropped?
17:48:55 <Shimizoki> He knows that, however he left them there so that its easier to read for us.
17:49:13 <Shimizoki> He does that quite often adding extra parenthesis.
17:49:17 <ski> yes, except for the ones for `(a -> a -> b)' in `pointwiseApply'
17:50:07 <ski> (fwiw, it makes it harder to read for me, because i'm hung up at them ;)
17:50:42 <Shimizoki> ski: we cant all be as awesome as you :P
17:50:52 <ski> btw, i suspect your definition of `add' is incorrect
17:51:28 <Shimizoki> ski: it probably is. I am supposed to build off pointwiseApply, however until I can get that working... I cant really test add.
17:53:14 * ski idly wonders what `pointwiseApply' is supposed to do when the two given matrices have different shapes
17:53:59 <Shimizoki> ski: its supposed to return an error, but Im not there yet. I dont see how it can unless the return type is Maybe b or something like that
17:54:47 <ski> @type error
17:54:49 <lambdabot> [Char] -> a
17:55:04 <ski> > 3 + error "oops"
17:55:05 <lambdabot>   *Exception: oops
17:55:13 <zaltekk> hey guys. i just installed ghc and cabal. trying to install yesod-platform with cabal. it errors out because it can't find happy >= 1.18.5
17:55:15 <ski> > "lala" ++ error "oops"
17:55:18 <lambdabot>   "lala*Exception: oops
17:55:19 <zaltekk> but happy is installed and is in my path
17:55:42 <zaltekk> what else could cause this issue? do i need to edit cabal's configuration for it to properly find happy?
17:55:57 <zaltekk> right now my shell rc file adds ~/.cabal/bin to my path
17:56:06 <Shimizoki> ski: but those arent matricies... and thats what is supposed to be returned, less I am missing something
17:56:54 <ski> Shimizoki : `error "oops"' can be a matrix as well
17:58:03 <geekosaur> zaltekk, have you verified it's an appropriate version?
17:58:11 <zaltekk> geekosaur: yes. it's 1.18.10
17:58:28 <geekosaur> Shimizoki, see the type of "error" above, it's got an unconstrained result type
17:58:40 <geekosaur> (and indeed, anything with that type must throw an exception)
17:59:13 <ski> @type \"" -> fix id
17:59:15 <lambdabot> [Char] -> a
17:59:21 <geekosaur> or otherwise fail to produce a valye
17:59:50 * ski boings happily
17:59:53 <Shimizoki> I understand. I still cant get passed this "No Constructor" think
18:00:28 <ski> Shimizoki : if `Mat' isn't exported, then you can't pattern-match on it, no
18:01:49 <Shimizoki> ski, so then I dont see a way to create a new matrix in which its rule is the "op" of the passed in rules.
18:02:18 <ski> Shimizoki> :t fillWith
18:02:24 <ski> Shimizoki> :t fromRule
18:02:42 <Shimizoki> but how do I get the two rules from the passed values?
18:03:19 <Shimizoki> or are you saying I can do that by using fromRule?
18:03:22 * ski has no idea what Shimizoki means by "rule"
18:03:49 <ski> i'm not saying anything atm, i'm just asking you for the types of two operations
18:04:27 <Shimizoki> ski: eek, my apologies. "rule" is the second parameter in the tuple in the matrix constructor. (the function (Int,Int) -> a)
18:05:21 <marisa_reddy12> anyone every try to make a neural network using haskell?
18:05:39 <ski> i think so
18:06:01 <ski> (i don't recall who, though)
18:06:50 <marisa_reddy12> got it...thans
18:06:52 <marisa_reddy12> *thanks
18:07:06 <copumpkin> alpounet was
18:09:00 <alpounet> marisa_reddy12, http://github.com/alpmestan/hnn is mine (you can see the docs at http://alpmestan.com/hnn/doc/ if you're interested), there's also "instinct" and "HaskellNN" that may be suitable, and a binding to the fann C library -- its API sucks though
18:09:49 <marisa_reddy12> thanks, alpounet
18:12:38 <mgaogw> what are some good resources to learn about category theory?
18:14:05 <lispy> mgaogw: Do you want text books, videos, blog posts, exercises, or course work?
18:14:05 <ski> mgaogw : perhaps "Conceptual Mathematics" by Lawvere and Schanuel ?
18:14:21 <ab9rf> pick a category
18:14:35 <mgaogw> videos and blog posts would be best
18:15:27 <lispy> mgaogw: http://www.youtube.com/user/TheCatsters
18:15:48 <lispy> mgaogw: the hard part with their videos is figuring out what order to watch them. I heard a rumor that someone figured it out.
18:16:25 <mgaogw> lispy: haha, cool thanks! which order did you watch them in?
18:16:44 <lispy> mgaogw: I haven't watched them :) This blog gives a hint: http://golem.ph.utexas.edu/category/2007/09/the_catsters_on_youtube.html
18:17:28 <mgaogw> lispy: thanks!
18:21:52 <A2kmm> I am getting undefined reference errors when linking code with ghc-7.6.1 and ghc-7.6.2; this happens even if I only build the code once, and is consistently reproducible after a clean build.
18:22:02 <A2kmm> Is this a known issue?
18:22:31 <lispy> A2kmm: someone was here just this week with a problem that fit that description but it was due to an error in the .cabal file
18:22:42 <lispy> A2kmm: So, without more information it's hard to say.
18:22:43 <A2kmm> (reproducible for my program, I can compile other things with ghc BTW)
18:23:13 <A2kmm> Well, it happens for this codebase: https://github.com/A1kmm/declarative-fieldml-prototype
18:23:28 <lispy> A2kmm: In the other person's case it was because they forgot to list something as an exposed module in the library section and then the executable was trying to import that same module
18:23:32 <A2kmm> Error look like: undefined reference to `declarativezmfieldmlzmprototypezm0zi0zi1_DataziFieldMLziInitialModel_biSrcSpan1_closure'
18:23:46 <lispy> preflex: zdec declarativezmfieldmlzmprototypezm0zi0zi1_DataziFieldMLziInitialModel_biSrcSpan1_closure
18:23:46 <preflex>  declarative-fieldml-prototype-0.0.1_Data.FieldML.InitialModel_biSrcSpan1_closure
18:24:03 <parcs> A2kmm: you don't have an other-modules field
18:24:04 <levi> Heh, I've had that happen too.
18:24:38 <A2kmm> Ah... I think Cabal needs to give better diagnostics in that case.
18:24:42 <lispy> A2kmm: yeah, looks like the same problem.
18:25:05 <lispy> A2kmm: It may already have them, try turning up the version of cabal: cabal-version:      >= 1.8
18:25:11 <lispy> A2kmm: try setting that to 1.16
18:25:19 <lispy> It may actually notice this problem (but I'm not confidentt)
18:28:13 <A2kmm> It seems that I still don't get a Cabal error about the issue with >= 1.16
18:28:36 <A2kmm> but adding other-modules: Data.FieldML.InitialModel fixed the undefined symbols problem.
18:28:40 <lispy> Ah, in that case I agree that the (much needed) diagnostics are missing :)
18:29:38 <tieTYT2> i'm reading the cabal guide right now so it may answer this, but if I download a package, how do I make it accessible inside ghci for exploring how to use it?
18:30:23 <dmwit> tieTYT2: unpack it, cd into the directory, and type "cabal install"
18:30:24 <A2kmm> tieTYT2: If you do cabal install, you should just be able to import it.
18:30:25 <dmwit> for most packages
18:30:38 <A2kmm> (after you restart ghci)
18:30:47 <dmwit> tieTYT2: But cabal can also download the packages for you, so usually people skip the "download and unpack" step and just type "cabal install name-of-package".
18:31:30 <tieTYT2> does that mean any .hs file I create after that will be able to say import Thing.I.Downloaded.With.Cabal and compile?
18:31:56 <dmwit> yes
18:33:01 <tieTYT2> that's kind of weird to me.  In java, if you use maven, you're only downloading for that project, not every project.  How do you handle wanting to use lib1 in project1 and lib2 in project2, but those libraries conflict with each other?
18:33:50 <mgaogw> i'm having difficulty with cabal install itself - I have ghci (GHCi, version 7.4.2) on my mac, but I can't install anything. when I run cabal update in terminal, I'm prompted with "Note: there is a new version of cabal-install available.
18:33:50 <mgaogw> To upgrade, run: cabal install cabal-install", but when I run this command it fails (cabal-install-1.16.0.2 failed during the building phase. The exception was:
18:33:51 <mgaogw> ExitFailure 1) any ideas?
18:34:33 <tieTYT2> mgaogw: maybe this? http://www.haskell.org/cabal/FAQ.html#exitfailure-1
18:34:37 <tieTYT2> it's on the cabal faq
18:35:05 <dmwit> tieTYT2: Conflict in what way?
18:35:47 <dmwit> mgaogw: Can you give the full output, say, on hpaste? You should also try running a higher verbosity -- say, -v, -v2, or -v3
18:35:48 <tieTYT2> well the faq brings up some situations.  One lib may depend on something that requires libx v2.  The other lib may depend on something that requires that same libx v3
18:36:26 <dmwit> You can install many versions of a library at once, no problem there.
18:36:37 <dmwit> There are problems, to be sure, but they're not so simple as that. =)
18:36:48 <lispy> tieTYT2: I use cabal-dev to make cabal-install a bit more maven-like
18:37:04 <tieTYT2> lispy: hrm, I see
18:37:05 <mgaogw> I'm new to IRC and haskell, what is hpaste? Here is the output when I just tried to install the HTTP library good from Hackage using cabal:
18:37:17 <tieTYT2> mgaogw: hpaste.org  a website
18:37:26 <mgaogw> Resolving dependencies...
18:37:27 <mgaogw> Configuring HTTP-4000.2.8...
18:37:28 <mgaogw> Building HTTP-4000.2.8...
18:37:30 <mgaogw> Preprocessing library HTTP-4000.2.8...
18:37:31 <mgaogw> <command line>: cannot satisfy -package-id mtl-2.1.2-02e701f9b1590ee88a0b5b0bd5d93a29
18:37:33 <mgaogw>     (use -v for more information)
18:37:34 <mgaogw> cabal: Error: some packages failed to install:
18:37:35 <mgaogw> HTTP-4000.2.8 failed during the building phase. The exception was:
18:37:36 <mgaogw> ExitFailure 1
18:37:43 <dmwit> Not in-channel, please.
18:37:46 <yitz> @where hpaste
18:37:46 <lambdabot> http://hpaste.org/
18:37:49 <tieTYT2> lispy: i see, well I guess I'll read about that in the guide
18:38:32 <dmwit> tieTYT2: Also, packages generally *are* installed per-project, so to speak: you must specify which packages (and at which versions) your new package or executable will use when you make its cabal file.
18:38:42 <hpaste> mgaogw pasted “cabal stuff” at http://hpaste.org/83956
18:38:44 <lispy> tieTYT2: It's a separate tool so you won't find it there. Someone made a reddit post about it.
18:38:47 <dmwit> Only one-offs (in their own .hs file) see the global set of packages.
18:38:56 <yitz> lispy: trying to expand use of haskell at our company. cabal-dev is basic for us. i really really need it on hackage.
18:39:16 <dmwit> mgaogw: What does ghc-pkg check say?
18:39:25 <lispy> yitz: it is on hackage
18:39:42 <yitz> lispy: oh? it's updated finally?
18:39:42 <tieTYT2> dmwit: yeah but isn't that file only used for other people to download your package?  I assumed that runghc doesn't read the .cabal thing
18:39:43 <lispy> tieTYT2: this is a bit dated now, but someone wrote this up a while ago: http://www.reddit.com/r/haskell/comments/f3ykj/psa_use_cabaldev_to_solve_dependency_problems/
18:40:00 <tieTYT2> lispy: thanks
18:40:06 <dmwit> tieTYT2: Correct, runghc doesn't read the .cabal file. But no, it is not used only for other people to download your package.
18:40:23 <lispy> yitz: http://comments.gmane.org/gmane.comp.lang.haskell.cafe/103731
18:40:37 <lispy> yitz: Looks like creswick did the upload on Feb. 28th
18:40:44 <yitz> yay!
18:41:08 <yitz> thanks! pls thank creswick too.
18:41:16 <lispy> yitz: will do :)
18:41:35 <lispy> yitz: Do you follow any of G+, reddit, haskell-cafe, etc?
18:41:42 <hpaste> mgaogw pasted “ghc-pkg check” at http://hpaste.org/83957
18:41:49 <lispy> yitz: we tried to announce it but sometimes we just don't post things were people look
18:42:57 <tieTYT2> lispy: I'm a real haskell newb.  You think it's ok to learn cabal and then look into cabal-dev when I run into dependency-hell?
18:42:58 <yitz> lispy: have gotten way behind with cafe lately, too busy. and not on g+. been sticking mostly to reddit and here.
18:43:08 <yitz> got to get back to checking cafe more often
18:43:08 <mgaogw> dmwit: so ghc-pkg check says my cache is out of date. think this is the issue?
18:43:51 <dmwit> mgaogw: No. It sounds like you've done something funny that overwrote mtl. What's the full output of ghc-pkg check?
18:44:27 <mgaogw> that was the full output...
18:45:15 <dmwit> huh
18:45:39 <dmwit> Well, I suggest cranking up the verbosity on cabal install until it says something useful, then.
18:46:37 <mgaogw> how, exactly? thanks for your help!
18:48:44 <mgaogw> jk - got it
18:52:55 <Shimizoki> If I have 2 function a (a = (\val -> 3+val)) and b (b = (\val -> 5+val)) is there a way to do (a + b) without passing the parameter val?
18:54:22 <dmwit> ?pl \val -> a val + b val
18:54:22 <lambdabot> liftM2 (+) a b
18:54:54 <dario> let a = \x -> x+2
18:54:55 <dario> let b = \y -> y + 4
18:55:00 <dario> (a . b) 4
18:55:10 <Shimizoki> dmwit: that is what I am using, however it is giving me an error due to  having not passed val
18:55:11 <XexonixXexillion> remember to import Control.Monad and Control.Monad.Instances
18:55:41 <dmwit> I don't believe you. (No offense.)
18:55:55 <lispy> yitz: I can't keep up with -cafe either :( I'll make sure we put something on reddit next time
18:55:57 <Shimizoki> dmwit: thats fine, I dont believe me either, I'll Hpaste it
18:56:11 <XexonixXexillion> > let a = \x -> x + 2 in let b = \y -> y + 4 in (a . b) 4
18:56:13 <lambdabot>   10
18:56:16 <lispy> yitz: hopefully cabal-install will add sandboxing and we won't need need more cabal-dev :)
18:56:26 <yitz> ok tnx. i'm posting to reddit right now.
18:56:33 <yitz> lispy: right :)
18:57:03 <lispy> tieTYT2: If you're used to maven you might find cabal-dev conceptually easier. Otherwise, cabal is a bit easier to understand but dependency hell is easy to trip over.
18:57:26 <hpaste> “Anonymous Coward” annotated “HW 6” with “HW 6 (Revised)” at http://hpaste.org/83955#a83958
18:57:30 <tieTYT2> lispy: I can just uninstall packages at that pint right?
18:57:49 <dmwit> ah... that you can't do
18:58:34 <Shimizoki> dmwit: how would I achieve a similar result?
18:58:50 <dmwit> s/that/uninstall packages/
18:59:00 <tieTYT2> why not?
18:59:21 <dmwit> Because nobody's paying dcoutts to hack on cabal. =P
18:59:52 <hpaste> Shimizoki revised “HW 6 (Revised)”: “HW 6 (Revised) EDIT” at http://hpaste.org/83958
19:00:38 <lispy> tieTYT2: yes
19:01:07 <lispy> tieTYT2: the command is non-obvious though
19:01:22 <joshcheek> Hi, I have a string (a line from the output of `ps -eo "pid user"` which I want to get the words out (delimited by unknown amounts of whitespace). In Ruby, I would do `line.strip.split(/\s+/)`, I skimmed through Data.Text but it seems like Haskell can only split on substrings, and I don't know how much whitespace there will be. I tried looking up regular expressions http://www.haskell.org/haskellwiki/Regular_expressions but there doesn't appear to be a
19:01:23 <joshcheek> standard, and I have no clue which one to choose. Could anyone give me a hint? This feels really simple for me to be stuck on. (currently, I'm doing an almost procedural process of anonymous functions + strip and breakOn https://gist.github.com/JoshCheek/5148805)
19:01:26 <lispy> tieTYT2: it's something like: ghc-pkg unregister --user foo
19:01:30 <yitz> dmwit: i don't think an uninstall feature was ever very high up on the priority list, even if dcoutts was being paid to hack on cabal.
19:01:52 <Shimizoki> dmwit: If I had access to (Mat) I think I may be done in no time... but I dont.
19:01:55 <lispy> tieTYT2: and often times you need to add --force and you can only specify one package per invocation of the command. /me needs to write a script.
19:02:07 <tieTYT2> ok thanks
19:02:16 <dmwit> Shimizoki: Sorry, it's bedtime; I hope somebody else can help you.
19:02:25 <Shimizoki> thats fine, thank you.
19:02:40 <yitz> you just use ghc-pkg unregister and leave the dead code lying around, or you track down the dead code and delete that too manually, or if things get really messed up, you just reinstall ghc/hp.
19:04:09 <yitz> > words "different    amounts of   white space"
19:04:11 <lambdabot>   ["different","amounts","of","white","space"]
19:04:16 <yitz> joshcheek: ^^
19:04:30 <yitz> joshcheek: and Data.Text.words for text
19:05:48 <eflister> is there an arrowy way to write (a->b,a->b) -> (b->c,b->c) -> (a,a) -> (c,c)
19:07:06 <yitz> joshcheek: regexps are less used in haskell. there is words, lines, a few other simple functions in Data.List and Data.Text, and there is the split library. For anything more complicated, we tend to use a parser combinator library like Parsec or Attoparsec rather than regexps.
19:07:33 <yitz> joshcheek: that said, there are also regexp libraries with several dialects of regexps supported, too.
19:09:00 <joshcheek> lambdabot: yitz: Thank you. That's what I was looking for. I'm still scared of parsing, though >.< that's the chapter I gave up on Programming in Haskell. I guess once I understand the language better, it won't be so daunting.
19:09:21 <ski> @botsnack
19:09:21 <lambdabot> :)
19:09:45 <yitz> joshcheek: not so hard, just a little different than regexps. and a *lot* nicer, in my opinion. worth giving another try.
19:10:02 <joshcheek> :)
19:10:11 <tieTYT2> i got this error installing curl.  What am I doing wrong? http://hpaste.org/83961
19:10:26 <jfischoff> joshcheek: I concur with yitz. Parsing in Haskell is the best
19:10:46 <tieTYT2> i don't know where it put the config.log either
19:12:18 <tieTYT2> i searched my whole hd for it
19:13:46 <arkeet> tieTYT2: "configure: error: curl libraries not found, so curl package cannot be built"
19:13:48 <arkeet> seems clear enough
19:14:03 <croikle> probably config.log is in some temp dir
19:14:08 <arkeet> you need to install dev packages for curl
19:14:19 <arkeet> something like "libcurl-dev"
19:14:40 <tieTYT2> i'd figure the dependency management feature would have done that for me
19:14:53 <tieTYT2> but ok
19:14:57 <arkeet> no
19:15:01 <arkeet> not a haskell package
19:15:20 <tieTYT2> oh well I found this on hackage: http://hackage.haskell.org/package/curl
19:15:31 <tieTYT2> i don't really know what I'm doing, but I think I want curl because I want to get the html of a url
19:15:31 <arkeet> no, there's a native library you need to install.
19:15:33 <ski> Shimizoki : btw, you didn't answer my two questions ..
19:15:37 <tieTYT2> oh ok
19:15:52 <croikle> the hackage curl is just the haskell bindings to the library
19:15:55 <arkeet> but if you just want to do http stuff, there are native haskell libraries for that too.
19:16:04 <arkeet> say http-conduit
19:16:09 <Shimizoki> sorry ski, I think I just solved my issue. But please, if you are curious restate your questions and I will answer them to the best of my ability
19:16:13 <tieTYT2> conduit huh? ok i'll look into that
19:16:16 <arkeet> @hoogle simpleHTTP
19:16:16 <lambdabot> Network.HTTP.Stream simpleHTTP :: Request_String -> IO (Result Response_String)
19:16:16 <lambdabot> Network.HTTP simpleHTTP :: HStream ty => Request ty -> IO (Result (Response ty))
19:16:16 <lambdabot> Network.HTTP.HandleStream simpleHTTP :: HStream ty => Request ty -> IO (Result (Response ty))
19:16:28 <arkeet> oh well.
19:16:30 <arkeet> that's from HTTP.
19:16:35 <tieTYT2> that looks easy
19:16:48 <arkeet> @hoogle simpleHttp
19:16:48 <lambdabot> Network.HTTP.Stream simpleHTTP :: Request_String -> IO (Result Response_String)
19:16:48 <lambdabot> Network.HTTP simpleHTTP :: HStream ty => Request ty -> IO (Result (Response ty))
19:16:48 <lambdabot> Network.HTTP.HandleStream simpleHTTP :: HStream ty => Request ty -> IO (Result (Response ty))
19:16:52 <arkeet> bah.
19:16:58 <arkeet> http-conduit's simpleHttp is simpler.
19:17:01 <ski> Shimizoki> :t fillWith
19:17:03 <ski> Shimizoki> :t fromRule
19:17:14 <arkeet> but of course you can have more flexibility than that.
19:17:41 <tieTYT2> i prefer easy
19:17:53 <tieTYT2> is simpleHttp a library or is it built in?
19:18:09 <hpaste> Shimizoki annotated “HW 6” with “HW 6 (Solution)” at http://hpaste.org/83955#a83962
19:18:21 <arkeet> it's a function from http-conduit
19:18:35 <Shimizoki> ski, that new paste should answer both questions
19:19:56 <ski> i see
19:21:53 <ski> you don't need the brackets in `sameShape'
19:22:30 <ski> otherwise it looks ok
19:25:04 <Shimizoki> ski, do you see a better way to do pointwiseApply?
19:26:09 <ski> not really
19:26:19 <ski> i suppose you could use guards, if you wanted to
19:26:52 <Shimizoki> ski: is there any reason in particular that I would want to?
19:27:52 <ski> depends on your taste
19:31:15 * hackagebot lagrangian 0.5.0.0 - Solve Lagrange multiplier problems  http://hackage.haskell.org/package/lagrangian-0.5.0.0 (JonathanFischoff)
19:32:34 <yitz> @type \x -> uncurry (***) . flip (uncurry (***) . ((.) *** (.))) x -- eflister
19:32:36 <lambdabot> (Functor (a b'), Functor (a b), Arrow a) => (a b a1, a b' a2) -> (a1 -> c, a2 -> c') -> a (b, b') (c, c')
19:34:03 <yitz> eflister: kind of a weird order of the arguments in your type. that made it harder.
19:36:03 <parcs> why would i want to solve lagrange multiplier problems?
19:36:32 <ben22> it's good for your soul
19:38:36 <jfischoff> parcs: Yeah I don't know. Its part of the maximum entropy package I'm making
19:38:41 <yitz> eflister: ah >>> could probably help a little. instead of (.)
19:39:37 <jfischoff> parcs: its a simple nontrivial example of using the ad package if nothing else.
19:39:46 <ben22> what is a "denotational compiler" in Haskell?
19:42:25 <yitz> @type \x -> uncurry (***) . (uncurry (***) . ((>>>) *** (>>>))) x -- eflister
19:42:27 <lambdabot> Arrow a => (a b b1, a b' b2) -> (a b1 c, a b2 c') -> a (b, b') (c, c')
19:42:40 <yitz> eflister: in short - i wouldn't use arrow stuff for this :)
19:43:44 <ivanm> @type (>>>)
19:43:45 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
19:43:59 <yitz> ivanm: flip (.)
19:44:01 <ivanm> @type \x -> uncurry (***) >>> (uncurry (***) >>> ((>>>) *** (>>>))) x
19:44:03 <lambdabot>     Couldn't match expected type `a0 (b0, b'0) (c1, c'0) -> c0'
19:44:03 <lambdabot>                 with actual type `((b'1, c3) -> (b1, c3), (c'1, c4) -> (c2, c4))'
19:44:03 <lambdabot>     In the return type of a call of `uncurry (***)
19:44:07 <ivanm> oh, flip (.), doh
19:44:14 <ivanm> I was trying to get more arrows in that type sig :p
19:44:22 <ivanm> @type \x -> uncurry (***) <<< (uncurry (***) <<< ((>>>) *** (>>>))) x
19:44:24 <lambdabot> Arrow a => (a b b1, a b' b2) -> (a b1 c, a b2 c') -> a (b, b') (c, c')
19:44:30 <ivanm> awww
19:44:47 <yitz> oh cool
19:46:41 <ivanm> so I tried to build GLURaw; Cabal says "missing C library: GLU" yet I have /usr/lib/libGLU.so right there! :@
19:47:59 <ivanm> preflex: seen lispy
19:48:00 <preflex>  lispy was last seen on #haskell 46 minutes and 5 seconds ago, saying: tieTYT2: and often times you need to add --force and you can only specify one package per invocation of the command. /me needs to write a script.
19:48:25 <croikle> do you need the dev headers as well?
19:48:45 <ivanm> they should be there; this is a source-based distro!
19:49:13 <ivanm> yup, /usr/include/GLU/glu.h
19:49:18 <ivanm> * GL/glu.h
19:49:39 <yitz> ivanm: try --verbose
19:49:41 <Shimizoki> Thank you everyone for your continued help.
19:49:57 <ivanm> yitz: this isn't using cabal-install, though I'll try with that just to see if it works
19:50:15 <yitz> ivanm: i'd use cabal-dev but ok
19:50:18 <ivanm> (my package manager is calling runhaskell Setup.hs)
19:50:46 <ivanm> OK, even "cabal configure --verbose" fails with the same error
19:50:59 <ivanm> and the standard error message :@
19:51:10 <yitz> but no info about exactly which files it was looking for?
19:51:43 <ivanm> oh, --verbose=3 says something: undefined reference to `glEvalCoord2f'
19:52:03 <ivanm> and a whole bunch of other undefined reference errors from libGLU.so :/
19:52:05 <yitz> ah you may have a version problem
19:52:49 <ivanm> yeah, I recently upgraded my nvidia drivers, which has a new version of OpenGL
19:53:50 <newsham> is there a package that evaluates an expensive mconcat across multiple cores of a multi-core processor?
19:54:34 <yitz> newsham: mconcat is a method. you'd need to implement that separately for each instance of Monoid.
19:54:56 <ivanm> unless you just used the default
19:55:04 <ivanm> @src mconcat
19:55:04 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
19:55:13 <ivanm> isn't it just foldr mappend mempty ?
19:55:57 <yitz> ivanm: yeah but if newsham wants to optimize across cores, that would probably by after optimizing mconcat, which is often significant
19:56:06 <ivanm> *nod*
19:56:33 <ivanm> yitz: unless the fun is that there's a version error with the Haskell library, which doesn't like the version of OpenGL, etc. I have :s
19:57:03 <yitz> ivanm: actually that's probably what is happening. sorry.
19:57:15 <ivanm> oh hooray...
19:57:21 <yitz> ivanm: the good news is that you're the maintainer of the library
19:57:27 <ivanm> no I'm not...
19:57:32 <yitz> no?
19:57:44 <yitz> oh well.
19:57:46 <ivanm> lispy and Sven Panne is
19:57:55 <ivanm> *are
19:58:43 <newsham> yitz: one could define an mconcat operation that works on any list of monoids
19:58:54 <newsham> and one could do it in a way that parallelized the work across multiple cores
19:58:57 <vu3rdd> I am not sure if this is off topic. Haskell newbie here. Trying to watch the videos posted on Prof. Wadler's blog today but getting an error on flash player version. Did anyone else face the problem? Have got flash plugin v11.x installed and working perfectly..
19:59:24 <newsham> using mappend and mempty, without using the default mconcat definition
20:00:36 <yitz> newsham: yes. but that generic mconcat is usually pretty bad. not clear you'll make that all back with the parallelization. better to figure out on a type by type basis how to mconcat and also parallelize if possible.
20:01:43 <ivanm> vu3rdd: WORKSFORME, though it's rather annoying that they use flash for it
20:02:01 <newsham> yitz: even across 8 cores?
20:02:28 <vu3rdd> ivanm: Hmm.. I am on GNU/Linux + Chrome.
20:02:29 <newsham> generic mconcat is going to be 8x slower than writing a reducer by hand?
20:02:33 <yitz> newsham: hard to say. may depend on the type.
20:02:50 <yitz> yeah it can be pretty drastic
20:02:56 <ivanm> vu3rdd: GNU/Linux + Firefox; maybe the new pepper-based flash has a problem?
20:04:25 <yitz> newsham: e.g. for text or bytestring, generic will copy repeatedly for O(n^2), whereas the type-specific mconcat will just concat it all once for O(n).
20:04:51 <vu3rdd> ivanm: I will try Firefox. I tried disabling the pepper based flash and enabled the other flash plugin (flashplugin-nonfree).. still the same. Thanks, I will try firefox.
20:04:55 <newsham> bytestring seems fairly atypical.  it doesnt even really "reduce"
20:05:05 <newsham> most monoids reduce down to a smaller amount of data
20:06:36 <vu3rdd> ivanm: Cool, firefox worked!
20:06:41 <yitz> newsham: dunno i use the monoid instance for text and bytestring probably more than any other. anyone, as i said, ymmv.
20:07:08 <yitz> *anyway
20:08:02 <yitz> newsham: now, if you're on a T2 with 60 cores... but still, if it's asymptotically worse...
20:10:52 <newsham> yitz: i wouldnt recommend parallelizing your bytestring joins
20:11:04 <yitz> fair enough
20:11:05 <newsham> but there are a lot of easily parallelized map-reduce style jobs
20:12:19 <newsham> was just hoping i could easily recast my current job in the form of a monoid and get magic parallel
20:12:48 <ivanm> @ask lispy as you're (one of) the maintainer of GLURaw, would you know why my attempt at building it has configure errors looking like "/usr/lib64/gcc/x86_64-pc-linux-gnu/4.7.2/../../../../lib64/libGLU.so: undefined reference to `glEvalCoord2f'"? is my version of (C) opengl too new/old?
20:12:48 <lambdabot> Consider it noted.
20:30:16 <fluffynukeit> Hi all.  Is there a modern library that can render html and javascript as a GUI front end?  Preferably compilable on Win7 Haskell Platform.  I have a snap server backend using Ji and I want an integrated GUI and not rely on Firefox.
20:30:16 <dashster18> hey
20:30:32 <dashster18> what are the benefits of learning haskell?
20:31:34 <parcs> blood flow to the brain increases by 20%
20:32:04 <dashster18> Fair enough :p
20:32:09 <dashster18> How should I go about learning it
20:32:26 <dashster18> Right now I'm doing the tutorial on learnyouahaskell.com and it seems pretty good
20:32:32 <Ralith> keep doing that
20:32:59 <dashster18> Any ideas of projects I can do on the side to learn better?
20:33:20 <dashster18> If it makes a difference, I have already done functional programming in common lisp for a class I took last semester
20:33:23 <parcs> yes that is a good resource. also check out this series of lectures by one of haskell's pioneers http://groups.inf.ed.ac.uk/vision/VIDEO/2009/inf1fp.htm
20:33:52 <dashster18> Ah cool, thanks
20:34:38 <dashster18> Does Haskell have many commercial uses? The only industry I know that uses it is quant finance which do some development in haskell since you can go from idea to implementation pretty quickly
20:35:09 <Ralith> you can go to idea from implementation quickly in python, too
20:35:27 <Clint> dashster18: facebook
20:35:40 <shergill> facebook is using haskell these days?
20:35:57 <fluffynukeit> Hi all.  Is there a modern library that can render html and javascript as a GUI front end?  Preferably compilable on Win7 Haskell Platform.  I have a snap server backend using Ji and I want an integrated GUI and not rely on Firefox.
20:35:59 <Clint> to manage their javascript, allegedly
20:36:05 <dashster18> I tried learning python, I wasn't motivated enough. I really liked lisp because it seemed so elegant and mathematical so I figured I might give Haskell a shot
20:36:11 <parcs> haskell is used sparsely a little bit in most industries, though it is steadily gaining traction. and yeah, quant finance is probably haskell's #1 adopter
20:36:36 <dashster18> Ah cool, didn't know facebook uses it
20:37:04 <Clint> fluffynukeit: can you use wai-handler-webkit?
20:37:08 <dashster18> Going to ask a friend whether he knows anything about that, he interned there two summers ago
20:38:10 <eflister> ivanm + yitz: thanks.  while i was waiting i found another route, but it involves: uncurry (***) $ (join (***) tmp) (fst,snd) -- what is going wrong that i keep finding myself going in this direction?
20:38:18 <parcs> hah, lisp ain't has nothing on haskell's mathy-ness
20:38:25 <ivanm> eflister: what are you actually trying to do?
20:38:39 <ivanm> I would say that one thing that's going wrong is your insistence on point-free... :p
20:39:00 <fluffynukeit> Clint: I'm not sure, let me look into it a sec
20:39:08 <dashster18> Really? That's great :D. I love the math part of things, that's why I chose to study CS
20:39:14 <ivanm> @type \ tmp -> (join (***) tmp) (fst,snd)
20:39:15 <lambdabot> (((a, a) -> a) -> c) -> (c, c)
20:39:23 <dashster18> and that's what really appealed to me about learning functional languages
20:39:26 <latro`a> O.o
20:39:35 <parcs> if you love mathy things then rest assured you'll love haskell
20:39:43 <eflister> ivanm: the problem should be simple -- i'm resizing an image.  :)
20:39:48 <dashster18> Perfect :)
20:39:59 <latro`a> the hell is an ((a,a) -> a -> c)
20:40:10 <ivanm> latro`a: it gets either fst or snd as it's first argument
20:40:24 <latro`a> sorry, ((a,a) -> a) -> c)
20:40:33 <latro`a> also, I see, I guess you can actually move the forall inside
20:40:37 <latro`a> technically
20:40:44 <eflister> since the dimensions are in a tuple (x,y), i want arrowyness to avoid restating the same calculations on each dimension
20:40:47 <ivanm> not sure where the `c' comes into it
20:41:05 <ivanm> eflister: which image format?
20:41:07 <latro`a> it's a function that given fst or second post composes an a->c with it
20:41:09 <latro`a> I think
20:41:21 <latro`a> where the a->c is "inside"
20:41:30 <ivanm> latro`a: yeah...
20:42:20 * ivanm should go tutor
20:42:33 <fluffynukeit> Clint: might work, depending on installation success on Win7.  Do you know of any alternatives?
20:42:39 <Clint> i do not
20:42:44 <eflister> ivanm: well i don't want it to matter.  i'm using juicypixels, where the function to synthesize the resized image gets coordinates as arguments
20:42:52 <fluffynukeit> Clint: thanks for the lead
20:43:29 <eflister> btw, has anyone successfully gotten cabal to install imagemagick or gd on windows?
20:44:28 <fluffynukeit> eflister: I recently was able to install the DevIL libraries and use them well enough for my purposes.  Check out Codec-Image-DevIL
20:46:27 <eflister> fluffynukeit: thx, but juicypixels is fine for reading/writing images -- i want the manipulation stuff from gd or imagemagick
20:52:00 <fragamus> :t In
20:52:02 <lambdabot> f (Mu f) -> Mu f
20:56:20 <ben22> monochrom, you there?
21:12:36 <m3ga> does byorgey's diagrams package do text?
21:13:18 <m3ga> bah! yes it does : http://projects.haskell.org/diagrams/manual/diagrams-manual.html#text
21:31:18 * hackagebot maxent 0.6.0.0 - Compute Maximum Entropy Distributions  http://hackage.haskell.org/package/maxent-0.6.0.0 (JonathanFischoff)
21:41:59 <adnap> Is there no function like:
21:42:05 <adnap> :t (\k m -> lookupIndex k m >>= (\x -> return $ elemAt x m))
21:42:07 <lambdabot>     Not in scope: `lookupIndex'
21:42:07 <lambdabot>     Perhaps you meant `M.lookupIndex' (imported from Data.Map)
21:42:07 <lambdabot>     Not in scope: `elemAt'
21:42:20 <adnap> :t (\k m -> M.lookupIndex k m >>= (\x -> return $ M.elemAt x m))
21:42:21 <lambdabot> Ord k => k -> M.Map k a -> Maybe (k, a)
21:48:07 <adnap> Or simply
21:48:13 <adnap> :t (\k m -> M.lookup k m >>= return . ((,) k))
21:48:14 <lambdabot> Ord a1 => a1 -> M.Map a1 a -> Maybe (a1, a)
21:49:02 <elliott> :t \k m -> (,) k <$> M.lookup k m
21:49:04 <lambdabot> Ord k => k -> M.Map k a -> Maybe (k, a)
21:49:27 <elliott> even (k,) <$> ... with TupleSections enabled
21:49:34 <Rotaerk> hmm which lens module is the most mature
21:49:42 <Rotaerk> edward's "lens"?
21:49:49 <elliott> lens is by far the most expansive and probably the most actively developed
21:49:56 <elliott> maturity is for you to decide :P
21:50:11 <Rotaerk> k
21:51:03 <liyang> Does excessive punning indicate immaturity?
21:51:10 * edwardk is immature.
21:51:20 <liyang> (If so, lens is very immature.)
21:51:24 <Rotaerk> heh
21:51:30 <edwardk> the punning is because naming is hard.
21:52:04 <edwardk> i challenge you to come up with 1200 names with consistent meanings that manage to avoid common words without resorting to puns. ;)
21:52:38 <edwardk> at least 1200 names that you'd want people to have to type over and over =)
21:52:43 <liyang> :)
21:53:09 * liyang isn't saying puns are bad. They're fun, in fact.
21:55:13 <applicative_> > let gettingnesser = (^.) in gettingnesser (1,2) _1
21:55:15 <lambdabot>   1
21:55:25 <adnap> > let x = "test" in putStr x
21:55:27 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
21:55:27 <lambdabot>    arising from a use of ...
21:55:44 <applicative_> > let x = "test" in text x
21:55:45 <lambdabot>   test
21:57:35 <adnap> > let (m, l') = (M.fromList [(42, "hi")], (\k m -> (,) k <$> M.lookup k m)) in map fromJust . filter isJust $ [l' 5 m, l' 42 m]
21:57:36 <lambdabot>   Ambiguous type variable `k0' in the constraint:
21:57:36 <lambdabot>    (GHC.Classes.Ord k0) ari...
21:58:23 <adnap> > let (m, l') = (M.fromList [(42, "hi")], (\k m -> (,) k <$> M.lookup k m)) in map M.fromJust . filter M.isJust $ [l' 5 m, l' 42 m]
21:58:24 <lambdabot>   Not in scope: `M.fromJust'
21:58:24 <lambdabot>  Perhaps you meant one of these:
21:58:24 <lambdabot>    `M.fromList'...
21:58:40 <latro`a> nesser?
21:58:44 <latro`a> the hell is a nesser
21:58:59 <adnap> oops, those are in Data.Maybe
21:59:33 <applicative_> :t fromMaybe
21:59:34 <lambdabot> a -> Maybe a -> a
21:59:50 <applicative_> :t fromJust -- rather
21:59:51 <lambdabot> Maybe a -> a
22:00:52 <adnap> yuck...
22:00:57 <adnap> > let (m, l') = (Data.Map.fromList [(42, "hi")], (\k m -> (,) k <$> Data.Map.lookup k m)) in Prelude.map Data.Maybe.fromJust . Prelude.filter Data.Maybe.isJust $ [l' 5 m, l' 42 m]
22:00:58 <lambdabot>   Not in scope: `Data.Map.fromList'Not in scope: `Data.Map.lookup'
22:00:58 <lambdabot>  Perhaps y...
22:01:15 <adnap> This works in GHCI
22:01:17 <applicative_> @type map fromJust . filter isJust
22:01:19 <lambdabot> [Maybe b] -> [b]
22:01:25 <applicative_> @type catMaybes
22:01:27 <lambdabot> [Maybe a] -> [a]
22:01:32 <adnap> Yes
22:01:33 <adnap> I want that!
22:02:03 <adnap> > let (m, l') = (M.fromList [(42, "hi")], (\k m -> (,) k <$> M.lookup k m)) in catMaybes [l' 5 m, l' 42 m]
22:02:05 <lambdabot>   Ambiguous type variable `k0' in the constraint:
22:02:05 <lambdabot>    (GHC.Classes.Ord k0) ari...
22:02:27 <adnap> Not sure how to add type constraints to a lambda
22:03:00 <applicative_> \(k::Int) might work with whichever extension
22:03:26 <adnap> What about type class constraints?
22:03:30 <adnap> Such as Ord
22:11:46 <beaky> hello
22:11:59 <beaky> what do I do if I have two functions, but they depend on the same data?
22:12:07 <liyang> beaky: hello!
22:12:21 <liyang> :t (&&&)
22:12:23 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
22:12:56 <liyang> :t (&&&) :: (b -> c) -> (b -> c') -> b -> (c, c')
22:12:57 <lambdabot> (b -> c) -> (b -> c') -> b -> (c, c')
22:13:08 <croikle> > (id &&& (+1)) 5
22:13:10 <lambdabot>   (5,6)
22:13:10 <beaky> wow great idea thanks
22:13:26 <liyang> beaky: (->) is an Arrow.
22:15:13 <Rotaerk> hmm why are lenses called "lenses"?  does that term come from some pre-existing field?
22:19:25 <mzero> BayHac '13 - http://www.haskell.org/haskellwiki/BayHac2013
22:19:26 <lispy> Rotaerk: they provide a view of data
22:19:27 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
22:19:52 <lispy> Rotaerk: in that sense, I suppose database theory might be related
22:19:55 <Rotaerk> lispy, so why not "view" or "accessor" or "property"
22:20:04 <lispy> Rotaerk: because they also allow you to focus
22:20:14 <Rotaerk> hmm meaning what
22:20:23 <lispy> Rotaerk: watch the link that mzero posted :)
22:21:21 <Rotaerk> err, it's not a video, or am I missing a link somewhere
22:22:03 <lispy> oh, I'll find you the video then
22:22:26 <lispy> Rotaerk: http://www.youtube.com/watch?v=cefnmjtAolY
22:22:58 <Rotaerk> ah that, yea I'll probably watch that some time soon; it's lengthy
22:23:37 <lispy> Rotaerk: anyway, focusing means that within a type that has a rich structure you can pinpoint a specific part and do something with it (access or update it)
22:24:05 <Rotaerk> how is that different from nested properties?
22:24:17 <Rotaerk> e.g. C#'s a.b.c.d = 5
22:24:39 <lispy> without lenses how would you do that easily in Haskell?
22:24:48 <lispy> You can compose record accessors
22:24:51 <lispy> build a custom function
22:25:02 <lispy> But lenses give you a nice way to build these
22:25:55 <Rotaerk> I'm not questioning the usefulness of lenses within haskell, just wondering what distinction warranted the different name
22:26:15 <Rotaerk> and "focusing", as I pointed out, is accomplishable with C# properties
22:26:20 <Rotaerk> but it's not a big deal, was just wondering
22:26:41 <lispy> at edwardk points out in his talk, "Costate Comonad Coalgebra is equivalent of Java's member variable update technology of Haskell" -- PLT_Borat
22:26:57 <Rotaerk> that's well over my head
22:27:01 <Rotaerk> heh
22:27:03 <lispy> it's a joke :)
22:27:53 <lispy> Rotaerk: I wish I had a nice way to explain why lenses are valuable in Haskell. In fact, I have yet to use any lens library in my haskell code.
22:28:10 <lispy> I understand the theory but I don't know the practice so I should defer to others.
22:28:26 <Rotaerk> I haven't really written any haskell code yet
22:30:10 <lispy> Rotaerk: there are a couple websites that make it trivial to start: http://tryhaskell.org/ https://www.fpcomplete.com/school/how-to-use-the-school-of-haskell  :)
22:30:36 <lispy> Rotaerk: but yeah, in C# the value of lenses is questionable.
22:31:09 <lispy> (just like the value of subtyping is questionable in Haskell)
22:34:15 <Rotaerk> lispy, meh, sub"typing" doesn't really exist in C#
22:34:40 <Rotaerk> classes aren't types so much as monstrous mixtures of a variety of mechanisms
22:35:13 <lispy> Ah, well, I meant OOP style inheritance if it wasn't clear.
22:35:39 <lispy> Perhaps the most natural translation to Haskell would actually be putting a predicate on a type
22:35:57 <Rotaerk> well inheritance exists as a way of taking one implementation of an interface and overriding parts of it.  an interface is analogous to a record type with only functions as fields
22:36:07 <lispy> But that wouldn't be a translation of the OOP paradigm but instead a translation of the idea of subtyping (subsetting the type)
22:36:16 <Rotaerk> an object is analogous to an instance of that record
22:37:05 <Heffalump> Rotaerk: C# properties aren't first-class things, you can't pass around a property name on its own and also compose it with other property names to get a more deeply nested "lens"
22:37:14 <lispy> I've implemented OO style subtyping that way in a ray tracer using records
22:37:20 <Rotaerk> Heffalump, ah true
22:37:26 <Rotaerk> I guess that warrants a different name
22:38:26 <jtbandes> Syntax question... looks like one can define an infix operator { let x "" y = 42 } but then trying to use the prefix notation ("") doesn't work, since it is parsed as the empty string. Is this supposed to be valid in the first place? How would I use it as a prefix operator?
22:38:31 <lispy> Oh yes, that's a good point. Most things in Haskell are first-class. Because, a) pretty much everything is a function at some level and functions are first class, b) laziness means that data types can implement control structures
22:38:46 <Rotaerk> lispy, and a class is really three things, 1) constructor, 2) object templating, and 3) a special kind of namespace (for static stuff)
22:38:52 <jtbandes> (Note: this is purely for my edification, I would never consider doing it in real code...)
22:39:07 <Rotaerk> #1 and #2 can be replicated in haskell by writing a function that returns an instance of that "interface" record-type
22:39:16 <lispy> Rotaerk: It's been said by folks far wiser than me than OOP languages tend to "conflate" type and interface
22:39:29 <Rotaerk> yep
22:39:43 <pharaun> hello, is there any good way to support plugins/reloading of code? IE can i spawn a new thread and load new code there and give it a pair of pipe for communication, and when i spawn a new thread for a reload, will the old code die out?
22:39:49 <lispy> jtbandes: http://stackoverflow.com/questions/10548170/what-characters-are-permitted-for-haskell-operators
22:40:08 <Rotaerk> and inheritance is basically writing a new constructor function in terms of another one, where you take the object it returns and replace some of the functions in it
22:40:26 <croikle> jtbandes: that defines x, not ""
22:41:00 <lispy> pharaun: One way to get that: http://hackage.haskell.org/package/plugins
22:41:00 <jtbandes> croikle: oh, good call
22:41:04 <Rotaerk> so it's perfectly doable, it's just not a particularly *special* concept that warrants explicit language support
22:41:15 <adnap> :t (.).(.)
22:41:17 <Rotaerk> doable in haskell *
22:41:17 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
22:42:27 <adnap> > (.).(.) (+1) (Just (Just 0))
22:42:28 <lambdabot>   Couldn't match expected type `a0 -> b0'
22:42:28 <lambdabot>              with actual type `Data...
22:42:59 <adnap> > (.).(.) (+1) [[0]]
22:43:01 <pharaun> lispy: yeah i was looking at that one, was wondering how the stability was, it seemed to have died a bit for a while
22:43:01 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `[t0]'
22:43:23 <pharaun> lispy: mainly wanted a way to reload plugins when new code was deployed without restarting the service
22:43:36 <lispy> pharaun: The truth is, it's pretty fiddly. It needs to be updated with almost every ghc release :(
22:43:45 <pharaun> :(
22:44:20 <lispy> pharaun: that's a hard problem. Someone did that for the linux kernel.
22:44:22 <pharaun> lispy: makes me wonder if it wouldn't be easier to somehow pass the state + file handle/socket handle and restart (ala xmonad model) would be easier
22:44:32 <lispy> pharaun: http://www.ksplice.com/
22:44:46 <pharaun> oh man ksplice
22:44:58 <pharaun> never played with it in the kernel but i've heard of it :)
22:45:11 <lispy> pharaun: probably. Don Stewart wrote plugins and later coauthored xmonad so it's reasonable to assume he applied "lessons learned" to xmonad.
22:45:31 <croikle> > ((.).(.)) (+1) (Just (Just 0)) -- adnap
22:45:33 <pharaun> lispy: oh right, just noticed the name, ha point taken
22:45:33 <lambdabot>   Just (Just 1)
22:45:54 <pharaun> i'll go dig into the xmonad source and see how hard it would be to do that, my main trouble probably will be socket/handle passing
22:46:28 <lispy> pharaun: Maybe? In general you might need a way to serialize/deserialize functions/closures.
22:46:46 <lispy> pharaun: but if your application isn't "that dynamic" you might be okay
22:47:06 <adnap> :t (*2) (.).(.) (+)
22:47:07 <lambdabot> (Functor f, Num a1, Num ((a -> a1 -> a1) -> f a -> f (a1 -> a1))) => (a -> a1) -> f a -> f (a1 -> a1)
22:47:16 <pharaun> yeah i'm just mainly trying to find a way to not interrupt service with a reasonable level of effort :)
22:47:36 <adnap> :t (.)
22:47:37 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:47:42 <pharaun> lispy: i was going to try to build a small collection of state and have the remaining state be file bound so that its able to be loaded on a restart
22:47:46 <adnap> No!
22:47:51 <mzero> oy - we have TOO MANY means of mass communication!
22:47:52 <pharaun> so i would only need to pass this tiny subset of state + handles
22:48:02 <lispy> pharaun: in that case, I recommend you follow this code style https://github.com/Mikkeren/FizzBuzzEnterpriseEdition ;)
22:48:10 <pharaun> har har
22:48:14 <croikle> adnap: on lambdabot (.) is fmap. it's a generalization
22:48:19 <mzero> I just advertised BayHac '13 - on five maliing lists, reddit, the wiki, and G+
22:48:24 <adnap> What is function composition?
22:48:28 <adnap> Oh wait
22:48:35 <adnap> fmap is (.) for functions
22:48:37 <Rotaerk> hmm sometimes I think I really need to learn category theory before I can understand what people are talking about with haskell... rather than merely to enhance my understanding
22:48:50 <lispy> mzero: agreed. I've been having trouble sorting it lately.
22:49:01 <pharaun> lispy: i'm just mainly curious to see if its reasonably possible ;p some folks been hooking about clojure hot reloading so i wanted to see if i could do something similar to that in haskell
22:49:07 <lispy> mzero: and by "lately" I actually mean "pretty much forever"
22:49:08 <Hermit> croikle: shouldn't fmap be just map instead of screwing up (.) ?
22:49:19 <Hermit> wouldn't break a thing...
22:49:35 <lispy> pharaun: lisp style "hot reloading" is actually not that wise.
22:49:41 <pharaun> hm?
22:49:52 <lispy> pharaun: But...in the sake of completeness. You could look at how ghci reloads things.
22:50:20 <lispy> pharaun: in a lisp interpreter, a "hot reload" is additive.
22:50:22 <mzero> Hermit - are you suggesting that fmap be renamed 'map'?
22:50:24 <jtbandes> @pl (\f xs -> g (map f xs))
22:50:24 <lambdabot> (g .) . map
22:50:34 <pharaun> lispy: hm i shall have, i'll probably abandon and look at some form of proxy in front and just have the proxy switch target when a new executable is available and running
22:50:42 <lispy> pharaun: so, imagine working for a long time on something. You refactor it a lot in your session. Some symbols live on, some get redefined, etc.
22:50:44 <pharaun> probably cleaner
22:50:46 <Hermit> mzero: yes, map being trashed and fmap be renamed as map
22:50:59 <jtbandes> @pl (\f g h -> p (q f g h))
22:51:00 <lambdabot> ((p .) .) . q
22:51:02 <pharaun> lispy: i've heard of issues about having to kill your jvm every so often
22:51:12 <lispy> pharaun: and then you come back later and load your code from scratch. What you don't realize is that it no longer works because some iteratation defined something that no longer exists in the input text :(
22:51:12 <Hermit> mzero: that way map would still work for lists, and would also work for other things
22:51:14 <otters> why is there a map function
22:51:18 <otters> why not use fmap
22:51:26 <pharaun> lispy: ugh
22:51:28 <otters> is it a learning curve thing
22:51:33 <pharaun> that does not sound like fun
22:51:34 <mzero> well... sometimes you don't want to have to expressly cooerce the type....
22:51:47 <mzero> which I think is sometimes useful, even well after you've learned Haskell
22:51:58 <lispy> pharaun: there is a reason why my nick is "lispy" and I spend all my time haskelling :)
22:52:16 <mzero> mind you.... I'm often tempted to write code like....        (+ 8) . [1..10]
22:52:24 <pharaun> lispy: :)
22:53:10 <otters> > 2 2 2
22:53:11 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> a1 -> t))
22:53:12 <lambdabot>    arising from the ambiguit...
22:53:16 <otters> what, really
22:53:18 <lispy> > 2 2
22:53:20 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> t))
22:53:20 <lambdabot>    arising from the ambiguity chec...
22:53:29 <otters> > 2 2 :: Int
22:53:30 <Hermit> mzero: that would catch many off-guard
22:53:31 <lambdabot>   No instance for (GHC.Num.Num (a0 -> GHC.Types.Int))
22:53:31 <lambdabot>    arising from the lit...
22:53:34 <lispy> otters: lambdabot loads NumInstances (among other things)
22:53:36 <otters> I thought lambdabot had num-instances
22:53:43 <otters> lispy: well apparently it doesn't
22:53:47 <mzero> Hermit: exactly, so I don't!
22:53:49 <otters> > 2 2 :: Integer
22:53:49 <lispy> hmm
22:53:50 <lambdabot>   No instance for (GHC.Num.Num (a0 -> GHC.Integer.Type.Integer))
22:53:50 <lambdabot>    arising f...
22:53:54 <otters> ^
22:53:57 <lispy> Cale: lambdabot uses numinstances, no?
22:54:15 <Hermit> mzero: then why have (.) mean fmap on lambdabot? I can't see that as a good thing
22:54:20 <pharaun> lispy: i guess having a proxy to keep the connection up then reconnecting after a restart and dumping state into the next executible ala xmonad would work *shrugs* thanks
22:54:48 <lispy> pharaun: you're welcome and good luck. Maybe you can blog about whatever solution works?
22:55:07 <mzero> Hermit: lambdabot has a sort of souped crazy version of the libs - perhaps for most people coming here it *isn't* a good thing
22:55:32 <mzero> it does let some people demonstrate jedi mind tricks with ease.....
22:55:33 <mzero> :-)
22:55:34 <pharaun> lispy: heh its tad silly :) i'm just mainly trying to see if its possible to keep a connection going on even through code-replacement, was just mainly thinking of hotloading cos of the issues of transferring the handlers
22:56:04 <Hermit> no matter how I see it, I can't agree with (.) being replaced for fmap as a good thing. It should stick to the prelude at the very least
22:56:13 <otters> :t (.)
22:56:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:56:20 <lispy> pharaun: I think it's a relevant engineering problem. A strength of erlang and all.
22:56:37 <Ralith> pharaun: passing FDs around works fine, no?
22:56:39 <lispy> Having a way to do it is not a bad thing :)
22:56:42 <pharaun> indeed, that strength of erlang was making me curious if i could do this in a reasonable way
22:56:56 <pharaun> Ralith: yeah i was looking at system.io didn't see a way to open/rebuild a handle from FD
22:57:01 <pharaun> i think i need to dig deeper
22:57:11 * lispy wonders if cloud haskell would help here but he has no idea what cloud haskell provides
22:57:12 <Hermit> mzero: ..specially for a bot meant to help learning/explaining haskell...
22:57:26 <Ralith> pharaun: I seem to recall one exists
22:57:38 <mzero> pharaun: careful there - you really don't want to give a FD to a Handle, if you ever want it back again!
22:58:12 <pharaun> mzero: i'm mainly interested in transferring a tcp socket cross new... code
22:58:41 <mzero> how are you going to load the new code?
22:59:15 <pharaun> mzero: http://nathanwiegand.com/wp/2010/02/hot-swapping-binaries/ c example, but i was looking at a few options but i think doing it ala xmonad approach is the best
22:59:18 <joneshf-laptop> can you compile haskell from within haskell?
22:59:31 <pharaun> in which i compile the new code, make sure it compile cleanly then do some cleanup and exec to switch over
22:59:51 <mzero> you can use plugins --- but beware.... the code has become a bit crusty - and it never unloads anything, so your memory image slowly bloats with loaded libs
22:59:54 <joneshf-laptop> i mean, i assume you can send a command to the system, bnut is there something in the libs somwhere?
23:00:27 <mzero> joneshf-laptop: you can link all of GHC in as a lib - and then, well, call it
23:00:38 <pharaun> mzero: yeah i was looking at that but i'm not exactly enthrilled by that, would prefer a cleaner way to restart the code so doing exec and passing a fd/some form of identifier that lets me rebuild the socket without interrupting would be ideal
23:00:44 <mzero> bit it will still need to system call the linker
23:01:19 * hackagebot ghc-mod 1.12.2 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.12.2 (KazuYamamoto)
23:01:36 <mzero> well... when you exec, you *can* "pass a fd" by having it live on a well known FD number (or for that matter, passing the FD number as an arg...)
23:01:57 <Ralith> the latter is how it's usually done
23:01:59 <Ralith> :p
23:02:08 <pharaun> mzero: that's what i was thinking, i just gotta to figure out if this is a doable approach within haskell
23:02:12 <mzero> this will need to be done carefully w.r.t. the GHC runtime which is managing FDs, and some of the exec like functions will try to shut your FD down
23:02:16 <mzero> yes
23:02:33 <mzero> (Is writing a shell in Haskell, and does FD shenanigans like mad)
23:02:43 <pharaun> it is, excellent, good to know
23:02:47 <lispy> mzero: is it public yet?
23:02:51 <mzero> yes
23:02:56 <mzero> has been for almost a year!
23:03:04 <lispy> link please :)
23:03:06 <c_wraith> The biggest problem with full erlang-like code loading with GHC is that GHC doesn't garbage collect unreachable code
23:03:12 <pharaun> seems like a cleaner approach instead of dragging in new code via hotload and bloating things up, etc with all of the other problems that... that approach has
23:03:15 <mzero> but it isn't quite at that magic 0.5 version yet - so it runs - but you need to be a little intrepid
23:03:18 <pharaun> c_wraith: yeah i read that, and that was a problem
23:03:31 <pharaun> c_wraith: hence me preferring passing the fd and restarting if possible
23:03:34 <mzero> https://code.google.com/p/plush/
23:03:59 <lispy> mzero: <implicit bias>any chance of moving to github?
23:04:01 <mzero> or, if you prefer - https://github.com/mzero/plush - but the wiki and docs and bug tracker are at the first link
23:04:12 <mzero> :-)
23:04:19 <Ralith> ooo, functional shells
23:04:23 <Ralith> always wanted to write one of those
23:04:35 <Ralith> "... that is accessed from a web browser"
23:04:41 * Ralith goes back to what he was doing
23:04:41 <pharaun> haha
23:04:44 * lispy is interested and reads on
23:04:44 * mzero works for Google, and it is a Google open-source project, hence the home base is on code.google.com
23:04:51 <lispy> ah
23:04:59 <pharaun> happen to be in norcal?
23:05:04 <mzero> yes
23:05:27 * lispy was deeply saddened when he learned that windows has no tty or pty abstraction
23:05:29 <pharaun> is this the relevant wiki chunk? - https://code.google.com/p/plush/wiki/PttyAndFdNotes
23:05:51 <mzero> that has some of my notes on it
23:05:59 <lispy> mzero: are you familiar with h4sh?
23:06:25 <mzero> yes
23:06:51 <mzero> but htat hasn't been worked on in a few years
23:06:51 <jbu> hi all: the "show" function prints out escape characters and I don't want it to, is there a similar function that doesn't do the escaping?
23:06:58 <lispy> Good, I feel like anyone who works on a shell these days should at least know about it :)
23:07:11 <lispy> it's the ideas it embodies that I care about
23:07:26 <jbu> for instance show "hi" prints : "\"hi\""
23:07:41 <mzero> well - you might be disappointed to know that plush strives to be a POSIX compliant shell, first
23:07:57 <mzero> jbu: for an String?
23:08:04 <jbu> mzero: yeah
23:08:12 <mzero> you want a function from String -> String that - well, is the String?
23:08:19 <mzero> how 'bout       id     ?
23:08:22 <mzero> :-)
23:08:34 <mzero> > putStrLn "hello there, jbu"
23:08:35 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
23:08:36 <lambdabot>    arising from a use of ...
23:08:36 <Ralith> jbu: your question is confused, but the thing you want is putStr(Ln)
23:09:24 <lispy> mzero: oh, through your github account I see your "real name" and the pieces click into place :)
23:09:25 <jbu> Ralith: could you help me understand I'm confused about?  I'm confused enough that I don't recognize I should be confused about something
23:09:34 <mzero> uh oh....
23:09:35 <jbu> ;p
23:09:43 <mzero> but yes, my real name isn't much of a secret
23:10:02 <Ralith> jbu: 'show' converts things to strings. 'putStrLn' writes strings to standard output.
23:10:16 <lispy> mzero: sometimes I don't know what handle people go by (I'm also guilty of this confusing association)
23:10:26 <mzero> jbu - in what context did you use the Show instance for String.... was it    print "some string"
23:10:30 <Ralith> jbu: if 'show' did not add escape characters to a string you passed to it, then you might as well not call show.
23:11:10 <mzero> print is just a simple combination of      putStrLn . show       so if you don't want the show behavior ---- use    putStrLn directly
23:11:16 <lispy> mzero: so when you say posix shell, you mean, "works a replacement for /bin/sh, more or less" ?
23:11:17 <mzero> @src print
23:11:18 <lambdabot> print x = putStrLn (show x)
23:12:30 <mzero> lispy: yes, if invoked directly from a terminal - it acts like sh -- but if invoked with the web UI - then while the input language is exactly that of sh  (what your fingers already know how to type without you thinking about it), the output is a richly formatted environment
23:13:00 <lispy> mzero: ah, interesting
23:13:15 <Ralith> oh
23:13:24 <Ralith> I was hoping it was a statically typed reinvention of shelliness
23:13:26 <mzero> you get directory context info, very clear visuals of commands and their output, you can leave multiple commands running, each scrolling into their own sub-pane of the window
23:13:27 <lispy> I'll be the first to admit that while the sh input language is not perfect it's not clear to me where to improve it.
23:13:40 <lispy> But improving the output is smart
23:13:46 <pharaun> lispy: amusingly enough i tend to know/think of people by their handle more than their real name >_<
23:14:03 <mzero> this was the observation that started the project: The shell language we all use was basically set 30 years ago!
23:14:24 <pharaun> haha
23:14:32 <mzero> it is well suited (if arcane) for an input method that hasn't changed in 140 years
23:14:52 <pharaun> mzero: i sure hope it never changes!
23:14:59 <pharaun> >_> voice input, no thanks
23:15:18 <mzero> 30 years ago, if you had an 50 line terminal with 8 colors - you had hot stuff!
23:15:25 <lispy> voice input is that button I hit accidentally on my phone and wish I hadn't :( :(
23:15:33 <adnap> This video presentation on leses is confusing.
23:15:38 <adnap> *lenses
23:15:49 <mzero> the output format of the shell reflects that --- but now we all have high resolution graphic screens with typography, layout engines, full color, etc....
23:15:56 <adnap> I'm 20 minutes in and he still hasn't got back to lenses yet.
23:16:09 <lispy> adnap: do you know how it's confusing? (it's okay if you don't, I just want more details if you can articulate)
23:16:25 <lispy> adnap: edwardk's video?
23:16:32 <adnap> lispy: Mainly I am just getting a lot of examples with no context for why they're presented
23:16:44 * mzero adnap hits it on the nose
23:16:47 <supki> adnap: that should hint lens is much more than lenses ;)
23:16:50 <adnap> I am slowly following the examples, but I don't see the point of them at all
23:17:17 <pharaun> hehe
23:17:30 <adnap> And I am just barely comprehending the examples. I can basically type check everything, but...
23:17:31 <jbu> mzero: ah I found that I was doing a show on a String concated with other strings
23:17:40 <jbu> mzero: when I shouldve just done string++otherstrings
23:17:42 <jbu> thanks
23:18:22 <lispy> Ralith: I love static typing, but I'm always skeptical of the benefit in a deeply interactive environment.
23:18:51 <lispy> Ralith: I'm honestly not sure how to make my daily shell (zsh) work better by adding types.
23:19:11 <amindfv> adnap: if you're talking about the edwardk video, pause it on the first slide
23:19:12 <Ralith> structured data streams would be useful
23:19:13 <tac> lispy: use the type system to prevent you from ever running rm -rf /
23:19:13 <tac> :)
23:19:17 <lispy> Ralith: it might make the find command easier?
23:19:29 <adnap> amindfv: Why? Also, I have the slides
23:19:31 <amindfv> spend 3 minutes comprehending that, and the whole thing makes more sense
23:19:50 <Ralith> it would dramatically simplify command line tools' interfaces, too
23:19:52 <lispy> glguy gave a really good lens talk at Galois but we didn't record it :(
23:20:03 <adnap> I am on the 31st slide
23:20:11 <adnap> "over mapped f"
23:20:14 <mzero> well, we've thought of adding >>= to the shell    -- ti would be a version of    | xargs
23:20:15 <amindfv> i think he rushed the foundations part, but it really is a good video once you have the foundations down
23:20:26 <Iceland_jack> The problem with adding structure or types to the shell is that it's almost impossible to not throw away all thousands of commands with it
23:20:47 <lispy> mzero: so, I think category theory has more potential to make the shell nice than "just adding types" has
23:20:49 <adnap> amindfv: Which slide?
23:20:58 <Iceland_jack> I worked on a typed shell in Haskell once and the agreement was basically that the shell was in a local optimum
23:21:12 <adnap> amindfv: The definition of Lens?
23:21:20 <adnap> amindfv: 'Cause I found that very simple
23:21:24 <amindfv> adnap: er, 1 second...
23:21:25 <lispy> mzero: but that observation is based on the idea that (co)monads, in particular, are good at adding context
23:21:36 <adnap> It's the implementing fmap with traversable stuff that's taking me forever
23:21:53 <mzero> well, I sort of think that by working on the computer -> human side of the shell - which clearly isn't at an optimum (fixed width character terminal emulators?) -
23:21:56 <adnap> And I don't know what the point of it, or a semantic editor combinator is
23:22:17 <mzero> might, eventually, allow the other side to be leap froged out of it's current minimum-energy well
23:22:55 <lispy> mzero: One of the things I like about fixed width fonts is that I can do rectangular operations in my editor (vim or emacs) quite easily. I'm also one of those programmers who takes the time to live things up in columns.
23:23:11 <mzero> sure, for code, that's great
23:23:13 <adnap> Ugh
23:23:21 <adnap> I hate when people use spaces just to line stuff up
23:23:39 <lispy> adnap: hate the spaces not the spacers ;)
23:23:39 <mzero> actually - we use fixed width for commands and output - just not all the other stuff
23:24:00 <adnap> lispy: Well, I hate the disease, not the symptom
23:24:13 <lispy> my point isn't that "gee spaces and fixed with are great" it's that "wow, being able to operate in bulk saves me time"
23:24:22 <lispy> width*
23:24:23 <amindfv> adnap: the text is small here, but this is the part I mean: http://www.youtube.com/watch?v=cefnmjtAolY&feature=share&list=UUE3MJbkTVLoK8dAq7Del8ww
23:24:37 <adnap> amindfv: It's okay. I am following along with the slides
23:25:03 <amindfv> (at 10:12 if that didn't carry through the URL)
23:25:27 <adnap> Oh, the SEC part
23:25:33 <lispy> mzero: When I program in agda I need unicode, so I've experimented with non-monospace-font programming and it's been a cognitive mismatch.
23:25:36 <adnap> Yeah, I still have no idea why those were introduced
23:25:52 <lispy> mzero: On the other hand, I don't like the kerning of fixed width.
23:26:36 * lispy doesn't know how to fix the situation but knows it's broken
23:27:17 <tdammers> lispy: unifont?
23:28:01 <pharaun> unicode... seems rough
23:28:05 <ivanm> anyone know who John Feltz is?
23:28:15 <adnap> amindfv: I understood the examples in this slide. I still don't see what the point of defining "type SEC" is
23:28:30 <lispy> tdammers: I use deja vu sans mono, and it does quite nicely for glyph coverage
23:29:04 <amindfv> adnap: because then you more or less have a lens
23:29:10 <lispy> tdammers: so, for me the problem isn't glyph coverage
23:29:19 <amindfv> you have a reference
23:29:21 <adnap> amindfv: I don't understand you yet
23:29:36 <lispy> tdammers: I'm starting to think that the mismatch is between input and output.
23:29:45 <ivanm> lispy: any idea about my error in building GLURaw?
23:30:12 <lispy> ivanm: Nope. I tried to leave you a note via lambdabot but I must have typo'd
23:30:31 <lispy> ivanm: I think I need more information about your computer and what it has installed.
23:30:40 <ivanm> *nod*
23:31:02 <adnap> I am not comfortable with (.).(.) either
23:31:05 <ivanm> x86_64 Linux (Exherbo to be specific); glu version 9.0.0
23:31:33 <lispy> ivanm: The best thing you can do to help me fix it is to record the information about your problem here: https://github.com/haskell-opengl/GLURaw/issues
23:31:34 <ivanm> not sure how to determine opengl version, but I've tried building with both the version of GL that comes with xorg-server and that comes with my binary nvidia drivers
23:31:47 <lispy> ivanm: if you could tell me how to build a vm to reproduce it, that is even better :)
23:31:56 <amindfv> adnap: you aren't comfortable with how it works?
23:31:56 <ivanm> fair enough; I was hoping it would be a quick enough fix that I wouldn't need to open an issue :p
23:32:14 * ivanm has had enough issues filed on github for repos owned by people that keep touting it but never answered...
23:32:18 <adnap> amindfv: No
23:32:22 <adnap> amindfv: (I'm not)
23:32:25 <ivanm> lispy: heh, that's probably too much to ask for :p
23:32:34 <lispy> ivanm: I might be slow to respond but I always read it :)
23:32:55 <ivanm> \o/
23:33:02 <amindfv> adnap: have you seen http://stackoverflow.com/questions/15029843/how-can-i-understand/15030372 ?
23:33:20 <adnap> amindfv: Nope
23:34:13 <lispy> ivanm: have you tried running any of the binutils tools on files that maybe define that symbol? (vague I know. I just mean, have you done nm /lib/foo too see if it's actually there)
23:34:25 <lispy> to*
23:34:48 <ivanm> "nm" ?
23:35:09 <lispy> IIRC, stands for name mangle, it's part of binutils
23:35:18 <ivanm> oh, says no symbols...
23:35:26 <lispy> NAME nm - list symbols from object files
23:35:32 <ivanm> lispy: I wonder whether it's because it's a symlink of a symlink of a symlink, etc.
23:35:43 <ivanm> I take it back, that file isn't
23:35:52 <mzero> if you want to see a screen shot of Plush:    http://www.ozonehouse.com/mark/plush/plush-example.png
23:36:08 <ivanm> but nm says it has no symbols :/
23:36:12 <adnap> If lenses aren't useful, I'm afraid I will just forget whatever I learn
23:36:18 <lispy> ivanm: All I really need is a ticket with your linux distro (and version), relevant distro packages, and ghc version
23:36:46 <lispy> mzero: nice!
23:36:46 <ivanm> which distro packages are relevant?
23:37:08 <lispy> ivanm: mesa and anything with opengl or nvidia in the name?
23:37:19 <lispy> ivanm: (I'm not totally sure, tbh)
23:37:34 <ivanm> heh, fair enough
23:37:38 <lispy> ivanm: I need to go to bed, it's late here :(
23:37:49 <ivanm> fair enough; g'night!
23:37:56 <amindfv> adnap: maybe it'll help; anyway, the point is you end up with a way to provide a way to point to data
23:37:57 <lispy> ivanm: just include things that seem relevant and I can ask you for more info
23:38:33 <lispy> ivanm: thanks!
23:38:36 * lispy -> bed
23:38:37 <ivanm> good-o
23:44:43 <hpaste> eflister pasted “why so ugly” at http://hpaste.org/83967
23:45:50 <eflister> can anyone take a look at that and help me see how i should have done it better?
23:46:15 <eflister> in matlab, it's pretty.  it is just the core part of resizing an image.
23:47:02 <eflister> in haskell, i want to avoid restating the same logic on each dimension, which seems to make it ugly
23:47:27 <eflister> plus i see no simple way to make it generalize to n dimensions
23:48:23 <mzero> well - I'd get rid of all those Arrow functions - I don't think they are helping
23:48:35 <mzero> do you really need this generalized to n-dimensions?
23:49:37 <mzero> this function seems - well, confused? why is it resizing from   orig -> resized... .but mapping a point from resized -> orig?
23:50:12 <eflister> mzero: cuz that's how you synthesize the resized image -- find corresponding points in the original
23:50:48 <eflister> mzero: can you show me specifically what to change?  the reason for the join (***) is to not restate the same logic on each dimension
23:51:20 <eflister> mzero: and this in particular doesn't need to be n-dimensional, but it's a continuing frustration for me with haskell that i can write n dimensional stuff in matlab so easily
23:51:26 <mzero> why not....      resizeOneDim r s x = (r*s, x/r)        then pattern match the input pairs, apply resizeOneDim twice, then reassemble?
23:53:18 <adnap> amindfv: Thanks. The link cleared up (.).(.). There is an error though: "it "composes" a function f :: a -> b with a function of two arguments, g :: s -> t -> b" should read "it "composes" a function f :: a -> b with a function of two arguments, g :: s -> t -> a"
23:56:10 <amindfv> adnap: good catch
23:56:45 <amindfv> fixed
23:57:51 <eflister> mzero: can you write it out?  i'm not seeing it -- thanks for your help
23:59:02 <supki> > (10,20) & both %~ round . (* 0.5) . fromIntegral
23:59:05 <lambdabot>   (5,10)
23:59:36 <eflister> :t (&)
23:59:37 <lambdabot> a -> (a -> b) -> b
23:59:53 <eflister> ;t both
23:59:57 <eflister> :t both
23:59:58 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
