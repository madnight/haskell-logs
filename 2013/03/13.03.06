00:10:13 <franco00_> let's say I have two functions, A and B, that can fail (Either/Either Monad/Either MT). Now I mix them in a function C. What's the preferred way to do so? Using a stack of monad transformers? Patternmatching?
00:12:55 <supki> mix?
00:13:33 <franco00_> yes, as in, let's say in C I take the result of A and the result of B (which might fail, with different type of errors) and compute something
00:13:48 <supki> what are types of A and B
00:13:48 <supki> ?
00:14:06 <franco00_> let's say Either ErrorA Int / Either ErrorB Int, for instance.
00:16:44 <supki> I'd go with pattern matching for 2 functions
00:16:57 <sopvop> So I have GADT with phantom DataKinds, how do I derive show for it?
00:17:34 <LambdaDusk> hi.... I am a bit stupid right now... I have an arrow "f :: a b [(String, String)]" and the function "fromList :: [(String, String)] -> Map String String", and I kind of want to end up with the arrow "f' :: a b (Map String String)", but I feel too dump to get there right now
00:17:46 <killy9999> > slap me
00:17:49 <lambdabot>   Not in scope: `slap'
00:17:49 <lambdabot>  Perhaps you meant `swap' (imported from Data.Tuple)No...
00:18:01 <ivanm> lambdabot: any particular arrow?
00:18:16 <ivanm> but my guess is you want to do some kind of composition
00:18:19 <ivanm> @src Arrow
00:18:20 <lambdabot> class Arrow a where
00:18:20 <lambdabot>     arr, pure   :: (b -> c) -> a b c
00:18:20 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
00:18:20 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
00:18:20 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
00:18:21 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
00:18:23 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
00:18:27 <sopvop> oh, got it deriving instance forall a b. (Show a) => Show (Ast a b)
00:18:27 <ivanm> lambdabot: >>> ?
00:18:40 <LambdaDusk> I tried >>> but got a type error
00:19:55 <LambdaDusk> oh wait
00:19:55 <LambdaDusk> it's because my function still has the other type
00:19:55 <supki> sopvop: you can omit forall I think
00:19:55 <LambdaDusk> see? dumb
00:19:55 <ivanm> LambdaDusk: do you actually have a polymorphic Arrow?
00:19:55 <LambdaDusk> thanks
00:19:57 <ivanm> LambdaDusk: use arr/pure with it?
00:20:15 <hpaste> LambdaDusk pasted “arrow.hs” at http://hpaste.org/83570
00:20:35 <LambdaDusk> it's not looking very good but it's what I came up with
00:20:41 <ivanm> @type \ f g -> f >>> arr g
00:20:44 <lambdabot> Arrow cat => cat a b -> (b -> c) -> cat a c
00:20:55 <ivanm> LambdaDusk: ^^
00:22:31 <ivanm> well, it's not an _arbitrary_ arrow, so you can always see if there's anything specific to IOSArrow you can use
00:24:39 <LambdaDusk> I had to see that the GHC quite often complains when I don't annotate types when using arrows
00:25:03 <shachaf> Solution: Don't use arrows.
00:25:35 <franco00_> thanks supki. I wat trying to get into 'correct' error handling w/haskell
00:27:30 <sopvop> edwardl: trifecta is pretty cool. Really nice output
00:28:07 <edwardk> if you are careful with the <?> annotations it can be quite nice
00:28:16 <edwardk> and you can do some nice things with the fixits, etc.
00:28:22 <ivanm> who's edwardl? :p
00:28:52 <wuttf> Can I get the fields of an arbitrary record at runtime, without TH
00:28:52 <wuttf> ?
00:29:56 <ivanm> well, you can't even really do it at runtime... :p
00:29:59 <ivanm> * with TH
00:30:13 <wuttf> ivanm: Catch my drift bro :D
00:30:37 * ivanm doesn't recall being related to wuttf ... :p
00:31:01 <wuttf> ivanm: You have a nitpicky day?
00:31:03 <Saizan> wuttf: look into SYB
00:31:14 <ivanm> wuttf: nope; just not a fan of the term "bro" :)
00:31:37 <ivanm> Saizan: or indeed any generic solution?
00:31:54 <wuttf> I obviously need reflection but I don't even know if that kind of information is available at runtime at all
00:32:18 <ivanm> wuttf: what are you doing that you need it at _runtime_?
00:32:30 <ivanm> especially since types are erased during the compilation process
00:32:48 <Saizan> wuttf: with a "Data" typeclass context it is
00:32:56 <wuttf> ivanm: Simplified example: I want to return the fields of any record as [String]
00:33:35 <ivanm> as in write a library function foo :: a -> [String] ?
00:33:36 <wuttf> Even if with that, I sacrifice type safety (eg, I someone inputs a non record type)
00:34:19 <wuttf> ivanm: Yeah, where a is any type, but U would throw an exception if the input is not a record type. Sg like that
00:34:20 <lightquake> there's no distinction between a 'record type' and a 'non-record type'
00:34:29 <wuttf> lightquake: I know
00:34:36 <wuttf> lightquake: See sentence above
00:34:51 <lightquake> i'm confused as to what would cause it to throw an exception.
00:35:06 <wuttf> Basically, I need this: http://golang.org/pkg/reflect/ in Haskell
00:35:18 <lightquake> like, presumably data Foo = Foo { bar :: Int, baz :: Int } is OK, but is data Foo = Foo Int Int?
00:35:18 <wuttf> If anyone familiar.
00:35:20 * ivanm wonders if this is an X-Y problem
00:35:30 <ivanm> wuttf: why do you need such functionality?
00:35:35 <lightquake> … yeah. what are you *really* trying to do?
00:36:50 <wuttf> I want to convert any record into a given map type
00:37:07 <lightquake> why do you keep saying 'record'?
00:37:17 <lightquake> also, what given map type? i'm confused, what's the broader context here?
00:37:26 <ivanm> why?
00:37:42 <Saizan> there clearly is a concept of record types
00:37:46 <Saizan> even in haskell
00:38:08 <sopvop> edwardk: Is there a way to add CPP line pragma support to trifecta? So it would report errors with different location/file?
00:38:15 <lightquake> Saizan: i'm unclear what the distinction is, besides 'records happen to come with convenient syntax for accessing/mutating'
00:38:37 <wuttf> Is this kind of information preserved at all at runtime?
00:39:02 <ivanm> sopvop: there's a LINE pragma in GHC; is that what you're after?
00:39:08 <ivanm> wuttf: no
00:39:28 <sopvop> ivanm: No, I'm parsing a c-like language preprocessed with cpp
00:39:29 <lightquake> wuttf: you can access it at compile time
00:39:34 <ivanm> wuttf: what's your actual end-goal/use-case here?
00:39:52 <ivanm> sopvop: oh... use cpphs to strip the cpp out? or do you want to keep it in?
00:40:00 <sopvop> I want to keep it in
00:40:12 * hackagebot http-streams 0.3.1.0 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.3.1.0 (AndrewCowie)
00:40:12 <sopvop> Or rather extend the language with modules....
00:40:23 <Saizan> lightquake: they have field names
00:40:25 <edwardk> you can inject Delta's directly into the Rope
00:40:31 <wuttf> ivanm I have a json-like recursive map type, and I want to convert between that an arbitrary (record) types. In languages with reflection it is piss easy
00:40:31 <LambdaDusk> anyone know a SAT-collision lib in haskell?
00:40:51 <ivanm> wuttf: IIRC, aeson has Generic support
00:40:53 <Saizan> wuttf: look at how Aeson does it
00:41:11 <wuttf> Saizan, ivanm Thanks, checking out
00:41:11 <edwardk> that gets you line pragma support. i have some code for doing CPP directly where they find their way in as an augmented form of the Delta type, but I never got that to a clean enough state to ship
00:41:43 <edwardk> then you get macros that you can see as part of the diagnostic. e.g. an error occured at this line in this macro expanded with these arguments, etc.
00:41:45 <ivanm> wuttf: see? next time, say what you want, not what you think you need to do based upon other languages :p
00:41:48 <Saizan> tbf SYB doesn't preserve field names
00:42:18 <ivanm> then again, IIUC what wuttf wants, he just wants to be able to get JSON map -> his custom record-based type
00:42:19 <Saizan> in fact Aeson has its own typeclass
00:42:34 <ivanm> which should just be based upon defining the correct instance of Aeson's class, shouldn't it?
00:43:02 <Saizan> right, the point is getting the instance for free, which aeson also handles
00:43:09 <ivanm> yup
00:43:23 <sopvop> Maybe I will just split file in parts on these line directives and parse separately
00:43:25 <Saizan> so in a sense you do keep the information about the field names at runtime
00:44:04 <Saizan> it's just more specialized and localized to where you need it
00:45:24 <dEPy> hi
00:45:49 * ivanm waves idly in dEPy's general direction
00:45:53 <dEPy> you guys always seem to explain some tricky concepts in an easy way... so, todays question...
00:46:07 <dEPy> reification :)  I cannot get a grasp on that
00:46:29 <dEPy> And everywhere it says it's just making abstract concepts concrete
00:46:45 <Saizan> in what context?
00:47:06 <Saizan> it's a term used quite loosely in various fields
00:47:24 <dEPy> in programming
00:47:30 <dEPy> i guess
00:48:02 <Saizan> you have to be more specific :)
00:48:18 <Saizan> where have you found it?
00:48:19 <dEPy> So it can mean different things?
00:48:57 <dEPy> well I first stumbled upon it in clojure (reify), then i started searching on google and now im confused
00:49:37 <Saizan> yeah, it doesn't really have a formal definition like e.g. "turing machine" would
00:49:40 <sw2wolf> reify == instance ?
00:50:03 <c_wraith> reify means more or less "to make real"
00:50:12 <c_wraith> what *that* means is highly context-dependent
00:50:50 <dEPy> ok for example in c when you "cast" adress to char, that is reification?
00:50:56 <dEPy> or so says wiki
00:50:58 <Saizan> dEPy: usually it's about converting some opaque or uninspectable thing into a more concrete representation
00:53:04 <Saizan> dEPy: i guess, i think you should just consult some clojure docs and check what they mean by it
00:54:16 <dEPy> doing that right now y :)
01:11:56 <liyang> edwardk: around? Am wondering why the types in Numeric.AD.Mode.Reverse seem to be unnecessarily restricted by the "forall s. Mode s =>" constraint. In that module, s could be specialised to Reverse t, no?
01:12:13 <edwardk> almost
01:12:29 <edwardk> the purpose of the consraint is to double as an infinitesimal as well
01:13:25 <edwardk> http://conway.rutgers.edu/~ccshan/wiki/blog/posts/Differentiation/ talks about the issue
01:13:40 <edwardk> without it you can get code that typechecks but generates nonsense
01:14:02 <edwardk> now i _do_ have an open issue on the repo to go make a version where i split the mode parameter from the infinitesimal
01:14:20 <edwardk> this would permit better inlining of AD code in different modes
01:14:48 <liyang> Issue #1?
01:15:31 <edwardk> yeah
01:15:54 <edwardk> it is a nontrivial change and leads to some loss of functionality so i have to be careful
01:16:05 <edwardk> thats one reason why its never happened
01:16:28 <liyang> Hum. Okay, thanks… I'll look through that wikiblogpost.
01:17:28 <liyang> (asking for alang, actually.)
01:17:36 <liyang> alang: aren't you on IRC?
01:18:09 <alang> hi
01:18:19 * edwardk is about to pass out
01:18:39 <liyang> bedwardk.
01:19:37 <edwardk> anyways if you specialize it to Reverse it becomes possible for the user to more easily subvert invariants, and easy for them to omit a necessary 'auto' and get nonsense
01:19:56 <edwardk> with the infinitesimal present the missing auto turns into a type error
01:20:06 <edwardk> so you don't get 'perturbation confusion'
01:21:08 <alang> thanks, i'll think about that
01:21:39 <edwardk> it really only becomes an issue if you take the derivative of a function that also takes derivatives
01:21:49 <liyang> This started because alang wanted Unbox (AD s a).
01:21:57 <edwardk> if you do the problem mentioned in chung-chieh's post can arise
01:22:14 <edwardk> ah using forward mode or something?
01:22:29 <alang> Reverse probably
01:22:38 <liyang> Forward and Reverse both seem Unboxable.
01:22:51 <liyang> In principle, I mean.
01:22:51 <edwardk> oh the new reverse
01:22:54 <edwardk> yeah
01:23:01 <edwardk> the old reverse (now kahn) wasn't
01:24:02 <edwardk> anyways if you guys wanted to tackle an initial pass at splitting the mode and infinitesimal i'd be happy to pick it up and double check the invariants, etc.
01:24:38 <edwardk> then inlining can inline through various modes
01:24:48 <edwardk> right now it can't see under the infinitesimal basically
01:25:23 <alang> ok i'll see what I can do
01:25:25 <liyang> I'll add it to my to-do list. Which is nice and short right now because I lost the old one in a HD crash two weeks back.
01:25:37 <edwardk> liyang: =)
01:25:43 <edwardk> i'll add you both to the repo
01:27:02 <liyang> I was going to say thanks but then I remembered why you give out commit access.
01:27:09 <edwardk> =)
01:27:11 <edwardk> muahahaha
01:27:46 <edwardk> alang = alang on github?
01:28:34 <liyang> No...
01:28:48 <edwardk> doesn't look like it
01:28:48 <edwardk> alang9?
01:28:53 <alang> yea alang9
01:29:09 <edwardk> done
01:30:10 * edwardk gives up trying to find an old pre-source-control-era voice compression codec of his and just decides to rewrite the relevant pieces of the arithmetic compressor he had. =/
01:30:38 <alang> thanks
01:31:42 <edwardk> np. ad gets a lot of users, so this would help a lot of people out
01:34:42 <ivanm> anyone here using haskell-mode for emacs and has experience getting it to read/load core files?
01:37:11 <kosta1> Hi!
01:37:21 <kosta1> How do I define a typeclass instance for String?
01:37:36 <kosta1> e.g. class Squarable a where square :: a -> a
01:37:49 <kosta1> instance Squarable Integer where square a = a * a
01:37:51 <kosta1> that works
01:38:07 <kosta1> but instance Squarable String where square s = s ++ s
01:38:17 <edwardk> kosta1: String = [Char]
01:38:37 <edwardk> you can add {-# LANGUAGE TypeSynonymInstances, FlexibleInstances #-}
01:38:41 <edwardk> and it'd work iirc
01:38:49 <kosta1> instance (Squarable [Char]) where square s = s ++ s doesn't work either
01:38:54 <edwardk> but you can also define it in pure haskell 98 by making a helper class
01:38:58 <tdammers> edwardk: I was wondering if there is any downside to these extensions
01:39:06 <tdammers> other than "won't work with any other compiler"
01:39:19 <edwardk> class SquarableList a where squareList :: [a] -> [a]
01:39:29 <edwardk> instance SquarableList Char where squareList xs = xs ++ xs
01:39:43 <edwardk> instance SquarableList a => Squarable [a] where square = squareList
01:39:54 <edwardk> this has the benefit that it has more robust type inference
01:40:05 <edwardk> tdammers: type inference is somewhat problematic for FlexibleInstances.
01:40:17 <edwardk> rather its not as robust as it could be
01:40:41 <edwardk> consider the IsString instance for String.
01:40:47 <edwardk> it'd be a MUCH better instance as
01:41:04 <edwardk> instance a ~ Char => IsString [a] where fromString = id
01:41:52 <edwardk> as it stands, if you turn on {-# LANGUAGE OverloadedStrings #-} then length "foo" causes inference problems
01:42:13 <edwardk> because it doesn't like what to pick for the arg to []
01:42:17 <kosta1> that's what I really don't like about Haskell
01:42:23 <edwardk> kosta1: ?
01:42:52 <kosta1> you want something simple like defining a typeclass on a String and the options just explode with consequences a beginner is unable to judge
01:43:27 <edwardk> kosta1: consider your isntance
01:43:32 <edwardk> you can make it more general
01:43:37 <edwardk> and side-step this whole concern
01:43:49 <edwardk> instance Squarable [a] where square s = s ++ s
01:43:52 <edwardk> works just as well
01:43:58 <edwardk> and now covers every list
01:44:02 <edwardk> and is haskell 98
01:44:05 <edwardk> and needs no extensions
01:44:29 <edwardk> since every String is a list this covers your string case as well
01:44:45 <kosta1> edwardk: In that case, I take back my complaint :)
01:44:51 <tdammers> instance Squarable String where square s = show (read s * read s :: Double) -- oh dear
01:45:04 <edwardk> so if we step back from the problem you asked, and go to what you want, it becomes elegant =)
01:45:14 * hackagebot stm-promise 0.0.2 - Simple STM Promises for IO computations and external processes  http://hackage.haskell.org/package/stm-promise-0.0.2 (DanRosen)
01:45:20 <edwardk> tdammers: =P
01:45:38 <tdammers> I think Acme.PHP defines a Num instance for String that way
01:45:40 <edwardk> @hackage acme-php
01:45:40 <lambdabot> http://hackage.haskell.org/package/acme-php
01:45:45 <edwardk> it does
01:45:56 <edwardk> i was linking to that as you commented =)
01:46:04 <tdammers> I figured :)
01:46:20 <statusfailed> wait a minute, Fay has typeclasses now?!
01:46:44 <tdammers> acme-php is great fun for someone with lots of PHP-induced battle scars like myself
01:46:52 <johnw> statusfailed: since when?
01:47:28 <srhb> I thought they were waiting for Haskell-suite (which is apparently vapourware?)
01:47:30 <statusfailed> johnw: oh damnit I misread something ;_;
01:47:50 <statusfailed> gutted
01:47:52 <johnw> haskell suite is in-progress-ware
01:47:56 <srhb> OK :)
01:47:59 <srhb> That's better.
01:48:26 <Hafydd> asymptote-ware
01:50:35 <quchen> Haskell-Suite?
01:50:56 <quchen>  > The task to build a fully modular, composable suite of libraries and tools, which taken together comprise a full Haskell compiler
01:51:08 <quchen> Like GHC+Cabal?
01:51:44 <johnw> if GHC were all those things, yeah
01:51:59 <quchen> So what's missing?
01:52:24 <srhb> It's actually a really noble effort. I think it will have a huge impact if it's succesful.
01:52:25 <johnw> the "fully modular, composable suite of libraries" part
01:52:36 <bxc> how is that different from haskell-platform?
01:52:43 <johnw> GHC is a monolith that few understand
01:52:58 <johnw> bxc: HP is just a collection of Haskell libraries
01:53:02 <johnw> not Haskell libraries for procesing Haskell
01:53:10 <bxc> oh i see
01:53:23 <quchen> johnw: Oh, so the Suite would be a chunk that lexes, a chunk that optimizes, a chunk that installs packages etc?
01:53:28 <johnw> for example, what if today you wanted to write a tiny utility that uses type inference to determine what an identifier at a particular position in your source code is
01:53:40 <johnw> try doing that with GHC API, and let me know when you're done screaming
01:54:02 <johnw> quchen: I'm not sure that Haskell-Suite aims to replace Cabal
01:54:15 <srhb> It does not.
01:54:24 <johnw> it would give you chunks for tokenizing, parsing, type resolution, optimizing, etc.
01:54:29 <quchen> johnw: I'm completely unfamiliar with the project, so I was just throwing catchwords out there hoping I would hit something
01:54:49 <johnw> lol
01:55:06 <quchen> Texas sharpshooting ;-)
01:58:07 <ion> Reached a milestone in ersatz code.
01:58:08 <ion> λ> do solveWith (minisatPath "/tmp/foo/cryptominisat-2.9.6-linux-static64") $ do a <- exists; b <- exists; assert $ not b && ((not a `xor` false) === b); return (a, b, a `xor` b, a && b)
01:58:10 <ion> (Satisfied,Just (True,False,True,False))
01:59:16 <Kinnison> ion: nice
01:59:39 <quchen> @hackage ersatz
01:59:39 <lambdabot> http://hackage.haskell.org/package/ersatz
01:59:48 <ion> http://github.com/ekmett/ersatz
01:59:52 <quchen>  > 404 Not Found
01:59:53 <quchen> :-(
01:59:59 <quchen> git works.
02:01:57 <Breadmonster> Is there a significant performance difference between Haskell and OCaml?
02:02:17 <johnw> that depends on too many factors to answer
02:02:46 <shachaf> Yes -- five letters is ~30% shorter than seven letters.
02:02:52 <shachaf> That's a signifact difference in my book.
02:03:04 <shachaf> (Imagine all the extra words I could get in my book if I talked about OCaml instead of Haskell!)
02:03:16 <ivanm> oh, great, whilst trying to work out how to solve my current issue with ghc-core-create-core in haskell-mode for emacs, one of the google results was of me trying to solve this problem about 18 months ago :p
02:03:22 <Breadmonster> Well, there's clearly a difference between hand optimized C and Haskell.
02:03:42 <shachaf> Is "optimized C" a language?
02:03:49 <johnw> and are you comparing to unoptimized Haskell?
02:03:58 <Breadmonster> Point taken.
02:04:02 <shachaf> There are many differences between the two.
02:04:04 * frerich takes bets on how long until this discussion moves to the 'languages are not implementations' discussion
02:04:05 <statusfailed> ivanm: nice :D
02:04:07 <quchen> shachaf: Just letrec out the name of the programming language.
02:04:14 <shachaf> "Haskell" can easily be faster than "C", though.
02:04:30 <shachaf> For example, if you're compiling to a machine designed for graph reduction!
02:04:35 <Breadmonster> Fine, as you wish.
02:04:41 <johnw> shachaf: I can say "C" much faster than I can say "Haskell"
02:04:51 <Breadmonster> Anything I ask about this topic, can be dissected and distorted.
02:04:52 <shachaf> johnw: Hence my previous argument about OCaml vs. Haskell.
02:04:55 <shachaf> Two letters shorter!
02:05:04 <ivanm> johnw: depends if you drag it out or not: "Ceeeeeeeeeeeeeeeeeeeeeeeee........" :p
02:05:20 <Breadmonster> I wanted to do something with low latency systems, and I was wondering if Haskell would be appropriate, its performance critical.
02:05:22 <shachaf> Breadmonster: The issue isn't just that people here like to nitpick -- although that's probably true -- it's that the question doesn't mean much.
02:05:23 <statusfailed> Breadmonster: performance is a tricky beast. You really have to ask a very specific question to get a good answer
02:05:27 <ivanm> Breadmonster: depends on how much work you put into the code
02:05:35 <ivanm> if you really optimise the code well, then either one can be faster
02:05:36 <shachaf> You have to take something more concrete in order to be able to measure it.
02:05:39 <ivanm> same as any two languages...
02:06:15 <johnw> Breadmonster: what you want to ask is: can the same person, with the same level of knowledge and experience in both languages (this being nearly impossible), and with the same degree of interest in both solutions, write the same program for the same platform given the same resources and constraints, in both Haskell and OCaml, to determine which result has better performance
02:06:29 <quchen> Breadmonster: Short version: Haskell is among the faster languages (C, Java, ...) and not among the slow ones (Python, Perl, ...).
02:06:39 <shachaf> "the same program"?
02:06:47 <shachaf> I think you're missing quantifiers here.
02:06:49 <Breadmonster> quchen: Yeah, but that's really compiler dependent.
02:07:01 <johnw> where the two programs are isomorphic up to behavior
02:07:01 <statusfailed> shachaf: does "a program to compute the same result from the same input" work?
02:07:03 <Breadmonster> johnw: I get your point, but the language idioms vary.
02:07:23 <shachaf> quchen: Languages aren't fast. :-(
02:07:25 <Breadmonster> johnw: That doesn't count, recursion is more expensive than iteration when calculating factorials, say.
02:07:38 <shachaf> statusfailed: No. Which program are we talking about here?
02:07:40 <johnw> Breadmonster: unless your compiler turns recursion into iteration :)
02:07:45 <ion> λ> let fullAdder a b cin = (s2, c1 || c2) where { (s1,c1) = halfAdder a b; (s2,c2) = halfAdder s1 cin }; halfAdder a b = (a `xor` b, a && b) in do solveWith (minisatPath "/tmp/foo/cryptominisat-2.9.6-linux-static64") $ do a <- exists; b <- exists; c <- exists; let { (d, e) = fullAdder a b c }; assert $ d && e; return ((a,b,c),(d,e))
02:07:46 <statusfailed> shachaf: I don't know anymore, i'm going to go hide ;_;
02:07:47 <ion> (Satisfied,Just ((True,True,True),(True,True)))
02:07:48 <shachaf> Breadmonster: Recursion is a semantics thing, not an implementation thing.
02:08:01 <quchen> shachaf: "fast" was a word hull that seemed to fit there. :P
02:08:09 <Breadmonster> johnw: Then we can compare MLton to GHC.
02:08:13 <quicksilver> using a garbage collected runtime for low-latency systems does require some detailed knowledge + craftmanship.
02:08:16 <Breadmonster> My point is more dependent on the programmer.
02:08:18 <Breadmonster> Not the system.
02:08:22 <shachaf> Before you can say "x is more expensive than y" you have to have an operational semantics for both of them.
02:08:29 <quicksilver> and lazy evaluation probably makes it worse.
02:08:48 <Breadmonster> Ah, thank you quicksilver, that's an important point.
02:09:00 <frerich> shachaf: My wife says "x is more expensive than y" all day long without having "oeprational semantics" at all. Go figure.
02:09:08 <johnw> lol
02:09:35 <quchen> frerich: She's probably not Turing-complete.
02:09:36 <LambdaDusk> anyone know how I can deal with "HTTP handler not configured" from HXT? I don't even use any network documents
02:09:41 <shachaf> quicksilver: Only if your operational semantics makes it so!
02:09:52 <shachaf> For example if you're compiling to x86.
02:10:04 <Breadmonster> Yes, I will be compiling to x86.
02:10:10 <Breadmonster> With that assumption in mind.
02:10:32 * shachaf sighs
02:10:39 <Breadmonster> Also that the most functional programming I have are the cesspool of C++ templates, can we please restart this converstation?
02:10:55 <Breadmonster> *fp experience is
02:10:59 <quicksilver> shachaf: hush.
02:11:06 <Breadmonster> ...that was an interesting grammar screw up.
02:11:07 <quicksilver> shachaf: I was talking about the runtime.
02:11:15 <shachaf> My point is just that you have to know what question you're asking.
02:11:36 <edwardk> ion++
02:11:59 <hkBst> is grapefruit any good?
02:12:05 <Breadmonster> Its a bit bitter.
02:12:08 <edwardk> hkBst: its tasty
02:12:18 <Breadmonster> hkBst: You're talking about the fruit, right?>
02:12:38 <LambdaDusk> hkBst: I recommend netwire - grapefruit is quite outdated
02:12:43 <hkBst> Breadmonster: I'm asking after the FRP library
02:12:53 <Breadmonster> hkBst: My bad.
02:12:54 <hkBst> LambdaDusk: ah
02:12:54 <frerich> Breadmonster: I think you can't claim that it's bitter (i.e. more bitter than something else) without operational semantics!
02:13:00 <LambdaDusk> hkBst: Or reactive-banana
02:13:17 <LambdaDusk> hkBst: It's a pain to get grapefruit to compile, it's that old
02:13:38 <ivanm> LambdaDusk: just like eating it is? :p
02:13:55 <LambdaDusk> hkBst: So, reactive-banana if you're after monads, netwire if you like arrows
02:14:46 <LambdaDusk> so, no one knows why HXT doesn't let me parse any document?
02:15:11 <ivanm> LambdaDusk: did you put the error up anywhere?
02:15:15 * hackagebot io-streams 1.0.0.1 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.0.0.1 (GregoryCollins)
02:15:23 <ivanm> and is it any document, or just one of the documents you want to parse? :p
02:15:25 <LambdaDusk> ivanm Will do so now
02:15:38 <kosta1> If I have Just 5, how can I add add 1?
02:16:06 <shachaf> fmap (+1)
02:16:16 <shachaf> (Which will keep Nothing as Nothing, as you want.)
02:16:24 <hpaste> LambdaDusk pasted “map.hs” at http://hpaste.org/83572
02:17:05 <tdammers> > (+ 1) <$> Just 5
02:17:07 <lambdabot>   Just 6
02:17:17 <kosta1> (+10) <$> Just 5
02:17:21 <tdammers> > fmap (+ 1) (Just 5)
02:17:23 <lambdabot>   Just 6
02:17:41 <kosta1> Can you show me how to do it using >>= ?
02:17:44 <LambdaDusk> > maybe 0 (+1) (Just 5)
02:17:46 <lambdabot>   6
02:17:46 <tdammers> > do { x <- Just 5; return $ x + 1 }
02:17:48 <lambdabot>   Just 6
02:18:01 <ivanm> LambdaDusk: is that file a local one?
02:18:07 <tdammers> > Just 5 >>= return . (+ 1)
02:18:08 <hkBst> LambdaDusk: thanks for the recommendations
02:18:11 <lambdabot>  Terminated
02:18:17 <LambdaDusk> ivanm: Yes, it's in the same folder
02:18:37 <tdammers> > Just 5 >>= return . (+ 1)
02:18:40 <lambdabot>   Just 6
02:18:49 <tdammers> kosta1: there you go
02:18:51 <Breadmonster> shachaf: How do I learn Haskell?
02:19:07 <Breadmonster> Guess the only way to go ahead is to try implementing it twice
02:19:25 <Kinnison> Breadmonster: I learned through long hours of hard graft
02:19:31 <Kinnison> Breadmonster: and reading books
02:19:33 <kosta1> ok, I'll use Just 5 >>= return . (+1)
02:19:35 <kosta1> thanks a lot!
02:19:40 <shachaf> Breadmonster: Well, learning to write fast Haskell code is rather different thing from learning to write fast C code.
02:19:49 <Breadmonster> I know.
02:19:52 <shachaf> Just to keep that in mind. :-) You need to think about different things.
02:19:53 <LambdaDusk> Breadmonster: http://book.realworldhaskell.org/read/ and http://learnyouahaskell.com/chapters
02:19:59 <Breadmonster> That's what's kept me off purity.
02:20:06 <shachaf> Anyway, people often recommend those books LambdaDusk just mentioned.
02:20:14 <Breadmonster> It makes things really, really difficult to optimize.
02:20:17 <shachaf> I like _Programming in Haskell_ but it's not free online.
02:20:19 <LambdaDusk> the first one especially
02:20:35 <Breadmonster> shachaf: Meh, I'll get a copy somehow.
02:20:50 <Breadmonster> I just need a book to teach me how it clicks.
02:20:52 <ivanm> LambdaDusk: where is doMap from?
02:20:52 <johnw> Breadmonster: I wouldn't say so much difficult, but different; the difficulty more related to skill and experience, than to the facilities available
02:21:06 <Breadmonster> I didn't like SICP because it didn't teach me how scheme worked.
02:21:18 <shachaf> Breadmonster: ?
02:21:24 <shachaf> "worked"?
02:21:26 * ivanm agrees with shachaf's "?"
02:21:30 <LambdaDusk> ivanm: It's just the parsing arrow
02:21:34 <Breadmonster> shachaf: I misspoke.
02:21:44 <ivanm> LambdaDusk: well, hayoo can't find it...
02:21:45 <Breadmonster> I find it difficult to grasp idioms at face value.
02:22:00 <shachaf> It goes through writing a Scheme compiler, doesn't it?
02:22:11 <Breadmonster> shachaf: In Scheme.
02:22:11 <ivanm> yup
02:22:19 <sopvop> @pl \a b c -> a:b:c
02:22:19 <lambdabot> (. (:)) . (.) . (:)
02:22:20 <shachaf> That seems as close to "understanding how a language works" as you can expect an introductory book to reasonably get you.
02:22:21 <Breadmonster> I wasn't comfortable with scheme.
02:22:24 <LambdaDusk> ivanm: It's a function of type "doMap ::FilePath -> IOSArrow XmlTree TiledMap" I wrote, just at is as "undefined"
02:23:10 <LambdaDusk> ivanm: *add it
02:23:19 <Breadmonster> Also, why do Haskell programmers adore their typing system?
02:23:24 <LambdaDusk> ivanm: I don't think you need the 300 lines for it
02:23:42 <LambdaDusk> Breadmonster: Because it makes them feels smug and superior over PHP programmers
02:23:49 <johnw> because it's adorable!
02:23:58 * johnw hugs his typing system
02:24:06 <Breadmonster> LambdaDusk: doesn't it make stuff more difficult to write?
02:24:18 <johnw> it makes incorrect code very hard to write
02:24:23 <Breadmonster> LambdaDusk: And it isn't like C++ where you can find a tweak around things.
02:24:26 <mm_freak_> Breadmonster: easier, and once you master it, it actually writes for you
02:24:27 <LambdaDusk> Breadmonster: they need that smugness because being a good haskeller doesn't land you job, being a mediocre PHP programmer gets you dozens of offerings
02:24:56 <bxc> some of us get jobs from haskelling...
02:25:00 <Breadmonster> johnw: True, but I once tried to implement a LISP in C++
02:25:02 <Breadmonster> It was a bitch.
02:25:10 <LambdaDusk> Breadmonster: and not to mention the almost orgasmic feeling when after 8 hours the type inferer finally accepts your code
02:25:13 <ivanm> LambdaDusk: are you using dummyHTTPHandler?
02:25:15 <awestroke> how do I sort a list alphabetically, with a secondary sorting to resolve ties?
02:25:22 <LambdaDusk> ivanm: No, how?
02:25:26 <Breadmonster> awestroke: Try merge sort.
02:25:30 <snoyberg> LambdaDusk: if there's one thing i've learned in my programming career, it's that very few programmers from any other language need a reason to feel smug relative to PHP programmers
02:25:33 <johnw> awestroke: see the comparing function
02:25:33 <ivanm> LambdaDusk: well, that's what's throwing the error
02:25:39 <shachaf> Breadmonster: You seem a bit hostile here. Is your goal to learn Haskell, or to show those Haskell people how they're all wrong, or what?
02:25:41 <ivanm> LambdaDusk: I'm trying to work out how you're actually reading the file
02:25:46 <ivanm> (and I've never used HXT before)
02:25:52 <typoclass> Breadmonster: on a more serious note, we feel the type system combines the best of static and dynamic languages. it combines "i don't have to debug so much because the compiler tells me about stuff" and "i don't have to repeat the same type signatures over and over because we have powerful type inference"
02:25:54 <shachaf> awestroke: There's a nice idiom for it using the Monoid instance for (r ->) and Ordering
02:25:56 <Breadmonster> shachaf: Oh, I'm sorry, I didn't mean to come across that.
02:26:00 <Breadmonster> *as that
02:26:03 <ivanm> awestroke: define a custom a -> a -> Ordering function
02:26:04 <LambdaDusk> ivanm: "readDocument" does that, doesn't it?
02:26:05 <ivanm> then use sortBy
02:26:17 <Breadmonster> Hmm.
02:26:18 <mm_freak_> i view haskell's type system as a kind of artificial intelligence…  at some point it starts knowing what you want and effectively writes your code
02:26:21 <ivanm> LambdaDusk: I don't know, you haven't shown me any code using it! ;-)
02:26:28 <shachaf> > sortBy (comparing length ++ compare) $ words "these are a few words to demonstrate -- they'll be sorted by length, and then sorted lexicographically"
02:26:31 <lambdabot>   ["a","--","be","by","to","and","are","few","then","these","words","sorted",...
02:26:41 <LambdaDusk> it's in like 4 of http://hpaste.org/83572
02:26:55 <shachaf> Hmm, instead of (++) you should say (<>)
02:27:00 <johnw> shachaf: yeah, I was gonna say...
02:27:01 <ivanm> LambdaDusk: so it is :s
02:27:01 <awestroke> shachaf: how does ++ work there?
02:27:01 <shachaf> (++) only works in lambdabot.
02:27:03 <typoclass> shachaf: awesome, very good, thanks
02:27:06 <johnw> ++ is Caleskel?
02:27:13 <mm_freak_> :t (++)
02:27:15 <ivanm> LambdaDusk: I just saw that doMap used fp, so I didn't think to check where else you used fp
02:27:15 <tdammers> bxc: ...while others have to smuggle haskell code into production systems, risking their job doing so...
02:27:15 <lambdabot> Monoid m => m -> m -> m
02:27:17 <shachaf> (++) is defined in lambdabot to be mappend
02:27:18 <ion> @type (<>) -- Does lambdabot have this yet?
02:27:20 <lambdabot> Monoid m => m -> m -> m
02:27:21 <shachaf> You should use (<>) instead.
02:27:24 <frerich> So mappend would just as well?
02:27:26 <typoclass> awestroke: it's the Monoid instance for ((->) a)
02:27:29 <bxc> tdammers: hey they got prolog into windows
02:27:46 <tdammers> bxc: :x
02:27:48 <ivanm> LambdaDusk: have you tried shrinking that function to track down where the error is coming from?
02:27:58 <johnw> http://byorgey.wordpress.com/2011/04/18/monoids-for-maybe/ goes into that trick is greater detail
02:27:59 <Breadmonster> shachaf: Fine, thanks for everything.
02:28:01 <Breadmonster> Last question.
02:28:04 <ivanm> i.e. does runX $ readDocument [] fp work ?
02:28:05 <Breadmonster> Does Haskell run on Windows?
02:28:14 <tlaine> yup
02:28:15 <awestroke>  Not in scope: `<>'
02:28:16 <ion> @faq Can Haskell run on Windows?
02:28:17 <lambdabot> The answer is: Yes! Haskell can do that.
02:28:18 <johnw> as does http://brandon.si/code/the-monoid-instance-for-ordering/
02:28:23 <typoclass> Breadmonster: yes
02:28:28 <mm_freak_> Breadmonster: the compiler runs on windows and produces windows executables
02:28:35 <mm_freak_> haskell is just a language…  it doesn't run =)
02:28:37 <bartavelle> tdammers, you can smuggle haskell without anyone objecting by replacing all the ruby crap
02:28:42 <bartavelle> this worked for me
02:28:45 <shachaf> Breadmonster: ?
02:28:52 <shachaf> Oh well, I don't know.
02:28:55 <LambdaDusk> ivanm: hm weird... read document alone doesn't throw any error
02:29:01 <Breadmonster> typoclass: And it can work with the Windows API?
02:29:07 <mm_freak_> Breadmonster: yes
02:29:12 <Breadmonster> Alright then.
02:29:14 <johnw> ooh, nice, and also http://www.markhneedham.com/blog/2012/05/23/haskell-using-monoids-when-sorting-by-multiple-parameters/
02:29:15 <LambdaDusk> @faq can Haskell solve the world hunger problem?
02:29:16 <Breadmonster> Thank you, gentlemen.
02:29:16 <lambdabot> The answer is: Yes! Haskell can do that.
02:29:20 <ivanm> LambdaDusk: right... slowly start adding in your other bits and see where the error comes in
02:29:21 <tlaine> :D
02:29:29 <Breadmonster> @faq
02:29:29 <lambdabot> The answer is: Yes! Haskell can do that.
02:29:37 <shachaf> We should really get rid of @faq
02:29:38 <Breadmonster> Now it all makes sense.
02:29:41 <typoclass> Breadmonster: haskell's foreign-function interface (calling out to c functions) is pretty mature and straightforward to use
02:29:46 <johnw> @faq Can you get rid of @faq?
02:29:46 <lambdabot> The answer is: Yes! Haskell can do that.
02:29:47 <LambdaDusk> ivanm: On the other note, how do I use this "dummyHTTPHandler"?
02:29:49 <awestroke> shachaf: Not in scope: `<>'
02:29:54 <LambdaDusk> @vixen
02:29:54 <lambdabot> I've never canceled a subscription to a newspaper because of bad cartoons or editorials. If that were the case, I wouldn't have any newspapers or magazines to read.
02:29:54 <shachaf> awestroke: See Hoogle
02:29:56 <mm_freak_> Breadmonster: should any function not be defined in the base library and you can't find a third party library for it you still have the foreign function interface, so you can easily build the bridge yourself
02:29:56 <shachaf> @hoogle <>
02:29:57 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
02:29:57 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
02:29:57 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
02:30:00 <shachaf> Hmm.
02:30:01 <shachaf> Not that.
02:30:03 <Breadmonster> Oh, okay.
02:30:07 <Breadmonster> That sounds excellent.
02:30:15 <shachaf> Weird.
02:30:20 <shachaf> awestroke: It's in Data.Monoid
02:30:26 <LambdaDusk> haskell's FFI is the most beautiful I have ever seen
02:30:38 <typoclass> awestroke: it's relatively new. (<>) is a synonym for mappend. you can always use "comparing length `mappend` compare"
02:30:45 <ion> lambdadusk: Also take a look at bindings-DSL.
02:30:53 <awestroke> works, thank you!
02:30:55 <ivanm> LambdaDusk: you don't want to; that's what throws that error!
02:31:07 <mm_freak_> Breadmonster: bringing a WinAPI function into scope is usually a one-liner, but sometimes you have to perform conversion between a haskell constructor and a C struct…  it's not too hard though
02:31:18 <ivanm> LambdaDusk: also, @vixen now resolves to @nixon
02:31:35 <LambdaDusk> ivanm: But why would it ever try to download a file?
02:31:50 <mm_freak_> and you want to give those things shorter names…  WinAPI code loves to fill your screen width
02:31:52 <ivanm> LambdaDusk: well, I don't know what the rest of your code does, or how to use HXT, so I don't know ;-)
02:31:55 <mm_freak_> MsgWaitForMultipleObjectsEx
02:32:07 <mm_freak_> the more powerful haskell equivalent of that:  "atomically"
02:32:24 <shachaf> I would not say "equivalent"
02:32:27 <shachaf> It's very different.
02:32:32 <shachaf> But there's some overlap.
02:32:44 * typoclass . o O ( it's a very different equivalent )
02:32:56 <mm_freak_> shachaf: the purpose is the same…  MsgWaitForMultipleObjectsEx is the equivalent of select/poll/epoll
02:33:03 <mm_freak_> and in haskell you don't select/poll/epoll =)
02:33:12 <LambdaDusk> ivanm: No wait, when I remove "doMap", it still throws that error
02:33:13 <shachaf> mm_freak_: Sure, but that has nothing to do with STM
02:33:23 <ivanm> LambdaDusk: so, start stripping out other bits!
02:33:24 <shachaf> That's implemented at a different level.
02:33:29 <mm_freak_> shachaf: waiting for multiple objects surely does
02:33:30 <shachaf> Anyway, never mind.
02:33:41 <mm_freak_> shachaf: unless you employ some switching variable
02:33:45 <mm_freak_> MVar (Either a b)
02:33:59 <LambdaDusk> ivanm: The actual error is not that one - it is just a warning, the interpreter continues
02:34:01 <mm_freak_> but then you're really just emulating STM =)
02:34:13 <LambdaDusk> ivanm: it says "fatal error" but it's actually just a notice
02:34:30 <ivanm> LambdaDusk: oh... I thought you were saying it was a fatal error :/
02:35:43 <LambdaDusk> ivanm: The error message begins with "fatal error" and then it stopped, so I thought is was an error
02:36:10 <ivanm> LambdaDusk: errors don't kill ghci though; do you actually get the data out that you were expecting?
02:36:55 <LambdaDusk> ivanm: No I got "*** Exception: Prelude.head: empty list"
02:37:16 <ivanm> ahhhh
02:37:27 <LambdaDusk> ivanm: Which I think is why the parsing failed
02:37:35 <LambdaDusk> ivanm: Wow I am dumb
02:37:53 <ivanm> well, that means that you got no results, right?
02:37:59 <kosta1> Sorry, I need your help again..
02:38:26 <kosta1> let mAddOne x = return x+1
02:38:33 <kosta1> (Just 5) >>= mAddOne
02:38:50 <kosta1> gives No instance for (Num (Maybe b0))
02:39:00 <ion> return x+1 = (return x)+1
02:39:12 <kosta1> aaaah thanks
02:39:27 <kosta1> hence the . in the last answer you gave me :)
02:39:28 <quchen> kosta1: use return (x+1).
02:40:15 <ion> > fmap (+1) (Just 5)
02:40:17 <lambdabot>   Just 6
02:40:37 <LambdaDusk> it's the DTD
02:40:42 <LambdaDusk> *rage*
02:41:20 <LambdaDusk> it's the *censored* DTD that kills my parser
02:42:34 <LambdaDusk> now it works, you're all invited to my "now it works" party
02:43:18 <Breadmonster> Anyone here from or living in geneva?
02:43:51 <quchen> I know a couple of people at CERN, but haven't been there
02:43:52 <ion> I follow the Geneva conventions.
02:44:06 <Breadmonster> quchen: Oh cool.
02:44:20 <Breadmonster> quchen: How did you meet them?
02:44:25 <quchen> -> blah
02:45:40 <LambdaDusk> Breadmonster: You know what I love about Haskell? It just works. Once it compiles, it works. And It does exactly what you expect it to do.
02:46:08 <edwardk> pchiusano++
02:46:13 <Breadmonster> LambdaDusk: Yes, that is something I would like too.
02:46:18 <edwardk> (for noting that we can kill Plan in machines)
02:47:08 <shachaf> edwardk: What's going on with machines?
02:47:29 <edwardk> pchiusano noted that with the new Machine model Plan is redundant
02:47:32 <LambdaDusk> Breadmonster: For example, I spent all day yesterday to make a parser for .tmx files in Scala and often got funky results... but in Haskell it plain works
02:47:50 <ivanm> LambdaDusk: except in your case, it compiled but _didn't_ work... :p
02:47:51 <edwardk> i'll wait until i'm fully conscious to double check but it looks like it works out
02:48:03 <kosta1> Why isn't "Either" in the prelude a Monad?
02:48:21 <shachaf> edwardk: "new" as in, the GADT-to-functor transition?
02:48:24 <Hafydd> Either a is, if Control.Monad.Instances is imported.
02:48:28 <shachaf> Or something else?
02:48:29 <Hafydd> Or in newer versions.
02:48:37 <Hafydd> ...of GHC
02:48:39 <Xaratas> arg, i do not understand wath the compiler wants me to tell -.-
02:48:50 <kosta1> i'll try
02:48:53 <edwardk> kosta1>>> :m + Control.Monad.Instances
02:48:53 <edwardk> >>> return 2 :: Either Int Int
02:48:55 <edwardk> Right 2
02:50:21 <quchen> edwardk: .Instances is deprecated, what happens when it's removed? Embedded in Prelude?
02:50:37 <edwardk> kosta1: they've been embedded in the Prelude
02:50:44 <edwardk> er quchen
02:50:45 <kosta1> if i import Control.Monad.Instances it works
02:50:47 <kosta1> thanks! :)
02:50:56 <hpaste> Xaratas pasted “Pattern Exception” at http://hpaste.org/83573
02:51:07 <quchen> edwardk: Either is presumably just Error, right?
02:51:15 <edwardk> kosta1: its missing from there for historical reasons and because there was a long standing debate about the semantics of fail
02:51:26 <edwardk> the good guys won in the end
02:51:39 <Xaratas> can you help my why the pattern in startList is non-exhausive?
02:52:08 <LambdaDusk> ivanm: Hush, haskell is the best language, period
02:52:21 <ivanm> LambdaDusk: some people prefer Agda...
02:52:22 <ivanm> ;-)
02:52:54 <LambdaDusk> ivanm: Some people also prefer suicidal extreme sports - doesn't make it a great thing
02:52:59 <edwardk> ivanm: that doesn't keep us from being insular and mocking them
02:53:04 <ivanm> edwardk: heh
02:53:25 <quchen> edwardk: The Either monad in Prelude doesn't use fail. Is that what the good guys wanted?
02:53:48 <LambdaDusk> Breadmonster: http://hammerprinciple.com/therighttool/items/php/haskell
02:54:04 <LambdaDusk> scroll down to the second last item
02:54:17 <quchen>  > 5 % PHP
02:54:21 <quchen> Well played
02:55:19 <Jeanne-Kamikaze> I wonder who is voting for shooting yourself in the foot and annoying syntax in haskell
02:55:28 <Jeanne-Kamikaze> and verbose :/
02:56:29 <quchen> I think those pages were voted for by Gaussian noise
02:56:49 <crl> > axe'' "haskell"
02:56:51 <lambdabot>   ["has","kell"]
02:57:03 <Breadmonster> ...how on earth does that work
02:57:04 <Breadmonster> ?
02:57:24 <crl> my useless function still there ;)
02:57:30 <Hafydd> > axe'' ""
02:57:32 <lambdabot>   ["",""]
02:57:38 <Breadmonster> crl: What does it do?
02:57:41 <tlaine> > axe'' "dragonborn"
02:57:43 <lambdabot>   ["drago","nborn"]
02:57:45 <crl> cut in 2
02:57:46 <Breadmonster> axe'' "Hello World!"
02:57:52 <crl> equal parts
02:57:53 <Breadmonster> Oh, right, explains.
02:57:53 <LambdaDusk> > let owl = axe'' "" in owl
02:57:56 <lambdabot>   ["",""]
02:58:03 <Hafydd> Hahahah.
02:58:51 <crl> @unset axe'
02:58:51 <lambdabot> Unknown command, try @list
02:58:52 <frerich> Xaratas: You use "all@(a:as) = candidatesb' ..." but candidatesb' might return an empty list in which case 'a:as' does not match.
02:59:14 <frerich> Xaratas: It seems you hit this case.
02:59:26 <Hafydd> @src axe''
02:59:27 <lambdabot> Source not found. My mind is going. I can feel it.
03:01:06 <Xaratas> frerich: ok, but candidatesb' is the same function you have given me last time, it is not possible for it to build an empty list with dimension = dim = n = 3
03:02:57 <frerich> Xaratas: It's the only place where you lack a pattern match I can see, and maybe candidatesb' has a bug which makes it return an empty list? Should be easy to verify.
03:03:00 <LambdaDusk> Anyone have the Bzip2 in a haskell module?
03:03:19 <ivanm> LambdaDusk: you could try the zlib library
03:03:22 <ivanm> not sure if it would though
03:03:36 <LambdaDusk> zlip only had zlib and gzip
03:06:51 <Xaratas> frerich: somehow its the second startList defination
03:08:46 <Xaratas> oO
03:09:12 <Xaratas> its a typo
03:11:14 <edwardk> quchen: yes
03:11:43 <edwardk> quchen: technically i wanted to go one step farther and have fail s = Left (error s)
03:12:04 <edwardk> quchen: then the Right x <- foo hack for list comprehensions would work
03:12:21 <edwardk> but we wouldn't incur the Error constraint.
03:12:22 <edwardk> but cooler heads prevailed ;)
03:13:40 <quchen> I think it's a step towards getting rid of error.
03:13:43 <quchen> Eh, fail
03:14:16 <quchen> I assume the evil people wanted fail = Left?
03:14:18 <LambdaDusk> quote of the student next to me "That Maybe type is unhandy and useless - just return false"
03:14:53 <ion> just return FileNotFound
03:15:04 <quchen> LambdaDusk: data TrueFalse a = False | True a
03:15:06 <quchen> Works for me
03:15:26 <typoclass> LambdaDusk: right, but that would require everything and the dog to be Bool?
03:15:43 <quchen> TrueFalse also has the advantage that it can easily be converted to Maybe, for which there's very good standard lib support in Haskell!
03:15:56 <LambdaDusk> quchen: +1
03:16:16 <LambdaDusk> however I can't use the standard Bool any more
03:16:30 <quicksilver> trueFalseToMaybe :: TrueFalse a -> Maybe a; trueFalseToMaybe = unsafeCoerce.
03:16:50 <LambdaDusk> oooooo unsafeCoerce - I like that word
03:16:59 <quchen> DONT
03:17:01 <quchen> :D
03:17:35 <LambdaDusk> oooo I can turn IO to pure now
03:17:37 <LambdaDusk> perfect!
03:17:53 <shachaf> LambdaDusk: unsafeCoerce doesn't do that.
03:17:55 <mikeplus64> quicksilver: surely that won't work, unless Nothing/False and Just/True have the same runtime rep?
03:17:58 <shachaf> It'll just crash your program.
03:18:03 <LambdaDusk> but unsafePerformIO
03:18:05 <hiptobecubic> LambdaDusk, you want unsafePerformIO
03:18:08 <shachaf> unsafeCough will
03:18:15 * shachaf sighs
03:18:24 <johnw> unsafeSigh
03:18:27 <hiptobecubic> I'm not suggesting that you actually use it, mind you
03:18:35 <shachaf> It is important to understand that "IO A" is a type which is completely unlike "A"
03:18:39 <wuttf> What's wrong with unsafePerformIO, I use it in almos every function I write.
03:18:43 * wuttf runs
03:18:57 <quchen> unsafeCoerce . unsafePerformIO :: IO (TrueFalse a) -> Maybe a
03:19:00 <LambdaDusk> @type unsafePerformIO . readFile
03:19:02 <lambdabot> Not in scope: `unsafePerformIO'
03:19:16 <quicksilver> mikeplus64: indeed, that is the requirement.
03:19:27 <quicksilver> mikeplus64: (they will have the same rep, in GHC, if the constructors are in the same order)
03:19:38 <ion> unsafeCoerce . unsafePerformIO . unsafeCoerce
03:19:46 <quchen> Spoiler: they aren't
03:19:50 <shachaf> quicksilver: In this case, yes, but there are a bunch of things to worry about when you start doing tricky reasoning like that.
03:19:52 <quchen> Oh wait nevermind
03:19:53 <quchen> They are.
03:19:59 <typoclass> LambdaDusk: is the person objecting to the names Maybe/Just/Nothing, or objecting to the idea behind them?
03:20:09 <mikeplus64> quicksilver: won't they have different heap objects? even though they are "the same"
03:20:22 <shachaf> quicksilver: For example, if you compile data Foo = Foo {-# UNPACK #-} !Int; data Bar = Bar {-# UNPACK #-} !Int with different optimization levels, you won't be able to unsafeCoerce between them.
03:20:29 <quicksilver> mikeplus64: not sure what that means. types don't have heap objects, values do.
03:20:33 <hiptobecubic> I'm imagining a file type agnostic tool that finds an embedded "modeline" of sorts, which contains build instructions for the current file. Does anyone know if such a thing exists already?
03:20:35 <quicksilver> shachaf: yes, I know, it wasn't a serious suggestion
03:20:39 <quicksilver> I'm sorry if it appeared to be.
03:20:44 <LambdaDusk> typoclass: As far I got it, he doesn't like that you have to clunkily convert the maybe type every time he needs the value
03:20:59 <shachaf> quicksilver: rwbarton was doing this sort of thing semio-serouriously at one point.
03:21:13 <quicksilver> mikeplus64: and it happens that the heap object format for the two will be the same, as it happens
03:21:19 <quicksilver> although that is not promised by anything.
03:21:21 <shachaf> Working with Data.Map by unsafeCoercing it to an equivalent representation, doing things to the tree, and coercing it back.
03:21:23 <LambdaDusk> is there any actual use in unsafeCoerce?
03:21:29 <shachaf> Yes.
03:21:33 <mikeplus64> quicksilver: neat
03:21:39 <shachaf> Sometimes you are smarter than the compiler.
03:21:48 <LambdaDusk> me? never
03:22:20 <quicksilver> the safe use for it is when the two types are *actually* the same
03:22:25 <quicksilver> but the compiler can't see that they are
03:22:36 <YayMe> :t liftM2
03:22:38 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
03:22:46 <quicksilver> then it really isn't doing anything - it's just witnessing a proof that for some reason the compiler can't follow.
03:23:00 <YayMe> :t liftM2 mplus
03:23:01 <lambdabot> (Monad m, MonadPlus m1) => m (m1 a) -> m (m1 a) -> m (m1 a)
03:23:05 <LambdaDusk> like when you have GLfloats everywhere?
03:23:06 <shachaf> lens has 213 uses of unsafeCoerce
03:23:34 <typoclass> shachaf: edwardk is 213 times as smart as ghc?
03:23:48 <quchen> typoclass: It's a logarithmic scale
03:23:49 <shachaf> (Admittedly almost all of them fit into a common pattern and are "relatively" guaranteed to be safe.)
03:23:52 <quchen> e^213
03:23:56 <YayMe> I'll go with 213 times as smart as me, which is why I should use it 0 times
03:24:06 <shachaf> typoclass: Most of those unsafeCoerces are there because of me, sadly.
03:24:21 <typoclass> shachaf: heh
03:24:28 <shachaf> I was not smart enough to not mention it to edwardk, though.
03:25:17 <LambdaDusk> shachaf: Does lens bear the "Safe" pragma?
03:25:44 <shachaf> If you compile with -fsafe
03:27:14 <crl> safe = unsafe . unsafe
03:27:23 <shachaf> Anyway, no one has answered my question yet! What is a minimal reasonable axiom to add as a GHC extension to allow you to write (forall p. p Char -> p Bool) -> Void?
03:27:45 <shachaf> Er.
03:27:48 <shachaf> s/axiom/extension/
03:27:55 <ion> counsafe
03:30:14 <ivanm> shachaf: I'm still not sure why you'd want to be able to say that... but I for one haven't answered because I have nfi ;-)
03:30:29 <shachaf> ivanm: To be able to do the sorts of things GADTs let you do.
03:30:54 <shachaf> data Foo a where A :: ... -> Foo Char; B :: ... -> Foo Bool
03:30:58 <shachaf> blah :: Foo Char -> ...
03:31:04 <shachaf> blah (A ...) = ...
03:31:08 <shachaf> -- don't need to match on B!
03:35:48 <LambdaDusk> step 1: Site shows attacks in real time
03:35:48 <LambdaDusk> step 2: Site down after attack
03:35:49 <typoclass> you don't need to match on B because blah is already declared to be ":: Foo Char -> ...", so it couldn't possibly be called with a "B :: Foo Bool"
03:36:02 <typoclass> right?
03:36:04 <shachaf> Right.
03:36:13 <typoclass> hm! interesting
03:36:14 <shachaf> (B x) will always have type Foo Bool
03:36:25 <shachaf> And since you know Bool isn't equal to Char, you don't need to match on it.
03:36:36 <typoclass> shachaf: exactly
03:37:38 <shachaf> Anyway, I don't think rank-2 types are enough to do it (maybe this is a good thing!) so I'm wondering what is.
03:39:56 <quicksilver> shachaf: if rank-n types were enough to do GADTs, then GADTs would be in System F
03:40:08 <quicksilver> and GHC wouldn't need System Fc
03:41:10 <shachaf> quicksilver: I don't think this (Is Char Bool -> Void) thing is the reason GHC uses System Fc. :-)
03:41:29 <quicksilver> not that specific thing
03:41:32 <quicksilver> but GADTs in general.
03:41:47 <shachaf> Either GADTs or TypeFamilies are enough for that.
03:41:59 <quicksilver> type families also require Fc
03:42:02 <quicksilver> as I understand it
03:42:39 <shachaf> Anyway, GADTs give you a lot of things. I just want to know what a minimal thing to add on top of Leibniz equality that would give you this would be.
03:42:50 <shachaf> quicksilver: You can make type equality witnesses, more or less, in System F, can't you?
03:43:41 <quicksilver> well I think the Fc paper explains where the line is
03:43:54 <quicksilver> http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/fc-tldi.pdf
03:44:11 <LambdaDusk> What is the most unnecessary use of GADTs I could do?
03:44:24 <shachaf> quicksilve: I should probably read that. :-)
03:45:21 <shachaf> quicksilver: Anyway, I suspect GHC's implementation of this particular thing is an explicit "if it can't unify, allow the case to be omitted without a warning" thing.
03:45:31 <shachaf> (Not that I know what I'm talking about!)
03:45:47 <YayMe> I know that none of you care, but do any of you think FP will become as common place as Java in the next decade? Just found it interesting, this fpcomplete.com website claims so and I've never heard anyone say such a thing
03:46:53 <quicksilver> a decade is a long time in a computer programming
03:47:02 <frerich> Is it the website which recently announced it's the year of IPv6?
03:47:08 <quicksilver> although, the last one wasn't.
03:47:27 <quicksilver> a time traveller from 2003 wouldn't even notice he'd moved.
03:47:44 <supki> YayMe: where does it claim so?
03:47:49 <RichyB> They would if they played any videogames.
03:48:08 <LambdaDusk> YayMe: In a different way - functional aspects will enter more and more languages, but languages like Haskell and OCaml will not become top tiers
03:48:11 <RichyB> Or tried writing any Haskell code. ;)
03:49:06 <kqr> YayMe, yup, i think so
03:49:14 <kqr> YayMe, because i think languages like Java will adopt FP idioms
03:49:22 <kqr> YayMe, like they already are
03:51:30 <typoclass> YayMe: i don't know, particularly because mainstream acceptance requires luck, marketing, timing, all kinds of things. but i do think that fp features slowly seep over into other languages. java and c++ are getting closures for instance. limited forms of type inference are slowly getting into c# apparently. for a while, c# has optionally supported Maybe. etc.
03:52:28 <typoclass> YayMe: a provocative way of phrasing it would be "look at haskell if you want to know what programming in 2030 will be like" :-)
03:52:43 <YayMe> https://www.fpcomplete.com/page/about-us
03:53:09 <LambdaDusk> I think the mainstream languages are a bit locked ... php for web, c++ for games, java for commercial - and that's it and it won't change that quickly
03:53:28 <YayMe> typoclass: That's like someone in the 60's thinking "I'll learn LISP, closures will catch on ~2010"
03:53:30 <LambdaDusk> mostly because of a classic hen&egg situation in the big corporations
03:54:13 <typoclass> YayMe: yeah?
03:54:52 <kqr> typoclass, there's a bit of type inference in c++ too
03:55:05 <typoclass> kqr: right
03:55:19 <kqr> typoclass, but i really do think c# is a great language in that it seems to just slowly seep in everything functional it can
03:55:25 <LambdaDusk> just declare evrything as Object in Java - bam, type inference
03:55:27 <YayMe> typoclass: I just mean; it would have been accurate for someone to stake that claim back then, but a bit useless no? Similarly so learning haskell to prep for 2030... if that's when I'll get to use these concepts I've learned without people jeering and calling my code overly-clever garbage...
03:55:41 <kqr> LambdaDusk, there's an important difference
03:55:56 <YayMe> LambdaDusk: Yeah, that's my thought, which is why I kind of thought it a bit of a stretch to find this website claiming FP will become so large
03:57:04 <LambdaDusk> YayMe: Corps stick with their languages cos it's what their employees know - and as long as they require this particular language, their employees will only learn that one
03:57:08 <YayMe> though I'm not convinced FP will really seep into those languages like you might think.. if people were going to become comfortable with ADTs in Java, they'd become comfortable with Haskell
03:57:32 <YayMe> and I don't see the latter happening and therefore not the former
03:57:33 <sopvop> How to parse several of same postfix expressions with parsec style Expression parsers? Is it ok to just specify list of "Prefix..." several times in op table?
03:59:43 <kqr> YayMe, why not? people seem to like it well enough in scala
03:59:46 <kqr> YayMe, even java developers do
04:00:00 <kqr> YayMe, to them, it's just a neater way to think about subclasses
04:00:07 <YayMe> Or immutability, I just don't see 90% of developers really getting there heads around working with that
04:00:25 <kqr> immutability is not an all or nothing thing either
04:00:32 <YayMe> kqr: Do you think scala will gain the acceptance of java or C++ in the next decade?
04:00:52 <kqr> people i've worked with have come to me months later and said, "you know, since I worked with you i've been starting to think more about referential transparency and my code has become a lot better"
04:00:56 <typoclass> YayMe: about overly clever garbage, i think a balance is needed. it's sad if someone has no interest in advancing his skills and basically has 1 year of experience which he has been repeating for 15 years. the other extreme, someone who never comes up with a working program because he keeps redesigning it, isn't very effective either
04:01:18 <supki> YayMe: where does it say anything about "next decade"?
04:01:49 <YayMe> supki: I'm being generous, the way I read that it sounds like they expect there to be a storm that happens
04:01:58 <kqr> YayMe, no, but i think something like C# will support something like ADT:s soon enough
04:02:00 <YayMe> maybe I'm wrong
04:02:01 <supki> Ah, I see
04:02:03 <shachaf> i love truisms
04:02:08 <kqr> YayMe, java in general is very slow to evolve because of several reasons
04:02:11 <shachaf> and clichés, and platitudes
04:02:13 <shachaf> they are so easy
04:02:17 <kqr> YayMe, but java isn't representative of everything that is the status quo either
04:02:27 <YayMe> kqr: Really? That would be awesome.
04:06:24 <YayMe> typoclass: Yeah, I get that, but when I say people see overly clever garbage, I refer to things like using functional composition or any of the basic concepts of Haskell which outside of 2% of devs, no one has ever seen
04:07:45 <typoclass> YayMe: i do have doubts about haskell becoming mainstream, mostly because of this notion that to use haskell, you need 4 doctorates and knowledge of 9000 incomprehensible math concepts. unfortunately, many haddock pages and other materials involuntarily encourage that
04:08:11 <kqr> typoclass, i think that's where the community can reeaally improve
04:08:25 <YayMe> Absolutely! I still have never made heads or tails of that "Why functional programming matters" document
04:08:31 <kqr> i mean, it's friendly enough and willing to explain at any level. it's just that the pre-written explanations are all assuming a bit
04:08:44 <typoclass> YayMe: but another question is, what would "becoming mainstream" really buy us. it's nice ego-wise, but ...
04:08:52 <YayMe> everytime I see someone link that I cringe, the thing is an irony all it's own because to someone who doesn't already know why it matters they just see a bunch of gibberish which couldn't actually matter
04:10:16 <kqr> typoclass, i personally think it would improve the standards of code everywhere
04:10:19 <kqr> typoclass, which is great
04:11:20 <typoclass> YayMe: about functional composition, i guess that might be an issue of teaching? presenting it in accessible ways? i think it might help if you say "it's like a pipe in the shell. 'cat | grep' is analogous to 'grep . cat'"
04:11:22 <YayMe> typoclass: I prefaced my question with I know nobody cares here, I get avoid success at all costs, but if these concepts became as common as Java/C++ like that page states then I could use stuff like this at work without people freaking out: static Func<T,V> c<T,U,V>(this Func<T,U> target, Func<U,V> compose) return x => compose(target(x));
04:12:03 <kqr> YayMe, it's not "(avoid success) at all costs", it's "avoid (success at all costs)" ;)
04:12:06 <shachaf> You probably should not use that.
04:13:00 <YayMe> shachaf: Just a for example.. I don't know that I would use it really
04:13:54 <typoclass> YayMe: right, you clearly have a problem there with syntax clutter getting in the way. the readability is what makes (.) great. the above stuff isn't nicely readable :-/
04:14:36 <YayMe> typoclass: it would be readable to use, someFunc.c(anotherFunc).c(heyAnotherOne)
04:14:53 <shachaf> Also known as "map"
04:15:24 <shachaf> C# doesn't support higher-kinded polymorphism, sadly.
04:15:50 <shachaf> To typoclass: "higher-kinded" means, in this case, abstracting over something that takes arguments.
04:16:13 <shachaf> E.g. class Functor f a where fmap :: (a -> b) -> f a -> f b -- the polymorphism is over different fs
04:16:14 <typoclass> YayMe: right, but that might be hard to sell because people will say "i could just do someFunc(anotherFunc(heyAnotherOne(x)))"
04:16:47 <Botje> typoclass: people are perfectly happy to chain functions together in jQuery
04:17:22 <tdammers> Botje: but jquery chaining is not 100% the same as function composition
04:18:02 <tdammers> at least it doesn't feel like it
04:18:14 <Botje> it's future pipelining >:)
04:18:15 <YayMe> typoclass: Yep. That's all well and good, but you could do the same in haskell with $ but instead we use . often because it's a nice clean approach for some things
04:18:38 <tdammers> it's more like, you call a function to modify an object, and the function returns the object, which is convenient because you can now call another method
04:18:41 <YayMe> tdammers: it doesn't return a re-evaluatable computation like function composition
04:19:08 <tdammers> YayMe: that's more to do with purity than anything
04:19:26 <tdammers> or did I misunderstand?
04:19:35 <tdammers> I think I did
04:19:55 <typoclass> shachaf: right. so you're saying Functor is more powerful than the Func<T,V> gobbledegook? (of which i'm not really sure what programming language it's written in)
04:20:28 <tdammers> click(someFunc).change(someOtherFunc) is not a function
04:20:46 <YayMe> typoclass: Either way, I just find what that website states hard to swallow unless it is referring to 2030 or 2040, though it doesn't sound like that's what it means
04:20:51 <shachaf> typoclass: ?
04:21:16 <shachaf> It's not really related.
04:21:21 <YayMe> but some of you seem to think it will, so cheers to that, y'all have more experience to know about FP adoption than I
04:21:27 <shachaf> I'm saying you can't write a function that works for any Functor.
04:21:42 <Xaratas> for me as beginner: the $ is only a way to avoid parantheses right?
04:22:02 <shachaf> Xaratas: That is a primary use of it.
04:22:11 <shachaf> It's just a regular operator, though.
04:22:15 <typoclass> shachaf: sorry, i understood that higher-kinded polymorphism is possible in haskell, but not possible with the above Func<T,V> thing. er never mind :-)
04:22:18 <shachaf> There are a few other uses, like ($ x)
04:22:27 <shachaf> typoclass: The above thing is just syntax.
04:22:39 <shachaf> C# type declarations are optimized for a different use case. :-)
04:23:11 <typoclass> (... optimized to fill a quota of < > and ( ) ... )
04:23:40 <ildorn_> typoclass: or to look ugly
04:30:12 <stavrosmeke> hi! how come "length [isUpper, isLower]" is all right? the type of length is [a] -> Int, right?
04:30:19 <parcs> i wish every other function in Data.List wasn't space-leaky
04:30:47 <Botje> stavrosmeke: keep in mind that 'a' can be  ANY type, including functions.
04:30:58 <bxc> stavrosmeke: yeah; and that's a list of two things, with type a being a particular funciton type
04:31:26 <bxc> stavrosmeke: a function is a "value" in haskell
04:31:33 <ildorn_> stavrosmeke: and length isn't interested about what's inside the list
04:31:45 <bxc> so you can put it in a list, or pass it to other functions, etc
04:31:52 <stavrosmeke> Botje, bxc: why then length [Int] is wrong ?
04:32:05 <stavrosmeke> oh, it's value
04:32:06 <bxc> because Int is a type
04:32:14 <stavrosmeke> now I see
04:32:27 <bxc> if you use the haskell variant language called Agda
04:32:35 <bxc> then that would work because types are values in agda...
04:33:05 <bxc> but tha tlanguage is on crack
04:33:13 <YayMe> also, the sky is on the floor in agda
04:33:25 <stavrosmeke> ildorn_: are you sure? i gave an example above
04:33:46 <ildorn_> stavrosmeke: only because it's a type
04:34:06 <ildorn_> the typesystem stops that
04:34:44 <ildorn_> length isn't interested of the specific values inside the list but it has to be values
04:35:03 <mroman_> @hoogle temp
04:35:03 <lambdabot> System.Posix.Temp module System.Posix.Temp
04:35:03 <lambdabot> package template
04:35:03 <lambdabot> package template-haskell
04:35:29 <mroman_> That's probably not windowsy.
04:35:34 <ildorn_> stavrosmeke: did you look at the definition of length?
04:35:36 <stavrosmeke> ok guys. I see. basically, functions are values, that's why length accepts all that stuff. thanks!
04:35:51 <stavrosmeke> yes, i looked at it. [a] -> Int
04:35:56 <stavrosmeke> oops sorry
04:36:09 <stavrosmeke> that's not the definition, right?
04:36:13 <ildorn_> stavrosmeke: that's the type, not the definition
04:36:57 <ildorn_> it's more or less: length (_:xs) = 1+length xs
04:37:20 <stavrosmeke> yes. ok, i'll have a look at it right now. i just didn't know that functions are values. :-)
04:37:28 <YayMe> weird, looks like this whole fpcomplete.com site and it's "School of Haskell" just popped up in the last week, anyone heard anything about this?
04:39:02 <stavrosmeke> i thought it was something else. In fact, I had written that definition for my own version of length'. recursively
04:39:11 <kqr> YayMe, it's been going on for a while, but it got out of beta very recently (matter of days or so)
04:40:05 <ildorn_> stavrosmeke: i think it's different in the prelude (using foldr) but for better understanding
04:41:15 <hiptobecubic> Is it possible to install any version repa with the current platform without installing multiple versions of a platform package?
04:43:49 <hiptobecubic> It appears not, but that seems unlikely
04:46:22 <hiptobecubic> Either quickcheck is too new or base is too old I think.
04:47:10 <hiptobecubic> Although I don't understand why libraries explicitly depend on QuickCheck. If the tests were kept separate from the library then it seems like that wouldn't be necessary.
04:47:46 <hiptobecubic> It doesn't even run the tests when repa is built.
04:49:52 <supki> hiptobecubic: maybe it uses QuickCheck not for tests
04:49:56 <supki> i.e. not directly
04:50:29 <davean_> hiptobecubic: you sometimes need to test internal functions - how do you propose to keep those seperate?
04:50:42 <stavrosmeke> guys, if functions are "values", then they hold some value by default? what ghci is really doing in the case of "length [isUpper, isLower]?
04:51:19 <typoclass> hiptobecubic: it's like with documentation. if the tests are far away from the code, they are more likely to be out of date
04:51:32 <linduxed> if i've got a "Data.Map Integer [Integer]", how do i return the (k, v) that has the v with the maximum length?
04:51:59 <bxc> >  (head [isUpper, isLower]) 'c'
04:52:01 <lambdabot>   False
04:52:03 <typoclass> stavrosmeke: it only checks how many elements are in the list. it's not trying to run each function in the list
04:52:10 <davean_> typoclass: well, if they were outside the files themselves it could also allow invariants to be broken in some cases
04:52:47 <davean_> Thus some safety specifications require test cohabitation with the tested source
04:53:00 <tdammers> a more interesting question would be what happens when you apply the functions in that list
04:53:01 <davean_> I suppose you could make it conditional code though?
04:53:09 <hiptobecubic> typoclass, davean_, is there a way to disable the tests then for release?
04:53:18 <hiptobecubic> with cpp in the worst case
04:53:24 <hiptobecubic> or maybe the best case...
04:53:46 <davean_> hiptobecubic: uh, I suppose you could also do it with template haskell?
04:53:49 <srhb> linduxed: Generally it doesn't sound like what you want is a Map.
04:53:50 <davean_> hiptobecubic: why do you care?
04:53:51 <bxc> stavrosmeke: try to figure out whats going on in that  (head [isUpper, isLower]) 'c'   example
04:54:01 <srhb> linduxed: Or at least not a Map Integer [Integer]
04:54:09 <hiptobecubic> davean_, because it adds to dependency hell
04:54:10 <typoclass> hiptobecubic: you could tell cabal not to build them, using buildable: False or whatever
04:54:16 <linduxed> srhb: well, i've already got one  :-/
04:54:20 <tdammers> > map ($ 'c') [toUpper, toLower]
04:54:22 <lambdabot>   "Cc"
04:54:39 <typoclass> hiptobecubic: something like "if flag --with-tests, then build everything ..."
04:54:40 <srhb> linduxed: You can of course build an assoclist and sort that by ascending length of the values.
04:54:49 <davean_> typoclass: That doesn't work, for the reasons I listed
04:54:58 <linduxed> srhb: hmm, that could be an idea
04:55:14 <hiptobecubic> davean_, right now i can't install repa, for example, because it wants quickcheck between 2.3 and 2.5 OR base 4.6. This isn't possible with the current Platform unless you install two versions of quickcheck
04:55:27 <srhb> linduxed: But yeah, that operations sounds like you should consider a different data structure. Looking up elements by value rather than key in a Map is not efficient.
04:55:38 <davean_> hiptobecubic: Ok, well, I've never understood why to use the platform
04:55:51 <typoclass> hiptobecubic: here is an example. it may or may not be what you meant http://hackage.haskell.org/packages/archive/xmonad/0.11/xmonad.cabal
04:55:56 <srhb> linduxed: Anyway, look at the assocs function.
04:56:35 <hiptobecubic> davean_, the platform is *also* intended as a way to reduce the chaos of installing libraries that have interestingly conflicting dependencies
04:56:57 <linduxed> srhb: https://gist.github.com/5099130 i'm feeding that function [1..1000000] as x and giving it back the gradually growing cache
04:57:00 <frerich> linduxed: Looking things up in a map by looking at the *value* isn't a very common way to use a map. However, if it doesn't happen to often, you could turn the map to al ist and then use that, e.g.
04:57:07 <hiptobecubic> typoclass, right. This looks like it, yes?
04:57:22 <frerich> linduxed: maximumBy (comparing (length . snd)) (toList myMap)
04:57:23 <linduxed> srhb: at the very end of it all, i just need to  find the sequence with the greatest length
04:57:35 <typoclass> hiptobecubic: how do you mean?
04:57:49 <linduxed> frerich: sounds ok, thx
04:57:56 <hiptobecubic> typoclass, the conditional dependency on quickcheck
04:58:06 <linduxed> frerich: and yes, it'll only happen once every million executions
04:58:35 <hiptobecubic> damnit. I forgot to specify X11==1.6.0.* .... sihg
04:59:11 <hiptobecubic> I guess I'll start over again
04:59:29 <stavrosmeke> thanks guys, i see now. :-) cu
04:59:30 <typoclass> hiptobecubic: i'm not sure what exactly xmonad is doing there, but it's an example of using "if" in .cabal files, and they have a testing flag, and they do some -DTESTING thing with CPP, etc.
04:59:45 <davean_> hiptobecubic: well, if it'lljust work you can force repa to compile with a specific quickcheck, or if it can't you can just improve repa
04:59:48 <typoclass> just for inspiration
04:59:59 <srhb> In acid-state, once I've migrated a data type, is it possible to get rid of the migrations and only keep the code for the newest version?
05:00:26 <hiptobecubic> typoclass, right. So if -DTESTING is not defined then the dependency on quickcheck will not be considered and presumably the post-processed code will be absent those parts as well.
05:02:03 <srhb> It _looks_ like I can just change 'extension to 'base after starting the application with the migration.
05:02:19 <srhb> But is that an error-prone method?
05:02:43 <typoclass> hiptobecubic: yes presumably. the executable is built always. the library is built only when the "testing" flag is on. executable and library have different dependencies. and if testing is on, there's additional dependencies. that's how i interpret that file *shrug*
05:17:44 <linduxed> this code https://gist.github.com/5099227 causes a stack overflow when i run it. my guess is that this is caused by deep recursive calls for high values of x in cacheCollatz. how would i either increase the cache size or tweak the code to fit inside the stack?
05:18:23 <shachaf> @where rts-xc should be helpful for figuring out where the overflow is, by the way.
05:18:24 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
05:18:50 <linduxed> shachaf: good point, thx
05:19:40 <shachaf> Are you compiling with -O2?
05:20:00 <linduxed> no
05:20:23 <shachaf> Well then. You should do that.
05:20:39 <shachaf> There's still a problem, of course. Maybe that turns it into heap usage rather than stack usage in this case, I don't know.
05:20:43 <linduxed> this is the output from the lambdabot command https://gist.github.com/5099254
05:21:51 <linduxed> i added the -O2 and it resulted in the same output as pasted in the gist
05:22:18 * shachaf is about to board an aæeiroplane so can't really look at the actual code.
05:22:31 <linduxed> :-/
05:22:45 <linduxed> have a nice flight then, hope someone else can help me out
05:22:58 <shachaf> I'm sure someone else can.
05:24:51 <shachaf> (Also I think some of the advice I would give would be hints on the actual problem, rather than on Haskell. It's possible that you don't want that.)
05:25:22 <linduxed> i'm open to all criticism
05:26:09 <shachaf> hints /= criticism :-)
05:26:16 <shachaf> Let me see, maybe there's some time.
05:26:32 <shachaf> All you care about is the length, isn't it? Why do you store the whole sequence?
05:26:57 <linduxed> in the end, yes
05:27:05 <linduxed> as the comments at the top describe
05:27:26 <shachaf> ?
05:27:36 <linduxed> in the gist i posted before
05:27:59 <linduxed> https://gist.github.com/linduxed/5099227
05:28:03 <shachaf> All you care about, for a given number n, is the length of the sequence starting from that number. Right?
05:28:24 <linduxed> well, not really
05:28:36 <frerich> linduxed: I think it would be sufficient to keep track of the last number of the sequence, and the number of items you added to the sequence so far.
05:29:00 <shachaf> OK, maybe I should read the code instead of just saying things.
05:29:17 <shachaf> Better yet, you should let frerich help you, since I'm about to go.
05:29:38 <linduxed> in the end, yes, i only want to find the absolutely longest sequence of them all, but to avoid recomputing sequences, i created a cache in the shape of a Map so that one wouldn't need to revisit paths
05:29:53 <typoclass> shachaf: i think the idea is, if the cache has the sequence from 13 to 1, and (say) when checking the sequence starting at 42, we encounter 13 at some point, we can reuse the cached thingy
05:29:53 <linduxed> shachaf: ok, cya!
05:29:53 <arkeet> sure, but you don't need to store the whole path.
05:29:54 <arkeet> just how long it was.
05:30:07 <linduxed> typoclass: that's the idea, yes
05:30:27 <shachaf> arkeet is here too!
05:30:30 <arkeet> !
05:30:43 <frerich> linduxed: Did you benchmark that this cache actually helps anything?
05:30:43 <shachaf> I am rendered redundant, unless you need bad puns or pointless nitpicking.
05:30:58 <linduxed> frerich: haven't been able to, since it blows the stack every time
05:31:12 * shachaf actually vanishes this time.
05:31:25 <typoclass> shachaf: good flight!
05:31:49 <arkeet> bye shachaf
05:35:44 <hpaste> frerich pasted “Collatz lengths” at http://hpaste.org/83577
05:36:12 <frerich> linduxed: Check that link, it's a lame (but short) version. What I meant is the 'collatzLength' function: I don't actually compute the sequences. I just compute how long it would be
05:36:24 <frerich> linduxed: This thing, whenc ompiled with -O2, takes about 2 seconds on this system.
05:36:53 <linduxed> frerich: i already have a naive version https://github.com/linduxed/project_euler/blob/master/14.hs
05:37:01 <linduxed> or well, not naive
05:37:04 <linduxed> brute force
05:37:13 * Kinnison loves seeing PE solutions in haskell
05:37:20 <Kinnison> they're often very elegant
05:37:26 <linduxed> Kinnison: they indeed are
05:37:40 <linduxed> frerich: i think it's pretty much the same thing
05:38:03 <linduxed> frerich: i didn't use -O2 though, so maybe that speeds things up, but i wanted to do it with a cache
05:38:09 <frerich> linduxed: Does my version cause a stack overflow for you, too?
05:38:38 <frerich> linduxed: Oh well, if you insist on using a cache, feel free to go crazy :-)
05:38:43 <linduxed> haven't tried, will do now, but then again you don't use a map
05:39:44 <linduxed> hmmm, that code gets a stack space overflow, yes
05:39:50 <arkeet> make sure you aren't building up thunks?
05:40:08 <linduxed> ghc -prof -auto-all -O2 collatz.hs && ./collatz +RTS -p && cat collatz.prof
05:40:11 <linduxed> did that
05:40:20 <linduxed> frerich: &
05:40:24 <linduxed> ^
05:40:33 <frerich> linduxed: I just ran 'ghc -O2 collatz.hs && ./collatz'
05:40:50 <frerich> With ghc 7.4.2
05:41:15 <frerich> Maybe the output is wrong though, it says the number with the longest collatz sequence is 837799
05:41:20 <frerich> (525 items in the sequence)
05:41:34 <linduxed> hmmm
05:41:36 <linduxed> now it worked
05:41:41 <linduxed> when i didn't use the -prof
05:41:45 <linduxed> and -auto-all
05:41:58 <linduxed> weird
05:42:16 <linduxed> maybe my code works too if i don't use the profiling, i'll check that...
05:42:23 <typoclass> heh, i get a stack overflow, but no stack overflow with -O2. i tried a naive maximumBy (comparing snd) $ [(x, length $ takeWhile (> 1) $ iterate collatz x) | x <- [1..999999]]
05:43:21 <linduxed> wtf is this
05:43:26 <linduxed> it didn't blow the stack
05:43:41 <linduxed> it's as if adding the profiling stuff makes the stack not like me :-S
05:44:04 <frerich> typoclass: Maybe ghc doesn't fuse (is that the correct term?) 'length $ takeWhile (>1) $ iterate' very well, at least without -O2
05:44:52 <quchen> frerich: length doesn't fuse I think
05:44:54 <typoclass> frerich: no idea :-/ i don't know anything about stack overflows and performance in haskell
05:45:05 * frerich neither
05:45:38 <quicksilver> length does fuse.
05:45:42 <quicksilver> well it should.
05:45:56 <quicksilver> it's a foldr.
05:45:58 <typoclass> is fusion something that's only done with -O?
05:46:01 <quicksilver> yes.
05:46:34 <typoclass> quicksilver: aha. that slightly explains why thunks accumulate and overflow the stack, while it runs fine with -O2
05:46:37 <quchen> quicksilver: I don't think it does. At least neither in Data.List or GHC.Exts.
05:47:57 <frerich> What's also a little strange: my version (which doesn't build up collatz sequences) gets a stack overflow error if I change 'Integer' to 'Int' (just tried it to see whether that makes things go faster)
05:48:01 <crl> > (1,(),2)
05:48:03 <lambdabot>   (1,(),2)
05:48:25 <LambdaDusk> why are there packages on hackage that fail compiling because of simple syntax/reference errors? doesn't anyone try them before uploading?
05:48:26 <crl> > ([1],(),[2])
05:48:27 <lambdabot>   ([1],(),[2])
05:48:55 <crl> () matches any type?
05:49:06 <quchen> No. () has type ().
05:49:11 <frerich> crl: You are using tuples, they can have values of different types.
05:49:12 <quchen> Tuples can be heterogeneous.
05:49:12 <typoclass> LambdaDusk: probably they worked at some point, but then ghc or the base package changed
05:49:13 <crl> hmm
05:49:14 <linduxed> i can't figure this shit out
05:49:20 <quchen> > ("hello", 2, '4')
05:49:21 <lambdabot>   ("hello",2,'4')
05:49:24 <linduxed> why would the profiling make the stack blow up?
05:49:31 <crl> o right sorry tuples..
05:49:42 <quchen> Try lists on the other hand:
05:49:47 <quchen> > ["hello", 2, '4']
05:49:48 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
05:49:48 <lambdabot>              with actual ty...
05:49:51 <typoclass> linduxed: i bet profiling turns off several optimizations
05:50:05 <feliperosa> frerich: Try Word instead of Int, or Data.Bits.shiftR instead of div (I don't know your implementation).
05:50:08 <linduxed> typoclass: could be it, i wouldn't know though
05:50:25 <LambdaDusk> just annoying when you ifnally found a package that does what you need, it turns out to be uncompilable
05:50:38 <frerich> feliperosa: I'll try; FWIW my implementation is at http://hpaste.org/83577 (and changing the signature of collatzLength so that it uses 'Int' triggers a stack space overflow)
05:51:12 <quchen> frerich: Oh!
05:51:18 <quchen> Well, your "len" isn't strict
05:51:25 <quchen> It builds up a huge 1+1+1+1+1+... thunk
05:51:29 <frerich> Ah, of course
05:51:47 <hpaste> quchen annotated “Collatz lengths” with “Collatz lengths (annotation)” at http://hpaste.org/83577#a83580
05:51:51 <quchen> Try that one
05:51:51 <typoclass> LambdaDusk: that's true. the good news is that it's often easy to fix things like "function foo was in Control.Something, has now moved to Control.Foo.Something". you know "cabal unpack thepackage", right?
05:52:37 <quchen> Didn't see your code pasted earlier to I thought we were blind debugging again ;-)
05:52:48 <LambdaDusk> typoclass: I dread that, though - it basically means that I either have to include their code into my project or tell other people who want to use my package "but first you gotta repair that one"
05:53:49 <linduxed> hmmm, the stack doesn't blow if i set the maximum number to 50000, funnily enough
05:53:59 <hpaste> Quchen annotated “Collatz lengths” with “Collatz lengths (now with BangPatterns)” at http://hpaste.org/83577#a83582
05:54:01 <typoclass> LambdaDusk: yeah, but the maintainer will generally be very happy if you updated his package. if there is no (reachable) maintainer anymore, afaik there's a straightforward procedure where you can upload the updated package under the existing name
05:54:09 <linduxed> so it must be a question of massive recursion of some sort
05:55:06 <feliperosa> frerich: Chaging Integer to Word the program finishes running in 2 secs in my computer. Adding -fllvm gives me 0.37 secs.
05:55:55 <frerich> heh, not bad!
05:56:02 <linduxed> if i just use 50000 numbers, intead of 1000000 i get this .prof file https://gist.github.com/5099451
05:56:18 <quchen> frerich: Yeah, you don't need Integer here. The result is (well) inside the Int/Word range.
05:56:22 <linduxed> anything higher than 50000 (or somewhere close to that) blows the stack
05:56:34 <frerich> quchen: right, but when I wrote the program, I didn't know the result :)
05:56:49 <quchen> Oh so you know the result already, that makes it easier. Use Word16 :-)
05:57:00 <linduxed> looks like nonCachedSequence has a huge alloc
05:57:52 <typoclass> linduxed: reducing the problem size will avoid stack overflows. that kind of thing is normal (in any language)
05:58:00 <typoclass> linduxed: ... except if you have a program that really has an infinite loop bug, but that's a whole different problem where no amount of stack space will help :-)
05:58:13 <frerich> typoclass: An infinite amount of stack space might help!
05:58:29 <linduxed> typoclass: yes, i assumed so, that was why i lowered the number to get any profiling data at all
05:58:33 <crl> shachaf: dmwit , i tried to make a split in 3 in the model of split2 http://hpaste.org/83583
05:58:58 <crl> there are 2 steps of n/3
05:59:09 <frerich> quchen: Currently trying to use ($!) (your annotation doesn't typecheck, and I'm trying to figre out why not)
05:59:35 <frerich> Unfortunately ghc gives an 'No instance for (Num (Integer -> Integer))' error, this is usually a good indication that the issue has nothing to do with instances :}
05:59:57 <LambdaDusk> typoclass: I might give it a try... how can I achieve it?
06:00:43 <linduxed> well now that i've got the profiling data for both the one with caching and without it i can confirm that the one with caching is faster
06:00:55 <LambdaDusk> hm says it's maintained by felipe lessa...
06:01:07 <linduxed> doesn't change the fact though that i still can't use profiling on the one with the caching, due to the stack getting blown
06:01:11 <quicksilver> quchen: you're right, foldr would make it stack overflow, so it's needs to be either foldl' or hand-written, which stops fusion.
06:01:11 <frerich> quchen: Argh.
06:01:22 <quchen> frerich: Typechecks for me.
06:01:33 <quchen> Also use the BangPatterns version, see 2nd annotation
06:01:38 <quchen> (Nicer code)
06:01:49 <crl> pretty sure i could reduce the code size in http://hpaste.org/83583
06:01:56 <frerich> quchen: The issue is that I wasn't using your version: in ony place I mistyped $! as $1 which looks very similiar in my editor. And it gave a rather crzy error message.
06:02:03 <frerich> :-}
06:02:36 <quchen> crl: Type signatures and function descriptions please.
06:02:54 <quchen> Right now it's a haystack of xs ys zs ;-)
06:03:17 <crl> ok wait
06:03:19 <typoclass> LambdaDusk: well in general, you do "cabal unpack thepackage", then "cd thepackage" and you edit the files, fixing imports, whatever. when done, you run "diff" with some switches that i can never remember :-) and it will give you a patch file with all the changes you made. you can mail that to the maintainer, who will generally thank you a great deal
06:03:28 <frerich> quchen: Actually, if you use Int instead of Integer you get the wrong result.
06:04:12 <quchen> frerich: Wat
06:04:14 <typoclass> LambdaDusk: alternatively, you can of course use git or darcs to get that patch. the maintainer can tell you the details how that's handled in his project
06:04:21 <frerich> quchen: I suspect the issue is that in some cases the numbers in the collatz sequence become too large, so some overflow occurs which in turn screws the ocmputation of the length of the sequence.
06:04:23 <quchen> The largest numbers are in the millions, the collatz length is around 500
06:04:42 <frerich> quchen: Right but it's possible that elements of the collatz sequence are much larger than that.
06:04:43 <quchen> (Actually I might want to check on that "millions" thing
06:04:46 <quchen> )
06:04:55 <Botje> crl: what is that even supposed to do?
06:05:21 <quchen> Botje: presumably split a list in 3 parts. But anyway, your question is why I asked him to write some comments.
06:05:51 <frerich> feliperosa : Unfortunately the insight that 'Int' (or anything smaller than that) gives the wrong results kind of invalidates your benchmark, pity :}
06:05:54 <quchen> frerich: For PE you can always use Integer by the way, that's rarely the bottleneck
06:06:03 <frerich> quchen: What's PE?
06:06:07 <quchen> Project Euler
06:06:16 <quchen> Which is where your problem is from, presumably
06:06:19 <frerich> quchen: Oh, is that where this is coming from? I only picked up the idea from linduxed.
06:06:36 <quchen> https://projecteuler.net/problem=14
06:07:31 <Botje> crl: looking at split3L', you have too many cases there.
06:07:54 <Botje> crl: you pass third xs as the first and second parameters, and xs as the third
06:08:08 <Botje> crl: since third xs is 1/3 the size of xs, the case on line 6 can never happen
06:08:08 <supki> crl: there was codereduced version in Lenskell already I think?
06:08:31 <Botje> crl: moreover, since the first two are the same size, you can drop another case.
06:09:38 <hpaste> crl revised “crl”: “split in 3” at http://hpaste.org/83583
06:10:09 <crl> yes ..
06:10:10 <Botje> crl: much better.
06:10:22 <crl> and still really not proud of it
06:10:34 <Botje> crl: well, let's look at the global structure of split3L' first
06:10:45 <crl> Botje: split in 3 a list
06:11:14 <Botje> crl: is there any requirement for the split?
06:11:38 <quchen> split3 = foldr (\ x ~(a,b,c) -> (b,c,x:a)) ([],[],[])
06:11:46 <quchen> @let split3 = foldr (\ x ~(a,b,c) -> (b,c,x:a)) ([],[],[])
06:11:49 <lambdabot>  Defined.
06:11:50 <crl> to return the 1st third, 2nd third and 3rd in separate
06:11:53 <feliperosa> frerich: Well, there's always Word64, which is as fast as the other data types
06:11:53 <quchen> > split3 [1..10]
06:11:55 <lambdabot>   ([3,6,9],[2,5,8],[1,4,7,10])
06:12:20 <feliperosa> > 2 ^ 64
06:12:21 <quchen> feliperosa: On a 64bit machine yes.
06:12:22 <lambdabot>   18446744073709551616
06:12:31 <dmwit> :t chunksOf
06:12:33 <lambdabot> Int -> [e] -> [[e]]
06:12:52 <Botje> crl: wouldn't it be easier to measure the length of 'a third' first and just take/drop?
06:12:55 <dmwit> > let wrongSplit3 = transpose . chunksOf 3 in wrongSplit3 [1..10]
06:12:58 <lambdabot>   [[1,4,7,10],[2,5,8],[3,6,9]]
06:13:07 <dmwit> Botje: Doesn't play well with infinite lists.
06:13:14 <Botje> neither does this
06:13:18 <quchen> Botje: we found out yesterday how to split a list in two parts without using length. It even worked on infinite lists. :-)
06:13:19 <dmwit> Botje: (Assuming this is a continuation of yesterday's split2.)
06:13:44 <crl> Botje: clearly
06:13:47 <quchen> Botje: http://codepad.org/1oNpfztc
06:13:49 <crl> :)
06:13:53 <dmwit> Botje: Really? I haven't run it, but nothing in this appears hostile to infinite lists.
06:13:55 <Botje> dmwit: ah, didn't know that. I was just trying to improve the code I saw :)
06:14:13 <Botje> dmwit: the recursive call on line 7 in that paste?
06:14:25 <dmwit> What's wrong with that?
06:14:34 <dmwit> It starts producing right away in the "in" clause.
06:14:41 <arkeet> > transpose . chunksOf 3 $ [1..]
06:14:43 <lambdabot>   [[1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,7...
06:15:04 <arkeet> > (!!1) . transpose . chunksOf 3 $ [1..]
06:15:05 <Botje> dmwit: but b and c can only be known once the case on line 6 returns, no?
06:15:06 <lambdabot>   [2,5,8,11,14,17,20,23,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68,71,74,77...
06:15:13 <crl> yes the aim is to avoid built-in length, take, drop
06:15:23 <Botje> might want to state that up front :/
06:15:29 <crl> sorry forgot to specify
06:15:43 <dmwit> Botje: Yeah, this code looks wrong to me.
06:15:56 <dmwit> not 100% sure yet
06:16:18 <dmwit> But the existence of split3L and no split3L'' suggests something a bit wonky =)
06:16:33 <dmwit> or at least some permutation like \(a,b,c) -> (b,c,a)
06:16:36 <Xaratas> quchen: what means the ~ you used in the foldr?
06:17:00 <crl> it's working, but really ugly
06:17:04 <quchen> Xaratas: Irrefutable pattern.
06:17:17 <dmwit> ?wiki lazy pattern match
06:17:17 <lambdabot> http://www.haskell.org/haskellwiki/lazy_pattern_match
06:17:41 <quchen> Xaratas: Normally, when you match against (a,b), the compiler has to check whether what you've supplied is actually a tuple, so it has to be evaluated to some extent.
06:17:51 <quchen> ~ says "believe me, this *will* match".
06:18:22 <quchen> Therefore, to match the tuple, nothing has to be evaluated.
06:18:23 <feliperosa> quchen: Alright, I was only sugesting some speedups. If all you've got is a 8 bit machine and you want to compute some large numbers, then, well, you'll have to accept its speed. If you want to compute a much larger collatz chain then your only choice is to use bigger integers (read Integer).
06:18:34 <crl> split3' does just separate the 1st third to the rest
06:18:35 <Xaratas> a, ok
06:18:48 <crl> split3 does the remaining middle third
06:18:56 <typoclass> quchen: yeah, but the compiler (runtime) will still check, it will only do it a little later, won't it
06:19:31 <quchen> typoclass: Yes. If the pattern doesn't match, it will still complain.
06:19:31 <dmwit> Botje: Ah, right, so, of course the second bit can't start returning until it's seen the whole list. =)
06:19:49 <dmwit> Botje: You can't possibly hope to write a split3 that's productive in its second argument on infinite lists.
06:20:11 <LambdaDusk> typoclass: are you sure it was "cabal diff"?
06:20:27 <dmwit> So, yeah, now that I've had this observation, once again nothing about this code seems particularly hostile to infinite lists.
06:20:36 <quchen> typoclass:
06:20:37 <dmwit> LambdaDusk: I think he really meant just plain "diff".
06:20:39 <quchen> > let ~(a,b) = (1 :: Int) in a
06:20:40 <typoclass> LambdaDusk: nope, "diff" is a separate tool (not cabal diff)
06:20:41 <lambdabot>   Couldn't match expected type `(t0, t1)'
06:20:41 <lambdabot>              with actual type `GHC....
06:20:45 <dmwit> (don't think he said "cabal diff" anywhere)
06:21:18 <dmwit> lets are already lazy
06:21:22 <dmwit> > let (a,b) = undefined in 3
06:21:24 <lambdabot>   3
06:21:26 <aleator> I'd need to make a concurrent camera controlling system with a gui. Any tips on which libraries to look at? (I've got the camera control nailed down)
06:21:46 <dmwit> aleator: Do you know any GUI frameworks from another language?
06:21:53 <dmwit> If so, use the Haskell bindings to that framework.
06:22:25 <aleator> dmwit: Not really no. qt from ages back but that is it.
06:22:40 <dmwit> ?wiki GUI
06:22:40 <lambdabot> http://www.haskell.org/haskellwiki/GUI
06:22:54 <dmwit> Take your pick from there, then. There's some discussion of what's good and bad about each, IIRC.
06:23:38 <dmwit> gtk2hs and wkHaskell seem to be popular choices.
06:24:24 <dmwit> Oh, and win32, I guess, if you're into that kind of thing.
06:25:18 <applicative_> > let o = Left ([],[]); op x (Left (xs,ys))  = Right (x:xs,ys); op x (Right (ys,xs))  = Left (ys,x:xs) in foldr op o [1..100]
06:25:21 <lambdabot>   Left ([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,...
06:25:30 <applicative_> > let o = Left ([],[]); op x (Left (xs,ys))  = Right (x:xs,ys); op x (Right (ys,xs))  = Left (ys,x:xs) in foldr op o [1..10]
06:25:31 <lambdabot>   Left ([2,4,6,8,10],[1,3,5,7,9])
06:25:41 <aleator> dmwit: Linux luckily..
06:25:56 <LambdaDusk> wow darcs makes this quite easy
06:25:59 <dmwit> > let o = ([],[]); op x (xs,ys) = (ys,x:xs) in foldr op o [1..100]
06:26:01 <lambdabot>   ([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
06:26:05 <LambdaDusk> now to sit on my hands until something happens
06:26:11 <dmwit> > let o = ([],[]); op x (xs,ys) = (ys,x:xs) in foldr op o [1..10]
06:26:13 <lambdabot>  Terminated
06:26:18 <dmwit> lol wut
06:26:26 <dmwit> > let o = ([],[]); op x (xs,ys) = (ys,x:xs) in foldr op o [1..10]
06:26:28 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
06:27:23 <dmwit> > let o = ([],[]); op x (xs,ys) = (ys,x:xs) in foldr op o [1..11]
06:27:25 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9,11])
06:27:47 <dmwit> Neat, it even always puts the odd indices on the same side of the tuple.
06:28:06 <applicative_> yes, very swank
06:28:17 <quchen> > let o = ([],[]); op x (xs,ys) = (ys,x:xs) in foldr op o [2..11]
06:28:19 <lambdabot>   ([3,5,7,9,11],[2,4,6,8,10])
06:28:23 <quchen> So much for that
06:28:29 <dmwit> quchen: odd *indices*
06:28:34 <dmwit> not odd values, of course
06:28:35 <quchen> Oh. Pardon
06:28:36 <quchen> :-)
06:29:03 <dmwit> > partition odd [1..10] -- ;-)
06:29:05 <lambdabot>   ([1,3,5,7,9],[2,4,6,8,10])
06:29:05 <applicative_> you can't tell which is the one that would need to be fed next, so to say
06:29:07 <crl> thc men, i knew foldl could be used, but didn't know how
06:29:36 <dmwit> crl: But this is a very different kind of split!
06:30:45 <crl> it can be used to the other
06:31:15 <crl> for*
06:32:07 <applicative_> can such a simple method be used for larger tuples
06:32:13 <dmwit> sure
06:32:42 <dmwit> > let o = ([],[],[]); op x (xs,ys,zs) = (ys,zs,x:xs) in foldr op o [1..10]
06:32:44 <lambdabot>   ([3,6,9],[2,5,8],[1,4,7,10])
06:32:45 <aleator> Anyone know if GStreamer package does video?
06:33:05 <dmwit> It's even easy to generalize to n-tuples if you're okay with switching to n-lists instead. ;-)
06:33:09 <dmwit> aleator: It does some things.
06:33:33 <LambdaDusk> well I've been on this for 8 hours. I think it's time to eat. I crave a curry, can't explain why
06:33:34 <dmwit> The documentation on what it does is available on Hackage, though you may want to go straight to the gtk-hosted documentation.
06:34:06 <applicative_> > let o = ([],[],[]) ; op x (xs,ys,zs) = (x:zs,xs,ys) in foldr op o [1..10]
06:34:08 <lambdabot>   ([1,4,7,10],[2,5,8],[3,6,9])
06:34:15 <applicative_> ah yeah you did it
06:34:24 <aleator> dmwit: The documentation is a bit.. sparse.
06:34:46 <quchen>  > 15:11 < quchen> @let split3 = foldr (\ x ~(a,b,c) -> (b,c,x:a)) ([],[],[])
06:34:47 <quchen> Pfff
06:34:53 <dmwit> Right. You'll probably have to translate the documentation/tutorials for the C library into Haskell.
06:35:23 <dmwit> quchen: pfff, I suggested split n = transpose . chunksOf n yesterday
06:35:28 <dmwit> I'm hipsterier...
06:35:42 <quchen> Transpose is odd
06:35:50 <dmwit> transpose is zipN
06:35:57 <quchen> I always feel dirty using it.
06:42:14 <dmwit> > let chunk n [] = []; chunk n xs = () : chunk n (drop n xs); lazySplitAt (_:n) (x:xs) = let (b,e) = lazySplitAt n xs in (x:b,e); lazySplitAt _ xs = ([], xs); lazySplit n [] = []; lazySplit n xs = let (b,e) = lazySplitAt n xs in b : lazySplit n e; split n xs = lazySplit (chunk n xs) xs in split 3 [1..10]
06:42:16 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9,10]]
06:42:39 <dmwit> ah
06:42:52 <dmwit> I could fix that up, but that would be some serious \bot spam, so I won't.
06:46:17 <crl> just what is the ~ in foldr (\ x ~(a,b,c) ->...
06:46:56 <dmwit> ?wiki lazy pattern match
06:46:57 <lambdabot> http://www.haskell.org/haskellwiki/lazy_pattern_match
06:46:59 <frerich> dmwit: I always thought that transpose is too crazy a function to be useful to me, it never occurred to me that it works like some kind of 'zipN', thanks for pointing that out! :-)
06:47:09 <dcoutts> crl: it's a lazy pattern match (also called an irrefutable pattern)
06:47:11 <frerich> I think that's a much nicer way to think of it than the 'it rotates stuff'
06:47:46 <dcoutts> crl: it's equiv of: foldr (\x y -> let (a,b,c) = y in ... )
06:48:01 <crl> > (foldr (\ x (a,b,c) -> (b,c,x:a)) ([],[],[])) [1..6]
06:48:02 <lambdabot>   ([3,6],[2,5],[1,4])
06:48:17 <crl> mm k
06:48:26 <dcoutts> crl: the point of using it there is because you don't want your foldr function to be strict in the second arg, otherwise you don't get the incremental behaviour you want
06:49:23 <crl> it returns the same resul thought?
06:49:46 <applicative_> > (foldr (\ x ~(a,b,c) -> (b,c,x:a)) ([],[],[])) [1..]
06:49:48 <lambdabot>   ([3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,7...
06:50:02 <applicative_> > (foldr (\ x (a,b,c) -> (b,c,x:a)) ([],[],[])) [1..]
06:50:04 <lambdabot>   *Exception: stack overflow
06:50:45 * hackagebot syb 0.4.0 - Scrap Your Boilerplate  http://hackage.haskell.org/package/syb-0.4.0 (JosePedroMagalhaes)
06:50:52 <applicative_> not that the increments are too helpful here ...
06:51:16 <dcoutts> crl: for finite results yes, the point is that one version is incremental, the other has to traverse the full input list before returning anything
06:53:25 <crl> yes, but you often need the full result
06:53:51 <dmwit> frerich: =)
06:54:17 <crl> nah, yes you could just treat the 1st item of the result
06:54:21 <dcoutts> crl: imagine if something like map would always consume the full input list before returning anything?
06:54:46 <dcoutts> crl: and so force all that input into memory, and use linear stack etc. You probably wouldn't use it so much :-)
06:55:09 <crl> > drop 10 (foldr (\ x ~(a,b,c) -> (b,c,x:a)) ([],[],[])) [1..]
06:55:11 <lambdabot>   The function `GHC.List.drop' is applied to three arguments,
06:55:11 <lambdabot>  but its type `...
06:55:37 <crl> > drop 10 $ fst (foldr (\ x ~(a,b,c) -> (b,c,x:a)) ([],[],[])) [1..]
06:55:39 <lambdabot>   Couldn't match expected type `(t0 -> [a0], b0)'
06:55:40 <lambdabot>              with actual ty...
06:55:49 <applicative_> > drop 10 $ (foldr (\ x ~(a,b,c) -> (b,c,x:a)) ([],[],[])) [1..]
06:55:51 <lambdabot>   Couldn't match expected type `[a0]' with actual type `(t0, t1, t2)'
06:55:51 <mroman_> does Debug.trace write to stderr?
06:56:00 <dcoutts> mroman_: yes
06:56:19 <crl> > drop 10 $ fst ((foldr (\ x ~(a,b,c) -> (b,c,x:a)) ([],[],[])) [1..] )
06:56:21 <lambdabot>   Couldn't match expected type `([a0], b0)'
06:56:21 <lambdabot>              with actual type `(t...
06:56:47 <dmwit> crl: fst only works on 2-tuples
06:56:58 <dmwit> perhaps try (\(x,y,z) -> x)
06:58:51 <crl> yep works
06:59:01 <applicative_> > (foldr (\ x ~(a,b,c) -> (b,c,x:a)) ([],[],[])) [1..] ^. _1
06:59:03 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
06:59:23 <applicative_> > drop 10 $  (foldr (\ x ~(a,b,c) -> (b,c,x:a)) ([],[],[])) [1..] ^. _1
06:59:25 <lambdabot>   [33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87,90,93,96,99,102,1...
06:59:46 <applicative_> > drop 10 $  (foldr (\ x ~(a,b,c) -> (b,c,x:a)) ([],[],[])) [1..] ^. _2
06:59:48 <lambdabot>   [32,35,38,41,44,47,50,53,56,59,62,65,68,71,74,77,80,83,86,89,92,95,98,101,1...
06:59:56 <applicative_> heh
07:01:15 <applicative_> >   (foldr (\ x ~(a,b,c,d) -> (b,c,d,x:a)) ([],[],[],[])) [1..] ^. _4
07:01:17 <lambdabot>   [1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97,10...
07:01:17 <crl> the problem of your split3 is it browse all list, though it can just browse 2/3 of it
07:01:50 <crl> hmm no
07:02:10 <crl> mixing with other stuff
07:02:15 <arkeet> how can you ever know you've seen 2/3 of it without seeing all of it?
07:02:15 <applicative_> wow, this lazy pattern matching is obviously the wave of the future!
07:02:32 <arkeet> ~ looks like a wave.
07:02:37 <crl> arkeet: indeed im dump
07:02:39 <applicative_> or maybe its the return of some 80's thing...
07:03:02 <arkeet> but the 80's is the future!
07:03:12 <Hafydd> The 2080s
07:03:14 * applicative_ has always thought so
07:03:47 <applicative_> man io-streams has them clawing at each other it seems
07:04:10 * applicative_ will wait til it dies down to figure out what the vox populi thinks
07:04:44 <applicative_> it does now rate as the easiest way to download a webpage in haskell
07:04:45 <crl> my code got reduced in 2 lines..
07:08:45 <crl> > (transpose . (foldr (\ x ~[a,b,c] -> [b,c,x:a]) [[],[],[]]) ) [1..9]
07:08:47 <lambdabot>   [[3,2,1],[6,5,4],[9,8,7]]
07:09:03 <crl> hmmm
07:09:39 <applicative_> get "http://www.haskell.org/" concatHandler >>=  BS8.putStrLn
07:09:58 <crl> > (transpose . chunksOf 3) [1..9]
07:10:00 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
07:10:09 <arkeet> io-streams is snap's answer to yesod? ;)
07:10:12 <arkeet> er, to conduits
07:10:18 <johnw> essentially
07:10:38 <johnw> we need to designate someone else to reinvent everything from scratch as well
07:11:21 <applicative_> well there's a few other web frameworks :)
07:11:42 <johnw> and when they each need resource streams, they can reinvent a new iteratee library :)
07:11:47 <arkeet> > set (partsOf (traverse.traverse)) <*> (transpose . chunksOf 3) $ [1..9]
07:11:49 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
07:12:02 <applicative_> stepcut said happstack has been waiting to decide between pipes and iostreams
07:12:14 <arkeet> pipes looks pretty
07:13:11 <applicative_> so the 'old' web framework will soon be the most advanced; its the law of combined and uneven development as Trotsky used to say ...
07:17:40 <applicative_> io-streams has an amazing test suite but, ahem, no category laws can be stated
07:20:23 <quchen> Pipes has a neat .Tutorial module
07:20:30 <quchen> I wish more packages would do something like that!
07:20:46 <johnw> quchen: I want to make that a standard for my packages
07:24:49 <quchen> Oh, you're the maintainer?
07:25:04 <applicative_> yes it's an awesome scheme, io-streams has replicated it.
07:25:06 <quchen> Well then let me congratulate you personally, sir! That is awesome documentation.
07:25:13 <johnw> no, I'm not
07:25:18 <johnw> I want to replicate that style
07:25:31 <johnw> i've started one for gitlib, for example
07:25:38 <applicative_> I think tekmo may have written it, oddly
07:25:39 <quchen> Actually, things like these make users decide between equally valid libraries.
07:28:20 <applicative_> the separate scheme of having a few simple executable things under say examples/ is also really excellent; I think it makes a giant difference to uptake of a library
07:30:58 <arthurmaciel> good afternoon
07:32:38 <arthurmaciel> I've faced the monad concept while searching the web. I know it is too complicated to fully understand it now, but for the sake of curiosity what are monads used for?
07:33:05 <Botje> the simplest use cases are probably just moving data around.
07:33:49 <johnw> huh?
07:34:04 <johnw> arthurmaciel: Haskell uses it to manage side-effects relating to I/O, for example
07:34:22 <arkeet> it's important to remember that monads are an abstraction
07:34:40 <arkeet> many unrelated things fit the pattern of a monad.
07:35:33 <YOLO> im writin all dis sik code YOLO fam bless
07:35:41 <arkeet> no.
07:35:47 <YOLO> ye ye
07:36:15 <Botje> must be the weather.
07:36:25 <hiptobecubic> Botje, isn't it lovely?
07:36:44 * tdammers runs a countdown in his head
07:36:44 <YOLO> Oh I must say, the weather is simply divine
07:36:45 <hiptobecubic> Botje, it's almost like we're on Earth.
07:37:23 <YOLO> how do i google
07:37:37 <hiptobecubic> YOLO, you ask nicely for someone to do it for you
07:37:47 <elliott> YOLO: are you here to be productive or just waste people's time?
07:37:54 <elliott> everything you've said so far points strongly to the latter.
07:38:06 <YOLO> yo fam you is waste
07:38:17 <YOLO> cunt
07:38:21 <hiptobecubic> sigh
07:38:25 <Botje> yawn. I miss protontorpedo.
07:38:38 <srhb> @ops
07:38:38 <lambdabot> Maybe you meant: docs oeis pl
07:38:41 <elliott> srhb: they left.
07:38:44 <srhb> Daw.
07:38:47 <arthurmaciel> johnw and arkeet: I've read monads are used to run specific side-effects 'procedures' sequentially, so they can always run as expected in time. Is that right?
07:38:49 <elliott> too bad they left before they could be banned :(
07:38:54 <srhb> Indeed.
07:38:59 <Clint> i miss beaky
07:38:59 <applicative_> arthurmaciel: people get hung up on the general word 'monad', you can use all the particular monads without having the general concept
07:39:16 <arkeet> arthurmaciel: not "monads". the IO monad does that, but that's a specific monad.
07:39:18 <hiptobecubic> Clint, beaky is *probably* not dead yet
07:39:20 <srhb> anyway, is there a way to make cabal-dev traverse directories towards the root in order to find a cabal-dev directory rather than just giving up if there's not one present?
07:39:24 <Botje> we could ask the nice people at occ.ac.uk to ban this person from the internet.
07:39:33 <arkeet> other monads can be quite different.
07:39:41 <applicative_> arthurmaciel: sequencing like that is involved in the monad constituted by the IO _ types
07:40:00 <applicative_> oh like arkeet says
07:40:36 <applicative_> this web freenode interface has the irksome feature of not updating while you type
07:40:50 <srhb> applicative_: That sounds particularly nasty.
07:40:51 <arthurmaciel> arkeet and applicative_: could you please cite any other frequently used monad?
07:41:21 <srhb> arthurmaciel: Maybe, [], State, Reader, Writer...
07:41:27 <applicative_> arthurmaciel: have you looked at one of the better tutorials like 'Learn you a Haskell?" It takes a sensible approach to putting it all across
07:41:38 <hiptobecubic> arthurmaciel, there are a lot of monads that get used in almost *every* program. srhb listed some of the good ones there....
07:41:44 <applicative_> arthurmaciel: lists, parsers
07:41:50 <`ramses> applicative_: you mean webchat.freenode.net? It seems to update while typing here...
07:41:52 <arkeet> Reader is an example of a monad that has no notion of sequencing at all, really.
07:42:08 <arkeet> (it's a commutative monad)
07:42:11 <hiptobecubic> list is not really about sequencing either
07:42:17 <hiptobecubic> although i guess it does anyway
07:42:18 <applicative_> arthurmaciel: lots of things Foo _ things are monads but we don't necessarily think of them that way
07:42:39 <arkeet> hiptobecubic: sure, but order of statements in a do block matters for lists.
07:42:41 <arkeet> :p
07:42:45 <arkeet> not so for reader.
07:42:45 <arthurmaciel> applicative_: so why are they (essentially) monads?
07:42:56 <applicative_> arthurmaciel: are you familiar with a type system like the one in Haskell, ML and such like languages
07:43:07 <arthurmaciel> applicative_: I've begun reading RWH
07:43:21 <arthurmaciel> applicative_: my comprehension is limited.
07:43:27 <applicative_> ah good.  learn you a haskell might make a useful help
07:43:50 <applicative_> but we sometimes define datatypes with a parameter, e.g. Maybe a = Nothing
07:43:54 <applicative_> | Just a
07:44:06 <arthurmaciel> applicative_: sincerely I moved from it to RWH because I found LYH to 'slow' (or verby). But maybe I should go back.
07:44:19 <applicative_> or Listy a = Nil | Cons a (Listy a)
07:44:38 <applicative_> arthurmaciel: yeah either way, they have different merits
07:45:07 <applicative_> anyway, it is when a type declaration has that feature data Foo a = .....
07:45:20 <applicative_> that the question of the great classes, Functor and Monad arise
07:45:21 <arthurmaciel> applicative_: I believe I would need to see something moving from a non-monadic way (or style) to a monadic one.
07:45:46 <arthurmaciel> I'll look for examples. Thanks!
07:45:47 <applicative_> the are lists of Ints, Chars, and so on, there are Maybe Ints, Maybe Chars, etc
07:46:14 <hiptobecubic> arthurmaciel, it's easy to write off LYAH as toyish, but I found that it actually the best job of developing my intuition about things like applicative functors and monads. RWH was more like "Look. We can parse. Ignore the man behind the curtain."
07:46:16 <srhb> foo config = something with config vs. foo = do { config <- ask; something with config } --without reader vs. with reader
07:46:18 <applicative_> so each such type or type-maker -- List, Maybe, IO, ...
07:46:20 <srhb> arthurmaciel: ^^^
07:46:25 <hiptobecubic> actually did *
07:46:31 <applicative_> is the kind of thing that can a FUnctor or Monad
07:47:15 <`ramses> applicative_: with some constraints, that is
07:47:27 <applicative_> arthurmaciel: I think hiptobecubic is right, it's actually very great you are drawn into amazingly deep abstractions without noticing
07:47:56 <applicative_> `ramses: yeah, I have the new theory that we must begin right away imparting the idea of kind * -> *
07:48:20 <applicative_> `ramses: in one way or another
07:48:36 <`ramses> applicative_: that may be fine, but be careful not to make it appear as if every such type constructor can be a functor or monad
07:49:10 * frerich concurs with hiptobecubic, I liked how LYAH went from Functor (which is not too hard to understand) to Applicative to Monads; the transition helped me quite a lot.
07:50:34 <hiptobecubic> The first few times I wanted to use Applicative I had to go back and read it again, but eventually it stuck and now I'm pretty comfortable with them
07:50:48 <arthurmaciel> thank you, guys!
07:50:52 <hiptobecubic> Things like what *really* makes applicatives different from monads, etc
07:50:54 <arthurmaciel> Now it makes more sense.
07:51:20 <arthurmaciel> https://en.wikipedia.org/wiki/Monad_%28functional_programming%29 is helping too. (I sometimes need generical explanations combined with detailed ones :)
07:53:14 <hiptobecubic> arthurmaciel, I read that as well, but that rabbit hole is *deep*. Before you know it you start asking about kliesli categories
07:53:15 <quchen> hiptobecubic: Applicative + join = Monad
07:53:37 <quchen> Therefore, Monad - Applicative = join
07:53:43 <quchen> That's what's the *real* difference. ;-)
07:53:51 * arthurmaciel would love a language that could combine Scheme's easy syntax to Haskell's extreme power and abstraction capabilites...
07:53:54 <hiptobecubic> quchen, sure, but the implication is huge. It's not like "Monad + mempty + mappend = MonadPlus" which is pretty obvious
07:54:36 <quchen> That's right
07:55:22 <`ramses> quchen: also, applicative _can_ combine two contexts, as (<*>) has to do so, but still you cannot write (>>=) using (<*>)
07:55:52 <dmwit> There is not a unique choice of X that makes the equation Applicative + X = Monad...
07:55:56 <hiptobecubic> `ramses, the data dependency is what matter i think
07:56:04 <`ramses> quchen: so it feels as if the restriction is less then "you don't have join", there is a limited version of join
07:56:13 <hiptobecubic> matters*
07:57:07 <`ramses> hiptobecubic: yes, but I don't know how to define that restriction using the type constructors only. Saying "you don't have join" is saying that the type constructor does not form a monoid, but that's not true, I think
07:57:18 <arthurmaciel> does haskell support native threads or green ones only?
07:57:23 <quchen> `ramses: I like just looking at the type signature for bind: m a -> (a -> m b) -> m b. Using this in a Functor context, you can create a "m (m b)" out of it, and for flattening it out, you need join.
07:58:01 <dmwit> arthurmaciel: GHC has m-to-n threading; that is, however many green threads you have are mapped onto however many OS threads you request.
07:58:01 <quchen> arthurmaciel: forkOS launches a OS thread, but it's rarely used
07:58:06 <dmwit> quchen: incorrect
07:58:10 <quchen> Oh?
07:58:18 <dmwit> forkOS does not in any way guarantee that it will create a new OS thread.
07:58:20 <`ramses> quchen: true, but ( (<*>) :: f (a -> b) -> f a -> f b) also has to "combine" the first two fs, meaning there is some notion of join-ing
07:58:31 <dmwit> forkOS *does* guarantee that the green thread it runs will always be on the *same* OS thread.
07:58:35 <dmwit> But nothing more than that.
07:58:47 <quchen> Oh, thanks, didn't know that.
07:58:58 <quchen> So I can only have one forkOS'd thread at a time in a program?
07:59:05 <dmwit> arthurmaciel: You might like the non-GTK pieces of http://dmwit.com/gtk2hs
07:59:07 <quchen> Ooh nevermind wait wait
07:59:11 <dmwit> quchen: nope =)
07:59:17 <quchen> forkOS threads will always be mapped on the same OS thread
07:59:32 <quchen> whereas forkIO threads can be scheduled at will by the runtime wherever there's space
07:59:38 <dmwit> right
07:59:47 <quchen> Wonderful! Thanks :-)
07:59:58 <dmwit> So forkOS threads don't migrate, but you can still have many of them on a single OS thread.
08:00:13 <dmwit> ...and of course many spread across OS threads as well.
08:01:07 <quchen> So the only advantage of forkIO is that it can be knapsacked easier?
08:01:31 <quchen> ("only" in a non-belitteling context)
08:01:35 <hiptobecubic> dmwit, are you sure? I thought they always forked a new thread because of concurrency issues
08:01:52 <aristid> dmwit: and the number of real threads is still affected by the RTS configuration and not at all by the number of forkOS calls?
08:01:56 <arthurmaciel> thanks dmwit and quchen
08:01:57 <arkeet> forkOS = forkIO . runInBoundThread?
08:02:00 <frerich> quchen: I'd say that forkIO makes life easier for the runtime scheduler because it can choose the OS thread to execute on more freely.
08:02:06 <beaky> hello
08:02:14 <hiptobecubic> Clint, see?
08:02:22 <frerich> quchen: And forkOS is useful if you interface with some C library or so which always needs to be called in the same thread (because of thread-local storage, maybe)
08:02:35 <dmwit> hiptobecubic: very sure
08:02:42 * Clint salutes hiptobecubic
08:02:42 <dmwit> aristid: Now that question is a subtle one.
08:03:02 <aristid> dmwit: do you know the answer? :)
08:03:04 <beaky> ?
08:03:10 <arthurmaciel> see you and thanks you all!
08:03:12 <hiptobecubic> beaky, hello.
08:03:17 <beaky> hekki
08:03:20 <beaky> helli*
08:03:24 <beaky> hello
08:03:34 <dmwit> aristid: Well, the answer is that "yes", the number of OS threads requested by a program can change if you switch from forkIO to forkOS.
08:03:35 * beaky cannot type
08:03:38 <quchen> frerich: I guess it's a granularity issue. If your forkOS thread is huge it's fine to use. But if you fork 1000 of them and all get assigned to the same OS thread initially it's bad.
08:03:45 <hiptobecubic> beaky, for a moment i thought you were going to turn out to be Finnish.
08:03:46 <dmwit> But it's not because the forkOS'd thread is getting run on a fresh OS thread.
08:04:00 <dmwit> It's because other threads are running FFI calls on fresh OS threads where they might not have had to before.
08:04:31 <aristid> dmwit: huh, that answer is a little confusing
08:04:37 <dmwit> yes =)
08:04:44 <quchen> ^^ seconded
08:04:50 <dmwit> There's a third object we haven't mentioned yet called "capabilities", which are a Haskell execution context.
08:04:55 <dmwit> They have thread pools.
08:05:09 <quchen> Capability = -N parameter, I assume.
08:05:14 <dmwit> yes
08:05:18 <quchen> i.e. the number of OS threads the runtime launches at start
08:05:26 <dmwit> hm
08:05:32 <quchen> (modulo setNumCapabilities)
08:05:46 <dmwit> I think the runtime just launches one thread at the start, and capabilities start new threads as they need to.
08:05:49 <aristid> capabilities + ffi threads = number of OS threads?
08:05:58 <dmwit> That is, as they discover that their empty thread pool isn't enough to run some Haskell. =)
08:06:16 <frerich> aristid, quchen: My one-stop-shop for all Haskell threading questions: http://blog.melding-monads.com/2011/10/24/concurrency-and-foreign-functions-in-the-glasgow-haskell-compiler/
08:06:21 <dmwit> But that particular detail could be just wrong; I wouldn't find myself horribly surprised if every capability started with a thread pool with one thread, either.
08:06:25 <aristid> dmwit: but each thread pool only contains green threads?
08:06:38 <dmwit> aristid: No, the thread pools are pools of OS threads.
08:07:00 <aristid> dmwit: what... why?
08:07:01 <dmwit> These pools are used to launch safe FFI calls and to run Haskell execution contexts.
08:07:31 <aristid> so the number of OS threads, even excluding FFI threads, can way outnumber the number of capabilities?
08:07:33 <dmwit> (FFI calls can't be interrupted by the runtime, so to really be concurrent they have to be run in their own OS thread.)
08:07:44 <dmwit> aristid: Yes, if the pool was made large sometime in the past.
08:07:48 <quicksilver> aristid: capabilities + RTS threads + FFI threads + forkOS-forced threads.
08:08:05 <dmwit> I don't know for sure whether the thread pools are ever decreased.
08:08:14 <beaky> how od I write a neural network in haskell
08:08:23 <Kinnison> carefully
08:08:28 <aristid> beaky: use a monoid!
08:08:39 <beaky> actually, neural nets are probably monoids
08:08:49 <dmwit> (In fact, forkOS is just an FFI call that immediately calls back into Haskell. =)
08:09:05 <beaky> so haskell is probably a good choice for this simple ML task (make a neural net to parse my handwriting
08:09:45 <dmwit> "X is a monoid" doesn't seem to imply (at least to me) that "X should be implemented in Haskell".
08:09:49 <frerich> Well parsing *my* handwriting would rather require something about as complex as Skynet.
08:10:09 <earthy> doubt it
08:10:28 <earthy> parsing general handwriting is considered a solved problem in limited domains
08:10:34 <earthy> (e.g. postal codes)
08:10:45 <aristid> frerich: what if they train it on doctors first? surely that will cover the range of undecipherable writing
08:10:46 <beaky> even if neural nets aren't monoids/monads, maybe haskell is still nice for writing enural networks
08:10:47 <quchen> frerich: Thanks for the article, sums up the discussion nicely
08:11:01 <frerich> aristid: haha :-)
08:11:22 <frerich> quchen: Yeah, I think so, too.
08:11:33 <quchen> frerich: There's an update for Skynet: Parsec! :D
08:12:17 * frerich surprised the chat about the difficulty of parsing handwriting didn't spawn any Oleg references yet.
08:12:26 <beaky> oleg?
08:12:36 <hiptobecubic> Oleg.
08:12:45 <aristid> frerich: all i've ever read from oleg was computerised.
08:12:46 <frerich> beaky: I think you would like him. To him, many things seem to be so easy!
08:12:56 <quchen> Who is this Oleg? I got a link on my 'build' file to one of his papers too.
08:12:57 <aristid> @quote oleg
08:12:57 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
08:13:08 <aristid> @quote oleg
08:13:09 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
08:13:14 <beaky> ah
08:13:16 <aristid> bad lambdabot
08:13:18 <aristid> @quote oleg
08:13:18 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
08:13:59 <beaky> @quote beaky
08:13:59 <lambdabot> No quotes match. Just what do you think you're doing Dave?
08:14:37 <quchen> 17:14 <quchen> @quote quchen
08:14:37 <quchen> 17:14 <lambdabot> No quotes match. Just what do you think you're doing Dave?
08:14:45 <quchen> I was like "WTF how do you know my name"
08:14:49 <emc2> @quote perliss
08:14:50 <lambdabot> No quotes match. I've seen penguins that can type better than that.
08:14:50 <hiptobecubic> :D
08:14:53 <quchen> Lambdabot can be really scary haha
08:15:08 <hiptobecubic> He called me broccoli brains :(
08:15:20 <emc2> @quote shivers
08:15:21 <lambdabot> No quotes match. :(
08:15:22 <`ramses> I wonder whether lambdabot stole that penguin insult from sudo or whether it was the other way around
08:15:30 <quchen> Penguin insult?
08:15:32 <dmwit> \bot stole from sudo
08:15:39 <aristid> quchen: the dave quote may be from 2001, but i'm not sure
08:15:48 <quchen> Ah, I see.
08:15:59 <quchen> (Wait, you keep memories from IRC from 2001?!)
08:16:01 <aristid> dave is a rather common name.
08:16:04 <frerich> quchen: The movie.
08:16:05 <`ramses> quchen: "I've seen penguins that can type better than that." Sudo has that quote in its insult file as well
08:16:08 <aristid> quchen: i mean the movie, of course.
08:16:15 <quchen> Sudo is a movie?
08:16:21 <quchen> Maaan I'm so young.
08:16:22 <frerich> 2001, the movie.
08:16:23 <dmwit> More precisely, I'm pretty sure both sudo and \bot stole from fortune.
08:16:26 <quchen> Oh.
08:16:38 <`ramses> dmwit: that could very well be true :)
08:17:01 <`ramses> although every now and then sudo comes up with new quotes as well
08:17:22 <aristid> @quote beaky
08:17:22 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
08:17:52 <frerich> Maybe there should be special handling of that in lambdabot, so that it says "I love quoting beaky, it's so easy!"
08:18:04 <beaky> ah
08:18:19 <`ramses> frerich: shouldn't be hard to patch that
08:18:30 <aristid> frerich: great idea.
08:19:06 <quchen> HAHA alright, I didn't know about the insults in sudoers, thanks guys :D
08:19:08 <aristid> frerich: what if somebody actually adds a quote for beaky though?
08:19:14 <dmwit> ?quote
08:19:15 <lambdabot> desrt says: man... there's this whole dark side to haskell that dr. kahl didn't teach us in 3e03
08:19:35 <`ramses> quchen: makes life so much better ;)
08:20:08 <frerich> aristid: Another quote for beaky? I don't understand...
08:20:12 <`ramses> ghci should have insults for type errors :)
08:21:02 <quchen> `ramses: It has. "No instance" basically means "haha I won't tell you what's wrong sucker".
08:21:45 <dmwit> Vilhelm suggests that we should then have a relation telling how embarassing the error is and how insulting the insult is.
08:21:49 <`ramses> quchen: okay, then the insult generator should try harder to make me laugh every now and then
08:22:38 <frerich> I think vigor can do that. Makes me wonder whether Peaker's "bottle" (what's the new name again?) has that.
08:23:10 <dmwit> -fprobability-of-insult=0.001
08:23:56 <kevinx> hello. I am looking at Data.List.Split, and I don't see a way to split a string by isSpace into at most N words. how would one do that?
08:24:17 <frerich> kevinx: What should happen if there are more than N spaces?
08:24:26 <beaky>  
08:26:54 <kevinx> frerich the last element should be the remaining of the string, with spaces included. wordsMax 2 "1 2 3 4 5" => ["1", "2", "3 4 5"]
08:27:25 <dmwit> I suppose the way to do this is to split up all the words, take the number you want, and join the rest back together.
08:27:33 <armlesshobo> ^
08:28:02 <frerich> Another approach might be to take the part of the string which has 'n' spaces, then split that, and then add the remainder of the strng as the final element.
08:28:07 <dmwit> You may have to be a bit careful if you want to get the exact same whitespace out as came in, but it should at least be possible.
08:28:28 <kevinx> yes I would prefer to keep the whitespace as it was
08:28:43 * dmwit nods agreeably
08:28:54 * armlesshobo nods profusely
08:29:04 * dmwit waggles his head dangerously
08:29:17 <cariveri> how di I find example for a given package on hackage in use?
08:29:25 * armlesshobo stops nodding and grips his neck in pain
08:29:39 <dmwit> cariveri: It's not possible in general.
08:29:47 <armlesshobo> cariveri: if they have a website you might find one there.
08:29:58 <dmwit> However, the Hackage page will sometimes have links to additional resources; github accounts; wikis; that sort of thing.
08:30:03 <cariveri> ok. it would be a very nice feature to hackage
08:30:22 <dmwit> There's also a reverse-dependencies tool elsewhere that could find something useful if the package is a library.
08:30:23 <hiptobecubic> Maybe the reverse dependency list?
08:30:52 <dmwit> I don't think it's really a feature that can reasonably be added to Hackage... it's just up to the package maintainer whether they include examples or not, right?
08:31:04 <frerich> Hm... is there something like takeWhile, except that the predicate doesn't consider a single element but rather the list which has been taken already?
08:31:04 <cariveri> let say Id like to see an example for "The IndentParser package"
08:31:23 <dmwit> frerich: takeWhile . inits?
08:31:35 <inaimathi> Hi.
08:32:00 <inaimathi> Is anyone here both familiar with the Criterion benchmarking library and willing to answer stupid questions?
08:32:26 <hiptobecubic> inaimathi, just ask
08:32:38 <frerich> dmwit: Hmm, not quite what I meant, but thanks for mentioning 'inits' (you sure are good with those odd functions I never found a use case for!)
08:32:41 <dmwit> cariveri: There are some examples in the documentation. Not much, but if you haven't looked yet, definitely do.
08:32:55 <dmwit> frerich: Heh. What did you mean?
08:33:56 <frerich> dmwit: I wanted a function which takes characters from a string until the complete input string is consumed, or until the string it took contains at least 5 spaces
08:34:25 <dmwit> I see. And your complaint about takeWhile/inits is that it's way too inefficient, I guess?
08:34:30 <dmwit> :t scanl
08:34:32 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
08:34:50 <inaimathi> Ok; I'm trying to use Criterion to bench some side-effect causing functions, but the side effects (database writes) don't seem to be happening. Am I doing something wrong, or is this intended behavior?
08:35:15 <dmwit> > scanl (\(c,n) c' -> (c',if c' == ' ' then n+1 else n)) ('\0',0) "hello world"
08:35:17 <lambdabot>   [('\NUL',0),('h',0),('e',0),('l',0),('l',0),('o',0),(' ',1),('w',1),('o',1)...
08:36:03 <dmwit> inaimathi: You're doing something wrong.
08:36:25 * frerich swears that if you compare any two programs of dmwit and me, you will find that the sets of used functions are perfectly disjoint
08:36:34 <dmwit> hehehe
08:36:47 <frerich> scanl is another one of those "I know they exist, but never thought of using them" functions.
08:37:28 <dmwit> I'm not sure I've ever used it outside of this channel. =P
08:38:27 <donri> is there any way to document TH-generated code with haddock?
08:38:31 <inaimathi> dmwit: Any idea what that might be? I've tried to call these functions directly and they do what I want them to outside of a bench call.
08:38:33 <Botje> I used it several times for project euler
08:38:48 <byorgey> donri: unfortunately not =(
08:38:52 <Botje> anything with running sums, basically.
08:38:54 <donri> :(
08:39:05 <dmwit> inaimathi: Show us some code. The smaller (but still broken) the better.
08:40:01 <dmwit> (Perhaps in the process of making it small you will discover what went wrong. It's happened to me many times. ;-)
08:40:47 * hackagebot fixed-vector 0.3.0.0 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.3.0.0 (AlexeyKhudyakov)
08:41:07 <dmwit> I wonder how many packages there are on Hackage for that.
08:43:01 <Hafydd> Whose idea was it to name arrays "vectors"? Surely someone without any understanding of the mathematical or physical meaning of "vector".
08:44:13 <byorgey> Whose idea was it to name vectors "vectors"? Surely someone without any understanding of the biological meaning of "vector".
08:44:20 <johnw> haha
08:44:31 <frerich> Doesn't the "vector" match the mathematical definition?
08:44:49 <frerich> Google says: "Mathematical definition of a vector is a member of the set Sn, which is an ordered sequence of values in a specific set (S)."
08:44:50 <johnw> an array is just one way to represent a vector whose basis is the index, right?
08:45:09 <Iceland_jack> I would wager a fair sum of money that whoever came up with using vectors for 1d arrays was well aware of other meanings...
08:45:37 * mgsloan bets they had some C++ background though :)
08:45:57 <Hafydd> An array of scalars can represent a finite-dimensional vector, yes, but not everything in a "vector", in the array-like sense, satisfies the requirements of a scalar.
08:46:22 <johnw> ah, that's a really good point
08:46:23 <tac> byorgey: not to mention those crazy biologists, calling the transportation method of a disease a "vector"
08:46:28 <tac> crazy, crazy nomenclature :P
08:46:34 <mgsloan> The C++ etymology particularly makes sense for Data.Vector.Unboxed
08:46:41 <johnw> you're saying (Vector Text) isn't really a vector in any mathematical sense
08:47:19 <Iceland_jack> Do you suppose the person that started talking about “strings” of characters realized that a string is actually something made of threads? what a moron
08:47:23 <Hafydd> frerich: where is that from?
08:47:59 <Hafydd> Yes.
08:48:05 <frerich> Hafydd: That particular quote? From StackOverflow (which Google suggested): http://stackoverflow.com/questions/581426/why-is-a-c-vector-called-a-vector
08:48:29 <frerich> Iceland_jack: It should have been a 'rope', really.
08:48:49 <Iceland_jack> frerich: really ;)
08:48:55 <frerich> :-)
08:49:00 <Hafydd> I think that's a misunderstood definition.
08:49:15 <Hafydd> At a glance it might appear so, yes.
08:49:33 <Iceland_jack> And *speaking* of threads of something—, no let's not even go there
08:49:50 <lxnch> why, after calling the horner function, everything gets so wrongly formatted.. http://pastebin.com/vMziHQtR how can I avoid this. the leftside of the string should be as in the *_pretty function return, I don't understand why it gets messed up
08:49:56 <mauke> The paste vMziHQtR has been copied to http://hpaste.org/83590
08:50:45 <inaimathi> dmwit: http://pastebin.com/3DSEXVM1 I had to chop it a bit to get to a minimal example. That still fails; I create the relevant DB table and run main, which I'm expecting to insert 100 records into that table as a side-effect. It gives me timing data, but getAccounts still returns [], which tells me this isn't exactly being accurate about what's going on.
08:50:48 <mauke> The paste 3DSEXVM1 has been copied to http://hpaste.org/83591
08:50:54 <inaimathi> dmwit: Um. Pardon the shitty Haskell highlighting.
08:51:32 <elliott> mauke saves the day
08:52:10 <Hafydd> Pairs of real numbers from R^2 can be considered as vectors, not because they are ordered sequences, because you can add and substract them, multiply them by real numbers, and there is a zero vector.
08:52:20 <Iceland_jack> > iterate (+ 1) 0
08:52:22 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
08:52:23 <Iceland_jack> > [0..]
08:52:25 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
08:52:38 <`ramses> Hafydd: many non-scalars can also form a vector when grouped in an array, can't they? As long as they form a field
08:52:57 <Hafydd> `ramses: if something comes from a field, I wouldn't call it a "non-scalar".
08:53:12 <linduxed> can someone tell me why i'm getting the warning  "Defaulting the following constraint(s) to type `Integer'" on this line? problem15 = sum $ map digitToInt $ show $ 2^1000
08:53:15 <johnw> you can say that the scalar is "1" in that case for each non-scalar, and then it's a vector space
08:53:26 <linduxed> it's putting the warning right on top of the ^
08:53:29 <`ramses> Hafydd: you wouldn't? ok, my algebra might be a little rusty :)
08:53:58 <geekosaur> @where DMR
08:53:58 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
08:54:04 <Hafydd> `ramses: but the term "scalar" is only precise in the context of a particular vector space, as far as I know.
08:54:10 <geekosaur> linduxed ^^ didn't I link you tot his before?
08:54:23 <byorgey> geekosaur: that warning is NOT because of the MR
08:54:23 <`ramses> Hafydd: vectors over the real numbers can themselves form a field, don't they? like the complex numbers for instance
08:54:30 <linduxed> geekosaur: yes you did, but i'm still not good at recognizing when it's about that and when it's not
08:54:34 <geekosaur> you have a top level binding with no parameters, which really wants to be polymorphic, but byd efault it's forced monomorphic and uses Integer
08:54:43 <byorgey> linduxed: 2^1000 is polymorphic, and 'show' is also polymorphic in its input
08:54:58 <linduxed> i d o have "problem15::Int" right above it
08:54:59 <byorgey> linduxed: so there's no way for GHC to decide what type you want 2^1000 to be.  Integer? Int? Double?  who knows?
08:55:04 <linduxed> i just didn't want to paste two lines
08:55:05 <geekosaur> solution, turn off the monomorphism restriction or give your names parameters
08:55:08 <lxnch> Hafydd: thanks, truncating the (**) did it!!
08:55:10 <dmwit> inaimathi: newAccount takes two arguments, but you've given it only one.
08:55:15 <Hafydd> `ramses: not in general. You have to be able to divide by a member of a field, and while this is possible for complex numbers, that's a bit special.
08:55:19 <byorgey> linduxed: so it has a system for resolving certain cases like these by picking a default type
08:55:26 <linduxed> byorgey: ok thx
08:55:57 <geekosaur> it's not a problem (unless you really wanted it to be polymorphic, which in this case you don't)
08:56:17 <dmwit> inaimathi: Also, at a guess (haven't used criterion in a while), you want to use one of the IO-evaluating benchmarks, not whnf.
08:56:24 <geekosaur> but it does warn you what it's doing to try to minimize the surprise if you *did* expect it to be polymorphic
08:56:36 <supki> lxnch: Add type signatures. The problem would be apparent (I think)
08:56:41 <`ramses> Hafydd: they have to have multiplicative inverses, you mean. Okay, I don't know when that's possible for vectors :)
08:57:19 <dmwit> inaimathi: (e.g. whnfIO or nfIO)
08:57:35 <Hafydd> `ramses: there is no notion of multiplication for general vectors, indeed.
08:57:38 <`ramses> You'd need a degenerate norm, at the least
08:57:46 <dmwit> (...or id ;-)
08:58:02 <`ramses> Hafydd: right, also that
08:58:51 <Hafydd> Now, this is a correct usage of the term: http://hackage.haskell.org/package/vector-space
08:59:12 <dmwit> I think you can safely say that about any Conal package.
08:59:26 <Hafydd> > (1,2,3) *^ 2
08:59:28 <lambdabot>   Ambiguous occurrence `*^'
08:59:28 <lambdabot>  It could refer to either `Numeric.AD.Internal.Cl...
08:59:30 <simpson> 1
08:59:39 <dmwit> He's one of the uncompromisingest Haskell hackers.
08:59:41 <Hafydd> Oops, I mean..
09:00:02 <Hafydd> > 2 Data.VectorSpace.*^ (1,2,3)
09:00:04 <lambdabot>   No instance for (GHC.Num.Num (Data.VectorSpace.Scalar t2))
09:00:04 <lambdabot>    arising from ...
09:01:00 <mroman_> is there a many $ notString "foobar" parsec thingy?
09:01:06 <Hafydd> > 2 Data.VectorSpace.*^ (1,2,3) :: (Float, Float)
09:01:08 <lambdabot>   Couldn't match expected type `(GHC.Types.Float, GHC.Types.Float)'
09:01:08 <lambdabot>          ...
09:01:26 <inaimathi> dmwit: That's a facepalm right there. Yup, whnfIO does what I was expecting. Thanks
09:01:31 <arkeet> > 2 Data.VectorSpace.*^ (1,2,3) :: (Float, Float, Float)
09:01:33 <lambdabot>   (2.0,4.0,6.0)
09:01:39 * Hafydd gasps.
09:02:22 <Hafydd> > zeroV :: (Float, Float, Float)
09:02:24 <lambdabot>   (0.0,0.0,0.0)
09:03:29 <`^_^v> is there a utility function that works like dropWhile also returns the number of elements dropped
09:04:30 <dmwit> `^_^v: I don't think so. You'll have to code one up using break or span.
09:09:58 <linduxed> project euler is a pretty nice past time
09:10:03 <linduxed> i like it
09:10:14 <linduxed> haven't come that far really, but it's still fun
09:11:25 <otters> is there a hackage package for strong functors
09:12:36 <dmwit> category-extras doesn't list a new place to look for Control.Functor.Strong, so if you find one let me know
09:13:14 <edwardk> fmap .(,) and sequence ;)
09:13:33 <edwardk> :t fmap.(,)
09:13:34 <lambdabot> Functor f => a1 -> f a -> f (a1, a)
09:13:44 <edwardk> yay strong functors
09:13:56 <danharaj> anyone have a preferred unbounded queue package?
09:14:00 <danharaj> There's a couple of them :|
09:14:03 <otters> rats
09:14:13 <dmwit> Right, all Functors are strong... but surely it's possible to give a functor typeclass weaker than Functor where not all instances are strong?
09:14:22 <otters> I was just using uncurry (fmap . (,)) but I wondered if there was a package I could needlessly import
09:14:26 <otters> :t uncurry (fmap . (,))
09:14:28 <lambdabot> Functor f => (a, f a1) -> f (a, a1)
09:14:33 <edwardk> otters: not currently
09:14:41 <otters> oh well
09:14:46 <edwardk> dmwit: in haskell? not sure
09:14:58 <dmwit> huh, ok
09:15:09 <edwardk> we get strength from the environment machinery
09:15:36 <ciaranm> strength through unity!
09:21:44 <clahey> ciaranm: unity through faith?
09:22:12 <clahey> And above all...
09:22:49 <dmwit> reminds me of the joke about the group theorists who prayed to 0, prompting a newcomer to ask "Is nothing sacred?"...
09:23:21 <osfameron> heh
09:25:27 <clahey> dmwit: What is a weak functor?
09:26:08 <dmwit> clahey: one that doesn't have an operation (a, f b) -> f (a, b)
09:27:27 <clahey> dmwit: You're talking about this in a category theory context, right?
09:28:07 <clahey> Or in some specific haskell context?
09:28:14 <clahey> Or is there some web page I should read to explain it?
09:28:16 <dmwit> CT, yes
09:28:23 <dmwit> You might like the nlab page on it?
09:28:32 <dmwit> I was just starting to read it to make sure I answered correctly. =)
09:28:38 <dmwit> http://nlab.mathforge.org/nlab/show/tensorial+strength
09:29:57 <elliott> edwardk: dmwit: can't you do it if you go to something weaker than (->)?
09:30:08 <elliott> so you can't close over stuff etc.
09:31:19 <dmwit> That's sort of what I was asking, yeah.
09:40:30 <danharaj> Is there a way to force GHC to relink if I changed my build options but not any source files?
09:41:56 <geekosaur> -fforce-recomp ?
09:42:42 <danharaj> geekosaur: preferably without recompiling every source file :|
09:42:56 <danharaj> Right now I just make a trivial change to a source file to trick GHC but that's a little silly.
09:44:51 <geekosaur> if you change your build options, do you really want that to apply only to one source file? if so you probably want {-# GHC_OPTIONS #-} in the source file in question
09:44:56 <geekosaur> if you really have per-source-file build options, that is
09:45:15 <danharaj> Well no, sometimes I want to change things like which RTS to link against or somesuch.
09:45:30 <danharaj> And GHC will not relink if such options are changed unless it sees work to do.
09:45:44 <beaky> how do I write a RPN calculator in haskell?
09:46:15 <danharaj> beaky: Start with a data type declaration to represent your expressions.
09:46:45 <c_wraith> wasn't there a @quote about this?
09:46:50 <beaky> alright. data Expression a = Op | Num a
09:46:54 <danharaj> @quote RPN
09:46:54 <lambdabot> No quotes match. You untyped fool!
09:47:39 <danharaj> beaky: That's not a very interesting declaration. It's just a weird way of defining Maybe.
09:47:55 <beaky> danharaj: right :(
09:48:20 <Philippa> but then, the whole point of RPN is to let it be a list
09:48:39 <beaky> a list of either numbers or operations?
09:48:43 <Philippa> danharaj: mostly because it doesn't name any of the ops, though
09:48:45 <beaky> operations on those numbers`*
09:48:49 <Philippa> beaky: sounds like RPN to me, yeah
09:48:51 <dmwit> danharaj: That sort of sounds like a bug to me.
09:48:58 <dmwit> danharaj: What version of GHC/what are you changing?
09:50:00 <beaky> so my purely-functional rpn calculator will be a REPL
09:50:07 <beaky> and the user enter stuff
09:50:10 <beaky> enters*
09:50:23 <c_wraith> are you going to maintain the stack between lines of user input?
09:50:53 <c_wraith> If so, you're basically copying the HP calculators that use RPN
09:51:02 <beaky> yeah
09:51:34 <beaky> everytime the user hits enter the top of the stack will be echoed
09:51:51 <c_wraith> If you're doing that, I don't know that you need a datatype to represent input.
09:52:00 <c_wraith> You just need one for the stack
09:52:02 <beaky> but then waht do I do if the user tries to break it by spamming operations?
09:52:05 <beaky> ah
09:58:41 <alshain> I used to be an applicative, but then I took a >>= to the knee.
09:58:54 <beaky> I love lists
09:59:03 <Saizan> danharaj: you try with shake
09:59:12 <beaky> before I learned haskell, I didn't know linked lists were so much more versatile than arrays
09:59:52 <kevinx> is it possible to redirect a file to stdin using :main command?
10:01:47 <Saizan> danharaj: +could
10:02:12 <stoned> hi
10:02:56 <stoned> Can Haskell be used for everyday general purpose programming etc. or is it only limited to mostly math related stuff
10:03:07 <c_wraith> I mostly use haskell for web apps
10:03:13 <c_wraith> That should answer your question
10:03:16 <danharaj> Saizan: hm?
10:03:17 <stoned> interesting
10:03:22 <dmwit> ?faq Can Haskell be used for everyday general purpose programming?
10:03:23 <lambdabot> The answer is: Yes! Haskell can do that.
10:03:40 <kevinx> stoned it's a general purpose language
10:04:06 <stoned> Could I see examples of some web app in haskell?
10:04:19 <beaky> yes
10:04:25 <Saizan> danharaj: shake is an haskell make replacement which is supposed to be better at tracking deps like that
10:04:25 <beaky> od
10:04:34 <danharaj> Saizan: oh that's cool.
10:04:40 <beaky> http://www.yesodweb.com
10:06:16 <stoned> I graduated ... 13 years ago
10:06:19 <stoned> 12
10:06:28 <stoned> And I was never particularly good at remembering things
10:06:28 <stoned> :)
10:06:41 <sproingie> stoned: with a nick like that, i'm not surprised :)
10:06:45 <stoned> haha
10:07:10 <stoned> I'm trying to make sense of this language and the functional paradigm
10:07:21 <kevinx> @where LYAH
10:07:21 <lambdabot> http://www.learnyouahaskell.com/
10:07:34 <stoned> that's what I'm reading actually
10:07:41 <kevinx> that's a good start
10:08:05 <stoned> The only thing is, I'm not particularly patient either.
10:12:40 <mgsloan> stoned: While not yet a complete set of tutorials (public as of a couple of days ago), http://www.fpcomplete.com has tutorials that allow you to try editing the examples
10:13:00 <stoned> I'
10:13:12 <stoned> I've been watching the online haskelle open courseware stuff
10:13:35 <stoned> there was some courses by some scottish perofessor from univ. of eninburgh I think
10:15:44 <stoned> dude
10:15:49 <yacks> stoned: pls could you give me link of either OCW or UniOfEninburg lectures?
10:15:51 * hackagebot fixed-vector 0.3.0.1 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.3.0.1 (AlexeyKhudyakov)
10:16:12 <stoned> is it just me or or is this fpcomplete respose time is superb
10:16:21 <stoned> every click and pages load almost instantly
10:16:34 <stoned> I'm guessing this site was done in haskell?
10:16:39 <byorgey> ye
10:16:40 <byorgey> yep
10:16:47 <byorgey> @yesod
10:16:47 <lambdabot> Unknown command, try @list
10:16:50 <stoned> good googa mooga
10:16:56 <byorgey> bleh, I should take a nap
10:17:00 <byorgey> @where yesod
10:17:01 <lambdabot> #yesod - http://yesodweb.com/
10:17:02 <stoned> then take a nap
10:17:05 <byorgey> stoned: ^^^ using this
10:17:11 <stoned> There are others to help me. Rest up mate
10:17:15 <byorgey> =)
10:17:22 <stoned> :)
10:17:49 <stoned> yacks, uno momento
10:19:11 <byorgey> yaks!  those can be dangerous
10:19:15 <stoned> https://www.youtube.com/watch?v=JeK979aqqqc <- Saw that, it was pretty good
10:19:22 <stoned> FP w/ Neal Ford
10:19:39 <stoned> https://www.youtube.com/watch?v=0nOnv9WvafQ <- also this, generic programming in haskell
10:20:02 <stoned> and video #3 of the course I talked about https://www.youtube.com/watch?v=gx28Umd7ELA
10:20:28 <yacks> byorgey, do u mean it's not useful to go thru it?
10:20:28 <stoned> first two are just the first day of class videos, not much there other than him going over policies and expectations and all that.
10:21:22 <stoned> And starts usually here from https://www.youtube.com/watch?v=FEIqjx-kOEM <- video #4 lists and so forth
10:21:43 <byorgey> yacks: no, sorry, just making a pun on your nick =)
10:22:35 <yacks> byorgy, never mind
10:22:45 <danharaj> @quote pun
10:22:45 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
10:22:57 <byorgey> hahaha =)
10:23:35 <yacks> thanks stoned for links...
10:23:38 <stoned> np
10:24:29 <stoned> that's actually what I do. Counterpoint classial indian raaga layered over rhythm and lead (counterpoint to both rhythm and melody depending on what works)
10:24:40 <stoned> Mostly in the style of metal using electric guitar.
10:24:45 <stoned> 7-8 strings :)
10:29:23 <mgsloan> stoned: Not only is the site written in Haskell, but most of the clientside code as well
10:30:01 <mgsloan> (technically not Haskell: https://github.com/faylang/fay/wiki )
10:30:36 <danharaj> fay is a strict subset so it's Haskell
10:30:46 <beaky> how do I realize the classical oop example of animal inheritance in haskell?
10:31:00 <stoned> yeah
10:31:01 <mgsloan> True, but it's not Haskell 98, which is somewhat of a reasonable baseline
10:31:06 <stoned> actually that might be helpful to me too
10:31:16 <stoned> programmers coming from the oop heavy paradigm to fp
10:31:23 <sellout-> beaky: maybe look at typeclasses.
10:31:29 <stoned> is there anything targeted towards them?
10:31:46 <stoned> b/c most of the haskell stuff is extreme beginner stuff and I get bored and lose interest.
10:31:52 <stoned> maybe I'm different, but that's me.
10:32:07 <elliott> stoned: well, it's sufficiently different enough that starting from step 1 is the most viable way to learn things
10:32:16 <stoned> I'm sure there are some educators also among us, as well as some psychology majors and perhaps they can shed light
10:32:17 <elliott> have you tried both LYAH and RWH?
10:32:22 <stoned> elliott, I see
10:32:40 <stoned> elliott, is some cases step 1 is the best way to go
10:32:42 <byorgey> mgsloan: is it Haskell 2010?
10:33:08 <elliott> fay doesn't even have proper types afaik
10:33:10 <elliott> as in, no typeclasses
10:33:20 <stoned> elliott, oh sorry that was a question to me/
10:33:25 <byorgey> stoned, beaky: http://www.haskell.org/haskellwiki/OOP_vs_type_classes
10:33:26 <stoned> elliott, no I have not even heard of them.
10:33:34 <danharaj> GHC isn't even Haskell 2010 so I'm not sure how much it matters.
10:33:42 <danharaj> (It's vaguely problematic)
10:33:43 <stoned> today I am just starting w/ it. I've been reading and watching videos about haskell for a few days.
10:33:51 <byorgey> danharaj: well, at least it's close.
10:34:04 <byorgey> I was just trying to figure out more precisely what mgsloan meant by saying that Fay is not H98.
10:34:12 <sellout-> byorgey: Ah, that looks like a good article :)
10:34:16 <c_wraith> byorgey: it doesn't have type classes
10:34:25 <c_wraith> byorgey: those are part of haskell98
10:34:29 <beaky> ah thanks
10:34:47 <elliott> stoned: well
10:34:49 <elliott> @where lyah
10:34:50 <lambdabot> http://www.learnyouahaskell.com/
10:34:50 <elliott> @where rwh
10:34:51 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:34:51 <byorgey> sure, I know typeclasses are in H98.  I guess it depends what you mean by saying something "is" or "isn't" H98.
10:34:53 <mgsloan> byorgey: The typeclasses thing was what I meant by that.  It does support some sugar-ey language extensions, though, like RecordWildcards
10:34:59 <elliott> stoned: are generally the recommended tutorials to learn haskell from
10:35:07 <hseg> How do I do a local import? i.e. I have two files, a.hs and b.hs in the same directory. a.hs needs stuff from b.hs What do I write in b.hs to make this happen?
10:35:09 <byorgey> if I say "this program is H98" I don't mean it contains type classes.  I mean it uses features which are only found in H98.
10:35:16 <byorgey> but maybe not all of them.
10:35:18 <elliott> RWH jumps in to a bit more practical stuff but (IMO) isn't very good as an introductory tutorial compared to LYAH (i.e. best to read LYAH first)
10:35:19 <mgsloan> byorgey: right, since we are already discussing subsets, I should have made that clear
10:35:31 <c_wraith> byorgey: If you say "this compiler is H98", you expect it to implement all of H98, not a subset
10:35:33 <byorgey> ok.
10:35:49 <mgsloan> Hmm, Fay needs to document supported extensions somewhere
10:35:50 <c_wraith> byorgey: it's the difference between describing code and a compiler
10:35:57 <byorgey> c_wraith: sure.  but the statement in question was about a language, not a compiler!
10:36:03 <byorgey> so I wasn't sure which was the right interpretation =)
10:36:04 <mgsloan> It also doesn't support pattern bindings, which has been annoying me
10:36:25 <mgsloan> I've got a WIP changeset to add support for them (it is largely a desugaring afterall)
10:36:35 <stoned> tyvm
10:36:37 <tvynr> hseg: I'm not quite sure what you mean by "local" import.  But your filenames should start with upper-case letters; case is relevant in Haskell.  Then it's just "import B" in A.hs.
10:36:40 <mgsloan> but as said WIP - there are more pressing matters
10:36:43 <hseg> Also, how do I make GHC do a dry run of my code.
10:36:56 <byorgey> mgsloan: is there a fundamental reason Fay can't support type classes?  Or is it just "no one's done the work to add them" sort of thing?
10:37:34 <byorgey> hseg: what do you mean, a dry run?  You mean just compile it without running it?  That's what ghc does by default.
10:37:39 <mgsloan> Yeah, more just the latter.  It actually does support typeclass declaration syntax, it just doesn't support typeclass methods :)
10:37:48 <byorgey> ghc MyCode.hs   -- compiles, but does not run, MyCode.hs
10:37:54 <c_wraith> byorgey: the reason it doesn't have type classes at the moment is because it doesn't have type inference. (It asks GHC to check types, then generates code without caring about types)
10:37:55 <Xaratas> hm
10:38:10 <mgsloan> byorgey: So, you can still typecheck polymorphic stuff, but the constraints don't provide dictionaries
10:38:12 <Saizan> how is Fay typechecked? it has its own implementation?
10:38:21 <byorgey> ah, I see
10:38:28 <c_wraith> Saizan: it asks GHC to run a type checking pass
10:38:29 <mgsloan> Saizan: Nope, you run GHC on your code
10:38:33 <hseg> Dry-run, as in, typecheck and sanity check the code, but don't actually start compiling.
10:38:34 <Xaratas> split a list of 9 elements in groups of 3? recursive use of take and drop? or are there better ways?
10:38:46 <mgsloan> c_wraith: Even better, I don't think fay has code to run GHC.  You just do it yourself
10:38:49 <byorgey> hseg: ah.  hmm, just a minute
10:39:08 <mgsloan> this means, like -fdefer-type-errors, you can compile Fay code even if it has type errors
10:39:32 <mgsloan> the difference with -fdefer-type-errors is that then you end up in a javascript debugger in the middle of the runtime :)
10:39:41 <mgsloan> instead of a nice runtime type error message
10:39:52 <danharaj> That sounds like an awful place to be :P
10:40:09 <byorgey> hseg: apparently you can do   ghc -fno-code , see here: http://stackoverflow.com/questions/12373722/make-ghc-only-type-check
10:40:22 <mgsloan> it's actually surprisingly straightforward, but yeah, debugging sometimes isn't so much fun
10:40:35 <hseg> Nice.
10:40:43 <hseg> Two more things. Must the module name be the same as the file name? And what will happen when unicode support is wanted?
10:40:50 * mgsloan is still holding out for fay sourcemaps + some good way to step it
10:41:48 <Saizan> mgsloan: ah, but the conversion into JS is done straight from unannotated Fay code?
10:41:51 <c_wraith> My big question on the subject is: why does GHCJS get less press? What are its limitations? I suppose it's probably way harder to get running.
10:42:43 <geekosaur> I thought they were still sorting out the runtime?
10:43:40 <mgsloan> Saizan: Right.  And ffi is just special function definitions that call an ffi function with a string.
10:44:14 <hpaste> dmj pasted “Decs” at http://hpaste.org/83595
10:44:43 <mgsloan> c_wraith: The main factors are the size of the generated code, debuggability, and ease of ffi
10:45:21 <Saizan> i wonder if GHC has a way to output just the result of desugaring + dictionary translation, without any other optimizations done
10:45:34 <kaleidic> I've been reading Wes Dyer's post from 2008 entitled "The Marvels of Monads" http://blogs.msdn.com/b/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx
10:45:35 <mgsloan> GHCJS reuses GHC ffi, which seems to be a rather bad match for javascript.  The generated code is quite a bit different from what you put in, so it's hard to tell what's going on when you're in a javascript debugger
10:46:04 <DMcGill> is there a generalisation of `map' to arrows?
10:46:12 <tvynr> hseg: I don't believe that the module names and file names must match, but it's usually recommended.  Haskell does have Unicode syntax support.
10:46:14 <mgsloan> Saizan: That would be pretty awesome.  I've definitely been thinking that Fay should reuse the desugarings from haskell-suite orso
10:46:20 <tieTYT> why does this compile: myFind :: Eq a => a -> [[a]] -> Bool ; myFind x = elem x . concat     but this doesn't:   myFind x = x `elem` . concat
10:46:26 <c_wraith> Saizan: how much other transformation is done in the core pass? I guess strictness analysis is done
10:46:30 <mgsloan> Saizan: But reusing GHC's desugarings would be even better
10:46:33 <tieTYT> parse error on input `.'
10:46:51 <hseg> Not unicode *syntax* support. Unicode *filename( support
10:47:14 <mgsloan> Saizan: Definitely an interesting idea.  It's halfway between Fay and GHCJS
10:47:19 <tvynr> hseg: As long as your filesystem supports Unicode, I don't *think* that's a problem...
10:47:58 <Saizan> c_wraith: lots of things, judging from what ghc-core spits out
10:48:19 <hseg> Possible reasons for problems: A) module names start with uppercase - see ML post re: using unicode for data constructors.
10:48:37 <hseg> B) See A
10:48:49 <geekosaur> tieTYT, you need parentheses around the section (x `elem`)
10:48:57 <tieTYT> geekosaur: why?
10:49:47 <geekosaur> "because the Report says so" I don't know what syntactic ambiguities the other way produces, but at this point I'm fairly convinced that most such things have a good reason
10:50:01 <tieTYT> hehe ok
10:50:20 <geekosaur> Haskell's syntax is rather finely tuned, things that look like they "ought to" work often turn out to have odd ramifications
10:50:35 <hseg> Also, two actual code questions. Why does ```map show ([1 ..] :: [Integer])``` work, yet ```map show $ [1 ..] :: [Integer]``` not work? For that matter, why can't I use :: within the brackets?
10:50:46 <geekosaur> and (.) in particular already has too many special cases that could interact oddly
10:51:58 <tsou> hseg: f $ x :: a is parsed as (f $ x) :: a, if i'm not mistaken..
10:52:14 <geekosaur> hseg, :: is lower precedence than any operator; the $ does not limit it
10:52:19 <hseg> I thought $ had the lowest precedence of them all?
10:52:32 <geekosaur> of all operators, yes. but :: is not an operator
10:53:08 <geekosaur> and cannot be defined as an operator, as operators work on values but :: has a type on one side
10:53:10 <beaky> the more dollar signs in haskell code, the more money it makes
10:54:13 <hpaste> hseg pasted “Non-working newtype” at http://hpaste.org/83596
10:54:16 <hseg> OK. Another thing: Why does the following code not work:
10:54:24 <hseg> s/following/preceding/
10:54:31 <geekosaur> as for [1.. :: [Integer]], I think you could argue that that's a corner case that might bear revisiting... but [..] is syntactic sugar and I would not be surprised if it expanded that to ```enumFromTo 1 (:: [Integer])``` whichis just Wrong
10:54:43 <Saizan> hseg: :: is syntax, not an operator
10:54:50 <shanse> beaky: http://i.imgur.com/74WVK.png
10:55:08 <hseg> OK, OK I get it. But why does the pasted code not work?
10:55:15 <geekosaur> hseg: a newtype requires a constructor
10:55:24 <geekosaur> maybe you meant type instead of newtype?
10:55:49 <geekosaur> the point of newtype is to "cover up" the type of something else, so you *must* provide a constructor so that values of the newtype can be distinguished
10:56:36 <hseg> Right. I meant type, in order to have a nicer alias for lists of program statements.
10:57:36 <hseg> Also, is there a way/proposal to namespace data constructors?
10:58:16 <danharaj> module boundaries
10:58:30 <geekosaur> so if you use type instead of newtype, your thing will work
11:00:27 <DanBurton> so with ghci you can set the prompt with  << :set prompt blah >>, but how do you set the prompt for paste-mode?
11:00:28 <hseg> OK.
11:07:19 <aCube> > foldl1 f [a,b,c]
11:07:21 <lambdabot>   f (f a b) c
11:07:39 <aCube> > foldr1 f [a,b,c]
11:07:41 <lambdabot>   f a (f b c)
11:09:41 <beaky> I love constructors
11:10:12 <beaky> because without them it would be clumsy using lambdas and closures
11:10:37 <DuelShark> beginner question - in haskell, if I have a list "state" with [1,1,1,1,1] and I have a function changeState which changes the nth element(say second) to 2, producing [1,2,1,1,1], is it possible to then re-call state and it'll show [1,2,1,1,1]?
11:11:01 <DuelShark> or how do we dynamically change and hold list element data and then re-call, any help appreciated
11:11:04 <hpaste> DanBurton pasted “ghci set paste prompt” at http://hpaste.org/83597
11:12:04 <shachaf> DanBurton: You cannot.
11:12:09 <byorgey> DanBurton: you probably can't, because no one thought of it.  Submit a patch!
11:12:20 <shachaf> People have thought of it, but no one has bothered to do it.
11:12:27 <byorgey> or that.
11:12:38 <shachaf> The file to look at: ghc/InteractiveUI.hs
11:12:44 <DanBurton> mmmkay patch time. Shouldn't be too hard.
11:12:54 <danharaj> DuelShark: changeState state will equal [1,2,1,1,1] by definition. What are you looking for?
11:12:59 <shachaf> Search for «rompt» and «| "»
11:13:08 <shachaf> You can see it's hard-wired
11:13:35 <Mortchek> DuelShark, you can't set the same variable twice. But you can, e.g., have a function call itself with new arguments/
11:13:38 <Mortchek> .
11:14:15 <shachaf> DanBurton: While you're messing with the ghci prompt, can you add a variety of %s that only shows the current loaded (*ed) module, rather than everything imported?
11:14:22 <DMcGill> "No instance for (Monad m)
11:14:22 <DMcGill>   arising from a proc expression", where the code is something like "proc _ -> do {...}"
11:14:29 <DMcGill> I thought proc didn't imply a monad?
11:14:41 <shachaf> My .ghci imports 117 modules at least
11:14:45 <DMcGill> i.e. you can use proc notation for things which are arrows but not monads
11:15:15 <typoclass> shachaf: (... mine imports 1 module, called Moar, which reexports eleventy things ...)
11:15:25 <DMcGill> ah never mind, the Arrow defn for Wires requires a Monad in the first place
11:15:27 <monochrom> proc doesn't imply monad, and works for me
11:15:37 <DanBurton> shachaf: lol, I'll see what I can do
11:16:15 <DMcGill> "Monad m => Category (Wire e m)"
11:16:21 <danharaj> man, I just fixed a severe bug and when I tested out the app and everything was working exactly as intended I actually said aloud "Ha! I am so awesome."
11:16:30 <danharaj> That moment when your narcissism shows.
11:18:14 <DuelShark> Mortchek sorry what I mean to say is, still trying to wrap my head around this - I'm trying to have a list I can keep changing based on user input and then another function which will print the list
11:18:40 <geekosaur> you need to copy around the new list. perhaps you want the State monad? or just pass it around
11:18:54 <DuelShark> ah I'll check the state monad out
11:18:55 <DuelShark> thanks
11:18:55 <geekosaur> haskell does not have mutable variables of the sort you may be used to from other languages
11:19:09 <DuelShark> yeah that's what I was kind of not understanding
11:19:11 <danharaj> DuelShark: Do not think of functions as procedures or variables as things that change. Those are bad ideas from other languages.
11:19:17 <DMcGill> although State lets it fake it pretty well
11:20:13 <DanBurton> "variables" *are* things that change. That's why they are called variable.
11:20:28 <geekosaur> but we do not have variables; we have bindings
11:20:32 <DanBurton> In Haskell, think of "values"
11:21:12 <danharaj> DanBurton: No, a variable is called a variable because it is indeterminate. If you bind a variable to a definition then it is no longer indeterminate. It is exactly one thing wherever that definition is in scope. You do not change a variable, you bind it.
11:21:13 <Mortchek> DuelShark, here's an example of what I mean: https://gist.github.com/Mortchek/5102196
11:21:21 <danharaj> Although now we are just arguing over verbs and nouns so I'll acquiesce :P
11:21:29 <Mortchek> The "state" is maintained by successive calls to loop
11:21:33 <DanBurton> danharaj: yes you're right. I sort of bit my tongue after I typed that.
11:21:49 <DuelShark> oh so the main would be a loop?
11:22:01 <DuelShark> that's how I can hold updated values to memory
11:22:15 <danharaj> DuelShark: If you want a mutable reference, look at IORef.
11:22:46 <typoclass> DuelShark: in haskell, you do that kind of thing often by calling a function repeatedly. in "f x = ..." you'd have x be the list, which you can process and print and whatever. you'd then call f again with another, changed x when needed
11:23:21 <DuelShark> okay I'll try and wrap my head around everything you've all said thanks
11:23:46 <kaleidic> Thanks, <danharaj>, for articulating the meaning of variable.
11:24:38 <aCube> Is there a monoid like the following: mappend (Just x) (Just y) = Just $ x <> y; mappend _ _ = Nothing; mempty = Just $ mempty
11:25:01 <typoclass> DuelShark: it'd be easier to explain with code :-) you can put stuff on hpaste (doesn't matter if it's incomplete) and folks in #haskell can usually point you in the right direction
11:25:18 <DuelShark> okay thanks will do once I've looked at these I appreciate it
11:25:29 <simpson> aCube: I think that that instance is done by default.
11:25:33 <simpson> @instances Monoid
11:25:34 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:25:44 <aCube> > Just 3 <> Nothing
11:25:46 <lambdabot>   Ambiguous type variable `a0' in the constraints:
11:25:46 <lambdabot>    (GHC.Num.Num a0)
11:25:46 <lambdabot>      a...
11:25:50 <aCube> > Just [3] <> Nothing
11:25:52 <lambdabot>   Just [3]
11:25:55 <danharaj> The Maybe monoid instance sucks. It has an extra mempty!
11:26:24 <aCube> Oh wait, wouldn't that be just Const?
11:26:34 <simpson> > Just "sitting " `mappend` Just "on a bench"
11:26:36 <lambdabot>   Just "sitting on a bench"
11:26:50 <aCube> > Just [3] <> Nothing
11:26:51 <lambdabot>   Just [3]
11:26:56 <aCube> i want this to be Nothing
11:27:04 <danharaj> aCube: That's not a monoid then.
11:27:07 <tac> > Just [1] <> Just [2]
11:27:08 <lambdabot>   Just [1,2]
11:27:09 <crl> > iterate (fix (1+)) 0
11:27:11 <lambdabot>   No instance for (GHC.Num.Num (a0 -> a0))
11:27:11 <lambdabot>    arising from a use of `e_110'
11:27:11 <lambdabot>  ...
11:27:12 <aCube> danharaj: why?
11:27:20 <danharaj> wait, I spoke too soon.
11:27:23 <aCube> > Just [1] <> Just []
11:27:25 <lambdabot>   Just [1]
11:27:36 <danharaj> I see what you want.
11:27:50 <tac> A monoid instance for Maybe [a]?
11:28:08 <danharaj> aCube: You can use a newtype to wrap Maybe and then write your own instance.
11:28:09 <simpson> aCube: I don't think it'd be a Monoid, since your identity no longer satisfies the laws.
11:28:25 <danharaj> Just mempty <> Nothing == Nothing
11:28:36 <aCube> Oh, right
11:28:36 <danharaj> (well, with the instance you want)
11:31:12 <danharaj> My current project has a leak that consumes several hundred megabytes of memory per second when compiled with -O0, and is memory-flat on -O1. That sort of scares me.
11:32:11 <DanBurton> my first time building ghc from source. *crosses fingers*
11:32:47 <Botje> it's not as picky as compiling linux kernels from source
11:33:01 <Botje> "oh, you wanted to actually _type_ on the console? better enable keyboard support then!"
11:33:15 <typoclass> DanBurton: find a comfortable pose for your fingers, cause it's going to take a few years?
11:34:02 <DanBurton> typoclass: well I did "make -j8" so hopefully it can be cut down to a half-dozen months or so
11:34:23 <Botje> at least you'll be warm
11:35:16 <typoclass> i think they pretty soon want to bring out a word for "dozen months"
11:36:42 <aCube> :t (>>)
11:36:44 <lambdabot> Monad m => m a -> m b -> m b
11:36:53 <DanBurton> I was searching for a word that suggested more than "a few" but less than "several", and "half-dozen" was the best I could come up with :P
11:37:03 <aCube> @hoogle m b -> m a -> m b
11:37:03 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
11:37:04 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
11:37:04 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
11:37:48 <Philippa> DanBurton: huh. I think my boundary for "several" starts sooner than yours
11:38:09 <monochrom> danharaj: if it is any consolation, you may like to know this example of the opposite: https://groups.google.com/d/msg/comp.lang.haskell/nKDULVCjj74/2YwZJeS1PpwJ
11:38:20 <typoclass> DanBurton: i'm not criticizing :-) you succeeded very well in being funny. half-dozen months is much better than half-year
11:38:26 <aCube> Why is there no flipped (>>)? (Other than <*)?
11:38:33 * DanBurton bows
11:39:11 <monochrom> "handful" may be similar to "half-dozen"
11:39:15 <DanBurton> aCube: why isn't there X, other than X? wat
11:40:07 <typoclass> aCube: huh, good question. you'd kind of expect it, since there are (>>) (>>=) (=<<)
11:40:08 <DanBurton> > (Just 3 <* Nothing, Just 3 <* Just 4)
11:40:10 <lambdabot>   (Nothing,Just 3)
11:40:44 <c_wraith> :t liftA2 const
11:40:45 <lambdabot> Applicative f => f c -> f b -> f c
11:40:53 <monochrom> perhaps because <* exists
11:41:02 <c_wraith> yeah, (<*) is the same as liftA2 const
11:41:06 <DanBurton> I suppose given the retarded state of Haskell's Functor/Applicative/Monad classes, there may be reason to justify <<
11:41:46 <DanBurton> since Monad does not automatically imply Applicative, even though sanity dictates that it should
11:42:16 <clahey> What would << do?  The same thing as <*?
11:42:20 <monochrom> when >> and >>= were thought up, there was no Applicative, and there was no demand for << =<<
11:42:25 <clahey> Or would it be flip (>>) ?
11:42:25 <DanBurton> clahey: yep
11:42:41 <srhb> Has anyone found a workable solution for haskell-mode and cabal-dev? I seem to have problems with subdirectories.
11:42:44 <DanBurton> clahey: that would be the same result, just implementation details
11:42:50 <typoclass> monochrom: yup, something like that must be the reason
11:43:14 <monochrom> later, there was demand for << =<<, but by that time Applicative existed, therefore, just use <*, but =<< must be defined separately
11:43:15 <clahey> > (Just 3 >> Just 4, Just 3 <* Just 4)
11:43:17 <lambdabot>   (Just 4,Just 3)
11:43:27 <DanBurton> srhb: isn't ghc-mod supposed to handle that sort of thing?
11:43:39 * DanBurton is guessing wildly
11:43:48 <srhb> Uh. Maybe.
11:43:59 <clahey> Where is <* defined?
11:44:12 <monochrom> Control.Applicative
11:44:21 <typoclass> i guess in an ideal world, we'd have (>>) (>>=) (=<<) (<<), Monads were all Applicative, and (<*) (*>) could probably be abolished
11:44:28 <DanBurton> clahey: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
11:44:46 <clahey> So, <* is not flip (>>).
11:45:10 <aristid> typoclass: wait, Monad = Applicative... that doesn't make any sense to me, even in an idealised world ;)
11:45:11 <clahey> Because print 4 <* print 5 ≠ print 5 >> print 4
11:45:14 <DanBurton> it is not defined that way, but it works the same
11:45:26 <clahey> DanBurton: I don't think it is.
11:45:28 <c_wraith> DanBurton: no, it doesn't work the same
11:45:30 <DanBurton> wat
11:45:37 <DanBurton> oh right
11:45:47 <monochrom> in an ideal world, you invent categories before you invent sets, you invent sets before you invent algebra, you invent algebra before you invent numbers.
11:45:50 <DanBurton> @smack DanBurton
11:45:51 <lambdabot> I'd rather not; DanBurton looks rather dangerous.
11:45:55 <DanBurton> -__-
11:46:12 <clahey> *> === >> though, right?
11:46:17 * typoclass mumbles something at aristid about "a ford is a car" without this meaning that all cars are ... oh never mind :-)
11:47:03 <c_wraith> clahey: yes, those two are the same
11:47:07 <DanBurton> @let (<<) = flip (>>)
11:47:09 <lambdabot>  Defined.
11:47:13 <monochrom> "is" is overloaded. (however, overloaded is not "is")
11:47:15 <typoclass> monochrom: i think you have that quite backwards ;-)
11:47:46 <monochrom> yes! I was sarcastic. clearly, you invent a less general thing first before you invent a more general thing
11:48:02 <aristid> typoclass: huh you _did_ say that <* and *> could be abolished... *confused*
11:48:17 <typoclass> monochrom: ah i see. we're all agreeing vigorously, hen
11:48:21 <typoclass> s/hen/then
11:48:33 <monochrom> therefore, you must invent Monad first before you invent Applicative. therefore, you have to fight backward compatibility when you want Monad to be a subclass of Applicative
11:50:06 <clahey> DanBurton: No no no.
11:50:22 <DanBurton> I'm still a little baffled upon realizing that we have the backwards-monad operators, which read from right to left, and the backwards-applicative operators, which read from left to right
11:50:37 <clahey> Oh, that's a good point.
11:50:48 <clahey> =<< does "execute" from right to left.
11:50:52 <typoclass> aristid: well i assumed things would be renamed. i thought the names (>>) (<<) look nicer than (<*) (*>) and fit better with (>>=) (=<<)
11:50:55 <c_wraith> DanBurton: I think that's why there's no <<
11:51:05 <monochrom> yikes, <* is not <<
11:51:08 <tac> @src (=<<)
11:51:08 <lambdabot> f =<< x = x >>= f
11:51:08 <aristid> typoclass: mm
11:51:11 <c_wraith> DanBurton: =<< is unambiguous, though. There's only one possible way it could work.
11:51:11 <DanBurton> c_wraith: that would make sense
11:51:13 <applicative__> danharaj: but isn't -O0 about what ghci manages?
11:51:24 <clahey> <* is quite useful.
11:51:26 <monochrom> ok, I don't know why no one else uses <<
11:51:32 <typoclass> aristid: you have however sufficiently confused me now that i don't know anymore what i wanted
11:51:33 <typoclass> ;)
11:51:36 <clahey> a *> b <* c is so easy to read.
11:51:53 <aristid> clahey: a very nice pattern indeed
11:51:58 <aristid> :t liftA2 flip
11:52:00 <lambdabot> Applicative f => f (a -> b -> c) -> f b -> f (a -> c)
11:52:14 <latro`a> :t \a b c -> a *> b <* c
11:52:16 <lambdabot> Applicative f => f a1 -> f a -> f b -> f a
11:52:21 <kaleidic> OK, I missed it. What (roughly) are the meanings of *> and <* ?
11:52:21 <monochrom> consider "(\_ -> action1) =<< action0"
11:52:22 <clahey> But the fact that =<< has to execute right to left is confusing.
11:52:30 <aristid> @src (<*)
11:52:30 <lambdabot> (<*) = liftA2 const
11:52:49 <clahey> So I guess I'm okay with << not being the same as <*?  Maybe.
11:52:52 <aristid> clahey: it obviously has to because it needs to fill in the parameter
11:52:54 <typoclass> (>>=) is back to front compared with (.)
11:53:05 <typoclass> (isn't it?)
11:53:18 <aristid> typoclass: (>=>) is
11:53:24 <clahey> aristid: It's not confusing why it has to.  It's confusing in how it interacts with the fact that <* executes left to right.
11:53:35 <DanBurton> kaleidic: *> means (\mx my -> mx; my), <* means (\mx my -> do x <- mx; my; return x)
11:54:18 <clahey> @src (*>)
11:54:19 <lambdabot> (*>) = liftA2 (const id)
11:54:23 <clahey> That was my guess.  :)
11:54:37 <aristid> that or liftA2 (flip const) :)
11:54:40 <hpaste> “Anonymous Coward” pasted “Haskell” at http://hpaste.org/83602
11:55:21 <DanBurton> Anonymous Coward couldn't have picked a less descriptive title for an hpaste...
11:55:23 <typoclass> kaleidic: "action1 *> action2" more or less means "execute action1 and action2, ignore the result of action1, give back the result of action2"
11:55:53 <kaleidic> Thanks, typoclass.
11:56:05 <clahey> DanBurton: Should there be an extra do in there somewhere?
11:56:12 <DanBurton> clahey: yes
11:56:27 <DanBurton> mx *> my = do mx; my
11:56:38 <clahey> kaleidic: And action1 <* action2 means "execute action1 and action2, ignore the result of action2, give back the result of action1"
11:56:43 <clahey> kaleidic: More or less.
11:57:02 <typoclass> DanBurton: "*> means (\mx my -> mx; my)" <- o rly? then why does this print only "41", not "43 41"? (print . succ *> print . pred) 42
11:57:11 <typoclass> DanBurton: ... just kidding, just messing with you ;-)
11:57:21 <applicative__> >  ((*) *> (+) <* (*)) 10 10
11:57:23 <lambdabot>   20
11:57:37 <aCube> For my needs, <* works as good as (<<) would do. (I wanted to use foldr, but thought it'd be nice if I didn't have to write flip (<<))
11:57:39 <DanBurton> @slap typoclass
11:57:39 * lambdabot throws some pointy lambdas at typoclass
11:58:47 <monochrom> @stab monochrom
11:58:48 * lambdabot smacks monochrom about with a large trout
11:58:51 <saep> @hoogle [a] -> [[a]]
11:58:51 <lambdabot> Data.List inits :: [a] -> [[a]]
11:58:52 <lambdabot> Data.List permutations :: [a] -> [[a]]
11:58:52 <lambdabot> Data.List subsequences :: [a] -> [[a]]
11:59:21 <clahey> Does it only list the first three matches?
11:59:37 <aCube> yes
11:59:55 <clahey> @hoogle a -> a
11:59:56 <lambdabot> Prelude id :: a -> a
11:59:56 <lambdabot> Data.Function id :: a -> a
11:59:56 <lambdabot> GHC.Exts breakpoint :: a -> a
12:00:02 <typoclass> clahey: yup. a defense against accidentally spamming the channel
12:00:08 <clahey> As that last would have done.
12:00:25 <saep> but it gave me the function i wanted ;)
12:00:32 <armlesshobo> win!
12:00:36 <clahey> Hooray!
12:00:48 * armlesshobo claps
12:00:51 <armlesshobo> :(
12:00:57 <DanBurton> t'would be nice if lambdabot gave a link to the hoogle website
12:01:12 <DanBurton> for each query
12:01:37 <monochrom> @clap monochrom
12:01:38 * lambdabot hits monochrom with an assortment of kitchen utensils
12:02:05 <DanBurton> @whap monochrom
12:02:05 <lambdabot> I know nothing about monochrom.
12:02:25 <geekosaur>  @slowclap?
12:02:40 <clahey> I'm surprised it doesn't find repeat on the full hoogle.
12:03:03 <DanBurton> repeat, or cycle?
12:03:05 <applicative__> > (fromIntegral *> (*3) *> (+) <*> (*10) <* even <* odd) 9
12:03:07 <lambdabot>   99
12:03:16 <typoclass> clahey: honestly, half the time i have no idea what hoogle is doing :-/ hayoo seems much more complete
12:04:17 <typoclass> > ((==) <*> reverse) "radar" -- palindrome checker. same as applicative's thing, without the red herrings ;-)
12:04:19 <lambdabot>   True
12:05:13 <DanBurton> that is a weird idiom. trying to figure out how to pronounce <*> specialized to functions
12:05:37 <DanBurton> "to itself after applying"
12:06:38 <DanBurton> @type on
12:06:40 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
12:06:59 <applicative__> "radar" is the constant environment, so the two elements are "radar" == and reverse "radar"
12:07:10 <clahey> DanBurton: repeat.
12:07:17 <clahey> > repeat [5]
12:07:19 <lambdabot>   [[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5...
12:07:24 <mauke> DanBurton: S
12:07:26 <applicative__> or ("radar" ==) and (reverse "radar")
12:07:36 <DanBurton> clahey: oh right, dur
12:07:38 <clahey> DanBurton: cycle isn't [a] -> [[a]]
12:08:16 <DanBurton> mauke: I was hoping for a term my grandmother would be slightly more likely to understand
12:08:33 <armlesshobo> where can I search for where these operators come from?
12:08:40 <armlesshobo> like <*> <|>
12:08:41 <armlesshobo> etc
12:08:49 <Dodek> armlesshobo: hoogle
12:08:54 <DanBurton> @where hoogle
12:08:54 <lambdabot> http://haskell.org/hoogle
12:08:59 <armlesshobo> :O ok thank you
12:09:03 <clahey> armlesshobo: What do you mean by where they come from?  Like where the source code is or what inspired them?
12:09:36 <DanBurton> Or where does thought come from? What is truth? Where did the universe come from? #mustgodeeper
12:10:54 <DanBurton> grrr, compiling ghc from source, it claims it can't execute /usr/bin/gcc even though it's clearly there.
12:10:58 <armlesshobo> clahey: no, the modules they come from.
12:13:43 <dmwit> ?hoogle+
12:13:44 <lambdabot> GHC.Exts inline :: a -> a
12:13:44 <lambdabot> GHC.Exts lazy :: a -> a
12:13:44 <lambdabot> Control.Exception.Base mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
12:13:48 <hpaste> DanBurton pasted “building GHC from source, can't find gcc while making TH/Syntax.hs” at http://hpaste.org/83603
12:13:52 <dmwit> clahey: in case three is not enough
12:14:38 <dmwit> DanBurton: And just to ask the stupid question, gcc is installed, right?
12:14:44 <hpaste> DanBurton annotated “building GHC from source, can't find gcc while making TH/Syntax.hs” with “building GHC from source, can't find gcc while making TH/Syntax.hs (annotation)” at http://hpaste.org/83603#a83604
12:14:51 <clahey> DanBurton: Can you execute it?
12:14:55 <DanBurton> yeah
12:15:00 <dmwit> right
12:15:02 <DanBurton> haven't tried on any C programs, but it's there
12:15:27 <clahey> I've had trouble where the file was there, but wouldn't execute because of some setting on the mount.
12:16:32 <DanBurton> okay I just compiled a hello world in C using /usr/bin/gcc and executed it just fine
12:16:52 <DanBurton> I'm on a mac, so I think that /usr is fake or something
12:17:10 <hpc> the configure should be catching that
12:17:24 <hpc> (unless it isn't, in which case google has something to say about fixing it)
12:20:05 <DanBurton> how am I supposed to hack ghci if I can't build it >,<
12:20:39 <slack1256> I've seen that in ocaml they have a normal 'let' and a 'recursive let' where haskell only has the latter.
12:20:42 <mauke> M-butterfly
12:20:48 <slack1256> is there any formal reason for this?
12:20:57 <dmwit> not really
12:21:04 <mauke> you never really need a non-recursive let
12:21:18 <mauke> α
12:21:22 <DanBurton> it is simpler to implement a non-recursive let
12:21:24 <slack1256> I've seen the distinction on lisp also.
12:21:32 <slack1256> oh that what I thought
12:21:38 <slack1256> maybe was more easy to implement
12:21:44 <applicative__> DanBurton: I remember having this problem in one mac setup -- or maybe the same problem.  I couldn't call gcc indirectly without superuser privileges
12:21:46 <dmwit> Right, but if you're going to have a recursive let anyway, simplicity hardly matters...?
12:21:46 <DanBurton> but the language user doesn't really need to know that
12:21:50 <mauke> quick, what's the difference between LET, LET*, FLET, LABELS, and DEFUN?
12:22:00 <DanBurton> applicative__: so... dare I "sudo make" ?
12:22:30 <slack1256> DEFUN takes away the FUN in LISP :-)
12:22:37 <applicative__> DanBurton: seems crazy, but my experience is that it might work.
12:22:43 <c_wraith> DanBurton: you should never sudo make.  you should make, then sudo make install
12:23:22 <DanBurton> c_wraith: the problem is that during "make" it can't use /usr/bin/gcc for some inexplicable reason
12:23:30 <c_wraith> oh.  That's terrifying
12:24:02 <applicative__> it was a major pain when a simple cabal install with c-bindings had to use gcc; i would do it with sudo, then had to change ownership in ~/,cabal
12:24:10 <applicative__> but of course, I was too lazy to look into the real problem
12:24:56 <DanBurton> my /usr/bin/gcc has execute privileges on everyone so... wtf :(
12:25:32 <dcoutts> applicative__: odd, since ghc calls gcc for everthing it compiles
12:26:09 <applicative__> I can't remember the details, sometimes it would complain if gcc was to 'make an executable'
12:27:05 <mauke> linkering?
12:27:19 <applicative__> dcoutts: what does 'ghc-stage1: could not execute: /usr/bin/gcc' suggest to you
12:27:20 <DanBurton> well, despite my better judgement, I just tried "sudo make", same error message (thankfully?)
12:27:31 <applicative__> ah, so there it is different
12:27:47 <dcoutts> applicative__: that it can't execute it :-)
12:27:53 <DanBurton> dcoutts: orly???
12:28:23 <DanBurton> :)
12:28:34 <applicative__> yes, but what can it be but a matter of privileges?
12:28:48 <dcoutts> applicative__: sorry, I just glanced at the backlog here, I thought it was a cabal-specific issue, but I see it isn't
12:28:54 <mauke> running out of memory?
12:29:01 <dmwit> running out of disk space?
12:29:05 <applicative__> dcoutts, I mean that it can't execute gcc, which DanBurton can do with hello.c
12:29:13 <dcoutts> applicative__: yes, looks like perms, you're saying it isn't?
12:29:20 <DanBurton> lrwxr-xr-x   1 root   wheel        12 Feb 11 11:38 gcc -> llvm-gcc-4.2
12:29:39 <dmwit> What are the permissions on llvm-gcc-4.2?
12:29:49 <DanBurton> lrwxr-xr-x   1 root   wheel        32 Feb 11 11:38 llvm-gcc-4.2 -> ../llvm-gcc-4.2/bin/llvm-gcc-4.2
12:29:55 <dmwit> ugh...
12:30:08 <applicative__> DanBurton's problem doesn't seem to be.  I was wondering if it was. It's building ghc anyway, not a cabal thing'; sorry I woke you ...
12:30:19 <dcoutts> np :-)
12:30:25 <DanBurton> -rwxr-xr-x  1 root  wheel  117168 Feb 11 11:38 llvm-gcc-4.2
12:31:01 * hackagebot caledon 2.0.0.0 - a logic programming language based on the calculus of constructions  http://hackage.haskell.org/package/caledon-2.0.0.0 (MatthewMirman)
12:31:20 <geekosaur> DanBurton, ls -lL
12:31:35 <applicative__> ah my neighbor mmirman is up to no good again
12:31:42 <geekosaur> (tells it to follow symlinks and show the actual target permissions etc.)
12:31:50 <applicative__> ah a unix master is here!
12:31:56 <DanBurton> geekosaur: ah, nice
12:32:28 <DanBurton> in that case, -rwxr-xr-x  1 root  wheel  117168 Feb 11 11:38 /usr/bin/gcc
12:33:38 <DanBurton> ugh, screw this, I'll just make a virtual linux box *sigh*
12:33:50 <dmwit> DanBurton: Have you checked on mauke's suggestion?
12:34:16 <DanBurton> running out of memory? Not sure how that could happen; I should have plenty available.
12:34:21 <DanBurton> not sure how to check
12:34:45 <DanBurton> disk space is plentiful
12:34:54 <dmwit> Me neither; maybe open top or something and see if memory goes to 100%.
12:36:27 * geekosaur wonders if ghc build is setting {,DY}LD_LIBRARY_PATH... that would be bad, as it doesn't do the same thing on OS X as on Linux/*BSD
12:37:08 <geekosaur> and yes, it can easily cause an otherwise working program to stop working
12:37:09 <geekosaur> \
12:37:12 <geekosaur> (oops)
12:39:57 <geekosaur> dtruss -f might also be helpful in sorting out what's going on
12:40:30 <Taneb> I'm trying to use the FFI and failing...
12:42:52 <Taneb> How do I tell GHC that when it compiles this C(++) file, this other library is in that location?
12:44:58 <thoughtpolice> Taneb: like gcc IIRC: ghc -L/path/to/libraries/ -llib_i_want
12:45:15 <Taneb> Right
12:45:33 <beaky> how do I define an isomorphism
12:45:38 <crl> > zipWith (:) [1,2,3] [[4,5],[4,5],[4,5],[4,5]]
12:45:40 <lambdabot>   [[1,4,5],[2,4,5],[3,4,5]]
12:45:46 <crl> how could i not lose the last element ^ ?
12:46:05 <crl> [[1,4,5],[2,4,5],[3,4,5],[4,5]]
12:46:43 <crl> need to create a custom zip
12:47:18 <DanBurton> beaky: what do you want to do with "an isomorphism"?
12:47:42 <DanBurton> @t iso
12:47:42 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:47:46 <beaky> ah thanks
12:47:52 <DanBurton> @type iso
12:47:53 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
12:48:46 <beaky> what's a profunctor
12:48:51 <beaky> @t profunctor
12:48:52 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:49:00 <beaky> @type profunctor
12:49:01 <lambdabot> Not in scope: `profunctor'
12:49:06 <beaky> ah
12:56:34 <crl> is there an opposite to concat?
12:56:47 <crl> [1,2] -> [[1],[2]]
12:56:53 <mauke> map (: [])
12:56:56 <croikle> beaky: a nice example of a profunctor is (->). it's a functor on the right side, and a reverse functor (contravariant) on the left.  see http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html
12:56:57 <crl> thx
13:00:17 <saep> @hoogle (a -> b) -> a -> (a, b)
13:00:17 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
13:00:18 <lambdabot> Control.Monad.Writer.Lazy listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
13:00:18 <lambdabot> Control.Monad.Writer.Strict listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
13:01:17 <mauke> :t liftA (,)
13:01:19 <lambdabot> Applicative f => f a -> f (b -> (a, b))
13:02:11 <elliott> :t fmap . (,)
13:02:13 <lambdabot> Functor f => a1 -> f a -> f (a1, a)
13:02:21 <elliott> oh, saep's didn't have an f
13:02:31 <mauke> :t ap (,)
13:02:32 <lambdabot> (a1 -> a) -> a1 -> (a1, a)
13:02:45 <S11001001> @ty (id &&&)
13:02:46 <saep> > (id &&& length) [1..5]
13:02:46 <lambdabot> (c -> c') -> c -> (c, c')
13:02:47 <lambdabot>   ([1,2,3,4,5],5)
13:04:54 <kevinx> getting weird error when using Data.ByteString.getContents. can someone take a look?  http://hpaste.org/83606
13:05:13 <kqr> is (,) an operator when you use it to say, e.g. (3, 4, 5)
13:05:30 <geekosaur> it's syntax
13:05:33 <mauke> kevinx: how are you running it?
13:05:37 <kqr> geekosaur, yeah that's what i thought
13:05:45 <kqr> geekosaur, but do you mean to say it exists as an operator as well?
13:06:09 <geekosaur> :t (,,)
13:06:11 <lambdabot> a -> b -> c -> (a, b, c)
13:06:35 <kevinx> mauke I am compiling it to executable and running it from terminal
13:06:41 <mauke> kevinx: how are you running it?
13:07:19 <kevinx> if that wasn't what you were asking clarify your question
13:07:39 <mauke> bored now
13:07:40 <geekosaur> what version of ghc is this? I think some versions had a bug like this on windows
13:07:53 <kevinx> geekosaur 7.4.2
13:10:02 <macrover> is there a comparison between the various streams/pipes/conduits libraries?
13:15:06 <Cale> macrover: I am presently resisting the temptation to make a table with the libraries and only one other column which is "maximum number of type parameters to a type constructor".
13:15:44 <danharaj> Cale: That sounds amusing. Do it!
13:17:07 <Taneb> lens has a type synonym with 7 arguments
13:23:50 <amyers> kevinx: Since your using strict bytestring that will load the whole input into memory before writing it won't it?
13:24:33 <ivanm> Cale: heh
13:24:46 <ivanm> @remember Cale <macrover> is there a comparison between the various streams/pipes/conduits libraries? <Cale> macrover: I am presently resisting the temptation to make a table with the libraries and only one other column which is "maximum number of type parameters to a type constructor".
13:24:46 <lambdabot> I will never forget.
13:27:13 <kevinx> amyers it should yes
13:28:45 <monochrom> hahaha
13:28:49 <kevinx> I am getting same error with Data.ByteString.Lazy. it works fine with Prelude.getContents
13:29:34 <amyers> ah
13:31:54 <beaky> I like the sigfpe blog
13:32:22 <monochrom> print contents? you don't want B.putStr contents? although, this is a separate issue
13:34:50 <monochrom> the program works for me after adding .Lazy. "./test </dev/zero" consumes O(1) memory
13:35:32 <kevinx> it works with Data.ByteString.Lazy, but not with Data.ByteString ?
13:35:44 <monochrom> I haven't tried. I can try now
13:36:01 <kevinx> don't redirect a file though
13:36:16 <kevinx> just run the program and have it read from stdin
13:36:19 <monochrom> it "realloc: resource exhausted (out of memory)" pretty quickly
13:36:22 <kevinx> if I redirect a file it works in here too
13:37:20 <monochrom> ok, I can enter data by hand, but I have to enter hundreds of megabytes, I can do that if I receive payment of $1 per byte
13:37:28 <kevinx> I get that error right away, without having a chance to type anything to stdin
13:37:44 <monochrom> ok, if I enter only a few bytes, I get no error
13:38:21 <monochrom> although, I am on linux, not windows. however, I see no reason for any difference at this point
13:38:47 <kevinx> you have tried both Data.ByteString.Lazy and Data.ByteString ?
13:39:02 <monochrom> yes
13:39:22 <monochrom> if I enter a few bytes by hand, both have no error
13:40:01 <monochrom> if I enter no byte, there is still no error
13:40:27 <kevinx> I can't even enter anything, that exception is thrown right away. also I was wrong, it only happens if I use Data.ByteString.Lazy.getContents. it works with both Data.ByteString.getContents and Prelude.getContents
13:41:29 <monochrom> at this point I am ready to blame it on defective computer or sunspot activities
13:41:35 <edwardk> Cale: we're this close to finishing dumbing down Machines by removing Plan.
13:42:26 <edwardk> Cale: that sounds like moral equivalent to the Old Man Murray 'start to crate' test for stream processing libraries.
13:43:13 <edwardk> http://www.oldmanmurray.com/features/40.html
13:43:21 <mapreduce> edwardk: What's the best place to read about machines other than the non-free book that's coming out?
13:43:34 <monochrom> hmm, perhaps next time I should change the price to 1 bitcoin per byte :)
13:43:38 <mapreduce> I find Apocalisp's slides etc., a bit tricky.
13:43:50 <edwardk> mapreduce: not sure yet. we're still working on them
13:44:08 <mapreduce> Hokay.
13:44:38 <hpaste> “Anonymous Coward” annotated “B.getContents error” with “B.getContents error (annotation)” at http://hpaste.org/83606#a83612
13:45:31 <edwardk> probably the #haskell-lens channel, since elliott tends to talk to me about machines in there every once in a while =)
13:54:05 <samm> when writing a haskell server is it common to use a thread per client?
13:54:16 <monochrom> yes
13:54:51 <mapreduce> dhp-examples fails to install because it depends on bmp-1.2.3.1, which fails to compile with: Codec/BMP.hs:208:11: Not in scope: `BSL.fromStrict'
13:54:57 <mapreduce> Any suggestions?
13:56:29 <dmwit> At a guess, that's an attempt to convert a strict bytestring to a lazy one.
13:56:40 <monochrom> I cannot find dhp-examples
13:56:43 <dmwit> Perhaps you can open up the file and verify that guess. If so, do that by hand.
13:57:01 <samm> arent there scalling and efficiency issues?
13:57:13 <monochrom> I do not know whether you must stick to bmp-1.2.3.1 or it could be pretty much any recent version such as 1.2.4.1
13:57:14 <samm> scaling
13:57:26 <monochrom> there is no scaling and efficiency issue
13:57:47 <dmwit> GHC's threads are very lightweight.
13:59:23 <monochrom> and it is not me saying it. it is people who use http servers written in haskell saying it.
13:59:59 <simpson> samm: Green threads, not OS threads.
14:00:14 <c_wraith> actually, there are scaling issues that GHC 7.8 will fix. But they're in scheduling IO rapidly enough
14:00:19 <simpson> samm: (You'd be right that OS thread-per-client would be intractable, and it is.)
14:01:22 <c_wraith> all the early testing shows that http servers compiled with GHC 7.8 handle several times as much traffic in heavy concurrency situations.
14:01:52 <c_wraith> Of course, this is also a good argument for the thread-per-request model. If there are performance bugs, they can be fixed.
14:02:03 <c_wraith> They're bugs, not limitations inherent in the system
14:02:43 <monochrom> I guess you use 1.2.3.1 because it is the last version to accept GHC 7.4's bytestring
14:04:09 <samm> aprox how many parallel threads can you reasonably run?
14:04:21 <c_wraith> hundreds of thousands
14:04:33 <hpc> as many as you have memory for, really
14:04:47 <monochrom> unfortunately, bytestring-0.10 is the one that provides fromStrict. it comes with GHC 7.6, not GHC 7.4
14:04:48 <simpson> The question is, "How much memory does a green thread take?"
14:04:51 <c_wraith> Which is generally hundreds of thousands.  Default 1MB stack for each
14:05:01 <simpson> For comparison, JVM needs 4MiB per green thread.
14:05:03 <c_wraith> Though you can set the default stack size lower at program start
14:05:22 <monochrom> I guess bmp-1.2.3.1 flunked it, therefore they put out 1.2.3.2 etc
14:06:01 <samm> and how many MBs are needed for OS thread?
14:06:26 * hackagebot language-eiffel 0.1.2 - Parser and pretty printer for the Eiffel language.  http://hackage.haskell.org/package/language-eiffel-0.1.2 (ScottWest)
14:08:43 <mapreduce> monochrom: D'oh, dph-examples not dhp-examples
14:08:46 <mapreduce> sorry
14:09:22 <mapreduce> dmwit: I might try that, but I'm unlikely to actually do anything useful there.
14:15:51 <samm> c_wraith: did you mistype 1MB per thread? that would require 100 GB for 100 thousand threads
14:16:24 <ciaranm> doesn't everyone have 100GB?
14:16:42 <c_wraith> Nah. That's the default. But if your threads aren't doing much, it's one command-line argument (at runtime) to reduce the size by a ton
14:16:55 <monochrom> mapreduce: if you had GHC 7.6, cabal would choose dph-examples 0.7.0.5, which would not requires gloss or bmp.
14:17:26 <mapreduce> hmph, 7.4.1
14:17:39 <monochrom> but you're on GHC 7.4, this forces dph-examples 0.6.1.3, which wants gloss and bmp
14:18:32 <XexonixXexillion> Is there any compiler flag to prevent IO evaluation in template haskell?
14:18:32 <lambdabot> XexonixXexillion: You have 1 new message. '/msg lambdabot @messages' to read it.
14:19:18 <mapreduce> monochrom: Ok, thanks.  Looks like I'll have to switch my sources.list
14:19:45 <monochrom> well, bmp-1.2.2.1 builds fine on GHC 7.4. so try: cabal install dph-examples --constraint='bmp == 1.2.2.1'
14:21:38 <hpaste> “Anonymous Coward” pasted “HTTP Errors” at http://hpaste.org/83613
14:22:37 <hsnoob> Can somebody help me with that hpaste above?
14:22:59 <monochrom> you need more parentheses. getRequest (x ++ y ++ z)
14:23:27 <samm> c_wraith: I managed to run 800 thousand threads with this code. http://stackoverflow.com/questions/1900165/how-long-does-it-take-to-create-1-million-threads-in-haskell
14:24:11 <samm> c_wraith: so I cant see how default can be 1MB?
14:24:24 <hsnoob> That leaves me with another error
14:26:51 <supki> getReddit cannot possibly be  :: String -> String
14:27:38 <hpc> when i try a million threads on a gig of RAM i swap way too hard
14:28:07 <monochrom> GHC thread stacks are grown and shrunk on the run. therefore, if you just create a thread and don't make it work hard, you don't consume 1MB per thread. perhaps 1KB, the default initial stack size for new threads. use +RTS -ki to change.
14:28:09 <c_wraith> samm: oh, the default might be 512k. I should actually check.
14:28:44 <danharaj> It is useful to be aware of the -xt RTS flag that includes things such as thread stack space in heap profiles.
14:28:52 <danharaj> (Otherwise it is invisible to you)
14:33:05 <hpaste> monochrom annotated “HTTP Errors” with “HTTP Errors (attempted correction)” at http://hpaste.org/83613#a83615
14:33:42 <monochrom> hsnoob: perhaps my paste corrects the error. I have not tested.
14:35:13 <c_wraith> monochrom: doubt it. I think the problem is that getRequest doesn't return a String, but he's using ++ on the result of it
14:35:31 <c_wraith> Which would be fixed with another set of parens, I think
14:35:45 <monochrom> oh, I haven't corrected that one. but your scroll buffer proves that I knew that one
14:36:08 <c_wraith> maybe if I read my scroll buffer it would.  Oops.  But yeah, adding that IO was necessary too
14:36:19 <monochrom> this is when the "Edit" option is useful!
14:36:48 <hpaste> monochrom revised “HTTP Errors (attempted correction)”: “HTTP Errors (attempted correction)” at http://hpaste.org/83615
14:38:04 <piezoid> hi, how a C api should be designed to be used from Haskell ?
14:38:33 <QinGW2> ffil
14:38:50 <QinGW2> ffi
14:39:16 <armlesshobo> iff
14:39:31 <armlesshobo> liff
14:39:33 <piezoid> ok, but are there some design rules ?
14:39:51 <piezoid> to cope with imutability for example...
14:39:54 <beaky> what does forall a.a mean?
14:39:59 <monochrom> hrm, hpaste does not do what I want
14:40:17 <beaky> hpaste is awesome
14:40:43 <piezoid> to be more specific, I build a directed graph, then give it to C function wich make a cache-effective (compact) version.
14:41:10 <Tritlo> :t hpaste
14:41:11 <lambdabot>     Not in scope: `hpaste'
14:41:11 <lambdabot>     Perhaps you meant `phase' (imported from Data.Complex)
14:41:26 <Sgeo> Well, don't have the C program use global variables
14:41:36 <Sgeo> Or, at least, don't... hmm
14:41:37 <piezoid> my question is : should I use a graph representation with haskell ADT or build the graph with C API ?
14:41:54 <sproingie> forall a.a means a is any type.  not that useful by itself
14:41:56 <Sgeo> Don't have functions etc. which change a conceptual mutable global
14:42:30 <beaky> if there is a forall, does haskell have an exists a.a?
14:42:40 <sproingie> something like "forall a. a -> a" is more interesting, it's a -> a that works for every type.  only thing that fills the bill there is 'id'
14:43:18 <sproingie> whereas just "a -> a" without the forall is "any function for some type a -> a", and there's a lot of those if you make a more specific
14:43:20 <beaky> what about exists a. a -> b ?
14:44:11 <QinGW2> @hoogle a.a
14:44:12 <lambdabot> Foreign.Marshal.Array advancePtr :: Storable a => Ptr a -> Int -> Ptr a
14:44:12 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
14:44:12 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
14:44:37 <crl> > let zip' (a:as) (b:bs) = (a++b) : zip' as bs; zip' _ _ = [];splitIn n xs = let nth=length xs `div` n; (a:as) = foldr (\x (y:ys) -> let (h,t)=splitAt x y in t:ys++[h]) [xs] (replicate n nth) in zip' as $ replicate (n-length a) [] ++ map (: []) a in splitIn 3 ['a'..'z']
14:44:39 <lambdabot>   ["abcdefgh","ijklmnopy","qrstuvwxz"]
14:44:43 <sproingie> that's about as much as i know about forall, the rest of the world of existentials will have to be from someone else :)
14:45:01 <beaky> @hoogle exists
14:45:01 <lambdabot> System.IO.Error alreadyExistsErrorType :: IOErrorType
14:45:02 <lambdabot> System.IO.Error isAlreadyExistsError :: IOError -> Bool
14:45:02 <lambdabot> System.IO.Error isAlreadyExistsErrorType :: IOErrorType -> Bool
14:46:55 <crl> @set splitIn n xs = let zip' (a:as) (b:bs) = (a++b) : zip' as bs; zip' _ _ = [];nth=length xs `div` n; (a:as) = foldr (\x (y:ys) -> let (h,t)=splitAt x y in t:ys++[h]) [xs] (replicate n nth) in zip' as $ replicate (n-length a) [] ++ map (: []) a
14:46:57 <lambdabot>  Defined.
14:53:44 <vorsimex> I'm trying to run a Windows command in Haskell with `rawSystem "cmd.exe" ["/c", "dir"]`, however, cmd always gives me an error about '"dir' not a recognized command. Why is it prepending a quotation mark on my argument?
14:53:50 <croikle> crl: btw, your zip' is just zipWith (++)
14:55:35 <crl> > zipWith (++) ["","","a"] ["x","x","x"]
14:55:38 <lambdabot>   ["x","x","ax"]
14:56:06 <crl> @undef splitIn
14:56:19 <crl> @unset splitIn
14:56:19 <lambdabot> Unknown command, try @list
14:56:30 <croikle> have you seen Data.List.Split, too?
14:56:43 <crl> nope
14:56:58 <crl> going to
14:58:08 <crl> :t splitEvery
14:58:09 <lambdabot> Int -> [e] -> [[e]]
14:58:35 <DanBurton> @undefine
14:58:50 <crl> @undefine splitIn
15:00:15 <crl> > let splitX n x = chunksOf (length x `div` n) x in splitX [1..15]
15:00:17 <lambdabot>   can't find file: L.hs
15:00:27 <DanBurton> o_O
15:00:43 <DanBurton> did I bork the lambdabot
15:01:00 <hpc> lambdabot borks itself every so often
15:01:07 <crl> > let splitX n x = chunksOf (length x `div` n) x in splitX 3 [1..15]
15:01:09 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15]]
15:01:19 <crl> no that was me
15:01:25 <hpc> ah
15:01:55 <DanBurton> @botsnack
15:01:55 <lambdabot> :)
15:01:58 <crl> splitEvery, chunk, chunksOf
15:03:21 <crl> > splitPlaces [5,5,5] [1..16]
15:03:23 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15]]
15:03:56 <DanBurton> @hoogle splitPlaces
15:03:56 <lambdabot> No results found
15:06:10 <crl> > split (condense $ endsWithOneOf ", ") "foo bar,quux"
15:06:12 <lambdabot>   Ambiguous occurrence `split'
15:06:12 <lambdabot>  It could refer to either `System.Random.split...
15:06:31 <crl> > Data.List.Split.split (condense $ endsWithOneOf ", ") "foo bar,quux"
15:06:32 <lambdabot>   ["foo ","bar,","quux"]
15:06:49 <crl> it's like regex..
15:07:14 <crl> would be good to elimite the match though ^ " " or ","
15:08:59 <connelly> I have a really stupid newbie question that has been baffling me - I have a Word64, how do I get 4 Word8's out of it? do I have to map shiftR across it? is there something simpler/built-in?
15:09:17 <crl> > Data.List.Split.split (condense . dropDelims $ oneOf " ,") "foo bar,quux"
15:09:19 <lambdabot>   ["foo","bar","quux"]
15:10:56 <crl> > length $ subsequences [1..10]
15:10:58 <lambdabot>   1024
15:11:43 <croikle> connelly: seems like there could be a lens into those sub-words. I implemented one myself, but it may be already done in the depths of lens
15:16:22 <hpc> crl: something with zipWith can give you a nice way of not having to write that crap out 8 times
15:16:35 <hpc> and zipping with [0, 4, ..]
15:16:47 <hpc> er, 0, 8, ..
15:21:40 * DanBurton is puzzling. 4 * 8 = 32 /= 64 :P
15:21:47 <crl> hpc yes but one of the list had a variable size
15:22:00 <hpc> DanBurton: yeah, i meant 8 shifts of 8
15:22:42 <crl> feel easier to fill this list to size n then zip those 2 n-lists
15:23:14 <hpc> part of me thinks ghc has this operation as a primitive somewhere
15:23:23 <hpc> because it'd be so easy to do in assembly
15:26:41 <crl> > 1:[2]:[[3]]
15:26:43 <lambdabot>   No instance for (GHC.Num.Num [t0])
15:26:43 <lambdabot>    arising from a use of `e_1123'
15:26:43 <lambdabot>  Possi...
15:27:28 <crl> right associatiity
15:27:45 <crl> > [1]:[2]:[[3]]
15:27:47 <lambdabot>   [[1],[2],[3]]
15:34:01 <connelly> so if I do this: let f = \x -> map (\y -> chr $ fromIntegral $ shiftR (fromIntegral x) y .&. 255) [0,8..56]
15:34:24 <connelly> it works if I call: f $ fromIntegral myWord64Var
15:34:36 <crl> > let powserset [] = []; powerset (x:xs) = let f ys r= (ys : (x : ys):r) in [x] : foldr f [] (powerset xs) in powerset [1..3]
15:34:38 <lambdabot>   [[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]*Exception: <interactive>:3:24-104: N...
15:34:45 <crl> @src nonEmptySubsequences
15:34:45 <lambdabot> Source not found. Sorry.
15:35:12 <connelly> but I have to call fromIntegral before passing the word64
15:35:25 <connelly> if I try to annotate it as :: Word64 -> [Char]
15:35:39 <connelly> it says it couldn't match the expected type
15:37:21 <armlesshobo> > foldr (+) 0 [1,2,3,4]
15:37:23 <lambdabot>   10
15:38:45 <connelly> oh.. the :: Word64 -> [Char] was applying the to list at the end of the map, not the whole function
15:39:51 <crl> weird.. I don't get errors on my ghci, but here:
15:39:53 <crl> let powerset []=  [];powerset (x:xs)  =  let f ys r = ys : (x : ys) : r in [x] : foldr f [] (powerset xs) in powerset [1..3]
15:39:59 <crl> > let powerset []=  [];powerset (x:xs)  =  let f ys r = ys : (x : ys) : r in [x] : foldr f [] (powerset xs) in powerset [1..3]
15:40:00 <lambdabot>   [[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
15:40:17 <crl> nvm
15:41:36 <crl> missing outer brackers at 00:34
15:41:38 * hackagebot ez-couch 0.6.2 - A high level static library for working with CouchDB  http://hackage.haskell.org/package/ez-couch-0.6.2 (NikitaVolkov)
15:42:57 <crl> weird that let f ys r= (ys : (x : ys):r) in  ...is different from let f ys r = ys : (x : ys) : r in
15:45:10 <crl> > ([]) /= []
15:45:11 <lambdabot>   False
15:45:17 <crl> > ([]) == []
15:45:19 <lambdabot>   True
15:45:50 <crl> > let powserset [] = []; powerset (x:xs) = let f ys r= (ys : (x : ys):r) in [x] : foldr  f [] (powerset xs) in powerset [1..4] -- mysterious
15:45:52 <lambdabot>   [[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,3,4...
15:45:58 <crl> > let powserset [] = []; powerset (x:xs) = let f ys r= (ys : (x : ys):r) in [x] : foldr  f [] (powerset xs) in powerset [1..2] -- mysterious
15:46:00 <lambdabot>   [[1],[2],[1,2]*Exception: <interactive>:3:24-105: Non-exhaustive patterns i...
15:46:18 <basho> What does xs mean instead of x in a function definition?
15:46:20 <basho> anything?
15:49:42 <crl> plural of x
15:53:12 <gwern> @quote quit
15:53:12 <lambdabot> TuringTest says: They got it work in Haskell without understanding Haskell.  It is quite an achievement, of some description.
15:54:01 <geekosaur> basho, it's a convention, <something>s implies a list of <something>
15:54:07 <geekosaur> and x is just a generic list item
15:54:33 <Cale> (he's gone)
16:22:32 <bitonic> mhm.  I seem to be incapable of using those pretty printing libraries.  is there a tutorial on how to use ‘pretty’ or ‘wl-pprint’?  for example, when I have an application ‘A (\x => B) C’, I want the pretty printer to break the line if needed but not in the lambda
16:22:46 <samm> damn microsoft for placing a BOM when saving utf8 file. they have to screw everything up
16:23:43 <bitonic> if I just place soft breaks with wl-pprint, it breaks them up where I don’t want to
16:23:55 <bitonic> so maybe I should just ‘size’ the terms and decide manually?
16:25:00 <DuelShark> hi - could anyone help me with some hints on this, http://pastebin.com/AufLFprN I am writing a program to play noughts and crosses, the part I'm stuck on is this - the bottom code is mine underneath the double ----- lines, I am going to change my "state" code so that it currently has 9 noughts, and each time the player uses "move" it'll change for e.g if they use move 2 Cross it'll change the
16:25:01 <DuelShark> second element in the list with cross. Is this possible in Haskell, to somehow store it in memory? so it can be re-called with updates value, all help appreciated
16:25:40 <DuelShark> (the part I'm stuck on is how to change a list element while called and each time it's re-called return the new values)
16:26:33 <Frostix> Hey guys, what does the error "Parse Error: Naked expression at top level." mean?
16:27:07 <geekosaur> Frostix, what it sounds like. instead of something like "foo = x + 5" you have "x + 5"
16:27:14 <geekosaur> this may mean you have an indentation proble
16:27:15 <geekosaur> m
16:27:23 <Frostix> Hi again geekosaur :D
16:27:29 <Frostix> Would you like to see my code?
16:27:53 <geekosaur> sure
16:28:03 <geekosaur> btw did you ever work out what was going on with the list?
16:28:28 <Frostix> Oh, the tutorial I was following was doing it wrong
16:28:36 <Frostix> So I tried a different method and it worked
16:28:38 <hpaste> Frostix pasted “FizzBuzz” at http://hpaste.org/83618
16:29:08 <Frostix> also the top line should be Int -> Int -> String
16:29:14 <gynna> http://www.reddit.com/r/AdultDating18/comments/19t7e6/sexi_and_thick_snow_bunny_atlantaga_airport/
16:29:29 <geekosaur> so what were you expecting that semicolon to do?
16:29:40 <Frostix> continue the if statement?
16:29:47 <Frostix> Dunno if that's right
16:29:53 <geekosaur> haskell does not have statements, it has expressions
16:29:55 <Cale> Frostix: The if expression is inside the list comprehension
16:30:05 <geekosaur> do blocks have things that look like statements but turn into expressions
16:30:23 <Cale> (the lines of a do block are actually called statements)
16:31:10 <Frostix> So the if should be on the outside?
16:31:32 <geekosaur> also a list comprehension produces a list, so String is the wrong result type for that; it'd be [String] after you sort out what the second thing is supposed to be
16:32:21 <geekosaur> > [if x `mod` 5 == 0 then "Fizz" else "Not divisible by 5" | x <- xs ]
16:32:23 <lambdabot>   Not in scope: `xs'
16:32:24 <lambdabot>  Perhaps you meant one of these:
16:32:24 <lambdabot>    `x' (imported from D...
16:32:43 <geekosaur> > let xs = [1..10] in [if x `mod` 5 == 0 then "Fizz" else "Not divisible by 5" | x <- xs ]
16:32:45 <lambdabot>   ["Not divisible by 5","Not divisible by 5","Not divisible by 5","Not divisi...
16:33:11 <Frostix> What about 3 and 5 and 3?
16:33:34 <geekosaur> what abotu them? does the above look anything like what you were expecting for a function returning String?
16:34:05 <geekosaur> also, what is the a supposed to be for in your type, when there is no matching parameter?
16:34:36 <Frostix> I meant that to be Int (the a). Also whats the diff between String and [String]
16:34:55 <Sgeo> String is a String, [String] is a list of Strings
16:35:32 <geekosaur> so you're not passing two Ints, you're pasisng one [Int]
16:35:44 <Frostix> Ok
16:35:44 <geekosaur> hhave you taken a look at LYAH yet?
16:35:53 <Frostix> No
16:36:05 <Frostix> Wait yes
16:36:11 <Frostix> That's what I'm following
16:36:17 <Frostix> Learn you a haskell
16:41:56 <samm> is there some global setting that will prevent exception being thrown if terminal's encoding cannot display printed character? I would prefer if every 20th character looked like garbage over exception crashing my program
16:42:44 <Cale> Well, what is it that you're printing that's causing exceptions? That's kind of strange.
16:45:12 <Cale> samm: You could hSetBinaryMode stdout True to turn off text encoding and newline translation.
16:45:36 <samm> putStrLn "č" for example throws <stdout>: commitBuffer: invalid argument (invalid character)
16:45:41 <Cale> Or you could just  hSetEncoding stdout char8  to turn off the text encoding part, but keep newline translation.
16:45:56 <Cale> samm: hmmm
16:47:40 <roconnor_> what do you guys think:  error vs exitFailure  for aborting a program with a shell error value
16:47:57 <Cale> samm: What if you do  hSetEncoding stdout utf8  ?
16:48:01 <monochrom> exitFailure
16:48:22 <ski> @hoogle exitFailure
16:48:22 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
16:48:22 <lambdabot> System.Exit exitFailure :: IO a
16:48:25 <Cale> samm: That'll force it to use UTF8 instead of whatever your locale says the encoding is.
16:48:54 <roconnor_> monochrom: any particular reason.
16:49:00 <samm> Cale this is on window's cmd.exe, which is crap and doesnt support utf8. still, I would prefer garbahe being printed every now and then, over exception
16:49:25 <monochrom> it is the one specified for shell error value, and it actually lets you choose that value
16:49:40 <samm> while still printing proper characters on other systems that support utf8
16:50:05 <geekosaur> that should be pretty much what you get if you set the utf8 encoding explicitly
16:50:05 <monochrom> windows's cmd.exe supports utf-8, just not default. chcp 65001
16:50:33 <Cale> (Or I've heard maybe just setting a unicode font is enough?)
16:51:17 <monochrom> also, code page is only half of the battle. font is the other half. all windows fixed width fonts are incomplete. some characters may not be displayed, but you get the right characters
16:51:20 <roconnor_> monochrom: exitFailure doesn't pick a specific shell error.
16:51:58 <monochrom> am I going to read all of System.Exit's haddock for you?
16:52:00 <roconnor_> On the flip side, is there any problem with using error as an IO value?
16:52:10 <samm> monochrom: I think there are some issues even with that? anyway my I *still* would like to prevent exceptions for this. imagine if you are performing a long computation, and then fail to see a result because of this (something similar just happened to me)
16:52:14 <ski> @type System.Exit.exitWith
16:52:15 <lambdabot> GHC.IO.Exception.ExitCode -> IO a
16:52:31 <geekosaur> you want exitWith (ExitFailure num), not exitFailure
16:52:43 <monochrom> exitWith (ExitFailure 4)
16:52:49 <Cale> samm: Then you could do one of the things I suggested earlier
16:52:52 <roconnor_> I had some vague recollection of obtuse security problems that may happen by using error, but I fear I was just making them up in my head.
16:52:59 <geekosaur> monochrom, the confusion is that there is ao an exitFailure function
16:53:23 <geekosaur> which uses an "implementation-dependent" exit code
16:53:25 <samm> Cale: wouldnt that prevent unicodr characters from being printed in all cases?
16:53:31 <roconnor_> monochrom: I don't want to use exitWith; lest I end up doing exitWith (ExitFailure 0) which will not fail.
16:53:45 <samm> even if system supports utf8, or if encoding was properly set
16:53:48 <Cale> samm: It'll truncate everything to 8 bits
16:53:48 <roconnor_> whatever exitFailure is, I'm sure it isn't 0.
16:54:01 <roconnor_> anyhow, perhaps I'm just bikesheeding
16:54:15 <monochrom> I don't understand. so use 4, don't use 0.
16:54:15 <geekosaur> In particular, some values may be prohibited (e.g. 0 on a POSIX-compliant system).
16:54:20 <roconnor_> I was more worried about what error :: IO a means.
16:54:33 <geekosaur> it means the same thing it means for any other tyoe
16:54:35 <geekosaur> *type
16:54:40 <samm> I would prefer it just tried to print it, and then ignored if terminal cant display that character
16:54:40 <monochrom> although, 1 is more popular than 4
16:54:49 <roconnor_> geekosaur: does that mean exitWith (ExitFailure 0) will fail on a POSIX system (and hence return non-zero?)
16:54:54 <Cale> samm: You could also just set the encoding to utf8 which will give an exception if you try to print invalid utf8 characters (there aren't many of these)
16:55:10 <Cale> But will produce proper UTF8 output unless you're doing something dumb.
16:55:29 <roconnor_> geekosaur: that means that error "foo" :: IO a means the same as an infinite loop
16:55:33 <geekosaur> host136:180157 Z$ ghc -e 'System.Exit.exitWith (System.Exit.ExitFailure 0)'
16:55:34 <geekosaur> <interactive>: exitWith: invalid argument (ExitFailure 0)
16:55:49 <roconnor_> *l*
16:55:51 <geekosaur> so it turns into the equivalent of ```error```
16:56:10 <Cale> > putStrLn ['\55296']
16:56:11 * roconnor_ wants to see the source
16:56:11 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
16:56:11 <lambdabot>    arising from a use of ...
16:56:12 <geekosaur> in any case you're getting a nonzero exit code
16:56:14 <roconnor_> @src exitWith
16:56:15 <lambdabot> Source not found. You speak an infinite deal of nothing
16:56:18 <Cale> > text ['\55296']
16:56:19 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (invalid character)
16:56:26 <Cale> kekeke
16:56:28 <geekosaur> (I got exit 1 from the shell, fwiw)
16:56:52 <roconnor_> geekosaur: nope, it uses ioError, which is different from error
16:57:27 <geekosaur> "the equivalent of" I am aware it's not exactly the same exception, but it is an exception
16:57:53 <geekosaur> just as ```error "whatever" :: IO a``` is going to be an exception just as ```error "whatever" :: Int``` is
16:58:17 <geekosaur> I do not understand your infinite loop comment, are you intepreting bottom in reverse?
16:58:31 <geekosaur> (an inifinite loop is one kind of bottom. that does not mean all bottoms are infinite loops)
16:58:58 <samm> with hSetEncoding stdout utf8, and chcp set to 65001, I get an empty space in between every line. wtf.
16:59:47 <Cale> Perhaps the newline mode?
17:00:05 <samm> chcp 65001 is the culprit
17:00:06 <Cale> samm: Now, on Linux or other systems using GNU iconv, there's a way to construct a UTF-8 text encoding which ignores errors, by executing mkTextEncoding "UTF-8//IGNORE"
17:00:13 <Cale> hSetEncoding stdout =<< mkTextEncoding "UTF-8//IGNORE"
17:00:20 <Cale> but I'm pretty sure that won't work on Windows
17:01:28 <Cale> samm: What happens if you put it in UTF-8 mode and then just set the terminal's font to something with Unicode characters in it?
17:01:57 <roconnor_> I wonder if there is some way to use laziness or seq or something to make code using error "foo" :: IO a do unexpected things.
17:02:18 <geekosaur> no, only way I can think of is a very poorly written catch
17:03:27 <ski> roconnor_ : such as `seq (undefined >>= return :: IO ()) ()' vs. `seq (undefined :: IO ()) ()' ?
17:03:30 <samm> what I just said, characters are displayed properly but I get extra newline when outputing \n
17:03:40 <geekosaur> well, I suppose you could write something which has a list containing error whatever but doesn't evaluate the list items, but why would you be using a list of IO something and ignoring its values?
17:03:54 <elliott> roconnor_: about as much as you can with Reader?
17:04:02 <elliott> (in GHC)
17:04:26 <roconnor_> ski: ya
17:04:28 <roconnor_> Prelude> ioError (userError "foo") `seq` print "bar"
17:04:28 <geekosaur> the worse that happens in that case is that thee xception isn't thrown. but the same thing happens if said list contains a call to exitWith / exitSuccess / exitFailure because you're ignoring the value fo the IO action...
17:04:30 <roconnor_> "bar"
17:04:31 <roconnor_> Prelude> ioError (userError "foo")
17:04:33 <roconnor_> *** Exception: user error (foo)
17:04:34 <samm> with chcp set to 852 all is well, but then program can potentially crash if I end up printing non-supported character
17:04:36 <roconnor_> oops
17:04:42 <roconnor_> Prelude> error "foo" `seq` print "bar"
17:04:44 <roconnor_> *** Exception: foo
17:04:45 <roconnor_> P
17:04:47 <roconnor_> anyhow
17:05:02 <roconnor_> the ioError and error do behave differently in strange situations
17:05:23 <ski> roconnor_ : well, that is expected
17:05:36 <ski> roconnor_ : `error "foo"' errors out when evaluated
17:05:54 <ski> roconnor_ : `ioError (userError "foo")' only errors out when *executed*
17:06:00 <geekosaur> I feel like you are very carefully looking for differences in how the GHC runtime works. I suggest, in that case, that you go read the code for the GHC runtime as it's the only way to answer uyour questions at the level of detail you are insisting on
17:06:12 <roconnor_> indeed
17:06:21 <ski> roconnor_ : also try `evaluate (error "foo")'
17:06:40 <roconnor_> @hoogle evaluate
17:06:41 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
17:06:41 <lambdabot> Control.Exception evaluate :: a -> IO a
17:06:41 <lambdabot> Control.OldException evaluate :: a -> IO a
17:06:53 <geekosaur> and I do not understand why you are worried about ExitFailure not doing the right thing if fed 0. are you trying to invoke it with random values for some reason?
17:06:59 <ski> hm, or perhaps `evaluate =<< error "foo"' ?
17:07:13 <monochrom> I don't understand this excursion into error
17:07:23 <ski> @type (Control.Exception.evaluate =<<)
17:07:24 <lambdabot> IO b -> IO b
17:07:26 <geekosaur> or are you just building the weirdest possible hypothetical? in which case I can probably dig you up some broken use of catch that will give you a program that won't ever terminate even with exceptions
17:08:23 <crl> @pl (<<=)
17:08:23 <lambdabot> (<<=)
17:08:26 <Cale> samm: Also, I'm seeing something about Windows Powershell 2.0 dealing with UTF-8 better?
17:08:48 <samm> I will give it a try
17:09:00 <monochrom> error is way more underspecified, in way more aspects, than exitWith (ExitFailure 1), or even exitFailure
17:09:21 <geekosaur> I can tell you with certainty that there is some way to defeat any possible way the code might exit. if you are looking to avoid that at all costs, then you want a non-Turing-complete language
17:09:24 <geekosaur> sorry
17:09:27 <roconnor_> geekosaur: I'm not so worried about ExitFailure.  I just don't like unecessary assumptions in code.  with exitFailure it knows internally how to provoke a failure without me having to know what is and is not a Posix failure.  Even if every system in Posix, it is still good design to avoid implicit dependencies
17:10:02 <monochrom> ok, then use exitFailure, supposedly it knows to choose the right value
17:10:04 <geekosaur> but you then wanted to specify an exit code, and then worried that it wouldn't do the right thing with 0...
17:11:12 <monochrom> if you worry about 0, don't use 0
17:11:16 <roconnor_> ah, no I don't want to specify an exit code
17:11:20 <crl> @src (<<=)
17:11:20 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:11:21 <roconnor_> I just want it to fail.
17:11:27 <monochrom> then exitFailure
17:14:18 <samm> this is unrelated to haskell btw, I am getting extea newline in other languages as well when encoding is set to utf8. I will try a more appropriate channel
17:15:19 <tsinnema> hey -- what does $ do, seen in various spots in this file?: https://github.com/ekmett/machines/blob/master/src/Data/Machine/Plan.hs
17:15:37 <samm> @src ($)
17:15:38 <lambdabot> f $ x = f x
17:15:52 <roconnor_> tsinnema: it's a low precidence application operator
17:16:15 <tsinnema> thanks!
17:16:30 <samm> basically f (a b c) is the same as f $ a b c
17:16:41 <monochrom> example. sin $ x + 1 = sin (x + 1). therefore, mind operator precedence, it is non-obvious
17:16:50 <tsinnema> got it, cheers!
17:17:10 <crl> @src (>>=)
17:17:10 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:17:20 <elliott> yikes, trying to understand CPS'd edwardk code before knowing ($)
17:17:23 <crl> > yes
17:17:25 <lambdabot>   Not in scope: `yes'
17:17:25 <elliott> my sympathies
17:17:30 <tsinnema> hehe
17:17:34 <geekosaur> crl, it's different for every monad
17:17:43 <geekosaur> @src [] (>>=)
17:17:43 <lambdabot> xs >>= f     = concatMap f xs
17:17:44 <crl> of course
17:17:54 <geekosaur> @src Maybe (>>=)
17:17:55 <lambdabot> (Just x) >>= k      = k x
17:17:55 <lambdabot> Nothing  >>= _      = Nothing
17:18:11 <crl> > @src [] (<<=)
17:18:12 <lambdabot>   <hint>:1:1: parse error on input `@'
17:18:19 <crl> @src [] (<<=)
17:18:19 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:18:26 <geekosaur> @src (=<<)
17:18:27 <lambdabot> f =<< x = x >>= f
17:18:39 <geekosaur> that one is not a typeclass-specific definition
17:18:39 <crl> @src (<<=) []
17:18:39 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
17:18:49 <geekosaur> and <<= is not a standard operator
17:20:50 <crl> @src (=<<) []
17:20:50 <lambdabot> Source not found. Do you think like you type?
17:21:24 <simpson> crl: It's defined in terms of (>>=).
17:21:26 <ski> `(=<<)' is not a type class method
17:21:47 <geekosaur> crl, I did it a couple minutes ago, read scrollback please
17:22:28 <geekosaur> (=<<) doesn't need to be a method of Monad, it can be defined in terms of (>>=) for all monads and there is no benefit to providing a per-monad definition
17:23:01 <crl> it exists for IO at least
17:23:14 <ski> no
17:23:24 <ski> there is one single definition of it, for *any* monad
17:23:33 <simpson> :t \f x -> x >>= f
17:23:34 <lambdabot> Monad m => (a -> m b) -> m a -> m b
17:23:47 <simpson> crl: ^^ That definition works for all Monads.
17:24:24 <geekosaur> crl, repeating myself about 5 minutes ago
17:24:29 <geekosaur> @src (=<<)
17:24:29 <lambdabot> f =<< x = x >>= f
17:24:59 <geekosaur> there is nothing monad specific about this definition, it lets (>>=) do the monad specific part and there is no reason to provide a separate one per monad
17:25:52 <crl> sorry i can't type correctly like length lenght ;)
17:26:11 <geekosaur> why do you feel there needs to be a specific definition of it for IO?
17:26:30 <geekosaur> or for lists?
17:28:47 <crl> > \x -> return x =<< Just 3
17:28:48 <lambdabot>   No instance for (GHC.Show.Show
17:28:48 <lambdabot>                     (Data.Maybe.Maybe b0 -> ...
17:29:03 <simpson> :t \x -> return x =<< Just 3
17:29:04 <sipa> > (\x -> return x) =<< Just 3
17:29:04 <lambdabot> Maybe b -> Maybe b
17:29:06 <lambdabot>   Just 3
17:29:25 <crl> damn precedence
17:29:34 <Sgeo> (\x -> return x) is the same as return
17:29:35 <simpson> > return =<< Just 3 -- Do you understand why *this* is equivalent?
17:29:36 <Sgeo> Kind of
17:29:37 <lambdabot>   Just 3
17:30:02 <crl> Sgeo: don't takeme for a  ;)
17:30:23 <crl> joking
17:30:40 <Sgeo> There can be a subtle difference between f and (\x -> f x) I think
17:30:46 <Sgeo> When f is a function
17:30:58 <crl> hmm
17:30:58 <simpson> Sgeo: There's a difference in strictness.
17:31:25 <crl> :t return
17:31:26 <lambdabot> Monad m => a -> m a
17:32:20 <crl> @pl (\x -> f x)
17:32:20 <lambdabot> f
17:33:32 <crl> @pl (\~x -> f x)
17:33:32 <lambdabot> (line 1, column 3):
17:33:33 <lambdabot> unexpected "~"
17:33:33 <lambdabot> expecting pattern
17:34:14 <ByteEater> hello! do you know a concise way to define a function partitioning a list with a tumbling window?
17:34:17 <ByteEater> by that I mean a function f :: (a -> Bool) -> [a] -> [[a]] uniquely defined by the following conditions: concat (f p l) == l and if l /= [] then tail (map head (f p l)) == filter p (tail l)
17:34:17 <geekosaur>  @pl doesn't parse full patterns (and doesn't really grok laziness)
17:35:55 <ByteEater> or, in prose: each element satisfying the predicate p should start a new list
17:35:59 <crl> that's normal, when this is just lazyness (in runtime)
17:37:08 <crl> ByteEater: in Data.List.Split maybe
17:38:04 <byorgey> > split . keepDelimsL . whenElt (==0) $ [1,2,0,3,0,0,4,5,6,0,7]    -- ByteEater, like this?
17:38:06 <lambdabot>   Ambiguous occurrence `split'
17:38:06 <lambdabot>  It could refer to either `System.Random.split...
17:38:19 <byorgey> arch
17:38:25 <byorgey> > Data.List.Split.split . keepDelimsL . whenElt (==0) $ [1,2,0,3,0,0,4,5,6,0,7]
17:38:27 <lambdabot>   Couldn't match expected type `t0 -> t1'
17:38:27 <lambdabot>              with actual type `Data...
17:38:59 <byorgey> > (Data.List.Split.split . keepDelimsL $ whenElt (==0)) $ [1,2,0,3,0,0,4,5,6,0,7]
17:39:01 <lambdabot>   [[1,2],[0,3],[0],[0,4,5,6],[0,7]]
17:39:06 <byorgey> there we go
17:39:41 <ByteEater> thanks
17:40:03 <crl> > (Data.List.Split.split . dropDelims $ whenElt (==0)) $ [1,2,0,3,0,0,4,5,6,0,7]
17:40:04 <ByteEater> looking at the module, isn't splitOn' actually the same?
17:40:05 <lambdabot>   [[1,2],[3],[],[4,5,6],[7]]
17:43:26 <crl> > (Data.List.Split.split . condense . dropDelims $ oneOf [0]) $ [1,2,0,3,0,0,4,5,6,0,7]
17:43:28 <lambdabot>   [[1,2],[3],[4,5,6],[7]]
17:44:26 <ByteEater> my mistake, it's not in the module actually, but the page http://www.haskell.org/haskellwiki/Data.List.Split which has splitOn' defined in the first snippet
17:44:38 <simpson> Hey, does anybody know whether sigfpe's heuristic list monad (http://blog.sigfpe.com/2009/07/monad-for-combinatorial-search-with.html) is on Hackage somewhere?
17:44:43 <ByteEater> anyway, thx a lot, problem solved
17:44:48 <crl> > (Data.List.Split.split . condense . dropDelims $ oneOf "aeiouy") $ "haskell"
17:44:50 <lambdabot>   ["h","sk","ll"]
17:45:09 <crl> > concat $ (Data.List.Split.split . condense . dropDelims $ oneOf "aeiouy") $ "haskell"
17:45:11 <lambdabot>   "hskll"
17:45:52 <simpson> > filter (not $ oneOf "aeiou") "haskell"
17:45:53 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
17:45:54 <lambdabot>              with actual type...
17:45:59 <simpson> Oh, derp.
17:46:29 <simpson> > filter (\c -> not $ c `elem` "aeiou") "haskell"
17:46:31 <lambdabot>   "hskll"
17:47:21 <crl> yep concat . split  ~~ filter
17:47:23 <jonkri> i would like a program that, for a given haskell project, will return a list of functions and the possible exceptions and errors that they can produce (`error' calls, io exceptions, Either e a, etc). is there something like this?
17:47:47 <fryguybob> Is there a name for amortizing snoc with  newtype Blah a = Blah ([a],[a]); fromList = Blah . (,[]); toList (Blah (hs,ts)) = hs ++ reverse ts; cons a = first (a:); snoc = second (a:) ?
17:48:21 <elliott> fryguybob: that looks like a list zipper
17:48:23 <fryguybob> I'm missing an fmap on snoc and cons there.
17:48:42 <fryguybob> elliott: Humm yes.
17:51:17 <crl> > filter (not . (flip elem) "aeiou") "haskell"
17:51:19 <lambdabot>   "hskll"
17:51:40 * crl not abuse point-free
17:51:43 <YayMe> > "hskll"
17:51:45 <lambdabot>   "hskll"
17:51:47 <YayMe> mine's shorter
17:53:23 <fryguybob> I seem to recall the queue version of that having a name.
17:54:16 <jonkri> what is the simplest way to create an IOException? also, i'm a little confused about the difference between ioexceptions and ioerror
17:54:22 <YayMe> Isn't that just okasaki's queue?
17:55:44 <elliott> crl:
17:55:46 <c_wraith> crl: you don't even need that inner set of parens
17:55:49 <elliott> > filter (`notElem` "aeiou") "haskell"
17:55:51 <lambdabot>   "hskll"
17:55:53 <jonkri> i guess `userError' would be suitable
17:56:32 <sproingie> > userError "Let me tell you how much I've come to hate you since I first began to live"
17:56:34 <lambdabot>   user error (Let me tell you how much I've come to hate you since I first be...
17:57:10 <sproingie> IOError is the type, IOException is the constructor
17:57:42 <Mortchek> Is there a special term for when you "unfurl" a type to remove the recursion from it? For example, for Nat = Zero | Succ Nat, you get UnfurledNat a = Zero | Succ a (isomorphic to Maybe a)
17:59:54 * sproingie coins "decursion"
18:02:51 <crl> > (intercalate " " . map (\(w:ws) -> w:(map toLower ws)) . words) "FOR READING   CAPS LIKERS "
18:02:53 <lambdabot>   "For Reading Caps Likers"
18:03:19 <crl> hmm, thats doesn't respect spaces
18:03:38 <danharaj> that would be the fault of `words`
18:03:42 <crl> i could just map without wording
18:03:49 <crl> indeed
18:04:01 <geekosaur> you might be interested in break or span for that
18:05:23 <arkeet> :t _tail
18:05:25 <lambdabot> Cons (->) f s s a a => LensLike' f s s
18:05:31 <arkeet> :t intercalated
18:05:33 <lambdabot>     Not in scope: `intercalated'
18:05:33 <lambdabot>     Perhaps you meant one of these:
18:05:33 <lambdabot>       `intercalate' (imported from Data.List),
18:05:35 <arkeet> no surprise.
18:05:36 <crl> > toLower ' '
18:05:38 <lambdabot>   ' '
18:05:53 <arkeet> btw, intercalate " " = unwords
18:06:05 <crl> right
18:06:19 <arkeet> :t iso
18:06:21 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
18:07:11 <arkeet> @let _words = iso words unwords
18:07:22 <lambdabot>  Defined.
18:07:44 <arkeet> > "HELLO WORLD" & _words . traverse . _tail . traverse %~ toLower
18:07:48 <lambdabot>   "Hello World"
18:08:04 <crl> > "HELLO      WORLD" & _words . traverse . _tail . traverse %~ toLower
18:08:06 <lambdabot>   "Hello World"
18:08:22 <arkeet> wait.
18:08:27 <arkeet> why is uh.
18:08:51 <arkeet> @let eachWord = _words . traverse
18:08:53 <lambdabot>  Defined.
18:09:30 <arkeet> actually uh.
18:09:38 <arkeet> we can do better.
18:10:43 <tac> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Rational
18:10:49 <tac> Is Ratio declared in Prelude?
18:11:01 <tac> The docs say it is.... but it doesn't look like it gets exported
18:11:16 <applicative_> its in Data.Ratio though
18:11:24 <arkeet> Rational is, Ratio isn't.  I think.
18:11:26 <tac> yeah
18:11:32 <arkeet> > split (oneOf ".") "a..b"
18:11:34 <lambdabot>   Ambiguous occurrence `split'
18:11:34 <lambdabot>  It could refer to either `System.Random.split...
18:11:39 <tac> I don't understand how Haddock works.....
18:11:41 <arkeet> > Data.List.Split.split (oneOf ".") "a..b"
18:11:43 <lambdabot>   ["a",".","",".","b"]
18:11:47 <arkeet> oh good.
18:12:19 <arkeet> > Data.List.Split.split (oneOf ".") "a.b."
18:12:21 <lambdabot>   ["a",".","b",".",""]
18:12:28 <arkeet> > Data.List.Split.split (dropDelims $ oneOf ".") "a.b."
18:12:30 <lambdabot>   ["a","b",""]
18:12:34 <ByteEater> one more question: what's an elegant way to change a function's value for just one argument (e.g. factorial but 37 instead of 120 for 5)? :: (a -> b) -> a -> b -> (a -> b)?
18:12:41 <applicative_> Wait, Rational is in the Prelude, though
18:13:14 <applicative_> tac: and its a synonym for Ratio Integer; that is kind of silly
18:13:23 <ByteEater> or, more generally (changing a finite number of points): (a -> b) -> [(a, b)] -> (a -> b)
18:13:31 <applicative_> ah thats what you linked
18:13:54 <tac> applicative_: ahhh. I didn't realize it was a type synonym :/
18:14:31 <applicative_> foo f pairs a = case lookup a pairs of Just b -> b ; Nothing -> f a
18:15:15 <arkeet> @let _splitOn x = iso (splitOn x) (intercalate x)
18:15:17 <lambdabot>  Defined.
18:15:58 <arkeet> > "HELLO    WORLD ! " & _splitOn " " . traverse . _tail . traverse %~ toLower
18:16:01 <lambdabot>   "Hello    World ! "
18:16:04 <ByteEater> applicative_, thanks
18:16:50 <arkeet> _splitOn isn't really a valid iso
18:18:12 <arkeet> ByteEater: more generally, (a -> b) -> (a -> Maybe b) -> (a -> b)
18:18:31 <arkeet> which comes from b -> Maybe b -> b
18:18:33 <arkeet> so...
18:18:37 <arkeet> :t liftA2 fromMaybe
18:18:39 <lambdabot> Applicative f => f c -> f (Maybe c) -> f c
18:18:49 <arkeet> :t liftA2 fromMaybe `asAppliedTo` (undefined :: a -> b)
18:18:51 <lambdabot> (a -> c) -> (a -> Maybe c) -> a -> c
18:18:53 <arkeet> :)
18:19:12 <arkeet> @let fact n = product [1..n]
18:19:14 <lambdabot>  Defined.
18:19:32 <ByteEater> arkeet, nice
18:19:53 <arkeet> > let foo = liftA2 fromMaybe fact (\n -> guard (n == 5) >> Just 37) in [foo 3, foo 5]
18:19:54 <ByteEater> but what I had in mind was having the values
18:19:56 <lambdabot>   [6,37]
18:20:47 <arkeet> ByteEater: your [(a,b)] can be turned into (a -> Maybe b) using lookup
18:20:52 <ByteEater> for one value I could use const c with your solution, for a list of pairs I'd need lookup anyway
18:20:58 <crl> > (concat . map (\(w:ws)->w:(map toLower ws)) . Data.List.Split.split (keepDelimsR $ oneOf " ")) "CAPLOCKS    = BAD"
18:20:59 <arkeet> > let foo = liftA2 fromMaybe fact (lookup [(5,37)]) in [foo 3, foo 5]
18:21:01 <lambdabot>   "Caplocks    = Bad"
18:21:01 <lambdabot>   Occurs check: cannot construct the infinite type:
18:21:02 <lambdabot>    b0 = [([(t0, t1)], b0)]
18:21:05 <arkeet> :t lookup
18:21:07 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
18:21:09 <arkeet> > let foo = liftA2 fromMaybe fact (`lookup` [(5,37)]) in [foo 3, foo 5]
18:21:13 <lambdabot>   [6,37]
18:21:17 <ByteEater> great, that combines into a nice toolkit
18:21:18 <arkeet> how about that?
18:21:23 <ByteEater> :-)
18:21:24 <arkeet> :)
18:21:42 <arkeet> :t maybe
18:21:44 <lambdabot> b -> (a -> b) -> Maybe a -> b
18:21:55 <arkeet> uh huh
18:22:51 <crl> > "hmm" & _tail
18:22:53 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
18:22:53 <lambdabot>              with actual ty...
18:23:00 <arkeet> > "hmm" ^. _tail
18:23:02 <lambdabot>   "mm"
18:23:07 <arkeet> > "" ^. _tail
18:23:09 <lambdabot>   ""
18:23:10 <arkeet> I knew it.
18:23:17 <arkeet> > "hmm" ^? _tail
18:23:20 <lambdabot>   Just "mm"
18:23:20 <arkeet> > "" ^? _tail
18:23:21 <ByteEater> :t asAppliedTo
18:23:23 <lambdabot> (t -> b) -> t -> t -> b
18:23:23 <lambdabot>   Nothing
18:23:38 <arkeet> ByteEater: f `asAppliedTo` x is just f, except with a more restrictive type.
18:24:28 <crl> @src iso
18:24:28 <lambdabot> Source not found. Just what do you think you're doing Dave?
18:24:30 <arkeet> it's mostly useless in real code, but handy for :t
18:24:34 <arkeet> @where src
18:24:34 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
18:25:09 <ByteEater> arkeet, where is it defined?
18:25:19 <arkeet> it's a lambdabot thing.
18:25:22 <arkeet> @where l.hs
18:25:23 <lambdabot> What lambdabot has in scope is at <http://code.haskell.org/lambdabot/State/L.hs>
18:25:29 <crl> yep
18:25:32 <ByteEater> :t liftA2 fromMaybe (undefined :: a -> b)
18:25:33 <lambdabot> (a -> Maybe c) -> a -> c
18:25:36 <samm> what was that emacs mode called that makes haskell code prettier? actual lambda character instead of \, etc
18:25:59 <ByteEater> :t liftA2 (fromMaybe (undefined :: a -> b))
18:26:01 <lambdabot> Applicative f => f (Maybe (b -> c)) -> f b -> f c
18:27:03 <applicative_> > map (fromMaybe <$> even <*> (lookup ?? [(11,True)])) [2..12]
18:27:05 <lambdabot>   [True,False,True,False,True,False,True,False,True,True,True]
18:27:34 <arkeet> lol
18:28:22 <ByteEater> :t (??)
18:28:24 <lambdabot> Functor f => f (a -> b) -> a -> f b
18:28:31 <crl> to sum up lens: (f.g.h) x = x ^. _g ^? _f ^% _h
18:28:47 <crl> :d
18:28:54 <arkeet> .. no :p
18:29:08 <arkeet> > [1,2,3] ^. _tail -- doesn't work
18:29:10 <lambdabot>   [2,3]
18:29:11 <arkeet> or wait
18:29:13 <arkeet> I'm dumb.
18:29:14 <applicative_> ByteEater: the simple use of ?? is as 'infix flip' , it's awesome for that
18:29:24 <arkeet> :t (??) `asTypeOf` flip
18:29:26 <lambdabot> (a1 -> a -> b) -> a -> a1 -> b
18:30:50 <applicative_> > (foldr ?? 0 ) (+) [1..10]
18:30:53 <lambdabot>   55
18:32:10 <crl> should have read this page at the start  http://www.haskell.org/haskellwiki/Keywords#.3F.3F
18:32:19 <crl> but dfound it just now
18:34:21 <ByteEater> indeed, from the general type I did't realize its high value for the (a ->) functor, but now I see I'll probably be using it often - interesting and useful stuff
18:56:59 <Frostix> Hey guys, can someone assist me with this. I want every number evenly divisible by 3 replaced with Fizz, evenly divisbly by 5 with Buzz, and both with FizzBuzz. Here's my current code- Every number evenly divisible by 3 should be replaced with Fizz Every number evenly divisible by 5 should be replaced with Buzz Every number evenly divisible by 3 and 5 should be replaced by FizzBuzz
18:57:00 <Frostix> Ooops
18:57:07 <Frostix> http://hpaste.org/83622
18:57:29 <crdueck> @hoogle Simple
18:57:30 <lambdabot> package simple-actors
18:57:30 <lambdabot> package simple-atom
18:57:30 <lambdabot> package simple-css
18:58:43 <BrianHV> Frostix: couple of things. first, your function only takes one Int, not two. second, to get a string from an Int you're looking for the show function.
18:59:06 <Frostix> Ok
18:59:26 <BrianHV> also, moding against a list like that isn't going to work...
18:59:26 <Frostix> Well what if I put a range in it for [1..100]?
18:59:41 <Frostix> Should I use an if statement?
19:00:24 <BrianHV> to run the same function over every item in a list, you'll want to use the map function
19:00:44 <Frostix> Ok have not learned that yet, let me see.
19:01:32 <BrianHV> Frostix: http://learnyouahaskell.com/higher-order-functions#maps-and-filters
19:01:43 <Frostix> Yup, looking at that now
19:01:50 * hackagebot hweblib 0.5 - Haskell Web Library  http://hackage.haskell.org/package/hweblib-0.5 (AycanIrican)
19:02:23 <crdueck> would it be possible to effectively use a haskell web framework like snap, yesod, happstack for a non HTML server? Like a server that talks to a database, or performs computations? I'm not very familiar with any of the frameworks unfortunately
19:02:33 <tac> Frostix: In Haskell, you rarely want to use "if" statements
19:02:40 <Frostix> Why is that
19:02:47 <tac> Frostix: you typically use pattern matching or guards instead
19:02:51 <Frostix> Ok
19:03:50 <ParahSail1n> guards are if statements
19:04:11 <tac> they fill a similar role, but morally, they are different
19:04:23 <ParahSail1n> they desugar to if in core
19:04:25 <crl> was reading http://www.haskell.org/haskellwiki/GADT, it seems to be missings stuff in the page, like 'parse' not defined for Terms..
19:04:29 <Frostix> Can I do something like * map (`mod` [5,3]) * ? Also how do I make it check for both 5 and 3
19:04:48 <tac> @let nToFizzBuzz n | n % 5 == 0 && n % 3 == 0; "FizzBuzz"; n % 5 == 0 = "Buzz"; n % 3 == 0 = "Fizz" in map nToFizzBuzz [1..20]
19:04:48 <lambdabot>   Parse error: ;
19:04:52 <BrianHV> Frostix: you might be able to use something like "all" to achieve what you want
19:05:11 <tac> @let nToFizzBuzz n | n % 5 == 0 && n % 3 == 0 = "FizzBuzz" | n % 5 == 0 = "Buzz" | n % 3 == 0 = "Fizz" in map nToFizzBuzz [1..20]
19:05:11 <lambdabot>   Parse error: in
19:05:12 <BrianHV> (is that the name of the function I'm thinking of?...)
19:05:14 <tac> damn
19:05:29 <BrianHV> yes. http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:all
19:06:10 <ParahSail1n>  @let {nToFizzBuzz n | n % 5 == 0 && n % 3 == 0 = "FizzBuzz"; | n % 5 == 0 = "Buzz"; | n % 3 == 0 = "Fizz"}  in map nToFizzBuzz [1..20]
19:06:14 <ParahSail1n> @let {nToFizzBuzz n | n % 5 == 0 && n % 3 == 0 = "FizzBuzz"; | n % 5 == 0 = "Buzz"; | n % 3 == 0 = "Fizz"}  in map nToFizzBuzz [1..20]
19:06:15 <lambdabot>   Parse error: |
19:06:30 <BMeph> tac: "%" is NOT the 'droid you're looking for. ;þ
19:06:35 <ParahSail1n> @let nToFizzBuzz n {| n % 5 == 0 && n % 3 == 0 = "FizzBuzz"; | n % 5 == 0 = "Buzz"; | n % 3 == 0 = "Fizz"}  in map nToFizzBuzz [1..20]
19:06:35 <lambdabot>   Parse error: |
19:06:41 <Sgeo> Does Write Yourself A Scheme in 48 Hours use Parsrc, or does it teach you how to build your own Parsec-like thing?
19:06:58 <Sgeo> Oh, it uses Parsec. How boring.
19:07:19 <Frostix> ParahSailin, Why use % instead of `mod`
19:07:21 <tac> @let nToFizzBuzz n | n `mod` 5 == 0 && n `mod` 3 == 0 = "FizzBuzz" | n `mod` 5 == 0 = "Buzz" | n `mod` 3 == 0 = "Fizz" | otherwise = show n
19:07:22 <lambdabot>  <local>:7:1:
19:07:22 <lambdabot>      Warning: Pattern match(es) are overlapped
19:07:22 <lambdabot>               In...
19:07:41 <tac> > map nToFizzBuzz [1..20]
19:07:43 <lambdabot>   ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","1...
19:07:43 <crl> anyone here understood this page http://www.haskell.org/haskellwiki/GADT?
19:08:19 <tac> crl: GADTs are fairly well-understood by haskellers
19:08:37 <crl> i don't understant from 'parse "K" = K
19:09:18 <crl> tac: i've a far notion of them for the momet
19:09:34 <tac> ah, yeah
19:09:54 <tac> This example isn't very clear, but it's mentioned about how you have to use an existential quantification in order to make that function typecheck
19:09:57 * BMeph wonders if any Pythonista Haskelliers have defined: "m %% n = (n *) . snd . properFraction $ m % n" ;þ
19:10:10 <tac> (existentials are pretty poorly handled in Haskell, sadly :(   )
19:10:22 <Frostix> Thank you tac, learned from that
19:10:43 <Frostix> Why did you use n, could you use any variable?
19:10:43 <tac> Frostix: (Just took me a few times to produce some actual working code :P )
19:10:54 <tac> no real reason
19:11:27 <Frostix> I didn't know you could use the && , I thought that was only for booleans. Does that mean I can use || as well regarding integers?
19:11:48 <tac> && is only for bools there
19:12:04 <fxr> crdueck: what do you want specifically?
19:12:09 <tac> you parse it as.... (n `mod` 5 == 0) && (n `mod` 3 == 0)
19:12:23 <Sgeo> I understand what using monadic parsing looks like, but what does applicative parsing look like?
19:12:30 <Frostix> Ok
19:12:32 <tac> crl: Did you figure out the parse thingy yet?
19:12:40 <crdueck> fxr: I want to serve streaming data, exploiting haskell's lazyness
19:12:46 <crdueck> fxr: from a database
19:12:52 <crl> tac: no...
19:13:09 <crl> @src parse
19:13:09 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:13:25 <tac> The example doesn't really show you how to define parse, but you can imagine how it might be defined
19:13:34 <tac> Think about the type of parse
19:13:44 <tac> (or rather, what we would WANT the type to be)
19:13:54 <bss03> Hoogle is failing me.  Is there a name for the function of type Monad m => m (a -> b) -> a -> m b?
19:14:23 <crl> tac: should return either K S or Term..
19:14:36 <fxr> crdueck: lazyness & IO don't seem to fit very well
19:14:37 <crl> should returns a Term sorry
19:14:45 <crdueck> fxr: I plan on using io-streams or pipes
19:15:09 <bss03> \x -> ap x . return being the function.
19:15:14 <tac> crl: Almost there :)
19:15:21 <roconnor_> @pl \x -> ap x . return
19:15:22 <lambdabot> (. return) . ap
19:15:29 <tac> crl: Term has kind * -> *... it's a type constructor
19:15:33 <tac> so we need Term *something*
19:16:06 <tac> Like Term Int     or     Term (a -> b)     or something like that, right?
19:16:13 <crl> Term a, Term (a->b) ..
19:16:28 <tac> What is the type of K?
19:16:32 <roconnor_> bss03: I'm not aware of one
19:16:35 <crl> yes right
19:16:36 <bss03> Maybe it has a more general type?  Like Traversable t, Monad m => m t b -> t m b?
19:16:46 <roconnor_> hmm
19:16:54 <roconnor_> @type sequenceA
19:16:55 <lambdabot>     Not in scope: `sequenceA'
19:16:55 <lambdabot>     Perhaps you meant one of these:
19:16:55 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
19:17:00 <crl> Term (a -> b -> a)
19:17:03 <tac> right
19:17:09 <tac> What about the type of S?
19:17:15 <roconnor_> @type Data.Traversable.sequence
19:17:17 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
19:17:22 <crl> S :: Term ((a -> b -> c)  -> (a -> b) -> a -> c)
19:17:25 <tac> yup
19:17:30 <tac> Do those have the same type?
19:17:31 <roconnor_> that seems backwards
19:17:34 <bss03> That's the first thing I thought of, but I think it goes the wrong direction.
19:17:39 <crl> no
19:17:47 <tac> That's correct. They have different types.
19:17:51 <tac> And that is the crux of the problem
19:18:13 <tac> If x is a string, what is the type of parse x ?
19:18:13 <crl> you can't parse them based on strings so
19:18:42 <crl> Term String
19:18:53 <tac> err, not quite :)
19:19:06 <tac> By the definition, parse x is either equal to K or it is equal to S (or it's undefined)
19:19:23 <crl> but parse isn't defined
19:19:32 <BMeph> bss03: It's not the wrong direction, it's just more general. :)
19:19:36 <tac> the definition is given in those two lines of code
19:19:46 <tac> (but it doesn't give the type annotation for it)
19:19:47 <crl> o
19:19:54 <crl> k i'm dumb
19:19:59 <bss03> BMeph: Really?
19:20:03 <crl> so
19:20:04 <tac> no, no. It's just unfamiliar
19:20:14 <tac> Plus, there's a trick here
19:20:26 <crl> If x is a string, what is the type of parse x ? K or S
19:20:44 <tac> The type has to be the same as either K or S... but it depends on x
19:20:54 <tac> Since it can't be two types, you can't write it in ordinary haskell
19:20:59 <crl> but they have different types like said
19:20:59 <tac> You need a tool called an existential type
19:21:02 <BMeph> bss03: I'm pretty sure that all Monads are Traversible, but I could be wrong - I am a lot, after all. ;þ
19:21:20 <crl> tac: makes sense
19:21:26 <tac> in this case, the type *ought* to be String -> exists s. Term s
19:21:26 <roconnor_> BMeph: I'm fairly confident that Cont is not Traversable.
19:21:44 <tac> Where "exists s. Term s" means "Term s for *some* type s which we don't know yet"
19:21:48 <roconnor_> BMeph: Every Traversable Functor is (isomorphic to) a finitary container
19:21:50 <bss03> > Data.Traversable.sequence (return id) 2 :: Idenity Int
19:21:52 <lambdabot>   Not in scope: type constructor or class `Idenity'
19:21:52 <lambdabot>  Perhaps you meant `Ident...
19:21:56 <bss03> > Data.Traversable.sequence (return id) 2 :: Identity Int
19:21:58 <lambdabot>   No instance for (GHC.Show.Show
19:21:58 <lambdabot>                     (Data.Functor.Identity.I...
19:22:00 <elliott> BMeph: Reader isn't traversable
19:22:11 <tac> (and the reason we don't know it yet is because it's determined at runtime, not compile time)
19:22:11 <roconnor_> elliott: a much simpler example
19:22:18 <elliott> can't do Applicative f => (r -> f a) -> f (r -> a)
19:22:33 <elliott> (consider f = IO for a concrete example)
19:22:56 <crl> tac: ok good explanation
19:23:21 <tac> crl: when you write a polymorphic type in Haskell, you're really using universal quantification
19:23:23 <bss03> elliott: I'm trying to go the other way though.  From IO (r -> a) -> r -> IO a
19:23:25 <tac> @type length
19:23:27 <lambdabot> [a] -> Int
19:23:30 <tac> means
19:23:34 <tac> forall a. [a] -> Int
19:23:52 <magicman> elliott: http://winterkoninkje.dreamwidth.org/81209.html (related)
19:23:52 <BMeph> elliott, roconnor_: I sit corrected.  Any simple counter-examples for the converse?
19:23:52 <tac> Existential quantification is the "dual" to universal quantification
19:23:58 <elliott> bss03: that's wanting IO to be Traversable, no?
19:24:15 <elliott> BMeph: (Const e) is Traversable not Monad
19:24:23 <crl> tac: parse after can be defined with generalization
19:24:31 <bss03> Well, neither of my Monads has to be IO...
19:24:48 <crl> parse (Term a) = ...
19:24:49 <roconnor_> BMeph: traversable that isn't a Monad?
19:24:56 <bss03> And, I can write f :: IO (r -> a) -> r -> IO a simply enough, I just thought it might already have a name.
19:25:11 <elliott> magicman: right
19:25:12 <applicative_> >  Data.Traversable.sequence [even,odd, (<2)] 3
19:25:12 <bss03> \x -> ap x . return
19:25:13 <magicman> "Reader a" is traversable when "a" is finite (okay, only slightly related)
19:25:13 <lambdabot>   [False,True,False]
19:25:18 <bss03> > @ty \x -> ap x . return
19:25:20 <BMeph> roconnor_: Yes. elliott: Fair enough, thanks! :)
19:25:21 <lambdabot>   <hint>:1:1: parse error on input `@'
19:25:23 <crl> tac: (using GADT)
19:25:26 <bss03> @ty \x -> ap x . return
19:25:27 <lambdabot> Monad m => m (a -> b) -> a -> m b
19:25:29 <roconnor_> BMeph: I think data Foo a = Foo a | Bar a a should work
19:25:34 <magicman> (but that's one of my favourite posts of the last few months, and I was just reminded of it :P)
19:25:43 <roconnor_> BMeph: Foo is traversable
19:25:55 <roconnor_> I don't *think* it is a monad.
19:26:14 <tac> crl: Yeah. What you can do with polymorphism is often doable with existential types and vice versa
19:26:25 <tac> So Haskell typically prefers using polymorphism
19:26:26 <BMeph> roconnor_: elliott already gave me Const a, but thanks. :)
19:26:34 <roconnor_> :)
19:26:37 <elliott> Const a is considerably more boring from a Traversable perspective though :P
19:27:07 <BMeph> roconnor_: (Technically, (Const e), but blah-blsh, alpha-sub, yadda-yadda.)
19:29:01 <roconnor_> BMeph: anyhow, a traversable is a finitary container
19:29:51 <crl> tac: isn't that possible to create a more global type data AnyTerm = K | S | ..
19:30:16 <crl> o well that was the first parageaph
19:30:22 <tac> data AnyTerm = forall s. Term s
19:30:29 <tac> is how you would usually define it, I believe
19:30:35 <tac> err rather
19:30:44 <tac> data AnyTerm = forall s. AnyTerm (Term s)
19:30:52 <tac> (I think is the syntax....)
19:31:34 <crl> yep the s information  is finer
19:32:15 <crl> which is a type
19:32:41 <tac> the definition of AnyTerm basically "hides" some of the information from the compiler
19:32:53 <tac> Which is useful in this case because it's information that's not available at compile time
19:35:30 <crl> Term x y, would be still a 'type constructor' or a constructor of type constructor :~
19:36:07 <tac> Term :: * -> *, so Term x y doesn't make any sense, really
19:36:13 <tac> Term takes one type argument at most
19:36:20 <crl> I mean Foo x y
19:36:24 <tac> ah
19:36:27 <crl> another data
19:36:34 <crl> Either a b
19:36:49 <tac> What is the question then? :)
19:36:56 <crl> @kind Either Int
19:36:57 <lambdabot> * -> *
19:37:12 <crl> the denomination of Either
19:37:31 <BMeph> Presbyterian! ;þ
19:37:40 <tac> :k Either
19:37:42 <lambdabot> * -> * -> *
19:37:43 <crl> ;)
19:38:09 <tac> bbaib
19:38:10 <crl> :k Either a Int
19:38:11 <lambdabot> Not in scope: type variable `a'
19:38:25 <tac> if a :: *, then Either a Int :: *, too
19:38:47 <crl> :k Either * Int
19:38:48 <lambdabot> parse error on input `*'
19:39:06 <crl> yes of course
19:41:07 <crl> well if you call it typeS constructor it should take all levels of kind
19:43:22 <crl> ok thx it's more clear
19:44:14 <bss03> Does lambdabot still run djinn?
19:45:29 <BMeph> bss03: Ask l-bot. ;)
19:45:54 <bss03> BMeph: It was rejecting my @djinn commands, but I figured it out, thanks.
19:54:33 <vamega> pl (not ((flip elem) [1,2,3]))
19:54:47 <vamega> @pl (not ((flip elem) [1,2,3]))
19:54:47 <lambdabot> not (flip elem [1, 2, 3])
19:55:19 <lispy> @pl \x -> not (flip elem x)
19:55:20 <lambdabot> not . flip elem
20:24:57 <JoeyA> > let headMaybe = foldr (const . Just) Nothing in (headMaybe [], headMaybe [1], headMaybe [1,2])
20:24:59 <lambdabot>   (Nothing,Just 1,Just 1)
20:25:59 <JoeyA> Meh, there's already listToMaybe.
20:34:01 <Sgeo> :t listToMaybe
20:34:03 <lambdabot> [a] -> Maybe a
20:34:55 <Bike> In ghci, is there a way I can make infinite lists stop printing after some number of elements?
20:35:13 <tac> Bike: control-C
20:35:20 <tac> or don't try to print infinite lists
20:35:26 <tac> > take 10 [1..]
20:35:28 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
20:35:33 <Bike> So no way to set up a cutoff?
20:35:37 <Cale> take
20:35:45 <Bike> I mean, just for printing.
20:35:56 <tac> not really, no
20:35:57 <JoeyA> > [1..]
20:35:59 <samm> no way to do it automatically afaik
20:35:59 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:36:04 <Bike> OK, thanks.
20:38:59 <Cale> Perhaps it would be interesting to allow setting a given function to process the String being printed.
20:39:01 <20WAB2P4B> I'm hazarding a guess that the "take" function would probably help
20:39:17 <20WAB2P4B> But I know nothing, sooo
20:39:22 <Cale> (which would also allow for pretty printing and such)
20:39:23 <Sgeo> Maybe replace stdout with a fake stdout that does cutoffs?
20:39:34 <Cale> Nah, you'd do it before that
20:39:42 <Bike> Yes, I was just wondering if there was some simple configuration thing. I'm used to it from other systems but it's no big deal of course.
20:39:43 <Cale> ghci already applies show to things
20:40:05 <Bike> Sgeo: I think you'd just have to redefine show to take 50 on lists or something?
20:40:50 <Cale> You'd just need a way to insert an arbitrary String -> String function to process the result of show
20:41:22 <Bike> i'm just learning, not as far as worrying about other lazy types yet, i guess.
20:45:50 <pharaun> *sigh* i keep on forgetting about lazyness :)
20:46:09 <pharaun> just implemented a dumb breath-first thingie the hard way when i could have just had the lazyness take care of it for me
21:02:00 * hackagebot hArduino 0.5 - Control your Arduino board from Haskell.  http://hackage.haskell.org/package/hArduino-0.5 (LeventErkok)
21:04:21 <Cale> pharaun: Laziness has a way of turning breadth-first into depth-first, usually.
21:04:44 <pharaun> Cale: yeah in this case i do need breadth first tho :) doing an tree search so i want to abort early
21:05:21 <pharaun> just forgot that i could lazy generate a list via breadth-first function that converts the tree into a list
21:05:25 <pharaun> and then exit when i found what i need
21:05:26 <Cale> right
21:28:36 <Hrumph> hi i can't get the new yesod-platform (1.1.8) to install. i just get cabal: could not resolve dependencies: trying: yesod-platform-1.1.8  trying: yesod-1.1.9.2
21:28:44 <Sifr> Hi, haskellmode-vim the defacto plugin for vim development?
21:28:54 <Sifr> developing in vim*
21:33:24 <mzero> yesod-platform looks like something to only be installed via cabal-dev or cabal with sandboxes
21:33:38 <johnw> why do you say that?
21:33:52 <mzero> it forces specific versions of other packages that you probably already have other versions of
21:34:00 <pharaun> good ol' yesod
21:34:01 <mzero> seems like certain to induce dependency issues
21:34:26 <pharaun> i didn't bother with yesod platform, i just dragged in all of the packages i could that corresponded to yesod-platform
21:34:30 <pharaun> so i could let the version wander a bit
21:34:41 <pharaun> but yeah sandbox/cabal-dev is probably better
21:35:17 <berr> hello
21:37:22 <cmears> hello berr
21:52:06 <applicative_> hello berr
21:54:47 <johnw> mzero: "yesod-platform provides a stable, tested set of packages which are known to compile together and interact well. If you're looking for stability and don't mind using libraries that are one to two months old, it's highly recommended. If you want to be using more recent libraries, then just install the yesod package directly instead."
21:55:18 <mzero> yes - that is how I came to my conclusion
21:55:47 <mzero> because if you have a set of packages that you have installed, and then want to "check out yesod" - then yesod-platform isn't going to work too well
21:55:57 <mzero> unless you install it cabal-dev style
21:56:11 <johnw> to just check it out, definitely use cabal-dev
21:56:34 <johnw> i run it with cabal-dev on my Mac, or I move aside my .cabal and .ghc and have a completely separate set of installed binaries for yesod
21:58:11 <pharaun> how does cabal-dev works out for folks?
21:58:16 <pharaun> i've been pondering checking it out
21:58:24 <johnw> i love it
21:58:32 <johnw> but sadly, hdevtools doesn't care for it much
21:58:38 <johnw> and fay doesn't like it
21:59:03 <johnw> i mainly use cabal-dev for producing binaries that I copy to ~/bin
21:59:09 <johnw> like git-annex
22:00:27 <lispy> johnw: if you use --prefix=$HOME/.cabal/ (double check that) then cabal-dev will even copy it there for you.
22:00:43 <johnw> oh, cool!
22:00:48 <lispy> johnw: plus, if the author of the package use the Path_foo modules then they will even point to a path that works if you blow away the sandbox
22:01:44 <lispy> I've never checked on all the repurcusions of using --prefix, but for the simple things I've done it with I had 0 problems
22:01:52 <lispy> (Im not sure where things build if you use --prefix)
22:02:11 <pharaun> nice
22:08:30 <johnw> lispy: how's things?
22:19:26 <lispy> not bad but wishing that C/C++ had a proper module system
22:19:33 <johnw> hehe
22:19:51 <johnw> I was in the subcommittee that discussed that at the last Standards meeting
22:19:58 <johnw> we ALL want that
22:20:20 * lispy spent longer than he wants to admit playing with ways to infer what .o files to use for each binary in a directory of .cc files
22:22:07 <lispy> I've probably spent more time trying to automagically calculate the dependencies than I would have spent manually fixing them when they were wrong.
22:24:42 <ivanm> since when did haddock start ignoring the "Description" header in modules?
22:28:34 <pharaun> heh
22:28:56 <pharaun> lispy: thankfully i've avoided... most of that but still, so easy of a trap to fall into
22:34:41 <Ralith> lispy: the 'tup' build system is pretty neat, as far as magic C build systems go
22:35:00 <Ralith> the author seems to be pretty bad at solving the DSL/scripting problem though
22:35:24 <lispy> I need to use make for this task due to othre constraints
22:35:40 <johnw> wow, yet another build system
22:35:43 <johnw> the wonders never cease
22:36:02 <lispy> Not sure what historical mistake to repeat? Write your own build system!
22:36:07 <cmears> You should use Shake
22:36:56 <johnw> i personally use cmake+ninja for non-Haskell projects, and Cabal for Haskell.  I'm interested in Shake (because it's Haskell), and I've mentioned to Neil the possibility of using CMake to generate something I can feed to Shake to start out with
22:36:57 <Hrumph> yesod install probolem solved
22:37:05 * hackagebot antigate 0.4.0.2 - Haskell interface for antigate.com captcha recognition service and services supporting its API  http://hackage.haskell.org/package/antigate-0.4.0.2 (MikhailKuddah)
22:37:07 * hackagebot antigate 0.4.0.3 - Haskell interface for antigate.com captcha recognition service and services supporting its API  http://hackage.haskell.org/package/antigate-0.4.0.3 (MikhailKuddah)
22:37:09 <Hrumph> i needed to install the seperate "ghc" fedora package
22:37:13 <ivanm> did Dave Roundy's build system ever actually get used by anyone?
22:37:25 <johnw> ivanm: which one was that?
22:37:40 <ivanm> @google dave roundy haskell build system
22:37:42 <lambdabot> http://blog.interlinked.org/tutorials/darcs.html
22:37:42 <lambdabot> Title: Darcs - IMHO
22:37:47 <ivanm> yeah, that's not it
22:37:50 <lispy> ivanm: franchise
22:37:54 <ivanm> that's the one
22:38:27 <ivanm> well, someone tried building it on Arch in 2010 :p
22:39:00 <Heffalump> anyone else, you mean?
22:39:02 <johnw> we should just go whole hog, and suggest to every new programmer that they implement a complete build system as their first task
22:39:14 <ivanm> Heffalump: yeah
22:39:15 <johnw> fight fire with fire
22:39:21 <ivanm> johnw: and a Monad tutorial!
22:39:27 <johnw> well, of course
22:39:31 <johnw> it would be a Build System Monad
22:40:14 <ivanm> huh, according to his github account, droundy now uses go
22:40:14 <lispy> and then you're required to write a tutorial about build system monads
22:40:31 <johnw> i just don't see the point of go
22:40:46 <ivanm> johnw: it's shiny and by google!
22:40:49 <johnw> i guess it's an alternative to D
22:41:16 <ivanm> for some reason I was busy looking for a ":" just before the "D" :p
22:41:27 <johnw> haha
22:41:37 <johnw> i think D could be an interesting replacement for C++, if it had wider acceptance
22:42:00 <johnw> some of the C++ people I know that went to Haskell went through D first
22:42:14 <johnw> but i've never met anyone who has done anything with go
22:45:14 <ivanm> so out of curiousity I just tried googling for "go vs haskell"; one of the top results was a blog post where the only mention of Haskell was in the tags which were basically SEO: "google go comparison with Haskell" (even though the actual post is comparing to C++)
22:46:20 <augur> any good videos lately?
22:47:09 <pharaun> golang does not seem all that interesting
22:47:18 <pharaun> but it does have some nice properties by default i suppose
23:08:51 <berr> when something says " let xs = [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)]" why is it xs instead of x?
23:09:30 <cmears> it's plural
23:09:32 <ivanm> berr: because there's more than one, so make it plural!
23:09:33 <Heffalump> there's a convention of suffixing variable names with 's' to indicate a list
23:09:42 <berr> ah I thought so thanks
23:09:51 <ivanm> this is more obvious when you do (x:xs)
23:22:06 * hackagebot lojbanXiragan 0.1 - lojban to xiragan  http://hackage.haskell.org/package/lojbanXiragan-0.1 (YoshikuniJujo)
23:36:46 <otters> crap there's no Ixed instance for [(a, b)]
23:38:10 <ivanm> otters: how would you define it?
23:38:22 <otters> similar to the instance for Map
23:38:26 <ivanm> and what would you want it for? an Array with multiple dimensions?
23:38:32 <ivanm> wait, there's an Ix instance for Map? :o
23:38:35 <otters> yeah
23:38:36 <otters> Ixed
23:38:36 <ivanm> @instances Ix
23:38:38 <otters> not Ix
23:38:39 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
23:39:01 <ivanm> oh, right :)
23:39:52 <ivanm> what does "~ * a b" mean in the Ixed constraints?
23:39:55 <otters> dunno
23:39:57 <ivanm> *Ixed instance constraints
23:40:42 <ivanm> there's an [a] instance; my guess is that any [(a,b)] instance would cause OverlappingInstance issues
23:40:44 <ivanm> so, newtype it?
23:41:10 <otters> or I could just do this update without lens
23:41:28 <edwardk> ivanm: thats haddock's braindead way of rendering a ~ b
23:41:34 <ivanm> edwardk: yeah, just got that
23:41:50 <ivanm> edwardk: so, you cheated with those instances by making GHC think it's for (a,b) when it's really for (a,a)?
23:42:02 <otters> i have a list of type [(a, [b])] and a' :: a and b' :: b
23:42:06 * hackagebot lojbanXiragan 0.3 - lojban to xiragan  http://hackage.haskell.org/package/lojbanXiragan-0.3 (YoshikuniJujo)
23:42:13 <otters> and if the list has the index a', prepend b' to the associated list
23:42:20 <otters> if not, create that index and make b' the sole member of the list
23:42:43 <edwardk> ivanm: not quite. the reason for the constraints is so that ghc can find the simpler type (a, b, c)  which it'll unify with quite easily, and then user the type family constraint to refine that type to (a, a, a)
23:43:18 <edwardk> if i'd made the instances for (a, a, a)   the compiler would have to know that type matched _exactly_ before it'd select the instance in fear you might have some other overlapping instances lying around
23:43:28 <ivanm> hmmmm
23:44:21 <edwardk> otters sounds messy
23:44:21 <edwardk> why is it an assoc list?
23:44:29 <edwardk> rather than say a Map a [b] ?
23:44:33 <otters> that's a good question heh
23:44:38 <otters> refactor!
23:45:15 <edwardk> :t anon
23:45:17 <lambdabot> (Functor f, Profunctor p) => a -> (a -> Bool) -> p a (f a) -> p (Maybe a) (f (Maybe a))
23:45:59 <edwardk> then it is "at foo.anon [] null %~ (bar:)"
23:46:26 <edwardk> for index foo and element you want to cons/construct with bar
23:47:54 <otters> what the--
23:48:01 <otters> how do you get a list of values from a Map a b
23:48:21 <edwardk> :t Data.Foldable.toList
23:48:23 <lambdabot> Foldable t => t a -> [a]
23:48:26 <edwardk> :t Data.Map.toList
23:48:27 <lambdabot> M.Map k a -> [(k, a)]
23:48:34 <edwardk> either works, depending on if you also need keys
23:48:40 <edwardk> :t itoList
23:48:41 <lambdabot> FoldableWithIndex i f => f a -> [(i, a)]
23:48:51 <edwardk> that works also for Map if you're lensy
23:49:26 <BMeph> edwardk: lensy Lohan? ;þ
23:49:45 <edwardk> thats otterly ridiculous
23:50:38 * BMeph smirks and whispers: "let the otters hit the floor, let the otters hit the floor,..." ;þ
23:51:15 <edwardk> hah
23:52:22 <BMeph> edwardk: Hey, something had to give... 8D
