00:00:40 <adnap> How do I see all functions exported by a module in GHCI?
00:00:54 <arkeet> :browse does something like that.
00:01:50 <adnap> Does GHC have a manpage? I don't have one.
00:03:02 <shachaf> GHC has a man page.
00:03:14 <shachaf> It also has a user's guide.
00:03:19 <shachaf> ghci has :help
00:03:19 <adnap> I use Gentoo and I compiled GHC with the doc USE flag.
00:05:05 <Pods> Any GSOC mentors here ??
00:05:17 <supki> adnap: #gentoo-haskell might know how to get manpages for ghc on gentoo
00:13:28 <liyang> ghci is so vimist. :<
00:14:03 <liyang> C-x C-c does nothing. D:
00:14:21 <shachaf> The default keybindings are pretty emacsy.
00:14:30 <shachaf> Except they're a cheap plastic imitation of readline.
00:17:45 * hackagebot bytestring-handle 0.1.0.1 - ByteString-backed Handles  http://hackage.haskell.org/package/bytestring-handle-0.1.0.1 (GaneshSittampalam)
00:21:36 <adnap> So... often when I reading haskell, I mentally specialize the type of a function (e.g. a -> a to Int -> Int). Can some program help me do this?
00:39:54 <bitonic> adnap: replace the type variables with what you need, making sure that the types you are replacing with respect the constraints
00:42:31 <pqmodn> @type: id `asAppliedTo` "hello"
00:42:33 <lambdabot> [Char] -> [Char]
00:42:34 <pqmodn> adnap: ^^
00:43:28 <shachaf> The type Int -> Int communicates much less information than the type a -> Int
00:44:53 <adnap> pqmodn:
00:44:55 <adnap> Thanks
00:45:52 <adnap> pqmodn: How do I do that in ghci?
00:48:40 * Pods waiting for ping
00:52:02 <pqmodn> adnap: let as :: (t -> b) -> t -> t -> b; as f t _ = f t
00:52:18 <pqmodn> adnap: :type id `as` "foo"
00:54:31 <adnap> It works, but I don't understand it
00:55:14 <adnap> as :: (a -> a) -> String -> String -> a ...
00:55:22 <pqmodn> adnap: the key is the type signature, which says the second and third argument are the same `t` type.
00:55:40 <pqmodn> adnap: no, as :: (String -> b) -> String -> String -> b
00:56:26 <adnap> type of first argument, id, is a -> a
00:57:10 <pqmodn> `as` works like this: give me an f :: t -> b, then an actual concrete type (well, maybe). now i can pin down the type variable for f.
00:58:27 <pqmodn> right, so t = a, b = a, initially (eg, as id :: a -> a -> a). but when you pass a second argument, (as id "hi") it can infer t must be String. so as id "hi" :: String -> String
00:58:51 <adnap> I see
00:59:13 <adnap> I don't understand the implementation though: "as f t _ = f t"
00:59:19 <pqmodn> it's not too far off from ($) really. except it requires an extra argument (_)
00:59:23 <pqmodn> @type ($)
00:59:25 <lambdabot> (a -> b) -> a -> b
00:59:43 <pqmodn> see how `as` just requires another `a`?
00:59:54 <pqmodn> it's the _ argument which we don't actually use
01:00:09 <pqmodn> the reason it's required is:
01:00:10 <adnap> Is it the first argument to the new function?
01:00:16 <pqmodn> @type ($) id "hi"
01:00:17 <lambdabot> [Char]
01:00:22 <pqmodn> that only gives the return type
01:00:46 <pqmodn> because ($) f t = f t
01:01:03 <adnap> Argh
01:01:26 <pqmodn> as f t _ = f t -- we require another argument, so as id "hi" :: String -> String, but ($) id "hi" :: String
01:02:02 <adnap> Oh, so
01:02:07 <adnap> the "hi" is a throwaway
01:02:09 <pqmodn> yes
01:02:17 <adnap> But it specifies the type of t
01:02:21 <pqmodn> yup
01:02:45 <pqmodn> actually "hi" isn't thrown away, but you have the general idea
01:02:46 * hackagebot Etage 0.1.11 - A general data-flow framework  http://hackage.haskell.org/package/Etage-0.1.11 (MitarMilutinovic)
01:02:58 <pqmodn> > let f t _ = f t in f "hi" "bai"
01:03:00 <lambdabot>   Occurs check: cannot construct the infinite type: t1 = t0 -> t1
01:03:04 <pqmodn> > let f t _ = f t in f id "hi" "bai"
01:03:06 <lambdabot>   Occurs check: cannot construct the infinite type: t1 = t0 -> t1
01:04:13 <pqmodn> eh, it's late:
01:04:18 <Cale> http://www.youtube.com/watch?v=HrIfZrDe788 -- Etagen, a marble-flow... network?
01:04:19 <pqmodn> > let as f t _ = f t in as id "hi" "bai"
01:04:21 <lambdabot>   "hi"
01:05:16 <adnap> Oh! I was staring at "as" for a while
01:05:41 <adnap> I realized it does compute something, but we just use its definition to get its type signature when applied to a function and type
01:05:53 <adnap> I forgot this all started with ":t as ..."
01:06:13 <pqmodn> adnap: sorry, probably a poorly chosen name
01:06:32 <adnap> pqmodn: Is there a function like this already in Prelude or somewhere else?
01:06:37 <adnap> I guess I could put it in .ghci
01:06:42 <pqmodn> i'm not sure, but probably not.
01:07:20 <adnap> Hm...
01:07:26 <adnap> > let x = "hi"; :t x
01:07:28 <lambdabot>   <hint>:1:15: parse error on input `:'
01:07:32 <adnap> > let x = "hi" in :t x
01:07:34 <lambdabot>   <hint>:1:17: parse error on input `:'
01:07:46 * hackagebot Etage-Graph 0.1.7 - Data-flow based graph algorithms  http://hackage.haskell.org/package/Etage-Graph-0.1.7 (MitarMilutinovic)
01:07:47 <pqmodn> you can bind at the top level in ghci with just "let". let x = "hi"
01:07:52 <pqmodn> then on the next command, :t x
01:09:07 <adnap> Hm...
01:09:11 <pqmodn> also, you might see if you squint at "as f t _ = f t" something that looks like const. in fact, as = (.) const :: (t -> b) -> t -> t -> b
01:09:24 <adnap> It doesn't seem like "as" generalizes to functions with more arguments
01:09:35 <adnap> I tried "foldl' `as` (2 :: Int)
01:10:04 <pqmodn> no, but you can. :t (\f xs -> foldl f (2 :: Int) xs)
01:10:50 <adnap> :t id "hi"
01:10:51 <lambdabot> [Char]
01:11:01 <pqmodn> or flip foldl `as` (2 :: Int) if you like
01:11:50 <adnap> :t (\f xs -> foldl f (2 :: Int) xs)
01:11:51 <lambdabot> (Int -> b -> Int) -> [b] -> Int
01:11:56 <adnap> :t foldl
01:11:57 <lambdabot> (a -> b -> a) -> a -> [b] -> a
01:12:20 <adnap> So, this makes the initial a argument go away
01:12:22 <pqmodn> oops, you need two flips, but chances are that ^^ above, using (\arg arg -> ...) will be generally easier to remember and use anyway
01:12:58 <pqmodn> ah, :t (\f -> foldl `as` (2 :: Int))
01:13:10 <pqmodn> sorry, foldl f `as` (2 :: Int)
01:13:24 <pqmodn> @type (\f -> foldl f (2 :: Int))
01:13:25 <lambdabot> (Int -> b -> Int) -> [b] -> Int
01:13:29 <pqmodn> @type (\f -> foldl f `asAppliedTo` (2 :: Int))
01:13:30 <lambdabot> (Int -> b -> Int) -> Int -> [b] -> Int
01:13:45 <adnap> Where is "asAppliedTo"?
01:13:52 <adnap> @hoogle asAppliedto
01:13:53 <lambdabot> No results found
01:13:59 <pqmodn> @type (\f init -> foldl f init `asAppliedTo` "hi")
01:14:00 <lambdabot> (b -> Char -> b) -> b -> [Char] -> b
01:14:03 <bitonic> adnap: asAppliedTo f _ = f
01:14:40 <bitonic> > let foo _ f = f in id `foo` 42
01:14:42 <lambdabot>   42
01:14:46 <bitonic> @ty let foo _ f = f in id `foo` 42
01:14:47 <lambdabot> Num t => t
01:14:53 <bitonic> @ty let foo _ f = f in id `foo` (42 :: Int)
01:14:55 <lambdabot> Int
01:15:02 <bitonic> @ty let foo f _ = f in id `foo` (42 :: Int)
01:15:03 <lambdabot> a -> a
01:15:07 <bitonic> oh.
01:15:10 <bitonic> ah.
01:15:16 <adnap> This is so confusing
01:15:25 <pqmodn> f = (.) const :: (t -> b) -> b -> b -> t
01:15:27 <bitonic> @ty let foo f x = let _ = f x in f in id `foo` (42 :: Int)
01:15:28 <lambdabot> Int -> Int
01:15:43 <bitonic> so, ‚ÄòasAppliedTo f x = let _ = f x in f‚Äô.
01:15:46 * bitonic didn‚Äôt sleep much
01:16:08 <pqmodn> adnap: is it as late there as it is here?
01:16:16 <bitonic> @localtime adnap
01:16:16 <lambdabot> Local time for adnap is Wed Mar 27 03:14:44 2013
01:16:22 <adnap> That's correct
01:16:29 <bitonic> lambdabot knows.
01:17:27 <pqmodn> adnap: so the moral is, if you want to specialize the n+1th argument, :t (\one two .. nth -> f one two .. nth `asAppliedTo` ..)
01:18:08 <adnap> pqmodn: What if I just want to specify some argument m, where 1 <= m <= n?
01:18:11 <pqmodn> put this in your .ghci: let asAppliedTo = (.) const :: (t -> b) -> t -> t -> b
01:18:50 <pqmodn> you mean you want to check the type of some function if the m-th argument has type t?
01:18:56 <adnap> pqmodn: Yeah
01:19:05 <bitonic> adnap: I think it would be useful to understand how ‚ÄòasAppliedTo‚Äô works
01:19:12 <adnap> bitonic: I'm really trying
01:19:23 <adnap> It's not clicking
01:19:48 <bitonic> adnap: are you looking at my definition?  because ‚Äò(.) const‚Äô is pretty obscure
01:19:58 <adnap> bitonic: No
01:20:07 <bitonic> adnap: ‚ÄòasAppliedTo f x = let _ = f x in f‚Äô
01:20:29 <pqmodn> oh, that's what i meant above. for instance to infer by specializing the first argument: foldl `asAppliedTo` (+). second argument: (\op -> foldl op `asAppliedTo` (0 :: Int)), third argument: (\op init -> foldl op init "list")
01:20:49 <pqmodn> sorry, third argument: (\op init -> foldl op init `asAppliedTo` "list")
01:21:10 <bitonic> adnap: so, asApplied to gets some function ‚Äòa -> b‚Äô.  ‚Äòa‚Äô and ‚Äòb‚Äô are type variables, they can be substituted with any type.
01:21:20 <adnap> Yeah
01:21:25 <adnap> and asks for another a
01:21:26 <pqmodn> adnap: i think asAppliedTo f arg _ = f arg is the simplest. don't forget to the type signature though
01:21:35 <adnap> Yes, it makes sense
01:21:57 <bitonic> pqmodn: oh yes, that‚Äôs nicer
01:22:10 <adnap> :t asAppliedTo
01:22:11 <lambdabot> (t -> b) -> t -> t -> b
01:22:46 <bitonic> adnap: so yes, it asks for another ‚Äòa‚Äô.  so with ‚Äòid‚Äô, you have ‚ÄòasAppliedTo id :: a -> a -> a‚Äô, right?
01:23:10 <adnap> Hold on... I keep doing double-takes
01:23:29 <bitonic> you start with ‚Äò(t -> b) -> t -> t -> b‚Äô, and ‚Äòid :: a -> a‚Äô
01:23:47 <bitonic> so given the type signature for ‚Äòid‚Äô, ‚Äòt‚Äô must be the same as ‚Äòb‚Äô
01:24:05 <pqmodn> and don't forget when you apply an argument to a function, the resulting type now has one *less* argument
01:24:30 <pqmodn> damnit, apply a "function to an argument". going to bed before i cause more damage
01:24:52 <bitonic> I have the reverse problem, woke up after 5 hrs for some reason lol
01:25:55 <adnap> asAppliedTo id "hi" _ = id "hi"
01:26:19 <adnap> :t asAppliedTo
01:26:20 <lambdabot> (t -> b) -> t -> t -> b
01:26:51 <adnap> asAppliedTp f x y = (\y -> f x)
01:27:15 <bitonic> adnap: maybe you meant ‚ÄòasAppliedTo f x = (\y -> f x)‚Äô
01:27:27 <adnap> Yes
01:28:13 <adnap> So... b is determined from the type of the function we pass in and t by the type of the argument we pass in
01:29:14 <adnap> Hm... why do we throw away y...
01:29:26 <adnap> asAppliedTo f x = (\y -> f y)
01:30:19 <bitonic> @djinn (t -> b) -> t -> t -> b
01:30:21 <lambdabot> f a b _ = a b
01:31:38 <adnap> Oh
01:31:42 <bitonic> @ty (\f _ x -> f x) :: (t -> b) -> t -> t -> b
01:31:44 <lambdabot> (t -> b) -> t -> t -> b
01:31:50 <adnap> So, calling the function on the passed-in type specifies t
01:31:52 <bitonic> it doesn‚Äôt really matter which one you throw away
01:32:02 <adnap> I think it does
01:32:09 <bitonic> look above
01:32:19 <bitonic> @ty (\f x _ -> f x) :: (t -> b) -> t -> t -> b
01:32:21 <lambdabot> (t -> b) -> t -> t -> b
01:32:25 <bitonic> @ty (\f _ x -> f x) :: (t -> b) -> t -> t -> b
01:32:26 <lambdabot> (t -> b) -> t -> t -> b
01:32:58 <bitonic> adnap: the function it‚Äôs useless, it‚Äôs just a device to instantiate those type variables
01:33:01 <bitonic> *is useless
01:33:07 * bitonic needs to go
01:34:26 <adnap> if I do "let asAppliedTo f x = (\y -> f y)" and then ":t id `asAppliedTo` "hi"" in ghci, I get t1 -> t1
01:35:03 <adnap> if I do "let asAppliedTo f x = (\_ -> f x" and then ":t id `asAppliedTo` "hi"" in ghci, I get t1 -> [Char]
01:35:13 <bitonic> @ty ((\f _ x -> f x) :: (t -> b) -> t -> t -> b) id "foo"
01:35:14 <lambdabot> [Char] -> [Char]
01:35:23 <bitonic> adnap: the type it infers is more general
01:35:38 <bitonic> I really need to go anyway, later
01:35:43 <adnap> Bye-bue
01:35:47 <adnap> *Bye-bye
01:38:54 <supki> @ty (undefined :: (t -> b) -> t -> t -> b) id "foo"
01:38:56 <lambdabot> [Char] -> [Char]
01:39:51 <adnap> :t foldl
01:39:52 <lambdabot> (a -> b -> a) -> a -> [b] -> a
01:42:14 <adnap> @ty (undefined :: ((a -> b -> a) -> a -> [b] -> a) -> b -> (a -> b -> a) -> a -> [b] -> a) foldl "foo"
01:42:15 <lambdabot> (a -> [Char] -> a) -> a -> [[Char]] -> a
01:42:39 <adnap> @ty (undefined :: ((a -> b -> a) -> a -> [b] -> a) -> a -> (a -> b -> a) -> a -> [b] -> a) foldl "foo
01:42:40 <lambdabot>     lexical error in string/character literal at end of input
01:42:42 <adnap> @ty (undefined :: ((a -> b -> a) -> a -> [b] -> a) -> a -> (a -> b -> a) -> a -> [b] -> a) foldl "foo"
01:42:43 <lambdabot> ([Char] -> b -> [Char]) -> [Char] -> [b] -> [Char]
01:43:02 <adnap> :t typeOf
01:43:03 <lambdabot> Typeable a => a -> TypeRep
01:44:02 <adnap> @ty (undefined :: (typeOf foldl -> a -> typeOf foldl) foldl "foo"
01:44:03 <lambdabot> parse error on input `"'
01:44:12 <adnap> @ty (undefined :: typeOf foldl -> a -> typeOf foldl) foldl "foo"
01:44:13 <lambdabot> (a -> b -> a) -> a -> [b] -> a
01:44:45 <turiya> hi
01:44:59 <turiya> is it possible to do symbolic math in haskell?
01:45:58 <supki> @ty (undefined :: (s -> t -> b) -> s -> t -> (s -> t -> b)) foldl (++) ""
01:46:00 <lambdabot> ([Char] -> [Char] -> [Char]) -> [Char] -> [[Char]] -> [Char]
01:46:35 <adnap> supki: I wonder if I can define something that does require me to type the type of the function I am interested in
01:46:40 <adnap> *doesn
01:46:43 <adnap> *doesn't
01:46:52 <supki> adnap: ?
01:47:45 <adnap> @ty (undefined :: (typeOf foldl -> a -> (a -> b -> a) -> a -> [b] -> a) foldl "foo"
01:47:46 <lambdabot> parse error on input `"'
01:47:53 <adnap> @ty (undefined :: typeOf foldl -> a -> (a -> b -> a) -> a -> [b] -> a) foldl "foo"
01:47:54 <lambdabot> ([Char] -> b -> [Char]) -> [Char] -> [b] -> [Char]
01:48:03 <adnap> @ty (undefined :: typeOf foldl -> b -> (a -> b -> a) -> a -> [b] -> a) foldl "foo"
01:48:05 <lambdabot> (a -> [Char] -> a) -> a -> [[Char]] -> a
01:48:49 <adnap> Just want to get rid of X in @ty (undefined :: typeOf foldl -> b -> X) foldl "foo"
01:49:01 <adnap> Avoid specifying X, rather
01:49:25 <supki> @ty (undefined :: foo bar -> b -> (a -> b -> a) -> a -> [b] -> a) foldl "foo"
01:49:27 <lambdabot> (a -> [Char] -> a) -> a -> [[Char]] -> a
01:50:27 <supki> oh, I see
01:50:33 <supki> I don't know if you can do that
01:51:37 <supki> adnap: note that  typeOf foldl  on the type level does not do what you probably think it does, it's just 2 type variables like in  f a
01:52:37 <adnap> @ty (\f _ -> (undefined :: (typeOf f -> a -> (a -> b -> a) -> a -> [b] -> a)) foldl "foo"
01:52:38 <lambdabot> parse error (possibly incorrect indentation)
01:53:24 <adnap> @ty (\f _ -> (undefined :: typeOf f -> a -> (a -> b -> a) -> a -> [b] -> a)) foldl "foo"
01:53:25 <lambdabot> typeOf f -> a -> (a -> b -> a) -> a -> [b] -> a
01:55:09 <supki> adnap: anyway, you can use  :: (t -> b) -> t -> t -> b  to specify first argument's type, :: (s -> t -> b) -> s -> t -> (s -> t -> b)  to specify first two arguments' type and so on
01:55:22 <adnap> Yeah
01:55:32 <adnap> But the annoying thing is having to type the type of the function
01:55:42 <supki> you don't need to
01:55:49 <supki> @ty (undefined :: (s -> t -> b) -> s -> t -> (s -> t -> b)) foldl (++) ""
01:55:50 <lambdabot> ([Char] -> [Char] -> [Char]) -> [Char] -> [[Char]] -> [Char]
01:56:00 <supki> I did not specify type of foldl in any way
01:56:09 <adnap> Uh...
01:56:11 <supki> well
01:56:23 <supki> I did specify that it takes at least 2 arguments
01:56:35 <adnap> :t foldl
01:56:36 <lambdabot> (a -> b -> a) -> a -> [b] -> a
01:57:12 <supki> s = (a -> b -> a), t = a, b = [b] -> a
01:57:48 <adnap> I see
01:58:49 <adnap> I wish I could just do something like (a :: Int) in typeOf foldl
01:59:55 <supki> @ty foldl :: (a ~ Int) => (a -> b -> a) -> a -> [b] -> a
01:59:57 <lambdabot>     Illegal equational constraint a ~ Int
01:59:57 <lambdabot>     (Use -XGADTs or -XTypeFamilies to permit this)
01:59:57 <lambdabot>     In an expression type signature:
02:00:01 <supki> oh well
02:00:08 <supki> anyway, it works in ghci
02:00:12 <adnap> No way!
02:00:18 <adnap> That's what I was asking for all along
02:00:26 <adnap> Wait...
02:00:33 <adnap> I don't want to have to type the type of foldl though
02:00:37 <supki> yeah
02:01:21 <adnap> "Assume that :t foldl applies the conventional type labeling. replace symbol x with type of value v"
02:01:28 <adnap> That's what I want
02:03:48 <supki> that's would be rather limited
02:03:57 <adnap> Why?
02:04:03 <supki> most of the time :t would tell something like  a137 -> b75 -> ...
02:04:43 <supki> there are even abominations like liftM
02:04:45 <supki> :t liftM
02:04:47 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
02:05:01 <adnap> I could do ":t f", look for the label, l, of the type I want to specify, and then supply (l -> s), where s is a specific type
02:05:43 <supki> now that sounds like a nice idea for a project ;)
02:06:34 <adnap> Even better would be...
02:07:45 <adnap> What would the type of foldl be if I called it like this: "foldl _ "hi" _"
02:09:58 <quicksilver> @type foldl ?a "hi" ?b
02:09:59 <lambdabot> (?a::[Char] -> b -> [Char], ?b::[b]) => [Char]
02:10:01 <quicksilver> adnap: like that?
02:10:23 <adnap> quicksilver: Whoa
02:10:56 <quicksilver> implicit parameters are pretty horrific to actually program with
02:11:03 <quicksilver> but they're quite handy for type-checking tricks :)
02:11:18 <adnap> What are implicit parameters?
02:11:47 <quicksilver> you can look them up in the manual if you want :)
02:12:00 <quicksilver> they're parameters which are implicitly passed around as a context, a bit like type class instances
02:12:14 <danr> adnap http://www.haskell.org/haskellwiki/Implicit_parameters
02:12:17 <adnap> quicksilver: One problem with the output is that it doesn't give "([Char] -> b -> [Char]) -> [Char] -> [b] -> [Char]"
02:12:37 <quicksilver> yes. Will I wasn't quite sure what you wanted.
02:13:05 <adnap> quicksilver: That's what I want
02:13:19 <quicksilver> you can define a help "withSecondParameter" such that you could write foldl `withSecondParameter` (undefined::[Char])
02:13:32 <quicksilver> or indeed foldl `withSecondParameter` "hi"
02:13:42 <shachaf> @ty (\a b c -> foldl a (b::[Char]) c)
02:13:43 <lambdabot> ([Char] -> b -> [Char]) -> [Char] -> [b] -> [Char]
02:14:15 <adnap> shachaf: Nice
02:14:38 <adnap> @type foldl ?a "hi"
02:14:39 <lambdabot> (?a::[Char] -> b -> [Char]) => [b] -> [Char]
02:14:49 <quicksilver> @let withSecondParameter f x :: (a -> b -> c) -> b -> (a -> b -> c); withSecondParameter = undefined
02:14:49 <lambdabot>   Left-hand side of type signature is not a variable: withSecondParameter f x
02:15:06 <quicksilver> @let withSecondParameter :: (a -> b -> c) -> b -> (a -> b -> c); withSecondParameter = undefined
02:15:09 <lambdabot>  Defined.
02:15:16 <quicksilver> @type foldl `withSecondParameter` "hi"
02:15:17 <lambdabot> ([Char] -> b -> [Char]) -> [Char] -> [b] -> [Char]
02:15:32 <adnap> quicksilver: But one still has to define withXParameter for all X
02:15:56 <quicksilver> well you could also define #$ and #* such that you could write
02:16:06 <adnap> And with "@ty (\a b c -> foldl a (b::[Char]) c)
02:16:15 <adnap> One has to type out a, b, c, etc.
02:16:18 <quicksilver> foldl #$ undefined #* "hi" #* undefined
02:16:19 <quicksilver> I think.
02:18:19 <adnap> quicksilver: What if it was like "foldl _ Char _"
02:18:54 <adnap> or "foldl (Char -> _ -> Char) _ _"
02:19:43 <shachaf> I thinkt he whole thing may be a bit misguided.
02:19:54 <shachaf> Type variables aren't bad. They give you more information than [Char]
02:20:07 <adnap> That's not the point of it
02:20:32 <adnap> The point of it is to help with the mental substitution of a specific type when working out how one will call a function
02:28:30 <Taneb> How does HashSet handle hash collisions?
02:29:53 <quchen> Taneb: Using Eq
02:30:18 <Taneb> Right
02:34:04 <quchen> What do the docs mean with "O(min(n,W))" here? http://hackage.haskell.org/packages/archive/unordered-containers/0.2.3.0/doc/html/Data-HashSet.html#g:3
02:34:13 <quchen> Is "W" some sort of standard notation?
02:34:29 <quchen> Like "Width of the set"? In any case, what's n then?
02:35:18 <supki> W is number of bits in something I think
02:35:25 <Chousuke> I'm pretty sure it has something to do with the hashing.
02:35:33 <Chousuke> :P
02:36:19 <supki> hmm, at least Data.IntMap uses W in that sense
02:36:20 <quchen> Hm.
02:36:28 <supki> not sure about unordered-containers
02:36:34 <quchen> Still weird that "member" isn't log(n)
02:36:40 <quchen> So there's gotta be some magic in there
02:37:19 <Chousuke> bloom filters? :P
02:38:00 <Chousuke> hmm
02:39:05 <Chousuke> it just does a HashMap lookup
02:39:08 <quchen> It's quite odd as "HashSet a = HashMap a ()"
02:39:10 <quchen> Yeah
02:39:16 <quchen> And the HashMap docs say log(n)
02:39:32 <quchen> Which makes sense as average case
02:39:51 <Chousuke> it's HashMap.Lazy which says the same as HashSet
02:40:07 <Chousuke> "Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of W -- the number of bits in an Int (32 or 64). "
02:41:21 <quchen> Where does it say that?
02:41:29 <Chousuke> HashMap.Lazy documentation
02:41:40 <Chousuke> at the top
02:41:46 <quchen> Can't find it in there :s
02:41:57 <quchen> 0.2.3.0?
02:41:57 <Chousuke> http://hackage.haskell.org/packages/archive/unordered-containers/0.1.2.0/doc/html/Data-HashMap-Lazy.html here
02:42:12 <Chousuke> just the first hit in google, didn't look at the version
02:42:41 <quchen> That comment was removed it seems
02:43:06 <quchen> I wonder why it even talks about worst-case complexity.
02:43:30 <quchen> That corresponds to having a constant hash function, which is clearly not important for applications
02:43:45 <Chousuke> I suppose due to laziness?
02:43:47 <hamid> I want to debug or trace to see which function calls or specifically what arguments are passed when my function calls itself recursively. Is there any way to do that?
02:44:17 <quchen> Chousuke: I think HashMap is a Map of lists.
02:44:42 <quchen> Lookup means calculating the hash, and looking it up in the Map. If there are multiple hits, Eq is used to traverse the list of "things that have this hash"
02:45:02 <quchen> So only when two hashes collide you have to traverse the list
02:45:43 <quchen> hamid: The quick and dirty way of doing this is using Debug.Trace
02:45:49 <Chousuke> yeah, well, you never know with laziness and functional data structures. They can get weird. :)
02:45:57 <thirsteh> in [x * y | x <- [1..100], y <- [1..100], cond $ x * y], does x * y only happen once per permutation (in GHC)?
02:46:08 <quchen> thirsteh: No.
02:46:18 <quchen> Wait
02:46:23 <hamid> quchen, as long as it's quick it's fine ;) thanks.
02:46:26 <quchen> Restate that, it could also be "yes"
02:47:03 <quchen> hamid: Debug.Trace.trace gives you the "trace" function, which allows you to print stuff out of pure functions.
02:47:19 <hamid> quchen, awesome! that's it :)
02:47:22 <quchen> It's not safe to use in release code, but as a quick way of "looking inside" it's fine
02:48:02 <thirsteh> quchen: any rule of thumb for this? (Same for multiple "f g" in a function/where clause)
02:48:33 <quchen> thirsteh: Oh, you mean whether GHC recognizes x*y as appearing twice? Possibly. It's called common subexpression elimination.
02:48:41 <thirsteh> quchen: yes
02:48:51 <supki> thirsteh: if you want to share computation it's better to state that explicitly with let
02:49:01 <thirsteh> quchen: to rephrase, I'm curious if there is a rule-of-thumb for when common subexpression elimination happens
02:49:15 <thirsteh> or doesn't happen
02:49:25 <quchen> I'm not sure how good GHC is at this, and I wouldn't rely on it. If you *know* you have common subexpressions, better use "let" manually.
02:49:34 <quchen> GHC does do this, yes.
02:49:55 <thirsteh> quchen: this is one of the (surprisingly) few cases where I'd like to retain the list comprehension
02:50:14 <supki> you can use let in list comprehensions
02:50:30 <thirsteh> ah, great
02:50:33 <quchen> filter cond $ liftM2 (*) [1..100] [1..100]
02:50:45 <thirsteh> quchen: that's also pretty good
02:50:58 <quchen> filter cond $ liftA2 (*) [1..100] [1..100]
02:51:02 <quchen> A!
02:51:07 <quchen> Booo monads ;-)
02:51:09 <supki> > [z | x <- [1..10], y <- [1..10], let z = x * y]
02:51:11 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,2,4,6,8,10,12,14,16,18,20,3,6,9,12,15,18,21,24,27,30,...
02:51:29 <thirsteh> perfect, thanks guys
02:51:38 <_yezariaely> I have fmap (+1) (Just 1) and fmap (+1) [1,2,3] which works both fine. How would I combine them? i.e. fmap (+1) [Just 1, Nothing, Just 2] = [Just 2, Nothing, Just 3] ?
02:51:40 <quchen> supki: Do you know what list comprehensions desugar to? Is it monadic code or only something similar?
02:51:54 <quchen> _yezariaely: (fmap . fmap)
02:51:56 <supki> @undo [z | x <- [1..10], y <- [1..10], let z = x * y]
02:51:57 <lambdabot> concatMap (\ x -> concatMap (\ y -> let { z = x * y} in [z]) [1 .. 10]) [1 .. 10]
02:52:18 <quchen> _yezariaely: Chaining "fmap" like this allows you to go multiple levels deep.
02:52:27 <_yezariaely> cool
02:52:30 <quchen> > (fmap.fmap) (+1) [Just 1, Nothing, Just 2]
02:52:31 <_yezariaely> thx
02:52:32 <lambdabot>   [Just 2,Nothing,Just 3]
02:53:39 <quchen> _yezariaely: the more obvious way would be using fmap (fmap (+1)) [...], but you can rewrite "f (g x)" as (f.g) x" and that's what happens here
02:54:00 <quchen> Plus it's more readable when you know about the idiom
02:54:43 <supki> quchen: I think report specifies what list comprehensions desugar to
02:55:04 <supki> yeah, section 3.11
02:55:30 <quchen> Oh. Well no monads then
02:55:37 <Chousuke> if you don't like repeating fmap you can also do fmap (+1) <$> [Just 1, Nothing, Just 2] which is actually just repeating fmap but with a different name :P
02:56:58 <Chousuke> applicatives are fun
02:57:04 <supki> well, monad comprehensions probably desugar to monadic code
03:02:29 <quchen> But that's not part of the report
03:14:12 <supki> no, they aren't, but ghc user guide should describe their desugaring
03:14:32 <supki> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#monad-comprehensions
03:15:26 <cinimod> I am trying to install a package which requires base==4.6.*
03:15:26 <lambdabot> cinimod: You have 1 new message. '/msg lambdabot @messages' to read it.
03:16:30 <supki> cinimod: you will need ghc 7.6.1 at least for that
03:17:55 <cinimod> I just tried to do that
03:18:04 <hamid> quchen, now I get what do you mean by dirty :P
03:18:29 <hamid> nvm this was just a testcase :)
03:18:55 <cinimod> ./configure --prefix=/Library/Haskell
03:19:05 <cinimod> sudo make install
03:19:35 <quchen> hamid: "dirty" in the sense it's a dirty hack and should never appear outside of testing
03:20:08 <quchen> 'trace' performs IO out of a seemingly pure function
03:20:37 <hamid> quchen, yes. but it's real useful to me. i didn't want to make mine impure.
03:21:15 <cinimod> It claimed to have installed but it looks like it didn't
03:21:25 <hamid> quchen, there's no other way like ghc tracing the function calls?
03:21:57 <quchen> hamid: You can of course use 'trace', but you should take it out again once you know what you wanted.
03:22:22 <quchen> hamid: Maybe look at the GHCi debugger, but I'm not familiar with that one
03:22:48 <hamid> quchen, ok thank you.
03:23:19 <cinimod> Despite me setting the prefix correctly it has installed it in /Library/Haskell/lib
03:23:27 <cinimod> Not sure why it would have done that
03:24:21 <cinimod> bash-3.2$ /Library/Haskell/lib/ghc-7.6.2/ghc --version
03:24:21 <cinimod> The Glorious Glasgow Haskell Compilation System, version 7.6.2
03:24:21 <cinimod>  
03:25:33 <cinimod> I now have 7.4.1 and 7.6.2
03:25:50 <cinimod> How do I tell cabal to use 7.6.2 and 7.4.1?
03:26:06 <dcoutts_> cinimod: -w ghc-7.6.2
03:26:19 <dcoutts_> assuming ghc-7.6.2 is on your $PATH
03:26:29 <dcoutts_> otherwise you'd need to pass the full path to it
03:26:33 <cinimod> It isn't at the moment
03:26:36 <cinimod> But it can be
03:26:43 <cinimod> Thanks
03:27:06 <dcoutts_> alternatively, just change your $PATH so that the 'ghc' on your $PATH is the one you want
03:28:01 <dcoutts_> cinimod: for people who need to use several (e.g. for testing) we usually arrange that all of them are on the path, and since ghc uses versioned names then that works out nicely
03:29:23 <cinimod> Cool! It is for testing. I have most of my stuff using the current platform but someone has sent me something that only works with the latest base.
03:44:59 <Antz> hello
03:46:24 <quchen> Good day to you sir.
03:46:28 <cinimod> bash-3.2$ which ghc
03:46:28 <cinimod> /Library/Haskell/lib/ghc-7.6.2/ghc
03:46:28 <cinimod>  
03:46:36 <cinimod> But I get
03:46:46 <cinimod> bash-3.2$ ghc
03:46:46 <cinimod> ghc: missing -B<dir> option
03:46:46 <cinimod>  
03:47:05 <adimit> OK, so here's an embarrassing newbie question. Suppose I want to write a function average :: (Num n, Fractional m) => [n] -> m -- I know why it obviously won't work so easily, but the question is: can it be done at all?
03:47:51 * hackagebot weather-api 0.4.2 - Weather api implemented in haskell  http://hackage.haskell.org/package/weather-api-0.4.2 (PeterGoncharov)
03:48:31 <adimit> So, the problem, as I see it, is that \ns -> sum ns / fromIntegral (length ns) won't give the desired output, becaues of sum's type (Num a => [a] -> a)
03:49:19 <cinimod> Why is that a problem?
03:50:33 <typoclass> cinimod: looks to me like ghc is present and prints a message. have you tried "ghc somefile.hs"? or "ghci"?
03:50:50 <adimit> because of the type of (/). If I give the average function a list of Integrals, that won't work --- I'd need fromIntegral there. But I only need it for Integrals, not for Fractionals.
03:51:30 <adimit> so I can write two versions of average, one for Fractional, one for Integral, but I can't make the compiler choose automatically between them.
03:52:06 <hpaste> adimit pasted ‚ÄúFractional/Integral‚Äù at http://hpaste.org/84709
03:52:16 <cinimod> I think I would just map the ints to floats or whatever
03:52:59 <cinimod> @typoclass: ghci is still 7.4.1
03:52:59 <lambdabot> Unknown command, try @list
03:53:11 <cinimod> typoclass: ghci is still 7.4.1
03:53:24 <adimit> cinimod: how (and why map?) You don't know that they're Ints. Ideally, you only know they're Nums.
03:53:35 <cinimod> bash-3.2$ ghci --version
03:53:35 <cinimod> The Glorious Glasgow Haskell Compilation System, version 7.4.1
03:53:35 <cinimod>  
03:54:56 <cinimod> avg_i = avg_f . map fromIntegral
03:56:42 <adimit> cinimod: that's not what I want. What i want would be avg :: (Num a, Fractional b) => [a] -> b
03:56:52 <adimit> which that isn't.
03:57:32 <adimit> It appears that I'm (of course not) the first one to ask this question, and that the answer isn't simple.. http://stackoverflow.com/questions/2376981/haskell-types-frustrating-a-simple-average-function :-|
03:57:48 <mcstar> there is a solution
03:58:09 <mcstar> i just always forget what the damn conversion function is, that converts from Num to Fractional
03:58:22 <mcstar> there is a SO question about this
03:58:53 <quicksilver> realToFrac
03:59:00 <mcstar> that
03:59:04 <quicksilver> although it doesn't convert from Num to Fractional.
03:59:06 <mcstar> just found the SO question
03:59:19 <mcstar> it converts typeclass constraints
03:59:23 <mcstar> :t realToFrac
03:59:23 <quicksilver> most of the time fromIntegral and realToFrac are everything you need.
03:59:24 <lambdabot> (Fractional b, Real a) => a -> b
03:59:35 <adimit> yeah, I linked the SO question above.
03:59:38 <quicksilver> occasionally you might want round,floor,ceiling.
03:59:56 <cinimod> Hmm I don't even seem to have a package config file
03:59:56 <adimit> I didn't consider that just googling Fractional Integral haskell was enough..
04:00:02 <mcstar> adimit: i missed that ...
04:00:21 <cinimod> bash-3.2$ ghc-pkg list
04:00:21 <cinimod> ghc-pkg: missing --global-package-db option, location of global package database unknown
04:00:21 <cinimod>  
04:00:48 <adimit> So the best I can get is average :: (Real a, Fractional b) => [a] -> b
04:01:06 <quicksilver> that's one thing you can get.
04:01:15 <mcstar> thats a pretty good thing i think
04:01:29 <adimit> yeah, I think it's OK, since I can feed it all numbers I want to.
04:01:43 <quicksilver> if you want integer average you have to concede that that is a different operation.
04:01:57 <quicksilver> you can get intAverage :: Integral a => [a] -> a
04:02:05 <adimit> yeah.
04:02:11 <mcstar> quicksilver: you mean integer to integer?
04:02:38 <mcstar> but thats probably not what he wants
04:02:52 * hackagebot NXT 0.2.3 - A Haskell interface to Lego Mindstorms NXT  http://hackage.haskell.org/package/NXT-0.2.3 (MitarMilutinovic)
04:03:03 <typoclass> cinimod: could you do "echo $PATH" and check if the new ghc's directory comes before the old one's?
04:03:07 <mcstar> also, you can write that in terms of the more general average
04:03:12 <adimit> no, it's not quite, but that's ok, since intAverage is no trouble to write the way I want it.
04:03:24 <cinimod> bash-3.2$ echo $PATH
04:03:24 <cinimod> /Library/Haskell/lib/ghc-7.6.2:/Users/dom/Downloadable/pylearn2/pylearn2/scripts/train_example:/Users/dom/Downloadable/pylearn2/pylearn2/scripts:/Library/Frameworks/Python.framework/Versions/2.7/bin:/Users/dom/Library/Haskell/bin:/Users/dom/Downloadable/pylearn2/pylearn2/scripts/train_example:/Users/dom/Downloadable/pylearn2/pylearn2/scripts:/Library/Frameworks/Python.framework/Versions/2.7/bin:/Users/dom/Library/Haskell/
04:03:24 <cinimod>  
04:03:37 <adimit> I'm just puzzled that something like (Num a, Fractional b) => a -> b doesn't exist.
04:03:59 <typoclass> cinimod: could you describe what your problem is?
04:04:14 <cinimod> bash-3.2$ ghc
04:04:15 <cinimod> ghc: missing -B<dir> option
04:04:15 <cinimod>  
04:04:20 <cinimod> Is one problem
04:04:26 <merijn> adimit: Well, not every Num might be convertible to a fractional...
04:04:42 <cinimod> bash-3.2$ ghc-pkg list
04:04:42 <cinimod> ghc-pkg: missing --global-package-db option, location of global package database unknown
04:04:42 <cinimod>  
04:04:43 <adimit> merijn: irrational numbers, say?
04:04:45 <cinimod> is another
04:04:45 <merijn> adimit: For instance, imagine a matrix/vector instance of Num, could you convert those to a Fractional?
04:04:50 <merijn> adimit: Those too, yes
04:05:29 <cinimod> I thought I had followed the instructions ./configure and make install
04:05:30 <mcstar> Prelude has Num instances of Integer, Int, Float, Double, exactly those are the instances of Real
04:05:32 <merijn> adimit: Num is *really* generic, on purpose. But that generality also means that some operations may not make any sense, even if they seem sensible at first glance
04:05:46 <adimit> so I guess, barring introspection/reflection, i'd have to force the caller to use fromIntegral on the supplied value.
04:06:05 <merijn> adimit: Well, what's wrong with using Real?
04:06:29 <merijn> All the likely suspect people will want to use should be Real's, I think
04:06:38 <cinimod> With 7.4.1 I seem to have bin and doc directories
04:07:32 <cinimod> But not with 7.6.2
04:07:41 <adimit> Yeah, I think what mcstar just said probably explains my confusion: All Num instances in Prelude look like (Num a, Fractional b) => a -> b should make sense, but that's not the intended use of the Num type class.
04:07:51 <mcstar> you have to import, to get Num instances of Complex a and Ratio a
04:07:54 <adimit> since it's conceived to be more general.
04:09:28 <adimit> but the (Real a, Fractional b) => [a] -> b one does what I want in any case.
04:09:58 <cinimod> The doc directory seems to be in /Library/Haskell/share/doc/
04:22:32 <circle> when you define a function recursively, and have a term (x:xs)
04:22:44 <circle> how does haskell "know" that that means a single x with a list xs on the end?
04:23:00 <circle> how do they know x:xs is a single element, then a list?
04:23:13 <skuggi> because that's what the : means
04:24:22 <merijn> circle: Because that's what the type of (:) says so
04:24:26 <merijn> :t (:)
04:24:28 <lambdabot> a -> [a] -> [a]
04:24:29 <blueonyx> @where lyah
04:24:29 <lambdabot> http://www.learnyouahaskell.com/
04:24:31 <mcstar> x : xs == (:) x xs
04:24:53 <blueonyx> lyah down? :>
04:24:56 <blueonyx> :(
04:24:57 <cinimod> Where does package-db point to by default?
04:25:11 <circle> oh okay
04:25:12 <circle> thanks
04:25:32 <typoclass> blueonyx: yes, seems down for me :-/
04:25:44 <merijn> circle: Do you know how to define your own datatypes yet? (I don't want to give an example that's too difficult :)
04:25:53 <circle> I don't know that yet
04:26:10 <merijn> Ah, then nevermind for now
04:26:13 <circle> I think it said in the beginning of the book that ":" means that, I just forgot somewhere along the line
04:27:13 <merijn> circle: Basically, when you define a datatype you specify some constructors and the types of arguments those constructors have. GHC uses that information to "know" what should be there when you pattern match
04:28:10 <mcstar> ghc?
04:28:10 <merijn> circle: [] and : are the constructors for lists, the former taking no arguments and the : taking an item and a list. So the way haskell "knows" is because the definition of lists tells that's what happens
04:28:25 <circle> hmm, yeah, fair enough
04:28:49 <mcstar> merijn: you have to supply it, what else is to know?
04:28:56 <mcstar> case x : xs of....
04:29:31 <mcstar> it not haskell that figures it, it is you, you put it there to pattern match on them
04:29:33 <merijn> mcstar: heh? I don't understand the relevance to the question?
04:29:59 <mcstar> merijn: i dont understand your answer to circle , what are you trying to explain with that 'haskell/ghc knows'?
04:30:11 <merijn> mcstar: circle was asking "if you pattern match (x:xs), how does the compiler tell x is a single x, where as xs is a list of x?"
04:30:28 <mcstar> thats a simple question of typechekcing
04:30:36 <merijn> mcstar: It is not as obvious as you think, for people coming from, say, python/ruby/javascript where you have heterogeneous lists
04:30:43 <t7> it checks the tag on the tagged union
04:30:52 <merijn> mcstar: Of course it's obvious and simple...to us :)
04:31:02 <t7> then decomposes the datatype
04:31:58 <t7> its a bit scary that im gonna be teaching foreign people IT in a few weeks
04:32:13 <merijn> t7: How so?
04:32:28 <t7> part of my new job is 10 hours teaching a week
04:32:29 <merijn> How is it different from teaching non-foreign people IT? :p
04:32:43 <mcstar> what does it stand for?
04:32:53 * mcstar puns
04:33:28 <t7> you have to use babbys first english words
04:35:37 <mcstar> > 1/0
04:35:38 <lambdabot>   Infinity
04:35:53 <mcstar> i dont remember this happening
04:36:05 <mcstar> wth is Infinity here?
04:36:05 <t7> > 1 / 0 :: Int
04:36:07 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
04:36:07 <lambdabot>    arising from a use o...
04:36:17 <t7> > 1 `div` 0
04:36:18 <lambdabot>   *Exception: divide by zero
04:36:38 <typoclass> mcstar: something defaults to Float or Double, and those are funky
04:37:04 <mcstar> > (1/0)::Float
04:37:05 <lambdabot>   Infinity
04:38:08 <mcstar> its just that ive never seen this before
04:38:22 <mcstar> maybe i was a good kid the whole time, and never tried division by zero
04:38:32 <mcstar> float division
04:39:03 <mcstar> anyway, what is it?
04:39:29 <mcstar> it is pure code, and it doesnt start with ***Exception
04:40:02 <merijn> mcstar: It's Infinity, as defined by IEEE754
04:40:24 <mcstar> > floor $ 1 / 0
04:40:26 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
04:40:51 <merijn> IEEE754 floating points have a bunch of things like positive infinity, negative infinity, multiple different zeroes and several NaN's (Not A Number)
04:41:10 <merijn> Haskell Floats should follow IEEE754, I think
04:41:23 <mcstar> merijn: that wasnt my question, i was asking what IT is, i guess 'show' converts float inf to "Infinity"
04:41:32 <merijn> Yes
04:41:38 <mcstar> it just wasnt clear to me first
04:41:58 <merijn> I think read doesn't support it, though
04:42:04 <merijn> > read "Infinity" :: Float
04:42:06 <lambdabot>   Infinity
04:42:10 <merijn> oh, I guess it does
04:42:14 <cinimod> I've reported the problems installing 7.6.2 here if anyone is interested: http://www.haskell.org/pipermail/glasgow-haskell-users/2013-March/023903.html
04:42:35 <tsou> > logBase 10 1000
04:42:36 <mcstar> merijn: why doesnt floor error out, or something? isnt that weird?
04:42:36 <lambdabot>   2.9999999999999996
04:44:11 <mcstar> the conversion from RealFrac to Integral is not checked against inf
04:44:29 <mcstar> i think it should give an error
04:45:11 <typoclass> mcstar: yes, the conversions are sometimes dubious
04:46:18 <merijn> Consult IEEE754? :p
04:46:27 <merijn> I avoid floats like the plague
04:46:33 <merijn> @quote mantissa
04:46:33 <lambdabot> quicksilver says: <jatqceer> i love them.  Double is my friend <quicksilver> You think he is, sure <quicksilver> he says nice things about you <quicksilver> but one day, when your back is turned, he
04:46:33 <lambdabot> will stab you in the back with a mantissa
04:47:55 <mcstar> The Praying Mantissa
04:57:56 * hackagebot http-streams 0.4.0.1 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.4.0.1 (AndrewCowie)
05:13:10 <aleator> I'd like to apply a rewrite rule to rewrite computations of form (sum (map sum (foo xs)), but I can't get the rules to fire. Besides -ddump-simple-firings, are there other tools for debugging such?
05:14:08 <arkeet> I'm guessing other rewrite rules are firing before tours.
05:14:13 <Boney> w/in 10
05:16:20 <circle> did something change recently in haskell? my book has recursive functions using like (n + 1) = a * (n) for instance but the ghci only accepts, for me at least, n = 1 * (n - 1)
05:16:50 <quchen> circle: (n+k) patterns aren't allowed in Haskell 2010 anymore.
05:16:59 <circle> jesus
05:17:20 <Rembane> quchen: Why? :D
05:17:55 <typoclass> circle: yes, the so-called n+k patterns were widely agreed to be a mistake, and were turned off by default. there's a compiler flag that turns them back on, if you absolutely want to
05:17:58 <quchen> Rembane: Because they're weird special case syntax. + isn't a data constructor after all.
05:18:16 <circle> Yeah I don't actually think they're very nice compared to the other way to do it
05:18:20 <Rembane> quchen: That's a very good point. Thanks.
05:18:23 <circle> but my book is doing it that way
05:18:32 <typoclass> circle: luckily, you really only need to watch out for "... + ... = ...". it shouldn't happen too often
05:18:33 <quchen> Change your book.
05:18:46 <circle> this is supposed to be a pretty good one
05:18:50 <circle> came out in 2007.
05:18:51 <Rembane> Which is it?
05:19:02 <circle> Programming in Haskell by Graham Hutton
05:19:05 <sopvop> is this ok? `Context reduction stack overflow; size = 201 Use -fcontext-stack=N to increase stack size to N`
05:19:07 <int-e> circle: you can use the NPlusKPatterns language extension in ghc; in ghci, type  :set -XNPlusKPatterns
05:19:47 <sopvop> no, it is not
05:19:55 <typoclass> circle: even the best book will have typos and slowly go out of date. if you have doubts about any of the book's code, feel free to ask in here
05:20:04 <int-e> circle: but enough people have agreed that it's ugly and not very useful to have those patterns. (The same discussion also suggested to remove n-patterns, i.e.  f 0 = foo, but that didn't happen because it's too useful.)
05:20:08 <circle> sopvop: Not a good book you say? WHich would you recommend?
05:20:20 <circle> This book also uses piece-wise functions a lot. Is that also a bad idea?
05:20:43 <quchen> int-e: What's wrong with "f 0"? 0 is a data constructor after all
05:20:55 <int-e> (the justification being that f 0 = foo is really syntactic sugar for  f x | x == 0 = foo, because of the nature of numerals in Haskell, where 0 = fromInteger 0)
05:20:56 <quchen> Polymorphic maybe, but still
05:20:58 <typoclass> circle: you mean functions defined in multiple equations? "f abc = ...", "f xyz = ..." ?
05:21:16 <int-e> quchen: it looks like one, maybe, but it isn't :)
05:21:26 <circle> Yeah. Like f a 0 = a. f a b = a * b. or whatever.
05:21:31 <quchen> int-e: That's not true. If you're using the guard, you need Eq. With patterns you don't.
05:21:35 <typoclass> circle: that's generally fine. also, you could always in a very simple way rewrite it with case-of
05:21:41 <circle> I know.
05:21:42 <int-e> quchen: but you do.
05:21:43 <sopvop> circle: my comment was not to you :)
05:21:48 <circle> So about this book. Is it bad or is it good?
05:22:02 <int-e> :t let f 0 = () in f
05:22:03 <lambdabot> (Eq a, Num a) => a -> ()
05:22:10 <int-e> quchen: see?
05:22:11 <quchen> Wat
05:22:15 <quchen> Color me surprised
05:23:16 <quchen> So what is 0 then?
05:23:19 <quchen> CAF?
05:23:23 <typoclass> quchen: it's somewhat surprising, yes. but it seems to work well enough
05:23:51 <int-e> syntactic sugar for fromInteger 0; now that Integer is actually a constant.
05:24:10 <quchen> That plus guard?
05:24:16 <int-e> quchen: as a pattern, yes.
05:24:33 <quchen> Oh, and 0 is generally fromInteger 0.
05:24:38 <quchen> Well that makes sense
05:24:45 <quchen> But the pattern part seemed odd
05:25:43 <Philonous> @type let f (fromInteger 0) = () in f -- That should work as well, then
05:25:44 <lambdabot> Parse error in pattern: fromInteger
05:25:57 <Philonous> It's a bit inconsistent.
05:26:07 <int-e> it is a special case in the syntax
05:26:18 <quchen> Naah. What int-e meant is that 0 in a pattern is desugared to a guard with fromInteger.
05:26:34 <quchen> f 0    ==    f x | x == 0
05:26:41 <quchen> f 0    ==    f x | x == fromInteger 0
05:28:15 <quchen> Oh right, I just realized why 0 isn't a data constructor. "data Int = Int Int#"
05:29:00 <Philonous> @type let f (fromInteger -> 0) = () in f
05:29:02 <lambdabot>     Illegal view pattern:  fromInteger -> 0
05:29:02 <lambdabot>     Use -XViewPatterns to enable view patterns
05:29:50 <quchen> ViewPatterns are odd too. I'm not sure what to think of code in patterns.
05:30:20 <quchen> The pathological examples outweigh the useful ones if you ask me.
05:33:29 <Philonous> quchen:  But you can just treat them es sugar for guards.
05:33:57 <Philonous> Oh wait, you need pattern guards then
05:34:59 <Philonous> Ah, but pattern guards are in Haskell 2010.
05:35:38 <quchen> The GHC manual gives the example "foo ((f, _), f -> 4) = ..."
05:36:24 <quchen> That's the next-to-easiest case of using them, and I can't really read it very easily.
05:36:49 <quchen> Compared to "((f, _), x) | f x == 4" I think it's not very clear.
05:37:16 <quchen> And when such a feature becomes readily available, I'm not sure to what extent it will be abused.
05:37:41 <quchen> I really like the distinction between the pattern and code parts we have right now.
05:39:31 <aleator> quchen: I think it might have been intended to work with stuff like complex ASTs, where the patterns quick√ly become illegible.For example, try to match a function return value of Language.C.AST
05:40:55 <quchen> Well in that case I'd use pattern guards, which can easily (and naturally) be split over multiple lines
05:41:29 <quchen> Actually, can you do multiline pattern matches in functions? "f 0\n   1 = ..."?
05:41:57 <quchen> Wow, it works
05:42:02 <quchen> That feels odd
05:42:17 <typoclass> quchen: i think you defined a function "f 0 1 = ..."
05:42:22 <typoclass> (2 arguments)
05:42:45 <quchen> Yes
05:43:16 <typoclass> quchen: right. just making sure :-) didn't know what you meant to do
05:43:39 <quchen> http://codepad.org/0K6VXhDp
05:43:59 <quchen> I was just wondering whether you could in general have newlines in patterns of top-level declarations
05:44:47 <dcoutts> quchen: for big patterns, that's rather useful
05:45:22 <quchen> dcoutts: Tell me about it, reading patterns of half a line is awful
05:45:40 <quchen> But that's why I'm here: talk about unrelated stuff and learn new things by accident
05:45:50 <quchen> Thank you, ViewPatterns ;-D
05:47:25 <quchen> Also, for the first time, I looked up what the 2010 report changed.
05:47:34 <quchen> Turns out it's more than n+k patterns
05:48:03 * dcoutts would bring back n+k patterns for integral types
05:48:17 <dcoutts> sorry, natural types
05:48:18 <dcoutts> and add a Nat and Natural type
05:48:20 <quchen> Is there any talk about the next iteration of Haskell by the way? Haskell prime seems a little inactive
05:48:33 <quchen> But then 2010 is only 2.something years ago
05:48:49 <quchen> Anyway, I want my BangPatterns official ;-)
05:50:38 <typoclass> dcoutts: so you mean, you'd disallow n+k patterns as far as negative numbers are concerned, and allow it for positive?
05:51:22 <quchen> What did "f (n+k)" mean anyway?
05:51:36 <quchen> Was it especially implemented or just desugar-able?
05:54:38 <dcoutts> typoclass: I'd allow it only on types that are natural numbers
05:54:52 <dcoutts> so not Int or Integer, and certainly not floating
05:55:07 <typoclass> dcoutts: hm ok, so it would be Word and the like
05:55:15 <dcoutts> typoclass: right
05:55:31 <dcoutts> typoclass: and at the same time, I'd add a new type Nat, and Natural, like Int and Integer
05:55:45 <quchen> Special syntax just for Word+co? Mmmmh
05:55:49 <dcoutts> typoclass: difference is that Word is supposed to wrap
05:56:07 <quchen> A Nat type would be nice, I agree
05:56:43 <dcoutts> typoclass: 0-1 :: Word is defined, for Nat or Natural it would not be defined (it'd be a checked error, like div by zero)
05:56:52 <quchen> dcoutts: I'm sure this has been proposed already
05:56:58 <dcoutts> has it?
05:56:59 <typoclass> dcoutts: right, sounds good
05:57:38 <quchen> dcoutts: I would think so. I miss positive integers quite frequently.
05:57:48 <liyang> So Integer is to Nat what Int is to Word?
05:57:50 <quchen> And I think many others do as well
05:58:04 <quchen> Integer <=> natural; Nat <=> Int
05:58:12 <quchen> Int = whatever your machine wants it to be in length
05:58:19 <dcoutts> liyang: um, Nat & Int, Natural & Integer
05:59:03 <quchen> I wonder how Natural would fit in the silly numeric classes though
05:59:10 <liyang> What's the difference between Nat and Word then? I mean, if Nat doesn't wrap, what would it do on overflow?
05:59:14 <quicksilver> it's always annoyed me that CPUs provide facilities for fairly efficient checked naturals
05:59:15 <quchen> a - b | b > a = 0
05:59:15 <quchen> ?
05:59:21 <quicksilver> runtime error, quchen
05:59:28 <dcoutts> and difference between Word and Nat, is that Word is explicitly defined to be mod 2^something
05:59:31 <quicksilver> but languages never expose them.
05:59:31 <dEPY> Any of u guys involved in a startup?
05:59:36 <quchen> Well that would make "-" a non-total function, which isn't really good either
05:59:40 <dcoutts> quicksilver: right
05:59:46 <quicksilver> "-" *is* a partial function on Nat.
05:59:50 <quicksilver> if you don't like that, don't use it.
05:59:52 <quicksilver> other types exist ;)
06:00:05 <liyang> (If the answer is error on overflow, why should't the corresponding Int do the same?)
06:00:17 <quicksilver> liyang: hysterical raisins, most likely.
06:00:25 <dcoutts> liyang: that's a good question, as quicksilver says, history
06:00:48 <quicksilver> just like all CPUs since about 1980 have the ability to implement efficient N*2-bit integers from their N-bit registers
06:00:55 <quicksilver> (all you need is a carry bit and a conditional jump)
06:00:56 <dcoutts> liyang: arguably it's more important for Nat than Int, because overflow is a long way off, but underflow is right here at 0!
06:01:07 <quicksilver> but no programming language gives you access to the carry bit.
06:01:09 <quicksilver> it's madness!
06:01:26 <t7> inline asm
06:01:41 <dcoutts> quicksilver: we looked into this when we were implementing the SafeInt type, ie how to do the overflow check in cmm/asm etc. In the end our client didn't need it to be *that* fast.
06:01:56 <liyang> dcoutts: that feels distinctly unnatural. :<
06:02:29 <liyang> We need to overhaul the Num hierarchy really, so that you can't subtract thing willy-nilly.
06:02:38 <dcoutts> liyang: I think it'd be prefectly within the H98 spec for int overlow to be a runtime error, but we don't do it because of performance I think
06:02:53 <dcoutts> liyang: which has it's problems, like we had to implement SafeInt
06:03:01 <quicksilver> dcoutts: yeah. You often don't need it. It just annoys the perfectionist in me :)
06:03:02 <dcoutts> quicksilver: interestingly, cmm isn't well adapted for those kinds of ops
06:03:07 <liyang> dcoutts: likewise, I'd like for Nat to behave the same for performance. (In which case it's just Word.)
06:03:17 <quicksilver> dcoutts: I tend to use it as a canned example of why C really *isn't* a low-level language.
06:03:24 <liyang> dcoutts: doesn't SafeInt kill performance?
06:03:27 <dcoutts> liyang: I think it can be done pretty efficiently
06:03:29 <quicksilver> it's lowest-common-denominator, not powerful.
06:03:36 <liyang> (In which case you may as well be using Integer.)
06:03:59 <dcoutts> liyang: the way we implemented it yes, it's between perf of Int and Integer, but by using the cpu properly we could get it much closer to Int performance
06:04:10 <Radish> I'm trying to use a haskell library for port audio on haskell, can anyone help me?
06:04:17 <dcoutts> liyang: correctly predicted jumps are more or less free
06:05:02 <Radish> I've kind of recreated this file structure on my computer: http://code.haskell.org/portaudio/ minus the readme and the _darcs and the .cabal
06:05:16 <dcoutts> liyang: as quicksilver was hinting, on x86 you already get the overflow bit in the flags, just need to do a conditional jump on that
06:05:24 <liyang> dcoutts: true‚Ä¶ but if you had a checked Nat, I'll want a checked Int. (as well as a non-checked Int.) ;p
06:05:34 <dcoutts> liyang: big difference with Integer is that the representation is much better
06:05:36 <Radish> I can run set up but I can run the examples, I'm not sure if the examples are bad or if its not meant to be run that way
06:06:32 <dcoutts> liyang: oh I agree, I expect that there would be enough of a remaining perf difference (perhaps more so on other cpus) that people would want both checked and unchecked Int
06:07:20 <Radish> Does anyone use haskell with windows who can help me out?
06:07:24 <liyang> dcoutts: so what are we going to call that? My original objection is mostly due to my concern that we're running out of nice names for these types.
06:07:29 <gspr> Suppose I have a package that uses some third party C library through FFI, and I don't include that library in my package itself, but rather consider it a dependency. It seems Hackage then refuses to generate haddock documentation for my package since it fails to build (since Hackage naturally doesn't have said dependency). Is there a way to tell Hackage that "I know this package won't build for you, but please generate the Haddock docs anyway"
06:07:57 <dcoutts> liyang: right, I don't know, we have SafeInt, but that's wordy. It'd be a hard sell to change Int, and as you say finding a suitable name isn't easy.
06:08:04 <liyang> s/re running/ve run/
06:08:37 <dcoutts> liyang: my suggestion with Nat is partly because it's a new type it's easier, and making Int consistent with that is hard because changing things is hard
06:09:00 <liyang> Consistency or death. D:
06:09:09 <dcoutts> :-)
06:09:40 <dmwit> gspr: I don't think so (which is a shame). Maybe you could mail Ross and ask him to install that C library or something.
06:09:44 <dcoutts> gspr: no there isn't, but the new hackage server allows multiple bots to do the doc build, or in a pinch maintainers can upload them
06:09:59 <dmwit> ETA on New Hackage?
06:10:13 <gspr> dmwit: A shame indeed! Nah, I won't bother him with that -- it's too ugly a solution :)
06:10:18 <dcoutts> dmwit: see new-hackage.haskell.org for info on the alpha testing
06:10:41 <gspr> dcoutts: Ah, OK, good to know!
06:11:08 <dmwit> ooo, shiny
06:11:16 <gspr> In cases such as this, is it customary to just build the Haddock docs oneself and provide a link from the package description?
06:11:35 <dmwit> That seems like the best choice to me.
06:12:32 <gspr> ok
06:12:59 <quchen> Is haskell.org written in Haskell by the way?
06:13:07 <dmwit> "The goal has been to get it deployed, rather than worrying too much about the new features. We believe that once it is actually up and running, that the community will be more interested in helping improve and add features." <- 100%
06:13:13 <quchen> I'm guessing the Hackage automatization is, but what about the frontend generateion?
06:13:33 <dmwit> quchen: I think haskell.org is just mediawiki or some other super-standard wiki software.
06:13:42 <dcoutts> dmwit: your patches gratefully accepted :-)
06:13:50 <dmwit> =D
06:14:17 <dcoutts> quchen: I'm not sure I understand your question
06:14:26 <liyang> dcoutts: stupid idea, but compile-time flag for checked/unchecked arithmetic?
06:14:54 <liyang> (y'know, like what C compilers did/do‚Ä¶)
06:14:58 <quchen> dcoutts: I was just wondering how much of haskell.org was made out of Haskell (and not PHP etc.)
06:15:19 <liyang> (or did they?)
06:15:24 <dmwit> quchen: There's lots of subdomains at haskell.org...
06:15:26 <liyang> (no they didn't.)
06:15:37 <dcoutts> quchen: different bits use different things, as dmwit said the main haskell.org wiki is just mediawiki
06:15:57 <typoclass> as a thought experiment, how about Int and UnsafeInt?
06:16:16 <liyang> UnsafeInt is wordy. :<
06:16:31 <liyang> It's not *that* unsafe.
06:16:41 <typoclass> then let's abbreviate it to UInt... urgh no, wait :-)
06:16:41 <sipa> how about UInt... oh wait
06:16:48 <dcoutts> heh heh
06:16:48 <liyang> And sometimes the ‚Äòunsafe‚Äô behaviour is exactly what you want.
06:16:51 <sipa> !hi5 typoclass
06:17:02 <dcoutts> liyang: but then you should be using Int32 or Int64
06:17:09 <dcoutts> probably
06:17:28 <typoclass> liyang: well, sometimes unsafePerformIO is exactly what you want, but i think the name is still justified ...
06:17:52 <dcoutts> liyang: yeah, I'm not sure that sits well with haskell really, and different behaviour in different modules depending on flags
06:18:02 <liyang> dcoutts: I rely on Int being the native size for performance, instead of a bunch of #ifdefs to decide whether I should use Int32 or Int64‚Ä¶
06:18:27 <dcoutts> liyang: but if you do that (which is fine) then you are not relying on the wrapping
06:18:34 <dcoutts> because you don't know how big the type is
06:18:48 <liyang> Yes I do! Bits!
06:18:52 <dcoutts> bah
06:19:03 <dcoutts> but in practice you're not doing that
06:19:31 <liyang> Suppose I had something that works for both 32 and 64-bit Ints‚Ä¶
06:19:40 <dmwit> Okay, cabal-install switched to new-hackage, and hackage search keyword in browser switched to new-hackage's AWESOME search feature!
06:19:43 <dmwit> \o/
06:19:44 <dcoutts> you see what I mean, code that doesn't mind how big the type is, it just wants it to be fast, is not likely to be relying on mod 2^n wrapping
06:20:09 <dmwit> Now, does this mean that "cabal upload" is going to do the wrong thing?
06:20:15 <dcoutts> dmwit: wait, what awesome search feature? I thought it was pretty crummy
06:20:23 <dmwit> dcoutts: existing is AWESOME
06:20:28 <dcoutts> dmwit: oh heh, ok
06:20:41 <liyang> (We don't have any -f flags that change runtime behaviour? I'd be surprised were that the case‚Ä¶)
06:20:43 <dcoutts> dmwit: there's a lot that needs doing to it, it doesn't search tags yet for starters
06:20:52 <quchen> New-hackage has an AWESOME search feature?
06:20:56 <dcoutts> no!
06:21:06 <dcoutts> it's got a rudimentary search feature
06:21:07 <dmwit> quchen: It has a search feature! Isn't that AWESOME?
06:21:11 <dcoutts> that's in need if your patches :-)
06:21:13 <typoclass> we could, as a thought experiment, just come up with a prefix or suffix. LLInt (low-level int), BInt (bad int), FInt (flaky int), etc.
06:21:28 <quchen> I just typed in "comonad" and it gave me "comonad" packages. Pretty AWESOME
06:21:36 <quchen> (Hoogle doesn't do that.)
06:21:43 <dcoutts> dmwit: actually I've not checked yet, I think it should do the right thing, ie it'll upload to the new server
06:21:52 <typoclass> quchen: have you seen hayoo?
06:21:54 <typoclass> @where hayoo
06:21:55 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
06:21:59 <liyang> typoclass: CInt I guess would be fine.
06:22:18 <dmwit> dcoutts: Ah, bummer (for this, admittedly transitory, situation).
06:22:19 <quchen> typoclass: I know Hayoo, but I prefer Hoogle when possible. Because of the colors.
06:22:28 <typoclass> liyang: oh, good point. don't we have that already in Foreign.Somewhere ...
06:22:37 <dcoutts> dmwit: well, we do want you to test uploading too :-)
06:22:41 <merijn> Also, Hayoo usually functions terrible for me, I don't think you can search types?
06:22:44 <quchen> Hmm, the AWESOME search feature doesn't match package descriptions though. It's very rudimentary it seems.
06:22:52 <liyang> typoclass: yeah, it's just an alias for something.
06:22:56 <dcoutts> quchen: only package synopsis I think
06:22:59 <merijn> Is there a way to have a local hoogle that indexes all installed packages?
06:23:04 <quchen> dcoutts: Not even that
06:23:08 <dmwit> dcoutts: I think I'll have to switch cabal back to old-hackage then, or I'll undoubtedly forget. If I remember, I'll test uploading, but by default I want my package releases going where they can be seen. =P
06:23:13 <quchen> OH nevermind
06:23:14 <merijn> As hoogle doesn't index some stuff I use
06:23:14 <quchen> typo
06:23:25 <quchen> Sorry for doubting the search
06:23:32 <dcoutts> phew!
06:23:33 <liyang> So‚Ä¶ -fignore-asserts changes runtime behaviour. We actually make use of that.
06:23:38 <quchen> http://new-hackage.haskell.org/packages/find?name=dualization
06:23:40 <quchen> Yipee.
06:23:42 <dcoutts> liyang: yes, I was going to mention that
06:23:59 <liyang> In fact I indirectly made use of it today‚Ä¶
06:24:22 <linduxed> in a line like the following, i prefer to add the parenthesis to make things clear, but also because i'm never sure what binds tighter (or in what order)
06:24:25 <linduxed> newUnusedNodes = (unusedNodes `Set.difference` connectedNodes) `Set.union` newNode
06:24:27 <liyang> So SafeInt is basically Int wrapped in lots of asserts.
06:24:38 <linduxed> i've tested it in ghci, and i could remove those parens
06:24:45 <typoclass> btw, in my thought-experiment parallel-world variant of haskell, Int and Integer will be swapped, with the short name giving the safe behavior
06:24:55 <dmwit> linduxed: I think most people would have little objection to those parens.
06:24:57 <linduxed> but i don't understand the rule that says why i could do that
06:25:04 <linduxed> dmwit: yeah i guess so
06:25:13 <liyang> In which case -funchecked-arithmetic is no different from -fignore-asserts‚Ä¶(!)
06:25:14 <dcoutts> typoclass: what!? the bigger name is the bigger type! :-)
06:25:26 <linduxed> dmwit: but is there some way to have ghci tell me what binds when and "how strongly"/
06:25:29 <linduxed> ?
06:25:34 <dmwit> linduxed: For sure, use :i
06:25:59 <dmwit> linduxed: If it doesn't say something like "infixl 7", then it will have the default fixity.
06:26:00 <quchen> linduxed: Infix backticks, `foobar`, have fixity "infixl 9" by default.
06:26:16 <linduxed> oh yeah, the fixity thing
06:26:19 <dmwit> (Which I can never remember off the top of my head. Rumor has it that future GHCi's will show even thedefault fixity.)
06:26:24 <quchen> I don't remember many `XY` with non-default fixities, mostly quot, rem etc.
06:26:29 * linduxed will have to read up on fixity
06:26:42 <linduxed> i've only glanced over it
06:26:47 <typoclass> > succ `map` (pred `map` [1..3])
06:26:48 <dmwit> There's not much to it. Lower numbers bind tighter.
06:26:49 <lambdabot>   [1,2,3]
06:26:57 <typoclass> > (succ `map` pred) `map` [1..3] -- error
06:26:59 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `[b1]'
06:27:05 <dmwit> infixl means associate to the left when the numbers are the same; infixr associates right; infix throws an error.
06:27:10 <liyang> Wat. Higher fixities bind tighter‚Ä¶
06:27:14 <dmwit> uh
06:27:19 <typoclass> > succ `map` pred `map` [1..3] -- same error
06:27:20 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `[b1]'
06:27:23 <dmwit> Colud be. I often get that backwards.
06:27:31 <dmwit> I always check (+) and (*) when I need to know... =P
06:27:35 <quchen> Mnenonic for dmwit: $upertight
06:27:35 <quchen> ;-)
06:27:38 <liyang> dmwit: snap.
06:27:51 <nooodl> when i enter ":t (>>=)" in ghci i get a result like "(>>=) :: Monad m => m a -> (a -> m b) -> m b". is there a way to ask it to "fill in" the type signature for a specific Monad instance?
06:27:59 <liyang> dmwit: well, more crackle. I never remember their exact fixities.
06:28:07 <nooodl> i.e., something like [a] -> (a -> [b]) -> [b]
06:28:22 <nooodl> or Maybe a -> (a -> Maybe b) -> Maybe b, for Maybe... etc
06:28:26 <dmwit> nooodl: You can use `asAppliedTo`.
06:28:33 <quchen> :t (>>=) `asAppliedTo` Just 1
06:28:34 <lambdabot> Num a => Maybe a -> (a -> Maybe b) -> Maybe b
06:28:35 <dmwit> :t (>>=) `asAppliedTo` [1,2,3]
06:28:36 <lambdabot> Num a => [a] -> (a -> [b]) -> [b]
06:28:44 <nooodl> @type asAppliedTo
06:28:46 <lambdabot> (t -> b) -> t -> t -> b
06:28:48 <dmwit> :t (>>=) `asAppliedTo` []
06:28:49 <lambdabot> [a] -> (a -> [b]) -> [b]
06:28:56 <quchen> asAppliedTo = undefined :: (t -> b) -> t -> t -> b
06:29:02 <nooodl> cool!
06:29:13 <dmwit> asAppliedTo = const, no?
06:29:42 <quchen> Matches the type sig.
06:30:15 <dmwit> > ((+1) `asAppliedTo` 3) 4
06:30:17 <lambdabot>   5
06:30:47 <quchen> Excellent example
06:32:20 <quchen> Has anyone accomplished having persistent definitions in ghci.conf yet?
06:32:34 <quchen> I've got 'asAppliedTo' in there, but :r kills it as usual
06:32:40 <quchen> Or :l or something
06:34:19 <ski> quchen : perhaps put it in `$HOME/.ghci' ?
06:35:03 <quchen> That's not the problem I think. If you have 'let' bindings in ghci.conf, it's overwritten when you switch modules.
06:35:14 <quchen> Just like using :l X and then :l Y throws out X
06:35:17 <ski> oh, i see
06:35:38 <quchen> That's also the reason we can't make colored GHCi output hacks
06:35:56 <quchen> I looked at the source and gave up pretty quickly
06:40:45 <Radish> I need to support the c library that a cabal file requires
06:40:53 <Radish> How do I get that going?
06:41:28 <Radish> It says I need to install the system package that provides this library
06:41:38 <liyang> *That* is why you can't have nice things.
06:41:44 <Radish> would that be .exe?
06:42:05 <kurkale6ka> I am trying to understand Monads. If I get it correctly, the maybe Monad is pure, is that right?
06:42:27 <liyang> All monads are pure in their own ways.
06:43:15 <linduxed> kurkale6ka: have you seen this introduction? http://www.youtube.com/watch?v=ZhuHCtR3xq8
06:43:39 <liyang> (and Maybe prefers to be referred to with its name capitalised.)
06:44:23 <kurkale6ka> linduxed: I will have a look
06:44:36 <liyang> Unless you're referring to the proletarian maybe.
06:44:57 <quchen> maybe is monadic, its value is of Reader type ;-)
06:45:30 <typoclass> kurkale6ka: which part is confusing you? if you have code, please use hpaste
06:45:30 <liyang> Your mother is a Reader.
06:45:33 <typoclass> @where hpaste
06:45:33 <lambdabot> http://hpaste.org/
06:46:01 <Peaker> if a thread is within a "modifyMVar_" action, and is killed, does it roll back to release the MVar to the old value?
06:46:01 <liyang> (Sorry, slightly drunk.)
06:46:27 <dcoutts> Peaker: yes
06:46:45 <fryguybob> Radish: Your question doesn't give enough information for me to know how to help.  Can you paste the specific error you are getting on hpaste.org?
06:46:49 <Peaker> thanks
06:48:11 <quchen> Peaker: "An exception-safe wrapper for modifying the contents of an MVar. Like withMVar, modifyMVar will replace the original contents of the MVar if an exception is raised during the operation. This function is only atomic if there are no other producers for this MVar. "
06:48:31 <quchen> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent-MVar.html#v:modifyMVar_
06:48:37 <Radish> fryguybob: my command prompt doesn't allow me to copy and paste so this will take a minute
06:48:52 <quchen> Radish: Try right click after selecting
06:48:57 <quchen> Or Ctrl+Shift+C
06:49:17 <typoclass> Radish: are you on linux? in that case, you can highlight the text in the terminal, and in another window click the middle mouse button
06:49:21 <Radish> quechen: windows
06:49:21 <fryguybob> Radish: I'm assuming you are on Windows.  If you go to the control menu there are options for selecting and copying.
06:49:38 <Radish> its cmd.exe
06:49:48 <Radish> I don't know any control menu :(
06:49:51 <typoclass> Radish: try alt-space and selecting copy
06:49:53 <fryguybob> Radish: You might have more success with PowerShell
06:50:21 <t7> Radish, right click, click mark, select your text, right click again
06:50:30 <t7> no dont do the last step
06:50:59 <Radish> groovy that alt space works
06:51:04 <t7> actually yes you have to right click
06:51:25 <Radish> thanks t7 i think your method works too
06:52:02 <hpaste> BadRadish pasted ‚ÄúDependency‚Äù at http://hpaste.org/84715
06:52:04 <t7> good old windows making it so awkward to copy from console
06:52:39 <Radish> is linux much better than windows?
06:52:47 <Radish> i've been working up the courage to make the swithc
06:52:50 <fryguybob> Radish: Yes
06:53:07 <t7> the grass really is greener
06:53:09 <Radish> fryguybob: i'm scared I won't be able to get anything working ever
06:53:18 <typoclass> Radish: linux needs more babysitting ...
06:53:20 <Radish> i hear installation is a nightmare
06:53:43 <t7> use ubuntu or similar until your a pro, you will be fine
06:53:52 <Radish> I'm kind of waiting for an oportunity where I have two computers lol ;)
06:54:02 <fryguybob> Radish: There are baby steps where you don't have to commit completely :D
06:54:14 <Radish> hard drive partitioning, right?
06:54:23 <Botje> Radish: installation hasn't been a nightmare since 2003.
06:54:23 <Radish> use two OSs?
06:54:37 <Radish> botje: what changed?
06:54:40 <Botje> Radish: ubuntu allows you to install inside a file on existing partitions.
06:54:51 <Botje> no need to faff around with partitions if you don't want to.
06:54:59 <Botje> Radish: likewise, you can always create a virtual machine.
06:55:01 <fryguybob> Radish: You can use a VM
06:55:04 <arbn> Radish: There are fancy graphical installers now that do autoconfiguration magic.
06:55:32 <Radish> that sounds difficult lol
06:55:42 <Heffalump> if it's happened before then replace, I guess, but perhaps more at your convenience than panic call to etyres (though I think they were actually a decent cheap option last time I investigated)
06:55:45 <fryguybob> Radish: It isn't.
06:56:09 <Botje> Radish: http://virtualboximages.com/ has premade ubuntu VMs.
06:56:20 <Botje> just install virtualbox, download one of these images, and you're set.
06:56:31 <arbn> For Haskell programming, I think it's convenient to have some sort of Unix. Mac OS X or Linux.
06:57:06 <fryguybob> Radish: To fix your problem you will want to get a pre-built release of the portaudio library (not the haskell one) for windows.
06:57:34 <Radish> fryguybob: the download page has .tgz files
06:57:42 <Radish> http://www.portaudio.com/download.html
06:57:57 <Meat_Puppet> I need to create in haskell, an real exact exponential algorithm witch calculates the optimal solution(minimum numbers of bins to pack all the itens) for the bin packing problem: list of itens with variable sizes that needs to be packed into bins with size S, somebody can help me?
06:58:10 <Radish> I'm not terribly familiar with any of this lol
06:58:17 <fryguybob> Radish: I don't think any of those are binaries which makes it harder.
06:58:27 <dcoutts> dmwit: still here? something to show you
06:58:29 <Radish> I just want to write code and not deal with this crap lol
06:58:33 <Radish> :D
06:58:39 <franco00> I am looking for an acyclic graph library in haskell. Does it exist?
06:58:54 <Botje> Radish: then get a linux vm. it's ten times easier compilation-wise.
06:58:54 <franco00> (it's not that difficult to write some functions myself, just don't want to reinvent the wheel)
06:59:06 <Radish> fryguybob: so i need to create the binary for portAudio
06:59:11 <Radish> fryguybob: ?
06:59:14 <fryguybob> Yes
06:59:21 <fryguybob> http://portaudio.com/docs/v19-doxydocs/compile_windows_mingw.html
06:59:44 <fryguybob> Radish: If you installed the haskell platform you already have a mingw.
07:00:01 <Radish> i did
07:00:04 <quchen> franco00: Have you tried http://hackage.haskell.org/package/fgl-5.4.2.4
07:00:33 <franco00> oh, cool quchen , thanks
07:02:17 <fryguybob> Radish: It might be easiest to follow the directions from the page I linked, but to be honest it might take a while with a few dead ends to get it all working.
07:02:44 <Radish> fryguybob: yeah this is just a tiddle over my head but I'll give it a shot.
07:03:24 <Radish> fryguybob: once I do this, if I build a program it will run on any platform that both haskell and portaudio run on, right?
07:04:40 <fryguybob> Radish: Right (anyone should be able to compile, the binary you build will be Windows only).  Once you have that library built and installed (I recommend something like c:\opt\) you will need to tell cabal to look there.
07:11:23 <Radish> fryguybob: I got haskell working for the first time like twenty minutes ago...
07:11:34 <Radish> fryguybob: CABAL**
07:11:50 <Radish> fryguybob: I got cabal working for the first time like twenty mintues ago...**
07:12:18 <Radish> fryguybob: i think I can figure it out though, thank you so much.
07:12:59 <fryguybob> Radish: No problem.  I hope it works out.  Feel free to keep asking questions as they come up.
07:15:57 <cardamon> Hard part for me was figuring out how to read the intructions.
07:16:19 <cardamon> Debian's cabal package breaks Debian's own rule about man pages.
07:16:31 <cardamon> In that it doesn't have one.
07:19:42 <arbn> Yeah. A lot of Haskell programs don't have man pages.
07:20:46 <typoclass> cardamon: you've discovered "cabal help" and "cabal help install" and the like, right? also, it has a very good user manual on the web
07:21:04 <jeff_s1> Why are the "Numeric Types" in Foreign.C.Types not instances of Integral? They're just newtypes of integer types? The same question could be asked of Bits, Bounded, and perhaps some others.
07:21:36 <jeff_s1> That second sentence wasn't supposed to be a question.
07:21:53 <arbn> typoclass: You just saved me two keystrokes. I usually type "cabal --help" and "cabal install --help".
07:23:18 <jeff_s1> For instance, if I want to truncate a CTime to 10 seconds, I have to unwrap and re-wrap (CTime x) and (CTime y): truncateTo (Ctime x) (CTime y) = Ctime $ (x `div` y) * y
07:23:45 <jeff_s1> Or I have to implement my own Integral typeclass for CType, which only takes 3 lines, but feels like it should be in base.
07:24:34 <typoclass> jeff_s1: hm that's a good question. http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-Types.html suggests CInt, CChar and all kinds of types have Integral instances, but not CTime
07:26:12 <jeff_s1> Yup! I'm just wondering if anyone here knows why before I ask the libraries mail list.
07:26:44 <jeff_s1> I had a similar complaint before, when CTime and others didn't have their constructors exposed, forcing me to use unsafeCoerce.
07:26:51 <jeff_s1> I didn't speak up at the time, though.
07:28:18 <typoclass> jeff_s1: apparently folks discussed it already in 2007, but there was no good conclusion. nobody said "here is an extremely good reason why" or "here is an extremely good workaround" http://web.archiveorange.com/archive/v/nDNOvn1ticwudBminciV
07:30:06 <typoclass> jeff_s1: it does seem like a weird oversight, in particular because CTime is a newtype for Int64, and Int64 has an Integral instance
07:31:04 <jeff_s1> OK thanks, I'll escalate my complaint. :-)
07:32:54 <Peaker> does anyone know how to work with OpenGL in a threaded context? e.g: I want to parallelize two GL texture loading operations
07:36:11 <parcs> Peaker: you can only call opengl functions from the thread in which the context was created
07:38:50 <Peaker> parcs, No way at all to parallelize things?
07:39:19 <geekosaur> opengl does not support parallel operations
07:39:21 <jeff_s1> It turns out that CTime can technically be a floating point type, so I guess I won't complain.... on the other hand, my other googling suggests that there's no platform where CTime isn't an integer of some sort.
07:39:36 <geekosaur> I do not mean haskell opengl bindings, I mean the underlying opengl library
07:40:01 <parcs> Peaker: nope
07:40:17 <geekosaur> jeff_s1, there have been experiments with floating types, one of the problems is you lose precision in some cases
07:40:32 <geekosaur> this is often considered a bad thing with times
07:42:50 <typoclass> jeff_s1: but haskell makes CTime a newtype for Int64, doesn't it? so by definition we're not on a platform that uses floats for CTime :-)
07:48:11 * hackagebot hashable-extras 0.1.0.1 - Higher-rank Hashable  http://hackage.haskell.org/package/hashable-extras-0.1.0.1 (EdwardKmett)
07:53:11 * hackagebot lens 3.9.0.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.9.0.2 (EdwardKmett)
07:58:11 * hackagebot compensated 0.2.0.1 - Compensated floating-point arithmetic  http://hackage.haskell.org/package/compensated-0.2.0.1 (EdwardKmett)
07:58:13 * hackagebot log-domain 0.5.0.1 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.5.0.1 (EdwardKmett)
07:58:15 * hackagebot hash 0.2.0.1 - Hashing tools  http://hackage.haskell.org/package/hash-0.2.0.1 (EdwardKmett)
07:59:10 * merijn is imagining the Unreal Tournament announcer going "P-P-P-PRODUCTIVITY-Y-Y!"
07:59:34 <edwardk> heh
08:00:11 <edwardk> More like mortal combat: "FINISH IT!"
08:00:36 <edwardk> er kombat
08:01:02 <Nimatek> I always hear "P-P-P-PROCASTINATION!"
08:04:13 <merijn> Nimatek: Join the club
08:06:08 <ski> @hoogle club
08:06:08 <lambdabot> No results found
08:06:31 <centrinia> I imagine the Unreal Tournament announcer go: "DENIED!!"
08:08:45 * typoclass imagines the UT announce go "MEEEEOOOWW!!"
08:27:17 <nooodl> is there a nice way to define mapM without relying on sequence?
08:28:49 <byorgey> nooodl: well, you can define mapM directly via explicit recursion, and then define sequence in terms of mapM
08:29:18 <byorgey> I don't know what exactly you're looking for
08:29:25 <nooodl> something like that, yeah
08:30:50 <merijn> nooodl: Why would you want that, though?
08:31:07 <nooodl> i'm just trying to understand mapM
08:31:34 <centrinia> @source mapM
08:31:34 <lambdabot> mapM not available
08:31:35 <merijn> nooodl: The trick to understanding mapM is probably more about understanding sequence than about mapM itself
08:31:47 <centrinia> lambdabot is not as insulting as in the past.
08:32:00 <merijn> centrinia: "mapM f = sequence . map f"
08:32:24 <byorgey> my point was that you can also invert it, and say that the trick to understanding sequence is to understanding mapM
08:32:33 <byorgey> I think the real trick is to understand how the two are related. =)
08:32:50 <merijn> nooodl: What is it that confuses you about mapM?
08:32:51 <nooodl> sequence = mapM id, right?
08:32:56 <byorgey> nooodl: right
08:33:27 <merijn> Yes, since map id xs = id xs = xs
08:34:09 <nooodl> maybe i should try to understand sequence first
08:34:11 <hpaste> Quchen pasted ‚Äúsequence written out‚Äù at http://hpaste.org/84717
08:34:32 <nooodl> i was about to do exactly that
08:34:32 <quchen> ^ This is from my "functions_comprehensible" file that I wrote to understand mapM and foldM and so on.
08:34:33 <mgsloan> nooodl: also, mapM f = sequence . map f
08:34:35 <quchen> Maybe it's helpful
08:34:39 <nooodl> thanks, quchen
08:34:39 <merijn> and "mapM f = sequence . map f", so "mapM id = sequence . map id" => "mapM id = sequence . id" => "mapM id = sequence"
08:35:28 <quchen> nooodl: Basically, if you have a list of monadic things, sequence pulls out the value of each one and puts it in a list of that monad.
08:35:36 <armlesshobo> mapM takes a list and maps a monadic constructor to each value.
08:35:37 <quchen> > sequence [Just 1, Just 2, Just 3]
08:35:37 <armlesshobo> right?
08:35:38 <lambdabot>   Just [1,2,3]
08:35:44 <nooodl> oooh, i see why sequence does what it does for the list monad
08:35:50 <merijn> nooodl: Try these in ghci: "map print [1..10] !! 3" and "mapM print [1..10] !! 3", compare results
08:35:59 <quchen> "pull out 1, pull out 2, pull out 3; put everything in a Maybe-List"
08:36:04 <nooodl> that do notation expansion is just a list comprehension
08:36:08 <armlesshobo> mapM (\x -> case x of 0 -> Nothing; _ -> Just x) [1,2,3,4]
08:36:15 <armlesshobo> > mapM (\x -> case x of 0 -> Nothing; _ -> Just x) [1,2,3,4]
08:36:16 <lambdabot>   Just [1,2,3,4]
08:36:39 <byorgey> merijn: well, the second one doesn't type check
08:36:40 <quchen> nooodl: do notation is somewhat similar to list comprehensions sometimes, yes.
08:36:44 <merijn> Actually, I guess my second example is a type error, silly me
08:37:03 <hpaste> Quchen pasted ‚ÄúmapM written out‚Äù at http://hpaste.org/84718
08:37:06 <merijn> quchen: By "somewhat similar" you mean "almost identical", right?
08:37:58 <byorgey> they are actually isomorphic for the list monad.  And with the MonadComprehensions extension turned on, you can use list comprehension syntax for any monad!
08:38:14 <byorgey> well, you need MonadPlus if you use guards.
08:38:32 <tom4939_> quchen: Isn't list comprehension syntax sugar for do-notation (which is sugar for bind ofc)?
08:39:00 <byorgey> tom4939_: I think list comprehensions are desugared directly to functions like filter and map, not to do-notation
08:39:01 <quchen> tom4939_: That would be one way to implement list comprehensions, yes.
08:39:02 <tom4939_> Oh, that's what the previous two lines said.
08:39:15 <roadfish> I noticed that case works with otherwise _other _otherwise ... why does Haskell have all the different versions?
08:39:37 <byorgey> roadfish: it doesn't.
08:39:49 <tom4939_> quchen: Ah sure, haskell implementations may choose an alternative implementation for performance reasons or whatnot.
08:39:53 <hpc> > case 1 of otherwise -> otherwise
08:39:55 <lambdabot>   1
08:39:56 <byorgey> roadfish: it works with eroifjergawlij too, try it!
08:39:59 <hpc> > otherwise
08:39:59 <quchen> roadfish: _ basically means "whatever". Sometimes you'd like to indicate which "whatever", so you call it "_something"
08:40:01 <lambdabot>   True
08:40:03 <hpc> :t otherwise
08:40:05 <lambdabot> Bool
08:40:18 <byorgey> roadfish: any variable name is a pattern which matches anything, so it doesn't matter what name you use
08:40:41 <quchen> tom4939_: The Haskell report says "list comprehensions satisfy these laws" and that's it. I'm not sure what GHC does internally.
08:40:46 <byorgey> roadfish: in fact for a default in a case expression, it's best to use _ instead of 'otherwise'
08:40:48 <roadfish> ok, so is really just: case 1 of _ -> 33
08:41:01 <byorgey> 'otherwise' is defined to be 'True', for use in guards
08:41:03 <merijn> roadfish: Yes, assuming the result clause doesn't use the same name
08:41:06 <quchen> tom4939_: For all practical purposes, list comprehensions are the same as do notation.
08:41:09 <roadfish> good. I'll switch to _ ... much shorter
08:41:34 <merijn> roadfish: _ and variable names are indistinguishable, but _ doesn't produce a warning if you don't plan to use the match
08:41:41 <hpc> list comprehensions can in fact be directly translated into do-notation (and i believe they are in ghc)
08:42:01 <hpc> older haskell standards had fully-generic monad comprehensions
08:42:14 <hpc> and there's an extension to get it back
08:42:38 <quchen> hpc: I'm not sure about that do notation thing. Guards for example may produce lots of [], which could be inefficient. Maybe having special handling can eliminate that
08:42:58 <roadfish> so list comprehensions are translated into do-notation which is then translated into >>=/return?
08:43:06 <hpc> and guard
08:43:08 <hpc> :t guard
08:43:09 <lambdabot> MonadPlus m => Bool -> m ()
08:43:22 <byorgey> roadfish: They *could* be, but I doubt it actually works that way in GHC.
08:43:30 <hpc> [expr | name <- action, action, boolean]
08:43:32 <hpc> translates to
08:43:46 <hpc> do {name <- action; action; guard boolean; return expr}
08:43:51 <quchen> [ x | x <- [1..10], even x ]   ==   [1..10] >> \x -> guard (even x) >>= return x
08:44:07 <quchen> = in the wrong place, woops
08:44:19 <quchen> [ x | x <- [1..10], even x ]   ==   [1..10] >>= \x -> guard (even x) >> return x
08:45:48 <byorgey> the code that actually desugars list comprehensions is here:  https://github.com/ghc/ghc/blob/master/compiler/deSugar/DsListComp.lhs
08:46:09 <byorgey> too bad the formatting is screwed up and it's impossible to read on that page
08:46:30 <quchen> And if you click on "raw" it doesn't get better
08:46:32 <tom4939_> https://raw.github.com/ghc/ghc/master/compiler/deSugar/DsListComp.lhs
08:46:48 <merijn> @ask mm_freak Ah, right. If your example had used ReaderT IO instead of Reader for the Wire monad then the example could've used stepSession directly, right?
08:46:49 <lambdabot> Consider it noted.
08:48:15 <byorgey> hah, it looks like it actually desugars directly into calls to 'foldr' and 'build'
08:48:27 <mm_freak> merijn: it's better to highlight me directly, otherwise you may find yourself waiting a few days for the answer =)
08:48:31 <nooodl> > let mapM' f [] = return []; mapM' f (x:xs) = f x >>= \r -> liftM (r:) (mapM' f xs) in mapM' (\x -> [x,-x]) [3,4]
08:48:33 <lambdabot>   [[3,4],[3,-4],[-3,4],[-3,-4]]
08:48:40 <nooodl> hell yeah
08:48:50 <mm_freak> merijn: in the case of ReaderT the outer computation must be a ReaderT as well when using stepSession
08:48:59 <mm_freak> merijn: in most cases even that's not what you want
08:49:18 <byorgey> nooodl: nice!
08:49:28 <mm_freak> the ReaderT carries information about the current instant and may change between instants
08:49:37 <merijn> mm_freak: I'm never sure when you're around :p
08:49:44 <mm_freak> so what you really want is:  runReaderT (stepWire w dt x) s
08:49:53 <mm_freak> merijn: you don't have to be =)
08:50:08 <mm_freak> merijn: as long as i'm online i receive the highlight as soon as i go to my computer =)
08:51:19 <nooodl> ooh, found something even nicer
08:51:22 <nooodl> > let mapM' f [] = return []; mapM' f (x:xs) = do { r <- f x; rs <- mapM' f xs; return (r:rs) } in mapM' (\x -> [x,-x]) [3,4]
08:51:23 <lambdabot>   [[3,4],[3,-4],[-3,4],[-3,-4]]
08:51:40 <merijn> What did you mean by "the outer computation must be a ReaderT as well"?
08:57:08 <merijn> mm_freak: i.e. in my case I have a "global" set of input state that doesn't change overtime that should go to all the wires
09:03:26 <mm_freak> merijn: your application loop basically
09:03:46 <mm_freak> merijn: if that's the case you can put everything into the ReaderT
09:04:07 <mm_freak> and then you can use stepSession
09:04:39 <merijn> Yeah, that's what I figured
09:04:45 <fxr> hmm may I ask another simplification for this lens expression in a state monad? "x <- uses listeners (flip (M.!) idx)"
09:04:57 <merijn> The same holds for RWST, I guess?
09:05:42 <merijn> fxr: M.! is the indexing function for Data.Map (probably), so "m ! x" looks up the key x in m.
09:06:17 <merijn> fxr: The flip is just there to avoid a confusing section "(M.! idx)"
09:06:47 <fxr> actually I'm looking for a simplification for the lens side
09:07:02 <fxr> there should be an operator for Indexed maps
09:07:53 <fxr> merijn: thanks, it looks better now
09:09:38 <edwardk> fxr: use (listeners.ix idx)
09:09:56 <edwardk> or use $ listeners.ix idx
09:11:30 <edwardk> actually that is a lie
09:11:40 <fxr> yeah I guessed
09:11:42 <edwardk> because the lens for 'ix' doesn't know you assume the element to actually be there
09:11:50 <mm_freak> merijn: yes
09:11:53 <edwardk> so it only gives you a traverse
09:12:00 <edwardk> preuse $ listeners.ix idx
09:12:10 <supki> Just x <- use (listeners . at idx) ?
09:12:14 <edwardk> will give you a preview (that is as a Maybe) in case the element isn't in the list.
09:12:14 <mm_freak> merijn: however, i always keep the monad of the application loop separate from the wire's monad
09:12:18 <edwardk> supki's suggestion works
09:12:40 <edwardk> also use $ listeners.singular (ix idx)
09:13:22 <edwardk> we don't offer non-total lenses by default, but instead offer traversals that you can choose to assert are total by using singular or reading with ^?!    sadly we don't have a 'use' equivalent for ^?!
09:13:46 <fxr> thank you very much
09:14:26 <merijn> mm_freak: For any specific reason?
09:14:37 <edwardk> fxr: but in general 'at' and 'ix' can be used to index into any indexed container.
09:14:55 <edwardk> > M.fromList [(2,"hello")]^.at 2
09:14:56 <lambdabot>   Just "hello"
09:15:00 <edwardk> > M.fromList [(2,"hello")]^.at 3
09:15:02 <lambdabot>   Nothing
09:15:23 <edwardk> that is a lens that lets you view any field of a map as Maybe its contents.
09:15:31 <edwardk> > M.fromList [(2,"hello")] & at 2 .~ Nothing
09:15:34 <lambdabot>   fromList []
09:15:35 <fxr> pretty clear
09:15:45 <fxr> I am exactly looking for at and ix.
09:15:46 <mm_freak> merijn: composability‚Ä¶  the wire is usually pure only needing some environment information
09:16:09 <edwardk> ix on the other hand is a traversal, not a lens. that means it can be used to edit something _only if it is already there_
09:16:21 <edwardk> > M.fromList [(2,"hello")] & ix 2 .~ "goodbye"
09:16:23 <lambdabot>   fromList [(2,"goodbye")]
09:16:26 <edwardk> > M.fromList [(2,"hello")] & ix 3 .~ "goodbye"
09:16:28 <lambdabot>   fromList [(2,"hello")]
09:16:40 <edwardk> > M.fromList [(2,"hello")] & at 3 .~ Just "goodbye"
09:16:42 <lambdabot>   fromList [(2,"hello"),(3,"goodbye")]
09:17:03 <edwardk> > M.fromList [(2,"hello")] & at 3 ?~ "goodbye" -- we can implicitly bolt the Just on the result with ?~ instead of .~
09:17:04 <lambdabot>   fromList [(2,"hello"),(3,"goodbye")]
09:17:20 <fxr> hmm, how about setters like "_ <- listeners %= M.insert (fromInteger i) h"
09:17:42 <fxr> can I simplify it more?
09:17:57 <edwardk> listeners.at (fromInteger i) ?= h
09:18:00 <glguy> You don't need to _ <- the %= operator
09:18:39 <fxr> glguy: yeah I added specifically for explanation
09:19:03 <glguy> That silly warning is why we have to have the <%= operator
09:19:48 <edwardk> yeah. half the operators in lens are caused by the 'you didn't remember to use that' police.
09:20:26 <otters> edwardk: omg i didn't realize that
09:20:38 <otters> i've been using .~ (Just ...)
09:20:44 <otters> shame on me
09:20:46 <edwardk> otters: =)
09:20:55 <edwardk> ?= and ?~ are pretty handy for playing with maps.
09:20:55 <lambdabot> Maybe you meant: . ? @ v
09:21:00 <edwardk> if nothing else they kill a lot of parens
09:21:07 <fxr> exactly
09:21:53 <fxr> but it's hard to find the right operators at the beginning
09:22:02 <coppro> edwardk: oh, hey, I like that solution of indexing
09:22:09 <coppro> edwardk: I vaguely recall we discussed it a while back
09:22:45 <otters> yeah there are so many operators in lens it's hard to find the right ones
09:23:00 <edwardk> i usually recommend folks to start with the basic ones
09:23:04 <edwardk> then learn the others as needed
09:23:28 <edwardk> in general if you ever wind up using the same lens twice in a chunk of code its because you didn't spot that there was a way to fuse both accesses together
09:23:36 <edwardk> and that is a good time to pop on #haskell-lens and ask
09:23:46 <glguy> Same lens twice?
09:24:03 <edwardk> glguy: e.g. reading from foo.at 2     and then later writing to foo.at 2  in the same block of code
09:24:04 <fxr> aha, a separate # for lens
09:24:10 * fxr joins...
09:24:26 <glguy> edwardk: Ah, OK.
09:24:47 <edwardk> glguy: most of the time that is better served by doing something smarter with the foo.at 2 lens that lets you share the work getting down with the work coming back up
09:24:55 <edwardk> and the result often has a more permissive type signature, etc.
09:25:21 <edwardk> After all that work put into defining cloneLens, etc. I basically find the need for them to be a sign that you're using the wrong combinators
09:25:49 * edwardk has to run.
09:26:10 <merijn> mm_freak: mmmm, I basically have a world state that gets mutated by the wires and some output IO events (networking) that get produced. I'm just not really sure whether I should just have the Wire use the RWST IO monad and carry the world state in State and do the networking directly in the wire, or just use a pure RWS wire that stuffs the networking in the Writer and runs everything at the end
09:27:27 <mm_freak> merijn: it's a tradeoff‚Ä¶  you should have tried both before you can make a real judgement
09:28:48 <merijn> ok, I'll just try RWST IO first, because then I can just get away with stepSession :p
09:45:51 <armlesshobo> i'm trying to do error handling, but am unsure about how to go about it.
09:46:00 <armlesshobo> really, i'm not sure if i should just use error
09:46:20 <armlesshobo> or come up with my own instance of the Error monad
09:47:18 <armlesshobo> I'm only checking if a file exists and is readable, but want to error out with the appropriate message
09:47:49 <armlesshobo> also, if the user put supplied an argument (this will be run in a terminal)
09:48:28 <armlesshobo> so, for three simple error cases, is it worth using the Error monad or just calling error?
09:49:57 <merijn> armlesshobo: It depends on the kind of error and how you want to handle it
09:50:16 <merijn> armlesshobo: If you say "if the file exists I'm just going to quit" then personally I think error is fine
09:50:36 <merijn> eh...doesn't exist, obviously
09:50:56 <armlesshobo> merijn: yeah, it's nothing too serious where I'd need to do special error handling.
09:51:36 <merijn> If you need to do things like "check if file exists, if yes do X else do Y" you'd prefer to use Maybe to handle that sort of scenario
09:51:37 <armlesshobo> merijn: i really just want to output a message and exit. really, i can't continue if those cases aren't met.
09:51:57 <merijn> armlesshobo: Then just go with error for now
09:52:02 <armlesshobo> merijn: ok, thank you
10:00:43 <mm_freak> merijn: i must say i'm inclined to remove stepSession‚Ä¶  i find using sessionUpdate + stepWire more sensible
10:01:17 <mm_freak> the monads simply aren't related
10:03:12 <mm_freak> if anything a monad morphism argument should be added to stepSession
10:03:24 <mm_freak> forall a. mw a -> m a
10:03:33 <merijn> My biggest annoyance is sessionUpdate and manually passing it to stepWire feels so redundant/unnecessary
10:07:09 <ehamberg> petterw: √Ønteresting
10:08:14 <pettter> ehamberg: ECHAN?
10:08:35 <pettter> or potentially wrong user :)
10:08:40 <mm_freak> merijn: it wouldn't be as annoying if i had called it "stepClock" instead =)
10:09:11 <mm_freak> (dt, c) <- stepClock c
10:09:11 <mm_freak> (mx, w) <- stepWire w c x
10:09:11 <ehamberg> pettter: ECHAN :)
10:09:16 <mm_freak> uh
10:09:24 <mm_freak> couldn't have written this more buggy =)
10:09:28 <mm_freak> (dt, c) <- stepClock c'
10:09:32 <pettter> :)
10:09:35 <mm_freak> (mx, w) <- stepWire w' dt x'
10:09:41 <mm_freak> there we go =)
10:10:45 <merijn> But I want things to work by magic :(
10:11:03 <mm_freak> merijn: they will‚Ä¶  i'm already working on the next netwire =)
10:11:47 <merijn> btw
10:11:52 <mm_freak> but i'm not going to merge sessionUpdate and stepWire‚Ä¶  i'm going to make the session value polymorphic and introduce wire monad morphisms
10:12:23 <merijn> What's the point of doing "mx `seq`" for the key up/down things in http://hpaste.org/83098?
10:12:32 <merijn> I don't think mx is ever actually used anywhere?
10:13:15 <mm_freak> merijn: wires can be interpreted as streams, so the 'seq' is akin to the difference between foldl and foldl'
10:13:54 <merijn> But if mx isn't used anywhere, shouldn't it just get discarded regardless of whether it's seq'ed?
10:14:26 <mm_freak> merijn: if it were that easy =)
10:14:35 <mm_freak> remove the seq and benchmark =)
10:14:41 <merijn> I think I'm missing something crucial about this...
10:15:12 <linduxed> i've got a function that in ghci get's through one recursion whereafter i get *** Exception <<loop>>
10:15:22 <linduxed> how could i check what's making it explode?
10:15:33 <linduxed> besides staring at my code for hours?
10:15:45 <merijn> linduxed: Debug.Trace.trac?
10:15:50 <merijn> :t Debug.Trace.trace
10:15:52 <lambdabot> String -> a -> a
10:15:56 <linduxed> merijn: already doing that
10:16:04 <mm_freak> merijn: the point is that mx does not get fully garbage-collected‚Ä¶  the intermediate representations stay in memory
10:16:05 <merijn> Ah, then I have no clue
10:16:44 <mm_freak> linduxed: make sure all your recursions are either productive or consuming
10:16:57 <linduxed> mm_freak: and that can be checked how?
10:17:04 <mm_freak> linduxed: by looking at your code
10:17:12 <mm_freak> productive:  f x = x : f (g x)
10:17:24 <linduxed> so "starting at my code for hours" then
10:17:37 <mm_freak> consuming:  f (x:xs) = ‚Ä¶ f xs ‚Ä¶
10:17:47 <linduxed> ok
10:17:48 <mm_freak> not consuming:  f (x:xs) = ‚Ä¶ f (x:xs) ‚Ä¶
10:17:49 <linduxed> well
10:17:58 <linduxed> it's hard for me to figure this out....
10:18:00 <linduxed> hmmm
10:18:07 <mm_freak> not productive:  f x = f (‚Ä¶ x ‚Ä¶)
10:18:18 <linduxed> i'll have another look at this, then i'll post snippets
10:20:27 <mm_freak> linduxed: the point is:  when you have a recursive function that produces some structure (like a list), you generally want it to produce before recursion
10:20:44 <linduxed> well this isn't producing or consuming
10:20:50 <mm_freak> then it consumes a structure, you generally want it to have consumed at least one layer before recursion
10:20:51 <linduxed> it's... mutating a structure
10:20:55 <simon> if FP is considered declarative, how can you justify an evaluation strategy like ML's where you do put thoughts into the order that expressions are calculated? that carries an implicit imperative with it, doesn't it? I mean, compared to Prolog's ! explicit backtrack operator.
10:21:15 <mm_freak> linduxed: so not a pure algorithm?
10:21:18 <zachk> > foldr (\x y->(y+1) 0 $ (,) <$> [1..8] <*> ['a'..'h']
10:21:19 <lambdabot>   <hint>:1:53: parse error (possibly incorrect indentation)
10:21:29 <linduxed> mm_freak: http://en.wikipedia.org/wiki/Neighbor_joining
10:21:42 <zachk> > foldr (\x y->y+1) 0 $ (,) <$> [1..8] <*> ['a'..'h']
10:21:44 <lambdabot>   64
10:21:58 <zachk> yet another way to count the number of squares on a chess board
10:22:06 <simon> @pl foldr (\x y -> y + 1) 0
10:22:06 <lambdabot> foldr (const (1 +)) 0
10:22:09 <simon> hm.
10:22:16 <zachk> ahh
10:22:29 <zachk> i tried that a minute ago in ghci, couldn't work out the details thought, thank you
10:22:49 <qwr> imho there are quite many definitions of fp, and not all require being declarative
10:23:16 * hackagebot multiarg 0.12.0.0 - Combinators to build command line parsers  http://hackage.haskell.org/package/multiarg-0.12.0.0 (OmariNorman)
10:23:18 * hackagebot rainbow 0.2.0.0 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.2.0.0 (OmariNorman)
10:23:41 <zachk> personally, I would roughly say one of the things you need for any sort of FP is just first class functions, and other features that allow the easy use of such
10:23:42 <zenzike_> jjjj
10:24:11 <zachk> rainbow!! wow that was actually stewing in my mind like an hour ago.. interesting :D
10:24:51 <mm_freak> linduxed: doesn't look like an imperative algorithm to me‚Ä¶  by "mutating" do you actually mean using destructive update?
10:26:20 <Shin-LaC> guys
10:26:37 <Shin-LaC> when I install ghc 7.4.2 (either from binary or from source), some packages are broken
10:26:41 <linduxed> mm_freak: i might be using incorrect terminology, but what i meant was that i take an input matrix, extract the data into a couple of data structures and pass around those structures to the same loop over and over, each time manipulating each of those structures
10:27:04 <linduxed> mm_freak: until the things i pass around fulfill a set of requirements
10:27:14 <mauke> Shin-LaC: do you mean packages coming with ghc?
10:27:21 <Shin-LaC> hxt, network, hxt-unicode, hxt-regex-xmlschema, hxt-charproperties, Cabal
10:27:22 <Shin-LaC> mauke: yes
10:27:38 <mauke> those don't come with ghc
10:27:45 <Shin-LaC> they do now
10:27:49 <mauke> platform?
10:27:54 <Shin-LaC> os x
10:28:09 <mauke> heh. no, I meant "are you installing the Haskell Platform?"
10:28:16 * hackagebot prednote 0.2.0.0 - Build and evaluate trees of predicates  http://hackage.haskell.org/package/prednote-0.2.0.0 (OmariNorman)
10:28:16 <Shin-LaC> no, I'm not
10:28:27 <Shin-LaC> I want to install the haskell platform later
10:28:27 <mauke> then I don't understand
10:28:32 <Shin-LaC> which is why I'm using 7.4.2
10:28:36 <Shin-LaC> 7.6.2 doesn't have this problem
10:28:39 <dmwit> dcoutts: pong
10:28:42 <Shin-LaC> but it's not compatible with hp
10:28:43 <mauke> o_O
10:28:59 <armlesshobo> i'd use just haskell-platform
10:29:10 <armlesshobo> that's what i do. it happens to come with ghc for me
10:29:22 <Shin-LaC> but I want to install it in a different location
10:29:39 <Shin-LaC> so I can't just use the HP binary package
10:29:56 <armlesshobo> Shin-LaC: you just want ghc in a different location?
10:29:56 <mm_freak> linduxed: in haskell to make sure that your program terminates, make make sure that your traversals are total
10:30:01 <merijn> Shin-LaC: Why do you want to install it in a different location, though?
10:30:14 <Shin-LaC> armlesshobo: hp too
10:30:17 <mm_freak> linduxed: the easiest way to do it is to express your traversals in terms of folds
10:30:34 <armlesshobo> why can't you install HP in a different location?
10:30:34 <Shin-LaC> merijn: I'm trying to install it through home-brew, a package manager
10:30:53 <armlesshobo> Shin-LaC: you can download it off of the website
10:30:55 <mm_freak> linduxed: but as you seem to be a beginner, i don't want to bombard you with new terminology‚Ä¶  put in simple terms:  make sure you destruct
10:30:59 <merijn> Shin-LaC: Why?
10:31:25 <Shin-LaC> merijn: because then I can keep track of what I have installed, and uninstall or upgrade it easily
10:31:35 <mm_freak> linduxed: always recurse with structurally smaller arguments (the tail of a list, one branch of a tree, etc.)
10:31:43 <linduxed> mm_freak: honestly, if i don't sort this shit out soon, i'll just post a link to my repo with explanations, because otherwise this will just be useless theorycrafting
10:32:20 <merijn> Shin-LaC: The binary install of Haskell Platform on OSX comes with an uninstaller that removes everything and uninstalling stuff installed with cabal is just a matter of nuking ~/.ghc and ~/.cabal
10:32:38 <mm_freak> linduxed: this is practical‚Ä¶  unfortunately i'm not familiar with the algorithm, so i can only express in words what i mean
10:32:50 <newsham> merijn: unless you install global
10:32:59 <merijn> Installing platform using homebrew and macports is just a painful exercise without much arguments in favour, in my experience
10:33:06 <merijn> newsham: But you shouldn't be doing that anyway...
10:33:11 <linduxed> mm_freak: i'm sure you'll see errors regardless of whether you're familiar with the alg
10:33:13 <newsham> why?
10:33:16 * hackagebot prednote 0.4.0.0 - Build and evaluate trees of predicates  http://hackage.haskell.org/package/prednote-0.4.0.0 (OmariNorman)
10:33:26 <Shin-LaC> oh
10:33:26 <newsham> merijn: i dont want a package existing for every user
10:33:32 <Shin-LaC> apparently the problem was ~/.ghc
10:33:32 <mm_freak> linduxed: <<loop>> means that something is defined by referring to itself in a strict manner:  let x = x in x
10:33:46 <Shin-LaC> after removing it, the error is gone
10:33:50 <mm_freak> linduxed: "to see what x is, see x"
10:33:57 <mm_freak> that's <<loop>>
10:34:12 <armlesshobo> mm_freak: what's the issue?
10:34:23 <linduxed> mm_freak: hmm, i'll consider that
10:34:32 <mm_freak> armlesshobo: linduxed gets a <<loop>> and is searching for the bug
10:34:56 <mm_freak> armlesshobo: and i'm failing to explain what productive/consuming recursion means =)
10:35:14 <armlesshobo> hmmm
10:35:32 <linduxed> don't worry
10:35:37 <Shin-LaC> merijin: thanks for the hint about nuking ~/.ghc
10:35:44 <Shin-LaC> that was the missing piece
10:35:48 <linduxed> i'm committing some stuff now which finishes most of the alg
10:35:52 <linduxed> still not working
10:36:00 <linduxed> but it will be something i can post a link to
10:36:11 <armlesshobo> linduxed: you're looping because you provide no edge case?
10:36:23 <linduxed> armlesshobo: you'll see in a sec
10:36:32 <Shin-LaC> btw, afaict the haskell-platform binaries still have this issue: http://hackage.haskell.org/trac/ghc/ticket/7040
10:36:37 <dmwit> dcoutts: (okay, disappearing again)
10:36:50 <mm_freak> linduxed: the classic explanation is:  you don't have a base case in some of your tail recursions‚Ä¶  or you have tail recursion where you really don't want it =)
10:37:06 <mm_freak> i've tried to explain this more fundamentally, so that you don't run into this issue again
10:37:39 <armlesshobo> if you provide a list to a function, then your edge case would be the condition that tells you you're done, which would be []
10:37:54 <armlesshobo> now, you'd also need to make sure you actually come across this case
10:38:04 <mm_freak> armlesshobo: failing to provide that wouldn't end in a <<loop>>
10:38:17 <mm_freak> rather something like this:  f (x:xs) = f (x:xs)
10:38:27 <armlesshobo> that would cause to loop
10:38:30 <armlesshobo> <<loop>>
10:38:33 <hpaste> merijn pasted ‚Äúnetwire mainloop compile error‚Äù at http://hpaste.org/84720
10:38:53 <merijn> mm_freak: Any clue what I'm screwing up there?
10:39:16 <Taneb> armlesshobo, I don't think Haskell can detect that
10:39:53 <Taneb> > let f (x : xs) = f (x : xs) in f "hello"
10:39:57 <lambdabot>   mueval-core: Time limit exceeded
10:40:20 <mm_freak> merijn: are you sure that your types are right?  add a type signature for 'loop'
10:40:26 <armlesshobo> Taneb: right, but he's trying to find where his code is causing this loop
10:40:41 <linduxed> mm_freak: alright, here we go: https://github.com/linduxed/progp-molbio/blob/evoltree/NJ.hs
10:40:45 <mm_freak> Taneb: it detects that, but only when you compile
10:40:48 <armlesshobo> as far as haskell is concerned, this is correct. semantically, though, it's not.
10:40:50 <mm_freak> <<loop>> is a feature of the RTS
10:40:52 <Taneb> I don't think I've ever actually seen <<loop>>
10:40:59 <linduxed> mm_freak: so the issue lies with the function "neighbor"
10:41:14 <dEPY> Just a dumb question...
10:41:26 <merijn> Adding "loop :: AppWire () () -> Session IO -> IO ()" results in the same error
10:41:28 <linduxed> i should start by saying that "createDMapWithConnectingNode" (while really ugly) works as it should. this i've verified
10:41:53 <mm_freak> linduxed: ok, just as a side note, that's definitely pure code =)
10:42:00 <dEPY> Do you guys think that when hiring, someone who knows at least Haskell basics is worth more just for the sake that he was curious enough to learn it?
10:42:17 <mm_freak> dEPY: yes
10:42:18 <linduxed> mm_freak: ok, i would have assumed it was
10:42:32 <merijn> oh, maybe the stepWire case is wrong...
10:43:08 <linduxed> dEPY: well he'll most likely be familiar with the concept of functional programming, along with some other things that enrich you as a developer
10:43:27 <armlesshobo> linduxed: what arguments did you provide "neighbor"
10:43:31 <dEPY> I thought so.
10:43:48 <linduxed> armlesshobo: i do :load tests.hs
10:43:51 <linduxed> armlesshobo: then
10:43:59 <linduxed> armlesshobo: neighbor $ makeDistanceMatrix $ convertSeqs shortDNAs
10:44:29 <linduxed> armlesshobo: or well... you could substitute "shortDNAs" with set found in the tests.hs file, same exception anyway
10:44:43 <merijn> mm_freak: Right now I'm not even sure which random bits I should fiddle with to get it to work...
10:45:31 <armlesshobo> linduxed: have you tried stepping through with ghci?
10:45:36 <armlesshobo> well
10:45:37 <armlesshobo> nvm
10:45:40 <linduxed> armlesshobo: nope, don't know how
10:46:00 <linduxed> i have tried adding a lot of trace output on line 64
10:46:17 <linduxed> but all that got me was that i realized that it only does one iteration before failing
10:46:42 <mm_freak> linduxed: at a first glance i don't see any trivial <<loop>>s there‚Ä¶  are you sure your algorithm indeed terminates?
10:47:04 <linduxed> mm_freak: well, just looking at "neighbor"
10:47:19 <linduxed> mm_freak: i know that createDMapWithConnectingNode works
10:47:32 <mm_freak> linduxed: another way to explain <<loop>>:  the run-time system has found a trivial non-productive infinite recursion
10:47:32 <fryguybob> linduxed: newDMap = ... connectingEdges ; connectingEdges = ... newDMap  Are you sure this terminates?
10:47:47 <linduxed> fryguybob: what line?
10:48:02 <fryguybob> 69-70
10:48:06 <mm_freak> linduxed: in other words:  it can either busy-loop forever or just tell you that it would busy-loop forever by printing <<loop>> and exiting =)
10:48:16 * hackagebot penny-lib 0.10.0.0 - Extensible double-entry accounting system - library  http://hackage.haskell.org/package/penny-lib-0.10.0.0 (OmariNorman)
10:48:22 <linduxed> fryguybob: hmmm, lemme think
10:49:48 <linduxed> fryguybob: hmmm, i know that createDMapWithConnectingNode returns correctly, so the only problem would be if connectingEdges didn't
10:50:36 <linduxed> fryguybob: ooooh waaait a minute
10:50:43 <sg> so i'm having a bit of a struggle with parsec right now
10:50:44 <sg> https://github.com/cbarcenas/MoCap/blob/6b84d5431399afae35792679ef3734bc2ab40f8e/Data/MotionCapture/AMC/SkeletonParser.hs#L66
10:50:56 <linduxed> fryguybob: that could be it... newDMap referencing itself
10:51:04 <linduxed> fryguybob: lemme read this a couple of time
10:51:17 <sg> is there a way to fix that so that i can have another "unknown" descriptor be ignored by the parser?
10:53:12 <linduxed> YES
10:53:15 <linduxed> !
10:53:17 * hackagebot penny-bin 0.10.0.0 - Extensible double-entry accounting system - binary and documentation  http://hackage.haskell.org/package/penny-bin-0.10.0.0 (OmariNorman)
10:53:20 <merijn> mm_freak: ok, I'm giving up for now, I can't figure out why it complains about an escaped type variable
10:53:22 <linduxed> fryguybob: you were exactly right!
10:53:31 <fryguybob> linduxed: Excellent!
10:53:38 <linduxed> i must have missed that while renaming some functions
10:53:42 <companion_cube> sounds like a bounded type variable that would escape
10:54:03 <linduxed> so 69-70 was self-referencing
10:54:07 <armlesshobo> linduxed: noice
10:54:18 <mm_freak> merijn: which Session are you using?  a custom one?
10:54:22 <linduxed> other than that it works just as it should
10:54:24 <merijn> clockSession
10:54:33 <linduxed> the minor errors... always so frustrating
10:54:34 <armlesshobo> btw. to use ghci's tracing, you do :break neighbor, and then call the function like you normally would
10:54:39 <armlesshobo> linduxed: ^
10:54:50 <merijn> I just have "session <- clockSession; mainLoop chan ui mainWire session" somewhere else in the code
10:54:51 <armlesshobo> linduxed: then do :step to step through each line
10:54:53 <linduxed> armlesshobo: ok
10:55:04 <mm_freak> merijn: GHC version?
10:55:08 <merijn> 7.4
10:55:10 <armlesshobo> :h will output more useful info
10:55:24 <merijn> (.1)
10:55:27 <mm_freak> merijn: "session <- clockSession" can't be right
10:56:07 <mm_freak> Session is definitely not a monad
10:56:49 <merijn> mm_freak: clockSession has type "MonadIO m => m (Session m)"
10:56:57 <mm_freak> merijn: oh, then your netwire version is outdated =)
10:57:16 <mm_freak> clockSession should have type:  (MonadIO m) => Session m
10:58:09 <merijn> bah
10:58:36 <merijn> I have 4.0.0, which version should I be having?
10:58:42 <mm_freak> 4.0.7
10:59:06 <elliott> (shouldn't that be 4.1 by the pvp...?)
10:59:17 <mm_freak> yes, it should
10:59:29 <mm_freak> my bad
11:00:53 <merijn> Right, seems to compile now
11:01:02 <mm_freak> in fact i wonder‚Ä¶  i thought the first release of netwire 4.0 had the proper clockSession type
11:01:31 <mm_freak> did you install from hackage or from repository?
11:01:39 <merijn> I don't remember
11:02:01 <mm_freak> it's probably a repository install‚Ä¶  IIRC i changed the type of clockSession before release
11:06:57 <linduxed> alright
11:07:00 <linduxed> now then
11:07:47 <linduxed> this is a *broad* question, but i'm kinda worried that i can't clean up linest 91-111 in https://github.com/linduxed/progp-molbio/blob/evoltree/NJ.hs
11:08:35 <linduxed> i might be wrong and everyone actually thinks that is some beautiful code right there, but i doubt it
11:09:03 <linduxed> so i'm just looking for some general pointers, if there's something that can very obviously be improved
11:10:14 <mm_freak> linduxed: your code is actually fine, except that you are a bit exaggerating with identifier names
11:10:44 <linduxed> mm_freak: i tend to use those to avoid all possible confusion
11:10:51 <linduxed> mm_freak: makes stuff wordy though
11:10:52 <mm_freak> oldX and newX could just as well be x0 and x1 or x' and x
11:11:24 <linduxed> mm_freak: hmm, maybe... i'm worried that will be impenetrable for others
11:11:42 <mm_freak> linduxed: it's a fairly common style in haskell
11:11:46 <linduxed> oh i see
11:12:19 <mm_freak> most use "x" for old and "x'" for new‚Ä¶  i prefer it the other way around, but in any case the apostrophe is usually used either for "versioning" (values) or for strictness (functions)
11:12:38 <linduxed> ok, i'll consider that
11:12:49 <mm_freak> nonstrict foldl, strict foldl', old x', new x
11:12:57 * elliott can't see the logic in doing it mm_freak's way at all
11:13:12 <linduxed> btw, is 116-118 sensible or is that an ugly way of doing things
11:13:26 <linduxed> it felt kinda hacky, even though it does its job
11:13:35 <mm_freak> elliott: it makes the code more obvious:  f a' b c'
11:13:45 <mm_freak> you know exactly which values will change in a recursive invocation or in the result
11:14:42 <elliott> why does that matter? "b" probably gets transformed somehow to turn into the result, too
11:14:44 <mm_freak> elliott: it's about the same rationale for using _ to show that you don't use a pattern variable
11:14:51 <elliott> just perhaps not in a way that makes sense to refer to it as the new b
11:15:40 <mm_freak> elliott: it's a preference that arose from experience with netwire where you use recursive invocations with new versions all the time
11:15:45 <mm_freak> it just makes the code much more accessible
11:17:03 <mm_freak> most people who have worked with the netwire code have agreed that it's a better style‚Ä¶  there is really no rationale of using the opposite style in favor of mine
11:17:12 <mm_freak> s/in favor/instead/
11:18:17 * hackagebot BlogLiterately 0.6.0.1 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.6.0.1 (BrentYorgey)
11:18:59 * elliott thinks that's overstating it a bit
11:20:05 <glguy> For those of us following along at home, the topic is using quote for the new or old version of a variable?
11:20:17 <mm_freak> glguy: yeah
11:20:22 <glguy> OK, thanks :)
11:20:49 <mm_freak> elliott: i don't think there is a right and wrong here
11:21:11 <mm_freak> elliott: i just figured:  when i reverse the style, i can see immediately which values change in this case
11:21:35 <mm_freak> this is really useful in netwire, and i found it also useful in other cases
11:21:44 <elliott> sure, but I don't see that as valuable... I do see it as valuable to know which values are newer versions of other values from their name, because it lets me trace the dependencies back
11:21:50 <elliott> with yours, "b" could be just b, or new b.
11:22:24 <mm_freak> true‚Ä¶  so it probably depends on the application =)
11:22:44 <glguy> It seems like the main problem is that in the rest of math the "primed" version of a version is the "next" version or the "derived" version, etc
11:22:52 <glguy> so you'd just confuse anyone who didn't read your style guide
11:23:17 * hackagebot VKHS 0.3.2 - Provides access to Vkontakte social network via public API  http://hackage.haskell.org/package/VKHS-0.3.2 (SergeyMironov)
11:23:34 <elliott> yeah, I was arguing separately from convention
11:24:09 <mm_freak> glguy: i think the style is easy to follow‚Ä¶  in the worst case you can treat "'" as yet another variable name character
11:24:14 <elliott> in the context of existing mathematical and Haskell use of ' I definitely think this is a bad idea, but I figured the fact that I'm not sure of the advantages even devoid of that was more pertinent :P
11:24:27 <mm_freak> if you can tell x from x' you can follow both styles, no matter which one you're used to
11:25:32 <monochrom> I know of only one bikeshed colouring dispute more trivial than this one.
11:26:02 <monochrom> "should the hardware clock be UTC or local time?"
11:26:07 <notdan> Is it possible to do semi-automatic testing with 'cabal test' and HUnit?
11:26:16 <glguy> monochrom: Oh, definitely UTC
11:26:20 <glguy> :)
11:26:39 <monochrom> my sister disagrees, based on Windows experience
11:26:40 <aristid> if it's not UTC, the computer is broken
11:26:47 <aristid> clearly
11:27:39 <mm_freak> notdan: what's "semi-automatic"?
11:27:53 <notdan> well, automatic
11:27:59 <notdan> I just want it to run unit tests
11:28:00 <mm_freak> notdan: then yes
11:28:02 <notdan> before compilation
11:28:08 <mm_freak> then no
11:28:14 <mm_freak> you compile, then test, then run
11:28:14 <notdan> Hm
11:28:21 <notdan> Oh, true, true
11:28:40 <monochrom> to be fair, there is a visible difference only when you have to change into and out of daylight saving time annually. otherwise, you can abstract away the hardware clock
11:28:44 <mm_freak> notdan: look into the 'lens' library for how to do it
11:28:46 <notdan> OK, I was just having troubles finding the docs, because I've found on stackoverlow the information that it's currently not possible to do that
11:28:52 <notdan> mm_freak: sounds legit
11:29:24 <monochrom> so, the manifested bikeshed colouring dispute is: should the OS change the hardware clock for daylight saving time or not
11:29:44 <armlesshobo> monochrom: yes
11:29:45 <armlesshobo> :)
11:29:47 <armlesshobo> done
11:29:54 <armlesshobo> next issue?
11:30:19 <monochrom> there is no next issue
11:33:41 <elliott> monochrom: I like the idea of it changing for DST but also being UTC
11:37:21 <greymalkin> Why does this work: shuffleList x y = map snd $ sortBy (comparing fst) $ zip x y
11:37:39 <greymalkin> But this doesn't: shuffleList = map snd . sortBy (comparing fst) . zip
11:38:14 <elliott> greymalkin: because that's shuffleList x = map snd (sortBy (comparing fst) (zip x))
11:38:16 <byorgey> greymalkin: because (.) is only for composing two one-argument functions
11:38:18 <monochrom> and this probably does: shuffleList x = map snd . sortBy (comparing fst) . zip x
11:38:24 <elliott> shuffleList x = map snd . sortBy (comparing fst) . zip x will work
11:38:27 <byorgey> greymalkin: it can't compose a two-argument function with a one-argument function
11:39:02 <elliott> greymalkin: basically, (f . g) x = f (g x), always; there's no magic :)
11:39:38 <greymalkin> Gotcha
11:40:06 <dario> @src (.)
11:40:07 <lambdabot> (f . g) x = f (g x)
11:40:07 <lambdabot> NB: In lambdabot,  (.) = fmap
11:41:18 <croikle> greymalkin: you could replace the last (.) with (.:), where (a .: b) x y = a (b x y)
11:44:37 <plhk> any ideas about what's going on here? http://hpaste.org/84722 (template haskell)
11:47:17 <notdan> I fogrot: is it advisable to update cabal-install package?
11:47:53 <danharaj> @pl (\(_,x) _ -> x == 1)
11:47:53 <lambdabot> const . (1 ==) . snd
11:48:13 <monochrom> I say no, but people say yes
11:48:48 <Taneb> It's an issue of "why should you need to", I believe
11:49:30 <monochrom> but I can agree to this method: inside a sandbox install the new cabal-install, copy out the exe, throw away the sandbox
11:49:39 <aCube> @hoogle  (a -> b -> b) -> [a] -> [b] -> [(a,b)]
11:49:39 <lambdabot> Data.Generics.Twins gmapAccumQr :: Data d => (r' -> r -> r) -> r -> (forall e. Data e => a -> e -> (a, r')) -> a -> d -> (a, r)
11:49:40 <lambdabot> Data.Generics.Twins gmapAccumQl :: Data d => (r -> r' -> r) -> r -> (forall e. Data e => a -> e -> (a, r')) -> a -> d -> (a, r)
11:49:59 <monochrom> this is to avoid getting two version of the Cabal lib
11:50:06 <monochrom> s/version/versions/
11:51:38 <aCube> :t \f a b -> zip a . zipWith f a b
11:51:39 <lambdabot>     Couldn't match expected type `a0 -> [b0]' with actual type `[c0]'
11:51:39 <lambdabot>     In the return type of a call of `zipWith'
11:51:39 <lambdabot>     Probable cause: `zipWith' is applied to too many arguments
11:51:58 <aCube> :t \f a b -> zip a $ zipWith f a b
11:51:59 <lambdabot> (a -> b1 -> b) -> [a] -> [b1] -> [(a, b)]
11:52:11 <croikle> how about zipWith (const &&& f)
11:52:27 <aCube> :t \f a b -> zipWith (id &&& f) a b
11:52:29 <lambdabot>     Couldn't match expected type `b0 -> c0'
11:52:29 <lambdabot>                 with actual type `(c1, c'0)'
11:52:29 <lambdabot>     Expected type: a0 -> b0 -> c0
11:52:35 <aCube> :t \f a b -> zipWith (const &&& f) a b
11:52:37 <lambdabot>     Couldn't match expected type `b0 -> c0'
11:52:37 <lambdabot>                 with actual type `(c1, c'0)'
11:52:37 <lambdabot>     Expected type: a0 -> b0 -> c0
11:53:29 <croikle> ehh, multiple arguments make trouble in the &&& I guess
11:53:50 <monochrom> "const &&& f" looks wrong. "const () &&& f" looks better
11:54:07 <aCube> :t \f a b -> zipWith (const () &&& f) a b
11:54:08 <lambdabot>     Couldn't match expected type `b0 -> c0'
11:54:08 <lambdabot>                 with actual type `(c1, c'0)'
11:54:08 <lambdabot>     Expected type: a0 -> b0 -> c0
11:54:27 <edwardk> :t const () &&& ?f
11:54:28 <lambdabot> (?f::b -> c') => b -> ((), c')
11:54:41 <edwardk> :t (() <$) . ?f
11:54:43 <lambdabot> (?f::a -> f b, Functor f) => a -> f ()
11:55:07 <edwardk> :t fmap ((,)()) . ?f
11:55:08 <aCube> :t \f a b -> zipWith (curry $ uncurry const &&& uncurry f) a b
11:55:08 <lambdabot> (?f::a -> f a1, Functor f) => a -> f ((), a1)
11:55:09 <lambdabot> (a -> b -> c') -> [a] -> [b] -> [(a, c')]
11:55:29 <edwardk> :t (,)() . ?f
11:55:30 <lambdabot> (?f::a -> b) => a -> ((), b)
11:55:35 <edwardk> derp
11:55:54 * edwardk looks up to find the original problem/question
11:56:05 <aCube> edwark: shortcut for \f a b -> zip a $ zipWith f a b
11:56:32 <notdan> Warning: nctlmc.cabal: Ignoring unknown section type: test-suit
11:56:33 <edwardk> :t zipwith (id &&& f) a b
11:56:34 <lambdabot>     Not in scope: `zipwith'
11:56:34 <lambdabot>     Perhaps you meant one of these:
11:56:34 <lambdabot>       `zipWith' (imported from Data.List),
11:56:35 <notdan> Ok well
11:56:37 <edwardk> :t zipwith (id &&& ?f) ?a ?b
11:56:38 <notdan> this is unfortunate
11:56:39 <lambdabot>     Not in scope: `zipwith'
11:56:39 <lambdabot>     Perhaps you meant one of these:
11:56:39 <lambdabot>       `zipWith' (imported from Data.List),
11:56:43 <edwardk> :t zipWith (id &&& ?f) ?a ?b
11:56:44 <lambdabot>     Couldn't match expected type `b0 -> c0'
11:56:44 <lambdabot>                 with actual type `(c1, c'0)'
11:56:44 <lambdabot>     Expected type: a0 -> b0 -> c0
11:57:38 <monochrom> zipWith (\x y -> (x, f x y)) a b
11:57:50 <edwardk> @pl \a b -> (a, f a b)
11:57:50 <lambdabot> liftM2 (.) (,) f
11:58:12 <aCube> Maybe it is a function that is already defined somewhere?
11:58:17 <edwardk> :t zipWith . liftM2 (.) (,)
11:58:18 <lambdabot> (a -> b -> b1) -> [a] -> [b] -> [(a, b1)]
12:00:05 <sproingie> Functor, Monad, Applicative ... any other classes that you'd say are "must-know"?
12:00:15 <byorgey> Monoid
12:00:18 <aCube> Traversable
12:00:20 <aCube> Foldable
12:00:29 <sproingie> oh yah forgot Monoid
12:00:37 * sproingie adds Traversable and Foldable to his list
12:01:03 <danharaj> you don't need to know traversable and foldable anymore all you need to know is the entire lens package ;0
12:01:10 <aCube> :D
12:01:15 * sproingie cringes
12:01:38 <donri> @where typeclassopedia -- sproingie
12:01:38 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
12:01:41 <aCube> It seems to me that nearly the entire lens package is build up on profunctors
12:02:09 <donri> aCube: just prisms and isos no?
12:02:20 <danharaj> indexed stuff uses a variation of profunctors
12:02:30 <danharaj> "Conjoined"
12:02:33 <donri> aha
12:03:29 <danharaj> I actually much like the new machinery compared to the initial indexed stuff despite the types being a bit imperspicuous.
12:04:46 <byorgey> imperspicuous is a good word for it.
12:04:59 <byorgey> it is self-referential.
12:05:28 <danharaj> byorgey: I learned it from oleg :D
12:05:38 <edwardk> Heh
12:06:18 <edwardk> Next we need to work on making sure there are fewer impertransible data structures.
12:07:00 <danharaj> edwardk: I am perturbed that impertransible is a word.
12:07:16 <edwardk> =)
12:07:37 <edwardk> I find myself imperturbed
12:08:47 <danharaj> edwardk: I am working on translating Martin Erwig's fgl library into lens language. Are you familiar with it?
12:09:27 <rofer> Is it normal to need to do 'cabal update', 'cabal install cabal-install' several times before getting to the most recent version?
12:09:51 <croikle> the new one may be later in your path
12:09:54 <croikle> try which -a cabal
12:10:38 <edwardk> I'm familiar with fgl.
12:10:46 <edwardk> I'm not a particular fan of the API
12:10:58 <rofer> croikle: Ah, I have a /usr/bin/cabal and a /bin/cabal
12:11:02 <edwardk> i find that it is impossible to make efficient
12:11:33 <danharaj> edwardk: Oh. That is important to me. I haven't been able to find any material on Haskell graph datastructures except fgl.
12:11:40 <danharaj> (and cutesy stuff like tying the knot)
12:12:14 <edwardk> danharaj: i spent some time on it a couple of years ago (and iirc annoyed ivanm by taking the package name 'graphs')
12:13:05 <edwardk> but in particular it is quite important to be able to separate the shape of the graph from the data that is associated with the nodes and edges of the graph otherwise you spend all your time manipulating and garbage collecting the same boring graph meta-data about what is connected to what
12:13:06 <danharaj> edwardk: About to go check it out. My idea with fgl was that graphs ought to have an At instance for fgl's Contexts, and decomposing a graph should be something like a Zipper.
12:13:28 <edwardk> the problem with fgl's contexts from a lens perspective is you really can't comply with the lens laws
12:13:46 <edwardk> so everything you write will be an 'almost lens' or 'almost traversal'
12:14:01 <danharaj> edwardk: hm? Which law is broken?
12:14:12 <edwardk> you might be able to get by with traversals that carry around the indices of what the end points are of the edge for instance as an index
12:14:30 <danharaj> oh I see "Get back what you put in" is broken.
12:14:32 <edwardk> depends on if you forbid multi-edges etc
12:14:36 <danharaj> wait no.
12:14:45 * sproingie ponders an Almost monad
12:15:04 <sproingie> let threeish = mostly 3 :: Almost Int
12:15:14 <edwardk> sproingie: http://rebase.org/analytics/Data-Analytics-Approximate-Mass.html
12:15:20 <rofer> Heh, looks like I have two cabal's in my path, but the one I want isn't in my path
12:16:02 <sproingie> huh neat.  i could see using that for fuzzy logic
12:16:49 <danharaj> edwardk: It seems to me that multiedge directed graphs satisfy the lens laws for contexts, at least.
12:16:52 <edwardk> sproingie: i use it in the api for things like http://rebase.org/analytics/Data-Analytics-Approximate-HyperLogLog.html to give back approximate answers
12:17:19 <edwardk> danharaj: if you are willing to allow multiedges, etc. you can get pretty far
12:17:44 <edwardk> but then you still run into the problem that the representation of all of those graphs is terrible for GC purposes
12:17:47 <danharaj> edwardk: I suppose you also need to allow 'dangling edges'
12:18:01 <sproingie> edwardk: that looks like some neat stuff
12:18:41 <Aune> Hi, I'm building a small space strategy game. It is meant to be at many scales: Star Cluster -> Solar System -> Planetary System -> Planets and moons. I dont know how to properly represent a players units. Any pointers would be greatly appreciated: http://hpaste.org/84723
12:22:41 <danharaj> Aune: that is a difficult question to answer.
12:24:06 <notdan> Is it possible to create a .cabal package with a library and an executable, such that the executable depends on the library?
12:24:45 <byorgey> notdan: yes
12:24:50 <sproingie> i would think the dependency is somewhat automatic, since they're built together
12:24:59 <byorgey> it is not automatic.
12:25:04 <Aune> danharaj, Yeah. Is it to open ended or is there more that makes it hard to answer. What context could I produce to make it easier to answer?
12:25:11 <byorgey> but you just have to list the library in the build-depends for the executable.
12:25:36 <danharaj> Aune: It would possibly be a good idea to make it a stackoverflow question to give would-be answerers time to give a nice comprehensive answer.
12:25:59 <danharaj> I am not sure if stackoverflow allows such questions. They seem to be a little capricious about what is an appropriate question.
12:26:33 <notdan> byorgey: I tried that and I have a strange error message when I try to build it: cabal: can't find source for NPNTool/PetriNet in ., dist/build/autogen
12:26:33 <sproingie> you might want to add to the question something more specific than "what's the best way", like whatever specific problem you're having with approach X or Y or what's blocking you &c
12:26:54 <byorgey> notdan: what version of cabal do you have?
12:26:56 <dEPY> What are  .hi  files?
12:26:56 <sproingie> basically, SO gets really persnickety about open-ended questions
12:27:02 <notdan> byorgey: 0.14
12:27:17 <byorgey> notdan: hmm, strange, I don't know
12:27:23 <Aune> I have noticed that.
12:27:49 <edwardk> @tell cale could we harass you to update lens on lambdabot?
12:27:49 <lambdabot> Consider it noted.
12:27:59 <notdan> byorgey: would you might taking a glance at my .cabal file? maybe I made some really stupid error somewhere there
12:28:03 <byorgey> dEPY: they specify the interface exported by a given module
12:28:07 <byorgey> notdan: sure
12:28:16 <edwardk> notdan: yes you need to list the library in the executable dependencies
12:28:41 <notdan> http://paste.lisp.org/display/136363
12:29:02 <edwardk> notdan: https://github.com/ekmett/ersatz/blob/master/ersatz.cabal builds two executables that use the library as part of the build process
12:29:36 <danharaj> edwardk: by the way, I recently watched your NY lens talk and I am disappointed that I didn't get to see it live. Mostly due to ignorance of its occurrence within my vicinity.
12:29:56 <edwardk> danharaj: clearly you just need to come up to boston haskell and hang out some time ;)
12:30:53 <danharaj> edwardk: Watch out, it could happen and then you'll be stuck with me asking stupid questions *in real life* :P
12:31:13 <byorgey> notdan: do you get that error when it's building the library, or the executable?
12:31:24 <dEPY> byorgey: something like .h files from c++ ?
12:31:49 <notdan> byorgey: looks like the executable
12:31:56 <byorgey> dEPY: yes, sort of, but automatically generated, and intended for consumption by other programs and not humans
12:32:24 <dEPY> byorgey: oh, what can other programs do with it?
12:32:31 <notdan> byorgey: but how can I check to know for sure?
12:32:39 <byorgey> dEPY: well, maybe I shouldn't have said 'other'
12:33:21 <dEPY> byorgey: :)  so, ghc uses them basically not "other" programs?
12:33:24 <byorgey> dEPY: GHC itself uses the .hi files when deciding what to recompile, calling the linker, etc.
12:33:37 <dEPY> byorgey: I see. Thanks. :)
12:33:38 <notdan> byorgey: no, sorry, the problem is with the library
12:33:41 <byorgey> perhaps there are other programs that use them too, I am not sure.
12:34:20 <byorgey> notdan: ah, then perhaps you need to add  an  hs-source-dirs:  field for the library?  where is NPNTool/PetriNet.hs located?
12:35:13 <Aune> danharaj, sproingie Im writing it up on http://codereview.stackexchange.com/   they seem more appropriate for open ended questions.
12:35:17 <notdan> god, I am so stupid
12:35:19 <notdan> thanks byorgey
12:35:22 <notdan> it works now
12:35:36 <byorgey> hehe, glad I could help =)
12:41:26 <notdan> Uh oh, now I have some really scary linking errors: http://paste.lisp.org/+2X7V/1
12:42:57 <notdan> aaand that's because I am stupid
12:43:15 <notdan> and haven't included NodeMap in other-modules
12:49:33 <fizruk> hey, guys! why does ghci act so different than runghc?
12:50:30 <`-_-a> one's a REPL the other isn't? that's my guess
12:51:08 <quchen> fizruk: GHCi is an interactive Haskell session, runghc compiles and immediately runs your program.
12:51:13 <fizruk> sorry, I didn't finished the message
12:51:20 <fizruk> here's sample code http://pastebin.com/YSe5YFPU
12:51:26 <mauke> The paste YSe5YFPU has been copied to http://hpaste.org/84727
12:51:57 <fizruk> when I run it with runghc, I get an error (and it's understandable)
12:52:20 <quchen> The code looks right to me.
12:52:47 <fizruk> when I remove ¬´main¬ª function, load module into ghci, and enter ¬´show $ One 1¬ª I get just "1"
12:53:21 <`-_-a> export main?
12:53:50 <quchen> Main is automatically exported unless otherwise stated
12:54:04 <quchen> (i.e. there's another module declaration)
12:54:19 <`-_-a> quchen: i could've sworn that some earlier versions of ghc required you to export it
12:54:25 <fizruk> that's not the problem
12:54:36 <dEPY> hm... is   withFile .... -> do ...... a monad stuff? (I'm not that far in a book, just wondering.) :)
12:54:50 <quchen> The problem seems to be that it can't infer the type of "One 1", which is "My Int ?"
12:55:00 <quchen> It doesn't know the ?, so it cannot pick the right show instance
12:55:09 <fizruk> quchen, exactly
12:55:15 <geekosaur> ha
12:55:22 <hpaste> Quchen annotated ‚ÄúGHCi & GHC‚Äù with ‚ÄúGHCi & GHC (annotation)‚Äù at http://hpaste.org/84727#a84728
12:55:24 <`-_-a> quchen: would it be My Int or My Integral?
12:55:25 <geekosaur> monomorphism restriction?
12:55:42 <geekosaur> ghci extended defaulting probably infers b as ()
12:55:48 <quchen> Integral is a typeclass, what you want is type.
12:55:55 <quchen> Integer and Int are types.
12:55:56 <`-_-a> oh, right.
12:55:58 <quchen> Integral is a type class.
12:56:01 <`-_-a> Integer*
12:56:10 <`-_-a> My Integer
12:56:42 <fizruk> geekosaur, perhaphs. Why does ghci act differently from ghc?
12:57:09 <geekosaur> fizruk, I actualy said why there
12:57:12 <geekosaur> extended defaulting
12:57:28 <quchen> GHCi tries to not get in your way too much, so it often guesses types when it can't actually infer them
12:57:42 <geekosaur> standard defaulting, which ghc does by default, can only infer types which are an instance of Num per the language standard
12:58:04 <geekosaur> extended defaulting, which ghci adds by default, adds some extra types not permitted by the standard... notably (), the unit type
12:58:25 <geekosaur> so you can get away with stuff like that without full types, because it can infer () as the type of the unused part, as a convenience
12:59:18 <quchen> Can you switch this off by the way?
12:59:24 <geekosaur> yes
12:59:29 <geekosaur> I'm looking up the exact option
12:59:35 <quchen> :set NoGuesses?
12:59:56 <geekosaur> :set -XNoExtendedDefaultRules
13:01:12 <fizruk> geekosaur, thanks a lot for the explanation!
13:01:15 <quchen> Wonderful.
13:15:25 <rofer> Is there a way to see the fully qualified name of something in GHCi?
13:16:01 <Shin-LaC> does ghci have something like python's help?
13:16:35 <shachaf> rofer: Which fully qualified name? Or why?
13:17:01 <`-_-a> rofer: try :i <name>?
13:17:08 <rofer> shachaf: Trying to figure out where something is from
13:17:11 <mikeplus64> Shin-LaC: what is python's help like?
13:17:19 <`-_-a> rofer: hoogle is also useful
13:17:22 <rofer> `-_-a: That's what I was looking for, thanks!
13:17:29 <shachaf> rofer: :i
13:17:30 <Shin-LaC> argh, sorry, gtg
13:17:40 <shachaf> Ah, you got an answer.
13:17:51 <shachaf> Though it wasn't an answer to your original question. :-)
13:18:09 <shachaf> Also note that :i will tell you which module defined a particular value, not which module you imported it from.
13:18:28 <rofer> shachaf: Ah, thanks for that
13:24:48 <dEPY> I'm on IO chapter in Learn you a haskell, and for everything IO related it states "It returns an I/O action" instead of performs. Is that to indicate lazyness?
13:24:58 <otters> not exactly
13:25:08 <otters> well, the IO monad is lazy, I believe
13:25:34 <dEPY> Oh, so it means the return type is IO and it's actually performed by the "do" ?
13:25:41 <otters> the IO monad is one of those weird monads that trip people up but it's like a "computation"
13:25:46 <shachaf> No.
13:26:01 <dEPY> Damn you haskell! Why can't I figure something out on my own! :D
13:26:02 <shachaf> A function like putStrLn :: String -> IO () returns an IO action.
13:26:12 <shachaf> That is, (putStrLn "blah") is an IO action.
13:26:19 <otters> When evaluated, it puts that strln
13:26:24 <shachaf> What?
13:26:33 <aristid> otters: no
13:26:35 <shachaf> Anyway, an IO action is a completely inert value.
13:26:52 <elliott> otters: not true
13:26:58 <otters> lol
13:26:58 <aristid> > putStrLn "foo" `seq` 123
13:27:00 <lambdabot>   123
13:27:05 <dEPY> shachaf: Go on.. I'm following
13:27:07 <aristid> note how this doesn't print "foo"
13:27:11 <otters> well, haskell isn't my strong point
13:27:26 <shachaf> dEPY: An IO action is like a program that can be run to do IO.
13:28:00 <shachaf> dEPY: You can construct these programs out of smaller programs, for example.
13:28:16 <dEPY> And... It's run by "do"?  O_√¥
13:28:25 <elliott> no, "do" is how you construct the programs out of smaller ones
13:28:28 <aristid> no. do just combines multiple smaller programs.
13:28:29 <shachaf> No, "do" is -- yes.
13:28:33 <dEPY> oh ok
13:28:33 <otters> no, do is syntax sugar for bind
13:28:41 <dEPY> I'm gonna shut up now and listen. :)
13:28:49 <shachaf> dEPY: Then when you compile your .hs file, the resulting executable runs the IO action "main".
13:28:51 <aristid> dEPY: the IO is run by the haskell runtime. it looks for an IO value returned by main, and executes that.
13:28:55 <otters> "do" is misleadingly named
13:28:57 <latro`a> do is syntax sugar for bind, bind is how you chain together IO actions, then one action that is actually performed is main
13:29:04 <latro`a> s/then/the
13:29:07 <aristid> otters: perhaps.
13:29:12 <glguy> lol, let shachaf finish :)
13:29:26 <otters> > unsafePerformIO (putStrln "foo") `seq` "foo"
13:29:28 <lambdabot>   Not in scope: `unsafePerformIO'Not in scope: `putStrln'
13:29:28 <lambdabot>  Perhaps you meant ...
13:29:31 <otters> rats
13:29:40 <shachaf> otters: I don't think you're helping.
13:29:46 <aristid> otters: we don't talk about unsafePerformIO in polite company
13:29:48 <armlesshobo> do { line <- getLine; putStrLn line;} = getLine >>= (\x -> putStrLn x)
13:29:56 <otters> I apologize everybody
13:30:02 <dEPY> someone finish the damn story :)
13:30:14 <latro`a> supposing you compile the program
13:30:19 <shachaf> dEPY: So, for example, (putStrLn "hi") and (putStrLn "ho") are both IO actions.
13:30:19 <latro`a> main = getLine >>= putStrLn
13:30:25 <otters> oh, weird
13:30:28 <latro`a> and then run it
13:30:32 <shachaf> dEPY: So do { putStrLn "hi"; putStrLn "ho" } is another IO action.
13:30:37 <otters> when I evaluate that in GHCI it outputs "hi\nfoo"
13:30:38 <latro`a> it will take a line from the user and then print it back
13:30:41 <jfischoff> what do I add to the cabal file to make this go away? Dynamic linking required, but this is a non-standard build (eg. prof) ‚Ä¶. -osuf to set the object file suffix
13:31:09 <latro`a> just evaluating getLine or putStrLn or getLine >>= putStrLn doesn't make the IO happen; what makes the IO happen is being in main
13:31:10 <shachaf> dEPY; If you say main = do { putStrLn "hi"; putStrLn "ho" }, then when you run that program, GHC will run the IO action "main".
13:31:23 <armlesshobo> putStr "Hello, " >> putStrLn "World"
13:31:32 <shachaf> dEPY: In order to do that it'll run each IO action that main is made up of, in turn.
13:31:33 <Mortchek> otters, GHCI evaluates and then *executes* IO actions. The execution is what you're seeing.
13:31:56 <armlesshobo> execute is for IO only, right?
13:32:12 <latro`a> technically yes, though others may be described that way sometimes
13:32:19 <aristid> shachaf: hmm, do you think a blueprint would be a good analogy?
13:32:20 <Mortchek> Don't quote me on the term "execute", I'm not sure it's technically correct
13:32:20 <armlesshobo> because binding other Monadic types don't necessary get executed
13:32:25 <dEPY> shachaf: So far so good. :)
13:32:26 <shachaf> latro`a: There is no "technically" because there's no technical definition of "execute".
13:32:47 <latro`a> well, "strictly speaking" or something like that
13:32:55 <shachaf> I think "execute" makes sense for just about any monad. But sometimes it's a boring kind of sense.
13:33:10 <armlesshobo> execute Maybe?
13:33:15 <Mortchek> > putStrLn "lambdabot refuses to execute IO, for good reason."
13:33:17 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
13:33:17 <lambdabot>    arising from a use of ...
13:33:29 <armlesshobo> execute Either?
13:33:33 <shachaf> "execute" means more or less the same thing as "interpret".
13:33:48 <shachaf> Executing a value of type (Maybe a) is pretty boring.
13:33:58 <aristid> armlesshobo: runEither :: Either a b -> (a -> c) -> (b -> c) -> c
13:34:07 <aristid> :t either
13:34:08 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
13:34:15 <aristid> :t maybe
13:34:16 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:34:25 <armlesshobo> ahhhh, i was thinking about it all wrong.
13:34:31 <armlesshobo> aristid: thank you
13:34:51 <aristid> :t maybe Nothing Just
13:34:52 <lambdabot> Maybe a -> Maybe a
13:34:59 <aristid> *giggle*
13:35:08 <latro`a> best id ever
13:35:19 <Mortchek> ($) is a pretty cool id too
13:35:32 <latro`a> evidently lens is filled with cool ids
13:35:38 <aristid> :t either Left Right
13:35:39 <lambdabot> Either a b -> Either a b
13:35:54 <latro`a> :t Control.Error.Util.hush
13:35:56 <lambdabot> Couldn't find qualified module.
13:35:58 <latro`a> aw
13:36:11 <latro`a> I love the names of hush and note
13:36:16 <latro`a> succinct and descriptive
13:36:30 <Mortchek> What do they do?
13:36:41 <latro`a> hush (Right x) = Just x; hush (Left _) = Nothing
13:36:58 <Mortchek> And note is the opposite?
13:37:12 <latro`a> note mynote Nothing = Left mynote; note _ (Just x) = Right x
13:37:20 <Mortchek> Neat.
13:38:38 <sproingie> sort of a maybeToEither
13:38:52 <latro`a> more descriptive than that name, though
13:38:57 <sproingie> definitely
13:39:01 <sproingie> shorter too :)
13:40:40 <ion> @type \a -> maybe (Left a) . Right
13:40:42 <lambdabot>     Couldn't match expected type `a0 -> Either a1 b0'
13:40:42 <lambdabot>                 with actual type `Either a3 a2'
13:40:42 <lambdabot>     Expected type: a2 -> a0 -> Either a1 b0
13:40:50 <ion> @type \a -> maybe (Left a) Right
13:40:51 <lambdabot> a -> Maybe b -> Either a b
13:41:20 <lispy> hello
13:41:25 <ion> hi
13:41:35 <latro`a> oh cool, you can implement them with maybe/either
13:41:45 <lispy> @tell ivanm were you looking for me?
13:41:45 <lambdabot> Consider it noted.
13:42:12 <ion> @type either (const Nothing) Just
13:42:13 <lambdabot> Either a a1 -> Maybe a1
13:42:18 <latro`a> indeed
14:04:50 <aristid> @pl \a -> maybe (Left a) . Right
14:04:50 <lambdabot> (. Right) . maybe . Left
14:07:21 <dates_> Hi. I have a function "func dist ref_pt pt_list = filter (\(x,y)->(distance_calc (x,y) ref_pt) <= dist) pt_list" this gives list of points which are inside this distance. I want to modify it so that it shall give only the closest points. Ex: if closest points are only in distance 1, just give them otherwise check distance 2 How can I do that?
14:09:27 <aristid> dates_: what's the rule for how many points it should be?
14:09:35 <Eduard_Munteanu> Presumably pt_list is non-empty.
14:09:58 <glguy> dates_: Are you confused about how to do this or how to implement a particular algorithm for it in Haskell?
14:10:25 <dates_> pt_list is never empty, and as many as points with least distance
14:10:48 <Eduard_Munteanu> Ok, that's reasonable.
14:10:54 <dates_> glguy : I am confused about its haskell implementation
14:11:16 * aristid isn't sure what exactly dates_ actually wants.
14:11:25 <edwardk> latro`a: hush = preview _Right
14:12:08 <dates_> the function gives all points inside that distance, I want it to give the ones with least distance
14:13:22 * hackagebot liblastfm 0.1.1.1 - Lastfm API interface  http://hackage.haskell.org/package/liblastfm-0.1.1.1 (MatveyAksenov)
14:13:34 <hpaste> glguy pasted ‚Äúminimums with measure‚Äù at http://hpaste.org/84731
14:13:38 <latro`a> @type \d r ps -> filter (\p -> dist p r == minimum (map (dist r) ps)
14:13:40 <lambdabot> parse error (possibly incorrect indentation)
14:13:43 * glguy guesses that's what he's looking for
14:13:48 <latro`a> @type \d r ps -> filter (\p -> dist p r == minimum (map (dist r) ps))
14:13:49 <lambdabot> Not in scope: `dist'
14:13:49 <lambdabot> Not in scope: `dist'
14:13:57 <latro`a> bah
14:14:09 <latro`a> @type \f d r ps -> filter (\p -> dist p r == minimum (map (dist r) ps)) ps
14:14:10 <lambdabot> Not in scope: `dist'
14:14:10 <lambdabot> Not in scope: `dist'
14:14:16 <latro`a> one more time...
14:14:20 <latro`a> @type \f d r ps -> filter (\p -> dist p r == minimum (map (f r) ps)) ps
14:14:22 <lambdabot> Not in scope: `dist'
14:14:26 <latro`a> ...
14:14:27 <latro`a> last time
14:14:39 <aristid> latro`a: what about "not in scope: dist" do you fail to understand?
14:14:41 <latro`a> @type \f d r ps -> filter (\p -> f r p == minimum (map (f r) ps)) ps
14:14:42 <lambdabot> Ord a => (t1 -> a1 -> a) -> t -> t1 -> [a1] -> [a1]
14:14:51 <latro`a> I just kept forgetting to fix it
14:15:55 <aristid> i don't think this is very efficient either
14:16:19 <latro`a> it's not, unless you get magic stream fusion
14:16:30 <glguy> dates_: Does the paste help?
14:17:11 <dates_> I'm trying to put it into function
14:21:18 <dates_> I couldn't figure how to use it
14:23:00 <duairc_> I'm trying to build GHC HEAD on a Debian system, and I'm running into problems, I think because shared libraries are default by now. How would I turn off the shared library stuff?
14:23:02 <quchen> I've got a data type with a constructor that requires Ord. Do I have to use GADTs to make the constructor work only on Ord things? (The reason is that every possible value of that constructor involves a call to Data.Map)
14:23:03 <glguy> minimumsWithMeasure (distanceToPoint referencePoint) points
14:23:50 <quchen> (Requiring a typeclass for a constructor seems like a code smell, but I can't think of anything better here.)
14:26:57 <tyler> is it idem'potent or idempo'tent i hear most people say idem'potent but omnipo'tent is used in that word
14:27:47 <monochrom> idem potent
14:27:54 <glguy> i.dem.po.tent |Ààƒ´demÀåp≈çt…ônt
14:28:03 <monochrom> also, omni potent
14:28:18 <glguy> (to paste from the dictionary)
14:28:26 <monochrom> ah, intonation? I don't know then
14:28:30 <tyler> because there is only one dictionary
14:28:59 <monochrom> look up 3 dictionaries then take the average :)
14:29:06 <tyler> lol
14:29:22 <tyler> i was more curious how people say it
14:29:27 <tyler> i guess its like tuple
14:29:32 <tyler> where you pretty much good either way
14:29:40 <singla_> join #svn-dev
14:29:43 <tyler> although most academic people i know say toople
14:30:03 <schellsan> id√©mpotent
14:30:51 <schellsan> i thought it was tuple like couple
14:31:12 <schellsan> (left, right) is a couple that makes a tuple
14:32:52 <glguy> schellsan: both pronunciations appear to be recognized
14:32:55 <schellsan> of course - i also always thought kludgey was like clud-gee and according to google it's klooo-gee
14:33:10 <tyler> i say kloo-gee
14:33:29 <schellsan> see - told you i was wrong ;)
14:34:21 <schellsan> budge, nudge...kludge?
14:34:46 <glguy> Yeah, boodge, noodge, and kloodge
14:34:53 <Ralith> >_>
14:34:55 <glguy> it's consistent :)
14:35:29 <schellsan> boodge your kloodge in the noodge
14:36:15 <schellsan> okay back to work for me - i've sufficiently gotten you guys off track for now :)
14:50:10 <cschneid> why is there both Either and Maybe?  They seem like close cousins.  When should I use one over the other in my code?
14:50:54 <elliott> cschneid: when there is some information you want to confer along with an absent value/failure, then use Either. otherwise Maybe
14:51:26 <cschneid> so Nothing is the same as a Left with nothing (except that's not a real type, since left does take an arg)
14:51:54 <cschneid> so I'm right that they're pretty close.  Is there a way to turn an Either into a Maybe (throw away the error, just tell me if it succeeded)
14:51:57 <elliott> Maybe a and Either () a are isomorphic
14:51:58 <glguy> Either () is isomorphic to Maybe
14:52:05 <cschneid> ahh, sure.
14:52:07 <elliott> cschneid: sure
14:52:14 <elliott> discard (Left _) = Nothing; discard (Right a) = Just a
14:52:15 <elliott> or:
14:52:19 <elliott> discard = either (const Nothing) Just
14:52:25 <elliott> but in general you rarely have to do this.
14:52:33 <cschneid> what's `const` doing there
14:52:46 <Clint> feels like i've had to do that several tiems
14:52:52 <glguy> const puts the "discard" in discard
14:52:58 <aristid> cschneid: unlike Just, Nothing is not a funciton.
14:53:32 <cschneid> ahh, since the first arg to either is a func. But `const x` is the "always return x" function
14:53:40 <cschneid> (had to go look it up)
14:54:35 <cschneid> I've really gotta go read through Prelude...
14:54:38 <cschneid> thanks for the quick answers
15:00:19 <`nand`> glguy: ignoring bottom
15:01:15 <glguy> That's right, but wouldn't have been helpful in that context
15:07:00 <`nand`> my preferred solution is "more or less isomorphic"
15:08:43 <divarvel> hi, I'm trying to install snap though cabal-install, but clientsession fails to build. Is this a know problem ?
15:08:45 <divarvel> https://raw.github.com/gist/5258524
15:10:18 <mightybyte> divarvel: Try adding --constraint='clientsessien<0.8.1'
15:10:39 <mightybyte> Oops, correct the spelling of clientsession
15:10:51 <glguy> I have clientsession-0.8.1 installed with cprng-aes-0.3.4 and crypto-api-0.11
15:11:01 <divarvel> mightybyte: I tried to manually install an older version
15:11:04 <divarvel> mightybyte: same issue
15:11:55 <cschneid> how far does haskell go to the dream of magic-parallelization of code? I know purely functional code lets you do tricks in compiler to make it just happen, but how far along is the real-world cases of that?
15:12:10 <mightybyte> divarvel: What version of cprng-aes and crypto-api do you have installed?
15:12:24 <sproingie> cschneid: it basically doesn't at all
15:12:29 <divarvel> glguy: for some reason crypto-api was not installed. I'm installing it
15:12:58 <sproingie> cschneid: the DPH extension however does do quite a bit, it requires you use special syntax for "parallel arrays" though
15:13:08 <glguy> divarvel: I was guessing that those two packages were related to your problem just based on the module and type names in your error message
15:13:11 <glguy> fyi
15:13:17 <divarvel> mightybyte: I have cprng-aes-0.3.4 crypto-api-0.11
15:13:36 <divarvel> glguy: unfortunately clientsession still fails to build
15:13:42 <glguy> What version of GHC is that?
15:14:05 <divarvel> 7.6.2
15:14:30 <glguy> divarvel: and you you have multiple versions of any libraries installed?
15:14:36 <sproingie> cschneid: the problem of optimally figuring out what to automatically parallelize for general purpose code is at least NP-complete if not undecideable.  so the Sufficiently Smart Compiler may remain mythical
15:14:47 <divarvel> glguy: it's a clean cabal-dev sandbox
15:15:20 <cschneid> sproingie: presumably doing it perfectly is really hard, but can't it see maps and that everything under it is pure function, and parallelize that?  I'd imagine there are easy-wins, even if you can't do it optimally
15:15:26 <`nand`> sproingie: do you know of any code example that will automatically make use of more than one processor thread to a non-negligible extent when compiled using the latest GHC?
15:15:45 <Ralith> sproingie: surely you mean figuring out the *optimal* paralellization
15:15:47 <cschneid> (honest questions - I only have undergrad CS, and only basic compiler knowledge, I may just be dumb here :) )
15:15:52 <sproingie> yes i mean optimal
15:16:06 <mightybyte> divarvel: What's the output of "cabal --version"?
15:16:14 <Ralith> there are plenty of useful suboptimal solutions
15:16:20 <sproingie> "optimal coverage" of anything tends to be NP complete of course
15:16:25 <Ralith> indeed
15:16:37 <napping> cschneid: there are various ways to add a decent amount of parallelism very easily, but nothing really tries to automatically add it
15:16:42 <Ralith> and that's often not as much an obstacle as it sounds
15:16:52 <Ralith> one very rarely actually needs *the* optimal solution
15:16:53 <divarvel> mightybyte: 1.16.0
15:17:05 <`nand`> suboptimal is better than nothing
15:17:08 <sproingie> it's not hard to write a map function that parallelizes, but having map itself do so, not so much
15:17:20 <sproingie> it can't really know how much of that list is going to be available
15:17:24 <divarvel> mightybyte: https://raw.github.com/gist/5258594
15:17:54 <cschneid> I just asked since I read a post on HackerNews that was all glowing erlang talk, about how it's designed for concurency up front.
15:17:59 <`nand`> sproingie: do you think practical parallelization will hinge on whole-program analysis and supercompilation or whatever the buzz word is?
15:18:08 <mightybyte> divarvel: Hmmm, I also have the same versions of those packages.
15:18:30 <sproingie> some kind of supercompilation i'm sure could help, but i suspect you're always going to want to give it hints.  enter DPH.
15:18:57 <napping> cschneid: Haskell has quite a lot of that, just not any magic "write a serial program, run a parallel program"
15:19:00 <cschneid> is manually-parallelized code in haskell easier to write/reason about?
15:19:02 <napping> nor does Erlang
15:19:16 <glguy> #ifdef USE_CRYPTOAPI
15:19:17 <glguy> -- going away in 0.4.0. use the CPRG instance.
15:19:17 <glguy> instance CAPI.CryptoRandomGen AESRNG where
15:19:20 <connelly> what's the correct way to write a type signature in a multi-line let statement?
15:19:33 <glguy> divarvel mightybyte : That instance is conditionally compiled
15:19:36 <connelly> I want to use read, but I neet to annotate the types
15:19:46 <connelly> s/neet/need/
15:19:55 <mightybyte> divarvel: I've got to head to the NYC Haskell meetup, so I can't look at this more.  I'd recommend looking at some of the clientsession dependencies to see if anything has changed recently and then try to add a --constraint.
15:20:10 <Ralith> connelly: (x :: T) is a legal expression
15:20:11 <hpaste> geekosaur pasted ‚Äúmultiline let with signature‚Äù at http://hpaste.org/84733
15:20:15 <divarvel> mightybyte: ok
15:20:18 <geekosaur> or that wat
15:20:21 <geekosaur> way
15:20:22 <napping> The main things Erlang has over haskell is a distributed runtime, plus standard libraries that make it easy to set up cooperating processes with lots of monitoring and restarting and logging and stuff
15:20:51 <divarvel> glguy: ok
15:20:52 <jfischoff> is there way to pass a flag to cabal and have it build an executable, but otherwise not?
15:20:53 <cschneid> napping: right, the "built for distributed/multiprocess" is right there. It's not haskell's focus of course. Was trying to get a feel for what Haskell does have.
15:20:53 <glguy> divarvel: Now that you have crypto-api installed, try reinstalling cprng-aes . Cabal is probably being clever about guessing flags for you
15:21:00 <divarvel> ok
15:21:30 <glguy> divarvel: and if that doesn't work you can peek to see what flag needs to be turned on and turn it on explicitly
15:21:46 <napping> cschneid: Haskell is good for parallelism across cores on a single node, it's just that the standard stuff doesn't automatically stretch between nodes over the network
15:22:06 <Cale> distributed-haskell!
15:22:08 <connelly> Ralith: let (foo::[[Int]]) = map (map read.words) $ tail stringlist in ....
15:22:13 <connelly> Ralith: like that?
15:22:54 <Cale> http://hackage.haskell.org/package/distributed-process
15:22:55 <Ralith> connelly: foo in that context is not an expression.
15:23:13 <connelly> how do I tell it I want read to force it to be an Int?
15:23:17 <sproingie> yah once you get into remote execution you have a whole different set of problems like "it can fail"
15:23:22 <Cale> ^^ That's an implementation of Erlang's distribution machinery in Haskell
15:23:23 <newsham> > read "1" :: Int
15:23:25 <lambdabot>   1
15:23:50 <sproingie> tho you can take C and P and sacrifice A at which point you can just treat it as a single logical machine with slow buses
15:23:55 <monochrom> connelly, see geekosaur's paste at http://hpaste.org/84733
15:24:10 <monochrom> there are as usual other options
15:24:19 <Cale> http://www.youtube.com/watch?v=1jJ2paFuErM -- here's a great talk about it :)
15:24:45 <Cale> http://www.haskell.org/haskellwiki/Cloud_Haskell (more info here)
15:24:50 <connelly> I get a "no parse" if I do that
15:25:18 <connelly> should I do multiple let .. in for each line or one let and an in at the end?
15:25:37 <geekosaur> one let is customary
15:25:38 <monochrom> ok, you should paste uncensored code
15:25:40 <newsham> https://github.com/panicsteve/cloud-to-butt
15:25:40 <Cale> You just need one let for a bunch of declarations.
15:26:57 <napping> cschneid: are you familiar with the runtime?
15:27:05 <Cale> Cloud Haskell seems rather well-designed and nicely modular, as well as having quite nice semantics (in fact, its semantics aren't quite Erlang's semantics, but what the Erlang folks think the semantics ought to be for future Erlang :)
15:27:09 <hpaste> connelly pasted ‚Äúno parse‚Äù at http://hpaste.org/84735
15:27:17 <cschneid> napping: not in the least.
15:27:18 <sproingie> Butt Haskell
15:27:23 <cschneid> napping: I'm not even familiar with the language.
15:27:33 <cschneid> I've successfully written non-trivial, but short programs so far
15:28:23 <monochrom> eh? your code leads to no error at all here
15:28:59 <connelly> wtf..
15:29:11 <hpaste> ‚ÄúAnonymous Coward‚Äù pasted ‚Äúmap function with tuples‚Äù at http://hpaste.org/84736
15:29:13 <newsham> tabs vs. spaces?
15:29:21 <monochrom> there is no tab in the paste
15:29:24 <connelly> hrms..
15:29:33 <napping> cschneid: threads are quite cheap (similar and perhaps cheaper than Erlang), blocking IO is properly done through epoll/kqueue without tying up OS threads, as many cores as you like can be used
15:29:45 <monochrom> and hpaste does the right thing to tabs anyway
15:29:49 <dates_> I'm the anonymous coward, can you help me with that?
15:29:52 <napping> cschneid: basically everything you want, and only GHC and Erlang seem to actually do
15:30:00 <cschneid> napping: so one-system concurency is relatively easy & fast.  Just missing the distributed nature.
15:30:15 <hpaste> dates revised ‚Äúmap function with tuples‚Äù: ‚Äúmap function with tuples‚Äù at http://hpaste.org/84736
15:30:35 <Cale> dates_: I think you're just missing parens around (distance_calc tpl)
15:31:26 <Cale> dates_: distance_calc tpl will be a function which you want to apply to each of the tuples in the list
15:32:00 <Cale> The expression you wrote is passing distance_calc, tpl, and lst as parameters to map, which is too many
15:32:01 <napping> cschneid: well, easier and faster than just about everything else, but yeah.
15:32:31 <cschneid> napping: cool - I'll have to play with that sometime, this was curiosity so far. I've got lots of learning to do before I really get there
15:33:06 <Cale> cschneid: and if you want the distributed stuff, look at the stuff I linked :)
15:33:27 <napping> is it getting a bit more finishes?
15:33:36 <dates_> Cale: yeah, silly me, thanks :)
15:33:49 <Cale> napping: Was that a question for me?
15:33:50 <connelly> so it compiles fine, but when I execute it gets no parse
15:34:02 <connelly> oh! stupid me
15:34:04 <napping> yeah, in the paper there were some limits to making closures and stuff
15:34:06 <connelly> the numbers are floats
15:35:15 <Cale> napping: Well, this is newer work than was described in SPJ's paper at least
15:35:39 <monochrom> oh, no parse at run time. I misread
15:36:03 <Cale> You have to explicitly tell it about types of closures you want to be able to serialise still.
15:36:20 <Cale> But it seems reasonable.
15:36:28 <divarvel> glguy: I tried to recompile cprng-aes, forcing the cryptoapi flag
15:36:35 <divarvel> glguy: clientsession still fails
15:36:45 <Cale> (There's some TH machinery to make that pretty easy)
15:39:13 <glguy> divarvel: Well, assuming the error is still the same, you need to go figure out 1) if that instance is being defined now 2) if it's not, why it's not
15:39:51 <divarvel> glguy: is there a way to see which flags are enabled ?
15:40:05 <divarvel> glguy: when installing a package
15:41:45 <dEPY> Why is there "Just" there?     let (Just action) = lookup command dispatch
15:42:12 <Clint> pattern matching
15:42:22 <dEPY> ah
15:42:26 <dEPY> ofc
15:42:56 <MCPlayer> For all the Minecraft players: Why u no earn money while playing? You'll even get free coins in the beginning. http://goo.gl/8QExy
15:42:56 <dEPY> no wait, what?
15:43:16 <dEPY> what does it matches?
15:43:16 <glguy> divarvel: I don't know, but you can specify the flag manually with -f
15:43:27 <divarvel> glguy: that's what I did
15:43:27 <monochrom> yes, in general, it's "pattern = expression", not just "variable = expression"
15:43:37 <divarvel> glguy: I just want to make sure it's effective
15:43:44 --- mode: ChanServ set +o glguy
15:43:54 --- mode: glguy set +q MCPlayer!*@*
15:43:56 <monochrom> if "lookup command dispatch" is "Just 4", then action becomes 4
15:44:27 <glguy> Oh, they already k-lined...
15:44:36 --- mode: glguy set -q mcplayer!*@*
15:44:42 <monochrom> idoru is pretty quick and smart
15:44:52 --- mode: glguy set -o glguy
15:44:55 * glguy sulks
15:44:58 <dEPY> monochrom: but, wouldn't it work without the Just ?
15:45:29 <monochrom> depends on what you mean by "work". pick one: do you want action to be 4? do you want action to be Just 4?
15:45:45 <dEPY> Is is because the next statement is:" action args " and if there was no action it would fail but now it wont because it's a MAybe?
15:45:48 <divarvel> glguy: I'm off for tonight. I'm tempted to drop snap and go with scotty
15:45:55 <divarvel> glguy: thanks for the help :)
15:45:55 <elliott> glguy: I was disappointed too
15:46:04 <monochrom> it would fail, yes.
15:46:05 <glguy> divarvel: alright, good luck
15:46:11 <elliott> I like how they even had "spam" in their hostname
15:46:18 <dEPY> monochrom: oh ok, that explains it :)
15:46:19 <monochrom> let me be precise
15:46:48 <monochrom> if "lookup command dispatch" is Nothing, then there will be a runtime error
15:47:48 <Lethalman> divarvel, scotty+fay+blaze+clay+shake is cool
15:48:24 * hackagebot gdiff-th 0.1.0.7 - Generate gdiff GADTs and Instances.  http://hackage.haskell.org/package/gdiff-th-0.1.0.7 (JonathanFischoff)
15:49:22 <gentleben> does anyone know of anything for fusing monad transformer stacks into a single transformer?
15:49:46 <simpson> gentleben: I would expect that you get to write the newtype and instances on your own.
15:49:52 <simpson> gentleben: What did you want to build?
16:02:12 <gentleben> simpson: I am starting to get quite a stack going, soon it will be 6 deep, it would be nice to fuse them into a single one and shorten the type signatures
16:02:23 <gentleben> simpson: I can of course write a wrapper
16:02:36 <gentleben> but I wanted to see if there was an easier way
16:04:04 <simpson> gentleben: Well, are three of your things Reader, Writer, and State? :3
16:04:08 <simpson> There's always RWS.
16:04:32 <gentleben> simpson: mostly thigns that have state under the hood
16:05:10 <simpson> gentleben: Hm. Well, you know about the type keyword right?
16:05:38 * Rachelcrow http://getworld.uk.to - Online Multyplayer Game - How rich you can be? -
16:05:47 <Aune> So Im trying to use Haskell SDL, but when I run my "main" function immediately get "Failed to create secure directory: Invalid argument". What does this mean?
16:05:54 <gentleben> simpson: yes
16:06:41 <simpson> Aune: Pretty much what it says on the tin. What did you ask it to do, exactly?
16:10:22 <Aune> simpson, actually a lot of things. But I managet to get it down to this: http://hpaste.org/84738
16:11:18 * Pods wants to start contributing for swish as a part of GSOC , could anyone guide for the same ??
16:12:14 <simpson> Aune: I'm gonna guess that SDLi.load is the problem.
16:12:23 <simpson> Aune: But I have no idea *why*, sorry.
16:13:02 <Aune> simpson, But the problem remains even if I remove that line
16:13:29 <simpson> Aune: Really? No idea then.
16:18:15 <Aune> Well, thats strange, the problem goes away if I exchange "InitEverything" with "InitVideo"
16:18:46 <simpson> Sounds like something doesn't want to be init'd then.
16:24:34 <Aune> yeah, well, I dont need all of it so thats a future me's problem
16:32:30 <nicoo> Aune: s/future me/future underling/
16:33:22 <Aune> nicoo, true ^^
17:21:44 <w|t> i'm on learnyouahaskell.com and this code doesn't work:
17:21:47 <w|t> boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
17:21:55 <w|t> <interactive>:51:14: parse error on input `='
17:21:57 <w|t> any ideas?
17:22:12 <shachaf> w|t: What is "work"?
17:22:29 <shachaf> My guess is that LYAH wants you to put that in a file but you typed it into ghci. But I don't know.
17:22:35 <sipa> i'm sure "work" implies not getting a parse error
17:22:57 <jfischoff> w|t: just put "let" first
17:23:47 <w|t> oh
17:24:16 <w|t> thanks, jfischoff
17:24:34 <jfischoff> w|t: np
17:24:35 <w|t> why is it that some functions need 'let' whereas others don't?
17:25:18 <Philippa> w|t: Haskell uses 'let' to bind values locally instead of at the top level of a module
17:25:33 <geekosaur> w|t, as you were told, put it in a file and it would have worked as is
17:25:39 <geekosaur> ghci's prompt is not like a file
17:25:46 <Philippa> Haskell also uses lexical scoping constructs (let, the top-level of the module) as a cue to "generalise"
17:25:47 <jfischoff> w|t: the explanation is kinda of technical. For now just remember that when you when you create variables in ghci use let
17:25:52 <Philippa> ghci's prompt isn't one
17:26:00 <Philippa> oh, right, *that*
17:26:02 <shachaf> Perhaps ghci should support "a = b" by now.
17:26:16 <Philippa> shachaf: I hacked that up last time I wrote my own REPL, yeah
17:26:20 <jfischoff> shachaf: good point
17:27:08 <Saizan> i had :let in the language for toplevel bindings instead!
17:27:13 <shachaf> jfischoff: The explanation is "that's how it works -- ghci is its own thing", more or less. :-)
17:27:19 <Saizan> obviously the better option
17:27:30 <shachaf> "ghci is a do block" is more of a mnemonic than an explanation.
17:27:34 <Philippa> shachaf: yeah
17:27:58 <geekosaur> also note ghci is gradually gorwing more toplevel-type things, and that may conceivably change at some point
17:28:16 <shachaf> Right. That's what I meant before.
17:28:17 <jfischoff> shachaf: yeah pretty much. Needlessly tricky for beginners
17:28:20 <geekosaur> (I could in particular see let ... as a binding that can be reset and minus the let is a more permanent one)
17:28:46 <Philippa> geekosaur: Yeah, that'd make sense
17:29:08 <shachaf> ghci will never be like a file.
17:29:12 <Philippa> heck, it'd be great to have the option to log all your bindings to disk
17:29:21 <shachaf> A file lets you reference bindings "before" you define them.
17:30:25 <jfischoff> Philippa: And save a execution as a doctest
17:30:38 <elliott> shachaf: we need spreadsheets.
17:40:35 <Michael__> If i have a string like "pavlov(2,2)", how do I remove the coordinates from the end, ie (2,2)?
17:41:10 <Philippa> so you want to match everything that isn't a pair of coordinates, followed by a pair of coordinates?
17:41:48 <Michael__> Philippa: yes
17:44:19 <Philippa> Michael__: alas, gtg. Someone else can probably help you from there though, and I know Parsec has a combinator that'll do that if you're not artificially limited
17:44:37 <Michael__> I'll look into it, thank you
17:46:03 <jfischoff> :t splitOn
17:46:04 <lambdabot> Eq a => [a] -> [a] -> [[a]]
17:46:31 <jfischoff> > head $ splitOn "pavlov(2,2)"
17:46:32 <lambdabot>   Couldn't match expected type `[a0]'
17:46:33 <lambdabot>              with actual type `[a1] -> ...
17:46:40 <jfischoff> :p
17:46:50 <jfischoff> > head $ splitOn "(" "pavlov(2,2)"
17:46:52 <lambdabot>   "pavlov"
17:47:43 <jfischoff> Michael__: ^ this is the crappy way, what Philippa said is more robust.
17:47:54 <mietek> "But more interestingly, neither Go (golang.org) nor Haskell (GHC) is fully preemptive. Go only switches context on communication, so a tight loop can hog a core. GHC switches upon memory allocation (which admittedly is a very common occurrence in Haskell programs)."
17:47:58 <mietek> http://jlouisramblings.blogspot.co.uk/2013/01/how-erlang-does-scheduling.html
17:48:12 <mietek> Is the comment regarding GHC still true?
17:48:50 <jfischoff> from the doc only calling yield on your thread guarantees switching
17:48:56 <mietek> Reading the Rts/Scheduler commentary, it seems there's more than one way to preempt a thread
17:49:04 <mietek> "A thread was pre-empted via the context switch flag (e.g. incoming message from another thread, the timer fired, the thread cooperatively yielded, etc);
17:49:05 <shachaf> GHC can switch on "pre√´mption points"
17:49:20 <shachaf> Which can happen on allocation and some other contexts.
17:49:40 <shachaf> See e.g. http://hackage.haskell.org/trac/ghc/ticket/367
17:50:06 <shachaf> There's a flag to add more of them at a performance cost.
17:51:10 <shachaf> jfischoff: Concurrent Haskell threads can be entirely co√∂perative, sure, but that's not what GHC does.
17:51:16 <hpaste> cmears pasted ‚ÄúMemory hungry‚Äù at http://hpaste.org/84740
17:51:27 <cmears> Can anyone tell me why that program uses lots of memory?
17:52:37 <jfischoff> shachaf: Right that's the impression I got from the doc
17:54:18 * BMeph_ suspects cmears is doin' it rong... ;)
17:54:18 <gynna> http://xeroticmomentsx.blogspot.com/2013/03/amateurgallery.html
17:54:55 <cmears> I really thought it would use constant space
17:55:24 <mietek> shachaf: so the proposed patch in #367 ‚Äî does it leave any cases where a non-interruptible loop is still possible?
17:56:53 <BMeph_> cmears: How does "thought it would use constant space" conflict with "uses lots of memory?" :)
17:57:09 <shachaf> cmears: I'd guess that the (seqs 15) value is being floated out into a top-level binding.
17:57:24 <shachaf> And therefore not being GCed.
17:58:29 * hackagebot happstack-authenticate 0.10.4 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-0.10.4 (JeremyShaw)
17:58:31 <cmears> Can you tell the compiler not to do that?
17:58:35 <shachaf> Hmm, maybe it's something more complicated.
18:03:29 * hackagebot diagrams-haddock 0.1.0.1 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.1.0.1 (BrentYorgey)
18:18:48 <cmears> The problem is something related to how sequence is implemented for lists, apparently:
18:18:52 <hpaste> cmears annotated ‚ÄúMemory hungry‚Äù with ‚ÄúMemory hungry (annotation)‚Äù at http://hpaste.org/84740#a84741
18:19:18 <cmears> I stumbled upon a way to do it in constant space, but I don't get why there is any difference
18:25:19 <cmears> I think here is the answer: http://stackoverflow.com/questions/3190098/space-leak-in-list-program
18:25:58 <cmears> It's not the whole thing that stays around, but the sublist being consed onto
18:26:15 <shachaf> Ah.
18:26:21 <shachaf> Good to know.
18:28:02 <cmears> The "sequenceDummy" version is a bit tricky
18:28:55 <shachaf> mietek: I don't know.
18:30:39 <mietek> shachaf: thanks.
18:31:27 <shachaf> mietek: At any rate you generally have to really try, or to be doing something unusual, to run into this.
19:02:06 <Michael__> is equality faster to test on chars, or integers?
19:07:18 <napping> Michael__: do you have a benchmark?
20:00:03 <mikurubeam> Is it possible to receive email alerts when specific packages are updated?
20:03:28 <luite> mikurubeam: dunno if hackage has something per package, but hdiff has an atom feed for each package
20:04:32 <luite> http://hdiff.luite.com/cgit/diagrams-lib/atom  for example
20:05:26 <mikurubeam> luite: Ah! ty!
20:06:04 <Shin-LaC> python's help gives you documentation on a function or class
20:06:35 <Shin-LaC> in ghci, :t is helpful, but I wonder if I can get more information
20:07:05 <nimish> anyone know if there is a data.frame like equivalent in hackage?
20:10:12 <tac> Shin-LaC: I believe there's hoogle plugins for GHCi
20:12:06 <Shin-LaC> tac: thanks, I'll try that
20:18:46 <cwl> > :t (/10)
20:18:48 <lambdabot>   <hint>:1:1: parse error on input `:'
20:19:20 <ab9rf> leave out the >
20:19:22 <ab9rf> :t (/10)
20:19:23 <lambdabot> Fractional a => a -> a
20:19:27 <cwl> :t (/10)
20:19:28 <lambdabot> Fractional a => a -> a
20:19:31 <cwl> :t (+10)
20:19:32 <lambdabot> Num a => a -> a
20:19:34 <cwl> :t (-10)
20:19:36 <lambdabot> Num a => a
20:19:39 <cwl> :t (- 10)
20:19:40 <lambdabot> Num a => a
20:19:58 <ab9rf> you have to use subtract for - sections
20:19:59 <cwl> why '-' doesn't act as + * / ..
20:20:06 <elliott> because of negative numbers
20:20:10 <ab9rf> cwl: because of magic syntax for negative numbers
20:20:58 <cwl> how to write code doing the same job as (substract 10) using -
20:21:20 <arkeet> flip (-) 10
20:21:24 <ab9rf> heh
20:21:38 <arkeet> cwl: (- 10) is negative 10.
20:21:48 <arkeet> cwl: this is exactly why subtract is provided.
20:21:58 <cwl> :t add
20:22:00 <lambdabot>     Not in scope: `add'
20:22:00 <lambdabot>     Perhaps you meant one of these:
20:22:00 <lambdabot>       `odd' (imported from Prelude), `and' (imported from Data.List),
20:22:00 <cwl> :t sum
20:22:01 <lambdabot> Num a => [a] -> a
20:22:13 <cwl> arkeet: got it
20:24:30 <ab9rf> @pl \x -> (- x 10)
20:24:30 <lambdabot> negate . ($ 10)
20:24:39 <ab9rf> erg
20:24:45 <ab9rf> @pl \x -> x-10
20:24:45 <lambdabot> subtract 10
20:25:39 <ab9rf> i was curious how lambdabot would pointfree that :)
20:26:10 <cwl> what does @pl mean?
20:26:14 <tac> pointless
20:26:30 <tac> @pl \x -> 2 * x + 1
20:26:31 <lambdabot> (1 +) . (2 *)
20:34:53 <ab9rf> it's mostly silly
20:35:15 <ab9rf> @unpl (.)$(.)
20:35:15 <lambdabot> (\ b c e f -> b c (e f))
20:43:57 <no-n> what do @pl and @unpl mean?
20:44:21 <Clint> pointless and unpointless
20:44:27 <no-n> ahh
21:13:35 * hackagebot bytes 0.1 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.1 (EdwardKmett)
21:14:08 <edwardk> dolio: decided to just release it in general
21:18:56 <dolio> Sounds good.
21:29:40 <lewis1711> is there a way to explicitly declare the type of a variable? like "x::Int = 3" or some such
21:29:55 <shachaf> x :: 3; x = Int
21:30:02 <shachaf> Sometimes x = 3 :: Int
21:31:13 <lewis1711> very good
21:31:49 <NemesisD> hi guys. i'm writing an ADT for an API request. debating doing either data APIResponse a = APISuccess a | APIError ErrorDetail; data ErrorDetail = ParamError | TransportError ..., or should it be APISuccess a | ParamError | TransportError ...
21:32:33 <shachaf> There is also "Either ErrorDetail a"
21:32:38 <NemesisD> on one hand the first case is easier to pattern match on if you don't care about the specific error, but the second is easier if you do
21:33:33 <NemesisD> that one doesn't work great because i've got to define json parsers, and some of the error conditions result in no json at all
21:33:36 * hackagebot test-framework-testing-feat 0.1.0.0 - A test framework provider for testing-feat  http://hackage.haskell.org/package/test-framework-testing-feat-0.1.0.0 (JonathanFischoff)
21:34:06 <NemesisD> so i'd have to have generalized newtype deriving i think
21:34:22 <lewis1711> more minutae: when one does "ghci $file.hs", is there a way to have it run through all the imports? like have all the stuff imported in the source file be available in the interpreter after the file is done running
21:34:39 <NemesisD> not sure what the correct pattern is in haskell
21:35:38 <NemesisD> in a previous project i used my own type instead of either, ended up defining Applicative and Functor instances for it
21:37:12 <edwardk> I apparently moved up to 6th place when I wasn't looking. https://gist.github.com/paulmillr/2657075
21:37:25 <cmears> lewis1711: if the source file loads successfully all the imported modules should already be available
21:37:36 <cmears> (but when there are errors, they aren't)
21:37:44 <edwardk> I'll probably hit 5th this weekend, and then stop advancing, because there is no way I'm doubling my commit rate ;)
21:37:47 <NemesisD> actually it i think it wouldn't be newtype deriving, it would be an orphaned instance, which ghc yells at me about D:
21:38:09 <lewis1711> cmears: thanks. it's a slow day...
21:38:51 <sw2wolf> @google orphaned instance
21:38:53 <lambdabot> http://www.haskell.org/haskellwiki/Orphan_instance
21:38:53 <lambdabot> Title: Orphan instance - HaskellWiki
21:43:13 <NemesisD> maybe i'll just newtype over the either
21:50:49 <TravisD> If you suspect that you're having some memory leaks from laziness, is there some way to spot places where strictness might help? I'm having a hard time reasoning about my code
21:51:19 <NemesisD> is Ix inRange O(N) or does it just compare the 2 elements
21:52:45 <TravisD> NemesisD: I'm not sure, but I think it depends on the particular instance of Ix
21:53:02 <cmears> TravisD, you can try GHC's heap profiling
21:53:05 <TravisD> NemesisD: I could give you an instance of Ix for which inRange checked all the elements
21:53:19 <TravisD> cmears: I've tried that a little bit but I can't really tell what's going on
21:53:44 <cmears> Or add assertions about whether a value should be a thunk or fully evaluated, to check your assumptions
21:53:56 <TravisD> cmears: How can you do that?
21:54:23 <cmears> With the "ghc-heap-view" package (GHC.AssertNF module)
21:54:31 <TravisD> ah okay, thanks
21:54:38 <cmears> you can assert that a value is evaluated
21:54:45 <TravisD> One of the reasons I'm finding it hard to reason about what's going on is because I can't actually test anything
21:54:59 <cmears> Yes, that's a big problem for me too
21:55:06 <cmears> You can't just print out a value to see if it is a thunk (:
21:55:11 <TravisD> heh
22:01:23 <cmears> Is there an easy way to set a timeout on a quickcheck test?
22:01:35 <cmears> e.g. if it takes more than X seconds to return a result, count it as a failure?
22:11:31 <applicative> cmears, but if it takes more than X seconds, shouldnt we count it as a success ;)
22:13:59 <applicative> cmears http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Timeout.html e.g.
22:18:38 * hackagebot test-framework-testing-feat 0.1.0.1 - A test framework provider for testing-feat  http://hackage.haskell.org/package/test-framework-testing-feat-0.1.0.1 (JonathanFischoff)
22:19:04 <hpaste> TravisD pasted ‚ÄúMemory leak‚Äù at http://hpaste.org/84746
22:19:33 <TravisD> Can someone help me understand why I'm leaking memory in this code snippet? Data.Random comes from the random-fu package
22:20:08 <TravisD> Also, I realize that the commented out listExpectation code is wrong, but it also leaks memory
22:22:33 <NemesisD> whats that haskell extension where the types in where clauses bind to those in the main function's type
22:23:02 <mjrosenb> if I want to draw a bunch of stuff on a window with cairo, what is the best method of doing this?
22:23:13 <td123> NemesisD: scoped type variables?
22:23:15 <NemesisD> ah yes
22:23:25 <td123> :)
22:23:30 <fxr> :t (^..folded)
22:23:31 <lambdabot> Foldable f => f b -> [b]
22:23:41 <fxr> :t (^..folded.to)
22:23:41 <shachaf> @ty Data.Foldable.toList
22:23:42 <lambdabot>     Occurs check: cannot construct the infinite type:
22:23:42 <lambdabot>       a0 = Accessor (Accessor (Endo [a0]) b0) (Accessor (Endo [a0]) b0)
22:23:42 <lambdabot>     Expected type: (a0 -> Accessor (Endo [a0]) b0)
22:23:43 <lambdabot> Foldable t => t a -> [a]
22:23:47 <lispy> Anyone tried the ical libraries on hackage?
22:24:21 <fxr> hmm which one is my output
22:24:38 <fxr> :t (^..folded.to)
22:24:40 <lambdabot>     Occurs check: cannot construct the infinite type:
22:24:40 <lambdabot>       a0 = Accessor (Accessor (Endo [a0]) b0) (Accessor (Endo [a0]) b0)
22:24:40 <lambdabot>     Expected type: (a0 -> Accessor (Endo [a0]) b0)
22:25:24 <shachaf> @ty \f -> (^..folded.to f)
22:25:26 <lambdabot> Foldable f => (a -> b) -> f a -> [b]
22:25:30 <augur> > repeat "Accessor ("
22:25:32 <lambdabot>   ["Accessor (","Accessor (","Accessor (","Accessor (","Accessor (","Accessor...
22:25:39 <augur> :(
22:25:44 <augur> ruin my fun why dont you
22:26:07 <fxr> hmm I wonder how can I sequence the monadic actions of "s^@..folded.to f"
22:27:04 <fxr> @ty \s f -> s^@..folded.to f
22:27:05 <lambdabot>     Couldn't match expected type `a0 -> Accessor (Endo [(i0, b0)]) a0'
22:27:05 <lambdabot>                 with actual type `Indexed i0 s0 (Accessor (Endo [(i0, b0)]) s0)'
22:27:05 <lambdabot>     Expected type: Indexed i0 b0 (Accessor (Endo [(i0, b0)]) b0)
22:35:43 <lightquake> does the old-locale package imply that there's a newLocale?
22:37:17 <lightquake> in particular, i have a ZonedTime that i would like to display as "March 28, 2013" or whatever
22:38:15 <elliott> afaik old-locale is the only locale
22:43:38 * hackagebot tuple-lenses 0.1.0.2 - Stock FieldN combos and generators  http://hackage.haskell.org/package/tuple-lenses-0.1.0.2 (JonathanFischoff)
22:45:03 <edwardk> nice of them to hold it in reserve for me like that
22:46:33 <Enigmagic> i'm replacing it, hold off :P
22:47:38 <edwardk> =)
22:48:04 <edwardk> i _do_ have a bunch of l10n and i18n code lying around ;)
22:48:20 <Enigmagic> i do think it's kind of cute that it's been called old-locale for so many years now
22:53:00 <sopvop> is there a library with `newtype Fix f = In { out :: f (Fix f) }` and helper functions?
22:53:39 <shachaf> @hackage recursion-schemes is one
22:53:39 <lambdabot> http://hackage.haskell.org/package/recursion-schemes is one
22:53:55 <shachaf> Probably several others.
22:54:30 <sopvop> I have a feeling what half of hackage packages are made by edwardk
22:54:36 <sopvop> thanks
22:55:14 <shachaf> It also has zygoHistoPrepro :: (Unfoldable t, Foldable t) => (Base t b -> b) -> (forall c. Base t c -> Base t c) -> (Base t (EnvT b (Cofree (Base t)) a) -> a) -> t -> a
22:55:22 <shachaf> Pretty much anything you could ever want.
22:55:29 <sopvop> that one is legendary
22:56:30 <Enigmagic> edwardk: unrelated, would it be generally useful to have sipport in Control.Lens.TH for creating lenses that wrap isos or lenses? been battling with this a bit with the protobuf library... would be nice if makeLensesWith could generate lenses that always applied some accessor lens
22:56:56 <edwardk> wrap isos?
22:57:16 <edwardk> if you use makeIso it generates an iso that can be used directly as a lens if that is what you mean
22:57:35 <edwardk> and makeClassy does that
22:57:42 <Enigmagic> i dunno what the proper term is. i have a newtype wrapper that is similar to Tagged that doesn't do much except carry around some types.
22:57:51 <edwardk> makeLensesWith $ classyRules & ‚Ä¶ can be used to customize the behavior
22:58:53 <edwardk> data Foo = Foo { _fooBar :: Int, _fooBaz :: Double }; makeClass ''Foo;   makes a class class HasFoo t where foo :: Lens' t Foo; fooBar : Lens' t Int; fooBaz :: Lens' t Double
22:59:12 <edwardk> and puts in instance HasFoo Foo where foo = id
22:59:20 <ivanm> preflex: seen lispy
22:59:21 <preflex>  lispy was last seen on #haskell 35 minutes and 34 seconds ago, saying: Anyone tried the ical libraries on hackage?
22:59:23 <edwardk> fooBar and fooBaz compose through that lens
22:59:31 <ivanm> lispy: yes, I was :)
22:59:32 <Enigmagic> edwardk: it's more like this https://github.com/tel/riemann-hs/blob/master/src/Network/Monitoring/Riemann/Types.hs#L156
23:00:32 <ivanm> lispy: I was wondering if you'd managed to have a look at my issues building GLURaw
23:00:40 <edwardk> What is 'field' there?
23:00:57 <edwardk> that seems backwards to me
23:00:59 <Enigmagic> edwardk: some record has '_field :: Tagged X Int' but i'd like 'field :: Lens' t Int' instead of 'field :: Lens' t (Tagged X Int)'
23:01:01 <ivanm> edwardk: a section of land typically used for either open space or agriculture? :p
23:01:11 <edwardk> ivanm: thanks!
23:01:16 <ivanm> heh
23:01:24 <hpaste> sopvop pasted ‚Äúcan lens be generated for this case?‚Äù at http://hpaste.org/84749
23:01:31 <edwardk> Enigmagic: blech =P
23:01:40 <ivanm> how does one deal with stuff in the ST monad with Criterion?
23:01:44 <sopvop> ^ lens question. every constructor have 'a' as first argument
23:01:53 <Enigmagic> edwardk: this is field https://github.com/alphaHeavy/protobuf/blob/master/src/Data/ProtocolBuffers/Types.hs#L105
23:02:03 <edwardk> sopvop: it could. its probably not smart enough to know it can
23:02:34 <edwardk> sopvop: you can't generate lenses for those, but you can generate prisms for the constructors
23:02:40 <TravisD> For those interested, I fixed the memory leak I had before. I would appreciate some style suggestions though: http://hpaste.org/84748
23:02:43 <sopvop> maybe something like `makeLensForArg 1 ''Foo`
23:03:01 <edwardk> sopvop: its a bit too 'one-off' even for lens ;)
23:03:09 <sopvop> :)
23:03:15 <edwardk> sopvop: nothing stops you from writing it by hand though
23:03:18 <edwardk> the lens itself is trivial to write
23:03:32 <sopvop> It is tiresome
23:03:34 <edwardk> oh i see you already did
23:03:52 <edwardk> clearly you should have put the annotation as the last field to make it less painful ;)
23:03:57 <edwardk> exprAnn f (SlBinary a b c d) = (\a' -> SlBinary a' b c d) <$> f a
23:03:58 <edwardk> vs.
23:04:07 <edwardk> exprAnn f (SlBinary a b c d) = SlBinary a b c <$> f d
23:04:28 <sopvop> I wrote original code when I had little expirience with haskell.
23:05:03 <edwardk> Enigmagic: that is a pretty alien way to use lens =P
23:05:20 <sopvop> Changing it now means changing 600 loc trifecta parser (which btw take 30 seconds to compile)
23:05:22 <edwardk> Enigmagic: i can kind of see how and why you are doing it, its kind very odd
23:05:29 <Enigmagic> edwardk: better ideas?
23:05:47 <sopvop> I guess it does lots of inlines
23:05:53 <edwardk> Enigmagic: a bit too buried at the moment to switch gears that much
23:05:59 <edwardk> sopvop: yeah
23:06:44 <Enigmagic> edwardk: this is the 3rd or 4th attempt at different representations... so generally happy with it in terms of using the library, not so happy with the library itself though.
23:08:21 <latermuse> @unpl (.).(.)
23:08:21 <lambdabot> (\ i b c f -> i (b c f))
23:08:45 <latermuse> *mind blown*
23:09:37 <c_wraith> wow, @pl chose horrible names for those values :)
23:09:49 <latermuse> how do i install @pl on my own ghci?
23:10:25 <c_wraith> lambdabot isn't ghci.  It just uses a standalone program to do that
23:10:44 <latermuse> which program?
23:11:02 <latermuse> is the code available somewhere?
23:11:48 <c_wraith> http://hackage.haskell.org/package/pointfree
23:14:18 <ivanm> warning: pointfree doesn't like ()
23:14:33 <ivanm> took me a while to work out why code I had gotten from point-free wasn't typechecking :s
23:15:08 <shachaf> Yep.
23:15:16 <shachaf> @pl return ()
23:15:16 <lambdabot> return ()
23:15:27 <shachaf> Hmm.
23:15:41 <shachaf> Well, something or other.
23:15:50 <ivanm> @pl \ v -> maybe v (const $ return ())
23:15:50 <lambdabot> flip maybe (const (return ()))
23:15:53 <ivanm> huh
23:15:58 <ivanm> maybe the version in lambdabot works...
23:16:11 <ivanm> or it could have been somethimg more subtle...
23:16:18 <ivanm> @pl \ x -> (,) x ()
23:16:19 <lambdabot> flip (,) ()
23:16:59 <YayMe> So I implemented something monad like in C#, similar to the exception monad. But it had a key distinction that made me basically trash the monad, I'm thinking the correct way would have been to use a monad transformer but I've not worked with those yet so I didn't really know
23:18:07 <YayMe> It works just like the exception monad except that it also carries a key around with it which is made available to all monadic functions for use looking up information about the current operation
23:18:37 <YayMe> so instead of being a monad m a, it's like an m k a
23:18:49 <YayMe> is that the kind of scenario where you want a transformer?
23:19:04 <YayMe> or should I have just used a tuple in my monad?
23:19:34 <edwardk> YayMe: the problem is when you go to define a monad transformer in c# is you run into the problem that you can't quantify over something with an unapplied type arg
23:19:51 <edwardk> YayMe: c# doesn't have that very concept
23:20:23 <YayMe> yeah, I know I can't really do a monad correctly in C#, I ran into that months ago the first time I tried doing a monad in C#, but you can fake a monad just by kind of hand implementing it against a fixed type
23:20:36 <YayMe> can you not fake a monad transformer similarly to how I faked my monad?
23:20:50 <YayMe> I just implemented a bind operation on the class that is Failable<K,T>
23:20:55 <edwardk> yes, but a monad-transformer kind of directly contradicts that ;)
23:21:24 <edwardk> you can implement any one monad, just no monad transformers because you've repeated the problem one level down
23:21:57 <YayMe> gotcha, monad transformers *require* that higher kinded polymorphism or whatever it's called that you can't do in C#
23:22:17 <shachaf> edwardk: That sentence also works with s/of //
23:22:19 <edwardk> Monad :: (* -> *) -> Constraint is the problem, so you monomorphized and moved the Monad definition into the particular data type you were interested in. MonadTrans :: ((*-> *) -> * -> *) -> Constraint so when you go to lower it you get (* -> *) -> * -> * still and are still stuck
23:22:20 <YayMe> You couldn't even fake it as a fixed transformer that only transforms monad x and y
23:22:43 <edwardk> correct
23:23:19 <YayMe> Ok, then I won't worry about the fact that I totally tossed out the monad rules when I added the key piece to my monad
23:23:56 <YayMe> In haskell though, does that make sense as a purpose for a monad transformer? Basically that i wanted an extra value to be carried around with my a, or would you generally just use a tuple?
23:24:45 <YayMe> I guess if you don't want another effect (that's what you call that behaviour in the bind right? a monadic effect?) you don't need another monad...
23:25:04 <YayMe> or is the (a -> m b) the "effect" ?
23:26:41 <edwardk> you can make a monad transformer that carries around an extra value in a few ways. ReaderT, WriterT and StateT kind of reflect the most common
23:28:39 * hackagebot bits 0.1 - Various bit twiddling and bitwise serialization primitives  http://hackage.haskell.org/package/bits-0.1 (EdwardKmett)
23:28:52 <YayMe> So that is a reasonable use od a transformer? I just implemented the exception monad to deal with service requests and being able to kleisli together a variety of activities that vary from one request to the next, but all of them need the key that's particular to their service request used for accessing cache information on the previous requests
23:29:40 <YayMe> If it were haskell a ReaderT would be rational way of tacking a key on that would be available to all those functions being kleisli'd on in the exception monad?
23:30:42 <edwardk> yeah Reader is a perfectly cromulent monad transformer
23:31:25 <edwardk> the 'effect' it gives you access to is the ability to read the environment you passed it, if you must think of monads as a way of accessing certain effects ;)
23:32:16 <YayMe> I thought somebody told me in here a while back the term "monadic effect" is the correct one for what the bind gives you, is there a different more correct term for what it gives you?
23:39:38 <ivanm> how does one deal with stuff in the ST monad with Criterion?
23:40:32 <ivanm> e.g. a mutable vector; how do I a) ensure that it is fully evaluated before running any benchmarks, and b) what's the best way to ensure it's evaluated (nf . runST ?)
23:43:04 <ivanm> well, I can't go via nf . runST, as MVector isn't an instance of NFData :/
23:48:39 * hackagebot Ref 0.1.0.0 - Generic Mutable Ref Abstraction Layer  http://hackage.haskell.org/package/Ref-0.1.0.0 (CarterSchonwald)
