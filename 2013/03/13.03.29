00:16:34 <dudlite> hello
00:16:57 <dudlite> having problems splitting lists recursively for merge sort function
00:17:22 <dudlite> this is what I wrote to split one list into two
00:17:23 <dudlite> halve :: [a] -> ([a],[a])
00:17:28 <no-n> wouldn't flip . flip $ f just return f?
00:17:30 <dudlite> halve k = splitAt (length k `div` 2) k
00:18:52 <shachaf> Oh boy.
00:18:57 <shachaf> We just had this a few days ago.
00:19:14 <shachaf> For a good time make it lazier.
00:19:38 <c_wraith> for an even better time, merge bottom up
00:20:06 <dudlite> my understand of merge sort is it just splits all the lists until 1 element remains
00:20:15 <dudlite> then my sort method just sorts each list up
00:20:19 <dudlite> from bottom
00:20:24 <lightquake> why does highlighting-kate use two-character CSS classes?
00:20:26 <dudlite> understanding*
00:20:44 <dudlite> function*
00:21:35 <c_wraith> dudlite: that's what a top-down mergesort does.  It starts at the top, then does the splitting recursively
00:21:36 <shachaf> Well...
00:21:52 <shachaf> Using "length" is probably a bad sign for a function like this.
00:22:04 <dudlite> because it has to traverse twice?
00:22:16 <dudlite> not worried about big n for this one
00:22:18 <c_wraith> dudlite: a bottom-up mergesort starts by doing a single pass to divide everything into lists of length one, then starts merging adjacent pairs
00:22:22 <dudlite> just a homework assignment
00:22:38 <lightquake> in a not-entirely-unrelated note, i wish pandoc didn't take ages to link against
00:22:54 <shachaf> This is also about elegance. :-)
00:23:13 <dudlite> Thankyou wraith
00:23:16 * shachaf is in favor of getting the length out of your system early.
00:23:37 <shachaf> Anyway, you haven't mentioned the trouble you're having yet.
00:23:39 <dudlite> whats the runtime on length?
00:24:08 <dudlite> o(n)??
00:24:20 <dudlite> Sorry, I am new to this language
00:24:23 <dudlite> confused as heck lol
00:24:38 <dudlite> pretty much I know what to do, just don't know how to do it
00:24:47 <dudlite> having problem calling my function recursively
00:26:27 <shachaf> [] is a (singly-)linked list, so yes, it's O(n) (in fact, it's exactly n).
00:27:14 <dudlite> ahh
00:27:18 <dudlite> thanks
00:28:39 <dudlite> sorry, I know so little about this language I am having problems explaining what my problem is lol
00:28:47 <dudlite> basicly the type is this
00:28:49 <dudlite> halve :: [a] -> ([a],[a])
00:29:03 <dudlite> which is returning two arbitary lists
00:29:32 <dudlite> arbitrary
00:29:34 <dudlite> oops
00:31:24 <dudlite> i ne
00:31:25 <dudlite> .0
00:32:04 <shachaf> I see.
00:36:06 <yezariaely> I want to use mapM f someList  where someList :: [(a,b)] and now I want f to replace the second element of the tuple with something that comes from state. Right now I have f (xi,_) = getNext >>= \v -> return (xi,v)  with getNext returning something from state. Can't I abbreviate this with second and liftM somehow?
00:36:20 <yezariaely> (second from Control.Arrow)
00:37:52 <yezariaely> the approach second getNext obviously does not work as this leaves the monadic context.
00:39:23 * hackagebot certificate 1.3.6 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.3.6 (VincentHanquez)
00:39:26 * hackagebot case-insensitive 1.0.0.1 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-1.0.0.1 (BasVanDijk)
00:40:53 <supki> @pl getNext >>= \v -> return (xi,v)
00:40:54 <lambdabot> (,) xi `fmap` getNext
00:41:46 <yezariaely> hmm. How does this know, that it works only on the second component?
00:41:52 <yezariaely> @ty (,)
00:41:53 <lambdabot> a -> b -> (a, b)
00:43:04 <dmead> !!!
00:43:54 <supki> yezariaely:   m >>= \x -> return (f x)  =   fmap f m
00:44:00 <supki> @pl m >>= \x -> return (f x)
00:44:01 <lambdabot> f `fmap` m
00:45:10 <yezariaely> supki: I see, thanks
00:45:41 <aavogt> :t \f -> uncurry ((. return) . ap ) . first (liftM zip . mapM f) . unzip
00:45:42 <lambdabot> Monad m => (a1 -> m a) -> [(a1, b)] -> m [(a, b)]
00:46:18 <yezariaely> @pl \(xi,_) -> (,) xi `fmap` getNext
00:46:18 <lambdabot> (`fmap` getNext) . (,) . fst
00:47:37 <yezariaely> can't this be somehow shortened using Control.Arrow.second ?
00:47:47 <yezariaely> I don't like the (,) . fst part
00:48:20 <shachaf> The . fst part seems OK.
00:48:29 <shachaf> You're explicitly ignoring the second half of the tuple.
00:49:23 * hackagebot packer 0.1.0 - Fast byte serializer and unserializer  http://hackage.haskell.org/package/packer-0.1.0 (VincentHanquez)
00:49:53 <yezariaely> ah yes, now it gets clearer. use the first part as-is and for the second do ...
00:50:25 <shachaf> By the way, not everything has to be point-free.
00:50:36 <yezariaely> hehe I know ;)
00:51:35 <yezariaely> I just want to get a feeling for what part should be written in point-free style and what not. Thus I try to write everything pf and then see what is ugly.
00:52:08 <shachaf> Good approach.
00:52:11 <mjrosenb> is it just me or is http://www.haskell.org/haskellwiki/X_window_programming_in_Haskell#Drawing_in_windows seriously lacking in the indentation department?
00:53:25 <shachaf> mjrosenb: You don't like one-space indentation?
00:53:35 <shachaf> Oh, hmm.
00:53:40 <shachaf> Yes, it looks lacking.
00:53:44 <shachaf> I wonder whether it parses.
00:55:11 <mjrosenb> shachaf: it does not.
00:55:18 <mjrosenb> X2.hs:10:2: parse error on input `let'
00:56:05 <mjrosenb> oh my, every example on that page is just like it
00:57:32 <shachaf> Wait, which example is that?
00:58:13 <shachaf> "We can now rewrite our initial code using the new function now."?
00:58:23 <mjrosenb> "We can now rewrite our example using this new approach: "
00:58:25 <mjrosenb> I believe.
00:58:47 <shachaf> Er, right, I was looking at an old version of the page.
00:58:55 <mjrosenb> yeah, that must be it.
00:59:03 <shachaf> Or not.
00:59:08 <shachaf> Yes, that's messed up.
01:02:32 <mjrosenb> I like how 5 of the last 7 or so changes are "fix the formatting"
01:03:11 <mjrosenb> ugh.
01:03:35 <mjrosenb> it seems like the easiest solution is "pull in gtk even though I only want to blat cairo to the screen.
01:03:37 <mjrosenb> "
01:04:31 <shachaf> Sounds like the sort of thing that happens.
01:04:40 <mjrosenb> :(
01:05:27 <shachaf> Don't hate Gtk. Hate the universe.
01:06:17 <mjrosenb> shachaf: I don't see any reason to not hate both
01:06:32 <mjrosenb> as well as triple negations.
01:06:53 <shachaf> That was only double.
01:07:08 <mjrosenb> shachaf: so?
01:07:18 <shachaf> So constructivists are still fine with it.
01:07:27 <shachaf> You have to get to triple negations to annoy them.
01:10:49 <yezariaely> When I use smart constructors to ensure that some constraints are met within my data constructors I don't want to export the normal data ctor. Can I somehow pattern match on the ctor outside, then?
01:10:49 <circle> how do I make a function return any number type?
01:10:52 <circle> Is it Num a => ?
01:11:05 <shachaf> yezariaely: Not if you don't export it.
01:11:07 <yezariaely> circle: f :: Num a -> b -> a
01:11:17 <yezariaely> circle: sorry, typo f :: Num a => b -> a
01:11:24 <shachaf> circle: It depends on what you're doing.
01:11:46 <circle> finding the sum of a list, just an exercise. I could be lazy and use double or something but technically the sum could be any rational.
01:12:15 <shachaf> Rational numbers isn't the same thing as any numbers!
01:12:35 <circle> a computer can't store an irrational number
01:12:43 <shachaf> Anyway, how about this: Write the function without giving it a type signature. Then ask ghci for its type.
01:12:50 <shachaf> Sure a computer can store an irrational number.
01:13:13 <shachaf> It can also store compex numbers and other things.
01:13:36 <circle> shut up man
01:13:49 <shachaf> ?
01:13:54 <circle> sorry, I take that back.
01:13:54 <shachaf> Oh well. Have fun.
01:15:44 <yezariaely> shachaf: any other possibility to restrict a data constructor's range but maintain pattern matching capabilities?
01:16:23 <yezariaely> I thought about a phantom type which can be instantiated in the module only?
01:16:28 <yezariaely> would this be possible?
01:16:36 <shachaf> yezariaely: There are view patterns...
01:16:46 <shachaf> It depends on what you're doing.
01:17:43 <yezariaely> ah view patterns locks like a solution for the problem.
01:17:54 <shachaf> Only sort of a solution.
01:18:33 <yezariaely> I have data Exp = Var String | ... and I want to ensure that String is always upper case.
01:18:47 <yezariaely> so I thought smart ctor is applicable.
01:19:03 <yezariaely> though then I don't export Var and can't pattern match.
01:19:34 <shachaf> You can make a "newtype UppercaseString" and have that be the smart constructor.
01:19:53 <shachaf> Then you can export Var.
01:20:10 <shachaf> Or you can parameterize Exp on the identifier type and move the problem elsewhere. :-)
01:20:33 <yezariaely> so, I basically hide the information that it is a string.
01:20:43 <yezariaely> hmm I see.
01:20:55 <yezariaely> moving elsewhere is a nice approach ;)
01:21:47 <shachaf> Sometimes if you move a problem around enough it stops being a problem.
01:21:59 <shachaf> At least that's what I'm hoping will happen. Any day now...
01:22:29 <yezariaely> though moving the problem from one stack on your desk to the other isn't helping ... ;)
01:32:24 <mjrosenb>     Could not find module `Time'
01:32:24 <mjrosenb>     It is a member of the hidden package `haskell98-2.0.0.1'.
01:32:40 <mjrosenb> what should I be importing now, rather than 'time'?
01:32:47 <shachaf> Data.Time?
01:35:12 <mjrosenb> Canvas.hs:3:34: Module `Graphics.UI.Gtk' does not export `fill'
01:35:12 <mjrosenb> Canvas.hs:3:51: Module `Graphics.UI.Gtk' does not export `lineWidth'
01:35:14 <mjrosenb> great.
01:35:33 * mjrosenb will deal with this bs in the morning.
01:36:02 <shachaf> Graphics.UI.Gtk.Gdk.GC?
01:36:53 <augur> are there any hypergraph packages for haskell?
01:37:38 <augur> hmm. seems there is one
01:38:20 <mjrosenb> shachaf: joke's on you!
01:38:40 <mjrosenb> shachaf: that was in a hiding declaration, so it doesn't matter if it is missing!
01:39:24 <shachaf> ?
01:39:30 <shachaf> You mean you imported hiding those things?
01:39:35 <mjrosenb>   import Graphics.UI.Gtk hiding (fill,drawPolygon,lineWidth)
01:39:38 <mjrosenb> yeah.
01:39:43 <shachaf> Good joke.
01:39:50 <mjrosenb> i'm just copying and pasting examples from the web
01:39:52 <shachaf> Anyway, hayoo++ for finding it.
01:40:01 <mjrosenb> trying to find something recent enough that it compiles
01:40:25 <mjrosenb> because gtk/X/cairo documentation is kinda annoying to read.
01:45:01 <dEPY> erm
01:45:17 <dEPY> is there any way to convert strings like "*", "+" to the functions?
01:45:36 <dEPY> so I could take parameter named: op     and to  (op) arg1 arg2 ?
01:48:29 <dEPY> on the other hand it's not the best idea ever...
02:00:18 <notdan> @pf (\_ -> f)
02:00:18 <lambdabot> Maybe you meant: bf pl
02:00:23 <notdan> @pl (\_ -> f)
02:00:23 <lambdabot> const f
02:03:25 <hamid_> > bf pl
02:03:27 <lambdabot>   Not in scope: `bf'
02:03:27 <lambdabot>  Perhaps you meant one of these:
02:03:27 <lambdabot>    `b' (imported from D...
02:16:31 <yezariaely> @pl get >>= \s -> return $ TVar (show s)
02:16:32 <lambdabot> (TVar . show) `fmap` get
02:17:45 <yezariaely> is there a function for a state monad which returns current state and applys a function on the state? I currently do a modify f >> get.
02:18:02 <yezariaely> order doesn't really matter for me.
02:18:12 <yezariaely> so, applying f after getting is fine, too.
02:19:18 <augur> @pl get >>= \s -> return $ f s
02:19:18 <lambdabot> f `fmap` get
02:19:51 <augur> yezariaely: unless you want to apply f to the state, rather than return that value
02:20:07 <yezariaely> augur:  I want to apply it to the state.
02:20:13 <augur> @pl get >>= \s -> put $ f s
02:20:14 <lambdabot> put . f =<< get
02:20:22 <augur> @pl modify f >> get
02:20:22 <lambdabot> modify f >> get
02:20:26 <augur> :|
02:20:38 <augur> @def modify
02:20:38 <lambdabot> Maybe you meant: bf do let
02:20:43 <augur> @define modify
02:20:47 <augur> @src modify
02:20:48 <lambdabot> Source not found. My mind is going. I can feel it.
02:20:50 <augur> :(
02:20:55 <yezariaely> well... ;)
02:21:13 <augur> well anyway, modify f >> get will apply f to the state and also return the result, i think
02:21:25 <augur> if all you want to do is apply f to the state, obviously you just want modify f
02:21:41 <augur> if you want to leave the state alone but return f of the state, then get >>= put . f
02:21:48 <yezariaely> sure, I want both. I am fine with modify and get, just wondered if there is a shorter one.
02:22:00 <augur> shorter one for which tho
02:22:05 <augur> i mean, probably not, but
02:22:38 <yezariaely> applying a function f to the current state AND returning the value of the state (either before, or after applying f doesn't matter)
02:22:51 <dEPY> any1 can tell me why my RPN calculator can do "1 2 +" but not "1 2 3 +", says parse error:  http://hpaste.org/84808
02:23:24 <augur> oh. then probably no. but if you dont like writing things like that, you can just write your own little function!
02:23:40 <augur> > let putModify f = put . f =<< get
02:23:42 <lambdabot>   not an expression: `let putModify f = put . f =<< get'
02:23:44 <augur> :|
02:23:49 <augur> @let putModify f = put . f =<< get
02:23:51 <lambdabot>  Defined.
02:23:58 <augur> @pl putModify f
02:23:58 <lambdabot> putModify f
02:23:58 <yezariaely> augur: Just beeing curious I like the version modify f >> get
02:24:26 <augur> yezariaely: if youre writing with do notation (you should) youll just write   do modify f ; get
02:24:28 <augur> er
02:24:37 <augur> do modify f ; s <- get
02:24:43 <augur> then the rest of your stuff
02:25:04 <yezariaely> currently it is:  getNext = modify (+1) >> (TVar . show) `fmap` get
02:25:14 <yezariaely> which seems to be fine without 'do'
02:27:07 <yezariaely> or should I rather use 'do' in this one liner?
02:27:15 <augur> blegh. i dont like it
02:27:59 <augur> getNext = do modify (+1) ; s <- get ; return $ TVar $ show s
02:28:01 <augur> but thats just me :)
02:28:59 <yezariaely> augur: Just compare the two versions and I agree with you. The do-version is cleaner.
02:29:03 <augur> or at least   getNext = modify (+1) >> return . TVar . show =<< get
02:29:04 <yezariaely> +d
02:29:49 <augur> i think the do is cleanest
02:31:03 <augur> return $ TVar (show s) might look even nicer. using $ after the return but treating the rest like normal function application creates a nice visual separation between the monadic and non-monadic parts
02:31:25 <yezariaely> in fact this is what I just coded ;)
02:31:42 <kartoffelbrei> dEPY: to see whats going on you should use Debug.Trace
02:33:32 <kartoffelbrei> i for one like to define a helper function "traceIt :: Show a => a; traceIt x = trace (show x) x". the replace the "read" with "(read . traceIt)" to see the arguments it will get.
02:34:22 <kartoffelbrei> s/the replace/then replace/
02:35:23 <kartoffelbrei> the traceIt function simply takes the argument, prints it and returns it again. it's useful for quick and dirty debugging.
02:35:25 <dEPY> then the whole thing will return a Show :S
02:35:34 <dEPY> no?
02:35:40 <kartoffelbrei> try it.
02:36:16 <dEPY> Could not deduce (Show (String -> String))
02:36:39 <kartoffelbrei> traceIt doesn't do anything. the argument to read is always a string, which is a "Show a => a".
02:38:35 <dEPY> It says there's problem with traceIt itself
02:38:58 <hpaste> kartoffelbrei pasted “heres what i did” at http://hpaste.org/84809
02:39:27 <dEPY> u fogot the one -> a   the first time :)
02:39:35 <dEPY> ok now
02:39:59 <kartoffelbrei> oh sorry, my bad.
02:40:10 <dEPY> np
02:40:16 <dEPY> cool little function btw :)
02:47:41 <dEPY> kartoffelbrei: I still have no idea what's wrong with it. If I give it "1 1 +" it works fine, and first two reads are "1" and "1" but If I give it "1 1 1 +" first read is "+" somehow and it fails :S
02:48:43 <hpaste> yezariaely pasted “Code” at http://hpaste.org/84810
02:49:02 <yezariaely> anyone willingly to look at the just pasted code for improvements in style?
02:49:23 <yezariaely> I'd consider it to be rather ugly, but I am new to haskell.
02:50:17 <dEPY> I'm also new, but, you got to split that big chunk into smaller functions
02:51:46 <dEPY> any1 else willing to look at my rpn calculator and tell my why is it failing to process "1 1 1 +" but works fine with "1 1 +" :S  http://hpaste.org/84811 ?
03:00:11 <hpaste> kartoffelbrei pasted “just added more traces” at http://hpaste.org/84812
03:01:31 <yezariaely> dEPY: so what do you expect it should do? "1 1 1 +" ?
03:02:08 <yezariaely> "1 1 + 1 +" would be fine in my opinion?
03:02:18 <yezariaely> but this term is not well-defined in upn
03:02:34 <yezariaely> + is binary not ternary
03:03:16 <kartoffelbrei> he expects it to put the result "2" on the stack and then do "2" + "1"
03:03:37 <yezariaely> but why?
03:04:08 <yezariaely> if he expects two additions, then there must be two additions.
03:04:13 <yezariaely> there is only one.
03:04:54 <yezariaely> the RPN seems to be perfectly fine. It is the input that is wrong
03:08:52 <kartoffelbrei> it is. i should have seen that. i feel stupid. i need coffee.
03:53:07 <NoWhereMan> hi all, is it correct to say that the "standard monad laws" described here http://en.wikibooks.org/wiki/Haskell/Category_theory#The_third_and_fourth_laws are the associativity and unity laws in Asperti-Longo (chap.5,p.104) ?
03:53:43 <NoWhereMan> and if that is correct, what do law 1 and 2 correspond two ?
03:54:29 <bitonic> NoWhereMan: it’s probably useful to reproduce the laws you are talking about here
03:55:26 <bitonic> btw I think that ‘do { let { y = v }; x }  -->  let y = v in do { x }’ is wrong
03:55:52 <Cale> bitonic: wrong how?
03:56:00 <bitonic> since the ‘do’ let is different with regards to pattern matching.  more like ‘do y <- return v; x’
03:56:10 <Cale> what?
03:56:16 <bitonic> Cale: pattern match failures with do lets will invoke ‘fail’, iirc
03:56:19 <Cale> no
03:56:24 <Cale> They shouldn't
03:56:45 <bitonic> Cale: iirc the only way to get pattern match failures in ‘do’ was ‘case’ but I might be wrong, let’s see
03:57:01 <bitonic> > fail "foo" :: Either String a
03:57:03 <lambdabot>   *Exception: foo
03:57:07 <bitonic> > fail "foo" :: Maybe a
03:57:09 <lambdabot>   Nothing
03:57:26 <bitonic> > do let Just _ = Nothing; return 1 :: Just Int
03:57:28 <lambdabot>   <hint>:1:26:
03:57:28 <lambdabot>      Invalid type signature: return 1 :: Just Int
03:57:28 <lambdabot>      Should ...
03:57:31 <Cale> > do { let { Just x = Nothing } ; x }
03:57:32 <lambdabot>   *Exception: <interactive>:3:12-27: Irrefutable pattern failed for pattern D...
03:57:43 <bitonic> I stand corrected :)
03:57:45 <Cale> > do { let { Just x = Nothing } ; return x } :: Maybe Integer
03:57:46 <lambdabot>   Just *Exception: <interactive>:3:12-27: Irrefutable pattern failed for patt...
03:58:05 <bitonic> > do { Just x <- return Nothing ; x } :: Maybe Integer
03:58:06 <lambdabot>   Nothing
03:58:17 <NoWhereMan> bitonic, you can find them on page 105 here http://www.ling.ohio-state.edu/~plummer/courses/winter09/ling681/asperti-longo/5Adj.pdf
03:58:36 <Cale> NoWhereMan: The "third and fourth laws" on that page just say that return and join are natural transformations
03:58:52 <bitonic> Cale: I can’t remember in which situation the only way to reliably get a failure was ‘case’...
03:59:00 <Cale> NoWhereMan: (they're the naturality squares)
03:59:46 <Cale> bitonic: Well, pattern bindings in let are lazy: you'll only get the exception if you demand the evaluation of the value.
04:00:26 <bitonic> Cale: no, it was something else that came up in a discussion here.  mhm
04:00:44 <Cale> > let Nothing = Just 5 in "this will be fine because the pattern Nothing doesn't bind any variables and so the failed match will never be discovered"
04:00:46 <lambdabot>   "this will be fine because the pattern Nothing doesn't bind any variables a...
04:01:47 <Peaker> Hard to debug what's keeping some objects alive.. finalizers not running
04:01:59 <bitonic> Cale: yeah, but I remember some strange behaviour with ‘do’ and fail
04:02:07 <bitonic> maybe I imagined it
04:03:54 <Saizan> fail is relevant for <-
04:04:52 <hpc> i always liked being able to do that
04:06:57 <bitonic> yeah pattern matches failures with ‘<-’ are nice
04:07:14 <Peaker> what are some good ways to debug a leak, or what's holding some value alive?
04:07:23 <bitonic> boh.  I must be confusing this issue with something else
04:07:35 <Peaker> in Python there's the "gc" module, you can ask it who refers to some value
04:08:57 <hpc> Peaker: do profiling
04:09:39 <Peaker> it's not a massive leak of many objects, but rather a leak of a few, very large objects
04:09:54 <hpc> even easier :P
04:09:59 <Peaker> I know exactly which objects aren't being freed, but afaik I'm not holding any references to them
04:10:05 <hpc> ah
04:10:07 <Peaker> and GC is running many times, not freeing them
04:10:21 <Peaker> is there a heap drawing thing?
04:10:23 <Peaker> visualizing
04:10:32 <hpc> there is; i forget what it is called
04:11:03 <hpc> something that has bit me in the past is doing something like
04:11:18 <hpc> loop = do {action; loop; return ()}
04:11:43 <Peaker> what leaked?
04:11:52 <hpc> the (>> return ()) action
04:11:56 <hpc> making it not a tail call
04:12:25 <Peaker> ah, well, I have an immutable Vector of MVars that hold "Cells", a Cell a = Uncomputed | Computed | Computing ThreadId
04:13:03 <Peaker> and the result of the computation of a cell is a drawing-combinators sprite, that has an allocation of an OpenGL texture ID in it
04:13:06 <hpc> if you can narrow it down to a simpler section of code, hpaste it
04:13:11 <Peaker> and when the sprite dies, it's finalizer will free the GL texture
04:13:12 <bitonic> hpc, Peaker: hp2ps?
04:13:28 <Peaker> I'll run some profiling just to get more input
04:13:44 <bitonic> (regarding the ‘heap visualising’ thing)
04:13:50 <NoWhereMan> Cale, then what about the first and second law?
04:16:39 <Peaker> bitonic, I want something to show me specific heap objects and pointers
04:17:12 <bitonic> Peaker: there was threadscope but that’s oriented towards parallelism
04:17:26 <bitonic> and I don’t think it does what you want
04:17:35 <Peaker> hah! If I use +RTS -h, I can see the finalizer printing that it's running
04:17:45 <Peaker> as expected
04:17:50 <Peaker> but without +RTS -h, it never runs
04:17:59 <Peaker> is this likely a GHC bug?
04:20:21 <Tordek> this is on a thread while main dies early? that's not a bug, but there's no easy way to have main wait on all threads iirc (this is quoting from a talk I watched last week, so grain of salt)
04:21:49 <Peaker> Tordek, nope, main is alive till the end
04:22:20 <merijn> Tordek: Well, depends you can wrap forkIO to update a top level MVar (using unsafePerformIO) and hen block until that's updated to a value indicating all threads have closed
04:22:34 <merijn> Which is pretty easy to implement
04:22:52 <merijn> Global mutable state \o/
04:23:07 <Tordek> \o/
04:27:27 <Eduard_Munteanu> Tordek: you can wait on all threads if you use something like 'async'
04:27:32 <Eduard_Munteanu> @hackage async
04:27:32 <lambdabot> http://hackage.haskell.org/package/async
04:29:11 <NoWhereMan> Cale, if I've understood correctly the first two laws are the definition of \mu and \eta in the monad (T,\mu,\eta)
04:30:55 <NoWhereMan> so haskell's monad laws would be 2 laws that enforce the definition of monad (of course), and then two extra laws that  require the naturality of \mu and \eta (which I think is part of the theoretical definition of monad itself)
04:33:17 <Peaker> "cabal clean && cabal configure --enable-{executable,library}-profiling && cabal build" <-- not building with profiling enabled, hmm?
04:33:29 <Peaker> "ghc-prof-options:    -Wall -O2 -prof -auto-all -rtsopts" <-- in the .cabal file
04:39:43 * hackagebot lifted-base 0.2.0.3 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.2.0.3 (BasVanDijk)
04:40:54 <Kaidelong> Eduard_Munteanu: Is that an implementation of F#'s async monad or is it something I'll need to relearn?
04:42:12 <Kaidelong> oh, I see, it isn't
04:42:37 <Kaidelong> I guess what'd I'd be looking for would still be Orc then
04:43:17 <Eduard_Munteanu> Dunno about F#'s stuff.
04:45:29 <Kaidelong> F# has an async monad that lets you use do notation to go "a <- b; c <- d" and the two bindings are done asynchronously
04:46:05 <Eduard_Munteanu> Interesting.
04:46:05 <Kaidelong> the main issue I saw going to haskell is that you'd need some kind of ugly interaction with the IO monad which is not an issue in F# as it is impure
04:46:39 <Kaidelong> the approach Orc took was to make itself an instance of MonadIO
04:46:41 <Eduard_Munteanu> I suspect you could just wrap IO.
04:46:49 <Eduard_Munteanu> Yeah.
04:46:54 <Saizan> "a <- async b; c <- async d" is pretty close
04:48:34 <Kaidelong> hmm, speaking of F#
04:48:56 <Kaidelong> is there a haskell extension that gives haskell a similar enhanced do notation? MonadComprehensions?
04:49:13 <Kaidelong> for stuff like yield, yield! mostly
04:49:53 <quchen> I'm not sure what yield does, but if it's any similar to Python then you can probably make something using Cont
04:50:55 <quchen> "getCC = callCC $ \exit -> let x = exit x in x" effectively creates a goto mark iirc
04:51:09 <quchen> And from there on you can go crazy (and equally unreadable)
04:52:36 <Kaidelong> probably more analogous to mplus
04:52:59 <Kaidelong> yield is like mplus . return and yield! is like mplus
04:53:14 <quchen> So it has nothing to do with Python's yield? Oh
04:53:29 <Kaidelong> I don't know how python's yield works
04:53:48 <Kaidelong> but the general use is for writing iterators, infinite streams and the like
04:53:49 <quchen> It's like a return statement, but when you call the function again you jump back to where the yield was
04:54:00 <Kaidelong> oh icon's "suspend"?
04:54:12 <Kaidelong> I suppose implementation wise it basically boils down to that
04:54:25 <Kaidelong> not really how I think of it conceptually
04:56:38 <circle> does "a" have special meaning in haskell?
04:56:44 <circle> when you're defining general functions
04:57:16 <Kaidelong> no
04:57:55 <Kaidelong> at least, I can't think of a way to interpret the question where the answer would be yes
04:58:18 <Kaidelong> the closest I can get to is that it's a string literal in a pattern match
04:58:50 <quchen> circle: In types, "a" is something like "anything"
04:58:59 <quchen> id :: a -> a -- id maps anything to something of the same type
04:59:05 <circle> I know what it means
04:59:08 <circle> so it does have special meaning
04:59:14 <circle> you can't just replace it with "e"
04:59:16 <circle> or something
04:59:17 <quchen> You can
04:59:18 <Kaidelong> yes you can
04:59:28 <circle> so it doesn'
04:59:29 <circle> t
04:59:29 <Kaidelong> id :: forall a. a -> a
04:59:33 <quchen> :t id :: u -> u
04:59:35 <lambdabot> u -> u
04:59:42 <Kaidelong> think of forall like a lambda for types
04:59:45 <quchen> :t id :: rabbit -> rabbit
04:59:47 <lambdabot> rabbit -> rabbit
05:00:14 <Kaidelong> lower case types are universally instantiated implicitly
05:00:16 <quchen> Using "a" is a convention like using "x" for variables
05:00:36 <Kaidelong> universal instantiation being what the forall does
05:02:32 <Saizan> itym universally quantified
05:03:14 <Saizan> instantiation is the term for when you use it at some type, afaict
06:00:03 <Radish> Can someone help me really quick?
06:00:17 <Radish> I'm using command prompt and I'm trying to install portaudio still
06:00:36 <Radish> I think I've resolved the dependencies but it doesn't seem like command prompt knows where I hid them.
06:00:40 <Radish> This problem can usually be solved by installing the system package that provides this library (you may need the "-dev" version). If the library is already installed but in a non-standard location then you can use the flags --extra-include-dirs= and --extra-lib-dirs= to specify where it is.
06:01:12 <Radish> do I just type cabal install portaudio --extra-include-dirs=C:\blah\blah or what?
06:01:22 <hpaste> ctc pasted “Strange” at http://hpaste.org/84813
06:02:22 <ctc> what is going on here: http://hpaste.org/84813
06:02:40 <Botje> ctc: haskell just expanded ("" `return`) to \x -> return "" x
06:03:22 <supki> and ((->) t) is a Monad
06:04:58 <Radish> does a directory need to be in quotes?
06:05:20 <Botje> if the path contains spaces.
06:05:26 <Radish> oh
06:05:44 <Radish> is this right? cabal install portaudio --extra-include-dirs=C:\blah\blah
06:06:30 <Radish> wait shoot.  I don't think I configured where I installed portaudio...
06:06:50 <Radish> Where is it then?  "It's not in any of the standard directories".
06:07:05 <Radish> this is why I hate programming.
06:07:12 * Radish is too stupid
06:07:27 <Botje> no, you're not precise enough :)
06:08:26 <Philonous> Does Windows not have pkg-config?
06:09:05 <Radish> I already installed portaudio
06:09:08 <ion> ctc: For shits and giggles, try with :set -XPostfixOperators, too.
06:09:16 <Radish> I am out of installation instructions!
06:09:33 <Radish> I'm supposed to run cabal install portaudio but alas after all my installing nothing changed
06:09:44 <Radish> I just want to do synthesis this is ridiculous. :( :(
06:11:06 <fumieval> I built with cabal unpack
06:11:34 <dmwit> Radish: Yes, --extra-include-dirs=C:\blah\blah looks right. What happens when you use that?
06:11:47 <Radish> same thing
06:11:51 <Radish> i need to locate the dll file
06:11:57 <dmwit> And with --extra-lib-dirs?
06:12:10 <Radish> i didn't use any fancy instructions with MSys
06:12:20 <Radish> just ./configure
06:12:21 <Radish> make
06:12:23 <Radish> make install
06:12:34 <Radish> where would it put the .dll?
06:12:46 <dmwit> ask configure =)
06:13:08 <Radish> i kind of already backed out of there
06:13:14 <Radish> i can get it back right?
06:13:43 <dmwit> I don't know. What does "backed out of there" mean?
06:14:30 <Philonous> Uh, what would I call a module that handles textual representation of IP addresses?
06:14:54 <dmwit> You're telling me that there isn't already a module for that?
06:15:09 <Philonous> dmwit:  I tried to find it, but I couldn't.
06:15:33 <Radish> so how would I ask configure?
06:15:49 <dmwit> Perhaps ./configure --help will tell you the defaults for its various options.
06:16:13 <Radish> i think it saved everything to "configure.status"
06:16:45 <dmwit> Even if ./configure --help won't say, make install --dry-run certainly will.
06:17:07 <Radish> it says the dot . is not recognized
06:18:00 <Radish> hmm wait no i think i've got it now
06:18:20 <Radish> got two command prompts open lol one had me fooled ;)
06:18:33 <merijn> Anyone know if the unix package works under windows if you use cygwin?
06:18:47 <Radish> it says "Port Audio was successfully installed"
06:19:18 <dEPY> off-topic:  anyone here uses heroku?
06:19:33 <fumieval> Radish: Did you check lib\.libs?
06:19:43 <Radish> I'm doing --dry-run
06:19:44 * hackagebot soap 0.1.0.4 - SOAP client tools  http://hackage.haskell.org/package/soap-0.1.0.4 (AlexanderBondarenko)
06:19:54 <Radish> where does it say where its installed?
06:20:14 <Radish> entering/leaving directory?
06:20:48 <Radish> its the same directory as the one I'm in, which I'm thinking might be where it's installed but I tried to feed that line to cabal install and besides I don't see the .dll...
06:21:06 <dmwit> No, that's just an indication of which directories it's looking for Makefiles in.
06:21:14 <Radish> okay
06:21:15 <fumieval> Um, The directory that you ran 'make'.
06:22:02 <Radish> maybe its this usr/local/lib/pkgconfig?
06:22:23 <Radish> could that be where it was installed to by default?
06:22:59 <Radish> this is tragic lol
06:23:33 <Radish> fumieval: how do i check lib\.libs?
06:24:12 <Radish> omg i think this is it
06:24:18 <Radish> fumieval: i think I got you, thank you
06:25:12 <alpounet> dEPY, i have seen a few blog posts about haskell & heroku, but don't remember discussions about that here while I was around. the blog posts may be all you need though
06:26:08 <Radish> oh for crying out loud new error
06:26:12 <Radish> it's missing the .h file
06:26:26 <Radish> thats the "header" file, right?
06:26:52 <Botje> this is where the --extra-include-dirs comes into play.
06:28:09 <Radish> okay so i need to point that one at wherever I put that .h file.
06:28:10 <Radish> okay
06:28:20 <Radish> this is confusing but kind of exciting
06:29:04 <Radish> i'm super inexperienced with command prompt, haskell, port audio, linux/unix, .h, .dll, .tar, .tgz, and just about everyone other aspect of this project.
06:29:30 * merijn has to hold off from making a sex joke
06:29:34 <Botje> yay! learning!
06:30:39 <Radish> oh yeah baby, defrag my kernel! -- if you know what i mean
06:30:58 <Radish> and he never got laid again
06:31:13 <Radish> where would the .h be agian??
06:31:24 <Radish> i'm rumaging around.  i found some .hxx lol
06:32:02 <Radish> aha!
06:33:47 <teneen> Is GHC RULES pragma a compile-time optimization?
06:33:54 <teneen> How is it different from #define?
06:34:10 <dmwit> It is compile-time.
06:34:25 <Radish> omg finally
06:34:32 <Radish> i've been working on this for weeks
06:34:35 <dmwit> I'm not sure exactly how to compare it to #define other than to say that it's hygienic.
06:34:41 <dEPY> How many of you guys use haskell at your job?:)
06:35:00 <Radish> I would kill to be a haskell programmer full time
06:35:07 <dmwit> ?wiki haskell in industry
06:35:08 <lambdabot> http://www.haskell.org/haskellwiki/haskell_in_industry
06:35:09 <Radish> that would be like totally suave
06:35:14 <teneen> dmwit: So #define can always replace RULES?
06:35:45 <dmwit> teneen: Ah, no, there's another difference: RULES can fire on optimized code.
06:35:48 <dmwit> #define happens once.
06:35:57 <hiptobecubic> i think there is a big divide between "paid to use haskell" and "paid in spite of the use of  haskell"
06:36:13 <Dodek> hey, is there a library that supports secure client-side websockets?
06:36:31 <dmwit> If you've looked on Hackage and didn't see one, there probably isn't.
06:36:37 <dmwit> If you didn't look on Hackage, do so now. =)
06:37:09 <Dodek> the "websockets" library only supports plain sockets, not secure ones
06:37:35 <merijn> Any haskell under cygwin users around?
06:38:03 <merijn> Radish: Make sure to have a profile on haskellers.com, I've gotten two recruitment messages for haskell jobs so far :)
06:38:10 <Radish> hiptobecubic: +1 dude
06:38:28 <Heffalump> merijn: I do sometimse
06:38:44 <Adeon> Dodek: can't you just tunnel the websocket in SSL connection?
06:38:44 <Taneb> How early is too early to make a profile on haskellers.com
06:38:53 <Radish> merijn: I can't program my way out of a paper bag at this point, but I'm trying to learn!
06:38:57 <Dodek> Adeon: tht's not what i am talking about
06:39:02 <Dodek> Adeon: http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-10#page-20
06:39:16 <Adeon> I see
06:39:32 <merijn> Taneb: Well, I have zero (useful) libraries on hackage and barely any OS haskell code to show, so there's no such thing as too early, I think :p
06:39:56 <Taneb> merijn, I'm still in high school, not doing any computer-y education
06:40:04 <Radish> merijn: i bookmarked the site though thanks
06:40:52 <Heffalump> Taneb: that's got nothing to do with being a haskeller or not!
06:40:59 <Taneb> Good point, Heffalump
06:41:00 <merijn> Taneb: My personal opinion is that most people in the industry are more terrible than you think (especially if you hang out here, this place is filled with outliers :p), so I don't think it hurts to start early
06:43:14 <merijn> Taneb: My biggest mistakes in high school/university was thinking I knew how much I was worth (i.e. not much), once I started working a bit I realised people were willing to pay craptons of money for me to do things I thought were trivial. My biggest life advice to someone in high school and coding would be to never underestimate how much value your skills have to people, else you'll screw yourself out of money and/or jobs
06:44:11 <merijn> In fact, if you ever get asked what kind of salary you're looking for. Think of the highest salary you realistically expect someone to pay you, then triple it (or maybe even quadruple or more)
06:44:37 <dmwit> $300,000/year!
06:44:46 * hackagebot hspec-expectations 0.3.1 - Catchy combinators for HUnit  http://hackage.haskell.org/package/hspec-expectations-0.3.1 (SimonHengel)
06:45:03 <Taneb> merijn, thank you for that advice
06:45:14 <sipa> +1 merijn
06:46:27 <merijn> Taneb: One example, I have a friend who started looking for jobs recently, to figure out how much he was worth (granted, he is rather experience already), they asked him to name a salary. He figured 75k would be too much, they immediately said "yes", turns out they probably would've gone up to 120k
06:46:47 <Taneb> Whoa
06:47:36 <Hafydd> merijn: one of the commas in your first sentence should be a full stop. Which one is it?
06:48:19 <merijn> Hafydd: I refuse to bow to your childish notions of correct punctuation! :p
06:48:37 <Hafydd> merijn: I'm asking because I actually didn't understand your sentence.
06:49:01 <geekosaur> Hafydd, I'd replace first comma with colon and second with semicolon
06:49:21 <merijn> I think the first comma should be a colon and the third a full stop?
06:49:57 <geekosaur> the third is after "granted", why would it be a full stop?
06:50:20 <merijn> geekosaur: I don't consider parenthesis part of the first sentence
06:50:25 <geekosaur> (also "experience" in that parenthetical probably should be "experienced")
06:50:34 <Hafydd> So the employer asked because they wanted to find out how much he was worth? I see.
06:50:47 <geekosaur> the comma after the parenthetical should not be a full stop, it might be removed though
06:50:55 <merijn> Hafydd: No, my friend was trying to figure out how much he could get for new jobs
06:51:24 <Hafydd> Oh.
06:51:32 <merijn> geekosaur: Spellchecking my IRC typing would be a fulltime job for someone...the number of typos is just awful
06:51:51 <Hafydd> I'll do it for 75k pa/.
06:52:24 <Botje> .. what currency?
06:52:31 <Hafydd> Bitcoins.
06:52:54 <Botje> that's a fun proposition.
06:53:01 <Hafydd> I'll also accept lambdabot karma points.
06:53:18 <Botje> one month you can buy a new house, the next you can barely afford a sandwich.
06:54:46 * hackagebot hspec-expectations 0.3.2 - Catchy combinators for HUnit  http://hackage.haskell.org/package/hspec-expectations-0.3.2 (SimonHengel)
06:55:10 <Hafydd> Because you spent all the money on the house? That sounds accruate.
06:55:38 <Taneb> Don't houses cost about as much as a red paperclip and some web hosting now?
06:55:38 * Hafydd pre-emptively shuts up.
06:56:06 <dmwit> What kind of unit is k pa/.?
06:56:24 <Taneb> Thousands of currency per year
06:56:29 <Hafydd> 75 k year^-1
06:57:26 <merijn> dmwit: I'm guessing pa = per annum?
06:57:29 <dmwit> I much rather prefer my interpretation of "kiloPascals per corrected period".
06:57:40 <Hafydd> Hahah.
06:57:45 <dmwit> "I will crush you with a thousand atmospheres for EACH ERROR!"
06:59:14 <dmwit> There's a lot of things I'd do for 75k BTC/year.
06:59:42 <Taneb> What's the BTC/GBP conversion rate atm
06:59:58 <dmwit> dunno about GBP, but I sold 10 BTC for $93/BTC yesterday
06:59:59 <dmwit> USD
07:00:41 <hiptobecubic> dmwit, yes, they are spiking like mad
07:01:20 <Taneb> And I've just spent 10 minutes trying to get the coordinates on my Haskellers profile correct to four decimal places
07:01:33 <dmwit> Even at the lowest exchange rate I've seen since I learned about them (namely $3/BTC) there's a lot of things I'd do for 75k BTC/year.
07:01:41 <hiptobecubic> yes
07:01:51 <Taneb> Darn, I'm two houses too far west
07:02:04 <Taneb> And a few meters too far south
07:02:10 <hiptobecubic> honestly btc are a pretty outrageous story
07:02:19 <dmwit> Taneb: Won't Google maps tell you your coordinates to as many decimal places as you like...?
07:02:27 <Hafydd> Taneb: please make it accurate so I can pay uninvited visits to your house.
07:02:46 <Taneb> dmwit, could never work it out
07:02:50 <Taneb> Hafydd, please don't
07:03:01 <Hafydd> That's the spirit.
07:03:34 <sipa> Spirits aren't welcome at his hiuse either, i suppose :)
07:03:55 <Hafydd> So bringing a bottle of Whiskey won't help?
07:04:04 <dmwit> Taneb: Right click -> center map here; then click the "permalink" button in the top left.
07:04:16 <dmwit> It has your latitude and longitude in the URL.
07:04:21 <Taneb> And now I've got it PERFECT
07:04:27 <Taneb> I'm gonna round to two decimal places
07:04:31 <Taneb> So nobody can find me!
07:04:33 <merijn> Hafydd: He said he was in high school, I don't think his parents would appreciate uninvited strangers bringing whisky ;)
07:04:50 <merijn> OTOH, feel free to come and bring me whisky!
07:04:55 <Hafydd> Heheh.
07:05:01 <Taneb> I don't think my mum would mind
07:05:06 <Taneb> But I'm not too keen on whisky
07:05:14 <sipa> Taneb: but she is?
07:05:25 <merijn> Single malt/cask only, please. I am a gentleman of taste...
07:05:30 <Taneb> Indeed
07:05:57 <merijn> Blended is for the uninformed and uncultured masses :>
07:06:30 <notdan> Is there a way to sort of make one module "friend" of another, so it can access private (non-exported) functions and variables?
07:06:41 <Taneb> I need a more professional gravatar image...
07:06:49 * Eelis sends merijn a nice bottle of blended whisky
07:06:50 <notdan> I haven't found anything regarding that in the docs, but maybe there is a pattern or whatnot
07:07:05 <Taneb> No
07:07:12 <Taneb> There is not
07:07:18 <merijn> notdan: Why not just have an internal module that exports everything but is not exported by your package?
07:07:35 <merijn> notdan: That way your own stuff can use it, but the rest of the world can't
07:08:04 <sipa> merijn: xkcd.com/915 ?
07:08:29 <notdan> merijn: hm, sounds like a nice idea
07:08:31 <notdan> thanks
07:08:50 <merijn> notdan: And if the outside world needs some internal stuff you can just reexport it from a "public" module
07:09:45 <Taneb> Okay, I have a public Haskellers.com profile
07:09:49 <Taneb> Time to play pokemon
07:09:54 <dario> hrhr
07:19:46 * hackagebot l-bfgs-b 0.1 - Bindings to L-BFGS-B, Fortran code for limited-memory quasi-Newton bound-constrained optimization  http://hackage.haskell.org/package/l-bfgs-b-0.1 (GardSpreemann)
07:37:25 <dockside1> Let's talk about the module namespace. I see there are a lot of packages providing Data.Vector, however they are very diffrent in both abstraction and functionallity. I also see high level algorithms using some of them resulting in a packages with a very abstract names that has very specific usecases. Is this accepted as a problem?
07:38:46 <aCube> What is the best way to map over a list with a function that needs the current element and the rest of the list?
07:39:03 <aCube> It sounds a lot like a zipper, but I wasn't sure how to use one here
07:39:38 <supki> @ty \f -> map f . tails
07:39:39 <lambdabot> ([a] -> b) -> [a] -> [b]
07:40:44 <k00mi> dockside1: what packages provide Data.Vector? I can only find the vector package and all the algorithms packages use that
07:40:55 <aCube> @ty \f l -> map (\x -> f x (delete x l)) l
07:40:57 <lambdabot> Eq a => (a -> [a] -> b) -> [a] -> [b]
07:41:11 <aCube> That's one implementation, but maybe there is a better way?
07:43:15 <Kyo> could haskell be used for soft realtime?
07:44:34 <k00mi> Kyo: that question has been asked a few times on stack overflow
07:44:47 * hackagebot names 0.1 - Types that symbolise Names.  http://hackage.haskell.org/package/names-0.1 (JulianFleischer)
07:44:53 <latermuse> kyo: what do you mean by soft realtime?
07:44:59 <dates> hi, Is it possible to do this in a haskell function : "if true then do this and this". I mean can I do two things if a logical expression is true in the function?
07:45:09 <latermuse> dates: yes
07:45:23 <aCube> > if True then 3 else 0
07:45:24 <lambdabot>   3
07:45:27 <latermuse> dates if True then ... else ...
07:45:32 <ramses_> @ty join . (map .) -- aCube
07:45:33 <lambdabot> ([a] -> a -> b) -> [a] -> [b]
07:45:56 <latermuse> > putStrLn $ if True then "yes" else "no"
07:45:57 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
07:45:57 <lambdabot>    arising from a use of ...
07:46:05 <dates> latermuse : no, I mean if the condition is true, do two things, call different funcitons etc..
07:46:12 <latermuse> dates: yes
07:46:29 <ramses_> aCube: ^^
07:46:37 <latermuse> if True then someFunction >> someOtherFunction else aThirdFunction
07:47:17 <dates> latermuse: using ">>" operation?
07:47:19 <aCube> ramses_: Sorry, i want the list sans the current element
07:47:25 <latermuse> dates: yes
07:47:29 <aCube> Another implementation:
07:47:30 <aCube> @ty \f l -> snd $ mapAccumL (\(l,r) e -> ((l ++ [e], tail r), f e (l ++ tail r))) ([], l) l
07:47:32 <lambdabot> (t -> [t] -> y) -> [t] -> [y]
07:47:33 <ramses_> aCube: ah, right..
07:47:42 <azaq23> dates: everything is an expression in haskell, hence you cannot do a standalone "if" (except when you're in a monad and use guard, but that's a different topic); you must always specify the if and
07:47:42 <azaq23> the else block which need to return a value of the same type
07:47:47 <dates> latermuse : thank you
07:48:05 <latermuse> dates: play around with (>>) a bit
07:48:22 <dockside1> k00mi: Correct, i got confused from weird imports
07:48:24 <latermuse> dates: if you need to pass a parament from the first function to the second function, then use (>>=) instead of (>>)
07:48:29 <latermuse> parameter
07:48:50 <centrinia> @wn parament
07:48:50 <lambdabot> No match for "parament".
07:49:19 <ramses_> aCube: the one with delete will always remove the first element which is equal to the current element, not necessarily the current, right?
07:49:27 <azaq23> yeah let's tell him to use some monad operations on the (r ->) monad instead of clearly addressing the underlying issue which lets us infer that he wants to do imperative programming in haskell
07:49:48 <latermuse> > if True then (putStrLn "hi" >> putStrLn "meow") else putStrLn "moo"
07:49:49 <azaq23> someone who has to ask for if clearly has experience in the use of monads and can do so responsible
07:49:49 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
07:49:50 <lambdabot>    arising from a use of ...
07:49:57 <latermuse> bah
07:50:12 <latermuse> azaq23: nothing wrong with imperative programming in haskell
07:51:14 <aCube> ramses_: yes, but I forgot to say that no element appears twice in the list
07:52:11 <ramses_> aCube: you could also write an efficient select function, like the standard prolog predicate, and use that. May be more efficient
07:52:24 <latermuse> dates: you probably want to read some "monad tutorials" if you really want to understand the question that you are asking
07:52:43 <ramses_> latermuse: bah, monad tutorials
07:52:58 <latermuse> ramses_: they suck, but a beginner has to start somewhere
07:53:29 <Kyo> what is the recommended interface to use to build a protocol for a server using haskell? im going to build a linux server that serves a webapp and ranks soccer streams. use a simple socket interface or is there something more high level?
07:53:48 <ramses_> latermuse: one should start with a good general tutorial which builds up all necessary abstractions to make monads as easy as they are
07:53:53 <latermuse> kyo: there are quite a few mature haskell servers
07:53:53 <dates> latermuse : I'm checking them on hoogle right now
07:54:06 <latermuse> kyo: might be more fun to use sockets though
07:55:01 <Kyo> latermuse: soft realtime = it needs to get there almost always to function properly but if it misses something every now or then or gets a bit light every now and then noone dies. hard realtime = this task needs to finish within 1ms or the patient dies.
07:58:24 <S11001001> @djinn (a -> ()) -> [a] -> ()
07:58:25 <lambdabot> Error: Undefined type []
07:58:53 <Taneb> :t fold
07:58:54 <lambdabot> (Foldable t, Monoid m) => t m -> m
07:58:56 <Taneb> :t foldMap
07:58:57 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
07:59:13 <Taneb> :t foldMap (a -> ()) -> [a] -> ()
07:59:15 <lambdabot> parse error on input `->'
07:59:22 <Taneb> :t foldMap : (a -> ()) -> [a] -> ()
07:59:23 <lambdabot> parse error on input `->'
07:59:24 <Taneb> Bah
07:59:30 <S11001001> Taneb: I wanted to see what djinn would do specifically
07:59:38 <aCube> :D
08:00:12 <Taneb> probably \_ _ -> ()
08:00:20 <S11001001> maybe
08:00:36 <S11001001> @djinn (a -> ()) -> (a, a) -> ()
08:00:36 <lambdabot> f a (b, _) = a b
08:00:53 <S11001001> maybe not
08:02:03 <elliott> djinn can't do lists
08:02:09 <elliott> so it wouldn't :P
08:03:24 <S11001001> @djinn (a -> ()) -> (b -> ()) -> (a, b) -> ()
08:03:24 <lambdabot> f a _ (b, _) = a b
08:04:09 <ParahSailin> whats djinn?
08:04:14 <supki> @djinn (a -> ()) -> (b -> ()) -> (a, b) -> ((), ())
08:04:15 <lambdabot> f _ _ _ = ((), ())
08:04:54 <S11001001> @ty (***)
08:04:55 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
08:05:32 <notdan> Ugh, there is no insertWith or unionWith in Data.Set :(
08:05:40 <notdan> I thought it had interface similar to Map
08:10:20 <elliott> notdan: what would it mean to have those in Set?
08:10:28 <elliott> Set k is like Map k ()
08:12:25 <k00mi> elliott: on values where Ord is defined by e.g. an ID it would make sense
08:13:55 <k00mi> i.e. where EQ does not mean the values are actually equal
08:15:21 <elliott> k00mi: if you are distinguishing values that are EQ for non-optimisation/internal implementation reasons, your instance is broken
08:15:25 <linduxed> instead of filtering two times, is there a way to add two conditions as the filter function?
08:15:44 <linduxed> so that i can do something like "filter (even && (<6))"?
08:15:58 <ocharles> linduxed: filter (\x -> even x && x < 6)
08:16:04 <linduxed> aaah yes
08:16:08 <linduxed> ofc
08:16:10 <linduxed> hahah
08:16:14 <ocharles> there are ways to do it point free, too
08:16:23 <linduxed> mind blanked there, ocharles
08:16:31 <linduxed> ocharles: hmmm, you think so?
08:16:44 <linduxed> or well, i expect that there is, but i can't think of the way
08:18:07 <ocharles> > filter ((&&) <$> even <*> (<6)) [1..10]
08:18:09 <lambdabot>   [2,4]
08:18:22 <linduxed> whoa
08:18:24 <k00mi> elliott: that is correct, although such an instance would make sense for Set (but I understand that is not what Ord is intended for)
08:18:30 <linduxed> i'd never figure that one out
08:18:50 <linduxed> i don't even know what the <$> and <*> are
08:18:56 <ocharles> linduxed: it uses the (int ->) reader applicative instance
08:18:59 <Philonous> linduxed:  The trick to understanding that is understanding the Applicative instance for (-> r)
08:19:02 <dmwit> aCube: There is, indeed, a better way.
08:19:13 <ocharles> but really, I think \x -> ... is clearer
08:19:14 <elliott> k00mi: you could use Map TheID TheOtherStuff
08:19:15 <dmwit> aCube: Step one is to write a function that takes a list and returns all the zippers.
08:19:20 <ion> linduxed: liftA2, http://heh.fi/haskell/functors/#function-instance
08:19:27 <linduxed> Philonous: yeah, i'm not that fluent with it yet :-S
08:19:34 <elliott> ocharles: liftA (&&) even (<6) is perhaps nicer (though the explicit lambda is obviously the way to go here)
08:19:40 <ion> linduxed: Also, what ocharles said.
08:20:12 <ocharles> I wonder if you can do it with distribute and getAll or something too
08:20:37 <k00mi> elliott: right
08:22:50 <ramses_> @ty filter . fmap and . Data.Traversable.sequenceA
08:22:51 <lambdabot> [a -> Bool] -> [a] -> [a]
08:23:05 <ramses_> linduxed: ^^ works for a list of boolean functions
08:23:07 <dmwit> > zip <$> inits <*> tails $ [1..5]
08:23:08 <lambdabot>   [([],[1,2,3,4,5]),([1],[2,3,4,5]),([1,2],[3,4,5]),([1,2,3],[4,5]),([1,2,3,4...
08:23:41 <ocharles> > filter (all . distribute [ even, (<6) ]) [1..10]
08:23:43 <lambdabot>   Not in scope: `distribute'
08:23:43 <lambdabot>  Perhaps you meant `distrib' (imported from Cont...
08:23:45 <ocharles> lame.
08:23:50 <linduxed> omg, this is too heavy for me atm
08:23:57 <aCube> > zip <*> inits <$> tails $ [1,2,3]
08:23:57 <linduxed> i'll dig into that stuff quite soon
08:23:58 <lambdabot>   [([1,2,3],[]),([2,3],[[1,2,3]]),([3],[[1,2,3],[2,3]]),([],[[1,2,3],[2,3],[3...
08:24:04 <linduxed> but right now it's too heavy
08:24:15 <ocharles> linduxed: don't worry about it
08:24:16 <ocharles> linduxed: haskell lets you go as far as you want
08:24:27 <ocharles> linduxed: as cool as other solutions are, the explicit lambda is easily the clearest
08:24:31 <dmwit> aCube: It depends a bit on exactly what you want to do with "the rest of the list", of course.
08:24:34 <ocharles> and clarity wins over cleverness
08:24:54 <dmwit> aCube: I prefer the function that's efficient but semantically equivalent to
08:24:58 <ramses_> maybe I shouldn't have taken the pointfree version, but I copy pasted it from some code I wrote a while ago
08:25:01 <linduxed> ocharles: we'll i'm currently only a couple of paragraphs into this chapter http://learnyouahaskell.com/functors-applicative-functors-and-monoids#functors-redux
08:25:14 <linduxed> ocharles: so i should get there quite soon
08:25:17 <dmwit> aCube: ...that function, but reverses the first list in each tuple.
08:25:21 <ocharles> linduxed: ok, you have a bit of time to go :)
08:25:34 <aCube> dmwit: yes, that's easier :D
08:25:38 <ocharles> linduxed: just take your time and get comfortable with each step - this will come naturally, in the end
08:25:42 <ocharles> (i started with that book too)
08:26:06 <ramses_> linduxed: that chapter is where the fun begins! :)
08:26:14 <ocharles> indeed, applicatives are da bomb
08:26:42 <dmwit> > let zippers = go []; zippers xs ys = (xs, ys) : case ys of [] -> []; y:yt -> go (y:xs) yt in zippers [1..3]
08:26:43 <lambdabot>   Conflicting definitions for `zippers'
08:26:43 <lambdabot>  Bound at: <interactive>:1:5-11
08:26:43 <lambdabot>      ...
08:26:57 <dmwit> > let zippers = go []; go xs ys = (xs, ys) : case ys of [] -> []; y:yt -> go (y:xs) yt in zippers [1..3]
08:26:58 <lambdabot>   [([],[1,2,3]),([1],[2,3]),([2,1],[3]),([3,2,1],[])]
08:27:31 <aCube> @ty \f l -> snd $ mapAccumL (\(l,r) e -> ((e:l, tail r), f e (l ++ tail r))) ([], l) l
08:27:32 <lambdabot> (a -> [a] -> y) -> [a] -> [y]
08:27:32 <dmwit> aCube: I would start with this function.
08:27:35 <aCube> dmwit: ^
08:27:45 <linduxed> robbe-: oh yeah it sure feels like it
08:27:56 <linduxed> ramses_: shit got real in a real hurry
08:27:59 <dmwit> :t mapAccumL
08:28:01 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
08:28:39 <ramses_> linduxed: I'm not sure what you mean by that..
08:28:58 <dmwit> aCube: Yes, that's similar.
08:29:13 <linduxed> ramses_: everything up to that point took some time to memorize, but not really to digest
08:29:18 <aCube> But I quite like the version with inits and tails :)
08:29:22 <dmwit> aCube: Except that whatever function you hand to that isn't allowed to observe *where* in the list the element it's currently looking at was extracted from.
08:29:26 <linduxed> ramses_: there was a lot of it, but it wasn't all that hard
08:29:34 <linduxed> ramses_: this chapeter however... holy shit
08:29:52 <linduxed> ramses_: i can only imagine what will happen in the coming chapters
08:29:53 <ramses_> linduxed: indeed, from that chapter on, the really nice (but harder to grasp initially) abstractions are discussed
08:30:40 <dmwit> aCube: Also, I guess you're probably getting some bits of the list in reverse order there, no?
08:31:01 <ramses_> linduxed: I found applicatives the hardest to get an intuition for, but once you got those, monads will seem easy
08:31:16 <dmwit> > snd $ mapAccumL (\(l,r) e -> ((e:l, tail r), l ++ tail r)) ([], [1..5]) [1..5]
08:31:18 <lambdabot>   [[2,3,4,5],[1,3,4,5],[2,1,4,5],[3,2,1,5],[4,3,2,1]]
08:31:27 <dmwit> Right, see the end. =)
08:32:24 <aCube> > let f = \f l -> snd $ mapAccumL (\(l,r) e -> ((e:l, tail r), f e (l ++ tail r))) ([], l) l in f (,) [1..5]
08:32:26 <lambdabot>   [(1,[2,3,4,5]),(2,[1,3,4,5]),(3,[2,1,4,5]),(4,[3,2,1,5]),(5,[4,3,2,1])]
08:32:46 <aCube> yes, that is the reversed version
08:32:54 <dmwit> In the middle, you get lists where part of the list is forward, part is backward, and there's no indication where the separation is.
08:32:58 <dmwit> That seems bad to me.
08:33:22 <aCube> > let f = \f l -> snd $ mapAccumL (\(l,r) e -> ((l ++ [e], tail r), f e (l ++ tail r))) ([], l) l in f (,) [1..5]
08:33:24 <lambdabot>   [(1,[2,3,4,5]),(2,[1,3,4,5]),(3,[1,2,4,5]),(4,[1,2,3,5]),(5,[1,2,3,4])]
08:34:03 <dmwit> Again, the right way to write this function depends a bit on what your plan for consuming the data is.
08:35:14 <aCube> > let f = \f l -> map (\(a,b) -> f (head b) (a ++ tail b)) $ init $ zip (inits l) (tails l) in f (,) [1..5]
08:35:16 <lambdabot>   [(1,[2,3,4,5]),(2,[1,3,4,5]),(3,[1,2,4,5]),(4,[1,2,3,5]),(5,[1,2,3,4])]
08:35:30 <aCube> I like that way tp write it :D
08:36:50 <Sculptor> hi
08:41:00 <dmwit> aCube: Why not \f l -> [f b (a ++ e) | (a, b:e) <- zip (inits l) (tails l)]
08:41:53 <aCube> dmwit: oh, that's even nicer :) Thanks
08:45:53 <ramses_>  @ty let select [] = []; select (x:xs) = (x,xs) : map (\(y,ys) -> (y,x:ys)) (select xs) in \f
08:46:32 <ramses_> err
08:46:36 <ramses_> @ty let select [] = []; select (x:xs) = (x,xs) : map (\(y,ys) -> (y,x:ys)) (select xs) in \f -> map (uncurry f) . select
08:46:38 <lambdabot> (a -> [a] -> b) -> [a] -> [b]
08:47:14 <`cc`> if you have a Map of string , [int] , is it easy to insert a new (string, int) by appending it existing key or inserting a singleton else
08:47:36 <`cc`> (like the append of erlang)
08:47:41 <ramses_> `cc`: insertWith
08:48:38 <ramses_> @ty Data.Map.insertWith (++)
08:48:39 <lambdabot> (Ord k, Monoid a) => k -> a -> M.Map k a -> M.Map k a
08:49:12 <`cc`> > Map.insertWith  5 'e' fromList [(5,'a'), (3,'b')]
08:49:14 <lambdabot>   Not in scope: `Map.insertWith'
08:49:14 <lambdabot>  Perhaps you meant one of these:
08:49:14 <lambdabot>    `M.inser...
08:49:44 <`cc`> > Data.Map.insertWith  5 'e' Data.Map.fromList [(5,'a'), (3,'b')]
08:49:46 <lambdabot>   mueval-core: L.hs: removeLink: does not exist (No such file or directory)
08:50:01 <monochrom> try again, race condition
08:50:02 <`cc`> > Data.Map.insertWith  5 'e' (Data.Map.fromList [(5,'a'), (3,'b')])
08:50:04 <lambdabot>   Not in scope: `Data.Map.insertWith'Not in scope: `Data.Map.fromList'
08:51:00 <monochrom> perhaps they call it M.insertWith and M.fromList
08:51:20 <`cc`> > M.insertWith  5 'e' (M.fromList [(5,'a'), (3,'b')])
08:51:22 <lambdabot>   No instance for (GHC.Num.Num (Data.Map.Map k0 GHC.Types.Char))
08:51:23 <lambdabot>    arising f...
08:51:35 <byorgey> `cc`: note you'll have to use  "e", "a", "b"
08:51:38 <aCube> :t M.insertWith
08:51:39 <lambdabot> Ord k => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
08:51:39 <byorgey> 'e' is a Char
08:51:41 <monochrom> where is your (++)?
08:51:43 <`cc`> > M.insertWith  5 'e' (M.fromList [(5,"a"), (3,"b")])
08:51:45 <lambdabot>   No instance for (GHC.Num.Num (Data.Map.Map k0 [GHC.Types.Char]))
08:51:45 <lambdabot>    arising...
08:51:48 <ramses_> > M.insertWith  (++) 5 "e" $ M.fromList [(5,"a"), (3,"b")]
08:51:50 <lambdabot>   fromList [(3,"b"),(5,"ea")]
08:51:55 <`cc`> hehe
08:52:12 <bobry> is there a guide on working with primitive array operations? for example GHC.Prim.writeByteArray#
08:53:50 <`cc`> ramses_, thx
08:54:09 <ludamad>  \o/ first time rewriting a 'do' block using >>=
08:54:23 <ramses_> @ty (++)  --  Wtf, this is a synonym for (<>) now?
08:54:24 <lambdabot> Monoid m => m -> m -> m
08:54:36 <ramses_> `cc`: np :)
08:54:38 <nicoo> ludamad: First time doing bindage ?
08:54:41 <nicoo> So kinky.
08:55:14 <ludamad> nicoo: Uhh, maybe
08:55:28 <nicoo> ^_^
08:55:45 <nicoo> ludamad: Was just a silly pun on bondage :)
08:56:07 <ludamad> nicoo: Yes, but is >>= called binding or something ?
08:56:19 <monochrom> it is usually called bind
08:56:26 <ludamad> ok
08:56:51 <monochrom> http://ro-che.info/ccc/01.html
08:57:30 <ludamad> monochrom: Gah the PUUUNS
08:57:54 <ludamad> anyway, time to write it back to a do block for the sake of my friends eyes
08:58:24 <nicoo> monochrom: Sooo classim :)
08:59:58 <magicman> Does anyone here know who introduced the concept of base functors of recursive datatypes?
09:01:42 <Kaidelong> ludamad: because the operation is analogous to being able to refer to the result of a subcomputation in another computation
09:02:07 <magicman> Specifically, I'm looking for a way to systematically derive a base functor from a given datatype, and to actually prove the functoriality of datatypes created by this construction.
09:02:42 <Kaidelong> basically for some computing system m, a value of type m a, an a computed in by the system m, that value can be accessed in another computation as a value of type a
09:02:52 <Kyo> a
09:02:56 <Kaidelong> provided it is also a computation done by the system m
09:03:17 <monochrom> "data X = .... X ..." becomes "data XBase again = ... again ..."
09:03:49 <Kaidelong> the way you import those bindings in is that you make functions from (a -> m b) that insert the value into the context that wants to bind it
09:04:04 <Kaidelong> hence the type m a -> (a -> m b) -> m b
09:05:01 <Kaidelong> I'm pretty sure that's the logic behind the name bind anyway, it's analogous to the idea of a binding in a programming language
09:05:03 <magicman> monochrom: Right, so basically a dumb search-and-replace for the original datatype header?
09:05:09 <ludamad> Kaidelong: makes sense, thanks
09:05:14 <monochrom> yes
09:06:24 <Kaidelong> I think that analogy is also what separates monads from applicative functors
09:06:44 <Kaidelong> in an applicative functor you can't refer to the contents of other applicative functors by name
09:06:57 <Kaidelong> you can just lift pure functions of arbitrary numbers of arguments
09:07:39 <ludamad> Kaidelong: What's an example of an applicative functor ?
09:08:06 <Kaidelong> ludamad: I think ZipLists are one of the few examples of an applicative functor that is not always a monad, but all monads are also applicative functors
09:08:28 <Kaidelong> also a monad...
09:09:53 <Kaidelong> IE you could define readInt :: IO Int = read . getLine
09:09:55 <Kaidelong> err
09:10:01 <Kaidelong> read <$> getLine
09:10:03 <Kaidelong> I meant
09:10:08 <mauke> readLn
09:10:18 <Kaidelong> and then use that readInt applicatively
09:10:41 <ludamad> :t <$>
09:10:42 <lambdabot> parse error on input `<$>'
09:10:49 <ludamad> :t (<$>)
09:10:50 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:10:51 <mauke> :t (+) <$> readLn <*> readLn
09:10:53 <lambdabot> (Num b, Read b) => IO b
09:11:10 <Kaidelong> sumTwo :: IO () = ((+) <$> readInt <*> readInt) >>= print
09:11:31 <Kaidelong> which prints the sum of two integers read from the command line
09:11:38 <mauke> :t print =<< (+) <$> readLn <*> readLn
09:11:40 <lambdabot> IO ()
09:12:46 <ludamad> :t liftM
09:12:48 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
09:13:11 <Kaidelong> a way to see (+) <$> readInt <*> readInt being like
09:13:12 <ludamad> Is <$> a general version of liftM ?
09:13:41 <quchen> ludamad: <$> is infix for fmap
09:13:44 <quchen> And liftM = fmap
09:13:54 <Kaidelong> IO { $readInt + $readInt }, or something, to discard the haskell syntax to illustrate that you're using + in a different context, IO in this case
09:13:59 <ludamad> :t fmap
09:14:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:14:13 <joaopizani> ludamad: every Functor is also a Monad
09:14:21 <ludamad> Ah. And monad a functor ?
09:14:21 <joaopizani> :t liftM
09:14:23 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
09:14:24 <Kaidelong> and that's what applicative functors are about, using functions of aribtrary numbers of arguments in different contexts
09:14:25 <byorgey> joaopizani: other way around.
09:14:31 <joaopizani> byorgey: sorry
09:14:39 <joaopizani> byorgey: exactly, every Monad is a Functor
09:14:41 <ludamad> right, so it is more general.
09:14:44 <ludamad> as I was asking
09:15:00 <Kaidelong> yeah monads are all functors because if you can get that binding behavior
09:15:12 <Kaidelong> then you can implement a generic conversion to all pure functions in the form
09:15:58 <ludamad> thanks all
09:16:08 <Kaidelong> pureFunction5 f a' b' c' d' e' = do { a <- a'; b <- b'; c <- c'; ... return f a b c d e
09:16:13 <Kaidelong>  ; }
09:16:13 <ludamad> this category theory stuff is becoming a little less daunting
09:16:51 <Philonous> That's not really category theory.
09:16:56 <Kaidelong> I think this is still in the realm of algebra, category theory is where you start talking about how examples of these things relate to one another, like how a bitmap related to a pixel
09:16:59 <Kaidelong> relates even
09:17:18 <Kaidelong> like, what general relationship do bitmaps represent to their pixels
09:17:25 <Kaidelong> then you end up with terms like "monoid orphism"
09:17:29 <ludamad> sure. either way.
09:18:00 <Kaidelong> and you start seeing that same kind of relationship between two data structures everywhere
09:18:19 <Kaidelong> if a data structure is an algebra then category theory is algebras for algebras
09:18:20 <Kaidelong> I guess
09:19:00 <Kaidelong> more abstract and IMHO less useful than the algebra part
09:19:51 <Kaidelong> algebra helps you write correct programs, category theory helps you architect them, but architecture to me is usually the easy part because even for large programs the architecture is often simple
09:20:19 <Kaidelong> both help by allowing you to see complex problems as simpler ones
09:20:23 <Kaidelong> through analogy
09:20:27 <tac> If you're talking about actual real programs, things grow much more organically.
09:20:41 <Kaidelong> that too
09:21:21 <Kaidelong> I mean there are some exceptions where a lot of the design was up front and by specification but usually things just evolve over time
09:21:45 <Kaidelong> where I still find that being able to identify "this is a monoid" is useful but "I want to make sure someone else can find a monoid morphism" not so much
09:22:27 <Kaidelong> I guess if you're designing a library the category-theory kind of viewpoint might be more useful
09:22:42 <Kaidelong> or it might be that I just haven't thought enough in that way to see how it is useful
09:24:02 <Kaidelong> thinking about things in terms of algebra though is wonderful and I do it even when writing stuff like C#
09:24:22 <Kaidelong> since it lets you identify places where you can reuse code so that things break in less places
09:25:20 <Kaidelong> and typeclasses are one of the nicest features of haskell in part because it automates that algebraic idea of design where you make analogies between one statement and another one with extra context
09:25:46 <Kaidelong> although I suppose you could do it better with metaprogramming facilities in things like lisp or nermele, not that I've used those much
09:27:03 <Kaidelong> I guess it's somewhat like rhyming slang in that rather than saying what you mean you say something that rhymes with what you mean, in this case taking advantage of it being shorter
09:27:10 <Kaidelong> and that's where applicative functors come in handy
09:28:12 <joaopizani> yeah... writing parsers using applicative functors was one of the nicest experiences I had lately :)
09:30:18 <Sculptor> now you sound like sheldon
09:37:30 <ludamad> :t zip
09:37:31 <lambdabot> [a] -> [b] -> [(a, b)]
09:39:50 <ludamad> How can I do a m a -> m b -> m (a, b) ?
09:39:55 <ludamad> Or well, what's a terse way ?
09:39:55 * hackagebot traverse-with-class 0.1 - Generic applicative traversals  http://hackage.haskell.org/package/traverse-with-class-0.1 (RomanCheplyaka)
09:44:13 <elliott> ludamad: liftM2 (,)
09:44:23 <ludamad> elliott, tyvm
10:06:20 <Philonous> Is there a portable way to handle SockAddr without autoconf?
10:10:45 <teneen> how to declare an instance of Typeable manually?
10:11:42 <ludamad> I'm getting 'Warning: Pattern match(es) are overlapped', but AFAICS the alternatives are '1' and '2' that its saying overlap. What could be going on ?
10:12:06 <geekosaur> @paste your code
10:12:06 <lambdabot> Haskell pastebin: http://hpaste.org/
10:13:21 <tgeeky> (along with the error)
10:13:59 <teneen> I can't use type-safely cast a newtype wrapper around Int to an Int. Why is this?
10:14:22 <ludamad> strange, im getting IRC messages but cant browse
10:16:40 <teneen> When is Data.Typeable.cast useful?
10:16:51 <ludamad> geekosaur, tgeeky: http://hpaste.org/84825
10:17:02 <ludamad> the problem is in getMessage
10:17:25 <geekosaur> figured that
10:17:31 <geekosaur> you cannot test for values that way in case
10:17:53 <ludamad> Oh ?
10:18:06 <geekosaur> you are not checoing against an existing loginMessageId, you are creating a new local binding to the value you are "testing"
10:18:08 <madhadron> Would someone on the Haskell mailing lists mind doing me a favor?
10:18:13 <geekosaur> it is a pattern match not a comparison
10:18:28 <ludamad> geekosaur: Oooh.
10:18:30 <ludamad> gotcha
10:18:30 <madhadron> I've been somewhat out of the community for a year or two, and at someone's request just updated the hdaemonize package to work with the latest GHC.
10:18:47 <ludamad> geekosaur: No way to have a named constant in a case ?
10:18:51 <madhadron> It's gone to Hackage, but would someone mind sending the usual little announce message that it's alive and updated?
10:19:05 <madhadron> (Or has that been automated or is not done anymore since I wandered off?)
10:19:20 <tgeeky> madhadron: not automated, someone will have to do it
10:19:40 <geekosaur> I don't see where those values are defined but if they derive Eq then you can do: case msgType of a | a == loginMessageID -> ... | a = createUserMessageID -> ...
10:19:46 <tgeeky> madhadron: I can't do it, unfortunately. I signed up with an "email+haskellmailinglist" kind of address, which doesn't let me reply
10:19:57 * hackagebot hdaemonize 0.4.5.0 - Library to handle the details of writing daemons for UNIX  http://hackage.haskell.org/package/hdaemonize-0.4.5.0 (FrederickRoss)
10:20:09 <ludamad> they're just in the file
10:20:10 <madhadron> Well, there's Hackagebot at least.
10:20:12 <ludamad> but that works, thanks
10:20:16 <tgeeky> madhadron: yep :)
10:20:36 <madhadron> (With special thanks to Karl Voelker for doing the actual work)
10:21:10 <tgeeky> KarlVoelker++
10:22:53 <madhadron> Anyway, anyone on the lists who would send the message for me?
10:23:04 <madhadron> (Besides tgeeky and his spamproofed address)
10:23:19 * tgeeky sulks in the corner
10:23:42 <madhadron> tgeeky: Hey, I don't blame you. We all know what a giant spamlord Simon Peyton-Jones is. (:
10:27:44 <hpaste> ParahSailin pasted “optimize” at http://hpaste.org/84826
10:28:38 <ParahSailin> in that example, will a call of "nearestNeighborTM" compute the thunk "countNeighbors sq" twice, or is ghc smart enough?
10:29:10 <geekosaur> in general, if you want to make sure something is computed once, use a let binding
10:29:51 <djahandarie> edwardk, I like how you got a whole meetup dedicated to studying your libraries in Japan
10:31:59 <tgeeky> djahandarie: as well there should be!
10:33:32 <aristid> djahandarie: in addition to a channel dedicated to discussing his libraries :)
10:43:56 <tgeeky> aristid: and now, thanks to diagrams-haddock, diagram-ize and example-ize.
10:55:56 <Pods> Hi, I want to start contributing for haskell- swish mainly , as a part of GSOC2013, any directions for relevant bugs in swish??
10:57:37 <madhadron> Pods: Is there a bug tracker up somewhere?
10:58:00 <madhadron> (I normally wouldn't respond since I'm almost not in the community at this point, but there's an epidemic of silence)
10:58:40 <Pods> madharon: there is , but I cannot seem to find something good to start with for the respective library
10:59:03 <madhadron> Ah. Everything requires more knowledge of the guts than you have?
11:00:21 <Pods> madharon : More like I dont know which is the best place to start using the knowledge I have :)
11:00:46 <madhadron> Ah. Have you built something with the library yet?
11:01:00 <ChongLi> hmm
11:01:07 <ChongLi> anyone here use ghcmod.vim?
11:01:15 <Pods> not yet
11:01:42 <madhadron> Pods: That's a good place to start in order to get some perspective.
11:02:35 <Breadmonster> Umm, how do you define a function in Haskell?
11:02:46 <ChongLi> Breadmonster: with =
11:02:54 <Breadmonster> yeah, I get an error.
11:02:56 <ChongLi> foo x = x * 2
11:03:00 <Breadmonster> One minute, let me show you.
11:03:18 <ChongLi> if you are at the ghci prompt, you need to use let
11:03:20 <madhadron> Breadmonster: Are you in GHCi or GHC?
11:03:24 <Pods> madhadron : thanks , will do
11:03:27 <ChongLi> let foo x = x * 2
11:03:40 <madhadron> Pods: Remember, free advice on the Internet is usually worth what you paid for it. (:
11:03:43 <Breadmonster> madhadron: GHCi
11:03:50 <Breadmonster> ghci> doubleMe x = x + x  <interactive>:8:12: parse error on input `='
11:04:01 <ChongLi> let doubleMe x = x + x
11:04:02 <madhadron> Breadmonster: Type 'let doubleMe x = x + x'
11:04:20 <Breadmonster> madhadron: would there be a difference if I was using ghc and ghci?
11:04:21 <madhadron> GHCi is more like programming in an IO do block than the basic language
11:04:24 <Pods> madharon : ^ . ^
11:04:31 <madhadron> Breadmonster: If you put it in a source file and compiled it, it would work fine.
11:04:53 <ab9rf> :t ^ . ^
11:04:54 <madhadron> GHCi is not a REPL in exactly the same way you would find in Lisp or Python
11:04:54 <lambdabot> parse error on input `^'
11:05:16 <Breadmonster> madhadron: Oh, so I have to use let for assignment in ghci?
11:05:23 <madhadron> Breadmonster: Right, just like you would in a do block
11:05:26 <Breadmonster> Strange, they don't say that in Learn You a Haskell.
11:05:31 <ab9rf> Breadmonster: no, you have t use let for binding in ghci
11:05:32 <Breadmonster> madhadron: What's a do block?
11:05:36 <ChongLi> it's not assignment, it's binding :)
11:05:47 <ChongLi> Breadmonster: you haven't got that far yet
11:05:49 <madhadron> Breadmonster: Oh, you're going through Learn You a Haskell. Forget I mentioned anything.
11:05:59 <madhadron> Yes, it would be good if they mentioned that.
11:06:07 <ab9rf> bad website
11:06:14 <Breadmonster> Hmm, isn't bonus on this chatroom?
11:06:17 <ab9rf> bad, naughty website
11:06:22 <ab9rf> no cookie for you
11:06:23 <madhadron> And yes, it's a binding, not an assignment, and you'll have learned something important and subtle when you understand the difference
11:06:25 <ChongLi> bonus?
11:06:32 <simpson> preflex: xseen BONUS
11:06:33 <preflex>  BONUS was last seen on freenode/#haskell 1 year, 333 days, 22 hours, 38 minutes and 44 seconds ago, saying: yeah i think that's better as well
11:06:37 <madhadron> ab9rf: There's a browser preference for that, I think...
11:06:59 <Breadmonster> Hmm.
11:08:36 <ChongLi> Breadmonster: hmm?
11:08:36 <ab9rf> Breadmonster: 'assignment' is a concept that doesn't really apply to functional languages.
11:09:22 <lispy> We prefer binding
11:09:28 <ChongLi> bound variables and free variables :)
11:09:30 <dmwit> preflex: xseen BONUS_
11:09:31 <preflex>  BONUS_ was last seen on freenode/#haskell 3 years, 112 days, 4 hours, 24 minutes and 51 seconds ago, saying: osaunders_: usually i think it's defined as a function that uses only the stuff it takes as parameters and function application
11:09:47 <dmwit> preflex has been going for three years? huh
11:09:49 <lispy> I wonder what happened to BONUS
11:10:27 <lispy> Scumbag haskller: writes a good book; then disappears forever.
11:10:41 <lispy> (BONUS isn't really a scumbag!)
11:11:28 <monochrom> you can still say "assignment" but you have to think "single assignment"
11:12:07 <edwardk> djahandarie: i'm huge in japan
11:12:28 <lispy> edwardk: so is tom waits
11:14:13 <monochrom> 3 years is a short time. 3 years is hardly 1% of my thesis time :)
11:15:12 <monochrom> in any case, preflex had down times too. but unlike lambdabot, preflex probably knows to save state to disk.
11:29:47 <TravisD> monochrom: Your thesis is 300 years?
11:30:52 <ChongLi> sounds like the plot of a point and click adventure game
11:31:00 <ChongLi> "Monochrom and the 300 year thesis"
11:36:32 <ab9rf> heh
11:37:20 <sproingie> ♫ heeyyyyo they love the way i do it ♫
11:41:34 <armlesshobo> ♫ as long as I got my suit & tie ♫
11:42:47 <TravisD> I have a literate haskell file that uses the gnuplot package to render some plots. Is there a good way to include them in the pdf output of running lhs2TeX -> pdflatex?
11:47:01 <ChongLi> anyone know of an easy equivalent to Clojure's juxt?
11:48:48 <shachaf> That depends on what Clojure's juxt is.
11:49:12 <ChongLi> juxt takes a bunch of functions and returns a function that is the juxtaposition of them
11:49:23 <shachaf> OK, now it depends on what a juxtaposition is.
11:49:44 <sproingie> http://clojuredocs.org/clojure_core/1.2.0/clojure.core/juxt looks like it
11:49:50 <ChongLi> it just returns a vector of the results of applying all those functions to the argument
11:50:13 <shachaf> The easy way to ask this question would be with a concrete example, you know. :-) Much simpler than English.
11:50:25 <shachaf> > sequence [(+1),(*2),sqrt] 5
11:50:26 <lambdabot>   [6.0,10.0,2.23606797749979]
11:50:40 <shachaf> > map ($ 5) [(+1),(*2),sqrt] -- sometimes simpler
11:50:42 <lambdabot>   [6.0,10.0,2.23606797749979]
11:50:48 <sproingie> looks just a bunch of concat'd maps
11:51:04 <ChongLi> right, but juxt can have different types for each function
11:51:13 <ChongLi> so it's a little more complicated
11:51:23 <sproingie> yeah you're not going to get that in haskell, it actually cares about types
11:51:27 <shachaf> OK, so what sort of type are you hoping for this function to have?
11:51:54 <ChongLi> well, I don't necessarily want this function, I'm just translating a pattern of thought
11:52:04 <ChongLi> there's probably a more idiomatic way to do this in haskell
11:52:22 <sproingie> sequence or maybe applicative on lists
11:52:29 <shachaf> Probably.
11:53:15 <shachaf> > (head &&& length) "hello"
11:53:17 <lambdabot>   ('h',5)
11:53:20 <TravisD> ChongLi: In Control.Arrow the (&&&) operator does what you want, but only for pairs
11:53:38 <byorgey> but pairs is all you need!
11:53:43 <TravisD> :)
11:53:51 <byorgey> > ((head &&& length) &&& reverse) "hello"
11:53:52 <lambdabot>   (('h',5),"olleh")
11:53:55 <ChongLi> yeah, haha
11:54:07 <byorgey> > (head &&& length &&& reverse) "hello"
11:54:08 <sproingie> what's the associativity normally
11:54:09 <lambdabot>   ('h',(5,"olleh"))
11:54:14 <sproingie> right looks like
11:54:24 <sproingie> more lispy anyway
11:54:25 <byorgey> yep, I wasn't sure if it had an associativity
11:54:26 <TravisD> a bit harder to work with, I guess :P
11:54:28 <ChongLi> makes sense
11:54:35 * sproingie probably woke lispy up with that one
11:55:00 <byorgey> my version is more sproingie
11:55:07 <ChongLi> I probably should just create a record type for what I want
11:55:13 <sproingie> yay :)
11:56:02 <ChongLi> there's always tradeoffs going back and forth between lisps and Haskell
11:56:21 <sproingie> > let (x,(y,z)) = (head &&& length &&& reverse) "hello" in (x,y,z)
11:56:23 <lambdabot>   ('h',5,"olleh")
11:56:33 <johnw> @tell chrisdone Ping me if you're around
11:56:33 <lambdabot> Consider it noted.
11:56:52 <sproingie> not pretty but there it is
11:56:59 <ChongLi> that seems pretty good
11:57:25 <fedvasu> hi guys, is there a library on hackage which lets me program gpu's (general computing) irrespective of my gpu card?
11:57:33 <sproingie> i don't guess there's some generic traversal of that form?
11:57:50 <fedvasu> I have read articles and papers by mauel on CUDA.accelarate
11:58:03 <ChongLi> CUDA requires a nvidia GPU
11:58:04 <fedvasu> but that is Nvidia specific.
11:58:12 <sproingie> openCL is the way to go these days
11:58:28 <fedvasu> but how? which haskell library?
11:58:48 <sproingie> with the opencl package from haskell i imagine
11:58:50 <fedvasu> where to find docs? may be good articles like Manuel's
11:58:57 <sproingie> s/haskell/hackage/
11:59:18 <ChongLi> http://hackage.haskell.org/packages/archive/OpenCL/1.0.3.2/doc/html/Control-Parallel-OpenCL.html
11:59:28 <fedvasu> sproingie: those are low level bindings
11:59:42 <sproingie> there's gpipe i suppose
11:59:45 <thoughtpolice> all opencl/cuda bindings modulo accelerate are fairly awful IMO
11:59:58 <fedvasu> not like CUDA.Array :'(
12:00:17 <sproingie> nothing as lovely as aparapi for java
12:00:26 <lispy> MOAR LISPY
12:00:26 <thoughtpolice> they're just far too low level for most people to tolerate. there is a WIP OpenCL backend for Accelerate somewhere, but AFAIK it's not finished
12:01:08 <fedvasu> I am a bit sad!!
12:01:22 <ChongLi> that's just the way it is!
12:01:57 <johnw> lispy: RAWR!
12:02:23 <k00mi> the repo for the OpenCL backend wasn't touched since over a year
12:02:23 <lispy> @rawr
12:02:24 <lambdabot> Maybe you meant: arr yarr
12:02:28 <lispy> @yarr
12:02:29 <lambdabot> Gangway!
12:02:47 <lispy> Is it talk like a lambdabot day?
12:03:00 <lispy> > fix Just
12:03:02 <lambdabot>   Occurs check: cannot construct the infinite type:
12:03:02 <lambdabot>    a0 = Data.Maybe.Maybe a0
12:03:19 <shachaf> > fix (In . Just)
12:03:22 <lambdabot>   In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (J...
12:03:49 <shachaf> > fix (Just . In)
12:03:51 <lambdabot>   Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just ...
12:03:52 <otters> this Just In
12:05:13 <croikle> :t In
12:05:15 <lambdabot> f (Mu f) -> Mu f
12:05:50 <aCube> :k Mu
12:05:51 <lambdabot> (* -> *) -> *
12:08:40 <fedvasu> will ghc-7.8 use dynamically linked libraries by default?
12:09:13 <fedvasu> does that mean less bloated binaries for my <favorite> linux distro?
12:10:05 <napping> you would have to ask the maintainers for your distro
12:11:02 <fedvasu> napping: ok, i understanf that the decision to build ghc as statically linked binaries is of distro maintainer
12:11:46 <fedvasu> napping: but dynamically linked libraries for ghc are the norm from now on right?
12:11:55 <ChongLi> I like the static linking
12:12:06 <ChongLi> far too much breakage would go on otherwise
12:12:34 <napping> we don't have a good plan for packaging binaries like that
12:12:52 <fedvasu> ChongLi : Noooooo, bandwidth is still way way too precious in poor countries
12:13:19 <fedvasu> ghc download on fedora takes like : 300 Mb
12:13:21 <napping> if you really care about bandwidth, source packages are the way to go
12:13:21 <ChongLi> fedvasu: I didn't even think of that!
12:13:26 <beefcube> i'm not sure if this is a haskell specific question, I'm wondering if there is a way to retain a System.IO Handle to a file, change the file, and have the handle point to the change? Or Is System.IO, essentially modeled so that I would need to reload the handle following a change to the file?
12:13:31 <fedvasu> on disk it is atleast 1GB
12:13:53 <tsinnema> is there any nice intro to the various tools in the HList package and particularly to useful things to know about their implementation?
12:14:12 <fedvasu> napping: yup, source packages are the way to go, so I will use gentoo from now on!!
12:14:21 <ChongLi> fedvasu: ghc on arch linux is 60MB download
12:14:21 <ab9rf> beefcube: "point to the change"?  i don't understand what you mean.
12:15:09 <napping> I think the nicest thing about shared libraries for distros is that you can hopefully just update the library for security fixes, but I doubt that works for dynamically linked haskell
12:15:16 <sproingie> it's a handle, a file descriptor.  handles don't have contents, they just point to an open file
12:15:33 <sproingie> if it changes, that'll be reflected when you read it
12:15:35 <fedvasu> ChongLi: Arch Linux, FTW!!
12:15:46 <ChongLi> fedvasu: yes, it does in general
12:15:48 <beefcube> ab9rf: for example, if hIsEOF returns true for a handle, and I subsequently write to the file, I want hIsEOF to return false
12:15:58 <ChongLi> but especialy so if you need to keep downloads small
12:15:59 <beefcube> ab9rf: for the same handle
12:16:04 <fedvasu> ChongLi: But wait, I can't explain this problem to fedora ghc maintainer, partly I am to blame here
12:16:20 <sproingie> is that EOF behavior even well defined in C?
12:16:21 <Eelis> i was installing archlinux today but when the installation guide said "now go read the GRUB wiki article", i'd had enough :P
12:16:43 <ChongLi> fedvasu: why are you to blame?
12:17:00 <napping> fedvasu: getting a binary ghc package and using cabal for the rest seems to work pretty well. The only thing that I remember that takes annoyingly long to build it gtk
12:17:14 <fedvasu> ChongLi: just a minute
12:17:43 <gspr> Does Hackage 2 have a feature to ignore non-documentation build errors when building the haddock documentation for a package?
12:18:17 <fedvasu> ChongLi: https://bugzilla.redhat.com/show_bug.cgi?id=911725
12:18:58 <fedvasu> napping: cabal ain't as pretty as adverstised, it doesn't work sometimes, like installing Agda2 recently
12:19:38 <napping> yeah, some things might be better built sandboxed, especially if you just want to produce a statically linked binary for yourself
12:20:44 <monochrom> "ghc-ghc-devel is for hacking on ghc" is wrong
12:21:05 <fedvasu> monochrom : for what it is?
12:21:34 <monochrom> if you use any of hint, ghc-mod, eclipsefp... you already need it
12:22:06 <fedvasu> monochrom: hmm, for emacs-haksell-mode??
12:22:46 <monochrom> not really, but ghc-mod is for emacs and goes beyond emacs haskell mode
12:23:25 <ChongLi> fedvasu: hmmm
12:23:44 <monochrom> anyway generally it is needed for advanced IDE and IDE-like things
12:23:56 <ChongLi> fedvasu: it sounds to me like the maintainer wants to help you
12:23:58 <fedvasu> monochrom: can just jeave your couple of points on that bugsite, so that I and mainatainer both are enlightened ??
12:24:10 <monochrom> no, I don't really care about fedora
12:24:48 <fedvasu> ChongLi: yeah, I get that, but does he understand what is absolutely required and what ain't?, I don't!!
12:25:05 <ChongLi> fedvasu: depends what you want to do
12:25:18 <ChongLi> Network is required for a lot of things, for example
12:25:31 <fedvasu> monochrom: OK, fair enough. No fedora love on irc huh?
12:26:14 <fedvasu> ChongLi: the previous bug report was because i was not able to use quick-chcek ok
12:26:46 <fedvasu> ChongLi: To fix it he added a whole lot of devel packages.
12:26:51 <ChongLi> perhaps you just want to install the compiler and cabal-install
12:27:00 <ChongLi> and then just add any package you need with that
12:27:42 <fedvasu> ChongLi: yeah, perhaps.. that is best. but the thing is ghc-compiler is not freely installable from packages, it has ghc-ghc-devel as dependency
12:28:12 <fedvasu> ChongLi: the problem is with dependendncy, not how i install ghc by default.
12:28:15 <ChongLi> by the way, I don't know how the arch maintainer gets such a small package
12:28:40 <ChongLi> if you just download ghc from the website on haskell.org/ghc it is 120+MB
12:28:44 <Pods> Looks like there is an error in building swish.. http://pastebin.com/raw.php?i=2CaU5yCL ;  (hpaste wasn't loading in my browser so i reverted to using pastebin instead)
12:28:49 <mauke> The paste 2CaU5yCL has been copied to http://hpaste.org/84834
12:28:58 <fedvasu> ChongLi: yeah
12:29:01 <thoughtpolice> ChongLi: it's because that includes documentation and other stuff
12:29:12 <thoughtpolice> and a lot of libraries
12:29:13 <ChongLi> perhaps you want to switch to arch linux!
12:29:22 <thoughtpolice> so most of the time maintainers will split those pieces out
12:29:42 <fedvasu> ChongLi: about time!! may be Gentoo!!
12:29:48 <ChongLi> haha, gentoo
12:29:54 <monochrom> GHC takes a while to build
12:30:09 <Pods> Thanks mauke :)
12:30:35 <fedvasu> monochrom: to build ghc we need ghc right?
12:30:42 <monochrom> also yes
12:30:48 <thoughtpolice> well, it *can* take a while to build. even my $80 ARM machine can build GHC in about 2 1/2 hours with 4 cores
12:31:07 <thoughtpolice> just changing your build flavour and using 'make -j1' can reduce the build time by a factor of like 10
12:31:14 <thoughtpolice> er, 'make -jX'
12:31:25 <fedvasu> thoughtpolice: some kind of chromebook or its knock-off?
12:31:35 <thoughtpolice> ODROID-U2
12:31:37 <fedvasu> -jX means what?
12:31:43 <Pods> Can anyone explain the error http://hpaste.org/84834
12:31:45 <ChongLi> number of jobs
12:31:49 <ChongLi> -j4
12:31:51 <ChongLi> 4 jobs
12:31:54 <thoughtpolice> it's just an ARM SoC, but a beefy one at that with 4 cores and 2GB of RAM @ 1.7gHZ
12:32:14 <sproingie> didn't know it worked with parallel make.  that oughta help on my 48 core server
12:32:18 <fedvasu> thoughtpolice: thats pretty hardcore
12:32:44 <thoughtpolice> sproingie: nobody seems to, i'd say 90% of the time people say GHC takes a long time to build, they're building with 1 core and not modifying their build settings.
12:32:55 <thoughtpolice> my view is skewed though, because i also mostly talk to people who want to work or patch GHC
12:33:06 <sproingie> it doesn't mention it anywhere in the README so i didn't assume it worked
12:33:36 <thoughtpolice> sproingie: i'll fix that
12:33:44 <thoughtpolice> and make sure the HACKING file has that too since I recently rewrote it
12:33:45 <sproingie> yay :)
12:37:27 <juliohm> Off-topic: Is someone advanced user of TeX/LaTeX? Where on earth i can learn this language in deep? All the book i've read are superficial and teach examples instead of the language itself.
12:37:56 <monochrom> if you really want deep, Knuth's The TeXbook
12:38:13 <ChongLi> that sounds pretty scary
12:38:36 <monochrom> what can I do. "deep" is being demanded.
12:38:54 <ChongLi> donald knuth is a crazy wizard genius who writes big scary tomes!
12:39:11 <napping> TeX is pretty scary too, but that is the book if you really want to know how it works
12:39:13 <byorgey> the TeXbook is not that big actually.
12:39:13 <ChongLi> hopefully he manages to finish TAOCP
12:39:15 <thoughtpolice> sproingie: https://github.com/ghc/ghc/commit/0b72347dc468ba081d67385a077238bcaa9eb4d5
12:39:45 <monochrom> this one, fortunately, is just 500 pages
12:40:17 <napping> I presume there's a literate programming version of the source if you really want, but the TeXbook is as in depth as I've needed
12:40:28 <byorgey> huh, for some reason I thought it was shorter than that
12:40:46 <sproingie> thoughtpolice: looks good :)
12:41:18 <thoughtpolice> oh shoot
12:41:19 <sproingie> make -j49 # mmmmmm
12:41:57 <yezariaely> sproingie: So many cores, you have? Using all of them, you must!
12:42:12 <sproingie> hrm!
12:44:33 <ChongLi> perhaps in a few thousand years they'll think of TAOCP the way we think of Euclid's Elements?
12:47:05 <augur> hmm
12:47:17 <augur> Num a => Num (Cont a) ??
12:47:41 <juliohm> monochrom, have you read the Knuth's book? It's worth buying?
12:47:54 <juliohm> i'll try it out...
12:47:57 <juliohm> searching for a preview
12:48:48 <thoughtpolice> sproingie: hilariously i almost broke the repository with that commit.
12:48:54 <thoughtpolice> submodules and 'git commit -a' strike again
12:48:56 <thoughtpolice> *sigh*
12:49:32 <thoughtpolice> i really wish we could just not use them somehow. they just seem error prone at this rate
12:50:14 <ChongLi> I don't use submodules :)
12:50:57 <yezariaely> juliohm: If you refer to Knuth's The Art of computer Programming, it is definitely worth buying, though large and (partly) complex. But if you do half of the exercises (follow the algorithm in the introduction ;-)) you learn lot of stuff.
12:51:29 <yezariaely> If you are able to use the new knowledge depends though.
12:51:53 <juliohm> yezariaely, no, The TeXBook
12:52:15 <juliohm> The Art of Programming is incredible, but no one has patience to read the full series
12:52:18 <juliohm> nor time
12:52:43 <yezariaely> Definitely. But I don't know his TeXBook, sorry.
12:53:20 * geekosaur has it in storage somewhere, if it hasn't suffered water damage or something
12:53:33 <napping> juliohm: I've found the TeXBook useful
12:53:50 <geekosaur> it's pretty good, but TeX is fairly low level. if you're using latex you probably want to start with lamport's book instead
12:54:08 <napping> I don't need to do it often, but it's been invaluable for understanding some weird stuff
12:54:26 <juliohm> geekosaur, i have read lots of books for latex, probably this one by lamport, all are superficial and don't teach the language, just copy/paste snippets
12:54:50 <juliohm> i'm not able to write my own packages by reading those latex books
12:54:58 <juliohm> or contribute to existing ones
12:55:20 <geekosaur> ok, for that level you would also need knuth
12:55:27 <fedvasu> juliom: have tried wikibook on latex? lt is cookbook style and I think covers lot of breadth
12:55:38 <fedvasu> juliom: not sure of depth
12:59:27 <dEPY> anyone can look at this: http://hpaste.org/84835 and tell me why is solveRPN working ok and myRpn is not working properly? myRpn calculates ok "1 1 +" but fails at "1 1 1 +"
13:01:23 <NemesisD> hi guys. i'm trying to specify build an API client, one of the functions returns IO [Result], on the remote end it is getting items a page at a time
13:02:11 <NemesisD> but i want that list to be lazy so that you'd do something like: results <- apiCall; print $ take 2 results and it would not make unnecessary API calls
13:02:47 <hpaste> NemesisD pasted “lazy io” at http://hpaste.org/84836
13:03:18 <NemesisD> a simplified example ^ could anyone give me a hint how i'd restructure this for laziness in the result
13:14:42 <NemesisD> should i be using an IOArray or just choose a streaming library and abandon this pursuit
13:15:08 * Pods waiting for any advancement in swish related queries 
13:15:36 <NemesisD> swish queries?
13:16:13 <tamiko> NemesisD: You can use unsafeInterleaveIO to lazily build up [result]
13:17:03 <Pods> NemesisD :  building swish gives me an error  http://hpaste.org/84834, seems to me like a bug
13:17:16 <NemesisD> tamiko: that sounds... unsafe
13:18:53 <tamiko> NemesisD: Actually it does what you want and is quite a nice way to interleave IO when building up a WHNF such as a list.
13:19:35 <NemesisD> tamiko: hmm, yeah i've just always strived to stay away from the unsafe functions because i don't know what i'm doing
13:20:10 <NemesisD> also this is a library and i don't want to hose anyone's code by doing this
13:20:21 <tamiko> NemesisD: I found an example snippet. Something I've written 2 or 3 years ago. http://dpaste.org/pptOo/
13:23:03 <mauke> preflex: longest-unseen
13:23:07 <mauke> inb4 ping timeout
13:25:39 <NemesisD> tamiko: more surprising to me is that you have to use the unsafeInterleaveIO function for something that seems like it should be within haskell's wheelhouse, lazily producing values
13:25:49 <lispy> I'll just leave this here...http://www.andres-loeh.de/GenericGenericProgramming/ggp.pdf
13:26:13 <preflex>  fghy was last seen on #perl 4 years, 349 days, 8 hours, 40 minutes and 50 seconds ago, saying: SINCE?
13:26:35 <mauke> oh, interesting
13:28:31 <tamiko> NemesisD: Not with IO. This is a very subtle matter.
13:30:01 <NemesisD> tamiko: makes me think what i'm doing might be a bad idea
13:30:29 <NemesisD> i'd just use io-streams or something but then that pisses off adherants to the religions of pipe, conduit, enumerators, etc
13:30:33 <tibbe> @pl \ z xs f -> foldl f z xs
13:30:33 <lambdabot> flip . flip foldl
13:30:45 <tibbe> lambdabot: you there?
13:30:58 <mauke> @msg #haskell yes
13:30:58 <lambdabot> Not enough privileges
13:31:25 <tamiko> mauke: ;-)
13:36:09 <otters> does anybody else use cabal-ghci?
13:36:24 <otters> it randomly breaks on me
13:39:01 <c_wraith> NemesisD: it doesn't really. Gabriel Gonzales was one of the main contributors to io-streams.
13:39:58 <Kayexter> Hey, im new to the haskell language, and i'm wondering if someone could tell me why this is not working
13:40:07 <Kayexter> remove:: Eq a => a -> [[a]] -> [[a]]
13:40:13 <Kayexter> remove a (x:xs) = remove (filter (/=a) x) xs
13:40:16 <NemesisD> c_wraith: how can he do both D:
13:40:20 <Kayexter> noidea what im doing wrong
13:40:27 <NemesisD> there is obviously only 1 true right answer
13:40:57 <mauke> Kayexter: define "not working"
13:41:17 <flux> kayexter, I don't know either, but at least I can see that you are not handling the base case: remove 42 []
13:41:19 <geekosaur> Kayexter, I see you using remove in two different types there (the one you declared, and one that takes a predicate)
13:41:23 <geekosaur> how is that supposed to work?
13:41:34 <mauke> geekosaur: what predicate?
13:41:47 <mauke> the different types are a and [a]
13:41:50 <geekosaur> mauke: the parameter with filter?
13:41:54 <geekosaur> oh, right
13:41:56 <geekosaur> ok
13:42:06 * geekosaur read too fast
13:42:13 <mauke> and too deep
13:43:04 <Kayexter> I get a 'Couldn't match type' error
13:43:27 <mauke> Kayexter: what's the error message?
13:45:04 <aavogt> geekosaur: you're allowed to have polymorphic recursion, for example:    remove a (x:xs) = concat $ remove (filter (/=a) x) [xs]
13:45:29 <geekosaur> no, I misread it as a partiual application
13:45:37 <Kayexter> 'a' is a rigid type variable bound by the type signature for remove :: Eq a => a -> [[a]] -> [[a]] is the full error
13:45:42 <geekosaur> was flipping beween this channel and another
13:45:45 <aavogt> in that remove on the right hand side is called with type   [a] -> [[[a]]] -> [[[a]]]
13:46:16 <aavogt> but then you need to do stuff to make sure that the type being returned isn't infinite / dependent on the length of the input list
13:46:31 <aavogt> Kayexter: you should keep the 'a' argument the same
13:46:55 <aavogt>  remove a (x:xs) = filter (/=a) x : remove a xs
13:47:03 <mauke> Kayexter: that's not the full error
13:47:56 <aavogt> or simpler:      remove a xs = map (filter (/= a)) xs
13:48:51 <Kayexter> I see, thank you people very much, first programming language im learning, still trying to get to grips with evreything
13:48:51 <sipa> remove a = map . filter (/= a)
13:49:19 <shachaf> sipa: I think you want $, not .
13:49:34 <shachaf> (Actually you want parentheses, of course.)
13:49:50 <sipa> eh, rifht
13:49:53 <sipa> right
13:58:45 <otters> as far as I can tell, the only way to read from a socket until null byte is character by character
14:00:06 <Eelis> these days if i were to use sockets and wasn't bound to an existing TCP protocol or something, i'd probably use zeromq
14:00:34 <geekosaur> otters, that's usually the only way provided by the OS
14:00:36 <otters> i'm bound to an existing TCP protocol
14:00:53 <otters> okay, thanks
14:03:08 <sipa> otters: i think you can peek into a socket to find its next data being read, without actually reading it
14:03:40 <sipa> otters: so you could do thay, scan tje memory buffer for null, and then 'read' that many bytes for real
14:04:30 <otters> hmmm
14:04:37 <otters> hLookAhead only returns a char though
14:04:38 <quchen> I've got a newtype wrapper around a monad (transformer stack). Is there an easy way of making this a monad?
14:04:55 <quchen> As in "is the obvious solution of writing bind using wrap/unwrap correct"
14:05:26 <quchen> GeneralizedNewtypeDeriving is black magic so I'd like to do it explicitly myself even if that's an alternative :-)
14:05:34 <otters> sipa: I don't think you can look ahead more than a character lol
14:07:25 <sipa> otters: pretty sure you can; recvfrom() , MSG_PEEK
14:07:36 <otters> in haskell?
14:08:11 <sipa> oh, no idea :)
14:08:31 <sipa> i meant sockets in general support that
14:08:33 <hpaste> dates pasted “modifying list of list of strings” at http://hpaste.org/84839
14:08:46 <sipa> i never wrote networking code in haskell
14:09:11 <dates> hi, I made a hpaste, can you help me  solving that problem?
14:14:00 <otters> is it possible to fork a child process and exit without killing it? basically replacing the current process with a new one
14:14:19 <otters> because code hotloading etc. is out of scope for this bot, I'd rather just have it restart itself by executing the binary
14:14:23 <mauke> er. it sounds like you're describing exec
14:14:45 <otters> er yes
14:15:02 * hackagebot names 0.2 - Types that symbolise Names.  http://hackage.haskell.org/package/names-0.2 (JulianFleischer)
14:15:04 * hackagebot named-records 0.1 - Named records.  http://hackage.haskell.org/package/named-records-0.1 (JulianFleischer)
14:16:23 <geekosaur> :t execProcess
14:16:24 <lambdabot> Not in scope: `execProcess'
14:16:36 <geekosaur> silly bot
14:17:06 <otters> like ruby's exec
14:17:07 <otters> !
14:17:12 <otters> and since ruby and haskell have so much in common...
14:17:36 <mauke> no, like unix exec
14:17:49 <otters> yeah, ruby exec is unix exec
14:19:11 <ChongLi> ruby and haskell have so much in common?
14:19:12 <beaky> hello
14:19:17 <otters> no ChongLi
14:19:18 <beaky> how do I make a lambda call itself?
14:19:24 <ChongLi> I didn't think so :)
14:19:25 <otters> beaky: fix
14:19:39 <beaky> @src fix
14:19:39 <lambdabot> fix f = let x = f x in x
14:19:40 <otters> so what I'm looking for is probably System.Posix.Process.executeFile then
14:19:42 <otters> or forkProcess
14:20:21 <geekosaur> not forkProcess
14:20:27 <joaopizani> beaky: an easier-to-understand definition for fix is probably
14:20:36 <joaopizani> beaky: fix f = f (fix f)
14:20:52 <otters> executeFile then
14:20:56 <shachaf> From some perspectives the other one is easier to understand.
14:21:08 <shachaf> > let x = 1 : x in x
14:21:10 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:21:13 <beaky> I guess the @src one is written in a way to avoid a recursive type?
14:21:14 <shachaf> Now abstract out the (1:)
14:21:29 <monochrom> for fix, see my http://www.vex.net/~trebla/haskell/fix.xhtml
14:21:52 <beaky> > fix (1:)
14:21:53 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:21:56 <otters> but then, how to figure out the location of the executable
14:22:11 <monochrom> also, the "let" version increases sharing
14:22:14 <mauke> otters: how portable does it have to be?
14:22:37 <otters> mauke: unix only
14:22:42 <mauke> which unix?
14:22:42 <otters> lunix
14:22:52 <mauke> ?
14:22:53 <otters> realistically speaking, just my debian server
14:23:03 <mauke> @hoogle readLink
14:23:03 <lambdabot> No results found
14:23:11 <beaky> how do i write fix without using recursion?
14:23:17 <joaopizani> > let fac = fix (\f n -> if n == 0 then 1 else n * f (n-1))  in  fac 4
14:23:20 <lambdabot>   24
14:23:25 <monochrom> cannot be written in haskell
14:23:31 <sproingie> fix is recursive by definition
14:23:32 <tibbe> :pl
14:23:33 <chrisdone> what up
14:23:33 <lambdabot> chrisdone: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:23:34 <tibbe> @pl
14:23:34 <lambdabot> (line 1, column 1):
14:23:35 <lambdabot> unexpected end of input
14:23:35 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
14:23:37 <joaopizani> monochrom: REALLY?
14:23:38 <elliott> beaky: you can do: fix f = let x = f x in x. that might or might not conut as recursive to you
14:23:45 <chrisdone> @yow do you work yet
14:23:45 <lambdabot> Couldn't find fortune file
14:23:54 <monochrom> really. because the type system gets into the way
14:24:04 <elliott> you can write it with only type-level, no value-level recursion
14:24:15 <shachaf> Getting into the way is the goal of the type system.
14:24:15 <sproingie> fix exists so you can say this:
14:24:17 <sproingie> > fix error
14:24:18 <beaky> :t \f -> let x = f x in x
14:24:19 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
14:24:19 <lambdabot> (t -> t) -> t
14:24:20 <tibbe> @pl let f x = undefined in Data.IntMap.foldrWithKey' (\ pl b -> f pb b)
14:24:20 <lambdabot> Data.IntMap.foldrWithKey' (const undefined)
14:24:22 <monochrom> oh, actually, I am probably wrong
14:24:41 <tibbe> @pl let f x = undefined in Data.IntMap.foldrWithKey' (\ pl b -> f pb <> b)
14:24:41 <S11001001> @djinn (a -> a) -> a
14:24:42 <lambdabot> Data.IntMap.foldrWithKey' (const (undefined <>))
14:24:42 <lambdabot> -- f cannot be realized.
14:24:45 <mauke> otters: /proc/self/exe
14:24:50 <otters> oh, I see
14:24:52 <otters> neato
14:24:56 <beaky> recursion is so cool
14:24:59 <joaopizani> monochrom: can we just use the Y combinator?
14:25:01 <monochrom> nevermind, I'm probably right
14:25:03 <joaopizani> monochrom: let me try :)
14:25:12 <monochrom> the Y combinator has a type problem in Haskell
14:25:14 <tibbe> @pl let f x = [x] in Data.IntMap.foldrWithKey' (\ pl b -> f pb <> b)
14:25:14 <lambdabot> Data.IntMap.foldrWithKey' (const ([pb] <>))
14:25:17 <beaky> so the y combinator is the essence of recursion?
14:25:19 <sproingie> Y is itself a fixpoint combinator
14:25:21 <joaopizani> monochrom: ahhh yeah
14:25:23 <glguy> .?quote monochrom nevermind, I'm probably right
14:25:28 <shachaf> monochrom: You can do it with Rec (a type with negative recursion).
14:25:29 <monochrom> haha
14:25:40 <glguy> oh, or remember, or whatever ;)
14:25:55 <elliott> you can write the Y combinator with a newtype wrapper
14:25:58 <elliott> but that wrapper is itself recursive
14:26:10 <monochrom> yeah, if you don't use value recursion, you need to go through a recursive type, but I still consider that "using recursion"
14:26:12 <shachaf> Curry's paradox!
14:26:13 <joaopizani> too many workarounds :)
14:26:21 <elliott> not really a workaround
14:26:25 <elliott> just being more explicit about your types
14:26:29 <shachaf> Curry's paradox may be the best paradox.
14:26:33 <beaky> @src fix
14:26:33 <lambdabot> fix f = let x = f x in x
14:26:50 <chrisdone> shachaf: https://twitter.com/pigworker/status/317065227852185600
14:27:08 <joaopizani> elliott: but this newtype wrapper would be to write type-level or value-level non-recursive fix?
14:27:11 <monochrom> it is certainly not as good as Y which moves the recursion completely to the meta level (the interpreter, the denotational semantics, etc)
14:27:33 <chrisdone> shachaf: thought it was a nice perspective shift from 'types block you from messing up' to 'types guide you to success'
14:27:58 <monochrom> ho hum, I have another idea
14:28:05 <elliott> joaopizani: the newtype wrapper would be type-level recursive.
14:28:10 <elliott> you'd then write a non-value-level-recursive fix using it
14:28:18 <shachaf> And crash GHC.
14:28:21 <shachaf> So it goes.
14:28:37 <tibbe> Anyone have a good idea how to make this point free and still readable: Map.foldr (\ pl b -> putPostingList pl <> b) mempty
14:29:04 <tibbe> The pattern that's repeating is that the function being folded over the map computes some values that's then mappended on to the front
14:29:06 <elliott> tibbe: that's a foldMap
14:29:10 <sproingie> @pl Map.foldr (\ pl b -> putPostingList pl <> b) mempty
14:29:11 <lambdabot> Map.foldr ((<>) . putPostingList) mempty
14:29:11 <elliott> foldMap putPostingList
14:29:17 <monochrom> use runST and mutable ref. this may get you a good fix.
14:29:18 <elliott> :ty foldMap ?putPostingList
14:29:21 <elliott> :t foldMap ?putPostingList
14:29:23 <lambdabot> (?putPostingList::a -> m, Foldable t, Monoid m) => t a -> m
14:29:32 <tibbe> ah :)
14:29:34 <elliott> (in Data.Foldable)
14:29:48 <tibbe> now lets see if Map has an efficient Foldable instance :)
14:29:49 <elliott> bonus, it might even use the tree structure efficiently, depending on how good Map's instance is
14:29:54 <shachaf> foldMap will give you a balanced rather than a right-biased tree.
14:29:55 <elliott> it should be at least as efficient as the foldr though.
14:30:03 <shachaf> This may be a bonus or an un-bonus.
14:30:10 <tibbe> I should know as I probably wrote it but I forgot
14:30:11 <elliott> (well, assuming you have a good Monoid.)
14:30:16 <elliott> tibbe: hehe
14:30:29 <elliott> it's annoying how some monoids get worse by giving them tree structure :(
14:30:33 <elliott> lens has that problem a lot.
14:30:41 <shachaf> Data.Map's Traversable instance is fine.
14:30:56 <shachaf> That can't be said for all the instances in containers. :-(
14:31:11 <tibbe> hmm, I think the Foldable Map instance associates wrong
14:31:21 <tibbe> foldMap f (Bin _ _ v l r) = Foldable.foldMap f l `mappend` f v `mappend` Foldable.foldMap f r
14:31:29 <shachaf> That looks OK to me?
14:31:31 <tibbe> I think that should be: foldMap f (Bin _ _ v l r) = Foldable.foldMap f l `mappend` (f v `mappend` Foldable.foldMap f r)
14:31:36 <shachaf> What would you want it to be like?
14:31:37 <shachaf> Oh.
14:31:45 <tibbe> like <> associates
14:31:48 <shachaf> I'm not sure that matters that much.
14:32:03 <tibbe> for continuation mono ids like the byte string builder it does
14:32:17 <tibbe> I hate colloquy autocomplete
14:32:30 <shachaf> monochromoids
14:32:51 <shachaf> It depends on how you're using the tree.
14:33:02 <shachaf> If you're using it right-to-left you want the opposite instance. :-)
14:33:04 <shachaf> But sure.
14:34:40 <tibbe> hmm, maybe it doesn't matter for trees
14:34:41 <shachaf> The nice thing about a balanced tree is that it doesn't matter that much.
14:34:45 <tibbe> too many continuations!
14:35:06 <tibbe> so the trees are ordered and the folds go left to right
14:35:27 <shachaf> Anyway you can recover the foldr behavior with Endo if you want it.
14:36:35 <shachaf> I think Map.foldr (mappend . putPostingList) mempty isn't so unreadable.
14:37:27 <Radish> I installed a cabal for portaudio earlier today, how come import Sound.PortAudio says it can't find anything?  Does anyone know?
14:37:53 <tibbe> shachaf: I agree
14:38:08 <tibbe> shachaf: although it requires the reader to think about which monoid goes on which side
14:38:15 <tibbe> which monoid value
14:38:20 <Radish> Oh wait, its just saying everything "is not in scope"
14:38:29 <Radish> bad example file I guess?
14:38:47 <Radish> I'll try to write one myself I guess...
14:38:49 <Radish> thanks
14:39:19 <Eduard_Munteanu> chrisdone: it says "haskell" on the door, but there's more "blah" than Haskell. ;P
14:39:55 <tibbe> decisions decisions, should I rely in the foldMap instance for Map traversing in order :/
14:40:04 <mietek> Has anyone seen a problem with Gloss on OS X where the animation doesn't work in example apps?
14:40:07 <shachaf> tibbe: "in order"?
14:40:17 <tibbe> shachaf: key1 <> key2 <> key3
14:40:29 <shachaf> Oh, I would certainly hope so.
14:40:34 <shachaf> At least I've been assuming that.
14:40:51 <tibbe> shachaf: I should check and document the current behavior
14:40:53 <shachaf> The shape of the tree is less safe to assume but I've been assuming it too.
14:41:09 <mietek> It seems like the animation gets stuck after ~5 frames.  The weird thing is, it was just working a while ago.
14:41:24 <shachaf> (Assuming that it's balanced, that is. I wouldn't mind the <> being infixr rather than infixl thing.)
14:41:58 <elliott> tibbe: foldMap is allowed to assume a monoid, not a commutative monoid :)
14:42:09 <elliott> if the order is inconsistent with foldr, I'm pretty sure that's a buggy instance
14:42:10 <mietek> And by a while ago, I mean minutes ago, right after installing gloss-examples with cabal.
14:42:13 <tibbe> elliott: right
14:42:38 <tibbe> elliott: one can reasonable assume that foldMap will traverse like just fold
14:42:54 <tibbe> elliott: is there any laws on the Traversable instances that guarantees that?
14:42:57 <croikle> if you depend on the order, maybe traversable is better
14:43:17 <tibbe> croikle: I have no interesting effects though
14:43:23 <shachaf> That guarantee what?
14:43:26 <tibbe> so an Applicative sounds a bit much
14:43:39 <shachaf> The Traversable instance should match the Foldable instance, at least.
14:43:47 <tibbe> shachaf: is there a guarantee in Foldable that foldMap traverses elements in the same order as foldr
14:43:53 <shachaf> But they can both choose any order they like.
14:43:54 <shachaf> Ah.
14:43:55 <shachaf> Yes.
14:44:01 <shachaf> At least I think so?
14:44:14 <shachaf> There aren't really any Foldable laws, but the default definition of foldr in terms of Foldable (and vice versa) gives you that.
14:44:22 <shachaf> Er, in terms of foldMap.
14:44:43 <tibbe> I see no laws in the docs :(
14:44:50 <shachaf> There are no Laws.
14:44:52 <shachaf> Foldable is awful.
14:45:01 <tibbe> the docs should mention the default implementation at least
14:45:18 <elliott> well, Foldable/Traversable are meant to define an ordering
14:45:28 <elliott> so it makes sense that you have to use the same one for all the different expressions of it
14:45:36 <shachaf> ==elliott
14:45:40 <shachaf> It's not really specified.
14:46:15 <shachaf> As far as I'm concerned a Foldable instance (or a Traversable instance) defines a canonical ordering for the elements of a data structure.
14:46:26 <ChongLi> didn't guy steele rail against the notion of ordering in folds/maps?
14:47:00 <ChongLi> that the idea is too specific
14:47:08 <sproingie> it would seem inherent to fold
14:47:20 <ChongLi> and thus inhibits parallelism
14:47:31 <sproingie> fold to me is more specific than an arbitrary reduce
14:47:42 <ChongLi> it isn't inherent if you're working with monoids
14:47:42 <sproingie> maybe that's just my reading of it
14:48:10 <sproingie> mplus isn't commutative, so i still see it as inherent
14:48:27 <shachaf> tibbe: I wouldn't object to these sorts of pseudo-laws being added to the documentation.
14:48:29 <Saizan> *mappend
14:48:44 <sproingie> right i'm always mixing them up
14:48:44 <shachaf> Foldable is still pretty awful, though. :-)
14:48:46 <tibbe> shachaf: me neither, docs are good
14:48:47 <Saizan> ChongLi: the ordering doesn't necessarily translate in evaluation order
14:48:56 <Saizan> *into
14:49:00 <ChongLi> it doesn't have to be commutative to be parallelizable
14:49:01 <cmccann> ChongLi: he complained about lack of associativity, not lack of commutativity
14:49:14 <cmccann> so yes
14:49:18 <ChongLi> cmccann: yeah, it wasn't me who brought that up :)
14:49:18 <tibbe> there's also the added confusion that the l and r in fold{l,r} are not about the traversal order
14:49:32 <cmccann> yeah, just confirming
14:49:33 <sproingie> evaluation doesn't have to be in order, but the result should appear to be in order
14:49:37 <tibbe> but about the associativity of the operator
14:49:40 <Saizan> ChongLi: if you only have associativity the order still matters
14:49:44 <otters> okay so executeFile does what I expect
14:50:02 <ChongLi> Saizan: only in the final reduction
14:50:05 <tibbe> it just happens so that fold' is more efficient than foldr' for lists
14:50:06 <cmccann> Saizan: not the order of evaluation
14:50:08 <cmccann> that's the point
14:50:08 <tibbe> foldl'*
14:50:11 <otters> but the connections that the "old" bot had don't close automatically
14:50:14 <otters> it times out after a bit
14:50:15 <Saizan> cmccann: yes, exactly
14:50:22 <sproingie> any general purpose way of evaluating out of order is back to the magical auto-parallelizing Sufficiently Smart Compiler
14:50:29 <cmccann> the word "order" is being confusingly overloaded here
14:50:38 <otters> so what I should do is disconnect first, THEN call executeFile
14:51:17 <Saizan> ChongLi: we're not talking about evaluation order, but the order the elements appear in the denotation of the result
14:51:30 <ChongLi> Saizan: ah, I was talking about evaluation order
14:51:45 <geekosaur> otters: if you have lost connectivity, doesn't much matter what you do on the client end, server won't see a clean disconnect
14:51:49 * cmccann starts talking about first-order vs. higher-order
14:51:59 <cmccann> just to confuse things further of course
14:52:14 * sproingie calls in a pizza order
14:52:17 <ChongLi> haha
14:52:17 <Saizan> 22:48     Saizan : ChongLi: the ordering doesn't necessarily translate into evaluation order <- i was trying to address this confusion from the start
14:52:33 <glguy> otters, you don't *have* to close the connection, you can had the socket file descriptor over to the new bot
14:52:34 <plhk> how do i tell cabal I need .txt file for building?
14:52:47 <plhk> (i use it in TH)
14:55:19 <Radish> ghci can't find my .dll, should i put a copy in the folder the file i'm executing is in?
14:55:23 <ChongLi> wayland/weston forked!
14:55:35 <Radish> or do i need to point it in the direction of the .dll somehow?
14:55:47 <ocharles> ChongLi: ?
14:56:01 <ChongLi> wayland is a display server protocol
14:56:05 <ocharles> i know
14:56:10 <ocharles> what's the forking about?
14:56:15 <ChongLi> northfield/norwood
14:56:22 <ChongLi> http://www.phoronix.com/scan.php?page=news_item&px=MTMzNTY
14:56:34 <ocharles> the ubuntu fork?
14:56:42 <ChongLi> no this is separate
14:56:46 <ocharles> interesting
14:56:48 * ocharles reads
14:56:48 <ChongLi> ubuntu has their own thing called mir
14:57:04 <simpson> Meh.
14:57:30 <ChongLi> meh?
14:57:31 <elliott> this isn't really about haskell :P
14:57:44 <ChongLi> I'm hoping it will be eventually
14:57:53 <ChongLi> a successor to Xmonad
14:58:01 <ChongLi> on the successor to X (whichever one wins)
14:59:25 <simpson> Uh, spoilers: X11 will win.
14:59:34 <shachaf> As elliott mentioned, this isn't really on-topic here.
14:59:36 <ChongLi> that's impossible!
14:59:55 <simpson> IYSS. >:3
15:22:03 <monochrom> I was wrong again. fix without recursion, but needs undefined and STRef:
15:22:07 <hpaste> monochrom annotated “lazy ST example” with “lazy ST implements fix” at http://hpaste.org/63925#a84840
15:22:53 <monochrom> w00t dolio, you will love this: http://hpaste.org/63925#a84840
15:25:48 <djahandarie> Hah
15:32:28 <monochrom> to understand recursion, first you must understand lazy ST! :)
15:34:38 <Saizan> that's even pretty close to what's happening on the heap with the let x = f x in x implementation of fix
15:36:37 <monochrom> yes, that's exactly how I designed it
15:36:58 <elliott> monochrom: you probably don't need undefined there
15:37:00 <monochrom> it's really "c := f (read c)" in essence.
15:37:16 <elliott> in particular, (return undefined) should work just as well, but I suspect you can do even better...
15:37:30 <Kyo> @src fix
15:37:30 <lambdabot> fix f = let x = f x in x
15:38:34 <Kyo> > fix 5
15:38:36 <lambdabot>   5
15:38:49 <Kyo> > fix (+1)
15:38:52 <lambdabot>   mueval-core: Time limit exceeded
15:39:03 <monochrom> "fix 5" is along the line of "fix (const 'x')", mind you
15:39:31 <monochrom> because lambdabot has a Num instance for functions that translates "5" to "const 5"
15:39:36 <monochrom> example:
15:39:36 <elliott> monochrom: huh, can you implement a memoising fix with ST like that?
15:39:39 <monochrom> > 5 'x'
15:39:41 <lambdabot>   5
15:40:01 <elliott> btw, how did that instance get back in?
15:40:01 <Kyo> fix-> anon recursion? how? show me with fib or fac
15:40:10 <elliott> I thought Cale removed it ages ago.
15:40:18 <elliott> Kyo: fix (\f x -> ...recurse with f, parameter is x...)
15:40:23 <monochrom> Kyo, see my http://www.vex.net/~trebla/haskell/fix.xhtml
15:40:35 * `cc` learning some linq, only way to make c# not ugly
15:41:00 <arkeet> > let fac n = if n == 0 then 1 else n * fac (n-1)   in   fac 5
15:41:02 <lambdabot>   120
15:41:10 <arkeet> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 5
15:41:11 <lambdabot>   120
15:45:39 <`cc`> congrats fix is somewhat twisted to understand
15:46:33 <`cc`> hmm here it's just a while
15:51:58 <lispy> @let unsafeCoerce = fix . (fix id) :: a -> c
15:52:00 <lambdabot>  Defined.
15:52:11 <lispy> > unsafeCoerce 1 :: String
15:52:14 <lambdabot>   mueval-core: Time limit exceeded
15:53:22 <jmcarthur> huh, i thought cale removed that instance, too
15:54:22 <elliott> maybe it's an accident?
15:55:16 <Kyo> > fix ( (0 :) . scanl (+) 1 )
15:55:19 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:55:30 * hackagebot hackage-db 1.5 - provide access to the Hackage database via Data.Map  http://hackage.haskell.org/package/hackage-db-1.5 (PeterSimons)
15:56:18 <jmcarthur> > fix ( (0 :) . scanl (+) 1 ) !! 100
15:56:19 <lambdabot>   354224848179261915075
15:56:42 <Kyo> > fix (\f n -> if n == 1 then 1 else n * (f (n-1)) )
15:56:43 <lambdabot>   *Exception: show: No overloading for function
15:56:57 <elliott> how did _that_ instance get in?
15:57:08 <Kyo> > fix (\f n -> if n == 1 then 1 else n * (f (n-1)) 5)
15:57:10 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = a0 -> t0
15:57:17 <jmcarthur> it's been popping up for me in ghci. not sure what library it is
15:57:42 <Kyo> > fix (\f n -> if n == 1 then 1 else n * (f (n-1))) 5
15:57:43 <lambdabot>   120
15:57:59 <Kyo> @type fix
15:58:01 <lambdabot> (a -> a) -> a
15:59:03 <jmcarthur> > (fix `asTypeOf` ?foo) (\f n -> if n == 1 then 1 else n * (f (n-1))) 5
15:59:05 <lambdabot>   mueval-core: internal error: PAP object entered!
15:59:05 <lambdabot>      (GHC version 7.4.2 fo...
15:59:07 <Kyo> so what is to be said about recursion and fixpoints? the function that i wasnt to implement recursively doesnt need fixpoint, or does it?
15:59:38 <Kyo> a function without a fixpoint cant be defined recursively?
15:59:40 <tibbe> @pl flip foldr
15:59:40 <lambdabot> flip foldr
15:59:54 <tibbe> :t flip foldr
15:59:56 <lambdabot> b -> (a -> b -> b) -> [a] -> b
16:00:08 <monochrom> I don't understand the question, but you can do whatever you like
16:00:10 <jmcarthur> Kyo: i don't understand your question
16:00:22 <tibbe> today I really needed a foldr with the higher order argument last a couple of time
16:00:54 <donri> tibbe: that looks more like the maybe/either/"bool" functions
16:01:14 <Kyo> if i want to define a math function f in haskell recursively, does it need to have a fixpoint?
16:01:15 <tibbe> donri: I needed b -> [a] -> (a -> b -> b)
16:01:21 <donri> aha :)
16:01:28 <tibbe> donri: so I can use foldr z xs $ \ x -> <newline>
16:01:29 <jmcarthur> Kyo: why would it?
16:01:32 <tibbe> since the body was large
16:01:32 <donri> yeah
16:01:33 <shachaf> tibbe: Why?
16:01:38 <tibbe> shachaf: big lambda
16:01:46 <tibbe> same reason there's both forM and mapM
16:01:48 <shachaf> Ah.
16:02:08 <donri> maldr and foldr then!
16:02:13 <shachaf> I,I Λ
16:02:14 <otters> is there a better way besides busy waiting to determine if a TChan is empt?
16:02:18 <otters> empty
16:02:20 <monochrom> yes, it needs to have a fixpoint, every recursion needs a fixpoint
16:02:32 <jmcarthur> Kyo: (+100) doesn't have a fixpoint, put at least for peano numerals it can still be defined recursively
16:02:53 <donri> otters: what's wrong with busy waiting!
16:03:06 <shachaf> jmcarthur: ?
16:03:09 <otters> donri: I don't have time for it
16:03:16 <jmcarthur> > fix (+100)
16:03:17 <donri> otters: runtime is smart about retries in stm
16:03:19 <Michael__> If I have a currently deterministic system, which simulates the interaction of "agents" according to certain rules, but I want to introduce a non deterministic agents, a random one, what's the best way to do that? To provide a seed I would have to pass that down throughout the functions which are respnsible for simulating the agents, and make every other agent accept a seed. Is there a better way?
16:03:20 <lambdabot>   mueval-core: Time limit exceeded
16:03:23 <otters> donri: ok
16:03:28 <jmcarthur> no fixpoint
16:03:30 <shachaf> jmcarthur: Oh, I thought you meant with lazy naturals.
16:03:30 <otters> cool, I'll do that then
16:03:38 <donri> otters: so just peekTChan
16:03:42 <shachaf> Besides, ⊥ is a fixed point.
16:04:08 <jmcarthur> ah
16:04:16 <otters> I'd use forever (atomically ...), not the reverse, right
16:04:18 <cschneid> I have two Ints, and want to get a Double with the result of the division
16:04:22 <cschneid> so Int -> Int -> Double
16:04:48 <cschneid> what func does this, OR, how do I convert Int -> Double?
16:04:50 <`cc`> can Linq be seen as a fnctional-like feature?
16:04:51 <monochrom> fromIntegral x / fromIntegral y
16:04:53 <jmcarthur> i was in the "ignore bottom" mode of thought
16:05:04 <monochrom> @quote monochrom fromIntegral
16:05:04 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
16:05:05 <donri> otters: you'd use atomically $ ... retry (or peekTChan which retries for you)
16:05:07 <jmcarthur> s/ignore bottom/bottom does not exist/
16:05:11 <otters> wait, I don't need forever
16:05:14 <donri> otters: not sure forever enters into it
16:05:24 <otters> well, I need the reverse of peekTChan
16:05:33 <otters> oh, no I don't
16:05:34 <otters> never mind
16:05:43 <otters> oh, yes I do
16:05:55 <otters> I need to retry if the channel isn't empty, so I guess tryPeekTChan
16:06:14 <cschneid> monochrom: thanks, and back again? Ideally with a rounding? (I think ceil just works)
16:06:34 <monochrom> there are round, ceil, floor, truncate. pick one.
16:07:20 <donri> otters: isEmptyTChan >>= flip when retry, or something like that
16:07:43 <donri> or throw in a "not"
16:10:10 <donri> otters: i have a feeling if you're waiting for the channel to be empty you're doing something "wrong", as in, there's a better way to do what you actually want
16:10:27 <donri> but i lack experience with stm
16:14:40 <Kyo> > fix (\f n -> if n == 1 then 1 else n * (f (n-1))) 5
16:14:42 <lambdabot>   120
16:15:07 <Kyo> @src atomically
16:15:08 <lambdabot> Source not found. My brain just exploded
16:15:19 <Kyo> @type atomically
16:15:21 <lambdabot> Not in scope: `atomically'
16:15:37 <Kyo> @src fix
16:15:37 <lambdabot> fix f = let x = f x in x
16:16:01 <shachaf> Kyo: You can /msg lambdabot for these sorts of things, by the way.
16:19:47 <otters> donri: well, the "reply" function in the bot writes to the channel, and there's a thread watching the channel that actually writes messages to the server
16:19:56 <otters> so I'm trying to make a kind of onExit function
16:20:14 <otters> where once all outgoing messages have been sent, it runs callbacks and exits
16:25:30 * hackagebot cabal-uninstall 0.1.4 - Uninstall cabal packages  http://hackage.haskell.org/package/cabal-uninstall-0.1.4 (JanChristiansen)
16:35:31 * hackagebot names 0.2.1 - Type level names.  http://hackage.haskell.org/package/names-0.2.1 (JulianFleischer)
16:35:33 * hackagebot named-records 0.2 - Flexible records with named fields.  http://hackage.haskell.org/package/named-records-0.2 (JulianFleischer)
16:36:31 * ocharles blinks at http://hackage.haskell.org/packages/archive/names/0.1/doc/html/Data-Name.html
16:36:31 <skyflash> First time I've had to parse/scan a timestamp string in Haskell.  Libs look complicated and I see old packages like "old-locale" as a dependency of Data.Time.Format (at least according to docs).  What's the official/modern way of doing this?
16:37:02 <skyflash> I'm trying readTime from Data.Time.Format
16:39:33 <geekosaur> old-locale is correct; it was, shall we say, mis-deprecated. (it was incorrectly considered to be tied to old-time)
16:39:55 <skyflash> hehe.  OK, thanks for putting my mind at ease.
16:40:33 * hackagebot named-records 0.2.1 - Flexible records with named fields.  http://hackage.haskell.org/package/named-records-0.2.1 (JulianFleischer)
16:45:12 <Paprikachu> ohhai
16:45:32 * hackagebot sourcemap 0.1.0.0 - Implementation of source maps as proposed by Google and Mozilla.  http://hackage.haskell.org/package/sourcemap-0.1.0.0 (ChrisDone)
16:50:32 * hackagebot sourcemap 0.1.0.1 - Implementation of source maps as proposed by Google and Mozilla.  http://hackage.haskell.org/package/sourcemap-0.1.0.1 (ChrisDone)
16:50:34 * hackagebot sourcemap 0.1.0.2 - Implementation of source maps as proposed by Google and Mozilla.  http://hackage.haskell.org/package/sourcemap-0.1.0.2 (ChrisDone)
17:00:32 * hackagebot sourcemap 0.1.0.3 - Implementation of source maps as proposed by Google and Mozilla.  http://hackage.haskell.org/package/sourcemap-0.1.0.3 (ChrisDone)
17:01:09 <beaky> how did they discover that the lambda calculus can be translated to a turing machine?
17:03:49 <ion> …
17:03:59 <dmwit> So... what package should I look in for a quality Text -> Rational parser?
17:04:11 <dmwit> beaky: By thinking about it.
17:04:16 <beaky> lol
17:04:24 <shachaf> dmwit: As in "123 % 456"?
17:04:33 <DanBurton> The dumb answer is "read Turing's paper on it"
17:04:35 <dmwit> beaky: Seriously. You alternate between trying to do it and trying to prove it can't be done. Eventually you succeed at one or the other.
17:04:45 <dmwit> shachaf: Preferably "123.456".
17:04:51 <shachaf> dmwit: Ah. How about "text"?
17:05:14 <shachaf> http://hackage.haskell.org/packages/archive/text/0.11.2.3/doc/html/Data-Text-Read.html http://hackage.haskell.org/packages/archive/text/0.11.2.3/doc/html/Data-Text-Lazy-Read.html
17:05:17 <dmwit> perfect
17:05:33 * hackagebot ssh 0.2.11 - A pure-Haskell SSH server library.  http://hackage.haskell.org/package/ssh-0.2.11 (SimonMichael)
17:05:42 <shachaf> Of course you can't represent all Rationals that way.
17:06:33 <dmwit> indeed
17:06:42 <dmwit> In fact, I suspect that in reality I am being sent a Double.
17:06:46 <dmwit> But I don't want to take any chances.
17:07:11 <shachaf> (Well, you can represent all rationals that way... But not with the obvious base-10 encoding.)
17:10:51 <slack1256> To me Alternative and MonadPlus fit the same purpose.
17:11:18 <slack1256> Is there any example of a datatype that can have a MonadPlus instance but no a Alternative?
17:11:27 <slack1256> *an Alternative one?
17:11:42 <arkeet> I hope not.
17:12:37 <shachaf> is there any example of a monoid which is not easy?
17:12:42 <arkeet> no
17:12:56 <shachaf> arkeet: Have you noticed how monoids are awful because they're untyped?
17:13:07 <arkeet> they are?
17:13:29 <DanBurton> shachaf: explain
17:14:18 <shachaf> You can just mappend any old thing to any old thing. No type safety.
17:14:32 <shachaf> You can't write out the types and then use holes etc. to write a function.
17:14:56 <slack1256> Having separated Alternative MonadPlus classes was a historical accident or a sane decision?
17:14:57 <donri> > mappend "hi" (Sum 5)
17:14:59 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:14:59 <lambdabot>              with actual ty...
17:15:02 <elliott> slack1256: accident
17:15:09 <Cale> beaky: Well, it was a natural sort of thing to try to do, because both are intended as models of computation. Since they're each pretty expressive, it's not especially hard (at least in comparison to writing other programs in these styles) to construct a lambda term which takes an encoding of a description of a Turing machine, and carries out steps, or a Turing machine which accepts a lambda term on its tape and carrie
17:15:09 <Cale> s out reduction.
17:15:41 <beaky> ah
17:16:58 <jmcarthur> slack1256: semi-accident. they aren't exactly the same
17:17:15 <jmcarthur> slack1256: MonadPlus has extra laws (except that we can't agree on one of them...)
17:17:45 <elliott> arguably Alternative shouldn't require Applicative.
17:17:48 <elliott> they're sort of dual
17:17:51 <jmcarthur> yeah
17:18:09 <shachaf> What are the Alternative laws?
17:18:11 <jmcarthur> well, independent, at least
17:18:18 <jmcarthur> nothing more than the monoid laws
17:18:47 <jmcarthur> they happen to interact with the applicative laws in interesting ways, but that would be the case regardless of whether it requires applicative
17:18:57 <Dodek> beaky: the actual point is that almost any model of computation you can come up with that is not crippled in an obvious way will be equivalent to turing machines.
17:19:13 <slack1256> Mmm I hadn't thought about the laws...
17:20:28 <donri> ArrowPlus! :D
17:20:57 <beaky> @src mappend
17:20:57 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
17:21:23 <donri> beaky: depends on the Monoid instance
17:21:35 <beaky> ah
17:21:52 <beaky> :t mappend
17:21:53 <lambdabot> Monoid a => a -> a -> a
17:22:16 * beaky still does not understand monoids
17:22:28 <donri> even though they're so easy?
17:22:38 <Cale> beaky: You might just look at the mathematical definition first
17:23:28 <Cale> A monoid is a set M together with a function M x M -> M (taking a pair of elements of M and producing some element of M) usually called "multiplication" in a general context, such that the following are true:
17:23:50 <jmcarthur> beaky: a monoid is just a set with an associative binary operation that has an identity. in haskell, the set is the set of values having some type, the identity is mempty, and the binary operation is mappend
17:24:03 <Cale> 1) For any a, b, c in M, we have a*(b*c) = (a*b)*c (where * is this multiplication function of course)
17:24:27 <Cale> 2) There is some element 1 in M such that for any a in M, we have 1*a = a*1 = a
17:25:15 <cl_away> My definition of monoid is:  A group is a monoid with a two sided inverse.
17:25:33 * hackagebot egison 3.0.0 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-3.0.0 (SatoshiEgi)
17:25:38 <beaky> hmm
17:25:42 <shachaf> What is "a two sided inverse"?
17:25:52 <Philippa> as opposed to left-inverse, right-inverse
17:25:55 <clahey> Right.
17:26:02 <shachaf> Oh, I read that backwards.
17:26:19 <shachaf> clahey: That's a definition of a group, not of a monoid.
17:26:21 <clahey> But now that I think of it, it's not possible to add a left-inverse vs. a right inverse to a monoid.
17:26:34 <clahey> shachaf: It's a definition by removal of axiom?
17:26:54 <ab9rf> clahey: i vaguely recall that if inverses exist then they're two-sided.  but it's been a _long_ time since i did any formal abstract algebra
17:27:01 <clahey> ab9rf: Exactly.
17:27:13 <clahey> ab9rf: At least in an associative algebra.
17:27:21 <shachaf> Well, it's a kind of vague way of putting it. But whatever.
17:27:30 <clahey> shachaf: It's not a serious definition.
17:27:42 <clahey> shachaf: Just helps me as a way to think about things.
17:27:50 <ab9rf> clahey: that makes sense
17:28:01 <beaky> I guess integers are monoids
17:28:07 <ab9rf> beaky: yes
17:28:21 <ab9rf> beaky: integers with addition and also integers with multiplication
17:28:30 <ab9rf> beaky: you need both a set _and_ an operation to talk about a monoid
17:28:36 <shachaf> Integers are a monoid, anyway.
17:28:50 <clahey> ab9rf: because if l is a left inverse and r is a right inverse, then l = l i= l a r = i r = r
17:29:00 <elliott> shachaf: at least two monoids
17:29:01 <ab9rf> clahey: yeah, i just did that proof in my head too :)
17:29:03 <elliott> !
17:29:25 <shachaf> elliott: Lots more than two.
17:29:31 <elliott> at least seven.
17:29:34 <ab9rf> heh
17:29:40 <beaky> how do typeclasses work?
17:29:48 <clahey> integers with addition are a group (and therefore a monoid)  Integers with multiplication are not a group, but are a monoid.
17:30:10 <clahey> integers are an infinite number of monoids.
17:30:11 <beaky> are they significant in functional programming? or are typclasses some haskell innovation?
17:30:17 * slack1256 never used the applicative interface of monad-transformers, didn't know what he was missing.
17:31:10 <clahey> For all k => (Z, \a b -> a + b - k) is a monoid with identity k.
17:31:50 <ab9rf> clahey: heh
17:33:01 <jmcarthur> monoids are just ways to build binary trees whose values are not alterable by rebalancing
17:33:51 <clahey> beaky: I'm not sure about my term usage here, but: Actually, one of the things that happens is because functions in typeclasses are only parameterized on the type of the function parameter.
17:33:55 <shachaf> jmcarthur: Also semigroups.
17:34:12 <jmcarthur> more generally, yes
17:34:27 <beaky> :t mempty
17:34:29 <lambdabot> Monoid a => a
17:34:30 <clahey> beaky: So even though the integers can be the set for an infinite number of monoids, Integer only has one definition for the typeclass Monoid.
17:34:36 <clahey> If it has any?
17:34:36 <jmcarthur> i thought about adding "possibly-empty" but opted to avoid being too wordy
17:34:41 <clahey> Oh, I remember now.
17:34:44 <clahey> It doesn't have any.
17:35:12 <cmccann> jmcarthur: it took me an embarrassingly long time to notice that binary tree rotations are just applications of the associativity identities
17:35:27 <clahey> But there are types, Sum and Product, which are defined as newtypes for Integers?
17:35:39 <clahey> And they have Monoid definitions.
17:35:51 <clahey> shachaf: Was that vaguely correct?
17:36:02 <AutoHaskellNoobi> @rules
17:36:02 <lambdabot> Unknown command, try @list
17:36:04 <AutoHaskellNoobi> !ules
17:36:04 <jmcarthur> clahey: Sum and Product are for any instance of Num, i believe
17:36:06 <AutoHaskellNoobi> !rules
17:36:26 <clahey> jmcarthur: Oh, they're functors (not Functors)?
17:37:06 <AutoHaskellNoobi> hi, i have a very noob haskell question if anyone is interested in helping?
17:37:10 <shachaf> I see no reason they couldn't be Functor instances.
17:37:13 <jmcarthur> they are type constructors and possibly should be Monads (or at least it would not be harmful if they were)
17:37:25 <cmccann> the best way to ask a question is to just ask it
17:37:32 <shachaf> cmccann: Innovative.
17:37:36 <cmccann> people will help if they want. they often do.
17:37:45 <clahey> shachaf: I just meant that I meant type constructors and not Functors.
17:37:55 <cmccann> shachaf: yes I am on the cutting edge of conversational technology here
17:38:03 <shachaf> clahey: "functor" with a lowercase f doesn't mean "type constructor"
17:38:29 <clahey> shachaf: "functors in Hask"?
17:38:32 <jmcarthur> clahey: "functor" actually subsumes "Functor"
17:38:40 <clahey> Oh, right.
17:38:42 <clahey> Of course it does.
17:38:43 <AutoHaskellNoobi> cmccann: thanks, i will throw away my question. i started learning haskell today and i am following learn haskell for greater good book. it has following example:
17:38:45 <AutoHaskellNoobi> boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
17:38:53 <jmcarthur> clahey: Functor is only endofunctors in Hask
17:38:53 <AutoHaskellNoobi> when i type this on ghci i get following:
17:39:05 <AutoHaskellNoobi> ghci> boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
17:39:05 <AutoHaskellNoobi> <interactive>:9:14: parse error on input `='
17:39:05 <AutoHaskellNoobi> ghci>
17:39:21 <AutoHaskellNoobi> cant figure out why...
17:39:23 <cmccann> use "let" in GHCi
17:39:26 <nooodl> add "let" before it
17:39:34 <AutoHaskellNoobi> ohh, thanks.
17:39:41 <shachaf> clahey: No, "functor" isn't really related to "type constructor".
17:40:13 <clahey> shachaf: A type constructor is a map in Hask, not a functor?
17:40:19 <clahey> Not necessarily a functor?
17:40:49 <AutoHaskellNoobi> one more question, is there auto complete in ghci? i tried tab, control space, etc... i could nto figure it out.
17:40:51 <shachaf> I guess? I mean, it does map types to other types.
17:40:55 <shachaf> I'm not sure what you're getting at.
17:41:00 <shachaf> AutoHaskellNoobi: Yes, Tab should work.
17:41:01 <clahey> shachaf: I don't either!
17:41:03 <jmcarthur> clahey: a type constructor is just something with kind * -> k
17:41:12 <cmccann> tab works for me
17:41:13 <jmcarthur> clahey: for any k (could be another type constructor)
17:41:19 <jmcarthur> aw man, i wasn't general enough
17:41:25 <shachaf> jmcarthur: How about k -> k'?
17:41:29 <jmcarthur> right
17:41:36 <AutoHaskellNoobi> hmmm, thanks, i am having problems with tab but thats ok.
17:41:42 <AutoHaskellNoobi> take care, thanks again for yourhelp.
17:41:42 <shachaf> I.e. a function!
17:41:45 <jmcarthur> a type constructor can also take other type constructors as arguments
17:42:00 <clahey> Words are hard.
17:42:04 <clahey> I'm going to go to a party.
17:42:05 <jmcarthur> yeah, i should have just left it at type-level function
17:42:10 <clahey> Maybe I'll write some code tonight.
17:42:34 <clahey> Probably not haskell unless I want to prep for codejam, which would actually be a pretty good idea.
17:42:40 <clahey> I'll talk to you guys later.
17:43:16 <Cale> beaky: type classes are an innovation which happened in Haskell, but aren't necessarily specific to it
17:43:21 <beaky> > let a = [True, False] in liftM2 (,) a a
17:43:23 <lambdabot>   [(True,True),(True,False),(False,True),(False,False)]
17:43:58 <cmccann> hm I think my gtk-based opengl context is working
17:44:13 <cmccann> who needs glut or sdl or that crap, pf
17:44:39 <beaky> > let p = [True, False] in do {a <- p; b <- p; return (a, b) }
17:44:41 <lambdabot>   [(True,True),(True,False),(False,True),(False,False)]
18:00:44 * hackagebot lambda-toolbox 1.0.1 - An application to work with the lambda calculus (for learning)  http://hackage.haskell.org/package/lambda-toolbox-1.0.1 (JulianFleischer)
18:01:07 <sven_> i'm confused by something very simple
18:02:18 <sven_> if liftA2 :: (a -> b -> c) -> f a -> f b -> f c, and id :: x -> x, then how do you (mechanically) do the substitution to find that (liftA2 id) :: (x -> c) -> f x -> f c
18:03:07 <sven_> the types make sense to me but the symbol manipulation rules are confusing me a bit
18:03:31 <shachaf> liftA2 :: (a -> b -> c) -> f a -> f b -> f c
18:03:34 <shachaf> id :: x -> x
18:03:45 <shachaf> Therefore (x -> x) = (a -> (b -> c))
18:03:50 <shachaf> Therefore x = a, x = b -> c
18:04:19 <shachaf> So liftA2 :: ((b -> c) -> (b -> c)) -> f (b -> c) -> f b -> f c
18:04:45 <DanBurton> @hoogle (Maybe a) -> (a -> m ()) -> m (Maybe a)
18:04:45 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
18:04:45 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
18:04:45 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
18:07:40 <DanBurton> @type let m >>=<< f = Data.Traversable.forM m (\a -> f a >> pure a) in (>>=<<)
18:07:42 <lambdabot> (Monad m, Applicative m, Traversable t) => t b -> (b -> m a) -> m (t b)
18:08:04 <sven_> schachaf: am I mistaken or is that liftA2 . id?
18:08:23 <sven_> shachaf: that one i understand better
18:08:44 <shachaf> No, that's liftA2 id
18:08:58 <circle> if you have map f (x:xs) = f x : map f xs, what does the colon character do?
18:08:59 <shachaf> liftA2 . id = liftA2
18:09:35 <geekosaur> both colons are doing pretty much the same thing: (de)constructing a list into (head:tail)
18:09:50 <sven_> shachaf: this is the type that ghci gives me: (liftA2 id) :: Applicative f => f (b -> c) -> f b -> f c
18:10:03 <sven_> shachaf: is that equivalent to what you wrote in a way that i'm not seeing?
18:10:05 <shachaf> sven_: That's the type that I gave you, too.
18:10:07 <shachaf> Er, right.
18:10:19 <shachaf> liftA2 id :: f (b -> c) -> f b -> f c
18:10:28 <shachaf> liftA2 :: ((b -> c) -> (b -> c)) -> f (b -> c) -> f b -> f c
18:10:40 <shachaf> id :: (b -> c) -> (b -> c) -- i.e. x -> x
18:10:52 <sven_> oh wait!
18:10:56 <sven_> now i get it
18:10:57 <sven_> sorry
18:11:18 <geekosaur> circle: do you understand how Haskell lists work? they're really cons lists: [1,2,3,4] is 1:2:3:4:[]
18:11:50 <sven_> you were showing me the type of liftA2 with id substituted in, but before liftA2 was applied to id (so if i remove everything before the first -> at the top level, i get the type ghci returns)
18:11:57 <circle> oh yeah true sorry
18:12:01 <shachaf> Yes.
18:12:10 <shachaf> All I did was unify it.
18:12:24 <shachaf> @ty liftA2 `asAppliedTo` id
18:12:26 <lambdabot> Applicative f => ((b -> c) -> b -> c) -> f (b -> c) -> f b -> f c
18:12:33 <sven_> shachaf: thanks. this was really helpful!
18:25:41 <xpika> whats the easiest way to putStrLn "hello world" 5 times?
18:25:57 <luite> replicateM 5
18:26:08 <monochrom> replicateM_ 5
18:26:16 <luite> oh good point about the _
18:26:59 <xpika> thankyou
18:27:37 <xpika> another question, whats the easiest way to time a function in ghci?
18:27:46 <fryguybob> :set +s ?
18:28:07 <tgeeky> xpika: that is the easiest. A more scientific way is to use criterion.
18:28:44 <tgeeky> s/scientific/statistical/
18:40:08 <lgas> Hi, everyone.  I'm getting "cabal: No test suites enabled. Did you remember to configure with '--enable-tests'?", when I run "cabal test" but I did in fact remember, and it built them, and if I run them from dist/build/test-... they work fine... what am I missing?
18:41:00 <shachaf> lgas: You run: cabal configure --enable-tests; cabal build; cabal test ?
18:41:13 <llumac> Hi all, I was wondering if I could get a little help with a problem. Basically I've created two functions, halve which takes a list of ints and gives the first half and second half back as a list, and mix - which takes two sorted lists of ints and sorts them into one list. The problem is to use them together recursively to sort an unsorted list.
18:41:53 <llumac> Any pointers would be much appreciated
18:42:37 <shachaf> llumac: Well, it might help to mention where you're having trouble.
18:43:02 <shachaf> (Isn't this the third mergesort we've had in the past few days?)
18:43:59 <lgas> shachaf: yes, I just ran exactly that and it ended with the message about "Did you remember ... --enable-tests"?
18:44:13 <shachaf> OK.
18:44:17 <shachaf> Then I don't know what's going on.
18:44:25 <shachaf> Maybe `cabal clean` and try again?
18:44:51 <llumac> Sure! Basically I understand that if the list is empty, just return the empty list. And if the list has multiple entries you want to recursively halve them until you get single element lists then mix them together to form a sorted list. Does that sound right?
18:45:18 <llumac> I'm rather rusty on the synatax
18:45:36 <shachaf> (Is this homework?)
18:45:50 <llumac> Yes. I'm not asking for a solution, just guidance
18:46:38 <shachaf> What class, out of curisoosity?
18:47:08 <llumac> Programming languages
18:47:14 <shachaf> I mean, where?
18:47:18 <lgas> shachaf: hmm, I swear tried clean before but after trying it again I got errors about missing dependencies at the configure step ... which seems like a strange combination of behaviors to me, but at least I'm on to the next problem now, thanks :)
18:47:28 <shachaf> Anyway, it sounds like you're describing a workable algorithm.
18:47:38 <shachaf> What's the trouble with implementing it?
18:48:05 <shachaf> If you're rusty on the syntax then maybe you should spend some more time on it and come back to this. :-)
18:48:43 <cmccann> llumac: you're not overlooking the fact that a 1-element list is always sorted, are you?
18:50:16 <monochrom> http://perl.plover.com/classes/OOPSLA/samples/slide061.html and onwards are pretty relevant
18:50:17 <cmccann> oh wait, you already mentioned that
18:50:40 <cmccann> llumac: it sounds like you pretty much have everything worked out?
18:52:47 <lgas> ok now I'm getting this http://pastie.org/7167981 which says I'm missing these libraries but if I try to install them it says I already have them....
18:53:16 <lgas> and I've been stung by --reinstall before so I know that way madness lies
18:53:36 <llumac> I think I'm close, maybe I just need to muscle it out. I think jsut voicing my problem has helped a lot. Thanls everyone, I'll give it another go and I'll let you know how I go
18:54:42 <monochrom> does "cabal configure" see the same package database as "cabal-dev" does?
18:54:54 <monochrom> I mean, likely no.
18:55:50 <monochrom> I mean, you call it "sandbox" because it is normally invisible
18:56:23 <lgas> ah
18:57:17 <lgas> Yeah, that should be cabal-dev configure, I just fat fingered that.  Usually I am running it out of a makefile instead of the command line which avoids that problem.  Thanks monochrom.
18:58:01 <lgas> oh but now I'm back to my original problem which is that it builds the tests and I can run them out of dist/ just fine but 'cabal test' still fails
18:59:28 <monochrom> do you think "cabal-dev test" works better?
19:00:13 <lgas> I am using 'cabal-dev test'
19:00:19 <lgas> I went back to the makefile this time to be sure
19:00:48 <monochrom> then I don't know
19:00:52 <lgas> this is the Makefile if it helps: https://github.com/lgastako/aldus/blob/master/Makefile
19:01:34 <lgas> and making the "full" target results in everything being built but then the "cabal-dev test" command to fail
19:01:38 <llumac> Huzzah! I cracked it! Thanks everyone. That merge sort link helped me so much.
19:02:51 <monochrom> haha
19:23:41 <sproingie> even with cabal-dev i get a lot of "this will break existing packages" refusal to install
19:30:31 <monochrom> because, at the end of the day, cabal-dev just calls cabal with more flags
19:31:08 <sproingie> ayep.  sandboxing really needs to be built in to cabal-install itself
19:40:31 <JoeyA> I wrote a package for wrapping a connection in an STM interface; anyone want to critique it?  http://joeyadams.github.com/hs-stm-connection/doc/Control-Concurrent-STM-Connection.html
19:43:35 <JoeyA> It works by doing the I/O in forked threads, using bounded channels to pass messages.
19:51:50 <xpika_> is there anyway to execute a script into ghci that exposes bindings that contain the results of IO?
19:53:01 <chenwl> cabal unpack http://well-typed.com/blog/aux/files/cloud-demos.tar.gz && cd distributed-process-demos-0.1.0.0 && cabal configure && cabal build
19:53:16 <chenwl> cabal: Package distributed-process-demos-0.1.0.0 can't be built on this system.
19:53:33 <chenwl> cabal install
19:53:39 <chenwl> cabal: The following packages are likely to be broken by the reinstalls: regex-posix-0.95.1 Use --force-reinstalls if you want to install anyway.
19:53:56 <chenwl> what's wrong?
19:54:14 <chenwl> I cannot build the demo from http://www.well-typed.com/blog/71
20:01:17 <CodeDmitry> Why so much ddos?
20:02:53 <parcs> JoeyA: neat. i think there should be an exception-safe 'withConnection' handler that opens and closes the for you
20:04:55 <JoeyA> parcs: Can't the caller do that with bracket?
20:05:11 <JoeyA> withConnection = bracket (new config backend) close
20:05:41 <JoeyA> err, withConnection config backend = bracket (new config backend) close
20:19:17 <parcs> yeah, never mind. since there are multiple ways to close a connection it's probably best to omit such a function
20:20:37 <JoeyA> parcs: actually, 'close' is the only way to close it completely (including freeing the underlying resource).  Unless you count GC.
20:21:14 <JoeyA> even if you call 'bye', you still need to call 'close'.
20:23:24 <JoeyA> I wonder if the connection should automatically close itself when there is no more data to send or receive (i.e. the user called 'bye', and ).
20:23:32 <JoeyA> 'recv' returned Nothing
20:27:54 <pharaun> JoeyA: this looks like its being treated like a queue of things to send
20:28:13 <pharaun> i wonder how hard it would be to rate-limit how fast you send things?
20:29:17 <JoeyA> pharaun: I didn't have that feature in mind, but you can do that by making backendRecv and backendSend do their own rate limiting.
20:29:37 <JoeyA> My application uses timeouts, but I didn't explicitly include support for those either.
20:29:49 <pharaun> JoeyA: sweet
20:30:13 <JoeyA> The issue with timeouts (this probably applies to rate limiting, too) is that it doesn't operate on the underlying byte sends.
20:30:14 <pharaun> yeah i can do that in the backend, looks like i can just have it block till its ready to send the next message and then it'll go fetch that
20:30:32 <JoeyA> You usually want the backend methods to parse and unparse messages.
20:30:54 <pharaun> my parsing is kinda big :)
20:31:06 <pharaun> but yeah i could see doing that
20:31:07 <JoeyA> If your message type is ByteString, calling recv over and over to read a really message will deadlock if you do it all in one transaction.
20:31:11 <JoeyA> really big message*
20:32:03 <JoeyA> My original plan was to just make send and recv operate on ByteString chunks, but then I realized that.
20:33:36 <pharaun> ah
20:34:11 <pharaun> hmm depending, it might work out better for my app to have the parsing being taken care in the backend
20:34:16 <pharaun> i'll have to play with this a little
20:34:37 <JoeyA> https://github.com/joeyadams/hs-stm-connection
20:34:51 <JoeyA> Let me know how it works out.
20:35:08 <pharaun> will do :) probably won't get to work on it right away but it looks like something i can make good use of :D
20:35:20 <pharaun> i am working on a network library api for a service
20:36:14 <JoeyA> You might consider implementing backend combinators (like rate limiting) with the io-streams package.
20:36:40 <pharaun> http://hackage.haskell.org/package/io-streams ?
20:36:43 <JoeyA> Yes
20:37:49 <JoeyA> Then turn a pair of io-streams into a Backend using io-streams read and write.
20:38:15 <JoeyA> Connection isn't itself an io-stream, though, since I didn't implement an unRecv (but I easily could).
20:38:40 <pharaun> since i'm not familiar with io-streams library yet, what's an unRecv?
20:38:47 <JoeyA> It puts back leftovers.
20:38:51 <pharaun> ah
20:39:14 <pharaun> so i can process what i can, then oh i still got some stuff that i can't do anything with yet, i can put it back till next time i loop over to process some more
20:39:25 <JoeyA> Right.
20:39:48 <pharaun> wfm, i've used the conduit packages before
20:39:54 <JoeyA> For example, if you're using the cereal package to serialize/unserialize binary-encoded messages, you can use runGetPartial to parse incrementally.
20:40:26 <JoeyA> When parsing finishes, it returns unused bytes, which you'll want to feed to the subsequent parse.
20:41:18 <JoeyA> pharaun: I haven't used io-streams myself yet.  It was released very recently.
20:42:02 <JoeyA> I recommended it because it works with plain IO types, so it's easy to turn a pair of streams into a Backend.
20:43:59 <pharaun> aha nice
20:44:14 <pharaun> yeah that's a bonus cos my current interface is just a rough wrap around the normal network api
20:44:29 <pharaun> so yeah this and the io-stream would be pretty easy to incorporate in
20:52:15 <slack1256> I found this in XMonad 'class Typeable a => Message a'
20:52:25 <slack1256> that's it
20:52:41 <JoeyA> slack1256: any instances?
20:53:17 <slack1256> no method, instances are 'Event, SomeMessage' etc
20:53:20 <shachaf> What is the problem?
20:53:22 <JoeyA> That makes sense.  It just requires that you explicitly say instance Message Foo, rather than automatically making all Typeable instances be messages.
20:53:36 <slack1256> but they just do 'instance Message Event'
20:53:38 <JoeyA> So you don't accidentally try to send an 'Int'.
20:53:55 <slack1256> oh
20:53:56 <JoeyA> or a Chan.  Or a function.
20:54:00 <slack1256> I see
20:54:19 <slack1256> This is the analogous of newtypes for classes
20:54:51 <slack1256> thanks JoeyA
21:35:28 <copumpkin> it'd be nice if haskell had a CleverMonad do notation, where CleverMonad takes maximal applicative subsets, tuples them up, and then makes a single bind
21:35:37 <copumpkin> or something like that :)
21:35:57 <copumpkin> so if I write do x <- foo; y <- bar; z <- bz; case x + y - z of _ -> ...
21:36:09 <copumpkin> it'd pile the x y z into one unit
21:37:16 <shachaf> This is even more extreme than your last proposal!
21:37:17 <elliott> it was pointed out that list comprehensions make pretty decent applicative notation
21:37:21 <elliott> sinec they already have the free "return"
21:37:29 <elliott> you just need to make sure the bindings don't mention each other
21:37:34 <shachaf> Pointed out by me, last time copumpkin was talking about all this.
21:37:56 <copumpkin> shachaf: which was that?
21:37:57 <shachaf> In fact the "zip comprehension" notation doesn't even allow (>>=)s.
21:38:32 <copumpkin> anyway, the monad laws mean that my transformation is safe
21:38:43 <copumpkin> and would allow much more interesting static analysis in some cases
21:38:46 <shachaf> copumpkin: http://www.haskell.org/pipermail/haskell-cafe/2011-September/095120.html
21:39:01 <shachaf> I agree that this proposal is interesting.
21:39:02 <copumpkin> oh I had already proposed that?
21:39:02 <elliott> the applicative not being a superclass of monad laws mean that it isn't safe :P
21:39:16 <copumpkin> man, I'm dumb
21:39:19 <djahandarie> Hahahaha
21:39:25 <shachaf> No, your last proposal was just about relaxing the whole thing to Applicative.
21:39:29 <copumpkin> oh okay
21:39:30 <shachaf> Not bundling things up and all that.
21:39:51 <elliott> f <$> x = [f v | v <- x]
21:40:35 <shachaf> I,I f <$> x <*> y = [f v w | v <- x | w <- y]
21:40:40 <shachaf> (Except not.)
21:41:36 <shachaf> copumpkin: This is reminiscent of arrow notation, of course.
21:41:49 <copumpkin> yeah but arrow notation sucks
21:41:53 <shachaf> Yes.
21:41:55 <copumpkin> so it's way better
21:41:57 <shachaf> As do arrows.
21:42:06 <elliott> shachaf: it would be f <$> x <*> y = [f v w | v <- x, w <- y]
21:42:19 <shachaf> elliott: No, the | version could be truly Applicative.
21:42:38 <shachaf> It doesn't allow | x <- y, z <- x
21:42:44 <copumpkin> oh, max bolingbroke
21:42:50 <elliott> shachaf: ?
21:42:51 <copumpkin> as he is wont to do, proposed what I did
21:42:52 <copumpkin> just now
21:42:53 <copumpkin> I think
21:42:58 <shachaf> Just now?
21:43:00 <elliott> shachaf: that would be inconsistent with the list Applicative
21:43:02 <shachaf> Where?
21:43:03 <copumpkin> http://www.haskell.org/pipermail/haskell-cafe/2011-September/095153.html
21:43:07 <copumpkin> no I mean what I suggested now
21:43:10 <copumpkin> is what he suggested back then
21:43:11 <shachaf> Ah.
21:43:15 <shachaf> elliott: I know, but the list applicative is bad.
21:43:22 <shachaf> So there you go.
21:44:02 <elliott> shachaf: you want the Applicative to be inconsistent with the Monad?
21:44:12 <shachaf> No, I want instances to magically be good.
21:44:23 <shachaf> 21:40 <shachaf> (Except not.)
21:44:53 <shachaf> The point is that the zip comprehension notation is consistent with what Applicative lets you do.
21:45:07 <shachaf> And Applicative *is* zippy in a sense.
21:45:22 <cmccann> -XDoWhatShachafWouldWant
21:45:50 <shachaf> cmccann: You have gained one rank in "making jokes that involve shachaf".
21:46:02 <sw2wolf> @instances Applicative
21:46:02 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
21:46:12 <cmccann> pretty sure I already have like all the ranks in that.
21:46:29 <shachaf> [Foo x y z | x <- char | y <- many whitespace | z <- char]
21:49:00 <elliott> shachaf: [MyRec{..} | field1 <- char | field2 <- char]
21:49:04 <elliott> too bad record puns are awful.
21:49:09 <shachaf> copumpkin: Hmm, maybe you can do without the tuple and just pass a partially-applied function directly.
21:49:11 <elliott> but they'd be good if we had lenses, or something.
21:49:15 <shachaf> Or a computation which will then be joined.
21:49:20 <copumpkin> that'd be nice
21:50:42 <shachaf> Maybe you could translate it in a pretty straightforward way with join.
21:51:06 <cmccann> yay my incredibly shitty drawing program works!!
21:51:08 <copumpkin> I think I see what you mean
21:51:51 <shachaf> Generate m (m a) and join it, and then simplify return + join
21:51:54 <shachaf> Or something.
21:52:12 <copumpkin> x <- foo; y <- bar; z <- baz; f x y z ===> (\f -> liftA3 f foo bar baz) (\x y z -> f x y z)
21:52:23 <copumpkin> with a join outside
21:52:41 <copumpkin> that could be pretty cute
22:05:10 <shachaf> copumpkin: You can use the monad laws for all sorts of things if you go far enough.
22:05:23 <copumpkin> yup
22:05:29 <shachaf> If you allow inlining things that use do notation.
22:05:40 <shachaf> What's the best you can do with something like this? do x <- a; y <- b; when y (print "y"); z <- c; when (x && z) (print "xz")
22:07:39 <shachaf> I guess this is only relevant when you have multiple <-s in a row.
22:07:56 <shachaf> Or when you have <- and return, liftAn-style, if you
22:07:59 <shachaf> 're doing that.
22:10:36 <shachaf> I guess the obvious translation with this scheme is join $ liftA2 (\x y -> when y (print "y") >> join (fmap (\z -> when (x && z) (print "xz")) c)) a b
22:22:45 <shachaf> copumpkin: I wonder whether you could do this with just rewrite rules.
22:22:51 <shachaf> Kind of silly but maybe you could express it.
22:23:19 <copumpkin> hmm, maybe!
22:23:29 <shachaf> In phases, (>>=)s to join+fmap, combine join (a <&> (\x -> b <&> (\y -> f x y))) to join (liftM2 (\f x y) a b)
22:23:42 <shachaf> Then maybe turn joins+fmaps back to (>>=)s for efficiency or something.
22:24:26 <shachaf> Even if the rewrite rule system can do it at all, it's a bit of a stretch.
22:24:35 <copumpkin> yeah
22:25:30 <shachaf> Er, that's (\x y -> f x y)
22:28:45 <sw2wolf> @type liftM2
22:28:47 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
22:53:04 <napping> how does lens work with optional positions?
22:53:22 <edwardk> you mean fields that are only present in some contructors?
22:53:44 <napping> yeah, something like that. Prism seems to work only with isomorphisms
22:54:12 <napping> or not exactly isomorphisms, but things where there is no other state
22:54:24 <edwardk> data Foo = Foo { _bar :: Int } | Baz { _bar :: Int, _quaffle :: Int } | Quux { _quaffle :: Int }; makeLenses ''Foo
22:54:45 <edwardk> that will generate two 'traversals' instead of lenses, because in some cases there is no target for the traversal to visit
22:55:27 <edwardk> bar :: Traversal' Foo Int -- and quaffle :: Traversal' Foo Int
22:56:38 <edwardk> if you look at the big hierarchy in http://hackage.haskell.org/package/lens you'll see the common superclass of both lens and prism is 'traversal'
22:57:24 <shachaf> I wonder whether there is a law hierarchy or something to go with the lens types hierarchy.
22:57:38 <shachaf> Some metalaws that would let you figure out the lens and prism laws and so on.
22:58:47 <edwardk> the generated code for, say, quaffle, would look like:
22:59:05 <edwardk> quaffle _ (Foo a) = pure (Foo a); quaffle f (Quux a) = Quux <$> f a; quaffle f (Baz i q) = Baz i <$> f q;
23:02:36 <napping> what works for reading the field?
23:02:57 <napping> view looks close, if I could stick in a First
23:03:14 <shachaf> preview
23:03:34 <shachaf> (preview uses First.)
23:04:22 <elliott> aka (^?)
23:04:50 <shachaf> firstOf, on the other hand, does not use First.
23:05:39 <edwardk> preview
23:05:54 <edwardk> equivalently view (pre quaffle)
23:06:03 <edwardk> preview = view . pre (at least morally)
23:06:16 <sw2wolf> :t (.)
23:06:17 <lambdabot> (b -> c) -> (a -> b) -> a -> c
23:06:59 <edwardk> > Left 4 ^? _Right
23:07:01 <lambdabot>   Nothing
23:07:05 <edwardk> > Left 4 ^? _Left
23:07:07 <lambdabot>   Just 4
23:07:16 <edwardk> > preview _Left (Left 4)
23:07:18 <lambdabot>   Just 4
23:07:24 <edwardk> > preview traverse [1..10]
23:07:26 <lambdabot>   Just 1
23:07:29 <shachaf> @ty (^? _Just)
23:07:31 <lambdabot> Maybe a -> Maybe a
23:08:02 <shachaf> edwardk: Can withMonoid move from examples/ into something actually exported by reflection?
23:08:10 <edwardk> =/
23:08:20 <edwardk> i'm not entirely happy with it as an api choice
23:08:49 <edwardk> i realize this makes your foldBy, etc stuff into code duplication
23:09:27 * edwardk decides to go get some sleep.
23:09:31 <shachaf> Well, presumably I'd define them in terms of withMonoid.
23:09:42 <shachaf> I was thinking of just exporting that as well.
23:09:51 <shachaf> But then I thought reflection would make more sense.
23:09:55 <edwardk> well, you can duplicate the code from withMonoid in an Internal module somewhere if you want
23:10:01 <edwardk> (well, in lens
23:10:07 <shachaf> Right.
23:10:22 <edwardk> in reflection i'd be more leery, since its so darn minimal right now i like to keep it that way
23:10:49 <shachaf> Well, it would be a separate module.
23:10:54 <elliott> so minimal you added another class :(
23:10:58 <shachaf> It doesn't incur any dependencies or anything.
23:12:05 <edwardk> elliott: i have writers remorse about adding it already ;)
23:12:20 <edwardk> i'll let you convince me it was a bad idea sometime when i've slept
23:12:24 <edwardk> ;)
23:13:26 <elliott> it's ok, i'll just spread the word you added something oleg wouldn't have dreamt of implementing :P
23:13:46 <edwardk> the main problem i have with the with monoid thing is it doesn't generalize well. there is the 'nicer in some sense' version with the constraints machinery, etc. but its still a hack =P
23:14:09 <edwardk> heh, he already cringed when i showed him the fast path
23:14:30 <shachaf> I,I achievement unlocked
23:14:58 <sw2wolf> @where hugs
23:14:58 <lambdabot> http://haskell.org/hugs
23:15:30 <elliott> hmm, how doesn't it generalise?
23:16:08 <mm_freak> wow, i didn't know there was such a great xournal clone in haskell
23:17:42 <tgeeky> mm_freak: thank the guy named 'wavewave'
23:18:09 <shachaf> copumpkin: I was going to reply to Bolingbroke's post about it but it was years ago.
23:18:17 <copumpkin> nothing wrong with that
23:18:18 <shachaf> At any rate this isn't too feasible to do right now.
23:18:26 <copumpkin> it might be in idris :)
23:18:41 <mm_freak> it seems like all seriously maintained haskell clone projects quickly overtake the original project they wanted to clone, at least in key aspects…  hledger, hoodle, hakyll, …
23:19:27 <luite> :)
23:19:44 <luite> i think he also wants to make a web viewer for hoodle, he's contributed some ghcjs code
23:19:55 <mm_freak> great
23:21:03 * hackagebot bytes 0.5 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.5 (EdwardKmett)
23:21:25 <mm_freak> some day haskell will be the new PHP and idris people trying to convince the mainstream haskell world that haskell is seriously broken =)
23:22:01 <shachaf> I think the mainstream Haskell world agrees that Haskell is broken.
23:22:18 <shachaf> By "mainstream Haskell world" I mean people who spend all day complaining on IRC.
23:22:22 <edwardk> wavewave has showed up at hac phi for the last couple of years. good guy
23:22:38 <shachaf> wavewave was at HacBoston too.
23:23:02 <luite> btw can i interest someone here in writing a patch for Cabal/cabal-install that lets me supply extra extensions of files that should be installed alongside the .hi files (same source/dest dirs)? for ghcjs i'd want to add [".js_hi", ".js", ".ji"]
23:23:02 <mm_freak> hehe
23:29:20 <luite> meh, no response :(  I'd offer haskell stickers if i hadn't given them all away
23:29:52 <tgeeky> luite: rename your file types to .svg, .png, and use diagrams-haddock
23:30:38 <kwos> Hi all :)
23:31:04 * hackagebot bytes 0.5.1 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.5.1 (EdwardKmett)
23:31:04 <luite> tgeeky: doesn't that require them to be listed in data-files or something?
23:31:54 <edwardk> tgeeky: that just gets you more stuff in the doc dir
23:32:15 <tgeeky> I just wanted to demonstrate that "no response" can be better than a bad response :o
23:32:19 <tgeeky> I didn't think it was magic
23:32:30 <kwos> is there some way to get list of record field names? Say derive from some class C and then have a method fieldNames :: C a => a -> [String]?
23:32:33 <luite> .. or doc dir :) the Cabal lib seems to be rather picky about the files it wants to copy
23:33:54 <luite> and i guess this should be fixed before 7.8.1 is released otherwise the ghcjs experience will be horrible
23:34:23 <dmwit> kwos: Are you double-plus sure that's what you want?
23:34:26 <edwardk> luite: hrmm. do you need those files, or could you say, cheat and tell ar to add them to the big archive file its building?
23:34:51 <wavewave> hi
23:34:51 <edwardk> luite: then when cabal moves the '.a' file it has your extra crap in it along for the ride
23:34:59 <luite> edwardk: oh i cheat already by letting ghcjs hash the .hi file and copy the other ones in place from a cache directory the next time it needs them
23:35:06 <kwos> dmwit: why wouldn't I want that? What I'm trying to do is to have a nice way of printing [SomeRecord] as a "table" on stdout
23:35:13 <dmwit> wavewave: Somebody was just complimenting your xournal clone. =)
23:35:26 <kwos> dmwit: I'd rather avoid hardcoding column names, that's why I somehow want to get hold of them using some sort of generic mechanism
23:35:42 <edwardk> luite: just thinking outloud re the .a file, not sure how viable the option would be, but it would just carry along the files for the ride
23:35:56 * dmwit nods agreeably towards kwos
23:36:01 <dmwit> kwos: Look into Template Haskell, then.
23:36:03 <wavewave> dmwit: oh? :-)
23:36:26 <kwos> dmwit: yeah, I can definitely do that, but would rather avoid it
23:36:48 <wavewave> dmwit: hoodle is not xournal-clone any more ;-)
23:37:00 <kwos> dmwit: ideally I'd like to just have deriving (Tabular)
23:37:01 <luite> edwardk: i'm not sure i can do that, i think the ar command is executed by cabal-install after the compiler, so i'm not sure if i have a chance to modify the .ar file (unless i make a wrapper for ar)
23:37:32 <luite> i've done the ar wrapping thing for yesod devel, but i'd rather not :)
23:37:34 <edwardk> wonder if the post build hook gets in at a good enough time that its after that but before it gets installed
23:37:49 <napping> edwardk: ^? , ^.. and .~ with traversals were enough. Maybe view or ^? should be on the diagram
23:38:17 <edwardk> napping: view is. check Fold
23:38:17 <luite> edwardk: does cabal have a way to have global post build hooks, that you run for all packages?
23:38:23 <edwardk> and Getter
23:38:31 <edwardk> luite: sadly no
23:38:35 <dmwit> wavewave: =)
23:39:20 <luite> most packages should install with ghcjs unmodified, you may need to add a .js reimplementation of the cbits, using the ccall emulation ffi
23:39:26 <edwardk> napping: if you want to open an issue to add (^?) to the diagram throw one on github.com/ekmett/lens/issues i'll try to remember next time i tweak it
23:39:33 <wavewave> dmwit: with xmonad-like scriptablilty. it will be like emacs of note-taking program.
23:40:23 <napping> oh, view is on there but I didn't realize the m could be a function type
23:42:04 <elliott> the view in the diagram should probably be specialised
23:42:08 <edwardk> napping: yeah thats the subject of about 10 fake signatures in the docs, just not in the quick reference sheet
23:42:08 <elliott> maybe the view in the package too...
23:42:14 <edwardk> =P
23:42:16 <luite> wavewave: i'm just finishing some ffi improvements for the ghcjs new code generator. do you still want canvas bindings, or have you finished som[D[D[D[D[De already?
23:42:20 * elliott has seen it cause inference issues :(
23:42:33 <luite> hm my terminal is borky
23:43:45 <wavewave> luite: great! in fact, I had some problem in installing ghcjs a few days ago... so didn't go further yet.
23:43:52 <edwardk> i've seen one rather contrived case that it caused a problem with iirc
23:44:11 <edwardk> that said, i'm disinclined to change it
23:44:17 <luite> wavewave: oh that's kind of expected, the trampoline (master) branch is a bit neglected, the new one can probably take over in not too much time
23:44:57 <shachaf> hi wavewave
23:45:06 <wavewave> shachaf: hi!
23:45:31 <luite> wavewave: there are some things left, mainly getting the standalone compiler working well enough, which means hacking in some cabal support, improving the ghcjs-pkg and ghcjs-cabal wrappers, and the installation procedure
23:45:43 <shachaf> Are you coming to BayHac in May?
23:46:16 <wavewave> luite: I see. anyway i am watching the project now, so soon I will try it again.
23:46:49 <wavewave> shachaf: I am thinking about it seriously now.
23:47:54 <wavewave> shachaf: visiting California is so good..
23:49:05 <luite> wavewave: https://github.com/ghcjs/ghcjs-base/blob/master/GHCJS/Foreign.hs / https://github.com/ghcjs/ghcjs/blob/gen2-64-alth/test/ffi/marshalString.hs   <- this is how foreign imports work now
23:49:05 <shachaf> Maybe copumpkin wants to come too.
23:49:32 <luite> (JSC should also be supported, if you want generated bindings and cross native/web things)
23:50:23 <wavewave> luite: great! looks cool
23:50:39 <napping> edwardk: I'd suggest using the fake signature with (s ->), considering you're already using fake signatures in the diagram
23:50:51 <wavewave> luite: are you in Europe btw?
23:51:11 <luite> yes
23:51:13 <luite> netherlands
23:51:43 <edwardk> napping: i'm willing to consider it. then i get the other side of the questions of how do i read from the environment in a monad transformer stack ;)
23:51:44 <wavewave> I see.
23:52:22 <wavewave> I am moving to Europe this fall.
23:52:29 <napping> edwardk: considering you are already using fake signatures for things, one sentance before the diagram saying you use simplified signatures wouldn't be amiss
23:52:33 <luite> wavewave: ah, where?
23:52:44 <wavewave> cern, switzerland
23:52:52 <edwardk> sounds good. add it to the issue =)
23:52:52 <luite> oh cool
23:54:11 <luite> and i'll be jealous that you're much closer to the mountains than me :p
23:54:35 <wavewave> shachaf: I feel that I now really want to join in BayHac.. need to persuade my wife now. ;-)
23:55:09 <edwardk> wavewave: no more hac phi for you?
23:55:41 <wavewave> edwardk: hacphi will be in July this year?
23:55:47 <edwardk> think so
23:56:12 <shachaf> When's the Boston one?
23:56:14 <wavewave> edwardk: I love to go there again.  still need to decide..
23:56:42 <dmwit> I think earlier this year -- early June.
23:56:50 <dmwit> This is probably something I should know.
23:57:04 <edwardk> shachaf: good question. ed yang moved to the wrong coast, so we didn't wind up getting the space arranged this year. i may follow up with akamai and see if we can do something later in the year though rather than in the dead of january
23:57:48 <edwardk> the trick is finding a time when it doesn't collide with icfp, etc.
23:58:09 <edwardk> maybe if we can figure out the icfp schedule and all the workshops it'd be possible to slot it in before or after
23:58:56 <napping> edwardk: you've got an issue
23:59:32 <edwardk> being right before popl was a good fit for us last time, because folks like edwin brady were able to fly in
23:59:42 <edwardk> so many repeating that with icfp would be a good idea
23:59:45 <edwardk> er maybe
