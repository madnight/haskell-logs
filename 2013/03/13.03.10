00:24:06 * hackagebot udbus-model 0.2.1 - Model API for udbus introspection and definitions  http://hackage.haskell.org/package/udbus-model-0.2.1 (VincentHanquez)
00:34:06 * hackagebot regex-deriv 0.0.3 - Replaces/Enhances Text.Regex. Implementing regular expression matching using Bzozoski's Deriviative  http://hackage.haskell.org/package/regex-deriv-0.0.3 (KennyLu)
00:35:49 <Ericson2314> Using flexible instances I defined
00:36:15 <Ericson2314> instance Binary [myType1 myType2]
00:36:30 <Ericson2314> I keep on needing to also enable overlapping instances because of
00:36:49 <Ericson2314> instance Binary a => Binary [a]
00:37:29 <dmwit> Perhaps you would like a newtype wrapper around your list.
00:37:47 <Ericson2314> yet instance mytype _ is not defined
00:37:52 <dmwit> newtype NotYetABinaryInstance a = NotYetABinaryInstance [a]
00:37:53 <samm> can you somehow define func Foo in one file and func Bar in another?
00:38:11 <dmwit> instance Binary a => Binary (NotYetABinaryInstance a)
00:38:19 <Ericson2314> I can't do the newtype because of the fancy polymorphism and existential stuff I am doing
00:38:29 <dmwit> samm: Sure, though functions have to start with a lower-case letter.
00:39:22 <Ericson2314> I checked with :i Binary and GHC did not list any instances for (mytype _) either
00:39:28 <Ericson2314> there is blatantly no overlap
00:39:35 <samm> I meant can you have func Foo = ... definition in one file and func Bar = ... in anothet
00:39:44 <samm> another
00:39:56 <Ericson2314> is this a pitfall in the implementation of flexible instances?
00:40:00 <dmwit> Ericson2314: There is an overlap. During instance resolution, an instance is chosen looking only at the instance head; instance contexts are only checked *after* a head is chosen.
00:40:02 <Ericson2314> samm: you want imports
00:40:23 <dmwit> Ericson2314: So instance Binary a => Binary [a] matches all lists, whether or not there is an instance of Binary for the contained type.
00:40:34 <samm> Ericson2314: did you see what I did? it is the same function
00:40:44 <Ericson2314> head meaning outermost type?
00:40:47 <dmwit> samm: Ah, no, you can't do that.
00:40:50 <Ericson2314> samm, no
00:40:56 <dmwit> samm: All clauses of a function definition must be together.
00:41:17 <dmwit> samm: I don't think there's a really deep reason for this, though there's a pretty good shallow one: that would be well confusing!
00:41:24 <Ericson2314> samm: multiple definitions like that are just sugar for a case _ of
00:41:33 <dmwit> Ericson2314: No, head meaning "stuff after the =>".
00:41:44 <dmwit> Ericson2314: And context meaning "stuff before the =>".
00:41:47 <Ericson2314> oh ok
00:44:06 <Ericson2314> dmwit: is there any way to manually specify what context you want?
00:45:22 <dmwit> Not really. You might want to look into IncoherentInstances, but not if this is a program you expect to ever use.
00:45:41 <dmwit> IncoherentInstances is more for fun than anything, I think. (Not all experiments work out, you see.)
00:45:55 <Ericson2314> aha
00:46:01 <Ericson2314> yeah it looks quite dangerous
00:46:46 <Ericson2314> it's possible also that this new cause were the overlapp is still not resolved is because some of the dispatch is dynamic as enabled with rankNTypes/existantialQuantification
00:47:12 <edwardk> IncoherentInstances are a great way to get me to never even look at a package
00:47:46 <dmwit> Ericson2314: I would be interested to hear a bit more detail about "I can't do the newtype because of the fancy polymorphism and existential stuff I am doing".
00:47:49 <ZFox> Mind going blank... How should you do something like this? data TokenInt = TokenInt Integer, newtype TokenInt = TokenInt Integer and have it the instances for to and from integer?
00:47:51 <dmwit> (I am a bit skeptical.)
00:47:57 * lispy reuploads all his packages with IncoherentInstances
00:47:57 * ZFox thinks newtype driving something ..
00:48:30 * mgsloan thinks standalone deriving would work then ..
00:48:32 <dmwit> ZFox: You just want conversion functions to and from Integer, or what does "instances" mean?
00:48:34 <edwardk> lispy suddenly vanished from my sight. what happened?
00:48:54 <lispy> edwardk: :)
00:49:15 <edwardk> Ericson2314: if you are doing 'funny existential things' then it is almost assured that your crazy instance wouldn't fire anyways
00:49:16 <lispy> I'm following the ulf mixfix parser paper and I stubbornly wanted to use happy...
00:49:33 <Ericson2314> I'll link source in a second
00:49:35 <ZFox> dmwit: deriving something?
00:49:35 <edwardk> lispy: now you have 3 problems
00:49:51 <dmwit> ZFox: Are you *sure* you want an instance? It sounds to me like you just want two functions.
00:49:52 <lispy> It's harder than I thought to use happy even with the Monadic api (using it to pass along the precedence graph)
00:50:11 <dmwit> Although my psychic powers have been wrong before.
00:50:50 <lispy> edwardk: I think I'm going to cave in and try it with parsec
00:51:04 <lispy> Perhaps if I get a working version I can tweak it and turn it into a happy parser
00:51:12 <ZFox> dmwit: Well.. I could just simply name tokenIntToInteger (TokenInt a) = a
00:51:19 * dmwit puts his tongue in his cheek and says: "Just start with Agda's parser and cut out the bits you don't like."
00:51:31 <edwardk> clearly if you're going all the way to parsec, trifecta is only one step farther ;)
00:51:39 <kallisti1> anyone familiar with the plugins library?
00:52:02 <ZFox> I already have a show instance which converts the integer into a base 62 16-byte string
00:52:06 <dmwit> ZFox: Right. The way you say it says you have some reservations. What are your reservations? What's bad about that?
00:52:18 <lispy> edwardk: the paper does it with an applicative parsing model
00:52:31 <lispy> edwardk: hence me reaching for parsec. What is trifecta based on?
00:52:38 <edwardk> dmwit: the problem with saying things with your tongue in your cheek is that while you know what you are saying, other people have a hard time making it out
00:52:38 <edwardk> unless you are speaking in a donald duck voice.
00:52:52 <edwardk> trifecta is basically parsec with much nicer error messages
00:52:53 <ZFox> dmwit: In short, can I get TokenInt to match Integer in a pattern?
00:53:11 <ZFox> I.e the type is just an alias with a single instance for show
00:53:19 <elliott> edwardk: what if you are donald duck?
00:53:45 <dmwit> "juth thtar wif a good parther and cuth off the bith o loan ithe"
00:53:48 <cmears> Mortchek, the cause of your Parsec problem earlier was the dreaded monomorphism restriction...
00:53:50 <mgsloan> edwardk: I've gotta admit, the main trifecta parsing code is probably some of the most obscure haskell I've seen
00:54:08 <lispy> dmwit: heh. Yeah, in some ways that might be easier.
00:54:13 <dmwit> ZFox: No, "newtype" and "data" make new types.
00:54:21 <mgsloan> edwardk: Don't get me wrong, trifecta is awesome, but wow
00:54:24 <Ericson2314> https://github.com/Ericson2314/Codec.Archive.CnCMix
00:54:34 <Ericson2314> There it is
00:54:57 <Ericson2314> sorry this  branch : https://github.com/Ericson2314/Codec.Archive.CnCMix/tree/existential_types to be be exact
00:55:01 <ZFox> dmwit: Yea I know. hence asking how to get a toInteger fromInteger fromIntegral toIntegral or whatever I could have as an instance
00:55:10 <mgsloan> edwardk: Did you rewrite Trifecta? There's like 10% of the number of modules there used to be.  Awesome!!
00:55:20 <edwardk> yeah i did
00:55:24 <edwardk> its missing some of the functionality
00:55:25 <lispy> the versioning goes 0.53 -> 1.0
00:55:27 <edwardk> but its a lot tighter
00:55:41 <mgsloan> edwardk++  this is great
00:55:45 <dmwit> ZFox: For fromInteger you can derive the Num typeclass.
00:55:49 <ZFox> I'd expect either deriving something or instance TokenInt something
00:55:50 <dmwit> :t fromIntegral
00:55:50 <arkeet> @karma edwardk
00:55:50 <lambdabot> edwardk has a karma of 26
00:55:51 <edwardk> its also based on 'parsers'
00:55:52 <lambdabot> (Integral a, Num b) => a -> b
00:55:53 <edwardk> @hackage parsers
00:55:53 <lambdabot> http://hackage.haskell.org/package/parsers
00:56:04 <dmwit> :t toInteger
00:56:06 <lambdabot> Integral a => a -> Integer
00:56:21 <dmwit> ZFox: Presumably for toInteger you could derive the Integral class.
00:56:29 <edwardk> which is probably the most generic library name ever
00:56:29 <kallisti1> ZFox: use the NewtypeDeriving extension, and then you can automatically derive instances for your newtype as long as its wrapped type has that instance
00:56:54 * lispy uploads "package" as a library
00:56:57 <edwardk> and one for which at least 2 users have given me crap about, as it doesn't contain any actual 'instances' just stuff for using them
00:57:07 <dmwit> lispy: bonus points if it provides only an executable
00:57:08 <lispy> the package package uses only IncoherentInstances and nothing else
00:57:17 <ZFox>       `Num' is not a derivable class
00:57:29 <ZFox> kallisti1: Did you mean XGeneralizedNewtypeDeriving ?
00:57:30 <Ericson2314> the problem is Main.hs
00:57:30 * lispy senses that it is bed time and uploads himself to bed
00:57:32 <edwardk> ZFox:  {-# LANGUAGE GeneralizedNewtypeDeriving #-}
00:57:47 <lispy> THIS PARSER WILL HAVE TO WAIT
00:57:55 <kallisti1> ZFox: that's the one
00:58:12 <arkeet> X isn't part of the extension name.
00:58:39 <ZFox> yay
00:58:51 <ZFox> Thanks dmwit kallisti1 edwardk ^_^
01:00:01 <kallisti1> do I need to specify an include path for System.Plugins.Load.load or will it automatically use system defaults
01:00:06 <ZFox> Anyone know any good vim one liners to sort everything in (a,b,c) ?
01:00:43 <dmwit> :'a,'b!sort
01:00:58 <dmwit> sorts the lines between mark a and mark b, inclusive
01:01:47 <dmwit> or hit V, highlight some lines, then :!sort and it will insert the range for you
01:01:58 <ZFox> no need for ! btw
01:02:33 <ZFox> dmwit: Also not what I'm asking for..
01:02:41 <Ericson2314> are you guys willing to look at the source?
01:02:47 <dmwit> Oh, yes, vim has all kinds of built-in things to pamper the poor Windows fools that don't have a good set of command line tools available.
01:02:56 <ZFox> Say you have import A.B.C (a, c, b, d, z, t)
01:03:03 <ZFox> To order the () section
01:03:10 <dmwit> ZFox: put them on separate lines, then... ;-)
01:03:21 <ZFox> dmwit: That's what I do currently ;)
01:03:49 <ZFox> well :s/,/,\r/g
01:03:50 <arkeet> make a command to split it into several lines, then sort, then put back together?
01:03:53 <arkeet> :d
01:03:57 <ZFox> Yea
01:04:10 <samm> typeOf foo == typeOf (undefined :: SomeType) <- is there a shorter way of writing this?
01:04:13 <ZFox> arkeet: That's what I was thinking, but curious to if anyone had done this already?
01:04:18 * ZFox would expect so
01:04:33 <dmwit> samm: Perhaps you'd like to use cast or whatever it's called.
01:04:53 <Ralith> samm: what are you using typeOf for?
01:05:00 <samm> dmwit: I am trying to see what the type is before casting
01:05:08 <dmwit> samm: Why?
01:05:31 <samm> it could be one of several types
01:05:35 <dmwit> So?
01:06:19 <arkeet> http://stackoverflow.com/questions/1327978/sorting-words-not-lines-in-vim
01:06:37 <arkeet> this could be adapted.
01:07:08 <samm> so I wanted to check if it type1, if so cast it to type1, then try the same with other types. I dont see any other way of doing it
01:07:13 <kallisti1> samm: you can just use multiple casts in order to test for each type
01:07:19 <dmwit> samm: Just cast to the various types.
01:07:21 <samm> oh?
01:07:23 <kallisti1> the cast automatically checks for you
01:07:26 <kallisti1> that's what it does.
01:09:56 <samm> I am not quite sure how that would look. I am doing this right now: func x | typeOf x == typeOf (undefined :: Type1) = ....  typeOf x  == typeOf (...) = ....
01:10:46 <dmwit> func (cast -> Just v) = ...; func (cast -> Just v) = ...
01:11:02 <dmwit> where each "..." fixes the type of v
01:11:10 <dmwit> or you can fix the type of v in the pattern, if you like that better
01:11:21 <samm> ah nice
01:11:31 <ZFox> arkeet: (Integral, Enum, Eq) Num, Ord, Real, deriving
01:11:35 <ZFox> from deriving (Integral, Num, Real, Enum, Ord, Eq)
01:11:36 <ZFox> xD
01:11:42 <arkeet> do it better.
01:11:50 <arkeet> :D
01:12:02 <ZFox> XD
01:12:03 <kallisti1> samm: here's a version that doesn't use view patterns: case (cast x, cast x, cast x) of (Just x, _. _) -> ...; (_, Just x, _) -> ...; (_, _, Just x) -> ...
01:12:07 <arkeet> I did say you'd have to modify it.
01:12:41 <arkeet> that's gross
01:12:51 <arkeet> if you really want to avoid view patterns, you could use pattern guards
01:13:13 <ZFox> Ughh
01:13:36 <kennyd> how would you do this? "or you can fix the type of v in the pattern"
01:13:44 <arkeet> write (v :: blah)
01:14:23 <Taneb> I wish you could say deriving (Storable)
01:14:25 <arkeet> f x | Just v <- cast x = ... | ...
01:14:30 <Taneb> For Product types
01:16:15 <dmwit> kennyd: func (cast -> Just (v :: Foo)), I would guess
01:16:18 <dmwit> haven't tested it though
01:16:23 <arkeet> hmm
01:16:28 <arkeet> can you even do that in a pattern?
01:16:34 <dmwit> one way to find out!
01:16:44 <kallisti1> arkeet: does your code not force the type to be inferred?
01:16:51 <arkeet> ??
01:17:12 <arkeet> well yes, you still need to fix the type of v somewhere
01:17:16 <dmwit> arkeet: With enough extensions, yes.
01:17:23 <arkeet> ah yeah
01:17:26 <kallisti1> case cast v of Just str -> putStrLn str; Nothing -> return ()
01:17:31 <dmwit> ScopedTypeVariables, to be specific
01:17:32 <kallisti1> arkeet: no explicit signature needed here
01:17:46 <arkeet> kallisti1: I never said you needed one.
01:19:50 <xpika> does anyone know of any software that can place type definitions on top of my functions?
01:20:29 <kallisti1> xpika: emacs haskell-mode has C-c C-t
01:20:39 <kallisti1> "insert a type annotation, for symbol at point, on the line above"
01:35:51 <edwardk> xpika: just compile with -Wall and you get the signatures for the missing ones as part of the output of compiling
01:36:38 <Ericson2314> hlint can help too
01:37:07 <Ericson2314> or at least when I do :hlint in ghci I guess it does -Wall too
01:37:16 <jbu> Hi all ... can someone explain the code after the "|" in the code: class (Monad m) => MonadState s m | m -> s where ...
01:37:50 <Ericson2314> it's a functional dependancy
01:38:01 <Ericson2314> a GHC extension
01:39:23 <jbu> Ericson2314: were u responding to my question?
01:39:27 <Ericson2314> yes
01:39:33 <Ericson2314> sorry I didn't say so
01:39:38 <jbu> ive never heard that term, but i'll look it up
01:39:38 <jbu> thx
01:39:52 <Ericson2314> I don't know much about it, but I heard it and seen the docs if not read them
01:45:20 <hiptobecubic> This is a very simple program tinkering with the command line. It "works" but it's possible to type two letters in rapid succession and have one sneak through without being processed. Is this just happening because it's already in the loop body and therefore can't capture it? http://vpaste.net/alWL2
01:48:02 <Taneb> Okay, I want an m (String -> String) for some m
01:48:13 <samm> can you do this without a lamda? (\(AnyFoo foo) -> func (casterr o))
01:48:45 <Taneb> Not in general, no
01:48:45 <samm> should have bern casterr foo
01:49:04 <Taneb> But maybe something like func . casterr . runAnyFoo
03:09:08 * hackagebot hakyll 4.2.1.2 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.2.1.2 (JasperVanDerJeugt)
03:19:44 <`nand`> func . casterr. (^?!_AnyFoo) -- because really, when would you not have a lens?
03:45:04 <piezoid> hi, I'm still stuck in the specification of a DSL for composable agents (in event-driven simulation context)
03:45:30 <piezoid> those agents make computations mutating their internal state but, depending on configuration variables.
03:46:06 <`nand`> computations mutating internal state -> automaton arrows
03:46:18 <piezoid> So I use a monadic style for the computation
03:46:21 <piezoid> but the configuration depedency is more like coeffect, right ?
03:48:41 <piezoid> `nand` thanks I will read on that
03:48:58 <`nand`> newtype Auto a b = Auto (a -> (b, Auto a b))
03:49:19 <twomashi> anyone know how to lazily convert [m a] into m [a]?
03:49:28 <`nand`> not in general
03:49:35 <`nand`> twomashi: some monads ‘m’ can't be lazy by design
03:49:38 <`nand`> eg [Just a]
03:49:40 <twomashi> <- infinite monadic sequence woes
03:49:52 <`nand`> if there's a Nothing; anywhere down the line (be it in the trillionth position), the result is Nothing
03:49:55 <twomashi> the author of the library im using suggests using Conduit
03:50:16 <twomashi> `nand`: yes, i read that
03:50:29 <`nand`> are you trying to do lazy IO?
03:50:57 <twomashi> yes, well consuming an iterator from a database.
03:51:19 <twomashi> MonadResource m => Iterator -> m [ByteString]
03:51:25 <twomashi> not lazy
03:51:33 <`nand`> there's technically a way to do it for IO, but it's ugly
03:51:54 <twomashi> this isnt IO tho… its m (Maybe a)
03:52:10 <twomashi> dont know why Conduit is a magic solution?
03:52:23 <skp> hi
03:53:06 <`nand`> I don't know the design of conduit in particular but the approach of iteratees is being able to define and compose ‘streams’ of data that are internally only processed out one chunk at a time
03:53:27 <`nand`> eg. imagine reading a single 1k chunk of bytes, processing that; then reading the next 1k chunk when the program needs more data
03:54:03 <twomashi> so isnt there a simple way to do that?
03:54:24 <twomashi> preferably implementable by mere mortals
03:54:44 <`nand`> I don't really have a good understanding of what it is you're trying to do
03:55:41 <twomashi> I have a monad m which wraps a Maybe a. I need to lazily consume a list of m (Maybe a) until a None is encountered, at which point the stream is finished.
03:56:07 <`nand`> oh
03:56:09 <skp> twomashi: MaybeT?
03:56:13 <`nand`> so you want [Maybe a] -> [a] -- ?
03:56:28 <`nand`> and not Maybe [a]
03:57:04 <twomashi> Yes, but thats not the issue
03:57:18 <twomashi> concatenating the maybes is fine
03:57:23 <twomashi> its the outer monad
03:57:32 <skp> so what’s the issue?
03:57:34 <twomashi> this is a non working approach:
03:57:36 <twomashi> :t let f (x:xs) = do { v <- x; case v of Nothing -> return []; Just a -> (a:) <$> f xs }
03:57:37 <lambdabot> <no location info>:
03:57:37 <lambdabot>     not an expression: `let f (x:xs) = do { v <- x; case v of Nothing -> return []; Just a -> (a:) <$> f xs }'
03:57:41 <`nand`> oh; wait I think I get it
03:57:48 <`nand`> you have something like [IO (Maybe a)] -- ?
03:57:52 <twomashi> Yes
03:58:02 <skp> hey what are « *.p_o » files?
03:58:05 <skp> prof objects?
03:58:07 <twomashi> right, maybe easier to illustrate using IO :
03:58:08 <twomashi> :)
03:59:16 <twomashi> the Maybes are easy; catMaybes $ takeWhile isJust xs
03:59:21 <`nand`> then yeah, an approach which should work is modelling your functions around T = IO (Maybe (a, T)); you just perform the IO to get the next result
03:59:28 <`nand`> if any
03:59:36 <`nand`> not sure if there's a simpler approach
04:00:57 <twomashi> interesting; so explicit recursion
04:01:19 <twomashi> ok, thanks
04:01:23 <`nand`> but again, the various iteratee libraries essentially cover this approach
04:02:13 <jbu_> hi all: in the line "newtype ExcT m a = MkExc (m (Exc a))" in the part "ExcT m a" is that saying ExcT depends on two types m and a? or is that a constructor that takes in m and a?
04:03:05 <`nand`> (of course, if you just want something quick and dirty; you could use unsafeInterleaveIO to get lazy I/O)
04:03:44 <twomashi> `nand`: im guessing that wont work with my MonadResource monad though
04:03:58 <`nand`> if it's not IO then it won't
04:04:44 <twomashi> damn; i would have liked to take the quick and dirty approach, having tried to solve it and finding that getting iteratee libraries involved is the solution :)
04:04:58 <twomashi> not that I have anyhting against them, just that I dont particularly understand them yet.
04:06:07 <`nand`> I understand where you're coming from, I don't understand iteratees and probably couldn't work with them either :)
04:06:31 <`nand`> however I do sort of understand ‘machines’, which is edwardk's iteratee library to rule them all
04:07:32 <twomashi> got a link?
04:08:46 <`nand`> http://ekmett.github.com/machines/index.html
04:09:03 <`nand`> for example: repeatedly $ request randomIO >>= yield :: Random o => Machine IO o
04:09:16 <`nand`> effectively gives you an infinite stream of random numbers
04:39:14 * hackagebot clay 0.3 - CSS preprocessor as embedded Haskell.  http://hackage.haskell.org/package/clay-0.3 (SebastiaanVisser)
04:50:00 <kallisti1> Prelude System.Plugins.Load Erisbot.Types> load_ "scripts/erisbot/dist/build/Erisbot.o" [] "erisbot" :: IO (LoadStatus (BotConf -> IO ()))
04:50:04 <kallisti1> <interactive>: scripts/erisbot/dist/build/Erisbot.o: unknown symbol `erisbotzm0zi0_ErisbotziCommands_commandDispatcher_closure'
04:50:06 <kallisti1> *** Exception: user error (resolvedObjs failed.)
04:50:22 <kallisti1> based on this output do you guys have any idea what's going wrong (the library is "plugins")
04:53:22 <`nand`> oh
04:53:32 <`nand`> repeatedly $ request randomIO >>= yield   -- can be simplified to: pass randomIO
04:54:25 <kallisti1> `nand`: repeatedly. is that anything like forever?
04:54:34 <`nand`> repeatedly = construct . forever
04:54:54 <niteria> :t construct
04:54:56 <lambdabot>     Not in scope: `construct'
04:54:56 <lambdabot>     Perhaps you meant `contract' (imported from Data.Constraint)
04:56:02 <`nand`> https://github.com/ekmett/machines/blob/master/src/Data/Machine/Type.hs#L175
04:57:54 <kallisti1> do I need to like... tell hs-plugins where something is?
05:00:59 <kallisti1> perhaps I should take a peek at lambdabots code.
05:04:16 * kallisti1 is developing Yet Another Replacement For Lambdabot
05:05:26 <niteria> data Is a b where Refl :: Is a a, looks like something from agda
05:05:30 <skp> hey, I know how to « cast » integral types between each other
05:05:34 <skp> but Floating?
05:05:37 <skp> fromFloating?
05:07:24 <niteria> @hoogle Float -> Real
05:07:25 <lambdabot> Warning: Unknown type Real
05:07:26 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
05:07:26 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
05:07:43 <niteria> @hoogle Float -> Double
05:07:44 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
05:07:44 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
05:07:44 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
05:08:06 <skp> @hoogle Float -> CFloat
05:08:07 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
05:08:07 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
05:08:07 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
05:08:14 <skp> :(
05:08:41 <skp> ok fromRational then
05:09:42 <skp> oh fuck no
05:09:46 <skp> it doesn’t work
05:10:24 <kallisti1> skp: there are multiple functions
05:10:39 <skp> I’m looking for ’em
05:10:40 <kallisti1> skp: the one that I find works often in many sitations is realToFrac
05:11:13 <statusfailed> skp: what's the type sig of the function you want? I'm confused
05:11:37 <skp> ok it works
05:11:48 <skp> statusfailed: I want Float -> CFloat
05:11:52 <skp> realToFrac works
05:12:42 <skp> thank you kallisti1
05:12:46 <kallisti1> @src realToFrac
05:12:46 <lambdabot> realToFrac = fromRational . toRational
05:13:13 <kallisti1> @src toRational
05:13:13 <lambdabot> Source not found. I've seen penguins that can type better than that.
05:17:24 <xpika> C-u C-c C-t inserts a type annotation, for symbol at point, on the line above <-- this haskell mode command is not working
05:19:15 * hackagebot monad-logger 0.3.1 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.1 (MichaelSnoyman)
05:24:17 * hackagebot alex 3.0.5 - Alex is a tool for generating lexical analysers in Haskell  http://hackage.haskell.org/package/alex-3.0.5 (SimonMarlow)
05:38:00 <basdirks> iterate is nice, for unary functions, but how about for binary+ functions?
05:38:08 <basdirks> like fibonacci
05:38:22 <basdirks> is there a performance penalty for using tuples there?
05:39:17 <basdirks> like fib = map fst $ iterate (\(a,b) -> (a + b, a)) (0,1)
05:43:21 <basdirks> ah well I guess it come down to fibs a b = a : fibs (a + b) a
05:43:36 <`nand`> skp: CFloat :: Float -> CFloat
05:49:07 <kallisti1> so I'm guessing no one knows what the problem could be (re: plugins)
05:49:18 <kallisti1> I can provide more info, just don't know what info is relevant
06:06:29 <yitz> kallisti1: lambdabot's code is really old and has been pretty much unmaintained for a long time. so that's probably not such a good example for you, unfortunately.
06:07:37 <yitz> kallisti1: were you looking at this recent link on reddit? http://codeutopia.net/blog/2011/08/20/adventures-in-haskell-dynamic-loading-and-compiling-of-modules/
06:09:57 <kallisti1> yitz: I was not
06:10:32 <kallisti1> yitz: I'm not much in the know. :P
06:10:53 <kallisti1> specifically I'm using the plugins library, which this blog doesn't seem to be using.
06:11:02 <yitz> basdirks: there is a penalty to that yes. usually an insignificant one, if that is the clearest way to write your function. But often it isn't the clearest way, either, when there is more than one variable involved.
06:11:41 <yitz> kallisti1: ok. probably plugins is meant to be a higher-level wrapper for that stuff. not sure, just a guess.
06:11:53 <kallisti1> yitz: yes it's a higher-level wrapper for the GHC API
06:12:06 <kallisti1> I'm just not sure what I'm doing wrong, there is always an "unknown symbol" error
06:12:53 <kallisti1> I would think that because plugins uses the global and user registered package.confs that it would know where to find modules that I've installed, but perhaps there's some piece of information I need to give it that is missing.
06:12:57 <kallisti1> @hoogle plugins
06:12:57 <lambdabot> package plugins
06:12:57 <lambdabot> package direct-plugins
06:12:57 <lambdabot> package happstack-plugins
06:13:04 <kallisti1> @hackage plugins
06:13:04 <lambdabot> http://hackage.haskell.org/package/plugins
06:13:13 <kallisti1> the function I'm using is System.Plugins.Load.load
06:13:58 <kallisti1> I don't supply any custom package.confs or directories in include path, because everything that my plugins depends on is already registered in ghc's package system (not sure if I'm using the correct terminology here since I don't fully understand GHC's package system)
06:14:52 <kallisti> "The Haskell system GHC has libraries that provide the ability to compile Haskell code and dynamically load it into a running Haskell program. A library that provides this functionality is hs-plugins. Unfortunately hs-plugins doesn't work with the latest GHC release, 6.10.1."
06:14:56 <kallisti> oh, well this could be my problem
06:15:12 <yitz> kallisti1: the package comment of the direct-plugins package claims that the plugins packages stopped working as of ghc 6.12, and claims to be a simpler replacement.
06:15:12 <kallisti> well, this blog post is from 2008, so the information is likely outdated.
06:15:29 <yitz> of course we are now quite a few ghc versions beyond that, too.
06:15:33 <kallisti> indeed
06:16:00 <yitz> i see that there a number of different packages that do plugins in different ways.
06:16:26 <awMinor> Hi! About what this chanel?
06:17:48 <kallisti> awMinor: this channel is about the Haskell programming language.
06:17:50 <yitz> kallisti: the maintainer of plugins is the lead developer of the happstack web framework. that is actively developed, and does use plugins. maybe email him and ask.
06:18:11 <kallisti> yitz: perhaps I'll try direct-plugins, though I don't necessarily like its interface
06:18:21 <kallisti> I would prefer not to specify a package name in order to load plugins.
06:18:36 <kallisti> I don't really know of a way to find package names
06:18:59 <yitz> eah
06:19:01 <yitz> yeah
06:19:51 <yitz> this sort of think can be very fiddly. so the most important thing is to find an approach that people are really using and it works.
06:20:31 <yitz> and my guess is that you're going to want to use the ghc support, at least indirectly.
06:21:22 <yitz> it probably also depends on the particular application you need plugins for.
06:21:59 <kallisti> yitz: yeah looks like happstack-plugins is my best best
06:22:04 <kallisti> s/best/bet/
06:22:28 <yitz> ok gl
06:25:14 <arturaz> Prelude| forall :: (Int -> Bool) -> Set -> Bool
06:25:15 <arturaz> Prelude| forall p set = ! List.any (\int -> set int && not p int) [-1000..1000]
06:25:20 <arturaz> <interactive>:24:14: parse error on input `='
06:25:26 <arturaz> huh? What I'm missing?
06:25:38 <kallisti> what is !
06:25:50 <Botje> you cannot define functions like that in GHCi
06:26:07 <arturaz> Botje, I'm using :{ :} for multiline
06:26:51 <arturaz> kallisti, yeah, that should be replaced with not
06:27:03 <kallisti> arturaz: looks like that's the problem
06:27:17 <kallisti> Prelude| f = ! "lol"
06:27:21 <kallisti> <interactive>:17:3: parse error on input `='
06:28:01 <kallisti> yitz: actually it looks like happstack-plugins uses plugins internally
06:28:05 <arturaz> I changed it to Prelude| forall p set = not List.any (\int -> set int && not p int) [-1000..1000]
06:28:08 <arturaz> <interactive>:30:14: parse error on input `='
06:28:10 <arturaz> still
06:28:30 <kallisti> yitz: oh nevermind, it's been removed in newer versions. once again I'm reading out-dated blogs.
06:28:32 <yitz> kallisti: ok. then maybe plugins really is supported these days. i would ask jeremey.
06:28:37 <yitz> ah. :)
06:29:09 <kallisti> nevermind. it still uses plugins. I promise I've got it right this time.
06:29:29 <basdirks> > let evenFibs = filter even $ take 100 (let f a b = a : f (a + b) a in f 0 1) in take 32 evenFibs == (take 32 $ tail $ zipWith (-) (tail evenFibs) (map (*4) evenFibs))
06:29:31 <lambdabot>   True
06:29:33 <basdirks> > let evenFibs = filter even $ take 100 (let f a b = a : f (a + b) a in f 0 1) in take 33 evenFibs == (take 33 $ tail $ zipWith (-) (tail evenFibs) (map (*4) evenFibs))
06:29:35 <lambdabot>   False
06:29:51 <yitz> haha
06:30:11 <yitz> kallisti: don't promise me, promise your users. :)
06:30:20 <kallisti> the only user is myself
06:30:23 <kallisti> so that's good
06:30:31 <applicative> arturaz: there may be trouble from forall being a keyword?
06:30:35 * kallisti is writing an IRC bot.
06:31:12 <applicative> arturaz: yeah, I think that's it, I get the error for
06:31:17 <basdirks> the fact that those two sequences only diverge after about 100 terms is kinda interesting no?
06:31:18 <skp> 13:43 #haskell: < `nand`> skp: CFloat :: Float -> CFloat
06:31:22 <skp> then the ctor?
06:31:28 <applicative> arturaz: forall x = even x , when in the multiline mode
06:33:02 <applicative> arturaz, so call it forevery or something
06:33:10 <kallisti> > let forall x = x in forall 2
06:33:11 <lambdabot>   2
06:33:17 <kallisti> forall is not a reserved word
06:33:24 <arturaz> set :: Int -> Bool
06:33:24 <arturaz> set -10 = True
06:33:25 <arturaz> set -2 = True
06:33:30 <arturaz> can this be shortened?
06:33:31 <applicative> kallisti: try it in multiline mode
06:34:05 <kallisti> hm, yeah I get an error
06:34:29 <applicative> no your right, it's hard to remember you still need let
06:34:39 <yitz> > let fibs = 0 : 1 : (zipWith (+) <*> tail) fibs in map head $ chunksOf 3 fibs
06:34:40 <kallisti> oh you do? that's odd
06:34:41 <lambdabot>   [0,2,8,34,144,610,2584,10946,46368,196418,832040,3524578,14930352,63245986,...
06:34:44 <kallisti> I never use multiline mode
06:35:02 <applicative> yeah me neither, I'm officially confused at the moment ...
06:36:02 <kallisti> before it existed, I thought to myself "oh it would be cool if I could define instances and data declarations in ghci"
06:36:10 <kallisti> and then when I actually have the functionality, I don't use it. :P
06:37:10 <kallisti> yitz: oh I think I found my problem.
06:37:32 <kallisti> I need to tell load where to find the object files for my IRC bot.
06:37:40 <kallisti> not sure why, since it's registered with ghc-pkg
06:38:35 <yitz> kallisti: not very surprising, really, when you're loading things manually like that.
06:39:54 <kallisti> yitz: maybe if I ask it to dynamically load the object files from .cabal/packages instead of from the local dist directory it would automatically link without having to specify any include paths
06:40:59 <kallisti> actually I don't know where those object files are located...
06:44:26 <kallisti> strifebot: /home/adam/.cabal/lib/plugins-1.5.3.0/ghc-7.4.1/HSplugins-1.5.3.0.o: unknown symbol `ghczm7zi4zi1_ErrUtils_zdsinsertzugo3_info'
06:44:37 <kallisti> this looks to be an error with hs-plugins
06:48:30 <maltem> It has been quite a long time since I last entered this room. I cannot say I would remember every detail of how it looked in those days, but I am very sure that it has not always been so crowded.
06:49:27 <byorgey> welcome back maltem =)
06:49:52 <basdirks> let eFib xs@(a:b:_) = a : eFib (a * 4 + b : xs) in take 10 $ eFib [2,0]
06:49:55 <basdirks> > let eFib xs@(a:b:_) = a : eFib (a * 4 + b : xs) in take 10 $ eFib [2,0]
06:49:57 <lambdabot>   [2,8,34,144,610,2584,10946,46368,196418,832040]
06:50:05 <maltem> :)
06:52:16 <maltem> So, question: Consider programming a webmailer that communicates with an IMAP server. Would it make sense to persist the IMAP connection along user sessions? Or is that not worth the hassle?
06:54:07 <yitz> > let fibsBy m a b = a : b : (zipWith (\x y -> x + m * y) <*> tail) (fibsBy m a b) in and . take 100 $ zipWith (==) (filter even $ fibsBy 1 0 1) (fibsBy 4 0 2) -- basdirks, is this what you are looking for?
06:54:09 <lambdabot>   True
06:54:47 <byorgey> > let eFibs = 0 : 2 : zipWith (+) eFibs (map (4*) (tail eFibs)) in take 11 eFibs
06:54:49 <lambdabot>   [0,2,8,34,144,610,2584,10946,46368,196418,832040]
06:55:17 <yitz> byorgey: right, i think he wants to multiply the *second* parameter by 4, not the first
06:56:03 <byorgey> yitz: mine gave the same output!
06:56:04 <yitz> > let fibsBy m a b = a : b : (zipWith (\x y -> x + m * y) <*> tail) (fibsBy m a b) in fibsBy 4 0 2
06:56:06 <lambdabot>   [0,2,8,34,144,610,2584,10946,46368,196418,832040,3524578,14930352,63245986,...
06:56:38 <yitz> byorgey: basdirks claims that they are the same only for the first 32 terms, then they differ
06:56:44 <basdirks> nono
06:56:50 <basdirks> that was a silly mistake on my part
06:57:23 <basdirks> point was the the even fibs are easily generated
06:57:30 <basdirks> and from those the odd ones can be derived
06:57:57 <yitz> basdirks: you can also just take every third term in the regular fibs, as i showed above.
06:58:15 <basdirks> yeah
07:01:10 <basdirks> your function seems a bit slower though
07:01:26 <basdirks> for the purpose of finding even fibs 1 to n
07:02:53 <yitz> basdirks: yes just easy to type
07:03:08 <basdirks> sure, I appreciate it
07:08:55 <qasd> how do I print a long double ? %Lf or %Le doesnt work for me. Im on win8, gcc.
07:11:02 <mauke> qasd: how is that a haskell question?
07:11:26 <qasd> oops wrong channel
07:11:44 <Hafydd> Begone, dirty heathen.
07:12:02 <Hafydd> It should I say... then?
07:12:15 <Hafydd> Er... nevermind.
07:21:25 <hpaste> asdasdasd pasted “asdasd” at http://hpaste.org/83794
07:22:50 <hpaste> asddsasda pasted “sdadsa” at http://hpaste.org/83795
07:32:02 <qasd> Is there soem well known fact abotu congruences and primes that you can think of?
07:32:40 <Hafydd> Like Fermat's Little Theorem?
07:35:42 <niteria> Chinese Remainder Theorem
07:39:21 <byorgey> quadratic reciprocity
07:39:36 <byorgey> guess it depends what counts as "well known" =)
07:39:43 <arkeet> chinese remainder theorem doesn't have much to do with primes
07:39:48 <arkeet> +1 for quadratic reciprocity though
07:40:57 <arkeet> also, pretty much any primality test
07:41:20 <Hafydd> That depends how you choose to characterise the CRT.
07:42:03 <arkeet> Hafydd: CRT is a statement about relatively prime moduli.
07:42:58 <arkeet> so no, not really.
07:45:05 <Hafydd> "A modern restatement of the theorem in algebraic language is that for a positive integer \scriptstyle n with prime factorization \scriptstyle p_1^{r_1} p_2^{r_2} \cdots p_k^{r_k} we have the isomorphism between a ring and the direct product of its prime power parts: ..."
07:47:21 <sellout-> Hafydd: Great, now I want an IRC client that supports embedded ΤΕΧ.
07:48:15 <Hafydd> I was too lazy to reformat it in ASCII, but it's quite possible.
07:48:53 <k00mi_> sellout-: should be possible with pidgin
07:50:49 <sellout-> Hrmm, too bad that the pidgin and erc Τεχ plugins expect different syntax. But the pidgin syntax might also work in erc. I'll have to test.
07:52:14 <sellout-> Hafydd: In future, do $$\scriptstyle p_1^{r_1} p_2^{r_2} \cdots p_k^{r_k}$$ :)
07:53:05 <Hafydd> $$\mathrm{Okay.}$$
07:53:47 <yitz> why \scriptstyle and not just $n$ ?
07:54:56 <sellout-> yitz: Oh, I just copy/pasted badly is all.
07:56:00 <yitz> i'm impressed that you got the glyphs right for Τεχ
07:56:05 <Hafydd> Hahah.
07:57:18 <sellout-> yitz: I keep a Greek layout around for just such occasions.
07:57:49 <yitz> sellout-++
07:57:59 <Hafydd> Is that capital τ or capital t?
07:58:14 <sellout-> Hafydd: τ
07:59:04 <qasd> what is the largest int value normally?
07:59:18 <maltem> > maxBound :: Int
07:59:20 <qasd> and if a function has to return an int and i return a long, what happens?
07:59:20 <lambdabot>   9223372036854775807
07:59:42 <danharaj> I guess he was in the wrong channel.
08:00:02 <maltem> looks like it
08:09:34 <kallisti> what is the particular motivation for using a 2-3 tree when implementing finger trees
08:09:45 <kallisti> over, say, a regular binary tree
08:09:48 <mauke> we have 2+3 fingers
08:10:33 <byorgey> kallisti: it gives just enough wiggle room to delay some balancing operations enough to make an asymptotic difference
08:10:42 <byorgey> kallisti: edwardk has some nice slides explaining this somewhere
08:13:12 <applicative> hm sure enough http://comonad.com/reader/wp-content/uploads/2010/04/Finger-Trees.pdf
08:14:01 <byorgey> yup, that's it
08:15:22 <applicative> looks a little rougher than I was hoping ...
08:23:55 <Taneb> Are there any fully standards-compliant implementations of Haskell other than GHC?
08:24:18 <elliott> Taneb: other than?
08:24:31 <Taneb> elliott, I was in two minds about adding that on
08:24:43 <Taneb> If I hadn't, someone would have said "GHC, of course!"
08:24:51 <danharaj> GHC isn't standards-compliant.
08:25:45 <donri> are there any other compilers whose Haskell{98,2010} modes are compatible with GHC's?
08:26:10 <danharaj> Doubtful. GHC made some unilateral breaking changes.
08:26:18 <bitonic> donri: the most compatible are UHC and JHC I think
08:26:24 <bitonic> but there’s no drop in replacement
08:26:50 <bitonic> ah wait, you asked about the std explicitely
08:26:52 <bitonic> then I don’t know :P
08:28:09 <donri> http://www.cs.uu.nl/wiki/bin/view/Ehc/UhcUserDocumentation#4_Haskell_compatibility
08:29:11 <bitonic> donri: what do you need to do?  or is it just curiosity?
08:29:22 * hackagebot cqrs-types 0.9.0 - Command-Query Responsibility Segregation. Modules for the basic types.  http://hackage.haskell.org/package/cqrs-types-0.9.0 (BardurArantsson)
08:29:24 * hackagebot cqrs-test 0.9.0 - Command-Query Responsibility Segregation Test Support  http://hackage.haskell.org/package/cqrs-test-0.9.0 (BardurArantsson)
08:29:26 * hackagebot cqrs 0.9.0 - Command-Query Responsibility Segregation  http://hackage.haskell.org/package/cqrs-0.9.0 (BardurArantsson)
08:29:33 <donri> curiosity; continuing Taneb's line of questioning
08:30:35 <bitonic> donri: the short answer is ‘no’ I’m afraid.  most modern Haskell libraries/program require GHC.  there are some people who take the trouble of packaging stuff that works with Hugs as wel, when possible
08:30:54 <bitonic> like edwardk has various Haskell98, I think he likes proving that it’s doable lol
08:31:02 <bitonic> *various haskell98 packages
08:31:27 <danharaj> It is a good idea to try to stick to haskell98 wherever possible.
08:31:36 <danharaj> And try not to lay the extensions on too thick in general.
08:31:37 <donri> IIUC he did that as a design constraint, to avoid the temptation of dubious extension without careful thought
08:32:03 <donri> but he also seems to do that less these days, especially for new packages
08:32:05 <bitonic> donri: I’m not sure - for example I like `data Void' much more than `data Void = Void !Void'
08:32:06 <`nand`> I program mainly for myself and my own convenience; so I always target the Haskell extensions that make life easiest for me, which usually locks me down to GHC
08:32:29 <donri> bitonic: yea. that's 2010 though :)
08:33:22 <bitonic> donri: my point is that I don’t think the ‘let’s limit ourselves to haskell98 so that we avoid useless extension’ is the reason behind edwardk’s decisions
08:33:49 <elliott> (it's newtype Void = Void Void)
08:33:52 <donri> bitonic: it's what he said himself, or something to that effect
08:34:06 <elliott> note that that one gives you a more "sound" absurd :: Void -> a, arguably
08:34:11 <elliott> in terms of just how the code looks
08:34:22 <bitonic> elliott: uhm, I remember the bang
08:34:22 * hackagebot cqrs-postgresql 0.9.0 - PostgreSQL backend for the cqrs package.  http://hackage.haskell.org/package/cqrs-postgresql-0.9.0 (BardurArantsson)
08:34:24 * hackagebot cqrs-sqlite3 0.9.0 - SQLite3 backend for the cqrs package.  http://hackage.haskell.org/package/cqrs-sqlite3-0.9.0 (BardurArantsson)
08:34:40 <bitonic> #if __GLASGOW_HASKELL__ < 700; data Void = Void !Void
08:34:43 <bitonic> I wonder why
08:34:43 <`nand`> both seem valid to me
08:35:27 <elliott> bitonic: ghc bug
08:35:36 <bitonic> oh, OK
08:40:54 <cariveri> hello
08:41:33 <bitonic> cariveri: hi
08:42:47 <cariveri> I was talking to someone who wanted to a readable and quick hasekll equivalent for something in written in c: for (int=0;i<=eol;i+=2){ ... }. every second element ?
08:43:27 <mauke> forM_ [0, 2 .. eol] $ \i ->
08:44:11 <Iceland_jack> cariveri: It depends on what's in the { … } body part to be honest
08:44:23 * hackagebot cqrs-example 0.9.0 - Example for cqrs package  http://hackage.haskell.org/package/cqrs-example-0.9.0 (BardurArantsson)
08:44:37 <cariveri> Iceland_jack: a list of elements is iterated. and every second elem should be processed.
08:44:41 <dmwit> :t map head . chunksOf 2
08:44:42 <lambdabot> [b] -> [b]
08:45:04 <dmwit> :t let f (x:_:xs) = x : f xs; f _ = [] in f
08:45:05 <applicative> > [0,2 .. 51]
08:45:06 <Iceland_jack> cariveri: I know, the question was processed /how/
08:45:06 <lambdabot> [a] -> [a]
08:45:06 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50]
08:45:25 <applicative> @type forM
08:45:26 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
08:46:50 <applicative> oh I didn't notice mauke's answer; way too fast
08:49:09 <applicative> Its surprising there can be a monad instance for a fingertree type, but it looks like its so
08:49:35 <cariveri> Iceland_jack: hmm that has not been discussed. for now in arbitrary way. but it depents you say...hmm.
08:50:25 <bitonic> applicative: most `T x' things that have tips that look like `X x' are monads
08:51:08 <bitonic> applicative: e.g. terms, where the `X x' would be a `Variable identifier'
08:51:20 <applicative> yes, its basically in the form of a free monad, but with curiosities
08:53:18 <bitonic> Maybe is the same
08:53:57 <bitonic> if the `X x' has the only occurrence of `x' then you’re good :)
08:55:20 <niteria> @src sequence
08:55:20 <lambdabot> sequence []     = return []
08:55:21 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:55:21 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
08:55:21 <`ramses> bitonic: can the oposite be proven? That if xs appear outside the tips, the thing cannot be a monad?
08:55:29 <`ramses> opposite *
08:56:13 <bitonic> `ramses: well the opposite it’s not true, [] is a monad with no tips of that shape
08:57:42 <`ramses> bitonic: ah, so it's exact in neither case, as you said "most ... are monads"
08:58:00 <niklasb> can I somehow get GHCi to load compiled object files from different locations? say directory build/ contains the object and hi files for modules in src/ and build2/ contains the object and hi files for src2/, can I instruct it to use all the compiled files without loading half of the dynamically in interpreted mode?
08:58:16 <`ramses> I guess that implies not all of such structures are monads, then
08:58:26 <niklasb> s/half of the/half of them
08:58:53 <bitonic> `ramses: *all* data types over `x' where `X x' is the only occurrence of `x' are monads
08:59:46 <`ramses> bitonic: ah, ok, interesting :) You can probably prove it by viewing them as "list-like"s with some more complex structure then?
08:59:47 <applicative> bitonic: if the type is a gadt don't some of the obvious thoughts break down?
09:00:07 <bitonic> applicative: ‘data type’ lacks the ‘G’ in ‘GADT’
09:00:20 <bitonic> but yes :)
09:00:25 <applicative> yes
09:01:14 <applicative> I've been trying to figure out when I can make a functor or monad with a GADT somehow as the basis.
09:01:41 <bitonic> applicative: well as long as the final `x' is a parameter and not an index, the same considerations apply
09:02:45 * applicative may not be following this use of index
09:02:58 <bitonic> you can see it like this: if `x' is non linear across the constructors `x' is appearing in equality proofs somewhere, and not only in the `X x' we were talking about
09:03:21 <bitonic> applicative: parameter = is the same across all constructors, index = can change from constructor to constructor
09:03:47 <bitonic> (talking about parameters of type constructors)
09:04:22 <applicative> right, I am thinking of the ones you are calling indexes. I can't make a functor instance if it changes
09:05:12 <bitonic> yes, if the last argument of the type constructor is an index you can’t, because of (>>=)’s type
09:06:30 <applicative> yes, but I was considering things like Free f , for such gadty fs
09:07:46 <applicative> that isn't a functor either, but e.g. Codensity f is, though I suppose its trivial
09:08:55 <bitonic> well yes, same considerations apply - if the last par of f is an index, the last of `Free f r' will be an index
09:09:39 <applicative> yes, but Codensity f and Nu f, so to call it, seem to work out
09:10:40 <bitonic> I don’t know what Codensity is and I guess Nu = GFP?
09:10:58 <applicative> e.g. for data Frei f a where Frei :: forall a f s . (s -> Either a (f s)) -> !s -> Frei f a
09:11:18 <bitonic> what does Nu look like?
09:11:39 <applicative> the functor instance doesn't depend on the functoriality of f,
09:11:54 <applicative> Frei there is what I mean
09:12:29 <applicative> data Nu f where Nu :: s -> (s -> f s) -> Nu f
09:12:51 <applicative> Frei above adds a parameter so the question of a functor can arise
09:13:13 <applicative> newtype Codensity f a = Codensity { runCodensity :: forall b. (a -> f b) -> f b }
09:13:33 <applicative> familiarly is a functor even if f isn't
09:13:57 <applicative> instance Functor (Codensity k) where  fmap f m = Codensity (\k -> runCodensity m (k . f))
09:14:15 <bitonic> applicative: Frei, Nu, and Codensity have no indices as far as I can tell
09:14:32 <bitonic> you don’t need GADTs to define them
09:14:34 <applicative> yes, but the f's do
09:14:48 <bitonic> ah
09:15:04 <bitonic> I’m losing you a bit here I’d have to write the code down :P
09:15:47 <bitonic> the bottom line is that working with Monad and non-linear thingies can be annoying ehe
09:16:05 <applicative> the Functor instance I gave for Codensity above doesn't rely on f being a functor
09:16:27 <applicative> so it works for the odd cases
09:17:10 <applicative> similarly for instance Functor (Frei f) where
09:17:17 <applicative> which is more laborious
09:17:41 <bitonic> applicative: well of course it depends, the Functor and Monad instances for `data Proxy f = Proxy' works for all `f' too ehe
09:18:09 <applicative> yes, so the question is exactly, what constructions of these types are not trivial
09:18:52 <applicative> which is a bit obscure as a question admittedly
09:19:41 <bitonic> yeah, I’m not sure I understand - how I see it is that if you have an `f a' and the `a' changes in the recursive occurrences of `f' in `f a' defining (>>=) is going to be tough
09:19:53 <applicative> I was thinking about cases where people try to make a functor for a GADT and the like by say literally adding an Fmap :: (a -> b) -> Z a -> Z b constructor
09:20:41 <applicative> bitonic: yeah I don't see how to get to a monad. Though e.g. Codensity makes a Functor of anything, it only makes a Monad of Functors
09:21:23 <applicative> Free can't make a Functor of anything, but makes a Monad of a Functor
09:21:28 <elliott> Codensity (Codensity f)!!
09:21:36 <bitonic> ehe
09:21:43 <applicative> elliott: you're freaking me out
09:21:45 <applicative> !
09:22:03 <elliott> Codensity (Codensity (Codensity f)) -- additional power
09:22:23 <bitonic> applicative: some times it’s nice to stand back and ask yourself ‘what are the semantics of the Monad instance I want for this - what does it do’
09:22:43 <applicative> yes, of course.
09:23:02 <applicative> in the case that interested me, the Frisby library, a Monad instance isn't needed actually
09:23:07 <bitonic> obvious it’s fun to just make the type match but it’d a dangerous game in Haskell :P
09:23:09 <applicative> applicative and alternative are
09:24:11 <applicative> the frisby library's main type is a gadt for so-called peg grammars
09:24:34 <applicative> all the instances are fraudulent but work out
09:24:55 <bitonic> fraudolent in what sense?
09:26:04 <applicative> see the PE type here http://hackage.haskell.org/packages/archive/frisby/0.1/doc/html/src/Text-Parsers-Frisby.html#PM
09:26:42 <applicative> instance Functor PE where fmap = PMap, well fmap id Any is then (PMap id Any) which isn't the same...
09:27:02 <bitonic> ah right.  PMap lol.  I never experimented with that kind of thing
09:27:04 <applicative> though of course he doesn't export PE etc
09:27:40 <applicative> it happens some
09:29:47 <applicative> here's another example, which I had meant to look for and now found
09:29:48 <applicative> http://jaspervdj.be/posts/2012-09-07-applicative-bidirectional-serialization-combinators.html
09:31:48 <applicative> the Table type basically justs constructors for Functor & Applicative
09:32:03 <applicative> basically just adds them
09:57:02 <bergey>  I'd like to alias fromIntegral to something shorter, like fi = fromIntegral.  When I do this, though, polymorphism suffers---ghc infers that every call to (fi x) has the same type, which isn't true of (fromIntegral x).  How can I avoid this?
09:57:23 <byorgey> bergey: turn off the MonomorphismRestriction
09:57:36 <byorgey> bergey: or give fi an explicit polymorphic type
09:58:03 <bergey> Makes sense.  Thanks!
09:58:20 <parcs> bergey: fi x = fromIntegral x should work
09:58:40 <byorgey> that too.
10:01:00 <bergey> Great, it compiles.  Now I can get back to figuring out why my code doesn't draw anything on the screen :)
10:05:24 <jmcarthur> elliott: newtype OMGPOWAR f a = OMGPOWAR (Codensity (OMGPOWAR f) a)
10:06:23 <jmcarthur> applicative: i know of a couple ways to make a functor from a type constructor that is not a functor
10:07:09 <jmcarthur> applicative: data CoYoneda f a = forall e. CoYoneda (f e) (e -> a)
10:07:40 <jmcarthur> applicative: newtype Yoneda f a = Yoneda (forall r. (a -> r) -> f r)  -- if i recall correctly
10:08:07 <jmcarthur> applicative: and if f happens to be a functor already, those are both isomorphic to it, i think
10:09:07 <jmcarthur> applicative: works for GADTs, IORefs, etc.
10:19:55 <bitonic> jmcarthur: if you have a `(f :: * -> *) -> (a :: *) -> *', as long as you don’t have `f a' you are fine really
10:20:05 <bitonic> well, you might be fine :)
10:23:08 <bitonic> ohh, `(f ∷ ⋆ → ⋆) → (a ∷ ⋆) → ⋆', better
10:25:22 * monochrom pushes it to the extreme: (φ ∷ ⋆ → ⋆) → (α ∷ ⋆) → ⋆ :)
10:25:58 * Iceland_jack pushes it further: (φ ∷ ⋆ → ⋆) → (α ∷ ⋆) → ⋆ ☺
10:26:09 <monochrom> yikes haha
10:27:49 <bitonic> ↖↗
10:28:06 <applicative> jmcarthur: sorry, I vanished but instance Functor f => Functor (Yoneda f) where fmap f (Yoneda k)  = Yoneda $ \g -> fmap g (k f)
10:28:20 <applicative> this requires a Functor constraint on f
10:29:42 <Saizan> oh, i was trying to get what type constructor ☺ was
10:30:02 <bitonic> applicative: fmap f (Yoneda k) = Yoneda (\g -> k (g . f)), no constraint
10:31:49 <applicative> am i hallucinating, whose fmap is that
10:31:50 <Taneb> Is there a way to see all public tutorials on School of Haskell?
10:31:51 <applicative> ha
10:32:49 <applicative> I'm freaking out how can there be two fmap definitions; the Functor constrained one must reduce to the other
10:33:42 <skp> why can’t we make tuples functors?
10:33:51 <applicative> hm, I copied the other from Edward K but its obvious
10:34:05 <applicative> skp you can
10:34:10 <aristid> the ominous mr. K
10:34:11 <bitonic> applicative: I just looked at the types I don’t know what those instances mean
10:34:20 <bitonic> (I never used Yoneda really)
10:34:20 <applicative> skp: there's a functor instance around for (,) a
10:34:36 <skp> alshain: why isn’t it in Prelude?
10:34:43 <skp> or in any lib?
10:35:06 <bitonic> skp: it is
10:35:12 <skp> oh?
10:35:14 <skp> I can do
10:35:28 <skp> (+1) <$> (3,5)
10:35:29 <skp> ?
10:35:39 <parcs> appamatto: in control.monad.instances i think
10:35:44 <parcs> applicative: ^
10:35:47 <geekosaur> import Control.Monad.Instances (a bit of a historical accident, that)
10:35:49 <bitonic> > (+1) <$> (3,5) -- let’s find out
10:35:49 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
10:35:56 <bitonic> > (+1) <$> (3,5) -- let’s find out
10:35:57 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
10:35:59 <geekosaur> wut
10:36:01 <bitonic> oh damn unicode
10:36:02 <applicative> I'm getting it in the Prelude skp if I do :i Functor
10:36:03 <parcs> applicative: oh, you're saying there is one, not whether there is one...
10:36:07 <bitonic> > (+1) <$> (3,5)
10:36:08 <lambdabot>   (3,6)
10:36:11 <bitonic> skp: seems to work
10:36:15 <skp> huh
10:36:19 <bitonic> skp: <http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Functor>
10:36:20 <skp> why only the second?
10:36:42 <bitonic> skp: because a if `Functor f', f :: * -> *, while (,) :: * -> * -> *
10:37:05 <bitonic> a functor ranges over one type
10:37:26 <skp> don’t get it
10:37:38 <bitonic> skp: look at the type signature for fmap
10:37:40 <bitonic> @ty fmap
10:37:42 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:37:52 <bitonic> skp: `f' is applied to one type variable, right?
10:38:26 <skp> yup
10:38:41 <bitonic> skp: so if you propose to substitute `f' with (,), how would that work?
10:38:43 <skp> here it would be (a,a) for a pair tuple
10:39:30 * hackagebot BlogLiterately 0.6 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.6 (BrentYorgey)
10:39:40 <bitonic> skp: well, that’s not how (,) works - (,) takes two parameters.  you can have `newtype SkpMagicTuple a = SkpMagicTuple (a , a)' and that would work as you want
10:40:08 <skp> two parameters?
10:40:12 <skp> which ones?
10:40:15 <bitonic> :k (,)
10:40:17 <lambdabot> * -> * -> *
10:40:30 <bitonic> skp: the first one and the second one, for example in (Int, Bool) it’s Int and Bool
10:40:47 <skp> and
10:40:52 <skp> (Int,Bool,Float)
10:41:03 <bitonic> skp: that is an entirely different type
10:41:11 <bitonic> 2-tuple and 3-tuple
10:41:14 <skp> it’s a tuple too
10:41:42 <geekosaur> so?
10:41:46 <bitonic> skp: they’re both called ‘tuple’, yes.
10:41:54 <skp> hm I think I see the problem
10:42:00 <bitonic> in the same way that haskell datatypes are called ‘datatypes’ :)
10:42:06 <skp> it’s because fmap is monovalued
10:42:20 <skp> I’d like a multivalued fmap
10:42:22 <skp> hihi
10:42:27 <skp> sounds weird
10:42:30 <srhb> I don't understand what you mean by that.
10:43:06 <skp> fmap work – in a functor – for just one type
10:43:10 <skp> works*
10:43:25 <skp> a tuple owns two types, a and b
10:43:26 <bitonic> skp: so you want `class Fmap2 f where; fmap2 :: (a -> b) -> f a a -> f b b'?
10:43:34 <skp> no
10:43:41 <skp> I want
10:44:02 <bitonic> or maybe `class Fmap2 f where; fmap2 :: (a -> c) -> (b -> d) -> f a b -> f c d'?
10:44:15 <skp> fmap2 :: ((a,b -> (c,d)) -> f a b -> f c d
10:44:23 <skp> yeah also
10:44:34 <bitonic> @ty (***)
10:44:36 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
10:44:46 <bitonic> @ty (+++)
10:44:47 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
10:44:53 <bitonic> I can never remember
10:44:59 <skp> I don’t know arrows :(
10:45:29 <bitonic> > ((+2) *** (+3)) (1, 2)
10:45:31 <lambdabot>   (3,5)
10:45:59 <crdueck> ffs, why does Data.ByteString.Lazy-0.10.2's length return an Int64...
10:46:01 <bitonic> > let skp f = (f *** f) in skp (+2) (1, 2)
10:46:03 <lambdabot>   (3,4)
10:46:23 <crdueck> the Strict version returns an Int, why would they make this one different
10:46:37 <hpaste> pete pasted “Scotty w/ Network.Wai.Middleware.Gzip” at http://hpaste.org/83802
10:46:47 <bitonic> skp: it’s not your Fmap2 but it works in this case
10:47:16 <bitonic> but it’s ranging over the ‘mapper’ instead of the container, the tuples are fixed
10:47:48 <skp> arrows sounds pretty weird
10:47:57 <skp> sound*
10:47:58 <skp> dammit
10:48:09 <hpaste> pete revised “Scotty w/ Network.Wai.Middleware.Gzip”: “added source ” at http://hpaste.org/83802
10:48:41 <bitonic> skp: the only weird part is ArrowLoop, I think
10:49:00 <mm_freak_> skp: any advantage of f a b over f (a, b)?
10:49:17 <mm_freak_> bitonic: ArrowLoop isn't really that weird once you know when to use it
10:49:26 <skp> mm_freak_: I want it to apply both the component
10:49:44 <skp> fmap f (a,b) will result in (a,b2)
10:49:48 <skp> and I want (a2,b2)
10:50:00 <skp> I’m talking about types here
10:50:07 <mm_freak_> > fmap (succ *** (++ "blah")) (Just (15, "heh"))
10:50:09 <lambdabot>   Just (16,"hehblah")
10:50:23 <skp> woh
10:50:31 <skp> what the fuck is *** :DDD
10:50:38 <bitonic> mm_freak_: well I still can’t find a person that can give me a definitive answer on a question in the Huges tutorial
10:50:43 <mm_freak_> bitonic tried to explain (***)
10:50:48 <mm_freak_> :t (***)
10:50:50 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
10:50:57 <mm_freak_> replicate "a b c" by "b -> c"
10:51:01 <mm_freak_> replace
10:51:21 <mm_freak_> bitonic: in AFRP/WFRP you use ArrowLoop quite often
10:51:27 <mm_freak_> it gives you feedback
10:51:31 <srhb> AFRP?
10:51:45 <mm_freak_> srhb: arrowized/applicative functional reactive programming
10:51:47 <srhb> Ah.
10:51:51 <bitonic> mm_freak_: I know what it does, but I think is by far and away the most delicate part of the arrow circus
10:52:05 <bitonic> you need to be very careful with lazyness etc.
10:52:27 <bitonic> the question was ‘define ArrowLoop for SP’ where ‘data SP a b = Put b (SP a b) | Get (a -> SP a b)’, I think
10:52:29 <mm_freak_> bitonic: well, for example in netwire you just need to pay attention to the haddocks =)
10:52:43 <bitonic> mm_freak_: well using them is easy, defining them less
10:52:45 <mm_freak_> bitonic: if it says "depends: previous instant", you can use ArrowLoop safely =)
10:52:59 <mm_freak_> defining them isn't any more difficult than defining mfix
10:53:57 <mm_freak_> SP might be isomorphic to Auto, for which it's easy to define 'loop'
10:54:30 * hackagebot delaunay 0.1.0.0 - Build a Delaunay triangulation of a set of points  http://hackage.haskell.org/package/delaunay-0.1.0.0 (MarcelRuegenberg)
10:56:19 <faulkner_> If anyone has time to glance at this wai middleware error http://hpaste.org/83802 I'd be glad for any help.  Am new to haskell and the doc has me expecting that lib to return a type Middleware but looks like it is type GzipSettings
10:57:48 <bitonic> mm_freak_: well last time we tried we elliott and you we couldn’t :P
10:58:37 <jmcarthur> @tell applicative it is as i said. Yoneda f and f are isomorphic *when f is a functor*, but Yoneda f is still a functor even if f is not
10:58:37 <lambdabot> Consider it noted.
11:02:03 <Saizan> Yoneda carves out of "f" a subset that you can map, CoYoneda instead is more like a synthetic functor
11:05:21 <notthemessiah> Oops, found a comonadic zipper that typechecks, but unwraps when I cobind anything to it.
11:05:53 <notthemessiah> and by unwrap, I mean it turns a finite list into an infinite list.
11:10:03 <mm_freak_> bitonic: any indication that 'loop' for SP is total?
11:10:10 <mm_freak_> i can come up with a nontotal solution
11:10:53 <bitonic> mm_freak_: I don’t know
11:11:04 <bitonic> mm_freak_: I could come up with a partial but somewhat sensible one as well
11:11:14 <bitonic> that was fairly straightforward iirc
11:11:37 <hpaste> “Ertugrul Söylemez” pasted “Partial ArrowLoop for SP” at http://hpaste.org/83804
11:12:40 <bitonic> mm_freak_: yeah.  but it’s partial
11:12:47 <mm_freak_> i don't think there is a sensible way to make this total…  you can do arbitrary look-ahead with the given input value at instant i
11:12:59 <mm_freak_> but when actually iterating the SP it might get a different input at instant i + 1
11:13:06 <mm_freak_> so it wouldn't be sound
11:13:09 <bitonic> mm_freak_: if you can prove that I’d like to have a word with Huges zxc
11:13:29 <bitonic> since he pretty much implies that a total definition is possible
11:13:53 <mm_freak_> it is possible, but it's not sound
11:14:11 <mm_freak_> let me explain the problem:
11:14:30 <mm_freak_> loop (Get f), where f might return another Get, which in turn needs an input
11:14:58 <mm_freak_> however there is no way to prefetch that input, because only the input to the current Get is available
11:15:17 <JuanDaugherty> was "notthemessiah" inspired by "notthemama" ?
11:15:34 <mm_freak_> the input to the next Get won't be available until the next instant, which is caused outside of the loop
11:15:47 <bitonic> yes I understand that.  I don’t think that your ‘arbitrary lookahead’ solution would be acceptable...
11:15:49 <mm_freak_> this is also precisely the reason why you can't map an SP to an Auto
11:16:22 <mm_freak_> this difficulty characterizes the difficulty to define 'loop'
11:17:50 <mm_freak_> i ran into a similar problem with netwire:  'loop' for Wire is nontotal…  it fails precisely when the wire inhibits, in which case the feedback value is not available
11:18:30 <mm_freak_> this causes a runtime exception
11:18:47 <notthemessiah> JaunDaughert: Nope: http://en.wikipedia.org/wiki/Monty_Python%27s_Life_of_Brian
11:19:06 <dario> @pl \[a,b] -> (a,b)
11:19:07 <lambdabot> (line 1, column 2):
11:19:07 <lambdabot> unexpected "["
11:19:07 <lambdabot> expecting pattern
11:19:19 <notthemessiah> s/t/ty/
11:19:56 <bitonic> mm_freak_: well the bottom line is that I’m not satisfied!  I should email Huges
11:20:20 <mm_freak_> do it =)
11:24:43 <JuanDaugherty> notthemessiah, also not "Jaun". notthemama is funnier.
11:38:07 * JuanDaugherty never like teH pythongs
11:38:46 <notthemessiah> > "notthemama" > "notthemessiah"
11:38:47 <lambdabot>   False
11:39:16 <mami> ?src (map)
11:39:17 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:39:31 * hackagebot delaunay 0.1.0.1 - Build a Delaunay triangulation of a set of points  http://hackage.haskell.org/package/delaunay-0.1.0.1 (MarcelRuegenberg)
11:39:32 <notthemessiah> JuanDaugherty: Okay, lambdabot disagrees with you.
11:42:03 <applicative> jmcarthur: yes I realized about yoneda after bitonic stated the obvious
11:42:03 <lambdabot> applicative: You have 1 new message. '/msg lambdabot @messages' to read it.
11:47:22 <JuanDaugherty> *liked
11:48:21 <FireFly> > "notthemessiah" > "*"
11:48:23 <lambdabot>   True
11:48:54 <applicative> the cs crowd uses the word 'strictly' in the strangest way: "  ResourceT is strictly more powerful than bracket ..., " as if we were likely to understand 'more powerful' to mean >= not >
11:50:20 <applicative> or 'this way of writing the function is strictly worse" than another....
11:51:12 <byorgey> applicative: I think in that context 'strictly' is simply used as a sort of intensifier
11:51:20 <byorgey> i.e. you could replace 'strictly' with 'quite a bit'
11:51:25 <byorgey> it is indeed a very odd usage.
11:51:35 <applicative> byorgey: yes, that is the ground of my accusation of incompetence and vulgarity
11:51:59 * byorgey is probably guilty of using 'strictly' in that way too, but promises not to anymore
11:53:01 <byorgey> hmm, actually, on the other hand you could read it as highlighting the fact that a technical rather than qualitative statement is being made.
11:53:17 <byorgey> i.e. "ResourceT is more powerful than bracket" might be read as "it's easier to get stuff done with ResourceT"
11:53:37 <byorgey> whereas "strictly more powerful" definitely means "you can do stuff with ResourceT which you provably can't with bracket"
11:54:22 <applicative> i think in the use about resourcet that is sort going on
11:54:32 <applicative> sort of
11:55:13 <byorgey> (this interpretation clearly doesn't apply in your second example, however)
11:55:53 <byorgey> In the second example, I would interpret it as implying something like "worse in every possible category", as opposed to "worse in some ways and better in others, but worse overall"
11:57:33 <bitonic> ‘strictly positive’ is the best strictly, clearly
11:58:36 <bitonic> it’s strictly the best usage of strictly
11:59:41 <jmcarthur> "more powerful" could just mean "more powerful in some ways, weaker in others" whereas "strictly more powerful" would mean "can do everything the other can do and more"
12:00:39 <aristid> yeah i'd read "strictly more powerful" as "there are no ways at all in which the other is less powerful"
12:01:03 <bitonic> ‘deepseq is strictly stricter than seq’
12:01:26 <byorgey> hahaha
12:01:37 <byorgey> @remember bitonic deepseq is strictly stricter than seq
12:01:37 <lambdabot> It is stored.
12:01:52 <bitonic> :)
12:02:05 <aristid> should be called strictseq
12:02:33 <applicative> yes, I was thinking f is strictly greater than g might be read as for all x, f x is greater than g x
12:02:50 <applicative> but that would need a bit of stage setting to make sense
12:04:14 <applicative> isn't there another epithet typically used by mathematicians for that sort of case though?
12:04:23 <applicative> uniformly x doesn't seem right
12:13:32 <ziman> is there a way to -hide-package in runhaskell? (or make runhaskell respect the cabal file or .ghci)
12:16:01 <quchen> What convention to you guys use for record fields? I've seen "_foo" and "foo_", is there some (other?) convention I should stick to?
12:16:29 <tdammers> I think _foo is pretty standard for lensified record types
12:16:32 <Eduard_Munteanu> _foo is a 'lens' convention.
12:16:47 <bitonic> quchen: fooBar where ‘foo’ is the name of the datatype or abridged version
12:16:55 <bitonic> and Bar is the name of the field
12:17:01 <bitonic> only sane way imo
12:17:05 <tdammers> yeah
12:17:17 <Eduard_Munteanu> Hungarian notation?
12:17:20 <quchen> bitonic: Makes sense in a non-lens context, yes
12:17:29 <bitonic> Eduard_Munteanu: no, ‘foo’ has nothing to do with the type of the field
12:17:40 <bitonic> ‘foo’ is the name of the record
12:17:40 <tdammers> it is hungarian, in the wider sense
12:17:41 <Eduard_Munteanu> Err, yeah, nevermind.
12:17:58 <bitonic> Eduard_Munteanu: but yes Hungarian is cool
12:18:11 <tdammers> and it wouldn't be necessary if we could get type-scoped record members
12:18:20 <Eduard_Munteanu> I thought people hated it.
12:18:22 <tdammers> or use the type name to qualify accessors or something like that
12:18:27 <bitonic> Eduard_Munteanu: I know.  I don’t
12:18:32 <tdammers> people do hate it
12:18:53 <bitonic> most haskell people use an extreme version of hungarian without realising
12:19:13 <quchen> data Foo = Foo { fooBar :: Bar }
12:19:25 <quchen> Like this, right?
12:19:26 <bitonic> it goes like this: ‘assign a 1 to 3 letters identifier to each type, and use that or variations for each variable of that type’
12:19:29 <bitonic> quchen: right
12:19:33 <bitonic> no sorry
12:19:43 <bitonic> data Foo = Foo { fooWhatBarIs :: Bar }
12:19:54 <tdammers> if we could have data Foo = Foo { bar :: Int }, and then use Foo.bar to access the bar accessor, all would be peachy
12:20:03 <bitonic> data Person = Person { personName :: String, personAge :: Age }
12:20:48 <bitonic> we should just have first class modules and records are automatically modulised
12:20:52 <bitonic> see, guess what, Agda
12:21:22 <bitonic> and local opening of modules
12:21:29 <tdammers> another solution I've come across is "one type per module"
12:21:50 <bitonic> tdammers: nooooooooo
12:21:57 <tdammers> :D
12:22:14 <tdammers> I've come to realize how impractical it is in reality, don't worry
12:22:43 <bitonic> who is it that always does that Module.T business?
12:22:54 <bitonic> and even took old packages and converted them to that
12:23:04 <tdammers> .T is horrible
12:23:11 <bitonic> <http://img.photobucket.com/albums/v31/GoodLuckBear3/I%20got%20some%20Gifs/THEOFFICEmichaelnooooo.gif>
12:23:20 <tdammers> Foobar.Foobar is bearable though
12:23:28 <tdammers> a bit pythonic, but I think I can live with that
12:23:42 <bitonic> there’s also the dreaded modules-with-rankntypes
12:24:04 <tdammers> yeah well, sometimes two types absolutely have to be in the same module
12:24:28 <applicative> Henning Thielemann yeag
12:24:46 <bitonic> applicative: yes, him!
12:25:12 * applicative doesn't believe in records anyway
12:25:29 <bitonic> applicative: they exist, I can assure you
12:25:51 <tdammers> just use tuples for everything
12:26:01 * applicative would accept them in a system with a data codata distinction. 
12:26:09 <tdammers> or import Acme.PHP and use strings
12:26:09 <bitonic> <http://hackage.haskell.org/packages/archive/haskore/0.2.0.3/doc/html/Haskore-Composition-Chord.html> yeeee every type is T!
12:26:36 <bitonic> applicative: where codata = records?
12:26:53 <bitonic> welcome to Agda with copatterns
12:27:05 <applicative> yeah, there was a convincing argument for that in some recent paper
12:27:19 <applicative> yeah the copatterns follow it, but agda also has meaningless records
12:27:28 <bitonic> records are useful for other things as well in those system, you can formulate η laws straightforwardly for example
12:27:56 <bitonic> I mean the η laws can be generated automatically
12:28:33 <applicative> maybe, I think what they mean is opaque
12:28:34 <bitonic> if `Foo { one : One, two : Two}' you get `x : Foo ⊢ x ≡ Foo (one x) (two x)' for free
12:29:04 <bitonic> where ≡ is the type checker equality
12:29:32 * hackagebot hspec-jenkins 0.1.0 - Jenkins-friendly XML formatter for Hspec  http://hackage.haskell.org/package/hspec-jenkins-0.1.0 (KoheiSuzuki)
12:29:46 <bitonic> applicative: I think it’s a compact way of defining construction and destruction at the same time
12:31:03 <applicative> yes, but the relation between them is not at all understood, so using records to define a type is basically opaque
12:31:41 <bitonic> applicative: what do you mean it’s not understood?  those equations that you can generate are very simple
12:32:30 <bitonic> they don’t tell you the whole story but it’s better than not having records
12:32:34 <applicative> Well, if you assume you are working with data you can derive either from the other; and if you assume you are working with codata, you can derive either from the other
12:33:09 <bitonic> applicative: no you can’t - those laws concern the equality for terms that the type checker has
12:33:17 <bitonic> this is completely irrelevant to Agda btw :P
12:33:20 <applicative> haskell, unlike agda, has real records :)
12:33:57 <bitonic> sorry, I meant ‘this is completely irrelevant to Haskell’
12:34:05 <bitonic> since equality of terms doesn’t matter
12:34:37 <bitonic> wait how are Agda records less ‘real’ :P?
12:34:41 <linduxed> let's say i've got a comma separated string which i'd like to use splitWith on, but there are some commas that are enclosed in quotation marks, which need to be skipped
12:34:50 <linduxed> how could i do this?
12:35:00 <linduxed> a sample string would be:
12:35:14 * applicative was toying with bitonic, thinking since everything in haskell is 'codata' defining a type by a record is a better fit with it
12:35:18 <linduxed> arst,123,,,515,"Hello, sir",123
12:35:45 <linduxed> the comma after Hello shouldn't be considered to be a separator
12:35:46 <bitonic> applicative: ehe ok
12:39:34 <geekosaur> linduxed, probably a CSV module would be easiest, you don't need to reinvent that wheel
12:44:08 <hpaste> tac pasted “Applicative Help with Data.Aeson” at http://hpaste.org/83807
12:44:22 <tac> Can anyone help me out with this simple applicative problem? ^
12:44:45 <tac> I know how to do it monadically, but I can't seem to get it working with just the applicative combinators
12:45:52 <tac> (I have written FromJSON instances for each of the four types neccesary, so those calls to parseJSON are defined elsewhere)
12:51:22 <tac> no one's around? :(
12:52:38 <supki> tac: why do you need explicit parseJSON ?
12:52:54 <twomashi> `nand`: you there? you wrote this earlier
12:52:54 <twomashi> repeatedly $ request randomIO >>= yield :: Random o => Machine IO o
12:53:01 <twomashi> whats the `request` ?
12:53:45 <tac> supki: what do you mean?
12:54:23 <hpaste> supki annotated “Applicative Help with Data.Aeson” with “Applicative Help with Data.Aeson (annotation)” at http://hpaste.org/83807#a83808
12:54:31 <supki> I mean something like this usually works
12:56:09 <tac> well, supki, great. I feel retarded now
12:56:19 <tac> Thanks. I don't know why I wasn't seeing that.
12:57:35 <`nand`> twomashi: I refactored it as ‘pass randomIO’, since that's a helper function which does exactly that :)
12:58:09 <`nand`> twomashi: but ‘request x’ is a plan that, essentially, requires ‘x’ to continue producing
12:58:28 <`nand`> in the case of IO actions, it means “to continue producing, you need to run this IO action first”
12:59:08 <`nand`> in the case of something else eg. functions (‘request id’), it could mean “to continue producing, I need this piece of input delivered to me first”
13:02:58 <twomashi> `nand`: do you think you could write a simple machine that returns values from Maybes?
13:07:23 <`nand`> you mean something like a Process (Maybe a) a --?
13:08:15 <fro0t> join #fpga
13:08:39 <twomashi> Yea
13:09:02 <twomashi> Just something working that I can (try to) adapt to my needs
13:09:55 <twomashi> I have my program working but have decided I will need some sort of iteratee like abstraction
13:10:42 <twomashi> and I'd like to use whatever gives me the greatest chance of being able to fully grok it at some point, so for want of a better metric, I'll take whatever has less LOC :)
13:10:53 <twomashi> given that I can't use unsafeInterleaveIO, haha...
13:11:28 <twomashi> hm I guess documentation is another thing… Machines has basically none
13:12:44 <hpaste> “Ertugrul Söylemez” pasted “Simple expression type” at http://hpaste.org/83809
13:13:07 <tac> Err... why does this return Nothing?
13:13:08 <tac> decode "\"def\"" :: Maybe String
13:13:14 <tac> > decode "\"def\"" :: Maybe String
13:13:16 <lambdabot>   Not in scope: `decode'
13:13:31 <tac> decode "\"def\"" :: Maybe Value returns Nothing too....
13:13:38 <geekosaur> check the aeson docs
13:13:39 <`nand`> ooh, this one's elegant
13:13:46 <`nand`> twomashi: repeatedly $ await >>= traverse yield
13:13:50 <geekosaur> IIRC the top level thing *must* be an object per json spec
13:13:59 <`nand`> that works for all traversable containers :D
13:14:29 <`nand`> now back to working on the presentation due tomorrow
13:14:29 <geekosaur> http://hackage.haskell.org/packages/archive/aeson/0.6.1.0/doc/html/Data-Aeson.html#g:6
13:14:57 <twomashi> ok, cheers! good luck
13:15:06 <geekosaur> ok, object or aggregate
13:17:58 <linduxed> geekosaur: hmm, true
13:19:10 <tac> yeah... that's obnoxious. I want to test my parser piece by piece and there's no obvious way to parse anything other than those :(
13:20:34 <stephanie88> hi, I need some help, is anyone available?
13:21:15 <geekosaur> tac, the section of manual I pointed you to indicates http://hackage.haskell.org/packages/archive/aeson/0.6.1.0/doc/html/Data-Aeson-Parser.html#v:value
13:21:20 <tac> I found a workaround
13:22:00 <tac> indicates? It's more like "hints at" *grumbles*
13:22:30 <tac> anyway, I can parse non-object, non-string things by sticking whatever I want between [ ... ] and parsing it as a list
13:22:54 <JuanDaugherty> stephanie88, it's bad form to ask to ask on irc
13:23:09 <JuanDaugherty> just ask
13:25:52 <adek> I have record type with ten fields. Can I pattern match its constructor without listing 10 '_' after it?
13:26:15 <supki> Foo {}
13:27:21 <adek> supki: amazing. Thank you!
13:29:42 <wunki> would it be possible to check if a module contains a certain function? If not, fall back to default fn.
13:34:20 <edwardk> quchen: i use _foo because then if i don't export it (and don't lens it) then the compiler doesn't complain
13:44:34 * hackagebot idris 0.9.7 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.7 (EdwinBrady)
13:51:32 <mietek> What's a good option for HTML scraping in Haskell? ndm's TagSoup?
13:53:48 <maltem> Is there any other option? :)
13:54:04 <mietek> Python and BeautifulSoup, for one
13:54:40 <maltem> well, "in Haskell" you asked
13:55:41 <maltem> I meant, I don't know of any web scraping Haskell library other than tagsoup
13:56:28 <mietek> http://egonschiele.github.com/HandsomeSoup/
13:56:42 <mietek> http://codingtales.com/2012/04/25/scraping-html-with-handsomesoup-in-haskell
13:56:51 <mietek> This looks interesting
13:58:52 <merijn> mietek: ttp-conduit combined with xml-conduit/html-conduit worked ok for me in the past
13:59:16 <merijn> eh, http for the first one, that is
13:59:21 <mietek> merijn: sounds like a lot of work :)
13:59:27 <maltem> Ok so as it turns out, there's indeed more also tagchup on hackage (if you're fine with Henning's naming conventions)
14:00:14 <merijn> mietek: Sounds like more than it is, the former has an action to fetch a URL and get a ByteString, the latter returns on a nicely traversable XML/HTML structure for that ByteString
14:00:31 <mietek> Thanks, perhaps I'll try that as well
14:02:24 <merijn> http-conduit has "simpleHttp :: MonadIO m => String -> m ByteString" and html-conduit has "parseLBS :: ByteString -> Document", then you can use XSLT like traversals to navigate the Document
14:03:03 <merijn> (Document and the function on it are defined in xml-conduit's Text.XML modules)
14:04:32 <quchen> Is there some way for strong emphasis (-> bold) in Haddock? / is only italics, which is not very well suitable for explaining abbreviations (as in HD = /H/ard/D/rive).
14:04:58 <mietek> quchen: Perhaps _H_ or *D*?
14:05:26 <quchen> mietek: Nope, tried them both already :-(
14:06:05 <monochrom> no, haddock provides no bold
14:07:19 <hpaste> NOTtheMessiah pasted “Comonadic Life on a Torus” at http://hpaste.org/83811
14:08:23 <notthemessiah> Oops, just noticed I divided by zero in my notes in sum [a^n / n | n <- [0..]]
14:10:23 <edwardk> notthemessiah: to make a cycle you need to talk in terms of combinatorial species.
14:10:49 <edwardk> if you had only the ability to randomly pick a starting point and from there you got the cyclic list, that would represent the quotient
14:10:50 <bxc> anyone know offhand what the status of haskell on raspberry pi is these days?
14:15:39 <nomeata> bxc: doesn’t stock Debian run on the pi? It comes with most of the packages haskell libraries, only TH-depending stuff is missing
14:17:23 <joeyh> anyone know why runghc Setup.hs is behaving differently than cabal configure for me?
14:17:30 <joeyh> I'm getting different flags selected
14:17:37 <notthemessiah> Googling turns up a library for it.
14:17:41 <notthemessiah> @hackage species
14:17:41 <lambdabot> http://hackage.haskell.org/package/species
14:18:01 <geekosaur> joeyh, runghc Setup.hs uses --global by default
14:18:07 <geekosaur> cabal uses --local
14:18:08 <nomeata> joeyh: I don’t know the reasons, but I have made similar observations as well
14:18:27 <geekosaur> and if that means different libraries/versions visible, that can affect flag solving
14:19:04 <joeyh> aha!
14:20:05 <monochrom> it is because Cabal authors expect normal people to use cabal-install and linux distro creators to use Setup
14:20:24 <monochrom> the expectation is documented nowhere
14:22:07 <monochrom> next, defaults in ~/.cabal/config reflects more expectations in the early days, too
14:22:29 <fro0t> bxc: GHC 7.4.2 apparently supports ARM & therefore R Pi
14:22:58 <monochrom> documentation: False; library-profiling: False
14:23:08 <fro0t> bxc:http://alenribic.com/posts/2012-08-06-running-haskell-on-raspberry-pi.html
14:23:22 <monochrom> in the early days, it was expected that people use cabal-install for xmonad only
14:30:09 <bxc> fro0t: ok. still no ghci and th then
14:32:15 <`nand`> GHCi really needs to be ported to more platforms
14:32:19 <`nand`> it's one of haskell's most invaluable tools
14:32:36 <fro0t> bxc: ref: the article .. looks like GHCi is supported on 7.4.2
14:34:17 <chrisdone> shachaf: http://ircbrowse.net/social
14:35:20 <joeyh> similarly, ghc is running on android, no ghci or TH yet though
14:35:46 <`nand`> chrisdone: the most popular man alive
14:36:26 <chrisdone> `nand`: shachaf loves being popular, it's so easy
14:37:01 <`nand`> astonishingly inefficient though, it runs at some fraction of 1 fps for me and slows down my browser to a near standstill while fully loading the CPU core it's running on
14:37:20 <joeyh> otoh, I have a debian armel with ghc 7.6.2, and ghci fails with ""ghc: unable to load package `ghc-prim'
14:37:40 <chrisdone> `nand`: firefox user?
14:37:43 <`nand`> chrisdone: yes
14:37:46 <chrisdone> teehee
14:38:07 <chrisdone> ヽ (  ＾▽＾)ﾉ  *pats `nand` on head*
14:38:19 <`nand`> it's okay, I'll just disable javascript again
14:39:48 <chrisdone> thinking of replacing it with graphviz actually, while the boingyness is cute it's a bit unwieldly and i couldn't figure out how to change the thickness of the edges with this lib
14:40:32 <`nand`> also, it doesn't help that not all the graph is visible at once
14:41:20 <chrisdone> that's what i meant by unwieldly
14:43:30 <Mathnerd314> hmm, so is there -XLinearTypes ?
14:43:46 <bitonic> chrisdone: I’m not there :(
14:43:51 <bitonic> Mathnerd314: ehe.  no.
14:44:40 <chrisdone> bitonic: you're not there because you don't talk to people directly enough, and no one talks to you =p
14:44:49 * chrisdone checks
14:44:52 <bitonic> chrisdone: that’s sad
14:44:54 <`nand`> chrisdone: not being able to see the entire thing at once is also probably not a good thing
14:45:10 <`nand`> oh
14:45:13 <`nand`> I already said that, excuse me
14:45:39 <`nand`> (I just suffered from a catastrophic graphics driver error and when I recovered the end of my backlog got chopped off so I forgot I already wrote that)
14:46:52 <chrisdone> bitonic: since the start of jan you've spoken to 89 people, edwardk, elliott and Lethalman the most. just trailing behind a bit =)
14:47:10 <edwardk> heh
14:47:13 <bitonic> chrisdone: ehe OK
14:47:26 <Mathnerd314> hmm, I show up pretty big here: http://ircbrowse.net/nick-cloud
14:47:32 <Mathnerd314> but I don't see me on the graph
14:48:16 <edwardk> man i'm not at the top of the list. clearly i need to move more conversations from #haskell-lens to #haskell
14:48:19 <`nand`> such a hipster, not speaking to shachaf
14:48:53 <chrisdone> Mathnerd314: yeah the graph is *just* whether you've been referenced like "Mathnerd314: hi" or you referenced other people… but the graph is just showing the top 100 weighteist edges
14:48:54 <bitonic> I need to move from -blah and #agda to here
14:51:07 <bitonic> chrisdone: is this since the beginning?
14:51:20 <bitonic> (of the tunes logs)
14:51:23 <bxc> fro0t: oh yes, i see - sorry i misrad.
14:51:24 <bxc> misread
14:51:26 <chrisdone> bitonic: this is just 2013
14:51:29 <Hafydd> Why are some of them sideways? <_>
14:51:30 <bitonic> ah, OK
14:51:33 <chrisdone> otherwise dons would own all your asses
14:52:25 <Hafydd> Whoever thought that was a good stylistic choice: consider that it isn't.
14:52:59 <bitonic> chrisdone: damn I missed the dons period of haskel
14:52:59 <bitonic> l
14:53:04 <bitonic> #haskell
14:53:10 <chrisdone> hmm. generating the graph is quite fast actually. takes 27 secs to generate for all 2012
14:54:35 <fro0t> bxc:cool
14:57:22 <danharaj> I wonder how the nick word cloud would look without log scaling.
14:58:16 <chrisdone> danharaj: by analogy, basically lambdabot looks like the sun, edwardk looks like earth, and everyone else looks like cornwall
14:58:23 <danharaj> haha
14:59:10 <chrisdone> actually you can see on the most active nicks bit, the top few are double the rest
14:59:14 <chrisdone> http://ircbrowse.net/
14:59:54 <mapreduce> cornish pasties
15:00:00 <chrisdone> mapreduce: yum
15:00:59 <aristid> > 1385+1371
15:01:01 <lambdabot>   2756
15:01:06 <aristid> hmm
15:01:30 <aristid> still less than edwardk
15:01:30 * typoclass will look like rory mcgrath. (is that the next step down from cornwall?)
15:02:10 <chrisdone> it is =)
15:03:01 <mapreduce> rab c nesbitt
15:03:53 <aristid> i didn't know i was this closely affiliated with jmcarthur: http://ircbrowse.net/social
15:04:03 <chrisdone> aristid: only since janurary
15:04:27 <chrisdone> i'm currently trying to generate a graph of everything…
15:04:30 <aristid> but shachaf is at the center of the social hierarchy, clearly
15:04:38 <totimkopf> how come you can only bind several variables with let insidea tupe? ie:  (let a = 100; b = 200; c = 300 in a*b*c, let foo="Hey "; bar = "there!" in foo ++ bar)
15:04:41 <chrisdone> holy shit that's fast. my code is awesome
15:04:42 <totimkopf> s/tupe/tuple
15:04:53 <geekosaur> wat
15:05:26 <latro`a> totimkopf, that should work with braces
15:05:29 <geekosaur> totimkopf, when doing it all on one line you may sometimes need explicit braces
15:05:37 <chrisdone> lol, generated a graph of 346910 edges from 2001 to 2013
15:05:50 <aristid> oO
15:05:52 <totimkopf> so the it will only work inside a tuple or braces, correct?
15:06:12 <latro`a> you can bind several variables in a let without a tuple
15:06:13 <geekosaur> I don't know what a tuple has to do with anything
15:06:13 <aristid> chrisdone: do we have full logs for #haskell for all that time?
15:06:20 <chrisdone> well well, as expected. dons is in most of the top 10
15:06:24 <latro`a> > let {a = 2; b = 3; c = 4} in a*b*c
15:06:25 <lambdabot>   24
15:06:38 <totimkopf> aha
15:06:41 <geekosaur> if you have mutiple let-s on a single line, you probably need braces to disambiguate
15:06:55 <latro`a> if it's not on one line you can use layout instead of braces
15:06:59 <aristid> chrisdone: that was in the olden days when he was actually active here :P
15:07:00 <chrisdone> aristid: full logs. i expect there were some clog outages, but not much, judging from the consistency of the data
15:07:10 <aristid> chrisdone: that's cool
15:07:15 <geekosaur> tuple syntax and some other syntaxes may well help with that, but there's nothing specific to braces about it
15:07:23 <geekosaur> rt, to tuples
15:07:52 <geekosaur> haskell syntax tends to assume that you are using layotu to your advantage; if you aren't, you'll often need to use braces to make up for it
15:08:18 <geekosaur> think of it as the language saying "quit doing everything on one line already"
15:08:25 <totimkopf> haha
15:08:28 <totimkopf> I gotcha
15:09:30 <chrisdone> ok, here's the top 100 most weighted edges of all 12 years: http://ircbrowse.net/social
15:09:43 <merijn> hey...I'm pretty popular according to those graphs \o/
15:09:57 <bitonic> Cale and dons
15:10:15 <chrisdone> shapr was there in the early years
15:10:21 <bitonic> and the shapr-sorear-dcoutts triangle
15:10:21 <totimkopf> Prelude>  let {a = 100; b = 200; c = 300} in a*b*c, let {foo="Hey "; bar = "there!"} in foo ++ bar what's up 2 lets on one line not working?
15:10:25 <chrisdone> still here now, but a lot more then
15:10:28 <chrisdone> yeah
15:10:40 <chrisdone> dcoutts and dons spoke the most
15:10:57 <totimkopf> <interactive>:23:41: parse error on input `,'
15:11:04 <merijn> Now dons just ports pictures of sunsets :p
15:11:13 <merijn> eh, s/ports/posts
15:11:27 <geekosaur> um
15:11:38 <geekosaur> you seem to be somewhat confused as to what makes a valid expression
15:11:39 <bitonic> mauke and preflex!
15:11:53 <geekosaur> > 1+2, 2+3 -- minus the lets
15:11:54 <lambdabot>   <hint>:1:4: parse error on input `,'
15:11:58 <totimkopf> oh duh, the comma was from when it was inside a tuple!
15:12:00 <`nand`> bitonic: floating off in their own little island
15:12:11 <bitonic> that’s a bit sad as well
15:12:15 <chrisdone> haha
15:12:20 <bitonic> mauke talks to robots
15:12:42 <Ericson2314> Is there any function to combine to Sets, and use a function to merge conflicting elements? something like (a -> a -> a) -> Set a -> Set a -> Set a
15:13:00 <chrisdone> hm yeah i think i'll generate it in future so that everyone is linked
15:13:44 <chrisdone> http://ircbrowse.net/exports/social.csv
15:13:49 <chrisdone> that's the graph of the top 1000 =]
15:14:09 <chrisdone> i think with graphviz i could make a MASSIVE image :D
15:15:40 <chrisdone> chrisdone	mmorrow	490
15:15:40 <chrisdone> ;_; i miss mmorrow
15:15:40 <bitonic> Ericson2314: the thing with that function is that it wouldn’t be able to make assumptions on the ordering or the results of applying that function, so in terms of complexity the best you can do is with union+intersection+difference
15:15:43 <bitonic> *of the results
15:16:11 <bitonic> in other words you can’t simply replace `x' with `f x x' in the tree
15:16:30 <bitonic> (where `x' is something appearing in both sets)
15:17:01 <chrisdone> anyhoo, enough data binging, i'm off
15:17:13 <bitonic> NOW TALK TO ME I NEED HEAVIER EDGES
15:18:27 <Ericson2314> Also, does mapping a newtype constructor get completely removed with compilation?
15:19:24 <Ericson2314> pitty because they have a "fast-map"
15:19:39 <danharaj> newtypes are represented exactly as their contents at runtime
15:19:39 <Ericson2314>  for when you know the function you want to map is injective
15:20:51 <Ericson2314> That's what I head read, but well a lesser compiler might be misled by higher-order use of a newtype constructor
15:21:13 <bitonic> Ericson2314: also, 1) why does the function take 2 arguments? you know they are equal 2) the assumption would have to be that `f = id', so it wouldn’t be very useful would it?
15:21:46 <Ericson2314> well for map it is ID
15:22:15 <Ericson2314> here it woulnd't be so simple but I sure there is some function which doesn't mess up the ordering
15:22:17 <bitonic> Ericson2314: no, for the unsafe map the function has to be monotonic
15:22:19 <Ericson2314> in my case I would be sort of combining incomplete records
15:23:04 <Ericson2314> does monotonic => injective ?
15:23:25 <bitonic> Ericson2314: monotonic = `forall x. f x >= x'
15:23:44 <bitonic> but in this case it wouldn’t be enough because you’d be applying f only to certain elements
15:24:22 <Ericson2314> well my case is something like this:
15:24:24 <Ericson2314> compare (type a b c) (type a' b' c') = compare a a'
15:25:01 <Ericson2314> f (Type a b _) (Type a _ c) = (Type a b c)
15:25:10 <Ericson2314> a == a by the use of the function
15:25:23 <Ericson2314> that should be safe
15:25:42 <bitonic> actually sorry
15:26:16 <bitonic> monotonic there means that you preserve the ordering, so `x > y ==> f x > f y'
15:27:39 <bitonic> well that’s what monotonic always means
15:27:47 <niteria> agda like holes (I mean stuff like { }0) with context information could be done in haskell, right?
15:27:47 <Ericson2314> ok so any function x == y -> f x y == f y x == x == y
15:28:06 <parcs> hmm, is that equivalent to forall x. exists c. f x >= x + c ?
15:28:26 <merijn> niteria: HEAD has holes, not sure whether they are as flexible as Agda holes, though
15:28:27 <geekosaur> niteria, not in standard haskell although I believe there's an extension in GHC HEAD for it
15:28:29 <bitonic> niteria: <http://www.haskell.org/haskellwiki/GHC/TypeHoles>
15:28:43 <geekosaur> some cases can be done with implicit parameters, but not in type signatures
15:28:51 <crl> > let f n=snd (g n); g n=(f.f n,f n); g 0=(1,0) in g 10
15:28:53 <lambdabot>   No instances for (GHC.Num.Num (f0 a0), GHC.Num.Num (f0 (f0 a0)))
15:28:53 <lambdabot>    arising...
15:29:38 <bitonic> Ericson2314: I don’t understand why your function has to have two arguments if it gets called for ‘conflicting’ elements.  I assume you mean that it gets called for elements that are in both sets
15:29:39 <crl> (should be fibonacci)
15:29:50 <Ericson2314> yes, that is what i mean
15:29:57 <Ericson2314> elements with same rank in both sets
15:30:15 <bitonic> Ericson2314: so aren’t `x' and `y' always going to be the same?
15:30:41 <Ericson2314> no because my Ord only depends on certain fields of the structure
15:30:48 <bitonic> ah well I guess your `Ord' could return EQ for things that are not ‘definitionally’ the same
15:30:53 <Ericson2314> yeah
15:30:54 <bitonic> OK, fair enough
15:31:01 <Ericson2314> though perhaps that's a design flaw on my part
15:31:07 <Ericson2314> I am making a tar like utility
15:31:18 <Ericson2314> sometimes I want to "update" the files in the archive
15:31:36 <bitonic> Ericson2314: OK sorry for being slow.  so yeah, if your Ord is like that, that function could exist
15:31:37 <Ericson2314> sometimes I want to make sure my merge has no conflicts ie files with same name
15:31:52 <Ericson2314> no wories
15:32:03 <bitonic> I was assuming that `compare x y == EQ ==> x === y', sorry for being slow
15:32:12 <bitonic> it’s kind of a weird use case
15:32:19 <Ericson2314> exactly
15:32:33 <Ericson2314> I think I should change my default ord to be the mathematically proper ord
15:32:39 <bitonic> so yeah it could exist but it doesn’t
15:32:44 <Ericson2314> and do something else for the "update files ace
15:32:55 <Ericson2314> * updating files
15:33:23 <Ericson2314> anyways what makes this espeically weird is that the "ID" in this case is not the filename, but a particularly bad hash of the filename
15:33:41 <Ericson2314> so hash collisions happen all the time
15:34:36 * hackagebot hOpenPGP 0.6.1 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.6.1 (ClintAdams)
15:34:43 <niteria> nice, I must install HEAD locally some time, type holes, deferred type errors, so much good stuff
15:34:44 <Ericson2314> So i'd like to be able to: 1) update archive so that no colliding filenames or ids are introduced and 2) update some files with new version but still make sure that new ID conflicts exist
15:35:11 <Ericson2314> so ID conflicts are ALWAYS bad, Filename conflicts are SOMETIMES bad
15:35:43 <Ericson2314> The reason why I think a single set will work is that Filename comflict => ID conflict
15:35:45 <jmcarthur> aristid: that graph seems so wrong
15:36:32 <jmcarthur> oh it's the updated one even
15:36:39 <jmcarthur> i guess i haven't been around so long, in that case :)
15:39:36 * hackagebot TypingTester 0.1.0.0 - Command Line Typing speed tester  http://hackage.haskell.org/package/TypingTester-0.1.0.0 (AlanHawkins)
16:02:15 <tac> What are some decent options for interproces RPC done locally on a machine?
16:03:58 <typoclass> tac: pipes? sockets?
16:04:06 <typoclass> (fsvo decent)
16:04:10 <tac> yeah
16:04:17 <geekosaur> pipes are probably easiest, AF_LOCAL sockets next easiest. fifos have "weird" restrictions and e.g. doors etc. are not well supported
16:04:20 <tac> I guess I'm also looking for some interlanguage op, ideally
16:04:27 <Clint> zeromq?
16:04:30 <geekosaur> (or well documented, even for use from C)
16:04:45 <geekosaur> yeh, on a higher level, zmq or dbus could qualifty
16:05:12 <bxc> i've done json over pipes for some interlanguage communication, where i've cared more about ease of implementation and flexibility of language rather than efficiency
16:05:31 <geekosaur> to some extent, it depends on what you're planning to do with it; dbus is not suited to bulk data, for example
16:05:51 <tac> yeah
16:06:05 <tac> I just want it to shuffle commands between my IRC bot and the worker processes
16:06:41 <typoclass> geekosaur: tangentially, what are AF_LOCAL sockets? same as unix domain sockets? i kinda thought they are practically the same as fifos, except fifos are identified by a path in the filesystem
16:06:44 <bxc> geekosaur: what are "doors" ?
16:06:52 <typoclass> bxc: some solaris thingy
16:07:16 <geekosaur> typoclass, the standards folks decided calling local sockets AF_UNIX was not such a good idea on non-unix, thus AF_LOCAL
16:07:32 <bxc> typoclass: and thats enough for me to find the wikipedia page for it. thx
16:07:46 <typoclass> geekosaur: ooh i see
16:08:01 <geekosaur> bxc, doors are a lightweight IPC mechanism first trindocued on solaris but also present on linux. they are not very well documented on linux, you pretty much need to study the glibc source to find out how to use them
16:08:23 <geekosaur> *first introduced
16:08:55 <geekosaur> and sockets are in general better behaved than fifos
16:09:10 <bxc> tac: if you're ever expecting to move onto two machines, using IP sockets is probably not too much harder and gives you that flexibility
16:09:22 <donri> surely unix sockets are the easiest here, you can run a http server on that or whatever
16:09:29 <tac> hmm
16:09:37 <geekosaur> for example, with fifos your options are: you can read up to EOF and then have to close and re-open the fifo to reset, or you can open it r/w so you don't have to close and reopen but then you can't detect EOF
16:10:09 <bxc> a thousand ways to do a thousand subtly different things.
16:10:56 <Sgeo> bxc, like Ruby?
16:10:58 <Sgeo> I mean, hi.
16:11:10 <hpaste> Ericson2314 pasted “Set Problems” at http://hpaste.org/83814
16:11:25 <typoclass> geekosaur: very interesting, thanks a lot
16:13:31 <Ericson2314> fifos are also one way whereas sockets are bi-directional
16:13:38 <crl> @hoogle Control.Concurrent.CHP
16:13:39 <lambdabot> package chp
16:13:39 <lambdabot> package chp-mtl
16:13:39 <lambdabot> package chp-plus
16:13:58 <crl> for IPc there's maybe CHP ^
16:14:23 <tac> Do you create a local socket just by binding to localhost instead of *?
16:14:26 <crl> Communicating Haskell Processes
16:14:43 <tac> err rather, Inet_Any
16:16:53 <tac> errr v
16:16:55 <tac> iNADDR_ANY
16:17:03 <crl> dont know if it's relevant  though (http://www.cs.kent.ac.uk/projects/ofa/chp/)
16:17:27 * geekosaur considers, briefly, doing and documenting a doors binding just so they are first usable from haskell... but suspects they're quiet about it for good reason (like, say, it sucks if there are more than 3 users or something)
16:18:58 <edwardk> doors?
16:19:11 * edwardk thinks BBS doors, which is probably not right. =)
16:19:17 <crl> oh, thaat's not only haskell processes?
16:19:31 <geekosaur> [10 19:07] <geekosaur> (...) doors are a lightweight IPC mechanism first introduced on solaris but also present on linux. they are not very well documented on linux, you pretty much need to study the glibc source to find out how to use them
16:19:41 <edwardk> oh IPC.
16:19:56 <geekosaur> (and the solaris docs are of only limited use as the linux doors are naturally somewhat different)
16:20:19 <edwardk> that makes a lot more sense =)
16:20:51 <Ralith> edwardk: btw, llvm-st is now fairly complete, minus the odd instruction builder binding
16:21:00 <edwardk> fair enough
16:21:13 <edwardk> i'll pass it along to the guy who is talking the llvm query compiler for analytics
16:21:17 <Ralith> I still haven't succeeded in getting ahold of bos re: maintainership of llvm-base so I can actually put it on hackage, though
16:21:19 <edwardk> er tackling
16:21:34 <Ralith> cool
16:21:53 <Ralith> will be very interested in any feedback
16:22:47 <Ralith> (to be clear, it depends on some fixes to llvm-base, as well as my llvm-wrapper package, but maintenance for llvm-base is MIA)
16:24:08 <typoclass> tac: here is a simple program i wrote to talk to a unix domain socket (to look at status from the wpa_supplicant daemon) http://hpaste.org/83816 . you're probably most interested in main. no idea if this is correct or stylistically awesome, but i works for me
16:24:17 <tac> ty typoclass
16:24:33 <eikke> Ralith: yeah, so I noticed too
16:24:54 <eikke> there's some trivial pull requests for llvm 3.1 compat etc, but they weren't merged last time i checked
16:25:09 <Ralith> I've got fixes up to 3.3 sitting ignored in a pull request
16:25:17 <Ralith> one which has been pending for almost six months now
16:25:22 <eikke> hmh
16:25:47 <Ralith> I finally emailed bos a week or so ago asking for maintainership of llvm-base, but I haven't heard back
16:25:54 <eikke> I managed to get things to build on my system some time ago, but then at runtime stuff failed (something about the engine not being linked in, had no clue how to fix though :( )
16:26:20 <Ralith> you probably needed to call the native target initialization function
16:26:26 <Ralith> common error when using the JIT
16:26:37 <eikke> Ralith: i did that
16:26:43 <typoclass> tac: also, i need to fix that program, since it tends to spam /tmp/ with its old files (= sockets). but i assume that will simply be an "on exit, remove file"
16:27:05 <Ralith> oh wait I remember
16:27:09 <Ralith> there's another thing you have to do for linking
16:27:14 <tsinnema> edwardk, i first ran into Category.Monoidal via google which pointed me to an old version that has a 'HasIdentity'. the current version doesn't -- might you be able off the top of your head to give some clue of why there is this difference? (i am a newbie to both haskell and category theory, but i happen to be doing something for which monoidal categories might be useful and i might also be interested in implementing that stuff
16:27:14 <tsinnema>  to scalaz, hence the interest)
16:27:24 <Ralith> might be a bindings-side error
16:27:28 <eikke> Ralith: the demos from the package didnt work either, so had to be something else
16:27:30 <Ralith> I don't use the JIT so I can't say for sure
16:27:46 <Ralith> anyway, you can use https://github.com/Ralith/llvm in the meantime
16:28:11 <Ralith> note that I don't maintain the high level stuff, all those type system shenanagans are beyond me
16:28:21 <tac> typoclass: I think I have a working solution that fits with what I have already. But ty for the code example
16:28:24 <Ralith> also not of interest to me, since they severely constrain what you can use it for
16:28:39 <tac> UNIX sockets are usually what people use for services, right? Like SQL servers, etc, right?
16:29:08 <eikke> Ralith: interesting, thanks, will try using your fork
16:29:37 <Ralith> you may actually want to use https://github.com/Ralith/llvm-st which is a safe, medium-level interface
16:30:01 <Ralith> (which depends upon llvm-base and llvm-wrapper from the other repo)
16:31:11 <eikke> Ralith: I'd be glad if the base bindings would work first ;)
16:31:28 <Ralith> ^^
16:31:29 <typoclass> tac: i'd guess that sql servers talk typically via tcp. if the authors of an sql server were sure that client programs will always be on localhost, they'd probably use unix domain socket
16:31:42 <tac> hm
16:31:44 <tac> gotcha
16:33:12 <tsinnema> edwardk, oh actually now i see the associated Id type. that explains it i suppose
16:33:52 <edwardk> tsinnema: glad i could help =)
16:34:02 <tsinnema> hehe
16:38:50 <crdueck> would it be possible to use a haskell web framework like snap, happstack or yesod to run a SQL server? I'm not familiar with any of the frameworks, so I'm not sure if they can be used for things besides serving HTML
16:39:13 <stepkut> crdueck: yes
16:39:25 <crdueck> stepkut: any examples?
16:39:51 <stepkut> crdueck: what do you mean by 'run a SQL server'
16:40:36 <crdueck> stepkut: basically accept connections, recieve requests, build a SQL statement and execute it with a database backend, then process and serve the results
16:40:40 <stepkut> there are quite a few bindings to popular SQL servers for Haskell.. to use them in a web application, you don't really have to do anything special
16:41:34 <crdueck> stepkut: I'm aware of HDBC and the like, but I'm wondering if I can get a framework to do all the work of handling resources, accepting connections and serving responses
16:41:35 <bxc> typoclass: mysql does either local domain socket or tcp
16:41:43 <stepkut> some of the SQL libraries are very straight-forward bindings to SQL, where you pass in SQL query strings.. other libraries, like haskellDB, aim to create a type-safe abstration layer over SQL, and other libraries, like acid-state, aim to replace SQL entirely with a native, type-safe haskell persistence layer
16:42:10 <typoclass> crdueck: if by "receive requests" you mean http, then i guess you can use those frameworks. if it's simpler (requests via tcp?) you don't even need those
16:42:12 <typoclass> bxc: right
16:42:13 <eikke> Ralith: that's quite a diff you got there, will take some time to review I guess :)
16:42:34 <stepkut> crdueck: you just want some sort of HTTP glue layer over top of a SQL server?
16:42:55 <Ralith> eikke: it wasn't so large when it started, but six months of work will tend to build up.
16:42:59 <Mathnerd314> what was that github repo which implemented a langauge with negative and fractional types? I think its name has a few Greek letters in it
16:43:04 <eikke> Ralith: sure
16:45:23 <crdueck> stepkut: I dont want to use HTTP. I dont have a completely specific idea of what I'd be using this for, I just want to know if its reasonably easy to use a web framework to serve SQL results on a socket instead of HTTP
16:45:39 <Clint> "yes"
16:46:01 <stepkut> crdueck: you want to use an HTTP server to server something that is not HTTP?
16:46:12 <eikke> "yes but sounds nuts to me"
16:47:13 <Ralith> crdueck: perhaps you want something other than a web framework.
16:47:49 <typoclass> crdueck: are you familiar with (e.g.) the command-line client tool that comes with mysql? you can enter statements ("select ..."), it sends them to the server, runs them, and gives back the result table for display. would that be sufficient?
16:47:51 <crdueck> stepkut: like I said, I'm not familiar with any of the frameworks. I dont know how tightly coupled the frameworks are to HTTP. I thought it would be possible to use the core parts of the framework (accepting requests, processing and serving responses) for my purposes
16:48:33 <Clint> you can use persistent without the rest of yesod
16:48:35 <crdueck> typoclass: yes I am, but I need something much more sophisticated than that.
16:48:42 <eikke> crdueck: depending on the IO system you want to use, that can be really trivial (setting up a simple TCP server which accepts/forks/handles connections)
16:49:13 <stepkut> crdueck: not really.. and it wouldn't make much sense to.. almost everything in the frameworks is HTTP specific and based around the stateless model
16:49:28 <crdueck> stepkut: okay, then that answers my question. thanks
16:49:34 <stepkut> crdueck: accepting a request and sending a response is pretty darn easy..
16:50:42 <stepkut> something like, listonOn 1234 $ \listenSocket -> forever (do acceptedSocket <- accept ; forkIO $ handler acceptedSocket)
16:50:51 <fragamus_> :t Just Nothing
16:50:52 <lambdabot> Maybe (Maybe a)
16:50:54 <typoclass> crdueck: ok, so basically, you want to write a client for mysql (or whatever database), similar to the command-line client but with a more complex ui. i agree with stepkut, it doesn't seem like http is necessary for that. hence you can skip yesod, snap, etc.
16:50:58 <stepkut> and handler just uses read/write functions to read and write the socket
16:51:07 <eikke> crdueck: e.g. when using conduit, see https://github.com/snoyberg/conduit/blob/master/network-conduit/echo-server.hs
16:51:24 <niteria> is Conor McBride on irc?
16:52:12 <tac> niteria: His nick is pigworker
16:52:13 <stepkut> pipes-network is also nice, if you want to get away from the traditional strict/lazy IO module
16:52:24 <tac> niteria: I haven't seen him in a while though
16:52:41 <niteria> tac: ok, thanks!
16:53:11 <Mathnerd314> nvm, found it: https://github.com/dmwit/pi-eta-epsilon
17:01:36 <bitonic> niteria: the best way to contact him these days seems to be twitter
17:11:13 <jbu> hi all: I'm trying to understand monad transforms - as I understand it, you can stack these monads to combine as many as you want.  Where/what exactly is the mechanism that enables the stacking to occur?  I guess this question is a little vague because I'm fuzzy on really how it all works
17:22:32 <Saizan> jbu: there isn't a general mechanism, each transformer has it's own way to make it work, even if they tend to be similar
17:22:46 <Saizan> *its
17:26:34 <nexx> This pages http://www.haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html says "the -m* options specify machine-specific optimisations to be turned on/off", but it doesn't list any -m* options. What does that mean?
17:27:52 <typoclass> nexx: good question. if you don't get any answers, try asking on the ghc mailing list or irc channel
17:28:50 <nexx> ok thx
17:30:23 <nexx> #ghc topic says "Please ask user questions in #haskell" :o
17:30:45 <Saizan> nexx: i think those are the same as those you'd pass to a C compiler
17:30:50 <typoclass> nexx: urgh. sorry, i wasn't aware of that :-/
17:32:24 <nexx> Saizan even if the c code generator is not used?
17:32:31 <nexx> typoclass no problem
17:32:50 <Saizan> http://gcc.gnu.org/onlinedocs/gcc/i386-and-x86_002d64-Options.html <- like these
17:33:24 <Saizan> nexx: i guess some might have no effect with other backends
17:33:33 <nexx> ok thx
17:35:24 <Saizan> still it'd be worth to hear a ghc dev on this
17:40:03 <TravisD> I had a failed cabal install and now when I compile with ghc I get "ld: warning: directory not found for option '-L/opt/local/lib/". What might I do to fix this?
17:43:14 <fryguybob> nexx: As far as I can tell -msse (-msse2 and -msse4.2 in other versions) is the only -m flag: https://github.com/ghc/ghc/blob/master/compiler/main/DynFlags.hs#L2196
17:44:18 <xxen> thank you fryguybob
17:44:40 <fryguybob> Humm I guess that is -msse with some version suffix is allowed now.
17:47:06 <fryguybob> nexx: Also: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-platform.html
17:49:11 <nexx> fryguybob ah. thx
17:53:05 <leprauchan> I'm learning Haskell and can't decipher a compile error on this code: http://pastebin.com/Utqh6kTa
17:53:08 <mauke> The paste Utqh6kTa has been copied to http://hpaste.org/83819
17:53:16 <leprauchan> SHOOT
17:53:18 <leprauchan> Nevermind guys.
17:53:22 <leprauchan> I goof'd.
17:53:33 <leprauchan> I swear, I have been on this for over a half hour and I just found it.
17:53:45 <pharaun> it happens
17:53:58 <pharaun> leprauchan: nothing like searching for a broken semicolon somewhere
17:54:15 <typoclass> leprauchan: it's called rubberducking ;-) the moment you explain it to someone (e.g. rubber ducky), it becomes clear
17:54:17 <leprauchan> It was a brain fart. I was comparing a list and a single item.
17:54:29 <leprauchan> Yeah, I was about to mention the rubber duck treatment, lol. It seems to work.
17:58:07 <pharaun> good ol' rubber duck
17:58:19 <typoclass> a related software development technique is yelling at the rubber duck until your face turns purple
18:05:08 <lispy> "Why won't you answer me?!!?!?"
18:05:25 <lispy> "....oh wait, I know the problem. I'm ...."
18:06:48 <ZFox> lispy: hi
18:08:37 <lispy> ZFox: hi
18:08:54 * ZFox thinks he has what he is after!! :D 
18:08:56 <ZFox> (thinks)
18:09:16 <ZFox> lispy: What's with those quotes?
18:11:00 <lispy> what quotes?
18:12:25 <dmwit> The ones from five minutes ago...?
18:12:37 <byorgey> (21:04) <     lispy> "Why won't you answer me?!!?!?"
18:12:50 <byorgey> presumably lispy was simulating talking to a rubber duck
18:13:07 <ZFox> Blah
18:13:16 <ZFox> lispy:  "Why won't you answer me?!!?!?" "....oh wait, I know the problem. I'm ...."
18:13:29 <lispy> ah, yeah byorgey nailed it
18:13:59 <ZFox> OH BOY! Nailed it here too... I held u in vim and I let go at the exact instant where it worked :D
18:13:59 <lispy> dmwit: I thought ZFox meant quotation marks not the actual quoted text
18:14:02 * lispy context fails
18:14:09 <ZFox> Heh
18:16:04 * ZFox wonders what he is doing wrong (low level sockets for communicating with bytestrings; is that it?)
18:20:34 <Saizan> (that should be fine, especially if you stick to strict ones)
18:21:09 <ZFox> "Tokenizer 0.0.1" "Tokenizer 0.0.1test" "Tokenizer 0.0.1testTokenizer 0.0.1"
18:21:11 <ZFox> Heheh
18:21:16 <ZFox> Inconsistancy!
18:25:53 <jfischoff> if I my code type checks with ghci but not when compiling with cabal, what are some things to check?
18:25:54 <lambdabot> jfischoff: You have 1 new message. '/msg lambdabot @messages' to read it.
18:26:00 <jfischoff> @messages
18:26:01 <lambdabot> edwardk said 1d 8h 52m 3s ago: if you unauto you are going to invalidate the resulting derivative
18:26:08 <jfischoff> yeah
18:27:24 <ZFox> When communicating between two programs through a socket, would it be ideal to have a data CommProtocol = CAction Action | CEtc etc ?
18:27:37 <ZFox> (binary encode/decode)
18:30:59 <ZFox> Couldn't match expected type `S.ByteString' with actual type `Data.ByteString.Lazy.Internal.ByteString' In the return type of a call of `encode'
18:31:02 <ZFox> Crap
18:31:52 <geekosaur> it's using lazy instead of strict?
18:32:13 <ZFox> geekosaur: Apparently..
18:32:56 <ZFox> Encode a value using binary serialisation to a lazy ByteString.
18:33:20 <ZFox> ""
18:33:59 <YayMe> Is this a reasonable type for a naive 2d MUD? I wonder if the TVar could be placed at a more granular level somehow.. type world = TVar (M.Map (Int,Int) [Thing])
18:34:34 <ZFox> YayMe: World *
18:34:49 <YayMe> ZFox:  ?
18:34:54 <ZFox> YayMe: "world" lowercase
18:35:00 <YayMe> Oh right
18:35:10 <jbu> hi all: what does the stuff in the curly braces mean in this piece of code ? newtype State s a = State { runState :: (s -> (a,s)) }
18:35:23 <jbu> is it saying that any instance of State must define runState?
18:36:04 <otters> no, it defines the State type constructor
18:36:20 <ZFox> jbu: It's a newtype called State, it takes two arguments... It has the record structure of State { runState :: (s -> (a,s)) }
18:37:12 <ZFox> geekosaur: What's the difference with a bs and a lazy bs?
18:37:18 <ZFox> s/bs/bytestring
18:37:23 <ZFox> !grab
18:37:27 <ZFox> fail
18:37:36 <jbu> ZFox, when you say it takes two arguments, are you saying that "State s a" is a constructor that takes two arguments?
18:37:47 <ZFox> jbu: Yes
18:37:50 <dmwit> A lazy ByteString is a (lazy) list of strict ByteStrings.
18:37:50 <ZFox> So..
18:38:00 <geekosaur> strict bytestring is read all at once, so if you ha ve 2GB of data its going to pull all 2GB into memory at once
18:38:19 <geekosaur> lazy bytestring is internally a lazy list of short strict bytestrings, so it doesn't have to read the whole thing at once
18:38:23 <geekosaur> in general you want lazy
18:38:39 <jbu> ZFox: ok thanks...I'm used to seeing data ___ = <List of Constructors> , so that really threw me off
18:38:46 <ZFox> geekosaur: But when transmitting over the network?
18:39:13 <ZFox> jbu: newtype, new type/constructor
18:39:15 <geekosaur> I'm not the best person to answer that, sorry
18:39:25 <ZFox> geekosaur: :/
18:40:25 <ZFox> http://hackage.haskell.org/packages/archive/network-bytestring/0.1.2.1/doc/html/src/Network-Socket-ByteString.html Network.Socket.ByteString uses strict..
18:40:38 <jbu> ZFox, I feel like I'm butchering the terminology - but in that case would runState be somewhat like a member function for State?
18:41:01 <ZFox> jbu: yes?
18:41:26 <jbu> ZFox, thx, makes more sense now
18:41:36 * ZFox hasn't used States yet
18:41:40 <ZFox> Meant to but haven't :P
18:41:45 <geekosaur> sort of
18:42:11 <ZFox> geekosaur: what sort of how?
18:43:01 <geekosaur> "member function" implies some kind of OO, but this has nothing to do with OO
18:43:12 <geekosaur> it's just a record field whose value is a function
18:43:29 <ZFox> yea
18:43:39 <ZFox> OO ?
18:43:52 <ZFox> oh
18:44:44 <ZFox> geekosaur: Any way to lazybs -> bs ?
18:45:53 <geekosaur> http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Lazy.html#v:toChunks ?
18:46:29 <ZFox> Ah Strict is a list of ByteString O.o
18:46:40 <ZFox> Thanks
18:47:30 <preyalone> I love Haskell, but I also like the homoiconicity of lisps. What's the closest a lisp has ever come to an ML?
18:48:18 <ZFox> Hmm
18:48:43 <ZFox> preyalone: ml?
18:49:10 <preyalone> Meta language, as in OCaml, Haskell, Coq, etc.
18:49:17 <ZFox> Ah
18:50:03 <Rotaerk_> preyalone, haskell is an ML?
18:50:22 <preyalone> Haskell is heavily inspired by SML, so yeah
18:50:43 <Rotaerk_> that's like saying C# is a Java
18:51:25 <preyalone> No. ML is a class of languages. We both know Java is not.
18:51:58 <ZFox> preyalone: haskell has way too many influences
18:52:00 <ZFox> Both ways
18:52:02 <Rotaerk_> ML is a programming language, not a class; there are ML-derivatives like OcaML and F#
18:52:22 <Rotaerk_> but haskell, while perhaps inspired by ML, isn't an ML derivative
18:54:00 <tippenein> I always thought Haskell was an ML, the same way Scheme is a Lisp.. Is that way off?
18:54:15 <geekosaur> I would say haskell is in the overall ML family via lazy ml, but fairly distant from core ML
18:54:34 <eikke> scheme is more lisp'y than haskell is ml'y
18:54:43 <ZFox> :)
18:54:52 <preyalone> hmm
18:54:55 <geekosaur> much as java is in the overall Algol family
18:55:21 <geekosaur> but would not be mistaken for algol-60
18:55:54 <eikke> Java is like C with some syntactic sugar :P
18:57:17 <pharaun> :D
18:57:28 <pharaun> java is like drinking sugary drinks
18:57:47 <eikke> you become fat without realizing it?
18:57:57 <YayMe> pharaun: it tastes good but eventually kills you?
18:58:11 <pharaun> pretty much both ^
18:58:27 <pharaun> tho i dunno on the taste good part
18:58:55 <ZFox> YayMe: No. it just bites hard
18:59:03 <YayMe> lol
18:59:11 <ZFox> Boss: You started that job a week ago, hurry up!
18:59:12 <ZFox> :P
18:59:19 <YayMe> ZFox:  so, does my type work for a simple MUD reasonably?
18:59:36 <ZFox> YayMe: I don't know.. It really depends on the rest of the code =D
18:59:40 <YayMe> I suppose the alternative is an actor model approach with local state and shared instructino queues
19:00:04 <ZFox> YayMe: http://hub.darcs.net/M30W/TextAdv
19:00:12 <ZFox> text adventure game I started to make..
19:00:30 <ZFox> Might help.
19:00:37 <YayMe> ZFox:  is darcs as easy as git to use?
19:00:44 <ZFox> YayMe: Easier
19:00:56 <ZFox> My github >> https://github.com/archeydevil/dotfiles
19:01:33 <ZFox> :P
19:02:17 <YayMe> I pondered using it instead a couple of times, but the whole "based on some quantum physics theory" thing scared me
19:02:26 <ZFox> YayMe: I'd recommend hosting your mud on hub.darcs.net and using darcs. Easy for anyone to contribute with your code and you don't have to live inside hpaste.org :P
19:03:24 <ZFox> Also hub.darcs.net runs darcsden so users can report issues just like on github
19:04:13 <ZFox> YayMe: You can because of how darcs works.. use darcs on your / and only add what you want to record and have a cronjob recording and pushing patches/updates around.
19:04:16 <ZFox> :D
19:04:30 <ZFox> With git, you'd have a hell of a .gitignore file....
19:04:38 <ZFox> (or just use rsync)
19:05:26 <ZFox> even rsnapshot doesn't really beat darcs being a vcs and for standalone exports. darcs dist
19:05:29 <ZFox> done
19:06:52 <ZFox> (For recursive repository reasons; you wouldn't do such exactly..)
19:08:57 <tswett> Is it possible to implement the free monad in Haskell? Is forall r. Cont r the free monad?
19:09:05 <tswett> (Obviously, if the second question is "yes", then so is the first.)
19:10:17 <Saizan> data Free f a = Roll (f (Free f a)) | Return a
19:10:57 <Saizan> \a -> forall r. Cont r a is pretty much a CPS version of the identity monad
19:11:28 <Saizan> maybe you meant Codensity f a = forall r. ContT r f a
19:12:18 <tswett> So, given a functor f, Free f is the free monad on that functor?
19:12:24 <Saizan> yeah
19:12:55 <tswett> Although I can clearly see that fact, I'm not sure at all what it actually means to be the free monad on a functor. :D
19:12:57 <ZFox> SO MANY {C,B,L}.BYTESTRING! D:
19:12:58 <ZFox> D:
19:13:44 <tswett> I guess it means that for any monad whose underlying functor is that functor, there exists a unique morphism from the free monad to that monad.
19:14:23 <tswett> And then a morphism from one monad to another... is a morphism from M to N just a function M a -> N a that's compatible with >>= and return?
19:14:27 <ZFox> YAY
19:14:41 * hackagebot cipher-aes128 0.2.1 - AES128 using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.2.1 (ThomasDuBuisson)
19:15:07 <Saizan> tswett: the usual definition for free something is "left adjoint to the forgetful functor"
19:15:21 <tswett> Is that what it is.
19:15:31 <tswett> I should learn about adjoints, then.
19:15:32 <Saizan> tswett: in this case the forgetful functor would be the one from Mon(C) to Endo(C)
19:15:42 <Saizan> *Monad(C)
19:15:57 <Saizan> End(C) being the category of functors C -> C
19:16:03 <tswett> In this case, from the category of monads in Hask to the category of... yeah, that.
19:16:36 <tswett> Oh, so not the category of endomorphisms in C.
19:16:39 <tswett> (What would that even mean.)
19:16:47 <pharaun> @pl rebuildPrimary x (onlySortBookmarksMenuChildrens x
19:16:48 <lambdabot> (line 1, column 51):
19:16:48 <lambdabot> unexpected end of input
19:16:48 <lambdabot> expecting variable, "(", operator or ")"
19:16:53 <pharaun> @pl rebuildPrimary x (onlySortBookmarksMenuChildrens x)
19:16:53 <lambdabot> rebuildPrimary x (onlySortBookmarksMenuChildrens x)
19:16:56 <pharaun> figures
19:17:31 <geekosaur> you need a lambda
19:17:46 <geekosaur> it won't substitute any names it doesn't see a lambda for, e.g. \x -> ...
19:17:55 <ZFox> geekosaur: need?
19:17:59 <ZFox> You never need a lambda
19:18:03 <ZFox> Juse useful :)
19:18:06 <geekosaur> ZFox, @pl does
19:18:10 <Hermit> pharaun: liftM2 ($) rebuildPrimary onlySortBookmarksMenuChildrens
19:18:13 <ZFox> Oh
19:18:21 <pharaun> Hermit: ah better thanks
19:18:32 <geekosaur> it can only remove points that it has been told are removable
19:18:34 <Saizan> tswett: yeah, no, Hask -> Hask functors with natural transformations (i.e. polymorphic functions) as morphisms
19:18:41 <Hermit> @pl \x -> rebuildPrimary x (onlySortBookmarksMenuChildrens x)
19:18:41 <lambdabot> ap rebuildPrimary onlySortBookmarksMenuChildrens
19:18:44 <Hermit> pharaun: ^
19:18:59 <Hermit> my ap-fu is rusty
19:19:10 <pharaun> good ol' ap, forgot about it
19:19:34 <Hermit> I thought of doing it with the function monad but...
19:19:41 <ZFox> pharaun: Very useful
19:19:41 * hackagebot wai-app-file-cgi 0.8.3 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.8.3 (KazuYamamoto)
19:22:15 <luite> anyone know how to do exceptions with eager blackholing? say i enter a thunk, so i blackhole it, then that thunk throws something, exception is caught somewhere, but the update frame disappears from the stack.
19:22:34 <luite> now the thunk is still a black hole, so if it's entered again: problem
19:23:23 <luite> what's the usual solution? do you unclaim thunks while unwinding the stack? that means you have to keep their context around (might be unavoidable? i'm not sure)
19:27:12 <tswett> All right, the obvious question. Is there such a thing as the free functor on Hask?
19:29:34 <Rotaerk_> tswett, someone a while back linked this http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
19:30:32 <tswett> Someone ought to just come up with a "You Could Have Invented Modern Mathematics" already. :D
19:30:53 <Rotaerk_> and I just ran across this while googling http://hackage.haskell.org/packages/archive/free/3.3.1/doc/html/Control-Monad-Free.html#t:Free
19:33:26 <hpaste> pharaun pasted “which is more clearer?” at http://hpaste.org/83823
19:35:21 <tac> tswett: (and maybe you already did)
19:35:35 <pharaun> i'm playing with pattern matching/guards and i'm not sure which seems more clearer ^
19:35:49 <pharaun> records pattern matching is kind of yucky
19:35:50 <Rotaerk_> eliminate the "more" :P
19:36:13 <pharaun> heh
19:37:47 <ZFox> How would one have a binary protocol? data TComm = CAction Action | CEtc Etc
19:39:19 <ZFox> instance Binary TComm where put (CAction a) = put a; put (Cetc a) = put a; what about get?
19:39:48 <ZFox> Oh wait
19:40:12 <alpounet> na you would put a "tag" first, referring to which constructor that TComm was created with
19:40:42 <alpounet> this is a number, 0 for the first constructor, 1 for the second, etc
19:41:20 <ZFox> Hmm
19:42:04 <ZFox> A data constructor of that name is in scope; did you mean -XDataKinds?
19:45:48 <Saizan> tswett: yes, there's a free functor too, "\f a -> exists b. (f b , b -> a)"
19:46:38 <Saizan> tswett: sometimes improperly named CoYoneda
19:46:43 <ag90> I'm writing a Conduit.sourceFile-like thing (for an experiment) that re-uses the underlying ByteString buffer. It does some unsafe stuff with ByteString.Internal. Anything obviously wrong with this? http://hpaste.org/83824
19:48:19 * ZFox is confused..
19:48:36 <ZFox> data TComm    = CAction Action ... instance Binary CAction where put (CAction a) = put a
19:48:46 <ZFox> Expecting one more argument to `CAction' In the instance declaration for `Binary CAction'
19:49:19 <ZFox> alpounet: Suggestion?
19:52:28 <Sgeo> exists? In a lambda?
19:52:30 <Sgeo> huh?
19:53:33 <no-n> AAAAAAAAAAARRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHHHHHHHH
19:53:58 <ZFox> no-n: ?
19:54:07 <no-n> sorry wrong chan
19:55:01 <ZFox> Ringt....
19:55:07 <ZFox> s/Ringt/Right/
20:02:02 <ZFox> AGH!~
20:02:07 <ZFox> oh nvm
20:02:20 <monochrom> is everybody doing ok? :)
20:02:49 * ZFox lost :|
20:03:32 <ZFox> monochrom: hello
20:03:32 <ZFox> http://ix.io/4Gv >> Expecting one more argument to `CAction' ... etc RAGE
20:03:32 <ZFox> D:
20:03:33 * ZFox feels like he is missing something so simple.... :|
20:05:16 <ZFox> What could it possibly want????
20:05:27 <ZFox> It says one more argument but.... HOW?
20:05:53 <monochrom> I may be unable to understand DataKinds
20:06:08 <monochrom> but which line is the error?
20:06:42 <ZFox>     Not in scope: type constructor or class `CAction'                                                                                                                                │  ~
20:06:46 <alpounet> ZFox, i think you meant to write "instance Binary TComm where ..."
20:06:46 <ZFox>     A data constructor of that name is in scope; did you mean -XDataKinds?
20:06:50 <ZFox> If you don't have it
20:07:01 <ZFox> alpounet: hmm
20:07:27 <monochrom> ok, you probably do not need DataKinds, and you probably misunderstand "data X = blahblah"
20:08:00 <geekosaur> I suspect in most cases if the compiler suggests DataKinds, you have actually done something Wrong
20:08:08 <monochrom> in "data TComm = CAction Action | ...", CAction is *not* a type, and is *not* a subtype of TComm.
20:08:21 <ZFox> geekosaur: Hehe
20:08:23 <hpaste> Dread pasted “Oh My Dread” at http://hpaste.org/83825
20:08:24 <ZFox> geekosaur: Any idea what?
20:08:58 <monochrom> you can only "instance Binary Action where ..." and "instance Binary TComm where ..."
20:09:31 * ZFox is confused.
20:10:10 <monochrom> what is confusing you?
20:10:26 <ZFox> monochrom: For one.. Action isn't a constructor
20:10:30 <ZFox> So can't have the instance
20:10:30 <geekosaur> ZFox, when you say data A = B | C | D, you are declaring constant values B, C, D
20:10:36 <geekosaur> and a type A
20:10:47 <ZFox> yes
20:11:16 <monochrom> wrong inference. you make a type into an instance of Binary (or other type classes). you don't make a constructor into an instance.
20:11:47 <monochrom> indeed, it is the other way round. CAction is a constructure, therefore, can't have the instance.
20:11:52 <ZFox> How should my instances be then?
20:12:06 <k0001_> ZFox: TComm is the name of a type that has two different constructors: One constructor named CAction that takes an Action as argument, and another constructor named CToken that takes a Token as argument.
20:12:06 <monochrom> "instance Binary Action where ..." and "instance Binary TComm where ..."
20:12:13 <YayMe> What's the simplest way to create network connections in haskell?
20:12:30 <monochrom> in general, "instance <name of type class here> <name of type here> where ..."
20:12:30 <ZFox> YayMe: Netowk
20:12:34 <ZFox> network *
20:12:52 <ZFox> :|
20:12:59 <ab9rf> netork
20:13:12 <ab9rf> upgrades to neturukhai
20:13:33 <monochrom> have you seen how other type classes and instances are done?
20:13:37 <YayMe> ZFox: Is network conduit make it any easier?
20:14:08 <geekosaur> gah, notwork dropped out
20:14:10 <ZFox> monochrom: http://ix.io/4Gw
20:14:10 <monochrom> "data Maybe a = Nothing | Just a", "instance Functor Maybe where..." not "instance Functor Just where"
20:14:34 <geekosaur> ^^
20:14:58 <monochrom> and that paste makes what point?
20:15:04 <hpaste> Dread pasted “Oh My Dread 2” at http://hpaste.org/83826
20:15:10 <ab9rf> i don't see what that paste has anything to do with anywho
20:15:19 <ZFox> monochrom: "Have you seen how other type classes and instances are done?"
20:15:25 <geekosaur> given data Foo = A | B Int | C String, you can't say instance Functor A where ... any more than you can say instance Functor 5 where ...
20:15:27 <ZFox> monochrom: I wrote those in that paste.
20:15:30 <ZFox> I understand them
20:15:33 <ZFox> But not this D:
20:16:07 <monochrom> ok, seriously, have you seen how it is "instance Functor Maybe" not "instance Functor Just"?
20:16:08 <ZFox> geekosaur: I understand that
20:16:20 <k0001_> YayMe: depends on your needs, if you need reliable streaming of network packets, then probably it does. Also, shameless plug: you might want to check pipes-network, in similar spirit than network-conduit.
20:16:20 <ZFox> monochrom: Yes, you sent it to me :)
20:16:36 <monochrom> then "instance Binary CAction" is wrong.
20:16:41 <geekosaur> so why are you trying to make an instance for CAction?
20:17:01 <monochrom> is there any new question?
20:17:04 <YayMe> k0001_: The only reason conduit caught my eye is I read the tutorial on it the other day on www.fpcomplete.com
20:17:05 <ZFox> Because it takes an argument?
20:17:13 <ZFox> Being Action
20:17:15 <geekosaur> look at my example again
20:17:25 <ab9rf> ZFox: no, because it's a constructor, not a type
20:17:30 <geekosaur> you can't make an instance for B any more than you can for A, even though it takes a parameter
20:17:34 <monochrom> no, because it is "instance <name of type class> <name of type". CAction is not the name of a type.
20:17:36 <geekosaur> it's still not a type, it's a value
20:17:48 <ab9rf> ZFox: types are what you make instances, not values
20:17:50 <ZFox> Ah
20:18:19 <ZFox> The type Action
20:18:30 <ZFox> How can I possibly make the instances?
20:18:31 <ZFox> I mean..
20:18:35 <ZFox> get atleast.. :/
20:18:51 <monochrom> "instance Binary Action", "instance Binary TComm"
20:19:01 <ZFox> put is just pattern matching which. but get?
20:19:13 <monochrom> I cannot write their bodies for you. I don't know what they are supposed to do, and I don't want to know.
20:19:22 <ab9rf> ZFox: all instances of a type are the same type
20:19:31 <ab9rf> you can't make some instances part of a typeclass and not others
20:19:53 <monochrom> eh? I don't understand those two sentences
20:20:06 <ab9rf> monochrom: good :)
20:20:09 * ZFox either
20:20:12 <tswett> ZFox: well, is it possible for a CAction and a CToken to have exactly the same byte string encoding?
20:20:13 <ZFox> ab9rf: bad :(
20:20:30 <ZFox> tswett: No
20:20:33 <ZFox> tswett: They are different
20:20:36 <k0001_> YayMe: what problem are you trying to solve? If you will be streaming lengthy data, either in or out, then any of the conduit/pipes solutions may benefit you.
20:20:46 <tswett> ZFox: in that case, given a byte string encoding, how can you tell whether it's a CAction or a CToken?
20:20:49 <geekosaur> ZFox: instance Binary TComm where put (CAction x) = ...; put (CToken x) = ...; ...
20:20:51 <hpaste> Dread pasted “Oh My Dread 3” at http://hpaste.org/83827
20:21:04 <Rotaerk_> hmm to represent the concept of identity in immutable data structures, you can create a Map with the entity's unique ID as the key, and its current state as the value; however, there has to be some policy around creating new entities... a way to generate the new ID.  Is there some standard solution to this problem?
20:21:09 <ZFox> geekosaur: Yea I have that but.. the get?
20:21:10 <joe9> haskell seems a perfect fit for building a shell. just curious why there is nothing so groundbreaking as xmonad is for window managers?
20:21:15 <geekosaur> and for get, you parse the bytestring and produce a CAction or CToken as appropriate
20:21:31 <Rotaerk_> some kind of generic "table" data structure
20:21:40 <geekosaur> presumably there is some indication in the bytestring of whether it is encoding an action or a token
20:21:50 <Sgeo> @hoogle Unique
20:21:50 <lambdabot> Data.Unique module Data.Unique
20:21:50 <lambdabot> Data.Unique data Unique
20:21:50 <lambdabot> package uniqueid
20:21:57 <ZFox> geekosaur: How?
20:22:03 <Rotaerk_> hmm thanks, will look at it
20:22:07 <geekosaur> um? it's *your* protocol?
20:22:18 <geekosaur> I have no idea what protocol this is, or how it works
20:22:38 <ZFox> geekosaur: TCommm
20:22:39 <geekosaur> if you have not worked out your wire protocol yet, I suggest you do so
20:22:40 <geekosaur> no
20:22:55 <geekosaur> TComm is not the series of bytes being transmitted/received
20:23:02 <Rotaerk_> Sgeo, hmm, that's really only part of the problem
20:23:07 <ZFox> It's the type
20:23:17 <geekosaur> and?
20:23:25 <tswett> ZFox: a ByteString is just a list of numbers. It doesn't *have* any types in it.
20:23:36 <notthemessiah> joe9: haskell doesn't seem to play nice with many graphics toolkits, so user software isn't often made with it.
20:23:37 <ZFox> decode stream :: TComm
20:23:41 <geekosaur> instance Binary is for converting netween an internal typed representation and a series of bytes.
20:23:44 <YayMe> k0001_: super simple MUD, if the pipes solutions are for large data streams I guess I don't need them. I was just wondering because the reading I did the other day on conduit made it sound like a very easy way to send data through functions such as for sending the data to a parser which is what I'll be doing
20:24:04 <tswett> ZFox: so if you want "get" to be able to tell the difference between a CAction and a CToken, you have to ensure that the list of numbers *indicates* the difference.
20:24:10 <geekosaur> if this is a new protocol you are working out, *you* need to decide what the byte representation is
20:24:28 <geekosaur> we know pretty much nothing about your type and cannot guess as to what the wire protocol (= byte encoding) is
20:24:47 <monochrom> I have never heard of TComm
20:24:49 <tswett> ZFox: one way to do this is by adding a number to the front of the byte string that says whether it's a CAction or a CToken. Perhaps you could use 0 to represent a CAction, and 1 to represent a CToken.
20:25:09 <geekosaur> also, I must note that Integer is not a type that is friendly to byte representations
20:25:09 <ZFox> geekosaur: You have all TComm, Action and Token..
20:25:13 <geekosaur> so?
20:25:34 <geekosaur> tell me how to write a TComm to a file
20:25:40 <tswett> ZFox: then you would have put (CAction x) = cons 0 (put x), and put (CToken x) = cons 1 (put x).
20:25:43 <geekosaur> or read it from a file
20:26:23 * ZFox is confused :|
20:26:24 <geekosaur> your definitions do not tell me this. they do not tell Haskell this. your definition for instance Binary tells Haskell this
20:26:25 <ZFox> encodeFile "file" someTComm
20:26:31 <geekosaur> sigh
20:26:37 <tswett> ZFox: and then get s = case uncons x of (0, s') -> CAction (get s'); (1, s') -> CToken (get s')
20:26:41 <geekosaur> encodeFile does not read your mind and figure out what bytes to generate
20:26:44 <k0001_> YayMe: it is easier! I can't give particular network-conduit use cases, I haven't used it myself, but with pipes-network it gets quite simple, see: http://hackage.haskell.org/packages/archive/pipes-network/0.1.0/doc/html/Control-Proxy-TCP-Safe.html#g:4
20:27:02 <geekosaur> the whole point of instance Binary is to tell haskell what bytes to generate or to decipher
20:27:37 <geekosaur> ZFox, let me try this: if I give you a number, say 1, there are a bunch of ways I could write that to a file
20:27:59 <monochrom> perhaps just use Read and Show
20:28:33 <Rotaerk_> Sgeo, in F#, I created something like:  data EntityId a = EntityId Int;  data EntityTable a = EntityTable { entities :: Map (EntityId a) a };
20:28:53 <geekosaur> it could be a string "1", it could be a single byte, a double byte, or 4 or 8 bytes (common on x86 and x86-64, respectively) --- and with the multibyte ones, the order matters; \x04\x03 is read as 256*4+3 on some kinds of machines and 256*3+4 on others (endianness)
20:28:56 <Rotaerk_> in this case, a given EntityId, even though it's really just an int, knows which type of entity it identifies
20:29:24 <geekosaur> which is why nothing can just magic up a representation for you; you need to choose one, and use an "instance Binary ..." to tell Haskell what that representation is
20:29:37 <Rotaerk_> also, there are insert, delete, modify functions, and insert would generate a new EntityId for the entity, and add it to the map while returning both the map and the ID
20:30:35 <Rotaerk_> so unique-identifier generation would be part of its implementation; but I'm looking for whether there's some full solution to this problem already in existence
20:30:46 <tswett> ZFox: I can try to help you through this, if you'd like.
20:30:48 <Rotaerk_> (not even necessarily the same approach)
20:31:04 <ZFox> tswett: You already have. I'm just trying to get those pieces together
20:31:15 <ZFox> tswett: ^_^
20:31:20 <tswett> *nod*
20:31:43 <ZFox> While geekosaur and monochrom are trying to explain it all you mentioned cons and uncons and I'm thinking yay.
20:31:56 <geekosaur> now, if you skip the Binary stuff, Haskell can buid textual representations for you; add "deriving (Read, Show)" to your declarations
20:32:59 <geekosaur> now ```show (CToken whatever)``` generates a string ```CToken whatever``` and ```read :: TComm``` will accept that string and generate a TComm of the form (CToken whatever). or the same for CAction.
20:34:00 <geekosaur> but text representations have some drawbacks (they are inefficient for large amounts of data, for example), so sometimes you want to define a compact binary protocol instead of the text one. but for now you may want to stick to the text one
20:34:41 <geekosaur> ZFox, see http://en.wikipedia.org/wiki/Marshalling_(computer_science)
20:35:15 <k0001> ZFox: for the record: you probably need the Binary interface just if you are going to save your data type in a binary file or, say, if you are sending it through a network connection. Otherwise, the Show/Read approach suggested by geekosaur is just fine.
20:35:39 <geekosaur> actually, strings work fine for network connections in most cases
20:35:41 <ZFox> WHOAH
20:35:49 <ZFox> cabal build |& wc -l # 207
20:35:51 <ZFox> D:
20:35:55 <geekosaur> most of the common network protocols such as imap and smtp use strings
20:36:36 <geekosaur> I used to run mail servers, and beng able to telnet to an imap or smtp server and send commands was often quite handy for debugging problems
20:36:44 <ZFox> Strings are slow
20:36:54 <monochrom> I do that for nntp and irc
20:36:59 <k0001> geekosaur: well, yes, they do, but compact representations are often prefered. That's what I meant.
20:37:01 <monochrom> and sometimes http too
20:37:12 <ZFox> irc/http, you can talk in plain if you like sure.
20:37:24 <ZFox> I'm not writing a protocol for netcat :P
20:37:26 <geekosaur> ZFox, don't commit the sin of premature optimization
20:37:27 <monochrom> so yes, sometimes I have to answer "PONG blahblah" manually!
20:37:34 <ZFox> geekosaur: hehe
20:37:40 <geekosaur> especially if you don't yet understand the concept of producing a binary encoding for your protocol
20:37:42 <ZFox> monochrom: I do that
20:37:52 <ZFox> monochrom: nc is a great irc client :P
20:38:10 <geekosaur> stick with the strings (or ByteString even) for now and worry about marshaling for efficiency later
20:38:15 <tswett> You know, being taught by multiple people at once is like being led out of a forest by multiple people at once.
20:38:27 <k0001> geekosaur: now that you mention it, I've done that myself too for debuging line-oriented network servers. Heh.
20:38:34 <ZFox> tswett: hehe
20:38:34 <tswett> If you follow any one person's directions, you'll get out of the forest. If you try to follow everyone's directions, you'll be split into pieces. :D
20:38:34 <Rotaerk_> hmm I effectively want a database schema in memory; no need for persistence
20:38:44 <Rotaerk_> but using haskell data structures
20:38:55 <Rotaerk_> acid-state seems to be about persistence
20:39:06 <pharaun> ZFox: what is this protocol and what are you doing?
20:39:07 <monochrom> use quantum mechanics to follow everyone's directions superimposedly
20:39:15 <pharaun> ZFox: i generally recommend just doing protocol in strong
20:39:17 <pharaun> *string
20:39:23 <pharaun> Rotaerk_: try edwardk's tables
20:39:37 <ZFox> pharaun: Basically a database
20:39:57 <Rotaerk_> pharaun, could you point me to it
20:40:25 <Rotaerk_> oh; this?  http://hackage.haskell.org/package/tables/
20:40:38 * ZFox wonders what he is doing wrong now..
20:41:18 <tswett> ZFox: I could still try to explain this to you. ^_^
20:41:48 <ZFox> http://ix.io/4Gw
20:41:50 <ZFox> What I have now
20:41:50 <ZFox> err
20:41:53 <ZFox> http://ix.io/4GB                                                                                                                                                                     │examples/TokenC.hs                                                      20,8           All
20:41:57 <ZFox> AH
20:42:19 <pharaun> Rotaerk_: yes
20:42:24 <ZFox> (inside tmux and selected too much fail)
20:42:46 <tswett> ZFox: hm. That looks like it ought to work, as long as you're not using Gen or List.
20:42:57 <ZFox> tswett: Heh
20:43:03 <ZFox> Forgot about those
20:43:09 <geekosaur> you should probably also pastebin any error message (complete) that you are getting
20:43:17 <tswett> And as long as Integer and Token both have instances for Binary.
20:43:28 <ZFox> tswett: How would I do them exactly?
20:43:56 <ZFox> geekosaur: cabal build |& ix # http://ix.io/4GC
20:43:58 <geekosaur> I would be somewhat dubious of any Binary instance for Integer. sure you don't want to use something like Int instead?
20:44:00 <tswett> Almost the same thing. When encoding, instead of using "put a", you'll probably want to just put the empty string there.
20:44:24 <tswett> So "B.cons 3 empty", or, equivalently, "B.singleton 3".
20:44:43 * hackagebot monoid-subclasses 0.1 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.1 (MarioBlazevic)
20:45:05 <tswett> For decoding, you know that s is going to be empty, and besides that, you don't care what s is. So, on the right hand side of the ->, you don't need to use s at all.
20:46:51 <ZFox> tswett: ix src/Data/Token/Protocol.hs
20:46:57 <ZFox> http://ix.io/4GD
20:47:02 <ZFox> cabal build |& ix
20:47:07 <ZFox> http://ix.io/4GE
20:47:14 * ZFox didn't mean for so many lines there :/
20:47:55 <tswett> Hmm.
20:48:13 <ZFox> tswett: From what you gave me before. It was missing the Just
20:48:27 <ZFox> Also I'm unsure what I should do if it catches something else _ -> what? O.o
20:48:32 <ZFox> Invalid
20:48:58 <tswett> Hm, looks like I misunderstood how Binary works...
20:49:12 <YayMe> It's not clear, does the Network module automatically forkIO the accept? I'm guessing not, but it's not clear.. Just reading hackage I'm guessing I'd do something like withSocketsDo $ listenOn 1234 >>= handleAccept where handleAccept a = (forkIO $ someRealHandler) >> handleAccept a
20:49:46 <geekosaur> this may be where you stop and read that wikipedia article I pointed at; you need to work that kind of stuff out for yourself, really
20:49:46 <monochrom> does not automatically forkIO
20:50:01 <tswett> ZFox: all right, my mistake. Lemme see.
20:50:33 <ZFox> 181 lines of errors now
20:50:34 <YayMe> monochrom: is would I fork and repeat the accept call like that, or do I fork and repeat the listenOn?
20:50:37 <geekosaur> recovering from bad data is something that whole books have been written about, because sometimes you need to abort the whole thing and sometimes you need to recover and keep processing the input stream, etc.
20:50:53 <ZFox> ix src/Data/Token/Protocol.hs; cabal build |& ix
20:50:57 <ZFox> http://ix.io/4GF
20:50:57 <ZFox> http://ix.io/4GG
20:50:57 <k0001> YayMe: you listen just once, then you fork many.
20:51:02 <YayMe> monochrom: Presuming it will automatically carry the connection off the initial port, no?
20:51:04 <tswett> Replace "B.cons n $ put a" with "putWord8 n >> put a", "B.singleton n" with "putWord8 n", and... one more thing, lemme see.
20:51:06 <ZFox> tswett: ^
20:51:11 <k0001> YayMe: s/fork/accept/
20:51:33 <YayMe> Ok, so my little shorthand I wrote makes sense more or less k0001?
20:52:17 <tswett> Then replace "case B.uncons x of" with "getWord8 >>= \x -> case x of", and, on each of the lines in each case statement, put "return (...)" around it.
20:52:18 <monochrom> don't repeat the listenOn. loop over the accept. at each accept return, you may fork
20:52:31 <tswett> Uh, lemme rephrase that last bit.
20:52:36 <monochrom> you forgot to call accept in your sample code
20:52:43 <k0001> YayMe: I missed it. IRC is behaving weird here, maybe I'm a net-split victim. ¿Can you paste that again?
20:52:49 <tswett> Replace "Just (1, s) -> Check $ get s" with "1 -> return (Check $ get s)".
20:52:50 <YayMe> oops I forgot to write the accept anyway
20:52:55 <tswett> ZFox: doing all that ought to fix it.
20:54:03 <monochrom> withSocketsDo $ listenOn 1234 >>= handleAccept where handleAccept a = (accept a >>= forkIO . someRealHandler) >> handleAccept a
20:54:08 <YayMe> k0001: withSocketsDo $ listenOn 1234 >>= handleAccept where handleAccept a = (forkIO $ someRealHandler $ accept a) >> handleAccept a
20:54:20 <YayMe> ah
20:54:33 <monochrom> (forkIO $ someRealHandler $ accept a) is a type error
20:54:45 <YayMe> forkIO takes an IO ()
20:54:45 <monochrom> also, $ is overrated
20:55:37 <monochrom> forkIO (someRealHandler (accept a))  would work in an inferior functional language such as ML
20:55:41 <YayMe> say for instance someRealHandler s = sClose s
20:56:01 <YayMe> it shouldn't be a type error should it?
20:56:04 <monochrom> mind the type of accept. not simply s.
20:56:15 <ZFox> tswett: where s?
20:56:37 <monochrom> in fact, not s at all
20:56:54 <tswett> ZFox: hm?
20:56:54 <monochrom> clearly, (Handle, HostName, PortNumber) != Socket
20:56:57 <YayMe> oh right
20:57:11 <ZFox> Getting there
20:57:17 <ZFox> tswett: <$> get *
20:57:23 <monochrom> also, don't close the socket. unless you no longer want to accept
20:57:27 <YayMe> monochrom: thanks, cool so I was on more or less the right path but yeah your accept >>= is key to grabbing the Handle
20:57:35 <tswett> Hm, I don't remember what <$> does.
20:57:42 <monochrom> <$> = fmap
20:57:43 <YayMe> monochrom: I was just saying that to make an example that type checked to what forkIO wants
20:58:07 <YayMe> but thanks for the tip, close is done once for all acceptances, not once per acceptance
20:58:08 <chowder> quick question. A client of mine wants a really simple web app that integrates with gmail. I was thinking of making a sidebar gadget. Does the google api support haskell?
20:58:27 <ZFox> http://ix.io/4GH+4GI - tswett
20:58:41 <tswett> Mm, right. I guess the line needs to be "1 -> fmap Check s", if I'm not mistaken...
20:59:15 <ZFox> tswett: s/s/get
20:59:30 <ZFox> tswett: See the updated paste ^
20:59:32 <YayMe> monochrom: you find () preferable to $ sometimes (where $ is even valid)?
20:59:42 <tswett> Since when does \case exist...
20:59:45 <luite> chowder: it should be a client side web app, right?
20:59:54 <arkeet> tswett: 7.6
20:59:55 <ZFox> tswett: since LambdaCase
21:00:14 <Ralith> chowder: that question is kind of backwards and sidewas
21:00:15 <ZFox> tswett: {-# LANGUAGE LambdaCase #-}
21:00:17 <Ralith> sideways
21:00:36 <tswett> ZFox: all right, I *think* the only problem is that you need to use "return AGen" and the like.
21:00:36 <Ralith> you might similarly ask if IRC supports haskell
21:00:44 <ZFox> Ah
21:01:13 <chowder> luite, correct. all he needs is something to generate and send invoices to clients. he also wants to manage his contacts. Gmail takes care of most of the work so I figured the best thing would be to make a sidebar gadget.
21:01:18 <chowder> Ralith, how so?
21:01:38 <YayMe> monochrom: If I start fiddling with this stuff, is a badly shut down process liable to orphan a listener locking up one of my ports, or will it pretty much always release properly even if I don't get my shutdown code right at first?
21:01:38 <ZFox> Hehe
21:01:51 <ZFox> Not quite..
21:02:12 <luite> chowder: hmm, for very simple apps, writing javascript directly is almost certainly simpler
21:02:22 <Ralith> chowder: google's API is network-based. Anything that can communicate coherently over the network should be able to implement it.
21:02:50 <monochrom> listenOn sets the ReuseAddr option because of this. when the process terminates, the port is freed. if the port is not freed, the process is still running.
21:03:18 <YayMe> monochrom: Cool, thanks. I'll start hacking some stuff together and see what I can get..
21:03:24 <ZFox> :/
21:03:53 <ZFox> tswett: http://ix.io/4GL+4GM
21:04:11 <chowder> luite: basically he needs to be able to tally up the costs for his clients and generate an invoice to then email it to a client. This could be a really simple sidebar gadget I'd think.
21:04:31 <xpika> is there a hackage rating system?
21:04:33 <luite> chowder: is that a windows vista/7/8 sidebar thing?
21:04:54 * ZFox has a feeling it's missing a get
21:04:59 <tswett> ZFox: well, that's not where you put the "return".
21:05:13 <chowder> luite, no no this is something that works in the browser as gmail application. As per the google api site: Gmail is now a gadget container
21:05:26 <tswett> We need "return AGen", but we need "ACheck <$> get", not "return (ACheck <$> get)".
21:05:51 <Anpheus_> What ever happened to the cabal sandbox commands?
21:06:03 <Anpheus_> The ones referenced here: https://github.com/haskell/cabal/pull/1011
21:06:11 <Anpheus_> And here: http://blog.johantibell.com/2012/08/you-can-soon-play-in-cabal-sandbox.html
21:06:18 <luite> chowder: oh right, well both are html+javascript things
21:06:40 <luite> chowder: you could do it with Fay if you like haskell
21:07:08 <monochrom> the sandbox commands are not officially released yet
21:07:37 <Anpheus_> When will they be? I can find no information on the state of cabal sandboxing and it's something I need
21:07:40 <chowder> luite, right the problem is that he wants to be able to send emails from within the application. I don't want to have to write a mail server when (a) his contacts are already saved in gmail and (b) its going to be significantly more work
21:07:50 <monochrom> I don't know. perhaps, no one knows.
21:08:08 <Anpheus_> why were those commands never added to cabal?
21:08:13 <Anpheus_> they were pulled in?
21:09:10 <ZFox> tswett: h
21:09:21 <ZFox> tswett: I was thinking about parsec but got it wrong in my memory
21:09:44 * hackagebot incremental-parser 0.2.2 - Generic parser library capable of providing partial results from partial input.  http://hackage.haskell.org/package/incremental-parser-0.2.2 (MarioBlazevic)
21:09:45 <ZFox> Yay build
21:09:51 <ZFox> Just lots of warnings from -Wall
21:10:11 <ZFox> redundent imports (not yet using)
21:10:25 <ZFox> Thank you sir tswett ^_^
21:10:30 <tswett> You're welcome. ^_^
21:11:03 <ZFox> binary > parsec
21:11:04 <ZFox> :D
21:11:33 <monochrom> that is false
21:12:01 <ZFox> monochrom: Depending on case
21:12:08 <ZFox> If user input, parsec <3
21:12:20 <monochrom> if you want some kind of incremental report or yield, parsec can be made to do it since it is a monad transformer. binary simply forbids it.
21:12:26 <ZFox> If protocol between two programs, binary sure nice
21:12:44 <monochrom> see my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#yield-intro
21:12:45 <ZFox> Heh
21:13:04 <ZFox> Still depends on use/case
21:13:39 <Anpheus_> monochrom: https://github.com/haskell/cabal/blob/master/cabal-install/src/Main.hs
21:14:01 <Anpheus_> monochrom: ctrl-f sandbox, why aren't they available?
21:14:10 <monochrom> binary cannot be used for decoding streaming video
21:14:14 <ZFox> Anpheus_: remove 33 lines!
21:14:16 <ZFox> (666)
21:14:44 * hackagebot process-conduit 1.0.0.0 - Conduits for processes  http://hackage.haskell.org/package/process-conduit-1.0.0.0 (HideyukiTanaka)
21:14:46 <ZFox> monochrom: It can't. but neither can parsec?
21:14:52 <ZFox> monochrom: Well... I guess it could
21:15:03 <monochrom> Anpheus_, I did not make the decisions, and I do not know why, and it is futile to grill me on this.
21:15:21 <monochrom> see my url for how to yield in parsec
21:16:15 <monochrom> if binary gave you a monad transformer, I could pull the same trick with binary too, then it could be used for decoding streaming video
21:20:28 <luite> chowder: ah using haskell for that wouldn't be terribly easy :)
21:22:56 <YayMe> Is GHC.IO.Handle the generally used module for working with a Handle?
21:26:25 <indomitus> can someone explain how to read this (in particular, i don't understand the !! arg to readFile): content <- readFile (args !! 0)
21:26:54 <ag90> indomitus: args !! 0 gets the element of args at index 0
21:26:55 <YayMe> that's an indexer (lest I remember wrong), it's basically saying head args
21:27:16 <ion> > ["foo", "bar", "baz"] !! 0
21:27:18 <lambdabot>   "foo"
21:27:24 <ion> > ["foo", "bar", "baz"] !! 3
21:27:25 <YayMe> > [] !! 0
21:27:25 <lambdabot>   "*Exception: Prelude.(!!): index too large
21:27:26 <lambdabot>   can't find file: L.hs
21:27:29 <YayMe> > head []
21:27:30 <lambdabot>   *Exception: Prelude.head: empty list
21:27:44 <YayMe> they both fail on empty, so why they didn't say head, I don't know..
21:28:02 <YayMe> > [] !! 0
21:28:04 <lambdabot>   *Exception: Prelude.(!!): index too large
21:28:28 <indomitus> interesting, so it's essentially analogous to C's syntax: args[0]
21:28:40 <YayMe> aye
21:28:49 <indomitus> cool thanks
21:28:54 <ion> @type (!!)
21:28:55 <ZFox> monochrom: Can you decode streaming video with parsec easily?
21:28:56 <lambdabot> [a] -> Int -> a
21:29:50 <ZFox> And sure binary can be used for video.... Just need a haskell encoding for the *new* codec :P
21:29:53 <YayMe> ZFox: can anyone decode streaming video of any sort easily with any language? I've never done any video decoding, but my general understanding is it's a complex domain
21:30:09 <ZFox> YayMe: Ofc
21:30:42 <ZFox> YayMe: Just often not "easily" but.. If you understand exactly what's going around, it'd be easier than for us. :P
21:30:50 <ZFox> (Who don't)
21:31:33 <YayMe> Aye. I've thought about trying to get into that domain since learning Haskell just because it seems like a great tool for the task
21:31:51 <YayMe> but it seems like one of those enormous domains that I'd have to study for a long time to be able to do the simplest things
21:33:02 <pharaun> ZFox: probably better to use attoparsec i think (faster bytestring) or whatever binary parser, cereal?
21:33:17 <pharaun> but i don't see why you can't decode video streams with haskell
21:33:51 <Radish> Am I supposed to use lots of Maybes?
21:34:02 <Radish> I can't tell if it's natural or not lol
21:34:06 <pharaun> for?
21:34:13 <XexonixXexillion> Radish: Maybe :p
21:34:16 <pharaun> Radish: there are some tricks that you can employ
21:34:16 <Radish> mostly filters
21:34:17 <Radish> :D
21:34:27 <Radish> i want to combine a filter and a function
21:34:32 <ZFox> Radish: Try to use as little code as you can
21:34:32 <Radish> I typically end up with mapMaybe
21:34:34 <ZFox> :)
21:34:37 <tswett> I'm not sure if Haskell would be the best tool for this, really. I know very little about decoding streaming video, but it seems like it would probably involve crunching lots of numbers in very specific, unchanging ways.
21:34:41 <pharaun> such as aborting early, etc... can help reduce the use of maybes but yeah
21:34:45 <Radish> I could alternately ++ []
21:34:46 <geekosaur> you can also use the Maybe monad instance
21:34:49 <ZFox> But not so little and pointfree that you can't read it
21:34:52 <Radish> or : []
21:35:00 <Radish> oh no i couldn't do that one.
21:35:06 <YayMe> tswett: crunching lots of numbers over large data sets, where in that space does Haskell not fit?
21:35:14 <XexonixXexillion> Haskell is a fine language for decoding and encoding video as long as random interrupts for garbage collection are ok
21:35:23 <tswett> YayMe: well, this sounds like the sort of thing that C would be perfect for.
21:35:32 <YayMe> ehh
21:35:34 <tswett> C is good when you know exactly how much memory you're going to need.
21:35:54 <Radish> tswett: thats a great point there
21:36:10 <indomitus> is there a way to have when do 2 things? like: when boolean (putStrLn "foo"; exitWith ExitSuccess)
21:36:18 <Ralith> tswett: surely you mean STArrays.
21:36:26 <Ralith> :D
21:36:28 <tswett> indomitus: yup, that's what >> will do.
21:36:39 <tswett> when boolean (putStrLn "foo" >> exitWith ExitSuccess)
21:36:51 <indomitus> rly? is it like bash |
21:37:10 <YayMe> you mean >> ?
21:37:11 <tswett> Not really. In IO, x >> y just means "do x, then do y".
21:37:32 <k0001> tswett: you can interface with C via FFI if you need to.
21:37:42 <tswett> The output of x is discarded.
21:37:50 <YayMe> more specificially f1 >> f2 is f1 >>= \_ -> f2
21:37:58 <ion> indomitus: Also: when boolean (do putStrLn "foo"; exitWith ExitSuccess)
21:38:04 <ion> indomitus: No, it’s like bash ;
21:38:15 <tswett> In bash, x | y uses the output of x as the input of y. Which I supposes is pretty much what >>= does in Haskell.
21:39:05 <indomitus> pooh ok so >> goes to the next statement and >>= goes to the next statement with the results of the l operand
21:39:14 <YayMe> yes
21:39:17 <YayMe> (ish)
21:39:50 <YayMe> >>= has a different implementation depending on the monad you're working with
21:40:04 <YayMe> in the IO monad yes it's just as you describe
21:40:15 <tswett> Note that it's not really necessary to understand what the word "monad" means.
21:40:44 <tswett> It's very much possible to use individual monads without understanding the general pattern first.
21:41:21 <ion> That’s more or less the way to understanding the general pattern.
21:41:47 <tswett> Indeed. Understanding the pattern before understanding instances of it is... only sometimes a good idea.
21:43:12 <indomitus> i have an idea about what monads are, but don't have the specifics down yet
21:47:40 <byorgey> where's the best/canonical place to find a function  String -> ByteString  that does UTF-8 encoding?
21:47:47 <YayMe> indomitus: It takes time, though yeah that is the general pattern you can expect until you understand it better. For what it's worth what really cemented them for me was implementing my own
21:48:16 <byorgey> @src Monad
21:48:17 <lambdabot> class  Monad m  where
21:48:17 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
21:48:17 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
21:48:17 <lambdabot>     return      :: a -> m a
21:48:17 <lambdabot>     fail        :: String -> m a
21:48:36 <byorgey> indomitus: ^^^ there are the specifics! except ignore 'fail'.
21:49:07 <Clint> byorgey: Data.Text.Encoding.encodeUtf8 . Data.Text.pack ?
21:50:20 <byorgey> Clint: ahh, cool
21:50:22 <byorgey> thanks
21:51:37 <YayMe> :t Network.accept
21:51:39 <lambdabot> Network.Socket.Socket -> IO (GHC.IO.Handle.Types.Handle, Network.Socket.HostName, Network.Socket.Internal.PortNumber)
21:57:45 <ZFox> YayMe: What are you attempting to network?
21:58:10 <indomitus> how can i concatenate getProgName to a string?
21:58:29 <ZFox> :t getProgName
21:58:31 <lambdabot> Not in scope: `getProgName'
21:58:36 <ZFox> @hoogle getProgName
21:58:36 <lambdabot> System.Environment getProgName :: IO String
21:58:49 <ZFox> indomitus: Note the IO ?
21:59:02 <YayMe> ZFox: simple MUD
21:59:18 <YayMe> or rather, anything. Starting with an echo.
21:59:38 <indomitus> yes, so maybe: "string1 "++(Just getProgName)++" string2"
21:59:57 <Ralith> :t Just
21:59:58 <lambdabot> a -> Maybe a
22:00:16 <Ralith> what do you expect to do with a Maybe (IO String)?
22:00:18 <YayMe> ZFox: thinking.. echoHandler a@(hdl, hname, pnum) = hGetChar hdl >>= hPutChar hdl >> echoHandler a
22:00:42 <ZFox> Ralith: I'd rather an IO (Maybe String) -- ;)
22:01:52 <ZFox> YayMe: s@(hdl, name, num) You're passing it the accept I see.
22:01:57 <ZFox> YayMe: Not bad
22:03:47 <ZFox> YayMe: Mind pasting your code somewhere?
22:03:59 <ZFox> http://hpaste.org/ or http://ix.io/
22:04:05 <YayMe> ZFox: let me get something compiling real quick..
22:04:29 <indomitus> is the only way to use (var <- getProgName) then concatenate var?
22:04:45 <ZFox> YayMe: Err.
22:04:52 <ZFox> s@(h,_,_) Hmm
22:04:59 <YayMe> ah yeah good point
22:05:21 <ZFox> idnar: getProgName >>= (++"test")
22:05:23 <YayMe> :t Network.PortID
22:05:24 <lambdabot> Not in scope: data constructor `Network.PortID'
22:05:27 <ZFox> indomitus: *
22:05:36 <ZFox> Sorry idnar
22:06:09 <ZFox> YayMe: What is you code?
22:06:12 <ZFox> Send ^_^
22:06:16 <ZFox> idc if it compiles or not :P
22:06:54 <hpaste> YayMe pasted “broken echo server” at http://hpaste.org/83831
22:07:14 <YayMe> 1234 won't do, need to actually create a Network.PortID type..
22:07:22 <ZFox> YayMe: yea
22:07:54 <ZFox> withSocketsDo $ listenOn .PortNumber $ fromInteger 1234 >>= repeatAccept
22:08:05 <ZFox> withSocketsDo $ listenOn . PortNumber $ fromInteger 1234 >>= repeatAccept
22:08:08 <YayMe> :t Network.PortNumber
22:08:09 <lambdabot> Network.Socket.Internal.PortNumber -> Network.PortID
22:08:25 <ZFox> YayMe: import Network (PortID(PortNumber))
22:08:50 <YayMe> what type is PortNumber though? Hackage says "PortNumber" which isn't a number..
22:09:17 <ZFox> PortID(PortNumber)
22:09:23 <ZFox> :t PortNumber -> PortID
22:09:25 <lambdabot> parse error on input `->'
22:10:19 <ZFox> YayMe: Also. I don't like your echoHandler
22:10:39 <ZFox> YayMe: You don't like do blocks?
22:11:00 * ZFox rages at import GHC.!!?
22:11:14 <ZFox> Handle is in System.IO
22:11:54 <ZFox> YayMe: I do quite a lot of networking personally (Well... Almost everything I've done in haskell uses Network) :P
22:12:17 <nejucomo> indomitus: You want to transform the result of a Monad type with a pure function?  The Monad type is probably also a Functor type, so you could use fmap.
22:12:49 <YayMe> ZFox: I wasn't sure how to work with a handle, when I googled and came up with a GHC module I thought it seemed way wrong but I asked in here and nobody answered about a better way of dealing with Handle's
22:13:07 <ZFox> YayMe: import System.IO (Handle)
22:13:08 <YayMe> System.IO.hGetChar?
22:13:24 <ZFox> Why are you getting a char?
22:13:25 <hpaste> David pasted “usage” at http://hpaste.org/83832
22:13:39 <YayMe> ZFox: how do I read and write from the Handle?
22:13:52 <ZFox> indomitus: That still has io String
22:13:56 <ZFox> indomitus: Try again
22:14:27 <ZFox> YayMe: ...
22:14:31 <ZFox> YayMe: hGetLine
22:14:36 <ZFox> hPutStrLn
22:14:45 <ZFox> For what you're doing, you don't need more
22:15:31 <YayMe> ZFox: those are in System.IO?
22:15:44 <ZFox> YayMe: indeed
22:15:54 <indomitus> ZFox, am i looking for a different function? or operators not in the paste?
22:15:57 <YayMe> cool ok then
22:16:05 <ZFox> indomitus: Step back a bit
22:16:13 <ZFox> You have.. getProgName
22:16:21 <ZFox> That is IO String
22:16:39 <ZFox> Then getProgName >>= (++"more string") :: IO String still
22:17:27 <Sgeo> > let ($) = asks in length $ foo -- this is not my work
22:17:29 <lambdabot>   Not in scope: `foo'
22:17:29 <lambdabot>  Perhaps you meant `Data.Traversable.for' (imported fro...
22:17:34 <Sgeo> > let ($) = asks in length $ "foo" -- this is not my work
22:17:36 <lambdabot>   3
22:18:29 <YayMe> Damnit why does windows never come with telnet by default anymore
22:18:39 <ZFox> YayMe: Because windows sucks
22:18:48 <nejucomo> :t getProgName
22:18:49 <lambdabot> Not in scope: `getProgName'
22:18:58 <ZFox> nejucomo: no io for lambdabot
22:19:01 <ZFox> @hoogle getProgName
22:19:02 <lambdabot> System.Environment getProgName :: IO String
22:19:22 <indomitus> I'm not quite sure of the difference between String and IO String, tbh
22:19:24 <nejucomo> ZFox: Shouldn't it be: fmap (++"more string") getProgName
22:19:39 <ZFox> nejucomo: Ah yes
22:19:46 <ZFox> sorry indomitus
22:19:48 <nejucomo> indomitus: String is the type of expression that evaluates to a String.
22:20:08 <nejucomo> indomitus: IO String is the type of expression that evaluates to an IO operation which results in a String when executed.
22:20:39 <ZFox> ("Usage: " ++) . (++ " [-dv] [degree]") <$> getProgName
22:20:40 <ZFox> even
22:20:45 <Sgeo> If String is a String, IO String is a program that results in a String
22:21:01 <ZFox> That reminds me of printf :P
22:21:06 <Sgeo> If a list of files is [File], then /bin/ls is IO [File]
22:21:12 <pharaun> :D
22:21:21 <Sgeo> I know I got that comparison from some well-known quote
22:21:25 <Sgeo> @quote ls
22:21:25 <lambdabot> edwardkmett says: Most monad tutorials are written by people who barely understand monads, if at all, but unfortunately nothing can stop someone from writing a monad tutorial. We've tried, there was
22:21:25 <lambdabot> blood everywhere.
22:21:25 <pharaun> i love /bin/ls -> IO [File] :)
22:21:34 <Sgeo> @quote /bin/ls
22:21:35 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
22:21:40 <pharaun> yes
22:21:44 <lightquake> oh, i like that one
22:22:11 <Sgeo> indomitus, does this help?
22:22:23 <lightquake> so if my code uses the pandoc library, what does that imply for the licensing of my code?
22:22:40 <Clint> lightquake: it must be gpl-compatible
22:23:49 <lightquake> so MIT's fine
22:24:11 <ZFox> indomitus: when (length args > 4) (putStrLn =<< ("Usage: " ++) . (++ " [-dv] [degree]") <$> getProgName >> exitFailure)
22:24:11 <lightquake> or BSD3 or whatever
22:24:20 <Clint> or ISC
22:24:48 <indomitus> Sego, it does, but i still don't quite understand. the fmap solution evaluates getProgName and applies (a->b) aka (++"more string") to it? and i need to look up <$>
22:25:11 <indomitus> ooh <$> is infix fmap got it
22:25:16 <ZFox> indomitus: <$> = infix fmap
22:25:17 <ZFox> yea
22:26:06 <indomitus> how does haskell know to insert that fmap at the . (or what does the period do? i assume there can only be one in such a statement)
22:26:20 <Clint> :t (.)
22:26:22 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:26:24 <ZFox> indomitus: (putStrLn =<< ("Usage: " ++) . (++ " [-dv] [degree]") <$> getProgName) >> exitFailure
22:26:25 <pharaun> you can have more than one .
22:26:38 <pharaun> custom = concatMap sortPlacesContainer . sliceBookmarks . getChildren
22:27:27 <Clint> > (+1) . (+1) . (+1) . (+1) . (+1) $ 0
22:27:28 <lambdabot>   5
22:28:29 <ZFox> indomitus: when (length "foo" >= 3) $ ("Usage: " ++) . (++ " [-dv] [degree]") <$> getProgName >>= putStrLn >> exitFailure
22:28:54 <indomitus> > (+1).(+2).(+3) $ 0
22:28:56 <lambdabot>   6
22:29:03 <Sgeo> I think Gregor is going to kill me
22:29:17 <Sgeo> I am laughing hysterically at something he introduced me to, and I'm eating.
22:29:20 <Sgeo> Um, ok, wrong chanenl
22:29:21 <ZFox> > ("<b>" ++).(++"</b>") "bold"
22:29:22 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
22:29:22 <lambdabot>              with actual ty...
22:29:27 <ZFox> > ("<b>" ++).(++"</b>") $ "bold"
22:29:29 <lambdabot>   "<b>bold</b>"
22:29:38 <indomitus> so that ^ is ( x + 3 + 2 + 1 | x = 0) essentially
22:30:55 <ZFox> > (+1).(+5-)$(+6)7
22:30:56 <lambdabot>   <hint>:1:10: parse error on input `)'
22:31:41 <ZFox> > (+1).(-5+)$(+6)7
22:31:41 <pharaun> Sgeo: uhoh if i don't ever see you in here ever again, can i have your computer
22:31:43 <lambdabot>   9
22:31:52 <ZFox> Hehe
22:32:30 <YayMe> :t System.IO.hGetString
22:32:31 <lambdabot> Not in scope: `System.IO.hGetString'
22:32:40 <ZFox> YayMe: NO hGetString!
22:32:44 <ZFox> YayMe: hGetLine
22:32:46 <YayMe> oh
22:32:50 <ZFox> :)
22:33:13 <ZFox> Well.... If you want a string :P
22:33:52 <indomitus> ZFox, that's: 7 +1 -5 +6?
22:34:01 <ZFox> indomitus: Yea
22:34:07 <ZFox> > 7 + 1 - 5 + 6
22:34:08 <lambdabot>   9
22:34:23 <ZFox> But shows how one would use minus in a function
22:34:27 <ZFox> as *
22:34:40 <ZFox> > (-5) 6 -- error
22:34:42 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> t))
22:34:42 <lambdabot>    arising from the ambiguity chec...
22:34:44 <ZFox> > (-5+) 6 -- error
22:34:45 <lambdabot>   1
22:34:47 <ZFox> not *
22:35:41 <indomitus> so is (-5+) 6 == -5 + 6 or +6 -5?
22:36:05 <ZFox> :)
22:36:09 <lispy> > (-5+) 0
22:36:10 <lambdabot>   -5
22:36:29 <lispy> > (\x -> -5+x) 0
22:36:30 <lambdabot>   -5
22:36:59 <indomitus> lisp, those are equivalent??
22:37:04 <indomitus> lispy*
22:37:09 <ZFox> @pl (\x -> -5+x)
22:37:09 <lambdabot> (line 1, column 8):
22:37:09 <lambdabot> unexpected "-"
22:37:09 <lambdabot> expecting lambda abstraction or expression
22:37:17 <ZFox> @pl a x = -5+x
22:37:17 <lambdabot> (line 1, column 6):
22:37:17 <lambdabot> unexpected " "
22:37:17 <lambdabot> expecting operator
22:37:20 <ZFox> Blah
22:37:32 <ZFox> @unpl (-5+)
22:37:32 <lambdabot> (\ a -> (- 5) + a)
22:37:37 <ZFox> :D
22:37:58 <ZFox> @unpl (+1).(+5-)$(+6)7
22:37:58 <lambdabot>  Parse error at ")$(+6..." (column 10)
22:38:02 <ZFox> lol
22:38:11 <ZFox> @unpl (+1).(-5+)$(+6)7
22:38:11 <lambdabot> (((- 5) + (7 + 6)) + 1)
22:38:45 <YayMe> ZFox: I was sitting here thinking my echo server was failing as I type and didn't get an echo, it was working perfectly, I didn't have local echo on so each character I saw was actually the server spitting it back to me heh
22:39:07 <ZFox> YayMe: So you made netcat
22:39:09 <YayMe> hGetLine on the other hand doesn't seem to be working
22:39:19 <ZFox> hGetLine worked
22:39:22 <ZFox> You didn't do it right tho
22:39:28 <YayMe> Probably true
22:39:33 <ZFox> try hGetLine >>= hPutStrLn h
22:39:36 <ZFox> try hGetLine h >>= hPutStrLn h
22:39:46 <ZFox> @pl hGetLine h >>= hPutStrLn h -- ap
22:39:46 <lambdabot> hPutStrLn h =<< hGetLine h
22:39:51 <ZFox> or not
22:39:57 <ZFox> lol
22:40:12 <ZFox> Pick one :P
22:41:31 <ZFox> YayMe: ping
22:41:55 <ZFox> YayMe: I made an echo server too... Except it takes binary and loops between server/client :D
22:42:58 <ZFox> Server said hello. client echo'd it back. server echo'd back etc.
22:43:10 <ZFox> :D
22:43:58 <hpaste> YayMe revised “broken echo server”: “broken echo server” at http://hpaste.org/83831
22:44:07 <ZFox> @denc hello world
22:44:07 <lambdabot> Unknown command, try @list
22:44:19 <YayMe> ZFox: this code doesn't work for me..
22:44:51 * hackagebot BlogLiterately-diagrams 0.1.2 - Include images in blog posts with inline diagrams code  http://hackage.haskell.org/package/BlogLiterately-diagrams-0.1.2 (BrentYorgey)
22:45:00 <ZFox> Messy
22:45:17 <YayMe> Yes well, I'm no great haskeller heh
22:45:47 <YayMe> Do you know why it's not echoing for me?
22:46:11 <ZFox> messy
22:46:53 <YayMe> ok...
22:47:12 <YayMe> it compiles and runs, and if I change the hGetLine to hGetChar and hPutStr to hPutChar it works fine..
22:48:21 <YayMe> nevermind, I must have busted something further, that doesn't work now either
22:49:03 <Sgeo> Buffering issues?
22:49:16 <Sgeo> No idea if that's a thing with networing
22:49:18 <Sgeo> networking
22:51:27 <indomitus> so I've begun to notice that there is a lot less error-checking involved in haskell (functional languages) as opposed to, say, C. is this your experience?
22:51:47 <YayMe> indomitus: there's a lot more errors found at compile time
22:52:47 <YayMe> you need less error checking code because of this, you can generate less error-prone scenarios. Though there's error handling code in Haskell still it's often handled fairly differently
22:53:15 <kennyd> indomitus my experience was the opposite
22:53:21 <indomitus> ya, i like that. but i mean as far as runtime errors go, haskell usually prints error messages and crashes for you. or at least tends to more than the imperative languages I've had experience with
22:53:57 <indomitus> kennyd, really?? how so? perhaps it is because of the types of programs you are developing?
22:54:00 <kennyd> whereas C gives you a segfault (if you're lucky) or randomly corrupts your data (if you are not).
22:55:33 <hpaste> ZFox annotated “broken echo server” with “broken echo server (annotation)” at http://hpaste.org/83831#a83834
22:55:37 <ZFox> YayMe: ^
22:55:40 <kennyd> indomitus nevermind I misunderstood, I thought you were talking about error checking by compiler at compile time for some reason.
22:55:55 <kennyd> it's getting late
22:56:38 <ZFox> YayMe: I didn't even run yours haha
22:56:41 * ZFox never got any errors
22:58:15 <hpaste> ZFox revised “broken echo server (annotation)”: “broken echo server (annotation)” at http://hpaste.org/83834
22:58:23 <ZFox> YayMe: Fixed exit :P
22:58:55 <YayMe> I'm an idiot
22:59:03 <ZFox> YayMe: What?
22:59:16 <ZFox> Why ?* *
22:59:17 <YayMe> the reason it was "broken" for me was stupid windows doesn't come with telnet anymore so I went and downloaded putty, and it was defaulting to SSH
22:59:25 <YayMe> so of course it was looking broken
22:59:34 <ZFox> xD
22:59:48 <ZFox> YayMe: ssh to some server use telnet there
22:59:51 <ZFox> or netcat :)
23:00:29 <ZFox> YayMe: Did you see my version?
23:00:29 <indomitus> kennyd, no worries. i'm just interested because I'm researching a paper I'm writing comparing the 2
23:00:39 <ZFox> YayMe: http://hpaste.org/83834
23:02:00 <hpaste> ZFox annotated “broken echo server” with “Working echo server!! w/ EOF handler, and exit escape!” at http://hpaste.org/83831#a83836
23:02:26 <YayMe> ZFox: Yeah, I saw. You lined everything all up in do notation
23:02:34 <ZFox> :P
23:02:43 <YayMe> is that common?
23:02:47 <ZFox> YayMe: I re-wrote the whole thing
23:02:58 <YayMe> I know do notation is, but the organizing things on lines
23:03:00 <ZFox> For what it's doing.. It's cleaner
23:03:10 <ZFox> Common to be reasable
23:03:12 <ZFox> readable *
23:03:17 <ZFox> reasonable too
23:03:17 <YayMe> I appreciate that it gives pointers for handling the exceptional cases
23:03:30 <ZFox> :)
23:03:58 <ZFox> You can easily merge main and runConn if you'd like
23:04:02 <ZFox> I'm just used to the splits
23:04:10 <YayMe> anywho, time for me to hit the hay. Thanks for the help ZFox
23:04:19 <ZFox> Enjoy YayMe ^_^
23:04:32 <ZFox> YayMe: When you have more fun with networking.. Tell me, I'll gladly help you out ^_^
23:04:54 * ZFox gotta go too ^_^
23:04:56 <ZFox> Catcha YayMe
23:08:49 <ZFox> Back too hot outside D: Ima leave later
23:09:37 <ZFox> YayMe: I suggest not using windows btw ;) Especially when playing with networking :P
23:12:21 <ab9rf> could be worse
23:12:26 <ab9rf> you could be using novell
23:12:42 <pharaun> oh god
23:13:26 <ab9rf> because IPX makes everything better
23:14:50 <ZFox> Heh
23:24:18 <Sgeo> @let o = (.)
23:24:20 <lambdabot>  Defined.
23:24:43 <Sgeo> > (+1) `o` (*2) `o` (/3) $ 9
23:24:45 <lambdabot>   Ambiguous occurrence `o'
23:24:45 <lambdabot>  It could refer to either `L.o', defined at <local...
23:27:29 <amindfv> how long does lambdabot hold onto those definitions for?
23:30:13 <lispy> amindfv: until someone says @undef
23:30:48 * lispy wishes @let/@undef were keyed on the names they introduce so it could be finer grained
23:34:52 * hackagebot HPDF 1.4.5 - Generation of PDF documents  http://hackage.haskell.org/package/HPDF-1.4.5 (alpheccar)
23:48:03 <hpaste> David pasted “bug” at http://hpaste.org/83839
23:48:26 <indomitus> can anyone tell me whats wrong with this?
23:49:21 <XexonixXexillion> is list a list, or the length of a list?
23:50:30 <indomitus> the length
23:51:15 <indomitus> list = length (lines words) where words comes from readFile
23:53:46 <Ralith> indomitus: procedure for asking for help
23:53:49 <Ralith> 1. what are you doing
23:53:52 <Ralith> 2. what happens
23:53:55 <Ralith> 3. what did you expect to happen instead
23:54:13 <Ralith> 4. all relevant code and error messages
23:54:43 <Ralith> if any of the above are missing, you are forcing people to speculate.
23:55:35 <indomitus> 1. printing an error message and bailing 2. Couldn't match expected type `ExitCode' with actual type `Int -> ExitCode' 3. no compilation errors, if list is too short, program bails 4. i think its all here
23:58:52 <luite> indomitus: ExitFailure takes an Int, the exit code
23:59:53 * hackagebot matchers 0.6.0.0 - Text matchers  http://hackage.haskell.org/package/matchers-0.6.0.0 (OmariNorman)
