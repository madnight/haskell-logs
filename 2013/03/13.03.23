00:00:19 <kallisti> why?
00:04:43 <cschneid> if I have a ByteString, and want to spit it out as a string containing hex characters, "aabbcc", how would I do that.  hoogle for ByteString-> String doesn't show much, I imagine it's a sidetrip through Numeric or similar?
00:05:22 <wavewave> hi
00:05:35 <wavewave> how can I combine two lenses into one?
00:05:50 <wavewave> when I use Control.Lens
00:06:18 <mewalz> cschneid: look in Data.ByteString.Char8
00:06:26 <shachaf> wavewave: Probably there's no easy way.
00:06:31 <wavewave> for example,  make onefour = (_1,_4)
00:06:33 <shachaf> wavewave: The trouble is that they might overlap, for instance.
00:06:47 <shachaf> But see various operators for working with multiple lenses, e.g. alongside.
00:06:48 <mewalz> cschneid: unpack I believe
00:07:27 <wavewave> When using fclabels, I could use applicative, say  (,) <$> _1 <*> _2
00:07:39 <mewalz> cshneid: Char8 bytestrings are the same as regular bytestrings too
00:07:52 <wavewave> can't I do this similarly?
00:08:11 <cschneid> mewalz: that gets me[Char] pretty easily, but how do I get to hex. I have a showHex command on Numeric which looks promising
00:08:36 <wavewave> shachaf: I will look up alongside. thanks.
00:09:17 <mewalz> that is called B64, check out Data.bytestring.b64 does that
00:09:31 <mewalz> *Base64 not B64
00:10:21 <cschneid> base 64 isn't hex.  I want to output the bytes I have as a string version of that. So the result if "FFAA00" or whatever
00:10:41 <cschneid> so I have a ByteString, and want that.
00:11:38 <Pods> From what I understand /Foo -> Bar is a function definition wherein Foo would be the input type and Bar would be the output, but what does (++)  :: [a] -> [a] -> [a] mean ??
00:13:51 <mewalz> cschneid: I was mistaken, I've had good luck with the data.hex package
00:14:41 <mewalz> cshneid: or base16-bytestring
00:14:56 <wavewave> shachaf: that lenses might be overlapped is a good point.  I am wondering how fclabels treated this problem.
00:15:38 <cschneid> cool
00:16:23 <cschneid> Data.hex worked instantly
00:20:49 <darkf> is there a way to do multiple patterns in one arm of a case? (e.g. case 5 of 5 | 10 -> ...)
00:23:54 <shachaf> wavewave: It has an operator for this?
00:24:14 <luite> darkf: case x of n | n == 10 || n == 5 ->
00:24:32 <darkf> luite: ugly, but works ;p
00:24:46 <shachaf> n `elem` [5,10]
00:25:04 <mewalz> Is there any reason to use STM over MVARs when only one thread has the right to modify the shared object?
00:26:23 <wavewave> shachaf : you mean fclabels?
00:26:33 <shachaf> Yes.
00:27:39 <wavewave> shachaf:  see Data.Label module in hackage documentation of fclabels
00:28:12 * BadKitty thinks he should seperate his token library to have base62 seperate.
00:28:24 <wavewave> ageAndCity example shows how to make a combined lens using applicative.
00:28:47 <wavewave> but I think your point is valid. probably this may break some lens laws.
00:32:13 <wavewave> now I am convinced that using a chain of lenses is better than making a combined lens (possibly law-breaking)
00:33:45 <Pods>  From what I understand /Foo -> Bar is a function definition wherein Foo would be the input type and Bar would be the output, but what does (++)  :: [a] -> [a] -> [a] mean ??
00:34:00 <Pods> ^Could anyone shed light on this ??
00:34:19 <wavewave> you can think [a] -> ([a] -> [a])
00:34:34 <fizbin> Pods: Foo -> Bar is not a function _definition_; it is a function _type_.
00:34:36 <wavewave> -> is right associative
00:35:11 <wavewave> (++) 1 gives a function from [a] to [a]
00:35:21 <Pods> something like recursive inputs and outputs ??
00:35:25 <wavewave> uhm sorry (++) [1]
00:35:28 <fizbin> What "(++)  :: [a] -> [a] -> [a]" says is "++" is a function with the _type_ "[a]->[a]->[a]"
00:35:58 <Pods> fizbin : and what would type [a] -> [a] -> [a] mean ??
00:36:21 <wavewave> Pods : it's isomorphic to ([a],[a]) -> [a]
00:36:37 <Pods> Oh okay
00:36:38 <wavewave> take two lists and get one list
00:36:41 <fizbin> Translating that type into English, it means "for any other type 'a', ++ takes two lists-of-a and returns another list-of-a"
00:36:56 <Pods> makes a lot more sense now
00:37:07 <fizbin> Scratch the word "other" from my English translation.
00:37:11 <wavewave> but if you think about partially applied function, then it's function generating function.
00:37:15 <Pods> Is haskell predominantly written with predicate logic as its basis ??
00:37:39 <Pods> wavewave : what is a partially applied function ??
00:37:45 <wavewave> Pods: if you apply only one argument to (++)
00:37:53 <wavewave> like (++) [1]
00:38:01 <fizbin> > map (3 +) [1,2,3,4,5]
00:38:02 <lambdabot>   [4,5,6,7,8]
00:38:11 <fizbin> :t (3 +)
00:38:13 <lambdabot> Num a => a -> a
00:38:30 <wavewave> it still make sense. because whatever next comes after it, it will add [1] .
00:38:52 <wavewave> so (++) [1] is a function which takes a list and output a combined list with [1]
00:39:06 <fizbin> "(3 +)" is a partially applied function. "+" normally takes two numbers; "(3 +)" is a function that takes one number.
00:39:12 <wavewave> this is called partial application of function argument.
00:39:27 <wavewave> then [a] -> [a] -> [a] notation makes sense.
00:39:29 <Pods> ohkay, i got it :)
00:39:34 <Pods> yes it does now
00:39:43 <wavewave> [a] -> [a] -> [a]  is equivalent to [a] -> ( [a] -> [a] )
00:39:51 <wavewave> this is called currying.
00:40:14 <otters> rats, my hackage password hasn't been reset yet
00:40:16 <otters> I can't deploy
00:40:41 <wavewave> this is why haskell programming usually doesn't use (a,b,..) for multiple argument functions.
00:40:51 <wavewave> f a b  instead of f (a,b)
00:41:01 <wavewave> they are equivalent.
00:41:28 <fizbin> :t curry
00:41:29 <lambdabot> ((a, b) -> c) -> a -> b -> c
00:41:31 <fizbin> :t uncurry
00:41:32 <lambdabot> (a -> b -> c) -> (a, b) -> c
00:41:33 <wavewave> and more powerful, since you can have a free function (f a) as a bonus.
00:41:41 <Pods> Right , so by definition it makes sense that I take a function taking many arguments and i make a partial function taking a single argument
00:41:47 <Pods> and that will be currying :)
00:42:16 <wavewave> Pods: you got it. You will feel more comfortable when seeing haskell type definitions now .
00:42:44 <Pods> I can already feel the concepts nesting in now :)
00:43:25 <Pods> So, Is haskell predominantly written with predicate logic as its basis ?? I cant help but draw out similarities in the two
00:43:25 <wavewave> You will be addicted to currying everything ;-)
00:44:12 <wavewave> I am not sure about what you mean by predicate logic. but haskell has quite strong background in mathematics.
00:44:39 <wavewave> strictly to typed lambda calculus.
00:44:56 <wavewave> which is foundation of computational logic
00:45:13 <Pods> which in turn is derived by propositional and predicate logic :)
00:45:57 <wavewave> both ways in fact. logic can be defined in terms of lambda calculus, too.
00:46:06 <Pods> Wondering if haskell features in "the beautiful code" ..This is graceful translation of pure logic into computer science.
00:46:33 <Pods> No wonder haskell is much closer to semantics than any other language i know of..
00:47:32 <wavewave> Pods: if you are interested in logic/ proof related system, you will be interested in dependent type languages some time soon, too.
00:47:50 <wavewave> like Agda, Coq, Idris, Cayenne... etc.
00:48:26 <wavewave> haskell is not dependent typed, but closely related to them.
00:48:36 <Pods> Havent been exposed to them yet, academic curriculums are restrictive ..(just a matter of flexing them a little bit. )
00:49:28 <Pods> *Agda, Coq, Idris, Cayenne noted in the to-do sometime list :)
00:49:39 <wavewave> Pods: any way one by one. Learning haskell is definitely the right road to learn those languages.
00:50:18 <Pods> yes :)
00:50:40 <no-n> what are teh main dependent typed languages?
00:51:08 <wavewave> no-n: I think agda is promising. at least for haskellers.
00:51:25 <Chousuke> idris looks neat as well
00:51:30 <wavewave> no-n: probably coq is for ML programmers.
00:51:49 <wavewave> idris is really nice. it's very new.
00:52:49 <wavewave> I haven't looked at coq much, but for real world proof checker system, coq is the best I heard .
00:54:37 <wavewave> dependent type languages have practical use in proof checking, but not yet for practical programming. agda and idris are experimenting towards practical language.
00:55:16 <no-n> *nod*
00:57:10 <wavewave> as for dependent types, the position of haskell looks in-between. haskell is not pursuing full dependent typing, but embracing lightweight dependent type system to a certain extent.
00:57:21 <Chousuke> the effect system in idris seems really nice compared to stacking monad transformers :P
00:58:14 <wavewave> Chousuke: I am not sure effect system can replace monad transformer, though.
00:58:41 <Chousuke> not in general perhaps, but in the case of combining effects, yes.
00:59:07 <wavewave> monad transformer is more about modularization.
00:59:15 <Pods> Wondering if it is the right time to start looking at monads now ...
01:00:00 <wavewave> Pods: learn as you go. you cannot avoid monads any way ;-)
01:00:13 <Chousuke> wavewave: the point being that instead of having to create a type that is a combination of the MTs you need, the system in idris allows a list of effects your function depends on, and then it's like you had the equvalent MT stack, but you don't need to use lift :P
01:00:39 <Chousuke> it's very interesting
01:01:12 <Pods> wavewave: So I am getting there today sometime it seems :)
01:01:18 <fizbin> Any Arrow experts around? Specifically, anyone know what an example would be of an ArrowZero that wouldn't be an ArrowPlus ?
01:02:00 <wavewave> Chousuke: yeah. in terms of side effects, you have a point, but monad transformer is not only about side effect. for example ListT
01:02:30 <Chousuke> wavewave: I'm not talking about side-effects
01:02:31 <Chousuke> just effects
01:02:46 <Chousuke> State, List, Maybe and IO all apply.
01:04:07 <vlatkoB> How to write the following in one line?
01:04:07 <vlatkoB>   readFile fileName >>= doPureTest >>= print
01:04:07 <vlatkoB> Print the result of pure function that processes the content of the file
01:04:43 <wavewave> Chousuke: still separation of concern matters. Transformer ways is one way to achieve it. anyway I agree your point.
01:05:07 <Chousuke> wavewave: I'm saying there is separation of concerns in the Idris system
01:06:18 <Chousuke> As far as I can tell it's pretty much equivalent to monad transformers for its intended use case, except it does type-level programming magic that means you don't have to do explicit lifts everywhere
01:07:00 <wavewave> Chousuke: yeah. maybe you're right. In fact monad transformers are nothing but type-level list.
01:07:16 <wavewave> type-level heterogeneous list.
01:07:21 <mikeplus64> mutable vectors have a function "grow" :: Int -> BigScaryVectorTypeFamily a -> m (BigScaryVectorTypeFamily a)
01:07:27 <mikeplus64> is there an "in place" grow?
01:07:45 <supki> vlatkoB: readFile fileName >>= print . doPureTest ?
01:08:32 <wavewave> if we can make type level tree or type level graph.. much more expressive and modular programming may be possible
01:09:51 <augur> wavewave: try agda!
01:09:52 <wavewave> for example, type level map. instead of monad transformers, then we don't need to remember how many stacks I put on..
01:10:05 <vlatkoB> supki: Thanks, it works.
01:10:19 <mikeplus64> another perhaps more suiting question is: what is the "best" structure for a sequence (order doesn't matter) that i will have to iterate through many times very frequently, and less frequently add/remove elements? a vector from the vector package doesn't seem to fit, although i could just use IORef (IOVector a)
01:10:46 <wavewave> no more lift . lift . lift . lift ..   but just (lift (state :: type level) )
01:10:57 <Chousuke> wavewave: well, yeah, the idris system does have a type-level list in it so maybe it in fact is exactly equivalent to monad transformers :P
01:11:05 <augur> wavewave: you should implement this in agda as a proof of concept
01:11:10 <Chousuke> but I don't know enough to say for sure.
01:11:27 <wavewave> Chousuke : yeah.. I am now sorta sold by you ;-)
01:11:56 <augur> wavewave: dont listen to chosuke! use agda! agda > all!
01:12:20 <augur> ok, idris is cool in that it lets you use more haskelly syntax, but it lacks the interactivity that agda has
01:12:39 <mikeplus64> surely there is a ghci for idris
01:13:09 <augur> sure but thats not wht i mean
01:13:33 <augur> agda mode for emacs is incredibly useful. idris lacks something like this, currently,
01:15:12 <wavewave> augur: can we use haskell functions in agda well by the way?
01:15:35 <wavewave> I am more practical side.
01:15:48 <augur> you can use the FFI stuff. but i just meant as a proof of concept to show how using dependent types avoids ugly monad transformer stuff
01:16:47 <skyflash_> Is there a way to install a cabal package so you can edit its source (to fix a big) and easily recompile and use it as normal?
01:16:50 <wavewave> yeah. maybe that's a good motivation for me to learn agda.
01:17:03 <augur> wavewave: agda's pretty simple. its like haskell, but not!
01:17:25 <wavewave> skyflash_ : just cabal unpack and modify source and install?
01:18:29 <skyflash_> wavewave: OK, sounds simple enough.  I've already got the package installed and in use, so I guess I unpack, edit then reinstall.
01:18:32 <wavewave> augur: yes. I know of syntax. but I found that grokking it is very difficult.
01:19:02 <luite> skyflash_: what i usually do in those situations is cabal unpack, fix bug, edit .cabal, bump version by .1 (add a .1), then cabal-src-install --src-only
01:19:26 <skyflash_> luite: Thanks.  I'll try that.
01:19:26 <luite> skyflash_: then it will be available in your local package database (cabal-src-install is in the cabal-src package)
01:19:37 <wavewave> luite: i was not aware of cabal-src-install.. good.
01:20:28 <luite> wavewave: its quite useful if you need to maintain a dozen or so patched packages
01:20:43 <augur> wavewave: someone on the mailing list just asked for intro stuff, so i might as well give it to you too
01:21:05 <wavewave> augur: thanks!
01:21:44 <augur> wavewave: http://www.cse.chalmers.se/~peterd/papers/DependentTypesAtWork.pdf http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf http://www.youtube.com/playlist?list=PL44F162A8B8CB7C87 https://www.cs.uoregon.edu/research/summerschool/summer10/curriculum.html (search for conor mcbride)
01:21:53 <luite> bleh idris' javascript backend is at least 10x smaller than ghcjs, i'm jealous :p
01:22:23 <pharaun> cabal-src-install, hmm
01:22:50 <wavewave> augur: thanks!
01:22:52 <pharaun> https://github.com/yesodweb/cabal-src this ?
01:22:57 <luite> yes
01:23:06 <augur> wavewave: #agda too
01:23:13 <augur> dont be shy, ask questions!
01:23:50 <wavewave> :-)
01:24:23 <augur> wavewave: actually, i'd give you a full on tutorial right now if you wanted. its a fun language
01:25:47 <wavewave> augur: :-) I will read through the articles you send first. Thanks though. :-D
01:26:02 <augur> wavewave: join the channel tho. youll probably have questions.
01:26:10 <wavewave> yup
01:29:40 <wavewave> since it came to the discussion, how is epigram project going?
01:29:54 <augur> not released yet, but when it is its gonna be awesome
01:30:29 <augur> epigram 2 i mean
01:30:41 <augur> epigram 1 is out but its missing a lot of the awesomeness that epigram 2 is going to have
01:30:49 <wavewave> i see.
01:31:39 <fizbin> @src returnA
01:31:39 <lambdabot> returnA = arr id
01:32:51 <fizbin> @src isA
01:32:52 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
01:37:03 <notdan> epigram 2 is going to be released at all?
01:37:15 <notdan> i thought Conor McBride has abandoned it
01:42:03 <skyflash_> luite: cabal-src-install worked beautifully.  Thanks for the tip.
01:45:06 <augur> notdan: conor doesnt work on it anymore, but i think mostly because its being devved by his previous uni
01:45:17 <augur> and so he cant work on it anymore
01:45:27 <augur> but i think hes still providing input, at least
01:56:46 * BadKitty is surprised that there is no "none" alias to not . all
01:58:39 <BadKitty> But again all (not . f)
01:59:11 <BadKitty> any even
02:12:39 <supki> @google Fairbairn threshold
02:12:41 <lambdabot> http://www.haskell.org/pipermail/libraries/2012-February/017548.html
02:12:41 <lambdabot> Title: generalization of maybeToList
02:12:44 <supki> BadKitty: ^
02:13:15 <BadKitty> supki: ?
02:14:14 <arkeet> btw, maybeToList = toList
02:14:17 <arkeet> or msum, or asum
02:14:36 <arkeet> if you're generalizing, why not generalize to (Foldable t, Alternative f) => t a -> f a
02:14:42 <arkeet> :t Data.Foldable.asum
02:14:43 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
02:14:47 <arkeet> err
02:14:51 <arkeet> not quite msum.
02:14:53 <arkeet> or asum.
02:15:16 <arkeet> hmm
02:15:29 <arkeet> :t Data.Foldable.asum . fmap pure
02:15:30 <lambdabot> (Functor t, Foldable t, Alternative f) => t a -> f a
02:15:33 <arkeet> good enough.
02:35:14 <BadKitty> supki: Err, I just read through that in full and noticed exactly what you meant.
02:35:43 <BadKitty> supki: Hehe.. So.. System.IO has too much under the threshold ;)
02:40:20 <BadKitty> Helper functions have a reason / purpose.
03:04:12 <dibblego> I have packages on hackage that need deletion/deprecation and also some I'd like to rename (e.g. I used capital letters, sorry it was 2009) — is there a process to do this?
03:05:49 <Saizan> dibblego: for deprecation i think you're supposed to mail ross
03:06:13 <dibblego> ok, what about renaming?
03:06:27 <dibblego> I might just email Ross and ask
03:06:31 <Saizan> no idea, i guess you can ask in the same email :)
03:06:40 <dibblego> yep cheers
03:06:54 <dibblego> Ross Paterson right?
03:08:16 <typoclass> this package has a big red "obsolete" warning, i wonder what triggered it. i'm guessing the word "deprecated" in the package description
03:08:29 <dibblego> which?
03:08:52 <typoclass> http://hackage.haskell.org/package/web-encodings <- this one. sorry, it's too early :-)
03:09:04 * typoclass crawls towards the coffee pot
03:10:33 <Saizan> yeah
03:10:36 <mallory> @ezyang
03:10:36 <lambdabot> Unknown command, try @list
03:10:41 <mallory> @list
03:10:43 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
03:11:16 <skp> hey
03:11:24 <skp> I try to compile a program with cabal-dev
03:11:26 <typoclass> dibblego: could you include a hint what people are supposed to use instead? (link to a blog post or to a replacement package). thanks a lot. that's one thing that bugs me about web-encodings
03:11:26 <skp> cabal: Could not resolve dependencies:
03:11:29 <skp> I got that
03:11:42 <skp> and the suggestion is the app version itself
03:11:52 <skp> do you have an idea about that issue?
03:11:58 <supki> skp: try with -v3
03:12:11 <dibblego> typoclass: I haven't a clue sorry, perhaps contact maintainers
03:12:13 <mallory> users seen
03:12:35 <skp> thanks supki
03:13:00 <skp> [__1] rejecting: base-3.0.3.2, 3.0.3.1 (global constraint requires installed instance)
03:13:04 <skp> is this bad?
03:14:28 <typoclass> dibblego: no, i mean about your own packages that you're deprecating
03:15:04 <tsinnema> i've been squiggling together some category theory, planning some possible experimentation in row polymorphism -- but i don't know whether to start writing it in scala or haskell. i'm very much a newbie to haskell
03:15:05 <dibblego> typoclass: oh yes I will be doing something like that once I know the proper process
03:15:21 <supki> skp: no
03:15:34 <dibblego> tsinnema: scala is not fun to entertain category theory
03:15:40 <typoclass> dibblego: i meant to say, please don't add a "deprecated" label and nothing else. it's frustrating if users find a package that does what they want, but it's marked deprecated for no apparent reason and with no information on what to use instead; not even a link to a blog post. often, they'll end up using the deprecated package anyway, just with an insecure feeling. but that's not what the author wanted either :-)
03:15:45 <skp> hm
03:15:46 <typoclass> dibblego: sounds great, thanks
03:15:57 <dibblego> typoclass: yes I can understand that frustration
03:16:07 <srhb> typoclass: old-time hurts me, too. The new time library doesn't implement a lot of what was in old-time.
03:16:37 <srhb> Actually mostly it just doesn't implement things that ought to be there for obvious reasons. ._.
03:16:47 <tsinnema> i know that edwardk has some nice-looking modules for category theory in haskell so that seems like a natural way to go
03:17:00 <typoclass> srhb: old-locale is an annoying one. there just is no such thing as new-locale :-/ so it's just confusing
03:17:05 <srhb> tsinnema: I think Scala will put a lot of road blocks in your way if your object is CT.
03:17:11 <srhb> typoclass: Yeah.
03:17:12 <dibblego> tsinnema: edwardk and I implemented a lot of it in scala too — just stick with haskell if it is for education purposes
03:17:32 <dibblego> scala puts road blocks in your way proportional to how effective you want to be
03:17:44 <srhb> I suppose that's another way of putting it. :)
03:17:50 <dibblego> tsinnema: edwardk did a lot of the generalising work in scalaz6
03:18:03 <typoclass> srhb: out of curiosity, which things are missing in time, compared to old-time?
03:18:26 <typoclass> @remember dibblego scala puts road blocks in your way proportional to how effective you want to be
03:18:27 <lambdabot> Nice!
03:19:35 <tsinnema> dibblego, srhb, the only obstacle in that direction is that i've hardly written a line in haskell. but i suppose learning haskell as i go shouldn't be much more of a problem than dealing with the quirks of scala
03:19:43 <dibblego> I starter scalaz in 2008 when I had to write a production app on the JVM and noticed all the basic libraries were missing
03:20:00 <dibblego> tsinnema: I highly recommend haskell for your endeavour — we are here to help you
03:20:20 * typoclass purrs friendlily at tsinnema
03:20:43 <dibblego> tsinnema: if you concede and use scala, we are over at #scalaz to help you too
03:20:50 <tsinnema> sure
03:20:59 <skp> oh?
03:21:08 <dibblego> oh there you are
03:21:15 <skp> cabal-dev doesn’t install private dependencies
03:21:25 <skp> that sounds quite obvious actually
03:22:26 <typoclass> tsinnema: the man himself (edwardk) is in here quite often and is very responsive. also most of what he says requires a saving throw against confusion
03:23:28 <dEPY> anyone can help me with this? https://gist.github.com/depy/5227221
03:23:37 <typoclass> s/also/although
03:24:23 <monoidal> dEPY: s/[bmi w h |/[bmi|
03:24:27 <aristid> typoclass: which means you can level up your confusion resistance
03:24:54 <gspr> Suppose I have a function foo :: Bar a -> Baz a, where Bar a is some data type with a structure highly optimal for what foo does. Let's say you can build Bar a from [a] by means of fromList :: [a] -> Bar a. In a package, do I expose foo and fromList, or a version of foo that takes lists? What if Bar a is really complicated, and making Bar a's from lists is expensive, but making them from Vector a's is cheap? Do I expose both alternatives? Maybe
03:25:07 <dEPY> monoidal: tnx
03:25:11 <typoclass> dEPY: hello. i suppose line 10 of your paste is the most important
03:26:39 <dEPY> Yes monoidal pointed that out for me.. :)
03:27:17 <srhb> gspr: If there's an efficient and a very inefficient way of constructing your Bars, you should probably hide away the inefficient one or put rather large disclaimers on it. It's hard to say something general about it.
03:28:03 <typoclass> gspr: hello. for me, you got cut off at "both alternatives? Maybe"
03:43:29 <Sgeo> @hoogle (<|>)
03:43:29 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
03:43:30 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
03:43:30 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
03:51:50 <gspr> typoclass: Ah, sorry! After Maybe I just said "it's a matter of taste, but I thought I'd ask"
03:52:09 <gspr> srhb: Right, OK. Makes sense.
03:52:14 <gspr> thanks
03:55:36 <skp> hey, I have a module which aim is to import others
03:55:48 <skp> do I have to use the `import` keyword?
03:55:52 <skp> it’s quite borring
03:56:00 <skp> since it’s already done in the export statememnt
03:56:25 <skp> module Foo ( module Bar, module Zoo ) where
03:56:31 <skp> and leave the file empty
03:56:33 <skp> is it possible?
03:58:32 <liyang> @faq Can Haskell have otherwise empty modules that simply re-export other modules?
03:58:32 <lambdabot> The answer is: Yes! Haskell can do that.
03:58:52 <srhb> But not without the import statements, though?
03:59:51 <srhb> skp: So no.
04:00:03 <liyang> Well, there's the trick of module Foo (module X) where import Bar as X; import Cow as X; import Moo as X
04:00:22 <liyang> But that buggers up Haddock if you're worried about that kind of thing.
04:00:34 <adnap> In ghci, I do ":m + Data.Text" followed by "let t = "(1,1)" :: Data.Text" and I get "Failed to load interface for `Data
04:00:39 <adnap> '"
04:01:00 <liyang> adnap: you mean Data.Text.Text
04:01:29 <liyang> Data.Text is the module, Data.Text.Text is the (qualified) type.
04:01:37 <srhb> Or simply :: Text
04:01:43 <adnap> I have been using Yesod and all the examples have "Data.Text as T". I guess this is misleading?
04:01:52 <srhb> adnap: Then it's T.Text
04:02:19 <srhb> Unless it's unqualified, in which case Text works too.
04:02:29 <adnap> Oh, nevermind. I'm just silly
04:02:32 <adnap> srhb: Thanks
04:03:01 <adnap> Okay, so if I do...
04:03:30 <adnap> In ghci, I do ":m + Data.Text" followed by "let t = "(1,1)" :: Data.Text.Text", I get "Couldn't match expected type `Text' with actual type `[Char]'..."
04:03:44 <srhb> adnap: You need OverloadedStrings to do that
04:03:48 <srhb> Otherwise "foo" :: String
04:03:52 <adnap> Oh, right
04:03:56 <srhb> :set -XOverloadedStrings
04:04:30 <adnap> Huh...
04:04:43 <adnap> So I can successfully do "let x = read $ show t :: (Int, Int)"
04:04:55 <srhb> Sure.
04:05:02 <adnap> I have having problems getting this to work in Yesod
04:05:14 <srhb> Though read . show is rather ugly :P
04:05:50 <adnap> I think it may have something to do with the text really being "(1%2C1)"
04:06:02 <srhb> What may have to do with that?
04:06:25 <adnap> The fact that I'm getting "Prelude.read: no parse" when I do virtually the same thing in Yesod
04:06:32 <srhb> Ah, yes.
04:06:45 <srhb> read doesn't readily parse (1%2C1) as (Int,Int)
04:06:55 <srhb> (And why would it?)
04:07:17 <adnap> Yeah, but I'm not certain that the Text value is really (1%2C1). It's just a guess. It
04:07:31 <adnap> It's confusing, because if I print the Text value to the web page, it shows up as (1,1)
04:07:34 <srhb> read doesn't take a Text anyway.
04:07:42 <srhb> print it to your terminal instead then.
04:08:17 <skp> 11:59 < liyang> Well, there's the trick of module Foo (module X) where import Bar as X; import Cow as X; import Moo as X
04:08:20 <skp> huh?
04:08:20 * srhb has to run for a bit
04:08:35 <srhb> skp: You can group them all with the qualifier X and just export that.
04:08:38 <skp> so I can’t do what it without importing the module
04:08:43 <srhb> No.
04:08:52 <skp> that’s weird :D
04:08:59 <adnap> Hm...
04:09:09 <skp> what if there’re conflicts?
04:09:14 <adnap> In the terminal, I get "(1,1)"
04:09:29 <adnap> for "liftIO $ putStrLn $ show test"
04:09:36 <srhb> Try printing it instead.
04:09:38 <adnap> where "test" is a Data.Text.Text value
04:09:48 <adnap> srhb: What do you mean?
04:10:14 <adnap> Oh, "print"?
04:10:54 <adnap> That still prints "(1,1)"
04:12:44 <supki> > read "\"(1,1)\"" :: (Int,Int)
04:12:46 <lambdabot>   *Exception: Prelude.read: no parse
04:12:47 <supki> > read "(1,1)" :: (Int,Int)
04:12:49 <lambdabot>   (1,1)
04:12:57 <supki> adnap: I'd guess that's your problem?
04:13:39 <adnap> Hm...
04:14:12 <supki> showing Text adds extra quotes
04:14:30 <adnap> I should be using unpack!
04:14:43 <supki> > (read . read) "\"(1,1)\"" :: (Int,Int)
04:14:44 <lambdabot>   (1,1)
04:15:17 <adnap> It works!
04:15:20 <adnap> supki: Thanks
04:15:42 <supki> wait, you wasn't supposed to use (read . read) =(
04:15:56 <adnap> > read . unpack . pack "(1,1)" :: (Int,Int)
04:15:58 <lambdabot>   Not in scope: `unpack'
04:15:59 <lambdabot>  Perhaps you meant one of these:
04:15:59 <lambdabot>    `BS.unpack' (imp...
04:16:13 <adnap> > read . Data.Text.Text.unpack . Data.Text.Textpack "(1,1)" :: (Int,Int)
04:16:15 <lambdabot>   Not in scope: `Data.Text.Text.unpack'Not in scope: data constructor `Data.T...
04:16:17 <adnap> > read . Data.Text.Text.unpack . Data.Text.Text.pack "(1,1)" :: (Int,Int)
04:16:18 <lambdabot>   Not in scope: `Data.Text.Text.unpack'Not in scope: `Data.Text.Text.pack'
04:16:43 <Hermit> > read . Data.Text.unpack . Data.Text.pack "(1,1)" :: (Int,Int)
04:16:45 <lambdabot>   Not in scope: `Data.Text.unpack'Not in scope: `Data.Text.pack'
04:16:51 <adnap> Hrm
04:17:00 <adnap> Well, it works in my code!
04:17:28 <merijn> if (read . read) works, it's escaped one time to many, where is the value coming from?
04:17:45 <supki> from  show  on Text
04:17:48 <Hermit> > read . Data.Text.Lazy.unpack . Data.Text.Lazy.pack "(1,1)" :: (Int,Int)
04:17:50 <lambdabot>   Not in scope: `Data.Text.Lazy.unpack'Not in scope: `Data.Text.Lazy.pack'
04:17:54 <Hermit> fuck it
04:17:59 <adnap> ^
04:18:00 <merijn> ah, but show on Text is probably wrong
04:18:04 <shanse> > read . BS.unpack . BS.pack "(1,1)" :: (Int, Int)
04:18:06 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
04:18:06 <lambdabot>              with actual type...
04:18:41 <shanse> it's BS, just like lambdabot told you
04:18:44 <merijn> You probably want to replace show with unpack
04:19:09 <merijn> shanse: No, he said he had Text, not ByteString
04:19:57 <merijn> "putStrLn . read . Data.Text.unpack $ test" would be the way to go
04:20:08 <merijn> eh, wait
04:20:16 <merijn> I forgot the original line you had...whatever
04:20:37 <merijn> show on text is like calling show on String
04:20:41 <merijn> > show "test"
04:20:43 <lambdabot>   "\"test\""
04:20:49 <merijn> That's what's messing up the read
04:24:22 <aCube> Can I ignore some declarations in HPC? (So they don't show up)? Because I can't test instances for Void ...
04:25:08 <arkeet> > fix show
04:25:10 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
04:28:39 <skp> hey, do you know a way to retrieve the length of an array got with the withArray function?
04:28:49 <skp> arrayLength0 seems to be here for CString
04:29:00 <skp> since it « doesn’t include terminator »
04:29:13 <skp> there’s no terminator in common arrays
04:29:41 <arkeet> skp: you look at the length of the list you give it.
04:30:12 <skp> hm
04:30:17 <skp> and if I want to C length
04:30:19 <skp> just
04:30:28 <skp> length […] * sizeOf
04:30:28 <skp> ?
04:30:34 <arkeet> sure.
04:30:36 <skp> nice
04:30:39 <skp> thank you
04:30:40 <arkeet> wait.
04:30:50 <arkeet> why don't you use withArrayLen?
04:30:56 <hasuser> hello
04:31:22 <hasuser> i'm new to haskell. i was wondering how haskell passes its arguments to functions, it's by reference?
04:31:37 <skp> I haven’t known that function till now
04:31:47 <skp> but hm
04:32:16 <skp> the length the binary function takes
04:32:23 <skp> it’s just a length called on the list
04:32:24 <skp> right?
04:32:36 <srhb> hasuser: Nope.
04:32:39 <arkeet> skp: although it's probably made to not have to walk the list twice.
04:32:57 <arkeet> hasuser: there isn't really a notion of "reference" in haskell.
04:33:02 <skp> oh sure
04:33:10 <skp> thank you
04:33:22 <srhb> hasuser: The language report doesn't define the evaluation strategy as such, but mostly it's call-by-name/by-need
04:33:23 <arkeet> hasuser: but even if there was, the answer wouldn't matter, since values never change.
04:34:47 <hasuser> thanks srhb
04:34:53 <skp> hm
04:34:56 <srhb> hasuser: If you were thinking about pass-by-value/reference, those are both strict evaluation strategies. Neither applu in a non-strict language such as Haskell.
04:35:19 <srhb> apply*
04:35:34 <skp> withArraLen $ \size buf -> putWithCLength (fromIntegral $ size * sizeOf) buf
04:35:41 <skp> it won’t work will it?
04:35:44 <hasuser> i'm beginnig to understand the functional paradigm... I'm an old imperative user
04:35:58 <skp> because of sizeOf needs to infer the type
04:35:58 <arkeet> skp: I don't know what putWithCLength is.
04:36:01 <srhb> hasuser: Nice. :) I bet you most people here started the same wya.
04:36:01 <typoclass> > take 8 [0..]
04:36:02 <lambdabot>   [0,1,2,3,4,5,6,7]
04:36:08 <arkeet> skp: well yes, which is why you pass it an argument.
04:36:09 <skp> an example C function
04:36:13 <arkeet> sizeOf (undefined :: whatever your type is)
04:36:27 <skp> arkeet: huh?
04:36:31 <skp> why not
04:36:39 <arkeet> why not what?
04:36:45 <skp> sizeOf :: CInt
04:36:49 <skp> directly
04:37:00 <arkeet> that makes no sense.
04:37:03 <srhb> :t sizeOf
04:37:04 <lambdabot>     Not in scope: `sizeOf'
04:37:04 <lambdabot>     Perhaps you meant one of these:
04:37:04 <lambdabot>       `IM.size' (imported from Data.IntMap),
04:37:19 <arkeet> skp: sizeOf has to return an Int.
04:37:19 <srhb> Well, that's why.
04:37:28 <arkeet> sizeOf :: Storable a => a -> Int
04:37:36 <typoclass> hasuser: above is an example ^^. the infinite list [0..] is not evaluated before it's passed to the 'take' function; obviously an infinite list would take forever to compute completely. in other words, haskell is lazy. things are generally evaluated only when they're needed (e.g. for printing into irc)
04:37:38 <skp> you’re right :D
04:37:46 <skp> and hm
04:37:55 <arkeet> it would be nicer if it was
04:38:01 <arkeet> sizeOf :: Storable a => p a -> Int
04:38:22 <skp> is undefined a special keyword?
04:38:24 <arkeet> no
04:38:26 <skp> I’d do
04:38:29 <skp> sizeOf def
04:38:39 <arkeet> that doesn't work
04:38:43 <skp> but it needs the type to be an instance of Default
04:38:45 <arkeet> unless you specify the type of def
04:38:56 <arkeet> and you also have that
04:39:02 <arkeet> so you have only gained problems.
04:39:12 <skp> you’re right
04:39:17 <skp> so what is undefined?
04:39:23 <monoidal> skp: from sizeOf def it's not clear which type you want
04:39:27 <skp> :i undefined
04:39:38 <hasuser> thanks typoclass
04:39:39 <skp> yeah I got it
04:39:39 <arkeet> :t undefined
04:39:40 <lambdabot> a
04:40:01 <monoidal> undefined = error "Prelude.undefined" iirc
04:40:29 <skp> ok, thank you for your help
04:40:49 <arkeet> @src undefined
04:40:49 <lambdabot> undefined =  error "Prelude.undefined"
04:43:56 <skp> hm that’s an issue for me here
04:44:01 <skp> I have a function
04:44:08 <skp> foo :: (Storable a) => [a] -> IO ()
04:44:10 <skp> for instance
04:44:22 <skp> inside that function
04:44:41 <skp> can’t I retrieve the size of the a type?
04:44:42 <skp> like
04:44:52 <skp> cs = sizeOf (undefined :: a)
04:45:28 <monoidal> skp: ScopedTypeVariables
04:45:56 <ClaudiusMaximus> skp: foo xs = print (sizeOf (head xs)) -- if you don't want to use the extension
04:45:58 <aCube> Is there a way to ignore some declarations in hpc?
04:46:21 <skp> I like extensions :)
04:46:24 <skp> thank you
04:46:34 <skp> ScopedTypeVariables huhu
04:46:41 <skp> what does it implie?
04:46:43 <skp> imply*
04:47:37 <arkeet> skp: it lets you reference type variables in an outer definition inside inner type annotations
04:47:54 <ClaudiusMaximus> means type variables have larger scope (across the whole function body) instead of being separate in each annotation
04:48:34 <arkeet> e.g. it lets you define
04:48:43 <skp> I don’t get what you mean with « annotation »
04:48:51 <arkeet> sizeOfP :: forall a. [a] -> Int; sizeOfP _ = sizeOf (undefined :: a)
04:49:09 <arkeet> I mean the ":: a" part.
04:49:12 <arkeet> maybe that's not called an annotation.
04:49:29 <Hermit> ClaudiusMaximus: foo = print . sizeOf . head   -- :3
04:49:40 <arkeet> actually I'd generalize that to sizeOfP :: forall p a. p a -> Int
04:49:59 <skp> so
04:50:01 <arkeet> uh, forgot Storable a =>
04:50:03 <skp> without the extension
04:50:25 <skp> we can’t use type variable in functions’ body?
04:50:39 <arkeet> you can't use the *same* type variable
04:50:50 <arkeet> if you tried, it would just create a new one that shadows the outer one.
04:51:12 <arkeet> and then it might complain that it can't match the types.
04:51:28 <skp> I see
04:51:34 <skp> thanks
04:51:37 <skp> by the way
04:51:48 <arkeet> it's good to read the ghc docs on this
04:51:57 <arkeet> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/other-type-extensions.html#scoped-type-variables
04:52:01 <ClaudiusMaximus> > let f :: Num a => a -> a ; f _ = (0 :: a) in f 0
04:52:02 <lambdabot>   Could not deduce (GHC.Num.Num a2) arising from the literal `0'
04:52:02 <lambdabot>  from the co...
04:52:10 <ClaudiusMaximus> > let f :: forall a . Num a => a -> a ; f _ = (0 :: a) in f 0
04:52:11 <lambdabot>   0
04:52:13 <klrr> what's good program for beginner to write, i tried to write sodukusolver but that's far too difficult?
04:52:30 <arkeet> ClaudiusMaximus: well, that's possible to write simply by dropping the type annotation.
04:52:40 <typoclass> klrr: have you seen the "99 problems"?
04:52:44 <typoclass> @google haskell 99 problems
04:52:45 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
04:52:46 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
04:52:46 <Hermit> klrr: how about project euler?
04:52:46 <klrr> typoclass: nope
04:52:50 <skp> huh
04:52:56 <monoidal> klrr: maybe number guessing game? computer generates random number, you guess and are told if it's too big or too small
04:53:00 <ClaudiusMaximus> arkeet: sure, but it shows the shadowing issue
04:53:03 <skp> ok I got it
04:53:05 <skp> the :: a
04:53:06 <arkeet> indeed.
04:53:08 <skp> in the function body
04:53:12 <skp> is another type variable
04:53:21 <klrr> Hermit: eh, i dont see how i can  learn haskell from euler, ive solved the task one but they seem more like writting math in haskell, not really programs that you can use
04:53:23 <skp> that’s why GHC calls it a2
04:53:24 <skp> ok
04:53:42 <arkeet> defining sizeOfP :: Storable a => p a -> Int in terms of sizeOf seems impossible without ScopedTypeVariables.
04:53:43 <skp> but the forall a. thing disturbs me
04:53:44 <Hermit> klrr: that's until you go beyond task 10 or so
04:53:50 <srhb> klrr: I agree. Mostly I think you should do the simplest task that interests you and work up from there.
04:53:55 <Hermit> klrr: you can't judge by just the first exercise
04:53:58 <typoclass> klrr: that's probably true, the euler stuff seems to be more about math
04:54:03 <srhb> Yeah.
04:54:36 <srhb> klrr: You could also browse www.reddit.com/r/dailyprogrammer for the "easy" challenges.
04:54:46 <skp> hey, it’s not related but – I’m french – and would you say « what do you mean with that » or « what do you mean by that »?
04:54:48 <klrr> Hermit: besides, i dont i think the iq for euler, it says the problems should be solved within 1-2 min after reading it, it took me 2 hours to solve nr 1
04:54:49 <srhb> klrr: Some of them are probably a bit too hard, some of them are probably just right.
04:54:59 <arkeet> skp: I would say "what do you mean by that?"
04:55:00 <klrr> srhb: will check
04:55:01 <monoidal> skp: by
04:55:16 <klrr> i will do 99 problems
04:55:17 <skp> by, ok
04:55:17 <arkeet> without the guillemets :p
04:55:18 <skp> chank you
04:55:59 <skp> thank*
04:56:00 <skp> gosh
04:56:58 <monoidal> klrr: or a sokoban clone (console interface)
04:57:06 <ClaudiusMaximus> arkeet: really? you can do a lot of workarounds in the spirit of 'asTypeOf'... eg:  unP :: p a -> a ; unP _ = undefined  ; sizeP :: Storable a => p a -> Int ; sizeP = sizeOf . unP
04:57:07 <srhb> Oh yeah, that's fun.
04:57:28 <arkeet> ClaudiusMaximus: ok, right.
04:57:41 <klrr> when someone write (x,xs) they mean a list?
04:57:46 <arkeet> klrr: no, it's a tuple
04:57:51 <monoidal> klrr: no, tuple. x:xs is a list
04:57:55 <klrr> okey
04:57:59 <klrr> can i write xs:x?
04:58:11 <monoidal> klrr: first argument to : is an element, second is a list
04:58:14 <arkeet> sure, but that would only make sense if x is a list.
04:58:17 <srhb> klrr: Sure but it means the same.
04:58:19 <monoidal> klrr: to append to the end, use xs ++ [x]
04:58:26 <arkeet> note: appending to the end is *slow*
04:58:27 <skp> I still have the error
04:58:35 <monoidal> > 3:[1,2] -- klrr
04:58:36 <lambdabot>   [3,1,2]
04:58:37 <srhb> arkeet: That's not really accurate..
04:58:41 <skp> hm
04:58:49 <arkeet> ok, well it's slow compared to appending to the front.
04:58:56 <typoclass> klrr: it's a tuple. the differences are roughly that in a list, all elements have the same type, and a tuple has a fixed length
04:59:01 <srhb> arkeet: Only in some circumstances.
04:59:14 <skp>     Could not deduce (Storable a0) arising from a use of `sizeOf'
04:59:14 <skp>     from the context (Storable a)
04:59:17 <srhb> arkeet: On most realistic scenarios it's the exact same speed.
04:59:19 <skp> and first line of the file :
04:59:25 <arkeet> er
04:59:32 <arkeet> I guess I meant appending repeatedly.
04:59:39 <skp> {-# LANGUAGE ScopedTypeVariables #-}
04:59:45 <monoidal> skp: hpaste?
04:59:49 <srhb> I think that's still borderline misinformation, but whatever. :P
04:59:50 <skp> ok wait
05:00:42 <ClaudiusMaximus> skp: you need to add explicit forall to the type variables you want bigger scope (otherwise the extension would break existing code much more readily)
05:00:42 <alexander__b> is there any difference to simply using "| foo True = bar" instead of "| foo otherwise = bar"?
05:00:54 <skp> monoidal: https://github.com/skypers/ark-gl/blob/master/Graphics/Rendering/Ark/GL/Buffer.hs#L161
05:00:56 <arkeet> alexander__b: no, otherwise is defined as True.
05:00:57 <srhb> If you consume the list in one go, what difference does it matter. And if you stop early for some reason, clearly the appends win (they're never actually done)
05:01:02 <monoidal> alexander__b: otherwise is defined as True, although stylistically you use it only as the last guard alone
05:01:05 <skp> forall?
05:01:07 <skp> why?
05:01:12 <skp> I don’t get it either
05:01:23 <arkeet> skp: it's needed for ScopedTypeVariables to work.
05:01:29 <typoclass> arkeet: in my opinion, he should write it the most obvious way. if the program then runs too slowly for the job (which is a big 'if'), then he can profile where the bottlenecks are. if (:) turns out to be a problem, he can still work on that (this is another big 'if')
05:01:50 <skp> ok it works
05:02:03 <skp> I need to find some readings about forall
05:02:06 <arkeet> typoclass: well I'm just pointing out that it's a potential issue.
05:02:12 <skp> exists may exist (:D) too?
05:02:29 <arkeet> skp: we don't have an exists keyword.
05:03:04 <typoclass> skp: nope, 'exists' doesn't exist :-)  somewhere there's an explanation of why. i think it was on a haskell wiki page
05:03:05 <skp> so what is it?
05:03:19 <skp> oh, ok
05:03:42 <monoidal> @skp: http://www.haskell.org/haskellwiki/Existential_type
05:03:43 <lambdabot> Unknown command, try @list
05:04:06 <klrr> what's wrong with this? http://hastebin.com/rijagitamo.hs
05:04:33 <srhb> > head []
05:04:34 <lambdabot>   *Exception: Prelude.head: empty list
05:04:53 <srhb> klrr: head is dangerous.
05:04:59 <klrr> srhb: why?
05:05:04 <srhb> Because it's not a total function.
05:05:04 <arkeet> because
05:05:05 <arkeet> > head []
05:05:07 <lambdabot>   *Exception: Prelude.head: empty list
05:05:21 <klrr> yeah, but why doesnt the code work? i get error with == and E
05:05:22 <monoidal> klrr: it should work on a nonempty list, you could have written just myLast xs = last xs
05:05:23 <arkeet> it blows up on an empty list.
05:05:30 <arkeet> consider myLast []
05:05:38 <monoidal> klrr: ah, you need type Eq a => [a] -> a
05:05:42 <klrr> monoidal: well im not even supposed to use last, im trying to implement it
05:05:53 <srhb> klrr: You should use pattern matching instead.
05:06:02 <monoidal> klrr: try to use pattern matching, like myLast (x:xs) = ...
05:06:02 <srhb> Oh.
05:06:07 <srhb> (He left)
05:06:42 <srhb> klrr: You should use pattern matching instead. There are several problems with your implementation
05:07:19 <srhb> But the most obvious one is that you will be recursing until you eventually do head []
05:07:22 <srhb> Which will fail horribly.
05:08:12 * hackagebot htiled 0.1.0 - Import from the Tiled map editor.  http://hackage.haskell.org/package/htiled-0.1.0 (ChristianRoedliAmble)
05:08:14 <alexander__b> can someone really quickly remind my mind what's what in this? "myCompare :: (Ord a) => a -> a -> Ordering"
05:08:58 <srhb> klrr: Sorry, that's obviously only true if you do pass it the empty list.
05:09:03 <srhb> klrr: Still, pattern matching is the way to go.
05:09:17 <wuttf> Any ide on how to test if a Text contains only whitespace?
05:09:31 <typoclass> klrr: to sum up, the problem with 'head' is that if you ever give it an empty list, it will crash the program and you'll have no useful error message. if you use "case thelist of (x:_) -> ...", it will crash but you'll have at least the filename and line number
05:09:34 <Hermit> alexander__b: it just takes 2 elements of the same type, and tells you if the first is GreaTer, EQual or LessThan the second
05:09:44 <alexander__b> Hermit: well yes, I'm asking what's what in that line
05:09:45 <arkeet> :t Data.Text.all isSpace
05:09:46 <lambdabot> Data.Text.Internal.Text -> Bool
05:09:58 <monoidal> Hermit: compare is a method of Ord typelcass
05:10:04 <monoidal> * alexander__b: ^
05:10:07 <alexander__b> I know that geez
05:10:13 <alexander__b> I'm asking what each word means in that line :-P
05:10:19 <alexander__b> first is the function name, then...
05:10:21 <Hermit> alexander__b: Ord a  means those a need to have an Ord instance
05:10:25 <wuttf> arkeet: cheking ty
05:10:45 <klrr> why doesnt this work http://hastebin.com/jidipucuda.hs ?
05:11:02 <monoidal> alexander__b: Ordering is a datatype data Ordering = LT | EQ | GT
05:11:25 <alexander__b> Hermit: then parameter -- parameter -- return-type, right?
05:11:36 <arkeet> klrr: you didn't say what myLast [] is.
05:11:40 <monoidal> alexander__b: use "null xs" to check if a list is empty
05:11:43 <klrr> arkeet: ok
05:11:43 <arkeet> (x:xs) doesn't match the empty list.
05:11:45 <alexander__b> monoidal: yes, I did :t LT to remind me of this.
05:11:48 <arkeet> oh, that too.
05:11:59 <alexander__b> monoidal: uhm yes but uh what?
05:12:09 <Hermit> alexander__b: roughly. It means, a function that takes an a and returns a function that takes an a and returns an Ordering
05:12:11 <typoclass> alexander__b: sure. the whole thing is a type signature, which is indicated by "::". myCompare is the name of the function that you're giving the signature for. the part in parens is a context or constraint, saying that myCompare does not work on any 'a', only on an 'a' for which we have an instance of typeclass Ord. (e.g. Int. there is an "instance Ord Int where ..." defined)
05:12:13 <alexander__b> monoidal: I don't see how that relates to what I'm doing, although I read that.
05:12:33 <alexander__b> typoclass: thank you!
05:12:45 <klrr> arkeet: still doesnt work
05:13:22 <arkeet> "doesn't work" doesn't contain much information.
05:13:24 <typoclass> alexander__b: "a -> a -> Ordering" is the main part of the signature, indicating two arguments and one return value. the two arguments can be of any type (as long as the constraint is satisfied). the two 'a's will refer to exactly the same type. Ordering is a predefined thing, as people pointed out
05:13:48 <klrr> http://hastebin.com/lomekowacu.hs <- arkeet
05:14:08 <monoidal> klrr: replace "xs == []" with "null xs"
05:14:11 <alexander__b> typoclass: so name :: constrain => param -> param2 -> param[n] ... -> return type
05:14:16 <klrr> monoidal: okey, why is that?
05:14:38 <arkeet> klrr: because "xs == []" needs an Eq constraint on the list's type.
05:14:50 <monoidal> klrr: or better, change to two cases: myLast (x:[]) = ...; myLast (x:xs) = ...
05:14:50 <arkeet> klrr: and you don't have one. and you don't need one.
05:14:59 <arkeet> yes, that's better.
05:15:04 <typoclass> alexander__b: yes, exactly. the part "constrain =>" is optional. also, if you leave out all the params, it works too. for example, "bufferSize :: Int" is valid
05:15:20 <klrr> arkeet: now it works :D
05:15:34 <alexander__b> typoclass: so if I have foo :: a -> a -- this will mean I take a param without constraint and return something that is of the same type as a?
05:16:02 <alexander__b> typoclass: and [a] -> a would mean that the parameter would be a list of "somethings", and I'd be returning a "something"?
05:16:19 <typoclass> alexander__b: yes exactly. for that function, there's only one useful implementation, which is the 'id' function (simply gives back exactly what you passed in)
05:16:22 <monoidal> alexander__b: yes. You can subsitute "a" for "Int", "Bool", etc
05:16:29 <Hermit> alexander__b: told you...  a -> b  means takes an a, returns a b.  In your line it's   Ord a => a -> (a -> Ordering)    meaning you can get a function that takes the remaining args when you just provide some of them
05:16:43 <alexander__b> typoclass: thanks a lot. I probably understood all this yesterday, but since this is so alien to me, I pretty much forgot by today.
05:17:36 <alexander__b> Hermit: sorry, but typoclass explained it in a way that was way easier for me to understand. I have only peeked at haskell.
05:17:38 <typoclass> alexander__b: yes, precisely. [a] means "list of a's", aka "list where all the elements have type 'a'". plausible implementations for [a] -> a would be head (gives back the first element of the list, if present) or last (gives back the last element)
05:18:20 <alexander__b> typoclass: thanks. again. :-)
05:18:22 <jbu> hi all: I have a method that does something like : "do x <- ... x" where that final x is the return of the function.  Execution gets to the point right before x is returned but the function never actually returns.  Any idea why this might happen?
05:18:42 <typoclass> alexander__b: don't worry, we all started out that way and found this very alien :-) the difference with other languages is that they often put the return type to the left of everything, e.g. int myCompare(int x, ...)
05:18:48 <typoclass> alexander__b: you're welcome
05:22:22 <monoidal> jbu: unlike "x = ... x ...", the arrow version "x <- ... x ...." is not recursive (right x is not the left x). hard to tell anything more without code
05:23:10 <jbu> maybe I can make a more specific question then
05:23:28 <typoclass> jbu: hello. that sounds weird. if you compile with the -Wall switch, do you get a warning about shadowing? also, could you paste more of the code in question? please use hpaste if it's more than one line
05:23:31 <typoclass> @where hpaste
05:23:31 <lambdabot> http://hpaste.org/
05:23:46 <jbu> typoclass: I probably shouldn't paste the code :( but -Wall doesn't show anything
05:24:08 <jbu> all: if I call "retry" in a sequence of STM (wrapped with "atomically") where does the retry start again from?
05:24:15 <arkeet> can you paste similar code that has the same behaviour?
05:24:29 <jbu> i dont even know how to reproduce the behavior
05:24:39 <typoclass> jbu: that's even more weird! have you tried "touch thefile.hs" before doing "ghc -Wall thefile.hs"?
05:24:47 <arkeet> or give it -fforce-recomp
05:25:08 <jbu> typoclass: what are you suspecting with that?
05:25:22 <monoidal> jbu: if your code is "do ...; x <- ... x ...; return x", can you replace it with "do ...; ... x ..."?
05:25:47 <monoidal> this shouldn't change meaning
05:25:47 <arkeet> @undo do { x <- f x; g x }
05:25:47 <lambdabot> f x >>= \ x -> g x
05:25:57 <arkeet> right.
05:26:28 <arkeet> @undo do { rec x <- f x; g x }
05:26:28 <lambdabot>  Parse error in pattern at "<-" (column 12)
05:26:30 <arkeet> aw.
05:26:41 <typoclass> jbu: i'm suspecting that ghc didn't recompile your file, and that's why you saw no warnings. it has this quirk where it doesn't recompile if the compiled file is newer than the source file, but it doesn't take into account the compiler flags
05:26:44 <monoidal> @undo do { rec { x <- f x }; g x }
05:26:44 <lambdabot>  Parse error at "<-" (column 14)
05:27:01 <jbu> monoidal: sorry maybe the whitespace meaning got lost.  the final "x" is on the same level as the do block, not inside it
05:27:21 <jbu> screw it lemme just paste you the code
05:28:15 <fryguybob> jbu: If there is an `orElse` it just rolls back up to the `orElse` and tries the alternative.
05:28:28 <fryguybob> jbu: If there isn't an orElse it is the whole transaction.
05:28:37 <jbu> http://pastebin.com/ghYQXaQm
05:28:40 <monoidal> jbu: also you might change "x <- ... x ..." to "y <- ... x ..." to avoid confusion
05:28:41 <mauke> The paste ghYQXaQm has been copied to http://hpaste.org/84557
05:29:07 <jbu> so if I were to put a error "hi" right before line 15, then it prints out "hi"
05:29:23 <jbu> but the caller of this method never resumes execution (i.e., this method never returns)
05:29:33 <jbu> yet it compiles fine
05:30:54 <jbu> I'm not quite sure how to make it print out the value without breaking compilation
05:31:02 <jbu> (still very much a haskell newb)
05:31:28 <arkeet> have you tried print?
05:31:38 <fryguybob> jbu: Print out the value from the other side of the atomically.
05:31:50 <arkeet> mhm
05:33:36 <fryguybob> jbu: What is the type of the `readChan` that you have there?
05:34:09 <jbu> fryguybob: readChan :: Chan a -> IO a
05:34:41 <jbu> chan is part of control.concurrent.chan
05:35:08 <monoidal> jbu: can you simplify it to "readFiniteChan (FC tv) = atomically $ do ..."?
05:35:13 <jbu> typoclass: oops yeah I wasnt seeing warnings bc I was in ghci
05:35:41 <arkeet> do { val <- ... ; val } probably is not doing what you want.
05:35:50 <fryguybob> jbu: So "not returning" from readFiniteChan implies that readChan is blocking or the transaction never gets what it needs to succeed.
05:36:17 <arkeet> a lot of the time that would be a type error, even.
05:36:29 <monoidal> jbu: I think that "let chanVal = readChan c" should be "chanVal <- readChan c"
05:36:40 <jbu> fryguybob: I would guess so too, but if I put a print/error statement right before line 15, then that gets printed out, meaning that the atomically block finishes
05:36:41 <fryguybob> monoidal: No
05:36:42 <jbu> ?
05:36:52 <monoidal> jbu: and due to this error you're *returning* STM action from the "atomically" block
05:36:56 <arkeet> aha
05:37:02 <arkeet> two type errors that cancel each other out
05:37:07 <fryguybob> monoidal: It is an IO action, not an STM action.
05:37:14 <monoidal> so retry has type STM (STM a) and "return chanVal" also
05:37:19 <arkeet> STM (IO a), rather.
05:37:25 <monoidal> and that's why the error occurs in "val", not in "val <- ..."
05:37:52 <arkeet> except readChan won't work inside STM.
05:38:00 <fryguybob> jbu: So if the trasaction finishes then readChan is blocking.
05:38:00 <monoidal> ah, right, so IO
05:38:32 <jbu> fryguybob: the transaction is really everything that "atomically" wraps, correct?
05:38:36 <fryguybob> jbu: There isn't enough code here to know why readChan would be blocking.
05:38:41 <fryguybob> jbu: Yes
05:38:47 <johnw> if he's using STM, should it be atomatically readTChan?
05:38:52 <monoidal> jbu: atomically requires STM block, but you attempt to use readChan there, which is IO
05:38:56 <johnw> atomically
05:39:08 <johnw> i can't tell you how many times I've written automatically in my code :)
05:39:09 <jbu> monoidal: that did interest me, yes...
05:39:16 <jbu> monoidal: do you think that is a problem?
05:39:20 <arkeet> looks like we should be using TChan instead of Chan.
05:39:21 <monoidal> jbu: yes
05:39:35 <johnw> arkeet: right
05:39:38 <jbu> monoidal: specificaly the line "let chanVal = readChan c" ?
05:39:43 <monoidal> jbu: yes
05:39:45 <typoclass> jbu: could you give us more information on the big picture? it certainly seems jumping in at the deep end if you're just starting with haskell and use stm, and atomically, and retry inside of it ...
05:39:47 <arkeet> jbu: here, chanVal is some IO a
05:39:58 <arkeet> jbu: this IO action isn't being executed, it's just sitting there.
05:40:33 <arkeet> instead, it's being assigned to val. and then once you write val on line 15, then it's being executed.
05:40:36 <arkeet> and presumably blocking.
05:40:49 <monoidal> jbu: it's like you were attempting "do let x < return (putStrLn "a"); x" then the error will be in second "x", first "x" will do nothing
05:40:55 <arkeet> you can't actually read your Chan inside the STM action.
05:41:31 <jbu> arkeet: what did you mean by the IO action isn't being executed? is that something to do with lazy execution?
05:41:35 <monoidal> um I mean the second x will print "a", first will do nothing
05:41:58 <fryguybob> jbu: It is getting executed, on line 15.
05:42:21 <arkeet> jbu: do { let blah = putStrLn "hello"; ... } will never print "hello".
05:42:30 <arkeet> (unless blah is executed later.)
05:42:35 <arkeet> (inside the ...)
05:42:43 <jbu> fryguybob: I was wondering the reason I was able to print the error just before line 15 was because of lazy execution and because line lines 1-14 only get executed when line 15 does
05:42:54 <arkeet> there is no such thing as lazy execution.
05:43:04 <fryguybob> jbu: Because you can't do IO inside a transaciton.
05:43:06 <jbu> sorry, lazy evaluation?
05:43:12 <arkeet> and it's not about evaluation.
05:43:24 <arkeet> you're are putting the action into the variable val.
05:43:28 <arkeet> not the result of running the action.
05:43:29 <jbu> fryguybob: yeah, I always felt funny doing that , but I didn't know how to get around it
05:43:45 <arkeet> and you can't run the action inside STM, because it's an IO action, not a STM action.
05:43:50 <fryguybob> jbu: You have to trust that the transaction will work :D
05:43:53 <jbu> arkeet: I see
05:43:56 <monoidal> jbu: the type system prevented you from executing it, since you're in STM
05:44:08 <fryguybob> jbu: You can debug and get a lot of hard to understand output.
05:44:20 <jbu> ok well le tme mull all this over
05:44:27 <jbu> thanks everyone
05:44:28 <arkeet> so my guess is you really want a TChan instead of a Chan, since you can do TChan operations inside STM.
05:44:38 <jbu> I'll take a look
05:45:07 <fryguybob> jbu: Like arkeet says, that is probably what you want.  But transactions that return IO actions are perfectly normal in the right situation.
05:45:26 <arkeet> sure. as long as that's what you intend to do.
05:46:36 <typoclass> jbu: i'd recommend that you double-check if you really need stm for your program, and if you're really using it correctly. you can do this via asking in here, or via a stack overflow question
05:47:26 <jbu> typoclass: I think I can get away with using MVars alone, actually, without STM
05:48:21 <arkeet> you probably could.
05:48:31 <jbu> wow...tchans seems to be exactly what I need
05:48:39 <arkeet> but STM is prettier.
05:48:40 <arkeet> :)
05:48:46 <jbu> I probably would have never known that tchan even exists
05:48:47 <typoclass> jbu: all i'm saying is, you mentioned that you're a beginner, and then can be hard to correctly answer questions like "are mvars/stm/... the right, most straightforward tool for this job"
05:48:51 <johnw> STM is really convenient
05:53:45 <johnw> jbu: if you look at the documentation for STM, you'll see that TChan is one of its submodules, along with TVar, TMVar, etc.
05:55:11 <jbu> johnw: thanks...i just thought that chan gave me exactly what i needed and since it was compiling that it must be fine
05:55:17 <jbu> so I stuck with that
05:55:29 <johnw> ah
05:56:17 <johnw> yeah, even though the static typing system is brilliant, getting something to compile isn't total confirmation that it will do what you expect :)  It just means that it's doable.
05:56:38 <johnw> foo x = foo x compiles just fine, for example
05:57:21 <typoclass> jbu: getting it to compile is obviously important, but the humans in #haskell are still good for something :-)
05:57:55 <jbu> typoclass: i am skeptical if they are human
05:58:10 <typoclass> jbu: you have good reason to be skeptical
05:58:12 * typoclass purrs
05:58:16 <jbu> as a beginner, I'm constantly struggling to see why any human would want to use haskell
05:58:25 <jbu> but...
05:58:33 <srhb> Ohh, but it's so nice.. ^^
05:58:33 <jbu> before i start a big argument
05:58:40 <jbu> I need to get this work done and go to sleep
05:58:44 <jbu> so maybe another time
05:58:49 <johnw> jbu: I've professionally used quite a number of languages, and I can tell you without reservation that Haskell has been my best experience to date
05:58:53 <Jello_Raptor> jbu: heh, never used functional language before?
05:59:05 <jbu> Jello_Raptor: ocaml too
05:59:14 <jbu> but never really felt that either was natural to me
05:59:23 <jbu> most likely because I never spent too much time with them
05:59:31 <srhb> You have to change your mind from imperative to functional, for sure. It takes a while. :)
05:59:32 <jbu> I'm sure if I spent more time with them I'd see more benefits
05:59:48 <jbu> srhb: yeah, I doubt I've given it a fair shot
05:59:53 <srhb> *nod*
06:00:12 <jbu> johnw: are you finding a lot of places to work that use haskell?
06:00:23 <Jello_Raptor> johnw: eh, even i'd disagree there, haskell is a one of local attractors in the programming space. It's brilliant for a lot of things, but i've still settled into using it, GoLang, and Ruby as the circumstances change.
06:00:46 <Jello_Raptor> jbu: how much of a maths person are you?
06:00:50 <typoclass> jbu: my own experience is that haskell has a steep learning curve, and the teaching material and presentation is maybe not so great, but overall, it becomes extremely rewarding
06:00:52 <johnw> jbu: i interviewed for two different Haskell jobs last year, but since I took one of them, I haven't tried again.  So I'm not really that aware of what the market is like now
06:00:54 <jbu> johnw: of all the jobs Ive ever interviewed for, I've only heard of one company using a functional language, and iirc, it wasn't even a true functional language
06:00:59 <jbu> Jello_Raptor: not that much
06:01:33 <Jello_Raptor> jbu: ahh, i find that people who like maths tend to take to haskell like fish to water, and with everyone it's pretty split.
06:01:34 <johnw> Jello_Raptor: I used to use Python and Ruby for sysadmin/scripting type of stuff, but now I use Haskell for that too
06:01:47 <jbu> Jello_Raptor: yeah that seems to be true of the people I know too
06:02:08 <typoclass> jbu: in my opinion, learning haskell will make you a better programmer -- whether you end up using haskell or another language
06:02:24 <typoclass> johnw: oooh interesting :-) do you use shelly? some homegrown thing? is it on hackage?
06:02:33 <johnw> yes, I use shelly :)
06:02:34 <Jello_Raptor> jbu: it doesn't make the people who dislike haskell any less wrong however.
06:03:06 <johnw> shelly, optparse-applicative, and parallel-io, are the three libraries I never leave home without for doing scripting
06:03:13 <jbu> woohoo, I got passed my blocked method
06:03:23 <johnw> in fact, I now have a prototypical template that I just copy each time I want to write a script
06:03:35 <typoclass> johnw: interesting, thanks
06:03:45 <johnw> I could put my template on Hackage
06:03:58 <fryguybob> johnw: JohnW.Prelude ...
06:04:06 <johnw> typoclass: https://github.com/jwiegley/script-template
06:04:17 <johnw> fryguybob: actually, it's called general-prelude :)
06:05:25 <typoclass> johnw: heh, oh wow. well i have all the imports in a file Moar for reexport, so that in the actual script it's enough to do "import Moar"
06:05:42 <typoclass> s/file/module
06:05:46 <Jello_Raptor> typoclass: haha, i think i'll steal that pattern
06:05:52 <johnw> heh
06:06:11 * Jello_Raptor would be tempted to call it "AllTheThings" however
06:07:09 <xpika> is it possible to define 2 STrefs on the one line. something like (ref1,ref2) <- (newSTRef 0,newSTRef 0)?
06:07:22 <johnw> yes
06:07:25 <johnw> liftM2 (,)
06:07:40 <johnw> (ref1,ref2) <- liftM2 (,) (newSTRef 0) (newSTRef 0)
06:08:50 <johnw> i think you can even get cute with: (ref1,ref2) <- join (liftM2 (,)) newSTRef newSTRef 0
06:09:02 <johnw> but now yo'ure sacrificing readibility pretty heavily
06:09:11 <monoidal> johnw: join (liftM2 (,)) (newSTRef 0)?
06:09:24 <merijn> johnw: Couldn't you do something fancy with the Kleisli arrow too?
06:09:35 <johnw> monoidal: i'm using the -> instance for Monad with that join, so it needs two function arguments
06:10:14 <xpika> what about 3?
06:10:16 <monoidal> johnw: join f x = f x x, and we have f = liftM2 (,), x = newSTRef 0
06:10:19 <johnw> monoidal: oh, I see what you mean
06:10:22 <johnw> right!
06:10:54 <xpika> liftM3 ?
06:11:03 <johnw> yes
06:11:03 <monoidal> xpika: yes
06:11:17 <merijn> I think it goes up to M5 or M6?
06:11:30 <merijn> :t liftM5
06:11:31 <lambdabot> Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
06:11:41 <merijn> :t liftM6
06:11:41 <hpaste> adas pasted “infinite lloop” at http://hpaste.org/84558
06:11:42 <lambdabot>     Not in scope: `liftM6'
06:11:42 <lambdabot>     Perhaps you meant one of these:
06:11:42 <lambdabot>       `liftM' (imported from Control.Monad.Writer),
06:11:45 <adas> when i try "take 10 $ result [0,1]" the code ^^^ never gives output ...
06:11:48 <monoidal> for larger n, xs <- replicateM n (newSTRef 0)
06:12:02 <johnw> [ref1, ref2] <- replicateM 2 (newSTRef 0)
06:12:14 <johnw> adas: what is "result"?
06:12:17 <adas> im trying to write a function that calculates fibanocci using state ..
06:12:24 <adas> result :: [Int]
06:12:35 <adas> oops sorry
06:12:37 <johnw> it's not in your pastie
06:12:39 <monoidal> ads: your fib function does not return
06:12:43 <monoidal> adas: ^
06:12:49 <adas> result :: [Int] -> [Int]
06:13:02 <merijn> adas: Well, yes. That state action never stops
06:13:24 <merijn> And since you want the final result laziness doesn't help you here
06:13:45 <merijn> execState can't return the final state until after the State action is finished
06:14:08 <johnw> adas: also, knowing the type of "result" does not tell me what result is
06:14:08 <adas> how may i change the code so i can simply do (take 10 $ result [0,1])
06:14:23 <johnw> you're asking me to guess about code only you can see
06:14:27 <typoclass> adas: i think the clearest thing is still "x <- something". i've never liked stuff like "(x,y,z,a,b,c) <- (somethingX, somethingY, ...)". it's just too easy to mess up in practice
06:14:49 <merijn> johnw: He hpasted it just now
06:14:56 <merijn> 14:11 < hpaste> adas pasted “infinite lloop” at http://hpaste.org/84558
06:15:01 <adas> johnw: result takes [0,1] and returns a never ending stream of the fibanocci series or atleast that is the intention
06:15:02 <monoidal> typoclass: you meant xpika not adas?
06:15:04 <johnw> his hpaste doesn't have "result" in it
06:15:11 <johnw> oh, duh
06:15:15 <johnw> why couldn't I see it?
06:15:31 <typoclass> monoidal: you're right, sorry
06:15:33 <typoclass> xpika: ^^
06:16:28 <adas> i thought importing the strict version of state might help but that did not either
06:16:45 <johnw> adas: it's infinitely recursive
06:16:52 <monoidal> adas: imagine that in your state block, you put "when (n = 50000) $ put [2,4,5]"
06:17:27 <monoidal> then it's not clear that the fib function will in the end start with [2,4,5,9,14..] not with [0,1,1,2,3,5..]
06:17:56 <monoidal> in other words, the state monad allows arbitrary transformations of the output, not only limited to appending to the end
06:18:27 <monoidal> so even with lazy evaluation the head of the result is not well-defined
06:18:47 <adas> so how may i restructure the code ?
06:19:09 <monoidal> adas: option A. return only a finite prefix
06:19:10 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
06:19:11 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:19:20 <merijn> option B, don't use State for this
06:19:26 <monoidal> adas: option B. as merijn said
06:19:56 <adas> the goal is not to calculate fibanocci series. the goal is to learn the State monad
06:20:15 <merijn> adas: Ah, then I'd probably ditch fibonacci and pick another example
06:20:26 <merijn> Maybe try building a calculator?
06:20:39 <adas> merijn: so the state monad cannot be used recursively?
06:20:47 <merijn> adas: It can, but it has to terminate
06:20:57 <johnw> adas: it cannot produce an infinite series
06:21:12 <johnw> without requiring infinite time, at least
06:21:14 <monoidal> adas: adding the termination condition to your code is not that hard, you might salvage getting only the n-th element
06:21:17 <merijn> adas: Actually, even that isn't true. It can be infinite/non-terminating too, but then you can't use the result
06:21:54 <merijn> adas: The problem is that "execState" returns the state *after* the entire action has completed. If your action is infinitely recursive, it will *never* complete
06:22:14 <monoidal> adas: instead of recursively calling "fib" in the end, check if it's the last iteration. you might add an additional parameter or store it in state, as an exercise
06:22:17 <adas> hmm.. i think ill make fib accept a parameter that determines how many terms to produce
06:22:24 <merijn> adas: That'd work, yes
06:22:53 <merijn> Then you can have "if n == 0 then return () else fibs" at the end
06:23:14 <merijn> (or, nicer "when (n /= 0) fibs")
06:23:25 <Iceland_jack> or: "unless (n == 0) fibs
06:23:26 <Iceland_jack> "
06:28:00 <twomashi> can anyone suggest a nicer way to write:
06:28:00 <twomashi> justParam "id" >>= (return . pack . read) >>= lookupId
06:28:25 <statusfailed> twomashi: what's justParam? snap framework?
06:28:34 <typoclass> twomashi: you could try "(pack . read) <$> ..."
06:28:39 <twomashi> Yea. its totally unsafe but im just playing around
06:29:24 <twomashi> (pack . read) <$> justParam "ID" >>= lookupId
06:31:19 <latermuse> oh thats cool. (pack . read) <$> ...
06:31:46 <twomashi> lookupId =<< (pack . read) <$> justParam "ID"
06:36:02 <hpaste> Lii pasted “Same body multiple patterns” at http://hpaste.org/84559
06:36:34 <hpaste> Lii revised “Same body multiple patterns”: “Same body multiple patterns” at http://hpaste.org/84559
06:36:55 <Liii> Hello all,
06:37:16 * typoclass meows at Liii
06:37:45 <hpaste> liyang annotated “Same body multiple patterns” with “Same body multiple patterns (annotation)” at http://hpaste.org/84559#a84561
06:38:32 <hpaste> typoclass annotated “Same body multiple patterns” with “Same body multiple patterns (annotation) (annotation)” at http://hpaste.org/84559#a84562
06:39:14 <Liii> I want to write a case-expression which performs the same computation for multiple different patterns, as illustrated by the snippet here: http://hpaste.org/84559
06:39:16 <liyang> Liii: it's annoying, but consider what happens if instead of matching on 0-ary constructors (e.g. True), you end up binding different names in each of the three cases.
06:39:42 <Liii> Ops, I already have got some suggestions! Thats, Ill look at them.
06:41:01 <typoclass> Liii: i think you've written this very clearly already. the only improvement is giving a name to the "same" action
06:41:06 <Liii> liyang: If every pattern bind the same varibales with the same types I guess this would work.
06:41:51 <typoclass> Liii: you're of course free to give an argument (or a few) to 'same'
06:42:29 <Liii> typoclass: Allright,  thanks.
06:42:35 <liyang> Liii: sure... but Haskell can't do that. :<
06:42:48 <Liii> This can be written with pattern guards in some way?
06:44:22 <hpaste> adas revised “infinite lloop”: “no more State recursion” at http://hpaste.org/84558
06:44:24 <adas> i made some changes and it sseems to work. Can someone please give me hints as to how i may improve the code ? ^^^
06:45:08 <hpaste> liyang annotated “Same body multiple patterns” with “Same body multiple patterns (annotation) (annotation) (annotation)” at http://hpaste.org/84559#a84564
06:46:05 <typoclass> Liii: yes i guess you could use pattern guards, but i don't think it would improve anything compared to case-of
06:46:24 <typoclass> liyang: blerg? :-)
06:46:30 <Liii> typoclass: Ok, thanks.
06:46:43 <liyang> yes bleurgh.
06:47:52 <Liii> liyang: Yeah, a boolean expression works also, but I tought it looked better with patterns. And a match on () is very weird!
06:48:39 <liyang> Actually that's just an if-then-else since there are only 2 alternatives. It read better with the original case-of.
06:48:43 <mee> #haskell-blah
07:02:06 <merijn> adnap: "modify id" is identical to "return ()"
07:02:09 <merijn> eh
07:02:13 <merijn> s/adnap/adas
07:13:17 * hackagebot http-streams 0.4.0.0 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.4.0.0 (AndrewCowie)
07:56:23 <aCube> Can I have multiple versions of GHC installed? (If I want to test my program with other versions?)
07:56:56 <monochrom> yes
07:56:59 <monoidal> aCube: yes
07:57:14 <parcs> yes!
07:57:26 <parcs> i have 3 in fact
07:57:47 <monochrom> do an "ls /usr/local/bin" to discover what GHC does to your hard disk
07:58:13 <aCube> If I install haskell-platform with GHC 7.6, do I get GHC 7.4 or do I have to compile it extra?
07:59:06 <monochrom> what is "haskell-platform with GHC 7.6"? it does not sound like it exists.
07:59:12 <merijn> aCube: You can install binary, but no, 7.4 doesn't ship with 7.6 (is there even a haskell-platform with 7.6?!)
08:00:26 <aCube> So if I got GHC 7.6, what's the best way to install 7.4? Download it from http://www.haskell.org/ghc/download_ghc_7_4_2?
08:00:46 <monoidal> aCube: I recommend you to cabal-install packages from platform
08:00:57 <monoidal> i.e. not the platform itself
08:02:17 <monochrom> I recommend the haskell platform and my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml#correction to lock down package versions
08:06:37 <merijn> monoidal: Why?
08:06:55 <dEPY> I wanna make something like this work: take 1 (filter (mod 3829 == 0) [100000, 99999..])
08:06:58 <merijn> I recommend installing platform and just doing a binary install of 7.6 next to it, works just fine
08:07:16 <merijn> dEPY: Use a lambda or .
08:07:17 <dEPY> but can't figure out how to make a curried mod that return true or false is result is 0
08:07:31 <merijn> \x -> mod 3829 x == 0
08:07:38 <dEPY> merijn: Ok I guess I'm not that far in the book :D
08:07:40 <centrinia> :t (==0) . (`mod` 3829)
08:07:41 <latro`a> you can technically make that point free but shouldn't
08:07:41 <lambdabot> Integral a => a -> Bool
08:07:46 <merijn> or "(0==) . mod 3829"
08:07:51 <monoidal> merijn: personal preference, I rarely had problem with this setup
08:07:51 <latro`a> ...disregard what I just said I guess
08:07:51 <Iceland_jack> dEPY: You shouldn't make that point free
08:07:59 <latro`a> with backticks it's not too bad
08:08:16 <merijn> dEPY: I would just use the lambda syntax as a newcomer
08:08:33 <dEPY> tnx :)
08:13:43 <monoidal> merijn: probably should be (0==) . flip mod 3829
08:19:55 <jmcarthur> :t let (===) = liftA2 (==) in 0 === (`mod` 3829)   -- probably won't be such a nice type signature without numinstances :\
08:19:57 <lambdabot> (Integral b, Num (b -> b)) => b -> Bool
08:20:24 <jmcarthur> oh the integral constraint...
08:20:53 <jmcarthur> ah it's okay, nevermind
08:34:30 <vermeille> Hello guys
08:34:32 <johnw> merijn: for that expression, I'd probably use the lambda anyway, it's a 3 char diff (once you surround the point-free version with parens)
08:34:37 <johnw> vermeille: hello!
08:34:38 <vermeille> I'm losing time for a stupid thing
08:34:57 <vermeille> I'm dealing with some Word16 (or Int16, depending on what you'll say)
08:35:04 <vermeille> I have a list of it
08:35:30 <vermeille> and I just want to print that *in binary form* (not string-serialized) on the standard output
08:35:51 <vermeille> So, ideally, I need something like [Word16] -> IO ()
08:36:17 <johnw> do you mean you want to see 0s and 1s?
08:36:22 <johnw> or that you want it "raw"?
08:36:28 <vermeille> I want it raw
08:36:29 <merijn> I'm assuming raw?
08:36:38 <johnw> first [Word16] -> ByteString
08:36:43 <johnw> then ByteString -> IO ()
08:36:57 <merijn> The easiest is probably to turn [Word16] into [Word8] and then convert that ByteString? Unless there's a direct [Word16] -> ByteString
08:37:13 <vermeille> yeah, I was trying to using Data.Binary.encode
08:37:14 <johnw> or use a bytestring builder
08:37:17 <johnw> it takes Word16's
08:38:16 <vermeille> Well
08:39:01 <vermeille> map (putStr . encode) $ map (ByteString) myWord16List
08:39:03 <vermeille> ?
08:39:42 <johnw> it's easier to try it in ghci than try to use us as ghci :)
08:40:02 <vermeille> In fact, I tried it, and it does not work :(
08:40:15 <johnw> you'd need mapM for the first one, but the second map is all wrong
08:41:28 <vermeille> Yeah, I'm quite new to Haskell
08:42:48 <johnw> i think you'd need mconcat (map word16BE myWord16List)
08:42:52 <johnw> that's if the data is big-endian
08:42:57 <johnw> otherwise you need word16LE
08:43:08 <johnw> and then the whole would be:
08:43:55 <johnw> Data.ByteString.putStr . mconcat . map word16BE $ myWord16List
08:44:41 <vermeille> Let's try it :D
08:46:48 <dEPY> what are  !! ?
08:47:01 <johnw> !! is an operator
08:47:04 <srhb> :t (!!)
08:47:05 <lambdabot> [a] -> Int -> a
08:47:11 <dEPY> I know. What does it do? :D
08:47:16 <johnw> see if you can tell from the type
08:47:27 <dEPY> It return nth element from a list?
08:47:32 <johnw> exactly!
08:47:37 <dEPY> tnx :)
08:47:40 <johnw> inferring behavior from types is a good skill to practice
08:48:06 <dEPY> :)
08:49:11 <vermeille> Well guy, forgive my stupidity, what means "Could not find module `Data.ByteString.Lazy.Builder.BasicEncoding.Binary' ; it is a hidden module in the package `bytestring-0.10.0.2'"
08:49:24 <johnw> are you using cabal
08:49:25 <johnw> ?
08:49:28 <vermeille> Nope
08:49:35 <johnw> you seem to be using GHC 7.6
08:49:54 <johnw> you are doing this in ghci?
08:49:58 <vermeille> You're right.
08:50:03 <vermeille> Nope, compiling with GHC
08:50:25 <johnw> ah, hmm... i don't do that often
08:50:39 <johnw> try putting -package bytestring
08:50:42 <johnw> on your command line
08:51:11 <vermeille> not better =/
08:51:26 <johnw> well, now I would be just guessing, maybe someone else knows
08:51:26 <vermeille> In can't believe that's it's so painful to deal with binary datas o_o
08:51:51 <johnw> it really isn't painful at all, but I always use cabal
08:53:01 <srhb> vermeille: It isn't painful at all. But it's a bit hard to tell you why your ghc can't find bytestring if you don't give a bit more info. :)
08:53:01 <Igloo> vermeille: That's an internal module; you can't use it
08:53:27 <johnw> he should only need: import Data.Bytestring; import Data.ByteString.Builder
08:53:28 * hackagebot sparse-lin-alg 0.4.2 - Effective linear algebra on sparse matrices  http://hackage.haskell.org/package/sparse-lin-alg-0.4.2 (AlexeyAlekhin)
08:53:30 * hackagebot sparse-lin-alg 0.4.3 - Effective linear algebra on sparse matrices  http://hackage.haskell.org/package/sparse-lin-alg-0.4.3 (AlexeyAlekhin)
08:54:13 <vermeille> Could not find module `Data.ByteString.Builder' :(
08:54:33 <vermeille> I'm googling, I swear I try to do my best
08:54:37 <johnw> ??
08:54:39 <johnw> http://hackage.haskell.org/package/bytestring/
08:54:43 <merijn> Is ByteString installed with ghc?
08:54:58 <johnw> something is amiss
08:55:07 <merijn> I guess not? And if he's using 7.6 he doesn't have platform so maybe ByteString is just missing?
08:55:09 <johnw> yes, i believe it's a core library
08:55:18 <merijn> Ah, maybe, I dunno
08:55:20 <johnw> let me check
08:55:22 <vermeille> I can import Data.ByteString, but I can't import Data.ByteString.Builder
08:55:37 <johnw> yes
08:56:07 <johnw> vermeille: that's very odd, because you said you're using ghc 7.6.2
08:56:12 <johnw> ghc 7.4.2 doesn't have Builder
08:56:19 <HugoDaniel> hi
08:56:34 <johnw> oh, it *very* new
08:56:39 <johnw> vermeille: try this instead:
08:56:40 <vermeille> Yup, 7.6.2 :(
08:56:43 <johnw> import Data.ByteString.Lazy
08:56:45 <johnw> import Data.ByteString.Lazy.Builder
08:56:51 <johnw> that should be in the version that you have
08:57:31 <vermeille> It's okay !
08:57:39 <vermeille> Sooooooooooooo \o/
08:57:52 <vermeille> Maybe we will finally have the right expression :D
08:58:38 <johnw> you'll need to use a lazy putStr
08:58:42 <johnw> Data.ByteString.Lazy.putStr
09:02:38 <vermeille> cannot match [Word16] with ByteString
09:02:38 <vermeille> We're reaching the goal !
09:02:38 <vermeille> YEAH
09:02:39 <vermeille> GO IT
09:02:39 <vermeille> It compiles !
09:02:49 <johnw> does it run? :)
09:02:53 <vermeille> but it does not output anything
09:03:06 <vermeille> BL.putStr $ encode $ sinW 0 (440.0)
09:03:40 <vermeille> Yeah, I missed to crash my computer :d
09:04:33 <vermeille> Nothing happens when I pipe it to hexdump :(
09:05:40 <johnw> not knowing what sinW outputs, I don't know what to say
09:06:11 <vermeille> It works :)
09:06:12 <vermeille> In fact, sinW outputs an infinite list
09:06:13 <vermeille> and putStr waits the end to flush
09:06:24 <johnw> so slap in a BL.take
09:06:37 <vermeille> I did it, and it works :)
09:06:41 <johnw> yay
09:06:42 <vermeille> thank you a LOT
09:06:53 <IngoPan> Hi, i am Linux newbie and i´d like to know if someone knows this Amazon book
09:06:53 <IngoPan> and can tell me if its any good to enter the Linux world: http://t.co/p9tS8QnDgc ?
09:07:11 <jmcarthur> this is the wrong channel for these kinds of questions
09:07:29 <jmcarthur> also could you paste the amazon link instead of some shortened thing?
09:07:32 <jmcarthur> :P
09:07:41 <IngoPan> sorry ;)
09:07:44 <johnw> yeah, that smelled way too much like spam
09:08:20 <IngoPan> just a suqstion
09:08:29 <geekosaur> this user is up to something
09:08:41 <jmcarthur> but i stand by my claim that this is the wrong channel and you should try elsewhere
09:08:48 --- mode: ChanServ set +o johnw
09:08:54 <geekosaur> hit #haskell once yesterday and #perl twice with a multiply obscured url, the final target was legit but the middle indirections were dubious
09:09:49 <geekosaur> (note, not confirmed but not at all trustworthy especially with te repeats)
09:10:23 <johnw> geekosaur: yeah, the guise of legitimacy is the worst
09:12:16 <klrr> hey
09:12:16 <dEPY> is there any way to get see how some internal functions looks in ghci ?
09:12:34 <dEPY> for example if I want to see how + is defined?
09:12:34 <parcs> nope
09:12:39 <geekosaur> usually they're compiled, so no
09:12:39 <johnw> @src (+)
09:12:40 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:12:54 <johnw> dEPY: you can generate the GHC Core, and then assembly
09:13:03 <johnw> but I don't think "+" is written in Haskell
09:13:11 <dEPY> oh
09:13:15 <dEPY> makes sense
09:13:30 <johnw> i usually boils down to "add" on whichever processor you're using
09:13:39 <johnw> which itself is just a number... ;)
09:13:39 <geekosaur> you can install hoogle and configure it into ghci, then use that to find source... but (+), while actually written in haskell last I checked, redirects to primops based on type
09:14:13 <johnw> ah, true, polymorphic + turns into primops type-specific +
09:19:13 <roadfish> @pl a b = if b == 3 then 33 else c (d e)
09:19:13 <lambdabot> a = flip (flip if' 33 . (3 ==)) (c (d e))
09:20:20 <johnw> a b = if' (b == 3) 33 (c (d e))
09:20:25 <johnw> not really helping
09:20:38 <dEPY> Hm. Learning haskell gives me a feeling like I've been given a space ship that can travel trough space and time but I can barely drive a moped. O_ô
09:20:54 <johnw> we do have a Tardis monad
09:21:00 <roadfish> @hoogle if'
09:21:00 <dEPY> LOL :D
09:21:00 <lambdabot> No results found
09:21:16 <dEPY> When do you get used to the "Tardis" ?:D
09:21:18 <johnw> http://hackage.haskell.org/package/tardis
09:21:26 <johnw> roadfish: it's functional if
09:21:33 <johnw> if' x y z = if x then y else z
09:21:36 <geekosaur> roadfish, it doesn't actually eist, you should take it as a hitnt hat if doesn't really have a pointfree form
09:21:49 <geekosaur> you can define it that way ^^ but it doesn't come predefined
09:22:52 <roadfish> the main hint is that I should skip point-free on this one
09:23:06 <johnw> just being point-free itself is rarely a worthy goal
09:23:25 <johnw> when it adds clarity, it's great
09:23:30 <johnw> but clarity should be the objective
09:23:47 <geekosaur> we like to refer to that as "pointless" for a reason :)
09:23:52 <roadfish> I wanted to shove getChar >>= ... without doing the getChar >>= \ch -> ...
09:24:49 <roadfish> well, first I have to try @pl before I can separate the good points from the pointless
09:25:17 <johnw> roadfish: huh?  do you want >=>?
09:25:20 <geekosaur> a good rule of thumb is if it contains more than one flip, it's not worth it
09:25:34 <johnw> or if it contains . with a paren immediately next to it
09:25:42 <johnw> flip (a .) . (. b)
09:25:44 <geekosaur> or more than one ap
09:25:46 <johnw> that's classic @pl noise
09:26:05 <roadfish> more than one flip only gets points in the Olympics
09:26:16 <johnw> although today I did write this:
09:26:17 <johnw> awsRetry = ((((retrying def (isFailure . responseResult) .) .) .) .) aws
09:26:22 <geekosaur> well, it gets points for obfuscation :)
09:26:47 <johnw> (each . corresponds to an argument passed to aws)
09:26:49 <aCube> is curry $ a . b . uncurry c worth it?
09:27:03 <roadfish> @hoogle aws
09:27:03 <lambdabot> package aws
09:27:03 <lambdabot> Graphics.Rendering.OpenGL.GLU.Quadrics data QuadricDrawStyle
09:27:03 <lambdabot> System.Process rawSystem :: String -> [String] -> IO ExitCode
09:27:06 <johnw> aCube: i wouldn't say so
09:27:15 <johnw> aws is Amazon Web Services
09:28:23 <johnw> aCube: i mean, it can be worth it
09:29:44 <geekosaur> the question might be, why are you using tuples to start with. (sometimes it's reasonable, as when you're working with arrows --- but then you probably want to use the appropriate arrow abstraction instead of curry/uncurry)
09:32:03 <roadfish> in what sense is aCube's example a triple?
09:32:05 <roadfish> the signature of "x a b c = curry $ a . b . uncurry c" is "x :: (b1 -> c) -> (b2 -> b1) -> (a -> b -> b2) -> a -> b -> c"
09:32:37 <roadfish> no, I retract
09:32:52 <roadfish> why did I think someone said triple?
09:33:24 <dEPY> I was trying to rewrite map with left fold and it doens't really work:D   let map2 f xs = foldl (\x acc -> acc ++ [(f x)]) xs []
09:33:31 <dEPY> Any idea?
09:33:47 <johnw> you have acc and x reversed
09:33:51 <johnw> and xs and []
09:34:19 <dEPY> oh yes, silly me :)
09:34:22 <dEPY> thank you
09:37:01 <johnw> i would use foldr, though
09:37:15 <johnw> foldl is really the worst choice possible for map
09:42:12 <Squid_Tamer> I have  2D list (A List of Lists of Eq). What would be the cleanest way to get the (x,y) coordinates of a specific value?
09:42:42 <Squid_Tamer> Like, find the first 7 in a grid of Ints and return the location?
09:43:30 <johnw> nested filter
09:43:42 <johnw> combined with take 1
09:44:11 <johnw> or, rather, nested find
09:44:15 <johnw> sorry, i just don't use find often
09:45:35 <Squid_Tamer> Yeah, I think I just need to recurse over the outer list and use findIndex on all of the inner ones.
09:46:23 <johnw> well, stopping after you have your answer
09:48:10 <Squid_Tamer> johnw: Yes, definitely will want to do that too. Thanks! I was just wondering if there was some magically simple solution that I was missing.
09:48:20 <supki> > [[1,2,3],[4,5,6]] ^@.. ifolded Lens.<.> ifolded . filtered (== 3)
09:48:23 <lambdabot>   [((0,2),3)]
09:49:08 <FireFly> :t (^@..)
09:49:10 <lambdabot> s -> IndexedGetting i (Endo [(i, a)]) s t a b -> [(i, a)]
09:49:19 <hiptobecubic> FireFly, hah. nice try
09:49:33 <edwardk> > [[1,2,3],[4,5,6]]^@..each Lens.<.> each.filtered (== 3)
09:49:35 <lambdabot>   [((0,2),3)]
09:49:43 <aCube> What is the best way to get GHC 7.4 on Archlinux ?
09:50:28 <edwardk> FireFly: in lens (^.) is used to evaluate a lens, or getter to get a single result. (^..) is used to get a list of all targets of a lens, getter, fold, traversal, etc. (@) modifies it to make it also return the 'index' of the targets.
09:50:51 <edwardk> ^@. returns the index and result of an indexed lens or getter,   ^@.. returns the indices and results of an indexed traversal, etc.
09:51:39 <edwardk> ^ is 'read', @ as a 'morpheme' is used to indicate index. . single result, and .. multiple
09:51:46 <aCube> What is <.>?
09:51:51 <FireFly> edwardk: and how do you pronounce ^@.. ? :D
09:52:00 <edwardk> FireFly: 'itoListOf'
09:52:31 <aCube> > [1,2,3] ^@. contains 1
09:52:32 <lambdabot>   (1,True)
09:52:34 <edwardk> aCube: if you compose two indexed traversals, etc. with (.) you only get the 'deepest' index. if you use <.> though, i can tuple them up and give them to you
09:52:48 <edwardk> > [[1,2,3],[4,5,6]]^@..each Lens.<.> each.filtered (== 3)
09:52:50 <lambdabot>   [((0,2),3)]
09:52:54 <edwardk> > [[1,2,3],[4,5,6]]^@..each . each.filtered (== 3)
09:52:56 <lambdabot>   [(2,3)]
09:53:03 <edwardk> notice how it lost the outer index.
09:53:06 <bad_alloc> Hi I'm trying to implement mergesort as an exercise. When I try to trace what is going on in my merge function this happens: http://cxg.de/_393a55.htm Why do the messages collide? does this have something to do with lazy evaluation (i.e. the unevaluated function call is spliced into the list)?
09:53:07 <aCube> ah :)
09:53:29 <edwardk> <.> <. and .> are used in lens to indicate which one to keep. (.>) is redundant because it matches the behavior of .
09:54:02 <edwardk> many combinators in lens, (like to) are index-preserving in that if they do not or cannot use the index they pass along whatever index was given to them
09:54:12 <Botje> bad_alloc: yes, it does.
09:54:13 <edwardk> that is what filtered is doing here
09:54:24 <hiptobecubic> there is *at least* one book's worth of material on lens that needs to be written
09:54:24 <Botje> ghci prints elements one by one and forces stuff when it's necessary.
09:54:46 <BMeph> edwardk: That has a very ISWIM-esque flavor to it. :)
09:54:53 <bad_alloc> Botje: How do I "fix" this?
09:55:03 <Botje> bad_alloc: force the list in one go :)
09:55:22 <edwardk> BMeph: heh
09:55:23 <Botje> bad_alloc: let m = merge [1,3,5] [2,4,5] in length m `seq` m
09:56:38 <Botje> bad_alloc: also note that your merge is slightly broken
09:56:49 <Botje> consider merge [1,2,3] [4,5,6]
09:57:00 <edwardk> this can be useful with tables if you want to do nested grouping, etc. because each group comes back as an indexed traversal of subtables that you can continue to group, etc.
09:58:01 <edwardk> foo^@..group FooBar <.> group FooBaz . to count  -- can be used with tables to use the indices to do grouping by the Bar field, then the Baz field, and tuple them up to give you the counts by the tuple of those two things
09:58:14 <edwardk> and that can be interspersed with 'with' clauses, etc.
09:58:23 <bad_alloc> Botje: Ah, I see. I get 1,4,2... Well back to the drawing board and thanks for the hints :)
09:58:35 <edwardk> that usecase was a big motivator behind adding index-preservation to 3.8
09:58:49 <Botje> bad_alloc: you're pretty close though :)
09:59:10 <aCube> :t traversed
09:59:11 <aCube> :t traverse
09:59:11 <lambdabot> (Applicative f1, Traversable f, Indexable Int p) => p a (f1 b) -> f a -> f1 (f b)
09:59:13 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
09:59:30 <aCube> what is the difference between the too?
09:59:31 <edwardk> traversed gives you the index, traverse does not
09:59:42 <aCube> [1,2,3] ^@.. traverse
09:59:44 <aCube> > [1,2,3] ^@.. traverse
09:59:46 <lambdabot>   Couldn't match expected type `Control.Lens.Internal.Indexed.Indexed
09:59:46 <lambdabot>        ...
09:59:47 <edwardk> traversed takes any container with a Traversable instance and gives you the ordinal position in the traversal as an index
09:59:49 <aCube> ah ok
09:59:57 <edwardk> that is ordinal position, not the position in the container.
10:00:01 <hiptobecubic> edwardk, can't say I've heard anyone clamoring for "index-based nested grouping of nested subtables by key"
10:00:05 <aCube> > [1,2,3] ^@.. traversed
10:00:07 <lambdabot>   [(0,1),(1,2),(2,3)]
10:00:19 <edwardk> so if you have a Map with keys, itraversed will give you the keys, traversed will give you the position
10:00:32 <edwardk> hiptobecubic: have you ever used group by in sql? think that
10:00:51 <edwardk> hiptobecubic: i for one use aggregates in sql all the time =P
10:00:52 <hiptobecubic> True, I just haven't done any CRUD in haskell
10:01:59 <edwardk> i try to avoid it myself ;)
10:02:07 <hiptobecubic> edwardk, clearly
10:03:28 <edwardk> heh fortunately it seems even my database stuff involves category theory, as we're starting to use galois connections to talk about hierarchies and compression schemes in analytics ;)
10:07:37 <roadfish> sequence does [m a] -> m [a]. Is there something that does (m a,m b) -> m (a,b)?
10:07:52 <bad_alloc> (Maybe Botje:) It seems to work now, but I'm not sure if it's done properly. What could be improved?: http://cxg.de/_de8c8c.htm
10:08:26 <edwardk> shachaf++ # nullary typeclasses
10:08:38 <hiptobecubic> bad_alloc, type in EQ case?
10:09:08 <hiptobecubic> typo* (ironically)
10:09:32 <Botje> looks okay to me
10:10:03 <supki> roadfish: not as one function
10:10:47 <bad_alloc> hiptobecubic: what typo?
10:10:48 <roadfish> supki: are you implying there are two functions that will do it?
10:11:07 <hiptobecubic> bad_alloc, it appears you are including 'a' in the result twice?
10:11:14 <aCube> @ty uncurry $ liftM2 (,)
10:11:16 <lambdabot> Monad m => (m a1, m a2) -> m (a1, a2)
10:11:20 <hiptobecubic> a : b : merge as bs
10:11:27 <hiptobecubic> is probably what you wanted
10:12:01 <aCube> couldn't the head of as be smaller than b? hiptobecubic?
10:12:13 <hiptobecubic> bad_alloc, also note that  x : [] ++ aList == x : aList
10:12:25 <bad_alloc> hiptobecubic: well, since a == b that shouldn't matter, so I figures a : a might be more obvious, or am I wrong here?
10:12:51 <bad_alloc> hiptobecubic: really? the compiler barfed on that when I tried it.
10:13:17 <hiptobecubic> bad_alloc, well for numbers where a == b, implies a *is* b then it shouldn't matter. But you can implement the Eq typeclass differently for different types
10:14:15 <hiptobecubic> crazytype1 == crazytype2 might just mean "these are equal in the parts we care about". Whether or not that's great practice is a different question I guess
10:14:35 <bad_alloc> hiptobecubic: um, is this like in java a ==  b vs a.equals(b) ?
10:14:43 <hiptobecubic> > x : [] ++ [y,z] == x : [y,z]
10:14:45 <lambdabot>   True
10:15:39 <skuggi> bad_alloc: not really. you can't generally do the equivalent of java's (a == b) in haskell
10:16:35 <bad_alloc> hiptobecubic: the code after your changes: http://cxg.de/_b1550d.htm
10:16:56 <aristid> :t [x,y,z]
10:16:57 <lambdabot> [Expr]
10:18:20 <danharaj> edwardk: I saw the new nullary type class extension and I thought of reflection.
10:19:09 <edwardk> danharaj: yeah that one is a bit tricky because its kinda nice to be able to have two constraints of the same type
10:19:27 <edwardk> hence the 's'
10:19:54 <edwardk> that said for pure 'global configuration stuff' a nullary reflection wouldn't be bad
10:20:12 <hiptobecubic> aristid, package simple-reflect
10:20:17 <hiptobecubic> aristid, it's *very* nice
10:20:28 <edwardk> or rather it becomes a unary reflection because you have the type of the value
10:20:34 <hiptobecubic> > foldr f x [y,z]
10:20:35 <lambdabot>   f y (f z x)
10:20:37 <edwardk> in which case it could be used today
10:22:13 <danharaj> edwardk: well if there ever arise -1 type classes we will be glad we have nullary type classes for reflection :P
10:22:15 <tac> bad_alloc: yeah, there's no such thing as "reference equality" in Haskell
10:22:45 <aristid> hiptobecubic: i do know about the package :)
10:22:48 <edwardk> class Given a where given :: a; give :: a -> (Given a => r) -> r
10:24:21 <edwardk> danharaj: https://github.com/ekmett/reflection/issues/6
10:25:25 <hiptobecubic> bad_alloc, looks ok i think? Although I think it's typical to divide the list by "unzipping" rather chopping in half because of the way lists are implemented
10:25:28 <bad_alloc> tac: I can say nothing meaningful to that, as I have no idea how haskell works. but I can complain, that I can't find anything that corresponds to lisp's eq, eql, equal and equalsp, which is really nice.
10:25:52 <tac> yeah, CL is horrible with that.
10:26:08 <danharaj> edwardk: That would be a good class to have.
10:26:32 <edwardk> hen we can ship system wide configurations around with it, etc.
10:27:25 <danharaj> I am actually having a little trouble seeing what extra power the phantom s gives you over Given.
10:27:37 <edwardk> make two moduli
10:27:45 <danharaj> ah, and then pass them both in.
10:27:47 <bad_alloc> hiptobecubic: how does that work?
10:27:53 <edwardk> yeah
10:28:15 <edwardk> the other thing is the existing API can nominally be implemented without the hack
10:28:19 <edwardk> but given cannot
10:28:46 <danharaj> edwardk: to be quite honest it seems like reflection is so nice that it should be folded into GHC base and made guaranteed to work.
10:28:59 <danharaj> and work fast instead of precariously relying on shenanigans.
10:29:38 <edwardk> yeah, though its kind of nice that as a library i can support it clear back to hugs.
10:30:12 <danharaj> That is rather impressive but it seems to be a sad but true fact that Haskell as a community is turning into GHC as a community.
10:30:20 <edwardk> sure
10:32:35 <edwardk> bad_alloc: by not giving you those tools, we can make things faster though. r5rs semantics for scheme are interesting, but they basically force you to implement virtually every lambda as given, because each lambda gets its own location and can be compared for equality, etc. by separating those concerns we get more flexibility for the compiler
10:33:08 <edwardk> GHC does incredibly heroic rewriting on your code. it wouldn't be possible to do so and preserve those operations that you want in a sane way
10:34:12 <edwardk> bad_alloc: now, that said there are things like reallyUnsafePointerEquality# lying around in GHC modules, but I've in geneal been able to get away with using StableNames and other techniques that  let me avoid using it.
10:34:45 <danharaj> it should be pointed out what the significance of "reallyUnsafe" is. unsafePerformIO can segfault, for comparison.
10:34:59 <hiptobecubic> segfault > wrong
10:35:43 <edwardk> reallyUnsafePointerEquaity can lie when you work with performance monitoring turned on, etc.
10:35:45 <hiptobecubic> I want my programs to either be correct or violently explode
10:36:36 <bad_alloc> edwardk: Well, in that case I'll go on a quest to coerce C++ code into haskell ;) Seriously, I've just been dealing with haskell for a few days and this is something for later on I guess. Thanks for all the input :)
10:37:38 <sproingie> @remember hiptobecubic I want my programs to either be correct or violently explode
10:37:38 <lambdabot> Nice!
10:38:00 <monochrom> there is much incentive, for people who code for money, for covering up incorrectness, at least postpone until after payment
10:38:19 <hiptobecubic> monochrom, good thing no one pays me anything :|
10:39:12 <monochrom> my conspiracy theory is that this explains why people who code for money hug their dynamic languages so much
10:41:10 <hiptobecubic> monochrom, maybe partly. I think a huge part of it is that people who code for money are often under the direction of people who demand .... less productive.. languages.
10:41:55 <hiptobecubic> So if I have to chose between pythons dynamism and Java's ... whatever gross mess you want to call that, the choice isn't so mind boggling.
10:43:42 <hiptobecubic> Going to duck typing after working in a type system that sucks is like driving without your seat belt on at all, instead of just tying it around your neck.
10:53:16 <dmwit> ?remember hiptobecubic Going to duck typing after working in a type system that sucks is like driving without your seat belt on at all, instead of just tying it around your neck.
10:53:16 <lambdabot> I will remember.
10:56:29 <aristid> @quote neck
10:56:29 <lambdabot> PreauxPhoto says: catpants: you are lucky i like you, today at lunch i was going to come up behind you kiss you on the neck, pinch you nipple and say "cant wait till out date tonight" but i figured
10:56:29 <lambdabot> that one of those guys was your boss
10:56:29 <hiptobecubic> Does anyone see how to lazy this?
10:56:37 <hiptobecubic> >  let (a, b) = foldr (\x (as, bs) -> (x:bs, as)) ([], []) [1..10] in take 5 a
10:56:39 <lambdabot>   [1,3,5,7,9]
10:57:28 <aristid> lambdabot has some not-that-haskell-specific quotes as well, it seems.
10:57:35 <tac> @quote life
10:57:36 <lambdabot> dons says: wolgo: don't wait. learn it now. life is to short for bad code
10:58:03 <aristid> @quote tac
10:58:03 <lambdabot> tac says: It's actually really easy to remember all the numeric typeclasses in Haskell. Just think about what makes sense... then make sure whatever your answer is is not that
10:58:17 <aristid> :D
10:58:38 <tac> @quote invent
10:58:38 <lambdabot> kilimanjaro says: the bad kind of laziness is "so they just invent an equivalance class of monotonic continuous functions that `represent' that partial order. but they haven't taken a shower in like
10:58:38 <lambdabot> 10 days!"
10:59:13 <aavogt> > let (a, b) = foldr (\x ~(as, bs) -> (x:bs, as)) ([], []) [1..] in take 5 a
10:59:15 <lambdabot>   [1,3,5,7,9]
10:59:19 <aavogt> hiptobecubic: ^^
10:59:53 <aavogt> or you could have the pattern (as,bs) inside a let (instead of lambda)
11:00:04 <hiptobecubic> aavogt, I suppose now is a good time to finally figure out what ~ is really good for
11:00:20 <crdueck> hiptobecubic: its a lazy pattern match
11:00:27 <aavogt> > let (a, b) = foldr (\x asbs -> let (as,bs) = asbs in (x:bs, as)) ([], []) [1..] in take 5 a
11:00:29 <lambdabot>   [1,3,5,7,9]
11:00:37 <hiptobecubic> I knew that much, just not why i'd want it
11:01:14 <hiptobecubic> that seems like a strange place for ~ to matter
11:01:29 <hiptobecubic> (as, bs) doesn't really do anything with the list anyway
11:05:44 <hiptobecubic> aavogt, why does the ~ make this work with lazy lists? the pattern match never fails anyway
11:08:41 <geekosaur> not a matter of failing, it delays the actual pattern match until the value is demanded
11:08:57 <geekosaur> whereas a normal pattern match is strict
11:08:58 <hiptobecubic> Why does that help us here though?
11:09:30 <hiptobecubic> whnf of (as, bs) doesn't do anything with as or bs
11:11:10 <geekosaur> no, but to get that (,) you need to force the computation that returns it
11:12:48 <hiptobecubic> which is what here?
11:15:34 <geekosaur> the previous iteration of the fold, tot he point that produces the tuple, which deconstructs the list in the process
11:15:48 <geekosaur> at least, as I'm reading it
11:21:47 <hiptobecubic> hmm
11:28:43 <hiptobecubic> geekosaur, this explains it. I'm still shaky though http://stackoverflow.com/questions/12429449/lazy-pattern-matching-in-data-list  Have to spend some time staring at it
11:29:27 <geekosaur> right, that's pretty much what I said
11:30:10 <geekosaur> it has to force the previous iteration of the fold to get the tuple constructor
11:33:56 <hiptobecubic> I think I see it. So we end up with select p x (if p x then (x : fst (select....), snd (select ...))
11:34:51 <hiptobecubic> And then somehow we avoid recomputing the (select ...)
11:35:28 <hiptobecubic> So more like let rest = (select p y .. ) in select p x (if p x then (x : fst rest, snd rest)
11:35:39 <hiptobecubic> )
11:38:46 <hiptobecubic> I hope, anyway
11:41:10 <monochrom> > case undefined of ~(x,y) -> "win"
11:41:12 <lambdabot>   "win"
11:41:29 <hiptobecubic> I understand the toy examples
11:41:41 <geekosaur> you migth want to play around with hood/ghood to watch it being evaluated?
11:41:45 <hiptobecubic> even the name "lazy pattern match" is enough to give that away
11:42:18 <monochrom> I think your translation to fst and snd is right
11:42:28 <hiptobecubic> geekosaur, what is this magic? Is this like ghc-vis?
11:42:47 <monochrom> except you have to write a different translation for a different type
11:43:15 <geekosaur> older version of the idea, ghood might be easier to work with (or might not)
11:43:34 * hackagebot pdf-toolbox-core 0.0.1.0 - A collection of tools for processing PDF files.  http://hackage.haskell.org/package/pdf-toolbox-core-0.0.1.0 (YurasShumovich)
11:43:36 * hackagebot pdf-toolbox-core 0.0.1.1 - A collection of tools for processing PDF files.  http://hackage.haskell.org/package/pdf-toolbox-core-0.0.1.1 (YurasShumovich)
11:46:57 <monochrom> "case e of ~(x:xs) -> ... x ... xs ..." = "let {x=head e; xs=tail e} in ... x ... xs ..."
11:47:16 <monochrom> ~ is more uniform and concise
11:47:43 <monochrom> also, changing between more ~ and fewer ~ is easy
11:48:34 * hackagebot pdf-toolbox-document 0.0.1.0 - A collection of tools for processing PDF files.  http://hackage.haskell.org/package/pdf-toolbox-document-0.0.1.0 (YurasShumovich)
11:48:46 <hiptobecubic> oh ghood is nice!
11:49:11 <hiptobecubic> it's not as pretty, but the stepping back and forth through computation is great
11:50:30 <parcs> lazy patterns are useful for higher order functions
11:51:57 <luite> hm i should build a ghc-vis like thing for ghcjs
11:52:55 <hiptobecubic> ghc-vis is also great
11:53:34 * hackagebot wai-util 0.2 - Collection of utility functions for use with WAI  http://hackage.haskell.org/package/wai-util-0.2 (StephenWeber)
11:56:48 <Scabe> Test
11:57:13 <elliott> test successful.
11:58:53 <Scabe> How would you write a Bool function where a number divisible by 4 is true and 100 is false or it is divisible by 4 and by 400
11:59:52 <ivan____> Scabe: leap year calc?
12:00:00 <Scabe> Yeah
12:00:17 <ivan____> there is probably already a library that can tell you if a year is a leap year
12:00:34 <hpaste> “Ben Gamari” pasted “Type level literals fail” at http://hpaste.org/84568
12:01:38 <monochrom> @let monoleap x = x `mod` 400 == 0 || (x `mod` 4 == 0 && x `mod` 100 /= 0)
12:01:42 <lambdabot>  Defined.
12:01:50 <monochrom> that is how I would write it
12:02:04 <Scabe> ooh thanks I'll try make some sense out of that
12:03:28 <timthelion> How do I get the advertized core dump from ghci? /home/timothy/bin/ghci-shell: line 3:  2283 Segmentation fault      (core dumped) ghci shellHack.hs
12:03:38 * lispy often puts parens around x `mod` y, due to being forgetfull about precedence
12:04:05 <monochrom> yeah, if there are also + and *, I add parentheses
12:04:17 * timthelion often adds parens due to a asthetic fondness for lisp.
12:04:19 <lispy> timthelion: well, just know that the core dump is unlikely to be useful. You probably need to look at the ulimit command.
12:04:40 <timthelion> lispy: What do the ghci devs want on trac?
12:04:53 <timthelion> lispy: I have something reproducable.
12:04:59 <timthelion> and racy :)
12:05:01 <lispy> timthelion: a reproducible test case that is minimal is usually ideal
12:05:06 <monochrom> complete procedure for how to segfault
12:05:08 <ion> > let ionleap year = year `divisible` 400 || (year `divisible` 4 && not (year `divisible` 100)) where { a `divisible` b = (a `rem` b) = 0 } in map ionlean [2000, 2003, 2004, 2005, 2100, 2200, 2300, 2400, 2500]
12:05:10 <lambdabot>   <hint>:1:133: parse error on input `='
12:05:20 <ion> > let ionleap year = year `divisible` 400 || (year `divisible` 4 && not (year `divisible` 100)) where { a `divisible` b = (a `rem` b) == 0 } in map ionlean [2000, 2003, 2004, 2005, 2100, 2200, 2300, 2400, 2500]
12:05:22 <lambdabot>   Not in scope: `ionlean'
12:05:22 <lambdabot>  Perhaps you meant `ionleap' (line 1)
12:05:24 <ion> sigh
12:05:32 <ion> Well, you get the idea. :-P
12:05:44 <monochrom> this is why I use @let
12:05:46 <ion> assuming typos were my only errors
12:10:22 <timthelion> I would like to send them the core dump along with the instructions. It is racy, about 10% reproducable. So I don't want them to lose time trying to reproduce it if thet cannot.
12:11:48 <monochrom> I see
12:12:14 <monochrom> ulimit and other OS settings are the only thing between you and a core dump
12:14:34 <timthelion> monochrom: but that only changes the file size(I didn't see in the man page where to find the path of the darned dump)
12:16:05 <lispy> timthelion: I thought the dump always appear in the cwd
12:17:31 <lispy> ulimit -c unlimited; ./myapp
12:17:40 <lispy> and then it should be in the same directory, I think
12:17:44 <roconnor> join #ledger
12:17:49 <roconnor> opps
12:18:15 <lispy> timthelion: oh, actually
12:18:18 <lispy> timthelion: http://man7.org/linux/man-pages/man5/core.5.html
12:18:20 <croikle> timthelion: looks like size 0 disables it, that's why
12:18:27 <lispy> timthelion: search for "naming of core"
12:18:34 * hackagebot git-annex 4.20130323 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20130323 (JoeyHess)
12:19:05 <lispy> By default, a core dump file is named core, but the /proc/sys/kernel/core_pattern file (since Linux 2.6 and 2.4.21) can be set
12:19:08 <lispy>        to define a template that is used to name core dump files.
12:20:37 <Scabe> Thanks for the help on the leap year guys. Although I still haven't been able to write down a code without an error.
12:20:59 <Scabe> is_leap_year :: Integer -> Bool (How would I continue on from that)
12:22:48 <timthelion> hrmph. no core files, and I have ulimit telling me that the limit is unlimited.
12:23:02 <lispy> timthelion: did you see what I said about the core pattern?
12:23:41 <timthelion> |/usr/lib/systemd/systemd-coredump %p %u %g %s %t %e
12:23:42 <lispy> timthelion: your distro might put core dumps in a fancy location and you can check by looking at that core_pattern file in proc
12:23:51 <timthelion> that's what is in the core_patter file
12:24:03 <lispy> man systemd? :)
12:24:21 <timthelion> lispy: It seems I'm in for the long haul here.
12:24:32 <lispy> yeah :(
12:25:03 <lispy> What you need to know/do is probably very simple. Sifting through the layers to get to that answer may take a while.
12:25:31 <lispy> timthelion: I think you can use systemd-coredumpctl to extract the core dump
12:25:32 <timthelion> lispy: If it's not in the current working directory it's not simple :)
12:26:12 <lispy> timthelion: see for example: http://www.freedesktop.org/software/systemd/man/systemd-coredumpctl.html
12:26:14 <timthelion> $ systemd-coredumpctl list
12:26:14 <timthelion> No coredumps found
12:26:18 <lispy> Description
12:26:19 <lispy> systemd-coredumpctl may be used to retrieve coredumps from systemd-journald(8).
12:27:16 <lispy> I'd ask in the distro-specific irc channel.
12:27:21 <lispy> I'm sure someone there has done this before
12:27:44 <timthelion> lispy: well thanks for your help anyways
12:29:58 <lispy> timthelion: yeah, no problem. I am curious what the answer turns out to be.
12:36:57 <dates> Hello. I have a list of lists like this : [[1,3],[1],[1,2,3]] and I want to make it a list of tuples like this [(0,1),(0,3),(1,1),(2,1),(2,2),(2,3)]. As you can see the indexes of lists become the first element of tuples. How can I make this conversion?
12:37:31 <lispy> dates: you should look at zip and zipWith
12:37:38 <lispy> ?src zip
12:37:38 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
12:37:38 <lambdabot> zip _      _      = []
12:37:50 <lispy> or, zip = zipWith (,)
12:38:13 <lispy> dates: you can do things like, zip [0..] mylist
12:38:24 <lispy> and you get back [(0,a), (1,b) ... ]
12:39:46 <dates> lispy : but as you can see, there are more than one (0,a)s
12:40:42 <lispy> yeah, so you'll probably want to have an outer zip and an inner zip plus a concat on the whole thing when you're done.
12:41:26 <lispy> concat (zipWith (zip ...) ...)
12:42:11 <dates> okey, thank you!
12:43:01 <lispy> I can see several ways to approach it, and it could be that one of those zips is more natural as a map.
12:43:13 * lispy disappears
12:44:59 <croikle> one way: concat . zipWith (map . (,)) [0..]
12:45:15 <croikle> not necessarily the clearest, of course
12:46:49 <timthelion> lispy: sigh http://hackage.haskell.org/trac/ghc/ticket/7789
12:47:02 <dates> croikle : where should I put the list of list in that expression?
12:47:05 <timthelion> lispy: it seems it was posting the core dump to standard output
12:47:37 <timthelion> lispy: but due to the brokenness of things when it does so, I cannot see more of it than that.
12:47:45 <croikle> dates: after a $, or define foo = (the function)
12:47:55 <croikle> but you should understand how it works
12:48:15 <shachaf> timthelion: Why is that a GHC bug?
12:48:28 <timthelion> shachaf: because it causes ghci to core dump
12:48:31 <croikle> (map . (,)) is more clearly expressed as (\n x -> map (n,) x)
12:48:36 <geekosaur> this sounds like it's more likely a bug in the ncurses binding
12:48:44 <copamp> > take 5 $ concat . zipWith (map . (,)) [0..]
12:48:46 <lambdabot>   Couldn't match expected type `[[[a0]]]'
12:48:46 <lambdabot>              with actual type `[b0]...
12:48:48 <shachaf> timthelion: I would be more inclined to suspect vty-menu
12:48:51 <timthelion> geekosaur: I'd agree that that's a possibility
12:48:54 <copamp> > take 5 $ ( concat . zipWith (map . (,)) [0..] )
12:48:56 * geekosaur was just noting the existence of several such in the haskell x11 bindings over in #xmonad
12:48:56 <lambdabot>   Couldn't match expected type `[[[a0]]]'
12:48:56 <lambdabot>              with actual type `[b0]...
12:49:14 <timthelion> shachaf: well, vty has some nasty bugs so I wouldn't be surprised.
12:49:15 <croikle> > concat . zipWith (map . (,)) [0..] $ [[1,3],[1],[1,2,3]]
12:49:18 <lambdabot>   [(0,1),(0,3),(1,1),(2,1),(2,2),(2,3)]
12:49:20 <geekosaur> it's generally rather more liukely that someone forgot to handle a null pointer return from the FFI than that ghci is broken
12:49:37 <timthelion> shachaf: ever tried inputing a non ascii charicter into vty?
12:49:43 <geekosaur> especially since ghci is threaded and ncurses can require some care around threads
12:49:53 <shachaf> timthelion: No, I've never used vty.
12:49:55 <geekosaur> *especially* involving input
12:50:27 <shachaf> geekosaur: As far as I know vty doesn't use ncurses.
12:50:40 <dates> Thanks a lot !
12:50:45 * timthelion can confirm that vty does not use ncurses.
12:51:00 <croikle> I wonder if ZipLists would express it nicely
12:51:07 <geekosaur> shachaf, the loaded library list shows ncurses involved; note that, while it may be not using the higher level ncurses stuff, the same library is used for lower level terminfo stuff and the same caveats vcan apply
12:51:28 <geekosaur> and it is clearly using terminfo level stuff from the other error messages
12:52:08 <aCube> When does :step just hang?
12:53:35 * hackagebot diagrams-contrib 0.6.1 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-0.6.1 (BrentYorgey)
12:53:37 * hackagebot csound-expression 1.0.4 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-1.0.4 (AntonKholomiov)
12:54:04 <aavogt> > concat . getZipList $ (map . (,)) <$> ZipList [0..] <*> ZipList [[1,3],[1],[1,2,3]] -- croikle
12:54:06 <lambdabot>   [(0,1),(0,3),(1,1),(2,1),(2,2),(2,3)]
12:54:26 <aavogt> seems messier if you explicitly have to wrap/unwrap newtypes
12:54:35 <croikle> aavogt: not really nicer, I agree
12:55:03 <aCube> Is there anything I can do to find out more information about the execution of some code if :step in ghci does not return?
12:55:31 <copamp> > (+1) 2
12:55:33 <lambdabot>   3
12:55:40 <timthelion> geekosaur: it always core dumps in the same place, with a lot of ffff's ;) my untrained eye tells me some kind of overflow is going on.
12:56:15 <geekosaur> a lot of ffffs may mean the syscall interface which is mapped into the top pages of process virtual memory
12:56:53 <timthelion> geekosaur: ok.
12:57:04 <geekosaur> aCube, lacking other information I would guess that it's a tight loop that isn't doing any allocations. which is possible in ghci if it's running compiled code that underwent stream fusion
13:00:02 <aCube> It doesn't loop with GHC 7.6, but it does with 7.4 :(
13:00:12 <aCube> I'm trying to simplify it
13:00:19 <timthelion> geekosaur: ghci itself uses ncurses, I think it uses readline
13:01:29 <geekosaur> granted, but unless vty is actually using its own private terminal database or just assuming and hardcoding ANSI, it's probably using terminfo. and again, the error messages about setaf and cup you attached to the ticket are from terminfo
13:01:29 <aavogt> croikle: something might be possible with http://hackage.haskell.org/package/newtype-0.2 , but I can't figure it out
13:04:02 <bgamari> Anyone have any idea how to get GHC's typechecker to realize that 0+1 ~ 1?
13:04:03 <timthelion> geekosaur: the real reason why it is a ghci bug, is that vty doesn't crash in this case, when run on it's own, without ghci
13:04:15 <bgamari> e.g.    Couldn't match type `0 + 1' with `1'
13:04:42 <geekosaur> try --no-ghci-sandbox then, which would point to using a non-thread-aware library unsafely in threaded context?
13:05:01 <geekosaur> which is not a ghci bug, it is just something you must be aware of when working with threads
13:05:33 <geekosaur> they're not going to remove threads from ghci so you can use a library that isn't threadsafe
13:05:37 <timthelion> geekosaur: is that a ghci flag? if so ghci 7.4.2 doesn't know it.
13:06:09 <timthelion> geekosaur: well, they might eventually revamp the ffi to make it work better with threads.
13:06:14 <timthelion> ;)
13:06:16 <geekosaur> hm, it's a recent flag, lemme check if it was in 7.4.2 (I thoguht it was)
13:06:16 <geekosaur> no
13:06:28 <geekosaur> the ffi can do precisely nothing about a C library that is not threadsafew
13:07:13 <timthelion> geekosaur: well, that may be true, but it's not transparent about which thread things belong to. thus causing no end of pain for people trying to use gtk :(
13:07:20 <monoidal> bgamari: I believe HEAD has not merged naturals yet
13:07:39 <monoidal> bgamari: there's a special branch with type-level naturals
13:08:31 <bgamari> monoidal, I'm pretty sure there were present in 7.6
13:09:05 <monoidal> bgamari: only as a datatype, not in the constraint solver
13:09:12 <bgamari> ahh, that could be true
13:09:31 <timthelion> geekosaur: sure ffi can deal with non thread safe libraries. There just needs to be some sequentialization enforced.
13:09:32 <bgamari> oh dear, it's still not even in HEAD?
13:09:33 <geekosaur> timthelion, sorry, it's -0fno-ghci-sandbox
13:10:12 <geekosaur> er
13:10:18 <geekosaur> I apparently cannot type
13:10:22 <otters> heh
13:10:26 <geekosaur> -fno-ghci-sandbox
13:10:33 <monoidal> bgamari: that's right. head currently cannot simplify 0+1 to 1
13:10:53 <bgamari> ouch, alright then
13:11:00 <monoidal> bgamari: the branch is here: https://github.com/ghc/ghc/tree/type-nats although I never tried it
13:11:27 <timthelion> geekosaur: still core dumps though :/
13:23:35 * hackagebot diagrams-haddock 0.1.0.0 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.1.0.0 (BrentYorgey)
13:26:08 <hiptobecubic> in this example, they ask why switching the order of the definitions of head' doesn't help. However, it seems to me like that would indeed make it equivalent to Prelude.head, either retuning the first element of the list or _|_
13:26:11 <hiptobecubic> https://en.wikibooks.org/wiki/Haskell/Laziness#When_does_it_make_sense_to_use_lazy_patterns.3F
13:26:31 <hiptobecubic> You get an error for a different reason, but bottom is bottom
13:28:23 <hpaste> dmj pasted “mergesort hask” at http://hpaste.org/84571
13:28:34 <hpaste> aCube pasted “Loops with 7.4, doesn't with 7.6 - Can probably be simplified still” at http://hpaste.org/84572
13:29:20 <geekosaur> hiptobecubic, the semantics are different if you swap them, in effect you have removed the ~[] case entirely because it can never be matched
13:30:05 <hiptobecubic>  geekosaur i realize that it changes the meaning if you swap them. but why does swapping them cause a problem. When they are swapped we get Prelude.head, don't we?
13:30:15 <geekosaur> so yes, different reason indeed, it's because you broke the semantics
13:30:35 <hiptobecubic> you lazily match against (x:xs). if it works you return x otherwise _|_
13:30:50 <hiptobecubic> ... which is also what head does
13:31:29 <hiptobecubic> I see that in its current state head' is _|_
13:31:47 <hiptobecubic> but with the equations flipped? It seems fine
13:31:50 <geekosaur> so the fact that a different semantics is desired is not relevant?
13:32:03 <hiptobecubic> Has a redundant case, but still works exactly the same way
13:32:15 <geekosaur> no, it throws the undefined later
13:32:26 <hiptobecubic> so does Prelude.head
13:32:27 <geekosaur> you have changed the time behavior of the undefined
13:32:38 <hiptobecubic> Oh right
13:32:41 <hiptobecubic> the lazy part :D
13:33:07 <geekosaur> it's a subtle difference but it is a difference, that means that you've already made an annoying bug to find even harder because it's even lazier now
13:34:29 <hiptobecubic> geekosaur, can you make a small example showing this being a problem?
13:35:08 <aCube> Can anyone help me with that paste? It can probably be simplified a lot, but I wasn't able to do that. It does loop with GHC 7.4, but doesn't with 7.6
13:35:48 <monoidal> aCube: what is the expected behavior?
13:36:09 <geekosaur> not sure I can off the top of my head, no; it is rarely a problem with simple examples because its easy to work out where the real problem is. where it becomes problematic is the complex ones where your undefined triggers at an unexpected place when something (usually your final print at the end of the program) finally demands the evaluation
13:36:38 <aCube> monoidal: i expect it to not loop
13:37:13 <dates> hi, Can someone copy&paste the chat history of last 2 hours to me?
13:37:41 * geekosaur points to logs in /topic, wonders why you need someone else to do stuff for you
13:37:50 <aCube> http://tunes.org/~nef/logs/haskell/
13:37:52 <typoclass> dates: hello. tunes.org has logs of this channel. see the channel topic for the link. you just need to select today's date
13:38:37 * hackagebot free-functors 0.1.2 - Provides free functors that are adjoint to functors that forget class constraints.  http://hackage.haskell.org/package/free-functors-0.1.2 (SjoerdVisscher)
13:38:45 <monoidal> aCube: could it be http://hackage.haskell.org/trac/ghc/ticket/7126 ?
13:38:59 <dates> thank you very much!
13:39:00 <timthelion> dates: http://ircbrowse.net/browse/freenode/haskell
13:45:21 <dates> timthelion : thank you
13:45:22 <hpaste> dmj revised “mergesort hask”: “mergesort non-exhaust” at http://hpaste.org/84571
13:46:03 <dmj> Anyone want to take a stab as to why my mergesort has non exhaustive patterns in merge? I feel as if I have covered all the corner cases...
13:46:30 <monoidal> dmj: merge left@(x:xs) right@(y:ys) matches only when left and right are nonempty
13:46:43 <dEPY> whats @ ?
13:46:56 <monoidal> dmj: effectively, null left is never true for this pattern
13:47:13 <monoidal> dEPY: x@pat is a pattern that matches p
13:47:24 <monoidal> dEPY: x@pat is a pattern that matches pat and binds to x
13:47:36 <dEPY> ok tnx
13:47:37 <latro`a> is x@p sugar?
13:47:50 <monoidal> dEPY: for example,
13:47:51 <dmj> monoidal: ahh thank you
13:47:53 <monoidal> > case [3,4] of x@(a:b) -> (x,a,b)
13:47:54 <lambdabot>   ([3,4],3,[4])
13:48:29 <dmj> case [] of x@(y:ys) -> (x,y,xs)
13:48:37 * hackagebot free 3.4.1 - Monads for free  http://hackage.haskell.org/package/free-3.4.1 (EdwardKmett)
13:48:37 <monoidal> > case [] of x@(y:ys) -> (x,y,xs)
13:48:39 <lambdabot>   Not in scope: `xs'
13:48:39 <lambdabot>  Perhaps you meant one of these:
13:48:39 <lambdabot>    `x' (line 1), `ys' (...
13:48:55 <dmj> case [] of x@(y:ys) -> (x,y,ys)
13:48:59 <monoidal> > case [] of x@(y:ys) -> (x,y,ys)
13:49:01 <lambdabot>   *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
13:49:05 <monoidal> dmj: you need to precede with >
13:49:09 <dEPY> dmj: you have to precede with >
13:49:15 <dEPY> > 1 + 1
13:49:17 <lambdabot>   2
13:49:55 <dmj> > case [] of a@(b:bs) -> (a,b,bs)
13:49:56 <lambdabot>   *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
13:50:00 <dmj> monoidal: thank you again
13:50:15 <latro`a> > case [] of x@(y:ys) -> x
13:50:17 <lambdabot>   *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
13:50:23 <latro`a> ^is an even clearer example
13:50:45 <elliott> that's clear? :P
13:52:54 <shachaf> > case case esac of fo -> esac of fo -> fo
13:52:56 <lambdabot>   hi
13:53:24 <monoidal> > esac
13:53:26 <lambdabot>   hi
13:54:24 <shachaf> Haskell could learn a thing or two from ALGOL!
13:54:29 <shachaf> (But it probably shouldn't.)
13:54:44 <hpaste> dmj revised “mergesort hask”: “mergesort vundebar” at http://hpaste.org/84571
13:55:28 <dmj> it's a very nice! nicer than this one: http://en.literateprograms.org/Merge_sort_(Haskell)
13:55:41 <dmj> why would they use a custom split function when we have splitAt?
13:55:55 <monoidal> dmj: you can replace (==) ... True with ...
13:57:08 <dmj> > sort [5,4,3,2,1] == [1..5]
13:57:09 <lambdabot>   True
13:57:24 <dmj> > sort [5,4,3,2,1] == [1..5] == True
13:57:25 <lambdabot>   Precedence parsing error
13:57:26 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
13:57:28 <dmj> :(
13:57:38 <monoidal> > (sort [5,4,3,2,1] == [1..5]) == True --dmj
13:57:38 <fjdw> Is the number zero a circle or an ellipsis? In keyboards and fonts it's an ellipsis, but I guess that could be due to the need to different is from the capitalized letter "o".
13:57:40 <lambdabot>   True
13:58:13 <shachaf> It is a number. Numbers are not shapes.
13:58:18 <dmj> monoidal: the linter didn't seem to care. Is there a performance gain or is the other style more idiomatic?
13:58:23 <monoidal> dmj: style
13:58:32 <geekosaur> also you meant ellipse
13:58:36 <geekosaur> ellipsis is "..."
13:58:48 <fjdw> shachaf: It has a correct way of being drawn, doesn't it.
13:58:53 <dmj> monoidal: how do you learn style? Read the spec?
13:59:03 <shachaf> I draw it as three connected line segments, as follows: Z
13:59:25 <shachaf> fjdw: At any rate this seems pretty off-topic for this channel.
13:59:52 <monoidal> dmj: for idioms like this, you can use hlint
14:00:03 <monoidal> dmj: do "cabal install hlint" and "hlint <sourcename>" to get tips
14:00:05 <geekosaur> and no, it does not have a "correct way of being drawn", as the existence of fonts where you cannot distinguish (and old-time typewheters which didn't have 0 at all but had you type capital O!) proves
14:00:35 <geekosaur> in fact, O-slash originated in that context, for those cases where clarity between O and 0 was needed
14:00:59 <geekosaur> (not commonly, so it didn't really come into its own until later)
14:01:52 <dmj> monoidal: hlint says "no suggestions" on my code when using " print $ (==) (mergesort [5,4,3,2,1] == [1..5]) True"
14:02:10 <geekosaur> *typewriters
14:02:20 <geekosaur> where in the world did my fingers gets typewheters from
14:02:37 <monoidal> dmj: it should if you write (mergesort [5,4,3,2,1] == [1..5]) == True. sometimes the hints do not fire
14:03:08 <dmj> monoidal: but isn't that the idiomatic way to write it?
14:03:34 <geekosaur> the hints are heuristic, it doesn't convert to an AST and recognize dubious constructs via the AST, it recognizes patterns
14:03:47 <geekosaur> if you write your expression sufficiently differently from how it expects, no hints
14:04:17 <monoidal> dmj: the tips appearing at hpaste come from hlint
14:05:17 <dmj> monoidal: yes, and http://hpaste.org/84571 shows no linting. Maybe it just didn't fire like you said.
14:05:46 <monoidal> dmj: if you write  (mergesort [5,4,3,2,1] == [1..5]) == True it should fire
14:06:05 <monoidal> dmj: still, hlint is a *really* useful tool, don't be discouraged by this one
14:06:14 <hpaste> dmj revised “mergesort hask”: “fire!” at http://hpaste.org/84571
14:06:26 <dmj> monoidal: cool
14:07:13 <dmj> monoidal: last question, is concat or (++) an O(n) operation?
14:07:24 <dmj> a*
14:07:44 <monoidal> dmj: that's bit complicated due to laziness, but in full generality, yes
14:08:23 <johnw> if you look at the definition for (++), you found:
14:08:29 <johnw> find: (++) (x:xs) ys = x : xs ++ ys
14:08:34 <johnw> so it's O(n)
14:08:40 <johnw> where n is the left argument
14:08:43 <johnw> (size of)
14:09:32 <dmj> monoidal: What's a good primer on reasoning about laziness? I saw on SO don stewart mentioned you take the amortized time modulo laziness. CLRS doesn't teach me these things.
14:10:28 <johnw> dmj: http://www.slideshare.net/tibbe/reasoning-about-laziness?
14:11:23 <monoidal> dmj: I don't know any good primer, johnw's link is a good one
14:11:48 <dmj> johnw: timely
14:12:48 <hpaste> aCube annotated “Loops with 7.4, doesn't with 7.6 - Can probably be simplified still” with “Exactly the same with own typeclass, except the profunctor noise. Does not loop” at http://hpaste.org/84572#a84576
14:13:20 <shachaf> aCube: Is this about the GHC bug?
14:13:23 <aCube> yes
14:13:27 <aCube> shachaf: another one :/
14:13:31 <shachaf> aCube: I did file http://hackage.haskell.org/trac/ghc/ticket/7788 yesterday
14:13:42 <dmj> johnw: thanks
14:13:44 <aCube> shachaf: this one only exists in 7.4
14:14:06 <shachaf> aCube: I wonder whether it exists in both but only happens when optimizations happen in a particular way.
14:14:11 <shachaf> Since this is so sensitive to inlining etc.
14:14:35 <monoidal> aCube: personally I have doubts whether GHC devs will have time to fix 7.4
14:14:39 <aCube> shachaf: I think this bug is another one, because it doesn't trigger if I use undefined for test val
14:15:32 <johnw> dmj: http://blog.ezyang.com/2011/04/the-haskell-heap/
14:15:51 <johnw> dmj: http://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/
14:16:42 <johnw> that last one wasn't the one I was thinking of
14:16:44 <monoidal> johnw: last link is more a criticism of laziness
14:16:44 <johnw> still looking...
14:17:53 <shachaf> johnw: Any reason you're +o?
14:17:58 --- mode: johnw set -o johnw
14:18:07 <johnw> we had a person who seemed like a spammer before
14:18:09 <johnw> forgot to deop
14:18:44 <aCube> monoidal: But what surprises me is that it goes away when I replace the Ixed and Contains type classes with own type classes. (With the only change being removing the indexed profunctor in favor of a simple function). Maybe this bug can be worked around?
14:18:47 <johnw> dmj: http://homepages.inf.ed.ac.uk/wadler/topics/call-by-need.html
14:18:53 <johnw> bunch of good papers there
14:20:20 * djahandarie finds it remotely amusing that Bob Harper's article was accidently linked to when trying to find something which explains laziness optimizations
14:20:41 <johnw> shachaf: do you know where that web article is which gives all the nice little diagrams to show data sharing, and which shows the difference between non-strict (denotational) and lazy (operational)?
14:20:49 <shachaf> Maybe
14:20:51 <shachaf> @where lazy ?
14:20:51 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
14:21:01 <johnw> thank you
14:21:08 <johnw> google utterly failed me on that one
14:21:17 <johnw> dmj: that
14:21:40 <edwardk> djahandarie: at least the rebuttals on that are good =)
14:23:44 <dmj> monoidal: Is (length xs) and (splitAt xs) recalculated on each recursive call? in CLRS mergesort uses indices p q r so finding the length and where to split is constant. Does ghc optimize for this?
14:23:50 <hpaste> dmj revised “mergesort hask”: “perf mergesort” at http://hpaste.org/84571
14:23:51 <djahandarie> It's too bad he's so invested in ML though, he does cool work on the Directed Type Theory stuff.
14:24:19 <monoidal> dmj: they're recalculated each call
14:24:50 <monoidal> dmj: note that this does not change asymptotics, but still, we're sorting linked lists
14:27:13 <johnw> it's funny how launching nuclear missiles has become our cultural example of a side-effect ;)
14:28:12 <Lethalman> considering it might not be a side effect at all :P
14:28:25 <dmj> monoidal: http://stackoverflow.com/questions/1215432/merge-sort-in-haskell is what I should have been looking at. So the optimizations that can be made are to use mutable arrays (ST?) and ByteString. How would using ByteStrings make this faster? Isn't linkedlist traversal still n?
14:29:28 <typoclass> johnw: i think it's only missiles. they could be non-nuclear. which is desirable anyway, from a perspective of reusability/generality/polymorphism/abstractitude
14:30:11 <typoclass> launchMissiloids
14:30:22 <typoclass> launchDangerousThings
14:30:34 <johnw> i'm reading ezyang's little comic series, and he has a radiation symbol on his missile :)
14:31:00 <shachaf> (☢) :: IO a -> a
14:31:07 <johnw> exactly
14:31:16 <johnw> that's an excellent name for that function!
14:31:17 <monoidal> dmj: bytestrings are more packed
14:31:29 <johnw> shachaf: propose it to libraries@, stat!
14:31:45 <monoidal> dmj: for sorting characters of a string, counting sort should be fastest
14:31:47 <jmcarthur> dmj: note that the standard sort function doesn't use anything like splitAt, btw
14:31:56 <jmcarthur> or length
14:32:38 <dmj> jmcarthur: is Prelude sort just quicksort?
14:32:45 <jmcarthur> (not that it makes it asymptotically better, but it is a bit nicer to think about from a laziness point of view)
14:32:46 <monoidal> dmj: it's mergesort
14:33:02 <dmj> oh
14:33:16 <johnw> quicksort isn't so fantastic if you have immutable data structures
14:33:41 <monoidal> dmj: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#sort
14:33:52 <latro`a> how is difflist quicksort?
14:33:54 <dmj> monoidal: so this is why they made their own split function
14:33:55 <jmcarthur> quicksort can still be pretty nice
14:34:01 <jmcarthur> you just have to be careful with append
14:34:12 <mikeplus64> latro`a: i don't think you can sort a dlist
14:34:25 <latro`a> I mean with intermediate structures of diff lists
14:34:27 <latro`a> instead of appends
14:34:32 <jmcarthur> mikeplus64: but you can use a diff list for the result
14:34:40 <dmj> jmcarthur: haskell quicksort doesn't use a randomized partition, unless I am mistaken
14:34:44 <johnw> dlists get turned into regular lists when you need to access any element
14:34:48 * timthelion hates monads :(
14:34:49 <jmcarthur> dmj: no
14:35:01 <johnw> timthelion: but they still love *you*
14:35:06 <jmcarthur> dmj: a randomized pivot is only a heuristic anyway
14:35:13 <johnw> their wrap their context-arms around you, and then give you no way out
14:35:24 <timthelion> johnw: try mixing IO with other monads, and you'll hate them too.
14:35:31 <monoidal> jmcarthur: it's not a heuristic. that guarantees nlogn expected case
14:35:35 <jmcarthur> timthelion: nah, i still love them
14:35:36 <johnw> ah, then what you hate are monad transformers
14:35:41 <johnw> actually, I like monad transformers
14:36:00 <timthelion> johnw: I like monad transformers, but they still don't make me hate monads any less.
14:36:04 <monoidal> jmcarthur: instead of average case, which might be suspectible to O(n^2) [I believe there are DOS attacks based on this]
14:36:04 <johnw> in fact, the library I'm working on now is like 90% made up of functions that return monad transformer types
14:36:05 <jmcarthur> monoidal: ah, yeah
14:36:16 <johnw> timthelion: and what is your hatred of the moment?
14:36:30 <timthelion> johnw: just remember, that monads are just fancy folds and then you'll realize how awful their syntax is.
14:36:37 <jmcarthur> monads aren't even something that seem "hatable" to me
14:36:41 <jmcarthur> transformers could be though
14:36:47 <johnw> i rather like their syntax, actually
14:36:54 <johnw> so which specific thing are you disliking tonight?
14:36:57 <jmcarthur> how are monads just fancy folds?
14:37:06 <timthelion> johnw: the fact that haskelline uses a monad instead of some state value.
14:37:14 <shachaf> I,I "No, I am not saying that at all; I am saying something far more drastic! What I am saying has absolutely nothing to do with right or wrong. What I am saying is that one who knows me for what I really am would simply find it psychologically impossible to hate me."
14:37:23 <johnw> oh, that's what you mean by a fold
14:37:28 <johnw> jmcarthur: he means threading context
14:37:28 <timthelion> johnw: thus forcing the use of some transformer garbage just to use the package.
14:37:34 <johnw> manually, rather than via >>=
14:37:53 <dmj> jmacarthur: My understanding is: in imperative styles mergesort is always O(n lg n) and input order doesn't matter, but the drawback is space. quicksort is in place, but worst-case O(n^2). Since haskell is immutable won't quicksort also have a space complexity issue? Or can ghc optimize for this?
14:37:57 <shachaf> What does that have to do with monads?
14:38:09 <dmj> jmcarthur: ^
14:38:14 <timthelion> johnw: well what is the difference between "foldl" and the run function that comes packaged with your favorite monad? Not much
14:38:16 <johnw> shachaf: to which point is that question addressed?
14:38:23 <jmcarthur> dmj: if by "issue" you mean will it be not in place, then yeah
14:38:25 <shachaf> Any of them.
14:38:36 <timthelion> johnw: though perhaps folds are just fancy monads ;)
14:38:41 <jmcarthur> dmj: if by issue you mean takes superlinear space then not at all
14:38:45 <johnw> timthelion: try implementing the behavior of the list monad using foldl
14:39:18 <johnw> dinner time, bbiab
14:41:34 <rsebasti_> Hey, I'm trying to download haskell platform from here: http://www.haskell.org/platform/mac.html and it's being really slow (10 kbps). Anyone know of a mirror? Or where I should be asking this?
14:42:34 <shachaf> rsebasti_: I'm getting ~500k -- are you sure it's the server?
14:43:19 <saep> Using TOR? :P
14:43:24 <rsebasti_> shachaf: Seems like it. Other stuff else downloads zippily.
14:43:56 <rsebasti_> saep: My first thought exactly :)
14:44:54 <otters> has anbody been able to use cabal-dev with .hsc files?
14:52:46 <copamp> whats the best channel on irc to talk realtime OSes?
14:54:27 <Hermit> copamp: how about you /list and search?
14:54:50 <timthelion> what is a realtime OS? Are you refering to something like the early DOS systems which ran processes in realtime? Or microcontroller libs?
14:58:29 <timthelion> What can I use to get lines of input from the user within ghci? getLine is uneditable(no backspace) readline requires ncurses which doesn't work under ghci(due to some linker bugs). haskeline has it's own monad, which would require me to cludge everything together with a transformer :/
14:58:39 * hackagebot caledon 3.2.0.0 - a logic programming language based on the calculus of constructions  http://hackage.haskell.org/package/caledon-3.2.0.0 (MatthewMirman)
14:59:51 <otters> so you can't pattern match on constructors themselves
14:59:53 <typoclass> timthelion: the realtime stuff is a niche segment for use in industry/flight/satellites/and so on. it has to do with giving guarantees like "no matter what else is going on in the system, it will do this and that check at least every 300 ms". this means that e.g. regular ethernet can't be used, since it gets slower as more clients try to talk. similarly, you'd have to heavily modify a normal linux, etc.
14:59:54 <hiptobecubic> timthelion, why do you want to do it in ghci?
15:00:17 <timthelion> hiptobecubic: because I am using ghci as my shell now :) it's great fun :D
15:00:31 <hiptobecubic> sounds miserable :)
15:01:00 <timthelion> hiptobecubic: not really
15:01:16 <timthelion> hiptobecubic: but I've come across some bugs in ghci
15:01:41 <Hermit> timthelion: how about you  do (_,Just out,_,_) <- createProcess (proc "cat" []) {std_out = CreatePipe}; line <- fmap (head . lines) . hGetContents out
15:01:53 <timthelion> Hermit: I like you.
15:02:11 <copamp> timthelion: the latter. microcontroller realtime operating systems.
15:02:12 <aCube> timthelion: You could also use :! to run processes?
15:02:13 <Hermit> \o/
15:02:33 <timthelion> Hermit: that seems like it might work!
15:02:36 <Hermit> timthelion: note I missed a $ between hGetContents and out
15:02:47 <timthelion> Hermit: that's fine :)
15:02:51 * Hermit wrote it in the irc imput line
15:03:27 <Hermit> oh, but there's a problem
15:03:38 <Hermit> cat will terminate on eof
15:03:50 <Hermit> so you should manually terminate it after reading the first line
15:04:53 <Nawmad> somebody took my other nick Nomad :(. Anyways... took a look at `simple programming problems` and I can't do any of them in haskell O_o.
15:04:58 <Nawmad> so discouraging
15:05:03 <timthelion> Hermit: I could just make a custom util that uses readline and then launch that with createProcess
15:05:21 <Hermit> timthelion: that should do the trick too
15:07:30 <copamp> how do I use the list command? does it just search channel names?
15:08:15 <copamp> Nawmad: i understand you, had the same issue when starting out. it gets a lot better and then it is worth it
15:09:06 <Nawmad> ugh
15:09:22 <prinnysocks> haskell has a super steep learning curve
15:09:30 <typoclass> copamp: the /list command depends on your client. it could even be useless because it's so many channels. but there's a bot "Alis" which you can talk to
15:10:13 <otters> okay so I need to interface with C and have datatypes mapped to string keys
15:10:19 <otters> both for writing and reading options
15:10:30 <otters> right now i have data Option = SomeOption ByteString | ...
15:10:35 <otters> which works alright, but for reading, it's lousy
15:10:53 <otters> because you can't pattern match on "SomeOption" itself
15:11:42 <latro`a> er, why exactly is that a problem?
15:11:54 <otters> i want to figure out the easiest way
15:12:01 <latro`a> f (SomeOption _) = ...
15:12:06 <latro`a> seems to do what you are suggesting
15:12:11 <otters> right
15:12:14 <otters> "f" being getOPtion
15:12:18 <otters> *getOption
15:12:25 <otters> but then what do you pass to it? f (SomeOption undefined)?
15:12:36 <latro`a> sure
15:12:41 <otters> that's weird
15:12:50 <typoclass> Nawmad: don't despair. which problem is the first on the list?
15:14:15 <Nawmad> sec
15:14:26 <Hermit> timthelion: just tried it out, seems to do the job:  do (_,Just out,_,ph) <- createProcess (proc "cat" []) {std_out = CreatePipe}; hSetBuffering out LineBuffering; line <- fmap (head . lines) . hGetContents $ out; return line
15:14:27 <latro`a> but wait, why do you have the ByteString argument at all then
15:14:27 <Nawmad> http://users.csc.calpoly.edu/~jdalbey/103/Projects/ProgrammingPractice.html
15:14:28 <Nawmad> :|
15:14:43 <otters> latro`a: to set the option
15:14:50 <otters> setOption (SomeOption "foo")
15:14:54 <Hermit> timthelion: oh, forgot to remove the ph binding. It's not necessary at all
15:14:58 <latro`a> uhh...
15:15:20 <latro`a> should the getter and setter take the same sort of argument?
15:15:37 <timthelion> Hermit: perhaps with setting line buffering I could get the same behavior with just getLine
15:15:56 <Hermit> timthelion: well, the line binding is not needed either but left it there because I was editing making cat finish prematurely
15:16:10 <otters> latro`a: that's how lenses work
15:16:12 <Hermit> timthelion: maybe, it's worth a try
15:16:14 <hpaste> aCube annotated “Loops with 7.4, doesn't with 7.6 - Can probably be simplified still” with “Now really the same, does not loop” at http://hpaste.org/84572#a84578
15:17:05 <aCube> Anyone got an idea on that paste? #1 loops, the rest doesn't (also only with 7.4)
15:17:08 <Hermit> timthelion: hSetBuffering stdin LineBuffering >> getLine
15:17:32 <timthelion> That's a bad idea in ghci ;)
15:17:52 <timthelion> now I cannot see what I type ;)
15:17:57 <Hermit> timthelion: you can set it back to NoBuffering
15:18:22 <timthelion> :r is easier
15:18:29 <typoclass> Nawmad: huh, that's quite elaborate. i have no idea why they labeled that "easy". it's taking me minutes to figure out what they're even asking. (i was expecting something like 'write a program that prints "ohai doods" to the console')
15:18:32 <Hermit> nice one
15:18:43 <Nawmad> yeah >.>
15:18:47 <prinnysocks> is haskell a good choice for learning real functional programming?
15:18:53 <Hermit> prinnysocks: you bet!
15:18:57 <Nawmad> But i dont even know how to make a 2d array to begin with
15:19:06 <Nawmad> let alone double index it
15:19:31 <Nawmad> then id probably need to do recursive transversal while doing Input
15:19:33 <Nawmad> :|
15:20:19 <Nawmad> at least not dynamically
15:20:37 <timthelion> Hermit:  do { hSetBuffering stdin LineBuffering ; l<- getLine ; hSetBuffering stdin NoBuffering ; return l} -- Works
15:20:53 <Hermit> good :-)
15:21:31 <Nawmad> I like avoiding do just to make the program flow explicit :)
15:21:44 <Nawmad> lets me use >>= more often
15:21:56 <Nawmad> which reminds me that im coding in haskell
15:22:26 <Hermit> I used to stick strictly to >>=, until I found out about do's per-monad match fail behaviour
15:22:33 <Hermit> that's what redeemed do for me
15:22:57 <timthelion> Hermit: I think "do rec" should make do seem even cooler.
15:23:03 <Nawmad> not sure what you mean by per-monad match :\
15:23:15 <latro`a> do notation will call fail on pattern match failure
15:23:15 <Hermit> I said match fail
15:23:35 <latro`a> which is nice in Maybe and [] and useless elsewhere afaik
15:23:35 <Hermit> @src Monad  -- Nawmad
15:23:35 <lambdabot> Source not found. It can only be attributed to human error.
15:24:01 <prinnysocks> annot satisfy -package haskell98 -hide-package base
15:24:10 <Hermit> Nawmad: ok, browse _all_ Monad's methods
15:24:46 <latro`a> > Just [] >>= \(x:xs) -> Just x
15:24:48 <lambdabot>   *Exception: <interactive>:3:13-29: Non-exhaustive patterns in lambda
15:24:59 <latro`a> > do (x:xs) <- Just []; Just x
15:25:01 <lambdabot>   Nothing
15:25:07 <prinnysocks> what does this mean?
15:25:13 <Hermit> Nawmad: what latro`a just exemplified
15:25:14 <prinnysocks> cannot satisfy -package haskell98 -hide-package base
15:25:20 <typoclass> Nawmad: here's an alternative list of problems you could check out http://www.haskell.org/haskellwiki/99_questions/1_to_10 if you want to do the ones from your link, i'd say #1 starts with figuring out how you can turn 34 into 3 and 4. the second step could be to get the nested list and the indexing right
15:25:29 <Hermit> latro`a: geez, I was going to get to that point soon, you killed the suspense
15:25:37 <latro`a> sorry :p
15:25:38 <Nawmad> thanks
15:26:34 <Hermit> it's like you tell the ending of a film when it's just starting
15:28:37 <byorgey> prinnysocks: what are you trying to build?
15:30:03 <prinnysocks> byorgey: was trying to do haskell koans but i decided to just do this 99 problems instead
15:30:54 <byorgey> prinnysocks: I mean, where did you see the error "cannot satisfy -package haskell98 -hide-package base" ?
15:31:48 <prinnysocks> byorgey: trying to run their setup script for the haskell koans
15:32:38 <byorgey> ah
15:38:40 * hackagebot confsolve 0.3.4 - A command line tool for resolving conflicts of file synchronizers.  http://hackage.haskell.org/package/confsolve-0.3.4 (DanielTrstenjak)
15:38:42 * hackagebot confsolve 0.3.5 - A command line tool for resolving conflicts of file synchronizers.  http://hackage.haskell.org/package/confsolve-0.3.5 (DanielTrstenjak)
15:38:44 * hackagebot pipes-safe 1.1.0 - Safety for the pipes ecosystem  http://hackage.haskell.org/package/pipes-safe-1.1.0 (GabrielGonzalez)
15:38:46 * hackagebot confsolve 0.3.6 - A command line tool for resolving conflicts of file synchronizers.  http://hackage.haskell.org/package/confsolve-0.3.6 (DanielTrstenjak)
15:41:00 <Nawmad> is it possible to simulate a state machine in haskell?
15:41:22 <Nawmad> or is there any alternatives
15:41:39 <Nawmad> eg, a text based menu
15:41:54 <byorgey> sure, you can simulate a state machine in Haskell
15:41:56 <Hermit> that's a job for the state monad
15:42:09 <byorgey> I don't understand what text based menus have to do with state machines
15:42:28 <Nawmad> text based menus change the way they work depending on "mode" they're in
15:42:44 <prinnysocks> it's just a tree right
15:42:49 <Nawmad> yeah
15:42:59 <Hermit> Nawmad: rule of thumb: need to keep state? need to simulate global vars? then it's the state monad
15:43:34 <Nawmad> so you wrap info on it recursively?
15:43:40 <Hermit> yup
15:43:51 <Hermit> you recurse on every event, and update the state
15:43:54 <Hermit> simple as that
15:44:10 <Nawmad> its just so hard to reason about it, especially since I do input on each event
15:44:14 <Nawmad> and that input might be invalid
15:44:33 <Hermit> then it's a job for the state transformer
15:44:51 <Nawmad> >.>
15:44:53 <Hermit> you could go about doing State s Maybe a
15:44:57 <Hermit> err
15:45:01 <Hermit> StateT s Maybe a
15:45:44 <Nawmad> ugh... i guess i need to read more before the idea makes any sense
15:45:47 <Hermit> so, when the input is wrong, you just lift Nothing
15:46:08 <Nawmad> yeah but im still trying to understand lifting
15:46:10 <Nawmad> :|
15:46:29 <AfC> Nawmad: keep at it :)
15:46:35 <Nawmad> :P
15:47:18 <Nawmad> I barely understood the idea of Monad's return and bind methods... and my way of understanding it is pretty fragile and probably wrong
15:48:34 <byorgey> Nawmad: don't try to understand "the idea", just try to understand their types
15:48:38 <monoidal> Nawmad: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
15:48:40 <hiptobecubic> Nawmad, there's no magic. They are just what the definitions say and that's really it
15:48:43 <byorgey> and work through lots of examples
15:48:51 <Nawmad> yeah but its tricky to understand the definitions
15:48:52 <typoclass> Nawmad: don't worry, keep writing code or trying to write code. the understanding will come.
15:49:06 <Nawmad> I even got "Categories for the working mathematician 2nd edition" and everything
15:49:10 <Hermit> well, to me the idea is more important than the multi-dimensional type tetris
15:49:11 <Nawmad> >.>
15:49:26 <byorgey> Nawmad: oh, I'm sorry =(
15:49:26 <hiptobecubic> Nawmad, that's not unique to monads. But like byorgey says, just practice using them and eventually it will just be something you're used to using
15:49:44 <hiptobecubic> Nawmad, are you a working mathematician?
15:49:53 <byorgey> Nawmad: that book should really be titled "categories for geniuses", it is extremely dense and really only useful as a reference once you understand category theory
15:49:53 <Nawmad> yeah but i am more of a person that "if i can't explain it, I don't feel comfortable using it"
15:50:06 <Nawmad> because programming is mostly about explaining wtf ur doing, rather than doing
15:50:17 <byorgey> sounds wise
15:50:19 <Nawmad> unless ur working alone, in which case u also confuse urself
15:50:27 <KayleL> Hello everybody.
15:50:32 <byorgey> hi KayleL
15:50:34 <typoclass> Nawmad: heh, that's a good ground rule in fact
15:51:07 <hiptobecubic> I'd like to get a copy of http://www.amazon.com/Conceptual-Mathematics-First-Introduction-Categories/dp/052171916X, but it's not in my budget yet
15:51:10 <Hermit> Nawmad: regarding your line about fragile monad understanding: I'm sure we all were there at some point, just don't give up. It took me 3 days for monad transformers to crystalize, yeah, 3 fucking days struggling trying to understand it. Everyone has a different time though. Don't loose hope!
15:51:24 <Ondra> Hello, please how can I make something like this to work? I'm preparing a QuickCheck test. The error is Haskell doesn't see the equality between Sample and Double.
15:51:34 <hpaste> Ondra pasted “Trouble” at http://hpaste.org/84579
15:51:41 <prinnysocks> is functional programming vastly more effective than other types of programming
15:51:53 <prinnysocks> does the steep learning curve justify itself?
15:52:01 <mauke> prinnysocks: what steep learning curve?
15:52:07 <KayleL> Prinnysocks: Depends on what you are doing.
15:52:14 <byorgey> Ondra: choose will return a Double, but you need a value of type SampleTest
15:52:33 <Nawmad> its always worth understanding complex concepts, it helps you understand when other people are bullshitting to you, and helps tell people who know what they're doing from people who don't
15:52:39 <prinnysocks> mauke well contrast having to learn monads to do state with just having state made easily available
15:52:44 <Hermit> Nawmad: of course, I figured out the type tetris in a couple of minutes, but it took me 3 days for the idea to crystallize and become clear
15:52:51 <byorgey> Ondra: you need to add a SampleTest constructor, like this:  arbitrary = SampleTest `fmap` choose (-1.0,1.0)
15:52:58 <mauke> prinnysocks: you don't need to "learn monads" to use state. you can just use state
15:53:07 <mauke> prinnysocks: and mutable variables have a steep learning curve
15:53:09 <Ondra> byorgey: thank you, I will try!
15:53:23 <hiptobecubic> prinnysocks, the learning curve isn't any steeper than trying to figure out how the hell to program anything else. Maybe you just don't remember what it was like when you first started programming.
15:53:36 <prinnysocks> mauke everything i've heard about haskell suggests that you need monads for state
15:53:39 <prinnysocks> i don't know much about it though
15:53:48 <mauke> prinnysocks: you've heard wrong
15:53:51 <Nawmad> I find learning haskell helps me learn mathematics at the same time :)
15:53:58 <Nawmad> or at least be more comfortable with them
15:54:04 <hiptobecubic> prinnysocks, also, the point of the state monad is to make the state easily available throughout a computation. you have it backwards.
15:54:04 <mauke> prinnysocks: how would that even work? do you know what monads are?
15:54:05 <johnw> you can use "state" in just plain recursion
15:54:07 <typoclass> Nawmad: about the math and category theory issue, i'm going to make myself unpopular again and say that in my view it's all a bit overrated. i really don't think that books on category theory will help anyone become a better haskell programmer
15:54:24 <elliott> prinnysocks: it will be a lot easier to make judgements if you learn about the things you wish to make judgements about.
15:54:31 <Hermit> typoclass: I second that. It's useless
15:54:33 <prinnysocks> elliott: i'm not making judgements about anything
15:54:37 <prinnysocks> i'm askign questions
15:54:41 <KayleL> I remember it took me a long time to understand what 'everything is an object' truely ment. It didn't help that I had a bad teacher.
15:54:44 * elliott was using "judgement" in a neutral sense
15:54:45 <Nawmad> it probably wont, but if you're already in computer science, its worth understanding distinction between sets and categories
15:54:57 <Nawmad> and at least understand the ideas behind monoids/monads
15:54:58 <johnw> typoclass: it will help you know what edwardk's packages even do :)
15:55:20 <Nawmad> I find category theory interesting :|
15:55:24 <Nawmad> a tad confusing though
15:55:28 <croikle> the state monad is mostly shorthand for passing your state along in arguments
15:55:29 <hiptobecubic> typoclass, certainly not *anyone*. Most of us are not in any position to leverage that kind of generality. As johnw mentioned, there are clearly some who benefit quite a lot from it :)
15:55:45 <typoclass> Nawmad: ok, if it's a separate interest of yours, then fair enough
15:56:17 <johnw> yes, like a profunctor can be a profoundly useful concept -- see its impact on the lens library -- and without CT, it will be very hard to really grasp what a profunctor is (in the abstract)
15:56:42 <johnw> howbeit, using the profunctor instance for (->) requires no CT and is still useful on its own
15:56:48 <Nawmad> idk, category theory is interesting but its so difficult to wrap mind around... eg, category of categories vs set of all sets... etc
15:56:59 <shachaf> johnw: You can grasp what a profunctor is as useful for lens without knowing anything about category theory.
15:56:59 <edwardk> Yes, I find it totally useless that category theory points me directly at the best abstraction that I could use for so many purposes. I want the joy of discovery! I want to return to being blissfully unaware that someone solved my problems 55 years ago, and that all I have to do is know how to read it off in the right sense to get back to working on the parts of my problem that are novel.
15:57:04 <johnw> it's a question of at what level you want to fathom the abstractions underlying Haskell
15:57:16 <elliott> johnw: fwiw, I have no idea about profunctors from a categorial perspective (presheaf categories and stuff) and I added profunctor-based isomorphisms to lens :P
15:57:27 <elliott> I find them much easier to think of as "contravariant in first arg, covariant in second"
15:58:08 <Nawmad> just because the problems appear to be solved, does not mean that people will be able to understand what the hell the crazy people mean by those solutions when the authors of those books are dead
15:58:27 <hiptobecubic> Nawmad, that's why you might want to study CT, was the point.
15:58:33 <Nawmad> its not books who carry information, but people
15:58:39 <hiptobecubic> Without knowing anything about CT then sure, it's pretty opaque
15:58:57 <johnw> you can use Monads without understanding monads.  You can understand monads without understanding adjoint functors.  But if you get adjoint functors, a few others things will become crystal clear in ways that may never happen without going that deep.
15:58:59 <johnw> this is why I advocate CT, but I don't insist on it
15:59:17 <Nawmad> meh, i find studying new things helps me think of things in different ways, which tends to increase my productivity in the long run
15:59:30 <Nawmad> rather than bashing head against problem with one hammer
15:59:37 <hiptobecubic> I find that it usually decreases my productivity, but increases my interest
15:59:46 <Nawmad> in short term thats the case
15:59:55 <johnw> did what I say get missed?
15:59:57 <hiptobecubic> the short term is apparently quite long
15:59:59 <johnw> my client cycled
16:00:02 <edwardk> Nawmad: I think the original ideas of category theory have been instilled pretty effectively in the next generation of mathematicians beyond Mac Lane. It is exploding fast enough to keep ahead of the death curve =P
16:00:15 <johnw> did anyone see what I said about profunctor?
16:00:20 <hiptobecubic> johnw, yes
16:00:23 <johnw> ok
16:00:33 <hiptobecubic> johnw, "... insist on it"
16:00:40 <johnw> great, thank you
16:00:50 <Nawmad> I still feel not many people even know that category theory is different from set theory lol
16:00:56 <johnw> edwardk has helped me appreciate the value of learning "the language behind the language"
16:00:57 <sproingie> so what is an adjoint functor anyway?
16:01:10 <johnw> sproingie: imagine you have two functors
16:01:14 <hiptobecubic> sproingie, it's like a regular function, but with joints added
16:01:17 <hiptobecubic> functor*
16:01:21 <johnw> F goes from some category C -> D, and G goes from D back to C
16:01:29 <johnw> there are three different ways in which F and G could be related
16:01:37 <Nawmad> is f in f: R -> R a functor?
16:01:44 <Nawmad> and the arrow is function?
16:02:05 <johnw> 1. there is no relationship at all.  mapping an X from C->D gives you F(X), and mapping from D->C with G gives you G(F(X)), but X and G(F(X)) are unrelatedt
16:02:24 <johnw> 2. they are isomorphic.  This is easy, and means that X and G(F(X)) are the same object
16:02:42 <johnw> 3. they are adjoint.  This means that X and G(F(X)) are not the same object, but they are related in a special way
16:03:55 <Nawmad> i once used to believe smart people do not exist, johnw made me a believer
16:04:06 <shachaf> johnw: Is this 1/2/3 thing actually a thing?
16:04:09 <johnw> that special way means that after you map any X to G(F(X)), you can make any G(F(G(F(X)))) back to G(F(X)).  It's like adding context to X, and this context can be mutated by further "round trips" from C to D
16:04:13 <johnw> shachaf: no, it isn't
16:04:16 <edwardk> shachaf: sadly, no
16:04:21 <shachaf> I suppose you haven't defined "related" so it's impossible to argue with it.
16:04:24 <typoclass> edwardk: i have my doubts if the years (decades) of studying math are really so quick and easy, "pointing you directly at the best abstraction" and so on
16:04:27 <hiptobecubic> special way meaning? There is some H such that H(G(F(X)) = X ? or H(X) = G(F(X)) or something?
16:04:34 <johnw> Nawmad: do you mean I convinced you that smart people don't exist? :)
16:05:10 <johnw> hiptobecubic: meaning that G and F have a relationship such that GFGF = GF
16:05:14 <johnw> ≅
16:05:16 <Nawmad> johnw: No, but most of the time smart people can say stuff that makes no sense to anyone else, you actually make sense lol
16:05:21 <sproingie> johnw: i sort of see the similarity to monads there
16:05:25 <Hermit> johnw: isn't that analogous to join?
16:05:26 <sproingie> sort of :)
16:05:31 <johnw> Hermit: it is exactly join :)
16:05:38 <Hermit> I _knew_ it
16:05:41 <johnw> and mapping X to G(F(X)) is exactly return
16:05:43 <johnw> enter the Monad
16:05:52 <johnw> now call it M instead of GF and you're golden
16:05:59 <hiptobecubic> GFGF is join?
16:06:00 <mauke> MM
16:06:06 <hiptobecubic> that doesn't make sense
16:06:10 <Nawmad> I'm still learning making sense. In fact I even have a book called "Making sense". Yet I still make no sense.
16:06:10 <johnw> GFGF -> GF is join
16:06:11 <Hermit> D:
16:06:13 <mauke> MM -> M
16:06:18 <hiptobecubic> johnw, oh. yes ok
16:06:19 <Nawmad> shachaf can confirm that
16:06:20 <edwardk> typoclass: i find the alternative, mindlessly ignoring all the work that has come before that can tell you when _no solution can exist_ so you can stop thinking about a problem, to be a much bigger risk.
16:06:31 <Hermit> johnw: That was really nice to follow :D
16:06:36 <johnw> Hermit: thanks
16:07:07 <johnw> edwardk: am I completely off the mark with my 1/2/3 delineation?
16:07:14 <hiptobecubic> Does join get a nice capital letter like the rest of these ?
16:07:23 <skp> night
16:07:26 <johnw> join is μ
16:07:32 <johnw> is that what you mean?
16:07:39 <hiptobecubic> Good enough
16:07:49 <johnw> and return is η
16:07:54 <hiptobecubic> so µ : GFGF -> GF?
16:07:57 <johnw> yes
16:08:08 <edwardk> typoclass: I personally spent about 10 years of my life slaving away on toy compilers, etc. for a language I now know can't really exist, because I thought I knew enough that I didn't need to go get some college to rubber stamp my education. Little did I know how much I didn't know. When I went back and collected all this useless math (and rounded out the bits of computer science i was weak on), it made a huge difference in where
16:08:09 <edwardk>  I chose to apply my efforts going forward.
16:08:37 <hiptobecubic> edwardk, which language is this?
16:08:44 <edwardk> So from a sunk cost perspective I've been there, done that and never want to do it again.
16:09:41 <niteria> what's the most gentle way to learn about adjoints?
16:09:48 <edwardk> hiptobecubic: I had a few projects mostly centered around building large bodies of provably correct code and some very naive assumptions about the halting problem, etc. Not enough that it crippled me, but enough that at least one of my little long term toy projects was laughable to someone who had the proper background.
16:09:50 <Hermit> edwardk: so you wanted to make your own language, until you found out (after learning a lot more things) how crappy it would have been
16:09:51 <hiptobecubic> niteria, scroll up
16:10:04 <niteria> hiptobecubic: I've read that
16:10:12 <Hermit> or did I get it wrong?
16:10:14 <niteria> but I need examples
16:10:22 <edwardk> Hermit: I still play with toy language designs and odd formalisms, etc. but I try to do so in a setting where I at least know what has come before.
16:10:30 <johnw> niteria: ask Cale in ##categorytheory to draw diagrams for you on his Web drawing board :)
16:11:03 <KayleL> Wow, the ghci error message is so weird. It's real English; I am not use to that.
16:11:41 <hiptobecubic> KayleL, well... the *words* are English words
16:11:44 <koninkje> niteria: For a gentle intro, you may want to check out what Wikipedia says about Galois connections
16:11:46 <Nawmad> beats C++'s STL error which is 100 pages and really means "hey, you forgot to include <string>, amrite?"
16:11:53 <hiptobecubic> Whether or not most people would count it as English is up for debate
16:12:16 <tac> edwardk: what kind of assumption would you call naive?
16:12:22 <koninkje> niteria: Galois are examples of adjoints, namely for when the categories are just posets
16:12:24 <edwardk> typoclass: I'm so focused on doing things nice formal ways precisely because I spent so long just hacking out crap I couldn't reuse, or didn't know had already been superceded decades before.
16:12:43 <hiptobecubic> Nawmad, indeed. I don't know who thought the way C++ handles errors in template functions was a good idea
16:13:32 <KayleL> It's more English-like compare to Ruby or Java.
16:13:35 <Nawmad> aww i think they fixed the error :|
16:14:02 <niteria> what would be an example of adjoint in category of groups?
16:14:44 <Cale> niteria: Say, the group ring construction?
16:14:47 <koninkje> niteria: adjoints are ways of relating two categories (which are, on general, differnt categories)
16:15:05 <edwardk> tac: Language design by implementation rather than having even a rough idea of the semantics. In my case, I spent a lot of time reasoning with weakest preconditions and Hoare triples/separation logic, because I just didn't know about how effective the techniques from functional programming can be, so I went off and wasted a lot of time on tools I never want to look at again. It depends on how far you go back. Heck even the me of
16:15:05 <edwardk>  6 months ago seems to me like he held all sorts of strange ideas, because in the meantime I've found so many better ways to work.
16:15:26 <niteria> so we have a forgetful functor that goes from groups to sets
16:15:28 <Cale> niteria: Where you have a right adjoint Group -> Ring which sends a group G to the group ring Z[G], and its left adjoint takes the group of units.
16:15:34 <tac> edwardk: ah I gotcha
16:15:47 <niteria> I'm particularly interested in forgetful functors
16:15:49 <Cale> er, sorry, wrong way
16:15:58 <Nawmad> i think c++ fixed their STL monstrous error messages... i am sad now =[
16:16:02 <Cale> Group -> Ring is the left adjoint there :P
16:16:16 <hiptobecubic> Nawmad, well the tradition is alive and well in boost and thrust
16:16:22 <Cale> niteria: Sure, there's the free group construction
16:16:38 <Nawmad> ill have to try those :|
16:16:59 <Cale> F: Set -> Group, and G: Group -> Set
16:17:01 <Hermit> edwardk: where could I take a peek at those better ways to work?
16:17:11 <sproingie> C++ still gives you the joy of whole classes of errors not showing up til link time
16:17:23 <sproingie> then spewing mangled symbols out at you that it can't find
16:17:24 <Cale> where F forms the free group on a set, and G takes the underlying set of a group
16:17:29 <hiptobecubic> sproingie, yes :)
16:17:31 <edwardk> Hermit: lens, bound, trifecta, http://github.com/ekmett   http://github.com/analytics
16:17:39 <Nawmad> woot
16:17:41 <Nawmad> i reproduced it
16:17:43 <niteria> Cale: would the same work for algebras?
16:17:46 <Cale> sure
16:17:47 <shachaf> edwardk: Between you and me, I couldn't stand the edwardk of six months ago. Seriously, that guy didn't have a clue.
16:17:53 <Hermit> edwardk: yeah, I'm on my way with lens, just starting though
16:18:00 <hiptobecubic> Hermit, buckle your seatbelt
16:18:09 <edwardk> shachaf: glad we agree =)
16:18:11 <Hermit> I'm on it!
16:18:15 <Cale> Also, Abelianisation
16:18:37 <edwardk> shachaf: can you believe he thought 'Projection' was a good idea?
16:18:37 <shachaf> edwardk: At least he was OK compared to shachaf-of-today, though.
16:18:47 <Cale> You have the forgetful functor from Abelian groups to plain ol groups
16:19:03 <hiptobecubic> What's wrong with projection :?
16:19:14 <Nawmad> http://hastebin.com/cunupugowi.tex awesome, I still got something to put on birthday cards.
16:19:19 <Nawmad> :-)
16:19:27 <Cale> and its left adjoint forms a quotient which forces any given group to be commutative
16:19:47 <Cale> i.e. G/[G,G] where [G,G] is the commutator
16:20:04 <shachaf> hiptobecubic: Projections are fine. http://hackage.haskell.org/packages/archive/lens/3.0/doc/html/Control-Lens-Projection.html is kind of awful.
16:20:04 <Nawmad> all that error means is "please override the ostream operator for mya class"
16:20:22 <Nawmad> "a class*"
16:20:44 <hiptobecubic> Nawmad, aha.
16:20:48 <hiptobecubic> Nawmad, yes of course.
16:20:50 <niteria> Cale: what if we take algebras with some equations?
16:20:56 <otters> right now the way I'm doing type synonyms for FFI objects in this library is
16:21:05 <otters> type SomeUserFacingType = ForeignPtr ()
16:21:11 <Hermit> edwardk: so, how long have you been messing with FP?
16:21:11 <niteria> will there be an adjoint for a forgetful functor?
16:21:12 <otters> and type CSomeUserFacingType = Ptr ()
16:21:15 <Cale> niteria: yep, there's a free/forgetful adjoint for every one of those.
16:21:17 <otters> is there a better haskelly way to do this
16:21:18 <edwardk> Hermit: Since 2006
16:21:31 <Hermit> I see
16:21:36 <Hermit> well, I'm at 4 months now
16:21:37 <Cale> niteria: But only if the laws are equational.
16:21:41 <Nawmad> hiptobecubic: isn't it beautiful :), if i give that to a girl, her eyes will water, the wording of the poetry is ... not of this earth
16:21:43 <Cale> (in general)
16:21:47 <Hermit> please take good care of me :-)
16:22:02 <edwardk> Hermit: I became a born-again Haskeller then.
16:22:45 <edwardk> I popped in here and regaled Cale with a common rant about how Functor wasn't a functor, and then stayed because he was so damn nice about it as he set about correcting my understanding.
16:22:48 <hiptobecubic> Nawmad, I particularly like the verse where it enumerates all of the primitive types and possible qualifiers that aren't isomorphic to 'a'
16:23:16 <Cale> Haha, I think I remember that conversation, maybe :)
16:23:22 <Nawmad> hiptobecubic: that's my favorite verse too!
16:23:45 <johnw> Cale: i do believe we should have a log of it!
16:23:47 <elliott> edwardk: were you expecting a CT, C++ or ML functor? :P
16:23:49 <niteria> Cale: is there any place where I can learn how exactly that works? I'm not sure what happens with the equations
16:23:53 <johnw> "edwardk: The Early Years"
16:23:54 <edwardk> Cale: I'll have you know that conversation was pretty much the entire reason I took to lurking in here.
16:24:02 <Hermit> johnw: I'm interested
16:24:13 <edwardk> elliott: In the category theoretic sense. I found Haskell first through the existence of pugs.
16:24:20 <Cale> niteria: Basically they force a quotient to happen. You mean algebra in the sense of universal algebra, right?
16:24:26 <elliott> perl, well known for attracting category theorists
16:24:39 <Cale> niteria: Or do you mean in the sense of vector spaces which are also rings in a compatible way?
16:24:40 <edwardk> elliott: well, i was mining category theory at the time too.
16:24:46 <shachaf> Pugs, well known for getting people into Haskell.
16:25:06 <elliott> it's kind of a shame it's so awkward to express CT functors in haskell.
16:25:06 <niteria> Cale: no, I mean universal algebra
16:25:11 <Cale> okay
16:25:14 <mauke> pugs++ audreyt++
16:25:20 <edwardk> cale: so any time you see me in here rambling on about something you don't care about, remember its your own fault for being so nice. ;)
16:25:31 <Cale> edwardk: ahaha
16:25:49 <mauke> http://www.riddlydiddly.com/
16:25:49 <Cale> edwardk: I actually do care about most of the things you ramble about though.
16:25:58 <Nawmad> http://codegolf.stackexchange.com/questions/1956/generate-the-longest-error-message-in-c X D
16:26:01 <edwardk> Cale: then i guess that worked out =)
16:26:17 <Cale> niteria: Then yeah, you just take equivalence classes when going in the other direction
16:27:05 <Hermit> edwardk: have you checked out dependent type systems? (e.g.: idris)
16:27:06 <Cale> niteria: So you form the free algebra on that set with your operators, and then put an equivalence relation on it which identifies elements of that free algebra according to your equations.
16:27:19 <Nawmad> what im trying to say is... Haskell error messages are FAR more readable than C++ :|
16:27:55 <Cale> niteria: and then your left adjoint is going to construct an algebra whose elements are the equivalence classes of that relation
16:27:58 <edwardk> Hermit: yeah. i catapulted past haskell and went nuts about pure type systems and substructural logic and coq, agda, etc. before i settled back to haskell as being the point at which i could say the vast majority of what i wanted to say and still get stuff done
16:28:01 <mauke> s/Haskell/ghc/; s/C++/g++/
16:28:27 <hiptobecubic> mauke, true
16:28:38 <Cale> niteria: Does that make sense?
16:28:43 <Hermit> fair enough
16:29:11 <niteria> Cale: give me a second
16:29:15 <tsinnema> sproingie, johnw, niteria, Cale and others -- i had one way of looking at adjoints that seemed to make it clearer to me, but i am not entirely sure it's accurate
16:29:18 <typoclass> edwardk: i don't know, you seem to have jumped around a bit between CT pointing directly at the most elegant solution, math preventing you from wasting time with things that provably can't exist, and general knowledge of history being necessary. it makes slightly more sense now after you told the story with the compiler and body of provable code ...
16:29:30 <tsinnema> (me being a CT newbie for whom adjoints have been very difficult)
16:29:35 <typoclass> edwardk: anyway, i didn't mean that all history and math is useless, and we should all be monkeys with compilers. i meant that CT is overrated in the sense that i don't agree with the view "to learn haskell, you first need full command of 7000 complicated CT terms". that's all.
16:29:36 <edwardk> Hermit: i started from the perspective, "well, if a little bit of type theory is good, then a lot of it must be awesome!" but in the end i settled back to Haskell because I find the power to weight ratio isn't there. In Haskell the types let me actually write less code that is more expressive. Once you go to Agda, etc. you need to start writing more, you get less reuse and have to name all the proofs, etc.
16:29:39 <johnw> aha, foundi
16:29:40 <shachaf> mauke: "more readable than g++++ :|" ?
16:29:52 <johnw> edwardk's famous discussion with Cale on the meaning of Functor
16:29:57 <Cale> I was actually just helping someone with a problem in order theory the other day which is very relevant to the present discussion.
16:30:02 <johnw> 2006/07/30 at 13:31:50
16:30:20 <mauke> s/s\/C\+\+\/g\+\+\//s\/C\\+\\+\/g++\//
16:30:36 <Hermit> edwardk: yeah, it seemed like overkill to me after a couple of days fiddling with idris
16:30:40 <edwardk> typoclass: then if that is the straw man you are arguing with, i'd be the first to agree with you. that said, once you have learned haskell well enough to know how to call stuff, even a bit of category theoretic understanding goes a long way towards helping you reason about the code you write
16:30:51 <shachaf> mauke: thx
16:30:59 <shachaf> Much clearer now.
16:31:00 <mauke> yrwcm
16:31:32 <wto> @src scanr
16:31:33 <lambdabot> scanr _ q0 []     =  [q0]
16:31:33 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
16:31:33 <lambdabot>     where qs@(q:_) = scanr f q0 xs
16:31:34 <edwardk> johnw: that sounds about right
16:31:39 <Nawmad> im kinda curious, C appears to have started trying to do basic pattern matching with printf/scanf/similar, would it be possible to make a pre-preprocessor for C in Perl to do additional pattern matching?
16:31:54 <johnw> whereupon Cale said: 13:31:50 <Cale> edwardk: Every Haskell functor is a mathematical functor
16:32:24 <edwardk> and with that i was enlightened ;)
16:32:36 <johnw> i can't find a web link to this conversation, but one can download the text file
16:32:45 <Cale> Let A and B be complete lattices. Let f: A -> B and g: B -> A be order preserving functions such that for all a in A, a <= g f a and for all b in B, f g b <= b. Given that for all families {a_i : i in I} of elements of A, we have f inf {a_i : i in I} <= inf {f a_i : i in I}, show that for any indexed family {b_j : j in J} of elements of B, we have g inf {b_j : j in J} = inf {g b_j : j in J}.
16:32:52 <Nawmad> i still have trouble distinguishing functors from functions
16:33:15 <Cale> ^^ If you know about adjoints and category theory, this problem is much easier :)
16:33:52 <Cale> Or at the very least, much more interesting :)
16:34:04 <johnw> Nawmad: well, a functor is also a type function, but it's not a function on values
16:34:16 <tsinnema> the idea (possibly inaccurate?) being that 'right adjoint' might well be called 'source adjoint' and 'left adjoint' might well be called 'target adjoint', since, for example, if you have a right adjoint functor R from category C to D and its left adjoint L from D to C, then if you take some morphism f: X -> A in C (being the one from which R takes off), then the adjoints give you a way to manipulate the _source ends_ of the mor
16:34:16 <tsinnema> phisms in C like so: f: X -> A => LRf: LRX -> A
16:34:25 <Nawmad> so a functor is a higher order function?
16:34:31 <johnw> no
16:34:37 <johnw> it's a function at the type level
16:34:39 <johnw> like Maybe Int
16:34:52 <johnw> without the Int, you'd have Maybe, and that's what implements Functor
16:34:54 <Nawmad> so f: R -> R is a functor?
16:35:04 <johnw> no
16:35:08 <johnw> f would be a regular function
16:35:15 <mauke> Maybe :: * -> * is a functor
16:35:32 <Cale> Nawmad: In the context of Haskell, an instance of the Functor typeclass is a type constructor F together with a function  fmap :: (a -> b) -> (F a -> F b)
16:35:56 <Nawmad> yeah but i still dont understand fmaps, i barely understand maps and mapMs
16:36:03 <Cale> Nawmad: That is, it's a sort of abstract "container", for which we have a way to "apply a function to all the elements"
16:36:04 <johnw> Cale: I heartily agree with your parenthesizing :)
16:36:10 <mauke> Nawmad: there's only one map
16:36:20 <mauke> I'd start there
16:36:24 <johnw> Nawmad: think of fmap as a map that works for any Functor
16:36:26 <monoidal> Nawmad: map is for lists, fmap is a generalization
16:36:33 <johnw> that's one way to think about it
16:36:33 <Cale> Or a sort of abstract "computation" for which we have a way to "apply a function to the eventual result"
16:36:34 <monoidal> > fmap (+5) (Just 3)
16:36:36 <lambdabot>   Just 8
16:36:36 <tsinnema> Cale, and johnw, do you think my above suggestion is accurate? for me it has seemed helpful
16:36:41 <Nawmad> so fmaps arise in generics?
16:37:09 <mauke> what's a generics?
16:37:11 <niteria> Cale: where do we get equations from when we go from sets to algebras with equations?
16:37:19 <Cale> tsinnema: I don't understand your characterisation very well
16:37:29 <shachaf> mauke: I heard edwardk is an expert on those.
16:37:36 <tsinnema> hm
16:37:38 <johnw> tsinnema: I would think that LR(f) : LR(X) -> LR(A)
16:37:49 <Cale> niteria: The left adjoint is going to *force* whatever equations we want to hold.
16:37:49 <hiptobecubic> Nawmad, not here. In C++ land that is how they use the word.
16:38:06 <mauke> oh, parameterized types?
16:38:11 <Cale> niteria: I'm assuming you're choosing the equations up-front.
16:38:16 <mikeplus64> would a category-theory faithful functor in haskell be (a -> b) -> f a -> g b?
16:38:40 <Cale> niteria: in order to get a category of algebras whose homomorphisms have to respect the equations
16:38:48 <Nawmad> so whats an example of a functor?
16:38:55 <johnw> mikeplus64: how are you involving a second functor in the fmap?
16:39:02 <monochrom> [] and Maybe are both functors
16:39:03 <Iceland_jack> Nawmad: Lists
16:39:06 <mauke> Nawmad: [] and Maybe
16:39:06 <johnw> mikeplus64: the functor maps a and b from the source, into a and b in the target
16:39:07 <monoidal> mikeplus64: no, a functor F must map X -> Y to F(X) -> F(Y)
16:39:13 <mauke> Iceland_jack: "lists" is not a type, though
16:39:15 <johnw> so (a -> b) -> f a -> f b
16:39:24 <Nawmad> yeah but how is that different from a function >.>
16:39:35 <mauke> Nawmad: are you asking how [] is different from a function?
16:39:36 <Cale> Nawmad: The functor is the thing at the type level
16:39:39 <monoidal> mikeplus64: on the other hand, those F(X) and F(Y) might reside in a different category (in Haskell they're the same kind as X,Y which means all functors are endofunctors)
16:39:43 <mikeplus64> johnw: monoidal: i was under the impression all haskell functors were endofunctors by the wikipedia article on functors
16:39:48 <Cale> Nawmad: together with its implementation of fmap
16:39:59 <johnw> mikeplus64: they are, but that fact doesn't enter into your question
16:40:06 <Cale> Let's just write down the class definition to be clear
16:40:09 <hiptobecubic> mikeplus64, endofunctors on Hask, i guess. because everything in haskell is in Hask by definition i think
16:40:12 <monoidal> mikeplus64: indeed, but the solution is not making it (a -> b) -> f a -> g b
16:40:19 <Cale> class Functor f where fmap :: (a -> b) -> (f a -> f b)
16:40:33 <Cale> So, if I have some data type like:
16:40:33 <Nawmad> so functors are more for data structures, and functions are for... functions?
16:40:39 <hiptobecubic> Nawmad, no
16:40:42 <mauke> Nawmad: what?
16:40:45 <monoidal> mikeplus64: also you can make functors between different categories in haskell - only the Functor class supplied by default implements endofunctors on Hask
16:40:46 <hiptobecubic> Nawmad, go *up* a level
16:40:49 <Nawmad> im confused >.>
16:40:51 <monochrom> I think you're getting ahead of yourself
16:40:58 <Cale> Each functors will be some type of data structure
16:40:59 <johnw> mikeplus64: a functor from C to D might look like this: (C(a) -> C(b)) -> (F(C(a)) -> F(C(b))), where any F(C(x)) is the image of C(x) in D
16:41:01 <Cale> -s
16:41:05 <Iceland_jack> Nawmad: Of course you are, #haskell is bad at explaining this
16:41:11 <Cale> Let me explain
16:41:18 <Cale> Let's do an example
16:41:19 <Nawmad> ill take all the help i can get >.>
16:41:21 <mauke> Nawmad: do you understand Maybe? (forget about functors, classes, or anything else)
16:41:29 <Nawmad> I think I understand Maybe
16:41:29 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
16:41:37 * johnw is happy we are delving into functors
16:41:37 * lispy thinks we should give Cale a chance to go through his explanation
16:41:39 <Cale> Do you understand that data declaration?
16:41:50 <Nawmad> yeah, its a binary tree
16:41:50 <hiptobecubic> functor is a data structure that includes a way to map function over it, obeying some rules like fmap f . fmap g = fmap (f.g)
16:41:53 <Cale> For each type a, we get a type Tree a
16:42:11 <Cale> For example, there is a type Tree Integer, of trees whose branches hold integer values.
16:42:24 <johnw> hiptobecubic: a functor is not a data structure
16:42:38 <johnw> hiptobecubic: (->) e is a functor
16:42:45 <hiptobecubic> by data structure i'm, perhaps unfairly, implying that there's something "in it"
16:42:49 <Cale> e.g.  Branch 0 (Branch 1 Tip Tip) (Branch 2 (Branch 3 Tip Tip) (Branch 4 Tip Tip)) :: Tree Integer
16:42:49 <Nawmad> so Tree is a constructor
16:43:13 <Cale> e.g.  Branch "hello" (Branch "there" Tip Tip) (Branch "world" Tip Tip) :: Tree String
16:43:15 <Cale> Tree is a type constructor
16:43:21 <Cale> Branch and Tip are data constructors
16:43:33 <mauke> (Tree takes a type and constructs a new type from it)
16:43:44 <monochrom> Piaget's theory is powerful. concrete before abstract. look at examples first. don't write essays first.
16:43:46 <hiptobecubic> johnw, maybe Cale can defend that position better than I can. I was quoting him.
16:43:46 <lispy> the -> in a -> b is also a type constructor, BTW
16:43:47 <Nawmad> makes sense
16:43:58 <Nawmad> but how does this relate to functors :X
16:44:06 <Cale> Tree is going to be an example of a functor
16:44:06 <lispy> monochrom: Piaget?
16:44:13 <monochrom> Piaget
16:44:13 <mauke> Nawmad: Tree is (or rather can be made) a functor.
16:44:21 <Cale> and in order to make it into a functor, we need to supply a function of type
16:44:22 <typoclass> lispy: a dude who studied learning
16:44:25 <Cale> (a -> b) -> Tree a -> Tree b
16:44:43 <Cale> fmap :: (a -> b) -> Tree a -> Tree b
16:44:50 <Cale> satisfying the rules that:
16:44:53 <Cale> fmap id = id
16:44:54 <Cale> and
16:44:56 <Nawmad> so a functor can take anything, and wrap it as a functor?
16:44:59 <Cale> fmap (f . g) = fmap f . fmap g
16:45:03 <Nawmad> onto itself?
16:45:12 <mauke> "wrap it as a functor" is meaningless
16:45:28 <elliott> \
16:45:29 <Cale> A functor is a type-level function which takes a type and produces another type
16:45:30 <Nawmad> is Maybe a functor?
16:45:37 <Cale> yes, it happens to be
16:45:38 <niteria> @kind Maybe
16:45:39 <lambdabot> * -> *
16:45:40 <hiptobecubic> Maybe is a functor
16:45:59 <monoidal> note "Maybe" is a functor; "Maybe a" is not.
16:46:08 <Nawmad> so Functor :: A -> Functor A ?
16:46:20 <elliott> (or rather, it doesn't even make sense to ask the question of whether (Maybe a) is a functor; it is a kind error)
16:46:21 <mauke> Nawmad: no, you're confusing levels there
16:46:35 <Cale> In order to be a functor, the type-level function F needs to come along with a value level function fmap which acts on functions a -> b, converting them into functions F a -> F b
16:46:37 <mauke> Nawmad: a functor takes a type and returns a type; this is written * -> *
16:47:01 <Cale> So, for instance, can you think of a natural way to convert a function a -> b into a function Maybe a -> Maybe b?
16:47:13 <mauke> we're talking about the "types of types" here, also known as "kinds"
16:47:15 <Cale> If you can, then you'll have turned Maybe into a functor
16:47:20 <typoclass> monochrom: how about this theory? "concrete before abstract; monads before concrete; first of all you check on wikipedia what on earth a monad is, second of all you give up completely"
16:47:22 <Nawmad> so the magic of functors is that they can wrap functors?
16:47:34 <Cale> Nawmad: I have no idea what you mean by "wrap"
16:47:37 <mauke> Nawmad: there is no magic
16:47:39 <hiptobecubic> typoclass, that's what *I* certainly did
16:47:43 <Cale> and yeah, there's no magic
16:48:01 <Cale> So, looking at Maybe:
16:48:06 <Cale> fmap f Nothing = Nothing
16:48:07 <hiptobecubic> typoclass, you forgot the endless chain of blog posts with bad analogies first thuogh
16:48:11 <Cale> fmap f (Just x) = Just (f x)
16:48:19 <Cale> This is a function
16:48:27 <Cale> fmap :: (a -> b) -> (Maybe a -> Maybe b)
16:48:31 <typoclass> hiptobecubic: hm yeah ... i was trying to be funny by exaggerating, but apparently reality has caught up with the exaggeration ...
16:48:41 <Cale> and it turns the type constructor Maybe into a functor
16:49:08 <Cale> Similarly, we can do this for our type of trees:
16:49:09 <hiptobecubic> typoclass, if I had *only* done what you said I'd have been better off
16:49:14 <Cale> fmap f Tip = Tip
16:49:27 <Nawmad> so if there exists a function that converts Maybe a to Maybe b, then Maybe must be a functor?
16:49:27 <Cale> fmap f (Branch x l r) = Branch (f x) (fmap f l) (fmap f r)
16:49:35 <hiptobecubic> typoclass, unfortunately I ended up on the wiki page for kliesli categories and then I blacked out
16:50:02 <Cale> Nawmad: If there exists a function which converts a function (a -> b) into a function (Maybe a -> Maybe b), satisfying a couple laws, then Maybe must be a functor
16:50:09 <mauke> Nawmad: ... a function that, given an a -> b, transforms Maybe a to Maybe b, in a way that satisfies the two laws Cale listed above
16:50:20 <Cale> The laws are that fmap id = id and that fmap (f . g) = fmap f . fmap g
16:50:30 <mauke> s/above/below/
16:50:33 <niteria> there's no need to understand monads, you can just learn about every monad instance
16:50:47 <johnw> hiptobecubic: want help with kleisli categories?
16:50:47 <hiptobecubic> you don't need every one at *all*
16:50:48 <Cale> or to write those another way, fmap id x = x and fmap f (fmap g x) = fmap (\v -> f (g v)) x
16:50:52 <hiptobecubic> you need like 4 and then bam
16:50:56 <Nawmad> two laws being associativity and identity?
16:51:22 <mauke> yeah
16:51:33 <Cale> Nawmad: Those aren't terrible names for them, though usually "respects identity" and "respects composition"
16:51:44 <hiptobecubic> Then you think to yourself. "Other than the fact that this compiles, these things are completely fucking unrelated.... oh"
16:51:49 <Cale> Time for dinner, bbiab
16:51:53 <mauke> oh right, it's not really associativity
16:52:05 <Nawmad> i wish i understood the distinction
16:52:05 <mauke> more like some kind of homomorphism
16:52:17 <mauke> associativity has 3 parts, not 2
16:52:29 <johnw> Nawmad: so, which part now is still unclear?
16:52:31 <mauke> it's like insects and spiders
16:52:34 <niteria> hiptobecubic: that's my approach with lens, as long as it compiles I don't need theory behind it
16:52:43 <Nawmad> a lot, still digesting
16:52:56 <johnw> Nawmad: I spent a few days chewing and googling, and then come back with more questions
16:53:01 <johnw> s/I spent/I'd spend
16:53:11 <hpaste> plhk pasted “Data.Binary, not enough bytes” at http://hpaste.org/84581
16:53:11 <hiptobecubic> niteria, I think that's the point of lens, honestly :)
16:53:12 <Nawmad> yeah, that's all i do nowadays, chew and google
16:53:17 <johnw> lol
16:53:28 <johnw> well, that still describes me too
16:53:45 <Nawmad> though at times there's nothing to chew :|
16:53:58 <hiptobecubic> niteria, I want to ___ all the ___ that satisfy ___ in ____ but i don't want to bork it."
16:53:59 <johnw> at least I've gotten my backlog of haskell blog articles down below a hundred
16:54:15 <typoclass> Nawmad: don't forget to write some haskell along the way. one- or two-line programs written are infinitely better than no code written
16:54:22 <mauke> another way to look at this from a very informal point of view: I know how map works on lists. there's an "obvious" generalization for all sorts of containers
16:54:34 <johnw> Nawmad: yes, what typoclass is absolutely correct
16:54:44 <mauke> e.g. you can write a 'map' for trees
16:54:53 <Nawmad> yeah, usually until i write code i don't really understand it. and i don't mean that if i write code i understand it, but it definitely helps show some value in what you learnt...
16:54:58 <mauke> and another one for Maybe because Maybe is just a list with at most 1 element
16:55:03 <johnw> and don't feel bad about the pain.  any pain you're feeling now is really setting you up for an enlightenment experience later, and that experience will change you forever
16:55:23 <plhk> can someone help me with that http://hpaste.org/84581 ? i'm absolutely sure there're enough bytes in the file (i'm using decodeFile)
16:55:26 <Nawmad> its okay i dont feel pain anymore, mild headache at all times, but i got used to it
16:55:31 <shachaf> And another one for ((Integer -> Bool) ->)!
16:55:42 <mauke> shachaf: that's step 2!
16:55:53 <mauke> that's where we twist our definition of "container"
16:56:20 <niteria> @hoogle hylo
16:56:20 <lambdabot> package hylolib
16:56:20 <lambdabot> package hylotab
16:56:20 <lambdabot> package DrHylo
16:56:27 <mauke> and view functions as dictionaries with a pre-applied lookup operation
16:56:53 <Nawmad> i got that from brian beckman
16:57:15 <shachaf> ((Integer -> Bool) ->) is uncountable, though.
16:57:23 <Nawmad> i wish brian beckman and SPJ made more youtube videos :(
16:57:57 <mauke> shachaf: don't worry, we have finite memory
16:58:10 <Nawmad> can you prove that mauke?
16:58:26 <mauke> yes
16:58:56 <mauke> the price of RAM is > 0
16:59:02 <Nawmad> im guessing nobody here is in Canada
16:59:05 <niteria> @hoogle Functor f => (f b -> b) -> (a -> f a) -> (a -> b)
16:59:06 <lambdabot> No results found
16:59:15 <elliott> that seems like an unsafe guess with over 1,000 people in the channel
16:59:23 <mauke> unsafePerformGuess
16:59:31 <Nawmad> well, ill narrow it down to nobody here is in Ontario
16:59:35 <mauke> O(canada)
16:59:52 <Nawmad> canada is not a complexity class... is it?
17:00:21 <shachaf> Plenty of people are in Ontario.
17:00:27 <niteria> @kind Fix
17:00:28 <hiptobecubic> johnw, why *should* we care about kliesli cat? Does it get applied the same way an understanding of the trifecta of functor/applicative/monad does?
17:00:29 <lambdabot> Not in scope: type constructor or class `Fix'
17:00:55 <mauke> @kind Mu
17:00:57 <lambdabot> (* -> *) -> *
17:01:44 <niteria> :t fix
17:01:45 <lambdabot> (a -> a) -> a
17:02:18 <johnw> hiptobecubic: kleisli cat allows direct composition of any a -> m b and b -> m c.  It's really just another way of thinking about monads
17:02:22 <mauke> @kind Mu Identity
17:02:23 <lambdabot> *
17:02:27 <mauke> :t fix id
17:02:27 <niteria> I get fix, but Mu blows my mind
17:02:28 <lambdabot> a
17:02:47 <niteria> and they're the same almost
17:02:49 <tac> Mu is greatest fixedpoint, isn't it?
17:02:50 <Nawmad> so if there exists a function that can take a function a->b and create a new function M a -> M b, then M must be a functor?
17:02:53 <johnw> so, >=> and <=<.  and using Kleisli with the Arrow library so you can use >>> to compose monadic functions
17:03:04 <dmwit> tac: least; though in Haskell they coincide
17:03:04 <elliott> Nawmad: only if that function obeys the functor laws.
17:03:11 <tac> dmwit: yeah
17:03:20 <dmwit> tac: That is, the convention is for mu to be the least fixed point and nu to be the greatest.
17:03:21 <tac> ah yeah, nu is greatest
17:03:39 <Nawmad> M a == M a, M (M a) == (M . M) a?
17:03:41 <mauke> > "nu" > "mu"
17:03:42 <lambdabot>   True
17:03:53 <dmwit> Nawmad: No, the functor laws are fmap id = id and fmap f . fmap g = fmap (f . g)
17:03:55 <hiptobecubic> i have never discussed even the idea of a "greatest fixed point"
17:04:13 <hiptobecubic> johnw, i have used >=> and <=< in ignorant bliss
17:04:15 <Nawmad> where id,f,g=?
17:04:26 <dmwit> Nawmad: id x = x; f and g are universally quantified
17:04:31 <Cale> Nawmad: id x = x, and f, g are arbitrary functions
17:04:32 <johnw> hiptobecubic: well then, Kleisli is the man behind the curtain :)
17:04:55 <niteria> does greatest fixed point always exist?
17:04:58 <Cale> (of the right types to make the expressions typecheck)
17:05:00 <Nawmad> hmm... arbitrary function == universal quantifiers...
17:05:01 <Nawmad> I like it
17:05:08 <johnw> Cale: short dinner!
17:05:22 <mauke> "universally quantified" just means "for all possible x"
17:05:26 <otters> how do you specify that a cabal package depends on a certain C library?
17:05:28 <Cale> johnw: Yeah, subs :)
17:05:31 <dmwit> Nawmad: Also, for the record, we are talking about Functor here, and not functors; Functor has some bits of the properties of a functor built in, so you get to skip some proofs you might have to do in an arbitrary category.
17:05:38 <otters> like this thing requires aspell
17:05:38 <koninkje> niteria: if (1) there is at least one fixedpoint, (2) all fixedpoints are linearly ordered, then yes there's a greatest one
17:05:47 <dmwit> (I apologies for using the wrong word earlier. =)
17:06:02 <Nawmad> i know but I have the book "Categories for the working mathematician 2nd edition" and I want to use it...
17:06:13 <mauke> Functor is the thing defined in a Haskell library; functor is the general CT concept
17:06:16 <cc> > 1 `take` "ok"
17:06:18 <lambdabot>   "o"
17:06:30 <hiptobecubic> how is ordering defined for fixed points?
17:06:31 <dmwit> otters: I think there's something that integrates with pkg-config, let's see here...
17:06:33 <koninkje> niteria: N.B., in Haskell, the least- and greatest fixedpoints of types coincide
17:06:40 <haskell_noob> can anyone tell me why this isnt working? map (\x -> x*x) . filter odd [1..10]
17:06:44 <mauke> > 4 `take` "mushroom"
17:06:46 <lambdabot>   "mush"
17:06:46 <Nawmad> well, ill go make tea
17:06:49 <mauke> is this even a pun
17:06:52 <dmwit> otters: See pkgconfig-depends
17:06:59 <elliott> haskell_noob: that parses as (map (\x -> x*x)) . (filter odd [1..10])
17:07:06 <mauke> haskell_noob: precedence
17:07:10 <elliott> haskell_noob: perhaps just write map (\x -> x*x) (filter odd [1..10]) if you're unsure of the meanings of (.)/($)?
17:07:13 <koninkje> hiptobecubic: it depends. If you consider fixedpoints of a function f :: a->a, then the order is the ordering on a
17:07:20 <dmwit> otters: If your C library isn't a pkg-config one, then you can choose between bundling the source of the library in your Haskell package or writing a custom Setup.hs, I suppose.
17:07:25 <elliott> best to get comfortable with the standard applicative form first, I think
17:07:25 <hiptobecubic> haskell_noob, long answer is that the types don't work together because it doesn't read how you think it does. The short answer is that you want to add a ($) before the list.
17:07:31 <johnw> > map (\x -> x*x)) . filter odd [1..10]
17:07:33 <lambdabot>   <hint>:1:16: parse error on input `)'
17:07:35 <johnw> > map (\x -> x*x) . filter odd [1..10]
17:07:36 <mauke> just add parens
17:07:37 <lambdabot>   No instance for (GHC.Real.Integral [b0])
17:07:37 <lambdabot>    arising from a use of `e_1110'
17:07:37 <lambdabot> ...
17:07:49 <mauke> > (map (\x -> x*x) . filter odd) [1..10]
17:07:51 <lambdabot>   [1,9,25,49,81]
17:07:52 <johnw> > map (\x -> x*x) . filter odd $ [1..10]
17:07:54 <lambdabot>   [1,9,25,49,81]
17:07:56 <johnw> ok
17:07:59 <niteria> it's just an ordering on domains, right?
17:08:05 <niteria> koninkje: ^
17:08:17 <copamp> > filter (>=10) [10,10.1,9.999999999]
17:08:17 <mauke> > map (\x -> x*x) (filter odd [1..10])
17:08:19 <lambdabot>   [10.0,10.1]
17:08:19 <lambdabot>   can't find file: L.hs
17:08:22 <mauke> > map (\x -> x*x) (filter odd [1..10])
17:08:24 <lambdabot>   [1,9,25,49,81]
17:08:39 <koninkje> hiptobecubic: for types, i.e. fixedpoints of functors, you could consider ordering to be subset inclusion (for types viewed as sets)
17:08:48 <koninkje> niteria: yes
17:08:59 * cc back to the indigest c#
17:09:09 <hiptobecubic> koninkje, can you give an example where greatest and least don't coincide?
17:09:12 <koninkje> niteria: though, phrasing it that way requires an understanding of domains and how they can be used to model other things...
17:09:13 <dmwit> > map (^2) [1,3..10]
17:09:15 <lambdabot>  Terminated
17:09:24 <dmwit> lambdabot--
17:09:34 <copamp> > map (\x->x*x) [1,3..10]
17:09:34 <Nawmad> have i ever told you guys how thankful I am for all your help, if I have, I must be annoying as hell, if I haven't, I must come off really rude, and unless I am both, I am not satisfied.
17:09:35 <lambdabot>   [1,9,25,49,81]
17:09:36 <elliott> @karma lambdabot
17:09:36 <lambdabot> lambdabot has a karma of 25
17:09:44 <haskell_noob> thnx guys
17:09:45 <niteria> koninkje: I meant set theoretic domains
17:09:47 <copamp> @karma elliott
17:09:48 <lambdabot> elliott has a karma of 38
17:09:55 <Nawmad> *thanks
17:09:57 <lemao> quick question: is it possible to have a Haskell cabal package that also compiles cpp code and generates a shared lib?
17:10:09 <koninkje> hiptobecubic: Consider any strict call-by-value language. The least fixedpoint of (1 + A*_) is the type of finite lists; whereas the greatest fixedpoint is the type of possibly infinite lists
17:10:21 <dmwit> lemao: All (computable) things are possible.
17:10:25 <dmwit> With sufficient effort.
17:10:25 <johnw> lemao: you can have a cabal package do absolutely anything you want
17:10:33 <johnw> lemao: just using the Custom build type
17:10:34 <koninkje> hiptobecubic: Of course, you need some way of making thunks in that strict language; otherwise you can't get the greatest fixedpoint
17:10:54 <hiptobecubic> i'm not sure how to read (1 + A*_)
17:11:21 <dmwit> hiptobecubic: type Foo b = Either () (A, b)
17:11:24 <lemao> johnw: :-) of course, but is it simple enough to be a viable option?
17:11:34 <koninkje> data A_List x = Nil | Cons A x
17:11:44 <johnw> lemao: i'm not sure what measure of simplicity you require for me to answer yes to that :)
17:11:49 <hiptobecubic> koninkje, oh
17:12:08 <beaky> hello
17:12:13 <hiptobecubic> dmwit, yours i don't see
17:12:16 <johnw> hi beaky!
17:12:33 <dmwit> hiptobecubic: Left () = Nil; Right (a, b) = Cons a b
17:12:37 <koninkje> The fact that LFP and GFP coincide, of course, relies on not using bangs in the data type definition :)
17:13:03 <elliott> hiptobecubic: + = Either
17:13:06 <elliott> * = (,)
17:13:10 <elliott> 1 = (), 0 = Void
17:13:29 <koninkje> and A^B = B -> A
17:13:34 <hiptobecubic> yes but Either () (A, b)?  not (A, Foo b) ?
17:13:43 <dmwit> The fixpoint comes later.
17:13:46 <lemao> johnw: the end goal is a shared lib that exports a CreateModule (C symbol) and returns a C++ class. This class would be build using .cpp and it would call two very simple functions taking a string and returing an int
17:14:06 <lemao> johnw: these 2 functions would be implemented in .hs
17:14:07 <dmwit> Or, to say it another way: Nil | Cons A x? not Nil | Cons A (A_List x)?
17:14:24 <koninkje> dmwit: right
17:14:45 <hiptobecubic> do the ? means something special ther?
17:14:49 <hiptobecubic> there*
17:14:54 <dmwit> hiptobecubic: Nope, it's the same ? you used in your question.
17:15:04 <hiptobecubic> oh i see
17:15:05 <dmwit> hiptobecubic: Just spelled with the A_List type instead of the Foo type.
17:15:16 <johnw> lemao: why does it have to be a shared lib?
17:15:18 <chrisdone> donri: try this http://oma.tryhaskell.org/decl.hs :p
17:15:18 <chrisdone> donri: try to change the 123 to something else =) hint: hold down ctrl to see the tree
17:15:22 <hiptobecubic> Right. let me reread :)
17:15:28 <koninkje> We have that List a ~= fix b. Either () (a,b)
17:15:31 <johnw> anyway, you could do this with the Simple build type
17:15:57 <johnw> just name the .cpp files as extra source files, and then set the compile/link flags to generate PIC and dylib
17:16:02 <lemao> johnw: because there is a c++ microkernel that loads these modules and provides the main entry point
17:16:14 <typoclass> chrisdone: oh very nice :) kudos
17:16:21 <koninkje> And, of course, fix b. Either () (a,b) ~= fix b. A_List b
17:16:23 <lemao> johnw: I basically want to use Haskell to build these modules
17:16:24 <donri> chrisdone: done
17:16:25 <hiptobecubic> koninkje, dmwit oh ok sure. You just used the other type, although that doesn't answer my question really. It just makes me ask it the way you did just there.
17:16:33 <chrisdone> donri: woo! :D
17:16:54 <dmwit> hiptobecubic: Aha! So we're making progress; now you don't understand *either* answer. =D
17:17:06 <donri> chrisdone: the tree table view reminded me of my http://camxes.lojban.org/ ;)
17:17:10 <johnw> chrisdone: very cool!
17:17:13 <hiptobecubic> well i understand that they are similar at least :)  If i get one i assume i'll get the other
17:17:17 <dmwit> right
17:17:20 <koninkje> hiptobecubic: if we're talking about fixedpoints, then we need to talk about both (a) the function/functor being fixed, and (b) the result of fixing
17:17:37 <chrisdone> donri: ;)
17:17:55 <luite> chrisdone: cool!
17:17:56 <chrisdone> typoclass: johnw: can you figure out how to change something? :D (the AST is shared between us)
17:18:09 <hiptobecubic> koninkje, *are* we talking about fixed points? I thought we were just spelling [] with different types
17:18:16 <koninkje> So, using better names than before: data PreList a b = Nil | Cons a b; type List a = Fix (PreList a)
17:18:23 <hiptobecubic> [a]
17:18:46 <koninkje> And, List a ~= [a]
17:18:57 <typoclass> chrisdone: no, couldn't figure it out so far :-/
17:19:03 <koninkje> And, PreList a b ~= Either () (a,b)
17:19:07 <donri> chrisdone: i'm also reminded [by the normal code view] of contenteditable in html... it's like wysiwyg for code without actually being visual programming
17:19:11 <dmwit> It might help to expand Fix (PreList a) a bit (without the newtype junk).
17:19:40 <koninkje> And, Fix f ~= fix b. f b
17:19:46 <chrisdone> donri: for me it reminds me a bit of firebug's html viewer too
17:19:49 <dmwit> In pseudo-Haskell: type List' a = PreList a (PreList a (PreList a (...))) = Nil | Cons a (Nil | Cons a (Nil | Cons a (...)))
17:19:55 <chrisdone> typoclass: arrow keys to navigate, RET to change =)
17:20:14 <donri> chrisdone: ah yeah. and dedicated xml editors in general i imagine
17:20:21 <dmwit> = Nil | Cons a Nil | Cons a (Cons a Nil) | Cons a (Cons a (Cons a Nil)) | Cons a (Cons a (Cons a (...)))
17:20:28 <chrisdone> typoclass: although it only supports like 4 expression types atm. i started the codebase last night
17:20:30 <typoclass> chrisdone: ah :-) excellent. works even in opera!
17:20:35 <hiptobecubic> dmwit, ah... hmm
17:20:40 <chrisdone> typoclass: haha, THAT'S surprising
17:20:54 <donri> typoclass: opera with webkit? :p
17:21:05 <hiptobecubic> dmwit, so you're unrolling the recursive type definition
17:21:11 <dmwit> yes
17:21:17 <dmwit> just so
17:21:19 <hiptobecubic> what happened to b
17:21:23 <chrisdone> donri: lol
17:21:26 <typoclass> donri: no, the normal one
17:21:27 <dmwit> b is the placeholder for recursive calls
17:21:41 <hiptobecubic> oh i see
17:21:57 <hiptobecubic> Cons a (b is the rest of this thing)
17:22:00 <dmwit> Just like in the term-level fix, you use the first argument to your lambda as a placeholder for recursive calls.
17:22:03 <dmwit> yes
17:22:15 <dmwit> fix (\fib n -> {- use fib as if it were a recursive call -})
17:22:28 <hiptobecubic> but then, isn't b's type changing ?
17:22:36 <dmwit> Mu (/\list. {- use list as if it were a recursive call -})
17:22:36 <hiptobecubic> depending on the length of the list
17:22:42 <beaky> is using [Char] bad for applications with string processing?
17:22:50 <hiptobecubic> beaky, usually
17:22:54 <beaky> ah :(
17:22:57 <lispy> beaky: what is bad?
17:23:02 <dmwit> hiptobecubic: Sort of, because we've been throwing away Mu's newtype junk as an aid to intuition (but not an aid to details).
17:23:07 <hiptobecubic> beaky, it's best to just learn to use Text properly when you want to work with Text
17:23:13 <lispy> beaky: [Char] supports unicode, so that's good
17:23:17 <dmwit> hiptobecubic: In reality, "b" will always be another copy of List, that is, Fix (PreList a).
17:23:19 <beaky> oh :D
17:23:46 <lispy> beaky: [Char] is good for lazy things and it can also be efficient when the lists are small
17:23:49 <dmwit> beaky: [Char] is fine for Unicode, but can be slow. Text is good for both Unicode and speed.
17:23:57 <hiptobecubic> beaky, just don't start [Word8]'ing :)
17:24:03 <shachaf> Speed at some things, anyway.
17:24:34 <beaky> I guess i'll go with Bytestring
17:24:39 <niteria> hm, it looks like hylo is making data a control stucture
17:24:40 <dmwit> what, no!
17:24:48 <donri> hahaha
17:24:48 <hiptobecubic> beaky, that's basically what i just said not to do
17:24:54 <dmwit> How did you end on ByteString after this discussion?
17:24:59 <donri> unicode is hard, i'll just use bytestrings!
17:25:04 <hiptobecubic> :D
17:25:09 <hiptobecubic> It's best to just close your eyes and jump
17:25:21 <lispy> bytestring is really really great. For raw bytes.
17:25:28 <donri> man bytestrings are hard i'll just use the Char8 APIs
17:25:31 <hiptobecubic> dmwit, so b isn't changing type?
17:25:38 <beaky> ah I thought ByteString was the one to go for in parsing jobs
17:25:43 <dmwit> hiptobecubic: Trick question. What is "b"?
17:25:50 <hiptobecubic> What *isn't* b?
17:25:53 <donri> beaky: really depends on what you're parsing
17:26:00 <dmwit> beaky: No, ByteString is the one to use when you want a string of bytes. (*gasp*)
17:26:06 <lispy> beaky: only if the parsing job is on byte streams. If you're procesing text, [Char] and Data.Text are prefered.
17:26:12 <hiptobecubic> Sadly, that was a legit question.
17:26:52 <hiptobecubic> C has completely trashed everyone's intuition about "string of text"
17:27:04 <hiptobecubic> or characters, rather
17:27:08 <dmwit> hiptobecubic: Can you try to make the question a self-contained one, devoid of reference to the rest of the conversation? This exercise might help you massage it into something I can reasonably answer.
17:27:14 <lispy> hiptobecubic: both really :)
17:27:56 <beaky> I thought strings were just arrays of bytes
17:27:56 <lispy> hiptobecubic: the notion of reading until the terminator is dangerous as is the notion of word8 = char
17:28:03 <beaky> (or linked lists of bytes :D)
17:28:08 <donri> text is like a parsed xml tree. bytestring is like the unparsed xml as text!
17:28:25 <prinnysocks> trying to define a type that is either a tuple of two values or a single integer value
17:28:28 <prinnysocks> how would i do that
17:28:35 <edwardk> How dangerous can a Terminator be? They've been trying for years and have yet to kill John Connor.
17:28:41 <dmwit> beaky: You should really read an introduction to Unicode, then. I guess there's many out there; Spolsky's seems to be popular for some reason.
17:29:08 <dmwit> http://www.joelonsoftware.com/Articles/Unicode.html
17:29:16 <dmwit> (...or is my sarcasm detector off again?)
17:29:23 <hiptobecubic> dmwit, in the definition "PreList a = Nil | Cons a b", what type is b? Prelist a is a cell in a "list of a's", and b is ... ? "the rest" ?
17:29:30 <beaky> I don't know what unicode is
17:29:32 <geekosaur> prinnysocks, what is the purpose of this type? (I can think of several ways to do it ranging from the simple to the highly complex; which si appropriate depends on ewhat you want to do with it)
17:29:40 <hiptobecubic> beaky, Pragmatic Unicode: http://nedbatchelder.com/text/unipain.html
17:29:46 <hiptobecubic> beaky, also that
17:29:47 <prinnysocks> geekosaur: simple as possible, i'm a newbie to haskell and trying to do the 99 problems
17:29:48 <donri> beaky: bytestrings are strings of bytes. String is a list of Char and a haskell Char is not a byte, it's a unicode character, an idea.
17:29:50 <koninkje> hiptobecubic: the definition is supposed to be parametric over b too
17:29:57 <koninkje> hiptobecubic: PreList a b =...
17:29:59 <dmwit> hiptobecubic: To be very careful, we must define "data PreList a b {- notice the b here -} = Nil | Cons a b".
17:30:03 <hiptobecubic> beaky, although i think that's python centric
17:30:13 <dmwit> hiptobecubic: And then the answer is that "b" hasn't been instantiated yet, so the question must be unasked.
17:30:23 <beaky> ah I always thought Chars were just bytes rather than unicode's more abstract notion of characters
17:30:33 <hiptobecubic> Oh i missed that
17:30:36 <dmwit> > "\14532"
17:30:37 <lambdabot>   "\14532"
17:30:40 <dmwit> beaky: ^_^
17:30:44 <lispy> beaky: this is standard reading material when someone is ready to admit they don't know what unicode is: http://www.joelonsoftware.com/articles/Unicode.html
17:30:47 <geekosaur> type MyType = Either Int (Int,Int) -- Left 3 or Right (5,7) -- but you haven't really answered the question, again what you intend to do with it decides whether this is the appropriate type
17:30:57 <hiptobecubic> lispy, was pasted already :)
17:31:03 <lispy> ah, sorry
17:31:13 <beaky> :D thanks guys
17:31:15 <hiptobecubic> dmwit, so then the length of the list is encoded in the type?
17:31:18 <donri> beaky: a byte in haskell is a Word8
17:31:30 <dmwit> hiptobecubic: Not at all!
17:31:39 <hiptobecubic> beaky, which perhaps clarifies my previous statement about not going to [Word8]
17:32:04 <hiptobecubic> dmwit, then I don't know what b looks like :)
17:32:15 <hiptobecubic> PreList a b = Nil | Cons a b, yes?
17:32:36 <koninkje> hiptobecubic: It might help to implement the function, roll :: PreList a (List a) -> List a
17:32:38 <dmwit> hiptobecubic: You might like to take these two definitions together (ignoring "Mu" for the moment): "data PreList a b = Nil | Cons a b; data List a = Constructor (PreList a (List a))".
17:32:52 <dmwit> hiptobecubic: Now, as an exercise, throw those in ghci and try to write a couple values of type "List Int".
17:32:56 <koninkje> hiptobecubic: and the inverse, unroll :: List a -> PreList a (List a)
17:33:12 <niteria> b is a list
17:33:18 <dmwit> hiptobecubic: koninkje is also suggesting some wonderful exercises
17:33:20 <prinnysocks> geekosaur: thank you
17:33:31 <hiptobecubic> right-o. let's see what happens
17:33:44 <niteria> http://conal.net/talks/folds-and-unfolds.pdf this is relevant
17:34:47 <koninkje> hiptobecubic: Another good exercise is to define the function, cata :: (PreList a b -> b) -> List a -> b
17:35:10 <koninkje> hiptobecubic: and the dual, ana :: (b -> PreList a b) -> b -> List a
17:35:32 <prinnysocks> geekosaur: i'm trying to do problem 11: http://www.haskell.org/haskellwiki/99_questions/11_to_20
17:36:41 <mauke> http://blog.plover.com/prog/springschool95-2.html
17:37:19 <geekosaur> prinnysocks, so that example in Haskell shows you the type they want, which is isomorphic to what I suggested but more specific (this is usually a good thing). although I might suggest you go through LYAH so that you can learn how types work, so you can work out how to do it yourself
17:37:21 <ParahSail1n> the behavior of stm retry seems a little magical to me
17:37:25 <geekosaur> @where LYAH
17:37:25 <lambdabot> http://www.learnyouahaskell.com/
17:37:58 <fryguybob> ParahSail1n: How so?
17:38:18 <geekosaur> anyway, the one they use looks something like like: data RLE a = Single a | Multiple Int a
17:38:28 <dmwit> ParahSail1n: Yeah! Pretty cool, right?
17:38:46 <geekosaur> and their encodeModified is using RLE Char
17:38:51 <dmwit> ParahSail1n: What they're not telling you (maybe) is that each transaction keeps track of *all* the STM variables it reads and writes from and to.
17:38:55 <ParahSail1n> take '(takeTMVar a `orElse` takeTMVar b)' for example-- both takeTMVars contain a retry if <- readTMVar is Nothing
17:39:11 <dmwit> ParahSail1n: So when "retry" comes along, it just patiently waits until some STM variable that was read from gets written to by another transaction.
17:39:13 <ParahSail1n> but the entire operation, will retry around both of them somehow
17:39:16 <hpaste> roSievers pasted “Error in openGL Redbook?” at http://hpaste.org/84583
17:39:52 <roSievers> Hi, I found s.th. that looks like a little typo to me, but I'm not sure where to report it.
17:40:12 <ParahSail1n> dmwit, ah, so magic properties of the STM monad
17:40:18 <roSievers> the "Redbook" is the one hosted at http://code.haskell.org/GLUT/examples/RedBook/
17:40:43 <dmwit> Well, only a little bit magical. =)
17:40:44 <fryguybob> ParahSail1n: It might help to note that retry and `orElse` go together.
17:40:57 <dmwit> But yes, retry and orElse know about each other.
17:41:11 <ParahSail1n> ah...
17:41:15 <shachaf> retry and orElse are the future.
17:42:32 <dmwit> roSievers: Looks like the GLUT package on Hackage is probably relevant.
17:42:45 <dmwit> roSievers: It suggests that the new home of the source code is github.com/haskell-opengl/GLUT
17:42:51 <dmwit> e.g. https://github.com/haskell-opengl/GLUT/tree/master/examples/RedBook
17:42:53 <fryguybob> retry does make sense on its own, but that is much less interesting.
17:43:01 <A1kmm> Anyone know if it is possible to derive a transformer re-ordering function  with type like t1 (t2 m) a -> t2 (t1 m) a for MFunctor / MMonad or similar?
17:43:44 * hackagebot haspell 0.1.0.0 - Haskell bindings to aspell  http://hackage.haskell.org/package/haspell-0.1.0.0 (JoelTaylor)
17:43:45 <roSievers> looks like the mistake is still in there, I'll report it on Github, thank you dmwit
17:44:02 <fryguybob> Another confusing thing is that  retry  is not the same as the transaction seeing inconsistent state and aborting to try again.
17:44:36 <A1kmm> I have a Consumer ByteString (ErrorT e m) () and want to transform it somehow to ErrorT e (Consumer ByteString m) () so I can run the error transformer and get a Consumer ByteString m (Either e a)
17:45:03 <dmwit> A1kmm: It is not possible in general to commute monad transformers.
17:45:07 <koninkje> A1kmm: in general, no
17:45:21 <A1kmm> dmwit: Not even with MFunctor?
17:45:25 <koninkje> A1kmm: Though, it may be possible for specific choices of t1 and t2
17:45:46 <niteria> infinite Bohm tree for I is the same as for Y, right? any intuition why?
17:45:54 <dmwit> I have no idea, since I've got no idea what MFunctor, MMonad, or Consumer are. But I wouldn't be surprised at all if the answer was still no.
17:45:58 <A1kmm> So is there any typeclass for t1 and t2 where it is possible.
17:46:12 <A1kmm> dmwit: http://hackage.haskell.org/packages/archive/mmorph/1.0.0/doc/html/Control-Monad-Morph.html
17:46:13 <dmwit> Traversable, maybe?
17:46:22 <dmwit> :t traverse
17:46:23 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
17:46:36 <dmwit> :t traverse id
17:46:38 <lambdabot> (Applicative f, Traversable t) => t (f b) -> f (t b)
17:46:50 <parcs> :t sequenceA
17:46:51 <lambdabot>     Not in scope: `sequenceA'
17:46:51 <lambdabot>     Perhaps you meant one of these:
17:46:51 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
17:47:07 <Nawmad> Somebody needs to write the book "Category theory for the Unemployed Mathematician"
17:47:10 <parcs> :t Data.Traversable.sequenceA
17:47:12 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
17:47:15 <hiptobecubic> koninkje, dmwit I've done roll and unroll, but I'll be honest, I don't understand why we're using two types here instead of one.
17:47:33 <dmwit> hiptobecubic: Ah!
17:47:35 <hiptobecubic> data List a b = Nil | Cons a b  seems like all you need
17:47:44 <koninkje> hiptobecubic: the reason is because we're distinguishing the thing we're taking the fixedpoint of, and the result of taking the fixedpoint
17:47:50 <hiptobecubic> specifically, what the hell is PreList supposed to do
17:47:55 <dmwit> hiptobecubic: That's because you can write "fold" once and for all for all recursive types if you formulate all your recursive types as Mu applied to something.
17:48:03 <dmwit> hiptobecubic: and other things, too, like "unfold" and such
17:48:04 <hpaste> hiptobecubic pasted “Rollin'” at http://hpaste.org/84584
17:48:20 <koninkje> hiptobecubic: (PreList a) is the functor who's fixedpoint is List a
17:48:35 <shachaf> hiptobecubic: PreList is a magic type such that PreList (List a) is isomorphic to List a
17:48:54 <dmwit> hiptobecubic: Notice that lines 13 and 17 are unnecessary.
17:48:56 <hiptobecubic> I though hpaste ran your program :(
17:49:00 <arkeet> :t In
17:49:01 <lambdabot> f (Mu f) -> Mu f
17:49:08 <hiptobecubic> dmwit, yes, they are vestigial
17:49:11 <dmwit> hiptobecubic: And after you delete them, the definitions of roll and unroll are 100% PreList-agnostic.
17:49:16 <hiptobecubic> dmwit, i also had (Cons a b) before pl
17:49:46 <ParahSail1n> oh, yeah i guess i should have figured out that orElse knows about retry directly from the docs
17:49:53 <dmwit> hiptobecubic: You should find with a bit of work that cata and ana can be PreList-agnostic, too. =)
17:50:11 <dmwit> (...I think.)
17:50:16 <koninkje> hiptobecubic: the big reason for all this is to program more generically. For any recursive polynomial type (e.g., List a) we know there exists a functor (e.g., PreList a) which generates it
17:50:32 <hiptobecubic> isn't List a already a functor
17:50:39 <hiptobecubic> (or able to be made one)
17:50:47 <dmwit> Definitely, but that's irrelevant.
17:50:47 <koninkje> hiptobecubic: Thus, we can abstract over the functor, and handle all recursive polynomials in one fell swoop
17:51:18 <koninkje> hiptobecubic: Replace (List a) by IntList or any other monomorphic thing
17:51:32 <hiptobecubic> I can see that at least so far, PreList is fairly useless looking. I don't see why you want to talk about it generating List instead of just talking about List.  Is PreList somehow easier to make than List?
17:51:36 <koninkje> the ideas still work, even though IntList isn't a functor
17:51:39 <niteria> what type would be not recursive polynomial?
17:52:01 <koninkje> niteria: data Fun a b = Fun (a -> b)
17:52:17 <koninkje> niteria: function types are "exponentials", so they're not polynomial
17:52:21 <dmwit> niteria: ...or many types that are available once you step outside of Haskell.
17:52:34 <koninkje> polynomial types are your usual sum-of-products style data types
17:52:44 <arkeet> @ty let cata f m = f (fmap (cata f) (out m)) in cata
17:52:46 <lambdabot> Functor f => (f b -> b) -> Mu f -> b
17:52:48 <niteria> does GADT break polynomiality?
17:53:54 <koninkje>  The idea of polynomials comes from the identifications: (+)=Either, (*)=(,), 1=(), 0=Void,...
17:54:32 <koninkje> niteria: So, we get polynomials by using (+), (*), 0, 1,...; What arithmetic thing would Pi- or Sigma-types represent?
17:55:07 <niteria> sorry I don't know the theory beind GADTs
17:55:17 <koninkje> no worries
17:55:52 <dmwit> hiptobecubic: (...in fact, your observation that List is itself a functor means we can take *its* fixpoint. When we do, we get another very useful type: rose trees.)
17:56:03 <koninkje> Pi-types (aka dependend functions) are a variety of function; so they're not polynomial for the same reason functions aren't
17:56:04 <Rotaerk> hmm learning about traversable, and want to play around with a binary tree data type which is an instance of traversable... however I'm not really sure how <*> should be implemented for a binary tree
17:56:16 <hiptobecubic> dmwit, I'm familiar with those, but I don't see *that* relation at all yet.
17:56:19 <arkeet> Rotaerk: <*> isn't part of traversable
17:56:27 <hiptobecubic> still trying to figure out what cata is supposed to look like
17:56:30 <dmwit> hiptobecubic: That's okay. Keep working with lists for a bit first. =)
17:56:40 <Rotaerk> oh wait I'm dumb; I only need Functor and Foldable
17:56:46 <Rotaerk> not applicative..
17:56:49 <arkeet> :p
17:56:54 <koninkje> niteria: Sigma-types are like products, except that the type of the second component depends on the value of the first component; We get things like that in maths, but not so much in arithmetic...
17:56:57 <arkeet> Rotaerk: well, it turns out that binary tree is in fact a monad.
17:57:14 <koninkje> niteria: btw, GADTs are just a weak form of dependent types
17:57:16 <arkeet> Rotaerk: if you have a tree whose leaves are trees, you can replace each leaf with the corresponding tree.
17:57:27 <arkeet> uh
17:57:37 <hiptobecubic> wat
17:57:48 <arkeet> no, that's not the kind of tree I'm thinkin gof.
17:58:22 <niteria> koninkje: ok, I see
17:58:28 <koninkje> :)
17:58:32 <niteria> cata is fold, ana is unfold?
17:58:35 <hiptobecubic> I can see that the first argument to cata looks suspiciously like `roll`... But now what
17:58:40 <koninkje> niteria: yep
17:59:58 <dmwit> hiptobecubic: You might want to implement instance Functor (PreList a) first.
18:00:03 <hiptobecubic> hmm
18:00:06 <dmwit> hiptobecubic: (also, this is a hint)
18:00:35 <xpika> does anyone know where the blog post about writing haskell that looks like C is ?
18:01:03 <niteria> F* is a way of saying Mu F?
18:01:34 <niteria> http://conal.net/talks/folds-and-unfolds.pdf slide 21 here
18:01:44 <xpika> i think newIORef was aliased to the function name "var"
18:01:50 <dmwit> niteria: Usually F* is 1 + F + F^2 + F^3 + ... i.e. [F]
18:02:12 <koninkje> xpika: I can't find the one for C offhand, but here's the one for Python:
18:02:13 <koninkje> http://augustss.blogspot.com/2011/07/impredicative-polymorphism-use-case-in.html
18:02:29 <koninkje> xpika: And here's the one for BASIC
18:02:29 <koninkje> http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
18:02:41 <dmwit> niteria: Although I guess here treating F* as Mu F is a bit more likely.
18:02:49 <dmwit> (just looked at the slides)
18:03:17 <arkeet> dmwit: by F^2 you mean F * F, not F . F, right?
18:03:39 <dmwit> yes
18:03:40 <arkeet> (incidentally, 1 + F + F.F + F.F.F + ... is Free F)
18:04:00 <shachaf> dmwit; What if it means 1 + F + F^2 + F^3 + ... i.e. thanks arkeet
18:05:34 * hiptobecubic whimpers
18:06:01 <niteria> what does F.F mean in this context?
18:06:09 <dmwit> functor composition
18:06:26 <shachaf> F∘F
18:06:26 <niteria> what does this mean for Maybe?
18:06:38 <arkeet> (F . F) a = F (F a)
18:06:56 <niteria> Maybe (Maybe a)
18:07:37 <niteria> how does free monad on Maybe look like?
18:07:50 <arkeet> Maybe a = 1 + a, so
18:08:02 <arkeet> (Free Maybe a) = (a + (1+a) + (2+a) + (3+a) + ...)
18:08:06 <hiptobecubic> dmwit, in this functor instance.... fmap f applies f to the List *inside* the PreList.... or ... you know? Right?
18:08:10 * hiptobecubic fidgets
18:08:17 <koninkje> niteria: data Free f a = Return a | Free (f (Free f a))
18:08:17 <arkeet> doesn't look that useful
18:08:21 <shachaf> Either a (Maybe (Either a (Maybe (Either a (Maybe ...
18:08:30 <arkeet> niteria: Maybe itself is a free monad, btw. Maybe = Free (Const ())
18:08:32 <dmwit> hiptobecubic: There's no Lists involved in the Functor instance for PreList.
18:08:36 <hiptobecubic> :t fmap
18:08:38 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:08:53 <hiptobecubic> fmap :: (a -> b) -> (Prelist c a -> PreList c b) ?
18:08:58 <dmwit> correct
18:09:01 * koninkje nods
18:09:11 <arkeet> uhhh
18:09:16 <hiptobecubic> oh i was using a in two places for two things in the code.... maybe that's what's wrong :)
18:09:28 <arkeet> uhhhh
18:09:42 <arkeet> it's really Free f = 1 + F . (1 + F . (...))
18:09:46 <arkeet> Free F.
18:09:57 <arkeet> they're only the same if F distributes over sums.
18:10:46 <koninkje> hiptobecubic: again, I't might help to just look at IntList and PreIntList (i.e., being monomorphic in a)
18:11:05 <niteria> that looks isomorphic to lists
18:11:09 <hiptobecubic> but...
18:11:16 <niteria> free monad on Maybe I mean
18:11:22 <koninkje> niteria: except the kinds are different...
18:12:21 <arkeet> niteria: nope
18:12:25 <arkeet> niteria: there's no empty list.
18:12:26 <koninkje> niteria: in arkeet's version, 1 is the Identity functor and (+) is sum of functors (i.e., (f+g)x = f x + g x)
18:12:33 <arkeet> yes
18:12:37 <koninkje> @where lifting lemma
18:12:37 <lambdabot> I know nothing about lifting.
18:12:43 <chrisdone> edwardk: no john, you are the demons
18:12:53 <koninkje> http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/26/slides/ralf.pdf
18:13:02 * edwardk is confused.
18:13:14 <koninkje> niteria, hiptobecubic: The above might be helpful (if it's not too confusing)
18:13:17 <edwardk> heya koninkje
18:13:23 <koninkje> edwardk: heya
18:14:02 <edwardk> koninkje: we should chat about logic programming stuff, dyna and what is going on in github.com/analytics at some point.
18:14:11 <koninkje> edwardk: You wouldn't happen to know of any work on type theory of keyword arguments, would you?
18:14:34 <edwardk> datalog with unstratified omega-continuous semiring solving, etc. ;)
18:14:42 <koninkje> :)
18:14:45 <koninkje> sounds fun
18:14:55 <edwardk> hrmm. named arguments?
18:15:05 <koninkje> er, keyword arguments I meant
18:15:26 <koninkje> e.g., in Python, OCaml, Scheme/Lisp,...
18:15:35 <edwardk> yeah. i want to call a function with these named args
18:15:37 <koninkje> or a la Haskell's record syntax
18:15:47 <edwardk> some optional, some required, etc.
18:16:11 <edwardk> i was going to point you towards the ocaml stuff
18:16:28 <koninkje> like what?
18:16:52 <edwardk> i kinda stopped thinking about them when i realized i couldn't have them nicely in haskell since i can't 'curry' the partial application to a few named args without telling it somehow that i'm all done
18:17:12 <koninkje> I'm finishing up one of my quals and am looking for citations for the related works section. But while many languages have keyword args, I can't find much on the type theory thereof...
18:17:22 <edwardk> ah
18:17:32 <edwardk> from a theoretical perspective i can't think of much
18:17:35 <edwardk> if anything
18:17:36 <koninkje> my chiastic lambda calculus would let you do that ;)
18:18:00 * koninkje hasn't looked into the optionality part of things yet though
18:18:16 <niteria> hm, interesting how Applicative instance for (e ->) is K and S, and S could be treated like application in given enviroment
18:18:59 <elliott> niteria: that's basically exactly what gives rise to Applicative
18:19:05 <elliott> it's "generalised K/S"
18:19:06 <koninkje> edwardk: as far as the analytics stuff, I'm swamped for this upcoming week; but we should chat sometime after that
18:19:14 <edwardk> k
18:19:20 <elliott> S is "generalised application"
18:19:40 <edwardk> i'm on here (and #haskell-lens) almost all the time
18:20:21 <edwardk> and i'll braindump then
18:20:38 <johnw> yumm, edwardk braindump
18:20:41 <johnw> is tasty dish
18:21:12 <hiptobecubic> koninkje, there is a problem here
18:21:23 <koninkje> hiptobecubic: where?
18:22:01 <hiptobecubic> koninkje, I need to go from PreList a b to List a, which is like roll, but roll assumes PreList a (List a) not PreList a b
18:22:39 <hiptobecubic> further, List a *contains* PreList a (List a) so we must have b ~ List a?
18:22:49 <hiptobecubic> but the type of cata doesn't have that
18:23:06 <koninkje> Do you have Functor (PreList a) yet?
18:23:10 <hiptobecubic> otherwise i'd say  cata f = f . unroll
18:23:20 <hiptobecubic> I think so?
18:23:35 <hiptobecubic> fmap _ Nil = Nil; fmap f (Const a b) = Cons a (f b)
18:23:35 <koninkje> and what did your ana look like? (hint: cata and ana are duals, so they should look the "same"/"opposite")
18:23:46 <hiptobecubic> well ana then was roll . f
18:24:12 <hiptobecubic> and that all look symmetrical enough that I though perhaps that was right, but the types don't work because roll and unroll assume to much it seems
18:24:18 <hiptobecubic> looks*
18:24:28 <hiptobecubic> thought*, damn.
18:25:18 <koninkje> hiptobecubic: your functor instance looks good
18:25:42 <hiptobecubic> koninkje, honestly I don't think it makes sense
18:25:44 <hiptobecubic> it works
18:25:47 <hiptobecubic> but what is it doing
18:25:50 <koninkje> Remember, cata/ana are going to have to be recursive functions, since we're basically doing induction on the recursion described by Fix/Mu
18:26:00 <hiptobecubic> the "values" live in a, not b
18:26:22 <koninkje> hiptobecubic: ignore a; or make it something monomorphic like Int
18:26:24 <hiptobecubic> But here we just traverse the list until we hit Nil
18:26:41 <koninkje> hiptobecubic: the a is just added complication; it doesn't matter for the stuff that's going on here
18:26:50 <hiptobecubic> koninkje, if we make it Int, it still has the values in it, no? It's a list of Ints.
18:27:31 <hiptobecubic> a List Int looks like   L (Cons 1 (L Nil)), for example
18:27:44 <hiptobecubic> and a PreList just drops the L
18:27:49 <koninkje> Well, Nil doesn't have any Ints in it...
18:27:50 <hiptobecubic> the leading one, I mean
18:28:31 <koninkje> Remember, Cons :: a -> b -> PreList a b. So it has both a value in a, and a value in b
18:28:51 <hiptobecubic> but the b is "the rest of the list" we said?
18:29:00 <koninkje> sure, but that's still a value
18:29:18 <hiptobecubic> right, but then this function does nothing ever
18:29:36 <koninkje> and, when writing cata/ana, there's no guarantee that it'll be an actual list... just something that corresponds to "the rest of the list" in an abstract way
18:30:04 <hiptobecubic> koninkje, ok. That is consistent with this type problem I'm having at least
18:30:31 <hiptobecubic> oh wait :D
18:31:01 * hiptobecubic gets a nose bleed
18:31:11 <hiptobecubic> I'm feeling some fmaps in here somewhere
18:31:59 <hiptobecubic> You know... because... this thing f's our PreList in the b
18:32:23 <hiptobecubic> which is suspiciously similar to what cata and ana what to make
18:32:30 <hiptobecubic> want*
18:32:40 <dmwit> yes
18:32:50 <dmwit> This is why my suggestion to write a Functor instance was a hint. =)
18:32:58 <dmwit> (sorry for disappearing for a bit)
18:32:59 <hiptobecubic> right, but I didn't see it at all
18:33:09 <hiptobecubic> I still don't. I just smell it from far away
18:34:07 <koninkje> When writing ana :: (b -> PreList a b) -> b -> List a, we can think of b as being a sort of "seed"
18:34:08 * hiptobecubic play https://www.youtube.com/watch?v=lP0D5u3EMfA in the background
18:34:14 <hiptobecubic> plays*
18:34:42 <koninkje> the seed somehow contains all the information needed to generate the list, and the first argument to ana gives us a way of opening up that seed just a bit
18:34:45 <niteria> what's NF lemma?
18:34:55 <hiptobecubic> koninkje, yes
18:35:27 <niteria> http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/26/slides/ralf.pdf last slide here
18:35:58 <koninkje> but, if we use the function on our original seed, we'll have something of type (PreList a b); so now we have some new seeds we need to grow...
18:36:21 <hiptobecubic> yes
18:36:34 <hiptobecubic> This music is helping. Let me bang away at it some more
18:52:35 <hiptobecubic> no
18:52:49 <hiptobecubic> cata is some kind of backwards fmap
18:53:46 <xkcd> I have written fib :: Intergral a => a -> a",  a fibonaci function for n th tem  Its is working I am trying to " evenFib :: Integral a => a -> a " "evenfib xs =  [x | x <- xs, even (fib x)]"  a function  will filter even fibonaci numbers What is Wrong with  this implementation?
18:54:01 <xkcd> for evenFib
18:54:29 <hiptobecubic> what is xs
18:54:45 <mikeplus64> evenfib seems to take a list of integrals and return a list of integrals
18:55:01 <xkcd> sorry evenFib :: Integral a => [a] -> [a]
18:55:24 <hiptobecubic> evenFib looks like filter even . fmap fib  then?
18:55:37 <xkcd> I know that way
18:55:38 <hiptobecubic> where hopefully it's always being applied to [1..]
18:56:13 <xkcd> What is wrong with this implementation
18:56:18 <hiptobecubic> well assuming `fib n` computes the n'th fib?
18:56:33 <xkcd> GHCI says The type signature for `evenFib' lacks an accompanying binding
18:56:34 <xkcd> Failed, modules loaded: none.
18:56:46 <xkcd> fib n is working fine
18:56:47 <hiptobecubic> and then xs is the list of indexes of fibs you want to consider
18:56:54 <niteria> function names are case-sensitive
18:56:54 <aavogt> xkcd: use the same capitalization
18:57:00 <hiptobecubic> evenFib != evenfib
18:57:14 <xkcd> Oh Sorry its a typo
18:57:21 <aavogt> @quote stereo
18:57:21 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
18:57:22 <xkcd> I wrote it properly
18:57:27 <hiptobecubic> :D
18:57:41 <shachaf> That's not even a quote, is it?
18:58:49 <hiptobecubic> looks like a quote to me
18:59:02 <shachaf> Well, I don't think Cale ever said that.
18:59:08 <hiptobecubic> Sure he did
18:59:12 <hiptobecubic> It's right there, quoted.
19:00:31 <Saizan> shachaf: might have been majestic?
19:00:35 <hiptobecubic> dmwit, fmap applies an f :: b -> c  to PreList a b, but I need a way to apply g :: PreList a b -> c to b. Is there some kind of obvious backwards fmap or something? My brain is melting
19:00:40 <shachaf> Saizan: That is what I remember.
19:00:51 <niteria> are actors a good abstraction in haskell?
19:00:58 <hiptobecubic> dmwit, 'apply' is used loosely thre
19:01:00 <hiptobecubic> there*
19:01:30 <xkcd> hiptobecubic: I am actually trying to solve this problem https://projecteuler.net/problem=2 But Recursion seems to take a lot of time is there any other way to calculate fib number and store them
19:01:33 <Saizan> shachaf: the quote got deleted for overuse, i guess it didn't replicate well
19:01:48 <hiptobecubic> niteria, there is an interesting video by a danish guy that implemented bittorrent in both haskell and erlang. He seemed to think that actors didn't work as nicely as just using STM.
19:01:50 <shachaf> Saizan: Someone added it back, except they didn't even add it correctly.
19:02:23 <Saizan> shachaf: yeah that's what i meant by replicate
19:02:35 <elliott> quotes are deleted for overuse?
19:02:38 <elliott> someone should tell @faq.
19:02:38 <niteria> hiptobecubic: that would be interesting to watch, do you happen to have a link?
19:02:54 <hiptobecubic> xkcd, well you need the previous fib, the current fib, and the total so far as you march towards n, yes?
19:03:19 <xkcd> Only the even fib
19:03:36 <hiptobecubic> niteria, http://www.infoq.com/interviews/haskell-erlang-p2p-implementation?utm_source=infoq&utm_medium=related_content_link&utm_campaign=relatedContent_interviews_clk
19:04:15 <hiptobecubic> xkcd, you don't know if it's even until you compute it, though
19:05:35 <xkcd> hiptobecubic: yeah That's true I am unable to the non-imperative way
19:05:36 <niteria> actually you do
19:05:40 <niteria> hiptobecubic: thanks
19:05:45 <hiptobecubic> well sure, you could change your algorithm
19:06:07 <niteria> every third is even
19:06:12 <niteria> but that doesn't matter
19:07:11 <niteria> > let next (a, b) = (b, a + b) in take 10 $ iterate next (1,1)
19:07:13 <lambdabot>   [(1,1),(1,2),(2,3),(3,5),(5,8),(8,13),(13,21),(21,34),(34,55),(55,89)]
19:07:43 <niteria> you only need two previous fibs to compute next fib
19:08:00 <beaky> how do I break away from the imperative mindset and write code the proper, functional way?
19:08:04 <hiptobecubic> yes, but we want to compute the sum of the even ones as we go
19:08:15 <hiptobecubic> beaky, drink some orange juice
19:08:48 <beaky> purely-functional fruit juice... mm...
19:09:23 <beaky> but my code spends os much time int he IO monad
19:09:34 <hiptobecubic> so don't
19:09:46 <hiptobecubic> are you printing everywhere?
19:10:51 <niteria> > let next (a, b) = (b, a + b) in take 5 $ (scanl (+) 0) . (filter even) . (map fst) $ iterate next (1,1)
19:10:51 <koninkje> beaky: well, one way would be to recognize that loops (e.g., for-loops, while-loops) are just a special case of recursion
19:10:52 * BadKitty is disapointed that java doesn't have the same as _
19:10:53 <lambdabot>   [0,2,10,44,188]
19:10:58 <BadKitty> Haskell ♥:)
19:11:41 <koninkje> beaky: with that insight in hand, it's worthwhile to take a look at the State monad--- in particular, the implementation and what it's really doing under the covers
19:11:58 <hiptobecubic> koninkje, i sent this to dmwit earlier, but it's (perhaps more) relevant for you.    fmap applies an f :: b -> c  to PreList a b, but I need a way to apply g :: PreList a b -> c to b. Is there some kind of obvious backwards fmap or something? My brain is melting
19:12:06 <koninkje> Imperative programming is just functional programming without the rigor
19:12:19 <hiptobecubic> heh
19:12:29 <xkcd> niteria: Actually my problem is how to use a already defined function in another function. GHCI is giving this error
19:12:31 <xkcd>     The type signature for `evenFib' lacks an accompanying binding
19:12:32 <xkcd> Failed, modules loaded: none.
19:12:35 <koninkje> fmap is "backwards" fmap...
19:12:53 <koninkje> hiptobecubic: what's your implementation look like so far?
19:13:45 <arkeet> xkcd: "let evenFib :: ... ; evenFib ... = ..."
19:13:45 <niteria> xkcd: wasn't the problem with capitalization?
19:13:58 <niteria> oh ghci
19:14:04 <xkcd> Nope it isn't
19:14:04 <arkeet> with one let.
19:14:07 <beaky> http://ideone.com/DFl8rR how do I implement the equivalent of 'break' and 'continue' if I want to do imperative-style loops in haskell?
19:14:08 <koninkje> hiptobecubic: if you need to apply (PreList a b -> c) to b, you're missing something... where'd c come from?
19:14:13 <hiptobecubic> it looks like  cata f = undefined, but sometimes i write fmap unstead of undefined and then squint it at really hard
19:14:14 <arkeet> and on one line, unless you turn on multi-line input
19:14:16 <beaky> I want to break out of the loop if I parse a zero
19:14:22 <hiptobecubic> at it*
19:14:47 <niteria> beaky: ContT
19:14:51 <arkeet> niteria: no please no
19:14:52 <arkeet> beaky: you can use MaybeT
19:15:02 <hiptobecubic> koninkje, maybe that was poorly worded
19:15:21 <niteria> what's wrong with ContT?
19:15:23 <arkeet> beaky: how come you don't use hpaste?
19:15:24 <hiptobecubic> koninkje, fmap sends f:: a->b  to g :: Prelist a b -> Prelist a c
19:15:29 <arkeet> niteria: it's way overkill
19:15:30 <hiptobecubic> err f :: a -> c
19:15:33 <arkeet> and harder to understand
19:15:40 <xkcd> niteria: Sorry I have been thinking I didn't  make capitilization error I made sorry
19:16:06 <beaky> ah I jeep forgeting to use hpaste
19:16:19 <hiptobecubic> koninkje, and cata :: (P a b -> b) -> (L a -> b)
19:16:50 <hpaste> arkeet pasted “beaky” at http://hpaste.org/84585
19:16:51 <niteria> I guess you can have break with MaybeT
19:16:51 <koninkje> hiptobecubic: hint: you can't do anything with List a directly, so the first thing to do will be to unroll the list. Thus, cata f = _ . unroll
19:16:56 <niteria> but continue?
19:17:13 <beaky> so to convert all those for-loops into haskell, I just use recusion?
19:17:17 <hiptobecubic> koninkje, i had that, but that assumes that you have a list, which doesn't unify with b
19:17:25 <xkcd>  let next (a, b) = (b, a + b) in take 10 $ iterate next (1,1)
19:17:27 <xkcd> let next (a, b) = (b, a + b) in take 5 $ (scanl (+) 0) . (filter even) . (map fst) $ iterate next (1,1)
19:17:29 <xkcd> Can you explain these niteria  I have been reading Learn you a haskell  I have reached Higher order functions in that I haven't seen iterate anywhere?
19:17:36 <otters> @src iterate
19:17:37 <lambdabot> iterate f x =  x : iterate f (f x)
19:17:38 <arkeet> > iterate f x
19:17:40 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
19:17:52 <koninkje> hiptobecubic: another hint: cata is going to transform things from the bottom up
19:18:08 <hiptobecubic> hm
19:18:28 <hiptobecubic> ah yes
19:18:34 <hiptobecubic> that's why this fmap doesn't touch a?
19:18:35 <arkeet> niteria: "continue" is easy, just quit the loop body early
19:18:53 <hiptobecubic> throw an error and use spoon :D  done
19:19:09 <koninkje> hiptobecubic: cata (f :: P a b -> b) = (_ :: P a (L a) -> b) . unroll
19:19:32 <hiptobecubic> i have that for f
19:19:57 <koninkje> it doesn't matter what b is... so long as you fill in _ in the right way
19:20:08 <hiptobecubic> what is the type of unroll
19:20:17 <hiptobecubic> I have   L a -> P a (L a)
19:20:24 <koninkje> right
19:20:34 <beaky> http://ideone.com/k2xcpu wow recursion is more elegant than looping :D
19:20:44 <beaky> but is recursion ppoor style in haskell?
19:20:45 <arkeet> beaky: did you see my paste?
19:20:55 <koninkje> in pointful style we have, cata (f :: P a b -> b) (x :: L a) = _ (unroll x)
19:21:17 <beaky> ah this one? http://hpaste.org/84585
19:21:20 <arkeet> yes
19:21:36 <arkeet> in fact, with the result value of runMaybeT (which is Nothing or Just ()), you can tell whether it exited early.
19:21:55 <beaky> :t mzero
19:21:56 <lambdabot> MonadPlus m => m a
19:22:02 <arkeet> mzero is like Nothing
19:22:04 <beaky> ooh monadplus
19:22:08 <koninkje> hiptobecubic: also, note that we only know of one way to make (an arbitrary) b: by using the function argument. Thus, cata f x = f (_ (unroll x))
19:22:49 <arkeet> beaky: you can of course do stuff before exiting out: ... then putStrLn "Ok" >> mzero
19:23:03 <arkeet> er, liftIO there.
19:23:34 <beaky> :t liftIO
19:23:36 <lambdabot> MonadIO m => IO a -> m a
19:23:42 <arkeet> IO a -> MaybeT IO a
19:24:06 <beaky> so it puts a monad on top of the IO monad?
19:24:16 <arkeet> MaybeT is a monad transformer.
19:25:05 <hiptobecubic> MonadIO is "monad's which can also do IO" so you can send IO a into MonadIO m => m a and it can still do it
19:25:25 <hiptobecubic> koninkje, banging away again.
19:25:32 <koninkje> :)
19:26:21 <arkeet> beaky: are you familiar with the Maybe monad?
19:27:46 <beaky> yes
19:28:13 <arkeet> so you know that Nothing lets you exit out of a (pure) computation early.
19:28:25 <arkeet> MaybeT lets you do the same thing, except combined with other monads.
19:28:56 <beaky> ah
19:30:21 <beaky> git log
19:30:28 <arkeet> :)
19:30:28 <beaky> oops wrong window
19:31:09 <skyflash_> Is there a way to enumerate Haskell functions matching type _at runtime_ e.g. introspection?  I'd like to enumerate public functions that match, say, Int -> Int in a module or modules.
19:31:38 <arbn> skyflash_: This doesn't sound very safe.
19:31:50 <tac> skyflash_: That kind of behavior would be in the realm of metaprogramming
19:32:02 <skyflash_> That's the realm I'm talking about.
19:32:03 <tac> Static typing makes metaprogramming more difficult than in a language like Ruby or Python
19:32:12 <beaky> or lisp :)
19:32:21 <tac> You have to jump through more hoops to get it, but it's possible (in some limited ways)
19:32:49 <arbn> https://www.youtube.com/watch?v=5-OjTPj7K54
19:32:59 <tac> skyflash_: Most Haskellers will consider unlimited metaprogramming as "unsafe" (in a technical sense of the word)
19:33:12 <tac> and type-safe metaprogramming is a current area of research
19:33:26 <tac> tl;dr, look at template haskell :)
19:33:46 <arkeet> TH is at compile-time.
19:34:03 <geekosaur> you may be thinking of hint?
19:34:04 <skyflash_> We (that is my company) use CAL (http://en.wikipedia.org/wiki/CAL_(Quark_Framework)#CAL) in our product.  We are thinking of moving to Haskell.  However, CAL has very powerful metaprogramming features.
19:34:05 <arkeet> if you want to look at code at runtime you'll need something like hint
19:34:48 <hiptobecubic> koninkje, this is what i'm not understanding. I see why we have this error, but how could we have anything else?  "Expected type: List a -> PreList a b Actual type:     List a -> PreList a (List a) In the second argument of `(.)', namely `unroll'"
19:34:51 <arbn> skyflash_: Consider making your code safer as you move it to Haskell. You might not *need* the metaprogramming.
19:35:13 <geekosaur> but as peole have said, type-safe metaprogramming is an open research area, there aren't many tools available to even attempt it
19:35:18 <hiptobecubic> unroll forces us to have b ~ List a
19:37:26 <BadKitty> Hmm
19:37:36 <skyflash_> arbn: Well, our tools are built on a principles of introspecting little combinator libraries that define combinators for pieces of a larger model.  The UI's then let users build models based on these available pieces (which are extensible).
19:38:07 <skyflash_> So, I was hoping to be able to do something similar in Haskell.
19:38:50 <skyflash_> I could probably keep separate data structures than source to have an encyclopedia of available pieces, but that seems redundant.
19:38:52 <hiptobecubic> skyflash_, why switch if what you have works?
19:39:10 <BadKitty> intToBase62 i = showIntAtBase 62 (b62 !!) i "" -- Should I have | i < 0 = error $ "Data.Base62: Applied to a negative number. " ++ show i -- or leave that error to just have Numeral.showIntAtBase ?
19:40:29 <skyflash_> hiptobecubic: Good question :-)  Well, naturally there are some features that we're excited about coming in Haskell, DPH is one.   We don't want to invest time augmenting CAL to replicate this.
19:40:47 <BadKitty> Question in short, should I lift the error?
19:41:17 <koninkje> hiptobecubic: nope. If we start with (x :: L a), then using unroll just means we have (unroll x :: P a (L a))... there's no b yet
19:41:21 <TravisD> Is there a built in function to find the index of the maximum element of a list?
19:42:16 <koninkje> hiptobecubic: remember, you'll need to use recursion. So, cata f = let rec = f . _ . unroll in \x -> rec x
19:42:33 <koninkje> where you use rec somewhere in _
19:43:44 <koninkje> (of course, you don't need to give a name to rec. You could just do, cata f = f . (...(cata f)...) . unroll
19:46:24 <hiptobecubic> hm
19:49:02 <beaky> hello
19:49:06 <BadKitty> hello
19:49:15 <beaky> I translated my imperative code to haskell, but it got out of hand :(
19:49:20 <BadKitty> beaky: What's up today?
19:49:31 <BadKitty> Share code
19:49:49 <BadKitty> s/$/!!/
19:49:51 <beaky> http://ideone.com/jT1xX8 this code solves for a '?' in the input
19:49:57 <beaky> how do I improve the elegance of the code?
19:50:15 <hiptobecubic> beaky, leather gloves
19:50:19 <Arc_Koen> well you have to check with the three elegance criteria
19:50:19 <BadKitty> Whoah
19:51:00 <otters> how do I make hackage document my package?
19:51:11 <arkeet> I think you wait.
19:51:11 <arkeet> :(
19:51:15 <otters> oh
19:51:25 <BadKitty> beaky: May I have the imperative version?
19:51:49 <hiptobecubic> ok it typechecks, but honestly I don't *see it*. It just compiles
19:51:54 <hiptobecubic> koninkje, ^
19:52:13 <koninkje> hiptobecubic: what'd you get?
19:52:25 <hiptobecubic> cata f = f . fmap (cata f) . unroll
19:52:32 * koninkje nods
19:52:35 <hiptobecubic> ana f = roll . fmap (ana f) . f
19:52:36 <beaky> BadKitty: http://ideone.com/Pv99N6
19:52:49 <BadKitty> Both ugly :D
19:52:56 <koninkje> hiptobecubic: cata performs a bottom-up traversal of some recursive type
19:53:04 <beaky> yeah :(
19:53:07 <arkeet> beaky: what is it supposed to do?
19:53:21 <BadKitty> arkeet: 5 + ? = 10 returning 5
19:53:22 <beaky> arkeet: it reads a single equation and solves for '?'
19:53:29 <koninkje> hiptobecubic: so, if we start with x::L a, first we unroll it... which just changes the type, nothing interesting...
19:53:30 <beaky> and the equation only has pluses or minuses
19:53:34 <beaky> no parens :D
19:53:46 <arkeet> you should use a parser.
19:53:55 <arkeet> :s
19:54:03 <BadKitty> beaky: Use guards
19:54:08 <koninkje> hiptobecubic: And then we say, hey I can convert L a into b by using cata f... so we map over the layer we just unrolled...
19:54:30 <beaky> a handrolles recursive-descent/operator precedence parser or Parsec just for this toy problem? :D
19:54:34 <beaky> handroled*
19:54:38 <koninkje> hiptobecubic: [recurse] after we're done with that step we have some P a b, where the b is what we got from recursion...
19:54:49 <hpaste> hiptobecubic pasted “Cata:Ana” at http://hpaste.org/84586
19:54:58 <koninkje> hiptobecubic: And now we can use f to crunch P a b down into b
19:55:18 <beaky> hmm this is actually a very nice problem to learn how to write a proper parser in Haskell :D
19:55:31 <koninkje> hiptobecubic: does that make sense?
19:55:55 <hiptobecubic> koninkje, not yet :D
19:56:01 <BadKitty> beaky: parsec
19:56:07 <koninkje> hiptobecubic: the idea is, via recursion, we unroll all the way down to the bottom; and then we apply f at each level in order to get rid of the bottom level
19:56:11 <dmwit> hiptobecubic: It may help to observe that cata is foldr and ana is unfoldr when we're talking about [a].
19:56:21 <hiptobecubic> koninkje, we unroll first, but then the next thing you do is "map over the layer we unrolled"
19:56:31 <hiptobecubic> but we unrolled that layer, so what are you referring to
19:56:46 <hiptobecubic> dmwit, christ. Not yet. :D
19:57:16 <koninkje> x :: L a ---> unroll x :: P a (L a) ---> fmap (cata f :: L a -> b) (unroll x) :: P a b
19:57:27 <shachaf> I,I foldr :: (Maybe (a,b) -> b) -> [a] -> b
19:57:47 <arkeet> no shachaf
19:57:53 <koninkje> hiptobecubic: we're fmapping over the (P a) part of P a (L a) in order to get our hands at the L a
19:58:12 <shachaf> arkeet: What is it this time?
19:58:17 <Nisstyre-laptop> koninkje: okay, "fmapping" is a potentially misreadable word
19:58:21 <arkeet> shachaf: you're terrible.
19:58:28 <arkeet> never mind
19:58:29 <koninkje> Nisstyre-laptop: er, yes...
19:58:44 <shachaf> arkeet: I'm terrible? How about you're terrible?
19:58:48 <arkeet> I am.
19:59:36 <beaky> my code is terrible :(
20:00:00 <hiptobecubic> beaky, lol
20:00:03 <shachaf> beaky: Does your code make puns?
20:00:05 <hpaste> beaky pasted “Ugly code” at http://hpaste.org/84587
20:00:29 <beaky> I followed hlint's suggestions but it still depends a lot on ugly recursion
20:00:50 <dmwit> hiptobecubic: Okay, here's another attempt. How do we collapse a list into a value of some other type? Answer: first, we collapse the tail (if there is one), then we combine the head with the collapsed value to get an even collapsed-er value.
20:01:03 <beaky> (btw TIL that if-then-else can return things other than Bools)
20:01:13 <hiptobecubic> dmwit, yes. We do, indeed, do that.
20:01:38 <dmwit> hiptobecubic: Now, in terms of the things you wrote: "cata" is the function for collapsing. "fmap cata" is the function that collapses the tail (if there is one). "f", the argument to cata, is the part that combines the head with the collapsed value.
20:01:49 <hiptobecubic> beaky, if then else is ugly. if' is nicer
20:02:03 <beaky> :t if'
20:02:04 <lambdabot>     Not in scope: if'
20:02:04 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
20:02:11 <hiptobecubic> hm
20:02:22 <dmwit> hiptobecubic: ...and all the rest is bookkeeping that we have to do because we're using Mu (PreList a) instead of a directly recursive type.
20:02:38 <hiptobecubic> beaky, from lisp's cond, if' p a b = if p then a else b
20:02:49 <hiptobecubic> dmwit, hmm
20:03:05 <otters> what do I do if cabal says
20:03:14 <koninkje> beaky: don't forget, you can use guard syntax on case patterns too
20:03:14 <otters> "Could not resolve dependencies:"
20:03:20 <dmwit> This stuff is a lot easier to do in person when you can share a whiteboard. =P
20:03:23 <hiptobecubic> dmwit, yes
20:03:37 <otters> oh whoops never mind
20:03:41 <koninkje> beaky: Also, it helps to have the "case...of" on its own line and aligned with the patterns
20:03:46 * hackagebot haspell 0.2.0.0 - Haskell bindings to aspell  http://hackage.haskell.org/package/haspell-0.2.0.0 (JoelTaylor)
20:03:47 <beaky> ah
20:03:48 * hackagebot haspell 1.0.0 - Haskell bindings to aspell  http://hackage.haskell.org/package/haspell-1.0.0 (JoelTaylor)
20:04:31 <beaky> how do I get rid of all those parameters piggybacking through go for the algorithm :D
20:05:19 <hiptobecubic> beaky, you were right. this is hideous
20:06:01 * beaky is the worst haskell programmer ever
20:06:16 <koninkje> beaky: since the parameters are booleans, you could always unfold/specialize things (e.g., define goTTT ~ go _ True True True; goTTF ~ go _ True True False;,...)
20:06:28 <koninkje> beaky: I'm not sure that'll really help here though
20:06:34 <koninkje> it's just a general trick/pattern
20:06:52 <beaky> ah partial function application
20:07:32 <koninkje> no no, I mean, instead of having a single function "go" which takes all thpse parameters; instead have a number of different functions which achieves the same effect
20:07:35 <BadKitty> beaky: I'm re-writing it and I've seemed to find an issue for me :(
20:08:12 <dmwit> hiptobecubic: If you can spot the lie I told in the bit that starts "Now, in terms of the things...", you get one Internet Point -- and perhaps one Understanding Mu Types Point. =)
20:08:20 <koninkje> e.g., if we had "foo x True = blah; foo x False = blargh" then we could instead have "foo_True x = blah; foo_False x = blargh"
20:08:29 <koninkje> ...with better names, hopefully
20:08:34 <hiptobecubic> dmwit, hmmm. Well points *are* important.
20:08:46 * hackagebot WordNet-ghc74 0.1.2 - Haskell interface to the WordNet database  http://hackage.haskell.org/package/WordNet-ghc74-0.1.2 (JoelTaylor)
20:09:17 <dmwit> Huh! There was no wordnet package already?
20:09:22 <dmwit> What does \bot use?
20:09:43 <geekosaur> I think it was not split out before, but various things in the bot are now being split?
20:09:44 <hiptobecubic> dmwit, foldr -> foldr1 ?
20:10:06 <dmwit> It really is foldr, but you're quite close.
20:10:13 <hiptobecubic> balls
20:10:20 <hiptobecubic> now i have to figure out why it looks like foldr1
20:10:38 <dmwit> Yes! That will certainly earn you one Understanding Cata Point.
20:11:01 <hiptobecubic> :t foldr
20:11:03 <lambdabot> (a -> b -> b) -> b -> [a] -> b
20:12:40 <dmwit> TIL Hackage categories are not case sensitive
20:12:48 <tgeeky> dmwit: nope, strings baby
20:13:02 <dmwit> ?
20:13:06 <dmwit> strings are case sensitive
20:13:19 <tgeeky> oh, well, /i strings :o
20:13:25 <tac> quotiented strings
20:13:37 <tgeeky> I asked once if I could put a domain name as a category name, and I think Russ or Ross or whoever said yes, it's possible.
20:13:43 <tac> strings / ~       where   x ~ toLower x for all x
20:14:09 <beaky> how do I read a file in haskell
20:14:14 <dmwit> :t readFile
20:14:15 <lambdabot> FilePath -> IO String
20:14:19 <beaky> ah thanks
20:14:21 <tdm> hi, can someone point me to some good resources on type inference and unification...preferably layman. thanks!
20:14:41 <dmwit> What kind of resource?
20:14:56 <tdm> lecture or tutorial
20:15:01 <beaky> do i need to close the file, or does haskell automatically clode it?
20:15:15 <hiptobecubic> do *not* close it
20:15:15 <tac> ergg.... how do you figure out what modules a package exposes again?
20:15:20 <dmwit> Haskell automatically closes it when you reach the [] of the returned String.
20:15:29 <hiptobecubic> beaky, if you are using lazy IO you are not allowed to close it yourself
20:15:34 <dmwit> If you need more control than that, you must use openFile and closeFile yourself.
20:15:37 <beaky> ah
20:15:46 <beaky> so haskell has C++-style dtors to close it?
20:15:49 <dmwit> tac: Look on Hackage. =)
20:15:53 <tgeeky> beaky: poke around where you find readFile, and you'll see the various options
20:16:02 <dmwit> tdm: I don't know of any such resources.
20:16:03 <tgeeky> (on Hackage)
20:16:21 <tac> hmm
20:16:34 <tac> apparently I have a different version than the latest for this package
20:16:42 <tac> or rather... the latest isn't publised on hackage.
20:16:44 <dmwit> tac: Or use cabal info, I guess.
20:18:05 <tgeeky> tdm: https://www.youtube.com/watch?v=fDTt_uo0F-g <-- I have never seen this before, but it is only 1 hour long
20:18:10 <BadKitty> tgeeky: I hate it when hackage is out of date
20:18:13 <BadKitty> tgeeky: ignore that
20:18:15 <BadKitty> tac: ^
20:18:21 <tgeeky> BadKitty: ignored
20:18:30 <BadKitty> :)
20:18:46 <tac> I'm ignoring everything right now that doesn't help me figure out how to get zeromq working in haskell
20:20:45 <tgeeky> tac: *surely* you have found this already: http://hackage.haskell.org/package/zeromq-haskell-0.8.4
20:21:03 <tac> Yes. That was the first of the three things I found
20:21:12 <tac> There's also zeromq3-haskell-0.2 (which I have installed)
20:21:25 <tac> and zeromq3-haskell-0.3 (which is the latest version, but not available on Hackage)
20:21:30 <tdm> tgeeky: thanks
20:22:03 <tgeeky> tdm: it's likely that the best sources for type inferrence are going to be highly technical, like the Simon Peyton Jones paper about type inferrence in GADTs
20:22:25 <otters> when does the package list get updated?
20:22:34 <tgeeky> otters: every minute or so
20:22:47 <otters> somebody try installing this http://hackage.haskell.org/package/WordNet-ghc74
20:23:01 <tgeeky> otters: please? not me, though, no GHC now
20:23:06 <Axman6> @hooogle comparing
20:23:06 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
20:23:15 <tdm> tgeeky: yeah, I've read it a couple of times now..it's quite dense
20:23:30 <otters> please
20:23:36 <dmwit> otters: Your local Hackage information is updated only when you "cabal update"; perhaps you forgot to do this?
20:23:41 <otters> i've done that multiple times
20:24:28 <dmwit> huh
20:24:37 <dmwit> Possibly a bug in cabal.
20:26:10 <tgeeky> perhaps the problem is that both "WordNet" and "WordNet-ghc74" exist? I don't know why that would matter.
20:28:25 <otters> weird
20:29:18 * BadKitty got bored so made a rake pic with a bit of paper. :)
20:29:24 <BadKitty> card board *
20:30:25 <otters> nah, still won't install
20:30:29 <otters> can I list all remote packages?
20:30:37 <dmwit> cabal list can help
20:30:55 <otters> cabal list
20:31:11 <tgeeky> otters: Your console is this way -->
20:31:18 <otters> can I see the source of the package list? WordNet-ghc74 isn't shown
20:31:33 <tgeeky> otters: yes, you can look at the index directly
20:32:07 <dmwit> otters: You can look in ~/.cabal/packages/hackage.haskell.org/00-index.*
20:32:24 <tgeeky> perhaps this package was uploaded in the future?
20:32:30 <dmwit> Mine does not include WordNet-ghc74.
20:32:38 <geekosaur> hm, occurs ot me if you still have the mirror in place you may need for the mirror to update or switch back to main
20:32:39 <otters> But it's on hackage
20:33:16 <tgeeky> otters: how about older, but still new packages like haspell-1.0.0, or confsolve?
20:33:17 <dmwit> otters: I agree. Perhaps a case of "take two aspirin and call me in the morning if it's still a problem"...?
20:33:31 <otters> yeah, haspell is up
20:33:33 <otters> I just installed it
20:33:34 <dmwit> haspell is in my cache at three different versions
20:34:55 <geekosaur> I just updated, not using mirror, not present. hrm
20:35:07 <niteria> what's the state of Cloud Haskell?
20:35:18 <geekosaur> wait an hour in case they only generate the index in an hourly cronjob, then send up the bat-signal?
20:35:24 <tgeeky> niteria: it's being actively developed by people close to the GHC team, if I remember
20:35:51 <geekosaur> (I know the macports folks only regenerate stuff like that hourly, you need to access repos directly to get things sooner)
20:45:04 <arkeet> @ty let cataM f m = f =<< Data.Traversable.sequence (cataM f <$> out m) in cataM
20:45:06 <lambdabot> (Monad m, Traversable t) => (t a -> m a) -> Mu t -> m a
21:06:34 <otters> can anybody install WordNet-ghc74 yet
21:06:37 <otters> please
21:11:59 <arkeet> cabal: There is no package named 'WordNet-ghc74'.
21:12:12 <arkeet> (yes, I just ran cabal update.)
21:12:12 <arkeet> ???
21:12:27 <otters> dunno
21:12:31 <otters> it's weird
21:13:40 <BadKitty> Just wordnet
21:13:55 <otters> which doesn't compile on ghc 7.4
21:14:31 <arkeet> you can download the tarball and install it from there, though.
21:15:11 <otters> yeah, but sucks for .cabal dependencies
21:16:05 <dmwit> otters: (Did you contact Max Rabkin about updating WordNet itself?)
21:16:16 <otters> that didn't occur to me
21:16:27 <dmwit> You should do that.
21:16:30 <otters> I will
21:19:37 <BadKitty> hhh
21:19:37 <BadKitty> It's just wordnet
21:19:37 <BadKitty> lagg....?
21:19:45 <BadKitty> lagggg
21:20:14 <BadKitty> lol
21:23:05 <roconnor> @botsnack
21:23:05 <lambdabot> :)
21:26:16 <TravisD> Are there faster random number generators than StdGen?
21:27:31 <geekosaur> lots, actually. the mersenne twister on hackage is commonly used for fast random numbers
21:27:57 <TravisD> I'll test for myself, but do you have some idea of how much faster it is?
21:28:04 <hiptobecubic> mwc-random is also popular
21:28:07 <hiptobecubic> TravisD, *a lot*
21:28:14 <hiptobecubic> System.Random is slow as balls
21:28:22 <TravisD> oh, this is so pleasing
21:28:23 <hiptobecubic> Slow balls.
21:29:19 <hiptobecubic> TravisD, if you are generating lots of randoms, think about doing it up front and putting them in a vector or something as well
21:30:14 <dmwit> hiptobecubic: why?
21:30:57 <hiptobecubic> I had more luck doing it that way than sprinkling calls everywhere
21:31:04 <hiptobecubic> performance-wise, i mean
21:31:25 <TravisD> Ah
21:31:33 <dmwit> Strange. I wonder why.
21:31:35 <hiptobecubic> I guess profile first, of course :)
21:32:22 <TravisD> It's not a huge deal, my code is a few times slower than I'd like right now
21:32:38 <TravisD> switching to the mersenne twister will probably be enough :)
21:32:41 <TravisD> what does "mwc" stand for?
21:32:47 <hiptobecubic> I don't honestly know
21:33:06 <elliott> The uniform PRNG uses Marsaglia's MWC256 (also known as MWC8222) multiply-with-carry generator, which has a period of 2^8222 and fares well in tests of randomness. It is also extremely fast, between 2 and 3 times faster than the Mersenne Twister.
21:33:10 <elliott> presumably that :)
21:33:19 <hiptobecubic> there we go
21:34:48 <TravisD> hehe
21:34:50 <TravisD> that's great :)
21:35:21 <geekosaur> hiptobecubic, mwc-random *is* the mersenne twister
21:35:43 <hiptobecubic> geekosaur, not what elliott pasted? Which is apparently different?
21:35:55 <TravisD> oh
21:35:57 <geekosaur> hm, maybe 'm misremembering
21:35:59 <geekosaur> I thought it was
21:36:10 <hiptobecubic> There is another package for the mersenne specifically
21:36:16 <hiptobecubic> not that there can't be many
21:36:25 <geekosaur> oh, sorry
21:42:05 <TravisD> it surprises me a bit that MWC isn't an instance of RandomGen
21:42:29 <TravisD> er, System.Random.MWC.Gen
21:46:45 <geekosaur> that's deliberate. RandomGen requires a "split" method, IIRC, and there's a lot of question whether it's even doable for various PRNGs
21:47:29 <TravisD> Ah, I see. That makes sense
21:47:33 <geekosaur> (cryptographically secure splitting of the generator, so you can have guaranteed-uncorrelated PRNG seeds in different threads or etc.)
22:09:41 <hpaste> Haisheng pasted “max-two-dim-array” at http://hpaste.org/84590
22:28:10 <TravisD> Hmm, so it turns out that I actually need to be able to split my random number generators. Does anyone know of a more efficient instance of RandomGen?
22:33:08 <copumpkin> no
22:33:21 <copumpkin> and I think that "anyone" is actually covered by my answer
22:33:33 <copumpkin> there was some discussion about this a while ago on haskell-cafe I think
22:33:40 <copumpkin> about how nobody actually knew of a good way of doing that
22:33:48 <TravisD> copumpkin: I stumbled onto that and I'm reading it now
22:33:48 <copumpkin> and there was remarkably little research on the topic
22:43:27 <dmwit> TravisD: Can you stick everything in a big State monad, so everything shares the same generator?
22:44:40 <TravisD> dmwit: I am writing a small lazy random monad that splits in every bind. If I can't split then the order that the random numbers are generated in is fixed
22:45:15 <TravisD> and might lead to some nasty memory leaks
22:47:47 <dmwit> The order that random numbers are generated in is fixed anyway.
22:48:05 <dmwit> I'm not sure I understood the comment about memory leaks.
22:48:30 <dmwit> Is there a reason you're writing your own monad and not just using MonadRandom?
22:48:50 <TravisD> dmwit: mostly because I'm curious
22:49:28 <TravisD> dmwit: If I do something like: do xs <- someRandomList; x <- someRandomInt; ...
22:50:28 <TravisD> hmm, actually, something like: do x <- somethingRandom; y <- somethingElseRandom; ...
22:51:16 <TravisD> if I don't split in the bind, then getting the value of y forces x to be generated
22:51:22 <TravisD> (Sorry - I'm probably being very unclear)
22:51:34 <dmwit> I see.
22:52:02 <TravisD> and if x requires lots of random numbers, they might end up hanging around in memory
22:52:20 <Nawmad> can someone explain what a natural transformation is
22:52:46 <Nawmad> would someone please* explain^
22:55:45 <TravisD> dmwit: Does that make sense?
22:57:16 <dmwit> yep
22:58:10 <dmwit> Nawmad: There's lots of explanations online... could you say what you don't understand?
22:59:58 <Nawmad> I was hoping to get some pointers... I don't know where to start to understand...
23:00:17 <Nawmad> it seems that its impossible to understand functors without understanding natural transformations, nor natural transformations without functors
23:00:20 <Nawmad> vicious circle
23:01:08 <dmwit> Functors can definitely be understood without understanding natural transformations.
23:01:21 <Nawmad> >.>
23:02:10 <dmwit> ...maybe a better way forward is to ask: What makes you say understanding functors requires understanding natural transformations?
23:02:11 <elliott> natural transformations are much more relevant in category theory than haskell.
23:02:43 <Nawmad> >.> I just want to understand both but don't know where to start
23:03:25 <elliott> well, if you want to learn about natural transformations and things, a book on category theory is probably the right place. you can do natural transformations in haskell and they're even useful for some things but you definitely want to get to grips with Functor first.
23:03:40 <elliott> (which doesn't require a book on category theory :P)
23:03:41 <tac> Nawmad: ##categorytheory
23:04:05 <Nawmad> i already have the book "categories for the working mathematician" but it assumes so much terminology without explaining it
23:04:20 <Nawmad> it just doesnt feel honest and at times doesnt seem to make sense
23:05:06 <elliott> well, it also doesn't have all that much to do with haskell Functors in practice.
23:05:15 <Nawmad> >.>
23:07:37 <shachaf> Nawmad: Buying Mac Lane may not be the best approach for learning category theory starting from nothing.
23:07:50 <Rotaerk> Nawmad, try "Conceptual Mathematics"
23:07:54 <Nawmad> tie
23:07:56 <Nawmad> ite*
23:08:20 <dmwit> Ah, MacLane. The book where the "ten minutes per page" rule becomes "ten minutes per sentence".
23:09:21 <Nawmad> for me it was about an hour per sentance
23:09:32 <dmwit> Not bad!
23:09:45 <Nawmad> i'm still on the sentance with cartesian product
23:09:54 <Nawmad> >.>
23:10:00 <shachaf> I've been alive for many years and haven't read *any* of Mac Lane yet!
23:10:13 <Nawmad> i want to read it by the time i die
23:11:53 <tgeeky> Nawmad: if you want, you could accelerate that process by convincing yourself you will die very soon. Perhaps you could take out a contract on your own life.
23:12:11 <Nawmad> that would be cheating
23:12:38 <tgeeky> it would be measurement!
23:13:53 <tgeeky> I think I've opened it once for a citation, not understood it, and went to sleep.
23:13:55 * hackagebot conduit 1.0.4.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.4.1 (MichaelSnoyman)
23:13:57 * hackagebot wai-extra 1.3.3.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.3.2 (MichaelSnoyman)
23:41:41 <dmj> Does anyone know if in peano arithmetic negation makes sense? I am attemping to implement peano arithmetic and the subtraction implementation is throwing off the absolute value implementation which is throwing off signum. This is not for homework, just for enjoyment
23:41:56 <hpaste> dmj pasted “dedekind axioms” at http://hpaste.org/84591
23:42:21 <shachaf> Negation does not make sense on natural numbers. You will have to use error.
23:42:52 <dmj> so how am I supposed to implement an absolute value?
23:43:07 <tgeeky> dmj: just return the number
23:43:14 <tgeeky> dmj: the result will never be negative
23:43:42 <dmj> shachaf: it will error everytime since the subtraction operator is evaluated first and there is no way to pattern match on negatives
23:44:17 <dmj> or am I wrong?
23:44:35 <shachaf> dmj: The Haskell numeric classes aren't a great source for learning about mathematical structures.
23:45:20 <shachaf> They more or less work for the built-in types. They are not suitable for natural numbers, for example.
23:46:08 <dmj> shachaf: I see what you're saying, I think this exercise was more an intro to typeclasses. But you were right, returning the number worked.
23:46:50 <hpaste> dmj revised “dedekind axioms”: “fixied” at http://hpaste.org/84591
23:46:57 <shachaf> tgeeky was right.
23:47:34 <dmj> tgeeky: shachaf: we still have a problem with signum though. It will never return -1
23:48:22 <tgeeky> dmj: that's not a problem, because (-1) doesn't exist with natural numbers
23:48:23 <dmj> tgeeky: shachaf: Is this a limitation of peano I must accept?
23:48:32 <feliperosa> Hey guys, does anyone has ever attempted to install york-lava before? It has a module also called Prelude and ghc is having some problem with that
23:48:38 <dmj> tgeeky: doh :)
23:49:32 <tgeeky> dmj: you can look at it as: natural numbers do not quite fit into the more feature-filled Num
23:50:23 <dmj> tgeeky: Ah I see, in math aren't the natural Numbers denoted Z+
23:50:30 <tgeeky> dmj: or, that the restrictions that the naturals impose don't cause Num do go wrong in any obvious way
23:50:32 <dmj> or is that integers
23:50:54 <hpaste> feliperosa pasted “Cabal ambiguity” at http://hpaste.org/84593
23:51:11 <feliperosa> What can I do about that error, could someone help me please?
23:51:15 <tgeeky> Z+ is, the positive integers, which are the natural numbers.
23:51:17 <tgeeky> I think?
23:51:35 <dmj> tgeeky: Yea I should've wikipedia'd first. It's just N
23:51:50 <tgeeky> dmj: yes, though I do believe people use Z+
23:52:04 <dmj> tgeeky: So much for remember my discrete math class
23:52:06 <tgeeky> dmj: in a sense, that is what you *are* constructing
23:52:10 <dmj> remembering*
23:52:43 <dmj> tgeeky: Yes, but the natural numbers are a round peg in a square hole in Haskell's num class.
23:53:38 <tgeeky> dmj: imho, the only problematic function is subtraction.
23:54:41 <dmj> tgeeky: since subtraction is a problem this poses a problem for signum as well right?
23:54:59 <tgeeky> dmj: no, just don't implement signum with subtraction
23:55:31 <tgeeky> dmj: the range of the signum function in this case is just [0, Positive]
23:55:42 <tgeeky> I'm sure someone will correct me if I'm being silly
23:58:53 <dmj> tgeeky: In theory it's right, but because the negation operator always evalutates the subtraction implementation I don't think its possible
23:59:38 <hpaste> dmj pasted “nat num” at http://hpaste.org/84594
23:59:56 <dmj> tgeeky: ok ignore the comments
