00:10:01 <ZWolf> Can anyone here see how one might go about converting a string into a decimal?
00:10:23 <aavogt> > read "123.456" :: Double
00:10:26 <lambdabot>   123.456
00:11:04 <ZWolf> No.. I mean.. 0 -> '000' 1 -> '001' ... something -> 'ZZZ'
00:11:16 <ZWolf> And vice versa
00:11:50 <ZWolf> /[a-zA-Z0-9]{16}/ to be exact.
00:12:17 <ZWolf> > 62^16
00:12:19 <lambdabot>   47672401706823533450263330816
00:12:22 <ZWolf> :)
00:12:52 <ZWolf> 47672401706823533450263330816 would be 9999999999999999 acturally.
00:13:13 <aavogt> @hoogle IntAtBase
00:13:13 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
00:13:46 <aavogt> and the inverse might be readInt in the same module
00:14:35 <ZWolf> aavogt: Example for using?
00:15:23 <hpaste> lightquake pasted “tables” at http://hpaste.org/83330
00:16:26 <aavogt> > showIntAtBase 9 (\x -> chr (x+ord 'a')) 1000 ""
00:16:27 <lambdabot>   "bddb"
00:17:16 <ZWolf> Hmm
00:17:19 <aavogt> I think you might have to list out your cases for the (Int -> Char) argument manually
00:17:25 <ZWolf> How about to what I'm trying? :P
00:17:29 <adas_> is there a way obtaining values of variables from C functions using FFI instead of only being able to call C functions?
00:17:33 <ZWolf> (16 of that range)
00:18:04 <aavogt> ZWolf: well you can split it up as two problems
00:18:13 <aavogt> first is get the number like  "abcde123"
00:18:20 <aavogt> second is add some leading zeros
00:19:06 <adas_> for functions i simply do foreign import <calling convention> <function>. Is there any special syntax if I simply want to obtain the value of a variable?
00:19:10 <`nand`> > "234.456" ^? base 10
00:19:12 <lambdabot>   Nothing
00:19:14 <`nand`> :(
00:19:28 <`nand`> edwardk!!
00:19:33 <`nand`> where's the Fractional equivalent?
00:19:48 <ZWolf> aavogt: What?
00:20:05 <uwjesd> Thanks for all the "help". Lol. F### haskell then and xmonad, too.
00:20:23 <ZWolf> uwWhat?
00:20:33 <ZWolf> noob
00:20:43 <ZWolf> Don't blame your tools!!
00:21:21 <ZWolf> ion even answered
00:22:41 <`nand`> F# and then Haskell? huh?
00:23:31 <aavogt> ZWolf: your issue with showIntAtBase is that it doesn't add any leading zeros?
00:23:56 <shachaf> ZWolf: Be nice.
00:24:18 <ZWolf> shachaf: I am. I even told him in a query. And now he is happy.
00:24:53 <ZWolf> `nand`: By F# He meant uck
00:25:14 <ZWolf> aavogt: No, I don't know how to use showIntAtBase :|
00:25:50 <shachaf> Well, aavogt demonstrated how it works above.
00:26:00 <ZWolf> Demonstrated.
00:26:05 * ZWolf still doesn't understand.
00:26:07 <shachaf> And Google can point you to a lot more examples.
00:26:16 <shachaf> And you can also figure it out yourself if you work at it. :-)
00:26:20 <shachaf> @google showIntAtBase examples
00:26:22 <lambdabot> http://stackoverflow.com/questions/1959715/how-to-print-integer-literals-in-binary-or-hex-in-haskell
00:26:22 <lambdabot> Title: How to print integer literals in binary or hex in haskell? - Stack Overflow
00:27:04 <ZWolf> Ughh
00:27:07 <ZWolf> :|
00:32:06 <`nand`> ZWolf: ..oh
00:32:31 <hpaste> edwardk annotated “tables” with “tables w/ inverted tag indexing” at http://hpaste.org/83330#a83333
00:34:51 <edwardk> `nand`: holler at ion and maybe he'll give you one
00:40:16 <ZWolf> `nand`: How would I have my (Int -> Char) for my selection of chars?
00:40:59 <ZWolf> aavogt: *
00:42:02 <aavogt> it'll be close to what that combination of chr ord in my example
00:42:37 <ZWolf> I didn't understand that part at all
00:42:38 <aavogt> worst-case you can write out      \x -> case x of 0 -> 'a'; 1 -> 'b'; 2 -> 'x'; ...
00:42:40 <ZWolf> :)
00:42:46 <ZWolf> Hehe D:
00:43:01 <aavogt> and then repeat yourself for the inverse
00:43:01 <ZWolf> s/x/c
00:43:12 <ZWolf> Or define that as a function?
00:43:24 <aavogt> yes, or define it in terms of existing functions
00:43:31 <aavogt> > chr 44
00:43:33 <lambdabot>   ','
00:43:51 <shachaf> map ("0123"!!) [0,1,2,3]
00:43:55 <shachaf> > map ("0123"!!) [0,1,2,3]
00:43:57 <lambdabot>   "0123"
00:44:57 <arkeet> > id "01234"
00:44:59 <lambdabot>   "01234"
00:45:01 <arkeet> er oops.
00:45:58 <hpaste> edwardk annotated “tables” with “tables w/ inverted tag indexing (annotation for lightquake)” at http://hpaste.org/83330#a83335
00:46:17 <ZWolf> aavogt: What about getting the char at an index?
00:47:01 <shachaf> arkeet: Yours adds an extra character at the end!
00:47:10 <shachaf> arkeet: So do you know things about modal logic?
00:47:11 <arkeet> I know. :(
00:47:14 <arkeet> no
00:47:23 <arkeet> but now that I'm on wikipedia, yes
00:47:37 <shachaf> How would you talk about it in Haskell?
00:47:39 <arkeet> oh, I've heard of this.
00:47:45 <arkeet> I have no clue.
00:47:47 <ZWolf> aavogt: f i = (['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9']) !! i
00:47:49 <ZWolf> Hehe
00:48:07 <shachaf> Square behaves sort of like comonad-minus-functor
00:48:17 <aavogt> ZWolf: sure. That approach is good enough for shachaf.
00:49:08 <arkeet> shachaf: minus functor?
00:49:27 <shachaf> arkeet: You have Sa -> a, and Sa -> SSa
00:49:28 <arkeet> I see a thing called a normal modal logic.
00:49:39 <arkeet> which looks like functor.
00:49:40 <shachaf> And S(a -> b) -> Sa -> Sb, but not (a -> b) -> Sa -> Sb
00:49:54 <arkeet> oh.
00:49:56 <arkeet> never mind.
00:49:59 <shachaf> Which makes sense.
00:50:22 <shachaf> Something like Cont can be Functor, because it's describing a logic stronger than Haskell.
00:50:38 <shachaf> But you can't have (a -> b) -> Fa -> Fb for a *weaker* logic.
00:52:45 <`nand`> shachaf: makes sense
00:56:22 <shachaf> arkeet: Actually maybe not.
00:56:31 <shachaf> I'm confused about the axioms here.
00:56:38 <shachaf> Can you pick a good set of axioms?
01:00:51 <arkeet> I don't know anything about modal logic.
01:01:25 <arkeet> I could ask someone who knew something about modal logic, at least when I talked to him a couple years ago. I wouldn't be surprised if he has forgotten by now.
01:04:15 <ZWolf> (['0'..'9'] ++ ['a'..'z'] ++ ['A'..'Z']) !! i -- Any good way to improve that?
01:04:58 <arkeet> I don't think it could be made much prettier.
01:05:02 <arkeet> although no doubt it could be made faster.
01:05:28 <ZWolf> bs magic?
01:05:52 <arkeet> what does bs have to do with anything?
01:06:11 <arkeet> these are Chars. :p
01:06:20 <ZWolf> I know.
01:06:22 <arkeet> so a Char array or so.
01:06:28 <ZWolf> [Char]
01:06:34 <ZWolf> list /= array
01:06:35 <arkeet> no, an array.
01:06:37 <arkeet> not a linked list.
01:07:01 <arkeet> also, in any case it could be made safer.
01:07:39 <shachaf> ZWolf: Why do you keep changing your nick?
01:07:43 <ZWolf> shachaf: Sorry
01:08:27 * M30W legit has 128 diff nicks. 64 groups, 32 unique.
01:11:13 <mjrosenb> M30W: why do you have so many?
01:12:43 <M30W> mjrosenb: No idea... IRC + Too much time = think of too many and give up in groups
01:12:46 <M30W> :P
01:13:03 <`nand`> gotta live on the edge, escape dem bans
01:14:12 <M30W> `nand`: Hehe
01:16:06 <M30W> Friend complains about haskell code easily becoming one-liners. So I send him the one liner version of my token generator (That currently doesn't pass with zeros)
01:16:07 <kini> M30W: you could use ord and chr, though I doubt it would be faster over such a small range
01:16:11 <M30W> (\i -> showIntAtBase 16 (\n -> (['0'..'9'] ++ ['a'..'z'] ++ ['A'..'Z']) !! n) i "") <$> randomRIO (0, 62^16)
01:16:36 <kini> and it would also be uglier lol
01:16:43 <M30W> :P
01:17:39 <M30W> Hmm
01:18:51 <M30W> What is the oppisite to showIntAtBase ?
01:19:21 <M30W> opposite *
01:21:00 <shachaf> aavogt answered that question an hour ago.
01:21:27 <M30W> srhb: I thought so but I looked up and couldn't find it :|
01:23:41 <M30W> shachaf: I sill can't find it :|
01:24:04 <shachaf> 00:13
01:24:53 <M30W> shachaf: That helps
01:24:58 <M30W> 04:23
01:25:22 <M30W> It does
01:25:23 <M30W> Minutes
01:25:25 <M30W> shachaf: ♥
01:26:18 <ski_> @type readInt  -- M30W, perhaps ?
01:26:19 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
01:26:24 <M30W> Yea
01:27:01 * M30W needs a char->bool function now
01:27:40 <ski_> @type (`elem` "0123456")
01:27:41 <lambdabot> Char -> Bool
01:27:55 <mauke> :t isDigit
01:27:56 <lambdabot> Char -> Bool
01:28:03 <M30W> I know
01:28:04 <M30W> :P
01:28:10 <ski_> > isDigit 'F'
01:28:11 <lambdabot>   False
01:28:33 <adas_> is there a way to obtain the value of a double variable in C and put it in haskell?
01:28:50 <mauke> yes
01:29:05 <adas_> i tried the 'def' directive in hsc2hs but i keep getting "missing symbols" in ghci
01:29:20 <mauke> you're not supposed to use hsc2hs
01:29:41 <mauke> is this a global variable in a C library?
01:30:23 <adas_> mauke: its a variable in the math.h library and i am sure it must be a global variable cos the variable name is in CAPS
01:30:38 <mauke> wrong
01:30:52 <mauke> if it's in CAPS, then it's not a variable but a macro
01:31:11 <mauke> also, math.h is not a library
01:31:20 <mauke> :-|
01:31:23 <mjrosenb> and macros are more difficult to import
01:31:26 <adas_> mauke: sory.. header file yea
01:31:44 <ski_> hm, should we have an easier way to grovel ?
01:31:52 <adas_> adas_: the documentation in the math.h file says that its a constant with type double
01:31:55 <shachaf> ∶—¦
01:32:10 <mjrosenb> adas_: what constant?
01:32:20 <mjrosenb> err, variable.
01:32:21 <srhb> Does this page exist in full length somewhere? http://web.archive.org/web/20090421010040/http://www.haskell.org/bz/th3.htm
01:32:30 <adas_> M_SQRT2 in math.h
01:32:46 <mjrosenb> adas_: i'd just define it in haskell.
01:32:54 <mauke> adas_: why do you need to use that specific macro?
01:33:15 <mjrosenb> > let x = sqrt 2 in x
01:33:17 <lambdabot>   1.4142135623730951
01:33:34 <shachaf> > let x = let y = sqrt 2 in y in x
01:33:36 <lambdabot>   1.4142135623730951
01:33:50 <mauke> > let x = y; y = sqrt 2 in y
01:33:51 <M30W> Hmm
01:33:52 <lambdabot>   1.4142135623730951
01:34:00 <adas_> mauke: im trying to learn how to use the ffi because i want to write bindings for the "wiringpi" library to access GPIO pins in the raspberry pi
01:34:11 <mauke> adas_: ok, but this has nothing to do with the FFI per se
01:34:25 <adas_> mauke: but the wiring pi lib is written in C
01:34:34 <mauke> yes
01:34:38 <M30W> http://ix.io/4Aa
01:34:40 <M30W> :(
01:34:45 <mauke> by "this" I mean M_SQRT2, not wiringpi
01:34:52 <shachaf> srhb: It looks pretty outdated anyway.
01:35:06 <adas_> mauke: actually i wouldn't bother learning the ffi. but unfortunately there is no haskell binding for the wiring pi lib yet..
01:35:14 <M30W> Anyone mind explaining what I am doing wrong with j?
01:35:28 <M30W> Other than not naming my functions... :)
01:36:08 <adas_> mauke: i assumed trying to groke how to get vars in math.h into haskell might prepare me for the challenge
01:36:16 <mjrosenb> M30W: what is the error message that you get?
01:36:48 <M30W>     Couldn't match expected type `Integer'
01:36:48 <M30W>                 with actual type `[(Integer, String)]'
01:36:49 <shachaf> Please use a better naming scheme.
01:36:49 <M30W>     Couldn't match expected type `Integer'
01:36:49 <M30W>                 with actual type `[(Integer, String)]'
01:36:51 <M30W> err
01:37:24 <mauke> adas_: they're macros, not vars
01:37:30 <ski_> M30W : `j :: ReadS Integer'
01:37:32 <mauke> adas_: and functions are far easier to import than variables
01:37:48 <ski_> @type readHex
01:37:49 <lambdabot> (Eq a, Num a) => ReadS a
01:38:07 <mauke> adas_: the first parts of wiringpi look trivial: no custom data types, just a few functions
01:38:11 <mauke> callbacks get trickier
01:38:19 <M30W> You've lost me
01:38:21 <mauke> and then there's macro stuff for variable declarations
01:38:25 <mauke> this might require shenanigans
01:38:50 <ski_> M30W : `readInt 16 k f s' doesn't compute to a number, but to a list of pairs of numbers and strings
01:39:00 <ski_>   type ReadS a = String -> [(a,String)]
01:39:03 <adas_> mauke: i know and that is why i was trying to write a C function that returns the value of M_SQRT2 so that i can simply call that function.. but after having done that using hsc2hs, ghci complains that it can't find the definition of the function...
01:39:27 <M30W>     Couldn't match type `Int' with `Char'
01:39:40 <mauke> adas_: just ... stop
01:40:01 <M30W> Ah
01:40:34 <ski_> M30W : .. so, it depends on what you want `j' to do
01:40:51 <adas_> mauke: sory, feelin exhausted..ive been at it for 6 hours. sadly i hav nothing to show for it
01:41:16 <mauke> adas_: start with something simple, like importing abs() or sqrt()
01:41:35 * ski_ idly wonders why `readHex' requires `Eq' on the thing read
01:41:37 <adas_> mauke: i did. i tried sin(). worked flawlessly
01:41:39 * M30W wonders how to reverse f
01:41:42 <mauke> ah
01:41:51 <mauke> adas_: I'm looking at https://git.drogon.net/?p=wiringPi;a=blob;f=wiringPi/wiringPi.h;h=18c6da51733e89aa12995b21447555147859b8ab;hb=HEAD
01:42:02 <mauke> looks mostly straightforward
01:42:27 <mauke> adas_: the macros can be done with hsc2hs and #enum or #const
01:42:54 <mauke> adas_: PI_THREAD requires some thinking (what should the Haskell API look like?)
01:43:03 <ski_> @type digitToInt
01:43:04 <lambdabot> Char -> Int
01:43:16 <ski_> > map digitToInt "fFgG"
01:43:17 <lambdabot>   [15,15,*Exception: Char.digitToInt: not a digit 'g'
01:43:59 * M30W is getting kicked off the computer.
01:44:04 <adas_> mauke: i would be happy with a one to one mapping. im not looking to optimize or make it look haskellish. i just want it to work and then i can think abt all that
01:44:05 <mauke> adas_: wiringPiISR may need some "foreign import "wrapper"" trickery
01:44:24 <M30W> Good night world. Thankyou ski_ etc
01:45:13 <mauke> adas_: wpiModePins = #const WPI_MODE_PINS
01:45:14 <mauke> etc
01:46:04 <adas_> mauke: yes .. all the defines must be trivial i hope.. with #enum
01:46:32 <mauke> foreign import ccall "wiringPi.h" wiringPiSetup :: IO CInt
01:46:37 <ski_> mauke : hm, how does that know where to extract `WPI_MODE_PINS' from ?
01:46:46 <ski_> (the `#const' one)
01:47:07 <adas_> ski_: the include directive ..
01:47:17 <adas_> not sure im right
01:47:22 <mauke> ski_: #include "wiringPi.h"
01:47:35 <ski_> i see
01:47:36 <adas_> oh good.. so i was right )
01:48:07 <mauke> foreign import ccall "wiringPi.h &" pinMode :: Ptr (Ptr (CInt -> CInt -> IO ()))
01:48:14 <`nand`> ion!!
01:48:40 <adas_> mauke: whats that '&' doing in there?
01:49:03 <mauke> foreign import ccall "wiringPi.h" wiringPiISR :: CInt -> CInt -> Ptr (IO ()) -> IO CInt
01:49:13 <ski_> importing a pointer to a variable
01:49:14 <mauke> adas_: pinMode is a variable
01:49:25 <mauke> variables can't be imported directly; you have to get their address
01:49:42 <mauke> pinMode is also a pointer; that's why its & import is a Ptr Ptr
01:50:14 <shachaf> I,I Fix Ptr
01:50:22 <mauke> (this is also why you can't import macros; they're text replacement, not things in memory)
01:50:39 <mauke> well, you can actually import macros if your ghc is sufficiently new (7.6)
01:51:03 <mauke> but this needs a different calling convention, not ccall
01:51:23 <ski_> hmm .. higher-order text macros
01:52:09 <mauke> (the "text" bit was a lie; cpp operates on a token stream, not raw text)
01:52:54 <elliott> wow, what does GHC do to import macros?
01:53:02 <shachaf> hsc2hs, not GHC
01:53:14 <mauke> shachaf: wrong
01:53:35 <mauke> elliott: http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/ffi.html#ffi-capi
01:53:43 <ski_> elliott : grovel, i'd assume
01:54:16 <shachaf> Oh, that's new, isn't it?
01:54:38 <shachaf> But "#const WPI_MODE_PINS" looks like hsc2hs syntax.
01:54:43 <mauke> it is
01:54:51 * shachaf didn't read part of the conversation, clearly.
01:57:39 <adas_> mauke: thanks for the pointers.. i think ill start with the ones that can be simply #const(ed)
01:58:09 <shachaf> The ones that can be simply #const(ed) aren't pointers.
02:00:00 <adas_> but coming back to my original question.. there is #const that works with C expressions that evaluate to 'C' ints or 'C' long ints. how would you do the same for 'C' doubles?
02:00:34 <adas_> returning the double by coding a function in C is one approach.. but there must be simpler
02:02:11 <ski_> hm, why does the `Foreign' link near the top of the above page actually link to docs for `Control.Concurrent' ?
02:21:27 <srhb> What do I need to make runQ [| 1 |] >>= print not throw parse error on input '|' at me?
02:21:59 * hackagebot snap-app 0.1.0.0 - Simple modules for writing apps with Snap, abstracted from hpaste.  http://hackage.haskell.org/package/snap-app-0.1.0.0 (ChrisDone)
02:22:15 <`nand`> [| |] ?
02:22:26 <`nand`> srhb: are you trying to quasiquote?
02:22:50 <srhb> I think I'm trying to see what the AST of the literal 1 is
02:23:09 <arkeet> turn on -XQuasiQuotes?
02:23:49 <srhb> I have.
02:24:25 <srhb> Or maybe my ghci is just being weird.
02:24:53 <`nand`> works for me
02:24:59 <`nand`> with -XTemplateHaskell -XQuasiQuotes
02:25:27 <srhb> I don't understand that, if I write main = runQ [| 1 |] >>= print and load that in ghci with those extensions, it works. But in the same ghci I cannot write runQ [| 1 |] >>= print without getting a parse error. Huh?
02:25:41 <arkeet> you turned it on in ghci?
02:25:55 <`nand`> did you just load the file or did you write :set -X... in GHCi?
02:25:58 <srhb> I assumed GHCI turned it on when I loaded the file with the extensions enabled in a language pragma
02:26:02 <arkeet> it does not.
02:26:11 <srhb> Oh, well that explains :P
02:26:13 <`nand`> I thought it does sometimes, not sure
02:26:19 <`nand`> I remember always being confused about this behavior
02:26:35 <srhb> Yeah, it really is confusing. Thanks, now it works!
02:43:54 <shachaf> Solution: Turn on every language pragma in ghci
02:44:11 <shachaf> I.e. :set -XEveryLanguagePragma in ~/.ghci
02:44:22 <shachaf> Or :iset if you want to be gentle.
02:46:47 <c-ab> > fromJust (Just "foo")
02:46:49 <lambdabot>   "foo"
02:47:01 <c-ab> > fromJust (Nothing)
02:47:02 <lambdabot>   *Exception: Maybe.fromJust: Nothing
02:53:26 <c-ab> browse :: BrowserAction conn a -> IO a
02:53:41 <c-ab> rsp <- browse $ do request $ getRequest "http://www.google.fr" print $ fmap rspBody rsp
02:54:13 <c-ab> rsp <- browse $ do {request $ getRequest "http://www.google.com"} print $ fmap rspBody rsp
02:54:45 <c-ab> I don't identify the args of browse there
02:55:18 <c-ab> the multiline version is
02:55:27 <c-ab> rsp <- browse $ do
02:55:34 <c-ab>     request $ getRequest "http://www.google.fr"
02:55:40 <c-ab> print $ fmap rspBody rsp
02:56:11 <shachaf> You haven't asked a question.
02:56:41 <c-ab> hmm /erase previous 6 lines ;)
02:57:24 <c-ab> :t request
02:57:25 <lambdabot> Not in scope: `request'
02:59:29 <c-ab> nvm that's me, but the design of this BrowserAction is bit complex
03:02:17 <c-ab> data BrowserAction conn a
03:03:10 <c-ab> (BrowserAction conn) is a Monad
03:04:58 <hpaste> srhb pasted “TH confusion” at http://hpaste.org/83336
03:05:15 <srhb> ^^^ Where does Name -> Exp come from?
03:05:41 <`nand`> shachaf: -XMonomorphismRestriction
03:06:09 <aristid> `nand`: the best pragma, obviously.
03:06:18 <supki> srhb: VarE is Name -> Exp
03:06:24 <srhb> Oh.
03:06:26 <srhb> Derp.
03:12:51 <srhb> So all I have to do is mkName "++" and I get a Name that refers to the already defined ++?
03:15:55 <srhb> So how come when I runQ [|\x -> (++) "Hello" x|] it just says VarE GHC.Base.++ ? Is that just the Show instance showing Names like that?
03:18:09 <mgsloan> srhb: It should show you the whole AST.  But yeah, unfortunately the output is not the construction code
03:18:15 <`nand`> srhb: yes
03:18:16 <srhb> Okay.
03:18:24 <`nand`> oh
03:18:26 <`nand`> wait, I misread
03:18:28 <`nand`> and I don't know
03:18:32 <srhb> :P
03:18:50 <`nand`> well, yes that (++) gets displayed as GHC.Base.++
03:18:59 <`nand`> what happens to the "Hello"?
03:19:06 <srhb> Uh..
03:19:12 <srhb> What do you mean what happens to it?
03:19:37 <mgsloan> LitE (StringLit "hello") or something like that
03:19:45 <srhb> Yes
03:19:47 <`nand`> why is the output only “VarE GHC.Base.++” when the expression should be something like LambdaE (..) (AppE ... (VarE GHC.Base.++) (LitE (StringLit ...))..
03:19:54 <srhb> Oh right, I didn't mention the rest
03:19:59 <`nand`> oh
03:20:45 <mgsloan> yeah, it's kindofa silly Show instance.  It's somewhat good that the full AST for the names isn't printed, though
03:20:45 <srhb> So the whole LamE (...) is actually equivalent to AppE (VarE (mkName "++")) (LitE (StringL "Hello"))? And I don't even have to deal with making a name for the lambda parameter then?
03:21:28 <mgsloan> No, there ought to be VarP and VarE in there for the x
03:21:30 <`nand`> srhb: “equivalent”
03:21:42 <`nand`> I mean you can eta reduce it, but that subtly changes semantics in some cases
03:21:47 <srhb> Really. What's the difference then?
03:22:35 <srhb> Is it the same difference if I define foo = (++) "Hello" vs bar x = (++) "Hello" x ?
03:22:53 <`nand`> once for type-checking, though for (++) it shouldn't matter; and another complication about the monomorphism restriction is involved I think
03:23:00 <`nand`> actually I think neither are relevant for (++)
03:23:12 <srhb> Hohum. Okay.
03:23:46 <`nand`> might as well forget what I said
03:23:55 <srhb> I'll try. :P
03:24:23 <`nand`> but semantically they're equivalent, yes
03:25:03 <srhb> The only difference I notice is that my return becomes ambiguous and I have to specify type Q Exp
03:25:25 <srhb> Presumably x <- mkName "x" resolved that ambiguity before.
03:26:17 <srhb> Uh, newName
03:26:28 <srhb> @hoogle newName
03:26:29 <lambdabot> Language.Haskell.TH.Syntax newName :: String -> Q Name
03:26:29 <lambdabot> Language.Haskell.TH newName :: String -> Q Name
03:26:29 <lambdabot> Language.Haskell.TH.Syntax qNewName :: Quasi m => String -> m Name
03:26:31 <srhb> Yeah.
03:26:44 <`nand`> presumably, yes
03:26:46 <`nand`> though runQ or w/e should suffice?
03:26:53 <srhb> How would I use runQ?
03:27:30 <`nand`> uhm
03:27:54 <`nand`> runQ :: Q a -> IO a
03:28:01 <ski_> `nand` : arguably, the `Show' instance for `Name' ought to show :  VarE '(++)
03:28:06 <`nand`> actually I have no idea how that's useful
03:28:21 <`nand`> ski_: that would be handy
03:28:31 <ski_> (which would be both correct and readable)
03:28:33 <srhb> ski_: The quote meaning "name"?
03:28:43 <`nand`> srhb: TH quoting syntax
03:28:46 <ski_> srhb : try entering that expression in the interactor
03:28:51 <shachaf> runQ :: Q a -> Q a
03:29:02 <srhb> runQ :: Q a -> m a
03:29:12 <`nand`> runQ :: Quasi m => Q a -> m a
03:29:28 <srhb> ski_: How do you mean? In a quasiquote?
03:29:35 <ski_> no, just plain
03:29:38 <srhb> Oh, no, I see what you mean. Nice!
03:29:59 <`nand`> ah, you can use runQ in GHCi; yes
03:30:03 <`nand`> that makes sense
03:30:16 <`nand`> you can't splice Q [Dec]s in GHCi, can you?
03:30:18 <ski_> srhb : however, unfortunately, it gets shown back as `VarE GHC.Base.++' -- which imo isn't that useful
03:30:25 <`nand`> (but you could splice Q Exp ?)
03:31:05 <srhb> So I can actually write the thing as (AppE (VarE '(++)) (LitE (StringL "Hello")))
03:31:20 * ski_ nods
03:31:20 <srhb> `nand`: $(foo) ? Yes.
03:31:56 <`nand`> srhb: yes
03:32:11 <`nand`> but that doesn't work for eg. “let $(foo :: Q [Dec])”
03:32:17 <`nand`> or “$(foo :: Q [Dec])”
03:32:22 <ski_> srhb : hmm .. though perhaps this wouldn't work for `[| \x -> x |]'
03:32:29 <srhb> ski_: Why not?
03:32:56 <ski_>  > LamE [VarP 'x] (VarE 'x)
03:32:56 <ski_> <interactive>:1:12: Not in scope: `x'
03:33:20 <srhb> Ah right, need to make a name for that still.
03:35:06 <ski_>  > print =<< runQ [| \x -> $(return (AppE (VarE 'x) (LitE (StringL "Hello")))) |]
03:35:09 <ski_> LamE [VarP x_2] (AppE (VarE x_2) (LitE (StringL "Hello")))
03:35:12 <ski_>  > print =<< runQ [| \x -> x "Hello" |]
03:35:13 <ski_> LamE [VarP x_3] (AppE (VarE x_3) (LitE (StringL "Hello")))
03:35:42 <srhb> Right, and the correct method here would always be to just use runQ instead of manually writing the whole AST out, won't it?
03:36:23 <ski_> correct method for what goal ?
03:36:24 <mgsloan> well, runQ is mostly useful for using ghci, otherwise it's not very useful for TH code
03:36:25 <srhb> I mean, when runQ _can_ be used.
03:36:31 <srhb> Oh.
03:36:43 <srhb> Hrm.
03:37:02 <srhb> I'm learning TH without an application for it, probably why I'm confused.
03:37:08 <`nand`> mkName :: String -> Name
03:37:19 <mgsloan> if it's between using [| |] and manually creating ASTs, I've found that unfortunately manually creating ASTs is usually what you end up doing
03:37:27 <srhb> mgsloan: How come?
03:37:38 <mgsloan> the main reason for this is that those quotes don't support splicing of names, and other types that would be useful to splice
03:37:50 <`nand`> that would be the thing \x -> ... actually translates to, since the ‘x’ actually shadows the outside scope
03:37:53 <`nand`> which is not the behavior of newName
03:37:54 <srhb> Didn't 'foo mean that you can splice names?
03:37:58 <ski_> we'd really want "syntax lambdas" or something to nicely express `LamE'-like things, i suppose
03:37:59 <mgsloan> I have a WIP package that provides better AST quotes, but it's got some rough corners
03:37:59 <srhb> Aha.
03:38:11 <`nand`> ski_: OverloadedSyntax-esque? :)
03:38:26 <ski_> `nand` : hm, what do you mean ?
03:38:41 <mgsloan> well, it's not even WIP, that would imply that I'd worked on it recently - more like I abandoned it more than half a year ago and am hoping to get some freetime :)
03:39:40 <`nand`> or Overloadable
03:39:42 <`nand`> w/e
03:39:45 <`nand`> the stuff that eg. lets you redefine do syntax
03:41:50 <ski_> `nand` : i was more thinking of lambdas in lambdaProlog, or "An Extension to ML to Handle Bound Variables in Data Structures"
03:42:04 <`nand`> ah
03:42:10 <`nand`> I see what you mean
03:42:12 <`nand`> yes, that would be interesting
03:42:34 <mgsloan> well, due to scoping rules, here (mkName "x") is fine :)
03:42:35 <ski_> (if you know how those "data lambda" work)
03:46:22 <Radish> hello
03:46:39 <Radish> got another noob question lol
03:46:54 <Radish> does anyone know of a good tutorial for using multiple .hs files?
03:47:18 <Radish> "a gentle introduction to haskell" is pretty confusing.
03:47:42 <ski_> perhaps LYAH explains this better ?
03:48:02 * ski_ can't recall how much it discusses modules
03:48:05 <ski_> @where LYAH
03:48:05 <lambdabot> http://www.learnyouahaskell.com/
03:49:01 <ski_> Radish : perhaps see <http://learnyouahaskell.com/modules#making-our-own-modules>
03:50:44 <ski_> (or, if you have a question about "multiple .hs files" or modules, you could try asking it)
03:50:44 <tritlo> Aye, LYAH explains it pretty well
03:51:07 <shachaf> ski_: Asking it? Lunacy!
03:51:30 * ski_ checks the phase of the moon
03:52:11 <Radish> ski_: what do you mean "asking" it?
03:52:27 <ski_> asking your specific module-related question, if you have one
03:52:33 <Radish> ski_: lol btw
03:52:45 <Radish> uhh... I just don't like harassing the channel /too/ much lol
03:52:55 <ski_> we don't mind
03:52:59 <Radish> i just want to use multiple .hs files but I'm doing it wrong.
03:53:09 <ski_> we usually like answering newbie questions :)
03:53:13 <Radish> actually it might be that I didn't name my files with a capital letter?
03:53:22 <ski_> that might be it
03:54:05 <Radish> Example.hs for module Example where?
03:54:12 <ski_> yes
03:54:18 <srhb> Yay. get n m = newName "x" >>= LamE [TuoP $ replicate (n-1) WildP ++ [VarP x] ++ replicate m-n WildP] (VarE x) -- gets element n from an m-tuple. I think I finally understand the TH basics. :)
03:54:26 <srhb> oops, TupP
03:54:34 <ski_> (though `module Main' is allowed to be in a file not named `Main.hs')
03:54:56 <shachaf> Also note that "module Main where" is different from no module declaration at all!
03:55:00 <shachaf> Or don't note that.
03:55:13 <shachaf> Also note that your "lol"-percentage is ~6.
03:55:33 <ski_> shachaf : `... >>= LamE ...' ?
03:55:37 <ski_> er
03:55:39 <ski_> srhb ^
03:55:49 <srhb> ski_: Yes? Is that bad?
03:56:01 <srhb> oh, return.
03:56:11 <srhb> I should fmap instead.
03:56:23 <Radish> wait how do i include it if it's in the same directory?
03:56:24 <ski_> `undefined >>= LamE undefined undefined' is a type error for me
03:56:28 <ski_> ok
03:56:34 <Radish> I have to do it inside the file, I don't use command line or anything.
03:56:36 <srhb> Yeah, forgot return.
03:57:10 <srhb> Actually no, do need the Monad instance for that, clearly.
03:58:16 <srhb> Uh, no I don't. Nevermind me
03:58:41 <shachaf> > replicate 10 "wildp" & ix 3 .~ "varp x"
03:58:44 <lambdabot>   ["wildp","wildp","wildp","varp x","wildp","wildp","wildp","wildp","wildp","...
03:58:45 <ski_> `get n m = liftM (\x -> LamE [TupP $ replicate (n-1) WildP ++ [VarP x] ++ replicate (m-n) WildP] (VarE x)) (newName "x")' works here, yes
03:58:46 <Radish> it says "could not find module Math" which is my module obviously.
03:58:54 <shachaf> srhb: ☝
03:58:57 <Radish> which is in Math.hs in the same file.
03:59:08 <shachaf> You can only have one module per file.
03:59:16 <Radish> i mean folder*
03:59:22 <srhb> shachaf: Yay, lenses AND TH. The ungodly demons fuse at last!
03:59:28 <srhb> ski_: Right. :)
03:59:45 <Radish>  ///example/Main.hs and ///example/Math.hs
03:59:51 <srhb> Somewhat prettier in do notation.
03:59:54 <Radish> do I have to qualify the folder?
04:00:04 <shachaf> > [if x == 3 then "varp x" else "wildp" | x <- [1..6]]
04:00:06 <lambdabot>   ["wildp","wildp","varp x","wildp","wildp","wildp"]
04:00:19 <ski_> @hoogle Functor f => f a -> (a -> b) -> f b
04:00:21 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
04:00:21 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
04:00:21 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
04:00:33 <shachaf> ski_: lens has (<&>) with that type.
04:00:55 * ski_ would probably just define `pamf' again
04:01:55 <ski_> Radish : i think it normally searches in the current directory, but not sub-directories
04:02:19 <ski_> Radish : you could try renaming `example' to `Example', and in `Example/Math.hs' say `module Example.Math where', though
04:02:30 <Radish> i assumed as much
04:02:37 <ski_> (and use `import Example.Math' when importing)
04:02:50 <Radish> but i'm importing from the local folder
04:02:51 <shachaf> Note: "current directory" means "the directory you are in", not "the directory your file is in"
04:03:14 <shachaf> You should apply the Usual Debuggin Procedure to see what's going on.
04:03:25 <shachaf> g
04:03:44 <Radish> shachaf: whats the usual procedure?
04:04:08 <shachaf> You know, add -v, add strace, look at logs, think about what the program might be doing and where it's failing.
04:04:20 <Radish> D:
04:04:21 <shachaf> Examine your assumptions and see where they contradict reality.
04:04:25 <shachaf> It's a good skill.
04:04:51 <shachaf> It's much more applicable than knowing how to make GHC work with Haskell modules in a directory, that's for sure.
04:04:52 <Radish> i don't have command line going.
04:04:57 <Radish> i have no idea how to use it.
04:05:16 <shachaf> Well, that would be a good thing to learn.
04:05:16 <aristid> shachaf: what if that contradiction would undermine one's self-worth? clearly that's a good reason not to  examine one's assumptions.
04:05:19 <Radish> i just open the hs files in the default program lol.
04:05:27 * ski_ thinks Radish is on NT
04:05:34 <shachaf> I don't know what a "program lol" is, unfortunately.
04:05:46 <Radish> forgive my grammar sir
04:05:49 <shachaf> But I recommend treating this as a learning opportunity.
04:05:49 <Radish> program, lol*
04:05:51 <Radish> lol
04:05:57 <shachaf> Oh, well.
04:06:00 <shachaf> I've had enough. Have fun.
04:06:07 <Radish> shachaf: cool thanks
04:08:34 <joker_89> do
04:08:40 <joker_89> hi
04:08:50 <srhb> joker_89: Hi.
04:08:51 <ski_>      lo
04:08:51 <joker_89> using List comprehensions how can i return a unique bool?
04:09:01 <srhb> joker_89: Unique Bool?
04:09:09 <Radish> hey wait it says i can use -v but I can't get out of prelude so it thinks i'm asking for negative v..
04:09:09 <ski_> list comprehensions compute to lists
04:09:19 <Radish> is there a quick way out?
04:09:30 <joker_89> i want to chech a list and if all elements pass the condition then return True
04:09:38 <ski_> Radish : "it" being ?
04:09:50 <ski_> joker_89 : try `all' ?
04:09:57 <ski_> > all even [2,4,10]
04:09:59 <lambdabot>   True
04:10:02 <srhb> Radish: I assume -v is the flag you give to ghci, not something you write _in_ ghci
04:10:02 <ski_> > all even [2,4,5,10]
04:10:03 <lambdabot>   False
04:10:48 <ski_> srhb : i suspect Radish only clicked on an icon, not typed `ghci' in any textual shell
04:10:51 <Radish> srhb: thanks
04:10:51 <srhb> @hoogle (a -> Bool) -> [a] -> Bool -- here's how to find such a function joker_89
04:10:51 <lambdabot> Parse error:
04:10:51 <lambdabot>   (a -> Bool) -> [a] -> Bool -- here's how to find such a function joker_89
04:10:51 <lambdabot>                              ^
04:10:57 <srhb> Huh.
04:11:02 <srhb> @hoogle (a -> Bool) -> [a] -> Bool
04:11:02 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
04:11:03 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
04:11:03 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
04:11:07 <srhb> There we go.
04:11:31 <ski_> clearly lambdabot hoogle should strip comments
04:11:46 <joker_89> ook thanks
04:11:52 <srhb> joker_89: So you can ask it, "given a function a to Bool and a list of a, is there a function that can give me a Bool?
04:12:02 <srhb> joker_89: And lo and behold, there are a few.
04:12:12 <ski_> @hoogle+
04:12:12 <lambdabot> Data.List any :: (a -> Bool) -> [a] -> Bool
04:12:12 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
04:12:12 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
04:12:20 <ski_> &c.
04:12:22 <joker_89> myfuction :: (a -> [a] -> a) -> a -> [a] -> Bool
04:13:41 <joker_89> myfucntion f e xs . i need to chech for every x in xs if f x e == x
04:13:52 <joker_89> and return True or False
04:14:38 <srhb> joker_89: OK, so try to construct that by using all.
04:15:03 <tritlo> Hey, I'm trying out irc now for the first time, and I'm wondering, (non-haskell question) how do you reply to a user in channel, like ski_ is doing to joker_89? i.e. <ski_> joker_89: message
04:15:06 <joker_89> but for itarate the list i need to use a List comprehensions
04:15:12 <srhb> joker_89: No, all does that for you
04:15:25 <srhb> tritlo: /msg name blahblah
04:15:33 <srhb> tritlo: Oh, sorry, no
04:15:35 <shachaf> tritlo: You write the user's name, and then a colon and a space, and then your message.
04:15:44 <tritlo> ah, I see
04:15:55 <shachaf> Sometimes you can write the beginning of the user's name and then press Tab.
04:16:16 <tritlo> shachaf: ah, convenient.
04:17:11 <tritlo> I didn't think of doing it the simple way.
04:19:35 <srhb> joker_89: Notice how the first argument to 'all' is the function to convert the x'es to Bool. If they all turn out True, you get True, otherwise False
04:20:57 <joker_89> i don0t use all
04:21:13 <srhb> joker_89: Why not? It's tailor-made for your use case.
04:21:16 <joker_89> i need to use a List comprehensions is a exercice
04:21:59 <c-ab> > fmap fromJust (Nothing, Just "test")
04:22:01 <lambdabot>   (Nothing,"test")
04:22:02 <srhb> Well, that won't suffice. You can use the list comprehension to convert your values to Bools, but you will need to reduce that list to a Bool with a fold or explicit recursion
04:22:24 <ski_> joker_89 : then convert all the elements to `Bool's, and then convert the list of those to a single `Bool'
04:22:27 <c-ab> > fmap fromJust (swap (Nothing, Just "test"))
04:22:28 <lambdabot>   (Just "test",*Exception: Maybe.fromJust: Nothing
04:22:44 <ski_> joker_89 : in any case, you'll need something outside the list comprehension
04:22:46 <joker_89> but how can i convert values to bools?
04:22:59 <beaky> hello
04:23:11 <ski_> > [x > 4 | x <- [2,3,5,7]]
04:23:13 <lambdabot>   [False,False,True,True]
04:23:13 <srhb> > [ (==1) x | x <- [1,2,3,4]]
04:23:15 <lambdabot>   [True,False,False,False]
04:23:20 <c-ab> > 1 :: Boolean
04:23:22 <lambdabot>   Not in scope: type constructor or class `Boolean'
04:23:27 <c-ab> > 1 :: Bool
04:23:29 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
04:23:29 <lambdabot>    arising from the literal `1...
04:23:40 <joker_89> i see
04:23:42 <ski_> > fromEnum 1 :: Bool
04:23:44 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
04:23:44 <lambdabot>              with actual type...
04:23:58 <ski_> > toEnum 1 :: Bool  -- i can never recall which is which
04:23:59 <lambdabot>   True
04:24:02 <srhb> joker_89: So you would end up with something like [ f x e == x | x <- xs ]
04:24:11 <srhb> But you'll need to figure out to reduce that list to one Bool.
04:24:17 <joker_89> solved!
04:24:26 <joker_89> yes i did it srh
04:24:30 <srhb> :)
04:24:40 <joker_89> now i put all
04:25:08 <c-ab> > fromJust snd (Nothing, Just "test")
04:25:09 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (t0 -> t1)'
04:25:10 <lambdabot>              wit...
04:25:16 <c-ab> > fromJust $ snd (Nothing, Just "test")
04:25:18 <lambdabot>   "test"
04:25:36 <shachaf> c-ab: You shouldn't use fromJust.
04:25:41 <beaky> is there a way to write f <$> xs using list comprehensions?
04:25:42 <shachaf> It'll make you sad later.
04:25:56 <srhb> beaky: [f x | x <- xs]
04:25:58 <c-ab> > fromJust <$> (Nothing, Just "test")
04:25:59 <beaky> ah thanks
04:25:59 <lambdabot>   (Nothing,"test")
04:26:30 <ski_> tritlo : actually, i would have done `<ski> joker_89 : message' :)
04:26:34 <srhb> joker_89: For the record, all is the right solution here, if it weren't such a specific exercise. all (\x -> f x e == x) xs
04:26:52 <c-ab> shachaf: I have it there `setProxy . fromJust $ parseProxy "61.55.141.12:80"`
04:27:40 <srhb> c-ab: What happens if parseProxy is Nothing?
04:27:40 <arkeet> scary.
04:27:51 <joker_89> i see
04:28:14 <c-ab> srhb: when the proxy is down, the code just fails
04:28:22 <srhb> c-ab: Yes, crashes.
04:28:27 <ski_> > flip all [2,3,5] $ \x -> gcd x 30 == x
04:28:28 <lambdabot>   True
04:28:39 <arkeet> all ((==) <*> flip f e) xs
04:28:41 <arkeet> :c
04:29:08 <ski_> c-ab : are you sure it'll never be `Nothing' ?
04:29:11 <joker_89> but now i have a list of True,False, how can check if all are true?
04:29:18 <arkeet> joker_89: "and"
04:29:19 <ski_> c-ab : otherwise, you might want to use `fromMaybe' (or perhaps `maybe')
04:29:30 <arkeet> (which is also "foldr (&&) True")
04:29:32 <srhb> joker_89: Again, you can find this yourself with Hoogle
04:29:36 <srhb> @hoogle [Bool] -> Bool
04:29:37 <lambdabot> Prelude and :: [Bool] -> Bool
04:29:37 <lambdabot> Data.List and :: [Bool] -> Bool
04:29:37 <lambdabot> Prelude or :: [Bool] -> Bool
04:30:37 <ivanm> edwardk: ahhh, OK; I'm just finding that my attempt at using Vectors is proving rather slow for adding/deleting (and since you were using Arrays I thought you might have found a way to deal with that)
04:30:51 <c-ab> ski_: not tested yet, probably it's Nothing when the proxy is down
04:31:12 <adas> is there a difference between the "()" unique type and the "()" unit type?
04:31:21 <arkeet> ??
04:31:24 <srhb> adas: What?
04:32:02 <adas> Real World Haskell Pg 416 under the subheading "Typed Pointers"
04:32:03 <srhb> adas: All types that have only one value are essentially equivalent. I'm not sure what you mean by unique and unit here, though.
04:32:36 <arkeet> adas: which section? so we can refer to the online version
04:32:43 <srhb> http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
04:33:01 <ski_> c-ab : if you don't think about the possibility for this condition now, chances are you'll forget about it, and (perhaps) later get mysterious failures, which are hard to track down
04:33:07 <arkeet> there is no "() unique type"
04:33:10 <adas> "We can increase safety in the binding futher by using a typed pointer, instead of using the () type. That is, a unique type, distinct from the unity type ..."
04:33:16 <ski_> c-ab : a handy rule of thumb is : never use `fromJust'
04:33:18 <arkeet> it's just talking about a type, different from (), that also has one value.
04:33:34 <srhb> I don't see how it increases safety. It might improve error messages.
04:33:45 <adas> arkeet: pg 416, Chapter 17 - Interfacing with C: The FFI
04:33:46 <ski_> c-ab : even `fromMaybe (error "my proxy is down")' is better
04:34:02 <arkeet> or no values.
04:34:03 <shachaf> The issue here is not the proxy being down, it is a hard-wired string failing to parse.
04:34:09 <shachaf> Even so, I would suggest not using fromJust. :-)
04:34:17 <ski_> adas : yes
04:34:47 <adas> ski_: you mean they are 2 different types?
04:35:05 <c-ab> ski_: is there actually the choice, see http://stackoverflow.com/a/3858190/1125394
04:35:12 <ski_> hrm, actually i misread you as saying "unit value" in one case
04:35:23 <ski_> adas : there is one `()' type
04:35:33 <c-ab> Hmm with a case
04:35:39 <c-ab> yes there is choice nvm
04:35:46 <beaky> why is fromJust bad?
04:35:50 <ski_> adas : i don't think "unique type" there should be takes as a name / definite description
04:35:52 <beaky> I use it always in my code :(
04:36:01 <arkeet> you are bad
04:36:04 <srhb> > fromJust Nothing
04:36:06 <lambdabot>   *Exception: Maybe.fromJust: Nothing
04:36:07 <ivanm> beaky: for starters, if you have lots of them, it can be hard to track down where a bug occurs when you accidentally pass it a Nothing
04:36:09 <adas> so that line on pg 416 of RWH is wrong or misinformation
04:36:10 <ski_> adas : i think they just mean that they will use some ersatz type instead of `()'
04:36:12 <ivanm> I know from experience :p
04:36:16 <beaky> ah
04:36:22 <arkeet> adas: no, you're reading it wrong.
04:36:25 <c-ab> case parseProxy of Nothing -> ...; Just s -> ù
04:36:29 <beaky> okay I will use fromMaybe instead
04:36:36 <ivanm> adas: my understanding was that line meant you should _use_ a unique type (for that pointer) rather than ()
04:36:37 <ski_> beaky : because if it fails, you'll have a hard time tracking down where the failure occured
04:36:48 <ivanm> c-ab: why use case rather than maybe ?
04:36:55 <arkeet> or fromMaybe
04:37:02 <beaky> like: fromMaybe "MyFunction: DomainError: Nothing received"
04:37:27 <ivanm> arkeet: well, fromMaybe nc = maybe nc id :p
04:37:36 <arkeet> yes
04:37:55 <arkeet> relatedly, why doesn't Data.Default have Default a => Maybe a -> a?
04:38:10 <beaky> how do I translate procedural algorithms into a functional version?
04:38:19 <beaky> like Minimax, A/B pruning, NegaMax, NegaScout, etc?
04:38:25 <ivanm> beaky: with great care
04:38:26 <arkeet> (well it's just fromMaybe def)
04:38:27 <beaky> (those are tree-based :D)
04:38:34 <c-ab> ivanm: o right it's lovel
04:38:37 <ski_> beaky,c-ab : if you have any other useful action to do than supply a default value (perhaps being an error message), then it's probably better to use `maybe' or pattern-matching (or sometimes `fmap'/`(<$>)'/`liftA'/`liftM') instead of `fromMaybe'
04:38:39 <c-ab> y*
04:38:52 <ivanm> beaky: in some cases you can translate the intent; other times, you bascially end up having a procedural implementation even in Haskell
04:38:54 <beaky> ah
04:39:07 <ski_> `fromMaybe' is specifically when there's a sensible default value (or providing an error message, and it's ok to defer it to when the value is forced)
04:39:10 <beaky> so some algorithms like qsort or knuth-shuffle are inherently procedural?
04:39:33 <ivanm> also, with using fromJust: if you _don't_ have a Nothing value (because you expect it to be Just), use fromMaybe (error "foo") to know where it is for debugging
04:39:41 <ivanm> or do an explicit pattern match (again for debugging)
04:39:56 <beaky> also, how do I choose between fmap/<$>/liftA/liftM ?
04:40:00 <ivanm> beaky: yeah
04:40:13 <arkeet> beaky: between fmap and <$>, use whichever is convenient. never use liftA.
04:40:21 <srhb> arkeet: What?
04:40:22 <ivanm> beaky: (<$>) = fmap, so depending on whether you want infix or prefix
04:40:25 <arkeet> use liftM when you are writing code that applies to a generic monad.
04:40:30 <beaky> why not use liftA?
04:40:34 <arkeet> becaues liftA = fmap
04:40:37 <beaky> oh
04:40:42 <ivanm> @src liftA
04:40:43 <lambdabot> liftA f a = pure f <*> a
04:40:52 <beaky> woah
04:40:57 <ski_> beaky : in some cases you can encapsulate stateful algorithms with `ST s'
04:40:57 <ivanm> fmap should be preferable over liftA or liftM as it is customised directly for the type usually
04:41:06 <ski_> (like quicksort)
04:41:10 <ivanm> and might be more efficient (less plumbing, etc.)
04:41:12 <ivanm> @src liftM
04:41:13 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
04:41:26 <arkeet> liftM = fmap, for anything that's both a Monad and a Functor
04:41:31 <arkeet> (every Monad *should* be a Functor)
04:41:39 <beaky> I find <$> prettier than fmap sometimes; is it still equivalent to fmap?
04:41:40 <arkeet> (and can)
04:41:42 <arkeet> yes
04:41:42 <beaky> :t (<$>)
04:41:45 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:41:53 <beaky> @src (<$>)
04:41:54 <lambdabot> f <$> a = fmap f a
04:41:57 <srhb> <$> is fmap, even when it's prettier. :P
04:42:00 <beaky> ah
04:42:03 <c-ab> > liftM (+1) [Just 1, Just 2]
04:42:05 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a0))
04:42:05 <lambdabot>    arising from a use o...
04:42:18 <arkeet> > (liftM.liftM) (+1) [Just 1, Just 2]
04:42:21 <lambdabot>   [Just 2,Just 3]
04:42:41 <beaky> @src <*>
04:42:42 <lambdabot> Source not found. Sorry.
04:42:43 <ivanm> arkeet: in terms of what it does, liftM = fmap; in terms of implementation it's not ;-)
04:42:46 <arkeet> sure.
04:42:46 * ski_ thinks `<*>' ought to have been named `<$>'
04:42:47 <beaky> @src (<*>)
04:42:47 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
04:42:47 <ivanm> @src (<*>)
04:42:48 <lambdabot> Source not found. Sorry.
04:42:53 <ivanm> wait, that's a class method
04:43:03 <ivanm> ski_: so what would we use for infix fmap?
04:43:05 <beaky> :t (<*>)
04:43:06 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
04:43:20 <ski_> ivanm : `$>' is one suggesion
04:43:20 <arkeet> :t ap
04:43:21 <lambdabot> Monad m => m (a -> b) -> m a -> m b
04:43:33 <arkeet> ski_: that doesn't make sense. especially not with *> and <$
04:43:44 <elliott> ($>) makes sense
04:43:50 <arkeet> but what about *> and <$.
04:43:50 <elliott> if you think of the <>s as meaning which end has "f"
04:43:51 <ivanm> ski_: I thought the single angle bracket operators usually denoted discarding a value
04:44:01 <elliott> (<$>) is ($>) (fmap) where the left hand argument has an f
04:44:03 <arkeet> but they already mean something else.
04:44:03 <ski_> @type (*>)
04:44:04 <lambdabot> Applicative f => f a -> f b -> f b
04:44:06 <ski_> @type (<$)
04:44:07 <lambdabot> Functor f => a -> f b -> f a
04:44:18 <arkeet> the <> tells you which sides get ignored or not.
04:44:24 <elliott> well, ski_ said should, not were.
04:44:58 * ivanm -> land of nod
04:44:59 <ivanm> g'night all
04:45:05 <ski_> night ivanm
04:45:17 <c-ab> > liftM (+1) (Just 2)
04:45:19 <lambdabot>   Just 3
04:45:23 <arkeet> use fmap
04:45:41 <c-ab> > (+1) <$> (Just 2)
04:45:42 <ski_> > (1 +) `fmap` Just 2
04:45:43 <lambdabot>   Just 3
04:45:43 <lambdabot>   can't find file: L.hs
04:46:06 <arkeet> > traverse +~ 1 $ Just 2
04:46:08 <lambdabot>   Just 3
04:46:18 <beaky> what are some algorithms that are much better expressed functionally than procedurally?
04:46:32 * c-ab no lens for the moment
04:46:45 <arkeet> > let fibs = 0:1: zipWith (+) fibs (tail fibs) in fibs
04:46:46 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
04:47:37 <ski_> beaky : well, in procedural programming, one often uses functions (potentially with side-effects) .. so the former is a subset of the latter ?
04:48:02 <beaky> oh
04:48:11 <shachaf> i love side-effects
04:48:12 <shachaf> they are so easy
04:48:25 <beaky> they are easy to see in haskell :D
04:48:45 <shachaf> monoids are pretty easy to see too :D
04:48:46 <srhb> shachaf: Is the user "so" really one of your accounts, just so that it gets emphasized whenenver you say that sentence?
04:49:17 <beaky> :D
04:49:31 <tritlo> let fact n = foldr (*) 1 [0..n]
04:49:51 <shachaf> srhb: It took me a bit to figure out what you meant.
04:49:58 <shachaf> I guess your IRC client highlights names which are nicks in the channel.
04:50:40 <beaky> I guess factorial and fibonacci are best expressed functionally :D
04:51:11 <tritlo> that should be [1..n] though, oops
04:52:08 <arkeet> :t product . enumFromTo 1
04:52:09 <lambdabot> (Enum b, Num b) => b -> b
04:54:04 <beaky> when should I prefer list comps over directly applying the functions?
04:54:50 <srhb> Never, when there are better combinators, basically.
04:55:01 <srhb> shachaf: Right.
04:55:19 <srhb> shachaf: Which makes that sentence stand out _every_ time :P
04:58:19 <c-ab> how to transform a type IO (a,b) in IO b
04:59:40 <c-ab> I'd like to compose  IO (Network.URI.URI, Response String) with rspBody :: Response a -> a
04:59:43 <beaky> :t liftM snd
04:59:44 <lambdabot> Monad m => m (a, r) -> m r
04:59:58 <c-ab> hmm k
05:00:36 <beaky> :t liftM . snd
05:00:39 <lambdabot> Monad m => (a, a1 -> r) -> m a1 -> m r
05:01:01 <beaky> :t snd <$>
05:01:03 <lambdabot> parse error (possibly incorrect indentation)
05:01:05 <beaky> :(
05:01:12 <c-ab> simpler to do rsp <- .. ; rspBody $ snd rsp
05:01:19 <beaky> yea
05:01:19 <`nand`> :t _Just +~ 1
05:01:21 <lambdabot> Num a => Maybe a -> Maybe a
05:01:31 <tritlo> Is there a place that lists all the unpronounceable haskell operators, and what they do, i.e ., $, <$>, <*> etc?
05:02:10 <`nand`> ($) applies a function, (<$>) maps a function, (<*>) applies a mapped function
05:02:31 <beaky> oh
05:02:51 <beaky> :t (***) . (<*>)
05:02:53 <lambdabot> Applicative f => f (a -> b) -> (b' -> c') -> (f a, b') -> (f b, c')
05:03:20 <beaky> with all those operators, haskell is shaping up to be like APL :D
05:03:31 <beaky> I don't even know what the ones in Data.Sequence do :(
05:04:06 <aristid> beaky: they are documented.
05:05:07 <beaky> ah
05:05:15 <beaky> :t (Data.Sequence.|>)
05:05:17 <lambdabot> Seq.Seq a -> a -> Seq.Seq a
05:05:22 <d-snp> hey, I can't seem to find the documentation of STarray, how would I create a 2 dimensional STarray?
05:05:34 <arkeet> d-snp: use a 2-tuple for your index
05:06:02 <d-snp> oh wait it implements the MArray interface and that has all the functions
05:06:09 <d-snp> ehh typeclass :P
05:06:10 <arkeet> that too
05:06:29 <`nand`> ‘interface’ is arguably still correct, considering the meaning of the word :)
05:06:48 <beaky> java has typeclasses :D
05:06:49 <hpaste> adas pasted “differnece” at http://hpaste.org/83337
05:06:51 <adas> is there a difference between those 2 functions ^^^^^?
05:07:37 <d-snp> hmm so the (i,i) first argument of newArray, is that first index and last index?
05:07:57 <arkeet> yes
05:08:42 <beaky> how do I only change one element of a pure Array?
05:08:55 <beaky> (or should I be using IOUArrays instead)?
05:09:38 <ski_> @hoogle [(i,e)] -> Array i e -> Array i e
05:09:38 <lambdabot> Data.Array (//) :: Ix i => Array i e -> [(i, e)] -> Array i e
05:09:38 <lambdabot> Data.Array accum :: Ix i => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
05:09:38 <lambdabot> Data.Array.IArray (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
05:09:47 <`nand`> adas: presumably one is more ‘proper’, if wpiPinToGpio isn't deterministic
05:09:53 <tritlo> :t (<$>)
05:09:55 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:10:09 <`nand`> ah, actually
05:10:17 <beaky> so there's no way? :(
05:10:17 <ski_> beaky : typically you'd want to do bulk updates on immutable arrays, if you'd want to update them at all
05:10:22 <beaky> ah
05:10:27 <`nand`> adas: I think with the second version you defer side effects to when you force the CInt
05:10:37 <`nand`> as opposed to when you evaluate the IO
05:10:38 <ski_> @type \arr i e -> arr // [(i,e)]
05:10:39 <lambdabot> Ix i => Array i e -> i -> e -> Array i e
05:10:46 <beaky> I guess (pure) array isn't the right datastructure for my tictactoe game :D
05:10:49 <ski_> beaky : ^ in case you really want to
05:11:04 <beaky> I thought // was like set difference. thanks :D
05:11:08 <adas> `nand`: any idea which one is the cannonical version if both are the same?
05:11:22 <ski_> @type (\\)
05:11:23 <lambdabot> Eq a => [a] -> [a] -> [a]
05:11:29 <`nand`> if wpiPinToGpio has side effects, the first
05:11:33 <`nand`> if in doubt, the first
05:11:58 <joker_89> how can i get the number of rows of a list of lists?
05:12:02 <`nand`> adas: note that >>= \x -> return (fromIntegral x)   is the same as fmap fromIntegral
05:13:11 <donri> joker_89: you can't, but you can cheat with max . map length
05:13:36 <adas> `nand`: thans for the pointer. fmap is more readable
05:13:46 <`nand`> adas: so wPinToGpio = fmap fromIntegral . c_wPinToGpio . fromIntegral
05:13:49 <donri> joker_89: sorry, maximum
05:13:49 <`nand`> much more readable :)
05:15:37 <ski_> > (maximum . map length) (map (const [0,1,2]) [])
05:15:39 <lambdabot>   *Exception: Prelude.maximum: empty list
05:16:27 <elliott> adas: you probably never want the latter (if the latter was OK you could drop the IO from the type -- probably it isn't)
05:17:19 <adas> elliott: why is it not ok?
05:17:34 <epta> How can I store long multiline string in source file as is without `unlines []'?
05:17:35 <elliott> becaus ethe function you're importing is probably not pure
05:17:51 <donri> epta: end lines with \
05:17:56 <arkeet> and also begin the following lines with \
05:18:10 <donri> ah
05:18:17 <donri> epta: or use a QQ
05:18:43 <adas> elliott: agreed.. but i thought the import line was always for making a one to one mapping with the corresponding C type...
05:19:29 <adas> because wpiPinToGpio is an int to an int in 'C'. so in haskell it should be CInt to CInt instead of IO CInt..
05:19:33 <adas> but i guess was wrong..
05:19:38 <ski_> epta : you can actually have any whitspace you want between the two `\'s
05:19:48 <arkeet> adas: CInt -> CInt should only be used for pure functions.
05:19:52 <ski_> (so you can indent and align)
05:20:13 <arkeet> if it has side effects it should have CInt -> IO Cint
05:31:27 <beaky> begin
05:32:09 <edwardk> end
05:32:42 <`nand`> edwardk: STOP.
05:35:28 <latro`a_> are there any Read instances that actually make use of the [(a,String)] functionality?
05:35:58 <c-ab> @hoogle [(a,String)]
05:35:58 <lambdabot> Numeric readFloat :: RealFrac a => ReadS a
05:35:58 <lambdabot> Prelude reads :: Read a => ReadS a
05:35:58 <lambdabot> Text.Read reads :: Read a => ReadS a
05:36:11 <latro`a_> I mean make use of the fact that you get a list
05:36:19 <latro`a_> all the examples I know of return [] or [val,[]]
05:36:28 <latro`a_> *[(val,[])]
05:36:43 <latro`a_> never [(val1,[]),[val2,(x:xs))]
05:37:20 <ski_> hm, possibly backtracking
05:37:51 <arkeet> > reads "123abc" :: [(Int,String)]
05:37:54 <lambdabot>   [(123,"abc")]
05:38:10 <ski_> (though istr derived `Read' (and `Show') instances not using fixity)
05:40:01 <`nand`> latro`a_: good question, I'd be interested as well
05:40:06 <`nand`> have you tried asking on stackoverflow?
05:43:20 <liyang> So has anyone here created any interesting content on FP Complete's Haskell School thing?
05:45:30 <c-ab>  > reads "a12" :: [(Char,Int)]
05:45:37 <c-ab> > reads "a12" :: [(Char,Int)]
05:45:39 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:45:39 <lambdabot>              with actual type ...
05:45:52 <liyang> c-ab: that's not how reads works.
05:45:55 <Fuco> I have type: data L a x = N | C a x and I'm trying to make it into functor: Functor (L a) where ... fmap f (C x xs) = C (f x) (fmap f xs), however, this gives me: Occurs check: cannot construct the infinite type: a1 = f a1 << why?
05:46:02 <c-ab> > reads "a12" :: [(String,Int)]
05:46:04 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:46:04 <lambdabot>              with actual type ...
05:46:20 <Fuco> I'm later using Mu to define List a as: type List a = Mu (L a)
05:46:39 <Radish> figured out what my module troubles were all about, Programmer's Notepad seems to be opening them in a strange manner.
05:46:57 <c-ab> type ReadS a = String -> [(a, String)]
05:47:02 <c-ab> indeed
05:47:12 <donri> Fuco: LANGUAGE DeriveFunctor?
05:47:19 <c-ab> > reads "abc" :: [(Char,String)]
05:47:21 <lambdabot>   []
05:47:32 <Fuco> donri: what's that?
05:47:35 <liyang> > show 'a'
05:47:37 <lambdabot>   "'a'"
05:47:43 <donri> Fuco: lets you deriving (Functor)
05:47:49 <c-ab> > reads "'a'bc" :: [(Char,String)]
05:47:50 <liyang> > reads "'a'" :: ReadS Char
05:47:50 <lambdabot>   [('a',"bc")]
05:47:52 <lambdabot>   Couldn't match expected type `Text.ParserCombinators.ReadP.ReadS
05:47:52 <lambdabot>           ...
05:48:09 <c-ab> > reads "2.3bc" :: [(Double,String)]
05:48:10 <lambdabot>   [(2.3,"bc")]
05:48:27 <Fuco> donri: gives me the same error :P
05:49:29 <donri> Fuco: you can only apply f to xs there i think?
05:49:59 <donri> fmap f (C x xs) = C x (f x)
05:50:06 <c-ab> > reads "Nothing " :: [(Maybe,String)]
05:50:08 <lambdabot>   Expecting one more argument to `Data.Maybe.Maybe'
05:50:11 <Fuco> that's pretty weird though
05:50:15 <donri> Fuco: and also shouldn't fmap there i don't think
05:50:17 <`nand`> can all legal functor instances be derived?
05:50:29 <`nand`> I think they can
05:50:30 <c-ab> > reads "Nothing " :: [(Maybe String,String)]
05:50:32 <lambdabot>   [(Nothing," ")]
05:50:36 <Fuco> donri: if fmap doesn't call itself recursively how can it do anything at all?
05:50:48 <donri> Fuco: it's not weird, it's perfectly logical :) the instance is for (L a) not L
05:51:03 <Fuco> Aaaah
05:51:17 <donri> > fmap show (Just [1,2,3])
05:51:19 <lambdabot>   Just "[1,2,3]"
05:51:25 <donri> note that it's not fmapped on the list
05:51:30 <arkeet> > (fmap.fmap) show (Just [1,2,3])
05:51:32 <lambdabot>   Just ["1","2","3"]
05:51:46 <arkeet> :t fmap
05:51:48 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:52:02 <arkeet> :t fmap.fmap
05:52:03 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
05:52:09 <arkeet> this lets you map something 2 functors deep.
05:52:14 <Fuco> I see, so the type is (in my case) (b -> c) -> L a b -> L a c
05:52:21 <donri> Fuco: if you want fmap for the 'a' (aka. 'x') as well maybe profunctors.
05:52:24 <donri> :t dimap
05:52:25 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
05:52:40 <arkeet> depends on whether it's covariant or contravariant in a
05:52:48 <c-ab> :t trimap
05:52:49 <lambdabot>     Not in scope: `trimap'
05:52:49 <lambdabot>     Perhaps you meant one of these:
05:52:49 <lambdabot>       `imap' (imported from Control.Lens),
05:52:55 <arkeet> :t bimap
05:52:57 <lambdabot>     Not in scope: `bimap'
05:52:59 <lambdabot>     Perhaps you meant one of these:
05:52:59 <lambdabot>       `imap' (imported from Control.Lens),
05:53:08 <edwardk> :t Data.Bifunctor.bimap
05:53:10 <lambdabot> Data.Bifunctor.Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
05:53:12 <arkeet> there.
05:53:29 <donri> ah yea bifunctors
05:53:44 <Fuco> I'm reading a paper on categories, it starts with F-algebras and they said I should try it out in Haskell... I don't know much Haskell but it's fun fooling around :P
05:53:51 <edwardk> we may start exporting that now that Reviewable uses Bifunctor
05:54:13 <donri> i see now bifunctors are what i thought profunctors should be and got confused because they're not
05:54:14 <arkeet> anyway yeah, that L would be a bifunctor.
05:54:53 <c-ab> is there any common example of bifunctor?
05:54:57 <Fuco> yea, L(A, X) = 1 + AxX
05:55:08 <arkeet> how about just (,)
05:55:10 <arkeet> or Either
05:55:37 <arkeet> and (->) is an example of a profunctor
05:55:46 <c-ab> > dimap show (2,3)
05:55:48 <lambdabot>   Couldn't match expected type `c0 -> d0' with actual type `(t0, t1)'
05:55:58 <arkeet> no, dimap is for profunctors.
05:55:59 <donri> dimap is profunctor
05:56:05 <arkeet> > Data.Bifunctor.bimap show show (2,3)
05:56:07 <lambdabot>   can't find file: L.hs
05:56:10 <arkeet> > Data.Bifunctor.bimap show show (2,3)
05:56:13 <lambdabot>   Not in scope: `Data.Bifunctor.bimap'
05:56:17 <arkeet> uh
05:56:22 <ski_> @let lexSymbol s s0 = [(s',s1) | (s',s1) <- lex s0 , s == s']
05:56:25 <lambdabot>  Defined.
05:56:27 <ski_> > (`runStateT` "0,1,2") $ do n0 <- StateT reads; ns <- many (StateT (lexSymbol ",") >> StateT reads); return ([n0] ++ ns) :: StateT String [] [Integer]
05:56:29 <lambdabot>   [([0,1,2],""),([0,1],",2"),([0],",1,2")]
05:56:39 <ski_> > (`runStateT` "0,1,2") $ do n0 <- StateT reads; ns <- many (StateT (lexSymbol ",") >> StateT reads); StateT (lexSymbol ","); n1 <- StateT reads; guard (n1 > 0); return ([n0] ++ ns ++ [n1]) :: StateT String [] [Integer]
05:56:41 <lambdabot>   [([0,1,2],""),([0,1],",2")]
05:57:05 <c-ab> > Data.Bifunctor.bimap show (2,3)
05:57:07 <lambdabot>   Not in scope: `Data.Bifunctor.bimap'
05:57:13 <ski_> latro`a_ : using a list for backtracking here means we can backtrack out of the greedy `[0,1,2]' solution
05:57:18 <arkeet> c-ab: yeah it's not imported
05:57:20 <arkeet> or something
05:57:25 <donri> :t Data.Bifunctor.bimap show (2,3)
05:57:26 <lambdabot>     Couldn't match expected type `c0 -> d0' with actual type `(t0, t1)'
05:57:26 <lambdabot>     In the second argument of `Data.Bifunctor.bimap', namely `(2, 3)'
05:57:26 <lambdabot>     In the expression: Data.Bifunctor.bimap show (2, 3)
05:57:29 <donri> :t Data.Bifunctor.bimap show show (2,3)
05:57:31 <lambdabot> (String, String)
05:57:40 <latro`a_> I guess I meant standard instances, but OK
05:57:44 <arkeet> :t Data.Bifunctor.bimap show length (2, "hello")
05:57:46 <lambdabot> (String, Int)
05:57:51 <latro`a_> I understand that you *can* make use of that functionality, I was curious if anyone actually had
05:57:54 <arkeet> would be ("2", 5)
05:58:11 <latro`a_> oh wait nvm, there's a reads in there already
05:58:11 <ski_> latro`a_ : if there's a standard instance taking fixity into respect, it could possibly use this
05:58:15 <latro`a_> no new instances
05:58:21 <c-ab> :t (2,3)
05:58:22 <lambdabot> (Num t1, Num t) => (t, t1)
05:58:22 <latro`a_> (I think?)
05:59:13 <ski_> latro`a_ : well, the point is that i'm building new (custom) `ReadS' actions -- so the intent of your "new instances" is probably there
05:59:19 <c-ab> o ok
06:00:36 <ski_> latro`a_ : of course, if one can avoid having to backtrack, that would be more efficient -- but it's handy to have the ability (e.g. for an initial, perhaps inefficient, solution)
06:00:43 <donri> edwardk: shouldn't this say *second* argument? http://hackage.haskell.org/packages/archive/bifunctors/3.2/doc/html/Data-Bifunctor-Joker.html
06:01:19 * ski_ doesn't like the "commit by default" policy in `Parsec'
06:01:20 <M30W> Which is more effeciant?   'c' `elem` ['a'..'z']  vs  c >= 'a' && c <= 'z'
06:01:22 <M30W> Second?
06:01:31 <ski_> M30W : probably
06:01:34 <edwardk> donri: yes
06:02:00 <M30W> :)
06:02:02 <donri> edwardk: i'll fix!
06:02:03 * edwardk grants donri access to fix it and goes to bed.
06:02:11 <donri> hihi
06:02:14 <ski_> profunctor is difunctor
06:03:42 * typoclass . o O ( what are those difunctors that i keep hearing about ... kids these days ... )
06:04:35 <ski_> if you're comfortable calling Hutton and Meijer kids, ;)
06:05:46 <JuanDaugherty> if you believe in existence after animal life, everybody is "kids"
06:06:29 <JuanDaugherty> neonates ftm
06:07:45 <ChongLi> Meijer is a kid for sure
06:07:49 <ChongLi> he'll always be a kid
06:07:57 <ChongLi> that's why he's so great!
06:16:36 <mm_freak> how can i expect /all/ samples of a quickcheck testcase to fail?  in other words, how do i turn non-failure into a test failure?
06:16:55 <elliott> donri: "WrappedBifunctor"'s doc is wrong too!
06:17:00 <mm_freak> expectFailure just makes failures non-fatal
06:17:27 <mietek> Does anyone know what's the right way to generate URLs in Yesod including #anchors?
06:25:48 <joker_89> how can i do the sum of 2 lists of integers?
06:26:00 <joker_89> lik [l1+l2,l1+l2,...]
06:28:26 <c-ab> list comprehension
06:28:32 <Mortchek> @type zipWith (+)
06:28:34 <lambdabot> Num c => [c] -> [c] -> [c]
06:28:52 <Mortchek> > zipWith (+) [1, 2, 3] [4, 5, 6]
06:28:54 <lambdabot>   [5,7,9]
06:29:46 <c-ab> > zipWith (+) [1..] [4, 5, 6]
06:29:47 <lambdabot>   [5,7,9]
06:34:00 <Tehnix> mietek: <a href=@{ArchivesR}#hejsa>
06:34:07 <Tehnix> mietek: #hejsa being the hashtag
06:35:01 <Tehnix> mietek: that is in the .hamlet file. I presume that's where you wanted it?
06:39:00 <c-ab> > [3,2,1] \\ [2,1,4]
06:39:02 <lambdabot>   [3]
06:39:02 <M30W> How might one go about running an io function that takes no arguments in a loop?
06:39:32 <M30W> -> [IO Token]
06:39:45 <M30W> or IO [Token]
06:39:49 <mietek> Tehnix: that's beautiful; I should've tried that! Thanks
06:40:01 <byorgey> M30W: what is the type of the thing you want to run in a loop?
06:40:13 <M30W> genToken :: IO Token
06:40:42 <M30W> It uses randomRIO
06:42:15 <arkeet> M30W: you don't.
06:42:24 <arkeet> either that, or unsafeInterleaveIO, but you don't.
06:42:31 <M30W> arkeet: No way to iterate it somehow?
06:42:39 <arkeet> not safely.
06:42:47 <arkeet> because it must produce the entire infinite list before you can perform anything else.
06:43:16 <byorgey> you cannot do it if you want an INFINITE list, true.  But you can easily do it for any given finite length.
06:43:21 <byorgey> just use  replicateM
06:43:21 <arkeet> so you can use unsafeInterleaveIO to do "lazy IO", or you could do some iteratee/conduit/pipe thing
06:43:39 <arkeet> ah, I did assume "loop" meant infinite loop.
06:43:56 <M30W> [ pureFunction | _ <- [0..15] ] is valid (Sure there is a better way to do such) and there is no way to do this with IO?
06:44:13 <arkeet> for a finite list, replicateM
06:44:25 <arkeet> :t replicate
06:44:26 <lambdabot> Int -> a -> [a]
06:44:27 <arkeet> :t replicateM
06:44:29 <lambdabot> Monad m => Int -> m a -> m [a]
06:44:44 <arkeet> :t sequence -- related
06:44:45 <lambdabot> Monad m => [m a] -> m [a]
06:44:59 <M30W> sequence and mapM use arguments
06:45:18 <arkeet> huh?
06:46:25 <M30W> mapM (\_ -> genToken) [0..15]
06:46:27 <M30W> Win
06:46:39 <arkeet> also known as replicateM 16 genToken
06:46:41 <arkeet> ...
06:46:45 <M30W> O.o
06:47:04 <M30W> @hoogle replicateM
06:47:04 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
06:47:04 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
06:47:04 <lambdabot> Data.Sequence replicateM :: Monad m => Int -> m a -> m (Seq a)
06:47:05 <preflex>  lambdabot: you have 1 new message. '/msg preflex messages' to read it.
06:47:15 <M30W> Yay :)
06:47:17 <arkeet> I guess you missed the part where both of us mentioned replicateM.
06:47:25 <srhb> Can I make a function with TH that creates a number of named top level definitions? Right now I have a list comprehension that defines a few variables n,m that I want to iterate over, but I keep getting stuck on them being defined locally, which is apparently not allowed.
06:47:27 <mietek> Tehnix: do you know how to do that when calling redirect?
06:47:38 <M30W> arkeet: I read it as a different function
06:48:03 <byorgey> srhb: sure
06:48:08 <srhb> Hurm..
06:48:24 <srhb> [ FunD ... n ... m ... | n <- ..., m <- ... ] ?
06:49:19 <M30W> O.o
06:49:40 <M30W> srhb: You trying to create lots of dummy records?
06:49:46 <srhb> Nope.
06:50:03 <srhb> Just making a bunch of named functions. No real reason. :-)
06:50:10 <srhb> OTher than learning TH
06:51:20 <M30W> Ah T
06:51:21 <M30W> TH
06:54:41 <srhb> So say I wanted to make x_n for n e {1..10} with the values [1..10] as well. How would I go about that? I want something like [ valD ... n  | n <- [1..10]]
06:57:38 <hpaste> beaky pasted “Why is my minimax implementation incorrect?” at http://hpaste.org/83339
06:57:51 <epta> offtopic: is there a way to make github show html in README's markdown?
06:57:58 <byorgey> srhb: what in particular are you having trouble with?
06:58:14 <byorgey> srhb: I don't remember the exact details but there is a way to convert a String into a name
06:58:45 <hpaste> beaky revised “Why is my minimax implementation incorrect?”: “Edit: Why is my minimax implementation incorrect?” at http://hpaste.org/83339
06:59:01 <Botje> beaky: might want to check what you just pasted.
06:59:13 <beaky> yeah I pasted the wrong thing sorry :( fixed :D
06:59:22 <byorgey> ValD (VarP (mkName $ "x" ++ show n)) ....   -- srhb
06:59:57 <byorgey> srhb: you really just have to poke around in the Haddock documentation for the AST until you find what you want.
07:00:07 <Botje> beaky: that's not a lot to go on ..
07:00:14 * M30W waits for his computer to generate 1024 different tokens.. Hehe MPD froze :P 
07:00:19 <M30W> ghci killed it's self O.o
07:00:41 <Botje> M30W: all hail the glorious OOM killer!
07:00:56 <beaky> Botje: ah so my problem may lie in one of the helper functions like gameTree, scoreTree, or nextStates?
07:01:06 <beaky> alright I will paste those too :D
07:01:09 <M30W> Botje: IO is slow on my systems :(
07:01:15 <M30W> All of them :P
07:02:52 <Botje> beaky: it's slightly less convoluted to zip each board with the result of scoreTree s . gameTree s
07:03:07 <Botje> then you can do maximumBy (compare `on` snd) or somesuch
07:04:30 <beaky> oh
07:04:47 <beaky> :t maximumBy
07:04:52 <lambdabot> (a -> a -> Ordering) -> [a] -> a
07:05:01 <ClaudiusMaximus> :t comparing
07:05:03 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
07:05:11 <Botje> or that.
07:05:31 <fryguybob> epta: Github pages or use pandoc to convert to markdown?
07:06:39 <beaky> @src comparing
07:06:40 <lambdabot> Source not found. Just what do you think you're doing Dave?
07:06:46 <beaky> @hoogle comparing
07:06:47 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
07:06:59 <EvanR> how to zip two lists that are not the same length but put the items in smaller list with the items in the bigger list that satisfy a predicate
07:07:01 <beaky> :t comparing snd
07:07:03 <lambdabot> Ord a => (a1, a) -> (a1, a) -> Ordering
07:07:19 <srhb> Hrm. Now I have [[DecQ] -> DecQ] .. That doesn't seem right.
07:07:38 <beaky> :t maximumBy (comparing snd)
07:07:39 <lambdabot> Ord a => [(a1, a)] -> (a1, a)
07:08:28 <alshain> @pl mySqrt x = head $ filter (goodEnough x) $ iterate (improve x) 1
07:08:28 <lambdabot> mySqrt = head . liftM2 filter goodEnough (flip iterate 1 . improve)
07:08:46 <srhb> At least, I have no idea how to splice that.
07:10:28 <Botje> EvanR: filter the bigger list first?
07:11:27 <srhb> Oh duh.. I think.
07:11:43 <EvanR> Botje: right... but
07:13:19 <EvanR> Botje: sorry. what if you want the whole first list. and you want Nothing paired with the false predicates, and Just x where x from the second list paired with the true
07:14:15 <Botje> ooh, hmm.
07:14:30 <Botje> I'd just write a tail-recursive function for that then.
07:14:40 <EvanR> thats basically what i did, a loop
07:15:35 <Botje> you could concoct something with unfoldr, but it'd be more cluttered than the straight version.
07:16:32 <EvanR> i know theres no standard function, but what im trying to figure out is if theres a more sensible algorithm design than basically a php style loop that builds a result
07:16:44 <Botje> well, what do you have now?
07:16:56 <EvanR> nothing, i wrote it in ruby
07:17:00 <EvanR> the above loop
07:17:04 <Botje> ah.
07:17:19 <EvanR> heres the use case
07:17:21 <srhb> How do I splice in a DecQ?
07:18:19 <EvanR> "select * from foo where bar = ?" and i tokenized this into the following list [Text "...", SingleQuestionMark] and you have in this case one argument ["baz"]
07:18:40 <EvanR> so you want to put the args with the question mark
07:19:06 <Saizan> is that Q Dec ?
07:19:13 <srhb> Yes
07:19:31 <Saizan> you need to $(liftM return foo), iirc
07:19:57 <Saizan> because $(..) expects a Q [Dec] in a declaration context
07:20:39 <srhb> Saizan: You are correct. For some reason I just couldn't figure that out.
07:21:17 <hpaste> Botje pasted “zip-ish function” at http://hpaste.org/83341
07:21:25 <Botje> EvanR: something like that ^^
07:25:36 <EvanR> ok
07:27:09 <EvanR> that doesnt look exactly right but now i get it
07:28:42 <joker_89> how can i do this operator?
07:28:42 <joker_89> (<+>) :: [[Float]] -> [[Float]] -> [[Float]]
07:28:53 <joker_89> the sum of 2 matrix
07:29:12 <ski_> @type (zipWith . zipWith) (+)
07:29:13 <lambdabot> Num c => [[c]] -> [[c]] -> [[c]]
07:29:15 <Botje> zipWith (zipWith (+))
07:29:47 <Botje> (I so wish people would stop abusing [[a]] as matrices)
07:32:35 <hiptobecubic> GUYS
07:32:37 <hiptobecubic> I GET IT
07:32:45 <hiptobecubic> http://youtu.be/2PJ_DbKGFUA?t=41m
07:33:15 <byorgey> Botje: it's fine as long as you never want to multiply them, index into them, invert them, factor them, ...
07:33:26 <byorgey> but adding them is just peachy =)
07:38:42 <Botje> :]
07:42:22 <hpaste> srhb pasted “My first TH abomination! :3” at http://hpaste.org/83342
07:42:29 <srhb> It would appear this takes some practice. :P
07:43:35 <byorgey> yes, it does.  but you seem to be getting the hang of it.
07:43:39 <d-snp> aI have created a monster
07:43:46 <d-snp> take bets if it compiles!
07:44:14 <typoclass> srhb: man, what is this stuuuff ...
07:44:16 <typoclass> :-)
07:44:18 <srhb> typoclass: :P
07:45:17 <liyang> srhb: I'm not a fan of the convenience helpers like funD. Would much rather use FunD instead.
07:45:37 <srhb> Oh, I just did as the docs told me. :P
07:46:09 <ski_> `funD' ?
07:46:09 <beaky>                      
07:46:11 <byorgey> good point, especially if you are just going to give it a Q something created with 'return'
07:46:26 <d-snp> it didn :(
07:46:26 <byorgey> might as well use FunD and omit the 'return'
07:46:28 * liyang feels they just pollute the namespace. 
07:46:33 <srhb> Oh, so that's what it does.
07:46:37 <srhb> I had no idea. :P
07:46:39 <liyang> They were added before we had Applicative, I believe.
07:46:57 <byorgey> liyang: good point re: Applicative.
07:49:37 <typoclass> srhb: what is the translation of that into normal haskell? (i have no clue about th) "get_3_4 = \(_,_,x,_) = x" ?
07:50:43 <byorgey> typoclass: yep
07:50:53 <typoclass> byorgey: thanks
07:51:12 <typoclass> ... erm, modulo typos ...
07:52:54 <uniquenick> is there a way to have two executables in a .cabal file and tell "cabal install" to only build one of them?
07:53:21 <geekosaur> flags, presumably
07:53:25 <liyang> srhb: you're just playing around with TH right? 'Cos there's _1, _2, ... in lens...
07:53:30 <byorgey> uniquenick: yes, you can use boolean flags
07:53:39 <byorgey> @package diagrams-builder
07:53:39 <lambdabot> http://hackage.haskell.org/package/diagrams-builder
07:53:44 <byorgey> uniquenick: see ^^^ for an example
07:55:17 <d-snp> omg it compiles
07:55:23 <d-snp> haskell-fu++
07:55:31 <uniquenick> perfect, thanks.  I suppose that answers my other question: "is there a way to share build-depends" with a no then?
07:56:25 <liyang> uniquenick: not that I'm aware of. I usually only specify versions for the main part (the library) and just list the packages for other bits.
07:57:23 <notdan> http://vimeo.com/59215336 that's a really nice talk
07:57:25 <byorgey> uniquenick: not between executables, no.  But note if you have a bunch of shared code, you can make that part into a library and list all the dependencies in the library section, then have the executables just depend on the library
07:58:46 <hpaste> srhb annotated “My first TH abomination! :3” with “My first TH abomination! :3 (annotation)” at http://hpaste.org/83342#a83343
07:58:56 <srhb> Now with 900% less abominability.
07:59:22 <srhb> typoclass: And yes :-)
07:59:29 <typoclass> srhb: thanks
07:59:37 <srhb> liyang: Yeah, just playing around to learn the basics.
07:59:49 <srhb> It seemed like an obvious use case if not for lens
08:00:36 <typoclass> srhb: 'let' inside a list comprehension, huh? sporty
08:01:02 <srhb> Right, very fancy! I didn't want to put it in the where and pass n and m everywhere.
08:02:26 <srhb> I'm sure it can be deuglified further, but not sure I'm capable :P
08:03:20 <ski_> i like how you have a complete `let'-`in' in the collectee of the list comprehension :)
08:03:35 <srhb> Is it really that horrible? :P
08:03:46 <ski_> not really, imo :)
08:04:01 <ski_> > [() | let {}]
08:04:02 <lambdabot>   [()]
08:04:18 <liyang> I'm quite proud of http://hackage.haskell.org/packages/archive/enummapset-th/latest/doc/html/src/Data-EnumMapSetWrapper.html
08:05:39 <Saizan> srhb: it'd probably look better on the rhs of |
08:06:52 <srhb> How would that work?
08:06:58 <srhb> Oh.. Right.
08:07:01 <srhb> Derp.
08:07:07 * hackagebot sandi 0.2 - Data encoding library  http://hackage.haskell.org/package/sandi-0.2 (MagnusTherning)
08:07:13 <ski_> srhb : hm, i assume this is unhygienic name generation ?
08:09:01 <srhb> ski_: ... maybe!
08:09:14 <srhb> What's unhygienic about it?
08:10:17 <ski_> than `$(makeGets 3)' can reference (in this case introduce) identifiers that aren't explicitly/literally mentioned in that expression
08:10:22 <ski_> s/than/that/
08:10:32 <typoclass> srhb: suppose the module by coincidence already contains a get_2_2 function. i think it's mostly an issue in lisp
08:10:37 <ski_> (which i assume is the point in this example)
08:11:04 <srhb> Ah yes, entirely true.
08:11:19 <srhb> But the compiler would complain about that, I think
08:11:44 <srhb> Yep, it does. Multiple declarations.
08:12:07 * hackagebot omnicodec 0.7 - data encoding and decoding command line utilities  http://hackage.haskell.org/package/omnicodec-0.7 (MagnusTherning)
08:12:28 <typoclass> ski_: the hygienic way is "newName", right? like in the hpaste
08:13:16 <srhb> And pass it in as an argument to makeGets, yeah
08:13:43 <ski_> typoclass : which hpaste ?
08:13:43 <srhb> Well actually mkName works just as well then
08:13:58 <ski_> oh, right, there's `newName' in there as well
08:14:10 <typoclass> ski_: ... yup
08:14:15 <ski_> typoclass : i suppose, but i don't understand hygiene aspects in TH very well
08:14:35 <srhb> Either way I can make makeGets take a String and use that as the base of the name instead of "get"
08:14:45 <srhb> And if there's a conflict, the compiler complains anyway.
08:14:57 <typoclass> ski_: i dunno, it seems not as much of an issue because of compiler complaints
08:14:59 <srhb> So I don't think there's anything really unhygienic about it.
08:15:16 <srhb> I mean, aside from the stupidity of it all. :P
08:16:22 <ski_> typoclass : hm, you mean variable not in scope errors ?
08:18:53 <srhb> I'm not sure I really understand why I need to newName the lambda parameter. I mean it's not top level thing anyway.
08:19:03 <srhb> Why does ghc have to make it unique?
08:19:20 <ski_> `newName' is basically `gensym' aiui
08:19:22 <ion> nand: was?
08:19:49 <typoclass> ski_: i thought "hygiene" in lisp referred to inadvertent name collisions, like "my macro messes around with x, but suppose the caller has an x defined already"
08:20:42 <liyang> srhb: avoids x shadows y warnings.
08:20:46 <ski_> typoclass : hygiene is about maintaining lexical scope (at least by default), even in the presence of macros and code generation and manipulation operations
08:21:15 <srhb> Which ghc takes care of by complaining about multiple declarations, right?
08:21:33 <ski_> afaiu, it's all manual in TH
08:22:01 <ski_> (well, possibly not with `[| ... |]' quotations)
08:22:07 <srhb> To put it another way, if I define foo = bar and then have a TH splice $(mkFoo) GHC complains about multiple declarations
08:22:45 <sproingie> ok what the *fuck* is wrong with haskell-mode?  tab brings up help for haskell-mode-hook?
08:23:11 <srhb> sproingie: I had that too, but I think it's ghc-mod doing that. Or at least some auto complete thingy.
08:23:43 <srhb> Or maybe even FlyMake. I didn't experience it before installing ghc-mod and Flymake at least.
08:23:44 <sproingie> don't have ghc-mod but i think i added some autocomplete junk.  cool, i'll nuke that then
08:24:02 <srhb> At any rate, killing the buffer and opening it again Just Worked for me.
08:24:19 <ski_> with hygiene,  $(mkFoo 'x)  can't refer to any variable in the context it's spliced into, apart from `x' (since it was explicitly passed to it)  -- at least *unless* you go out of your way to make `mkFoo' ungygienically refer to some selected identifiers
08:24:38 <joker_89> how can i simulate zipwith using list comprehension ? for sum 2 lists of lists
08:25:23 <sipa> joker_89: i don't think you can
08:25:28 <sipa> at least not efficiently
08:25:45 <joker_89> i tried this but is not the same: yz1 <+> yz2 = [[x+y|x<-xs1,y<-xs2]| xs1<-yz1, xs2<-yz2]
08:25:47 <liyang> joker_89: [ f x y | (x, y) <- zip xs ys ]
08:26:17 <sipa> [ (x!!i) ++ (y!!i) | i <- [0..] ] would also work
08:26:26 <ski_> hygiene also means that  $(mkFoo 'x)  could exand to code which references *unexported* identifiers from the context in which `mkFoo' was defined
08:26:39 <sproingie> srhb: it's haskell-doc-mode
08:26:52 <liyang> > [ (a, b) | a <- [1,2,3] | b <- "abc" ]
08:26:54 <lambdabot>   [(1,'a'),(2,'b'),(3,'c')]
08:27:09 <liyang> ^ that
08:27:18 <sproingie> which is something i actually want, so i guess i need to butcher it
08:27:24 <sipa> liyang: woah, i didn't know that was possible
08:27:38 <liyang> I think it's kind of new-ish.
08:27:41 <ski_> srhb : if you look at <http://community.schemewiki.org/?syntax-case-examples>, in the last example, `(aif (compute) (+ it 1) 0)' unhygienically introduces a binding of `it' in the consequent of the conditional
08:28:45 <liyang> sipa: http://colourbox.tsuru.it/local/doc/ghc/html/users_guide/syntax-extns.html#parallel-list-comprehensions
08:28:51 <ski_> srhb : note how one have to explictly call `datum->syntax-object' on the identifier `aif' to get a hold of the context in which `(aif ...)' expands (and where `it' has meaning, in `(+ it 1)')
08:28:55 <liyang> Oops. Ignore that link.
08:29:29 <ski_> (in the identifier `aif', and the (raw) variable name `it')
08:29:54 <liyang> sipa: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#parallel-list-comprehensions
08:31:10 <srhb> ski_: I see.
08:32:52 <ski_> unless you go out of your way to introduce an identifier in the environment the splice appears in, variables automatically refer to what is in scope at the definition of `mkFoo' (or, is a local variable in the definition of it)
08:33:51 <sproingie> srhb: aha, looks like the problem goes away when i move all my mode customizations into an eval-after-load
08:33:51 <ski_> in the  $(mkFoo 'i)  example, though, the `i' "knows" it belongs to the environment the splice appears in, so `mkFoo' could then refer to `i' in that environment, via it
08:34:12 <joker_89> what means in haskell !! ?
08:34:29 <ski_> joker_89 : list indexing
08:34:36 <sipa> joker_89: take nth item from a list; but don't use it
08:34:37 <sproingie> @hoogle (!!)
08:34:38 <lambdabot> Prelude (!!) :: [a] -> Int -> a
08:34:38 <lambdabot> Data.List (!!) :: [a] -> Int -> a
08:34:38 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
08:34:48 <ski_> > [0,1,2] !! 3  -- index out of bounds
08:34:49 <lambdabot>   *Exception: Prelude.(!!): index too large
08:35:25 <joker_89> [0,1,2]!!
08:35:28 <joker_89> >[0,1,2]!!
08:35:32 <joker_89> > [0,1,2]!!
08:35:34 <lambdabot>   <hint>:1:10: parse error (possibly incorrect indentation)
08:35:42 <sipa> > "hello" !! 2
08:35:43 <ski_> missing right operand
08:35:44 <lambdabot>   'l'
08:36:12 <sproingie> !! is almost always an inappropriate thing to use on lists
08:36:19 <sproingie> if you need to index, use an array and !
08:36:54 <ski_> > listArray (0,4) "hello" ! 2
08:36:55 <lambdabot>   'l'
08:36:56 <geekosaur> joker_89, is there some reason you think a singly linked list is an appropriate representation for a matrix?
08:37:41 <sproingie> @hoogle (!)
08:37:42 <lambdabot> Prelude (!!) :: [a] -> Int -> a
08:37:42 <lambdabot> Data.List (!!) :: [a] -> Int -> a
08:37:42 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
08:38:05 <sproingie> eh, not the best way to hoogle operators
08:38:24 <sproingie> joker_89: anyway you're looking for Data.Array
08:38:31 <ski_> @index !
08:38:31 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.IntMap, Data.Map, Data.Array, Text.Html
08:38:46 <ski_> @type (Data.Array.IArray.!)
08:38:48 <lambdabot> (Ix i, Data.Array.Base.IArray a e) => a i e -> i -> e
08:38:49 * geekosaur would have said Vector, but either one is more sensible
08:43:54 <Philippa> so, I'm trying to build myself labelling of individual functors 'inside' a functor composition type operator
08:44:06 <Philippa> (so Label wrappers and :.)
08:44:06 <Raydiation> could it be that its really easy to write a compiler/interpreter in haskell?
08:44:20 <Raydiation> the whole type matching reminds me of yacc
08:44:28 <Philippa> I'm failing to get the right instances, anyone know what I should be doing?
08:44:41 <Philippa> Raydiation: you wouldn't be the first person to start using Haskell for that reason
08:44:45 <Philippa> but there're many, many reasons more
08:44:54 * ski_ suspects he would have use for such labelling as well, here
08:45:37 <ski_> (though for the moment, i'm kludging my way around lack of rank-`2' instances)
08:46:07 <Philippa> alternative phrasing: I want to lift a predicate over a type-level monoid :-)
08:46:53 <ski_> hm, that sounds interesting
08:47:04 <ski_> lift in what sense ?
08:49:09 <Tehnix> sup
08:49:25 <Tehnix> woops, wrong channel :|
08:49:45 <ski_> Tehnix : inf
08:50:09 <Philippa> ski_: I guess I want a left-biased map, in effect? Or at least the result of one
08:52:11 <ski_> hmm .. `type class TypeMonoid k where Empty :: k; Append :: k -> k -> k' ?
08:52:58 <ski_> Philippa : .. i'm not clear on what kind of situation you're considering
08:54:01 <ski_> hm
08:55:05 <Philippa> ski_: I guess I'm being distinctly ambiguous/stab-in-the-dark about things, yeah
08:55:40 <ski_> it can happen
08:55:58 <Philippa> in this case: I know how to grab a labelled thing in my hand. I'd like to write the steps to handle grabbing the left-most matching labelled thing in a "list" where :. is the ++ equivalent
08:56:15 <ski_> i assume given `blah :: (Foo . Bar . Baz) T', and `f :: forall a. Bar a -> Quux a', we'd want `myLift f blah :: (Foo . Quux . Baz) T', at least
08:56:37 <ski_> relazing the polymorphism on `f' could be useful
08:57:05 <ski_> (`myLift' would find itself for how many steps it must traverse the composition chain)
08:57:26 <ski_> is that anyway near what you're pondering ?
08:59:07 <Philippa> sort of, yeah
08:59:29 <Philippa> but clarifying the "sort of" is probably a case of "I'm not awake enough"
08:59:51 <Philippa> I mean, I can go without that generalisation, it's just in the "would be nice to have nailed once and for all" category
09:00:27 <ski_> in my case, i have some constructors which are ersatz for subtyping, and others that are "real"
09:00:38 <`nand`> ion: we need something like ‘base’ but for fractional types
09:01:06 <Philippa> ski_: *nod*
09:01:11 <joker_89> whats the problem if this code? z1 <+> yz2 = [ [ (yz1!!(i+j)) + (yz2!!(i+j)) | j <- [0..(columnas yz1)-1] ] | i <- [0..(filas yz1)-1]]
09:01:16 <joker_89> for sum 2 lists of lists
09:01:24 <ski_> when i'm factoring the types, i sometimes have to introduce new intermediate layers -- it'd be nice if i hadn't have to manually change all the carefulling balanced traversals of this
09:01:32 <sipa> joker_89: sloow
09:02:32 <ski_> (ultimately i take a `Mu' of the whole "layer" type)
09:02:34 <Philippa> ski_: yep. It's... type-level programming in Haskell's an appalling accident, just not quite as bad as C++'s :-)
09:02:43 <Philippa> ski_: you too, huh?
09:02:53 <Philippa> I just call it Fix, but same difference
09:03:22 <byorgey> joker_89: if yz1 is a list of lists, then  yz1!!(i+j) is a list, and you cannot add it
09:03:36 <byorgey> joker_89: you would have to index twice like   (yz1!!i)!!j
09:03:44 <joker_89> oh yes...
09:04:05 <ski_> Philippa : hm, i suppose i actually don't need `Mu' for this atm (though i have another argument which is sortof similar, where i need it)
09:04:27 <ski_> (but being able to decorate is nice, so why not ?)
09:04:52 <Iceland_jack> joker_89: hint, indexing lists in Haskell is often a sign that you should try a different approach
09:05:23 <joker_89> i know that i can do it wint zipWith but i wanted to try with indexes
09:05:45 <geekosaur> agan, is there some reason you are using perhaps the worst possible type for this?
09:07:07 <Mortchek> joker_89, why do it with indices if you can do it easier with zipWith (assuming I understood your problem when I gave that answer).
09:07:12 <Mortchek> s/\./?/
09:07:14 <byorgey> geekosaur: could you phrase that more constructively?  joker_89 is clearly just learning.
09:07:18 <ski_> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = array ix [(i,f i) | i <- range ix]
09:07:20 <lambdabot>  Defined.
09:08:13 <byorgey> joker_89: if you are just playing around for the sake of learning, that's fine.  If you want to use that code in a real application, note that it will be very inefficient.
09:08:49 <joker_89> yes i'ts jast for learning
09:08:52 <joker_89> only this
09:09:51 <byorgey> Mortchek: because getting code that works (without understanding it) is not the only possible goal of coding.
09:10:19 <Mortchek> byorgey, I never said it was; I was looking specifically for joker_89's reason. They gave it.
09:10:47 <Mortchek> joker_89, I think something that might teach you more with this particular problem would be to try doing the same thing with pattern matching. Using (!!) is just kind of clumsy and likely to frustrate you more than teach you anything valuable.
09:11:17 <joker_89> with pattern matching can i do this?
09:11:20 <byorgey> Mortchek: sure, it's just that saying "why do X when you could do Y" often implies "you are doing it wrong" than it does a genuine desire to know the answer to the question.
09:11:59 <byorgey> I am just sensitive to the impression newbies get here, and it often has a lot more to do with the way things are phrased than the actual information imparted.
09:12:00 <Mortchek> byorgey, I only meant to imply that it was harder, that is all.
09:12:39 <Mortchek> joker_89, sure. Have you read any of Learn You A Haskell by any chance?
09:13:17 <joker_89> but i am sayiing to sum 2 lists of lists using patterns
09:15:46 <Mortchek> joker_89, yep, there is a pretty simple way to write this using pattern matching on lists.
09:16:43 <ski_> @type let yz0 <*> yz1 = tabulate ((minRow0,minCol1),(maxRow0,maxCol1)) $ \(k,i) -> sum [ yz0 ! (k,j) * yz1 ! (j,i) | j <- range (minCol0,maxCol0)] where ((minRow0,minCol0),(maxRow0,maxCol0)) = bounds yz0; ((_minRow1,minCol1),(_maxRow1,maxCol1)) = bounds yz1; in (<*>)
09:16:44 <lambdabot> (Num e, Ix t2, Ix t1, Ix t) => Array (t1, t) e -> Array (t, t2) e -> Array (t1, t2) e
09:16:56 <Mortchek> The idea is you care about only the next element of both lists at any given moment, since when you're summing pairs of elements you don't really care about the rest of the list just yet.
09:17:29 <Mortchek> So you can write something like: foo (x:xs) = …
09:17:37 <Mortchek> err, foo (x:xs) (y:ys) = …
09:18:20 <Mortchek> where x and y are the first (or next, depending on how you look at it) elements, and xs and ys are the rest.
09:18:31 <joker_89> oh yes i se..
09:19:16 <joker_89> but if i define an operator how can i use foo (x:xs) (y:ys)?
09:19:50 <joker_89> solved
09:20:01 <ski_>   (x:xs) <+> (y:ys) = ...
09:20:02 <ski_> alt.
09:20:11 <ski_>   (<+>) (x:xs) (y:ys) = ...
09:20:27 <ski_> if the precedence is lower than `5' (which is the precedence of `:') you could even say
09:20:33 <ski_>   x:xs <+> y:ys = ...
09:20:40 <kartoffelbrei> is there a definition for "flip (.)" as an operator with a high fixity (Control.Category.>>> has fixity )in some package? Hoogle failded me.
09:21:14 <applicative_> join idris
09:21:18 <applicative_> hah
09:21:29 <simpson> kartoffelbrei: I wouldn't be surprised if lens has one, but I don't know which it would be.
09:21:35 <ski_> was the `/' left in another channel ?
09:21:36 <simpson> :t (#) -- is it this one?
09:21:37 <lambdabot> parse error on input `)'
09:21:50 <aCube> If I have an iso f g, f . g = id must hold. But must g . f = id also hold?
09:22:00 <ski_> aCube : yes, that's a requirement
09:22:36 <ski_> aCube : if only `r . s = id' holds, it's not necessarily an isomorphism situation. it is called a retract situation, `r' is the retraction and `s' the section of it
09:22:59 <kartoffelbrei> simpson: no, but thanks anyways
09:23:05 <joker_89> but if i do (x:xs) <+> (y:ys) then x and y are also lists
09:23:13 <Mortchek> joker_89, are you familiar with the concept of recursion?
09:23:13 <ski_> yes
09:23:20 <joker_89> yes
09:23:27 <aCube> ski_: But there is no data type for that in lens, is there?
09:23:35 <ski_> define a helper function to deal with `x' and `y' ?
09:23:52 <ski_> aCube : no idea, i'm not that familiar with `lens'
09:24:12 <ski_> you could ask edwardk, i suppose
09:24:14 <Mortchek> Well, x and y are elements of your list. xs and ys are the same type as the original lists. So if you have two [Int]s, then x and y are Ints.
09:24:51 <applicative_> oh a lens concept for section/retract
09:25:25 <joker_89> yes but the pattern with detct that are two ints for then sum
09:26:23 <Mortchek> joker_89, I don't understand.
09:26:39 <joker_89> i have this pattern (x:xs) <+> (y:ys) = (x) <+> (y) : xs<+>ys
09:26:52 <joker_89> but now i need the 2ond patern wichi is the particular
09:27:11 <Mortchek> Well, say you have [1, 2, 3] and [4, 5, 6], and you are looking at just 1 and 4 right now. What do you want to do with them?
09:27:38 <Mortchek> (In English, not in code.)
09:27:39 <joker_89> sum x+y
09:27:42 <ski_> joker_89 : your `(<+>)' accepts two lists of lists of numbers
09:27:45 <joker_89> sum the values
09:27:52 <Mortchek> Sure, you want to add them. So what operator adds two numbers together?
09:27:57 <ski_> joker_89 : the recursive call `xs<+>ys' passes two lists of lists of numbers
09:28:15 <ski_> joker_89 : however, in `(x) <+> (y)' you're attempting to pass two plain lists of numbers
09:28:29 <ski_> (see the problem ?)
09:28:42 <joker_89> yes
09:28:44 <joker_89> is not the same
09:29:00 <ski_> so, what to do ?
09:29:14 <Mortchek> If I say "add the number 1 to the number 4", what does that translate to as a Haskell expression?
09:29:24 <monochrom> 4+1
09:29:32 <kartoffelbrei> 1+4
09:29:59 <aCube> applicative_: Do you know if there is something like that in lens?
09:30:06 <ski_> hm, in `m + n' is `m' or `n' traditionally the augend ?
09:30:15 <Mortchek> joker_89, so do you see that you need x + y?
09:30:41 <joker_89> yes .. but i be away some minuts for reflexionig thanks ;)
09:30:48 <latro`a_> ski_, I think that mostly depends on what you've already set up
09:30:57 <latro`a_> for example it would vary in situations with double sums
09:31:09 <monochrom> I think m is the augend. I don't actually know. I only remember that "x/y" x is the dividend, then I generalize the -end
09:31:11 <ski_> double sums `
09:31:12 <ski_> ?
09:31:24 <latro`a_> indexing on double sums
09:31:32 <ski_> the addend is the one that acts, the augend is the one that is added to
09:31:41 <ski_> (think monoid/group action)
09:31:43 <latro`a_> oh you didn't mean the names, you meant the positions
09:31:49 <ski_> yes
09:32:13 <latro`a_> I think that varies as well, for example when talking about cosets usually you talk about both left and right cosets
09:32:43 <ski_> (e.g. in `point + vector', `point' is the augend and `vector' is the addend)
09:33:31 <latro`a_> seems like that distinction is *most* important when you're talking about different types of things, and essentially irrelevant when things commute
09:33:49 <ski_> yes, more or less
09:33:50 <joker_89> but if i do this : (x:xs) <+> (y:ys) = x+y : xs<+>ys then x+y are lists and i can't sum lists
09:33:50 <latro`a_> then in the middle where you have a noncommutative operation on pairs of things of the same type it matters an intermediate amount
09:34:22 <Mortchek> joker_89, if you give (<+>) two lists of numbers, then x and y are numbers.
09:34:24 <ski_> joker_89 : that's an acceptable definition of summing two plain lists of numbers
09:34:38 <ski_> joker_89 : perhaps now define a function to sum two lists of lists of numbers ?
09:34:49 <ski_> (joker_89 : you need a base case too, of course)
09:35:15 <ski_> (e.g. you could call it `(<<+>>)')
09:35:51 <joker_89> and if i want all in one function
09:36:06 <ski_> why not two ? :(
09:36:18 <ski_> (you could use `where', though)
09:36:25 <joker_89> because why perhaps is posible
09:37:08 <ski_> ?
09:37:26 <monochrom> zipWith (zipWith (+))
09:38:09 <ski_> (*schh* :)
09:38:23 <Mortchek> joker_89 is learning :)
09:39:14 <monochrom> it is not my answer to the original question. it is my answer to "if I want all in one function"
09:39:41 * ski_ . o O ( "You could have invented `zipWith' -- and maybe you already have !" )
09:40:14 <monochrom> yes
09:40:17 <Mortchek> I've reinvented zipWith in JS before
09:40:56 <monochrom> if you want to use only one function, you must write a higher-order, polymorphic one so that it is applicable to both levels of the nested list
09:41:06 <Mortchek> Well, it was a specialized zipWith that errored out on arrays of different sizes instead of dropping extra elements, because it was for vectors and I didn't think it made sense to zip vectors of different sizes
09:41:36 <monochrom> if you stay first-order or monomorphic, it cannot be done with just one function
09:41:39 <Mortchek> s/a specialized/slightly different from/
09:42:08 <Mortchek> Err, woop. Imagine I rephrased that sentence correctly :P
09:43:04 <Mortchek> Hmm, you could define a Num instance for lists though, no?
09:43:32 <ski_> yes
09:43:34 <Mortchek> instance (Num a) => Num [a]
09:43:46 <ski_> s/(Num a)/Num a/
09:44:21 <Mortchek> Is it bad style to put parens around it if there's just one?
09:44:29 <oio> what is this (=~)
09:44:31 <oio> ?
09:44:57 <monochrom> I always add parens. I like it more.
09:45:38 <monochrom> but frankly both are good styles. toss a coin.
09:45:39 <oio> >:t =~
09:45:39 <geekosaur> oio: see Text.Regex
09:45:47 <oio> >:t (=~)
09:45:57 <feliperosa> :t (=~)
09:45:59 <lambdabot>     Not in scope: `=~'
09:45:59 <lambdabot>     Perhaps you meant one of these:
09:45:59 <lambdabot>       `==' (imported from Data.Eq), `#~' (imported from Control.Lens),
09:46:02 <geekosaur> :t (=~) -- but I don't think it's imporeted
09:46:03 <lambdabot>     Not in scope: `=~'
09:46:03 <lambdabot>     Perhaps you meant one of these:
09:46:03 <lambdabot>       `==' (imported from Data.Eq), `#~' (imported from Control.Lens),
09:46:04 <geekosaur> that
09:46:20 <oio> ok
09:46:29 <ab9rf> it's not in Text.Rege
09:46:31 <ab9rf> regex
09:46:41 <geekosaur> not directly, no
09:46:59 <geekosaur> but that should have a pointer to it somewhere, it's in one of the interface packages
09:47:07 <ski_> Mortchek : depends on who you ask. i (usually) prefer to not have redundant variables in contexts, definiendums, expressions, types
09:47:08 <geekosaur> and each regex backend provides its own implementation
09:47:24 <geekosaur> also the regex stuff is rather confusing at first
09:47:28 <ab9rf> found it :)
09:47:33 <ab9rf> regex-posix
09:47:36 <ski_> Mortchek : my real point was only that you should be aware of the possibility, then decide for yourself
09:48:36 <c-ab> > sin (pi/3)
09:48:37 <lambdabot>   0.8660254037844386
09:48:48 * ski_ . o O ( `map :: (a -> b) -> ([a] -> [b])' )
09:49:50 <Mortchek> Yep, I was aware of it. I've seen both styles, and preferred the one where parens are used regardless.
09:50:41 <Mortchek> (I usually don't like superfluous parens, but it made sense to me there.)
09:51:22 <c-ab> @hoogle [a -> a] -> [a] -> [a]
09:51:23 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
09:51:23 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
09:51:23 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
09:52:02 <monochrom> I add parens for this reason. suppose I see the prefix "class MyClass a", I think "you are defining MyClass". then I continue and it unfolds to "class MyClass a =>", now I have to backtrack "oh you are not defining MyClass". with "class (MyClass a", I do not have you backtract, you are not defining MyClass.
09:52:04 <ski_> @type zipWith id
09:52:05 <lambdabot> [b -> c] -> [b] -> [c]
09:52:41 <ski_> monochrom : i something think it would have been better to have written like `instance Eq [a] <= Eq a'
09:53:08 <c-ab> > zipWith id [sin, cos, tan] [pi/4,pi/4,pi/4]
09:53:10 <lambdabot>   [0.7071067811865475,0.7071067811865476,0.9999999999999999]
09:53:29 <ski_> (the predicate being partially defined coming first, then the conditions)
09:54:15 <ski_> > [sin, cos, tan] `ap` [pi/3,pi/4,pi/6]
09:54:16 <lambdabot>   [0.8660254037844386,0.7071067811865475,0.49999999999999994,0.50000000000000...
09:54:48 <Mortchek> Would that be sort of like writing "p(x) forall x in S"?
09:54:57 <ski_> > [sin, cos, tan] ?? pi/4
09:54:59 <lambdabot>   [0.7071067811865475,0.7071067811865476,0.9999999999999999]
09:55:05 <Mortchek> (in mathematical notation, not necessarily Haskell)
09:55:19 <ski_> perhaps
09:55:51 <oio> >:m System.IO
09:55:56 <ski_> there's a reason we write `f(x) = ..x..' rather than `..x.. = f(x)', and `f(...)' rather than `(...)f'
09:55:57 <oio> >:m + System.IO
09:55:57 <c-ab> > [sin, cos, tan] <*> [pi/3,pi/4]
09:55:59 <lambdabot>   [0.8660254037844386,0.7071067811865475,0.5000000000000001,0.707106781186547...
09:57:06 <erkin> Is there a function to find possible combinations of a list?
09:57:22 <erkin> Like combinations [1,2,3] returns [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
09:57:43 <ski_> sounds like permutations
09:57:53 <erkin> Oh, my mistake.
09:57:56 <ski_> > permutations [1,2,3]
09:57:57 <feliperosa> :t permutations
09:57:57 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
09:57:58 <lambdabot> [a] -> [[a]]
09:57:58 <erkin> I often confuse them.
09:58:18 <erkin> Which library is it in?
09:58:23 <ski_> @index permutations
09:58:23 <lambdabot> bzzt
09:58:29 <ski_> @hooglee permutations
09:58:30 <lambdabot> Maybe you meant: hoogle hoogle+
09:58:32 <ski_> @hoogle permutations
09:58:32 <lambdabot> Data.List permutations :: [a] -> [[a]]
09:58:32 <lambdabot> package action-permutations
09:58:41 <erkin> Thanks.
09:58:58 <c-ab> length $ permutations [1..10]
09:59:02 <c-ab> > length $ permutations [1..10]
09:59:05 <lambdabot>   3628800
10:01:00 <ski_> hm, i wonder what weird ordering `permutations' is using
10:01:01 <c-ab> let fac n = length $ permutation [1..n] in fac 12
10:01:10 <c-ab> > let fac n = length $ permutation [1..n] in fac 12
10:01:10 <ski_> > permutations "abcd"
10:01:12 <lambdabot>   mueval-core: L.hs: removeLink: does not exist (No such file or directory)
10:01:13 <lambdabot>   ["abcd","bacd","cbad","bcad","cabd","acbd","dcba","cdba","cbda","dbca","bdc...
10:01:45 <c-ab> > let n=2 in [1..n]
10:01:47 <lambdabot>   [1,2]
10:02:34 <c-ab> > let fac n = length $ permutations [1..n] in fac 12
10:02:38 <lambdabot>   mueval-core: Time limit exceeded
10:02:39 <ski_> @let select :: MonoidPlus m => [a] -> m (a,[m]); select as = return ([],as) `mplus` case as of [] -> mzero; a:as -> liftM (fmap (a:)) (select as)
10:02:40 <lambdabot>  <local>:9:11:
10:02:40 <lambdabot>      Not in scope: type constructor or class `MonoidPlus'
10:02:40 <lambdabot>     ...
10:02:52 <ski_> @let select :: MonadPlus m => [a] -> m (a,[a]); select as = return ([],as) `mplus` case as of [] -> mzero; a:as -> liftM (fmap (a:)) (select as)
10:02:53 <lambdabot>  <local>:9:64:
10:02:54 <lambdabot>      Could not deduce (a ~ [a0])
10:02:54 <lambdabot>      from the context (MonadP...
10:02:59 * ski_ sighs
10:03:53 <canta> is there also some function to get all permutations of m things out auf a set like [1..n] ? (e.g. [3,2],[2,3],... out of [1..5])
10:04:19 <ski_> that sounds more like combinations
10:04:31 <ski_> (except that order seems to matter)
10:04:33 <byorgey> @let select :: MonadPlus m => [a] -> m (a,[a]); select [] = mzero; select (a:as) -> return (a,as) `mplus` liftM (fmap (a:)) (select as)
10:04:33 <lambdabot>   TemplateHaskell is not enabled
10:04:44 <byorgey> @let select :: MonadPlus m => [a] -> m (a,[a]); select [] = mzero; select (a:as) = return (a,as) `mplus` liftM (fmap (a:)) (select as)
10:04:46 <lambdabot>  <local>:10:1:
10:04:46 <lambdabot>      Duplicate type signature:
10:04:46 <lambdabot>        <local>:10:1-41: select ...
10:05:02 * ski_ fixed it
10:05:10 <byorgey> ah, k
10:05:13 <byorgey> > select [1..5]
10:05:16 <lambdabot>   No instance for (GHC.Show.Show (m0 (a0, [a0])))
10:05:16 <lambdabot>    arising from a use of `M...
10:05:27 <byorgey> > select [1..5] :: [(Int, [Int])]
10:05:29 <lambdabot>   [(1,[2,3,4,5]),(2,[1,3,4,5]),(3,[1,2,4,5]),(4,[1,2,3,5]),(5,[1,2,3,4])]
10:05:34 <ski_> > select "abcd" :: [(Char,String)]
10:05:36 <lambdabot>   [('a',"bcd"),('b',"acd"),('c',"abd"),('d',"abc")]
10:06:06 <simpson> > replicateM 2 [1...5] -- canta
10:06:08 <lambdabot>   Not in scope: `...'
10:06:08 <lambdabot>  Perhaps you meant one of these:
10:06:08 <lambdabot>    `.&.' (imported fro...
10:06:14 <simpson> > replicateM 2 [1..5] -- canta
10:06:17 <lambdabot>   [[1,1],[1,2],[1,3],[1,4],[1,5],[2,1],[2,2],[2,3],[2,4],[2,5],[3,1],[3,2],[3...
10:06:21 <simpson> Who *doesn't* like the list monad?
10:06:54 <canta> thanks
10:06:59 <simpson> canta: This relies on replicateM and the fact that lists are monadic. It's a bit abusive but probably the best way do to it.
10:07:12 <simpson> (I highly recommend sitting down and figuring out why this works!)
10:07:23 <canta> does abusive mean inefficient?
10:07:38 <simpson> No, it's more that it might not be obvious how the mechanism works.
10:07:48 <simpson> :t replicateM -- hardly looks like it should do this!
10:07:50 <lambdabot> Monad m => Int -> m a -> m [a]
10:08:06 <canta> ah, alright, I will check replicateM
10:08:11 <c-ab> > [2] <$> [1..5]
10:08:13 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `[t0]'
10:08:48 <ski_> @. hoogle type \f g a b -> f (g a b)
10:08:49 <c-ab> > [2++] <$> [1..5]
10:08:49 <lambdabot> Parse error:
10:08:50 <lambdabot>   (t1 -> t) -> (t2 -> t3 -> t1) -> t2 -> t3 -> t
10:08:50 <lambdabot>  
10:08:51 <lambdabot>   A section must be enclosed in parentheses thus: (2 ++)
10:09:01 <canta> @src replicateM
10:09:01 <lambdabot> replicateM n x = sequence (replicate n x)
10:09:08 <simpson> > [(2+)] <$> [1..5]
10:09:10 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `[t0]'
10:09:14 <c-ab> > ([2]++) <$> [1..5]
10:09:16 <lambdabot>   No instances for (GHC.Enum.Enum [t0], GHC.Num.Num [t0])
10:09:16 <lambdabot>    arising from a u...
10:09:35 <c-ab> > ([2]:) <$> [1..5]
10:09:35 <simpson> Oh, derp, list applicative is not ZipList.
10:09:37 <lambdabot>   No instances for (GHC.Enum.Enum [[t0]], GHC.Num.Num [[t0]])
10:09:37 <lambdabot>    arising from...
10:09:56 <c-ab> > (2:) <$> [1..5]
10:09:58 <lambdabot>   No instances for (GHC.Enum.Enum [a0], GHC.Num.Num [a0])
10:09:58 <lambdabot>    arising from a u...
10:11:07 * feliperosa doesn't get why replicateM 2 [1..5] does that rofl
10:11:46 <simpson> > replicate 2 [1..5] -- feliperosa
10:11:49 <lambdabot>   [[1,2,3,4,5],[1,2,3,4,5]]
10:12:13 <feliperosa> simpson: Ok.
10:12:32 <simpson> > do { x <- [1..5]; y <- [1..5]; return [x,y] } -- this is what sequence does afterwards
10:12:34 <lambdabot>   [[1,1],[1,2],[1,3],[1,4],[1,5],[2,1],[2,2],[2,3],[2,4],[2,5],[3,1],[3,2],[3...
10:12:42 <simpson> Behold the list monad.
10:12:45 <feliperosa> oh, right
10:13:18 <ski_> @let unfoldrM :: Monad m => (s -> m (Maybe (a,s))) -> (s -> m [a]); unfoldrM step s = maybe (return []) (\(a,s) -> liftM ((:) a) (unfoldrM step s)) =<< step s
10:13:20 <lambdabot>  Defined.
10:14:11 <c-ab> > zipWith (++) [1..5] [1..5]
10:14:13 <lambdabot>   Ambiguous type variable `c0' in the constraints:
10:14:13 <lambdabot>    (GHC.Enum.Enum c0)
10:14:13 <lambdabot>     ...
10:14:38 <c-ab> > zipWith (,) [1..5] [1..5]
10:14:39 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5)]
10:14:57 <ski_> > unfoldrM (\s -> if null s then return Nothing else liftM Just (select s)) "abc" :: [String]
10:14:59 <lambdabot>   ["abc","acb","bac","bca","cab","cba"]
10:15:12 <ski_> > unfoldrM (\s -> if null s then return Nothing else liftM Just (select s)) "abcd" :: [String]
10:15:14 <lambdabot>   ["abcd","abdc","acbd","acdb","adbc","adcb","bacd","badc","bcad","bcda","bda...
10:17:15 <ski_> @let insertArb :: MonadPlus m => a -> [a] -> m [a]; insertArb a0 as0 = return (a0:as0) `mplus` case as0 of [] -> mzero; a:as -> liftM (a :) (insertArb a0 as)
10:17:17 <lambdabot>  Defined.
10:17:34 <ski_> (i was confusing that with `select' above, when i tried to define it)
10:19:51 <ski_> > foldr ((=<<) . insertArb) (return []) "abc"
10:19:52 <lambdabot>   No instance for (GHC.Show.Show (m0 [GHC.Types.Char]))
10:19:52 <lambdabot>    arising from a use...
10:19:56 <ski_> > foldr ((=<<) . insertArb) (return []) "abc" :: [String]
10:19:58 <lambdabot>   ["abc","bac","bca","acb","cab","cba"]
10:20:02 <ski_> > foldr ((=<<) . insertArb) (return []) "abcd" :: [String]
10:20:04 <lambdabot>   ["abcd","bacd","bcad","bcda","acbd","cabd","cbad","cbda","acdb","cadb","cda...
10:20:24 <ski_> those are the two "canonical" orderings, i'd say
10:20:28 <ski_> > permutations "abc"
10:20:30 <lambdabot>   ["abc","bac","cba","bca","cab","acb"]
10:20:46 <ski_> i however distinct from both
10:20:52 <ski_> s/i /is /
10:22:49 <Mortchek> Why do certain functions, such as replicateM, take an Int for a number of repetitions, instead of any Integral or even specifically a natural number?
10:23:14 <ski_> @type genericReplicate
10:23:16 <lambdabot> Integral i => i -> a -> [a]
10:23:20 <ski_> @type genericReplicateM
10:23:21 <lambdabot>     Not in scope: `genericReplicateM'
10:23:21 <lambdabot>     Perhaps you meant `genericReplicate' (imported from Data.List)
10:23:43 <ski_> i suspect H98 simplified `Prelude'
10:23:50 <Mortchek> Oh, is this one of those things done for pedagogical reasons?
10:24:42 <Mortchek> Okay, then why not a natural type?
10:24:53 <Mortchek> natural number type*
10:26:32 <ski_> that would probably had made more sense, yes
10:26:47 <ski_> (`Word' didn't exists then, i think)
10:27:23 <Mortchek> So, mostly historical reasons?
10:27:58 <ski_> i suppose so
10:30:10 <c-ab> > take 10 ([1..] \\ [20..])
10:30:19 <lambdabot>   mueval: Prelude.undefined
10:30:35 <flebron_> Possibly a stupid question: While inside the IO monad, using do notation, can I also use do notation for the List monad? (Or any other monad)
10:30:38 <c-ab> > take 10 ([1..] \\ [4..9])
10:30:43 <lambdabot>   mueval-core: Time limit exceeded
10:30:47 <Mortchek> flebron_, yes.
10:30:55 <ski_> flebron_ : of course, as long as you keep types straight
10:31:26 <ExternalReality> I need to generate some unique strings of about 20 chars or so. Anyone know of any good guid style packages?
10:31:32 <flebron_> I tried a no-op using [Maybe Int], saying sequence_ $ (do return (Just 2))$
10:31:35 <ski_> > [1..] \\ [4..9]
10:31:37 <lambdabot>   [1,2,3,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32...
10:31:44 <ski_> > [1..] \\ [4..]
10:31:51 <lambdabot>   mueval: ExitFailure 1
10:31:52 <lambdabot>  mueval: Prelude.undefined
10:32:06 <ski_> > take 3 ([1..] \\ [4..])
10:32:10 <lambdabot>   mueval-core: Time limit exceeded
10:33:03 <ski_> > sequence_ $ do return (Just 2)
10:33:05 <lambdabot>   Just ()
10:33:11 <ski_> > sequence $ do return (Just 2)
10:33:13 <lambdabot>   Just [2]
10:33:23 <monochrom> example of IO-do and []-do together: do { cs <- getLine; print (do { c<-cs; return (ord c) }) }
10:33:46 <flebron_> Oh, I guess I need to assign it to something if it's a Maybe ().
10:33:55 <flebron_> If it were an IO () I could just use sequence_ by itself.
10:34:18 <flebron_> (I want to walk a list, and do some action for every element of that list. Hence, using the list monad, and inside that, the IO monad.)
10:34:34 <flebron_> (This list of IO actions will be returned to the main :: IO monad, to run with sequence_)
10:35:25 <ski_> > do l <- words "I moan, live on, oh evil Naomi"; do {c <- l; [toLower c]} `mplus` "\n"
10:35:26 <monochrom> second example: do { c<-"abcd"; return (do { cs<-getLine; putStrLn (if [c]==cs then "correct" else "wrong") }) }
10:35:27 <lambdabot>   "i\nmoan,\nlive\non,\noh\nevil\nnaomi\n"
10:36:27 <ski_> flebron_ : not `mapM' ?
10:36:42 <flebron_> I could also do that, yeah.
10:38:10 <ski_> @type forM_
10:38:13 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
10:47:27 <c-ab> > takeWhile (< 100) $ take 10 $ [1..] \\ [4..9]
10:47:29 <lambdabot>   [1,2,3,10,11,12,13,14,15,16]
10:48:27 * sm updates http://hub.darcs.net/simon/cabal-install-tutorial , review welcome
10:50:31 <ion> nand: Yeah, that might be nice.
10:53:48 <epta> sm: what about cabal-dev?
10:53:54 <ski_> elliott : hmm, i'm thinking `showsPrec1By :: (Int -> a -> ShowS) -> (Int -> f a -> ShowS)' could be a useful addition to `Show1'
10:54:26 <sm> epta: it's mentioned..
11:01:45 <c-ab> question: when you do nevil\nnaomi\n"
11:01:45 <c-ab> 19:36 < ski_> flebron_ : not `mapM' ?
11:01:52 <c-ab> oops
11:02:28 <flebron_> (I ended up using sequence_ and not mapM_ because the list had two parameters (i.e. i <- ..., j <- ...), and didn´t want to use tuples to pass args to and fro.)
11:02:31 <c-ab> question when you do rsp <- browse $ request $ getRequest "http://www.google.com"; print $ rspBody $ snd rsp ; .. the request body is actually fetched only in second step?
11:03:27 <c-ab> or does it just read the record argument of the Request type, fteched in first step
11:03:30 <s_kilk> hi all, I've got a weird issue when trying to launch a yesod application. when I run `yesod --dev devel` , i get back: "<command line>: cannot satisfy -package-id LocalTest-0.0.0-inplace". Any ideas how to fix this?
11:04:35 <geekosaur> sounds like you're working from a copy of yesod that has notbeen installed yet, from a different directory than the one with the cabal file
11:06:19 <s_kilk> hmm, I had cloned the yesod repo locally and was trying to use it in the "sources.txt" file for a test project. but this error is now happening on all yesod projects on the machine.
11:06:47 <s_kilk> i presumed i was safe because I was using cabal-dev for each application
11:09:07 <s_kilk> so anyway, aside from my sillyness, is it not safe to assume that different yesod applications using cabal-dev are sandboxed from each other? just trying to get it straight in my mind for future
11:09:32 <luite> s_kilk: normally the package id should be in dist/package.conf.inplace
11:10:01 <luite> s_kilk: does that file exist? can you check with yesod -v --dev devel that it indeed adds that package config file?
11:10:22 <s_kilk> oh wait, i think i just realised something, even if im using `cabal-dev install` on the app, im still using the "global" `yesod` command to launch the application
11:10:32 <luite> that's not really a problem
11:10:38 <luite> it's just an executable
11:11:51 <luite> make sure you're running teh latest one though, yesod version should say 1.1.9.1
11:12:12 <luite> (there were some yesod devel fixes last week)
11:12:34 <s_kilk> ok, that file contains installedPackageId = InstalledPackageId "LocalTest-0.0.0-inplace" , and then a lot
11:12:58 <s_kilk> i think it was 1.1.9.1 that i cloned from github
11:13:10 <luite> s_kilk: what's the command line that yesod -v --dev devel gives you for the runghc command?
11:13:46 <s_kilk> Starting development server: runghc -package-conf/home/shane/working/haskell/LocalTest/cabal-dev/packages-7.4.2.conf -hide-all-packages -package-idyesod-static-1.1.2.2-3746eb5b1da826ddacbd53d4bd980564 -package-idyesod-form-1.2.1.3-d588a8ed296871e5ef51b80991d8e2b1 -package-idyesod-default-1.1.3.2-a3321dd6b7dadf0b38c2e0af71f3c894 -package-idyesod-core-1.1.8.2-df360fca2b734fc1ba144c5aedf07431 -package-idyesod-auth-1.1.5.3-01e
11:13:46 <s_kilk> 768badc2c1e8761f12607ac73c016 -package-idyesod-1.1.9.1-e9f889e9b7e7ecde10ac97fa17ada5ab -package-idyaml-0.8.2.1-2ea6baa3141bddddd0b134560c676203 -package-idwarp-1.3.7.4-df0886f2e5e194b1b072c379d171d4f7 -package-idwai-extra-1.3.2.4-91248ec18d763b06cb0a768fe656d68d -package-idtext-0.11.2.0-6e262ab4f62aa2bea82c6932cbc266c4 -package-idtemplate-haskell-2.7.0.0-2bd128e15c2d50997ec26a1eaf8b23bf -package-idshakespeare-text-1.0.0.5
11:13:47 <s_kilk> -33380ca8da9ef29ab1a877b1b0b95214 -package-idshakespeare-js-1.1.2-fdb6710e1965058d188ecdd5edeb190f -package-idshakespeare-css-1.0.3-d547e67b1e5d87f231fb05af447b71fa -package-idpersistent-template-1.1.2.4-eee172a02207b11edc67334c09bbe924 -package-idpersistent-sqlite-1.1.4.1-b38dc47208f09b91fafc8a1185388e91 -package-idpersistent-1.1.5.1-d05a4b4494ae6dc5420dcaa820d01359 -package-idmonad-logger-0.3.0.1-12b6e4be3a6c5d0a44ef19be
11:13:54 <s_kilk> 74a07104 -package-idmonad-control-0.3.1.4-83560fedcd54bda582bc1867a61c5f8a -package-idhttp-conduit-1.9.0-845e88883a7cd5ecd09dd613bd272744 -package-idhjsmin-0.1.4.1-6e85d76530c1ffbe1e26445a9741b6da -package-idhamlet-1.1.6.3-53fd1adf45c075630acbd146a31642f4 -package-idfast-logger-0.3.1-11077391a6d8e40c8d1c915dbb20ad45 -package-iddirectory-1.1.0.2-c30059d750d04b32316f9eeced589f8a -package-iddata-default-0.5.0-3f2342d47b82639c
11:13:59 <s_kilk> 0ef7a179feefe779 -package-idconduit-1.0.1-aaf6fe7a6ca586ba2e8f44ddf6cb1999 -package-idclientsession-0.8.1-57a7764b4f84216c13d96cfcacbc17c9 -package-idbytestring-0.9.2.1-503e91bb155301fdb1956cb5c26ce6e9 -package-idbase-4.5.1.0-6e4c9bdc36eeb9121f27ccbbcb62e3f3 -package-idaeson-0.6.1.0-b55f7df8ca2964449b854598770e183d -package-idLocalTest-0.0.0-
11:14:03 <s_kilk> oh no, sorry, didn't realise it was so long
11:14:06 <bitonic> s_kilk: what the hell?
11:14:12 <c-ab> @where paste
11:14:12 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
11:14:13 <luite> uh..
11:14:15 <bitonic> s_kilk: :P paste next time
11:14:22 <s_kilk> hahah, sorry!
11:15:06 <s_kilk> http://hpaste.org/83349
11:15:13 <luite> ok looks like the inplace package conf is indeed missing
11:16:00 <s_kilk> ok, how would I fix that? :)
11:17:34 <luite> s_kilk: lemme check what's going on
11:17:49 <jfischoff> luite: which do you recommend integrated or standalone for ghcjs?
11:18:07 <benmachine> suppose I have a Haskell file (or perhaps a cabalised project) and I want a list of all identifiers it imports, which modules and packages they are from
11:18:16 <benmachine> does anyone know if there's an automated way to recover that stuff?
11:19:21 <shane_kilkelly> woops, disconnected for a moment there
11:19:38 <luite> s_kilk: hm looks like that package conf is missing in the dynflags with older ghc
11:19:44 <ExternalReality> :benmachine ghc has an api to help with that stuff.
11:20:00 <luite> jfischoff: uh i think probably none yet
11:20:09 <jfischoff> luite: go on
11:20:10 <benmachine> ExternalReality: I know that, but I want to know if someone has already done the hard work :P
11:20:31 <shane_kilkelly> would completely un-installing ghc/haskellplatform and installing fresh clear it up?
11:20:36 <benmachine> ExternalReality: I think I could write a thing to do it, but it seems like such an obvious thing to do I wouldn't be surprised if someone already has
11:21:38 <jfischoff> luite: so would you recommend fay instead?
11:21:40 <luite> jfischoff: sorry about that. standalone only really works with the new code generator, but some memory management stuff is missing. i had hoped to have it ready by now but unfortunately got sick 10 days ago or so, working on it again now.
11:22:32 <jfischoff> luite: okay so what is in github right now is busted?
11:22:38 <luite> jfischoff: integrated has some bugs that have been fixed in the new codegen, but have not been backported (and might not be ever if the standalone can be fixed in the short term)
11:23:14 <ExternalReality> :benmachine -- Looks like you know as much as I do on the matter. If you can't find anything perhaps you could find some of the functionality you need in the Scion code base.
11:23:44 <luite> jfischoff: yeah, you can try, but it's not quite ready for release i have to admit. we're aiming for a hackage release when ghc 7.8.1 is released (standalone obviously)
11:24:24 <jfischoff> luite: okay cool thanks
11:24:47 <luite> jfischoff: then we'll also be able to support 64 bit host platforms
11:25:07 <luite> currently, 7.6.x and lower, 64 bit hosts will give you really inefficient js code, if it works at all
11:25:21 <benmachine> ExternalReality: thanks for the tip, I'll look into it later
11:25:21 <luite> becasue of missing cross compile support in the ghc api
11:25:31 <jfischoff> luite: ah. I will work on the code I want to run as js then.
11:25:42 <luite> with 7.8.1 we can generate proper 32 bit code
11:26:01 <lispy> hello
11:26:04 <luite> (and also 64 bit native code for running TH)
11:26:30 <lispy> luite: keep up the good work :)
11:26:45 <jfischoff> luite: yeah I really can't wait
11:27:42 <luite> I'm also excited about getting closer to release, being sick and not being able to work on this was really frustrating :)
11:28:15 <luite> I was thinking of writing up some experience and design report for ICFP but I'm afraid I'm going to miss the deadline now
11:28:46 <jfischoff> luite: ah yeah that would be very interesting. Are you still going?
11:29:19 <luite> not sure if i'm going at al, would probably have to come out of my own pocket
11:29:32 <jfischoff> yeah long trip
11:29:41 <luite> yeah not the cheapest time to fly to boston
11:31:01 <luite> I still need to submit some ghc patches, but i lost them somehow
11:31:10 <jfischoff> :o
11:32:12 <jfischoff> luite: random question, on the ghcjs setup readme is has the sync-all fails from github a lot, what are the symptoms when this happens?
11:32:43 <luite> dunno, that's something that happens to hamishmack, it seems to work fine here :)
11:33:22 <luite> I work in the GHC HEAD tree a lot, so i use that quite often, never had problems
11:33:53 <jfischoff> hmm, I'm been getting git errors when trying to build the ghc-ios branch
11:34:05 <jfischoff> thought you might have some insight
11:34:50 <lispy> Does \xs ys -> concat (zipWith (\x y -> x:y:[]) xs ys) already exist in the standard libs?
11:34:58 <lispy> it's just interleaving the two lists
11:35:15 <lispy> ?pl \xs ys -> concat (zipWith (\x y -> x:y:[]) xs ys)
11:35:15 <lambdabot> (join .) . zipWith ((. return) . (:))
11:36:00 <lispy> @pl \x y -> x : y : []
11:36:00 <lambdabot> (. return) . (:)
11:36:38 <ski_> @let infixr 5 ++; (/\/) :: [a] -> [a] -> [a]; [    ] /\/ ys =            ys; (x:xs) /\/ ys = x : xs /\/ ys  -- slightly more useful(?)
11:36:39 <lambdabot>  .L.hs:126:10:
11:36:39 <lambdabot>      Multiple fixity declarations for `++'
11:36:39 <lambdabot>      also at  <loca...
11:36:46 <ski_> @let infixr 5 /\/; (/\/) :: [a] -> [a] -> [a]; [    ] /\/ ys =            ys; (x:xs) /\/ ys = x : xs /\/ ys  -- slightly more useful(?)
11:36:48 <lambdabot>  Defined.
11:37:02 <ski_> > (/\/) "ab" "012"
11:37:06 <lambdabot>   mueval-core: Time limit exceeded
11:37:15 <ski_> err
11:37:17 <ski_> @define
11:37:24 <ski_> @let infixr 5 /\/; (/\/) :: [a] -> [a] -> [a]; [    ] /\/ ys =            ys; (x:xs) /\/ ys = x : ys /\/ xs
11:37:26 <lambdabot>  Defined.
11:37:27 <ski_> > (/\/) "ab" "012"
11:37:29 <lispy> I think you're missing the xs /\/ [] = xs case
11:37:30 <lambdabot>   "a0b12"
11:37:36 <lispy> or not
11:37:38 <ski_> > (\xs ys -> concat (zipWith (\x y -> x:y:[]) xs ys)) "ab" "012"
11:37:39 <lambdabot>   "a0b1"
11:37:54 <lispy> ah, in my case I know that length xs == length ys
11:38:44 <ski_> (i think the Craft calls it `(/\/)')
11:41:25 <int-e> let xs /\/ ys = concat (transpose [xs,ys]) in "ab" /\/ "012"
11:41:57 <ski_> hm, yes
11:42:24 <int-e> @pl (\x y -> x:y:[])
11:42:25 <lambdabot> (. return) . (:)
11:42:46 <lispy> [x,y] would have been the simpler way to write that
11:42:52 * lispy makes that edit
11:44:06 <ski_> @type ($ []) .: (.: (:)) . (:)
11:44:07 <lambdabot> a -> a -> [a]
11:44:40 <lispy> In terms of readability, I like how this looks now: compileLet' defs env' `interleave` updates
11:44:55 <lispy> (I'm less fond of /\/)
11:45:54 <ski_> hm, why interleaving there ?
11:49:00 <lispy> ski_: I'm not sure how to answer that
11:49:24 <lispy> ski_: do you want to know about the semantics of what I'm compiling or because you think there are more idiomatic ways to write the line?
11:49:59 <ski_> more the former, i suppose
11:50:16 <lispy> ski_: ah, okay I'm implementing the compilation scheme on page 114: http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/
11:50:16 <ski_> i was curious why you'd want to interleave in such a situation
11:50:33 <lispy> this is for a recursive let.
11:50:48 <lispy> You evaluate the parameters and the update is how sharing is implemented
11:51:06 <lispy> in the non-recursive case the update is not there
11:52:15 <lispy> ah, but the way I've written it is buggy
11:54:34 <ski_> hm, so in Scheme terms, this is `letrec*' rather than `letrec' ?
11:54:52 <lispy> I believe so, but my scheme is rusty
11:55:01 <lispy> the * variant means all names are mutually in scope?
11:55:17 <ski_> no, the `rec' means that
11:56:04 <ski_> in `letrec', first all the definiens' are evaluated, *then* the definiendums are bound to the respective values (and then the body is evaluated in the expanded environment)
11:57:09 <ski_> so, `(letrec ((x 0) (f (lambda (a b) (- (* a b) (* b a))) (y (+ x 1))) (f x y))' wouldn't work
11:57:33 <ski_> since when `(+ x 1)' is evaluated, `x' hasn't got the value `0' yet
11:58:29 <ski_> (and `letrec' evaluates the definiens'(?) in an arbitrary order)
11:59:02 <ski_> while in `letrec*', you can immediately refer to the values from the previous bindings (and they are evaluated in order)
11:59:20 <lispy> ah
12:01:44 <b4dw017_> hello all solving euler's this weekend in haskell
12:02:10 <b4dw017_> Im currently working problem 4 and have ran into issues
12:02:11 * hackagebot shakespeare-js 1.1.2.1 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-1.1.2.1 (MichaelSnoyman)
12:02:19 <b4dw017_> http://pastebin.com/Y6KDS3N6
12:02:25 <mauke> I have copied your paste Y6KDS3N6 to http://hpaste.org/83350 - pray I don't copy it any further.
12:02:40 <fdgs> hey, is there an elegant way to turn a list with two elements into a tuple?
12:02:42 <lispy> ski_: Now that I fixed the bug I don't need the interleave at all :) (and I can compile Y f = letrec x = f x in x)
12:03:08 <ski_> what was the bug ?
12:03:43 <lispy> ski_: the compileLet' handled all the bindings at once and returned [Instruction]. I was thinking it returned [[Instruction]]
12:03:58 <b4dw017_> im not sure i new to haskell and not sure what to make of the error message it gives
12:04:21 <lispy> ski_: so I just made it insert the Update instruction directly. I plan to refactor let/letrec separately once I've tested them a bit
12:05:39 <b4dw017_> im simply checking whether or not any of the multiple of list x and y are a palindrome
12:06:04 <typoclass> b4dw017_: hello. the line you pasted works for me with no errors. do you have any weird stuff imported? (you may want to restart ghci to get a known state)
12:06:15 <monochrom> it seems to me the problem is with isPalindrome which you do not provide
12:06:37 <Kennichiwa> lol hi im new to mirc is there people here? ::D:D
12:06:51 <parcs> ew mirc
12:06:59 <typoclass> b4dw017_: (just to clarify, 'works with no errors' after i defined a dummy isPalindrome function)
12:07:15 <Kennichiwa> Hey could somebody help me how to connect to a server?
12:07:23 <Kennichiwa> I have a name but don't know where to type it
12:07:52 <geekosaur> wat
12:08:01 <parcs> Kennichiwa: try /connect my.server.name
12:08:02 <typoclass> Kennichiwa: hello, this channel is about the programming language haskell. try googling your question, i'm sure it's explained somewhere how to do that in mirc
12:08:19 <hpaste> “Anonymous Coward” pasted “isPalindrome” at http://hpaste.org/83351
12:08:24 <Kennichiwa> k thx
12:08:52 <b4dw017_> posted isPalindrome
12:08:54 <monochrom> your isPalindrome is good for strings but not numbers
12:09:01 <ski_> Kennichiwa : also, you're probably new to IRC. mIRC is just one client people use to connect to IRC networks with
12:09:16 <typoclass> ski_: he's gone now
12:09:23 <ski_> hm, point
12:09:29 <b4dw017_> ok I how should i fix it?
12:09:41 <monochrom> that depends on how lazy you are
12:10:16 <Taneb> A variation on isPalindrome would be to "map toLower . filter isLetter" first
12:10:19 <lispy> monochrom: let's say that I'm VERY lazy
12:10:21 <monochrom> for maximum laziness, if you have a number like 4, the code (show 4) gives you the string "4". now you can do the palindrome test
12:10:31 <typoclass> b4dw017_: okay, that makes sense now. so yes, you used the "reverse" function, and that works only on strings (lists). hence your isPalindrome function only works on strings/lists. you can check this by doing ":t isPalindrome" to see the type that ghc inferred
12:10:35 <monochrom> show x == reverse (show x)
12:10:39 <b4dw017_> Im not lazy but this is my second day working with haskell so my understanding is limited
12:11:23 <monochrom> ok, for minimum laziness, write a palindrome test for numbers not strings. I am too lazy to say how. in fact I am too lazy to even think how
12:11:26 <typoclass> monochrom: that will work, won't it :-) don't see what's lazy about it
12:11:41 <monochrom> human lazy, not computer lazy
12:11:54 <monochrom> <monochrom> that depends on how lazy you are
12:11:57 <monochrom> did you see that?
12:11:57 * tgeeky thinks byorgey's 'split' library will help
12:12:43 <typoclass> b4dw017_: as monochrom suggested, the 'show' function converts a number into a string, which you can then reverse and compare with (==)
12:12:54 <b4dw017_> so can i create a list out of the input and reverse the list?
12:13:13 <b4dw017_> i see ill give that a try now
12:13:42 <typoclass> monochrom: yes, but lazy sounds negative. i don't see what the problem is with "show", instead of some much more error-prone thing with dividing repeatedly or whatnot
12:14:43 <monochrom> I don't know, this is why I say that it depends on you
12:15:03 <b4dw017_> is show recursive? if so what the base case?
12:15:21 <b4dw017_> im sorry i meant the show method
12:15:32 <monochrom> it is probably recursive, and the base case is probably 0
12:15:59 <ski_> b4dw017_ : typically it's defined as `show a = shows a ""'
12:16:25 <ski_> (and `shows' is typically defined as `shows = showsPrec 0')
12:16:51 <monochrom> are you going to patiently explain the full story of showsPrec?
12:17:12 * hackagebot th-extras 0.0.0.2 - A grab bag of functions for use with Template Haskell  http://hackage.haskell.org/package/th-extras-0.0.0.2 (JamesCook)
12:17:27 <[swift]> so i'm playing around with quick check, and i find myself at a loss for how to effectively test higher order functions. here's an example: "(.&&.) f g v = f v && g v" (for combining two boolean predicates) how can i quick check that?
12:17:31 <ski_> well, i was going to say that `showsPrec' is commonly recursively defined, for `Show' instances of recursive data types
12:18:12 <monochrom> then you don't need the name-dropping to answer the question, and the question's context is Int or Integer
12:19:05 <beaky> what is the difference beytween a type & a value?
12:20:13 <ski_> b4dw017_ : assuming `data Tree a = Leaf a | Branch (Node a) (Node a) deriving Show', the definition is `showsPrec p (Leaf a)     = showParen (p > 10) $ showString "Leaf " . showsPrec 11 a; showsPrec p (Branch l r) = showParen (p > 10) $ showString "Branch " . showsPrec 11 l . showChar ' ' . showsPrec 11 r', which is recursive
12:20:14 <monochrom> a value is what I want a program to input and output, because I use a program to get things done
12:20:50 <monochrom> a type is what some other people want a program to input and output, because they use a program to marvel at and praise Curry-Howard
12:21:04 <ski_> [swift] : what property would you like to check ?
12:21:16 <int-e> . o O ( what's the difference between a flamingo and a zoo? )
12:21:34 <b4dw017_> i have just posted my attempt at the show method  in hpaste
12:22:08 <hpaste> b4dw017 pasted “error using show” at http://hpaste.org/83353
12:22:12 * hackagebot dependent-sum-template 0.0.0.1 - Template Haskell code to generate instances of classes in dependent-sum package  http://hackage.haskell.org/package/dependent-sum-template-0.0.0.1 (JamesCook)
12:22:19 <ski_> b4dw017_ : you forgot to fill in `#haskell' as the channel
12:22:34 <ski_> ok
12:22:48 <b4dw017_> sorry just noticed
12:22:55 <[swift]> ski: well this is just a simple example, so the definition of the function pretty much defines the property. it should be true that "(f .&&. g) v == f v && g v".
12:23:10 <monochrom> you forgot to add "isPalindrome = "
12:23:15 <typoclass> b4dw017_: yes, the syntax is "let name arg1 arg2 ... = expression ..."
12:23:51 <ski_> [swift] : in general, the QC property would often take a function as argument (which will be randomly generated by QC)
12:24:36 <b4dw017_> sorry i dont understand am i supposed to defind show within isPalindrome
12:24:49 <monochrom> you are using, not defining, show
12:25:03 <monochrom> just like you are using, not defining, reverse
12:25:13 <b4dw017_> ok that what i wasn't understanding
12:25:14 <typoclass> b4dw017_: show is already defined in Prelude
12:25:34 <[swift]> ski_: ah dang, i see that in documentation now. terrible googling on my part. that's awesome that it can do that though! thanks!
12:26:17 <ski_> [swift] : you will need to make instances of `CoArbitrary' for the argument types of those argument functions, if there aren't already such instances, for QC to be able to randomly generate such functions
12:26:20 <b4dw017_> thank it works all
12:26:40 <monochrom> good good
12:26:52 <[swift]> ski_: i was actually gonna just leave the argument type as a type variable. maybe that's a little too general? =)
12:27:12 <ski_> [swift] : iow, if you want to be able to randomly generate (`Arbitrary') functions of type `Foo -> Bar', then you need `Arbitrary Bar' and `CoArbitrary Foo'
12:28:00 <[swift]> gotcha. that makes sense
12:28:23 <ski_> [swift] : i'm not saying you necessarily need to fix or constraint the argument type of the argument function in the QC property -- but for each instance you want to check it, the corresponding type must be in that class
12:28:32 <int-e> beaky: sorry, but it is an odd question. you may think of a type as a set of values; the type Integer consists of values 0,1,-1,2,-2,3,-3, etc. (and, in Haskell, bottom, for undefined values); each of these values has type Integer. Types restrict the semantics of function, the values that they can compute; a function of type Integer will evaluate to some integer if defined; it will never evaluate to, say, a list.
12:34:35 <edwardk> kartoffelbrei: we have 'flip ($)' in lens, but not 'flip (.)' (and our flipped ($) has very low fixity, not high.
12:35:46 <monochrom> I guess we can use Category's >>> for flip(.)
12:37:33 <kartoffelbrei> edwardk: thanks, monochrom: well, what i wanted is >>> but with a higher fixity (it's fixity is one)
12:37:58 <b4dw017_> how would you save your script in the ghci
12:38:36 <monochrom> I once invented an idea. it goes like this for >>>. use >>>> for fixity 2, >>>>> for fixity 3, etc
12:38:47 <edwardk> monochrom: hah
12:39:44 <monochrom> I invented it when I read a haskell-cafe question: want to use several operators, but omit parentheses
12:40:16 <byorgey> monochrom: but how to distinguish between that and arbitrary-precedence greater-than?
12:40:29 <monochrom> I wanted to mock it with "define $, $$, $$$, $$$$ etc to be all function applications. $$$ has precedence 3, etc"
12:40:43 <byorgey> hehe
12:41:00 <kartoffelbrei> this would be very funny for code golfing
12:47:05 <Walther> Just curious, are there any pub/priv key auth implementations in haskell?
12:47:33 <Walther> say, ssh-rsa
12:47:49 <harrison> it must be that by using higher level languages because C is ugly coders simply do not have the design space available to them to create the intricate faberge eggs of code that flow ceaselessly from my fevered brain
12:48:29 <shachaf> Walther: Why do you want them to be in Haskell?
12:48:30 <lambdabot> shachaf: You have 1 new message. '/msg lambdabot @messages' to read it.
12:49:26 <beaky> how do i make a global variable? atm I am using a top-level IO IORef
12:50:27 <skuggi> can unboxed tuples not be let-bound?
12:50:47 <Walther> shachaf: merely considering building a thing in haskell that would involve user auth, and considering the possibility of using encrypted content even within program code instead of only in os level / user connection
12:50:47 <ski_> right
12:51:03 <ski_> > let (# _ , _ #) = (# (), () #) in ()
12:51:05 <lambdabot>   ()
12:51:26 <ski_> hm, or at least i thought that was the case
12:51:39 <Taneb> :t (# , #)
12:51:40 <lambdabot> a -> b -> (# a, b #)
12:51:41 <shachaf> Walther: Oh, you want a library usable from Haskell, not something written in Haskell.
12:51:45 <kartoffelbrei> beaky: http://www.haskell.org/haskellwiki/Top_level_mutable_state
12:51:49 <shachaf> Yes, various things exist.
12:51:49 <ski_> > let _ = (# (), () #) in ()
12:51:51 <lambdabot>   mueval-core: GhcException "panic! (the 'impossible' happened)\n  (GHC versi...
12:52:10 <ski_> > let up = (# (), () #) in ()
12:52:12 <lambdabot>   The variable `up' cannot have an unboxed tuple type: (# (), () #)
12:52:55 <ski_> > case (# (), () #) of _ -> ()
12:52:56 <Walther> schovi: okay, fair enough
12:52:57 <lambdabot>   A wild-card pattern cannot have an unboxed tuple type: (# (), () #)
12:52:58 <ski_> > case (# (), () #) of up -> ()
12:53:00 <lambdabot>   The variable `up' cannot have an unboxed tuple type: (# (), () #)
12:53:05 <Walther> er, shachaf
12:53:47 <ski_> skuggi : anyway, a variable can't be bound to an unboxed tuple, you have to unpack it
12:54:05 <skuggi> ah
12:54:07 <skuggi> damn
12:55:16 <ski_> but apparently you can unpack in a `let' (and presumably `where') as well
12:57:12 * hackagebot snap-app 0.1.4 - Simple modules for writing apps with Snap, abstracted from hpaste.  http://hackage.haskell.org/package/snap-app-0.1.4 (ChrisDone)
13:00:19 <hiptobecubic> It's really hard to know if what I see in threadscope is "good"
13:01:55 <applicative_> Walther: is there nothing in the wild productivity of https://github.com/vincenthz
13:03:34 * shachaf sighs at all the reimplementation of cryptography.
13:05:47 <JoeyA> Is it possible to tell cabal install to use a custom package database (instead of ~/.ghc/x86_64-linux-7.6.2 ), or do I need cabal-dev for that?
13:05:53 <applicative_> programmers love crypto
13:06:04 <mandarg> s
13:06:31 <typoclass> shachaf: i guess programmers love programming more than integrating existing stuff. plus the usual overoptimism, "how hard can it be", etc.
13:07:05 <JoeyA> Sometimes, you have to implement it yourself to appreciate the problems the original author was trying to solve.
13:07:23 <shachaf> Yes, but you'll get cryptography code wrong.
13:07:29 <shachaf> And then you won't know until it's too late.
13:07:30 <kartoffelbrei> JoeyA: well, i guess you could mess around with the relevant enviorment variables yourself
13:07:38 <applicative_>     --package-db=DB    Use a given package database (to satisfy    dependencies and register in). May be a    specific file, 'global', 'user' or 'clear'
13:07:53 <typoclass> JoeyA: true. (although it could help if more people documented this stuff better, particularly the big-picture design things.)
13:07:56 <shachaf> (This has happened before with these Haskell cryptography packages.)
13:09:15 <JoeyA> shachaf: are you referring to, say, the TLS package, instead of just linking with OpenSSL?
13:09:45 <shane_kilkelly> hi luite, i disconnected there for a while. any ideas on a solution for the package conf problem
13:11:59 <luite> shane_kilkelly: i think it's a bug in yesod devel, i'll need to test with 7.4.x and commit a fix
13:12:34 <shane_kilkelly> ah right, thanks very much. in the mean-time, would it be worth me removing haskell-platform and re-installing?
13:12:42 <luite> uh probably not
13:13:16 <shane_kilkelly> ok. if im understanding this correctly, it's a bug in the latest build of yesod that is causing the problem?
13:14:21 <luite> yeah a few weeks ago a change was made so it uses the command line cabal-install instead of the cabal library to build stuff
13:14:37 <luite> which changed how the package databases are configured
13:14:55 <luite> for some reason it's missing the inplace package db for you, and it's probably ghc version dependent
13:15:03 <shane_kilkelly> right, and then I experienced this problem because I pulled down the latest version from master. had this bug been spotted before?
13:15:16 <luite> this is the first time i've heard
13:15:38 <luite> i think it might only show up with 7.4.x if you use cabal-dev
13:15:51 <shane_kilkelly> is ghc 7.4.2 current? would upgrading make a difference?
13:16:00 <luite> 7.6.x will probably work fine
13:16:16 <c-ab> what is the simplest/shortest http server in haskell?
13:16:40 <shane_kilkelly> cool, I'm not against the idea of upgrading. only trick is that I had installed through the ubuntu haskell-platform package.
13:16:56 <luite> i'll check in a few hours, fix will probably be on github tomorrow
13:17:06 <JoeyA> c-ab: http://codegolf.stackexchange.com/a/3995/38
13:18:16 <shane_kilkelly> thanks luite. i appreciate the help. question: once a fix gets to github, does it also get pushed to hackage at the same time? or do the hackage packages lab behind the development repo?
13:18:37 <JoeyA> shane_kilkelly: the maintainer pushes to Hackage
13:19:02 <luite> shane_kilkelly: usually snoyman uploads a new version to hackage pretty quickly after that, but i can also do it
13:19:08 <c-ab> JoeyA: wow, let's upvote that
13:19:09 <JoeyA> The gears of Hackage are oiled by the sweat of the maintainers.
13:20:48 <c-ab> they hangle just GET request I guess
13:20:54 <shane_kilkelly> cool, i was just curious about the time-scale. at the moment it seems like my yesod development installation is out-of-action for the next while. actually, while we're on the subject, say I've been using the ubuntu haskell-platform package, which has ghc 7.4, what would be the best way of upgrading/replacing that with a more recent version?
13:20:58 <c-ab> handle*
13:21:29 <sm> shane_kilkelly: can't you fix it by reverting to the version you had before ?
13:21:30 <typoclass> luite: do you happen to know what the replacement for package web-encodings is? it's marked as deprecated
13:21:48 <luite> typoclass: nm no sorry
13:21:53 <c-ab> hs http-server is pretty much clearer than ruby's
13:22:09 <typoclass> luite: ok
13:23:49 <c-ab> > unlines "rr\ntrgt\nt"
13:23:51 <lambdabot>   Couldn't match expected type `GHC.Base.String'
13:23:51 <lambdabot>              with actual typ...
13:23:53 <shane_kilkelly> @sm, no idea why i didn't think of that. how would i go about nuking the current version and reverting?
13:23:54 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
13:23:59 <c-ab> :t unlines
13:24:01 <lambdabot> [String] -> String
13:24:48 <typoclass> c-ab: you may be looking for 'lines'
13:26:21 <c-ab> > concat [unlines $ ("HTTP/1.0 " ++ "foo") : [], "\n", "bar"]
13:26:23 <lambdabot>   "HTTP/1.0 foo\n\nbar"
13:26:31 <sm> shane_kilkelly: if you previously had yesod-1.1.9.1 from hackage, eg, I'd try cabal install yesod-1.1.9.1
13:27:17 <shane_kilkelly> i think i have 1.1.9.1 as the currently installed version
13:27:54 <shane_kilkelly> will try a reinstall anyway
13:31:33 <carter> thoughtpolice I started looking at the lz4 bug  a teeny itsy bit
13:32:31 <sm> the hackage version just before the date of luite's github change seems a good bet, but I don't know when that was. 1.1.9 or 1.1.8 perhaps ?
13:37:00 <luite> yeah that one has other problems though..
13:37:41 <c-ab> the man who wrote a http server in vb.net is masochist
13:38:15 <shane_kilkelly> you'd be surprised what people will do in vb.net and not bat an eyelid
13:38:18 <c-ab> http://codegolf.stackexchange.com/a/4017/7459
13:38:29 <monochrom> haha nice
13:39:07 <monochrom> but here, we look forward to a http server at the type level
13:39:48 * geekosaur is holding out for an http server at the kind level
13:40:15 <shane_kilkelly> instance HttpServer MyApp where
13:40:25 <c-ab> data HttpServer ...
13:40:55 <c-ab> monadic httpserver
13:41:04 <shane_kilkelly> applicative httpserver
13:43:00 <shane_kilkelly> huh, so i just re-installed yesod-1.1.9.1 from hackage and am getting the same "cannot satisfy -package-id" issues as before.
13:43:31 <ski_> hmm .. or doing `showsPrec1By' means i have to manually build instances :/
13:43:40 <luite> shane_kilkelly: uh yeah that's kind of expected :)
13:44:04 <shane_kilkelly> wait, im a dope. which version should i downgrade to then?
13:44:27 <luite> if you can wait an hour or so i can probably fix it
13:44:33 <luite> i'm installing the dependencies now
13:45:19 <shane_kilkelly> your a good person luite. I can wait until tomorrow easily. I'll just space out and listen to some Thin Lizzy for a while.
13:45:30 <sm> I'm a rocker!
13:45:45 <sm> I'm a roller too, baby!
13:46:09 * sm hurries off to find some Thin Lizzy
13:47:17 <shane_kilkelly> @sm , Jailbreak. go on.
13:47:17 * lambdabot submits , Jailbreak. go on.'s email address to a dozen spam lists
13:47:20 <luite> shane_kilkelly: if you want to help, can you upload yesod-devel/ghc-args.txt to hpaste?
13:47:44 <shane_kilkelly> will do
13:47:52 <shane_kilkelly> from an affected app yeah?
13:47:57 <luite> yeah
13:48:25 <thoughtpolice> carter: awesome, thanks! i saw some of the activity on the ticket.
13:49:10 <carter> thoughtpolice since the same bug happens with compress HC, that makes me think the problem might be on the decompress side, or somehow both compress algs have the same bug!
13:49:19 <hpaste> “Shane Kilkelly” pasted “ghcargs.txt” at http://hpaste.org/83357
13:49:31 <shane_kilkelly> http://hpaste.org/83357
13:49:40 <shane_kilkelly> oh wow, we have a hpaste bot. sweet
13:50:05 <shane_kilkelly> that paste is from a brand-new yesod app.
13:50:06 <carter> so what I think i'll do next is stare at the decompress code and see if theres some encoding hiccup there that isn't escaped or something
13:50:19 <luite> shane_kilkelly: tnx, appears to be missing indeed
13:50:49 <shane_kilkelly> superb. glad i could help. all part of my resolution to contribute to the yesod project. :)
13:51:29 <luite> yeah just send a pull req if you have code to contribute
13:52:08 <shane_kilkelly> will do, that's actually what got me into this mess in the first place i think. I was trying to set up a local development branch
13:52:28 <shane_kilkelly> I've already got one small addition I want to make to the Yesod Test module.
13:52:37 <carter> thoughtpolice or maybe i should just try adding the test case to the lz4 fuzzer code module https://bitbucket.org/carter/lz4-mirror/src/dd107ca14089e0a6273d61facd6e5806d1018244/fuzzer.c?at=master
13:52:50 <shane_kilkelly> and this is my first time contributing to an OSS project, so it's all new ground for me.
13:52:58 <luite> shane_kilkelly: hmm, it works fine here btw, with 7.4.2, i think because i have a newer cabal-install
13:53:13 <shane_kilkelly> weird.
13:53:27 <shane_kilkelly> so, can i upgrade my cabal-install?
13:53:55 <sm> http://www.youtube.com/watch?v=oMFYs3gfgis <- bugfixin music
13:54:07 <shane_kilkelly> I'm not really sure of how the dependencies work in this case
13:54:31 <shane_kilkelly> sm : outstanding
13:54:34 <sm> yes, you can upgrade cabal-install if it lets you
13:54:47 <sm> should be safe enough and in fact recommended
13:54:51 <shane_kilkelly> `cabal install cabal-install` ?
13:54:57 <shane_kilkelly> that looks a bit weird
13:55:16 <sm> exactly :) http://hub.darcs.net/simon/cabal-install-tutorial/README.md#getting-cabal
13:55:42 <ocharles> is there an official channel for Cabal development?
13:55:49 <shane_kilkelly> actually, that is by far the weirdest terminal line I've ever seen.
13:57:12 <luite> which cabal-install do you have?
13:57:18 <sm> ocharles: #hackage maybe
13:57:19 * hackagebot fay-base 0.14.2.0 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.14.2.0 (ChrisDone)
13:57:28 <ocharles> sm: thanks, I'll try there
13:57:43 <monochrom> if you "cabal install cabal-install", you often get a second version of the Cabal library. if this doesn't alarm you, read my http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon
13:58:09 <sm> oh oh
13:58:34 <monochrom> the safe way to build a new cabal-install version is to build it in sandbox, so that you can copy out the exe and then throw away the second version of Cabal
13:59:07 <sm> or maybe cabal install cabal-install && ghc-pkg unregister Cabal ?
13:59:18 <shane_kilkelly> fun times people, updating cabal-install has solved it.
13:59:34 <monochrom> hopefully, that is the only thing you need unregister
13:59:36 <shane_kilkelly> just a straight `cabal install cabal-install`
14:00:42 <applicative_> duncan c. was insisting this wasn't a problem, a second 'Cabal', since nothing much uses it.  I'm not sure I believe it...
14:01:00 <sm> I've never noticed a problem from it, I must say
14:01:06 <sm> but good to remember
14:01:38 <hiptobecubic> I am trying to understand church encoding of numerals. I get that \fx.x can be 0 (applications of f) and \fx.f x can be 1 and so on. I don't understand the successor function though
14:01:39 <sm> if it did cause trouble, it should be relatively easy to comprehend and fix
14:02:06 <hiptobecubic> How does  \nfx.f (n f x)  correspond to (+1) ?
14:02:09 <luite> shane_kilkelly: tnx for testing :)
14:02:13 <shane_kilkelly> lads, you've all been great but I must go now and open a few cans. Thanks for all the help this evening!
14:02:19 * hackagebot persistent-refs 0.2 - Haskell references backed by an IntMap for persistence and reversibility.  http://hackage.haskell.org/package/persistent-refs-0.2 (AdamFoltzer)
14:02:38 <monochrom> it is relatively easy to comprehend and fix for experts
14:02:38 <shane_kilkelly> don't worry, I'll be back in the morning if I manage to break it all again :)
14:02:39 <applicative_> sm, I'm reinstalling my foolishness, having inexplicably used your ghc-pkg-reset function to rm everything
14:02:41 <luite> i think i'll still commit a workaround
14:02:52 <applicative_> by foolishness I mean my customary packages
14:03:10 <monochrom> every 2-version cabal problem is incomprehensible to non-experts
14:03:11 <shane_kilkelly> probably best to patch it up indeed. anyway, thanks and goodnight!
14:04:45 <ski_> hiptobecubic : if `n' is `\f. \x. f (..(f x)..)' with `N' `f's, then `\f. x.f (n f x)' is `\f. \x. f (..(f x)..)' with `N+1' `f's
14:05:15 <sm> applicative_: um, so everything's working out ?
14:06:32 <applicative_> yeah, partly I had an arbitrary pile of things, but I wanted to see if I could install the main stuff all at once with -jN
14:06:34 <[swift]> argh. i don't get why this doesn't work. can someone tell me what's wrong about my use of ReaderT here? http://hpaste.org/83358
14:07:03 <hiptobecubic> ski_, each numeral is encoded as a function which returns a function which applies it's argument to the first argument n times, yes?
14:07:18 <ski_> yes
14:07:51 <hiptobecubic> ski_, so in the successor function, 'n' is one of these functions of two arguments (uncurried)
14:07:59 <ski_> hiptobecubic : .. what's a sensible type for the naturals here ?
14:08:00 <monochrom> in "m >>= f", m must be Scanner String, not String -> Scanner String
14:08:05 <ski_> hiptobecubic : yes
14:08:16 <applicative_> sm You might emphasize, though it doesn't matter immediately after a 'cabal update' -- that one does well to start of installing as much as possible together in one command
14:08:24 <applicative_> start off
14:08:34 <hiptobecubic> ski_, so the first argument to n, which binds to 'x' in 'n', will be 'f' ?
14:09:01 <[swift]> monochrom: i don't get that though; when i compose functions in the IO monad with >>=, they generally have type "a -> IO b"
14:09:21 <ski_> hiptobecubic : it binds to `f' in `\f. \x. f (..(f x)..)', not to `x'
14:09:44 <hiptobecubic> ohhhh that's where i was going wrong
14:09:52 <monochrom> that is for f, not for m. your two is doing fine in "... >>= two". your one is wrong in "one >>= ..."
14:09:53 <carter> thoughtpolice : the munging around with the c code requires enough reloading of things into my head it'd almost be easier for me to try a haskell version of the lib...
14:09:54 <hiptobecubic> yes of course. itls \f(\x(...))
14:10:01 <carter> but i'll see what i can do
14:10:02 <hiptobecubic> it's*
14:11:07 <[swift]> monochrom: oh wait. i guess i always start with getArgs which _does_ have type IO [String]. dang. i guess it is the same!
14:11:09 <[swift]> monochrom: thanks!
14:11:25 <sm> applicative_: thanks, will do
14:11:34 <monochrom> you're welcome
14:12:33 <applicative_> sm I very much approve of the advice to just get rid of everything, as if it were a matter of course, and the explanation that the trouble thus averted is due to the changes in hackage since you first installed stuff
14:14:03 <sm> I had a long list if excuses^H^H^Hreasons why people see these hassles with cabal, but I took it out
14:14:08 <monochrom> it is a great idea from Windows experience. try rebooting. try erasing and re-installing Windows
14:14:45 <hiptobecubic> ski_, is this correct? http://vpaste.net/uTs7n
14:14:48 <monochrom> indeed, the Windows CD has been updated since you first installed it
14:15:44 <sm> http://hub.darcs.net/simon/cabal-install-tutorial/browse/draft1.md#cabal-hell-and-how-to-escape-from-it-cabal-hell <- excuses
14:16:23 <ski_> hiptobecubic : `\nfx. f (n f x) \fx.x' should be `(\nfx. f (n f x)) \fx.x'
14:16:36 <catbee> omg i'm about to use the continuation monad, spare a moment and pray for me
14:16:36 <lambdabot> catbee: You have 1 new message. '/msg lambdabot @messages' to read it.
14:16:41 <ski_> (otherwise it looks ok)
14:16:59 <hiptobecubic> ski_, ah yes. ok thanks
14:17:05 <applicative_> see monochrom, he had linked to your page, but he took it out because you're too surly
14:17:36 <sm> lol I was just fixing that :)
14:18:47 <epta> Haskell-platform depends on ghc version? Can I install last platform with ghc-7.6.2?
14:19:17 <geekosaur> a given platform version only works wite ghc in that platform
14:20:05 <applicative_> epta, no, you can probably collect the same libraries with cabal install etc.  I guess there will be a new platform fairly soon
14:21:03 <monochrom> pick two: recent, well-tested, free of charge
14:21:24 <geekosaur> usual release date is sometime in April; they're already working out details, and I believe have already decided to build around 7.6.1
14:21:44 <geekosaur> (7.6.2 just came out, is not sufficiently tested for an April Platform release)
14:22:30 <applicative_> oh is that right?
14:22:51 <applicative_> epta, what os are you using, and what sort of thing do you want to do?
14:23:13 <carter> thoughtpolice point being: my c debugging foo right now is quite weak and among the things on my deck i don't have much bandwidth for doing that piece I think
14:24:18 <geekosaur> well, not "just" just came out, but it had been out for about a week when they discussed which ghc release to use
14:25:43 <epta> applicative_: I'm trying to create sufficient environment to build system for building haskell packages with ghc-7.6.2. Current problem is a long time of every build, so I wanna reduce it by having some bunch of packages preinstalled
14:25:46 <applicative_> epta do you have a working version of the cabal executable?
14:26:43 <applicative_> oh sorry you said something while I was typing
14:31:02 <epta> applicative_: whole question is what packages should I choose to keep them preinstalled for every build
14:32:30 <lemao> does anyone knows what is the purpose of dist/build/autogen/{module_Paths.hs,cabal_macros.hs} generated by 'cabal build'?
14:34:10 <applicative_> lemao: I hate ghc-paths too
14:34:38 <lemao> applicative_: :-) I am not sure yet if I hate it or not since I am not sure what it is used for
14:35:18 <geekosaur> lemao, it lets a program refer to itself. cabal-macros.h defines macros you can use with LANGUAGE CPP to conditionalize based on flags or etc.; Paths_foo.hs lets you get at, for example, where cabal was told to install the program
14:36:26 <geekosaur> http://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
14:36:53 <[swift]> http://hpaste.org/83363
14:37:00 <[swift]> i can't figure out how to do what i'm trying to do, here
14:37:21 <[swift]> is there any way i can make "runScanner" work?
14:37:42 <[swift]> if not, what's a haskelly way to "embed" some ReaderT stuff in a sequence of IO actions?
14:38:27 <c-ab> :t (ap)
14:38:28 <lambdabot> Monad m => m (a -> b) -> m a -> m b
14:38:35 <lemao> geekosaur: I see. So this would be the equivalent to ClassLoader.getResource()/getResourceAsStream() i.e. load a data file from the binary package
14:38:40 <lemao> (in java)
14:38:45 <geekosaur> sot of
14:38:56 <lemao> geekosaur: you need to load relative to the current package
14:38:57 <geekosaur> *sort of
14:39:18 <[swift]> c-ab: all the m's are the same there, though
14:39:44 <hiptobecubic> ski_, I think I've got this :) http://vpaste.net/dGPwX
14:40:20 <lemao> geekosaur: not sure what you mean by sort of, but what happens when I statically link an exe with this lib package containing a data file?
14:40:37 <[swift]> it seems like i need something like "Monad m1, m2 => m1 a -> (a -> m2 b) -> m1 b"
14:42:07 <geekosaur> "sort of" because java produces a jar containing all the data files along with the program classes and hands you a filehandle to something in the jar; this just gives you a path, and it's up to you to have the appropriate stuff in the cabal file to make sure the file is installed in that path
14:42:39 <geekosaur> also, the java setup means any jar can be relocated, but cabal will bake the pathname of the data file in at compile time
14:42:43 <ski_> hiptobecubic : missing `x' in `\fx.f    -- 1'. in `-- Plus 0 0 = 0', the next to last two steps have redundant brackets, and `\fx.f f x' is missing brackets
14:42:52 <geekosaur> so you can't move the data files
14:43:09 <epta> ghc ./configure failed http://pastebin.com/raw.php?i=3f0vVybw
14:43:13 <mauke> The paste 3f0vVybw has been copied to http://hpaste.org/83365
14:43:24 <ski_> (hiptobecubic : and the last `(\fx.x)' in the first two lines of `-- Plus 0 0 = 0' could also be removed, if you care for it)
14:43:31 <lemao> geekosaur: I am starting to hate this _Paths.hs :-)
14:43:40 <hiptobecubic> ski_, oops. miised that x in copy and paste :)
14:43:42 <ski_> hiptobecubic : otherwise it looks fine
14:44:36 <geekosaur> epta, I would suspect that the bootstrap ghc-pwd was built for a different linux version and can't find its ELF "interpreter"/runtime loader
14:45:27 <geekosaur> unix apis can only indicate errors with a numeric erro code and if you get ENOENT back from exec you can only guess that it applies to the executable and not to, say, its interpreter
14:46:50 <c-ab> > [(1+),(2+)] `ap` [4,5]
14:46:52 <lambdabot>   [5,6,6,7]
14:46:59 <hiptobecubic> ski_, how could one remove the second \fx.x ? isn't it needed to apply our function to it?
14:47:10 <c-ab> [swift]: yep
14:47:16 <hiptobecubic> ski_, or do you mean just not mentioning it until after we've dealt with the first one
14:47:52 <Ralith> geekosaur: unix APIs have very specific and well documented errors, and if you're guessing it's because you didn't read the docs :P
14:48:11 <epta> geekosaur: and how can I configure it?
14:50:09 <geekosaur> epta, you might be able to use a hex editor to change the embedded interpreter path, if that is the issue (try running ghc-pwd from the shell to see what happens, first; might also use strace to watch what it's trying to do), but if it's old enough to be pointing to the wrong ELF interpreter then the result would probably just crash on startup
14:52:41 <c-ab> > Just 1 `mplus` Nothing
14:52:42 <lambdabot>   Just 1
14:52:52 <hiptobecubic> ski_, I guess in the 0 0 case, I can use my previous proof of the succ function, if that's what you meant
14:53:13 <c-ab> > Nothing `mplus` Just 1
14:53:15 <lambdabot>   Just 1
14:53:31 <hiptobecubic> ski_, actually, nevermind. It's not the same function
14:53:38 <ski_> hiptobecubic : not remove it, just remove the brackets : `(\mnfx.m f (n f x)) (\fx.x) \fx.x' (a matter of taste, and exact concrete syntax)
14:53:47 <hiptobecubic> oh i see
14:53:57 <c-ab> should know that mplus is commutativz
14:54:10 <ski_> c-ab : it's not
14:54:23 <ski_> > Just False `mplus` Just True
14:54:24 <c-ab> hmm
14:54:24 <lambdabot>   Just False
14:55:09 <c-ab> by communtative I mean mplus x y == mplus y x
14:55:24 <ski_> @wiki MonadPlus
14:55:24 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus
14:55:29 <ski_> @wiki MonadPlus reform proposal
14:55:29 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
14:55:35 <ski_> c-ab : see those ^
14:55:51 <c-ab> > Just True `mplus` Just False
14:55:53 <lambdabot>   Just True
14:56:00 <c-ab> ski_: k
14:57:24 <c-ab> that's ovious for lists, i'm  stupid
14:57:40 * ski_ thinks `MonadElse' would be a better name than `MonadOr'
14:58:45 <c-ab> what would the thiord operator MonadOr do
14:59:08 <c-ab> nvml it's written
14:59:41 <Feuerbach> Any ideas on how to prove idempotency of Or? http://hpaste.org/83367 (unrelated to MonadOr :)
15:00:42 <c-ab> the proposal is also to modify mplus?
15:02:43 <c-ab> mplus is commutative is one of its arguments is mzero ;)
15:03:10 <c-ab> not lmuch useful
15:04:41 <ski_> c-ab : that's true for any monoid
15:08:00 <ski_> conal : hm, `proveSafeIO' could be interpreted as the system being required to prove it. i think something like `promiseIOPure' could sound better (cf. e.g. <http://www.mercurylang.org/information/doc-latest/mercury_ref/Promising-purity.html> and the `promise_X' goals at <http://www.mercurylang.org/information/doc-latest/mercury_ref/Goals.html>)
15:08:46 <centrinia_> @let (++++) = mplus
15:08:49 <lambdabot>  Defined.
15:09:47 <hiptobecubic> rewriting "\f.\x n"  as  "\fx.n" is uncurrying right? Or is it currying?
15:10:25 <ski_> hiptobecubic : neither, it's just syntactic sugar
15:10:44 <hiptobecubic> ski_, ah ok. \(f,x).n would be though?
15:10:55 <ski_> `\f -> \x -> ..f..x.' in Haskell is the same as `\f x -> ..f..x..'
15:11:20 <c-ab> since a function is like a value
15:11:33 <c-ab> hmm no
15:11:36 <hiptobecubic> ski_, yes indeed. Currying is going between that representation and pairs then?
15:13:18 <ski_> > seq ((\(\() -> False -> True) () -> ()) ()) ()
15:13:19 <ski_> > seq ((\(\() -> False -> True) -> \() -> ()) ()) ()
15:13:20 <lambdabot>   ()
15:13:21 <lambdabot>   *Exception: <interactive>:3:7-42: Non-exhaustive patterns in lambda
15:13:55 <ski_> hiptobecubic : currying is going from `\a -> \b -> ..a..b..' to `\(a,b) -> ..a..b..', yes
15:14:04 <ski_> sorry, the opposite direction
15:14:14 <ski_> (the above direction was uncurrying)
15:14:41 <hiptobecubic> ok
15:14:46 <hiptobecubic> :t uncurry
15:14:47 <lambdabot> (a -> b -> c) -> (a, b) -> c
15:14:55 <hiptobecubic> Yes ok.
15:15:26 <ski_> also, note that since `curry' itself is curried in Haskell, it can be used to partially apply a function
15:15:51 <hiptobecubic> :t curry
15:15:52 <lambdabot> ((a, b) -> c) -> a -> b -> c
15:15:56 <rodlogic> another question I could not find answers in the users guide: what is the purpose of libHSpackageB-0.1.0.0.a, which is an 'ar' of the individual .o files in a package? Doesnt GHC use the .hi and .o to perform the linking?
15:15:59 <c-ab> @hoogle curry
15:15:59 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
15:15:59 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
15:15:59 <lambdabot> package curry-base
15:16:07 <ski_> @type curry (\(a,b) -> a + b) 2  -- partially applying `\(a,b) -> a + b' with `a' as `2'
15:16:08 <lambdabot> Num c => c -> c
15:16:17 <geekosaur> rodlogic, that is a static archive
15:16:27 <geekosaur> try reading the documentation for ld
15:16:38 <hiptobecubic> ski_, yes.
15:16:40 <ski_> well, perhaps that was clumsily stated
15:16:54 <ski_> @type let partiallyApply = uncurry curry in partiallyApply
15:16:55 <lambdabot> ((b, b1) -> c, b) -> b1 -> c
15:17:31 <ski_> i ought to have said that `partiallyApply' is curried in Haskell (and is then the same as `curry'), because of the custom of currying by default
15:17:33 <hiptobecubic> ski_, I'm just working out multiplication using church numerals
15:17:50 <hiptobecubic> I see
15:18:01 <ski_> if arguments were tupled by default, then `partiallyApply' and `curry' would be different operations
15:18:32 <ski_> c-ab ^
15:19:24 <ski_> (btw, the above `seq' example show that in GHC, `\f -> \x -> ..f..x.' need not be the same as `\f x -> ..f..x..', in case `f' and `x' are allowed to stand for arbitrary patterns, and not just variable names)
15:22:20 <c-ab> @type (uncurry curry)
15:22:22 <lambdabot> ((b, b1) -> c, b) -> b1 -> c
15:23:17 <hiptobecubic> Took me a moment to realize what was happening there
15:23:20 <c-ab> > uncurry (+)
15:23:22 <lambdabot>   No instance for (GHC.Show.Show ((c0, c0) -> c0))
15:23:22 <lambdabot>    arising from a use of `...
15:24:43 <hiptobecubic> But yes, we're just storing the first argument to the curried function in the second position of the tuple i guess
15:25:29 <c-ab> > (uncurry (+)) (2, 1)
15:25:31 <lambdabot>   3
15:26:39 <hiptobecubic> curry fst ~ const then
15:26:53 <hiptobecubic> and curry snd ~ some weird thing that throws away the first of its arguments
15:27:13 <hiptobecubic> const id i suppose
15:28:22 <c-ab> > (curry fst) 1 2
15:28:24 <lambdabot>   1
15:29:53 <crdueck> @hoogle Unique
15:29:54 <lambdabot> Data.Unique module Data.Unique
15:29:54 <lambdabot> Data.Unique data Unique
15:29:54 <lambdabot> package uniqueid
15:37:15 <sproingie> yay, i ported my conway's life demo to OpenGLRaw and GLFW :)
15:44:47 <applicative_> @type let plus = uncurry (+); papply = uncurry curry; in papply (papply,plus)
15:44:49 <lambdabot> Num c => c -> c -> c
15:50:34 <lispy> sproingie: congrats
15:52:13 <KAction> @type fix
15:52:15 <lambdabot> (a -> a) -> a
15:52:54 <c-ab> @hoogle json
15:52:55 <lambdabot> package json
15:52:56 <lambdabot> package json-b
15:52:56 <lambdabot> package json-builder
15:53:03 <donri> @hackage aeson
15:53:03 <lambdabot> http://hackage.haskell.org/package/aeson
15:54:00 <c-ab> k
15:55:15 <ski_> applicative_ : now express "versions" of the three Futamura projections using that ?
15:56:24 <c-ab> :t decode
15:56:24 <applicative_> ski_: I'm having trouble getting a handle on it ....
15:56:25 <lambdabot> Not in scope: `decode'
16:01:29 <c-ab> aeson parsing needs to know the structure ;?
16:01:53 <Enigmagic> c-ab: no
16:02:22 * hackagebot OpenAL 1.4.0.2 - A binding to the OpenAL cross-platform 3D audio API  http://hackage.haskell.org/package/OpenAL-1.4.0.2 (BenFoppa)
16:02:27 <Enigmagic> c-ab: from the docs: >>> decode "{\"foo\": [\"abc\",\"def\"]}" :: Maybe Value
16:02:43 <Enigmagic> Value represents any JSON value
16:03:11 <c-ab> alright thx
16:08:50 <c-ab> "The type of gfoldl is a headache, but operationally it is a simple generalisation of a list fold."
16:09:07 <c-ab> ;
16:09:49 <ski_> @type Data.Data.gfoldl
16:09:51 <lambdabot> Data.Data.Data a => (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
16:11:03 <ski_> @type (??)
16:11:04 <lambdabot> Functor f => f (a -> b) -> a -> f b
16:11:52 <c-ab> @type (ap)
16:11:53 <lambdabot> Monad m => m (a -> b) -> m a -> m b
16:12:50 <quchen> c-ab: ap == <*>
16:13:01 <ski_> @type Data.Data.gfoldl (??)
16:13:03 <lambdabot> (Data.Data.Data a, Functor c) => (forall g. g -> c g) -> a -> c a
16:13:23 * ski_ thinks functions can't (generally) be compared with `(==)'
16:13:59 <ski_> > Data.Data.gfoldl (??) (const Nothing) [Just 2,Just 3]
16:14:01 <lambdabot>   Not in scope: `Data.Data.gfoldl'
16:14:02 <quchen> ski_: Yes, comparing two functions is undecidable. Not just in Haskell, but in general.
16:14:04 <ski_> bah
16:14:17 <quchen> Basically, you would have to compare all input/output pairs, which never halts.
16:14:20 <ski_> quchen : .. so i would have stated `ap = (<*>)'
16:14:29 <ski_> .. but also see
16:14:33 <ski_> @where impossible
16:14:34 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
16:15:13 <ski_> (in which case total `(Natural -> Bool) -> Bool' functions can be compared for equality)
16:15:32 <quchen> By the way, seeing your name: for functions, <*> = S from SKI calculus. :-)
16:15:42 <ski_> i know :)
16:20:39 <quchen> Not sure I'm in the mood of reading technical stuff now :/
16:20:44 <quchen> Is there an abstract for those?
16:25:38 <TravisD> Does anyone know of a tutorial for the random-fu library?
16:29:47 <hpaste> Xaratas pasted “Type Problem” at http://hpaste.org/83368
16:30:09 <fxr> Hmm how can I convince a boss to use haskell as the primary language for developing a network security product for his startup? Do you have any ideas, experiences?
16:30:31 <Xaratas> hi, can someone help me to understand why haskell does not find the type?
16:30:37 <c-ab> depend on your collegues also
16:30:45 <fxr> I'm seeing nightmares, he is insisting on python due to programmer availibility.
16:30:46 <lispy> fxr: who is the technical lead?
16:31:21 <fxr> lispy: The team is not setup. I will be the first employee
16:31:29 <lispy> fxr: BTW, https://github.com/GaloisInc/HaNS
16:31:39 <Ralith> fxr: cite results in the literature demonstrating reliability and security implications of a good type system
16:31:41 <fxr> lispy: yeah I already read it
16:32:10 <lispy> fxr: IMO, the person who is accountable for execution should be the one making such decisions. if that person has responsibility but not authority the team will have larger problems
16:32:30 <fxr> hmm
16:32:32 <Ralith> also, what lispy said
16:32:38 <hpaste> skuggi pasted “Kind error” at http://hpaste.org/83369
16:33:05 <skuggi> does anyone know what that's about?
16:33:15 <Ralith> if it's not your boss's place to make the decision, then you should sort that out first
16:34:31 <MrWoohoo> sudo cabal install happstack {results in -->} src/Happstack/Server/Internal/Socket.hs:66:7:ghc: panic! (the 'impossible' happened)
16:34:55 <parcs> don't ever do 'sudo cabal'
16:35:06 <fxr> Ralith: well that choice was made by two other partners, and I really don't know how to fix this problem.
16:35:21 <stepcut> MrWoohoo: what OS and version of GHC ?
16:35:26 <hpaste> MrWoohoo pasted “GHC bug???” at http://hpaste.org/83370
16:35:28 <Ralith> fxr: the problem that it's not your decision, or the problem that they chose python?
16:35:42 <stepcut> ah, darwin
16:35:54 <MrWoohoo> osx 10.8.2
16:36:02 <stepcut> MrWoohoo: one moment
16:36:03 <sproingie> what would the python code be doing?  if it's a web UI for a security product, i might pick python too
16:36:07 <MrWoohoo> The Glorious Glasgow Haskell Compilation System, version 7.4.2
16:36:11 <fxr> Ralith: the former one.
16:36:30 <sproingie> (actually i'd pick java but python's a close second)
16:36:45 <Ralith> fxr: I'm no expert, I'd worry for the prospects of this startup if people don't agree on how major decisions should be made.
16:36:52 <MrWoohoo> Bleh… I hated python's syntax
16:36:54 <Ralith> , but I'd*
16:36:58 <stepcut> MrWoohoo: try, cabal install happstack-server -f-template_haskell
16:37:28 <sproingie> Ralith: any healthy company has disagreements, it's how they're resolved that counts
16:37:47 <Ralith> sproingie: right, thus the impetus to resolve it first.
16:37:48 <MrWoohoo> should I retry the happstack install after this?
16:37:56 <c-ab> you could also develop in 2 languages in parallel
16:38:01 <MrWoohoo> oh… LOL NM
16:38:19 <MrWoohoo> worked great! tghanks!
16:38:25 <chrisdone> c-ab: that'll lead to some bad us and them culture
16:38:27 <fxr> c-ab: yeah that's an option god bless FFI
16:39:06 <MrWoohoo> stepcut: so how will I recognize this sort of problem and solution in the future?
16:39:18 <chrisdone> as someone working in a "some haskell, some php, some java" workplace of a single team, polylinguism is not good
16:39:21 <sproingie> python's syntax bothers me less than the prevailing dev culture
16:39:38 <lispy> fxr: I suppose you could try posting for haskell programmers and python programmers (separately) and see how the applicant pools compare :)
16:39:41 <sproingie> ignoring it entirely works out pretty well tho
16:40:04 <lispy> fxr: I mean, if the issue really is about hiring then maybe the way to convince your boss is with facts
16:40:29 <lispy> fxr: I say that knowing that often language choice comes down to "gut feel"
16:40:32 <sproingie> i work in one of those "you could write it in brainfuck as long as it works" shops
16:41:35 <fxr> well I am very comfortable with haskell and lisp
16:41:41 <lispy> fxr: on the bright side, at least your boss isn't advocating C++
16:41:49 <chrisdone> sproingie: that works well if the 'it' isn't a 20kloc codebase that handles payments or complex data/workflows
16:41:56 <stepcut> MrWoohoo: no idea… I just happen to have a lot of experience with happstack and template haskell
16:42:11 <stepcut> MrWoohoo: this bug may provide a clue about the underlying problem, http://hackage.haskell.org/trac/ghc/ticket/7235
16:42:20 <stepcut> MrWoohoo: what version of template-haskell do you have installed ?
16:42:29 <fxr> I think I'll develop such product half the time that he planning
16:42:33 <chrisdone> sproingie: otherwise it's a maintenance disaster waiting to happen
16:42:46 <MrWoohoo> not sure. will cabal tell me?
16:43:10 <sproingie> chrisdone: exactly, the sort of stuff we're writing in this shop is either totally a one-off sort of thing, or ops automation that doesn't need continuous maint
16:43:46 <sproingie> nothing shipping to customers, not that many things providing integration points except streams of CSV files
16:44:39 <kris928> Can anyone here help me understand how to use quickcheck with a GADT? I've read http://www.haskell.org/haskellwiki/QuickCheck_/_GADT but don't follow where GADTs come in there.
16:46:22 <fxr> lispy: have you ever used HaNS?
16:47:16 <kris928> Can anyone help me understand how to define an instance of Arbitrary for a GADT to use with quick check?
16:48:15 * M30W has a nice little base62 library for generating tokens. And now for the IO :(
16:48:26 <M30W> Well fixing the io
16:48:38 <ion> 62?
16:48:40 <c-ab> :t oneif
16:48:41 <lambdabot>     Not in scope: `oneif'
16:48:42 <lambdabot>     Perhaps you meant `oneOf' (imported from Data.List.Split)
16:48:45 <c-ab> :t oneof
16:48:47 <lambdabot>     Not in scope: `oneof'
16:48:47 <lambdabot>     Perhaps you meant `oneOf' (imported from Data.List.Split)
16:48:52 <c-ab> :t oneOf
16:48:53 <lambdabot> Eq a => [a] -> Splitter a
16:49:03 <fxr> elliott: you there?
16:50:16 <kris928> I don't see how to define an instance of Arbitrary for a GADT that represents an expression of different types since I want to effectively define an arbitrary definition separately for each type of expression. So I want to do something like "instance Arbitrary (Expr Double)" but I can only do "instance Arbitrary (Expr a)"
16:50:19 <croikle> ion: I guess digit+alpha
16:51:24 <c-ab> kris928: what is the kind of Arbitrary
16:51:36 <ion> croikle: Yeah. I was wondering why not use the more popular base64 at that point.
16:52:12 <kris928> c-ab: Sorry, I don't follow what you mean by kind? Arbitrary is a typeclass used to generate test data in quickcheck
16:52:38 <c-ab> @kind Either
16:52:40 <lambdabot> * -> * -> *
16:52:50 <kris928> @kind Arbitrary
16:52:52 <lambdabot>     Not in scope: type constructor or class `Arbitrary'
16:53:14 <lispy> fxr: I have yeah, but indirectly. Basically, I sit next to the author.
16:53:22 <c-ab> I guess it's * -> *
16:53:32 <lispy> fxr: I don't know what his irc handle is, it's not elliott. He doesn't come here often.
16:54:20 <kris928> c-ab: Was that the kind of arbitrary or a response to lispy?
16:54:25 <monochrom> Arbitrary is a type class. perhaps you can say, its kind is ContraintKind
16:55:19 <monochrom> or perhaps * -> ConstraintKind
16:55:21 <kris928> monochrome, right. Any idea how I can define an instance of Arbitrary for an GADT effectively?
16:55:33 <hiptobecubic> ski_, If feels like a huge magic coincidence that these functions work. http://vpaste.net/pJN9A
16:55:41 <monochrom> I don't know. I have not studied Arbitrary
16:55:54 <fxr> lispy: peng li, the events and threads guy
16:57:31 <kris928> The problem I can't work around is that arbitrary  is a function that returns a "Gen a" but I want to return a "Gen a" for each b in "Expr b" of my GADT differently.
16:57:36 <lispy> fxr: I'm not familiar with peng li. I thought you were looking for "elliott" thinking that was the same as elliottt on github
16:59:14 <lispy> kris928: I haven't really thought it through so I could be wrong, but maybe you can make a wrapper that hides the b?
16:59:34 <kris928> I'll try that. I think I did last night but it was late ;).
16:59:39 <lispy> (and then unpacking that wrapper recovers the b)
16:59:41 <hiptobecubic> church encoding feels suspiciously like difference lists
17:00:28 <kris928> lispy: seems to work if I define a new type like "newtype DoubleExpr = Expr Double"
17:01:01 <kris928> Always seems strange when I can work around problems like this, you would think it would just let me say "instance Arbitrary (Expr Double)" instead
17:01:10 <jmcarthur> hiptobecubic: yup!
17:01:45 <jmcarthur> hiptobecubic: also compare to the implementation of foldl in terms of foldr
17:02:33 <kris928> lispy: of course, now I have defined a new type so this doesn't really work because i actually want to return the old type "Expr Double".
17:02:39 <hiptobecubic> jmcarthur, hmmm
17:02:42 <jmcarthur> i haven't sat down to deduce an explanation of their relationship, but i'm certain all these are related
17:02:59 <hiptobecubic> jmcarthur, I haven't implemented that yet actually, despite everyone talking about it
17:03:14 <jmcarthur> ah, then i won't spoil it
17:03:42 <hiptobecubic> :) I suppose I should just get it over with
17:07:55 <ski_> hiptobecubic : `(\nfx.(n f x)) \fx.x' in `Plus 0 0 = 0' has redundant brackets, as does `(\nfx.(n f) ((n f) x)) \fx.f (f (f x))  -- rewrite' (which is really the same as the previous line, unnecessary step, strictly speaking)
17:08:48 <JoeyA> I've run into a case where I need to use a Conduit in a resumable fashion: client sends chunks of compressed data (one possible type of message), and server feeds them to a compressor and handles resulting data.  Is there something ready-made for this, or will I have to code up a ResumableConduit myself?  Surely I'm not the only one who has wanted to do this.
17:09:03 <hiptobecubic> I wasn't terribly worried about redundant brackets. I guess I could fix them
17:09:19 <JoeyA> Granted, I could just run the conduit in a forked thread, but I'd rather not have all those context switches.
17:09:35 <hiptobecubic> The extra brackets and unnecessary steps were to make it easier for me to retrace my steps
17:10:52 <ski_> the outer brackets in `((\y.(\z.f (f z)) ((\z.f (f z)) y)))' (after `α-conversion') are also redundant
17:11:20 <Taneb> Is there something that is for Apply and Applicative what Option is for Semigroup and Monoid?
17:12:57 <ski_> hiptobecubic : looks fine
17:13:26 <ski_> > equalS cantor (\_ -> True) (\bs -> if b !! 0 then True else True)
17:13:27 <Taneb> data Foo f a = Pure a | Foo (f a); instance Apply f => Applicative (Foo f)
17:13:29 <lambdabot>   Couldn't match expected type `[GHC.Types.Bool]'
17:13:29 <lambdabot>              with actual ty...
17:13:36 <ski_> > equalS cantor (\_ -> True) (\bs -> if bs !! 0 then True else True)
17:13:38 <lambdabot>   True
17:14:41 <otters> :t cantor
17:14:42 <lambdabot> ([Bool] -> Bool) -> [Bool]
17:14:51 <otters> what does that do
17:15:36 <JoeyA> > cantor head
17:15:38 <lambdabot>   [True,False,False,False,False,False,False,False,False,False,False,False,Fal...
17:15:48 <JoeyA> > cantor (!! 1)
17:15:50 <lambdabot>   [False,True,False,False,False,False,False,False,False,False,False,False,Fal...
17:15:55 <JoeyA> > cantor (!! 10)
17:15:57 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,True,False,Fal...
17:16:05 <ski_> > equalS cantor (const True) (const False)
17:16:08 <lambdabot>   False
17:16:11 <JoeyA> @src cantor
17:16:11 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:16:12 <hiptobecubic> ski_, thanks
17:16:22 <ski_> checks whether the two given functions are equal
17:16:33 <otters> oh
17:16:49 <otters> wait a second
17:16:50 <otters> how does cantor do that
17:16:53 <sproingie> o/~ i hate the peano space and the coq curve // i fear the cantor ternary set // the serpinski gasket makes me want to cry o/~
17:16:55 <ski_> (total functions on infinite list input, i.e.)
17:16:59 <M30W> What would be the preferred method to have a mutatable list work through different lightweight threads (network sockets/handlers)
17:17:11 <M30W> Map *
17:17:12 <ski_> > equalS cantor (const True) (\bs -> bs !! 13)
17:17:14 <lambdabot>   False
17:17:39 <JoeyA> M30W: TVar (Map k v)
17:17:50 <hiptobecubic> > cantor evens
17:17:52 <lambdabot>   Not in scope: `evens'
17:17:52 <lambdabot>  Perhaps you meant `even' (imported from Prelude)
17:17:57 <M30W> Thank you JoeyA ^_^
17:18:06 <Taneb> Aha, MaybeApply
17:19:17 <JoeyA> M30W: http://ofps.oreilly.com/titles/9781449335946/sec_conc-server.html
17:19:54 <M30W> Wow -vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
17:19:58 <JoeyA> If you're not familiar with STM yet, look at some of the preceding chapters first.
17:20:02 <carter_> thoughtpolice i'm digging into the decomprress foucntion
17:20:28 <kris928> I get it now, I need to define an existential type over my GADT
17:20:45 <Saizan> ?ty equalS
17:20:47 <lambdabot> Eq p => ((a -> Bool) -> a) -> (a -> p) -> (a -> p) -> Bool
17:20:48 <ski_> > equalS cantor (\bs -> bs !! sum ([2 | bs !! 3 || bs !! 4] ++ [4 | bs !! 1 || bs !! 4])) (\bs -> if bs !! 4 then bs !! 6 else bs !! if bs !! 3 then if bs !! 1 then 6 else 2 else if bs !! 1 then 4 else 0)
17:20:50 <lambdabot>   True
17:21:03 <Xaratas> how to create lists with a paramter driven amount of elements? [1..n] is easy but how to do something like [[a,b, .., n] | a <- [1..n], b <- [1..n], ..., <more filter conditions>] ?
17:21:13 <hiptobecubic> @let (x:xs) /\/ ys = x : (ys /\/ xs)
17:21:16 <lambdabot>  Defined.
17:21:37 <hiptobecubic> > [1,3..]  /\/ [2,4..]
17:21:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:21:40 <ski_> > equalS cantor and or  -- fails, because `and' and `or' are not total on every infinite list
17:21:44 <lambdabot>   mueval-core: Time limit exceeded
17:22:21 <hiptobecubic> :t unzip
17:22:23 <lambdabot> [(a, b)] -> ([a], [b])
17:23:19 <ski_> > equalS cantor (and . take 10) (and . take 20)
17:23:22 <lambdabot>   False
17:23:55 <hiptobecubic> @let peel (x:y:ys) = y:peel ys
17:23:57 <lambdabot>  Defined.
17:24:01 <hiptobecubic> peel [1..]
17:24:08 <hiptobecubic> >peel [1..]
17:24:20 <hiptobecubic> > peel [1..] -- sigh
17:24:20 <ski_> > peel [0 ..]
17:24:22 <lambdabot>   can't find file: L.hs
17:24:22 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
17:24:58 <hiptobecubic> > cantor peel
17:25:00 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
17:25:01 <lambdabot>              with actual type...
17:25:06 <hiptobecubic> :t cantor
17:25:08 <lambdabot> ([Bool] -> Bool) -> [Bool]
17:25:18 <hiptobecubic> oh
17:28:06 <hiptobecubic> > cantor (head . dropWhile not)
17:28:10 <lambdabot>   mueval-core: Time limit exceeded
17:28:24 <hiptobecubic> I suppose that's the only thing that makes senes there
17:28:27 <hiptobecubic> sense*
17:29:16 <hiptobecubic> > cantor (last . take 20)
17:29:17 <sw2wolf> :t head . dropwhile not
17:29:18 <lambdabot>     Not in scope: `dropwhile'
17:29:18 <lambdabot>     Perhaps you meant one of these:
17:29:18 <lambdabot>       `dropWhile' (imported from Data.List),
17:29:18 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
17:29:33 <hiptobecubic> > cantor (last . take 7)
17:29:35 <lambdabot>   [False,False,False,False,False,False,True,False,False,False,False,False,Fal...
17:29:40 <sw2wolf> :t head . dropWhile not
17:29:42 <lambdabot> [Bool] -> Bool
17:30:20 <ski_> @let digits :: ([Int] -> Bool) -> [Int]; digits = sequenceS (repeat (ambiguousS [0 .. 1]))
17:30:23 <lambdabot>  Defined.
17:31:10 <M30W> JoeyA: What is the diff with a TVar and an IORef?
17:31:12 <ski_> > digits (\as -> as !! 5 == 3 && as !! 3 == 4 || as !! 2 == 7 && as !! 4 == 9)
17:31:15 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:31:18 <sproingie> "head . dropWhile not" seems like it'd only ever return one value
17:31:22 <sproingie> that or error
17:31:35 <chrisdone> http://perse-irc.net/ -- hehe, simple beginnings
17:32:03 <arkeet> > cantor (last . take 5)
17:32:06 <lambdabot>   [False,False,False,False,True,False,False,False,False,False,False,False,Fal...
17:32:17 <M30W> > repeat 1 -- ski_ lol
17:32:19 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:32:21 <hiptobecubic> sproingie, yes. it's the same as False.
17:32:31 <hiptobecubic> sproingie, well... if it terminates
17:32:48 <M30W> @where cantor
17:32:48 <JoeyA> M30W: the difference between IORef and TVar is the difference between the familiar and the enlightening.
17:32:49 <lambdabot> I know nothing about cantor.
17:32:59 <hiptobecubic> M30W, ski_ defined it
17:33:12 <M30W> hiptobecubic: That's what I thought..
17:33:18 <M30W> where should give me the definition
17:33:21 <M30W> @where rot13
17:33:22 <lambdabot> (let e[a,b,c]=zip[a..c]$[b..c]++[a..]in map$fromMaybe<*>(`lookup`(e"anz"++e"ANZ")))
17:33:22 <M30W> like that
17:33:22 <JoeyA> An IORef is just a mutable cell, like a pointer to a single value.
17:33:27 <JoeyA> @hoogle IORef
17:33:28 <lambdabot> Data.IORef module Data.IORef
17:33:28 <lambdabot> Data.IORef data IORef a
17:33:28 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
17:33:44 <M30W> JoeyA: So TVar still?
17:34:02 <arkeet> :t ap fromMaybe
17:34:04 <ski_> > cantor (\bs -> bs !! 2)
17:34:07 <sproingie> the heck is e"anz"?
17:34:08 <lambdabot> (b -> Maybe b) -> b -> b
17:34:10 <lambdabot>   [False,False,True,False,False,False,False,False,False,False,False,False,Fal...
17:34:13 <arkeet> sproingie: the function e applied to "anz"
17:34:16 <M30W> TVar (M.Map Integer DateTime)
17:34:29 <sproingie> arkeet: ah, the spacing threw me
17:34:43 <JoeyA> Sharing IORefs among threads can easily lead to race conditions.
17:34:58 <M30W> TVar locks?
17:35:09 <M30W> Sweat.
17:35:27 <JoeyA> TVars are variables in STM.  You can modify multiple TVars at once in a single transaction.
17:35:42 <JoeyA> And the transaction's effects aren't seen by other threads until they complete.
17:35:59 <indomitus> > putStr "Hello World!"
17:35:59 <JoeyA> It's sort of like having a global lock.
17:36:01 <arkeet> STM is cool.
17:36:01 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
17:36:01 <lambdabot>    arising from a use of ...
17:36:04 <ski_> > searchS (ambS 0 1) (== 0)
17:36:07 <lambdabot>   Just 0
17:36:09 <ski_> > searchS (ambS 0 1) (== 1)
17:36:10 <M30W> Cool indeed
17:36:12 <lambdabot>   Just 1
17:36:12 <ski_> > searchS (ambS 0 1) (== 2)
17:36:15 <lambdabot>   Nothing
17:36:18 <JoeyA> M30W: but the really cool thing STM provides is *blocking* transactions.
17:36:31 <M30W> Blocking how?
17:36:39 <JoeyA> You can wait for a TVar to become true: atomically $ do b <- readTVar var; if b then return () else retry
17:36:54 <sw2wolf> JoeyA: what's *blocking* Tx ?
17:36:56 <ski_> > searchS cantor (!! 2)
17:36:57 <JoeyA> Conceptually, it keeps trying over and over until it succeeds.
17:36:58 <lambdabot>   Just [False,False,True,False,False,False,False,False,False,False,False,Fals...
17:37:18 <ski_> > searchS (ambiguousS [0 .. 9]) (== 0)
17:37:20 <lambdabot>   Just 0
17:37:22 <ski_> > searchS (ambiguousS [0 .. 9]) (== 10)
17:37:24 <lambdabot>   Nothing
17:37:28 <ski_> > searchS (ambiguousS [0 .. 9]) (== 9)
17:37:30 <lambdabot>   Just 9
17:37:30 <M30W> JoeyA: cpu hungry ot threaddelay?
17:37:33 <ski_> hmm
17:37:40 <M30W> or just good?
17:37:52 <hiptobecubic> Ok i'm off for the night. Thanks again ski_
17:37:59 <ski_> oh
17:38:00 <arkeet> M30W: that's just a conceptual model.
17:38:08 <JoeyA> M30W: no, it's implemented a little more sophisticatedly.
17:38:11 <ski_> @let digits10 :: ([Int] -> Bool) -> [Int]; digits = sequenceS (repeat (ambiguousS [0 .. 9]))
17:38:12 <lambdabot>  <local>:20:1:
17:38:13 <lambdabot>      The type signature for `digits10' lacks an accompanying b...
17:38:17 <ski_> @let digits10 :: ([Int] -> Bool) -> [Int]; digits10 = sequenceS (repeat (ambiguousS [0 .. 9]))
17:38:18 <M30W> :)
17:38:20 <lambdabot>  Defined.
17:38:24 <arkeet> really it just sleeps until the TVar it read has been modified.
17:38:30 <arkeet> and then tries again.
17:38:34 <ski_> > searchS digits10 (\as -> as !! 5 == 3 && as !! 3 == 4 || as !! 2 == 7 && as !! 4 == 9)
17:38:36 <lambdabot>   *Exception: stack overflow
17:38:54 <ski_> interesting
17:39:21 <JoeyA> An STM transaction records changes (without applying them).  At the end of the transaction, it commits.  If any of the variables changed under it, it tries again.
17:39:50 <JoeyA> If the transaction calls 'retry', it means it didn't like what it saw, so it will wait until one of the TVars it read changes, then try again.
17:40:40 <ski_> > searchS digits10 (\as -> as !! 0 == 3 && as !! 1 == 2)
17:40:43 <lambdabot>   Just [3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
17:40:45 <ski_> > searchS digits10 (\as -> as !! 0 == 3 && as !! 0 == 2)
17:40:47 <lambdabot>   Nothing
17:41:05 <ski_> hiptobecubic : yw
17:41:27 <ski_> > searchS digits10 (\as -> as !! 0 == 3 || as !! 0 == 2)
17:41:30 <lambdabot>   Just [3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
17:41:37 <sw2wolf> JoeyA: How about if the Tx fails forever ?
17:41:56 <JoeyA> sw2wolf: You mean it keeps trying over and over?
17:42:04 <sw2wolf> yes
17:42:15 <JoeyA> It waits for the variable to change.
17:42:22 <JoeyA> So if one var has 3 and the other has 4
17:42:31 <JoeyA> and we want a > b
17:42:31 <sw2wolf> can timeout it ?
17:42:39 <JoeyA> You can throw an exception at it.
17:42:50 <ski_> > digits10 (\as -> as !! 0 == 3 || as !! 1 == 2)
17:42:54 <lambdabot>   [0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
17:42:58 <ski_> > digits10 (\as -> as !! 0 == 1 || as !! 1 == 2)
17:43:01 <lambdabot>   [0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
17:43:04 <JoeyA> Or if you compile with -threaded, you can use registerDelay to wait.
17:43:16 <M30W> JoeyA: genToken :: IO (M.Map Integer DateTime), how would I go about adding tokens generated with this function?
17:43:47 <sw2wolf> @hoogle registerDelay
17:43:48 <lambdabot> GHC.Conc.IO registerDelay :: Int -> IO (TVar Bool)
17:43:48 <lambdabot> GHC.Conc registerDelay :: Int -> IO (TVar Bool)
17:43:48 <lambdabot> Control.Concurrent.STM.TVar registerDelay :: Int -> IO (TVar Bool)
17:44:05 <ski_> > digits10 (\as -> as !! 1 == 3 || as !! 0 == 2)
17:44:07 <lambdabot>   [*Exception: stack overflow
17:44:12 <JoeyA> But deadlocked threads (on MVar or STM) are garbage collected automatically.
17:44:13 <ski_> curious
17:44:26 <JoeyA> via the BlockedIndefinitelyOnMVar and BlockedIndefinitelyOnSTM exceptions
17:44:57 <sw2wolf> Great
17:44:57 * M30W installs stm :3
17:45:20 * sw2wolf interested in STM now
17:45:55 <hashem> How does one prevent the export of a data constructor? I was surprised to see "IO(..)" in the system.IO source http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.0.0/src/GHC-Types.html#IO
17:46:14 <hashem> because when I load system.IO in ghci, the IO data constructor isn't in scope
17:46:25 <JoeyA> I'm trying to find a talk by Simon Peyton Jones about STM.  I've seen one or two.
17:46:31 <JoeyA> I just don't know the go-to link for that.
17:46:47 <JoeyA> I would refer to http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/index.htm, but the video takes forever to download.
17:46:50 <shachaf> There is no module called system.IO.
17:47:01 <shachaf> The module System.IO doesn't export "IO(..)", just "IO".
17:47:18 <sw2wolf> JoeyA: thx
17:47:37 <shachaf> You linked to GHC.Types, which is not System.IO. It's the module that defines the type IO.
17:48:00 <hashem> ah okay. Thanks shachaf
17:50:27 <jfischoff> how do I pretty print float with only a limited amount of precision
17:52:04 <Hafydd> jfischoff: do you know about http://www.haskell.org/onlinereport/haskell2010/haskellch38.html#x46-31500038.1 ?
17:52:38 <jfischoff> Hafydd: thanks that's what I was looking for
17:57:57 * M30W thinks he should make a parsec parser to fix this..
17:59:44 <carter> bahhh, low level debugging is hard
18:05:27 <c-ab> :t doesFileExist
18:05:29 <lambdabot> Not in scope: `doesFileExist'
18:05:50 <ski_> @hoogle FileExist
18:05:51 <lambdabot> System.Posix.Files fileExist :: FilePath -> IO Bool
18:05:51 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
18:06:08 <c-ab> thx yes found it
18:09:21 <quchen> jfischoff: The easier way is probably using printf.
18:09:50 <jfischoff> quchen: oh right printf
18:10:03 <ab9rf> printf infects _everything_
18:10:25 <ab9rf> i can't think of a language that i've used in the past two decades that doesn't have either printf or something very close to it
18:10:37 <quchen> Which is a good thing.
18:11:00 <Hafydd> ab9rf: do you consider Python's format strings to be "very close" to printf?
18:11:07 <ab9rf> Hafydd: yes
18:11:21 <Hafydd> Well then, that's no surprise. Format strings are a nice abstraction.
18:11:34 <lispy> format strings are a dsl :)
18:11:39 <sproingie> lisp of course has FORMAT
18:11:42 <quchen> Very close to printf is everything that makes sense of cryptic stuff like "%02d"
18:12:05 <ab9rf> Hafydd: didn't say otherwise :)
18:12:13 <Hafydd> I'm glad we agree.
18:12:13 <ab9rf> Hafydd: they're not the best for performance though
18:12:31 <sproingie> it's a crappy DSL but it's very compact
18:12:53 <sproingie> no one wants to have to "break out" of the string they're formatting to satisfy the DSL
18:12:54 <ab9rf> python especially, since it has to allocate a result string as large as whatever you shove through it
18:13:00 <arkeet> shachaf: we need your string formatting esdl
18:13:06 <ab9rf> haskell can at least generate the result string lazily
18:13:19 <shachaf> arkeet: It's not mine!
18:13:31 <shachaf> All I did was fix it up not to use Category.
18:13:32 <arkeet> well, whoever's.
18:13:36 <arkeet> lol
18:15:18 <shachaf> @let now m k d = k (\m' -> d (m <> m')); later am k d a = k (\m' -> d (am a <> m')); run l = l ($ mempty) id
18:15:21 <lambdabot>  Defined.
18:15:24 <shachaf> Hmm, there's a simpler version.
18:16:25 <arkeet> > run (now "a" . later show . now "b") 3
18:16:28 <lambdabot>   "a3b"
18:16:40 <arkeet> :t now
18:16:41 <arkeet> :t later
18:16:42 <lambdabot> Monoid m => m -> ((m -> t1) -> t) -> (m -> t1) -> t
18:16:43 <lambdabot> Monoid m => (t2 -> m) -> ((m -> t1) -> t) -> (m -> t1) -> t2 -> t
18:16:58 <shachaf> jmcarthur: Hey, I finally get to try patdiff!
18:17:10 <arkeet> at least the types make sense.
18:17:11 <arkeet> :t run
18:17:12 <lambdabot> Monoid a => (((a -> b) -> b) -> (a1 -> a1) -> t) -> t
18:17:24 <shachaf> I think this version has a built-in DList.
18:17:27 <shachaf> Well, DMonoid.
18:20:09 <c-ab> @hoogle join
18:20:09 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
18:20:10 <lambdabot> package join
18:20:10 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
18:20:17 <ski_> CL has `~format', <https://github.com/Hexstream/lispy-format/blob/master/hairiest.lisp>
18:21:06 <jmcarthur> shachaf: woowoo!
18:21:18 <c-ab> @ty flatten
18:21:19 <lambdabot> Tree a -> [a]
18:22:50 <arkeet> @ty Data.Foldable.foldr (:) []
18:22:52 <lambdabot> Foldable t => t a -> [a]
18:22:58 <arkeet> @ty Data.Foldable.toList
18:22:59 <lambdabot> Foldable t => t a -> [a]
18:23:18 <arkeet> @ty toListOf folded
18:23:19 <lambdabot> Foldable f => f b -> [b]
18:24:17 <shachaf> @ty toListOf folded
18:24:19 <lambdabot> Foldable f => f b -> [b]
18:29:26 * M30W ragequit
18:31:32 <shachaf> M30W: That's not how "ragequitting" works...
18:31:35 <shachaf> (You're still here.)
18:31:51 <tgeeky> he's probably not even angry! THIS GUY'S A PHONY! A BIG FAT PHONY!
18:32:44 <c-ab> I failed to use bind here: do {paths <- getDirectoryContents path;return $ response "200 OK" [] (intercalate "<br>" paths)}
18:32:54 <c-ab> something like return $ response "200 OK" [] (intercalate "<br>" =<< getDirectoryContents path)
18:33:00 <c-ab> would be better
18:33:48 <arkeet> fmap (response "200 OK" [] . intercalate "<br>") getDirectoryContents
18:34:06 <c-ab> nice
18:34:15 <M30W> shachaf: My irc user may be. But from my vim. It's gone :)
18:34:20 <c-ab> operate things inside the IO
18:34:26 <shachaf> (Except for the whole (intercalate "<br>") thing...)
18:34:43 <arkeet> do { a <- x; return (f a) } = x >>= return . f = liftM f x = fmap f x
18:36:16 <mgsloan> ("<marquee>"++) . (++"</marquee>") . intercalate "</marquee><marquee>"
18:36:34 <M30W> tgeeky: Not exactly angry, just inriched with rage from debugging to faiure
18:37:25 <arkeet> (>>= ("<marquee>"++) . (++"</marquee>"))
18:37:38 <arkeet> (>>= ("<x>"++) . (++"</x>")) ["a","b"]
18:37:43 <arkeet> > (>>= ("<x>"++) . (++"</x>")) ["a","b"]
18:37:46 <lambdabot>   "<x>a</x><x>b</x>"
18:37:47 <M30W> Wow that still alive?
18:37:53 <tgeeky> M30W: is this like "enriched bread" where you have to add the rage back in, because it was removed due to industrial processing?
18:37:53 <M30W> "marquee"
18:37:54 <mgsloan> arkeet: nice!
18:38:11 <M30W> tgeeky: O.o?
18:38:47 <mgsloan> > ("<x>"++) . (++"</x>") =<< ["a", "b"]
18:38:50 <lambdabot>   "<x>a</x><x>b</x>"
18:39:07 <arkeet> well my first thought was concat . map (...)
18:39:15 <arkeet> but then that's concatMap = (=<<)
18:39:15 <mgsloan> right, of course
18:39:46 <mgsloan> I was mostly just using intercalate for inane html :)
18:40:12 <tgeeky> you sould have been tipped off by the use of "<marquee>"
18:40:32 <arkeet> at least it's not <blink>
18:40:34 <tgeeky> should*
18:40:38 <M30W> > (("<a href=\"" ++) . (++"\">"++) . (++"</a>")) =<< ["a","b"]
18:40:40 <lambdabot>   <hint>:1:32: parse error on input `)'
18:40:44 <M30W> Meh
18:40:47 <mgsloan> oh, should definitely be marquee + blink
18:41:52 <c-ab> :t (intercalate "<br>")
18:41:54 <lambdabot> [[Char]] -> [Char]
18:44:32 <M30W> What broewsers still have marquee???
18:53:45 * M30W 's token generator; not a bad password generator :P
18:54:48 <M30W> Just remember an equation to give a very large number :P
19:01:05 <nolrai_25> Okay what is the "-package" flag for?
19:01:30 <JoeHazzers> is there a named function equivalent to (\x -> x), it's late, so don't blame me
19:01:38 <nolrai_25> id
19:01:47 <nolrai_25> > id 4
19:01:49 <lambdabot>   4
19:02:06 <JoeHazzers> i'll let myself out now
19:02:15 <nolrai_25> No problem.
19:02:27 <nolrai_25> Easy questions make me feel smart.
19:02:39 <shachaf> Another answer is Hoogle.
19:02:41 <shachaf> @where hoogle
19:02:41 <lambdabot> http://haskell.org/hoogle
19:02:45 <shachaf> @type (\x -> x)
19:02:47 <lambdabot> t -> t
19:02:57 <shachaf> Combine ☝ and ☝
19:03:35 <arkeet> @@ @hoogle @type \x -> x
19:03:37 <lambdabot>  Prelude id :: a -> a
19:03:37 <lambdabot> Data.Function id :: a -> a
19:03:37 <lambdabot> GHC.Exts breakpoint :: a -> a
19:04:27 <shachaf> That works, but doesn't help you much unless you already know about lambdabot.
19:04:31 <nolrai_25> So ghc is unable to import Control.Monad.List in one of my src files..but does just fine in another, what is going on?
19:04:52 <arkeet> what does it say?
19:05:07 <shachaf> arkeet: Shh, you're supposed to guess.
19:05:12 <arkeet> oh.
19:05:32 * shachaf has some guesses, but will not give them up until arkeet's question is answered.
19:10:17 <applicative_> nolrai_25: my theory is that the more recent ghc's sense that the monad transformer laws are violated
19:10:48 * tgeeky suggests a trick. shachaf did not specify which question, so tgeeky proposes you ask another, easier question (why is the sky blue? physics) and we'll have him!
19:10:49 <jmcarthur> wat
19:11:15 <arkeet> here's a question.
19:11:23 <arkeet> why is shachaf so horrible? :[
19:11:31 <shachaf> arkeet: :☹(
19:11:33 <tgeeky> a) because he's human
19:11:40 <shachaf> Am I so horrible?
19:12:14 <applicative_> nolrai_25: but what are the other symptoms?
19:12:25 <nolrai_25> arkeet: http://hpaste.org/83377
19:12:36 <arkeet> cool.
19:12:44 <applicative_> mispelled monad
19:12:47 <arkeet> "Could not find module `Control.Moand.List'"
19:13:09 <shachaf> Yes, what applicative_/arkeet/GHC said.
19:13:16 <nolrai_25> >.<
19:13:18 <shachaf> Also: You shouldn't use monads-tf. Use mtl.
19:13:19 <arkeet> what's a moand?
19:13:24 <nolrai_25> Thanks.
19:13:26 <nolrai_25> Why?
19:13:33 <applicative_> class Moand m where rteurn :: a -> m a;
19:13:34 <johnw> a Moanad is what you get after trying to explain what Monads are
19:13:54 <arkeet> *groanad*
19:13:54 * applicative_ thinks this class may suit his typing abilities
19:14:45 <applicative_> yeah, monads-tf is a bit of trouble
19:15:36 <nolrai_25> Why is mtl better then monads-tf?
19:15:36 <applicative_> class Moand m where rteurn :: a -> m a; joni :: m (m a) -> m a; class MoandTrnas ....
19:15:47 <applicative_> well maybe it isnt
19:15:48 <applicative_> it
19:15:58 <applicative_> s just torture having both since module names overlap
19:16:18 <nolrai_25> ahh.
19:16:31 <nolrai_25> Right. I am ignoring that problem for now.
19:16:34 <shachaf> mtl is better because it is standard.
19:16:42 <shachaf> There was a fight, and monads-tf lost.
19:16:45 <JoeHazzers> it's extremely late and i don't understand why (nub . union) is not valid
19:16:49 <JoeHazzers> i should probably go to sleep
19:16:58 <shachaf> @ty (Prelude..)
19:17:00 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:17:01 <shachaf> @ty nub
19:17:03 <lambdabot> Eq a => [a] -> [a]
19:17:04 <shachaf> @ty union
19:17:06 <lambdabot> Eq a => [a] -> [a] -> [a]
19:17:10 <applicative_> I mean, unless you have some good reason, its certainly not worth the trouble
19:17:24 <arkeet> union :: Eq a => [a] -> ([a] -> [a])
19:17:31 <shachaf> JoeHazzers: union takes a list and returns a function. nub takes a list and returns a list.
19:17:34 <shachaf> A function is not a list.
19:17:52 <JoeHazzers> oh of course
19:17:54 <arkeet> :t (nub .) . union
19:17:56 <lambdabot> Eq a => [a] -> [a] -> [a]
19:18:34 <JoeHazzers> arkeet: huh?
19:18:41 <shachaf> arkeet is just being confusing.
19:18:47 <shachaf> You want: \x y -> nub (union x y)
19:19:04 <arkeet> let (f .: g) x y = f (g x y)
19:19:06 <arkeet> nub .: union
19:19:13 <shachaf> You can do that.
19:19:19 <JoeHazzers> was i essentially trying to say nub :: (a -> a) -> a
19:19:19 <JoeHazzers> ?
19:19:23 <shachaf> Or you can just write out the names...
19:19:33 <hpaste> gpeterso pasted “Noob Question” at http://hpaste.org/83378
19:19:38 <shachaf> I have no idea what you were trying to say. But probably not that.
19:19:54 <shachaf> arkeet: I think you should understand what's going on with the unabstracted version fairly well before introducing craziness like (.:)
19:20:05 <arkeet> ok.
19:20:35 <shachaf> gpeterso: foo [x] matches only one thing -- a list with exactly one element
19:21:08 <arkeet> you probably also want head, not init.
19:21:15 <shachaf> You probably means to say "foo xs = " -- square brackets aren't a magic "there's a list involved here somewhere" operator. :-)
19:21:15 <arkeet> you probably also just want to pattern match.
19:21:18 <shachaf> arkeet: No, init.
19:21:26 <arkeet> oh wait.
19:21:27 <arkeet> sure.
19:21:38 * geekosaur thinks that should have been xs, not [xs] which is matching a single character list and extracting the Char (not String) into xs
19:21:42 <arkeet> okay.
19:21:48 <shachaf> gpeterso: Also, "last" and "init" work here, but they're awful functions and you should try to do without them.
19:22:23 <nolrai_25> Is Prompt differnt then Cont?
19:22:30 <shachaf> Awful for all sorts of reasons -- they're inefficient, they crash your entire program if you give them an empty list, they don't match the natural style of operating on linked lists.
19:22:53 <shachaf> "head" and "tail" are also awful.
19:23:07 <gpeterso> @shachaf thx!  Oh yeah.  I already told it the type.  I don't need to tell it again!
19:23:07 <lambdabot> Unknown command, try @list
19:23:08 <shachaf> But at least this implementation does work.
19:23:11 <JoeHazzers> i almost got my head around monads today
19:23:21 <JoeHazzers> i felt like i nearly reached total enlightenment
19:23:23 <shachaf> gpeterso: "[xs]" the pattern isn't telling anything any types.
19:23:26 <nolrai_25> Or am I confusing my self..
19:23:35 <shachaf> It's telling *values*.
19:24:00 <shachaf> Don't confuse the type "[a]" with the value "[a]".
19:24:04 <shachaf> They're very different.
19:24:48 <applicative_> > let gpeterso [mybigvariable] = 1 in (gpeterso [1], gpeterso [1,2])
19:24:50 <lambdabot>   (1,*Exception: <interactive>:3:5-32: Non-exhaustive patterns in function gp...
19:25:08 <JoeHazzers> I'm working with a recursive data structure which *can* branch. Say for example, a data structure representing a mathematical expression.
19:25:55 <JoeHazzers> I'm trying to print this data structure. how would i go about only adding parentheses where necessary, assuming i know in which cases they are needed? (i.e. when something branches)
19:25:58 <applicative_> gpeterso: are we being too obscure, or is it clear?
19:26:23 <JoeHazzers> first up, i'll say that it's assessed work, so don't just plainly tell me :x
19:26:25 <shachaf> JoeHazzers: By doing just that.
19:26:28 <shachaf> What's the question?
19:27:11 <JoeHazzers> is using @ frowned upon?
19:27:16 <gpeterso> @applicative_: I'm good.  schachaf answered my question twice.  Awesome-thanks!
19:27:16 <lambdabot> Unknown command, try @list
19:27:19 <applicative_> no
19:27:36 * hackagebot notmuch-web 0.1.0 - A web interface to the notmuch email indexer  http://hackage.haskell.org/package/notmuch-web-0.1.0 (JohnLenz)
19:27:40 <applicative_> gpeterso: yeah, I saw after I inquired; I had missed a bit
19:28:00 <arkeet> JoeHazzers: you mean to parenthesize correctly given operator precedence and stuff?
19:28:18 <applicative_> the @ is kind of ugly ...
19:28:23 <JoeHazzers> arkeet: yes
19:29:01 <applicative_> JoeHazzers: but this is just for writing the values out handsomely
19:29:01 <arkeet> ok, consider having an extra Int argument or so to your printing function for the precedence level.
19:29:14 <arkeet> derived instances of Show do this with showsPrec.
19:29:31 <JoeHazzers> there is only one specific operator which has higher precedence than others
19:29:45 <shachaf> Oh, you want to deal with precedence.
19:29:50 <JoeHazzers> i'm essentially just trying to match (TypeA (TypeB _ _))
19:29:53 <shachaf> Maybe you can take inspiration from Show in Haskell.
19:30:05 * applicative_ is trying to remember a simple example.  
19:31:02 <glguy> JoeHazzers: they talk about how Show works in http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Show
19:31:12 <glguy> you'd want to implement something like showsPrec
19:31:39 <arkeet> showsPrec kind of does two things at once, though. parenthesization and DList-ification.
19:32:00 <arkeet> (which is why you see . instead of ++)
19:32:23 <JoeHazzers> oh, i think i can deal with this one, but there is a much more complicated situation i can't get my head around
19:32:35 <applicative_> hah glguy has linked it http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/Text-Show.html
19:34:18 <arkeet> so example: say you have data Exp = Lit Int | Plus Exp Exp | Times Exp Exp
19:34:26 <JoeHazzers> uh huh
19:34:35 <arkeet> and we want to print Times (Lit 1) (Plus (Lit 2) (Lit 3)) as "1 * (2 + 3)"
19:34:51 <arkeet> but Plus (Lit 1) (Times (Lit 2) (Lit 3)) as "1 + 2 * 3"
19:35:09 <JoeHazzers> yeah
19:35:15 <arkeet> so the idea is to have an extra argument representing the precedence
19:35:22 <arkeet> so let's say Plus has precedence 1, and Times has precedence 2.
19:35:49 <JoeHazzers> okay
19:36:40 <arkeet> so we might have a function showPrec :: Int -> Exp -> String
19:36:43 <arkeet> where the rule is
19:37:02 <shachaf> data Exp = Lit Int | Op Op Exp Exp; data Op = Plus | Times; fun Plus = (+); fun Times = (*); and then pass around Plus and Times directly!
19:37:15 <arkeet> say if we're doing showPrec d (op x y)
19:37:17 <arkeet> where op is some operator
19:37:29 <arkeet> if op has lower precedence than d, then we parenthesize the whole thing.
19:37:48 <JoeHazzers> and d is the precedence of the parent?
19:37:51 <arkeet> yes.
19:37:52 <jfischoff> can fromRational . toRational loss precision?
19:38:16 <arkeet> but we never parenthesize literals.
19:38:21 <JoeHazzers> so you're essentially passing down the precedence as you go through the stack?
19:38:24 <arkeet> yeah
19:38:32 <JoeHazzers> that's pretty genius
19:38:43 <arkeet> and then at the top level, you pass 0
19:38:51 <arkeet> since you probably never want to parenthesize the whole expression
19:39:05 <shachaf> JoeHazzers: For what type?
19:39:21 <shachaf> Er, jfischoff:
19:39:25 <shachaf> Or are you hoping for numeric "laws" or something crazy like that?
19:39:36 <jfischoff> haha
19:39:56 <arkeet> jfischoff: for Float/Double, it won't.
19:40:01 <jfischoff> cool
19:40:09 <jfischoff> that's was my question specifically
19:40:16 * jfischoff needs to be more specific
19:40:21 <arkeet> since all Float/Double values can be represented by (dyadic) fractions
19:40:30 <arkeet> m * 2^e
19:40:52 <arkeet> (where m and e are integers)
19:41:01 <jfischoff> interesting
19:41:07 <shachaf> > (fromRational . toRational) (0/0)
19:41:10 <lambdabot>   -Infinity
19:41:12 <arkeet> haha.
19:41:16 <arkeet> yes, except the exceptional ones.
19:41:16 <shachaf> Is NaN -> -Infinity "precision"?
19:41:30 <arkeet> well, -Infinity is indeed Not a Number
19:41:40 <arkeet> so it's gaining precision.
19:41:51 <tac> Silly engineers
19:41:55 <tac> And their NaN values...
19:42:20 <shachaf> Most of my values are not numbers.
19:42:23 <shachaf> Numbers = the devil
19:42:54 <arkeet> is that strict equality or just isomorphism?
19:43:20 <shachaf> Isomorphism, naturally.
19:43:28 <arkeet> I hate you.
19:43:38 <shachaf> I think the devil is unique up to unique isomorphism.
19:43:39 <arkeet> =[
19:43:48 <shachaf> Why does arkeet hate me?
19:44:02 <tac> isomorphism, naturally? Or natural isomorphism?
19:44:14 <arkeet> shachaf = the devil, up to unique isomorphism.
19:44:33 <shachaf> How do you catch a unique isomorphism?
19:44:38 <arkeet> no.
19:44:46 <shachaf> Unique up on it!
19:44:46 <arkeet> don't do this.
19:44:47 <arkeet> :(
19:44:57 <shachaf> How do you catch the same (up to unique isomorphism) isomorphism?
19:45:03 <shachaf> Hmm.
19:45:08 <shachaf> I messed it up.
19:45:09 <arkeet> I thought it went "tame".
19:45:10 <shachaf> Oh well.
19:45:18 <shachaf> I blame arkeet for distracting me.
19:45:25 <shachaf> h8rkeet
19:45:55 <arkeet> now I'm thinking about tame knots.
19:46:01 <hpaste> applicative pasted “showsPrec Exp” at http://hpaste.org/83379
19:46:13 <arkeet> I thought he didn't want a full solution.
19:47:24 <applicative_> hm
19:47:31 <arkeet> or even a Show instance, I guess.
19:47:43 * applicative_ cant remember reading "I hate you." on #haskell
19:49:58 <applicative_> showsPrec is too hard to think about; I prefer 'deriving Show'
19:50:19 <arkeet> absolutely.
19:50:26 <arkeet> but it's good to know how it works.
19:50:52 <arkeet> clearly we should just use prefix or postfix notation.
19:51:02 <mm_freak> which GHC version introduced InstanceSigs?
19:51:13 <arkeet> we need a table of these.
19:51:35 <shachaf> @google InstanceSigs ghc release notes
19:51:37 <lambdabot> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/release-7-6-1.html
19:51:37 <lambdabot> Title: 1.5.�Release notes for version 7.6.1
19:51:41 <shachaf> Looks like it's 7.6
19:52:01 <arkeet> does it actually gain us anything?
19:52:13 <shachaf> Maybe type variable scoping?
19:52:31 <shachaf> Also, it helps you write the function.
19:52:52 <arkeet> it does.
19:55:12 <AfC> Does Cabal run cpp over the .cabal file?
19:55:18 <arkeet> no
19:55:47 <arkeet> or if it did, that would be news to me.
19:59:53 <applicative_> AfC the syntax of .cabal files isn't alarming enough already?
20:00:18 <JoeHazzers> arkeet: thank you so much for that help earlier!
20:00:23 <arkeet> np
20:01:00 <nolrai_25> :t runCont
20:01:01 <lambdabot> Cont r a -> (a -> r) -> r
20:01:14 <nolrai_25> @ty runCont
20:01:15 <lambdabot> Cont r a -> (a -> r) -> r
20:01:50 <applicative_> @unmtl ContT r IO a
20:01:50 <lambdabot> (a -> IO r) -> IO r
20:02:02 <nolrai_25> errrr..gahh. so its like backwards prompt?
20:02:14 <applicative_> it's certainly backwards
20:02:19 <mm_freak> shachaf: thanks
20:02:34 <TravisD> Is the version of the typeclassopedia from issue 13 of the monad reader up to date? I'd like to read it on my tablet as a PDF
20:03:12 <nolrai_25> Bahh, I will just write a tf frendly version of Prompt its not hard and I understand how it works.
20:04:05 <shachaf> You should use mtl.
20:04:23 <shachaf> It is standard, and it is less verbose.
20:04:34 <nolrai_25> I thought I understood Cont but no..
20:04:36 <applicative_> TravisD: I think there was a giant plan to update it but nothing has yet emerged
20:04:56 <TravisD> applicative_: So it would be better to read the wiki version?
20:04:59 <applicative_> TravisD: you can ask byorgey who is frequently around here
20:05:08 <nolrai_25> Okay okay is type families just thought to not be useful?
20:05:55 * applicative_ isn't familiar with the wiki version; he dimly remembered byorgey wanting to maintain editorship so to say
20:06:17 <applicative_> ah indeed
20:06:24 <geekosaur> they're undergoing revision because of a number of shortcomings
20:07:07 <TravisD> applicative_: Thanks :) I may just read the TMR version
20:09:53 <ab9rf> i am increasingly unfond of wikis
20:14:42 * applicative_ notes that the wiki-ized typeclassopedia page says • This page has been accessed 60,310 times.
20:15:28 <ab9rf> applicative_: how many times by googlebot? :)
20:18:23 <applicative_> ab9rf: hm ok
20:20:33 <TravisD> It looks like there have been some major changes to the wiki version, so maybe I should actually read that
20:21:17 <ZWolf> How do you have a type definition to '0' '1' '2' '3' '4' 'a' 'b' 'c' ... (/0-9a-zA-Z/)
20:21:58 <applicative_> TravisD: yeah I was wondering.  It awfully I ugly I was trying to get it back into latex just now...
20:22:20 <geekosaur> ZWolf, not easily because that is a dependent type
20:23:10 <TravisD> applicative_: Ah, were you trying to convert the wiki to latex?
20:23:31 <applicative_> yeah just seeing how much trouble pandoc would have
20:23:40 <ZWolf> geekosaur: Example?
20:23:49 <TravisD> neat, I didn't know you could do that
20:24:16 <geekosaur> I have none on tap; it's a bit more advanced type hackery than I normally deal with
20:25:00 <geekosaur> if your needs are simple enough you can get away with a smart constructor (don't expose the actual constructor, use a function which constructs values and ensures they're valid)
20:25:13 <geekosaur> although for it to be safe you'd need a newtype
20:25:51 <geekosaur> so you wouldn't be able to simply use e.g. '0' as a value, you'd have to use the smart constructor and the result would have a constructor protecting the actual value
20:26:39 <shachaf> What is the problem here, and what does it have to do with dependent types?
20:26:59 <geekosaur> [02 23:21] <ZWolf> How do you have a type definition to '0' '1' '2' '3' '4' 'a' 'b' 'c' ... (/0-9a-zA-Z/)
20:27:20 <shachaf> I saw that sentence. But I don't understand it.
20:27:35 <shachaf> The puzzle is to have a type with 36 inhabitants?
20:27:36 <applicative_> TravisD: it can also make e.g. epub but I don't know about those formats
20:27:52 <geekosaur> he wants a subrange type, which is a simple dependent type, yes
20:28:13 <shachaf> Why is it dependent?
20:28:18 <geekosaur> ZWolf, you might want to look at the references in http://www.haskell.org/haskellwiki/Dependent_type#Dependent_types_in_Haskell_programming
20:28:55 <geekosaur> because its validity is dependent on the actual value, and there are values which fall outside the range of the type
20:29:37 <geekosaur> it's a simple dependent type, but still dependent because the exact value matters to determine whether it inhabits the type or not
20:30:04 <shachaf> Whose validity?
20:30:23 <ab9rf> well, that answers a question
20:30:24 <geekosaur> wat
20:30:30 <shachaf> I don't think I understand.
20:30:35 <geekosaur> evidently not
20:30:44 <geekosaur> (the exact value) ... (it)
20:30:52 <ab9rf> i was wondering if there was a way to have two types share some of their constructors, and had concluded that that wasn't really possible
20:31:39 <geekosaur> it's not like this has not been discussed in #haskell before, even within the past week, and confirmed to be a dependent type by folks rather better versed in it than I am, but whatever
20:32:02 * shachaf sighs.
20:32:07 <shachaf> I am not attacking you, geekosaur.
20:32:39 <geekosaur> no, you're just being frustrating
20:32:53 <shachaf> I don't understand why this is dependent.
20:33:00 <shachaf> "dependent type" means you have something whose type depends on the value of another thing, doesn't it?
20:33:08 <ab9rf> ZWolf: if i understand what you're doing, it's similar to something i ws trying to do and determined isn't possible
20:33:19 <ab9rf> you can't make a type that is a subset of another type
20:33:59 <ab9rf> that is, an algebraic type whose set of constructors is a subset of the set of constructors of another type
20:34:12 <ZWolf> :(
20:34:13 <ab9rf> each type has its own constructors exclusive to itself
20:34:28 <shachaf> Haskell does not have subtyping, if that's what you mean. I don't think it's exactly what you mean, but it's close enough.
20:35:19 <ab9rf> shachaf: it really can't, not with the type system it has
20:35:44 <shachaf> geekosaur: For example: You can make the type data T = A | B | C | ..., with thirty-six values.
20:36:07 <shachaf> Doesn't that type satisfy the requirement (other than "not being awkward")?
20:38:13 <geekosaur> shachaf, it's any time a type depends on a value. in this case, a subtype of Char is dependent on the exact Char value being considered
20:39:12 <geekosaur> yes, you can define an ADT with the constructors and some mapping functions to convert Char from/to your type instead, but that's a workaround
20:39:19 <shachaf> What?
20:39:29 <shachaf> Well, whatever.
20:40:03 <geekosaur> "yes, you can <what you suggested a few minutes ago>"
20:40:13 <geekosaur> [02 23:35] <shachaf> geekosaur: For example: You can make the type data T = A | B | C | ..., with thirty-six values.
20:40:28 <geekosaur> that type is not dependent, but it's also not using the Char "constructors"
20:40:50 <ab9rf> in haskell a value has exactly one type
20:40:57 <ab9rf> and there are no "subtypes" or "supertypes"
20:41:12 <ab9rf> there are classes but classes are not types
20:41:22 <byorgey> TravisD: the version on the wiki is now the official version.  I have made a number of updates.
20:41:28 <shachaf> Subtyping seems to me to be completely unrelated to dependent types.
20:41:49 <TravisD> byorgey: Thanks! (both for the comment and for the excellent article)
20:41:56 <shachaf> Do you mean that you can have a type like: ((c:Char), Proof (c `elem` "0123..."))?
20:42:36 <byorgey> TravisD: my rationale for the move is here: http://byorgey.wordpress.com/2011/11/26/typeclassopedia-v2-moving-my-efforts-to-the-haskell-wiki/
20:42:57 <ab9rf> shachaf: not following you
20:43:49 <byorgey> TravisD: glad you find it helpful!
20:50:22 <applicative_> ah byorgey is here
20:56:22 <glguy> geekosaur: dependent types come up in the example you are talking about when you encode them as the dependent sums where the second component component is a proof that the first component is in some subset
20:56:51 <glguy> Σ (c : Char) (IsLowercase c)
20:57:13 <glguy> but the dependent type part of that is that particular encoding, not because its a subset
20:57:17 * shachaf is annoyed at how people use the word "sum" here and there.
20:57:35 <shachaf> (A normal "product" is a dependent "sum", and all that.)
20:58:05 <glguy> Well, I'm not influential enough to make up my own terminology and have it adopted :-p
20:58:11 <shachaf> Sure.
20:59:28 <shachaf> Anyway, the type Σ (c : Char) (IsDigit c) is isomorphic to data C = C0 | C1 | ..., and to Either Bool (Bool,Bool,Bool), and so on.
20:59:45 <shachaf> It seems to me that that there's nothing fundamentally dependent going on here.
21:00:54 <glguy> Σ-types are fundamentally dependent types, the type of the second component depends on the value of the first
21:01:20 <glguy> so I probably just misunderstood what you were saying
21:03:01 <shachaf> I mean that there isn't anything particularly dependent about the type "character which is `elem` "012345689""
21:03:12 <shachaf> Because you know the inhabitants at compiletime.
21:03:32 <glguy> I see. using a dependent type is just one way to implement such a thing
21:03:52 <glguy> Your point is that it's not fundamental to the notion of a subset
21:03:55 <glguy> ?
21:04:34 <shachaf> Something like that.
21:05:19 <shachaf> When someone asks "how do I make a type for characters that are 0-9a-zA-Z", saying "you need dependent types" doesn't really make sense to me.
21:09:50 <byorgey> It's like when someone asks how to get to the post office and you say "you need a hovercraft".
21:10:19 <byorgey> (because it's too far to walk!)
21:10:48 <geekosaur> ok, won't bother saying why it can't be done directly, just that it can't
21:12:13 <crdueck> #j agda
21:12:15 <glguy> In Haskell you just make a newtype, hide the constructor, and pretend it only contains the subset you wanted
21:12:47 <shachaf> That is another way.
21:14:03 <fragamus> hey has anyone played with minecraft in haskell?
21:16:51 <ab9rf> fragamus: how would that work?
21:17:09 <ab9rf> byorgey: i've always wanted a hovercraft.
21:20:22 <TravisD> fragamus, ab9rf: It would be neat if there was some way to automate things in minecraft using Haskell. Similar mods exist for Lua, I think
21:22:49 <ab9rf> TravisD: haskell is generally not the best choice for an imbedded scripting language
21:23:22 <ab9rf> the runtime is very heavy
21:23:48 <TravisD> Ah. Too bad - that would make for quite a few fun exercises
21:23:59 <ab9rf> i've threatened to write a dfhack plugin in haskell, just to be irritating
21:23:59 <shachaf> Heavy how?
21:31:28 <hpaste> autmaz pasted “bjk-fb” at http://hpaste.org/83380
21:50:25 <Hrumph> pull requested for conduit submitted
21:50:36 <Hrumph>   https://github.com/snoyberg/conduit/pull/89
22:54:59 <JoeHazzers> what's a clean way of doing (Just x) (Just y) = Just (f x y), (Just x) (Nothing) = Just x, (Nothing) (Just x) = Just x
22:55:06 <JoeHazzers> or is that it?
22:55:20 <shachaf> That looks like an error.
22:55:29 <shachaf> I guess you meant "f " in front of each equation?
22:55:45 <shachaf> You can use mplus (or (<|>) from Control.Applicative).
22:56:08 <shachaf> (Please do write the "f ", though. :-) )
22:56:14 <JoeHazzers> >.>
22:56:39 <JoeHazzers> shachaf: could you use it in an example
22:58:04 <shachaf> Can you complete your example first?
22:58:10 <JoeHazzers> sure
22:58:18 <JoeHazzers> let me just give some stuff a go
22:58:22 <shachaf> Oh, wait.
22:58:23 <shachaf> I misread it.
22:58:27 <shachaf> Never mind.
22:58:28 <liyang> > f <$> (Just x <|> Just y)
22:58:31 <lambdabot>   Ambiguous type variable `b0' in the constraints:
22:58:31 <lambdabot>    (GHC.Show.Show b0)
22:58:31 <lambdabot>     ...
22:59:11 <shachaf> What do you do with Nothing and Nothing?
22:59:37 <croikle> got to make Nothing, I'd think
22:59:40 <JoeHazzers> ^
22:59:43 <shachaf> Who knows?
22:59:45 <shachaf> Maybe it's z
23:00:07 <shachaf> There are lots of options when we don't know what's in scope.
23:00:11 <shachaf> @ty let foo f (Just x) (Just y) = Just (f x y); foo f (Just x) Nothing= Just x; foo f Nothing (Just y) = Just y; foo f Nothing Nothing = Nothing in foo
23:00:13 <lambdabot> (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a
23:00:34 <arkeet> not quite liftA2.
23:00:46 <shachaf> OK, that's a weird function. I doubt there's anything more straightforward than writing it out.
23:00:59 <arkeet> well, foo mappend = mappend with that.
23:01:03 <arkeet> if you have a Monoid.
23:02:01 <shachaf> I suspect we're answering the wrong question (well, actually there's no question at all).
23:02:18 <JoeHazzers> i might as well just say what i'm trying to do, only to find out i've been going at it in entirely the wrong way
23:02:29 <JoeHazzers> after I really work it out, anyway
23:05:51 <JoeHazzers> really, I just want to go about simplifying logical expressions, but I just want a pointer on the issue as to what I should research
23:10:49 <arkeet> JoeHazzers: what is the f that you want to use this with?
23:11:13 <JoeHazzers> arkeet: it doesn't matter, I've worked out that I wasn't approaching the problem properly
23:11:22 <arkeet> oh ok :p
23:29:45 <portnov1> hi all
23:37:01 <notdan> Hi
23:47:41 * hackagebot persistent-refs 0.3 - Haskell references backed by an IntMap for persistence and reversibility.  http://hackage.haskell.org/package/persistent-refs-0.3 (AdamFoltzer)
23:47:43 * hackagebot cuda 0.5.0.1 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.5.0.1 (TrevorMcDonell)
23:57:41 * hackagebot persistent-sqlite 1.1.5 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-1.1.5 (MichaelSnoyman)
