00:04:18 * hackagebot poker-eval 0.2.1 - Binding to libpoker-eval  http://hackage.haskell.org/package/poker-eval-0.2.1 (DavidHimmelstrup)
00:04:20 * hackagebot ghc-mod 1.12.0 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.12.0 (KazuYamamoto)
00:05:16 <supki> samm: older Glade, I'm not sure about acceptable libglade versions
00:06:27 <supki> glade package .cabal says  pkgconfig-depends: libglade-2.0 >= 2.0.0
00:08:16 <samm> thanks. hopefully I can get libglade working
00:11:23 <kennyd> Gtk has replaced libglade with gtkbuilder. if you use GtkBuilder (you need Gtk 2.12+) you don't need to install libglade or any additional C libraries
00:11:48 <kennyd> see http://reflectionsonprogramming.com/2012/02/hello-world-haskell-gtk/
00:19:39 <samm> oh wow, I spent over an hour trying to install libglade and that worked out of the box.
01:05:59 <beaky> hello
01:14:24 * hackagebot test-framework-skip 1.0 - Functions for conveniently marking some of the tests in a suite as being skipped.  http://hackage.haskell.org/package/test-framework-skip-1.0 (GregoryCrosswhite)
01:33:23 <nilg> hi, what the st part means in "csvFile :: CharParser st [[String]]"? thx
01:33:57 <shachaf> It's a type variable.
01:34:13 <nilg> because it's in lower case?
01:34:23 <shachaf> Yes.
01:34:27 <nilg> cool thx
01:35:06 <shachaf> Probably it stands for "state".
01:35:46 <nilg> frankly I don't understand that type signature, it doesn't return anything, so I guess it "changes" the state?
01:36:01 <shachaf> It's not a function so it can't return anything.
01:36:04 <mauke> what do you mean, it doesn't return anything?
01:36:21 <nilg> see http://hackage.haskell.org/packages/archive/MissingH/latest/doc/html/Data-CSV.html
01:36:29 <mauke> it's a parser for a list of list of strings that doesn't change the state
01:36:30 <nilg> it says "The return value is a list of lines"
01:37:18 <nilg> oh, I guess I see "CharParser st [[String]]" is the type of what is returned, right?
01:38:16 <nilg> no I get it!!! CharParse is a type construct that takes 2 types st and [[String]], right?
01:38:40 <mauke> yes
01:38:58 <nilg> (it's my second program in Haskell...)
01:39:34 <mauke> fun :-)
01:39:40 <nilg> at the end I guess CharParser is a monad
01:39:40 <mauke> do you know any other programming languages?
01:39:55 <mauke> (technically, 'CharParser st' is the monad)
01:40:21 <nilg> mauke: I know C/C++, Python and other stuff
01:41:01 <nilg> so 'CharParser st' is a monad, that takes as argument the type '[[String]]', right?
01:42:13 <mauke> yes
01:44:01 <nilg> OK I sorta got the basics, but I'm till missing something
01:44:11 <nilg> They give the example
01:44:17 <nilg> To parse a file, you might instead use:
01:44:18 <nilg>  
01:44:18 <nilg> do result <- parseFromFile csvFile "/path/to/file"
01:44:18 <nilg>  
01:44:52 <nilg> but how to parse stdin?
01:45:53 <bartavelle> use "parse"
01:46:46 <nilg> bartavelle: you mean 'do result <- parse csvFile' ?
01:47:03 <mauke> do result <- runParser csvFile () "(stdin)" <$> getContents
01:47:58 <nilg> omg, sorry could you explain that line, the () and <$> bit?
01:48:17 <mauke> () is ()
01:48:19 <mauke> <$> is fmap
01:48:20 <bartavelle> ah sorry, I was thinking of attoparsec, not parsec
01:48:27 <shachaf> @djinn (forall p. p Char -> p Bool) -> Void -- /me sighs
01:48:28 <lambdabot> Cannot parse command
01:48:53 <bartavelle> that might be a stupid question, but what is Void ?
01:49:32 <shachaf> An empty type.
01:49:34 <shachaf> data Void
01:49:53 <bartavelle> does @djinn infer this ?
01:50:07 <shachaf> What is the purpose of prefixing a question with "that might be a stupid question"?
01:50:22 <bartavelle> you could answer "this is a stupid question"
01:50:26 <bartavelle> then I would think more about it
01:50:28 <shachaf> Is it a way of saying "please explain to me how I might have figured out the answer to this by myself"?
01:50:28 <nilg> ok, I won't bother you too much thanks to hoogle
01:50:32 <bartavelle> and find the answer by myself
01:50:44 <shachaf> Hmm.
01:50:45 <bartavelle> something like that
01:50:57 <mauke> http://hackage.haskell.org/packages/archive/parsec/3.1.3/doc/html/Text-ParserCombinators-Parsec-Prim.html#v:runParser
01:50:57 <shachaf> Anyway, Djinn knows about Void.
01:51:05 <nilg> use this http://www.haskell.org/hoogle/ to avoid asking stupid question there ;-)
01:51:14 <mauke> csvFile is the GenParser
01:51:20 <mauke> () is the state
01:51:21 <shachaf> Void isn't the point anyway. I want foo :: (forall p. p Char -> p Bool) -> a
01:51:27 <mauke> "(stdin)" is the SourceName
01:51:48 <mauke> and then we need a list of chars as input, which we have to read from stdin
01:51:51 <mauke> :t getContents
01:51:52 <lambdabot> IO String
01:52:00 <mauke> :t (<$>)
01:52:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:52:18 <mauke> we use <$> to lift the partially applied runParser call to IO
01:52:58 <mauke> runParser csvFile () "(stdin)" :: [Char] -> Either ParseError [[String]]
01:53:21 <mauke> (runParser csvFile () "(stdin)" <$>) :: IO [Char] -> IO Either ParseError [[String]]
01:53:29 <mauke> (runParser csvFile () "(stdin)" <$>) :: IO [Char] -> IO (Either ParseError [[String]])
01:55:48 <mauke> http://www.riddlydiddly.com/
02:01:28 <nilg> I've got 3 runParser http://www.haskell.org/hoogle/?hoogle=runParser , why? what is the standard one?
02:01:44 <shachaf> Look to the left.
02:01:56 <shachaf> Oh, you mean three in Parsec.
02:02:25 <shachaf> Of those three, only two are in Parsec.
02:02:31 <shachaf> One of them is in a "compatibility module".
02:02:46 <nilg> parsec is the standard?
02:03:54 <shachaf> Standard compared to what?
02:04:19 <shachaf> Look at all the options there. I suspect only one is relevant to what you're doing.
02:04:23 <nilg> standard = what most people do
02:04:26 <shachaf> But shouldn't you already know which module you're using?
02:05:05 <nilg> no, I'm just trying to implement mauke suggestion 'do result <- runParser csvFile () "(stdin)" <$> getContents'
02:06:25 <shachaf> You brought up parseFromFile
02:06:28 <shachaf> Where is that from?
02:07:00 <nilg> shachaf: from that example http://hackage.haskell.org/packages/archive/MissingH/latest/doc/html/Data-CSV.html
02:07:45 <shachaf> Oh.
02:07:54 <shachaf> MissingH :-(
02:07:57 <shachaf> Anyway, click on CharParser there.
02:08:03 <shachaf> Look at what module it brings you to.
02:08:09 <shachaf> s/module/package/
02:08:12 <shachaf> Look for runParser inside that package.
02:10:16 <quchen> What does the suffix "FB" stand for in the (non-exported) Data.List functions? It's used when list functions are parameterized over (:), i.e. map works on cons lists, and mapFB works on "c" lists.
02:10:31 <shachaf> Probably foldr/build?
02:10:43 * shachaf looks
02:11:06 <shachaf> Yes, looks like it's foldr/build.
02:11:07 <quchen> Fusion/build maybe
02:11:13 <shachaf> ?
02:11:17 <shachaf> This is called foldr/build fusion.
02:11:40 <quchen> Oh. Well then I'll go with foldr/build. :-)
02:12:04 <quchen> I thought fold/build was just a special case of fusion (namely fusion using build).
02:12:22 <shachaf> There are lots of different kinds of fusion.
02:12:32 <shachaf> But generally if you're using build you'll be using foldr.
02:12:59 <shachaf> @ty \l -> build (\f z -> foldr f z l)
02:13:01 <lambdabot>     Not in scope: `build'
02:13:01 <lambdabot>     Perhaps you meant one of these:
02:13:01 <lambdabot>       build' (line 1), `buildG' (imported from Data.Graph)
02:13:33 <shachaf> @let build :: (forall b. (a -> b -> b) -> b -> b) -> [a]; build k = k (:) []
02:13:34 <lambdabot>   TypeOperators is not enabled
02:13:48 <shachaf> ?
02:14:06 <shachaf> @ty let build :: (forall b. (a -> b -> b) -> b -> b) -> [a]; build k = k (:) [] in build
02:14:08 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
02:14:15 <shachaf> Ugh.
02:14:18 <quchen> It worked yesterday after someone got the same error.
02:14:19 <shachaf> lambdabot is such a mess.
02:14:23 <shachaf> @ty build
02:14:24 <quchen> Not sure what the fix was though
02:14:25 <lambdabot>     Not in scope: `build'
02:14:25 <lambdabot>     Perhaps you meant one of these:
02:14:25 <lambdabot>       build' (line 1), `buildG' (imported from Data.Graph)
02:14:31 <shachaf> I bet it's unfixable.
02:14:34 <quchen> @ty GHC.Exts.build
02:14:35 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
02:14:40 <shachaf> Good enough.
02:14:49 <shachaf> @ty \l -> GHC.Exts.build (\f z -> foldr f z l)
02:14:51 <lambdabot> [a] -> [a]
02:14:55 <nilg> back to the basics, what is wrong with my code?
02:14:56 <nilg> parseTSV :: IO [[String]]
02:14:56 <nilg> parseTSV = do
02:14:59 <nilg>   line <- getLine
02:14:59 <nilg>   [[line]]
02:15:02 <nilg>  
02:15:08 <nilg> there is an error on [[line]]
02:15:13 <quchen> So all the list consumers are RULEd to folds I assume so fusion has a common interface?
02:16:01 <shachaf> I don't know what you mean.
02:16:10 <shachaf> nilg: Indeed.
02:16:25 <mauke> nilg: missing 'return'
02:16:26 <quchen> shachaf: Doesn't matter really. Thanks for the help
02:16:40 <shachaf> quchen: ?
02:16:50 <shachaf> quchen: It's important that you understand foldr to understand build.
02:16:55 <quchen> Oh I thought you meant me
02:16:55 <nilg> mauke: thx (I start to conceptually get it I think)
02:17:30 <shachaf> I did mean you.
02:17:49 <quchen> Oh.
02:18:02 <Saizan> quchen: yes, all the consumers are rewritten into folds so that the foldr f z (build g) = g f z rule can apply
02:18:19 <Saizan> well, by "all" i mean "some" really
02:18:20 <quchen> ^ That's what I meant. Good. :-)
02:18:46 <quchen> "map" [~1] forall f xs. map f xs = build (\c n -> foldr (mapFB c f) n xs)
02:18:52 <quchen> etc.
02:18:55 <Saizan> they are sometimes called "good consumer"
02:20:07 <arkeet> :t build . ((flip.) . flip $ foldr)
02:20:09 <lambdabot>     Not in scope: `build'
02:20:09 <lambdabot>     Perhaps you meant one of these:
02:20:09 <lambdabot>       build' (line 1), `buildG' (imported from Data.Graph)
02:20:12 <arkeet> :t GHC.Exts.build . ((flip.) . flip $ foldr)
02:20:14 <lambdabot>     Couldn't match expected type `forall b. (a0 -> b -> b) -> b -> b'
02:20:14 <lambdabot>                 with actual type `[a1] -> (a1 -> c0 -> c0) -> c0'
02:20:14 <lambdabot>     Expected type: c0 -> forall b. (a0 -> b -> b) -> b -> b
02:20:17 <arkeet> aw
02:20:24 <arkeet> oh right
02:20:47 <shachaf> That @pled code clears things right up!
02:21:12 <shachaf> @ty (\f z g -> foldr f z (build g))
02:21:14 <lambdabot>     Not in scope: `build'
02:21:14 <lambdabot>     Perhaps you meant one of these:
02:21:14 <lambdabot>       build' (line 1), `buildG' (imported from Data.Graph)
02:21:18 <shachaf> @ty (\f z g -> foldr f z (GHC.Exts.build g))
02:21:20 <lambdabot>     Couldn't match type `t' with `(a -> b1 -> b1) -> b1 -> b1'
02:21:20 <lambdabot>       `t' is a rigid type variable bound by
02:21:20 <lambdabot>           the inferred type of it :: (a -> b -> b) -> b -> t -> b
02:21:26 <shachaf> @ty (\f z g -> foldr f z (GHC.Exts.build g)) :: (a -> b -> b) -> b -> (forall c. (a -> c -> c) -> c -> c) -> b
02:21:27 <lambdabot> (a -> b -> b) -> b -> (forall c. (a -> c -> c) -> c -> c) -> b
02:21:31 <shachaf> Is that the right type?
02:21:44 <arkeet> no
02:21:49 <arkeet> ?
02:21:53 <arkeet> I dunno
02:22:12 <shachaf> @ty (\g f z -> foldr f z (GHC.Exts.build g)) :: (forall c. (a -> c -> c) -> c -> c) -> (forall b. (a -> b -> b) -> b -> b)
02:22:14 <lambdabot> (forall c. (a -> c -> c) -> c -> c) -> (a -> b -> b) -> b -> b
02:22:59 <shachaf> arkeet: You should answer my question about (forall p. p Char -> p Bool)!
02:23:07 <arkeet> what's the question?
02:23:30 <shachaf> If you have Haskell + RankNTypes + a primitive of that type, and no GADTs/TypeFamilies, can you write Void?
02:23:41 <shachaf> Without any of the normal ‚ä• tricks, of course.
02:24:10 <arkeet> what do you mean, write Void?
02:24:27 <shachaf> Can you write (forall p. p Char -> p Bool) -> Void, I mean
02:24:31 <arkeet> oh
02:25:01 <shachaf> It is seeming like you cannot.
02:25:06 <arkeet> why no GADTs?
02:25:20 <shachaf> The real question is: What's a minimal thing to add to RankNTypes in order to be able to do that?
02:25:29 <shachaf> Because GADTs give you more power than RankNTypes and I want to know why.
02:27:44 <Saizan> the type theory way to get Void out of subst uses a "type family"
02:28:05 <arkeet> I don't know any type theory.
02:28:31 <shachaf> Saizan: Also not allowed. :-)
02:28:48 <shachaf> TypeFamilies is kind of a huge extension.
02:29:07 <arkeet> is "type family" different from *type family*?
02:29:09 <Saizan> \(eq : true = false) -> subst (\b -> if b then Unit else Void) eq ()
02:29:28 <Saizan> it's just a function Bool -> Set here
02:29:42 <Saizan> nothing weird like pattern matching on types :P
02:30:39 <arkeet> dependent types is probably also cheating.
02:31:04 <Saizan> yeah, i just wanted to provide it for context
02:34:37 * hackagebot cabal2nix 1.45 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.45 (PeterSimons)
02:36:31 <Rogach> Q: Why "modify" in State monad has return type of "m ()", instead of "m a"?
02:36:42 <arkeet> what would a be?
02:36:55 <Rogach> For example, the following gives me error: (return [] >> modify ("!"++):: State [Int] String)
02:37:08 <arkeet> indeed.
02:37:20 <quchen> Rogach: modify modifies only the state, not the value held by the monad.
02:37:30 <arkeet> modify ("!") has type State [Char] ()
02:37:33 <arkeet> er
02:37:35 <arkeet> ("!"++)
02:37:46 <Rogach> quchen: But what if I want to modify the state and keep the value?
02:38:03 <arkeet> :t state (\x -> (x,x))
02:38:05 <lambdabot> MonadState a m => m a
02:38:11 <arkeet> hm
02:38:16 <arkeet> that's get.
02:38:21 <arkeet> Rogach: you can just get after.
02:38:24 <arkeet> or before. as the case may be.
02:38:29 <quchen> Rogach: Bind it to a variable before?
02:39:52 <Rogach> mapState (mapSnd ("!" ++)) $ return [] -- this works, but seems ugly.
02:40:14 <nilg> Sorry but I don't understand what is wrong with
02:40:15 <nilg> parseTSV :: IO [[String]]
02:40:15 <nilg> parseTSV = do
02:40:15 <nilg>   line <- getLine
02:40:18 <nilg>   case line of
02:40:21 <nilg>     [] -> return []
02:40:23 <quchen> > (`runState` "") $ return 1 >>= \n -> put "hello" >> modify (++ "!") >> return n
02:40:23 <nilg>     _ -> return ([splitOn "\t" line] ++ parseTSV)
02:40:25 <lambdabot>   (1,"hello!")
02:40:26 <nilg>  
02:40:28 <quchen> nilg: use hpaste please.
02:40:31 <quchen> @where hpaste
02:40:32 <lambdabot> http://hpaste.org/
02:40:39 <Saizan> Rogach: use liftM or fmap
02:41:25 <shachaf> If only there was a better way to say "return x >>= f"
02:41:52 <Saizan> ah, no, that'd be with mapFst
02:42:14 <nilg> http://hpaste.org/83492 (seems to work here, hmmm...)
02:42:21 <quchen> shachaf: if you want a bindy pipeline there is none. Yes I know the monad laws. That wasn't production code.
02:42:26 <Saizan> ?ty (<*)
02:42:28 <lambdabot> Applicative f => f a -> f b -> f a
02:42:51 <Saizan> Rogach: ^^^
02:43:05 <arkeet> nilg: parseTSV has type IO [[String]], which is not a list.
02:43:08 <arkeet> so line 6 has a type error
02:43:10 <shachaf> nilg: That code couldn't type-check because parseTSV isn't a list.
02:43:42 <shachaf> "the value held by the monad" :-(
02:43:54 <shachaf> I cause people too much anguish in here.
02:44:04 <Rogach> Saizan: How should I use it?
02:44:15 <nilg> shachaf: of course!!!
02:44:17 <nilg> thx
02:44:37 <arkeet> Rogach: return x >>= f  =  f x
02:44:53 <arkeet> (this is one of the monad laws)
02:45:12 <Saizan> > (`runState` "") $ return 1 <* modify ("!"++)
02:45:14 <lambdabot>   (1,"!")
02:45:24 <Saizan> Rogach: ^^^
02:45:51 <andrewhn> Hi, haskell newbie here. Hoping someone can help me write a time string to a file. Essentially like this: Prelude Data.Time> appendFile "testfile" getCurrentTime , but I'm having trouble getting the IO UTCTime into something I can use. Thanks
02:46:12 <arkeet> andrewhn: the easiest thing is show :: UTCTime -> String
02:46:23 <ivanm> @hoogle getCurrentTime
02:46:24 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
02:46:24 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
02:46:24 <shachaf> andrewhn: getCurrentTime isn't a value that holds a time at all.
02:46:35 <shachaf> It's a program that you can run to get the current time.
02:46:36 <arkeet> do {time <- getCurrentTime; do stuff with (show time :: String)}
02:46:42 <shachaf> So the first step would be do do that.
02:46:43 <ivanm> andrewhn: do { theTIme <- getCurrentTime; appendFile "testfile" (show theTime) }
02:46:44 <arkeet> it's show time.
02:46:52 <ivanm> arkeet: why the explicit type sig?
02:46:53 <ivanm> and heh
02:47:02 <arkeet> ivanm: because I was making its type clear
02:47:04 <arkeet> for the reader
02:47:29 <andrewhn> @ivanm so it has to be within the IO monad, because the type is IO UTCTime?
02:47:29 <lambdabot> Unknown command, try @list
02:47:33 <ivanm> @remember arkeet <arkeet> do {time <- getCurrentTime; do stuff with (show time :: String)} <arkeet> it's show time.
02:47:34 <lambdabot> It is stored.
02:47:39 <arkeet> oh dear.
02:47:51 <shachaf> <arkeet> :(
02:48:07 <arkeet> ... where stuff with x = appendFile "testfile" x
02:48:12 <nilg> and what is wrong with that? http://hpaste.org/83495
02:48:16 <arkeet> , and with = something else
02:48:25 <shachaf> nilg: Why don't you paste the type error with your code?
02:48:35 <shachaf> That way people can actually help you, rather than guess.
02:49:21 <arkeet> also
02:49:21 <nilg> good idea, thx http://hpaste.org/83496
02:49:24 <arkeet> last line parses as
02:49:30 <arkeet> (return splitOn) "\t" ...
02:49:39 <arkeet> splitOn is not a thing you want to return.
02:50:09 <andrewhn> arkeet, shachaf, ivanm: thanks
02:50:26 <Rogach> Saizan: Thanks!
02:50:49 <shachaf> andrewhn: You should read an introduction to IO.
02:51:04 <shachaf> I'm not sure what you mean by "within the IO monad" but it might well be a misconception of some kind.
02:51:14 <arkeet> andrewhn:  one could shorten it to getCurrentTime >>= appendFile "testfile" . show, but that may be less readable
02:51:31 <nilg> is 'return' a function defined in the Haskell lib, or a keyword? (sorry for my stupid questions I've ordered the book Learn Haskell a Great good)
02:51:40 <shachaf> It is a function.
02:51:41 <arkeet> return is a function.
02:51:48 <nilg> wow
02:51:56 <nilg> what it's type???
02:51:59 <shachaf> It has nothing to do with "return" the keyword you're used to.
02:52:00 <arkeet> :t return
02:52:00 <quchen> :t return
02:52:01 <lambdabot> Monad m => a -> m a
02:52:02 <lambdabot> Monad m => a -> m a
02:52:12 <shachaf> So don't be impressed. It doesn't "return".
02:52:25 <arkeet> > return 5 :: [Int]
02:52:27 <lambdabot>   [5]
02:52:37 <arkeet> > return 5 :: Either () Int
02:52:39 <lambdabot>   Right 5
02:52:55 <arkeet> > return 5 :: (String,Int)
02:52:57 <lambdabot>   No instance for (GHC.Base.Monad ((,) GHC.Base.String))
02:52:57 <lambdabot>    arising from a us...
02:53:00 <arkeet> ???
02:53:08 <shachaf> arkeet: That instance does not exist it.
02:53:11 <shachaf> s/ it//
02:53:17 <arkeet> where does it it exist?
02:53:30 <shachaf> In your dreams.
02:53:58 <quchen> And in Writer.
02:54:05 <shachaf> No, that's a different instance.
02:54:15 <hpaste> Rogach pasted ‚Äúgraph to tree‚Äù at http://hpaste.org/83497
02:54:24 <arkeet> > return 5 :: Writer String Int
02:54:26 <lambdabot>   No instance for (GHC.Show.Show
02:54:26 <lambdabot>                     (Control.Monad.Trans.Wri...
02:54:28 <arkeet> =(
02:54:37 <Rogach> Is there a way to improve this code - http://hpaste.org/83497 ?
02:54:39 <arkeet> > runWriter (return 5 :: Writer String Int)
02:54:41 <lambdabot>   (5,"")
02:54:54 <shachaf> Notice how it's backwards.
02:55:02 <arkeet> gross.
02:55:24 <shachaf> It's that way just to spite you.
02:55:32 <arkeet> it offends me as a mathematician.
02:55:37 <quchen> Same for State :x
02:55:59 <crl> @kind [[]]
02:56:01 <lambdabot>     Expecting one more argument to `[]'
02:56:01 <lambdabot>     In a type in a GHCi command: [[]]
02:56:03 <shachaf> arkeet: As a mathematician you should accept the Functor (_,w)
02:56:14 <arkeet> why are you always right.
02:56:17 <arkeet> and horrible.
02:56:38 <nilg> see that http://hpaste.org/83498 with a question about syntax sweeteners
02:56:40 <shachaf> Why are my puns always fun?
02:56:40 <craigInnes> Hi, I am trying to learn to do things in parallel in haskell. I have one thread which will periodically write things to a file and one which will read things from the same file. How can I ensure that one thread does not read while the other is writing? (Is it possible to guarantee just with simple MVars?)
02:56:55 <arkeet> (that's concurrency, not parallelism.)
02:56:56 <shachaf> craigInnes: That sounds like concurrency, not parallelism!
02:57:09 <craigInnes> shachaf: sorry, slip of the tongue, you are correct
02:57:20 <shachaf> Anyway, everything is possible with just an MVar.
02:57:26 <shachaf> But might not be optimal.
02:57:40 <shachaf> You can use an MVar as a lock on the file, if nothing else.
02:57:45 <arkeet> nilg: _ -> fmap (splitOn "\t" line :) parseTSV
02:57:46 <arkeet> :)
02:58:07 <shachaf> arkeet: (s
02:58:14 <arkeet> g:
02:58:16 <nilg> oh, it all falls in place :-)
03:01:08 <feliperosa> good morning :)
03:03:55 <Vertue> Question about HXT...
03:04:19 <Vertue> I am parsing some poorly formed xml
03:04:41 <Vertue> it has the structure <serial XXXX>
03:05:11 <Vertue> <data blah blah> more studd <\data>
03:05:16 <nilg> guys, if I read Learn You a Haskell for Great Good! will I understand all these monad things, and all haskell type system in depth, or is it the wrong book? should I just go through the documentation, what think?
03:05:23 <Vertue> and so forth
03:05:34 <Vertue> and then the next serial
03:05:36 <arkeet> nilg: it is not the wrong book. but no one book is sufficient.
03:05:42 <arkeet> read a variety. experiment yourself.
03:05:52 <arkeet> LYAH is a good first book.
03:05:56 <Vertue> problem is that data is not contained in the serial blocks
03:05:59 <nilg> arkeet: OK, I just need something to start with, sounds good
03:06:16 <Vertue> so somehow HXT has to keep the serial to insert into the following blocks
03:06:19 <feliperosa> nilg: I agree with arkeet, you should read it. But you should experiment too
03:06:44 <Vertue> any way of keeping state like that inside a parser?
03:06:46 <nilg> I've writen 2 programs in Haskell so far and I feel I miss the basics ;-)
03:08:17 <feliperosa> Vertue: I'm not familiar with HXT, I'll have a look and try to help you
03:08:31 <henriavelabarbe> hi, need advice with parsec
03:08:59 <henriavelabarbe> I'm writing a sql 92 parser
03:09:05 <gofs> New hack tools Cryptography, Encryption,Hack,windows,linux,games,cs,psybnc,mirc,scan,ssh , etc.. feel free to visit www.team3d.3xforum.ro
03:09:29 <feliperosa> Vertue: Which version of HXT are you using?
03:09:40 <quchen> (Is there a law spammers have to be unable to write proper sentences?)
03:10:23 <tdammers> quchen: no, it's implicit
03:10:26 <arkeet> that spammer is a disgrace to .ro domain owners.
03:10:39 <tdammers> a consequence of political and technical constraints
03:10:47 <henriavelabarbe> I would like to keep the term and factors in a numeric expression.
03:11:04 <arkeet> > 1 + (2 * 3) :: Expr
03:11:06 <lambdabot>   1 + 2 * 3
03:11:43 <henriavelabarbe> I don't want to evaluate them durng parsind using the expr builder
03:12:04 <arkeet> you could write a data type to represent an expression tree.
03:12:15 <arkeet> and then have your parser result in that type.
03:12:28 <arkeet> I should probably wait for the question.
03:13:03 <henriavelabarbe> In fact I use a lot if datatypes generated from the sql 92 bnf, and I want to stick to that as long as I can
03:14:04 <henriavelabarbe> <numeric value expression> ::=  -                <term>  -        |   <numeric value expression> <plus sign> <term>  -        |   <numeric value expression> <minus sign> <term>
03:14:22 <henriavelabarbe> it is represented like that
03:15:25 <henriavelabarbe> and the associated datatype created
03:15:27 <henriavelabarbe> data NumericValueExpression = NumericValueTerm Term         | NumericValuePlus Sign Term         | NumericValueMinus Sign Term         deriving (Show, Read, Eq)
03:18:13 <henriavelabarbe> I'm an haskell noob and I don't see how I could use a function to build the numeric value expression from parsec expression buider
03:18:30 <henriavelabarbe> or via chainl
03:20:57 <hpaste> feliperosa pasted ‚ÄúMemoization‚Äù at http://hpaste.org/83500
03:21:08 <feliperosa> could someone explain me that?
03:21:41 <shachaf> What is the trouble?
03:21:46 <mauke> what do you mean by "memoize"?
03:22:36 <feliperosa> Well one seems to recompute 'len' for element in the list created, while the other does not
03:23:02 <mauke> makes sense
03:23:10 <feliperosa> shachaf: I posted 2 functions on hpaste, I'm trying to understand memoization.
03:23:15 <feliperosa> mauke: Why?
03:23:28 <feliperosa> (because it makes no sense for me, hehe)
03:23:32 <ivanm> feliperosa: any particular reason you need/want memoisation?
03:23:44 <shachaf> There is no memoization here.
03:23:46 <ivanm> though realistically, if you're calculating the length of a list repeatedly, you're doing it wrong
03:23:51 <shachaf> ivanm: Understanding sharing is a noble cause.
03:23:59 <ivanm> shachaf: I suppose
03:24:10 <shachaf> By noble cause I mean you should understand why len is shared in one example but not the other.
03:24:27 <ivanm> yeah, that's what I figured you meant
03:24:39 <feliperosa> ivanm: Well, no particular reason. Only because I'm too curious
03:24:39 <quicksilver> feliperosa: because your second case calls rec_ and 'len' goes out of scope.
03:24:53 <quicksilver> feliperosa: your first case stays inside the scope of len.
03:25:01 <hpaste> m pasted ‚Äúanother detective story of cabal failure‚Äù at http://hpaste.org/83501
03:25:03 <epta> Need some help with solving another detective story of why `cabal install' failed. My cabal project depends on darcs, cabal picked up 2.8.4; darcs-2.8.4 depends on regex-compat ‚â•0.95.1, cabal picked up 0.95.1; regex-compat-0.95.1 is installed with regex-posix-0.95.2. And then CONTAINERS SEMIGROUPS, hard to understand where conflict is came from
03:25:15 <ivanm> quicksilver: I would have thought that as it's a constant of the function it wouldn't need to be re-computed every time
03:25:21 <ivanm> though that might depend on optimisation flags
03:25:32 <ivanm> epta: build log?
03:25:32 <quicksilver> yes, it might have been lifted out. But it wasn't.
03:25:39 <quicksilver> understanding optimisation is hard :)
03:25:48 <nicoo> > (\f -> f+1) :: Expr
03:25:50 <lambdabot>   The lambda expression `\ f -> f GHC.Num.+ 1' has one argument,
03:25:51 <lambdabot>  but its typ...
03:25:53 <quicksilver> did feliperosa compile it or interpret it? what flags?
03:26:06 <nicoo> > f+1 :: Expr
03:26:08 <feliperosa> quicksilver: Just loaded it on GHCi
03:26:09 <lambdabot>   f + 1
03:26:12 <nicoo> :)
03:26:26 <epta> ivanm: http://hpaste.org/83501
03:26:34 <quicksilver> well that answers ivanm's question; ghci doesn't do optimisations like that.
03:26:40 <quicksilver> feliperosa: do you understand my naive answer?
03:26:59 <dcoutts> epta: can you try with --max-backjumps=-1
03:27:12 <ivanm> maybe also with --verbose
03:27:39 <ivanm> dcoutts: btw, thanks for the suggestion of using the dep of ghc to find the shipped version of Cabal; the exherbo guys didn't really like the approach but they accepted it :p
03:28:04 <crl> > (\f -> f+1) :: (Int -> Int)
03:28:06 <dcoutts> ivanm: or they can just look it up :-)
03:28:06 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.Int -> GHC.Types.Int))
03:28:06 <lambdabot>    arising...
03:29:07 <epta> ivanm: --verbose produce the same log
03:29:09 <feliperosa> quicksilver: I think so. In the first function len is part of rec and I do the recursion on rec', which stays inside the same rec (read scope) as len. So once computed it can be read again 'for free' later
03:29:28 <epta> dcoutts: how much time should it take? :]
03:29:39 * hackagebot string-conversions 0.3 - Simplifies dealing with different types for strings  http://hackage.haskell.org/package/string-conversions-0.3 (SoenkeHahn)
03:29:41 <dcoutts> epta: a bit longer
03:29:43 <adas> I wrote a haskell binding to a 'C' delay Function. The C function takes and argument and delays for that many milliseconds. I called the C function from haskell. Should there by any reason why the delay does not happen?
03:29:44 <quicksilver> yes, scope is the most naive way to view it, but it's a good first intuition.
03:29:44 <ivanm> dcoutts: want it done automagically rather than hard-coding it (they didn't even want to have a version bump to 1.16.0.2, only finally accepted it because cabal-install has that bug with 1.16.0)
03:29:51 <epta> dcoutts: -1 sounds like +Inf
03:29:54 <feliperosa> @src replicate
03:29:54 <lambdabot> replicate n x = take n (repeat x)
03:29:56 <quicksilver> each new recursive call is logically a new 'len' (even though they have the same value)
03:29:57 <dcoutts> epta: yes
03:30:37 <feliperosa> @src repeat
03:30:37 <lambdabot> repeat x = xs where xs = x : xs
03:32:05 <dcoutts> epta: I suggest that because the error says that the installed versions of semigroups and regex-posix need conflicting versions of semigroups, but that doesn't tell us that there's no solution if we were to rebuild some packages from source
03:32:10 <feliperosa> quicksilver: Hum... right. Even if the function is tail recursive?
03:32:15 <ivanm> dcoutts: didn't help when there's some weird escaping or something going on when the flags are passed to runhaskell Setup.hs and it kept splitting --constraint="Cabal == ${shipped_version}" on whitespace (in the end I realised it accepted it without quotes)
03:32:27 <Vertue> feliperosa: the latest one
03:32:52 <epta> \> semigroups and regex-posix need conflicting versions of semigroups
03:32:54 <crl> :t sin
03:32:55 <epta> dcoutts: are you sure?
03:32:55 <lambdabot> Floating a => a -> a
03:33:04 <quicksilver> feliperosa: sure. that's not relevant to scope.
03:33:08 <dcoutts> epta: that's what the error says
03:33:25 <quicksilver> feliperosa: it *might* be a different value each time through recursion (if it depended on changing parameters)
03:33:36 <quicksilver> feliperosa: so, that's why it's logically different.
03:33:41 <dcoutts> epta: but that's only the installed instances, if they were to be rebuilt from source then it could be anything that satisfies the source constraints
03:33:59 <feliperosa> quicksilver: Right. So that I'm doing is not actually memoization, right?
03:34:01 <ivanm> epta: when dcoutts says he's sure that's how cabal-install works, then trust him :p
03:34:03 <quicksilver> In practice, if it doesn't reference other local variables it is a natural optimisation to lift it out - GHC -O will do that, I believe.
03:34:11 <quicksilver> and if it gets lifted out it is shared between all calls.
03:34:16 <dcoutts> epta: look at the text: semigroups => containers==0.5.0.0/installed-461..., regex-posix => containers==0.5.2.1/installed-ddd...
03:34:26 <quicksilver> feliperosa: memoization refers specifically to functions, as far as I know, and 'len' is not a function.
03:35:07 <dcoutts> epta: though one also has to notice that it's the existing installed instances of semigroups and regex-posix that it's referring to there
03:35:08 <epta> dcoutts: but containers do not depends on semigroups
03:35:31 <dcoutts> epta: no, semigroups depends on containers
03:36:55 <epta> dcoutts: does it mean that I have two installed versions of containers? (containers==0.5.0.0/installed-461,  containers==0.5.2.1/installed-ddd)
03:37:03 <dcoutts> epta: yes
03:37:24 <epta> Dunno that it's possible :[
03:37:46 <dcoutts> epta: so the solver has not terminated?
03:37:57 <epta> dcoutts: ok, I kinda understand why it fails
03:37:57 <dcoutts> when you ran it with --max-backjumps=-1 ?
03:38:03 <dcoutts> epta: well I don't
03:38:18 <hpaste> riaan pasted ‚Äúxml sample‚Äù at http://hpaste.org/83502
03:38:25 <dcoutts> epta: just because of that conflict with installed packages doesn't mean there's no solution
03:38:35 <epta> dcoutts: Resolving dependencies...
03:38:36 <dcoutts> it would just involve rebuilding some things
03:38:53 <Vertue> I pasted and example of the XML I am trying to parse with the output I am trying to get to
03:38:57 <dcoutts> epta: if you get bored, you can try running it with the --reorder-dependencies flag
03:39:10 <dcoutts> epta: sorry, --reorder-goals
03:39:11 <epta> Never got bored with cabal
03:39:16 <dcoutts> hah
03:39:56 <epta> Is there some rational timeout?
03:40:06 <dcoutts> your boredom threshold
03:40:14 <dcoutts> epta: to be honest, I've never seen it run this long
03:40:21 * dcoutts is rather surprised
03:40:32 <Vertue> The problem is trying to get the serial into the records as it is not part of the hierarchy
03:40:38 <epta> dcoutts: http://hpaste.org/83503
03:40:41 <epta> It's done
03:42:32 <adas> A delay function in C, called from haskell does not "delay" even though I believe the function is being called. Is there possible reason why the delay does not happen?
03:43:10 <shachaf> Yes, there is possible reason.
03:43:24 <Kinnison> It may be being run in a different thread, or it may not be being run at all
03:43:59 <adas> Kinnison: ah. thats what i thought too..
03:44:16 <adas> do you think its possible to know for sure?
03:44:42 <Kinnison> since it's in C and thus not bound by purity rules, have it open a log file and write out when it was called and what thread it was in?
03:44:46 <epta> Cabal acts here rally unproductive :
03:45:03 <feliperosa> Vertue: I don't understand, you want to take that serial record out?
03:45:50 <Vertue> feliperosa: the serial number should be associated with all the data that follows it
03:46:03 <feliperosa> quicksilver: Are you familiar with the memoized fibonacci from the wiki? Would it be too much work to try to explain it to me, please?
03:46:22 <dcoutts> epta: ok, so it means it's tried everything, but for the error, it's showing us the first one again, because that's the simpler error
03:46:30 <adas> thanks.. ill try it out
03:46:33 * ivanm is surprised at all the ... in the output, even with --verbose
03:46:58 <quicksilver> feliperosa: (1) store the results of the function in a list (2) use a new function which fetches answers from the list instead of calculating them
03:46:59 <Vertue> feliperosa: there could be 100 data blocks and will be parsed to a record in haskell but I need the serial in each of the records
03:47:08 <quicksilver> feliperosa: it's not magic. That's how you'd do it in any language :)
03:47:17 <epta> dcoutts: m, --reorder-goals reject template-haskell instead of regex-posix http://hpaste.org/83506
03:47:35 <quicksilver> feliperosa: the only clever bit is that lazy evaluation gives you a simple way to calculate the answers the first time they are needed.
03:48:26 <feliperosa> quicksilver: Oh yeah, My dificulty is not doing memoization it self, but what makes haskell memoize a function. Like, I get what they're doing there, but why does that work??
03:48:35 <dcoutts> epta: so there must really be a conflict here, but it's not telling us about the conflict between source packages, just the existing installed instances
03:48:37 <quicksilver> feliperosa: nothing.
03:48:48 <quicksilver> feliperosa: nothing makes haskell memoize a funciton. There is no feature, and no compilation trick.
03:48:49 <Hafydd> adas: I have to ask... why are you trying to call a C delay function from Haskell?
03:48:55 <dcoutts> epta: you can start by getting rid of the multiple versions of containers
03:49:02 <quicksilver> feliperosa: if you want to do it, you have to do it explicitly just like you would in another language.
03:49:12 <epta> dcoutts: I don't wanna solve this problem actually
03:49:54 <epta> It's interesting to get what packages are conflicting
03:51:34 <dcoutts> epta: though we don't really know which are conflicting, we just know the installed instances are, not what source packages conflict
03:51:56 <adas> Hafydd: im writing haskell binding for the 'C' wirinPi library for RasperryPi. I've got all the other functions from that library working. The delay func in that library befeddles me..
03:52:18 <adas> just wanted to access the GPIO pins on the pi using haskell. - )
03:52:19 <Hafydd> adas: do you understand that Haskell is a pure functional language?
03:52:58 <adas> yea.  i do. and the bindings i've made reflect that
03:53:10 <Hafydd> Alright, just checking.
03:54:49 <epta> dcoutts: sad story
03:56:41 <dcoutts> epta: you can try --constraint='semigroups source' --constraint='free source' --constraint='regex-posix source' --constraint='regex-compat source' --constraint='containers==0.5.0.0'
03:58:32 <epta> dcoutts: http://hpaste.org/83508
03:59:07 <dcoutts> epta: ahh, is biegunka-core your thing?
04:00:37 <epta> dcoutts: supki's
04:01:22 <feliperosa> Is there anyway I can see the reduction steps Haskell makes while evaluating an expression?
04:01:26 <epta> dcoutts: or what do your mean by `your thing'?
04:01:32 <dcoutts> epta: so this may be the root of the issue, the solver may need to rebuild biegunka-core against some different version of some dependency, but it doesn't know how to do that because the solver only has access to the installed version, not the source version of that package, and so it's forced to pick whatever installed instances the existing biegunka-core is built against, and that leads to the conflict in the installed instances.
04:02:12 <dcoutts> epta: so the solution may simply be to let the solver rebuild that package, do something like: cabal install --dry-run ./biegunka-core/ ./biegunka-darcs/
04:02:55 <epta> dcoutts: so I could tell cabal to build two cabal files?
04:03:25 <dcoutts> epta: yes, in general it's best to let the solver see everything that you want to build, all at once. It can pick better that way.
04:04:04 <epta> dcoutts: yep, now cabal tell about possibility to solve it with --force-reinstalls
04:04:11 <dcoutts> woo!
04:04:16 <epta> Ok, good to know
04:04:21 <epta> Thanks
04:04:34 <dcoutts> epta: check those reinstalls look sensible to you, you may want to force it to pick the older containers rather than the newer
04:05:57 <epta> Downgrade containers is actually what it wanna do
04:05:58 <epta> regex-base-0.93.2 (reinstall) changes: containers-0.5.2.1 -> 0.5.0.0
04:05:58 <epta> regex-posix-0.95.2 (reinstall) changes: containers-0.5.2.1 -> 0.5.0.0
04:06:05 <dcoutts> ok, that's probably good
04:06:41 <Wizek> Can I run runghc or runhaskell with -XNoMonomorphismRestriction somehow ?
04:06:48 <Wizek> it seems to ignore the flag
04:09:23 <MasseR> Wizek: Is it feasible to add {-# Language NoMonomorphismRestriction #-} pramga
04:11:44 <Wizek> MasseR: That's exactly what I need! Thanks!
04:12:06 <MasseR> I think that's even the preferred method nowadays :)
04:18:49 <robstewartuk> bah, when haskell code has inline sentences, and the code indented with "> ", how do I run with ghci, again?
04:20:52 <ivanm> robstewartuk: save it to a .lhs file?
04:20:52 <Hafydd> robstewartuk, is the file's extension "lhs"?
04:21:10 <robstewartuk> that's it :-)
04:21:41 <robstewartuk> thanks1
04:21:42 <robstewartuk> !
04:32:22 <crl> is modifyMVar blocking?
04:32:41 <Breadmonster> How do I learn Haskell?
04:32:50 <shachaf> @where faq
04:32:50 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
04:32:55 <shachaf> Breadmonster: ‚òù has some recommendations.
04:32:58 <crl> take and putMVar are blocking so far
04:33:02 <shachaf> @src modifyMVar
04:33:03 <lambdabot> modifyMVar m io = block $ do
04:33:04 <lambdabot>     a      <- takeMVar m
04:33:06 <lambdabot>     (a',b) <- Exception.catch (unblock (io a)) (\e -> do putMVar m a; throw e)
04:33:08 <lambdabot>     putMVar m a'
04:33:10 <lambdabot>     return b
04:33:15 <shachaf> crl: Now you know!
04:33:19 <crl> oh indeed
04:33:28 <shachaf> Also I think the documentation specifies the MVar behavior pretty well.
04:33:49 <shachaf> There is pretty much only one way to do things with MVars, and it involves blocking.
04:34:09 <crl> I'd like to store a list in the MVar
04:34:32 <crl> and remove/add items along time
04:35:58 <crl> I think i've seen a way to do it with a newMVar []   and a newEmptyMVar as a semaphore
04:36:16 <crl> but i'm not sure the semaphore is really necessary
04:37:54 <crl> such things like modifyMVar_ mvList (return . (item:))
04:41:31 <crl> I think the semaphore was used as a way to observe modifications in the list
04:43:05 <crl> there's a thread trying to take on it, each time something happen other threads put on it, then the mvList is processed
04:44:40 * hackagebot shelly 0.15.4.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.15.4.1 (GregWeber)
04:48:10 <Taneb> It occurs to me I have no idea who Oleg actually is
04:48:30 <yogsototh> Just a newbie question, I downloaded the Hakyll source code from github and I want to compile my local executable using this code. I tried to use "ghc -i dir/to/hakyll/src/Hakyll" and it complains it couldn't find a module but I can see it in the source code of Hakyll
04:49:22 <arkeet> yogsototh: you should use cabal to build it.
04:49:23 <shachaf> Probably you should use Cabal?
04:49:49 <yogsototh> shachaf: no I want to have the source version because the cabal one isn't up to date.
04:49:55 <yogsototh> yet.
04:50:06 <shachaf> Not Hackage.
04:50:07 <shachaf> Cabal.
04:50:19 <Taneb> yogsototh, navigate to the directory and say "cabal install"
04:50:21 <shachaf> You'll notice a file called hakyll.cabal
04:50:26 <shachaf> Taneb: Not install!
04:50:30 <shachaf> Well, unless you actually want to install it.
04:50:35 <shachaf> In which case you can install it.
04:51:04 <Hafydd> Hello, SHODAN.
04:51:07 <yogsototh> shachaf: ah thanks! How didn't I thought about it.
04:51:14 <yogsototh> Taneb: thanks!
04:56:55 <hpaste> henriavelabarbe pasted ‚ÄúparsecChainl1‚Äù at http://hpaste.org/83509
04:57:09 <shachaf> Taneb: "Oleg" is Portuguese for "Oleg".
05:00:16 <henriavelabarbe> got it working using my type definition, is there a better way without changing the type?
05:02:17 <SHODAN> Hafydd: yes, hello
05:08:11 <crl> @set split2 x = splitAt ((length x) `div` 2) x
05:08:13 <lambdabot>  Defined.
05:09:09 <shachaf> length :-(
05:10:54 <quchen> shachaf: I wonder what the best way of writing it without length would be.
05:11:17 <quchen> Recursively split and re-merge?
05:11:22 <shachaf> quchen: Probably a thing that goes through the list twice.
05:11:24 <shachaf> Sort of life
05:11:28 <shachaf> s/f/k/
05:11:30 <shachaf> @where sneaky
05:11:31 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
05:11:36 <shachaf> Well, OK, not really like that.
05:11:42 <shachaf> Er, by "twice" I don't mean "in two passes".
05:13:04 <companion_cube> you maye be able to do it in a non-tailcall fashion, returning a difference list
05:13:10 <quchen> That dropFromEnd function is fancy.
05:13:29 <shachaf> Yes, it certainly shouldn't be tail-recursive.
05:13:38 <crl> shachaf: hehe is length a so heavy operation?
05:13:39 <shachaf> As soon as you've seen two elements you know you can yield one.
05:13:58 <shachaf> crl: Well, it's a bad operation for lists.
05:14:16 <quchen> crl: Using length is generally regarded as giving up.
05:14:20 <crl> yes you could splitin2 by recursing from srart and end of the list
05:14:31 <shachaf> It's not about "giving up"...
05:14:32 <quchen> crl: You can't start at the end.
05:14:39 <crl> reverse
05:14:53 <liyang> Starting at the end seems a contradiction in terms.
05:15:05 <shachaf> liyang: Only for nonempty things.
05:15:16 <crl> then take head .. and when you find an already seen element from the other way, then you split
05:15:30 <crl> wait I'll make it
05:15:31 <liyang> shachaf: I always speak with the utmost generality.
05:15:46 <shachaf> liyang: It isn't always a contradiction, though.
05:15:55 <davidthomas> take2 without length seems worthwhile, split2 less so - as soon as you force any part of the second half you need to have seen the end of the list anyway
05:15:58 <shachaf> If I say "I started at the end", that just means I was doing an empty thing.
05:16:17 <liyang> *pfft* Fine.
05:16:28 <shachaf> davidthomas: It's still worthwhile.
05:16:52 <shachaf> Doing a thing in two passes can have all sorts of impact on whether it can be GCed and what not, if nothing else.
05:18:04 <shachaf> Hmm, writing split2 is actually a bit trickier than it sounds.
05:18:14 <davidthomas> well, you'll keep the same O() memory usage, but i suppose cutting it in half could be meaningful sometimes
05:18:43 <shachaf> Will you?
05:18:53 <shachaf> Using length means you force the whole original list before you've done anything.
05:18:58 <crl> split2 x = split2' x (reverse x) , .... split2' x:xs y:ys =  ..
05:18:59 <davidthomas> right
05:19:13 <crl> if reverse is not too costly
05:19:23 <shachaf> (liyang will be quick to point out that you've done it after *something*)
05:19:23 <quchen> crl: About as costly as length.
05:19:28 <davidthomas> and you have to force the second half of the list before you have done anything to the tail
05:19:28 <crl> a crap
05:19:44 <crl> quchen: so it's not worth like that?
05:19:49 <shachaf> davidthomas: What if I consume first the first half, then the second half?
05:19:58 <shachaf> Well -- it depends on what you do.
05:20:01 <davidthomas> O(f(n)/2) = O(n)
05:20:01 <quchen> crl: It doesn't solve the problem I think
05:20:04 <davidthomas> err
05:20:08 <shachaf> I might not consume the whole list at all.
05:20:12 <davidthomas> = O(f(n))
05:20:40 <shachaf> Yes, I know how O(f(n)/2) works.
05:21:07 <shachaf> There's still an asymptotic improvement if I look at part of the first half and then decide to forget about it, if nothing else.
05:21:22 <davidthomas> right, yes
05:21:38 <shachaf> And, I mean, why would you use length?
05:21:39 <quchen> shachaf: Splitting without traversing the entire list? Isn't a finite list you haven't traversed indistinguishable from an infinite list (which has no split2)?
05:21:53 <shachaf> quchen: An infinite list can have split2
05:22:05 <quchen> Oh right, it's the list itself I guess
05:22:11 <shachaf> split2 xs = (xs,‚ä•) when xs is infinite
05:22:20 <shachaf> Unless you use length.
05:24:42 <quchen> What about a zipper-like attempt? You traverse the list, and put the first element on the "left" stack, the second one on the "right" stack. In the next step, if there's a third element, shift the "right" stack onto the "left" stack, and put element #3 on the now empty "right" stack.
05:25:09 <dmwit> > let halfsies (x:_:xs) = x:halfsies xs; halfsies _ = []; end (_:xs) (_:ys) = end xs ys; end xs [] = xs; split2 xs = let h = halfsies xs in (zipWith const xs h, end xs h) in split2 [1..]
05:25:11 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
05:25:30 <dmwit> > let halfsies (x:_:xs) = x:halfsies xs; halfsies _ = []; end (_:xs) (_:ys) = end xs ys; end xs [] = xs; split2 xs = let h = halfsies xs in (zipWith const xs h, end xs h) in split2 [1..10]
05:25:32 <lambdabot>   ([1,2,3,4,5],[6,7,8,9,10])
05:25:32 <neutrino_> quchen: that does not converge for infinite lists either.
05:25:35 <shachaf> dmwit++
05:26:11 <crl> :t end
05:26:12 <lambdabot>     Not in scope: `end'
05:26:12 <lambdabot>     Perhaps you meant one of these:
05:26:12 <lambdabot>       `snd' (imported from Data.Tuple), `and' (imported from Data.List),
05:26:32 <crl> nice
05:26:39 <dmwit> > let split2' (x:y:xs) = let (b,e) = split2' xs in (x:b, y:e); split2' xs = (xs, []) in split2' [1..]
05:26:41 <lambdabot>   ([1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,...
05:26:44 <dmwit> > let split2' (x:y:xs) = let (b,e) = split2' xs in (x:b, y:e); split2' xs = (xs, []) in split2' [1..10]
05:26:46 <lambdabot>   ([1,3,5,7,9],[2,4,6,8,10])
05:26:56 <Wizek> What's the easiest way to execute a system command in haskell (like ls) and get back it's output?
05:26:58 <arkeet> > let split2' (x:y:xs) = let (b,e) = split2' xs in (x:b, y:e); split2' xs = (xs, []) in split2' [1..9]
05:27:00 <lambdabot>   ([1,3,5,7,9],[2,4,6,8])
05:27:07 <shachaf> Wizek: System.Process
05:27:19 <quchen> Wizek: http://hackage.haskell.org/packages/archive/process/latest/doc/html/System-Process.html#v:system
05:27:29 <neutrino_> hey guys, is there something for haskell like 4clojure? i.e. a list of short exercises, increasing in difficulty, with a js interpreter form to submit answers?
05:27:46 <dmwit> tryhaskell.org, maybe
05:28:17 * crl trying to reindent dmwit 's code
05:28:47 <neutrino_> dmwit: tryhaskell doesn't have a list of problems..
05:29:03 <dmwit> I thought it had a tutorial, which was essentially a list of problems.
05:29:33 <dmwit> There's also a translation of the 99 Lisp problems into Haskell on the wiki, though no check that you got them right, I guess.
05:29:41 * hackagebot marxup 1.0.2 - Markup language preprocessor for Haskell  http://hackage.haskell.org/package/marxup-1.0.2 (JeanPhilippeBernardy)
05:29:53 <neutrino_> hmm, there's a tutorial indeed
05:30:17 <neutrino_> dmwit: 4clojure is nice because it has so much built up around solving problems
05:30:48 <neutrino_> you can look at what solutions others came up with, and also follow people to always see their solutions
05:32:59 <crl> what's the interest of zipWith const??
05:33:21 <popx_> @djinn (a,b) -> (b,a)
05:33:22 <lambdabot> f (a, b) = (b, a)
05:33:33 <dmwit> crl: It's like end, but beginning instead.
05:33:36 <arkeet> crl: cuts the first list to the length of the second.
05:33:57 <crl> ok
05:34:00 <arkeet> > zipWith const [1,2,3,4,5] [6,7,8]
05:34:02 <lambdabot>   [1,2,3]
05:34:16 <shachaf> dmwit: Oh, split2' isn
05:34:20 <shachaf> 't split2 at all!
05:34:23 * shachaf feels cheater.
05:34:26 <shachaf> cheated
05:34:33 <dmwit> It's a different way to split, yes.
05:34:39 <dmwit> That's why I gave it a prime!
05:36:47 <shachaf> > let half [] = []; half [x] = []; half (x:y:xs) = x:half xs; splitL [] l = ([], l); splitL _ [] = ([],[]); splitL (_:ns) (x:xs) = (x:a,b) where (a,b) = splitL ns xs; split2 xs = splitL (half xs) xs in split2 "hello"
05:36:52 <lambdabot>   mueval-core: Time limit exceeded
05:36:55 <shachaf> I wonder if that's the same as dmwit's solution.
05:37:44 <shachaf> Mine is just a straight port of splitAt (length xs `div` 2) xs using lazy naturals.
05:37:59 <shachaf> I think they're not quite the same but the same general idea.
05:38:04 <crl> :t splitL
05:38:07 <lambdabot>     Not in scope: `splitL'
05:38:07 <lambdabot>     Perhaps you meant one of these:
05:38:07 <lambdabot>       `split2' (line 6), `split' (imported from System.Random),
05:38:39 <crl> nvm
05:39:05 <shachaf> splitL :: [unit] -> [a] -> ([a],[a])
05:40:55 <crl> > let half [] = []; half [x] = []; half (x:y:xs) = x:half xs in half "abcde"
05:40:57 <lambdabot>   "ac"
05:41:17 <shachaf> You can change which side the leftover element goes on by changing the half [x] case.
05:41:31 <crl> well that's not this split
05:41:40 <shachaf> ?
05:41:44 <crl> wait
05:42:11 <arkeet> :t chunksOf
05:42:13 <lambdabot> Int -> [e] -> [[e]]
05:42:17 <arkeet> :t transpose . chunksOf 2 $ [1..10]
05:42:19 <lambdabot> (Enum a, Num a) => [[a]]
05:42:20 <arkeet> transpose . chunksOf 2 $ [1..10]
05:42:26 <arkeet> > transpose . chunksOf 2 $ [1..10]
05:42:30 <lambdabot>   [[1,3,5,7,9],[2,4,6,8,10]]
05:43:07 <arkeet> > transpose . chunksOf 2 $ [1..9]
05:43:10 <lambdabot>   [[1,3,5,7,9],[2,4,6,8]]
05:43:22 <shachaf> arkeet: It's the wrong split again... And now it has the wrong type too. :-(
05:43:29 <arkeet> :-(
05:43:46 <shachaf> :‚ò∫(
05:44:08 <shachaf> arkeet: Can you improve on lazy split2?
05:44:12 <shachaf> I don't like all these helpers.
05:44:37 <arkeet> > (partsOf both ?? ([],[])) . transpose . chunksOf 2 $ [1..9]
05:44:40 <lambdabot>   Couldn't match expected type `[[a0]] -> f0 [[a0]]'
05:44:40 <lambdabot>              with actual...
05:44:45 <arkeet> uh
05:44:54 <arkeet> > (set (partsOf both) ?? ([],[])) . transpose . chunksOf 2 $ [1..9]
05:44:57 <lambdabot>   ([1,3,5,7,9],[2,4,6,8])
05:45:02 <arkeet> better type?
05:45:04 <shachaf> Yay!
05:45:08 <shachaf> Type safety restored.
05:45:18 <shachaf> You must be a real hero in mathematicianland.
05:45:24 <arkeet> 8)
05:45:29 <crl> [1..10] -> ([1..5], [6..10])
05:45:37 <arkeet> ok crl
05:45:38 <arkeet> here
05:46:31 <arkeet> > flip ap (set (partsOf (both.traverse))) ((set (partsOf both) ?? ([],[])) . transpose . chunksOf 2) $ [1..9]
05:46:33 <lambdabot>   Couldn't match expected type `((t0 a0, t0 a0) -> (t0 a0, t0 a0))
05:46:33 <lambdabot>           ...
05:46:35 <arkeet> nope.
05:46:41 <arkeet> you get the idea.
05:47:48 <arkeet> > \x -> ([],[]) & partsOf both .~ (transpose . chuknsOf 2 $ x) & partsOf (both.traverse) .~ x
05:47:50 <lambdabot>   Not in scope: `chuknsOf'
05:47:50 <lambdabot>  Perhaps you meant `chunksOf' (imported from Data....
05:48:01 <arkeet> > [1..9] & \x -> ([],[]) & partsOf both .~ (transpose . chunksOf 2 $ x) & partsOf (both.traverse) .~ x
05:48:03 <lambdabot>   ([1,2,3,4,5],[6,7,8,9])
05:48:07 <arkeet> =)
05:48:34 <shachaf> > [1..] & \x -> ([],[]) & partsOf both .~ (transpose . chunksOf 2 $ x) & partsOf (both.traverse) .~ x
05:48:37 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
05:48:41 <arkeet> > [1..13] & \x -> ([],[].[]) & partsOf each .~ (transpose . chunksOf 3 $ x) & partsOf (both.traverse) .~ x
05:48:43 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `[a1]'
05:48:48 <arkeet> > [1..13] & \x -> ([],[],[]) & partsOf each .~ (transpose . chunksOf 3 $ x) & partsOf (both.traverse) .~ x
05:48:49 <lambdabot>   Couldn't match type `(,,) [a0]' with `(,)'Couldn't match type `(,)' with `(...
05:48:53 <arkeet> awh
05:48:56 <arkeet> > [1..13] & \x -> ([],[],[]) & partsOf each .~ (transpose . chunksOf 3 $ x) & partsOf (each.traverse) .~ x
05:48:59 <lambdabot>   ([1,2,3,4,5],[6,7,8,9],[10,11,12,13])
05:49:09 <shachaf> arkeet: Which of us is disgusting again?
05:49:12 <arkeet> you!!
05:49:20 <shachaf> So fix f = f^‚àû undefined
05:49:37 <shachaf> Or lim_n‚Üí‚àû f^n undefined
05:49:42 * hackagebot xml-picklers 0.3.1 - XML picklers based on xml-types, ported from hexpat-pickle  http://hackage.haskell.org/package/xml-picklers-0.3.1 (PhilippBalzarek)
05:49:57 <arkeet> > [1..13] & \x -> (transpose . chunksOf 3 $ x) & partsOf (traverse.traverse) .~ x
05:50:00 <lambdabot>   [[1,2,3,4,5],[6,7,8,9],[10,11,12,13]]
05:50:13 <arkeet> > (!!1) $ [1..] & \x -> (transpose . chunksOf 3 $ x) & partsOf (traverse.traverse) .~ x
05:50:17 <lambdabot>   mueval-core: Time limit exceeded
05:50:20 <arkeet> daw.
05:50:23 <crl> you think complexity of lens will be better :) ?
05:50:25 <arkeet> > (!!0) $ [1..] & \x -> (transpose . chunksOf 3 $ x) & partsOf (traverse.traverse) .~ x
05:50:28 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
05:50:32 <arkeet> oh of course.
05:50:49 <arkeet> makes sense.
05:54:18 <crl> o right I finished reindenting sha & dmw solutions
05:56:30 <crl> ye the idea was tricky
05:58:40 <supki> > [[1..5],[6..10]] & partsOf (traverse . traverse) .~ [11..20]
05:58:42 <lambdabot>   [[11,12,13,14,15],[16,17,18,19,20]]
06:00:58 <supki> so I take it partsOf doesn't have any examples in haddocks because all of them are disgusting
06:07:40 <elliott> supki:
06:07:54 <elliott> > 123 & partsOf bits %~ reverse :: Int
06:07:57 <lambdabot>   -2449958197289549824
06:08:08 <shachaf> supki: Yes, they're all disgusting.
06:08:13 <shachaf> But does it actually not have examples?
06:08:28 <shachaf> It probably should.
06:08:35 <supki> wel, I didn't check HEAD
06:08:40 <supki> well*
06:08:58 <dmwit> :t partsOf
06:09:00 <lambdabot> Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
06:09:25 <dmwit> :t bits
06:09:27 <lambdabot> (Applicative f, Bits b, Indexable Int p) => p Bool (f Bool) -> b -> f b
06:09:52 <dmwit> ugh
06:09:57 <byorgey> hehe
06:09:59 <elliott> That one's GHC's faults.
06:10:03 <elliott> *fault
06:10:06 <byorgey> dmwit: just think of p as (->)
06:10:17 <elliott> bits :: Bits i => IndexedTraversal' Int i Bool
06:10:35 <elliott> i.e. a traversal from Bits instances to Bools, indexed by Int (the position of the bit)
06:10:38 <byorgey> then it has the usual traversal pattern   (a -> f a) -> (b -> f b)
06:10:50 <dmwit> I feel like this is exactly the kind of thing BCP is railing about when he talks about why PHP is popular. =P
06:11:27 <byorgey> hehe.  To be fair, lens is probably one of the most PHP-like I know when it comes to examples and documentation and such.
06:12:00 <dmwit> Yeah, though its monomorphic/polymorphic tradeoff is _very_ heavily slanted towards polymorphic.
06:12:14 <elliott> well, that's why we have much simpler signatures in the documentation
06:12:23 <elliott> it's not lens's fault :t sucks :P
06:12:34 <elliott> even beyond not giving the example signatures, it likes to expand our type synonyms for no reason :/
06:13:00 <shachaf> I like how the example signatures in lens are actually invalid.
06:13:04 <shachaf> Without eta expansion, anyway.
06:13:36 <dmwit> Perhaps today will be the day I finally sit down and work all the way through a tutorial.
06:15:59 <crl> > let length' [] = 0;length' [x] = 1;length' (x:_:xs) = 2 + length' xs in length' [1..15]
06:16:01 <lambdabot>   15
06:16:06 <crl> > let length' [] = 0;length' [x] = 1;length' (x:_:xs) = 2 + length' xs in length' [1..14]
06:16:08 <lambdabot>   14
06:16:24 <crl> it's maybe implemented like that
06:17:17 <crl> @src length
06:17:17 <lambdabot> Source not found. You speak an infinite deal of nothing
06:17:34 <crl> @src Data.List.length
06:17:35 <lambdabot> Source not found.
06:18:09 <dario> why is it implemented with the additional case for two?
06:18:44 <srhb> crl: Unlikely. length [] = 0; length (x : xs) = 1 + length xs -- seems more idiomatic. :) But in the source it probably has some accumulator rewrite
06:18:55 <srhb> uh, make that _:xs
06:19:05 <srhb> dario: It's not.
06:19:16 <arkeet> > let length' = foldl' (\acc _ -> (acc+1)) 0 in length
06:19:19 <lambdabot>   No instance for (GHC.Show.Show ([a0] -> GHC.Types.Int))
06:19:19 <lambdabot>    arising from a u...
06:19:19 <arkeet> > let length' = foldl' (\acc _ -> (acc+1)) 0 in length' [1..15]
06:19:21 <lambdabot>   15
06:19:36 <arkeet> > let length' = foldl' (\acc _ -> (acc+1)) 0 in length' [1..1000000]
06:19:39 <lambdabot>   1000000
06:20:01 <shachaf> I think this is trying to be like 05:36 <shachaf> > let half [] = []; half [x] = []; half (x:y:xs) = x:half xs
06:20:32 <crl> @src foldl'
06:20:32 <lambdabot> foldl' f a []     = a
06:20:32 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
06:21:17 <crl> k.
06:21:24 <srhb> Indeed, it uses an accumulating parameter in the source
06:21:37 <srhb> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-List.html#length
06:22:19 <shachaf> Note: It probably doesn't need to be defined with Int# these days.
06:37:50 <neutrino_> http://www.reddit.com/r/haskell/comments/1989h5/meta_shoudnt_the_subreddit_title_be_haskell/
06:39:40 <Peaker> why is OpenGL not hooking up the GC/ForeignPtr's to the deletion of generated object names?
06:39:43 * hackagebot SBench 0.2.0 - A benchmark suite for runtime and heap measurements over  a series of inputs.  http://hackage.haskell.org/package/SBench-0.2.0 (DanielSeidel)
06:40:02 <Peaker> Apparently need to manually generate/delete the textures, which is not done correctly in libraries (e.g: graphics-drawingcombinators)
06:44:15 <parcs> that's something a higher level library should do
06:48:39 <Peaker> Trying to write a little opengl image gallery viewer, because I couldn't find any sane program available for gnome
06:48:52 <Peaker> naively loading all images into textures kills the machine
06:50:13 <Botje> peaker: you can free the texture data after uploading it
06:51:01 <Botje> dont need to wait for the opengl object to be deleted
06:51:11 <Peaker> Botje, but you need to deleteObjectNames on a dying TextureObject
06:51:54 <Botje> i dont know the haskell bindings that well ..
06:52:15 <Botje> you may need to go low level then
06:53:29 <Peaker> well, if I try to addFinalizer on my TextureObject, it seems the GC prematurely decides it can run the finalizer
06:56:52 <Peaker> is there an equivalent to ForeignPtr's "touch" for weak-pointed objects?
06:57:05 <Peaker> I want to make sure the GC keeps something alive as long as some closure exists
06:57:15 <parcs> what's weak-pointed?
06:58:28 <Peaker> doh: "WARNING: weak pointers to ordinary non-primitive Haskell types are particularly fragile, because the compiler is free to optimise away or duplicate the underlying data structure. Therefore attempting to place a finalizer on an ordinary Haskell type may well result in the finalizer running earlier than you expected. This is not a problem for caches and memo tables where early finalization is benign"
06:58:55 <Peaker> parcs, a value that has a weak pointer to it, with a finalizer
06:59:25 <int-e> Peaker: there's a touch# primitive.  touchThing a = IO (\s -> case touch# a s of s' -> (# s', () #)), perhaps?
06:59:32 <Peaker> I have a data type that represents a loaded texture, and I throw that value away, but keep around a closure that encapsulates it (renders that texture). The closure should be keeping it alive, but I get early finalization (presumably due to that warning)
07:00:15 <parcs> at this point i would just use the raw OpenGL bindings since then you'll be working with Ptrs directly
07:00:45 <Peaker> hmm. I only want to get a finalizer to run when my object representing a texture is dying :(
07:01:01 <Peaker> int-e, thanks, that seems like a good last resort
07:02:14 <int-e> Peaker: (that's almost exactly the implementation of touchForeignPtr, except for the type)
07:02:29 <parcs> i'm not sure how well deleting OpenGL resources with finalizers would work because the finalizer could be scheduled in a separate OS thread or something
07:02:49 <int-e> ("almost" because touchForeignPtr actually only touches the ForeignPtrContents part of the ForeignPtr)
07:02:49 <srhb> blaze-html haddocks seem to refer to a function "text" all the time that looks like it has type Text -> Html, however, I don't see this function anywhere in the package. What am I missing?
07:02:57 <totimkopf> totimkopf> Hi, I'm trying to create a textarea with Text.Blaze.Html5 but text is not in scope ?  textarea $ span $ text "foo" is there some other module that I need to include?
07:04:43 <Peaker> int-e, the "primitive" package wraps "touch" that way already, and that does seem to do the trick! thanks :)
07:04:46 <elliott> srhb: looks like it is in blaze-markup?
07:04:46 <parcs> totimkopf: use toHtml
07:04:58 <elliott> hmm, but marked Internal
07:05:10 <int-e> Peaker: ah, good to know
07:06:14 <hiptobecubic> Does the community more or less agree that semantic versioning is the only way that doesn't result in mass suicide?
07:06:28 <parcs> totimkopf: or turn on OverloadedStrings and omit any function call
07:06:58 <hiptobecubic> it seems like versioning could really be entirely automatic
07:07:04 <Philippa> hiptobecubic: seeing as we've had this come up already - semantic versioning or Semantic Versioning?
07:07:21 <hiptobecubic> Philippa, I guess the latter?
07:07:41 <elliott> @where PVP
07:07:41 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
07:07:42 <preflex>  lambdabot: you have 1 new message. '/msg preflex messages' to read it.
07:07:48 <elliott> heh
07:08:00 <elliott> @msg #haskell preflex: messages
07:08:01 <lambdabot> preflex: messages
07:08:01 <preflex>  ski_ said 4 days, 7 hours, 47 minutes and 16 seconds ago: When are you going to enter the dream again ?
07:08:50 <hiptobecubic> I'm wondering if it couldn't be automated, or at least verified. It's easy to detect if the API has changed and how, no?
07:09:45 <elliott> hiptobecubic: you can change what a function does in a way that breaks backwards compat without changing its signature
07:10:06 <elliott> types are very informative, but the form we have in haskell aren't enough to encapsulate everything about an API
07:10:14 <Philippa> hiptobecubic: I suspect automation is out. Verifying that it "probably" hasn't, maybe
07:10:24 <Philippa> elliott: Rice's Theorem doesn't help, either!
07:11:39 <elliott> Philippa: indeed. but maybe the Agda folk could get away with defining an API as a module signature and automating versioning based on that...
07:11:55 <Philippa> yeah, that'd probably work
07:12:15 <elliott> the trade-off being, you have to make your types as expressive as possible or you'll end up with version conflicts, which might not be a bad pressure when you can express that much
07:12:45 <hiptobecubic> It would be great if we could have more than one version of a package installed as well
07:14:12 <elliott> hiptobecubic: we already can
07:14:17 <hiptobecubic> elliott, in use?
07:14:18 <elliott> it's not so great in practice though :P
07:14:23 <hiptobecubic> right
07:14:45 <shachaf> Expressive types are a burden on the programmer and a burden on society.
07:14:54 <shachaf> Real programmers keep it all in their heads.
07:14:59 * shachaf sighs.
07:15:03 <companion_cube> ?
07:15:07 <shachaf> OK, I think my thing is done.
07:15:08 <hiptobecubic> But is it more than just "ghc/cabal wasn't written with the foresight to handle this" ?
07:15:53 <hiptobecubic> if my modules uses foo-1.0 and bar-2.0  and foo-1.0 uses bar-1.0
07:16:11 <hiptobecubic> Is there any good reason that it shouldn't be able to do this?
07:16:37 --- mode: ChanServ set +o shachaf
07:16:43 --- kick: shachaf was kicked by shachaf (pointless inflammatory remark)
07:16:59 <parcs> poor shachaf
07:17:18 <hiptobecubic> And they say self-regulation doesn't work
07:18:28 <b_jonas> hiptobecubic: the usual problem is when you create a value of type Bar then try to pass it to a function in foo, but it doesn't work, because foo expects a different type of bar
07:19:03 <hiptobecubic> b_jonas, you should be able to have both kinds of bar really
07:19:11 <hiptobecubic> then pass foo the kind that it wants
07:19:24 <b_jonas> hiptobecubic: but you can't convert them.
07:19:32 <hiptobecubic> b_jonas, i didn't say you should be able to
07:19:51 <hiptobecubic> although depending on what it is, maybe you could it manually if you wanted
07:21:30 <b_jonas> hiptobecubic: so anyway, sometimes it's fine, sometimes it causes problems, and it's usually hard to tell in advance when it's fine. you'd have to know the details.
07:22:12 <hiptobecubic> b_jonas, but using bar-1.0 with foo-1.0 is always fine. Using bar-2.0 to do whatever else you were intending to do is also always fine.
07:22:17 <b_jonas> if foo never takes or gives bar objects or any objects depending on bar, then it's fine. this is often the case when foo is using bar only as an implementation.
07:22:43 <hiptobecubic> b_jonas, also true.
07:40:29 <Sculptor> hello
07:40:51 <byorgey> hi Sculptor
08:22:33 <franco00> probably a very naive question. I found a typesig "attempt :: (forall e. Exception e => e -> b) -> (a -> b) -> Attempt a -> b". Is it the same as "attempt :: (Exception e) => (e -> b) -> (a -> b) -> Attempt a -> b"?
08:23:32 <hiptobecubic> The Platform is surprisingly slim
08:23:44 <byorgey> franco00: it's not a naive question.  And the answer is no, it is not the same.
08:24:15 <byorgey> franco00: the first one says the caller of 'attempt' must provide a function which works for all Exception types e.  The second says that the caller of attempt may pick a specific type e.
08:24:16 <Radish> how come {[1..(sqrt 1000)]} works, {fn [1..33]} works, but {fn [1..(sqrt 1000)]} throws a type error?
08:24:35 <byorgey> franco00: i.e. in the first case it's 'attempt' itself which gets to choose the type e
08:24:45 <Radish> 31**
08:25:10 <byorgey> Radish: what is the type of fn?
08:25:34 <Radish> I tried a few things but I couldn't get it to like any types I picked.
08:25:55 <byorgey> Radish: probably fn is expecting a list of Integers, or some sort of Integral type.
08:26:08 <byorgey> whereas  [1..(sqrt 1000)] is going to be a list of Doubles, or some other floating-point type
08:26:12 <Radish> should be (Enum a, RealFrac a) => [a] -> [Word] I think...
08:26:29 <byorgey> @type [1..(sqrt 1000)]
08:26:31 <lambdabot> (Enum t, Floating t) => [t]
08:26:48 <Radish> I guess I'll try that?
08:26:54 <byorgey> Radish: try what?
08:27:35 <franco00> byorgey: ohhh thanks, now it's clear.
08:28:07 <Radish> byorgey: that type
08:28:17 <Radish> didn't take.
08:28:19 <byorgey> Radish: what do you mean 'try it'?
08:28:41 <Radish> fn :: (Blah b) => [b] -> [Whatever]
08:28:50 <Radish> oi.
08:29:03 <byorgey> Radish: do you really need this code to be polymorphic?
08:29:22 <byorgey> I would suggest for now sticking to concrete types like [Double] -> [Word8] or whatever.
08:29:30 <byorgey> once you get that to work you can generalize it if needed.
08:29:39 <byorgey> and put type signatures on all your functions.
08:29:45 * hackagebot zip-archive 0.1.3.4 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.1.3.4 (JohnMacFarlane)
08:30:02 <Radish> byorgey: I need fn [1..(floor (sqrt x))]
08:31:01 <nilg> I need to load a file of 700M, turn this into a matrix, I'm using [[String]] to store the matrix but it takes more than my RAM (8GB), any suggestion to optimize RAM (I tried -O already)?
08:31:13 <byorgey> Radish: yes, that sounds like it might work
08:31:27 <byorgey> nilg: don't use [[String]]
08:31:28 <nilg> would Data.Sequence take less memory?
08:31:29 <Radish> byorgey: it throws an error hang on 1 sec
08:32:03 <Peaker> which package/API is recommended for simple mutable arrays?
08:32:04 <Radish> "no instance for RealFrac Word"
08:32:05 <byorgey> nilg: you probably want something like http://hackage.haskell.org/package/vector, perhaps?
08:32:07 <Peaker> Data.Array, vector, repa?
08:32:24 <byorgey> Peaker: vector, I think
08:33:10 <byorgey> nilg: lists have a lot of memory overhead, and they're not a good way to store matrices anyway.
08:33:32 <Peaker> what's vector's equivalent of listArray?
08:33:39 <Peaker> rather: newListArray
08:33:41 <nilg> byorgey: OK, I'll try that, I assume there is cabal way to install it
08:34:30 <byorgey> nilg: yes, 'cabal install vector'
08:34:30 <nilg> oh I found the tutorial, find, thx
08:35:52 <jerng> Hi. Does anyone have a simple example of getting (Text.Regex.PCRE.ByteString) to work? I've been poking about the various regex modules for a few days, and am about to retreat to stock Text.Regex.
08:36:16 <byorgey> Peaker: fromList ?
08:36:23 <Radish> could it be because x :: Word?
08:36:33 <Peaker> byorgey, seems not to be available for mutable ones. I'll just write them all manually
08:36:51 <nilg> byorgey: I'm fine with immutable arrays, maybe I should directly use Array? http://www.haskell.org/haskellwiki/Arrays
08:36:54 <byorgey> Radish: can you paste your code on hpaste.org?
08:37:12 <byorgey> nilg: vector has immutable arrays too, and is much more efficient than Array
08:37:21 <nilg> great thx
08:37:34 <Radish> byorgey: yes 1 minute
08:37:54 <Peaker> would it be appropriate to say that Vector subsumes Data.Array?
08:38:04 <Peaker> i.e: no reason to use Data.Array anymore?
08:38:20 <parcs> Data.Array gives you easy multidimensional indexing
08:38:54 <hpaste> Radish pasted ‚Äúsqrt causing me trouble‚Äù at http://hpaste.org/83513
08:39:04 <byorgey> Peaker: that's my understanding.
08:39:15 <byorgey> parcs: oh, and vector doesn't?
08:39:17 <elliott> well, Array can do stuff Vector plain can't in terms of indexing
08:39:22 <elliott> you could argue repa obsoletes Array, I guess
08:39:27 <parcs> byorgey: i don't think so
08:39:29 <elliott> Array isn't very nice though :(
08:39:34 <byorgey> ah, cool, didn't know that
08:39:44 * byorgey has never actually used vector
08:40:54 <byorgey> Radish: first of all, your type for customFilter does not make sense.  It's impossible to take a list of *ANY* type and do some sort of filtering on it.
08:41:27 <Radish> byorgey: right that's more of a comment i guess
08:41:33 <Radish> byorgey: for hpaste
08:41:35 <byorgey> Radish: what is the type of lfsrSize ?
08:41:43 <Radish> byorgey: it doesn't seem to work with any type
08:41:46 <Radish> byorgey: Word
08:42:00 <Radish> byorgey: sorry i was taking that 1 minute to make sure I got everything, I didn't.
08:42:04 <byorgey> Radish: ok, well you can't take the sqrt of a Word
08:42:17 <Radish> byorgey: how to i cast it?
08:42:23 <byorgey> Radish: you'll have to write  sqrt (fromIntegral lfsrSize)
08:42:34 <Radish> byorgey: thanks
08:42:44 <Radish> byorgey: i bet that fixes it
08:42:53 <byorgey> I think it should
08:43:12 <byorgey> @type sqrt
08:43:13 <lambdabot> Floating a => a -> a
08:43:14 <Radish> yep that was it, thank you
08:43:22 <byorgey> Radish: you can only call sqrt on floating-point types, like Double or Float
08:43:52 <Radish> byorgey: I'm surprised it cared
08:44:02 <byorgey> Radish: what do you mean?
08:44:32 <Radish> byorgey: figured it could convert word to float for me
08:44:47 <Radish> byorgey: like it does for a lot of other things.
08:45:01 <byorgey> Radish: Haskell never does implicit conversions.
08:45:11 <Radish> byorgey: or maybe it doesnt?  it seems like it does.
08:45:21 <byorgey> Radish: probably what you're thinking of is that numeric literals are polymorphic.
08:45:26 <hiptobecubic> Can anyone help me understand this error? http://vpaste.net/BL7Z1   the version of HTTP that it wants is installed, but then it complains about not being able to satisfy it
08:45:29 <byorgey> so  5  can have type Int, or Integer, or Double
08:45:41 <Radish> byorgey: probably where I'm hung up, thanks for being so helpful byorgey
08:45:45 <hiptobecubic> running cabal update; cabal install cabal-install; after installing the platform
08:45:46 <byorgey> depending on the context.  But there's no conversion happening.
08:45:58 <byorgey> Radish: sure, glad I could help
08:46:04 <Radish> byorgey: follow up question you may or may not be able to help me with:
08:46:17 <Radish> byorgey: is sqrt safe for getting the root of ints?
08:46:33 <Radish> byorgey: will it sometimes give me like swrt 64 = 7.999999799
08:46:38 <Radish> sqrt*
08:46:44 <hiptobecubic> Radish, that is floating point math.
08:47:01 <byorgey> Radish: It might.  you should probably use 'round' instead of 'floor'.
08:47:02 <Radish> hiptobecubic: even in this corner case I'm asking about?
08:47:08 <elliott> > sqrt 64
08:47:10 <lambdabot>   8.0
08:47:11 <byorgey> s/probably/definitely/
08:47:24 <elliott> > sqrt 2
08:47:26 <hiptobecubic> Radish, yes.
08:47:26 <lambdabot>   1.4142135623730951
08:47:48 <Radish> hiptobecubic: any idea what the margin of error might be at a maximum?
08:48:07 <hiptobecubic> Radish, you can round like byorgey says, or if you can use a (much slower) exact representation like (Ratio Integer)
08:48:17 <Radish> hiptobecubic: i know theres a way to calculate it but i don't need exact
08:48:25 <byorgey> Radish: the margin of error will be quite small.
08:48:29 <hiptobecubic> very small
08:48:34 <Radish> byorgey: less than...?
08:48:39 <byorgey> like 0.00000000001 or something.  I don't know.
08:48:49 <Radish> byorgey: so for sure less than .0001?
08:48:52 <hiptobecubic> yes
08:49:07 <Radish> hiptobecubic: cool I'll add .0001 and floor it?
08:49:08 <hiptobecubic> otherwise planes would be exploding the skies and
08:49:14 <hiptobecubic> who knows what
08:49:18 <hiptobecubic> Radish, why not round?
08:49:20 <Radish> hiptobecubic: rofl
08:49:32 <Radish> hiptobecubic: if I accidentally round up its slower
08:49:48 <hiptobecubic> What?
08:49:51 <Radish> hiptobecubic: better to do that when there's an error margin
08:50:08 <hiptobecubic> If you accidentally round up it's slower? What are you talking about
08:50:21 <Radish> > sqrt 3
08:50:23 <lambdabot>   1.7320508075688772
08:50:38 <Radish> don't need 2
08:50:56 <Radish> anyway thank you guys both!
08:51:01 <hiptobecubic> Oh you mean your particular use case doesn't need that kind of accuracy i guess?
08:51:12 <hiptobecubic> then sure, do whatever you want. clearly you don't have be that accurate really
08:51:32 <jerng> Has no one got a simple Text.Regex.PCRE.ByteString or Text.Regex.TDFA.ByteString example?
08:52:49 <Radish> hiptobecubic: i'm using [1..sqrt]
08:52:59 <Radish> ints
08:54:52 <issimus> jerng: TDFA is documented on hackage
08:54:57 <bitonic> is there a pretty printing library that lets you control the ‚Äòbadness‚Äô of breaking up a line?
08:55:14 <bitonic> e.g. I want it to break up in certain points instead that in others, if possible
08:55:49 <jerng> issimus: yup. So is PCRE - can't make head or tail of the API though. I'm just slow.
08:55:57 <jerng> Thanks. All.
08:56:09 <hiptobecubic> the regex api's are not at all easy to comprehend, imo
08:56:43 <issimus> jerng: no i mean, all the newtypes are documented in a particular source file, the operator, i think its =~ is polymorphic depending on the result you want
08:56:43 <hiptobecubic> the types are all crazy and there is too much jammed in via typeclass using (=~) and the like
08:57:10 <jerng> No kidding.
08:58:21 <jerng> I figured out a simple PCRE example actually - but haven't gotten TDFA to work. Even then, the PCRE example I have works at the mid-level, and will need a wrapper function for "all matches". The overall Regex.Base API doesn't even have substitution built in.
08:59:04 <gwern> @quote
08:59:04 <lambdabot> lispy says: monad tutorial : haskell :: conflictor representation : darcs hacking
08:59:17 <hiptobecubic> So this error. Does anyone know how to interpret it. Why does it demand *this* particular HTTP with *this* particular hash? http://vpaste.net/BL7Z1
09:00:20 <hiptobecubic> gwern, what are "things you must write before you understand them?"
09:00:25 <parcs> > 0x7F
09:00:28 <lambdabot>   127
09:04:21 <applicative_> jerng: it helps if you specialize some things right away, e;g;  (==~) :: RegexContext Regex ByteString target => ByteString -> ByteString -> target ; (==~) = (=~)
09:05:23 <applicative_> jerng if youi are using ByteString.   The regex libraries are a bit mad; I think those perl hackers who were building pugs must have been behing them
09:06:24 <hiptobecubic> hmmm. can't install cabal 1.16.0 or 1.16.0.1 either :(
09:06:55 <applicative_> hiptobecubic: hm, does ghc-pkg check show anything broken
09:07:05 <hiptobecubic> how?
09:07:30 <hiptobecubic> ghc-pkg check ?
09:07:39 <elliott> yes
09:08:17 <hiptobecubic> just warnings about missing haddock
09:08:54 <jerng> applicative I'm thinking to write some simple wrappers for the mid-level API in PCRE.ByteString, whenever I recover from this headache. This is as far as I got - the code works. http://sextechandmergers.blogspot.com/2013/03/haskell-textregexpcrebytestring.html
09:09:14 <applicative_> maybe its that your http is built against something that the new Cabal etc cant use
09:10:24 <hiptobecubic> i just installed the platform. it told me to run cabal update, which told me to run cabal install cabal-install, which then gave this error
09:11:48 <Saizan> hiptobecubic: ghc-pkg list HTTP ?
09:12:45 <hiptobecubic> Saizan, http://vpaste.net/gmEcY
09:13:04 <hiptobecubic> wait! magic
09:13:15 <hiptobecubic> When I ran that the first time, it said it was out of date
09:13:22 <hiptobecubic> so i switched to root and recached
09:13:37 <hiptobecubic> when i switched back, cabal installed successfully
09:13:47 <hiptobecubic> I'm not sure why it was out of date right after installing though
09:14:18 <Saizan> i guess it was there from a previous installation
09:14:31 <hiptobecubic> perhaps
09:15:11 <Saizan> anyhow cabal asked for that hash because that's what ghc-pkg told it was available
09:15:28 <Saizan> it pins down the hash in case there are others too
09:20:28 <otters> is there something on hackage for managing arbitrary configs
09:20:39 <otters> oo ConfigFile
09:20:55 <otters> can anybody vouch for the efficacy of ConfigFile
09:28:52 <hpaste> applicative pasted ‚Äúregex.bytestring‚Äù at http://hpaste.org/83521
09:29:41 <applicative_> jerng but why are you using the midlevel api instead of nonsense like this ^^
09:32:01 <kqr> otters, arbitrary configs would require a parser like parsec
09:32:09 <kqr> otters, configfile is for ini-style configs
09:32:52 <kqr> otters, i don't think theres a Grand Package of Config Parsers. if you like INI-style, go for configfile, if you like json, go for text.json or something
09:32:55 <kqr> otters, and so on
09:53:17 <otters> okay
09:54:47 * hackagebot blaze-html 0.6.1.0 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.6.1.0 (JasperVanDerJeugt)
09:55:13 <hpaste> roadfish pasted ‚Äúhow to get show to work like polyTypeOf?‚Äù at http://hpaste.org/83522
09:55:53 <yitz> otters: yesod uses yaml file for config. there are also a number of yaml packages. yaml and json2yaml are the ones yesod uses i think, together with aeson.
09:57:00 <roadfish> I'm using polyTypeOf inside of instance Show (a->b) ... how do I get show to report "[a1] -> Int" instead of just "a1 -> a2"?
09:57:08 <otters> yitz: I'm using YAML right now, it's not hugely user-friendly but it's better than nothing
09:57:09 <roadfish> details are in http://hpaste.org/83522
09:57:10 <otters> I guess I'll stick with that
09:57:17 <otters> I want basically a persistent hash
09:57:46 <kqr> otters, json is pretty much yaml with C-like syntax, if you prefer that
09:57:52 <kqr> otters, something else to consider is just plain text files
09:57:55 <otters> right
09:58:06 <otters> I looked at Aeson but it appears to require objects of a fixed format
09:58:17 <kryft> Hmm, are the Real World Haskell exercises generally considered good? Some of them don't seem all that well thought out, at least up to chapter 4.
09:58:31 <kqr> kryft, anything in particular you don't like?
09:58:49 <yitz> otters: no you can create instances for all kinds of things. the object types in the json itself are fixed by json of course.
09:58:56 <otters> right
09:59:12 <yitz> you just have to decide how to serialize.
09:59:23 <kryft> kqr: Numerous details; the comments in the web version point out most of them (not that I agree with all the complaints in the comments)
09:59:29 <otters> well I mean, all the FromJSON instances I saw represented a datatype with a fixed set of top-level keys
09:59:42 <otters> and the config file would have an arbitrary number of top-level keys named arbitrary things
09:59:55 <kryft> I was also wondering if there are any recommended solutions for the exercises. (Googling suggests no, but can't hurt to ask)
10:00:11 <yitz> otters: snoyberg has general instances for yaml stuff in the yesod code i think, if you look around.
10:00:37 <kryft> I'm sure I can solve them, but it would be nice to compare with a 'good' solution written by an experienced haskell coder
10:01:04 <kryft> (Well, at least I've been able to solve them so far.)
10:01:12 <yitz> yaml can be simpler than json if you stick to the simple stuff. and more complicated and harder to use if you don't.
10:02:27 <otters> I'm using YAML right now but the method I'm using is pretty gross
10:02:38 <Jaleks> hi all
10:02:38 <Jaleks> as i am quite a newbie to haskell i hoped someone can get me a tip what i have to do to use lookupLT in my .hs. I already told cabal to include containers, so the import is valid now.
10:02:38 <Jaleks> unfortunately the function lookupLT still is not recognized (using Eclipse FP)
10:03:16 <yitz> kqr: you mean "just plain text files" with some syntax you define. which is exactly what ini, json, and yaml are, too. so what you really mean is "roll your own syntax". which is fine too sometimes.
10:03:19 <kqr> kryft, i don't know. it was quite a while since i read real world haskell. i personally don't think it's a good book to start out with anyway
10:03:29 <kqr> kryft, and aren't there solutions in the comments to the exercises?
10:04:03 <kqr> yitz, sure, i guess that's technically correct
10:04:24 <kqr> yitz, i've just heard extremely simple custom syntax be called "plain text files" in this context before
10:04:28 <yitz> hey you can use s-expressions. those are not syntax by definition. because if you call it syntax, 100 lispers will attack you.
10:05:06 <kqr> yitz, e.g. if you need a list of people, not using a json library and instead just putting one name per line is called using "plain text files"
10:05:09 <kqr> yitz, ...i think.
10:05:35 <yitz> kqr: that is indeed very simple syntax and often quite adequate.
10:06:15 <yitz> kqr: or, say, haskell lists and tuples that you can feed to reads or maybeRead.
10:06:24 <kqr> yeah
10:06:49 <kqr> but the problem of overusing advanced syntax formats might be bigger with java people who use XML for everything
10:06:51 <kqr> i don't know
10:06:54 <kryft> kqr: I took a course that covered roughly LYAH a year ago, so I already know some things
10:07:14 <kqr> kryft, ah, great
10:07:32 <Jaleks> or is there maybe somehting similar to  lookupLT
10:07:36 <yitz> kqr: when you're in an environment where many advanced xml tools are being used (like we are at work), then usually xml is actually the best format for configuration files.
10:07:42 <Jaleks> one would use if one just would know it?
10:07:48 <kqr> kryft, you shouln't use me as an authority on this, but my personal thoughts go roughly along the lines of real world haskell being a super cool book when you know some haskell and want to start making real programs
10:07:58 <kryft> kqr: There are lots of solutions posted by various people, yeah, but there's no way for me to know whether they teach good practices etc
10:08:04 <kqr> kryft, i view it as more of a cookbook than "here's how you turn on your stove"
10:08:11 <kryft> kqr: Ah, that's precisely where I am, I guess :)
10:08:42 <kqr> yitz, yeah, that could be true
10:09:01 <yitz> kryft: by seeing a variety of different styles, you can start to form your own opinions
10:09:54 <kryft> yitz: Sure
10:10:40 <kqr> kryft, the ad/hd part of my brain really wants to sit down and create a wiki-like something for solutions but i'm sorry to admit that i really shouldn't so i won't.
10:11:31 <kryft> kqr: You shouldn't in the sense that you don't consider yourself competent?
10:12:30 <kqr> kryft, i shouldn't in the sense that i have lots of other things i need to do in order to get food on my table :D
10:12:37 <kryft> kqr: Ah, hehe :)
10:13:10 <roadfish> if only spam was edible ... then you'd have all the food you need on your table.
10:13:55 <hpaste> kryft pasted ‚ÄúRWH exercise 4.1.4‚Äù at http://hpaste.org/83523
10:14:08 <dennda> Does the haskell standard require implementations to implement TCO?
10:14:26 <luminous> so i am trying to learn me some haskell, coming from a predominantly python background, and the thing i realize that is tripping me up the most is the syntactical structure... it is really difficult for me to read haskell and determine what is going where and what not. are there any resources you might suggest?
10:15:14 <kryft> kqr: Maybe I'll just ask about a single exercise: does this seem reasonable, e.g. that ++ won't result in any unnecessary traversal here? I don't think it should, but I'm not entirely sure
10:15:53 <kryft> kqr: (Incidentally I thought this exercise was good, so it's not an example of my earlier complaints :)
10:16:00 <edwardk> a single ++ is generally fine. its when you start using it iteratively you have problems
10:16:27 <kryft> edwardk: As in recursively appending one element with it?
10:16:27 <kqr> kryft, could you give a link to the exercise too? i tried finding it but the numbering in the online version of the book doesn't seem to follow the 4.1.4 scheme
10:16:33 <kryft> kqr: Oh right, sorry
10:16:34 <edwardk> kryft: yes
10:17:34 <edwardk> kryft: so what is clamping your line lengths?
10:17:34 <kryft> kqr: http://book.realworldhaskell.org/read/functional-programming.html It's the 4th exercise of the first block
10:18:11 <kryft> edwardk: Sorry, what do you mean?
10:19:14 <edwardk> just eyeballing the padLines and takeWhile notAllSpaces
10:19:19 <edwardk> on the transposition
10:19:24 <edwardk> er oh the tranposition
10:19:44 <kryft> edwardk: What do you mean by clamping line lengths?
10:25:37 <fragamus> hey hey hey
10:25:40 <eff> hi, i'm sorry i guess the question comes a lot here, but the haskell.org gives too much possible answers to the question to feel helpful to me, what is the ONE documentation / book / tutorial, you would recomment to learn haskell for someone with a C / python background and no functional experience at all please ?
10:26:33 <kqr> kryft, any reason you don't do
10:26:35 <kqr> kryft, transposeText = unlines . transpose . lines
10:27:08 <kryft> kqr: I didn't know about that function
10:27:18 <edwardk> > unlines (transpose (lines "hello\nworld\this is neat"))
10:27:20 <lambdabot>   "hw\neo\nlr\nll\nod\n\t\nh\ni\ns\n \ni\ns\n \nn\ne\na\nt\n"
10:27:42 <edwardk> > unlines (transpose (lines "hello\nworld\nthis is neat"))
10:27:44 <lambdabot>   "hwt\neoh\nlri\nlls\nod \ni\ns\n \nn\ne\na\nt\n"
10:27:50 <kryft> kqr: I don't think it's mentioned anywhere in the book (though someone probably did mention it in the comments for the exercise)
10:28:33 <crl> > transpose "abc"
10:28:35 <lambdabot>   Couldn't match expected type `[a0]'
10:28:35 <lambdabot>              with actual type `GHC.Type...
10:28:41 <fragamus> hey edwardk I GOTTA find out what comonads are good for
10:28:53 <ab9rf> fragamus: vmaking
10:28:57 <kryft> kqr: I assume you're intended to write the function yourself anyway, as it's not much of an exercise otherwise :)
10:29:13 <ab9rf> fragamus: they seem mainly good for getting people to go "but what are comonads good for?"
10:29:27 <Lethalman> eff, learn you a haskell
10:29:36 <crl> > transpose ["a","b","c"]
10:29:37 <kqr> crl, transpose :: [[a]] -> [[a]]
10:29:38 <lambdabot>   ["abc"]
10:29:53 <ab9rf> eff: which one is best for you is mainly a factor of what your learning style is.
10:29:53 <crl> > sequence ["a","b","c"]
10:29:55 <lambdabot>   ["abc"]
10:29:55 <edwardk> hah
10:30:02 <edwardk> i use lots of little comonads in my code
10:30:10 <fragamus> yes I know
10:30:12 <edwardk> but i don't structure my code around one gigantic comonad
10:30:29 <Philippa> which... makes sense in terms of duality
10:30:32 <crl> > sequence [[1,2],[3,4]]
10:30:33 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
10:30:40 <crl> > transpose [[1,2],[3,4]]
10:30:42 <lambdabot>   [[1,3],[2,4]]
10:30:47 <Philippa> it's a common monad that wants to own "all the something". It's an uncommon comonad
10:30:56 <fragamus> I am adept at using monads, although I don't go around pondering the monad laws
10:30:57 <eff> ab9rf: i understand there is no silver bullet, but i think choosing a relatively suited resource and sticking with it mught be more efficient than jumping between 5 differents ones
10:31:05 <eff> Lethalman: thanks you
10:31:16 <ab9rf> eff: well, start on one and if it's not working choose a different one
10:31:24 <fragamus> Once I wrote my own monad
10:31:46 <fragamus> it was essentially ListT State
10:31:53 <Philippa> fragamus: the laws are mostly the sort that're good for stopping you having to think, anyway
10:32:16 <Philippa> they amount to "the sequence of stuff in a do statement means at least /something/, and return has no effects"
10:33:02 <kqr> kryft, i wouldn't say that
10:33:03 <fragamus> yes. What I crave is a practical sense of how to apply comonads
10:33:06 <kqr> kryft, but i don't know
10:33:25 <kqr> kryft, i think it's way more important being able to find the functions you need in the documentation and know how to apply them properly
10:33:33 <kqr> kryft, the rest will come with time
10:33:39 <kqr> kryft, but people have different needs and values
10:33:52 <kqr> kryft, regardless, i like your interactWith
10:34:09 <kqr> kryft, your main is needlessly complicated with the extra depth that i don't see the point of
10:35:10 <kqr> kryft, http://hpaste.org/83524
10:35:20 <kqr> kryft, that would do the same thing and it wouldn't need you to refer back and forth to definitions as much
10:38:53 <luminous> so i am trying to learn me some haskell, coming from a predominantly python background, and the thing i realize that is tripping me up the most is the syntactical structure... it is really difficult for me to read haskell and determine what is going where and what not. are there any resources you might suggest?
10:39:16 <Philippa> luminous: if you can read the metasyntax, the Haskell Report itself is pretty good
10:39:40 <Philippa> (if you can't, learn? It's a highly useful skill)
10:39:53 * hackagebot happstack-fay 0.2.0 - Support for using Fay with Happstack  http://hackage.haskell.org/package/happstack-fay-0.2.0 (JeremyShaw)
10:39:55 * hackagebot happstack-fay-ajax 0.2.0 - Support for using Fay with Happstack  http://hackage.haskell.org/package/happstack-fay-ajax-0.2.0 (JeremyShaw)
10:40:17 <luminous> metasyntax?
10:40:31 <Philippa> syntax for describing syntax
10:40:44 <kqr> luminous, is it the syntax or the whitespace rules?
10:41:01 <kryft> kqr: The main isn't mine. Only the part from transposeText :: .. onwards is mine; the rest is a template provided by the book (it hasn't covered IO yet at that point)
10:41:06 <Philippa> kqr: good question. Though I also recommend reading the report to understand how layout works because it's not the same as Python's
10:41:56 <fragamus> im going to change my name to comonad. That way, when anyone says comonad in here, it will ring a little bell and highlight it for me.
10:42:13 <Philippa> your IRC client may have another way to accomplish that :-)
10:42:30 <kqr> kryft, oh, i see
10:42:33 <Lethalman> fragamus, if you're using xchat, you can add custom names for highlighting :P
10:42:55 <kqr> Philippa, how does the layout differ from python
10:42:59 <kryft> kqr: Maybe you're right, but most of the other exercises have you reimplementing things that have standard implementations
10:43:19 <kryft> kqr: (Regarding whether the point of the exercise is to use transpose or not)
10:43:36 <Philippa> kqr: easiest answer is "read the report"
10:43:42 <kqr> kryft, okay. your transposeLines looks good, but I don't see the point of padLines and notAllSpaces
10:44:03 <kqr> Philippa, hah!
10:44:04 <fragamus> I haven't looked at this in a while, but I am again and it is making sense
10:44:05 <fragamus> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
10:44:06 <Philippa> there're some fun rules like the "if a close bracke'd be legit here and not having one causes a parse error, insert a close brace"
10:44:24 <kqr> Philippa, i'm just curious if there's anything in particular you could mention
10:44:28 <kqr> Philippa, oh right and so you did. thanks
10:44:28 <kryft> kqr: (Incidentally, I noticed that some other people complained that the provided template was unnecessarily complicated)
10:44:29 <wuttf> Philippa: can I PM you?
10:44:32 <Philippa> that'd be one of the original uses cases for Parsec 3 btw: that with a monadic lexer that'll backtrack a character
10:44:41 <kryft> kqr: Hmm, I added padLines because the lines can be of different length
10:44:52 <fragamus> i think I can only learn things I *almost* already know
10:44:53 * hackagebot fay-hsx 0.1.0 - Clientside HTML generation for fay.  http://hackage.haskell.org/package/fay-hsx-0.1.0 (JeremyShaw)
10:45:34 <Philippa> wuttf: is there any particular reason not to say it in here or eg -blah or -overflow?
10:45:40 <Philippa> (but I guess in a pinch)
10:45:51 <wuttf> Philippa: Definitely.
10:46:02 <Philippa> eh, go for it
10:46:21 <elliott> kryft: your hpaste has some unnecessary parens, btw
10:46:35 <elliott> around the whole defn in padLines and around (takeWhile notAllSpaces)
10:46:41 <TravisD> That's just not fair - now I'm curious about what wuttf was going to say
10:46:47 <letrec> I'm using ghc --make. The project builds well on Mac (ghc works out dependencies). But it doesn't work on Linux (it only builds the main module and stops with an error). It's ghc 7.4.2 on both machines. Any idea?
10:47:07 <wuttf> I want to say sorry. I was rude to Philippa when I joined the Haskell community.
10:47:15 <wuttf> TravisD: If you want to know :D
10:47:25 <TravisD> Oh
10:47:25 <kryft> elliott: Ah, thanks
10:47:35 <TravisD> now I feel like a jerk :P Very noble of you
10:47:46 <wuttf> TravisD: You are not ;)
10:47:49 <kryft> elliott: I guess I'm still a bit confused by operator precedence
10:47:55 <wuttf> TravisD: Dont feel like one ;)
10:48:35 <elliott> kryft: nothing binds tighter than function application
10:48:39 <elliott> except record syntax
10:48:46 <elliott> (which is record syntax's fault)
10:49:10 <kryft> kqr: I'm sure there are other ways of accomplishing the same thing, but if I just removed padLines, wouldn't calling head result in an exception as soon as I've consumed the shortest line in the input?
10:49:39 <kryft> elliott: Heh
10:50:20 <Taneb> Just found a typo in the T & C's of School of Haskell
10:50:24 <wuttf> TravisD: It is just a., I am drunk and it softens my "like I give a sh*t" attitude, b., I think I am here to stay for a looong time. c., I am genuinely embarrassed
10:50:33 <Taneb> Unless "worldwine" is a thing
10:50:36 <kqr> kryft, yeah, it definitely would
10:50:48 <TravisD> wuttf: no need to explain. It's a good thing to do
10:52:54 <luminous> kqr: i guess it is both.. i am used to being able to discern the boundaries between funtions and code expressions
10:53:05 <luminous> i have a hard time doing so in haskel
10:53:24 <kqr> luminous, i'm not sure what you mean
10:53:27 <luminous> *haskell
10:53:43 <kqr> luminous, one thing i have noticed, however, is that do-expressions are difficult
10:54:35 <Philippa> luminous: functions aren't magical. There're lambdas, there're equational form bindings, the latter are sugar for a simpler binding + lambdas and case
10:55:01 <luminous> some form of: foo(a b) {}  makes sense to me, i have a hard time seeing those same boundaries in haskell
10:56:20 <kqr> luminous, foo a b = expression
10:56:27 <Philippa> in Haskell they go let {foo = bar; baz = quux} where foo and baz're variables and bar and quux are expressions
10:56:27 <kqr> luminous, if you want the expression on a new line, indent it slightly
10:57:07 <kqr> kryft, i guess my thinking is that padLines and notAllSpaces are superflous
10:57:16 <kqr> kryft, it should be possible to transpose without them
10:57:34 <kqr> kryft, but unfortunately couldn't come up with a quick and nice example of how to do it
10:57:44 <kqr> kryft, if you are daring, you could look at how it is defined in the standard library
10:57:49 <kqr> kryft, http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#transpose
10:58:05 <kqr> kryft, it does something similar to your function, but somehow manages to avoid the problem with different line lengths
10:59:07 <monochrom> perhaps there needs no boundary between function and code expression
10:59:30 <monochrom> (\x -> x && not x) is both function and code expression
10:59:55 <wuttf> I don't understand how the input consuming of parsec works. Does it consume input when something matches, like  string "abc" <|> string "abcd" does not work but string "xyz" <|> string "abc" does?
11:00:43 <monochrom> yes, string "abc" consumes input when "abc" matches
11:04:53 <luminous> thanks for the insights, I will absorb and read some more :)
11:04:54 * hackagebot hsp 0.7.2 - Haskell Server Pages is a library for writing dynamic server-side web pages.  http://hackage.haskell.org/package/hsp-0.7.2 (JeremyShaw)
11:05:55 <kryft> kqr: Thanks, I'll take a look at it at some point; at the moment I'm too tired and feverish :)
11:07:57 <Philippa> wuttf: fundamentally, parsec eats a character at a time. It's either one it wants, in which case it swallows, or one it doesn't in which case it goes "yuck!". You can use try to, er, yank characters back out of its throat if it ate some and found out part way through that a string isn't to its taste
11:09:34 <wuttf> Philippa: Yeah I littered try everywhere but then I had the feeling I don't need it when there are matches which are not prefixes of each other.
11:10:19 <Philippa> that's right
11:10:28 <Philippa> basically, you get LL(1) without trying
11:10:34 <kqr> kryft, fair enough, there's no hurry! in general, i write haskell almost on intuition. when code doesn't "feel" right (like being too low-level, or not straightforward enough) i start looking for a general principle and search for other solutions to the general principle
11:10:39 <Philippa> (...okay, someone shoot me for that one?)
11:10:52 <kqr> kryft, in your case, the padding and removing of spaces doesn't "feel" right
11:10:53 <wuttf> A lot of previously impossible things are made trivial by parsec, I love it so much.
11:10:58 * RichyB drops two drums and a cymbal off a cliff, onto Philippa. ;)
11:11:03 <dmwit> ah, not being prefixes of each other doesn't sound like the right property to talk about without try
11:11:16 <dmwit> Without try, they have to actually start with different characters, no?
11:11:39 <Philippa> dmwit: yeah
11:11:53 <Philippa> I figured wuttf meant "don't have common prefixes"
11:12:08 <RichyB> Yeah, if you don't use `try` then you get LL(1), if you do then you can get up to LL(infinity), with possibly pathological backtracking. :)
11:12:20 <kryft> kqr: Thanks, this is why having a set of solutions to compare against would be nice, but maybe I'll write them myself if I ever actually learn haskell properly ;)
11:12:22 <dmwit> But you can't go all the way to prefixes. They have to be different *on the first character*.
11:12:44 <kryft> kqr: I know the kind of intuition that you're referring to from other contexts
11:13:10 <wuttf> Yes, my english is bad, it's hard to nail the correct terminology =)
11:13:26 <Philippa> dmwit: right. "No common prefixes" includes "not even one character", but
11:13:32 <kqr> kryft, yeah, it would be really nice. on the other hand, you don't need to stress about it as long as you keep your mind open. if you do, you'll learn the preferred way of doing things in no time
11:13:49 <dmwit> Ah, I see. ok
11:13:51 <RichyB> Nesting two Parsec parsers is nice for that. You use one as a lexer and have it emit tokens that the other one turns into abstract syntax trees. That makes not-having-common-prefixes easier in the second one.
11:13:57 <kqr> kryft, i find it particularly funny to look back at python code i wrote just after i had switched from C to python. it's terrible but I don't think that affects me negatively in any way today
11:15:14 <wuttf> RichyB: Yeah the problem starts with that I kind of mixed the lexing and parsing phase which is ain't a good idea to start with
11:15:24 <Philippa> RichyB: yeah. I think I'd prefer to have something other than Parsec doing the lexing in the long run, but
11:15:24 <kryft> kqr: Yeah; actually I was just about to say that I'm pretty sure I worry far too much about writing 'good' code for my own good. It would probably be more effective to jump in and write a lot of code and learn from your mistakes. (Of course you do need to keep your mind open, but for me the problem is usually keeping it closed long enough to get something done)
11:15:36 <Philippa> wuttf: it's not a /bad/ idea, but it helps to know which functions were 'lexing'
11:15:49 <Philippa> (also, what info you want other than a raw parse!)
11:16:03 <kryft> kqr: I never wrote anything significant in C, but I knew the ANSI standard and the comp.lang.c FAQ more or less by heart :P
11:16:35 <wuttf> The thing is ready for now and now way I am going to refactor that thousand lines unless I have to :D
11:17:23 <kryft> Parsec seems really nice, in fact so nice that I'm worried that I'll never learn how to parse myself if I start using it ;)
11:17:48 <bxc> if I use ffi from ghc, my understanding is that (C-side) fopen and fread should work ok without me needing to do some specific "c environment" initialization...
11:17:51 <bxc> is that right?
11:17:57 <kqr> kryft, yeah. thing is, I often write several lines of haskell code only to realise that "wait a minute. the general principle behind this can't be new" so I look it up and sure enough, all the lines I just spent time writing can be replaced with a function call from the standard library
11:18:10 <kqr> kryft, with an open mind you go "oh great, I can make my code better now, and I have learned about a concept"
11:18:12 <bxc> kryft: you'll learn better parsing than building crazy state tables by hand
11:18:49 <kqr> kryft, with a closed mind you go "frak me, why did I write all this code for no reason at all?" and then "i'll keep my version in" or "i should stop programming now"
11:19:20 <wuttf> Actually I am quite surprised how often my code works in hs, I always modify my unit tests to see them fail, because I can't believe my eyes
11:19:24 <Philippa> kryft: learn to write Parsec :-)
11:19:28 <wuttf> Creepy, init
11:19:36 <kqr> kryft, one of my better friends is the second kind of programmer and it's a little sad seeing him give up on good stuff because he feels like the code he writes is superfluous
11:19:40 <Philippa> (or one of the alternative designs)
11:19:58 <Philippa> yeah. Nothing wrong with learning what a pattern feels like once - it's how you learn to apply it
11:20:55 <kryft> bxc: You mean .. uh, what's the kind of parsing called again where you compose lots of simple parsers?
11:21:05 <ryant5000> is there a way to determine the version of a dependency from the C preprocessor?
11:21:20 <ryant5000> i'm trying to make a package that can build with Template Haskell 2.7 or 2.8
11:21:28 <wuttf> kryft: parser combinators?
11:21:30 <bxc> kryft: parser combinators? thats parsec!
11:21:34 <edwardk> #if MIN_VERSION_template_haskell(2,7,0)
11:21:43 <kryft> wuttf, bxc: Yes, that's it!
11:21:45 <edwardk> you need to be building with cabal for it
11:21:46 <ryant5000> edwardk: great; thanks!
11:21:55 <edwardk> ryant5000: i use a lot of these kinds of constraints in lens
11:21:56 <ryant5000> yep, i am
11:21:56 <wuttf> kryft: That's how parsec works, as bxc said
11:21:59 <edwardk> there are some caveats
11:22:07 <kryft> wuttf: Yeah, so I've read
11:22:12 <edwardk> notably on old cabals you need to ensure you surround that in parens if you negate it!
11:22:27 <ryant5000> edwardk: ah, interesting
11:22:41 <ryant5000> not too surprising, though, knowing the C preprocessor :P
11:23:02 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Parallel/Strategies/Lens.hs shows an example of how i use it
11:23:07 <crl> do you know if haskell is used in trading/ broker softwares?
11:23:22 <edwardk> notably i tend to put a backup definition for MIN_VERSION_foo at the top of the module in case i'm building with ghci directly
11:23:25 <feliperosa> So, in my quest trying to understand memoization and sharing I had no luck figuring out when does haskell memoizes functions and until what point it keeps the memoized information. Anybody could help me?
11:23:57 <crl> i(ve no experiences in that, just talked to someone that said he was using an obscure c++ library
11:24:19 <edwardk> ryant5000: that at least maximizes the number of ways the code will build properly
11:24:21 <kqr> does ghc ever memoize functions?
11:24:31 <c_wraith> feliperosa: in general, assume haskell does no automatic memoization, but anything you've bound to a name is not recomputed within that name's scope
11:24:34 <crl> but some parts of haskell could fit to this domain
11:24:39 <wuttf> crl: I think finance is one of the few areas where FP is used a lot, see Jane street
11:24:43 <crl> notably
11:24:46 <wuttf> crl: They use OCaml though
11:24:49 <ryant5000> edwardk: that makes sense
11:24:50 <Philippa> edwardk: is Haskell used in trading/brokerage software? :-p
11:24:52 <edwardk> anyways the main issue was cabal used to put it in a form that if you negated it you only negated the first clause of a multiple clause expression
11:24:58 <edwardk> Philippa: yes
11:25:01 <crl> wuttf: hmm right
11:25:09 <kryft> kqr: For me it's not really a question of only finding coding satisfying if I'm doing everything myself, but a part of me is wary of using tools that I don't understand, especially if they're things I feel it would be good to be familiar
11:25:13 <kryft> kqr: with
11:25:25 <wuttf> crl: And I know a guy from the same country as me who was immediately hired by a bank in Singapore when he finished uni
11:25:25 <Philippa> crl: see what edwardk said. He'd know
11:25:32 <kryft> kqr: For instance, it's good to know how to sort even if it's rarely a good idea to actually write your own sort for production use
11:25:34 <wuttf> crl: * To code them in haskell
11:26:01 <edwardk> crl: see what the guys at tsuru capital are up to. its all low latency algorithmic trading with haskell
11:26:18 <edwardk> there are others as well
11:26:19 <fragamus> what protocol do they use
11:26:40 <crl> and also a network library, possibly http
11:26:40 <fragamus> im working on some UDP hacks
11:27:01 <crl> for showing client accounts
11:27:15 <crl> edwardk: ok noted
11:27:48 <feliperosa> c_wraith: Ok, so should I just try really understanding the sharing features of lazy evaluation?
11:28:01 <kqr> kryft, i have a hard time coming up with a situation it would be good, other than in a constructed problem such as interview questions
11:28:03 <TravisD> I find I'm using some data types a little bit like classes from other languages. I'll make a type that has a bunch of related data, and then a bunch of functions that work on the data. Is this idiomatic haskell?
11:28:09 <feliperosa> c_wraith: I mean, not bother too much about automatic memoization
11:28:16 <edwardk> fragamus: https://github.com/alphaHeavy/kospi shows some example code for using ragel with haskell that does kospi quotes over udp
11:28:19 <kqr> kryft, i'm probably burned on the stake daily for this, but I actually don't think knowing how things work is *that* important
11:28:31 <kqr> kryft, programming is all about not having to care about how things work
11:28:41 <c_wraith> feliperosa: yeah, there basically is no automatic memoization, except for some occasional common subexpression elimination.
11:28:43 <kqr> kryft, ...ironically enough
11:29:07 <Philippa> kqr: rather, about knowing what you don't have to know
11:29:25 <feliperosa> c_wraith: Right. Good to know that, this automatic memoization thing was driving me crazy
11:29:37 <kqr> kryft, i guess i could be faded since i've been up and down the software stack multiple times and starting to realise that there's no end to the "why" and "how" questions one could ask if one thinks its important
11:30:08 <Philippa> kqr: The Theory of Everything! (and then you realise it's not helpful anyway)
11:30:08 <kryft> kqr: No, that's true
11:30:14 <kqr> Philippa, ...and making sure the next guy has to know as little as possible
11:30:40 <Philippa> kqr: hrmm. There's room for precision tooling as well
11:31:10 <Philippa> IME the next girl likes to know what she's getting for the work she does
11:31:23 <kryft> kqr: One of my main arguments against my obsession of wanting to understand how my tools work is that I can't possibly understand everything anyway; I will need to rely on black boxes at some point if I ever want to actually get anything done
11:32:03 <Philippa> yep. Know those resource characteristics you care about, know the effects, forget the rest
11:32:14 <kryft> Philippa: Right
11:32:26 <crl> > reverse . filter (/=' ') $ "a man a plan a canalpanama"
11:32:28 <lambdabot>   "amanaplanacanalpanama"
11:33:33 <kryft> This has actually always been a big problem for me in general in life. :P
11:34:04 <Philippa> learn the details of stuff you can get paid to care about :-)
11:34:31 <kryft> I have only relatively recently started to realize that you really do need to accept a very limited understanding of almost everything almost all of the time if you want to get anything done and not go crazy, but it's still very difficult for me to escape the gravity well :)
11:34:39 <crl> kryft: that's actually the problem, when there's a bug on an obscure api
11:35:25 <crl> you need to dig into it, partially
11:35:50 <Philippa> kryft: 'tis a problem of modern society. We're waaaaay past the point of it being remotely possible just for the stuff we do to survive each day
11:35:52 <crl> or redo everything :)
11:36:36 <dmwit> seems orthogonal to modernity
11:36:51 <dmwit> I doubt anyone can understand their own finger perfectly.
11:38:23 <kqr> kryft, but then again, sometimes its easier to understand how to use something when you understand how it works. i'm currently in the process of learning to cook properly, and i've made some great advances since i started caring for the science-y "why" bit of it. it just makes things simpler to me
11:38:32 * typoclass . o O ( the question is also, will you become a better driver if you, among a million other things, obsess if some part deep in the bowels of the car was spot-welded or plasma-whatnot-welded )
11:39:27 <kryft> Philippa: Yup
11:39:39 <lightquake> why does readFile "/etc/passwd\0.jpg" work? that seems like it's a security hole
11:39:40 <Philippa> dmwit: we get a feel for it though, develop expertise
11:39:46 <kryft> kqr: That's entirely true
11:40:23 <kqr> lightquake, why shouldn't it work?
11:40:23 <Botje> lightquake: huh, does it? interfacing with system calls always kind of sucks :(
11:40:29 <Taneb> Seriously, who do I complain about typos in the SoC T&Cs to
11:40:34 <lightquake> kqr: i mean, it shouldn't read /etc/passwd
11:40:36 <typoclass> lightquake: you mean, you can read /etc/passwd even if you don't have permission? that seems serious
11:40:40 <lightquake> no no no i mean
11:40:50 <lightquake> it will try to read /etc/passwd, and fail if you don't have permission
11:41:09 <elliott> if you normalise the path (I think System.FilePath has a function for it or such) does it come out as "/etc/passwd"?
11:41:18 <elliott> you should be normalising stuff before checking validity or whatever anyway
11:41:34 <kqr> lightquake, /etc/passwd is often world-readable on unix systems, so isn't that the expected behaviour?
11:41:45 <lightquake> elliott: nope
11:41:53 <kryft> kqr: I've studied quite a bit of math, and I've always suffered from the same fallacy there: I would try to understand a theorem as generally as possible before I would actually try to apply it. Of course in practice it's generally easier to understand a proof once you've played around with its consequences
11:42:07 <lightquake> kqr: well, I would expect it to say 'what the hell, you gave me a path with a null byte' and choke
11:42:23 <lightquake> this is what python does, for example
11:42:44 <typoclass> lightquake: right, that's reasonable. it feels like it should do that
11:43:05 <typoclass> ... instead of silently changing the path and using only part of it
11:43:07 <lightquake> ‚Ä¶ wait, i think i filed this, and it got closed as WONTFIX
11:43:09 <michaeltbaker> Hello, I'm trying to understand how STM is implemented in Haskell. I've found several research papers about it, but none of them seem to cover the low-level implementation. In particular I'm interested in how the values of multiple TVars are committed atomically. Can anyone point me to a description or paper about the low level details of Haskell's STM?
11:43:17 <kqr> kryft, don't get me started on maths. i really don't get why everyone needs to learn how to do everything symbolically when they could become masters of numerical methods which are actually usable in real life too
11:43:39 <lightquake> i should file it against *something* though
11:43:42 <kqr> lightquake, oh, of course. i missed the null byte
11:43:53 <Philippa> kqr: you have numerical methods for refactoring code? :p
11:44:13 <elliott> kqr: symbolic methods don't work in real life?
11:44:16 <kqr> Philippa, that's where i apply my monte carlo refacto... maybe not.
11:44:35 <kqr> elliott, oh they do, but the majority will never use them again
11:44:39 <typoclass> lightquake: do you have a link? i'd be interested in the explanation they offered for the WONTFIX decision
11:44:42 <`ramses> kqr: numerical methods wont teach you the same type of abstract reasoning
11:45:06 <lightquake> lemme search the bug tracker
11:45:29 <`ramses> kqr: neither would it allow to deduce e.g. complex physical theories and such, as those are built on concepts, not on numbers
11:45:36 <kqr> `ramses, i would like to see more effort put into logic, statistics, probability and programming for the abstract reasoning
11:45:39 <lightquake> http://hackage.haskell.org/trac/ghc/ticket/5741
11:45:52 <kqr> `ramses, and i don't think your average joe is going to work with deducing complex physical theories
11:45:58 <Philippa> `ramses: the way I was taught symbolic methods didn't teach me much but another round of having to develop some heuristics. Maybe the teaching sucked
11:46:25 <lightquake> they closed it because you should do that checking yourself
11:46:30 <lightquake> which‚Ä¶ i don't know if i believe
11:46:44 <colah> I'm trying to do geometric constraint solving in Haskell. I have constraints like "the distance between these points is..." and "the angle made by these points is...". Constraints act on multiple points, forming a hypergraph. I was wondering if anyone had recomendations on data structures or algorithms that would make it easy to: split unrelated sub graphs, lookup constraints by points, add and remove consraints.
11:46:44 <kqr> `ramses, also what Philippa said
11:47:20 <`ramses> maybe I misunderstood "symbolic" in this context.. I thaught you were saying you thought they should teach numerical methods instead of abstract math
11:47:42 <lightquake> Filesystem.Path does report it as being an invalid file name, but...
11:47:43 <Philippa> colah: so it's a good idea to keep multiple structures so you've got indices etc
11:47:53 <Philippa> can't comment on the hypergraph aspect
11:48:02 * colah nods
11:48:58 <colah> For early prototyping, I'll probably just brute force things. But doing things right would be nice in the long run.
11:49:09 <kqr> `ramses, i just think that people should learn maths they will use, not be forced to apply rote memorisation to rules of symbol manipulation to pass a test and then forget it
11:50:05 <kqr> `ramses, computers are really good at solving equations (if nothing else, numerically)
11:50:09 <`ramses> kqr: most of the math I learned (quite a lot), I will never use, but the way it shaped my thinking is useful every day
11:50:10 <Philippa> kqr: Yeah. Learning that symbol manipulation *works* etc would be far more useful, but that's like... philosophy, the sort of stuff you can't test so the market decides it can go fuck itself
11:50:23 <kqr> `ramses, why should everyone learn to solve a limited subset by hand? (usually quadratic and perhaps really neatly organised cubic)
11:50:53 <Philippa> kqr: Having the basic experience that it can and does work, maybe some additional intuition about newtonian mechanics
11:51:00 <Philippa> (the latter is *really* useful if you're eg dyspraxic)
11:51:09 <kqr> Philippa, i don't think intuition comes from (mostly) blind symbol manipulation
11:51:09 <`ramses> kqr: because it gives understanding? How are you supposed to see the structure behind those equations if you only see numbers? It's all about the relations between those numbers
11:51:38 <Philippa> kqr: intuition comes in part from looking into and manipulating things. That includes the symbols and the system working them
11:51:43 <kryft> crl: You're right; that's probably the main reason why I would ideally like to understand how my tools work even if I don't need to reimplement them
11:51:53 <Philippa> now, I'd be happy to see a little more metalogic? The idea that there isn't *one* logic, say?
11:52:10 <kqr> `ramses, i might have been to a bad school, but most people just followed rules blindly
11:52:11 <`ramses> kqr: btw, you said you'd like to see more logic, how is that not symbol manipulation?
11:52:27 <Philippa> kqr: that's standard, yeah. And I hinted at the reasons above
11:52:28 <crl> the black box programing
11:52:29 <kqr> logic is symbol manipulation, but useful symbol manipulation!
11:52:38 <`ramses> kqr: I agree that just applying some rules is bad, but that's also not math, that's calculating
11:52:41 <Philippa> so's equation solving
11:52:44 <`ramses> kqr: math is about structure
11:53:02 <kqr> `ramses, and the problems i have with maths education where i live is that they teach just calculation
11:53:25 <Philippa> kqr: not just where you live. I hinted at reasons above
11:53:28 <kqr> `ramses, you can excel in a class by just committing the right equations to memory and then substituting mechanically
11:53:37 <kqr> Philippa, i saw that
11:53:41 <tac> kqr: logic? useful? Hmph! :P
11:53:45 <c_wraith> kqr: only if you're taking bad classes
11:53:46 <hiptobecubic> I'm not sure why I expected installing the HP to relieve packaging problems.
11:53:49 <typoclass> lightquake: thanks for the link. seems like weak arguments to me. they discussed the security aspect, but imho that's besides the point. functions should either do what you requested or indicate failure, not do some half-ass thing
11:54:01 <`ramses> kqr: happens here as well, which is really sad, cause it makes students dislike math very strongly
11:54:06 <typoclass> i wonder if i should file another bug
11:54:07 <Philippa> c_wraith: since when do kids have a meaningful choice in which they take?
11:54:25 <hiptobecubic> It's great if all you do is golf with fibonacci implementations, but eventually you need to install some other library
11:54:26 <kqr> tac, you should see the looks people give me when I show their arguments are false through transposition
11:54:27 <c_wraith> Philippa: I did. *shrug*
11:54:30 <lightquake> typoclass: i wonder if i can make persuade them that it shouldn't always fail if there are null bytes, but that it should do so on systems where null bytes can't be in paths
11:54:37 <lightquake> (which is probably *all* of them)
11:54:51 <Philippa> c_wraith: you're lucky. I got yay-or-nay on a few subjects and that was it until university
11:54:53 <lightquake> hiptobecubic: it worked decently for me
11:55:02 <hiptobecubic> That library hasn't been sitting dormant for the last six months, so now it needs things that you don't have
11:55:26 <hiptobecubic> and before you know it, you are depending on multiple versions of some fundamental package like bytestring
11:55:35 <lightquake> ah, that one
11:55:44 <hiptobecubic> HP is great alone.
11:55:46 <lightquake> yeah, people with dependency upper bounds annoy me
11:55:53 <lightquake> that's why i don't use them :)
11:56:09 <`ramses> kqr: I think it is very hard to get math education right though, it's difficult to get kids to think at a sufficient level of abstraction to make it fun (and probably not everyone is made for that kind of thinking)
11:56:11 <lightquake> also why i use hsenv
11:56:21 <hiptobecubic> But cabal install -j "allthepackagesinHP" would work fine too, because HP isn't so large and the packages are all very well maintained
11:56:55 <typoclass> lightquake: er, even if the haskell library restricts paths so that they may not contain \0, it's not like haskell is excluding lots of platforms, expectations, valid uses ...
11:57:09 <kqr> `ramses, definitely hard, yeah
11:57:12 <lightquake> typoclass: well, yeah, but i tried that argument and it didn't work
11:57:17 <hiptobecubic> lightquake, but installing 600MB of libraries for every script gets annoying very quickly. It doesn't even work in all cases. XMonad for example, won't tolerate being cabal-dev'd
11:57:26 <kqr> `ramses, but i think a good start would be to allow more experimentation and finding out relations on your own
11:57:36 <lightquake> hiptobecubic: does it tolerate hsenv? hsenv isolation is stronger, iirc
11:57:52 <Philippa> kqr: that's, er. Produces a very luck-oriented class. If you started out with the right grab-bag of intuitions, you do great - if not, you're fucked
11:57:54 <kqr> `ramses, which i also think is greatly aided by computers, since they allow you to work quickly and scrap as many ideas as you like without running out of paper
11:58:29 <`ramses> kqr: but by hiding much of the low-level technicalities, it is hard to get intuition for the stuff you're working with
11:58:31 <Philippa> sometimes you just can't see the possibility that you need to reach: the more times we force students to pass such a test, the more we force people to drop out and stop learning at all
11:58:58 <crl> o great, flash will not be updated for linux..
11:59:04 <kqr> Philippa, of course not unsupervised or unguided
11:59:10 <hiptobecubic> lightquake, it *might* ?  But we still face the issue writing out a bunch of tedious dependencies in a cabal file and then waiting ten minutes for it to pull them all down every time you write a new toy
11:59:40 <kqr> `ramses, i'm not too sure
12:00:04 <lightquake> hiptobecubic: so you want something that figures out dependencies from your import list or something?
12:00:05 <kqr> `ramses, i have not learned the low-level technicalities of a few subjects because I frankly found them boring and I had other things in my life going on at the time
12:00:26 <`ramses> I think the repeated exercising is not bad per se, but I think it should be augmented with more conceptual reasoning (now what exactely is that derivative? Can we understand why these rules are true?)
12:00:29 <kqr> `ramses, this has *forced* me to develop an intuition so that i can make calculations without really... calculating
12:00:38 <hiptobecubic> lightquake, that would make this less annoying sure. In reality it would be nice to have a package manager instead of cabal.
12:01:12 <lightquake> sure
12:01:13 <Philippa> kqr: how does that work for you when you have to work in a different formal system?
12:01:45 <hiptobecubic> well anyway. I guess I'll torch ~/.cabal and ~/.ghc *again* and avoid the platform and try this one more time
12:02:01 <typoclass> hiptobecubic: what new functions would cabal need? i thought the "cabal is not a package manager" critique boiled down to "there no cabal-remove command"
12:02:05 <kqr> `ramses, yeah, exactly. and i think the starting point should be the "what is a derivative? what are the possible interpretations of dx?" and not "d x^n/dx = nx^(n-1)"
12:02:29 <kqr> Philippa, i usually don't, and I don't think that the majority of people going to highschool will have to ever in their lives either
12:02:44 <hiptobecubic> typoclass, you say that like it's not a critical feature.
12:03:03 <hiptobecubic> typoclass, but more importantly, not doing something that is guaranteed to fail would at least be a good start
12:03:05 <kqr> Philippa, i'm not saying we should banish formal reasoning, i just don't think it's very useful to force it upon people with maths
12:03:09 <Philippa> kqr: hah. Ever dealt with a bureaucracy?
12:03:13 <kqr> Philippa, since maths is such a useful subject even outside of formal reasoning
12:03:19 <`ramses> kqr: "will never have to" is no reason, I'll probably wont find much use for many things I've learned
12:03:25 <hiptobecubic> typoclass, like installing two versions of bytestring at once
12:03:44 <`ramses> kqr: but the very act of learning them, learned me a lot of useful things
12:03:53 <kqr> `ramses, it's a very good reason when it's at the expense of things which could be used often
12:04:20 <monochrom> hiptobecubic: you need my http://article.gmane.org/gmane.comp.lang.haskell.cafe/103083/ to insure package sanity, HP or not.
12:04:20 <hiptobecubic> even a sledgehammer command like "cabal scorched-earth -j" would be helpful.
12:04:25 <kqr> `ramses, i don't have a particular example at hand, but i believe the general population could be much more proficient in maths if the focus wasn't on formal reasoning but on solving problems and getting okay answers
12:04:32 <`ramses> kqr: I could have learned how to fix my car instead of studying physics, but I'm glad I didn't :)
12:05:06 <`ramses> (maybe this discussion should be taken to #haskell-blah...)
12:05:10 <Philippa> kqr: approximation's just another formal system
12:05:32 <Philippa> all programming sure as hell is
12:05:41 <Philippa> (that's what it means to compute!)
12:05:52 <hiptobecubic> monochrom, I'm not sure I understand why cabal needs us to tell it which packages it has installed already.
12:06:30 <monochrom> I know why. because the authors are pros and they think it's so easy to solve problems manually
12:06:44 <monochrom> also, programmers are upgrade whores
12:06:48 <hiptobecubic> If this thing works, it should probably also be distributed with the platform.
12:06:54 <lightquake> monochrom: don't use that word, thanks
12:07:08 <monochrom> why not?
12:07:45 <`ramses> kqr: I would be really bored if I'd had too learn a gazillion different ways to actually solve differential equations instead of learning about their abstract properties
12:08:08 <lightquake> because you shouldn't insult people by comparing them to sex workers?
12:08:11 <`ramses> s/too/to
12:08:19 <hiptobecubic> he didn't say sex worker
12:08:36 <Philippa> no, he didn't, but that's what the word means
12:08:39 <kqr> `ramses, my hypothesis is that you (and me) aren't representative of the average person who goes to high school.
12:08:41 <monochrom> hiptobecubic: my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml#correction has the exact list for two HP versions
12:08:46 <kqr> lightquake, is it insulting to be a sex worker?
12:08:52 <typoclass> hiptobecubic: hmmm ... not sure. it seems like a reasonable change that could happen with some new cabal version. "cabal now defaults to using --constraint=everything-installed". it doesn't seem like a fundamental thing that requires cabal to go and some other thing to come in
12:09:06 <lightquake> kqr: no, but insult is just as much as in the intent
12:09:12 <Philippa> kqr: nice derail attempt, did you learn it from Derailing For Dummies?
12:09:23 <`ramses> kqr: that might be :) I don't live in the us, so I am not really familiar with the school system there either
12:09:25 <lightquake> iow, it's not insulting to be gay, but you shouldn't call things 'gay' as an insult
12:09:34 <hiptobecubic> typoclass, until you finally do want to upgrade something.
12:09:50 <kqr> lightquake, oh, i misinterpreted you then
12:10:08 <`ramses> lightquake: I highly doubt any insult was intended here, so by your own words it's fine then
12:10:21 <dcoutts> typoclass: I'm not sure I get what the suggestion is here
12:10:22 <lightquake> "[15:06:32] <monochrom>	 also, programmers are upgrade whores"
12:10:29 <hiptobecubic> lightquake, which part of that is insulting?
12:10:33 <lightquake> you seriously don't think this was intended to be at least sort of insulting?
12:10:56 <Philippa> hiptobecubic: the whole damn thing. Really.
12:10:57 <Philippa> do I need to put my op hat on for this one?
12:11:37 <typoclass> dcoutts: ohai. i was asking him what specifically is his problem with cabal. i'm not entirely clear on his suggestions either
12:12:04 <dcoutts> hia :-), yeah I don't quite grok the problem yet
12:12:17 <dcoutts> and I'm not sure what your --constraint=everything-installed is about
12:12:21 <Philippa> hiptobecubic: the entire analogy involved there is fundamentally both insulting and *dangerous*. So yeah.
12:12:22 <monochrom> I fully intend to insult. but only people who upgrade without discretion. not sex workers. perhaps, a way out is to define "whore" to be different from sex workers.
12:12:24 <hiptobecubic> Philippa, no need to swear.
12:13:30 <Philippa> hiptobecubic: You're in no position to tell me off for a word as mild as "damn" right now. I suggest you listen rather than defending, because the original user clearly recognises there's a problem
12:13:34 <typoclass> dcoutts: that was because monochrom linked to http://article.gmane.org/gmane.comp.lang.haskell.cafe/103083/ which recommends cabal install --constraint="bytestring installed" ...
12:13:37 <hiptobecubic> Well I can think of an entire army of people who take pride in constantly updating everything willy nilly (cough arch.. cough)
12:13:44 <dcoutts> typoclass: ah
12:13:57 <Philippa> monochrom: Not really. It's an entire class of analogy that needs to die because the underlying association of the words won't
12:14:26 <lightquake> "perhaps, a way out is to define "whore" to be different from sex workers." well, if you can somehow figure out how to change the english language by yourself...
12:14:31 <dcoutts> typoclass: it's ok but only for the things you really don't want to change, like things in the HP, in general it'll prevent you from finding solutions
12:14:31 <Philippa> monochrom: it's not an accident that similar words for the concept you want all have these kinds of problem, unfortunately
12:14:34 <hiptobecubic> Philippa, You're absolutely right. monochrom saying "whore" is a perfectly good reason for you to say damn to me and threaten your "op hat" powers.
12:14:44 <typoclass> dcoutts: right
12:15:24 <lightquake> hiptobecubic: who gives a shit about swearing, really
12:15:25 <Philippa> hiptobecubic: me feeling like it's a perfectly good reason to say damn, it's not an infrequently used word in here. If you don't understand the relevance of an op's role in defining what's appropriate in this channel, that is your problem, not mine
12:15:50 <Philippa> monochrom: thank you for the willingness to discuss, much appreciated
12:15:52 <hiptobecubic> My point is simply that it's not at all constructive and no one did anything to merit aggression in the first place.
12:15:57 <dcoutts> typoclass: the "right thing"tm, I now think, is that we try to add a package to the environment -- consistent with all other things in the environment -- and then if that's not possible we tell users they have to chuck out certain packages from their env or create a new env that will accommodate the thing they want. But never allow an env with multiple versions of the same package exposed.
12:16:15 <Philippa> hiptobecubic: mine is that you need to stop telling me how to do my job
12:16:24 <dcoutts> typoclass: but that does rely on being able to make new envs quickly and easily, and also to share packages between them ,ie a nix-like system.
12:16:34 <Cale> lightquake: The way to change the English language is just to use it differently. There's no standards body defining what words mean, it's just general consensus of usage. That said, this entire thread of discussion is offtopic.
12:16:46 <Philippa> now, we in fact seem to have a constructive outcome that's being buried under - well, the derailing you've carried out. Gee, never seen that before.
12:17:07 <Philippa> Cale: yeah, we might not have consensus but I think we have a degree of understanding at least
12:18:28 <Cale> Yeah, it's important to understand someone's intent when they use words rather than outright complaining that certain words have been used, I think.
12:18:57 <hiptobecubic> Anyway, while we're on the topic of derailing. The original problem was that is extremely difficult to keep the installed package base consistent. I was wondering why cabal is even willing to allow it, considering it installs *every* package.
12:19:01 <typoclass> hiptobecubic: just to voice this, i agree with Philippa on everything she has said about the matter. i suspect the vast majority does. it's okay if monochrom originally wasn't aware; he was told, and was open to suggestions. there's no basis for your claim "nobody did anything".
12:19:36 <hiptobecubic> typoclass, "nobody did anything to be aggressive about" is not at all the same "no one was wrong about anything"
12:19:55 * hackagebot pgsql-simple 0.1.2 - A mid-level PostgreSQL client library.  http://hackage.haskell.org/package/pgsql-simple-0.1.2 (ChrisDone)
12:19:56 <hiptobecubic> I don't think 'whore' is a great description either.
12:20:02 <Philippa> Cale: so, er. I don't think there's something wrong with pointing out that the words themselves are an issue so long as that's done on an understanding basis (and that is /also/ defined in terms of the individuals discussing it)
12:20:46 <Philippa> hiptobecubic: Cale said can it. Can it.
12:20:51 <dcoutts> hiptobecubic: "allow it", you mean install multiple versions of the same package?
12:20:56 <hiptobecubic> dcoutts, yes
12:21:00 <Cale> On the actual question, I think there's a place for some kind of "vertical slicing" of Hackage into sets of package-versions which are intended to be consistent with one another.
12:21:11 <typoclass> Cale: i think intent can be considered, but there's limits. otherwise "i wasn't aware, i didn't intend" would forever protect people and no behavior would ever need to change
12:21:46 <dcoutts> hiptobecubic: because in general you want to have multiple versions of things
12:21:59 <lightquake> Cale: I think this is the problem things like yesod-platform intend to solve
12:22:03 <hiptobecubic> dcoutts, when would you want that?
12:22:23 <dcoutts> hiptobecubic: when developing something, or if you have packages that need different versions of a dependency
12:22:23 <simpson> Cale: I like that idea. I think that the big problem is that there are so many tiny packages out on the edge that only barely participate in Haskell packaging conversations.
12:22:35 <Cale> typoclass: If someone clarifies what they mean by a word by providing a definition or additional constraints on its meaning, I stop caring at that point what other meanings that word might have.
12:22:46 <dcoutts> hiptobecubic: what we didn't initially realise is that it's not sufficient to do that, you actually need multiple instances of the same version of a package.
12:22:48 <hiptobecubic> dcoutts, are you referring to cabal-dev and a local package repo? That I understand.
12:23:10 <hiptobecubic> dcoutts, now I'm lost. Why would you need multiple instances of the same version of a package?
12:23:28 <Philippa> Cale: yeah, I think it's fair to say there's division amongst the ops on that front and fair grounds for alternate viewpoints though
12:23:32 <dcoutts> hiptobecubic: well, those are different approaches to solving the same problem. What you're referring to is that it's not desirable to have multiple versions of the same package in the same environment, and on that I agree with you.
12:23:40 <Philippa> anyway, too much meta
12:24:30 <dcoutts> hiptobecubic: because you have packages that depend on a common package but built against different dependencies
12:24:35 <Cale> hiptobecubic: Because those versions can be compiled against different versions of their dependencies
12:24:49 <dcoutts> hiptobecubic: if you want to imagine those living in different sandboxes, then that's fine, but you do still have them installed at the same time
12:24:54 <hiptobecubic> dcoutts, but cabal can clearly tell what is installed or not, which is how these --constraints additions work, I assume
12:25:10 <dcoutts> hiptobecubic: yes it knows what is installed.
12:25:18 <av> hello folks, I'm stuck again and need some help
12:26:11 <hiptobecubic> Cale, aha. That makes sense.
12:26:13 <c_wraith> hey av. Feel free ask without introduction. :)
12:26:16 <av> I'd like to control an external program from my Haskell code, and I'm still in search of a viable solution
12:26:40 <c_wraith> av: what sort of options does that program give for interacting with it?
12:26:43 <av> I'd like to use attoparsec for that
12:27:30 <av> the idea is this: I use attoparsec for parsing the output of the program, then use its result to feed the external program with new input
12:27:38 <dcoutts> hiptobecubic: so cabal enforces that within any single "solution", there's at most one version of each package, but it allows an environment to contain multiple versions, and that's when we run into problems
12:27:52 <hiptobecubic> i see.
12:28:07 <c_wraith> av: is the other program an interactive terminal application?
12:28:28 <av> that way, the entire interaction is encoded in the attoparsec parser -- is that possible?
12:28:43 <av> c_wraith: yes, sort of, but the interface is very simple
12:28:54 <dcoutts> hiptobecubic: what we need is to be able to install loads of things simultaneously, but then as a UI issue, arrange things so that each environment has at most one version of anything.
12:29:06 <hiptobecubic> dcoutts, in this case, strangely, it's only ghci that refuses to load this module. It will still compile and run, but loading it fails because two versions get linked
12:29:54 <hiptobecubic> I always see people pointing to the nix package manager as a working example of this, but I haven't used it and I can't say if it makes sense or not
12:30:09 <av> c_wraith: the program gives one of two prompts in an arbitrary order -- one prompt just needs new numerical value, the other means that the program waits for a new command
12:30:27 <dcoutts> hiptobecubic: then if you find that you want to install two independent things that have conflicting deps, then those two things cannot live in the same environment, and that will be explicit in the UI. Currently we just allow both to be installed, but then when you operate on the assumption that everything in your env can be used together then we run into problems (combined with the fact that currently we cannot have multiple instances of the same
12:30:27 <dcoutts>  version of a package so we end up reinstalling and breaking things).
12:30:37 <hiptobecubic> I think part of the problem is that there isn't clean separation between modules because ghc's intense optimization, yes?
12:30:45 <sm> the single-version-build-link restriction comes from GHC, and might be lifted some day, as I understand it
12:30:50 <dcoutts> hiptobecubic: no that's not a problem
12:30:50 <c_wraith> av: anyway, to answer your question...  I don't think you can do it entirely in attoparsec.  Attoparsec doesn't have an interface that lets you perform IO during the process, iirc.  Parsec does, though..
12:30:55 <sm> s/-link//
12:31:06 <sm> um.. single version per build
12:31:12 <hiptobecubic> dcoutts, ok, my understanding there is apparently no good :)
12:31:16 <dcoutts> hiptobecubic: and ghci can load multiple versions of a package, but some packages have C symbols and they do not get versioned, so that's a problem.
12:31:34 <hiptobecubic> I'm a little confused by why this compiles then
12:31:43 <hiptobecubic> but ghci cannot load it
12:31:47 <Philippa> av: nothing wrong with building another monad that has your parser inside it and is written in terms of IO
12:31:56 <dcoutts> hiptobecubic: oh that's just because the system linker ignores the second symbol
12:32:06 <hiptobecubic> ah
12:32:14 <dcoutts> hiptobecubic: presumably this is a C symbol right?
12:32:22 <hiptobecubic> for bytestring? Probably?
12:32:23 <av> Philippa: is there any code around that I can study?
12:32:32 <Philippa> it's generally worth separating out parsing from other activities though
12:32:34 <dcoutts> hiptobecubic: ah yes, so it is then, there's some C code in there.
12:32:45 <Philippa> av: um. Too much for me to know which piece is quickest to point you at (I've been around too long!)
12:33:09 <av> Philippa: start with one :)
12:33:26 <Philippa> but doing something in the vein of input <- parseInput <$> getLine works
12:33:35 <hiptobecubic> does cabal track somewhere what was installed explicitly vs pulled in as a dep?
12:33:37 <Philippa> (where parseInput has your runParser call etc inside it)
12:33:51 <Philippa> could someone else expand more here please? I'm out of date on the current libs/identifier names :-)
12:33:59 <dcoutts> hiptobecubic: so the issue here is that we've constructed an environment with multiple versions of some packages, cabal can cope with that fine because anything it builds will use only one version of anything, but ghci isn't so smart, it just picks the latest version of everything, and that can lead to using inconsistent dependencies.
12:34:35 <dcoutts> hiptobecubic: this is another reason I want to move to the UI I described, with multiple consistent environments
12:34:39 <hiptobecubic> dcoutts, that doesn't make much sense. If it picks the latest version, why is it linking two versions?
12:35:02 <av> Philippa: that's what I was thinking too, but how on earth does that input get translated into IO actions?
12:35:18 <dcoutts> hiptobecubic: it picks latest version of A and latest version of B. A needs bytestring-0.9, B needs bytestring-0.10. So both get loaded.
12:35:25 <hiptobecubic> ah
12:35:49 <dcoutts> hiptobecubic: now if you made a cabal package depending on A and B, then the solver would rebuild one or the other of A, B so that both depend on the same version of bytestring.
12:36:15 <Philippa> av: er, do a case statement and pick an action
12:36:35 <hiptobecubic> dcoutts, would we not then have multiple versions of A, B, *and* bytestring to confuse ghci?
12:36:36 <Philippa> do case Foo of {Foo -> print "Hello world!"; Bar -> launchMissiles everywhere}
12:36:51 <Philippa> (the do is redundant because one statement, but it's okay to add more)
12:36:53 <EvilMachine> Hmm‚Ä¶ I‚Äôm confused. There Control.Monad.Trans.State with State, and Control.Monad.State with MonadState. Which one do I choose?
12:37:02 <EvilMachine> (+is)
12:37:35 <dcoutts> hiptobecubic: yes, ghci would likely be more confused, and cabal not confused. Again, that's why I think it makes sense to move to a system of multiple consistent environments, it's easier for users to reason about what's going on, and tools like ghci can continue to just do the simple thing.
12:37:51 <phischu> hiptobecubic: we would like to have multiple installed versions of the same version of, say, B but we cannot so we overwrite the installed B breaking everything that depended on it
12:38:07 <phischu> dcoutts: by environment you mean set of installed packages used for compilation?
12:38:08 <monochrom> if you want to use the type class MonadState, import Control.Monad.State. if you aren't using that type class, importing either one suffices
12:38:30 <dcoutts> phischu: yes (and also a set of available source packages)
12:38:35 <EvilMachine> phischu: If you‚Äôre talking about installed packages‚Ä¶ Sounds like slotting‚Ä¶ correct?
12:38:50 <hiptobecubic> It's annoying that it works that way but i'd be willing to wait patiently if there was a "cabal --please-just-do-whatever-it-takes" flag that recursively rebuilt everything necessary
12:38:53 <dcoutts> EvilMachine: slotting is not nearly enough, we already have slotting.
12:39:09 <dcoutts> hiptobecubic: cabal does do exactly that.
12:39:11 <phischu> EvilMachine: sorry i don't know what you mean by slotting
12:39:14 <EvilMachine> dcoutts: :D Okay.
12:39:31 <dcoutts> hiptobecubic: but only for cabal packages
12:40:09 <dcoutts> hiptobecubic: if you want to set up your environment, tell cabal to install everything at once.
12:40:28 <startling> hiptobecubic: cabal install x --force-reinstalls ?
12:40:46 <dcoutts> hiptobecubic: and don't let it reinstall core packages, look at --dry-run before you let it go
12:40:54 <EvilMachine> phischu: Gentoo, for example, has slots for versions (e.g. one per major version), so you can install multiple versions of the same package at he same time. But as dcoutts said, Cabals seems to have that, so I‚Äôll keep out. :)
12:41:16 <dcoutts> EvilMachine: slotting is just multiple versions at once, we have that already. What you need it multiple instances of the same version.
12:41:22 <startling> hiptobecubic: --upgrade-dependencies too
12:41:43 <hiptobecubic> because each instance might depend on something else
12:42:03 <dcoutts> startling, hiptobecubic: avoid --upgrade-dependencies, you don't want to upgrade core packages
12:42:16 <monochrom> today you can already add two instances (same version). put one in --global and one in --user
12:42:16 <EvilMachine> dcoutts: Interesting. I have no idea what the point of that would be. How can the exact same package depend on different stuff each time it‚Äôs installed. (This is interesting stuff for me.)
12:42:29 <phischu> hiptobecubic: exactly and we cannot distinguish package instances by what they were installed with as of right now
12:42:41 <dcoutts> EvilMachine: each instance built against different dependencies.
12:42:43 <EvilMachine> monochrom: (About before Aah, so Monad
12:42:44 <EvilMachine> oops
12:42:48 <hiptobecubic> phischu, wouldn't that be as simple as a flat file somewhere with a list in it?
12:43:03 <monochrom> later today, after you learn about --package-conf (aka --package-db, aka -package-db), you can add countably many instances
12:43:04 <EvilMachine> monochrom: (About before:) Aah, so MonadState is when you want to make your *own* instance. Got it.
12:43:16 <startling> dcoutts, oh, you're right. I'm thinking of something else
12:44:14 <EvilMachine> dcoutts: Ah. Like different versions of one of its dependency‚Ä¶ Makes sense. Of course with dynamic linking and stable ABIs that should not happen in the first place, no?
12:44:29 <hpaste> ‚ÄúAndrew Myers‚Äù pasted ‚ÄúCassava conduit‚Äù at http://hpaste.org/83532
12:44:30 <hiptobecubic> stable ABI is the problem
12:44:33 <monochrom> also, if you fetch from Fedora or Debian, you can have two --global instances
12:44:45 <phischu> hiptobecubic: well sorry i wasn't clear. We do know what a package was installed with right now. But packages of the same version are installed into the same location and registered into your package database with the same id
12:45:27 <amyers> Can anyone help me understand why that doesn't type check?
12:45:46 <dcoutts> EvilMachine: in the C world, consider if you have a lib A that provides some Gtk stuff, and that lib can be built against gtk+2 or gtk+3 (but they are of course ABI incompatible) now you have two apps that use this lib, and one of them only works with gtk+2, and the other only works with gtk+3, so now you need A to be installed twice built against different deps.
12:46:13 <EvilMachine> phischu: Hmm‚Ä¶ now I know where that problem with binary came from back then, that I had on my box. Nice to know.
12:46:27 <dcoutts> EvilMachine: C can get away with this some of the time because they can do stable ABIs, but they cannot always do it, so the same problem exists, but to a lesser degree
12:47:36 <hiptobecubic> I guess what I am imagining is an associative list where you have packages with unique ids mapped to lists of packages that depend on it, and also a bit that indicates if this package has been installed explicitly or not
12:48:08 <dcoutts> hiptobecubic: we've got something like that, see ghc-pkg dump | less
12:48:24 <dcoutts> hiptobecubic: and ~/.cabal/world
12:48:59 <EvilMachine> dcoutts: Makes perfect sense. And I just realized something: If you have one package, that builds against two different incompatible versions of the same lib, then really you have *two* packages. It‚Äôs like it‚Äôs not a package, but a package *function*. And compiling is running the function. It‚Äôs a single package/function, but it results in two different installed packages, depending on its parameters/libraries.
12:49:01 <hiptobecubic> these two together seem to cover it then. world is only things you've cabal installed manually yes?
12:49:18 <dcoutts> hiptobecubic: yes, though of course we currently lack uninstall, so it only grows
12:49:25 <hiptobecubic> yes
12:50:09 <EvilMachine> dcoutts: So if the installer (e.g. Cabal) handles such a package, it must treat the target as just two unrelated packages, complete with different names and all.
12:50:13 <dcoutts> EvilMachine: yes, they're all functions of their deps, a bit like ML functors
12:50:19 <EvilMachine> dcoutts: But I guess you‚Äôre way aread of us. :)
12:50:19 <hiptobecubic> So then as long as one uses cabal for *everything*, things will be rebuilt as needed if such an arrangement is indeed possible?
12:50:22 <EvilMachine> us=me
12:50:24 <cajla> cant say I'm a fan of systems like cabal
12:50:24 <EvilMachine> oops. :)
12:50:42 <cajla> Can I be allowed to have one package system instead?
12:50:43 * EvilMachine sings ‚ÄúThe many‚Ä¶ sing to us‚Äù
12:50:54 <phischu> EvilMachine: After a package is installed we call it an "instance" of a package (and I find this distinction very important)
12:51:02 <dcoutts> EvilMachine: certainly it has to identify the installed instances separately, but as a developer you don't want to give them different names, that would not scale.
12:51:25 <dcoutts> hiptobecubic: yes, exactly, but it does leave ghci / ghc --make with a problem.
12:51:45 <phischu> dcoutts: the developer should not specify instances (or should she)?
12:52:05 <dcoutts> phischu: the author should not, right. The builder can do that if they care.
12:52:09 <hiptobecubic> dcoutts, additionally, if the linker is just ignoring the extra symbols... certainly something is using the *wrong* version of bytestring then?
12:52:24 <cajla> I would argue you can't make a broad statement for or against all dependencies like that
12:52:30 <EvilMachine> cajla: In Gentoo, Portage (the package manager) has a class for Cabal, and even a generator that allows you to make a package out of any Cabal package. So really, Portage uses Cabal (the distribution-agnostic Haskell package manager) internally, which, I think, is actually quite nice.
12:52:40 <filipe> hey there. can somebody please tell me which form is more common in haskell, "contains" or "contains2" or none? https://gist.github.com/anonymous/5094156
12:52:46 <dcoutts> hiptobecubic: the C code in bytestring is being linked in twice and the second ignored, that's technically rather dodgy, but the C code in there doesn't change so in practice that'll work.
12:52:50 <cajla> EvilMachine: sounds fantastic
12:52:58 <EvilMachine> phischu: Yes, ‚Äúinstance‚Äù is a great word to describe that.
12:53:00 <cajla> That is exactly how I want i tto work
12:53:39 <cajla> If a community wish to have a package system it should do it at an abstraction level that allows others to do that
12:53:53 <dcoutts> hiptobecubic: the "right thing"tm would be for the C symbols in the lib to be versioned with the package, like the Haskell symbols are.
12:54:08 <hiptobecubic> Why aren't they?
12:54:19 <hiptobecubic> EvilMachine, does that uninstall successfully?
12:54:25 <dcoutts> hiptobecubic: we don't currently have a good way to do that
12:54:28 <cajla> Because C is archaic
12:54:56 * hackagebot fay 0.14.2.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.14.2.0 (ChrisDone)
12:55:03 <typoclass> filipe: hello. both look fine to me. contains2 is a little longer, so i probably would prefer contains
12:55:10 <EvilMachine> hiptobecubic: In Gentoo, everything uninstalls successfully. :)
12:55:12 <cajla> C is not a language designed for humans or the scale of software projects it is used for today
12:55:26 <cajla> It is a 70's replacement for ASM
12:55:32 <amyers> hello, can someone help me understand why this doesn't type check? http://hpaste.org/83532
12:55:41 <typoclass> filipe: note that inside of the 'where', you can still see the 'x' from line 8. you don't need to repeat it as an argument to c
12:55:46 <cajla> See it as the other BASIC
12:55:48 <amyers> It's a small attempt at writing a conduit parser using cassava
12:55:50 <filipe> typoclass: thanks! is there a rule of thumb to choose between both when length is the same?
12:55:59 <EvilMachine> hiptobecubic: I always see ‚Äúregistering package with GHC‚Äù and ‚Äúunregistering package with GHC‚Äù when the update runs.
12:57:29 <hiptobecubic> EvilMachine, sounds right.
12:57:32 <EvilMachine> cajla: You could ask the guys over at #Gentoo-Haskell how they did it. I found them generally quite friendly. :)
12:58:12 <cajla> Im quite tempted to switch over to gentoo because of that fact alone
12:58:18 <dcoutts> cajla: the Cabal format and interface were designed to be able to be translated into native packages, and there are several cabal->native tools
12:58:43 <dcoutts> cajla: it's the way it's done for fedora, gentoo, arch, debian, nixos, and probably more.
12:58:44 <typoclass> filipe: wait, looking at it more closely, i would definitely prefer contains. it has the 'Empty' case clearly handled in one place. in contains2, the 'Empty' is in two places (lines 18, 19). this also raises the question what happens if use an empty tree: "contains2 Empty 123" will crash, where "contains Empty 123" will correctly give False
12:58:54 <EvilMachine> cajla: C is the assembler of today. It has good uses, and bad ones. :)
12:59:33 <tdammers> EvilMachine: pffff... JavaScript is the new assembler :P
12:59:52 * EvilMachine is a bit afraid and a bit curious of the times when Haskell will be ‚Äúthe assembler of today‚Äù. Or ‚Ä¶ JavaPHPScript. *shudder* :D
13:00:21 <int-e> tdammers: are you thinking of http://bellard.org/jslinux/ ?
13:00:34 <tdammers> int-e: among other things, yes
13:00:46 <tdammers> but more along the lines of Fay and CoffeeScript and such
13:00:53 <croikle> amyers: it looks like Conduit isn't a monad. Pipe is, and Conduit is a specialized version, which fixes the contained type to (), among other things
13:01:48 <filipe> typoclass: hm, refactored it to https://gist.github.com/anonymous/5094244
13:02:02 <EvilMachine> cajla: Gentoo‚Äôs problem is that you *have* to read up, configue and decide everything. Good for learning, or when you like that anyway. Bad when you want it to ‚Äújust work‚Äù. And of course the endless compilations. But this is hugely OT.
13:04:57 * hackagebot uu-parsinglib 2.7.4.2 - Fast, online, error-correcting, monadic, applicative, merging, permuting, idiomatic parser combinators.  http://hackage.haskell.org/package/uu-parsinglib-2.7.4.2 (DoaitseSwierstra)
13:05:09 <amyers> croikle: ah, so that's why the type error mentions ConduitM?
13:06:04 <typoclass> filipe: much better!
13:06:25 <filipe> typoclass: alright! thanks again man
13:06:34 <croikle> hmm, I have an old version of conduit, so my complaint may not be valid
13:07:39 <amyers> croikle: I think you're still correct, the latest version has
13:07:40 <amyers> type Conduit i m o = ConduitM i o m ()
13:07:47 <croikle> so replace Pipe with ConduitM, yeah
13:09:36 <hpaste> av pasted ‚Äúblocking lazy attoparsec‚Äù at http://hpaste.org/83533
13:10:00 <av> Philippa: so what's wrong with this code: http://hpaste.org/83533 ?
13:10:19 <amyers> I see, I need  to use Sink here
13:10:32 <amyers> because I'm not expecting anything downstream
13:10:39 <amyers> It just consumes the input or fails
13:10:59 <amyers> Thanks croikle!
13:11:11 <croikle> ok, good luck
13:12:10 <ktosiek> is there a text encoding guessing library for Haskell?
13:12:22 <monochrom> I think no
13:12:32 <elliott> iirc yes
13:13:00 <Philippa> av: Honestly? There's not enough for me to tell what's happening there. Someone else is probably in a better position to figure it out
13:13:03 <ktosiek> something I can toss a ByteString at, with some prefered encodings, and get Text and encoding would be perfect :-)
13:13:34 <elliott> though now I cannot find it
13:13:35 <`ramses> is there a flag for cabal to see how the dependency resolution gets to its conclusions?
13:13:43 <dcoutts> -v
13:14:09 <monochrom> or -v2, or -v3. try them in that order until you see what you want
13:14:25 <`ramses> dcoutts: ah -v3, tried -v but that wasn't enough
13:14:33 <av> anyone else, what's wrong with http://hpaste.org/83533 ?
13:15:16 <typoclass> filipe: here's a suggestion http://hpaste.org/83534. i like to avoid overly long lines (overly indented lines), but it's a matter of taste
13:15:18 <bxc> does your interactive process read input
13:15:19 <monochrom> although, dcoutts, have you seen chrisdone's https://plus.google.com/102125020195927401442/posts/EEshZadTXKq ? :)
13:15:21 <bxc> av: ^
13:15:39 <av> bxc: it does
13:16:00 <bxc> av: but you don't send it any in that fragment?
13:16:14 <dcoutts> monochrom: mm, a less than stellar error message
13:16:14 <filipe> typoclass: oooh now that's proper
13:16:16 <av> bxc: no
13:16:35 <monochrom> of course, he hasn't shown -v3, so I don't know how bad it is
13:16:53 <typoclass> filipe: well it's really not very far from your original "contains1" :-)
13:16:58 <bxc> av: does it make output before it wants input?
13:17:02 <monochrom> P.S. amelia is the software behind hpaste
13:17:25 <gwern> @quote
13:17:25 <lambdabot> MarkPilgrim says: "In the long run, the utility of all non-Free software approaches zero. All non-Free software is a dead end."
13:17:49 <monochrom> it's perfectly possible that external_program is also blocking because it awaits data from you
13:17:50 <filipe> typoclass: nice! thanks again
13:17:54 <simpson> That doesn't sound like him at all.
13:17:55 <simpson> @quote
13:17:56 <lambdabot> <ksf> says: duh, we can't run out of energy, as there's a fixed amount of it.
13:18:00 <typoclass> filipe: you're welcome
13:18:12 <EvilMachine> av: Something with lazyness and it being interactive, causing a deadlock? (Just guessing)
13:18:18 <bxc> EvilMachine: thats what i'm thinking
13:18:30 <bxc> EvilMachine: and maybe output buffering in the process
13:18:31 <elliott> @remember ksf duh, we can't run out of energy, as there's a fixed amount of it.
13:18:31 <lambdabot> Good to know.
13:18:32 <EvilMachine> av: I‚Äôd try making everything you can strict
13:18:34 <elliott> @forget <ksf> duh, we can't run out of energy, as there's a fixed amount of it.
13:18:34 <lambdabot> Done.
13:18:40 <EvilMachine> bxc: exactly
13:19:11 <bxc> av: are you prepared to disclose your external_command to the channel?
13:19:32 <jfischoff> if I have a :m Data.List in my global .ghci file what else do I need to do to have the definitions in scope?
13:19:54 <av> av: no I'm afraid, but at this first stage it simply outputs a prompt and waits for input.
13:20:05 <croikle> you could try hGetNonBlocking and see if there's anything
13:20:07 <monochrom> sorry, "the definition" of what?
13:20:07 <av> bxc^
13:20:19 <av> my hpaste code output something like this:
13:20:20 <jfischoff> the definitions in Data.List
13:20:57 <jfischoff> i.e. I would like to be able to open ghci and be able to use transpose without importing Data.List
13:21:01 <EvilMachine> av: I remember a blog post or wiki or something about that exact problem.
13:21:02 <monochrom> I don't understand. why "definition" not "names"? "names" means you can use "sort [1,3,2]". is that enough?
13:21:10 <jfischoff> yes names
13:21:11 <av> Done Chunk "all but the first character of the prompt"    -- there is a space after the second " and then nothing
13:21:12 <jfischoff> sorry
13:21:18 <monochrom> ok, then it already works
13:21:23 <jfischoff> odd
13:21:30 <jfischoff> its not working for me
13:21:33 <monochrom> but let me try
13:21:36 <jfischoff> but the prompt setting is
13:22:01 <av> EvilMachine: can you tell me where?
13:22:01 <jfischoff> I have my fancy Œª> which is a start
13:22:13 <EvilMachine> av: I wish I still knew‚Ä¶ :/
13:22:41 <monochrom> I just tried. "transpose []" is not an error
13:22:47 <jfischoff> hmm
13:23:11 <jfischoff> well at least I had the right idea
13:23:19 <monochrom> (of course, I had to restrict permission flags to avoid "*** WARNING: /home/trebla/.ghci is writable by someone else, IGNORING!". I hate that with all my heart.)
13:23:21 <croikle> av: the Done result returns the entire leftover input
13:23:29 <croikle> which is not complete, hence it can't finish
13:23:51 <croikle> try something like parseOnly to get the prompt back
13:24:06 <jfischoff> I wonder if there is ordering issue?
13:24:13 <av> croikle: sure, but it's a lazy ByteString just like the result of hGetContents
13:24:21 <monochrom> do you have other :m commands afterwards
13:24:55 <monochrom> use ":m + Data.List", ":m + Control.Monad" etc so they are accumulative, not overriding.
13:24:55 <croikle> it's trying to show it to you, which requires it to read it completely :)
13:25:03 <av> croikle: which, on the other hand, does finish
13:25:12 <ktosiek> is there any way to check if given code may throw an exception?
13:25:45 <Kinnison> monochrom: Just FYI, because I find it easier to type, you might find 'import Data.List' and then 'import Control.Monad' easier to type, even in ghci
13:26:04 <jfischoff> monochrom: thats it
13:26:23 <jfischoff> thanks
13:29:57 * hackagebot fastcgi 3001.0.2.4 - A Haskell library for writing FastCGI programs  http://hackage.haskell.org/package/fastcgi-3001.0.2.4 (ChrisDone)
13:30:09 <monochrom> you can also ":m + Data.List Control.Monad ClassyPrelude Data.Bytestring.Char8.Die.Die.Die" in one go. this has no "import" equivalent. \‚à©/
13:31:01 <Kinnison> monochrom: :-)
13:31:21 <Kinnison> monochrom: I taught myself to always 'import Foo' because otherwise I have a tendency to forget the +
13:31:23 <edwardk> Data.ByteString.Char8.Die.Die.Die sounds fun
13:32:06 <monochrom> it's how a lot of newsgroups are named. alt.celebrity.<the celebrity name here>.die.die.die
13:33:00 <edwardk> sure
13:33:03 <monochrom> module Data.Bytestring.Char8.Die.Die.Die(module Data.Text) where { import Data.Text }
13:33:16 <shachaf> alt.lang.deutsch.die.die.die
13:33:37 <edwardk> Alt.Swedish.Chef.Bork.Bork.Bork
13:34:07 <monochrom> my unfathomable knowledge of newsgroup names shows my old age
13:34:36 <monochrom> (find me in alt.algebra.help and comp.lang.haskell !)
13:34:57 * hackagebot snap-app 0.1.5 - Simple modules for writing apps with Snap, abstracted from hpaste.  http://hackage.haskell.org/package/snap-app-0.1.5 (ChrisDone)
13:37:17 <av> croikle: here's another try:    take 10 $ maybe undefined id $ maybeResult $ parse (count 1000 anyChar) h
13:37:48 <av> croikle: doesn't finish -- how can I make it to?
13:37:56 <shachaf> @ty maybe undefined id -- creative way of writing it
13:37:58 <lambdabot> Maybe b -> b
13:38:06 <shachaf> It still counts as fromJust, though.
13:38:57 <av> shachaf: good point, I missed that one... I promise to use fromJust in the future
13:39:00 <croikle> is there 1000 chars of input expected?
13:39:18 <av> croikle: no, but I'm only asking for the first 10, thus the take
13:39:24 <shachaf> av: No, don't use fromJust
13:39:27 <shachaf> It's evil.
13:39:49 <shachaf> (maybe undefined id is also evil. Arguable more evil.)
13:39:52 <croikle> the parser doesn't know if it will succeed until it reads 1000, right?
13:40:08 <av> shachaf: sure, I don't use it in real code :)
13:41:39 <av> croikle: the question is -- how do I write a better piece of code that works that way?
13:41:56 <BigEndian> I've found what seems to be a bug in ghc 7.6.2 when running in interactive mode, where might I go about reporting this?
13:42:19 <croikle> av: have you tried parseOnly? that's what I usually do
13:42:46 <croikle> parseOnly (count 10 anyChar) h
13:44:11 <av> croikle: that's fine, but I was thinking of using a "continuous" parse that spits out parts of my (long) parser as it finds them -- so you're saying that that doesn't work?
13:44:45 <croikle> hmm, maybe (many anyChar)
13:45:13 <cariveri> Hi there. is there alternatives to MVC architecutes, that are more haskell fit ?
13:46:24 <av> croikle: that would just give me the entire input back :(
13:47:40 <av> croikle: also, parseOnly doesn't allow me to continue parsing the input after the proper IO action has completed
13:48:23 <croikle> okay, so you want results to be output before the input is fully read? hmm
13:48:50 <av> croikle: correct
13:50:17 <croikle> maybe you need to run the looping yourself, reading Done results from single-element parser and feeding it. That seems a bit annoying, though.
13:51:02 <croikle> a single parser can't output data until complete, because it might fail later in the input
13:51:25 <byorgey> yeah, parsec is simply not set up to parse lazily.  The entire input must be consumed before you can get anything.
13:51:34 <byorgey> a lazy parser has to be structured quite differently
13:52:08 <croikle> you may be able to build a "parseMany" function
13:53:39 <av> thanks guys, I'll give it some more thought
13:55:30 <monochrom> see my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#yield-intro for how to run parsec incrementally!
14:00:24 <byorgey> oh, sweet!
14:01:36 <byorgey> monochrom++
14:04:58 * hackagebot io-streams 1.0.0.0 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.0.0.0 (GregoryCollins)
14:05:00 * hackagebot openssl-streams 1.0.0.0 - OpenSSL network support for io-streams.  http://hackage.haskell.org/package/openssl-streams-1.0.0.0 (GregoryCollins)
14:16:34 <hpaste> croikle pasted ‚ÄúparseMany‚Äù at http://hpaste.org/83536
14:17:10 <croikle> simple stuff, but it works
14:19:36 <croikle> av: maybe this will do what you want
14:22:03 <cariveri> ls
14:22:58 <cariveri> Hey. Im still looking for an alternative for model view controller. it jsut does not seem to be the ebst when making a gui app with hasekll.
14:25:05 <crl> is it possible from a thread to acces its threadId
14:26:01 <croikle> myThreadId seems to do that ?
14:26:32 <crl> perfect
14:27:18 <magneticduck> question!
14:27:21 <magneticduck> why doesn't (/)
14:27:29 <magneticduck> work as Float -> Float?
14:27:36 <magneticduck> err, I'm not sure if that's the problem
14:27:44 <crl> :t (/)
14:27:45 <magneticduck> but I seem to be having problems dividing two floats
14:27:46 <lambdabot> Fractional a => a -> a -> a
14:27:49 <magneticduck> fractional, eh
14:27:55 <magneticduck> so I use toIntegral?
14:28:22 <magneticduck> :t toIntegral
14:28:24 <lambdabot>     Not in scope: `toIntegral'
14:28:24 <lambdabot>     Perhaps you meant one of these:
14:28:24 <lambdabot>       `fromIntegral' (imported from Prelude),
14:28:31 <magneticduck> >_>
14:28:31 <typoclass> @instances Fractional
14:28:32 <lambdabot> Double, Float
14:28:39 <crl> > ((/) :: Float -> Float -> FLoat) 2 1
14:28:39 <mikurubeam> :t fromIntegral
14:28:40 <magneticduck> alright, so
14:28:41 <lambdabot>   Not in scope: type constructor or class `FLoat'
14:28:41 <lambdabot>  Perhaps you meant `Float' ...
14:28:42 <lambdabot> (Integral a, Num b) => a -> b
14:28:47 <magneticduck> > 0.4 / 0.5
14:28:49 <lambdabot>   0.8
14:28:52 <magneticduck> yep
14:29:00 <magneticduck> it works fine, my problem is something else
14:29:15 <crl> > ((/) :: Float -> Float -> Float) 2 1
14:29:16 <lambdabot>   2.0
14:29:19 * magneticduck is tired
14:29:19 <typoclass> magneticduck: it'd be a little weird, but maybe you don't have the instance Fractional Float imported
14:29:38 <mikurubeam> :t (%)
14:29:40 <lambdabot>     Not in scope: `%'
14:29:40 <lambdabot>     Perhaps you meant `R.%' (imported from Data.Ratio)
14:29:42 <crl> > ((/) :: Int -> Int -> Int) 2 1
14:29:43 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
14:29:43 <lambdabot>    arising from a use o...
14:30:25 <crl> > 2 `div` 1
14:30:27 <lambdabot>   2
14:30:40 <magneticduck> yeah, problem is fixed
14:30:52 <magneticduck> a funny lambda function syntax was pointing the problem to somewhere else
14:31:02 <magneticduck> but projecting it at the location of the division
14:31:05 <magneticduck> if that makes any sense
14:33:31 <typoclass> magneticduck: maybe you thought it was a Float, but really ghc inferred some other type? try adding a type signature or two. it will help you locate the root cause
14:34:06 <av> croikle: thanks, will look at it
14:34:32 <magneticduck> yeah, type signatures weren't the problem
14:35:07 <magneticduck> the problem was a bit like this: (\x -> <f x>) $ b / c
14:35:23 <magneticduck> b was inferred to be an integer because f x was of Int -> Float
14:35:29 <magneticduck> and the error was showing up there
14:35:34 <magneticduck> intead of in the function
14:40:25 <Frostix> Can someone assist me with this - http://prntscr.com/v6ala ?
14:40:59 <magneticduck> not sure what you're trying to do, Frostix
14:41:07 <magneticduck> you can't define functions like that in GHCi
14:41:19 <magneticduck> uhh
14:41:21 <magneticduck> never mind
14:41:30 <Frostix> Um
14:41:46 <Frostix> Trying to make 7 be "Lucky number 7" and every other number say "Out of luck"
14:42:15 <magneticduck> kk
14:42:16 <Frostix> so something like
14:42:19 <magneticduck> don't do it like that
14:42:22 <Frostix> Alright
14:42:28 * lispy discovers a potentially interesting article (I've only read the abstract so far): http://www.cl.cam.ac.uk/~dao29/drafts/monad-or-comonad-orchard11-draft.pdf
14:42:39 <magneticduck> I would just write a code file
14:42:50 <magneticduck> GHCi isn't good at defining functions like that
14:42:55 <croikle> Frostix: put let at the start of the line
14:42:56 <magneticduck> I've never actually tried
14:42:57 <Frostix> Ok, is leksah good?
14:43:03 <Frostix> alright
14:43:06 <magneticduck> nopenopenopenope
14:43:07 <magneticduck> :D
14:43:10 <magneticduck> just use VIM
14:43:13 <Frostix> VIM?
14:43:17 <magneticduck> bim
14:43:18 <magneticduck> *vim
14:43:27 <Frostix> I dunno what that is
14:43:31 <magneticduck> your preferred text editor, whatever it is
14:43:35 <elliott> leksah is fine
14:43:40 <elliott> if you want to use it
14:43:44 <magneticduck> well, it's not exactly...pristine
14:43:45 <elliott> notepad is fine too
14:43:58 <magneticduck> tbh, learning vim is a good investment
14:44:05 <Rembane> +1
14:44:09 <Rembane> Or emacs :D
14:44:10 <magneticduck> seeing as you've not been doing much editing in the past
14:44:18 <Frostix> I'm compltely new to this xD
14:44:19 <EvilMachine> oops
14:44:20 <magneticduck> it's a simple yet powerful text editor
14:44:24 <elliott> learning Haskell is quite enough for one person's workload without also picking up emacs or vim, I think :P
14:44:26 <EvilMachine> Frostix: I liked leksah.
14:44:29 <magneticduck> you can just run it in the temrinal
14:44:44 <magneticduck> Frostix: if you learn how to use vim, you can use it in a lot of other situations too
14:44:49 <magneticduck> and it's really awesome
14:44:50 <magneticduck> :P
14:44:55 <magneticduck> for the moment you can use whatever you want
14:45:15 <magneticduck> also, problem with your code: lucky should have type signature of (Num a) => a -> String
14:45:16 <Frostix> I'll use it when I get more expierenced
14:45:20 <magneticduck> or Integer -> String
14:45:32 * EvilMachine isn‚Äôt a masochist, and thinks VIM/Emacs is just the other extreme of Notepad, and just as bad, because it can‚Äôt scale to different skill levels.
14:45:33 <magneticduck> Frostix: it's never too early to learn something like that
14:45:38 <magneticduck> because it'll take a while to sink in
14:45:47 <Frostix> Ok
14:46:54 <elliott> Frostix: if you have a preferred text editor you already know, you might as well use it
14:47:02 <EvilMachine> magneticduck: /implying vim is ‚Äúsimple‚Äù‚Ä¶ Yes, and Notepad is a highly complex code editor too‚Ä¶ ^^
14:47:11 <Frostix> I'm just following this book and it's using ghci i think
14:47:19 <magneticduck> notepad?
14:47:22 <magneticduck> ahjahahhaha
14:47:26 <EvilMachine> :D
14:47:28 <magneticduck> Frostix: yeah, that's the interpreter
14:47:35 <magneticduck> vim is the program that you'll use to edit files
14:47:42 <magneticduck> question: are you using windows, OSx or linux?
14:47:56 <Frostix> I'm using windows.
14:48:16 <magneticduck> kk
14:48:20 <magneticduck> USE LINUX
14:48:22 <magneticduck> xD
14:48:27 <EvilMachine> magneticduck: Can we agree on C-x M-c M-butterfly? :D
14:48:30 <magneticduck> this is the day you change for the better, sir
14:48:36 <Frostix> Lol
14:48:37 <magneticduck> EvilMachine: ahaha, xkcd ftw
14:48:49 <magneticduck> Frostix: seriously, if you're going to take an investment like learning haskell
14:48:52 <magneticduck> now is the time to CHANGE!
14:48:57 <magneticduck> do you play games on windows?
14:49:01 <magneticduck> :D
14:49:05 <Frostix> Yes
14:49:12 <Frostix> Kinda why I haven't switched
14:49:12 <magneticduck> I'm giving this guy the full remake
14:49:16 <magneticduck> ahah, darn
14:49:18 <EvilMachine> magneticduck: Please don‚Äôt pressure him. Linux and even VIM are much better sold by making them attractive. Which is really easy, considering that already is the case. :)
14:49:25 <magneticduck> EvilMachine: ahah, sure
14:49:36 <magneticduck> Frostix: no pressure xD
14:49:41 <Frostix> Lol
14:50:02 <magneticduck> Frostix: so, to get set up on any OS
14:50:05 <elliott> magneticduck: Frostix wants to learn Haskell and you want them to switch operating systems and learn a new text editor at the same time?
14:50:13 <magneticduck> you need some way to run GHCi, and some way to edit files
14:50:19 <elliott> those things have nothing to do with learning Haskell, really.
14:50:25 <magneticduck> elliott: :D why not, that's how I did it. And I LOVED IT
14:50:28 * EvilMachine feels a climate of sexual tension coming up between magneticduck and Frostix, and Frostix doesn‚Äôt like ti. 
14:50:33 <EvilMachine> ti=it
14:50:43 <elliott> EvilMachine: not appropriate
14:50:50 <magneticduck> yeah, that was not exactly on my mind
14:50:59 <magneticduck> I just love introducing people to linux
14:51:26 <EvilMachine> elliott: Sorry. Wasn‚Äôt meant in an offensive way. More like a bit of friendly *nudge nudge wink wink* humor. I apologize.
14:51:35 * EvilMachine wonders how #haskell got more OT than #haskell-blah
14:51:51 <Frostix> Hmm. Haskell people are weird. I hope I don't turn out like this. o.0
14:51:54 <Philippa> yeah, pushy OS and editor advocacy doesn't belong here
14:52:05 <magneticduck> :D
14:52:10 <magneticduck> alright, let's move to another channel, eh
14:52:15 <EvilMachine> Frostix: This is not the normal state around here right no.w :)
14:52:21 <parcs> Frostix: note that you're talking to a single person at this point
14:52:24 <EvilMachine> magneticduck: #haskel-blah is fun.
14:52:26 <crl> johnw: since yesterday, i've made a sort of garbage cllector http://hpaste.org/83538, it seems memory doesn't leak like before (when I kept refreshing pages)
14:52:30 <magneticduck> Philippa: sorry, I'm kind of imposing a high pressure environment
14:52:46 <magneticduck> come to #haskell-blah if you want to talk about this stuff, Froxtix
14:52:48 <magneticduck> Frostix
14:53:15 <magneticduck> otherwise I'll just leave you alone
14:53:32 <crl> the only problem is I see exceptions like: Http: <socket: 9>: hPutBuf: illegal operation (handle is closed)
14:57:37 <Philippa> Frostix: I missed your original question, how can we help?
14:58:03 <Frostix> Ah
14:58:05 <Frostix> Well one sec
14:58:54 <Frostix> http://prntscr.com/v6dhs
14:59:07 <Frostix> am i supposed to be let in front of the other lucky's as well?
14:59:19 <EvilMachine> no, no let
14:59:24 <Frostix> ok
14:59:25 <EvilMachine> let is only for inside functions
14:59:30 <EvilMachine> and in GHCi
14:59:38 <EvilMachine> (which essentially is inside a function)
14:59:45 <EvilMachine> (a Monad to be exact)
14:59:57 <magneticduck> now YOU'RE confusing the new guy!
15:00:00 <Frostix> Should I have the semi colon at the end either?
15:00:06 <magneticduck> take this advice: don't use GHCi too much
15:00:13 <gridaphobe> Frostix: also no semicolon at the end
15:00:17 <magneticduck> Frostix: no
15:00:21 <EvilMachine> Frostix: nope. No semicolons needed in haskell, unless you want to
15:00:21 <Philippa> Frostix: you never need to add a semicolon yourself, layout is always good enough
15:00:22 <monochrom> ghci is special in many ways. it's really simpler to just say "ghci is special"
15:00:29 <magneticduck> only use GHCi to call functions, type check.. etc
15:00:36 <Frostix> It worked!
15:00:37 <magneticduck> at least, that's a good idea for a beginner
15:00:40 <magneticduck> yay!
15:00:43 <gridaphobe> :)
15:00:55 <magneticduck> now, remember that atm it's defined as (a -> String)
15:01:00 <magneticduck> you should probably change that
15:01:00 <Frostix> Oh wait xd
15:01:15 <magneticduck> not sure how you're tutorial's doing things though
15:01:23 <EvilMachine> Frostix: To be exact, semicolons is when you *want* to have multiple things on one line that would go on multiple lines normally. So unless you do a do block in GHCi, it‚Äôs really rare.
15:01:25 <croikle> How does defaulting work in that case: does the 7 match against any integral 7?
15:01:42 <monochrom> defaulting tries Integer and then Double
15:01:50 <crl> :t split2
15:01:51 <lambdabot>     Not in scope: `split2'
15:01:52 <lambdabot>     Perhaps you meant one of these:
15:01:52 <lambdabot>       `split' (imported from System.Random),
15:02:03 <Frostix> It worked :) - http://prntscr.com/v6dyk
15:02:04 <crl> :t split'
15:02:06 <lambdabot>     Not in scope: split'
15:02:06 <lambdabot>     Perhaps you meant one of these:
15:02:06 <lambdabot>       `split' (imported from System.Random),
15:02:08 <monochrom> matching against 7 is done by ==
15:02:15 <S11001001> @ty \7 -> 42
15:02:16 <lambdabot> (Eq a, Num a1, Num a) => a -> a1
15:03:12 <Frostix> I'm following this - http://learnyouahaskell.com/syntax-in-functions
15:03:45 <croikle> mono, S11: hm, neat
15:04:14 <magneticduck> LYAH is pretty good
15:04:36 <gridaphobe> LYAH is how i learned haskell, really good intro
15:05:18 <Frostix> Haskell is so simple compared to java
15:05:48 <EvilMachine> @let uglyKodeJoe x = do { in <- getLine; let worse = x ++ ": " ++ in ++ "!!!"; putStrLn worse } in uglyKodeJoe "Grumpy Cat"
15:05:48 <lambdabot>   Parse error: in
15:05:50 <magneticduck> Frostix: ahaha
15:06:07 <magneticduck> Frostix: well, the basics are kind of simple
15:06:12 <Frostix> :P
15:06:16 <magneticduck> but it quickly evolves into a form of art
15:06:17 <EvilMachine> @let { uglyKodeJoe x = do { in <- getLine; let worse = x ++ ": " ++ in ++ "!!!"; putStrLn worse }; gc = "Grumpy Cat" } in uglyKodeJoe gc
15:06:18 <lambdabot>   Parse error: in
15:06:20 <magneticduck> err
15:06:26 <magneticduck> it's a bit like a spoken language
15:06:29 <magneticduck> because it's so elegant
15:06:32 * EvilMachine fails today.
15:06:32 <danharaj> advanced Haskell is pretty straightforward
15:06:41 <magneticduck> it's math
15:06:43 <danharaj> polymorphism and type classes
15:06:43 <Rembane> Simple Haskell is very complmicated?
15:06:48 <magneticduck> math is, some would say, completely obvious
15:06:58 <magneticduck> but that doesn't mean that people spend their lives studying it
15:07:14 <magneticduck> the basic building blocks of haskell are mathematical
15:07:17 <magneticduck> simple and effective
15:07:27 <magneticduck> but again, that doesn't mean that haskell programs are simple and large
15:07:36 <magneticduck> they're compact and elegant
15:07:46 <magneticduck> (optimally)
15:07:58 <EvilMachine> magneticduck: But math *language* is a extremely non-obvious non-self-explanatory way of describing those wonderful concepts. ^^
15:08:37 <EvilMachine> magneticduck: You might be a bit‚Ä¶ hyperactive‚Ä¶ today‚Ä¶ :)
15:08:41 <magneticduck> COFFEEEE
15:08:44 <magneticduck> just kidding
15:08:47 <magneticduck> it's just this keyboard
15:09:23 <magneticduck> EvilMachine: that's because language puts into words what cannot possibly exist in logic
15:09:25 <magneticduck> :P
15:09:29 <magneticduck> haskell is just math
15:09:33 <magneticduck> that we use to compute things
15:09:42 <magneticduck> well, some might say that math can be comparable to language
15:09:45 <magneticduck> but I don't really think so
15:10:18 <magneticduck> actually I don't think a lot of people say that
15:10:34 * magneticduck will now shut up..a bit
15:11:08 * EvilMachine was just about to ignore magneticduck for being so all over the place. :)
15:12:28 <EvilMachine> Anyway, guys, thanks for the general enlightenment again. Have a good night everybody.
15:13:00 <magneticduck> all in favor of me going to bed finally say "aye"
15:13:09 <magneticduck> :D
15:13:11 <magneticduck> I won't wait
15:17:03 <parcs> christ
15:21:19 <cdntr> My feelings precisely.
15:26:27 <jaroslaw> Hi, Ive seen implementations of functions in GHC-Base and recent Data-List that have a comment such as "Stolen from HBC" ... What does HBC mean in this context? thanks
15:26:54 <elliott> jaroslaw: an old haskell compiler
15:27:07 <jaroslaw> ty elliott
15:42:53 <otters> there was a blog post a long time ago about making type-level extensible "records"
15:42:56 <otters> does anybody remember it
15:43:07 <geekosaur> @google HList
15:43:10 <lambdabot> http://hackage.haskell.org/package/HList-0.2.3
15:43:10 <lambdabot> Title: HackageDB: HList-0.2.3
15:43:18 <geekosaur> probably linked from in there
15:43:30 <geekosaur> unles syou mean some even deeper type hackery
15:43:32 <otters> I don't think it was that, but that might work
15:44:07 <otters> geekosaur: it wasn't anything complicated but it did use type operators
15:44:12 <otters> heh
15:45:37 <otters> I'm trying to define an extensible datatype that can be serialized to JSON
15:47:55 <alpounet> otters, https://github.com/jonsterling/Vinyl/blob/master/README.lhs ?
15:48:12 <otters> alpounet: yes that was it
15:50:11 <otters> requires GHC 7.6 though, shit
15:51:43 <crl> > (intercalate "ni" . axe'') "cabal"
15:51:45 <lambdabot>   "canibal"
15:57:27 <otters> okay actually, I have no idea how to do this
15:57:55 <otters> I was thinking of specifying some kind of Section class where a datatype can specify a key and a constructor function
16:02:36 <gks> So, kinda curious. Is there a reason home-brew doesn't install GHC 7.6.2? instead it installs 7.4.2
16:03:03 <gridaphobe> gks: 7.4.2 is the current version distributed with the haskell platform iirc
16:03:20 <gks> understood, so i shouldn't worry about it
16:03:36 <gridaphobe> right
16:03:45 <gks> great, thank you :)
16:06:57 <gks> can't believe how dense Real World Haskell is‚Ä¶ feel like it's going to take me months to get through it
16:07:34 <elliott> gks: have you read Learn You a Haskell?
16:07:35 <elliott> @where lyah
16:07:36 <lambdabot> http://www.learnyouahaskell.com/
16:07:39 <elliott> it's generally better to read it before RWH
16:07:45 * shachaf never got through RWH
16:07:50 <shachaf> Then again, I never started reading RWH
16:07:56 <gks> yea i tried, i felt like i was missing things. started with RWH and it's going better
16:08:15 <gks> it's just a lot of information coming from C/C++
16:08:15 <elliott> perhaps they're the things RWH doesn't cover :)
16:08:40 <gridaphobe> gks: i remember feeling like RWH got too bogged down in details for an introduction, but this was a while ago..
16:09:05 <gks> i felt like LYAH was lacking real examples
16:09:13 <gridaphobe> hehe
16:09:28 <gks> not to mention it had no exercises to try
16:09:36 <gks> so i never felt like i was really getting a lot out of it each chapter
16:09:40 <gridaphobe> i would like to see LYAH enhanced with exercises
16:09:46 <gridaphobe> right
16:10:00 <gks> i'm sure they're both great books, it would be great if they could be combined a bit lol
16:10:23 <gks> they have pros and cons. so far RWH seems to be the better book for me, but i can see how others may like LYAH
16:11:06 * dario is reading both currently
16:11:09 <hpc> at this point, both tutorials are in need of update
16:11:35 <hpc> mtl, parsec, and so many other things have had major structural changes since either was made
16:11:38 * DanBurton went LYAH then RWH, very satisfied with this progression
16:12:04 <DanBurton> that was 2.5 years ago, though
16:12:15 <hpc> i went from LYAH to the wikibook
16:12:37 <hpc> this was before the zipper chapter went up
16:12:56 <hpc> the wikibook needs a lot of work, iirc
16:13:12 <gks> ok, maybe i'll hit up the LYAH book for a bit and see if that is better after reading the first few chapters of RWH
16:13:27 <gks> certainly won't hurt i don't think lol
16:13:44 <hpc> LYAH gets the "how do i even get started" process exactly right
16:13:58 <hpc> and it teaches the functor-applicative-monad stack in the right order
16:14:02 <hpc> (with monoid interlude)
16:14:28 <simpson> And it's a little silly, which IMO is really important.
16:14:41 <DanBurton> ^ the tone of LYAH is very lighthearted and fun
16:14:58 <DanBurton> RWH is a bit more enterprisey
16:15:18 <gridaphobe> yea, i found the tone of LYAH really helpful for getting through such abstract material
16:15:52 <hpc> gonna be honest, the thing that really sold me on haskell was naming a function conanO'Brien
16:16:10 * gridaphobe doesn't remember that one
16:16:38 <gks> very beginning
16:16:39 <gks> lol
16:16:56 <gks> function chapter i think (chp 2?)
16:17:23 <hpc> that and berengal's constant postings about "i made a session-tracking webserver in 30 lines with ContT"
16:17:32 <hpc> (he used to be in here)
16:17:55 * DanBurton laments once again that Haskell doesn't support hyphenated identifiers
16:18:20 <hpc> a whitespace-sensitive minus would solve every syntactic issue i have
16:18:33 <hpc> -<num> is numeric negation
16:18:38 <gridaphobe> mmm
16:18:46 <hpc> (- <expr>) is a section
16:18:47 <hpc> always
16:19:02 <dario> eeew, semantic whitespace..
16:19:25 <DanBurton> if it were up to me, I'd make whitespace surrounding operators mandatory
16:19:31 <lemao> what is the best command line args library out there?
16:19:36 <hpc> i wouldn't go that far
16:19:46 <hpc> > 2 + 1/2 :: Rational
16:19:48 <lambdabot>   5 % 2
16:19:51 <hpc> that's still handy, at times
16:20:11 <DanBurton> meh, just special case numeric literals with / in them
16:20:14 <byorgey> lemao: I use cmdargs
16:20:30 <gridaphobe> does anyone have practical experience with TH? it seems to have a bad reputation. hyphenated identifiers and macros are two big things i miss about lisp
16:20:51 <hpc> lemao: i use that module in base, but people are constantly telling me i have bad taste in packages so ymmv
16:21:02 <DanBurton> I know right? gridaphobe I'm 100% with you on those two things
16:21:16 <gridaphobe> :)
16:21:27 <lemao> byorgey: is this the one that also generates bash auto-completion?
16:21:40 <byorgey> metaprogramming is about 100 times easier in a homoiconic language with no types.
16:22:03 <byorgey> lemao: not that I know of
16:22:07 <parcs> gridaphobe: TH is great. i don't think it has a bad reputation, but people obviously prefer non-TH solutions to problems
16:22:07 <hpc> byorgey: but regular programming is easier in languages that are neither of those ;)
16:22:15 <byorgey> hpc: indeed. =)
16:22:53 * gridaphobe should investigate TH
16:23:18 <DanBurton> TH is ugly, but it does get the job done afaict
16:23:21 <parcs> :t $([|True|])
16:23:22 <lambdabot> parse error on input `$'
16:23:26 <hpc> TH is a mistake, imo
16:23:39 <hpc> it makes your code get read from top to bottom
16:23:57 <lemao> hpc: I think you meant System.Console.GetOpt?
16:23:58 <DanBurton> that is pretty typical of macro systems, no?
16:23:59 <simpson> hpc: Do you have your IRC buffer flipped? :3
16:24:27 <simpson> Or do you read IRC top-to-bottom like the rest of us?
16:24:27 <gridaphobe> hpc: TH isn't handled in a separate pass?
16:24:43 <hpc> i have had situations where i had to enable standalone deriving just so i could work easily with acid-state
16:24:54 <hpc> gridaphobe: it is, but that pass is top-down
16:25:04 <gridaphobe> i see
16:25:12 <hpc> and with TH trying to be like haskell...
16:25:37 <gridaphobe> i can see how that would cause confusion
16:26:23 <jfischoff> is there a way to make the ghci history file infinite instead of being capped at 100 lines?
16:26:38 <[swift]> is it possible to take over an abandoned library on hackage? what would be the process for that?
16:26:48 <hpc> jfischoff: set the history limit to maxBound, whatever that might be
16:26:59 <hpc> (and then prepare for a huge-ass history file between runs
16:27:00 <shachaf> [swift]: Yes -- it's on the wiki somewhere.
16:27:12 * shachaf has to go but there's a page that lists the whole process.
16:27:31 <[swift]> shachaf: cool, thanks. google didn't work for me but i'll try browsing the wiki
16:27:41 <jfischoff> hpc: what's the command for that?
16:30:18 <hpc> oh, seems to not be configurable
16:30:34 <hpc> so sayeth the 7.4.1 docs
16:30:42 <hpc> (so it might be configurable by now)
16:31:32 <jfischoff> too bad
16:31:38 <hpc> you should submit a patch, join the hall of fame
16:32:14 <jfischoff> I do have HEAD built ‚Ä¶
16:32:14 <sordina1> Hey guys. Is anyone having issues with simpleHttp in http-conduit?
16:32:33 <jfischoff> but too many much else to do, oh well
16:32:46 <hpc> heh
16:33:05 <hpc> i have... at least 3 projects that i have yet to work on
16:33:15 <jfischoff> what are they?
16:34:00 <hpc> http benchmarking program, a game, and imagemagick bindings that don't suck
16:34:16 <sordina1> I'm getting Exception: FailedConnectionException for anything I try to download.
16:34:48 <jfischoff> what do you want to use imagemagick for?
16:35:17 <hpc> dunno; good uses will pop up once i have easy access to the more complicated features
16:35:33 <hpc> like ridiculous compositions of masks and animation handling
16:36:23 <jfischoff> hpc: oh yeah then that is probably best. I wrote a resizing app with repa and feel like we (haskell community) need more native image stuff
16:36:24 <hpc> oh yes, my fourth project is looking for another acme package idea
16:36:37 <jfischoff> but were not there yet
16:36:39 <hpc> oh, it won't be even remotely native, either
16:36:52 <hpc> it shells out to `convert` because i don't trust their API ;)
16:37:03 <jfischoff> err by native I mean native haskell
16:37:07 <hpc> ah
16:37:08 <jfischoff> not sure if that was clear
16:37:21 <jfischoff> yeah that is best way to start with a binding I think
16:37:24 <hpc> well yes, it will be very haskell
16:37:39 <hpc> it uses a fairly strange form of CPS for short-circuited caching
16:38:05 <jfischoff> what does? the acme idea?
16:38:19 <hpc> the imagemagick bindings
16:38:24 <jfischoff> ah
16:38:30 <jfischoff> ck
16:38:33 <jfischoff> ick
16:39:15 <hpc> it's fairly nice, actually
16:40:07 <jfischoff> I'm not a fan of CPS in general
16:40:15 <hpc> oh, it's only CPS internally
16:40:25 <hpc> to the user, it's just autoCheckpoint :: Magick ()
16:40:27 <jfischoff> well that's fine
16:44:28 <hpaste> fxr pasted ‚Äúabusing io-streams‚Äù at http://hpaste.org/83543
16:44:39 <crl> > hax'' [1..20]
16:44:41 <lambdabot>   Not in scope: hax''
16:45:07 <crl> > axe'' [1..20]
16:45:09 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20]]
16:45:25 <crl> > axe'' [1..]
16:45:27 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
16:46:41 <otters> :t axe''
16:46:43 <lambdabot> [t] -> [[t]]
16:46:48 <otters> > axe'' [1]
16:46:51 <lambdabot>   [[],[1]]
16:47:00 <otters> what's it do
16:47:03 <otters> @src axe''
16:47:03 <lambdabot> Source not found. Take a stress pill and think things over.
16:48:04 <hpaste> feliperosa pasted ‚Äúcollatz + sharing‚Äù at http://hpaste.org/83544
16:48:35 <applicative_> fxr I can't figure out the abuse :(
16:48:56 <feliperosa> could someone help me achieve sharing in the (n `div` 2) and (n * 3 + 1) computations, please?
16:49:13 <feliperosa> I wanted it to remember the previous computed values
16:49:41 <Rembane> feliperosa: iterate! :D
16:49:53 <feliperosa> Rembane: What do you mean?
16:50:04 <hpc> the typical first approach is to make collatz = (collatzList !!)
16:50:04 <Rembane> feliperosa: Just trollin', it's an awesome function though
16:50:09 <feliperosa> Rembane: I'm trying to grasp this sharing thing
16:50:17 <Rembane> feliperosa: Sharing?
16:50:18 <hpc> where collatzList is an infinite list
16:50:25 <hpc> that's defined in terms of collatz
16:50:45 <fxr> applicative_: an outputstream looks like in and out stream at the same time
16:51:28 <feliperosa> hpc: Right, I get what you mean. I'll try to come up with something :), thanks
16:51:37 <Saizan> feliperosa: yeah, as hpc is saying you want to recurse through the list
16:51:47 <fxr> I find ekmetts' machines wonderful, it's based on semigroups which I found profound
16:52:04 <amiller> okay this is my mendler-style functor fixpoint stuff so far
16:52:04 <amiller> https://gist.github.com/amiller/5095810
16:52:08 <hpc> feliperosa: given the wonky shape of the collatz function, a tree might be more beneficial
16:52:16 <hpc> but i would have to think more than 5 seconds on that, and it's late here
16:52:17 * elliott doesn't recall machines using semigroups very much...
16:52:18 <amiller> i feel like this is pretty weird because i haven't seen anything else work quite like it yet
16:52:28 <amiller> in particular the mendler-style folds in recursion-schemes still use the ordinary data fixpoint
16:52:36 * edwardk needs to spend more time on machines
16:52:49 <fxr> elliott: http://hackage.haskell.org/package/machines this one
16:52:52 <amiller> the main point of note here is that there's no general recursion needed, this whole thing should (i guess!) typecheck in agda or coq
16:53:01 <elliott> fxr: yeah I know
16:53:10 <elliott> fxr: but what do you mean by based on semigroups?
16:53:33 <crl> otters: it does
16:53:36 <crl> > let half (x:_:xs) = x:half xs;half _ = [];split' l [] = [[], l];split' (x:xs)  (y:ys) = let [a,b] = split' xs ys in [x:a,b];axe'' xs = split' xs (half' xs) in  axe'' [1..3]
16:53:36 <fxr> edwardk: btw thank you for your effort
16:53:38 <lambdabot>   [[1],[2,3]]
16:54:00 <feliperosa> hpc: No problem, I don't wanna bother you guys so much. I think I can figure something out.
16:54:01 <amiller> search works correctly, 'show' doesn't seem to make much sense i'm not sure what would be required to make it work using normal instances
16:54:07 <amiller> like derived from the functor instance
16:54:43 <fxr> elliott: semigroups looks exactly as automatas
16:54:46 <crl> otters: split in 2 half
16:55:01 <edwardk> amiller i have a bunch of ancient mendler code lying around somewhere one sec
16:55:02 <applicative_> feliperosa: theres the obvious         collatz' n len = case n `quotRem` 2 of (k,0) -> collatz' k (len + 1); (k,1) -> collatz' (6 * k + 1) (len + 1)
16:55:23 <elliott> fxr: not quite sure what you mean :/
16:55:24 <amiller> if i go in the order i went before, basically i would extend this by a) making apomorphism so i can have insert work, b) making some parameterized-monadic instance to capture effects, c) going to a higher order functor
16:55:51 <amiller> i think that all of a) b) c) are orthogonal to the mendlerization and therefore it will be straightforward but i think i'm off in weird territory already
16:56:01 <hpaste> edwardk pasted ‚Äúancient mendler code for amiller‚Äù at http://hpaste.org/83545
16:56:02 <amiller> edwardk, cool, that sounds very helpful!
16:56:04 <crl> > axe'' ['a'..'z']
16:56:06 <lambdabot>   ["abcdefghijklm","nopqrstuvwxyz"]
16:56:07 <applicative_> feliperosa: except the second case isn't right ...
16:56:20 <edwardk> amiller: not sure how much is there. i found it when i was cleaning out a compiler i hadn't booted since 2007
16:57:05 <applicative_> feliperosa: wait, I guess it is right; I panicked
16:57:09 <edwardk> apparently 2008, because that was when i sat down with uustalu and really internalized mendler style
16:57:26 <edwardk> er s/compiler/computer
16:57:59 <applicative_> fxr I see that the io-streams library has hit hackage finally
16:58:39 <edwardk> that also looks like it was written for an old category-extras
16:58:50 <amiller> yeah i can't find the equivalent of control.functor.fix
17:01:26 <feliperosa> applicative_: That makes the program loop forever, hehe
17:02:22 <applicative_> feliperosa: oh no, do I have something backward?  the idea of making better use of the calculation of even seems okay
17:04:02 <feliperosa> applicative_: Yeah, we forgot that in that expression n = k * 2 + 1, so that 'k * 6 + 1' should be  '(k * 2 + 1) * 3 + 1'. And that gives the right answer (no performance diference btw)
17:04:36 <amiller> edwardk, if i understand mendler-style correctly, the mcatas here don't work because they require direct general recursion?
17:05:24 <amiller> like avoiding mcata phi = phi (mcata phi) . outF is the main point
17:05:32 <amiller> er i'm probably unfairly focusing on the instance for FixF
17:06:22 <feliperosa> applicative_: collatz' n len = case n `quotRem` 2 of { (k, 0) -> collatz' k (len + 1); (k, _) -> collatz' (6 * k + 4) (len + 1); }
17:06:45 <applicative_> feliperosa: ah, right, that's what I panicked about, but somehow convinced myself of the first idea
17:07:11 <feliperosa> applicative_: :), I didn't know of quotRem. It's cool btw
17:07:34 <applicative_> feliperosa: people usually recommend some kind of memoization, but I remember it being difficult to manage because you know nothing about the upper bound
17:09:52 <feliperosa> applicative_: The problem I'm having with this is that it's probably recomputing those next nS (n `div` 2 and n * 3 + 1). This version is running at the same speed as the not memoized C version. The memoized C version runs about 10 times faster. I wanted to see how would haskell perform if I could skip some calculations there.
17:11:17 <feliperosa> applicative_: My first thought was making it remember the calculations by sharing. But I think I'm not gonna make it (I know so little about the GHC, I have like 4-5 months of haskell).
17:11:58 <Saizan> amiller: you can't do apo- for the least fixed point, unless you have something else to recurse over
17:14:07 <Negatratoron> I'm trying to learn what a monad is, and to that end I'm wondering if this thing I wrote in Javascript constitutes a monad: http://codetidy.com/4857/
17:14:28 <jonkri> how do i catch errors produced with the error (undefined) function?
17:15:32 <Negatratoron> Normally the lifted function would also return the state, and that would be passed in again, but Javascript's mutability allows you to avoid that step
17:17:28 <hpaste> ‚Äúv0|d‚Äù annotated ‚Äúabusing io-streams‚Äù with ‚Äúabusing io-streams (annotation)‚Äù at http://hpaste.org/83543#a83546
17:18:27 <crl> Negatratoron: where is defined arguments
17:19:00 <Negatratoron> arguments is how javascript does variable arguments passed to functions
17:19:34 <Negatratoron> I'm just turning any other arguments into an array and passing them through to the lifted function
17:19:58 <Negatratoron> this would be State parserState
17:20:21 <Negatratoron> like* State parserState
17:20:29 <hpaste> ‚ÄúAnonymous Coward‚Äù annotated ‚Äúabusing io-streams‚Äù with ‚Äúabusing io-streams (annotation) (annotation)‚Äù at http://hpaste.org/83543#a83547
17:20:50 <monochrom> this is not a monad
17:21:22 <Negatratoron> Ahh cool, why not?
17:22:16 <crl> Negatratoron: anyway im not good in js, but it  could be fun to write it in haskell then use https://github.com/faylang/fay/wiki
17:22:31 <crl> to generate javascript
17:22:49 <Negatratoron> that's a really good idea
17:22:52 <Negatratoron> i could compare the code
17:23:10 <monochrom> because it has "lift", and it doesn't have either (return and bind) or (return and fmap and join).
17:24:01 <amiller> Saizan, the insert-as-apomorphism i have in mind is basically this: https://github.com/NicolasT/generic-storage/blob/master/src/Data/Tree/Algorithms.hs#L41
17:24:12 <amiller> that comes from visser and loeh's generic storage in haskell paper
17:25:30 <hpaste> crl pasted ‚Äúmonadic parser example‚Äù at http://hpaste.org/83548
17:30:34 <Saizan> amiller: yeah, you'd have to write that as a cata/para, apomorphisms on least fixed points are not necessarily total
17:33:39 <applicative_> hm, hadn't heard of this erudify company that helped fund something of io-streams  a little mysterious https://erudify.ch/jobs/
17:35:05 <byorgey> ah, sounds cool
17:35:18 <byorgey> straight out of Diamond Age =)
17:37:05 <Negatratoron> monochrom, CreateParser is return.  The return function just ignores any parserState passed to it and makes a fresh one.
17:37:28 <jonkri> what is the Exception type used for "error" (the function) errors using Control.Exception.try?
17:37:28 <Negatratoron> and it looks like bind and lift differ only on whether the return value of the function that's binded or lifted returns a monadic value
17:37:35 <monochrom> that is not what return does
17:37:39 <Negatratoron> (and the order of the arguments)
17:38:28 <geekosaur> jonkri, http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Control-Exception.html#t:ErrorCall
17:39:17 <Negatratoron> If I want a State Int, I call return and pass it a regular Int
17:39:41 <monochrom> yes, and it emphatically does not create a new state
17:40:07 <monochrom> and does not ignore old state
17:40:34 <jonkri> geekosaur: thanks!
17:40:42 <Negatratoron> so CreateParser would be more like return if it took the object that became parserState
17:42:25 <applicative_> jonkri: oh i see, the definition of error is error str = throw (ErrorCall str)
17:44:01 <edwardk> amiller: those may be completely bunk. i haven't read that code in a long time
17:44:46 <hpaste> crl revised ‚Äúmonadic parser example‚Äù: ‚Äúmonadic parser example‚Äù at http://hpaste.org/83548
17:45:13 <jonkri> > try $ return $ (5 :: Int) `div` (0 :: Int) :: IO (Either ErrorCall Int)
17:45:15 <lambdabot>   Not in scope: type constructor or class `ErrorCall'
17:45:15 <lambdabot>  Perhaps you meant `AsE...
17:45:26 <Negatratoron> A State Int can hold an integer and the most recently lifted function's return value, I believe
17:45:31 <jonkri> > try $ return $ (5 :: Int) `div` (0 :: Int) :: IO (Either Control.Exception.ErrorCall Int)
17:45:33 <lambdabot>   Not in scope:
17:45:34 <lambdabot>    type constructor or class `Control.Exception.ErrorCall'
17:45:34 <lambdabot>  P...
17:45:38 <jonkri> bah
17:46:02 <jonkri> anyway, that results in: Right *** Exception: divide by zero
17:46:29 <monochrom> that description is most likely wrong. and I am uncertain just because I do not know what "hold" and "lift" mean.
17:47:03 <Negatratoron> :t lift
17:47:05 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
17:47:06 <Negatratoron> :t liftM
17:47:08 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
17:47:12 <Negatratoron> that's what I meant
17:47:16 <Negatratoron> :t (>>=)
17:47:18 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:47:28 <monochrom> lift and liftM are unrelated. pick one.
17:47:32 <Negatratoron> liftM
17:47:39 <jonkri> why does not try catch that exception?
17:48:07 <Negatratoron> thanks for all the help, i realize i'm pretty noobish
17:50:14 <Negatratoron> anyway, liftM and >>= both take a monadic type.  They also both take a function that takes a type and returns either a type or a monadic type.
17:51:05 <crl>  http://hpaste.org/83548 if anyone cares, i'd like to modify line 22 with [ (show x ++ show y,u) | , but it doesn't typecheck
17:52:02 <monochrom> with only return and liftM, you still don't have a monad. you have to add join or >>=
17:52:40 <crl> I actually can't concatenate a type a with a type b
17:52:51 <monochrom> also, it does not look like your code has liftM
17:53:11 <crl> if i stringify them with show, it says Couldn't match type `b' with `[Char]'
17:53:23 <Negatratoron> yeah, it just returns the lifted function's return value, rather than a monadic object
17:53:27 <Negatratoron> is that what you're talking about?
17:53:31 <byorgey> crl: a Parser is of type  String -> [(a, String)]
17:53:44 <byorgey> crl: that means the first element of the pairs is some type which the user of a Parser gets to pick
17:54:00 <byorgey> crl: so you cannot pretend it will be a String.
17:54:12 <jonkri> why does not `try' catch the exception in: "try $ evaluate $ (5 :: Int) `div` (0 :: Int) :: IO (Either ErrorCall Int)"
17:54:19 <crl> byorgey: hm i know, to remember results, i need to list results in tuple
17:54:42 <crl> byorgey: thx
17:55:07 <crl> wanted to do something like apply (star (token 'a' `mplus` token 'b') >> plus (token 'b' `mplus` token 'c') ) "abc"
17:55:28 <crl> and have a consumed result ("abc","")
17:55:49 <crl> but of course I can't add possibe different types
17:55:59 <johnw> is io-streams yet another iteratee library?
17:56:24 <elliott> yet another non-iteratee library, I think
17:56:40 <johnw> i mean, it's the same concept as pipes and conduit, isn't it?
17:56:45 <augur> koninkje_away: ping
17:56:50 <jonkri> s/ErrorCall/SomeException solved it
17:57:30 <Negatratoron> I argue that returning a monadic value is not necessary here.  Normally you need to tail recurse, so each function must return a monadic value to pass into the next function.  Mutability allows you to maintain that state without making the function return it.
17:58:59 <monochrom> suppose I call your monad P. suppose I have a function f :: Int -> Bool. then liftM f :: P Int -> P Bool. therefore, liftM f is a function that takes a P Int parameter, not a character parameter. that is the first problem.
17:59:45 <shachaf> But 'P' is a character. Checkmate.
18:00:03 * hackagebot diagrams-core 0.6.0.2 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-0.6.0.2 (BrentYorgey)
18:00:18 <monochrom> the second problem: liftM f will use f in ways like "f 5", "f 10", etc. because f :: Int -> Bool. liftM f will not use f in ways like "f parserstate 5", because f :: Int -> Char, not f :: Parserstate -> Int -> Char
18:01:14 <Negatratoron> CreateParser is the the return function for a State ParserState monad, where ParserState is the type of parserState
18:03:54 <Negatratoron> P Int and P Bool don't exist, this is just State ParserState
18:04:36 <monochrom> ok, I can use the name "State ParserState"
18:04:49 <Negatratoron> I'm trying to think what that means for the so-called "lift" function
18:04:55 <shachaf> monochrom is making life simpler by using P, not more complicated.
18:05:14 <monochrom> suppose I have a function f :: Int -> Bool. then liftM f :: State ParserState Int -> State ParserState Bool. therefore, liftM f is a function that takes a State ParserState Int parameter, not a character parameter. that is the first problem.
18:05:23 <shachaf> By using a letter rather than a complicated thing, you can ignore everything about the letter except for the essential.
18:05:23 <Negatratoron> Oh okay, P = State ParserState
18:05:26 <monochrom> the second problem: liftM f will use f in ways like "f 5", "f 10", etc. because f :: Int -> Bool. liftM f will not use f in ways like "f parserstate 5", because f :: Int -> Char, not f :: Parserstate -> Int -> Char
18:06:08 <tvynr> Would this be the right place to ask a question about cabal?  It's doing something strange and I don't understand why.
18:06:18 <byorgey> tvynr: sure
18:06:27 <shachaf> tvynr: Ask first, ask questions alter.
18:06:58 <Negatratoron> Okay, I'm looking at the first problem
18:07:34 <Negatratoron> so the lifted function should be called with the previous lifted function's return value?
18:08:20 <tvynr> Thanks.  :)  Just wasn't sure if there was a #cabal I should go find or something.  Just a sec; I'll put the relevant things in a paste.
18:08:21 <applicative_> johnw: yeah io-streams is competition with conduit et al on the anti-lazy-io front
18:08:29 <monochrom> there is no previous lifted function when specifying or implementing liftM
18:09:31 <Negatratoron> I come from dark lands and still see it as State TStateModel TReturnValue
18:09:41 <crl> byorgey: a bit long, but works using do: apply (do {x <- star (token 'a' `mplus` token 'b'); y <- plus (token 'b' `mplus` token 'c'); return (x,y)}) "abc"
18:09:50 <Negatratoron> instead of State t a
18:10:05 <crl> i gues it not possible to write it with bind
18:10:47 <tvynr> Okay, here's the situation.  I'm running a Debian testing laptop with a Debian Sid chroot so I can use ghc 7.6.  The chroot has Debian packages for Cabal and other things installed.  But I intend to use updated stuff myself, so I'm running everything out of ~/.cabal/bin.
18:11:04 <tvynr> My ghc-pkg listing is at http://pastebin.com/Uzhhy6Xk and an example of my problem is at http://pastebin.com/YYRZC9vL
18:11:08 <mauke> The pastes Uzhhy6Xk YYRZC9vL have been copied to http://hpaste.org/83551 http://hpaste.org/83552
18:11:17 <monochrom> I am not picking on "TStateModel vs ParserState", "TReturnValue vs a". I said, there is no previous lifted function when specifying or implementing liftM. I don't understand, how does it have to do with "TStateModel vs ParserState", "TReturnValue vs a"?
18:11:44 <shachaf> tvynr: A chroot? Why not just install GHC 7.6 yourself, and ignore the Debian packages?
18:12:12 <tvynr> The thing that's confusing me is that, in the second listing, buildwrapper complains about the version of cabal changing.  This normally happens if the cabal library is a different version than the cabal-install executable.  But in my case, I *just built* both of those things using the ~/.cabal/bin, which should be using Cabal 1.16.0.3 according to my GHC package listing.
18:12:32 <tvynr> So any idea why buildwrapper is being compiled with 1.16.0 would be helpful.
18:12:34 <tvynr> :)
18:13:22 <tvynr> shachaf: I'm using a chroot because I want my Debian testing system to run the GHC 7.4 that ships with Debian.  I need the GHC 7.6 for a specific project.
18:13:41 <crl> o well i can do,   m1 foo >>= \x -> m2 bar >>= \y -> return (x,) but i guess do notation is preferable in this case
18:13:41 <shachaf> tvynr: You can install GHC 7.6 in a specific directory, then.
18:13:53 <shachaf> I mean, you can do the chroot too, but it seems like a lot of extra trouble.
18:14:59 <tvynr> I should note that the chroot has Cabal 1.16.0 installed.  But I don't understand why "cabal install buildwrapper" is compiling against *that* cabal library and not the 1.16.0.3 one I installed previously with "cabal install cabal".  After all, "cabal install cabal-install" built a cabal binary against 1.16.0.3.
18:15:15 <tvynr> And buildwrapper seems to be very picky about these things.  :-P
18:15:49 <tvynr> shachaf: There are also some other Sid-y things that I wanted to isolate from my main system.  I'm a bit of a chroot junkie.  :-P
18:15:52 <Frostix> What does xs mean?
18:16:00 <monochrom> depends on author
18:16:25 <tvynr> Frostix: "xs" is just a variable name meant to be the plural of "x", as I understand.  Usually a list of whatever "x" would be.
18:17:05 <Frostix> Ok so there's no different when you let a variable be called x, xs, or noodles?
18:17:30 <tvynr> Correct.
18:17:34 <Frostix> Thanks!
18:17:39 <tvynr> np :)
18:19:14 <amiller> does anyone have experience with this recursion patterns by adjoints http://www.cs.ox.ac.uk/ralf.hinze/publications/MPC10.pdf
18:19:28 <amiller> i like the tidy presentation of initial/final forms
18:20:52 <monochrom> Franktur for data constructors?! :)
18:20:53 <levi> I hadn't seen that before.
18:21:49 <monochrom> I should read this more
18:21:51 <jaroslaw> http://www.cs.ox.ac.uk/ralf.hinze/publications/MPC10.pdf
18:22:03 <jaroslaw> woops
18:25:47 <hpaste> tvynr pasted ‚ÄúCabal Behavior‚Äù at http://hpaste.org/83556
18:26:49 <tvynr> Okay, so my Cabal problems can be summed up by the small session at http://hpaste.org/83556 .  cabal install buildwrapper is using 1.16.0 but cabal install cabal is using 1.16.0.3.  I don't understand how this could be the case; any elightenment would be appreciated.
18:27:30 <tvynr> Actually, any *guesses* would be appreciated.
18:28:24 <shachaf> Does -v3 give you more information?
18:28:42 <shachaf> (Well, it does. More information of any use?)
18:31:01 <tvynr> shachaf: Fair point; I'll check.
18:32:15 <monochrom> cabal install --dry-run buildwrapper --constraint='Cabal==1.16.0.3'
18:34:14 <monochrom> oh, I know now. buildwrapper depends on ghc (it means the GHC API). ghc is built against the Cabal that comes with GHC.
18:34:43 <tvynr> shachaf, monochrom: Both of those got something (although the constraint approach was more direct).  So: rejecting: Cabal-1.16.0.3/installed-9db... (conflict: buildwrapper => Cabal==1.16.0/installed-88c...)
18:34:56 <tvynr> monochrom: I see.  Is there any way around that without rebuilding GHC?
18:35:12 <monochrom> no. and don't bother rebuilding GHC
18:35:42 <tvynr> monochrom: I suppose I could force cabal-install to build against Cabal 1.16.0; that'd get the job done.  I just sort of wanted to avoid that; it seems sort of odd.
18:36:08 <tvynr> monochrom: Though I guess I mostly just wanted to understand why this was happening.  And I do now.
18:36:18 <tvynr> monochrom, shachaf: Thanks for the help!  :)
18:36:44 <sproingie> is there anything for cabal like perl's local::lib or python's virtualenv?
18:37:37 <levi> I'm not sure exactly what those do, but maybe cabal-dev is what you want?
18:38:11 <sproingie> yep looks exactly like what i'm looking for, thanks :)
18:40:41 <amyers> sproinge: There's also hsenv
18:40:59 <amyers> I believe that's a bit closer to virtualenv
18:44:07 <Frostix> Can someone help me with this piece of code? http://prntscr.com/v74oz
18:45:30 <Frostix> Anyone?
18:45:32 <Hafydd> Frostix: what about it do you not understand?
18:45:36 <geekosaur> Frostix, in (x:xs), xs is a lisr
18:45:38 <geekosaur> *list
18:45:48 <geekosaur> not a single element
18:46:11 <Frostix> Um could you explain that better?II'm new to this
18:46:17 <shachaf> Is posting a screenshot of your code a new trend? I've seen it a few times recently.
18:46:27 <shachaf> Oh, but maybe all the times were the same person.
18:46:27 <Frostix> It's what I do :)
18:46:31 <geekosaur> think a Lisp cons cell, or a singly linked list in C
18:46:45 <geekosaur> the head is an item, the tail is a pointer to another list cell
18:47:03 <geekosaur> so [a,b,c) is (a:(b:(c:[])))
18:47:09 <geekosaur> er
18:47:13 <geekosaur> so [a,b,c] is (a:(b:(c:[])))
18:47:16 <shachaf> [a,b,c) is a weird sort of half-open interval.
18:47:33 <geekosaur> which we normally write a:b:c:[] because of recedence
18:47:33 * geekosaur glares at finfers
18:47:38 <geekosaur> precedence
18:47:47 <Frostix> Um one sec
18:48:18 <shachaf> I don't think it has to do with precedence, but maybe that's nitpicking. :-)
18:48:32 <geekosaur> this means that if I passed [a,b,c] to your tails', y would be (b:(c:[])) or [b,c]
18:49:12 <Frostix> Well what if I want y to just be the end of the list?
18:49:29 <geekosaur> you cant do that with a simple pattern match; you need to iterate over the list
18:50:17 <geekosaur> because a list is a recursive data structure (note the nested parentheses)
18:50:23 <monochrom> I don't like screenshot. it forbids cut and paste
18:50:33 <Frostix> Sorry, dunno where else to upload
18:50:47 <monochrom> hpaste.org, and put text there
18:51:03 <geekosaur> it also forbids my using fork capability on gist or annotate on hpaste to edit your code, and your ability to use diff to see the changes
18:51:16 <monochrom> then again, windows console makes it difficult
18:51:25 <hpaste> Frostix pasted ‚Äútails'‚Äù at http://hpaste.org/83561
18:51:33 <Frostix> Oh that's neat!
18:52:08 <monochrom> anyway, [a,b,c] is syntax sugar for a : (b : (c : [])) and so follow what geekosaur says
18:52:16 <shachaf> Frostix: Also include your error, when you have an error.
18:52:28 <shachaf> And ideally, what you expect, if it doesn't match what you got.
18:52:40 <geekosaur> the structure of that should be a hint as to how to look for the end of the list
18:53:16 <Frostix> Alright, I don't know how to do that yet but I'll add it in. Also Geekosaur how should I change it again? Change what?
18:54:14 <geekosaur> think about what I said about a list being recursive, and how that fits into the list representation using : that you've been shown a couple times already
18:54:28 <Frostix> Ok
18:55:31 * geekosaur doesn;t want to just give out the answer, because (a) this might be homework-ish (b) you'll understand better if you work it out for yourself instead of simply being given the answer. there is a very simple solution just from what you've already been shown
18:56:03 <geekosaur> but I'll as one question to try to get you started: given the : structure of a list, how do you detect the end of the list?
18:56:29 <geekosaur> (look at the :-representation again)
18:56:45 <shachaf> monochrom: Cutting and pasting from someone's hpaste is pretty rude.
18:56:49 <shachaf> Then nobody else can see it.
18:57:25 <monochrom> don't worry, it is the zipper kind of cut and paste. non-destructive
18:57:55 <shachaf> Ah.
18:58:05 <shachaf> Is it related to the "mov" instruction in x86?
19:00:28 <Frostix> Oh yeah, this ain't homework :P Just learning this on my own, I understand however ^^
19:01:00 <shachaf> Fortunately the strategy for learning on your own is not very different from the strategy for learning when given homework.
19:01:24 <shachaf> (In fact, sometimes the best solution for the latter is to reduce it to the former.)
19:25:05 * hackagebot highlighting-kate 0.5.3.8 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.3.8 (JohnMacFarlane)
19:35:06 <dibblego> is ((,) t) Traversable?
19:35:34 <ion> > traverse pure ("foo", "bar")
19:35:36 <lambdabot>   No instance for (GHC.Show.Show
19:35:36 <lambdabot>                     (f0 ([GHC.Types.Char], [...
19:35:56 <dibblego> why not?
19:35:57 <ion> > traverse Just ("foo", "bar") :: Maybe (String, String)
19:36:00 <lambdabot>   Just ("foo","bar")
19:36:08 <dibblego> oh
19:36:24 <dibblego> where is its instance defined?
19:36:43 <dmj> Is it possible to pull a value out of the IO monad into a Reader monad that can be queried by pure code?
19:36:44 <ion> > traverse id ("foo", Just "bar")
19:36:46 <lambdabot>   Just ("foo","bar")
19:37:02 <dmj> question for anyone
19:37:16 <dibblego> dmj: only if you remain within IO
19:37:22 <ivanm> dmj: you can get the value from IO, then run the Reader within IO
19:37:26 <revcbh> Is there any way to define an instance like this?: instance (Default a) => Comonad (Maybe a) where ...
19:37:26 <ion> dmj: fmap (runReader foo) ioAction
19:37:27 <crdueck> dmj: sounds like you want ReaderT
19:37:34 <ivanm> or, shove a ReaderT on top of IO
19:37:41 <edwardk> no
19:37:43 <dibblego> revcbh: no, but there is instance Extend Maybe (without the extract)
19:37:45 <YayMe> Does anyone else find Haskell makes them want to write code in other languages that would just be wrong for the language?
19:38:01 <revcbh> dibblego: thanks
19:38:36 * geekosaur just stuck some haskelly combinators in his perl code yesterday, along with a comment regretting that they couldn;t be more haskelly :)
19:38:40 <YayMe> I think it's a problem of the minimalism of the language; given very few abilities in another language you can do things similar to how you would in Haskell if you don't know the idiomatic way for that language
19:39:04 <YayMe> haskell had me for lack of another idea on hand of how to sequence my operations write this F# while fiddling around earlier today, let doc filePath:string = (fun (d:XmlDocument) -> d.Load filePath |> (fun _ -> d)) (new XmlDocument)
19:39:30 <hpaste> dmj pasted ‚ÄúReader-Monadify‚Äù at http://hpaste.org/83563
19:39:38 <revcbh> dibblego: although that's the idea of the (Default a) constraint, then you could write extract extract (Just x) = x and extract _ = def right?
19:40:11 <YayMe> which I know has got to be a strange way to do it in F#, but all I could think was to mimic behaviour like >> where it sends the result to another function which drops the input and returns something else
19:40:17 <dibblego> revcbh: that would not hold to the laws
19:40:34 <dmj> crdueck: The AST I have is created based on an IO String a user will provide. I've heard once I'm in the IO monad there is no getting out
19:41:03 <revcbh> dibblego: sure, I was just playing around and curious about the type constraint bit
19:41:08 <crdueck> dmj: yes, bar unsafePerformIO of course. So you layer a ReaderT monad over IO
19:41:25 <dmj> Do you have any code samples of this?
19:41:28 <crdueck> dmj: so your read-only state in this case is the [Declaration] in toDecs?
19:41:42 <dmj> it would be the ast inside of IO
19:42:05 <dmj> I'm traversing the tree while I need to query it globally
19:42:19 <dibblego> @type \f (x, a) -> (x, f a) -- traverse for ((,) t) ?
19:42:21 <lambdabot> (t -> t2) -> (t1, t) -> (t1, t2)
19:42:40 <otters> how should I get the compiler name/version that the current program was compiled with?
19:43:03 <crdueck> dmj: so then any function that needs to use the ast will be a "ReaderT AST IO a" where a is the eventual result of the function
19:43:30 <monochrom> please don't pull a value out of IO. because there is none.
19:43:46 <dmj> crdueck: Could you annotate to point me in the right direction? Still a little befuddled
19:44:10 <dmj> crdueck: It would be ReaderT Jack IO a in this case then
19:45:05 * hackagebot hArduino 0.4 - Control your Arduino board from Haskell.  http://hackage.haskell.org/package/hArduino-0.4 (LeventErkok)
19:46:15 <dmj> crdueck: How can I take the IO String out of the IO Monad and put it into a ReaderT Monad Transformer to be looked up globally. I think that's what I want to do
19:47:59 <dmj> monochrom: what do you mean?
19:48:26 <shachaf> dmj: There is no "taking the IO String out of the IO Monad"
19:48:41 <shachaf> That sentence doesn't make sense as it is. What does it mean?
19:48:49 <monochrom> IO is not a vault that guards a value. therefore, there is no breaking open the vault to begin with.
19:48:49 <danharaj> IO String is not in any way a String.
19:49:01 <geekosaur> @quote ls.*files
19:49:02 <lambdabot> No quotes match. You speak an infinite deal of nothing
19:49:08 <geekosaur> oh right, we lost quotes :(
19:49:19 <hpaste> crdueck annotated ‚ÄúReader-Monadify‚Äù with ‚ÄúReader-Monadify (annotation)‚Äù at http://hpaste.org/83563#a83564
19:49:20 <crdueck> dmj: i'm not sure if this type checks, but this should give you an idea how to use the Reader Monad, in this case i dont think you need a monad transformer
19:49:28 <geekosaur> "an IO String contains a String in the same way /bin/ls contains a list of files"
19:49:38 <shachaf> @quote /bin/ls
19:49:39 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
19:49:40 <shachaf> :-(
19:49:47 <monochrom> however, you do have a procedure called getLine (for example), and you can ask, after it reads a string, how to feed that string into a second procedure. and that is done by >>=, or the do-notation
19:49:56 <danharaj> I wonder if all my quotes died :(
19:49:59 <danharaj> @quote danharaj
19:49:59 <lambdabot> danharaj says:  The industry wields types like an ancient weapon of forgotten technology.
19:50:14 <shachaf> Oh, I'm just going to add it back. It's pedagogical.
19:50:46 <YayMe> @quote YayMe
19:50:47 <lambdabot> No quotes match. Where did you learn to type?
19:50:48 <shachaf> @remember shachaf getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
19:50:48 <lambdabot> It is forever etched in my memory.
19:50:53 <YayMe> ah
19:51:01 <shachaf> One day I'll go through the logs and add them back in properly. Maybe.
19:51:19 <danharaj> shachaf: you mean run a script :P
19:51:36 <dmj> crdueck: So now whenevr I need to access ast I just call ask?
19:51:38 <monochrom> but you're already doing that with "file <- readFile filename" etc. file is already a string, and you're giving it to parseString.
19:51:54 <YayMe> is IO monad one of the big reasons people use Reader/Writer monads?
19:51:59 <dmj> monochrom: yes
19:52:06 <crdueck> dmj: yes, ask returns the read only state
19:52:07 <shachaf> danharaj: What do you mean?
19:52:41 <dmj> crdueck: Thanks a lot for the help. I'm gonna try this out.
19:52:43 <danharaj> shachaf: could you not just grep for any line containing @quote at the front and repeat them?
19:52:47 <YayMe> When I poked around at those two monads I just felt they were odd stateish things and wondered why I wouldn't just use the State monad instead
19:52:53 <crdueck> dmj: if you have a Reader a b, and a f :: a -> a, then you can do "asks f" and save a line of do notation
19:52:56 <shachaf> danharaj: Yes, sort of.
19:52:57 <crdueck> :t asks
19:52:59 <lambdabot> MonadReader r m => (r -> a) -> m a
19:53:04 <shachaf> Except the state of the quote file is vaguely inconsistent.
19:53:09 <shachaf> And you need to account for @forgets.
19:53:17 <shachaf> And some quotes come from other channels. Those are pretty hopeless.
19:53:40 <crdueck> f :: a -> b rather
19:53:59 <danharaj> shachaf: hm quotes from other channels is probably a completely lost cause but perhaps for #haskell the best course of action would be to wipe the quote file clean and reconstruct it from logs... and then back it up! :P
19:54:15 <shachaf> danharaj: Yes, but then we lose *all* the quotes from other channels.
19:54:16 <dmj> crdueck: So whenever I want access to the full tree I have to write do notation? Also, do I now need to annotate every function with Reader?
19:54:21 <shachaf> Rather than just the ones since 2011.
19:54:27 <shachaf> Anyway I have no idea what state the quote file is in right now.
19:54:45 <shachaf> Cale took one from somewhere but I don't know what it is, and a binary search through the logs leads to inconsistent results.
19:54:56 <crdueck> dmj: every function that would use the ast is now part of the Reader Monad. it lets you clearly see the dependency on the read only state
19:55:01 <pendos_> How do you print a boolean in haskell?
19:55:16 <shachaf> print
19:55:22 <monochrom> print True
19:55:22 <danharaj> :t print
19:55:24 <lambdabot> Show a => a -> IO ()
19:55:27 <crdueck> dmj: not do notation specifically, but you're in a monad, so it's going to be written in monadic style
19:55:29 <Cale> I'm not sure what it is either. It was just the one which was in my lambdabot build directory.
19:55:48 <danharaj> pendos_: Notice the polymorphism that requires its argument satisfy the constraint of the Show typeclass.
19:56:02 <danharaj> This is probably the most complicated idea that gets in the way of groking Haskell, so to speak.
19:56:54 <dmj> crdueck: This is interesting, so instead of passing the global object to every function I now pass a monadic context that grants me access if I need it?
19:57:14 <crdueck> dmj: exactly, you write the functions assuming they have access to some implicit state
19:57:36 <crdueck> dmj: the reader monads (>>=) operator takes care of passing the state around for you
19:57:36 <dmj> crdueck: All my functions continue to call new functions as they go deeper into the tree. Can I skip levels of applying the reader Monad if I don't need it to access the ast?
19:58:27 <crdueck> no, because even if F doesnt use the state, if F calls G and G does, then F implicitly relies on the state
19:59:16 <dmj> crdueck: Gotcha, fascinating
19:59:42 <crdueck> the Reader monad seems redundant in some cases like this, but its really forcing you to be conscious of the dependencies of your functions
20:00:08 <dmj> crdueck: Now what If I also had an accumulator. Because I need to increment the number of if statements in the generated VM code. Should I use the Reader Monad with local to manipulate state on this global counter or should I use the State Monad?
20:00:43 <dmj> Also, is there a performance hit for dragging along this monadic context to every sub function?
20:00:43 <danharaj> It sounds like you want a Writer, vaguely.
20:01:05 <crdueck> in this case, a monad transformer would probably be best. now you have ReaderT Jack (State Counter) a
20:01:25 <crdueck> danharaj: i dont think its a writer, he's incrementing, not appending
20:01:39 <danharaj> Writer only requires a Monoid instance.
20:01:54 <danharaj> appending and adding are both monoidal.
20:02:30 <crdueck> danharaj: true, the Sum monoid. you're right actually, unless he needs to use the counter in any way besides incrementing
20:03:53 <dmj> crdueck: I do need to decrement as well.
20:04:17 <monochrom> ReaderT Jack IO a desugars to Jack -> IO a. this costs exactly the same as passing around Jack.
20:04:35 <crdueck> dmj: the Reader monad doesnt do anything special. it just hides passing the state around through (>>=).
20:05:13 <danharaj> >>= for the reader monad is just like (.) for values.
20:05:34 <danharaj> The 'values' for >>= are functions (r -> a), that is, they take a parameter.
20:05:38 <crdueck> dmj: so you'll need ReaderT Jack (State Int) a, you can access the Jack with ask, and change the state with modify (+/- 1)
20:06:33 <dmj> crdueck: So in the IO Monad, where we pass in runReader, would I also pass in runState inside of this reader?
20:07:26 <crdueck> you would call runReaderT (runState toClass 0) ast
20:07:35 <crdueck> you unwrap the state first, then the reader
20:08:58 <dmj> crdueck: I see so runState takes two parameters, and I use modify inside of monad to increment/decrement this paramter?
20:09:10 <dmj> this integer*
20:09:17 <crdueck> yes
20:09:20 <crdueck> :t runState
20:09:21 <lambdabot> State s a -> s -> (a, s)
20:09:22 <crdueck> :t evalState
20:09:24 <lambdabot> State s a -> s -> a
20:09:42 <dmj> crdueck: when would I use evalState?
20:09:57 <crdueck> if you just want the result of the stateful computation, and dont care about the final state
20:10:02 <crdueck> of course, theres also
20:10:07 <crdueck> :t execState
20:10:08 <lambdabot> State s a -> s -> s
20:10:20 <crdueck> for when you just care about the final state
20:10:57 <crdueck> lets say you have a parser, that keeps the state of whats left to parse in the State monad, and returns the part its consumed
20:11:11 <crdueck> when you parse the entire input, you dont care about the final state (its empty)
20:11:36 <crdueck> so evalState would return the parsed result, and discard the final state
20:12:07 <crdueck> i have an example of that if you'd like
20:12:14 <dmj> ah I see, yes please.
20:12:47 <dmj> I knew nothing of parsec a week ago, now I'm stuck with this monstrous ast.
20:13:04 <crdueck> http://sprunge.us/HLIh
20:15:48 <dmj> :t splitAT
20:15:50 <lambdabot>     Not in scope: `splitAT'
20:15:50 <lambdabot>     Perhaps you meant one of these:
20:15:50 <lambdabot>       `splitAt' (imported from Data.List),
20:15:56 <dmj> :t splitAt
20:15:58 <lambdabot> Int -> [a] -> ([a], [a])
20:16:04 <crdueck> dmj: parseGNM' :: State [B.ByteString] (B.ByteString -> GNMMessage), if that helps
20:16:36 <crdueck> > splitAt 3 [1,2,3,4,5]
20:16:38 <lambdabot>   ([1,2,3],[4,5])
20:16:43 <dmj> So why isn't State in your type signature?
20:17:09 <dmj> oh nevermind it would be if it was included
20:17:09 <crdueck> parseGNM' is a stateful computation, parseGNM isnt. I run the State monad in parseGNM and get a pure result
20:22:05 <dmj> crdueck: So where are you writing it back to IO? I see b.readFile
20:22:20 <dmj> no writeFile?
20:22:40 <crdueck> dmj: in this case, I am just parsing the file into an in-memory [GNMMessage]
20:22:51 <crdueck> some other function can use that
20:23:48 <dmj> so when you call state . splitAt 3, you are incrementing the state?
20:23:58 <crdueck> yes
20:23:59 <crdueck> :t state
20:24:01 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
20:24:04 <crdueck> :t splitAt
20:24:06 <lambdabot> Int -> [a] -> ([a], [a])
20:24:35 <crdueck> can you see how those types match up?
20:26:03 <dmj> since list is a monad your (s -> (a,s)) maps to [a] -> ([a],[a])
20:26:34 <dmj> you already provided int, so its curried and makes it match right?
20:26:39 <crdueck> yes, but not because list is a monad
20:26:42 <crdueck> thats right though
20:27:08 <dmj> s and a are two different types so that is throwing me off
20:27:22 <dmj> wheres the other is all [a]'s
20:27:50 <crdueck> yes, but theres nothing stopping s ~ a
20:28:06 <crdueck> meaning type equality
20:28:50 <crdueck> if i wrote do { consumeN 3; consumeN 2; consumeN 1 } , the state of whats left in the list would be implicitly passed to each consumeN
20:29:39 <crdueck> @let consumeN = state . splitAt
20:29:41 <lambdabot>  Defined.
20:30:06 * hackagebot linear 1.0.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.0.1 (EdwardKmett)
20:30:13 <dmj> so when you call eval state it will only return what is left. in (a,s)
20:30:17 <dmj> :t evalState
20:30:19 <lambdabot> State s a -> s -> a
20:30:28 <crdueck> evalState (do {x <- consumeN 3; y <- consumeN 2; z <- consumeN 1; return (x,y,z) } "abcdefg"
20:30:31 <crdueck> > evalState (do {x <- consumeN 3; y <- consumeN 2; z <- consumeN 1; return (x,y,z) } "abcdefg"
20:30:34 <lambdabot>   <hint>:1:84: parse error on input `"'
20:30:39 <crdueck> > evalState (do {x <- consumeN 3; y <- consumeN 2; z <- consumeN 1; return (x,y,z) }) "abcdefg"
20:30:41 <lambdabot>   ("abc","de","f")
20:31:14 <crdueck> > execState (do {x <- consumeN 3; y <- consumeN 2; z <- consumeN 1; return (x,y,z) }) "abcdefg"
20:31:17 <lambdabot>   "g"
20:31:25 <crdueck> because the 'g' wasnt consumed
20:31:46 <dmj> woa ok
20:31:56 <dmj> so it's all or nothing
20:32:11 <crdueck> what do you mean by that?
20:32:37 <dmj> if all the chars in the string are not consumed it won't return any that have been consumed
20:32:46 <crdueck> > runState (do {x <- consumeN 3; y <- consumeN 2; z <- consumeN 1; return (x,y,z) }) "abcdefg"
20:32:49 <lambdabot>   (("abc","de","f"),"g")
20:33:03 <crdueck> remember, execState only returns the final state
20:33:05 <dmj> oh sorry, thats for execSTate
20:33:57 <dmj> This might be naive, but is this why Parsec uses Either Left of Right when evaluating parsers
20:34:04 <dmj> Left or Right
20:34:19 <crdueck> thats to allow an informative error message if parsing fails
20:34:33 <crdueck> Left is generally used to store error messages/values
20:34:41 <crdueck> and Right for a succesful result
20:35:05 <crdueck> they could use Maybe, but then you dont get any information when parsing fails
20:35:18 <crdueck> since Nothing doesnt tell you anything besides "failed computation"
20:35:45 <dmj> ok, but parsec uses the state monad under the hood when evaluating parsers I have made correct?
20:35:58 <crdueck> something similar, I think they use their own monad
20:36:29 <dmj> so I like your example on parsing with the State monad. Would this be overkill for just an accumulator?
20:36:37 <dmj> in my case
20:37:08 <slack1256> I don't have any background on CS
20:37:16 <slack1256> why is code coverage useful?
20:37:28 <slack1256> why hpc percentage is a big deal?
20:37:49 <slack1256> *why is hpc a big deal? (sorry)
20:38:47 <crdueck> if you need to incr/decr the Int accumulator, then State sounds right
20:39:16 <croikle> slack1256: the idea is you want your tests to test all of your code
20:39:19 <crdueck> if you didnt use State, you'd probably be hand-writing the code the State monad would generate anyways
20:40:04 <crdueck> it just hides all the ugly tuple passing for you
20:41:06 <dmj> crdueck: yes, my biggest problem with an accumulator is knowing when to decrement. Let's say I have an If statement nested inside an If statement. In the second If I need to decrement (so the vm instructions are consistent). but since the If evaluator function is recursive it has no knowledge of what is the first or second if statement. In that sense my simple accumulator is worthless
20:43:23 <crdueck> dmj: its hard to understand without knowing how your program works. the state monad could hold a (RecursionLevel :: Int, IfCounter :: Int) as its state?
20:43:34 <crdueck> there is probably a more elegant solution
20:44:12 <slack1256> croikle: could you say for instance "it's the percentage of 'code' that your tests touch (at least once)"
20:44:23 <crdueck> monads allow computations to depend on the results of previous computations, so it should be possible
20:47:37 <dmj> :t runState
20:47:38 <lambdabot> State s a -> s -> (a, s)
20:48:02 <dmj> :t runReaderT
20:48:03 <lambdabot> ReaderT r m a -> r -> m a
20:50:15 <dmj> slack1256: code coverage is important in imperative paradigms (Java, C#, C++) to ensure that your unit tests are actually implementing desired functionality and also avoiding bugs. In IDE packages like Visual Studio they will allow you to print a report of the actual percentage of code that your unit tests cover. So in that sense, yes, it can be a percentage
20:51:11 <dmj> slack1256: actually, probably important in any paradigm, but especially those that are mutable by default, which is every language but haskell.
20:51:21 <slack1256> dmj: why only in imperative?
20:51:21 <dmj> and clean and miranda
20:51:23 <slack1256> oh
20:52:41 <dmj> slak1256: haskell has a library called quickcheck that lets you do property based testing. Which can be just as effective as manually writing your own unit tests
20:52:58 <dmj> it also has HUnit for unit tests
20:53:06 <BMeph> (or even more effective. ;)
20:53:12 <dmj> ;)
20:53:38 <dmj> crdueck: Thanks for all your help so far, I'll let you know how it goes.
20:54:50 <crdueck> dmj: no problem, really understanding Reader, State, and Writer was a milestone in my haskell career :)
20:57:23 <slack1256> dmj: oh I thought HUnit and quickcheck where for sightly different purposes
20:59:15 <slack1256> quickcheck => I need random input for to test this definitions, HUnit => I know which cases need to be checked, let's just check that
21:00:06 <BrianHV> I have a data structure that is sequential, but each element needs to be assigned to a row. the number of rows is "small" (<100), but not known at compile time. is there a way for the type system to check that no element is assigned to a row that doesn't actually exist?
21:02:31 <ParahSail1n> BrianHV, i dont think so
21:04:26 <BrianHV> ParahSail1n: thanks. I don't think so either, but I've seen some crazy tricks with recursive types to represent things sort of like this. wasn't sure if I was missing something.
21:05:33 <ParahSail1n> in existing packages like vector and array, i've only seen checks like that done in actual code as opposed to type system inference
21:05:57 <BrianHV> and those packages are written by more clueful people than me.
21:06:36 <BrianHV> I wonder if there's a good way of quickchecking my structure mutators to make sure I don't lose consistency
21:07:56 <fragamus> ugh I'm back in ByteString Hell
21:09:37 <YayMe> You sure ByteString isn't just back to fragamus Hell?
21:09:50 <fragamus> Somewhat
21:10:03 <slack1256> which of the hell? the Lazy/Strict hell?
21:10:09 <slack1256> the ffi hell?
21:10:20 <fragamus> Lazy strict hell
21:10:26 <slack1256> the I wanted Text but just got this nasty bytestring!
21:10:46 <slack1256> fragamus: oh the 3rd hell
21:10:54 <slack1256> nice choice. very popular this days
21:11:25 <fragamus> yes I must have done great evil to be thrust so into Lazy Strict BytesString Hell
21:12:00 <slack1256> fragamus: not that much, the guys in the "ffi/bytestring hell" have it worse
21:12:30 <slack1256> in which are of the hell are you? "The library expect a Lazy Bytestring but I just got this boring Strict ones!"
21:12:57 <YayMe> Is there particular reason for having both strict and lazy bytestrings? Or rather, are scenarios where strict bytestrings are actually worth having that common?
21:13:02 <slack1256> or the "I got a space leak but I am already Strict, should I put two bangs instead"?
21:13:10 <fragamus> I have lazy but I need strict
21:13:37 <fragamus> I'm using Lazy to generate some data and then I need to send via UDP
21:13:46 <slack1256> YayMe: for example when using the FFI to pass byteString to C
21:13:54 <slack1256> you won't want them lazy :-)
21:14:03 <YayMe> makes sense I guess
21:14:33 <YayMe> I'm so used to streams from working in C# for years I feel like lazy should be fine the vast majority of the time
21:15:10 <slack1256> fragamus: and the standard function to pass from Lazy -> Strict are failing? why?
21:15:13 <fragamus> *Should* is a word we don't use in ByteString Hell
21:15:35 <fragamus> *why*
21:16:19 <slack1256> no, explain why you aren't using them, I am interested :-)
21:17:19 <slack1256> hey guys! edwardk left
21:17:25 <slack1256> we can say what we think now
21:17:34 <slack1256> Hey edwardk! you rock
21:17:38 <slack1256> hah! take that mate!
21:18:38 <YayMe> You can define alternative in terms of MonadPlus?
21:20:24 <latro`a_> as far as I understand the types work out but depending on which MonadPlus laws you're using you may not get a valid Alternative
21:20:47 <YayMe> how do you define alternative based on MonadPlus?
21:20:50 <latro`a_> for example there are at least two MonadPlus instances for Maybe, one of them doesn't make sense for Alternative
21:20:59 <YayMe> ah
21:21:21 <YayMe> MonadPlus has some controversy about it, doesn't it?
21:21:29 <arkeet> does it?
21:21:33 <latro`a_> a bit, yeah
21:21:48 <latro`a_> there are some laws that are well established and then some others that are nice in one circumstance or another
21:22:17 <latro`a_> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
21:22:17 <arkeet> what are the laws, other than "it's a monoid object in the category of monads"?
21:22:30 <latro`a_> Left Zero, Monoid, and then either Left Distribution or Left Catch
21:22:42 <latro`a_> the accepted laws are what you just said
21:22:48 <latro`a_> but those by themselves are basically useless
21:23:03 <arkeet> no, this is different from "m a is a monoid"
21:23:14 <latro`a_> I know, that's not what I said
21:23:18 <arkeet> ?
21:23:42 <latro`a_> I was referring to the law listed as Monoid on that page
21:24:22 <latro`a_> oh wait nvm, I see, I think the version you are thinking of is the distribution version
21:24:37 <arkeet> I think so.
21:24:40 <arkeet> I haven't written it out.
21:24:49 <latro`a_> whereas the catching version doesn't have the interaction with >>=
21:24:53 <arkeet> I also think it ought to involve both return and bind.
21:24:56 <latro`a_> but is nonetheless rather useful
21:25:08 * hackagebot lagrangian 0.2.0.0 - Solve lagrangian multiplier problems  http://hackage.haskell.org/package/lagrangian-0.2.0.0 (JonathanFischoff)
21:25:11 <latro`a_> well, for say Maybe, once you specify one of those laws the result is unique iirc
21:25:22 <latro`a_> but the instances are different; one is symmetric, the other is not
21:25:48 <latro`a_> (note the instance MonadPlus and instance MonadOr further down)
21:26:18 <arkeet> that MonadPlus instance looks...
21:26:23 <latro`a_> the MonadOr one is probably what you want for what Maybe is actually used for, even though the MonadPlus one is sort of mathematically better
21:26:28 <arkeet> it is?
21:26:36 <arkeet> mplus (Just x) (Just y) = Nothing?
21:26:41 <latro`a_> no
21:26:46 <latro`a_> oh wait
21:26:48 <latro`a_> huh
21:26:52 <latro`a_> perhaps that was a mistake
21:27:06 <latro`a_> ...now that I think about it as written that doesn't even typecheck
21:27:06 <YayMe> monads is a category... that category stuff still sounds extremely confusing... I'm just glad to have typeclasses and their laws figured out (conceptually anyway)
21:27:22 <latro`a_> they dropped the Justs on the rhs
21:27:24 <arkeet> latro`a_: heh.
21:27:51 <YayMe> > mplus (Just 3) (Just 2)
21:27:52 <lambdabot>   Just 3
21:28:12 <latro`a_> I think that was supposed to be
21:28:18 <latro`a_> mplus (Just x) _ = Just x
21:28:27 <latro`a_> mplus _ (Just y) = Just y
21:28:30 <latro`a_> mplus _ _ = Nothing
21:28:45 <latro`a_> so that if you get two Justs the first one is taken
21:29:12 <arkeet> yes, that's the current instance.
21:29:20 <YayMe> latro`a_: But you said there's another implementation of mplus for Maybe?
21:29:26 <YayMe> how does it behave?
21:29:34 <latro`a_> the morelse example there is a technically valid mplus
21:29:35 <arkeet> the only other reasonable one would be the right-biased one, I think.
21:29:51 <latro`a_> in the sense that it typechecks and satisfies the monoid laws
21:29:54 <YayMe> ah
21:30:08 * hackagebot monad-memo 0.4.1 - Memoization monad transformer  http://hackage.haskell.org/package/monad-memo-0.4.1 (EduardSergeev)
21:30:23 <latro`a_> the right biased one also works, but is essentially isomorphic anyways
21:30:50 <YayMe> latro`a_: something like mplus x Nothing = x; mplus _ x = x;
21:30:53 <YayMe> ?
21:31:05 <arkeet> yes
21:31:07 <TravisD> Is the chapter of Real World Haskell on profiling a good place to start with writing efficient Haskell code?
21:31:32 <YayMe> yeah I guess that is isomorphic...
21:31:37 <fragamus> @hoogle toStrict
21:31:37 <lambdabot> Data.Text.Lazy toStrict :: Text -> Text
21:31:37 <lambdabot> Control.Monad.ST.Lazy lazyToStrictST :: ST s a -> ST s a
21:33:01 <YayMe> they could map as mplus x y = mplus' y x I suppose
21:33:14 <YayMe> I think?
21:33:26 <latro`a_> that would be the isomorphism, yes
21:34:19 <latro`a_> hm, is it considered bad style to use _ when only one pattern can now go in that spot?
21:34:19 <fragamus> http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Lazy.html#g:2
21:34:43 <latro`a_> for example in the second line of mplus up there, only Nothing can go in the _
21:34:45 <YayMe> I was thinking the same heh
21:34:55 <fragamus> why is toStrict advertised in the URL i just gave but it is not defined
21:34:58 <fragamus> @hoogle toStrict
21:34:58 <lambdabot> Data.Text.Lazy toStrict :: Text -> Text
21:34:58 <lambdabot> Control.Monad.ST.Lazy lazyToStrictST :: ST s a -> ST s a
21:35:14 <arkeet> fragamus: hoogle does not know all.
21:35:21 <fragamus> apparently
21:35:30 <arkeet> but it's in bytestring.
21:35:43 <arkeet> but only since 0.10.
21:35:49 <tvynr> latro`a_: I don't know about style, but I usually try to avoid the _ pattern whenever I can.  It's brittle in the face of refactoring.  If I add a new constructor to an ADT during a refactoring, I like that the type system can usually find all of the places I need to update my code.  (That said, I'll use _ if it saves me a dozen lines of code or other painful ugliness.)
21:36:19 <latro`a_> I assume you'd also use it for the "else" pattern at the bottom
21:36:35 <latro`a_> because that doesn't suffer from refactoring issues
21:37:25 <tvynr> latro`a_: Only if there are more than two or three constructors for the else case (for practical reasons).  Since I don't know what this hypothetical new constructor will be, I usually don't know for sure that it would fall into the "else" side of my reasoning at a given case expression.
21:37:49 <latro`a_> well, it depends how "elseish" the case is I guess
21:38:04 <latro`a_> for example if there's just a default value at the end, that'll probably persist after refactoring
21:38:31 <latro`a_> I see your point, though
21:38:44 <tvynr> latro`a_: *nodnod* It's a judgment call.  But I err on the side of being a touch verbose.  I love Haskell for its type system, but debugging it at runtime is quite a pain in my (limited) experience.  So I try to tend to these refactoring issues as carefully as possible.
21:38:48 <YayMe> if maybe got a new constructor of Sometimes x, mplus x Nothing = x; mplus Nothing x = x; would throw an error about missing match for Sometimes where _ would just gobble it up without telling you
21:39:10 <tvynr> YayMe: Yeah, that's the gist.
21:39:12 <YayMe> makes sense to avoid _ then
21:39:26 <tvynr> YayMe: Although I'm not really concerned about Maybe getting a new constructor, your example is the thing I'm aiming at.  :)
21:40:02 <YayMe> tvynr: you misunderestimate the entropy qubits will bring us! Even maybe will change! *boggle*
21:40:11 <tvynr> That said, I'll use _ to prevent myself from enumerating all of the constructors for a given ADT everywhere it appears.
21:40:18 <fragamus> Module `Data.ByteString.Lazy' does not export `toStrict'
21:40:41 <tvynr> YayMe: *hehe* I like to thing we'd solve that with conversion functions and a newtype wrapper or two.  :-P
21:41:52 <fragamus> oh no I need the new version
21:43:24 <fragamus> I just installed the platform a week ago‚Ä¶ why do they not include a recent version of bytestring
21:50:09 * hackagebot language-java 0.2.2 - Manipulating Java source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/language-java-0.2.2 (VincentHanquez)
21:50:17 <fragamus> cabal install network-bytestring    this is going to break a lot of stuff...
21:52:15 <arkeet> stuff like that is why I prefer to get ghc and install all the other packages separately.
21:55:09 * hackagebot lagrangian 0.2.0.1 - Solve lagrangian multiplier problems  http://hackage.haskell.org/package/lagrangian-0.2.0.1 (JonathanFischoff)
21:58:14 <fragamus> network-bytestring-0.1.1.2 depends on unix-2.6.0.1 which failed to install.
21:58:58 <fragamus> hey edwardk
21:59:02 <edwardk> yo
21:59:02 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
21:59:12 <edwardk> you managed to finally catch me when i'm not pair programming, etc. ;)
21:59:20 <fragamus> im interested in comonads
21:59:26 <fragamus> Yeah
21:59:31 <edwardk> what a coincidence. i've heard of those.
21:59:43 <edwardk> what do you want to know?
21:59:50 <shachaf> im interesting in common ad operators
21:59:55 <shachaf> s/ing/ed/
22:00:09 <edwardk> :t diff
22:00:09 * hackagebot lagrangian 0.2.0.2 - Solve lagrangian multiplier problems  http://hackage.haskell.org/package/lagrangian-0.2.0.2 (JonathanFischoff)
22:00:10 <lambdabot> Num a => (forall (s :: * -> *). Numeric.AD.Types.Mode s => AD s a -> AD s a) -> a -> a
22:00:11 <edwardk> :t grad
22:00:13 <lambdabot> (Num a, Traversable f) => (forall (s :: * -> *). Numeric.AD.Types.Mode s => f (AD s a) -> AD s a) -> f a -> f a
22:00:15 <edwardk> there you go
22:00:18 <fragamus> well, I am just trying to get a sense of them
22:00:25 <edwardk> fair enough
22:00:32 <edwardk> have you worked through any of them by hand yet?
22:00:48 <fragamus> I read the cellular automaton example that is touted here
22:00:52 <edwardk> its kind of like with monads you work through enough of them and all of a sudden they click and are like the third one you've seen ;)
22:00:57 <fragamus> but I sense that they are more general
22:01:19 <edwardk> lets just start with the most boring thing you can think of that satisfies the comonad laws
22:01:24 <edwardk> (,) e
22:01:31 * shachaf wonders whether Store is in some sense "the most general" as far as intuition goes, like Cont is for monads.
22:01:32 <edwardk> extract :: (e, a) -> a
22:01:44 <edwardk> shachaf: i tend to think of it as such
22:02:00 <edwardk> fragamus: i'll let you write the definitions for (,) e as i give the signatures ;)
22:02:46 <Hafydd> instance Comonad ;) e
22:02:58 <edwardk> Hafydd: =)
22:03:15 <edwardk> Hafydd: instance Comonad =P
22:03:20 <Hafydd> Heh.
22:04:37 <fragamus> ok
22:06:13 <edwardk> anyways the (,) e  comonad just has those two operations extract :: (e, a) -> a     and extend :: ((e, a) -> b) -> (e, a) -> (e, b)
22:06:18 <edwardk> @djinn (e,a) -> a
22:06:18 <lambdabot> f (_, a) = a
22:06:29 <edwardk> @djinn ((e,a) -> b) -> (e, a) -> (e, b)
22:06:29 <lambdabot> f a (b, c) = (b, a (b, c))
22:07:30 <fragamus> extract (_,a) = a
22:07:37 <edwardk> so extend in this context is just taking a function that needs some value (a) and something extra (e) which can calculate b from it, and rewraps it with the (e) as an optional extra
22:08:07 <edwardk> extract is just throwing away this extra bit of data
22:08:31 <edwardk> this is the most boring comonad out there, its the moral equivalent of the 'Reader' monad.
22:09:04 <fragamus> ok
22:09:47 <edwardk> we can 'ask :: (e, a) -> e'     then   extend ask (e,a) = (e,e)
22:10:40 <edwardk> this kind of comonad gets a fair bit of use though, becuase its so common. 'extract' gives you a common name for getting the part you care out of the comonad.
22:11:25 <fragamus> extend f x = f x
22:11:27 <edwardk> this product comonad (i call it Env in comonad-transformers) has the 'ease of use benefit' that there is only one value of type 'a' in it to concern yourself with.
22:11:37 <edwardk> ere its a little more complicated than that
22:11:51 <edwardk> extend f w@(e,_) = (e, f w)
22:11:55 <fragamus> lemme check again
22:12:06 <edwardk> we need to wrap the 'e' around the result
22:12:15 <edwardk> ((e, a) -> b) -> (e,a) -> (e, b)
22:12:34 <fragamus> oic
22:13:04 <sopvop> are alex and happy still the best choice for prog language parsing?
22:13:55 <Sgeo> Said this in another channel, but
22:13:56 <Sgeo> Iteratees are the new monad tutorials.
22:14:24 <edwardk> sopvop: depends on what you want out of the tool. trifecta gives better diagnostics. happy gives better error recovery so you can spam the user with more parse errors
22:14:59 <edwardk> alex is pretty terrible in that it doesn't really understand utf-8, etc.
22:14:59 <fragamus> extend f  z@(e, a) -> (e, f z)
22:15:05 <edwardk> fragamus: yep
22:15:07 <lightquake> bah. i'm at a dilemma. do i want to use hamlet or heist for my HTML templating
22:15:20 <sopvop> alex 3.0 states it understands utf-8
22:15:29 <lightquake> trifecta looks neat, wish i could've used it
22:15:51 <edwardk> then i stand corrected, i guess jaffacake got sick of dealing with the hack ;)
22:16:12 <edwardk> lightquake: this the classroom thing?
22:16:12 <sopvop> and I find trifecta a bit lacking on documentation... at least it was half a year ago
22:16:17 <lightquake> yeah
22:16:26 <lightquake> they explicitly wanted us to not use parser combinator libraries
22:16:28 <edwardk> sopvop: most of trifecta is factored out into parsers now
22:16:32 <edwardk> @hackage parsers
22:16:32 <lambdabot> http://hackage.haskell.org/package/parsers
22:16:49 <edwardk> and yeah it was terrible doc wise
22:16:56 <edwardk> i turned over a new leaf on documentation with lens
22:17:05 <edwardk> i'm slowly trying to percolate that back through my older libs
22:17:57 <lightquake> hamlet kills my compile times, and i can't use most inline functions, but it gives me type safety, which is very nice. heist i can load from disk every time during development, but i can have unbound tags that get propagated through
22:18:35 <fragamus> what is the fastest parsing lib
22:18:39 <edwardk> fragamus: one common use for something like this comonad would be holding onto 'Typed' or 'Named' values, where you have some extra fact, want to be able to map over them, maybe change out the contents of one of them while using the name, etc.
22:19:02 <fragamus> i think i see
22:19:04 <sopvop> I like how edwardk chooses most generic names for packages. Everyone will use it anyway so why bother with fancy names.
22:19:10 <lightquake> haha
22:19:13 <edwardk> heh
22:19:36 <lightquake> i think i might use hamlet, it'll be instructional in how to use it in snap
22:19:40 <edwardk> people give me crap for unimaginative names until i start using imaginative names, then they give me crap about that ;)
22:20:15 <edwardk> parsers was probably the most egregious land grab i've done naming wise. maybe lens was a close second given the number of other lens libraries
22:20:38 <sopvop> tables?
22:20:42 <lightquake> but yours is the best!
22:20:51 <fragamus> oh so like this: I have chromosomes and fitness values and mostly I just work with one and leave the other so...
22:20:51 <edwardk> i mostly name packages to minimize the amount of effort i have to put into figuring out which package it is in my haskell folder ;)
22:21:01 <edwardk> sopvop: 'analytics' is also pretty blunt =)
22:21:08 <shachaf> edwardk: You should use rhyming slang.
22:21:17 <edwardk> shachaf: =)
22:21:23 <elliott> edwardk: you should start making ridiculous backronyms. like that ChristmasTree library
22:21:24 <lightquake> edwardk: for the longest time i thought analytics was some kind of google analytics thing
22:21:27 <lightquake> i'm still not sure what it is
22:22:39 <edwardk> fragamus: you could have a data Chromosomed a = Chromosomed Chromosome a; instance Comonad Chromosomed where extract (Chromosomed _ a) = a; extend f w@(Chromosomed c _) = Chromosomed c (f w)
22:23:08 <fragamus> nice
22:23:20 <edwardk> fragamus: then you can extend, fmap, traverse, foldMap, etc. to manipulate the 'a' in there.
22:23:37 <edwardk> and you carry along the chromosome for the ride
22:23:48 <fragamus> yeah that is nice
22:23:50 <edwardk> its a fairly boring application, but it is nice to just not have to make up the name
22:23:58 <edwardk> 'extract' just does what you want
22:24:50 <fragamus> well I am doing great with monads but comonads seem so important and I haven't ever delved into it so that is why I am here
22:24:58 <edwardk> lightquake: its a database engine i'm building up in haskell that focuses on summarizing the data that gets stored in it, elaborating the data with something like datalog and streaming data flow processing with recursion
22:25:07 <fragamus> thanks for the info and I shall try to comprehend it
22:25:24 <edwardk> lightquake: basically the end goal is to be able to let haskell do some serious data processing
22:25:31 <lightquake> neat :)
22:25:35 <edwardk> fragamus: so thats the easiest comonad to understand
22:25:53 <edwardk> fragamus: Store generalizes the cellular automaton example, which can be seen as a special case of Store.
22:26:13 <edwardk> Traced is er.. a bit harder to motivate ;)
22:26:21 <edwardk> but there are lots of stream processing comonads
22:27:33 <edwardk> another good comonad is the 'cofree comonad'. we can get there by considering just a binary tree and what it looks like as a comonad.
22:27:54 <edwardk> data Tree a = Bin a (Tree a) (Tree a) | Tip a
22:27:59 <edwardk> so how would i extract?
22:28:20 <edwardk> if it helps you can ignore 'Tip' and just have an infinite tree.
22:28:33 <lightquake> oh, trees with values in branches are comonads, not trees with values only at tips
22:28:39 <edwardk> yeah
22:29:05 <edwardk> the comonad lets you _redecorate_ the tree, a monad lets you grow it
22:30:01 <edwardk> notice something the comonad will never change the shape of the structure its manipulating. it'll use the (w a -> b)  action over and over to assemble a bunch of different b's from different 'perspectives', and then glue that mosaic together to form a new 'w b'
22:30:30 <edwardk> lightquake: its very much a work-in-progress anyways
22:31:05 <edwardk> i'm still working on the backing store, the dataflow processing engine, a bunch of reductions we can use on the data, some corners of the semantics, how to deal with transactions, etc.
22:34:21 <drbean> The right bracket of a list split over several lines has to be over the right as much as the left bracket?
22:34:58 <edwardk> drbean: no, but it does have to obey whatever other layout is in scope introduced by 'do', 'let', 'where' and 'of'
22:36:22 <edwardk> the word after each one of those keywords introduces a 'layout context' so if you try to outdent a brace of bracket or paren farther than that you're closing the context in which the paren probably started in the first place.
22:46:34 <sopvop> whoa, trifecta pulls half of hackage with it
22:46:45 <edwardk> heh
22:46:54 <edwardk> wait til you try to build analytics some day ;)
22:49:30 <amindfv> edwardk: you have a comment on stackoverflow about being able to build data types in ghci with functor/bifunctor combinators -- can you explain how that works?
22:50:31 <edwardk> amindfv: those used to be in category-extras. i recently ported a few of the nicer ones to the bifunctors package though
22:50:44 <edwardk> @hackage bifunctors
22:50:44 <lambdabot> http://hackage.haskell.org/package/bifunctors
22:50:52 <edwardk> http://hackage.haskell.org/packages/archive/bifunctors/3.2.0.1/doc/html/Data-Bifunctor-Joker.html
22:51:06 <edwardk> http://hackage.haskell.org/packages/archive/bifunctors/3.2.0.1/doc/html/Data-Bifunctor-Flip.html
22:51:39 <edwardk> but those can be viewed as variations on using Product with Identity or Const e, etc.
22:52:07 <edwardk> (or Proxy), etc.
22:56:12 <edwardk> but you could fake a list in the repl, by, say taking a Mu (Coproduct (Product (Const a) Identity) Proxy)
22:56:20 <edwardk> if i derived that right =)
22:56:23 <edwardk> i wouldn't recommend it
22:56:27 <edwardk> and the compiler does it these days
22:57:31 <amindfv> edwardk: i see; thanks
22:57:39 <amindfv> i don't think i've seen that before
22:58:04 <edwardk> it was something i thought would be a good idea back when i first found haskell
22:58:13 <edwardk> before i realized quite how pathological that gets ;)
22:58:40 <edwardk> roconnor wrote a tool for lambdabot iirc that unmtl's the types in reaction to that.
23:00:04 <edwardk> something used to have all the Biff, etc. types that category extra used to have
23:00:13 <edwardk> er category-extras
23:22:35 <sopvop> edwardk: How do I get parser position from trifecta/parsers?
23:23:27 <edwardk> trifecta provides 'delta'
23:23:32 <edwardk> parsers doesn't give you one
23:23:50 <edwardk> since there isn't a portable position i can give back across the different parsers, some don't maintain it
23:25:02 <sopvop> Oh, it's DeltaParsing typeclass.
23:27:29 <chemist> :t map
23:27:31 <lambdabot> (a -> b) -> [a] -> [b]
23:30:42 <applicative_> :t fmap
23:30:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
