00:00:27 <arbn> lispy: Recently, I was writing some Python code, and there was a horrible bug due to the overloading of the subscript operator that it took me like 30 mins to find. I felt like an idiot. :P
00:00:34 <johnw> lispy: maybe you just want LYAP? :)
00:00:36 <lispy> aviraldg: aye. I've pretty much never successfull refactor a python program.
00:01:24 <arbn> I'm too used to Haskell doing half of my thinking for me.
00:01:33 <aviraldg> lispy, it certainly has its faults
00:01:43 <aviraldg> arbn, ...?
00:02:00 <lispy> aviraldg: many of us learn to use types to direct our thinking.
00:02:07 <lispy> aviraldg: and haskell can infer most types...
00:02:41 <hpaste> adnap pasted “test” at http://hpaste.org/84147
00:02:54 <johnw> ooh, refactoring in Python can indeed be a huge PITA if your tests are awesome
00:02:55 <lispy> aviraldg: http://matthew.brecknell.net/posts/2013/02/26/hole-driven-haskell/
00:03:10 <johnw> it's funny how much type-checking replaces certain kinds of testing in monotyped languages
00:03:14 <lispy> aviraldg: no one programs literally like that video shows but that video makes an interesting point
00:03:28 <arbn> aviraldg: I design my program with types, and then most of my time *writing code* is just getting the types to match up. I have trouble without this crutch.
00:03:44 <johnw> -
00:03:57 <adnap> What is wrong with this? I'm getting "Couldn't match expected type `forall t. Frameworks t => Moment t ()' with actual type `Moment t0 ()'"
00:04:20 <aviraldg> Which brings me to why I started trying to learn Haskell: mixing up `item` and `item_view` in Python (in a project too small to have tests) and not realising my mistake until after deployment. :-/
00:04:29 <johnw> adnap: need to see code
00:04:35 <adnap> johnw: see hpaste
00:04:38 <simpson> aviraldg: :c
00:04:58 <simpson> aviraldg: Deploying without testing makes people sad.
00:05:09 <johnw> adnap: why do you need forall t?
00:05:23 <johnw> i think that is your problem
00:05:24 <aviraldg> simpson, => (in a project too small to have tests)
00:05:35 <johnw> you want to call a function that work for any t with a specific t
00:05:37 <lispy> aviraldg: I think that's the right kind of reason to give haskell a shot
00:05:54 <johnw> (that requires a value that ranges over any t)
00:06:01 <aviraldg> :)
00:06:03 <johnw> err, a type that does
00:06:17 <johnw> where is shachaf when you need him
00:06:20 <adnap> johnw: I have no idea
00:06:24 <simpson> aviraldg: Well, whatever floats your boat, but if something's worth deploying, it's usually worth testing.
00:06:28 <johnw> adnap: just delete it and you should be fine
00:06:37 <adnap> johnw: I tried that already. It doesn't work
00:06:43 <johnw> same error?
00:06:43 <adnap> johnw: Why don't you try compiling the code
00:06:52 <johnw> adnap: because I have other things to do
00:06:57 <adnap> johnw: Then don't help me
00:06:57 <lispy> aviraldg: You might really enjoy this paper: ftp://ftp.cs.iastate.edu/pub/techreports/TR05-02/TR.pdf
00:07:05 <lispy> aviraldg: it's not really haskell specific.
00:07:42 <lispy> aviraldg: you could follow that paper in python, for example
00:07:47 * arbn thinks that lispy really likes reading papers typeset in LaTeX, fulfilling a stereotype of Haskellers.
00:08:45 <lispy> arbn: It's true. I do. Also, reading papers is the only way to level up in comp. sci. :)
00:08:49 <adnap> arbn: I guess most programmers who write academic papers uee LaTeX
00:09:00 <arbn> lispy: Haha. Indeed.
00:09:32 <arbn> adnap: Yeah. I just see links to academic papers may more frequently among this crowd than, say, among Rubyists.
00:09:52 <lispy> I recommend reading 1-2 papers/week and pausing that to implement any of them that you think would be relevant to what you're actually doing.
00:09:53 * aviraldg smiles at the mention of Rubyists
00:10:34 <no-n> partial application is sexy
00:10:35 <lispy> Reading a paper gives you a clue but you won't actually understand the material in a meaningful way if you don't also implement it
00:11:26 <arbn> lispy: Yeah. I kind of want to re-implement the modeling of OO inheritance with typeclasses. I know that HOC does it, but HOC is kind of dead, and it would be useful for a current project.
00:11:55 <lispy> arbn: HOC = haskell on crack?
00:12:25 <arbn> lispy: HOC == Haskell to Objective C
00:12:28 <arbn> :P
00:12:36 <lispy> ah, cool.
00:12:48 * lispy should head to bed
00:12:55 <lispy> 'night folks
00:13:00 <arbn> lispy: Night.
00:35:50 <Vertue> johnw: It worked - thanks
00:36:04 <Vertue> ion: Your gist helped loads, thanks
00:36:25 <johnw> Vertue: great!
00:37:21 <ion> nice
00:47:52 <no-n> how can I make my own operators in haskell?
00:48:27 <johnw> no-n: surround the name of the operator function in parens
00:48:32 <johnw> (++++) :: Int
00:48:35 <arkeet> > let x ^%$ y = 2*x + y in 5 ^%$ 8
00:48:35 <johnw> (++++) = 10
00:48:37 <lambdabot>   18
00:48:47 <johnw> well, it wants two argument,s but you get the idea
00:48:52 <johnw> (++++) :: Int -> Int -> Int
00:48:58 <no-n> thanks
00:49:02 <johnw> x ++++ y = x + x + y + y
00:49:15 <johnw> you can use the infixl and infixr declarations to adjust fixity and precedence
00:49:22 <arkeet> remember x ^%$ y is the same as (^%$) x y
00:49:32 <no-n> ah
00:49:50 <no-n> well, I just wanted to do let (%) = mod
00:49:55 <arkeet> you can do that.
00:49:57 <no-n> I guess I don't have to worry about setting its precedence?
00:50:04 <johnw> you will
00:50:08 <no-n> ok
00:50:08 <johnw> by default it will have precedence 9
00:50:10 <arkeet> if you don't set it, it will default to infixr 9
00:50:15 <no-n> alright
00:50:16 <johnw> which may be too low
00:50:20 <arkeet> high*
00:51:05 <no-n> how would I give it the same precedence as `mod`?
00:51:17 <arkeet> `mod` would be infixr 9 becuase no one set its precedence.
00:51:21 <elliott> > (0$0`mod`)
00:51:22 <lambdabot>   The operator `GHC.Real.mod' [infixl 7] of a section
00:51:22 <lambdabot>      must have lower pr...
00:51:25 <elliott> arkeet: nope.
00:51:28 <arkeet> oh?
00:51:30 <arkeet> so someone set it.
00:51:31 <elliott> no-n: infixl 7 %
00:51:40 <elliott> no-n: if you do :info op in ghci it'll tell you precedence
00:51:44 <no-n> thanks
00:52:01 <elliott> e.g. :info mod or :info `mod`
00:52:10 <arkeet> I learned something.
00:52:13 <arkeet> kind of trivial but ok
00:54:39 <elliott> unfortunately arkeet all my knowledge is trivial.
00:54:45 <elliott> I use shachaf to remember the complicated things.
01:00:54 <johnw> does anyone know how to download videos from skillsmatter.com?
01:07:26 <BMeph> johnw: Yes.
01:07:58 <johnw> BMeph: share!
01:08:18 <BMeph> (I don't, but you asked for "anyone" and I am absolutely positive that there is an "anyone" out there who does.) ;þ
01:08:25 <johnw> sigh
01:08:59 <simpson> BMeph: Objection; speculation. Provide a proof of your existential witness. :#
01:12:42 <ion> johnw: get_flash_videos seems to work.
01:12:53 <ion> % ~/nobackup/src/get-flash-videos/get_flash_videos 'http://skillsmatter.com/podcast/scala/scalable-web-applications-with-yesod'
01:12:55 <ion> BLAKE_RAIN_-_SCALABLE_WEB_APPLICATIONS.flv: 32% (30066.67 / 93075.31 KiB)
01:13:05 <johnw> ah, thank you!
01:13:21 <no-n> do people commonly name [[a]]'s xss? or xxs?
01:13:29 <johnw> i want to watch SPJ's Adventures with Types, but the connection is so bad it keeps pausing
01:13:45 <no-n> xss makes more sense to me but I think I've seen xxs
01:14:25 <ion> I don’t think i have seen xxs.
01:14:36 <ion> And if i had, i would still not use it. :-P
01:14:46 <no-n> yeah i'll use xss, hehe
01:15:03 <no-n> in learn you a haskell there's a lot of x and xs
01:15:10 <no-n> I don't know if that's common in the haskell world or what
01:15:14 <johnw> learn you a haskell to xs
01:15:25 <no-n> hehe
01:15:57 <ion> When you deconstruct a (:), “foo:foos” for some foo is typical.
01:17:28 <Hafydd> What about xxx? Has anyone ever used that as a name?
01:17:41 <Hafydd> (Or, for that matter, sss?)
01:23:11 <johnw> apps with tons of Perl dependencies == teh suck
01:23:17 * johnw gives up
01:24:02 <hpaste> me pasted “what's going on here?” at http://hpaste.org/84148
01:24:16 <no-n> (that was me, sorry)
01:24:55 <ion> johnw: If you run a Debian variant, debian/control in the source tree lists the dependencies.
01:24:57 <no-n> it's not letting me do the function prototype (is that the right term?) that it comes up with when I do it implicitly
01:25:35 <johnw> ion: that's not a bad idea at all
01:27:03 <dEPy> Anyone can help me understand continuations?
01:27:13 <johnw> dEPy: absolutely!
01:27:23 <dEPy> I know this is #haskell, but, I've been playing with them in ruby and scheme a bit and .. I dont' know :)
01:27:27 <dEPy> I'm confused...
01:27:28 <johnw> dEPy: do you know what a lambda and a closure are?
01:27:47 <dEPy> yes, and I kinda know what continuations are but I have no idea why would I use them
01:28:08 <johnw> well, think of it as a closure that captures not only local variables in scope, but the runtime stack as well
01:28:16 <dEPy> If you want some stuff done then return to the same point of execution with same context why not just wrap that "stuff" into function and call it?
01:28:31 <johnw> so, just as when you run a closure it "recalls" those variables, a continuation can "recall" the execution stack at the time it was made
01:28:39 <augur> dEPy: continuations take many forms
01:28:56 <johnw> dEPy:  think of implementing a green-threading library
01:29:05 <augur> dEPy: one form is exactly what you describe. a function A -> B is a B-type continuation of A
01:29:25 <johnw> contituations could be used to transfer control back to your scheduler, which can then resume the continuation at a later time
01:30:08 <dEPy> ok green threads mighty be the best example I've heard so far :)
01:30:19 <augur> dEPy: consider the "continuization" of a value x: \f -> f x (or in scheme (lambda (f) (f x)))
01:30:54 <augur> dEPy: this gives us the ability to then apply the "value" to its continuation:  (\f -> f x) g
01:31:06 <augur> we get the same result we wouldve gotten by just applying g to x as g x
01:32:03 <augur> lets write \f -> f x as cont x
01:32:14 <no-n> oh, I'd typed [[a]] => [a] instead of [[a]] -> [a] :3
01:32:27 <no-n> silly
01:32:38 <augur> this lets us view x as a thing we do, and the rest of the process as something we push x into (by application)
01:32:45 <augur> cont x g == g x
01:33:01 <augur> ok but thats pretty boring!
01:33:07 <dEPy> y :D
01:33:18 <augur> no not y
01:33:41 <augur> so lets invent some gadget that lets us write this more neatly
01:33:44 <dEPy>  no no, I said "yes", agreeing :)
01:33:50 <dEPy> I mean, I'm wondering where can I use them in day to day
01:33:52 <augur> o ok
01:34:00 <augur> m >>= \x -> M   instead of m (\x -> B)
01:34:04 <augur> infact, lets go one step further
01:34:12 <augur> do x <- m ; M
01:34:25 <augur> which you can read as
01:34:31 <augur> "take x from m, and do M"
01:34:31 <dEPy> I should probably tell you that I don't know haskell.. :D
01:34:40 <augur> dEPy: thats ok, just be flexible!
01:34:45 <dEPy> np :)
01:35:20 <augur> so now we can talk about programs that employ continuized values a plenty. want continuized addition? sure thing:
01:35:35 <augur> do x <- m ; y <- m' ; cont (x + y)
01:35:44 <augur> un-translating our notation a bit:
01:36:02 <augur> m >>= (\x -> m' >>= (\y -> cont (x + y)))
01:36:04 <augur> which is ofcourse just
01:36:14 <augur> m (\x -> m' (\y -> cont (x + y)))
01:36:33 <dEPy> hm
01:36:41 <augur> but now lets consider a different kind of m
01:36:52 <augur> instead of all m's being \f -> f x (ie m = cont x)
01:37:04 <augur> we might have m = \f -> 3
01:37:30 <augur> lets write such things as throw 3
01:37:56 <augur> notice: cont 3 (\x -> x + 1) = 3 + 1 = 4
01:38:02 <augur> but throw 3 (\x -> x + 1) = 3
01:38:18 <augur> because throw ignores the continuation and just gives you back the value
01:38:23 <augur> but translating now into our fun notation:
01:38:46 <augur> throw 3 (\x -> x + 1)   ==   throw 3 >>= (\x -> x + 1)   ==   do x <- throw 3 ; x + 1
01:38:48 <ion> johnw: In fact, the Debian packaging in the source tree seems to build a working package. It had some problems long ago, but it seems to work now.
01:39:44 <augur> dEPy: now it seems that our notation is conveying to us the real purpose of such a throw gadget: when we encounter it, we ignore the rest of the computation!
01:40:28 <augur> forget x + 1, we dont do that, we just hand back 3, end of story
01:40:43 <augur> dEPy: but what might be the use of this? well. what if instead of throw 3, i have
01:40:48 <dEPy> Ok. I think I kinda get it.
01:41:05 <augur> do x <- some-computation-that-might-be-cont-1-or-might-be-throw-3 ; x + 1
01:41:33 <augur> well thats much more interesting. whether or not we continue computing with 1, or just throw out 3, depends on that computation
01:42:14 <augur> for instance!
01:42:30 <augur> do x <- if test then cont 1 else throw 3 ; x + 1
01:42:39 <augur> so now, if test == true, we continue with 1
01:42:49 <augur> but if test == false, we just cancel the rest of that computation and give back 3
01:42:58 <augur> and who knows which we do! it depends on what test is
01:43:21 <dEPy> ok you lost me :)
01:43:31 <augur> dEPy: ok, whered i lose you
01:43:49 <dEPy> so what's the different if I do like:   do x <- if test return 1 else return 3; x +1 ?
01:43:57 <dEPy> ignore my lack of haskell knowledge :D
01:44:05 <augur> well, lets call return cont
01:44:19 <augur> just because we want to "cont"inue computing with its argument
01:44:28 <augur> if we did ... cont 1 ... cont 3 ...
01:44:38 <augur> we'd always be continuing that computation: we'd always end up doing x + 1
01:44:53 <augur> x will be either 1 or 3, but we'd always do x + 1
01:45:08 <augur> throw just ignores all of that
01:45:14 <augur> to see why, translate it back:
01:45:31 <augur> (if test then cont 1 else throw 3) (\x -> x + 1)
01:45:54 <dEPy> oh
01:46:02 <augur> if test == true then we do   cont 1 (\x -> x + 1) which is just (\f -> f 1) (\x -> x + 1) ie 1 + 1
01:46:12 <dEPy> so the first I get it now yes
01:46:18 <augur> but if test == false then we do   throw 3 (\x -> x + 1) which is just (\f -> 3) (\x -> x + 1) ie 3
01:46:18 <dEPy> throws will also ignore x+1
01:46:27 <dEPy> else we pass x+1 as argument to continuation?
01:46:41 <augur> no, (\x -> x + 1) IS the continuation
01:46:58 <augur> we'd apply the continuized value -- cont 1 -- to the continuation, as per the translation
01:47:26 <augur> the continuation being "what to do with the value" or "how to continue computing"
01:48:15 <augur> the idea here is that by continuizing things, you get the ability to have "values" that cancel computation
01:49:18 <augur> dEPy: you can of course do this in scheme just as well:
01:49:37 <augur> ((if test (cont 1) (throw 3)) (lambda (x) (+ x 1)))
01:49:59 <augur> (define (cont x) (lambda (f) (f x)))
01:50:07 <augur> (define (throw x) (lambda (f) x))
01:50:37 <augur> here f = the rest of the computation -- just a function
01:50:46 <augur> cont uses it, throw doesnt
01:51:00 <augur> but thats horrible notation! it doesnt feel right, if you're an imperative thinker
01:51:23 <augur> so haskell has do notation (basically what i used above tho with some differences)
01:51:40 <dEPy> Ok I think I get it know.
01:51:51 <augur> this is just one example of what you can do with continuations
01:51:59 <augur> theres lots of interesting stuff.
01:52:02 <dEPy> But, I guess I asked the wrong questino :D
01:52:09 <dEPy> I meant to ask about call/cc :)
01:52:18 <dEPy> call with curent continuation
01:52:22 <augur> call/cc is a beast of a gadget that you probably dont want ;)
01:53:48 <augur> call/cc is kind of like this, except it uses some ambient "rest of the computation" that is determined in some specific way
01:54:44 <augur> i dont know enough about it to properly explain it tho.
01:54:50 <dEPy> ok :) np
01:54:59 <dEPy> At least I know now what continuation is :)
01:55:03 <augur> :)
01:55:20 <augur> there are some interesting things you can do with continuations
01:55:40 <arbn> dEPy: http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
01:55:55 <augur> for instance, consider this gadget: all'
01:56:27 <augur> all' takes a list of things and produces a function that takes predicates and applies them to that lit of things cojunctively
01:56:27 <dEPy> arbn you think I undestand monads after asking what continuation is ? :D
01:56:42 <augur> all' [x,y,z,...] p = p x && p y && p z && ...
01:56:49 <augur> dEPy: does that make sense?
01:56:50 <c_wraith> monads are simpler than continuations. :)
01:57:21 <dEPy> augur not really :D
01:57:30 <augur> dEPy: if you know scheme, its just something like
01:57:42 <arbn> dEPy: Monads want to be your friend.
01:58:17 <augur> (define (all l p) (if (null? l) #t (and (p (car l)) (all (cdr l) p)))
01:58:35 <augur> dEPy: just look at the "meaning" i gave: all' [x,y,z,...] p = p x && p y && p z && ...
01:58:55 <augur> it applies p to everything in the list, and then it &&'s them up -- it tests of p applies to all of the elements of the list!
01:59:10 <augur> for instance all' [0,2,4] even == True
01:59:19 <augur> all' [1,3,5] odd == True
01:59:26 <dEPy> Got it :)
01:59:27 <augur> all' [0,1,2] even == False
01:59:28 <augur> etc
01:59:50 <augur> now, since all' takes a function, that means it takes a continuation as its second argument
01:59:55 <augur> ok so:
02:00:07 <augur> all' xs (\x -> whatever)
02:00:17 <augur> == all' xs >>= (\x -> whatever)
02:00:23 <augur> == do x <- all' xs ; whatever
02:00:27 <augur> hm!
02:00:37 <augur> now it looks like we're "taking" x from all' xs
02:00:42 <augur> and doing whatever to "it"
02:01:22 <augur> but this is just the same thing as all' xs (\x -> whatever) -- its just asking of whatever is true of all of the xs!
02:01:44 <augur> so we can sort of read this do thing somewhat more naturally
02:02:36 <augur> if we use some' its even nicer, because we can REALLY just read it naturally: x is some xs and whatever is true of it
02:02:45 <dEPy> I guess I'll have to learn a bit Haskell, at least some basics :D
02:02:55 * augur nods
02:02:59 <augur> @where lyah
02:02:59 <lambdabot> http://www.learnyouahaskell.com/
02:03:26 <dEPy> I had this page opened like 5 times already and I just can't collect courage to go trough with it :D
02:03:35 <augur> really what im giving you is an imperfect description of haskell's continuation monad, so dont expect to do what ive been doing here
02:03:39 <augur> but it should give you a gist
02:04:26 <augur> the haskell continuation monad says "lets do continuations EVERYWHERE!"
02:04:44 <dEPy> And I guess it's about time I learn it... I love types and functional programming... sooo
02:04:52 <dEPy> this might be most natural thing to do :D
02:04:59 <augur> do it!
02:05:01 <augur> also, good night :P
02:05:32 <dEPy> It's 10am here so this might be the reason for my brains to work at half speed :D but... good night :)
02:06:33 <arbn> dEPy: If you like Scheme, and you like strong, static types, Haskell would be perfect for you.
02:58:26 * hackagebot ersatz 0.2.0.1 - A monad for expressing SAT or QSAT problems using observable sharing.  http://hackage.haskell.org/package/ersatz-0.2.0.1 (EdwardKmett)
03:02:00 <no-n> I'm beginning to believe that haskell is a very cool language
03:02:33 <johnw> but you don't know it to be true?
03:02:50 <mikeplus64> no-n: 'tis!
03:03:26 * hackagebot aws 0.7.6.3 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.7.6.3 (AristidBreitkreuz)
03:03:37 <johnw> yay, an aws release
03:15:07 <ion> johnw: The Adventures with Types talk was nice. Too bad he ran out of time.
03:15:21 <alanz> Has anyone ever seen a Haskell source file with more than 100,000 lines in it?
03:16:25 <tdammers> I'd be hard pressed to find a haskell project with that many lines *total*
03:17:02 <alanz> I agree, just doing a sanity check, I need to put an encoding scheme onto line numbers to fit into an Int
03:17:04 <bitonic> tdammers: GHC comes close
03:17:04 <lambdabot> bitonic: You have 1 new message. '/msg lambdabot @messages' to read it.
03:17:36 <tdammers> bitonic: OK, that makes sense
03:17:42 <tdammers> not in a single file though
03:17:51 <bitonic> no.
03:18:22 <edwardk> alanz: i've generated one with 20,000 instances.
03:18:30 <edwardk> i later found a better encoding
03:18:44 <alanz> ouch.
03:18:56 <bitonic> tdammers, alanz: actually, cloc reports 289617 lines of actual Haskell code for GHC
03:19:03 <alanz> this is for the Haskell Refactorer, to encoded added and deleted srcspans
03:19:09 <edwardk> you meant 'file' not project right?
03:19:17 <alanz> I am talking about in a single file
03:19:35 <edwardk> you should be able to fit your line numbers into an Int ;)
03:19:56 <tdammers> int_max is far larger than 100k though
03:19:58 <edwardk> you can probably even bit pack some other crap in there clang-style if need be
03:20:00 <alanz> Well, I am trying to tie up the GHC SrcSpan to my own token structure in a tree
03:20:39 <alanz> I know I can go to a more complex scheme if needed, want to prove the concept in simplest way first
03:20:59 <alanz> Int goes to 2^29-1, or 538million
03:21:28 <bitonic> alanz: probably more in most compilers :)
03:22:07 <alanz> yes, but that is what the language spec says
03:22:22 <bitonic> sure just pointing out that it’s most likely going to be more
03:22:46 <alanz> agree, but would hate to have obscure overflow bugs pop up some time
03:23:08 <alanz> admittedly this implementation is tied to GHC.
03:23:12 <edwardk> the language spec only gives you ~30 bits or so but you get 32 in ghc
03:23:23 <arkeet> or 64, depending on things
03:23:29 <edwardk> sure
03:23:32 <bitonic> > sizeOf (undefined :: Int)
03:23:34 <lambdabot>   Not in scope: `sizeOf'
03:23:34 <lambdabot>  Perhaps you meant one of these:
03:23:34 <lambdabot>    `IM.size' (impor...
03:23:40 <bitonic> @hoogle sizeOf
03:23:40 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
03:23:40 <lambdabot> GHC.Constants sIZEOF_CostCentreStack :: Int
03:23:40 <lambdabot> GHC.Constants sIZEOF_generation :: Int
03:23:53 <bitonic> > Foreign.Storable.sizeOf (undefined :: Int)
03:23:54 <lambdabot>   Not in scope: `Foreign.Storable.sizeOf'
03:23:57 <bitonic> whatever.
03:24:05 <edwardk> in 64 bit mode haskell follows ILP64 even when the host platform does not
03:24:14 <arkeet> > bitSize (undefined :: Int)
03:24:15 <lambdabot>   64
03:24:48 <alanz> > maxBound Int
03:24:49 <lambdabot>   Not in scope: data constructor `Int'
03:24:49 <lambdabot>  Perhaps you meant one of these: `In' ...
03:25:05 <arkeet> > maxBound :: Int
03:25:07 <lambdabot>   9223372036854775807
03:26:09 <alanz> ok. Will let it fit into 32 bits for now since I am sitting there, and the encoding should fit.
03:27:56 <alanz> So we will be able to refactor million line files
03:28:39 <tdammers> you have to admit, if a file has millions of lines, it is in dire need of refactoring
03:28:45 <alanz> :)
03:29:40 <aristid> @hoogle Int32
03:29:40 <lambdabot> Data.Int data Int32
03:29:45 <aristid> @hoogle Word32
03:29:45 <lambdabot> Data.Word data Word32
03:31:48 <alanz> on my machine maxBound :: Int gives 2147483647
03:32:01 <arkeet> you're using a 32-bit GHC then.
03:35:28 <alanz> yes, and will try to maintain backward compatibility to it for now
03:35:56 <asdf-085f> @slap asdf-085f
03:35:56 <lambdabot> I'd rather not; asdf-085f looks rather dangerous.
03:36:04 <asdf-085f> Ha!
03:48:26 * hackagebot cabal-db 0.1.0 - cabal-db  http://hackage.haskell.org/package/cabal-db-0.1.0 (VincentHanquez)
03:50:35 <aristid> @slap asdf-085f
03:50:36 * lambdabot puts on her slapping gloves, and slaps asdf-085f
04:13:35 <asdf-085f> @slap aristid
04:13:35 * lambdabot karate-chops aristid into two equally sized halves
04:14:01 <asdf-085f> @slap aristid
04:14:01 * lambdabot hits aristid with a hammer, so they breaks into a thousand pieces
04:14:37 <ion> they breaks?
04:16:07 <k00mi> IIRC, "they" can be used as "he or she"
04:20:25 <srhb> k00mi: Yes, though it's considered bad style often.
04:21:31 <srhb> And wow, the recent SPJ talk from Skills Matter is really awesome for getting a quick introduction to the big language extensions.
04:24:29 <Estrellas> they can be singular or plural but it's always conjugated with other things as if it's plural
04:53:28 * hackagebot htune 0.1 - harmonic analyser and tuner for musical instruments  http://hackage.haskell.org/package/htune-0.1 (PetrRockai)
04:55:19 <mornfall> cabal: <file descriptor: 4>: resource exhausted <-- what does that even *mean*?
04:55:33 <mornfall> (friend's trying to run "cabal update" on pretty much vanilla ubuntu?)
04:58:51 <mornfall> Heh. Short on disk space, apparently. Error messages par excellence...
05:02:29 <RenJuan> as likely just descriptors
05:02:53 <RenJuan> if not more
05:03:32 <RenJuan> a disk filled condition is pretty apparent
05:23:51 <Eelis> i know that ADTs sort of provide sum types, but wouldn't it be nice if we could use the constituent constructors as actual (record) types? for instance, given   data Message = MsgA Int Bool | MsgB Double  , you'd be able to write a function of type MsgA -> X without having to change to   data MsgA = MsgA Int Bool; data Message = MsgA' MsgA | MsgB Double
05:24:17 <Eelis> and there would be a subtyping relation MsgA <: Message
05:33:44 <arkeet> Eelis: are you looking for GADTs?
05:34:38 <arkeet> errr
05:34:40 <arkeet> never mind
05:44:58 <Taslem> I'm trying to do profiling with GHC, but I have libraries which aren't for profiling (SDL).
05:45:15 <Taslem> Is there a way to avoid that?
05:46:44 <johnw> you need to rebuild those libraries
05:48:20 <aristid> Eelis: may i query you?
05:49:00 <Eelis> aristid: sure
06:07:49 <dmwit> So, sometimes when I'm feeling FFIlthy I like to pretend my closure of type IO () is actually a void (*f)().
06:08:12 <dmwit> But GHC surely can't see when that pointer stops being referenced by whatever foreign code I just handed it to.
06:08:23 <dmwit> Does this mean that anything referenced by that closure can never be garbage collected?
06:08:34 <dmwit> Is there a way I can tell GHC when I stop referencing that closure?
06:09:27 <shachaf> How did you tell GHC that you're keeping a reference to it in the first place?
06:09:30 <shachaf> (Are you literally casting IO () to void (*)()?)
06:09:43 <shachaf> (That doesn't really make sense. Are you using "wrapper"?)
06:09:45 <dmwit> I suppose I'm using the official method -- there's a "wrapper".
06:09:54 <shachaf> OK, so there's a way to free those.
06:10:07 <shachaf> @google foreign import wrapper
06:10:08 <lambdabot> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Foreign-Ptr.html
06:10:08 <lambdabot> Title: Foreign.Ptr
06:10:17 <shachaf> freeHaskellFunPtr
06:10:23 <dmwit> Say, for the sake of argument, that I'm using whatever gtk2hs uses when you hand it a callback for some signal. ;-)
06:11:03 <dmwit> Aha, perfect.
06:11:05 <dmwit> Thanks!
06:11:27 <shachaf> Does Gtk2hs use "wrapper" for all Gtk callbacks?
06:11:51 <shachaf> That seems kind of expensive.
06:11:53 <dmwit> err, isn't that the only way to hand Haskell code off to C?
06:12:42 <shachaf> Surely there's a way to do it without actually generating machine code at runtime.
06:12:56 <shachaf> I wonder whether there's any sort of standard mechanism for that.
06:13:11 <shachaf> Gtk's callback API lets you pass a callback_data pointer along with the function pointer.
06:13:22 <shachaf> Can you connect that to a GHC closure?
06:19:50 <dmwit> Okay, seems gtk2hs does something more exciting, touching GHC internals in a funky way via C.
06:20:09 <dmwit> GClosure *gtk2hs_closure_new(HsStablePtr callback) { ... }
06:20:59 <dmwit> neat
06:21:18 <shachaf> Ah, I was going to say you could do something with a StablePtr.
06:33:46 <k0ral> Hello
06:34:24 <phaer> k0ral: Hi
06:34:49 <k0ral> I'd like to hardcode an URI (as in Network.URI) in my program, however the only way I found to build an URI is parseURI* functions and they deliver Maybe URI, not a bare URI
06:36:03 <k0ral> as I know the URI I'm hardcoding is valid, I'd like to avoid this "Maybe"
06:36:11 <`ramses> k0ral: use fromJust then
06:37:10 <k0ral> fromJust gives an error in case it's Nothing, and I guess it will be detected at runtime
06:37:37 <`ramses> but you just said you're sure it will be a just :)
06:37:43 <k0ral> now I have another requirement: would it be possible to detect it at compile time ? as it is hardcoded, I figured the compiler could directly evaluate the expression
06:37:57 <k0ral> yeah but I might write typos :)
06:38:10 <k0ral> I would like to detect typos at compile time if possible
06:38:42 <`ramses> k0ral: then you'd need some kind of DSL to write the URI in structured form, I think
06:38:43 <bitonic> k0ral: you can use TH to throw an error if it’s a Just
06:38:51 <bitonic> *if it’s a Nothing
06:39:14 <bitonic> that is, throw an error at compile time
06:39:16 <dmwit> hold up, hold up
06:39:23 <dmwit> parseURI *cannot* be the only way to make a URI
06:39:29 <dmwit> I simply don't believe that.
06:39:49 <bitonic> dmwit is right, the constructors are available <http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network-URI.html#t:URI>
06:40:50 <k0ral> yeah but writing the URI using constructors is really tedious
06:41:01 <dmwit> boooooo
06:41:03 <dmwit> BOOOOOO
06:41:11 <k0ral> s/tedious/a pain
06:41:16 <dmwit> suck it up
06:41:40 <bitonic> k0ral: meh
06:41:50 <bitonic> so what function do you require?
06:41:54 <k0ral> no, seriously, I mean it, it's REALLY annoying
06:42:03 <k0ral> just dive it a try
06:42:06 <k0ral> give*
06:42:06 <bitonic> something that typechecks only if the string is a valid URI?  you can’t have that in Haskell
06:42:22 <bitonic> what you can have is a compile-time parsing with TH
06:43:01 <k0ral> bitonic: that's what I want
06:43:05 <bitonic> but some people would say that’s ugly
06:43:09 <bitonic> k0ral: then go for it
06:43:32 <k0ral> maybe fromJust . parseURI is the best compromise
06:44:17 <k0ral> URI "http:" (Just $ URIAuth "" "//www.google.com" "") "" "" ""
06:44:37 <k0ral> and you would want me to write this in my code ?
06:44:46 <dmwit> Yes?
06:44:50 <bitonic> k0ral: writing that once is such a big deal?
06:44:51 <k0ral> no way
06:44:54 <dmwit> That doesn't look that bad at all to me.
06:45:01 <bitonic> me and you have clearly different priorities ehe
06:45:11 <dmwit> yeah
06:45:24 <bitonic> you can simply have an `simpleHttpUri' function that does what you want anyway
06:45:28 <bitonic> :: String -> String
06:45:28 <dmwit> By the time you connected to #haskell you could have written three of those. =P
06:45:56 <k0ral> :D sure, but it still looks terribly ugly
06:46:04 <bitonic> simpleHttpUri s = URI "http:" (Just $ URIAuth "" ("//" ++ s) "") "" "" ""
06:46:06 <bitonic> problem solved
06:46:20 <bitonic> `simpleHttpUri "www.google.com"'
06:46:20 <k0ral> what if I want https ? what if I want ftp ?
06:46:35 <k0ral> I would have to make a simplification of the current constructor
06:46:41 <deech> Hi all, can Shake be used as a continuous compilation tool? Anyone have experience with how fast it is compared to ghc-mod?
06:46:55 <bitonic> k0ral: `simpleUri scheme s = URI (scheme ++ ":") (Just $ URIAuth "" ("//" ++ s) "") "" "" ""'
06:47:25 <bitonic> you get the idea.  they’re called ‘smart constructors’
06:48:01 <k0ral> I'll go with fromJust, thanks :)
06:48:07 <bitonic> k0ral: you’re welcome
06:51:58 <arkeet> fromJust?
06:52:00 <arkeet> EVIL
06:52:18 <arbn> arkeet: Not if he's typing a valid string into his source-code. A default value is a bit silly, there. :P
06:52:25 <bitonic> arkeet: we tried to convince him
06:52:35 <arkeet> :p
06:52:43 <bitonic> arbn: you’re wasting an opportunity to sanitise that string at compile time
06:53:01 <arkeet> there should be a TH thing to parse URIs at compile time
06:53:11 <arkeet> a quasiquoter?
06:53:25 <bitonic> arkeet: it doesn’t take much to write...
06:53:29 <arkeet> :p
06:53:31 <arbn> Well, sure, if you like TH.
06:53:31 <bitonic> yeah an [url| ... ]
06:53:45 <arkeet> I think it's a reasonable thing in this case.
06:53:58 <bitonic> arkeet, arbn: the most reasonable thing is still to use URI + smart constructors...
06:54:26 <arkeet> how so?
06:55:29 <bitonic> arkeet: I prefer to avoid TH when possible, and it’s definitely possible here.  for various reason: unportability (not only to other compilers but also to platforms that GHC supports, iirc), slower compile times, useless complication
06:55:32 <hpaste> genshi pasted “easy_install problem Genshi” at http://hpaste.org/84156
06:55:52 <arkeet> bitonic: oh well. :p
06:56:05 <k0ral> that's why I consider fromJust as the best compromise
06:56:06 <arkeet> why is that paste here.
06:56:14 <k0ral> TH is unportable and tedious
06:56:25 <k0ral> constructor is ugly
06:56:26 <arkeet> I must be naive then.
06:56:48 <bitonic> k0ral: I’m sure you’ll have fun when your application with crash with a `fromJust' and you’ll have completely forgotten about this!
06:56:52 <k0ral> fromJust is reasonable as the developer will notice at runtime the problem
06:57:19 <k0ral> bitonic: I can't forget about it, it will either crash at start up, or not crash at all
06:57:42 <bitonic> k0ral: why?  do you immediately use the value?  what if the code changes and the URI gets forced much later in the execution?
06:58:01 <bitonic> also the `fromJust' is absolutely uninformative, at least use an `error'
06:58:02 <k0ral> I immediately use the value, and this will hardly change in the future
06:58:26 <bitonic> k0ral: mah.  I think it’s very bad practice, especially if anybody else but you will use that software.  they’ll be puzzled
06:58:36 <jfischoff> how do I fix this: rejecting: ghc-7.6.1/installed-4e9... (package is broken)
06:59:04 <bitonic> k0ral: unless it’s a throwaway script
06:59:05 <k0ral> bitonic: I think in general it's bad practice, but in this very case it's reasonable
06:59:16 <bitonic> k0ral: I disagree, but OK
07:00:07 <arbn> bitonic: And, yeah, TH is unportable, so I have to avoid it. I'm writing some code to run on the iThings, and the cross-compiler for those doesn't like TH.
07:00:28 <k0ral> and, by the way, using constructors, I think you can build an invalid URI too with forbidden characters
07:00:28 <bitonic> arbn: right, it’s related to the liking issues that ghci has on those platforms
07:01:01 <bitonic> k0ral: that is probably true.
07:01:54 <k0ral> that looks more dangerous to me than a crash at startup
07:02:30 <bitonic> k0ral: I might agree with you on that, and the only way to effectively avoid that is TH
07:02:53 <k0ral> why is TH unportable ?
07:02:58 <bitonic> tbh having an `error' that prints the issue is not a bad solution, if the URI value is forced at startup
07:03:06 <k0ral> or, put it differently, why isn't that part of the standard ?
07:03:22 <bitonic> k0ral: 1) because only GHC supports it 2) because of the way it works by linking things at compile time
07:03:26 <Taneb> The standard is comparatively conservative
07:03:26 <lambdabot> Taneb: You have 1 new message. '/msg lambdabot @messages' to read it.
07:03:41 <bitonic> k0ral: the standard defines a pretty small and ‘tractable’ language
07:04:06 <bitonic> (still not as tractable as, say, SML)
07:05:41 <bitonic> k0ral: the way std Haskell works is fairly well understood.  I don’t think anyone understands GHC Haskell in its entirely :P
07:06:01 <Taneb> bitonic, SPJ might
07:06:20 <bitonic> yeah SPJ and a few others
07:06:36 <k0ral> good for them :)
07:06:53 <bitonic> but the inference algorithm in particular is very obscure
07:06:58 <bitonic> and type class resolution too
07:07:21 <Taneb> I think maybe FlexibleInstances, FlexibleContexts, MultiParamTypeClasses, GADTs, FunctionalDependencies and TypeFamilies should possibly be added to the Haskell standard
07:07:28 <Saizan> there are papers on it, even
07:07:47 <bitonic> Taneb: no, the inference for the GADTs related stuff is the most intricate part I reckon...
07:07:56 <bitonic> that and inference for higher ranked types
07:08:14 <bitonic> maybe rankntypes takes the prize for subtlety, at least imo :P
07:08:39 <k0ral> I couldn't live without FlexibleContexts :)
07:09:05 <bitonic> Taneb: also there’s a lot of overlap between fundeps and type families, it’d be quite inelegant to have both (always imo)
07:09:33 <Taneb> bitonic, they overlap, but there are cases when you'd very much prefer one over the other, in both directions
07:10:01 <Taneb> tables would be pretty much useless if it tried to use FunctionalDependencies instead of TypeFamilies, for example
07:10:30 <Taneb> And Control.Lens.Tuple wouldn't work very well with TypeFamilies
07:10:41 <bitonic> Taneb: well I’m sure you’re right but I think the right thing to do is to find a more unified system that is useful to express both
07:10:52 <bitonic> instead of rushing everything into a standard
07:11:04 <Taneb> Good point...
07:11:22 <Taneb> FlexibleInstances and FlexibleContexts should definitely be added, though
07:11:24 <bitonic> I mean in the end fundeps and type families are implemented using the same bare tools in GHC Core, so it’s a matter of finding the right interface
07:11:41 <srhb> What is it FlexibleContexts do again?
07:12:01 <bitonic> srhb: Foo [a]
07:12:16 <bitonic> well
07:12:30 <Taneb> foo :: Show [a] => a -> String
07:12:54 <Taneb> Or something
07:13:29 <bitonic> yeah in general it allows you to put constraints on constructor-headed things (I think that’s the right term?)
07:13:38 <bitonic> or is that from Agda?
07:13:42 <bitonic> oh well <http://hackage.haskell.org/trac/haskell-prime/wiki/FlexibleContexts>
07:13:46 <srhb> Yeah, thanks.
07:14:07 <Saizan> bitonic: i don't think there's any better interface, we might need a way to use classes with fundeps as type families though, just like we have ~ to use type families as constraints
07:14:46 <bitonic> Saizan: well that would be already much better
07:15:05 <Saizan> bitonic: though that still needs a strenghtening of the semantics of fundeps as they are implemented in GHC now
07:18:14 <Taneb> Hmm
07:18:26 <Taneb> Hugs doesn't allow constraints on foralls, as far as I can make out
07:19:18 <bitonic> Saizan: well in general the semantics of fundeps are pretty weird, some things that should be allowed aren’t
07:19:55 <hpaste> Genshi pasted “vcvarsall” at http://hpaste.org/84160
07:21:55 <bitonic> Taneb: what do you mean ‘constraints on forall’?
07:22:09 <Taneb> "forall f. Functor f => a -> f b"
07:22:23 <Taneb> (for example)
07:22:49 <Taneb> (even though you can't actually satisfy that without _|_)
07:23:08 <bitonic> Taneb: does Hugs have explicit quantification like that to begin with?
07:23:23 <Taneb> It definitely has forall
07:23:35 <merijn> Taneb: I think that the problem with including GADTs is that it would also draw ExistentialQuantification into the standard
07:23:50 <bitonic> Taneb: then I don’t see what’s wrong with that, let’s try
07:24:13 <bitonic> merijn: not necessarily
07:24:19 <Taneb> merijn, I'm not actually sure what ExistentialQuantification does
07:24:31 <Taneb> And I've used GADTs many a time without it
07:24:33 <merijn> Things like [forall a . a]
07:24:44 <merijn> bitonic: That's what I got told, last time I brought it up
07:24:44 <bitonic> merijn: that’s not an existential
07:25:12 <bitonic> merijn: well as to now GADTs have existential but you could remove that possibility
07:25:14 <merijn> eh "[forall a . Show a]", I guess
07:25:24 <arkeet> I got bored.
07:25:25 <bitonic> merijn: nope :P
07:25:31 <merijn> bitonic: Noo, I like existential GADTs :(
07:25:38 <bitonic> you’d have to have [exists a. Show a => a], but you don’t
07:25:39 <hpaste> arkeet pasted “URI quasiquoter” at http://hpaste.org/84161
07:25:56 <merijn> bitonic: meh, I forgot the proper way to write existential quantification, since I mostly use GADTs for them now :p
07:26:10 <bitonic> or `data Exists = forall a. Exists a' and then `[Exists]'
07:26:26 <bitonic> merijn: well you can’t introduce an existential without a constructor, in Haskell
07:28:32 <srhb> Playing around with the rolling you an IRC bot... What's the saner approach to getting the server's messages? Bytestring or Text?
07:28:49 <merijn> srhb: ByteString, IRC doesn't define an encoding
07:28:55 <arbn> I've never understood existentials, and why a forall on the left makes it existentially quantified... is there a tutorial on this that is light on the type theory?
07:29:00 <srhb> merijn: Thanks. :)
07:29:03 <arbn> forall on the right*
07:29:05 <merijn> Nothing guarantees that other users actually send you valid utf-8, for example
07:29:06 <srhb> So I guess attoparsec is the way to go for the parsin.
07:29:33 <merijn> If I wanted I could write utf-16 to the channel and see what happens to your clients, but I'm nice, so ;)
07:29:42 <srhb> hehe :P
07:30:02 <arkeet> arbn: in first order logic, (exists x. p(x)) -> q = forall x. (p(x) -> q)
07:30:04 <bitonic> Taneb: I just tried, and Hugs accepts `foo :: forall a b f. Functor f => a -> f b; foo = undefined'
07:30:08 <merijn> arbn: The forall on the right is basically "because people were to lazy to define an 'exists' keyword"
07:30:12 <srhb> Oh I suppose there's a ByteString version of Parsec too. Is there any reason to prefer one over the other?
07:30:36 <geekosaur> attoparsec is reportedly faster, especially for bytestrings
07:30:37 <arkeet> arbn: so when you write data E = forall a. E a
07:30:51 <arkeet> arbn: that really gives you a constructor E :: forall a. (a -> E)
07:30:52 <bitonic> merijn: weeellll not quite
07:30:59 <arbn> arkeet: Oh. So, it just follows from DeMorgan's laws and the identity of implication and disjunction?
07:31:03 <Taneb> bitonic, hmm
07:31:08 <bitonic> there are reasons to keep the `forall', although it is confusing
07:31:20 <arkeet> which is "the same as" E :: (exists a. a) -> E
07:31:24 <Taneb> I think my problem was I was using it in a type?
07:31:28 <merijn> bitonic: Yes, but I filed them under "not relevant enough to rememeber"
07:31:46 <bitonic> an `exists' would trick you into believing you have a power you don’t have.  also that notation kind of makes sense
07:32:08 <bitonic> also you’d have to introduce some ad-hoc rules for where `exists' can appear
07:32:23 <bitonic> unless you keep exists at the left of the constructor anyway
07:33:27 <arbn> arkeet: OK. Explaining it in terms of FOL makes it clear to me. Thanks.
07:33:49 <arkeet> np
07:40:34 <arkeet> I love template haskell
07:40:35 <arkeet> it is so easy
07:46:08 <bitonic> or is it?
07:47:04 <geekosaur> jure it's easy, just think like ghc }:>
07:47:15 <bitonic> is }:> a thing?
07:47:17 <arkeet> "http://hpaste.org/84161"  ======>  URI "http:" (Just (URIAuth "" "hpaste.org" "")) "/84161" "" ""
07:47:20 <arkeet> :>
07:47:27 <geekosaur> devil w/horns
07:47:39 <arkeet> [|it is so easy |]
07:48:48 <mm_freak> arkeet: what about OverloadedStrings?  is that one easy?
07:49:01 <arkeet> it is not only easy, it is also fun
07:50:00 <mm_freak> you should join the yesod team…  yesod is templatehaskelled to do what you mean =)
07:50:14 <arkeet> :(
07:50:28 <bitonic> ‘You’ve been TemplateHaskell’ed!’
07:50:33 <arkeet> what's wrong with my uri quasiquoter?
07:50:48 <arkeet> (actually, anyone care to see if how I made it makes sense?)
07:50:56 <mm_freak> arkeet: nothing…  i just noticed that you can do that with OverloadedStrings, too…  almost…
07:51:06 <mm_freak> only with OverloadedStrings it's runtime
07:51:11 <bitonic> mm_freak: no, you can’t, the whole point is getting the error at compile time
07:51:12 <arkeet> exactly
07:51:15 <arkeet> exactly
07:51:22 <bitonic> exactly.
07:51:28 <mm_freak> Exactly.
07:51:41 <bitonic> exactly?
07:51:43 <mm_freak> and yeah, i know that…  i understand the rationale for TemplateHaskell, but i don't like it much
07:51:50 <mm_freak> it makes my code too opaque
07:52:04 <arkeet> -ddump-splices can solve that
07:52:15 <bitonic> mm_freak: you’re 20 minutes late
07:52:31 <mm_freak> arkeet: no, it can't
07:52:35 <arkeet> :p
07:52:53 * mm_freak scrolls up
07:53:04 * adnauseam hears mouse wheel grinds
07:53:18 * bitonic hears C-r
07:53:34 * mm_freak doesn't use the mouse wheel…  what you hear is the click of my pgup key
07:53:49 <adnauseam> dem noises in my head ;[
07:54:58 <mm_freak> bitonic: nothing about netwire, nothing about kernel development in haskell…  what did i miss?
07:55:09 <bitonic> mm_freak: I was referring about TH actually
07:55:16 <mm_freak> ah
07:55:20 <bitonic> we already had the ‘why TH is not that great’ safety lecture
07:55:25 <arkeet> using fromJust . parseURI on a static string
07:55:35 <mm_freak> i see
07:55:37 <bitonic> ‘you can release the belt by pulling the metal flap...’
07:56:01 <Taneb> Huh
07:56:14 <Taneb> Hugs seems to have a different Show instance for Data.Monoid.Sum
07:56:22 <Taneb> No
07:56:23 <Taneb> UHC
07:56:35 <Taneb> Hugs and GHCi have "Sum {getSum = 5}
07:56:41 <Taneb> UHC just has "Sum 5"
07:57:12 <mm_freak> UHC probably doesn't add field names
07:57:42 <geekosaur> I don't think the standard requires that something declared as a record must use show in record form. the more interesting question is whether its read instance accepts both (I think ghc's doesn't?)
07:57:56 <geekosaur> > read "Sum 5" :: Sim Int
07:57:58 <geekosaur> er
07:57:58 <lambdabot>   Not in scope: type constructor or class `Sim'
07:57:58 <lambdabot>  Perhaps you meant one of the...
07:58:02 <geekosaur> > read "Sum 5" :: Sum Int
07:58:03 <lambdabot>   Sum {getSum = *Exception: Prelude.read: no parse
07:58:30 <mm_freak> interesting
07:58:51 <Taneb> UHC doesn't but thinks it does
07:58:57 <Taneb> "Sum 34947492340798"
07:59:10 <geekosaur> *blink*
07:59:37 <Taneb> That was read "Sum 5" :: Sum Int
07:59:43 <Taneb> Honestly
08:00:02 <arkeet> > read "Sum {getSum = 5}" :: Sum Int
08:00:04 <lambdabot>   Sum {getSum = 5}
08:10:19 <arkeet> apparently Q = IO.
08:10:46 <geekosaur> no, although it is MonadIO
08:12:14 <Taneb> You've got runQ and liftIO which can convert back and forth between Q and IO
08:12:15 <arkeet> but we have runQ :: Q a -> IO a, and qRunIO :: IO a -> Q a
08:12:56 <arkeet> :p
08:12:57 <geekosaur> that doesn't mean Q is IO, any more than liftIO + runReaderT make a ReaderT IO an IO
08:13:04 <arkeet> I'm joking.
08:13:13 <arkeet> they aren't actually inverses of course.
08:16:14 <arkeet> oops, I forgot a ":p"
08:29:25 <hpaste> timthelion pasted “?graph” at http://hpaste.org/84164
08:29:45 <timthelion> Hey, anyone recognise this syntax, with the ?graph?
08:30:28 <timthelion> Apparently it was valid haskell98, but not haskell2010.  Can't figure out what it meant though.
08:31:15 <supki> -XImplicitParams
08:31:20 <sepp2k> timthelion: It's an implicit parameter
08:31:47 <timthelion> supki, sepp2k, thanks :)
08:31:47 <sepp2k> It's a GHC extension and was never part of any Haskell standard as far as I'm aware.
08:33:01 <timthelion> sepp2k: yeah, this code was compiled with --ghc-exts(or whatever the flag was) I'm updating it to use the LANGUAGE pragmas now.
08:33:27 <arbn> ImplicitParams are cool, at least if you've programmed in elisp or FORTRAN in a past life. ;)
08:39:56 <bitonic> ImplicitParams :(
08:42:34 <danols_work> white space is optional in haskell right ?
08:43:07 <danols_work> i.e. indentation block - how can I specify them manually using 'curly brackets' ?
08:44:04 <k00mi> do { x <- foo; bar x}
08:44:31 <danols_work> so I can either do white space indentation or curly brackets ?
08:45:22 <k00mi> you can omit the brackets in that case: do x <- foo; bar x
08:45:37 <k00mi> i'm not sure when they are required
08:47:36 <bitonic> k00mi, danols_work: you need them when the statements are not aligned
08:47:49 <bitonic> in the case of do blocks an example might be
08:47:52 <bitonic>     do { x <- undefined;
08:47:52 <bitonic>              y <- undefined;
08:47:52 <bitonic>          return () }
08:48:02 <bitonic> it won’t work without braces and ;
08:48:50 <k00mi> ok, i thought so
08:48:55 <bitonic> this applies in general, see the layout rule
08:48:57 <danols_work> ok thank yo
08:48:59 <merijn> danols_work: In practice it usually ends up being whitespace, as most haskell coders will murder anyone who'd suggest using braces
08:49:05 <danols_work> s/yo/you
08:49:53 <bitonic> merijn: that’s not true, I’ve seen braces from old time Haskellers - I forget who
08:50:06 <bitonic> it’s taste really
08:50:29 <danols_work> good to know
08:50:39 <merijn> bitonic: I didn't say *no one* used it, I just said most people will hate your guts if you do
08:50:59 <bitonic> well with ‘old time Haskellers’ I meant ‘respected people’ = people don’t ‘hate’ them :P
08:51:13 <merijn> Since the majority of all library/open source haskell seems to use prefer layout rule
08:51:19 <bitonic> I think maybe it was in some lhs2tex paper maybe
08:51:42 <danols_work> white space not being significant is just a smart move
08:51:47 <danols_work> this way you can pick whichever style you prefer
08:51:49 <merijn> bitonic: I don't care if SPJ himself prefers braces, if I had to work on the same code base I'd still hate him for using it :p
08:52:00 <danols_work> SPJ ?
08:52:09 <bitonic> merijn: you must hate GHC then - its pretty printer loves braces
08:52:14 <merijn> bitonic: I do
08:52:22 <bitonic> lol I don’t mind it
08:52:23 <parcs> i think explicit braces look nice
08:52:34 <arkeet> danols_work: simon peyton jones
08:52:51 <tdammers> https://en.wikipedia.org/wiki/Simon_Peyton_Jones
08:53:11 <arkeet> haha, there's a simple english version of that.
08:55:41 <danols_work> cool
08:56:19 <danols_work> parcs white space like in Python has edge cases that drive you mad
08:56:40 <bitonic> danols_work: Haskell syntax is many times more flexible than Python’s
08:56:45 <danols_work> i know
08:56:51 <Rembane> That's scary :O
08:56:55 <parcs> doThingsWithX x
08:56:56 <parcs>   = do { a <- foo x;
08:56:58 <arkeet> layout is pretty simple once you konw the rules.
08:56:58 <parcs>        ; b <- bar x;
08:57:00 <parcs>        ; return (a+b)
08:57:02 <parcs>        }
08:57:05 <bitonic> ehe
08:57:27 <jmcarthur> it's interesting that records don't have a whitespacey syntax as an alternative to braces
08:58:04 <bitonic> jmcarthur: it’s also interesting that it binds the tightest
08:58:14 <jmcarthur> yeah that's kind of weird
08:58:16 <bitonic> you need some token for records anyway
08:58:23 <jmcarthur> although i admit i have used it on more than one occasion
08:58:34 <bitonic> if you want to keep parsing independent of the scope
08:58:41 <jmcarthur> i mean record definitions, specifically
08:59:00 <jmcarthur> data Foo = Foo { blah :: Int; wibble :: String }
08:59:00 <bitonic> well yeah I take advantage of that all the time but I keep the braces attached to the datacon
08:59:11 <bitonic> jmcarthur: ah.  yeah there is no need for that
08:59:22 <bitonic> I guess it’s just to be consistent with constructing/destructing records
08:59:27 <jmcarthur> at the value level this also applies somewhat, but you still need some sort of delimiter i guess
08:59:44 <jmcarthur> no i take that back
08:59:56 <jmcarthur> the whitespace can be a delimiter, just as with do notation or something
09:00:04 <bitonic> jmcarthur: how would that work?
09:00:07 <parcs> oops, i just realized my example has two redundant semicolons
09:00:09 <mcstar> > True == True == True
09:00:10 <lambdabot>   Precedence parsing error
09:00:10 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
09:00:21 <bitonic> the only way I can see it working is by keeping note of what datacons are constructors
09:00:25 <bitonic> which is not nice
09:00:27 <jmcarthur> bitonic: perhaps you have a particular case in mind? if you have one i'll play with it
09:00:29 <parcs> anyway explicit braces is quite nice if you format it correctly
09:00:46 <jmcarthur> i guess it's tough to see when a record should start
09:00:49 <jmcarthur> do notation has "do"
09:01:03 <jmcarthur> maybe there could be a "record" keyword
09:01:58 <jmcarthur> record Foo { blah = 5; wibble = "foo" }   -- but using whitespace instead of braces and semicolons
09:02:18 <mcstar> ocaml records dont even have constructors...
09:02:25 <jmcarthur> yeah
09:02:32 <bitonic> jmcarthur: how do you parse `foo Foo blah = x = ...'?  it gets messy soon
09:02:36 <jmcarthur> but that's not the design choice that was made in haskell, for better or worse
09:02:37 <merijn> danols_work: What kind of edge cases? I don't think I've ever encountered an edge case in python that drove me mad...
09:02:52 <mcstar> jmcarthur: i think better, not that it counts
09:03:57 <jmcarthur> mcstar: i'm less certain. after all, we still don't allow different record types to have fields with the same name, so it would be unambiguous to leave out the constructor in most cases (the only counterexample i can think of being when you define more than one constructor for the same type with the same fields)
09:03:58 <ion> New Ersatz example: sudoku solver https://github.com/ekmett/ersatz/commit/c1249c2a6c5016374c1619f3bf34fcffe51a1707
09:04:36 <mcstar> ersatz?
09:04:50 <jmcarthur> bitonic: i'm not sure i understand. could you express that in current haskell syntax?
09:05:01 <bitonic> jmcarthur: `foo Foo{blah = x} = ...'
09:05:15 <jmcarthur> ah, pattern matching
09:05:19 <bitonic> in general I think it’d get very tricky (too tricky) with destructors
09:06:03 <ion> mcstar: A nice Haskell API for SAT solvers.
09:06:22 <mcstar> ion: is there a problem that ekmett didnt solve?
09:06:24 <jmcarthur> bitonic: yeah i think this syntax would not be useful for pattern matching
09:06:33 <ion> mcstar: No.
09:06:34 <bitonic> the layout rule is already messy enough, with tle lexer intertwined with the parser ehe
09:06:35 <jmcarthur> doable with some work i think, but nobody would use it
09:06:49 <bitonic> well ofc it’s ‘doable’ but you’d end up with weird rules
09:07:28 <jmcarthur> sure
09:08:00 <jmcarthur> i still think it could be nice for rhs stuff, but i don't care enough to argue for it much
09:08:57 <bitonic> this discussion makes me think of this <http://michaeldadams.org/papers/layout_parsing/>
09:11:30 * bitonic really wants a nice library to write layout-rule kind of things
09:12:34 * Taneb wants more cool group-y things I can add to the groups library
09:13:44 <mcstar> I->he
09:14:08 <mcstar> pretty bad that /me cant be used in sentence
09:14:19 <Taneb> I mix all the persons!
09:14:38 <johnw> Taneb: how come not minvert?
09:14:41 * Taneb thinks I am pretty stupid, aren't you?
09:14:54 <Taneb> johnw, minvert?
09:15:01 <johnw> mempty, mappend, minvert
09:15:12 <Taneb> Aaah
09:15:12 <johnw> just that it would fit a pattern is all
09:15:18 <shachaf> Does the m in minvert stand for "monoid"?
09:15:18 <Taneb> Because I hate that pattern
09:15:24 <srhb> How do I write do { x <- digit; y <- digit; z <- digit; return [x,y,z] } in Applicative style?
09:15:29 <Taneb> shachaf, one would presume so
09:15:33 <srhb> aconcat? <<
09:15:33 <johnw> shachaf: yeah, i thought of that too, but ginvert is no better than just invert
09:15:40 <johnw> so, invert it is!
09:15:44 <johnw> it should be sappend then
09:15:47 <shachaf> srhb: replicateA 3?
09:15:49 <johnw> sappend, mempty, ginvert
09:15:57 <shachaf> @ty replicateA 3 (print "hi")
09:15:59 <lambdabot>     Not in scope: `replicateA'
09:15:59 <lambdabot>     Perhaps you meant one of these:
09:15:59 <lambdabot>       `Seq.replicateA' (imported from Data.Sequence),
09:16:00 <Taneb> johnw, that's awful
09:16:01 <shachaf> Hmm.
09:16:04 <johnw> abstract algebra through prefixes!
09:16:07 <mcstar> > (\x z y -> [x,y,z]) <$> [1,2] <*> [3,4] <*> [5,6]
09:16:09 <lambdabot>   [[1,5,3],[1,6,3],[1,5,4],[1,6,4],[2,5,3],[2,6,3],[2,5,4],[2,6,4]]
09:16:20 <shachaf> @ty replicateM 3 (print "hi") -- I'm not sure there's an Applicative version...
09:16:21 <lambdabot> IO [()]
09:16:36 <johnw> Taneb: make shachaf into a Group, so I can invert him sometimes
09:16:37 <shachaf> You can alwys sequenceA . replicate 3
09:16:59 <mcstar> "\x z y" -> "\x y z" i meant to say
09:17:24 <Taneb> instance Group Shachaf where invert = unsafePerformIO $ ringAndTell johnw "invert shachaf plz"
09:17:52 <johnw> don't forget to use unsafeCoerce in there too
09:18:02 <Taneb> Obviously, ringAndTell has type person -> String -> IO (Shachaf -> Shachaf)
09:18:29 <johnw> inverting shachaf would generate statements like 'TH is so awesome, I use it whenever I can'
09:18:35 <shachaf> i love th
09:18:37 <shachaf> it is so easy
09:18:38 <johnw> look, LambdaCase!
09:19:05 <johnw> shachaf: I'm sorry, were you making that statement at compile-time?
09:19:12 <Taneb> johnw, take in mind that appending the inverse of Shachaf to Shachaf gives you Shachaf
09:19:17 <Taneb> That is, mempty
09:19:27 <jmcarthur> srhb: that looks like an argument for the existence of replicateA, to me
09:19:35 <johnw> Fahcahs
09:19:47 <shachaf> jmcarthur: replicateM is enough of an argument for the existence of replicateA, I think.
09:20:04 <shachaf> Any operationM which can be made into operationA should be.
09:20:15 <jmcarthur> srhb: you could do something like this:   sequenceA [digit, digit, digit]
09:20:20 <jmcarthur> shachaf: agreed
09:20:27 <shachaf> sequenceA [busy, busy, busy]
09:20:31 <mcstar> but that has [Seq a] type
09:20:34 <jmcarthur> and Monad should require Applicative so they are compatible :(
09:20:38 <mcstar> mine stays list
09:20:42 <shachaf> jmcarthur: Naturally.
09:21:02 <ozataman> in profiling, is there a way to see an underlying library's cost centers as well?
09:21:21 <mcstar> if it is in haskell, yes
09:27:33 <ozataman> hm, the underlying library needs the -fprof-auto -fprof-auto-calls flags in its ghc-prof-options cabal flag...
09:27:39 <ozataman> then it works
09:28:05 <lzm> i cant install cabal-install 0.14 on a system with only ghc-7.6.2.. is this a known bug?
09:28:45 <shachaf> That depends.
09:28:50 <shachaf> Perhaps you should @paste the error.
09:29:08 <lzm> "Setup: At least the following dependencies are missing: base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.6"
09:29:26 <lzm> when i ran bootstrap.sh
09:30:06 <liyang> base <3
09:30:17 <liyang> More like base </3
09:30:17 <lzm> i see that ghc-7.6.2 comes with Cabal-1.16, but the latest cabal-install downloads Cabal-1.14
09:30:18 <liyang> D:
09:31:08 <liyang> Doesn't ghc already come with cabal-install? (The 'cabal' executable.)
09:31:17 <geekosaur> no
09:31:26 <geekosaur> haskell platform does, ghc comes only with the Cabal library
09:31:36 <liyang> oh rite.
09:32:14 <ion> lzm: The source tarball from http://hackage.haskell.org/package/cabal-install didn’t work?
09:33:19 <lzm> ion: i got the tarball from http://www.haskell.org/cabal/download.html
10:26:54 <viller> here's the source code for intersperse http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#intersperse
10:27:19 <viller> why does it use a separate function prependToAll? I imagine the comment in front of it is explaining that but as newb I don't get it
10:28:26 <geekosaur> it's related to compiler internals, and is a level of optimization you should probably not be worried about
10:29:16 <bitonic> geekosaur: no, it’s not, `prependToAll a [b,c] === [a,b,a,c]'
10:29:32 <bitonic> while `intersperse a [b,c] === [b,a,c]'
10:29:34 <ozataman> is there way yet to select a specific executable for compilation during cabal install?
10:29:35 <einsof> What is haskell?
10:29:40 <bitonic> viller: actually that was your question :P
10:30:02 <geekosaur> it makes sense for heavily used functions that are part of the base install to be as fast as they can possibly be, so they sometimes do things that look a bit contorted. as a user, you do not want to worry about getting perfect code from the compiler like that
10:30:11 <einsof> What is love?
10:30:24 <geekosaur> bitonic, I don't quite see what your response has to do with what I said
10:30:27 <sepp2k> bitonic: How does that explain anything?
10:30:35 <viller> bitonic: what? My question was why not what the functions do
10:31:14 <bitonic> viller, geekosaur, sepp2k: ?  the auxiliary function is used to implement `intersperse'
10:31:55 <bitonic> I thought the question was ‘why isn’t intersperse need an auxiliary function’
10:32:00 <bitonic> *why does intersperse
10:32:20 <geekosaur> but, in short: if you break up code into a worker and a wrapper like that, you can often cause the compiler to fuse the traversal so you get both laziness and minimal memory allocation. in addition it appears that at least some versions of ghc fuse it better if it's a top level definition instead of using a worker defined in a "where" clause as is commonly used in other places
10:33:12 <viller> geekosaur: ok your explanation is mostly sufficient, thanks. I don't think I want to understand how GHC works :)
10:33:25 <geekosaur> "related to compiler internals" does not mean "mucks with compiler internals", it just means reliance on a particular behavior not specified as part of the haskell standard... like worker/wrapper fusion
10:33:28 <sproingie> is there an easy way to know when you're getting fusion and when you're not?
10:33:46 <sproingie> other than "the heap isn't blowing up"?
10:33:48 <geekosaur> not really; you generally have to inspect the generated GHC Core
10:34:01 <geekosaur> (see the ghc-core package on hackage if you really care)
10:34:15 <sproingie> learning core is somewhere on my todo list :)
10:34:22 * sproingie flips a few pages ...
10:35:46 <bitonic> viller: oh, sorry about the misunderstanding
10:36:29 <bitonic> viller: I wouldn’t worry too much about that anyway - few people could accurately predict what’s going on, it’s just about running benchmarks and inspecting the output of GHC
10:36:35 <viller> bitonic: no problem
10:37:04 <bitonic> also considering that the whole fusion business is quite fragile last time I checked
10:37:34 <geekosaur> worker/wrapper's usually an easy one; that someone actually went to the effort of benching a top level binding vs. a local binding is (a) surprising and (b) potentially quite fragile in the face of GHC upgrades
10:38:33 <geekosaur> but since the GHC devs maintain that code, it may well make perfect sense --- for *them*
10:38:58 <geekosaur> not for general user code, unless you really need to squeeze the last few milliseconds of performance out of your code for some reason
10:39:19 <mcstar> , you switch to C
10:39:52 <geekosaur> .oO { duff's device in haskell }
10:40:38 <mcstar> geekosaur: and why the hell would cause space leak, writing a recursive intersperse?
10:42:02 <bitonic> mcstar: well geekosaur postulated that the top-level worker helps trigger fusion
10:42:15 <bitonic> if you don’t get fusion you are going to get more space
10:42:17 <joker_89> hi
10:42:18 <bitonic> *use
10:42:34 <geekosaur> mcstar, not clear immediately, but I am guessing from the way the comment is phrased that it's not intersperse itself that would have the space leak, but naïve uses of it. making it fuse would help avoid that
10:43:01 <geekosaur> and it's a lot easier for ghc to fuse worker/wrapper than straight recursion, although it gets better at the latter all the time
10:43:03 <bitonic> mcstar: fusion = eliminating intermediate lists when composing list operations, roughly
10:43:38 <joker_89> can i use multiples cases inside other cases? like | x==y <return key> | x==1 =1 <return key> | x==1 =2 <return key>x\=y = -1
10:43:45 <geekosaur> (note also that some things in the libraries were written with earlier versions of ghc and not necessarily revisited with later versions to see if a more obvious implementation would work just as well; "if it ain't broke...")
10:44:39 <monochrom> fusion in GHC is done by adding handwritten rewrite rules and helper functions to library code. GHC does not have a specific fusion optimizer; it has a use-the-handwritten rules optimizer instead
10:44:44 <geekosaur> joker_89, no, but you can have the duplicate cases use a local "where" binding if the code is significant. or you can use logical operations: | x == y || x == 1 = ...
10:46:32 <mcstar> well, thanks for the answers, but there doesnt seem to be a concensus
10:46:35 <stelleg> anyone know why minusPtr and plusPtr don't have type dependent analogs?
10:46:38 <mcstar> i dont want to press the issue though
10:46:48 <joker_89> how to put nested sentnces in haskell?
10:46:53 <stelleg> a la c
10:47:34 <sepp2k> joker_89: Put them where?
10:47:40 <mcstar> Foreign.Ptr plusPtr :: Ptr a -> Int -> Ptr b, how is that not type dependent?
10:47:41 <sepp2k> And what exactly is a nested sentence?
10:47:44 <monochrom> what is nested sentences?
10:47:44 <geekosaur> joker_89, I have no idea what you just asked
10:48:00 <monochrom> show examples
10:48:03 <stelleg> mcstar: I guess what I mean is the increment should depend on a
10:48:09 <geekosaur> stelleg, last I checked they used the size of a?
10:48:32 <geekosaur> hm, no they don't
10:48:36 <geekosaur> "offset in bytes:
10:48:38 <stelleg> geekosaur: nope, they increment in bytes
10:48:40 <stelleg> yeah
10:48:43 <mcstar> stelleg: maybe it does? and the Int you give is measure in the sizes of 'a'
10:48:50 <geekosaur> oh wait, I know why
10:48:54 <joker_89> like this in c: (if a==1) { if(b==2) do this; else do this} else do this
10:48:59 <joker_89> nested sentences
10:49:06 <geekosaur> you may be looking for Foreign.Marshal.Array
10:49:11 <geekosaur> plusPtr is used to index structs
10:49:14 <stelleg> geekosaur: ah
10:49:27 <stelleg> geekosaur: thanks, I think I have seen that before and just blanked
10:49:46 <monochrom> if a==1 then (if b==2 then this else this) else this. some parentheses may be omitted, I have not checked
10:49:55 <stelleg> peekArray is what I'm looking fore
10:49:56 <sepp2k> joker_89: You can nest ifs just fine in Haskell.
10:49:59 <stelleg> :t peekArray
10:50:01 <lambdabot> Not in scope: `peekArray'
10:50:06 <sepp2k> They're not usually called sentences though.
10:50:20 <monochrom> in fact, maybe I should check now
10:50:21 <joker_89> but how can i do this with cases |
10:50:34 <joker_89> where can i put my code?
10:50:34 <monochrom> > if False then if False then 0 else 1 else 2
10:50:34 <stelleg> although actually
10:50:36 <lambdabot>   2
10:50:39 <monochrom> \∩/
10:50:52 <joker_89> but i use cases not if then else
10:50:57 <geekosaur> @paste
10:50:57 <lambdabot> Haskell pastebin: http://hpaste.org/
10:51:03 <stelleg> geekosaur: actually thats a little different, because I want pointer arithmetic
10:51:07 <monochrom> you want case? I can do that too
10:51:16 <sepp2k> joker_89: What exactly do you want to nest in your cases?
10:51:40 <sepp2k> You can nest patterns just fine. And you can also use a case within another case without problems.
10:51:46 <hpaste> bet pasted “fdfs” at http://hpaste.org/84166
10:51:56 <monochrom> > case False of { True -> case False of { True -> 0; False -> 1 }; False -> 2 }
10:51:56 <joker_89> like this: http://hpaste.org/84166
10:51:57 <geekosaur> stelleg, see Foreign.Marshal.Array.advancePtr maybe?
10:51:58 <lambdabot>   2
10:52:13 <monochrom> {;} can be replaced by indentation and newline
10:52:16 <stelleg> e.g. geekosaur yeah that works for plus
10:52:22 <joker_89> perhaps i have other errors, because i do only a draw
10:52:31 <geekosaur> Int is signed...
10:52:56 * stelleg is kind of slow
10:53:11 * stelleg should probably go back to bed
10:53:18 <monochrom> joker_89: I see no if-then-else or case in your paste
10:53:23 <stelleg> geekosaur: thanks for putting up with me being stupid
10:53:28 <joker_89> the where clauses monique_
10:53:30 <sepp2k> joker_89: Some of your guards aren't followed by a =
10:53:32 <geekosaur> (plusPtr and minusPtr are what they are because of hsc2hs, which is not especially smart, I think)
10:53:42 <joker_89> ouch is the =
10:53:45 <geekosaur> (which is why some folks prefer c2hs)
10:53:56 <stelleg> yeah I'm using c2hs
10:54:34 <monochrom> ok, I see what you want. unfortunately, guards don't support your kind of nesting.
10:54:35 <sepp2k> joker_89: \= should be /= I imagine.
10:54:37 <joker_89> but says parse error on input `|'
10:55:18 <joker_89> in line 8
10:55:26 <sepp2k> joker_89: Yes because every guard needs a =
10:55:28 <monochrom> you must say: | condition = answer. that is all you can do.
10:55:29 <geekosaur> joker_89, it would, your line 6 is missing an = so line 8 would produce that error
10:55:33 <geekosaur> as someone already mentioned
10:55:38 <sepp2k> And there's no = for the guard on line 6
10:55:50 <geekosaur> and again, you can use | condition || condition = ... or whatever
10:55:52 <monochrom> if you want nesting, switch back to if-then-else
10:56:05 <stelleg> geekosaur: actually I wasn't being entirely stupid
10:56:22 <joker_89> i put the = and says the same
10:56:23 <monochrom> or yeah, re-arrange your logic to fit a flat list of "| condition = answer"
10:56:28 <stelleg> @hoogle Storable a => Ptr a -> Ptr a -> Int
10:56:28 <lambdabot> Foreign.Ptr minusPtr :: Ptr a -> Ptr b -> Int
10:56:28 <lambdabot> Foreign.Marshal.Array lengthArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO Int
10:56:28 <lambdabot> Prelude asTypeOf :: a -> a -> a
10:56:44 <geekosaur> you werent be ing stupid at all, I read it as you were thinking in terms of plus{tr and minustr, but *those* are stupid because they're designed for use by a rather stupid tool
10:56:45 <sepp2k> joker_89: You also have otherwise followed by more guards. That doesn't make sense.
10:56:55 <geekosaur> wow, where is my typing today
10:57:21 <stelleg> theres no analog to subtract two pointers dependent on the size of their type argument
10:57:46 <geekosaur> yeh, I think that's not often called for in haskell
10:57:49 <sepp2k> joker_89: I just realized what you want to achieve there. You can't nest guards that way. Use if or case.
10:58:03 <joker_89> ok
10:58:03 <stelleg> yeah
10:58:14 <monochrom> sepp2k: joker_89 desires to write "if x then (if y then 0 else 1) else 2" as "| x (| y = 0 | otherwise = 1) | otherwise = 2"
10:58:38 <sepp2k> monochrom: Yeah, I got it.
10:58:40 <joker_89> ok i going to change it thanks
10:58:47 <stelleg> just seems like it would be useful functionality given that c is capable of it
10:58:55 <stelleg> oh well
10:58:59 <stelleg> thanks for the help
10:59:09 <geekosaur> C is perfectly capable of producing core dumps; we kinda like to avoid them :p
10:59:38 <stelleg> haha fair enough
11:01:15 <joker_89> inside a if-then-else can i put a where clause?
11:01:33 <joker_89> because i have a if-elseif-else
11:01:57 <geekosaur> no, if-then-else is an expression, where is part of declaration syntax
11:02:06 <geekosaur> but you can use let ... in ...
11:02:06 <sepp2k> joker_89: No, you can only use where after the function definition. You can use let though.
11:02:13 <joker_89> so how can i simpuate a if-elseif-else..
11:02:19 <joker_89> ok let..
11:02:31 <geekosaur> also, nothing wrong with if ... else if ... else
11:03:23 <mcstar> you can use a guard... didnt you use that?
11:03:39 <joker_89> a guard?
11:03:46 <mcstar> the |
11:04:07 <joker_89> yes but
11:04:12 <joker_89> i can uses guards nested
11:04:21 <mcstar> you dont need to nest
11:04:48 <mcstar> you can translate an if(){}else if(){} else if() {} directly
11:05:10 <joker_89> but i have this inside an if then ( )
11:05:29 <mcstar> joker_89: paste the code you want to haskell-ize
11:05:33 <mcstar> on hpaste
11:05:38 <joker_89> like this: http://hpaste.org/84166
11:05:46 <joker_89> i pasete it before
11:05:53 <joker_89> now i convert the | to if then else
11:05:56 <mcstar> oooh
11:07:31 <arbn> Wow. That's not pretty.
11:07:32 <mcstar> you can flatten much in that
11:07:45 <mcstar> after line 31 everything can be flattened
11:08:31 <anonymoose_lambd> hello
11:08:32 <joker_89> using where?
11:08:36 <joker_89> i have repetitive code
11:08:45 <joker_89> but first i want to structure my nested |
11:08:50 <chrisdone> lpsmith: how are you supposed to implement an instance of FromRow? http://hackage.haskell.org/packages/archive/postgresql-simple/0.2.4.1/doc/html/Database-PostgreSQL-Simple.html#t:FromRow
11:10:01 <chrisdone> lpsmith: ah, nevermind. it's just a re-export and haddock's confusing output
11:10:29 <lispy> ah yeah, I don't recommend reading haddocks as html :(
11:11:02 <lispy> it's unfortunate but there are too many infelicities in the way it displays things
11:11:09 <joker_89> mcstar any idea?
11:11:16 <arbn> lispy: How do you recommend reading them?
11:11:27 <mcstar> joker_89: i mthinking
11:11:39 <joker_89> only how to structure the sentences
11:11:42 <joker_89> then i will flatten
11:12:38 <anonymoose_lambd> I want to install bullet (physics library) for haskell. Bullet requires c2hs. c2hs requires language-c, but the version of language-c from cabal is too new.
11:12:41 <anonymoose_lambd> I am running Linux Mint 13, and I am trying to install by doing `runhaskell Setup configure; runhaskell Setup build; sudo runhaskell Setup install`
11:12:57 <anonymoose_lambd> what should I do?
11:13:20 <anonymoose_lambd> btw, this is a first time I am trying to install something from cabal.
11:13:34 <anonymoose_lambd> so this may be really obvious and stupid question
11:14:11 <geekosaur> if you know a version of language-c that works, --constraint might work there
11:14:41 <geekosaur> runhaskell Setup.hs configure --constraint language-c==known.good.version
11:14:45 <elliott> joker_89: didn't someone already tell you that |s don't nest?
11:14:53 <anonymoose_lambd> ok, thank you. I will try that
11:15:12 <elliott> beyond that, this code looks like it can't possibly work. like, unless you defined (\=), that operator doesn't exist (is it even a valid operator name?)
11:15:57 <mcstar> joker_89: http://sprunge.us/UJKY?haskell you can use this trick
11:16:49 <joker_89> i go to si
11:16:51 <joker_89> see
11:16:53 <geekosaur> (I am not actually sure it'sll support constraints like that; I would hope it does but don't know which options are specific to cabal-install and which are actually part of the Cabal framework. that said, if it rejects that option you can try "cabal install --constraint language-c=whatever" without a package name
11:16:54 <elliott> case () of _ | ... | ... is nicer imo. but this code just wants rewriting from scratch; even beyond the nesting there's much duplication
11:17:21 <mcstar> or that
11:18:04 <joker_89> and using more than 1 fucntion?
11:18:39 * hackagebot split-channel 0.2.0.0 - Control.Concurrent.Chan split into sending and receiving halves.  http://hackage.haskell.org/package/split-channel-0.2.0.0 (LeonSmith)
11:19:34 <anonymoose_lambd> geekosaur: ok
11:22:44 <mcstar> elliott: like this? http://sprunge.us/GKJT?haskell
11:24:20 <elliott> mcstar: right. though honestly I'd just refactor, e.g. into two functions with guards, or use if/else, or in this case use case instead of (==) if possible, etc.
11:24:43 <mcstar> yeah that code is a mess
11:27:36 <mcstar> elliott: this could work too http://sprunge.us/FJac?haskell
11:27:40 <mcstar> joker_89: ^
11:27:47 <joker_89> yes
11:27:53 <mcstar> refactor, and if you still need nesting, use one of the styles
11:28:06 <elliott> mcstar: right
11:28:32 <joker_89> ok
11:28:34 <joker_89> tahnks
11:30:15 <anonymoose_lambd> what does "Setup.hs: dependency expected" mean?
11:32:02 <lispy> arbn: as source
11:32:25 <lispy> arbn: About 80% of the time the first thing I do when looking at haddocks on hackage is to click the source link at the top.
11:41:51 <jmcarthur> if a library uses UndecidableInstances and it type checks, the fact that it uses UndecidableInstances doesn't have any potentially unsafe or annoying effects on client code, right?
11:43:06 <byorgey> jmcarthur: correct
11:44:01 <mcstar> well, maybe it mentally isnt too satisfying
11:44:09 <Xaratas> hmm
11:45:06 <Xaratas> i have mapM_ (print longcalculation_which_returns_a_list) how can i add a line number to each print?
11:45:39 <crdueck> Xaratas: use a zipWithM, and zip the list of calculations with [1..]
11:46:00 <lispy> > [1..]
11:46:02 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:46:07 <Xaratas> ah, nice
11:46:18 <fizbin> :t zipWithM
11:46:20 <lambdabot> Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
11:46:23 <arkeet> > zip [0..] "hello"
11:46:25 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
11:46:28 <Taneb> Remember that guy who said he had a roughly Haskell 98 compliant implementation a couple of weeks ago?
11:46:29 <lispy> Xaratas: if you have more than 28 in your list you might be in trouble
11:46:37 <arkeet> > "hello" ^@.. itraversed
11:46:40 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
11:46:49 <lispy> Taneb: implementation of what?
11:46:52 <Taneb> Haskell
11:47:05 * lispy doesn't remember it
11:47:14 <mcstar> with jit?
11:47:37 <Taneb> I dunno
11:47:48 <Taneb> I'm just in a mood for off-piste Haskell implementations
11:48:07 <mcstar> there was talk about fay, ghcjs, lambdachine
11:48:16 <mcstar> take your pick
11:54:55 <srhb> What can cause a failed pattern match to cause a silent crash rather than error then crash?
11:54:59 <fizbin> @pl \f -> 0 : 1 : zipWith (+) f (tail f)
11:54:59 <lambdabot> (0 :) . (1 :) . ap (zipWith (+)) tail
11:55:13 <mcstar> srhb: can you paste an example
11:55:28 <mcstar> megalol, sry
11:55:29 <srhb> mcstar: I wish, my code is a little too complex, hence the question.
11:55:46 <srhb> I suppose if I'm catching it somewhere by mistake...
11:56:04 <fizbin> @pl \f -> [0, 1] ++ zipWith (+) f (tail f)
11:56:04 <lambdabot> ([0, 1] ++) . ap (zipWith (+)) tail
11:56:32 <mcstar> srhb: how does a silent crash look like?
11:56:59 <srhb> mcstar: Like program terminates with no error.
11:57:07 <mcstar> hm
11:57:15 <elliott> srhb: threads?
11:57:20 <mcstar> thats not really a crash, id say
11:57:26 <monochrom> a monad that defines "fail" to give a silent sensible answer can cause a failed pattern match to be silent. but it gives an answer, not a crash
11:57:54 <srhb> I'll have to go over it again. I have a feeling only catching the exception should cause this.
11:57:55 <monochrom> > do { 0 <- return 1; [3] }
11:57:57 <lambdabot>   can't find file: L.hs
11:57:59 <monochrom> > do { 0 <- return 1; [3] }
11:58:01 <lambdabot>  Terminated
11:58:06 <monochrom> > do { 0 <- return 1; [3] }
11:58:07 <lambdabot>   []
11:58:19 <srhb> What the hell?
11:58:19 <monochrom> that is in fact a correct answer
11:58:34 <arkeet> > do { mzero; [3] }
11:58:34 <srhb> Which one? :P
11:58:35 <lambdabot>   []
11:59:01 <monochrom> ignore "can't find L.hs" and "Terminated". they are just the host machine acting up.
11:59:09 <Taneb> > do {1 <- return 1; [3]}
11:59:10 <lambdabot>   [3]
11:59:16 <srhb> OK, great.
11:59:27 <monochrom> []'s fail is []'s mzero which is the empty list
11:59:41 <monochrom> similarly, Maybe's fail is mzero which is Nothing
11:59:49 <monochrom> > do { 0 < return 1; Just 3 }
11:59:50 <lambdabot>   Couldn't match expected type `m0 a0'
11:59:51 <lambdabot>              with actual type `GHC.Typ...
11:59:58 <monochrom> > do { 0 <- return 1; Just 3 }
12:00:00 <lambdabot>   Nothing
12:00:10 <monochrom> and it is also a correct answer
12:00:12 <sproingie> as expected
12:01:12 <fizbin> > do { 3 <- [3,3,3,3]; [4] }
12:01:14 <lambdabot>   [4,4,4,4]
12:01:47 <sproingie> > do { 1 <- [1,2,1,2]; [3] }
12:01:49 <lambdabot>   [3,3]
12:01:55 <sproingie> simple
12:02:37 <mcstar> when i explained someone monads, i said, dont look at 'fail' it was a bad design decision
12:02:39 <mcstar> was i correct?
12:02:42 <sproingie> yes
12:02:46 <srhb> I don't like it.
12:02:53 <srhb> It's completely unexpected.
12:03:05 <srhb> (but problem solves)
12:03:06 <srhb> d*
12:03:25 <sproingie> fail is a wart, mzero is the proper abstraction.  now a MonadFail for some special cases might have some merit
12:04:25 <fizbin> Also, the CT monad definition doesn't really have a "fail" analogue.
12:06:03 <aCube> MonadFail is MonadPlus without (mplus)?
12:06:09 <monochrom> right
12:06:44 <heath> i'm a little confused on the difference between algebraic data types and and typeclasses right now. I had these two concepts mixed up it seems, researching...
12:06:57 <sproingie> encapsulating the notion of a "failed" computation so you could stack it over, say, the List monad and differentiate between zero and a bad match
12:07:14 <monochrom> it should be easy. a type class is not even a type.
12:07:15 <sproingie> if this were enforced throughout, it might be a bit inconvenient though for, say, IO
12:07:16 <mcstar> typeclasses have nothing to do with ADTs, they are predicates on types
12:07:46 <monochrom> the code "class Haha a where" does not define a type.
12:08:02 <mcstar> i read a paper today, that proposes it should :)
12:10:03 <mcstar> thiemann: interfaace types for haskell
12:10:41 <sproingie> what would they add?
12:10:53 <heath> actually, yeah, what is the difference between data foo... and class foo...?
12:11:08 <mcstar> they both dont work
12:11:08 <sproingie> quite a bit.  data defines data constructors for concrete types
12:11:15 <sproingie> class defines a predicate on types
12:11:15 <monochrom> "data Foo = ..." defines a type. "class Foo a where ..." does not.
12:11:20 <mcstar> heath: they should start with uppercase
12:11:23 <sproingie> and instance asserts the predicate holds
12:11:49 <monochrom> suppose you write "class Foo a where ..." and then never write any "instance Foo ...". then Foo is completely unusable.
12:12:10 <monochrom> however, "data Foo = ..." you can immediately use Foo now
12:12:38 <heath> fantastic, ty monochrom :)
12:12:40 <mcstar> you cant use instance on a type that doesnt exist
12:13:08 <mcstar> (notwithstanding type parameters)
12:14:28 <monochrom> type class is for organized name overloading. that is all.
12:14:44 <hpaste> jmcarthur pasted “wondering how to best do this crazy thing” at http://hpaste.org/84172
12:15:37 <jmcarthur> i don't particularly mind whether P is defined as a data family or a GADT, although the former is nicer due to the lower runtime overhead
12:15:45 <jmcarthur> the GADT version has the same problem though
12:15:53 <mysticc> Given a datatype (for now consider it to be non recursive), I want to iterate over all its constructors (Somehow I want to generate values of this datatype with each of its constructor). I feel like typeable can help but I am not sure.
12:16:16 <monochrom> "I want Int, Bool, and Float to all enjoy functions of the same name 'whee' and operators of the same name '^^'."  class Same a where {whee :: a -> a; (^^) :: a -> a -> a}; instance Same Int where ...; instance Same Bool where ...
12:16:18 <jmcarthur> mysticc: what kind of an iteration. what is the type of the function you need?
12:18:05 <mysticc> jmcarthur: Suppose my datatype is data Foo = Bar | Biz Int, then I want to generate two value Bar and Biz 0 (It can be any Int) (This has to be general and not restricted to this example)
12:18:26 <jmcarthur> mysticc: what do you mean by "generate"? random values?
12:18:43 <jmcarthur> enumerate?
12:19:00 <mysticc> jmcarthur: Maybe
12:19:24 <jmcarthur> anybody have any thoughts on my hpaste? ^^
12:20:21 <mysticc> jmcarthur: My actual problem is given an example like Case a of p1 -> e1; p2 -> e2; I want to generate two values of typeOf a such that it can satisy p1 and then p2
12:20:33 <jmcarthur> ah woops i left an extra error in my paste
12:21:08 <hpaste> jmcarthur revised “wondering how to best do this crazy thing”: “wondering how to best do this crazy thing” at http://hpaste.org/84172
12:21:35 <jmcarthur> (was just a missing constraint that i could handle, but the other missing constraint is still not doable)
12:22:17 <jmcarthur> mysticc: could you use generics for this?
12:23:42 * hackagebot snap-app 0.3.0 - Simple modules for writing apps with Snap, abstracted from hpaste.  http://hackage.haskell.org/package/snap-app-0.3.0 (ChrisDone)
12:23:50 <mysticc> jmcarthur: I haven't used generics so I am not sure. Is there any concrete example or reading material of generics you can point me to, so that I can investigate further.
12:24:12 <mcstar> jmcarthur: i watched yaron minsky on ocaml, do you guys really use curses ui's? XD
12:24:20 <jmcarthur> mcstar: yes, all over the place
12:24:32 <mcstar> haskell at least has vty-ui
12:24:35 <jmcarthur> why bother with a gui when a cli is so much easier to write and maintain?
12:24:57 <mcstar> jmcarthur: are there terminal emulators for the browser?
12:25:03 <jmcarthur> probably
12:25:20 <mcstar> i guess curses is more easily 'protable' to the browser then say qt XD
12:25:24 <jmcarthur> heh
12:25:31 <jmcarthur> we just use shells anyway
12:25:49 <srhb> What's funny about curses?
12:26:08 <arbn> What Haskell program uses curses? Off the top of my head, I can't think of any.
12:26:34 <mcstar> off the top of my head i cant think of many programs that use haskell at all
12:26:37 <jmcarthur> we rarely even directly use the computers we're sitting at and just use ssh most of the time
12:26:58 <monochrom> chrisdone has a terminal emulator in javascript. it imports jquery.
12:27:35 <geekosaur> http://packdeps.haskellers.com/reverse/hscurses
12:27:57 <monochrom> https://github.com/chrisdone/jquery-console
12:28:01 <supki> arbn: vimus
12:29:22 <jmcarthur> we're even starting to use raspberry pis to drive some of our monitoring systems. it's tougher to do that with clunky complicated guis
12:29:43 <mcstar> o.O
12:29:57 <mcstar> that goes against my intuition
12:30:06 <jmcarthur> wha-?
12:30:06 <mcstar> the first part not the second
12:30:09 <jmcarthur> ah
12:30:17 <jmcarthur> they just ssh into the "real" hardware
12:30:40 <jmcarthur> they are more like dumb terminals, i guess
12:30:50 <arbn> Raspberry Pis are kind of pricey, as far as such things go.
12:30:56 <arbn> I guess they're trendy, though.
12:30:56 <monochrom> soon, you will say, it makes more sense to set jumping switches than typing on a keyboard
12:31:07 <jmcarthur> less pricey than a desktop or something
12:31:08 <monochrom> s/jumping/jumper/
12:31:31 <jmcarthur> monochrom: i do use a mechanical keyboard :P
12:31:36 <arbn> jmcarthur: Yeah. I just mean, if you look around, you can find RPi-like devices that are cheaper. Just less marketing and hype.
12:31:36 <monochrom> indeed, a block of 8 jumper switches is 10% of the cost of a keyboard
12:31:39 <jmcarthur> so there are switches at least
12:31:51 <jmcarthur> arbn: sure
12:32:53 <jmcarthur> trying one more time... halp!   http://hpaste.org/84172
12:32:54 <monochrom> also, a keyboard doesn't fit on the small motherboard of arduino
12:33:01 <jmcarthur> heh
12:33:23 <mcstar> chris done got really angry, when someone asked if his name is really done
12:33:37 <jmcarthur> o_O
12:33:41 <mcstar> ^ was meant to be on haskell-blah
12:33:44 <jmcarthur> ah
12:35:06 <parcs> are CLIs really simpler to write than GUIs?
12:35:11 <mcstar> jmcarthur: can  you describe what are you trying to achieve? just that i learn somehting from the paste
12:35:27 <mcstar> parcs: no, but dont tell that to them
12:35:40 <parcs> i wouldn't think so. ncurses is terrible
12:35:46 <mcstar> (and they are less flexible, but they dont need X either...)
12:36:12 <parcs> i do see the appeal of the CLI but i don't think they're easier to write
12:36:13 <monochrom> but ncurses etc are GUI in text mode, not CLI. CLI refers to getopt, cmdargs, etc
12:36:18 <jmcarthur> to be fair, most of our tools are honest to goodness command line tools. most of our curses stuff are monitoring-related
12:36:33 <mcstar> monochrom: yeah, he meant text ui
12:36:38 <arbn> parcs: I am firmly of the opinion that, even if you are writing a GUI, you should write a CLI interface to all functionality as well. This forces you to separate presentation from mechanism like you should.
12:36:38 <parcs> monochrom: a text GUI is still a CLI :P
12:36:55 <parcs> actualyl that's probably not true
12:37:06 <monochrom> no way. a text GUI contradicts the "line" part of CLI
12:37:20 <jmcarthur> mcstar: i'm trying to make a type that stacks some monad transformer n times, possibly with some different type parameters at each layer. i'm exposing those type parameters in a type level list
12:37:30 <monochrom> a text GUI is 2D screen-wise not 1D line-wise
12:37:31 <srhb> Yeah, people are talking about TUIs here.
12:37:35 <jmcarthur> mcstar: and the whole thing should be a monad transformer, too
12:38:07 <monochrom> I am fine if you say "CI" and say "C means console"
12:38:09 <mcstar> jmcarthur: is 'n' determined implicitely, by the type?
12:38:23 <jmcarthur> mcstar: yeah, the length of the list is n
12:38:28 <parcs> arbn: depends on the application. how are you going to write a CLI for a CAD system?
12:39:15 <monochrom> "add line (0,3) (100,4000)"
12:39:29 <monochrom> "add circle (40, 30) 2000"
12:39:41 <mcstar> also, the lines it draw, could really use some smoothing
12:39:46 <mcstar> maybe a 1x1 font would do
12:40:27 <arbn> parcs: It doesn't depend on the application. At some level, the graphical interface is translated into an intermediate representation as data, and you can accept that data from a command-line.
12:40:38 <monochrom> you can use colours of nearby character positions for unaliasing. pixel-level drawing already does that.
12:40:38 <arbn> parcs: Look at the GIMP as an example of this, for instance.
12:40:53 <arbn> the graphical interface inputs*
12:41:02 <srhb> mplayer has an ASCII output mode, afaik
12:41:14 <parcs> oh, i see
12:41:14 <mcstar> it has framebuffer too
12:41:20 <mcstar> id rather use that
12:41:25 <srhb> mcstar: Psch. :P
12:41:48 <jmcarthur> i think using the command line for a graphical domain is taking it a bit too far
12:42:11 <jmcarthur> although that's not to say it can't be keyboard oriented
12:42:16 <mcstar> well, it isnt that far, if you embed a scripting language in an apap
12:42:19 <mcstar> which is common
12:42:26 <mcstar> CAD has it
12:42:36 <mcstar> mayavi has it
12:42:49 <arbn> jmcarthur: I'm not saying that you should *use* the command-line, I'm saying that including a scriptable text interface aids separation of concerns.
12:43:12 <YayMe> Any tips on what I could do better here, or if this is fairly correct and appropriate implementation? http://codereview.stackexchange.com/questions/23963/haskell-network-connection-graceful-handler
12:43:38 <arbn> jmcarthur: Such that, I make sure to include such a direct interface to the mechanism layer (as oposed to presentation) in everything I write.
12:43:39 <jmcarthur> arbn: that's fine
12:44:43 <YayMe> I should probably use lens instead of having created fst' (a,b,c) = a
12:44:47 * geekosaur wonders what jmcarthur thinks of wksh/dtksh
12:44:50 <YayMe> Does anyone here know lens well enough to tell me how to get that?
12:45:20 <YayMe> (presuming edwardk isn't here, obviously he knows it well enough)
12:45:26 <mcstar> > (1,2,3) .^ _1
12:45:28 <lambdabot>   Not in scope: `.^'
12:45:28 <lambdabot>  Perhaps you meant one of these:
12:45:28 <lambdabot>    `.' (line 112), `P.....
12:45:29 <klrr> http://hastebin.com/fowiwoyobe.hs <- i get some weird error about missmatching types in the first function, what did i wrong :x ?
12:45:34 <jmcarthur> geekosaur: i don't know anything about those
12:46:06 <YayMe> mcstar: cool. Can I cabal install lens and get a relatively correct version?
12:46:30 <mcstar> YayMe: oh no..... i just tried that to check, not that it WORKS
12:46:38 <geekosaur> > (1,2,3) ^. _1 -- ?
12:46:40 <lambdabot>   1
12:46:43 <mcstar> ah right
12:46:49 <mcstar> i remembered something like that
12:46:52 <mcstar> i messed up the . :)
12:47:09 <parcs> klrr: you forgot to call unlines, i think
12:47:17 <YayMe> Is cabal install the best way to get lens? I know it's so recently become stable..
12:47:31 <geekosaur> would help if you included the full error message
12:47:35 <klrr> parcs: hmm, it works in ghci
12:47:39 * mcstar thinks cabal install is always the best way
12:47:48 * jmcarthur too
12:47:54 <elliott> YayMe: cabal install lens is ok
12:47:55 <parcs> klrr: do ':t reverseAll' in ghci
12:47:59 <klrr> parcs: map reverse (lines str) returns a list which can be used by reverse why not?
12:48:01 <byorgey> klrr: lines str :: [String];  map reverse (lines str) :: [String];  reverse $ map reverse (lines str) :: [String]
12:48:01 <klrr> okey
12:48:04 <monochrom> yes, use cabal install to get lends
12:48:11 <monochrom> err, s/lends/lens/
12:48:11 <byorgey> klrr: yes, but you said reverseAll should return a String
12:48:13 <elliott> there is always fancy stuff in the repository. but there is always fancy stuff in the released version too
12:48:19 <byorgey> klrr: but at the moment you have it returning a list of Strings
12:48:22 <klrr> byorgey: oh shit yeah
12:48:23 <YayMe> righto. Thanks
12:48:29 <klrr> unlines it will be then sry!
12:49:37 <klrr> hmm now it doesnt complain about type missmatch, but it seems to not work
12:50:30 <byorgey> klrr: you will have to be more specific.  In what way exactly does it not work?
12:50:52 <byorgey> klrr: oh, note inFile is a *file name*
12:51:02 <byorgey> so you are writing the reversed name of the input file to the output file
12:51:11 <byorgey> presumably you want to use readFile to get the contents of inFile first
12:51:25 <geekosaur> they did, then forgot about it
12:51:34 <geekosaur> file <- readFile inFile
12:51:40 <byorgey> oh, hehehe
12:51:43 <klrr> byorgey: http://hastebin.com/yivoluvada.txt
12:52:07 <byorgey> klrr: yup. You wrote the reversed *name* of the file.
12:52:57 <klrr> byorgey: oh shit, thanks!
12:53:29 <klrr> NOW IT WORKS!!! :D
12:53:39 <klrr> (sry for getting overexcited)
12:53:42 <byorgey> =D
12:54:14 <klrr> http://shuklan.com/haskell/ <- hmm now im done with all lectures number 9 aint out yet :(
12:54:42 <hpaste> timthelion pasted “heh, I think not” at http://hpaste.org/84174
12:54:42 <YayMe> klrr: Suggestion, create a separate method for the activity which you hand args to, then you can pattern match instead of using if. reverseFile (in,out) = readFile in >>= \x -> writeFile out (reverseAll x) >> Just "Done!"; reverseFile x = Nothing; main = do result <- reverseFile getArgs <|> Just "Error, usage: blaaaa."; putStrLn result;
12:54:52 <flebron_> Hi. Why is :t genericLength [] generic, but let x = genericLength [], :t x is Integer? http://pastebin.com/H4YjWUr8
12:54:55 <timthelion> Anyone seen this beauty of an error message before
12:54:58 <mauke> The paste H4YjWUr8 has been copied to http://hpaste.org/84175
12:55:14 <YayMe> that won't type check
12:55:15 <YayMe> ignore me.
12:55:28 <timthelion> ?
12:55:34 <geekosaur> flebron_, that'd be the monomorphism restriction
12:55:38 <geekosaur> @where DMR
12:55:39 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
12:55:44 <klrr> YayMe: good idea , after that ill watch some Programming in Haskell lectures
12:56:23 <geekosaur> timthelion, that error would be exactly what it says, cabal is noting that you did not list the package as a dependency but tried to use it anyway
12:56:24 <YayMe> :t (>>)
12:56:26 <lambdabot> Monad m => m a -> m b -> m b
12:56:44 <geekosaur> cabal hides any packages you do not explicitly depend on
12:56:52 <timthelion> geekosaur: yes, when building the package fenfire, I need to depend on the package fenfire
12:57:02 <geekosaur> oh wait, I see, same package
12:57:06 <klrr> > (\x -> x+x) 2
12:57:08 <lambdabot>   4
12:57:16 <timthelion> geekosaur:  :D
12:57:28 <geekosaur> so you are using executable and library in the same package? I think cabal-install mishandles that cirrently and you need to build the library a separate time as part of the executable?
12:57:44 <timthelion> geekosaur: ah, I'll look at that
12:58:02 <klrr> > let f = (\x -> f $ x + 1) 0
12:58:04 <lambdabot>   not an expression: `let f = (\x -> f $ x + 1) 0'
12:58:09 <geekosaur> (known cabal shortcoming, not sure of current status but you should be able to find it in cabal's bug tracker)
12:58:12 <YayMe> Is there any reason >> isn't Monad m, Monad m' => m a -> m' b -> m' b ? (Is there such a function?)
12:58:41 <geekosaur> kirr, lambdabot is not ghci, you must use let {bindings} in {expression}
12:58:55 <YayMe> I recognize the defintion is >>= \_ -> which obviously would have the type >> does, but curious since you're throwing away the result why not make it exit the present monad altogether?
12:58:59 <timthelion> geekosaur: thanks for the tip.
12:59:06 <monochrom> I don't know what "[1,2,3] >> getLine" should means
12:59:31 <YayMe> monochrome: but you know what getLine >> [1,2,3] should mean
12:59:40 <monochrom> no, I don't know that one either
12:59:55 <YayMe> get a line, then disregard it and return [1,2,3] anyway
13:00:20 <srhb> YayMe: "return" in what sense?
13:00:25 <YayMe> [1,2,3] >> getLine being "disregard [1,2,3] and return getLine's result instead
13:00:36 <srhb> YayMe: What would happen to the IO action?
13:00:36 <YayMe> srhb: sorry, just in the sense of a function's return, not a monad return
13:00:45 <srhb> Ie. its value
13:00:50 <monochrom> ok, you are saying, "getLine >> [1,2,3]" has type [Integer]. now, how does a value of type [Integer] performs I/O?
13:01:05 <timthelion> geekosaur: it seems to me that cabal is one of those projects that is badly designed, but too complex to be easilly replaced.
13:01:11 <YayMe> srhb: what happens to the monad action of getLine >> getLine >>= putStrLn right now? The first getLine is executed then thrown away
13:01:22 <srhb> YayMe: But who would implement the sequencing?
13:01:27 <srhb> YayMe: LEft hand? Right hand?
13:01:44 <monochrom> and your "why not make it exit the present monad" reveals the problem. how to exit a monad?
13:01:45 <geekosaur> srhb, if you do not use the result of getLine, it will not be run. in your other example, it is a hidden result of getLine maintained by the IO monad that ensures that it runs
13:02:02 <timthelion> geekosaur: though I guess we cannot complain, as it's better than the build tools for C
13:02:07 <geekosaur> er, I mean YayMe
13:02:08 <srhb> geekosaur: Sorry, what?
13:02:10 <srhb> Ah
13:02:13 <YayMe> we have >> for the purpose of executing but disregarding the left side's monad, if we execute it but disregard it, why do we care what monad comes next? I think the correct answer is: lazy evaluation would in the scenario I propose actually resolve out the left hand side to never execute.
13:02:22 <srhb> YayMe: No.
13:02:23 <monochrom> how do you exit IO? how do you define IO a -> a?
13:02:25 <pantsman> how does getLine >> [1,2,3] even compile?
13:02:32 <srhb> YayMe: What does 'disregarding the left side's monad" mean?
13:02:34 <pantsman> they are not the same monad
13:02:36 <sproingie> YayMe: the types have to match
13:02:38 <YayMe> pantsman: It doesn't, I'm pondering why we don't have such functionality
13:02:43 <timthelion> monochrom: performUnsafeLaunchSpaghetti
13:02:47 <geekosaur> pantsman, that's the point, YayMe wants >> to not require the same monad
13:02:51 <srhb> YayMe: Disregarding the return value is exactly what is implemented for each >>
13:02:52 <geekosaur> but does not understand the implications
13:02:55 <monochrom> I like spaghetti
13:03:01 <jmcarthur> YayMe: what should (>>) do then?
13:03:13 <sproingie> if they didn't have to match, then chains of >>= would be very ambiguous indeed
13:03:14 <YayMe> geekosaur: I'm trying to understand the implications, I know the people who made all this stuff thought it all through extremely carefully
13:03:29 <jmcarthur> YayMe: (>>) doesn't do "nothing"
13:03:33 <sproingie> like how would you interpret "liftM"?
13:03:34 <monochrom> YayMe, my questions reveal the implications.
13:03:44 <srhb> YayMe: Basically, without the machinery _in each monad_ you can't even disregard the first value. because you don't know how.
13:03:51 <amyers> YayMe: (>>) does not disregard the left side's monad, it disregards the value of the left side's computation
13:04:01 <timthelion> monochrom: you are ze zen master, all shall worship thou.
13:04:02 <croikle> maybe YayMe wants `seq` instead
13:04:14 <YayMe> amyers: I know that, getLine >> getLine >>= putStrLn waits for two lines, it just tosses one of them
13:04:22 <jmcarthur> right
13:04:45 <amyers> YayMe: Right, but in your previous comment you said it regards the left side's monad
13:04:52 <amyers> as opposed to the left side's value
13:05:02 <YayMe> I meant action
13:05:06 <pantsman> do you actually want fmap (const [1,2,3]) getLine
13:05:11 <srhb> It doesn't disregard the action
13:05:19 <jmcarthur> (>>) operates on the "m"s in "m a" and "m b" rather than the "a" and "b"
13:05:24 <YayMe> err, I don't know the right term for what I meant :P
13:05:27 <jmcarthur> (if you squint)
13:05:28 <srhb> the value.
13:05:46 <amyers> YayMe: srhb is exactly right, I think this is the confusion.  It runs the action but disregards the value
13:06:15 <amyers> YayMe: For example, discarding an IO a is very different from discarding an a
13:06:17 <jmcarthur> it doesn't "run" anything. i think that use of terminology leads to more confusion
13:06:39 <jmcarthur> @src (*>)
13:06:39 <lambdabot> (*>) = liftA2 (const id)
13:06:44 <YayMe> amyers: I understand how it works and how to use it just fine :P I'm just trying to understand the implications of a function that did as I'm referring to... though I'm having a hard time imagining how such a function would even be implemented because monads exist in layers
13:07:05 <srhb> Even without introducing "layers" (Transformers?) you have a problem.
13:07:10 <jmcarthur> YayMe: the function are asking about exists, it just doesn't do what you think it does since it necessarily can't considere effects at all
13:07:16 <jmcarthur> :t seq
13:07:17 <lambdabot> a -> b -> b
13:07:20 <jmcarthur> *consider
13:07:49 <pantsman> > [1,2,3] <$ getLine
13:07:51 <flebron_> How could I replicate this in Haskell? while(cin >> n) { ... }. I'd like to read from stdin, and return if there's nothing.
13:07:51 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO [t0]))
13:07:51 <lambdabot>    arising from a use o...
13:08:06 <YayMe> > seq (Just 3) (Left 4)
13:08:08 <lambdabot>   Left 4
13:08:26 <srhb> flebron_: Nothing _right now_?
13:08:41 <flebron_> I don't understand your question.
13:08:49 <jmcarthur> flebron_: you mean you want to return once you hit EOF?
13:09:04 <flebron_> Yep.
13:09:06 <srhb> flebron_: Either you want nonblocking IO or you want to read until EOF
13:09:23 <zacts> so when would I want to use haskell, and when would I want to use python?
13:09:33 <srhb> zacts: This is not a constructive question.
13:09:38 <flebron_> main() { int n; while(cin >> n) { ... } }
13:09:39 <jmcarthur> zacts: i never want to use python. i don't know when *you* would want to use python
13:09:42 <srhb> zacts: The answer in here is always and never, because we just lurv Haskell.
13:09:42 <monochrom> that requires uploading your brain for a full analysis
13:09:50 <jmcarthur> i take that back, i want to use python when i want to use a python library
13:09:53 <YayMe> jmcarthur: what does seq do? seq a b = b ?
13:09:57 <hpc> i have never wanted to use python, but at times i have needed to use it
13:10:02 <hpc> namely, mailman
13:10:04 <int-e> flebron_: nice endless loop?
13:10:09 <jmcarthur> YayMe: it evaluates the first argument, but its result is the second argument
13:10:11 <int-e> flebron_: hmm.
13:10:12 <zacts> srhb: I'm just trying to seriously understand the differences between the languages.
13:10:16 <flebron_> It finishes when there´s no more input.
13:10:21 <srhb> zacts: Then your question was just bad. :)
13:10:26 <flebron_> (It's the standard way to read input for programming competition,)
13:10:32 <jmcarthur> > seq undefined 5
13:10:34 <lambdabot>   *Exception: Prelude.undefined
13:10:39 <YayMe> jmcarthur: I just tried seq getLine (Just 4) in ghci and it didn't wait for anything..
13:10:42 <hpc> zacts: step 1. learn one of {haskell, python}
13:10:45 <hpc> zacts: step 2. learn the other
13:10:46 <jmcarthur> > let notseq _ x = x in notseq undefined 5
13:10:48 <lambdabot>   5
13:10:52 <jmcarthur> YayMe: exactly!
13:10:52 <srhb> zacts: You can read a lot of descriptions of Haskell at a lot of places, but none really encompass it. If you feel tempted by pure functional programming, have a go at it and decide if you like it.
13:10:57 <mcstar> python is great for a lot of stuff
13:11:07 <flebron_> Ah, it seems this is what i want: http://stackoverflow.com/questions/9754794/read-until-end-of-stream-in-haskell
13:11:11 <YayMe> jmcarthur: I don't understand :(
13:11:12 <jmcarthur> YayMe: it *evaluates* the first argument but can't *execute* an action because it's unaware of monads
13:11:20 <YayMe> ahh
13:11:23 <jmcarthur> YayMe: evaluation and execution are not the same thing
13:11:27 <mcstar> seq is a built-in
13:11:29 <mcstar> you cant define it
13:11:32 <monochrom> perhaps, you would use haskell in a python project, and python in a haskell project, just to be a rebel
13:11:33 <zacts> ok
13:11:33 <jmcarthur> YayMe: that's why your idea for (>>) doesn't really make sense to us
13:11:34 <singpolyma> Is there a way to tell using CPP and cabal when cabal is building with tests enabled?
13:11:47 <YayMe> right, but is there any such similar one that executes?
13:11:49 <srhb> zacts: If you have concrete quesitons about language differences, feel free to ask them. But please keep them oncrete. :)
13:11:57 <srhb> zacts: Otherwise it's just off-topic.
13:11:59 <zacts> sure, ok
13:12:06 <jmcarthur> YayMe: you could use unsafePerformIO, but that would be specificly for IO
13:12:07 <dmwit> mcstar: You can define type-restricted versions of it.
13:12:10 <YayMe> mcstar: makes sense. I couldn't imagine how to define such..
13:12:10 <jmcarthur> *specifically
13:12:11 * geekosaur wonders what an island has to do with it
13:12:31 <YayMe> jmcarthur: that makes sense.. basically it's the layering that screws me right?
13:12:33 <mcstar> dmwit: i think you have to use unsafe* to define seq
13:12:38 <jmcarthur> mcstar: class Seq a where seq :: a -> b -> b   -- just can't do it for things like functions
13:12:45 <YayMe> you'd lose all purity if one monad could just be dissolved
13:12:47 <jmcarthur> YayMe: "layering" is not the point here
13:12:55 <dmwit> mcstar: Not for all types. For some types it's very easy to write seq.
13:12:57 <jmcarthur> YayMe: nor is "dissolving"
13:13:02 <mcstar> jmcarthur: im not talking about its type sig, im talking about what it does
13:13:08 <dmwit> e.g. seqList :: [a] -> [a]; seqList [] = []; seqList (x:y) = x:y
13:13:09 <jmcarthur> YayMe: the point is that a monad is *meaningless* in the absense of its interpretation
13:13:18 <jmcarthur> YayMe: to interpret it, a function must understand it
13:13:20 <dmwit> or rather seqList xs@(_:_) = xs
13:13:29 <jmcarthur> YayMe: seq does not understand its arguments
13:13:39 <YayMe> right..
13:13:41 <jmcarthur> (except in the magical way that it evaluates one of them)
13:13:52 <croikle> flebron_: you can just use getContents or interact in many situations
13:13:53 <zacts> how can you program without functions that produce side effects, don't you at some point have to produce side effects?
13:13:56 <jmcarthur> mcstar: pattern matching would be the usual way to do it
13:14:00 <dmwit> Wow, I'm all over the place today.
13:14:09 <ski> zacts : "effects" is not "side effects"
13:14:09 <dmwit> seqList xs y = case xs of [] -> y; _:_ -> y
13:14:34 <jmcarthur> zacts: we have effects, just not side effects (except for a couple that we pretend are not side effects, like nontermination)
13:14:36 <ski> zacts : we do have I/O effects, just no I/O *side*-effects
13:14:52 <zacts> ah ok
13:15:08 <mcstar> dmwit: ok, but a general seq, that works on every value constructor, can be defined within the language?
13:15:21 <flebron_> croikle: The issue is that depending on what I read in the first line, I'll read more lines.
13:15:28 <jmcarthur> mcstar: about the only thing you can't define it for is functions
13:15:28 <ski> zacts : the difference is that something that can do I/O effects must have a type that reflects this fact, i.e. involving `IO' (or a type defined in terms of it)
13:15:37 <dmwit> mcstar: No. Hence my comment about "type-restricted".
13:15:45 <flebron_> The standard way to give a list in a programming competition is you give the length n, and then an element for each of the next n lines.
13:16:01 <ski> zacts : an expression of type `Int' can never express I/O effects, while an expression of type `IO Int' can
13:16:10 <jmcarthur> mcstar: it turns out that functions are also the most questionable part of seq anyway, so there are some good arguments that a type class is really the way to go
13:16:11 <zacts> ok
13:16:18 <srhb> flebron_: replicateM n getLine?
13:16:30 <flebron_> Yeah, but that's IO, and replicate wants String -> String.
13:16:36 <jmcarthur> mcstar: but a type class is more awkward since it requires a constraint in the context that you use it
13:16:40 <flebron_> (I did sequence (replicate n readLn)
13:16:48 <srhb> flebron_: hence replicateM
13:16:50 <srhb> Ah
13:16:50 <zacts> neat, well I'll for sure check out haskell once I finish this python course.
13:16:51 <mcstar> jmcarthur: ok, lets exclude functions, can you write 1 seq function that works on all value constructors? or you'd need typeclasses for each one?
13:16:51 <jmcarthur> flebron_: replicateM
13:16:53 <jmcarthur> ah
13:16:56 <dmwit> replicateM n = sequence . replicate n
13:16:56 <flebron_> haha
13:17:00 <srhb> >_>
13:17:01 <ski> zacts : so, we separate, by types, things that may do I/O from things that mayn't -- being *explicit* (in the interface/type) about this is what makes this "I/O effects", rather than "I/O side-effects"
13:17:02 <jmcarthur> mcstar: you still need type classes
13:17:03 <YayMe> jmcarthur: ah! So I *could* implement such but it couldn't be made generic! (m>>) m e = case m of Just x -> Right x; Nothing -> Left "Nothing :("
13:17:09 <ski> (the "side" is eliminated)
13:17:18 <YayMe> because the context is necessary of the particular monad
13:17:27 <jmcarthur> YayMe: yeah you could make a type class or something
13:17:31 <ski> zacts : does that help?
13:17:31 <mcstar> :t seq
13:17:37 <zacts> yes thanks ski
13:17:41 <croikle> flebron_: you can do the processing on the String, and not deal with IO, as long as you don't need to intersperse output to get more data
13:17:50 <srhb> flebron_: I don't understand quite what you're saying then.
13:17:54 <jmcarthur> YayMe: depending on the semantics you expect it to have, it might have be a multiparam type class or something
13:17:56 <lambdabot> a -> b -> b
13:18:09 <mcstar> jmcarthur: so, this built in seq, without mentioning typeclasses, cant be defined within the language, is that correct?
13:18:09 <dmwit> mcstar: No, you can't write a generic seq in the language. I think I've said this at least twice now.
13:18:17 <mcstar> dmwit: ok, thanks
13:18:20 <mcstar> jmcarthur: thanks
13:18:23 <jmcarthur> mcstar: as far as i know, correct
13:18:24 <YayMe> jmcarthur: thanks, it makes sense now
13:18:29 <srhb> flebron_: If you just want all lines until the end, just ls <- lines <$> getContents
13:18:43 * hackagebot hspec 1.4.5 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.4.5 (SimonHengel)
13:18:45 * hackagebot hspec-meta 1.4.5 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.4.5 (SimonHengel)
13:18:53 <flebron_> int main() { int n; while(cin >> n) { list<int> nums; for(i = 0; i < n; ++i) { int x; cin >> x; nums.push_back(n); } cout << func(nums); }}
13:18:54 <srhb> flebron_: If you only want n of those, then take n of them.
13:18:58 <flebron_> That's the sort of thing I'm doing.
13:18:59 <ski> zacts : you could say roughly, that "side-effects" are any deviation from the expression evaluating to a (single) value
13:19:00 <srhb> I can't read C
13:19:02 <flebron_> Read an n.
13:19:07 <flebron_> Read n next lines.
13:19:12 <YayMe> we all put things into and take things out of monads all the time, the transformation from one monad to another is not difficult; but it must be strictly typed.
13:19:12 <srhb> n <- readLn
13:19:14 <flebron_> Call a function with what you just read.
13:19:22 <srhb> ls <- take n . lines <$> getContents
13:19:25 <flebron_> Do this over and over.
13:19:29 <flebron_> Yes, I know how to do this once.
13:19:30 <YayMe> there's no way to genericize such (other than through the use of transformers)
13:19:30 <srhb> map yourFun ls
13:19:33 <flebron_> What if there is no more n?
13:19:41 <jmcarthur> YayMe: well, for example, i think you will have trouble writing your version of (>>) for IO without unsafePerformIO
13:19:45 <YayMe> which isn't quite the same thing because they're their own monad
13:19:45 <srhb> > take 9 [1]
13:19:47 <lambdabot>   [1]
13:19:50 <flebron_> An input could be 2 1 1 3 1 1 1
13:20:00 <srhb> flebron_: are those on their own line?
13:20:05 <flebron_> Yes.
13:20:08 <flebron_> Each is a separate line.
13:20:14 <YayMe> jmcarthur: exactly. that point is what made me realize it's all dependent.
13:20:15 <srhb> And you are told there are n lines
13:20:18 <flebron_> No.
13:20:25 <srhb> OK, then lines <$> getContents
13:20:27 <flebron_> I am told, for each test case, that I will read a n, and then n lines.
13:20:38 <ski> zacts : because `getLine' evaluates to an `IO'-action (that when executed for effects will compute a `String'), and not to a `String', the I/O-effects of the computation are *incorporated* in the result value of `getLine' (which is an `IO'-action), instead of "happening on the side"; as would be the case with `gets()' in C
13:20:38 <srhb> loop around?
13:20:38 <flebron_> There will be multiple test cases.
13:20:47 <srhb> flebron_: Right, so you just start over for each new n
13:20:48 <flebron_> ??
13:20:55 <flebron_> What if there _is_ no n?
13:21:07 <mcstar> is _no_
13:21:11 <flebron_> (Say, read 3 1 1, and then there are no further test cases.)
13:21:12 <ag90> flebron_: forever $ (read N and test case here)
13:21:19 <flebron_> That will fail.
13:21:20 <croikle> cases (x:xs) = p : cases q where (p,q) = splitAt x xs
13:21:25 <flebron_> Because reading n wil f ail.
13:21:29 <srhb> flebron_: Could you make a concise specification of your data?
13:21:29 <flebron_> *will fail.
13:21:36 <flebron_> One or more test cases.
13:21:45 <srhb> Yeah, so?
13:21:48 <flebron_> Each test case is a line with a number n, and then n lines with one number each.
13:21:54 <flebron_> That's it.
13:22:02 <srhb> You juts said "what if n isn't there!"
13:22:03 <zacts> ski: interesting.
13:22:05 <flebron_> ...
13:22:12 <flebron_> That's because you've processed the last test case.
13:22:24 <flebron_> n <- readLn will fail, because you've reached the end of the input.
13:22:31 <flebron_> There is no more input to read.
13:22:34 <flebron_> No input is there to be rad.
13:22:35 <flebron_> *read.
13:22:49 <srhb> So all you want is "how do I check if stdin is EOF?"
13:22:51 <ag90> loop h = eof <- hIsEOF h >> unless eof (doStuff >> loop h)
13:23:01 <sellout> flebron_: So handle isEOFError?
13:23:03 <ag90> Oh wait I mixed up my syntax there
13:23:05 <flebron_> In a non shitty way, yes, which is what the stack overflow link I posted above wrote :)
13:23:11 <flebron_> http://stackoverflow.com/questions/9754794/read-until-end-of-stream-in-haskell
13:23:44 <srhb> You want to test for EOF without testing for EOF?
13:23:50 <srhb> Sorry. :-)
13:24:06 <YayMe> srhb: It's not hard, you just test for reverse . FOE instead
13:24:07 <ski> zacts : of course, in one sense, this is "all a trick", since presumably the Haskell code compiles to machine code that operates through side-effecting memory -- however, the *point* is that this makes a real difference at the level of the source Haskell code : it makes it easier to reason about and refactor Haskell code than corresponding code in some language with side-effects
13:24:20 <flebron_> Catching exceptions is what I would count as "a shitty way".
13:24:48 <sellout> flebron_: But checking hIsEOF is not catching exceptions.
13:24:52 <srhb> hIsEof stdin is not catching exceptions
13:25:09 <flebron_> isEOFError is
13:25:22 <sproingie> ski: yep even modern C compilers are getting closer to functional idiom with SSA
13:25:35 <srhb> flebron_: I didn't see that suggestion
13:25:43 <sellout> flebron_: But checking hIsEOF lets you avoid isEOFError.
13:26:06 <ski> zacts : so, one of the most important consequences of using monads to model effects in Haskell is that we can know when we're *not* using an effect (because we're not using a monad encoding that effect -- and we can know this just by looking at the types of the code in question)
13:26:14 <augur> ski!
13:26:24 <ski> augur : syn ack
13:26:30 <augur> :)
13:26:32 <croikle> better to stay out of IO, in my opinion.
13:26:36 <YayMe> Can you stack Maybe and IO to do something like have an hIsEOF turn your Just handle into Nothing ?
13:26:43 <ski> croikle : if you can reasonably do so, yes
13:26:44 <YayMe> does that even make sense?
13:26:56 <ag90> YayMe: Monad transformers
13:27:00 <augur> ski: im leaving soon, but we really should talk more. also, i got this relational datamining book by dzeroski
13:27:08 <augur> im going to scan it, since its not available anywhere online
13:27:22 <YayMe> ag90: I get that, but I've not really used any of them, my curiosity is more along the lines of "Is this a monad transformer already and does it make sense"
13:27:39 <ag90> YayMe: EitherT is often used for error handling like that
13:27:46 <dmwit> YayMe: MaybeT exists.
13:28:05 <ski> sproingie : *nod* (though i was expressly talking about machine code)
13:28:32 <ski> (and : single *static* assignment is still different from single *dynamic* assignment)
13:29:01 <YayMe> dmwit: Would my example be a rational case? Working with a Just Handle that on hIsEof becomes Nothing to halt the rest of the function (by getting to the bottom which loops back onto itself for a pattern match against Nothing or some such)
13:29:02 <ski> @unmtl MaybeT IO String
13:29:02 <lambdabot> IO (Maybe String)
13:29:54 <dmwit> YayMe: That sounds a bit odd, though I guess with a bit of work you could code it up.
13:30:14 <dmwit> I haven't really been following along, so perhaps I shouldn't be trying to give advice.
13:30:15 <YayMe> I'm happy working with monads now, but I guess I need to start working with monad transformers next..
13:30:43 <ag90> YayMe: The Monad Transformers chapter in RWH is great for that IMO
13:30:46 <YayMe> dmwit: nah, that's reasonable advice. I figured it seemed odd but iduno
13:30:49 <johnw> YayMe: transformers are fun
13:31:20 <srhb> YayMe: Isn't the result of what you're saying claiming that you can make a function that has a type :: Maybe Handle? Witout unsafePerformIO?
13:31:41 <srhb> (that queries the state of the handle)
13:31:41 <jmcarthur> YayMe: there is a MaybeT transformer
13:32:05 <jmcarthur> YayMe: MaybeT IO a == IO (Maybe a)
13:32:44 * ski isn't sure what YayMe is wanting ..
13:32:45 <srhb> Though I suppose that's actually safe to do.. Since once there's EOF it can never be un-EOF'ed.
13:32:54 <srhb> Well
13:32:57 <srhb> Not SAFE-safe :P
13:33:04 <YayMe> srhb: you can't have a Maybe Handle? How about: blargh = do hdl <- stdout; return someFuncThatTakesMaybeA (Just hdl)
13:33:07 <jmcarthur> YayMe: so if you have an IO action    maybeReadLn :: IO (Maybe String)   that would be equivalent to   maybeReadLn :: MaybeT IO String
13:33:19 * ski thinks this "safe" terminology isn't really that good
13:33:30 <ski> (safe wrt which considerations ?)
13:33:39 <srhb> ski: Sure, you just prop (SAFE-)^n in front of things and everything makes sense.
13:34:01 <srhb> YayMe: I don't understand that. What's stdout?
13:34:05 <ski> i don't think it's a commutative monoid (if it's a monoid)
13:34:10 <YayMe> srhb: it's a Handle
13:34:22 <YayMe> err, an IO Handle
13:34:33 <YayMe> :t stdout
13:34:34 <srhb> YayMe: Then that function is IO something.
13:34:34 <lambdabot> Not in scope: `stdout'
13:34:57 <geekosaur> :t stdOut
13:34:58 <ski> @type System.IO.stdout
13:34:58 <lambdabot> Not in scope: `stdOut'
13:34:59 <lambdabot> GHC.IO.Handle.Types.Handle
13:35:05 <YayMe> srhb: in blargh = do hdl <- stdout; hdl is IO Handle, not Handle?
13:35:06 <geekosaur> ah, right
13:35:18 <ski> YayMe : no, `hdl' has type `Handle' there
13:35:21 <srhb> YayMe: No
13:35:30 <geekosaur> hdl is Handle, but remember what that really means
13:35:35 <ski> YayMe : .. except that code is actually type-incorrect
13:35:38 <srhb> Indeed.
13:35:40 <geekosaur> and that, yes
13:35:42 <ski> (`stdout' isn't an `IO'-action)
13:37:07 <YayMe> ski: you just said in my example it would be IO Handle not Maybe Handle, but if hdl is Handle, then Just hdl is Maybe Handle correct? Perhaps I have a method that's :: Maybe Handle -> IO (), I could then give Just hdl to that and return the value, no?
13:37:13 <ag90> YayMe: To clarify, "hdl <- stdout" is incorrect because "stdout" is not an IO action. It's a Handle. (hPutStrLn stdout "foo") is an IO action (IO () specifically).
13:37:42 <YayMe> oh oops
13:37:44 <ski> YayMe : "it" being ?
13:38:01 <ski> "if hdl is Handle, then Just hdl is Maybe Handle correct?" -- yes
13:38:26 <ski> "Perhaps I have a method that's :: Maybe Handle -> IO (), I could then give Just hdl to that" -- yes
13:38:29 <YayMe> ski: if stdout is IO Handle (whic it's not) in my example, hdl would be Handle not IO Handle, correct?
13:38:40 <ski> YayMe : correct
13:39:11 <monochrom> "hdl <- return stdout" would be fine
13:39:13 <croikle> flebron_: http://hpaste.org/84179 might be a reasonable way to parse your input
13:39:22 <ski> (but it would probably be nicer to argue non-contra-factually, if possible)
13:39:52 <flebron_> I ended up doing done <- isEOF  when (not done) (do .... main)
13:40:23 <srhb> flebron_: That's what we were trying to fail, but I guess we didn't communicate it very well.
13:40:37 <srhb> flebron_: "fail?".. freudian. "convey" :P
13:40:51 <flebron_> You perhaps did, I had just found that solution on SO way before (when I posted the link :p)
13:40:58 <YayMe> ski: I get that, but I'm also a lot less bright than I might appear heh
13:41:16 <srhb> flebron_: I got confused about that when you started talking about exceptions. Glad you solved it anyway.
13:41:33 <ski> (no comment)
13:41:57 <srhb> YayMe: As far as I can tell, this started out with you wanting to do something that starts with do { eof <- isEOF; if eof then ...? else ...? }
13:42:19 <srhb> YayMe: And then you wanted a function in there that gave you Just stdin on True and Nothing on False.
13:42:29 <srhb> YayMe: And... Then what?
13:43:51 <srhb> I might also be misunderstanding you completely, I guess. I don't know where this is going. :P
13:44:17 <tsinnema> newbie question: i'm not sure i understand what "(->) (,)" means in "instance Braided (->) (,)". might someone hand me a clue?
13:44:45 <ag90> :t (,)
13:44:47 <lambdabot> a -> b -> (a, b)
13:44:48 <ski> tsinnema : `Foo -> Bar' is infix syntax for `(->) Foo Bar' (which is the same as `((->) Foo) Bar')
13:44:54 <ski> compare with `Either Foo Bar'
13:45:14 <ski> `Either' is a type constructor, `(->)' is also a type constructor
13:45:25 <ski> tsinnema : .. er, but
13:45:59 <ski> tsinnema : in the `Braided (->) (,)' case, that's actually two separate arguments of `Braided' (you can think of it as `(Braided (->)) (,)')
13:46:27 <Sando> hey everyone... I'm trying to install the Haskell Platform in a shared hosting environment but can't satisfy the OpenGL dependency. Is there a way to install the platform without opengl support? Thanks for your help...
13:46:33 <ski> so, apparently `Braided' is a multiparameter type class (MPTC), where both parameters are to be type functions with two arguments
13:46:33 <YayMe> srhb: I'm thinking about a function like processEachLine Nothing = (); processEachLine (Just hdl) = hIsEof hdl >>= \x -> if x then processEachLine Nothing else processLine hGetLine hdl >> processEachLine (Just hdl)
13:46:49 <srhb> YayMe: That's a type error
13:47:00 <YayMe> srhb: Probably. but does the idea translate?
13:47:03 <tsinnema> ok thanks ski and ag90
13:47:17 <ski> tsinnema : similarly, the type `(Foo,Bar)' is just syntactic sugar for `(,) Foo Bar', iow `((,) Foo) Bar'
13:47:29 <srhb> YayMe: Hm, no, not really. All I see is the type error. :P Sorry.
13:47:58 <YayMe> srhb: haha that's ok, I've gotten used to the strictness of the mental parsers all you haskellers have..
13:48:02 <srhb> To me it seems like, undearneat what you're saying, thjere's an unsafePerformIO :P
13:48:19 <ski> YayMe : possibly you meant `return ()' instead of `()' in the base case
13:48:47 <srhb> IN that case it's fine. But all you've done is convert Bool to Maybe.
13:49:00 <jmcarthur> YayMe: it's not just that. in the presence of a type error it's generally hard to tell what the intent is
13:49:07 <YayMe> srhb: No, I don't want an unsafe performIO, I want hIsEof to just become Nothing, because when a function acting in the Maybe monad get's Nothing, the rest of the function does nothing, which is useful in IO when the rest of your function might otherwise probe an EOF'd file
13:49:32 <jmcarthur> YayMe: by definition a type error usually implies an idea that hasn't been throughly explained
13:49:44 <jmcarthur> s/thoroughly/accurately/
13:49:53 <YayMe> jmcarthur: I get that, that's why the haskell compiler is so strict, it allows no ambiguity, and y'all are one with the language and see the ambiguities which I'm not aware of
13:49:54 * ski is working on getting a type error slicer integrates with the brain
13:49:56 <hpaste> ag90 pasted “What I think YayMe wants” at http://hpaste.org/84180
13:50:26 <YayMe> ag90: isn't that what I said?
13:50:28 <YayMe> haha
13:50:39 <YayMe> Probably not, but even I can't tell anymore
13:50:39 <ski> YayMe : it sounds like you possibly want the `MaybeT IO' monad
13:50:39 <ag90> Without the type errors (I hope) :)
13:51:03 <ag90> Oh, there's a type still. heh
13:51:10 <elliott> http://code.haskell.org/~dons/haskell-1990-2000/msg00029.html DMR complaints in 1990
13:51:19 <srhb> I still don't get it. You're still just converting Bool to Maybe Handle. Which, by the way, is a Handle you already have whether or not it's empty.
13:51:44 <hpaste> ag90 pasted “What he probably wants instead” at http://hpaste.org/84181
13:51:47 <YayMe> ski: I think so.. my whole question was about if my use of MaybeT IO made sense or was not the way most people would do it
13:52:40 * srhb butts out because she's obviously not getting it :P
13:52:47 <ski> YayMe : `MaybeT m' is to be used when you want `m'-actions, but also the ability for an action to fail, aborting all the succedent actions
13:52:47 <YayMe> ski: Does my explanation of a reason for the behaviour I want seem reasonable or is there an altogether different approach of solving the "Halt IO, this handle is done" scenario that would be more common?
13:53:15 <hpc> elliott: my first thought was "that's a nice email; wonder how many minutes it took to send on a 1990 internet connection"
13:53:21 <srhb> unless isEof ...
13:53:39 <ag90> YayMe: You would probably use the MaybeT IO monad if you had actions that could fail. For example, you could implement nextLine :: MaybeT IO String that would return Nothing if there were no more lines.
13:53:42 <elliott> "As a final note, we believe that the efficiency we gain by the pattern
13:53:42 <elliott> binding typing law is far less substantial than the eventual
13:53:43 <elliott> complications to Haskell."
13:53:49 <srhb> woah
13:54:03 <YayMe> ag90: Right, and that wouldn't be odd or non-idiomatic you don't think?
13:54:36 <hpc> elliott: i don't think we ever actually hit any complications from that rule, did we?
13:54:42 <ski> YayMe : "I want hIsEof to just become Nothing, because when a function acting in the Maybe monad get's Nothing, the rest of the function does nothing, which is useful in IO when the rest of your function might otherwise probe an EOF'd file" sounds `MaybeT'-like
13:55:12 <elliott> hpc: depends if you consider persistent newbie and expert confusion complications :p
13:55:15 <ag90> YayMe: Not at all. Basically, operations with type MaybeT IO a say, "this function returns either Just a, or Nothing. If it returns Just a, get the 'a' and pass it over to the next operation. Otherwise, something went wrong. Stop executing this operation."
13:55:15 <srhb> It sounds like unless isEOF $ do ... to me :(
13:55:40 <ski> YayMe : but like srhb (and others) suggest, a `when' or `unless' wouldn't be unreasonable in the specific case of reading from a handle until EOF
13:55:40 <hpc> elliott: it's only a complication if you don't put type signatures on your top-level definitions
13:55:43 <YayMe> srhb and that would just be in the IO monad?
13:55:46 <hpc> in which event they deserve it ;)
13:56:00 <YayMe> :t unless
13:56:01 <lambdabot> Monad m => Bool -> m () -> m ()
13:56:12 <ag90> :t unlessM
13:56:13 <lambdabot>     Not in scope: `unlessM'
13:56:13 <lambdabot>     Perhaps you meant `unless' (imported from Control.Monad.Writer)
13:56:29 <elliott> hpc: except it applies in GHCi too.
13:56:30 <ag90> Too bad, it's unavailable. unlessM :: m Bool -> m ()  -> m ()
13:56:30 <ski> (hm, why `Control.Monad.Writer' ?)
13:56:36 <srhb> ski: No clue :P
13:56:43 <srhb> ag90: yeah that's what I meant.
13:56:56 <hpc> :t \p m -> do {b <- p; unless p m}
13:56:57 <lambdabot>     Couldn't match expected type `Bool' with actual type `m0 t0'
13:56:57 <lambdabot>     In the first argument of `unless', namely `p'
13:56:58 <lambdabot>     In a stmt of a 'do' block: unless p m
13:56:59 <monochrom> since you're already in IO, I suggest using exceptions instead of MaybeT!
13:57:01 <YayMe> ski: Yeah that makes sense, thanks. That get's to the heart of what I was looking for: An approach that was simpler than mine, acting under the assumption my approaches are (as of yet) never particularly idiomatic or simple
13:57:07 <hpc> :t \p m -> do {b <- p; unless b m}
13:57:09 <lambdabot> Monad m => m Bool -> m () -> m ()
13:57:18 <hpc> ag90: ^
13:57:26 <hpc> :t whileM
13:57:28 <lambdabot> Not in scope: `whileM'
13:57:33 <hpc> :t while
13:57:35 <lambdabot> Not in scope: `while'
13:57:39 <elliott> http://code.haskell.org/~dons/haskell-1990-2000/msg00108.html hahaha. this archive is gold
13:57:46 <ski> @. pl undo \p m -> do {b <- p; unless b m}
13:57:46 <lambdabot> (. flip unless) . (>>=)
13:59:07 <ag90> What
13:59:08 <ninjaaron> I'm interested in learning Haskell, but I get the impressoin it's for CS majors and math people, neither of which am I. Is there fun stuff to do with haskell as a hobbyist programmer?
13:59:22 <srhb> ninjaaron: _YES_
13:59:32 <monochrom> yes, a lot of hobbyists prefer haskell
13:59:36 <ski> @type flip ((=<<) . flip unless)  -- not particularly nice
13:59:37 <lambdabot> Monad m => m Bool -> m () -> m ()
13:59:52 <srhb> I'd venture a guess and say most of the people in this channel are hobbyists wrt. Haskell.
14:00:13 <elliott> "Now, with this decision made, a second EVEN MORE RADICAL proposal was
14:00:13 <elliott> put forth: eliminate list comprehension syntax in favor of something
14:00:13 <elliott> that looks like LET!"
14:00:21 <elliott> hm, is this the invention of do notation...?
14:00:31 <elliott> it uses "for". doesn't F# (or was it Scala) use "for" for do notation?
14:00:39 <ski> monad comprehensions ftw !
14:00:47 <elliott> (http://code.haskell.org/~dons/haskell-1990-2000/msg00270.html)
14:00:47 <monochrom> some people go into CS after and because of knowing haskell. some people don't even bother going into CS
14:01:18 <donri> ski: lens ftw! got rid of a lot of view patterns and monad comprehensions for me ;)
14:01:35 <tdammers> personally, I use haskell as a haven of sanity in the wild chaos that is programming for a living
14:02:48 <elliott> hmm, I use haskell as a haven of chaos...
14:03:30 <tdammers> ...in the utter sanity that is business programming?
14:03:50 <Taneb> That reminds me
14:03:53 <Taneb> I bought a book today
14:04:00 <Taneb> ...it's completely irrelevant
14:04:11 <monochrom> "use a 'let' notation" is not radical. Moggi did it 10 years before that message.
14:04:50 <ninjaaron> does haskell have good libraries for text parsing? I'm kind of a linguist, and lot of my programming involves processing text information.
14:04:54 <ski> which is "the ambiguity in the precedence of WHERE clauses" that is alluded to ?
14:04:58 <srhb> Sando: Another option is to just install the binary GHC package
14:04:58 <monochrom> where we say "m >>= \x -> blah", Moggi wrote "let x<-m in blah"
14:05:05 <srhb> Sando: I think that would be the easier route for you.
14:05:10 <Taneb> ninjaaron, yes, very very much so
14:05:21 <Taneb> @hackage parsec
14:05:21 <lambdabot> http://hackage.haskell.org/package/parsec
14:05:22 <no-n> what's haskell for printf("I am %d years old", 5); ?
14:05:23 <srhb> Sando: And you really lose nothing and gain a lot from doing so.
14:05:29 <srhb> no-n: That
14:05:34 <no-n> :D
14:05:44 <srhb> Though I'm no big fan of printf myself.
14:05:51 <Taneb> no-n, "import Text.Printf; printf "I am %d years old" 5"
14:05:56 <ski> > printf "I am %d years old" 5              :: String
14:05:58 <lambdabot>   "I am 5 years old"
14:06:00 <Eduard_Munteanu> > printf "I am %d years old" 5
14:06:01 <lambdabot>   Ambiguous type variable `a0' in the constraints:
14:06:01 <lambdabot>    (GHC.Show.Show a0)
14:06:01 <lambdabot>     ...
14:06:06 <no-n> ah
14:06:14 <monochrom> with that in mind, (>>=), list/monad comprehension, and do-notation are the radical ones
14:06:15 <srhb> I would prefer being explicit about it.
14:06:21 <ag90> :t printf
14:06:23 <lambdabot> PrintfType r => String -> r
14:06:23 <no-n> is there a newer or more haskelly or standard way to do str formatting?
14:06:25 <ski> > "I am " ++ show 5 ++ " years old"
14:06:28 <lambdabot>   "I am 5 years old"
14:06:47 <donri> no-n: i like the interpolatedstring-perl6 package for that sort of thing. there are many similar packages. HoleyMonoid is interesting too
14:06:55 <ski> "string interpolation" might be nice, i suppose
14:06:55 <ninjaaron> Alright, thanks for the infor guys!
14:07:02 <elliott> http://code.haskell.org/~dons/haskell-1990-2000/msg00124.html lots of syntax talk.
14:07:08 <Sando> srhb: I have GHC installed. Are you saying that once I have this I can get around installing the platform? how so?
14:07:13 <srhb> Sando: Yes!
14:07:16 <ski> ninjaaron : you're welcome to ask more questions in here :)
14:07:19 <no-n> okay
14:07:37 <srhb> Sando: Assuming you have cabal already (which is bundled with the binary package) you can just cabal install whatever libraries you need.
14:08:01 <ninjaaron> ski: thanks, I will.
14:08:10 <ninjaaron> but not now.
14:08:32 <Sando> srhb: cool...thanks! I'll go try that now
14:08:44 <jmcarthur> one last try. anybody feel like trying some type hackery?   http://hpaste.org/84172
14:08:55 <srhb> Sando: If you don't have cabal, I'll assume you got GHC from some weird place. :-)
14:08:57 <donri> Sando: also for a shared host you might want to precompile your stuff and deploy binaries. that would also mean that a haskell environment usually wouldn't be required on the server
14:09:16 <elliott> jmcarthur: hah, yikes
14:09:43 <elliott> jmcarthur: don't you just need instance (MonadTrans (P rs), Monad (P rs m)) => MonadTrans (P (r ': rs)) where?
14:09:49 <elliott> since you don't get a forall constraint or anything
14:10:13 <Sando> srhb: some weird place like the ghc website? :)
14:10:21 <srhb> Sando: No, that's the good place :-)
14:10:25 <elliott> jmcarthur: perhaps you can write a proof term all_p_monad :: Monad m => (Monad (P rs m) => r) -> r by induction or such and use that in the instance, but this seems simpler
14:10:28 <Sando> donri: thanks, i'll keep that in mind
14:10:43 <jmcarthur> elliott: the m isn't available in that scope
14:10:44 <srhb> On that note, I'm wondering if the big fat warning to not get GHC but instead Haskell PLatform on haskell.org is not a really bad idea.
14:10:45 <monochrom> the GHC website will not give you cabal
14:10:51 <srhb> It won't?
14:10:54 <elliott> jmcarthur: oh, hmm, right
14:11:01 <monochrom> at least, not cabal-install
14:11:11 <elliott> jmcarthur: then perhaps the proof term approach is more viable
14:11:27 <srhb> monochrom: Yes it will.
14:11:28 <jmcarthur> i've been trying such approaches
14:11:42 <elliott> jmcarthur: you could also write class MonadTrans t => MonadTrans' t where witness :: Monad m => (Monad (t m) => r) -> r
14:11:52 <donri> srhb: the ghc binary does not include cabal-install, no
14:11:57 <elliott> and gives instances for P, and then use witness in your MonadTrans instances.
14:11:58 <srhb> Or at least I thought that's how I got cabal-install.
14:12:00 <donri> binary distribution*
14:12:00 <srhb> Hm.
14:12:07 <srhb> Sando: OK, I lied to you, apparently.
14:12:12 <monochrom> do not think. perform an experiment.
14:12:13 <srhb> Sando: You need to get cabal-install as well, seperately.
14:12:20 <jmcarthur> elliott: i've been trying various things with Data.Constraint without success yet
14:12:28 <srhb> monochrom: I thought I had, but clearly I've forgotten.
14:12:29 <Sando> srhb: lol...thats ok. I'll get it
14:12:35 <elliott> jmcarthur: I don't think you need to go that far. let me have a try. btw, any reason you're not using a gdat instead?
14:12:39 <elliott> *gadt
14:12:44 <jmcarthur> elliott: both have the same problem
14:12:53 <jmcarthur> gadt or data family
14:13:07 <jmcarthur> elliott: data families have the one benefit that they don't have the runtime cost (since they are newtypes)
14:13:21 <jmcarthur> but until the type stuff is worked out i am willing to sacrifice that
14:13:28 <elliott> @tell chrisdone bug report: hpaste "view raw link" shows older revision. see e.g. http://hpaste.org/84172
14:13:28 <lambdabot> Consider it noted.
14:14:07 <Xaratas> ups
14:14:53 <hpaste> jmcarthur annotated “wondering how to best do this crazy thing” with “yes, the same problem comes up with GADTs” at http://hpaste.org/84172#a84184
14:15:00 <Xaratas> tail recursion is nice, but doing a stackoverflow with it , i think thats not the correct way of using this
14:15:19 <srhb> Xaratas: Hm?
14:15:36 <Xaratas> Stack space overflow: current size 8388608 bytes.
14:16:11 <Xaratas> all i have done was shifting a result of a recursion fully to an function argument
14:16:47 <srhb> Xaratas: Have you read the wiki page on stack overflows?
14:17:06 <srhb> @where wiki stack overflow
14:17:06 <lambdabot> I know nothing about wiki.
14:17:07 <Xaratas> there is one? no i havnt
14:17:09 <croikle> the accumulator gets unevaluated thunks, which causes the overflow
14:17:10 <srhb> http://www.haskell.org/haskellwiki/Stack_overflow
14:17:15 <elliott> jmcarthur: not averse to using GADTs as part of a solution, right?
14:17:17 <srhb> It's very well explained there.
14:17:32 <jmcarthur> elliott: not averse, just *hoping* to avoid the runtime cost
14:18:20 <plhk> does something like readChanWithTimeout :: Chan a -> Int -> IO (Maybe a) exist?
14:18:47 <srhb> plhk: http://hackage.haskell.org/packages/archive/synchronous-channels/0.1/doc/html/Control-Concurrent-Chan-Synchronous.html#7 ?
14:19:11 <srhb> Hmm, where's the timeout.
14:19:33 <ski> @wiki Stack overflow
14:19:33 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
14:19:45 <srhb> ski: Thanks
14:19:56 <srhb> plhk: Nevermind me.
14:20:05 <ski> @wiki This is a dream
14:20:05 <lambdabot> http://www.haskell.org/haskellwiki/This_is_a_dream
14:20:24 <Heffalump> @wiki Side effects rule
14:20:24 <lambdabot> http://www.haskell.org/haskellwiki/Side_effects_rule
14:20:34 <hpaste> elliott annotated “wondering how to best do this crazy thing” with “wondering how to best do this crazy thing (annotation)” at http://hpaste.org/84173#a84185
14:20:36 <elliott> jmcarthur: here's a thing.
14:20:41 <elliott> I believe you can eliminate the additional class.
14:21:12 <lispy> jmcarthur: If I had to guess it's because the instance of Monad (P '[] ms) and Monad (P (r ': rs) ms) have different kind than Monad (P rs ms)
14:21:59 <jmcarthur> elliott: nice! you are a gentleman and a scholar
14:22:20 <elliott> nobody deserves praise for such an ugly hack :P
14:22:30 <jmcarthur> lispy: that would surprise me since P constrains the kind
14:22:41 <elliott> MonadTrans really ought to include that "witness". too bad it's a pain to use.
14:23:01 <lispy> jmcarthur: oh, good point
14:24:06 <jmcarthur> elliott: well, ugly or not, i'm running with it. it's less ugly than some of the other thing i tried
14:24:09 <jmcarthur> *things
14:24:19 <jmcarthur> i'll attempt to pretty it up a bit
14:24:35 <elliott> jmcarthur: I think something like:
14:24:47 <svend> can anyone ELI5 monads? it seems confusing from the documentation :/
14:24:48 <elliott> jmcarthur: newtype P rs m a = P { runP :: ReaderT (HList rs) m a } would be better.
14:25:04 <elliott> svend: learn haskell (by reading a tutorial like learn you a haskell, say) and don't worry about it.
14:25:22 <jmcarthur> elliott: this isn't the actual type i need
14:25:23 <elliott> they're not scary, they just need haskell experience to appreciate. any good tutorial will get to them in time (and they're overhyped)
14:25:28 <jmcarthur> i simplified it for the question
14:25:31 <elliott> you might also find the typeclassopedia a good read, but probably later:
14:25:33 <elliott> @where typeclassopedia
14:25:33 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
14:25:57 <svend> can I use mondads for addition of multiple numbers?
14:26:23 <ski> > zipWith (+) [1,2,3] [100,200,300]
14:26:25 <lambdabot>   [101,202,303]
14:26:25 <elliott> um.
14:26:28 <ski> > liftM2 (+) [1,2,3] [100,200,300]
14:26:29 <srhb> The mere prospect of the answer was scary.
14:26:29 <lambdabot>   [101,201,301,102,202,302,103,203,303]
14:26:31 <srhb> Monad overload.
14:26:33 <lispy> > do x <- [1..3]; y <- [4..6]; return (x + y)
14:26:34 <lambdabot>   [5,6,7,6,7,8,7,8,9]
14:26:42 <srhb> Best troll ever.
14:26:42 <srhb> :P
14:35:20 <tac_> Is there a standard library operator for flip id?
14:35:29 <tac_> like F#'s |> (iirc)
14:35:37 <monochrom> no
14:35:47 <monochrom> but perhaps lens has one
14:36:26 <monochrom> lens has cameras, microscopes, and your kitchen sink :)
14:36:26 <ion> tac: (&) in lens
14:36:33 <monochrom> QED!
14:36:36 <tac_> neat
14:36:37 <tac_> thanks
14:46:07 <mwc> It was just pointed out to me that map can be considered zipWith1 and repeat as zipWith0 in the family of functions zipWithN :: (a1 -> ... -> an -> z) -> [a1] -> ... -> [an] -> [z]
14:46:34 <ski> yes
14:46:43 <ski> this is the `ZipList' applicative functor
14:47:09 <mwc> yeah, just a connection I never really made. Interesting.
14:47:42 <ski> > getZipList (ZipList [(+),(*)] <*> ZipList [2,3] <*> ZipList [10,20])
14:47:44 <lambdabot>   [12,60]
14:48:14 <ski> > getZipList (liftA3 id (ZipList [(+),(*)]) (ZipList [2,3]) (ZipList [10,20]))
14:48:16 <lambdabot>   [12,60]
14:48:39 <ski> so `liftA3' here corresponds to `zipWith3'
14:49:41 <ski> > foldr (zipWith (:)) (repeat []) [[1,2,3],[4,5,6],[7,8,9]]
14:49:43 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
14:49:52 <ski> > foldr (liftM2 (:)) (return []) [[1,2,3],[4,5,6],[7,8,9]]
14:49:53 <lambdabot>   [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2...
14:53:05 <jmcarthur> elliott: it is truly ugly, but it's working for my real problem too, fyi
14:53:28 <elliott> jmcarthur: if it's any consolation, you might be able to make it less ugly by having a typeclass on "rs" instead
14:53:42 <jmcarthur> that is what i did
14:53:45 * hackagebot base58address 0.1 - Parsing and serialization for Base58 addresses (Bitcoin and Ripple)  http://hackage.haskell.org/package/base58address-0.1 (StephenWeber)
14:53:48 <quchen> When I'm using Type(..), *all* data constructors are exported. Is there some way of exporting "all but"?
14:53:54 <srhb> quchen: No.
14:54:08 <simpson> You can export specific constructors, can't you?
14:54:14 <simpson> Like, a whitelist, not a blacklist.
14:54:25 <quchen> simpson: Well, I have 12 of them. A blacklist would be shorter. ;-)
14:54:39 <simpson> quchen: Only twelve? That's not too much typing.
14:55:18 <quchen> simpson: I think it makes sense in my context.
14:55:22 <Xaratas> oh, beutiful, no stackoverflow anymore, now its a out of memory
14:55:34 <quchen> It's basically a tuple of API functions.
14:55:34 <srhb> Xaratas: Did the article help?
14:55:56 <Xaratas> a bit, it has told me why it comes to the stackoverflow
14:56:16 <srhb> Xaratas: Great. :)
14:57:07 <Xaratas> but my try to use ($!) results in "i take a bit of ram, because i need it" (it takes then all bits of ram)
14:59:31 <Xaratas> fail
14:59:37 <srhb> Xaratas: Hm?
14:59:59 <Xaratas> its only an "out of memory" because i changed the order of the parameter
15:00:14 <Xaratas> and the out of memory just occours first
15:00:26 <srhb> I'm not sure what you're doing.
15:00:44 <Xaratas> i post it
15:02:22 <hpaste> Xaratas pasted “tail recursive try” at http://hpaste.org/84186
15:08:17 <Nolrai_25> So ghc is telling me that: "System" is a member of the hidden package `haskell98-2.0.0.1'. Should I un hide haskell98?
15:08:23 <srhb> No
15:08:32 <srhb> You should import the Haskell 2010 version of the module. :)
15:08:36 <Nolrai_25> I just want to be able to get comand line arguemnts.
15:08:38 <srhb> What functions are you trying to get at?
15:08:42 <srhb> System.Environment, I believe.
15:08:46 <srhb> @index getArgs
15:08:46 <lambdabot> System.Environment
15:08:48 <srhb> Yep.
15:08:57 <Nolrai_25> Okay. Thought I was going nuts there..
15:09:07 <srhb> Just an outdated tutorial, I'm afraid.
15:10:54 <Nolrai_25> I should remember @Index.
15:11:01 <srhb> It's flaky at best.
15:11:20 <srhb> Nolrai_25: You should remember hoogle instead
15:11:23 <srhb> @where hoogle
15:11:24 <lambdabot> http://haskell.org/hoogle
15:11:59 <srhb> Nolrai_25: And Hayoo once you move past the standard libraries.
15:13:37 <croikle> does (($!) (++) result shortlist) put the strictness in the right place? it might be simpler to use a bang pattern on result instead.
15:15:18 <srhb> croikle: What are you trying to do?
15:15:30 <croikle> just looking at Xaratas' paste
15:15:53 <Xaratas> hm, the bangpattern, i should read about it too
15:16:35 <croikle> nah, I think your $! will evaluate result first, you're okay
15:16:38 <srhb> Well, I don't think $! does what Xaratas thinks it does. It emphatically doesn't force the whole list
15:17:17 <croikle> true
15:19:37 <aCube> > foldl1 f [a,b,c,d]
15:19:38 <lambdabot>   f (f (f a b) c) d
15:19:47 <aCube> f> foldr1 f [a,b,c,d]
15:19:59 <aCube> > foldr1 f [a,b,c,d]
15:20:01 <lambdabot>   f a (f b (f c d))
15:20:54 <kyle__> if I made a function: "let ug _ 100 = []", wouldn't that mean any time the function ug was called with the second argument being 100, it would terminate, returning an empty array?
15:21:16 <srhb> kyle__: Empty list, yes, if that was the first equation for ug
15:21:43 <kyle__> srhb: Hum... Bceause it is, but with the second line it makes an infinte loop...
15:21:53 <srhb> kyle__: Then your problem is there.
15:22:07 <srhb> Or at least not in that line you gave here.
15:22:37 <kyle__> let ug l y = l:(ug l (y+1))
15:22:47 <srhb> What's the initial arguments?
15:23:12 <kyle__> srhb: I intended it for something else, but the problem boils down to that function being infinite, instead of terminating after 100.
15:23:17 <srhb> And what's the type of the second argument?
15:23:24 <srhb> It terminates _on_ 100 if it reaches it
15:23:30 <kyle__> srhb: integer?
15:23:36 <srhb> If 100 is skipped for whatever reason, it doesn't
15:24:31 <srhb> Oh, hang on
15:24:35 <srhb> Seperate let bindings for each of them?
15:24:42 <srhb> Then you're shadowing the first one
15:24:44 <kyle__> srhb: If I start it ug 1 1, it recurses forever.  I think I"m making some insanely stupid error, I can't put my finger on it.
15:24:51 * kyle__ facepalms
15:24:59 <srhb> I almost missed it, too.
15:25:11 <aCube> > let ug _ 100 = []; ug l y = l:(ug l (y+1)) in ug [] 1
15:25:13 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
15:26:00 <kyle__> srhb: Thank you.  I thought I REALLY forgot everything there for a minute.
15:26:10 <srhb> kyle__: :)
15:26:33 <srhb> kyle__: Throw a case in there and you're fine.
15:26:34 <HogNobbles> Is there any preference to using $ over parentheses? I prefer parentheses because I find them to be less ambiguous, but I could replace almost every instance of parentheses with a $. What's your opinion on this?
15:26:58 <srhb> HogNobbles: Whichever is more readable given the circumstances.
15:27:09 <srhb> HogNobbles: If you have a lot of composition, use . and $
15:27:55 <srhb> foo . bar . baz $ x over foo (bar (baz x)) and, I think, also over (foo . bar . baz) x, but the latter is a more personal preference I guess.
15:28:00 <HogNobbles> srhb, in that situation I prefer to put the composition in () because it's similar to the style used in mathematics.
15:28:12 <srhb> Personal preference then. :)
15:29:15 <HogNobbles> I guess I'll stick with my parentheses then :P.
15:29:33 <srhb> I don't see why not, it won't appear my reading of it at least. :-)
15:29:51 <srhb> impair*
15:31:11 <HogNobbles> That's good, I jut wanted to make sure the Haskell comunity wouldn't banish me for not using $ lol.
15:31:15 <HogNobbles> just*
15:32:40 <sarfraz> hi, I have a function of type a -> IO () that I want to map to a Maybe [a] value. Does someone have an idea?
15:32:44 <hpaste> Sarfraz pasted “map IO action over a mybe list” at http://hpaste.org/84187
15:32:55 <quchen> sarfraz: You can't do that.
15:32:58 <sarfraz> and here is some code
15:33:11 <quchen> You can't map IO away.
15:33:42 <quchen> Plus that code is not very easy to read. Could you make a minimal example?
15:33:45 <simpson> quchen: He was backwards with his terminology.
15:33:45 <sarfraz> o I see
15:35:11 <ab9rf> i'm confused
15:35:39 <hpaste> simpson revised “map IO action over a mybe list”: “If Nothing, do nothing!” at http://hpaste.org/84187
15:35:43 <simpson> sarfraz: ^^ ?
15:37:03 <sarfraz> that seems to work, thank you :)
15:37:21 <ab9rf> oh, i figured it out finally
15:38:03 <simpson> sarfraz: Do you understand what's going on there?
15:39:03 <sarfraz> You use pattern matching I think
15:39:15 <ab9rf> there's a function in Data.Maybe for that too, i thi
15:39:44 <simpson> Yes, there is, but I didn't want to fuss with types on such a long line.
15:39:50 <simpson> This code is *really* not pleasant to read.
15:39:57 <ab9rf> maybe
15:39:59 <ab9rf> :t maybe
15:40:00 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:40:17 <ab9rf> simpson: yes, agreed
15:41:36 <ab9rf> can't you just lift over the maybe monad?
15:41:50 <sarfraz> Is it so? I thought it was not so ugly. Maybe I should clean it up
15:45:39 <Nolrai_25> @hoogle (x, y) -> (y, x)
15:45:40 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
15:45:40 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:45:40 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
15:47:04 <sarfraz> just by curiosity, how would you lift it?
15:47:10 <HogNobbles> sarfraz, I think the code would be much easier to read if you simply put in some comments explaining what you're trying to accomplish.
15:49:09 <ab9rf> sarfraz: basically if you have Maybe a and you a function a -> t you fmap the function over the maybe to get a Maybe t
15:49:31 <croikle> what do we do with Maybe (IO ()) then?
15:49:34 <ab9rf> if you had a Nothing, you get back a (different) Nothing, and if you had a Just a, you get a Just t
15:49:49 <ab9rf> croikle: yeah, that's not really useful in this case
15:50:07 <croikle> sequence_ on that might work
15:50:20 <ab9rf> at least not without rewriting the function
15:50:46 <ab9rf> although the 'maybe' function from Data.Maybe will work in a fairly ugly way
15:51:40 <ab9rf> croikle: that's close at least
15:52:26 <ab9rf> hoogle suggest for_
15:53:23 <croikle> why not just mapM_ ?
15:53:27 <ab9rf> @hoogle Maybe t -> (t -> IO()) -> IO ()
15:53:27 <lambdabot> GHC.Conc.IO closeFdWith :: (Fd -> IO ()) -> Fd -> IO ()
15:53:27 <lambdabot> GHC.Conc closeFdWith :: (Fd -> IO ()) -> Fd -> IO ()
15:53:27 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
15:54:24 <croikle> you need the Data.Foldable mapM_ rather than the prelude, but it seems right
15:54:35 <ab9rf> croikle: yeah, the signature is right at least
15:56:12 <ab9rf> croikle: forM_ is just mapM_ with its arguments flipped
15:56:31 <croikle> yeah, whichever way is convenient
15:57:21 <ab9rf> sarfraz: often enough in haskell the best thing to do is figure out what the type signature is of whatever you're trying to do _first_
15:57:49 <ab9rf> in this case you have a Maybe t and a t -> IO() and you want an IO ()
16:01:03 <sarfraz> Ok, I did try what you said and it seems to work also
16:01:29 <sarfraz> thanks for the pointers, I will try to remember them
16:08:24 <ab9rf> often enough there's already someting that does what you want, which is whta hoogle is good for
16:08:29 <ab9rf> if not, you can always write it
16:10:39 <hpaste> johnny934759 pasted “create pure array from mutable operations” at http://hpaste.org/84192
16:12:27 <Nolrai_25> Has anyone here used CmdArgs? is it worth learning?
16:14:16 <johnny934759> what's a idiomatic way to handle creating multiple pure vectors with codependency?
16:14:33 <johnny934759> see http://hpaste.org/84192
16:14:41 <copumpkin> johnny934759: can you explain that more? I saw your paste but don't really get what you can't do?
16:15:48 <copumpkin> you want to create two mutable vectors in a single operation?
16:17:35 <johnny934759> copumpkin: yes, and convert them to pure afterwards without inside any monad
16:17:55 <johnny934759> copumpkin: is that possible?
16:18:03 <copumpkin> sure
16:19:14 <copumpkin> just writing up a sample
16:19:28 <johnny934759> ok
16:23:43 <hpaste> copumpkin pasted “frozen” at http://hpaste.org/84193
16:23:47 <copumpkin> johnny934759: that ^
16:25:34 <johnny934759> copumpkin: ah so I have to use ST monad explicitly
16:25:40 <johnny934759> copumpkin: thanks so much!
16:25:53 <copumpkin> you shouldn't have to name it as I did, but I like writing top-level types
16:26:11 <copumpkin> you will need runST though somewhere
16:26:59 <copumpkin> dolio: didn't Vector adopt your mutable -> immutable combinator at some point? I thought it was wrapped up in that New type but that seems to be designed to create mutable vectors
16:27:53 <dolio> I don't know if it was adopted or invented independently.
16:28:03 <copumpkin> but is it in there? I can't find it now
16:28:18 <dolio> Let me think what it was called....
16:28:21 <dolio> modify?
16:29:02 <copumpkin> aha
16:29:02 <copumpkin> modify :: Vector v a => (forall s. Mutable v s a -> ST s ()) -> v a -> v a
16:29:09 <dolio> Yeah, that's the one.
16:29:47 <copumpkin> oh, and new :: Vector v a => New v a -> v a
16:29:51 <copumpkin> that's what I was looking for
16:35:28 <jmcarthur> so i've generalized pipes/proxies. pipes accept information from one side and send it to the other. proxies generalize that by allowing you to send and receive on either side. now i have a thing that has an arbitrary number of these two-way communication channels. however, i have no use for it.
16:36:47 <jmcarthur> i guess one use case might be something like logging
16:37:19 <jmcarthur> you can add it on the side with its own pipeline instead of having to go out of band some other way
16:45:57 <Xaratas> srhb, croikle: ok, i dont get it, if i write !result or use $! it doesn't change any thing, its a stackoverflow
16:46:17 <srhb> Xaratas: Forcing a list only causes it to be evaluated to head normal form
16:46:37 <srhb> Xaratas: If you want to go this route and force the entire list, you need something like deepseq
16:46:52 <srhb> Mind I've no idea what your actual code is supposed to be doing and I'm too tired to try and figure it out. :P
16:51:13 <Xaratas> its calculating magical squares, this part takes a line and find all lines which lead to a magical square if combined with the first
16:53:53 <srhb> I have a feeling that it ought to be rewritten entirely to really see the right way of doing this, but for now, have a go at deepseq unless someone else is around to give you a hand.
16:54:22 <croikle> if your original code works fine, I wouldn't worry too much about the tail-recursive rewrite. laziness makes more things okay
16:57:48 <Xaratas> its in deep enough to try the tail recursive form, the other function which i changed this way lead to a noticeable (>10%) runtime improvement
16:58:55 <Xaratas> oh, and rewriting to get even more speed is also planed
17:09:43 <Blkt> good (late) evening everyone
17:43:51 * hackagebot bash 0.1.8 - Bash generation library.  http://hackage.haskell.org/package/bash-0.1.8 (JasonDusek)
17:53:10 <srhb> In Parsec, what's the difference between try (foo <|> bar) and (foo <|> bar) ?
17:54:42 <geekosaur> by itself? nothing. but if the try is itself part of an alteration, then the other legs get to try again with the full input instead of whatever either foo or bar parsed before it failed
17:55:19 <srhb> Meaning: In the latter, if foo parses something partially and then fails, bar does not get to retry from the beginning?
17:55:26 <geekosaur> that is, try p for some p does not change how p behaves. try p <|> q is what's affected
17:55:39 <geekosaur> a parser that consumes input is not "unwound" when it fails
17:55:51 <srhb> OK, great, I had somehow gotten that in my head.
17:56:08 <geekosaur> so if foo successfuly matches a character adn the fails, that character is gone. but try around it puts it back on failure
17:56:20 <srhb> Great, thanks. :)
17:57:41 <tac_> srhb: the key to that is that when a parser fails, it might still have consumed some of the input
17:58:02 <srhb> That makes me wonder why there isn't an optionEither
17:58:30 <srhb> Hm, no, that isn't quite the same.
17:58:39 <srhb> But still, why isn't there an optionEither? :P
17:59:34 <Peaker_> @type (+++)
17:59:35 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
17:59:51 <srhb> Okay.
18:00:01 <tac_> Peaker_: what an imprecise type!
18:00:18 <tac_> :)
18:00:39 <Peaker_> srhb, of what type?
18:01:04 <Peaker_> @type \x y -> (Left <$> x) <|> (Right <$> y)
18:01:05 <lambdabot> Alternative f => f a -> f b -> f (Either a b)
18:22:56 <tsou> is there a built-in function that given n and k will return (n `div` k, n `mod` k) ?
18:23:13 <lispy> ?hoogle divMod
18:23:13 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
18:23:13 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
18:23:27 <lispy> > n `divMod` k
18:23:29 <lambdabot>   (n `div` k,n `mod` k)
18:23:33 <lispy> tsou: ^^
18:24:06 <tsou> lispy: ah, thanks
18:24:24 <no-n> why don't I get the infixl when I do :info divMod
18:25:33 <lispy> > 39 `divMod` 7
18:25:34 <lambdabot>   (5,4)
18:28:52 * hackagebot Win32-services 0.2 - Windows service applications  http://hackage.haskell.org/package/Win32-services-0.2 (MichaelSteele)
18:30:04 <tsou> how did lambdabot just answer this?  (the (n `div` k,n `mod` k) answer)
18:31:33 <croikle> they have some symbolic magic. I'm curious how it works, too.
18:31:46 <croikle> new num instance?
18:31:50 <mikeplus64> > div n k
18:31:52 <lambdabot>   n `div` k
18:31:57 <mikeplus64> croikle: must be
18:32:06 <mikeplus64> > typeOf n
18:32:08 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable
18:32:08 <lambdabot>                     Debug....
18:32:30 <tsou> still it wouldn't explain how it came up with (n `div` k,n `mod` k)
18:32:54 <mikeplus64> > [] n
18:32:55 <lambdabot>   The function `[]' is applied to one argument,
18:32:55 <lambdabot>  but its type `[a0]' has none
18:33:09 <tsou> > take n (x:xs)
18:33:11 <lambdabot>   Not in scope: `xs'
18:33:11 <lambdabot>  Perhaps you meant one of these:
18:33:11 <lambdabot>    `x' (imported from D...
18:33:14 <elliott> tsou: SimpleReflection magic
18:33:16 <mikeplus64> aw it's missing the line that would show what the type is
18:33:17 <elliott> it's just a fancy data type
18:33:18 <elliott> :t x
18:33:18 <mikeplus64> :(
18:33:20 <lambdabot> Expr
18:33:25 <mikeplus64> oh yeah :t
18:33:27 <elliott> with its own implementation of divMod etc.
18:33:29 <mikeplus64> :t n
18:33:30 <lambdabot> Expr
18:34:32 <tsou> elliott: thanks for the pointer
18:34:57 <tsou> ah, so it's not so magic afterall :P
18:36:06 <croikle> some details: http://twanvl.nl/blog/haskell/simple-reflection-of-expressions
18:37:05 <roconnor> tsou: this is magic:
18:37:24 <roconnor> > diff (\x -> sin x ^2) x
18:37:26 <lambdabot>   sin x * (cos x * 1) + cos x * 1 * sin x
18:37:39 <mikeplus64> woah
18:37:46 <tsou> hehehe
18:38:18 <mikeplus64> > diff (^2)
18:38:19 <lambdabot>   No instance for (GHC.Show.Show (a0 -> a0))
18:38:19 <lambdabot>    arising from a use of `M16736...
18:38:21 <mikeplus64> > diff (^2) x
18:38:23 <lambdabot>   x * 1 + 1 * x
18:38:35 <croikle> :t diff
18:38:37 <lambdabot> Num a => (forall (s :: * -> *). Numeric.AD.Types.Mode s => AD s a -> AD s a) -> a -> a
18:38:42 <tac_> Is there a way I can search for a substring in a Text?
18:38:58 <tac_> like a contains or isSubstr
18:38:59 <tac_> or something?
18:39:16 <mikeplus64> tac_: isInfixOf
18:39:45 <tac_> ty
18:41:26 <mikeplus64> also text-icu has regex search and other stuff you might find useful
18:41:44 <tac_> thanks
19:01:44 <xiamx> is there any twitter API binding for haskell? I looked up various exisitings stuff like hs-twitter, they all look outdated
19:08:12 <tactics> xiamx: I was looking around a while ago. I couldn't find one.
20:21:21 <vladimir_> help. can only install cairo, pango, et al as user. Global install can't find gtk2hsC2hs. This is bs. Installed gtk2hs-buildtools global. Installed  gtk2hs-buildtools user. If $PATH points to /usr/local/bin then fail. elseif $PATH points to /home/user/.cabal/bin first, success. But no global build of gnomish stuff succeeds if built global. wtf, over.
20:24:06 <jmcarthur> does anybody know if there is a package that already provides a trivial functor? i'd hate to duplicate work unnecessarily. (i'm talking about something like  data Empty a  -- no constructors, must have a Functor instance)
20:24:34 <jmcarthur> or perhaps in place of no constructors it has something equally impossible like (forall a. a)
20:25:25 <jmcarthur> i could just use Const Void i guess
20:26:46 <vladimir_> off doing other things. will respond with effusive thanks if original query is answered. brb
20:26:49 <arkeet> data Void :: k
20:26:54 <arkeet> can that even work?
20:27:33 <jmcarthur> no, i think data definitions have to have * as the result type
20:27:46 <arkeet> indeed
20:28:07 <arkeet> but it should. one could take k to be * or * -> * or whatever
20:28:13 <jmcarthur> i'm just going with (forall a. a) for now
20:28:36 <jmcarthur> turns out that it's more convenient than i thought it would be anyway
20:28:56 <jmcarthur> in this context i would just have to newtype the Void functor anyway, so i might as well just use (forall a. a)
21:04:02 <jmcarthur> elliott: btw, i managed to get rid of the need for that witness stuff. i refactored so that instead of layering monad transformers i'm just layering functors and making a free monad out of the whole thing. functors are a lot easier to work with than monad transformers
21:04:18 <elliott> jmcarthur: phew, I'm glad :P
21:04:25 * elliott would hate for that to be his mark on the world.
21:04:35 <jmcarthur> you were in great danger of that
21:05:18 <jmcarthur> s/layering functors/taking the coproduct of functors/
21:28:51 <hxn1248> clear
21:29:03 <hxn1248> \exit
22:07:32 <ab9rf> i just discovered the DeriveFunctor extension
22:07:47 <arkeet> there's also DeriveFoldable and DeriveTraversable
22:08:08 <Argue> I didn't really know where to ask this but is there a data analysis/machine learning channel around here?
22:08:19 <ab9rf> arkeet: yes
22:09:23 <ab9rf> arkeet: i was annoyed because something i am working on was going to force me to write a bunch of fairly trivial functor instances, and now i don't
22:09:31 <arkeet> :)
22:09:41 <ab9rf> er, don't have to
22:10:07 <ab9rf> obvious idea is obvious?
22:11:16 <copumpkin> Argue: #machinelearning appears to exist
22:11:23 <ab9rf> heh
22:12:29 <tactics> copumpkin: that's only a weak answer to the question :P
22:13:04 <Argue> huh, why didn't i think of that ._.
22:13:05 <Argue> thanks
22:25:50 <ab9rf> kitten!
22:55:36 <KinkyKitty> @ping
22:55:36 <lambdabot> pong
23:01:43 <zhulikas> bad kitty, kinky kitty little ball of fur
23:46:41 <mysticc> I need to perform some code transformation
23:47:56 <mysticc> something related to manually inlining functions and for that I need to find the functions active in the current context. Right now I am using haskell-src-ext for parsing the source. Any suggestions?
23:49:33 <mgsloan> mysticc: https://github.com/feuerbach/haskell-names  (not sure if it's 100% complete, but this is your best bet)
23:50:01 <mgsloan> you could also use the GHC API or TH reify
23:50:59 <mysticc> mgsloan: It is a part of a larger project and I dont want to use another parser until it adds something more as I will be required to switch a lot of code.
23:51:28 <mgsloan> well, haskell-names uses haskell-src-exts too
23:51:33 <mysticc> mgsloan: Is it not yet available on hackage
23:51:39 <mgsloan> nope
23:52:40 <mgsloan> mysticc: But it worked well enough for roche (feuerbach) to do a renaming refactoring with it (the has-fix repo)
23:53:19 <mgsloan> Could be that it's complete and he just doesn't want to maintain it on hackage yet till some other haskell-suite packages are ready
23:54:21 <mysticc> mgsloan: Ok I will try and see how useful it is actually.
23:56:42 <mysticc> mgsloan: It is a real pain to actually install it. It has many dependencies not available on hackage. :(
23:57:14 <mgsloan> Yeah, you'll find most of those on his github page
23:58:47 <mgsloan> Oh, interesting, you might also check out the "open" branch - it's being actively developed (he's got a blog post about this new design here http://ro-che.info/articles/2013-03-04-open-name-resolution.html )
23:59:06 <mgsloan> I hadn't seen the new branch till now though
