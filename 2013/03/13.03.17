00:01:28 <tieTYT2> i'm trying to install curl but it gives me an error "configure: error: curl libraries not found, so curl package cannot be built".  How do I get the libraries?  I have cygwin
00:03:03 <mgsloan> mysticc: it should just depend on feuerbach/hse-cpp and  feuerbach/haskell-packages, installing these is not so much pain.  Check out this git utility: https://github.com/defunkt/hub
00:04:29 * tieTYT2 found this: http://gbacon.blogspot.com/2009/06/installing-curl-from-hackage-on-cygwin.html
00:04:47 <mysticc> mgsloan: cabal1.17
00:04:51 <mgsloan> then you can just do "git clone feuerbach/haskell-packages & cabal install haskell-packages/" etc
00:04:52 <mgsloan> ah
00:05:12 <mgsloan> Looks like that version isn't honest, just lower it
00:05:40 <mgsloan> oh, nvm, I misinterpreted
00:05:51 <mgsloan> Hmm, I think I ran into that too
00:06:11 <mgsloan> There was a discussion recently about having a cabal parser be separate
00:06:21 <mgsloan> and have ghc depend on that
00:06:38 <mgsloan> would be good for this too
00:06:55 <mgsloan> Wellp, yeah, this is a hard thing :)
00:07:03 <mysticc> ok I have lowered the dependency of cabal :)
00:07:12 <mgsloan> worth a shot!
00:07:43 <mgsloan> (I thought you meant the cabal file itself)
00:08:40 <mysticc> mgsloan: In the dependency of haskell-packages
00:08:49 <mgsloan> Yeah, I saw it
00:09:14 <mysticc> mgsloan: I am installing the openbranc
00:09:17 <mysticc> *branch
00:09:21 <mgsloan> I mean, it might even be worthwhile to change that package to support more versions of cabal (if it is indeed an issue)
00:11:09 <mysticc> mgsloan: Also do you know how to work generically with constructors of a datatype? I was using typeable but I am having some problems.
00:14:24 <arkeet> mysticc: have a look at Data.Data.Data
00:15:02 <arkeet> or Generics maybe
00:17:11 <mgsloan> mysticc: I think SYB is the most straightforward approach
00:17:52 <mgsloan> there're some fancier and faster approaches out there, but I still resort to SYB when it comes to things like "get all of the names used in an AST, so I can be sure not to alias them"
00:18:09 <mgsloan> Or "dequalify all of the names in the AST"
00:18:23 * ski doesn't trust SYB
00:19:57 <bourbaki> Greetings
00:20:01 <genisage> Hello
00:20:59 <bourbaki> I would like to write a small haskell dll that makes use of opencl, i just came to wonder how i can make sure that the context created that way will be able to be initialized at one point and destructed in another using haskell.
00:21:01 <genisage> Can anybody explain how a variable ends up as Interactive.Foo instead of just Foo?
00:21:02 <mgsloan> ski: Probably a good choice.  If you care about performance, it's probably a good idea to include a case for "String", so that it doesn't go walking down all of the strings in your AST :)
00:21:43 <mgsloan> ski: But yeah, I wouldn't use it in code that I'd recommend to others
00:21:51 <bourbaki> I want to link that library with C++ or C# then.
00:22:00 <mgsloan> at least when it comes to  manipulating ASTs, maybe for other things
00:22:12 <genisage> I tried assigning it in the exact same way several times but couldn't reproduce it.
00:22:22 <mysticc> mgsloan: The open branch of haskell-names doesn't compile, Also master branch fails for gen-iface executable which I think uses cabal 1.17
00:22:40 <mysticc> atleast I can generate docs for master branch :)
00:23:02 <mgsloan> hehe, well, I dunno!  There're reasons it's not on hackage
00:23:39 <mgsloan> sorry for leading you astray (I mean, it might still work out), but in theory haskell-names would be the right solution
00:23:57 <bourbaki> How fast is the string marshalling when you call haskell from c++ and what memory foot print does it have?
00:23:59 * hackagebot binary-file 0.2 - read/write binary file  http://hackage.haskell.org/package/binary-file-0.2 (YoshikuniJujo)
00:24:01 * hackagebot binary-file 0.3 - read/write binary file  http://hackage.haskell.org/package/binary-file-0.3 (YoshikuniJujo)
00:24:11 <mysticc> mgsloan: Ok I am checking out the haddock.. If it seems right then I might try installing cabal 1.17
00:24:19 <tieTYT2> i'm about to give up on haskell.  I'm getting really frustrated at how cabal can't install any of the libraries.
00:24:53 <tieTYT2> i'm trying to install curl but it gives me an error "configure: error: curl libraries not found, so curl package cannot be built".  How do I get the libraries?  I have cygwin, I installed curl and curl libraries on it
00:25:08 <tieTYT2> this is windows btw, the key to my frustration
00:29:02 <nexx> did you install pkg-config?
00:29:08 <genisage> if you add the directory containing your libraries to your LDFLAGS, it might fix it
00:29:37 <tieTYT2> nexx: no
00:29:58 <tieTYT2> genisage: can you show me an example of how to do that?  I've never used gcc before but that looks like a gcc setting
00:30:41 <genisage> it's an environment variable, you can change it with export LDFLAGS=$LDFLAGS:somepath
00:31:22 <genisage> or you can add directories on a case by case basis with the -L option.
00:33:41 <tieTYT2> cabal.exe: unrecognized option `-L'
00:33:49 <bourbaki> What do i do when this happens? accelerate-cuda-0.12.1.2 depends on cuda-0.4.1.1 which failed to install.
00:33:59 * hackagebot sized-vector 0.0.1.0 - Size-parameterized vector types and functions.  http://hackage.haskell.org/package/sized-vector-0.0.1.0 (HiromiIshii)
00:35:15 <arkeet> bourbaki: you provide more information.
00:35:38 <ab9rf> i was going to say "you find out why cuda-0.4.1.1 didn't install and fix that"
00:35:43 <arkeet> that too.
00:35:47 <genisage> the -Lpath option is for gcc, if you want to use their install scripts instead of building everything manually you should probably just update your environment
00:36:02 <arkeet> tieTYT2: cygwin is of no use for that.
00:36:11 <bourbaki> Im on a win8 machine, installed haskell platform, updated the installer, updated the package list, then tried to install accelerate-cuda to the avail that i just recently posted.
00:36:14 <arkeet> tieTYT2: you'll need some mingw
00:36:26 <genisage> or better yet, some gentoo.
00:36:28 <arkeet> tieTYT2: and possibly tell ghc where to look for the mingw files
00:36:37 <arkeet> tieTYT2: windows is a pain.
00:36:49 <bourbaki> I also have installed the Cuda sdk.
00:37:04 <arkeet> bourbaki: well, we can't help you without more information, like a build olg
00:37:05 <arkeet> log
00:37:16 <bourbaki> Oh :)
00:37:44 <tieTYT2> arkeet: yes it's seriously a pain
00:38:04 <tieTYT2> arkeet: I'm thinking of learning/using clojure instead.  At least I'll have the whole java ecosystem available to me
00:38:14 <arkeet> why not scala?
00:38:55 <arkeet> it's closer to haskell than clojure is, at least.
00:38:56 <tactics> Why not Frege?
00:39:14 <tieTYT2> i like rich hickey a lot, and his philosophy is interesting to me.  I don't like how scala tries to give you the best of OO and FP together
00:39:24 <arkeet> I never heard of frege.
00:39:38 <hpaste> bourbaki pasted ‚Äúaccel fail‚Äù at http://hpaste.org/84199
00:39:39 <tieTYT2> my impression is clojure tries to be more FP but lets you do some OO things if you need to
00:39:43 <tactics> It's a JVM Haskell-like thing
00:39:49 <arkeet> tactics: I see it now
00:39:53 <tactics> Not exactly haskell, but... I forget it has some similarity to it
00:39:54 <arkeet> tieTYT2: closure is more of a lisp
00:39:56 <bourbaki> arkeet: Thats the log i got when installing
00:40:03 <tieTYT2> arkeet: yeah :T
00:40:18 <tactics> https://github.com/Frege/frege/wiki/Differences-between-Frege-and-Haskell
00:41:17 <arkeet> bourbaki: can you see the error?
00:41:27 <tieTYT2> tactics: it's interesting, but I've never heard of it.  At least with clojure I could put it on a resume
00:41:30 <arkeet> it is a very clear error which tells you exactly what you need to do.
00:41:43 <bourbaki> No why would i ask then?
00:41:47 <tactics> tieTYT2: right. I just wanted to point it out to you guys if you hadn't heard of it :)
00:41:54 <tieTYT2> arkeet: why would you prefer scala?
00:42:01 <tieTYT2> tactics: yeah that's pretty cool
00:42:28 <tactics> tieTYT2: types, 'nuff said
00:42:44 <tactics> types are the raison d'etre of functional programming </opinion>
00:43:15 <tieTYT2> that's weird, so you don't think lisp is functional?
00:43:34 <arkeet> bourbaki: ok, look for the part where it's building cuda.
00:43:36 <arkeet> line 56.
00:43:39 <mauke> tieTYT2: it totally isn't
00:43:42 <arkeet> or 57.
00:43:43 <bourbaki> ok
00:43:49 <tactics> tieTYT2: It's dysfunctional :P
00:43:53 <tieTYT2> mauke: why not?
00:44:00 * hackagebot sized-vector 0.0.1.1 - Size-parameterized vector types and functions.  http://hackage.haskell.org/package/sized-vector-0.0.1.1 (HiromiIshii)
00:44:00 <mauke> tieTYT2: SETF
00:44:20 <tactics> tieTYT2: Lisp is functional by most measures, but IMO, types are the real benefit of FPLs
00:44:30 <bourbaki> So i need to install c2hs?
00:44:38 <arkeet> yes
00:44:55 <bourbaki> Ah should be a dependency then right?
00:44:57 <tieTYT2> i dunno what SETF is
00:45:00 <simpson> tactics: Uh, what.
00:45:02 <ski> (which lisp ?)
00:45:05 <arkeet> bourbaki: you can't depend on executables
00:45:06 <mauke> ((f .) . g) x y
00:45:17 <arkeet> or can you?
00:45:29 <bourbaki> arkeet: Oh ok, can i install c2hs as a package?
00:45:34 <arkeet> yes
00:45:52 <bourbaki> Ok thanks a lot :)
00:45:58 <mauke> (funcall (compose (lambda (x) (compose #'f x)) #'g) x y)
00:46:08 <arkeet> what an obtuse syntax.
00:46:15 <mauke> I mean (funcall (compose #'(lambda (x) (compose #'f x)) #'g) x y)
00:46:51 <arkeet> mauke: although lisps don't do curried functions.
00:47:00 <arkeet> conventionally.
00:47:02 <tieTYT2> mauke: is that clojure, lisp or both?
00:47:03 <arkeet> do they?
00:47:08 <mauke> tieTYT2: common lisp
00:47:35 <mauke> oops
00:47:37 <hpaste> bourbaki pasted ‚Äúc2hs fail‚Äù at http://hpaste.org/84200
00:47:45 <mauke> I mean (funcall (funcall (compose #'(lambda (x) (compose #'f x)) #'g) x) y)
00:48:12 <bourbaki> Hm ok trying to install c2hs does not seem to compile with an error to not finding alexGetByte in scope..
00:48:22 <ski>   ((compose f g) x y)  ; Scheme
00:48:25 <ski>   (((compose (cut compose f <>) g) x) y)  ; Scheme, alternatively
00:48:36 <mauke> compose(sub { compose($f, $_[0]) }, $g)->($x)->($y)   # Perl is basically CL
00:50:38 <arkeet> bourbaki: hmm, do you need to update alex?
00:50:49 <bourbaki> Who is alex?:)
00:50:55 <arkeet> a package
00:51:02 <bourbaki> Let me try
00:51:07 <bourbaki> Is it just called alex?
00:51:16 <arkeet> I've never seen that error before.
00:51:17 <arkeet> yes
00:51:25 <bourbaki> what is it good for?
00:51:30 <arkeet> it's a lexer.
00:51:50 <arkeet> or a lexer generator.
00:52:32 <bourbaki> Cool that seemed to work :) now lets see about the cuda package
00:53:14 <amatsu> Hey #haskell
00:53:31 <amatsu> I was covering Applicative functors yesterday, and was wondering,
00:54:00 * hackagebot conduit 1.0.4 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.4 (MichaelSnoyman)
00:54:01 <amatsu> Is there any speed benefit to using Applicative over using, say, list comprehensions?
00:54:24 <amatsu> (or is it just all syntax sugar?)
00:55:10 <tactics> amatsu: I can't imagine any speed benefit you could gain in Haskell
00:55:36 <edwardk> amatsu: for lists, no. for other monads/applicatives, sometimes, yes.
00:55:59 <tactics> edwardk: Are there any rewrite rules for Applicative?
00:56:16 <tactics> I would think the answer ought to be "yes, but only theoretically"
00:57:35 <edwardk> tactics: the laws are there for you, not the compiler
00:58:14 <tactics> I'm saying that GHC won't gain any benefits automatically by restricting yourself to Applicative
00:58:42 <edwardk> um, if you write your particular Applictive instance, it can take advantage of the extra flexibility to write a smarter 'ap'
00:58:54 <edwardk> but ghc won't turn monadic code into applicative code, no
00:59:00 * hackagebot resourcet 0.4.7 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.4.7 (MichaelSnoyman)
00:59:52 <amatsu> tactics: edwardk: thanks for the clarification!
01:00:10 <ab9rf> blah
01:06:38 <bourbaki> Hm are there some issues with Win8 and HaskellPlatform maybe?
01:07:16 <bourbaki> I updated cabal and it installs everything into AppData\Roaming then i have a new cabal.exe there with the new version.
01:07:29 <bourbaki> But when i check the version in Powershell i see the old one.
01:07:40 <ab9rf> d'oh.  i r eejit.
01:08:02 <ab9rf> mutual recursion can result in infinite loops
01:10:31 <edwardk> heh. i uploaded a package named log, but that apparently doesn't work due to http://hackage.haskell.org/packages/archive/log
01:15:32 <ab9rf> heh
01:16:04 <ab9rf> edwardk: you hit a reserved word!
01:17:21 <edwardk> was bound to happen eventually =)
01:20:41 <edwardk> log-domain it is
01:24:00 * hackagebot log-domain 0.1 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.1 (EdwardKmett)
01:24:28 <edwardk> yay
01:24:34 <edwardk> the first splinter package from analytics works
01:33:04 <simukis_> Do we have a library which provides cross-platform notifications of file changes?
01:39:24 <c_wraith> simukis_: there is a library that's intended to do that. I'm not sure how well-implemented it is.
01:40:05 <c_wraith> simukis_: http://hackage.haskell.org/package/fsnotify
01:40:28 <c_wraith> I haven't used it. It's relatively recent.
01:40:41 <simukis_> w_wraith: Thanks, I'll check it out.
01:40:52 <simukis_> s/w_/c_/ :)
01:42:03 <simukis_> by the way can you tell me the about the black magic you used to find this package? Hoogle's really uncooperative with me today.
01:44:10 <c_wraith> uh.  I went to http://hackage.haskell.org/packages/archive/pkg-list.html and did an in-browser search for "notify"
01:44:10 <liyang> Go to http://hackage.haskell.org/packages/archive/pkg-list.html , press Ctrl+F, try various keywords.
01:44:19 <c_wraith> It's hardly advanced
01:44:21 <c_wraith> but it works!
01:45:05 <simukis_> Oh, thanks again :)
01:47:47 <ab9rf> that was a lot of work to completely break my parser :)
01:47:48 <liyang> It won't find stuff in the long description though, only the synopsis.
01:49:07 <ab9rf> c_wraith: i read 'fsnotify' as f snotify.  i assume it's not intended to be read that way, and this is just because i have young children.
02:29:02 * hackagebot log-domain 0.1.0.1 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.1.0.1 (EdwardKmett)
02:30:32 <no-n> (takeWhile (==x) (x:xs)) : (pack' (dropWhile (==x) xs)) -- how would I do this without evaluating every element of (takeWhile (==x) (x:xs)) twice?
02:31:45 <Hermit> no-n: break
02:31:50 <Hermit> @ty break
02:31:51 <elliott> > break (==a) [a,a,a,b,c]
02:31:51 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
02:31:53 <lambdabot>   ([],[a,a,a,b,c])
02:31:59 <elliott> > span (==a) [a,a,a,b,c]
02:32:01 <lambdabot>   ([a,a,a],[b,c])
02:32:12 <no-n> thank you :>
02:33:45 <ab9rf> @hoogle [(s,t)] -> [t]
02:33:45 <lambdabot> Prelude snd :: (a, b) -> b
02:33:46 <lambdabot> Data.Tuple snd :: (a, b) -> b
02:33:46 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
02:34:17 <ab9rf> :t concat . map . snd
02:34:18 <lambdabot>     Couldn't match expected type `[[a0]]'
02:34:18 <lambdabot>                 with actual type `[a1] -> [b0]'
02:34:18 <lambdabot>     Expected type: (a1 -> b0) -> [[a0]]
02:35:01 <ab9rf> :t concat . map snd
02:35:02 <lambdabot> [(a1, [a])] -> [a]
02:35:09 <ab9rf> yay
02:35:14 <Hermit> :t concatMap snd  -- ab9rf
02:35:16 <lambdabot> [(a, [b])] -> [b]
02:36:43 <ab9rf> i actuall y have to use concatMap (snd.snd)
02:36:59 <ab9rf> and hm, i should probably use a fold instead
02:37:21 <ab9rf> because i need the first half of the tuple as well
02:40:17 <ab9rf> @pl \(_,(b1,c1)) (_,(b2,c2)) -> (b1,c1++c2)
02:40:19 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . (((.) . const) .) . flip flip snd . (ap .) . flip flip fst . (((.) . const) .) . (. (++)) . (.) . (,)) . snd
02:40:25 <ab9rf> snort
02:40:46 <ab9rf> yeah, i'll use that
02:40:59 <Clint> use it
02:42:41 <ab9rf> :t uncurry
02:42:42 <lambdabot> (a -> b -> c) -> (a, b) -> c
02:54:04 * hackagebot llvm-base-util 3.0.1.0 - Utilities for bindings to the LLVM compiler toolkit.  http://hackage.haskell.org/package/llvm-base-util-3.0.1.0 (PaulMeng)
03:18:46 <madsj> I can only find a limited amount of the monad reader 1-13 in pdf form; does anyone know where I can find them all?
03:20:12 <BadKitty> madsj: Not sure here.. But send us the link
03:20:20 <BadKitty> Send google the link... Google's good at links :)
03:24:39 <madsj> BadKitty: I tried googling for "the monad reader filetype:pdf", and miss several of the 1-13 results
03:39:50 <BadKitty> madsj: What's missing?
03:39:55 <BadKitty> issue 0-12 ?
03:40:28 <BadKitty> or 1-12 idk
03:40:40 <BadKitty> http://www.haskell.org/haskellwiki/The_Monad.Reader/Previous_issues
03:40:43 <BadKitty> madsj: ^
03:58:21 <no-n> HASKELL
04:09:38 <hpaste> srhb pasted ‚ÄúApplicative?‚Äù at http://hpaste.org/84206
04:10:02 <srhb> I can't find an obvious translation of this to Applicative. Is this a case where the monadic parser is just simpler to use?
04:11:08 <ion> (\s m e -> Serverprefix (s : m ++ e)) <$> (letter <|> digit) <*> many (letter <|> digit <|> char '-') <*> many (letter <|> digit)
04:11:16 <srhb> Oh duh.
04:11:33 <srhb> I tried Serverprefix . (\s m e ->) ... which is obviously a type error
04:11:33 <srhb> Thanks
04:14:22 * elliott prefers the monadic form here.
04:15:42 <srhb> Yeah I think I do, too
04:15:48 <srhb> The lambda isn't as pretty as the infixform
04:28:08 <PaulVisschers> I¥ve once again run into the issue of needing to use a function of type (IO a -> IO a) in a MonadIO context. Is there a good way to solve this?
04:34:06 * hackagebot wai-test 1.3.0.5 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-1.3.0.5 (MichaelSnoyman)
04:42:25 <srhb> How do I check from which characters Parsec exclude when I use eg. noneOf?
04:54:22 <Twey> PaulVisschers: id ‚à∑ IO a ‚Üí IO a
04:55:31 <Twey> There's nothing generally wrong with a function of type IO a ‚Üí IO a; it might be bad design, depending on your use-case
04:55:51 <PaulVisschers> Twey: I meant that I have a function of type IO a -> IO a in a library and I want to use my own function of type MonadIO m => m a as an input to that function
04:55:53 <elliott> presumably PaulVisschers is asking about lifting them, i.e. (IO a -> IO a) to (m a -> m a) for some MonadIO m
04:56:02 <elliott> which is impossible in general and kind of a tricky/vaguely-defined problem
04:56:02 <PaulVisschers> elliott: exactly
04:56:09 <Twey> Ah
04:56:18 <elliott> hard to help without more concrete details, there's no real panacea here IMO
04:56:45 <PaulVisschers> elliott: yeah I figured, but thought I¥d ask anyway
04:57:00 <Twey> Find the library author and poke them a bit ‚ò∫
04:57:42 <PaulVisschers> elliott: it¥s fine btw, since I can just call this function to wrap my main function (it¥s withSocketsDo if you¥re curious)
04:57:57 <elliott> right, withSocketsDo can genreally just go right in main
04:58:24 <ion> Why isn‚Äôt it just ‚ÄúwithSockets‚Äù, i wonder?
04:58:43 <PaulVisschers> ion: withSocketsDo $ do :P
04:58:58 <ion> $ do $ do $ do $ do
05:00:09 <PaulVisschers> elliott: still I made this network monad transformer and really would¥ve like it if the withSocketsDo was in the runTransformer function so people wouldn¥t have to remember to use it
05:01:11 <PaulVisschers> elliott: although using it once may be a lot more efficient
05:04:16 <xorox90> What kinds of application do you recommend to write with haskell (considering especially library mature or othere things)
05:08:11 <elliott> xorox90: it's general-purpose. it works for pretty much anything well.
05:08:35 <elliott> well, except maybe really low-level stuff like kernels and drivers, though there are operating systems in haskell.
05:08:57 <elliott> there are several mature web frameworks, GUI libraries, numeric computation type stuff...
05:09:23 <XexonixXexillion> Haskell works for anything that isn't a hard real time system IMO
05:09:55 <xorox90> elliott, XexonixXexillion // thx!
05:12:02 <elliott> XexonixXexillion: and there's things like copilot...
05:12:47 <th0gz19> Hello Haskell Hackers... there's something i don't understand about instances documented in haddock
05:12:58 <Taneb> th0gz19, fire away
05:13:08 <th0gz19> Instances
05:13:08 <th0gz19> (LayoutClass l1 a, LayoutClass l2 a, Show a) => LayoutClass (PerWorkspace l1 l2) a	
05:13:09 <th0gz19> (Read (l1 a), Read (l2 a)) => Read (PerWorkspace l1 l2 a)	
05:13:09 <th0gz19> (Show (l1 a), Show (l2 a)) => Show (PerWorkspace l1 l2 a)	
05:13:15 <th0gz19> can someone paraphrase this for me?
05:13:24 <XexonixXexillion> elliott: I tend not to consider that Haskell, but as a language in its own right
05:14:24 <Taneb> If instances exist for "LayoutClass l1 a", "LayoutClass l2 a", and "Show a", for some l1, l2, and a, then here's an instance for "LayoutClass (PerWorkspace l1 l2) a"
05:14:29 <XexonixXexillion> elliott: My point was more that it's suitable for anything where you don't need strict time guarantees
05:14:34 <elliott> yeah
05:16:06 <Taneb> th0gz19, basically, the things on the left of the "=>" are instances that must exist for the instance on the right to exist
05:16:10 <Taneb> th0gz19, is this helping>
05:17:09 <th0gz19> d'aww.. i thought this gonna be easy.. well thank you i think you answered it, i just have to keep it and read it again... i think i got it 10% lol
05:18:19 <th0gz19> well anyway thanks...
05:18:35 <Taneb> Keep persevering, you'll get it eventually :)
05:20:37 <XexonixXexillion> Has anyone implemented Lisp's type system in Haskell?
05:22:12 <Taneb> Could you give me a quick summary of Lisp's type system?
05:23:48 <XexonixXexillion> Dynamically but strongly typed. Types are some superset of Cons cells, symbols, ints, reals, bools and function from [LispType] -> LispType
05:24:45 <XexonixXexillion> I wanted to implement something like CLOS (Common Lisp Object System) in Haskell, and wondered if anyone else had done something similar
05:29:47 <mm_freak> assuming that Taneb meant common lisp
05:30:33 <Taneb> XexonixXexillion, that should be relatively easy...
05:30:35 <mm_freak> XexonixXexillion: it's hardly a "type system"‚Ä¶  it's rather memory references with type annotation
05:31:27 <mm_freak> when writing (+ x y), it's +'s responsibility to check that x and y are both numeric
05:31:43 <merijn> XexonixXexillion: Probably it has been done, have you looked at the "Write Yourself a Scheme in 48 Hours" tutorial?
05:31:48 <mm_freak> there is also statically typed racket, which makes things more interesting
05:33:58 <XexonixXexillion> mm_freak: It's still a type system, it's just a world apart from Haskell's (except statically typed racket)
05:35:37 <mm_freak> XexonixXexillion: it's a type discipline, but i think a type system does stuff
05:36:06 <mm_freak> example:  clisp isn't strongly typed because there is a type system that checks your types at runtime, but because + actually has code to check the types
05:36:36 <tdammers> mm_freak: "strongly typed" isn't exactly a well-defined term
05:36:41 <XexonixXexillion> mm_freak: Perhaps. But I think this conversation is about as useful as "Is scheme actually lisp" that appear on #lisp
05:37:05 <XexonixXexillion> s/appear/sometimes appears/
05:37:23 <srhb> How do I parse up to n occurrences of something with Parsec?
05:38:01 <mm_freak> XexonixXexillion: i think it's important to a language implementor‚Ä¶  your type system would essentially consist of adding a type field to memory references‚Ä¶  if you want to do something satisfactory, write a statically typed scheme =)
05:38:25 <mm_freak> XexonixXexillion: to increase the satisfaction understand monadic ASTs and check out the 'bound' library =)
05:38:35 <sepp2k> mm_freak: That's not true for the object system though, is it? I mean when you define a method in CLOS, the system checks the types - you don't have to do that yourself, right? (I don't really know - I'm not that familiar with CLOS).
05:38:56 <mm_freak> sepp2k: CLOS (the library) checks the types
05:39:33 <sepp2k> Right, so wouldn't it be accurate to say that CLOS is (or has or whatever) a type system?
05:39:55 <sepp2k> Or "provides" rather.
05:40:13 <mm_freak> probably yeah, but when you extend this notion + also has a type system =)
05:40:45 <johnw> CLOS is much more runtime-oriented, isn't it?
05:40:59 <johnw> i think of it as a dispatcher
05:41:32 <srhb> I thought it ought to be replicateM n $ optional parser
05:41:53 <XexonixXexillion> mm_freak: Does + actually check the types? I don't think the standard requires that (whether the implementation does or not is another unrelated story)
05:42:32 <mm_freak> srhb: it's not that simple‚Ä¶  you need to "defail" properly at the end, so explicit recursion is probably your best bet
05:42:43 <srhb> Ah.
05:42:59 <mm_freak> srhb: but there is 'count'
05:43:14 <mm_freak> i don't know if it implemenets "up to" semantics, so check the documentation first
05:43:19 <ski> "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf> has a common definition of "strongly typed" in section 1.2
05:44:14 <mm_freak> XexonixXexillion: you certainly want (+ 3 "blah") to exit with an error instead of segfaulting‚Ä¶  my guess is that just like in haskell there is a primitive addition function that checks types
05:45:34 <mm_freak> of course the haskell version doesn't check types
05:46:08 <XexonixXexillion> mm_freak: It will signal type-error
05:46:24 <mm_freak> "it"?
05:46:46 <XexonixXexillion> the lisp environment
05:47:10 <XexonixXexillion> isn't signally type-error instead of adding 3 to the address of blah the presence of a type system?
05:47:21 <XexonixXexillion> s/signally/signalling/
05:48:30 <ski> i'm not sure dynamic folks would call this a "type system" ?
05:49:07 <ski> (possibly they would call it "type checking", though)
05:50:09 <tdammers> I'd say Lisp (CL / Scheme / whatev) definitely has a type system
05:50:17 <tdammers> just not at the compilation stage
05:50:33 <opqdonut> CL definitely does have compiler support for types
05:50:40 <opqdonut> I mean, compile-time checks
05:50:44 <tdammers> sure
05:50:46 <mm_freak> ski: according to that document haskell is not statically typed
05:50:53 <tdammers> but those aren't required for the compiler to work
05:51:06 <opqdonut> yeah I guess they aren't required in the spec
05:51:34 <ski> i'd think a contract checking system like in Racket would have a better claim for being called a "type system", in the dynamic world
05:51:37 <mm_freak> ski: correction:  haskell with ExistentialQuantification and/or RankNTypes isn't statically typed
05:51:47 <mm_freak> according to that document
05:52:15 <tdammers> I'm curious how one would argue that
05:52:25 <ski> mm_freak : i don't see that ?
05:53:20 <ski> (i don't think "the type of every expression can be determined by static program analysis" entails a requirement for type inference)
05:55:09 <latermuse> how does this powerset algorithm work exactly?  powerset = filterM (const [True, False])
05:55:13 <mm_freak> ski: let me use abbreviated syntax:  getSomething :: IO (exists a. a)
05:55:16 <ski> .. also, i don't think the presence of existentials refute that quote -- if they'd do, then ordinary parametric polymorphism would as well
05:55:24 <latermuse> > filterM (const [True, False]) [1..3]
05:55:26 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
05:55:42 <mm_freak> ski: static analysis can't find out what type this will result in
05:55:51 <ski> latermuse : for each element, nondeterministically select wheether to include it or not
05:55:54 <mm_freak> because potentially the type is determined at runtime
05:56:12 <ski> mm_freak : of course it can, the type is `IO (exists a. a)'
05:57:06 <latermuse> ski: how does it know how to do the permutations of the list that I gave it then?
05:57:22 <latermuse> (err not permutation)
05:57:39 <mm_freak> ski: perhaps the document isn't clear about when a type is "determined" =)
05:58:46 <mm_freak> ski: also the document defines "strongly typed" as "executes without type errors"
05:58:56 <mm_freak> so PHP is strongly typed according to that document
05:58:59 <ski> latermuse : it basically translates to roughly `do b0 <- [True,False]; b1 <- [True,False]; b2 <- [True,False]; return ([1 | b0] ++ [2 | b1] ++ [3 | b2])'
05:59:42 <ski> latermuse : which in terms of list comprehensions is `[[1 | b0] ++ [2 | b1] ++ [3 | b2] | b0 <- [True,False],b1 <- [True,False],b2 <- [True,False]]'
06:00:09 <ski> > [[1 | b0] ++ [2 | b1] ++ [3 | b2] | b0 <- [True,False],b1 <- [True,False],b2 <- [True,False]]
06:00:12 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
06:00:34 <latermuse> wow thanks a lot ski. that makes a lot of sense now.
06:01:11 <latermuse> <3
06:01:35 <ski> mm_freak : anyway, is the type of `f a' "determined" in `map :: forall a b. (a -> b) -> ([a] -> [b]); map f [    ] = []; map (a:as) = f a : map f as' ?
06:02:17 <ski> mm_freak : i agree about PHP
06:03:50 <ski> (as long as it doesn't invoke UB, i.e. as long as type inconsistencies are detected, it'd be strongly typed)
06:05:00 <ski> latermuse : btw, `[x | b]' for a boolean `b' was just a short way for me to say "keep `x' just in case `b'" -- you can of course express basically the same thing with guards or conditionals/`case'
06:05:17 <mm_freak> ski: you said that it's a common definition‚Ä¶  it's the first time i hear a definition, for which PHP is strongly typed
06:05:29 <mm_freak> and i strongly typedly disagree
06:05:38 * ski thought it was fairly uncontroversial
06:06:02 <ski> why would you want to deny PHP being strongly typed ?
06:06:08 <mm_freak> the most common definition of strongly typed is: "errors instead of implicit casts"
06:07:13 <mm_freak> there is a + for two numbers and a + for two strings‚Ä¶  PHP makes + work for any of the four possible combinations of the two
06:07:17 <ski> i thought the canonical examples of non-strongly, iow weakly, typed was things like C (specifically pointer casts)
06:07:23 <mm_freak> in fact i don't know how to make + fail with an error
06:09:27 <mm_freak> ski: perhaps "strongly typed" shouldn't be a language property, but rather a function property
06:09:28 <ski> doesn't Java invoke `toString' (implicit coercion ?) instead of erroring, when you concatenate with a string ?
06:09:35 <mm_freak> and it's that in haskell every function is strongly typed
06:10:03 <hpc> ski: yes; and there's a default implementation of toString in Object that shows you the pointer address
06:10:53 <ski> hpc : perhaps tasteless, but i don't understand why one would want to deny Java being strongly-typed on these grounds
06:11:25 <mm_freak> java may be called "strongly typed with some weird exceptions"
06:11:36 <hpc> mm_freak: which is funny because java exceptions are weird
06:11:48 <mm_freak> lol
06:11:53 <hpc> some of them are checked at compile-time and others are not
06:12:02 <hpc> and there's an entire other object heirarchy, Error
06:12:08 <hpc> which is like Exception but not catchable
06:12:18 <mm_freak> checked in what way?  type-checked?
06:12:27 <ski> (i think "checked" is perhaps the wrong word here)
06:12:29 <hpc> checked for being caught
06:12:50 <mm_freak> then it's just like PHP, where you have three different kinds of errors
06:12:52 <hpc> the compiler enforces that somewhere, every checked exception is caught
06:13:13 <mm_freak> the first and best kind, seldomly used:  exceptions
06:13:32 <mm_freak> the second kind:  PHP fatal errors (to catch those you have to register a global handler)
06:13:40 <mm_freak> and the worst kind:  -1, 0, null, ‚Ä¶
06:13:47 <mm_freak> or ""
06:13:53 <hpc> oh, there's more
06:14:00 <ski> hpc : depending, that could just mean that every exception not caught otherwise is caught by `main' (or really the starting code invoking it initially)
06:14:01 <hpc> some php functions use return parameters
06:14:09 * hackagebot csound-expression 1.0.3 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-1.0.3 (AntonKholomiov)
06:14:14 <hpc> because i guess they forgot to port ($x, $y) = func() over from perl?
06:14:38 <hpc> so you have to pass a reference to the function, then check if it is null after
06:14:45 <mm_freak> i'll stop right here‚Ä¶  everybody knows that i hate PHP
06:15:06 <hpc> ... how is it that i know so many wtfs about languages i don't use?
06:15:25 <mm_freak> hpc: simple: you know why you don't use them
06:15:35 <hpc> haha
06:17:41 <ski> mm_freak : btw, what would you call systems where type inconsistencies can lead to UB ?
06:18:18 <mm_freak> ski: UB?
06:18:24 <ski> Undefined Behaviour
06:18:45 <mm_freak> ski: like 3 + "x" = segfault?
06:18:49 <ski> yes
06:18:54 <ski> (or worse)
06:19:06 <mm_freak> good question
06:19:45 <mm_freak> since a common definition of weakly typed is, "implicit conversion instead of type error", i'd say it's neither strong nor weak
06:21:55 <sepp2k> mm_freak: I think a more useful definition of weakly typed would be "hides the error", which both implicit conversion and UB would meet.
06:22:41 <mm_freak> sepp2k: UB doesn't exactly mean to "hide the error"‚Ä¶  a definition that covers this is:  "doesn't result in a type error"
06:22:53 <mm_freak> however, it's not a useful definition‚Ä¶  i'd call these languages simply inconsistent
06:23:01 <typoclass> what is ub? (sorry, i just came in)
06:23:03 <sepp2k> I mean "x"+3 = segfault is still pretty harmless, but if you get "x"+3 = 42, you'll have a hard time finding out why your program acts differently than you expect.
06:23:13 <sepp2k> typoclass: Undefined behavior.
06:23:18 <typoclass> thanks
06:26:50 <parcs> back in the day people programmed with punch cards
06:27:05 <parcs> i think they wouldn't mind using php
06:29:34 <ski> hm .. i wonder if the sense of "weakly-typed" the Cardelli paper uses is older, and the one mm_freak mentioned is newer, due to weakly-typed languages in the former sense not being as common in use nowadays ..
06:34:46 <leoncamel> /ojinn/qui
06:35:25 <leoncamel> oops.. sorry.
06:35:33 <notdan> Hm, is it normal for cabal-install on Mac OS X to update executables but not link them in ~/Library/Haskell/bin ?
06:36:04 * typoclass thinks calling things 'dynamically typed' sounds way too positive. it's unfortunate
06:36:08 <geekosaur> "no" but I have certainly observed it not doing so
06:36:28 <geekosaur> it's presumably a bug but nobody has been able to provide a reproducible test case :/
06:36:53 <notdan> Ok I seem to have a lot of problems on this system...
06:37:20 <notdan> I've install haskell plaftorm using homebrew, so there is a cabal executable in /usr/local/Cellar and for some reason there is also ~/Library/Haskell/ stuff
06:38:00 <geekosaur> sounds like at some point you had the haskell.org/platform vedrsion installed, and it created your ~/.cabal/config
06:38:54 <geekosaur> well, actually, stuff installed via homebrew would go in /usr/local; cabal-install would put stuff in ~/Library/Haskell or ~/.cabal/bin depending on whose packaging
06:39:29 <notdan> I have ~/.cabal/config and ~/.cabal/config.platform
06:39:42 <notdan> Woah I've created such a mess
06:41:01 <ski> typoclass : i think it's more unfortunate that dynamic typers mean something not that related to what static typers mean, by "typed"
06:43:33 <typoclass> ski: how do you mean? haskell and a hypothetical python version could have similar type systems, only in python it's kinda pointless because the type errors occur only at runtime?
06:45:26 <ski> i mean several static typers would prefer to rename "dynamically typed" to "dynamically checked", except that the dynamic typers don't like that, since they're used to "dynamically typed" in their sense
06:45:54 <hpaste> latermuse pasted ‚ÄúHelp with insertion sort‚Äù at http://hpaste.org/84209
06:46:00 <latermuse> hey can you guys help me with this real quick?
06:46:06 <typoclass> ski: right
06:46:25 * typoclass renames dynamic typing to theological typing. "we just hope."
06:46:25 <ski> (since "typed" as used in "statically typed" resp. as used in "dynamically typed" isn't that connected to each other)
06:47:05 <monoidal> latermuse:
06:47:08 <monoidal> > [10..1]
06:47:10 <lambdabot>   []
06:47:26 <monoidal> > [10,9..1]
06:47:28 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
06:47:30 <latermuse> oh man
06:47:34 <latermuse> im retarded. thanks
06:48:24 <ski> (typoclass : btw, it's not clear how to check something has type `forall a. Int -> [a] -> [a]' at run-time)
06:49:54 <monoidal> with -XPolyKinds, is there a reason why is: `data A a where X :: A []; Y :: A Int` does not compile?
06:50:10 <ski> (.. checking `Int -> [String] -> [String]' at run-time would actually work, in a sense, with a contract checking system like in Racket, though)
06:50:40 <hpc> monoidal: polymorphic kinds are the same kind of polymorphism as regular polymorphism
06:50:46 <hpc> [] :: * -> *
06:50:49 <hpc> Int :: *
06:51:05 <hpc> and by applying both of them to A like that, it's forcing ghc to unify them
06:51:07 <hpc> which it can't
06:51:27 <hpc> monoidal: the key question to ask is, what is the kind of A?
06:51:37 <monoidal> hpc: I wanted k -> *
06:51:46 <ski> i presume monoidal wanted the kind of `A' to be `forall k. k -> *'
06:52:00 <hpc> ski: exists, you mean?
06:52:12 <hpc> existential kind polymorphism is not yet a thing
06:52:22 <ski> (which would actually mean `A' is a polymorphic *type* (not kind) ..)
06:52:28 <hpc> and afaict it's what you would need to pull this off as easily as possible
06:52:28 <typoclass> > let f [] ys = ys ; f xs _ = xs ; (...) x y = enumFromTo x y `f` (reverse $ enumFromTo y x) in (9...5) -- latermuse ;-)
06:52:30 <lambdabot>   [9,8,7,6,5]
06:53:01 <monoidal> hpc: why an existential is needed?
06:53:02 <ski> hpc : i meant what i wrote, so that both `A []' and `A Int' would be well kinded (with kind `*')
06:53:04 <typoclass> it's not entirely water-tight, but you get the idea
06:53:17 <ski> monoidal : no existential
06:53:48 <hpc> ski: the forall in that position is what we have already with kind polymorphism
06:53:52 <monoidal> on the other hand, that would mean that every GADT should have kind k1 -> k2 -> k3 -> ... kn -> * where ki are arbitrary
06:54:16 <ski> hpc : *nod* (except "kind polymorphism" is a misnomer)
06:54:57 <monoidal> we can write `data A a where X :: (a ~ []) => A a; Y :: (a ~ Int) => A a`
06:55:36 <ski> monoidal : i'd suppose it's just a limitation in the interaction between `GADTs' and `PolyKinds'
06:57:45 <hpc> ski: it's a limitation in the same way that foo :: a -> Int; foo "hello" = 1; foo False = 2 is a limitation
06:57:58 <ski> possibly
06:59:18 <hpc> i suppose you could turn it around and say the problem is our lack of GADT equivelent at the data level?
06:59:36 <ski> hm, how do you mean ?
06:59:49 <notdan> What's the point of being able to use type equivalence operator (~)? I mean, if we have a ~ b, can't we just replace 'a' with 'b' in the signature anyway?
06:59:54 <ski> (iow, what would the latter even mean ?)
07:00:14 <monoidal> notdan: true, but if you have say `F a ~ G b` where F, G are type functions...
07:00:14 <hpc> GADTs have kind * -> *
07:00:17 <latermuse> typoclass: hahaha ;)
07:00:18 <hpc> or something along those lines
07:00:18 <johnw> notdan: I think you are making an assertion to the type unifier
07:00:28 <johnw> otherwise, it doesn't know that a and b can be unified
07:00:33 <hpc> but they are limited in what specific type of kind * they can accept
07:00:42 <notdan> monoidal: ah, true
07:00:57 <notdan> Dammit, why can't I install hlint with the latest containers?
07:01:11 <ski> hpc : really ?
07:01:11 <notdan> bin % cabal install hlint                                                                         2013-03-17 17:56:53 dan
07:01:11 <notdan> Resolving dependencies...
07:01:11 <notdan> In order, the following will be installed:
07:01:11 <notdan> hscolour-1.20.3 (reinstall) changes: containers-0.5.2.1 -> 0.4.2.1
07:01:12 <notdan> hlint-1.8.43 (new version)
07:01:21 <notdan> wtf :(
07:01:29 <typoclass> notdan: use hpaste please
07:01:59 <typoclass> latermuse: i've thought about the "9...9" case, and it correctly gives [9]. it's more water-tight than i thought
07:02:02 <ski> hpc : i thought with `data Booly :: * -> * where B :: Booly Bool' that `Booly Int' was a perfectly legitimate type (but having no non-bottom value)
07:02:25 <notdan> typoclass: right, sorry
07:02:28 <hpc> oh right
07:02:36 <hpc> those pesky bottoms always getting in the way
07:03:07 <ski> even without bottoms, `Booly Int' would still be sensible
07:05:50 <aCube> a ~ b can also be used to make instance selection more "greedier", because the context is checked after the instance has been selected (idk if this is a valid usage, but it seemed to work in my case)
07:07:13 <ski> hm, when i try what passes for GADTs in MetaML (which is strict), the corresponding thing to `Booly Int' also works fine
07:10:34 <monoidal> I can write class A a; instance A Int; instance A [], though. what's the difference with the GADT?
07:11:33 <latermuse> typoclass: did you just put that together?
07:12:03 <tippenein> I'd like to learn haskell through one of the web frameworks. Is there one that has better documentation?
07:12:08 <latermuse> yesod
07:12:29 <latermuse> tippenein: http://www.yesodweb.com/book
07:12:44 <tippenein> thanks
07:12:56 <latermuse> no problem
07:13:58 <typoclass> latermuse: no, i put it together at some point, and today i copy-pasted it from my file for "vaguely interesting stuff that might be useful sometime" :-)
07:14:30 <latermuse> typoclass: hehe. its a fun line of code. i saved it too
07:16:24 <ski> monoidal : hm, how about `type'/`data' families ?
07:22:12 <monoidal> ski: they work
07:22:58 <ski> with `type instance A [] = ...; type instance A Int = ...', yes ?
07:23:08 <monoidal> ski: yes
07:23:20 <monoidal> ski: (and type family A (a :: k) :: *)
07:23:25 * ski nods
07:23:55 <srhb> Hmm. I'm having trouble reading ABNF for my IRC project and translating it to Parsec. In http://tools.ietf.org/html/rfc2812#section-2.3 I can't seem to disambiguiate nickname from servername. For instance, "foo" might be either, I think?
07:25:43 <geekosaur> srhb, the BNF is context dependent, you can't just by looking at the token stream determine what is a nickname and what is a server namer
07:25:55 <srhb> Ugh, how annoying.
07:26:47 <johnw> is there ever a reason to use MVar in addition to TMVar in the same app?
07:26:53 <srhb> I was hoping to parse it into Either Serverprefix Nickprefix
07:26:59 <srhb> But that seems completely hopeless now.
07:27:25 <monoidal> so, while I cannot define a GADT D with A :: D [] and B :: D Int, I can define a GADT with C a => D a and instances C Int, C []
07:27:33 <elliott> johnw: efficiency?
07:27:49 <elliott> monoidal: you can define such a GADT D with GHC HEAD, I believe
07:27:59 <monoidal> elliott: I can't
07:28:06 <elliott> hmm.
07:28:07 <johnw> elliott: is a TMVar significantly less efficient than an MVar?
07:28:16 <elliott> maybe you need a buncha kind annotations and stuff.
07:28:33 <elliott> johnw: I think they're just different. MVar is still the fundamental superfast locking primitive
07:28:42 <srhb> I can't believe any real IRC client obeys this structure.
07:29:11 * typoclass has some kind of rare parsec disability. i've mentioned it before. i always end up doing 'lines' and 'split ":"' on stuff, which somehow seems more manageable than parsec-based code
07:29:40 <srhb> That wouldn't really help in this case.
07:29:46 <srhb> Aside from making it all much less manageable.
07:29:55 <srhb> I can't disambiguate it whether or not I use Parsec.
07:30:00 <srhb> Or at least, I don't see how.
07:30:09 <typoclass> srhb: sure, it was tangential rambling, not really a suggestion
07:30:13 <srhb> Ah :P
07:30:17 <typoclass> :-)
07:31:11 <geekosaur> srhb, the IRC protocol is a state machine, just track the current machine state to know what you're lexing/parsing next
07:31:28 <srhb> geekosaur: I don't see how that is possible in this case
07:31:50 <srhb> ":foo cmd" is completely ambiguous.
07:31:54 <geekosaur> I may have misspoken earlier, if you are simply looking at a bunch of octents you cannot know just from those octets the machien state, but if you track the IRC state machine you should know exactly what's coming next
07:32:59 <geekosaur> and in the cases where you don't, the protocol forces an iontroducer of some kind (so, for example, all channel names start with one of a limited set of characters so that you can distinguish them from nicknames)
07:33:34 <srhb> Supposedly, the prefix (any message that starts with ':') will be followed by either a nick or a server name
07:33:53 <srhb> And in the case of nick, possibly (this is where the ambiguity arises) a hostname for the user, and maybe a username before that.
07:34:00 <typoclass> is it defined for all commands if they're from a server or not? or is there overlap in the sense that some commands can come from a server or a nick? in the first case, you could look at the cmd field of the message to determine if the part left of it is a server or a nick
07:34:36 <srhb> Hmm.
07:35:58 <srhb> It's possible I can disambiguate it from the command.
07:36:02 <srhb> Not exactly pretty, though.
07:36:19 <typoclass> srhb: you could maybe postpone it for later. parse it into a "name" field and leave it for the later logic ("case command of ...") to decide if it's going to view "name" as a server name or a nickname
07:36:40 <merijn> johnw: The performance difference between MVar and TMVar is hard to describe, since it depends on the odds of the transaction being restarted (which in turn depends on what else you're doing in any of the overlapping transactions)
07:36:40 <no-n> if I have a list of pairs how can I do something similar to map but for a function taking two parameters?
07:36:56 <srhb> Yeah, I might end up doing that. Just parse the Prefix as a Prefix, whatever that may be
07:37:01 <merijn> no-n: map + uncurry (or was it curry?)
07:37:03 <merijn> :t curry
07:37:04 <johnw> merijn: that makes sense
07:37:05 <lambdabot> ((a, b) -> c) -> a -> b -> c
07:37:10 <ski> > map (uncurry (+)) [(1,2),(3,4),(5,6)]
07:37:12 <lambdabot>   [3,7,11]
07:37:12 <merijn> :t uncurry
07:37:13 <lambdabot> (a -> b -> c) -> (a, b) -> c
07:37:18 <srhb> (What a silly protocol)
07:37:21 <merijn> Yeah, there you go. map + uncurry
07:37:37 <no-n> thanks!
07:37:53 <ski> no-n : .. while if you had two lists, you'd use `zipWith'
07:38:05 <no-n> yea
07:39:00 <monoidal> Ah. When I write "data C (a :: k) :: * where" instead of "data C (a :: k)" the error message is much better: Data constructor ‚ÄõA‚Äô cannot be GADT-like in its *kind* arguments
07:39:29 <monoidal> not sure why there is such restriction, but at least there is some explanation
07:39:35 <ski>   zipWith f as bs = map (uncurry f) (zip as bs)
07:40:08 <ski> monoidal : hm, what if you write `data C :: k -> * where' ?
07:40:19 <ski> (with `KindSignatures', of coursE)
07:40:46 <ski> (i suppose i'd expect the same, or similar, error message)
07:40:46 <monoidal> ski: same error
07:41:28 <latermuse> im loving applicative functors
07:41:43 <ski> hm, i wonder what they mean by "*kind* argument" there
07:41:45 <jmcarthur> the type signatures that ghci gives you when PolyKinds is enabled are really bad :\
07:42:05 <jmcarthur> they aren't even syntactically valid
07:42:22 <parcs> example?
07:42:59 <jmcarthur> i'll hpaste one along with the valid type
07:43:04 <monoidal> parcs: kinds are shown as parameters
07:43:24 <monoidal> like when you have a class A :: k -> *, messages mention instance A k a instead of A a
07:43:44 <ski> hm, i'm not even sure why they would talk about "kind arguments" for a *data* constructor ..
07:43:57 <notdan> http://www.reddit.com/r/haskell/comments/1agqys/problems_installing_cabaldev_on_os_x/
07:44:11 * hackagebot persistent-template 1.1.3 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.1.3 (MichaelSnoyman)
07:44:29 <monoidal> ski: I believe data C (a :: k) is internally converted to "data C k a"
07:44:42 <hpaste> jmcarthur pasted ‚Äúterrible type from ghci‚Äù at http://hpaste.org/84212
07:44:49 <jmcarthur> parcs: ^^
07:44:51 <ski> monoidal : *nod*, `A :: forall k. k -> *' being thought of as `A :: (k :: **) -> k -> *' (or whatever is the actual notation for `**')
07:45:20 <ski> monoidal : yes, but what does that have to do with (purported) *kind* arguments of the *data* constructor `A' ?
07:46:42 <monoidal> ski: ah, right. it should say "Type constructor `C` should not be GADT-like in its *kind* arguments", if I understood correctly
07:46:50 <ski> if you had `data C :: k -> * where A :: C []', then i don't see why one would say `A' has any argument at all, let alone kind arguments
07:47:38 <ski> (`C' would have an implicit kind argument of `* -> *' in that signature for `A' -- which is different from `A' having any (kind or not) argument)
07:48:26 <jmcarthur> might this be summarized by saying that ghc doesn't support kind equality contraints?
07:48:36 <ski> if we had `data C :: k -> * where A :: forall (a :: *). C (Either a)', then one could arguably say that `A' has a *type* argument
07:50:11 <ski> and if we had `data C :: k -> * where A :: forall_kind k. forall (a :: k). C a', then one could arguably say that `A' has a *kind* (as well as a type) argument
07:53:24 <ski> monoidal : sounds more reasonable
07:53:49 <ski> jmcarthur : hm, i don't know about that
07:54:21 <monoidal> i think internally GHC uses constraints with kind equalities somewhere
07:54:57 <elliott> maybe the unifying-types-and-kinds thing will allow us to do this.
07:55:14 <jmcarthur> ski:   `data C :: k -> * where A :: C []`  might be treated by ghc as something like  `data C (k :: **) (a :: k) = (k ~ *, a ~ []) => A
07:55:37 <monoidal> since constraints appear in types such as "C => t" we'd also have constraint-kinds in kinds "C => k"
07:56:52 <ski> jmcarthur : then why does `data C :: k -> * where A :: (a ~ []) => C a' work ?
07:57:22 <jmcarthur> oh it *does* work? i was under the impression from the conversation that it does not
07:57:23 <monoidal> ski: bug in 7.6, head rejects
07:57:33 <ski> (also, itym s/k ~ \*/k ~ \* -> \*/)
07:57:41 <jmcarthur> ah right
07:58:23 <jmcarthur> it does not seem to work for me in 7.6.2
07:59:06 <jmcarthur> I'm interpreting "Data constructor `A' cannot be GADT-like in its *kind* arguments" to mean that the k ~ * -> * constraint is not allowed
07:59:09 <monoidal> ah, I did something wrong. indeed 7.6 and head reject
07:59:17 <ski> monoidal : hm, i don't follow how that'd entail constraint-kinds
07:59:24 <ski> (in kinds)
08:00:04 <jmcarthur> oh, indeed the next line of the error message says this:  A :: forall (a :: * -> *). a ~ [] => C (* -> *) a
08:00:13 <jmcarthur> a :: * -> *  is like  k ~ * -> *
08:00:27 <monoidal> ski: sorry, I did not mean that constraints-in-kinds appear, but in principle they could do
08:01:15 <ski> monoidal : i was just not seeing how it would follow from constraints appearing in types and [some other implicit starting point]
08:04:15 <skp> hey
08:04:31 <skp> I have a list of dependencies for a cabal project
08:04:45 <skp> where the dependencies are local to my computer (for now)
08:04:58 <skp> I mean, not released on hackagedb yet
08:05:06 <skp> how can I deal with such a situation?
08:05:16 <jmcarthur> what do you mean "deal with"?
08:05:24 <jmcarthur> what problem does it cause you?
08:05:29 <skp> well
08:05:31 <parcs> locally install the dependencies first
08:05:39 <skp> oh
08:05:41 <skp> hm
08:05:47 <skp> but if the dependencies are also wip?
08:05:57 <skp> s/if/what if
08:06:00 <skp>  /
08:06:02 <jmcarthur> you could use cabal-dev or something if you don't want to actually install them
08:06:15 <skp> cabal-dev, hm‚Ä¶
08:06:19 <skp> I need to read about it
08:06:57 <jmcarthur> if all your projects are put into a directory structure like   my-multilib-project/{lib1,lib2,lib3}  you can cd into my-multilib-project and say `cabal-dev install lib1 lib2 lib3`
08:07:12 <jmcarthur> where lib1, lib2, and lib3 are normal cabal projects
08:07:20 <parcs> if they are a WIP then use -i to add their directory to the list of directories to search modules for
08:07:30 <skp> nope the project are all in the same directory, not nested
08:07:40 <skp> oh
08:07:40 <skp> -i
08:07:41 <skp> nice
08:07:44 <jmcarthur> and cabal-dev will make a local directory for your installed libs instead of installing them into your user or global package database
08:07:49 <skp> on the cabal configure?
08:07:50 <parcs> then you can do 'ghci -i../dep1 -i../dep2 Main.hs' or whatever
08:08:04 <parcs> what exactly is your goal?
08:08:10 <skp> parcs: I use cabal
08:08:23 <skp> maybe I just should switch to cabal-dev
08:08:38 <parcs> what exactly is your goal?
08:09:14 <skp> parcs: I have a few projects
08:09:15 <notdan> What does ExitFailure 127 mean in Cabal? http://hpaste.org/84215
08:09:18 <skp> in a directory
08:09:18 <romand> hi, is there any standard function like: a <||> b = if a == empty then b else a ?
08:09:26 <notdan> Even with -v there are no specific error :(
08:09:29 <skp> ~/dev/{p1,p2,p3}
08:09:38 <skp> and ~/dev/foo
08:09:44 <skp> where foo is my ¬´ main ¬ª app
08:09:48 <jmcarthur> romand: for certain types, <|>
08:09:49 <monoidal> romand: mplus for Maybe
08:10:02 <skp> the pn projects are WIP libraries
08:10:18 <skp> I just want to be able to use them with cabal on the foo project
08:10:21 <geekosaur> 127 is likely to mean exec failed with file not found
08:10:54 <geekosaur> cabal does not define those values, they come from whatever program cabal tried to run
08:10:54 <romand> I want "foo" <||> "bar" = "foo", not "foobar"
08:10:54 <jmcarthur> romand: but beware, for some types <|> is more like append
08:11:05 <jmcarthur> it depends on the type
08:13:37 <skp> woot
08:13:49 <skp> cabal-dev seems to be just AWESOME
08:14:04 <jmcarthur> cabal-install itself will have cabal-dev-like features soon
08:14:15 <skp> cabal-install?
08:14:19 <skp> what‚Äôs that?
08:14:21 <jmcarthur> the command called cabal
08:14:35 <jmcarthur> it's actually cabal-install, and Cabal is the library
08:14:44 <romand> so, if I need 'failover' operator for strings, I need to write it myself?
08:14:48 <skp> I see
08:15:06 <jmcarthur> romand: it doesn't sound like a very common operation to me
08:15:09 <ski> @type \a b -> maybe b (const a) (listToMaybe a)
08:15:10 <lambdabot> [a] -> [a] -> [a]
08:15:28 <jmcarthur> @pl \a b -> maybe b (const a) (listToMaybe a)
08:15:28 <lambdabot> ap (flip . flip maybe . const) listToMaybe
08:15:32 <jmcarthur> @pl \b a -> maybe b (const a) (listToMaybe a)
08:15:32 <lambdabot> (`ap` listToMaybe) . (. const) . maybe
08:15:33 <skp> fuck
08:15:36 <skp> can‚Äôt install cabal-dev
08:15:37 <skp>     cannot find normal object file `dist/build/cabal-dev/cabal-dev-tmp/Distribution/Dev/InterrogateCabalInstall.o'
08:15:55 <xiamx1> ragerage :D
08:16:17 <skp> how am I supposed to fix that?
08:16:21 <latermuse> lots of 404 not founds on this page: http://hackage.haskell.org/package/base/
08:16:26 <monoidal> romand: if possible, I'd change the type to Maybe String
08:16:51 <jmcarthur> :t \b -> liftA2 (maybe b) const listToMaybe
08:16:52 <lambdabot> [a] -> [a] -> [a]
08:19:56 <jmcarthur> skp: no idea. it didn't do that for me
08:20:03 <jmcarthur> skp: what version of cabal-install are you using?
08:20:04 <skp> I use yaourt
08:20:08 <skp> through arch
08:20:09 <jmcarthur> oh
08:20:17 <skp> it seems to work now
08:20:17 <jmcarthur> i never have good luck with distributionized packages
08:20:22 <jmcarthur> i always just use cabal-install
08:20:22 <skp> huh
08:20:44 <skp> I tried withcabal-install version 1.16.0.2
08:21:48 <skp> ok
08:21:51 <skp> I have cabal-dev
08:21:53 <skp> :)
08:21:53 <jmcarthur> yeah that's the version i'm using. since i now realize you are on arch i would expect you to be up to date :)
08:21:57 <skp> let‚Äôs try it!
08:22:12 <skp> yeah
08:22:16 <skp> arch is awesome for that
08:23:34 <jmcarthur> also i now realize you may have had some misunderstanding about what we meant by "install" earlier
08:23:53 <skp> ?
08:23:54 <jmcarthur> you can use cabal-install to install your packages in your home directory without having to make a pacman package or something
08:24:08 <jmcarthur> and ghc knows where to look already
08:24:13 <skp> I know
08:24:15 <jmcarthur> okay
08:24:17 <jmcarthur> just checking
08:24:30 <skp> I don‚Äôt use yaourt
08:24:39 <skp> I always install haskell package with cabal
08:24:46 <skp> but for cabal-dev
08:25:02 <skp> yaourt does the job while cabal doesn‚Äôt
08:25:10 <jmcarthur> wha-?
08:25:12 <jmcarthur> it worked for me
08:25:54 <skp> I don‚Äôt know what happened
08:26:04 <romand> do I get it right that purpose of cabal-dev is somehow similar to 'bundler' in ruby, i.e. provide way of reproducable builds?
08:26:20 <jmcarthur> no idea what bundler is
08:26:39 <jmcarthur> cabal-dev is just a way to set up an environment separate from your user or global environments
08:26:43 <jmcarthur> a sandbox, if you will
08:27:44 <skp> it sounds great, seriously
08:28:27 <geekosaur> romand, cabal-install does reproducible builds, at least to the extent that you have good dependencies. I think there are tools to help work out the dependency declarations
08:30:00 <jmcarthur> if you don't have a cabal project yet, cabal init will work out some dependencies automatically for you, but if i recall correctly it doesn't think very hard about package version numbers
08:30:51 <romand> haskell libraries change all the time; if I have build my code a month ago, it may not compile today with new libraries versions; how do I 'remember' libraries versions I use, preferably in some file I can commit in cvs?
08:30:57 <jmcarthur> geekosaur: any recollection about the names of these tools? i'd heard proposals for such things before, but don't remember if anything came of them
08:31:13 <jmcarthur> romand: a .cabal file can do that already
08:31:20 <jmcarthur> romand: you just list your dependencies in there
08:31:23 <geekosaur> not off the top of my head, I thought I saw an announcement in -cafe though
08:32:10 <romand> jmcarthur: I write weak restrictions like 'frobnificator >= 0.1' there
08:32:12 <jmcarthur> romand: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
08:32:24 <jmcarthur> oh
08:32:31 <jmcarthur> so you want a separate way to constrain it?
08:32:55 <romand> but when I do cabal install, it installs specific version
08:33:28 <romand> there may be a number of versions that satisfy .cabal restrictions
08:34:00 <geekosaur> http://hackage.haskell.org/package/cabal-progdeps http://hackage.haskell.org/package/cblrepo http://hackage.haskell.org/package/packdeps look interesting but not exactly what I thought I remembered :/
08:34:17 <romand> what I'm trying to avoid is a situation where I can't get my code compiled after updating dependencies
08:34:18 <skp> I tried the add-source CLI parameters of cabal-dev
08:34:30 <skp> to install in the sandbox private dependencies
08:34:46 <skp> but it doesn‚Äôt work since ghc can‚Äôt resolve import modules
08:34:55 <skp> Could not find module‚Ä¶
08:34:57 <jmcarthur> romand: maybe you could just keep a separate patch in your repo for your own builds that you just never share or upload to hackage. this is easier with some tools than with others
08:35:57 <jmcarthur> i do sometimes keep a bundle of patches that i don't push externally when i want a project to be slightly different for me than for other people
08:37:07 <jmcarthur> i normally just annotate them with something like PRIVATE and set darcs to not push anything with PRIVATE by default. it's been a while since i did this though
08:37:12 <romand> not sure I get you right... what are those patches and how they help with problem I described?
08:37:25 <jmcarthur> the patch in this case would be to tighten the version constraints
08:37:33 <jmcarthur> in the cabal file
08:38:29 <romand> ah you suggest to constrain deps to specific versions?
08:38:34 <jmcarthur> yes
08:39:15 <jmcarthur> that is what i intended before, but i interpreted your objection as wanting to keep the cabal file in a state that makes sense for public consumption (looser constraints), so i went into this patch thing
08:39:42 <romand> got you, that seems reasonable, thanks!
08:41:32 <jmcarthur> skp: if you do what i said before where you just cabal-dev install all your libraries at once it should work out the external dependencies for you
08:41:55 <jmcarthur> and the internal ones are specified implicitly by that command
08:42:43 <jmcarthur> that kind of setup is where you just have multiple libraries that are logically a part of the same project. i find it more managable than separate sandboxes for each one
08:42:51 <notdan> Does anyone here have experience with ghc-mod? For some reason ghc-mod check fails on my file (it cannot find the Text.XML.HXT.Core module), but ghc-mod list has Text.XML.HXT.Core as part of its output
08:45:04 <johnw> notdan: i keep solving that, and keep forgetting how I solve it :(
08:46:34 <notdan> Nevermid, turns out I had cabal-dev/ folder somewhere up the file system tree
08:46:37 <notdan> which messed everything up
08:46:49 <johnw> ah, yes indeed
08:46:53 <johnw> one of the features of ghc-mod!
08:47:26 <skp> 16:41 < jmcarthur> skp: if you do what i said before where you just cabal-dev install all your libraries at once it should work out the  external dependencies for you
08:47:34 <skp> you mean
08:47:50 <skp> install each dependency?
08:47:53 <jmcarthur> cd my-multilib-project; cabal-dev install lib1 lib2 lib3
08:48:03 <skp> wouldn‚Äôt it install them locally?
08:48:17 <jmcarthur> cabal-dev would create a sandbox inside my-multilib-project
08:48:28 <skp> huh?
08:48:38 <jmcarthur> h/o
08:48:47 <jmcarthur> i'll hpaste an example (if my old libraries still build...)
08:48:53 <skp> dev/{p1,p2,foo}
08:48:56 <skp> cd foo
08:48:59 <jmcarthur> no
08:49:03 <jmcarthur> h/o
08:49:14 <skp> cabal-dev add-source ../p1 ../p2
08:49:16 <skp> cabal-dev install
08:49:20 <jmcarthur> no
08:49:21 <skp> that‚Äôs what I typed
08:49:38 <jmcarthur> that's a viable way to go, but it's more work and harder to maintain
08:49:52 <Philonous> I really wish there was a function addrFamily :: SockAddr -> Family in network
08:50:22 <skp> I‚Äôm all ears then
08:51:11 <jmcarthur> well, it didn't build for me since my packages are too out of date, but i'll paste what i did anyway
08:51:44 <hpaste> jmcarthur pasted ‚Äúcabal-dev‚Äù at http://hpaste.org/84217
08:51:49 <jmcarthur> skp: ^^
08:52:54 <jmcarthur> ignore the stray cabal-dev directory in the tree output... shouldn't be there
08:54:24 <jmcarthur> oh woops
08:54:35 <jmcarthur> skp: that didn't work because i didn't make it clear in the command that those are directories
08:54:38 <jmcarthur> sorry, it's been a while
08:54:44 <jmcarthur> i will paste a new session
08:55:34 <hpaste> jmcarthur annotated ‚Äúcabal-dev‚Äù with ‚Äúcabal-dev (corrected)‚Äù at http://hpaste.org/84217#a84219
08:55:39 <jmcarthur> skp: ^^
08:55:53 <skp> thank you
08:55:56 <jmcarthur> you need the trailing slashes on the lib names or else it will try to get them from hackage instead
08:56:44 <skp> I se
08:56:45 <skp> see
08:56:48 <skp> thanks
08:56:53 <jmcarthur> np
08:58:30 <jmcarthur> to be clear, this is what i would do if i'm developing all the libraries simultaneously. if i tend to work on just one at a time, i would still consider the one-sandbox-per-library approach
08:58:54 <jmcarthur> it just means that switching from one library to another is more painful
08:59:11 <jmcarthur> but working within just one is a bit nicer that way
08:59:34 <skp> ok
08:59:35 <skp> I see
08:59:38 <skp> actually
08:59:47 <skp> I have ‚Äì to remind ‚Äì these:
08:59:57 <skp> ~/dev/{p1,p2,p3,foo}
08:59:57 <skp> so
09:00:00 <skp> cd ~/dev
09:00:09 <skp> cabal-dev install p1 p2 p3
09:00:13 <skp> and foo too
09:00:19 <jmcarthur> cabal-dev install p1/ p2/ p3/ foo/
09:00:23 <jmcarthur> slashes
09:00:26 <skp> and it runs it cabal-dev/
09:00:29 <skp> yeah
09:00:33 <skp> it seems to be ok
09:00:40 <skp> yes!
09:00:42 <skp> installed
09:00:43 <skp> :)
09:00:45 <skp> thank you!
09:00:49 <jmcarthur> welcome
09:00:53 <skp> and hm
09:01:11 <skp> since I‚Äôm writting an app called foo
09:01:19 <skp> do I have to ¬´ install it ¬ª too?
09:01:25 <skp> cabal-dev configure
09:01:27 <skp> cabal-dev build
09:01:28 <skp> ?
09:01:46 <jmcarthur> if foo was in your first run then it should already be built
09:02:18 <skp> it‚Äôs not
09:02:54 <skp> I have typed
09:02:55 <jmcarthur> cabal-dev install foo/ then :)
09:03:03 <skp> cabal-dev install p1 p2 p3
09:03:06 <skp> it‚Äôs not a lib
09:03:09 <skp> and fails to install
09:03:21 <jmcarthur> err
09:03:38 <skp> skp@orchid ~/dev % cabal install worlds/
09:03:38 <skp> Resolving dependencies...
09:03:38 <skp> cabal: Could not resolve dependencies:
09:03:38 <skp> trying: worlds-0.1.0.0
09:03:42 <jmcarthur> that should be orthogonal to it being a lib vs. exe
09:03:44 <skp> oups
09:03:47 <skp> cabal-dev*
09:04:04 <skp> nvm then :D
09:04:06 <skp> all my fault
09:13:55 <skp> hm
09:14:04 <skp> if a package has a dependency with SDL
09:14:16 <skp> if I have a dependency with such a package
09:14:24 <skp> have I a dependency with SDL?
09:14:30 <skp> or is the dependency imported?
09:15:06 <geekosaur> it should be imputed automatically
09:15:21 <skp>     Could not find module `Graphics.UI.SDL'
09:15:21 <skp>     It is a member of the hidden package `SDL-0.6.4'.
09:15:21 <skp>     Perhaps you need to add `SDL' to the build-depends in your .cabal file.
09:15:25 <skp> :(
09:15:49 <mauke> that looks like you're trying to use SDL yourself
09:16:11 <geekosaur> ^^
09:16:11 <skp> no
09:16:19 <skp> I‚Äôm not
09:16:27 <mauke> prove it
09:16:53 <skp> hm ok
09:17:00 <skp> the problem was in hidden files
09:17:08 <skp> I removed them
09:17:14 <skp> problem solved
09:17:22 <skp> they might be using SDL indeed
09:18:15 <skp> ok
09:18:29 <skp> I‚Äôm off
09:18:34 <skp> thank you again!
09:18:42 <skp> see you
09:24:14 * hackagebot computational-algebra 0.0.2.0 - Well-kinded computational algebra library, currently supporting Groebner basis.  http://hackage.haskell.org/package/computational-algebra-0.0.2.0 (HiromiIshii)
09:29:14 * hackagebot nsis 0.2.1 - DSL for producing Windows Installer using NSIS.  http://hackage.haskell.org/package/nsis-0.2.1 (NeilMitchell)
09:44:50 <gspr> Is there a reason CTime is not at instance of Integral? Does it sounds safe to assume that a reasonable toIntegral can be written by taking the numerator after passing the CTime to toRational (CTime *is* an instance of Real)?
09:44:55 <gspr> *sound
09:54:15 * hackagebot hakyll-convert 0.1.0.0 - Convert from other blog engines to Hakyll.  http://hackage.haskell.org/package/hakyll-convert-0.1.0.0 (EricKow)
09:57:21 <mustermark> I'm having some trouble with typeclasses.
09:57:26 <mustermark> Relevant code: https://gist.github.com/anonymous/1f60dcf2a450d91764eb
09:58:08 <mustermark> The commented out line on the bottom is giving me an error where there's No instance for (BoardLookup Square [a])
09:58:28 <mustermark> arising from the use of !
09:58:36 <mustermark> Why would that not work?
10:07:54 <Botje> I think fundeps solve this.
10:08:04 <monoidal> mustermark: try adding a fundep class BoardLookup key value | key -> value where
10:08:25 <monoidal> mustermark: does the error say something about ambigous type variable?
10:09:15 * hackagebot nptools 0.6.0 - A collection of random tools  http://hackage.haskell.org/package/nptools-0.6.0 (NicolasPouillard)
10:09:57 <mustermark> It doesn't say so outright, but it's talking about a [a] where it should be talking about a list of coords
10:10:18 <Botje> mustermark: length doesn't care what type of list it's measuring
10:11:03 <monoidal> mustermark: imagine you would add to your code "instance BoardLookup Square [Int] where ...". now the compiler would not know whether you meant length (b ! Owned h) for this instance or the other
10:11:56 <ab9rf> 'a collection of random tools'?  that description is a bit vague.
10:11:58 <mustermark> Aaah, that makes sense. It compiles now!
10:13:42 <mustermark> If I wanted to later add an instance BoardLookup Foo Square, would that mess up the functional dependancy at all?
10:16:44 <monoidal> mustermark: it would still work (assuming you won't add also instance BoardLookup Foo X for some different X)
10:17:30 <mustermark> That makes perfect sense.
10:17:53 <shachaf> hi monoidal
10:18:09 <monoidal> hi
10:18:11 <mustermark> Is it a sign of codesmell when you need to enable weird language parameters like MultiParamTypeClasses and FunctionalDependancies?
10:18:14 <shachaf> Thanks for finishing that patch! I would probably only have gotten to it at the end of this month.
10:18:41 <Botje> mustermark: MPTC and fundeps are quite standard in modern haskell.
10:19:21 <mustermark> They're just not in core haskell because of compatability?
10:19:32 <mustermark> (Also THANKS SO MUCH <3 <3 <3)
10:21:12 <mastensg> Is it possible to convince Haskell that a C function is pure, so that it can run in parallel?
10:21:43 <Hermit> mastensg: what's preventing you from doing that?
10:22:35 <Botje> mustermark: the GHC devs insist on keeping the haskell98 standard by default
10:22:51 <ab9rf> is there a newer standard?
10:22:52 <monoidal> Botje: 2010
10:23:06 <Botje> 2010 doesn't have fundeps? O_o
10:23:24 <Eduard_Munteanu> 2010 doesn't have MPTCs. :(
10:23:25 <monoidal> Botje: no, 2010 is a minor extension
10:25:52 <merijn> mustermark: Most haskell extensions are considered good (or at least acceptable), as long as you don't mind not being portable outside GHC (which is generally not seen as a really big problem)
10:26:04 <merijn> There is a good/bad/ugly list at: http://stackoverflow.com/questions/10845179/which-haskell-ghc-extensions-should-users-use-avoid
10:26:12 <Igloo> The GHC default is 2010 + NondecreasingIndentation - DatatypeContexts
10:26:21 * mcstar <3 UndecidableInstances
10:26:23 <skp> hey
10:26:34 * bitonic <3 turing complete type systems
10:26:54 <flux> indeed, all great type systems are turing complete. for example, just look at c++!
10:27:17 <bitonic> I know right?
10:27:18 <merijn> mustermark: Personally I'd try to avoid the ugly ones (especially, Undecidable/Overlapping/IncoherentInstances), but most of the others are considered very sane and reasonable
10:27:31 <elliott> UndecidableInstances isn't that bad. even mtl uses it
10:27:32 <skp> I need to manipulate matrix for game dev
10:27:34 <mcstar> the previous discussion on strongly-typedness was funny
10:27:36 <skp> what lib should I use?
10:27:40 <skp> write my very own?
10:27:45 <Botje> merijn: nice list, thanks!
10:27:50 <merijn> elliott: I'm not saying it's bad, I'm saying I'd avoid it as a newcomer
10:28:34 <luisalima> ? src concat
10:28:40 <luisalima> ?src concat
10:28:40 <lambdabot> concat = foldr (++) []
10:28:41 <merijn> ExistentialQuantification sometimes causes ex-OOP programmers to try the "existential anti-pattern", but otherwise it's fine. The others make perfect sense IMO
10:28:44 <mastensg> Hermit: I don't know how.
10:29:07 <bitonic> I‚Äôd say that UndecidableInstances *should* be avoided, if possible
10:29:18 <merijn> elliott: It's a bit annoying if you don't know what you're doing and cause GHC to hang during compilation
10:29:36 <Hermit> mastensg: nevermind, doesn't look like it's possible. I was asking because I thought some clever trick with monads was needed or something. I'd like to be more helpful...
10:30:06 <monoidal> mastensg: in principle, if you give it a type without IO haskell knows it's pure
10:30:28 <mastensg> The type is: c_mandelbrot :: Float -> Float -> Int
10:30:38 <monoidal> mastensg: whether it's possible to run it in parallel, I'm not sure
10:30:45 <merijn> mastensg: Yes, FFI functions have safe/unsafe annotations, I forget which is which
10:31:16 <merijn> mastensg: One means that GHC should consider the function "pure"
10:31:33 <shachaf> No, they don't really mean that.
10:31:48 <shachaf> Well, OK, I have no idea what "pure" means.
10:32:03 <mustermark> Oh man, UndecidableInstances is awesome.
10:32:19 <mustermark> Now I just need to find the language extension that will let me do comprehensions over things that arent lists :(
10:32:29 <merijn> mustermark: You say that now, but wait until it makes the compiler infinite loop :p
10:32:29 <monoidal> mustermark: -XMonadComprehensions i believe
10:32:35 <elliott> merijn: well, GHC will never hang.
10:32:41 <merijn> mustermark: Haskell2010 has MonadComprehensions
10:32:44 <elliott> that does not happen with just turning UndecidableInstances on.
10:32:52 <monoidal> merijn: I believe ghc not h2010
10:33:18 <monoidal> merijn: or Haskell X for some X < 98
10:33:23 <merijn> monoidal: MonadComprehensions are an extension in GHC for h98, but I was pretty sure they're back in the 2010 standard?
10:33:32 <merijn> They used to be standard before 98 too, yes
10:33:41 <monoidal> merijn: i thought they are not
10:34:04 <mastensg> unsafe seems to help: http://www.ping.uio.no/~mastensg/mandel.png
10:34:40 <monoidal> merijn: according to http://www.haskell.org/haskellwiki/Haskell_2010, they are not
10:34:53 <merijn> hmm, my bad
10:34:59 <shachaf> foreign import "unsafe" will certainly be faster, but you should understand all the implications of using it.
10:35:06 <mustermark> That's amazing O_O.
10:35:11 <shachaf> It doesn't really have anything to do with "purity", though.
10:35:25 <mustermark> But for some reason ghc 7.4 can't find the language extension :C
10:35:43 <shachaf> s/"//g
10:35:46 <mwc> What's a good place to learn about the RTS runtime behaviour for people attempting to build multilanguage applications? Specifically info w.r.t. the RTS response to signals, anything I need to be aware with regards to C threads in the same process, etc.
10:36:09 <merijn> mustermark: Did you include the final s? i.e. "MonadComprehensions" instead of "MonadComprehension"
10:38:01 <mustermark> merijn: Yeah, no luck :(
10:41:12 <merijn> Odd...
10:42:35 <mustermark> I'm going to try reinstalling, because if I can get monad comprehensions to work I'll never program in anything else ever again.
10:42:58 <Botje> mustermark: monad comprehensions are probably not what you want.
10:43:08 <RenJuan> mwc, why would that be a spot for translations?
10:43:24 <RenJuan> (assuming you mean human natural language, not ffi)
10:43:41 <mwc> no, FFI, C + Haskell
10:43:50 <RenJuan> ah
10:45:38 <RenJuan> in any case it's all open source and there's expository docs on that stuff, prolly slightly to majorly out of date
10:45:57 <RenJuan> out of date or fragmentary wrt to whole topic
10:46:35 <mwc> Yeah, there's the RTS docs on the trac, but that seems to be more targeted to people hacking inside the RTS, I'm more looking for the guidelines on how my threads needs to interact with the RTS threads
10:49:11 <mustermark> I had to reinstall haskell because the one from brew was borked, but it works now. This is the best morning ever, thanks guys!
10:49:16 * hackagebot clckwrks-plugin-page 0.1.4 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.1.4 (JeremyShaw)
10:49:46 <RenJuan> brew?
10:49:55 <mustermark> the OSX package manager
10:50:19 <RenJuan> macports homebrew?
10:50:21 <jrajav> *an
10:50:31 <jrajav> Macports is another one
10:59:17 * hackagebot clckwrks-plugin-page 0.1.5 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.1.5 (JeremyShaw)
11:03:32 <yitz> mwc: start with the ghc documentation about the -threaded option. maybe a google search for other stuff about ghc threads...
11:03:56 * mwc nods
11:04:05 <yitz> mwc: once you get the basics of how that works, if you have any specific questions, ask here or on #ghc/.
11:04:08 <yitz> #ghc
11:04:09 <mwc> thanks.
11:05:20 <Nolrai> Whats the standard way to iterarate an (a -> IO a) function n times?
11:06:13 <Nolrai> Is anyone here?
11:06:16 <srhb> Sure
11:06:21 <srhb> About a thousand people :-)
11:06:28 <mwc> @type foldl
11:06:29 <copumpkin> can't think of anything much nicer than folding >=> over a replicate
11:06:29 <lambdabot> (a -> b -> a) -> a -> [b] -> a
11:06:37 <mwc> er, meant to follow that with a (>>=)
11:06:42 <mwc> @type foldl (>>=)
11:06:43 <lambdabot> Monad m => m a -> [a -> m a] -> m a
11:07:03 <Taneb> Nolrai, I generally use fix (foo >>)
11:07:05 <ab9rf> copumpkin: i was thinking a fold over something but couldn't think of what
11:07:06 <mwc> so you need a list with n copies of your function
11:07:15 <Taneb> :t fix (?foo >>)
11:07:16 <lambdabot> (?foo::m a, Monad m) => m b
11:07:17 <copumpkin> :t Data.Foldable.foldMap Kleisli
11:07:18 <lambdabot> (Foldable t, Monoid (Kleisli m a b)) => t (a -> m b) -> Kleisli m a b
11:07:28 <ab9rf> my son is running around in circles right now and that's making it hard for me to think
11:07:30 <elliott> Taneb: that's forever foo
11:07:32 <copumpkin> :t (Data.Foldable.foldMap Kleisli .) . replicate
11:07:34 <lambdabot> Monoid (Kleisli m a b) => Int -> (a -> m b) -> Kleisli m a b
11:07:41 <copumpkin> :t runKleisli . (Data.Foldable.foldMap Kleisli .) . replicate
11:07:42 <lambdabot>     Couldn't match expected type `Kleisli m0 a0 (t0 (a1 -> m1 b0))'
11:07:42 <lambdabot>                 with actual type `a2 -> [a2]'
11:07:42 <lambdabot>     Expected type: Int -> Kleisli m0 a0 (t0 (a1 -> m1 b0))
11:07:55 <copumpkin> :t ((runKleisli .Data.Foldable.foldMap Kleisli) .) . replicate
11:07:56 <lambdabot> Monoid (Kleisli m a b) => Int -> (a -> m b) -> a -> m b
11:07:58 <Nolrai> Taneb: but that runs it an infinte number of times..
11:08:24 <copumpkin> oh dammit
11:08:28 <mwc> . take n . replicate :)
11:08:30 <copumpkin> Kleisli isn't a Monoid
11:08:32 <Taneb> Nolrai, I was wrong and getting mixed up
11:08:36 <ab9rf> yeah
11:08:39 <copumpkin> mwc: take n . repeat?
11:08:44 <mwc> that's it
11:09:17 * hackagebot universe 0.0 - Classes for types where we know all the values  http://hackage.haskell.org/package/universe-0.0 (DanielWagner)
11:09:21 <mwc> always get repeat and replicate mixed up
11:14:17 <ab9rf> isn't take n . repeat just replicate n?
11:14:39 <shachaf> It is.
11:14:46 <copumpkin> yes
11:16:48 <hpc> when a scifi monster replicates forever, that's dangerous
11:16:59 <hpc> but when a secret message repeats forever, that's predictable and easy to decode
11:17:09 <hpc> haskell makes secret messages, not scifi monsters
11:17:19 <magicman> @type replicate forever
11:17:21 <lambdabot>     Couldn't match expected type `Int'
11:17:21 <lambdabot>                 with actual type `m0 a0 -> m0 b0'
11:17:21 <lambdabot>     In the first argument of `replicate', namely `forever'
11:17:28 <magicman> @type repeat forever
11:17:28 <hpc> t replicate
11:17:29 <lambdabot> Monad m => [m a -> m b]
11:17:34 <magicman> >_> <_<
11:17:35 <hpc> :t replicate
11:17:37 <lambdabot> Int -> a -> [a]
11:17:42 <Taneb> Ahah!
11:17:53 <Taneb> I was thinking of "fix (foo >>>)
11:17:54 <Taneb> "
11:18:03 <Taneb> :t fix (?foo >>>)
11:18:04 <lambdabot> (?foo::cat b b, Control.Category.Category cat) => cat b c
11:20:00 <Nolrai> wait all I am doing with the chaining is swaping two variables..
11:20:04 <mcstar> 'secret message repeats forever, that's predictable and easy to decode' i dont follow, playing back a message coded with a one time pad, doesnt make it less secure
11:20:24 <aCube> :t id :: ? -> Int
11:20:25 <lambdabot> parse error on input `?'
11:20:50 <hpc> mcstar: i am using movie logic, not real logic
11:20:52 <mcstar> :t (?)
11:20:54 <lambdabot> Not in scope: `?'
11:21:06 <mcstar> ? is |> right?
11:21:13 <mcstar> reversed $
11:21:13 <hpc> :t (|>)
11:21:15 <lambdabot> Snoc Control.Lens.Internal.Review.Reviewed Identity s s a a => s -> a -> s
11:21:21 <hpc> gadzooks
11:21:31 <mcstar> i didnt mean in lens context
11:21:37 <hpc> neither did i
11:21:51 <tippenein> is there a reason cabal doesn't install dependencies and just fails?
11:22:06 <srhb> tippenein: There's always a reason when it happens.
11:22:14 <srhb> tippenein: Though it might not be obvious.
11:22:18 <hpc> newer cabal is much better at telling you why
11:22:48 <tippenein> srhb: is it assumed I should install the dependencies 1 by 1 until it passes?
11:22:55 <srhb> No.
11:23:05 <aCube> @ty id ?i + ?x
11:23:06 <lambdabot> (?i::a, ?x::a, Num a) => a
11:23:08 <srhb> That's almost never what you want.
11:23:34 <hpc> i would even go farther and say it's never what you want
11:23:51 <hpc> and if you get in a situation where that happens to work, what you want is to change it so you don't have to do that kind of crap
11:24:04 <ion> hpc: Newer than what?
11:24:04 <tippenein> Trying to install yesod with cabal and get : Data/Pool.hs:42:8: Could not find module `Control.Concurrent.STM' There are files missing in the `stm-2.3' package,
11:24:19 <srhb> Eeek
11:24:23 <srhb> NUke everything and start over!
11:24:39 <Nolrai> aCube: ? is syntax for implicit parameters.
11:24:42 <ab9rf> your cabal has been run over by a car
11:24:47 <tippenein> that was the plan. Just making sure I wasn't missing a flag or something
11:24:50 <hpc> ion: dunno; i remember the messages getting better when i upgraded to 7.4.1 though
11:24:57 <mcstar> implicit parameters in haskell?
11:24:59 <mcstar> wth
11:25:14 <Nolrai> They can be simi useful.
11:25:22 <hpc> it's an awful extension and the only really nice use for them is holes
11:25:23 <srhb> tippenein: No, and if stm is global, it's probably your entire Haskell installation that's fubar'ed
11:25:31 <srhb> tippenein: How did you install things?
11:25:56 <tippenein> quite possible. I installed through equo, which is a clone of the portage package manager
11:26:07 <tippenein> I've had things like this before
11:26:12 <mcstar> whats ?? ?
11:26:18 <tippenein> should probably just switch distro
11:26:19 <srhb> I don't know if those packages are sane
11:26:20 <mcstar> hoogle lists it as a keyword
11:26:30 <tippenein> is there a way to build from current source?
11:26:35 <srhb> tippenein: Honestly, on most distros, the saner solution seems to be to just install ghc and cabal-install manually and then go from there
11:26:36 <tippenein> or is that even a good idea?
11:26:58 <dmwit> mcstar: Must be specific to some package you're using.
11:27:00 <srhb> tippenein: There are ginary packages on the GHC website, and you need cabal-install, too. I very much recommend that route, no matter the distro.
11:27:11 <srhb> binary*
11:27:11 <mcstar> @hoogle (??)
11:27:12 <lambdabot> keyword ??
11:27:15 <dmwit> mcstar: Try adding +packagename to your hoogle query.
11:27:15 <mcstar> dmwit: ^
11:27:20 <dmwit> Yes, I'm aware.
11:27:56 <mcstar> i dont understand, if it is a keyword, then it is not an operator
11:28:01 <dmwit> Hayoo suggests it may be from lens, cond, hylolib, xmonad-contrib, ...
11:28:05 <mcstar> ergo, it cant be specialized
11:28:09 <dmwit> mcstar: incorrect =)
11:28:23 <srhb> tippenein: You could probably get away with just using ghc and cabal-install from your package manager, though. If you remove everything else (and the versions aren't horribly old)
11:28:23 <hpc> mcstar: it' only a keyword at the kind level
11:28:23 <dmwit> It is a keyword at the kind level, but not at the type or value level.
11:28:31 <mcstar> ok
11:28:39 <hpc> dmwit: is it even a kind anymore in recent ghc?
11:28:46 <dmwit> Dunno!
11:29:08 <geekosaur> I think ghc with the new kind system no longer uses it, yeh
11:29:16 <tippenein> srhb: I'm going to try the binaries and see what happes. thanks for the help
11:29:30 <sellout-> tippenein: I find that for any language you plan on developing in (rather than just installing packages that depend on it), it‚Äôs much safer to install it manually, then use the language‚Äôs package manager (cabal, in the case of Haskell) instead of the distro‚Äôs.
11:29:38 <srhb> tippenein: Sure, check back if you run into problems.
11:30:42 <Nolrai> So do bi-directional parser/writers exist yet?
11:31:01 <dmwit> There's a paper about a library for that based on partial isomorphisms.
11:31:24 <dmwit> http://camlunity.ru/swap/Library/Computer%20Science/Parsers/Invertible%20Syntax%20Descriptions.%20Unifying%20Parsing%20and%20Pretty-Printing.pdf maybe?
11:31:36 <dmwit> Yep, that one.
11:31:45 <mcstar> "and unfortunately, typed languages, in particular Hindley-Milner typed languages like Haskell, only support static scoping of variables." why would that be unfortunate..
11:32:27 <hpc> mcstar: that's one magnificently disingenuous sentence
11:32:30 <dmwit> ?hackage partial-isomorphisms
11:32:31 <lambdabot> http://hackage.haskell.org/package/partial-isomorphisms
11:32:47 <mcstar> hpc: ghc docs
11:32:55 <dmwit> Oh, whoops.
11:32:59 <dmwit> ?hackage invertible-syntax
11:32:59 <lambdabot> http://hackage.haskell.org/package/invertible-syntax
11:33:34 <dmwit> mcstar: Presumably the sentences just before or just after that one discuss why that would be unfortunate.
11:34:00 <mcstar> not reaaly
11:37:24 <hpc> fun function of the day:
11:37:29 <hpc> ?type join . readChan
11:37:30 <lambdabot> Not in scope: `readChan'
11:37:33 <hpc> :(
11:37:50 <ab9rf> i don't see why you would want implicit parameters
11:38:07 <ab9rf> i've just read the manual section on them and i don't see the point
11:38:37 <Eduard_Munteanu> Don't you first have to join to read the channel? :P
11:38:39 <jmcarthur> there isn't much point
11:38:49 <monochrom> hahahaha
11:39:04 <hpc> Eduard_Munteanu: ;)
11:39:21 <monochrom> do { x <- haskell_blah; x; readChan x ... }
11:40:06 <hpc> monochrom: you make me want to write a threaded IRC client where that's actually how you read a line of cha
11:40:09 <hpc> chat
11:41:33 <monochrom> haskell_blah :: IO (IO (Chan String))
11:42:09 <monochrom> do { c <- join haskell_blah; forever (readChan c >>= putStrLn) }
11:51:54 <PrO_OkI> HI.Can anyone give me a NixOX torrent link, I cannnot find it.Thanks.:)
11:52:04 <PrO_OkI> *NixOS
11:53:50 <mcstar> yes, www.haskell.org
11:54:17 <mcstar> oh, i misread, sry
11:54:45 <Eduard_Munteanu> PrO_OkI: you might want to try #nixos
11:55:01 <PrO_OkI> Ok.Will do that.:)
12:20:46 <hpaste> ab9rf pasted ‚Äúwhy overlapping patterns?‚Äù at http://hpaste.org/84220
12:21:26 <ab9rf> this is probably a dumb question, but why does that paste generate an overlapping patterns warning, is there really a problem with that code, and if so what is the right way to do that?
12:22:18 <geekosaur> you cannot match values that way
12:22:36 <geekosaur> a1, a2, a3 are all new bindings having nothing to do with your earlier bindings
12:22:43 <geekosaur> use guards instead
12:23:10 <ab9rf> i figured it was something like that
12:23:37 <hpaste> geekosaur annotated ‚Äúwhy overlapping patterns?‚Äù with ‚Äúwhy overlapping patterns? (annotation)‚Äù at http://hpaste.org/84220#a84221
12:24:02 <hpaste> geekosaur revised ‚Äúwhy overlapping patterns? (annotation)‚Äù: ‚Äú(remove the spurious parens)‚Äù at http://hpaste.org/84221
12:24:15 <mcstar> geekosaur: why the case?
12:24:34 <geekosaur> just duplicating the pattern they had
12:24:41 <mcstar> oh
12:24:44 <geekosaur> it's not needed, but then neither was the original
12:25:29 <hpaste> geekosaur annotated ‚Äúwhy overlapping patterns?‚Äù with ‚Äúand this is how it probably ought be done‚Äù at http://hpaste.org/84220#a84223
12:26:15 <ab9rf> geekosaur: that's not the actual code i wrote last night at 3:40 am but it's the same structure
12:26:55 <ab9rf> 'new bindings' is the salient point that escaped me in my sleep-deprived state last night (and roaring headache state today)
12:28:25 <mcstar> ouch, i see the headlines: "Haskell causes headache in young man"
12:28:56 <ab9rf> mcstar: except i'm neither young nor a man
12:29:07 <mcstar> yeah, thats why its weird
12:29:17 <mcstar> the two seemingly have nothing in common
12:31:31 <ab9rf> geekosaur++
12:36:24 <ab9rf> and the code from which that was abstracted now works
12:39:12 <ab9rf> i added comment capture to the parser i'm writing
12:39:15 <beaky> hello
12:39:24 <beaky> what is the difference between rank n types and higher kind types?
12:40:37 <Taneb> Quite a lot, but I don't know enough about the latter to be in a good position to inform you further
12:40:51 <monochrom> they are unrelated
12:40:54 <beaky> ah
12:41:00 <beaky> i thought they were synonymous
12:43:33 <ab9rf> i hadn't looked at rank-n types before now
12:44:48 <beaky> yes
12:44:55 <mauke> frank-n-types
12:45:01 <beaky> rank n types are like the solution to the expression problem
12:45:57 <Philippa> beaky: higher kinds are when you get to parameterise on something you can fill with [] or Maybe rather than [String] or Maybe Int
12:46:06 <Ralith> beaky: insofar as that you don't know what they are?
12:48:33 <ab9rf> mauke: heh, i just got that
12:48:39 <beaky> ah
12:49:07 <beaky> so rank n types is like inheritance in OOP?
12:49:15 <beaky> (at least I thought of them that way)
12:49:16 <ab9rf> dear lord no
12:49:30 <beaky> or subtyping
12:49:36 <jmcarthur> rank n types just allow you to use universal quantification
12:49:41 <beaky> ah
12:50:02 <ab9rf> multiple levels of universal quantification, more specifically
12:50:14 <jmcarthur> right
12:50:21 <jmcarthur> as opposed to only at the top level
12:50:23 <monochrom> did you actually read up on rank-n types and examples?
12:50:28 <beaky> so that's what the "forall a.a" means in my haskell code?
12:50:32 <beaky> nope
12:50:41 <jmcarthur> forall doesn't always mean rank n types
12:51:02 <beaky> ah
12:51:17 <monochrom> then I suggest you request some #haskell members to copy and paste an article on rank-n types for you right here
12:51:21 <ab9rf> typically only forall on tleft side of a function arrow
12:51:21 <Philippa> sure it does. Sometimes n is 1 though, and you get 1 already
12:51:58 <jmcarthur> forall a b c. (a -> b) -> c  is not a higher rank type, but  forall a c. (forall b. a -> b) -> c  is
12:52:03 <jmcarthur> Philippa: yeah, i mean for n > 1
12:52:40 <Philippa> jmcarthur: *nod*. Just wearing my semanticist hat for a moment :-)
12:52:49 <beaky> http://www.haskell.org/haskellwiki/Rank-N_types this is rankntypes?
12:53:07 <Philippa> ab9rf: right. Plus the thing where by "LHS" we mean "left-hand child node"
12:53:27 <jmcarthur> Philippa: no no, i think it's valuable to be precise, especially when explaining something new to somebody
12:53:43 <Philippa> jmcarthur: sure. It's just semantics - just the thing that matters :-)
12:53:50 <jmcarthur> although i admit nothing i have said so far has been very helpful
12:54:04 <Philippa> which is to say: not picking on you personally
12:54:15 * albel727 wonders, why typeclassopedia isn't mentioned anywhere on meta-tutorial page
12:54:59 <beaky> lets edit it :D
12:55:59 <ab9rf> hm, yeah, i ran into typeclassopedia last night and it helped me considerably with some issues that i'm not really understanding yet
12:56:21 <beaky> typclassopedia helped me understand some haskell
12:56:26 <beaky> like what monoids were
12:57:14 <ab9rf> the daq at the top of the page really help
12:57:17 <beaky> a monoid is a type that responds to mappend and mempty
12:57:38 <ab9rf> beaky: i don't find that useful
12:58:20 <ab9rf> it's like saying that a cat is a thing that gets high on catnip
12:58:23 <Philippa> beaky: in such a way that you can treat 'mappends' as a sequence e
12:58:29 <Philippa> whatever tree of them you get handed
12:58:43 <Philippa> ab9rf: eh. I can see how it's useful for people who don't think like a mathematician
12:58:58 <beaky> yes
12:59:09 <beaky> numbers are monoids
12:59:22 <srhb> That's at best imprecise.
12:59:28 <beaky> ah
12:59:58 <srhb> For instance, for products, mappend is multiplication and identity is 1
13:00:06 <srhb> Whereas for addition, mappend is addition and 0 is identity
13:00:18 <Philippa> beaky: it's more accurate to say that there are monoids on (or containing) numbers
13:00:23 <beaky> oh
13:00:34 <beaky> so monoids are mor elike functions?
13:00:36 <Philippa> (whereas for comparison, lists are the free monoid)
13:00:42 <ab9rf> Philippa: there are people who don't think like mathematicians?  and i should care about how they think? :)
13:00:56 <beaky> how do i think like a mathematician?
13:01:22 <Philippa> beaky: a monoid is a type, a binary function on that type, a value of that type - all of which behave according to certain rules
13:01:37 <beaky> ah
13:01:37 <Philippa> if it helps to think of it as a record or an object containing those things for now, that's fine
13:01:41 <srhb> beaky: monoids are types with a binary operation mappend and an identity element mzero
13:01:41 <mcstar> beaky: it seems you dont
13:01:49 <beaky> :(
13:02:25 <srhb> Er, or is it called something other than mzero
13:02:27 <srhb> :t mzero
13:02:28 <lambdabot> MonadPlus m => m a
13:02:33 <monochrom> it's mempty, not mzero
13:02:43 <srhb> mempty
13:02:44 <srhb> right
13:02:55 <beaky> :t mappend . mempty
13:02:57 <lambdabot> (Functor f, Monoid (f a), Monoid a) => f (a -> a)
13:03:09 <ab9rf> hee
13:03:40 <Philippa> mcstar: I don't think that's a helpful thing to say to someone who's trying to learn
13:04:04 <Philippa> beaky: so I don't think there's a single snappy answer to that? Mathematics is a surprisingly nuanced culture
13:04:12 <mcstar> they told him, he doesnt think like a mathematician...
13:04:34 <Philippa> mcstar: no, what you said implies that he /can't/
13:04:41 <mcstar> "I can see how it's useful for people who don't think like a mathematician"
13:04:46 <ab9rf> the key to thinking like a mathematician is to, whenever you learn anything, immediately attempt to replace anything in what you learned with as many layers of abstraction as possible :)
13:04:59 <beaky> ah
13:05:13 <Philippa> mcstar: yes, that was me even. I don't think beaky had a problem with that (though I'm happy to be told otherwise!), but your response there was something different
13:05:28 <Philippa> ab9rf: heh. That's part of it. Symbol games are another...
13:05:34 <mcstar> Philippa: it was a funny twist building on your response
13:05:41 <monochrom> I am not convinced that you must strive to think like a mathematician. also, which kind of mathematician?
13:05:48 <ab9rf> Philippa: i realized at some point that i've done that for a very long time
13:06:05 <Hafydd> I don't see any harm in being aware of the precise definition of something.
13:06:35 <ab9rf> Philippa: it's actually problematic when doing software engineering, it tends to result in overengineered, overgeneral solutions that are elegant, beautiful, and impossible to either use or bring to completion in a nongeologic timescale
13:06:47 <Philippa> mcstar: it was an inappropriate one that formed a personal attack on a beginner. That's not appropriate here
13:06:54 <Philippa> ab9rf: yep
13:07:03 <monochrom> there is in particular a kind who insist "use your brain, never use a computer". thinking like them will contradict your pursuit with computing and programming languages
13:07:13 <Hafydd> Wait, I think I missed something...
13:07:19 <Philippa> ab9rf: I knew a guy who proudly announced that his 10sKLoC 3D engine had just reached a milestone - it'd rendered its first triangle
13:07:21 <mcstar> Philippa: he is a regular here, and the meaning is open to interpretation
13:07:25 <ab9rf> Philippa: haha
13:07:35 <jmcarthur> i don't know. as far as i know the whole purpose of mathematics is clarity of systematic thought
13:07:50 <beaky> yes mathematicians are good at reasioning through problems
13:07:54 <ab9rf> Philippa: i admit that i've fallen prey to the overengineering bug way too many times
13:08:04 <ab9rf> beaky: no they're good at distilling problems to their core
13:08:13 <jmcarthur> and i think good mathematics *should* be accessible to non-mathemeticians (perhaps with work, but still)
13:08:13 <beaky> ah
13:08:15 <ab9rf> and then realizing that the core problem has no solution :)
13:08:18 <Philippa> mcstar: It's clear how it was interpreted by beaky. Again, it was inappropriate. And yes, one of my roles in this chan is to help decide what is appropriate and let people know
13:08:19 <beaky> lol
13:08:33 <ab9rf> or that it's already been solved before
13:08:35 <Philippa> jmcarthur: certainly well-presented mathematics should be, yes
13:08:46 <mcstar> well then i guess i must leave
13:09:12 <beaky> :(
13:09:21 <jmcarthur> Philippa: i think what i'm trying to say is that presentation should be more than just an afterthought
13:09:23 <Philippa> beaky: yeah, not ideal :-( Not your fault, though
13:09:37 <Philippa> jmcarthur: Hell yes! Alas, most presentations are aimed at experts in a specific subfield
13:09:41 <monochrom> mathematics (or mathematicians?) no longer holds the monopoly on clarity of systematic thought. several CS fields now have it too, for example programming language research, theorem provers
13:09:42 <jmcarthur> presentation and deeper understanding go hand in hand
13:10:02 <jmcarthur> monochrom: i consider those fields quite related to mathematics
13:10:09 <luisalima> ?src foldr
13:10:09 <lambdabot> foldr f z []     = z
13:10:09 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:10:29 <monochrom> but mathematicians don't call those mathematics
13:10:38 <Philippa> monochrom: you mean those bits that are effectively engineering-of-mathematics?
13:10:41 <jmcarthur> i attribute that to culture
13:11:09 <Philippa> (which is why mathematicians don't call them mathematics - that, and they're nowhere near ready for *exploratory* maths)
13:11:38 <luisalima> ?src foldl
13:11:38 <lambdabot> foldl f z []     = z
13:11:38 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:11:48 <jmcarthur> i think there are valuable elements of the culture of mathematics missing from a lot of these newer fields, too, to be fair
13:12:27 <ab9rf> monochrom: to be fair, i consider computer science a subdiscipline of mathematics :)
13:13:43 <Philippa> ab9rf: how do you find my "engineering-of-mathematics" description?
13:14:17 <ab9rf> Philippa: i think the core theory of computation is fairly solid mathematics
13:14:38 <Philippa> *nod* no argument there
13:14:49 <Philippa> (cue arguments about choice of foundations etc etc :p)
13:15:06 <ab9rf> Philippa: a lot of what is often identified as computer science i really think is more accurately describes as computer engineering
13:15:25 <johnw> axiomatic computer science?
13:15:27 <jmcarthur> yeah, like pretty much every undergraduate "computer science" degree
13:15:28 <Philippa> *nod*. Or the point in-between where the engineers have identified what the mathematical problem looks like
13:16:02 <ab9rf> jmcarthur: when i took computer science in the 80s, we had a significant component that was fairly theoretical
13:16:06 <lpsmith> http://hackage.haskell.org/trac/ghc/ticket/4001
13:16:11 <ab9rf> i have no idea how CS is taught these days
13:16:29 <srhb> Depends on where.
13:16:42 <bitonic> ab9rf: my ‚Äòcomputing‚Äô degree can be fairly theoretical even with that engineery name :)
13:16:44 <jmcarthur> there is usually a good chunk of theory, but it's very deemphasized
13:16:45 <Lethalman> @hoogle fromStrict
13:16:46 <lambdabot> Data.Text.Lazy fromStrict :: Text -> Text
13:16:49 <srhb> Where I've taken courses it was almost 100% theoretical aside from some introduction to programming courses that were inadequate at best.
13:17:01 <bitonic> if you take the right courses it can be almost all theory
13:17:05 <ab9rf> i hear people on the intarwebs who are taking computer science degrees that to me sound like more vocational training
13:17:13 <jmcarthur> exactly
13:17:29 <jmcarthur> they learn the minimal theory to get running and then it's all engineering
13:17:38 <jmcarthur> (and a little extra theory for the "exercise")
13:17:39 <Taneb> Both ways have their advantages
13:17:39 <ab9rf> learning how to configure a cisco router has nothing to do with computer science
13:17:40 <bitonic> ab9rf: eventually ‚Äòcomputer science‚Äô and ‚Äòsoftware engineering‚Äô will be well separate, maybe with CS being a specialisation of maths
13:17:54 <taterbase> Hey guys, I'm learning haskell and going through the learn you a haskell book. One of my experiments, as idiotic as it may be is to create my own toUpper function. Right now the only way I see this happening is mapping succ through a string but multiple times. I'm struggling to figure out how to perform a function for a known amount of times
13:17:56 <bitonic> because they really are very different endeavours ehe
13:18:11 <ab9rf> bitonic: when i took CS it was in a department that had only formally split from the math department only a few years before :)
13:18:11 <tippenein> ab9rf: depends which route you go. you can do either at my university
13:18:26 <Hafydd> tippenein: do you not have (+)?
13:18:29 <bitonic> taterbase: Char is an instance of Num.  this means that you can use ‚Äò+‚Äô on Chars, which should solve your problem
13:18:31 <jmcarthur> taterbase: so first of all, haskell Chars are not ASCII. you could choose to limit yourself to the ASCII subset, though
13:18:33 <mauke> taterbase: what are you using succ for?
13:18:38 <jmcarthur> bitonic: it is?
13:18:40 <tippenein> Hafydd: ?
13:18:42 <jmcarthur> @instances Num
13:18:43 <lambdabot> Double, Float, Int, Integer
13:18:45 <Hafydd> Sorry, tippenein. Wrong person.
13:18:48 <bitonic> oh.  maybe it isn‚Äôt :P
13:18:49 <ab9rf> i'm at a loss how succ will implement toUpper
13:18:51 <tippenein> heh, ok
13:18:56 <taterbase> bitonic: I thought so but I was getting type errors
13:18:58 <bitonic> taterbase: sorry then, use ‚Äòord‚Äô and ‚Äòchr‚Äô
13:19:09 <bitonic> @ty ord
13:19:11 <lambdabot> Char -> Int
13:19:15 <bitonic> @ty chr
13:19:16 <lambdabot> Int -> Char
13:19:21 * hackagebot split-channel 0.2.0.1 - Control.Concurrent.Chan split into sending and receiving halves.  http://hackage.haskell.org/package/split-channel-0.2.0.1 (LeonSmith)
13:19:57 <ab9rf> of course, i'm not clear on what succ is anymre :)
13:20:02 <ab9rf> :t succ
13:20:04 <lambdabot> Enum a => a -> a
13:20:06 <taterbase> jmcarthur: it is utf8 then?
13:20:14 <bitonic> taterbase: to answer your question more directly, a function like `foo f n x = if n > 0 then f (foo f (n-1) x) else f x' will work
13:20:19 <taterbase> mauke: just trying to go on to the next char until I hit the capital letter
13:20:28 <jmcarthur> taterbase: unicode codepoints, not any particular encoding of them
13:20:42 <ab9rf> taterbase: uppercase letters are before lowercase in the usual enumeration
13:20:46 <mauke> taterbase: in general you need to go backwards, though
13:20:54 <taterbase> ab9rf: oh! good to know
13:21:07 <ab9rf> taterbase: but that may not be true for codepoits not in the first plane
13:21:14 <ab9rf> 'A' < 'a'
13:23:05 <taterbase> So my next question then, is how to push a Char backwards, if it is not an instance of Num
13:23:06 <ab9rf> it looks like in most cases the uppercase version of a given glyph precedes the lowercase version
13:23:31 <ab9rf> taterbase: changing case of unicode characters is fairly complicated
13:24:16 <mauke> taterbase: you use a huge lookup table
13:24:23 <ab9rf> especially when you're dealing with composed characters
13:24:40 <taterbase> So what you're saying is my simple exercise is not so simple :)
13:25:10 <mauke> it's not complex, just long and boring
13:25:20 <ab9rf> yeah
13:25:22 <mauke> you simply have to enumerate all lowercase/uppercase pairs
13:25:37 <ab9rf> mauke: it's complicated if you have composed characters in your string
13:25:44 <mauke> ab9rf: toUpper :: Char -> Char
13:26:22 <ab9rf> mauke: that's going to potentially fail if there are combining characters in the string
13:26:33 <mauke> what string?
13:27:15 <ab9rf> hm, actually i think it's ok for toupper and tolower
13:27:21 <ab9rf> it's title case that requires string awareness
13:27:56 <ab9rf> in theory the combining characters are supposed to adjust themselves
13:28:21 <mauke> there is no string here
13:28:39 <mauke> on the other hand, the interface of toUpper is fundamentally broken in some sense
13:28:54 <mauke> toUpper '√ü' *should* be "SS" but of course it can't
13:29:06 <ab9rf> eg A\x308 -> √Ñ
13:29:14 <Nolrai25> Yo ghc is giving me a "    Perhaps you haven't installed the profiling libraries for package `base'?"
13:29:20 <ab9rf> mauke: there are a small number of such cases
13:29:24 <Nolrai25> error
13:29:34 <ab9rf> mauke: there are others beyond that one, but yes
13:30:13 <ab9rf> mauke: title case has to break ligatures in some cases
13:30:17 <Nolrai25> How do I tell cabal to install the profiling libraries for `base'?
13:31:25 <ab9rf> and there's \x1c4Ãà «Ñ \x1c5 Ãà «Ö \x1c6 «Ü
13:31:40 <johnw> Nolrai25: which OS?
13:31:47 <johnw> Nolrai25: i think debian has ghc-prof or something
13:32:22 <Nolrai25> ubuntu..but I don't think i have the distribution's version of ghc.
13:32:40 <johnw> you built it yourself?
13:33:36 <Nolrai25> hmm...do you know how I would tell, I know I have installed/built ghc sevral times and am not sure which I did most recently.
13:33:36 <ab9rf> mauke: there are also a handful of characters that, due to oversights by the Unicode committee, have only uppercase or lowercase glyphs; the other case can only be constructed using combining forms
13:34:47 <ab9rf> i think they finally fixed most of those in the last unicode standard revision, but new ones pop up all the time
13:35:47 <thm_prover> does mplus have to satisfy anything besides: forall mv, (m-plus m-zero mv) = mv = (m-plus mv m-zero) ?
13:35:57 <thm_prover> does it have to satisfying things like (m-zero a b) = (m-zero b a)
13:36:08 <thm_prover> err,does it have to satisfy (m-plus a b) = (m-plus b a)
13:36:18 <thm_prover> or (m-plus a (m-plus b c)) = (m-plus (m-plus a b) c) ?
13:36:31 <mauke> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t:MonadPlus
13:37:30 <thm_prover> so, no?
13:37:32 <Taneb> mplus (mplus a b) c == mplus a (mplus b c) -- it's associative
13:37:44 <Taneb> mplus a mzero == mplus mzero a == a
13:37:46 <thm_prover> it only needs satisfy that (mplus mv m-zero) = mv = (mplus m-zero mv) ?
13:38:11 <mauke> thm_prover: no, it also needs to satisfy the three other things listed there
13:38:48 <thm_prover> http://hpaste.org/84227 is all I see
13:39:52 <shachaf> What are the Alternative laws?
13:39:59 <shachaf> Other than associativity and identity.
13:40:36 <jmcarthur> i think that's basically it
13:40:49 <magicman> Not distributivity over (<*>)?
13:41:09 <thm_prover> or even commutative?
13:41:38 <jmcarthur> i know not commutativity
13:41:45 <jmcarthur> i'm pretty sure there is no distributive law in mind
13:41:51 <ab9rf> magicman: not mandatory
13:41:56 <magicman> Cool.
13:42:01 <ab9rf> many do have distributivity but it's not required
13:42:24 <shachaf> jmcarthur: Nothing like the mzero >>= _ = mzero law or anything like that?
13:42:37 <shachaf> That doesn't sound right...
13:42:39 <jmcarthur> well there's no >>= for Applicative anyway
13:42:43 <shachaf> Right.
13:42:45 <magicman> Yeah, I just realized that may go wrong with State or Writer inside of things. (a <|> b) <*> c, when redistributed, may have c's actions twice.
13:42:46 <shachaf> But something like that.
13:43:10 <magicman> (or c's effects on the state or log or whatever you may call it)
13:43:13 <jmcarthur> empty <*> a  ==  empty?
13:43:17 <jmcarthur> @instance Alternative
13:43:18 <lambdabot> Maybe you meant: instances instances-importing
13:43:21 <jmcarthur> @instances Alternative
13:43:22 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
13:43:30 <jmcarthur> @instances-importing Control.Applicative Alternative
13:43:30 <lambdabot> Either e, ErrorT e m, Maybe, ReaderT r m, StateT s m, WrappedMonad m, WriterT w m, []
13:43:53 <ab9rf> Typeclassopedia has all of the various laws, i believe
13:44:09 <jmcarthur> it shouldn't in principle have any that the documentation lacks
13:44:38 <shachaf> jmcarthur: For example.
13:46:29 <jmcarthur> well the standard instances at least seem to have that property
13:47:06 <jmcarthur> for that matter, i think it might be inherent given the other laws and the types
13:47:25 <Nolrai25> how do you tell cabal to install the profile versions of a package.
13:47:36 <Nolrai25> s/./?/
13:47:43 <monochrom> add flag "--enable-library-profiling"
13:47:49 <jmcarthur> empty can't actually have any functions "contained" in it, so that <*>ed to anything can't do much for you
13:48:02 <jmcarthur> monoids always have unique identities, iirc
13:48:13 <shachaf> Yes.
13:48:13 <jmcarthur> so the empty value you get as a result must be the same empty that you put in it
13:48:15 <monochrom> there is also a setting in $HOME/.cabal/config for it
13:48:39 <jmcarthur> (i hypothesize)
13:49:48 <monochrom> you may have to rebuild a lot of packages because they were not built with profiling. but don't rebuild things that come with GHC; they already come with profiling
13:50:05 <jmcarthur> shachaf: yeah i'm thinking that adding such a law would be redundant, now
13:50:37 <shachaf> Wait, which law?
13:50:46 <jmcarthur> something to the effect of   empty <*> a  ==  empty
13:50:58 <monochrom> $HOME/.cabal/config has pretty ancient and counter-productive defaults
13:51:00 <shachaf> If the law is redundant then the documentation should at least mention that.
13:51:31 <jmcarthur> i don't think so. when should it stop enumerating "interesting" properties you can derive from the laws?
13:52:04 <monochrom> Wadler found that 1 of the 9 arrow laws can be omitted :)
13:52:12 <shachaf> Somewhere past where it does!
13:52:20 <shachaf> Why is the law necessary for MonadPlus?
13:52:29 <monochrom> of course, it was not obvious at the beginning
13:52:43 <shachaf> Anyway you say that from the Applicative and Alternative laws you can derive empty <*> a  ==  empty?
13:52:45 <Tesseraction> silly question, what's the best way of obtaining the tuple with the highest 'y' value in a list of coordinates [(Int, Int)]?
13:52:45 <jmcarthur> shachaf: maybe it isn't?
13:53:00 <jmcarthur> shachaf: i don't know. i'm not sure either way yet. haven't thought hard about it
13:53:01 <shachaf> Tesseraction: What is a 'y' value?
13:53:07 <monochrom> perhaps maximumBy
13:53:11 <monochrom> @type maximumBy
13:53:13 <lambdabot> (a -> a -> Ordering) -> [a] -> a
13:53:16 <shachaf> Ah, co√∂rdinates, so (x,y) pairs.
13:53:22 <shachaf> maximumBy, yes.
13:53:36 <monochrom> now I have to craft the comparison
13:53:38 <ab9rf> Tesseraction: you want the tuple with the largest snd?
13:53:47 <geekosaur> comparing snd?
13:53:48 <monochrom> @type on
13:53:49 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
13:53:53 <jmcarthur> shachaf: i think there would be a parametricity argument involved in the proof, and i do not have the proper vocabulary for it
13:53:53 <monochrom> @type comparing
13:53:55 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
13:53:55 * Hadoop is Heffalump's long-lost brother
13:54:11 <monochrom> oh, comparing is perfect
13:54:17 <Tesseraction> ah
13:54:21 <Tesseraction> cheers
13:54:21 <monochrom> maximumBy (comparing snd) the_list
13:57:31 <Nolrai25> is there a way to tell cabal to reinstall everything with profiling?
14:01:54 <jmcarthur> as an appeal to authority, ed kmett makes the same claim that i did, here: http://stackoverflow.com/questions/10167879/distinction-between-typeclasses-monadplus-alternative-and-monoid
14:02:11 <jmcarthur> he also claims distributive and catch properties
14:03:23 <jmcarthur> perhaps "appeal to authority" is a bit strong, but we at least can agree that if he said it then it's probably not far from the truth
14:03:47 <shachaf> edwardk has been known to disagree with ed kmett
14:03:56 <shachaf> I never know whom to believe.
14:04:00 <jmcarthur> heh
14:04:00 <edwardk> yeah
14:04:06 <jmcarthur> ;)
14:04:06 <edwardk> both of those guys are assholes
14:04:32 <jmcarthur> i did not mean to avoid your nick. wasn't thinking about it
14:05:18 <mauke> kedmet
14:05:42 <ClaudiusMaximus> gnnnrrrg, seems cairo doesn't support negative stride so i'll have to manually flip my image data
14:08:30 * chetoo www.zonalatina.org enten Chat Gratis - Chatea con gente y has amigos en nuestro chat online, liga con gente de todo el mundowww.zonalatina.org Chat gratis con chicos y chicas de tu ciudad. Conoce amigos y liga en nuestro chat gratuito conoce gente de todo el mundo y diviertete chateando irc.zonalatina.org /server irc.zonalatina.org /server -m irc.zonalatina.org gracias
14:09:22 * hackagebot shake 0.10 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.10 (NeilMitchell)
14:09:34 <shachaf> preflex: xseen ndm
14:09:34 <preflex>  ndm was last seen on freenode/#haskell 2 years, 89 days, 1 hour, 53 minutes and 35 seconds ago, saying: if you don't, then there was a parse error
14:10:33 <ion> preflex: xseen bonus
14:10:33 <preflex>  bonus was last seen on freenode/#haskell 1 year, 322 days, 1 hour, 42 minutes and 44 seconds ago, saying: yeah i think that's better as well
14:10:47 <shachaf> preflex: xseen ddarius
14:10:48 <preflex>  ddarius was last seen on freenode/#haskell 197 days, 12 hours, 7 minutes and 34 seconds ago, saying: > let f n = g (n-1) where g k [] = []; g 0 (_:xs) = g (n-1) xs; g k (x:xs) = x:g (k-1) xs in f 5 "hello, world"
14:14:23 * hackagebot eigen 1.0.0 - Haskel binding for Eigen library  http://hackage.haskell.org/package/eigen-1.0.0 (OlegSidorkin)
14:17:52 <jmcarthur> preflex: xseen mmorrow
14:17:53 <preflex>  mmorrow was last seen on freenode/#ghc 3 years, 59 days, 18 hours, 20 minutes and 20 seconds ago, saying: * mmorrow is rtfm'ing
14:18:20 <sellout-> It‚Äôs a pretty long manual ‚Ä¶
14:18:39 <jmcarthur> the main reason i love doing that is because the reaction is always the same
14:18:41 <ab9rf>  heh
14:18:52 <hpc> sometimes i wonder if he said that and left just to mess with us
14:19:02 <hpc> preflex: xseen bonus
14:19:02 <preflex>  bonus was last seen on freenode/#haskell 1 year, 322 days, 1 hour, 51 minutes and 13 seconds ago, saying: yeah i think that's better as well
14:19:07 <hpc> :(
14:20:35 <ab9rf> when did they stop sending out 'freenode birthday' notes, anyway?
14:20:51 <ab9rf> i remember getting a ten-year freenode birthday note a while back
14:21:24 <ab9rf> also, when my freenode user account turns 18, can it vote?
14:22:46 <johnw> i've been doing a lot of STM these past few days, and I must say it really makes concurrency a lot less burdensome to deal with -- at times fun, even!
14:24:44 <RenJuan> and it works, right?
14:24:49 <johnw> yeah, it works great
14:25:28 <RenJuan> are you still converting base ledger to haskell?
14:25:37 <johnw> yes, slowly
14:25:49 <johnw> current work is on the commodities library
14:25:56 <RenJuan> so what point hledger then or will you merge?
14:26:11 <fryguybob> johnw: If you have anything using STM that could turn in to a benchmark let me know.
14:26:39 <johnw> RenJuan: sm and I would very much like to collaborate as much as we can
14:27:01 * Lethalman having fun with fay + clay + scotty + shake + blaze-html
14:27:04 <johnw> sm is more active UI stuff (using Yesod, for example), and my interests lie in the core ideas
14:27:21 <johnw> fryguybob: sadly what i'm doing is not easily extractable, but I'll keep it in mind
14:27:25 * RenJuan thinks you should have kept core ledger c++.
14:27:35 <johnw> RenJuan: well, it is right now
14:27:38 <fryguybob> johnw: That is often the case, no worries.
14:28:14 <johnw> RenJuan: but for me personally, Ledger is more like a garden: I find joy just playing with the code; it's not really about pragmatism as much has some other projects
14:30:10 <RenJuan> odd because as an app it's super pragmatic/mundane
14:30:21 <johnw> yeah, it strikes me as odd too
14:30:30 <johnw> i have no idea what it interests me like it does, but it does
14:30:37 <johnw> s/what/why
14:31:11 <RenJuan> it's just cognitively consonant, reassuring to have the base impl be c++
14:31:23 <johnw> RenJuan: and don't worry about C++ ledger, it will be maintained for at least the next decade, if not longer
14:31:34 <johnw> it's in full-on stability mode now
14:31:35 <RenJuan> ah, great, thx
14:31:51 <johnw> i still use it every day :)
14:37:49 <parcs> > fmap fix return ()
14:37:50 <lambdabot>   ()
14:37:53 <tippenein> when I run ghc-pkg check I get a warning on everything (*.haddock)
14:38:05 <johnw> yeah, that happens
14:38:07 <tippenein> do I have to rebuild ghc also to repair cabal?
14:38:13 <johnw> no
14:38:30 <johnw> just rm -fr ~/.ghc ~/.cabal/lib
14:38:36 <johnw> and then cabal install world, or whatever you want to install
14:38:52 <parcs> why? you can safely ignore the haddock warnings
14:39:05 <johnw> yeah, but it burns us, says golum
14:39:27 <tippenein> can you ignore this? -> "The following packages are broken, either because they have a problem
14:39:30 <tippenein> listed above, or because they depend on a broken package.
14:39:41 <tippenein> followed by a list of every package I downloaded
14:39:43 <tippenein> :)
14:39:55 <johnw> tippenein: here's my reset script: https://gist.github.com/5183770
14:40:02 <johnw> apply liberally where needed ;)
14:40:13 <parcs> tippenein: if you're not directly experiencing any package-related problems then i say let it be
14:40:26 <ClaudiusMaximus> (nevermind, cairo does support negative strides, but they must be aligned appropriately, moreover even FormatRGB24 expects BGRA 4-byte pixels)
14:41:10 <tippenein> parcs: I embarked on this because yesod failed to download because of broken packages
14:41:18 <sm> g'day all
14:41:22 <johnw> sm!!
14:41:41 <johnw> sm: are you coming to emacs conf?
14:41:52 <parcs> tippenein: oh then a wipe is a good idea
14:41:52 <shachaf> johnw: Does soh support files without main yet?
14:42:03 <sm> johnw: huh, let me check!
14:42:03 <shachaf> Nothing interesting involves IO!
14:42:05 <johnw> shachaf: not yet
14:42:38 <johnw> shachaf: but it will be coming soon
14:42:50 <sm> johnw: london 30th march.. alas no!
14:42:55 <johnw> alas yes!
14:43:23 * sm feels reality warping
14:43:45 <finnrobi> question: I want to do something like do { handle <- openFile path ReadMode; out <- parseInterestingStuff handle; hClose handle; return out; } but it fails because hClose runs before the handle is actually read. What's the intelligent way to do this?
14:44:07 <johnw> finnrobi: this is a classic one
14:44:14 <finnrobi> johnw: I had assumed as much :-)
14:44:19 <shachaf> finnrobi: Read about lazy I/O
14:44:24 <johnw> finnrobi: the problem is that you aren't using the value of "out" until after you close the handle, so no parsing happens while the file is open
14:44:24 <shachaf> And hGetContents
14:44:45 <johnw> i like how well you asked the question, finnrobi
14:44:57 <mauke> finnrobi: what does parseInterestingStuff do?
14:45:40 <finnrobi> mauke: it uses hGetContents and parses the resulting string (I'm just writing wc here to try to actually IO a little)
14:45:45 <parcs> [][][][[]
14:46:12 <mauke> finnrobi: contents <- readFile path; parseInterestingStuff contents
14:46:21 <mauke> and make it read from a String instead
14:46:21 <parcs> finnrobi: before closing the handle you have to make sure 'out' is evaluated, due to how lazy io works
14:46:32 <finnrobi> mauke: aha, thank you
14:46:39 <finnrobi> parcs: okay, and to do that I would use seq?
14:46:58 <parcs> Control.Exception.evaluate is preferred
14:47:17 <mauke> that only goes to WHNF
14:47:17 <finnrobi> okay
14:47:37 <finnrobi> WHNF? I'm afraid I don't know that term
14:47:54 <mauke> and that's why I went for readFile instead :-)
14:48:17 <johnw> Weak Head Normal Form: it means only the first very "layer" of the value is evaluated, not the whole structure
14:48:20 <finnrobi> either way, this fixes my problem and makes the code neater to boot, thanks for the help! :-)
14:48:32 <finnrobi> ahh, I had actually heard that before
14:48:39 <johnw> in fact, not even the first layer, but the structure of the first layer
14:48:52 <johnw> for a tuple X, (_,_) is WHNF
14:49:03 <johnw> where _ can be anything at all, you haven't evaluated it
15:00:38 <hpaste> tippenein pasted ‚Äúcabal errors‚Äù at http://hpaste.org/84231
15:01:53 <geekosaur> nice leaving out the actual error
15:01:54 <tippenein> johnw: the script seemed to work in the sense that it attempted to build yesod, but it fails on the same package, just at a different spot
15:01:54 <srhb> tippenein: Is that on a fresh .cabal and .ghc?
15:02:11 <johnw> @hpaste
15:02:12 <lambdabot> Haskell pastebin: http://hpaste.org/
15:02:24 <tippenein> I used johnw's script
15:02:32 <johnw> show me your error
15:02:36 <srhb> tippenein: geekosaur is right, you left out the point where the error occurred.
15:05:19 <tippenein> this is the full error http://hpaste.org/edit/84231
15:05:33 <srhb> That can't be right.
15:05:53 <srhb> Where's the error message for the install of resource-pool?
15:06:07 <johnw> yes, there is context missing
15:06:14 <johnw> also don't install with -j yet
15:06:19 <johnw> try using -j1
15:06:23 <johnw> it will make the error much clearer
15:06:38 <tippenein> I didn't use any flags
15:06:50 <johnw> that's interesting
15:06:56 <tippenein> now that I'm scrolling up, many of the dependencies of yesod failed also
15:06:58 <johnw> anyway, try this: cabal install -j1 resource-pool
15:07:06 <johnw> ah
15:07:14 <johnw> do you have Haskell Platform installed?
15:07:50 <srhb> tippenein: Yes, that's what we were trying to say. Those you pasted are just collateral
15:08:03 <srhb> The first error will be the interesting one.
15:08:10 <srhb> (probably)
15:08:23 <tippenein> I don't have haskell platform
15:08:43 <srhb> tippenein: How come you're on ghc 7.4.1 then?
15:08:46 <johnw> ok, do you have any extra haskell libraries installed via your package manager?
15:09:12 <tippenein> yup, when I ghc-pkg check I get a full list of them saying they're all broken
15:09:34 <tippenein> or depend on a broken package
15:09:50 <johnw> what OS are you on?
15:09:57 <srhb> Could you tell us about your Haskell installation?
15:10:19 <thm_prover> what is the relation between (1) monads, (2) coroutines, and (3) lightweight threads ? [I read somewhere that monadtic controls gives me delimited continuations]. I have no idea what any of these things are.
15:10:29 <tippenein> I got ghc from the package manager and built cabal from source
15:10:44 <tippenein> the OS is sabayon (a gentoo derivative)
15:10:54 <johnw> thm_prover: i would recommend some googling and reading, and then coming back with more specific questions
15:11:26 <danny__> hi.  What is a haskell function for recursively copying a directory to a new destination?  For the life of me I can't find it.
15:11:33 <johnw> thm_prover: those three things can be related, but necessarily have to be, so it's hard to give you a quick answer
15:11:40 <johnw> but don't*
15:11:52 <tippenein> the only thing now that could be a problem with my OS repos is GHC, and that's 7.4.1 I believe
15:12:06 <shachaf> thm_prover: Well, given continuations, you can implement coroutines (and in turn co√∂perative threading).
15:12:06 <tippenein> maybe that's my problem?
15:12:18 <johnw> danny__: believe it or not, there isn't one
15:12:20 <srhb> danny__: I don't think there's such a function in the standard libraries
15:12:21 <shachaf> And there's a continuation monad (and in general monads are very related to CPS).
15:12:21 <johnw> but I have some code for you
15:12:22 <thm_prover> so I'm currently working through a monad tutoirla
15:12:26 <srhb> danny__: BUt it's easy to roll.
15:12:39 <srhb> thm_prover: Careful with that.
15:12:55 <srhb> thm_prover: If it's not "you could have invented monads" it'll probably do more harm than good.
15:12:58 <danny__> I was afraid of that, thanks all
15:12:58 <taterbase> Are arithmetic operations lazy?
15:13:04 <taterbase> Like if I say a = 2 * 3
15:13:07 <srhb> taterbase: No
15:13:21 <taterbase> Ok thanks
15:14:06 <johnw> he left already? hrpmh
15:14:08 <johnw> http://stackoverflow.com/questions/6807025/what-is-the-haskell-way-to-copy-a-directory
15:15:00 <srhb> a
15:15:04 <srhb> johnw: Impatient indeed :-)
15:15:21 <johnw> taterbase: you do have to use of the value 'a' though
15:15:33 <johnw> a won't contain 6 prior to evaluation, if that's what you are asking
15:15:42 <taterbase> johnw: that's what I thought
15:15:43 <taterbase> Ok
15:15:46 <taterbase> so it is lazy
15:15:50 <johnw> yes
15:15:53 <taterbase> cool
15:15:55 <taterbase> thank you
15:16:03 <johnw> once it's needed, the arguments to * will be evaluated and then the * itself
15:16:14 <johnw> that is why we say * is strict in its arguments (and all the math ops are)
15:16:33 <srhb> It's not that the arithmetic operation is lazy, mind.
15:16:58 <taterbase> srhb: maybe I'm misunderstanding
15:17:08 <taterbase> is it not lazy in the same way [1..] is?
15:17:14 <srhb> No
15:17:41 <srhb> (:) is lazy in both arguments.
15:17:49 <johnw> [1..] is really 1:2:3:.., and : is lazy in both arguments
15:17:56 <taterbase> Oh!
15:17:57 <srhb> (*) is strict in both arguments
15:18:00 <johnw> or rather, it is non-strict
15:18:04 <srhb> Right.
15:18:24 <Lethalman> srhb, are you sure * is strict in its arguments?
15:18:29 <Lethalman> I mean, is it really that?
15:18:34 <srhb> Yes.
15:18:37 <taterbase> interesting. so * requires both arguments to be non-lazy?
15:18:38 <srhb> (Pretty sure)
15:18:53 <johnw> taterbase: http://stackoverflow.com/questions/7490768/what-are-haskells-strictness-points
15:18:53 <taterbase> Or do I have it all wrong :S
15:18:57 <Lethalman> srhb, can you prove that?
15:19:00 <heath> a math major friend of mine keeps saying this statement is wrong: "This represents a set that contains the first ten natural numbers. The part before the pipe is called the output function, x is the variable, N is the input set and x <= 10 is the predicate. That means that the set contains the doubles of all natural numbers that satisfy the predicate." in reference to http://s3.amazonaws.com/lyah/setnotation.png
15:19:00 <srhb> As in, I'm not sure how it could be done any other way
15:19:12 <srhb> Lethalman: I think it's easier to prove otherwise, if that's the case.
15:19:21 <heath> i'm saying it's equivalent to [x*2 | x <- [1..10]] -- [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
15:19:33 <heath> is this inaccurate?
15:19:33 <Lethalman> srhb, whatever, how would you prove?
15:19:49 <srhb> Lethalman: I wouldn't.
15:20:01 <Lethalman> for example
15:20:07 <Lethalman> > take 3 [1,2,3,10*undefined]
15:20:09 <lambdabot>   [1,2,3]
15:20:18 <Lethalman> doesn't that mean it's lazy?
15:20:32 <srhb> It shows that : is nonstrict in its second argument, ys.
15:20:36 <johnw> heath: yes, that is true
15:20:45 <Lethalman> srhb, can you rephrase?
15:20:46 <hpaste> pwseo pasted ‚Äútransformers‚Äù at http://hpaste.org/84234
15:20:53 <augur> heath: the first sentence in your statement is false
15:20:59 <srhb> Lethalman: Not without losing meaning, I think.
15:21:03 <augur> "This represents a set that contains the first ten natural numbers."
15:21:06 <augur> this is obviously false.
15:21:29 <Lethalman> srhb, ah by : you mean (:)
15:21:39 <srhb> Lethalman: Yes, sorry.
15:21:53 <heath> ah, the first ten natural even numbers
15:21:55 <heath> i see
15:21:57 <heath> that
15:22:05 <tippenein> I think 1 package was downloaded through the sabayon repos rather than cabal, which broke everything (? perhaps ?)
15:22:05 <johnw> health: I was commenting on the equivalence of the intensionally defined set in that image, and your haskell code
15:22:14 <heath> thanks augur
15:22:29 <augur> heath: but i dont know what your friend means. you should ask him to clarify why he thinks its wrong.
15:22:30 <srhb> heath: Not even that, if 0 belongs to N
15:22:31 <johnw> > [2*x | x<-[1..], x <= 10]
15:22:35 <lambdabot>   mueval-core: Time limit exceeded
15:22:35 <Lethalman> srhb, but the operation itself is lazy, isn't it?
15:22:40 <copumpkin> srhb: why not?
15:22:56 <srhb> copumpkin: because 2 /= 0
15:23:03 <copumpkin> srhb: ?
15:23:15 <copumpkin> oh you mean his haskell code?
15:23:23 <srhb> Yes.
15:23:30 <augur> johnw's example is interesting
15:23:42 <srhb> Lethalman: What operation?
15:23:45 <Lethalman> srhb, it operates on strict arguments but that doesn't mean let a = b*c in 54 that "a" will be evaluated right?
15:23:56 <johnw> augur: I guess the predicate doesn't realize that the list is ascending
15:23:59 <augur> > take 20 [ 2*x | x <- [1..], x <= 10 ]
15:23:59 <srhb> Lethalman: No, but that has nothing to do with the strictness of *
15:24:03 <lambdabot>   mueval-core: Time limit exceeded
15:24:03 <johnw> augur: it goes on to test every member
15:24:06 <srhb> Or at least I think not.
15:24:08 <augur> johnw: no, definitely thats why
15:24:20 <Lethalman> mh
15:24:27 <Lethalman> ok
15:24:32 <augur> johnw: but it leads to an interesting question -- can such things be made to work?
15:24:35 <srhb> Lethalman: let foo = a `seq` b -- doesn't mean a is evaluated before foo is either
15:24:42 <augur> > take 10 [ 2*x | x <- [1..], x <= 10 ]
15:24:43 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
15:24:44 <johnw> > take 10 [ 2*x | x <- [1..], x <= 10 ]
15:24:45 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
15:24:46 <johnw> haha
15:24:49 <Lethalman> ok
15:24:52 <augur> > take 11 [ 2*x | x <- [1..], x <= 10 ]
15:24:56 <lambdabot>   mueval-core: Time limit exceeded
15:25:04 <augur> indeed indeed. hmm.
15:25:22 <johnw> it races off into infinity, leaving us to ponder
15:26:04 <augur> indeed
15:28:33 <augur> i feel like i need a gold medallion on my forehead after all those indeeds
15:28:50 * johnw press a gold medallion upon augur's forehead
15:28:57 <augur> owww
15:29:12 <danharaj> I want a data structure like a Map but with efficient lookup of the smallest unused key. What am I looking for?
15:29:13 * johnw presses it gently, sticking it there with olive oil
15:29:41 <johnw> danharaj: you mean the key space is finite?
15:29:50 <danharaj> johnw: I don't see why it needs to be finite.
15:29:57 <johnw> true
15:30:14 <johnw> in C land i'd suggest an augmented rbtree
15:30:19 <johnw> i wonder what the answer is in Haskell land...
15:30:20 <augur> danharaj: thats probably also just a Map-like thing
15:30:35 <danharaj> augur: I was hoping someone knew a hackage package
15:30:39 <augur> danharaj: iinm, map and other efficient set-like data structures often use some sort of balanced tree
15:30:51 <albel727> what, there's no navigable map in haskell?
15:31:01 <johnw> danharaj: maintain an auxiliary value with your Map that records the least unused key
15:31:02 <merijn> Maybe a metric tree?
15:31:19 <augur> danharaj: given that most of these also have an Ord constraint, it should be easy to define your thing
15:31:32 <johnw> (Int, Map Int a), where it begins with (0,empty)
15:31:39 <srhb> johnw: That's difficult once you remove the key you've got stored, no?
15:31:46 <johnw> oh, snap
15:31:54 <stepkut> oh heist
15:31:56 <johnw> yes, you'd have to do a search then
15:32:01 <srhb> Indeed.
15:32:05 * srhb wants gold medallions, too
15:32:16 <danharaj> I mean it wouldn't be hard to roll myself but I am lazy.
15:32:25 <johnw> i have a feeling edwardk would know the answer to danharaj's question in milliseconds
15:32:30 <srhb> I think it's not easy. :P
15:32:48 <johnw> srhb: with an augmented tree it is
15:32:58 <merijn> eh...
15:33:00 <srhb> I haven't read of those. I'll check it out.
15:33:02 <Lethalman> danharaj, a LinkedHashMap with LRU ?
15:33:11 <merijn> FYI, Map implement "findMin :: Map k a -> (k, a)"
15:33:17 <Lethalman> that's what I'd use in java
15:33:20 <johnw> srhb: in each node, you store the least unused key of the left and right
15:33:27 <srhb> johnw: Ah.
15:33:30 <danharaj> merijn: that is smallest used key
15:33:31 <srhb> johnw: Simple enough,
15:33:38 <merijn> if you have an Enum constraint you can just use the predecessor?
15:34:25 * hackagebot pandoc 1.11.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.11.1 (JohnMacFarlane)
15:34:31 <srhb> merijn: HOw so?
15:34:34 <danharaj> merijn: What if findMin gives you the minimum possible value?
15:35:15 <merijn> Yeah, it doesn't really help I just realised
15:35:22 <albel727> Lethalman: why wouldn't you use TreeMap?
15:35:23 <srhb> If the tree has all keys filled continuously from min to max, you still pass through the entire tree
15:35:25 <srhb> yeah..
15:36:09 <danharaj> I think I'll just use a finger tree and an appropriate Monoid
15:36:12 <Lethalman> albel727, he said smallest unused not smallest... no?
15:36:36 <Lethalman> you have to reinsert in the treemap every time
15:36:58 <Lethalman> maybe I didn't get the "smallest unused" part
15:37:50 <albel727> hmm. unused. I missed that. is that to implement some kind of PID/UID allocation scheme?
15:38:41 <danharaj> vaguely
15:40:00 <Lethalman> danharaj, I believe you should clarify what you mean by smallest unused, because they are two characteristics
15:40:13 <srhb> Lethalman: How so?
15:40:27 <Lethalman> srhb, what does he mean by smallest unused?
15:40:37 <srhb> Lethalman: if the keys 0,1,2,3,5,6,7 are used, the smallest unused key is 4
15:40:46 <srhb> Lethalman: Assuming they are natural numbers.
15:41:07 <Lethalman> srhb, and by used he means...?
15:41:17 <srhb> That a value in the Map has that key
15:41:49 <srhb> The completely lazy version is probably to store a keyset alongside :P
15:41:55 <srhb> (Please don't hurt me)
15:43:24 <jfischoff> is there a package that binds to a fast sparse matrix library?
15:43:35 <jfischoff> something with ARPACK bindings perhaps?
15:44:11 <johnw> hmatrix
15:44:17 <johnw> binds to OpenBLAS
15:46:08 <srhb> tippenein: Did you ever paste the original error or solve your problem?
15:47:05 <genisage> ++ is right associative, right?
15:47:09 <Lethalman> ok unused number... I did do something like this (not in haskell) some time ago, didn't know the concept had such name, thanks
15:47:41 <tippenein> srhb: still working on it. about to post a problem with haskell-src-exts as a dependency for xmobar.
15:47:46 <tippenein> I appreciate all the help btw
15:48:00 <monoidal> genisage: yes (you can check it with :i (++))
15:48:10 <genisage> Thanks
15:48:45 <hpaste> tippenein pasted ‚Äúsame error, more context‚Äù at http://hpaste.org/84235
15:49:18 <srhb> tippenein: afraid that doesn't help either
15:49:20 <tippenein> this is after I uninstalled ghc, reinstalled, wiped .cabal, updated and redownloaded everything
15:49:33 <srhb> tippenein: It just shows us that stm is broken, which we already knew.
15:49:58 <tippenein> is 7.4.1 problematic?
15:50:15 <srhb> tippenein: If you can build stm-2.3 with cabal, it would appear you have some global libraries floating around, broken
15:50:19 <srhb> tippenein: Not as such, no.
15:50:22 <shachaf> srhb: ...Oh, the package. Not STM in general.
15:50:31 <srhb> your install is just borked in interesting way
15:50:35 <srhb> shachaf: ;D
15:50:38 <jfischoff> johnw: I'm not finding much on OpenBlas's support for sparse matrices or in hmatrix's doc. Got a link?
15:50:38 <tippenein> lol
15:50:49 <tippenein> quite borked
15:51:00 <srhb> tippenein: Try cabal install stm-2.3
15:51:29 <srhb> tippenein: If you get an error, paste it.
15:51:46 <tippenein> says already installed, so I --reinstall
15:52:00 <tippenein> no problem there
15:52:00 <srhb> Yeah.
15:52:19 <srhb> tippenein: Could you paste ghc-pkg list
15:53:20 <tippenein> sure
15:54:02 <srhb> Also, did you wipe ~/.ghc before as well?
15:54:37 <tippenein> http://hpaste.org/84235
15:54:46 <tippenein> the script does yes
15:55:28 <tippenein> the pkg list looks awfully strange :/
15:55:46 <srhb> Not that strange.
15:56:14 <tippenein> I didn't realize it should be split up into 2 locations
15:56:33 <srhb> That's normal, question is, which is broken
15:56:35 <srhb> Well
15:56:39 <srhb> Presumably it's the global one.
15:57:15 <srhb> Honestly, save yourself the headache, wipe everything and get the binary packages from ghc website and cabal-install from wherever that lives.
15:57:51 <tippenein> Is there more to wipe than uninstalling ghc?
15:58:13 <merijn> tippenein: Might need to nuke ~/.cabal and ~/.ghc
15:58:15 <tippenein> rm -rf ~/.ghc ~/.cabal/lib
15:58:16 <srhb> Well wipe your local stuff as well, and make sure that /usr/lib/ghc.. is gone
16:02:46 <Zoxc> Can you implement type classes by simply duplicating the code for all used types and replacing the type class methods with the calls to the type class instances?
16:03:22 <Zoxc> It would probably complicate the implementation of existential types
16:03:27 <Philippa> Zokc: yes. Monomorphisation followed by dictionary-passing
16:04:50 <Zoxc> That is, instead of passing dictionaries of functions
16:04:52 <monoidal> um why do you need to duplicate the code?
16:05:40 <arkeet> replace classes with data types, instances with values thereof (dictionaries), and class constraints with dictionary arguments.
16:05:44 <arkeet> that's basically how it's implemented.
16:06:17 <Philippa> Zoxc: yeah, you'd be inlining the dictionaries
16:07:03 <c_wraith> ... I still *really* want a pragma to tell GHC to specialize a function based on the value of an argument, if it's known at compile time.
16:08:13 <c_wraith> It'd allow use of higher-order functions in very performance-sensitive tight loops.
16:08:38 <Zoxc> Philippa: So another way to phrase my question would be to ask if the inlining of the dictionary can fail
16:08:55 <arkeet> Zoxc: polymorphic functions.
16:10:23 <c_wraith> haskell allows polymorphic recursion, such that you can't know all types at compile time.
16:11:02 <arkeet> Zoxc: if the instance to be chosen is known at compile time (e.g. if it's monomorphic, or with a SPECIALIZE pragma), ghc will inline the dictionaries.
16:11:28 <Nisstyre-laptop> Zoxc: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
16:12:31 <c_wraith> @ty let dumbExample :: Show a => a -> Int -> IO () ; dumbExample x 0 = print x ; dumbExample x n = dumbExample [x] (n - 1) in dumbExample
16:12:33 <lambdabot> Show a => a -> Int -> IO ()
16:12:54 <Philippa> c_wraith: that's only /nearly/ true, and you only need to pass a residue of them
16:13:04 <Philippa> but it'd need special handling, yes
16:13:12 <arkeet> > let dumb :: Show a => a -> Int -> String; dumb x 0 = show x; dumb x n = dumb [x] (n-1) in dumb () 3
16:13:14 <lambdabot>   "[[[()]]]"
16:13:16 <Philippa> (because sometimes you'll need to pass instance-residue in)
16:13:45 <arkeet> the dictionary can't be inlined here for the same reason recursive functions can't be inlined.
16:13:52 <shachaf> Polymorphic recursion is, like, crazy, man.
16:14:03 <shachaf> How does jhc handle it?
16:14:05 <c_wraith> hmm, yes, that's a much better example than mine
16:14:09 <Nisstyre-laptop> shachaf: do you have a use for it?
16:14:16 <c_wraith> since lambdabot can actually run it.
16:14:35 <arkeet> > let dumb :: Show a => a -> Int -> String; dumb x 0 = show x; dumb x n = dumb (x,x) (n-1) in dumb 0 3
16:14:36 <lambdabot>   "(((0,0),(0,0)),((0,0),(0,0)))"
16:14:52 <shachaf> Nisstyre-laptop: For polymorphic recursion?
16:14:55 <Nisstyre-laptop> shachaf: yes
16:15:09 <shachaf> Data.Sequence?
16:15:21 <Nisstyre-laptop> that uses it? interesting
16:15:31 <shachaf> Doesn't it?
16:15:46 <c_wraith> I'm pretty sure it does
16:15:59 <monoidal> Nisstyre-laptop: a lot of irregular purely functional structures use it, check okasaki
16:16:29 <arkeet> yeah, doesn't Data.Sequence use a type to tag the depth in the tree or something?
16:16:33 <c_wraith> yes
16:16:46 <bitonic> ‚Äòbound‚Äô uses polymorphic recursion
16:16:46 <arkeet> there, polymorphic recursion.
16:16:56 <bitonic> there are a lot of uses for polymorphic recursion
16:17:04 <bitonic> it‚Äôs a pity that inference is undecidable
16:17:27 <c_wraith> Still, haskell's solution (allow it, but require it to be manually annotated) is nicer than ML's
16:17:34 <bitonic> that‚Äôs for sure
16:19:28 <arkeet> probably any use of type-level naturals needes polymorphic recursion.
16:20:36 <bitonic> if you have dependent types or something that resembles it every other function has polymorphic recursion :)
16:20:41 <arkeet> :p
16:20:48 <monoidal> curious simple case: "x = x x", normally occurs check but works with "x :: a"
16:21:34 <arkeet> :t let x :: a -> (); x = x x in x
16:21:39 <lambdabot>     Couldn't match expected type `a -> ()' with actual type `()'
16:21:39 <lambdabot>     In the return type of a call of `x'
16:21:39 <lambdabot>     Probable cause: `x' is applied to too many arguments
16:21:43 <arkeet> duh
16:22:15 <monoidal> :t let x :: a; x = x x in x
16:22:16 <lambdabot> a
16:22:37 <bitonic> monoidal: well, that has to do with the fact that higher ranked inference is undecidable too
16:23:11 <bitonic> I... think
16:23:40 <bitonic> I mean I‚Äôd expect an inference algo for polymorphic *functions* to infer an arrow type for `x'
16:25:00 <arkeet> :t let x :: a -> (b; x = x x in x
16:25:02 <lambdabot> parse error on input `;'
16:25:03 <arkeet> :t let x :: a -> b; x = x x in x
16:25:05 <lambdabot> a -> b
16:25:15 <parcs> x = x x is polymorphic recursion
16:25:44 <bitonic> parcs: yes, but I‚Äôd expect an arrow type to be inferred
16:25:51 <arkeet> :t let x :: (a -> b) -> b; x = x x in x
16:25:52 <Philippa> shachaf: I'd imagine jhc passes dictionary-names
16:25:52 <lambdabot> (a -> b) -> b
16:25:58 <arkeet> :t let x :: ((a -> b) -> b) -> b; x = x x in x
16:25:59 <lambdabot> ((a -> b) -> b) -> b
16:26:06 <Philippa> (thus giving it the chance to optimise the dictionary lookup/building process)
16:26:32 <arkeet> bitonic: would you expect the types inside the arrow type to be inferred too?
16:26:57 <arkeet> :t let x :: (a -> b) -> c; x = x x in x
16:26:58 <lambdabot> (a -> b) -> c
16:27:10 <arkeet> :t let x :: (a -> b) -> (c -> d)
16:27:11 <lambdabot> <no location info>:
16:27:11 <lambdabot>     not an expression: `let x :: (a -> b) -> (c -> d)'
16:27:20 <arkeet> what?
16:27:32 <bitonic> arkeet: that‚Äôs a fair point :).  I guess I was focusing on having polymorphic arguments, I‚Äôm still not sure on whether this problem and higher ranked inference are connected
16:28:04 <parcs> bitonic: wikipedia says type inference for polymorphic recursion is undecidable
16:28:15 <arkeet> ah, proof by wikipedia
16:28:16 <bitonic> parcs: yeah I knew that much
16:28:16 <arkeet> :)
16:28:38 <bitonic> parcs: but I was wondering if inferring `forall a. a' for that term incurs in other problems as well
16:28:52 <arkeet> that would be a pretty pointless type to infer
16:29:26 <parcs> :t let x = x x in x
16:29:27 <lambdabot>     Occurs check: cannot construct the infinite type: t1 = t0 -> t1
16:29:28 <lambdabot>     In the return type of a call of `x'
16:29:28 <lambdabot>     Probable cause: `x' is applied to too many arguments
16:29:36 <bitonic> arkeet: well, it‚Äôs quite useful to have a type system that tells you what‚Äôs _|_!
16:29:53 <arkeet> but it has a more specific type than that!
16:30:03 <bitonic> but we want the most general!
16:30:16 <arkeet> yes, it has a more specific most general type.
16:30:24 <bitonic> aaahhhh.
16:30:34 <arkeet> or does it.
16:30:39 <monoidal> note that x = x x works without -xrankntypes, although this is far from a proof
16:31:01 <arkeet> never mind. :p
16:32:15 <bitonic> monoidal: well yeah `forall a. a' is rank 1.  my comment derives that from how inference in HM (W) works, an abstraction *must* have an arrow in its type
16:33:02 <otters> :t let x = x x in x
16:33:03 <lambdabot>     Occurs check: cannot construct the infinite type: t1 = t0 -> t1
16:33:03 <lambdabot>     In the return type of a call of `x'
16:33:03 <lambdabot>     Probable cause: `x' is applied to too many arguments
16:33:22 <shachaf> :t let x :: x; x = x x in x
16:33:23 <lambdabot> x
16:33:33 <arkeet> ok, I guess I agree that x = x x should be forall a. a
16:33:33 <arkeet> :p
16:34:06 <bitonic> arkeet: I doubt you can find a type more general than that
16:34:10 <arkeet> indeed
16:34:29 <bitonic> the land of _|_
16:37:11 <Zoxc> so polymorphic recursion basically constructs new types at runtime
16:37:43 <arkeet> no
16:37:44 <bitonic> Zoxc: at runtime it doesn‚Äôt really matter - types can be erased safely
16:37:45 <arkeet> types don't exist at runtime
16:37:56 <bitonic> in languages like Haskell anyway.
16:38:27 <bitonic> I‚Äôd argue that types exist very much at runtime, but people can‚Äôt mess with them :P
16:38:54 <parcs> polymorphic recursion is just a fancy name for a recursive function whose type can't be inferred
16:39:10 <Zoxc> Anything else that would prevent dictonaries from being inlined?
16:39:47 <bitonic> parcs: that‚Äôs a weird way of looking at it, imo.  polymorphic recursion is when you re-instantiate the type variables in the recursive calls
16:39:54 * Zoxc is designing a language and is trying to steal as many features from Haskell as possible =P
16:39:56 <bitonic> the fact that it‚Äôs undecidable it‚Äôs a bad suprise :(
16:40:24 <danharaj> Polymorphic recursion isn't a feature of Haskell. It is something you can do with higher rank types.
16:40:41 <monochrom> "recursive function whose type can't be inferred" may be too broad
16:40:42 <bitonic> danharaj: you don‚Äôt need higher ranked types to have it
16:41:00 <parcs> :t let f x = f (show x, show x) in f
16:41:01 <lambdabot> (String, String) -> t
16:41:18 <bitonic> haskell98 (or Mycroft‚Äôs ML) have polymorphic recursion but no higher ranked types
16:41:19 <monoidal> "fix :: (a -> a) -> a" gives normal recursion. is there a combinator supporting polymorphic recursion?
16:41:42 <danharaj> bitonic: I guess we should define polymorphic recursion more precisely.
16:41:50 <parcs> :t let f x = show x ++ f (x,x) in f
16:41:52 <lambdabot>     Occurs check: cannot construct the infinite type: t0 = (t0, t1)
16:41:52 <lambdabot>     In the expression: x
16:41:52 <lambdabot>     In the first argument of `f', namely `(x, x)'
16:42:03 <parcs> :t let f :: Show a => a -> String; f x = show x ++ f (x,x) in f
16:42:05 <lambdabot> Show a => a -> String
16:42:06 <bitonic> monoidal: yeah
16:42:36 <monoidal> > let f :: Show a => a -> String; f x = show x ++ f (x,x) in f 0
16:42:45 <lambdabot>   "0(0,0)((0,0),(0,0))(((0,0),(0,0)),((0,0),(0,0)))((((0,0),(0,0)),((0,0),(0,...
16:43:03 <bitonic> danharaj: isn‚Äôt ‚Äòreinstantiate type variables in recursive calls‚Äô precise enough?
16:43:48 <danharaj> bitonic: sure, but the way I'm picturing the fixpoint operator used to make the recursion happen, there's a higher rank type somewhere.
16:44:11 <arkeet> "f = fix (\k x -> show x ++ k (x,x))"
16:44:17 <arkeet> what's the type of the lambda?
16:44:29 <bitonic> danharaj: not necessarely.  if you defined types as in HM - e.g. you have type schemes and types - you can work out a polymorphic Fix
16:44:54 <bitonic> without ever writing an higher ranked type
16:45:00 <danharaj> bitonic: ok I see. But say we were working in pure System F, then what?
16:45:18 <arkeet> Show a => ((a,a) -> String) -> a -> String?
16:45:19 <bitonic> danharaj: well you can‚Äôt bring that assumption to the table now :P
16:45:25 <danharaj> bitonic: just clarifying :P
16:46:00 <bitonic> danharaj: btw, Mycroft works as I described
16:46:44 <parcs> arkeet: (forall b. Show b => b -> String) -> a -> String
16:47:04 <arkeet> hmm
16:47:26 <danharaj> :t \k x -> show x ++ k (x, x)
16:47:27 <lambdabot> Show t => ((t, t) -> String) -> t -> String
16:47:37 <danharaj> :t fix (\k x -> show x ++ k (x, x))
16:47:39 <lambdabot>     Occurs check: cannot construct the infinite type: t0 = (t0, t1)
16:47:39 <lambdabot>     In the expression: x
16:47:39 <lambdabot>     In the first argument of `k', namely `(x, x)'
16:48:28 <danharaj> Seems a little unsatisfying though.
16:48:34 <arkeet> so our "fix" would have type
16:48:51 <bitonic> :t fix (\(k :: forall a. a -> a) x -> show x ++ k (x, x))
16:48:52 <lambdabot>     Couldn't match expected type `forall a. a -> a'
16:48:52 <lambdabot>                 with actual type `t0 -> t1'
16:48:52 <lambdabot>     In the pattern: k :: forall a. a -> a
16:49:06 <arkeet> (forall a. Show a => (forall b. Show b => b -> String) -> a -> String) -> t -> String
16:49:06 <arkeet> ?
16:49:20 <monochrom> under normal use, "\k" makes k monomorphic. add some type sigs to make it polymorphic
16:49:31 <bitonic> :t fix (\(k :: forall a. Show a => (a, a) -> String) x -> show x ++ k (x, x))
16:49:32 <lambdabot>     Couldn't match expected type `forall a. Show a => (a, a) -> String'
16:49:32 <lambdabot>                 with actual type `t0 -> t1'
16:49:32 <lambdabot>     In the pattern: k :: forall a. Show a => (a, a) -> String
16:49:34 <arkeet> (forall a. (forall b. f b) -> f a) -> f t ?
16:49:45 <arkeet> where f a = Show a => a -> String.
16:49:47 <arkeet> if that even makes sense.
16:50:45 <bitonic> well this doesn‚Äôt work because `x' is not of the right type
16:51:27 <bitonic> I mean when you use `fix' to define a function, you pass it something of the form `(a -> a) -> (a -> a)'
16:52:06 <bitonic> but if you quantify the argument type for the function argument the actual argument (`x') won‚Äôt be equal
16:53:44 * bitonic is about to fall asleep
16:53:57 <bitonic> night
16:54:27 * hackagebot OpenGL 2.8.0.0 - A binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGL-2.8.0.0 (JasonDagit)
16:54:29 * hackagebot GLUT 2.4.0.0 - A binding for the OpenGL Utility Toolkit  http://hackage.haskell.org/package/GLUT-2.4.0.0 (JasonDagit)
16:57:26 <hpaste> arkeet pasted ‚Äúfix for polymorphic recursion‚Äù at http://hpaste.org/84239
16:57:27 <arkeet> ^
16:58:47 <dmwit> copumpkin: Oh shit, I didn't know about enumerable!
16:58:55 <dmwit> uh, I mean, snap
16:59:10 <copumpkin> dmwit: it's ancient and was some of the earliest haskell I wrote, so I don't think much is lost :P
16:59:28 <arkeet> > let f :: Show a => a -> String; f x = show x ++ f (x,x) in take 100 . show $ f ()
16:59:28 <dmwit> I have to look at it later for social reasons, though.
16:59:30 <lambdabot>   "\"()((),())(((),()),((),()))((((),()),((),())),(((),()),((),())))(((((),()...
16:59:32 <arkeet> :p
16:59:34 <copumpkin> I've fooled around with the same idea in Agda though
16:59:34 <dmwit> sorry
16:59:42 <copumpkin> and I do kinda like my function instance
17:00:04 <arkeet> > let f :: (Num a, Show a) => a -> String; f x = show x ++ f (x+1,x+1) in take 100 . show $ f 0
17:00:06 <lambdabot>   Could not deduce (GHC.Num.Num (a, a)) arising from a use of `f'
17:00:06 <lambdabot>  from the c...
17:00:09 <arkeet> doh
17:00:14 <copumpkin> then you can write instance (Finite a, Eq b) => Eq (a -> b)
17:00:14 <arkeet> > let f :: Show a => a -> String; f x = show x ++ f (x,x) in take 100 . show $ f 0
17:00:17 <lambdabot>   "\"0(0,0)((0,0),(0,0))(((0,0),(0,0)),((0,0),(0,0)))((((0,0),(0,0)),((0,0),(...
17:00:21 <copumpkin> which is the most awesome instance evar
17:00:44 <copumpkin> and you can even write (Finite a, Eq b) => Ord (a -> b) or Finite a, Ord b => Ord (a -> b)
17:00:50 <arkeet> > let f :: Show a => a -> String; f x = show x ++ f (x,x) in take 100 . show $ f (text "")
17:00:52 <lambdabot>   "\"(,)((,),(,))(((,),(,)),((,),(,)))((((,),(,)),((,),(,))),(((,),(,)),((,),...
17:00:55 * lispy updates OpenGL/GLUT and runs away to hide from the framewars that might ensue over this update
17:00:57 <arkeet> beautiful.
17:01:07 <arkeet> lispy: you are horrible.
17:01:26 <lispy> arkeet: my hackage release is bad and I should feel bad :)
17:01:36 <arkeet> almost as horrible as shachaf
17:02:10 <Kaidelong> I take it framewar is supposed to be some kind of graphics related pun
17:02:17 <arkeet> that's the horrible part.
17:02:23 <Kaidelong> has anyone here used Data Supported Haskell?
17:02:29 <Kaidelong> yeah, determined as much
17:03:13 <arkeet> I wonder if this polyfix is too restrictive.
17:03:15 <Kaidelong> I should probably compile libraries I've used in the past that worked well
17:03:49 <monoidal> arkeet: I think you might get some more generality with polykinds
17:03:55 <arkeet> I was thinking that.
17:04:33 <arkeet> but I mean even for simple stuff.
17:06:57 <Kaidelong> random-fu, haskell-mpi, bmp, accelerate, GHood all come to mind
17:09:27 * hackagebot jmacro 0.6.4 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.6.4 (GershomBazerman)
17:15:32 * MidnightSun99  Picture of my ex-girlfriend naked: http://imagetwist.com/9au1ada5n7nu
17:20:19 <Sgeo> Is there a nice library for conveniently using RESTful APIs?
17:27:30 <Sgeo> Suppose I have a bunch of IO performing things, each of which should refer to some persistent state
17:28:01 <Sgeo> Would it make sense to have the last argument be some entity and then return IO () (or whatever), so that reader monad can easily be used?
17:28:10 <Sgeo> Or is making the thing the first argument better somehow/
17:28:14 <Sgeo> Or making a custom monad/
17:29:37 <Cale> Sgeo: another option is just to define them all inside of an IO action where you have constructed an IORef which they can share.
17:30:00 <arkeet> that provides no benefit if you're just reading.
17:30:22 <Sgeo> At least one mutates... something
17:30:29 <Cale> Or also, note that you can create an IORef and then pass (readIORef r) and (writeIORef r) to separate parts of the computation. This little bit of abstraction I've often found very useful later on.
17:31:12 <Cale> (Because it lets you replace the manner in which that state is read from or written to, and change the semantics of that from a central location)
17:31:17 <Sgeo> That sort of thing (define them all in an IO action) doesn't work well when I want each thing to have a top level name
17:31:31 <Cale> That's true
17:32:10 <Cale> So if you want them to be top level, you need them to take some sort of parameter. I wouldn't worry *too* much about which parameter it is -- do whatever's most convenient for you.
17:33:01 <Cale> Some people like ReaderT or whatever, but unless you're going to build up a wide range of actions in your transformed IO monad, it's not worth it.
17:33:45 <Cale> (You have to weigh the tax of applying liftIO to all your plain IO computations versus the additional parameter passing)
17:34:12 <Sgeo> Lisps don't have this problem, they'd probably just use a dynamically scoped variable
17:34:14 <Cale> Personally, I prefer to err on the side of more parameter passing, because it's nicely explicit.
17:34:25 <Cale> Dynamic scope sucks for a lot of other reasons though.
17:34:26 <pharaun> i like parameter passing
17:34:27 * hackagebot HStringTemplate 0.7.1 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.7.1 (SterlingClover)
17:34:46 <pharaun> imho being explicit is a general win usually
17:35:13 <Sgeo> There's still no library to make consuimg RESTful resources easier?
17:36:14 <Clint> Sgeo: what does that mean?
17:36:50 <Cale> There are plenty of HTTP client libraries :P
17:37:10 * Cale refuses to admit that there's a difference between REST and standard HTTP usage. :P
17:39:34 <Sgeo> Hmm, I could just live in the Browser monad, I guess
17:39:39 <Sgeo> In this case
17:41:12 <dmwit> copumpkin: Ah, yes, I really meant to include that function instance. Somebody suggested (by email) an instance for representable functors, too (which I guess is nearly identical).
17:41:22 <copumpkin> ah, probably
17:41:35 <copumpkin> dmwit: an interesting direction that I wanted to take it but never got around to
17:41:47 <copumpkin> was to allow the enumeration of bottoms, optionally
17:41:59 <donri> Sgeo: i think http-{conduit,streams} are the current recommendations
17:42:00 <dmwit> Right, I see this enumeratePartial stuff is probably about that.
17:42:04 <dmwit> Is that useful?
17:42:12 <copumpkin> probably not too useful, except for smallcheck-like testing of strictness properties
17:43:03 <dmwit> ah
17:43:19 <dmwit> I wonder whether some kind of enumeration of zippers might cover that use case.
17:43:33 <dmwit> Probably not, since you want multiple holes (?).
17:44:19 <Sgeo> What about http-conduit-browser
17:46:39 <Cale> The conduit stuff is mostly if you're using yesod or something. I honestly wouldn't bother with any of the iteratee libraries unless I was required to by a dependency or performance constraints. The plain ol' HTTP library works just fine to make requests. :P
17:47:01 <Heffalump> if you don't want https, anyway :-(
17:47:15 <pharaun> i don't mind conduit, once you wrap your head around it, its not *too* bad
17:47:19 <pharaun> it can get a tad fancy
17:49:17 * interzoneboy loves haskell
17:49:28 * hackagebot log-domain 0.2 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.2 (EdwardKmett)
17:49:34 <Cale> I just don't like pulling in machinery which exposes such complicated types if I can avoid it.
17:52:08 <arkeet> I still wish we could specify that a type family was injective.
17:52:52 <arkeet> wait.
17:52:57 <arkeet> never mind, I don't need that here.
17:53:12 <TravisD> Is it bad style to make a Num instance for pairs of Nums?
17:53:55 <pharaun> Cale: fair enough :) i prefer to avoid if i could but for what they do i think they do it alright
17:55:30 <lightquake> TravisD: you mean to define instance (Num a, Num b) => (a, b)?
17:55:33 <arkeet> heh
17:55:36 <lightquake> yes, because that's an orphan instance, which are (generally) bad
17:55:44 <lightquake> er, => Num (a, b) obviously
17:55:46 <arkeet> I was just thinking "it would be nice if Data.Proxy used PolyKinds" and I see that it actually does now.
17:55:52 <TravisD> lightquake: What's an "orphan instance"?
17:55:53 <Cale> It seems to me like most (all?) of the iteratee libraries push the Haskell type system into an uncomfortable place. Perhaps with dependent typing or some newer type system features, a lot of the things going on could be tidied up.
17:56:09 <arkeet> TravisD: an instance that's defined neither in the same module as the class or as the same module as the data type.
17:56:19 <TravisD> Ah
17:56:41 <arkeet> Cale: uncomfortable how?
17:56:43 <pharaun> Cale: is that from their abstraction or?
17:56:50 <TravisD> And the reason such an instance doesn't already exist is because there's not a natural way to do it?
17:57:20 <lightquake> TravisD: orphan instances are bad because you can't not export an instance, so somebody that imports MyModule now has a completely unrelated instance
17:57:49 <lightquake> TravisD: i would assume it's because fromInteger doesn't really have a clear definition
17:57:55 <Cale> arkeet: Here's a nice example from the pipes library: (\>\) :: (Interact p, Monad m) => (b' -> p a' a x' x m b) -> (c' -> p b' b x' x m c) -> c' -> p a' a x' x m c
17:58:14 <arkeet> what about it?
17:58:15 <otters> oh come on that's totally straightforward
17:58:20 <arkeet> haha
17:58:47 <otters> it takes a b' -> p a' a x' x m b and a c' -> p b' b x' x m c and returns a c' -> p a' a x' x m c
17:59:06 <TravisD> lightquake: Yeah, that makes sense. There's no "most natural" choice for some functions
17:59:08 <arkeet> Cale: what about lens?
17:59:10 <Cale> Basically, far too many type parameters with no way to rein them in and express what's going on more clearly. You can stare at that and work out what it means, but it's obviously a mess. :P
17:59:12 <lightquake> i feel like that'd be nicer if the variable names weren't all single letters
17:59:41 <edwardk> arkeet: i freely admit that a number of the types in lens are somewhat.. over the top.
17:59:44 <Cale> It could also be worse if the variable names were longer...
17:59:49 <arkeet> edwardk: haha
18:00:06 <Cale> (because then you start to lose sight of what's going on structurally)
18:00:10 <edwardk> lightquake: if you lengthen the variable names all you get are several lines of impenetrable names between you and the symbols you used to put them together
18:00:32 <edwardk> the structure of the type signature is what you want. a type variable's job is to be distinguishable but short enough to 'chunk'.
18:00:47 <edwardk> if its too long you can't see the shape of the forest, just the trees
18:01:47 <lightquake> also, \>\ is a pretty awful operator
18:01:52 <lightquake> i keep wanting to parse the \ as escapes
18:02:05 <shachaf> \‚á≤\
18:02:05 <edwardk> or just listen to bruce lee explain the problem with focusing on the type variables: http://revision3.com/melodysheep/bruce-lee
18:02:24 <lightquake> edwardk: haha
18:02:59 <lightquake> cale: i'm curious, what do you think would be useful to alleviate this problem?
18:03:45 <edwardk> who knew that bruce was a functional programmer at heart
18:03:47 <Cale> lightquake: Well, a way to give bundles of type variables names and then operate on them functionally would work.
18:04:00 <lightquake> like?
18:07:04 <Cale> Well, these things which p is abstracting over all have their first 2 type parameters being the types of request and response in the communication to the upstream interface, and then the next 2 type parameters being the types of request and response in the communication with the downstream interface. Then they're parameterised by a monad, and then finally a result type (these are monad transformers)
18:07:38 <Cale> It would be good if somehow these parts of the parameters could be named and discussed in a way which isn't just positional.
18:08:00 <Cale> I'm not sure exactly how it might look.
18:09:43 <Cale> I think even just type level pairs would help to cut down on the number of parameters though.
18:10:18 <Cale> Because the downstream types don't really need to get destructured like that, they just need to be the same.
18:16:52 <Cale> (\>\) :: (Interact p, Monad m) => (Request (Upstream b) -> p a m (Response (Upstream b))) -> (c' -> p b m c) -> c' -> p a m c -- Would this be better? I'm not sure. Here a and b have a different kind.
18:17:07 <Cale> I think it's a little better.
18:17:42 <Cale> Hopefully possible to be cleaner still.
18:18:53 <arkeet> or just replace b' -> p a' a x' x m b with Something m x a b
18:19:22 <pharaun> Cale: that seems a bit more clearer
18:19:51 <arkeet> except no
18:22:14 <Cale> So, we'd need something like Upstream, Downstream :: Node -> Channel, and Request, Response :: Channel -> * (or with some other names, I'm not terribly happy with those) and then we need other-kinded polymorphism.
18:22:37 <ctc> is it possible to write a default for an associated type?
18:23:04 <arkeet> ctc: it seems so.
18:23:11 <ctc> how?
18:23:12 <Cale> http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/type-families.html#assoc-decl-defs
18:23:21 <Cale> wrong version, sorry
18:23:25 <arkeet> the same way you'd write one for an instance.
18:23:29 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-families.html#assoc-decl-defs
18:23:48 <arkeet> class C a where
18:23:50 <Cale> (docs haven't changed anyway)
18:23:58 <arkeet> type T a
18:23:58 <arkeet>   type T a = ()
18:23:59 <arkeet> say
18:24:12 <arkeet> oops, spacing.
18:24:23 <ctc> oh I see
18:24:56 <ctc> expected all in one line
18:26:07 <ctc> type T a; type T a = ()  is ugly
18:33:29 <bgamari> Why does hmatrix's Data.Packed.Matrix.mapWithIndex coerce the indices to the element type?
18:33:52 <bgamari> mapMatrixWithIndex :: (Storable t, Element a, Num a) => ((a, a) -> a -> t) -> Matrix a -> Matrix t
18:34:06 <bgamari> whereas the vector case is sane
18:34:07 <bgamari> mapVectorWithIndex :: (Storable a, Storable b) => (Int -> a -> b) -> Vector a -> Vector b
18:52:46 <Hugglesworth> so, no matter the version of ghc I'm using, the show-0.5 lib fails to compile for stupid reasons "Constructor `Failure` should have 8 arguments, but has been given 7"
18:53:01 <Hugglesworth> and I'd like to figure it out, 'cause I think it'd be cool to have a lambdabot
18:53:32 <Hugglesworth> it fails for me with both 7.6.2 and 7.4.2
18:53:41 <Hugglesworth> same error
18:53:50 <shachaf> builds for me
18:53:54 <shachaf> 7.6.2
18:54:02 <Hugglesworth> and if I use the previous version of show off hackage (not 0.5), it gives me an other stupid error
18:54:05 <Cale> Hugglesworth: Well, this constructor is part of QuickCheck, so I suspect the version of QC you're using is different than what's expected.
18:54:05 <Hugglesworth> hrm
18:54:34 <Cale> http://hackage.haskell.org/packages/archive/show/0.5/doc/html/src/ShowQ.html#tests -- it's pattern matched on here
18:54:59 <Cale> tbh, that code should probably use  Failure {} rather than all the underscored
18:55:04 <Cale> underscores*
18:55:45 <Cale> But many people are unaware of that little feature (it works even with types that were not defined using record syntax)
18:56:34 <Hugglesworth> shachaf: what's your version of quickcheck?
18:56:48 <shachaf> 2.5.1.1
18:57:36 <Hugglesworth> yeah, that looks like the difference then
18:58:15 <Cale> Yeah, the newest QC has 8 parameters.
18:58:42 <Cale> It would be good for someone to replace those underscores in the pattern matches with {} which should make that code work with either version.
18:59:54 <Hugglesworth> just changed the version of QC it's expecting
18:59:58 <Hugglesworth> compiled fine
19:01:17 <Hugglesworth> hrm, why isn't cabal seeing my installed show
19:01:24 <Hugglesworth> it still tries to build off hackage
19:02:54 <pharaun> {} hm?
19:03:18 <geekosaur> the degenerate case of record pattern syntax
19:03:50 <pharaun> i figured, but why would i want to use Failure {} vs _
19:03:55 <pharaun> looking around to see if i can find info
19:04:02 <geekosaur> so you don't have to count the _s
19:04:09 <geekosaur> exactly as described previously
19:04:20 <geekosaur> (or so you can be lazy and not type a bunch of _s)
19:04:53 <pharaun> geekosaur: so like "foo {} x y = whatever vs foo _ _ _ _ x _ y = whatever ?
19:05:11 <geekosaur> no, it has to be used with a constructor
19:05:24 <geekosaur> foo (Constructor {}) ... = ...
19:06:22 <geekosaur> for the case when you care only about the exact constructor but not the fields/data values. sometimes used as foo x@(Constructor {}) ... = ... when you need to match the constructor and send the whole record on to something else without otherwise inspecting it
19:06:33 <aavogt> > let f Just {} 1 = 2 in f (Just 3) 1
19:06:34 <lambdabot>   2
19:07:03 <geekosaur> and yes, the parens are (or should be, as with record update syntax) optional but recommended for comprehensibility
19:07:21 <pharaun> geekosaur: thanks :)
19:07:36 <pharaun> i've used records but wasn't aware of the dengerate case
19:12:11 <Hugglesworth> also on the list of lambdabot shit to fix: OldException is depreciated
19:12:23 <Hugglesworth> and doesn't exist in the newest compiler
19:14:19 <gienah> Hugglesworth: we have a patch for that
19:15:13 <gienah> Hugglesworth: in the files directory under here: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/dev-haskell/lambdabot
19:25:33 <NemesisD> what data structure do you guys reach for listlike structures that have efficent tail appends instead of efficient head appends
19:26:12 <shachaf> Reversed lists.
19:28:59 <luite> NemesisD: also Data.Sequence
19:30:37 <NemesisD> ah ok. i'll check that out
19:32:09 <NemesisD> looks like ClassyPrelude includes it
19:32:56 <shachaf> ?
19:33:03 <shachaf> Data.Sequence is from containers
19:33:12 <shachaf> ClassyPrelude is a different beast.
19:39:55 <NemesisD> shachaf: sorry, i meant that it reexports it and provides instances for all the prelude methods that apply to it
19:41:32 <shachaf> I would not recommend switching to ClassyPrelude for that.
19:49:30 <NemesisD> shachaf: i happen to be using it on the project
20:01:18 <tippenein> upon a fresh install of haskell-platform on xubuntu I still have a problem getting packages with cabal-install
20:01:59 <monochrom> perhaps the problem is with your ~/.ghc rather than haskell-platform
20:02:19 <monochrom> read my http://www.vex.net/~trebla/haskell/sicp.xhtml
20:02:53 <donri> tippenein: better @hpaste an example problem
20:03:01 <hpaste> tippenein pasted ‚Äúxmonad build fail‚Äù at http://hpaste.org/84245
20:03:28 <tippenein> I would paste it in xmonad, but I imagine all those ppl are here too
20:03:59 <monochrom> "configure: error: X11/extensions/Xrandr.h (from libXrandr) is required" seems important
20:04:19 <geekosaur> you are probably missing your OS's XRandR dev package
20:04:32 <tippenein> ah, quite possible
20:06:11 <geekosaur> looks like the xorg-dev package should pull in everything you would need
20:08:10 <tippenein> sorry, I should've figured that. needed libxrandr-dev not just xrandr
20:08:19 <geekosaur> yes
20:08:33 <geekosaur> as I mentioned, the metapackage should pull in any other dev packages you might need
20:09:47 <tippenein> I was just paranoid because my ghc and cabal was broke pretty hard about 2 hours ago and this is the rebuild
20:14:09 <danharaj> I am watching Edwin Brady's third Idris video and I am experiencing something like what I experienced when I first learned Haskell.
20:15:50 <TravisD> Are there many companies that use Haskell?
20:16:02 <danharaj> define many
20:16:16 <TravisD> mmh, enough that you could find a job in most major cities :P
20:16:22 <danharaj> define major
20:16:27 <danharaj> (just kidding)
20:16:30 <TravisD> hehe :)
20:16:44 <danharaj> There are companies in pretty much every major tech city of the US at least.
20:17:03 <danharaj> I would not say they are common enough that you could get a job is *every* major city.
20:17:08 <danharaj> s/is/in
20:17:17 <TravisD> Ah, that's great
20:17:28 <TravisD> (I'm not looking for a job - I was just curious)
20:18:01 <danharaj> A functional programmer would do well to learn Scala/Erlang/OCaml etc. to expand their job opportunities.
20:18:33 <TravisD> ah yeah
20:18:51 <TravisD> I was originally planning to learn Scala, but #Scala told me to learn haskell instead :)
20:19:00 <danharaj> That is a weird thing for #Scala to suggest.
20:19:11 <TravisD> or - told me that it might be a better language to learn about fp
20:20:26 <geekosaur> not that improbable then, since a large part of the point of scala is sticking closeish to java (and in fact last I checked, it compiled to java)
20:21:14 <sw2wolf> Maybe Clojure is better than Scala
20:21:30 <TravisD> Does clojure have types?
20:21:34 <TravisD> I also checked it out before Haskell
20:21:54 <Rogach> Hello! I'm trying to call C function from Haskell, and seem to have troubles. I have a C source files, sieve.h and sieve.c, which I compile with "gcc -std=gnu99 -o sieve.o sieve.c", Haskell source with "main", and .hs for ffi. All those I compile with "ghc --make -o primes primes.hs sieve_ffi.hs sieve.o". It complains "sieve.o: file not recognized: File
20:21:54 <Rogach> format not recognized". What could be wrong?
20:21:58 <sw2wolf> You can use types which seems ugly
20:22:15 <sw2wolf> in Clojure
20:22:25 <m3ga> TravisD: haskell is probably the best example of what a good statically typed FP langauge should me.
20:22:27 <shachaf> Rogach: Lots of things.
20:22:39 <shachaf> Rogach: What if you give ghc sieve.c instead of .o?
20:22:51 <TravisD> Anyways, thanks :) I don't know what prompted me to ask about companies
20:23:20 <Rogach> shachaf: "error: ‚Äòfor‚Äô loop initial declarations are only allowed in C99 mode"
20:23:31 <Rogach> shachaf: I need to pass -std=gnu99 to gcc somehow.
20:23:46 <m3ga> TravisD: i'm using Haskell in my day job. i now quite a few others that use haskell at work as well.
20:23:49 <shachaf> Use -optc?
20:23:58 <shachaf> However, it *should* work with the .o
20:24:10 <shachaf> Rogach: Wait, are you not passing -c to gcc?
20:24:39 <Rogach> shachaf: Thanks! It seems to work now.
20:24:45 <geekosaur> wouldn't they have gotten a link failure from gcc?
20:24:56 <shachaf> geekosaur: That's what I'd think, but who knows.
20:25:14 <shachaf> At any rate that command line shouldn't work for that.
20:25:16 <TravisD> m3ga: What kind of work do you do? If you don't mind me asking
20:25:20 <Rogach> shachaf: I seem to have this line in Makefile: "gcc -std=gnu99 -c -o sieve.o sieve.h"
20:25:26 <shachaf> OK.
20:25:30 <geekosaur> um
20:25:43 <shachaf> And what's your actual ghc line, while we're at it? :-)
20:25:45 <geekosaur> sieve.*h*??
20:26:03 <shachaf> Er.
20:26:04 <m3ga> TravisD: haskell webdev with yesod
20:26:06 <shachaf> What geekosaur said.
20:26:07 <Rogach> shachaf: "ghc -optc -std=gnu99 --make -o primes primes.hs sieve_ffi.hs sieve.c
20:26:17 <shachaf> I meant the old ghc line.
20:26:31 <Rogach> shachaf: Yes, it was.
20:26:32 <shachaf> But anyway compiling sieve.h is broken.
20:26:40 <m3ga> TravisD: all internal web apps for large US company.
20:26:56 <Rogach> shachaf: Yes, now I realize this.
20:27:31 <Rogach> geekosaur: It's actually almost my first time using C and binding haskell to C, so I'm doing lots of stupid things.
20:27:59 <TravisD> m3ga: cool, thanks
20:31:11 <lightquake> i have a, b, and c which are various Maybe values. i want to apply some function f to the 'inner' values if they're all Just, or just evaluate to some value 'failure' if any are Nothing. what's the idiomatic way to do that?
20:31:29 <geekosaur> :t maybe
20:31:30 <lambdabot> b -> (a -> b) -> Maybe a -> b
20:31:32 <sw2wolf> m3ga: Can yesod burden a heavy traffic web site (c10k) ?
20:31:41 <shachaf> fromMaybe default (liftA3 f a b c)
20:31:59 <shachaf> I like how "default" is a great placeholder since it's a syntax error.
20:32:02 <lightquake> shachaf: oh, neat
20:32:12 <lightquake> didn't think about using liftA3
20:32:26 <shachaf> f <$> a <*> b <*> c also works
20:32:32 <kvda> are type aliases frowned up? I think i heard they make compiler errors hard to decipher?
20:32:42 <shachaf> Or { x <- a; y <- b; z <- c; return (f x y z) }
20:33:29 <Hail_Spacecake> is there a way to get the name of a function as a string?
20:33:31 <geekosaur> oh sorry, misread the request
20:33:32 <m3ga> sw2wolf: nothing i am going to be doing is anywhere near c10k (these are internal web apps), but haskell/yesod is *way* faster than python or ruby alternatives.
20:33:34 <geekosaur> Hail_Spacecake, no
20:34:29 <sw2wolf> m3ga: thx
20:57:04 <Mortchek> kvda, think of type aliases as shorthand that the compiler expands out for you. If you use lots of said shorthand to express something complex, the thing you're talking about is still complex.
20:57:59 <Rogach> How do I call C function, that returns an array of longs, from haskell ffi?
20:59:02 <lightquake> oh huh, f"x" apparently lexes as f "x"
20:59:31 <genisage> has anybody here used happy?
20:59:36 <kvda> thanks Mortchek, i get that. Just wanted to check if there were any issues with their use.
21:01:35 <Mortchek> kvda, I'd say they are okay when used appropriately and in moderation. Just make sure you know what your aliases stand for.
21:01:51 <kvda> Got it, thank you.
21:09:16 <m3ga> genisage: yes, i've used happy and parsec. prefer parsec :-)
21:10:12 <lispy> genisage: yeah
21:10:37 <lispy> genisage: the documentation has a few rough spots, but the tool itself is pretty good
21:19:37 * hackagebot hfsevents 0.1.4 - File/folder watching for OS X  http://hackage.haskell.org/package/hfsevents-0.1.4 (LuiteStegeman)
21:24:59 <copumpkin> luite: omg I see you have withCStrings there
21:25:09 <copumpkin> have you seen Cale's beautiful treatment of that function?
21:25:19 <luite> no
21:25:44 <Cale> You can use the Cont monad to nest a bunch of them and get a list. :)
21:26:00 <Cale> (I assume that's what copumpkin is referring to :)
21:26:03 <copumpkin> yup
21:26:09 <copumpkin> http://www.haskell.org/pipermail/haskell-cafe/2008-February/038963.html
21:26:11 <luite> hehe interesting
21:26:27 <copumpkin> Cale uses sequence . map
21:26:31 <copumpkin> instead of mapM
21:26:33 <copumpkin> haha noob
21:27:26 <copumpkin> luite: anyway, I think the end result is the exact same type signature as yours
21:27:52 <Cale> There is a bit of a reason to keep that separate
21:28:18 <Cale> It's like a worker/wrapper transformation.
21:28:39 <copumpkin> oh
21:28:44 <copumpkin> copumpkin: haha noob
21:28:48 <luite> i don't need a list but a double ptr?
21:29:01 <copumpkin> what he ended up doing was withCStringArray0 :: [String] -> (Ptr CString -> IO a) -> IO a
21:29:05 <Cale> Well, it's a good point that you can just mapM there
21:29:17 <Cale> But that's not how I was thinking of the trick at the time
21:30:41 <luite> copumpkin: right i'm stupid :p (didn't see that i had Ptr CChar)
21:42:17 <luite> copumpkin: ok i hope you're happy now ;p
21:42:30 <luite> (pushed to github)
21:44:23 <luite> tnx for the suggestion btw
21:45:29 <copumpkin> luite: yay :)
21:45:29 <copumpkin> thanks
21:57:06 <Sgeo> Is it really that bad to, when decoding JSON, just decode it into a Map, and use that?
22:00:13 <arkeet> why would that be bad?
22:07:24 <dmwit> ?src drop
22:07:24 <lambdabot> drop n xs     | n <= 0 =  xs
22:07:24 <lambdabot> drop _ []              =  []
22:07:25 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
22:08:25 <Cale> Sgeo: There's no problem with that, though most JSON parsers (which you should probably use) will tend to do a little more for you than that.
22:08:46 <Cale> (i.e. they will destructure the entire thing recursively)
22:08:48 <dmwit> Sgeo: No problem until your JSON has nesting. =)
22:09:18 * Sgeo was thinking in terms of using Aeson
22:22:49 <jaeyeun> Is there any books or videos you guys suggest for starting Haskell?
22:22:59 <arkeet> @where lyah
22:22:59 <lambdabot> http://www.learnyouahaskell.com/
22:24:44 <kvda> jaeyeun, is it your first functional language?
22:24:51 <jaeyeun> kvda: yup
22:24:57 <jaeyeun> lambdabot: thanks!
22:25:35 <arkeet> lambdabot is a bot. :)
22:26:18 <jaeyeun> arkeet: huh... I'm not use to IRCs. Now it seems apparent why its name ends in b-o-t :_
22:26:20 <jaeyeun> :)
22:26:43 <kvda> you might want to add books like The Little Schemer, How to Design Programs, and SICP
22:28:16 <arkeet> @where rwh -- is another good one to look at
22:28:16 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
22:28:52 <arkeet> I guess there'es this school of haskell thing these days too. https://www.fpcomplete.com/school
22:29:03 <jaeyeun> kvda: thanks. but is SICP related to FP?
22:29:17 <kvda> certainly
22:30:44 <jaeyeun> kvda: I should look a bit more in to it. Thanks!
22:30:55 <arkeet> SICP uses scheme, which is indeed another functional programming language
22:31:05 <arkeet> although it's quite different from haskell
22:31:32 <arkeet> it uses eager evaluation, and it doesn't have much of a type system to speak of
22:31:36 <arkeet> and types are where all the fun is ;)
22:31:51 <jaeyeun> arkeet: I heard about scheme before
22:32:35 <jaeyeun> it looks like a great langauge but I never had the time to learn it..
22:32:58 <jaeyeun> So to sum it up..
22:33:39 <jaeyeun> lyah, rwh, sicp, little schemer, how to design programs ,and SoH
22:33:51 <jaeyeun> thanks a lot guys!
22:34:24 <dmwit> ?where tutorials
22:34:24 <lambdabot> http://haskell.org/haskellwiki/Tutorials
22:34:48 <dmwit> Seems I'm always too late with that to prevent people from typing the same suggestions over and over, though.
22:34:52 <arkeet> haha
22:36:00 <Jonno_FTW> is map f $ map g xs  the same as map (f.g) xs?
22:36:28 <dmwit> Yes.
22:36:38 <dmwit> This is one of the Functor laws for [], and is also a free theorem:
22:36:41 <Ralith> the latter is better style, though
22:36:47 <dmwit> ?free map :: (a -> b) -> [a] -> [b]
22:36:47 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
22:36:47 <fumieval> And GHC automatically transform them
22:37:25 <dmwit> erm
22:37:38 <dmwit> I've never been good at free theorems. Probably I am wrong about that bit.
22:37:40 <jaeyeun> dmwit: thanks
22:37:45 <arkeet> it's a free theorem for Functor given fmap id = id, but for map
22:38:10 <arkeet> er, that shouldn't matter.
22:38:26 <arkeet> ? free fmap :: (a -> b) -> f a -> f b
22:38:30 <arkeet> ?free fmap :: (a -> b) -> f a -> f b
22:38:30 <lambdabot> Extra stuff at end of line
22:38:33 <arkeet> heh.
22:38:43 <arkeet> oh well, you can still take k = id there
22:39:06 <dmwit> oh, yeah, perfect
22:39:48 <sw2wolf> :t maybe
22:39:49 <lambdabot> b -> (a -> b) -> Maybe a -> b
22:41:07 <sw2wolf> @pl fn  b -> (a -> b) -> Maybe a -> b
22:41:07 <lambdabot> (line 1, column 9):
22:41:07 <lambdabot> unexpected '>'
22:41:07 <lambdabot> expecting operator
22:42:21 <Jonno_FTW> okay thanks
22:42:27 <koninkje> That fmap f . fmap g == fmap (f . g) is a law required for things to be a functor
22:42:47 <arkeet> yes, but it follows for free from fmap id = id
22:43:12 <sw2wolf> :t fmap id
22:43:13 <lambdabot> Functor f => f b -> f b
22:43:17 <koninkje> That fmap if == id is the other law required for things to be a functor
22:44:00 <koninkje> Neither is free, in that neither follows directly from the type of fmap; but they'd both better be true for any instance of Functor
22:44:18 <koninkje> er, s/if/id/
22:44:41 <arkeet> koninkje: that's the thing.
22:44:42 <arkeet> it is free.
22:44:56 <koninkje> How is fmap id == id free?
22:44:58 <arkeet> because of parametricity.
22:45:01 <arkeet> no, fmap id = id isn't free.
22:45:18 <arkeet> but g . h = k . f => fmap g . fmap h = fmap k . fmap f is free.
22:45:31 <koninkje> yes, that one's free
22:45:34 <arkeet> now take k = id
22:45:39 <arkeet> and assume fmap id = id
22:46:18 <koninkje> But the composition law is not free; it requires you to make that assumption that fmap id == id
22:47:10 <arkeet> that's why I said it follows for free from fmap id = id
22:47:24 <koninkje> That fmap f . fmap g == fmap (f.g) follows from fmap id == id does indeed follow by parametricity, but that doesn't make it free
22:48:18 <arkeet> I don't know what we're disagreeing about
22:49:13 <koninkje> What makes something free
22:49:41 * shachaf smells an argument about words.
22:49:48 <koninkje> For example, the ability to rely on parametricity to prove the composition law also relies on the assumption that your type constructor is indeed parametric
22:50:20 <koninkje> If you try to define a Functor instance for a type family, then you don't get composition without proving it
22:50:32 <koninkje> just sayin'
22:51:01 <koninkje> people throw around "free theorems" alot without, IMO, really understanding what it is that the theorems are
22:51:39 <koninkje> the theorems are a lot more finicky than we'd like
22:51:58 <koninkje> e.g., http://www.iai.uni-bonn.de/~jv/paper.pdf
22:55:29 <Jonno_FTW> @src count
22:55:29 <lambdabot> Source not found.
22:55:33 <Jonno_FTW> wot
22:57:35 <arkeet> @where src
22:57:35 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
22:58:11 <Jonno_FTW> is there a countby?
22:58:28 <koninkje> @hoogle countby
22:58:29 <lambdabot> No results found
22:58:36 <koninkje> @hoogle countBy
22:58:36 <lambdabot> No results found
22:58:45 <Jonno_FTW> :(
22:59:00 <Jonno_FTW> guess I'll write it myself
22:59:17 <arkeet> Jonno_FTW: what's it supposed to do?
22:59:21 <arkeet> what might its type be?
22:59:41 <Jonno_FTW> I want a function to count the number of times a list is a subset of a list of lists
23:00:19 <Jonno_FTW> countSubsets :: [a] -> [[a]] -> [(a,Int)]
23:00:28 <koninkje> sub-"set"?
23:00:55 <Jonno_FTW> yes
23:01:06 <Jonno_FTW> I know the lists won't have repeating elements
23:01:12 <koninkje> ah
23:01:40 <koninkje> so, morally, you want countSubsets :: Set a -> ?? -> IntMap a
23:01:41 <koninkje> ?
23:02:03 <Jonno_FTW> yes
23:02:11 <Jonno_FTW> but I'm not using sets
23:02:33 <koninkje> what's "??". Is it Set (Set a) ...morally speaking?
23:02:43 <arkeet> why the pair (a,Int)? can you give some example input and output you want?
23:03:19 <koninkje> ...or [Set a], or...?
23:03:51 <Jonno_FTW> a list of a?
23:05:24 <Jonno_FTW> wait it should return (a, Int)
23:05:34 <Jonno_FTW> not a list of that
23:05:53 <arkeet> can you give some example input and output?
23:05:57 <arkeet> I still don't know what the a is supposed to be.
23:06:12 <Jonno_FTW> I'm writing apriori
23:06:28 <Jonno_FTW> maybe it would just return int
23:06:57 <Jonno_FTW> countSubsets [1,2] [[1,2],[1,2,3],[4,5,6]] ==> 2
23:06:59 <arkeet> maybe iy would
23:07:39 <arkeet> ok, well suppose you had a function isSublistOf :: [a] -> [a] -> Bool
23:07:46 <Jonno_FTW> I've done that
23:07:48 <arkeet> then you could
23:08:06 <arkeet> :t \a as -> length (filter (a `isSublistOf`) as)
23:08:08 <lambdabot>     Not in scope: `isSublistOf'
23:08:08 <lambdabot>     Perhaps you meant one of these:
23:08:08 <lambdabot>       `IS.isSubsetOf' (imported from Data.IntSet),
23:08:13 <arkeet> :t \a as -> length (filter (?isSublistOf a) as)
23:08:14 <lambdabot> (?isSublistOf::t -> a -> Bool) => t -> [a] -> Int
23:12:02 <Jonno_FTW> O
23:12:07 <Jonno_FTW> I'm writing apriori btw
23:12:35 <arkeet> huh?
23:12:49 <Jonno_FTW> it's a data mining algorithm
23:17:05 <Jonno_FTW> @free
23:17:05 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:21-35
23:17:13 <Jonno_FTW> @help
23:17:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:17:19 <Jonno_FTW> @list
23:17:19 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
23:17:24 <mauke> @free length
23:17:27 <lambdabot> length = length . $map f
23:17:58 <mauke> @free (:)
23:17:58 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:21-35
23:18:05 <mauke> @free cons :: a -> [a] -> [a]
23:18:05 <lambdabot> $map f . cons x = cons (f x) . $map f
23:54:47 * hackagebot shake 0.10.1 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.10.1 (NeilMitchell)
