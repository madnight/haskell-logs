00:00:10 <applicative> all the mad optimization
00:00:41 <adnap> What I don't get is...
00:01:15 <adnap> If List implements Foldalbe, then calling foldl' on a list should perform an efficient fold for lists.
00:01:50 <adnap> There are two foldl' for List and it doesn't make any sense!
00:02:21 <shachaf> foldable was i ere i saw elba dlof
00:02:50 <adnap> not a palindrome!
00:03:06 <edwardk> maybe Napoleon was addressing someone named Dlof.
00:03:34 <applicative> is the implementation different?
00:04:16 <shachaf> instance Foldable [] where foldl' = Data.List.foldl'
00:04:28 <adnap> I don't know! If you import Data.Foldable, import Data.List hiding (foldl'), and call foldl' on a list, do you get a general foldl' provided by Foldable or a List-specific implementation?
00:04:50 <shachaf> Let's say that it's because of historical reasons.
00:05:03 <adnap> So...
00:05:04 <adnap> 01:53 < applicative> adnap, fwiw if foldr generally were the one from Data.Foldable it might impede  optimizations specific to list foldr
00:05:09 <adnap> This was misleading
00:05:13 <shachaf> Surely if you were designing the standard library from scratch today, there are all sorts of things you'd do differently.
00:05:34 <shachaf> I don't know if foldl' being Foldable-polymorphic is one of them. Maybe it is.
00:05:43 <edwardk> Yes, like not make me duplicated a third of my code because someone can't be bothered to write 3 lines for an Applicative superclass.
00:05:47 <edwardk> er duplicate
00:06:11 <adnap> I don't like having to type L.filter, M.filter, etc.
00:06:42 <applicative> the reasons are obviously historical adnap, I was just wondering about foldr in particular.
00:06:45 <edwardk> adnap: used 'filtered', problem solved.
00:07:05 <shachaf> edwardk: class Applicative m => Monad m? Ridiculous!
00:07:07 <edwardk> > [1..10]^..folded.filtered even
00:07:08 <adnap> edwardk: Where is that?
00:07:08 <arkeet> use lens, problem solved.
00:07:10 <lambdabot>   [2,4,6,8,10]
00:07:12 <adnap> @hoogle filtered
00:07:12 <lambdabot> Codec.Compression.Zlib.Internal Filtered :: CompressionStrategy
00:07:12 <lambdabot> Codec.Compression.Zlib.Raw Filtered :: CompressionStrategy
00:07:12 <lambdabot> Codec.Compression.Zlib Filtered :: CompressionStrategy
00:07:20 <shachaf> edwardk: filtered doesn't generalize Data.Map.filter...
00:07:33 <shachaf> I don't know any good generaliszation of that, in fact.
00:07:34 <edwardk> :t ifiltered
00:07:36 <lambdabot> (Applicative f, Indexable i p) => (i -> a -> Bool) -> Overloading' p (Indexed i) f a a
00:07:45 <edwardk> :t M.filter
00:07:47 <lambdabot> Ord k => (a -> Bool) -> M.Map k a -> M.Map k a
00:08:02 <edwardk> ah for Map to Map
00:08:29 <shachaf> lens forces a very Monoidy view of the world onto you.
00:08:34 <edwardk> true
00:08:45 <shachaf> Now, I love monoids -- they are so easy, after all -- but it's not always what you want.
00:09:12 <edwardk> yep. uhoh. lens development has slowed down to the point where shachaf has started to lose faith ;)
00:09:17 <adnap> class Filterable m; filter :: (a -> Bool) -> m a -> m a
00:09:27 <shachaf> No. :-(
00:09:28 <arkeet> it should suffice to have f (Maybe a) -> f a
00:09:49 <adnap> Why doesn't this exist?
00:09:50 <arkeet> and then you can write filter in terms of that
00:09:57 <edwardk> arkeet: i generally dislike building containers full of values i don't need just to collapse them
00:10:03 <arkeet> but.
00:10:13 <shachaf> edwardk: Well, you can make a (>>=)/traverse-style function as an optimization.
00:10:18 <edwardk> sufficient is not efficient
00:10:19 <arkeet> sure.
00:10:22 <shachaf> (a -> Maybe b) -> f a -> f b
00:10:25 * arkeet is not efficient.
00:10:44 <shachaf> I assume arkeet just meant what the behavior of the class would be like. But I'm not sure that I see. :-)
00:10:45 <edwardk> I use that as 'filterMap' in a lot of scala code
00:11:09 <arkeet> in any case, I don't like Bool
00:11:11 <edwardk> adnap: i've written that in a few code-bases, i tend towards the filterMap variant though
00:11:21 <shachaf> edwardk will try to get you addicted to monoids. The first one is always free.
00:11:43 <edwardk> @remember shachaf edwardk will try to get you addicted to monoids. The first one is always free.
00:11:43 <arkeet> and shachaf will try to get you addicted to horrible puns.
00:11:43 <lambdabot> Good to know.
00:11:53 <edwardk> At least they are funpuns
00:11:58 <FireFly> Those are always free though
00:12:17 <arkeet> ok sure, you can plug id into filterMap.
00:12:27 <arkeet> to get catMaybes
00:13:27 <arkeet> @let filterMap f = foldr (\x xs -> maybe id (:) x xs) []
00:13:31 <lambdabot>  Defined.
00:13:31 <arkeet> :t filterMap
00:13:33 <lambdabot> t -> [Maybe a] -> [a]
00:13:36 <arkeet> doh.
00:13:37 * applicative confesses that he  loves building containers full of values he doesnt need just to collapse them
00:13:40 <arkeet> @undefine
00:13:45 <shachaf> @ty catMaybes .: map
00:13:47 <lambdabot> (a1 -> Maybe a) -> [a1] -> [a]
00:13:47 <shachaf> hth
00:13:54 <arkeet> I know.
00:13:55 <arkeet> but
00:14:12 <shachaf> Is filterMap really better than filter, though?
00:14:18 <shachaf> You have this Maybe instead of a Bool.
00:14:19 <applicative> simonpj calls 'free' 'tree'
00:14:21 <arkeet> :t \f -> foldr (\a b -> maybe id (:) (f a) b)
00:14:22 <lambdabot> (a -> Maybe a1) -> [a1] -> [a] -> [a1]
00:14:25 <arkeet> :(
00:14:29 <arkeet> :t \f -> foldr (\a b -> maybe id (:) (f a) b) []
00:14:30 <lambdabot> (a -> Maybe a1) -> [a] -> [a1]
00:14:38 <arkeet> @let filterMap f = foldr (\a b -> maybe id (:) (f a) b) []
00:14:41 <lambdabot>  Defined.
00:14:41 <arkeet> :t filterMap id
00:14:43 <lambdabot> [Maybe a1] -> [a1]
00:14:58 <shachaf> @ty (>>= id)
00:15:00 <lambdabot> Monad m => m (m b) -> m b
00:15:03 <shachaf> @ty traverse id
00:15:05 <lambdabot> (Applicative f, Traversable t) => t (f b) -> f (t b)
00:15:13 <shachaf> @ty collect id
00:15:15 <lambdabot> Not in scope: `collect'
00:15:20 <shachaf> @ty Data.Distributive.collect id
00:15:21 <lambdabot> (Functor f, Data.Distributive.Distributive g) => f (g b) -> g (f b)
00:15:35 <arkeet> what does that do?
00:15:43 <shachaf> Which?
00:15:47 <arkeet> Data.Distributive
00:15:56 <arkeet> oh I see.
00:16:04 <shachaf> It's a generaliszation of (??)
00:16:37 <edwardk> Or even just 'flip'
00:16:44 <shachaf> Sure.
00:16:55 <shachaf> Did you end up deciding to keep (??) as it is?
00:16:59 <edwardk> yeah
00:17:09 <edwardk> i don't like generalizing infix operators to having fewer than 2 args
00:17:23 <edwardk> kinda pointlessly pointless
00:17:27 <shachaf> But "distribute" already exists!
00:17:35 <shachaf> This way there's one new type that exists in the universe.
00:17:56 <edwardk> :t Data.Distributive.distribute
00:17:57 <lambdabot> (Functor f, Data.Distributive.Distributive g) => f (g a) -> g (f a)
00:18:15 <arkeet> :t (??)
00:18:16 <lambdabot> Functor f => f (a -> b) -> a -> f b
00:18:21 <arkeet> right
00:18:53 <edwardk> A distributive functor is baically a function in disguise
00:18:53 <DarkFox> Anyone here have any basic tls examples
00:19:27 <shachaf> So is a representable functor!
00:19:47 <DarkFox> Does tls use Network.Socket.ByteString?
00:20:21 <arkeet> shachaf: you mean corepresentable.
00:20:30 <arkeet> :p
00:20:47 <edwardk> yep
00:20:50 <shachaf> arkeet: edwardk swapped it
00:20:56 <edwardk> the main difference is that distributive is haskell 98
00:21:17 <shachaf> Shouldn't it be Distributive g => Representable g, or something, then?
00:21:41 <edwardk> well, to be fair, representable can be used for either form when it is unambiguous.
00:21:49 <edwardk> shanse: it does
00:21:59 <edwardk> wel, Representable has it as a superclass
00:22:56 <edwardk> oh it doesn't any more
00:22:57 <edwardk> http://hackage.haskell.org/packages/archive/representable-functors/3.0.1/doc/html/Data-Functor-Representable.html
00:23:36 <edwardk> i ripped almost all the superclasses off of Representable after people complained. Perhaps I went one too far.
00:25:21 <DarkFox> No one have a basic tls example?
00:31:17 <applicative> DarkFox: maybe these https://github.com/vincenthz/hs-tls/tree/master/debug/src but they use his library
00:31:45 <DarkFox> applicative: No simple server :P
00:32:00 <DarkFox> And that client sure isn't the most simple.
00:32:58 <DarkFox> BALH
00:33:19 <DarkFox> socketToHandle... where have you been all my network.socket.bytestring fun time!! :|
00:33:22 <DarkFox> :D
00:34:03 <arkeet> hm, if every distributive is representable, then a distributive g should be isomorphic to ((forall r. g r -> r) ->)
00:34:22 <arkeet> but I'm not seeing how to ((forall r. g r -> r) -> a) -> g a
00:38:55 <DarkFox> applicative: Do you understand how to use tls?
00:39:31 <lpsmith> Haddock is eating my documentation >:o
00:39:45 <lpsmith> I've run across quite a few haddock bugs lately it seems
00:40:02 <DarkFox> lpsmith: Link to source
00:40:38 <lpsmith> DarkFox, http://hackage.haskell.org/packages/archive/postgresql-simple/0.3.0.0/doc/html/src/Database-PostgreSQL-Simple-FromField.html
00:40:51 <lpsmith> http://hackage.haskell.org/packages/archive/postgresql-simple/0.3.0.0/doc/html/Database-PostgreSQL-Simple-FromField.html
00:41:07 * hackagebot VKHS 0.3.1 - Provides access to Vkontakte social network via public API  http://hackage.haskell.org/package/VKHS-0.3.1 (SergeyMironov)
00:41:46 <DarkFox> ------------------------------------------------------------------------------
00:41:51 <DarkFox> What that doing there?
00:41:57 <lpsmith> Nothing
00:41:58 <lpsmith> decoration
00:42:09 <lpsmith> That's not causing the problems though
00:42:13 <DarkFox> Does it work without it?
00:42:17 <lpsmith> no
00:43:04 * DarkFox wonders why you have 4 different language declarations.. Why not one, you can have commas and new lines you know? (You have commas already)
00:43:09 <DarkFox> New lines work too :)
00:43:48 <lpsmith> DarkFox, it doesn't matter
00:44:11 <lpsmith> It's completely irrelevant to the issue at hand
00:44:22 <DarkFox> lpsmith: http://hackage.haskell.org/packages/archive/postgresql-simple/0.3.0.0/doc/html/Database-PostgreSQL-Simple.html
00:44:25 <DarkFox> It's working
00:44:54 <DarkFox> Diff page nvm
00:44:54 <lpsmith> No,  it's missing a bunch of documentation at the start of the module
00:44:56 <lpsmith> different
00:45:32 <lpsmith> No, the problem appears to be something less-than-trivial inside the example code block
00:45:38 <lpsmith> I take that out it works
00:45:52 <lpsmith> but it's not as simple as a single line at least in the code block
00:45:53 <DarkFox> Idk
00:46:35 <arkeet> lpsmith: remove the block, and add one line at a time?
00:46:52 <applicative> lpsmith: try this method at the top
00:46:54 <lpsmith> arkeet, I've tried removing one line at a time until it works
00:46:59 <applicative> http://hackage.haskell.org/packages/archive/sink/0.1.0.1/doc/html/src/Data-Sink.html e.g.
00:47:07 <DarkFox> Can anyone here link me to a minimal example for a tls client & server using pre-defined keys. All clients must be auth'd with the server through their unique keys
00:47:28 <arkeet> DarkFox: you assume one exists.
00:47:36 <lpsmith> but then I went back and removed just the line I removed when everything started to work, and it didn't work again.
00:47:43 <DarkFox> arkeet: Indeed.
00:47:48 * DarkFox can't find any. 
00:47:55 <shachaf> arkeet: DarkFox would be perfectly happy for you to write one right now and then give them a link.
00:48:04 <arkeet> I would be less than perfectly happy to do so.
00:48:13 <applicative> lpsmith: but haddock block comments dont work?
00:48:22 <DarkFox> arkeet: Someone in here would know how to do it.
00:48:23 <DarkFox> shachaf: Yea
00:48:29 <shachaf> ...DarkFox = ZFox = M30W = archeyDevil = ...?
00:48:32 <shachaf> Come on.
00:48:36 <shachaf> Why do you keep changing your nick?
00:48:39 <arkeet> lpsmith: so remove later lines too
00:48:43 <DarkFox> shachaf: Last time I swear.
00:48:45 <DarkFox> Sorryu
00:48:53 <arkeet> lpsmith: start removing lines from the opposite end.
00:49:16 <arkeet> shachaf: he's also been asking for tls examples for a while.
00:49:32 <DarkFox> arkeet: Yea.
00:49:39 <arkeet> you could have made one yourself by now.
00:49:51 <lpsmith> applicative, that didn't work either
00:49:52 <DarkFox> arkeet: I've benn looking, I've tried, didn't end up getting anywhere.
00:50:01 <shachaf> Perhaps it is impossible.
00:50:07 <applicative> hm
00:50:13 <DarkFox> For my knowledge atm for me yea
00:50:15 <DarkFox> :P
00:50:36 <DarkFox> s/for me//
00:50:49 <applicative> DarkFox: file a big report on the github site
00:50:57 <applicative> bug rather
00:50:59 <shachaf> a huge report
00:51:08 * hackagebot representable-functors 3.1 - Representable functors  http://hackage.haskell.org/package/representable-functors-3.1 (EdwardKmett)
00:51:16 <DarkFox> applicative: What? asking for a basic server and client?
00:51:29 <DarkFox> Or more documentation examples for the haddock?
00:51:33 <DarkFox> (or both even)
00:51:53 <applicative> well, implicitly communicting that you cant figure out his library...
00:52:16 <applicative> which doesnt have much documentation
00:52:17 * DarkFox wishes he were just on IRC
00:53:10 <DarkFox> Meh
01:00:35 <lpsmith> ok, the problem seems to have been the double quotes
01:01:15 <DarkFox> lpsmith: Report?
01:06:05 <lpsmith> perhaps
01:06:09 * hackagebot adjunctions 3.2 - Adjunctions  http://hackage.haskell.org/package/adjunctions-3.2 (EdwardKmett)
01:06:11 * hackagebot postgresql-simple 0.3.0.1 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.3.0.1 (LeonSmith)
01:11:47 <edwardk> arkeet, shachaf: ok. i've finally exorcised that 'Corepresentable' demon from my codebase. Now they are just both 'Representable' which is at least a defensible position. ;)
01:11:56 <arkeet> haha
01:12:26 <edwardk> and the knock-on effects of doing it were fairly minimal
01:13:23 <shachaf> So it's Data.Functor.Contravariant.Representable, since it's a contravariant functor?
01:13:46 <shachaf> Just like Data.Functor.Yoneda.Contravariant, which is for, uh...
01:14:12 <edwardk> shachaf: =P
01:14:30 <shachaf> I don't really get what's contravariant about that one.
01:14:36 <edwardk> me neither
01:14:36 <shachaf> Maybe it should be called Roneda and Loneda?
01:15:02 <edwardk> heh
01:34:06 <QinGW`> Any references about instant messaging tool development?
01:46:10 * hackagebot generic-deriving 1.5.0 - Generic programming library for generalised deriving.  http://hackage.haskell.org/package/generic-deriving-1.5.0 (JosePedroMagalhaes)
01:47:40 <edwardk> yay!
01:47:45 * edwardk closes the lens issue.
01:51:30 <bind> was there an issue with lenses?
01:51:53 <edwardk> lens on 7.7 relied on generic-deriving changes that weren't released yet
01:51:56 * bind gratulates by the way
01:52:11 <edwardk> this enables us to build cleanly on ghc HEAD
01:52:32 <edwardk> we'd had an open issue for the last couple months
01:52:39 <bind> thats good news :-)
04:06:48 --- topic: '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.2 http://v.gd/oXnqjU ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","If Hackage is down, try: http://hdiff.luite.com "]'
04:06:48 --- topic: set by monochrom on [Tue Jan 29 09:36:42 2013]
04:06:48 --- names: list (clog hiro3w dmarker k00mi ninzine Tordek Reite sopvop carlocci ketil EarlGray^ identity Palmik t7 mimi_vx steful acfoltzer LAMMJohnson Philonous ozgura ilyanok tavelram vramana twomashi brisbin paddymahoney ptek asQuirreL spion bitonic PatrickRobotham owst arpunk` SoupE davorb_laptop heruur ulfdoz piotr_ tomboy64 Jeanne-Kamikaze MrGwen wyfrn [mth] solarus xcombelle duosrx schovi_ hallski tahu bezik yacks techlife `fogus jacobw k0ral joneshf schlicht profmakx)
04:06:48 --- names: list (sonda dEPY ctype_real thorkilnaur_ osnr dsantiag_ TheFuzzball ft jang Flint Botje_ joar_ pfoetche1 `bps_ XMunkki_ suiside_ Chousuke_ arkx_ KitB JoshuaA__ Guest84888 mullein emma_ m3ga PartyKat1e shepheb_ xaimus bens andrewsw mcguitan93 arenz Jonte_ magicman_ voyd Gilly_ xnyhps_ bxc_ ejls_ hpc_ iulian threeday1onk `0660 sgronblo_ bcoppens_ Axman6 Varakh milessabin DustyDin1o bholst wump qwandor|quassel Natch mattp__ xpika dixie_ skyflash_ dschoepe julmae)
04:06:48 --- names: list (quchen DT` silver edsko itemad edon MrFenix cduez Xaratas hkBst edtsech niloc132 Alice3 Itkovian Sonderblade hiyakashi Targen AfC aninhumer weie_ akamaus macbr raichoo charliesome perspectival danvet HaltingState mceier kaoskorobase Zzompp Pantoufle agundry freiksenet kennyd ThomasLocke_ hamishmack __dv__ JaRoel|4d dogmaT LucasCampos cmears shintah ARCADIVS zhulikas RayNbow`TU hamid bind edwardk Argue takumn cyphase hiratara ritek kushal MnO2 guymann pikhq_)
04:06:48 --- names: list (imeredith gspr path[l] mikecaruso d-snp notdan kerrick preflex mauke ijp stepcut c_wraith BMeph_ Mortchek apaku dreixel s00pcan theorbtwo [[zz]] Will| tamiko yc4891 kmrhb joneshf-laptop ortmage b52 joeyh hive-mind dysinger memand gseitz kamatsu sclv ozataman_ bos Swizec Kaidelong mgsloan predator217 vili xinming_ descender tensorpudding ernst dawe ktosiek creichert Rarrikins Ralith colah azaq23 Khisanth maurer saep dolio crdueck jaeyeun nilg` nilg)
04:06:48 --- names: list (AntiSpamMeta latro`a cmccann u_quark1 cads tvaalen kith DrChaos __main__ hiroaki mortberg Fuuzetsu threesome nighty^ Eelis cl_away \rs perlite ben_d lcfrs Nahra bradleyayers nus- augur mmaruseacph2 nwf ndngvr` aristid thetallguy merijn Megant tuv gwern boegel tgeeky sellout- dottedmag ousado MoALTz idntfy2 OlegYch Dodek nule jtalk ofan simon___ steez FireFly tridactyla neena pqmodn eacameron1 mefisto Eiam dgvncsz0f thirsteh bytbox Enigmagic dju Tesseraction)
04:06:48 --- names: list (ccasin McManiaC ghorn levi mietek junsuijin ciaranm rmarianski glguy sbahra julmuri Luke drbean sShintah gbeshers gthorslund trh178 melter chirpsalot Zariel thorsten` S11001001 Hermit verrens whaletechno ks07 Nshag doomlord DarkFox amatsu Th0mas ajhager robbert` isomorphic leoncamel MK_FG lopex chessguy tomejaguar machisuji UziMonkey__ lazard Vert imphasing labo BigEndian yam a11235 davean ski Derander Maxdamantus ab9rf ahihi lattenwald rfw adnap ]OLI[ Cerise)
04:06:48 --- names: list (Amadiro MOMI jlamothe SegFaultAX _anona joe9 DarkLinkXXXX Brando753 tdammers Razz ique sohum yriw_ dilinger_ pettter Rembane kaol jaspervdj otto_s kalven jml neurocyte xcvii anders^^ ninegrid jliikka_ Vq jlaire srcerer obcode_ William_ folone Jonno_FTW _flow_ wilfredh_ zxq9 etabot VZakharov SuperNoeMan shutdown_-h_now lahwran zoktar sunnavy yeltzooo6 byorgey numeral tessier_ _yezariaely wormphlegm deavid Adeon wei2912 Bigcheese Cale bbloom jrslepak matzo_)
04:06:48 --- names: list (mlinksva Walther elliottc1ble Tehnix_ opqdonut Kinnison certaint1 kini dqd lokydor_ vhz_ klugez kryft qwr Zouppen petanqk inr_ ptrf Belgarion0 rio oitnelis IanKelling myme warpy___ tanakh ClaudiusMaximus sirchurchill tim1 FalkoPeters abumirqaan mtlatif ormaaj tomh_ Xorlev helgikrs Philippa mike2 arkeet jonke u__ parcs necropumpkin tippenein mrd x7 sm chrisirc_ JoeHazzers Martty jaimef lpvb eviltwin_ dlundy h_chiro gdeest epta Valodim Tarential hanDerPeder)
04:06:48 --- names: list (kosmikus lpsmith ibid strax_ orzo xrq otterdam rainmaker black_joe xrl__ Sgeo akahn trevize_ sipa alios netj canvon s_quark reiddraper saiam Ghoul__ koninkje_away staafl_alt fotc natte jtobin tsou drewr Dashkal xymox dumbhat Saizan ziman ps-auxw JPohlmann endojelly marienz hyko fabjan canta The_third_man niko Excureo hungryblank xorox90 KaneTW sh liesen arun mollerstrand yumike DrSyzygy thetallguy1 flux b_jonas Kuba_ heath SLi ysulsky Internet13 Gunni alcz)
04:06:48 --- names: list (hpd jamwt hackagebot lambdabot alejandrogomez NougatRillettes Draconx simpson linduxed munro mjr841 Canar mikeplus64 petantik _br_ hiroyuki2 Heffalump rsimoes dkasak fireglow wunki kylcarte Athas ChongLi tom4939_ ahf aforemny mornfall sunfun kmicu jlewis ivan` def-lkb Vorpal chr1s fergusnoble noj Gothmog_ zwiebel majoh ocharles setmeaway2 lulf integral_ edenc_ pharaun DigitalK1wi alshain noplamodo flori jix joachifm jercos mrshoe Igloo Bwild saurik Eliel)
04:06:48 --- names: list (`micro Plex- brandonw alang gcmalloc raek rs0 smarter tomku pepijndevos int-e Estrellas robbe- mlh pcapriotti meyersh zeiris_ WhereIsMySpoon_ bergey` yan_ puzza007_ hpaste othiym23 wto mcdonc froztbyte quaestor Tene Dybber Baughn knz aszlig scgilardi nlogax td123 SeanTAllen dyreshark fcr lightquake Liskni_si Raynes fgomez rcj_ Soft Iceland_jack blackmir1oxx guerrilla malorie_ acharles_ johnw araujo brixen_ bstrie_ dennda skuggi tkd gdsx_ harrison_ wting)
04:06:48 --- names: list (ozataman jlouis elliott crs__ sordina3 jrib1 yiannis_1 Guest76523 kennyp_ dan_johnsin kvey AtnNn miasma zz__ nikola plhk shanse ion bgamari_ Scott_firebeta jMCg wereHamster dropdrive aajmakin Ulrar_ Jaak comak aleator luite lispy shachaf _dabradley cwvh1 pyykkis_ connelly seats mirsal domingo_ Fubar^ qz_ Nisstyre ByronJohnson rossabaker dockside1 tg Laney stephe- mokus Squid_Tamer ryanakca ent- armlesshobo kloeri User_ ido dented42 Fuco alnix mjrosenb mrko)
04:06:48 --- names: list (popz_ tobiassj1sten CosmicRa` birkenfeld drek_ newsham barrucadu zenzike_ asante10111 rmunroe_ mastensg dfletcher KaiSforza Nimatek noam ToRA purefn charlesofarrell albel727 vehk wchun peterhil ericmj waterlaz genisage lusory reembarking08 Adios drmegahertz rcl finnrobi monique_ tunixman nonymousa geekosaur kshannon djahandarie prinnysocks felipe_ wollw Eridius dario tazjin brainproxy f8 jon-shape LeaChim alang_ fryguybob gemelen solirc kkris Boreeas)
04:06:48 --- names: list (knyppeldynan cschneid kallisti jabirali jbauman hiredman taruti shergill Hafydd timemage akosch elgot lzm Shapeshifter kyle__ mateu no-n Counter-Strike Riussi ivan\ arbn dmwit mixi otters earthy Ptival gbarboza sajith ParahSail1n morolin frz_ ahkurtz faen bbee Deewiant fayden mechairoi phaul skp monochrom wtw tomprince rmunoz mm_freak caligula liyang Nanar ttuegel volstvok akraut coppro arnihr__ SHODAN vobi raid `nand` Nickeeh Jaxan henk whoops bartavelle)
04:06:48 --- names: list (rexamophone kranius_ brett duairc_ ecuderpam tromp hvr banjiewen cow-orke1 chance companion_cube djanatyn zomg moonlite_ mux MasseR pdxleif_away IbnFirnas maksbotan_ ixian lenstr augustl kqr redjohn nardul jdoliner Vertue jmcarthur pyrtsa mami kniu wagle Ke Spockz tswett theDon stelleg_away Erstarrung Ornedan milli ccxCZ lucca tlaine chrisbuchholz_ adnauseam vmeson mpu si14 idoru Cryovat bogner alpounet pnielsen jodaro leroux PrO_OkI amiller bobry)
04:06:48 --- names: list (frontendloader sw17ch SaBer formalcow alexander__b Twey jayne so Boney hachiya Jello_Raptor BlastHardcheese absence sully celery__ Watcher7|off _janne quuxman r126l_ Starfire jyyou osfameron thoughtpolice davorak jcp cods edwtjo cmsd2 Nik_89 ethercrow BrianHV nicoo peddie frio blooberr zorzar zebr kakos TDJACR krig_ jackhill mrdomino_ Gracenotes TML jrockway eL_Bart0 ehamberg idnar sproingie dcoutts fxrh fionnan betawaffle cynick bd_ peltchu eyck fall_)
04:06:48 --- names: list (horlicks gbluma Sagi chrra CindyLinz supki Draggor mendez koala_man cjay cross quicksilver anachron_ yano wjlroe statusfailed tomaw prh danr schlumpi trolling tmiw sjl adimit gereedy confound pr liszt Clint @ChanServ n_b)
04:07:24 --- topic: '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.2 http://v.gd/oXnqjU ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","If Hackage is down, try: http://hdiff.luite.com "]'
04:07:24 --- topic: set by monochrom on [Tue Jan 29 09:36:42 2013]
04:07:24 --- names: list (clog sanemat hiro3w dmarker k00mi ninzine Tordek Reite sopvop carlocci ketil EarlGray^ identity Palmik t7 mimi_vx steful acfoltzer LAMMJohnson Philonous ozgura ilyanok tavelram vramana twomashi brisbin paddymahoney ptek asQuirreL spion bitonic PatrickRobotham owst arpunk` SoupE davorb_laptop heruur ulfdoz piotr_ tomboy64 Jeanne-Kamikaze MrGwen wyfrn [mth] solarus xcombelle duosrx schovi_ hallski tahu bezik yacks techlife `fogus jacobw k0ral joneshf)
04:07:24 --- names: list (schlicht profmakx sonda dEPY ctype_real thorkilnaur_ osnr dsantiag_ TheFuzzball ft jang Flint Botje_ joar_ pfoetche1 `bps_ XMunkki_ suiside_ Chousuke_ arkx_ KitB JoshuaA__ Guest84888 mullein emma_ m3ga PartyKat1e shepheb_ xaimus bens andrewsw mcguitan93 arenz Jonte_ magicman_ voyd Gilly_ xnyhps_ bxc_ ejls_ hpc_ iulian threeday1onk `0660 sgronblo_ bcoppens_ Axman6 Varakh milessabin DustyDin1o bholst wump qwandor|quassel Natch mattp__ xpika dixie_ skyflash_)
04:07:24 --- names: list (dschoepe julmae quchen DT` silver edsko itemad edon MrFenix cduez Xaratas hkBst edtsech niloc132 Alice3 Itkovian Sonderblade hiyakashi Targen AfC aninhumer weie_ akamaus macbr raichoo charliesome perspectival danvet HaltingState mceier kaoskorobase Zzompp Pantoufle agundry freiksenet kennyd ThomasLocke_ hamishmack __dv__ JaRoel|4d dogmaT LucasCampos cmears shintah ARCADIVS zhulikas RayNbow`TU hamid bind edwardk Argue takumn cyphase hiratara ritek kushal)
04:07:24 --- names: list (MnO2 guymann pikhq_ imeredith gspr path[l] mikecaruso d-snp notdan kerrick preflex mauke ijp stepcut c_wraith BMeph_ Mortchek apaku dreixel s00pcan theorbtwo [[zz]] Will| tamiko yc4891 kmrhb joneshf-laptop ortmage b52 joeyh hive-mind dysinger memand gseitz kamatsu sclv ozataman_ bos Swizec Kaidelong mgsloan predator217 vili xinming_ descender tensorpudding ernst dawe ktosiek creichert Rarrikins Ralith colah azaq23 Khisanth maurer saep dolio crdueck jaeyeun)
04:07:24 --- names: list (nilg` nilg AntiSpamMeta latro`a cmccann u_quark1 cads tvaalen kith DrChaos __main__ hiroaki mortberg Fuuzetsu threesome nighty^ Eelis cl_away \rs perlite ben_d lcfrs Nahra bradleyayers nus- augur mmaruseacph2 nwf ndngvr` aristid thetallguy merijn Megant tuv gwern boegel tgeeky sellout- dottedmag ousado MoALTz idntfy2 OlegYch Dodek nule jtalk ofan simon___ steez FireFly tridactyla neena pqmodn eacameron1 mefisto Eiam dgvncsz0f thirsteh bytbox Enigmagic dju)
04:07:24 --- names: list (Tesseraction ccasin McManiaC ghorn levi mietek junsuijin ciaranm rmarianski glguy sbahra julmuri Luke drbean sShintah gbeshers gthorslund trh178 melter chirpsalot Zariel thorsten` S11001001 Hermit verrens whaletechno ks07 Nshag doomlord DarkFox amatsu Th0mas ajhager robbert` isomorphic leoncamel MK_FG lopex chessguy tomejaguar machisuji UziMonkey__ lazard Vert imphasing labo BigEndian yam a11235 davean ski Derander Maxdamantus ab9rf ahihi lattenwald rfw)
04:07:24 --- names: list (adnap ]OLI[ Cerise Amadiro MOMI jlamothe SegFaultAX _anona joe9 DarkLinkXXXX Brando753 tdammers Razz ique sohum yriw_ dilinger_ pettter Rembane kaol jaspervdj otto_s kalven jml neurocyte xcvii anders^^ ninegrid jliikka_ Vq jlaire srcerer obcode_ William_ folone Jonno_FTW _flow_ wilfredh_ zxq9 etabot VZakharov SuperNoeMan shutdown_-h_now lahwran zoktar kryft sunnavy yeltzooo6 byorgey qwr Zouppen numeral petanqk inr_ ptrf Belgarion0 rio tessier_ _yezariaely)
04:07:24 --- names: list (wormphlegm deavid Adeon wei2912 Bigcheese Cale bbloom jrslepak matzo_ mlinksva Walther elliottc1ble Tehnix_ opqdonut Kinnison certaint1 kini dqd lokydor_ vhz_ klugez oitnelis IanKelling myme warpy___ tanakh ClaudiusMaximus sirchurchill tim1 FalkoPeters abumirqaan mtlatif ormaaj tomh_ Xorlev helgikrs Philippa mike2 arkeet jonke u__ parcs necropumpkin tippenein mrd x7 sm chrisirc_ JoeHazzers Martty jaimef lpvb eviltwin_ dlundy h_chiro gdeest epta Valodim)
04:07:24 --- names: list (Tarential hanDerPeder kosmikus lpsmith ibid strax_ orzo xrq otterdam rainmaker black_joe xrl__ Sgeo akahn trevize_ sipa alios netj canvon s_quark reiddraper saiam Ghoul__ koninkje_away staafl_alt fotc natte jtobin tsou drewr Dashkal xymox dumbhat Saizan ziman ps-auxw JPohlmann endojelly marienz hyko fabjan canta The_third_man niko Excureo hungryblank xorox90 KaneTW sh liesen arun mollerstrand yumike DrSyzygy thetallguy1 flux b_jonas Kuba_ heath SLi ysulsky)
04:07:24 --- names: list (Internet13 Gunni alcz hpd jamwt hackagebot lambdabot alejandrogomez NougatRillettes Draconx simpson linduxed munro mjr841 Canar mikeplus64 petantik _br_ hiroyuki2 Heffalump rsimoes dkasak fireglow wunki kylcarte Athas ChongLi tom4939_ ahf aforemny mornfall jlewis ivan` def-lkb Vorpal chr1s fergusnoble noj Gothmog_ zwiebel majoh ocharles setmeaway2 lulf sunfun kmicu integral_ edenc_ DigitalK1wi alshain pharaun noplamodo flori jix joachifm jercos Igloo Bwild)
04:07:24 --- names: list (saurik mrshoe Eliel `micro Plex- brandonw alang gcmalloc raek rs0 smarter tomku pepijndevos int-e Estrellas robbe- mlh pcapriotti meyersh zeiris_ WhereIsMySpoon_ bergey` yan_ puzza007_ hpaste othiym23 wto mcdonc froztbyte quaestor Tene Dybber knz Baughn aszlig scgilardi nlogax td123 SeanTAllen dyreshark fcr lightquake Liskni_si Raynes fgomez rcj_ Soft Iceland_jack blackmir1oxx guerrilla malorie_ acharles_ johnw araujo brixen_ bstrie_ dennda skuggi tkd)
04:07:24 --- names: list (gdsx_ harrison_ wting ozataman jlouis elliott crs__ sordina3 jrib1 yiannis_1 Guest76523 kennyp_ dan_johnsin kvey AtnNn miasma zz__ nikola plhk shanse ion bgamari_ Scott_firebeta jMCg wereHamster dropdrive aajmakin Ulrar_ Jaak comak aleator luite lispy shachaf _dabradley cwvh1 pyykkis_ connelly seats mirsal domingo_ Fubar^ qz_ Nisstyre ByronJohnson rossabaker dockside1 tg Laney stephe- mokus Squid_Tamer ryanakca ent- armlesshobo kloeri User_ ido dented42)
04:07:24 --- names: list (Fuco alnix mjrosenb mrko popz_ tobiassj1sten CosmicRa` birkenfeld drek_ newsham barrucadu zenzike_ asante10111 rmunroe_ mastensg dfletcher KaiSforza Nimatek noam ToRA purefn charlesofarrell albel727 vehk wchun peterhil ericmj waterlaz genisage lusory reembarking08 Adios drmegahertz rcl finnrobi monique_ tunixman nonymousa geekosaur kshannon djahandarie prinnysocks felipe_ wollw Eridius dario tazjin brainproxy f8 jon-shape LeaChim alang_ fryguybob gemelen)
04:07:24 --- names: list (solirc kkris Boreeas knyppeldynan cschneid kallisti jabirali jbauman hiredman taruti shergill Hafydd timemage akosch elgot lzm Shapeshifter kyle__ mateu no-n Counter-Strike Riussi ivan\ arbn dmwit mixi otters earthy Ptival gbarboza sajith ParahSail1n morolin frz_ ahkurtz faen bbee Deewiant fayden mechairoi phaul skp monochrom wtw tomprince rmunoz mm_freak caligula liyang Nanar ttuegel volstvok akraut coppro arnihr__ SHODAN vobi raid `nand` Nickeeh Jaxan)
04:07:24 --- names: list (henk whoops bartavelle rexamophone kranius_ brett duairc_ ecuderpam tromp hvr banjiewen cow-orke1 chance companion_cube djanatyn zomg moonlite_ mux MasseR pdxleif_away IbnFirnas maksbotan_ ixian lenstr augustl kqr redjohn nardul jdoliner Vertue jmcarthur pyrtsa mami kniu wagle Ke Spockz tswett theDon stelleg_away Erstarrung Ornedan milli ccxCZ lucca tlaine chrisbuchholz_ adnauseam vmeson mpu si14 idoru Cryovat bogner alpounet pnielsen jodaro leroux PrO_OkI)
04:07:24 --- names: list (amiller bobry frontendloader sw17ch SaBer formalcow alexander__b Twey jayne so Boney hachiya Jello_Raptor BlastHardcheese absence sully celery__ Watcher7|off _janne quuxman r126l_ Starfire jyyou osfameron thoughtpolice davorak jcp cods edwtjo Nik_89 cmsd2 ethercrow BrianHV nicoo peddie frio blooberr zorzar zebr kakos TDJACR krig_ jackhill mrdomino_ Gracenotes TML jrockway eL_Bart0 ehamberg idnar sproingie dcoutts fxrh fionnan betawaffle cynick bd_ peltchu)
04:07:24 --- names: list (eyck fall_ horlicks gbluma Sagi chrra CindyLinz supki Draggor mendez koala_man sjl adimit gereedy confound pr liszt Clint @ChanServ n_b tmiw trolling schlumpi danr prh tomaw statusfailed wjlroe yano anachron_ quicksilver cross cjay)
04:09:45 <bitonic> @ty id
04:09:46 <lambdabot> a -> a
04:09:52 <bitonic> oh, so you are not down.  mhm
04:10:37 <bitonic> lambdabot: localtime bitonic
04:10:47 <bitonic> localtime doesn’t seem to work.  weird.
04:10:51 <arkeet> no, you forgot the @
04:10:54 <arkeet> @localtime bitonic
04:10:55 <lambdabot> Local time for bitonic is Tue Mar 26 12:11:03 2013
04:11:02 <bitonic> doh.  thanks arkeet.
04:11:07 <plhk> ADT with hundred constructors is a bad idea, right?
04:11:09 <arkeet> lambdabot: @localtime
04:11:10 <lambdabot> Local time for arkeet is 火 3月 26 04:10:58 2013
04:11:18 <arkeet> crap, I better go.
04:11:23 <arkeet> plhk: probably.
04:11:35 <arkeet> night everyone o/
04:11:39 <bitonic> plhk: it’d take a while to compile.
04:11:43 <bitonic> arkeet: night
04:11:58 <bitonic> plhk: I remember this guy with thousands of TH-generated constructors.
04:14:39 <plhk> bitonic: yeah, i was thinking about generating them from the spec
04:15:09 <bitonic> plhk: hundreds is definitely OK
04:15:52 <plhk> bitonic: how bad is that from performance point of view?
04:15:55 <quicksilver> constructors don't really cost anything.
04:16:13 <FireFly> @localtime
04:16:19 <bitonic> the only problem I know with GHC is that it goes nuts compiling if you have too many
04:16:21 <lambdabot> Local time for FireFly is Tue, 26 Mar 2013 12:19:44 +0100
04:17:25 <ketil> Kaidelong, not exactly what I wanted - I just want something like a2ps or enscript to nicely format my (non-literate) sources for printing.
04:17:36 <ketil> Sun's shining, I'm not going to sit here in the dark to read code :-)
04:19:10 <plhk> i'm parsing binary format which is like Foo: word32, Bar: word8 and so on. So I think about making a huge Variable ADT
04:19:18 <plhk> is there a better way to do that?
04:21:23 <xpika> thanks for the help  ghc -e "Data.ByteString.putStr (Data.ByteString.pack [128])" | xxd  => 0000000: 80
04:21:44 <xpika> arkeet: @
04:22:06 <plhk> currently I use Map [("Foo", W32value), ("Bar", W8Value)], but this is not very typesafe
04:27:29 <m_hyperbolic> Is there a smart way to partition a list into a list of lists with specified length ?
04:27:48 <fizbin> plhk: Do you have much experience with template haskell?
04:29:15 <arkeet> @hoogle chunksOf
04:29:16 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
04:29:16 <lambdabot> Data.Text.Lazy chunksOf :: Int64 -> Text -> [Text]
04:29:17 <arkeet> m_hyperbolic: ^
04:29:19 <arkeet> er
04:29:34 <arkeet> no, it's in the split package somewhere.
04:29:46 <arkeet> :t Data.List.Split.chunksOf
04:29:47 <lambdabot> Int -> [e] -> [[e]]
04:30:02 <arkeet> > Data.List.Split.chunksOf 3 [1..10]
04:30:03 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
04:30:24 <fizbin> plhk: Because I wonder if maybe it would be possible to build up a set of combinators that when run together would create a structure that described your format, then have three functions, one that went from that description to an Expr defining a datastructure, one that went from that description to a parser and one that went from that description to a generator.
04:30:59 <m_hyperbolic> arkeet: cool!. Is that a standard package ?
04:31:06 <arkeet> split is in the haskell platform
04:31:12 <arkeet> which I guess is as standard as it gets.
04:31:55 <m_hyperbolic> ok. Thanks!
04:46:19 * hackagebot miniball 0.1 - Bindings to Miniball, a smallest enclosing ball library  http://hackage.haskell.org/package/miniball-0.1 (GardSpreemann)
05:01:29 <plhk> fizbin: no, i don't
05:07:50 <dmwit> miniball looks like a pretty piece of math
05:08:58 <bitonic> it does, I was reading the paper now
05:09:09 <bitonic> 500lines of C++ ehe
05:11:52 <dmwit> "The method reaches its limits much earlier than in dimension 30, when it comes to the worst case."
05:12:10 <dmwit> 30 is such a strange number to be a worst case!
05:14:08 <sipa> dmwit: do you know which is the smallest number N for which it is true that the set {0..N-1} has more numbers with an even number of prime divisors than numbers with an odd number of prime divisors?
05:16:38 <sipa> eh, make that {2..N-1}
05:22:17 <dmwit> sipa: No, but I got to 20 and was six in the hole before I stopped counting in my head. =P
05:22:33 <sipa> dmwit: iirc it's somewhere around 955 billion
05:22:43 <dmwit> amazing
05:22:50 <dmwit> I'm glad I didn't keep going.
05:25:44 <bitonic> sipa: who the hell thought and checked that?  link?
05:26:26 <sipa> bitonic: i checked that myself, some years ago, but afterwards i learnt that it was known since somewhere in the '80s
05:26:33 <bitonic> aha, OK.
05:26:48 <bitonic> it is very weird.  is there something deep going on?
05:27:03 <sipa> can't remember the name of the conjecture (that no such number existed) or who proved it wrong
05:32:03 <notdan> How can I run `cabal-dev ghci' inside Emacs/haskell-mode?
05:35:52 <Fubar^> notdan: I usuall do M-x shell and then cabal-dev ghci in that shell. I think there is supposed to be cabal-dev support in haskell-mode. But i don't know how it works
05:38:09 <hpaste> “Anonymous Coward” pasted “fib” at http://hpaste.org/84665
05:39:00 <x7a1c0b> is there a way to make that approach posted above more efficient
05:39:13 <x7a1c0b> so that it's possible to calculate fib_1000000
05:39:34 <bobry> where can I read about GHC simplifier phases?
05:39:49 <x7a1c0b> right now, this overflows the stack on my machine somewhere after fib_100000
05:40:37 <arkeet> x7a1c0b: make go strict
05:40:52 <bobry> in both arguments?
05:41:06 <arkeet> maybe
05:41:35 <croikle> x7a1c0b: also, there is a better algorithm, with repeated squaring of the 2x2 transition matrix
05:42:05 <arkeet> croikle: not if you want to compute all the fibs
05:42:12 <arkeet> but yeah, for a single one you can do better.
05:42:20 <croikle> arkeet: yeah.
05:42:21 <x7a1c0b> arkeet Could you tell me how to do that?
05:42:51 <arkeet> x7a1c0b: seq or BangPatterns
05:42:58 <arkeet> croikle: you can do better than a matrix.
05:43:17 <hpaste> croikle annotated “fib” with “fib (annotation)” at http://hpaste.org/84665#a84666
05:43:53 <arkeet> you're only taking powers of a single matrix, so you can do it all in the subring it generates.
05:43:54 <croikle> ehh, messed up the pragma brackets
05:44:02 <m_hyperbolic> What is the correct way to seperate something like print zip preparelist a preparelist b ? is print $ zip (preparelist a) (preparelist b) the cleanest way ?
05:44:09 <croikle> {-# #-} instead
05:44:21 <arkeet> m_hyperbolic: I'd do that.
05:44:59 <arkeet> croikle: i.e. compute stuff in the ring Z[phi] = Z[x]/(x^2 - x - 1)
05:45:24 <croikle> arkeet: hmm, okay
05:45:34 <arkeet> 2 components instead of 4.
05:46:28 <arkeet> wait.
05:46:32 <arkeet> actually,
05:46:34 <arkeet> never mind.
05:46:44 <arkeet> x7a1c0b: the problem, I think, is that you're computing a+b twice.
05:47:10 <arkeet> strictness isn't the problem.
05:47:30 <arkeet> uh.
05:47:35 <arkeet> hang on.
05:48:17 <arkeet> maybe it's both.
05:48:59 <croikle> m_hyperbolic: if you want silly pointfree, print .: (zip `on` preparelist)
05:49:25 <croikle> but your way is clearer probably :)
05:50:15 <arkeet> ah yeah it is the strictness.
05:51:37 <m_hyperbolic> yeah I haven't really mastered the .: thing so for my own readability I'll do the other one hehe
06:01:21 * hackagebot SVGFonts 1.2 - Fonts from the SVG-Font format  http://hackage.haskell.org/package/SVGFonts-1.2 (TillmannVogt)
06:08:29 <twomashi1> is there a strict version of (:) ?
06:10:49 <BMeph_> twomashi1: Depending on what you think "a strict version" would do,... yes! ;)
06:12:00 <twomashi1> let (!:) x y = (seq y x) : y
06:14:39 <alpounet> twomashi1, this will "only" evaluate to weak head normal form
06:14:48 <alpounet> and you probably meant 'seq x y'
06:15:21 <twomashi1> no… seq y x
06:15:42 <twomashi1> just want a strict version of (:) to make a recursive function non lazy
06:19:56 <alpounet> twomashi1, lazy in what? your current code will just force the evaluation of y just far enough to know whether y is [] or has at least another element and the rest of the list behind it
06:20:06 <alpounet> you are not forcing the evaluation of the elements of the list here
06:20:19 <alpounet> the actual values stored in that list, I mean
06:20:22 <twomashi1> true.
06:20:44 <alpounet> maybe this is what you are looking for?
06:21:39 <twomashi1> basically I want the entire list to compute so that i dont have a ton of old data lying around taking up memory
06:26:51 <Saizan> (!:) !x !y = x : y
06:27:14 <parcs> twomashi1: you should do that as you're constructing the list, not after
06:27:39 <elliott> hm, is (!:) a valid operator?
06:27:43 * Iceland_jack wonders if he should mention Control.DeepSeq
06:27:45 <Iceland_jack> oops.
06:29:20 <twomashi1> Iceland_jack: probably a better solution, yes..
06:29:37 <Iceland_jack> Or using a strict data structure
06:29:50 <Iceland_jack> Lists are not horribly efficient for most things
06:30:15 <twomashi1> parcs: thats what I want to do. use a strict (:) so that the first argument "depends" on the second, thus forcing evaluation of the spine of the list I am creating
06:31:00 <twomashi1> Iceland_jack: is there a more memory efficient data structure that can be operated on recursively?
06:32:22 <twomashi1> maybe something liike: data MyList = MyList {!_head, !_rest :: MyList }
06:32:34 <Iceland_jack> I'm not sure what you mean by your second part (operated on recursively), but you can look at Data.Sequence
06:33:02 <dates_> hi guys, can you tell me the answer of this? http://hpaste.org/84668
06:33:17 <Saizan> twomashi1: you shouldn't make the first argument depend on the second, but have the cons cell depend on both
06:34:02 <geekosaur> dates_, no indentation means that isn;t going to work
06:34:19 <geekosaur> haskell is indentation sensitive, if wherever you got that shoed indentation, use the same indentation
06:34:21 <Saizan> twomashi1: which is what defining a list datatype with strict fields also does
06:35:06 <twomashi1> Saizan: How does one do that?
06:35:18 <dates_> geekosaur : fixed
06:35:24 <Saizan> twomashi1: seen my definition of (!:) above?
06:35:38 <Saizan> twomashi1: it uses BangPatterns
06:36:27 <Saizan> twomashi1: though if you're being strict like that maybe a more compact datastructure would be best, like an array (especially if you can unbox)
06:36:39 <twomashi1> Ah
06:37:11 <twomashi1> Saizan: yes, thats what I want to do. But I need to be able to operate on them recursively, since I need to implement a merge of 2 sorted sets
06:37:42 <twomashi1> ie smerge (x:xs) (y:ys) ...
06:37:56 <Saizan> twomashi1: you can recurse with different starting indexes
06:38:22 <Saizan> twomashi1: though i guess building an array recursively wouldn't work so well
06:38:53 <Saizan> a strict list neither though, unless you're using an accumulator
06:39:13 <Saizan> because you'll get a stack overflow from the strictness
06:39:30 <twomashi1> I wont… the lists are small
06:39:40 <twomashi1> just that theres thousands and thousands of them
06:39:43 <twomashi1> small lists.
06:41:13 <twomashi1> maybe an unboxed data type like A { !head, !tail :: A }
06:42:09 <eacameron1> I think I am doing this wrong but I'm not sure how to move forward: let's say I have "data D = A | B | C [A]" <- I want one of my constructors to take a list of one of the others. That can't be done. How would I achieve something like that?
06:42:23 <Saizan> twomashi1: that's not valid syntax
06:43:10 <Saizan> twomashi1: and you need {-# UNBOX #-} for unboxing
06:43:15 <elliott> eacameron: what do you mean by that?
06:43:17 <bitonic> eacameron: ‘data D = A | B | C [D]’?
06:43:31 <bitonic> in that way you have a list of Ds, which I assume is what you mean?
06:43:44 <twomashi1> Saizan: sorry, bit of a newb :). but yes, reimplement list with unboxed head and rest.
06:43:48 <bitonic> eacameron: if you want a list of either A or B, you need a separate datatype for that
06:43:52 <eacameron> bitonic: elliott: bitonic's example is technically what is correct, but C cannot have any A's or B's in the list
06:43:57 <bitonic> (or a GADTs but it’s overkill here)
06:44:10 <Saizan> twomashi1: you can only do that if your element type is monomorphic
06:44:19 <Saizan> twomashi1: and the rest won't be unboxed
06:44:20 <bitonic> eacameron: what so what does the list in ‘C’ should contain?
06:44:28 <Saizan> twomashi1: you should consider arrays
06:44:31 * elliott stands by his original question
06:44:39 <elliott> perhaps you shold give some example values of the D you want?
06:45:11 <eacameron> elliott: bitonic: Example: data VValue = VHash String VValue | VDict [VHash]
06:45:29 <eacameron> there are other constructors for VValue that I'm not showing
06:45:34 <bitonic> eacameron: what does that mean?  it’s not valid Haskell
06:45:44 <bitonic> unless there is a VHash type somewhere that you are not showing
06:46:08 <eacameron> bitonic: I know it's not valid haskell... ;) That's why I'm trying to figure out how I would achieve that the correct way
06:46:13 <eacameron> I'm obviously thinking about it wrong
06:46:28 <twomashi1> Saizan: "and the rest won't be unboxed" because it must be A | Nil right?
06:46:51 <bitonic> eacameron: but we are having a hard time understanding what you want.  can you give some examples of actual values of type VValue?
06:47:12 <elliott> eacameron: okay, make a new type then
06:47:26 <elliott> eacameron: data Hash = Hash String Value
06:47:32 <elliott> eacameron: data Value = VHash Hash | VDict [Hash]
06:47:56 <eacameron> elliott: simple as that, eh?
06:48:03 <eacameron> I'll give it whack
06:48:06 <eacameron> thanks
06:48:37 <eacameron> btw: what are GADTs?
06:48:39 <elliott> :)
06:48:42 <bitonic> OK so I had guessed right ehe
06:48:45 <elliott> GADTs are a generalisation of the data type syntax
06:48:51 <elliott> they let you do some more stuff.
06:48:59 <eacameron> template haskell?
06:49:06 <Saizan> twomashi1: no because recursive occurences are not unboxed, i.e. you'll still get a linked list out of it
06:49:32 <bitonic> eacameron: nothing to do with TH, they let you do interesting stuff with the parameters of type constructors
06:49:45 <eacameron> I'll have to check them out!
06:50:20 <bitonic> eacameron: you probably don’t need them yet ehe
06:51:39 <hamid_> @src foldl
06:51:39 <lambdabot> foldl f z []     = z
06:51:39 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:14:39 <hamid_> @src error
07:14:39 <lambdabot> error s = throw (ErrorCall s)
07:15:13 <hamid_> :t throw
07:15:14 <lambdabot> Not in scope: `throw'
07:15:21 <hamid_> :/
07:16:25 <m_hyperbolic> isn't it possible to patternmatch again a list of touples with something like ((a,b):xs) ?
07:16:41 <Botje_> yes, that should work
07:17:20 <m_hyperbolic> great. thanks!
07:27:22 <tdammers> > let f ((a,b):xs) = a ++ "," ++ b ++ " and the rest" in f [("foo","bar"),("baz","quux")]
07:27:24 <lambdabot>   "foo,bar and the rest"
07:27:36 <tdammers> m_hyperbolic: does that answer your question?
07:28:44 <m_hyperbolic> tdammers: Yes. I really just wanted to know if I was trying to do something that wans't possbile, or if I just messed it up
07:28:53 <m_hyperbolic> the latter it seems
07:28:57 <tdammers> :D
07:29:17 <byorgey> m_hyperbolic: maybe you wrote  (a,b):xs  instead of  ((a,b):xs)  ?  The outer parentheses are required.
07:30:22 <m_hyperbolic> No, I just messed my output up :D . My function has the type signature  ([Double],[Double]) -> [([Double],[Double])] -> Double -> [Double] -> [Double], and I have hard time keeping track of it hehe
07:30:47 <tdammers> maybe some more explicit types are in order?
07:31:00 <m_hyperbolic> what do you mean ?
07:31:12 <tdammers> I suspect there is more semantic meaning to those Doubles than "any number"
07:31:26 <tdammers> I suspect your types are either too concrete or too specific
07:31:48 <m_hyperbolic> hm.. Could be. I just can't see how to make them different
07:32:31 <tdammers> well, either make it more generic, sth like ([a], [b]) -> [([a],[b])] -> a -> [a] -> [b] (maybe, idk what the function does)
07:32:41 <hpaste> m_hyperbolic pasted “Program” at http://hpaste.org/84678
07:32:49 <tdammers> or more concrete, by wrapping the Doubles in more descriptive construcors
07:33:36 <m_hyperbolic> I could maybe make them more generic. I only pass numbers around, so I properly don't have to specify them to much
07:35:43 <m_hyperbolic> How would I wrap the Doubles in 'more descriptive constructor' ? what does that mean
07:36:52 <croikle_> you can make a synonym: type Foo = ([Double],[Double]), or for more safety and hassle use newtype
07:37:46 <elliott> better data than newtype of tuple
07:37:55 <copamp> why is strncmp implemented like this: if (len--==0) return 0? what about a size 1 string? or is the null terminator included?
07:37:56 <croikle_> good point
07:42:49 <geekosaur> strncmp still expects nul-terminated strings, yes, but remember that's post-increment so it tests the length as it was before the decrement
07:42:57 <geekosaur> er, post-decrement
07:56:03 <alexander__b> what is 'p' usually short for? in learnyouahaskell they implement filter' as filter' p = foldr (\x acc -> if p x then x : acc else acc) [] -- whereas I used f instead of p. but then again I don't know all that much maths...
07:56:30 <geekosaur> predicate
07:56:37 <geekosaur> in that case
07:56:52 <geekosaur> the name doesn't really matter, of course
07:57:40 <alexander__b> oh yes of course
07:57:51 <typoclass> alexander__b: yup, functions that evaluate to booleans are sometimes called predicates
07:57:51 <copamp> is there a simple trick to convert to lover case? likfe if (x>= a and x <=b) x -= offset_to_lower_case_chars; ?
07:57:52 <alexander__b> makes sense to me then.
07:58:10 <alexander__b> typoclass: I should have guessed, because that's a naming convention I'm very accustomed to.
07:58:22 <typoclass> > map toLower "LOLcats" -- copamp, here's an example
07:58:23 <lambdabot>   "lolcats"
07:58:36 <alexander__b> typoclass: to the point of frequently asking someone whether they are at "school-p".
07:58:49 <typoclass> alexander__b: ;-)
07:59:36 <alexander__b> typoclass: I guess it's just overwhelming when most things are so alien, that I kind of expect nothing to be familiar, heh.
08:00:00 <alexander__b> s/that/so
08:00:09 <geekosaur> copamp: Data.Char.toLower is preferred, it does the right thing with unicode
08:00:51 <croikle> there's something weird with turkish, for example
08:01:44 <typoclass> alexander__b: by the way, i don't think that convention is very fixed. you might just as well do "if f x then ..."
08:02:16 <geekosaur> "split-p soup?"
08:02:23 <alexander__b> geekosaur: yes, exactly, hehe.
08:03:54 <alexander__b> geekosaur: more than once my colleague has responded to "sup" with "NIL"
08:05:34 <m_hyperbolic> If I want to map a function that takes an element x and a list (y:ys) over a list of x, (x:xs), is there another way to do it other than have my function like f (y:ys) x so that I can map (f (y:ys)) (x:xs) ? That is; to make a partial applied function, does the variable I want to leave out have to be the last varible passed to the function?
08:07:29 <geekosaur> usually, yes. there is the flip combinator, or using infox notation and creating a section, but having the partially applied values first and the unapplied one last is usually clearest
08:07:38 <typoclass> > zipWith (/) [6,8] [3,2] -- m_hyperbolic, this may be what you're asking for. zipWIth is essentially a map function that walks through two lists. the function gets passed two elements
08:07:40 <lambdabot>   [2.0,4.0]
08:08:43 <typoclass> m_hyperbolic: when in doubt, you could always do map (\y -> f (x:xs) y) ys
08:08:44 <m_hyperbolic> typoclass: No, I need to take all the elements of one list, and compare each one to all the elements of another list, with some parameters
08:08:49 <alexander__b> hm. it says foldr can work on infinite lists and foldl not. but ':' is faster than '++'. would it be more useful to implement the generic reverse' function with foldr or foldl?
08:09:11 <alexander__b> the book does "reverse' = foldl (\acc x -> x : acc) []", and I did "reverse' = foldr (\x acc -> acc ++ [x]) []"
08:09:33 <elliott> alexander__b: reverse cannot possibly work on infinite lists
08:09:41 <elliott> so it doesn't really matter that foldl doesn't here
08:10:23 <alexander__b> elliott: I didn't really think of that. true.
08:11:30 <alexander__b> also reversing [0..10000] with : was *a lot* faster than ++, heh.
08:12:09 <parcs> do you mean [x] ++ y vs x : y?
08:12:37 <alexander__b> parcs: yes, I realise that : is faster than ++ because of how they work internally.
08:13:11 <parcs> i find that hard to believe
08:13:24 <elliott> "(:) is faster than (++)" doesn't really make sense
08:13:46 <elliott> I mean, it's not really quite why the foldl version is faster
08:13:52 <parcs> it sounds like you are describing different algorithms
08:14:06 <elliott> (in particular, it's true that [x] ++ y and x : y are the same modulo very small constant factors if that)
08:14:07 <parcs> the O(n^2 reverse vs the O(n) reverse
08:14:49 <parcs> ghc should be able to optimize away [x] ++ y
08:15:30 <alexander__b> I meant that with ++ haskell internally walks through the entire left-side list, so with a big list using foldl and ':' is faster than foldr and '++'. unless I don't fully grasp how foldl and foldr work.
08:15:43 <hpaste> dmwit pasted “Parsec choice” at http://hpaste.org/84682
08:15:48 <elliott> it only walks through the left list as you go through (xs ++ ys)
08:15:52 <elliott> lazy evaluation
08:16:50 <dmwit> (Negative answers to my hpaste also appreciated.)
08:17:01 <typoclass> dmwit: NO!1!
08:17:14 <geekosaur> dmwit, I think the utrecht parser combinators work that way? but they're also somewhat more complex, iirc
08:17:34 <parcs> indeed bar x xs = [x] ++ xs gets optimized away to bar = (:)
08:17:44 <typoclass> alexander__b: it's important to measure these things with profiling or some other method. you need to know that you're optimizing the right things, instead of spending time optimizing something that's entirely drowned out by other stuff
08:17:56 <dmwit> I mean, I don't even need my "choice" to be able to work over arbitrary parsers, just static strings.
08:18:06 <dmwit> So I shouldn't need a more complex parser type, right?
08:18:21 <dmwit> I'll take a look at the Utrecht stuff anyway, though.
08:18:41 <geekosaur> wasn't this discussed on one of the lists recently?
08:18:48 <dmwit> It wouldn't surprise me!
08:19:23 <typoclass> dmwit: could you use 'try'?
08:19:40 <dmwit> typoclass: That's option 1, right?
08:20:23 <typoclass> dmwit: blerg, of course. sorry
08:20:44 <byorgey> dmwit: the other option is to use 'symbol' from a parsec lexer, which (I'm 95% sure) uses 'try' as well as ensures that "min" (or whatever) is not a prefix of an identifier like "minBlah"
08:21:20 <dmwit> Ah, yeah, maybe it's time to make a real lexer.
08:21:48 <byorgey> oh, not symbol, 'reserved'
08:22:30 <dmwit> Until now, I've been dealing with that problem by having all identifiers begin with '<'. =P
08:25:33 <tdammers> sth like: try (string "min" $ notFollowedBy alphanum)
08:27:30 <m_hyperbolic> assuming b1 and b2 are two lists representing vector wouldn't sqrt $ sum $ zipWith (\x y ->  (x - y)^2) b1 b2 be the euclidian distance between the two ?
08:28:20 <byorgey> m_hyperbolic: no, you want  (\x y -> x^2 - y^2)
08:28:33 <byorgey> wait, no, ignore me =P
08:28:55 <byorgey> your code looks right
08:29:27 <dmwit> m_hyperbolic: Maybe! What types are stored in the vector?
08:29:38 <dmwit> (Maybe you need to convert to a type that implements sqrt.)
08:29:45 <m_hyperbolic> Doubles
08:30:26 <dmwit> Looks okay to me!
08:30:56 <m_hyperbolic> Hmm.. That sucks.. Then I actually need to go through my code for some other error :P
08:31:04 <dmwit> > sqrt $ sum $ zipWith (\x y -> (x-y)^2) [1,2,3] [4,5,6::Double]
08:31:06 <lambdabot>   5.196152422706632
08:32:49 <nycs> has anyone used either hmatrix or numkell?
08:33:34 <m_hyperbolic> nycs: I've used hmatrix a bit
08:36:43 <nycs> any thoughts on it? i'm looking to do fast multidimensional matrix math
08:37:24 <dmwit> hmatrix uses LAPACK/BLAS in the background, which are highly optimized.
08:38:08 <t7> im more of an eigen guy myself
08:38:18 <t7> well glm these days ¬¬
08:38:50 <m_hyperbolic> Well I havn't used any other, so I can't really compare it with any other, but I've used it for a datamining exam this week, and I work great for me
08:41:18 <m_hyperbolic> And the documentation for hmatrix is good. Lots of examples and such. I don't know if that matters much to you, but I really like that
08:41:54 <m_hyperbolic> The only real downside so far is that the built-in plot functions are very limited, but that also depends on your use for them :)
08:46:00 <nycs> cool. i'll check it out i guess
08:57:17 <m_hyperbolic> Does anybody know of a good way to code critique for a semi-beginner? Does there exists some officiel 'critique-my-code' forums or such ?
08:58:08 <Taneb> I don't think so
08:58:24 <parcs> that's what university is for! i think
08:58:27 <Taneb> Put it online somewhere and put a link here and someone'll have a look at it
08:58:53 <`^_^v> ha, writing good code in academia?
08:59:06 <merijn> `^_^v++
08:59:32 <merijn> For my master project I scrapped half the existing codebase because I considered it to awful to work with :p
09:00:14 <typoclass> m_hyperbolic: i think you'll get responses if you just hpaste the code and ask in here, unless you have lots and lots of code
09:00:37 <m_hyperbolic> well I don't have any coding classes untill my master, and I want to improve in the mean time..
09:00:49 <alexander__b> length (takeWhile (<1000) (scanl1 (+) (map sqrt [1..]))) + 1    -- why plus 1?
09:01:01 <alexander__b> m_hyperbolic: write a patch to a program
09:01:01 <`^_^v> read clean code by rob martin
09:01:13 <Philonous> is there a package that parses / displays SockAddr in dot-decial / hexadecimal representation?
09:01:18 <m_hyperbolic> typoclass: well mostly I just small thing, and maybe snippets of LARGER PROGRAMS
09:01:33 <m_hyperbolic> sorry for caps :P
09:01:55 <m_hyperbolic> alexander__b: but is there any program that a beginner could realistically write a patch for ?
09:02:32 <alexander__b> m_hyperbolic: you'd be surprised how easy it is to contribute something meaningful to even the largest projects, as long as you focus on one small component of it.
09:03:50 <alexander__b> m_hyperbolic: (though I don't have any suggestions right now, since I'm very much a newbie when it comes to haskell. the only projects I know of are uhm frag (or something) and xmonad)
09:07:05 <m_hyperbolic> alexander__b: Yeah you are properly right. I should just start looking into fun programs, and look at some source code :)
09:21:40 * hackagebot simplex 0.3.2 - A simple markup language that translates to LaTeX  http://hackage.haskell.org/package/simplex-0.3.2 (JulianFleischer)
09:29:50 <otters> :t fix id
09:29:52 <lambdabot> a
09:30:11 <amiller> hey does anyone have any experience with call by push value
09:30:29 <amiller> it's an alternative to monadic semantics that's meant to be a generalization
09:30:51 <amiller> i know how to take a lambda calc language and make a monadic evaluator, meaning one that's parametric for any monad
09:30:53 <amiller> and that's great
09:31:07 <amiller> but i have to choose either call-by-name or call-by-value semantics
09:31:54 <amiller> the point of CBPV is that you have a couple extra primitives force/return/thunk that let you indicate call-by-name and call-by-value in the source language
09:32:08 <amiller> but what's interesting is that the semantics is then parametric in an *adjunction* rather than in a monad
09:32:19 <amiller> the trouble is that i don't know wtf to do with an *adjunction*
09:32:36 <amiller> from the paper there is an adjunction that corresponds to the state monad
09:33:08 <amiller> but i know the typeclass for an adjunction nor do i know how to express the standard state monad as an adjunction
09:33:25 <amiller> but i don't* know the typeclass
09:33:46 <byorgey> amiller: http://hackage.haskell.org/package/adjunctions ?
09:34:16 <amiller> hm, good point - also here's the standard edwardk post http://comonad.com/reader/2008/representing-adjunctions/
09:34:50 <amiller> oh okay these do in fact contain a representation for state monad as an adjunction.
09:34:53 <edwardk> heh i forgot i wrote that
09:34:55 <amiller> okay maybe this is doable then
09:35:12 <amiller> i've seen only a couple implementations of call-by-push-value and as far as i can tell they're all degenerate
09:35:13 <edwardk> what are you trying to do?
09:35:22 <amiller> have you seen CBPV?
09:35:25 <edwardk> yes
09:35:40 <amiller> i think i should be able to provide a semantics for it that takes an adjunction as a parameter
09:36:00 <edwardk> ah
09:36:07 <amiller> and if you give it the adjunction that arises from state monad (i think i described that backwards but you know what i mean) then it should correspond to monadic semantics with state as a store
09:36:07 * edwardk gets out of the way. ;)
09:36:15 <amiller> no get back in the way i have no idea what i'm doing :p
09:36:18 <edwardk> =)
09:36:23 <edwardk> sok, neither do i =)
09:36:42 <amiller> sometimes i feel like only my compiler really understands me.
09:37:00 <edwardk> I can empathize
09:37:57 <hpaste> gspr pasted “Pointers to Storable vectors” at http://hpaste.org/84684
09:39:08 <gspr> http://hpaste.org/84684 - Is this a sensible way to pass a pointer to a vector of pointers to storable vectors to a C function (bar in the paste) expecting, say, int**?
09:40:02 <gspr> (I don't like the fact that the length of xs is traversed three times)
09:41:33 <hpaste> jbracker pasted “Space Leak” at http://hpaste.org/84685
09:41:56 <jbracker> I have a space leak in the code above, but I don't know where it comes from
09:42:58 <jbracker> When I parse this file "http://people.eecs.ku.edu/~jerzy/data/common_combined_lers.d" with the scanner my memory usage is between 1,5 and 2GB and I don't see why that is the case
09:44:59 <linduxed> hey guys, i've got two functions in which i want to use a curried function called 'd'
09:45:05 <linduxed> the code is here https://gist.github.com/linduxed/5246956
09:45:23 <linduxed> the problem is that let-syntax doesn't work the way i expect it to :-/
09:46:24 <glguy> linduxed: your "where" needs to be more indented than "edgeBDistance"
09:46:42 <linduxed> glguy: is that it? i'll try that...
09:46:51 <donri> glguy: i don't think that's the problem here...
09:46:51 <linduxed> i don't think it's that though
09:47:03 <linduxed> nope
09:47:08 <sepp2k> linduxed: I think the problem is rather that A and B aren't valid variable names as variable names must not start with capital letters.
09:47:15 <glguy> oh, you also can't define names like that in a let-in
09:47:32 <linduxed> sepp2k: that could be true! i'll fix that
09:47:45 <donri> linduxed: you have bindings in the expression context (the edge distances). not sure what you're going for with A and B there. also in your case you could put all bindings in the where clause
09:48:11 <monochrom> after "in", you can have an expression, not a definition.
09:48:12 <linduxed> donri: lowNodeA and lowNodeB are String
09:48:25 <donri> linduxed: ok, then that won't work
09:48:34 <sepp2k> linduxed:  Well, it's one problem anyway... The body of a let-in needs to be an expression and foo = bar is no expression.
09:48:52 <linduxed> sepp2k: could you fork the gist and show what you mean with a new gist?
09:48:52 <donri> linduxed: you're saying you have a data constructor A that is the value of lowNodeA
09:49:09 <linduxed> donri: yeah, i need to fix the capitalized names
09:49:12 <linduxed> donri: just a sec
09:49:12 <Taneb> ghci> execState (_1 <~ liftM (uncurry mappend) get >> _2 <~ liftM (uncurry mappend <<< second invert) get >> _1 <~ liftM (uncurry mappend <<< first invert) get) (Sum 1, Sum 2)
09:49:12 <Taneb> (Sum {getSum = -2},Sum {getSum = 1})
09:50:24 <donri> linduxed: just lowercase a and b, move all bindings (the things with a =) to the where and drop the whole let thing
09:50:49 <donri> linduxed: then you need an actual expression that the where belongs to
09:51:03 <donri> linduxed: what do you actually want to return?
09:51:15 <elliott> Taneb: yikes
09:51:31 <elliott> :t (<~)
09:51:33 <lambdabot> MonadState s m => ASetter s s a b -> m b -> m ()
09:51:34 <elliott> oh, right.
09:51:38 <Taneb> elliott, I love being me. I can do ridiculous things like that and not care
09:51:42 * hackagebot simplex 0.3.3 - A simple markup language that translates to LaTeX  http://hackage.haskell.org/package/simplex-0.3.3 (JulianFleischer)
09:52:32 <linduxed> donri: but the problem is that i want to use the stuff under the where and the "d" function in both edgeADistance AND edgeBDistance
09:52:47 <donri> linduxed: so?
09:52:52 <linduxed> donri: if i don't use a let-in i'll have to define the "d" function two times
09:52:55 <elliott> oh, I was expecting that to be simplex noise.
09:52:56 <linduxed> with where
09:53:03 <donri> linduxed: binding order doesn't matter in haskell
09:53:20 <linduxed> lemme see if i can make this work then
09:53:42 <donri> > let b = a; a = "see" in b
09:53:44 <lambdabot>   "see"
09:54:19 <`ramses> :t let a = b; b = a in b
09:54:21 <lambdabot> t
09:54:22 <donri> note that i keep saying "bindings" because = isn't assignment in haskell
09:54:23 <DanBurton> a group of bindings has no particular order
09:54:45 <DanBurton> but nested bindings do impose order
09:55:19 <linduxed> basically, this is the ugly as fuck result i want https://gist.github.com/5247061
09:55:32 <linduxed> that functionality, but not as horrible
09:55:35 <DanBurton> > let b = "yep" in let a = b in let b = "nope" in a
09:55:37 <lambdabot>   "yep"
09:56:07 <sepp2k> linduxed: You need to define d twice either way. The only ways you wouldn't have to define it twice, would be to make it global. You can't have local variables across multiple global functions.
09:56:25 <linduxed> sepp2k: hmmm, ok
09:56:38 <donri> linduxed: ah. i would suggest making a private top-level function helper for making the edge functions
09:56:40 <linduxed> sepp2k: well, i guess i'll extract the "d" then
09:57:09 <linduxed> that was my idea, why i used the let-in
09:57:19 <sepp2k> Well, I supposed you could do something  (f,g) = let d = ... in (\x -> body_of_f, \x -> body_of_g) ... But don't.
09:57:20 <DanBurton> "you can't have local variables across multiple global functions" - but it'd be nice
09:57:36 <DanBurton> Isn't there an extension for that or something?
09:57:37 <linduxed> since both edgeXDistance share that "d" function, i wanted them to use that
09:57:54 <linduxed> actually... they share all except what's written before the where
09:58:03 <sepp2k> linduxed: That's not how let-in works though. It goes inside a function definition (or anywhere else where an expression is expected) - not around it.
09:58:16 <linduxed> sepp2k: aaah, i see
09:58:28 <linduxed> sepp2k: i take it there's no such construct?
09:58:44 <donri> linduxed: you could also make all bindings top-level and then hide them from being exported. maybe make the names longer than "d" then
09:59:01 <sepp2k> linduxed: No, there isn't.
09:59:07 <linduxed> donri: yeah, that's what i gathered from this discussion, i think i'll have to do it that way
09:59:24 <donri> linduxed: but i suspect you could make a makeEdgeFunction function somehow ...
09:59:41 <sepp2k> SML has local ... in ... for this, but Haskell has no equivalent of that.
09:59:50 <linduxed> yeah, i've already got a lot of code here that i could tweak into something like that
10:00:05 <linduxed> sepp2k: SML?
10:00:32 <hpaste> DanBurton pasted “Shared globals, sort of” at http://hpaste.org/84686
10:00:55 <donri> oh right you can pattern match in the top-level
10:01:00 <donri> i keep forgetting that trick :)
10:01:09 <sepp2k> linduxed:  Standard ML. It's a functional programming language.
10:01:09 <monochrom> SML is another functional language
10:01:15 <linduxed> sepp2k: oooh
10:01:26 <donri> linduxed: see DanBurton's hpaste
10:01:28 <linduxed> i know about ML, haven't heard it being called SML
10:01:38 <DanBurton> not the prettiest way to do things
10:01:45 <geekosaur> ML is a family of languages
10:01:49 <c_wraith> linduxed: ML is a family of languages.  SML is one of the specific implementations
10:01:50 <geekosaur> SML is a member of that family
10:01:59 <DanBurton> if it were me, I'd just make the shared function an un-exported global
10:02:05 <mikurubeam> c_wraith: I thought SML was defined by a standard, having multiple implementations.
10:02:16 <mikurubeam> s/having/and had/
10:02:34 <geekosaur> how would that contradict him?
10:02:39 <monochrom> that statement is also true, and there is no contradiction.
10:03:04 <geekosaur> OCaml is also a member of the ML family but is not SML and not strictly SML standard compliant
10:03:27 <mikurubeam> geekosaur: monochrom: If anything, the choice of the word "implementation" in "SML is one of the specific implementations" is rather unfortunate.
10:04:09 <geekosaur> mikurubeam, that is why I did not use "implementation" (c_wraith did, and yes, I disagree with that usage)
10:04:39 <monochrom> oh, that's why
10:05:07 <hpaste> DanBurton pasted “Shared portions of computation via continuations” at http://hpaste.org/84687
10:05:16 <linduxed> DanBurton: donri: that looks interesting, didn't think of that. but yeah, it's not the prettiest
10:05:17 * monochrom has an error-correcting modem and overlooked that error
10:05:44 <hpaste> DanBurton revised “Shared portions of computation via continuations”: “*” at http://hpaste.org/84687
10:06:10 <geekosaur> that said, I think there *is* a reference SML implementation. it is not the only such implementation
10:06:42 * hackagebot cipher-aes128 0.2.5 - AES128 using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.2.5 (ThomasDuBuisson)
10:06:44 <c_wraith> ah, true.  I was thinking SML/NJ, specifically.
10:06:53 <c_wraith> that one is an implementation.
10:08:07 <gspr> Where does one typically begin to chase down the reason GHC segfaults? It's probably my own fault, due to an unsafePerformIO, but I'm having a hard time both reproducing and debugging it. The unsafePerformIO block is only a few lines, but it would really help if I could get more out of GHC than just a segfault
10:08:23 <bitonic> gspr: GHC or a binary produced by GHC?
10:08:34 <gspr> bitonic: Sorry, yes, a binary produced by ghc
10:08:37 <gspr> my bad
10:08:48 <bitonic> well, there’s always gdb :P
10:09:01 <xenoxaos> anyone have any experience building GHC on ARM(v5/v6/v7)?
10:09:09 <gspr> bitonic: hehe, yeah, I guess
10:09:51 <bitonic> gspr: but that’s not very useful (still better than nothing).  I’m not sure if there are better ways...
10:10:37 <bitonic> gspr: apparently GHC devs do that routinely, <http://hackage.haskell.org/trac/ghc/wiki/Debugging/CompiledCode?redirectedfrom=DebuggingGhcCrashes>.  nice.
10:11:00 <bitonic> gspr: I would stare at the code a long time before going there
10:11:49 <gspr> bitonic: The following should be safe inside an unsafePerformIO, right? mallocForeignPtrArray (with the right size), withForeignPtr on that ForeignPtr to get a Ptr I pass to C, which fills the right number of elements, and then unsafeFromForeignPtr0 to get a storable vector, which is returned.
10:13:57 <gspr> If I compile with the threaded runtime, I get a "strange closure type 44" (just found out), without the threaded runtime I simply segfault
10:14:09 <bitonic> gspr: it *looks* OK.  I suppose you are taking the right precautions with ‘unsafePerformIO’, NOINLINE etc.
10:14:34 <amiller> re: adjunctions and monads, i'm working on understanding this stackexchange post now http://stackoverflow.com/questions/4697320/monads-as-adjunctions
10:14:41 <amiller> it seems pretty on target
10:14:54 <gspr> bitonic: yeah I think I am... I better just go stare at the code some more
10:14:57 <c_wraith> gspr: storable immutable vector, right?
10:15:01 <gspr> c_wraith: Yes
10:15:08 <linduxed> ok so i went from this https://gist.github.com/linduxed/5247061 to this https://gist.github.com/linduxed/5247223
10:15:25 <linduxed> apart from the reduntant parentheses, it's still... weird
10:15:26 <c_wraith> gspr: then it doesn't even need to be marked NOINLINE - if that's inlined and duplicated, that's not incorrect.
10:15:52 <linduxed> i also dropped the A = lowNodeA because that looked ugly when extracted
10:15:57 <gspr> bitonic: Fun part is, if I add a print inside the unsafe block (just for the fun of it), the code works. So I have a hunch that it has to do with timing -- my ForeignPtr being collected or something
10:16:24 <jfischoff> does anyone know of some example code using STM's TArray?
10:16:36 <bitonic> gspr: well, try to use simple Ptrs without collecting them
10:16:48 <gspr> c_wraith: That was my impression as well, but I've tried both with and without NOINLINE
10:16:53 <gspr> bitonic: Good idea!
10:17:04 <bitonic> gspr: maybe the ForeignPtr gets collected while the C code is still using it?
10:17:28 <c_wraith> the ForeignPtr shouldn't be collected with an unsafeFromForeignPtr call pending
10:17:36 <scooty-puff-sr> if a monad transformer that may be used over IO and over ST is specialized for ST, will IO kind of happen automatically (since they are both similar in structure)?
10:17:39 <gspr> bitonic: But it's inside withForeignPtr
10:17:41 <c_wraith> But..  It still sounds worth investigating
10:17:51 <scooty-puff-sr> (specialized == use of SPECIALIZE)
10:18:19 <Hermit> amiller: are you trying to understand what was asked in that stackoverflow post?
10:18:27 <c_wraith> scooty-puff-sr: use of the SPECIALIZE pragma doesn't affect any other type being used, even if it's just a different newtype wrapper over the same underlying type
10:18:28 <Hermit> amiller: or something along the topic?
10:18:44 <amiller> Hermit, i'm most of all trying to understand how about doing the 'adjunction' implementation of call by push value
10:18:47 <scooty-puff-sr> c_wraith: k - exactly what i needed - thanks
10:18:49 <bitonic> gspr: yeah, it should be fine, unless the C code does something funky
10:18:53 <amiller> i'm sort of familiar with implementing semantics using state monad
10:19:07 <gspr> (By the way: Do any of you think there's any significance to the fact that the threaded runtime gives "strange closure type 44" while the unthreaded one simply segfaults?)
10:19:58 <bitonic> gspr: I don’t know what that means, but it could be 1) timing issues 2) the RTS setting up things that interfere with what’s going on 3) both
10:20:12 <Hermit> amiller: I see, I thought for a second you were trying to figure out how were monads derived from adjoints
10:20:27 <amiller> well i do wish to see how monads are derived from adjoints
10:20:37 <amiller> and in particular the state monad is what i understand the best so fortunately that's the example in scope here :o
10:20:39 <gspr> bitonic: Makes sense
10:23:36 <Hermit> amiller: well, it's actually pretty simple to derive monads from adjoints. Are you in for the trip?
10:23:49 * amiller buckles up
10:24:28 <amiller> i remember from the cbpv paper that the adjoint decomposition of state monad is like this
10:24:28 <amiller> type State s = Compose ((->) s) ((,) s)
10:24:40 <amiller> then we have    unit x = \y -> (y, x)
10:24:45 <amiller>     counit (x, f) = f x
10:24:54 <Hermit> amiller: I was going to avoid going into code
10:25:14 <amiller> and that's roughly functor f, g => class Adjoint f g where      counit :: f (g a) -> a    and      unit   :: a -> g (f a)
10:25:25 <amiller> ah okay well in either case i think you're about to talk about going in the other direction
10:25:41 <Hermit> so, not what you wanted
10:26:00 <amiller> ah, no, go on, i hope to understand both ways
10:26:31 <amiller> (what i just pasted is my toehold of current understanding)
10:27:10 <Hermit> amiller: ok, suppose you have two functors, F and G. F goes from cat C to D, and F goes the other way around.
10:29:19 <Hermit> F and G can relate in 3 ways:  1. X and G (F X) are unrelated  2. X and G (F X) are the same object  3. they are adjoint, meaning X an G (F X) are not the same object, but related
10:30:58 <jbracker> I have a space leak in the code above, but I don't know where it comes from: http://hpaste.org/84685
10:31:00 <jbracker> When I parse this file "http://people.eecs.ku.edu/~jerzy/data/common_combined_lers.d" with the scanner my memory usage is between 1,5 and 2GB and I don't see why that is the case
10:31:33 <Hermit> amiller: this relation means you can map any X to G (F X), which gives you  G (F (G (F X))) and turn it back to G (F X) which is category's join
10:31:43 * hackagebot dead-simple-json 0.1.2 - Dead simple JSON parser, with some Template Haskell sugar.  http://hackage.haskell.org/package/dead-simple-json-0.1.2 (JulianFleischer)
10:32:17 <amiller> ok i recognize that as join for Monad M where M = G ◦ F
10:32:25 <Hermit> amiller: mapping X to G (F X) is return, and G F is M (monad), and you are done
10:32:39 <Hermit> amiller: yep, that's it, no big deal
10:32:52 <amiller> can you show me how that join identity follows from the adjoint laws?
10:33:01 <amiller> (which i don't know how to express in terms of the haskell adjoint class)
10:35:52 * Hermit scratches head
10:41:39 <johnw> amiller: you mean, how GFGF(x) -> GF(x)?
10:41:53 <johnw> the adjunction provides a natural transformation FG->I
10:42:00 <johnw> which is used to "drop out the middle" from GFGF
10:42:23 <johnw> this is the "counit" transformation
10:42:36 <amiller> how would i write the rule that gives me FG -> I from the adjoint
10:42:50 <johnw> what do you mean?  It's a requirement of adjunction
10:43:44 <johnw> in fact, so long as you have:
10:43:45 <dolio> Depending on which definition you use, it's harder to see.
10:43:49 <johnw> class (Functor f, Functor g) ⇒ Adjunction f g where
10:43:49 <johnw>   η ∷ a → g (f a)               -- unit (natural transformation)
10:43:49 <johnw>   ε ∷ f (g a) → a               -- counit (natural transformation)
10:44:04 <johnw> you can implement both monad and comonad
10:44:23 * edwardk somehow remembers this presentation ;)
10:44:30 <johnw> edwardk: :)
10:44:36 <amiller> 1) can you write the law for me in terms of η here
10:44:42 <johnw> right before me to go into the dagobah tree and face my fears
10:44:44 <amiller> and 2) where'd you find that because it looks pretty
10:44:47 <johnw> you told me to*
10:44:58 <djahandarie> Down with unicode
10:45:00 <beaky> hello
10:45:04 <johnw> amiller: I wrote it, and what do you mean by "the law"?
10:45:08 <beaky> http://ideone.com/hcmhjz how do I prove that my code is correct?
10:45:22 <amiller> i suppose just that η is natural
10:45:32 <edwardk> amiller: If you start with the f a -> b     ~ a -> g b   representation, then pick a = g b     and you get f (g b) -> b   from one direction and     picking b = f a and you'd get   a -> g (f a) from the other
10:45:32 <amiller> am i right that that doesn't follow automatically from the type
10:45:34 <johnw> an adjunction between two functor is defined by having two functors and these two natural transformations
10:46:20 <edwardk> amiller: you start from the isomorphism between f a -> b  and a -> g b.. you can also encode it differently, but thats easiest at least in haskell.
10:46:50 <amiller> ok i think i could work that out.
10:47:12 <amiller> another question here, is it roughly right that these functors can only express endofunctors from Hask to Hask
10:47:24 <amiller> like they're required to provide id and map for any haskell type
10:47:25 <edwardk> e.g. given f a -> b is isomorphic to a -> g b, when a = g b you have f (g b) -> b is isomorphic to g b -> g b    use the identity morphism from g b -> g b to get f (g b) -> b
10:48:05 <amiller> if i were in agda/coq i could be more precise by providing a universe code for types and then provide a functor that need only be specified for the coded types
10:48:08 <tsinnema> edwardk, did you say earlier that you had some work on row polymorphism? can you say anything on how it's implemented?
10:48:11 <edwardk> amiller: depends on if you want this in general or permit 'f' to be a functor to/from another category
10:48:23 <edwardk> tsinnema: dolio can probably say more
10:48:43 <tsinnema> ok
10:49:00 <edwardk> baically we have an ad hoc solver for row-type constraints that uses a funny notion of 'disjunction constraints' as the only row type relation.
10:49:07 <djahandarie> Row polymorphism is teh hard
10:49:22 <edwardk> e.g. we have a constraint that looks like a <- (b,c,d)   which says that we can partition the fields of a into the sets b, c and d.
10:49:41 <edwardk> thats the only constraint we have added in our row type system
10:50:57 <edwardk> so with that a join looks something like join :: (a <- (d,e), b <- (e,f), c <- (d,e,f)) => Rel a -> Rel b -> Rel c -- where Rel is a type of database relations
10:51:02 <edwardk> for a natural join
10:51:43 * hackagebot strings 1.0.2 - Functions for working with strings, including Text, ByteString, etc.  http://hackage.haskell.org/package/strings-1.0.2 (JulianFleischer)
10:51:47 <edwardk> we use the disjointness constraints to permit unions of records with disjoint field sets, etc.
10:51:52 <tsinnema> i have during the past few days squiggled together some category theory for row polymorphism, which looks promising but i'm not yet completely sure it's going to work out. if it does, and if i actually learn some haskell, maybe i'll have eventually have a library for that :)
10:52:23 <edwardk> Our system is rather completely ad hoc, but it works pretty well and is inferable, which is a plus
10:52:51 <dolio> Sometimes it doesn't take 20 minutes to type check your program.
10:52:55 <edwardk> hah
10:52:59 <tsinnema> :)
10:53:18 <johnw> beaky: how do you mean?
10:53:19 <edwardk> yeah there are some.. unfortunate corner cases based on inference order that occasionally arise as it explodes the row types
10:53:42 <edwardk> i have full faith in dolio's ability to resolve them however. ;)
10:53:51 <dolio> I'm not really even sure they're corner cases.
10:53:55 <beaky> how do I prove that a haskell program has no logic errors?
10:54:05 <byorgey> middle-of-the-room cases?
10:54:14 <tsinnema> there are also explosions, hairy explosions, in the categories i have squiggled
10:54:21 <edwardk> byorgey: yeah
10:54:40 <edwardk> We have a lot of room for improvement in what we're doing
10:54:46 <dolio> It's just one of two ways of writing an expression is usually bad.
10:55:00 <dolio> f (g (h x)) is okay, (f . g . h) x never finishes.
10:55:02 <dolio> Stuff like that.
10:55:06 <edwardk> who needs (.) anyways?
10:55:09 <dolio> And the latter is preferable.
10:55:26 <johnw> beaky: if the types are correct, and the functions are both pure and total, the fact that it compiles should constitute proof
10:55:50 <johnw> making sure that the function is total is tricky part
10:55:58 <edwardk> That said, the current checker _is_ written in scala, so we'll see how bad it is in haskell ;)
10:56:12 <edwardk> (not that i expect it to change much)
10:56:34 <johnw> each time edwardk mentions Scala, I think of some Bizzaro Edwardk somewhere in another channel, writing obscure code that our edwardk undoes as fast as he can
10:56:41 <edwardk> hahahaha
10:56:43 * hackagebot miniball 0.1.0.1 - Bindings to Miniball, a smallest enclosing ball library  http://hackage.haskell.org/package/miniball-0.1.0.1 (GardSpreemann)
10:56:43 <beaky> ah thanks
10:56:45 * hackagebot som 4.0 - Self-Organising Maps  http://hackage.haskell.org/package/som-4.0 (AmyDeBuitleir)
10:56:47 <dolio> It'll be a much more elegant implementation of something that doesn't work well.
10:57:14 <djahandarie> Though when you have an elegant implementation it's easier to see what's going wrong and possibly how to fix it, though.
10:57:23 <S11001001> I hope so
10:57:36 <Shin-LaC> hey guys/girls
10:57:43 <djahandarie> S11001001, oh, you were that guy at Boston Haskell?
10:57:46 <beaky> Shin-LaC: helll
10:57:50 <beaky> hello*
10:57:53 <S11001001> djahandarie: yep
10:57:55 <dolio> Which guy?
10:57:59 <Shin-LaC> I want to learn haskell by making a small project with it
10:58:06 <Shin-LaC> but the project I had in mind involves graphs
10:58:20 <djahandarie> dolio, not sure actually. I just saw edwardk point to the other side of the room and say "S one zero one zero something"
10:58:24 <Shin-LaC> and it seems that haskell may not be that suitable to working with graphs...?
10:58:44 <edwardk> djahandarie: =)
10:58:52 <edwardk> djahandarie: he was at boston haskell the other day too
10:58:52 <djahandarie> Shin-LaC, graphs aren't the nicest thing to deal with using recursive types
10:59:12 <typoclass> djahandarie: well, "S one zero one" must be another guy, because our guy is S110something
10:59:24 <djahandarie> Haha
10:59:26 <Shin-LaC> should I change project? or should I take a different approach to learning haskell?
10:59:56 <djahandarie> Shin-LaC, projects are fine for learning. If you want something graph-like, you can do something with trees, which are fun to implement :)
11:00:09 <companion_cube> graphs are more complex than trees
11:00:24 <djahandarie> Not sure I'd say that
11:00:26 <typoclass> Shin-LaC: have you seen lyah? it's free
11:00:28 <typoclass> @where lyah
11:00:28 <lambdabot> http://www.learnyouahaskell.com/
11:00:52 <djahandarie> Ah well, off to class now, tata.
11:00:56 <Shin-LaC> typoclass: lyah looks like a _why-style thing, which is really not to my taste
11:01:00 <Shin-LaC> bye, djahandarie
11:01:26 <Shin-LaC> https://github.com/roman/HaskellKoans <- is this good?
11:01:30 <typoclass> Shin-LaC: that's true i suppose
11:04:26 <Shin-LaC> I guess I'll start with the koans for now
11:04:46 <typoclass> Shin-LaC: i'm not sure how those koans work. there's also 99 problems, and rwh
11:04:52 <typoclass> @google haskell 99 problems
11:04:55 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
11:04:55 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
11:04:55 <typoclass> @where rwh
11:04:55 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:05:23 <typoclass> Shin-LaC: rwh is maybe a little more for the intermediate learner. but have a look :-)
11:05:46 <Shin-LaC> what kind of learner am I?
11:07:49 <typoclass> Shin-LaC: i meant, if you're a complete beginner, rwh might be a bit too difficult. i suggest you have a look at it (it's free) and decide for yourself
11:08:00 <Shin-LaC> ok, thanks
11:08:11 <sproingie> rwh is very uneven.  LYAH has a more gradual approach.
11:11:14 <Shin-LaC> hm
11:11:29 <Shin-LaC> I have cabal in /usr/local/bin
11:11:43 <Shin-LaC> but it wants to work inside ~/.cabal
11:12:05 <Shin-LaC> but then, if I install cabal-install, I end up with ~/.cabal/bin/cabal
11:12:12 <Shin-LaC> should I put that on my path and ignore the global cabal?
11:12:34 <byorgey> yes, that's probably the best approach
11:12:51 <Shin-LaC> ok
11:13:19 <Shin-LaC> hm, I seem to have broken something by deleting ~/.cabal
11:13:54 <byorgey> Shin-LaC: broken what?
11:14:26 <Shin-LaC> There are files missing in the `Cabal-1.16.0.3' package
11:15:16 <Shin-LaC> I think I'll just reinstall everything
11:15:21 <byorgey> hmm, usually that would not be caused by deleting ~/.cabal
11:15:45 <Shin-LaC> yes, especially since ghc-pkg check says the broken packages are in /usr/local
11:15:50 <byorgey> but reinstalling everything may be the simplest/easiest solution
11:15:59 <Shin-LaC> probably it broken when I tried to do "sudo cabal install cabal-install"
11:16:15 <geekosaur> don't ue sudo with cabal intall
11:16:17 <byorgey> ahh, yes, that might do it
11:16:50 <dcoutts> you can use sudo with cabal for global installs, but you have to indicate that using --global
11:16:53 <otters> cabal install --global is what you want
11:16:56 <otters> ^
11:17:00 <Shin-LaC> aah, I see
11:17:18 <byorgey> even in that case it's better to do   cabal install --global --root-cmd=sudo
11:17:31 <dcoutts> oh byorgey beat me to it :-)
11:18:01 <byorgey> but, as a general rule, you shouldn't be doing  cabal install --global anyway, unless you know what you're doing and why you want that
11:18:11 <geekosaur> ^^
11:18:22 <geekosaur> lovely way to have to trash your entire haskell installation and start from scratch
11:18:25 <Shin-LaC> so I should work with my local cabal and leave the shared copy without updates
11:18:28 <Shin-LaC> ?
11:18:42 <byorgey> Shin-LaC: yes
11:18:46 <Shin-LaC> ok
11:19:21 <armlesshobo> you should install the package you want again only if necessary
11:20:06 <Shin-LaC> well, this started because, when trying to install something, I was told to do "cabal update"
11:20:14 <Shin-LaC> which told me to do "cabal install cabal-install"
11:20:22 <geekosaur> you don;t have to do that
11:20:32 <Shin-LaC> which didn't seem to have effect, because ~./cabal/bin was not in the path
11:20:38 <geekosaur> the cabal update, yes. the other is a suggesion, you don't need to fllow it
11:20:38 <robde> hello, in "learn you a haskell" there is an example which reverses words in a string: reverseWords = unwords . map reverse . words. shouldn’t it be reverseWords = unwords . map reverse $ words?
11:20:52 <geekosaur> robde, no
11:20:55 <Shin-LaC> oh, ok
11:21:03 <geekosaur> words is a function
11:21:24 <skp> is it possible to use #ifdef in Haskell programs?
11:21:29 <byorgey> skp: yes
11:21:36 <geekosaur> you are not applying unwords . map reverse to the function itself, which is what $ would mean there
11:21:38 <sipa> unwords . map reverse . words = \x -> unwords (map reverse (words x))
11:21:56 <skp> byorgey: and how can I -D them?
11:22:00 <sipa> unwords . map reverse $ words = unwords (map reverse words)
11:22:17 <DanBurton> skp: you can use #ifdef in anything, just run the C pre-processor on it. But yes, GHC and cabal have tools to help you use the CPP
11:22:31 <robde> geekosaur: but unwords . map reverse . words "hello world" in GHCi does not work.
11:22:32 <cschneid> Thank you to everybody in this channel who's helped me the last few days. I finished this problem I'm working on, 180ish lines of haskell that works :) More than I
11:22:33 <geekosaur> skp, pronably -optP-Dsomething
11:22:35 <cschneid> I've ever written
11:22:54 <byorgey> cschneid: congrats!
11:22:59 <geekosaur> robde, if you are doiung *that* instead of defining the function, you need to *add* a $ (or parenthesize)
11:23:00 <sipa> robde: (unwords . map reverse . words) "hello world"
11:23:16 <geekosaur> but you do not *replace* a dot with a $, that has a completely different meaning
11:23:26 <DanBurton> > (unwords . map reverse . words) "hello world"
11:23:29 <lambdabot>   "olleh dlrow"
11:23:47 <otters> :t traverse
11:23:48 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
11:23:50 <geekosaur> hm, ok, I see your confusion, you are imagining that you can pick up a definiton and drop it in place without parentheses and think it will be somehow sane
11:23:54 <robde> > unwords . map reverse $ words "hello world"
11:23:56 <lambdabot>   "olleh dlrow"
11:23:59 <geekosaur> which means you don't really understand haskell expressions yet
11:24:07 <otters> @instances Applicative
11:24:08 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
11:24:17 <sipa> robde: ok, so (\x -> unwords . map reverse $ words x) works
11:24:30 <geekosaur> yes, it works there, tjhat does not mean it would work the same in reverseWords = unwords . map reverse . words
11:24:42 <DanBurton> you can't do that in math either. x = 2 + 3, y = x * 4. y /= 2 + 3 * 4
11:25:03 <geekosaur> let me try explaining it this way: there is an implicit set of parentheses there
11:25:22 <geekosaur> so if you want to drop the expansion into another expresison you must add parentheses
11:25:41 <geekosaur> reverseWords x -- valid
11:25:50 <geekosaur> (unwords . map reverse . words) x -- valid
11:25:59 <geekosaur> unwords . map reverse . words x -- NOT correct
11:26:17 <geekosaur> does this make sense to you?
11:26:22 <otters> function application binds more tightly than operators
11:26:56 <sipa> because unwords . map reverse . words x is actually unwords . (map reverse) . (words x)
11:27:15 <notdan> Is there a way to generate an xml parser based on the XML schema?
11:27:27 <sipa> while you clearly intended x to be applied to reverseWords, not to be dropped somewhere inside its definition
11:27:30 <otters> $ kinda puts parentheses around both halves
11:27:40 <Shin-LaC> $ is a very low-priority application?
11:27:49 <otters> unwords . map reverse . words $ x is like (unwords . map reverse . words) (x)
11:28:03 <otters> I think $ is infixl 0 or something
11:28:09 <typoclass> Shin-LaC: yes, precisely
11:28:31 <Shin-LaC> cool
11:28:36 <otters> Shin-LaC: that's also why f $ g $ h $ x is frowned upon generally
11:29:01 <merijn> Shin-LaC: $ is the lowest you can get, that's its entire point ;)
11:29:12 <sproingie> yah hlint will tell you to turn it into f . g . h $ x
11:29:35 <robde> ok, that confuses me now: unwords . map reverse . words $ "hello world"
11:29:43 <Shin-LaC> so $ is right-associative?
11:29:51 <geekosaur> yes
11:29:54 <Shin-LaC> I see
11:30:10 <sproingie> robde: read compose chains right to left
11:30:31 <sproingie> take words of hello world, map reverse over it, then unwords the result of that
11:30:53 <merijn> robde: "unwords . map reverse . words $ "hello world"" => "unwords (map reverse (words "hello world"))"
11:31:31 <merijn> robde: Moving the words right of the $ doesn't affect the meaning, because you're still doing "words "hello world"" and then applying "unwords . map reverse" to the result
11:32:14 <robde> and why does unwords $ map reverse $ words "hello world" work?
11:32:36 <sipa> that's unwords (map reverse (words "hello world"))
11:32:37 <otters> unwords (map reverse (words "hello world"))
11:32:38 <otters> is what that is
11:32:38 <merijn> f $ x = f x
11:32:49 <sproingie> because it's basically the same idea expressed differently
11:32:56 <merijn> and "(f . g) x = f (g x)"
11:34:55 <sproingie> using the $ is essentually expanding the definition of the composition, in a very syntax-sugary way
11:35:35 <armlesshobo> > unwords $ map reverse $ words "hello world"
11:35:37 <lambdabot>   "olleh dlrow"
11:35:39 <sproingie> so there it doesn't matter.  but there is of course a big difference between "foo = bar . baz" and "foo = bar $ baz"
11:36:09 <sproingie> one is composing bar and baz, the other is applying bar with baz
11:44:22 <merijn> @ask mm_freak I was going over a netwire example you gave me some time ago and I see you're using sessionUpdate and stepWire to manually pass in the time. Is there reason for doing this instead of using stepSession?
11:44:22 <lambdabot> Consider it noted.
11:50:42 <mm_freak> merijn: yes, notice the monad arguments of Wire and Session
11:50:43 <lambdabot> mm_freak: You have 1 new message. '/msg lambdabot @messages' to read it.
11:50:47 <mm_freak> Wire e m a b, Session m
11:50:53 <mm_freak> Wire e m1 a b, Session m2
11:51:01 <mm_freak> when you use stepSession, then m1 = m2 is required
11:51:14 <mm_freak> this is often not what you want
11:53:18 <DarkLinkXXXX> How do I indent with ghci?
11:53:50 <geekosaur> generally we use braces instead, but see :{ (try :help)
11:54:32 <byorgey> DarkLinkXXXX: ghci isn't well-suited for entering lots of multi-line definitions.  Much easier is to put your definitions in a file and then load them into ghci with :load (and :r to reload after changing the file)
11:54:37 <typoclass> DarkLinkXXXX: ghci works best if you stick to one-liners. for longer code, you can always put it in a file and do ":load file.hs" (:l file.hs). after changes, you can do :r
11:56:14 <DarkLinkXXXX> Okay. Thanks.
12:33:50 <neurocyte> xenoxaos, I’ve built a GHC ARM cross compiler many times
12:34:20 <xenoxaos> will you be my new best friend?
12:34:23 <xenoxaos> :P
12:36:17 <xenoxaos> are you familiar with Arch Linux ARM neurocyte?
12:36:30 <neurocyte> xenoxaos, yes. I’m an arch linux user
12:45:01 <dEPY> any1 knows a good haskell talks I can watch? beginner friendly :D
12:46:57 * hackagebot easyplot 1.0 - A tiny plotting library, utilizes gnuplot for plotting.  http://hackage.haskell.org/package/easyplot-1.0 (JulianFleischer)
12:47:37 <edwardk> dEPY: http://www.youtube.com/feed/?feature=guide has a bunch of haskell talks (and a few scala talks mixed in). not sure how introductory it all is, but most of it was presented at Boston Haskell
12:47:42 <edwardk> er
12:47:44 <edwardk> derp
12:47:47 <edwardk> that didn't show my feed
12:47:55 <edwardk> http://www.youtube.com/user/edwardkmett
12:47:56 <edwardk> =)
12:48:34 <dEPY> thank you:)
12:48:58 <djahandarie> Oh, hah, copumpkins vids got up there huh
12:49:45 <djahandarie> And Spivak!
12:50:03 * djahandarie makes mental note to watch this stuff
12:53:47 <DMcGill> anybody here familiar with hmatrix?
12:54:25 <DMcGill> or OpenGl itself might have it. I need to rotate a vector, probably by making a rotation matrix.
12:54:56 <dockside1> can i set predicates on a type function somehow?
12:56:47 <eacameron> does this make sense? data Hash a = Eq a => Hash a VValue
12:57:36 <elliott> eacameron: not really
12:57:47 <elliott> you shouldn't put class constraints on data types, generally
12:57:53 <eacameron> why's that?
12:58:19 <koninkje> eacameron: they only matter for derived instances...
12:58:37 <koninkje> but also, they're being deprected form the language
12:58:49 <koninkje> er, s/form/from/
13:01:33 <eacameron> koninkje: ok...I'll get rid of it
13:01:34 <eacameron> thanks
13:02:43 <dockside1> So only through type classes can i get restrictions on parameterized types?
13:02:52 <dockside1> Well should I
13:03:15 <catbee> edwardk: you're here but not on #haskell-lens?  for shame
13:03:32 <edwardk> i'm in both
13:03:53 <catbee> ah sorry missed it
13:06:57 * hackagebot conduit 1.0.4.2 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.4.2 (MichaelSnoyman)
13:11:45 <byorgey> dockside1: right.
13:12:04 <johnw> byorgey!
13:12:33 <S11001001> @ty fix (\r -> liftA2 (++) id r)
13:12:35 <lambdabot> Monoid c => c -> c
13:12:46 <byorgey> hi johnw!
13:13:25 <S11001001> @ty fix . (++)
13:13:26 <lambdabot> Monoid b => b -> b
13:17:08 <otters> :t (<-->)
13:17:09 <lambdabot> parse error (possibly incorrect indentation)
13:18:26 <otters> okay I don't think I need cabal-dev's sandboxing features
13:18:36 <otters> but it is helpful to have it load package-wide language extensions and so on from the .cabal file
13:18:54 <otters> is there any alternative tool that does that?
13:19:08 <elliott> I think "cabal ghci" is a thing these days
13:19:16 <otters> i don't think it is
13:19:21 <otters> I have the latest cabal as far as I know
13:19:26 <johnw> there's just cabal-dev ghci
13:19:29 <otters> 1.16.0.2
13:19:39 <glguy> 1.16.0.3 is the latest I know of and it doesn't
13:20:05 <madjestic>  hey guys.  How do I find out what's the name of the source package of an imported module?
13:20:10 <elliott> maybe it's only in the dev version
13:20:13 <otters> hm
13:20:36 <glguy> Oh, .3 was from the Cabal  lib version
13:21:16 <glguy> madjestic: ghc-pkg --help says "  ghc-pkg find-module {module}"
13:21:23 <glguy> Does that do what you want?
13:23:13 <madjestic> glguy: yes it does, thank you
13:24:27 <Shin-LaC> I regret my decision to install ghc from source
13:25:34 <achernoff> does the Arrows library define anything equivalent to \f a b -> (uncurry f) ^<< (a &&& b) ?
13:25:54 <hpaste> dEPy pasted “my reverse” at http://hpaste.org/84693
13:26:04 <otters> :t \f a b -> (uncurry f) ^<< (a &&& b)
13:26:05 <dEPY> Any1 can explain why that doesn't work?
13:26:06 <lambdabot> Arrow a => (a1 -> b1 -> d) -> a b a1 -> a b b1 -> a b d
13:26:40 <napping> Shin-LaC: what's wrong?
13:27:17 <Shin-LaC> typoclass: in the 99 problems, should I use built-in stuff like reverse?
13:27:22 <otters> okay cabal 1.17 still doesn't have cabal ghci
13:27:27 <otters> does that command exist anywhere
13:27:29 <Shin-LaC> or should I do it all from scratch?
13:27:34 <Shin-LaC> napping: it just takes a long time to build
13:27:41 <Shin-LaC> so I'm stuck starting at a terminal for now
13:27:54 <Shin-LaC> is there an online haskell interpreter?
13:28:00 <napping> yeah, it does that. The binary packages from haskell.org work great for me
13:28:33 <napping> unless you're planning to work on GHC itself?
13:28:39 <armlesshobo> dEPY: what error are you getting?
13:29:01 <dEPY> armlesshobo: *** Exception: test99q1to10.hs:(5,1)-(7,43): Non-exhaustive patterns in function myRevers
13:29:01 <Shin-LaC> no
13:29:15 <armlesshobo> dEPY: you're not matching all patterns
13:29:16 <napping> yeah, then you might as well cancel it and grab a binary package
13:29:45 <dEPY> hm, what am I missing then? i check if it's empty and i check otherwise
13:29:48 <kadoban> Shin-LaC: codepad.org and ideone.com ?
13:30:04 <napping> Shin-LaC: either this http://www.haskell.org/ghc/download_ghc_7_6_2 or the platform release
13:30:32 <latro`a> dEPY, the match at the top will only match if the list isn't empty
13:30:58 <latro`a> as in, if you pass an empty list, it will not even get to the guard, instead it will just prompty fail to match any of the bindings
13:30:59 <armlesshobo> dEPY: the reason being that (x:xs) won't match (x:[])
13:31:10 <latro`a> no, (x:xs) will match (x:[])
13:31:12 <latro`a> it will not match []
13:31:16 <armlesshobo> right
13:31:19 <dEPY> aaaaa
13:31:21 <armlesshobo> i caught myself too late :\
13:31:37 <latro`a> generally you should pattern match rather than using predicates to the extent possible
13:31:59 <latro`a> for example it's generally better to do case xs of [] -> ...; (x:xs) -> ... rather than if null xs then ...
13:32:01 <napping> Shin-LaC: using a GHC that isn't in a platform release is probably bleeding-edge enough for most :)
13:32:15 <armlesshobo> dEPY: myReverse [] = []
13:32:58 <Shin-LaC> kadoban: thanks!
13:33:04 <dEPY> Already fixed! :) tnx all
13:33:13 <Shin-LaC> napping: I think I'll go with the platform release
13:33:29 <dEPY> Still fresh in this haskell business .)
13:34:03 <latro`a> by the way, once you get your reverse working you should work on how to make it O(n)
13:34:09 <latro`a> the naive implementation is O(n^2), which is terrible
13:35:06 <latro`a> (Data.List's reverse is O(n))
13:36:24 <dEPY> latro`a: is it O(n^2) because ++ is looping trough the whole list or?
13:36:41 <latro`a> each ++ is O(m) where m is the length of the left hand side
13:36:54 <latro`a> this means the whole thing takes sum(m=1 to n) m, which is O(m^2)
13:37:15 <johnw> so foldr (flip (++) . return) [] "Hello" is O(n^2)?
13:37:36 <latro`a> I'd have to expand it, but I believe so, yes
13:38:04 <armlesshobo> how come I doubt this?
13:38:09 <johnw> then foldl' (flip (:)) [] "Hello" would be O(n)
13:38:24 <latro`a> which is exactly what GHC does
13:38:30 <dEPY> cool :)
13:38:34 <latro`a> except just foldl, so that it has the right semantics with, say, [undefined,undefined,1]
13:38:42 <johnw> ah
13:39:15 <armlesshobo> latro`a: how is it O(n^2)? what am i missing?
13:39:19 <johnw> in ghci, foldl and foldl' behave the same if undefined is used
13:39:23 <cschneid> naming question:   foo' typically means - "strict" in the stdlib, yes?  foo_ means "ignoring the result".  Any other common naming schemes?
13:39:41 <johnw> cschneid: M means monadic, A applicative,
13:39:43 <latro`a> armless, it's not hard to prove that sum(m=1 to n) m = m(m+1)/2
13:39:48 <johnw> a prefixed 'g' is generic
13:39:49 <latro`a> occasionally A means arrow
13:40:11 <latro`a> and then the point is that to build xs ++ ys, you have to make new cons cells for each element of xs
13:40:13 <cschneid> mapM for instance, the M is monad. not sure I've run across applicative?
13:40:17 <johnw> a 1 means it assume the starting case for a fold
13:40:27 <johnw> traverse is the applicative of mapM
13:40:44 <armlesshobo> latro`a: that makes sense now.
13:40:53 <armlesshobo> latro`a: didn't realize it did that
13:41:57 <jfischoff> ++latro`a
13:42:37 <cschneid> is there a good resource for "hey, so you want to learn applicative, here's a real use case, and why it helps, where boring functors fails"
13:42:37 <latro`a> gah
13:42:38 <latro`a> typo
13:42:46 <latro`a> sum(m=1 to n) m = n(n+1)/2
13:42:49 <cschneid> as opposed to the wikibooks one I'm reading which is "here are math laws."
13:42:54 <latro`a> what I wrote before made no sense
13:43:23 <latro`a> one of the nice things applicative can do that functor can't is liftA2, liftA3, etc.
13:43:46 <jfischoff> cschneid: and unlike monad you can compose them
13:44:46 <latro`a> if f is a Functor and you have g :: (a->b->c) and x :: f a, then fmap g x :: f (b->c)
13:45:11 <latro`a> you can do this with just a functor
13:45:46 <latro`a> what you tend to want to do afterward is apply these to another value of type f b; an example use case is applying a function to every pair of elements of two lists
13:45:46 <cschneid> yeah, that's pretty technical. I've had good luck learning with actual "so you're in this spot, here's how this tool gets you from a to b"
13:46:13 <dmwit> cschneid: Here's one: I want to write a parser for expressions.
13:46:24 <dmwit> cschneid: I've got a parser for parenthesized expressions, call it "parens".
13:46:32 <cschneid> ok
13:46:45 <dmwit> cschneid: My grammar is a pretty crappy one: all expressions are fully parenthesized. So E = P op P or so
13:46:54 <dmwit> Let's say I have a parser for operators, to, call it "op".
13:47:12 <dmwit> With Applicative, my parser for expressions is
13:47:12 <cschneid> yep
13:47:28 <dmwit> expr = BinOp <$> parens <*> op <*> parens
13:47:32 <dmwit> Doesn't look too bad, right? =)
13:47:57 <cschneid> is applicative always (nearly?) <$> followed by <*>s?
13:48:10 <dmwit> No, though that's a very, very common pattern.
13:48:19 <ab9rf> you might find <|> instead
13:48:25 <dmwit> In fact, the guys before were hinting at it with liftA3 and friends, e.g.
13:48:34 <dmwit> expr = liftA3 BinOp parens op parens -- another spelling of expr
13:48:50 <jfischoff> <|> for Alternative the Applicative Monoid
13:49:02 <ion> integer :: Parser Integer; integer = negation <*> natural; negation :: Parser (Integer -> Integer); negation = negate <$ char '-' <|> pure id
13:49:29 <jfischoff> it might be worth pointing out that you can do <$> and <*> with Monad too
13:49:45 * dmwit awaits the "why is Applicative a worthwhile class when we've already got Monad" question
13:49:54 <cschneid> dmwit: without applicative, how would I write expr. Is it possible and ugly, or not possible
13:49:55 <johnw> why is Applicative a worthwhile class when we've already got Monad?
13:50:30 <latro`a> the simplest example of an Applicative instance that has no compatible Monad instance is the one where liftAn is zipWithn
13:50:31 <johnw> a <$> b <*> c == a `liftM` b `ap` c
13:50:37 <latro`a> *simplest nontrivial
13:50:38 <dmwit> cschneid: That's a trick question. If your parser library provides operations that had the behavior of (<$>) or (<*>), but not the right names, you'd use those.
13:50:39 <johnw> translating applicative into monad
13:51:03 <dmwit> cschneid: If the library didn't provide those, well... it's impossible to say how to write it without knowing the rest of the library's interface, I guess!
13:51:07 <tomejaguar> latro`a: Is there a trivial instance that has no compatible Monad instance?
13:51:23 <johnw> also, MonadApply will turn any Monad into an Applicative, if it isn't already
13:51:30 <latro`a> probably, though I can't think of one off the top of my head
13:51:48 <tomejaguar> What would that even mean?
13:51:58 <dEPY> If I have this:  data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)
13:51:59 <ion> tomejaguar: Map
13:52:07 <ion> err, sorry
13:52:08 <dEPY> Is there an easy way to write a 'head' function?
13:52:11 <ion> ZipList
13:52:11 <johnw> tomejaguar: sure, take an Applicative Writer for instance which accumulates all errors, whereas a Monadic Writer stops at the first error
13:52:15 <jfischoff> latro`a: Compose?
13:52:21 <dmwit> tomejaguar: I bet there's a free Applicative. That would be pretty trivial in some sense of the word, but not monadic.
13:52:22 <latro`a> ion, that was my example, which I was considering to be nontrivial
13:52:40 <ion> Map k can be a functor but not an Applicative. ZipList (of unrestricted size) can be Applicative but not Monad.
13:52:52 <latro`a> but the point of it is that you'd only have an Applicative instance if <*> could be defined as ap
13:52:53 <tomejaguar> Yes I don't think any of those are trivial in the sense that latro`a (or at least the sense that I interpreted it)
13:53:06 <latro`a> @src ap
13:53:06 <lambdabot> ap = liftM2 id
13:53:10 <cschneid> I suppose last question: when do I know to reach for fancier parts of haskell as a newbie learning
13:53:25 <latro`a> (bah, would've been nice to see the expanded form)
13:53:28 <latro`a> @src liftM2
13:53:28 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:53:37 <johnw> cschneid: when you can't get it done another way :)
13:53:42 <Saizan> johnw: i thibk you mean Either
13:53:58 <ion> mf `ap` ma = do { f <- mf; a <- ma; return (f a) }
13:54:04 <johnw> Saizan: did I?  I guses so
13:54:16 <cschneid> Does your typical code end up mostly advanced concepts, or a ton of basic functions tied together with a few of these more advanced concepts?
13:54:22 <armlesshobo> > liftM2 (+) (Just 4) (Just 7)
13:54:24 <lambdabot>   Just 11
13:54:35 <armlesshobo> > fromMaybe $ liftM2 (+) (Just 4) (Just 7)
13:54:37 <lambdabot>   No instance for (GHC.Show.Show
13:54:37 <lambdabot>                     (Data.Maybe.Maybe (Data....
13:54:37 <johnw> cschneid: higher-order functions are the most used concept
13:54:41 <latro`a> (actually, how do you do this proof, I don't remember)
13:54:45 <armlesshobo> from Just
13:54:46 <armlesshobo> lol
13:54:47 <dmwit> cschneid: *my* code ends up with only a few advanced concepts. Now, edwardk on the other hand (for example)...
13:54:53 <armlesshobo> > fromJust $ liftM2 (+) (Just 4) (Just 7)
13:54:55 <lambdabot>   can't find file: L.hs
13:55:01 <ion> fromJust is evil.
13:55:08 <armlesshobo> >:D
13:55:31 <cschneid> > liftM2 (+) (Just 4) (Nothing)
13:55:33 <Saizan> johnw: the Writer monad has no problems accumulating as much as the applicative can
13:55:33 <lambdabot>   Nothing
13:55:34 <johnw> use fromMaybe, not fromJust
13:55:44 <johnw> Saizan: ah, thanks, I did mess those up
13:55:49 <cschneid> > liftM2 (+) (Just 4) (Just 5) (Just 6)
13:55:51 <lambdabot>   Couldn't match expected type `t0 -> r0'
13:55:51 <lambdabot>              with actual type `Data...
13:55:59 <johnw> that won't work, cschneid
13:56:10 <cschneid> right, the 2 says two args
13:56:12 <johnw> > liftM3 (,,) (Just 4) (Just 5) (Just 6)
13:56:14 <lambdabot>   Just (4,5,6)
13:56:15 <armlesshobo> > liftM3 (+) (Just 6) (Just 4) (Just 7)
13:56:16 <lambdabot>   Could not deduce (GHC.Num.Num (a30 -> r))
13:56:16 <lambdabot>    arising from the ambiguity che...
13:56:19 <johnw> and + only takes 2 args
13:56:29 <cschneid> ahh, sure.
13:56:44 <dmwit> > liftM3 (\x y z -> x + y + z) (Just 6) (Just 4) (Just 7)
13:56:46 <lambdabot>   Just 17
13:57:08 <cschneid> if I had [Maybe Int], and wanted to fold over it to get the sum?
13:57:18 <johnw> foldMap
13:57:23 <dmwit> :t sequence
13:57:24 <jfischoff>  > liftA3 (\x y z -> x + y + z) (Just 6) (Just 4) (Just 7)
13:57:24 <lambdabot> Monad m => [m a] -> m [a]
13:57:35 <dmwit> :t liftM sum . sequence
13:57:36 <lambdabot> (Monad m, Num r) => [m r] -> m r
13:57:38 <johnw> getSum $ mconcat $ fmap (fmap Sum) xs
13:57:50 <johnw> getSum $ mconcat $ catMaybes $ fmap (fmap Sum) xs
13:57:56 <danharaj> edwardk: I have a weird type error with lens I cannot make sense of.
13:58:01 <danharaj> http://hpaste.org/84694
13:58:07 <dmwit> johnw: Oh, well, if you're going to use catMaybes, it's just sum . catMaybes, then.
13:58:17 <johnw> heh, you are right
13:58:20 <dmwit> But catMaybes is cheating. =)
13:58:27 <johnw> oh, what was the challenge?
13:58:29 <danharaj> edwardk: false alarm I am an idiot
13:58:32 <Shin-LaC> how are you supposed to install the GHC bindists? can you just untag them anywhere?
13:58:33 <johnw> "do it without catMaybes"?
13:58:47 <cschneid> do it as the next step using similar concepts.... so I can figure stuff out
13:58:49 <Shin-LaC> *untar
13:58:50 <dmwit> Shin-LaC: Yes, untar them and run ./configure && make && make install
13:58:56 <cschneid> I understand there are shorter / easier ways to do many things
13:58:59 <johnw> oh, I see
13:59:02 <Shin-LaC> ok, I'll try that
13:59:06 <johnw> you want to generalize what liftM2 is doing
13:59:14 <cschneid> right. one step further than that :)
13:59:38 <dmwit> cschneid: (in case you missed my serious answer: sequence)
13:59:40 <cschneid> something (+) [Just 1, Just 2, Just 3, Just 4]
13:59:52 <cschneid> > sequence (+) [Just 1, Just 2, Just 3, Just 4]
13:59:54 <lambdabot>   Couldn't match expected type `[t0 -> a0]'
13:59:54 <lambdabot>              with actual type `a1...
13:59:57 <dmwit> > sequence [Just 1, Just 2, Just 3, Just 4]
13:59:59 <lambdabot>   Just [1,2,3,4]
14:00:08 <dmwit> > sum <$> sequence [Just 1, Just 2, Just 3, Just 4]
14:00:10 <lambdabot>   Just 10
14:00:45 <dmwit> > sum `liftM` sequence [Just 1, Just 2, Just 3, Just 4] -- if you prefer only Monad-y operations
14:00:47 <lambdabot>   Just 10
14:00:51 <cschneid> :t sequence
14:00:53 <lambdabot> Monad m => [m a] -> m [a]
14:01:02 <cschneid> ahh I see. hmm
14:01:05 <johnw> > foldM (\acc x -> (acc+) <$> x) 0 [Just 2, Just 3]
14:01:07 <lambdabot>   Just 5
14:01:23 <glguy> What's the fancy sum function supposed to do when it sees a nothing?
14:01:32 <cschneid> liftM is turning sum into something that works on Maybes?
14:01:36 <johnw> > foldM (liftM . (+)) 0 [Just 2, Just 3]
14:01:38 <lambdabot>   Just 5
14:01:47 <johnw> > foldM (liftM . (+)) 0 [Just 2, Just 3, Just 4, Just 5, Just 6]
14:01:49 <lambdabot>   Just 20
14:01:52 <dmwit> glguy: Oh, good question. I just assumed, since this was a continuation of the liftM2, liftM3 discussion...
14:01:57 <johnw> that's your generalized liftM*
14:02:02 <dmwit> cschneid: yes
14:02:08 <jfischoff> :t liftM sum
14:02:08 <dmwit> :t liftM
14:02:09 <lambdabot> (Monad m, Num r) => m [r] -> m r
14:02:09 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
14:02:24 <dmwit> liftM :: Monad m => (a -> b) -> (m a -> m b)
14:02:41 <cschneid> cool
14:02:44 <glguy> dmwit: I was just asking because people were using catMabyes at one point
14:02:48 <dmwit> cschneid: In case you missed glguy's question...
14:02:58 <cschneid> sure. I know that's an undefined corner./
14:03:05 <cschneid> "is it 0, or is it blow-up-entire-calc"
14:03:10 <dmwit> right
14:03:14 <johnw> glguy: giving the semantics of liftM and Maybe, the result should be Nothing
14:03:26 <johnw> > foldM (liftM . (+)) 0 [Just 2, Just 3, Nothing, Just 4, Just 5, Just 6]
14:03:28 <lambdabot>   Nothing
14:03:41 <cschneid> > catMaybes [Just 1, Just 2]
14:03:43 <lambdabot>   [1,2]
14:03:47 <cschneid> > catMaybes [Just 1, Nothing]
14:03:49 <lambdabot>   [1]
14:04:18 <johnw> see, very different behavior
14:04:35 <dmwit> > getSum . foldMap Sum $ [Just 1, Just 2, Just 3]
14:04:37 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a0))
14:04:37 <lambdabot>    arising from a use o...
14:04:39 <cschneid> > sum $ catMaybes [Just 1, Nothing]
14:04:41 <lambdabot>   1
14:04:59 <dmwit> oh rite
14:05:03 <cschneid> fun times. I understand more.
14:05:09 <cschneid> and I should probably write ruby code that I get paid for.
14:05:18 <cschneid> thanks a bunch of for the lesson guys!~
14:06:47 <diphtherial> hello; i realize this is kind of a silly question, but do any of you have recommendations for a nice graphics library for the absolute beginner?
14:06:58 <diphtherial> (on windows x64, if that makes a difference)
14:06:58 * hackagebot gloss-juicy 0.1.1 - Load any image supported by Juicy.Pixels in your gloss application  http://hackage.haskell.org/package/gloss-juicy-0.1.1 (AlpMestanogullari)
14:07:22 <diphtherial> seems that gloss is a good choice..?
14:08:22 <scooty-puff-sr> i'm having a problem with SPECIALIZE - if i specialize for a newtype wrapper around a parameterized "m", called with IO (called it Wrapped IO), specialize does not appear to happen - however, if i use IO directly in the SPECIALIZE, there are no problems (though it could be something other than the specialization - perhaps inlining..)
14:08:40 <sproingie> diphtherial: gloss is being used to teach kids, so i suppose it's good for starting out
14:08:54 <scooty-puff-sr> is SPECIALIZE known to be hit or miss with sufficiently complicated type constructors?
14:09:25 <scooty-puff-sr> (i do not have a simple example now, but could post what i have)
14:09:34 <edwardk> danharaj: looking.
14:09:40 <edwardk> danharaj: idiot status confirmed ;)
14:10:03 * glguy has used gloss to make a multi-player hide-in-plain-sight clone and a multi-player boardgame (both networked). It's pretty easy to use as long as all you want it to do is what it already does :)
14:10:33 <edwardk> dmwit: its no fun if you only use one advanced concept. someone might be able to follow along. You have to use every concept you know. Then when someone is able to follow along you know they are smarter than you and that you can learn from them.
14:11:13 <danharaj> edwardk: and once you have learned all you can, you toss them aside and look for you next victi- I mean mentor.
14:11:14 <tdammers> edwardk: that never works for me. people never understand.
14:11:25 <diphtherial> glguy: sounds reasonable, then :) as long as i can draw primitives on the screen i think i'll be happy
14:11:34 <luite> glguy: do you have the source for that somewhere? I'm still looking for examples of things to compile wiht ghcjs as examples
14:11:43 <tdammers> although that could also be attributed to my own self-explanation skills
14:11:44 <edwardk> danharaj: My usual interview tactic is to drill until I find where someone's knowledge stops, and if I learn something they are a good candidate for hiring ;)
14:12:49 <danharaj> edwardk: I think you would strike oil within 30 seconds if you interviewed me :3
14:13:17 <glguy> luite: I don't know anything about ghcjs, but https://github.com/glguy/Ninjas https://github.com/glguy/Yinsh (and one or both use https://github.com/glguy/networked-game to do the networking )
14:14:01 <glguy> If anyone wants to play a game of Ninjas, let me know :)
14:14:50 <luite> glguy: tnx. it should support most of what the usual GHC does, except STM (but with threads, async exceptions, weak refs etc, so bytestring is no prob, vector also works, repa works but seems buggy, dunno where the bugs are)
14:15:17 <glguy> luite: Yinsh in the repository is single player, no networking, I think
14:15:19 <luite> adn when i figure out what kind of undocumented StableName behaviour it expects, reactive-banana also works
14:15:30 <glguy> (the networked version is in Iavor's repo, I think)
14:15:36 <glguy> that might be easier to test with
14:16:19 <luite> is it client/server or peer to peer?
14:16:28 <luite> since web apps can only communicate with the servr
14:16:37 <glguy> Ninjas is client/server (we've played up to 10 people)
14:17:26 <glguy> Yinsh is played between two people and one of the clients hosts the game directly, no external server
14:17:33 <glguy> (in the networked case)
14:17:43 <luite> ok all dependencies except gloss seem fine
14:18:02 <glguy> gloss is going to be important :)
14:18:17 <luite> that's the part that's going to be replaced by some canvas api :)
14:18:23 <glguy> I guess you could strip out gloss to just host a ninjas server
14:18:33 <glguy> but the client relies quite a bit on gloss
14:18:37 <tomejaguar> I'm on Debian and foolishly uninstalled the Deb of ghc.  I reinstalled but now /usr/lib/ghc/package.conf.d/package.cache is gone.  Can I recreate it somehow?
14:19:25 <geekosaur> sudo ghc-pkg recache
14:20:16 <tomejaguar> Yes!  Thank you geekosaur.
14:21:48 <luite> hmm, i wonder if it would be a good GSoC project to build a few similar networked games with ghcjs, documenting and writing required libs as they go. I can then help by optimizing and improving them compiler itself where necessary. problem is how to evaluate the project, the games themselves wouldn't be the most important thing
14:23:17 <luite> probably better to have something with a more well-defined goal
14:43:55 <hpaste> idntfy revised “Solve heat equation”: “Solve heat equation with six-point approximation scheme” at http://hpaste.org/83797
14:49:42 <gwern> suppose I want to parse out number from a String (a file), like turn "a mean of 112,000.3 (p<0.005)" into ["112,000.3","0.005"]. any thoughts on the easiest approach?
14:50:20 <mauke> perl
14:50:37 <sproingie> free-form?  regex i'd say
14:50:40 <gwern> mauke: I'm going to pretend you didn't say that.
14:50:46 <mauke> why?
14:50:53 <gwern> why what?
14:51:32 <mauke> [ $string =~ m{ \d+ (?: [.,] \d+ )* }xga ]
14:52:25 <gwern> sproingie: hm, i suppose so. I was thinking a primitive recursive function with a boolean flag - if the next character is not a digit, dot, or comma, drop it, return a newline, and recurse on the tail; else if it is, return the digit/dot/comma and recurse on the tail
14:53:08 <sproingie> sure or you could just express all that in a mini-language like a regex
14:53:14 <mauke> gwern: I'd rather use a high-level language
14:53:31 <gwern> sproingie: well, I'm not really familiar with regexes
14:53:45 <mauke> http://p3rl.org/perlretut
14:53:50 <sproingie> it's a pretty simple one.  i just dont recall the haskell api for it offhand
15:03:56 <quchen> The Haskell API for regex? I think it's along the lines of 'result = string =~ regex'.
15:04:01 <quchen> Plus imports.
15:04:10 <quchen> RWH has a chapter for it.
15:04:40 <quchen> But then if you're just looking for a small hack grep or whatever may be faster.
15:13:47 <aristid> @remember merijn So apparently there's a footballer named lens, who played some important part in the match against the Netherlands... Which would explain the fact that twitter is telling me "lens" is trending, I was starting to think haskell had won the PL revolution with edwardk as our glorious leader ;)
15:13:47 <lambdabot> Nice!
15:19:39 <labo> gwern: filter (/= "") . T.split (not . (`elem` "0123456789,.")
15:20:53 <gwern> labo: data.text?
15:22:19 <labo> :) yes
15:22:55 <gwern> not bad
15:22:56 <labo> substitue (/= "") for a better predicate to better match numbers
15:23:27 <gwern> seems to be a type mismatch in string types. overloadedstrings I'm guessing
15:26:52 <labo> correct, I also missed the final parenthesis in copy+paste
15:30:30 <gwern> '{-# LANGUAGE OverloadedStrings #-}; import Data.Text as T; main = interact (T.unpack . T.unlines . Prelude.filter (/="") . T.split (not . (`elem` "0123456789,.")) . T.pack)' <-- seems to work
15:42:48 <Shin-LaC> I have a question about the testsuite
15:43:24 <Shin-LaC> in the source distribution page, it says
15:43:25 <Shin-LaC> ghc-7.6.2-testsuite.tar.bz2 (2.8 MB). If you unpack this tarball on top of the above then you will be able to run the testsuite.
15:43:56 <Shin-LaC> in the tar ball,  everything is inside "ghc-7.6.2/testsuite"
15:44:55 <Shin-LaC> so it's not like any of the content are going to merge with those of the ghc-7.6.2 source tarball
15:45:18 <Shin-LaC> e.g., "ghc-7.6.2/testsuite/config" won't merge with "ghc-7.6.2/config"
15:45:19 <luc_> quick question about [Char]s vs. ByteStrings
15:45:22 <Shin-LaC> is that a problem?
15:45:34 <luc_> can anyone help me out super quick?
15:45:36 <shachaf> Shin-LaC: I assume it's meant to work that way. Just extract them in the same directory.
15:45:42 <shachaf> luc_: Only if you ask the question.
15:45:44 <glguy> luc_: Just ask your question on IRC
15:45:47 <luc_> k
15:45:53 <luc_> <-- n00b
15:46:03 <shachaf> luc_: However: [Char] and ByteString are totally different things. One is a sequence of characters and the other is a sequence of bytes.
15:46:07 <luc_> so, i'm playing around with Database.Redis
15:46:22 <luc_> and i want to be able to use the results of other functions to pass into redis
15:46:46 <Shin-LaC> shachaf: ok
15:46:55 <luc_> and i can keep using various `pack` functions to change strings into bytestrings, and it never seems to work
15:47:00 <shachaf> Shin-LaC: Try it and see. :-)
15:47:06 * hackagebot lambda-toolbox 1.0 - An application to work with the lambda calculus (for learning)  http://hackage.haskell.org/package/lambda-toolbox-1.0 (JulianFleischer)
15:47:24 <Shin-LaC> does it make sense to run the test suite with the binary packages?
15:47:26 <shachaf> luc_: "pack" won't convert between strings and bytestrings because they're different types that mean different things.
15:47:35 <luc_> okay
15:47:49 <shachaf> You probably want things called names like "encode" and "decode".
15:47:52 <luc_> how can i convert a string into something that i could pass into redis (or most DB clients for that matter)
15:47:54 <luc_> okay
15:48:05 <luc_> Data.Text.Encoding?
15:48:09 <shachaf> Probably a name like encodeUTF8.
15:48:18 <luc_> got it
15:48:19 <shachaf> But you should first figure out what encoding you're using. :-)
15:48:58 <luc_> well, let me ask you this: if the type of "foo" is [Char8], does that mean that encodeUTF8 would likely work?
15:49:47 <dmwit> luc_: What the heck is Char8?
15:49:49 <luc_> (sorry…new to FP and slogging through some of the finer points)
15:50:02 <arbn> Haskop is the opposite category to Hask, I guess.
15:50:17 <dmwit> That seems like a good guess to me.
15:50:18 <shachaf> luc_: This has nothing to do with FP. It's boring old real-world practical not-everyone-speaks-English things.
15:50:41 <luc_> oops
15:50:48 <luc_> i just meant [Char]
15:50:52 <shachaf> There is no type called Char8. There's a module called Char8 but it's a lie.
15:51:04 <shachaf> I recommend avoiding it and learning how to do things properly. :-)
15:51:04 <luc_> yeah, i accidentally typed that
15:51:14 <luc_> duly noted!!!!
15:51:18 <glguy> shachaf: I speak English, but I just have to have my PILE OF POO glyph
15:51:41 <dmwit> UNICODE SMILY FACE WITH ZIT
15:51:54 <luc_> learning what libraries to avoid….now THAT is useful info
15:51:58 <luc_> and not easy to come by...
15:52:14 <dmwit> luc_: So, what do you know about Unicode?
15:52:32 <luc_> not a whole heckuva lot…but it's clear that i should go back and do some research
15:52:43 <luc_> i know that, say, ñ is probably not utf8
15:52:48 <shachaf> luc_: The FAQ talks about this a bit.
15:52:52 <shachaf> @where faq
15:52:52 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
15:53:02 <dmwit> Yes, read Spolsky's intro (something like "what every programmer should know about Unicode") and possibly the FAQ.
15:53:10 <luc_> nice
15:53:12 <shachaf> You should make sure to know the difference between Unicode and UTF-8, for one.
15:53:13 <luc_> great stuff
15:53:21 <shachaf> dmwit: The latter even links to the former!
15:53:22 <dmwit> Also, the sentence you said was not even wrong.
15:53:40 <dmwit> (The one about ñ.)
15:53:52 <shachaf> dmwit: Well... This is IRC, which means that sentence was sent as a sequence of bytes.
15:54:07 <glguy> luc_:  "5.11 How do I convert between String (or Text) and ByteString?" in the aforementioned FAQ
15:54:09 <shachaf> That ñ was probably encoded with either UTF-8 or ISO-8859-1.
15:54:28 <shachaf> Unfortunately my client plays guess-the-encoding so I don't know which one it was.
15:54:33 <shachaf> Anyway this is pointless pedantry.
15:54:44 <dmwit> shachaf: I am using the "not even wrong" in the technical, jargon-file sense.
15:57:28 <kdridi> hi
15:57:38 <luc_> okay, so it looks like i would need to convert a string into text and THEN into a bytestring
15:57:50 <kdridi> is there an automatic unencoding lib in haskell ?
15:57:57 <luc_> let foo = encodeUtf8 (pack "foo")
15:58:02 <kdridi> that guess the encoding of a string
15:58:11 <luc_> that would get me a bytestring usable in redis
15:58:13 <luc_> from a string
15:58:32 <kdridi> thx, i try that :)
15:59:40 <luc_> that seems like a little roundabout to be good haskell, though...hmmmm
16:06:18 <DanBurton> what about OverloadedStrings? let foo = encodeUtf8 "foo"
16:06:57 <DanBurton> or are we not dealing with actual string literals?
16:07:44 <shachaf> There should be a standard UTF-8 function :: String -> ByteString
16:08:34 <glguy> utf8-string has such a function
16:08:52 <shachaf> True.
16:09:00 <shachaf> Perhaps utf8-string should be more standard.
16:09:38 <shachaf> Hmm, does Data.ByteString.UTF8 have indexing functions?
16:10:23 <DanBurton> @google Data.ByteString.UTF8 docs
16:10:26 <lambdabot> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/utf8-string-0.3.4/Data-ByteString-UTF8.html
16:10:26 <lambdabot> Title: Data.ByteString.UTF8
16:11:08 <shachaf> Yes, I saw those. None of them are quite what I want.
16:11:43 <shachaf> I asked in here because glguy is the author of the package.
16:12:52 <DanBurton> but if you already knew the module in question did not in fact have what you are looking for, then it seems your true question is something else entirely than the one you posed
16:13:15 <glguy> I'd have to check. I haven't fussed with it much in the last couple years :)
16:13:38 <glguy> It's got 285 rev deps, though :) (just peeked)
16:14:27 <shachaf> DanBurton: You found me out.
16:18:39 <mgccl> Is there a way to give alias to things in data? for example for now I have data Exp a = Atom a | Repeat a Int, I wonder if I can make (Atom a) to be an alias of (Repeat a 1)
16:18:59 <shachaf> mgccl: No.
16:19:10 <shachaf> But you can define a function: atom a = Repeat a 1
16:20:06 <mgccl> shachaf: ok. Is it possible with template Haskell?
16:20:22 <elliott> you could make a splice I guess.
16:20:31 <elliott> but it'd look like $(atom a) instead.
16:20:37 <elliott> actually I guess it'd have to be more elaborate than that
16:20:39 <shachaf> What are you actually trying to do here?
16:20:51 <kdridi> how do i convert a CP1252 encoded string to UTF8 ?
16:21:43 <shachaf> kdridi: Probably decode it -- maybe with http://hackage.haskell.org/packages/archive/encoding/0.6.7.2/doc/html/Data-Encoding-CP1252.html ? -- and then encode it.
16:22:22 <kdridi> shachaf: decodeString CP1252 "\224" returns "\224" insetad of "à"
16:22:56 <shachaf> kdridi: How about [chr 224]?
16:23:21 <Saizan> > "\224" == "à"
16:23:21 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
16:23:26 <Saizan> meh
16:23:41 <mgccl> shachaf: I want to make readability easier. So I can use Atom a to refer to things instead of writing out Repeat a 1, but I guess this is not so important.
16:23:44 <kdridi> shachaf: [char 224] returns "\224"
16:23:56 <shachaf> kdridi: How about "à"? :-)
16:24:07 <glguy> kdridi: Try using putStrLn to look at it, which will output that string appropriately for your terminal
16:24:08 <shachaf> (It's all the same thing.)
16:24:21 <kdridi> shachaf: it returns "\224" :)
16:24:24 <luc_> :set -XOverloadedStrings
16:24:26 <luc_> this is proving useful
16:24:27 <glguy> when you "show" a String, it escapes characters like \224
16:24:34 <luc_> I didn't realize just how useful that was
16:24:47 <luc_> now I don't have to convert to Text, which is nice
16:24:48 <kdridi> ah ok. i didn't knew
16:25:24 <luc_> good call, @DanBurton
16:25:42 <DanBurton> luc_: :)
16:26:10 <kdridi> so, is there any way to print "à" as "à" instead of "\224" ?
16:26:27 <shachaf> show will always give you the string "\"\\224\""
16:26:35 <shachaf> You can use something other than show if you want.
16:26:53 <glguy> kdridi: I just told you the way
16:27:24 <shachaf> glguy: You're pretty suspicious-looking, though.
16:27:28 <kdridi> glguy: thx, i'll try that :)
16:27:39 <DanBurton> that depends on what you mean by "print". Do you actually want to write a letter to the screen? Or to a piece of paper?
16:27:46 <glguy> shachaf: too many 'g's?
16:29:19 <kdridi> glguy: that works, thx ;-)
16:49:21 <ivanm> is there an equivalent to liftM* where the lifted function is also monadic? i.e. liftM2' f mx my = do { x <- mx; y <- my; f x y }
16:49:35 <shachaf> join (liftM2 f x y)
16:49:46 <copumpkin> shachaf speaks the truth
16:49:50 <shachaf> Other than that, no. Sometimes people call it bind2 or something.
16:49:58 <ivanm> shachaf: yeah, I figured that out; I was hoping there was a better way without needing to use join
16:50:08 <ivanm> *nod*
16:50:17 <ivanm> at least hoogle and hayoo weren't lying to me then :p
16:57:25 <catbee> IRC newbie question : how does one find out the nickname <-> person map?
16:57:42 <ivanm> catbee: in general, you can't
16:57:49 <ivanm> you can try a /whois
16:57:55 <catbee> ivanm: what about for #haskell?
16:58:08 <ivanm> or see if they use the same nick on github or something and then list their real name
16:58:25 <catbee> for example, /whois ivanm gives me : Unknown
16:58:30 <ivanm> catbee: in general == there's no reliable way that it will work for any random person :)
16:58:42 <ivanm> huh, I thought I had my name in my config
16:58:48 <shachaf> What is a person?
16:58:52 <glguy> catbee: the command is, "Hi, I'm <name>. What's your name?"
16:59:05 <shachaf> Let's try it.
16:59:06 <catbee> hi i'm ben, what's your name?
16:59:09 <shachaf> Hi, I'm glguy. What's your name?
16:59:26 <catbee> hm server must be down
16:59:34 <glguy> shachaf: You can't trick me!
16:59:37 <ivanm> catbee: which server?
16:59:52 <catbee> lol
16:59:56 <shachaf> glguy: Wait, <name> isn't where I substitute the nick of the person I want to find things out about?
17:00:12 <shachaf> This is hard. :-(
17:00:24 <glguy> Yeah, English has a lot of nuances
17:00:43 <shachaf> nuisances, too.
17:01:09 <glguy> that's #haskell
17:01:20 <ivanm> shachaf, copumpkin: and the best bit is, I actually only needed liftM2; I was doing it late last night and got confused, the error messages were because I hadn't updated the type *facepalm*
17:01:28 <copumpkin> yay
17:01:40 <shachaf> ivanm: Have you considered using liftA2 instead?
17:01:51 <shachaf> "doing my part"
17:02:10 <ivanm> yeah, just used to the M variants
17:02:26 <ivanm> I even went and defined "type AMonad m = (Applicative m, Monad m)" and use that for my type sigs :/
17:04:45 <shachaf> A monad, a plan, a canal: Padanoma!
17:04:54 <byorgey> catbee: I maintain a large nick <-> person map in my head, so you could ask me =)
17:05:17 <shachaf> byorgey: Where can I find this Yorgey person? Is he related to Brent Byorgey?
17:05:44 <byorgey> shachaf: yes, they are twins
17:05:53 <byorgey> one of them always tells the truth and the other one always lies.
17:05:55 <newsham> surely sh. achaf.
17:06:06 <shachaf> Are they categorical duals?
17:06:34 <byorgey> well, they are in a categorical duel
17:06:39 <shachaf> Even better.
17:13:58 <edwardk> diagrams at 30 paces?
17:14:31 <c_wraith> non-commutative diagrams only
17:15:18 <byorgey> hehe
17:15:55 <otters> joke's on you
17:15:57 <otters> i have a magma cannon
17:15:59 <shachaf> I suppose Brent Byorgey and Edwardk Kmett and all the rest of them are from a parallel universe.
17:16:27 <otters> i'm self conscious because my real name isn't part of my username
17:16:39 <edwardk> Nah, byorgey and I are the evil twins. You can tell by the beards.
17:18:04 <ivanm> byorgey: that reminds me, with your diagrams-haddock package, I take it from the usage in Diagrams.TwoD.Path.IteratedSubset that it can also use functions in scope, not just defined in comments?
17:19:16 <byorgey> ivanm: no. It's just that the stuff defined in comments can include imports.
17:20:25 <byorgey> so the definitions for the diagrams in the IteratedSubset module include 'import Diagrams.TwoD.Path.IteratedSubset'.  diagrams-contrib has to be built & installed somewhere before running diagrams-haddock.
17:21:19 <ivanm> byorgey: ahhh, so it's importing itself?
17:21:22 <byorgey> right
17:21:28 <byorgey> making stuff in scope available would be possible in principle, but it's tricky to get right
17:21:44 <ivanm> *nod*
17:21:58 <ivanm> preflex: seen lispy
17:21:58 <preflex>  lispy was last seen on #haskell 1 day, 5 hours, 25 minutes and 59 seconds ago, saying: Cale: It's a new type, but it can be used in the same places as the unrefined type, right?
17:22:20 <Cale> Hello preflex
17:23:22 <arkeet> Cale: you should fix lambdabot's (.)
17:23:37 <Cale> arkeet: lambdabot's (.) is functioning as intended
17:23:48 <arkeet> the intention is broken :p
17:23:49 <glguy> it's a "feature"
17:24:11 <sproingie> what's wrong with the intention?
17:24:39 <shachaf> (.) = flip lmap is the only correct definition, hth
17:24:44 <arkeet> its use in :t and ensuing confusion is far more common than its actual use as infix fmap, for which we already have <$> anyway.
17:25:03 <shachaf> I agree with arkeet and I think most other people do too, but I doubt Cale will change his mind.
17:25:16 <arkeet> we must try harder!
17:25:28 <ivanm> shachaf: "lmap" ?
17:25:36 <sproingie> i find <$> ghastly to type, but i can see the problem with :t
17:26:10 <Cale> Well, the ensuing confusion is only confusing for a short time, so long as it's explained :)
17:26:20 <arkeet> but it has to be explained every single time.
17:26:33 <Cale> Since when are we opposed to explaining things?
17:26:36 <arkeet> I don't recall anyone using . with lambdabot where the fmap generality is actually used, anyway.
17:26:52 <sproingie> it reveals to people the generality of fmap.  people should be grokking that anyway.
17:27:12 <arkeet> explaining random quirks in caleskell is not something worth anyone's time, I think.
17:27:39 <Cale> It generates opportunities to teach something interesting, which there would be too few of otherwise.
17:27:39 <sproingie> tho maybe caleskell should get even more radical and just put on a different bot trigger
17:27:51 * elliott throws in his strong support for Prelude (.).
17:27:54 <arkeet> when was the last time it has taught someone something interesting?
17:27:58 <glguy> the way to solve it is for someone else to figure out how to compile lambdabot
17:28:02 <elliott> people need to know about (.) far before they need to know it should be generalised to fmap.
17:28:04 <glguy> and we can just ban lambdabot
17:28:05 <glguy> and move on
17:28:18 <elliott> also the universal reaction is just to tell people to ignore the silly type and type out the real one by hand.
17:28:26 <shachaf> Compiling lambdabot isn't that hard.
17:28:50 <shachaf> I think the fact that fmap = (.) at the (r ->) instance is good to know. But people who are confused by (.)'s regular type are going to be much more confused by also trying to understand the fmap thing.
17:29:13 <shachaf> You need to understand type classes (of non-* kind!) and all sorts of crazy things that beginners shouldn't need to understand just to compose functions.
17:29:14 <elliott> there's also the fact that basically nobody else who wants to generalise (.) wants it to be fmap, rather than Control.Category.(.)...
17:29:29 <elliott> ...so it isn't even the generalisation most would pick
17:31:10 <arkeet> shachaf: I think there is some hope. he changed his mind about flip, after all.
17:31:47 <ivanm> arkeet: what did he change?
17:31:52 <arkeet> flip used to be
17:31:53 <arkeet> :t (??)
17:31:55 <lambdabot> Functor f => f (a -> b) -> a -> f b
17:32:10 <shachaf> mikeplus64: How's your bot thing going?
17:32:28 <Cale> and the moment I changed flip back, someone complained
17:32:31 <Cale> :)
17:33:10 <ivanm> ahhh, right
17:33:21 <arkeet> but most people didn't!
17:33:28 <Cale> shachaf: That's the kind of reasoning which explains why map is separate from fmap
17:33:41 <sproingie> {-# LANGUAGE SpaceBarHeating #-}
17:33:53 <shachaf> Cale: I think lambdabot map should be specialized to [], yes.
17:34:05 <ivanm> sproingie: heh
17:34:06 <shachaf> I think *Haskell* map should be fmap, but I think lambdabot should reflect the Prelude.
17:34:22 <arkeet> I agree about respecting the prelude.
17:34:23 <elliott> (why should both (.) and map be fmap...?)
17:34:28 <arkeet> heh.
17:34:36 <shachaf> elliott: Well, one is infix.
17:34:43 <Shin-LaC> I'm a newbie and I'm confused by the idea that lambdabot works differently from prelude
17:34:53 <elliott> anyway, yes, of course what should be standard and what a bot that is regularly (even primarily) used to aid beginners in learning the actual Haskell language that is already standard should have
17:34:55 <Shin-LaC> I think I'll avoid lambdabot
17:35:00 <arkeet> > succ . [1,2,3] -- ????
17:35:03 <lambdabot>   [2,3,4]
17:35:03 <shachaf> There are reasonable arguments for (.)=fmap. I'm not arguing for or against it in general, just lambdabot.
17:35:12 <Cale> Shin-LaC: Really, it doesn't work differently. There are just some local bindings in scope and some Prelude definitions are hidden.
17:35:13 <elliott> ...and I think Shin-LaC has made the rest of my point for me.
17:36:34 <Shin-LaC> if it's *almost* the same, I'll be afraid of getting tripped up when it isn't
17:36:57 <arkeet> :t (++)
17:36:58 <lambdabot> Monoid m => m -> m -> m
17:37:03 <arkeet> :t (<>)
17:37:05 <lambdabot> Monoid m => m -> m -> m
17:37:24 <sproingie> btw just curious, what sort of things does Control.Category.(.) enable over fmap?
17:37:52 <Cale> sproingie: There aren't so many instances of Category (which isn't really a very faithful representation of what categories are), so not a whole lot.
17:38:06 <sproingie> that's what i noticed too
17:38:31 <sproingie> i do like the visual aspect of >>> and <<< though
17:38:43 <arkeet> I think <<< is a lot of characters.
17:38:49 <Cale> Well, yeah, uses of Category are rare enough that <<< is good enough.
17:38:58 <sproingie> same number as <$> and a lot faster to type
17:39:06 <arkeet> it's faster?
17:39:17 <sproingie> amazingly hitting the same key is like that
17:39:22 <arkeet> I find <$> much faster.
17:39:28 <arkeet> by a factor of 2 perhaps.
17:39:52 <Philippa> you can pipeline <$> pretty ferociously and you're interleaving hands - if your timing's good...
17:40:10 <sproingie> yeah, meanwhile back on planet *earth*
17:40:20 <ousado> :)
17:40:24 <arkeet> releasing a key before pressing it again takes time :)
17:40:26 <Philippa> where > is still right next to < :p
17:40:28 <arkeet> anyway...
17:41:01 * sproingie should just write some unshifted aliases in emacs or something
17:41:04 <Philippa> but <<< is good enough, yeah
17:41:09 <sproingie> have ,4. expand to <$> maybe
17:43:25 <sproingie> gave eclipsefp a try last night, took <3 hours before eclipse managed to crash and take the workspace with it.  stabby stabby stabby ...
17:43:48 <sproingie> this from a fresh install.  so back to emacs+flymake
17:45:32 <shachaf> @poll-add Prelude-(.)?
17:45:32 <lambdabot> Added new poll: "Prelude-(.)?"
17:45:42 <shachaf> @choice-add Prelude-(.)? yes
17:45:43 <lambdabot> New candidate "yes", added to poll "Prelude-(.)?".
17:45:44 <shachaf> @choice-add Prelude-(.)? no
17:45:44 <lambdabot> New candidate "no", added to poll "Prelude-(.)?".
17:45:51 <shachaf> @vote Prelude-(.)? yes
17:45:51 <lambdabot> voted on "yes"
17:46:04 <arkeet> @vote Prelude-(.)? yes
17:46:04 <lambdabot> voted on "yes"
17:46:16 <ivanm> @vote Prelude-(.)? yes
17:46:16 <lambdabot> voted on "yes"
17:46:58 <elliott> I sincerely doubt this will achieve anything, but
17:47:02 <elliott> @vote Prelude-(.)? yes
17:47:02 <lambdabot> voted on "yes"
17:47:05 <arkeet> heh
17:47:19 <elliott> I guess it has better chancse than most online petitions
17:47:54 <sproingie> lambdabot's response is odd
17:48:39 <sproingie> or is everyone voting on a poll called "yes"? :)
17:50:58 <elliott> sproingie: it supports multiple choice
17:51:04 <elliott> @help poll
17:51:04 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
17:51:11 <elliott> @poll-result Prelude-(.)?
17:51:11 <lambdabot> Poll results for Prelude-(.)? (Open): no=0, yes=4
17:51:23 <arkeet> @poll-list
17:51:23 <lambdabot> ["\"MacGood\"","(++)","ConfusedWithVixenSituation","FlavaOfJRuby","Prelude-(.)?","best-programming-language","best-spoken-language","food","funniest-thing-in-the-whole-world","naming","nethack","
17:51:24 <lambdabot> president","prove->","remove@src","sleep"]
17:51:33 <arkeet> @poll-result remove@src
17:51:33 <lambdabot> Poll results for remove@src (Closed): no=1, yes=1
17:51:47 <elliott> @poll-result sleep
17:51:47 <lambdabot> Poll results for sleep (Open): no=1, yes=7
17:51:49 <shachaf> arkeet: plz see #-blah
17:58:05 <jmcarthur> ugh, why does arrow have to be so *not* what i want it to be?
18:00:56 <edwardk> jmcarthur: because you really want a cartesian closed category or a profunctor.
18:00:59 <jmcarthur> the presence of arr, how frequently it is generated by the desugarer, and how the rewrite rules tend to collapse my nicely introspectible AST down into more arrs
18:01:13 <edwardk> ah, then CCC ;)
18:01:21 <jmcarthur> edwardk: exactly. i actually prototyped this thing in adga precisely as a CCC
18:01:47 <jmcarthur> and i go to port it to haskell and am reminded that Arrow is so awful :\
18:01:55 <edwardk> you're welcome to build it using 'categories' rather than arrows =)
18:02:01 <jmcarthur> (i do *want* arr in this case, i just want control over when it's used)
18:02:14 <edwardk> heck if you need to upgrade categories to support it let me know ;)
18:02:28 <edwardk> i haven't had anyone driving that forward development wise in a while
18:03:23 <jmcarthur> i'm playing with some partial evaluation sort of stuff, so the ability to avoid arr when possible is important since it allows me to reach more deeply into the expression i've built
18:04:17 <jmcarthur> i haven't given categories a very hard look yet. i will do so now
18:04:25 <jmcarthur> the downside of course is the lack of arrow notation :\
18:05:13 <catbee> wasn't there some noise on -cafe about generalizing arrows?
18:05:18 <jmcarthur> yeah
18:05:29 <catbee> did anything come of it?
18:05:34 <jmcarthur> there's also this, which looks perfect http://www.cs.berkeley.edu/~megacz/garrows/
18:05:35 <copumpkin> a decent amount
18:05:38 <copumpkin> yeah
18:05:40 <johnw> category notation!  oh wait, that's just id and . ;)
18:05:42 <copumpkin> and a coq plugin for ghc
18:05:54 <johnw> copumpkin: ooh, is there such a thing?
18:06:05 <copumpkin> well, I'm not sure what it actually is
18:06:10 <copumpkin> but he verified his garrows stuff for ghc in coq
18:06:17 <catbee> from what i remember i thought they were proposing standardizing the garrows thing, but i wasn't reading too carefully
18:06:37 <jmcarthur> well, the conversation drifted in that direction, but i don't think it was the focus
18:08:04 <edwardk> the profunctor/prearrow stuff wouldn't really help here
18:08:17 <edwardk> since it just slides the 'arr' around, and still uses it everywhere in the desugaring
18:08:24 <jmcarthur> yeah
18:10:35 <jmcarthur> edwardk:
18:10:37 <jmcarthur> oops
18:11:22 <jmcarthur> edwardk: categories looks like it basically has the abstraction i'm after, but i don't see a whole lot of benefit in using it apart from getting away from Arrow's rewrite rules
18:12:00 <jmcarthur> maybe that's enough reason on its own
18:12:41 <edwardk> I was mostly putting it forth as something that let you get the introspection you wanted that was already written and that I'm open to improving given an actual user ;)
18:13:05 <jmcarthur> :D
18:14:58 <edwardk> I figure if i can get you and say cmccann hooked then I can piggyback on someone who actually wants it to do something and get cool toys to play with
18:15:30 <edwardk> (He was working with linear logic in categorical form)
18:17:03 <cmccann> been busy with other stuff lately unfortunately
18:18:33 <jmcarthur> maybe i could do something crazy, like make my own Arrow-like interface that works with RebindableSyntax
18:18:37 <sclv> i'm sure it wouldn't be hard to tweak the standalone arrow desugarer to do something different for categories
18:18:41 <jmcarthur> (or tweak categories for it, of course)
18:19:07 <jmcarthur> i wonder how robust it would actually be to just use rewrite rules to turn the overuse of arr into something more useful
18:19:10 <sclv> just run it as a preprocessor
18:19:22 <jmcarthur> probably not very
18:19:35 <cmccann> or hack something with a QQ'er
18:19:50 <kdridi> is there any way to retrieve le last insert id using HDBC ?
18:19:52 <cmccann> if only as a prototype
18:19:58 <jmcarthur> yeah
18:20:12 <sclv> or hack it into she
18:20:16 <sclv> is she still under development?
18:20:55 <sclv> Strange Haskell Extensions
18:21:05 <jmcarthur> pretty sure pigworker still uses it, so it's probably at least somewhat maintained
18:21:17 <cmccann> is "development" really the right word for whatever process created she?
18:23:12 <djahandarie> Ah man, linear logic in category form? Talk about a pain
18:23:26 <djahandarie> Well, classical linear logic at least. Damn *-autonomous categories
18:24:20 <djahandarie> (Symmetric Monoidal Closed Categories on the other hand are just fine)
18:25:22 <jfischoff> Amr Sabry touched on their relationship, but I don't understand it exactly, djahandarie could you elaborate?
18:25:29 <cmccann> djahandarie: it was mostly just random tinkering
18:25:35 <cmccann> not something intended to be useful
18:25:36 <sclv> this is related from -cafe if ppl haven' seen it yet http://www.haskell.org/pipermail/haskell-cafe/2013-March/107215.html
18:26:46 <djahandarie> jfischoff, sure, *-autonomous is SMCC with a dualizing object. I just don't like the definition, I think it's ugly. It's a little nicer when you use the natural isomorphism / bijection formulation but I still think it's ugly
18:27:39 <cmccann> djahandarie: http://ncatlab.org/nlab/show/polycategory seems like a much nicer way to look at it
18:28:37 <jfischoff> djahandarie: thanks. Do you know if *-autonomous are related to any geometric categories like Vect or something equivalent for clifford algebras?
18:28:38 <djahandarie> I have to say I haven't played with them much
18:33:56 <djahandarie> jfischoff, I suppose it depends on what you mean by 'related', but I'm not seeing anything. Maybe someone smarter could figure something out though. Why are you interested in those combination of things?
18:35:31 <jfischoff> djahandarie: yeah pretty much :).
18:38:39 <djahandarie> jfischoff, that was a "why are you" question. :p
18:41:42 <jfischoff> djahandarie: I read it "are you" . I'm big believer in reversible computation, and when I was working on implementing (with dmwit and tgeeky) "The Two Dualities of Computation: Negative and Fractional Types" I learned about SMCC.
18:43:14 <jfischoff> jfischoff: I thought it was interesting that with clifford algebras you also have two "tensor" products the outer product and the grade compution direct sum
18:44:05 <jfischoff> my thinking is maybe there is interesting way to represent visually the computation in DCNFT
18:45:25 <jfischoff> by finding a interesting geometrically thing that lives in same category that there programming language lives in
18:46:53 <jfischoff> s /grade compution/ grade composition
18:48:15 <jmcarthur> i love the negative and fractional types stuff
18:48:28 <jfischoff> so cool
18:49:45 <jmcarthur> jfischoff: is that implementation basically a complete implementation?
18:50:12 <jmcarthur> i've not had an opportunity to actually try using that computational model
18:50:48 <jfischoff> jmcarthur: I don't so. I can compute with it though. It doesn't have the product trace just the sum trace
18:50:54 <jmcarthur> ah
18:51:03 <jfischoff> and I can't remember if it type checks
18:51:05 <jmcarthur> the product trace is the cooler of the two :(
18:51:10 <jmcarthur> (IMO)
18:51:20 <jmcarthur> oh just the trace
18:51:22 <jmcarthur> i misunderstood
18:51:43 <jmcarthur> for some reason i read that as "has negative types but not fractional types"
18:52:12 <jfischoff> it has to do with a way to do non deterministic computation
18:52:17 <jmcarthur> yeah
18:52:47 <jmcarthur> i have ready access to the author of the paper and he has succeeded in chatting my ear off
18:53:09 <jfischoff> oh cool Amr or the other author?
18:53:13 <jmcarthur> roshan
18:53:35 <jfischoff> roshan. He should do more with it
18:53:52 <jmcarthur> agreed!
18:53:59 <jfischoff> :)
18:54:08 <jfischoff> okay you have convinced me
18:54:19 <jmcarthur> ?
18:54:21 <jfischoff> I'm going to hack on it tonight
18:54:24 <jmcarthur> yay!
18:54:45 <jfischoff> it needs to generate diagrams with #diagrams!
18:54:55 <jmcarthur> ooh that would be awesome
18:55:17 * byorgey approves
18:55:41 <jfischoff> :)
18:56:24 <jfischoff> byorgey: the haddock integration is so cool
18:56:24 <cmccann> jfischoff: what's this you're hacking on?
18:57:08 <jfischoff> cmccann: https://github.com/jfischoff/pi-eta-epsilon
18:57:18 <jfischoff> after dinner :)
18:57:29 * hackagebot discordian-calendar 0.1 - library for handling Discordian calendar dates  http://hackage.haskell.org/package/discordian-calendar-0.1 (AdamCurtis)
18:58:45 <jmcarthur> cmccann: see www.cs.indiana.edu/~sabry/papers/information-effects.pdf and then www.cs.indiana.edu/~sabry/papers/rational.pdf
18:58:59 <cmccann> probably won't have time tonight but ok
18:59:06 <cmccann> sounds like fun stuff
18:59:45 <jmcarthur> cmccann: both are pretty easy reading. the first is pretty neat and the second is basically really awesome
19:02:08 <tgeeky> cmccann: there are some implementations of that paper floating around, fwiw. I have one, dmwit has one
19:02:14 <tgeeky> cmccann: of the rational.pdf paper
19:03:13 <cmccann> tgeeky: I'll have to take a look at some point
19:03:32 <tgeeky> cmccann: dmwit's implementation is here: https://github.com/dmwit/pi-eta-epsilon
19:03:52 <cmccann> that's what jfischoff's is forked from I think
19:04:09 * sw2wolf i use stumpwm instead of xmonad as xmonad has no REPL ...
19:04:10 <tgeeky> cmccann: yep. the three of us worked on it together. I have a totally seperate (and worse) implementation
19:04:23 <cmccann> haha
19:04:25 <tgeeky> cmccann: and the authors have their own, which they never released
19:04:49 <cmccann> I will resist any temptation to write my own
19:04:53 <cmccann> there seem to be enough already
19:05:09 <tgeeky> cmccann: indeed. If you could understand the usefulness of it, perhaps that would be a good direction to research :)
19:05:30 <cmccann> pf, what is this "usefulness" thing, I have never heard of that
19:07:50 <tgeeky> cmccann: I had a short conversation with the authors in which I convinced them that their interpretation of the meaning of several things (negative types, negative entropy) might be incorrect (from a physics point of view, which they are interested in), but they asked me to provide a more correct one and I was stumped.
19:32:07 <fxr> hi, is it possible to simplify such a lens expression? "modify $ (\s -> scenario .~ (M.map f $ s^.scenario) $ s)"
19:32:11 <cmccann> tgeeky: btw, did you ever see my toy linear logic thing?
19:32:25 <tgeeky> cmccann: link? I don't think so.
19:32:51 <edwardk> scenario.mapped %= f ?
19:32:52 <arkeet> fxr: scenario . mapped %= f
19:32:53 <arkeet> ?
19:32:55 <arkeet> heh
19:33:32 <cmccann> tgeeky: simple encoding of linear logic computation in Haskell, reliant on not mucking around inside a newtype for correctness, nothing fancy
19:33:54 <cmccann> tgeeky: https://github.com/isomorphism/Delineate/blob/master/Control/Delineate.hs
19:33:55 <fxr> arkeet: hmm thanks
19:34:00 <arkeet> no, thank edwardk, he was first
19:34:08 <arkeet> :p
19:34:30 <edwardk> team effort ;)
19:34:33 <cmccann> thanking edwardk for help with lens balances with blaming him for it :P
19:34:38 <edwardk> haha
19:34:39 <arkeet> lol
19:34:45 <cmccann> both are kind of implicit in any conversation about it really
19:34:52 <fxr> edwardk: thanks for the lib, anyway I think it needs more examples
19:35:04 <edwardk> feel free to send patches with examples =)
19:35:06 <tgeeky> fxr: patches!
19:35:15 <edwardk> in all seriousness, many of the examples are user contributed
19:35:32 <tgeeky> fxr: you'll be amazed how fast edwardk turns patches into published code.
19:35:34 <edwardk> My idea of 'appropriate example' tends to be at either too high or too low level for many users
19:35:50 <edwardk> so simple middle of the road examples are great
19:35:50 <cmccann> tgeeky: oh and fyi that code relies on the new TypeOperators behavior
19:35:52 <cmccann> like kind of a lot
19:35:57 <cmccann> also, unicode
19:35:58 <arkeet> be careful with sending patches though, you might find yourself with a commit bit
19:36:11 <tgeeky> cmccann: I noticed both quickly. That's fine (re: type operators) with me.
19:36:30 <cmccann> I have shortcuts in my code editor for typing all those symbols, heh
19:36:38 <edwardk> and then you can spend all your time trying to bump shachaf off the top of https://github.com/ekmett/lens/contributors
19:36:43 <edwardk> its a fun game!
19:36:57 <tgeeky> fxr: don't do that, you'll go insane. Patches welcome!
19:37:45 <fxr> I'll try to find some time
19:37:46 <cmccann> tgeeky: I was hacking on a simple linear lambda calculus interpreter at one point but never finished and then other stuff got in the way
19:39:18 <cmccann> I have a bunch of loosely-thought-out notes on a Haskell/ML flavored language with a linear type system as well
19:40:59 <tgeeky> cmccann: I don't have anything smart to say. Some of the code reminded me of my own hacking on this: http://hackage.haskell.org/packages/archive/pointless-haskell/0.0.8/doc/html/src/Generics-Pointless-Combinators.html
19:42:33 <edwardk> cmccann: i honestly find uniqueness to be more useful than linearity in a type system
19:42:43 <cmccann> tgeeky: if you want something smart to think about, ponder termination checking for a linear language, without exponentials built in and with macro expansion that happens before linearity is checked
19:42:49 <tgeeky> cmccann: that might just be the boilerplate aspects of both
19:43:16 <cmccann> tgeeky: you would be surprised how much arbitrary recursion is viable because linearity prevents nontermination
19:43:44 <cmccann> edwardk: how so? or rather, what's the relevant difference?
19:45:11 <tgeeky> cmccann: nevetheless, bookmarked for future inspection.
19:45:13 <edwardk> cmccann: think of linearity that you won't contract or weaken something again, then uniqueness is the contract that you haven't contracted (and since you have it still, trivially haven't weakened) it yet
19:45:39 <edwardk> cmccann: they are opposite facing temporal modalities
19:46:13 <edwardk> cmccann: uniqueness is forgettable, linearity is forever
19:46:16 <cmccann> edwardk: that seems more like an implementation issue regarding the semantics of the exponentials than anything else
19:46:29 <edwardk> no, they sit at opposite ends of the lattice of constraints
19:47:03 <edwardk> i can turn a uniqueness value into an unrestricted one, i can turn an unrestricted one into a linear one
19:47:22 <edwardk> its a different perspective
19:47:41 <cmccann> hm, ok
19:48:08 <shergill> linearity as in linear types?
19:48:10 <edwardk> dana harrington's thesis dove into the distinction somewhat, and i cared a lot about it 7 years ago when i first found haskell ;)
19:48:13 <edwardk> shergill: yeah
19:48:30 <cmccann> I think there's actually some subtlety possible with linearity beyond just unrestricted or not, but that's all in my disorganized notes
19:48:36 <cmccann> and I can't recall what I had in mind at the moment
19:49:04 <cmccann> and anyway that was going beyond what people usually mean by a linear type system
19:50:55 <edwardk> i had a whole lattice of unrestricted, relevant, affine, uniqueness, linear, etc. back in the day
19:51:02 <cmccann> sounds fun
19:51:14 <edwardk> i wasn't smart enough to program in the resulting type system =(
19:51:18 <cmccann> hahahaha
19:51:45 <ivanm> did my eyes decieve me, or did edwardk just say there was something he _couldn't_ hack stuff in? :o
19:51:45 <tgeeky> beautiful but totally unusuable!
19:51:48 <cmccann> at one point I was sketching out a language based on dual-intuitionistic logic
19:51:55 <cmccann> that was too confusing for me
19:52:16 <edwardk> tgeeky: exactly
19:52:35 <edwardk> ivanm: perhaps it was a consequence of _how_ i embedded all those connectives into my type system
19:52:43 <ivanm> ahhhh
19:52:59 <edwardk> ivanm: it made the type system have all the features but they were all just formally usable together, not very practically so
19:53:55 <cmccann> I would think they could all coexist in some larger coherent framework
19:54:07 <cmccann> that was actually usable
19:54:44 <edwardk> They can. In my case I was just throwing everything into the display logic blender.
19:55:30 <edwardk> http://www.researchgate.net/publication/225666320_Display_logic/file/d912f51095c63c6e00.pdf
19:56:16 <edwardk> and http://ftp.rsise.anu.edu.au/ftp/techreports/1997/TR-ARP-08-97.ps.gz
19:56:32 <Cale> I wonder why Chrome seems to think that PDF files are potentially harmful.
19:56:42 <cmccann> Cale: because everyone hates PDF
19:57:22 <sproingie> because pdf has historically had as many security holes as flash
19:57:50 <cmccann> edwardk: anyway uniqueness types seem interesting and useful but linear types seem to have more potential for making things awkwardly complicated so I'm sticking with that for now
19:57:55 <Cale> sproingie: On Linux?
19:57:57 <edwardk> hah
19:58:00 <sproingie> Cale: everywhere
19:58:04 <Cale> sproingie: uhhhh
19:58:26 <Cale> Are there demonstrations of PDF exploits for Evince?
19:58:32 <sproingie> at least the reader does
19:58:36 <edwardk> uniqueness types are mostly nice because you can give them a really nice operational interpretation where you can edit something in place so long as it holds onto the uniqueness property and then it inherently freezes and becomes immutable thereafter
19:58:48 <sproingie> chrome should know what it's opening in, but doesnt
19:58:53 <tgeeky> I like PDF, and I think I'm included in the set "everybody".
19:59:03 <Cale> Yeah, I like PDF as well
19:59:30 <edwardk> tgeeky: then i think cmccann just called you a nobody. you should beat him up.
19:59:51 <cmccann> heh
19:59:54 <tgeeky> edwardk: lover, not a fighter.
20:00:01 <Cale> Besides, it's not Chrome's job to protect users from badly written 3rd party software, even if that is the case.
20:00:24 <tgeeky> I could just pull a snarky "show me the better system you've invented!"
20:00:37 <tgeeky> with my luck, he's Knuth and he'll say LaTeX.
20:00:59 <cmccann> better system raises the question of better for what
20:01:17 <cmccann> and my main complaint about PDF is people using them inappropriately :P
20:01:25 <cmccann> also, with adobe's software being crap
20:03:15 <tgeeky>  .ppt < .djvu < .pdf < .ps < in the browser, stupid
20:03:31 <tgeeky> imho
20:03:54 <ivanm> tgeeky: I've tried using html-based presentations
20:04:10 <ivanm> I find they don't work too well, as if you're using a different browser with a different resolution than you tested...
20:04:36 <tgeeky> ivanm: yes, the state of them leaves something to be desired. However, they allow the potential for animation and interaction, which I consider essential these days.
20:04:41 <cmccann> personally I prefer plain text unless I have a particular need for formatting or images or whatever
20:04:49 <tgeeky> ivanm: none of those other solutions even start in that direction
20:05:03 <Cale> PDF is usually nicer than postscript because text is more frequently selectable in PDFs.
20:05:05 <ivanm> you can embed videos in pdf-based presentations... though that depends on the viewer
20:05:07 <Cale> (and searchable)
20:05:17 <ivanm> I tend to fake animations using overlays in beamer ;-)
20:05:35 <tgeeky> Cale: i actually switched .ps and .pdf to avoid flack. :( [Confession Bear]
20:05:43 <Cale> Also, there's a lot of things which I'd much rather see in PDF form than HTML
20:05:44 <tgeeky> I'd prefer pdf to ps :)
20:05:55 <Cale> (papers involving any significant amount of math)
20:05:59 <tgeeky> sure, I meant that list to represent how much I like these for my needs.
20:06:02 <Eduard_Munteanu> I wish it didn't matter.
20:06:05 <ivanm> Cale: though I'd rather see forms in html form than pdf form :p
20:06:40 <cmccann> Cale: those are one of the few places where I strongly prefer PDFs myself, yeah
20:07:03 <ivanm> pdf.js is surprisingly good for a quick`n`dirty read though
20:07:10 <Cale> I'm not bothered by forms in PDF form. I open them in Xournal and just write on them and make another PDF to send back :)
20:07:41 <ivanm> Cale: I mean the ones you need to use adobe reader for to fill in, etc.
20:07:49 <Cale> Yeah, I just fill those in by hand.
20:07:59 <ivanm> I'm not allowed to :(
20:08:08 <cmccann> Cale: xournal? what, not hoodle? :P
20:09:38 <mgccl> instance Show (Exp a) where show (Atom x) = show x    this gives an error, since there is no instance for show a. How can I restrict (Exp a)'s a to Show a?
20:09:45 <donri> Cale: mathml?
20:09:52 <Cale> donri: lol
20:09:57 <donri> i see
20:10:02 <cmccann> mgccl: instance (Show a) => Show (Exp a)
20:10:52 <mgccl> cmccann: thx, I was playing this (Show a)=> everywhere, and didn't get it into the right place...
20:11:05 <donri> Cale: but why?
20:12:31 * hackagebot binary-file 0.12.8 - read/write binary file  http://hackage.haskell.org/package/binary-file-0.12.8 (YoshikuniJujo)
20:13:40 <Cale> cmccann: Might be worth trying that again at some point, but last I tried both, I preferred Xournal's pen's slight velocity dependence
20:14:30 <cmccann> Cale: actually I have no idea how they compare, just that hoodle was originally based on xournal
20:14:49 <Cale> Yeah, they're fairly similar
20:15:10 <cmccann> if memory serves me he started it because he got tired of patches he submitted to xournal being ignored, heh
20:15:19 <cschneid> is it bad style to stack where clauses?  top level, where func where funcinner
20:15:23 <cschneid> it's still only a few lines
20:15:32 <Cale> cschneid: You usually don't *need* to stack them
20:15:32 <cschneid> but when should I make a top level vs. a nested where block
20:15:45 <cmccann> cschneid: dunno about bad style
20:15:46 <Cale> But if scoping makes it necessary, then go ahead
20:15:48 <cmccann> a little tacky maybe
20:16:00 <cmccann> make sure you have a good reason for it but go ahead
20:16:14 <Cale> cschneid: You can put as many declarations inside a single where block as you want
20:16:17 <donri> if one of the where's is from an instance declaration, go right ahead and nest another ;)
20:16:23 <cschneid> Cale: yeah, more of a style question :)
20:16:44 <Cale> cschneid: Well, just do whatever reads better
20:16:44 <cschneid> trying to fit into the world of haskell.  For instance, I come from ruby, which strongly encourages everything to be separated out to lots of small methods
20:17:01 <cschneid> which is distinct from some other languages style
20:17:08 <donri> cschneid: not sure i see how nested where's would help that
20:17:24 <donri> you can have lots of small definitions inside a single where
20:17:33 <cschneid> donri: well, I think it's me naming things which more experienced users would inline (perhaps?).
20:17:42 <cmccann> in Haskell we encourage that everything be separated out into lots of small variable names, preferably of one or two letters each
20:17:43 <cschneid> ahh, instead of nesting. Hmm
20:17:47 <Cale> The main difference that you have with nested where is that the parameters to the function being defined are in scope inside the where
20:18:04 <Cale> If you don't need those, then there's not so much point in nesting them.
20:18:10 <donri> poe's law on cmccann ;)
20:18:20 <Cale> cmccann: lol
20:18:50 <donri> while you're at it just call every type you make "T" and use qualified imports
20:19:02 <cmccann> ah, Henning.T style
20:19:02 * danharaj has done that
20:19:20 <cmccann> the haddocks are hilarious
20:19:24 <donri> also, unicode makes for great syntax and identifiers!
20:19:33 <sproingie> that style would give me a haddock too
20:19:48 <cmccann> donri: I have dozens of shortcuts in my text editor for creating gratuitous unicode!
20:19:55 <donri> \o/
20:20:01 <sproingie> <Multi_key> <a> <r> <r>             : "☠" U2620 # SKULL AND CROSSBONES
20:20:12 <Cale> The actual rule for variable name length is that the lengths of variable names should grow with the size of the scope in which the variable is bound, and shrink with the frequency of use.
20:20:15 <donri> i bet you write agda code
20:20:21 <arkeet> @arr
20:20:21 <lambdabot> Avast!
20:21:22 <Cale> So, if you have something which only scopes over one line, one letter is enough, because its point of definition is always going to be in view and in recent memory at each point of usage.
20:21:27 <cschneid> Cale: good rule of thumb. So a var that's only bound for that line can easily be a single letter, but a global "constant" variable might need to be a full thingWithCamelCase
20:21:29 <cschneid> ?
20:21:35 <Cale> yeah
20:21:35 <danharaj> Cale: don't forget how polymorphic it is
20:21:41 <cmccann> donri: here take a look http://hpaste.org/75848
20:22:38 <Cale> If you have something which scopes over the entire program, but you use it constantly, it's also okay for it to have a short name.
20:23:11 <cmccann> Cale: is that why you call fmap (.)?
20:23:16 <Cale> ehehe
20:23:25 <Cale> Well, that's part of the reason I like that
20:23:34 <Cale> over, say, blessing Control.Category
20:23:42 <cmccann> that is true
20:23:43 <donri> cmccann: you've shown me this before :)
20:23:52 <cmccann> donri: hahaha yeah that was an old hpaste
20:24:04 <donri> ah same paste even
20:24:38 <cmccann> clearly "snowman=☃" is the most important one
20:26:24 <sproingie> the snowman is really underrepresented in mathematical notation
20:26:34 <cmccann> it's a valid Haskell identifier
20:26:37 <cmccann> just sayin'
20:26:47 <donri> and domain name
20:28:49 <TravisD> in Control.Monad.Primitive, the type of primitive is: "primitive :: (State# (PrimState m) -> (#State# (PrimState m), a#)) -> m a"
20:28:52 <TravisD> what are all the #'s?
20:29:03 <arkeet> they are characters
20:29:17 <danharaj> magic hashes
20:29:26 <TravisD> heh, arkeet
20:29:32 <arkeet> conventionally they're put in names for things that deal with unboxed stuff
20:29:57 <TravisD> so State# is just a type?
20:30:00 <arkeet> sure.
20:30:19 <arkeet> also that last bit is (# State# (PrimState m), a #)
20:30:22 <arkeet> (# , #) is an unboxed tuple
20:30:37 <TravisD> mh, I see
20:31:36 <LowPotential> Hi everyone. I've been learning Haskell off and on for a few years, and I wrote a small interactive RPN calculator. I'm trying to write idiomatic Haskell. Any tips for improving the code? http://hpaste.org/84700
20:35:24 <arkeet> LowPotential: a few things can be shortened I guess.
20:35:34 <arkeet> push x = modify (x:)
20:35:49 <arkeet> assuming ErrorT has a MonadState instance.
20:36:01 <arkeet> (otherwise you can lift modify, I suppose)
20:36:04 <ivanm> arkeet: need to use the non-Trans version of ErrorT
20:36:17 <arkeet> well something.
20:36:22 <arkeet> duplicate = top >>= push
20:36:31 <ivanm> it'd need to be lift . modify $ (x:)
20:36:39 <ivanm> the "return ()" there is redundant as-is
20:36:43 <arkeet> it is.
20:37:31 * hackagebot tuple-lenses 0.1.0.0 - Stock FieldN combos and generators  http://hackage.haskell.org/package/tuple-lenses-0.1.0.0 (JonathanFischoff)
20:37:46 <ivanm> my browser just froze on me again so I can't check whether this makes sense, but consider using maybe + listToMaybe for pop
20:37:57 <LowPotential> ivanm arkeet: Nice suggestions. Thanks!
20:38:47 <ivanm> OK, can't use maybe and listToMaybe for pop
20:38:53 <LowPotential> The "case" statement on 117 is sort of bothering me. Is there a better way to accomplish that?
20:39:25 <ivanm> you could use the either combinator...
20:39:54 <ivanm> might be able to clean up pop if you use the the LambdaCase language extension
20:40:02 <arkeet> no
20:40:11 <arkeet> :c
20:40:27 <ivanm> applyBinaryOp op = liftM2 op pop pop
20:40:45 <arkeet> I'm sure we can do better than two cases there.
20:41:05 <ivanm> arkeet: sure you could... write a function for the Left case, and then do `either foo (return ())'
20:41:12 <arkeet> sure
20:41:17 <arkeet> with a const there
20:41:31 <ivanm> oh, right
20:41:39 <arkeet> but something like
20:41:40 <arkeet> :t catchError
20:41:42 <lambdabot> MonadError e m => m a -> (e -> m a) -> m a
20:42:06 <arkeet> hmm
20:42:23 <ivanm> applyUnaryOp = (<$> pop)
20:42:31 * hackagebot tuple-lenses 0.1.0.1 - Stock FieldN combos and generators  http://hackage.haskell.org/package/tuple-lenses-0.1.0.1 (JonathanFischoff)
20:42:39 <ivanm> oh, that's not right... need to push it again
20:43:00 <ivanm> applyUnaryOp op = push =<< (op <$> pop)
20:43:12 <ivanm> applyBinaryOp op = push =<< liftM2 op pop pop
20:43:28 * ivanm has to run for a tute
20:43:35 <LowPotential> I can tell that neither of you like "do". Has it sort of gone out of favor in the last few years?
20:43:47 <LowPotential> ivan: Thanks!
20:43:48 <arkeet> do is fine for longer things. :p
20:43:58 <arkeet> I wouldn't write mainLoop without it.
20:45:02 <arkeet> but for 1- or 2-line things I probably wouldn't use it.
20:45:09 <arkeet> up to you
20:46:14 <arkeet> this is just me being picky, but I'd align the = signs in the definition of fromString. :p
20:47:02 <arkeet> I think I'd move hFlush into showPrompt.
20:47:34 <arkeet> or maybe factor out the whole prompt + getLine thing into its own action.
20:48:57 <arkeet> looks fine overall.
20:49:18 <arkeet> I better go, battery is running out. :)
20:52:32 * hackagebot lens 3.9.0.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.9.0.1 (EdwardKmett)
21:01:05 <LowPotential> arkeet: Just stepped away from the computer for a second. Thanks for all the feedback.
21:05:26 <William_> hi
21:05:50 <jfischoff> hi William_
21:06:43 <William_> whats the most advanced graphics thats possible with haskell?
21:07:07 <elliott> that's a pretty vague question :P
21:07:11 <Cale> William_: Well, there's OpenGL and Cairo bindings...
21:07:31 <Cale> "advanced graphics" is pretty vague, yeah :)
21:07:34 <centrinia_> William_, Quake 3 map viewer!
21:07:38 <Cale> hehe
21:07:42 <Cale> There is that
21:08:08 <centrinia_> http://www.haskell.org/haskellwiki/Frag
21:08:28 <jfischoff> William_: And if you want to make a raytracer, a pure functional languages has some parallelization advantages
21:08:29 <William_> ok
21:08:34 <Cale> Frag is a nice little proof of concept that was thrown together apparently in about a week
21:08:53 <Cale> (though it may have received a little attention since then, I don't know)
21:09:08 <William_> idk i want to make a game but I want it to work with a controller
21:09:46 <William_> maybe xbox or something
21:10:11 <jfischoff> compiling for the xbox might be an issue
21:10:35 <centrinia_> Cale, it claims to work with ghc-6.8 but was originally written in 2005.
21:10:38 <Rants> What would be considered to be 'advanced' types?
21:11:00 <Cale> Rants: heh, depends on your perspective
21:11:02 <William_> modern things like pixel shader and stuff
21:11:06 <Cale> Rants: Do you have some context?
21:11:19 <William_> pixel shader 3.0
21:11:27 <centrinia_> William_, sure. You can bind shaders with OpenGL.
21:12:05 <William_> does using openGL make  it impure?
21:12:10 <Cale> William_: you might be interested in http://hackage.haskell.org/package/GPipe-1.1.7
21:12:33 <jfischoff> Cale: have you used it? I'm curious, I haven't myself
21:12:50 <Rants> Cale: More advanced than what would be covered in the first couple of weeks in a programming languages class
21:12:59 <Cale> jfischoff: I haven't used it, but I've worked with one of the people responsible for it.
21:13:13 <elliott> William_: no more than doing any other kind of IO
21:13:37 <jfischoff> Cale: cool
21:13:47 <William_> ok ty
21:13:50 <William_> bbiab
21:13:56 <Cale> Rants: Well, does that include type classes? I guess that most extensions to Haskell 98 wouldn't be included in such coverage, but depending on your focus, you might touch on those.
21:14:18 <Cale> Rants: Or, beyond what's available in Haskell implementations, you have dependent type systems
21:14:50 <Rants> I think they covered haskell type classes
21:15:22 <Cale> Yeah, so there are a lot of extensions to the functionality of typeclasses
21:16:04 <Cale> For example, class associated types / type and data families, and multiparameter type classes, and functional dependencies
21:16:56 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html -- you might be interested to look through this
21:17:33 <Cale> (that's the section of the GHC user's guide on all the supported language extensions)
21:17:50 <Rants> actually yeah that's what I was looking for
21:18:18 <Rants> It's been a while since I navigated that section of haskell.org
21:18:18 <Cale> You also have things like GADTs and type equality constraints
21:18:50 <cmccann> jfischoff: hey were you the one working on some geometric algebra whatnot stuff at some point in the vaguely described past?
21:18:51 <Cale> Higher rank polymorphism (which gives functions the ability to demand polymorphic arguments)
21:20:08 <jfischoff> cmccann: yeah the update is after a conversation with you I looked into Singular for doing the symbolic manipulation. I now think that wrapping Singular is a good idea in general
21:20:29 <jfischoff> cmccann: http://www.singular.uni-kl.de/
21:20:30 <Cale> Existential types, which give you data types which can (partially) "forget" the types of their contents, allowing various things to be stored, so long as they, for instance, belong to some type class, or have the functions which act on them packaged inside the data structure with them.
21:21:37 <Rants> Cool, thanks
21:21:40 <jfischoff> cmccann: it is just a reasonably efficient algebra library that can handle clifford algebras and more esoteric algebras
21:22:04 <cmccann> jfischoff: hm
21:22:15 <cmccann> that probably precludes a pure API though, doesn't it?
21:22:25 <Rants> at this point I'm just trying to think of a way to present it that would be most accessible to these people
21:22:28 <Cale> I like their logo
21:23:03 <cmccann> it's an appropriate logo
21:23:12 <wavewave> jfischoff: i'm sorry I just miss the discussion. what library are you talking about?
21:23:32 <jfischoff> cmccann: I think you do it monadically well. You have to setup a algebra you are operating in first
21:23:35 <cmccann> wavewave: http://www.singular.uni-kl.de/
21:24:11 <wavewave> cmccann: ah.. yeah. i know it. thanks.
21:24:15 <jfischoff> I'm there might be a better open source lib for symbolic algebra, but that was best I could find.
21:24:48 <jfischoff> and the there are books to go a long with it
21:25:09 <cmccann> I was more interested in simple calculation rather than symbolic manipulation anyway
21:25:28 <Cale> It's kind of sad that practically every computer algebra system seems to have its own half-baked programming language implementation.
21:25:36 <jfischoff> cmccann: then you can use matrices pretty straight forwardly… one sec...
21:25:51 <cmccann> Cale: instead of sharing a common half-baked programming language implementation?
21:25:52 <wavewave> hmm .. it's much evolved after I saw it last time.
21:26:07 <Cale> cmccann: haha
21:26:59 <wavewave> I glanced at it when I needed to find Grobner basis of polynomial systems.
21:27:13 <Rants> everyone knows mathematica is the best programming language ever written
21:27:31 <monochrom> every time an application catches on, people must demand "but now we want it to be scriptable!" therefore, they must evolve (repeat: evolve) another programming language.
21:28:09 <wavewave> i do not like mathematica much.
21:28:18 <augur> Cale: what do you mean its own ... ?
21:28:27 <Rants> THE BEST
21:28:44 <Kaidelong> monochrom: very true, although some people learn their lesson and design things to be scriptable from the start
21:28:53 <Cale> augur: They're generally not libraries for general purpose programming languages.
21:29:25 <wavewave> it has good man-power covering many mathematical disciplines though.
21:30:15 <wavewave> I would like to see DoCon revive..
21:30:15 <Cale> augur: Instead, they consist of a new programming language which is usually somewhat weak, but with a handful of syntactic conveniences, together with an extensive library built on top.
21:30:32 <augur> weak in what sense
21:30:53 <Cale> Weak in the sense of not having a lot of useful features for general programming.
21:31:00 <augur> ah ok.
21:31:10 <Cale> Usually a halfassed type system if any
21:31:18 <jfischoff> cmccann: it is described in this book http://amzn.to/XceQ7g there is a pdf version on the web somewhere but I couldn't find it. Which is also captured here http://bit.ly/YDy7h7 but way more succinctly
21:31:30 <wavewave> it's too good to be just abandoned.
21:31:37 <Cale> Maybe no module system at all
21:31:48 <Rants> MATHEMATICA SUPPORTS PROCEDURAL, FUNCTIONAL, AAAND OBJECT ORIENTED PROGRAMMING also yeah the programming language is pretty weak and there's not much of a type system to speak of
21:32:30 <cmccann> I was under the impression that mathematica mostly supported mathematica-oriented programming
21:32:49 <tgeeky> wolfram demonstrations is nice
21:33:03 <Rants> hahaha
21:33:49 <cmccann> jfischoff: ah yeah I've seen that
21:34:27 <Cale> Everyone knows that Stephen Wolfram is at least twice as smart as the next smartest human being, and is responsible for completely transforming science as we know it.
21:34:46 <cmccann> Cale: specifically, transforming it into mathematica
21:35:31 <Shin-LaC> show me where Stephen Wolfram touched you on this doll
21:35:46 <tgeeky> I think it's unfair to judge him that way, because I wouldn't want my projects being so directly connected to my hubris and other moral scruples of mine.
21:35:47 <Rants> but, see, a good number of mathematicians wouldn't want a proper type system
21:35:56 <Rants> the smart ones would, once you showed it to them
21:35:58 <cmccann> wavewave: is DoCon even on hackage?
21:36:11 <wavewave> cmccann: i don't think so.. shame.
21:36:17 <Rants> buuuuut
21:36:40 <wavewave> cmccann: shall we make it available on hackage?
21:36:59 <tgeeky> my main objection to mathematica is that it didn't seem possible to me, to build a sense of trust in the correctness of the code into the code.
21:37:23 <cmccann> wavewave: it looks awfully abandoned... wonder if it even builds?
21:37:33 <Cale> Did you know that in 1982, Stephen Wolfram coined the term "complex systems research"?
21:37:40 <cmccann> that's got to be like a hundred GHC versions ago or something
21:37:51 <coppro> Cale: I hear he also invented science around that time
21:38:17 <cmccann> tgeeky: I'm pretty sure the poking fun at mathematica and wolfram are two separate things, being done on their own merits
21:38:20 <wavewave> cmccann: yeah... this is too bad.
21:39:36 <cmccann> wavewave: also, it seems to have a non-standard license which might be a problem for actual use
21:39:47 <jfischoff> speaking of things that should be on hackage and aren't is this tensor lib: http://www.volkerschatz.com/haskell/tensor.hs
21:41:37 <wavewave> cmccann: exactly.. now I was looking at license.txt file.
21:42:12 <cmccann> wavewave: I suspect this would take a moderate amount of tinkering to get in working order on a modern GHC
21:42:28 <liyang> jfischoff: looks like it could do with more invariants built in to the type.
21:42:28 <wavewave> cmccann: even putting it on hackage with the name DoCon may be problematic.
21:42:35 <cmccann> might be worth getting in touch with the author as well, to ask about the license and whether he's doing anything with it these days
21:42:47 <copumpkin> liyang++
21:43:06 <copumpkin> I feel like that's the kind of thing you could make decently correct by construction in haskell with some cleverness
21:43:13 <copumpkin> and without going too crazy
21:43:22 <cmccann> and copumpkin makes a dynamic entry to express support for type-enforced invariants
21:43:29 <cmccann> a shocking twist
21:43:29 <copumpkin> lol
21:44:21 <jfischoff> liyang: yeah I'm sure it needs a lot clean up.
21:44:29 <wavewave> good symbolic computation libraries are where haskell can excel but suprisingly few  libraries exist
21:44:54 <cmccann> wavewave: probably a matter of it still being a lot of work to implement despite Haskell being well suited to it
21:45:04 <wavewave> cmccann: definitely.
21:45:15 <cmccann> plus a lot of stuff already exists
21:45:25 <jfischoff> wavewave: That seems like step two. Step one is too wrap an existing library from c++/c land
21:45:42 <liyang> You're probably better off not looking at that and starting from scratch.
21:45:43 <cmccann> and "reinventing the wheel in Haskell" is not the best reason for writing a complicated library
21:46:26 <wavewave> it's not exactly reinventing the wheel  though in my opinion.
21:46:41 <wavewave> since almost all such libraries are written in untyped language.
21:47:03 <wavewave> or just C API for a specific computation.
21:47:05 <cmccann> it's inventing a new wheel that is like the old one except with better traction for icy roads
21:47:41 <wavewave> CAS in strongly typed language is something worth to make.
21:47:56 <wavewave> but anyway it's not very simple at all.
21:48:03 <cmccann> yeah
21:48:38 <cmccann> also there's the matter of would anyone want to use it? might be a hard sell to people used to the CAS with crappy types or none at all
21:49:31 <wavewave> cmccann: yeah.. that's true.. my field is already filled with mathematica people who wouldn't change it anyway.
21:50:01 <cmccann> you might be able to win people over with time
21:51:20 <wavewave> we can start some from small things, like clifford algebra, group representations or computational commutative algebra
21:51:29 <wavewave> I like the approach by HaskellForMath
21:51:51 <cmccann> unfortunately I'm not familiar enough with how CAS are actually used in practice to know where to start on something like that
21:52:22 <wavewave> oh.. HaskellForMaths has been grown up quite much. nice.
21:53:05 <cmccann> unfortunately jfischoff seems to have disappeared, but he's been interested in clifford algebra stuff
21:53:14 <cmccann> which is how this conversation started
21:55:52 <wavewave> hmm. HaskellForMaths looks very good. Seem to be a good starting point where to add on top of
21:58:02 <cmccann> wavewave: what kind of stuff would you want to add?
21:59:13 <wavewave> cmccann : for my purpose, some differential geometry stuff and Lie group stuff maybe.
22:01:26 <cmccann> hm... looks like HaskellForMaths hasn't been updated for a while
22:01:51 <wavewave> prabably the author is busy these day.
22:02:09 <cmccann> most likely.
22:02:18 <cmccann> hopefully he hasn't abandoned it
22:04:43 <LowPotential> xb
22:04:53 <LowPotential> Oops. Typo.
22:16:20 <xunatai> so, wait, is there any alternative to dealing with state other than records flying all over the place?
22:18:13 <wavewave> xunatai : try to use lens
22:18:14 <Rants> STATE MONAD
22:18:26 <xunatai> ah yes, lens!
22:18:33 <xunatai> i was trying to remember the name all day
22:19:03 <xunatai> rants, do state monads make even the record stuff easy to deal with?
22:19:55 <Rants> isn't lens basically a state monad with certain features?
22:19:59 <xunatai> hm
22:20:13 <Ralith> no.
22:20:38 <Ralith> the State monad is useful, and lens is useful, and they are different things, and neither of them subsume records
22:20:50 <Ralith> (though lens is capable of making records nicer to use)
22:20:59 <arkeet> lenses are actually coalgebras for a certain comonad.
22:21:00 <arkeet> :>
22:21:31 <arkeet> incidentally, it's the comonad coming from the same adjunction that gives the state monad.
22:21:48 <Ralith> xunatai: if you aren't using the State monad, and you are troubled by the need to pass things in/out all over the place, using the State monad will probably resolve your immediate concern.
22:21:58 <arkeet> but please ignore this abstract nonsense
22:22:12 <xunatai> thanks ralith
22:22:18 <Rants> I NEVER IGNORE ABSTRACT NONSENSE
22:22:25 <xunatai> well
22:22:27 <arkeet> lens does make the State monad nicer to work with, though ;)
22:22:29 <elliott> or caps locks?
22:22:38 <Ralith> arkeet: sure, but one thing at a time.
22:22:39 <cmccann> elliott: CAPS LOCK IS AWESOME OK
22:22:41 <xunatai> it's not so much that i ignore the abstract nonsense, it's that i can't make any sense of it!
22:22:54 <elliott> cmccann: #cobol
22:23:07 <arkeet> Lens' s a = s -> Context' s a
22:23:10 <Rants> I'm not hitting caps lock, I'm holding down the Shift key
22:23:13 <arkeet> Context' s is the comonad here.
22:23:16 <cmccann> elliott: BUT HOLDING DOWN SHIFT AND TYPING CAPS THAT WAY IS EVEN MORE AWESOME.
22:23:16 <xunatai> should i learn state monads, or lenses first?
22:23:22 <cmccann> caps lock is for lazy people
22:23:41 <elliott> arkeet: that definition of Lens is awful because it doesn't give you prisms.
22:23:42 <elliott> :(
22:23:44 * BMeph_ thinks fondly of programming in COBOL...especially when dealing with C++ APIs.... ;þ
22:23:46 <arkeet> sure.
22:23:58 <Ralith> xunatai: you want the State monad.
22:24:03 <xunatai> okay
22:24:19 <cmccann> BMeph_: have you seen the trendy new web framework for cobol?
22:24:21 <cmccann> http://www.coboloncogs.org/INDEX.HTM
22:24:23 <Ralith> xunatai: lens is useful but it is not the solution to your problem.
22:24:26 <arkeet> the State monad is a very good example to learn about monads with.
22:24:40 <xunatai> i'm in that annoying limbo where i understand monads, /sort/ of, but not enough to effectively apply them, but i can tell that it's very annoying to do anything without them
22:24:55 <Ralith> applying the state monad may well help you overcome that!
22:25:00 <Cale> It's not that annoying to do stuff without them
22:25:12 <xunatai> depends on what you're doing
22:25:16 <Cale> It's just that there are a fair number of libraries out there which happen to be monads
22:25:18 <Rants> a good thing to do for practice is write your own state monad
22:25:22 <BMeph_> cmccann: I'd rather have had COBOL on cobblestones, but, eh, beggars, choosers, yadda-yadda. :)
22:25:30 <cmccann> BMeph_: that site is hilarious though
22:25:37 <Cale> So... it's useful to know about monads in general to be able to use all those libraries a little better.
22:25:40 <xunatai> Rants, i was actually thinking exactly that
22:25:45 <xunatai> thanks for reminding me
22:26:24 <Ralith> Cale: manually threading state, for example, seems pretty annoying to me.
22:26:32 <Ralith> assuming you have to do much of it
22:26:35 <Cale> Ralith: well, occasionally, sure
22:26:55 <xunatai> i'm making a small game, with a good chunk of statey stuff
22:26:59 <Cale> Though to be honest, explicit parameter passing is a lot better than Reader a lot of the time
22:27:22 <BMeph_> I like to think of Manads as colors - it's not so much "understanding" them as it is understanding how to use certain ones, and them figuring out what they all have in common. :)
22:27:33 * hackagebot honk 1.1.1.2 - Cross-platform interface to the PC speaker.  http://hackage.haskell.org/package/honk-1.1.1.2 (ChrisWong)
22:27:35 <BMeph_> Oops - *Monads
22:27:44 <Cale> and if you're in IO already, sending an IORef (or half of one, i.e. partially applied readIORef/writeIORef) is frequently nicer than StateT
22:28:28 <BMeph_> cmccann: I'll peruse, thanks. :)
22:28:32 <Cale> (unless you go to a lot of trouble)
22:29:03 <cmccann> BMeph_: it's full of little jokes making fun of COBOL and RoR simultaneously
22:29:06 <cmccann> you really can't ask for more than that
22:29:07 <Ralith> StateT IO is a bit silly, yes
22:29:38 <Cale> People overuse some of the machinery which is available
22:29:43 <cmccann> pf, clearly you use the StateT to store the IORefs!
22:29:56 <Cale> cmccann: More likely ReaderT at least.
22:30:00 <BMeph_> cmccann: Oh, yeah? How about a site that makes fun of RoR and Drupal simultaneously? ;)
22:30:08 <Cale> but even then, you're paying a heavy tax to have to liftIO everything
22:30:11 <cmccann> Cale: but what if you need to, er, change the IORefs!
22:30:30 <Cale> just to save on parameter passing
22:30:31 <cmccann> I actually like doing the ReaderT IO thing.
22:30:44 <cmccann> if I have enough stuff I want to keep around
22:31:56 <Cale> One thing I highly recommend though, is splitting the ends of an IORef by creating it at some top level and passing the partially applied read/write into different parts of a computation. This can also really help in a multithreaded setting especially if you later need to change the semantics of how that state is accessed.
22:32:33 <Cale> Or for example you can log the changes to the state really easily from that central location
22:32:35 <cmccann> Cale: sometimes I take that one step further and pass around things parameterized in the monad with read/write type signatures
22:32:55 <cmccann> so that the same code can work with different reference types
22:33:03 <cmccann> assuming it doesn't do any IO directly obviously
22:33:21 <Cale> well
22:33:32 <cmccann> though you can make putStrLn look like a "write" operation and such as well
22:33:54 <Cale> If something isn't really doing any IO, I'd start to question whether it wouldn't be better off written in some other less-stateful style.
22:34:02 <Cale> But yeah
22:34:17 <cmccann> usually it's because I have something doing input and output but not necessarily direct IO
22:34:23 <cmccann> as well as using references or whatever
22:34:25 <Cale> ah, yeah
22:34:31 <Cale> Also, have you seen MonadPrompt?
22:34:41 <Cale> It can be good for that sort of thing
22:34:49 <cmccann> and then parameterizing the whole thing and shoving it in a record so it can be State+lenses or IO or whatever else
22:34:55 <cmccann> I think so
22:35:42 <Cale> Basically, you get to create a GADT of primitives for your newly constructed monad, and then the parameters to the run function let you specify their exact semantics.
22:35:50 <cmccann> ah yeah
22:36:37 <cmccann> mostly I never used it because I started with a fixed monad and then refactored to get the parameterized style, heh
22:36:46 <cmccann> if I was thinking ahead and wanted that kind of thing it would make sense
22:37:36 <cmccann> it amounts to mostly the same thing anyhow
22:37:39 <sw2wolf> @wn GADT
22:37:39 <lambdabot> No match for "GADT".
22:41:58 <cmccann> sw2wolf: Gratuitous Acronyms Demand Tribute
22:42:00 <cmccann> obviously
22:43:18 <Enigmagic> Grunt Axle Diminished Types
23:25:22 <cardamon> What's the > operator do to a pair of lists?
23:25:49 <cardamon> I'm reading Learn you a Haskell and got confused on this.
23:26:06 <simpson> > "abba" > "adder"
23:26:08 <lambdabot>   False
23:26:12 <cardamon> It compares heads, then second elements, etc, as long as they're true?
23:26:16 <arkeet> cardamon: it compares two lists like you would compare words in a dictionary.
23:26:27 <simpson> > [1,2,3,4] > [1,3,2,2]
23:26:28 <lambdabot>   False
23:26:41 <shachaf> @google lexicographical ordering
23:26:42 <lambdabot> http://en.wikipedia.org/wiki/Lexicographical_order
23:26:43 <lambdabot> Title: Lexicographical order - Wikipedia, the free encyclopedia
23:26:47 <arkeet> ^
23:26:55 <cardamon> Yeah, but how is [3,2,1] > [2,10,100] True?
23:26:59 <arkeet> because 3 > 2
23:27:04 <shachaf> 3 > 2
23:27:10 <arkeet> read the wiki link:
23:27:11 <arkeet> :p
23:27:33 <arkeet> it compares the first elements. if one of them is greater, then done.
23:27:33 <sw2wolf> what does :p mean :)
23:27:43 <arkeet> otherwise, repeat with the second elements. and so on.
23:27:52 <arkeet> if you hit the end of one list, then it's smaller than the other list.
23:27:55 <arkeet> (unless they're equal)
23:28:10 <shachaf> Nonexistence is considered smaller than any value.
23:28:17 <arkeet> [3,2,1] > [2,10,100] for the same reason "cba" > "bjz"
23:28:25 <arkeet> becuase cba would come after bjz in the dictionary.
23:28:46 <elliott> you have a very strange dictionary, arkeet.
23:28:57 <arkeet> *if* they were words.
23:28:57 <shachaf> > chr (ord 'a' + 100)
23:28:58 <lambdabot>   '\197'
23:29:14 <elliott> you cannot hide your Alien Dictionary for Aliens from me
23:29:23 <shachaf> "cba" > "bjÅ"
23:29:24 <elliott> cba bjz glurk.
23:29:41 <arkeet> my dictionary contains all strings that could conceivably be a word in any language.
23:29:49 <shachaf> I thought arkeet was only going to be an alien in the summer.
23:29:56 <cardamon> arkeet: THat's the part I didn't get.  So it compares 3 and 2 and then finishes, rather than comparing to make see if every element in list 1 was greater than every element of the same index in list two, which is what I mistakenly infered it would do?
23:30:16 <shachaf> cardamon: You have a very operational way of phrasing it, but yes.
23:30:26 <cardamon> operational?
23:30:36 <arkeet> cardamon: you look at the first position where the two lists differ. the list with the larger element at that position is larger.
23:30:45 <bitonic> cardamon: you think about how it runs rather than how it works
23:30:56 <bitonic> or rather than what it does :P
23:31:11 <shachaf> Or what it is/what it describes.
23:31:13 <shachaf> Whatever.
23:31:15 <arkeet> you could look at it recursively.
23:31:27 <arkeet> (a:as) <= (b:bs) iff a <= b or (a == b and as <= bs)
23:31:48 <elliott> arkeet: that would literally be easier to define by making it valid haskell
23:31:48 <cardamon> How should I know what it does without knowing how it does it, unless someone tells me?
23:31:48 <arkeet> and [] <= x for any list x
23:31:56 <arkeet> sure.
23:32:05 <arkeet> cardamon: it's all in the Ord instance for lists.
23:32:09 <elliott> well, you don't need to care about what it does.
23:32:13 <elliott> only what it means.
23:32:15 <arkeet> well, that's where it's defined.
23:32:17 <cardamon> I read dthe book, the book apparently assumed I could infer things I did not.
23:32:22 <elliott> its behaviour was specified in full even before arkeet's recursive definition
23:33:24 <arkeet> er
23:33:28 <arkeet> I should have written a < b up there.
23:33:45 <arkeet> whatever.
23:34:43 <cardamon> I think there's some meaning to "lexicographical ordering" that I'm not getting.
23:35:04 * sw2wolf thinking Why is it hard to implement a light weight REPL using haskell ?  
23:35:07 <shachaf> cardamon: Later elements are used as tie-breakers for earlier elements.
23:35:28 <shachaf> The first element is what counts. If it happens to be the same in both lists, you resort to checking the next one. And so on.
23:35:32 <arkeet> <arkeet> cardamon: you look at the first position where the two lists differ. the list with the larger element at that position is larger.
23:35:36 <arkeet> I thought this was pretty clear.
23:36:25 <arkeet> it's how you would see if one word comes before another in the dictionary.
23:36:28 <arkeet> s/if/whether/
23:36:41 <cardamon> Yeah, but then you started going on about the what not the how, as if I'd missed something fundamental in the presentation resulting in my confusion.
23:37:13 <arkeet> ok, I don't know what you aren't sure about.
23:37:47 <cardamon> How "ng haskell ?                                                   │·····························
23:37:50 <cardamon> 02:33 < shachaf> cardamon: Later elements are used as tie-breakers for earlier elements.                                                    │·····························
23:37:54 <cardamon> 02:33 -!- Rickasaurus [~quassel@ool-44c0bd65.dyn.optonline.net] has quit [Ping timeout: 248 seconds]                                        │·····························
23:37:58 <cardamon> ...sorry.
23:38:09 <cardamon> I mashed a button I shouldn't have.
23:38:55 <pharaun> heh
23:39:07 * pharaun takes away cardamon's buttons
23:41:13 <cardamon> pharaun: urxvt and pasting is hard.
23:42:59 <pharaun> heh indeed
23:46:24 <cardamon> I"m going to bed.  Night.
23:52:03 <TravisD> Is there a way to give ghc hints about the type of an expression without specifying the entire type?
23:53:04 <Pods> Hey, having learnt haskell for a while I was thinking what exactly are the development arenas for noobs in swish ?? P.S. Looking at applying for the same for gsoc too..
23:55:14 * cardamon feels bad that he can't figure out how to exit ghci
23:55:30 <cardamon> Ah.
23:55:32 <cardamon> got it.
23:55:35 <cardamon> need a :
