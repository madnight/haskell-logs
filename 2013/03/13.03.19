00:14:10 <Jonno_FTW> is there a function that returns init of a list and the tail as a tuple?
00:14:16 <Jonno_FTW> s/tail/last/
00:14:32 <BadKitty> Jonno_FTW: what in/out ?
00:14:43 <BadKitty> [1,2,3] -> (1,3) ?
00:14:51 <Jonno_FTW> ([1,2],3)
00:15:28 <Jonno_FTW> using (init x, last x) seems inefficient
00:16:37 <BadKitty> > let f = liftM2 (,) init last in f [1,2,3]
00:16:39 <lambdabot>   ([1,2],3)
00:16:43 <BadKitty> :)
00:17:09 <BadKitty> Jonno_FTW: How would that be inefficient? init and last oh wait.. why not ..
00:17:28 <Jonno_FTW> isn't last O(n)?
00:17:48 <Jonno_FTW> and so is init?
00:17:52 <BadKitty> Yea
00:18:15 <Jonno_FTW> so you get O(2n), but you could easily make it O(n)
00:18:29 <BadKitty> Yea
00:18:37 <supki> O(2n) = O(n)
00:19:23 <Jonno_FTW> it seems wasteful to use an O(n) operation to get the last element, when you are already going over the list once
00:20:23 <simpson> Jonno_FTW: Remember that init has to build an entirely new list.
00:20:50 <BadKitty> Jonno_FTW: Look at the source for init and don't kill the tail
00:20:59 <simpson> Jonno_FTW: Anyway, if you really care about the efficiency of this, why not use Data.Sequence?
00:21:52 <Jonno_FTW> @src init
00:21:52 <lambdabot> init [x]    = []
00:21:52 <lambdabot> init (x:xs) = x : init xs
00:21:52 <lambdabot> init []     = undefined
00:22:16 <genisage> @src insert
00:22:16 <lambdabot> insert e ls = insertBy (compare) e ls
00:25:54 <supki> Jonno_FTW: 2 usual approaches to get  (init xs, last xs)  are 1) use appropriate data structures like Data.Sequence 2) generate list backwards and then pattern match
00:27:02 * BadKitty wonders how he should be managing his payload length :/
00:32:40 <BadKitty> BAHL!
00:52:59 <startling> which datatype should I use for time on a server that different user times will be converted to and from?
01:06:36 <Kinnison> What precision will you require?
01:07:05 <Sgeo> I guess view patterns are really useful with Data.Sequence?
01:07:14 <Sgeo> What other libraries are view patterns useful for?
01:08:53 <liyang> Everything?
01:09:47 <Sgeo> Data.Sequence.viewl and Data.Sequence.viewr seem like functions practically intended to be used with view patterns
01:11:09 <Jonno_FTW> bah
01:11:39 <hpaste> Jonno_FTW pasted “apriori” at http://hpaste.org/84305
01:12:05 <Jonno_FTW> I get an error on line 8 and I don't know how to fix it
01:13:59 <Jonno_FTW> http://hpaste.org/84306 that
01:14:03 <Jonno_FTW> that's the error
01:15:26 <Kinnison> Give apriori a type signature to help it along is one approach
01:17:08 <Jonno_FTW> apriori :: [[a]] -> Int -> [([a],a,(Fractional,Fractional)]
01:18:08 <Kinnison> apriori :: Fractional b => [[a]] -> Int -> [([a], a, (b, b))]
01:18:11 <Kinnison> might be more traditional
01:18:17 <Kinnison> but I have to go now, good luck
01:37:21 <Sgeo> http://en.wikibooks.org/wiki/Haskell/Laziness#When_does_it_make_sense_to_use_lazy_patterns.3F
01:37:27 <Sgeo> "Why won't changing the order of the equations to head' help here?"
01:38:24 <Sgeo> What's the answer to that? It looks like it does make a difference
01:43:27 <edwardk> Sgeo: basically any lazy pattern will succeed with a value that will cause the pattern match to happen later
01:43:41 <edwardk> changing the order still results in the same problem
01:44:09 <edwardk> (though admittedly one that is less bad, because then it at least does mostly what head does
01:44:18 <edwardk> because the other unreachable branch just fails anyways
01:45:40 <supki> head' :: [a] -> Maybe a  would be a better example here
01:53:41 <edwardk> supki: yeah
02:36:48 <quchen> So yesterday, people talked about nesting seq as a joke here. At some point, someone evaluated "fix seq ()", which to my surprise terminated.
02:37:03 <quchen> I then got an explanation that I thought I understood, but turns out I didn't.
02:37:29 <quchen> fix seq () = seq (fix seq) () = seq (seq (fix seq)) () = ...
02:37:55 <quchen> So in order to check whether the first argument of each seq is bottom, it has to be evaluated to WHNF.
02:38:25 <b_jonas> that doesn't seem right
02:38:25 <quchen> I don't get how this is done without building the infinitely large tower of seq(seq(seq(...
02:38:32 <b_jonas> @source fix
02:38:33 <lambdabot> fix not available
02:38:37 <b_jonas> @src fix
02:38:37 <lambdabot> fix f = let x = f x in x
02:38:49 <quchen> > fix seq ()
02:38:51 <lambdabot>   ()
02:39:16 <quicksilver> fix seq = let fs = seq fs in fs;
02:39:34 <quicksilver> therefore fix seq () = fs () = seq fs ()
02:39:54 <quchen> Oh, my definition of fix was simply wrong?
02:40:21 <quicksilver> your expansion looks right.
02:40:39 <quicksilver> but it's important that fs is named and shared
02:40:46 <quicksilver> or maybe it is.
02:40:58 <quicksilver> anyway I think this is just successful strictness analysis
02:41:07 <quicksilver> the compiler can see that 'fs' is not _|_
02:41:10 <quchen> I always though "fix f = f (fix f)" was a valid definition.
02:41:10 <b_jonas> I'm not sure if your expansion is right or wrong, I just said it doesn't look right
02:41:23 <quicksilver> so it doesn't need to do any actual work.
02:41:31 <Xaratas> > fix seq undefined
02:41:32 <lambdabot>   *Exception: Prelude.undefined
02:41:36 <b_jonas> > let { myfix f = f myfix f } in myfix seq ()
02:41:38 <lambdabot>   Occurs check: cannot construct the infinite type:
02:41:38 <lambdabot>    t2 = t1 -> t2 -> t0Occ...
02:41:48 <b_jonas> > let { myfix f = f (myfix f) } in myfix seq ()
02:41:49 <lambdabot>   ()
02:41:53 <quchen> Hm.
02:42:07 <quchen> Well then I'm still confused.
02:42:30 <quicksilver> I'm not sure I must admit.
02:42:38 <quicksilver> I thought strictness analysis was compiler-only
02:42:46 <quicksilver> but ghci works too
02:42:56 <quicksilver> not sure which of my assumptions is wrong.
02:42:59 <quchen> Aaaaaaaaaaah waiiiit.
02:43:17 <docksider> quicksilver: that you are selfaware? ;)
02:43:21 <b_jonas> quicksilver: but strictness analysis can't change whether an expression terminates, right?
02:43:34 <quchen> seq (seq (fix seq)) ()   ---   the argument of the outer seq is "seq (fix seq)", which is a partially applied function, which is not bottom
02:44:02 <b_jonas> isn't strictness analysis just an optimization that has no visible side effect other than some nice speedups?
02:44:36 <quchen> b_jonas: I always thought so. I also thought Lambdabot wouldn't do that.
02:44:39 <quicksilver> b_jonas: I'm not sure that's true.
02:44:58 <quchen> Anyway, could my explanation above be correct?
02:45:00 <b_jonas> quicksilver: well, maybe it could turn a stack overflow error to termination
02:45:05 <b_jonas> I don't know
02:45:23 <quicksilver> b_jonas: can you not devise an expression which according to a naive expanding evaluator has an infinite expansion, but the strictness annotations prove is non-_|_?
02:45:24 <quchen> We'll have to wait for shachaf.
02:45:26 <b_jonas> I thought strictness analysis is basically just eliminating extra boxes
02:45:41 <quchen> Or post it on SO. I think it'd fit there.
02:45:48 <quicksilver> quchen: yes, I think you're right, by the way.
02:45:52 <quchen> Oh.
02:45:57 <b_jonas> which is nice especially for numerical computations
02:45:58 <quicksilver> quchen: partially evaluated function is not _|_
02:46:03 <quicksilver> and that's all there is.
02:46:14 <b_jonas> I don't really know how it works
02:46:32 <quchen> quicksilver: And that's because "seq (...)" is already in WHNF, right?
02:46:43 <quchen> Like \x -> x isn't bottom
02:46:54 <quicksilver> even \x -> _|_ isn't bottom
02:47:07 <quchen> It may *evaluate* to bottom when fully applied eventually, but it *is* not bottom.
02:47:07 <quicksilver> which is why some people think we shouldn't really use seq on functons
02:47:35 <quchen> Wait, why shouldn't we seq functions?
02:47:43 <quicksilver> because \x -> _|_ isn't bottom
02:47:47 <quchen> And?
02:47:47 <quicksilver> but "logically" it should be
02:47:48 <b_jonas> quicksilver: that's exactly why we _should_ use seq on functions
02:47:57 <quicksilver> the function which returns _|_ on all values is the _|_-function
02:48:04 <quicksilver> it doesn't make sense to distinguish it from _|_
02:48:12 <quicksilver> ..for some subjection values of "sense" and "logically".
02:48:14 <quchen> I think it does.
02:48:15 <quicksilver> subjective.
02:48:25 <b_jonas> quicksilver: on most other types you can replace seq with something else: for algebraic types, you use a case match, for numbers, you use arithmetic, etc
02:48:28 <quchen> > const (\x -> undefined) 3
02:48:30 <lambdabot>   No instance for (GHC.Show.Show (t0 -> a0))
02:48:30 <lambdabot>    arising from a use of `M76154...
02:48:35 <quchen> > const 3 (\x -> undefined)
02:48:36 <b_jonas> but for functoins, seq is the only way you can force them without applying
02:48:36 <lambdabot>   3
02:48:39 <quicksilver> you can think that. It's subjective. However you should appreciate the other argument.
02:48:42 <b_jonas> so you need seq for functions
02:48:57 <quchen> quicksilver: It's a fair bit into the bottom region, I can agree with that.
02:49:35 <quchen> :t \x -> undefined
02:49:37 <lambdabot> t -> a
02:49:42 <quicksilver> if you think very operationally it is 'obvious' that seq on functions makes sense (and does the right thing)
02:49:44 <quchen> @djinn a -> b
02:49:44 <lambdabot> -- f cannot be realized.
02:49:47 <quchen> ;-)
02:49:52 <quicksilver> however if you think very denotationally, it doesn't
02:50:03 <quchen> I understand neither of these words. :-s
02:51:12 <quicksilver> suppose functions mean something
02:51:22 <quicksilver> suppose you have an actual mathematical model of what a function is
02:51:33 <quicksilver> there is only one thing you can do to a function to observe it - you must apply it to a value.
02:51:43 <quicksilver> you can't observe them any other way, as they are opaque.
02:51:59 <quicksilver> So, given the function \x -> _|_ the only way you can observe what it is, is to give it a parameter
02:52:03 <quicksilver> and then, you will get _|_
02:52:11 <quicksilver> ... on the other hand, if you had the function _|_ in the first place
02:52:17 <quchen> That makes sense.
02:52:22 <quicksilver> then the only thing you can do with *that* is give it a parameter
02:52:28 <quicksilver> and of course _|_ x is _|_
02:52:37 <quicksilver> so, the two functions are indistinguishable in the theory of functions.
02:52:51 <quicksilver> \x -> _|_ is "observationally equivalent" to _|_.
02:53:02 <quicksilver> except... seq gives us a way to tell them apart.
02:53:07 <quicksilver> so it drives a hole in the theory.
02:53:09 <quicksilver> that's why.
02:53:21 <quchen> Yeah seq seems to break a lot of things.
02:53:34 <quicksilver> so, some people say that seq should only be used on data types
02:53:44 <quicksilver> where it has a very clear operational purpose of "force the top constructor"
02:53:58 <quicksilver> and in one much earlier version of haskell, that was how it worked.
02:58:50 <quchen> Is there any reason for seq to exist on purely theoretical grounds anyway?
02:59:17 <quchen> All the "but it's useful" arguments I can come up with are about efficiency.
02:59:54 <tharper> quchen: what do you mean "reason"?
03:01:30 <quicksilver> yes, it's about efficiency.
03:01:38 <quicksilver> it doesn't let you calculate things you couldn't calculate anyway
03:01:50 <quicksilver> it just lets you ask the runtime not to waste space by storing big thunks it doesn't need to.
03:01:55 <quchen> tharper: ^ That's what I meant. :-)
03:02:51 <srhb> Ideally I guess we wouldn't need seq and strictness analysis would always be spot on.
03:03:26 <srhb> I'm not convinced that's even possible.
03:04:07 <quchen> Sounds like a pipe dream, even for pure code
03:04:23 <quchen> But who knows
03:05:49 <quicksilver> in some cases it isn't strictness analysis, though
03:05:56 <quicksilver> it's simply a programmer decision
03:06:08 <quicksilver> "it would be more efficient to evaluate this now, rather than waiting for it to be demanded"
03:06:21 <quicksilver> you might not know 100% for sure that it will be demanded (that's the case strictness analysis covers).
03:06:37 <johnw> it's seq just like a universal case analysis?
03:06:40 <johnw> s/it's/isn't
03:06:57 <quicksilver> you might just not want to waste the space even if it is never demanded.
03:07:11 <quicksilver> johnw: if you have a very operational view of case analysis, then yes.
03:07:22 <johnw> ah
03:07:23 <johnw> true
03:07:24 <quchen> I'm not sure what seq is. It crashes when an argument crashes, otherwise does nothing.
03:07:32 <johnw> i get my denotational mixed up with my operational often
03:07:33 <quchen> Internally it probably has fairies or something.
03:07:39 <quicksilver> quchen: in practice it evalutes the top constructor.
03:07:55 <srhb> quchen: Yes, internally it does have fairies.
03:07:56 <quicksilver> which unrolls enough of your nested thunk to find that top constructor.
03:08:16 <quchen> quicksilver: Well that part I get. But then people on #haskell come up with weird examples and then I un-get it.
03:08:29 <srhb> quchen: Externally, you can think of seq a b as injecting an evaluation dependency on a that states that whenever b is required, we must evaluate a first.
03:09:10 <quchen> srhb: But "seq a b" doesn't evaluate a first.
03:09:22 <quchen> Seq just does stuff and that turns out to follow some rules.
03:10:07 <srhb> quchen: What do you mean it doesn't evaluate a first? When the value of seq a b is required, a is evaluated before b, and b is returned
03:10:26 <quchen> Not necessarily.
03:10:32 <srhb> Example?
03:10:45 <quchen> seq a b evaluates a and b in some order, and returns b iff a is not bottom.
03:10:54 <srhb> (Yes, necessarily)
03:11:07 <quchen> But that doesn't mean a is evaluated before b.
03:11:22 <srhb> I don't follow how you reach that conclusion
03:11:35 <Jonno_FTW> how would I write a function that returned all subsets of a list?
03:12:09 <docksider> recursively
03:12:18 <quchen> srhb: seq undefined (1+1) = seq undefined 2 = undefined
03:12:24 <quchen> That's not different to evaluating undefined first
03:12:58 <srhb> How did you get to the second step?
03:13:27 <quchen> By evaluating (1+1).
03:13:33 <srhb> Well, you shouldn't
03:13:36 <srhb> because it isn't.
03:13:50 <`nand`> forcing “seq a b“ forces a followed by b
03:13:56 <no-n> would there be a curryish way to remove the x and make this not a lambda? (\x -> isprime (n-x)) ... I tried (isprime (n-)) but it did not work
03:14:12 <`nand`> though I'm not sure whether it really forces a first, might be worth figuring out for impure a
03:14:20 <quchen> no-n: Don't. The Lambda is clearer.
03:14:36 <no-n> ok :>
03:14:38 <`nand`> isprime . (n-)
03:19:56 <`nand`> for the sake of answering your question
03:19:57 <no-n> ahh
03:19:59 <`nand`> Jonno_FTW: depends on what you mean by subsets, in list order? sequentially?
03:20:00 <`nand`> like [1,2,3] => [[],[1],[2],[3],[1,2],[2,3],[1,2,3],[1,3]] ?
03:20:00 <docksider> im guessing he wants the powerset, or combinations if you will
03:20:00 <docksider> represented as lists
03:20:25 <quchen> isPrime . (flip subtract n)
03:20:25 <quchen> srhb: So what's pseq for?
03:20:26 <quchen> Also, (1+1) evaluates to true for me.
03:20:26 <quchen> Evaluating "f a b" might have to evaluate both a and b, so the computer (/compiler) starts working on that.
03:20:26 <quchen> Turns out in the case of seq it is a smart default implementation to first evaluate a, but it's not a requirement.
03:20:27 <quchen> The report defines "seq bot b = b; seq a b = b if a /= bot", and doesn't mention evaluation order
03:20:34 <`nand`> > subsequences [1,2,3]
03:20:51 <`nand`> lambdabot?
03:21:10 <quchen> > let powerset = filterM (\x -> [True, False]) in powerset [1,2,3]
03:21:15 <srhb> > seq undefined (error "foo")
03:21:15 <lambdabot>   *Exception: Prelude.undefined
03:21:15 <srhb> > error "foo"
03:21:15 <lambdabot>   *Exception: foo
03:21:15 <srhb> Whenever seq a b is required, a is evaluated, then b. I've not seen examples to the contrary, but I may just be lacking imagination.
03:21:40 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
03:21:40 <lambdabot>   mueval-core: NotAllowed "These modules have not been loaded:\nL\n"
03:21:51 <quchen> srhb: Well, current GHC implements basic 'seq' as "first a, then b".
03:21:59 <srhb> Yes.
03:22:07 <srhb> I wasn't aware we were talking about another Haskell implementation.
03:22:11 <quchen> But there's a note at the pseq docs about this: http://hackage.haskell.org/packages/archive/parallel/latest/doc/html/Control-Parallel.html#v:pseq
03:22:24 <quchen> srhb: We were talking about seq, which isn't GHC but Haskell.
03:22:35 <docksider> It is very important to remember that ghc is not haskell
03:22:49 * srhb shrugs
03:22:59 <quchen> seq = pseq is a valid implementation.
03:23:04 <srhb> I was talking about code I can run. :-)
03:23:27 <quchen> Even then, GHC could decide to change its method.
03:23:34 <srhb> Sure.
03:23:34 <docksider> yeah, that might be diffrent :)
03:23:44 <quchen> Or the compiler could start swapping seqs around, like the link above mentions.
03:23:53 <docksider> I'm not really a fan of ghc tbh
03:23:57 <srhb> I've never actually seen it happen.
03:23:59 <quchen> a `seq` b = b `seq` a `seq` b
03:24:07 <srhb> But like I siad, perhaps I'm just lacking in imagination.
03:24:17 <srhb> For now it seems my understanding is spot on.
03:24:35 <docksider> I shared your understanding, now im back to confused
03:25:07 <quchen> seq is defined by two equations and nothing more.
03:25:11 <quchen> And those don't mention order.
03:25:25 <quchen> That's precisely why we have pseq.
03:25:26 <srhb> seq is undefinable in Haskell, so that makes little sense.
03:25:54 <srhb> And I don't understand what difference that rewrite makes
03:26:07 <quchen> The Haskell report defines seq, therefore it is definable in Haskell.
03:26:31 <srhb> I don't follow.
03:26:46 <quchen> Well, if "a `seq` b" evaluates a first, then the rewrite "= b `seq` a `seq` b" would be invalid.
03:27:59 <srhb> Right. I don't know in which case the compiler does that reordering.
03:28:10 <`nand`> A lot of things in Haskell probably need to made more rigorous in the presence of unsafePerformIO
03:28:12 <`nand`> such as the result of forcing seq a b where ‘a’ and ‘b’ have side effects
03:28:19 <quicksilver> quchen: The Haskell report defines seq, therefore it is definable in Haskell.
03:28:29 <quicksilver> quchen: that is quite untrue.
03:28:45 <quicksilver> however you are right that the report doesn't specify evaluation ordering for seq a b
03:29:02 <quicksilver> and you are also right that pseq exists to specify this ordering more precisely
03:29:07 <quchen> Haskell is what the report says, and not the ideal people make out of it.
03:29:22 <quicksilver> I think probably you just misunderstand what "definable in Haskell" means.
03:29:34 <quicksilver> if seq was definable in haskell it wouldn't need to be a primitive
03:29:36 <quchen> You can't write a Haskell program with "seq a b =" in it.
03:29:43 <quicksilver> you could just write "seq = ...." and define it.
03:29:43 <quchen> But it's still Haskell.
03:29:45 <quicksilver> and you can't.
03:29:47 <srhb> ?
03:29:48 <`nand`> import Prelude hiding (seq)
03:29:53 <quicksilver> yes, it's haskell but it's not definable in haskell.
03:29:53 <srhb> That interpretation is rather useless.
03:29:54 <quicksilver> you said it was.
03:30:08 <`nand`> import qualified Prelude as P (seq); seq = P.seq
03:30:14 <quicksilver> `nand`: :P
03:30:21 <srhb> helpful :D
03:30:24 <quchen> It's definable in Haskell, but not in Haskell code that compiles.
03:30:32 <quicksilver> quchen: no. it is not.
03:30:48 <`nand`> case unsafeCoerce a of () -> ... -- does something like this make sense?
03:30:57 <quicksilver> "definable in Haskell" would mean that there was an expression in "haskell-without-seq" which would give a working definition of seq.
03:31:00 * hackagebot comonad 3.0.2 - Haskell 98 compatible comonads  http://hackage.haskell.org/package/comonad-3.0.2 (EdwardKmett)
03:31:01 <quicksilver> and there isn't.
03:31:10 <quicksilver> it is a primitive, and it has to be.
03:31:41 <quicksilver> `nand`: I think that's just liable to segfault in some of the interesting cases.
03:32:04 <quicksilver> if it doesn't simply get optimised away :)
03:32:07 <quchen> Well it is definable in the Haskell report, which defines Haskell. Page 75. It's an integral part of the language.
03:32:15 <quicksilver> quchen: it is part of haskell, yes.
03:32:18 <quicksilver> it is in the report.
03:32:29 <quicksilver> it is not *definable in* haskell - that's why it has to be primitive.
03:32:36 <srhb> If you wrote the equations that supposedly define seq, you wouldn't get seq.
03:32:45 <srhb> NOt in Haskell.
03:32:57 <`nand`> quicksilver: I tried it out, it succeeds on “myseq undefined 3” but that's hardly a comprehensive benchmark :)
03:33:07 <quicksilver> `nand`: :)
03:33:21 <srhb> In fact even calling that a definition is slightly imprecise, I think. It would be closer to say that it obeys these characteristics.
03:33:22 <`nand`> quickCheck $ \a b -> spoon (seq a b) == (myseq a b)
03:33:29 <quchen> Well that's logically inconsistent. You can't talk about "seq" without accepting you have Haskell, which already includes seq.
03:33:30 <`nand`> oh, forgot a spoon
03:33:42 <srhb> Which, even, it doesn't.
03:33:51 <quicksilver> quchen: it is widely understood that when you say
03:33:53 <srhb> Or at least I think it doesn;t.
03:33:55 <quicksilver> "Is X definable in Y"
03:33:56 <quicksilver> you mean
03:33:58 <`nand`> I think the question here is clear
03:34:05 <quicksilver> "Is X definable in (Y without X)"
03:34:09 <`nand`> “can you define something which behaves identically to seq without using seq, in Haskell”
03:34:22 <quicksilver> otherwise it would be a vacuous thing to say.
03:34:53 <quicksilver> this strikes me as a silly thing to argue about because you were right about your main point (that seq doesn't specify order)
03:34:56 <srhb> > let foo a b = b `seq` a `seq` b in foo undefined (error "foo")
03:34:58 <lambdabot>   *Exception: foo
03:35:19 <srhb> But equality for bottom is a bit weird to use for defining anything.
03:35:38 <srhb> And differerent bottoms is weird, too.
03:36:30 <quchen> Well I neither agree with the "widely understood" part not the "vacuous" one, but I don't think this discussion leads to anything. I shall halt now.
03:36:36 <`nand`> srhb: case ... of () -> ... -- shouldn't ever be optimized out, should it? It could be ⊥ instead of ()
03:36:47 <`nand`> unless the compiler can prove that it isn't ⊥, I guess
03:36:54 <srhb> `nand`: Yeah.
03:38:01 <srhb> Oh, the obvious conclusion from the rewrite is that it _only_ has meaning if b is bottom.
03:38:04 <srhb> Right?
03:38:14 <srhb> (Ie. it only makes a difference in that case)
03:38:18 <`nand`> I haven't found a counterexample to my custom ‘seq’ yet (where it behaves differently to GHC's seq), but I don't know if it actually forces strictness properly, I'll try implementing foldl'
03:38:21 <srhb> In which case your program crashes anyway.
03:38:41 <quicksilver> `nand`: try compiling it, and try it on a functio
03:38:54 <`nand`> quicksilver: oh, yeah
03:39:10 <srhb> So if you hand-wave that all bottoms are the same (I know they're not) it still means seq a b
03:39:17 <`nand`> I should try compiling it instead of using the interpreter :)
03:40:48 <`nand`> quicksilver: doesn't crash; main = print $ (\x -> x+x) `myseq` 3
03:41:24 <quicksilver> interesting.
03:41:32 <quicksilver> I don't know how that works but I'm interested that it does ;)
03:41:53 <`nand`> @src foldl'
03:41:53 <lambdabot> foldl' f a []     = a
03:41:53 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
03:42:00 <quicksilver> what about print $ (error "boom" :: Int -> Int) `myseq` 3
03:44:46 <`nand`> my foldl'' works as well as foldl' when it comes to stritness
03:45:19 <`nand`> quicksilver: both versions error with "boom"
03:45:40 <`nand`> GHC's seq and mine. Speaking of which, isn't that an error with GHC's as well?
03:45:50 <srhb> No, that's correct.
03:45:53 <`nand`> okay
03:46:00 <quchen> `nand`: quicksilver's example should evaluate to 3 I think
03:46:00 <srhb> Why would it be an error?
03:46:14 <`nand`> since functions are already in WHNF or whatever
03:46:18 <srhb> Oh, right.
03:46:38 <`nand`> quchen: might be an issue with GHC then
03:46:55 <quchen> Hm? What might be an issue
03:47:09 <srhb> That it doesn't evaluate to 3
03:47:22 <srhb> though if you let foo a = undefined, then seq foo 3 is 3
03:47:24 <`nand`> using `seq` instead of `myseq` errors with "boom" instead of printing 3
03:47:34 <quchen> Huh?
03:47:52 <quchen> @src myseq
03:47:52 <lambdabot> Source not found. Take a stress pill and think things over.
03:48:03 <`nand`> myseq a b = case unsafeCoerce a of () -> b
03:48:05 <srhb> Is it perhaps becuase you're lying and the function "constructor" isn't really there?
03:48:08 <quicksilver> no, quchen, `nand` boom is correct.
03:48:13 <quicksilver> so that's interesting.
03:48:21 <quicksilver> `nand`'s implementation works very well then
03:48:26 <`nand`> :)
03:48:54 <quicksilver> I think the exact reason why requires deeper knowledge about the GHC runtime that I have
03:48:56 <srhb> quicksilver: Could you explain why seq undefined :: Int -> Int is an error while seq foo where foo a = undefined isn't?
03:48:57 <`nand`> shachaf: you're the only core hacker I know, can you find a way to make them differ?
03:49:01 <srhb> Ok :)
03:49:08 <quchen> quicksilver: Eh, right, if he had used "seq" it should be 3, for reasons discussed above
03:49:18 <quicksilver> quchen: no, with seq it would also be boom.
03:49:30 <quicksilver> my arguments were saying "this is why some people don't like seq on functions"
03:49:36 <quicksilver> but there is no doubt that that is what it does.
03:49:44 <quchen> Yes? Well then I just stopped understanding the "fix seq" we talked about earlier.
03:49:56 <quicksilver> > (error "boom" :: Int -> Int) `seq` 3
03:49:56 <`nand`> > fix seq
03:49:57 <lambdabot>   *Exception: boom
03:49:57 <lambdabot>   can't find file: L.hs
03:50:02 <`nand`> > fix seq
03:50:03 <lambdabot>   No instance for (GHC.Show.Show (b0 -> b0))
03:50:03 <lambdabot>    arising from a use of `M13742...
03:50:08 <`nand`> oh right
03:50:12 <`nand`> > fix seq 3
03:50:14 <lambdabot>   3
03:50:15 <quicksilver> quchen: a partially evaluated function is not a call to error.
03:50:31 <quicksilver> you correctly pointed out that a partially evaluated function is never _|_.
03:50:41 <srhb> Right, then my intuition was correct.
03:50:53 <`nand`> fix myseq works as well :)
03:50:59 <quchen> Arr I assumed "error X :: a -> a  ==  \a -> error X" or something like that.
03:51:01 <quchen> Nevermind
03:51:02 <srhb> Understanding undefined :: Int -> Int isn't _really_ a partially evaluated function.
03:51:14 <quicksilver> `nand`: I wonder if your implementation crashs if you pass it an unboxed value
03:51:19 <quicksilver> but I'm not sure if that's even possible.
03:51:43 <quicksilver> I think the compiler will see that it is a proper function which requires boxed arguments and box them up.
03:51:44 <`nand`> I don't know how to test that, can you conjure up an example?
03:51:48 <quicksilver> no, I can't ;)
03:52:14 <quicksilver> I'm trying to think of things whose runtime representation is different from ()
03:52:28 <quicksilver> I'm still surprised function didn't work (functions are not data, the runtime rep is different)
03:52:35 <srhb> Wouldn't it be simpler to dump it to core and see what happens?
03:56:40 <quchen> Does Travis-CI say what it is at some point?
03:56:53 <quchen> I always see the build report in #h-lens, but the website is as uninformative as it gets
03:57:08 <srhb> Hm, no idea actually.
03:57:24 <quchen> Does it check Github for changes, fetches and builds automatically or something?
03:58:04 <`nand`> hmm
03:58:05 <srhb> Yeah.
03:58:17 <srhb> You create one of them fancy service hooks on github
03:58:21 <srhb> That causes it to trigger.
03:59:41 <quchen> Right! You just have to click on Blog | Getting started. Just where docs are supposed to be!
04:00:14 <supki> also, you can click Docs
04:00:15 <quchen> (Bonus points for "getting started" delivering the only explanation of what the service actually does)
04:01:15 <quchen> I remember websites having something like "hello this is what this site is about" on the home page.
04:01:30 <`nand`> quicksilver: I can't pass a primitive type to ‘seq’, kind mismatch (seq expects *, not #)
04:01:35 <srhb> Which is really annoying if you know what it's for and you want the _actual_ front page. Where did cookies go?
04:01:40 <`nand`> which sort of makes sense, considering it's already primitive
04:02:09 <srhb> "Have you not been here before? Cool, here's the info on what's on. Have you? Let me not bother you with pointless information"
04:02:17 <quicksilver> `nand`: nod, that makes sense.
04:02:24 <`nand`> quchen: I remember needing ages to get any sort of information out of travis
04:02:34 <`nand`> the website is ridiculously confusing
04:02:36 <`nand`> and uninformative
04:03:07 <quchen> I really wonder why nobody's making money off that. Knowing a website that sucks is usually a goldmine.
04:03:56 <liyang> quchen: if you don't know what travis does, then it's not for you.
04:04:12 <liyang> (Avoid success at all costs &c. &c.)
04:04:19 <`nand`> haha
04:05:08 <quchen> liyang: I knew it builds stuff. I'd like to know the details.
04:05:13 * liyang doesn't understand why the landing page shows you other people's projects. He really does not care…
04:05:25 <`nand`> imo the best part is how the website is simply completely blank if you have noscript disabled
04:05:29 <`nand`> enabled*
04:05:32 <srhb> Even if you're logged in?
04:05:36 <quchen> And a continuously updated timer for the builds of those projects. Hey I know Javascript!
04:05:42 <srhb> ...
04:06:37 <quchen> `nand`: Clearly if you don't have Javascript you're outdated etc pp
04:06:44 <quchen> Greetings to crawlers
04:07:08 <liyang> quchen: don't you know what continuous integration means?!?
04:07:12 <`nand`> quchen: the website is so slow for me that firefox asks me if I want to halt the scripts
04:07:29 <quchen> liyang: nope.
04:07:49 <liyang> (It's a real analysis thing. Ask your local mathematician.)
04:07:58 <quchen> I am a local mathematician.
04:08:09 <quchen> Thanks for the pun though.
04:08:25 <no-n> can you not create operators ending with '
04:08:36 <quchen> no-n: ' is sort of a letter in Haskell.
04:08:36 <liyang> no-n: ' is a letter. :<
04:08:42 <no-n> ah
04:09:06 <quchen> It's a shame, because I would totally love to have operators like  :'(
04:09:18 <no-n> yes
04:09:32 <no-n> but the trade-off is functions like that, which is nice
04:09:35 <liyang> You can still have :'< — it's even grumpier.
04:09:39 <`nand`> liyang: haha
04:09:51 <quchen> You can? I don't think so
04:09:55 <`nand`> “don't” is the best function name
04:09:56 <quchen> :-< works though
04:10:00 <quchen> :D
04:10:25 <tharper> LOL
04:10:29 <tharper> that is amazing
04:10:32 <liyang> quchen: oh, you can't. I've no idea why I thought that. :'<
04:10:54 <quchen> liyang: Maybe there's some other Unicode '
04:11:16 <quchen> (Maybe is Unicode speech for "of course") ;-)
04:11:23 <liyang> $ g ':<' | wc -l … 7
04:11:33 <liyang> s/g/git grep/
04:14:26 <liyang> quchen: you have all of ′″‴
04:18:04 <quchen> @let (☠) = undefined
04:18:06 <lambdabot>  Defined.
04:18:20 <quchen> > seq ☠ 2
04:18:20 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
04:18:24 <quchen> > seq (☠) 2
04:18:24 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
04:18:29 <quchen> :-(
04:20:20 <arkeet> ☃
04:23:28 <`nand`> lambdabot really needs to begin accepting UTF-8 :)
04:23:33 <`nand`> if only we had a maintainer..
04:23:59 <structuralist> What are smart things to do when code starts looking like a complex pile nested cases?
04:25:03 <quicksilver> (1) change more of it into one big case
04:25:14 <quicksilver> (2) factor commonly occuring case patterns into combinators
04:25:22 <quicksilver> those are kind-of opposite
04:25:46 <aCube> (3) Search for a package that provides these combinators
04:26:52 <arkeet> (4) monads!
04:26:59 <arkeet> (actually this is a special case of 2)
04:31:51 <`nand`> arkeet: hehe
04:32:02 <`nand`> (3) is the lazy version of (2)
04:32:42 <aCube> or maybe (5) lens ?
04:32:59 <`nand`> (3) is a special case of (5)
04:38:58 <nomeata> Hi. Someone knowledgable about compiling stuff dynamically that can help with this problem: https://lists.debian.org/debian-haskell/2013/03/msg00031.html
04:48:10 <structuralist> took suggestion (1); thanks!
04:49:39 <`nand`> (6) post code here as an optimization challenge
04:51:27 <RichyB> `nand`: tell dons that it's on the shootout. :)
04:53:01 <donri> (7) use the magic of data-type generics to remove the whole case. this is a special case of (5) :p
04:54:37 * bxc sighs at "ghc: panic! (the 'impossible' happened)" in the bowels of some NDA code
04:55:16 <donri> the impossible happened, and you can't tell anyone!
04:55:32 * bxc nods
04:56:10 <t7> is there 'elems' like [a] -> [a] -> Bool ?
04:56:45 <donri> @hoogle [a] -> [a] -> Bool
04:56:45 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
04:56:45 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
04:56:45 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
04:56:54 <supki> @ty all . flip elem
04:56:55 <lambdabot> Eq a => [a] -> [a] -> Bool
04:56:57 <johnw> bxc: can you describe the context at all?
04:57:05 <johnw> i've been there too
04:58:58 <bxc> i had an implementation of non empty lists that I just swapped out in a source file for the semigroups NonEmpty implementation
04:59:07 <bxc> and i now get this error
04:59:10 <bxc> ...
05:00:04 <hpaste> bxc pasted “impossible” at http://hpaste.org/84314
05:01:30 <bxc> that test file is using a bunch of LANGAUGE features DeriveGeneric StandaloneDeriving ScopedTypeVariables FlexibleInstances MultiParamTypeClasses, the last two because smallcheck seems to need it now
05:04:06 <bxc> if i take out the smallchecks, it compiles
05:04:25 <bxc> smallchecks and multiparamtypeclasses and flexible instances, and a deriving Serial.
05:04:27 <supki> http://hackage.haskell.org/trac/ghc/ticket/5884
05:04:28 * bxc digs some more
05:04:53 <bxc> that sounds like it!
05:04:54 <supki> bxc: you should try not so ancient compiler :p
05:05:25 <bxc> ha
05:05:42 <bxc> just whatever is in my distro
05:06:37 <bxc> i guess its time to build a dev VM for this project.
05:07:06 * bxc hadn't realised he'd fallen so far behind
05:15:30 <bxc> actually i'll just remove the smallcheck stuff, because I want people ot be able to run this code iwth a distro ghc
05:17:13 <Xaratas> what was the name of the module to get the warnings which hpaste has in gch(i)?
05:18:35 <MasseR> Xaratas: Are you talking about HLint program?
05:19:28 <Xaratas> yes
05:21:00 <mikeplus64> :t ContT
05:21:01 <lambdabot> ((a -> m r) -> m r) -> ContT r m a
05:26:07 * hackagebot http-conduit-browser 1.8.1.1 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-1.8.1.1 (MikhailKuddah)
05:30:49 <t7> anyone written A* search in haskell?
05:31:07 * hackagebot fields-json 0.2.2 - Abusing monadic syntax JSON objects generation.  http://hackage.haskell.org/package/fields-json-0.2.2 (MagnusCarlsson)
05:31:13 <tdammers> t7: probably ;)
05:31:22 <t7> ah theres one on hackage
05:31:35 <tdammers> I was *this* close to suggesting google
05:32:04 <t7> it has almost exactly my function stub :)
05:36:07 * hackagebot http-conduit-browser 1.9.0.1 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-1.9.0.1 (MikhailKuddah)
05:50:27 <t7> @pl f a b = c
05:50:27 <lambdabot> f = const (const c)
05:50:39 <hpaste> fxr pasted “tcp payload” at http://hpaste.org/84315
05:50:58 <fxr> hi, is there any way to get rid of the Nothing values in this paste?
05:52:07 <fxr> I wanna try to simplify it
05:52:23 <Botje> use monads!
05:53:09 <tdammers> fxr: write or find a function that converts Eithers to Maybes, then run the calculation in the Maybe monad
05:53:22 <Botje> or even run the entire thing in Either e first.
05:53:32 <tdammers> or that
05:53:33 <fxr> hmm
05:54:01 <fxr> can you give me an example?
05:54:25 <Botje> do { (_,r) <- runGet parseEthernetFrame frame; (_,hl,pl) <- runGet ... r; u <- runGet getTcpPacket ...; return u }
05:54:38 <fxr> aha ok
05:54:50 <fxr> I may prefere to change the return type to Eiter a
05:54:55 <fxr> thank you
05:55:09 <Botje> you can still bind that to a variable and use a case again.
05:56:20 <fxr> is it possible to get rid of runGets also?
06:01:58 <hpaste> fxr annotated “tcp payload” with “tcp payload (annotation)” at http://hpaste.org/84315#a84317
06:02:23 <quchen> That's hard to tell without knowing what runGet does.
06:02:33 <quchen> But probably not
06:02:46 <fxr> it uses Data.Serialize.decode
06:06:08 * hackagebot som 3.0 - Self-Organising Maps  http://hackage.haskell.org/package/som-3.0 (AmyDeBuitleir)
06:06:10 * hackagebot matrix 0.1.1 - A native implementation of matrix operations.  http://hackage.haskell.org/package/matrix-0.1.1 (DanielDiaz)
06:06:50 <hpaste> “Anonymous Coward” annotated “tcp payload” with “tcp payload (annotation) (annotation)” at http://hpaste.org/84315#a84318
06:06:59 <powergiant> Hey guys. How would you convert an int to a float on the fly ? As in I need to length of a list in the form of a float
06:07:10 <quchen> powergiant: round, floor, ceil?
06:07:22 <quchen> Ah wait
06:07:22 <Jonno_FTW> fromIntegral?
06:07:23 <quchen> fromIntegral
06:07:40 <powergiant> oh... I should have realized. Thanks!
06:07:40 <quchen> fxr: ^^^^^^ is a non-proofread version.
06:07:52 <Jonno_FTW> > (fromIntegral $ length [1..5]) / sum [1..5]
06:07:54 <lambdabot>   0.3333333333333333
06:07:55 <fxr> thanks
06:08:10 <quchen> I don't like to rely on 'fail
06:08:12 <quchen> '
06:08:33 <quchen> So the checks are made explicitly. It's still quite ugly code like that though
06:08:35 <fxr> but I think there should be a way to compose Gets more nicely.
06:08:49 <quchen> Well I don't know the corresponding lib
06:09:19 <fxr> aha it's Hans, http://hackage.haskell.org/package/hans
06:10:21 <quchen> That package has no docs online :-(
06:10:41 <fxr> yeah sorry I just realized it has no docs
06:11:05 <fxr> but it's basically a Get Monad
06:16:29 <hpaste> quchen annotated “tcp payload” with “tcp payload (more refactoring)” at http://hpaste.org/84315#a84320
06:17:13 <quchen> You're familiar with the Maybe/Either monads, right?
06:18:57 <fxr> yup
06:20:42 <quchen> You could still reduce the getPacket in the code above, but I think it's clearer this way
06:25:34 <fxr> quchen: thank you very much for your time
06:30:31 <quchen> The general advice here is "if you indent past two levels using Either or Maybe, you should try using their monad instance"
06:33:09 <aCube> Also, the package errors on hackage might be worth a look
06:34:25 <quchen> Right, it fails to build. That would explain the missing Haddock
06:37:36 <hpaste> amatsu pasted “List comprehension” at http://hpaste.org/84321
06:37:49 <amatsu> Any way to rewrite this in Applicative or Monad style?
06:40:03 <hpaste> “Anonymous Coward” annotated “List comprehension” with “List comprehension (annotation)” at http://hpaste.org/84321#a84322
06:41:36 <hpaste> Quchen annotated “List comprehension” with “List comprehension - What you want is a filter.” at http://hpaste.org/84321#a84323
06:42:35 <amatsu> quchen: ah, thanks, I totally missed that!
06:44:21 <hpaste> Quchen annotated “List comprehension” with “What you want is a filter. (Two lines left)” at http://hpaste.org/84321#a84325
06:55:28 <dario> why do people call their functions in where-clauses "go" so often?
06:56:04 <quchen> Convention. Like foo bar.
06:56:05 <ocharles> http://stackoverflow.com/questions/5844653/haskell-why-the-convention-to-name-a-helper-function-go
06:56:13 <ocharles> dario ^
06:56:21 <quchen> "go" basically means "worker function that doesn't deserve a better name".
06:56:58 <Jonno_FTW> :t fromIntegral
06:57:00 <lambdabot> (Integral a, Num b) => a -> b
06:57:24 <Jonno_FTW> :t 5.0/2
06:57:26 <lambdabot> Fractional a => a
06:57:49 <t7> i wish there an idiomatic style that people used. Everyone's code looks totally different
06:57:55 <linduxed> hey guys
06:58:10 <linduxed> is there some nice way to make this shorter? https://gist.github.com/5196309
06:58:49 <t7> (`elem` [lowNodeA, lowNodeB ...])
06:59:55 <linduxed> t7: hmm, ok, i'll see if i can fit that in
07:00:44 <supki> > (2,8) & anyOf each (`elem` [1..5])
07:00:46 <lambdabot>   True
07:00:56 <supki> > (7,8) & anyOf each (`elem` [1..5])
07:00:58 <lambdabot>   False
07:01:18 <linduxed> supki: i've completely forgotten what & does
07:01:24 <supki> flip ($)
07:01:49 <supki> > (2,8) & anyOf both (`elem` [1..5])
07:01:51 <lambdabot>   True
07:02:47 <hpaste> Quchen pasted “@linuxed refactoring” at http://hpaste.org/84327
07:02:53 <linduxed> supki: can't find & with hoogle :-/
07:03:01 <quchen> & = flip $
07:03:06 <supki> linduxed: lens
07:03:06 <Kinnison> linduxed: I think it's a lens trick
07:03:12 <quchen> x & f = f x
07:03:14 <linduxed> oooh
07:03:56 * linduxed hasn't started using lens yet
07:04:03 <linduxed> but i hear about it quite often
07:04:23 <johnw> usingLens .~ True $ linduxed
07:04:46 <johnw> or, I guess the new hotness is linduxed & usingLens .~ True
07:05:08 <linduxed> johnw: you lost me at .~
07:05:18 <johnw> .~ modifies through the lens
07:05:32 <Kinnison> linduxed: don't worry until you start playing with lens
07:05:43 <Kinnison> linduxed: Immediately you should drop what you're doing and shave the lens yak
07:08:31 <linduxed> why is hoogle failing me so hard now
07:08:34 <linduxed> ...
07:08:39 <linduxed> can't hoogle "each"
07:08:46 <linduxed> or "anyOf"
07:08:59 <supki> hoogle doesn't index lens :-(
07:09:05 <linduxed> :-(
07:09:12 <geekosaur> hoogle only indexes the bootlibs by default. try hayoo?
07:09:26 <johnw> linduxed: try https://www.fpcomplete.com/hoogle
07:09:37 <johnw> it indexes lens
07:10:22 <quchen> Hoogle? I don't think so
07:10:32 <quchen> Hayoo knows Lens, Hoogle doesn't as far as I know
07:10:32 <flo1> Is there a way to emit two token in alex?
07:10:54 <flo1> I try something like  <stateToSep1> "|" { (\y x -> do emit TokenAlternative y x; makeStateTo y x) `andBegin` stateTo }
07:11:00 <geekosaur> quchen, they pointed to a different hoogle instance; hoogle *can* index other libraries if someone did the necessary work...
07:11:01 <flo1> but doesn't work
07:11:14 <flo1> only emit the result of makeState
07:11:33 <quchen> geekosaur: Why doesn't Hoogle know Lens? Would it simply be an entry somewhere, or something more complex?
07:11:33 <linduxed> johnw: that worked
07:11:46 <quchen> geekosaur: Also what's a bootlib?
07:11:55 <geekosaur> bootlib = a library that ships with ghc
07:12:21 <SuperMeo> http://www.sponsokdo.com/index-216929.html
07:12:22 <quchen> Really? I thought it would index much more
07:12:45 <geekosaur> and what it would take is someone arranges for the hoogle instance to index more packages. I don't know why haskell.org/hoogle is limited to boot libraries
07:12:59 <geekosaur> but we keep losing the folks who maintain haskell.org...
07:13:20 <fryguybob> I think fp complete has a hoogle with lens.
07:13:21 <geekosaur> I think it's a spare time thing for someone at galois (or at yale?)
07:13:39 <fryguybob> http://fpcomplete.com/hoogle
07:13:44 <geekosaur> someone else could set up their own hoogle instance indexing more stuff; see the fpcomplete url previously posted for one such
07:13:55 <fryguybob> Oh, someone already posted that :D
07:14:01 <geekosaur> or if you install hoogle locally you can add anything you want to its database
07:17:21 <quchen> What's the difference between Hoogle and Hayoo anyway?
07:17:30 <quchen> Apart from having different results I mean
07:17:40 <quchen> Is there something one can that the other one cannot do?
07:17:50 <johnw> i think hoogle has a more sophisticated type search
07:18:11 <sopvop> What's your opinion, should I first type check and then transform source, or transform during typecheck?
07:18:32 <geekosaur> hoogle's type search is better, hayoos' name search is better
07:18:42 <geekosaur> so both are useful tools
07:18:44 <johnw> how is their name search better?
07:19:08 <quchen> And Hayoo indexes all of Hackage?
07:19:08 <johnw> (I ask this as someone who works on Hoogle and is looking to improve its name search)
07:19:30 <geekosaur> in my experience hoogle will pay more attention to the type than to a name if you don't have an exact match, so hayoo handles typoed/misemembered names better if you don't provide (enough of) a type
07:20:20 <geekosaur> although recent hoogle has gtten somewhat better in that area, I still find it to return a lot of useless stuff before the match I'm really looking for, so I still tend to start out with hayoo
07:20:33 <johnw> i've added "exact" searching to Hoogle, btw
07:20:33 <geekosaur> unless i'm actually looking for something by type instead of by name
07:20:49 <johnw> so that you can search for identifier "x" wherever it appears
07:21:05 <geekosaur> but most often what I have in mind is part of a name, not part of a type...
07:21:08 <johnw> ah
07:21:23 <johnw> the ranking algorithm for inexact matches could stand some improvement
07:21:32 <johnw> right now we simply rank exact over prefix over partial
07:21:41 <johnw> but we could do something better for ranking amount partials
07:21:47 <johnw> among*
07:21:48 <quchen> johnw: Another thing that is sometimes weird about Hoogle is how low it ranks packages compared to functions. For example, I'm often using it to search for the Map docs, but the actual package appears way down the list.
07:22:09 <quchen> Data.Map comes after all the functions containing "map" as a prefix
07:22:14 <geekosaur> (keep in mind that 95% or so of my searches are for something half-remembered from the huge disorganized mess that is xmonad-contrib :)
07:22:24 <johnw> isn't that because the package is named "containers"?
07:23:01 <quchen> johnw: I don't know. But even then, "data Map" is also down there
07:23:15 <geekosaur> so I know manes because there's a decent naming convention in place, but type searches get skewed by the oddball typing around layouts
07:23:19 <geekosaur> *names
07:23:26 <quchen> I think exact matches should always rank first.
07:23:41 <johnw> Map +containers is the best way to jump to Map
07:23:44 <johnw> it will be the first hit
07:23:46 <johnw> but it's a lot to type
07:24:05 <johnw> exact matches do rank first, but types are apparently a different ball game
07:24:08 <johnw> this is something that should be fixed
07:24:20 <quchen> johnw: Why is it called containers anyway? That doesn't appear anywhere else. Why not call them modules?
07:24:23 <johnw> (and hoogle's definition of "exact", when not doing a true exact query, is case-insensitive
07:24:39 <johnw> quchen: i don't know, you'd have to ask the author of Map
07:24:45 <johnw> Map is in a package called "containers"
07:24:48 <quchen> It should probably be case insensitive
07:24:54 <quchen> Ah I see. Well then it makes more sense.
07:24:55 <johnw> i agree
07:25:05 <johnw> actually, that's a very easy change to make
07:25:27 <johnw> CaseExact < CI Exact < CasePrefix < CI Prefix < CasePartial < CI Partial
07:25:37 <johnw> making a note...
07:25:39 <quchen> CI?
07:25:43 <johnw> case insensitive
07:25:50 <quchen> Anyway, thanks for working on Hoogle, it's a great tool.
07:25:50 <supki> < ?
07:26:11 <johnw> sure!  i live in my local hoogle
07:26:12 * hackagebot phone-push 0.1.0 - Push notifications for Android and iOS  http://hackage.haskell.org/package/phone-push-0.1.0 (DavidFendrich)
07:26:13 <johnw> supki: s/</> :)
07:29:36 <johnw> quchen: http://newartisans.com:3030/?hoogle=Map&exact=1
07:29:45 <johnw> as you can see, there are many things called Map
07:29:55 <johnw> i guess in this case, types should come before modules?
07:30:05 <quchen> Oh boy :-(
07:30:17 <quchen> That's your private Hoogle right?
07:38:02 <Xaratas> ok, maybe this foldl has a space leak, but its definitly faster than foldr
07:42:50 <byorgey> Xaratas: I have no idea what you are doing, but there's a 99.9% chance that you want to use foldl' instead of foldl
07:42:57 <johnw> quchen: there: http://hoogle.newartisans.com
07:43:04 <johnw> now with nginx to serve the static bits
07:43:20 <johnw> that hoogle indexes 3488 packages
07:43:40 <johnw> which is much more than the one we run at FP Complete (whether that's good or bad depends on what you're looking for)
07:45:50 <davorak> jmcarthur: Can you link to the code you were talking about, arbitrary number of channels for pipes? ref: http://ircbrowse.net/browse/haskell?id=15333782&timestamp=1363473328#t1363473328
07:47:13 <quchen> davorak: You may want to @tell him that.
07:51:12 * hackagebot html-truncate 0.3.0.0 - A HTML truncator  http://hackage.haskell.org/package/html-truncate-0.3.0.0 (MarcelRuegenberg)
07:51:14 * hackagebot blaze-html-truncate 0.3.0.0 - A truncator for blaze-html  http://hackage.haskell.org/package/blaze-html-truncate-0.3.0.0 (MarcelRuegenberg)
07:51:43 <davorak> quchen: lambda bot function? syntax: @tell <name> <msg> ?
07:52:03 <hiptobecubic> davorak, yes
07:52:16 <davorak> hiptobecubic: thanks
07:52:28 <hiptobecubic> @tell davorak imma lammabort
07:52:28 <lambdabot> Consider it noted.
07:52:50 <davorak> @tell jmcarthur  Can you link to the code you were talking about, arbitrary number of channels for pipes? ref: http://ircbrowse.net/browse/haskell?id=15333782&timestamp=1363473328#t1363473328
07:52:50 <lambdabot> Consider it noted.
07:53:11 <quchen> Next time he says something in a Lambdabot channel he'll get a message.
07:53:19 <quchen> @tell davorak foobar
07:53:19 <lambdabot> Consider it noted.
07:53:20 <hiptobecubic> Personally, I prefer mesgserv
07:53:43 <hiptobecubic> or is it memoserv
07:53:48 <hiptobecubic> the latter i think
07:53:49 <yitz> @ask davorak Did you know that the @ask and @tell commands do the same thing?
07:53:49 <lambdabot> Consider it noted.
07:54:02 <quchen> davorak: hello.
07:54:08 <quchen> Lambdabot: You have 10202023 new messages
07:54:41 <davorak> quchen: hi
07:54:42 <lambdabot> davorak: You have 3 new messages. '/msg lambdabot @messages' to read them.
08:01:14 <skp_> hey
08:01:30 <skp_> why Array isn’t in the Applicative class?
08:01:39 <skp_> I need it to :(
08:01:55 <srhb> skp_: What kind of arrays?
08:02:02 <skp_> base array
08:02:13 <skp_> Data.Array
08:02:15 <byorgey> skp_: what should 'pure' do?
08:02:46 <skp_> byorgey: fulfil the infinite array with the same value ?
08:02:53 <skp_> or create a singleton arary
08:02:54 <skp_> array*
08:02:59 <skp_> I don’t know
08:03:06 <byorgey> skp_: there is no such think as an infinite array
08:03:22 <skp_> so singleton array
08:03:23 <skp_> like list
08:03:27 <byorgey> you could have it create a singleton, if you want the Applicative instance which works the same way as the list monad
08:03:30 <skp_> pure a = [a]
08:04:00 <geekosaur> keep in mind that arrays are fixed size (which is why they are not infinite), a singleton array would restrict you to only working woth singleton arrays
08:04:13 <geekosaur> if you are expecting array to be list, you're misunderstanding either arrays or lists
08:04:17 <geekosaur> (or both)
08:04:30 <skp_> geekosaur: actually
08:04:42 <skp_> I’m writing a matrix list – a tiny one
08:04:51 <byorgey> no, an Applicative instance for arrays which acts like the list monad could make sense
08:05:10 <byorgey> skp_: note that the types from the 'vector' package have Applicative instances
08:05:12 <byorgey> so maybe you want to use that instead of Data.Array
08:05:37 <skp_> hm
08:05:49 <skp_> I want finite array actually
08:05:58 <byorgey> that's the only kind there is.
08:06:21 <skp_> I’m writing a matrix *lib* – not list huhu – and I want to use array to implement matrices
08:06:26 <skp_> for now I have something like
08:06:37 <byorgey> skp_: why are you writing a matrix library?  just for fun?
08:06:37 <skp_> data Mat33 a = Mat33 a a a a a a a a a
08:06:39 <skp_> it’s hm
08:06:41 <skp_> loled
08:06:49 <skp_> byorgey: kinda yes
08:06:49 <yitz> i think nowadays people use vector whenever they used to use array. is there any case where array has an advantage over vector?
08:07:08 <geekosaur> array is lower level and sometmes still used for raw speed, I think
08:07:09 <skp_> vector you say
08:07:18 <geekosaur> but as such it's also much more primitive and harder to use
08:07:20 <byorgey> yitz: array does multidimensional indexing more conveniently.
08:07:26 <byorgey> geekosaur: what? I thought it was the other way around
08:07:33 <byorgey> vector is highly optimized
08:07:35 <davorak> quchen: Thanks for the pointer, I added a note to the irc wiki page about it.
08:07:48 <yitz> geekosaur: is it really faster? they worked pretty hard at getting vector optimized, getting fusion to work, etc.
08:07:50 <geekosaur> vector is highly optimized but array is rawer
08:07:58 <skp_> maybe I just can stay with aa a a a a a a a a a a a a a :D
08:08:03 <supki> yitz: lazy arrays are useful for simple dynamic programming tasks
08:08:04 <skp_> a a a a a MATRIX
08:08:10 <geekosaur> they worked hard to get vector performance on a par with what you get from array, yes
08:08:22 <byorgey> geekosaur: I see.
08:08:32 <skp_> it’ll be faster than vector for sure
08:08:34 <geekosaur> but array you get it because they're primitive raw operations, vector needed a lot of optimization to catch up while being less raw
08:10:43 <skp_> imagine you have two arrays
08:10:51 <skp_> and like something like
08:11:00 <skp_> (+) <$> a <*> b
08:11:03 <skp_> how could you do that?
08:11:15 <yitz> supki: perhaps. truth is, i've almost never needed such deep optimization over such vast amounts of data that there has been any reason to use array or vector over more functional containers.
08:11:54 <byorgey> skp_: the only instance which makes sense would be to get out an array of length (length a * length b) with all possible sums of pairs from the two arrays
08:12:09 <byorgey> you can easily write an Applicative instance yourself if you want
08:12:33 <skp_> hm
08:12:33 <skp_> ok
08:12:35 <skp_> thank you
08:12:38 <skp_> I see
08:15:25 <eacameron1> I have a data type that doesn't take any type parameters, can I make it an instance of Functor? (i.e. data MyType = A | B | C...instance Functor MyType where...)
08:16:20 <quchen> eacameron1: Sure, but I don't think that'll be useful
08:16:36 <eacameron1> well A B C do have fields of fixed types
08:16:40 <eacameron1> *quchen
08:16:42 <quchen> "fmap _ = id" would be a valid instance
08:17:13 <quchen> (Probably it is also the only valid instance)
08:17:33 <cztomsik> @pl \x -> x * x
08:17:33 <lambdabot> join (*)
08:17:34 <aCube> but the functor class doesn't allow instances of kind *
08:17:40 <Cale> eacameron1: No, you can't, because it doesn't have the right kind.
08:17:53 <Cale> However, you could add a dummy type parameter
08:18:07 <eacameron1> Cale: how would I do that?
08:18:10 <quchen> aCube: Right, you need a dummy type parameter
08:18:11 <Cale> (making it into a constant functor)
08:18:22 <Cale> data MyType a = ... the same stuff ...
08:18:24 <byorgey> eacameron1: the more important question is: why do you want to?
08:18:30 <Cale> instance Functor MyType where
08:18:37 <Cale>   fmap f x = x
08:18:44 <aCube> or: instance Monoid MyType where ...  and then use Const MyType as the Functor
08:18:48 <quchen> Wait, that doesn't work.
08:18:50 <byorgey> no, fmap x = x  won't work
08:18:52 <Cale> (actually, you may need to do a little more there)
08:18:56 <Cale> right, it won't
08:18:57 <byorgey> because x has the wrong type
08:19:03 <byorgey> you have to deconstruct and reconstruct the values.
08:19:14 <quchen> fmap _ = unsafeCoerce :>
08:19:18 <byorgey> fmap A = A; fmap B = B; ...
08:19:25 <eacameron1> byorgey: because I don't need a parameterized type: I'm wrapping a bunch of types (like Int, Double, String) so I can represent them all in the same list
08:19:29 <byorgey> or be evil as quchen is suggesting =)
08:19:34 <Cale> byorgey: of course, with the f parameter ;)
08:19:40 <byorgey> eacameron1: but why do you want it to be a Functor?
08:19:52 <byorgey> Cale: right, that too =)
08:19:52 <gynna> http://binaalbina84.wix.com/femeseekingmanadult
08:20:02 --- mode: ChanServ set +o Cale
08:20:18 <eacameron1> byorgey: because I want  to "blindly" apply functions to the innerds of my various wrappers
08:20:50 <eacameron1> byorgey: which might be the problem? ;)
08:21:07 --- mode: Cale set -o Cale
08:21:15 <byorgey> eacameron1: what do you mean by "blindly apply functions"?
08:21:31 <byorgey> can you give an example?
08:21:41 <byorgey> Functor is likely not what you want
08:21:46 <Cale> eacameron1: Yeah, a Functor instance won't really let you do that. It would let you apply functions to the insides of *polymorphic* containers.
08:21:50 <byorgey> s/likely/definitely/
08:22:05 <eacameron1> Cale: good point
08:22:12 <eacameron1> byorgey: I think you're right
08:22:14 <eacameron1> now that I ask
08:22:30 <Cale> eacameron1: You might want some kind of fold
08:22:41 <hpaste> Quchen pasted “@eacameron1” at http://hpaste.org/84329
08:22:50 <eacameron1> it makes sense now: If you don't have a type parameter, then there's nothing consistent between your types that fmap can do polymorphically
08:22:57 <quchen> The easier way of generating a heterolist is by making it a list of wrapped things.
08:22:59 <Cale> i.e. a function which replaces all the data constructors in your type with other appropriately-typed functions/values
08:23:52 <eacameron1> Cale: right: I've got that
08:24:11 <eacameron1> quchen: make sense (thanks)
08:24:50 <Cale> Let's say we're following along with that and have  data ABC = I Int | B Bool | C Char
08:24:51 <eacameron1> as usual, GHC tells me something true that I hadn't realized yet ;)
08:24:56 <Cale> and we write
08:25:44 <Cale> foldABC i b c x = case x of I z -> i z; B z -> b z; C z -> c z
08:26:27 <Cale> Then you could also write  toInt = foldABC id fromEnum ord
08:27:28 <eacameron1> Cale: wow...brevity
08:27:30 <Cale> (This sort of thing isn't always the best idea, but sometimes if you have many similar things, it can save lots of trouble pattern matching)
08:28:09 <eacameron1> Cale: I'll keep that in the back of my mind. I haven't had pattern matching explode on me yet: but if it does....
08:28:16 <Cale> It's even better once you have a recursive type
08:28:28 <eacameron1> I do
08:29:24 <Cale> data Nature a = Rock a | Stream a (Nature a) | Bush (Nature a) (Nature a)
08:30:05 <Taneb> Cale, that feels like a monad
08:30:36 <quchen> It does?
08:30:45 <Cale> foldNature r s b = f where f x = case x of Rock z -> r z; Stream z n -> s z (f n); Bush n n' -> b (f n) (f n')
08:31:13 <byorgey> you could make a Monad out of Nature, but it's not a particularly natural one
08:31:19 <Taneb> (it's completely irrelevant to the point Cale is trying to make)
08:31:31 <quchen> Looks more like comonad to me
08:31:38 <Taneb> quchen, things can be both
08:31:51 <quchen> What would be the monad instance?
08:31:57 <quchen> Conceptually I mean
08:31:58 <Cale> countRocks = foldNature (\x -> 1) (\x n -> n) (+)
08:31:58 <byorgey> there are probably several
08:32:15 <johnw> all depends on what it means to join X to Y, for each possible combination
08:32:26 <quchen> (Rock a) >>= f = Rock (f a)
08:32:29 <quchen> But then ..?
08:32:31 <Taneb> There are at least 4 ways of defining extract that I can see
08:33:17 <quchen> Taneb: Which ones? I see only two right now, and they both crash for cyclic natures :-(
08:33:19 <Cale> Don't forget that whatever you come up with has to obey the laws -- I'm not sure exactly what the right way of turning this into a monad would be.
08:33:59 <Taneb> quchen, combinations of left/right on bushes, first/deeper on streams
08:34:04 <byorgey> see http://article.gmane.org/gmane.comp.lang.haskell.cafe/91287  for inspiration
08:34:20 <quchen> Taneb: Right, but then extracting an infinite nature won't work in 3 of those
08:34:29 <quchen> Eh, all 4
08:34:48 <quchen> Should break some laws shouldn't it?
08:34:58 <Taneb> There's no rule about it not being _|_
08:35:29 <Cale> (But yeah, there's usually some way)
08:35:57 <quchen> I'm not sure about this. "extend extract = id" for example.
08:37:46 <quchen> Or even clearer: "extract . fmap f = f . extract" doesn't hold. The RHS crashes on extracting an infinte tree structure, the left doesn't necessarily (imagine fmap f _ = const something)
08:38:34 <quchen> Ah wait no, if f = const the RHS works out as well
08:38:36 <quchen> Hmpf
08:41:29 <edtsech> hey guys, I need your help, which modules I have to import to get MaybeT included?
08:41:55 <supki> @hoogle MaybeT
08:41:55 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
08:41:55 <lambdabot> Control.Monad.Trans.Maybe MaybeT :: m (Maybe a) -> MaybeT m a
08:41:55 <lambdabot> Control.Monad.Trans.Maybe newtype MaybeT m a
08:44:20 <edtsech> thanks!
09:20:07 <armlesshobo> Does the T in ErrorT stand for Transformer?
09:20:55 <Cale> armlesshobo: Yeah
09:20:57 <mikurubeam> Why is ErrorT called ErrorT instead of EitherT?
09:21:11 <simpson> mikurubeam: There is a real EitherT in the either package.
09:21:27 <mikurubeam> Ah!
09:21:32 <mikurubeam> simpson: ty
09:23:04 <yitz> mikurubeam: historically, there was some confusion surrounding the names of the types/typeclasses Error, ErrorT, Either, and EitherT. fourtunately, it has now been cleaned up, but there may be a little bump or two left around.
09:24:07 <quchen> Also exceptions are called errors, errors are called exceptions and the monad instance for Either is Error which is an exception. ;-)
09:25:03 <quicksilver> because that particular distinction between exception and error is a rather modern notion and not universally accepted.
09:25:24 <quicksilver> although it's certainly convenient to have different words available to distinguish catchable things from uncatchable things
09:26:58 * geekosaur tempted to @remember quchen there
09:33:24 <shachaf> `nand`: Did you figure out whatever you were figuring out?
09:34:33 <timtom> @unmtl MaybeT (Data.Acid.Query DBState) Category
09:34:33 <lambdabot> Data.Acid.Query DBState (Maybe Category)
09:48:31 <fizbin> Anyone have any good code pattern/library to use when looking at having a collection of similar data structures that serialize to and deserialize from XML?
09:54:06 <johnw> fizbin: i didn't quite follow that
09:54:16 <johnw> what do you want to do?
09:56:15 * hackagebot warp 1.3.7.5 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.7.5 (MichaelSnoyman)
10:01:01 <fizbin> johnw: I'm looking at needing to write two programs, one which creates a somewhat complicated data structure, the other which takes that data structure as input. It occurs to me that if there were a convenient library for round-tripping a haskell data structure to XML (we're not _absolutely_ committed to XML as the storage format, but we'e done our initial spec. work assuming that), I should use that and avoid having to write two 
10:03:11 <srhb> @hoogle many
10:03:12 <lambdabot> Text.ParserCombinators.ReadP many :: ReadP a -> ReadP [a]
10:03:12 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
10:03:12 <lambdabot> Text.ParserCombinators.ReadP many1 :: ReadP a -> ReadP [a]
10:05:48 <srhb> Hum. Alternative is weird. What on earth does many (Just 1) mean?
10:05:59 <elliott> not much
10:06:13 <srhb> No, I couldn't think up something meaningful.
10:06:42 <shachaf> It means some (Just 1) <|> Just []
10:08:33 <srhb> So the only way make many terminate is if it's argument is empty? O_o
10:08:44 <shachaf> No.
10:08:51 <Kinnison> I have a fairly awkwardly open question -- What is the simplest web framework to get started with in Haskell?  In particular, I'm looking for something where handlers can do IO and where I'm not going to drown in dependencies just to get started.
10:08:55 <shachaf> But it's not very useful with Maybe.
10:09:14 <shachaf> @where web
10:09:14 <lambdabot> #haskell-web | #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
10:09:26 <srhb> Kinnison: Can't handlers do IO in all of them?
10:09:30 <srhb> shachaf: What's a useful example?
10:09:34 <sproingie> speaking of yesod, i cant seem to build it from hackage
10:09:36 <parcs> Kinnison: happstack
10:09:38 <shachaf> srhb: Parsers.
10:09:38 <sproingie> some error with shakespeare-js
10:09:44 <srhb> Ah, yes.
10:09:52 <Kinnison> parcs: thanks.  I shall examine it
10:10:03 <sproingie> not at the machine where it's failing so can't remember exactly what the issue was
10:10:10 <srhb> Kinnison: There's a very friendly #happs channel for #happstack. They helped me get started. :)
10:10:24 <Kinnison> seems to me that happstack-lite is a good place to start then
10:10:31 <srhb> That's probably true for all of them, though I don't know the other channels.
10:14:12 <srhb> :t sequence
10:14:13 <lambdabot> Monad m => [m a] -> m [a]
10:14:25 <srhb> @hoogle [f a] -> f a
10:14:26 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
10:14:26 <lambdabot> Test.QuickCheck.Gen oneof :: [Gen a] -> Gen a
10:14:26 <lambdabot> Test.QuickCheck oneof :: [Gen a] -> Gen a
10:14:53 <timtom> Kinnison: I looked into web frameworks a couple of days ago. I am by no means an expert, but i also agree that happstack-lite might be a good starting place
10:15:21 <Kinnison> timtom: I'm just poking at an idea, and fancied doing it in haskell rather than python :-)
10:16:29 <timtom> Kinnison: same here... Yesod seems to to lots of template haskell magic which i personally don't like
10:16:43 <mreh> this place gets bigger every time I come back
10:17:01 <sproingie> do all the haskell web stacks use WAI?
10:17:14 <srhb> Is there some function to combine my [Alternative a] with <|>?
10:17:20 <srhb> fold.. derp
10:17:21 <Kinnison> timtom: I like the idea of Yesod, but not to hack something up as a PoC
10:17:29 <fizbin> :t fold
10:17:30 <lambdabot> (Foldable t, Monoid m) => t m -> m
10:17:38 * srhb is slow
10:18:16 <timtom> Kinnison: I just want to write a REST-Api and let a html5/js client do the rest - so i don't need all the templating stuff, etc...
10:19:19 <elliott> srhb: probably not fold?
10:19:22 <srhb> No?
10:19:28 <elliott> (f a) isn't necessarily a Monoid for all Alternative f, a
10:19:40 <srhb> Huh.
10:19:45 <elliott> hm, I wonder if there is a monoid somewhere semi-standard wrapping that...
10:19:57 <srhb> > foldr (<|>) empty [Nothing, Just 4, Just 5]
10:19:59 <lambdabot>   Just 4
10:19:59 <elliott> foldr (<|>) empty should work, but might not be great on tree structures (fine for [] though)
10:20:03 <srhb> Looks right.
10:20:06 <Kinnison> timtom: :-)
10:20:10 <srhb> That's what I need I think.
10:20:58 <mreh> :t fold
10:21:00 <lambdabot> (Foldable t, Monoid m) => t m -> m
10:21:19 <mreh> <|> is a monoid on applicative functors
10:22:25 <srhb> Is there some notion of "matchable functions" in the sense that I want to foldr (<|>) empty . map ($ a) $ [f, g, h, ...] but for each f,g,h,... the function itself decides if the input matches
10:22:32 <srhb> I guess it can just throw a Nothing if it doesn't..
10:24:27 <mreh> oh, it's not a Monoid
10:24:45 <typoclass> srhb: i have an idea for your chat client
10:24:55 <srhb> typoclass: Does it involve cats?
10:25:08 <Taneb> mreh, I... think it is a small-m monoid?
10:25:14 <typoclass> srhb: how about running a spellchecker on other people's messages, and when (say) more than 2 typos are found, show a cat picture as the background for that message
10:25:20 <mreh> yeah :)
10:25:21 <srhb> :P
10:25:21 <typoclass> srhb: sure! :-D you know me well
10:26:01 <typoclass> srhb: so, people who're struggling with english essentially are depicted as lolcats, and occasionally also regular people who are tired
10:26:05 <srhb> typoclass: I'm not sure that's very helpful as a motivation for people to spellcheck better.
10:26:11 <srhb> typoclass: Perhaps the other way around.
10:27:12 <sproingie> i think squiggly red lines are sufficient
10:27:14 <typoclass> srhb: well, this feature is designed to be entertaining for me. i haven't thought much about getting people to spell better
10:27:35 <srhb> Haha.
10:28:32 <srhb> Hm. I guess what I ideally want are actions that may or may not sequence together. And each action knows which other action it may not sequence with.
10:28:39 <srhb> Back to the drawing table...
10:28:46 <sproingie> i think if misspelled messages showed a picture of goatse as the background, that might motivate them better
10:28:57 <timtom> ewww
10:41:55 <parcs> does anybody have a preferred actors library
10:49:04 <joe9> I am trying to parse this line: parseTest transplantInfo " Transplant Info: testvalue ........................................ Date of transplant:" and have gotten this far: http://codepad.org/Me2rl4v5 the line 23, I am clueless of what I can add there.
10:49:16 <joe9> any thoughts, please? It has to be able to span newlines, etc.
10:49:26 <joe9> it is a paragraph.
10:49:47 <joe9>  http://codepad.org/N3RPXdHg is the error message from ghci
10:53:35 <seliopou> anybody have experience using the language-python package?
10:54:03 <seliopou> just curious if anybody has formed any opinion of it from using it in the wild
10:54:20 <geekosaur> joe9, I cannot understand why you would think that would work
10:54:48 <geekosaur> manyTill is going to consume until EOF, becase you told it to, and of course it will not then match your string
10:56:56 <Cale> seliopou: I haven't used it, but it's a dependency of berp, which is apparently an implementation of Python which compiles Python to Haskell code. You might give that a try.
10:58:04 <johnw> Cale: oh, interesting
10:58:15 <johnw> I have some old Python code laying around I'd like to convert
10:59:03 <seliopou> Cale: thanks for the heads up
11:01:25 <srhb> mwhen l p m a = if p (m^.l) then return $ a m else empty. Monstrous!
11:01:40 <srhb> (but it reads nicely)
11:01:45 <shachaf> s/return/pure/
11:01:49 <srhb> Oh yes
11:01:51 <srhb> Thanks
11:02:29 <shachaf> Seems related to guard.
11:02:36 <srhb> I felt it would be.
11:02:48 <shachaf> I can't say much without knowing how it's used. :-)
11:03:12 <aCube> a m <$ guard (p $ m ^. l) ?
11:03:27 <srhb> mwhen command (=="PING") pong m
11:03:36 <aCube> mwhen = a m <$ guard (p $ m ^. l) ?
11:04:11 <srhb> But I need a Nothing
11:04:35 <srhb> er, a Maybe
11:04:42 <aCube> that will give you a maybe, wont it?
11:04:45 <srhb> Or something else that has an Alternative instance
11:04:51 <srhb> Will it? Hm
11:05:03 <aCube> :t \l p m a -> a m <$ guard (p $ m ^. l)
11:05:04 <lambdabot> (Functor f, MonadPlus f) => Getting a1 s t a1 b -> (a1 -> Bool) -> s -> (s -> a) -> f a
11:05:06 <srhb> :t (<$)
11:05:08 <lambdabot> Functor f => a -> f b -> f a
11:05:27 <aCube> :t guard
11:05:27 <srhb> Oh. Neat!
11:05:28 <lambdabot> MonadPlus m => Bool -> m ()
11:05:36 <srhb> Thanks :)
11:05:48 <shachaf> @gyarrd
11:05:48 <lambdabot> Avast!
11:06:17 * hackagebot active 0.1.0.4 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.4 (BrentYorgey)
11:06:46 <[swift]> so i've noticed that i have this pattern sometimes when composing messages to print to the console and things like that: mkMessage x y z = concat [f x, g y, h z]
11:07:02 <[swift]> is there a clean way to make that point-free? or to restructure it to be a bit nicer?
11:08:01 <geekosaur> :t liftA3 concat f g h
11:08:03 <lambdabot>     Couldn't match expected type `b0 -> c0 -> d0'
11:08:03 <lambdabot>                 with actual type `[a0]'
11:08:03 <lambdabot>     Expected type: [[a0]] -> b0 -> c0 -> d0
11:08:06 <parcs> looks sufficiently nice to me
11:08:09 <srhb> > [f,g,h] <*> [x,y,z]
11:08:09 <geekosaur> didnt think so...
11:08:11 <lambdabot>   Ambiguous type variable `b0' in the constraints:
11:08:11 <lambdabot>    (GHC.Show.Show b0)
11:08:11 <lambdabot>     ...
11:08:14 <srhb> Whee
11:08:25 <srhb> Oh, that's a bad idea anyway :P
11:08:31 <[swift]> parcs: well in particular there can be many arguments to construct the message
11:08:47 <[swift]> parcs: i was basically hoping to avoid listing them all, since they're kind of redundant (generally very clear from context)
11:10:06 <aCube> swift: are f g and h all of the same type?
11:10:27 <parcs> what do you mean that "there can" be many arguments to construct the message?
11:10:43 <[swift]> aCube: well, they all return a string, but their inputs are different
11:11:13 <[swift]> parcs: i mean that's just a general pattern. i have a few of these, some of which take 6 arguments or so, which gets a bit unwieldy
11:12:36 <coppro> grargh
11:12:45 <coppro> stupid expression problem
11:13:07 <joe9> geekosaur: I could not figure out how to get that to work. that does not work. I am still trying to figure out how to get it to work.
11:13:14 <joe9> geekosaur: any pointers, please?
11:13:47 <geekosaur> you seem to be assuming that parsec does arbitrary backtracking. it does not, and just tossing random try combinators in will not cause it to do so
11:14:08 <coppro> How do you guys handle situations where you have functions on a type that only some instances of the type support?
11:14:10 <geekosaur> but for  ahint, if you are parsing up to something, that something is what you should be telling manyTill about
11:14:22 <geekosaur> telling it about eof is not telling it that you are parsing up until some string
11:14:32 <coppro> and by type I mean class
11:14:41 <joe9> geekosaur: thanks. that makes sense.
11:14:59 <coppro> I want a refined typeclass, but then I can't avoid the type erasure that occurs
11:15:02 <coppro> at least, I don't think I can
11:16:17 * hackagebot diagrams-contrib 0.6.0.4 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-0.6.0.4 (BrentYorgey)
11:16:42 <ab9rf> i hate IO
11:16:44 <bgamari> @seen dons
11:16:44 <lambdabot> Unknown command, try @list
11:17:38 <johnw> anyone know how to send stderr to /dev/null withb shelly?
11:17:47 <ab9rf> best way to read in a file as a list of bytestrings broken by lines?
11:18:24 <shachaf> What is a line?
11:18:43 <srhb>  mwhen l c v f m = f m <$ guard (c (m^.l) v) -- I should probably rethink my approach here.. :P
11:18:58 <srhb> (but it reads so nicely.... ._.)
11:19:30 <ab9rf> shachaf: reasonable assumption?
11:19:49 <shachaf> ab9rf: ?
11:19:52 <ab9rf> shachaf: newline characters separate lines; if the file does not end with a newline pretend that it did
11:20:05 <shachaf> What is a newline character?
11:20:20 <typoclass> ab9rf: have you considered this? http://hackage.haskell.org/packages/archive/bytestring/0.9.0.4/doc/html/Data-ByteString-Char8.html#14
11:20:26 <Cale> ab9rf: Use the lines function in Data.ByteString.Char8
11:20:39 <shachaf> For example are U+85 or U+2028 newline characters?
11:20:50 <srhb> I thought Data.ByteString.Char8 was banned for all eternity.
11:20:50 <ab9rf> Cale: ok, i was just looking at that when shachaf distracted me with his pedantic questioning ;)
11:21:05 <Cale> However, you should be cautious that the IO primitives for ByteString read the file as a string of bytes, rather than as text.
11:21:07 <shachaf> ab9rf: My point is: ByteStrings represent bytes, not lines, so it doesn't really make sense to separate them into lines without specifying what lines are.
11:21:21 <Cale> You may be better off with Data.Text
11:21:25 <shachaf> You should perhaps be reading text in as Data.Text, or use Data.ByteString.UTF8, or something else.
11:21:27 <ab9rf> Cale: i'm not concerned, i'm feeding this into pcre-light anyway
11:21:42 <ab9rf> shachaf: this is for a one-off
11:22:04 <ab9rf> shachaf: there won't be any naughty unicode in the input
11:22:08 <shachaf> s/lines/characters/
11:23:00 <monochrom> Char8 is why Americans won't have "naughty" unicode in the input
11:23:15 <monochrom> this is a self-fulfilling prophecy
11:23:30 <johnw> and UTF-8 fits in Char8 :)
11:23:41 <johnw> let the hilarity ensue...
11:23:52 <monochrom> yeah but the unpack uncons etc do the wrong thing
11:24:08 <ab9rf> monochrom: since this is a one-off script that won't go anywhere, i don't care
11:25:12 <shachaf> "UTF-8 fits in Char8"?
11:25:13 <monochrom> I am talking about the bigger picture. it does not matter that you will delete this script one hour later.
11:25:20 <johnw> shachaf: you're on fire tonight
11:25:47 <shachaf> I don't get it.
11:25:58 <johnw> i don't want to play the pedantry game
11:26:17 <Cale> shachaf: This is how we used to do things, in fact.
11:26:35 <ab9rf> monochrom: that's fine, but i'm not adding three hours to my development time to make this script work for data that i'm never going to give it :)
11:26:39 <chrisdotcode> can you guys be honest? will I eventually get used to "\" being used for anonymous functions?
11:26:52 <shachaf> chrisdotcode: I don't know about you. I did.
11:26:59 <Cale> chrisdotcode: I did almost immediately.
11:27:17 <monochrom> the bigger picture is: why don't one-off scripts need to handle unicode properly? because you don't have non-trivial unicode files. that is the self-fulfilling prophecy. you don't use it and you will never use it.
11:27:38 <chrisdotcode> shachaf, Cale: I would have honestly prefered even a simple "fn", personally. but I'm assuming "\" was chosen because the language designers knew what they were doing?
11:27:50 <Cale> (though in general, it took me about 2 months before I really felt like I could do much that was useful with Haskell, and about a year to be comfortable)
11:28:06 <Cale> \ is ascii art for λ
11:28:07 <typoclass> chrisdotcode: yes it looks weird at first :-) but you get used to it
11:28:08 <monochrom> already, my own text files contain a lot of ∀ λ etc. my one-off scripts cannot ignore unicode.
11:28:12 <shachaf> chrisdotcode: I prefer \ because it stands out more than text.
11:28:18 <Cale> But it's a lot easier to type than λ
11:28:22 <mcstar>  \ is a trick, it stands without the quickstand, unbelievable
11:28:23 <chrisdotcode> "\" feels less explict for me (I came from Python, so now you know ;) )
11:28:24 <Cale> (on most keyboards anyway)
11:28:55 <ab9rf> monochrom: the pcre-light library uses bytestrings anyhow, i'd just be slamming them back into bytestrings two steps later
11:29:00 <stephenjudkins> there is no reason not to support all of unicode properly in a modern environment.
11:29:02 <chrisdotcode> but at the same time, "lambda" is too verbose, and "λ" is untypable...
11:29:12 <Cale> λ is also a *letter*
11:29:27 <Cale> which would have to be stolen from identifiers if we used it
11:29:39 <aCube> λ is not untypeable if you have your editor replacing \... automatically.
11:29:43 <ab9rf> and, yay, it works
11:29:45 <stephenjudkins> "we will never need it" is just totally false. a product coworkers were working on (web app for children) worked perfectly until the kids discovered emoticons
11:29:52 <ab9rf> you can go back to bickering about unicode :)
11:29:54 <Cale> Though there are mathematical symbol versions of it in Unicode.
11:29:55 <johnw> ab9fr: just use bytestring.  when your one-off script becomes a long-term maintenance program at the heart of an enterprise organization, just give us our due :)
11:29:57 <elliott> U+03BB λ MATHEMATICAL SYMBOL ANONYMOUS FUNCTION
11:29:58 <stephenjudkins> suddenly, the BMP wasn't sufficient.
11:30:12 <chrisdotcode> aCube: yeah, that vim plugin looks wonderful.
11:30:18 <ab9rf> johnw: i'll rewrite it to use parsec at that point :)
11:30:31 <Cale> There's also ↦ which is the usual mathematical symbol for anonymous functions which is popularly used, but it's also hard to type.
11:30:37 <chrisdotcode> I keep trying to run away ...but haskell keeps calling me back.
11:30:38 <elliott> Cale: and has the infix problem
11:30:42 <elliott> you see (x ...) where x is out of scope
11:30:46 <ab9rf> Cale: and not supported in my terminal font
11:30:47 <Cale> and being infix, doesn't work as well with multiple parameters, yes
11:30:49 <Hafydd> U+B3BB λ HASKELL OPERATOR LAMBDA ABSTRACTION
11:30:58 <chrisdotcode> "$" for function application also confuses me, but I'm assuming that's just temporary.
11:31:01 <johnw> haha
11:31:16 <Cale> chrisdotcode: Just don't pick up the bad habit of chaining $
11:31:22 <aCube> emacs, vim and leksah all have functions to convert these symbols in unicode automatically :D
11:31:33 <johnw> I see U+B3BB as HANGUL SYLLABLE DYES
11:31:44 <Hafydd> Damn.
11:32:07 <chrisdotcode> Cale: confuses as in "confusing looking". dot for composition, I get, that's intuitive, but "$" as the symbol for application doesn't make intuitive sense to me. I'll stay quit for now, though, because I'm still only learning ;)
11:32:13 <Cale> (lots of people do that, but function composition exists for a reason, and forcing yourself to write things as compositions has a number of beneficial effects)
11:32:27 <ab9rf> i wrote a perl script to do this a few days ago
11:32:29 <Cale> Well, there are only so many symbol characters on the keyboard.
11:32:37 <chrisdotcode> that is true...
11:32:57 <chrisdotcode> but what about something like ">>>" or something?
11:33:04 <ab9rf> but i decided i wanted to manipulate the results more and decided to rewrite it in haskell, but that meant i either needed a regexp library or would have ot rewrite the regexps in parsec or something, and i'm lazy
11:33:08 <aCube> >>> is arrow
11:33:08 <Cale> It's not like the actual typography of $ is particularly relevant to composition, but it's one character
11:33:16 <Cale> and it's easy to type
11:33:22 <chrisdotcode> ...right. ergonomics.
11:33:39 <ab9rf> ergonomics matter in the real world :)
11:34:05 <chrisdotcode> I would agree wholeheartedly.
11:34:35 <chrisdotcode> but what abou ">>="? I don't know what it means yet, but it doesn't look easy to type
11:34:59 <ab9rf> chrisdotcode: a lot of the various funky operators are a bear to type
11:35:21 <ab9rf> @hoogle (<=-)
11:35:21 <lambdabot> No results found
11:35:23 <Cale> >>= is also perhaps a little less common than $ -- its name is influenced by two things:
11:35:27 <ab9rf> amazing, nobody's used that one yet
11:35:45 <Cale> One is that it is very much directional -- its two arguments have different types
11:36:02 <elliott> so is ($) :P
11:36:08 <Cale> well, that's true :)
11:36:10 <chrisdotcode> so what does >>= do?
11:36:15 <aCube> >> = sequence
11:36:19 <aCube> =     Bind
11:36:20 <Cale> uh
11:36:23 * chrisdotcode is still reading learn you a haskell, and is up to modules
11:36:34 <aCube> that's how I interpreted it ...
11:36:37 <ab9rf> it would amuse me if the sequence ">>= x =>" meant something special
11:36:38 <Cale> Don't say that it's sequence, because sequence is something specific :P
11:36:44 <johnw> chrisdotcode: >>= has to do with monads, and is called "bind"
11:36:56 <`ramses> chrisdotcode: then have some patience, you will only regret looking at monads before you learned the prerequisites, imho
11:37:10 * johnw agrees with `ramses
11:37:21 <shachaf> The FAQ talks about this:
11:37:22 <shachaf> @where faq
11:37:22 <chrisdotcode> I *think* I know what a monad is.
11:37:22 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
11:37:26 <`ramses> chrisdotcode: it will be pretty easy if you understood the stuff that comes in the preceding chapters
11:37:28 <ab9rf> chrisdotcode: you're probably wrong :)
11:37:30 <shachaf> chrisdotcode: You should read that. It's very useful.
11:37:31 <chrisdotcode> haha
11:37:38 <`ramses> chrisdotcode: and quite hard otherwise :)
11:37:39 <chrisdotcode> that's shachaf
11:37:43 <ab9rf> chrisdotcode: i still don't know what a monad is and i've written four
11:37:45 <Cale> If x is an action, and f is a function from results of that action to further actions, then x >>= f is an action which first performs x, and then applies f to the result (say v), and then performs (f v)
11:37:49 <chrisdotcode> I thought it was like chaining?
11:38:04 <Cale> So, in do-notation, this is  x >>= f = do v <- x; f v
11:38:19 <chrisdotcode> like, (forgive my python accent) returning self from a instance function so you can do.stuff().like.this() ?
11:38:22 <Cale> (though in fact, the do notation translates into uses of >>=)
11:38:26 <tom339> Does anybody have any examples ViewPatterns in a Haskell program? (I found none in xmonad, my first go-to program for haskell in practice)
11:38:32 <ab9rf> i have some clue what a monad is, but i don't _know_ what a monad is yet
11:38:42 <Cale> chrisdotcode: Here's a concrete example in the IO monad
11:38:48 <johnw> tom339: foo (length -> x) $ 10
11:38:50 <Cale> We have: getLine :: IO String
11:38:59 <johnw> foo (length -> x) $ "Hello"
11:39:00 <otters> a Monad is a type with (>>=) and return defined for it
11:39:01 <shachaf> johnw: ?
11:39:04 <johnw> that will capture 5 in x
11:39:06 <Cale> this is an action, which when you run it, gets a line of text from the user
11:39:07 <Iceland_jack> tom339: if you make an interpreter, you often need the argument evaluated before pattern matching on it
11:39:08 <johnw> yeah, brain slip
11:39:09 <Cale> (which is a String)
11:39:13 <ab9rf> otters: see, that's true but not really useful
11:39:28 <Iceland_jack> so: eval (eval → Var x) = … is a nice use of view patterns
11:39:30 <joe9> geekosaur: wow, parsec is pretty powerful, just needed this: info <- manyTill anyChar (string "Date of transplant:")
11:39:36 <Cale> There's also: putStrLn :: String -> IO ()
11:39:38 <otters> ab9rf: I agree
11:39:55 <Cale> which, given a String produces an action that when executed will put that String on the screen
11:40:00 <chrisdotcode> Cale: so monads deala with side effects. that much I know.
11:40:07 <Cale> So, we can use >>= to glue these together:
11:40:08 <Iceland_jack> chrisdotcode: no they don't
11:40:11 <chrisdotcode> no?
11:40:12 <Cale> getLine >>= putStrLn
11:40:12 <Iceland_jack> they can
11:40:17 <otters> not necessarily
11:40:22 <johnw> i wonder why we don't have #haskell-monads...
11:40:22 <Cale> will be an action which gets a line of text from the user, and prints it back out
11:40:30 <saml> monad is a wrap
11:40:30 <Cale> (try it in ghci)
11:40:34 <chrisdotcode> remember, I'm only a beginner! don't confuse me with true details yet ;)
11:40:40 <otters> monad is a context
11:40:41 <johnw> saml: ?
11:40:42 <Cale> (there's so much confusing discussion here...)
11:40:44 <otters> maybe
11:40:45 * shachaf is a bit tired of all the monad mystique.
11:40:46 <saml> you can fmap to go inside the wrap
11:40:51 <ab9rf> chrisdotcode: monads _can be used_ to deal with side effects.  that's not what they _are_ though
11:40:55 <shachaf> Oh well.
11:40:56 * Iceland_jack enjoys watching Haskellers explain monads to people in horrible horrible ways
11:41:03 <monochrom> do { x <- #haskell-monads; x }
11:41:05 <ParahSailin> seeking within a Handle breaks BL.hGet
11:41:11 <johnw> shachaf: how many times have you watched this conversation now?
11:41:18 <otters> at least 100
11:41:19 <ab9rf> heh
11:41:19 * hackagebot log-domain 0.3.0.1 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.3.0.1 (EdwardKmett)
11:41:21 * hackagebot compensated 0.1.1.1 - Compensated floating-point arithmetic  http://hackage.haskell.org/package/compensated-0.1.1.1 (EdwardKmett)
11:41:23 <otters> :t (>>=)
11:41:25 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:41:37 <saml> >>= is fmap
11:41:42 <otters> no it isn't
11:41:44 <Iceland_jack> so: what?
11:41:45 <saml> it goes inside the cover
11:41:48 <otters> it is not
11:41:49 <Iceland_jack> -so:
11:41:50 <ab9rf> i hate the fact that because IO is a monad everyone focuses (at first at least) on how monads can be used to do side-effecty things like IO
11:41:52 <Cale> pls
11:41:56 <saml> it's not . my bad
11:41:57 <ab9rf> i don't think that really engenders comprehension
11:42:02 <otters> fmap :: Monad m => (a -> b) -> m a -> m b
11:42:04 <mcstar> monochrom: its empty!
11:42:08 <Cale> ;___;
11:42:10 <otters> in this case
11:42:13 <otters> not in all cases
11:42:14 <saml> yah >>= is about composition
11:42:20 <elliott> we need some kind of alarm we can set off for monad voodoo emergencies.
11:42:21 <monochrom> yeah, it's empty
11:42:26 <otters> assuming the Monad is a Functor, which practically speaking all Monads are
11:42:36 <Cale> saml: but not (.)
11:42:39 <chrisdotcode> I'm sorry for not knowing what a monad is guys! ;_;
11:42:42 <Cale> It's a specific kind of composition
11:42:49 <shachaf> chrisdotcode: Did you read the FAQ entry on it?
11:42:51 <Iceland_jack> Do you need to know what a “monoid” is to understand natural numbers?? You don't need to explain monads to use IO, [], State, Writer, ... ffs
11:42:52 <aCube> A monad is anything that obeys the monad laws. There are things with monad instances that you can't imagine
11:42:54 <sproingie> it's the burrito-signal!  quick Simon, to the Monadmobile!
11:42:54 <shachaf> You shouldn't worry about it.
11:42:54 <chrisdotcode> shachaf: I was doing that now
11:42:58 <elliott> :t ((.), flip)  -- we need to be even more confused, I think
11:43:00 <lambdabot> Functor f => ((a -> b) -> f a -> f b, (a1 -> b1 -> c) -> b1 -> a1 -> c)
11:43:06 <saml> this channel is so many tweets
11:43:07 <elliott> oh, I forgot about flip.
11:43:08 <Cale> chrisdotcode: Yeah, just listen to me for a bit, there's a lot of stuff being said which is (intentionally or not) rather confused/confusing.
11:43:08 <shachaf> chrisdotcode: The FAQ is much better than #haskell :-)
11:43:09 <ab9rf> ok, now you guys are preventing me frm getting anything done
11:43:18 <tom339> Iceland_jack: Interpreters using ViewPatterns seems a boring use of ViewPatterns: it's used a trivial sugar. I was after "it's possible that people would start routinely hiding the data representation and exporting view functions instead, which would be an excellent thing." as described by http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
11:43:23 <johnw> chrisdotcode: don't worry about it now, it will still be there later.  better to ponder functors first, if you are looking to delve into Haskell's mathematical abstractions
11:43:26 <chrisdotcode> Cale: okay, I'm listening.
11:43:41 <chrisdotcode> johnw: haskell seems so... wonderful. I can't stop thinking about infinite lists.
11:43:41 <otters> saml: if you treat m as a "context", "(>>=) :: m a -> (a -> m b) -> m b" can be read as a function that takes a value in a context and inserts it into a function that returns another value in the same context
11:43:46 <johnw> Cale: maybe take him to #haskell-in-depth?
11:43:57 <Iceland_jack> I'm sorry for giving a ‘boring’ example tom339
11:44:02 <Cale> Yeah, maybe that would be good, because there's a lot of noise here :)
11:44:08 <ab9rf> i actually found the little dag at the top of the typeclassopedia far more illuminating than any of the other "what the fuck is a monad" monologues i've read so far
11:44:09 <saml> i discovered monad when it wasn't cool
11:44:16 <shachaf> johnw: #haskell-in-depth is specifically not for monad tutorials.
11:44:22 <sproingie> it's not necessarily even "a value".  with a list, it's "zero or more values"
11:44:23 <shachaf> It's in the topic.
11:44:39 <johnw> is it?
11:44:41 <tom339> Iceland_jack: I realise my question was ill-defined, sorry. :) Thanks though.
11:44:45 <johnw> huh
11:44:53 <otters> sproingie: the "value" in a list is a nondeterministic "computation"
11:44:56 <ab9rf> do people actially look at topics?
11:45:03 <otters> which can be represented as zero or more whatevers
11:45:38 <otters> it helps to think of "m a" as an "action" that can be composed with other "actions"
11:45:52 <otters> and at some point the "result" can be extracted
11:45:57 <otters> or forced in some way
11:46:17 <otters> like main, an IO action, being evaluated by the compiler
11:46:19 <sproingie> that connotes effects a little too much
11:46:20 <monochrom> tom339, Iceland_jack: bytestring has uncons :: ByteString -> Maybe (Word8, ByteString). it can be used with view patterns when you somehow want to "is it empty? if not, I want head and tail": f (uncons b -> Nothing) = "it is empty"; f (uncons b -> Just (x,xs)) = ...
11:46:22 <Taneb> You'll probably use no more than 6 IO-capable monads in your life, not counting transformer stacks
11:46:25 <laker> anyone knows how to represent 'exp exp' in an LL grammar?
11:46:30 <otters> sproingie: good point
11:46:34 <otters> I'm trying to keep it abstract though
11:47:03 <Iceland_jack> otters: If I didn't know what monads were, I don't think I would be any closer from that explanation
11:47:07 <sproingie> i think the abstraction is half the problem people have grasping monads
11:47:22 <otters> heh
11:47:23 <sproingie> that said, i don't actually know what the proper approach is
11:47:24 <Iceland_jack> Monads are abtract enough to warrant starting out with concrete examples at first
11:47:29 <otters> Iceland_jack: I never found a helpful monad tutorial
11:47:30 <johnw> laker: exps: epsilon | exp exps?
11:47:32 <otters> it just clicked for me one day
11:47:44 <sproingie> i personally only got it by seeing a bunch of them in action and seeing "oh that's the common pattern"
11:47:46 <monochrom> Piaget's theory. concrete before abstract.
11:47:46 <otters> sproingie: nobody knows what the proper approach is, that's why there's a monad tutorial fallacy
11:47:49 <`ramses> sproingie: I think explanations which arn't abstract enough have caused all the confusion around the topic
11:48:07 <Iceland_jack> otters: Probably after actually /using/ them right, not hearing about actions composed with actions with extracted results
11:48:13 <ab9rf> otters: everyone i've read has either gone burrito on me, been too deeply abtrusely mathematical, or been handwavy
11:48:14 <otters> right
11:48:16 <monochrom> if I have never learned Chess, you telling me "it's about controlling the centre" means nothing.
11:48:23 <otters> Iceland_jack: well, it was my first try
11:48:27 <tom339> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html and http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf helped me understand monads, for those who care.
11:48:31 <Iceland_jack> Sorry, didn't mean to put you down otters
11:48:32 <otters> and I didn't get lynched by shachaf so I'm counting it a success
11:48:33 <monochrom> similarly for functor monad etc
11:48:40 <sproingie> scala actually does pretty well with "map" and "flatten", and from there you have flatMap aka bind
11:48:56 <sproingie> fmap is pretty easy to explain
11:48:57 <monochrom> actually, functor monad etc are worse.
11:49:02 <otters> yeah
11:49:08 <shachaf> Do I lynch people?
11:49:14 <Iceland_jack> I just never see monads explained well, but that's probably what everyone things before writing their own tutorial
11:49:19 <Iceland_jack> *thinks
11:49:29 <otters> shachaf: I've spent enough time on Freenode to deeply fear accidentally spreading misinformation
11:49:36 <ab9rf> Iceland_jack: many of the tutorials are written by people who don't understand them.
11:49:47 <magic__> hi everyone!
11:49:57 <geekosaur> worse, written by people who *think* they understand them...
11:50:02 <Iceland_jack> ab9rf: What does it mean to “understand” monads?
11:50:10 <otters> to be perfectly honest with you, my mental conception of "IO action" is "a thing that does stuff and can be sequenced with other things that do stuff"
11:50:16 <S11001001> woo woo http://blog.jorgenschaefer.de/2013/01/monads-for-normal-programmers.html?m=1
11:50:18 <shachaf> @quote array.*monad
11:50:18 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
11:50:19 <ab9rf> it's kinda like wikipedia pages, so many of which are written by people who have had one lecture on the topic.
11:50:27 <S11001001>     A Monad is an object whose methods return monads.
11:50:27 <sproingie> Iceland_jack: looking at non-monadic code and recognizing a monad and knowing how to rewrite it to use one
11:50:30 <Iceland_jack> Sure otters, but it's probably concrete in your mind
11:50:42 <sproingie> Iceland_jack: that's a good test for me anyway
11:50:43 <monochrom> Chess "controlling the centre" means nothing to me, which is no harm done. Monad "its about blahblah" may mean something to me, but I interpret it wrong, this is strictly harmful.
11:50:50 <otters> a concrete example of my explanation earlier would be Maybe a, Maybe being a monad, and representing a "computation" that could be "nothing" or "something"
11:50:52 <ab9rf> S11001001: what's a 'method'
11:50:54 <elliott> S11001001: doesn't #haskell produce enough monad information without importing it from blogs?
11:50:57 <elliott> er.
11:50:57 <elliott> misinformation.
11:50:59 <sproingie> tho honestly, i couldn't look at most code and see ContT in there
11:50:59 <S11001001> is edwardk's preferred definition
11:51:06 <otters> and if you bind two Maybe computations together
11:51:13 <shachaf> S11001001: A normal programmer is one whose digits are distributed uniformly, right?
11:51:13 <otters> wait
11:51:15 <otters> abort, abort
11:51:28 <S11001001> elliott: the whole thing is worth reading
11:51:37 <S11001001> shachaf: digit sounds ivory towery
11:51:46 <shachaf> S11001001: I meant finger.
11:51:46 <magic__> Please, how can I get an integer number as Int from a [Int]?
11:51:48 <otters> damn it i've failed again
11:51:48 <S11001001> ab9rf: it's like a function but more #pragmatic
11:51:51 <srhb> Conceptually, if I want to transform the result of a getter (from lens) how do I do that?
11:51:54 <ab9rf> S11001001: haha
11:52:00 <shachaf> magic__: [Int] is a list of Ints. What if the list is empty?
11:52:01 <ab9rf> magic__: head
11:52:07 <ab9rf> magic__: will fail if the list is empty
11:52:07 <sproingie> @hoogle [Int] -> Int
11:52:07 <lambdabot> Prelude head :: [a] -> a
11:52:07 <lambdabot> Data.List head :: [a] -> a
11:52:07 <lambdabot> Prelude last :: [a] -> a
11:52:19 <otters> > head 0[
11:52:20 <otters> oops
11:52:20 <lambdabot>   <hint>:1:8: parse error (possibly incorrect indentation)
11:52:21 <ab9rf> @hoogle [Int] -> Maybe Int
11:52:21 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
11:52:21 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
11:52:21 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
11:52:22 <otters> > head []
11:52:24 <lambdabot>   *Exception: Prelude.head: empty list
11:52:29 <sproingie> yeah more interesting than head anyway
11:52:40 <edwardk> srhb: 'to'
11:52:41 <otters> > listToMaybe []
11:52:43 <lambdabot>   Nothing
11:52:45 <sproingie> hoogle should prioritize more specific matches first.  i'm sure that's super-easy, so get right on it ;)
11:52:48 <monochrom> anyway, my complete criterion for "understanding" is: can you use it?
11:52:55 <edwardk> > (1,"hello")^._2.to length
11:52:59 <lambdabot>   5
11:53:08 <ab9rf> @hoogle (^._)
11:53:08 <srhb> edwardk: foo^.getter . to bar ?
11:53:08 <lambdabot> Parse error:
11:53:08 <lambdabot>   (^._)
11:53:08 <lambdabot>      ^
11:53:10 <magic__> I don't care this time about empty list, becuase the list is known from [1..100]
11:53:12 <elliott> monochrom: well, people can use cars without understanding how they work. (sounding my "car alarm metaphor" alarm as we speak)
11:53:16 <edwardk> srhb yeah
11:53:17 <elliott> er.
11:53:18 <monochrom> if you can use it, you already understand. I don't care if you "feel" you don't "understand"
11:53:19 <edwardk> :t to
11:53:20 <lambdabot> (Conjoined p, Gettable f) => (s -> a) -> p a (f a) -> p s (f s)
11:53:21 <elliott> another alarm snuck in there
11:53:21 <srhb> Ah, neat.
11:53:35 <edwardk> to takes a function and makes a (index-preserving) getter from it
11:53:56 <edwardk> index-preservation matters more for advanced uses
11:53:58 <ab9rf> i don't understand anything about monads, but i use them anyway
11:54:02 <magic__> but I need a number exctracted from a list
11:54:02 <ab9rf> so THERE
11:54:05 <monochrom> elliott: for your meaning of "understand car", my criterion translates to: can you repair the car
11:54:17 <edwardk> ab9rf: the operator is (^.)   _ is part of the lens name _2
11:54:18 <elliott> monochrom: fair enough.
11:54:21 <ab9rf> monochrom: am i permitted to use a credit card?
11:54:26 <elliott> how does one understand cdr?
11:54:29 <edwardk> > (1,2) ^. _2
11:54:31 <lambdabot>   2
11:54:44 <ab9rf> edwardk: i figured that out eventually.  haskell can get a little sendmaily sometimes with all the funky operators
11:54:49 <edwardk> elliott: in terms of how to read it?
11:54:52 <shachaf> I understand all natural numbers smaller than 100 or so.
11:55:01 <elliott> edwardk: well, it's the natural question after how one understands a car :)
11:55:25 <ab9rf> elliott: haha
11:55:30 <shachaf> I,I bёrgey
11:55:41 <edwardk> car = "contents of the addressing part of the register".   cdr = "contents of the decrement part of the register"
11:55:42 <monochrom> elliott: for an even deeper understanding: can you use car components to escape from certain death like MacGyver does :)
11:56:02 <ab9rf> monochrom: better yet, can you use cdr components to escape from certain death?
11:56:03 <elliott> edwardk: I may not have been entirely serious :P
11:56:07 <S11001001> edwardk: there's a sequel: http://blog.jorgenschaefer.de/2013/02/monads-for-normal-programmers-part-2.html
11:56:12 <magic__> [x | x <- [1..100], x * x == n] -- I need just x, How can I please? :)
11:56:29 <ab9rf> magic__: what is ix?
11:56:31 <merijn> ab9rf: tbh, there's just not that much to understand about monads :p
11:56:33 <ab9rf> er what is x?
11:56:33 <edwardk> S11001001: i've given up on him
11:56:42 <merijn> ab9rf: ix is short for index
11:56:50 <ab9rf> merijn: ix was a typo :)
11:57:11 * merijn just saw some lens code and went from there
11:57:13 <geekosaur> magic__, your question makes no sense, "just" *which* "x"?
11:57:51 <ab9rf> magic__: there are no unbound x's in that code snippet
11:57:56 <ab9rf> there's no x to get
11:57:58 <magic__> It's according to the test of x * x == n and n is an input to the function
11:58:23 <geekosaur> oh, I see, you are doing a really poor way to search for a square root by creating a list, then you want to knwo how to turn your possiblyu empty list into a single item.
11:58:34 <ab9rf> > (\n -> [x|x<-[1.100], x * x == n]) 25
11:58:36 <lambdabot>   []
11:58:39 <geekosaur> note that there is a phrase in there that you have probably failed to think about
11:58:42 <magic__> :D yes Indeed
11:58:52 <ab9rf> oh, lost a dot
11:58:54 <edwardk> lens should offer car and cdr ;)
11:58:55 <ab9rf> > (\n -> [x|x<-[1..100], x * x == n]) 25
11:58:57 <lambdabot>   [5]
11:59:01 <ab9rf> there, happy?
11:59:04 <edwardk> just to maximize confusion
11:59:06 <geekosaur> and which ab9rf just inadvertently demonstrated
11:59:14 <magic__> And I know it is poor way but just practicing :D
11:59:35 <ab9rf> i didn't turn it into a single itme, i just printed the possibly empty list
12:00:28 <monochrom> you can prove that the list is non-empty
12:00:54 <ab9rf> i almost never use list comprehensions anymore
12:00:59 <laker> johnw: /exit
12:05:34 <ab9rf> :t comparing length
12:05:35 <lambdabot> [a] -> [a] -> Ordering
12:05:39 <ab9rf> aha
12:07:13 <ab9rf> yay
12:10:13 <bgamari> pcapriotti, ping
12:10:44 <bgamari> pcapriotti, Is there a reason why ReadM in optparse-applicative HEAD doesn't have an Applicative instance?
12:11:09 <viller> the gentle introduction tutorial has this sentence "The Prelude contains a number of classes defining monads are they are used in Haskell." Is it supposed to say "are they are"?
12:11:43 <elliott> viller: probably not.
12:11:45 <geekosaur> "as they are", I think
12:11:50 <typoclass> viller: i think it's a typo and should be "monads as they are used"
12:11:52 <monochrom> let me read that part of the tutorial again and see what it should be
12:11:58 <viller> it's so old and still has a typo :P
12:12:17 <viller> june 2000, I guess noone reads that tutorial
12:12:45 <typoclass> monochrom: yes, i wonder about "a number of classes defining monads"
12:13:31 <monochrom> the multiplicity of classes refers to Functor, Monad, and MonadPlus
12:14:06 <typoclass> monochrom: fair enough
12:14:08 <monochrom> "are they are" should be "as they are" as everyone guesses
12:14:21 <shachaf> are everyone guesses
12:14:57 <monochrom> "associating the type with the some or all of the monadic classes, Functor, Monad, and MonadPlus"
12:15:16 <monochrom> while we are at it, "with the some or all" should delete "the" :)
12:16:06 <magic__> still get a list of one Item!
12:16:10 <magic__> mysqr n = (\n -> [x|x<-[1..100], x*x == n]) n
12:16:24 <ab9rf> magic__: indeed
12:16:31 <magic__> any way to get it as a number of type Int?
12:16:42 <geekosaur> except when it's a list of 0 items
12:16:44 <viller> can someone fix the tutorial or is it sealed for eternity?
12:16:46 <ab9rf> magic__: sometimes
12:17:03 <ab9rf> hrm
12:17:23 <Botje> magic__: (\n -> ...) n is the same as writing ... directly.
12:17:35 <monochrom> just use head. until it explodes
12:18:02 <ab9rf> aha
12:18:06 <ab9rf> bite me!
12:18:14 <geekosaur> Botje, modulo the monomorphism restrictio
12:18:15 <geekosaur> n
12:18:18 <monochrom> I love puns
12:18:32 <monochrom> but I won't bite your head
12:18:38 <sproingie> > fix head
12:18:39 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
12:20:05 <ab9rf> can't fix your head.  sorry!
12:21:04 <ab9rf> hm, looks like i need memoization here
12:22:03 <magic__> Yeah, using head now it works :D
12:22:07 <magic__> mysqr n = head ((\n -> [x|x<-[1..100], x*x == n]) n)
12:22:21 <pcapriotti> bgamari: no reason, I just didn't need it
12:22:23 <ab9rf> magic__: try it for n = 24
12:22:36 <magic__> the poor way I think :)
12:23:01 <bgamari> pcapriotti, pull request opened
12:23:28 <pcapriotti> bgamari: thanks!
12:24:01 <ab9rf> ferk, i left out the code to ignore %prec
12:27:05 <docksider> Can force a type in a where statement?
12:27:21 <docksider> Suspecting XY problem here
12:27:28 <docksider> Not sure it is want i really want
12:27:39 <elliott> you can do foo :: type; foo = defn in a where clause
12:27:41 <elliott> just like at the top level
12:30:14 <docksider> thanks
12:30:41 <shachaf> docksider: (You can also use a newline and keep the indentation, rather than a semicolon. Just like everywhere else.)
12:31:00 <docksider> Did that :)
12:32:05 <docksider> Realized that the reason that the inferencer complaining couldn't be fixed without me redoing the types some
12:32:28 <docksider> Impossible to make unambigous without defeating the purpouse atm
12:36:20 * hackagebot yesod-markdown 0.7.1 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.7.1 (PatrickBrisbin)
12:50:23 <Mortchek> I tried `cabal install sexpr` but it failed with "`coarbitrary' is not a (visible) method of class `Arbitrary'". Is the package simply broken?
12:50:48 <latro`a_> try reinstall quickcheck
12:50:58 <ab9rf> ferk, i left out the code to ignore %prec
12:51:00 <ab9rf> oops
12:51:15 <byorgey> Mortchek: sounds like sexpr was coded against an older version of QuickCheck
12:51:21 <byorgey> reinstall QuickCheck will not help
12:51:36 <byorgey> coarbitrary used to be in the Arbitrary class but at some point it got split out into its own Coarbitrary class.
12:51:37 <Mortchek> I'm not sure I even had quickcheck. And no it didn't help.
12:52:54 <byorgey> Mortchek: try  cabal install sexpr --constraint='QuickCheck < 2'
12:53:11 <byorgey> that should get you an older version of QuickCheck which ought to work
12:53:40 <Mortchek> That succeeded, but on import I get "There are files missing in the `sexpr-0.2.1' package"
12:58:34 <Radish> I've got some code that compares some number a with some number b
12:58:54 <Radish> b needs to be a specific number that must be higher or equal to a
12:59:14 <Radish> so i increment b by some value
12:59:27 <Radish> there are actually a bunch of b's
12:59:31 <Radish> and i have them in a list
12:59:47 <Radish> my question is, should i use functional such and pass the entire list?
12:59:57 <Radish> to the next iteration of the compare?
13:00:08 <c_wraith> is there always guaranteed to be a value for b that's larger than the value of a?
13:00:16 <Radish> or should i do some imperitive such to modify the list?
13:00:16 <c_wraith> (or equal, I suppose)
13:00:24 <c_wraith> Radish: you should use higher-order functions
13:00:27 <Radish> i check and increment until it is
13:00:49 <c_wraith> :t \a -> dropWhile (< a)
13:00:50 <lambdabot> Ord a => a -> [a] -> [a]
13:01:02 <c_wraith> :t \a -> head . dropWhile (< a)
13:01:04 <lambdabot> Ord b => b -> [b] -> b
13:01:07 <Radish> i don't want to drop it i want to increase it
13:01:12 <Radish> until it meets the criteria
13:01:16 <c_wraith> You said you had a list of b values
13:01:20 <c_wraith> pass the whole list in
13:01:30 <Radish> and get a list with one change out?
13:01:34 <Radish> over and over?
13:01:34 <geekosaur> wait, are you looking to create a value higher than any value in a list?
13:01:38 <Radish> that seems inefficient is all
13:01:49 <geekosaur> :t maximum
13:01:51 <lambdabot> Ord a => [a] -> a
13:01:52 <Radish> like this say a = 20 and b = 5
13:02:00 <Radish> i'm sorry b = 21, 5, 13
13:02:03 <Mortchek> succ (maximum xs)
13:02:08 <Radish> [21,5,13]**
13:02:20 <Radish> so then i want to increment b until its greater and then move on to 13
13:02:28 <Radish> but typically i'll stop at one of them eventually
13:02:32 <c_wraith> what does "increment b" mean?
13:02:35 <byorgey> Radish: so you want to end up with [21,21,21]?
13:02:56 <monochrom> map (max a) your_list
13:03:01 <monochrom> example:
13:03:07 <SpawnPro> http://www.youtube.com/watch?v=9amsg2rF5f0 that will tell u how to do it better m8
13:03:12 <Radish> i'm not sure what it will end up at, I'll be incrementing 5 by some number i derive, say [2,8,6]
13:03:24 <monochrom> > map (max 20) [21, 5, 13]
13:03:26 <lambdabot>   [21,20,20]
13:03:27 <c_wraith> What does "increment b" *mean* ?
13:03:34 <c_wraith> You haven't actually defined that.
13:03:40 <madhadron> Bizarre, off topic collection: anyone know how to set a named capture group in a regex to a fixed value, not matching anything in the text you're processing?
13:03:46 <Radish> i increment it by some number c until it is greater or equal to a
13:03:54 <c_wraith> Are you using a different head of the list? what about the rest of the list?
13:04:01 <c_wraith> These are questions you're not answering
13:04:06 <c_wraith> and they're very important
13:04:08 <Radish> i'm trying to keep this simple - maybe that was a bad idea.
13:04:27 <Radish> i have a list of a and a list of (b,c) tuples
13:04:41 <Radish> I want to find the first a that b + c * any number
13:04:47 <geekosaur> madhadron, in general you can't, the point of a capture group is to capture something not to pretend to be a general variable. but you want to ask in a regex channel, not #haskell
13:05:14 <madhadron> geekosaur: Yeah, I know, just thought I'd toss it out since this place has a random knowledge base
13:05:26 <Radish> my question is, in this case, would i be better of not passing the entire list [(b,c)]
13:05:34 <madhadron> Radish: The first a that what? Not clear what the predicate is.
13:05:36 <Radish> and just using an imperitive modification
13:05:57 <Radish> the first a that is greater or equal to b + (c * any number)
13:06:04 <Radish> and once i increase b i need to keep it increased
13:06:22 <Radish> because no a will ever be lower than another a so there's no reason to add again and again
13:06:29 <madhadron> Radish: So a >= b + c*x for all x. There is no such finite a.
13:06:35 <Radish> so i *increment* b by c (on a case by case)
13:06:44 <c_wraith> Radish: you just said all a values are equal?
13:07:00 <madhadron> Radish: What are you trying to accomplish? Maybe step back and tell us that.
13:07:07 <Radish> madhadron: any not all
13:07:19 <Radish> it's for a sieve
13:07:32 <madhadron> Radish: Then use x = -infinity and it's always true for finite a.
13:07:40 <Radish> i'm just incrementing b by c and passing the new b list with very few changes, is that efficient?
13:08:17 <Radish> madhadron: a can by various numbers, i'm looking for a match between b and c * some number, otherwise i increment past it for a new b
13:08:29 <madhadron> Radish: Do you have some code? I think that may make this clearer.
13:09:01 <Radish> let me ask this much simpler question: if I change a list by one value, is it better to pass the whole list?
13:09:19 <Radish> or should i use some imperitive array style thing that i can modify?
13:09:40 <madhadron> Radish: Haskell will share as much of the tail of the list as is unmodified
13:10:04 <Radish> madhadron: oh so it only replaces the list up to the value i changed?
13:10:13 <madhadron> Radish: Right.
13:10:27 <Radish> madhadron: thank you!  that's what i was looking for.
13:10:33 <Radish> sorry for the confusion everyone.  thank you!
13:17:44 <shachaf> dreixel: So is the plan to remove Proxy from base entirely?
13:19:14 <dreixel> shachaf: no. it will probably be somewhere
13:19:30 <SpawnPro> http://www.youtube.com/watch?v=9amsg2rF5f0 that will tell u how to do it better m8
13:19:55 <geekosaur> @where ops
13:19:55 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconnor Saizan shapr sjanssen ski wli
13:19:55 <lambdabot> xerox
13:20:03 --- mode: ChanServ set +o monochrom
13:20:06 --- mode: ChanServ set +o dcoutts
13:20:26 <monochrom> oooh, already gone
13:20:33 <c_wraith> spam and run
13:20:35 --- mode: monochrom set -o monochrom
13:20:39 --- mode: ChanServ set -o dcoutts
13:21:21 <geekosaur> that's the second time they've spammed that url with same text
13:21:33 <geekosaur> is why I yelled; not about to open the url...
13:21:46 <shachaf> dreixel: OK. Can it go in a module unrelated to Data.Typeable, if it goes in? :-)
13:23:17 <mika^> Hello, I need an algorithm that can search an undirected graph for a circle in O(|V+E|) and a directed graph in O(|V|), can you recommend on something?
13:23:38 <companion_cube> what do you mean a circle in this case?
13:24:30 <mika^> any type of circle, doesnt have to be an Euler cycle. everything that loops over a few nodes
13:24:40 <companion_cube> ah, you mean a cycle
13:24:48 <mika^> yeah, sorry
13:24:55 <dreixel> shachaf: that's probably what will happen, since it's not really used in Data.Typeable
13:24:57 <companion_cube> to look up cycles in a graph, you can use DFS
13:25:02 <companion_cube> and look for back edges
13:25:40 <mika^> what do you mean by back edges?
13:25:58 <shachaf> dreixel: Oh, you made the polymorphic proxy changes, I see.
13:26:01 <shachaf> Excellent.
13:26:08 <dreixel> shachaf: yes :-)
13:26:31 <companion_cube> http://en.wikipedia.org/wiki/Depth-first_search#Output_of_a_depth-first_search mika^
13:26:47 <shachaf> dreixel++
13:27:25 <mika^> thanks companion_cube
13:28:55 <docksider> Is there a nice way to do something like type class extension? I want to create a typeclass that satisfies all the properties of Vector but has has more properties
13:29:42 <timtom> Does anybody here have experience with AcidState?
13:32:34 <hpaste> “Anonymous Coward” pasted “AcidState” at http://hpaste.org/84340
13:32:53 <timtom> http://hpaste.org/84340
13:33:13 <timtom> I'm trying to run some kind of randomized query
13:33:37 <timtom> but then i get all sorts of typeable and safecopy issues
13:43:13 <mika^> companion_cube: about the DFS and back edges, dont i need to create some spanning tree for that ?
13:44:41 <companion_cube> mika^: the DFS is the algorithm that produces the spanning tree
13:44:50 <companion_cube> you can do it all within one algorithm
13:45:24 <mika^> ok, thanks
13:46:21 <shachaf> dreixel: Any idea what's going to happen with the Refl Typeable thing?
13:50:54 <mikeplus64> timtom: the people in #happs might be able to help
13:51:07 <timtom> mikeplus64: thanks
13:58:19 <dreixel> shachaf: what do you mean exactly?
13:58:38 <mika^> companion_cube: a follow up, given a graph G, would DFS and BFS will produce the same spanning tree? assuming both algorithms always choose the next vertex with the smallest value
13:59:07 <shachaf> dreixel: foo :: (Typeable a, Typeable b) => Maybe (a :~: b) -- not related to the proxy thing, just another post related to typeable.
13:59:19 <mika^> assuming they both start from the minimal node
13:59:29 <dreixel> shachaf: ah. we definitely want that in somewhere too :-)
14:01:45 <shachaf> I hope :~: gets separated out into its own module too.
14:05:56 <elliott> shachaf: I hope it gets separated out into not being called (:~:)
14:06:05 <shachaf> elliott: I proposed (==)
14:06:08 <elliott> wasn't the idea to make that the primitive and build everything else on top of it?
14:06:13 <shachaf> Mixed response.
14:06:17 <elliott> instead of cast etc
14:06:19 <elliott> that's what I understood from the mailing list thread
14:06:24 <shachaf> By mixed I mean no one liked it but one person disliked it.
14:07:01 <shachaf> We should get SPJ into #ghc!
14:07:26 <companion_cube> mika^: not necessarily
14:07:39 <companion_cube> besides, I'm not sure BFS yields a spanning tree
14:07:58 <edwardk> shachaf: i thought i said i liked it
14:08:16 <shachaf> Oh.
14:08:38 <shachaf> I suppose.
14:08:54 <elliott> edwardk doesn't count.
14:08:58 <edwardk> personally i'm happy with gcast
14:09:16 <edwardk> it is simply more useful to me
14:09:18 <shachaf> I wasn't really aware of gcast when I posted that post.
14:09:25 <shachaf> Otherwise I'd've been fine with it.
14:09:33 <shachaf> In fact gcast's type was one of my suggested primitives.
14:11:22 * hackagebot signed-multiset 0.3.0.1 - Multisets with negative membership.  http://hackage.haskell.org/package/signed-multiset-0.3.0.1 (StefanHoldermans)
14:12:23 <dacto> I have a function whose definition looks like: typeOp :: [Token] -> [Token] -> Token. It takes two token lists and returns a token. However when I call the function supplied with two token lists, it returns a type [Token] -> Token. I have a feeling that it has to do with currying. Any idea how i might sort this out?
14:12:55 <shachaf> dacto: It sounds like you've only given it one list.
14:13:11 <shachaf> Do you know how "multi-argument functions" in Haskell work?
14:13:12 <dacto> I call it like this: ; let tempNode = typeOp (state sNode)
14:13:25 <dacto> state is a list of tokens and so is sNode
14:13:50 <ParahSailin> typeOp state sNode
14:15:08 <dacto> ._. argh I thought i tried that already earlier and it didnt work. Maybe I changed something else and forgot to do that. sigh, thanks.
14:15:31 <dacto> been working on this too long, brain is melting haha
14:15:33 <ParahSailin> @ty ($)
14:15:35 <lambdabot> (a -> b) -> a -> b
14:16:24 * hackagebot snaplet-fay 0.3.1.1 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.3.1.1 (AdamBergmark)
14:16:36 <dacto> these little things always sap time lol
14:20:34 <fizbin> Anyone know any good libraries/patterns for converting haskell datastructures to/from some pickled form? (e.g., to/from XML)
14:22:15 * fizbin investigates Text.XML.HXT.Arrow.Pickle, despite having been bitten nastily by HXT in the past.
14:22:24 <Taneb> aeson for JSON
14:22:25 <Taneb> Don't actually know any that are similar to aeson but for XML
14:24:50 <otters> haskell programmers don't use XML
14:25:08 <monochrom> I use XML all the time
14:25:19 <monochrom> I also use HXT
14:25:58 <bitonic> fizbin: the fact that you use the world ‘pickled’ makes me think you might want something like Binary/Cereal
14:26:15 <bitonic> compact binary representation over plaintext
14:26:35 <henk> I have doubts about this example http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html#g:3. It looks broken to me in the "Option ['o']" and "Option ['c']" line. It uses "inp" and "outp" there, but that is supposed to correspond to the "data Flag" values "Input" and "Output". Am I right in assuming that this is some kind of typo/inconsistency? Or is everything fine about that
14:26:38 <henk> example?
14:27:31 <monochrom> it is not a typo
14:27:44 <skp> hey
14:28:03 <skp> is there a way to write android programs in haskell?
14:28:10 <joe9>  I am looking to convert a date string from "mm/dd/yyyy" to "yyyymmdd" . I found this http://stackoverflow.com/questions/4174372/haskell-date-parsing-and-formatting using Locale, Data.Time and Data.Time.Format.
14:28:15 <skp> through a binding to C++ or Java JVM
14:28:18 <joe9> I read that Locale is old now
14:28:35 <monochrom> outp (Just "x") = Output "x".
14:28:44 <joe9> Is there a better package to do the date stuff?
14:28:52 <monochrom> outp (Nothing) = Output "stdout"
14:29:12 <fizbin> bitonic: My concerns here mean that compactness is not at all a concern, and plaintext of any sort is preferable to binary for this. Besides being a communication boundary between two programs written in haskell, it's very likely that this representation will also be used by humans to debug, and may eventually be read by something constructing a web UI of the intermediate steps in this process.
14:29:28 <bitonic> fizbin: OK.  go for JSON
14:29:56 <bitonic> fizbin: both ‘aeson’ and ‘json’ contain modules that derive the representation
14:30:08 <monochrom> you need no locale to convert from "mm/dd/yyyy" to "yyyymmdd".
14:30:10 <fizbin> joe9: do you really need date parsing? It sounds like you're just shuffling bits of the string around.
14:30:11 <skp> if you have an idea please hl me
14:30:11 <henk> monochrom: oh right, damn. That means I did not understand yet … Thank you!
14:30:13 <Clint> joe9: use System.Locale instead
14:32:34 <aristid> joe9: ignore the warning about locale being old
14:32:46 <aristid> oh yes, it's in System.Locale
14:32:51 <aristid> but even that is "old"
14:33:19 <Clint> "old" with no replacement
14:33:47 <monochrom> I don't understand the worry about locale for this problem.
14:35:34 <joe9> clink, aristid : thanks.
14:36:05 <henk> Can anyone recommend some basic/simple examples of command line option/argument parsing (using getopt)?
14:36:10 <joe9> monochrom: I was trying to convert to a haskell date as the storing format.
14:36:19 <joe9> the output is in yyymmdd
14:36:41 <henk> I’m a little overwhelmed by http://www.haskell.org/haskellwiki/High-level_option_handling_with_GetOpt and http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html#g:3 I think. Or should I just read up until I understand those two?
14:36:52 <joe9> i could just use straight string parsing. but, feel that having it as a haskell date makes sense.
14:37:45 <monochrom> that involves Data.Time but still no locale
14:38:26 <fizbin> Haskell needs a joda equivalent.
14:38:54 <fizbin> But then it'd need someone as obsessive about maintaining it as the guy who maintains the joda time libraries.
14:39:02 <aristid> monochrom: you need to pass the default locale thing because that's just a paraemter :P
14:39:05 <aristid> :t parseTime
14:39:06 <lambdabot> Not in scope: `parseTime'
14:39:13 <aristid> @hoogle parseTime
14:39:13 <lambdabot> Data.Time.Format class ParseTime t
14:39:13 <lambdabot> Data.Time.Format parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t
14:40:34 <monochrom> I see
14:41:05 <monochrom> use undefined
14:41:40 <otters> :t use undefined
14:41:41 <lambdabot> MonadState s m => m a
14:44:19 <latro`a_> :t use
14:44:21 <lambdabot> MonadState s m => Getting a s t a b -> m a
14:44:22 <joe9> I can get 07/13/2012 to work correctly. but, am having trouble with '7/13/2012' http://codepad.org/WuDAvJIn
14:44:41 <joe9> An suggestions on how I can get it to pad the month or day values?
14:45:59 <docksider> Im trying to create a typeclass for a point, snippet: http://pastebin.com/PW0MB2bX , that's how I would like to use it but that code does not work. Because "Could not deduce (a ~ Int)..", what is it that im not understanding?
14:46:07 <mauke> The paste PW0MB2bX has been copied to http://hpaste.org/84347
14:47:19 <johnw> @tell quchen Try hoogle.newartisans.com now, I implemented the refinements in identifier ranking that we discussed
14:47:19 <lambdabot> Consider it noted.
14:47:19 <mika^> mmm, given n players, every time 2 players match agains each other, one goes and one stays. until there's only one left. given the knowledge that player x can beat player y, which algorithm can be used to make sure that a specific player will be the ultimate winner? something to do with graph theory
14:49:19 <geekosaur> docksider, any time your result type does not mention the typeclass type, you should stop and question if typeclasses are correct
14:49:53 <docksider> Thats what's Im doing? the type of element is not what i want it to be
14:50:00 <geekosaur> in this case, indeed haskell cannot guarantee that your unspecified a is allowed to be Int... because when you have a result type a and you do not specify it, it means the *caller* decides --- not you
14:50:15 <labo> henk: can't help you, I just use CmdArgs
14:50:24 <geekosaur> you're doing it iun both length (where it is at least reasonable) and element (where it is not)
14:50:47 <geekosaur> you explicitly told haskell that element will return whatever type its caller wants
14:50:56 <geekosaur> you do not then get to say it is Int
14:50:59 <docksider> Yes, I dont want to do that
14:51:04 <monochrom> if you give me f::Int->a, I will gladly call it with a = my secret type
14:51:05 <geekosaur> then you do not want a typeclass
14:51:32 <docksider> Well i want something that says nothing about the representation
14:51:44 <mauke> forall a. a
14:51:46 <monochrom> then you should use your secret type
14:52:10 <docksider> I want element to return a specific type for a specific member of Point
14:52:22 <docksider> but i don't want to decide it in Point
14:53:06 <henk> labo: Thanks for responding :) Can you recommend CmdArgs? Maybe I should take a look at that?
14:53:38 <monochrom> I have two alternatives. pick one. (A) you don't need a type class. (B) you need a multiple-parameter type class.
14:53:55 <monochrom> in the interest of KISS, I recommend (A).
14:54:00 <docksider> The later sounds like what i tried to achieve
14:54:01 <joe9> fyi, this did it. let timeFromString = readTime defaultTimeLocale "%-m/%-d/%Y" dateString :: UTCTime
14:54:15 <geekosaur> docksider, you should think out what exactly you want it to do and how it should behave. if you don't want to decide that type in Point, where *do* you want to decide it?
14:55:02 <monochrom> in the interest of having enough rope to hang you, I recommend (B)
14:56:00 <docksider> can you do multiple-paramater typeclasses in standard Haskell or is that a ghc extension that you need pragmas for?
14:56:22 <monochrom> it is a GHC extension. MultiParamTypeClass IIRC. may have to add es
14:56:49 <monochrom> GHC extension spellings are pretty inconsistent. it must be rote memory.
14:58:25 <monochrom> once upon a time, "class Container c e | c -> e where ...", "instance Container [a] a where ..." etc were pretty popular
15:01:13 <labo> henk: it's a lot simpler
15:01:24 <labo> http://community.haskell.org/~ndm/cmdargs/
15:02:00 <docksider> Yep, seems multi-parameter type classes is exactly what i tried to achieve by leaving the element type to the inferencer
15:02:14 <henk> labo: Maybe exactly what I want :) Thank you!
15:02:30 <docksider> Thanks :)
15:03:15 <monochrom> the joke about how a programmer envisions a toaster is true
15:04:07 <monochrom> "why don't I add 10 type classes and 5 type families so that I can instantiate them to be the toaster. plus it can receive email."
15:04:35 <docksider> Hehe
15:04:55 <docksider> The reason i seek out such abstraction is because i need it
15:05:05 <docksider> (I Think)
15:05:08 <docksider> Either that or yagni
15:05:15 <shachaf> I haven't been following, but you probably don't.
15:05:32 <shachaf> Type classes tend to be overused by people who are just learning about them.
15:05:34 <ab9rf> :t \p -> map (\l -> filter (\s -> (head s) /= '\'') l) p
15:05:35 <lambdabot> [[[Char]]] -> [[[Char]]]
15:05:37 <docksider> making a kd-tree that takes vectors of any Ord elements
15:06:15 <docksider> Because i got pissed at the ones in hackage, they use Double
15:06:15 <skp> no idea about android?
15:07:01 <docksider> im making the user specify the distance function and the element type when they  want to use my tree
15:08:14 <docksider> shachaf: Seems most of the packages in hackage is code written by ppl just learning the language
15:08:24 <docksider> don't see a lot of coherence at all tbh
15:09:33 <ab9rf> whee, infinite recursion for the lose
15:13:05 <solirc> `data Foo = Foo | Bar` is called a sum type, data `Foo = Foo String Int` is a product type, so how do we call `data Foo = Foo`?
15:13:06 <lambdabot> solirc: You have 1 new message. '/msg lambdabot @messages' to read it.
15:13:24 <arkeet> solirc: a unit type
15:13:42 <solirc> arkeet: thx :)
15:14:15 <shachaf> arkeet: It is an empty product.
15:14:16 <arkeet> for it is the unit for the product (up to isomorphism and bottoms)
15:14:19 <shachaf> s/arkeet/solirc/
15:14:25 <arkeet> indeed. also known as unit
15:15:09 <johnw> shachaf: check out http://hoogle.newartisans.com/?hoogle=*safe+oi
15:15:17 <monochrom> "Foo = Foo String Int" is also a sum type, just uninteresting in terms of sum
15:15:25 <arkeet> it's a sum of 1 thing.
15:15:53 <monochrom> "data U = U" is both product and sum, and uninteresting in both
15:15:56 <solirc> so Foo = Foo is also a sum
15:16:04 <arkeet> in a stupid way, yes
15:16:05 <docksider> So it is also a product type
15:16:06 <hpc> johnw: things i learned from that link: there's a package called enummapmap
15:16:12 <johnw> haha
15:16:16 <arkeet> all simple data types are sums of products
15:16:20 <johnw> that server has other improvements too
15:16:25 <monoidal> arkeet: should I report the ((Num Int => Num) ()) => () bug to trac?
15:16:30 <johnw> which just got merged into hoogle now, so someday...
15:16:31 <arkeet> monoidal: why not?
15:16:34 <monoidal> ok
15:17:27 <arkeet> I wonder if there's a practical purpose to quantifying and constraining classes.
15:18:39 <arkeet> at least we could then treat Constraint in a more consistent way with *
15:19:10 <elliott> arkeet: well what does (Show a => Maybe) mean
15:19:44 <arkeet> but (c Int => c) Int should make sense as a constraint.
15:19:49 <c_wraith> :t undefined :: Show a => String
15:19:51 <lambdabot>     Ambiguous constraint `Show a'
15:19:51 <lambdabot>       At least one of the forall'd type variables mentioned by the constraint
15:19:51 <lambdabot>       must be reachable from the type after the '=>'
15:20:08 <c_wraith> at least one of?  Oh, MPTCs
15:20:25 <arkeet> I dunno.
15:20:48 <arkeet> it might make sense. it might not.
15:45:17 <mcstar> \quit
15:45:37 <otters> :t undefined :: forall a. Show a => String
15:45:39 <lambdabot>     Ambiguous constraint `Show a'
15:45:39 <lambdabot>       At least one of the forall'd type variables mentioned by the constraint
15:45:39 <lambdabot>       must be reachable from the type after the '=>'
15:45:42 <otters> reats
15:46:52 <labo> skp: I read that someone wrote a linux kernel module in haskell
15:47:11 <labo> and android is based on linux :)
15:47:55 <labo> but I have no idea about applications, though it interests me as well
15:49:59 <fragamus> hey guys
15:50:21 <dacto> Hey
15:50:22 <fragamus> Whats the best category theory text
15:51:25 * hackagebot htune 0.2 - harmonic analyser and tuner for musical instruments  http://hackage.haskell.org/package/htune-0.2 (PetrRockai)
15:52:22 <yitz> fragamus: categories for the working mathematician by saunders mac lane. if you are a working mathematician.
15:52:42 <fragamus> im a haskell programmer
15:53:16 <fragamus> which is like being a botswainian lumberjack
15:55:06 <monoidal> fragamus: for lecture notes, I can recommend http://www.maths.ed.ac.uk/~tl/msci/all.pdf
15:55:06 <niteria> what was the name of the package that was a nice wrapper around ncurses?
15:55:26 <monoidal> fragamus: but it's less haskell-oriented
15:58:40 <monoidal> fragamus: also Eugenia Cheng's notes are very readable http://cheng.staff.shef.ac.uk/catnotes/categorynotes-cheng.pdf
15:58:48 <niteria> fragamus: A Gentle Introduction to Category Theory - the calculational approach seemed nice
15:59:03 <fragamus> i just bought the saunders book
15:59:08 <geekosaur> niteria, depends onw hat you mean by nice
15:59:35 <niteria> geekosaur: it was easy to understand
15:59:43 <fragamus> those gentle introductions can be quite violent from my experience
16:00:33 <geekosaur> hscurses is fairly close to the C curses/ncurses api, for example, but the ncurses package appears to be higher level and slightly more haskelly
16:01:41 <niteria> geekosaur: there was something else, I think it supported something else than ncurses, too
16:02:00 <geekosaur> vty?
16:02:34 <geekosaur> and vty-ui
16:02:47 <niteria> maybe
16:06:30 <monoidal> fragamus: saunders book is graduate level. it requires lots of dedication and has a bit specific style
16:15:11 <Ralith> @hoogle (b -> m c) -> (a -> m b) -> a -> m c
16:15:12 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
16:15:12 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
16:15:12 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
16:31:33 <robde> hello, is it possible to use the element of a list in the filter function without using a where binding? like this: filter (mod x 2 == 0) [0..10]
16:31:47 <elliott> > filter (\x -> mod x 2 == 0) [0..10]
16:31:48 <lambdabot>   [0,2,4,6,8,10]
16:32:08 <robde> ah, what is \?
16:32:36 <geekosaur> cheap ascii rendering of lambda (as in lambda calculus), for an anonymous function
16:33:22 <Peaker> > filter ((== 0) . (`mod` 2)) [0..10]
16:33:24 <lambdabot>   [0,2,4,6,8,10]
16:33:41 <robde> ah! would that be a good example case for a lambda expression?
16:33:42 <Peaker> @pl \x -> mod x 2 == 0
16:33:42 <lambdabot> (0 ==) . flip mod 2
16:35:25 <robde> thank you so much!
16:42:28 <niteria> is there a function f such that f [1..] is bottom and f $ f [1..] is not?
16:43:17 <napping> that wouldn't be continuous
16:43:38 <jfischoff> is there a way to clear the output from a ghci session?
16:43:56 <lispy> Does anyone remember the name of that project a while back that was kind of like a mathematica notebook but use haskell?
16:44:03 <lispy> The demo ran in a webpage
16:44:13 <bitonic> lispy: shapr was involved, it was a GSOC
16:44:15 <Mortchek> jfischoff, Ctrl+L
16:44:23 <lispy> bitonic: older, not ghclive
16:44:30 <niteria> ok, what about cheating, what if some of the existing rewrite rules were used (like ones for fusion)
16:44:31 <jfischoff> Mortchek: thanks
16:44:32 <Hafydd> If by "output" you mean the console output, :!clear works in POSIX, at least.
16:44:37 <napping> or was it monotone? anyway, y at least as defined as x implies f y at least as defined as x for any ordinary function
16:44:38 <bitonic> lispy: ah.  dunno
16:44:38 <lispy> I want to say it had wolf in the name
16:44:45 <napping> you can cheat with unsafePerformIO and timeouts
16:44:55 <niteria> one can imagine reverse . reverse being rewritten to id
16:45:29 <napping> ah, if "f" is actually a class method so it's not the same f you might get that
16:45:41 <bitonic> niteria: in haskell reverse . reverse != id, because of the bottomz.  so that rule would be risky
16:46:05 <bitonic> and I agree that there is no ‘proper’ way to define such a bottom-skipping function
16:46:19 <elliott> don't need _|_
16:46:21 <elliott> just need infinite lists
16:46:26 <bitonic> ah right
16:46:33 <bitonic> even worse
16:46:45 <napping> like, class Foo a where f :: a -> [a], instance Foo [Int] where f _ = undefined; instance Foo [[Int]] where f _ = []
16:47:09 <niteria> nice
16:47:50 <bitonic> niteria: the wikibooks page on domain theory might give background on what napping was talking about (monotone functions)
16:48:41 <bitonic> oh if it was just a puzzle I guess napping wins :)
16:48:55 <lispy> bitonic: wolfgang lambda was the name. Seems to have disappeared from the 'tubes
16:49:34 <bitonic> lispy: indeed, only spammy results
16:50:10 <bitonic> lispy: but a clue is ‘jabberwock.xs4all.nl/exp/wolfgang/’, someone here uses that domain
16:51:58 <bitonic> can’t remember who
16:52:17 <luite> me neither
16:53:18 <luite> lispy: yeah it was mine, it's been put on hold for a while though, because i'm really busy with GHCJS
16:54:56 <luite> lispy: the demo was just hacked together in a week or so, i've spent lots of hours after that working on it
16:56:27 * hackagebot pianola 0.1.0 - Remotely controlling Java Swing applications  http://hackage.haskell.org/package/pianola-0.1.0 (DanielDiazCarrete)
17:03:51 <scooty-puff> i was trying to figure out if a finger tree was the write structure for a particular set of operations
17:04:14 <scooty-puff> but i'm having trouble figuring out how <| and |> operate compared to how split operates
17:05:03 <scooty-puff> it appears the the former operate like deque operations, the latter like .. well, depends on the monoid
17:06:09 <scooty-puff> anyways, what is particularly throwing me off is http://hackage.haskell.org/packages/archive/fingertree/0.0.1.1/doc/html/Data-PriorityQueue-FingerTree.html - <| and |> and listed as O(log n) - assume this must be worst case?
17:06:48 <scooty-puff> err, insert and add here, though both just call the underlying fingertree's <| and |>
17:16:20 <arkeet> scooty-puff: it's also O(n^30)
17:16:54 <arkeet> big O only is an upper bound.
17:17:08 <latro`a_> eh, not in practice
17:17:22 <latro`a_> the notation gets used as a superposition of asymptotic bound and "on the order of" in the real world
17:17:44 <latro`a_> "O(10^10)" isn't that uncommon for example
17:17:54 <arkeet> I've never seen that, ever.
17:18:05 <latro`a_> among physicists/physical chemists
17:18:12 <latro`a_> it's not THAT unusual
17:18:26 <arkeet> even among physicists.
17:18:48 <arkeet> maybe I've been hanging around with the wrong kind of physicists.
17:18:55 <latro`a_> more likely I have
17:18:56 <latro`a_> lol
17:18:56 <scooty-puff> i guess what i find confusing is the notation is the same between fingertree and the associated priority queue
17:18:59 <arkeet> lol
17:19:05 <scooty-puff> one is O(1), the other is O(log n)
17:19:18 <scooty-puff> though the latter calls the former directly
17:19:25 <edwardk> scooty: the asymptotics written in that module are a little wonky
17:19:42 <edwardk> they are using the insert to pay down the cost for minView, etc.
17:19:56 <scooty-puff> k - i assumed was something along those lines
17:20:11 <edwardk> but in practice they probably should claim O(1) insert and O(log n) minView, but they bothered to bubble the minView up the tree, so they don't want to say that
17:20:17 <edwardk> but that log(n) has to go somewhere
17:20:21 <edwardk> so the slop it into the insert
17:20:35 <edwardk> er they
17:21:17 <edwardk> otherwise you could get something with precisely those asymptotics with just storing the min priority and not bubbling up the actual value that got that key
17:21:45 <edwardk> as it is they get pay the O(log n) 'up front' so they can charge against it for the O(1) minView later.
17:22:44 <edwardk> this is a nicer set of asymptotics than doing it the other way, because you _can_ repeatedly minView in O(1), once you pay for the insert, since it only gets forced once.
17:48:51 <hpaste> “Anonymous Coward” annotated “listArgMins” with “listArgMins (annotation)” at http://hpaste.org/65911#a84352
17:54:15 <stepkut> I wonder if the new cross-compiler support in GHC will make it easier to support 'bare metal Haskell'
17:54:29 <stepkut> where you target the hardware directly with no OS/libc
17:59:01 <ag90> Hey, is there a way to force something to be garbage collected?
18:00:08 <ag90> I'm doing that needs to use as little memory as possible so I'm wondering if I can manually release some of the vectors that are allocated.
18:00:17 <ag90> s/doing/doing something/
18:00:30 <luite> ag90: you can call performGC, but it will only be collected if you don't have references to it obviously
18:00:52 <ag90> luite: Cool. Thanks.
18:01:47 <ag90> I'm guessing there isn't anything unsafe that can do it more explicitly (and presumably efficiently).
18:01:49 <luite> ag90: so make sure that you force any thunk that may still refer to those vectors, do some heap profiling if necessary
18:02:52 <ag90> luite: I did. Only the byte strings and vectors are taking up any significant memory now. The byte strings are unavoidable and minimal (I re-use buffers used by the bytestrings). It's only the vectors now.
18:03:11 <luite> ah they are allocated rather differently
18:04:03 <luite> so i guess it's good that you mostly have vector, they live on the heap, which helps
18:09:50 <jmcarthur> davorak: it's not readily available right now, but i'll explain the trick
18:09:50 <lambdabot> jmcarthur: You have 1 new message. '/msg lambdabot @messages' to read it.
18:13:38 <jmcarthur> davorak: start with data Suspension o i a = Suspension o (i -> a) deriving Functor. define a data family something like  data family CoroutineF (s :: [(*,*)]) :: (* -> *) -> * -> *, where s is a list of types for your channels. for the empty list you choose the trivial functor (no constructors). for each larger list you make a functor that is the coproduct of a suspension with the smaller coroutine (the tail
18:13:40 <jmcarthur> of the list). now you make a free monad out of CoroutineF
18:13:47 <jmcarthur> davorak: the rest basically follows from that
18:14:38 <jmcarthur> instead of a data family it could be a GADT, but using a data family allows you to use newtypes for the constructors
18:42:04 <dmwit> Straw poll. glib and cairo both implement toUTF8 :: String -> String. How annoyed would people be to find that cairo suddenly depended on glib? How annoyed would people be to discover that both cairo and glib suddenly depended on (say) utf8-string?
18:42:54 <sellout-> dependencies > duplication, IMO.
18:44:02 <ion> “toUTF8 :: String -> String” is an oxymoron.
18:44:19 <sellout-> ion: Yeah, that signature does seem a bit odd.
18:44:37 <dmwit> Yes, I appreciate the typing considerations.
18:45:06 <dmwit> At the moment, those are not debatable (though future might be convinced to consider it an issue).
18:45:45 <ion> toXML :: Integer -> Integer
18:46:37 <sellout-> ion: Well, with bignums, that seems actually more possible than toUTF8 :)
18:46:43 <Twey> dmwit: I assumed that cairo already depended on glib.  I would much rather they both depended on a lightweight package like utf8-string than that one pulled in the other for no better reason than toUTF8.
18:48:09 <dmwit> Twey: That's sort of what I was leaning towards, too.
18:48:14 <dmwit> Okay, that's settled, then.
18:49:04 <Twey> Isn't utf8-string used by GHC now anyway?
18:49:20 <dmwit> Given the name in the "maintainer" field, it wouldn't surprise me.
18:53:05 <hpaste> sproingie pasted “cabal install yesod fails” at http://hpaste.org/84353
18:54:02 <dacto> Does anyone have an example of using pattern guards?
18:56:31 * hackagebot husk-scheme 3.8 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.8 (JustinEthier)
18:59:38 <arkeet> dacto: http://www.haskell.org/haskellwiki/Pattern_guard
18:59:40 <arkeet> has an example.
19:00:05 <dacto> Yeah, I found that one - just seeing if anyone know of some more
19:01:31 * hackagebot network-bitcoin 1.0.2 - An interface to bitcoind.  http://hackage.haskell.org/package/network-bitcoin-1.0.2 (ClarkGaebel)
19:37:39 <Mortchek> I notice myself doing do { foo <- bar ; baz ; return foo } a lot. Is there a more succinct way to phrase this?
19:40:02 <c_wraith> Mortchek: if it's an applicative, foo <* bar
19:40:18 <c_wraith> err, foo <* baz
19:40:42 <Mortchek> That doesn't look right either. But I'll check out that function.
19:40:51 <c_wraith> :t (<*)
19:40:52 <lambdabot> Applicative f => f a -> f b -> f a
19:41:00 <Mortchek> Aha, perfect! Thanks.
19:41:23 <ion> bar <* baz
19:41:46 <c_wraith> yes.  Wow, I'm bad at reading.  The type signature is the important part
19:42:05 <Mortchek> Heheh, yep. Looks to be just what I'm looking for.
19:56:33 * hackagebot gitit 0.10.3.1 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.10.3.1 (JohnMacFarlane)
20:15:41 <natnayr> test hello
20:16:50 <liyang> fail kthxbai
20:17:30 <ion> > fail "kthxbai"
20:17:31 <lambdabot>   No instance for (GHC.Show.Show (m0 a0))
20:17:31 <lambdabot>    arising from a use of `M53848434...
20:18:23 <arkeet> > fail "kthxbai" :: [a]
20:18:25 <lambdabot>   []
20:19:58 <shachaf> johnw: ?
20:30:46 <bytes> hello, i just started learning haskell today and i was wondering which resources to use besides the ones found here http://stackoverflow.com/questions/1012573/getting-started-with-haskell
20:30:54 <bytes> or would those stated there be sufficient?
20:31:46 <monochrom> yes, they are sufficient
20:38:07 <xkcd> Hi, I want to learn haskell I have read several pages on Haskell Wiki but still couldn't understand difference between a functional programming language and imperative programming language Can somebody explain?
20:38:36 <shachaf> Those aren't precise terms, so there isn't a precise answer.
20:38:55 <shachaf> Haskell is an imperative programming language by most accounts. Also a functional programming language.
20:39:57 <monochrom> I'm going to be lazy and just give this answer: read Learn You A Haskell and find out the different mindset. http://learnyouahaskell.com
20:40:45 <xkcd> But this page http://www.haskell.org/haskellwiki/Introduction#What_is_functional_programming.3F says its FPL rather an IPL
20:41:25 <monochrom> actually I myself have an example at http://hpaste.org/52480
20:41:31 <shachaf> Hmm, then that page should probably be updated.
20:41:34 * hackagebot maxent 0.6.0.3 - Compute Maximum Entropy Distributions  http://hackage.haskell.org/package/maxent-0.6.0.3 (JonathanFischoff)
20:41:44 <elliott> I believe the FAQ addresses this topic
20:41:52 <elliott> http://www.haskell.org/haskellwiki/FAQ#Paradigms
20:41:53 <natnayr> Hi, i have to generate moving animation using haskell and the gloss library. Specification is based on gloss:scale and recursively moves according to seconds. Any Tutorials out there?
20:45:08 <hpaste> “Anonymous Coward” annotated “listArgMins” with “listArgMins (annotation)” at http://hpaste.org/65911#a84354
20:46:35 * hackagebot maxent 0.6.0.4 - Compute Maximum Entropy Distributions  http://hackage.haskell.org/package/maxent-0.6.0.4 (JonathanFischoff)
20:51:09 <napping> has anyone looked into loading Happy parse tables dynamically?
20:55:32 <natnayr> Hi, i have to generate moving animation using haskell and the gloss library. Specification is based on gloss:scale and recursively moves according to seconds. Any Tutorials out there?
20:57:22 <no-n> what's the haskell equivalent of "for element in list: print element"?
20:57:45 <napping> natnayr: how about the included examples?
21:00:46 <lispy> has anyone here written a successful haskell platform proposal?
21:00:51 <lispy> I'm working on one and I could use a reviewer...
21:01:05 <Mortchek> no-n, mapM_ print list
21:01:16 <no-n> ty
21:02:57 <alang> edwardk: hello
21:03:01 <edwardk> yo
21:03:31 <alang> do you have any ideas about doing fast matrix multiplications of ad values?
21:03:39 <edwardk> yes
21:03:47 <alang> yay
21:06:28 <edwardk> trying to find the paper one ec
21:06:28 <alang> how should I go about it?
21:06:33 <alang> ok
21:06:35 <edwardk> er one sec
21:09:36 <edwardk> http://people.maths.ox.ac.uk/gilesm/files/NA-08-01.pdf is a start but its not the paper i wanted. basically we can encode AD based matrices and vectors more directly
21:09:51 <edwardk> and take the derivative of matrix equations, not individual scalars
21:10:54 <edwardk> so rather than doing matrices of AD values, its AD functions of matrices
21:11:29 <alang> hmm ok
21:11:42 <alang> this is related to https://github.com/ekmett/ad/issues/2 ?
21:12:03 <edwardk> yep
21:13:36 <alang> ok I'll read the paper
21:13:51 <alang> do you think it will be difficult to implement?
21:15:28 <edwardk> overall its not too bad
21:15:42 <edwardk> that paper isn't the one i was thinking of, but its a good enough start to get you the idea
21:16:04 <alang> ok
21:16:12 <alang> tell me if you come across the other paper
21:17:15 <lispy> napping: what do you mean loading the tables dynamically?
21:17:29 <lispy> napping: I'm guessing I've never looked at it, but I'm curious what you mean
21:21:35 * hackagebot csv-conduit 0.5.0 - A flexible, fast, conduit-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-conduit-0.5.0 (OzgunAtaman)
21:24:43 <lispy> there are so many matrix/linear-alg libraries on hackage. Is Haskell becoming a domain specific language for half-finish math libraries?
21:25:33 <napping> lispy: happy code generated with "-a" uses arrays to encode the transition function
21:26:21 <napping> usually it has a custom type for semantic values, and code for actions (in an Array holding functions), but I'm thinking about writing a generic version of the driver that just parses into something like a tree of strings
21:26:41 <napping> the point being to support languages with some support for extending grammar at runtime
21:30:11 <lispy> napping: ah
21:30:17 <hpaste> “Anonymous Coward” pasted “errors” at http://hpaste.org/84355
21:30:55 <lispy> napping: I'm working on something that has a similar goal (user can provide new operators) but in my case the lexer stays the same so I store the user defined operators in the state of my parser monad (yeah, happy + a monad)
21:30:57 <darkf> Hi - I built the SDL bindings on Windows but they won't seem to run - I get this error http://hpaste.org/84355
21:31:40 <lispy> darkf: does it work if you use this code instead? https://github.com/elliottt/blank-slate
21:31:57 <lispy> darkf: someone I work with made that because he was having trouble getting the sdl bindings to work on windows.
21:32:13 <lispy> darkf: so I don't know if it directly addresses your problem but it should work better
21:32:31 * elliott was very confused by that ping for a second
21:32:46 <lispy> elliott: he has more ts!
21:33:40 <lispy> napping: it could be that happy isn't really a good choice for what you're doing.
21:33:51 <darkf> lispy: Well, unfortunately I don't know OpenGL and I was looking for something that exposes primitives like drawing rectangles/circles and image loading :)
21:34:19 <ab9rf> hm
21:34:41 <simpson> darkf: Those are actually much higher-level things than you'd expect. :3
21:34:56 <simpson> lispy: Is this a thing for easing SDL pain on Win32?
21:35:10 <darkf> simpson: Indeed. Fortunately SDL provides SDL_image, etc. But I can't get them to work! ;)
21:35:44 <simpson> darkf: SDL_image is a separate library and IIRC has separate bindings.
21:36:09 <darkf> Yep.
21:36:19 <lispy> simpson: yes
21:36:45 <lispy> simpson: I haven't tried it so I can't directly vouche for it
21:37:40 <lispy> darkf: for image loading you're probably a lot better off with JuicyPixels
21:37:53 <lispy> darkf: http://hackage.haskell.org/package/JuicyPixels
21:38:15 <lispy> darkf: and if you want some example code to get started: https://github.com/dagit/nehe-tuts
21:38:38 <lispy> darkf: that haskell code matches these tutorials: http://nehe.gamedev.net/tutorial/lessons_01__05/22004/
21:39:06 <darkf> Hmm, is there a graphics library that has high-level features but doesn't get in your way much? Or is writing one in GL my main option? ;)
21:39:33 <lispy> darkf: have you looked at gloss?
21:39:47 <ab9rf> this code is finally working
21:39:53 <lispy> darkf: http://gloss.ouroborus.net/
21:40:01 <ab9rf> it ran into a hitch because the grammar i'm abusing has a circular production
21:40:22 <simpson> lispy: So, my main problem with gloss is that it uses GLUT.
21:40:24 <lispy> darkf: and if it's a static image you might prefer the diagrams package: http://hackage.haskell.org/package/diagrams
21:40:35 <simpson> Which is too bad, because its API is otherwise pretty great.
21:41:04 <lispy> simpson: the author has made a half-way port to GLFW-b. I'm sure patches to fully support it would be appreciated
21:41:37 <simpson> lispy: That's good to know, thanks.
21:43:00 <lispy> simpson: as terrible as GLUT is we still don't have a good substititue for all the functionality of GLUT (in particular, what is the story with fonts? I made a low-level freetype2 binding as a start)
21:43:07 <darkf> lispy: Gloss looks interesting, thanks!
21:43:23 <simpson> lispy: Yeah, fonts are hard.
21:43:57 <lispy> Depending on what day you ask me I still want to replace GLFW-b with something in pure haskell.
21:44:07 <lispy> I'm not a fan of atexit()
21:44:47 <lispy> and the api that glfw presents is probably not that hard to mimic with a tiny bit of ffi and some haskell.
21:46:03 <simpson> The trickiness is in setting up windowing.
21:46:08 <simpson> Which is different on every platform.
21:46:15 <simpson> *That's* what SDL provides so seamlessly.
21:48:47 <lispy> I wonder how much work it would actually be if one person sat down and could dedicate full days to it.
21:49:33 <lispy> It would require a lot of testing on different platforms but I suspect it's not much code and given the other libraries you could probably get a really solid idea of what the api calls need to be like on each platform
21:54:27 <simpson> It's more code than you suspect. I'd start by consulting and rewriting SDL directly rather than trying to grok all of the platforms.
22:16:01 <darkf> maaaan, Haskell really needs some better graphics libaries. Gloss is... confusing :p
22:16:38 <ab9rf> darkf: graphics libraries are always confusing
22:17:05 <darkf> ab9rf: they shouldn't be
22:17:13 <ab9rf> darkf: but they are
22:17:24 <ab9rf> i worked a bit on GDK back in the 90s and that was bad enough
22:18:23 <darkf> everything non-Haskell I use nowadays is some canvas API (fillRect blah; drawString "blah"; etc)
22:18:50 <darkf> that is pretty much what I want, wrapped around IO, but I guess I would have to write it myself
22:18:50 <ab9rf> darkf: because that's what the underlying engines use
22:19:50 <ab9rf> darkf: surely there's a set of gtk bindings that would do that
22:21:49 <ab9rf> yeah, gtk-0.12.0 includes access to drawing areas
22:23:21 <ab9rf> and the primitives are in Graphics.UI.Gtk.Gdk.Drawable
22:23:58 <qnikst> hello, I have a problem, I want to test some functions with criterion, but if I'm using -O2 it breaks all criterion logic
22:24:16 <darkf> ab9rf: apparently Cairo could work too
22:24:43 <ab9rf> darkf: i mainly mention gtk because i used to be a gtk/gdk developer, and so i know that library set
22:24:52 <ab9rf> don't know cairo
22:24:52 <qnikst> should I use separate module build with -O2?
22:25:34 <darkf> ab9rf: I believe Cairo can work fine with GTK
22:25:48 <ab9rf> darkf: yeah, that's a different function, looks to be a renderer
22:26:14 <ab9rf> darkf: rather than a UI library
22:27:15 <darkf> ab9rf: yep, I might have to use GTK to do input/windowing
22:27:38 * darkf now wishes SDL would work :-)
22:27:43 <ab9rf> darkf: i don't really like gtk that much, but there is nothing out there that i like that much more
22:28:11 <ab9rf> sdl's operational model is really intended to be used for full screen games
22:28:27 <simpson> ab9rf: Works fine for tiled and windowed setups too!
22:28:33 <darkf> ab9rf: I rather enjoy using it even for windowed stuff (albeit without hardware acceleration)
22:28:44 <ab9rf> simpson: it does, but it's not what it's _designed_ for
22:29:10 <simpson> ab9rf: Well, in terms of what things are *designed* for... Ever used SDL to access a CD-ROM drive? :3
22:29:31 <ab9rf> simpson: that's part of its gaming role, though
22:29:32 <darkf> oh lord no
22:30:19 <simpson> ab9rf: I think it's also got support for AIX, or some other commercial UNIX along those lines.
22:30:27 <simpson> IRIX! It was IRIX.
22:31:01 <ab9rf> simpson: well, gtk worked on OS/2, most commercial unixes, windows, and BeOS, back when i worked on it :)
22:31:42 <ab9rf> IRIX isn't that difficult to deal with, although it has some fairly interesting display behaviors
22:32:06 <ab9rf> SGI machines had some freakingly awesome graphics capabilities
22:32:14 <simpson> ab9rf: Did you also get a nice chuckle out of the recent Ubuntu Mir news?
22:32:28 <ab9rf> simpson: no, i don't follow that stuff these days
22:33:00 <ab9rf> simpson: don't keep up with the linux gossip at all
22:33:09 <ab9rf> i have my debian machine that i update about once a year :)
22:33:15 <ab9rf> and my windows 7 laptop :)
22:33:22 <simpson> ab9rf: Short version: Ubuntu is going to replace Xorg with something new, developed in-house, and will start shipping it in a year. :3
22:33:31 <simpson> Best timeline ever.
22:33:38 <ab9rf> simpson: oh, dear lord
22:34:02 <ab9rf> simpson: shuttleworth has been baking that for at least 15 years
22:34:24 <ab9rf> simpson: he was recruiting devs for that in the late 90s
22:34:33 <ab9rf> simpson: that's when i decided i didn't like him
22:35:02 <darkf> oh, there we go - SDL works when compiled, but not with `runghc`, heh, silly me
22:35:08 <simpson> ab9rf: Yeah, well, we'll see how badly this crashes and burns. Maybe it'll work, but I doubt it.
22:36:50 <ab9rf> simpson: the linux community is at its core uncompromisingly meritocratic.
22:37:14 <ab9rf> simpson: so if it works, and it's not too opaque, then it might do ok
22:37:52 <ab9rf> simpson: but a year for a windowing system that's enough better than X to displace X?  how much of shuttleworth's money is going to be burnt on this?
22:38:26 <simpson> ab9rf: Don't know, don't care.
22:38:38 <simpson> I just hope that the devs are well-compensated for their time.
22:38:39 <ab9rf> simpson: indeed
22:38:47 <ab9rf> i haven't used X in quite a while, actually
22:38:58 <lispy> darkf: if you want something closer to cairo try diagrams
22:39:27 <lispy> darkf: I'm not really sure what you're looking for so I'm kind of just making suggestions. We have libraries, not all of which work great.
22:39:50 <darkf> lispy: I'm just making a simple game - SDL seems to work fine, so I'll use that. thanks for your help :)
22:39:50 <ab9rf> lispy: you mean not all of it is perfect?
22:40:17 <lispy> darkf: also, yes ghci has a tendency to not run things from the initial thread which tends to break native libs. Try -fno-ghci-sandbox
22:40:57 <lispy> darkf: things that pin their datastructures to the initial process thread don't like the way ghci forks a thread for each expression
22:41:14 <lispy> (thread local storage blah)
22:41:40 <lispy> ab9rf: right. The state of the graphics/gui libraries in haskell is not great. With some determination you can make it work but it's not always worth it :(
22:41:56 <lispy> Sometimes you just have to play around with the different libraries till you find something that you like and suites you needs
22:43:36 <lispy> darkf: those nehe-tuts I linked show how to get glfw-b + openglraw up and running and even texture a cube in one example
22:43:52 <lispy> darkf: there is also a quake3 clone on hackage called frag
22:44:06 <lispy> the source of that might be helpful, but I've found that frag is pretty hard to read
22:44:19 <darkf> lispy: frag is pretty insane yeah - I still have to wrap my head around FRP
22:45:36 <arkeet> I never successfully compiled frag
22:45:53 <ab9rf> making sense of FRP is on my agenda for this decade
22:48:33 <lispy> arkeet: I've built in on osx and windows before. I don't recall it being hard.
22:48:44 <lispy> arkeet: do you remember what broke?
22:48:56 <arkeet> no, it's been a couple years I think
22:49:27 <lispy> For a while it would segfault on start up if it couldn't find the texture files.
22:49:38 <lispy> I fixed that but I don't think my patch ever made it on to hackage
22:50:14 <lispy> I even started to fix the mishandling of mouse input on osx that it has, but it turned into a miserable bug fix so I stopped :)
22:50:45 <lispy> They try to reset the mouse position so that they can always calculate the amoun of movement relative to the last frame. Works fine until your frames come really fast.
22:51:02 <lispy> Then you always have a diff of 0 :(
22:52:38 * lispy declares it bed time
22:52:47 <lispy> Happy hacking; see you folks tomorrow!
22:55:09 <ARCADIVS> Why can't I see the source for Integer? (Not found) http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Integer
22:55:28 <ab9rf> ARCADIVS: why would you expect a primitive type to have source?
22:55:57 <ab9rf> that said, there are a lot of broken links on hackage
22:56:23 <ARCADIVS> Depending on the expressiveness of the language, that isn't necessarily primitive.
22:57:28 <ab9rf> ARCADIVS: all of the source links for base are broken
22:58:15 <ab9rf> at ;east for Prelude
22:58:19 <ab9rf> Prelude is "special"
22:58:51 <ARCADIVS> How can I tell which things in base have a source and which are simply too primitive if many links are broken?
22:59:14 <shachaf> ARCADIVS: cabal unpack base-4.5.0.0; cd base-4.5.0.0; grep
22:59:26 <Jonno_FTW> can anyone help with my question here? http://stackoverflow.com/questions/15516360/haskell-generating-k-itemsets-for-apriori
22:59:53 <ab9rf> j\k\\\
22:59:56 <ARCADIVS> Thanks, shachaf.
22:59:57 <ab9rf> aqwe\\
22:59:59 <ab9rf> gah
23:00:10 <ab9rf> keyboard shifted on me while i was typing
23:02:13 <elliott> ab9rf: actually Integer has source in GHC.
23:02:15 <elliott> @src Integer
23:02:15 <lambdabot> data Integer = S# Int#
23:02:15 <lambdabot>              | J# Int# ByteArray#
23:02:20 <elliott> though it is abstract in Haskell.
23:02:45 <ARCADIVS> What's with the #'s?
23:03:00 <ab9rf> ARCADIVS: GHC implemention specific
23:03:20 <shachaf> GHC allows # as part of an identifier, with an extension.
23:03:35 <shachaf> With that extension you can name anything foo# -- it's not magic in itself.
23:03:47 <hpaste> “Anonymous Coward” pasted “Cabal error” at http://hpaste.org/84358
23:03:50 <shachaf> There are also some primitive types like Int# and ByteArray# that are magic and come from GHC.
23:03:54 <Kaidelong> but by convention it gets attached to unboxed values
23:03:58 <shachaf> Note that S# and J# are just constructors -- they're not primitive.
23:04:09 <shachaf> Kaidelong: Not always unboxed.
23:04:12 <Kaidelong> unboxed basically means it gets passed by value, IIRC
23:04:19 <Kaidelong> shachaf: hence "by convention"
23:04:24 <YellowOnion1> could someone help me install template-haskell : http://hpaste.org/84358
23:04:37 <Kaidelong> although
23:04:41 <Kaidelong> I should probably say tends to
23:06:03 <ab9rf> Jonno_FTW: i suspect you have [a] on one side of ++ and [[a]] on the other
23:06:45 <ab9rf> Jonno_FTW: yup, that's what you have
23:06:54 <Jonno_FTW> how do I fix it then?
23:07:10 <ab9rf> Jonno_FTW: by using the same type on both side of ++
23:07:18 <supki> YellowOnion1: template-haskell package is tied to ghc, you shouldn't install it yourself
23:07:20 <ARCADIVS> @src Int#
23:07:20 <lambdabot> Source not found. You speak an infinite deal of nothing
23:07:24 <Jonno_FTW> well I want to return a [[a]]
23:07:26 <ARCADIVS> @src Int
23:07:26 <lambdabot> data Int = I# Int#
23:07:37 <ARCADIVS> Interesting. :)
23:07:39 <ab9rf> Jonno_FTW: then both args of ++ have to be [[a]] too
23:07:39 <Kaidelong> well if it is a type problem you could use cons
23:07:47 <Kaidelong> rather than append
23:07:57 <Kaidelong> why'd ghci accept it then
23:07:58 <YellowOnion1> supki, well its a dependency of the package I was trying to install (process-conduit)
23:07:58 <ab9rf> Jonno_FTW: ck is [a]
23:08:06 <supki> YellowOnion1: not that's impossible, it will just lead to weird problems after
23:08:42 <ab9rf> Jonno_FTW: or possibly ck is [[a]], and you're doing [[a]] ++ [[[a]]]
23:08:45 <ARCADIVS> @src ByteArray
23:08:46 <lambdabot> Source not found. It can only be attributed to human error.
23:08:49 <ab9rf> but still noncomformant
23:08:53 <Kaidelong> t : u :: [[a]]  ==>  t :: [a], u :: [[a]]
23:08:55 <Jonno_FTW> ck is [[a]]
23:09:23 <YellowOnion1> supki, should I be updating ghc?
23:10:21 <Jonno_FTW> Kaidelong: ghci, didn't accept it, I just commented it out and run some cmds
23:10:31 <Kaidelong> oh okay
23:11:07 <Jonno_FTW> using cons doesn't work either
23:11:16 <supki> YellowOnion1: process-conduint accepts template-haskell (≥2.4 & <2.9)
23:11:32 <Kaidelong> what I'd do at this point is solve kItemSets' k t by hand for an example
23:11:39 <supki> YellowOnion1: you can try  cabal install process-conduit --constraint='template-haskell installed'
23:11:53 <Kaidelong> and see what goes wrong
23:12:44 <ab9rf> i'd also be adding type signatures to tht code
23:13:00 <YellowOnion1> supki, this error is basically always causing me problems I'm not sure why cabal tries to install template haskell every time if it is already installed.
23:13:11 <Kaidelong> that's idiomatic for haskell at least
23:13:23 <Kaidelong> it does have the advantage of helping put type errors closer to where the actual error is
23:13:27 <ab9rf> if you add type signatures and the compiler rejects them it means what you wrote wasn't what you thought you wrote
23:14:20 <ab9rf> and it often moves the type error closer to the problem... sometimes you get type errors way the far away from the actual error otherwise
23:15:21 <ab9rf> especially once you have monads running around mating with one another
23:15:34 <supki> YellowOnion1: hmm, what version of ghc do you have?
23:15:35 <Kaidelong> on the other hand the type inference engine might be better at generalizing your code but I guess haskell's particular approach to static typing makes it more about error checking than automatic generalization
23:15:59 <Jonno_FTW> okay I'll do that
23:16:04 <YellowOnion1> supki, what ever comes with plateform 12.4 I think
23:16:29 <YellowOnion1> supki, I have v2.5 template-haskell
23:17:18 <supki> oh, that's old
23:17:34 <YellowOnion1> well its the lastest stable on the site
23:18:01 <ab9rf> i had a type error earlier tonight where it was complaining about a mismatch with an IO type in a function that had nothing to do with IO because I had left out a return somewhere
23:18:32 <supki> actually that's strange, HP site claims th-2.7 is in current platform
23:18:41 <Kaidelong> wouldn't "[ y | y <- nub cs, count y cs >= o]" be simpler?
23:18:56 <YellowOnion1> supki, I'm using windows if that has anything do with.
23:18:57 <supki> YellowOnion1: what does ghc --version say?
23:19:04 <Kaidelong> although that looks kind of wrong
23:19:05 <Jonno_FTW> yep
23:19:11 <Jonno_FTW>  i thought it was a bit odd
23:19:16 <YellowOnion1> supki, 7.0.4
23:19:37 <Kaidelong> why not
23:19:42 <Kaidelong> @ty group
23:19:44 <lambdabot> Eq a => [a] -> [[a]]
23:20:07 <Kaidelong> @ty length . group . sort
23:20:09 <lambdabot> Ord a => [a] -> Int
23:20:16 <Kaidelong> @ty map length . group . sort
23:20:18 <lambdabot> Ord a => [a] -> [Int]
23:20:45 <Kaidelong> > map length . group . sort $ [1,43,3,45,1,2,3,4,4,3,2,6,6,5,3,3,6,3,3,1,1,4,5,6]
23:20:49 <lambdabot>   [4,2,7,3,2,4,1,1]
23:21:01 <arkeet> > map (head &&& length) . group . sort $ [1,43,3,45,1,2,3,4,4,3,2,6,6,5,3,3,6,3,3,1,1,4,5,6]
23:21:03 <lambdabot>   [(1,4),(2,2),(3,7),(4,3),(5,2),(6,4),(43,1),(45,1)]
23:21:33 <arkeet> :t non
23:21:35 <lambdabot> (Eq a, Functor f, Profunctor p) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
23:21:49 <supki> YellowOnion1: then you probably should update, current plarform bundles ghc 7.4.2. Actually it would be enough to upgrade cabal-install since it was overenthusiastic about reinstalls
23:21:50 <Kaidelong> &&& was either in Control.Arrow or Control.Category, it's worth knowing
23:21:54 <arkeet> Arrow
23:22:16 <supki> YellowOnion1: but on windows it's probably easier to upgrade platform I don't know
23:22:33 <arkeet> I bet there's a lensy way to do this.
23:23:45 <Kaidelong> I've never seen the profunctor typeclass before. Looks like it's a pair of two functors, one covariant and one contravariant?
23:23:56 <supki> YellowOnion1: did --constraint trick worked?
23:24:56 <YellowOnion1> supki, yeah but I get more errors, TBH I've been plagued by so many errors I give up every few months, if I could actually find a platform update it might solve all my problems.
23:25:23 <arkeet> > foldl' (\m i -> m & at i . non 0 +~ 1) M.empty "hello world"
23:25:26 <lambdabot>   fromList [(' ',1),('d',1),('e',1),('h',1),('l',3),('o',2),('r',1),('w',1)]
23:25:35 <arkeet> ;)
23:26:15 <Kaidelong> I do not imagine this abstraction is particularly helpful to Jonno though and possibly also intimidating
23:26:26 <Kaidelong> speaking of which
23:26:47 <Kaidelong> it'd be easier to help you Jonno if I knew what that algorithm was actually supposed to do, I don't actually know what those terms mean
23:27:35 <Kaidelong> you should put a type annotation on that list comprehension though, definitely
23:27:51 <Kaidelong> to make sure it is what you think it is
23:28:39 <YellowOnion1> supki, wait a minute I have plateform 11.4 >.> must have read it wrong, I'll try updating now.
23:58:40 <ARCADIVS> http://stackoverflow.com/questions/6884220/is-there-a-practical-way-of-using-natural-numbers-in-haskell This is an interesting question that makes me wonder. Why doesn't haskell allow expression of smart constructors as /part/ of the data definition so you don't need to hide the actual constructors in your module?
