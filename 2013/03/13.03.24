00:00:18 <dmj> tgeeky: if I call signum (-ten) it will still give me 0
00:02:00 <Sgeo> What libraries use the ability to make a Monad where the Applicative instance isn't just instance Applicative Foo where { pure = return; (<*>) = ap } to their benefit
00:02:12 <Sgeo> e.g. some optimizations of things when used in an applicative style?
00:02:22 <shachaf> Some parsers, for instance.
00:02:39 <shachaf> Look at all the arrow parsers -- you can do more or less the same tricks.
00:02:42 <elliott> you want your Applicative and Monad instances to coincide for everything but performance
00:03:40 <shachaf> Sure.
00:03:51 <shachaf> Well, your internal representation might be different with ap/(<*>)
00:03:55 <shachaf> But it shouldn't be user-visible.
00:04:27 <tgeeky> dmj: I don't know exactly what to say. The most correct answer is you should not be able to / be trying to call signum (-ten) because it should not be well defined (that is, your LT case should = error "this is not defined for the natural numbers")
00:04:51 <tgeeky> that's what shachaf was alluding to initially, I think.
00:05:49 <shachaf> LT case?
00:06:43 <tgeeky> of signum http://hpaste.org/84594
00:07:41 <tgeeky> for what it's worth, I'd guess that there are 30 to 40 online peano numbers implementations scattered around hackage, github, etc
00:07:56 <tgeeky> and between 29 and 39 of them are probably more accurate than me
00:15:02 <tgeeky> dmj: I could state it this way: making an instance of Num (ignoring the default function definition) expects you to only ever return one of: [-1,0,1]; but it does not mandate that you *must* ever return any of them, you could just blindly return 0 all the time.
00:15:30 <tgeeky> It expects that you return [-1] when the input is negative, but that won't be a problem because Peano numbers don't have negative numbers.
00:16:05 <tgeeky> dmj: same with abs; conceptually it just strips a leading (-) from a number if it exists, but it should not for Peano
00:21:35 <TravisD> Is there some way to tell ghc to recompute a value instead of storing it in memory?
00:25:51 <c_wraith> TravisD: In some cases, that's a challenge
00:27:39 <c_wraith> TravisD: the first thing to try is not referring to it with a constant binding. Doing that always keeps it in memory
00:31:41 <TravisD> ah
00:48:57 * hackagebot hoodle-types 0.2 - Data types for programs for hoodle file format  http://hackage.haskell.org/package/hoodle-types-0.2 (IanWooKim)
00:48:59 * hackagebot hoodle-builder 0.2 - text builder for hoodle file format  http://hackage.haskell.org/package/hoodle-builder-0.2 (IanWooKim)
00:49:02 * hackagebot hoodle-parser 0.2 - Hoodle file parser  http://hackage.haskell.org/package/hoodle-parser-0.2 (IanWooKim)
00:49:04 * hackagebot hoodle-render 0.3 - Hoodle file renderer  http://hackage.haskell.org/package/hoodle-render-0.3 (IanWooKim)
00:49:06 * hackagebot hoodle-core 0.10 - Core library for hoodle  http://hackage.haskell.org/package/hoodle-core-0.10 (IanWooKim)
00:54:08 * hackagebot hoodle 0.2 - Executable for hoodle  http://hackage.haskell.org/package/hoodle-0.2 (IanWooKim)
00:54:18 <wavewave> lol
00:59:47 <hpaste> “Anonymous Coward” pasted “type definition error” at http://hpaste.org/84595
01:00:32 <hpaste> “Anonymous Coward” revised “type definition error”: “type definition error” at http://hpaste.org/84595
01:01:54 <cenger> hi
01:03:16 <wavewave> hi
01:03:49 <cenger> I am trying to define a new data type named List, with this piece of code : data List a = Nil | Cons a (List a)
01:04:03 <wavewave> i see your hpaste.
01:04:36 <wavewave> [] is predefined in haskell. you cannot change its type.
01:05:06 <wavewave> List a is [a] anyway.
01:05:10 <arkeet> cenger: you should use ghc :)
01:05:43 <arkeet> wavewave: well, not quite "is"
01:05:49 <cenger> let me try the same code in ghci
01:05:55 <arkeet> cenger: no, you'll get the same problem.
01:06:14 <arkeet> the point is that the [1,2,3] syntax only works for the built-in list type.
01:06:37 <arkeet> and [Integer] is not List Integer.
01:06:52 <dmwit> cenger: If you want to create a value of type List Integer, you'll have to use the List constructors: Cons 1 (Cons 2 (Cons 3 Nil))
01:07:17 <arkeet> or, write a function [a] -> List a
01:07:23 <arkeet> (given by, say, foldr Cons Nil)
01:07:27 <shachaf> So you can add either (Is Char Bool) or (Is Char Bool -> Void) consistently to Haskell+RankNTypes.
01:07:34 <shachaf> GADTs and TypeFamilies give you the latter.
01:07:41 <wavewave> is isomorphic to
01:07:42 <shachaf> What's a smaller extension that gives you the latter?
01:08:56 <cenger> Thanks for answers. Let me digest the new info, and read a little about it. :)
01:12:18 <dmwit> shachaf: hpaste ;-)
01:12:55 <shachaf> dmwit: ?
01:13:14 <dmwit> it depends on what your definition of Is is
01:13:22 <shachaf> Good point.
01:13:29 <shachaf> Is a b = forall p. p a -> p b
01:18:16 <dmwit> GADTs suffice.
01:18:48 <dmwit> data CUBV a where CU :: () -> CUBV Char; BV :: Void -> CUBV Bool
01:18:59 <dmwit> foo isCharBool = case isCharBool (CU ()) of BV v -> v
01:19:18 <shachaf> I know.
01:19:34 <shachaf> But GADTs are a pretty huge extension.
01:20:04 <dmwit> Oh, I see, by "GADTs and TypeFamilies give you the latter" you meant "GADTs give you the latter and TypeFamilies give you the latter".
01:20:11 <shachaf> Ah. Yes.
01:20:17 <shachaf> I'm looking for something smaller that captures the power GADTs give you.
01:20:54 <shachaf> In general you could translate that GADT to data CUBV a where CU :: CU (Is Char a) () | BV (Is Bool a) Void
01:21:02 <shachaf> Er.
01:21:13 <shachaf> data CUBV a = CU (Is Char a) () | BV (Is Bool a) Void
01:22:00 <shachaf> But that doesn't let you do everything that a GADT does -- it only lets you use the identity proof positively (to use "a" as "Bool"), not negatively (to prove that you couldn't possibly have "CU").
01:22:15 <dmwit> yes
01:22:49 <shachaf> I want to figure out what the simplest axiom that captures the extra GADT power is.
01:24:11 <shachaf> In HoTT maybe you don't want this axiom.
01:25:12 <dmwit> Aha, and now I understand "What's a smaller extension" to mean "if we were to design a new one from scratch" rather than "currently available in GHC".
01:25:19 <shachaf> Oh. Yes.
01:25:39 <shachaf> Ideally it would be no extension at all, merely a type, but I'm not sure you can even express this as a type.
01:25:52 <shachaf> It seems that clues may lurk in pigworker's thesis.
01:25:56 <shachaf> preflex: seen pigworker
01:26:00 <preflex>  pigworker was last seen on #haskell 335 days, 11 hours, 11 minutes and 14 seconds ago, saying: * pigworker hacked all day, hits the hay.
01:26:14 <hpaste> “Anonymous Coward” pasted “type definition errorless” at http://hpaste.org/84597
01:26:18 <dmwit> I think the smallest reasonable extension would be to add ~ and a case expression with no cases when there's an inconsistent equality in the context.
01:26:19 <lewis1711> why is mapM_ called "mapM_" ? it's not a very clear name
01:26:32 <dmwit> lewis1711: Do you think mapM is a clear name?
01:26:32 <shachaf> Because it's the version of mapM that ignores the result.
01:26:55 <sw2wolf> lewis1711: ignore the return value in mapM_ ?
01:27:01 <dmwit> lewis1711: If so, then I can defend mapM_ as being the version of mapM that ignores things, and _ is the pattern that ignores things elsewhere in Haskell, so it makes sense to use it for that meaning here, too.
01:27:20 <lewis1711> well that explains it. thanks. I tried to google why
01:27:43 <dmwit> shachaf: What do you think of this proposed extension?
01:27:58 <shachaf> dmwit: Oops, I didn't see that.
01:28:17 <shachaf> dmwit: It's interesting that you can't actually write this right now.
01:28:31 <shachaf> I.e. you can't write a value of type (Char ~ Bool => Void)
01:28:33 <shachaf> Not even undefined
01:28:39 <dmwit> Yes, it's very annoying.
01:28:57 * hackagebot attoparsec-conduit 1.0.1 - Consume attoparsec parsers via conduit.  http://hackage.haskell.org/package/attoparsec-conduit-1.0.1 (MichaelSnoyman)
01:29:04 <shachaf> Anyway, I was hoping for something that would let me stick with Leibniz equality if possible.
01:29:19 <shachaf> ~ is a pretty big thing to add to Haskell+RankNTypes -- lots of compiler magic and so on
01:29:19 <dmwit> It would let you stick with Leibniz equality.
01:29:38 <shachaf> Well, sure, but I mean something that works with it directly.
01:29:47 <shachaf> This is a pretty ill-phrased question, in case you haven't noticed. :-)
01:29:53 <dmwit> =)
01:29:56 <shachaf> I'm not entirely sure what I want.
01:31:56 <dmwit> Of course, the very simplest thing of all is just to add a primitive of type Is Char Bool -> Void. ;-)
01:32:22 <dmwit> (I know this is very much not in the spirit of the game.)
01:32:27 <shachaf> Naturally.
01:33:31 <shachaf> Note that GeneralizedNewtypeDeriving more or less amounts to adding a primitive of type Is Foo NewtypeOfFoo in certain contexts, of value unsafeCoerce
01:34:07 <shachaf> That's why you need something like TypeFamilies to actually get an unsafeCoerce out of it.
01:34:14 <shachaf> Plain old types are too parametric.
01:34:42 <shachaf> Anyway I tried to phrase the question in a more general way but talking about type inequality is pretty awkward.
01:34:58 <c_wraith> GADTs will also turn it into unsafeCoerce
01:35:07 <shachaf> Right.
01:35:26 <shachaf> I've mostly been mentioning GADTs and TypeFamilies in the same breath here.
01:36:13 <c_wraith> People who should know have said it's possible to reimplement GeneralizedNewtypeDeriving safely, it's just that no one has gotten around to it yet.
01:36:46 <dmwit> There's even a published paper showing how! =)
01:38:20 <shachaf> And existing implementations, I think.
01:39:39 <shachaf> dmwit: Any reason GHC doesn't already support this extension, by the way?
01:41:42 <shachaf> cmccann: Maybe you know how to talk about this, given the whole type-inequality thing.
01:42:56 <dmwit> "this" = "make newtype deriving play well with TypeFamilies"?
01:43:20 <shachaf> Er, no, the previous topic.
01:43:33 <dmwit> I don't know that anybody's proposed it.
01:43:59 <shachaf> undefined :: Char ~ Bool => a would be nice to have.
01:44:07 <dmwit> Actually, that's not true; I think there *was* actually a proposal a little while back for case statements with empty bodies.
01:44:10 <shachaf> I bet it really messes up typechecking or something.
01:44:31 <shachaf> GHC HEAD has EmptyCase
01:45:00 <shachaf> dmwit: I think if this extension was added it would let you CPS-ify GADTs in a way that you can't do right now.
01:45:53 <shachaf> data Foo a = (a ~ Char) => A One | (a ~ Bool) => B Two
01:46:28 <dmwit> http://hackage.haskell.org/trac/ghc/ticket/2431
01:46:29 <shachaf> newtype Foo a = Foo { runFoo :: forall r. (a ~ Char => One -> r) -> (a ~ Bool => Two -> r) -> r }
01:46:39 <dmwit> It even has absurd :: True :~: False -> a as a use case.
01:46:42 <shachaf> You can write the type Foo but you can't really use it.
01:47:55 <dmwit> So maybe EmptyCase and a hypothetical extension that turned on ~ but not the rest of the type families stuff would be enough.
01:48:08 <shachaf> Hmm, that works.
01:48:32 <shachaf> I mean the "absurd" example there works in HEAD.
01:49:13 <shachaf> dmwit: So that's nice, and a bit smaller than GADTs.
01:49:42 <shachaf> But my main objection to GADTs is that they bring type equality into a context where the compiler knows about it directly.
01:49:52 <shachaf> Whereas Leibniz equality is more implicit.
01:50:03 <dmwit> I don't really think you're going to be able to get away from that.
01:50:23 <shachaf> I don't think I'll properly understand what this axiom is until I do. :-)
01:50:34 <dmwit> At some point the compiler has to notice that Char and Bool don't unify.
01:51:02 <shachaf> Right now the axiom is implemented in GHC via the mechanism of "don't emit a warning under certain conditions".
01:51:05 <dmwit> To ask it to unify them, you're going to have to teach it about Is somehow.
01:51:29 <shachaf> Right, but maybe there's some other way of talking about type inequality or who knows what.
01:51:42 <shachaf> I mean, like you said, you can add (Is Char Bool -> Void) as a primitive.
01:51:51 <dmwit> My understanding was that type inequality was significantly more complicated than type equality.
01:52:16 <shachaf> dmwit: By the way, I'm not sure GHC HEAD+an extension that turned on just ~ is quite enough for this.
01:52:41 <shachaf> Because you still can't write (Char ~ Bool => Void). You have to rely on the fact that you're matching on a GADT.
01:54:05 <dmwit> Oh, well.
01:54:41 <dmwit> Yes, it's a bit annoying that you have to reify constraints via GADTs, considering they're values anyway in core.
01:55:22 <shachaf> @ty mapAndUnzipM
01:55:24 <lambdabot> Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])
01:55:26 <shachaf> @src mapAndUnzipM
01:55:26 <lambdabot> mapAndUnzipM f xs = sequence (map f xs) >>= return . unzip
01:55:29 <shachaf> Weird.
01:55:59 <aCube> @hoogle mapAndUnzipM
01:56:00 <lambdabot> Control.Monad mapAndUnzipM :: Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])
01:56:44 <dmwit> > (length "mapAndUnzipM", length "unzip<$>mapM")
01:56:45 <lambdabot>   (12,12)
01:57:32 <aCube> shachaf: isn't that just sequence . unzip . map f ?
01:57:47 <shachaf> No, the unzip happens post-sequence.
01:57:56 <shachaf> It's liftM unzip . sequence . map f
01:59:39 <dmwit> I like my spelling better.
01:59:56 * aCube too
02:03:15 <dmj> :t sequence
02:03:16 <lambdabot> Monad m => [m a] -> m [a]
02:04:32 <skp> hi
02:04:40 <dmj> sequence_ $ take 4 $ repeat $ putStrLn "hi"
02:04:48 <dmj> > sequence_ $ take 4 $ repeat $ putStrLn "hi"
02:04:49 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
02:04:49 <lambdabot>    arising from a use of ...
02:05:38 <dmj> > sequence_ $ replicate 4 $  putStrLn "hi"
02:05:39 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
02:05:39 <lambdabot>    arising from a use of ...
02:05:50 <dmj> > sequence $ replicate 4 $  putStrLn "hi"
02:05:52 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO [()]))
02:05:52 <lambdabot>    arising from a use o...
02:06:07 <dmj> skp: hi
02:06:48 <aCube> Can anybody help me with http://hpaste.org/84572? I don't understand why #1 loops but #3 doesn't
02:10:04 <skp> how are you dmj?
02:12:27 <beaky> hello
02:12:58 <hpaste> beaky pasted “Refactoring ugly code” at http://hpaste.org/84598
02:13:24 <beaky> I've refactored it a bit, but my code is still the quasimodo of parsing algorithms... what do I do?
02:16:37 <dmj> skp: not bad, watching life of pi, doing haskell u of c lectures. Yourself?
02:16:47 <dmj> http://brick.cs.uchicago.edu/Courses/CMSC-16100/2012/lectures.php
02:16:53 <beaky> haskell lectures? wow thanks
02:17:17 <beaky> I didn't know that they taught haskell to freshman undergrad folks
02:17:39 <Hafydd> Haskell was taught as the first language in a UG CS course I know of.
02:17:41 <beaky> oh, 'honors intro to programming' ^^
02:17:41 <dmj> beaky: yea lucky them :)
02:18:46 <dmj> beaky: I would take haskell over c++ as an undergrad :)
02:18:54 <dmj> anyday
02:18:59 <beaky> In my first undergrad programming class I was taught C++
02:19:08 <dmj> same
02:19:16 <dmj> make a battleship game
02:20:30 <dmj> beaky: Do you use haskell professionally?
02:20:59 <beaky> dmj: nope I am just learning it as part of learning hwo to program :D
02:22:03 <dmj> beaky: nice, sounds fun.
02:24:02 <shachaf> Oh, this is a fun bug-ish thing.
02:24:11 <beaky> knowing a bit of haskell has probably made me a little bit better at programming
02:24:30 <beaky> e.g. I learned that lots of what programmers work with are math stuff like monoids
02:24:59 <shachaf> Prelude> newtype Bar a = Bar { runBar :: forall r. (a ~ Char => r) -> (a ~ Bool => r) -> r }
02:25:17 <shachaf> Prelude> :t runBar (Bar (\x y -> x)) undefined undefined -- runBar (Bar (\x y -> x)) undefined undefined :: r
02:25:38 <shachaf> Prelude> :t let q = runBar (Bar (\x y -> x)) in q undefined undefined -- Couldn't match type ‛Char’ with ‛Bool’ ...
02:26:18 <timthelion> beaky: everything is math and or chaos. To the extent you can "work" you must have regularities, and the description of regularities is called "math".  Haskellers are simply better at describing the regularities in their language. Every language is mathy.
02:26:50 <dmj> beaky: most programmers aren't formally trained in CS and couldn't tell you what big O is much less what functional programming is.
02:27:12 <dmj> *bold*
02:27:16 <beaky> ah
02:29:00 * hackagebot hamlet 1.1.7 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.7 (MichaelSnoyman)
02:29:04 <pharaun> sadly enough
02:29:14 <timthelion> dmj: Some would say every language is a functional language, what makes haskell special is that it's type system allows one to modify the domain and or range of the function, where as in C , every function is just Universe -> Universe
02:29:43 <pharaun> i hate Universe -> Universe :)
02:34:05 <c_wraith> hmm.  (a -> b -> m (c, a)) -> a -> [b] -> m ([c], a)
02:34:22 <c_wraith> throw a (Monad m) => constraint in
02:34:41 <c_wraith> Easy enough to implement, but is it some easy combination of existing combinators?
02:35:40 <aCube> How would you implement that?
02:35:46 <shachaf> Each a provides a value for the next one, mapAccumL-style?
02:35:55 <c_wraith> yeah
02:36:02 <c_wraith> Is that mapAccumL?
02:36:04 <c_wraith> :t mapAccumL
02:36:06 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
02:36:10 <c_wraith> close
02:36:12 <c_wraith> just monadic
02:36:15 <shachaf> No, you don't have the M
02:36:18 <shachaf> Right.
02:36:34 <c_wraith> and I flipped the tuple types
02:36:56 <shachaf> mapAccumL is mapM in State
02:37:01 <shachaf> Maybe you can do it with StateT
02:37:10 <dmj> timthelion: I wish there was a definitive definition as to what functional programming is. I've heard it defined as "first class functions" (Which would rule out java but includes C). And then others include "immutable by default"
02:37:35 <aCube> C has first-class functions?
02:37:38 <mauke> no
02:38:01 <timthelion> C has first class functions, but not first class Clojures ;)
02:38:11 <timthelion> C has first class function pointers
02:38:18 <shachaf> Hmm, I was going to take inspiration from lens's implementation of mapAccumLOf
02:38:21 <shachaf> But...
02:38:22 <shachaf> mapAccumLOf l f acc0 s = swap (runState (l g s) acc0) where g = cotabulate $ \wa -> state $ \acc -> swap (corep f (acc <$ wa) (extract wa))
02:38:23 <beaky> C has first-class references :D
02:38:32 <mauke> C functions are little more than labeled blocks
02:38:39 <mauke> beaky: C has no references
02:38:42 <beaky> ah :(
02:38:46 <c_wraith> cotabulate?
02:38:54 <aCube> :t cotabulate
02:38:55 <lambdabot> Not in scope: `cotabulate'
02:39:01 * hackagebot confsolve 0.3.7 - A command line tool for resolving conflicts of file synchronizers.  http://hackage.haskell.org/package/confsolve-0.3.7 (DanielTrstenjak)
02:39:06 <c_wraith> by the arg names, I'd assume it's a comonad thing
02:39:07 <aCube> it's in Corepresentable type class
02:39:08 <shachaf> @ty Data.Profunctor.Rep.cotabulate
02:39:09 <lambdabot> Data.Profunctor.Rep.Corepresentable p => (Data.Profunctor.Rep.Corep p d -> c) -> p d c
02:39:14 <timthelion> C has first class structs that contain state and function pointers, and do what clojures do in 10 times the code :D
02:39:34 <timthelion> What C does NOT have is partial application.
02:39:50 <aCube> timthelion: But C++ has, see boost::bind
02:40:04 <mauke> timthelion: do you mean "closure"?
02:40:20 <timthelion> mauke: yes, sorry, my mind has been corrupted.
02:41:00 <timthelion> Ever since I started getting fluent in Haskell, my C code has started being littered with function pointers.
02:41:06 <aCube> :p
02:41:32 <beaky> yes functions are the ultimate abstraction
02:41:45 <beaky> it was proven since 1930 that functions can express all of computation
02:42:07 <timthelion> I'm still not fluent in monad transformers though. And I never will be, because they are gross and non-performant.
02:42:37 <dmj> aCube: I don't think bind in C++ is the same in haskell, nor functor. Unless you were being facetious
02:42:41 <srhb> timthelion: I'm fluent in them and don't really get the alternatives, so my code is gross and non-performant, except GHC fixes that for me.
02:42:42 <timthelion> beaky: the question, is whether computation and interaction are the same thing.
02:43:09 <timthelion> srhb: there are alternatives to transformers?
02:43:19 <srhb> Building your own monads, presumably.
02:43:40 <shachaf> c_wraith: I'm not sure StateT saves you that much...
02:43:56 <timthelion> I would love to have a way to "store partial monad operation in object" function, rather than use a transformer.
02:44:42 <shachaf> @ty \f a bs -> (`runStateT` a) (mapM (\x -> do { y <- get; (x',y') <- lift (f y x); put y'; return x' }) bs)
02:44:43 <aristid> timthelion: meanwhile, transformers do exist, unlike your wish thing.
02:44:43 <lambdabot> Monad m => (s -> a -> m (b, s)) -> s -> [a] -> m ([b], s)
02:44:50 <beaky> does haskell has C's ternary operator?
02:44:53 <shachaf> c_wraith: It would be nice if there was a monadic version of "state".
02:44:57 <aristid> beaky: if then else.
02:45:01 <beaky> ah
02:45:12 <c_wraith> heh.  stateT
02:45:15 <timthelion> Like, with Maybe, I can do some monadic stuff, and then carry my Mabe a elsewhere, but with some other monads, their States are not portable and that makes them useless to me.
02:45:33 <srhb> timthelion: What Monads, for instance_
02:46:19 <timthelion> srhb: Like I was looking at Haskeline, it stores it's state in a non-escapable monad, but I don't want to keep my entire program in the Haskeline monad just to get input.
02:47:05 <srhb> Hm.
02:47:23 <aristid> timthelion: that criticism isn't even specific to transformers
02:48:04 <timthelion> aristid: Well, it is specific to all non escapable, non general purpose monads.
02:48:13 <aristid> yes
02:48:26 <timthelion> aristid: I could use transformers to HELP. But they would make my code ugly.
02:48:26 <aristid> and i agree that this is a rather annoying design then
02:48:38 <aristid> timthelion: ?
02:48:44 <aristid> timthelion: you mean using liftIO?
02:48:51 <timthelion> aristid: yes.
02:48:52 <aristid> even liftIO is not a transformers thing IMHO
02:48:58 <aristid> but whatever :P
02:49:52 <aristid> i think it's unfair that you hate transformers just because haskeline has a bad API design.
02:50:42 <timthelion> aristid: well, I think that they demonstrate a weakness in Haskells monad implimentation, that the monads are not very combinable.
02:50:56 <c_wraith> that's unrelated to the implementation
02:51:04 <c_wraith> That's just math
02:52:34 <aristid> i'd love to see your more combinable alternative to monads :D
02:52:44 <timthelion> Well actually, I wonder if we could create a "twist,or flip" function. that would take a transformer, and reverse it. So it would take WriterT IO a and give us IOT Writer a (does IOT exist?) then we would just twist our transformers to choose which monad we wanted to be active, and no more lifting needed.
02:53:04 <c_wraith> IOT has some metaphysical issues
02:53:04 <aristid> IOT cannot exist.
02:53:27 <c_wraith> IOT Cont, for instance, would require being able to set the universe back to a previous state.
02:53:33 <c_wraith> Or, for that matter, to a future state.
02:54:30 <aristid> timthelion: the transformers you're familiar with are probably mostly StateT, ReaderT and WriterT? those _do_ commute. most others don't.
02:55:44 <shachaf> "commute"?
02:56:04 <aristid> shachaf: i guess i used the wrong word. but you know what i mean. tell me the right word.
02:56:16 <c_wraith> commute seems to mean the right thing.
02:56:38 <aristid> @unmtl StateT s (MaybeT Identity) a
02:56:38 <lambdabot> s -> Maybe (a, s)
02:56:41 <c_wraith> However, it's already used in very similar contexts by the term "commutative monad", which means something very different
02:56:45 <shachaf> Ah, you mean only among themselves.
02:56:59 <aristid> @unmtl MaybeT (StateT s Identity) a
02:56:59 <lambdabot> s -> (Maybe a, s)
02:57:33 <aristid> subtle difference, but it's different :)
02:57:45 <c_wraith> hardly subtle at all. >_>
02:57:53 <aristid> c_wraith: i missed it at first :D
02:58:09 <c_wraith> Oh, I usually end up with the wrong one on my first try.
02:58:09 <shachaf> It would be less subtle if State's tuple had the right order!
02:58:21 <aristid> shachaf: :)
02:58:24 <c_wraith> But the difference is *huge* in practice :)
02:58:40 <aristid> right.
02:59:04 <c_wraith> especially if you start using the MonadPlus instance for those.
02:59:10 <aristid> timthelion: so sadly, the universe hates your idea of twisting around monad transformers :)
02:59:12 <c_wraith> Wow does it matter then
02:59:35 <timthelion> aristid: but you see how it would be usefull ;)
02:59:45 <shachaf> It would be useful if 1=0
02:59:48 <aristid> timthelion: oh sure, if it was possible at all.
02:59:56 <aristid> if 1=0, everything would be possible! \o/
03:03:39 <skp> hi
03:04:55 <skp> I handle error with Either
03:05:00 <skp> something like
03:05:35 <skp> newtype GLError = Either (String,GLenum)
03:05:38 <skp> in my engine
03:05:56 <skp> newtype GLError = GLError (String,GLenum)
03:05:59 <skp> no Either actually
03:06:28 <skp> so in my engine, if something goes bad (in EitherT monad), it « lefts » a GLError
03:06:34 <skp> and the GLenum is set by my engine
03:06:48 <skp> now, what if the client wants to « left » too?
03:07:00 <skp> he can’t with that because of the GLenum he doesn’t have access
03:07:24 <skp> maybe I should just drop the GLenum part of the tuple
03:07:32 <skp> and make it simplier
03:09:38 <dmj> Is "Categories for the working mathematician" the go-to book on category theory?
03:10:30 <dmj> or does that book not exist?
03:10:55 <bitonic> dmj: that’s the go–to book if you are a working mathematician
03:11:24 <bitonic> dmj: if you’re not, most people suggest <http://ukcatalogue.oup.com/product/9780199237180.do>
03:12:20 <aCube> Can instance resolution make a program loop at runtime?
03:14:45 <dmj> bitonic: This is perfect! I've been looking for something like this
03:15:26 <dmj> bitonic: looks like the author sat under Saunders Mac Lane too.
03:15:32 <bitonic> dmj: he did
03:16:16 <notdan> Hi
03:16:22 <dmj> bitonic: looks like our conversation is verbatim in the preface
03:16:37 <dmj> bitonic: did you read this?
03:16:54 <dmj> bitonic: more importantly did it help you with haskell in any way?
03:16:58 <bitonic> dmj: I read a bit, but I got bored
03:17:33 <arkeet> aCube: no. types don't exist at runtime
03:17:42 <bitonic> dmj: the little I learnt did not help me much, but it can help you if you are interested in certain things.  I wouldn’t read it if my goal was to be a better Haskell programmer
03:17:44 <arkeet> and all instances are resolved at compile time
03:17:44 <hiptobecubic> working mathematician is .... terse
03:18:27 <aCube> arkeet: But then I can't understand how http://hpaste.org/84572 can loop / hang
03:19:47 <aCube> How can I get core ouput from GHC?
03:19:55 <arkeet> -ddump-core, or ghc-core
03:20:18 <hiptobecubic> ghc-core is what you want. it's got syntax highlighting.
03:20:24 <arkeet> :p
03:20:35 <bitonic> dmj: the feeling I get is that CT gains you a deeper understanding of many abstractions, and that can be transported a bit in Haskell programming.  packages like ‘lens’ and ‘pipes’ seem to have benefited from the authors’ knowledge of CT.  personally if I wanted to understand Haskell in a deeper way I’d read a book on types
03:20:54 <arkeet> I would too.
03:21:53 <lewis1711> what is "<-" called, and why can't I find out its type in ghci?
03:22:08 <bitonic> lewis1711: ‘<-’ is a piece of syntax, not a function
03:22:20 <lewis1711> oh
03:22:21 <aCube> ghc: unrecognised flags: -ddump-core ?
03:22:28 <bitonic> lewis1711: part of ‘do’ notation, which is expressed in terms of ‘>>=’ and ‘return’
03:22:33 <bitonic> AKA Monad :)
03:22:34 <arkeet> aCube: er... that's not it. but you still want ghc-core
03:22:48 <aCube> arkeet: I don't have ghc-core on my system as it seems :O
03:22:48 <arkeet> (the flag was -ddump-simpl)
03:22:55 <arkeet> you should install it.
03:22:57 <arkeet> it's on hackage.
03:23:09 <lewis1711> does it have a name? because I don't really get what it does
03:23:17 <arkeet> lewis1711: it's part of do notation
03:23:23 <lewis1711> ok, I'll look that up
03:23:27 <aCube> How can I install it for multiple ghc versions?
03:23:39 <bitonic> lewis1711: the thing to understand is monads.  ‘do’ is simple syntactic sugar
03:24:00 <bitonic> lewis1711: if you just want to do IO, then you might just want to use ‘do’ without understanding it
03:24:04 <bitonic> for a bit anyway
03:24:14 <timthelion> lewis1711: "x <- f;somethingElse" is like "f>>=(\x->somethingElse)"
03:24:19 <lewis1711> I am aiming for a superficial understanding
03:24:36 <lewis1711> basically trying to figure out how to read a file from a commandline argument
03:25:08 <dmj> lewis1711: can I take a shot in the dark and assume you are going through LYAH?
03:25:32 <bitonic> lewis1711: well, you might have heard that in Haskell everything is immutable, and there are no side effects.  ‘do’ gives you an environment in which side effecting tasks can be performed
03:26:21 <timthelion> import System.Enviornment\nmain = do args <- getArgs; case args of []-> putStrLn "No file given." ; (f:_) -> do contents <- readFile f ; putStrLn contents
03:26:46 <lewis1711> dmj: nope. I read that a while ago though.
03:26:55 <lewis1711> ok that was much different to what I was trying
03:26:58 <timthelion> lewis1711: that's how, plus or minus some indentation for the case
03:29:38 <dmj> lewis1711: Chapter 9 of LYAH gives a good walkthrough of IO. import System.IO
03:29:38 <dmj> main = do
03:29:38 <dmj>     contents <- readFile "girlfriend.txt"
03:29:41 <dmj>     putStr contents
03:29:57 <lewis1711> yeah I know that much
03:30:01 <timthelion> dmj: I already posted the answer
03:30:03 <lewis1711> but it's not from a commandline
03:30:06 <bitonic> ‘import System.Environment; main = do {args <- getArgs; case args of {[] -> putStrLn "No file given.";(f:_) -> do {contents <- readFile f; putStrLn contents}}}’ is actually valid Haskell :P
03:30:38 <lewis1711> ohh
03:30:52 <timthelion> bitonic: it's sad, I typed that out without reference material, I've been coding too much I guess.
03:31:02 <lewis1711> get args is "IO [String]" not "IO String"
03:31:22 <timthelion> lewis1711: yep :D
03:31:27 <dmj> yes, and I believe the first argument is the filename no?
03:31:28 <bitonic> timthelion: ?
03:31:55 <dmj> timthelion: that's nothing to be sad about :)
03:31:55 <lewis1711> yes
03:32:02 <lewis1711> ok now timthelions code makes perfect sense
03:32:33 <bitonic> timthelion: oh, I get it now.  it’s unsurprising ehe
03:34:22 <hpaste> dmj pasted “timthelion's code” at http://hpaste.org/84602
03:34:50 <dmj> I didn't test it, but it compiles
03:35:03 <timthelion> dmj: well if the first argument is not a file, then the program will exit and give you a nice friendly error message that there was a user error and that the file does not exist.
03:35:24 <timthelion> ;)
03:36:44 <dmj> timthelion: I always did appreciate friendly error messages
03:37:33 <lewis1711> can I declare a normal value in do notation, not one of type "IO t" ?
03:37:56 <timthelion> I tend to write code without exception handling. The trick is, to make sure that the exception happens before you write anything to disk. That way, the program will exit informatively no harm done, and your code isn't dirtied by unnessecary checks.
03:38:01 <dmj> yea let bind it
03:38:06 <dmj> let normalvalue = 7
03:38:17 <dmj> > let normal_value = 7
03:38:18 <lambdabot>   not an expression: `let normal_value = 7'
03:39:11 <lewis1711> ahh
03:39:22 <lewis1711> is that the reason why you must use "let" in ghci?
03:39:26 <dmj> yes
03:39:29 <dmj> everything is in the IO Monad
03:40:09 <dmj> the only place you can use "let" without a corresponding "in" is inside a monadic context
03:40:19 <dmj> amiright?
03:40:33 <arkeet> inside do notation
03:40:42 <arkeet> or in a list comprehension
03:41:04 <arkeet> > [foo | x <- [1..5]; let foo = 2*x]
03:41:06 <lambdabot>   <hint>:1:19: parse error on input `;'
03:41:09 <arkeet> > [foo | x <- [1..5], let foo = 2*x]
03:41:10 <lambdabot>   [2,4,6,8,10]
03:41:37 <arkeet> > [foo | x <- [1..5], let y = [1..x], foo <- y]
03:41:39 <lambdabot>   [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5]
03:41:47 <arkeet> uh
03:41:55 <lewis1711> I don't suppose there's anything where I can look up functions that match some type signature? Show a => a -> IO ()
03:42:01 <arkeet> lewis1711: hoogle
03:42:04 <lewis1711> on it
03:42:06 <arkeet> or hayoo
03:42:10 <dmj> > [(x,y,z) | x <- [1,2,3], y <- [1,2,3], let z = x+y, even z]
03:42:12 <lambdabot>   [(1,1,2),(1,3,4),(2,2,4),(3,1,4),(3,3,6)]
03:42:18 <jbu> hayoo, lol clever
03:42:38 <lewis1711> ah print
03:44:21 <kurkale6ka> Hi, I don't understand how this numbers = 0:map (1+) numbers evaluates to [0,1,2,3,4...] To me it looks like it should evaluate to [0,0,0,0,0,0,0...]
03:45:12 <arkeet> numbers = 0 : something
03:45:27 <arkeet> numbers = 0 : map (1+) (0 : something)
03:45:45 <arkeet> numbers = 0 : ((1+0) : map (1+) something)
03:46:03 <arkeet> er
03:46:23 <arkeet> let's start again.
03:46:29 <arkeet> numbers = something
03:46:35 <arkeet> numbers = 0 : map (1+) something
03:46:51 <arkeet> where something is numbers.
03:46:57 <arkeet> numbers = 0 : map (1+) numbers
03:47:02 <arkeet> numbers = 0 : map (1+) (0 : map (1+) numbers)
03:47:03 <jbu> hi all: I wish to have a function do a sequence of function calls.  I was expecting a do-block to handle this but it appears that only allows monads and let statements in it?  what is the programming idiom for this?  I'm not sure how I made it as far as I have without knowing how to do this
03:47:09 <arkeet> numbers = 0 : (1+0 : map (1+) numbers)
03:47:14 <arkeet> numbers = 0 : 1 : map (1+) numbers
03:47:25 <jbu> *a sequence of function calls that don't return monads
03:47:28 <arkeet> forget it.
03:47:30 <aCube> jbu: What do you mean by "function call"?
03:47:42 <jbu> aCube: just a bunch of methods that don't return mondas
03:47:50 <arkeet> numbers = 0 : 1 : map (1+) (map (1+) numbers)
03:47:51 <arkeet> etc.
03:47:52 <kurkale6ka> arkeet: fotgrt it :) Was your explanation incorrect
03:47:53 <jbu> aCube: in my case they just return data structures
03:48:00 <arkeet> kurkale6ka: I just kept making mistakes.
03:48:21 <aCube> jbu: and what do you want to achieve by calling functions in sequence?
03:48:41 <aCube> combine the datastructures with some function?
03:48:44 <arkeet> kurkale6ka: well, numbers = f numbers, where f x = 0 : map (1+) x
03:48:59 <arkeet> kurkale6ka: now work out the sequence
03:49:14 <arkeet> x, f x, f (f x), f (f (f x))
03:49:17 <arkeet> etc.
03:49:50 <arkeet> @let f x = 0 : map (1+) x
03:49:52 <lambdabot>  Defined.
03:49:54 <arkeet> > undefined
03:49:55 <lambdabot>   *Exception: Prelude.undefined
03:49:56 <arkeet> > f undefined
03:49:58 <lambdabot>   Ambiguous occurrence `f'
03:49:58 <lambdabot>  It could refer to either `L.f', defined at <local...
03:49:58 <dmj> jbu: What do you have so far?
03:50:03 <arkeet> @let asdf x = 0 : map (1+) x
03:50:05 <lambdabot>  Defined.
03:50:06 <arkeet> > asdf undefined
03:50:09 <lambdabot>   [0*Exception: Prelude.undefined
03:50:10 <arkeet> > asdf (asdf undefined)
03:50:12 <lambdabot>   [0,1*Exception: Prelude.undefined
03:50:13 <arkeet> > asdf (asdf (asdf undefined))
03:50:16 <lambdabot>   [0,1,2*Exception: Prelude.undefined
03:50:19 <arkeet> > asdf (asdf (asdf (asdf undefined)))
03:50:21 <lambdabot>   [0,1,2,3*Exception: Prelude.undefined
03:50:32 <aCube> > let x = asdf (asdf x) in x
03:50:35 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
03:50:35 <jbu> aCube, I think I see where you're going...the functions are creating data structures so i need to actually use them in the do block
03:50:37 <arkeet> > fix asdf
03:50:39 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
03:50:42 <arkeet> kurkale6ka: another way to see it:
03:50:51 <arkeet> look at numbers = 0 : map (1+) numbers as an *equation*
03:50:54 <arkeet> the head of numbers is 0
03:50:59 <jbu> dmj: I think I might know what to do, let me get back to you if things fail, thanks
03:51:00 <arkeet> the tail of numbers is map (1+) numbers
03:51:10 <arkeet> so, the (n+1)'th element of numbers is the n'th element of numbers, plus 1.
03:51:28 <arkeet> so the only list satisfying that equation is [0,1,2,3,...]
03:51:39 <kurkale6ka> arkeet: great, good explanation
03:51:47 <aCube> > let x = 0:1:scanl (+) x in x
03:51:49 <lambdabot>   Couldn't match expected type `[a0]' with actual type `[b0] -> [a1]'
03:51:51 <kurkale6ka> arkeet: I will play with it a bit
03:51:54 <aCube> > let x = 0:1:scanl1 (+) x in x
03:51:56 <lambdabot>   [0,1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,1...
03:52:09 <arkeet> > fix $ (0:) . scanl (+) 1
03:52:11 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
03:52:37 <aCube> > let x = 0:scanl (+) 1 x in x
03:52:39 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
03:52:43 <aCube> ah :)
03:53:21 <arkeet> > scanl (+) 1 [a,b,c]
03:53:23 <lambdabot>   [1,1 + a,1 + a + b,1 + a + b + c]
03:54:20 <arkeet> right, so it says that the n'th element of the tail is 1 + the sum of the first n elements of the list.
03:55:09 <arkeet> in other words, F_(n+1) = 1 + F_0 + ... + F_(n-1)
03:55:34 <arkeet> well that's not how it's calculated.
03:56:07 <arkeet> > fix $ (a:) . scanl (+) b
03:56:09 <lambdabot>   [a,b,b + a,b + a + b,b + a + b + (b + a),b + a + b + (b + a) + (b + a + b),...
03:56:48 <bakkl> :t map
03:56:49 <lambdabot> (a -> b) -> [a] -> [b]
04:04:55 <dmj> oh, scanl is cool. The same as foldl, but returns intermediate values.
04:10:19 <Guest68707> Looking for a bit of advice, just started learning Haskell
04:10:24 <Guest68707> A light is just starting to go on in my mind about what's special and different about functional programming.
04:10:29 <Guest68707> I wouldn't mind writing something beyond a few lines now, any suggestions?
04:10:36 <Guest68707> Problem I have is I come from games programming, learning new languages I write a game
04:10:42 <Guest68707> They're really stateful and it doesn't seem like the best usage for Haskell, I'd just end up trying to write a load of imperative stuff wouldn't I?
04:10:46 <Guest68707> Would there be something else that'd be a better learning experience?
04:10:46 <Guest68707> Any opinions gratefully received :)
04:12:01 <sipa> gaztext: do you know LYAH?
04:12:15 <sipa> @where lyah
04:12:15 <lambdabot> http://www.learnyouahaskell.com/
04:12:28 <gaztext> No? all I've done is a few episodes of the Channel9 course
04:12:37 <gaztext> which is ace, it's got a crazy dutchman
04:12:42 <gaztext> cheers :)
04:13:21 <tsinnema> in soviet russia, haskell learns a you
04:13:29 <gaztext> :D
04:13:48 <dmj> Guest68707: You can write games in haskell
04:13:53 <aristid> gaztext: remember the name of the crazy dutchman?
04:13:57 <gaztext> I'm sure you can
04:14:09 <gaztext> Just asking if that's missing the point a bit?
04:14:13 <dmj> http://www.youtube.com/watch?v=gVLFGQGRsDw
04:14:20 <dmj> super mario in haskell
04:14:57 <aristid> gaztext: why would it be missing the point?
04:15:15 <aristid> to write games, you can use quite sophisticated experimental concepts.
04:15:35 <aristid> all kinds of FRP come to mind :P
04:16:31 <gaztext> Yeah but evaluation order is one of the most important things, it -looks- to me that Haskell is awesome when you have a problem where it can do decide what is and isn't evaluated
04:16:34 <gaztext> and when
04:17:32 <gaztext> If you're going to tightly control evaluation you're just writing imperatively aren't you? And loads of other languages do that pretty well
04:17:52 <aristid> no, there are non-imperative ways to control such things as well
04:17:54 <gaztext> I might have a gp at
04:17:55 <gaztext> oops
04:17:59 <dmj> Haskell attempts to mimic imperative constructs using monads, which allow it to maintain its purity without a global state.
04:18:02 <aristid> and haskell isn't bad at imperative programming.
04:18:07 <wyfrn> is there a way to install different versions of a package with cabal ?
04:18:11 <gaztext> I might have a go at generating some geometry I guesse
04:18:20 <XexonixXexillion> is Vector's fromList very slow?
04:18:32 <gaztext> dmj: doesn't the DO operator ensure order?
04:18:38 <gaztext> Or have I got that wrong
04:18:52 <dmj> the do operator is just syntactic sugar
04:18:58 <gaztext> what for?
04:19:06 <sipa> it translatea to monadic binds
04:19:11 <Hafydd> It is also not really an operator.
04:19:17 <gaztext> which in turn ensures order?
04:19:31 <gaztext> Most of the game sources I've looked at are a slew of do :D
04:19:36 <sipa> and those indeed construct an IO action (or other monad) which encodes a certain order yes
04:19:40 <gaztext> for Haskell
04:19:55 <gaztext> Yeah I think I get monads
04:20:07 <sipa> but it's important to realize that an IO action is just a description of an imperative action, and not the action itself
04:20:14 <sipa> so it can evaluate lazily
04:20:30 <sipa> but is executed as you expect
04:20:30 <gaztext> but must maintain order relative to other IO actions?
04:20:56 <mikeplus64> XexonixXexillion: as opposed to what?
04:21:13 <sipa> combining two IO actions using a bind will construct a new IO action consisting of the two original ones, in order
04:21:53 <gaztext> Actually I guesse a lot of game stuff can be expressed where evaluation order isn't important but just you have regular sync points
04:21:55 <Hermit> gaztext: IO actions are performed when they are evaluated, so, to perform a sequence of IO actions, you must thread them using binds. Do notation is just a convenient way to express bindings. It boils down to >>=
04:22:12 <gaztext> What happens when you have IO that's time critical?
04:22:18 <gaztext> Say syncing to 60hz in a game?
04:22:28 <gaztext> for frame refresh?
04:22:46 <gaztext> When it has to be evaluated is dictated externally?
04:23:20 <gaztext> Or any event driven IO?
04:24:03 <gaztext> BTW cheers for the explanation of DO, i was missing that it's just kind of a closure
04:24:23 <mikeplus64> gaztext: i haven't read above, but in glfw and sdl at least, it just reads like while gameIsRunning $ do resetTime; ...; delta <- getTime; let s = 1/60 - delta; when (s > 0) (delay s)
04:24:41 <Palmik> Hmm, I guess it is not possible to have a type family Foo such that (Foo Int ~ FF) and (Foo a ~ TT) if 'a' is not Int, or is it?
04:24:42 <mikeplus64> actually i think glfw automatically syncs buffer swaps to 60 fps
04:25:02 <gaztext> mikeplus64: yeah I think it does
04:25:12 <Hermit> Palmik: I think that's doable with GADTs
04:25:14 <mikeplus64> (but you can do it manually if you want)
04:25:20 <gaztext> well depending on platform, I think there's some differences between mac and linux
04:25:40 <gaztext> okay, I'll try and do some gfx then
04:25:45 <mikeplus64> gaztext: for callbacks, glfw has like setKeyCallback (\key isDown -> ...)
04:26:08 <dmj> gaztext: you might find the source for this game interesting: http://www.haskell.org/haskellwiki/Frag
04:26:10 <XexonixXexillion> mikeplus64: Faster than writing simply constantly resizing the vector
04:26:20 <XexonixXexillion> s/writing simply/simply/
04:26:21 <gaztext> cos I love doing gfx :) I reckon some procedural geometry would cool for haskell
04:26:34 <gaztext> Cheers guys :)
04:26:37 <Hermit> Palmik: simpler yet: /= constraints
04:27:21 <gaztext> Right I got a plane trip tomorrow and I have LYAH on my iPad
04:27:22 <mikeplus64> gaztext: i'm partial to the "OpenGL" package though - it's a "high level" wrapper around a lot of OpenGL, but kind of haphazardly documented iirc. but if you're familiar with OpenGL itself, you should be fine with OpenGLRaw (ie 1:1 bindings with C)
04:27:49 <XexonixXexillion> mikeplus64: well, it's order n, so it's obviously not that, but if I do it a lot is it likely to be a bottle neck
04:28:03 <Palmik> Hermit: Hmm, I'm not really sure how... even with /= (if it can be used as ~).
04:28:23 <mikeplus64> XexonixXexillion: what do you mean constantly resizing, like doing cons 1 (cons 2 (cons 3 empty))?
04:28:32 <gaztext> mikeplus64: cool I know OGL pretty well, didn't know about the raw package
04:29:24 <mikeplus64> gaztext: yeah, it's handy
04:30:05 <Hermit> Palmik: what's the code?
04:30:55 <mikeplus64> XexonixXexillion: fromList should be much faster than lots of Data.Vector.cons-s, unless cons has magical fusion stuff, which it probably does
04:31:24 <XexonixXexillion> mikeplus64: Don't worry about it, I just wrote my own which is fast enough for my purposes.
04:31:52 <mikeplus64> XexonixXexillion: care to paste it somewhere? just out of curiosity
04:36:09 <XexonixXexillion> mikeplus64: I doubt it's faster than fromList, it's just that I need to split a list into 3 vectors, and doing it without calling filter multiple times speeds it up
04:36:57 <mikeplus64> XexonixXexillion: ok, i just have a soft spot for case specific optimizationy things
05:04:44 <chrisdone> mauke: ping
05:14:04 <kdridi> a little question about HXT: I didn't get why getRSS returns an empty array
05:14:05 <kdridi> https://gist.github.com/kdridi/5231661
05:33:52 <notdan> @source fix
05:33:52 <lambdabot> fix not available
05:34:56 <cc> > fix 3
05:34:57 <lambdabot>   No instance for (GHC.Num.Num (a0 -> a0))
05:34:57 <lambdabot>    arising from a use of `e_13'
05:34:57 <lambdabot>  P...
05:35:14 <cc> > const $ fix 3
05:35:15 <lambdabot>   No instance for (GHC.Num.Num (a0 -> a0))
05:35:15 <lambdabot>    arising from a use of `e_13'
05:35:16 <lambdabot>  P...
05:39:20 <alexander__b> okay, confused again
05:39:27 <alexander__b> what does [a | a <- xs, a <= x] actually mean?
05:40:34 <mcstar> == filter (<=x) xs
05:41:05 <alexander__b> mcstar: if that was for me, I have no idea what that means.
05:41:14 <mcstar> read it as english
05:41:35 <mcstar> ignore the ==
05:41:45 <mcstar> thats for 'is equivalent to'
05:42:05 <alexander__b> (<=x) is not a construct you'll find in the English language.
05:42:29 <mcstar> \a -> a <= x
05:42:58 <alexander__b> you are still just posting things I don't understand. if I understood that, I'd probably understand the original sentence I posted.
05:43:34 <mcstar> then i cant help
05:43:43 <Chousuke> is it the list comprehension syntax that is unfamiliar to you or something else?
05:44:06 * hackagebot blaze-builder 0.3.1.1 - Efficient buffered output.  http://hackage.haskell.org/package/blaze-builder-0.3.1.1 (SimonMeier)
05:44:09 <Chousuke> it literally says a for each a from xs where a <= x
05:44:34 <alexander__b> Chousuke: no. it in no way at all literally says that. it uses haskell syntax and semantics to say that.
05:44:48 <Chousuke> which you need to know to be able to read it.
05:44:58 <alexander__b> which I don't, which is why I asked.
05:45:05 <Chousuke> well, now you do.
05:45:22 <mcstar> you could have said it at the beginning
05:45:31 <mcstar> that you are not familiar with haskell the least bit
05:45:44 <alexander__b> right... I'll look at the Web somewhere instead. thanks for trying.
05:45:56 <mcstar> you shouldnt go now
05:46:17 <mcstar> anyway, do you know what a list it?
05:46:22 <mcstar> in haskell?
05:47:12 <mcstar> is*
05:49:40 <alexander__b> mcstar: figured it out by looking it up. thanks though.
05:49:51 <mcstar> sure
05:55:55 <Nawmad> i wonder if i can reduce riemann sum to a recursive divide and conquer function with edge condition when (b - a) is negligible
05:58:53 <LambdaDusk> So how could I get a Ptr from a ByteString?
05:59:06 * hackagebot computational-algebra 0.1.0.0 - Well-kinded computational algebra library, currently supporting Groebner basis.  http://hackage.haskell.org/package/computational-algebra-0.1.0.0 (HiromiIshii)
06:01:09 <Pods> Prelude> let inc n  = n + 1 ; Prelude> :t inc inc :: Num a => a -> a and Prelude> :t inc(inc 3) inc(inc 3) :: Num a => a, Can someone cite the conceptual difference between the last 2 ghci outputs here
06:02:42 <mcstar> :t let inc n  = n + 1 in (inc inc) 2
06:02:43 <lambdabot> (Num a, Num (a -> a)) => a
06:02:51 <mcstar> > let inc n  = n + 1 in (inc inc) 2
06:02:52 <lambdabot>   No instance for (GHC.Num.Num (a0 -> a0))
06:02:52 <lambdabot>    arising from a use of `e_112'
06:02:53 <lambdabot>  ...
06:02:54 <fryguybob> LambdaDusk: Perhaps you want  unsafeUseAsCString
06:02:58 <mcstar> it doesnt work
06:03:03 <mcstar> thats the conceptual difference
06:03:09 <LambdaDusk> fryguybob: Sounds unsafe
06:03:10 <mcstar> you are adding 1 to a function
06:03:18 <fryguybob> LambdaDusk: You did say Ptr
06:03:34 <LambdaDusk> fryguybob: OpenGL textures require Ptr
06:04:42 <Pods> mcstar : what i mean here is the conceptual difference of the usage of => operator in the type of a function.
06:05:02 <LambdaDusk> fryguybob: And when I have a CString, what then?
06:05:21 <mcstar> thats a type predicate, i wouldnt call it type operator, but whatever
06:05:27 <fryguybob> LambdaDusk: type CString = Ptr CChar
06:05:33 <LambdaDusk> oh ok
06:05:34 <LambdaDusk> sorry
06:05:50 <Pods> Num a => a this would conceptually mean that a function here of the type Num a evaluates to a while Num a => a -> a would mean that the function of type Numa will take input a and give output of type a
06:05:54 <Pods> am i right ??
06:05:54 <fryguybob> LambdaDusk: There is also  useAsCString  which copies the data.
06:06:12 <mcstar> Pods: thats wrong
06:06:27 <LambdaDusk> fryguybob: Since the texture binding is read-only, unsafe should be safe
06:06:34 <fryguybob> LambdaDusk: Right
06:06:35 <mcstar> Num a => a means whatever type 'a' that is a Num
06:07:03 <mcstar> so a function cant have a type 'Num a'
06:07:15 <Pods> mcstar: how do I map this definition in sync with the function inc i described above ??
06:07:31 <mcstar> ghci does that for you
06:07:44 <Pods> Does this description give any description about the type of the function , or just the types of its IO parameters ??
06:08:02 <mcstar> how did we get to IO?
06:09:53 <Pods> sorry i meant the input it takes and the output parameters , wrong term used there too :\
06:10:50 <Nawmad> any idea what's wrong with this attempt at making a recursive area function?
06:10:51 <mcstar> :t let inc n  = n + 1 in inc
06:10:51 <Nawmad> http://hastebin.com/sugikupodi.coffee
06:10:52 <lambdabot> Num a => a -> a
06:11:30 <mcstar> :t let inc n  = n + 1 in inc inc
06:11:31 <lambdabot> (Num a, Num (a -> a)) => a -> a
06:11:45 <mcstar> :t let inc n  = n + 1 in inc inc :: Num a => a -> a
06:11:47 <lambdabot>     Could not deduce (Num (a1 -> a1)) arising from a use of `inc'
06:11:47 <lambdabot>     from the context (Num a)
06:11:47 <lambdabot>       bound by the inferred type of it :: Num a => a -> a at Top level
06:12:35 <mcstar> idk how did you manage to get inc inc :: Num a => a -> a
06:13:14 <mcstar> Pods: ^
06:13:34 <mcstar> since that is clearly conflicts with the type of (inc inc)
06:13:36 <mcstar> -is
06:16:23 <Nawmad> program, y u no work :| http://hastebin.com/sugikupodi.coffee
06:16:44 <Nawmad> attempt at reinventing riemann sum through recursion
06:17:13 <LambdaDusk> and how can I turn a Vector into a Ptr?
06:17:48 <Pods> mcstar : Prelude> :t inc inc :: Num a => a -> a Prelude> inc (inc 3) 5 Prelude> :t inc(inc 3) inc(inc 3) :: Num a => a
06:18:01 <Pods> This is the copy paste of my prelude output
06:18:33 <asQuirreL> Nawmad, I don't think you can guarantee that it will terminate
06:18:48 <mcstar> Pods: but whats the output to :t inc inc :: Num a => a -> a ? it cant work
06:18:56 <Nawmad> why not :| it should keep dividing and conquering until there is a delta less than 0.1
06:19:25 <asQuirreL> Nawmad, is the second expression in the else-case's sum supposed to read area(b/2) b ?
06:19:36 <asQuirreL> * area (b/2) b
06:20:04 <Nawmad> yeah, b is exclusive
06:20:05 <Pods> the output to :t inc is inc :: Num a => a -> a
06:20:08 <Nawmad> :\
06:20:30 <asQuirreL> I see, well you can tell that that part will terminate
06:20:37 <asQuirreL> Nawmad, but what about if a > b?
06:20:39 <mcstar> Pods: the output to :t inc inc :: Num a => a -> a
06:20:42 <mcstar> not :t inc
06:20:47 <asQuirreL> then the left hand side will diverge
06:21:11 <Nawmad> perhaps but for testing purposes i avoid that for now
06:21:21 <Nawmad> but i can add a safe condition much like binary search
06:21:22 <Pods> The output to that certainly wont work
06:21:28 <Pods> ^mcstar
06:21:41 <mcstar> Pods: they what are you asking exactly? i told you it wont work
06:21:44 <mauke> mcstar: you're wasting your time
06:22:06 <Vermeille> Hello :)
06:22:41 <Pods> what was trying to ask you was what exactly does Num a => a -> a expression mean
06:23:14 <Pods> and i was trying to understand it with respect to the expression Num a => a
06:23:28 <Pods> I am sorry if i wasnt too clear.
06:23:50 <mcstar> Pods: first of all, dont try to understand something through faulty code, i think
06:24:07 * hackagebot computational-algebra 0.1.0.1 - Well-kinded computational algebra library, currently supporting Groebner basis.  http://hackage.haskell.org/package/computational-algebra-0.1.0.1 (HiromiIshii)
06:24:28 <mauke> mcstar: there is no faulty code
06:24:40 <Vermeille> I have a function which needs to generate random numbers for it's computation (it's a whitenoise function), is there a way not to polluate it's signature with IO monad ? All my function have prototype Float -> [Int16]
06:25:01 <mcstar> there is, he pasted things that would not typecheck if run
06:25:03 <mauke> Pods has pasted intermixed input/output with all newlines removed
06:25:19 <Nawmad> asQuirreL: my program should converge in any cases... where am I mistaken :|
06:25:43 <mauke> ':t inc' is one line, 'inc :: ...' is another
06:25:46 <Nawmad> asQuirreL: a == b means 0^2 = 0, a < b = converge, b < a = converge
06:26:00 <mauke> this isn't obvious from his line. you have to already know it to be able to read the mess
06:26:17 <asQuirreL> Nawmad, consider the case: a = 0.6, b = 0.9
06:26:17 <Pods> mauke: Agreed , messed up :\
06:26:38 <Nawmad> ahhh,
06:26:47 <asQuirreL> Nawmad, for the LHS expr you would get (a,b) = (0.6,0.45), (0.6,0.225)….
06:26:51 <Nawmad> 0.6 + (0.6 + 0.9)/2
06:26:51 <Pods> should have used something like pastebin instead .. :\
06:26:51 <asQuirreL> it'll miss a completely
06:27:13 <mcstar> mauke: this was his first line: "let inc n  = n + 1 ; Prelude> :t inc inc :: Num a => a -> a and Prelude> :t inc(inc 3) inc(inc 3) :: Num a => a", thus he definitely entered this into ghci
06:27:36 <mauke> mcstar: no
06:27:42 <Pods> yes , i sis
06:27:44 <Pods> *did
06:27:49 <mauke> Pods: no, you didn't
06:27:56 <Pods> these were ghci outputs
06:28:02 <mcstar> they cant be outputs
06:28:03 <mauke> mcstar: those are 5 lines
06:28:05 <asQuirreL> :t inc inc is not Num a => a -> a, is it?
06:28:06 <mcstar> they are ghci inputs
06:28:06 <lambdabot> parse error on input `=>'
06:28:06 <mauke> Pods: no
06:28:09 <mauke> mcstar: no
06:28:09 <Pods> But you are right in saying that these were multiple outputs
06:28:14 <mauke> mcstar: they are 3 inputs, 2 outputs
06:28:28 <Pods> mauke is right
06:28:36 <Pods> this is not a single output though
06:29:21 <mcstar> im totally confused now, how in the hell would on output start with ':t'
06:29:27 <mcstar> an*
06:29:37 <Pods> i will just post the actual set
06:29:48 <Pods> the one with proper input and output new lines
06:30:12 <Pods> I am really sorry for not having done this earlier, didnt realize it would be such a mess
06:30:14 <mcstar> mauke: ok i get it
06:30:45 <mcstar> i would have never thought of that, turning newlines into spaces..., thats evil
06:31:42 <Pods> http://pastebin.com/raw.php?i=c3HtHgjY
06:31:51 <mcstar> @where hpaste
06:31:52 <lambdabot> http://hpaste.org/
06:31:54 <Pods> *feeling nasty now :\
06:32:03 <mauke> The paste c3HtHgjY has been copied to http://hpaste.org/84605
06:32:41 <mauke> Pods: do you understand the type of 'id'?
06:32:42 <mcstar> Pods: because of your last line?
06:32:55 <Nawmad> asQuirreL: http://hastebin.com/figinajegi.coffee works ... although now i have to change it to actually make sense, but it doesn't infinitely regress, which is good
06:32:57 <mcstar> you still shouldnt write 'inc inc'
06:33:28 <Pods> yes, feeling nasty to have not pasted it somewhere with newlines..Will not repeat this error
06:33:42 <Pods> mauke: i am sorry 'id' ??
06:33:43 <mcstar> i mean, check the last line in your paste
06:33:51 <asQuirreL> Nawmad, lol :P
06:33:51 <mcstar> id is the identity function
06:33:56 <mcstar> :t id
06:33:57 <lambdabot> a -> a
06:34:07 <Pods> yes that gives me an error
06:34:16 <mcstar> Pods: do you know why?
06:34:42 <mcstar> do you understand why you had to use parens in :t inc (inc 3)
06:34:50 <Pods> because if i put inc inc 2 without the brackets then inc would take inc as input instead of inc 2
06:34:54 <asQuirreL> Pods, function application is both implicit and left associative
06:35:01 <mauke> Pods: right
06:35:18 <mcstar> asQuirreL: implicit?
06:35:29 <Pods> ^
06:35:34 <Pods> ^ +1
06:35:35 <mauke> there's no special operator for it, as in C
06:35:42 <asQuirreL> mcstar, yeah, that
06:35:52 <asQuirreL> like in mathematics, you would have implicit multiplication
06:36:14 <Pods> ok.
06:36:21 <mcstar> i never heard it described implicit, but ok
06:36:23 <arkeet> implicit?
06:36:35 <mauke> arkeet: yes
06:36:41 <mcstar> i would rather call it prefix function application
06:36:52 <mauke> f(x) is still prefix
06:36:52 <arkeet> one calls it "juxtaposition"
06:37:01 <Rembane> Juntaposition
06:37:02 <arkeet> what's more prefix about f(x) than f x?
06:37:02 <mauke> but you need the ( ) in there in C
06:37:17 <mauke> arkeet: no
06:37:32 <arkeet> no what?
06:38:50 <asQuirreL> arkeet, juxtapositioning is normally used in the context of putting two contrasting things next to each other
06:39:14 <arkeet> asQuirreL: it's also used in mathematics to say that "multiplication is denoted by juxtaposition"
06:39:29 <asQuirreL> arkeet, oh really? that's interesting, I've not seen that before
06:40:00 <arkeet> anyway, the important point is that it's left associative.
06:40:10 <asQuirreL> yes, lol
06:40:11 <arkeet> or rather, it parses that way.
06:40:36 <Pods> would a prefix function refer to a function on which currying is applied ??
06:40:50 <arkeet> ???
06:40:58 <arkeet> everything is prefix.
06:40:59 <mauke> what's a prefix function?
06:41:01 <arkeet> (except operators)
06:41:05 <arkeet> (which may be used infix)
06:41:17 <mauke> arkeet: ) isn't prefix
06:41:18 <asQuirreL> Pods, prefix function just means that the name of the function appears before its parameters
06:41:23 <arkeet> mauke: shut up
06:41:30 <mauke> no one said anything about "prefix function"
06:41:36 <mauke> English isn't left associative
06:41:48 <mauke> "prefix function application" parses as "prefix (function application)"
06:41:59 <asQuirreL> English is a natural language, let's not pain ourselves with applying parsing rules to it :P
06:42:22 <mauke> asQuirreL: if I don't apply parsing rules, how do I understand written sentences?
06:42:35 <hiptobecubic> mauke, citation needed, there i think
06:42:37 <asQuirreL> mauke, rather parsing hints, than parsing rules
06:42:51 <quchen> Are you guys seriously insulting each other over "f(x)" vs "f x"?
06:42:56 <quchen> Oh boy.
06:42:57 <mcstar> yes
06:42:59 <mauke> no
06:43:04 <mcstar> oh, then no
06:43:04 <asQuirreL> quchen, this isn't insulting...
06:43:17 <quchen> "Shut up" is just having a friendly conversation then
06:43:18 <mauke> I haven't seen anything I'd call an insult
06:43:19 <mcstar> quchen: what you do is insulting
06:43:20 <quchen> Standards seem to have changed
06:43:22 <mcstar> quchen: how dare you
06:43:26 <mauke> "shut up" was rude, though
06:43:36 <asQuirreL> have you guys been in ##c++, it's a blood bath in there every day, over code styles
06:43:52 <asQuirreL> it's a veritable garden of eden in here
06:43:57 <arkeet> and ") isn't prefix" is overly pedantic.
06:44:07 <mauke> arkeet: no, it's not
06:44:17 <mauke> "everything is prefix" is completely ridiculous
06:44:19 <Heffalump> ) isn't even well-formed, is it?
06:44:19 <mcstar> also, i still dont get why would you call f(x) prefix notation... lispers wont call it that i think
06:44:19 <arkeet> I'm not going to argue about whether it is or isn't.
06:44:36 <arkeet> mcstar: you wouldn't.
06:44:47 <mauke> most things in Haskell syntax aren't prefix
06:44:59 <mauke> 42  <- not prefix
06:45:02 <hiptobecubic> Why is anyone claiming that natural language has unambiguous parsing rules? This conversation pretty meaningless altogether.
06:45:02 <asQuirreL> Pods, wanna PM me your questions? I'll do my best to answer them
06:45:04 <quchen> 4 2 <- prefix
06:45:06 <mauke> A :: B  <- not prefix
06:45:20 <arkeet> this discussion is going nowhere.
06:45:29 <quchen> This is a discussion?
06:45:39 <asQuirreL> whats a discussion?
06:45:42 <arkeet> quchen: whatever it is.
06:45:50 <Heffalump> this is now a meta-discussion
06:45:54 * quchen pictures two children in a sandbox arguing over who built the more square tower
06:46:22 <Pods> asQuirreL: I haven't seen this kind of discussion over the other channels i have been to..sort of overwhelming ..:)
06:46:22 * arkeet takes a time-out.
06:46:27 <arkeet> ...to go to sleep.
06:46:36 <asQuirreL> Pods, lol :P
06:46:37 <Vermeille> Hey guys, no one for answering a trivial (I think) question about random numbers :D ?
06:46:45 <mauke> quchen: well, I'm kinda still waiting for Pods to react to my question
06:46:54 <asQuirreL> Vermeille, it requires polluting the program with state, so it's probably not trivial :P
06:47:05 <mcstar> Vermeille: sorry cant, but you can ask about pseudo random numbers
06:47:29 <Saizan> Vermeille: you can take a StdGen as argument
06:47:42 <mcstar> lets hear him out first, shall we?
06:47:45 <Saizan> Vermeille: or some other RandomGen
06:47:46 <Pods> mauke : sorry ,lost track of it amidst all this..Going back to where it is now
06:47:53 <Vermeille> It breaks my polymorphism
06:48:12 <asQuirreL> it should be possible to create a non monadic psuedo random number stream right?
06:48:18 <Vermeille> In fact, I have functions generating waves (sinW, squareW, triangleW and sawW)
06:48:27 <asQuirreL> iirc it's possible to implement one as an FSM
06:48:27 <Vermeille> they are all Float -> [Int16]
06:48:29 <mcstar> asQuirreL: you can pass around an infinite list ofc
06:49:14 <Saizan> Vermeille: you can't keep it with type Float -> [Int16] if you need a separate source of randomness
06:49:17 <Vermeille> And, in the future, it would be cool to have something like lowPassFilter :: ... -> (Float -> [Int16]) -> [Int16]
06:49:59 <mcstar> Vermeille: if you will need performance, then you might want to consider some kind of vector instead of your lists
06:50:48 <Saizan> Vermeille: you can write them with a type StdGen -> Float -> [Int16] and then partially apply them to a stdgen before you pass them to filters
06:51:13 <Vermeille> mcstar, I'm using lazyness, so that I can mapM_ on my list, to play infinite sounds
06:51:44 <Pods> mauke: understanding that id would mean the expression  Num a => a -> a; what i understand by it is that Num a type of function takes an input of the type a and returns an output of type a
06:51:49 <Vermeille> mcstar, I also use zipWith, to merge two sounds, etc
06:51:52 <mcstar> you can still do that with a vector, no need to trash the GC
06:52:02 <Pods> I am not sure how much of that would I be getting right though
06:52:04 <mauke> Pods: parse error
06:52:20 <Saizan> mcstar: vectors can be infinite?
06:52:25 <mauke> Pods: was that supposed to be one sentence?
06:52:33 <mcstar> no, but you can pass over them as many times as you want
06:52:43 <Pods> no the semi colon in between was supposed to be a delimiter ro the parser
06:52:47 <Pods> *to
06:52:51 <Vermeille> Saizan, hum, what about *all* the other waves generator which does not need random number generation ? isn't that dirty ?
06:53:00 <Pods> ^^ mauke
06:53:03 <mauke> Pods: then I don't understand what you're trying to say
06:53:30 <mcstar> Pods: nothing has type 'Num a'
06:53:34 <Saizan> Vermeille: no? it's better to be explicit about such things in types
06:53:37 <mcstar> if by Num you mean the Num typeclass
06:53:58 <Pods> mcstar : yes i am confused as to what would Num a refer to here
06:54:06 <Pods> in the :t inc output
06:54:09 <mauke> it's a class constraint
06:54:13 <mcstar> ^
06:54:19 <Vermeille> Oh wait
06:54:21 <mcstar> well, type constrait
06:54:22 <Vermeille> I'm stupid.
06:54:29 <mauke> that's why I asked you if you understand 'id :: a -> a' before
06:54:30 <Saizan> Pods: in the type "Num a => a -> a" thye role of "=>" is to separate the typeclass constraints on the left from the rest of the type on the right
06:54:55 <Saizan> Pods: the typeclass constraints are not arguments (at the source level syntax at least)
06:55:01 <geekosaur> Pods: read that as:  given that 'a' is a member of class 'Num', the type of this function is 'a -> a'
06:55:17 <mcstar> ^ thats what i said in the beginning
06:55:23 <Pods> ^ makes so much more sense now
06:55:34 <Pods> mcstar : maybe i didnt process it well then
06:56:05 <mcstar> 'Num a => a means whatever type 'a' that is a Num'
06:56:22 <Pods> mauke : yes i understand that this refers to a being passed as an input to the given function and getting the same type a as an output from that function
06:56:27 <mcstar> ofc, geekosaur's explanation is clearer
06:56:33 <Saizan> mcstar: that doesn't make much sense
06:56:45 <mcstar> why?
06:56:47 <Saizan> mcstar: you're leaving out the rest of the type there
06:57:04 <Pods> after i know what it is , mcstar's definition makes sense too
06:57:10 <mcstar> what rest of the type? there is no rest
06:57:54 <Saizan> i guess "whatever" is not a quantifier there
06:58:07 <mcstar> (i didnt explain what 'Num a => a -> a' means but what 'Num a = > a' means
06:58:24 <mauke> )
06:58:49 <Saizan> i'd say something like: whatever type 'a', provided it's a Num, you get an 'a'
06:58:54 <Vermeille> Well, wait
06:58:54 <Vermeille> Saizan, If I use a StdGen like you said, I see that getStdRandom is (StdGen -> (a, StdGen)) -> IO a, won't I polluate also my return type with IO monad ?
06:58:55 <Vermeille> I can't see how to achieve StdGen -> Float -> [Int16]           and not         StdGen -> Float -> [IO Int16]
06:58:55 <Vermeille> Okay, I see randomR
06:58:55 <Vermeille> I'm okay
06:58:55 <Vermeille> Thank you very much :)
07:01:57 <notdan> Is there anything like filterMap in the standart lib?
07:02:02 <notdan> I can't seem to find any
07:02:07 <arkeet> what is filterMap?
07:02:18 <notdan> like filter f . map g
07:02:27 <arkeet> no, because you can use filter f . map g
07:02:41 <Hafydd> Vermeille: what is the Float? A random seed?
07:02:47 <notdan> Well, there is concatMap
07:02:54 <Hafydd> Vermeille: er... nevermind, I was scrolled up.
07:02:54 <notdan> and you can use concat . map too
07:03:02 <mcstar> filter (f . g) ?
07:03:07 <arkeet> I don't know why concatMap exists, other than to define (>>=)
07:03:07 <typoclass> notdan: yeah, i've wondered about that too
07:03:08 <arkeet> mcstar: nope
07:03:19 <parcs> arkeet: for efficiency perhaps
07:03:25 <mauke> I don't know why map exists, other than to define fmap
07:03:26 <parcs> historically speaking
07:03:41 <Hafydd> Heh.
07:03:46 <parcs> now ghc can probably optimize 'concat . map f' to be as fast as a hand rolled concatMap
07:04:26 <arkeet> well, there are some RULES for it.
07:04:30 <mauke> :t mapMaybe
07:04:31 <lambdabot> (a -> Maybe b) -> [a] -> [b]
07:04:32 <arkeet> so it can do foldr/build fusion
07:04:37 <arkeet> @hoogle mapMaybe
07:04:38 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
07:04:38 <lambdabot> Data.IntMap mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
07:04:38 <lambdabot> Data.Map mapMaybe :: Ord k => (a -> Maybe b) -> Map k a -> Map k b
07:05:06 <arkeet> :t \f -> catMaybes . map f
07:05:07 <lambdabot> (a1 -> Maybe a) -> [a1] -> [a]
07:05:28 <Vermeille> Hafydd, the frequency
07:07:28 <mcstar> ooops
07:12:48 <Vermeille> I have a general question. Is it possible to "escape" the IO Monad ?
07:13:24 <mauke> no but yes but no
07:13:28 <Vermeille> I mean, if a functions does some IO, how not to propagate the IO to *all* callers ?
07:13:39 <mauke> by not executing the IO
07:13:51 <mauke> well, that doesn't exactly help
07:14:06 <mauke> functions don't "do" IO, they construct IO. IO is a data structure
07:14:31 <Vermeille> Actually, I understand the necessity for purity to propagate the IO monad
07:15:07 <Vermeille> But sometimes, you don't want to, like in my case of random numbers >_<
07:16:42 <mcstar> i thought you had an infinite list of random numbers already, that doesnt have IO, it has []
07:17:07 <Vermeille> Oh yesssss
07:17:08 <Vermeille> i see
07:17:18 <Vermeille> Well
07:17:28 <Vermeille> Haskell is a huge mindfuck
07:17:30 <Vermeille> <_<
07:18:30 <mcstar> i guess, you can view it like that, if it helps
07:18:44 <skp> hey
07:19:01 <skp> a hGetContents on a file handler returns empty string
07:19:04 <skp> any idea why?
07:19:08 <skp> the file is found
07:19:12 <mauke> because it's empty
07:19:12 <skp> and is not empty
07:19:16 <mauke> show me
07:19:29 <skp> withFile "test.txt" hGetContents
07:19:35 <mauke> yeah, that's wrong
07:19:35 <skp> ReadMode*
07:19:40 <skp> wait
07:19:43 <mauke> you're closing the file before hGetcontents can read it
07:19:43 <skp> I copy paste.
07:20:01 <skp> ah
07:20:06 <mauke> use readFile instead
07:20:06 <skp> so I have to disable buffering?
07:20:13 <mauke> this has nothing to do with buffering
07:20:28 <skp> so what is hGetContents for then?
07:20:41 <mauke> reading from filehandles
07:20:56 <geekosaur> like much of Haskell, the standard I/O things are lazy. if you don't actually do anything with the contents, it's not read
07:21:21 <geekosaur> if you close it and *then* try to use the data, you get nothing
07:21:25 <mauke> well, it's really just hGetContents
07:21:33 <typoclass> skp: the thing with hGetContents is that you have to think about laziness issues. (we have all fallen into that trap. i know i have)
07:21:44 <mcstar> i havent
07:21:55 <skp> I see
07:21:59 <skp> thank you
07:22:12 <mauke> some people read the docs for hGetContents and withFile first
07:22:15 * mcstar goes and tries IO in haskell to fall into the trap :)
07:22:45 <mcstar> i just used readFile, but that was unintentional
07:28:18 <cc> > reverse "a man a canal a canalpanama"
07:28:19 <lambdabot>   "amanaplanac a lanac a nam a"
07:28:33 <cc> > reverse "a man a plan a canalpanama"
07:28:34 <lambdabot>   "amanaplanac a nalp a nam a"
07:29:26 <Hermit> skp: readFile creates a handle, and once it reaches EOF it is automatically closed, so you don't really need to worry about closing it manually
07:30:10 <typoclass> mauke: i think the docs are not very clear. you basically can only find this if you're digging for it. in my opinion, comments like that are not justified
07:30:11 <Vermeille> https://bitbucket.org/Vermeille/code-your-zob/src/5ffd15dc33a52e286d9435239a01f736420f5b6e/sound/TotalWaveforms.hs?at=master Well, here is the code, the function I want to create is whiteW
07:30:55 <Hermit> skp: also, if you must absolutely load everything in memory for whatever reason, you could force it like  liftM2 seq length id . hGetContents
07:31:13 <Hermit> just so you know.
07:31:21 <skp> ok, thanks
07:31:39 <skp> I actually need the file to be read in order to pass it to OpenGL
07:31:47 <skp> (for shader stage source)
07:32:10 <Vermeille> But the problem is still there. if I want my list to be really random, I have to give a random seed to mkStdGen, so... I just reported the problem
07:32:16 <parcs> ski: you should use a bytestring for that
07:32:19 <parcs> skp: ^
07:33:56 <skp> a bytestring
07:33:58 <skp> why?
07:34:16 <skp> Data.ByteString?
07:34:25 <mauke> Hermit: or just 'evaluate (length s)'
07:34:32 <Vermeille> (I appreciate any commentary on my code, mayt it be good or bad)
07:34:53 <typoclass> skp: this page has a good description, in particular answer #1 http://stackoverflow.com/questions/296792/haskell-io-and-closing-files
07:35:00 <Hermit> @ty evaluate
07:35:01 <lambdabot>     Not in scope: `evaluate'
07:35:01 <lambdabot>     Perhaps you meant `evalState' (imported from Control.Monad.State)
07:35:16 <Hermit> mauke: was evaluate part of the expression?
07:35:41 <mauke> @hoogle evaluate
07:35:42 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
07:35:42 <lambdabot> Control.Exception evaluate :: a -> IO a
07:35:42 <lambdabot> Control.OldException evaluate :: a -> IO a
07:36:09 <parcs> skp: because opengl shaders are ascii only
07:36:18 <Hermit> mauke: how's that any different from using just return in an IO monad?
07:36:26 <mauke> Hermit: it evaluates its argument
07:36:31 <skp> yeah
07:36:35 <Hermit> in depth?
07:36:38 <skp> so I can’t pass it String
07:36:39 <mauke> no
07:36:44 <skp> which are unicode
07:40:45 <aristid> i think ByteString is pretty much the accepted type for ASCII
07:42:06 <madjestic> hey guys, is it possible to write something like that: foo = 2+2 where 2=3, so that foo returns 6?
07:42:40 <aristid> madjestic: what?
07:43:05 <arkeet> madjestic: foo = two + two where two = 3
07:43:25 <madjestic> arkeet: close to that, yes.
07:43:27 <mauke> foo = 2+2 where 2+2 = 6
07:43:32 <arkeet> haha
07:43:35 <arkeet> I guess that works.
07:43:40 <donri> or a custom Num instance? :p
07:43:42 <Hermit> mauke: reading the Control.Exception.evaluate doc, it evaluates to WHNF, but as far as I know, so does seq; I'm not seeing what's special about it
07:43:43 <aristid> madjestic: why do you want that?
07:43:48 <aCube> > let _ + _ = 6 in 2 + 1
07:43:49 <lambdabot>   6
07:44:10 <madjestic> aristid: that's an existential question
07:44:25 <aristid> madjestic: ah, so it's a joke question.
07:44:45 <typoclass> madjestic: if you want you can redefine the (+) function, as aCube showed. it's not special in haskell
07:45:48 <madjestic> thanks guys :)
07:46:31 <copamp> Do haskell functions fulfill the mathematical definition of a function?
07:47:03 <geekosaur> "sometimes"
07:47:35 <typoclass> copamp: normal functions in haskell don't have side-effects, if that's what you're asking for
07:47:49 <Botje> they're probably the closest thing to a mathematical function you'll find.
07:49:02 <Vermeille> HELL this is *mindfucking*
07:49:03 <aristid> Botje: nah
07:49:14 <aristid> Botje: i'd say an agda function is closer :)
07:49:28 <copamp> If you were a mathematical function which one would you be?
07:49:40 <Vermeille> 1/x
07:49:47 <aristid> exp
07:49:56 <Vermeille> I can grow to the infinity, and never be zeo :D
07:49:57 <typoclass> copamp: i would be the function that changes every argument into a kitty
07:50:10 <Vermeille> zero*
07:50:20 <aristid> typoclass: const kitty?
07:50:29 <typoclass> const meow
07:51:25 <mcstar> Vermeille: at one point, you have to deal with IO
07:51:47 <mcstar> make the whiteW in main
07:52:13 <Vermeille> mcstar, I don't mind, it's disguting, but I can use unsafePerformIO if needed
07:52:22 <Vermeille> What ?
07:52:39 <mcstar> ^ fast switching split personality
07:52:42 <Vermeille> nope nope, this main is just an "test" main
07:53:50 <Vermeille> Well, if I understand, the solution would be to encapsulate all my waves computations into a IO ?
07:53:54 <Vermeille> That's... dirty
07:54:21 <mcstar> no
07:54:45 <mcstar> anyway, im quite sick of the IO is dirty attitude
07:55:26 <Vermeille> Well, I have no problem with IO
07:56:04 <Vermeille> ... But here, I really need the return value of all my generators to be the same
07:56:57 <typoclass> Vermeille: you could get your (infinite) list of random numbers in main, then pass it as a pure value into your whiteW function, or whatever other place where you need it
07:57:03 <skp> hey
07:57:23 <skp> does the ByteString version of readFile appends the \0?
07:58:06 <arkeet> no
07:58:14 <skp> so I have to do something like
07:58:22 <Vermeille> typoclass, good idea !
07:58:32 <skp> (fromIntegral 0) `snoc` mybs
07:58:32 <skp> ?
07:58:37 <LinuxGirl> hello
07:58:38 <arkeet> what for?
07:58:40 <arkeet> skp
07:58:43 <skp> to add the \0
07:58:49 <arkeet> why do you want to add it?
07:59:09 <skp> because I want to pass that ByteString to a C function
07:59:18 <skp> and useAsCString seems not to do the job
07:59:38 <typoclass> LinuxGirl: hi
07:59:50 <skp> or I don’t understand what’s happening
07:59:53 <arkeet> skp: useAsCString already adds a '\0'
08:00:03 <skp> so I don’t get it
08:00:05 <LinuxGirl> lol
08:00:08 <LinuxGirl> http://www.youtube.com/watch?v=NGPRHRfmqxE
08:00:25 <mcstar> great... here goes my fantasy
08:01:07 <typoclass> skp: i think adding \0 is usually the job of the ffi, the library that you're using to talk to opengl, and so on. normally you don't have to do this yourself with (++) or snoc or whatever
08:01:16 <skp> ok
08:01:22 <alexander__b> what does the colon mean in "map f (x:xs) = f x : map f xs"?
08:01:27 <skp> so there’s a problem elsewhere
08:01:27 <mauke> arkeet: since when?
08:01:32 <skp> I print the ByteString
08:01:33 <arkeet> mauke: since I looked at the source.
08:01:33 <skp> it’s ok
08:01:35 <skp> I pass it
08:01:43 <skp> and the GLSL compiler complains:
08:01:46 <skp> 0:1(1): error: syntax error, unexpected $end
08:01:56 <mauke> arkeet: oh, you're right, of course
08:02:08 <donri> alexander__b: list cons
08:02:40 <mcstar> that wont help him im afraid
08:02:42 <donri> data [a] = [] | a : [a]
08:02:45 <typoclass> skp: if you use the glsl compiler directly on the file (with no haskell), do you get a similar error?
08:02:48 <alexander__b> donri: oh of course. I'm just so used to the author doing cons like a:b instead of a : b. it's pretty inconsistent in terms of that. =/
08:03:02 <skp> no idea
08:03:05 <skp> hm
08:03:06 <mcstar> i was wrong, it did help
08:03:10 <skp> I’m gonna test something else
08:03:15 <pthom> Hello, I am trying to learn haskell and I have (yet another :-) question about indentation
08:03:22 <hpaste> pthom pasted “indentationQuestion” at http://hpaste.org/84608
08:03:23 <donri> alexander__b: it seems to be common to use whitespace in expressions and no whitespace in patterns
08:03:32 <skp> zsh: segmentation fault (core dumped)
08:03:34 <skp> ahah
08:03:35 <mcstar> pthom: first, pls, match you parentheses ")
08:03:37 <alexander__b> donri: oh. then maybe it *is* consistent, heh. thanks.
08:03:43 <skp> I think there’s a problem here
08:03:44 <pthom> :-)
08:03:47 <mcstar> thats a smiley :)
08:03:48 <typoclass> alexander__b: the right side of course groups as "(f x) : (map f xs)". just to be clear :-)
08:03:54 <skp> I want a Ptr (Ptr Char)
08:03:56 <skp> so
08:04:12 <pthom> If I uncomment the last function in my paste (nudge function), then it won't compile
08:04:13 <typoclass> skp: wait, you mean the compiler crashes?
08:04:29 <skp> useAsCString mybs gives me a CString, which is Ptr Char if we castPtr it
08:04:30 <skp> then
08:04:32 <alexander__b> typoclass: got that. thanks. :-)
08:04:37 <mauke> pthom: )
08:04:37 <skp> if I castPtr it twice
08:04:43 <skp> can I get a Ptr Ptr ?
08:04:53 <Saizan> pthom: you lack a ) at the end there
08:04:57 <skp> or do I have to use with
08:05:00 <mauke> skp: you don't need to castPtr
08:05:08 <skp> to create another Ptr
08:05:12 <mauke> CString is Ptr Char
08:05:16 <mcstar> (Point (x2+a)
08:05:25 <mauke> casting won't create another level of pointering
08:05:26 <donri> well, Ptr CChar
08:05:30 <mauke> er
08:05:35 <mauke> yeah, CChar
08:05:35 <pthom> ok, thanks a lot Saizan
08:05:36 <skp> ok
08:05:38 <skp> well wait
08:06:30 <skp> https://github.com/skypers/ark-gl/blob/master/Graphics/Rendering/Ark/GL/Shader/Stage.hs#L73
08:06:42 <skp> here’s how I push the ByteString to OpenGL shader compiler
08:07:31 <mauke> don't castPtr
08:07:45 <mauke> what's the type of glShaderSource?
08:08:00 <skp> it expects a Ptr (Ptr GLuchar)
08:08:29 <geekosaur> castPtr is the wrong way to get that
08:08:34 <geekosaur> that would indeed dump core
08:08:50 <skp> well
08:09:02 <skp> I actually get that with both the useAsCString (first Ptr) and the with
08:09:26 <typoclass> skp: just to be sure, have you read a little about the ffi? http://www.haskell.org/haskellwiki/FFI_Introduction normally, it's quite straightforward to call c functions from haskell. there is hsc2hs and other tools helping with it. doing things like castPtr yourself sounds suspicious :-)
08:09:31 <geekosaur> you're saying "I assert that this Ptr CChar is really Ptr (Ptr GLuchar) -- but that means you're sending a single-indirect pointer to something wanting a double indirect
08:09:36 <bergey> skp: I've been doing this with the OpenGL library, instead of OpenGLRaw, and it avoids all this Ptr gymnastics.  Is that an option for you?
08:10:06 <skp> no
08:10:07 <skp> it’s not
08:10:07 <geekosaur> naturally it SEGVs trying tofollow the character data as if it were a pointer
08:10:17 <typoclass> bergey: that's an extremely useful suggestion
08:10:23 <skp> ark-gl is a binding just like OpenGL is
08:10:31 <skp> and geekosaur
08:10:42 <mauke> this nb thing looks wrong
08:10:44 <skp> I _don’t_ pass it a single-indirect pointer
08:11:10 <skp> mauke: glShaderSource takes an array of int that gives the number of lines we pass
08:11:16 <skp> so with 1, because one line
08:11:42 <mauke> skp: that's not the number of lines, that's an array of the line lengths
08:11:59 <skp> fuck you’re right
08:12:11 <skp> it’s my first 1 which represents the number of lines
08:12:12 <skp> ahah
08:12:22 <skp> now, I understand the error
08:12:28 <skp> thank you
08:12:30 <skp> gonna fix that
08:12:40 <mauke> you can just pass nullPtr
08:13:27 <typoclass> skp: just for inspiration, here is someone who uses glShaderSource http://hackage.haskell.org/packages/archive/OpenGL/2.2.1.1/doc/html/src/Graphics-Rendering-OpenGL-GL-Shaders.html
08:13:35 <parcs> only if the shaders are null terminated
08:13:48 <typoclass> (i just googled this; i don't know if the code is up to date)
08:13:49 <Vermeille> Fuck it. I'm damn too stupid for Haskell. *rage rage*
08:13:49 <bergey> skp: OK.  In that case, isn't the code for setShaderSource in the OpenGL binding pretty similar to your source function?
08:14:02 <bergey> http://hackage.haskell.org/packages/archive/OpenGL/2.8.0.0/doc/html/src/Graphics-Rendering-OpenGL-GL-Shaders-Shaders.html#shaderSource
08:14:26 <skp> it looks like to mine, yes
08:14:41 <skp> 0:1(10): error: GLSL 1.50 is not supported. Supported versions are: 1.00 ES, 1.10, 1.20, and 1.30
08:14:44 <skp> ok
08:14:44 <skp> it works!
08:14:46 <skp> thank you
08:20:04 <khismetix> I am starting into FP --- a quick question -- are local variables a no-no in strict FP ?
08:22:03 <latro`a> khismetix, not at all, they lessen as you begin to use point-free style more
08:22:17 <mcstar> Vermeille: this code deals with random numbers, maybe it will help you http://sprunge.us/Tdeh?haskell
08:22:21 <latro`a> but they're typically present in the smaller functions that you compose together in pointfree style anyways
08:22:36 <mcstar> it uses IO, and i dont think it is particularly ugly
08:23:06 <mcstar> ignore the last lines, idk where those come from...
08:23:08 <orzo> Is there a way to compare expressions without evaluating htem?  I just want to know if they are represented as the same underlying thunk.
08:23:28 <Hafydd> Why?
08:23:29 <Vermeille> mcstar, the problem is not being ugly or not
08:23:31 <typoclass> khismetix: hello. in haskell, there are arguments to functions, and those are set only once when the function is called and don't change afterwards. there is 'let' and 'where', but those work similarly
08:24:00 <Vermeille> I just need my function to have a non-IO return type, to be like all others generators
08:24:14 <orzo> Hafydd: the reason is that i have a container that can be made more efficient with an equivalence and i want a decent default equivalence and I don't want ot require Eq
08:24:54 <orzo> It works fine with \a b -> False, but it would be pretty cool to be able to do better
08:25:36 <mcstar> Vermeille: in this code https://github.com/liquid-phynix/asteroids/blob/master/Game.hs you can see in initGame, that i give back a list of am inifnite number of asteroids, (which appear at random positions)
08:25:40 <Hafydd> > let x = 1 in (\ a b -> False) x x
08:25:42 <lambdabot>   False
08:26:55 <Philonous> khismetix:  Variables in haskell aren't places that you can write to / read from but names that get values bound to them.
08:28:20 <Vermeille> thx mcstar ! I'll read carefully your code, I have a lot to learn with IOs, and impure calculations. Writing a compiler is a task that won't face those issues, so I never studied it :)
08:30:37 <aCube> Is there a good introduction on the Haskell FFI somewhere?
08:30:49 <Philonous> Khisanth:  Generally, rather than updating a variable, you bind the value to a new name. If you want to do a loop, you recurse with the new value (or use one of the premade combinators)
08:32:27 <pthom> Hello, I have one question about Text.Printf.printf
08:32:29 <Philonous> Khisanth:  Sorry, didn't mean you ;)
08:32:31 <hpaste> pthom pasted “QuestionAboutPrintf” at http://hpaste.org/84609
08:32:40 <orzo> Requiring Eq would ruin my Monad
08:33:09 <donri> aCube: http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
08:33:17 <pthom> In my paste, the printf works, but ilt will not if I comment out the last print " "
08:33:28 <pthom> Any idea why?
08:33:56 <Philonous> pthom:  Is stdout line buffered? Try adding \n to the end of the string
08:34:08 <Vermeille> mcstar <3 THANK YOU ! I managed to do it \o/
08:34:11 <arkeet> pthom: what about it doesn't work?
08:34:25 <mcstar> great
08:34:33 <aCube> donri: thanks
08:34:49 <pthom> It says Ambiguous type variable `t0' in the constraint:       (PrintfType t0) arising from a use of `printf'
08:34:59 <arkeet> that was my guess.
08:35:10 <arkeet> (always provide the error message when something doesn't work)
08:35:15 <pthom> ok
08:35:23 <geekosaur> why are you using both $ and parentheses? (unrelated)
08:35:28 <Philonous> pthom:  You need to add a type declaration to test. So test :: IO ()
08:35:33 <arkeet> ^
08:35:55 <Philonous> pthom:  That's because printf uses some advanced type magic to accept a variable number of parameters
08:36:00 <pthom> Woops, this one was tricky. Thanks !
08:37:11 <Hafydd> Vermeille: writing a _good_ compiler should require an understanding of every aspect of programming in the language being compiled.
08:37:37 <Philonous> pthom:  Btw. you don't have to give the qualified name. Just printf should work.
08:38:06 <pthom> I know.
08:38:12 <Philonous> ok
08:40:10 <Vermeille> Hafydd, I agree, but the language being compiled isn't Haskell :)
08:40:24 <Vermeille> I write a compiler in Haskell for an imperative language
08:56:02 <alexander__b> where p x = x `mod` 3829 == 0
08:56:05 <alexander__b> ... wat?
08:57:27 <typoclass> alexander__b: this groups as p x = ((x `mod` 3829) == 0)". it's a function that will tell you if a number is divisible by 3829. (whatever that is good for)
08:58:06 <alexander__b> typoclass: I'm not sure I fully understand what it means that "p x ="
08:58:26 <Hermit> alexander__b: where is a keyword for bindings....
08:58:35 <orzo> Hafydd: I think I found the answer to my weak equivalence question, System.Mem.StableName
08:58:40 <Vermeille> p is a function which takes an arg x
08:58:45 <monochrom> do you know that we can define functions by "f x = expression"?
08:58:47 <alexander__b> typoclass: I mean I get "where foo = "bar" -- but
08:58:50 <alexander__b> Vermeille: oh
08:59:06 <typoclass> alexander__b: in a 'where' block you can define names, much like a 'let'. both "x = 123" and "f x = ...", "f x y = ..." and so on are possible
09:00:31 * Hermit smacks alexander__b with a haskell syntax overview for beginners
09:00:57 <typoclass> Hermit: please provide a link, instead of smacking people
09:01:05 <Hermit> right
09:01:10 <Hermit> @where lyah
09:01:11 <lambdabot> http://www.learnyouahaskell.com/
09:01:14 <Hermit> alexander__b: ^
09:01:14 <alexander__b> Hermit: sorry if it's not allowed to ask elementary questions in here. I'll use the Web instead for now on.
09:01:45 <Hannibal_Smith> alexander__b, ahahaha no so fast, you can ask here all the questions you like
09:01:53 <alexander__b> Hermit: that's the book I'm reading. I was just having trouble grasping some things. if it's not allowed to ask really basic haskell questions here, I guess I'll look elsewhere.
09:02:15 <typoclass> alexander__b: no, don't worry, it's fine
09:02:24 <Hermit> yeah, I was just playing around
09:02:33 <Hannibal_Smith> I'm more newbie than you, and here people always reply to my questions
09:02:45 <jmcarthur> alexander__b: please ask questions here
09:02:56 <alexander__b> I'm used to int a = 1, b = 2 -- so "where p x = mod x 3829 == 0" is utterly confusing to me.
09:03:28 <Hermit> alexander__b: do this with a and b, where a = 1; b = 2
09:03:30 <alexander__b> because my head wants to read it like "okay, you set... p to... wait what".
09:03:39 <jmcarthur> alexander__b: haskell syntax is pretty different from your usual C-derived language. once you get over that, you can get to the really fun stuff :)
09:03:53 <alexander__b> jmcarthur: I'm having fun already. :-)
09:04:03 <jmcarthur> glad to hear it!
09:04:22 <typoclass> alexander__b: don't worry, you'll get used to that pretty quickly
09:04:25 <alexander__b> for the record, I'm looking at this function
09:04:27 <alexander__b>     largestDivisible :: (Integral a) => a
09:04:29 <alexander__b>     largestDivisible = head (filter p [100000,99999..])
09:04:31 <alexander__b>         where p x = x `mod` 3829 == 0
09:04:41 <alexander__b> so, I get what's going on. I'm just mostly confused by the x.
09:05:02 <alexander__b> if it were just p = mod a 3829 == 0, or something, I would be fine.
09:05:10 <Hermit> alexander__b: that just returns all numbers divisible by 3829, starting at 100000 down to 0
09:05:17 <alexander__b> Hermit: I get that
09:05:26 <Hermit> err, no, just the first
09:05:26 <typoclass> @type filter
09:05:28 <lambdabot> (a -> Bool) -> [a] -> [a]
09:05:41 <alexander__b> Hermit: uhm yes. the first/biggest number.
09:05:59 <skp> I’d like starting a talk about haskell programs’ size
09:06:20 <skp> I wonder if we can output small programs
09:06:21 <skp> in haskell
09:06:26 <typoclass> alexander__b: this has to do with how the filter function is defined. the signature ^^ indicates it takes a function (a -> Bool) as its first argument, which is what p is. the second argument is a list [a]
09:06:29 <alexander__b> typoclass: yes filter accepts a procedure that returns a bool, and a list, and then it returns a filtered list of the same type (see, I know how to use :t now :-P)
09:06:48 <donri> skp: dynamic linking :p
09:06:49 <typoclass> alexander__b: yes, exactly :-)
09:07:04 <alexander__b> so p is the function that does mod x 3829, right?
09:07:07 <Hermit> alexander__b: it works like this: [100000,99999..] means create a list from 100000, the next step being 99999, and continue. Now create a list of just the divisible numbers, then take the first one. Since all list creation is lazy, just enough work is done to get you your result
09:07:13 <skp> it requires the targeted machine to have the runtime
09:07:17 <alexander__b> Hermit: I know this
09:07:28 <Hermit> good
09:07:29 <alexander__b> typoclass: so my confusion is over the inclusion of 'x'.
09:07:41 <alexander__b> typoclass: it's not clear to my C-brain how x is set.
09:07:55 <Hermit> alexander__b: it's the parameter of the p function
09:08:01 <cmccann> shachaf: the only things I know about type inequality involve doing things in the horrible way
09:08:14 <cmccann> shachaf: you probably don't want to ask me to help make things less horrible
09:08:22 <Hermit> alexander__b: the function p is defined in the where block, and it takes a parameter, namely x
09:08:42 <typoclass> alexander__b: the filter function will call p and set the x to one value of the list. it will do this repeatedly one by one for each value in the list
09:08:55 <alexander__b> Hermit: right so p [100000..99999] -- the list would be x in the where?
09:09:02 <alexander__b> typoclass: oh
09:09:06 <alexander__b> typoclass: yes. right. thanks.
09:09:11 <typoclass> ;-)
09:09:43 <Hermit> alexander__b: no, x would be a single number, also, [100000..99999] != [100000,99999..]
09:09:56 <alexander__b> Hermit: sorry typo
09:12:11 <Hermit> alexander__b: this is the overview I was meaning to smack you with before: http://cheatsheet.codeslower.com/CheatSheet.pdf
09:12:24 * Hermit was trying to find the link
09:12:29 <ion> Also, [100000,99999..] ≠ [100000,99999..0]
09:14:14 <alexander__b> Hermit: looks more than a little useful. thanks! I'll put it in a tab next to my ghci/learnyouahaskell tab.
09:14:59 <Hermit> alexander__b: the where syntax is covered in the second page
09:15:02 <dmwit> shachaf: Well, if eir makes the same suggestion as me, then I feel pretty vindicated. =P
09:15:30 <dmwit> shachaf: (re: we could add a term that dispatches inconsistent contexts)
09:16:10 <typoclass> Hermit: thanks, that's a useful pdf
09:16:25 <Hermit> yeah, it's pretty neat
09:16:41 <Hermit> I just don't have all my bookmarks synced across boxes
09:16:42 <Hermit> so...
09:20:50 <mcstar> nice cheetsheet
09:23:11 <jmcarthur> it's a bit large to be a cheatsheet, no?
09:23:20 <jmcarthur> more of a quick reference booklet :P
09:23:42 <jmcarthur> (not that that makes it much less useful if you need it)
09:23:45 <dmwit> cheatsheets
09:24:51 <mcstar> jmcarthur: we should make a multi player lights out game for the next contest
09:25:29 <jmcarthur> hmm
09:26:40 <mcstar> that enthusiasm, is a killer
09:27:18 <jmcarthur> i'm just trying to think of a way to make it work for multiplayer
09:27:47 <jmcarthur> roshan: i don't happen to know you, do i?
09:28:27 <mcstar> jmcarthur: im was thinking of multiple colors of light, and ofc there needs to be some simple but nontrivial rule
09:28:28 <jmcarthur> fine then
09:28:36 <mcstar> but im sure we can work it out :)
09:28:44 <jmcarthur> ah, multiple colors sounds like a neat twist
09:30:18 <dmwit> Is Lights Out the game where you try to solve a linear equation over the booleans by hand?
09:30:21 <dmwit> What a blast.
09:31:01 <jmcarthur> haha
09:31:31 <jmcarthur> it would be more fun in an adversarial context, i think
09:34:49 <mcstar> dmwit: you wouldnt solve this one by hand, but by writing an 'ai'
09:35:04 <typoclass> dmwit: use category theory
09:35:06 <mcstar> (by today's standards that is hardly an ai, but we have to call it that)
09:35:32 <dmwit> Ah, yes, Gaussian elimination, the most clever of all AIs. ;-)
09:35:53 <dmwit> I kid, I kid.
09:36:00 <mcstar> dmwit: we would add twists, that would require to solve some kind of pruned search
09:36:02 <dmwit> I had loads of fun with it the first time I saw it.
09:36:08 <dmwit> mcstar: sure
09:36:24 <nexx> What is the syntax to hide 2 type variables with existential types?
09:36:47 <dmwit> data Exists2 = forall a b. Exists2 a b -- ?
09:36:56 <jmcarthur> mcstar: should we take this to #aichallenge?
09:36:57 <dmwit> or
09:37:06 <dmwit> data Exists2 where Exists2 :: a -> b -> Exists2
09:37:07 <mcstar> jmcarthur: if you want to continue, sure
09:37:14 <jmcarthur> let's do so
09:41:10 <nexx> thanks dmwit. Thought it didn't worked, when I tried it first becaus of a different error.
09:49:18 * hackagebot libsystemd-daemon 0.1.0.1 - Haskell bindings for libsystemd-daemon.  http://hackage.haskell.org/package/libsystemd-daemon-0.1.0.1 (CedricStaub)
09:52:18 <Vermeille> How fromIntegral guesses the type in wich to cast ?
09:52:29 <jbu> hi all, inside of a do-block, I wish to do something like if x > 5 -> ... else if x < -5 -> ..., but apparently with case I can't do that (because I'm matching on the variable) and in haskell there's no if-else, so what's the idiom to do this?
09:53:51 <Hannibal_Smith> in haskell there's no if-else <-Uhm?
09:54:07 <Hannibal_Smith> if x then ... else ...
09:54:29 <jbu> :r
09:54:47 <jbu> Hannibal_Smith: oops, I meant there's no "else if"
09:55:01 <geekosaur> have you tried it?
09:55:47 <jbu> geekosaur: I thought I did, and then I googled it
09:56:14 <geekosaur> it's considered poor design, but it works. case + guards is often preferable
09:57:08 <applicative> Vermeille, it doesn't, the result of fromIntegral 12 is a member of any Num type
09:57:35 <Vermeille> Hum... okay. That's annoying
09:57:40 <Vermeille> well, or not
09:57:49 <geekosaur> Vermeille, the result type is typically fixed by type inference based on how the result is used. the monomorphism restriction and defaulting may come into play depending on how it's used
09:58:02 <applicative> Vermeille: the function you 'call' the result with will specialize it further, or else you can annotate it
09:58:16 <jbu> geekosaur: I just tried the case, and it didn't work...is it supposed to?
09:58:24 <geekosaur> did you use guards?
09:58:27 <applicative> > fromIntegral (17 :: Int) + (0.2:: Float)
09:58:28 <lambdabot>   17.2
09:58:36 <jbu> geekosaur: I tried guards, but syntax wasn't right, so I guess not
09:58:42 <geekosaur> case by itself does pattern matching only. guards can be used to add conditions
09:59:00 <geekosaur> case () of () | x < 5 -> ... | x > 10 -> ... | otherwise -> ...
09:59:18 * hackagebot computational-algebra 0.1.1.0 - Well-kinded computational algebra library, currently supporting Groebner basis.  http://hackage.haskell.org/package/computational-algebra-0.1.1.0 (HiromiIshii)
09:59:19 <geekosaur> (this is roughly what if-then-else is convderted into internally
09:59:20 <Vermeille> thank you :)
10:00:34 <Vermeille> I'm dealing with Int16, and do some computation that can overflow, I want to cast operand to Int, do my computations, "scale" my result then cast it to Int16
10:00:50 <Vermeille> but fromIntegral cannot infer that I want to do this to avoid overflow
10:00:55 <rmunroe> hmm; I wonder if you can make irssi hilight everywhere *except* a particular channel.
10:01:16 <Vermeille> and it does... nothing, and converts me an Int16 to an Int16
10:01:16 <Vermeille> :D
10:01:55 <geekosaur> in that case you can use a type constraint: let a = fromIntegral my16 :: Int
10:04:19 <Vermeille> I tried :D And got parse Error :D
10:05:11 <monochrom> "I am 16, going on 17"
10:05:23 <geekosaur> @paste your code
10:05:23 <lambdabot> Haskell pastebin: http://hpaste.org/
10:05:29 <beaky> hello
10:05:45 <geekosaur> also note what I typed as an example was not complete in and of itself
10:06:05 <Vermeille> obiously.
10:06:50 <geekosaur> since I don't know what exactly you are doing I cannot provide a full example...
10:07:39 <geekosaur> also I suggest that your problems with syntax suggest you haven't sopent a lot of time with LYAH
10:07:42 <geekosaur> @where LYAH
10:07:43 <lambdabot> http://www.learnyouahaskell.com/
10:08:35 <beaky> in what ways can static typing make a language more expressive/powerful compared to dynamic typing?
10:08:41 <hpaste> Verm' pasted “parse error” at http://hpaste.org/84611
10:08:51 <Vermeille> here, geekosaur
10:09:14 <Vermeille> parse error on ::
10:09:19 <geekosaur> your parse error is because you don;t have your parentheses matched up properly
10:09:31 <geekosaur> hm, sorry, no
10:09:55 <geekosaur> the :: prolem is that :: tries to go as far to the left as possible; you should parenthesize around it
10:10:05 <Vermeille> Ohhhhhhhhh
10:10:12 <Vermeille> Thank you !
10:10:15 <geekosaur> (fromIntegral x :: Int) instead of (fromIntegral x) :: Inty
10:11:06 <kdridi> Do i need to process the whole XML file when unserialize with HXT ?
10:11:09 <Vermeille> Yeah, it works
10:11:13 <Vermeille> thanks :)
10:11:18 <Vermeille> Stupid question.
10:14:13 <k00mi> beaky: the purpose of types is to restrict what can be expressed
10:15:08 <geekosaur> beaky: a well designed type can turn a logic error into a type error that can be checked at compile time instead of a runtime exception or a nonsense result value
10:15:11 <beaky> ah
10:15:53 <beaky> even with static typing haskell is extremely expressive
10:16:41 <beaky> coming from C++, i thought static typing was just a legacy of the old days where compilers needed to be told what to do
10:16:45 <geekosaur> sure, and if you make everything polymorphic that expressiveness can shoot you in the foot pretty expressively :)
10:16:52 <beaky> haha
10:18:04 <monochrom> dynamic typing is less expressive than static typing at the type level. static type is less expressive than dynamic typing at the value level.
10:18:29 <beaky> ah
10:18:59 <beaky> I am a firm believer of values
10:21:19 * Kinnison notes that oftentimes when you apply a type signature to something in haskell, it's more to make sure *you* don't mess up, than to help the compiler out.
10:21:33 <Hannibal_Smith> Do anyone here use a document based database?
10:21:45 <beaky> how come haskell does not support modern OOP features like encapsulation, information hiding and access control, modularity, inheritance, polymorphism, interfaces, etc?
10:22:02 <beaky> that languages like java or C++ thrive on
10:22:17 <beaky> (or C#)
10:22:30 <Hannibal_Smith> beaky, modularity...functional programming are more modular that oop programming
10:22:31 <sproingie> haskell supports polymorphism to a crazy degree
10:22:43 <sproingie> even *literals* are polymorphic in haskell
10:23:01 <Hannibal_Smith> For interface and polymorphic in Haskell *we* use typeclass
10:23:21 <Hannibal_Smith> Information hiding it's possibile ad module level
10:23:21 <beaky> I thought typeclasses were a last-resort thing
10:23:26 <sproingie> encapsulation you from modules by not exporting names
10:23:33 <tac> beaky: Functional programming has all those things... just in different forms
10:23:36 <copamp> Hannibal_Smith: is typeclass and interface interchangeable?
10:23:37 <beaky> ah
10:23:38 <sproingie> beaky: hardly, they're the first thing to reach for in a lot of cases
10:23:39 <simpson> beaky: You seem to ask this question every few days.
10:23:50 <tac> Encapsulation isn't as important when your data structures are immutable.
10:23:51 <simpson> beaky: Remember, objects are about *behavior and state*, together.
10:23:59 <tac> What's more important is module-level encapsulation.
10:24:03 <sproingie> ah, are we just being trolled then?  oh well, saturdays are usually slow anyway
10:24:06 <Hannibal_Smith> copamp, I tend to view interface and typeclass the same thing
10:24:24 <tac> beaky: polymorphism is possible in a functional language, but it presents as many problems as it does solutions
10:24:24 <Hannibal_Smith> I think typeclass is more powerful than interfaces
10:24:25 <sproingie> simpson: i dunno about state, but when you don't use state, it's typically identity that matters
10:24:46 <tac> (and polymorphism is something FP does 100x better than OOP)
10:24:51 <tac> (because FP does it right)
10:25:01 <Hannibal_Smith> I'm an absolute newbie in Haskell
10:25:04 <simpson> sproingie: I'm talking about languages where everything is an object. Smalltalk and kids.
10:25:28 <sproingie> simpson: sure, where even numbers are objects -- but you don't tend to mutate a number's state
10:25:35 <Hannibal_Smith> And I think that there are some advanced topic that cover some other topic that you asked
10:25:36 <monochrom> beaky: consider https://plus.google.com/u/0/111539170343022224273/posts/YhV2w8t5JGQ
10:25:37 <tac> copamp: typeclasses are more powerful than interfaces.... but to explain why is a bit tricky
10:25:39 <sproingie> or really care about its identity, but i suppose that's a special case
10:25:47 <beaky> I tried a bit of ruby, but I still didn't grasp the OO paradigm :( maybe if I played more in squeak
10:25:59 <Hannibal_Smith> I don't think that objects are a good thing
10:26:17 <Hannibal_Smith> They are too "closed"
10:26:20 <sproingie> i think objects have their uses
10:26:31 <tac> everything in Haskell is an object -- they just don't have mutable state like we usually think of an object having
10:26:34 <Hannibal_Smith> In Haskell I can add any data to my typeclass
10:26:37 <tac> State is the real enemy
10:26:45 <Hannibal_Smith> In Java I cannot modify an object
10:27:00 <sproingie> meh, state has its use.  local to a computation i should hope
10:27:28 <tac> yes, state is necessary.... but it's hard to reason about
10:27:41 <tac> You want to localize state as much as possible if you want a nice, maintainable program
10:27:46 <tac> That's what encapsulation in OOP is all about
10:28:00 <tac> In Haskell, instead we use monads (usually) to encapsulate state
10:28:08 <eikke> state is OK for global immutable or local mutable/immutable, not for global mutable
10:28:22 <simpson> sproingie: Objects don't have to be mutable to have behavior and state! :3
10:28:27 <tac> We generally use state to mean something mutable, eikke :)
10:28:33 <sproingie> simpson: that's what i've been arguing too :)
10:29:07 <tac> If you have a database Connection object.... the Connection object itself might be immutable, but its methods affect the state of the database
10:29:16 <sproingie> haskell lets you have state just fine, you just have to account for it wherever you use it
10:29:24 <sproingie> haskell keeps you honest.  forces it, really.
10:29:25 <tac> That means anyone who has a handle to the Connection object can futz with your data!
10:29:40 <stelleg> does anyone here know of a compiler for a lazy language that doesnt do graph reduction on supercombinators?
10:29:52 <tac> If you are getting junk data or deleted records, you have to check *every* place that has access to your Connection object
10:31:36 <Vermeille> Kind mismatch, The first argument of `Monad' should have kind `* -> *' but `Player' has kind `*'
10:32:00 <Vermeille> wtf
10:32:02 <tac> Vermeille: is that a question?
10:32:03 <tac> :)
10:32:11 <Vermeille> Haha :D
10:32:16 <Vermeille> My question is "wtf ?"
10:32:32 <tac> the Monad typeclass requires that your thingy be a type constructor
10:32:38 <tac> Player is a type, not a type constructor
10:32:39 <Hannibal_Smith> Do anyone here use a document based database?
10:32:52 <sproingie> lazy kind of implies graph reduction, how else would you evaluate?
10:32:56 <tac> Vermeille: try changing it to    data Player a = ....
10:33:12 <Vermeille> In fact, Player is a type, and the constructor is named Player too
10:33:32 <Mortchek> You mean a data constructor, not a type constructor
10:33:47 <tac> Monads must be type constructors. Like Maybe
10:33:51 <Vermeille> Oh.
10:33:58 <tac> You can't have a "Maybe"... you have to have a "Maybe Int" or a "Maybe Bool"
10:34:07 <Vermeille> Okay, better now :)
10:34:34 <Vermeille> thank you tac ! It works :)
10:34:35 <stelleg> sproingie: yeah I guess the more important part of my question is do they all operate on supercombinators
10:34:46 <tac> np np
10:34:59 <sproingie> stelleg: ah, wouldn't know :)
10:39:19 * hackagebot bv 0.2.2 - Bit-vector arithmetic library  http://hackage.haskell.org/package/bv-0.2.2 (IagoAbal)
10:45:17 <parcs> @tell quchen awesome, much appreciated :)
10:45:17 <lambdabot> Consider it noted.
10:51:43 <Rotaerk> reading through https://github.com/ekmett/lens/wiki/Derivation
10:52:24 <Rotaerk> I don't understand the purpose of defining a Setter as "(a -> Identity b) -> s -> Identity t" instead of just "(a->b) -> s -> t"
10:52:38 <Rotaerk> I mean, "over" transforms a setter into the latter
10:52:43 <Rotaerk> so why not just directly use it
10:53:39 <Rotaerk> I see that "traverse" fits the former signature, and thus would have to be transformed via "over" in order to fit the latter signature... but I don't see why that implies all setters must go through the "over" transform
10:55:17 <zebr> hey all. is there any literature on having multiple evaluation strategies, depending on the term (or its type)? i know in some languages you can make certain subterms evaluate lazily, so there must be work proving that to be valid?
10:57:50 <jmcarthur> zebr: in haskell you can make fields in data structures strict or cause one value to be forced in order to force another
10:58:06 <jmcarthur> zebr: and you can also make certain pattern matches lazy (they are strict by default)
10:58:25 <zebr> ah yeah, that's true too.
10:58:39 <stelleg> jmcarthur: you can make pattern matches lazy?
10:58:48 <zebr> is there any theory on lambda calculus wrt that?
10:58:51 <jmcarthur> stelleg: ~
10:58:54 <zebr> as in, proving its correctness?
10:59:06 <jmcarthur> zebr: define "correctness"
10:59:55 <stelleg> jmcarthur: TIL
10:59:56 <stelleg> thanks
11:00:06 <jmcarthur> zebr: in a strongly normalizing language, evaluation order doesn't really matter all. in a possibly nonterminating language, the only effect evaluation order should have is the difference between terminating and not terminating. i don't think you should ever get a different result when it terminates though
11:00:32 <jmcarthur> s/i don't think you should ever/you should never/
11:00:36 <zebr> mm, true.
11:01:14 <stelleg> it can effect the number of reductions though
11:01:17 <stelleg> i.e. the running time
11:01:24 <jmcarthur> zebr: now, there are some weird issues with seq relating to parametricity in haskell, because it allows you to distinguish  _|_  from  \_ -> _|_
11:01:53 <jmcarthur> but i'm not a great person to talk to about parametricity
11:02:15 <zebr> i'm currently thinking about term rewriting systems, see, and i was wondering if there's any literature on having multiple reduction strategies in a given term such that, given some confluent rewrite system, you can evaluate outermost or innermost at different places, and what effects that has... not quite related to haskell, though.
11:02:35 <jmcarthur> maybe you might be interested in call by push value?
11:04:22 <zebr> hmm, i'll have a read, thanks
11:05:52 <monochrom> if you already say "confluent", then you only have this left: each strategy non-terminates or terminates with same answer as other strategies that terminate.
11:06:06 <monochrom> there is no other effect
11:06:30 <monochrom> you have to say "not confluent" to get different terminating answers
11:06:55 <jmcarthur> ah that's the word i needed
11:07:02 <monochrom> (where to find this out? from the definition of "confluent")
11:07:43 <jmcarthur> Rotaerk: the reason is that it has to match the pattern of a traversal
11:08:12 <jmcarthur> Rotaerk: it allows you to use traversal as setters rather than just things that were designed only as setters
11:17:30 <shachaf> dmwit: Arguably any expression should typecheck in an inconsistent context...
11:17:42 <shachaf> dmwit: (This is not a very good argument.)
11:18:34 <TravisD> does it make a big difference to use {-# INLINE ... #-}?
11:18:44 <shachaf> dmwit: It would be an exciting way of making unsafeCoerce, though! unsafeCoerce :: a -> b; unsafeCoerce x = case evilRefl of Refl -> x
11:18:49 <shachaf> TravisD: Sometimes.
11:19:49 <aristid> shachaf: that unsafeCoerce would seem to me a good argument against whatever you're talking about :)
11:19:49 <shachaf> dmwit: I'm a bit uncomfortable with a "magic term" like contra. What would its "type" be?
11:24:20 * hackagebot hakyll 4.2.2.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.2.2.0 (JasperVanDerJeugt)
11:26:35 <dmwit> shachaf: err, uh...
11:26:36 <dmwit> hm
11:28:07 <dmwit> shachaf: (Also, I guess it still wouldn't be possible to implement unsafeCoerce that way meaningfully, since evilRefl would presumably have to loop to have the right type, hence the match would never succeed)
11:28:28 <shachaf> dmwit: Well, evilRefl = unsafeCoerce Refl :: Is Char Bool or something.
11:28:38 <shachaf> It's still a primitive of some kind, of course.
11:29:01 <dmwit> Oh, you want to make evilRefl primitive instead of unsafeCoerce?
11:29:04 <dmwit> Seems a bit silly.
11:29:12 <shachaf> No, just saying that it could be possible.
11:29:20 <shachaf> If you allow "inconsistency -> anything goes".
11:29:33 <dmwit> evilRefl :: a ~ b -- much simpler
11:29:45 <dmwit> Though then you'd have to admit that ~ constraints are values even at the Haskell level. =)
11:29:51 <shachaf> I,I gunsafeCoerce :: p a -> p b
11:30:02 <shachaf> preflex: seen cmccann
11:30:03 <preflex>  cmccann was last seen on #haskell 2 hours, 21 minutes and 49 seconds ago, saying: shachaf: you probably don't want to ask me to help make things less horrible
11:30:09 <dmwit> What is this "I,I" thing you use so often?
11:30:59 <cmccann> hi shachaf
11:31:10 <shachaf> dmwit: I'm not entirely sure.
11:31:13 <shachaf> hi cmccann
11:31:46 <shachaf> cmccann: So you know how Haskell+RankNTypes is consistent with either (foo :: Is Char Bool -> Void) or (bar :: Is Char Bool)?
11:32:13 <shachaf> dmwit: It always looked like an owl face to me.
11:32:16 <cmccann> maybe
11:32:31 <cmccann> I'm not entirely sure which terrible thing you're doing this time
11:33:07 <shachaf> cmccann: Nothing! You're confusing me with you.
11:33:36 <cmccann> impossible, I don't make enough bad puns.
11:33:53 <shachaf> You don't make bad enough puns.
11:33:58 <cmccann> that too.
11:34:26 <mauke> dmwit: it stands for IHNP, IJLS
11:35:20 <aristid> oO
11:35:29 <shachaf> cmccann: So GADTs and/or TypeFamilies will give you (Is Char Bool -> Void)
11:35:30 <mauke> HTH, HAND.
11:35:33 <cmccann> mauke: sounds reasonable to me
11:36:11 <cmccann> shachaf: ok
11:36:29 <shachaf> cmccann: What's a smaller extension/axiom/whatever that'll give that to you?
11:36:56 <shachaf> s/'s/'d be/
11:36:57 <cmccann> -XGiveMeIsCharBoolImpliesVoidPlz
11:37:02 <cmccann> problem solved!
11:37:10 <shachaf> Yes, that was dmwit's solution.
11:37:16 <cmccann> it's a good solution.
11:37:21 <shachaf> It's not.
11:37:25 <cmccann> gets right to the heart of the matter.
11:37:41 <shachaf> I'd like something a bit more general-purpose from our type-inequality-expert-in-residence.
11:38:08 <cmccann> I don't think my type inequality thing is relevant here.
11:38:18 <shachaf> I agree.
11:38:21 <shachaf> It's just an excuse.
11:39:05 <Breadmonster> I'm having a bit of problem with my Haskell platform installation.
11:39:07 <Breadmonster> For some reason.
11:39:19 <Breadmonster> winghci refuses to work.
11:39:20 * hackagebot WordNet 1.0.0 - Haskell interface to the WordNet database  http://hackage.haskell.org/package/WordNet-1.0.0 (JoelTaylor)
11:39:24 <jmcarthur> shachaf: how do you actually create a value of type (Is Char Bool -> Void)?
11:39:35 <Breadmonster> I'll give you the error code in a minute.
11:39:35 <cmccann> shachaf: ok, so remind me again what "Is Char Bool" means exactly
11:39:37 <jmcarthur> without nontermination
11:39:47 <shachaf> jmcarthur: With GADTs?
11:39:50 <jmcarthur> yeah
11:39:53 <shachaf> cmccann: Let's say that it means (forall p. p Char -> p Bool)
11:40:00 <cmccann> I was assuming it was a GADT, in which case asking for a smaller extension in irrelevant
11:40:30 <cmccann> ok, that works.
11:40:58 <shachaf> data Foo a where { A :: Foo Char; B :: Void -> Foo Bool }; foo :: (forall p. p Char -> p Bool) -> Void; foo f = foo' (f A) where foo' :: Foo Bool -> Void; foo' (B x) = x
11:41:09 <Breadmonster> http://imgur.com/plUal2l
11:41:15 <Breadmonster> Can someone please help me with this?
11:42:29 <cmccann> shachaf: I think fancier type-aware exhaustiveness checking would be the sensible thing
11:42:35 <jmcarthur> is that doable if Is is defined as   data Is a b where Refl :: Is a a  ?
11:42:43 <jmcarthur> eh i'll just try it
11:42:50 <dmwit> mauke: TDH, kthxbai
11:43:00 <Breadmonster> jmcarthur: got a minute?
11:43:03 <shachaf> jmcarthur: Sure, it's just an empty case.
11:43:09 <Breadmonster> jmcarthur: http://imgur.com/plUal2l
11:43:15 <Breadmonster> What do I do in that case
11:43:16 <Breadmonster> ?
11:43:26 <jmcarthur> i will not click on a random imgur link without some context
11:43:32 <shachaf> jmcarthur: It's easy to convert back and forth between Leibniz Is and GADT Is, anyway.
11:43:36 <dmwit> Google tells me IJLS = I Just Like Saying; it doesn't answer for IHNP but at a guess it's something like I Have No Point, so... thanks for the one-level expansion!
11:43:43 <Breadmonster> jmcarthur: It's a screen shot.
11:43:44 <jmcarthur> shachaf: empty cases are legal?
11:43:50 <shachaf> jmcarthur: They are in HEAD!
11:43:50 <Breadmonster> winghci refuses to load
11:44:01 <jmcarthur> ah i'm not a windows user, sorry
11:44:03 <shachaf> Breadmonster: Is there any reason you're asking jmcarthur in particular?
11:44:24 <Breadmonster> No, just the first user I caught :P
11:44:27 <Breadmonster> Can you help?
11:44:37 <jmcarthur> that's not a very pleasant thing to do, btw
11:44:42 <Rotaerk> jmcarthur, what is a "traversal"? sounds like it just matches the pattern of the "traverse" function
11:44:43 <Breadmonster> My bad.
11:44:46 <jmcarthur> picking out a specific person for your general question
11:44:47 <shachaf> Picking on random people like that isn't a good strategy for getting help.
11:44:54 <Breadmonster> Fair enough.
11:44:58 <shachaf> Everyone saw your question.
11:44:58 <edwardk> Rotaerk: yes
11:45:02 <jmcarthur> Rotaerk: right
11:45:07 <edwardk> Rotaerk: that is exactly what it is
11:45:08 <elliott> Rotaerk: traversals are just generalised traverse
11:45:19 <Rotaerk> but that's just one function; most setters *aren't* the traverse function
11:45:27 <shachaf> A good strategy for getting help is to not post screenshots, though. Post text -- you just have one line of text anyway.
11:45:27 <jmcarthur> shachaf: ah, in HEAD. that explains it. i was trying to find a way to do it without that
11:45:28 <cmccann> man everyone wants to talk about traversals.
11:45:40 <edwardk> > (1,2) & both +~ 1
11:45:42 <lambdabot>   (2,3)
11:45:43 <jmcarthur> shachaf: somebody was asking me last week if it's possible to define something like that type in ocaml
11:45:45 <Rotaerk> so why not just make the signature (a->b)->s->t, and then let everything implement that signature, and then map traverse TO that signature
11:45:48 <shachaf> jmcarthur: You can do it without empty cases the way I said.
11:45:49 <edwardk> > [1,2,3] & traverse +~ 1
11:45:51 <lambdabot>   [2,3,4]
11:45:56 <Breadmonster> shachaf: I'm sorry.
11:46:02 <edwardk> > [[1,2],[3,4]] & traverse.traverse +~ 1
11:46:03 <lambdabot>   [[2,3],[4,5]]
11:46:05 <jmcarthur> shachaf: in ocaml there are no higher kinds, so you can't do it that way :\
11:46:20 <edwardk> Rotaerk: because the only things i can compose _that_ way are things that work like map, not traverse
11:46:23 <edwardk> traverse is more powerful
11:46:30 <jmcarthur> shachaf: and there are no empty matches
11:46:48 <dmwit> Breadmonster: Are you trying to open a .hs file that doesn't exist? Does ghci exist at the place it was originally installed / on your %PATH%?
11:46:50 <edwardk> the suggestion you just made gives you what conal called 'semantic editor combinators' which are in many ways a precursor to modern lenses
11:46:51 <shachaf> jmcarthur: No higher kinds? As in no polymorphism over things of kind other than *?
11:46:54 <elliott> edwardk: yikes, have you seen https://github.com/duairc/implicit/blob/master/src/Data/Implicit.hs?
11:46:56 <jmcarthur> shachaf: right
11:47:03 <shachaf> jmcarthur: That's ridiculous. How do you survive?
11:47:08 <jmcarthur> barely :)
11:47:09 <dmwit> Breadmonster: I don't have many ideas beyond that. What actions do you take that cause that error?
11:47:10 <Rotaerk> edwardk, what's an example of something that works like traverse?
11:47:25 <jmcarthur> shachaf: ocaml functors work for many of the cases that one might normally use higher kinded types
11:47:26 <Rotaerk> which wouldn't work without the Identity wrapping and unwrapping
11:47:28 <jmcarthur> shachaf: but not all
11:47:30 <edwardk> elliott: nice =)
11:47:49 <edwardk> Rotaerk: both f (a,b) = (,) <$> f a <*> f b
11:47:56 <edwardk> Rotaerk: traverse.traverse
11:48:04 <edwardk> traverse.both
11:48:06 <edwardk> both.both
11:48:06 <edwardk> etc.
11:48:15 <Breadmonster> dmwit: It's a fresh install.
11:48:25 <Breadmonster> I installed it, went out, came back and got this.
11:48:34 <Rotaerk> one sec, lemme play with that
11:48:36 <edwardk> Rotaerk: try using the equivalent of mapM over them
11:48:49 <edwardk> you want to be able to run monadic or applicative side-effects under them at each target
11:49:02 <edwardk> wth just the 'functor' like version you can only set. with the version i gave here you can also read.
11:49:08 <mcstar> i think the GUI cant find ghci
11:49:08 <edwardk> > (2,3)^..both
11:49:10 <lambdabot>   [2,3]
11:49:11 <dmwit> Breadmonster: instructions unclear, got caught under the daystar
11:49:19 <edwardk> Rotaerk: try doing that with your functor-like form
11:49:36 <mcstar> Breadmonster: make sure the gui can launch ghci
11:49:42 <edwardk> Rotaerk: the extra complexity of the shape used by lens wasn't just to make ourselves feel better ;)
11:49:45 <mcstar> at it to PATH or something
11:49:49 <Breadmonster> mcstar: Oh, okay.
11:49:50 <mcstar> (just a gusss)
11:50:01 <Rotaerk> edwardk, well I figured that much; I'm just trying to understand it
11:50:18 <cmccann> you do not understand lens, you just get used to it
11:50:20 <Rotaerk> but lemme play with these examples you've all provided...
11:50:27 <Rotaerk> cmccann, I refuse ! :P
11:50:30 <edwardk> Rotaerk: sure =)
11:51:39 <edwardk> Rotaerk: if you swap out the inner arrows in your suggested representation you can get what we call pure profunctor lenses. p a b -> p s t  for some profunctor p, when p is allows to be any profunctor that is an isomorphism, when p is only allowed to be representable you get a lens, when p is allowed to only be (->) you get a setter, etc.
11:51:44 <shachaf> cmccann: Fancier type-aware exhaustiveness checking?
11:52:01 <Rotaerk> information overload :)
11:52:37 <Breadmonster> mcstar: I should've edited PATH earlier.
11:52:41 <Breadmonster> Thanks guys :D
11:52:43 <cmccann> shachaf: I was thinking of there being some way to get an impossible type from that even without type families and that you'd have an empty case based on that
11:52:45 <shachaf> cmccann: Axioms like (Is Char Bool -> Void) would be incompatible with HoTT, by the way, right?
11:52:54 <cmccann> but the more I think about it the more I'm not sure that's possible
11:53:38 <cmccann> I don't really know anything about HoTT.
11:53:48 <shachaf> I don't either.
11:54:12 <elliott> you can get it with GADTs
11:54:15 <elliott> don't need TFs in Haskell
11:54:22 <Saizan> shachaf: i don't think so, unless you can find an isomorphism between Char and Bool
11:55:15 <shachaf> Saizan: OK, Char and Bool is a bad example.
11:55:22 <shachaf> Let's say Int8 and Word8.
11:55:33 <shachaf> (You get Is Int8 Word8 -> Void too, with GADTs.)
11:56:29 <Saizan> yeah, that'd be bad
11:57:14 <Saizan> though it all depends on how you interpret Int8 and Word8
11:57:32 <tac> Is there a built-in way to convert between strict and lazy bytestrings?
11:57:51 <notdan_> Couldn't match expected type `Tree PTMark' with actual type `[containers-0.4.2.1:Data.Tree.Tree c0]'
11:58:02 <notdan_> How to get around this error ^ ?
11:58:23 <mauke> notdan_: recompiled some packages
11:58:39 <Saizan> notdan_: that's caused by using more than one version of containers at the same time
11:58:52 <DarkLinkXXXX> Is there a mirror for the haskelll platform? The official download seems broke.
11:59:13 <notdan_> Hm. Yeah, it works fine if I do cabal-dev ghci
11:59:15 <mcstar> some lib uses another version, than your progranm is now
11:59:22 <notdan_> but for some reason I can't do that in Emacs :S
11:59:27 <mcstar> so there are duplicate installs of a package, i think
12:01:12 <notdan_> mcstar: yeah, you are right
12:01:39 <notdan_> containers-4 and containers-5 is installed globally due to fgl
12:01:39 <mcstar> what are the uses cases of lazy pattern matching in non toplevel definitions?
12:01:42 <monochrom> the short-term workaround is hide packages. the long-term solution is unregister some packages and never allow them again
12:01:52 <notdan_> but in cabal-dev/ I managed to compile fgl with containers-5
12:02:18 <DarkLinkXXXX> So are there download mirrors for the haskell platform? I tried downloading it twice: the first ended from a network error, and the second ended pre-maturely.
12:02:41 <notdan_> I would be perfectly OK with running cabal-dev ghci from Emacs but for some reason I can't get it to work
12:02:58 <notdan_> but thanks for the advice monochrom
12:04:38 <monochrom> cabal-dev probably hides a lot of packages. cabal-install certainly does
12:05:22 <mcstar> DarkLinkXXXX: idk about mirrors or platforms, but you could continue a previous download
12:05:47 <Rotaerk> hmm I think I understand now... making the signature for Setter that way allows for functions of the form "TC tc => (a -> tc b) -> s -> tc t" to automatically be Setters, where TC is any typeclass implemented by Identity
12:06:16 <Rotaerk> including Applicative, Traversable, Monad, Functor, and MonadFix
12:06:38 * DarkLinkXXXX uses wget this time.
12:07:06 <mcstar> you can ^c wget when it doesnt seem to proceed with the donwload
12:07:14 <edwardk> Rotaerk: yeah, then all those other things can be used directly as setters
12:07:23 <Rotaerk> k
12:07:30 <Rotaerk> yea that's nice
12:07:58 <edwardk> this is basically where the lattice of type constraints in lens comes from. picking constraints that are subtypes of other constraints
12:08:37 <`nand`> alexander__b: oh, you're here
12:08:38 <edwardk> so every lens is a traversal, because it just demands forall f. Functor f => (a -> f b) -> s -> f t    while a traversal is forall f. Applicative f => (a -> f b) -> s -> f t  -- so every lens is a traversal that just doesn't use the extra stuff it is given
12:08:39 <`nand`> that makes things easier
12:08:40 <`nand`> @src (.)
12:08:41 <lambdabot> (f . g) x = f (g x)
12:08:41 <lambdabot> NB: In lambdabot,  (.) = fmap
12:08:55 <`nand`> alexander__b: (<>) = mappend -- usualy
12:08:58 <`nand`> usually*
12:09:08 <`nand`> or the equivalent operator from Semigroup
12:09:15 <cmccann> edwardk: I thought the purpose of that was so you could have that fancy diagram on the hackage page
12:09:20 <Rotaerk> edwardk, when you say "traversal", do you mean functions of the above form where TC = Traversable?
12:09:20 <edwardk> Rotaerk: and since Identity is a functor (and applicative) you can use any lens or traversal as a setter
12:09:33 <alexander__b> `nand`: right.
12:09:39 <edwardk> type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t
12:09:44 <Rotaerk> oh that
12:09:44 <edwardk> Rotaerk: lots of stuff fit that form
12:09:46 <`nand`> (not . (<=x)) = (>x)
12:10:01 <edwardk> traverse :: Traversable f => Traversal (f a) (f b) a b
12:10:17 <edwardk> traverse.traverse :: (Traversable f, Traversable g) => Traversal (f (g a)) (f (g b)) a b
12:10:35 <edwardk> both :: Traversal (a,a) (b,b) a b
12:10:51 <Rotaerk> k
12:11:03 <edwardk> both.both :: Traversal ((a,a),(a,a)) ((b,b),(b,b)) a b
12:11:03 <`nand`> each > both
12:11:24 <Rotaerk> > :t each
12:11:26 <lambdabot>   <hint>:1:1: parse error on input `:'
12:11:26 <chrisdone> what's that phantom type for Data/Typeable tricks that's just data GetType a or w/e?
12:11:41 <edwardk> traverse.both :: Traversable f => Traversal (f (a,a)) (f (b,b)) a b
12:11:55 <edwardk> chrisdone: Proxy ?
12:12:46 <chrisdone> edwardk: hmm where's that defined?
12:12:47 <`nand`> alexander__b: anyway, I'm off again. If you have any questions ask them here instead and you should get even better responses :)
12:13:32 <elliott> chrisdone: tagged package
12:13:50 <edwardk> Data.Proxy in tagged
12:13:54 <elliott> chrisdone: note that if you only want to take it in as input, you should do (proxy a -> ...) rather than (Proxy a -> ...) (more flexible)
12:13:57 <chrisdone> edwardk: i'm doing the usual 'provide a witness for the type' stuff combined with asTypeOf. undefined::X sucks
12:14:10 <edwardk> chrisdone: there is asProxyTypeOf in there
12:14:12 <johnw> chrisdone: hey chris
12:14:17 <johnw> chrisdone: did you find a ticket?
12:14:25 <chrisdone> johnw: not yet
12:15:31 <edwardk> chrisdone: one way to write that asTypeOf variant is just to take
12:15:39 <elliott> edwardk: hm, does Data.Proxy have proxy a -> Proxy a? that could be useful
12:15:47 <edwardk> asArgTypeOf :: a -> p a -> a    -- then any Proxy type can be used for p.
12:15:59 <edwardk> elliott: not off hand
12:16:02 <edwardk> feel free to add it
12:17:03 <chrisdone> edwardk: writing it's trivial yeah, i just wanted to use a standard convention. i can't believe it's not already in the syb packages
12:17:37 <jmcarthur> Proxy, the terminal type constructor
12:19:21 * hackagebot matrix 0.2 - A native implementation of matrix operations.  http://hackage.haskell.org/package/matrix-0.2 (DanielDiaz)
12:24:59 <Rotaerk> what are my chances of surviving terminal type constructors?
12:25:16 <edwardk> Rotaerk: not good. that is the problem with the final solution
12:25:39 <chrisdone> edwardk: asProxy :: Proxy a -> a -> a allows  f (asProxy p -> a) = … =)
12:29:05 <jmcarthur> ViewPatterns syntax is so annoying if you want to matching more than one case for the same view
12:29:14 <jmcarthur> to slightly change the subject
12:29:19 <jmcarthur> *to match more
12:30:11 <chrisdone> jmcarthur: f (x -> foo) | a <- foo = … | b <- foo = … ?
12:30:34 <jmcarthur> hmm
12:30:43 <chrisdone> hmm sucks a bit if combiend with other stuff i bet
12:31:08 <monochrom> are they the same foo?
12:31:20 <chrisdone> yeah
12:31:21 <jmcarthur> still annoying to have to name foo, but that at least gets closer to agda's "with"
12:31:27 <chrisdone> pattern guards or w/e it was called
12:31:46 <monochrom> is foo a pattern?
12:31:52 <chrisdone> a and b are the patterns
12:31:59 <jmcarthur> foo is a variable
12:32:03 <chrisdone> you know, foo x | Just a <- x = … syntax
12:32:05 <johnw> yes, pattern guards
12:32:18 <monochrom> then "(x -> foo)" looks wrong
12:32:29 <johnw> view patterns + pattern guards
12:32:35 <chrisdone> so many arrows :p
12:32:39 <jmcarthur> x -> foo is just a view pattern
12:32:49 <chrisdone> \(←___→)/
12:33:09 <monochrom> it is "f (function -> pattern)", not "f (pattern -> function)"
12:33:09 <elliott> edwardk: does asProxyOf make sense as a prism?
12:33:11 <elliott> or something.
12:33:20 <chrisdone> f (x ↻ y) = …
12:33:31 <jmcarthur> f (viewl -> v) | EmptyL <- v = _ | x :< xs <- v = _
12:33:41 <jmcarthur> it could be worse
12:34:06 <johnw> monochrom: yes, and that's how he used it
12:34:08 <chrisdone> monochrom: yeah, so x was the function and foo was the pattern, but patterns bind new names
12:34:14 <jmcarthur> monochrom: the pattern is just a name in this case
12:34:16 <johnw> x -> foo to capture into foo, then a <- foo to capture from foo
12:34:24 <edwardk> hrmm
12:34:35 <monochrom> this is why I hate the name "foo"
12:34:39 <chrisdone> hehe
12:35:03 <centrinia> "I pity the fool who uses foo." -- Mr. T
12:35:09 <cmccann> f ↑↑↓↓←→←→ b a = ...
12:35:12 <johnw> foo is probably the most polymorphic identifier in all of computer science
12:35:23 <jmcarthur> not x?
12:35:35 <johnw> x is almost always a variable
12:35:43 <johnw> foo is a function, type, variable, password, you name it :)
12:35:45 <jmcarthur> oh right
12:36:05 <jmcarthur> i kind of associated "most polymorphic" with "very common"
12:36:17 <monochrom> foo is also more common than x
12:36:24 <jmcarthur> that would surprise me
12:36:38 <jmcarthur> in tutorials and such maybe, but in real code?
12:36:40 <chrisdone> i guess foo is used outside of writing code
12:36:57 <henk> I don’t understand the notation in the second code sample of http://hackage.haskell.org/packages/archive/cmdargs/latest/doc/html/System-Console-CmdArgs-Implicit.html. What exactly does &= do here?
12:37:19 <jmcarthur> henk: it's this function  http://hackage.haskell.org/packages/archive/cmdargs/latest/doc/html/System-Console-CmdArgs-Implicit.html#v:-38--61-
12:38:31 <elliott> if it's in System.Console.CmdArgs.Implicit then what it does is evil and unsafe :P
12:38:34 <henk> jmcarthur: ah, thank you! I thought it was some standard syntax first …
12:38:49 <jmcarthur> yeah i dislike the unsafe things in that package
12:39:07 <copamp> > concat [[1,2,3],[4,5,6]]
12:39:08 <lambdabot>   [1,2,3,4,5,6]
12:39:08 <chrisdone> unsafePerformGetAllTheArgumentsAndIgnoreThemAndSetTheKeyboardOnFireAgain
12:39:17 <jmcarthur> it's one of the rare cases where somebody "gave up" instead of finding a good purely functional interface
12:39:26 <jmcarthur> (IMO)
12:39:28 <copamp> > concat ["hello"," ","there"]
12:39:30 <lambdabot>   "hello there"
12:39:32 <cmccann> unsafePerformUnspecifiedMagic
12:39:40 <Ralith> chrisdone: what happens if you call that before the keyboard's been set on fire the first time?
12:39:40 <copamp> :t intersperse
12:39:41 <lambdabot> a -> [a] -> [a]
12:39:42 <elliott> well, there's an .Explicit too.
12:39:48 <elliott> but I really wish .Implicit would die.
12:39:59 <copamp> > concat $ intersperse " " ["hello","there"]
12:40:00 <lambdabot>   "hello there"
12:40:05 <monochrom> I don't think they gave up. they give a good purely functional interface too. they give both.
12:40:09 <elliott> > unwords ["hello","there"]
12:40:11 <lambdabot>   "hello there"
12:40:14 <elliott> copamp: ^
12:40:22 <jmcarthur> i personally see little reason to use the unsafe interface
12:40:32 <chrisdone> optparse-applicative ftw
12:40:46 <cmccann> I found the unsafe interface kinda confusing the one time I looked at it anyway
12:40:52 <johnw> yeah, optparse-applicative is much better
12:40:54 <otters> :t unfoldr
12:40:56 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
12:40:57 <chrisdone> optparse-applicative is the kind of obvious approach considering formlets and digestive-functors
12:41:02 <jmcarthur> "To disable sharing you may need to specify {-# OPTIONS_GHC -fno-cse #-} in the module you define the flags."  <-- just awful
12:41:51 <copamp> irc take basically 0 bandwidth right? because internet is slow as hell right now but i can go on here
12:42:03 <johnw> you don't really notice irc lag
12:42:19 <jmcarthur> irc takes very little bandwidth unless you do something crazy like list all of freenode's channels
12:42:19 <johnw> if your connection is low, it means your lag is really high, but you don't know it
12:42:32 <jmcarthur> which isn't even that crazy
12:42:57 <monochrom> use /ping to discover latency
12:42:59 <chrisdone> when the rapture comes the only people online will be #haskell and ##c
12:43:27 <johnw> chrisdone: why haskell?  are we forsaken?
12:43:30 <jmcarthur> what does that mean? we're the only atheists?
12:43:40 <chrisdone> and that channel that you sometimes join by mistake and notice there are 3 people in it. you know the one
12:43:51 <johnw> we are not all athesists
12:44:01 <jmcarthur> johnw: (right)
12:44:12 <henk> So is using cmdargs a bad idea for someone learning haskell? Or just the impure functions?
12:44:15 <monochrom> I am not athesist
12:44:26 <chrisdone> #haskell and ##c are the most resillient =p i imagine
12:44:28 <elliott> henk: I would just use the explicit interface
12:44:39 <johnw> henk: i wouldn't use cmdargs if you have a choice
12:44:41 <jmcarthur> Athesists, students who don’t have a thesis, question the existence of their thesis?
12:44:47 <johnw> haha
12:44:52 <johnw> my fingers are cold, so my typing is terrible
12:44:52 <mauke> chrisdone: you pung me?
12:44:56 <jmcarthur> (urban dictionary)
12:44:56 <luite> chrisdone: do you know if there's a way to find out if a javascript event handler is "dead", cannot receive events anymore, for example because all its dom elements have been removed?
12:45:14 <monochrom> ok, I am not atheist either.
12:45:34 <jmcarthur> i did not mean to bring up a religious topic here
12:45:50 <johnw> i think chrisdone did :)
12:45:50 <henk> elliott: explicit == pure?
12:45:59 <elliott> yes
12:46:01 <chrisdone> mauke: yeah i was wondering what the e -> r instance of Default was useful for
12:46:27 <mauke> ignoring arguments
12:46:30 <jmcarthur> mauke: i am a fan of that past tense for ping and will now use it forever and ever
12:46:52 <mauke> chrisdone: doStuff `catch` def  -- ignore exceptions
12:47:07 <mauke> except that's probably ambiguous
12:47:21 <johnw> yeah, you have to type qualify def
12:47:23 <chrisdone> luite: err dunno if that's possible, no
12:47:31 <henk> johnw: I do have a choice. I’m looking for an argument/option parser. I’m just starting with haskell. Can you recommend anything? optparse-applicative I guess?
12:47:37 <henk> elliott: ok, thank you :)
12:47:40 <johnw> henk: most definitely optparse-applicative
12:47:57 <johnw> not only is it better, but it gets you familiar with applicative style in a pragmatic way
12:48:32 <chrisdone> mauke: i was wondering because it overlapped with a cool instance i wanted to use where the def was a record but some fields that couldn't be populated by def alone, so i thought, why not `def foo'
12:48:33 <mauke> chrisdone: doStuff `catchIOError` def  -- ignore IO errors
12:48:39 <henk> johnw: Will take a look, thanks :)
12:48:46 <chrisdone> mauke: mm ok
12:49:11 <luite> chrisdone: hmm, i'm trying to figure out how to do event handling, but one of the problems is that any haskell value passed to javascript stil needs to be known to the haskell runtime, otherwise it will finalize its weak refs and reset its CAFs. but of course i don't want to leak memory over time
12:49:20 <elliott> chrisdone: instead of "def foo", why not just write a function? :)
12:49:34 <chrisdone> elliott: but then what do i call it?
12:49:46 <mauke> def'
12:49:53 <johnw> wouldn't it have to be: doStuff `catch` const def?
12:50:07 <mauke> johnw: no, that's the point
12:50:08 <chrisdone> johnw: no the def instance is const
12:50:11 <johnw> ah
12:50:21 <mauke> it lifts right through (e ->) and IO
12:50:21 <copamp> how is ping used?
12:50:24 <johnw> then just (def :: IO SomeException) should be sufficient to avoid ambiguity?
12:50:26 <elliott> chrisdone: well, good question :) but "def" is a bad name for it: if it has to take parameters then there's not a single "default" value
12:50:58 <copamp> and generally what is the problem when there is high lag on my internet connection? i basically cant go to other websites but IRC is fine.
12:51:00 <luite> chrisdone: otherwise the haskell side can do everything, with the makeStablPtr / freeStablePtr primitives
12:51:08 <mauke> you could of course leave them undefined and use def{ foo = 42 }
12:51:12 <chrisdone> elliott: well if your data type can have default values apart from just one field, you still want to use the established Default concept
12:51:15 <cmccann> jmcarthur: surely it should be "pang" instead? like ring vs. rang.
12:51:27 <chrisdone> mauke: yeah that's the usual approach. it just feels like a code smell to use undefined outside of debugging
12:51:33 <cmccann> though conflating rang and rung is a pretty common mistake.
12:51:36 <elliott> chrisdone: well, if it was Name -> Foo I might call it fooNamed or something
12:51:53 <elliott> chrisdone: what type is it that you cannot initialise with def, anyway?
12:52:11 <monochrom> w00t optparse-applicative contains Option.Applicative.Arrow :)
12:52:18 <monochrom> err, s/Arrow/Arrows/
12:52:19 <cmccann> jmcarthur: but I would think that if you have pung someone, they would respond with "you pang?"
12:52:23 <otters> can anybody suggest a method of mocking out a TCP server for HUnit tests
12:52:57 <chrisdone> elliott: not sure what it was now. just the kind of value that doesn't have a meaningful 'default'
12:53:08 <johnw> ping, pung, have panged!
12:53:16 <elliott> chrisdone: I'd say Int doesn't have a meaningful default either, but it has a Default instance anyway :P
12:53:29 <johnw> otters: which TCP service?
12:53:31 <chrisdone> elliott: well i didn't say "type", i said "value" =)
12:53:44 <elliott> fair enough
12:53:48 <otters> johnw: it's a chat server with a custom protocol
12:53:52 <elliott> but you could do def{ field = blah }
12:53:57 <elliott> and have def initialise it with the meaningless def
12:53:59 <otters> I'd write the fake server myself
12:54:00 <elliott> (I think this is ugly but oh well)
12:54:24 <johnw> otters: maybe just write a little mock server with 'network'
12:54:24 <chrisdone> elliott: yeah it's ugly that's the point. i think a def instance that takes an arg is nice. but alas
12:54:32 <otters> yeah
12:54:37 <elliott> I think def is ugly :)
12:54:54 <copamp> hhow do I use ping?
12:55:11 <chrisdone> elliott: def is a symptom of a larger problem i think =p
12:55:29 <johnw> copamp: just say to someone "name: ping"
12:55:47 <copamp> johnw: ping
12:55:48 <johnw> usually we have our IRC apps configured to alert us in that case somehow
12:55:50 <johnw> yeah
12:56:00 <johnw> if I weren't actually watching this channel, I'd get an OS notification
12:56:06 <copamp> johnw: ping
12:56:12 <johnw> copamp: pung
12:56:14 <copamp> did you ping me before?
12:56:19 <mauke> copamp: are you just trying to annoy people?
12:56:19 <johnw> no
12:56:24 <johnw> it's just an informal thing, btw
12:56:28 <monochrom> monochrom: ping
12:56:30 <johnw> there is no technology involved here
12:56:37 <cmccann> there's also CTCP ping
12:56:41 <cmccann> that is a thing that happens
12:56:42 <chrisdone> elliott: i.e. not having keyword arguments =o
12:56:48 <johnw> yeah, I forgot about that
12:57:00 <elliott> chrisdone: and I think the need for keyword arguments is a symptom of a larger problem still
12:57:05 <copamp> im talking about the irc ocmmand PING, can i get the time to ask the serve r and get an swner back then?¨
12:57:08 <elliott> (insufficiently factored, compositional API)
12:57:10 <johnw> i don't think anyone has ever CTCP pinged me :)
12:57:13 <elliott> but it's true that they are convenient.
12:57:33 <chrisdone> elliott: you should speak to Peaker about that as his editor will let you write functions consisting only of records
12:57:37 <johnw> copamp: oh!
12:57:38 <companion_cube> optional arguments are cool too
12:57:39 <johnw> you mean /ping
12:57:44 <johnw> yes, I did ping you before!
12:57:44 <cmccann> johnw: other than that I just did? :P
12:57:48 <kmels_> does anyone know how can i compile base:Data/List.hs in ghc with -fext-core? I tried -XCPP but I get the error: "unknown flag in  {-# OPTIONS_GHC #-} pragma: -fno-warn-typeable-instances" at Data/Typeable/Internal.hs
12:57:50 <chrisdone> elliott: but with some niceities to make it not as horrid as doing it manually in haskell
12:58:06 <johnw> cmccann: my client completely ignored it, interesting
12:58:20 <cmccann> johnw: it replied, so not completely
12:58:24 <johnw> but that ping is just to find latency times
12:58:24 <elliott> chrisdone: do you mean records only consisting of functions? otherwise I don't quite understand
12:58:25 <johnw> haha
12:58:43 <luite> chrisdone: threading! http://hdiff.luite.com:3000/race.hs.txt / http://hdiff.luite.com:3000/
12:58:46 <chrisdone> elliott: instead of currying/multi-args, all functions are 1-arg functions that take a record of fields specifying the arguments
12:59:05 <cmccann> copamp: anyway I got a CTCP ping reply from your client in 0.8s so you're not lagging much at all
12:59:50 <elliott> hm. I think that's the wrong direction: you want more currying, not less
12:59:53 <elliott> but I don't know the system
12:59:59 <chrisdone> elliott: so pretty much like common lisp or javascript-style foo({ a: 1, b: 2 })
13:00:16 <chrisdone> luite: haha it works, cool =)
13:00:42 <chrisdone> elliott: i can link you the post, hold up
13:01:06 <luite> chrisdone: source is pretty horrible unminified, closure+gzip gets it down to ~150kB including rts and 3rd party libs
13:01:42 <chrisdone> elliott: https://plus.google.com/u/0/102125020195927401442/posts/XmH7529pYU4 ctrl-f the page for 'record'
13:02:03 <chrisdone> luite: yeah i waited a while for it to load =p
13:03:29 <luite> chrisdone: i'm going to add a basic optimizer step to ghcjs itself, and store a few things more efficiently, to make it less horrible during development. but closure is probably still a good idea for production
13:03:54 <chrisdone> luite: My Life as a JavaScript Minifier Writer
13:04:04 <jmcarthur> cmccann: it would be "you pang" or "you have pung" i guess
13:04:10 <elliott> chrisdone: in general I prefer types simple/specific enough that you don't need parameter names. but it's an ideal, not something always attainable without great effort
13:04:12 <chrisdone> luite: yeah definitely don't wanna be running closure in dev
13:04:34 <cmccann> jmcarthur: yes
13:05:11 <mauke> jmcarthur: I prefer "you pung" in analogy to "sting"
13:05:17 <luite> chrisdone: hey it's haskell, javascript minification is basically a oneliner with lens! ;)
13:05:39 <chrisdone> elliott: yeah there's some trade-off there. FilePath is a cool type, but it's just documentation. it could easily be String:filepath with some labelling like in ocaml, which actually tells you *more* because you don't need to wonder whether it's Text or String or w/e
13:05:52 <jmcarthur> chrisdone: is it really?
13:05:55 <chrisdone> luite: Control.Lens.JS?
13:05:57 <elliott> chrisdone: in that case, the problem is that FilePath is wrongly implemented as an alias for String :)
13:06:01 <jmcarthur> chrisdone: i thought it behaved differently on windows and linux and such
13:06:17 <elliott> paths are structured data types, but even apart from that, e.g. on linux they are bytestrings, not unicode strings
13:06:37 <elliott> system-filepath is better in theory, though IIRC it has some problems
13:07:31 <jmcarthur> shows how much i use FilePath
13:07:33 <chrisdone> elliott: sure -- it could be properly newtyped with parsing and checks. but there are cases when a type's just a type. FilePath was just the first example to mind
13:08:15 <chrisdone> jmcarthur: maybe you're thinking of System.FilePath's </> and such?
13:08:37 <jmcarthur> probably
13:08:45 <elliott> chrisdone: I think you might find that coming up with more examples only shows you more ways in which the types shouldn't be aliases
13:09:20 <luite> chrisdone: I think just renaming local vars wouldn't be much longer if you really want to golf it and don't do nested functions (ghcjs doesn't generate those, can ignore the few cases where an ffi import splices in a function decl): collect all bodies, collect all var declarations from those, make a renaming map, collect all identifiers and map them to their renamal
13:09:28 <donri> elliott: Lens etc? :)
13:09:31 <chrisdone> elliott: http://cvs.haskell.org/Hugs/pages/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-BasicTypes.html
13:09:40 <luite> if you have the right lens instances for the jmacro AST types
13:09:54 <elliott> donri: well, lens is a bit of a special case. in many ways :P
13:10:05 <cmccann> very special
13:10:29 <elliott> chrisdone: that's an ironic example, because that's a very old documentation page, and nowadays, OpenGL implements those types as separate data types, not aliases
13:11:01 <chrisdone> ah ok
13:12:51 * cmccann wishes there were better ways to use newtypes as if they were the wrapped type without lots of boilerplate, unsafeCoerce, GeneralizedNewtypeDeriving, or whatnot
13:13:16 <chrisdone> cmccann: yeah i think that's the main reason for `type' uses
13:13:28 <elliott> cmccann: you repeated yourself there: unsafeCoerce, GeneralizedNewtypeDeriving
13:13:45 <cmccann> elliott: not the same in use
13:13:57 <shachaf> the joke is GND is unsafe
13:13:58 <cmccann> the former is more boilerplate, the latter only works for type classes :P
13:13:59 <shachaf> hth
13:14:31 <cmccann> a safe version of GeneralizedNewtypeDeriving wouldn't be what I want either
13:14:42 <dEPY> how often do you use $ indsted of parens?
13:14:54 <mauke> always
13:14:54 <shachaf> cmccann: I bet what you want is HoTT.
13:15:07 <hiptobecubic> who doesn't
13:15:15 <shachaf> never
13:15:31 <shachaf> I use $ for application and parentheses for grouping. Totally different.
13:17:08 <cmccann> why not use both? "($) (f x) (g y)", the best of both worlds!
13:18:36 <NemesisD> anyone have any suggestions for quickly running cabal test suites in a project using cabal-dev
13:19:01 <ion> cabal-dev test
13:19:06 <byorgey> cabal-dev configure --enable-tests && cabal-dev build && cabal-dev test?
13:19:10 <byorgey> what do you mean "quickly"
13:19:10 <byorgey> ?
13:19:25 <NemesisD> right now i'm just using a makefile that does something like cabal-dev configure --enable-tests; cabal-dev build; cabal-dev test, which takes about 4 seconds
13:19:26 <byorgey> actually, the cabal-dev build part is probably not required
13:20:12 <NemesisD> byorgey: just reducing the time to actually run the tests, i can't really do runhaskell because of the cabal-dev part
13:20:34 <shachaf> Probably the cabal-dev configure part is not required either.
13:20:53 <NemesisD> in my normal workflow in other languages, i use a tool that monitors the test and source dirs and reruns the tests on change so you get that tight feedback loop
13:21:50 <johnw> NemesisD: you can do that with, say, "hobbes"
13:21:53 <chrisdone> elliott: so here's an interesting problem. i have a `slot' function which takes renderer and maybe-a-value, and it renders a slot using the renderer and the function. now let's say i sometimes want to provide a classname to the slot, and sometimes a title, or both. what would your approach be?
13:21:58 <mcstar> haskell hott doesnt result in usable results
13:23:01 <NemesisD> johnw: haven't heard of hobbes yet. i'll have a look
13:23:28 <elliott> chrisdone: hm, I can't say for certain without a more general perspective on the API design, but I'd try doing it with combinators: you can have a combinator that adds a title, a combinator that adds a class name, and perhaps a combinator that adds a value (replacing the maybe-a-value part)
13:23:45 <mcstar> let me phrase this differently: what is HoTT?
13:23:53 <elliott> then, you can simply compose those to add what you need, and they get descriptive "labels" thanks to you calling the combinators
13:23:58 <shachaf> elliott: What's a combinator again?
13:23:59 <NemesisD> johnw: oh the file monitoring thing i'm not worried about. i can rig that with any number of tools, its just getting the time it takes to get the tests ready to run that i want to minimize
13:24:30 <elliott> shachaf: something that makes my design skills sound a lot fancier than they are!
13:24:39 <elliott> ok, I'll be honest: s/combinator/function/g in what I said
13:26:05 <chrisdone> elliott: ok, more info. suppose the function is monadic and its purpose is to side-effect the slot, so it really needs to be configured before it effects anything
13:26:34 <mcstar> shachaf: what does HoTT stand for?
13:27:10 <elliott> mcstar: homotopy type theory
13:27:16 <mcstar> ty
13:27:19 <shachaf> What elliott said.
13:27:20 <chrisdone> elliott: hmm. it's tricky, because it's like two functions that are like this, but they're a few lines, it would take more code to generalize them rather than adding a couple Maybe arguments. it's funny
13:27:25 <elliott> chrisdone: the render function, right?
13:27:31 <johnw> NemesisD: ah, you just want faster turnaround after modifying code?
13:27:33 <elliott> all this stuff would go in the argument to the render function, AIUI
13:28:12 <elliott> render . named "my cool name" . classNamed "my cooler class name" . title "hello" . valued 123 $ myRenderer
13:28:13 <chrisdone> elliott: ok so here's the function: http://hpaste.org/84615
13:28:16 <johnw> NemesisD: you also don't have to use cabal.  I've myself converted Cabal files to ninja build files, and been able to achieve radical improvements in turnaround for frequent builds
13:28:30 <elliott> note that this approach can and does require restructuring your library generally
13:28:43 <elliott> i.e., it's not so much a local transformation as it is a way to design them in a factored manner in the first place
13:28:49 <johnw> so much so that I started changing cabal-install to auto-generate Ninja files, but I ran out of steam
13:29:25 <chrisdone> elliott: now, right now, it's perfect. it does what it should do and lets me write code using it nicely. the problem is if i want to add a title, a class, and whatever else
13:29:34 <elliott> hm, in this case I don't even know why slot takes Maybe (a Ann), seeing as it's a nop when it's Nothing
13:29:57 <chrisdone> elliott: it's because i use slot a lot, so rather than do the maybe at the call-site, slot takes care of it
13:30:23 <elliott> mm... I wonder why you have these maybes being plumbed so far into your system in the first place, then (maybe they can be discarded earlier?)
13:30:50 <NemesisD> johnw: do you have any examples up online of your test harness for haskell projects with ninja?
13:31:05 <johnw> not of a test harness
13:31:10 <johnw> let me see if I still have the ninja file I made
13:31:11 <NemesisD> i don't have any particular affinity to using cabal for testing. in fact I kind of hate it as it decolors and eats all the output from hspec
13:31:58 <johnw> NemesisD: seems I don't have it
13:32:46 <chrisdone> elliott: well, slots are used to represent a tree. and the functions that draw parts of the tree, using slot, can either be called with a value, so, "render this part of the tree", or they can be called for /creating/ a value, so "render an editor for this part of the tree"
13:33:25 <chrisdone> elliott: but i think we're getting stuck on a digressing issue, the maybe stuff isn't the problem
13:34:07 <chrisdone> elliott: if it helps, consider the Maybe to be like that of Formlets or digestive-functor's input combinators
13:36:29 <nexx> Is there a way to use existential quantified types on data type constructors? Or actually: What to do, when I want to put data with a common data type constructor (but of course different types due to different types applied to the type constructor) into a (heterogenous) list, so that I can map a function over it?
13:37:04 <elliott> chrisdone: sure
13:37:40 <chrisdone> elliott: anyhoo, i tried 1. adding two Maybe's for title and class. that sucks, i have to write Nothing or mempty everywhere. yeuch. i tried slotWithClass but then what for title and class? yeuch. if blaze-html were more smart i could just leave it as-is and then do slot … … ! title "foo" !? "class" (\c -> c ++ "another class") or something, combinators like you said. but it's kinda opaque
13:37:59 <elliott> (btw, why on earth do you use (fromJust v) instead of x? :) )
13:38:17 <chrisdone> elliott: (well, i /can/ do that for ! title, but ja)
13:38:29 <elliott> chrisdone: yeah, in this case I think it's that you're using blaze-html quite directly
13:38:43 <elliott> so it's really blaze-html's API decisions you're seeing, more than your own
13:38:52 <chrisdone> elliott: mm because the code changed when x wasn't a parameter, and toClass is using typeable
13:38:59 <elliott> but, you could make an addClass function
13:39:09 <elliott> that makes {!? "class" (\c -> c ++ "another class"} less awful
13:40:02 <chrisdone> even !? doesn't exist. once parameters are set, they're set, no further manipulation
13:40:49 <elliott> chrisdone: sounds like the problem is blaze-html here :)
13:40:50 <chrisdone> elliott: oh i also did the err data Slot = Slot { … } approach with the configuration in there, with def
13:41:15 <elliott> chrisdone: what if you defined a function like hole, but (a) taking the Maybe, and (b) without the $ f x?
13:41:23 <chrisdone> elliott: welll, maybe, but i should probably abstract from blaze, too. so i dunno
13:41:27 <elliott> then you could add more attributes to it, and maybe it'd be about as easy to use?
13:41:30 <elliott> or something.
13:41:37 <sm> johnw, NemesisD: I use sp (searchpath) for fast turnaround (recompiles on file change)
13:41:53 <elliott> you can do (f <$> v) rather than casing on the Maybe, perhaps... or something.
13:42:35 <johnw> sm: that's a bit hard to google for; link?
13:42:56 <sm> http://hub.darcs.net/simon/searchpath .. the command is sp --no-exts --no-default-map ghc -O0 PROG.hs -o PROG GHCFLAGS -include -optPPROG/dist/build/autogen/cabal_macros.h --run
13:43:05 <johnw> aha
13:43:07 <johnw> simonware!
13:43:18 <johnw> i wonder if I even have darcs...
13:43:30 <sm> no, just my patches to the work of somebody smarter, as usual :)
13:43:32 <yezariaely> anyone knows of a haskell library which can read java classfiles including the bytecode?
13:43:47 <yezariaely> language-java-classfile prints "MethodBody Nothing" :-(
15:43:14 --- topic: '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.2 http://v.gd/oXnqjU ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","If Hackage is down, try: http://hdiff.luite.com "]'
15:43:14 --- topic: set by monochrom on [Tue Jan 29 09:36:42 2013]
15:43:14 --- names: list (clog miclorb joker_89 cmears pkrnj Guest8967 [mth] nimish copamp jao wereSheep ijp`` vili tsinnema kamatsu hive-mind morazow jang eyebloom kdridi madjestic ben_d IAmNotARobot khismetix schlicht__ carlocci tomboy64 twanvl_ Nisstyre-laptop agumonkey flux kartoffelbrei Jesin plucas Tharugrim ccc joe9 mgsloan kennyd_ KaiSforza inad922 Philonous scottj amathew Nimatek noam Guest52280 stvc AfC cognominal seliopou ToRA asQuirreL purefn twomashi doomlord nus)
15:43:14 --- names: list (skyflash_ conehead RichyB charlesofarrell quchen fxr jfischoff hajimehoshi bananagram Thomyho4 NemesisD mceier yitz merijn samedhi refold RageOfThou dkasak dixie typoclass estebistec Bwild ISF__ kmels_ issimus Targen bradleyayers dEPY sepp2k ormaaj Zedrikov Nisstyre lunarjar centrinia dnolen threesome u_quark1 DarkLinkXXXX iago toekutr Lethalman bmfx tanakh dolio TravisD azaq23 tg Noldorin eacameron Mewnoid solancile HugoDaniel MoALTz Jeanne-Kamikaze)
15:43:14 --- names: list (albel727 Martty EarlGray^ bitonic Esa_ jaeyeun fmapE q66 notdan_ theodoiko xinming vehk Enigmagic wchun chatsiri_ memand Eduard_Munteanu imeredith orzo cadsII jbu Sculptor stat_vi Rotaerk kevinqcs thorsten` hallski peterhil donri ericmj gcmalloc erkin nade heruur Tesseraction numeral parcs Swizec end3rW gwern ClaudiusMaximus Sorella chessguy Apocalisp weie_ ZFox TheFuzzball ivan` pikhq danvet Icewing k00mi kmels preflex piotr waterlaz sirchurchill janbanan)
15:43:14 --- names: list (coeus hamishmack emmanuel__ genisage Cale Eelis srhb` yumike acfoltzer dm120769 Maarten___ ilyanok DolphR hiyakashi rsimoes MrFenix leoncamel DrCode SoupEvil hughfdjackson ceii eis pantsman AntiSpamMeta Sgeo ulfdoz Reite nexx ctype_real cdidd DexterLB drbean lusory ritek xymox dreixel__ dumbhat majoh reembarking08 dont_oracle wei2912 reiddraper b52 Adios bbloom amatsu\idle copumpkin DigitalKiwi xplat drmegahertz rcl def-lkb lokydor jedai otto_s_ connelly)
15:43:14 --- names: list (alang joneshf-laptop knz mauke Nahra apaku sarfraz_ [[zz]] thirty2k fgomez nighty^ finnrobi monique_ gentleben predator217 A1kmm ktosiek rfw pettter dabradley aavogt JaRoel|4d marchdown hiratara saep Belgarion0 ezyang_ lispy ab9rf tunixman whaletechno SegFaultAX Hugglesworth nonymousa geekosaur kshannon djahandarie BMeph xunatai prinnysocks Rarrikins_f felipe_ wollw _br_ u__ ousado Eridius smarter S11001001 schroedinbug edwardk petekaz dario electrogeek)
15:43:14 --- names: list (julmuri crs_ kaoskorobase guampa niloc132 squidz c_wraith collin ozgura danols_work dannybtran tazjin realnot pcapriotti jml brainproxy f8 jon-shape LeaChim Fuuzetsu permagreen Vert alang_ eff_ Ghoul_ DrSyzygy mlh spion jtalk fryguybob tim fotc gemelen solirc Gothmog_ kkris myme s00pcan techlife Boreeas obcode nwf OlegYch8 osnr Internet13 knyppeldynan noplamodo path[l] ajhager andrewsw cschneid nu11ptr kallisti jabirali guymann jbauman hiredman taruti kith)
15:43:14 --- names: list (idntfy shergill Hafydd timemage Ralith DrChaos skyflash brisbin Philippa tzxn3 akosch elgot tavelram_ perlite KaneTW imphasing lzm Shapeshifter bholst lopex Sonderblade kyle__ johnw tgeeky mateu jlaire byorgey no-n Counter-Strike elliott setmeaway2 mmaruseacph2 flori Testos Riussi ivan\ jonke freiksenet identity ps-auxw mcdonc dented42 cyphase Shin-LaC arbn canvon floatingman dmwit yriw rs0 sh mixi neena Excureo sysop_fb IanKelling otters Rickasaurus tranma)
15:43:14 --- names: list (earthy cl_away MOMI Fuco acharles HaltingState junsuijin helgikrs dfletcher wto araujo Ptival plhk lattenwald jMCg gbarboza mjrosenb Axman6 sajith aristid Fubar^ alios ozataman nilg` emc2 kennyp Eliel ParahSail1n morolin yezariaely dan_johnsin frz_ fergusnoble __main__ gbeshers jaroslaw ahkurtz arkeet faen bbee Cerise Hermit wormphlegm profmakx Deewiant fayden zeiris sunfun mechairoi lpvb zxq9 phaul ido tomku levi message144 bergey appamatto kylcarte skp)
15:43:14 --- names: list (neurocyte mrkotfw armlesshobo Kuba monochrom wtw tomprince rmunoz mm_freak tridactyla gienah zz_nh2 inr Natch julmae Athas zz__ caligula cmccann ghorn ibid \rs latro`a tkd x7 liyang theorbtwo Igloo jlouis zoktar xorox90 sipa SLi Zariel dsantiago Nanar Gunni kmicu mspells ttuegel Th0mas volstvok tdammers tomh_ akraut FalkoPeters coppro arnihr__ SHODAN vobi Xorlev wilfredh canta PHO_ raid `nand` Nickeeh mimi_vx Jaxan scgilardi henk whoops bartavelle)
15:43:14 --- names: list (thorkilnaur rexamophone shanse solarus drek petantik FireFly Nshag kranius_ labo zwiebel_ emma alnix_ meyersh_ raek brett duairc_ integral DT` lazard ecuderpam tromp fcr othiym23 jlamothe hvr eviltwin_ banjiewen drewr simpson malorie netj Jaak sclv wumpus threedaymonk cow-orke1 XMunkki DustyDingo PaksAway chance rossabaker companion_cube djanatyn Rembane zomg ysulsky_ moonlite_ xnyhps voyd_ blackmirroxx mux MrMeh mietek MasseR robbert` pdxleif_away IbnFirnas)
15:43:14 --- names: list (pharaun jix zero7 SeanTAllen dju thirsteh maksbotan_ mimico__ ixian lenstr liesen gseitz chrisirc CosmicRay hungryblank Draconx `bps augustl hyko Tarential tensorpudding k0ral kqr1 redjohn nardul mcguitan83 lulf NougatRillettes jdoliner UziMonkey Vertue jmcarthur qwr niko kaol sbahra wting Amadiro yiannis_t Vq Dashkal pyrtsa mami kniu wagle birkenfeld simon___ mastensg joneshf Squid_Tamer bcoppens WhereIsMySpoon colah anona Ke Walther gspr Spockz ent tswett)
15:43:14 --- names: list (theDon endojelly tuv ndngvr srcerer jaspervdj stelleg domingo chirpsalot Vorpal jlewis hpc Erstarrung Ornedan Varakh Scott_firebeta heath milli rcj_ mollerstrand ccxCZ lucca Raynes kryft thetallguy1 ft verrens Zzompp brandonw machisuji mornfall agundry ChongLi tlaine kalven chrisbuchholz_ mefisto alshain mrd Tordek skuggi adnauseam vmeson jrib dottedmag mpu si14 idoru mortberg Cryovat Estrellas bogner pfoetchen ninegrid alpounet gdsx trevize brixen BigEndian)
15:43:14 --- names: list (pnielsen koninkje jodaro b_jonas leroux PrO_OkI amiller xrl_ abumirqaan bobry frontendloader puzza007 sw17ch SaBer The_third_man arun formalcow tlevine guerrilla bstrie jerojasro `micro ciaranm munro n_b jamwt natte @ChanServ ahihi Canar Clint dyreshark Laney bens sjl adimit gereedy confound wunki pr liszt mlinksva Kinnison Adeon petanqk Plex- qz pyykkis Ulrar yan_ hpaste zenzike elliottcable ahf lightquake deavidsedice otterdam tmiw hiroyuki2 edenc vhz)
15:43:14 --- names: list (trolling Megant ique td123 Guest10329 schlumpi danr lpsmith xcvii nlogax Tehnix prh dqd tomaw rio statusfailed linduxed nikola wjlroe _flow_ yano Saizan Dybber Tene anachron_ quicksilver hackagebot hpd lambdabot cross cjay koala_man mendez Draggor supki CindyLinz chrra Sagi gbluma sunnavy jercos robbe- stephe horlicks adnap harrison ziman fall_ mike2 tamiko rainmaker eyck peltchu aninhume1 Liskni_si aforemny bd_ cynick betawaffle fionnan fxrh dcoutts)
15:43:14 --- names: list (sproingie steez idnar ehamberg eL_Bart0 jrockway TML d-snp bgamari Gracenotes rmunroe mrdomino_ jackhill krig_ TDJACR alcz JPohlman1 kakos zebr zorzar wereHamster kosmikus warpy__ akahn blooberr levitation_ chr1s shachaf dennda guy_ ocharles yam dilinger strax_ tessier frio ernst Will| ptrf aszlig peddie nicoo BrianHV ethercrow epta aleator_ marienz matzo joachifm certainty qwandor|quassel cmsd2 Nik_89 suiside sgronblo arkx tahu etrepum iulian PartyKat2e sm)
15:43:14 --- names: list (JoshuaA mrshoe Soft bxc mullein Guest22595 quaestor mattp_ seats noj mikeplus64 dropdrive Baughn cdntr MK_FG luite Chousuke fireglow jaimef ByronJohnson newsham ninzine edwtjo klugez jliikka cods froztbyte tomejaguar mirsal a11235 Jonte_ etabot jcp Derander shepheb davorak thoughtpolice davean asante osfameron fabjan jyyou ]OLI[ ortmage ryanakca joeyh sohum Starfire bezik Brando753 sordina2 kloeri saurik r126l_ quuxman tippenein JoeHazzers h_chiro popz)
15:43:14 --- names: list (magicman saiam opqdonut Botje _janne ion Watcher7 s_quark docksider yeltzooo jrslepak celery__ tvaalen KitB__ sully absence Iceland_jack Gilly Heffalump gdeest_ xaimus pqmodn_ BlastHardcheese lahwran hanDerPeder Jello_Raptor miasma kini Mortchek hachiya joar Maxdamantus Khisanth Bigcheese Boney mjr84 Zouppen pepijn_away so alejandrogomez anders^^ barrucadu `0660 thetallguy shutdown_-h_now aajmakin jayne AtnNn dlundy_ int-e jtobin_ ski mokus_ tobiassjosten)
15:43:14 --- names: list (Twey cwvh descender jacobw tsou Razz Valodim ofan alexander__b)
15:43:16 <shachaf> There is no recursion.
15:43:19 <Nisstyre-laptop> where is the recursion?
15:43:25 <shachaf> You must first understand the lambda syntax.
15:43:37 <Saizan> eyebloom: but there are actually no type definitions in System F
15:43:37 <alexander__b> right. then I do not understand the implication of using xs in the body of \xs.
15:43:44 <shachaf> \xs is not a name.
15:43:49 <Nisstyre-laptop> xs is the name of the parameter
15:43:53 <shachaf> xs is the name of the argument.
15:43:54 <alexander__b> ahhhhh
15:43:56 <shachaf> Yes. Parameter.
15:44:09 <shachaf> I think you should read that chapter more carefully. :-)
15:44:12 <alexander__b> yes I just reread the lambda section. silly me. why would you name a lambda function, I even thought as I read it.
15:44:17 <ion> Yes. Paramedic.
15:44:25 <joker_89> if i have a function that takes a list of random numbers and return a tuple like ([Int],[Int]) with the list of even numbers and a list of odd numbers, how can i do it in one function?
15:44:44 <shachaf> @ty partition
15:44:45 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
15:44:56 <monochrom> joker_89: you can draw inspiration from the source code of partition
15:45:00 <monochrom> @src partition
15:45:00 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
15:45:00 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
15:45:00 <lambdabot>                               | otherwise = (ts, x:fs)
15:45:03 <typoclass> joker_89: this function ^^ should be able to do it
15:45:15 <joker_89> mm partition
15:45:21 <monochrom> hmm, "one function"? that may be a harder requirement
15:45:41 <monochrom> oh, it is not, you can expand "foldr" into your own recursion
15:45:45 <joker_89> i put a simple example but its similar to odd and even numberes, I go to search on google about partition
15:45:47 <alexander__b> shachaf: I think maybe I'm too tired for this, if I can't even read. be back tomorrow. thanks for the help. :-)
15:45:49 <eyebloom> Saizan: I see, do mean not in the strict definition of System F? Or in FC-Pro>
15:45:55 <Nisstyre-laptop> alexander__b: you can desugar "let f a b = a + b" to "let f = (\a -> \b -> a + b)"
15:46:04 <ParahSail1n> >let oneFunction = partition even
15:46:24 <Nisstyre-laptop> desugaring is the act of breaking something down into something simpler
15:46:49 --- topic: '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.2 http://v.gd/oXnqjU ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","If Hackage is down, try: http://hdiff.luite.com "]'
15:46:49 --- topic: set by monochrom on [Tue Jan 29 09:36:42 2013]
15:46:49 --- names: list (clog mizu_no_oto ijp`` staafl darinmorrison miclorb joker_89 cmears pkrnj Guest8967 [mth] nimish copamp jao wereSheep vili tsinnema hive-mind morazow eyebloom kdridi madjestic ben_d IAmNotARobot khismetix schlicht__ carlocci tomboy64 twanvl_ Nisstyre-laptop agumonkey flux kartoffelbrei Jesin plucas ccc joe9 mgsloan kennyd_ KaiSforza inad922 Philonous scottj amathew Nimatek noam Guest52280 stvc AfC cognominal seliopou ToRA asQuirreL purefn twomashi doomlord)
15:46:49 --- names: list (nus skyflash_ conehead RichyB charlesofarrell quchen fxr jfischoff hajimehoshi bananagram Thomyho4 NemesisD mceier yitz merijn samedhi refold RageOfThou dkasak dixie typoclass estebistec Bwild ISF__ kmels_ issimus Targen bradleyayers dEPY sepp2k ormaaj Zedrikov Nisstyre lunarjar centrinia dnolen threesome u_quark1 DarkLinkXXXX iago toekutr Lethalman bmfx tanakh dolio TravisD azaq23 tg Noldorin eacameron Mewnoid solancile HugoDaniel MoALTz albel727 Martty)
15:46:49 --- names: list (EarlGray^ bitonic Esa_ jaeyeun fmapE q66 notdan_ theodoiko xinming vehk Enigmagic wchun chatsiri_ memand Eduard_Munteanu imeredith orzo cadsII jbu Sculptor stat_vi Rotaerk kevinqcs thorsten` hallski peterhil donri ericmj gcmalloc erkin nade heruur Tesseraction numeral parcs Swizec end3rW gwern ClaudiusMaximus Sorella chessguy Apocalisp weie_ ZFox TheFuzzball ivan` pikhq danvet Icewing k00mi kmels preflex piotr waterlaz sirchurchill janbanan coeus hamishmack)
15:46:49 --- names: list (emmanuel__ genisage Cale Eelis srhb` yumike acfoltzer dm120769 Maarten___ ilyanok DolphR hiyakashi rsimoes MrFenix leoncamel DrCode SoupEvil hughfdjackson ceii eis pantsman AntiSpamMeta Sgeo ulfdoz Reite nexx ctype_real cdidd DexterLB drbean lusory ritek xymox dreixel__ dumbhat majoh reembarking08 dont_oracle wei2912 reiddraper b52 Adios bbloom amatsu\idle copumpkin DigitalKiwi xplat drmegahertz rcl def-lkb lokydor jedai otto_s_ connelly alang joneshf-laptop)
15:46:49 --- names: list (knz mauke Nahra apaku sarfraz_ [[zz]] thirty2k fgomez nighty^ finnrobi monique_ gentleben predator217 A1kmm ktosiek rfw pettter dabradley aavogt JaRoel|4d marchdown hiratara saep Belgarion0 ezyang_ lispy ab9rf tunixman whaletechno SegFaultAX Hugglesworth nonymousa geekosaur kshannon djahandarie BMeph xunatai prinnysocks Rarrikins_f felipe_ wollw _br_ u__ ousado Eridius smarter S11001001 schroedinbug edwardk petekaz dario electrogeek julmuri crs_ kaoskorobase)
15:46:49 --- names: list (guampa niloc132 squidz c_wraith collin ozgura danols_work dannybtran tazjin realnot pcapriotti jml brainproxy f8 jon-shape LeaChim Fuuzetsu permagreen Vert alang_ eff_ Ghoul_ DrSyzygy mlh spion jtalk fryguybob tim fotc gemelen solirc Gothmog_ kkris myme s00pcan techlife Boreeas obcode nwf OlegYch8 osnr Internet13 knyppeldynan noplamodo path[l] ajhager andrewsw cschneid nu11ptr kallisti jabirali guymann jbauman hiredman taruti kith idntfy shergill Hafydd)
15:46:49 --- names: list (timemage Ralith DrChaos skyflash brisbin Philippa tzxn3 akosch elgot tavelram_ perlite KaneTW imphasing lzm Shapeshifter bholst lopex Sonderblade kyle__ johnw tgeeky mateu jlaire byorgey no-n Counter-Strike elliott setmeaway2 mmaruseacph2 flori Testos Riussi ivan\ jonke freiksenet identity ps-auxw mcdonc dented42 cyphase Shin-LaC arbn canvon floatingman dmwit yriw rs0 sh mixi neena Excureo sysop_fb IanKelling otters Rickasaurus tranma earthy cl_away MOMI Fuco)
15:46:49 --- names: list (acharles HaltingState junsuijin helgikrs dfletcher wto araujo Ptival plhk lattenwald jMCg gbarboza mjrosenb Axman6 sajith aristid Fubar^ alios ozataman nilg` emc2 kennyp Eliel ParahSail1n morolin yezariaely dan_johnsin frz_ fergusnoble __main__ gbeshers jaroslaw ahkurtz arkeet faen bbee Cerise Hermit wormphlegm profmakx Deewiant fayden zeiris sunfun mechairoi lpvb zxq9 phaul ido tomku levi message144 bergey appamatto kylcarte skp neurocyte mrkotfw armlesshobo)
15:46:49 --- names: list (Kuba monochrom wtw tomprince rmunoz mm_freak tridactyla gienah zz_nh2 inr Natch julmae Athas zz__ caligula cmccann ghorn ibid \rs latro`a tkd x7 liyang theorbtwo Igloo jlouis zoktar xorox90 sipa SLi Zariel dsantiago Nanar Gunni kmicu mspells ttuegel Th0mas volstvok tdammers tomh_ akraut FalkoPeters coppro arnihr__ SHODAN vobi Xorlev wilfredh canta PHO_ raid `nand` Nickeeh mimi_vx Jaxan scgilardi henk whoops bartavelle thorkilnaur rexamophone shanse solarus)
15:46:49 --- names: list (drek petantik FireFly Nshag kranius_ labo zwiebel_ emma alnix_ meyersh_ raek brett duairc_ integral DT` lazard ecuderpam tromp fcr othiym23 jlamothe hvr eviltwin_ banjiewen drewr simpson malorie netj Jaak sclv wumpus threedaymonk cow-orke1 XMunkki DustyDingo PaksAway chance rossabaker companion_cube djanatyn Rembane zomg MrMeh mietek MasseR robbert` pdxleif_away ysulsky_ moonlite_ xnyhps voyd_ blackmirroxx mux IbnFirnas pharaun jix zero7 SeanTAllen dju)
15:46:49 --- names: list (thirsteh maksbotan_ mimico__ ixian lenstr liesen gseitz chrisirc CosmicRay hungryblank Draconx `bps augustl hyko Tarential tensorpudding k0ral kqr1 redjohn nardul mcguitan83 lulf NougatRillettes jdoliner UziMonkey Vertue jmcarthur qwr niko kaol sbahra wting Amadiro yiannis_t Vq Dashkal pyrtsa mami kniu wagle birkenfeld simon___ mastensg joneshf Squid_Tamer bcoppens WhereIsMySpoon colah anona Ke Walther gspr Spockz ent tswett theDon endojelly tuv ndngvr)
15:46:49 --- names: list (srcerer jaspervdj stelleg domingo chirpsalot Vorpal jlewis hpc Erstarrung Ornedan Varakh Scott_firebeta heath milli rcj_ mollerstrand ccxCZ lucca Raynes kryft thetallguy1 ft verrens Zzompp brandonw machisuji mornfall agundry ChongLi tlaine kalven chrisbuchholz_ mefisto alshain mrd Tordek skuggi adnauseam vmeson jrib dottedmag mpu si14 idoru mortberg Cryovat Estrellas bogner pfoetchen ninegrid alpounet gdsx trevize brixen BigEndian pnielsen koninkje jodaro)
15:46:49 --- names: list (b_jonas leroux PrO_OkI amiller xrl_ abumirqaan bobry frontendloader puzza007 sw17ch SaBer The_third_man arun formalcow tlevine alexander__b ofan Valodim Razz tsou jacobw descender cwvh Twey tobiassjosten mokus_ ski jtobin_ int-e dlundy_ AtnNn jayne aajmakin shutdown_-h_now thetallguy `0660 barrucadu anders^^ alejandrogomez so pepijn_away Zouppen mjr84 Boney Bigcheese Khisanth Maxdamantus joar hachiya Mortchek kini miasma Jello_Raptor hanDerPeder lahwran)
15:46:49 --- names: list (BlastHardcheese pqmodn_ xaimus gdeest_ Heffalump Gilly Iceland_jack absence sully KitB__ tvaalen celery__ jrslepak yeltzooo docksider s_quark Watcher7|off ion _janne Botje opqdonut saiam magicman popz h_chiro JoeHazzers tippenein quuxman r126l_ saurik kloeri sordina2 Brando753 bezik Starfire sohum joeyh ryanakca ortmage ]OLI[ jyyou fabjan osfameron asante davean thoughtpolice davorak shepheb Derander jcp etabot Jonte_ a11235 mirsal tomejaguar froztbyte cods)
15:46:49 --- names: list (jliikka klugez edwtjo ninzine newsham ByronJohnson jaimef fireglow Chousuke luite MK_FG cdntr Baughn dropdrive mikeplus64 noj seats mattp_ quaestor Sagi chrra CindyLinz supki Draggor mendez koala_man cjay cross lambdabot hpd hackagebot quicksilver anachron_ Tene Dybber Saizan yano _flow_ wjlroe nikola linduxed statusfailed rio tomaw dqd prh Tehnix nlogax xcvii lpsmith danr schlumpi Guest10329 td123 ique Megant trolling vhz edenc hiroyuki2 tmiw otterdam)
15:46:49 --- names: list (deavidsedice lightquake ahf elliottcable zenzike hpaste yan_ Ulrar pyykkis qz Plex- petanqk Adeon Kinnison mlinksva liszt pr wunki confound gereedy adimit sjl bens Laney dyreshark Clint Canar ahihi @ChanServ natte jamwt n_b munro ciaranm `micro jerojasro bstrie guerrilla gbluma sunnavy jercos robbe- stephe horlicks adnap harrison ziman fall_ mike2 tamiko rainmaker eyck peltchu aninhume1 Liskni_si aforemny bd_ cynick betawaffle fionnan fxrh dcoutts sproingie)
15:46:49 --- names: list (steez idnar ehamberg eL_Bart0 jrockway TML d-snp bgamari Gracenotes rmunroe mrdomino_ jackhill krig_ TDJACR alcz JPohlman1 kakos zebr zorzar wereHamster kosmikus warpy__ akahn blooberr levitation_ chr1s shachaf dennda guy_ ocharles yam dilinger strax_ tessier frio ernst Will| ptrf aszlig peddie nicoo BrianHV ethercrow epta aleator_ marienz matzo joachifm certainty qwandor|quassel cmsd2 Nik_89 suiside sgronblo arkx tahu etrepum iulian PartyKat2e sm JoshuaA)
15:46:49 --- names: list (mrshoe Soft bxc mullein Guest22595)
15:46:53 <Saizan> eyebloom: don't know what FC-Pro> is
15:47:02 <Nisstyre-laptop> simpler for a compiler/interpreter of course
15:47:08 <eyebloom> Sorry that > should be a ?
15:47:29 <typoclass> > partition (== 'l') "lolcat" -- joker_89: here is an example use of the partition function
15:47:31 <lambdabot>   ("ll","ocat")
15:47:46 <eyebloom> FC-Pro is the type system now used in haskell to my knowledge?
15:48:03 <Saizan> eyebloom: in the internals of GHC you mean?
15:48:28 <eyebloom> I think so.
15:48:33 <eyebloom> I'm no expert
15:48:54 <Saizan> it sounds plausible from the name
15:49:03 <TravisD> Am I doing something obviously wrong here? http://hpaste.org/84620
15:49:06 <eyebloom> F little c with an up arrow on it.
15:49:28 <TravisD> the type of runWithCreate is: "runWithCreate
15:49:29 <TravisD>   :: Control.Monad.Primitive.Class.MonadPrim m => Rand m a -> m a"
15:49:40 <Saizan> eyebloom: yeah, i guess that's a recent version of the core language GHC translates haskell into
15:49:46 <typoclass> TravisD: dmr?
15:49:51 <TravisD> dmr?
15:50:13 <shachaf> @where dmr
15:50:13 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
15:50:27 <eyebloom> In any case my goal is just to understand how the compiler breaks down data statements, either by desugaring or into operational symantics.
15:50:29 <dEPY> in case i have a function:   something a b = f1 (f2 b) a       is it ok to shorten it to:    something = f1 . f2   ?
15:50:33 * geekosaur thinks that either also tries to leak something out of the ST, or is pointlessly using it
15:50:43 <dEPY> or do you rather see the longer version cause it's more readable?
15:50:46 <joker_89> not in scope partition
15:50:50 <edwardk> eyebloom: have you read the spineless tagless g-machine papers?
15:50:59 <geekosaur> joker_89: Data.List
15:51:05 <joker_89> ok
15:51:18 <edwardk> eyebloom: oh you mean data statements not misc. statements sorry
15:51:21 <geekosaur> @pl something a b = f1 (f2 b) a
15:51:22 <lambdabot> something = flip (f1 . f2)
15:51:27 <edwardk> eyebloom: /me reads back
15:51:38 <TravisD> geekosaur: The random number generator keeps its state in ST. I'm just trying to figure out how to use it
15:51:41 <monochrom> TravisD: I don't think "runST (MWC.runWithCreate a)" has type "ST s a"
15:52:05 <eyebloom> Tried to, I'm just finishing up "Types and Programming Languages" I was going to start "Implementing Functional Programming Languages" after that.
15:52:13 <TravisD> oh, oops - I was messing around. It should "sampleRV :: RV s a -> a"
15:52:27 <monochrom> yeah! that may work better
15:52:42 <eyebloom> Couldn't really get through spineless tagless the first time I read it but I think I may be ready again soon.
15:52:59 <monochrom> but then you need (forall a. RV s a) -> a
15:53:09 <TravisD> monochrom: Still get  a new error: http://hpaste.org/84620
15:53:10 <TravisD> ah
15:53:17 <monochrom> oops, not forall a. forall s
15:53:18 <joker_89> ouch partition doesn't work because i need to take 4 by 4 elements not 1 by 1
15:53:22 <joker_89> of my list
15:53:25 <monochrom> (forall s. RV s a) -> a
15:53:38 <c_wraith> I was going to ask about that forall a.
15:53:39 <eyebloom> edwardk: lines that begin with "data" or "type".
15:53:43 <c_wraith> 'cause it didn't make much sense
15:53:53 <TravisD> monochrom: That works
15:54:01 <TravisD> at least it type checks
15:54:08 <monochrom> my brain has high error rate!
15:54:39 <joker_89> how can i write a partition function that thakes 4 by 4 the elements of the list?
15:55:16 <edwardk> eyebloom: that story has evolved quite a bit over time, but really it comes down to just making value constructors of the appropriate types from them, and before the polykinded days it involved doing a monomorphization pass to clamp remaining kind variables to *.
15:56:14 <eyebloom> I see, how is a value constructor encoded?
15:57:25 <TravisD> monochrom: So, the first "sampleRV" implicitly had the type "forall s. forall a. RV s a -> a". And what we needed was "forall a. (forall s. RV s a) -> a"?
15:57:31 <edwardk> eyebloom: part of that is the STG story, the rest is just making a function that has the right type that in the end builds the right representation for the data constructor when it is fully applied
15:57:51 <EarlGray^> Is there a "update or insert" function in Data.Map ?
15:58:05 <johnw> EarlGray^: lens has one, fwiw
15:58:08 <monochrom> yes TravisD
15:58:14 <EarlGray^> something like (Maybe a -> a) -> k -> Map k a -> Map k a
15:58:24 <TravisD> monochrom: Can you help me understand what the difference is?
15:58:25 <eyebloom> edwardk: Or, is there a place that shows how the compiler operationally encodes these. I think in the case of GADTs it becomes important to know what's happening under the hood for example.
15:58:28 <EarlGray^> but Hoogle does not find anything
15:58:33 <monochrom> it is similar to runST :: (forall s. ST s a) -> a
15:58:50 <TravisD> mhm, I recognize the pattern
15:59:01 <cmears> EarlGray^, "adjust" ?
15:59:04 <dEPY> What's the ratios in this channel for academic : non-academic   programmers?:)
15:59:12 <cmears> EarlGray^, and "update"
15:59:34 <edwardk> eyebloom: in our little compiler here at s&p capital iq, we wind up desugaring data List a = Nil | Cons a (List a) into an additional type in the environment, and two terms Nil that expands out to our core-like equivalent of saying to build a data constructor with index 1 with no args, and 'Cons' which expands out into something that expects 2 args, and packs them up into the data constructor with index 2 with those args.
15:59:37 <cmears> EarlGray^, and "alter" is the most general one
15:59:39 <EarlGray^> What does 'adjust' do if there's no such key?
15:59:46 <monochrom> in "sampleRV :: forall a. (forall s. RV s a) -> a", you (author) chooses s, I (user) chooses a.
16:00:06 <edwardk> they get put in the environment with types Nil :: forall a. List a   and Cons :: forall a. a -> List a -> List a and then type checking proceeds from there.
16:00:07 <EarlGray^> alter is what I need, thanks
16:00:08 <cmears> EarlGray^, it does nothing -- use "alter" if you want to do something olse
16:00:14 <cmears> No problem (:
16:01:05 <edwardk> eyebloom: to typecheck them we basically just find all the strongly connected components between our different type and data statements, and then resolve them in topological order. checking kinds in each cycle
16:01:16 <edwardk> then we spit out all the data constructors
16:01:41 <edwardk> and they look to most of the rest of the system like arbitrary functions (except that they can be used to pattern match)
16:02:16 <edwardk> eyebloom: it sounds complicated but its actually really simple until you bring in GADTs and System F_c machinery
16:02:17 <eyebloom> how does the environment store the fact that both nil and cons are of type list?
16:03:10 <TravisD> monochrom: Hm, I see. So what prevents me from making an instance of RV Int Int, or something. Where the user specifies what s must be
16:03:10 <edwardk> eyebloom: they literally look to much of the system like functions. as in they get put in the environment just like i'd put a function named 'nil'
16:03:25 <edwardk> we do track what things are members of each type so we can do exhaustiveness checking for case analysis, etc. but thats almost entirely separate
16:04:16 <eyebloom> I see, that makes a lot of sense. Why don't you use GHC?
16:04:55 <edwardk> eyebloom: we have a lot of constraints on the language we need that make it make more sense for us to write our own compiler that we can run in other backends, notably the jvm.
16:05:31 <joker_89> monochrom
16:05:35 <edwardk> while we don't have a lot of the stuff ghc does offer we can do other things like control the error messages better and we can implement things like a row type solver in the typechecker, etc. to give us a nicer user experience for working with database backends, etc.
16:07:18 <eyebloom> I see. I find it's really helpful to reduce expressions by hand on occasion and I'm dealing with a particularly difficult typing problem that I've been trying to figure out for a little while so I've been trying to break it down as much as possible into just a lambda calculus...
16:08:38 <hpaste> pharaun pasted “is there a nicer way of doing this?” at http://hpaste.org/84622
16:08:45 <edwardk> note: you can typically pretend that a data type is just its church or scott encoding.
16:09:47 <johnw> updateLength p x = updatePangoLength <$> pure x <*> calcLength p x
16:09:55 <eyebloom> I see. That seems daunting just because the amount of computation there expands a lot, but I'll have to see.
16:10:37 <edwardk> data List a = Nil | Cons a (List a)   could be re-encoded (Church-like) as type List a = forall r. r -> (a -> r -> r) -> r        or Scott-like as type List a = forall r. r -> (a -> List a -> r)     if you want to ignore the sharing implications -- the latter is of course not legal haskell
16:10:45 <pharaun> johnw: dang it, nice :) i keep on forgetting applicative
16:10:48 <pharaun> thanks
16:11:26 <johnw> sure.  whenever you use "<-" just to use the result only once on the next line (or maybe several such), applicative might be the answer
16:11:37 <ExternalReality> question: If one where to break down a conversation into its constituent parts then what name would be given to a single exchange of ideas. I mean what would you call a type representing a statement and a possible reply to that statement by another.
16:11:41 <ExternalReality> *were
16:11:46 <pharaun> johnw: yeah that's what i keep on forgetting >_<
16:11:51 <johnw> ExternalReality: exchange?
16:11:54 <eyebloom> Not legal because it's recursive?
16:12:14 <edwardk> it expands out to an infinite type
16:12:34 <eyebloom> My favorite.
16:12:54 <edwardk> but ignoring those thats fine
16:13:21 <edwardk> our first pass at implementing our compiler did that
16:13:41 <eyebloom> used recursive types?
16:13:53 <edwardk> used that operational interpretation for pattern matching
16:17:37 <ExternalReality> pharaun: There is really no way to know without knowing what you are doing
16:18:52 <pharaun> ExternalReality: yeah, i was more after a nicer way of formatting/cleaning up that line :) and applicative did the job
16:19:25 <pharaun> ExternalReality: but basically i was just using pango to get the length of a string which is (io double) so i wanted to restuff that and update a record with that value
16:21:39 <joker_89> i am using (take 4 list) (++) xs and says that "takes" is taken 4 arguments lol
16:21:43 <joker_89> why?
16:22:07 <shachaf> johnw: Was disconnected. 16:16 <shachaf> johnw: f <$> pure a <*> b?
16:22:20 <johnw> yes?
16:22:31 <raek_> joker_89: you are giving it 4 arguments...
16:22:32 <shachaf> johnw: Simplifying that is left as an exercise for the reader.
16:22:37 <johnw> f a <$> b
16:22:43 <raek_> a b c d = (((a b) c) d)
16:22:50 <shachaf> Yep. :-)
16:23:06 <raek_> joker_89: try removing the parenteses around ++
16:23:11 <johnw> pharaun: updateLength p x = updatePangoLength x <$> calcLength p x
16:23:18 <joker_89> ok
16:23:39 <raek_> take 4 list ++ xs == ((take 4) list) ++ xs
16:23:57 <joker_89> another question
16:24:01 <johnw> shachaf: thanks for that
16:24:08 <pharaun> johnw: ha
16:24:08 <joker_89> how can i write a partition function that thakes 4 by 4 the elements of the list?
16:24:18 <pharaun> yeah that would be ever slightly a bit nicer :)
16:24:39 <ExternalReality> pharaun: the definition updateLength seems to imply state monad.
16:24:39 <ExternalReality> johnw: I was thinking "exchange" but I was also thinking  "somebody has to have come up with a term for this by now!"
16:25:18 <pharaun> ExternalReality: yeah i am starting to debate that cos i've been passing around - updateLength :: (PangoContext, [PangoAttribute]) -> Primary -> IO Primary
16:25:27 <pharaun> so probably could put the () into a reader/state monad
16:27:24 <raek_> joker_89: something like "partition 3 [1, 2, 3, 4, 5, 6, 7] == [[1, 2, 3], [4, 5, 6], [7]]"?
16:29:53 <johnw> :t partition
16:29:55 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
16:30:37 <raek_> I'm used to the Clojure 'partition'... :-)
16:31:09 <joker_89> it's like partition but in group of 4 elements
16:31:14 <johnw> raek_: I think the function you want is some kind of "chunks"
16:31:35 <johnw> @hoogle chunksOf
16:31:36 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
16:31:36 <lambdabot> Data.Text.Lazy chunksOf :: Int64 -> Text -> [Text]
16:31:47 <johnw> yes, it's in the 'split' package
16:31:58 <johnw> chunksOf :: Int -> [e] -> [[e]]
16:32:16 <monochrom> joker_89: I still don't understand what it means. is there a good example?
16:32:21 <johnw> Data.List.Split.chunksOf
16:32:34 <joker_89> i use a function and then 2 separete fucntions
16:32:57 <joker_89> i can't do it with one function
16:33:12 <monochrom> ok, that's still very abstract
16:33:32 <monochrom> I mean too abstract for me to see what it means
16:34:00 <monochrom> also, I am wary of the requirement "one function". why impose it?
16:35:15 <joker_89> mm somthing that i recive a list of all cards played, then i check the first 4 cards and apply a filter, if even players win then go to the first part of the tuple, if odd players win then go to second part of the tuple and the result is ([Card],[Card])
16:37:50 <cschneid> Just ran into an error: "Type of kind * used as a constraint" on compile.  The type signature is simple: parseCorpus :: [String] => Map.Map Char Int
16:38:04 <cschneid> what's going on? I want to take a bunch of strings, categorize them into something I can then lookup into
16:38:07 <johnw> yes, that type is illegal
16:38:09 <cschneid> I import Data.Map as Map
16:38:13 <johnw> [String] -> Map.Map Char Int
16:38:15 <cschneid> yeah, so why :) New to all this
16:38:17 <johnw> I think that's what you wanted
16:38:19 <cschneid> AHH
16:38:20 <cschneid> damn
16:38:23 <cschneid> stupid ruby fingers.
16:38:27 <cschneid> always making fat arrows
16:38:40 <jmcarthur> fat arrows have a meaning too, just not the same :)
16:38:49 <joker_89> split
16:38:52 <cschneid> yes, I know that. Just not there :)
16:38:57 <cschneid> thank you guys
16:39:01 <monochrom> ok, you start with a list of cards [c0, c1, c2, c3, ... c19]. first use what they said to pre-process it into [ [c0, c1, c2, c3], [c4, c5, c6, c7], ..., [c16, c17, c18, c19] ]
16:39:41 <joker_89> i see
16:39:54 <joker_89> then i need 2 funcitons , one to process
16:40:17 <monochrom> then you can use partition to get, say, ( [ [c0, c1, c2, c3], [c16, c17, c18, c19] ], [ [c4, c5, c6, c7], [c8, c9, c10, c11], [c12, c13, c14, c15] ] )
16:40:46 <joker_89> yes then i know
16:40:57 <monochrom> finally you can use (\(x,y) -> (concat x, concat y)) to flatten them
16:41:43 <monochrom> ok, you insist on one function. I guess I'll play along. the code is still pretty close to partition's.
16:42:19 <monochrom> bonapart [] = ([], [])
16:42:31 <johnw> part of the whole joy of Haskell is composition, so I'd say require more functions!
16:43:09 <monochrom> bonapart (c0:c1:c2:c3:more) = let (x,y) = bonapart more in ...
16:43:25 <Hafydd> boneapart [] = ([], "8==D", [])
16:43:42 <monochrom>   if your_condition c0 c1 c2 c3 then (c0:c1:c2:c3:x, y) else (x, c0:c1:c2:c3:y)
16:46:34 <otters> ok this is confusing me
16:46:52 <otters> my cabal package has one executable called "lexie"
16:46:53 <monochrom> I agree. (j/k)
16:47:16 <otters> I want my test suites to have access to the internal lexie modules
16:47:16 <monochrom> does it also have a library part?
16:47:17 <otters> no, it doesn't
16:47:17 <otters> well, it does now
16:47:18 <otters> I copied the Executable section and replaced Executable lexie with Library
16:47:28 <monochrom> then sorry, I don't know the testing parts of cabal
16:47:31 <otters> but if I make the Test-Suite build-depend on lexie, it still needs all the packages that lexie *also* depends on
16:47:38 <otters> and it seems like there should be an easier way
16:48:17 <Clint> there isn't, if your tests actually use those packages
16:48:48 <joker_89> well how can i sum a list of Cards wich some cards have some value like 5,4,3,2,1 or 0 depending of the type, i do a (x:xs) | x==King =3 + xs...
16:48:48 <joker_89> but don't work
16:48:48 <otters> Clint: all my test does is run the executable
16:48:49 <otters> well, not precisely
16:48:56 <otters> main = lexie hostname port is the contents of Main.hs
16:49:18 <otters> I made it take a hostname argument because I want to make a fake TCP server
16:49:18 <otters> for testing purposes
16:50:07 <joker_89> well how can i sum a list of Cards wich some cards have some value like 5,4,3,2,1 or 0 depending of the type, i do a myfucntion (x:xs) | x==King =3 + myfunction xs...
16:50:51 <Botje_> joker_89: don't repeat yourself.
16:51:20 <monochrom> "myfucntion (x:xs) | x==King =3 + myfunction xs" is exactly right, provided "x==King" makes sense. therefore, the problem is not with summing, but with x==King
16:51:25 <monochrom> no no, repeating is fine by me!
16:51:35 <monochrom> especially since this one is new information added
16:51:54 <elliott> monochrom: actually, it does not necessarily make sense
16:51:57 <Botje_> oh yeah, now i see
16:52:01 <elliott> myfucntion vs. myfunction
16:53:30 <monochrom> these days GHC will suggest "myfunction is not in scope. do you mean: myfuvction?"
16:55:07 <skyflash_> Hmm, I have a (Map -> IO (Map) and want to chain these forever (in fact, like 'forever' but with bind and an initial value for a).  Should I change this function to (IO Map -> IO Map) and use iterate?
16:56:02 <monochrom> no need, and iterate is beside the point. let me think.
16:56:31 <monochrom> @type foldM
16:57:18 <monochrom> not foldM
16:59:57 <monochrom> perhaps foldr (>=>) return (repeat your_function) initial
17:00:53 <monochrom> you can also write your own recursion
17:01:37 <skyflash_> monochrom: Thanks... having a play...
17:02:02 <S11001001> @ty \f -> fix (f >=>)
17:02:18 <S11001001> lambdabot: yo
17:02:53 <S11001001> anyway how about that skyflash?
17:03:15 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
17:03:15 <lambdabot> Monad m => (b -> m b) -> b -> m c
17:03:49 <S11001001> or skyflash_
17:04:16 <monochrom> that is even better. fix (your_function >=>) initial
17:05:48 <Michae___> what's the time complexity of the default sort function? I'm having trouble finding this in the docs.
17:06:02 <monochrom> n * log n
17:07:48 <Peaker> lists as control structures (replacing loops) is nice, lists as data structures, quite terrible most of the time.   sort indicates the latter
17:09:34 <monochrom> perhaps I want to sort my control structure :)
17:10:53 <skyflash_> monochrom or S11001001:  fix (your_function >=>) initial, works like a charm.  Can't help but thinking I fell off the beaten path though.  I was expecting a standard Monad function to iterate over a function of that pattern.  Anyway, thanks!
17:12:15 <monochrom> @type void
17:12:16 <lambdabot> Functor f => f a -> f ()
17:12:40 <monochrom> @type undefined :: Void
17:12:41 <lambdabot> Not in scope: type constructor or class `Void'
17:19:44 * hackagebot z3 0.3.0 - Bindings for the Z3 Theorem Prover  http://hackage.haskell.org/package/z3-0.3.0 (IagoAbal)
17:34:27 <parcs> hello
18:02:59 <hpaste> “Anonymous Coward” pasted “testrunner” at http://hpaste.org/84623
18:03:11 <otters> so that's my TestRunner.hs
18:03:29 <otters> it's the main-is in my main test suite
18:04:06 <otters> and cabal-dev reports one failing test case
18:04:08 <otters> what's going on
18:06:14 <cschneid> This doesn't compile due to the difference between IO String and String. Can somebody point me to an example on how to work with strings that came from an IO source?
18:06:16 <cschneid> https://gist.github.com/cschneid/e3ffc325e08a1e1de378
18:06:26 <cschneid> ie, I want to pass them through to normal String functions
18:06:44 <sipa1024> you cannot
18:07:08 <sipa1024> well, you can apply normal String functions to them while inside the IO monad
18:07:11 <cschneid> I understand you can't directly. But I bet I can in a different way.
18:07:40 <cschneid> I'm new to working with this, and looking for a guide / example code for how to hide the IO part for a while to do the standard string functions like `lines`
18:09:02 <otters> oh I fixed it
18:09:12 <otters> is it possible to have thread-specific stdout?
18:10:36 <cschneid> ok, nice netsplit there. Back to my question: my goal is to read a file, then pass it through to a function that works on String.
18:10:49 <cschneid> for example, `Prelude.lines`
18:12:02 <pharaun> cschneid: do { a <- strio; let b = blah a } for ex
18:12:26 <pharaun> but you can lift and run pure code in the IO monad for the string stuff
18:12:44 <cschneid> pharaun: do you have a bit of example code you can share?
18:12:54 <cschneid> or I can gist up the let version, and you can show me a different way?
18:13:23 <pharaun> that would be helpful
18:13:35 <cschneid> pharaun: https://gist.github.com/cschneid/277f8a132adc93a4d54a
18:13:37 <cschneid> this does work
18:13:44 <cschneid> (with the help of all my surrounding code
18:13:54 <pharaun> what's wrong with this?
18:14:07 <cschneid> pharaun: well, you mentioned the lift approach
18:14:12 <cschneid> for learning purposes, I'd like to see it
18:14:24 <pharaun> and btw its probably just style, but i would try to reduce the indenting on the operationSolve :)
18:14:42 <cschneid> hah
18:14:43 <cschneid> ya
18:15:05 <cschneid> pharaun: also, what is the difference between `<-` and `let x =`
18:15:10 <cschneid> both are "assign a variable"
18:15:16 <pharaun> not really
18:15:18 <cschneid> but they behave different
18:15:22 <latro`a> let assigns; <- doesn't really
18:15:22 <pharaun> <- is binding
18:15:33 <cschneid> so what's <- really doing then
18:15:35 <pharaun> how much do you know about monad and etc ?
18:16:14 <cschneid> uhh, enough to be dangerous, but not enough to pull the words out :)
18:16:18 <latro`a> have you seen Maybe?
18:16:24 <cschneid> yes, used that a bit
18:16:31 <latro`a> > x <- Nothing; return x
18:16:35 <latro`a> er
18:16:40 <latro`a> > do x <- Nothing; return x
18:16:42 <lambdabot>   <hint>:1:13: parse error on input `;'
18:16:44 <lambdabot>   Nothing
18:16:51 <otters> how do you make the main thread exit when child threads encounter exceptions
18:17:05 <latro`a> the one that I didn't screw up should show you part of how <- isn't assignment
18:17:16 <latro`a> x <- Nothing can't "assign" because there's no value for x to be
18:17:28 <latro`a> instead what I wrote is:
18:17:36 <latro`a> Nothing >>= \x -> return x
18:18:38 <cschneid> latro`a: thanks. Not clicking yet, but steps forward.
18:18:48 <cschneid> I'll have to go dig up my copies of the various books I've got
18:19:51 <cschneid> original question: pharaun said there is a way to use `lift` rather than the let approach in my code (https://gist.github.com/cschneid/277f8a132adc93a4d54a)
18:19:53 <latro`a> I forget, are do blocks in Identity corecursive?
18:19:58 <cschneid> 1) does that make sense, and 2) what would it look like
18:20:38 <latro`a> not sure how lift helps there
18:20:49 <latro`a> but that can be shortened to
18:21:35 <latro`a> operationSolve x corpusFile = readCorpus corpusFile >>= putStrLn . head . lines
18:21:46 <latro`a> or without pointfree
18:21:58 <latro`a> operationSolve x corpusFile = readCorpus corpusFile >>= \corp -> putStrLn $ head $ lines corp
18:22:01 <cschneid> for now, I'm sticking w/ not-pointfree since it helps see where my args end up
18:22:15 <latro`a> in this particular case pointfree is nice because you're just passing up
18:22:25 <latro`a> apply lines, then head, then putStrLn
18:22:27 <pharaun> well that was a bit of misnomer, i was referring to "lifting" as lifting your pure code into the monadic code
18:22:55 <cschneid> pharaun: well, I ended up reading about lift the function instead :)
18:22:59 <cschneid> no problem
18:23:07 <sipa1024> :t liftM
18:23:13 <latro`a> you can give these separate names to the intermediate values, but you don't need to, since they're small changes
18:23:34 <latro`a> also, liftM wouldn't suffice here
18:23:51 <latro`a> since he needs an input and then an output action
18:24:20 <latro`a> btw, why Prelude.
18:24:23 <latro`a> cschneid,
18:24:30 <latro`a> why is your Prelude qualified
18:24:33 <cmears> Is there a Handle I can use as output that behaves like /dev/null ?
18:24:41 <cschneid> latro`a: I have bytestring pulled in
18:24:48 <cschneid> and that was quicker than qualifying what I'm using in bytestring
18:24:52 <latro`a> gotcha
18:25:08 <pharaun> ahh
18:25:31 <pharaun> cschneid: btw usually folks qualified their bytestring fwiw and i would do it as P imho
18:25:35 <pharaun> easier to read
18:26:03 <latro`a> people usually abbreviate, yeah, albeit not always to one letter
18:26:05 <cschneid> yeah, import Data.ByteString as BS, versus import qualified Data.ByteString as BS
18:26:16 <latro`a> import qualified Data.Map as Map
18:26:18 <latro`a> isn't uncommon
18:26:20 <cschneid> I assume the second one doesn't pollute top level namespace
18:28:18 <coppro> cmears: short answer: no.
18:28:35 <cschneid> latro`a: readCorpus corpusFile >>= P.putStrLn . P.head . P.lines can you help me figure out how that would look in a 2 line do block?
18:28:40 <cmears> coppro, thanks -- it's no problem just to open /dev/null anyway
18:28:56 <cschneid> do; corpus <- readCorpus corpusFile;   <<<<< no idea if that's right
18:28:59 <cschneid> for the first line
18:29:23 <cschneid> then P.putStrLn . P.head . P.lines corpus blows up on types
18:29:31 <latro`a> do corpus <- readCorpus corpusFile; P.putStrLn $ P.head $ P.lines corpus
18:30:31 <cschneid> latro`a: ahh, is a binding issue.
18:30:37 <cschneid> (err
18:30:50 <cschneid> not binding. Order of operations I suppose. What's the word I'm looking for
18:31:00 <latro`a> precedence, perhaps?
18:31:52 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
18:32:08 <latro`a> wut
18:32:09 <latro`a> oh
18:32:14 <latro`a> the :t liftM from earlier
18:33:26 <cschneid> latro`a: hah. what's up with the network
18:34:41 <pharaun> danged freenode
18:38:07 <pharaun> finally figured out the readerT monad
18:38:18 <pharaun> surprised it took me this long to need/use it
18:41:13 <Ondra> Hello, web (http://hackage.haskell.org/package/sample-frame-0.0.2) says sample-frame needs QuickCheck (≥1.0 & <3.0), so why does Cabal say:
18:41:13 <Ondra> rejecting: sample-frame-0.0.2/installed-2bd... (conflict:
18:41:13 <Ondra> QuickCheck==2.5/installed-a08..., sample-frame =>
18:41:13 <Ondra> QuickCheck==2.6/installed-280...) ? Does anybody know, please?
18:41:50 <carter> Ondra that might mean that there are version constraints that are disagreeing
18:42:04 <carter> try using cabal-dev to build the project
18:42:12 <carter> it'll take longer
18:42:17 <carter> but it will
18:42:46 <carter> enable you to try to build it  withouth dealing  with the constraints induced by the stuff you've already installed in the ghc pkg db
18:43:33 <no-n> I keep getting parse error on input `where' in ghci but not in haskell scripts. how do I enter functions with where correctly in ghci? (I am using set +m)
18:47:11 <elnadi> no-n: Have you tried using ':{' and ':}'?
18:47:20 <no-n> no. I don't know it.
18:47:45 <elnadi> It's for writing more than one line in ghci.
18:47:56 <elnadi> :{ to open and :} to close.
18:48:19 <Ralith> or you could just rewrite them in terms of let
18:48:33 <no-n> ah
18:48:47 <elnadi> Yes, I prefer let as well :P.
18:50:21 <no-n> :>
18:50:26 <latro`a> > (do x <- (+1); y <- (+2); return y) 3
18:50:27 <lambdabot>   5
18:50:35 <no-n> bbiab
18:51:00 <latro`a> @undo do x <- (+1); y <- (+2); return y
18:51:01 <lambdabot> (+ 1) >>= \ x -> (+ 2) >>= \ y -> return y
18:52:16 <latro`a> > (do x <- (+1); y <- (+2); return (x+y)) 3
18:58:25 <stevec> noob q: if I have a variable of data type T in a function, and I want to get at the constituent "parts" that it contains, say, in an if statement, how should I "expand" the variable?
18:58:40 <stevec> (apologies if I'm asking this in a confusing way)
18:59:27 <stevec> say I have type   data Car = Car Color Make Model
18:59:53 <stevec> and in a function I have a Car variable: c
19:00:27 <lambdabot>   9
19:00:30 <stevec> and I want to say "if (Car color make model) color == Red"
19:00:47 <stevec> (probably nonsensical...)
19:01:01 <stevec> (but hopefully I'm getting my point across)
19:01:09 <stevec> how do I unpack "c"?
19:01:28 <monochrom> two ways
19:01:43 <monochrom> 1. case c of Car Red _ _ -> ...
19:02:13 <monochrom> hmm, I erred, one way
19:02:25 <stevec> so, case is my only option?
19:02:37 <monochrom> in general, read up on pattern matching
19:02:40 <stevec> can't use if? (case is fine, just wondering)
19:02:46 <monochrom> no, not if
19:03:13 <elliott> you could also define an accessor function or make Car a record.
19:04:25 <stevec> monochrom: thanks, i'll try it
19:08:48 <cschneid> Can somebody help me understand why this function expects an IO a return value? https://gist.github.com/cschneid/0f18d9c5570539f02d8a
19:08:55 <cschneid> (new to all this, probably something simple...)
19:09:44 <otters> look at the type of (>>=)
19:09:45 <otters> :t (>>=)
19:09:56 <otters> hey, lambdabot, wtf
19:09:58 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:10:28 <cschneid> otters: so I'm obligated to return an IO (something)
19:10:32 <otters> yes
19:10:53 <cschneid> otters: ok, my program has a bit of IO work to fetch some inputs, work with them, then finally output a value.
19:11:03 <otters> cschneid: if getFrequencies is a pure function, you might be looking for fmap instead of (>>=)
19:11:03 <cschneid> I need to read a file, and calculate character frequency
19:11:18 <otters> fmap getFrequencies (readCorpus corpusFile), for example
19:11:24 <cschneid> ok.
19:11:29 <otters> which would turn an IO String into an IO (Map.Map String INt)
19:12:09 <applicative> fmap getFrequencies (readCorpus corpusFile ) was what I was going to write....
19:12:19 <pharaun> : (=<<)
19:12:22 <pharaun> :t (=<<)
19:12:24 <lambdabot> Monad m => (a -> m b) -> m a -> m b
19:12:32 <pharaun> seems to have recovered but still laggish
19:12:54 <applicative> or:  do { corpus <- readCorpus corpusFile ; let freqs = getFrequencies corpus ; ....}
19:12:55 <cschneid> cool. So now I can fmap stuff sometimes. :)
19:13:43 <sw2wolf> @instances fmap
19:13:45 <lambdabot> Couldn't find class `fmap'. Try @instances-importing
19:13:51 <cschneid> applicative: that didn't quite work
19:13:54 <applicative> @instance Functor
19:13:59 <sw2wolf> @instances Functor
19:14:02 <lambdabot> Maybe you meant: instances instances-importing
19:14:03 <lambdabot> ContT r m, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
19:14:19 <cschneid> applicative: gisted at bottom: https://gist.github.com/cschneid/0f18d9c5570539f02d8a
19:14:21 <applicative> hm, the one with let?
19:14:22 <cschneid> (the comment)
19:14:26 <cschneid> applicative: yeah
19:14:42 <black_joe> Hey guys, I'm new to Haskell and I ran into a problem. I have the type signature of :: (Eq a) => [(a,b)] -> a -> b for a function, and I need a catch-all for an empty list so that the recursion doesn't go on forever.
19:14:51 <black_joe> What could I have this function return that is within these constraints?
19:14:57 <black_joe> I jury-rigged it here: https://www.refheap.com/paste/12915
19:15:04 <applicative> cschneid: yeah it was retarded, the purpose was to do without fmap, so the second line need changing
19:15:21 <cschneid> ohh, heh
19:15:24 <applicative> let freqs = getFrequencies corpus
19:15:29 <latro`a> black_joe, you actually can't do that in general
19:15:34 <dario> @src lookup -- black_joe
19:15:35 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
19:15:40 <dario> meh
19:15:48 <sw2wolf> @hoogle (Eq a) => [(a,b)] -> a -> b
19:15:51 <latro`a> what you can do, however, is use a function like lookup, which can return Nothing
19:15:52 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
19:15:52 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
19:15:52 <lambdabot> Language.Haskell.TH.Syntax RecConE :: Name -> [FieldExp] -> Exp
19:15:57 <black_joe> So... What I would want to do is have it infinitely recurse, and hope that somebody doesn't misuse it?
19:16:02 <latro`a> nope
19:16:09 <applicative> cschneid: woops it turns out I was calling you retarded indirectly thinking i had to do with one of my typical errors! sorry
19:16:15 <latro`a> with a function like lookup you have a "failure" essentially if the value isn't found
19:16:20 <latro`a> which is why the return value is Maybe b, not b
19:16:27 <cschneid> applicative: no worries, no offense taken
19:16:38 <cschneid> this is the furthest I've really gotten with haskell, having fun :)
19:17:06 <black_joe> Oh, I kind of skipped over Maybe in my research. I'll go back and look at it.
19:17:34 <latro`a> but in general, if you don't restrict the types a and b any further, you can't define a total function [(a,b)] -> a -> b
19:18:04 <latro`a> you can define a partial one, like "bad_lookup [] _ = error "key not found""
19:18:48 <latro`a> but otherwise bad_lookup [] would be a function that can take any type and turn it into any other type, and there is no such function
19:19:11 <black_joe> Thanks. I was kind of wondering what Maybe was. This is exactly what I need.
19:19:22 <sw2wolf> :t Maybe
19:19:44 <sw2wolf> @type Maybe
19:21:44 <stevec> monochrom: the case / pattern match worked beautifully
19:33:59 * hackagebot implicit-params 0.1 - Named and unnamed implicit parameters with defaults.  http://hackage.haskell.org/package/implicit-params-0.1 (ShaneOBrien)
19:34:29 <lambdabot> Not in scope: data constructor `Maybe'
19:34:29 <lambdabot> Not in scope: data constructor `Maybe'
19:35:04 <sw2wolf> @hoogle Maybe
19:36:15 <lambdabot> Prelude data Maybe a
19:36:15 <lambdabot> Data.Maybe data Maybe a
19:36:15 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
19:50:03 <lewis1711> https://gist.github.com/lewis1711/5234602 simple implementation of wc to practice using IO, anything particularly unidiomatic here?
19:50:44 <glguy> lewis1711: You don't need to use $ nearly that much
19:51:19 <glguy> For example, this line should be:    let str = "" : [show nLines, show nWords, show nBytes, filename]
19:51:33 <lewis1711> ah yes. they originally had more arguments and I left them there
19:51:41 <lewis1711> good point
19:52:58 <Cale> If you prefer, you're also allowed to put multiple declarations into a single let
19:55:49 <lewis1711> so it has the same syntax as a let outside of the do syntax?
19:56:25 <Clint> lewis1711: you can also do filename <- fmap head getArgs
19:57:44 <sw2wolf> :t fmap head
19:58:06 <binroot> lambdabot: @pl \xs n -> take n xs ==> flip take
19:58:15 <binroot> \xs n -> take n xs ==> flip take
19:58:20 <binroot> @pl \xs n -> take n xs ==> flip take
19:58:31 <binroot> uhh, how do I use lambdabot? :\
19:58:51 <sw2wolf> lambdabot is sleeping now :)
19:58:58 <binroot> oh
20:00:47 <lewis1711> ok I spent a bit of time looking at the type sig of fmap and comparing it with map. that makes sense. somewhat
20:01:18 <lewis1711> so there is a functor that makes a list, which is expressed as [] ?
20:01:22 <External`> lewis1711: Why not use Text.Printf or something like that?
20:01:38 <lewis1711> didn't know it existed, will look it up
20:06:51 <lambdabot> flip flip (flip take) . ((==>) .) . flip take
20:06:54 <lambdabot> flip flip (flip take) . ((==>) .) . flip take
20:06:55 <lambdabot> Functor f => f [b] -> f b
20:11:47 <cschneid> This code works: https://gist.github.com/cschneid/5ac84c9815f61330dc93 but gives me Stack overflow errors when run on biggish input.  How would I force it to be strict on updating the Map, so I don't build a giant tree there that's not needed
20:16:13 <liyang> cschneid: use Data.Map.Strict or Data.EnumMap.Strict from enummapset-th.
20:16:33 <cschneid> liyang: yeah, I landed on Data.Map.Strict - but my ghc doesn't find it. Is it a cabal installed lib?
20:17:01 <binroot> Can every function be written in point-free notation?
20:17:17 <liyang> cschneid: it's not the map that's big. (Assuming your input is ASCII, you should only have <128 entries.) It looks like you have lots lazy thunks.
20:17:25 <cschneid> liyang: right.
20:17:38 <cschneid> liyang: new to haskell, so I know what to problem is, but not really how to run around fixing it
20:17:39 <liyang> cschneid: which version of ghc and containers?
20:17:50 <cschneid> liyang: cabal install containers found it, moving on :)
20:17:54 <ben22> anybody know how I can SORT an infinite list?
20:17:58 <cschneid> The Glorious Glasgow Haskell Compilation System, version 7.4.2
20:18:12 <shachaf> ben22: You have rather limited options.
20:18:21 <ben22> like this shachaf
20:18:31 <cschneid> liyang: so. how do I hunt down what's up with the code such that it doesn't work. Specifically, this happens: Stack space overflow: current size 8388608 bytes.
20:18:40 <ben22> how do I execute haskell void function code here?
20:18:50 <ben22> I want to execute this
20:18:51 <ben22> [ 2^(i-j) * 3^(j-k) * 5^k | i <- [0..], j <- [0..i], k <- [0..j] ]
20:18:53 <sproingie> binroot: not entirely.  flip for example can't be
20:19:00 <cschneid> > [ 2^(i-j) * 3^(j-k) * 5^k | i <- [0..], j <- [0..i], k <- [0..j] ]
20:19:01 <lambdabot>   [1,2,3,5,4,6,10,9,15,25,8,12,20,18,30,50,27,45,75,125,16,24,40,36,60,100,54...
20:19:01 <shachaf> What is "void function code"?
20:19:21 <ben22> cschneid, did it for me
20:19:33 <ben22> see how it's not sorte
20:19:38 <ben22> I want to sort this
20:19:49 <ben22> but I have no idea!!!
20:19:57 <sproingie> sort an infinite list?
20:20:00 <ben22> btw cschneid how did you do that?
20:20:05 <cschneid> ben22: the > up front
20:20:11 <ben22> > hi
20:20:13 <lambdabot>   Not in scope: `hi'
20:20:13 <lambdabot>  Perhaps you meant one of these:
20:20:13 <lambdabot>    `pi' (imported from ...
20:20:19 <ben22> oh ok thx!
20:20:50 <cschneid> liyang: so how do I go about hunting down where my leak is? Presumably this code has no reason to expand out, so I'm leaking thunks. But where, and then what's the fix
20:20:51 <ben22> sproingie, I just need it like this [1,2,3,4,5,6,8,9,15]
20:20:52 <liyang> cschneid: not a helpful reply, but in practice I use intuition. :<
20:20:58 <cschneid> :-/
20:21:10 <cschneid> I don't have that yet. All my ruby knowledge isn't much help here
20:21:15 <cmears> There is a package for testing assertions about thunks that might help
20:21:16 <binroot> sproingie: thanks
20:21:26 <ben22> so it is impossible to sort an infinite list right
20:21:33 <cmears> So you can say "here this should not be a thunk" and have it tested
20:21:50 <pharaun> oh nice
20:21:53 <cschneid> ben22: yes. the next value could always be the smallest. So you can't know its sorted until you look at every value
20:22:06 <cschneid> cmears: 1) awesome. 2) This seems like an easy problem. This isn't rocket-science code
20:22:18 <ben22> ok thanks guys. hugs and kisses! :)
20:22:41 <liyang> cschneid: if you want to keep using the lazy Data.Map, you'll want to make sure you're inserting the result rather than the unevalutated (getOrDefault key freqs + 1).
20:22:41 <sproingie> if you can prove your function has global minima, you can sort it in chunks, but no general purpose sort can prove that
20:22:44 <cschneid> odd that it's so easy to screw up memory allocations like that. I assume it's more my fault than the language, but, I don't know what bit of intuition I'm missing
20:22:52 <cschneid> liyang: how.
20:23:15 <cschneid> liyang: and strict map didn't fix it
20:23:19 <cmears> cschneid, the package is "ghc-heap-view" and GHC.AssertNF is the module
20:23:26 <ben22> > show "The cake is a lie"
20:23:28 <lambdabot>   "\"The cake is a lie\""
20:23:39 <liyang> cschneid: ! patterns or seq.
20:23:51 <liyang> (or rnf from deepseq.)
20:24:08 <cschneid> liyang: is that two or three suggestions (off to google how seq and such work)
20:24:11 <cschneid> and what do you mean patterns
20:24:28 <liyang> Yes reasoning about space usage should be simple, but unfortunately it's not. :<
20:24:55 <elliott> I'll take complex space usage reasoning for the advantages we get (like properly-composable algorithms)
20:25:11 <cschneid> elliott: which is why I'm trying to learn
20:25:21 <cschneid> very disheartening that my simple algorithm just doesn't work due to the laziness.
20:25:23 <elliott> that was more to liyang
20:25:36 <liyang> elliott: you know that I know that. :p
20:25:48 <elliott> I know you do, and I know you know I know you know you do!
20:25:53 <elliott> cschneid: I could point to very simple things that just don't work due to strictness
20:26:23 <cschneid> elliott: sure, and I'm fine learning the intuition parts. Can somebody just point me to what's wrong in my code for a start? https://gist.github.com/cschneid/5ac84c9815f61330dc93
20:26:30 <elliott> like (head . sort) being an inefficient way to find the minimum element (with an appropriate sort)
20:27:06 <elliott> cschneid: I would put a bang (!) on the freqs argument of getFrequencies'
20:27:10 <elliott> i.e. freqs -> !freqs
20:27:14 <elliott> looks like you're building up a big thunk there
20:27:29 <elliott> btw, you can make the process more mechanical with profiling, if you're having trouble building intuition
20:27:41 <elliott> the intuition here is: when you do (getFrequencies' (updateKey key freqs) rest), (updateKey key freqs) isn't evaluated
20:27:54 <elliott> you build up a big chain of promises to build a modified map when it's forced, but only force it at the very end
20:28:03 <cschneid> elliott: can you type out the line of what the bang'd version looks like
20:28:08 <cschneid> elliott: right, I figure it's that
20:28:12 <elliott> getFrequencies' !freqs (key:rest) = getFrequencies' (updateKey key freqs) rest
20:28:20 <elliott> you need to turn on the BangPatterns language extension; an alternative way to write it would be
20:28:25 <elliott> getFrequencies' freqs (key:rest) = freqs `seq` getFrequencies' (updateKey key freqs) rest
20:28:36 <elliott> this just forces freqs to be evaluated whenever (getFrequencies' (updateKey key freqs) rest) is
20:28:45 <cschneid> huh, ok
20:28:50 <elliott> so that as you recurse further, the updated Map keeps getting evaluated at each step
20:28:52 <cschneid> bangpatterns is just a nice way to say that
20:29:01 <elliott> yeah
20:29:10 <cschneid> ok, how do I do language extentions
20:29:18 <elliott> {-# LANGUAGE BangPatterns #-} at the top of your source file
20:29:47 <cschneid> that did indeed fix my problem
20:29:51 <elliott> I should say since it's a common misconception: (x `seq` x) is the same thing as x (in other words, if you define: force !x = x -- it doesn't do anything)... (x `seq` y) just means "when you evaluate y, also evaluate x"
20:30:00 <elliott> (so (x `seq` x) is "when you evaluate x, also evaluate x")
20:30:13 <cschneid> yeah, saw that when I searched up seq
20:30:24 <cschneid> that it's just a forced data connection between two items
20:30:35 <cschneid> and a connection between something and itself doesn't add anything
20:31:10 <cschneid> elliott: thanks a bunch for walking me through this. I'll probably go through the profiler route next time I run into this so I can learn that approach
20:31:42 <elliott> yeah, GHC has some very good profiling tools, though I admit I've never figured out how to read the heap profiling output
20:32:37 <cschneid> elliott: it's weird just how foreign a lot of this is. It's not the happy-path, it's the things that trip you up are so different
20:32:59 <cschneid> I can do function calling, and even easy monads right away. whatever. But this thunk leak totally stymied me.
20:33:20 <elliott> the evaluation model takes a lot of getting used to
20:33:22 <NemesisD> have any of you guys used shake for anything?
20:33:43 <monochrom> lazy evaluation is unfamiliar. so you start assuming, and assuming wrong things. but see my http://www.vex.net/~trebla/haskell/lazy.xhtml
20:34:13 <slack1256> shake the build system?
20:34:19 <NemesisD> slack1256: yes
20:36:10 <DarkLinkXXXX> I tried install this in eclipse, and then it asked me install some helper executables, which I agreed to. But in the log, I'm seeing a lot of "cabal.exe: permission denied". Do these programs need to be run as administrator?
20:36:23 <DarkLinkXXXX> http://eclipsefp.github.com/index.html
20:37:04 <slack1256> NemesisD: I had interest in it. but Neil said it was intended for big programs, so if you had programs that could be compiled with 'ghc --make' you should go with that.
20:37:57 <slack1256> I think did a blogpost of some rules used on a complex build system in his work. seemed quite succinct
20:38:06 <sproingie> DarkLinkXXXX: cabal should install things to ~/.cabal.  maybe you previously did a sudo cabal or something that made parts of ~/.cabal owned by root?
20:38:15 <NemesisD> slack1256: fair. this is not a big project. i just don't like copying around the same busted Makefile from project to project
20:38:44 <DarkLinkXXXX> sproingie, Nope. On windows, btw.
20:38:46 <sproingie> my problem with eclipsefp is some of the dependencies simply wouldn't install
20:39:01 <NemesisD> what i really need to do is figure out a faster way to get feedback from my tests. using cabal-dev to build and run tests takes about 4 seconds on this pretty small project
20:39:30 <sproingie> DarkLinkXXXX: ah, don't know.  i certainly didn't need escalation to cabal-install anything
20:39:45 <DanielDiaz> Hello, is there a standard library to work with polynomials?
20:39:48 <DarkLinkXXXX> Maybe it's using different paramters though. There was also an "Install for this user only" box that I unchecked. So it might trying to  install in C:\ProgramFiles somewhere.
20:40:25 <stevec> noob pattern match q: Let's say I have data Car = Car Color Make Model, and data Cars = Cars [Car] and I want to define an instance Show Cars in which, to start, I have a simple case statement like show cars = case cars of Cars(c:cs) -> show(c) ++ " " ++ show(Cars(cs))   ...
20:41:36 <shachaf> You should give up on the "function(argument)" syntax sooner rather than later -- it's "function argument" -- but OK.
20:42:07 <stevec> now I want a higher precedence match where I do something else, like Cars((Car Red _ _ c):cs) -> "It's Red!" ++ show(c) ++ " " ++ show(Cars(cs))   ...
20:42:16 <stevec> (sure, re: style)
20:42:52 <stevec> I guess I don't get how I do the pattern match *and* have a car ("c") variable I can use on the right side
20:43:02 <shachaf> Just the way you wrote it, I assume.
20:43:12 <latro`a> the way you wrote it works fine, yeah
20:43:27 <latro`a> except you have one too many _
20:43:30 <latro`a> but that's a minor error
20:44:07 <stevec> it's Car Color Make Model ...
20:44:30 <latro`a> you have Car Red _ _ c
20:44:37 <latro`a> this makes Car have 4 arguments, not 3
20:44:48 <stevec> I'm getting "should have 3 arguments, but has been given 4"
20:45:01 <shachaf> stevec: Ah, then it's what latro`a said.
20:45:01 <latro`a> you want Car Red _ c
20:45:17 <stevec> ah interesting...
20:45:22 <shachaf> A Car looks like this: Car someColour someMake someMoudel
20:45:26 <coppro> no
20:45:34 <coppro> what stevec wants is c@(Car Red _ _)
20:45:35 <shachaf> ('u's are for elliott)
20:45:46 <stevec> so intuitively it seems like then I'd be dropping the wildcard of Model...
20:45:47 <shachaf> Oh, that's also true.
20:45:55 <latro`a> I think he may have wanted that, but that will result in infinite recursion
20:45:55 * shachaf didn't look carefully enough at what was happening.
20:46:01 <latro`a> I think
20:46:02 <latro`a> oh wait, no
20:46:03 <latro`a> nvm
20:46:04 <stevec> (btw, dropping the last wildcard works...)
20:46:15 <slack1256> how well is doing the llvm backend on the nofib suite?
20:46:18 <latro`a> it does, but I think it does something different from what you wanted
20:46:22 <coppro> stevec: you want c to be the Car, right?
20:46:31 <stevec> coppro: yeah
20:46:34 <slack1256> how long until we welcome our new llvm overlords?
20:46:42 <coppro> yeah, then use  my snippet
20:46:51 <coppro> http://www.haskell.org/tutorial/patterns.html
20:47:17 <shachaf> stevec: Usually you wouldn't write this using explicit recursion, of course. But all in its good time.
20:48:00 <stevec> ah awesome, saw that in LYAHFGG but blew through it the first time
20:48:32 <stevec> well, i'm determined to be recusion-crazy for now
20:48:41 <stevec> in good lisp form ;)
20:49:35 <slack1256> ah that's good, I did the same thing about being recursion-crazy
20:51:17 <stevec> i'll optimize at some point
20:51:39 <shachaf> Recursion is low-level.
20:55:25 <DanielDiaz> Any recommendations about a library to work with polynomials?
20:58:40 <kfish> DanielDiaz, what do you want to do with polynomials?
21:00:47 <DanielDiaz> Well, I want a type to represent them and use them. And root finding would be awesome too.
21:04:25 <cmears> I guess the "polynomial" package is worth a look (:
21:05:42 <kfish> and dsp for http://hackage.haskell.org/packages/archive/dsp/0.2.1/doc/html/Polynomial-Roots.html
21:06:30 <DanielDiaz> cmears: Yes, I already saw it, but didn't see contributions for a while, when the library is not that complete. Not a big deal since I can contribute myself, but I wanted to have more opinions in hands.
21:09:21 <alang> @src abs
21:09:21 <lambdabot> Source not found. You type like i drive.
21:10:43 <DanielDiaz> kfish: but dsp represents polynomials by lists and it doesn't look orientated to provide a rich interface.
21:11:34 <DanielDiaz> Perhaps the polynomial package is the best point to start with.
21:15:59 <dmj> hey guys, anyone know what "primrec" means in the context of natural numbers?
21:18:21 <tertl3> recursive?
21:18:30 <luite> i'd  guess primitive recursive
21:18:44 <luite> which is a subset of recursive
21:28:29 <tgeeky> dmj: I remember reading and studying this paper: http://arxiv.org/pdf/1104.5311v1.pdf
21:29:16 <tgeeky> dmj: I don't want you to waste time deviating from whatever your professors text is, but this might help you put the natural numbers in perspective.
21:36:00 <dmj> tgeeky: So this Peano guy made the Natural Numbers a standard by his axioms?
21:37:21 <tgeeky> dmj: I think he's credited with sort of the simplest possible axioms, probably not the only ones
21:38:53 <dmj> Ok so primerec is "The natural recursive function generator for NaturalNumber"
21:39:12 <dmj> the way my numbers are implemented are recursived by default "two == succ one"
21:39:17 <dmj> recursive
21:39:19 <External`> You know. I was on a C# project and I really wanted to use TPL Dataflow to modularize my code. Problem was the primatives (know as blocks) run concurrently by default and always build queues. So here I have this great modularization tool but I can't get them to run in strict syncronization without the added overhead. This is the greatness of Lazy and Iteratee type things.
21:39:58 <dmj> External' C# and .NET 4 have a Lazy<T>
21:40:08 <External`> Boo
21:40:11 <dmj> There is also a Concurrent_Bag<T> you can wrap your List<T> with
21:40:19 <External`> Double Boo
21:40:35 <dmj> External': Why boo?
21:40:47 <DarkLinkXXXX> Umm, what works here doesn't seem to work in ghci. http://learnyouahaskell.com/starting-out#texas-ranges
21:41:10 <dmj> As with all things in .NET the a concurrent_bag is just an abstraction over a lock
21:41:16 <DarkLinkXXXX> Prelude> removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
21:41:16 <DarkLinkXXXX> <interactive>:2:23: parse error on input `='
21:42:22 <elliott> DarkLinkXXXX: you need "let" at the start
21:42:26 <tgeeky> DarkLinkXXXX: 'let'
21:42:27 <elliott> GHCi isn't the same as Haskell files
21:42:35 <DarkLinkXXXX> Ah. Okay.
21:42:41 <tgeeky> > let removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
21:42:42 <lambdabot>   not an expression: `let removeNonUppercase st = [ c | c <- st, c `elem` ['A...
21:43:07 <tgeeky> > let removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']] in removeNonUppercase "This is a test."
21:43:08 <sproingie> lambdabot is itself different
21:43:09 <lambdabot>   "T"
21:43:39 <sproingie> all the LYAH examples use ghci, what specifically isn't working?
21:44:04 <sproingie> oh already pasted nevermind.  i'm slow tonight
21:44:06 <DarkLinkXXXX> sproingie, Nevermind. Fixed.
21:44:19 <External`> dmj: Correct me if I'm wrong but Lazy<T> is lazy instantiation not lazy evaluation which is different -- no producer/consumer behaviour there.
21:44:35 <dmj> > let remNonUp st = [ c | c <- st, c `elem` ['A'..'Z']]
21:44:37 <lambdabot>   not an expression: `let remNonUp st = [ c | c <- st, c `elem` ['A'..'Z']]'
23:25:08 <SuperNoeMan> what is the best way to install haskell?
23:25:26 <SuperNoeMan> on mac?
23:27:38 <elliott> SuperNoeMan: you probably want the haskell platform
23:27:41 <elliott> @where haskell-platform
23:27:41 <lambdabot> I know nothing about haskell-platform.
23:27:42 <elliott> @where platform
23:27:42 <lambdabot> http://hackage.haskell.org/platform/
23:35:26 <circle> I want to install the "gloss" and "bmp" libraries for haskell
23:36:01 <circle> I've been told to type "cabal install gloss bmp" but I don't have cabal
23:36:10 <elliott> how did you install ghc?
23:36:14 <circle> pacman
23:36:36 <elliott> try installing the cabal-install package
23:36:42 <circle> alright, thank you friend
23:38:27 <circle> this seems to have worked
23:38:28 <circle> thank you
