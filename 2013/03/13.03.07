00:03:06 <srhb> Are there any of the cabal-dev alternatives that play nicely with haskell-mode?
00:04:34 <ivanm> srhb: someone was working on hsenv support IIRC
00:04:42 <ivanm> and there seems to be support for cabal-install sandboxes
00:05:26 <srhb> Well, that's a relief. :) I get sad when I can't launch ghci on whichever file and just have it work.
00:12:42 <johnw> @pl \x -> return (x + 1, x + 1)
00:12:43 <lambdabot> return . liftM2 (,) (1 +) (1 +)
00:14:06 <ski>   return . join (liftM2 (,)) (+ 1)
00:17:18 <ivanm> ski: which is still longer than the original :p
00:22:13 <beaky> hello
00:22:20 <beaky> how do I do a finite state machine in haskell?
00:23:29 <ski> if the FSM is statically known, you can make a bunch of mutually recursive functions
00:23:41 <beaky> ah
00:24:09 <beaky> so it is just like writing an ordinary recursive function, but with multiple go?
00:24:27 <ski> "multiple go" ?
00:24:51 <ski> btw, usually the functions would be tail-recursive, FSVO that
00:25:13 <frerich> I think he means "go" as in the common recursive helper function called "go".
00:25:18 <beaky> let f state args  = case state of { S1 -> go1 args; S2 -> go2 args; Halt -> return () }
00:25:21 <ski> oh
00:25:21 <beaky> ah yeha
00:25:31 * ski usually calls it `loop'
00:25:46 <beaky> I liek using f'
00:26:02 <beaky> but I found that haskell style is to use 'go' as the name for it :D
00:26:21 <ski> not that i'm aware
00:26:35 <ski> you can probably use whichever you think is neatest
00:27:13 <ivanm> I got into the habit of using "go" from dons' blog posts
00:27:30 <ivanm> but I typically only do it if I have a single worker function
00:27:49 <beaky> btw, can you rewrite every function that uses a 'go' in terms of a fold?
00:27:56 <beaky> (maybe a fold is the most elegant way to go)
00:27:59 <ivanm> don't think so
00:28:12 <beaky> a
00:28:18 <beaky> I wish I used folds more in my code
00:28:20 <ski> `fix f = go where go = f go' ?
00:28:35 <ivanm> heh
00:28:49 <ivanm> beaky: if you have only a simple recursive go then you can probably use a fold
00:29:02 <otters> if I want to add-or-modify a key in a Map in a lensy way, using at
00:29:06 <ivanm> but if you have anything more complicated (mutual recursion, different end-points, etc.) then you can't
00:29:06 <beaky> but maybe not if I have a state macine
00:29:11 <beaky> ah :(
00:29:28 <otters> mymap & at newkey %~ (fmap mutation) has no effect on the map
00:29:29 <otters> wat do
00:29:38 <otters> > fromList [(1, "hello")]
00:29:40 <lambdabot>   Not in scope: `fromList'
00:29:40 <lambdabot>  Perhaps you meant one of these:
00:29:40 <lambdabot>    `IM.fromList' ...
00:29:45 <otters> > M.fromList [(1, "hello")]
00:29:47 <lambdabot>   fromList [(1,"hello")]
00:30:02 <otters> > M.fromList [(1, "hello")] & at 2 %~ (fmap ("world" ++))
00:30:04 <lambdabot>   fromList [(1,"hello")]
00:30:06 <otters> see, what do I do
00:30:58 <beaky> I love folds
00:31:05 <beaky> and recursino
00:31:10 <supki> "world" ++ what?
00:31:18 <ski> > let fix (($ x) -> x) = x in fix (' ' :)
00:31:18 <supki> > M.fromList [(1, "hello")] & at 2 .~ Just "world"
00:31:20 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
00:31:20 <lambdabot>              w...
00:31:20 <lambdabot>   can't find file: L.hs
00:31:24 <edwardk> otters: [02:45] edwardk:	 then it is "at foo.anon [] null %~ (bar:)"
00:31:24 <edwardk> [02:46] edwardk:	 for index foo and element you want to cons/construct with bar
00:31:25 <otters> I thought At wanted a Monoid instance
00:31:28 <otters> so it would be mempty
00:31:42 <beaky> > let cycle xs = xs ++ xs in cycle [1..3]
00:31:45 <lambdabot>   [1,2,3,1,2,3]
00:31:48 <otters> > M.fromList [(1, "hello")] & at 2 . anon [] null %~ (fmap ("world" ++))
00:31:50 <beaky> :(
00:31:50 <edwardk> > M.fromList [(1,"hello")] & at 2 .~ Just "world"
00:31:50 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
00:31:52 <lambdabot>   fromList [(1,"hello"),(2,"world")]
00:31:57 <edwardk> > M.fromList [(1,"hello")] & at 2 ?~ "world"
00:31:57 <beaky> > let cycle xs = xs ++ cycle xs in cycle [1..3]
00:31:59 <lambdabot>   can't find file: L.hs
00:31:59 <lambdabot>   fromList [(1,"hello"),(2,"world")]
00:32:04 <companion_cube> :t at foo.anon [] null
00:32:06 <lambdabot> (Functor f, Indexable Word64 p, At m, IxValue m ~ [a], Index m ~ Word64) => p [a] (f [a]) -> m -> f m
00:32:07 <edwardk> ?~ can be used to set the target to Just
00:32:07 <lambdabot> Maybe you meant: . ? @ v
00:32:07 * hackagebot http-conduit 1.9.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.9.1 (MichaelSnoyman)
00:32:09 <ski> ivanm : not sure about mutual recursion
00:32:18 <otters> edwardk: right, but I want to modify an existing key if it exists
00:32:26 <edwardk> otters: hence the anon example
00:32:36 <edwardk> :t at 2 . anon [] null
00:32:37 <lambdabot> (Functor f, Num (Index m), Indexable (Index m) p, At m, IxValue m ~ [a]) => p [a] (f [a]) -> m -> f m
00:32:56 <ivanm> ski: well, for starters mutual recursion implies you have two "go" functions; and unless the distinction between them is trivial I don't think you can generally convert a mutual recursion into a fold over a list or something
00:33:00 <edwardk> :t M.empty & at 2 . anon [] null %~ ("otters":)
00:33:02 <lambdabot> (Num k, Ord k) => M.Map k [[Char]]
00:33:08 <edwardk> > M.empty & at 2 . anon [] null %~ ("otters":)
00:33:10 <lambdabot>   fromList [(2,["otters"])]
00:33:14 <otters> awesome
00:33:20 <companion_cube> ivanm: not when you have early exit, can you?
00:33:23 <edwardk> > M.fromList [(2,"edwardk")] & at 2 . anon [] null %~ ("otters":)
00:33:24 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
00:33:28 <ivanm> companion_cube: zigackly
00:33:30 <edwardk> > M.fromList [(2,["edwardk"])] & at 2 . anon [] null %~ ("otters":)
00:33:32 <lambdabot>   fromList [(2,["otters","edwardk"])]
00:33:55 <otters> lens amazes me
00:34:03 <otters> but I have no idea how I would hav earrived at that conclusion by myself
00:34:10 <companion_cube> remind my, the usual abstraction to iterate on containers without knowing their actuel implementation in haskell, is Traversable/Foldable, right?
00:34:25 <ivanm> companion_cube: yeah
00:34:32 <edwardk> non (or anon) is basically saying we'll assume for the moment that the container doesn't contain any values equal to the empty list, and to treat any empty lists as 'missing values' and delete them from the map
00:34:38 <edwardk> :t non []
00:34:39 <lambdabot> (Eq a, Functor f, Profunctor p) => p [a] (f [a]) -> p (Maybe [a]) (f (Maybe [a]))
00:35:10 <edwardk> that lies and claims there is an isomorphism from Maybe a to a    technically it is an isomorphism from Maybe (a except for []) to a
00:35:38 <edwardk> > M.fromList [(2,3)] & at 2 . non 0 +~ 2
00:35:40 <lambdabot>   fromList [(2,5)]
00:35:46 <edwardk> > M.fromList [(2,3)] & at 2 . non 0 -~ 3
00:35:48 <lambdabot>   fromList []
00:35:54 <ski> ivanm : well, i was taking for granted that we weren't talking about arbitrary mutual recursion (for a fold to make sense, there has to be some data structure present on which we could fold)
00:35:58 <edwardk> it is useful when you want to deal with nested maps
00:36:06 <ivanm> ski: *nod*
00:36:12 <edwardk> > M.fromList [(2,3)] & at 2 . non M.empty . at 2 . non 0 -~ 3
00:36:12 <otters> so my next puzzle
00:36:14 <lambdabot>   No instance for (GHC.Num.Num (Data.Map.Map k0 a0))
00:36:14 <lambdabot>    arising from a use of...
00:36:17 <edwardk> > M.fromList [] & at 2 . non M.empty . at 2 . non 0 -~ 3
00:36:19 <lambdabot>   fromList [(2,fromList [(2,-3)])]
00:36:24 <edwardk> > M.fromList [] & at 2 . non M.empty . at 2 . non 0 +~ 3
00:36:26 <lambdabot>   fromList [(2,fromList [(2,3)])]
00:36:44 <otters> is that I have some data structure Foo with a Data.Unique member, and it's somewhere inside a Map a [Foo]
00:36:47 <ski> so then i saw the question as whether there exists mutual recursions on lists which can be written using folds (on the list)
00:36:54 <otters> and I want to delete that specific value, wherever it may be
00:37:19 <ski> (or any other recursive data structure than lists, if you prefer)
00:37:22 <osa1> can anyone help me to understand this comment: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html?showComment=1338305803531&m=1#c5117471807774445845 function types in this commend don't look like valid to me
00:37:22 <edwardk> thats a bit messy
00:37:30 <otters> yeah
00:37:37 <beaky> @src cycle
00:37:37 <lambdabot> cycle [] = undefined
00:37:37 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
00:37:47 <augur> ski!
00:37:57 <ski> augur?
00:38:18 <edwardk> can't build a smarter container like a table or something?
00:38:34 <edwardk> @hackage tables
00:38:34 <lambdabot> http://hackage.haskell.org/package/tables
00:38:45 <ivanm> osa1: they should probably be Monad (f -> f a)
00:38:55 <edwardk> you could then implement that easily
00:39:12 <augur> ski: so im thinking, it might be useful in the ILP system to have unary predicates. that seems sensible enough. but since the aim is to have some sort of graph-walking model, we would have booleans in the graph
00:39:14 <ivanm> edwardk: since the link osa1 is referring to is quoting you, want to actually state what you meant? :p
00:39:19 <osa1> ivanm: can you give me the full type of return and bind ?
00:39:35 <osa1> ivanm: is Monad (f -> f a) a valid type ?
00:39:37 <augur> ski: then we can have two kinds of learnable things: relations of type D -> {D} for relations on D, and D -> Bool for predicates
00:39:40 <ski> > let zipWith f = go0 where go0 [] = \_ -> []; go0 (x:xs) = \ys -> go1 ys x xs; go1 [] = \_ _ -> []; go1 (y:ys) = \x xs -> (x,y) : go0 xs ys in zipWith (\a b -> [a,b]) "foo" "bar"
00:39:41 <ivanm> osa1: oh, I mis-read it
00:39:41 <lambdabot>   [('f','b'),('o','a'),('o','r')]
00:39:47 <edwardk> oh
00:39:51 <edwardk> my scheme monad trick
00:39:57 <ski> (is a simple way to mutual recur `zipWith')
00:40:19 <otters> oh fucking hell
00:40:36 <ivanm> osa1: you have some kind of Monad data type that's a dictionairy containing the return and >>= implementations
00:40:39 <edwardk> otters: ?
00:40:46 <ivanm> I think chrisdone did a larger blog post on the topic
00:40:52 <edwardk> osa1: that was Monad f -> f a
00:40:54 <osa1> ivanm: aha
00:41:07 <edwardk> osa1: the idea is to take your dictionaries and pass them around explicitly.
00:41:08 <osa1> edwardk: ok so Monad here is a data type and not a typeclass?
00:41:09 <ivanm> then again, the one I was thinking of is what's in that blog post :p
00:41:21 <edwardk> so Monad f is a data type for an explicitly reified dictionary
00:41:34 <augur> ski: then we can do things like walk the graph from entities in D to booleans. so something like has_daughter/1 would be something like has_daughter = is_female . children
00:41:48 <augur> ski: obviously we'd need some sort of disjunctive composition there.
00:42:15 <ski> augur : `Bool = {()}'
00:42:27 <augur> ski: but can we graph walk using that?
00:42:30 <edwardk> so what we can do in a language without typeclasses where we really want monads is explicitly transform each chunk of monadic code so that instead of bind working with the monad in question it takes a 'reader transformed' version of the monad, where the 'environment' of the ReaderT'd version of our moment is the dictionary for manipulating it =)
00:42:44 <augur> ski: for both positive and negative examples, i mean
00:42:45 <ski> augur : or rather, functions to `Bool' correspond to relations to `{()}'
00:43:11 <edwardk> in scheme i can then take this and encode a bunch of extra stuff in that dictionary, for other methods like get, put for state, mzero, mplus for monadplus, etc.
00:43:33 <augur> ski: i mean, that works for positive examples, right, but how would we do negative examples? i guess failure as negation?
00:43:52 <edwardk> and return :: a -> (Monad f -> f a)      is going to take the a and the dictionary Monad f, and rummage in the dictionary for the return method and call it with 'a'
00:43:54 <otters> @djinn [[m a]] -> m [a]
00:43:55 <lambdabot> Error: Undefined type []
00:43:58 <otters> rats
00:44:25 <ski> @type sequence . concat
00:44:27 <lambdabot> Monad m => [[m a]] -> m [a]
00:44:46 <osa1> edwardk: how do you define `Monad` type here ?
00:44:48 <edwardk> and (>>=) :: (Monad f -> f a) -> (a -> (Monad f -> f b)) -> Monad f -> f b    takes the two normal args to (>>=), but instead of working in f   is working in ReaderT (Monad f) f   effectively.
00:45:21 <ski> osa1 : `data Monad m = MonadDict {return :: forall a. a -> m a,bind :: forall a b. m a -> (a -> m b) -> m b}'
00:45:32 <edwardk> osa1: data Monad f = Monad { return' :: forall a. a -> f a, (>>=#) :: forall a b. f a -> (a -> f b) -> f b }
00:45:53 <edwardk> osa1: possibly with more stuff so it can have a Functor, etc.
00:45:57 <edwardk> but for now just that
00:46:13 <sopvop> edwardk: So, I'm building a rope to supply to trifecta parser, LineDirective strand works great.
00:46:15 <edwardk> then: return a (Monad ret _) = ret a
00:46:20 <osa1> great, thanks
00:46:25 <edwardk> sopvop: glad to hear =)
00:46:44 <edwardk> sopvop: i should clean up my c preprocessor some time
00:47:01 <edwardk> osa1: and you can construct a similar encoding for bind
00:47:14 <sopvop> How do I handle comments? Will anything break if I put empty bytestring strand with not null delta? Or it is better to newtype parser and reimplement TokenParser skipWhitespace?
00:47:19 <osa1> edwardk: thanks very much. I'm trying to wrap my head around it
00:47:51 <edwardk> osa1: it came up a few years back when i needed it for a book on monads in scheme that never came through
00:48:09 <edwardk> sopvop: you should be fine
00:48:16 <ivanm> edwardk: you were writing a book on monads in scheme? :o
00:48:38 <edwardk> ivanm: technically dan friedman wanted to write one, and i got roped in to figure out what they should look like
00:48:53 <ivanm> ahhh
00:48:57 <ivanm> as in just for a chapter?
00:49:03 <edwardk> no, it was the whole book
00:49:10 <`ramses> edwardk: did you ever reach a draft or so which is available somewhere?
00:49:12 <edwardk> his words, my code basically
00:49:13 <ivanm> how could you have an entire book on monads in scheme? :/
00:49:21 <edwardk> but it never did wind up fitting into the 'little schemer' format
00:49:58 <edwardk> `ramses: i have fragments of code. i have a version that fit dan's constraints and a version for plt scheme nee racket that used more features.
00:50:07 <edwardk> let me see what i can dig up for you
00:53:07 <edwardk> found an old version of the plt form. adding that to the repo
00:54:14 <edwardk> https://github.com/ekmett/scheme-monads shows the terrible version
00:54:31 <edwardk> https://github.com/ekmett/scheme-monads/tree/plt is less gut wrenching
00:54:58 <edwardk> ((do (x <- amb 1 2 3) (y <- amb 4 5) (return (* x y))) list-monad) => (4 5 8 10 12 15)
00:55:07 <`ramses> edwardk: nice, I'll have a look at it :)
00:55:22 <edwardk> the <- in there is pure kitsch though ;)
00:55:45 <snowylike> "avoid any use of advanced language features" <- does that include continuations?
00:55:57 <Hafydd> Heh.
00:56:35 <edwardk> the problem was he didn't want to use macros because they were only really introduced in the seasoned schemer, so we were only assuming the first 9 chapters of the little schemer
00:56:47 <edwardk> its hard to do much with that, since there is no tool support for programming in the large in there.
00:57:44 <edwardk> so the do sugar: https://github.com/ekmett/scheme-monads/blob/plt/monad.ss#L87 and currying macro https://github.com/ekmett/scheme-monads/blob/plt/curry.ss#L38 were a source of contention
00:58:31 <edwardk> i should make the plt branch the master and move the other to a side-branch
00:59:53 <edwardk> ok, i switched the branches
01:00:16 <edwardk> the plt branch is now master. the old master with more examples, worse names and modularity, etc. is dirty-schemer
01:02:08 * hackagebot uulib 0.9.15 - Haskell Utrecht Tools Library  http://hackage.haskell.org/package/uulib-0.9.15 (JeroenBransen)
01:02:33 <edwardk> `ramses: if you have any questions feel free to shoot me an email or an issue on the repo. i can try to remember enough scheme to resolve it ;)
01:03:26 <sopvop> edwardk: Does it hurt your feelings what I use Attoparsec to preparse bytestring to rope? :)
01:03:45 <edwardk> sopvop: nope. i've been meaning to add a non-rope based parser to parec
01:03:48 <edwardk> er parsec
01:03:55 <edwardk> er s/parsec/trifecta
01:04:22 <edwardk> the integrated cpp engine is for that same kind of purpose
01:04:42 <edwardk> i just never bothered to ship it
01:06:25 <snowylike> i wonder - monads for scheme seems like a great idea, making some things more natural, but why the restriction to the first 9 chapters of little schemer?
01:08:21 <edwardk> snowylike: because it was being used for a 4th such book
01:08:45 <snowylike> an early introduction to monads, so people don't develop weird habits?
01:09:07 <edwardk> snowylike: the problem is that the examples don't fit very well with the socratic dialog format. the macros are big and then you can build lots of succinct code.
01:09:22 <edwardk> but the upfront setup cost is high for that format
01:09:45 <edwardk> e.g. once you have all the machinery you can throw a list monad in: https://github.com/ekmett/scheme-monads/blob/master/list.ss
01:09:57 <edwardk> or a reader monad: https://github.com/ekmett/scheme-monads/blob/master/reader.ss#L1
01:10:14 <edwardk> and they are pretty lightweight
01:10:31 <ski> edwardk : hm, `.ss' ?
01:10:45 <edwardk> with the encoding of the book it was a bit odd: https://github.com/ekmett/scheme-monads/blob/dirty-schemer/reader.scm
01:11:21 <edwardk> ski: it was the default file extension for plt scheme
01:11:28 <Hafydd> .ᛋᛋ
01:11:39 <edwardk> http://download.plt-scheme.org/doc/html/drscheme/drscheme-files.html
01:12:13 <edwardk> i was using it explicitly to distinguish between stuff that was plt scheme specific and what was in the 'schemer' format.
01:12:19 <augur> ski: i think a multimodal logic with names is actually exactly what we need
01:12:23 <ski> hm, for some reason i was thinking `ss' was only the default for "system" PLT files
01:13:03 <edwardk> probably because it is mostly used on those files ;)
01:13:06 <ski> augur : with different kinds of modalities, or just different "dimensions" of the same kind ?
01:13:13 <augur> ski: dimensions
01:13:18 <augur> for each relation
01:13:24 <`ramses> edwardk: will do, thanks :)
01:14:02 <edwardk> snowylike: anyways the assumption was that readers wouldn't necessarily have understood the last chapter of little schemer
01:14:53 <augur> ski: so has_daughter = <child> <female>, ancestor = <child> \/ <child> <ancestor>
01:15:07 <augur> well, trailing with True, obviously :)
01:15:31 * ski . o O ( "MOLOG - a tool for non-classical logic programming" <http://www.irit.fr/ACTIVITES/EQ_ALG/Herzig/molog.html> )
01:15:47 <augur> inductive molog?
01:15:50 <augur> :)
01:16:54 <snowylike> edwardk: the "What is the value of all of this" chapter?
01:17:13 <edwardk> snowylike: yeah
01:17:46 <edwardk> snowylike: that was the chapter in which he kind of raced ahead and introduced a bunch of stuff. the y combinator, iirc, etc.
01:17:52 * ski . o O ( "A very compact database query language based on binary relations" by KragenSitaker at <http://canonical.org/~kragen/binary-relations.html> )
01:18:10 <edwardk> the rest of the book is pretty easily read even by a highschool kid
01:18:31 <snowylike> edwardk: yes, i think so. it's been quite some time since i've read it, though
01:18:38 <edwardk> snowylike: likewise =)
01:18:50 <edwardk> ski: have you been following what is going into analytics?
01:19:00 <snowylike> edwardk: but i suppose i'd get more out of reading it again than you would
01:19:23 <edwardk> given that i've mostly forgotten scheme, maybe not ;)
01:19:32 <augur> ski: im still not comfortable with this, because it feels like we're still going to have to do a lot of search
01:20:41 <edwardk> ski: datalogish haskell: https://github.com/analytics/analytics/blob/master/examples/Closure.hs
01:22:32 <ski> edwardk : i don't really like the datatype for variables
01:22:41 <edwardk> ski: me neither. in head that has changed
01:22:44 <edwardk> er
01:22:46 <edwardk> not head
01:22:51 <edwardk> but its going in in a branch slowly
01:22:51 <ski> tail ?
01:22:54 <edwardk> =)
01:22:55 <augur> ski: i guess we can limit search by starting with disjunctions of the facts, and then generalizing from those somehow
01:23:19 <edwardk> the datatypes for variables was a stopgap to get the dsl to work and it solved a lot of pain points but it made the types one step too magical
01:23:56 <edwardk> in the new dsl you need to use "rule $ \x y -> tc x y :- edge x y"
01:24:20 <edwardk> "rule $ \x y z -> tc x z :- tc x y <* edge y z"
01:24:37 <startling> not in HEAD but in edwardk's head
01:24:46 <augur> ski: the problem is, generalizations wont always work
01:24:47 <augur> hmm
01:24:56 <edwardk> startling: well, its the 'alternative-syntax' branch but its mostly not in the repo yet, just in stashes
01:25:03 <startling> hehe
01:25:19 <augur> ski: maybe the process should look like: generalize when possible, otherwise refine to some new formula
01:25:32 <ski> (hm, that presupposes `edge' is acyclic)
01:25:38 <edwardk> it has been turning out to be a big refactoring of the Data.Analytics.Datalog.* code and it isn't critical
01:25:46 <edwardk> ski: this is datalog. why would it?
01:26:03 <edwardk> you can put cycles in all you want
01:26:15 <augur> ski: i dont think that will work either tho, unless the refinement to a new formula is not a refinement of the existing formula, but a refinement to an alternative true formula
01:27:27 <ski> hm, no; if `edge' is cyclic, that would still count as `tc' being cyclic
01:27:35 <ski> (for some reason i thought it wouldn't)
01:28:26 <augur> ski: but some times i think we would want refinements of the existing formula? just to make disjunctions? i guess we could refine by other true formulas
01:30:56 <killy9999> how can I tell GHCi to perform some computation but don't display the result
01:30:57 <killy9999> ?
01:31:03 <edwardk> >>> toList $ evalState ?? Env 4 mempty [] $ naive $ test >> query (row (tc B Y))
01:31:03 <edwardk> [Edge B A (),Edge B B (),Edge B C ()]
01:31:12 <johnw> > 1 + 2 >> return ()
01:31:14 <lambdabot>   Could not deduce (GHC.Num.Num (m a0))
01:31:14 <lambdabot>    arising from the ambiguity check f...
01:31:25 <edwardk> pardon the messy toy evaluator =)
01:31:26 <johnw> > return (1 + 2) >> return ()
01:31:27 <lambdabot>   No instance for (GHC.Show.Show (m0 ()))
01:31:28 <lambdabot>    arising from a use of `M17659220...
01:31:28 * ski doesn't really follow augur's reasoning atm :/
01:31:39 <augur> ski: i wonder if we can use partial implicational knowledge to help. for instance suppose we have the hypothesis <has_daughter> = <parent> True
01:31:48 <startling> killy9999: whatever >> return () ?
01:32:04 <ski> edwardk : looks fine
01:32:06 <augur> ski: we'd know that this is true in all the true cases, but true in some false cases too. so we'd know that this is maybe partially correct?
01:32:27 <killy9999> startling: right, I knew this must be easy :)
01:33:11 <ski> killy9999 : you could define `ignore = fmap (const ())' ..
01:33:37 <ski> (or `done = return ()', if you prefer)
01:33:50 <edwardk> in the alternative syntax approach that simplifies quite a bit. because we no longer need as much to instantiate Env, the base tables use their TypeRep from Typeable as their identifier in the database and the query applicative doesn't need the 'row' shim to get rows rather than values because the omega-continuous-semiring-weighted datalog stuff is more explicit
01:34:04 <edwardk> :t void
01:34:06 <lambdabot> Functor f => f a -> f ()
01:34:09 <ski> augur : i was pondering whether we want our search to be monotonic
01:34:17 <edwardk> (in Control.Monad)
01:34:18 <augur> ski: in what sense
01:36:19 <ski> augur : such as every candidate at all times making the true evidence true; alternatively at all time making the false evidence false
01:36:47 <augur> ski: oh, yes i think thats probably desirably
01:37:01 <augur> itll cut down on search i think, since we rule out a bunch of stuff immediately
01:37:05 <ski> augur : or perhaps one could elect to only consider a subset of the evidence, and incorporating the rest of it one by one
01:37:33 <ski> augur : or perhaps partition the evidence into equiv. classes, and have separate hypotheses for them, then trying to merge
01:37:47 <augur> ski: whow would we partition into equiv classes?
01:38:13 <ski> i was thinking starting with the finest partition, then try to merge classes
01:38:30 <ski> (the starting evidence for each singleton class is perhaps itself ?)
01:38:39 <augur> ski: no but i mean, what criteria seperates examples?
01:39:01 <ski> separates ?
01:39:31 <augur> ski: yeah, how do you take a set of facts and partition it? what criteria do you just to say these two facts go in different buckets
01:39:44 <ski> each fact gets its own equiv. class, initially
01:39:49 <augur> ok
01:39:55 <augur> how would we merge then?
01:40:06 <ski> i'm not sure :)
01:40:32 <augur> btw i think thats basically what im describing as starting with just disjunctions of the facts
01:40:33 <ski> i think the Bratko chapter talked about monotonic search
01:40:44 <augur> and the merging is what i mean by generalization
01:40:51 <ski> ok
01:41:15 <augur> a theory for each partition is a disjunction of the theories, i think, no?
01:41:55 <augur> P(x) = x == a ; P(x) = x == b ; ... for each example a, b, ... is the same as P(x) = x == a \/ x == b \/ ...
01:46:40 <augur> ski: i think the generalization could take one of two forms: combining equivalence classes because each have the same form, or combining equivalence classes because they have related forms
01:46:53 <augur> the latter would be the means of introducing recursion
01:47:39 <augur> but this requires that we can efficiently take each fact and look at its truth-makers
01:48:41 <augur> ie given a fact x is-R-related-to y, we can look at the fact graph and collect up all the paths from x to y
01:49:23 <augur> in propositional form, and then for x' and y', do the same, and then see, aha, the proposition/edge P is in both set of facts
01:49:38 <augur> both sets of facts' edges
01:50:10 <augur> see thats another thing tho -- if we have logical operators, we dont get normal edges, we get weirdo multi edges
01:51:20 <augur> ski: i guess that just means that we'd have to consider not just edges, but subsets of edges (for conjunction), and something else -- alternatives? -- for disjunction
01:53:36 <augur> ski: i guess we could do that by using counterexamples -- some negative fact has edge E, just like some positive fact, so E alone cant be sufficient, so we search for other edges in common, or we search for edges that the negative facts lack
01:54:14 <augur> if its conjunction that we need to ultimately find, all the pos facts with have the extra edges, but some neg facts wont
01:54:31 <augur> if its disjunction, no neg facts will have any of the edges
01:54:49 <adas> is there a way to import a module from a specific folder?
01:55:45 <supki> ghc -ipath/to/module ...
01:56:11 <supki> actually not to module but to module directory
01:56:21 <adas> if i do a simple "import <module name>" it searches in the current directory and the standard directory.. but is there a way to ask ghc to get a module in a specified directory?
01:56:28 <adas> supki: oh okay.. thanks.. )
02:00:01 <supki> actually not to module directory but to some root path from which module names are resolved :)
02:01:21 <augur> ski: i guess in such cases, we can stage search by complexity -- search for only little bits at a time, and let the user decline further search
02:01:47 <dreixel_> does anyone know who "pejo" on the GHC trac is? namely, who wrote most of this page? http://hackage.haskell.org/trac/ghc/wiki/Supercompilation
02:03:28 <ski> augur : "logical operators" ?
02:03:36 <augur> ski: \/ and /\
02:03:45 <augur> and i guess also not
02:04:00 <augur> but we can push not down to predicates
02:05:08 <augur> or rather, down to False as an atomic prop
02:05:09 <aleator> Anyone have an example of a functor that is not a monad?
02:05:11 <ski> preflex: xseen pejo
02:05:11 <preflex>  pejo was last seen on freenode/#ghc 10 hours, 57 minutes and 59 seconds ago, saying: It wasn't ready?
02:05:29 <augur> so the atomic props are True, False, and whatever term props we have for the nominals
02:05:34 <hpaste> killy9999 pasted “IO boilerplate” at http://hpaste.org/83630
02:06:03 <ski> aleator : `CoYoneda IORef'
02:06:22 <killy9999> can someone tell me how to get rid of such IO boilerplate?
02:06:46 <augur> ski: actually maybe in the modal case we cant do that
02:06:47 <killy9999> I mean is there already a function for that or should I write my own?
02:07:01 <augur> ski: i think we have to have polarities on the modalities
02:07:22 <aleator> ski: Anything within the realm of haskell'98?
02:07:24 <augur> or maybe just general negation? hm.
02:07:46 <ski> killy9999 : `t3 <- liftM sum (replicateM 3 someIOComputation)' ?
02:08:38 <Hermit> killy9999: someIOComputation is the same operation all 3 times?
02:09:43 <killy9999> Hermit: yes
02:09:45 <killy9999> ski: thanks
02:10:23 <supki> aleator: Const
02:11:49 <ski> supki : for which parameter ?
02:12:05 <augur> ski: hm no, i think its ok if we have just False
02:12:23 <augur> because ~<R>True = <R>False
02:12:46 <augur> we just would need to also have polar nominals
02:13:05 <ski> shouldn't you use the dual modality there ?
02:13:15 <aleator> supki,ski: Thanks!
02:13:32 <augur> ski: sorry, yes :)
02:13:51 <supki> ski: uhm, I mean  newtype Const a b = Const { runConst :: a }
02:13:58 <supki> I guess for second?
02:14:26 <ski> supki : yes, so `Const a' is a functor for any `a' -- for which `a' did you want it to not be a monad ?
02:14:54 <augur> ski: so i think its ok if we push negation down to the atomics, which have polarity
02:16:04 <supki> ski: for any  a  except ()?
02:18:25 <Hermit> killy9999: just in case you then need different IOComputations, t3 <- fmap sum $ sequence [call1, call2, call3]
02:19:39 <supki> ski: I guess I should have said  Const a  instead of  Const =(
02:22:51 <ski>   instance Monad (Const Bool) where return _ = Const False; Const b >>= amb = Const (b || runConst (amb undefined))  -- hm, i suppose this doesn't work
02:23:53 <ski> `return a >>= amb' is `amb undefined', while `amb' might be `Const'
02:24:14 <HugoDaniel> hi
02:24:24 <HugoDaniel> how do i remove an item from a Sequence ?
02:24:55 <ski> supki : i still think you should specify a concrete `a' ..
02:25:15 <Hermit> HugoDaniel: Data.List.delete?
02:25:16 <ski> (or quantify, if you can)
02:26:00 <Hermit> HugoDaniel: oops, did you mean Data.Sequence?
02:26:06 <HugoDaniel> yes Data.Sequence :)
02:26:15 <HugoDaniel> im using filter :/
02:26:45 <HugoDaniel> but im sure there is a better way
02:27:51 <Hermit> HugoDaniel: funny, it doesn't seem to have a function for that. I guess your best bet here is to use breakl, but not sure, never used Sequence
02:28:40 <supki> ski: oh, I think I see that you mean
02:29:21 <supki> I parsed that question as "For which X you can write 'instance Functor X where ...' but not 'instance Monad X where ...'"
02:31:20 <HugoDaniel> Hermit: thanks, im currently using filter (\a -> a /= itemToDelete)
02:31:36 <ski> i parsed "a functor that is not a monad" as requiring either a concrete example, or a parametric one where every instance is a functor, and *no* instance is a monad (not just "not all")
02:33:02 <Hermit> HugoDaniel: yeah, what I meant by using breakl is roughly: (a, b) = breakl (== itemToDelete) ss   then   a >< drop b
02:33:10 <ski> (in case just not all instances are monads, you should be able to give one such concrete example, yes ?)
02:33:12 <HugoDaniel> oh cool
02:33:18 <Hermit> HugoDaniel: haven't tried it, but should work
02:40:17 <hpaste> Hermit pasted “Sequence delete  -- HugoDaniel” at http://hpaste.org/83631
02:41:42 <HugoDaniel> :D cool
02:41:52 <HugoDaniel> this is better than filter which is O(n)
02:47:10 * hackagebot hakyll 4.2.0.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.2.0.0 (JasperVanDerJeugt)
02:50:13 <jonkri> how can i fail in an attoparsec parser?
02:53:29 <augur> ski: night
03:01:12 <johnw> @pl \x y -> return x
03:01:13 <lambdabot> const . return
03:07:52 <hpaste> kallisti pasted “attoparsec question” at http://hpaste.org/83632
03:08:01 <kallisti> attoparsec-related question: http://hpaste.org/83632   ^^^^^
03:08:23 <kallisti> is there a way to rewrite this to be cleaner and roughly equally efficient
03:08:34 <kallisti> specifically the numeric parser
03:09:34 <kallisti> it would be nice if attoparsec has some builtin "take n bytes that satisfy the given condition" combinator
03:09:39 <kallisti> but I doubt that's a common case.
03:10:10 <kallisti> I could always use take 3 and then manually trigger errors.
03:11:47 <mikeplus64> jonkri: can't you use the fail function?
03:12:39 <jonkri> mikeplus64: oh, maybe :)
03:14:29 <bxc> i have a C function that returns a struct. (not a struct pointer). lots of the FFI documentation says this won't work; so do any of the higher level things like c2hs make it work or should I write a c-side wrapper?
03:15:51 <lemao> If there a way to traverse the haskell-src-exts Module contents without having to cases for all the different data types there? I am only interested in a few cases
03:17:15 <neutrino> bxc: ask dcoutts
03:17:54 <bxc> dcoutts: nudge
03:19:07 * bxc learning more than he wanted to about C/x86 calling conventions
03:26:39 <kqr> any particular reason tail on an empty list throws an exception?
03:27:03 <strebe> kqr: what would you have it do instead?
03:34:48 <tdammers> strebe: what tailSafe does maybe?
03:34:54 <tdammers> > tailSafe []
03:34:56 <lambdabot>   Not in scope: `tailSafe'
03:35:02 <tdammers> pity
03:35:38 <m3ga> @hoogle tailSafe
03:35:39 <lambdabot> No results found
03:36:40 <kqr> strebe, what tailsafe does, which is also what drop 1 does
03:37:03 <m3ga> @hoogle '[a] -> Maybe a'
03:37:04 <lambdabot> Parse error:
03:37:04 <lambdabot>   '[a] -> Maybe a'
03:37:04 <lambdabot>   ^
03:37:12 <m3ga> @hoogle [a] -> Maybe a
03:37:13 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
03:37:13 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
03:37:13 <lambdabot> Prelude head :: [a] -> a
03:37:48 <ldrndll> if you consider tail to be the opposite of head, its behaviour makes sense
03:49:11 <supki> ldrndll: opposite in what sense?
03:57:02 <tlaine> I think he means tail returning the complement of head (in the context of a given list)
03:57:19 * hackagebot ghc-mod 1.12.1 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.12.1 (KazuYamamoto)
03:57:40 <ldrndll> yeah, what tlaine just said
04:03:20 <ZFox> Does anyone here know of any good guides/tutorials/real-world examples for using a socket file in haskell?
04:05:47 <sopvop> socket file?
04:08:07 <ZFox> sopvop: Yes, file not listening on a port.. I.e tmux -S /path/to/your/session/socket.sock, mpd's non-tcp socket on disk. Lots of us here are running on linux/unix systems so there are unix sockets that are files.
04:08:13 <tdammers> file descriptor referencing a socket, I would guess
04:09:02 <sipa> tdammers: no, i assume a unix socket file entry
04:09:12 <ZFox> Hmm
04:09:20 <ZFox> sipa: Yea
04:09:33 <tdammers> mkay. carry on.
04:09:48 <sipa> tdammers: it's like a named fifo, but bidirectional
04:10:25 <ZFox> sipa: And can have multiple clients reading and writing to the socket as if it were tcp
04:10:32 <ZFox> tdammers: *
04:11:19 <supki> ZFox: you may want to look at libmpd sources then
04:11:24 <tdammers> yeah, I know what they are. I just haven't used them yet
04:11:32 <tdammers> not programming wise that is
04:11:39 <ZFox> supki: afaik, libmpd doesn't use the socket but only tsp
04:11:40 <ZFox> tcp *
04:11:53 <ZFox> Atleast the last time I checked
04:11:54 <sipa> ZFox: fifo's can also have multiple clients, afaik
04:12:49 <ZFox> sipa: iirc, fifo is just in/out you send input from multiple sources and the program reading from the fifo will read it as one session in tcp case
04:12:55 <ZFox> handler *
04:13:22 <supki> hmm
04:13:54 <ZFox> supki:             (Just <$> connectTo "" (UnixSocket host))
04:13:59 <ZFox> supki: I may have been wrong
04:14:33 <ZFox> host@('/':_) << Interesting pattern match there I must say. :D
04:14:34 <supki> yeah, that looks like what you've asked for
04:16:40 <ZFox> Looks like the Network.Socket is what I am after afterall.
04:17:11 * ZFox thought maybe that would be a lower level networking library but as it is, it's also what I need for this. :)
04:17:25 * ZFox still can't find any examples for using Unix Sockets for serving
04:17:33 * ZFox hopes it's more or less the same eitherway
04:21:48 <statusfailed> hm. what's the best way to parse a JSON string field with only two valid values "yes" and "no"?
04:22:06 <statusfailed> I can just look them up in a map but it seems like there should be a better way
04:24:20 <aristid> statusfailed: case x of "yes" -> True ; "no" -> False ?
04:25:27 <ZFox> > let yesno = (== "yes") in yesno "yes"
04:25:28 <lambdabot>   True
04:25:30 <ZFox> > let yesno = (== "yes") in yesno "no"
04:25:32 <lambdabot>   False
04:25:36 <ZFox> statusfailed: ^_^
04:25:51 <ZFox> Not quite type setting but oh well.
04:25:52 <Hafydd> "\u0079es" and "yes" both represent the same string in JSON.
04:25:57 <ZFox> aristid: _ -> error
04:26:24 <statusfailed> uh whoops
04:26:29 <statusfailed> that was only meant to be an example
04:27:04 <ZFox> Hafydd: "\u0079es" I assume is "y" so.. that should pattern match if parsed correctly.
04:27:07 <kallisti> anyone know where I can find a generic parsec/attoparsec URL parser on hackage?
04:27:45 <ZFox> kallisti: What are you parsing exactly? "protocol://user:pass@domain.tld/path/file.ext" ?
04:27:48 <ZFox> :)
04:28:00 <Hafydd> But statusfailed was askin about "parsing a JSON string", which seems to entail that it is encoded in JSON.
04:28:04 <ZFox> Obviously parts there are optional.
04:28:34 <Hafydd> But I suppose there is a lot of evidence now they were communicating inadequately, so let's see.
04:28:38 * ZFox wonders if statusfailed is using the JSON string raw or using some package to manage
04:28:40 <kallisti> ZFox: more or less. what I need it for is actually really siple so I could just write it by hand with some string mangling functions
04:28:44 <statusfailed> basically what i'm concerned with is parsing a value, say a string, and then verifying it further against some criteria
04:28:48 <kallisti> *simple
04:28:52 <statusfailed> i'm using aeson
04:28:56 <statusfailed> and I forgot to say that too :P
04:29:13 <Hafydd> So JSON actually has nothing to do with your problem?
04:29:36 <statusfailed> well aeson is a JSON parsing library
04:29:53 <Hafydd> Yes, and if you are using aeson, that should take care of every JSON-related concern.
04:30:04 <kallisti> statusfailed: make a type for you "yes" | "no" value and define a FromJSON / ToJSON instance for it
04:30:19 <kallisti> when the string is not "yes" or "no" it should fail and the whole JSON parse will fail
04:30:37 <ZFox> kallisti: That assumes quite type checking json
04:30:48 <kallisti> what do you mean?
04:31:11 <ZFox> "yes" "no" I guess limiting to those values in it's self is type checking
04:31:17 <ZFox> However... JSON has true/false
04:31:33 <kallisti> yes, but I assume he's parsing some specific JSON format in which "yes" and "no" are used, and no other string is valid
04:31:51 <statusfailed> no that was just an example
04:31:53 <kallisti> the type could also accomodate true or false
04:31:54 <ZFox> kallisti: He never mentioned if/how the json is created.
04:31:55 <kallisti> statusfailed: ah okay.
04:32:15 <ZFox> well if kinda hence example
04:32:26 <kallisti> well, that's the general idea. if you want aeson to enforce specific rules you want to make your own types with custom FromJSON instances
04:32:32 <statusfailed> sorry I should've formulated my question better before spewing my thoughts everywhere :P
04:32:42 <Philippa> ZFox: "verifying it against some criteria" would be your "type checking", anyway
04:32:53 <Philippa> statusfailed: it looked well-formulated to me
04:32:54 <kallisti> statusfailed: does solving your example problem help you with your more general problem?
04:33:20 <Philippa> kallisti: so long as you parse *then* verify, I would've thought
04:33:37 <statusfailed> kallisti: basically
04:33:48 <ZFox> Philippa: Well.. Expected/parsed to true/false, it's still typechecking to a point.
04:33:53 <ZFox> Just runtime not compile time.
04:34:00 <statusfailed> Right now I write a function maybe2Parser :: (a -> Maybe a) -> (a -> Parser a)
04:34:04 <kallisti> well, yes, that's essentially what aeson does. JSON is already a well-defined grammar. so aeson just parses that, then runs its "Parser" monad which is an overglorified error monad.
04:34:13 <statusfailed> and use that to lift my "verification" function into a parser
04:34:26 <statusfailed> but I feel like Ishould be able to use parser combinators somehow
04:36:53 <ZFox> statusfailed: I just made a parser that did such. Not long ago in fact.. I'm checking each character as it parses to be 0-9a-zA-Z using my isTChar function which simply checks that it's in the range. I could have used isAny or soemthing in parsec which may be a little cleaner but I don't think there would be any improvement.
04:37:29 <ZFox> Ensures a protocol is followed. [gric] and depending on which letter, a space and an argument.
04:37:46 <statusfailed> ZFox: makes it pretty awkward to check for strings, or convert to integers, etc. though
04:38:02 <ZFox> How so?
04:38:24 <statusfailed> ZFox: well, unless you wrote combinators for that?
04:38:41 <ZFox> statusfailed: Combinators?
04:39:53 <johnw> ZFox: usually that word means "functions that make other functions"
04:40:05 * ZFox is using showIntAtBase 62 .. to parse the 0-9a-zA-Z into an integer.
04:40:10 <johnw> but this is not the true meaning
04:40:15 <statusfailed> ZFox: like these for example: http://hackage.haskell.org/packages/archive/parsers/0.5/doc/html/Text-Parser-Combinators.html
04:40:36 <ZFox> Yea
04:40:43 <ZFox> In a way
04:41:15 * ZFox really doesn't like this line >> tokenToInt s = fst ((readInt 62 isTChar tCharToInt s) !! 0) -- readInt gives a to me useless [(a,_)] structure D:
04:42:07 <statusfailed> ZFox: Are you using a parsing library? What's this from?
04:42:15 <kallisti> ZFox: use pattern matching instead of fst and !!
04:42:15 <ZFox> statusfailed: numeral
04:42:37 <ZFox> kallisti: Yea I have but that still gets messy
04:42:46 <ZFox> One sec ima re-write a few things
04:42:51 <kallisti> ZFox: it's less messy I would say. you're just checking [(a,_)] or []
04:44:14 <cloudhead_> anyone know how to compile haskell statically with a libc other than glibc?
04:44:39 <hpaste> kallisti pasted “example of matching JSON values against specific criteria” at http://hpaste.org/83633
04:44:43 <kallisti> statusfailed: ^
04:44:57 <ZFox> kallisti: (\((a,_):_) -> a)
04:45:08 <ZFox> Pattern match w\o the [] case
04:45:17 <ZFox> :P
04:45:34 <kallisti> ZFox: :_(
04:45:46 <statusfailed> kallisti: that unfortunately doesn't cover the case where the record containing it needs to have just a regular Bool
04:46:13 <kallisti> statusfailed: true, but you can convert it later, in a different FromJSON if you want
04:46:19 <kallisti> the newtype just allows you to override aeson behavior
04:46:24 <kallisti> you can later unwrap it
04:46:26 <statusfailed> What i'd like is some way to write v .: "foo" >>= integer
04:46:34 <statusfailed> where integer :: Parser Integer
04:46:42 <kallisti> there you go
04:46:48 <statusfailed> and that would parse a field called "foo" as an integer (even if it's in quotes)
04:46:50 <kallisti> that's exactly what the code would look like. :P
04:46:58 <kallisti> well, roughly
04:47:02 <supki> you can write parsers directly, without FromJSON instances
04:47:03 <kallisti> (roughly exactly)
04:47:08 <kallisti> yeah
04:47:25 <arturaz> ohai. Is it a stupid idea to write an android NDK app with haskell?
04:48:38 <kallisti> statusfailed: you could just as easily have FlexibleBool :: Value -> Parser Bool  and then use v .: "foo" >>= flexibleBool
04:48:48 <kallisti> excuse me, flexibleBool :: Value -> Parser Bool
04:49:04 <jfischoff>  arturaz: ask JoeyA he's doing it
04:49:23 <jfischoff> arturaz: also there is haskell-mobile
04:49:34 <jfischoff> #haskell-mobile
04:49:44 <albel727> V:
04:50:03 <kallisti> statusfailed: this gives you even more flexibility. you could have integerInRange :: Integer -> Integer -> Value -> Parser Integer
04:50:05 * ZFox wonders how readInt might have more than one output...
04:50:10 <kallisti> statusfailed: which only matches integers within a specific range of values
04:50:19 <ZFox> Why is this thing a useless map??
04:50:51 <kallisti> ZFox: it's supposed to facilliate two things: a) handling of leftover data  b) ambiguous parses
04:50:54 <ZFox> type ReadS a = String -> [(a,String)] :|
04:51:06 <kallisti> ZFox: but in reality just accomplishes: c) being a really cumbersome interface for the most common usage
04:51:24 <ZFox> kallisti: "readInt" should have -> Integer!
04:51:33 <kallisti> no it should be Maybe Integer
04:51:35 <kallisti> or Either String Integer
04:51:43 <ZFox> Maybe Integer *
04:51:44 <ZFox> :)
04:52:07 <kallisti> @hackage spoon
04:52:07 <lambdabot> http://hackage.haskell.org/package/spoon
04:52:45 <ZFox> Heh
04:52:49 <kallisti> ZFox: there's always spoon
04:53:27 <kallisti> Prelude Control.Spoon> spoon (read "1") :: Maybe Int
04:53:28 <kallisti> Just 1
04:53:28 <ZFox> handlers = [ Handler $ \(_ :: ArithException)   -> return Nothing, ... ]
04:53:33 <ZFox> Interesting looking code O.o
04:53:51 <kallisti> technically it's unsafe, but I don't care because it gets rid of annoying partial functions in Prelude
04:54:00 <ZFox> Type on _
04:54:12 <ZFox> kallisti: haha
04:55:44 <ZFox>     | n0 < 0    = error "Numeric.showInt: can't show negative numbers" -- Lie in code, you can too... just mod by the base you already know :P
04:55:45 <supki> ZFox: that's fairly common idiom for specifying what kinds of exceptions handlers should handle
04:55:52 <ZFox> If only... you'd still need a length :/
04:55:54 <statusfailed> hey, spoon is cool
04:56:17 <ZFox> supki: I understand the code, just haven't seen such pattern matching
04:56:27 <kallisti> it requires an extension whose name escapes me.
04:56:45 <kallisti> ScopedTypeVariables
04:56:45 <johnw> view patterns?  pattern guards?
04:57:53 <ZFox> (str,s) <- lex r ; (n,"")  <- readPos str ; return (n,s)
04:57:58 <ZFox> -_-
04:58:06 <kallisti> yep
04:58:33 <ZFox> Why are we returning s???
04:58:39 <ZFox> Every time I've tested it... ALWAYS ""
04:58:45 <kallisti> have you tried
04:58:52 <ZFox> Hmm spaces :)
04:58:55 <kallisti> readInt blah blah "2 pizzas"
04:59:30 <ZFox> [(2," pizzas")]
04:59:36 <ZFox> Stupid array
04:59:53 <ZFox> A. It doesn't do the recursion against the spaces. B. It's a bloody list!
04:59:53 <kallisti> ZFox: well-document stupid array
04:59:55 <ZFox> s/array/list/
04:59:56 <kallisti> *documented
05:00:11 <ZFox> kallisti: I was getting to it
05:00:21 <ZFox> Good morning world.
05:02:12 * ZFox wishes it were Maybe Integer
05:02:34 <kallisti> ZFox: write a library that fixes it; publish to hackage; profit
05:04:03 <ZFox> To get snd part to the pair, you need spaces (or I guess anything that doesn't match the boolian functions). To get an empty list, you must give it null. To get multiple list elements, you have to join multiple commands!
05:04:14 <ZFox> (It can't come back with more than one afaict)
05:05:30 <paolino> hello, is there a precedence for (?) to use (.) to compose it? so I can write  x ? y . z ? t  in place of  (x ? y). (z ? t)
05:05:45 <kallisti> what is ?
05:05:48 <kallisti> *(?)
05:06:06 <paolino> an operator
05:06:14 <kallisti> paolino: operators in Haskell are user-defined, which includes user-defined precedences. So whether or not the precedence works the way you want it to depends on which (?) you're referring to
05:06:39 <paolino> it's an operator I define
05:07:28 <paolino> I want to know if I can give it a precedence so it works without parens when I compose with (.)
05:07:42 <kallisti> paolino: default operator precedence is 9. and I believe (.) is also level 9
05:08:09 <kallisti> paolino: is (?) by chance some kind of conditional? I may have already written the code for you. :>
05:08:35 <paolino> sure it's a function of at least 3 args
05:08:42 <kallisti> yep . is infixr 9 .
05:09:19 <kallisti> paolino: if you do: infixr 9 ?
05:09:37 <kallisti> it should work
05:10:11 <kallisti> also here's a library with that operator in it: http://hackage.haskell.org/packages/archive/cond/0.3/doc/html/Control-Conditional.html#g:4
05:10:27 <kallisti> though it's a rather trivial thing to implement by hand, so it may not be worth the dependency in your case.
05:11:03 <paolino> I need infixr 10 for (?)
05:11:48 <kallisti> paolino: you can't have it. sorry.
05:12:41 <paolino> so, why (.) is so high , that I cannot use it to compose other operator is the question :-)
05:13:39 <Philippa> because you haven't redefined its fixity
05:13:51 <paolino> oh
05:13:55 <Philippa> (/precedence, but the declaration starts "infix...")
05:14:44 <kallisti> if by "redefine" you mean "create a completely different symbol with a different fixity that refers to the same function"
05:15:01 <kallisti> then yes, that's an option
05:15:40 <beaky> hello
05:16:15 <paolino> Philippa, there should be a reason for it to be 9 and not 5
05:16:39 <Philippa> paolino: and there is one
05:17:05 <kallisti> paolino: the real problem is that there's a finite number of precedence levels. the reason for the current precedence level is because all the other ones are being used by other things that the Haskell Committee wanted to be lower precedence than .
05:17:06 <ZFox> Hello beaky
05:17:11 <Philippa> kallisti: huh, I thought you could just pop a module-local fixity decl in scope. It's not like the fixity decls themselves define the operator
05:18:22 <kallisti> Prelude> let infixr 8 . in "test"
05:18:22 <kallisti> <interactive>:3:14:
05:18:22 <kallisti>     The fixity declaration for `.' lacks an accompanying binding
05:18:22 <kallisti>       (The fixity declaration must be given where `.' is declared)
05:18:29 <kallisti> oh. I mean to abort that and paste insteas
05:18:31 <kallisti> oh well
05:19:10 <kallisti> Philippa: it's possible to allow in a language, Haskell just doesn't do it.
05:19:14 <paolino> kallisti, I cannot imagine all these different standard operators that must live together with (.) in the same expression, but I take it
05:20:19 <paolino> infixr  9 . means you cannot use . to compose anything but function applications
05:20:54 <RichyB> kallisti: IIRC Prolog solves this by giving all of the existing operators precedence numbers in like [7000, 8000..]
05:21:01 <kallisti> Philippa: locally rebound fixity declarations would be a fun extension.
05:21:08 <RichyB> Er
05:21:50 <RichyB> Solves the limited number of available precedence levels - by leaving a thousand separate precedence levels between every pair of built-in operators, so probably you can find room to slot yours in to the right place.
05:22:09 <Sgeo> Are there Haskell libraries for Windows for dealing with shared memory stuff?
05:22:34 <kallisti> RichyB: it's also possible to not use precedence levels at all and instead define precedences in relation to existing operators, forming an acyclic graph.
05:23:25 <RichyB> Maybe that's a better idea. How do you disambiguate the precedences of 2 different operators that are both defined relative to, say, (*)?
05:23:41 <RichyB> They can't necessarily know about each other because they may be in different packages by different maintainers.
05:23:56 <paolino> "infixr ? higher then ." can be a declaration
05:24:04 <kallisti> believe they would be considered equal precedence if they're both defined to be on the same side of the same operator.
05:25:45 <kallisti> or undefined precedence. one of those. I'm not sure myself.
05:26:02 <gynna> http://www.reddit.com/r/AdultDating18/comments/19t98u/ebony_pornstar_simone_staxxx/
05:27:17 <ZFox> gunna -_-
05:27:28 <ZFox> freenode ♥
05:28:20 <kallisti> RichyB: but yeah, if your precedence graph doesn't contain a path between 2 operators, their precedence in relation to each other is undefined and so you should get a parse error.
05:29:10 <kallisti> so there is no "absolute precedence hierarchy" in such a system. it's a forest of operators instead of a tree.
05:30:01 * sopvop is making parser for c-like language. Hates ?: operator.
05:30:37 <mauke> sopvop: why?
05:30:57 <sopvop> cant figure out how to parse it. :(
05:31:15 <mauke> like a right-associative incircumfix operator
05:31:48 <mauke> what's your parser written in?
05:31:57 <sopvop> erm, trifecta
05:32:08 <sopvop> it has optables like parsec
05:32:10 <mauke> oh, I don't know how that work
05:32:14 <mauke> what's an optable?
05:32:44 <sopvop> Parsec.Expression OperatorTable
05:32:57 <mauke> never used it
05:33:03 <sopvop> trifecta is pretty much parsec, with a twist.
05:33:56 <Philippa> paolino: It could be, but it shouldn't be in Haskell at this point. It's easy to forget the language is more than 20 years old with the associated historical weight behind it
05:34:25 <Sgeo> With a twist?
05:35:02 <kallisti> yes, it was the butler.
05:35:18 <mauke> wtf is this thing doing?
05:37:10 <mauke> sopvop: Infix (do { operator "?"; y <- expr; operator ":"; return (\x z -> CondExpr x y z)}) AssocRight
05:37:13 <mauke> 100% untested
05:39:59 <hiptobecubic> My joke ended up in the wrong room :(   How unfortunate.
05:40:10 <hiptobecubic> Granted, it was not a good joke.
05:43:12 <kallisti> my hobby: abusing the fact that Data.ByteString.Char8 exists
05:43:49 <Sgeo> @hoogle WaitForSingleObject
05:43:49 <lambdabot> No results found
05:44:09 <Sgeo> :(
05:44:26 <Hafydd> That sounds like something from Java.
05:44:40 <Sgeo> It's something from the Win32 API I think
05:44:50 <frerich> Yep.
05:44:51 <sopvop> mauke: I'll try it. thanks
05:44:57 <Hafydd> Oh yes, they also embrace the "long names are good" philosophy.
05:45:22 <Sgeo> I guess I should learn how Win32 mapped files work before trying to pretend to be one
05:45:30 <Hafydd> Also known as "LongNamesAreGood"
05:47:10 <sopvop> the language makes distinction between expression, relation expression and logical expression. Cant use same table or will have to check correctness in typecheck :(
05:47:44 <sopvop> the closed source compiler errors on parsing if not a relation/logic expression on left of ?
05:48:55 <Sgeo> @hoogle mapViewOfFile
05:48:55 <lambdabot> No results found
05:49:00 <Sgeo> @hayoo mapViewOfFile
05:49:00 <lambdabot> Unknown command, try @list
05:49:58 <alshain> @pl f x y = f (g x) (h y)
05:49:58 <lambdabot> f = fix (flip flip h . ((.) .) . (. g))
05:50:19 <alshain> @pl f x y = k (g x) (h y)
05:50:20 <lambdabot> f = (. h) . k . g
05:50:46 <Sgeo> Maybe Haskell isn't the best language for this task...
05:51:03 <kallisti> Sgeo: of course it is!
05:51:34 <Sgeo> Its wrapping for the Win32 API is rather incomplete
05:51:44 <Sgeo> I think I need to call CreateMutex at some point, and I don't see it
05:53:37 <ZFox> Anyone here who understands the STM/TVar mind helping me create a little program? http://ix.io/4DT+4DU+4DV+4DW+4DX/
05:53:51 <alshain> @pl f x y = k (f x) (f y)
05:53:52 <lambdabot> f = fix (flip =<< (((.) . k) .))
05:53:58 * ZFox is very unsure where to start but I know that TVar is what I'm after :)
05:54:06 <alshain> 00:00:44 #warez-bb: |*Kyle123 > yo GhostShot mrmcpowned you around?
05:54:45 <Hafydd> à² _à² 
05:55:23 <alshain> 00:00:44 #warez-bb: |*Kyle123 > yo GhostShot mrmcpowned you around?
05:56:12 <ZFox> alshain: You trying to accomplish something?
05:56:35 <fryguybob> ZFox: What are you trying to do?  I can't tell from the code.
05:57:57 <ZFox> fryguybob: To be exact.. A token server, intended to be listening on a UnixSocket however.. Right now I am trying to keep a Map of these tokens using their int value as the key and their expire date as their value (I'm going to have more information there than just the date, but it was just quick and easy)
05:58:10 <alshain> ZFox: just experimenting :)
05:58:13 <ZFox> I.e. purpose/usable for.
05:58:26 <ZFox> Generated by user n etc
05:58:49 <Hafydd> alshain: I recommend experimenting somewhere else.
05:59:00 <fryguybob> ZFox: So you want atomic insertions into this map?
05:59:02 <alshain> Hafydd: oh that... I accidentally hit Right mouse button, sorry, autopaste
05:59:06 <alshain> didn't even notice
05:59:19 <mauke> putty user detected
05:59:21 <alshain> Hafydd: I was experimenting with @pl above
05:59:25 <Hafydd> I see.
05:59:55 <Sgeo> Is it easy to use the Haskell FFI to use Win32 API stuff?
06:00:15 <ZFox> fryguybob: >> Token server to manage different tokens (62^16 possible tokens) for different things such as.. Registration program for a shared shell that is invite only.
06:01:20 <ZFox> In case of (however rare) that a token gets duplicated, also need to filter that to regenerate a new random Integer, or apply an offset and mod to the 62^16 if need be)
06:01:38 <Sgeo> Huh, looks easy to at least get the c_ version, but not so easy to wrap it to be Haskell-y
06:02:17 <ZFox> fryguybob: I guess atomic insertions yea
06:02:56 <Leftmost> Say I have a Foldable Num implemented using foldMap and use `Foldable.foldl (+) 0 foo'. How is it that foldl constructs a Num -> Monoid m function to give to foldMap?
06:03:25 <fryguybob> ZFox: Ok.  As you have it now if you know what manipulations you want to do on the map that need to be done atomically, make that some function f then do atomically $ modifyTVar f.
06:04:07 <ZFox> fryguybob: Problem -> Lack of STM/TVar exp
06:04:58 <fryguybob> ZFox: Right, with just one top level TVar there isn't much too it.  The  f  I'm describing doesn't involve STM.
06:05:56 <ZFox> fryguybob: Mind giving an example for say. adding?
06:06:13 <fryguybob> ZFox:  atomically $ modifyTVar (+1) t
06:06:58 <ZFox> Also, genToken -> (Integer, DateTime) I will change this to (Integer, Token) where Token will have more information about the entry.
06:07:20 <fryguybob> Just having a single top-level TVar doesn't get you much though.  You would be better off using atomicModifyIORef or whatever it is called.
06:07:26 <ZFox> fryguybob: Not what I meant by addming but I'm just gonna have a look at this more.
06:07:47 <fryguybob> ZFox: Adding to the map?
06:08:13 <ZFox> Yea
06:08:49 <ZFox> fryguybob: This is going to be between threads (hs lightweight threads atleast)
06:08:56 <fryguybob> ZFox:  atomically $ modifyTVar (M.insert k v) t
06:08:58 <Saizan> Leftmost: "foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z" -- from the source of Foldable
06:10:12 <fryguybob> ZFox: If you want multiple threads to be able to mutate disjoint parts of the map concurrently you will want a more complicated structure where the map has TVars internally.
06:10:55 <ZFox> (k, v) <- genToken; atomically $ modifyTVar (M.insert k v) t
06:11:27 <ZFox> fryguybob: How so?
06:11:44 <ZFox> You suggesting a tvar list of tvar?
06:12:25 <ZFox> TVar [TVar (Map Integer Token)] ?
06:13:07 <fryguybob> ZFox: Something like that might work, there are existing examples like btree-concurrent.
06:13:13 <Leftmost> Hmm. That's beyond my ken. I'll keep reading.
06:13:35 <ZFox> fryguybob: Hmm
06:14:02 <fryguybob> That packages does a bit more then you probably want.
06:14:24 <ZFox> fryguybob: If you don't mind and have the time, could you write up something quickly that would do what I'm after?
06:14:28 <ZFox> Hmm
06:15:48 <Saizan> Leftmost: it's basically composing together the applications of the step function f to each of the elements inside t, and applying that to z
06:16:08 <Saizan> Leftmost: s/that/that composition/
06:16:09 <fryguybob> ZFox: Unfortunately I don't have time.  But STM really isn't hard.  First decide what you need to be atomic conceptually (note this will always involve some thread mutating while others might just read).
06:16:42 <ZFox> So beware of race conditions
06:16:52 <ZFox> ?
06:17:07 <fryguybob> ZFox: No, the point is you don't have to be aware of race conditions.  That's what STM is taking care of.
06:17:36 * ZFox unfortunately doesn't have the skills D: Kinda neither time too Hehe 0117 and I have to be awake and ready for school in 6hrs :|
06:17:42 <koltar> is there a way to change ghci's default floating-point output format?
06:19:24 <fryguybob> ZFox: btree-concurrent has an example that might be useful to you if you look at the source for Data.BTree.HashTable.STM.
06:19:40 <ZFox> Oh boy
06:20:30 <fryguybob> http://hackage.haskell.org/packages/archive/btree-concurrent/0.1.5/doc/html/src/Data-BTree-HashTable-STM.html#HashTableSTM
06:20:43 <Saizan> koltar: nope, unless you are ok with using a newtype of Double, that way you could give your own instance of Show, which is what ghci uses
06:20:50 * ZFox is really too tired....
06:20:54 <crl> @set uncap = concat . map (\(x:xs)->x:(map toLower xs)) .  Data.List.Split.split (keepDelimsR $ oneOf ".!?\n")
06:20:58 <lambdabot>  Defined.
06:21:05 <ZFox> fryguybob: Thanks but I am barly keeping my eyes opened as it is...
06:21:15 <Saizan> Leftmost: btw for (+) you probably want foldl'
06:21:30 <koltar> Saizan: i was afraid of that, thanks
06:21:36 <ZFox> Good night fryguybob, thanks again. Sorry, but I have to get up in not too long and I've not been sleeping properally for...... many months. :|
06:21:38 <samm> what unit tests do you guys usually use, if any?
06:21:41 <fryguybob> ZFox: If you look at the data declaration there you see there are several places with TVar's.  Then look at the insert funciton.  it is modifying multiple fields and doesn't have to do any sort of explicit synchronization, but due to STM it will all be atomic.
06:21:49 <fryguybob> ZFox: Good night!
06:21:56 * ZFox hopes so
06:21:59 <jfischoff> samm: HUnit with test-framework
06:22:07 <crl> > uncap "TEST.\nCAPLOCKS.\nFOO!"
06:22:10 <lambdabot>   "Test.\nCaplocks.\nFoo!*Exception: <local>:10:23-49: Non-exhaustive pattern...
06:22:10 <jfischoff> samm: although the cool kids are using doctest
06:22:15 <ZFox> fryguybob: Good night to you sir, or good day or evening or... whichever. Cya
06:22:45 * ZFox ctrl-a d M-S-q
06:22:46 <crl> @set uncap' = concat . map (\~(x:xs)->x:(map toLower xs)) .  Data.List.Split.split (keepDelimsR $ oneOf ".!?\n")
06:22:46 <lambdabot>   Parse error: ->
06:22:55 <supki> samm: hspec/doctest
06:23:00 <Leftmost> Saizan, still just reading through Learn You, trying to understand what's going on.
06:23:20 <jfischoff> I plan on using doc test in the future more
06:23:24 <Leftmost> Thanks for your help, though.
06:27:57 <samm> lets see hunt beat a grappler before we match him with jds
06:28:37 <samm> wrong window
06:29:37 <xenon`> hello. is GTK the most usable GUI library currently available for haskell?
06:29:52 <xenon`> is it usable for production?
06:29:58 <fryguybob> xenon`: Some say it is.
06:31:00 <x7a1c0b> quick question: I have a Data Constructor that takes 2 Integers, but i would like to restrict one of them, so that every value except 0 is accepted
06:31:04 <x7a1c0b> is that possible?
06:31:10 <mauke> not directly
06:31:22 <mauke> you'd have to use a "smart constructor" a.k.a. a function
06:31:25 <Hermit> xenon`: have you tried wxWidgets?
06:32:13 <crl> quick question on lazy pattern matching:
06:32:16 <crl> > (\y ~(x:xs) -> y:x:xs ) 'a' "foo"
06:32:18 <lambdabot>   "afoo"
06:32:19 <crl> > (\~(x:xs) -> x:xs ) "foo"
06:32:21 <lambdabot>   <hint>:1:11: parse error on input `->'
06:32:25 <crl> why  ^
06:32:56 <mauke> crl: \ ~
06:33:03 <crl> k
06:33:14 <xenon`> Hermit I h aven't tried either yet, just weighing my options. do you prefer wxWidgets on haskell?:
06:33:31 <mauke> crl: \~ is parsed as a custom operator
06:33:43 <crl> @set uncap' = concat . map (\ ~(x:xs)->x:(map toLower xs)) .  Data.List.Split.split (keepDelimsR $ oneOf ".!?\n")
06:33:46 <lambdabot>  Defined.
06:33:55 <crl> > uncap' "TEST.\nCAPLOCKS.\nFOO!"
06:33:58 <lambdabot>   "Test.\nCaplocks.\nFoo!*Exception: <local>:11:24-52: Irrefutable pattern fa...
06:34:02 <mauke> > (\~(x:xs) + x:xs)
06:34:04 <lambdabot>   Not in scope: `\~'
06:34:04 <lambdabot>  Perhaps you meant one of these:
06:34:04 <lambdabot>    `\\' (imported from ...
06:34:13 <mauke> as this error message demonstrates
06:34:15 <fryguybob> > let a \~ b = 42 in 1 \~ 2
06:34:17 <lambdabot>   42
06:34:25 <Hermit> xenon`: more like I've only used wxWidgets on haskell so far. They seem good enough, and it's more portable than GTK iirc (should double check this)
06:35:39 <Hermit> xenon`: I'd say both are stable and mature enough for most projects
06:35:52 <Hermit> xenon`: so, grab a tutorial, and see what code do you like the most
06:36:29 <quicksilver> wxwidgets has better mac support than gtk
06:36:38 <quicksilver> they both work fine on windows and linux, I believe
06:36:45 <quicksilver> all GUI toolkits are a pain to compile on windows though.
06:37:38 <crl> @src (\~)
06:37:38 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
06:38:09 <Hermit> xenon`: wxwidgets looks native on OSX, while GTK doesn't. For the other platforms is the same
06:38:51 <crl> @hoogle (\~)
06:38:51 <lambdabot> No results found
06:39:22 <crl> > let a \~ b = 42 in 1 \~ 1
06:39:24 <lambdabot>   42
06:40:07 <fryguybob> crl: The let is defining that operator.
06:41:37 <crl> > let a \~ b = 42 in 1 \~ (1,1)
06:41:39 <lambdabot>   42
06:43:41 <xenon`> Hermit I will give both a try, thanks
06:44:14 <Hermit> xenon`: if you aim for linux and windows, both look native
06:44:22 <Hermit> so, flip a coin
06:45:01 <tdammers> what does "native" even mean on linux?
06:45:10 <tdammers> gtk? qt?
06:49:53 <Hafydd> 640*480 VGA terminal?
06:50:09 <tdammers> teletype?
06:50:25 <Hermit> tdammers: motif
06:50:30 <Hermit> haha
06:59:13 <koltar> huh, never knew lambdabot had a sense of humor
06:59:50 * koltar has just discovered hlint, and it is wonderful
07:04:09 <Kinnison> hlint is great.  I have it tied into emacs' flymake mode
07:04:43 <Entroacceptor> is it better, worse or not overlapping than ghc-mod?
07:05:33 <geekosaur> hlint is a style checker, not a type checker
07:05:53 <koltar> looks like ghc-mod integrates flymake/ghc/hlint
07:06:31 <Kinnison> koltar: oooh, I shall have to play with that
07:10:56 <koltar> Kinnison: on my machine, `apt-get install ghc-mod' Just Works
07:11:08 <koltar> flymake and all
07:11:37 <koltar> Entroacceptor: thanks for bringing ghc-mod to my attention
07:11:54 <Entroacceptor> you're welcome
07:12:24 * hackagebot QuickCheck 2.6 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.6 (NickSmallbone)
07:13:09 * Kinnison might be able to undo his immensely messy flymake hack in that case
07:13:12 <Kinnison> that'd make me very happy
07:17:24 * hackagebot data-default 0.5.1 - A class for types with a default value  http://hackage.haskell.org/package/data-default-0.5.1 (LukasMai)
07:18:58 <kallisti> is there a withoutMVar somewhere?
07:19:19 <kallisti> I'm using an MVar as a lock but I'm sort of reversing the way you would normally use it.
07:19:24 <mauke> no, but there's an Acme.Don't
07:19:47 <kallisti> it's an MVar ThreadID where the thread currently locking thread "deposits" its ThreadId for the duration
07:20:05 <mauke> :t withMVar
07:20:06 <Kinnison> Entroacceptor: ghc-mod seems to save my haskell every time to run flymake
07:20:06 <lambdabot> Not in scope: `withMVar'
07:20:09 <kallisti> the ThreadID can then be used to figure out who's to blame for unnecessary locks
07:20:21 <Kinnison> Entroacceptor: which is annoying (but not insurmountably so) -- where my hack saved a temp file out and ran against that
07:20:57 <Entroacceptor> ah, mhm
07:21:05 <kallisti> I can implement "withoutMVar" myself (and maybe give it a better name), just wondering if this use case has already been solved for me
07:21:11 <Entroacceptor> I guess there are reasons for that
07:22:21 <mauke> :t let withoutMVar mv x body = mask $ \restore -> do putMVar mv x; r <- restore body `onException` takeMVar mv; takeMVar mv; return r in withoutMVar
07:22:23 <lambdabot>     Not in scope: `mask'
07:22:23 <lambdabot>     Perhaps you meant `ask' (imported from Control.Monad.Reader)
07:22:23 <lambdabot>     Not in scope: `putMVar'
07:22:26 <mauke> :-(
07:23:27 <kallisti> it seems like a better solution than MVar () for plain old locks
07:24:50 <kallisti> and if I understand MVars correctly the thread safety should be the same even though you're inverting the usual order of operations
07:30:16 <Technology\> !help
07:30:31 <mauke> ?what with
07:30:31 <lambdabot> I know nothing about with.
07:32:54 <koltar> Kinnison: the problem is in ghc-flymake-init in ghc-flymake.el
07:33:15 <Kinnison> koltar: I'd need to get my other laptop out to investigate -- think it's an easy fix?
07:33:51 <franco00> I have a function which signature is String -> EitherT HexError (Writer Log) String. I want to use it in the IO Monad (for a simple "myFunc >>= print"). What's the correct way to lift it?
07:34:32 <franco00> lift . myFunc cs >>= print does not work
07:34:55 <Kinnison> franco00: You'd need to get IO into the bottom of that stack
07:35:00 <franco00> argh
07:35:10 <koltar> Kinnison: probably; just change ghc-flymake-init to do something besides (save-buffer)
07:35:14 <Kinnison> franco00: EitherT HexError (WriterT Log IO) String
07:35:18 <Kinnison> franco00: or something like that
07:35:25 * Kinnison hasn't played much with writer
07:35:50 <Botje> franco00: you can just use runWriter . runEitherT or something.
07:35:53 <Kinnison> franco00: then to do IO inside that, do liftIO
07:38:44 <franco00> like return . runWriter . runEitherT . replaceCols $ testString >>= \res -> ?
07:39:53 <franco00> (I don't get how to get a stack IO friendly, so to speak. Or if that is even possible)
07:40:57 <Kinnison> If you want to do IO *inside* your stack, you get it stuffed in at the bottom of the transformer stack.  Otherwise you need to run the stack before you get something you can print
07:41:32 <crl> :t liftM
07:41:34 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
07:42:39 <crl> > liftM (1+) (Just 2) >>= return
07:42:41 <lambdabot>   Just 3
07:43:24 <crl> > liftM (1+) (Just 2) >>= return . liftM (2*)
07:43:26 <lambdabot>   No instance for (GHC.Num.Num (m0 r0))
07:43:27 <lambdabot>    arising from a use of `e_1122'
07:43:27 <lambdabot>  Po...
07:43:42 <companion_cube> > liftM (+1) (Just 2)
07:43:44 <lambdabot>   Just 3
07:43:56 <crl> > liftM (1+) (Just 2) >>= liftM (2*) .return
07:43:58 <lambdabot>   Just 6
07:44:34 <k00mi> > liftM (2*) $ liftM (1+) (Just 2)
07:44:36 <lambdabot>   Just 6
07:56:44 <koltar> Kinnison: i think the issue is that filenames to match module names
07:57:18 <Kinnison> Mmm, possibly
08:00:48 <franco00> thanks
08:03:10 <Philippa> 'lo
08:03:20 <Philippa> I think I've figured out the gist of what I want to solve that type-level programming issue I've been complaining about for weeks
08:03:26 <Philippa> I've thought that before, mind
08:03:43 <Philippa> and I'm going to have to poke at extensions I've not used before, so hey, let's have some fun?
08:04:11 <Philippa> ("I want a type-level id in some circumstances" -> "I want a type family, don't I?")
08:05:08 <franco00> liftM (runWriter . runEitherT . replaceCols) (return testString) >>= \res -> did the trick, I guess I am better writing my own "lift all" function
08:07:09 <hpaste> srhb pasted “inferior-haskell-load-file hack to deal with cabal-dev” at http://hpaste.org/83635
08:08:03 <qualcalm> :t forever
08:08:05 <lambdabot> Monad m => m a -> m b
08:08:30 <srhb> Did my paste get through? Apparently I wasn't online. <_<
08:08:32 <Kinnison> srhb: oooh is that for ghc-mod?
08:08:52 <srhb> Anyway, if someone wants to nick it, feel free. I was going crazy with that issue. It needs find-file-in-project
08:08:58 <srhb> It's for haskell-mode. I think ghc-mod does it automagically.
08:09:00 <srhb> At least, it works for me
08:09:15 <Kinnison> neato
08:09:24 <srhb> But loading the file in ghci didn't in haskell-mode, which meant I had to manually flip between cabal-dev ghci for projects and ghci for one-off .hs-files
08:09:28 <srhb> Which drove my up the walls.
08:09:38 <srhb> me*
08:09:39 <Kinnison> lulz
08:10:16 <Saizan> Philippa: a type family Id is of as little use as a type synonym Id, you can't pass it around un-applied
08:10:52 <Saizan> Philippa: though i guess you meant using type families as interpreters for a defunctionalized Id?
08:11:32 <Philippa> Saizan: I don't need to pass it around, thankfully
08:11:38 <crl> > unfoldTree (\i -> (show i, [i`div`2..i-1])) 2
08:11:41 <lambdabot>   Node {rootLabel = "2", subForest = [Node {rootLabel = "1", subForest = [Nod...
08:11:52 <Philippa> I can let the instance-building gubbins do that for me
08:12:47 <Philippa> (so yes, I could also think of that as "associated type synonym", but my brain's not working that way round today and tbh that never worked as well for me as "associated type family")
08:13:33 <Saizan> ah, i see now
08:13:52 <Saizan> you want to have a type family that's id for some instances, that's fine
08:17:17 <kallisti> why is there a breakSubstring for strict bytestring but not for lazy?
08:21:44 <Philippa> re
08:21:45 <Philippa> gotta love the high-quality connection you achieve on a train, huh?
08:21:49 <crl> i don't understand instance Monad Tree where .... this-> Node x ts >>= f = Node x' (ts' ++ map (>>= f) ts)  where Node x' ts' = f x
08:22:20 <crl> Node x' ts' = f x, <-- isn't f that should be set here
08:22:33 <crl> nvm
08:22:49 <crl> it's the definition of  Node x ts >>= f
08:23:48 <crl> yet it's obscure ..
08:24:12 <crl> Node x' (ts' ++ map (>>= f) ts) where Node x' ts' = f x
08:25:34 <quicksilver> is it the where clause you're finding obscure, crl?
08:25:45 <quicksilver> that where clause is 'unpacking' the result of f x
08:25:51 <crl> yes
08:26:02 <crl> hmm pattern matching
08:26:03 <quicksilver> and binding new names x' and ts' to the fields of (f x)
08:26:06 <quicksilver> yes.
08:28:13 <crl> makes sense, but ts isn't used?
08:28:48 <crl> o it is recursively for the children
08:29:10 <crl> map (>>= f) ts   , hurts ;)
08:30:18 <crl> first time i see a recursive definition of >>=
08:30:27 <applicative_> in Node x ts >>= f = case f x of Node x' ts'  ->  Node x' (ts' ++ [t >>= f | t <-  ts])
08:30:41 <applicative_> Node x ts >>= f = case f x of Node x' ts'  ->  Node x' (ts' ++ [t >>= f | t <-  ts])
08:30:43 <applicative_> rather
08:31:37 <quicksilver> crl: that's because it's an elementary definition instead of using a named combinator
08:31:47 <quicksilver> you could write >>= for list directly and recursively
08:31:53 <crl> applicative_: prefer that yes
08:31:57 <quicksilver> but it's more common to write it in terms of map+concat
08:32:18 <quicksilver> similarly there is some general tree combinator which could have been used there, I think
08:32:26 <applicative_> I find things like fmap (>>=f) ... and the like difficult to read for some reason
08:32:46 <crl> very
08:33:16 <applicative_> I think it arises in cases where a formulation by return and join would be preferable, but I'm not sure
08:34:06 <crl> but thx your expression is really clearer to me at least
08:34:44 <Saizan> you should learn to deal with them though, higher-order programming is one of the best parts of FP
08:35:11 <applicative_> Maybe in this case too, think how you would write Tree (Tree a) -> Tree a.   Node (Node a as) atrees ...
08:35:42 <adek> Does haskell support line splicing like python? I have very long line and I would like to split it into shorter pieces
08:36:01 <crl> oww tree holding tree as vaklues
08:36:04 <applicative_> join (Node (Node a as) trees = Node a (as ++ map join trees)
08:36:22 <Clint> adek: in a string literal or in code?
08:37:01 <adek> Clint: in code
08:38:05 <crl> adek: you mean that? http://www.haskell.org/haskellwiki/Keywords#.5C
08:38:18 <applicative_> basically you can do what you want as long as you dont break the ambient left margin , that of the statement block
08:38:20 <typoclass> adek: the rule of thumb is, it'll work if you insert a line break and indent more
08:38:44 <applicative_> adek: maybe paste the line or definition?
08:38:48 <typoclass> adek: this discussion will be much easier if you post some code to hpaste :-) we can show you
08:39:32 <applicative_> adek: right, what typoclass said about the layout rule is what I meant, just make sure you indent more than you already where
08:39:54 <adek> Wow. Line breaks really work well if I indent code a bit more
08:39:59 <adek> Thank you!
08:41:22 <applicative_> adek: it's pretty much laissez faire except where you are making a sequence of statements with where, do, case
08:41:39 <tertl3-laptop> http://colinm.org/language_checklist.html
08:42:10 <bartavelle> ok I can see that with flags and cabal I can change all configuration inside an executable or library block. But how can I decide to build some executable only when some flag is set (there is the special case of tests, but I'd like something more general)
08:43:21 <dcoutts> bartavelle: see the "if flag(blah) { buildable: False }" trick
08:43:42 <byorgey> @package diagrams-builder
08:43:42 <lambdabot> http://hackage.haskell.org/package/diagrams-builder
08:43:49 <byorgey> bartavelle: ^^^ see that package for an example
08:43:54 <bartavelle> ahh
08:43:57 <bartavelle> thanks
08:44:22 <christoph_> hey
08:44:34 <christoph_> are there any mathematicans in?
08:45:26 <byorgey> christoph_: in what? you'll have to be more precise, otherwise the mathematicians will not understand you ;-)
08:45:39 <christoph_> computer algebra
08:45:48 <christoph_> i just came across the paper
08:45:49 <christoph_> http://arxiv.org/pdf/0909.4950.pdf
08:46:00 <applicative_> are there any mathematicians in computer algebra?
08:46:06 <christoph_> that implements grbner bases in haskell,
08:46:09 <byorgey> christoph_: ah, you are looking for DrSyzygy
08:46:23 <byorgey> (who is the second author of that paper)
08:46:29 <christoph_> i know of Syzygy
08:46:52 * frerich thought syzygy was an AI player in Unreal Tournament
08:46:55 <christoph_> but just from the algebraic side :-)
08:47:56 <applicative_> oh here's the library http://hackage.haskell.org/package/Operads
08:48:38 <christoph_> to be honest, I need more than that,
08:48:59 <christoph_> has anybody investigated in the characteristic set method?
08:52:12 <Philippa> re
08:52:21 <Philippa> should actually be at a stable location now
08:53:56 <Philippa> Saizan: The id case works fine, figuring out just how to get the things I need in scope for the others!
08:54:56 <byorgey> christoph_: I hadn't heard of that, but it looks interesting
08:55:13 <christoph_> characteristic set?
08:55:24 <christoph_> or the grbner-bases paper?
08:55:35 <byorgey> the characteristic set method
08:56:02 <christoph_> byorgey: I'm doing my research currently on the work of Ritt,
08:56:23 <christoph_> byorgey: who defined it in his fundamental book on differential algebra
09:04:41 <Taneb> Is there anyone here familiar with combining C++ and Haskell willing to spare me some time?
09:06:06 <shachaf> Taneb: You should probably just ask your question.
09:06:30 <Taneb> It's less of a question and more "can you hold my hand and walk me through this"
09:06:37 <fragamus> edwardk you said "we can 'ask :: (e, a) -> e'     then   extend ask (e,a) = (e,e)"
09:06:49 <fragamus> I want to ask you some questions about this
09:06:56 <edwardk> i'll answer as i can
09:07:03 <shachaf> Taneb: OK, so you should write what you know and what you don't and what you're trying to do.
09:07:16 <fragamus> ok I know you are at work and busy so dont worry about timeliness
09:07:19 <shachaf> That way even people who aren't familiar with combining C++ and Haskell (like me!) might be able to help you.
09:07:26 <Taneb> Yay!
09:07:29 <Philippa> edwardk: you may be relieved to know I'm making some progress on my problem and now have something more specific to whine about
09:07:36 <edwardk> Philippa: =)
09:07:48 <shachaf> Taneb: I'm not volunteering, mind you.
09:07:52 <fragamus> so the ask function in this case, is that part of the comonad
09:08:04 <edwardk> that is an operation associated with the comonad.
09:08:09 <fragamus> ok
09:08:23 <Saizan> Philippa: yeah, i only figured out later what you meant
09:08:26 <Taneb> My code is in src/Galakhsy/Saturn/, and I've got a C++ library I want to use somewhere in lib/saturn/
09:08:28 <Philippa> edwardk: aaand crap, I think I've just hit a dead end because no overlapping instances + associated type synonyms
09:08:32 <edwardk> you could envision a class Comonad w => ComonadEnv e w | w -> e where ask :: w a -> e
09:08:49 <edwardk> overlapping instances are a good sign you are on to the wrong abstraction
09:09:14 <fragamus> and this bit:    "extend ask (e,a) = (e,e)" is not a line of code, but rather an illustration of what would result if someone used extend with ask right?
09:09:16 <Philippa> generally I agree? In this case they're a sign I want a list-like structure at type level
09:09:17 <Taneb> How do I tell GHC that that library is there when the .cpp file in src/Galakhsy/Saturn/ asks for it
09:09:22 <Philippa> or to put it another way: didn't realise you were so against row types :p
09:09:29 <edwardk> fragamus: yeah
09:09:57 <edwardk> i usually write that sort of thing with a triple-= when doing code examples =)
09:10:32 <edwardk> i'm not against row types, but haskell doesn't have them ;)
09:10:35 <fragamus> mkay… I have read and re-read the conversation that we had before.  Thank you for that.
09:10:37 <Philippa> mmm. => would be more tempting if it wasn't also a haskell operator
09:10:37 <ptek_> Guys, what would you do if the current maintainer of a package from hackage does not answer emails and you want to publish a newer version of a package?
09:11:18 <Philippa> edwardk: *nod*. Which, er. You know how I tend to have subtle but strong reasons for wanting another language?
09:11:23 <applicative_> ptek_: you ask about it on haskell cafe and thus elicit hundreds of incompatible answers
09:11:24 <shachaf> ptek_: The wiki has guidelines somewhere.
09:11:33 <edwardk> i build composite alternatives using prisms and lenses rather than data types ala carte. requires a bit more explicit work, but no overlapping instances and its much saner to use
09:11:58 <applicative_> if it does they are the work of one of the partisans surely...
09:11:59 <edwardk> ptek_: which package?
09:12:03 <tac> What's a row type again?
09:12:05 <ptek_> NetSNMP
09:12:09 <ski> fragamus : yes, that's a true statement, holding for every `e' and `a'
09:12:12 <Philippa> *nod*. And I guess what I'm doing smells of the data types ala carte's innards a bit
09:12:29 <ptek_> edwardk: it was last updated in 2009
09:12:36 * edwardk also wanted to clean that up at some point
09:12:48 <Philippa> tac: they're a bit like what you get when you turn Haskell (composite) constraints into types, in that eg they're unordered
09:13:07 <edwardk> i gave up and switched to sending stats to statsd instead
09:13:17 <ski> tac : an association (at type level) of names to types (say all of the same kind)
09:13:17 <Philippa> tac: the prototypical example's a scheme for record types that doesn't need subtyping per se
09:13:39 <tac> hmm
09:14:22 <Philippa> ski: right. I'm, er, starting to worry that I'd have to break GHC *really* hard to pull it off for labelled layers of composed functors
09:14:29 <ski> tac : given a kind `Row', you can imagine `Record :: Row -> *' and `Variant :: Row -> *' for building record resp. variant types with fields/alternatives named by the names, and with corresponding data of the appropriate type
09:14:47 <Philippa> which is a problem, because that's exactly what I need
09:14:52 <Philippa> and, er, I'm more allergic to boilerplate than edwardk?
09:15:11 <tac> hmm
09:15:13 <Saizan> Philippa: fundeps are still there :)
09:15:18 <Philippa> (and not entirely clear on how the boilerplate would scale with the lens approach, which is admittedly putting me off)
09:15:37 <Philippa> Saizan: yeah. Which is going to make for some real fugly instances, but meh
09:15:46 <edwardk> i've written enough c++ over the years that i've built up an immunity to both iocaine powder and boilerplate.
09:16:00 <ski> Philippa : fwiw, i've suspected that we really should have labels to refer to the levels in a monad transformer stack (instead of this type class overloading business, which only will "see" the outermost layer supporting `MonadState', &c.)
09:16:04 <Philippa> I've written enough C++ over the years to have a serious allergy to boilerplate, alas
09:16:08 <tac> So is this just another way to do subtype polymorphism?
09:16:12 <edwardk> i also find the cure you're trying to use worse than the disease
09:16:33 <crl> > map (>>= return) [Just 1, Just 2]
09:16:35 <lambdabot>   [Just 1,Just 2]
09:16:35 <Philippa> tac: it's fundamentally different to subtyping, with some significant meta-level differences. But close enough
09:16:41 <tac> hmm
09:16:49 <tac> I'll just stick to my dependent types!
09:16:51 <tac> :P
09:17:01 <fragamus> speaking of boilerplate, I saw in one of edwardk's videos some example where there was a function that operated on booleans and it was apparently provable that the type signature implied a single implementation. In that case, I think ghc should generate the implementation automatically.    : P
09:17:10 <Philippa> edwardk: hmm, I'm wondering how you define "the cure you're trying to use" there. And whether eg you'd have the same problem in a language that lets me write the autolifting in a neater fashion?
09:17:25 <crl> > map (>>= \x-> return x^2) [Just 1, Just 2]
09:17:27 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b0))
09:17:28 <lambdabot>    arising from a use o...
09:17:48 <ski> tac : it's not subtyping, it's row polymorphism
09:17:50 <yitz> fragamus: usually that means that there is provable only one *total* implementation
09:17:56 <yitz> *provably
09:18:09 <fragamus> yeah that was the upshot
09:18:27 * edwardk has to run for a bit. Philippa we can pick up later
09:18:54 <yitz> fragamus: you may not want that one. especially since in many cases that implementation turns out to be vacuous in some way.
09:19:06 <fragamus> I just get tired of typing implementations when it should be OBVIOUS how to implement it  : P
09:19:11 <tac> ski: ah. I think I get it. You don't end up hiding those extra fields. you keep them all in the type
09:19:26 <DuelShark> I know this is a bit off-topic, (have asked for help here last two days but struggling) does anyone know a good website for Haskell consultation for small periods? (4-8 hours) with assistance in explaining/writing code, any help appreciated
09:19:46 <Philippa> @tell edwardk Sure, might take a day or three though - RL windows are a PITA, right?
09:19:46 <lambdabot> Consider it noted.
09:19:53 <ski> tac : see "Extensible records: Trex" <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.2> in Hugs, and "Polymorphic variants" <http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual006.html#toc36> in OCaml
09:20:04 <Kinnison> DuelShark: I found it was best to get local support.  Websites didn't help me in the early days
09:20:11 <yitz> fragamus: a haskell ide could potentially offer implementations, not even total ones, as an option. that would be really cool.
09:20:13 <applicative_> ptek did you write to the guy?
09:20:37 <DuelShark> thanks Kinnison, I have found nice support here but still struggling, I think it's best if I pay someone to help me on a hourly rate but quite hard to find people
09:21:06 <k00mi> fragamus: that does actually exist: http://lambda-the-ultimate.org/node/1178
09:21:07 <ptek_> applicative_: yes I did. He did not answer yet
09:21:13 <fragamus> yitz, well I'm sure it's rather rare that there is provably only one implementation
09:21:15 <k00mi> fragamus: lambdabot even has it as @djinn
09:21:29 <fragamus> whoa
09:21:41 <yitz> @djinn a -> b
09:21:41 <lambdabot> -- f cannot be realized.
09:21:52 <Taneb> @djinn a -> a
09:21:52 <lambdabot> f a = a
09:21:56 <yitz> @djinn a -> a
09:21:56 <lambdabot> f a = a
09:22:02 <applicative_> ptek_: how long has it been with no response?
09:22:13 <Kinnison> DuelShark: well good luck, and if you find such a resource, please do let us know -- but I'm not very optimistic about your chances
09:22:20 <ptek_> applicative_: since monday. Which is probably not much...
09:22:21 <yitz> @djinn (a -> b) -> [a] -> [b]
09:22:22 <lambdabot> Error: Undefined type []
09:22:37 <Philippa> DuelShark: if the DWP weren't such total arseholes about accounting, I might consider it?
09:22:50 <yitz> @djinn (a -> b) -> (a,c) -> (b,c)
09:22:50 <lambdabot> f a (b, c) = (a b, c)
09:22:59 <ptek_> applicative_: so I wonder what can one do if there will be no answer...
09:23:02 <DuelShark> Philippa what's the DWP? :p
09:24:24 <applicative_> ptek_: I can't find the wiki page shachaf mentioned, but the -cafe blather seems to recommend waiting a couple of weeks. see e.g. http://www.haskell.org/pipermail/libraries/2011-May/016397.html and d fisher   http://stackoverflow.com/questions/9435513/non-maintainer-uploads-to-hackage
09:25:29 <ptek_> applicative_: this is helpful. Thank you...
09:25:48 <ptek_> applicative_: will write him maybe once more next week then
09:25:55 <Philippa> DuelShark: You're in the UK, right? They're the lot that run social security/welfare/benefits here
09:26:05 <crl> > (>>= return . (+1)) (Just 2)
09:26:06 <DuelShark> ahh I see
09:26:08 <lambdabot>   Just 3
09:26:45 <DuelShark> I wasn't looking to have major work done Philippa just a very simple program assistance on writing/explainign
09:26:49 <Philippa> as I'm officially Too Crazy To Work, demonstrating that I can do a small amount of very specific work is also potentially unwise for me? But either way I'd have to do ludicrous accounting and I'd probably lose most of it to the council anyway
09:26:52 <DuelShark> on whatever the hourly rate is
09:27:04 <Philippa> *nod*. Head to -overflow and describe your problem?
09:27:14 <Philippa> it's quieter there, so people can take more time with you
09:27:15 <DuelShark> I have a lot of problems haha :P
09:27:29 <Philippa> first one: picking the first other problem to describe!
09:27:46 <crl> #haskell-assistance ;)
09:28:29 <Philippa> crl: 'twould be fairly redundant, yeah :-)
09:29:48 <DuelShark> I tried hiring a freelancer but for the first time ever I only received a few messages :p
09:29:59 <byorgey> DuelShark: I might be willing to help.  Send me an email with more info -- my nick at gmail.
09:30:11 <DuelShark> okay will do
09:30:39 <byorgey> DuelShark: you could also look at http://www.well-typed.com/
09:30:47 <byorgey> they specifically do Haskell consulting
09:30:49 <applicative_> ptek_: you might also just write a new version, I notice it uses some rather olde fashioned haskell
09:30:51 <DuelShark> oh nice thanks
09:31:12 <applicative_> ptek_: and it defines a special error monad Trouble with the comment -- Better would be to use ErrorT from the mtl (or other transformer library) but I don't want the dependency before the dust has settled between them; it smells like a compatibility tarpit.
09:31:54 <ptek_> applicative_: it has a lot of quirks but I did not feel like rewriting it from scratch yet :)
09:32:33 <ptek_> applicative_: also I can't claim, that I would have better style since this was my first encounter with ffi in haskell
09:33:05 <dmwit> DuelShark: There's also http://www.haskellers.com/skills/17
09:33:14 <applicative_> yes, it looks like a nightmare, but that he managed it capably
09:33:17 <DuelShark> thanks
09:34:45 <hpaste> srhb annotated “inferior-haskell-load-file hack to deal with cabal-dev” with “inferior-haskell-load-file hack to deal with cabal-dev (annotation)” at http://hpaste.org/83635#a83637
09:35:06 <Zamarok> Is there a function in prelude that tells me how many times an element appears in a list? Like `frequency "c" "aabbccc"` would return `3`.
09:35:26 <shachaf> Zamarok: length . filter (==x)
09:35:33 <srhb> Zamarok: length . filter (==x)
09:35:39 <srhb> ah..
09:36:13 <Zamarok> I know I can code it.. but isn't there a function for that already? I thought I remembered seeing one
09:36:29 <srhb> > let frequency x = length . filter (==x) in frequency "aabbcc"
09:36:31 <lambdabot>   No instance for (GHC.Show.Show
09:36:31 <lambdabot>                     ([[GHC.Types.Char]] -> G...
09:36:36 <shachaf> Nope.
09:36:42 <srhb> Zamarok: I don't think it's there, too simple to combine your way to :)
09:36:50 <Zamarok> okay, thanks
09:37:03 <srhb> derp
09:37:23 <ptek_> applicative_: thanks for the ideas. I'll see how it goes then
09:37:23 <srhb> > let frequency x = length . filter (==x) in frequency 'c' "aabbcc"
09:37:25 <lambdabot>   2
09:37:34 <srhb> Easy and I still fail :-)
09:39:19 <crl> > (Node 1 []) ^. _1
09:39:21 <lambdabot>   Could not deduce (Control.Lens.Tuple.Field1
09:39:21 <lambdabot>                      (Data.Tree...
09:40:09 <applicative_> > let counting x xs = foldr (\ c n -> if c == x then n+1 else n) 0 xs in counting 'a' "The Haskell Programming Language"
09:40:11 <lambdabot>   4
09:48:43 <dmwit> > M.fromListWith (+) . (`zip` repeat 1) $ "The Haskell Programming Language"
09:48:46 <lambdabot>   fromList [(' ',3),('H',1),('L',1),('P',1),('T',1),('a',4),('e',3),('g',4),(...
09:49:17 <applicative_> Zamarok: by the way Data.Text (like ByteString) supplies a special optimize 'count' if you are indeed counting characters
09:49:49 <applicative_> can't do that with Data.Text now can you
09:50:30 <Zamarok> applicative_: Integers actually, thanks though
09:52:39 <dgpratt> TIL lazy evaluation is actually a really bad technique to have...I wish you guys would've told that me before now
09:52:54 <srhb> dgpratt: Huh?
09:53:01 <Philippa> how so (in particular)? It's not all-bad by any means
09:53:07 <dgpratt> http://www.youtube.com/watch?v=w1tScIsUz7Q
09:53:36 <srhb> Oh, the irony tags were missing. :P
09:53:42 <dgpratt> srhb: :)
09:54:01 <sm> g'day all. How do you read the status of a trac issue, eg of http://hackage.haskell.org/trac/ghc/ticket/4471 ? I can't tell if it's closed
09:54:18 <dgpratt> you can't argue against what "a lot of professionals online" claim!
09:55:01 <Philippa> a lot of professionals online claim there is no objective reality! (though not always while acting as professionals)
09:55:05 <applicative_> 'the number 1 isn't always the same as the number 1'
09:55:05 <srhb> Following his facial features I think he's taking that with a grain of salt himself.
09:56:06 <applicative_> awesome, wadler makes them write haskell with pencil and paper
09:56:17 <srhb> Hehehe.
09:57:14 <Dodek> could any native english speaker tell me what accent does the guy in the video speaks with?
09:57:27 * hackagebot hakyll 4.2.1.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.2.1.0 (JasperVanDerJeugt)
09:57:32 <dgpratt> sounds scottish or maybe irish to me
09:57:39 <dgpratt> yeah, scottish
09:57:55 <hiptobecubic> We had pencil and paper haskell exam as well
09:58:01 <lispy> applicative_: don't most university exams require you to write code with pen&paper?
09:58:06 <dgpratt> (speaking as a'Murican)
09:58:08 <Dodek> we also had pencil and paper haskell exam
09:58:14 <sm> scottish, definitely
09:58:23 <Dodek> dgpratt: sm thanks
09:58:28 <hiptobecubic> Although there was also a second part involving some more complicated exercises
09:58:33 <srhb> lispy: Never experienced that.
09:58:34 <Dodek> i can barely understand this guy
09:58:39 * lispy has had to write java, c, lisp, haskell, and possibly other languages on exams
09:59:33 <crl> > let t=unfoldTree (\i -> ( i, [0..i-1])) 2 in t >>= (\n -> return $ Node (rootLabel n) (subForest n))
09:59:35 <lambdabot>   No instances for (GHC.Enum.Enum (Data.Tree.Tree a0),
09:59:36 <lambdabot>                    GHC...
09:59:41 <crl> what is wront on thaat ^
09:59:48 <Dodek> i recall that on exam i had we had to implement a type representing probability distributions
09:59:49 <crl> wrong*
10:00:02 <Dodek> some functions transforming distributions
10:00:14 <Dodek> and a monad instance for probability distribution
10:00:17 <byorgey> @type unfoldTree
10:00:18 <lispy> crl: [0..i-1] :: [Data.Tree.Tree]
10:00:19 <lambdabot> (b -> (a, [b])) -> b -> Tree a
10:00:41 <sm> Dodek: tune your ear in with these (funny): https://www.google.com/search?q=adventure+call+limmy
10:00:42 <lispy> crl: What I meant to say is, I think the enum is happening in the list comprehension
10:00:44 <byorgey> no, I don't think that's why
10:00:54 <byorgey> look at the type of unfoldTree
10:01:02 <byorgey> > unfoldTree (\i -> ( i, [0..i-1])) 2
10:01:04 <lambdabot>   Node {rootLabel = 2, subForest = [Node {rootLabel = 0, subForest = []},Node...
10:01:10 <byorgey> see, that part works just fine
10:01:12 <crl> t :: Tree Integer
10:01:28 <crl> @ty unfoldTree (\i -> ( i, [0..i-1])) 2
10:01:30 <lambdabot> (Enum a, Num a) => Tree a
10:01:38 <byorgey> crl: ah, you don't want the 'return'
10:01:51 <byorgey> crl: you're using the Tree monad, so  Node (rootLabel n) ...  is already a Tree
10:02:54 <byorgey> crl: but there are other things wrong.  if  t :: Tree Integer, then  n :: Integer
10:03:08 <byorgey> crl: which monad did you intend to use?
10:03:12 <Dodek> sm: this is crazy, i almost understand the showman, but i understand at most one word per sentence of the caller
10:03:36 <tac> > toRational 3.14
10:03:38 <lambdabot>   7070651414971679 % 2251799813685248
10:04:03 <byorgey> tac: haha, nice
10:04:08 <dmwit> ?hoogle toRational
10:04:09 <lambdabot> Prelude toRational :: Real a => a -> Rational
10:04:18 <sm> yeah :)
10:04:21 <byorgey> thus proving that toRational actually goes via Double.
10:04:22 <sm> it gets easier
10:04:25 <dmwit> Oh, rounding?
10:04:39 <dmwit> > toRational (3.14 :: CReal)
10:04:41 <lambdabot>   *Exception: CReal.toRational
10:04:42 <byorgey> I would assume so.  3.14 can't be represented exactly.
10:04:43 <tac> byorgey: I was learning about the numeric tower last night
10:04:48 <crl> byorgey: I thought n would be a node
10:04:56 <tac> It's actually really easy to remember all the numeric typeclasses in Haskell
10:05:01 <byorgey> @type (>>=)
10:05:03 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:05:06 <byorgey> crl: ^^^
10:05:07 <tac> Just think about what makes sense... then make sure whatever your answer is is not that
10:05:16 <byorgey> if the first argument is  Tree Integer, then a = Integer
10:05:20 <dmwit> > toRational (3.14 :: Rational) -- ;-)
10:05:23 <lambdabot>   157 % 50
10:05:29 <byorgey> cheater!
10:05:39 <tac> dmwit: ah, I didn't even think of that :)
10:05:44 <tac> Gogo monomorphism restriction!
10:05:47 <jfischoff> @remember tac It's actually really easy to remember all the numeric typeclasses in Haskell. Just think about what makes sense... then make sure whatever your answer is is not that
10:05:47 <lambdabot> I will remember.
10:05:54 <crl> byorgey: ok so (unfoldTree (\i -> ( i, [0..i-1])) 2 >>=)
10:05:57 <jfischoff> @quote tac
10:05:58 <lambdabot> tac says: It's actually really easy to remember all the numeric typeclasses in Haskell. Just think about what makes sense... then make sure whatever your answer is is not that
10:06:01 <crl> @ty (unfoldTree (\i -> ( i, [0..i-1])) 2 >>=)
10:06:03 <lambdabot> (Enum a, Num a) => (a -> Tree b) -> Tree b
10:06:16 <byorgey> > read "3.14" :: Rational   -- if only this worked =(
10:06:19 <lambdabot>   *Exception: Prelude.read: no parse
10:06:24 <jfischoff> @quote numeric
10:06:24 <lambdabot> ghc says: Only unit numeric type pattern is valid
10:06:31 <dmwit> Yeah, I've been annoyed by that in real code before.
10:06:37 <jfischoff> @quote numeric
10:06:37 <lambdabot> ghc says: Only unit numeric type pattern is valid
10:07:09 <ski> > read "\"\"" :: String
10:07:11 <lambdabot>   ""
10:07:14 <ski> > read "[]" :: String
10:07:17 <lambdabot>   ""
10:07:24 <dmwit> surprise!
10:07:35 <dmwit> > read "    (((((3)))))  " :: Int
10:07:38 <lambdabot>   3
10:07:42 <byorgey> wat!
10:07:42 <tac> > toRational (read "3.13" :: Fractional a => a)
10:07:45 <lambdabot>   Could not deduce (GHC.Read.Read a)
10:07:45 <lambdabot>    arising from a use of `Text.Read.read...
10:07:54 <tac> hmm
10:08:00 <tac> oh typeclasses :(
10:08:07 <ski> i thought i read Strings will only parse with `readsPrec' in the double quoted form ?
10:08:07 <byorgey> tac: that's not going to work.  It needs to know specifically which instance to use.
10:08:17 <tac> byorgey: right. right.
10:08:20 <ski> (though i suppose perhaps GHC is more liberal)
10:09:14 <dmwit> ski: double-quoted form?
10:10:25 <ski> dmwit : you know, like  "abc"  rather than  ['a','b','c']
10:10:46 <dmwit> I'm pretty sure all the instances accept anything that "show" spits out.
10:10:53 <dmwit> And "show" spits out "abc".
10:11:12 <ski> yes, but not the latter alternative
10:11:19 <ski> > read "['a']" :: String
10:11:20 <lambdabot>   "a"
10:11:21 <ski> > read "'a':[]" :: String
10:11:22 <lambdabot>   "*Exception: Prelude.read: no parse
10:11:46 <dmwit> Oh, you're saying you're surprised that "['a']" succeeds? Okay, yeah, me too.
10:12:11 * ski nods
10:13:27 <byorgey> I'm glad, because it makes the case for having (read "3.14" :: Rational) succeed much stronger =)
10:14:04 <koltar> > read "['a','b']"
10:14:05 <lambdabot>   *Exception: Prelude.read: no parse
10:14:16 <ski> "`readsPrec' will parse any valid representation of the standard types apart from strings, for which only quoted strings are accepted, and other lists, for which only the bracketed form `[…]' is accepted." <http://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18600011.4>
10:14:38 <ski> koltar : that defaulted to reading as value of type `()'
10:15:00 <koltar> > read "['a','b']" :: [Char]
10:15:01 <lambdabot>   "ab"
10:15:06 <byorgey> "any valid representation" is a little vague =P
10:15:38 <koltar> i think that means "no expressions"
10:16:02 <byorgey> yes, you're probably right
10:16:30 <Philippa> yeah, I figure it means one that's in normal form or sugar for one
10:16:57 <crl> > let t=unfoldTree (\i -> ( i, [0..i-1])) 2 in t >>= (\n -> Node (show (n==1)) [])
10:16:58 <Philippa> (plus a few fudges for eg fromIntegral)
10:16:59 <lambdabot>   Node {rootLabel = "False", subForest = [Node {rootLabel = "False", subFores...
10:17:21 <ski>   "The result of show is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used."
10:17:26 <ski>   "Parentheses are only added where needed, ignoring associativity. No line breaks are added. The result of show is readable by read if all component types are readable. (This is true for all instances defined in the Prelude but may not be true for user-defined instances.)"
10:17:30 <crl> so the entry point n is the rootValue, hmmmm
10:17:42 <ski> (note especially "ignoring associativity")
10:17:56 <crl> > let t=unfoldTree (\i -> ( i, [0..i-1])) 2 in t >>= (\n -> Node (show (n==2)) [])
10:17:58 <lambdabot>   Node {rootLabel = "True", subForest = [Node {rootLabel = "False", subForest...
10:18:23 <ski> byorgey : so i think "any valid representation" should be read in the light of the above
10:18:32 <byorgey> ski: ah, ok, sure
10:18:40 <ski> (there's also the namespace problem)
10:19:03 <byorgey> ski: but it sounds like the Report does not *rule out* Read instances which are more liberal?
10:20:04 <ski>   "It should be the case that `(x,"")' is an element of `(readsPrec d (showsPrec d x ""))'. That is, `readsPrec' should be able to parse the string produced by `showsPrec', and should deliver the value that `showsPrec' started with."
10:20:52 <byorgey> right.
10:20:53 <ski> byorgey : i think so
10:22:23 <ski> i wonder if it would be sensible to strengthen the above to `(x,s)' being an element of `readsPrec d (showsPrec d x s)', under some mild conditions on the starting characters of `s'
10:22:31 <ski> (think "maximal munch")
10:30:11 <crl> > reads "Just 1"
10:30:13 <lambdabot>   []
10:30:33 <crl> > read "Just 1"
10:30:36 <lambdabot>   *Exception: Prelude.read: no parse
10:31:01 <shachaf> What are you expecting to happen here?
10:31:16 <crl> nothing :)
10:31:32 <crl> @ty read
10:31:34 <lambdabot> Read a => String -> a
10:31:54 <crl> > read "\"Just 1\""
10:31:56 <lambdabot>   *Exception: Prelude.read: no parse
10:32:43 <Saizan> > read "Just 1" :: Maybe Int
10:32:45 <lambdabot>   Just 1
10:33:07 <simpson> > read . read $ "\"Just 1\"" :: Maybe Int
10:33:10 <lambdabot>   Just 1
10:33:58 <crl> o, didn't think it would
10:34:21 <donri> > fromJust $ read "Just 1"
10:34:23 <lambdabot>   *Exception: Prelude.read: no parse
10:34:39 <dmwit> > fromJust $ read "Just ()"
10:34:41 <lambdabot>   ()
10:34:44 <donri> > fromJust (read "Just 1") + 0
10:34:46 <lambdabot>   1
10:35:14 <shachaf> fromJust :-(
10:35:40 <donri> read :-(
10:35:46 <dmwit> > maybe Nothing Just (read "Just 1") + 0
10:35:48 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a0))
10:35:48 <lambdabot>    arising from a use o...
10:36:04 <dmwit> > maybe Nothing (Just . (+0)) (read "Just 1")
10:36:06 <lambdabot>   Just 1
10:36:14 <donri> > fmap (+0) $ maybe Nothing Just (read "Just 1")
10:36:16 <lambdabot>   Just 1
10:36:32 <shachaf> @ty maybe Nothing Just
10:36:34 <lambdabot> Maybe a -> Maybe a
10:36:35 <shachaf> good function
10:36:57 <dmwit> We're playing the "make a type-restricted id without using type annotations" game, right? =)
10:37:05 <donri> yep!
10:37:22 <kallisti> I cannot find a good HTML entity decoder on hackage..
10:37:31 <kallisti> (that doesn't do many other things that I don't want to do)
10:37:39 <shachaf> @ty [id, ask, asks, ($)]
10:37:41 <dmwit> HaXml doesn't have one?
10:37:41 <lambdabot> [(r -> a) -> r -> a]
10:38:00 <kallisti> dmwit: not a Text -> Text function, anyway
10:38:34 <dmwit> Congratulations, I'm pretty sure you just volunteered.
10:38:46 <kallisti> would appear so
10:40:07 <shachaf> mplus and mzero are both sensible individually, aren't they?
10:41:17 <kallisti> shachaf: yes
10:41:43 <saeidw> hey guys, I just saw an interesting implementation of the Fibonacci sequence in Perl, and I was wondering how I could write something similar in Haskell
10:41:44 <dmwit> MonadSemigroup
10:41:56 <dmwit> ah, now Fibonacci we can do
10:42:06 <shachaf> @quote _pizza_
10:42:07 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
10:42:28 <dmwit> ?wiki the fibonacci sequence
10:42:29 <lambdabot> http://www.haskell.org/haskellwiki/the_fibonacci_sequence
10:42:36 <saeidw> lol, I'm interested in the aesthetics of it, not so much the actual solution
10:42:59 <dmwit> Are you going to show us the code, or what? =)
10:43:06 <saeidw> the perl solution looks like this: (0,1, *+* ... *)
10:43:28 <donri> that looks like perl6
10:43:37 <koltar> saeidw: that's... incomprehensible
10:43:38 <saeidw> it is
10:43:57 <dmwit> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
10:43:59 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:44:00 <saeidw> it's basically a range, where the third element is a function describing how to generate the rest of the list
10:44:13 <dmwit> NEXT!
10:44:23 <koltar> dmwit: that's probably my favorite version
10:44:31 <saeidw> dmwit, I'm familiar with that solution, and it's elegant but it's not the same
10:44:42 <donri> it is the same
10:44:45 <dmwit> It is the prototypical Haskell version, and it happens to be the analogue of saeidw's Perl version by accident, too.
10:44:46 <donri> that's what the perl version describes
10:44:59 <dmwit> In what way is it not the same?
10:45:02 <saeidw> hmm.. actually yeah, you're right
10:45:12 <donri> perl 6 just has more sugar for it
10:45:36 * koltar uses zip xs (tail xs) more than is healthy
10:45:39 <saeidw> I was wondering if I could write an operator that would mimic the range notation, but with space for a generator function
10:45:41 <int-e> > fix ((0:) . scanl (+) 1)
10:45:43 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:46:44 <byorgey> saeidw: no, Haskell doesn't support defining arbitrary mixfix notations like that
10:47:01 <byorgey> though you could certainly write a function of type   a -> a -> (a -> a -> a) -> [a]
10:47:03 <kallisti> dmwit: eh, instead of volunteering to do actual work I can just be lazy and do everything through xml-conduit
10:47:03 <koltar> i think you could get something close, though
10:47:22 <kallisti> even tough parsing the HTML into an XML tree is hugely overkill
10:47:37 <saeidw> close is good enough, I just want to know how bendable the syntax can get :D
10:47:41 <typoclass> kallisti: i keep hearing about tagsoup ...
10:48:02 <byorgey> well, ok, how about this?
10:48:03 <dmwit> kallisti: Doing a real parse turns out to be the right choice more often than seems reasonable.
10:48:05 <byorgey> > let (...) a b f = list where list = a : b : zipWith f list (tail list)  in   (0 ... 1) (+)
10:48:07 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:48:28 <kallisti> dmwit: at least it's lazy.
10:48:41 <saeidw> byorgey, one second while I mentally parse that!
10:48:53 <byorgey> ... doesn't really work for that I guess
10:49:09 <berr> if you do something like factorial (factorial 100) is lamdabot going to be safe?
10:49:22 <kallisti> yes
10:49:26 <byorgey> berr: only one way to find out! ;-)
10:49:46 <berr> I did it on my laptop the other day and it caused problems
10:49:48 * kallisti ***spoilers***
10:49:51 <berr> :)
10:49:52 <byorgey> berr: but yes, lambdabot has strict limits on time, memory, and length of output
10:49:54 <koltar> berr: that'll crash my visual cortex before it crashes lambdabot
10:50:12 <berr> byorgey:  ahh I would think so
10:50:18 <int-e> berr: it's not even 160 digits ...
10:50:45 <berr> int-e: yeah I was surprised it was so troublesome
10:50:46 <dmwit> int-e: Are you sure? Did you see the double call to factorial?
10:50:46 <byorgey> berr: right, ghci will just evaluate whatever you tell it to.  lambdabot has lots of extra protections on top of that so it won't crash, is secure, etc.
10:50:52 <int-e> > length (show (product [1..100]))
10:50:53 <lambdabot>   158
10:50:56 <berr> lol
10:51:12 <koltar> int-e: it's 100!!, not 100!
10:51:14 <dmwit> int-e: factorial (10^158) seems like it would reasonably cause problems.
10:51:23 <int-e> ah
10:51:29 <int-e> dmwit: no I didn't.
10:51:31 <berr> no I thought it might cause problems but I didn't think it would choke the computer
10:51:42 <int-e> dmwit: seems a silly thing to do :)
10:51:52 <dmwit> #haskell is a silly place
10:52:06 <koltar> we have fun with Haskell, and it shows
10:52:09 <int-e> @pl \d o t -> t o d o
10:52:09 <lambdabot> join . (flip .) . flip (flip . flip id)
10:52:25 <connelly> so I'm trying to work with Text.Disassembler.X86Disassembler - it's using parsec, when I send it a bytestream to parse, if the last instruction is bad, the whole parse fails (Either ParseError, [Instructions]) is this just bad design or am I not getting something?
10:52:26 <berr> making a factorial function is in learn you a haskell so NATURALLY the first thing I thought of was calling it inside itself
10:53:21 <int-e> > product [2,4..100] -- the *other* 100!!
10:53:23 <lambdabot>   342432247025119762482464328952081859751186750537191988279156544634880000000...
10:53:37 <dmwit> connelly: That is how it's designed. Whether that's a bad design or not is a tougher question to answer, I guess.
10:53:42 <berr> it may  have just been factorial(factorial 10) even
10:53:51 <berr> I don't remember
10:53:57 <berr> but all my chrome windows crashed
10:54:07 <berr> ium
10:54:25 <dmwit> If the point was to complain and get some commiseration, then... "Dang, that sucks.". ;-)
10:55:00 <berr> sharing purposes
10:55:13 <koltar> if you're not crashing your system regularly, you're not being crazy enough
10:57:36 <connelly> dmwit: is that a common parsec idiom?
10:58:50 <ski> @type [ask,asks]
10:58:51 <lambdabot> [(r -> a) -> r -> a]
10:59:27 <typoclass> @type ask
10:59:29 <lambdabot> MonadReader r m => m r
10:59:35 <supki> @ty [ask, asks, (%%~)]
10:59:37 <lambdabot> [(p a (f b) -> q s (f t)) -> p a (f b) -> q s (f t)]
10:59:43 <ski> > let doubleFactorial n = [n,n-2 .. 1] in doubleFactorial 100
10:59:45 <lambdabot>   [100,98,96,94,92,90,88,86,84,82,80,78,76,74,72,70,68,66,64,62,60,58,56,54,5...
11:00:14 <ski> hm, `product' ... oh, and int-e
11:00:43 <int-e> berr: I'm inclined to say that factorial(factorial 10) should not be a problem, except that it will take a long long time to print the result. running with about 200M of memory in ghci, using this code: let foldb _ [x] = x; foldb f xs = foldb f (pairup f xs); pairup f (x:y:xs) = f x y : pairup f xs; pairup _ xs = xs; factorial n = foldb (*) [1..n] in factorial (factorial 10)
11:01:23 <tac> @type ((>>=),(=<<))
11:01:25 <lambdabot> (Monad m1, Monad m) => (m a -> (a -> m b) -> m b, (a1 -> m1 b1) -> m1 a1 -> m1 b1)
11:01:52 <Taneb> @djinn (s -> (a, s)) -> (a -> s -> (b, s)) -> s -> (b, s)
11:01:53 <lambdabot> f a b c =
11:01:53 <lambdabot>     case a c of
11:01:53 <lambdabot>     (d, e) -> b d e
11:02:23 <berr> int-e: I can see the matrix
11:02:35 <int-e> > let foldb _ [x] = x; foldb f xs = foldb f (pairup f xs); pairup f (x:y:xs) = f x y : pairup f xs; pairup _ xs = xs in foldb f [a,b,c,d,e]
11:02:37 <lambdabot>   f (f (f a b) (f c d)) e
11:02:46 <int-e> aka "tree fold"
11:05:18 <byorgey> factorial (factorial 10) has about 22 million digits
11:05:38 <byorgey> so not outside the realm of possibility.
11:06:13 <tac> @let factdigs n = length . read $ product [1..n]
11:06:15 <lambdabot>  <local>:12:30:
11:06:15 <lambdabot>      No instance for (Num String)
11:06:15 <lambdabot>        arising from a use o...
11:06:26 <yitz> byorgey: just curius. did you count them, or did you use sterling?
11:06:35 <yitz> *curious
11:07:15 <tac> @let factdigs n = length . show $ product [1..n]
11:07:16 <byorgey> yitz: I used Wolfram Alpha.
11:07:18 <tac> durr
11:07:18 <lambdabot>  Defined.
11:07:23 <yitz> hah even better
11:07:27 <tac> > map factdigs [0..]
11:07:31 <lambdabot>   mueval-core: Time limit exceeded
11:07:43 <tac> > take 4 (map factdigs [0..])
11:07:47 <lambdabot>   mueval-core: Time limit exceeded
11:07:47 <byorgey> yitz: I thought about using Sterling but decided to be lazy.
11:08:27 <tac> odd, why isn't that working?
11:08:35 <byorgey> tac: dunno, try again
11:08:35 <tac> > factdigs 2
11:08:38 <lambdabot>   1
11:08:41 <tac> > factdigs 4
11:08:44 <lambdabot>   2
11:08:49 <tac> > map factdigs [1..4]
11:08:52 <lambdabot>   [1,1,1,2]
11:08:54 <tac> > map factdigs [1..]
11:08:57 <lambdabot>   [1,1,1,2,3,3,4,5,6,7,8,9,10,11,13,14,15,16,18,19,20,22,23,24,26,27,29,30,31...
11:08:58 <byorgey> sometimes lambdabot just gets in a snit
11:09:00 <tac> there :)
11:09:04 <yitz> tac: length forces the entire thing to be calculated
11:09:34 <yitz> oh i see nm
11:09:41 <ski> @let halve :: [a] -> ([a],[a]); halve [    ] = ([],[]); halve (a:as) = (a:odds,evens) where (odds,evens) = halve as; infixr 5 /\/; (/\/) :: [a] -> [a] -> [a]; [       ] /\/ odds =     odds; (a:evens) /\/ odds = a : odds /\/ evens
11:09:41 <byorgey> > factdigs 0  -- nothing wrong with this one either
11:09:44 <lambdabot>   1
11:09:45 <lambdabot>  Defined.
11:09:47 <tac> yeah. Length only seqs the spine
11:09:50 <tac> which is all I need
11:10:43 <byorgey> > halve [1,2,3,4]
11:10:46 <lambdabot>   ([1,2,3,4],[])
11:10:49 <byorgey> thought so
11:11:03 <int-e> hehe.
11:11:26 <ski> oh, right
11:11:29 <byorgey> it works for sufficiently large values of 0.5
11:11:31 <ski> @define
11:12:03 <crl> @ty Nothing (Just . (+0))
11:12:05 <lambdabot>     The function `Nothing' is applied to one argument,
11:12:05 <lambdabot>     but its type `Maybe a0' has none
11:12:05 <lambdabot>     In the expression: Nothing (Just . (+ 0))
11:13:01 <crl> @ty (Just . (+0))
11:13:03 <lambdabot> Num a => a -> Maybe a
11:13:04 <ski> @let everyOthers :: [a] -> ([a],[a]); everyOthers [    ] = ([],[]); everyOthers (a:as) = (a:odds,evens) where (evens,odds) = everyOthers as; infixr 5 /\/; (/\/) :: [a] -> [a] -> [a]; [       ] /\/ odds =     odds; (a:evens) /\/ odds = a : odds /\/ evens
11:13:06 <lambdabot>  Defined.
11:13:21 <int-e> > transpose . unfoldr (ap ((>>) . guard . not . null) (return . splitAt 2)) $ [1..7]
11:13:24 <lambdabot>   [[1,3,5,7],[2,4,6]]
11:15:40 <int-e> > transpose . takeWhile (not . null) . map (take 2) . iterate (drop 2) $ [1..7]
11:15:42 <lambdabot>   [[1,3,5,7],[2,4,6]]
11:16:05 <tac> > transpose [[1], [2, 3]]
11:16:08 <lambdabot>   [[1,2],[3]]
11:16:26 <byorgey> > transpose . chunksOf 2 $ [1..7]
11:16:28 <lambdabot>  Terminated
11:16:34 <byorgey> > transpose . chunksOf 2 $ [1..7]
11:16:37 <lambdabot>   [[1,3,5,7],[2,4,6]]
11:17:40 <adek> Have you got some clues how to test code which makes havy use of Channels? I have one input channel, it passes messages around to some threads and it produces output on a few channels?
11:19:11 <koltar> adek: maybe check that correct messages are being sent to threads, etc.? i'm not familiar with Channels, so i'm just guessing
11:19:36 <adek> I was thinking about establishing a bunch of channels. Setting up input list and feeding input to the input channel and then for each output channel have list of expected output which then I can assert if they are equal?
11:20:16 <koltar> that's basically what i meant; you're talking unit testing, not integration testing, right?
11:20:51 <adek> Its quite big unit, but yeah. That is basically it
11:21:07 <Jeanne-Kamikaze> funny how the javascript section on the wiki is entitled "the javascript problem", as if it were a CS problem like p vs np
11:22:45 <kallisti> so as it turns out
11:23:14 <kallisti> using threads greatly simplifies the logic of handling events in an IRC bot.
11:23:29 <koltar> kallisti: i'll buy that
11:23:47 * kallisti has a working IRC bot in Haskell
11:23:48 <kallisti> nothing fancy
11:24:14 <kallisti> currently it just looks up URLs and spits out their <title>
11:24:16 <crl> i want one fort xmas
11:24:41 <koltar> kallisti: mind sharing the code?
11:25:18 <kallisti> koltar: after I clean it up a bit I'll put it on github, though you may need to remind me that you wanted to see it
11:26:04 <koltar> cool. i'm working on a bot for dAmn, and i'd like to look at an IRC bot
11:26:40 <kallisti> ah okay
11:26:53 <kallisti> koltar: well I kind of cheat and using an IRC parsing library
11:26:58 <kallisti> but it's not cheating because I wrote said library
11:27:17 <koltar> ah, the parsing was really what i was looking for
11:28:15 <kallisti> koltar: well here is a severely out-of-date version of the code I'm running: https://github.com/kallisti-dev/irc-conduit/blob/master/Network/IRC/Conduit/Raw.hs
11:28:24 <koltar> my bot isn't purely a bot, though; it's more like a scriptable third-party dAmn client
11:28:29 <kallisti> note that I'll be renaming it to irc-bytestring and probably getting rid of most of the conduit stuff
11:28:34 <kallisti> and it's not on hackage (until I do all of that)
11:29:12 <BrianHV> [A
11:29:13 <BrianHV> [A
11:29:15 <BrianHV> oops
11:29:17 <kallisti> also that version of the parser is slightly broken (turns out using attoparsec's takeWhile inside <|> is a bad idea because takeWhile never fails)
11:30:32 <koltar> thanks
11:30:40 * koltar really needs to learn Parsec
11:31:35 <kallisti> but yes, using threads makes event-based logic much simpler in IRC clients. You just spawn a thread that waits on the event. In a single-threaded asynchronous system that would be a big headache
11:33:21 <koltar> for me, event-based logic just screams "thread me!"
11:34:02 <simpson> Well, it depends on how powerful your threads are.
11:34:22 <crl> if your threads keeps interacting, it may suck
11:34:24 <simpson> If they're undecideable in order of execution and context switching, then things get unfun really fast.
11:34:36 <dgpratt> as a C# programmer by trade, threads terrify me
11:35:00 <simpson> I write Python all day, and I will gladly keep my Twisted around, TYVM.
11:35:18 <kallisti> that's because Python has terrible concurrency support
11:35:22 <koltar> i learned about threads from Java, but never worked up the courage to use them until Erlang
11:35:27 <kallisti> Twisted actually looks appealing in comparison. :P
11:36:41 <napping> Twisted seems to appromixate the semantics of threads+STM, by making you CPS everything yourself and then just running one thread at a time
11:37:05 <simpson> kallisti, napping: Uh, sorry, what.
11:37:23 <simpson> napping: Twisted gives you Deferred, which is very roughly Cont.
11:37:34 <simpson> Or EitherT Cont, really.
11:37:52 <sproingie> twisted has defgen which is a bit like a CPS transform macro ... actually i'm not sure how defgen works
11:38:15 <kallisti> so far the biggest headache in debugging threads for my Haskell IRC bot has had nothing to do with the code itself
11:38:25 <kallisti> I simply forgot to add -threaded to my ghc options. :P
11:38:35 <simpson> sproingie: defgen.py died a horrible flaming death almost a decade ago. :T
11:38:52 <kallisti> which results in fun things like 'threadDelay' causing the entire program to sleep (instead of a single thread)
11:38:53 <sproingie> ok so i havent kept up :)
11:38:55 <napping> yeah, explicitly breaking up your code into chunks of callbacks, and then the system runs chunks at a time as events (IO) come in
11:39:01 <ski> @let halve :: [a] -> ([a],[a]); halve as = race as as where {race     [    ] [] = (  [],[ ]); race xs0@(_:_ ) [    ] = (  [],xs0); race     (x:xs) (_:[]) = (x:[],xs ); race (x:xs) (_:_:ys) = (x:front,back) where (front,back) = race xs ys}
11:39:03 <lambdabot>  Defined.
11:39:28 <simpson> The SON OF DEFGEN, inlineCallbacks, is alive and well, and works fine as long as you're willing to accept a slight performance hit.
11:39:32 <napping> with some control of interference through variables because only one is running at a time
11:39:42 <sproingie> i wish Deferred was like Either.  it has a Left (Failure) but no such encapsulation for success
11:40:01 <sproingie> and the things it has to do to deal with that is ... horrific
11:40:10 <simpson> napping: Nope, the *entire* computation is run once it's started. Deferreds don't actually contain any concurrency information, they just let you delay (defer!) a computation until after a value becomes available.
11:40:13 <ski> @let riffle,raffle :: [a] -> [a]; riffle = uncurry (/\/) . halve; raffle = uncurry (++) . everyOthers
11:40:15 <lambdabot>  <local>:3:47:
11:40:15 <lambdabot>      Not in scope: `/\/'
11:40:15 <lambdabot>      Perhaps you meant `//' (imported...
11:40:30 <koltar> simpson: so basically a promise or thunk?
11:40:55 <simpson> sproingie: Uh, it pretty much is. If something's currently succeeding, then it's on the success side, just like how Either's Monad/Applicative/Functor instance is on the Right.
11:41:17 <simpson> koltar: Yes, except Deferreds only fire once and promises keep their value available as long as they live.
11:41:20 <ski> > riffle "abcdefgh"
11:41:23 <lambdabot>   "aebfcgdh"
11:41:25 <sproingie> simpson: except from what I could tell, it's either an instance of Failure or anything else
11:41:32 <ski> > raffle "abcdefgh"
11:41:34 <lambdabot>   "acegbdfh"
11:41:35 <sproingie> simpson: that's duck typing for you
11:41:38 <simpson> sproingie: Either Failure a
11:42:12 <simpson> sproingie: That phrase does not mean what you think it means.
11:42:50 <sproingie> except you get at it with Right a, whereas with Deferred it's basically just a
11:42:51 <napping> Well, I'm talking specifically about the event-driven part rather than the success handling/promise stuff - the style where you use a Deferred to say what should happend once some IO finishes, and the body of that deferred (running all at once) makes a further request using a second Defered to chain handling it
11:43:20 <sproingie> no "need" to unwrap it.  which results in some funny gyrations when exceptions get into the mix
11:43:23 <napping> I've forgotten most of the stuff about chaining multiple actions and success vs. failure continuations
11:44:00 <koltar> it's nice to actually understand the conversation in #haskell for once
11:44:00 <jfischoff> preflex seen DanBurton
11:44:00 <preflex>  DanBurton was last seen on #haskell-lens 18 hours, 48 minutes and 40 seconds ago, saying: can you even write an instance for anything other than (->) ?
11:44:13 <Taneb> preflex is back!
11:44:17 <Taneb> preflex, seen shapr
11:44:17 <preflex>  shapr was last seen on #haskell-blah 29 days, 23 hours, 55 minutes and 12 seconds ago, saying: Solution? get business class internet
11:44:26 <Taneb> I miss shapr
11:44:39 <jfischoff> yeah I wonder why he doesn't hang here so much
11:44:56 <napping> Anyway, I'm really just claiming that the way GHC runs threads under the hood is very similar to any event-driven system, just with a surface programming model of blocking operations and threads of control
11:44:56 <koltar> i think his last words give us a hint :P
11:45:03 <aristid> Taneb: he's active on google+
11:45:12 <shachaf> Probably because #haskell is full of mean nasty people (like me).
11:45:23 <Taneb> aristid, do you know if he got a Raspberry Pi in the end
11:45:36 <jfischoff> shachaf: you ruin everything
11:45:50 <aristid> Taneb: no idea
11:49:07 <koltar> parsec is exactly the kind of library i wanted when looking at flex/bison -- the parallels between lexing and parsing were compelling, so i wanted a generic library that could do both
11:49:41 <Taneb> Because I started with parsec, I never figured out the difference between lexing and parsing
11:49:47 <Taneb> Not that I've tried to figure out the difference
11:50:08 <sproingie> lexer is sort of a degenerate parser in its own way
11:50:18 <koltar> Taneb: IMO there isn't much of one; lexing is basically parsing on individual characters
11:50:37 <sproingie> a lexer tends to stick to a regular grammar
11:50:52 <sproingie> thus the fondness for regexes
11:51:01 <shachaf> jfischoff: I do, don't I.
11:51:16 * koltar will have nightmares of context-dependent lexers
11:51:26 <Hask00ler_> What's my issue with this code?
11:51:27 <hpaste> Hask00ler_ pasted “-” at http://hpaste.org/83638
11:51:42 <jfischoff>  shachaf: well not as well as I do, but your getting there
11:51:54 <sproingie> i have nightmares of trying to convince antlr to parse a line-oriented format
11:52:18 <hpaste> LambdaDusk pasted “Load.hs” at http://hpaste.org/83639
11:52:22 <sproingie> antlr has ideas about whitespace that it hates you dearly for trying to override
11:52:22 <byorgey> Hask00ler_: that code looks fine to me
11:52:25 <shachaf> jfischoff: I'll have to keep on practicing.
11:52:27 <monochrom> > [x*2 | x <- [1..10], x*2 >= 12]
11:52:29 <lambdabot>   [12,14,16,18,20]
11:52:32 <byorgey> Hask00ler_: does it give you an error? Or just not compute what you expect?
11:52:38 <LambdaDusk> can anyone help me with the snippet above, I don't see the error
11:52:39 <monochrom> works, what issue?
11:52:44 <jfischoff> shachaf: I have faith in you
11:52:50 <ski> does either of Twisted and Deferred give anything like promises and promise pipelines in E ?
11:52:58 <byorgey> Hask00ler_: if this is part of a larger program, you will have to show us the whole thing
11:53:11 <Hask00ler_> byorgey: It gives me the error: parse error on input `,`
11:53:16 <ski> napping ^
11:53:16 <Hask00ler_> byorgey: it's not
11:53:32 <koltar> LambdaDusk: i think `is' is a keyword
11:53:42 <byorgey> Hask00ler_: are you typing this at the ghci prompt?
11:53:49 <Hask00ler_> byorgey: Yes
11:53:49 <byorgey> Hask00ler_: or do you have it in a .hs file?
11:54:03 <Hask00ler_> byorgey: First option
11:54:15 <simpson> ski: Funny that you should mention E. dash and I have a little project going in that direction. Will you be at Pycon?
11:54:17 <napping> ski: I don't think anything but E has E-style promise pipelining, not sure about simple promises.
11:54:21 <byorgey> Hask00ler_: what version of ghc?
11:54:36 <ski> simpson : i don't know Python
11:54:36 <Hask00ler_> byorgey: 7.4.2
11:54:48 <monochrom> > do { is <- Just 5; return is }
11:54:49 * ski . o O ( <http://en.wikipedia.org/wiki/Futures_and_promises#Promise_pipelining> )
11:54:50 <lambdabot>   Just 5
11:54:57 <monochrom> "is" is not a keyword
11:54:59 <byorgey> Hask00ler_: can you copy and paste the contents of the entire ghci session?  i.e. start up ghci, type in that expression, then copy the contents of the entire window
11:55:02 <simpson> ski: Aw. Well, uh, watch this space, I guess.
11:55:14 <jfischoff> I need some help higher ranked types
11:55:24 <koltar> monochrom, LambdaDusk: nvm then
11:55:25 <jfischoff> anyone up to the challenge?
11:55:56 * ski ranks up the type
11:56:01 <shachaf> jfischoff: You should just ask your question. :-)
11:56:01 <jfischoff> yes!
11:56:07 <monochrom> I am a total n00b on higher ranked types
11:56:09 <jfischoff> ski in the house!
11:56:17 <kallisti> koltar: https://github.com/kallisti-dev/irc-bytestring/blob/master/src/Network/IRC/ByteString/Parser.hs
11:56:21 <shachaf> monochrom: What's a partial higher-ranked type?
11:56:22 <kallisti> koltar: IRC parser
11:56:24 <LambdaDusk> koltar: I exchanged the variable name and even put f to the to namespace and still get that error
11:56:25 <ski> (or maybe "types up the rank" ?)
11:56:37 <byorgey> LambdaDusk: it's probably to do with indentation
11:56:47 <Hask00ler_> byorgey: Now that I've restarted it it works, I'm using the exact same code though
11:56:50 <monochrom> (forall a. a->a) -> b seems to be a partial higher-ranked type
11:56:55 <byorgey> though off the top of my head I cannot see what is wrong
11:56:56 <ski> jfischoff : where !?
11:56:59 <jfischoff> ski: http://hackage.haskell.org/packages/archive/lagrangian/0.2.0.2/doc/html/Numeric-AD-Lagrangian.html
11:57:04 <jfischoff> so that is my code
11:57:07 <byorgey> Hask00ler_: that's very strange!
11:57:10 <jfischoff> but I don't like it
11:57:25 <koltar> LambdaDusk: maybe tab/space issues?
11:57:30 <Hask00ler_> byorgey: I know, I wouldn't of expected restarting it to help. Thanks for the help though
11:57:46 <byorgey> LambdaDusk: yes, check that you don't have any tab characters
11:57:49 <jfischoff> I am confused about how Numeric.AD
11:58:32 <jfischoff> can take [a] -> a and use it  (forall s. [AD s a] -> AD s a)
11:58:45 <jfischoff> I would like to do something similar
11:58:49 <monochrom> tab is not the issue. hpaste would show tab issues
11:59:02 <jfischoff> in the since that
11:59:09 <monochrom> but I don't understand the line "g i@PathImage{..} = (takeExtension iSource) == ".tga" ->"
11:59:10 <ski> jfischoff : `x -> x * log x'
11:59:11 <jfischoff> I having this Floating constraint there
11:59:27 <monochrom> why is it not: g i@PathImage{..} | (takeExtension iSource) == ".tga" =
11:59:28 <jfischoff> it should just be Num
11:59:44 <koltar> kallisti: thanks again
12:00:02 <jfischoff> but actually in practice I will have to the make the constraint RealFloat
12:00:02 <tac> When doing traditional algorithms in Haskell, do you usually consider the space and time complexity when you have to deep-seq your output?
12:00:23 <jfischoff> because I can't figure out how to make the polymorhpic values that are part of constraint
12:00:30 <jfischoff> one sec that isn't clear
12:01:02 <Hask00ler_> byorgey: I'm now getting the same issue, I have to restart GHC every time I want to do one line
12:01:36 <byorgey> Hask00ler_: hmm, can you paste the output now?  Also, are you on Windows, OSX, linux...?
12:01:44 <hpaste> “Jonathan Fischoff” pasted “the type signature I want” at http://hpaste.org/83640
12:01:48 <jfischoff> ^ I want this type signature
12:02:03 <jfischoff> or something as close to it as possible
12:02:05 <Hask00ler_> byorgey: I usually use BSD but I'm on my laptop since I'm not home right now, so I'm on Windows
12:02:12 <ski> jfischoff : and s/about/amount/ ?
12:02:23 <koltar> Hask00ler_: did you type the code into HPaste, or did you copy/paste?
12:02:29 * hackagebot irc-bytestring 0.1 - serialization and parsing of IRC messages  http://hackage.haskell.org/package/irc-bytestring-0.1 (AdamCurtis)
12:02:38 <Hask00ler_> koltar: copy/paste
12:03:05 <koltar> Hask00ler_: perhaps Windows is mangling the comma?
12:03:18 <jfischoff> so first do I need to have the higher ranked types uncurried like that?
12:03:53 <kallisti> koltar: ^ whenever that link generates documentation you can read it on hackage, but there's not really any documentation because for the most part it's pretty obvious from the type signatures
12:04:12 <Hask00ler_> byorgey: Strangely problems are now working
12:04:29 <monochrom> sunspot activities
12:04:46 <Hask00ler_> koltar: Doesn't seem like it since they're all working now
12:05:00 <byorgey> A Heisenbug! exciting.
12:05:16 <ski> jfischoff : are you passing those arguments to a function with higher-ranked type ?
12:05:17 <kayloos> I'm having trouble getting a parser to fall through to the second case, https://gist.github.com/kayloos/afe624b882731eb38d4d for simplified example
12:05:30 <jfischoff> ski: yes
12:05:44 <byorgey> kayloos: parsec does not backtrack unless you explicitly request it to
12:05:47 <ski> jfischoff : then you'd need to be higher-ranked yourself
12:05:50 <monochrom> which line is "the second case"?
12:06:02 <ski> jfischoff : perhaps you wanted `RealFloat' instead of `Floating' in the rank-`2' type ?
12:06:23 <byorgey> kayloos: replace 'lookUp' with 'try lookUp' if you want it to backtrack
12:07:03 <hpaste> “Anonymous Coward” annotated “the type signature I want” with “the type signature I want (annotation)” at http://hpaste.org/83640#a83641
12:07:22 <kayloos> byorgey: ok thanks. That's what i thought <|> was for, since for the expression function in my example, it falls through correctly
12:07:29 <jfischoff> ski: should I be able to do this? http://hpaste.org/raw/83641
12:07:48 <byorgey> kayloos: if you have   foo <|> bar  and  foo fails *without consuming any input* it will fall through to bar.
12:07:54 <jfischoff> or do the two higher ranked types have to be in a tuple
12:08:05 <jfischoff> which is the only way I have gotten it to work
12:08:06 <byorgey> kayloos: but if foo consumes some input first and then fails, it does not backtrack so it cannot fall through.
12:08:35 <byorgey> kayloos: 'try foo' is a parser which acts like foo except backtracks when it fails, so that it puts any consumed input back in the input stream
12:09:24 <kayloos> byorgey: Ahhh, thanks... i was really having trouble understanding this. I'm super glad you helped!!
12:09:32 <kayloos> no homo
12:09:40 <Hask00ler_> very homosexual.
12:09:58 <byorgey> kayloos: this is the most annoying aspect of parsec, but it enables parsers to be much more efficient
12:10:30 <kallisti> how does attoparsec get away with no requiring it?
12:10:52 * kallisti uses attoparsec for most things.
12:10:58 <ski> jfischoff : i don't think you'd need a tuple, no
12:11:19 <kallisti> Parsec is nice when you need to parse a programming language. attoparsec is sufficient for simple parsing.
12:11:37 <byorgey> kallisti: I dunno.
12:12:11 <ski> (`forall a. (f a,g a)' is logically equivalent to `(forall a. f a,forall a. g a)' -- hopefully both variants (as well as the curried one) would work)
12:13:48 <jfischoff> I imagine though I might need the uncurried way if I have forall a. f a -> forall a. g a and the a's have to be the same?
12:16:17 <ski> that type is not equivalent to `forall a. f a -> g a', if that's what you meant, yes
12:16:32 <ski> (but i'm not sure what this would have to do with "the uncurried way")
12:17:00 <monochrom> advice: every time you write forall, use a different variable name. example: forall a. f a -> forall b. g b
12:17:16 <monochrom> or perhaps you meant forall a. f a -> forall b. g a
12:17:25 <jfischoff> look at the second argument of http://hackage.haskell.org/packages/archive/lagrangian/0.2.0.2/doc/html/Numeric-AD-Lagrangian.html#v:solve
12:17:46 <jfischoff> I pass in a tuple but I would rather that be two args
12:20:05 <jfischoff> ski: I see what you mean s/about/amount
12:20:06 <jfischoff> yeah
12:20:16 <ski> jfischoff : and the other typo
12:20:59 <monochrom> likely: Double -> (forall a. Floating a => [a] -> a) -> (forall b. Floating b => [Constraint b]) -> the rest
12:21:21 <ski> jfischoff : yes, when you said `forall a. f a -> forall b. g b', i was actually assuming you meant `(forall a. f a) -> (forall b. g b)', rather than `forall a. (f a -> (forall b. g b))', which is how GHC (and Hugs) would read it
12:21:53 <monochrom> advice: add more parentheses
12:22:03 <jfischoff> so it should be possible to separate those?
12:22:20 <jfischoff> monochrom: to help the typechecker or for style?
12:22:41 <monochrom> to help humans
12:22:48 <ski> jfischoff : depends on which of the interpretations you intended
12:23:24 <monochrom> I think the separation does not make a difference to the callee. the separation may affect the caller, as in more convenient vs less convenient
12:24:39 <jfischoff> monochrom: what do you mean by seperation?
12:25:02 <monochrom> separation means preferring Double -> (forall a. Floating a => [a] -> a) -> (forall b. Floating b => [Constraint b]) -> the rest
12:25:39 <jfischoff> okay
12:28:15 <armlesshobo> when one types a program in a terminal and they are missing an argument, the program usually outputs an error/usage message and exits. Is there a proper way of doing that in Haskell?
12:28:32 <armlesshobo> or is it like "just do what you think is best"?
12:28:38 <jfischoff> cmdargs opt-parse-applicative
12:28:47 <jfischoff> @where cmdargs
12:28:48 <lambdabot> I know nothing about cmdargs.
12:28:54 <donri> @hackage optparse-applicative
12:28:54 <lambdabot> http://hackage.haskell.org/package/optparse-applicative
12:29:06 <jfischoff> @hackage cmdargs
12:29:07 <lambdabot> http://hackage.haskell.org/package/cmdargs
12:29:21 <donri> i recommend optparse-applicative
12:30:30 <jfischoff> how is that the grad function in ad grad :: (Traversable f, Num a) => (forall s. Mode s => f (AD s a) -> AD s a) -> f a -> f a
12:30:38 <jfischoff> can work when I pass in [a] -> a
12:31:00 <jfischoff> how does that type check since it isn't Mode s => f (AD s a) -> AD s a
12:31:24 <shachaf> It's more general, though.
12:31:28 <shachaf> @ty length
12:31:30 <lambdabot> [a] -> Int
12:31:34 <shachaf> @ty length :: Num a => [a] -> Int -- still works
12:31:36 <lambdabot> Num a => [a] -> Int
12:31:42 <shachaf> @ty length :: (Num a, Show a) => [a] -> Int -- still works
12:31:44 <lambdabot> (Num a, Show a) => [a] -> Int
12:31:52 <shachaf> @ty length :: [Char] -> Int -- still works
12:31:54 <lambdabot> [Char] -> Int
12:32:10 <jfischoff> [a] -> a is more general?
12:33:10 <shachaf> (forall a. [a] -> a) is more general than (forall a. Foo a => [a] -> a)
12:33:12 <jfischoff> ah okay so Num a =>  AD s a is an instance of Num
12:33:12 <monochrom> where can I find some instacnes of Mode?
12:33:28 <jfischoff> I guess
12:34:08 <connelly> so Text.Disassembler.X86Disassembler has a function that takes a list of inputs and returns the results wrappen in a paramterized type monad - why did they do that? that makes it so hard to work with
12:35:34 <connelly> disassembleList :: Monad m => [Word8] -> m (Either ParseError [Instruction])
12:35:45 <connelly> why did they wrap the Either in an m?
12:36:31 <monochrom> you can pick m = Identity, then it is just as good as a pure function
12:36:37 <shachaf> connelly: That seems a bit pointless to me.
12:36:52 <shachaf> monochrom: Because the type works for any m, it is *always* as good as a pure function.
12:36:53 <monochrom> but the Either is for bad input
12:37:04 <shachaf> (forall m. Monad m => m A) ~ A
12:37:05 <connelly> monochrom: oh, interesting - I get the Either part
12:37:23 <sproingie> you'd think you could just lift it as needed
12:37:27 <monochrom> shachaf, my explanation is more elementary
12:37:53 <shachaf> monochrom: Explanation of what?
12:37:58 <shachaf> This seems like a pointless API to me.
12:38:25 <shachaf> I agree with connelly that it makes it more annoying to work with, and I don't see the point. But perhaps I'm missing something.
12:38:29 <monochrom> of why (forall m. Monad m => m A) ~ A
12:39:19 <monochrom> which sentence did I say that implied that I argue for this API choice?
12:39:38 <shachaf> None. connelly's question was "why did they do that?", so that's what I was wondering about.
12:39:51 <connelly> so if I had a list of results, I could just map runIdentity to the list and I'd remove the monad and have a list of Eithers?
12:39:57 <monochrom> ok, I forgot to answer why, I only answered how to use it
12:40:08 <shachaf> Oh. I didn't see that question at all.
12:40:44 <shachaf> connelly: runIdentity . disassembleList :: [Word8] -> Either ParseError [Instruction]
12:41:22 <monochrom> perhaps because it may use "fail"
12:41:33 <shachaf> Oh. "fail" :-(
12:41:42 <shachaf> Does it actually use it?
12:41:57 <monochrom> but they have that Either ParseError already. they don't need fail
12:41:59 <Hask00ler_> I have a challenge for you people, create a FizzBuzz in Haskell
12:42:30 <monochrom> it is either a historical relic or a mistake
12:42:38 <mauke> Hask00ler_: BTDT
12:42:41 <Hask00ler_> A FizzBuzz is a program that makes every number evenly divisible by 3 should be replaced with Fizz
12:42:45 <Hask00ler_> mauke: BTDT?
12:44:20 <ecuderpam> Hask00ler_: And every number evenly divisible by 5 should be replaced with Buzz.
12:44:31 <Hask00ler_> ecuderpam: Yep
12:44:39 <ecuderpam> Hask00ler_: Numbers divisible by both (i.e., divisible by 15) should be replaced with FizzBuzz.
12:44:45 <geekosaur> Hask00ler_, homework? not like you're the only one to waltz in here and ask about fizzbuzz recently. sounds like a challenge for *you*, not necessarily for us...
12:44:46 <Hask00ler_> ecuderpam: beat me to it :c
12:44:47 <ecuderpam> BTDT = been there, done that
12:44:49 <monochrom> I confess I do suffer from the YZ Answer problem. you ask "why", but I tend to answer "how to use it". also, Y rhymes with "why"
12:44:59 <geekosaur> not that we're unwilling to help, emphasis on help, not write for you
12:45:45 <Hask00ler_> geekosaur: It is a challenge for me, yes. But that's not why I asked. Simply wondering how many people in here can do it.
12:46:19 <shachaf> I hope no one ever gives "write fizzbuzz" as homework.
12:46:22 <ecuderpam> would you mind not stealing my interview questions? :)
12:46:32 <kayloos> Everybody in here can do it, given enough time and motivation
12:46:41 <monochrom> because when it comes to someone else's design decision, "why" is usually pointless. do you want to use their design? yes or no? if yes, how to use it is more relevant, not why. if no, then the whole thing is irrelevant.
12:46:45 <dogmaT_> `/quit
12:47:21 <shachaf> monochrom: Not from the perspective of someone learning Haskell.
12:48:33 <shachaf> Alternatively: If I want to pick which library to use among a few options, I don't want to pick one which makes silly API decisions if I can help it.
12:49:05 <shachaf> If I see that program A has a bizarre API and program B doesn't, I might ask #haskell why, to see whether the bizarre API is justified.
12:49:07 <monochrom> after you use it, you will see why, or you will see there is no reason
12:50:52 <mauke> monochrom: a bold claim
12:54:19 <shachaf> I think a "why" question is reasonable to ask here.
12:54:22 <shachaf> I don't know the answer.
12:55:01 <levi> I agree; I like knowing the motivation behind design choices.
12:55:33 <monochrom> and I say, use it to find out
12:56:09 <roadfish> How do I do a lazy lambda? This is a function with a lazy argument: z ~(x,y) = ((*2) x, id y). Here is a lamdba expression \(x,y) -> ((*2) x, id y). But \~(x,y) = ((*2) x, id y) reports: parse error on input `\~'
12:56:52 <mauke> monochrom: that doesn't tell you why
12:57:49 <roadfish> have to drink the KoolAid before you find out if it's sweet
12:58:42 <levi> You may not like it and still find the motivation behind its contstruction interesting and useful.
13:00:57 <monochrom> > (\~x -> True) ()
13:00:59 <lambdabot>   <hint>:1:6: parse error on input `->'
13:01:11 <yitz> > (\ ~(x,y) -> ((*2) x, id y)) (2,3)
13:01:13 <lambdabot>   (4,3)
13:01:16 <roadfish> > (\ ~x -> True) ()
13:01:18 <lambdabot>   True
13:01:26 <monochrom> then it needs more space
13:01:29 <roadfish> ok, a bit of whitespace
13:01:45 <roadfish> right, \~ looks like another funky Haskell operator
13:01:54 <yitz> > (\ ~(x,y) = ((*2) x, id y)) (2,3) -- roadfish, there was also this problem
13:01:56 <lambdabot>   <hint>:1:11: parse error on input `='
13:02:30 <monochrom> > let x \~ y = y x in () \~ (\ ~x -> True)
13:02:32 <lambdabot>   True
13:02:37 <monochrom> yikes
13:02:43 <sproingie> oh that's readable
13:03:35 <roadfish> I figure in another 20-30 years, we'll see 7 character operations in Haskell. Will look like a swear festival.
13:03:46 <roadfish> operators, I mean
13:03:57 <mauke> dude, unicode!
13:04:04 <roadfish> > @$#$#$#$
13:04:06 <lambdabot>   <hint>:1:1: parse error on input `@$#$#$#$'
13:04:37 <Iceland_jack> mauke: If Haskell gets unicode identifiers by default it will become Agda in the blink of an eye
13:04:41 <mauke> > let x <̈ y = x ++ y in "word" <̈ "bird"
13:04:41 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
13:04:55 <mauke> Iceland_jack: ...if?
13:05:00 <mauke> it already has them
13:05:08 <monochrom> there is no conflict between using unicode and using 7 characters
13:05:12 <roadfish> I've got dips on the smiley face!
13:05:38 <sproingie> > let a ☠ b = a ++ " arr " ++ b  in "hey" ☠ "there"
13:05:38 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
13:05:41 <mauke> roadfish: which one?
13:05:51 <sproingie> huh.  it works in ghci
13:05:57 <mauke> inb4 CAT FACE WITH WRY SMILE
13:06:11 <monochrom> lambdabot has some utf-8 problems, that's all
13:06:49 <roadfish> all smiley faces are reserved for lolcat monadic transformers
13:06:53 <talamon> @v
13:06:53 <lambdabot> Exception: <<loop>>
13:06:55 <monochrom> it is just some, because I think...
13:07:03 <monochrom> > text "☠"
13:07:04 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
13:07:11 <monochrom> oh, nevermind
13:07:25 <roadfish> ☠ is for when the lolcat runs out of 9 lives
13:07:33 <monochrom> well, at least now it consistently has utf-8 problems!
13:10:04 <monochrom> > let ö = () in ö
13:10:04 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
13:10:29 <yitz> roadfish: once i wanted an infix operator for the Last monoid. I used this 733+ operator: !@$+
13:10:53 <monochrom> it may be receiving utf-8 fine and borking on sending
13:12:56 <RichyB> > let a ☺ b = 2*a + b in foldl (☺) 0 [1,1,0,0,1]
13:12:57 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
13:13:21 <RichyB> Hrmn. Works perfectly at a ghci prompt, though. :/
13:13:52 <monochrom> yes, lambdabot has utf-8 problems
13:14:39 <donri> at least she's talking about it
13:15:12 <Sgeo> Isn't foldl bad? (Should be foldl')
13:15:53 <monochrom> yes but don't worry for a toy example. how long can [1,1,0,0,1] be? :)
13:16:33 <mauke> >  mueval: recoverEncode: invаlid argument (invalid character)
13:16:33 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
13:16:46 <shachaf> foldl is not "bad".
13:16:57 <mauke> @src reverse
13:16:57 <lambdabot> reverse = foldl (flip (:)) []
13:17:00 <shachaf> It is rarely what you want, though.
13:18:18 <roadfish> @src first
13:18:19 <lambdabot> Source not found. Maybe you made a typo?
13:18:24 <shachaf> foldl' would be reasonable for reverse, I think.
13:18:33 <shachaf> Probably doesn't matter much.
13:19:00 <monochrom> haha mauke wins
13:19:20 <roadfish> how is @src provided? I'd like to get something like this in ghci. I have ":hoogle" and ":doc" and ":pl" already.
13:19:20 <yitz> used to be with -O2 that didn't matter for anything simple like sum or reverse. haven't checked lately.
13:19:36 <roadfish> @src fst
13:19:37 <lambdabot> fst (x,_) =  x
13:19:40 <donri> roadfish: lambdabot has a custom made data base
13:20:02 <donri> roadfish: and you can't really get *the* source for 'first' because it depends on the Arrow instance
13:20:09 <monochrom> the entries in @src are handwritten and not systemically curated
13:20:26 <yitz> mauke: that's one of the best quines i've ever seen
13:20:31 <shachaf> Sadly it's not a quine.
13:20:42 <yitz> shachaf: close enough
13:20:48 <roadfish> donri: where is this database sitting?
13:20:53 <donri> @list
13:20:53 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:21:09 <monochrom> it is not exactly a quine. that makes it all the more fun :)
13:21:10 <Sgeo> > foo bar baz
13:21:12 <lambdabot>   Not in scope: `foo'
13:21:12 <lambdabot>  Perhaps you meant `Data.Traversable.for' (imported fro...
13:21:22 <Sgeo> > Not in scope: `Not'
13:21:22 <donri> roadfish: http://code.haskell.org/lambdabot/State/source
13:21:24 <lambdabot>   <hint>:1:5: parse error on input `in'
13:21:40 <Sgeo> > <hint>:1:5: parse error on input
13:21:42 <lambdabot>   <hint>:1:1: parse error on input `<'
13:21:42 <sproingie> how do you get the "perhaps you meant" bit in ghci?
13:21:57 <Sgeo> > <hint>:1:1: parse error on input `<'
13:21:59 <lambdabot>   <hint>:1:1: parse error on input `<'
13:21:59 <roadfish> donri: thanks
13:22:11 <donri> sproingie: that's based on what's in scope
13:22:14 <monochrom> that's a good one too Sgeo
13:22:56 <sproingie> > maz 1 2
13:22:57 <lambdabot>   Not in scope: `maz'
13:22:57 <lambdabot>  Perhaps you meant one of these:
13:22:57 <lambdabot>    `map' (imported fro...
13:23:09 <sproingie> in ghci it just gives me "not in scope"
13:23:55 <donri> sproingie: update ghc
13:24:03 <donri> or haskell-platform
13:24:14 <sproingie> ah.  old machine, old ghci, must be why
13:24:24 <monochrom> or perhaps map is really not in scope, and nothing is in scope
13:25:02 <sproingie> prelude is.  old machine, it's running ... 7.0.4
13:26:45 <roadfish> what (almost) quine are you talking about?
13:28:01 <yitz> > (\x->text$"> "++x++show x)"(\\x->text$\"> \"++x++show x)"
13:28:04 <lambdabot>   > (\x->text$"> "++x++show x)"(\\x->text$\"> \"++x++show x)"
13:30:10 <monochrom> roadfish, it's mauke's >  mueval: recoverEncode: invаlid argument (invalid character)
13:31:24 <danharaj> hm, I have a strange problem with github. I can use my ssh key to push changes fine, but I get a permission denied error when I try to clone a repo.
13:31:27 <danharaj> (???)
13:32:56 <roadfish> so #haskell is getting github questions after switching from darcs to git
13:33:04 <monochrom> haha
13:33:39 <roadfish> danharaj: I not into github yet. But there is a huge channel at #github
13:33:46 <monochrom> some haskell projects still use darcs. expect both kinds of questions!
13:33:49 <connelly> so if I have a [Either (a,b)] , what's the best idiomatic haskell way of getting the first Right's value in the list?
13:34:00 <danharaj> roadfish: thanks
13:34:06 <monochrom> [Either a b]?
13:34:13 <connelly> yeah, sorry
13:34:29 <roadfish> connelly: rights
13:34:38 <roadfish> in Data.Either
13:34:42 <danharaj> head . rights
13:34:44 <monochrom> perhaps head [ x | Right x <- the_list ]
13:34:59 <roconnor> connelly: what if there are no Rights?
13:34:59 <roconnor> @type rights
13:35:00 <lambdabot> [Either a b] -> [b]
13:35:09 <connelly> nice!
13:35:17 <sproingie> @src rights
13:35:17 <lambdabot> Source not found. There are some things that I just don't know.
13:35:18 <roconnor> s/head/listToMaybe
13:35:20 <yitz> head.snd.partitionEithers
13:35:30 <danharaj> roconnor: then we take the runtime error on the chin and persevere.
13:35:44 <connelly> I basically did that - I made two functions and did getRight $ head $ dropWhile isLeft mylist
13:35:49 <roadfish> roconnor: I can think of other answers to you question.
13:36:09 <connelly> but I like not having to make random helper functions that throw exceptions
13:36:19 <roconnor> roadfish: my question?
13:36:49 <yitz> connelly: right. Is it OK to return a Maybe b?
13:36:52 <roadfish> roconnor: what if there are no Rights? ... sounds like a legal question.
13:36:53 <srhb> Yes
13:36:58 <srhb> If you must. :-)
13:37:16 <srhb> Mind, pattern matching on [] vs Nothing makes little difference
13:37:33 <srhb> So you're probably better off just getting rights and pattern matching the first element out, rather than taking a detour via Maybe
13:37:39 <connelly> yitz: Maybe... ;)
13:37:52 <roconnor> roadfish: :D
13:37:54 <monochrom> srhb's advice is good
13:38:08 <yitz> srhb: no with a Maybe you can use the Prelude function maybe
13:38:22 <srhb> yitz: With a list you can use Haskell's pattern matching.
13:38:35 <monochrom> with a list you can use the Prelude function foldr :)
13:38:44 <srhb> If you're providing something library-like, then I'd say go for the Maybe solution.
13:38:46 <srhb> Otherwise don't.
13:38:50 <srhb> You're just adding indirection.
13:38:57 <yitz> srhb: right. but my point is that with a Maybe you can avoid pattern matching altogether. sometimes that works out cleaner.
13:39:08 <srhb> It never works out cleaner if you have to do both.
13:39:19 <srhb> To get the Maybe, you need to pattern match.
13:39:24 <yitz> no
13:39:36 <srhb> Fine, you can use headMaybe, same difference.
13:39:45 <yitz> listToMaybe. etc.
13:39:50 <srhb> *shrugs*
13:39:52 <srhb> Do as you like.
13:39:56 <yitz> :)
13:40:36 <monochrom> maybe d f (listToMaybe (rights the_list)) = foldr (\x _ -> f x) d (rights the_list)
13:41:54 <roadfish> monoidal flamewar
13:42:34 <yitz> @pl \x _ -> f x -- monochrom, no pattern matching
13:42:34 <lambdabot> const . f
13:43:04 <monochrom> I don't so much avoid pattern matching
13:43:32 <monochrom> besides, _ is so much cheaper than Just/Nothing
13:44:16 <yitz> the compiler *ought* to optimize those away. but it doesn't always.
13:45:32 <[swift]> is there an existing library function that will fork two threads and terminate them both once either of them finishes? this is the same as the "either" function in the Asynchronous Exceptions in Haskell paper, but such a thing doesn't seem to exist in Control.Concurrent (and I notice the semantics of throwTo are different IRL than they are in the paper)
13:45:40 <connelly> what's the most efficient way to remove the last element from a list? reverse.tails.reverse ?
13:45:43 <shachaf> [swift]: "async" has that.
13:45:49 <shachaf> @hackage async
13:45:49 <lambdabot> http://hackage.haskell.org/package/async
13:45:50 <yitz> listToMaybe never made any of my programs run noticeably slower. sometimes it makes my code clearer, so i use it then. (and sometimes not, so i use pattern matching)
13:46:01 <[swift]> shachaf: super, thanks!
13:46:04 <monochrom> init is the most efficient way to remove the last element from a list
13:46:07 <connelly> s/tails/tail/
13:46:12 <shachaf> http://hackage.haskell.org/packages/archive/async/2.0.1.4/doc/html/Control-Concurrent-Async.html#v:race
13:46:56 <shachaf> I don't like the name "listToMaybe" because the function loses information. It arbitrarily picks the first element.
13:47:17 <shachaf> (maybeToList has a similar issue -- should it be (:[]) or repeat?)
13:47:36 <yitz> connelly: const []. however, sometimes it also removes other elements of the list too, unfortunately.
13:47:41 <shachaf> It should be called "head".
13:47:43 <shachaf> Alas.
13:48:01 <monochrom> consider "the adjoint functor of the free functor from Maybe to []" or something
13:48:29 <yitz> shachaf: not always a very illuminating name, right.
13:48:38 <shachaf> Free functor from Maybe to []?
13:48:40 <[swift]> oh wow, Control.Concurrent.Async is great. will be using this a great deal going forward
13:48:42 <shachaf> What is that?
13:48:45 <simpson> [swift]: I know!
13:48:52 <arkeet> shachaf: who knows.
13:48:59 <arkeet> there's a functor though.
13:49:01 <shachaf> arkeet: monochrom, presumably.
13:49:03 <arkeet> er
13:49:03 <monochrom> I am half joking and being very imprecise
13:49:05 <arkeet> a natural transformation.
13:49:13 <kqr> how does one best encode a many-to-many relation in haskell? i was initially thinking map, but that seems to be one-to-one (where the last one can be many with a list, but eh)
13:49:34 <arkeet> kqr: what do you want to do with the relation?
13:49:56 <yitz> shachaf: conceptually, listToMaybe picks an element arbitrarily from a non-empty list. it just happens always to select the first one, because that is most efficient.
13:50:01 <arkeet> you could just use a set of pairs, but that may not be very efficient for what you want to do with it.
13:50:21 <kqr> yeah, i'm thinking list of pairs currently, but i was just wondering if there exists a pre-made solution
13:50:22 <monochrom> there is something initial or free or whatever about Nothing -> [], Just x -> [x]. as opposed to Just [x] -> repeat x
13:50:33 <monochrom> err, as opposed to Just x -> repeat x
13:50:36 <arkeet> they're both natural transformations.
13:50:45 <arkeet> but are they monad morphisms?
13:50:49 <arkeet> this is important.
13:51:37 <arkeet> I'm pretty sure [] -> Nothing, (x:_) -> Just x is the only way to make it a monad morphism.
13:51:39 <monochrom> and then there is something adjoint or canonical or retract or whatever about [] -> Nothing, x:_ -> Just x being an inverse
13:51:55 <arkeet> wait.
13:52:03 <monochrom> so the categorical description is something like "... adjoint of ... free ..."
13:52:03 <arkeet> not true. you could take the last element in the list, say
13:52:13 <arkeet> monochrom: these are not functors.
13:52:30 <arkeet> Maybe and [] are functors
13:54:36 <HogNobbles> Hello, I have a simple question. I always thought you needed to use 'qualified' to import something under an alias, but I recently tried just 'import as' and it worked exactlly the same. What's the deal?
13:54:49 <HogNobbles> exactly*
13:55:08 <arkeet> HogNobbles: that imports both qualified and unqualified.
13:55:27 <monochrom> "import Prelude as P" means you can use both "id" and "P.id" to refer to the same thing
13:55:34 <HogNobbles> Oh I see. What would be the purpose of that?
13:55:45 <monochrom> "import qualified Prelude as P" means you can use only "P.id"
13:56:55 <monochrom> to give me more freedom
14:00:31 <HogNobbles> Lol. So there's no purpose really? It's just incase you feel like typing something before your functions?
14:01:39 <ab9rf> heh
14:01:53 <Hafydd> No, it's so that you can avoid name clashes from disparate modules.
14:03:55 <napping> If some names collide, you can use others unqualified and use the short "as" name for ambiguous ones
14:04:11 <napping> but it is kind of useless
14:04:49 <napping> import Data.List(transpose) as L *should* make transpose in scope unqualified and everything else available as L
14:05:10 <napping> but that's illegal syntax, and import Data.List as L(transpose) makes only "transpose" and "L.transpose" available
14:05:13 <DuelShark> is there an alternative of getLine for two arguments? such as an int and custom data type
14:05:43 <ab9rf> DuelShark: what would hte other oargument be?
14:06:07 <DuelShark> for example "move 1 Cross" Cross being a custom data type
14:06:15 <ab9rf> move?
14:06:22 <DuelShark> move being the function
14:06:30 <ab9rf> types are not arguments
14:07:03 <DuelShark> sorry I'm very bad at this - to clarify what I want to do is keep calling my move function for user input
14:07:24 <ab9rf> you woul have to have a different function for each type you want to input
14:07:27 <DuelShark> getLine seems to work for [String] but something similar for other types
14:08:13 <DuelShark> umm kk
14:08:16 <ab9rf> getLine is for String, not [String], iirc
14:08:30 <DuelShark> but how would I keep it in a loop?
14:08:38 <DuelShark> thanks btw
14:09:25 <ab9rf> DuelShark: look into the Read class
14:09:35 <DuelShark> alright
14:09:36 <Clint> @src interact
14:09:36 <lambdabot> interact f = do s <- getContents; putStr (f s)
14:10:03 <ab9rf> DuelShark: and the readsPrec function in
14:10:14 <DuelShark> kk
14:10:31 <ab9rf> :t readsPrec
14:10:33 <lambdabot> Read a => Int -> ReadS a
14:11:01 <ab9rf> :t read
14:11:02 <lambdabot> Read a => String -> a
14:11:20 <ab9rf> seems to be what you're looking for
14:11:38 <DuelShark> alright
14:15:17 <chrisirc> More often than not, cabal fails midway through installing some package with many dependencies.
14:15:37 <chrisirc> Does it resume properly or?
14:15:53 <ab9rf> i have a question that i will ask when i figure out how to do so
14:16:13 <monochrom> it cleans up properly and can resume properly if the error is fixed
14:17:15 <monochrom> DuelShark: my http://www.vex.net/~trebla/haskell/reads.xhtml may help
14:17:32 * hackagebot monad-control 0.3.2 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-0.3.2 (BasVanDijk)
14:18:19 <chrisirc> This time it failed for HTTP. I say "cabal install HTTP" in the hope that it resumes, but now installs a ton of packages *again*?
14:18:25 <chrisirc> It explicitely says "Warning: Note that reinstalls are always dangerous. Continuing anyway...", well, why then did you not finish installation of those dependencies in the previous run, cabal?
14:18:41 <ab9rf> heh
14:18:46 <dcoutts> chrisirc: yeah, don't do that, tell it to install everything at once
14:18:57 <fragamus> what is an endofunctor
14:18:57 <dmwit> connelly: yes
14:19:10 <dmwit> connelly: (...yes, that is a common Parsec idiom; check the type of "parse")
14:19:16 <chrisirc> dcoutts, well, I didn't see any error message when it installed HTTP in the first run, so I figured, let's just try that?
14:19:27 <dmwit> fragamus: any functor whose domain and codomain are the same category
14:19:52 <chrisirc> dcoutts, or, more to the point, why say "cabal install cabal cabal-install" again when that was what failed in the first run?
14:19:55 <fragamus> i thought something like that might be the case
14:20:44 <dcoutts> chrisirc: well yes, but the same is true if you go an try and install things individually (only there you'll create worse problems). You want to find out why it failed, then you have a chance to fix it.
14:21:00 <dcoutts> chrisirc: so the error will be there, and if you run it again it'll show you again
14:21:08 <dmwit> chrisirc: cabal is making a global install plan, so it needs global knowledge about your goals
14:21:28 <dmwit> If you give it only local knowledge, it will likely come up with a different plan.
14:21:46 <chrisirc> ok, I remember, time to unpack the package in question (HTTP) and run cabal there manually.
14:21:50 <dcoutts> chrisirc: note that in this case it can actually be more helpful to run it in it's less verbose mode that it uses when doing parallel installs, then it logs all the builds and will give you a log file, rather than logging them to the screen
14:22:03 <monochrom> I did not say, "cabal can resume properly unconditionally". I only said, "cabal can resume properly if the error is fixed". therefore, you must fix the error first.
14:23:10 <chrisirc> I still don't get why cabal wouldn't just install those dependencies that compiled right away?
14:23:24 <monochrom> it does
14:23:51 <chrisirc> Then why does it reinstall them when I issue "cabal install HTTP"?
14:24:09 <dcoutts> chrisirc: because you're now asking it to do something rather different than you were before
14:24:12 <monochrom> something else confuses it and leads it to build again
14:24:44 <monochrom> use "ghc-pkg list" to discover what has been installed and done deal
14:24:51 <chrisirc> I thought cabal only installs dependencies that aren't already installed in the same version that it would install now?
14:25:00 <chrisirc> Ok trying.
14:25:04 <dcoutts> chrisirc: what's happened here is that one of the dependencies failed to build, but it carried on with the others that didn't depend on that failing one, so the error scrolled by. It tells you at the end which failed, but you'd have to scroll back to see the details. Not the most helpful admittedly.
14:25:22 <dcoutts> chrisirc: sadly it's much more complicated than that
14:25:31 <chrisirc> I'm not running a parallel build (this cabal is too old anyway).
14:25:35 <monochrom> oh, it is way more complicated than that. perhaps time to see my http://www.vex.net/~trebla/haskell/sicp.xhtml
14:25:44 <chrisirc> HTTP was the last thing it built, but it didn't output any error.
14:26:01 <dcoutts> chrisirc: cabal install a; cabal install b  is not the same as cabal install a b
14:26:15 <monochrom> there are many ways to cause cabal to see you have x-0.1 and still rebuild x-0.1 again and again
14:26:51 <dcoutts> chrisirc: the latter will arrange things so that a and b are built with consistent dependencies, if you do it individually then it doesn't try to do that (it's impossible in general) it just tries to install the thing you asked for
14:28:31 <monochrom> HTTP comes with the Haskell Platform. should be a no-brainer to build either way
14:29:18 <monochrom> unless you have spurrious packages installed. see my article
14:30:31 <lispy> monochrom: when you were talking about Bird's book the other day, is this the one you meant? http://www.amazon.com/Introduction-Functional-Programming-Haskell-Edition/dp/0134843460/ref=sr_1_10?ie=UTF8&qid=1362695364&sr=8-10&keywords=richard+bird
14:30:46 <monochrom> yes
14:30:51 <lispy> monochrom: I recently acquired a book by Bird but it's a different one (Functional Pearls)
14:31:03 <lispy> so it seems we were talking about different books
14:31:13 <monochrom> I happen to have that one too
14:31:32 <toki78> http://toki.burn3r.de/pid.html
14:31:42 <lispy> monochrom: is the first one just for beginners?
14:31:49 <monochrom> yes
14:31:59 <lispy> Okay, I may skip it then.
14:32:14 <monochrom> my quote is about the first one
14:32:19 <monochrom> @quote monochrom krad
14:32:20 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
14:32:20 <lambdabot> entire human race would have to be rewritten!
14:32:38 <monochrom> well, it is not that ambiguous because I did say "haskell book"
14:32:54 <monochrom> in any case, I said that way before the Pearl book existed
14:32:56 <lispy> I think there are haskell topics where i'm still solidly a beginner, but there probably arent' enough of those topics for me to justify the cost of that book
14:33:13 <dcoutts> lispy: it's a beginners book, but what Bird considers as beginners stuff, so it's full of laws, proof schemes etc
14:33:35 <monochrom> sure, today you probably already know fusion, parser monad, monad transformer, and foldl'
14:34:16 <Jafari> Which book was mentioned?
14:34:33 <monochrom> "introduction to functional programming using haskell"
14:34:35 <lispy> Jafari: http://www.amazon.com/Introduction-Functional-Programming-Haskell-Edition/dp/0134843460/ref=sr_1_10?ie=UTF8&qid=1362695364&sr=8-10&keywords=richard+bird
14:34:52 <Jafari> Thank you.
14:35:07 <HogNobbles> Sorry I was AFK, but thanks for clearing that up for me, I understand purpose of not using 'qualified' now.
14:35:44 <monochrom> laws and proof schemes are beginner stuff. it's just highschool algebra again. different topic, sure, but same techiniques
14:37:36 <monochrom> proof is the best way to learn fusion, and the only way to know you're using it correctly
14:38:06 <monochrom> and the proof is just highschool algebra again
14:39:05 <monochrom> working with variables, substitute equal for equal, plug and chug
14:40:08 <dcoutts> totally agree, but one can only get away with that approach to teaching in Universities
14:40:09 <ski> DuelShark : `case (reads :: ReadS MyType) string of [(myValue,restOfString)] -> ...; _ -> ...'
14:42:20 <ski> monochrom : hmm .. perhaps you should mention how one can use `ReadS' on your page ?
14:44:58 <monochrom> there is no escape from learning and teaching highschool algebra for haskell
14:45:36 <monochrom> sooner or later, you must confront lazy evaluation, and it is working with variables, subtitute equal for equal, plug and chug again
14:46:10 <monochrom> the only difference is, perhaps you write --> instead of =
14:48:08 <dcoutts> monochrom: I was about to disagree, then I realised I'd misunderstood :-). Yes, you do need to be at least vaguely familiar with the idea of substituting definitions
14:48:41 <dcoutts> we teach a course and go into a quite lot of detail about lazy evaluation, strictness etc. We do do reduction and the idea of evaluation by expanding definitions.
14:48:48 <dcoutts> but you don't have to go into much more detail than that
14:54:00 <toki78> Hi, the guys in logic do not answer. Can I talk to you about the SAT problem ?
14:54:59 <grok> has development of YI stagnated?
14:55:03 <grok> anyone using it?
14:55:10 <dcoutts> grok: sadly I think it has
14:55:24 <grok> seemed so promising
14:55:32 <dcoutts> aye
14:55:45 <Heffalump> toki78: that would be particularly appropriate if you encode your question as a dependency management problem for Cabal ;-)
14:56:20 <monochrom> I am going to do that for April 1st this year
14:56:45 <toki78> Heffalump, you mean, if I programm my SAT solver in Haskell ?
14:57:20 <dcoutts> toki78: Heffalump is joking, but he's referring to the fact that package management problems are equivalent to SAT
14:57:21 <Heffalump> no, Cabal is Haskell's package management system. I believe finding an installation plan is equivalent to SAT solving.
14:57:29 <grok> I would like to try my hand at replicating something like sublime text in haskell, would you say it would be hard to do such custom ui work with the gtk2hs project?
14:57:44 <toki78> ok :)
14:58:12 <dcoutts> grok: if you can do it with cairo+gtk, then you can probably do it with gtk2hs
14:58:46 <dcoutts> grok: it's got good bindings to cairo and pango
15:00:51 <grok> I investigated doing it straight on top of opengl with freetype for text, but text layout and such proved to be quite a hassle and a well solved problem in pango
15:01:08 <grok> to be toolkit independent
15:01:52 <toki78> I think, #algorithm is the correct channel here
15:07:29 <joe_k> i haven't used haskell in a while and I was writing a type example.... how do I write the type of a function of no arguments?
15:07:37 <joe_k> is it () -> a  or just a?
15:07:48 <joe_k> i am thinking this has something to do with a word I heard, monomorphisms?
15:07:51 <geekosaur> a
15:07:58 <RichyB> a.
15:08:18 <geekosaur> and monomorphism is not related, but the monomorphism restriction is unless you give a type signature
15:08:18 <RichyB> The vague thing that you've heard of to do with monomorphisms is the "monomorphism restriction".
15:12:05 <edwardk> joe_k: just 'a'. its lazy so it won't get computed happen until you look at it  (or until the compiler can figure out that it'll need it on all control flow paths)
15:12:17 <joe_k> and to call the former I would actually have to write "f ()" and not "f" i guess. makes sense
15:12:38 <joe_k> although, i understand my use of the word "call" may be inappropriate
15:12:43 <roconnor> @botsnack
15:12:44 <lambdabot> :)
15:12:45 <edwardk> in general the idiom of passing ()'s to nominally 0-ary functions isn't a concern in a lazy setting
15:12:57 <edwardk> 'non-strict' for the pedantic crowd =)
15:13:28 <edwardk> there are a few weird case where you may want it, but if you ever need it by then you'll know exactly why
15:13:59 <lispy> mathematically I'd say 0-ary functions exist and make sense, but I'm not convinced haskell has a good way to model them
15:14:24 <lispy> But I suppose treating () like the empty set and passing that is not unreasonable
15:15:05 <monochrom> outside haskell, you have 1-ary, 2-ary, 3-ary... it costs you nothing to add 0-ary, and it even buys a convenience and uniformity
15:16:15 <monochrom> inside haskell, you have "the type is X->Y" and "the type is not X->Y". if you forced n-ary on it, you would only have 1-ary and 0-ary. you may as well screw it and just say function, non-function
15:16:39 <monochrom> although, morally, you could say:
15:16:44 <monochrom> @quote monochrom 17-ary
15:16:45 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
15:17:20 <dmwit> I feel unconvinced. "arity" may not have an upper bound for polymorphic things, but it can certainly have a reasonable lower bound that's higher than 1.
15:17:45 <dmwit> e.g. you could reasonably say a type of the form "X -> Y -> Z" represents a function of arity at least 2
15:18:05 <dmwit> and "a" represents a function of arity at least 0 =)
15:18:25 <monochrom> I am not going for upper bound. I am going for the cost and benefit of adding a definition
15:18:54 <dmwit> Benefit: it is convenient for discussion.
15:19:00 <dmwit> (What other benefit could you possibly want for a definition?)
15:19:27 <dcoutts> dmwit: arity certainly has a meaning to ghc in the optimiser
15:20:16 <joe_k> ok i am trying to figure out the types (in haskell) of some coffescript testing functions to explain partial application to a coworker
15:20:25 <dmwit> monochrom: In other words, it costs nothing for you to understand what people mean when they say 2-ary, so why not go ahead and understand them?
15:20:39 <monochrom> if you are in the mood of saying "X->Y->Z is 2-ary", of course 0-ary makes sense. I just said that
15:21:01 <joe_k> we have a function "it" (don't ask. came from ruby) that takes (description, testing func) where testing func has zero arguments and lets say returns a TestResult
15:21:16 <joe_k> so is the type of this
15:21:28 <joe_k> it :: string -> ( ??? ) -> TestResult
15:21:29 <dmwit> joe_k: At a guess, "testing func" is intended to be something side-effectful.
15:21:33 <joe_k> oh it is
15:21:37 <joe_k> i am just ignoring that for now
15:21:42 <joe_k> it doesn't necessarily have to be though
15:21:48 <monochrom> if you are in the mood of saying "X->Y->Z is 1-ary", then you are in this situation: "there are two kinds of people, kind #0 and kind #1". at this point, why use a number when you can use a boolean.
15:21:50 <dmwit> So you must reify the side effects, or there's going to be nothing interesting happen.
15:21:56 <joe_k> lets just say it takes (testingcontext, ...) and returns IO TestResult :)
15:24:02 <joe_k> mm ok i think i see the issue
15:25:02 <joe_k> the environment (side effects) are basically the arguments to "testing func"
15:25:11 <dmwit> yes
15:25:58 <joe_k> geez. been a while. is snap still the web framework if I want to show that off?
15:26:00 <dmwit> As you suggested, one reasonable way to deal with this is to allow the testing function to have an IO type (and then "it" will of course also have to have an IO type).
15:26:21 <monochrom> you could ask the same question again about () -> IO Answer, and you get the same simplification to just IO Answer
15:26:47 <levi> Snap, Yesod, and Happstack are all pretty nice in different ways.  Probably depends on your audience what will be most impressive to them.
15:27:13 <monochrom> if you already know snap, you can use snap again
15:27:22 <levi> Yesod has a bunch of DSLs of the sort that Rubyists tend to like.
15:27:27 <joe_k> audience is a .net/c# crowd who is used to working on a codebase with ... thousands of classes small and large, no clear ideas about mutable state or invocation lifetime, etc
15:27:35 <joe_k> asp.net mvc folks
15:27:46 <joe_k> oh they like the ruby dsls for some reason. that's good
15:28:53 <levi> For 'HTML designer-friendly' types, Snap's Haste is a great template system.
15:30:03 <levi> Happstack provides (among other options) a library that lets you embed quasi-quoted XML literals directly in your haskell program, if that would appeal to some.
15:30:16 <joe_k> been trying to get them to use f#.  just the type inference is such a boon.  the reason they have thousands of types is because of the pain of constructing value literals
15:30:25 <joe_k> (so thats another plus)
15:30:29 <levi> Web programming people tend to be opinionated about that sort of thing.
15:31:42 <levi> There are a couple of interesting web frameworks in F#.
15:33:05 <levi> Websharper is pretty nifty, for example.
15:33:17 <lispy> Webshapr?
15:33:27 <lispy> @get webshapr
15:33:28 <lambdabot> shapr!!
15:33:33 <levi> No, that's the next version of Happstack. :P
15:33:47 <monochrom> soon, we will have webdons too
15:34:20 <crl> is there lower layers network stuff in haskell, things like software defined networking, openflow?
15:34:40 <crl> probably erlang is on that stuff
15:34:59 <levi> See Nettle for Haskell OpenFLow.
15:35:17 <JoeyA> I may have asked this before, but: is there a special name for the continuation-based representation of a recursive data structure?  e.g. instead of data List a = Nil | Cons a (List a), you have newtype ListC a = ListC (forall b. r -> (a -> r -> r) -> r)
15:35:22 <JoeyA> err, forall r.
15:35:33 <crl> k, unfortunately there's most stuff in c++ / python
15:36:07 <crl> levi: thx looking
15:37:30 <joe_k> so i guess i have e.g. http://pastebin.com/jzFXHszZ
15:37:37 <mauke> The paste jzFXHszZ has been copied to http://hpaste.org/83649
15:37:52 <joe_k> how about that ;)
15:41:44 <joe_k> damn i love haskell. i need to work in it more.  so i am interested in logic databases / logic rule systems.... is there a good haskell implementation of that kind of stuff
15:42:01 <joe_k> e.g. the kind of stuff datalog does
15:42:23 <levi> There's LogicT, but there are probably more complete things as well.
15:44:33 <dmwit> joe_k: Church encoding?
15:44:35 <dmwit> uh
15:44:43 <dmwit> JoeyA: Church encoding?
15:46:15 <shachaf> dmwit: Oleg would disagree.
15:46:22 <shachaf> http://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html
15:47:20 <monochrom> JoeyA has left. but it is what oleg says
15:52:11 <monochrom> I cannot reliably remember that name. may I call it Barenboim instead? cool musician :)
15:53:08 <shachaf> monochrom: Nobody reads that name all the way to the end anyway.
15:53:29 <shachaf> Call it Boehm-Barenboim or Boehm-Balducci or anything else.
15:53:42 <monochrom> that's even better
15:53:58 <geekosaur> boehm-bam!
15:54:19 <shachaf> Boehm-Boehm
15:54:37 <monochrom> Boehm-Barbie
15:56:22 <lispy> boehm-beam
15:58:08 <monochrom> I still haven't started reading Bird's Pearl book!
15:59:33 * monochrom thinks up another amazon url prank! http://www.amazon.com/Perl-Functional/dp/0521513383/
16:00:29 <monochrom> yikes, computer modern roman
16:07:12 <ski> joe_k : edwardk mentioned <https://github.com/analytics/analytics/blob/master/examples/Closure.hs> re deductive databases (like Datalog). perhaps it would be of some interest
16:07:59 <edwardk> joe_k: i've been building a data analytics platform in haskell that uses an enriched dialect of datalog for its query and data manipulation language.
16:08:40 <joe_k> you dont happen to work in atlanta do you
16:10:26 <edwardk> boston
16:10:34 <joe_k> have you heard of logicblox?
16:10:37 <edwardk> ep
16:10:39 <edwardk> er yep
16:10:44 <joe_k> i worked there for a bit
16:11:32 <edwardk> my focus with analytics is to get most of the machinery needed to work on these problems at any kind of scale 'under one roof'. i have them all lying around in different projects.
16:12:02 <joe_k> sounds awsome. i am definitely going to take a look
16:12:02 <ski> edwardk : machinery for deductive databases ?
16:12:36 <edwardk> ski: deductive database machinery but also a strong focus on olap-style workloads where i don't have to pay 'per row' for aggregate queries
16:13:07 <ski> edwardk : obviously you implement the differential optimization. how about magic sets ? context parameters ? others ?
16:13:20 <edwardk> the current storage story is more like a cache oblivious lookahead array (COLA) based on space filling curves
16:14:58 <edwardk> magic sets are somewhat problematic given the nature of how the backing store works. basically what we're doing is something closer to naiad's streaming differential operators so we can deal with changing source data, that gives a very bottom up story for how to build 'materialized views' off of "omega-continuous-semiring-weighted" datalog programs, but then querying top down can proceed using variant and subsumptive tabling
16:14:59 <edwardk>  against these expanded stores.
16:15:49 <edwardk> as the logicblox guys noted, in general subsumptive tabling beats magic sets
16:16:14 <ski> "streaming differential operators so we can deal with changing source data" implying incremental/adaptive computation ?
16:16:25 <edwardk> yeah
16:16:51 <edwardk> http://research.microsoft.com/apps/pubs/?id=174076
16:17:35 * hackagebot snap-app 0.2.0 - Simple modules for writing apps with Snap, abstracted from hpaste.  http://hackage.haskell.org/package/snap-app-0.2.0 (ChrisDone)
16:17:42 <ski> "variant and subsumptive tabling" ?
16:18:00 <edwardk> so calculate, say, a strongly connected component set off of a huge dataset, then update it incrementally as you update it, say, dropping off the most recent second's worth of data and dropping the oldest to maintain a true 24 hour window, etc.
16:18:15 <ski> (related in any way to constraint data bases, with some constraints subsuming others ?)
16:18:55 <edwardk> https://github.com/ekmett/analytics/blob/master/notes/papers.md covers a lot of the vocabulary and has the subsumptive tabling paper
16:20:36 <ski> what does "don't have to pay 'per row' for aggregate queries" mean ?
16:20:52 <danharaj> edwardk: analytics looks like a PhD thesis :|
16:20:53 <edwardk> in particular i've been spending a lot of time working on unstratified aggregations where the aggregations are done in an omega-continous semiring or closed-semiring (one with a kleene *)
16:21:13 <edwardk> ski: have you ever used a sum table in computer graphics?
16:21:19 <edwardk> danharaj: i got bored
16:21:27 <ski> edwardk : not that i know of
16:21:52 <mgsloan> danharaj: edwardk got bored with the lens thesis
16:21:59 <edwardk> ski: ok, here is the challenge. given two coordinates in a picture, give me the average color in the picture over the rectangle bounded by those coordinates.
16:22:22 <edwardk> you can preprocess the picture, but you can only have a small constant multiple of the original storage space
16:22:35 * hackagebot snap-app 0.2.1 - Simple modules for writing apps with Snap, abstracted from hpaste.  http://hackage.haskell.org/package/snap-app-0.2.1 (ChrisDone)
16:22:37 * hackagebot parsec-permutation 0.1.2.0 - Applicative permutation parser for Parsec intended as  a replacement for Text.Parsec.Perm.  http://hackage.haskell.org/package/parsec-permutation-0.1.2.0 (SamuelHoffstaetter)
16:22:39 * shachaf remembers this challenge!
16:22:49 <edwardk> so you need to be able to answer queries like that quickly. how can you do so in O(1)?
16:23:03 <edwardk> shachaf: =)
16:23:30 <napping> looks like a nice bibliography
16:23:30 <ski> edwardk : do i need to be able to handle updates to the picture ?
16:23:39 <edwardk> ski: for now lets say no
16:24:12 <edwardk> eventually you can construct a hybrid that lets you tradeoff update efficiency for query efficiency
16:24:14 <napping> edwardk: have you heard of Network Datalog?
16:24:19 <edwardk> but thats more advanced
16:24:48 <edwardk> napping: network datalog, overlog, daedalus, bloom, etc. yes
16:24:57 <edwardk> the distribution story is closely based on bloom actually
16:25:07 <edwardk> for now i'm limiting scope to the single node story
16:25:24 <ski> edwardk : i think that i could compute the average (or sum) of the colors from the corner of the picture to every point in the picture (storing this away), and then just "add and subtract rectangles" to get the part of the pic i wanted
16:25:34 <edwardk> and getting a solid semantics and evaluation model for handling that, and scaling out with bloom, and building anything else on top using that as a substrate
16:25:40 <napping> I saw a bit of this stuff coming from the other direction a long time ago -
16:25:46 <edwardk> ski: yep
16:25:49 <ski> edwardk : is that the right answer ?
16:25:51 <ski> ok
16:26:05 <napping> rather than doing analytics and wanting it distributed, realizing that the server layer of a web applications was basically a painstakingly handwritten deductive database
16:26:09 <edwardk> ski: so you can see that it is possible to answer aggregate queries in time cheaper than the number of entries involved.
16:26:19 * ski recalls something slightly similar with efficient multiplication algorithms for big numbers
16:26:42 <edwardk> ski: anyways that is a super-naive way to think about OLAP.
16:30:51 <edwardk> my focus has been on trying to support very large mostly-olap style workloads
16:30:51 <edwardk> so the storage backend is built with those assumptions in mind
16:30:51 <edwardk> good for streaming range queries, bad for point queries, good for bulk insert performance, etc.
16:30:51 * hackagebot caledon 2.1.0.0 - a logic programming language based on the calculus of constructions  http://hackage.haskell.org/package/caledon-2.1.0.0 (MatthewMirman)
16:30:51 <edwardk> lots of tunable knobs
16:30:51 <edwardk> once i know what the overall optimal points in the design space i'm considering are i can ratchet down on those.
16:30:51 <ski> edwardk : essentially, we're doing a clever caching
16:30:51 <ski> (like caching height of trees in nodes for AVL)
16:30:51 <edwardk> but i don't know where the pareto frontier is
16:30:53 <edwardk> yeah, basically we wind up with datalog for the 'key space' and then associated with the rows we wind up with data in (semigroup/lattice/semiring/omega-continuous semiring)-based facts that know how to aggregate themselves
16:30:59 <edwardk> then we can roll it up and do joins, etc. using the datalog query engine
16:30:59 <edwardk> hopefully in a form that still admits a nice EDSL for it for embedding into other applications, but really with the focus on it as a 'real database' as my primary motivation.
16:31:17 <ski> ("omega-continuous" ?)
16:32:03 <ski> perhaps it's the directed union thing
16:32:53 <chrisirc> How do I build a package 'manually' so that it is installed as --user ?
16:33:03 <chrisirc> runhaskell Setup configure --user    doesn't cut it
16:33:18 <ski> edwardk : how do you know "which kind of aggregate operations are worthwhile to cache for in this way", so to speak ?
16:33:27 <chrisirc> ehr sorry, it does
16:33:36 <ski> (or is the question ill-formed or misinformed ?)
16:33:40 <chrisirc> I was thinking --user but typing --local
16:34:50 <edwardk> ski: given a semi(group|ring), we can say that it is naturally ordered if the relation a <= b = exists c. a + c = b is a partial order and (+) (and (*)) are properly monotone. when you start talking about omega-chains you want the end of the omega-chain to be in the set described by the semiring.
16:36:06 <ski> edwardk : ok, so an infinite ascending chain should have a least upper bound (as i suspected)
16:36:08 <edwardk> we can embellish any semiring with a * operator, such that a* = 1 + aa* = 1 + a*a, either by completing it or starting with a nice semiring where that holds. if we can distribute it over countable sums we can use this to ascribe meaningful values in the 'omega-continuous semiring' that results. this is slightly weaker in construction than the class closed semiring
16:36:38 <edwardk> er than the class of closed semirings, where you just add the * operator, but where (+) winds up idempotent
16:36:47 <ski> (and then homomorphisms should commute with this, i assume, a like Heine continuity)
16:36:57 <edwardk> this permits us to do things like provenance calculations in the omega-continuous semiring setting
16:36:59 <ski> (s/a like/a la/)
16:37:11 <edwardk> that is to say, given a result, we can define an aggregation that tells us what facts contributed to that fact
16:37:48 <edwardk> either as a preprocess or as a post-process, to support drilldown to see the raw data
16:37:48 <edwardk> but its also useful because i want to be able to do things like floyd-warshall without needing stratified aggregation
16:37:52 <chrisirc> Hm, any idea about: (while compiling HTTP)  Network/StreamSocket.hs:37:25: Module 'System.IO.Error' does not export 'catch'
16:38:10 <edwardk> since its been shown that stratified aggregation takes lots of otherwise nice computatins and incurs an asymptotic penalty
16:38:42 <edwardk> so i called nwf who works on Dyna and spent some time chatting with him about how to take what i have and what they are doing and meet in the middle
16:38:59 <ski> edwardk : "semi" in "semiring" referring to ? lack of multiplicative identity ?
16:39:02 <edwardk> because i want some of what dyna can do but i want to retain confluence, so that i have some flexibility in choosing the evaluation strategy
16:39:07 * ski doesn't recall
16:39:13 <edwardk> negation basically
16:39:41 <edwardk> sadly semiring and semigroup are usually unrelated 'semi's ;)
16:39:54 <edwardk> nobody uses the nice formulation where a semiring is a pair of semigroups
16:40:08 <edwardk> silly history
16:40:09 <ski> ("provenance calculations" being ?)
16:40:30 <ski> (oh, perhaps you are explaining that above)
16:40:33 <edwardk> provenance is also linked in the papers doc i gave, but its about knowing 'where the data came from'
16:40:34 <chrisirc> monochrom, on http://www.vex.net/~trebla/haskell/sicp.xhtml you don't explain *why* the previous registration would be removed when installing the same package with different ABI hash?
16:40:44 <edwardk> e.g. showing your work
16:41:02 <edwardk> its all well and good to spit out an answer, but if you want to be able to cite your sources, etc. its nice to be able to figure out where it came from
16:41:41 <chrisirc> monochrom, to me the whole sense in making the hash part of the directory names is that multiple versions can be installed in parallel?
16:41:54 <edwardk> there are other provenance concerns when i start talking about unstratified aggregation too, so the machinery gets multiple uses
16:41:59 <edwardk> or will
16:42:06 <edwardk> right now most of it is in note form
16:42:07 <dmwit> shachaf: What's this? Something *Oleg* finds incomprehensible and must explain simply?
16:42:55 <ski> hm, "provenance calculations" sounds perhaps somewhat related to "truth/reason maintenence" in LP / expert systems
16:43:13 <edwardk> ski: probably
16:43:19 <ski> ("retain confluence" in this context being ?)
16:43:32 <edwardk> it was mostly an example of where i needed something stronger than a closed-semi(near)ring
16:43:34 <dmwit> chrisirc: Unfortunately, as it stands now, a single version can have many hashes depending on what versions of its dependencies it's built with.
16:43:57 <dmwit> chrisirc: When this happens, and you register a new build of the same version (but with different dependencies), it replaces the old build of that version.
16:44:24 <edwardk> lets say we have an 'enhanced' datalog where each relation carries with it some value in a semiring. and we say how those values will roll up a priori
16:44:25 <chrisirc> dmwit, yes, I get that first line of what you said and it makes sense and is ok. But why the second? Doesn't make sense
16:44:27 <edwardk> we can define a lot of things
16:44:28 <edwardk> like
16:44:30 <edwardk> matrix multiplication
16:44:47 <dmwit> chrisirc: Perhaps in the future, GHC will allow even more flexible installs where you may have many copies of a single version of a package built against different dependencies.
16:44:52 <dmwit> chrisirc: But for now it doesn't.
16:44:55 <edwardk> foo X Z :- bar X Y * baz Y Z    -- assuming :- aggregates with (+)
16:45:09 <edwardk> we can define minimum cost paths with
16:45:47 <edwardk> mincost X Y :- edge X Y; mincost X Z :- mincost X Y + edge Y Z -- assuming (:-) aggregates with min, but this example is slightly different!
16:46:06 <edwardk> the second example it matters the order in which my rules fire and are reached
16:46:20 <edwardk> i can get different answers if i'm not careful to fully evaluate 'up to' some node.
16:46:30 <edwardk> or if i don't compute the entire tree
16:46:53 <edwardk> so i want something that yields the same answer regardless of the order in which i discover those nodes
16:46:58 <edwardk> this is what i mean by confluence
16:47:25 <edwardk> you usually achieve confluence in a datalog by fully stratifying negation (and any form of aggregation)
16:47:33 <edwardk> but this rules out algorithms like floyd-warshall
16:48:03 <ski> edwardk : hm, comparing the category of modules over the ior ring with two elements to other categories of modules (or semiringblah-based modules) ?
16:48:27 <edwardk> ior?
16:48:33 <ski> inclusive or
16:48:38 <ski> iow `1 + 1 = 1'
16:48:47 <edwardk> ah
16:49:34 <edwardk> that forms a trivial closed semiring. we can add a kleene-* operator to it easily, etc.
16:49:37 <edwardk> so it falls in the framework
16:49:59 <edwardk> the need for kleene-* arises when you view these reductions in the presence of cycles in the proof tree.
16:50:14 <edwardk> e.g. computing min-cost paths in the transitive closure in the presence of cycles.
16:50:25 <ski> recursively defined predicates or ?
16:50:34 <edwardk> recursively defined, yes
16:50:52 <ski> in `mincost', disjunction corresponding to `min' ?
16:51:10 <edwardk> yep
16:51:39 <ski> "i can get different answers if ...","or if i don't compute the entire tree" -- but you get a bound anyway, right ?
16:51:51 <edwardk> so i need to go through stratify as usual, then i can do pretty much any aggregation i want across strata, but within a strata i can only have cyclic rules where they reduce within an omega-continuous semiring
16:53:11 <ski> corresponding to monotonic / not going through negations/aggregations, *nod*
16:53:18 <edwardk> what i can do is lazy provenance discovery. set up a bloom filter. run the algorithm assuming confluence. if i get two writes to the same thing, then i need to effectively bottom it out, and anything that depends on it, and go through and redo those portions of the calculation with more rigor. this lets me do most of my calculations in an optimistic manner
16:53:48 <edwardk> and then only pay for provenance discovery when it turns out i need it
16:54:02 <edwardk> (this is a different abuse of provenance than the one exposing it to the user)
16:54:17 <ski> (bound, yes or no ?)
16:54:24 <edwardk> bound my library?
16:54:33 <edwardk> currently not in use inside it
16:54:42 <edwardk> oh can you calculate a bound
16:54:48 <ski> i mean when computing `min', if you don't explore all branches, you still get an upper bound, i assume
16:54:50 <edwardk> yeah you can calculate a conservative bound from the first pass
16:56:02 <edwardk> i have a lot of stuff in analytics calculating conservative bounds.
16:56:22 <ski> nice
16:56:27 <ski> hm, how (or in which sense) is the above "provenance discovery" ?
16:56:29 <edwardk> e.g. in the hyperloglog implementation and bloom filter code I return lower bounds on the probability that the answer is correct, etc.
16:57:19 <edwardk> here we're concerned with the provenance of the new resulting value, if there is only a single source of provenance its trivially correct, when there are multiple contributors and i let something race ahead with the answer from just one, it gave a potentially invalid result.
16:57:36 <ski> ah, ok. i see
16:57:48 <ski> (a bit like the STM)
16:57:53 <edwardk> yep
16:58:46 <ski> (edwardk : .. also i still don't have a that good idea of what OLAP really means :/ )
16:58:50 <edwardk> my goal has been to get relatively cheap confluence wherever i can and pay for the provenance trick only as needed, when dealing with unstratified aggregation
16:59:12 <ski> ok
16:59:19 <edwardk> http://en.wikipedia.org/wiki/OLAP_cube
17:00:35 <berrr> b-schooler detected
17:00:36 <ski> should it be thought of as a function from a cartesian product, or as a relation where the "truth values" are more interesting ?
17:01:17 <ski> (of course i presume there's more to it that only this)
17:01:18 <edwardk> well, thats the thing. the generalized annotated program model in the prolog world is all about 'more interesting truth values'
17:01:54 <gynna> http://www.reddit.com/r/AdultDating18/comments/19u89j/italian_amateurs/
17:01:57 <ski> like your `foo' and `mincost' examples above, i take it
17:02:06 <edwardk> the version i care about for aggregation/projection more like a function on the cartesian product to reduce, and yet further within a cycle i need the full semiring machinery and i need to solve it yet differently again
17:02:15 <edwardk> yeah
17:02:36 * hackagebot multiarg 0.10.0.0 - Combinators to build command line parsers  http://hackage.haskell.org/package/multiarg-0.10.0.0 (OmariNorman)
17:02:44 <edwardk> so basically both the function of the cartesian product and 'more interesting truth' viewpoints are useful to me
17:02:51 <berrr> interesting stuff
17:03:10 <ski> (i also str some difference in emphasis on relative efficiency (and expected use) of read vs. write)
17:03:48 <edwardk> yeah OLTP is about giving you ACID properties, nice consistency guarantees about lots of simultaneous small inserts
17:03:58 <edwardk> OLAP is traditionally about supporting big batch updates and efficient queries
17:04:10 <edwardk> there are a few players that kind of live in the midle.
17:04:36 <edwardk> i'm heading toward that middle space and towards OLAP and less so towards traditional OLTP.
17:05:11 <edwardk> basically you can give me input data, and i'll eventually care to offer you 2-phase commit guarantees and MVCC, etc on it
17:05:35 <ski> and how does either and both of these contrast to more traditional RDBMSs ?
17:05:46 <edwardk> and then i run it through the dataflow-recursive calculation engine computing a 'derived' data set that i can query with respect to a given transaction, etc.
17:05:57 <edwardk> OLTP is what you think of when you talk SQL
17:06:09 <ski> oh, i see
17:06:09 <edwardk> OLAP is what you think of when you write MDX.
17:06:22 <johnw> edwardk: is OLAP like adding extra tables to accelerate certain kinds of queries?
17:07:05 <edwardk> well, you can pre-"can" a few views in the OLTP world that might be faster, and bulk update them, etc. but even so you usually just rigorously follow the hierarchy
17:07:21 <edwardk> you're still 'paying by the row' mostly
17:07:31 <edwardk> just for fewer rows
17:07:44 <ski> ("follow the hierarchy" ?)
17:08:40 <edwardk> when you star-schema or snowflake schema a database, we usually refer to the table in the center of the star as a 'fact' table and each table it links to as a 'dimension' table. then the dimensions may have multiple hierarchies on them: for a date table it may have Year/Quarter/Month/Day and you can drill in
17:09:20 <edwardk> for a product table it may have manufacturer/name, for a store table it may have Country/State or Province/City/Store
17:10:17 <edwardk> when i do a 'pivot table' i usually care to drill in on these hierarchies independently and view say, total sales by store by quarter and then drilldown to see how they are doing in the months in that quarter or by department or by sales person, etc.
17:10:53 <edwardk> it'd be like taking datalog and embellishing the structure of the entities you use to have structure in their own right
17:11:09 <edwardk> and then letting us roll up facts into these higher levels
17:11:56 <edwardk> you _can_ implement all of this with just more and more datalog, but there comes a point at which there are great gains in efficiency you can gain from viewing it the way the olap industry does, and putting structure in the dimensions
17:12:17 <edwardk> since dimensions tend to be small relative to the fact tables that index into them
17:12:33 <ski> "embellishing the structure of the entities you use to have structure in their own right" like compound terms ?
17:12:49 <ski> (plus summarizing)
17:13:27 <berr> how do you do the "naive fibonacci" in ghci? just adding let doesn't seem to work
17:13:29 <berr> http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
17:13:33 <edwardk> i mean doing something smarter than that, think of it as assigning the terms a place in (potentially multiple) hierarchies so that i can use their IDs to enable me to quickly roll up to higher levels if i have something like that sum table
17:14:09 <ski> > let nfib 0 = 0; nfib 1 = 1; nfib n = nfib (n-1) + nfib (n-2) in nfib 100
17:14:10 <edwardk> ski: consider laying out dates on one dimension, just use the julian date.
17:14:13 <lambdabot>   mueval-core: Time limit exceeded
17:14:21 <edwardk> i can query for a given month just by looking at a contiguous range of julian dates
17:14:25 <ski> berr ^
17:14:26 <edwardk> same for a given year
17:15:00 <edwardk> so if i can answer rollup queries in sub-linear time, then we can answer things at a higher level of aggregation by doing lots of these
17:15:07 <ski> berr : you can omit the `in nfib 100' in GHCi (or in `do'-notation), then you can use `nfib' in later computations
17:15:46 <berr> Thanks ski, I meant why won't that implementation work if you just add let to the beginning of each line
17:15:46 <piezoid> hi, is there a simpler syntax for modify (\s -> s{field = field s }) :: State s () ?
17:15:48 <edwardk> then the relation/atom becomes an n-dimensional cube we are restricting our view of when we pick particulars or pivoting and expanding when we join
17:16:05 <berr> For some reason it is just crashing the window now after thinking for a bit but earlier I was getting error messages
17:16:06 <simpson> piezoid: Have you seen lens yet? :3
17:16:40 <edwardk> piezoid: in lens that is   'field %= f'   assuming you wanted to modify it ;)
17:16:58 <magicman> (unrelated: Is "Have you seen lens yet?" going to be the new @faq response?)
17:17:04 <edwardk> magicman: =)
17:17:21 <magicman> The answer is: Yes! lens can do that!
17:17:23 <piezoid> yes, but they look like a hammer for this use o O
17:17:27 <edwardk> ski: anyways you get the rough idea =)
17:17:50 <simpson> piezoid: Nothing wrong with using a shoe to place one nail.
17:17:53 <berr> something must be wrong with my platform it shouldn't take so long to interpret this
17:18:01 <simpson> piezoid: But if you have an entire birdhouse to put together...
17:18:09 <edwardk> basically its me throwing all my tricks for working with 'big data' into a blender.
17:18:15 <edwardk> and seeing what comes out
17:18:35 <ski> edwardk : yes, i'm getting some kind of rough idea of what it's about. ty
17:19:07 <ski> berr : there's is something wrong with the algorithm
17:19:34 <ski> berr : the same would happen in other language implementations (assuming a non-SSC)
17:20:02 <ski> berr : computing `nfib n' takes exponential time in `n'
17:20:18 <ski> berr : because it is *recomputing* the answer to lots of subproblems
17:22:30 <berr> ski: hmm I didn't think it would be a problem for very small numbers
17:22:37 <monochrom> as it happens, this algorithm takes nfib n time to compute nfib n :)
17:23:01 <berr> ha
17:23:26 <monochrom> I am fine with very small numbers, but make sure they are very small
17:23:42 <berr> it still tries to use all my memory and then dies if I put in 1 or zero apparently
17:23:59 <MeatPuppet> there's possible to do a fib algoritmn with a botom-up recursion?
17:24:01 <berr> but I think I can see why
17:24:15 <latro`a> MeatPuppet, yes there is
17:26:01 <ski> > (!! 100) . fix $ \fibs0@ ~(_:fibs1) -> 0 : 1 : zipWith (+) fibs0 fibs1
17:26:03 <lambdabot>   354224848179261915075
17:27:26 <latro`a> is that any better than just:
17:27:33 <latro`a> let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 100
17:27:42 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = array ix [(i,f i) | i <- range ix]
17:27:45 <lambdabot>  Defined.
17:27:52 <latro`a> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 100
17:27:53 <lambdabot>   354224848179261915075
17:28:05 <ski> latro`a : you could go with an accumulator, if you preferred
17:29:33 * sproingie gets an "Evolution of a Haskell Programmer" vibe off this
17:29:33 <ski> > let fib = loop 1 0 where loop m n 0 = n; loop m !n i = loop n (m+n) (i-1) in fib 100
17:29:35 <lambdabot>   354224848179261915075
17:29:49 <latro`a> impressive
17:29:59 <sproingie> let's see type-level fib
17:31:12 <ski> @let memoArr :: Ix i => (i,i) -> (i -> e) -> (i -> e); memoArr ix f = (tabulate ix f !)
17:31:14 <lambdabot>  Defined.
17:31:30 <monochrom> we need an "evolution of an agda programmer"
17:32:26 <ski> > let (memoArr (0,100) -> fib) = \n -> case n of 0 -> 0; 1 -> 1; n -> fib (n-1) + fib (n-2) in map fib [0,5,12,20,100]
17:32:26 <elliott> ski: memoArr should memoise arbitrary Arrow arorws
17:32:29 <lambdabot>   [0,5,144,6765,354224848179261915075]
17:32:36 <elliott> haha, nice sugar
17:32:39 <ski> elliott :)
17:33:06 <monochrom> what? arbitrary arrows could be memoised?!
17:34:24 <ski> latro`a,barr : note that the `memoArr' version using top-down dynamic programming -- this is perhaps not that useful for `fibonacci', where you only need to the tw most recent results -- but for more complicated kinds of dynamic programming, this can be a very handy technique (e.g. avoiding mutable arrays)
17:35:08 <latro`a> what is that arrow
17:35:20 * ski thinks `tabulate' should be in `Data.Array.IArray'
17:35:21 <latro`a> a view pattern?
17:35:25 <ski> yes
17:35:33 <Micha____> Why am I getting an empty list error here? I'm trying to recursively generate more "Agents", but when I call that function (reproduce), it throws a prelude.head empty list error. https://gist.github.com/mfine15/d47bccb5beab876a5e58
17:36:25 <ski> latro`a : it's to avoid having to explicitly mention the array underneath, so that we can *appear* to call `fib' recursively, in the naive way
17:36:27 <bbbbbbb> is it possible to do something like newtype MyList a b c = [a,b,c] where you require a list of exactly three elements to passed to a function like myFunc :: MyList -> ()
17:37:06 <simpson> bbbbbbb: Often you would not use a list for this; you would use something like a tuple.
17:37:10 <simpson> bbbbbbb: Why?
17:37:25 <ski> bbbbbbb : you could say `data MyList a = ML a a a', if you wanted to
17:37:35 <ski> but there's no refinement types in Haskell, no
17:37:37 * hackagebot caledon 2.1.1.0 - a logic programming language based on the calculus of constructions  http://hackage.haskell.org/package/caledon-2.1.1.0 (MatthewMirman)
17:38:18 <ski> (and, btw, the different `a',`b',`c' doesn't make sense, if we're thinking of this as (homogenous) lists -- perhaps you wanted something like a tuple/record ?)
17:38:36 <bbbbbbb> i'm thinking of something like a chessboard
17:38:37 <ski> (iow, `data MyTriple a b c = MT a b c' would work)
17:38:58 <bbbbbbb> which has a definite size and is filled with data Spot = ...
17:39:57 <ski> i suppose you could use an `Array Int' or an `IntMap' or something
17:40:05 <ski> (or a custom data type, if you insist)
17:40:20 <bbbbbbb> so like [[ChessSpot,.. * 8] * 8]
17:45:18 <[swift]> can anyone show me what's wrong with my use of MaybeT?
17:45:20 <[swift]> http://hpaste.org/83651
17:45:34 <[swift]> i've tried a couple of variations and i just don't get it
17:46:21 <[swift]> shouldn't functions in MaybeT evaluated to "Maybe a"?
17:46:22 <hpc> Swizec: you're giving it a (Maybe x) where it wants (MaybeT IO x)
17:46:32 <hpc> no, MaybeT is a different thing
17:46:34 <hpc> @src MaybeT
17:46:35 <lambdabot> Source not found. Do you think like you type?
17:46:37 <hpc> :(
17:47:09 <[swift]> my goal is to have a chain of functions, any of which can fail and stop the chain from being evaluated further. i thought MaybeT was the right thing for that?
17:47:23 <ski>   newtype MaybeT m a = MaybeT (m (Maybe a))
17:47:30 <hpc> you want getCommandInfo :: MaybeT m CommandInfo
17:47:41 <hpc> probably
17:48:24 <hpc> there's other uglier ways to lift Maybe into MaybeT, but it's sadly not the way MonadTrans abstracts away lifting
17:48:25 <[swift]> hpc: and then "return (Just x)" or whatever inside there?
17:48:42 <hpc> something like that
17:49:40 <[swift]> i see, thanks
17:49:46 <hpc> hmm, this abstraction is giving me trouble
17:49:57 <[swift]> ski: that isn't how it works already?
17:50:10 <ski> sorry ?
17:50:14 <hpc> i have a single action that i want running concurrently
17:50:17 <[swift]> ski: I'd think MaybeT m a would always expect a wrapped in a Maybe?
17:50:22 <hpc> specifically, visiting a webpage
17:50:36 <hpc> and i want to be able to change the number of concurrent requests
17:50:39 <ski> @unmtl MaybeT m a
17:50:39 <lambdabot> m (Maybe a)
17:51:16 <ski> @unmtl StateT s (MaybeT IO) a
17:51:16 <lambdabot> s -> IO (Maybe (a, s))
17:51:26 <ski> @unmtl MaybeT (StateT s IO) a
17:51:26 <lambdabot> s -> IO (Maybe a, s)
17:52:11 <[swift]> ski: i see, that is how i thought it worked
17:53:14 <ski> the suggested definition of `MaybeT' above conforms with the `unmtl' answers
17:54:08 * [swift] is just puzzled
17:54:39 <ivanm> preflex: seen srhb
17:54:40 <preflex>  srhb was last seen on #haskell 4 hours, 14 minutes and 48 seconds ago, saying: Do as you like.
17:55:23 <[swift]> if "return $ f x" where "f :: a -> Maybe b" doesn't work inside MaybeT, i just don't know how to interact with it
17:55:45 <hpc> it also needs the MaybeT constructor
17:56:02 <[swift]> i thought that's what "return" does, tho?
17:56:18 <hpc> use the types, luke
17:56:37 <hpc> f x :: Maybe a, return :: a -> m a
17:57:03 <hpc> so taking m to be MaybeT m', you have return $ f x :: MaybeT m' (Maybe a)
17:57:16 <ski> type for `return' can be `return :: a -> MaybeT m a' (where `Monad m'), while `MaybeT :: m (Maybe a) -> MaybeT m a'
17:57:16 <hpc> or you could take return to be operating on IO
17:57:21 <hpc> so you have IO (Maybe a)
17:57:33 <hpc> MaybeT :: m (Maybe a) -> MaybeT m a
17:57:36 <ski> to get from `Maybe a' to `m (Maybe a)', you need `return :: forall a. a -> m a'
17:57:42 <hpc> MaybeT (return $ f a) :: MaybeT IO a
18:02:04 <[swift]> hmm. so this all works so forth, but i am a bit confused why in "MaybeT m a", return doesn't have type "a -> MaybeT m a". if return in general has type "a -> m' a", isn't the m' here "MaybeT m"?
18:03:17 <monochrom> return has type a -> MaybeT m a. you made some other error.
18:03:40 * [swift] rereads the explanation above
18:03:42 <croikle> if you already had a Maybe a, you need MaybeT
18:03:57 <monochrom> return (f x) :: MaybeT m (Maybe b)
18:05:22 <fragamus> Hey is there a UDP API that doesn't suck?
18:05:28 <[swift]> agh, i think i get it. so if I had a _bare_ value without Maybe, "return" _would_ work
18:05:38 <croikle> yeah
18:05:58 <[swift]> ahhh, ok. i'm starting to put it together. thanks for the help everyone!
18:20:41 <ski> [swift] : in `MaybeT (return (f a))', `return' would probably have a type like `a -> IO a'
18:21:00 <ski> (assuming `hpc's example types above)
18:52:02 <DanBurton> can you write "first" in terms of "arr" and "&&&"?
18:52:17 <dmwit> :t (&&&)
18:52:19 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
18:52:28 <dmwit> I don't think so?
18:52:29 <dmwit> :t first
18:52:31 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
18:52:58 <ab9rf> :t arr
18:53:00 <lambdabot> Arrow a => (b -> c) -> a b c
18:53:01 <DanBurton> also throw in >>> and id
18:53:06 <DanBurton> into the toolkit
18:55:03 <DanBurton> Or, on the other hand, is there a discussion somewhere on the interwebs about an Arrow abstraction without first/second?
18:55:06 <geekosaur> if first is required for a minimally complete arrow, this implies that first cannot be constructed from other arrow functions
18:55:15 <elliott> :t (&&& id)
18:55:18 <lambdabot> (c' -> c) -> c' -> (c, c')
18:55:25 <elliott> :t (&&& arr id)
18:55:27 <lambdabot> Arrow a => a c' c -> a c' (c, c')
18:55:57 <DanBurton> :t (arr id &&&)
18:55:58 <lambdabot> Arrow a => a c c' -> a c (c, c')
18:56:14 <elliott> :t \f -> (f &&& arr id) >>> arr (\(x,(_,y)) -> (x,y))
18:56:16 <lambdabot> Arrow cat => cat (t, t2) t1 -> cat (t, t2) (t1, t2)
18:56:30 <elliott> :t \f -> ((arr fst >>> f) &&& arr id) >>> arr (\(x,(_,y)) -> (x,y))
18:56:32 <lambdabot> Arrow cat => cat b t -> cat (b, t1) (t, t1)
18:56:41 <DanBurton> oh my
18:56:50 <elliott> tada
18:57:15 <DanBurton> elliott++
18:57:46 <elliott> well, technically you need ~(x, ~(_,y)) there I think if you want to match first
18:57:49 <elliott> for (->) at least
18:58:26 <DanBurton> @let newFirst f = \f -> ((arr fst >>> f) &&& arr id) >>> arr (\(x,(_,y)) -> (x,y))
18:58:28 <lambdabot>  Defined.
18:59:33 <DanBurton> > (length &&& id >>> newFirst (+1) >>> newFirst even >>> second head) [1,2,3]
18:59:34 <lambdabot>   Couldn't match expected type `(([a0], t20), t1)'
18:59:34 <lambdabot>              with actual t...
18:59:47 <DanBurton> @type newFirst
18:59:49 <lambdabot> Arrow cat => t -> cat b t1 -> cat (b, t2) (t1, t2)
19:00:03 <elliott>  f = \f ->
19:00:16 <DanBurton> derp
19:00:24 <DanBurton> @undefine
19:00:32 * DanBurton goes off to his own ghci session to play
19:02:01 <danharaj> edwardk: if the parameter to a free monad is the set of free variables a term closes over, what is the parameter to a cofree comonad?
19:05:14 <hpaste> “Jonathan Fischoff” pasted “Help with AD” at http://hpaste.org/83653
19:05:41 <jfischoff> man edwardk is really getting hammered tonight
19:06:05 <jfischoff> So just pasted an issue I am having with AD
19:06:22 <jfischoff> I think I am getting closer to the correct solution
19:07:47 * jfischoff doubts anyone is familiar enough with AD to help him ;(
19:09:15 <Saizan> forall a. Floating a => [a] -> a would be too restrictive as the type of the argument of laplacian?
19:11:43 <jfischoff> Saizan: can you annotate?
19:12:01 <danharaj> jfischoff: shouldn't you use grads to get higher order derivatives?
19:13:56 <jfischoff> danharaj: Yeah … I just think of a gradient as a vector of derivatives, one for each variable
19:14:14 <arkeet> but gradient is really a covector
19:14:23 <danharaj> No, the differential is a covector :P
19:14:32 <arkeet> ...fine
19:14:44 <danharaj> arkeet: indices abused me as an undergrad
19:15:06 <arkeet> most of the time you really want the covector anyway
19:15:16 <jfischoff> danharaj: that example is mostly to show case my typing issue, it doesn't really do anything
19:16:29 <danharaj> jfischoff: I am simultaneously trying to grok AD the conecpt, AD the library, and your issue in an attempt to help. Bear with me :P
19:17:34 <jfischoff> danharaj: you have all the time in the world :)
19:17:42 <danharaj> No, I just waste what little I have.
19:17:47 <danharaj> (Not that helping you is a waste :P)
19:18:14 <jfischoff> I hope not
19:18:59 <hpaste> Saizan revised “Help with AD”: “more polymorphic” at http://hpaste.org/83653
19:20:08 <jfischoff> Saizan: I think that case you can't pass a Floating instead of Fractional
19:20:35 <hpaste> asdf pasted “asdf” at http://hpaste.org/83655
19:20:47 <hpaste> asdf pasted “asdf” at http://hpaste.org/83656
19:20:52 <jfischoff> Saizan: I'm trying to get away from putting the constraints in the higher rank parts
19:21:15 <hpaste> asdf pasted “asdf” at http://hpaste.org/83658
19:21:35 <hpaste> asdf pasted “asdf” at http://hpaste.org/83659
19:21:40 <danharaj> Really?
19:22:04 <danharaj> hpaste: Someone is abusing you I think?
19:23:01 <Saizan> jfischoff: oh, i actually meant to put Floating there, but same difference
19:23:32 <hpaste> asdf pasted “asdf” at http://hpaste.org/83660
19:23:57 <danharaj> jfischoff: ok I think I get AD and ad. What is it that ails you
19:24:21 <jfischoff> Saizan: The "working" version that I have uses RealFloat  and I use (fromRational . toRational) to make things polymorphic
19:24:59 <jfischoff> danharaj: So basically I want the unAD function in the paste http://hpaste.org/83653
19:25:14 <danharaj> jfischoff: ok. why?
19:26:07 <jfischoff> oh wait
19:26:15 <jfischoff> that is not the right paste
19:27:50 <jfischoff> http://hpaste.org/revision/83653
19:27:55 <jfischoff> there we go
19:29:15 <jfischoff> alright where are we. I don't want constraints in the higher ranked parts, too restrictive. I need a type with like (forall s r. (Mode s, Mode r) => ([AD s (AD r Double)] -> AD s (AD r Double)) because I take the gradient twice
19:29:40 <jfischoff> but I can't then convert my input function to [Double] -> Double
19:29:53 <jfischoff> which in need to for my numerical solver
19:31:18 <jfischoff> danharaj: does that make any sense?
19:31:42 <hpaste> a pasted “t” at http://hpaste.org/83661
19:32:35 <danharaj> jfischoff: It will eventually :P Now, the predefined solvers for various problems packaged with AD have different types than what you want. I am curious why?
19:32:51 <hpaste> a pasted “t” at http://hpaste.org/83662
19:33:11 <hpaste> a pasted “t” at http://hpaste.org/83663
19:33:51 <jfischoff> danharaj: I'm using a solver that doesn't come with AD
19:34:22 <danharaj> oh ok I see.
19:35:11 <jfischoff> danharaj: I have been given the suggestion to look at the Identity mode
19:35:20 <jfischoff> which sounds like it could be the key
19:35:39 <hpaste> a pasted “t” at http://hpaste.org/83664
19:35:45 <danharaj> jfischoff: I cannot find such a mode.
19:36:33 <hpaste> a pasted “tttt” at http://hpaste.org/83665
19:36:42 <jfischoff> well as it turns out it doesn't exist
19:36:54 <danharaj> jfischoff: It may have been a subtle request for a pull request ;)
19:37:04 <hpaste> a pasted “ttttttttt” at http://hpaste.org/83666
19:37:11 <YayMe> Does anybody have any effective definitions for a "combinator" ? I've heard it referencing higher-order functions, pure functions, functions that return functions, just small functions, functions that only reference parameters, is any one of these completely incorrect to call a "Combinator" ?
19:37:33 <jfischoff> danharaj: :)
19:37:35 <danharaj> YayMe: combinator is pretty much as generic as 'function'
19:38:03 <arkeet> as generic as?
19:38:11 <arkeet> function has a pretty specific meaning.
19:38:36 <danharaj> does it?
19:38:42 <hpaste> a pasted “tttt123” at http://hpaste.org/83667
19:38:43 <arkeet> doesn't it?
19:38:44 <YayMe> danharaj: that's what I thought, but I'm writing some stuff up and just wanted to be sure I wasn't using any totally *wrong* rules
19:38:59 <danharaj> arkeet: I would say it depends on where you're defining functions.
19:39:08 <danharaj> e.g. difference between functions in Set and functions in DCPO
19:39:15 <arkeet> I thought we were talking about haskell.
19:39:35 <danharaj> Were we? I thought we were talking about in general :\ my bad.
19:39:38 <YayMe> arkeet: Nah, I'm just referring to the term in general programming
19:40:09 <YayMe> combinators can be written in any language (probably)
19:40:42 <danharaj> jfischoff: I just noticed the grad' function which you could use
19:40:45 <YayMe> err, generally. not so sure you could write one in regexp
19:41:06 <jfischoff> danharaj: lowerFU in http://hackage.haskell.org/packages/archive/ad/3.4/doc/html/Numeric-AD-Types.html
19:41:09 <jfischoff> I think is it
19:41:28 <danharaj> jfischoff: indeed, good catch
19:41:44 <jfischoff> danharaj: edwardk told me ;)
19:42:02 <jfischoff> in retrospect I should used yahoo
19:42:18 <danharaj> jfischoff: I once asked edwardk a rather insipid and obscure question and he referred me to a dusty corner of a long deprecated library he once wrote.
19:42:27 <danharaj> It was exactly what I needed.
19:42:39 <jfischoff> :)
19:42:49 <edwardk> hah
19:43:19 <danharaj> edwardk: I have another insipid question if you scroll up :3
19:43:25 <mgsloan> YayMe: I just got here, so I don't know what the context is, but:  Haskell makes combinators reasonable to use.  Here's an unreasonable use of such power: http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
19:43:30 <jfischoff> edwardk: hey man its hard to tell edward stories when your right here ;)
19:43:53 <edwardk> danharaj: hard to find in the scroll. what do you need?
19:44:22 <danharaj> edwardk: I was thinking of free monads and how their parameter is the set of variables a term closes over. I was wondering what the parameter to a free comonad is?
19:44:22 <YayMe> mgsloan: yeah I just saw that blog the other day heh, but that said what would you say are *required* rules for a function to follow before it can be referred to as a "combinator" ?
19:44:50 <elliott> nobody really agrees on the definitoin of "combinator"
19:45:00 <edwardk> 3that is the type of decorations/annotations you've put on the 'syntax tree'
19:45:22 <YayMe> elliott: that's what I thought.
19:45:22 <mgsloan> Yeah, it's definitely informal.  I'd say it's an operator that takes functions as one or both of its arguments
19:45:26 <danharaj> edwardk: hm. I had this picture of cofree comonads as the type of generalized state machines, not really syntax trees.
19:45:31 <edwardk> elliott: ?
19:45:38 <edwardk> A combinator is a higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
19:46:32 <edwardk> danharaj: take a syntax tree defined with Mu. replace Mu f with Cofree f a  -- the a is now dangling at every recursive invocation. those are annotations. you can use them for synthesized and inherited attributes, etc.
19:46:43 <edwardk> it gives you a generalized notion of an attribute grammar
19:47:01 <edwardk> danharaj: http://comonad.com/reader/2009/incremental-folds/
19:47:23 <edwardk> that uses the cofree comonad and some typeclass machinery to generate 'precalculated' folds over data.
19:47:39 <edwardk> e.g. like storing size in the nodes of a Map.
19:47:42 <YayMe> edwardk: yeah, that's my favorite definition as well, and what I write will kind of culminate there as that ruleset on a function is where you get the useful benefits of combinators
19:48:10 <YayMe> Ok. I'm satisfied now that I can write about combinators without anybody complaining that I'm defining them incorrectly since nobody agrees in here as I figured..
19:48:20 <edwardk> YayMe: well, its the definition from combinatory logic, where the term came from
19:48:26 <danharaj> YayMe: If edwardk gives you a definition, you use it.
19:48:31 <edwardk> danharaj: hah
19:48:37 <danharaj> (sometimes in your code)
19:49:31 <danharaj> edwardk: so I had this idea stuck in my head that free monads ought to be Mu fixpoints and cofree comonads ought to be Nu fixpoints, so the idea of treating them as syntax trees is a bit weird to me right now.
19:49:33 <elliott> edwardk: sure, there are reasonable definitions of combinator, multiple in fact :P
19:49:44 <elliott> I agree that's the best one but it seems just too confusing to use it in practice
19:51:02 <YayMe> edwardk: I know, but there's terms from math/logic like that which people disagree with the use of in programming. mgsloan just had a different definition of it.
19:52:51 <edwardk> elliott: well, it comes up when you start giving things semantics, so i figure its the best one to stick to
19:53:19 <ofan> Hello, I have a question about conduits, is it possible to connect a conduit to two sinks, so the conduit broadcasts the data to all connected sinks, like the pub/sub pattern?
19:53:41 <edwardk> that reminds me i should try to post up dolio's normalization by evaluation talk, which is done entirely in terms of combinators =P
19:54:28 <mgsloan> YayMe: True, but edwardk's is definitely more precise.  It might be better to just call my definition a higher order function (that happens to be an operator).  I haven't really heard people say "higher order operator", but maybe using that term instead could reduce the aliasing of the term combinator
19:55:43 <BrianHV> ofan: there's a conduitFile function that may be worth looking it. it appears that it works by both consuming and passing along the data
19:56:25 <YayMe> mgsloan: I think the confusion comes from how you use combinators and the fact that you can write functions that don't follow the rules but still are useful similarly so
19:56:46 <BrianHV> ofan: also, zipSinks
19:57:36 <ofan> BrianHV: OK, I'll take a look at it. Thanks
20:00:00 <YayMe> edwardk: to complete that definition, can you tell me, in combinatory logic is it still a combinator if it takes a value? I'm thinking it's not just a higher-order function, but a functino that *only* takes functions (not a function and a value). Yes, no?
20:00:59 <YayMe> ...my finger *always* finds the n before the o...I'll just presume functino is is an italian function...
20:01:17 <edwardk> the 'only takes functions' is an unnecessary constraint to me.
20:01:24 <jfischoff> > length (undefined :: (forall s. Mode s => [AD s Double]))
20:01:25 <lambdabot>   Ambiguous occurrence `Mode'
20:01:26 <lambdabot>  It could refer to either `Text.PrettyPrint.Hug...
20:01:32 <heatsink> It's clearly a subatomic particle, superpartner to functions.
20:01:40 <jfischoff> I'm surprised that won't type check
20:01:41 <YayMe> edwardk: but it has to accept at least one function then?
20:02:08 <edwardk> why?
20:02:15 <danharaj> heatsink: are functions bosons or fermions?
20:02:21 <YayMe> you called it a higher-order functino, were you referring to it must return a function?
20:02:28 <jfischoff> if I am calling length on something why does it matter what the type of a is in [a]
20:02:44 <edwardk> the higher order was more about enabling it to be higher order than restricting it from being first-order =P
20:02:52 <YayMe> ah
20:02:53 <Saizan> jfischoff: it only matters when classes are involved
20:03:06 <jfischoff> why?
20:03:07 <Saizan> jfischoff: because it has to pick a dictionary
20:03:16 <Saizan> otherwise there's no list.
20:03:27 <tac> > length (undefined :: (forall s. Show s => [s]))
20:03:28 <lambdabot>   *Exception: Prelude.undefined
20:03:54 <tac> > length ([undefined] :: (forall s. Show s => s))
20:03:56 <lambdabot>   Could not deduce (s ~ [t0])
20:03:56 <lambdabot>  from the context (GHC.Show.Show s)
20:03:56 <lambdabot>    bound by...
20:03:57 <tac> oops
20:04:12 <jfischoff> so it has to pick a dictionary even though one isn't being used?
20:04:41 <jfischoff> well how does one get around that?
20:04:49 <Saizan> jfischoff: it can't tell that the dictionary won't affect the length of the list
20:05:12 <jfischoff> how could anything affect length?
20:05:36 * jfischoff a teachable moment is quickly approaching
20:05:58 <Saizan> ?type \x -> replicate (sizeOf x) x
20:06:00 <lambdabot>     Not in scope: `sizeOf'
20:06:00 <lambdabot>     Perhaps you meant one of these:
20:06:00 <lambdabot>       `IM.size' (imported from Data.IntMap),
20:06:38 <Saizan> ?type \x -> replicate (Foreign.StorablesizeOf x) x
20:06:39 <lambdabot>     Not in scope: data constructor `Foreign.StorablesizeOf'
20:06:41 <jfischoff> @t sizeof
20:06:41 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
20:06:42 <Saizan> ?type \x -> replicate (Foreign.Storable.sizeOf x) x
20:06:44 <lambdabot> Foreign.Storable.Storable a => a -> [a]
20:06:50 <jfischoff> > :t sizeof
20:06:52 <lambdabot>   <hint>:1:1: parse error on input `:'
20:06:55 <jfischoff> :p
20:07:05 <Saizan> you can elide the argument there
20:07:21 <shachaf> You can never elide the argument in #haskell.
20:07:27 <jfischoff> is ? the syntax for an implicit?
20:07:41 * hackagebot notmuch-web 0.1.0.1 - A web interface to the notmuch email indexer  http://hackage.haskell.org/package/notmuch-web-0.1.0.1 (JohnLenz)
20:07:45 * jfischoff is confused
20:07:48 <Saizan> ?type fix $ \x -> replicate (Foreign.Storable.sizeOf x) undefined
20:07:50 <lambdabot> Foreign.Storable.Storable [a] => [a]
20:08:03 <jfischoff> ?type sizeof
20:08:05 <lambdabot>     Not in scope: `sizeof'
20:08:05 <lambdabot>     Perhaps you meant one of these:
20:08:05 <lambdabot>       `IM.size' (imported from Data.IntMap),
20:08:09 <Saizan> ?type fix $ \x -> replicate (Foreign.Storable.sizeOf (head x)) undefined
20:08:10 <lambdabot> Foreign.Storable.Storable a => [a]
20:08:13 <Saizan> there
20:08:37 <shachaf> @yarr
20:08:37 <jfischoff> what am I looking at?
20:08:37 <lambdabot> Yeh scurvy dog...
20:09:00 <shachaf> A list whose length depends on the sizeOf its elements, presumably.
20:09:07 <Saizan> > let xs = fix $ \x -> replicate (Foreign.Storable.sizeOf (head x)) undefined in length (xs :: [Int32])
20:09:09 <lambdabot>   Not in scope: `Foreign.Storable.sizeOf'
20:09:19 <Saizan> yes
20:09:32 <Saizan> except lambdabot is not helping
20:09:58 <elliott> genericReplicate + fromInteger, perhaps?
20:10:05 <elliott> (+ Word types)
20:10:34 <jfischoff> so the size of the array depends on the result of sizeOf
20:10:40 <jfischoff> which is based on the dictionary?
20:10:53 <Saizan> right
20:11:15 <jfischoff> I see why that is the case there
20:11:31 <jfischoff> but why does it have to assume that is the case in general?
20:11:38 <Saizan> (s/array/list/)
20:11:48 <jfischoff> yeah
20:12:57 <Saizan> let me ask you, what should it use for the dictionary when it can't tell which one you want?
20:13:06 <Saizan> undefined?
20:13:10 <jfischoff> yes
20:13:31 <jfischoff> which I guess
20:13:32 <Saizan> you can do so yourself
20:13:51 <Saizan> data Undef; instance Mode Undef
20:14:00 <Saizan> then add a type annotation
20:15:56 <jfischoff> will it blow up in my face in some unforeseen way?
20:16:50 <YayMe> edwardk: Is there a "second-order-function" vs "third-order-function" etc, or is it first and higher-order? Just trying to make sure I don't misuse terminology..
20:17:07 <edwardk> http://en.wikipedia.org/wiki/Second-order_logic
20:18:06 <tac> YayMe: You can talk about n-order functions
20:18:18 <tac> but 3rd order and above are pretty rare
20:18:21 <Saizan> jfischoff: it shouldn't
20:18:37 <jfischoff> Saizan: cool thanks
20:18:42 <edwardk> tac: callCC is rank-3 done right
20:20:06 <YayMe> ...and now I (presume to) know where the language HOL got it's name...
20:20:09 <tac> I remember in Ben's thesis on the DDC language, he talks about an issue he had with effects in higher order functions
20:20:22 <tac> And he talked a bit about examples of 3rd 4th, and 5th order
20:20:36 <tac> but by the time you get to 4, it becomes incredibly difficult to even come up with examples
20:20:49 <tac> that you would see in the wild *
20:21:01 <tac> citing parsers, I think, for a "very high order function"
20:21:30 <edwardk> yeah i don't have any 4th rank types i use. i have a number of third rank types in my code
20:21:49 <danharaj> I am mostly a rank 2 programmer. I think I have used a rank 3 type once.
20:21:58 <danharaj> (Then again I am bad at counting ranks)
20:21:59 <YayMe> I'm unranked :(
20:22:02 <edwardk> machines uses a rank 3 type
20:22:37 <heatsink> Machines?  Like airplanes?
20:22:43 * heatsink is missing something
20:22:47 <edwardk> @hackage machines
20:22:47 <lambdabot> http://hackage.haskell.org/package/machines
20:22:50 <danharaj> edwardk: I think I am bad at counting ranks then.
20:22:55 <heatsink> ok
20:23:34 <edwardk> newtype PlanT k o m a = PlanT { runPlanT :: forall r. (a -> m r) -> (o -> m r -> m r) -> (forall z. (z -> m r) -> k z -> m r -> m r) -> m r -> m r }
20:24:10 <edwardk> the forall r. in there takes us to rank 2 when you look at runPlanT. the forall z raises it to rank 3.
20:24:18 <shachaf> callCC uses a rank-3 types
20:24:25 <shachaf> Well, it doesn't. But maybe it should.
20:24:34 <edwardk> it should
20:24:36 <edwardk> it doesn't
20:24:38 <danharaj> ah hm
20:24:46 <edwardk> there is a way to break it up into two rank 1 types though
20:24:57 <shachaf> The easy way is to just use Void
20:25:00 <edwardk> by 'label' and 'break' to borrow terms from some old code of mine
20:25:09 <shachaf> How do those work again?
20:25:29 <elliott> runPlanT isn't actually rank-2 with just the r is it?
20:25:36 <elliott> as in, the accessor itself is rank-1, modulo the z
20:25:44 <elliott> but PlanT is rank-2.
20:25:44 <edwardk> :t Control.Monad.Cont.callCC
20:25:46 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
20:25:51 <shachaf> Do you count polymorphic components as rank-2?
20:26:15 <edwardk> sorry PlanT
20:26:21 <edwardk> not runPlanT
20:26:24 <danharaj> I haven't thought of foralls inside of data constructors as higher rank.
20:26:43 <shachaf> It makes sense, since the constructor is rank-2
20:26:53 <edwardk> PlanT :: (forall r. (a -> m r) -> (o -> m r -> m r) -> (forall z. (z -> m r) -> k z -> m r -> m r) -> m r -> m r) -> PlanT k o m a
20:27:01 <shachaf> GHC has a slightly weaker extension for it, I think.
20:27:17 <danharaj> I think GHC is going to smash down all the Rank stuff into one extension next release?
20:27:28 <danharaj> I know that Rank2 is being deprecated in favor of just RankN
20:27:43 <edwardk> danharaj: kind of a shame, i liked the separation. there at least exists in theory an inference algorithm for rank 2. its just terrible
20:28:18 <danharaj> edwardk: It would be quite nice for GHC to be able to infer them.
20:28:28 <danharaj> It would also be nice if you could use (.) with higher rank types :(
20:28:35 <edwardk> ghc has too many other balls in the air for that to happen ;)
20:28:35 <danharaj> (well, use it without going insane)
20:28:41 * shachaf wonders how you do rank-2 inference.
20:28:51 <shachaf> You can encode existentials with that, can't you?
20:29:32 <tac> yeah
20:29:38 <YayMe> edwardk: Are there any constraints on combinators regarding their relation to generics? (not even certain what "generics" are in terms of math/logic)
20:29:44 <shachaf> So I'm not quite sure how it works.
20:29:54 <edwardk> 'generics'?
20:29:57 <jfischoff> edwardk: whats a fast traversable to use with AD?
20:29:58 <tac> YayMe: generics like java generics?
20:30:38 <YayMe> tac: generics like a
20:30:44 <jfischoff> is there any wrangle Vector into Traversable?
20:30:46 <tac> a?
20:30:52 <tac> Like [a] -> Int?
20:30:58 <YayMe> yes
20:31:00 <tac> ah
20:31:05 <tac> Those are universal quantifiers in logic
20:31:10 <edwardk> @google a direct algorithm for type inference in the rank 2 fragment of the second order lambda calculus
20:31:10 <YayMe> ah
20:31:13 <tac> "For all types a", [a] -> Int
20:31:13 <lambdabot> http://dcommon.bu.edu/xmlui/bitstream/handle/2144/1475/1993-017-finite-rank.pdf?sequence=1
20:31:13 <lambdabot> Title: A Direct Algorithm for Type Inference in the Rank 2 Fragment of the Second-Order ...
20:31:38 <tac> Same as in math "for all integers n, n is either even or odd"
20:32:07 <tac> [a] -> Int   means in logic    "for every type a, a list of a has a integer (it's length)"
20:32:14 <tac> an*
20:33:17 <YayMe> :t (\x -> 3)
20:33:18 <lambdabot> Num a => t -> a
20:33:41 <YayMe> tac: and in that type sig what is t?
20:34:37 <latro`a> any type
20:34:37 <ab9rf> YayMe: a type
20:35:18 <latro`a> > (\x -> 3) undefined
20:35:19 <tac> YayMe: That is read "for any type a and any type t, IF a is a numeric type, then t implies a"
20:35:20 <lambdabot>   3
20:35:58 <tac> YayMe: (the -> can either mean "is a function that takes _ and returns _.... or it can mean _ implies _)
20:36:25 <YayMe> thanks, and that's a "universal quantifier" ?
20:36:29 <tac> yes
20:36:46 <tac> the type variables are (implicitly) universally quantified over
20:36:50 <tac> :t length
20:36:52 <lambdabot> [a] -> Int
20:36:59 <tac> :t length :: forall a. [a] -> Int
20:37:00 <lambdabot> [a] -> Int
20:37:11 <tac> See how "forall a." is optional :)
20:37:35 <ab9rf> it's implicit, mainly because it makes little sense otherwise
20:38:08 <tac> it's just implicit because it's shorter and in Haskell '98, you can't have forall anywhere but at the front
20:38:58 <heatsink> I have some confusion about matrices.  Matrices are usually described as if they were two-dimensional arrays of numbers.
20:39:03 <heatsink> That is certainly a canonical way to represent a matrix.
20:39:11 <heatsink> But matrices with very specific structure, such as diagonal matrices, are also described this way
20:39:21 <heatsink> even when people write code that never refers to the zeros and use data structures that do not store the zeros.
20:39:27 <heatsink> By this point, what's the point of pretending that a matrix is a two-dimensional array of numbers?
20:39:44 <tac> heatsink: are you talking about matrices like the ones in math class?
20:39:48 <heatsink> yeah
20:40:17 <tac> Matrices are just a nice finite way of representing linear maps
20:40:27 <heatsink> Yes
20:40:54 <tac> They depend on a choice of basis, which makes them bias and deceptive. It's best to avoid them as long as possible :)
20:41:30 <tac> a matrix *is* the two dimensional array of numbers, btw
20:41:31 <heatsink> But, in my experience, people who do numerical algorithms (such as computational physicists) do not understand matrices as linear maps.
20:41:37 <tac> yeah
20:41:42 <shachaf> OK, what does it mean to do rank-2 inference?
20:41:48 <shachaf> Can you infer a type for (\x -> x x)?
20:42:03 <tac> I'm trying to learn about multilinear algebra, and it's irritating. So many resources only talk about matrices
20:42:11 <heatsink> What do you mean by "a matrix is the two dimensional array of numbers"?
20:42:18 <tac> I mean, by definition
20:42:25 <tac> a matrix is a two dimensional array of numbers
20:42:30 <tac> that's what a matrix *is*
20:42:33 <tac> :)
20:42:36 <danharaj> tac: You want a resource that is directed at mathematicians. The physicist's definition of a tensor is a multi-indexed matrix that transforms in a certain way!
20:42:44 <heatsink> alright...
20:42:51 <edwardk> tac: just think of a tensor as adding more dimensions
20:42:57 <centrinia> A matrix can be a two dimensional array of certain non-numbers.
20:43:08 <tac> edwardk: I want a universal mapping property for them!
20:43:18 <tac> and a deeper understanding of how they fit together with the rest of the subject :)
20:43:33 <tac> @type (\x -> x x)
20:43:35 <lambdabot>     Occurs check: cannot construct the infinite type: t1 = t1 -> t0
20:43:35 <lambdabot>     In the first argument of `x', namely `x'
20:43:35 <lambdabot>     In the expression: x x
20:43:58 <shachaf> @ty (\x -> x x) :: (forall a. a -> a) -> b -> b
20:43:59 <lambdabot> (forall a. a -> a) -> b -> b
20:44:00 <edwardk> they are just matrices with more dimensions
20:45:03 <edwardk> and where gaussian elimination doesn't work
20:46:03 <heatsink> I can accept that matrices are defined in terms of 2D array of numbers.  When your algorithm doesn't actually build the array, it still seems more natural to think of them as linear maps.
20:46:20 <tac> gaussian ellimination is just an inverse-finding algorithm, right?
20:46:28 <tac> the naive inverse algorithm, in a sense
20:46:43 <tac> heatsink: I agree. Linear maps are much more natural.
20:47:11 <tac> But because linear algebra is so damn practical, you end up with a lot of practical applications
20:47:22 <tac> with no respect for the symmetry and beauty of the subject!
20:48:40 <tac> shachaf: It's strange Haskell with rank2types can't infer the type there
20:49:02 <tac> I would think that's exactly what rank 2 type inference means
20:49:04 <shachaf> tac: Why? GHC doesn't even pretend to try to infer rank-2 types.
20:49:25 <tac> The flag just makes it legal to use the syntax then?
20:49:27 <tac> gotcha
20:50:26 <jfischoff> are there any traversable instances that can store a list of doubles in a contiguous array of memory?
20:50:52 <shachaf> tac: And that's not "the most general type" for that function.
20:50:53 <heatsink> There are no functors that can do that
20:50:58 <edwardk> no
20:51:01 <shachaf> You can give it other incompatible types.
20:51:45 <heatsink> jfischoff, there are no generic data structures that can store doubles contiguously in memory, so no.
20:52:04 <ab9rf> why do you wan tto store doubles contiguously in memory?
20:52:25 <edwardk> ab9rf: cache coherence
20:52:30 <jfischoff> would is my best bet if I plan on handing of an traversable to an array via FFI
20:52:35 <jfischoff> well that too
20:52:43 <shachaf> I'd prefer to store doubles continuously in memory. But unfortunately they are discrete.
20:52:52 <edwardk> shakakai: =P
20:52:58 <ab9rf> shachaf: ha
20:53:05 <edwardk> poor shakakai takes many comments intended for shachaf
20:53:05 <heatsink> Your best bet would be to write traversable-like functions for UArray Double
20:53:12 <shakakai> :/
20:53:14 <heatsink> or UVector Double
20:53:15 <shakakai> :D
20:53:17 <ab9rf> edwardk: i imagined it was to allow for the use of a vector primitive :)
20:53:28 <shachaf> I guess I should read the paper edwardk linked to.
20:53:37 <edwardk> ab9rf: i assume its because he wants to use combinators directly from 'ad' on it
20:53:52 <jfischoff> well I need to pass a traversable of to functions that take traversable, when I am done I pass to a c++ function
20:53:56 <shachaf> But instead of that I can just complain?
20:54:00 <jfischoff> edwardk: yeah
20:54:09 <heatsink> myDoubleArray Array.! pi
20:54:42 <zachk> hello all...
20:54:45 <edwardk> shachaf: you can?
20:54:46 <zachk> what is a linear map?
20:54:49 <tac> heatsink: It's interesting you brought that up about matrices. That's something I was thinking about today and yesterday.
20:55:00 <jfischoff> vector homomorphism
20:55:03 <ab9rf> and we're back to linear maps
20:55:14 <shachaf> edwardk: Well, don't I?
20:55:24 <jfischoff> vector space
20:55:26 <jfischoff> :p
20:55:39 <heatsink> A linear map is a linear function between cartesian spaces.
20:55:48 <tac> cartesian spaces?
20:55:59 <ab9rf> poker, bridge, rummy, blackjack
20:56:00 <heatsink> I think that's what R^N is called
20:56:02 <tac> R isn't a cartesian space is it? :)
20:56:06 <tac> Just regular R
20:56:15 <tac> or {0}, the trivial vectorspace :)
20:57:02 <heatsink> Well, that's R^1 and R^0
20:57:22 <ab9rf> what about R^0.5 ?
20:57:37 * lispy mumbles something about hilbert
20:57:48 <heatsink> Depends on whether the continuum hypothesis is true
20:57:53 <tac> heatsink: What about the set of functions R -> R that are defined by finite linear combinations of sinusoids?
20:57:54 <jfischoff> ?
20:58:02 <centrinia> What about R^{-1} ?
20:58:35 <ab9rf> heatsink: i had a professor who explained how to take the half derivative of a function once
20:58:45 <tac> centrinia: Nat is the preferred monoid around here!
20:59:15 <jfischoff> heatsink: all R^n have the same cardnality
20:59:18 <ab9rf> heatsink: mind you, my undergrad degree is in political science
20:59:34 <jfischoff> the continuum hypothesis has nothing to do with this I think
20:59:37 <heatsink> I didn't know you could half differentiate something
20:59:43 <tac> jfischoff: I think he meant AoC
20:59:49 <jfischoff> fractional calculus
21:00:06 <ab9rf> heatsink: i'm fairly certain that's what he did. it took nearly 20 minutes to explain
21:00:23 <tac> only 20 minutes?
21:00:32 <tac> For math, 20 minutes to explain something is fantastic!
21:00:34 <ab9rf> heatsink: i won't try because i'm certain to get it wrong, i did't really understand it then and that was over 20 years ago
21:01:03 <ab9rf> i think it involved hilbert spaces in some way
21:01:07 <zachk> so linearMap :: (Natural n,m) => R^n -> R^m (to not get too philosophical)
21:01:46 <tac> zachk: you can't really phrase it that way...
21:01:58 <zachk> oh
21:01:59 <heatsink> tac, you're pointing out that there can be linear maps involving spaces that aren't R^n?
21:02:00 <jfischoff> tac: perhaps AoC is needed for fractional dimensions but I don't it. Its mostly about ratios of limiting processes Ithink
21:02:01 <tac> zachk: think of it more like a typeclass with some laws that need to be satisfied.... sorta
21:02:06 <zachk> how ma it be phrased
21:02:19 <zachk> ooo, kinda of an algebra over vector(spaces) ?
21:02:24 <tac> heatsink: right
21:02:34 <zoheb> If I define a method with : it should be right associative?
21:02:40 <tac> Not to mention, you can also have linear functions for non-real vectorspaces
21:02:53 <tac> Sometimes we want Vectorspaces over C
21:03:00 <tac> or (rarely) over some finite field
21:03:08 <zachk> actually
21:03:13 <zachk> over finite fields
21:03:14 <Cale> If V and W are vector spaces over some field F, then a linear map T: V -> W is a function V -> W such that for any v,v' in V and any a in F, you have T(v + v') = T(v) + T(v') and T(a*v) = a*T(v)
21:03:16 <heatsink> You're right.  I don't spend much time thinking about uncountable things.
21:03:19 <zachk> is huge in crypto and security
21:03:25 <tac> hi Cale
21:03:28 <zachk> things like credit card verifications etc
21:03:28 <Cale> hi
21:03:38 <tac> zachk: ah yeah. It would be important there, wouldn't it? :)
21:03:48 <Cale> R^n is an example of a vector space over the field R.
21:04:02 <zachk> o
21:04:24 <monochrom> hi, I have a homework question. what is the splitting field of x^5 - 2? hehe
21:04:30 <tac> Something I was wondering last night was.... are all finite dimensional vectorspaces over R iso R^n for some n?
21:04:42 <zachk> they are linear as in I can "extract"/undistribute the a
21:04:50 <lispy> Cale++
21:04:51 <zachk> ?
21:05:07 <tac> zachk: f(x+y) = f x + f y
21:05:10 <monochrom> yes tac
21:05:13 <tac> and f(a * x) = a * f x
21:05:22 <tac> (where a is a scalar and x and y are vectors
21:05:39 <zachk> also would f(x*a) = f x * a be implied?
21:05:42 <lispy> Cale: so, if you want to describe it in terms of homomorphisms. I guess it respects bot the additive and multiplicative subgroups?
21:06:04 <tac> zachk: nope.
21:06:07 <tac> err
21:06:08 <ab9rf> zachk: x*a isn't necessarily even defined
21:06:10 <Cale> lispy: Well, it respects vector addition and scalar multiplication
21:06:11 <tac> a * f(x)
21:06:19 <lispy> Cale: oh, good point.
21:06:26 <monochrom> f x * a = (f x) * a = yes
21:06:26 <zachk> and so a is.... a constant? *duck*
21:06:43 <tac> I've seen a vary before
21:07:00 <tac> what's important is that it's a scalar in the underlying field
21:07:02 <Cale> Well, a is an element of the field F.
21:07:03 <Cale> yeah
21:07:04 <zachk> more so as a parameter?
21:07:07 <zachk> ok
21:07:13 <Cale> This is supposed to be true of any a in F.
21:07:19 <Cale> and any x in V
21:07:27 <zachk> all or any?
21:07:33 <Cale> all = any
21:07:37 <zachk> aight
21:07:47 <zachk> thank you for the intro tutorial on linear maps
21:07:57 <tac> f(x) = 2x
21:08:18 <tac> f(1 + 1) = 2(1 + 1) = 2 + 2 = f(1) + f(1)
21:08:43 <tac> f(2 * 2) = 2 * f(2) = 2 * 2(2) = f(4)
21:08:52 <monochrom> you can also talk about linear maps for modules
21:08:59 <zachk> o_O
21:09:28 <Cale> Or, perhaps even slightly more enlightening there: f(x+y) = 2(x+y) = 2x + 2y (by distributivity), which is then equal to f(x) + f(y)
21:09:31 <monochrom> haha. a module is similar to a vector space. replace scalar field by scalar ring, that's all
21:09:40 <Cale> yeah
21:09:55 <Cale> Modules are much more complicated to try to study than vector spaces in general though.
21:10:04 <monochrom> of course, as a result, you stop talking about 1/a. that's all
21:12:12 <monochrom> there is no end to playing with mathematics
21:12:13 <Cale> For example, not all modules have a basis, and so don't necessarily have a dimension.
21:13:21 <Cale> and actually even modules which do have a basis don't necessarily have a unique dimension (or rank), depending on the underlying ring
21:13:38 <zachk> !!
21:14:21 <Cale> While for vector spaces, every vector space has a basis, and any two bases have the same cardinality
21:14:45 * monochrom had several years of fun time indulging in this zoo of mathematics. therefore, 5 years later, when he saw category theory, it was easy. "yeah, homomorphism -> morphism, of course!"
21:16:05 <tac> Cale: And to think my algebra book said modules had "nicer" properties than rings....
21:16:20 <tac> They tried short-selling me. I'll take vectorspaces, thank you
21:16:25 <Cale> tac: Well, nicer than rings, maybe
21:16:35 <Cale> But they're built over rings
21:16:53 <monochrom> wait, that cannot make sense. a ring is already a module.
21:16:55 <Cale> and so if the underlying rings have shitty properties, then the modules might be a bit screwy too
21:17:04 <tac> yeah
21:17:08 <Cale> Well, a ring is a module over itself :P
21:17:29 <tac> monochrom: That's how I feel when I see most "applied" math stuff now
21:17:41 <tac> "Just show me the category, and I'll figure out the rest"
21:18:06 <Cale> That's...
21:18:54 <monochrom> categorical :)
21:19:18 <monochrom> oh, I know!
21:19:21 <tac> Maybe that's a bit extreme.... but I don't like it when wikipedia articles start off with an example before getting to the definition.
21:19:31 <monochrom> That's... natural! :)
21:19:53 <monochrom> or maybe: That's... universal! :)
21:19:56 <Cale> Well, applied mathematics usually needs some kind of interpretation in terms of stuff outside mathematics, and that's often where most of the trickiness lies, I think. Maybe that's a bit untrue, there can be a lot of complexity and details on the mathematical side of things too, but often that's not so easily captured just with broad categorical structures.
21:20:31 <Cale> Maybe there are ways to make it happen sometimes though, and categorify various physical models :)
21:21:13 <tac> I'm just trying to post-rationalize my own hangups when I see things explained at a certain level of concreteness
21:21:41 <tac> I just plug my ears, going "lalala" and google the general concept later that night
21:23:06 <tac> too much detail clutters the mind
21:28:53 <ExternalReality> Is it safe to do the following: unsafeIOToSTM $ deRefWeak weakpointer
21:28:53 <ExternalReality> The docs seem to be telling me "Don't try it!"
21:33:08 * hackagebot regex-deriv 0.0.2 - Replaces/Enhances Text.Regex. Implementing regular expression matching using Bzozoski's Deriviative  http://hackage.haskell.org/package/regex-deriv-0.0.2 (KennyLu)
21:33:48 <ExternalReality> Is it safe to do the following: unsafeIOToSTM $ deRefWeak weakpointer
21:33:55 <ExternalReality> The docs seem to be telling me "Don't try it!"
21:34:22 <simpson> ExternalReality: The function has "unsafe" in the name. :3
21:38:27 <ExternalReality> Simpson: Well yes! :-), but I am trying to the documentation outlines some criteria that let you know why it is unsafe to call this function. The statement seems to be exempt from all except for the last. Which says that the transaction may have an inconsistent view of memory. This would mean that deRefWeak may not give the proper result inside a transaction.
21:39:04 <simpson> ExternalReality: Something like that.
21:39:54 <ExternalReality> Simpson: What does something like that mean?
21:40:24 <simpson> ExternalReality: I don't know the details of STM's implementation.
21:40:34 <simpson> But the docs are pretty accurate, I would imagine.
21:41:13 <ExternalReality> yea, it's all kinds of dangerous. *starts to cry*
21:42:46 <simpson> Why? What are you trying to do?
21:46:58 <ExternalReality> I want to give a function a weak pointer to a queue such that before it writes to the queue it has to check whether the queue has not been garbage collected or not. Now, I wouldn't want the to check to see if the queue still exist only to be told "yes" and then have it GC'ed right before I go to write to the queue. That would suck. So I try to stuff both the check and the write into a transaction.
21:47:33 <ExternalReality> Now the queue is already inside the STM monad but weak pointers are inside the IO monad.
21:47:54 <simpson> This sounds pretty complicated.
21:47:58 <ExternalReality> hence unsafeIOToSTM -- (* resumes crying *)
21:54:30 <lispy> ML style comments in #haskell?!
21:54:36 <lispy> how dare you? ;)
21:57:17 <Ericson2314> I have an instance of a binary monad where the get method is supposed to skip some bits before parsing another type, yet it seems skip does not happen. https://github.com/Ericson2314/Codec.Archive.CnCMix/blob/master/Codec/Archive/CnCMix/RedAlert/Normal.hs
22:00:55 <lispy> Ericson2314: skip 32 bits or 32 bytes?
22:01:24 <Ericson2314> oh haha
22:01:52 * Ericson2314  facepalms
22:02:37 <lispy> Ericson2314: I'd recommend using sizeof
22:02:40 <lispy> ?hoogle sizeof
22:02:41 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
22:02:41 <lambdabot> GHC.Constants sIZEOF_CostCentreStack :: Int
22:02:41 <lambdabot> GHC.Constants sIZEOF_generation :: Int
22:02:59 <lispy> > sizeOf (undefined :: Int32)
22:03:01 <lambdabot>   Not in scope: `sizeOf'
22:03:01 <lambdabot>  Perhaps you meant one of these:
22:03:02 <lambdabot>    `IM.size' (impor...
22:03:08 <lispy> well, you get the idea
22:03:20 <Ericson2314> I am sure I want 1 byte
22:03:24 <lispy> 0 would actually be shorter than undefined
22:03:45 <lispy> well your put instance will write out 4 bytes
22:03:53 <lispy> if you want get/put to be symmetric...
22:04:01 <Ericson2314> oh yeah
22:04:04 <Ericson2314> 1 word
22:04:08 <Ericson2314> (on 32 bit machine)
22:04:15 <covi> How can I completely remove anything Haskell-related (platform / diff. versions of ghc / cabal, etc) and reinstall them? I am using Mac OS X.
22:04:25 <Ericson2314> I am clearly my own worst enemy with this
22:04:30 <Ericson2314> 4 bytes
22:04:46 <lispy> Ericson2314: that's why I recommend using the sizeOf method for the get :)
22:04:52 <Ericson2314> I see now
22:04:52 <lispy> harder to get it wrong
22:04:58 <Ericson2314> indeed
22:05:13 <Ericson2314> ghc elimantates it with other constants too?
22:05:20 <lispy> covi: I suppose it depends on how you installed it
22:06:03 <lispy> Ericson2314: sizeOf gives the same answer for all values of type Int32
22:06:12 <lispy> Ericson2314: (not sure if I understood your question)
22:07:46 <Ericson2314> can ghc recognize size of (something) as a compile time constant?
22:08:02 <lispy> hmm...I'm not sure
22:08:19 <Ericson2314> not that this code needs to be super optimized but i was curious
22:08:45 <lispy> I think that you can add RULES to make it happen but I don't know if they exist by default
22:10:46 <Ericson2314> ok
22:10:48 <Ericson2314> thanks so much!
22:15:19 <Ericson2314> works!
22:46:22 <ExternalReality> Is it safe to do the following: unsafeIOToSTM $ deRefWeak wp
22:47:26 <simpson> ExternalReality: It is still unsafe.
22:47:34 <simpson> ExternalReality: It still has "unsafe" in the name. :T
22:51:32 <turiya> hi
22:53:41 <turiya> i am using JuicyPixels to load an image. it loads it as a DynamicImage. However DynamicImage is an algebraic data type (?). How do I find which one of the many alternatives it is?
22:54:15 <Cale> turiya: case?
22:54:41 <turiya> Cale: ok.. thanks i will try that
22:56:32 <lispy> JuicyPixels could use more examples of typical usage
22:56:54 <lispy> The library is pretty good but it's not always obvious how to use it
22:59:25 <tac> lispy: a lot of Haskell libs feel that way to me
22:59:31 <tac> sadl
22:59:33 <tac> y*
23:00:06 <hpaste> ExternalReality pasted “Pixels” at http://hpaste.org/83668
23:01:19 <ExternalReality> I just posted some example of JuicyPixels. I like this one since its a port of a TPL-data flow example on MSDN.
23:01:50 <ExternalReality> Output: http://s1290.beta.photobucket.com/user/externalreality/media/WindowsSampleBitmapsComposed_zps98a417b6.png.html
23:02:40 <lispy> that's pretty
23:04:02 <ExternalReality> I would assume you are talking about the jpg and not the code. ;-)
23:05:57 <turiya> Cale: thanks but I do not understand what to "case" on?
23:06:27 <mauke> the value you want to examine
23:07:04 <turiya> for example DynamiImage = ImayeY8 (Image Pixel8) | ImageYF (Image PixelF)
23:07:45 * hackagebot hArduino 0.6 - Control your Arduino board from Haskell.  http://hackage.haskell.org/package/hArduino-0.6 (LeventErkok)
23:07:51 <turiya> so if I want to know if a DynamicImage is an ImageY8 or ImageYF
23:08:01 <mauke> yes
23:08:44 <turiya> can I write "case ImageY8 a = b ... case ImageYF a = c" where a is a DynamicImage
23:09:05 <turiya> sorry b is a DynamicImage
23:09:27 <mauke> case b of ImayeY8 x -> ...; ImageYF y -> ...
23:09:58 <turiya> aha.. i understand now..thanks
23:10:07 <turiya> :mauke++
23:10:18 <mauke> (you don't need that ':')
23:10:32 <turiya> mauke++
23:11:01 <turiya> thanks
23:13:48 <[swift]> i feel like i'm missing something simple
23:14:05 <[swift]> if i have a bytestring with 4 bytes in it, how i can turn that into an Int?
23:14:22 <srhb> Using the Get monad.
23:14:50 <srhb> getWord32be/le
23:15:30 <[swift]> srhb: thanks, that gives me a good starting point
23:23:02 <lispy> [swift]: you could also convert each byte to an Int and then shift/add them
23:23:32 <[swift]> honestly maybe i should describe my _real_ problem
23:23:44 <[swift]> which is that i'm using cereal to serialize a data structure and send it over the network
23:23:59 <[swift]> and on the other end i'm using network-conduit to read it, and deserialize it with cereal again
23:24:07 <lispy> so far sounds good
23:24:11 <[swift]> the problem is that sometimes i don't get the whole thing in one chunk, obviously enough
23:24:25 <[swift]> i can't figure out how best to handle that
23:24:46 <[swift]> one option is to prepend a length and then explicitly read that number of bytes
23:25:00 <lispy> I've never used conduit so, but iteratees/enumerators had a way to deal with this
23:25:22 <[swift]> yeah, i feel like this should be simple
23:25:42 <[swift]> if you don't get all the data, just block until you get or more you get signaled that the socket closed
23:25:54 <[swift]> "get more or"
23:26:01 <lispy> in the iteratee world you'd layer your iteratees so that the inner one always gets the chunks it wants (or says, hey I need more input) and the outer layers deal with fetching
23:26:38 <lispy> do conduits have a way to say, "sorry, need more input"
23:26:59 <[swift]> they do have a way of doing that, indeed
23:27:13 <[swift]> but i hate to try the parse and then restart it over and over if it fails
23:27:23 <lispy> ah
23:27:46 <lispy> I think I'm out of my depth here (not familiar with the libs your using)
23:27:50 <lispy> and it's past my bedtime
23:27:52 <lispy> Good luck!
23:27:54 <[swift]> cereal supports incremental parsing but i had some difficulty getting it working. maybe i should try that again.
23:28:01 <[swift]> lispy: thanks for your help!
23:28:07 <lispy> yw
23:28:15 <johnw> [swift]: what about cereal-conduit?
23:29:00 <augur> ski: ping
23:29:06 <augur> sorry
23:29:08 <augur> ski: syn
23:29:49 <[swift]> johnw: hmm, that looks good like it might be what i'm looking for!
23:30:36 <ExternalReality> [swift]: I found this to be really simple to use -- http://msgpack.org/
23:30:49 <[swift]> ExternalReality: yeah, so did I. that was the first thing i tried
23:31:15 <[swift]> ExternalReality: i had the problem that it worked perfectly, but printed an error to the console every time a socket got closed
23:31:58 <[swift]> ExternalReality: i couldn't figure out where the problem was so i decided to give up and use something else
23:32:24 <[swift]> specifically i was using msgpack-rpc
23:33:07 <ExternalReality> [swift]: Oh, I just used the serialization bit and sent it over the wire myself -- well over zeromq socket.
23:33:45 <[swift]> ExternalReality: yeah, the serialization bit works fine for me. i can't use zeromq either alas, for this program. which is too bad; i used it before in c++ and it was great
23:51:48 <covi> I cd'ed into a fresh project dir and did 'yesod devel', but I encountered this error: yesod: readProcess: runghc "--numeric-version" "0" (exit 127): failed
23:53:57 <srhb> covi: What does runghc --numeric-version yourFile.hs say?
23:55:00 <srhb> covi: Or just runghc --numeric-version 0
23:56:10 <covi> srhb: nothing is outputed, and no errors
23:56:46 <srhb> covi: Nothing is output in your terminal? No version number?
23:56:50 <srhb> covi: Then that is your problem.
23:57:26 <srhb> covi: Your ghc installation appears to be broken.
23:57:52 <covi> srhb: yeah, I was aware of that, and I just did install haskell platform again.
23:58:27 <srhb> Oh, sorry, I didn't see there was a previous conversation on the topic
23:58:52 <covi> It's okay. Basically I downlowded the platform installer and reinstalled.
23:58:59 <srhb> And it works now?
23:59:04 <covi> No.
23:59:34 <covi> I mean, the reinstallation lets me install yesod (cabal install yesod-platform) now, but the above simple command failed.
23:59:39 <srhb> covi: Okay. what does which runghc say?
