00:12:19 <`nand`> morning all (or night if that's where you are)!
00:12:54 <ARCADIVS> With the definition: "data Nat = Zero | Succ Nat" it seems possible that an implementation could store a Nat as an integer instead of a linked list as there are no values held other than the tags. Would GHC perform such an optimization or is such analysis difficult?
00:13:54 <`nand`> ARCADIVS: that's not necessarily possible
00:13:57 <`nand`> if you account for ⊥
00:14:29 <supki> ARCADIVS: what Integer represents  Succ undefined ?
00:14:34 <`nand`> what integer does Succ (Succ undefined) correspond to?
00:15:03 <arkeet> data Nat = Zero | Succ !Nat now what
00:15:17 <`nand`> now it should definitely be possible in principle
00:15:40 <`nand`> but I doubt GHC does analysis like that
00:15:47 <ARCADIVS> How could a Nat have Succ (Succ undefined)?
00:16:02 <`nand`> :t undefined
00:16:03 <lambdabot> a
00:16:23 <`nand`> undefined :: Nat -- matches the type of the constructor (Succ :: Nat -> Nat) just fine
00:18:34 <ARCADIVS> I don't understand.
00:18:51 <arkeet> > 1:2:undefined
00:18:53 <lambdabot>   [1,2*Exception: Prelude.undefined
00:20:50 <mgsloan> > take 2 $ 1:2:undefined
00:20:52 <lambdabot>   [1,2]
00:20:52 <lambdabot> mgsloan: You have 1 new message. '/msg lambdabot @messages' to read it.
00:22:41 <ARCADIVS> I'm not sure how having to deal with undefined invalidates the idea that Nat could be stored as an integer. How is it different from any other time one must handle undefined? An exception is thrown when evaluation is attempted. You catch it or don't.
00:23:08 <`nand`> because with lazy nats you can have eg. Succ (Succ Nat) and know that it must at least be 2
00:23:11 <`nand`> err
00:23:13 <`nand`> Succ (Succ undefined)
00:23:18 <`nand`> for example
00:23:24 <`nand`> Succ (Succ undefined) > Succ Zero -- returns True
00:23:57 <`nand`> the exception isn't thrown right away
00:24:02 <arkeet> it also lets you have Succ (Succ (Succ (...)
00:24:06 <`nand`> only when you try to look at the undefined
00:24:13 <`nand`> yes, what arkeet said
00:24:17 <`nand`> infinity = fix Succ
00:24:38 <`nand`> \n -> n < infinity -- returns True or diverges
00:24:38 <Jonno_FTW> ab9rf: I fixed it, I used append as well
00:26:00 <ARCADIVS> What can I read to better understand this?
00:31:28 <Jonno_FTW> I've found a bug in ghci in windows
00:31:55 <mgsloan> ARCADIVS: While this is also a little theoretical, the diagrams are nice: http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/
00:32:41 <ARCADIVS> I know I'm in for a good time considering I never heard of a Hasse diagram.
00:32:48 <ARCADIVS> Thanks, mgsloan.
00:32:50 <ARCADIVS> :)
00:33:35 <mgsloan> ARCADIVS: Welcome!  "Nat" is the 4th example there
00:35:11 <`nand`> “If Haskell allowed us to construct infinite types” <- but surely it's possible, with a Fix helper
00:38:54 <ARCADIVS> "While we normally think of unit as only having one possible value, (), but in fact they have two: () and bottom (frequently written as undefined in Haskell, but fix id will do just as well.)" This just seems wrong. *shrug*
00:44:34 <mgsloan> ARCADIVS: It's the cost of having data structures that correspond to control flow
00:47:08 <ARCADIVS> "correspond to control flow"? Example?
00:48:45 <mgsloan> So, lists are a lot like loops (very similar to what's often called generators or coroutines in other languages).  When pattern matching on a list, you have two possibilities: [], and (x : xs).  One says "I'm done!" - like a loop condition, while the other says there's still more to process (if you choose to)
00:49:45 <mgsloan> If not for laziness, then this wouldn't be like the control flow of generators or coroutines
00:50:21 <mgsloan> Hmm, I guess I mean iterators, not coroutines
00:51:03 <ARCADIVS> You mean the data structure corresponds to an implementation?
00:51:18 <`nand`> “extremist programming (no relation to extreme programming)” haha
00:51:26 <`nand`> I like to imagine extreme programming as what goes on in #haskell-lens
00:51:39 <edwardk> heh
00:52:53 <Jonno_FTW> why does division have to be so annoying in haskell?
00:53:08 <otters> because types
00:55:33 <ARCADIVS> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Exception.html#throw "Exceptions may be thrown from purely functional code," If it does something it isn't purely functional. /pedantic
00:57:35 <`nand`> Jonno_FTW: what do you mean by annoying?
00:57:37 <Cale> ARCADIVS: When that happens, the resulting value is _|_ (i.e. undefined, nontermination), and one can only tell which exception was thrown from IO.
00:58:10 <Jonno_FTW> I have to use fromIntegral if I want a floating point value from division
00:59:38 <mgsloan> ARCADIVS: I forgot to mention something important about laziness / data structures corresponding to control flow.  We can write an "ifThenElse" function in Haskell, with type "Bool -> a -> a -> a", just like a ternary, but not built into the language.  Without laziness you can't do that
01:00:47 <mgsloan> ARCADIVS: There are languages that allow you to return types that ensure that bottom (non-termination / exceptions) aren't included, but they're not very practical for real world programming
01:02:49 <ARCADIVS> So all types in Haskell have undefined as a possible value? Is there a purely mathematical analogy to this or is it just something Haskell has for practical issues?
01:03:27 <mgsloan> Jonno_FTW: This is an example of Haskell forcing you to think about a choice that languages with numerical coercions / weak typing allow you to ignore.  It's much better than implicitly coercing to some number representation that's arbitrarily chosen by the language designer, and can help avoid errors in large numerical programs
01:04:13 <mgsloan> ARCADIVS: Well, the mathematical side of this is ezyang's Hasse diagrams stuff I linked to
01:04:26 <mgsloan> ARCADIVS: But I'm sure there's more :)
01:06:12 <mgsloan> ARCADIVS: Here's a paper that justifies using reasoning based on the properties of the "ideal" total version of functions: http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/index.html#fast+loose
01:06:59 <mgsloan> (not that I'm really recommending it as reading material)
01:07:59 <`nand`> Jonno_FTW: division should already return a fractional number, at least if you do it with (/). fromIntegral seems invalid on the result of that
01:08:03 <`nand`> :t fromIntegral .: (/)
01:08:05 <lambdabot> (Fractional a, Integral a, Num b) => a -> a -> b
01:08:17 <`nand`> I'm pretty sure Integral and Fractional are mutually exclusive
01:08:36 <mgsloan> Nice!
01:08:53 <mgsloan> maybe Jonno_FTW is using `div`
01:08:56 <`nand`> oh, or did you mean fromIntegral on the input?
01:09:03 <Jonno_FTW> I mean like
01:09:03 <`nand`> ie. to divide two integers and get a fractional result
01:09:04 <mgsloan> (err nvm)
01:09:12 <Jonno_FTW> > sum [1..5] / length [1..5]
01:09:14 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
01:09:14 <lambdabot>    arising from a use o...
01:09:25 <`nand`> > sum [1..5] / genericLength [1..5]
01:09:26 <lambdabot>   3.0
01:09:33 <Jonno_FTW> :t genericLength
01:09:34 <lambdabot> Num i => [b] -> i
01:09:46 <ARCADIVS> mgsloan: the paper looks interesting to me anyways.
01:09:52 <`nand`> but you're right, that's essentially just fromIntegral . length
01:11:04 <`nand`> I wonder if doing something crazy like moving (/) to Num and giving it the type :: (Num a, Fractionl b) => a -> a -> b -- would work
01:11:05 <Jonno_FTW> the docs say genericLength is less efficient than length
01:11:20 <`nand`> Jonno_FTW: yes, it's less efficient than fromIntegral . length
01:11:38 <Jonno_FTW> then why isn't it implemented like that then?
01:11:39 <`nand`> at least I think so, I don't know what shortcuts ‘length’ takes
01:11:46 <`nand`> Jonno_FTW: to account for eg. lazy nats
01:11:51 <`nand`> genericLength [1..] -- works
01:12:00 <`nand`> as a Nat, that is
01:12:03 <Jonno_FTW> fair enough
01:12:42 <`nand`> on the other hand, genericLength with lazy nats can be more efficient than regular length
01:12:48 <ARCADIVS> Would it be unbearable if Haskell forced all functions to be total? Wouldn't that result in better type safety and a runtime less prone to collapsing from exceptions?
01:12:52 <`nand`> genericLength [1..10000000] > 4 -- True
01:13:11 <Jonno_FTW> > genericLength [1..10000000] > 4
01:13:12 <mgsloan> Hmm, I'd imagine that genericLength would just use "fromIntegral" from Num
01:13:13 <lambdabot>   *Exception: stack overflow
01:13:14 <`nand`> ARCADIVS: sounds like Agda or Idris
01:13:24 <`nand`> > 1 :: Nat
01:13:25 <lambdabot>   Not in scope: type constructor or class `Nat'
01:13:29 <mgsloan> And the reason it's potentially slower is because of the typeclass constraint
01:13:35 <`nand`> Jonno_FTW: that's using Integer as usual, I don't think we have lazy nats here
01:13:42 <mgsloan> (slower if it's not inlined)
01:14:07 <`nand`> mgsloan: length is spine-strict, genericLength is not
01:14:21 <mgsloan> ah, no way
01:14:40 <`nand`> not necessarily, at least
01:14:53 <`nand`> it depends on the strictness of (+) for the type you instantiate it to
01:17:06 <`nand`> ARCADIVS: in particular, forcing totality removes turing completeness iirc
01:17:53 <`nand`> proving whether an arbitrary computation halts (is total) or not (is partial) involves solving the halting problem
01:20:04 <ARCADIVS> My idea of checking for totality was if a function was exhaustive in case handling which GHC currently determines. I'm not sure what you mean.
01:21:42 * hackagebot text-printer 0.1 - Abstract interface for text builders/printers.  http://hackage.haskell.org/package/text-printer-0.1 (MikhailVorozhtsov)
01:21:45 <`nand`> collatz :: Natural -> Bool; collatz 1 = True; collatz n | even n = collatz (n `div` 2) | otherwise = collatz (3*n + 1)
01:21:54 <`nand`> this is exhaustive in case handling
01:22:12 <`nand`> but is it total for all inputs? if you prove that, you've proven the collatz conjecture
01:22:28 <`nand`> oh, include collatz 0 = True -- also
01:24:04 <ARCADIVS> I thought exhaustive and total were synonymous, but I guess we're talking about different things.
01:24:23 <`nand`> no, a function that diverges is also partial
01:24:38 <`nand`> f x = f x -- exhaustive, not total
01:25:33 <`nand`> I think a haskelly denotational definition of partial could be “is ⊥ for an input other than ⊥”
01:26:07 <ARCADIVS> So do you think it would be bad if Haskell forced all functions to be exhaustive?
01:26:32 <arkeet> I wouldn't mind it.
01:26:33 <`nand`> that I would think is a good idea
01:26:39 <Kinnison> It wouldn't necessarily be valuable, but it wouldn't be bad
01:26:44 <`nand`> at the very least, it forces the user to supply a more useful error message
01:26:58 <`nand`> other than “Non-exhaustive pattern at line bla”
01:26:59 <arkeet> you can always -Wall
01:27:42 <`nand`> arkeet: and -Werror
01:27:45 <arkeet> yes
01:27:54 * Kinnison tends to -Wall and -Werror in C, so doing so in haskell would make sense too
01:28:28 <`nand`> I ignore warnings often enough
01:28:31 <`nand`> for example name shadowing
01:28:42 <Kinnison> I tend to try and avoid shadowing
01:28:54 <Kinnison> anyway, time to head for work, ciau
01:29:28 <ARCADIVS> What if Haskell forced all functions to be exhaustive /and/ you couldn't return undefined or error as that doesn't type check?
01:29:58 <arkeet> that wouldn't help much, you could just return some other nonterminating value.
01:30:01 <`nand`> you mean “what if we removed exceptions”?
01:30:02 <arkeet> like fix id
01:30:24 <`nand`> it might cause some functions to switch to Maybe and friends, but it might as well just cause non-informative nontermination instead
01:30:28 <arkeet> unless you propose to solve the halting problem :p
01:30:34 <ARCADIVS> `nand`: exceptions would still be available, just not in functions.
01:30:46 <`nand`> oh
01:30:49 <`nand`> more like uh
01:30:58 <`nand`> “what if we removed unsafePerformIO + exceptions”?
01:31:02 <ARCADIVS> I just wonder what's wrong with functions being mathematical functions and nothing more.
01:31:10 <arkeet> they are.
01:31:19 <`nand`> they are, mathematical functions can be partil
01:31:21 <`nand`> partial*
01:31:34 <`nand`> f(x) = 1/x
01:31:38 <`nand`> f(0) = ?
01:31:55 <`nand`> in essence, the denotation of Haskell is such that ⊥ arises everywhere in values
01:32:11 <`nand`> so they're like functions on the set of values (which includes ⊥)
01:32:16 <centrinia> f :: R \ {0} -> R\{0}; f(x) = 1/x
01:32:24 <ARCADIVS> Whenever you define a function as returning error you're just giving an instruction to throw. It's nothing but imperative programming coming out of hiding.
01:32:32 <`nand`> in that regard one could even argue that they're mathematicall total
01:32:35 <`nand`> cally*
01:32:45 <arkeet> f : R u {⊥} -> R u {⊥}; f(x) = 1/x if x is nonzero, f(0) = ⊥
01:32:46 <arkeet> easy
01:32:58 <`nand`> ARCADIVS: not necessarily, you could just as well be defining a value that represents a special error state
01:33:04 <centrinia> What  is f(⊥) ?
01:33:08 <arkeet> f(⊥) = ⊥
01:33:10 <`nand`> that an IO exception is thrown is a side-detail imo
01:33:20 <`nand`> (other than that it lets you catch it)
01:33:26 <arkeet> you want all your functions to be domain maps.
01:59:57 <mushi> hello
02:00:46 <mushi> anyone willing to help a haskell n00b?
02:03:42 <tdammers> probably
02:03:46 <tdammers> fire away
02:03:47 <quchen> That's what this channel is for.
02:03:47 <lambdabot> quchen: You have 1 new message. '/msg lambdabot @messages' to read it.
02:06:51 * hackagebot local-search 0.0.6 - Generalised local search within Haskell, for applications in combinatorial optimisation.  http://hackage.haskell.org/package/local-search-0.0.6 (RichardSenington)
02:11:23 <mushi> oh sorry
02:11:25 <mushi> ok
02:11:37 <mushi> i am using rectangleWire to draw a square
02:11:45 <mushi> how do i colour in the square
02:11:57 <mushi> i have picture = rectangleWire (10, 10)
02:13:04 <quchen> The docs say there's color :: Color -> Picture -> Picture
02:13:23 <quchen> So maybe wrapping your rectangleWire in that will simply color it?
02:13:34 <quchen> (Haven't used the Lib myself)
02:14:07 <mushi> (i ve only been on the haskell learning curve for 3 days, so sorry if my questions sound dumb)
02:14:26 <mushi> but i really dont get this color :: color -> Picture ->Picture stuff
02:14:42 <mushi> eg. rectangleWire has :: float -> float ->picture
02:14:54 <mushi> float i am assuming means numbers
02:15:00 <mushi> so what does picture mean?
02:15:06 <Rembane> 123.45 <- that kind of number
02:15:37 <quchen> Float is "a number with a point in it", as opposed to integers for example.
02:15:37 <Rembane> mushi: It's a data type that probably describes a picture.
02:15:54 <c_wraith> mushi: pay attention to caps. They're important. Things that start with a lowercase letter are very different from things that start with a capital letter.
02:16:16 <mushi> sorry c_wraith yeap i know
02:16:46 <mushi> e.g. I am confused on what do you mean wrapping
02:18:43 <quchen> Wrapping as in "put around"
02:18:57 <quchen> "3" wrapped in "f" would be "f 3"
02:19:48 <quchen> So what you want is maybe something like "color ??? (rectangleWire (10,10))"
02:20:01 <quchen> Where ??? is something of type Color
02:20:31 <mushi> so something along this line?  picture = color (red, RectangleWire 10, 10)    ?
02:20:39 <quchen> "To make a custom color, use 'makeColor'"
02:20:46 <mushi> oh thanks qucken
02:20:49 <quchen> http://hackage.haskell.org/packages/archive/gloss/latest/doc/html/Graphics-Gloss-Data-Color.html#v:makeColor
02:21:00 <mushi> quchen*
02:21:34 <quchen> So you can create your color via "color 1 0 0 1", which would be red.
02:22:04 <quchen> Then "color 1 0 0 1 (rectancleWire (10, 10))" should be a red rectangle.
02:22:28 <mushi> wouldnt red already be a colour?
02:22:52 <supki> rectangleWire (10, 10)  is a type error,  rectangleWire  does not take a tuple
02:23:13 <quchen> mushi: Oh, I see, the module predefines some colors, like red. You can also use that one then.
02:23:46 <quchen> And as supki mentioned, rectangleWire doesn't take a tuple "(10,10)" but two arguments a la "10 10"
02:24:05 <quchen> So try "color 1 0 0 1 (rectancleWire 10 10)"
02:24:26 <quchen> Eh, wait, "color red (rectancleWire (10, 10))"
02:24:52 <mushi> no comma between 10's right
02:25:13 <mushi> that didnt wokr
02:25:20 <mushi> i got the following error
02:25:21 <mushi> ouldn't match expected type `Picture'                 with actual type `Float -> Picture'     In the return type of a call of `rectangleWire'     Probable cause: `rectangleWire' is applied to too few arguments     In the second argument of `color', namely `(rectangleWire (50 50))'     In the expression: color red (rectangleWire (50 50))
02:25:41 <quchen> Remove the parentheses around the 10s.
02:26:07 <quchen> "(10 10)" stands for "10 10" which means the function "10" applied to "10", which doesn't make much sense.
02:26:59 <mushi> thanks!
02:27:10 <mushi> my square is red outline
02:27:15 <mushi> but not filled with red
02:30:12 <quchen> Hm.
02:30:24 <quchen> rectangleWire sounds like it draws only an outline.
02:30:54 <quchen> try rectangleSolid
02:31:22 <Taneb> ...diagrams?
02:31:44 <quchen> mushi: By the way, I'm making these things up as we talk by reading the docs: http://hackage.haskell.org/package/gloss-1.7.8.2
02:32:18 <Taneb> Ah, gloss
02:32:32 <quchen> If you're looking for some function, it may be helpful to click on some module and then "Index" on the top right side.
02:32:50 <quchen> Then click on "All", and you can easily search all the things the package defines in a looong list.
02:33:13 <quchen> So I did that for "rectangle", and found "rectangleSolid".
02:33:29 <mushi> ah thanks
02:33:32 <mushi> seems helpful
02:33:49 <mushi> lecturer told us to use rectanglewire
02:33:57 <mushi> but rectnaglesolid does the job
02:33:57 <`nand`> uh
02:34:06 <`nand`> gloss should have names for colors built-in, no? like ‘red’
02:34:06 <mushi> strange, thanks alot quchen!
02:34:07 <powergiant> How do you structure a program in a good way in Haskell? I'm write my first (very small) program for an school assignment, and so far I have a main = do, and then a where in the bottom with differnet helping function, but as I handle different questions, it gets diffcuelt to tell them apart from looking at the code (I do comments and such but still). How do you guys do it? Create some "main" functions and
02:34:08 <powergiant> then call them from the main or ?
02:34:58 <`nand`> powergiant: I think that depends too much on what the program is doing to be answered easily
02:35:24 <`nand`> my favorite style of program is where ‘main’ is a one-liner, and the rest is some pure functional description of my program
02:35:40 <m3ga> powergiant: the stuff you have in the where clause should probably be separate functions.
02:36:52 <powergiant> yeah I may have got a little to fond of doing things in a where..
02:37:18 <powergiant> `nand`: You most of your program are just functions that call eachother and such, and then then main would just be a "start" function or such ?
02:37:55 <`nand`> something like main = runGame $ ... some pure description of the game; or main = print $ ... some value; or main = runServer $ .. some pure description of how the server responds to requests
02:38:45 <`nand`> powergiant: I like to move away of the concept of “functions calling eachother” and a “starting point”; it calls to mind a very imperative control flow
02:39:04 <`nand`> I meant more like, the rest of my program is a static definition of what my program behaves like
02:40:25 <powergiant> Hmm yes.. I may be a bit too stuck in doing Java..
02:42:42 <hpaste> Assignment pasted “Powergiant” at http://hpaste.org/84361
02:43:35 <powergiant> How would you strucutre something like this? (Of course this is a very small thing, so it may be difficualt, and please do pay attention to the bad code hehe)
02:44:18 <powergiant> Would it be a idea to move away from a big main block and then do more smaller functions ?
02:44:54 <EarlGray^> I see a lot of 'let' in the monad code, it may be a sign you can refactor that part into a pure function
02:45:54 <powergiant> EarlGray^: What do you mean with 'Pure function' ? Something without variables ?
02:46:05 <EarlGray^> If you need to print several values, they can be returned as a tuple
02:46:19 <EarlGray^> nope, a function which type does not involve IO
02:46:41 <EarlGray^> calcualtions are better done in such functions
02:48:46 <powergiant> Oh ok. Some of the lets binding are also just to create readble code for myself, but maybe a function with a where would be better?
02:48:49 <EarlGray^> You print just two things: avgSunSpots and biasedSampVar
02:49:14 <EarlGray^> Ideally, they should be calcaulated outside of main
02:49:52 <EarlGray^> Try to shrink your `main` in favor of pure functions, that's what makes Haskell programming much more enjoyable
02:49:58 <powergiant> So the idea is to have all my unpure code (such a print) in the main, and all calculations in functions by themselves?
02:50:18 <EarlGray^> yep, that's the point of pureness
02:50:24 <EarlGray^> *purity
02:50:58 <powergiant> I see.. I'll try to resturcture it a bit. Thanks for the input!
02:51:18 <EarlGray^> if you have a lot of impure code it should be fractured into impure "procedures" just like in imperative languages, but here is not the case
02:51:37 <Taneb> Things that suck about my own code:
02:51:53 <Taneb> I very rarely use comments
02:52:15 <Taneb> I tend to overuse MaybeT and StateT
02:52:37 <Taneb> I start writing code before understanding what I want to do
02:53:14 <Taneb> I make huge pattern matches that can be simplified right down quite a lot of the time
02:53:16 <powergiant> Most of the impure in this will be the database connection, and some print statements..
02:53:23 <`nand`> powergiant: do { x <- getAllMyData :: IO Data; print (someCalculations x) }; someCalculations :: Data -> SomeResult; -- essentially
02:53:36 <kqr1> powergiant, also do mind that you have a few function that don't really add any readability
02:54:05 <kqr1> powergiant, vectorSum is just (+)
02:54:33 <Taneb> I probably ought to break out of these habits
02:54:36 <EarlGray^> What's the problem with the comment absence if the code is descriptive enough :)
02:54:37 <powergiant> kqr1: Ah yes it is now. I used it for a tuple before, but yes that should be removed now !
02:54:52 <kqr1> powergiant, and you can sum all the solarspots with the sum funvtion that already exists
02:54:55 <kqr1> ah
02:55:49 <powergiant> Same reasosn for not using sum before, but I should change it now yes :)
02:56:46 <Taneb> powergiant: tiny little nitpick, is there any reason you're using Float rather than Double?
02:57:02 <supki> foldr (+) and sum are different functions
02:57:56 <powergiant> Taneb: Not really. I don't have a bit reason for the extra presicous of Double but there is another reason maybe ?
02:57:58 <EarlGray^> 'foldr (+) 0' and `sum` are the same
02:58:16 <Taneb> supki: almost all of the time, the only difference is that sum crashes less
02:59:44 <`nand`> EarlGray^: modulo efficiency and/or laziness concerns
02:59:52 <Taneb> powergiant: I'm just conditioned to prefer Double to Float, there's reasons for it but I don't know them. Keep to Float until you get actual reasons
02:59:54 <quchen> Taneb: Waaaait, sum is strict? And here I was redefining it in terms of foldl' because I thought it would leak
03:00:03 <supki> Taneb: uhm, probably, but he still wants  foldl' (+) 0, not sum
03:00:26 <supki> > sum [1..1000000]
03:00:27 <EarlGray^> powergiant: also I'd write convRow as convRow [a] = read ((fromSql a)::String)::Float
03:00:29 <lambdabot>   *Exception: stack overflow
03:00:31 <supki> > foldl' (+) 0 [1..1000000]
03:00:33 <lambdabot>   500000500000
03:00:57 <quchen> Oh nevermind. It isn't, there's no seq in sum.
03:00:57 <Taneb> Huh
03:01:12 <quchen> It's just made tail recursive for whatever reason.
03:01:17 <`nand`> I think sum isn't strict to account for strange Num instances, like lazy nats
03:02:18 <quchen> > let sum xs = sum' xs 0; sum' [] s = s; sum' (x:xs) s = sum' xs (x+s) in sum [1..10^6]
03:02:21 <lambdabot>   *Exception: stack overflow
03:02:30 <quchen> > let sum xs = sum' xs 0; sum' [] s = s; sum' (x:xs) s = s `seq` sum' xs (x+s) in sum [1..10^6]
03:02:33 <lambdabot>   500000500000
03:03:52 <kqr1> Taneb, Don't Quote Me On This(tm) but i believe doubles give you extra precision at virtually no cost, so there's no reason not to use them (on x86 that is)
03:03:55 <powergiant> Taneb: I've actuall hit a problem before with Float vs Double, but I also don't really remeber the reason.. Maybe you are right that I should just start using double as a standard
03:04:37 <Taneb> I know if you're using Complex, it's optimized for Double, but that's irrelevant here
03:04:49 <Taneb> If you're on a 64 bit computer, Double and Float take up the same space
03:04:49 <quchen> Is there a difference between Float and Double in Haskell? I've recently heard about some language where they're simply the same, but I don't recall which one.
03:05:12 <Taneb> quchen: Doubles have, guess what, Double the precision of a Float
03:05:38 <kqr1> according to ieee anywaw
03:05:50 <quchen> Taneb: Just like a small int is always smaller than an int in C - guess what, no
03:05:50 <kqr1> anyway*
03:06:03 <supki> > (0.1 + 0.2 :: Float, 0.1 + 0.2 :: Double)
03:06:05 <lambdabot>   (0.3,0.30000000000000004)
03:06:23 <Taneb> I'm pretty sure Float and Double are
03:06:34 <kqr1> quchen, no, it's defined to be "no bigger than" or something like that"
03:06:37 <Taneb> IEEE specified
03:07:34 <kqr1> yeah, 704  something i think
03:07:56 <kqr1> ...that could be wlan too
03:07:57 <Taneb> 754
03:08:39 <kqr1> yeah that's the one
03:09:13 <Taneb> Anyway, I'm off now
03:09:14 <quchen> Ah, Wikipedia says Ruby+Python have float := double
03:09:22 <quchen> http://en.wikipedia.org/wiki/Single-precision_floating-point_format
03:13:18 <hpaste> NewAssignment pasted “Powergiant” at http://hpaste.org/84362
03:13:34 <powergiant> So maybe this is a bit more Haskelly ?
03:13:44 <skp_> hello
03:15:13 <skp__> do you have a link or some read that explain how to use Distribution.Test? the doc is quite poor and the userguide seems to be deprecated
03:15:22 <skp__> Distribution.TestSuite*
03:16:39 <skp__> no one? :(
03:16:57 <Botje> give it some time
03:17:04 <Botje> it's still early for most europeans :)
03:17:05 <`nand`> powergiant: the type annotations in line 26 are both unnecessary
03:18:07 <`nand`> powergiant: the where in line 31 is completely unnecessary. Instead of writing f ... = b where b = ...; just write f ... = ...
03:18:16 <`nand`> (unless b refers to itself, which it doesn't :)
03:18:58 <`nand`> also, I'm not entirely convinced “minusNumAndSquare” is a very good name, or a gain over just using (a-x)^2 instead of calling it
03:21:04 <powergiant> That is properly true.. I need to use lambdas a bit more
03:21:53 * hackagebot persistent-template 1.1.3.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.1.3.1 (MichaelSnoyman)
03:22:06 * `nand` .oO( (^2) .: (+) -- look ma, no lambdas! )
03:23:29 <powergiant> that is clever!
03:24:15 <asQuirreL> `nand`, what in the hell is that?
03:24:28 <`nand`> :t (^2) .: (+)
03:24:29 <lambdabot> Num b => b -> b -> b
03:24:40 <`nand`> :t \x -> (^2) . (+) x
03:24:41 <asQuirreL> oooooh lmao
03:24:42 <lambdabot> Num b => b -> b -> b
03:24:49 <asQuirreL> I thought I was in the C++ channel >.>
03:24:55 <`nand`> :t \x y -> (^2) ((+) x y) -- (x + y)^2
03:24:56 <lambdabot> Num a => a -> a -> a
03:25:01 <asQuirreL> I know what it is in Haskell xD
03:25:07 <`nand`> ah, okay :)
03:26:14 <asQuirreL> well would you look at that.. they're talking about lambdas in there too
03:27:08 <powergiant> what is the '.:' ? '.' i understand but the other ?
03:28:01 <nithp> :t (.:)
03:28:02 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
03:28:18 <nithp> :t Functor
03:28:19 <lambdabot> Not in scope: data constructor `Functor'
03:28:35 <nithp> :P
03:28:41 <supki> :k Functor
03:28:43 <lambdabot> (* -> *) -> Constraint
03:28:49 <nithp> supki, thanks :)
03:29:35 <powergiant> I get '.: not in scope' I need to import a module to use it =
03:31:27 <supki> powergiant: (.:) = (.) . (.)
03:32:26 <supki> powergiant: lambdabot's (.) is fmap, so you see more general type signature
03:39:28 <feliperosa> Hello :)
03:39:43 <feliperosa> is there any problem compiling for profiling with optimizations?
03:40:06 <mushi> anyone have idea scale (gloss function) in  a loop
03:42:29 <powergiant> You gotta love something working out in the first try.. I feel clever.. yeah!
03:42:41 <Hermit> feliperosa: why should there be?
03:42:44 <Hermit> mushi: what?
03:43:35 <feliperosa> Hermit: I don't know, I read somewhere we should not do so but I don't remember why...
03:43:59 <mushi> i am using gloss library and a function scale :: Float -> Float -> Picture -> Picture, but i need it to increase solowly. e,g first start square super small, the get bigger and bigger
03:44:14 <mushi> any idea how to do this in haskell
03:44:19 <mushi> (i am a haskell n00b)
03:45:19 <Botje> use the map function to scale the same picture to several scales
03:45:22 <Botje> then you have [Picture]
03:45:34 <Botje> and then you need to put them together into one Picture in some way.
03:45:45 <feliperosa> "However, because cost-centre profiling operates at a high level, it can be difficult (if not impossible) to use it to profile optimized code." at http://hackage.haskell.org/trac/ghc/wiki/Commentary/Profiling
03:47:59 <`nand`> Botje: I think he means time-based
03:48:16 <`nand`> in which case, scale by some multiple of the elapsed time?
03:48:37 <mushi> Botje: is map function in gloss or where?
03:48:49 <Botje> it's a haskell built-in.
03:48:51 <mushi> yeah i mean time based
03:48:59 <mushi> so something along the lines a loop
03:49:02 <Botje> then disregard my advice, follow `nand`s instead.
03:52:37 <Hermit> mushi: what's the scale interval you need?
03:52:37 <mushi> i ll show some code
03:52:41 <mushi> on what i m trying to do
03:52:48 <mushi> http://pastebin.com/dQsfy0A2
03:52:51 <mauke> The paste dQsfy0A2 has been copied to http://hpaste.org/84367
03:52:59 <mushi> i need 0 where its really small
03:53:06 <mushi> then 1 where its current picture size
03:53:33 <mushi> then 2 twice the square size
03:53:52 <mushi> then 2.5 times, 3 times, 3.5 times and so on
03:55:54 <Palmik> Is there something like splitUpdate :: Ord k => (a -> Maybe a) -> (Bool, Bool, Bool) -> k -> Map k a -> Map k a? I know I could use mapMaybeWithKey, but that does not have complexity sensitive to the size of the updated chunk of the map.
03:55:54 <lambdabot> Palmik: You have 1 new message. '/msg lambdabot @messages' to read it.
03:56:12 <Hermit> mushi: scale (Float, Float, picture)  <-- what? double check that
03:56:43 <`nand`> line 8 makes no sense
03:57:36 <mushi> yeah i know
03:57:42 <mushi> i just was playing with shit
03:57:52 <mushi> but i know i need the scale functions somewhere there
03:57:54 <Hermit> mushi: I don't quite get the stepping you need, please reformulate
03:57:55 <mushi> in  a loop?
03:58:31 <Hermit> mushi: get your question right, and then we can help
03:58:48 <mushi> i ve been given this "The side length of the square should grow in direct proportion to time."
03:59:19 <mushi> "In other words:  anim 0 should be invisible. anim 1 (the square after one second) should be exactly the same as the square you originally defined in picture. anim 2 should be twice the side length of anim 1 or picture anim 2.5 should be two and a half times the side length of picture anim 3 should be three times the side length of picture and so on..."
03:59:33 <mushi> thats my instructions
03:59:40 <mushi> as a haskell n00b (only a few days)
03:59:51 <HugoDaniel> oh, haskell hackaton in ukraine
03:59:57 <mushi> it has thrown me off and google loops in haskell hasnt helped
04:04:56 <Hermit> mushi: first of all, start by putting a working definition at line 8: anim n = scale n n picture
04:06:32 <mushi> done Hermit
04:07:39 <`nand`> and now the problem is solved
04:07:39 <mushi> hmm that actually does someting
04:08:07 <mushi> wow
04:08:15 <mushi> haskell is really functional
04:08:34 <mushi> and i ve spent all the time on java/C
04:08:44 <mushi> can anyone kinda explain what happened
04:09:32 <Hermit> mushi: you should definitely start with at least some introduction tutorial to haskell
04:09:45 <Hermit> mushi: you'll get nowhere otherwise
04:10:36 <shock_one> Hi. How do I get all possible combinations of multipliers for a given number? So, for example, for 60 I want to get (5,12), (3, 20), (2, 30), (2,2,15), (2,2,3,5) and so on. I think I should prime factorize the number first, but what's next? How to get the combinations of a different length?
04:11:04 <mushi> yeah Hermit i have started one
04:11:11 <mushi> but i ll need to read more
04:12:06 <Hermit> mushi: of course... seeing as you put a C style function call....
04:13:32 <powergiant> I don't get why I can't do map (++ [1]) [1,2,3] ? ghc gives an error about ambigious types?
04:14:22 <earthy> > map (++ 1) [1,2,3]
04:14:23 <lambdabot>   Ambiguous type variable `b0' in the constraints:
04:14:23 <lambdabot>    (GHC.Num.Num b0)
04:14:23 <lambdabot>      a...
04:14:39 <earthy> > map (++ 1) [1,2,3] :: [Int]
04:14:40 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
04:14:41 <lambdabot>    arising from a use of...
04:14:46 <Hermit> earthy: check that 1....
04:14:48 <earthy> oh, right. :)
04:15:16 <earthy> > map (:[1]) [1,2,3] :: [Int]
04:15:16 <Hermit> powergiant: your problem is exactly the opposite as what earthy was doing
04:15:17 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
04:15:17 <lambdabot>              with actual type ...
04:15:21 <earthy> > map (:[1]) [1,2,3] :: [[Int]]
04:15:23 <lambdabot>   [[1,1],[2,1],[3,1]]
04:15:24 <Hermit> god...
04:15:26 <earthy> there :)
04:15:47 <earthy> this set of attempts should clarify things ;)
04:16:02 <powergiant> hehe yes I think I understand. Thanks!
04:16:48 <earthy> hermit: that was kinda on purpose. he had multiple problems. ;)
04:17:28 <`nand`> powergiant: because in “2 ++ [1]” the first ‘2’ must be a list (due to ++); and GHC can't reasonably default that. If you were to write a Num instance for lists of numbers, and specify a type signature, it would theoretically type check
04:18:21 <earthy> um. well, monoid (due to ++)
04:18:34 <`nand`> :t (++)
04:18:35 <lambdabot> Monoid m => m -> m -> m
04:18:36 <Hermit> nope
04:18:42 <Hermit> oh, custom prelude
04:19:03 <Hermit> I thought (.) as fmap was the only thing
04:19:13 <Sgeo> :t from
04:19:14 <lambdabot> (Functor f, Profunctor p) => AnIso s t a b -> p t (f s) -> p b (f a)
04:19:15 <earthy> plus, it really depends on haskell '98 or newer and details like that ;)
04:19:17 <Hermit> `nand`: where can I get a diff summary?
04:19:19 <Sgeo> ...
04:19:23 <`nand`> oh, okay; so yes, GHC can't reasonably default Monoid either
04:19:26 <Sgeo> According to Hackage it should be
04:19:31 <Sgeo> from :: AnIso s t a b -> Iso b a t s
04:19:42 <Sgeo> s t a b -> b a t s
04:19:50 <`nand`> turns out it *can* default [Integer], so the only error you get with the list (++) is a missing instance
04:19:58 <supki> Sgeo: :t expands synonyms
04:20:04 <Sgeo> Ah
04:20:05 <`nand`> Hermit: diff between regular Prelude and lambdabot's?
04:20:11 <Hermit> `nand`: aye
04:20:42 <Hermit> just to avoid quirks
04:20:53 <Sgeo> :t simple
04:20:55 <lambdabot> (Functor f, Profunctor p) => p a (f a) -> p a (f a)
04:21:07 <Hermit> though I like the mappend as (++)
04:21:12 <Hermit> I'm in favor of that
04:21:55 <`nand`> Hermit: http://code.haskell.org/lambdabot/State/L.hs
04:22:06 <`nand`> this should be a reasonably close approximation
04:22:24 <Hermit> right...
04:22:50 <Hermit> looks like flip is the other quirk
04:22:53 <Hermit> :t flip
04:22:54 <lambdabot> (a -> b -> c) -> b -> a -> c
04:23:01 <Hermit> oh?
04:23:22 * Hermit wonders why it's been hidden in the lambdabot prelude
04:23:41 <supki> :t (??)
04:23:42 <lambdabot> Functor f => f (a -> b) -> a -> f b
04:24:48 <`nand`> you're probably going to have to poke Cale for the actual L.hs
04:24:54 <Hermit> yeah, I see that definition in L.hs but...
04:25:06 * Hermit takes notice
04:28:38 <johnw> is that (??) from lens?
04:28:47 <supki> yep
04:28:56 <johnw> it's a clever operator name
04:29:30 <supki> it was (?) for a day or two =(
04:29:40 <johnw> map (f ?? a) [..]  it shows you where the substitution will happen
04:29:56 <supki> yes, that's the intention
04:30:33 <whathelle> hi
04:31:19 <whathelle> how to create a picture in haskell?
04:31:29 <johnw> you mean, like a PNG?
04:31:56 <whathelle> something like that, import gloss library?
04:32:05 <johnw> yeah, that's one way
04:32:47 <petantik> or bit banging a bmp
04:33:08 <johnw> for that approach, see http://hackage.haskell.org/packages/archive/gd/3000.7.3/doc/html/Graphics-GD-ByteString.html
04:33:31 <whathelle> thank pal. i go to check it
04:34:24 <adzeitor> diagrams http://projects.haskell.org/diagrams/ ?
04:40:48 <Hermit> what about cairo?
04:43:17 <`nand`> depends on what kind of picture you want to create, but if you want to create a diagram, my vote lies with diagrams
04:43:17 <`nand`> where diagram means vector graphic
04:53:52 <Hermit> I'm trying to compile wxc, it's failing and I have no idea what's going on whatsoever: http://dpaste.com/1028858/  Just WTF is the error?
04:56:23 <gienah> Hermit: I don't see the error either, please try --verbose=3
04:56:26 <Botje> Hermit: do you have a wx-config binary?
04:59:27 <Hermit> gienah: hang on, seems that the problem is as Botje suggested
05:00:28 <Hermit> ok, it keeps failing, but at least it's for a version incompatibility now
05:01:09 <Botje> \o/
05:01:22 <Botje> well, kind of :]
05:01:56 * hackagebot grid 4.1 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-4.1 (AmyDeBuitleir)
05:11:56 * hackagebot som 3.1 - Self-Organising Maps  http://hackage.haskell.org/package/som-3.1 (AmyDeBuitleir)
05:33:40 <dcoutts> dmwit: imho, nothing should depend on utf8-string, that package should never be needed
05:33:53 <dcoutts> dmwit: it's a symptom of using the wrong types
05:34:18 <Taneb> And yet http://packdeps.haskellers.com/reverse/utf8-string
05:34:31 <dcoutts> I know, it's terrible
05:38:14 <dmwit> Yes, if there's a next step it's to use bytestring more.
05:38:28 <dmwit> But I wanted to fix the bug first and make the code nice second. =)
05:38:48 <dcoutts> what bug?
05:39:11 <dmwit> gtk's homebrew UTF8 conversion only handled 1-, 2-, and 3-byte characters.
05:39:22 <dmwit> See also Trac #1284
05:39:46 <dmwit> s/gtk/gtk2hs/
05:40:08 <dcoutts> dmwit: there are only 1,2 and 3 byte chars (iirc)
05:40:16 <dmwit> No, there are 4-byte characters.
05:40:53 <dmwit> Three bytes covers the basic multilingual plane, but you need four bytes for the other planes.
05:41:04 <dcoutts> ah, it's 5 & 6 that are overlong
05:41:13 <dcoutts> and most of the 4-byte code space is also overlong
05:41:22 <dmwit> right
05:41:51 <dmwit> gotta run, but I'll be back on IRC in half an hour or so if there's more to discuss
05:42:20 <dcoutts> dmwit: well I think I copied that code from somewhere else in the first place, I'd just copy it again rather than adding a dep
05:49:33 <Jonno_FTW> @src print
05:49:33 <lambdabot> print x = putStrLn (show x)
06:01:35 <dmwit> dcoutts: Yeah, I was wondering what people would think of adding a dependency.
06:01:47 <dmwit> But really, shying away from dependencies seems like a losing goal long-term.
06:01:59 <dmwit> Code reuse is Good!
06:02:19 <dmwit> Fixing a bug, then spending three hours trying to figure out why your fix isn't being used because somebody used copy-and-paste instead of code reuse is Bad!
06:02:38 <dcoutts> dmwit: I think there's a particular issue with cairo depending on glib. It used to but we dropped the dep because some people could build cairo but not glib on their platforms (clibs)
06:02:53 <dcoutts> dmwit: oh in general I agree
06:03:00 <dmwit> Sure. And cairo still doesn't depend on glib.
06:03:26 <dcoutts> dmwit: I just have a semi-rational dislike of the utf8-string package
06:03:53 <dmwit> I'm happy to depend on a different package. It was just the first hit on Hayoo with the right type and a name thout sounded about right. =P
06:04:02 <dmwit> s/thout/that/
06:04:18 <dcoutts> as others have pointed out, the type is wrong
06:04:31 <dcoutts> it's only used for marshalling to CString
06:04:51 * dmwit nods agreeably
06:05:04 <dmwit> What do you suggest?
06:05:50 <dcoutts> ideally we'd be using Text and then we'd just use the appropriate function to convert to an external rep in utf8
06:06:19 <dcoutts> if you just want to fix the bug, then I'd suggest just fixing the bug
06:06:28 <dmwit> bug is just fixed
06:06:40 <dmwit> Switching to Text is a pretty seriously breaking change.
06:06:50 <dcoutts> aye
06:06:58 * hackagebot pontarius-xmpp 0.2.0.1 - An incomplete implementation of RFC 6120 (XMPP: Core)  http://hackage.haskell.org/package/pontarius-xmpp-0.2.0.1 (JonKristensen)
06:07:04 <Jonno_FTW> how would I make sure the cmd line args are my program are in a specific format, ie string float float ?
06:07:21 <dmwit> Jonno_FTW: parse them
06:07:30 <Jonno_FTW> and run if it is, otherwise show a usage message
06:07:31 <dmwit> There's half a dozen packages on Hackage for munging the command line arguments.
06:07:53 <dmwit> cmdargs, getopt, that one that uses applicative parsing...
06:08:30 <supki> optparse-applicative
06:09:07 <fizbin> Doesn't cmdtheline also use applicative parsing?
06:09:34 <fizbin> http://hackage.haskell.org/package/cmdtheline
06:10:09 <Jonno_FTW> which one would you recommend for what I need?
06:10:17 <Jonno_FTW> and the tutorial for cmdtheline is 404
06:11:58 * hackagebot wai-routes 0.2.2 - Typesafe URLs for Wai applications.  http://hackage.haskell.org/package/wai-routes-0.2.2 (AnupamJain)
06:13:17 <twomashi> Any way to get all functions with a certain type using template haskell?
06:14:56 <supki> Jonno_FTW: any of them? in optparse-applicative you can provide custom parser for option if you really want to be hardcore
06:15:17 <Jonno_FTW> I want to be simple, I haven't written haskell for a while
06:15:25 <dmwit> Hell, even "none of them" is reasonable.
06:15:52 <Jonno_FTW> yeah I was thinking of that
06:16:11 <dmwit> args <- getArgs; case args of [x_,y_,z_] -> let x = read x_; y = read y_; z = read z_ in ...
06:16:14 <Jonno_FTW> but them I'm looking up arguments and checking their type like a sucker
06:20:52 <saml> i offer haskell tutoring. $50/hr
06:21:12 <Jonno_FTW> is it minimum 1/hr?
06:21:20 <Jonno_FTW> I offer java tutoring at $30/hr
06:22:03 <saml> java is no use. no one uses java anymore
06:22:22 <Jonno_FTW> not if you're a first year at uni
06:22:40 <ab9rf> heh
06:22:55 <ab9rf> saml: except on android :)
06:23:57 <liyang> When you upgrade Java, Oracle displays a banner along the lines of "9 billion devices run Java". I consider that a threat.
06:24:17 <ab9rf> liyang: especially since oracle is working really hard to reduce that number
06:24:24 <saml> i can't define a data constructor on ghci
06:24:42 <saml> actually, i can. lambdabot can't
06:24:56 <hpaste> Jonno_FTW pasted “opthorrors” at http://hpaste.org/84371
06:24:58 <ab9rf> poor lambdabot
06:25:09 <Jonno_FTW> that's what I have now but it doesn't work, I really have no idea
06:25:35 <tlaine> our uni starts first year CS with java
06:27:41 <liyang> tlaine: sorry to hear that.
06:27:52 <ab9rf> it could be worse
06:27:57 <ab9rf> it could be C++
06:28:06 <Jonno_FTW> my uni teaches c++ in 2nd year
06:28:28 <Jonno_FTW> cp1 is java, cp2 is c++, cp3 is c++/java plus jni
06:28:51 <ab9rf> Jonno_FTW: are they teaching computer science, or training junior codemonkeys?
06:29:09 <liyang> ab9rf: what's the difference?!
06:29:10 <Jonno_FTW> cs in cp2/3
06:29:32 <Jonno_FTW> of course there's a gajillion other cs topics
06:29:43 <tlaine> :D
06:30:01 <ab9rf> liyang: one of them is about the science of computing, the other is about spewing forth massive amounts of hopefully nt entirely useless code.
06:30:02 <tlaine> ok, there's a month of python first
06:30:09 <liyang> ab9rf: I'm trolling.
06:30:36 <ab9rf> liyang: a friend of mine is a professor of computer science at a small school in virginia, we have this conversation fairly frequently
06:30:50 <Jonno_FTW> any help with my paste?
06:30:52 <Botje> ours only teaches scheme and c++, everything else is learned on the job
06:30:59 <saml> Jonno_FTW, what is it doing?
06:31:07 <Jonno_FTW> not compiling
06:31:09 <ab9rf> liyang: of course, i'm a systems engineer by trade, and bitch constantly about the state of all things related to computer technology
06:31:13 <saml> what's the error?
06:31:46 <Jonno_FTW> indentation error,
06:31:52 <saml> too many let's
06:31:58 <liyang> ab9rf: I'm in both camps. I think the SW engineering / industry camp is wrong though.
06:31:59 <Jonno_FTW> how do I format it?
06:31:59 <ab9rf> yeah the let syntax is wrong
06:32:00 <tlaine> tabs
06:32:03 <saml> > let a = 1; b = 2 in a + b
06:32:04 <lambdabot>   3
06:32:18 <ab9rf> liyang: there's nothing wrong with training people to be code monkeys, but that's not computer science, it's vocational training.
06:32:19 <saml> > let a = 1; let b = 1 in a + b
06:32:20 <lambdabot>   <hint>:1:30: parse error (possibly incorrect indentation)
06:32:42 <saml> don't write one liners
06:32:45 <saml> spread things out
06:32:58 <ab9rf> liyang: calling it 'computer science' or even 'computer engineering' is abusive to the language
06:33:12 <ab9rf> whitespace is cheap, use it
06:33:16 <saml> i call it 'computer programming'
06:33:19 <wires> ab9rf, liyang: shit like that is going on everywhere though. there seems to be this tendency that everyone should be able to go to university and if you go to a engineering school, this is lame
06:33:27 <liyang> ab9rf: I split it down the IT / SW engineering / computer science lines.
06:33:36 <saml> or 'web design'
06:33:51 <saml> wanna get Bachelor's in Web Design Technology?
06:33:52 <ab9rf> saml: web design ought to be taught in the marketing or creative arts departments, if you ask me
06:34:01 <ab9rf> it has nearly nothing to do with computer science
06:34:03 <wires> saml: lol
06:34:11 <saml> no bro, node.js and mongodb all the way
06:35:02 <ab9rf> saml: you're making me twitch now
06:35:50 <Jonno_FTW> saml: I spread it out and now i get another error, I'll paste it
06:36:17 <saml> maybe paste compilable test case
06:36:32 <ab9rf> liyang: i was talking to someone the other day getting a bachelor's in some IT/IS field who was taking what amounted to a class in Cisco.
06:37:00 <hpaste> Jonno_FTW pasted “opts” at http://hpaste.org/84372
06:37:24 <ab9rf> indentation is wrng
06:37:28 <saml> yah
06:37:32 <ab9rf> you backdented too far out
06:37:50 <liyang> ab9rf: I'd say that's fair enough for IT/IS.
06:37:54 <ab9rf> basically your let block is empty
06:38:06 <`nand`> > let in 3
06:38:07 <lambdabot>   3
06:38:09 <ab9rf> liyang: it's fine if it's a vocational program
06:38:27 <liyang> IT/IS *is* vocational in my books...
06:38:36 <saml> https://gist.github.com/saml/5204689  do like this Jonno_FTW
06:38:36 <Jonno_FTW> how should it be formatted then?
06:38:42 <liyang> (as is SW engineering,, for the most part.)
06:38:42 <Jonno_FTW> ahk
06:38:43 <saml> that's $10
06:38:50 <ab9rf> liyang: i don't like that we give bachelor's degrees in vocational fields
06:39:12 <saml> http://en.wikibooks.org/wiki/Haskell/Indentation
06:39:14 <ab9rf> liyang: especially when the classes are so moronic
06:39:15 <liyang> ab9rf: well that's a separate issue...
06:39:22 <saml> what are we talking about
06:39:41 <saml> academia is changing
06:39:51 <Jonno_FTW> I'm only and honours students, I don't have $10 :(
06:40:01 <ab9rf> saml: the arrogation of higher education by business so they no longer have to pay to train employees
06:40:06 <`nand`> we're talking about the invasion of a perfectly fine field by enterprise programmers
06:40:32 <saml> make a school then. and teach the way you like
06:40:32 <liyang> In the UK at least, I feel it was down to Labour deciding that "everyone should go to university", and as a result many vocational colleges got turned into 'universities'.
06:40:41 <`nand`> my school is #haskell
06:40:43 <saml> wanna make a school with me?
06:40:51 <ab9rf> it used to be that you got paid while you were being trained, now you have to put three to five years pay in advance in order to get training
06:40:55 <saml> i want to be a school president and get girls
06:41:03 <ab9rf> saml: i don't think it works that way
06:41:03 <`nand`> monday is Haskell 101 taught by Cale
06:41:24 <`nand`> tuesday is Monads and Their Evil Twins taught by edwardk
06:41:42 <`nand`> oh, “Comonads and Their Evil Twins” ;)
06:41:55 <ab9rf> and even then after you pay your money you don't have any assurance of getting a job
06:42:08 <ab9rf> i thought comonad were the evil twins
06:43:29 <labo> saml: maybe if you choose something other than CS. Biology perhaps?
06:46:00 <saml> i don't like killing frogs
06:46:06 <`nand`> don't worry
06:46:22 <`nand`> frogs have been created with see-through skin
06:46:56 <`nand`> I wonder how long until the technology is transferrable to humans
06:47:13 <Jonno_FTW> saml: I formatted it like you said and still get an error
06:47:45 <saml> Jonno_FTW, use brackets and semicolons . forget about indentation
06:48:04 <saml> let { a = b; c = d } in  { .. }
06:48:18 <saml> > let {a =1; b=2} in {a+b}
06:48:20 <lambdabot>   <hint>:1:20: parse error on input `{'
06:48:26 <saml> nevermind
06:48:30 <saml> just use java
06:48:31 <Jonno_FTW> :/
06:48:39 <Jonno_FTW> but this is the last thing I need to do
06:48:43 <saml> > let {a =1; b=2} in a+b
06:48:45 <lambdabot>   3
06:50:14 <saml>  rules <- fmap B.words <$> B.lines <$> B.readFile fname      mapM_ putStrLn $ showRules $ filterRules gmax gmin smax smin $ apriori rules 2
06:50:20 <saml> these are not haskell
06:51:21 <Jonno_FTW> then what are they?
06:54:02 <win2mac> nazdar
07:04:52 <ab9rf> ink?
07:09:25 <Jonno_FTW> I finally got it working
07:09:38 <ab9rf> that'll be $13.95
07:09:48 <Jonno_FTW> can I get fries with taht?
07:10:30 <ab9rf> yes, but you have to pay shipping on them
07:10:42 <Jonno_FTW> how much to post to australia?
07:17:49 <no-n> they'd better be curried
07:24:07 <ab9rf> curried curry
07:26:59 <Jonno_FTW> I'll uncurry them when I unpack them
07:28:38 <ab9rf> why would you do that?  curried fries sound delicious.
07:29:03 <ab9rf> i wonder how curried popcorn would go
07:32:29 <Jonno_FTW> eugh
07:34:55 <hpaste> add20 pasted “RealWorldHaskell-chapter5-Exercises2-nest” at http://hpaste.org/84378
07:45:41 * QinGW > ++= *
07:46:25 <Botje> QinGW: did you fall on your keyboard? do you need help?
07:48:34 <QinGW> i just try if haskell has gene of cplusplus
07:49:04 <Kinnison> ab9rf: popcorn seasoned with cumin is nice
07:54:03 <xkcd> Does anybody know of instances where people wrote symbolic algebra software with Haskell
07:54:05 <xkcd> ??
07:55:22 <xkcd> Comparable http://sympy.org  who have wrote quite a bit of software completely in python
07:56:35 <armlesshobo> xkcd: like CAS?
07:56:42 <xkcd> yeah
07:57:04 <armlesshobo> xkcd: i don't think there is.
07:57:19 <armlesshobo> xkcd: be the first to write it! :P
07:57:45 <xkcd> Will it be worth it?? According to me yes
07:58:00 <xkcd> Yeah I am thinking of it..
07:58:06 <armlesshobo> I think so too.
07:58:58 <xkcd> But I am just a beginner now I have to learn a lot.
07:59:42 <armlesshobo> xkcd: have you considered DoCon?
07:59:49 <armlesshobo> (i'm just perusing google search results)
08:00:11 <xkcd> No I haven't seen it
08:00:18 <xkcd> Do you know what these are
08:00:20 <xkcd> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:algebra
08:01:39 <armlesshobo> looks like algebra packages.
08:02:08 <xkcd> DoCon seems to be inactive for quite sometime
08:02:49 <quchen> How do I construct a Maybe value using TH? I thought I could just write 'runQ [| Just 1 |]' and I'd get the corresponding code. However, this results in 'AppE (ConE Data.Maybe.Just) (LitE (IntegerL 1))', which is not valid code, as Data.Maybe.Just is not a Name (which is what ConE expects).
08:03:33 <quchen> Basically I'm looking for a cheap way of getting the TH wrapper of a complicated data type this way.
08:03:50 <quchen> Above I inserted the dummy valud 1, and when I abstract that away then I've got a wrapper function.
08:03:53 <armlesshobo> xkcd: if anything you could just use ghci and the algebra/number package you need to work with
08:04:57 <xkcd> Okay  Thanks armlesshobo I look at them.
08:05:36 <armlesshobo> xkcd: np :)
08:05:46 <parcs> quchen: it is definitely valid code
08:06:19 <quchen> Well, GHCi says  Couldn't match expected type `Name'
08:06:19 <quchen>                 with actual type `a0 -> Maybe a0'
08:06:20 <quchen>     In the first argument of `ConE', namely `Just'
08:06:40 <parcs> xkcd: http://vimeo.com/60737699
08:06:41 <quchen> Which is correct, as ConE :: Name -> Expr
08:07:02 <parcs> xkcd: that guy is writing a symbolic algebra thing is haskell too
08:08:01 <`nand`> xkcd: what a confusing name
08:08:30 <`nand`> misleading, rather
08:08:39 <parcs> quchen: how does GHCi say that?
08:09:12 <hpaste> Quchen pasted “GHCi's error” at http://hpaste.org/84380
08:09:30 <parcs> quchen: Data.Maybe.Just is how the Name gets pretty printed
08:10:02 <quchen> parcs: I suspected that. But how do I make a "Just" constructor in TH?
08:10:13 <quchen> lookupTypeName?
08:10:23 <xkcd> parcs: Thank you
08:11:06 <parcs> quchen: or mkName, or just use [| Just |]
08:12:19 <parcs> quchen: you rarely need to use the raw TH ast. just use splices
08:14:06 <quchen> Ah, I see, like do { just <- [| Just |]; return $ AppE just (LitE (IntegerL 1)) }
08:14:12 <quchen> Compiles and seems to do the right thing
08:14:57 <quchen> parcs: Especially the "you rarely need the raw TH stuff" is encouraging :-)
08:15:25 <liyang> > VarE 'Just `AppE` LitE (IntegerL 1)
08:15:26 <lambdabot>   Not in scope: data constructor `VarE'Syntax error on 'Just
08:15:26 <lambdabot>  Perhaps you int...
08:15:34 <quchen> Oh waiiiit. \x -> [| Just x |]
08:15:38 <quchen> That one should be easier
08:15:44 <quchen> Silly me
08:16:15 <liyang> You don't need to [| |] just to get a Just Q Exp.
08:16:16 <quchen> parcs: See, telling me not to use the raw functions already has consequences :-D
08:16:22 <notdan> Hi! Can somebody please tell me why GHC is complaining about overlaping instances for Data.MultiSet.MultiSet in this code: http://hpaste.org/84381
08:16:30 <quchen> liyang: ?
08:16:32 <parcs> [| $([|Just|]) 1 |]
08:16:36 <notdan> It's strange, because MultiSet is not an instance of Functor
08:16:39 <notdan> so it should not overlap
08:17:13 <`ramses> notdan: constraints are checked _after_ instance resolution
08:17:24 <quchen> parcs: Isn't $( [| XXX |] ) == XXX?
08:17:25 <`ramses> so the first instances matches all types
08:17:27 <liyang> quchen: [| Just |] returns VarE 'Just
08:17:48 <notdan> Hm, well
08:17:53 <notdan> that sounds strange
08:17:58 <quchen> liyang: I'm not familiar with ' yet
08:18:19 <`ramses> notdan: it's confusing indeed..
08:18:21 <liyang> quchen: it's just a Name.
08:18:22 <notdan> `ramses: what can I do about it then?
08:18:28 <quchen> ' = make name of whatever follows?
08:18:42 <quchen> If lower case, then variable, else type?
08:18:43 <`ramses> notdan: newtyping would be the off-the-shelve workaround, I think
08:18:43 <liyang> quchen: yes. And '' is the same for types.
08:19:04 <notdan> `ramses: newtyping?
08:19:11 <liyang> quchen: no, ' for names and constructors, '' for types and stuff.
08:19:14 <quchen> Ah, so ''Maybe is the type name of Maybe
08:19:14 <notdan> But I dont have any types defined
08:19:18 <quchen> Good to know, thanks
08:19:37 <quchen> TH is strangely fascinating. :-)
08:19:53 <liyang> As is a car crash.
08:20:04 <quchen> I'm beginning to see why it's an unfortunate blessing. Very tempting.
08:20:18 <quchen> Yeeeah no I wouldn't call a car crash fascinating
08:20:25 <quchen> Let's say nuclear power
08:20:40 <liyang> If you can do the job with CPP, do that. :)
08:20:58 <`ramses> notdan: the problem is the first catch-all instance. To avoid that you could make some type F which wraps a functor and has an OrdFunctor instance
08:21:00 <liyang> (Except GHC uses CPP with --traditional, which has its own quirks.)
08:21:17 <quchen> liyang: I can't use CPP, I'm trying to use TH as a poor man's supercompiler
08:21:38 <quchen> Basically a compile time deepseq
08:23:25 <liyang> Good luck. :)
08:23:48 <djahandarie> edwardk, I should be there for Boston Haskell today!
08:24:30 <quchen> liyang: I'll finally beat these assembler nerds at project euler brute force solving! ;-)
08:26:10 <djahandarie> I don't have a laptop though... that should be interesting.
08:26:26 <notdan> `ramses: right, thanks
08:34:43 <ag90> I've run into this memory problem. I have this function: loop args = <stuff that requires memory> >> loop newArgs. The loops are completely independent, i.e., nothing done in one iteration is required by another (args are just 2 integers). The heap graph shows memory being allocated in phases and not freed when a new loop begins (http://i.imgur.com/YHrpymx.png)
08:35:16 <ag90> I'm completely at loss on how to fix this.
08:35:53 <ag90> (The graph ends early because I terminated program execution.)
08:37:56 <labo> ag90: maybe something isn't fully evaluated and thunks are creeping up?
08:38:07 <labo> (just a guess)
08:39:37 <ag90> labo: I've been keeping operations pretty strict with bang patterns and $!. Perhaps I missed something.
08:39:44 <aleator_> ag90: Can you show code?
08:40:01 <labo> what is a good library for parsing json?
08:40:02 <ag90> Okay, just a moment.
08:40:08 <labo> I want to parse to a data type
08:40:13 <aleator_> labo: aeson seems popular
08:40:43 <hpaste> ag90 pasted “External Mergesort” at http://hpaste.org/84382
08:41:20 <ag90> Line 402
08:42:00 <tippenein> anyone using shim.vim (superior haskell mode) ?
08:43:52 <aleator_> ag90: Well. Atleast it is not obvious.
08:44:12 <ag90> Heh, yeah.
08:44:26 <ag90> The code is not in the best state either.
08:44:49 <aleator_> ag90: I'm not enough familiar with conduit to offer anything smart. What happens if you slap performGC at the end of the loop?
08:45:00 <aleator_> (Nothing should happen)
08:45:01 <ag90> I tried that. Didn't make a difference.
08:45:42 <aleator_> I've actually had problems where that helped.
08:47:48 <aleator_> ag90: This is bit funny, since you'd expect that whatever is sticking to the memory would lie in input output or n. None of which can contain increasing amounts of data.
08:48:38 <aleator_> I'm looking forward to learning how that gets solved.
08:48:43 <ag90> Yeah. So, I just added performGC to the start of the loop. Went from http://i.imgur.com/sBt6rhU.png to http://i.imgur.com/9AbYQ8u.png
08:49:12 <aleator_> Huh?
08:49:13 <ag90> Which I find weird since that seems to have increased memory usage.
08:49:23 <ag90> (smaller data set)
08:50:20 <aleator_> ag90: Thats a small difference
08:50:35 <aleator_> How many loops does that do?
08:50:45 <ag90> I'll check.
08:51:23 <aleator_> ag90: Also, did you already do retainer profiling? (The -hr thingy?)
08:51:49 <ag90> No. I should check that.
08:51:55 <ag90> On this data set, it's only one loop iteration.
08:54:42 <linduxed> tippenein: nope, but so far i've been satisfied with lushtags + neco-ghc, don't feel i need much more
08:54:56 <linduxed> tippenein: when speakin of haskell-specific plugins, that is
08:55:03 <linduxed> tippenein: i've got a ton of other ones
08:55:12 <linduxed> tippenein: syntastic comes to mind, really helps
08:55:13 <ag90> http://i.imgur.com/GWDwQHQ.png
08:55:46 <linduxed> ag90: really clear diagram right there
08:57:13 <aleator_> Also, -hc might Tell you what actually stuffed the sticky stuff to memory..
08:57:40 <aleator_> ag90: From the latest pic, I can't really see the leak anymore?
08:58:10 <ag90> I'll try running it on the larger data set. The smaller data set does not cause it to take multiple passes.
08:58:30 <aleator_> Yeah. You'd probably want something that has two or three passes.
08:59:06 <ag90> Running. It'll take a few minutes.
09:00:38 <tippenein> linduxed: I'm not concerned with much more than just executing ghci inside vim
09:01:12 <linduxed> tippenein: well, i haven't tried that plugin, so i can't help you with that
09:01:30 <tippenein> does neco-ghc or any of your other plugins do that?
09:02:00 <ag90> So, to be clear, retainer profiling tells me why something is not being GCed?
09:02:05 <linduxed> tippenein: don't think so, i use neco-ghc for omnicompletion of functions, it looks through installed packages
09:02:17 <linduxed> tippenein: lush just generates ctags for haskell
09:02:37 <aleator_> ag90: Yeah. Kinda.
09:03:21 <tippenein> linduxed: ok, cool. So you just use a different window for ghc --make ?
09:03:30 <linduxed> yeah
09:03:46 <linduxed> although i generally test stuff in ghci
09:03:57 <linduxed> load the files, run specific functions in the interpreter
09:04:06 <aleator_> ag90: In lucky cases it points you to thunk holding the data
09:04:20 <ag90> Hah, that would be awesome.
09:04:46 <ag90> However, considering the things I've done in this code, I don't think I'll be that lucky.
09:09:47 <ag90> It's either in the third pass or the fourth pass. Might be okay to kill it now. I don't know how long this will take.
09:10:56 <aleator_> ag90: You can actually plot the profiles while the program is running if you drop the last, incomplete, item from the prof
09:11:10 <ClaudiusMaximus> ag90: BS.take and BS.drop reference the existing data, maybe you need BS.copy? http://i.imgur.com/GWDwQHQ.png
09:11:13 <ClaudiusMaximus> oops
09:11:18 <ClaudiusMaximus> http://hpaste.org/84382#line199
09:12:46 <ag90> ClaudiusMaximus: Cannot copy. Copying will allocate new memory blocks. take/drop will refer to a slice of the same block.
09:12:52 <ClaudiusMaximus> ok
09:13:15 <ClaudiusMaximus> must admit it's a lot of code using libraries i'm not familiar with :)
09:14:01 <ag90> ClaudiusMaximus: Agreed. My familiarity with most of them was minimal too.
09:14:08 <ag90> aleator_: http://i.imgur.com/hOxfFVT.jpg
09:14:57 <aleator_> ag90: So the excess is held by groupMV.
09:15:11 <ag90> Apparently. I did not expect that.
09:15:11 <aleator_> +1 for ClaudiusMaximus
09:17:09 <ag90> Looking at groupMV, I don't see anything obvious.
09:18:47 <aleator_> ag90: I need to go invigilate an exam. I think it is what ClaudiusMaximus just said: take will reference everything, which might retain older copies.
09:18:55 <aleator_> Hope you get it fixed.
09:19:06 <ag90> Cool. Thanks for your help.
09:21:50 <edwardk> djahandarie: yay!
09:22:15 <edwardk> djahandarie: luke palmer said something about flying into BOS earlier on facebook, so maybe we can lure him out as well
09:23:55 <flebron> "Hey, I am Haskell; and this is lazy; so here's a function; I'll call it, maybe."
09:24:12 <flebron> (It also works if you remove the last comma :D)
09:24:57 <monochrom> haha
09:25:04 <yitz> flebron: you have provided the answer to this question: what does haskell have in common with Harvard economists?
09:25:21 <Taneb> flebron, that... works better than the original
09:25:45 <Taneb> flebron++
09:26:01 <edwardk> If we start thinking of Haskell as the "Call me, Maybe" language then I'll never be able to avoid that song.
09:26:06 <monochrom> @remember flebron "Hey, I am Haskell; and this is lazy; so here's a function; I'll call it, maybe."
09:26:06 <lambdabot> Done.
09:26:30 <yitz> flebron++
09:26:53 <ClaudiusMaximus> ag90: hm, i think VM.clear might not work as advertised - haven't figured out where the instances are defined but class MVector v a where ...  basicClear _ = return ()  -- looks ominous
09:27:09 <powergiant> Is there a standard function for taking two lists and subtracting their x's with eachother? as in f [1,2] [2,1] = [1-2,2-1] ?
09:27:10 <klrr> i try solve this problem http://projecteuler.net/problem=1 , http://hastebin.com/jaqenuvoyu.hs <- that's my code, but i get the wrong answer why is that? (or is it correct?)
09:27:40 <flebron> powergiant: zipWith (-)
09:27:50 <S11001001> powergiant: what's f [1] [2,1]?
09:28:15 <powergiant> flebron: Oh yes, I should have remebered. Thnaks!
09:28:32 <S11001001> > zipWith (-) [1,2] [2,1,42] :: [Expr]
09:28:33 <ag90> ClaudiusMaximus: It's defined in Data.Vector.Mutable for that instance. It merely sets the values to uninitialized defaults.
09:28:33 <lambdabot>   [1 - 2,2 - 1]
09:28:41 <powergiant> S11001001: And is undifiend.. Right now I can assume I always use lists of equal sizes
09:28:49 <powergiant> but that'll work too
09:28:51 <yitz> klrr: *below* 1000
09:29:24 <yitz> > [1..5]
09:29:26 <lambdabot>   [1,2,3,4,5]
09:29:48 <klrr> yitz: oh, so [1000..1] ?
09:30:13 <yitz> klrr: no, what i meant is that you are including the number 1000, but the problem says not to
09:30:16 <ClaudiusMaximus> ag90: ok - considering library bugs is a sign i'm out of my depth :)
09:31:26 <ag90> ClaudiusMaximus: Thanks for your help anyway.
09:31:47 <ag90> I'll see if I can find a way.
09:37:09 <yitz> wow, interesting. try that euler problem for 1000, 10000, 100000, ... i'm surprised they didn't do something with that. (yes, i know, klrr is gone...)
09:37:46 <powergiant> is it possible to do something like 'runhaskell' from inside ghci ?
09:38:18 <Iceland_jack> powergiant: :! runs a shell command
09:38:45 <yitz> powergiant: or load the module and just type main at the ghci prompt.
09:39:09 <powergiant> yitz: That does it good enough for my needs. Thanks!
10:05:43 <srhb> Hmm. I'm basically reading Strings directly from an IRC server. And it seems things like 水 and other weird characters are handled just fine. is there any reason to switch to Text or maybe even ByteString for the handling of things from the network socket?
10:07:57 <byorgey> Text is faster and uses less memory and handles things like uppercasing/lowercasing properly.  But I would say if String is working OK for you then don't worry about it.  (I'm sure others may disagree.)
10:08:37 <srhb> OK.
10:08:55 <byorgey> Since it sounds like you are actually processing text (as opposed to binary data) you should only use ByteString if you really need to handle encoding/decoding yourself.
10:08:58 <sapphire> Hello. I know that --xs!!n-- gives me n-1th element in a list. Can you tell me how can I edit nth element in a list. For example how can I make 'a' an 'e' in this : ['s','a','p','p','h','i','r','e'] ?
10:09:22 <luite> oh what's wrong with uppercasing/lowercasing in String?
10:09:58 <byorgey> luite: I don't really know the details, apparently in some languages to do upper/lowercasing properly requires looking at several consecutive characters to decide what to do
10:09:59 <supki> sapphire: there isn't predefined function for that
10:10:03 <byorgey> so 'map toUpper' is not correct
10:10:39 <srhb> byorgey: I guess I just don't know yet. I assumed I would have to, but apparently things are working just fine.
10:10:44 <sapphire> <supki> can you give me at least a hint for that?
10:11:15 <luite> byorgey: oh uhm odd. I could imagine that would be a problem for utf16 encoded things, where some characters are encoded as a surrogate pair, but Char is just a single integer representing the codepoint
10:11:19 <typoclass> byorgey: that sounds like a job for icu?
10:11:28 <monoidal> sometimes uppercasing depends on locale. for example, English has small i and capital I, while Turkish has capital I, lowercase ı and captial İ, lowercase i
10:11:53 <luite> byorgey: oh wait, real characters
10:11:54 <byorgey> I defer you all to http://hackage.haskell.org/packages/archive/text/0.11.2.3/doc/html/Data-Text.html#g:8 for the details.
10:12:01 <luite> hmm that's interesting
10:12:29 <luite> oh that's quite cool, didn't know that :)
10:12:39 <byorgey> oh, uppercase ß -> SS  is a simple example
10:13:01 <fizbin> sapphire: You'll need to take the list apart and put it back together.
10:13:08 <luite> ah good one, but that's a deprecated character ;)
10:13:08 <typoclass> sapphire: hello, just as a heads-up, "editing" a list in haskell is done by giving back a new list with a few things changed. the old list stays intact.
10:13:27 <byorgey> luite: well, sure, but it still needs to be handled correctly!
10:13:39 <byorgey> > map toUpper "spaß"
10:13:39 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
10:13:47 <byorgey> heh
10:13:47 <luite> ooh
10:14:03 <typoclass> byorgey: that's broken since an update a while ago
10:14:13 <sapphire> thanks guys!
10:14:25 <luite> i need to review the ghcjs code for this
10:14:29 <typoclass> sapphire: for your job, you should look at the map function
10:14:31 <fizbin> > let updateList n newval lst = take (n-1) lst ++ [newval] ++ drop n lst in updateList 5 'g' "Hello world"
10:14:34 <lambdabot>   "Hellg world"
10:15:05 <byorgey> you can also use 'splitAt' to take the list apart
10:15:21 <typoclass> > map (\x -> if x == 'p' then 'u' else x) "sapphire"
10:15:23 <lambdabot>   "sauuhire"
10:15:26 <fizbin> Although that implementation has an off-by-1 error.
10:16:04 <fizbin> > let updateList n newval lst = take n lst ++ [newval] ++ drop (n+1) lst in updateList 5 'g' "Hello world"
10:16:06 <lambdabot>   "Hellogworld"
10:17:01 <fizbin> Or sure, you can write it slightly more efficiently with splitAt.
10:17:34 <sapphire> #typoclass I don't see how map would work for me since I want to edit one or two elements in a list
10:18:09 <typoclass> sapphire: oh sorry, i didn't catch that. map will process all of the elements in the list
10:18:11 <yitz> byorgey, srhb: normally, for a network protocol, you read ByteString off the line, then once you know you have text (and not binary goop) you immediately decode it to Text.
10:22:14 <typoclass> srhb: afaik, the encoding is not defined in irc, so most clients use utf-8. you seem to have used utf-8 decoding when you read that into the String, so it works out
10:22:34 <ab9rf> typoclass: freenode is officially utf-8
10:23:34 <typoclass> ab9rf: don't know. i guess we'd have to set the client to utf-16 and reconnect, and see what happens.
10:24:03 <ab9rf> in practice, irc only allows ascii-7 in the portions of the communication it actually interprets
10:24:18 <ab9rf> in message payloads the server doesn't care what encoding is used
10:24:52 <ab9rf> typoclass: a UCS-16 client would not get far :)
10:25:37 <ab9rf> i've yet to see an irc server that allows nonlatin characters in channel names
10:25:40 <ab9rf> or in user ids
10:26:51 <chrisdotcode_> hello everyone :)
10:27:26 <ab9rf> the server doesn't interpret any of the payloads so they can be arbitrary binary data.  freenode has a social policy of utf-8, but the servers do not enforce well-formedness, and you will sometimes find channels that are using other encodings
10:28:01 <byorgey> hi chrisdotcode_
10:31:52 <sapphire> Is it possible to get the index of an element in the list? For example how can I get the indexes of "p"s in ['s','a','p','p','h','i','r','e']?
10:32:20 <ab9rf> sapphire: oddly enough, yes
10:32:49 <ab9rf> sapphire: do you want to write the function yourself or use a library? :)
10:32:50 <sapphire> can I ask how?
10:33:23 <sapphire> I'd like to learn to write the function :)
10:33:34 <srhb> You could zip the list with its indices
10:33:39 <srhb> And then extract them afterwards.
10:33:48 <srhb> > zip [1..] "sapphire"
10:33:49 <lambdabot>   [(1,'s'),(2,'a'),(3,'p'),(4,'p'),(5,'h'),(6,'i'),(7,'r'),(8,'e')]
10:34:13 <eikke> a combination of map, filter & zip should do the trick :)
10:34:16 <srhb> NOte that calling it indices seems to imply that you have fast lookup in lists. You don't.
10:38:47 <yitz> srhb: on modern machines, it would usually need to be a list with at least 10s of thousands of elements for it to be worthwhile to use anything other than lists tho
10:42:30 <srhb> yitz: Yeah.
10:42:37 <srhb> Well, define worthwhile..
10:45:17 <ab9rf> it depends on how often you're doing it
10:48:43 <arbn> Yo, Haskellers. So, I want to play with Cloud Haskell, but don't know anything about distributed computing yet. Any recommendations on books of algorithms, or other sources of stuff on which to cut my teeth?
10:50:04 <tippenein> arbn: you've looked at all these? http://www.haskell.org/haskellwiki/Cloud_Haskell
10:50:07 <nardul> arbn: I'd look at distributed algorithms and systems like chord and such. I'm currently taking a course, we're using a tannenbaum book called distributed systems.
10:50:56 <tippenein> or are those too specific to haskell
10:52:02 <arbn> tippenein: Oh. I had forgot about the Well Typed blog posts. I'll read over those again.
10:52:28 <arbn> nardul: How do you like the book?
10:53:22 <arbn> tippenein: I am kind of looking more the abstract description of algorithms, that I can implement with Haskell for learning.
10:56:10 <srhb> So I suppose I really ought to be using attoparsec instead.
10:56:19 <srhb> I wonder how hard the rewrite is...
10:57:09 <johnw> srhb: what are you using right now?
10:57:49 <srhb> Parsec
10:58:00 <johnw> it won't be terribly hard
10:58:13 <johnw> there are few combinators missing, but not anything you can't work around
10:58:33 <srhb> Alright. I'll have a crack at it. Then to the actual ByteString -> Maybe Text afterwards.
10:58:55 <johnw> why Maybe Text?
10:59:02 <johnw> you don't know whether it will be textual data or not?
10:59:58 <aristid> johnw: i suppose it's Maybe because the function might fail?
11:00:02 <srhb> Yeah
11:00:15 <johnw> hmm... i don't think decodeUtf8 provides that?
11:00:25 <aristid> @hoogle decodeUtf8
11:00:26 <lambdabot> Data.Text.Encoding decodeUtf8 :: ByteString -> Text
11:00:26 <lambdabot> Data.Text.Lazy.Encoding decodeUtf8 :: ByteString -> Text
11:00:26 <lambdabot> Data.Text.Encoding decodeUtf8' :: ByteString -> Either UnicodeException Text
11:00:28 <srhb> There's probably something in text-icu then
11:00:32 <srhb> Ah
11:00:33 <aristid> johnw: it does:)
11:00:45 <aristid> just with a '
11:00:45 <srhb> There's one.
11:00:47 <johnw> ah
11:00:49 <johnw> decodeUtf8'
11:01:05 <johnw> the non ' case just throws an exception
11:01:08 <srhb> Apparently I can't trust irc users to actually write valid anything. So it will be interesting. :-)
11:01:59 <srhb> The bad part is, I need to decide on an encoding, and I don't think that's actually very true to the idea that anyone can just write any byte sequence in a message.
11:02:03 <aristid> srhb: oh, in case of irc just make a best effort guess as to what they meant :)
11:02:08 <srhb> aside from \CR\LF
11:02:10 <srhb> Yeah.
11:02:19 <nardul> arbn: It's a bit general. Try building something like: http://zond.github.com/god/architecture.html
11:02:26 <srhb> I wonder if there's a helper out there for making that guess.
11:02:42 <aristid> srhb: i think the "standard" encoding for reading irc is either-latin1-or-utf8. probably easiest on a line-by-line basis
11:02:55 <srhb> Yes, I will be reading line-by-line anyway.
11:02:56 <ab9rf> srhb: there's no guarantee that the payload of an IRC message is valid UTF-8, or indeed valid anything.  i think you can be assured it won't contain any nulls.
11:02:59 <aristid> like first you try utf8 and if that fails for the line, fall back to interpreting it as latin-1 :D
11:03:10 <srhb> aristid: Fun fun :P
11:03:19 <aristid> srhb: irc is da fun!
11:03:26 <srhb> ab9rf: So should I just give up on even trying to encode the bytestring?
11:03:44 <srhb> ab9rf: That seems like my bot won't be able to do a lot of useful things :P
11:03:45 <ab9rf> srhb: my advice? allow encoding to be set on a channel-by-channel basis
11:03:51 <srhb> Hmm.
11:04:25 <geekosaur> there's also what xchat does by default, which is attempt utf8 and fall back to iso8859-1
11:04:29 <ab9rf> srhb: i've seen channels that are in 8859-5 or CP-1251
11:04:34 <srhb> Ack.
11:04:42 <aristid> geekosaur: which is pretty much the procedure i described.
11:04:46 <ab9rf> srhb: because they're eastern yurpers
11:04:47 <srhb> tryAllEncodingsOrNothing...
11:04:48 <srhb> :P
11:04:51 <aristid> geekosaur: latin-1 == iso-8859-1
11:05:03 <geekosaur> sorry, yes
11:05:07 <ab9rf> the thing is, you can't tell if it's 8859-1 or 8859-5 by inspection
11:05:09 <aristid> well latin 1 will always succeed
11:05:15 <srhb> Oh dear.
11:05:19 <aristid> ab9rf: except with very fancy heuristics
11:05:21 <hiptobecubic> one of its best qualities :D
11:05:37 <ab9rf> all the 8859-X encodings have mappings for every character... just some of them render weird.
11:05:40 <xkcd> Does anybody know nice color scheme for syntax highlighting haskell in vim
11:05:46 <aristid> just tell eastern yuropers to use utf-8 :P
11:05:50 <monochrom> you should just keep it as bytestring and let the real user interpret it
11:05:52 <srhb> Screw it, people can get UTF8 or they can get nothing!
11:06:05 <srhb> monochrom: Unfortunately the bot has to actually respond to things :P
11:06:10 <ab9rf> srhb: i think the practice of trying utf-8 and falling back to 8859-1 is a safe bet
11:06:19 <srhb> Right.
11:06:23 <powergiant> does anybod know how I can make mplot (from Graphics.Plot) display something by calling it from my main = do ? When I use it in ghci it displays the graphics, but when i run my program nothings happens.
11:06:31 <monochrom> ok, but move the decoding to the responder
11:06:35 <ab9rf> but maximum niceness would allow for overriding that on a channel-by-channel basis
11:06:45 <srhb> Hmm.
11:06:47 <hiptobecubic> xkcd, it's a matter of taste. Here's mine. I like it. http://vpaste.net/N0oBO
11:06:55 <ab9rf> because there are plenty of 8859-5 channels still out there
11:06:56 <srhb> Can I then at least assume that anything before ':' is not weird?
11:07:03 <hiptobecubic> xkcd, oh you wanted the color scheme. then no.
11:07:04 <ab9rf> i've seen 8859-8 too
11:07:04 <monochrom> yes
11:07:21 <ab9rf> srhb: yes, all of the protocol exchanges are in ASCII-7
11:07:32 <hiptobecubic> xkcd, I grew my own color scheme over time starting from peachpuff in the terminal. I guess you could have that if you watned
11:07:36 <ab9rf> srhb: there ought never be any high-bit-set bytes outside of payloads
11:07:38 <srhb> So I can always decode prefix, command and the first params to Text
11:07:44 <srhb> That helps a bit I guess.
11:07:50 <xkcd> Yeah sure hiptobecubic
11:08:02 <Ralith> For debugging purposes, is there any way to get the pointer identity of a STRef in ghci?
11:08:29 <ab9rf> srhb: no irc server ive seen allows non-latin characters in channel names or nicks
11:08:43 <srhb> Still, just allowing utf8 should be fine.
11:08:53 <srhb> Or I assume it will be :P
11:08:59 <srhb> Up until the :, I mean
11:09:00 <monochrom> depending on what your bot does, you may be able to leave a lot of things undecoded
11:09:00 <ab9rf> srhb: in fact, the reason irc allows ^[/]{|} in nicks and channel names is to accomodate the finns
11:09:28 <hiptobecubic> xkcd, http://vpaste.net/ZfILr  Assumes you have 255 color support
11:09:49 <ab9rf> because back when irc was developed, those characters were used for diacritically marked letters in a number of scandinavian languages.
11:09:54 <srhb> Oh.
11:10:41 <srhb> Alright. I'll have a crack at the attoparsec part and let the idea of not being able to decode the payload / fallback or fail settle a bit :P
11:11:13 <ab9rf> srhb: honestly i'd parse at the bytestring level and only parse payloads when you actually need to
11:11:57 <ab9rf> payloads always start with a : and end with a newline; you can just capture them dumb and transcode them only when needed
11:12:13 <xkcd> Thank you hiptobecubic
11:12:24 <hiptobecubic> xkcd, sure
11:13:45 <ab9rf> srhb: oh, you'll also find channels using CP-437
11:14:51 <xkcd> hiptobecubic:  How to actually check whether terminal has 255 color support? I use gnome terminal 3.6
11:15:46 <hiptobecubic> xkcd, http://www.frexx.de/xterm-256-notes/
11:16:10 <hiptobecubic> i suppose this one http://www.vim.org/scripts/script.php?script_id=1349
11:20:08 <ab9rf> hrm.
11:23:43 <theseb> i've had people tell me confidently that in future we'll be using functional languages more and more.....how/why are people that say such things so certain?
11:23:55 <Ralith> when stepping through a computation in ghci, is there any way to hold onto a value gotten from a local var?
11:24:12 <theseb> (i.e. I want to be convinced I should get obsessed with functional and the way forward and the silver bullet)
11:25:26 <Cale> theseb: Being certain about it isn't wise, but there are a bunch of things which are making functional languages more attractive, one of which is the fact that processor clocks aren't getting much faster, making parallelism the only way forward in performance.
11:25:42 <flebron> I used to think I know Haskell, like you, but then I took an Arrow to the ContT.
11:25:48 <ab9rf> flebron: heh
11:26:12 <ab9rf> theseb: people will continue to use imperative languages for the indefinite future
11:26:14 <Cale> Another is that people are realising more and more that purity/referential transparency leads to all sorts of good correctness properties.
11:26:15 <theseb> Cale: thanks...say haven't i seen on @math often
11:26:19 <theseb> ?
11:26:23 <theseb> Cale: #math i mean
11:26:28 <Cale> theseb: I'm often there, yeah
11:26:50 <theseb> Cale: i'm a math guy myself...i was thinking that math guys may have a bright future if functional keeps growing
11:27:03 <theseb> Cale: especially if it scare away a lot of the folks that aren't so into math
11:27:14 <ab9rf> theseb: honestly i think one of the main advantages of learning a functional languge is that it forces you to think about computation in a more structured and rigorous way that leads to better coding practices even when writing in other languages
11:27:16 <xkcd> hiptobecubic: How to run the test I don't know perl
11:27:32 <theseb> ab9rf: thanks
11:27:49 <hiptobecubic> xkcd, perl filename
11:27:57 <xkcd> Okay
11:27:58 <Cale> theseb: Well, it ought not to *scare away* non-math people, but it definitely encourages a mathematical way of thinking.
11:28:25 <hiptobecubic> xkcd, I made one in bash at one point as well. it just prints some escape sequences to the terminal to tell it to change colors. http://vpaste.net/qdwHZ
11:28:26 <ab9rf> theseb: i find myself looking more at data flows and less at execution flow
11:29:20 <Cale> Well, there are lots of good things about functional programming generally, to the point where it's hard to say what will be the cause of future popularity.
11:29:42 <ab9rf> from a personal-competency standpoint, the more tools you have the more capable you are
11:29:43 <hiptobecubic> Cale, i think the correctness argument is probably the strongest
11:30:18 <hiptobecubic> Even for non-critical applications, bug hunting is still *most* of the development effort.
11:30:19 <Cale> There are basic things like, well, you write an algorithm, and then you write another and realise that it's very similar except for a little chunk of code which has been replaced, and you'd like to factor that out.
11:30:52 <ab9rf> Cale: i've been impressed on how much easier it is to generalize haskell code.  often it's just a matter of changing the type signature.
11:30:54 <Cale> Of course, OO programming has sort of an answer to that, insofar as it can somewhat awkwardly model functional programming.
11:31:11 <hiptobecubic> Cale, heh
11:31:35 <ab9rf> i've gotten increasingly disenchanted with OO programming
11:32:02 <hiptobecubic> I just don't think it's much fun really.
11:32:10 <Cale> OO has always been good for some things, but it's only ever been good for some things.
11:32:48 <ab9rf> Cale: that's true of basically every programming model
11:32:57 <Cale> also, most OO languages do a really poor job of supporting object oriented programming
11:32:58 <c_wraith> I've written OO code in haskell.  Once.  That was the time when it solved the problem well.
11:32:59 <hiptobecubic> it makes me think less about data and more about recipes, which i think is kind of boring
11:33:14 <Cale> In fact, to the point that I think Haskell beats them at it. :P
11:33:35 <theseb> Cale: how does the haskell job market look?
11:33:44 <ab9rf> there's a job market? :)
11:33:46 <Cale> theseb: Well, I'm employed :)
11:33:53 <theseb> Cale: doing haskell!?!?!?
11:33:56 <Cale> yeah
11:34:00 <johnw> OO is easy to describe, but hard to use well; Haskell is hard to describe, but easy to use well (once you've learned it)
11:34:03 <c_wraith> My company has about 5 engineers using haskell.
11:34:04 <theseb> Cale: like WOW
11:34:08 <aristid> there are a bunch of companies that seem to use some haskell now
11:34:09 <theseb> Cale: really....WOW
11:34:18 <johnw> aristid: Haskell is the only language we use :)
11:34:19 <Taneb> theseb, quite a few people are
11:34:21 <theseb> Cale: paid to use Haskell and be mathy
11:34:29 <ab9rf> aristid: yeah, it's been growing quietly inside larger, more forward-looking companies
11:34:31 <Cale> I've been employed 3 different times writing Haskell code for money.
11:34:38 <aristid> johnw: well you're in the haskell teaching business from what i can tell :P
11:34:57 <johnw> aristid: that's just our beginning
11:35:08 <c_wraith> also, all their code *is* in haskell
11:35:12 <Cale> There are not that many jobs, but there's also not a *huge* amount of competition for those jobs
11:35:13 <ab9rf> i'm wondering what's going to happen with perl6
11:35:30 <johnw> i haven't written a line of code in any other language but Emacs Lisp in almost six month snow
11:35:31 <theseb> Cale: nice
11:35:40 <c_wraith> johnw: that's a long winter
11:35:44 <Cale> If you're a Java programmer, you really have to do a lot to set yourself apart from the ridiculous number of people who know (or at least claim to know) Java.
11:35:53 <thoughtpolice> actually, my experience has been the number of jobs isn't typically very high, but those positions are very competitive in terms of who apply for it
11:35:55 <aristid> johnw: haskell and emacs lisp... make a johnw happy i hope :D
11:35:57 <ab9rf> johnw: i've been known to go a year or more without writing code in any language other than perl
11:36:00 <theseb> Cale: where do you find these lovely haskell jobs?
11:36:02 <johnw> aristid: more than I can tell you!
11:36:07 <Cale> If you're a Haskell programmer, probably everyone in the Haskell community eventually knows who you are.
11:36:14 <thoughtpolice> the average haskell programmer you're going up against for a position like that is likely not going to be a run-of-the-mill regular developer
11:36:15 <Cale> People ask me
11:36:18 <theseb> Cale: any entry level jobs for low pay?
11:36:24 <Cale> and I say "yeah, that'd be cool"
11:36:41 <theseb> Cale: i'd love to get a humble paying entry level monkey coder haskell job
11:36:50 <ab9rf> theseb: i'm not sure there are any such jobs
11:36:55 <theseb> i'd give you a Steak dinner finders fee
11:37:04 <ab9rf> theseb: haskell is not a language that calls for monkey coders
11:37:05 <Cale> thoughtpolice: That's true
11:37:41 <Cale> thoughtpolice: Then again, you know Haskell, so you're likely already an above average average programmer yourself.
11:39:35 <aristid> Cale: is the typical haskell job associated with something like a "you may use haskell" pay cut?
11:39:41 <thoughtpolice> Cale: :)
11:40:10 <ab9rf> i've been out f work for four years now, which is part of why i'm coding again
11:40:40 <Sculptor> how many haskell jobs are out there, ab9rf
11:40:41 <ab9rf> of course, now that i'm actually getting my legs back, i have a fairly serious job prosect
11:40:50 <ab9rf> Sculptor: i have no idea.  i'm a systems engineer.
11:41:11 <theseb> aristid: lol
11:41:15 <ab9rf> Sculptor: i haven't worked in a development role professionally since 2001
11:41:27 <Sculptor> ok
11:41:28 <Cale> aristid: I can't really say from experience, but my pay seems pretty reasonable to me, and I'm being paid the same in my current job since we switched to Haskell.
11:42:08 <Cale> I haven't taken that many non-Haskell programming jobs :P
11:42:10 <aristid> Cale: what did you use before in that job?
11:42:27 <Cale> Maintain a horrible grails/groovy codebase :D
11:43:00 <Cale> (Which we're now replacing with Snap/Haskell)
11:43:01 <ab9rf> Sculptor: although i'm probably going to start writing haskell code to automate systems administration if i get back to working again :)
11:43:06 <aristid> Cale: yay.
11:43:16 <aristid> Cale: were you involved in convincing them to switch? :D
11:43:20 <Cale> Nope
11:43:32 <aristid> did you join after the decision was already made?
11:43:35 <Cale> My boss is also a Haskeller
11:43:38 <Sculptor> ab9rf, glad to hear that
11:43:42 <johnw> Cale: what is his name?
11:43:47 <Cale> Ryan Trinkle
11:44:04 <Taneb> Can you guys make sure that there's loads of Haskell jobs available in about 5 years
11:44:07 <ab9rf> Sculptor: that, or writing games in haskell
11:44:13 <johnw> Taneb: we're working on that :)
11:44:17 <Taneb> Thanks
11:44:27 <johnw> in fact, if FP Complete meets its primary goal, that is exactly what will happen
11:44:31 <Taneb> Wow
11:44:47 <Taneb> Perfect
11:44:50 <aristid> johnw: the fp complete jobs are remote, right?
11:44:56 <hiptobecubic> Cale, oh the game company? How is that going?
11:44:56 <johnw> aristid: yes
11:45:06 <Cale> hiptobecubic: This is actually a different company now :)
11:45:14 <johnw> aristid: in fact, I'm now chatting with you from London, and I bet you had no clue :)
11:45:24 <hiptobecubic> Cale, oh. It went poorly then :D ?
11:45:26 <aristid> johnw: no i thought you were in the US:)
11:45:33 <johnw> aristid: my home is in Illinois
11:45:36 <aristid> johnw: whacha doing in the londons?
11:45:38 <johnw> aristid: I'm here for Emacs Conf
11:45:41 <aristid> ah
11:45:59 <johnw> which is in just 10 days, I need to work on my talks...
11:46:14 <aristid> johnw: and you thought you might as well work on them right in london? cool
11:46:19 <Sculptor> ab9rf, i like games better
11:46:21 <aristid> johnw: in a hotel, or...?
11:46:22 <johnw> yeah, my Dad lives here
11:46:29 <aristid> ah, with your dad then
11:46:33 <johnw> so he's hacking on his computer right now while I hack on mine
11:46:51 <ab9rf> Sculptor: i like the idea of writing games but i hate the tedium of writing them in languages like C++ or Java
11:46:53 <johnw> this has been a super productive trip.  In gitlib yesterday I wrote a generic "push" algorithm for any Git backend
11:47:02 <aristid> aw father son hacking romanticism :P
11:47:13 <Cale> hiptobecubic: The game is on hiatus, but blackh has put some more work into it recently, to get things running on android. We have most of a game engine, and you can run around and kill enemies and stuff, but there's lots of work to be done on the content and features related to the actual RPG aspect of things.
11:47:33 <johnw> except his hacking is mostly reading e-mails and writing legal documents (he's a lawyer)
11:47:51 <aristid> johnw: the gitlib README is a little short
11:47:57 <ab9rf> johnw: ah, a social engineer
11:48:08 <johnw> aristid: I haven't worked on the documentation yet at all
11:48:27 <aristid> johnw: then just explain here what gitlib is:)
11:48:44 <johnw> aristid: basically, it lets you write git "algorithms" to an abstract API, which will then work for variety of backends: cmdline Git, libgit2, GitHub, Amazon S3 (via your aws), and soon "Hit"
11:48:59 <aristid> what's "Hit"?
11:49:07 <johnw> a pure-Haskell implementation of Git
11:49:11 <aristid> johnw: hmm
11:49:24 <aristid> johnw: do you use the same storage format?
11:49:31 <johnw> here is a real-world utility I wrote based on gitlib, which I use daily now: https://github.com/fpco/gitlib/blob/master/git-monitor/Main.hs
11:49:42 <johnw> aristid: each backend can decide its own storage format, gitlib itself is agnostic
11:50:02 <aristid> i mean in Hit
11:50:08 <johnw> git-monitor is a super-efficient daemon that snapshots changes to your working tree as you work
11:50:11 <hiptobecubic> Cale, isn't the game engine the 'hard part' ?
11:50:16 <johnw> ah, Hit I believe duplicates the Git on-disk format
11:50:18 <aristid> johnw: and how does the s3 storage work?
11:50:18 <Cale> hiptobecubic: It would be a shame not to return to it at some point, as we have a lot of stuff that's done. We also have a pretty cool FRP library. At the very least, we ought to write a couple of papers about that and release something to the community at some point. ;)
11:50:27 <johnw> aristid: I serialize the Git objects to JSON
11:50:31 <Cale> hiptobecubic: yeah
11:50:34 <johnw> oh, S3
11:50:34 <aristid> johnw: ah, so no packing?
11:50:39 <johnw> I thought you meant GitHub
11:50:47 <Ralith> man, a way to inspect the pointer identity of STRefs would be handy
11:50:48 <aristid> when i say s3 i usually don't mean github:P
11:50:58 <johnw> for the S3 backend I use the same on-disk storage format as Git, except I provision 8 bytes at the beginning of each object to store its type and size
11:51:08 <aristid> johnw: hmm
11:51:18 <johnw> I store refs in their own refs.yaml file
11:51:25 <johnw> but no, no packging
11:51:29 <johnw> all objects are loose
11:51:33 <aristid> ugh
11:51:36 <johnw> because storage and bandwidth are cheap
11:51:50 <johnw> it's number of GETs/PUTs that I have to optimize for
11:52:14 <aristid> that's just an artifact of s3's pricing i think:)
11:52:36 <Cale> hiptobecubic: Though there are many layers of completeness to a game engine. Our game engine might be complete enough to do a less ambitious kind of game, which we also might also do at some point in order to actually, you know, make some money from it.
11:52:37 <johnw> sure
11:53:08 <johnw> but this is just a first version; I would hope to support getting and putting packs at some point.  Since Hit is working on reading/writing packfiles, maybe that's how I'll get that support in
11:53:32 <sipa> hit = git in haskell?
11:53:36 <johnw> also, libgit2 I think does deltification, that might work too (since the S3 backend is also an hlibgit2 backend)
11:53:38 <johnw> sipa: yes
11:54:00 <aristid> johnw: i would have some other ideas for how to make such a thing :)
11:54:15 <johnw> all suggestions welcome!
11:54:21 <johnw> open tickets for me on github
11:54:25 <johnw> gitlib is under active development
11:54:33 <sm> I would have thought for most games, the content is actually the harder part
11:54:43 <aristid> johnw: no i just want to tell you the idea right here :P
11:54:47 <johnw> i'm trying to get the API just right before the initial release, which I'm hoping will happen quite soon
11:54:52 <johnw> aristid: haha, ok, tell
11:54:57 <aristid> johnw: are you familiar with bup and/or rsync?
11:55:02 <johnw> yes
11:55:04 <johnw> both
11:55:15 <johnw> and xdelta
11:55:39 <aristid> johnw: are you also familiar with the "implementation detail" of how bup splits its blocks?
11:55:51 <johnw> no
11:55:51 <aristid> (interestingly gzip --rsyncable does more or less the same)
11:55:55 <johnw> i do know that it only grows
11:56:29 <johnw> my gzip doesn't have that option :(
11:56:51 <johnw> sm: the one time I tried to write a game, that's where i got blocked
11:57:05 <aristid> johnw: ok, if you split a file into blocks so you can deduplicate them, and do it in the obvious way of splitting by fixed block sizes, there's a problem, right? the behavior when you insert something in the middle of the file is quite abysmal, all the blocks after the insertion change
11:57:16 <johnw> right
11:57:34 <aristid> johnw: now, bup does something clever, and it's actually inspired by rsync
11:57:55 <aristid> johnw: and the method is also well-known among academics in that area i think, so it's not a new idea *building tension*
11:58:09 <BOOMLAY> ANY HOT AND SWEET LADY WANT TRUE FRIENDSHIP PM ME
11:58:11 <johnw> it tries to "sync up" by considering sub-blocks within each block?
11:58:13 --- mode: ChanServ set +o johnw
11:58:16 --- mode: johnw set +b *!~khuram_la@182.177.55.184
11:58:16 --- kick: BOOMLAY was kicked by johnw (Kicked)
11:58:20 --- mode: johnw set -o johnw
11:58:50 <Taneb> Alas, there are very few "HOT AND SWEET" ladies here
11:58:52 <shachaf> And there I was hoping for true friendship.
11:58:54 <aristid> johnw: you take a rolling checksum of a 128 byte window (which is rolled byte-by-byte), and once the 13 least-significant bits of the checksum are zero, a new block is started
11:59:10 <aristid> johnw: this way, blocks are guaranteed to line up after an insertion
11:59:19 <aristid> and the average block size will be 8 KB
11:59:27 <aristid> > 2^13
11:59:29 <lambdabot>   8192
11:59:44 <johnw> aristid: neat.  want to write this for my S3 backend? :)
12:00:26 <aristid> johnw: i might write some generic code for this, but edwardk already has some code for it in his analytics (i also told him about the trick, and he finished implementing before i got far)
12:00:41 <johnw> he does that when you mention ideas to him
12:00:49 <aristid> :D
12:00:57 <johnw> if you want a chance of doing it, you have to show him code, not talk about code that will be :)
12:01:34 <aristid> well his code is a little different from how i'd like to do it
12:02:11 <johnw> has it been differentiated and lifted into a profunctor already?
12:02:16 <aristid> johnw: https://github.com/analytics/analytics/blob/master/src/Data/Analytics/Hash/Rolling.hs
12:02:21 <aristid> no, it's quite low-level
12:03:06 <shachaf> johnw: If you show him code he'll just reïmplement it anyway.
12:03:07 <aristid> johnw: so whether you want to use that or not, is pretty much your decision :P
12:03:17 <shachaf> I have evidence.
12:03:23 <johnw> shachaf: haha
12:03:45 <aristid> shachaf: you do love your diaresis in english words :P
12:04:00 <shachaf> aristid: What's the matter with diæreses?
12:04:02 <johnw> aristid: so, I keep a pack file and a separate table of checksums, right, apply the algorithm to determine what needs to be added to the pack file, and just send that?  later I use some nifty algorithm to de-deltify and read out just the objects I want?
12:05:18 <aristid> johnw: the trick is that with this object splitting, you don't need any deltification.
12:05:39 <johnw> sure
12:05:41 <aristid> johnw: because you just split your objects once and store them in a deduplicating store, and that's all there is to it.
12:06:15 <johnw> but how do I avoid having to download the whole pack file every time I want one object out of it?  cap them at a certain size and start keeping generations?
12:06:22 <aristid> by not using pack files.
12:06:36 <aristid> i never mentioned any pack files
12:06:51 <johnw> i meant by pack file: that big glomming thing now in S3
12:07:27 <aristid> johnw: i think you'd just try to store everything as loose objects, but due to the intelligent block splitting that should not waste too much storage.
12:07:43 <johnw> wait, i think we're missing signals here
12:07:53 <johnw> how many files end up in S3 after pushing 10 objects?
12:08:10 <aristid> 10 git objects as generated by git?
12:08:15 <johnw> right
12:08:22 <johnw> blobs, trees, and one commit
12:08:22 <aristid> it depends on the size
12:08:32 <aristid> approximately total size divided by 8192 many
12:09:03 <johnw> how, my 10 objects are spread over a potentially fewer or greater number of files?
12:09:06 <johnw> s/how/so
12:09:35 <aristid> yes, it depends on the precise contents how many
12:09:44 <johnw> so, how do I read back 1 of those objects?
12:10:00 <johnw> i presume I have a table which says which of the X files I need to download in order to reassemble the bytes for that object?
12:10:04 <aristid> you also store a list of objects in the same store
12:10:10 <aristid> a list of blocks i mean
12:10:16 <aristid> and that list of blocks is the file
12:10:26 <johnw> i see, mapping blocks to "block containers"
12:10:35 <johnw> and a file is just a group of blocks
12:10:40 <johnw> (a git object)
12:10:42 <aristid> something like that
12:10:56 <johnw> this way I get fairly fine-grained deduplication, without having to download too much extra data
12:11:16 <aristid> yes, and you can cache things locally
12:11:28 <johnw> you mean, the block list?
12:11:42 <aristid> and the individual blocks
12:11:53 <johnw> for my purposes, I cannot cache
12:11:54 <aristid> they are identified by their SHA1 or so anyways
12:12:02 <johnw> I'm using S3 because it's the only storage I have which isn't ephemeral
12:12:16 <aristid> a cache CAN use ephemeral storage quite easily
12:12:16 <johnw> but I could store the block list in an SQL table
12:12:17 <aristid> it's a cache
12:12:24 <johnw> i see what you mean
12:12:37 <johnw> for as long as the cache remains viable, use it to avoid re-getting the same block
12:12:40 <aristid> if you don't want to use ephemeral storage for cache, you don't have to cache
12:12:44 <johnw> this sounds very cool
12:12:46 <johnw> you've sold me
12:12:51 <aristid> lol
12:12:56 <aristid> tell me how well it works!
12:13:06 <johnw> no, this sounds very doable, and not very complicated
12:13:14 <aristid> maybe there are some hidden problems with this scheme, as i've only tried it in my brain
12:13:32 <johnw> this sort of thing goes on our "low-hanging fruit list", for when we discover we could use such an optimization
12:13:40 <aristid> heh.
12:13:55 <johnw> i'm going to copy this conversation into my notes
12:15:38 <johnw> aristid: https://github.com/fpco/gitlib/issues/10
12:17:17 <davorak> quchen++
12:17:39 <aristid> johnw: ok, i'm glad you found this interesting
12:18:07 <johnw> yes, rather
12:18:09 <davorak> preflex: quchen++
12:19:06 <johnw> did quchen say something I didn't see?
12:25:20 <twomashi> Stack space overflow
12:25:41 <twomashi> could mapM be to blame?
12:25:54 <johnw> twomashi: it all depends on what mapM is doing
12:26:32 <twomashi> liftM concat (mapM stateFunc myList)
12:26:49 <twomashi> (MonadState)
12:27:02 <johnw> well, now it depends on how myList is built, and what stateFunc does :)
12:27:24 <johnw> :t liftM concat
12:27:26 <lambdabot> Monad m => m [[a]] -> m [a]
12:27:35 <twomashi> concatMapM basically
12:27:41 <johnw> :t fmap sequence
12:27:42 <lambdabot> (Monad m, Functor f) => f [m a] -> f (m [a])
12:28:08 <twomashi> stateFunc is not doing anything huge at all. It takes a data record and returns a (small) list
12:28:10 <johnw> :t fmap join
12:28:12 <lambdabot> (Monad m, Functor f) => f (m (m a)) -> f (m a)
12:28:26 <johnw> which is identical to liftM concat for lists...
12:28:37 <johnw> as in, liftM=fmap and join=concat :)
12:29:23 <johnw> twomashi: can you @hpaste some code?
12:29:26 <arkeet> I'm trying to compile frag and GHC is using all of my memory building the BSP module.
12:29:35 <twomashi> johnw: sure
12:29:43 <sproingie> frag is a beast
12:30:05 <parcs> twomashi: yes mapM can be to blame
12:30:22 <hpaste> “Anonymous Coward” pasted “Stack space overflow” at http://hpaste.org/84385
12:30:29 <twomashi> ^^ thats me
12:31:44 * arkeet watches his swap space fill up
12:32:20 <mcstar> kill it while you can!!
12:32:29 <johnw> twomashi: I'd use a Data.Map.Strict, and I'm your data type Map.Map !Label !Int, and State !NodeIndex
12:32:52 <johnw> otherwise, mixElems will generate a number of sizable thunks
12:33:30 <twomashi> aah… so it could be too many thunks
12:33:31 <johnw> you may need strict state as well
12:33:36 <twomashi> not neccesary too long
12:33:54 <twomashi> I'm doing batch ops on a fairly large dataset, it would make sense for me to be strict when possible no?
12:34:11 <johnw> unless there are expensive-to-compute results that you may not need
12:34:14 <twomashi> i suppose except if I need to stream information for some reason
12:34:17 <arkeet> yep, it ate up 7GB of VM and it still couldn't do it.
12:34:26 <twomashi> arkeet: hello
12:34:28 <arkeet> hi
12:34:31 <twomashi> been doing that myself recently :)
12:34:37 <arkeet> :)
12:34:44 <arkeet> but this was GHC eating up memory.
12:35:11 <twomashi> ah, in my case it was my own naivete, basically!
12:35:21 <johnw> twomashi: well, don't be so sure I'm right yet
12:35:26 <johnw> but what I suggested is cheap to try
12:35:36 <twomashi> yea sure we can run this memory exponential algo on this large dataset!
12:35:50 <johnw> also, why are you using State instead of doing this is a fold?
12:35:54 <twomashi> johnw: I will try these things :)
12:36:30 <twomashi> johnw: Yes, you mean pass (NodeIndex, [elements]) in a fold right?
12:36:35 <arkeet> lazy Map is strict in the keys already.
12:36:39 <johnw> yes
12:37:06 <johnw> it seems you are using State to accumulate some values as you process the data set
12:37:21 <twomashi> because once it had occurred to me I'd already invested half an hour into writing the State based code… xl
12:37:24 <johnw> this essentially describes the behavior of a foldM
12:37:35 <johnw> ah :)
12:37:43 <twomashi> but I will do this.
12:37:51 <twomashi> thanks, I'll try the bangs now..
12:38:13 <johnw> how large is a Mix?
12:38:45 <arkeet> :t \kv -> at k ?= v
12:38:47 <lambdabot> (MonadState s m, At s, IxValue s ~ Expr, Index s ~ Expr) => t -> m ()
12:38:49 <arkeet> :t \k v -> at k ?= v
12:38:50 <lambdabot> (MonadState s m, At s) => Index s -> IxValue s -> m ()
12:38:55 <arkeet> lens =)
12:39:12 <armlesshobo> why would one want to use "lift"?
12:39:21 <arkeet> as opposed to what?
12:39:34 <arkeet> :t lift
12:39:34 <johnw> armlesshobo: to lift a function into the next monad down in a transformer stack
12:39:36 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
12:39:37 <edwardk> armlesshobo: try calling putStrLn down 4 levels in a monad transformer stack
12:39:50 <edwardk> armlesshobo: or even just one level down in a state monad
12:40:15 <edwardk> armlesshobo: or working with the inner state if you are misguided enough to want to use StateT s (State t) a
12:40:30 <arkeet> edwardk: that sounds like a case for liftIO, not lift.
12:40:32 <twomashi> johnw: lets say about 10 smallish URLs in ByteString form.
12:40:34 <armlesshobo> oh! i understand now.
12:40:40 <armlesshobo> johnw, edwardk: thank you :)
12:40:45 <edwardk> it comes up a lot when you didn't think to write a function in such a way that it can be lifted over a monad transformer stack
12:40:57 <johnw> twomashi: and how many are in this list?
12:40:58 <edwardk> arkeet: sure, both admit similar usecases
12:41:02 <arkeet> sure.
12:41:09 <edwardk> but point taken
12:41:11 <twomashi> johnw: about 60000
12:41:16 <ExternalReality> I am having a bit of a problem when using Data.Cereal -- you I have the constraint (Serialize a) on a method and yet when I call something like (encode $ (Just item :: Maybe a)) I get a type error.
12:41:26 <johnw> ok, here's what you need to do
12:41:49 <johnw> when you mkGraph nodes edges, you needs for nodes and edges to be fully evaluated... unless of course there is some reason you want to defer computation in any of them
12:41:57 <arkeet> ExternalReality: you're saying that Just item has type forall a. Maybe a
12:42:15 <arkeet> ExternalReality: does it work if you remove the type annotation?
12:42:19 <johnw> because I'm betting that mkGraph is evaluating the *spine* of the nodes and edges list, but it is not evaluating each node and edge
12:43:05 <johnw> thus, you are creating a graph that has many thunks in it, each of which holds onto the original data you passed in.  In effect, the resulting graph is as large as the input list, plus a set of recipes for how to begin the work of computing the edges and nodes
12:43:28 <ExternalReality> arkeet: If I remove the annotation GHC tells me I'm being ambiguous
12:43:38 <twomashi> johnw: so i could use a lazy foldl and strictness in data constructors
12:43:44 <arkeet> ExternalReality: would you like to paste some code?
12:43:55 <johnw> well, the very first thing  you could do to test thi stheory
12:44:16 <johnw> is import Control.DeepSeq and do: nodes `deepseq` edges `deepseq` mkGraph nodes edges
12:44:24 <ExternalReality> sure thing
12:44:31 <johnw> if that fixes your problem, then you think more about how to do it correctly with seq and strictness annotations
12:44:45 <johnw> but I bet you adding those bangs I mentioned above will help a great deal
12:45:06 <cdk> @pl \e -> f >> print e
12:45:06 <lambdabot> (f >>) . print
12:45:17 <johnw> now, the deepseq trick may not be enough, because it may be blowing stack before you even get to the mkGraph call
12:45:39 <johnw> so maybe don't even bother with that
12:45:44 <johnw> try making your data types strict first
12:45:55 <twomashi> johnw: GHC doesnt like them:Unexpected strictness annotation
12:46:11 <johnw> you can't put them everywhere
12:46:14 <hpaste> ExternalReality pasted “Ambiguity” at http://hpaste.org/84387
12:46:15 <johnw> which type was this for?
12:46:18 <twomashi> I had to remove all of them :(
12:46:29 <johnw> oh
12:46:31 <twomashi> type BuilderState = State !NodeIndex — rejected
12:46:33 <johnw> there are type synonyms
12:46:40 <johnw> yeah, they only work for data types
12:46:57 <structuralist> So… I'm playing around and trying to get (>>=) (bind) from (>>=) (Kleisli composition)… is there a less confusing way to get it than (>>=) = (($ ()) .) . (>=>) . const ?
12:47:07 <johnw> data NodeIndex = NodeIndex (Map.Map !Label !Int)
12:47:10 <twomashi> so I should use seq against some Map keys to force eval?
12:47:10 <structuralist> er second >>= should be >=>
12:47:27 <johnw> twomashi: yes, but realize that seq is shallow, it only evaluates to WHNF
12:47:42 <structuralist> looking at (($ ()) .) (i.e. apply () to result) in particular
12:48:33 <ExternalReality> akreet: I can't see what I am doing wrong. Maybe a is and instance of serialize as long as a is.
12:48:42 <arkeet> ExternalReality: but it doesn't know what a is.
12:49:06 <arkeet> well
12:49:10 <arkeet> could you paste the error too?
12:49:12 <ion> structuralist: How did you come up with such a contrived way to write it? :-P f =<< a = (f <=< const a) ()
12:49:28 <twomashi> johnw: data NodeIndex = NodeIndex (!Map.Map !Label !Int) — rejects bang on Label
12:49:34 <monoidal> @pl \x y -> ((const x) >=> y) ()
12:49:34 <lambdabot> flip flip () . (>=>) . const
12:49:35 <structuralist> ion: it's not contrived! it was the first thing I wrote down :P
12:49:44 <twomashi> though thats fine, surely, label will be evaulated upon the insert.
12:49:47 <mzero> okay, I haz the dumbs today.....    seems like I should have a better way to write:      actionWithMaybeResult >>= maybe (return Nothing) action2WithMaybeResult
12:49:48 <monoidal> structuralist: ^
12:49:49 <swineflu> Anyone here work with haskell professionally?
12:50:01 <arkeet> mzero: MaybeT
12:50:06 <chrisirc> How can I enter the debugger from a ghc-compiled binary?
12:50:09 <johnw> twomashi: ok, I'm no expert at using strict annotations yet.  I will have to leave you to others here, as I'm heading out to dinner now
12:50:16 <ion> structuralist: Try using more points the next time.
12:50:18 <mzero> er, the actions are in IO
12:50:23 <twomashi> johnw: cool, thanks for your help !
12:50:26 <arkeet> mzero: yes, MaybeT IO
12:50:28 <cariveri> Hi. counldn't match expected "IO ()"  with actual a0 -> m0 a0 of "fct _ _ = do return". whats going on?
12:50:31 <geekosaur> chrisirc, which debugger?
12:50:37 <arkeet> MaybeT actionWithMaybeResult >>= MaybeT action2WithMaybeResult
12:50:39 <arkeet> :t MaybeT
12:50:40 <mzero> ah... see I DO have the dumbs today!
12:50:40 <danr> chrisirc: you can't, ghci demands it to be interpreted
12:50:41 <lambdabot> Not in scope: data constructor `MaybeT'
12:50:42 <hpaste> “Anonymous Coward” annotated “Ambiguity” with “Ambiguity (annotation)” at http://hpaste.org/84387#a84389
12:50:43 <johnw> anything you can do with strictness annotations, you can do using seq when you create those values
12:50:44 <beaky> hello
12:50:48 <Lethalman> swineflu, yes (not me)
12:51:00 <arkeet> :t Control.Monad.Trans.Maybe.MaybeT
12:51:02 <lambdabot> m (Maybe a) -> Control.Monad.Trans.Maybe.MaybeT m a
12:51:07 <hpaste> beaky pasted “Animal List” at http://hpaste.org/84390
12:51:11 <arkeet> errr
12:51:14 <arkeet> what I wrote isn't quite it.
12:51:15 <johnw> twomashi: but rather than get this code to work, you may just want to use a fold :)
12:51:16 <arkeet> but whatever.
12:51:27 <beaky> http://hpaste.org/84390 why does my code fail to compile even though all of the members of the list are instances of the Animal class?
12:51:29 <twomashi> johnw: going to try that.
12:51:30 <chrisirc> danr, aha, ok, thanks
12:51:31 <swineflu> Lethalman: I'm just wondering how wide spread its use is in industry
12:51:32 <geekosaur> cariveri, need to see rather more than that snipped (also, "do return" is redundant, plus "return" is not a control flow command, it is an expression which requires a parameter)
12:51:47 <arkeet> ExternalReality: oh see, the problem is in the encode Nothing line.
12:51:56 <arkeet> it doesn't know which a to use for Nothing :: Maybe a
12:51:59 <structuralist> `flip flip ()' is harder for me to understand than (($ ()) .)
12:52:07 <danr> cariveri: you probably need an argument to return (what to return)
12:52:37 <monoidal> @pl flip (\f -> (id>=>f))
12:52:38 <lambdabot> flip (id >=>)
12:52:38 * hackagebot universe 0.1 - Classes for types where we know all the values  http://hackage.haskell.org/package/universe-0.1 (DanielWagner)
12:52:41 <monoidal> structuralist: ^
12:52:51 <cdk> beaky: even though they are all instances of Animal, they dont have the same type and the standard list type is homogeneous in Haskell
12:52:59 <arkeet> ExternalReality: so you need to fix the type of Nothing
12:53:15 <ion> Both flip flip () and (($ ()) .) are bad.
12:53:28 <geekosaur> beaky, you did not include a full error mesage, but I must point out that typeclasses are not OOP
12:53:31 <arkeet> perhaps Maybe (). perhaps Maybe a' (with ScopedTypeVariables)
12:53:40 <ExternalReality> akreet: The type annotation (Nothing :: Maybe a) does not seem to give clue enough to GHC
12:53:45 <johnw> edwardk: see that universe package?
12:53:51 <cariveri> danr: expected is IO () . so nothing should be returned. I just want to pattern match the call of a function as a default of doing nothing.
12:54:00 <arkeet> ExternalReality: well yes, a is a universally quantified type variable there.
12:54:08 <arkeet> ExternalReality: it's the same as writing no annotation at all
12:54:09 <edwardk> johnw: i did
12:54:20 <arkeet> ExternalReality: you'll have to pin down a specific type for a.
12:54:21 <johnw> he took me up on a suggestion to use your representable-functors
12:54:46 <mzero> beaky - or in otherwords, animalList :: Animal a => [a] doesn't mean "a list of stuff so long as each of them is an Animal"....
12:54:54 <edwardk> ah nice
12:54:55 <structuralist> ion: couldn't someone directly read off "(($ ()) .) f" as "apply () to the result of f"?
12:54:58 <beaky> oh
12:55:02 <mzero> it means "a list of things of type a --- where a, the type of all of them, is an Animal"
12:55:03 <cariveri> geekosaur: It should do nothing. how would I do it without the return ? its a default fct _ _ = do DoNothing
12:55:06 <beaky> how do I get an object-oriented list?
12:55:10 <mzero> you don't
12:55:12 <structuralist> no intuition for flip flip though
12:55:13 <beaky> :(
12:55:22 <geekosaur> cariveri, it expects IO (), you ```return ()```
12:55:23 <mzero> you define    data Animal = Cat | Rat | Dog
12:55:26 <arkeet> :t flip flip
12:55:28 <lambdabot> b -> (a -> b -> c) -> a -> c
12:55:29 <mzero> and you're done!
12:55:32 <beaky> ah
12:55:39 <geekosaur> beaky, you *can* do OOP in Haskell but typeclasses are not the way to do it
12:55:44 <mzero> there are ways to do what you were trying....
12:55:46 <ion> structuralist: Sure, if you’re in the writing things in a contrived way competition.
12:55:52 <beaky> but that's a bit different from the OOP way of achieving ad-hoc polymorphism
12:55:57 <mzero> but they are not usually what you want to do
12:56:04 <beaky> ah
12:56:04 <structuralist> ok how would you write flip flip () then
12:56:05 <jamiltron_>  /join #libgdx
12:56:06 <geekosaur> you might want to look up OOHaskell, which uses HList --- but this is not something trivial. haskell is functional, not OO
12:56:06 <mzero> (and they aren't standard Haskell - they are GHC extensions)
12:56:30 <geekosaur> you would do better learning how to program functionally instead of trying to force Haskell to be an OO language
12:56:39 <monoidal> structuralist: flip (id>=>) is IMO the best way to write (>>=)
12:56:48 <beaky> I wanna make my animals say different voices when I apply a "voice" function on them.. is the only way is the use higher-order functions?
12:57:04 <monoidal> structuralist: it's very intuitive that when you kleisli-compose with identity you get monadic bind
12:57:06 <ion> structuralist: See the expression before @pl ruined it.
12:57:17 <arkeet> beaky: data Animal = Animal { voice :: String, ... }
12:57:39 <mzero> or
12:57:40 <cariveri> geekosaur: ok "return ()" did it. thanks.
12:57:41 <mzero> easier
12:57:41 <ExternalReality> akreet: I'd like 'a' to remain polymorphic
12:57:56 <arkeet> ExternalReality: no
12:58:05 <mzero>     voice Cat = "meow"      voice Dog = "woof"
12:58:05 <ion> Functional and OO are not the opposites of each other.
12:58:07 <mzero> etc....
12:58:15 <beaky> a
12:58:22 <arkeet> ExternalReality: ok here
12:58:55 <mzero> you only do     data Animal = Animal { voice :: String ... }    if you want each individual value to have it's own voice
12:59:03 <geekosaur> ion, that's struictly true in a vacuum but does not make Haskell speak OO paradigms natively
12:59:06 <hpaste> arkeet annotated “Ambiguity” with “Ambiguity (annotation)” at http://hpaste.org/84387#a84392
12:59:06 <structuralist> monoidal: whoah I was really confused how flip (id (>=>)) could be different from flip (>=>) for a second but yeah now it makes sense
12:59:13 <beaky> what if I want to define different data representations of my animals? any way to do this without having to use typeclasses or some language extensions?
12:59:15 <arkeet> ExternalReality: this is the morally correct way of doing it
12:59:24 <monoidal>  structuralist: it's section, like (2+)
12:59:29 <structuralist> yep, got it now
12:59:37 <timtom> @type (>=>)
12:59:38 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
12:59:40 <arkeet> ExternalReality: in reality, it doesn't matter what type you pick for Nothing, since they all get encoded to the single byte 0
12:59:56 <mzero> no no - easy         data Animal = Cat String | Dog Int | Insect Int Int Int
12:59:59 <elliott> structuralist: they can't be different
13:00:03 <elliott> but (id >=>) isn't (id (>=>))
13:00:03 <mzero> see - each constructor can have different values
13:00:07 <arkeet> or that
13:00:12 <timtom> @type (id >=>)
13:00:15 <lambdabot> Monad m => (b -> m c) -> m b -> m c
13:00:20 <ExternalReality> akreet: Yes, I realize that fact
13:00:35 <beaky> hmm I guess I need existentials :D
13:00:39 <arkeet> ExternalReality: in any case you have to pick something.
13:00:40 <arkeet> beaky: no.
13:00:49 <arkeet> beaky: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ and no.
13:00:55 <beaky> ah thanks
13:01:00 <mzero> or, beaky         data Animal = Cat { catBreed :: String } | Dog { dogSize :: Int } | Insect {{ insectLegs :: Int, insectFeelers :: Int }
13:01:02 <DanBurton> @type ((id >=>), =<<)
13:01:03 <ExternalReality> akreet: why can I not pick 'a'?
13:01:03 <lambdabot> parse error on input `)'
13:01:05 <structuralist> elliott: yeah I got it
13:01:09 <mzero> you don't need existentials for most things
13:01:10 <yitz> mzero: i'm sure there's some fancier way to write it, but i'd sure rather see what you wrote when i read your code
13:01:17 <DanBurton> @type ((id >=>), (=<<))
13:01:18 <lambdabot> (Monad m1, Monad m) => ((b -> m c) -> m b -> m c, (a -> m1 b1) -> m1 a -> m1 b1)
13:01:23 <arkeet> ExternalReality: a is an unrestricted type variable
13:01:31 <shachaf> I don't know of any way to get the vtable-style optimizations that existentials give you without existentials.
13:01:38 <mzero> yitz - yeah, MaybeT was just as verbose - only useful if I had like a huge chain of them
13:01:38 <shachaf> Note that this is unrelated to type classes.
13:02:17 <arkeet> ExternalReality: when you write Maybe a, that's really forall a. Maybe a
13:02:39 * hackagebot transformers-compat 0.1.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/transformers-compat-0.1.1 (EdwardKmett)
13:02:58 <elliott> edwardk: good description
13:03:00 <mzero> has a 9k line haskell program with only one existential in it....
13:03:01 <shachaf> By which I mean: (exists a. (a, (a -> Int, a -> Char, a -> Bool, ...)) can share the entire dictionary. (Int, Char, Bool, ...) takes more space the more elements you have in the tuple.
13:03:03 <beaky> what if I wanted to represent employee data in haskell? e.g. data Employee = Hourly { rate :: Double } | Salaried { annualPay :: Double, months :: Int } | Commissioned... converting between the value types might be difficult to do :(
13:03:07 <edwardk> hahahahaha
13:03:21 <beaky>                  you have in the tuple.
13:03:25 <beaky> oops misclick
13:03:32 <DanBurton> edwardk: ah the things we do for backwards compatibility
13:03:37 <dmwit> johnw: hi =)
13:03:46 <arkeet> hahahaha
13:04:03 <DanBurton> yeah looks like the synopsis got borked on that one
13:04:10 <mzero> beaky - what you wrote looks fine for   data EmplyeePay = .....
13:04:15 <mzero> I think that would work easily
13:04:30 <mzero> and writing it this way ensures that everywhere you deail with EmployeePay, you cover all three options
13:04:36 <beaky> ah
13:04:48 <structuralist> monoidal: okay why is it intuitive?
13:04:52 <ExternalReality> arkeet: ok, I think I got it. Thx
13:05:30 <dmwit> This is so fun.
13:05:30 <mzero> you'd probably factor out EmployeePay from other common Employee data     so      data Employee = Employee { empBoss :: Maybe Employee, empPay :: EmployeePay, empName :: String, empFacelessIdentifier :: Integer }
13:05:37 <beaky> in C++ I would make it an existential or something (then suffer thanks to using inheritance)
13:05:54 <dmwit>  > (&&) < (||)
13:05:55 <dmwit> True
13:05:57 <structuralist> monoidal: the intuition behind ( ($ ()) . ) . (>=>) . const was that you take the type signature of (>=>) and set a = ()
13:06:03 <beaky> oh right
13:06:05 <monoidal> structuralist: kleisli composition takes a -> m b and b -> m c and gives a -> m c. putting identity this means a = m b and then it becomes (b -> m c) -> (m b -> m c), i.e. type of bind
13:06:10 <structuralist> @type (>=>)
13:06:12 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
13:06:34 <monoidal> structuralist: btw you can also avoid flip and use (<=<id)
13:06:35 <structuralist> monoidal: right I can see how the type works out but it seems like magic
13:06:51 <arkeet> has anyone written a monad tutorial that emphasizes return and >=> (instead of >>=)?
13:06:51 <monoidal> structuralist: it's just like (>>=id) gives join
13:07:07 <edwardk> arkeet: i've answered a lot of stack overflow questions that way
13:07:14 <structuralist> arkeet: definitely yes but I don't remember where
13:07:15 <arkeet> :)
13:07:26 <arkeet> I think it's a good way to think about them.
13:07:35 <beaky> I lvoe existentials
13:07:39 * hackagebot transformers-compat 0.1.1.1 - A small compatibility shim exposing the new types from transformers 0.3 to older Haskell platforms.  http://hackage.haskell.org/package/transformers-compat-0.1.1.1 (EdwardKmett)
13:07:41 <arkeet> beaky: are they easy?
13:07:48 <monoidal> structuralist: there we have a function taking m a, a -> m b and putting a = m b means the function takes m (m b) and returns m b
13:07:59 <arkeet> edwardk: couldn't have overwritten 0.1.?
13:08:00 <arkeet> 0.1.1
13:08:11 <beaky> they are easy yes
13:08:15 <edwardk> can't overwrite on hackage
13:08:18 <arkeet> oh
13:08:32 <edwardk> or i'd have a lot fewer versions out there ;)
13:08:36 <arkeet> lol
13:08:50 <monoidal> structuralist: (>=>) composes two functions and then uses join. if one of the functions is id, then it takes the function and uses join - which effectively is bind
13:08:56 <Taneb> As someone who mainly uploads when half asleep, I can sympathise, edwardk
13:09:08 <edwardk> Taneb: heh
13:09:20 <arkeet> I really like how kleisli arrows look for State.
13:09:25 <arkeet> (s,a) -> (s,b)
13:09:31 <monoidal> structuralist: do you know typeclassopedia? i got a lot of intuition from there and experiments
13:10:04 <structuralist> monoidal: I see how the plumbing works, now I'm looking for more "semantic" motivation. yeah I've seen typeclassopedia
13:10:04 <Taneb> family-tree-0.3.0.0 had requirement containers > 0.42 & < 0.6
13:10:48 <structuralist> the intuition I have is that going from (>=>) to (>>=) is like going from pointfree to pointful programming
13:10:59 <structuralist> function composition to function application
13:11:08 <structuralist> and the bridge is A isomorphic to () -> A
13:11:20 <shachaf> There isn't anything especially "pointful" about function application.
13:11:42 <DanBurton> when you apply a function, you specify a "point"
13:11:45 <arkeet> :t \() -> ?m >=> ?f
13:11:46 <lambdabot> (?m::a -> m b, ?f::b -> m c, Monad m) => () -> a -> m c
13:11:50 <arkeet> uhg
13:11:53 <arkeet> :t (\() -> ?m) >=> ?f
13:11:55 <lambdabot> (?m::m b, ?f::b -> m c, Monad m) => () -> m c
13:12:01 <arkeet> :t \() -> ?m >>= ?f
13:12:02 <lambdabot> (?m::m a, ?f::a -> m b, Monad m) => () -> m b
13:12:21 <structuralist> what does the "?" do there?
13:12:28 <dmwit> ?wiki implicit arguments
13:12:28 <lambdabot> http://www.haskell.org/haskellwiki/implicit_arguments
13:12:29 <shachaf> DanBurton: For example in "(.) f g" f and g are points?
13:12:39 <DanBurton> shachaf: yep
13:12:41 <dmwit> structuralist: (that was at you)
13:12:44 <shachaf> I don't think that's what "point" means.
13:12:52 <Cale> Sure it does
13:12:53 <DanBurton> Then what does "point" mean?
13:12:53 <dmwit> um
13:12:56 <arkeet> shachaf: sure it does.
13:12:58 <dmwit> Apparently there is no wiki page for this.
13:12:59 <structuralist> dmwit: "There is currently no text in this page"
13:13:02 <hiptobecubic> that wiki page is empty
13:13:07 * dmwit apologizes profusely
13:13:08 <arkeet> structuralist: implicit parameters
13:13:10 <Cale> This term comes from topology
13:13:12 <shachaf> A named argument, as in a lambda abstraction.
13:13:20 <Cale> A point is an element of a space (which is a set)
13:13:21 <monoidal> structuralist: personally I like to think x >>= f as join (fmap f x). now you put f = id and fmap id disappears
13:13:25 <Cale> Or in our case, a type
13:13:36 <arkeet> structuralist: except I'm not really using it the way it was intended. I'm using them for holes.
13:13:57 <dmwit> structuralist: http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters
13:14:04 <DanBurton> shachaf: I think of points not as the named arguments, but as the applied arguments
13:14:04 <dmwit> hiptobecubic: you, too, if you're interested
13:14:05 <monoidal> structuralist: there's analogous identity for >=> although I'm too lazy now to figure it
13:14:19 <shachaf> DanBurton: OK, then there is almost no point-free code.
13:14:32 <arkeet> f >=> g = join (fmap g f)
13:14:35 <Aune> Hello, I want to write a datatype to represent some celestial bodies. I want it to have a logical hierarchy akin to this: http://hpaste.org/84393
13:14:42 <arkeet> :t \f g -> join (fmap g f)
13:14:42 <hiptobecubic> dmwit, just found it as well
13:14:43 <lambdabot> (Monad m, Functor m) => m a1 -> (a1 -> m a) -> m a
13:14:45 <Aune> how would I go about doing that?
13:14:46 <arkeet> errr
13:14:48 <shachaf> arkeet: That looks like >>=
13:14:48 <arkeet> :t \f g -> join (fmap g . f)
13:14:49 <Cale> The thing which is points-free about points-free style is that you're defining functions without mentioning a generic point that's being acted upon, but the parts of the expressions are still likely points in respective spaces.
13:14:49 <lambdabot> (Monad m, Functor m) => m (m a1) -> (a1 -> a) -> m a
13:14:52 <arkeet> err
13:14:53 <arkeet> :p
13:15:18 <arkeet> @src (>=>)
13:15:18 <lambdabot> Source not found. Maybe you made a typo?
13:15:22 <Cale> (i.e. you don't use lambdas)
13:15:32 <DanBurton> shachaf: well yes and no. Going back to "(.) f g", if you think of "." as "composition" rather than "a function", then "f . g" is pointfree.
13:15:33 <dmwit> Aune: The simplest thing is to just make them different types.
13:15:35 <arkeet> :t \f g -> join . fmap g . f
13:15:36 <lambdabot> (Monad m, Functor m, Functor f) => f (m a1) -> (a1 -> m a) -> f (m a)
13:15:43 <arkeet> caaaaaale!
13:15:55 <Cale> What?
13:15:59 <arkeet> :t let (.) = (Prelude..) in \f g -> join . fmap g . f
13:16:00 <lambdabot> (Monad m, Functor m) => (a -> m a2) -> (a2 -> m a1) -> a -> m a1
13:16:00 <arkeet> this again.
13:16:01 <Aune> dmwit, I could do that, but is there a way to make them the same type?
13:16:01 <shachaf> DanBurton: This sounds like a boring argument now.
13:16:06 <dmwit> Aune: data Moon = Moon Name; data Planet = Planet Name [Moon]; data Sun = Sun Name [Planet]; data StarCluster = StarCluster Name [Sun]
13:16:09 <DanBurton> shachaf: I agree.
13:16:20 <hiptobecubic> dmwit, i don't see what it *does*
13:16:27 <arkeet> Cale: you should put (.) back to the Prelude version.
13:16:39 <dmwit> Aune: Yes, but you lose the guarantees that you seem to be asking for in that paste.
13:16:44 <DanBurton> @type (.)
13:16:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:16:56 <structuralist> … whaaaat
13:17:04 <DanBurton> why not the category version?
13:17:10 <structuralist> ^ yeah
13:17:11 <hiptobecubic> (+2) . Just 4
13:17:15 <hiptobecubic> > (+2) . Just 4
13:17:15 <dmwit> hiptobecubic: It lets your function have implicit, named arguments which can be bound (by name) far away from the call-site.
13:17:17 <lambdabot>   Just 6
13:17:36 <arkeet> > (+2) <$> Just 4
13:17:38 <lambdabot>   Just 6
13:17:38 <Aune> dmwit, ok, I'll go with the separate datatype solution then
13:17:45 <beaky> @pl \a b c -> c b c a c a a
13:17:45 <lambdabot> flip =<< (flip .) . (flip =<< (flip .) . flip flip id . (ap .) . flip (flip . join . flip id))
13:17:54 <arkeet> :t let (.) = (Control.Category..) in \f g -> join . fmap g . f
13:17:56 <lambdabot> (Monad m, Functor m) => (a -> m a2) -> (a2 -> m a1) -> a -> m a1
13:17:57 <hiptobecubic> dmwit, type constraints on free variables?
13:17:58 <DanBurton> beaky: wat
13:18:18 <dmwit> hiptobecubic: ...sort of, I guess?
13:18:19 <fizbin> :t (Control.Category..)
13:18:21 <lambdabot> Control.Category.Category cat => cat b c -> cat a b -> cat a c
13:18:23 <arkeet> ok, maybe the Category one is acceptable.
13:18:38 <hiptobecubic> dmwit, how is it not that?
13:18:40 <arkeet> but how many actual categories do we have available in lambdabot?
13:18:49 <monoidal> :i Category
13:19:00 <arkeet> @instances Category
13:19:00 <lambdabot> Couldn't find class `Category'. Try @instances-importing
13:19:07 <arkeet> @instances-importing
13:19:08 <lambdabot> Plugin `instances' failed with: Prelude.last: empty list
13:19:10 <dmwit> hiptobecubic: Well, "that" didn't really make sense to me.
13:19:17 <shachaf> @instances-import Control.Category Category
13:19:17 <arkeet> help
13:19:18 <lambdabot> (->), Kleisli m
13:19:23 <arkeet> yeah
13:19:24 <dmwit> So I can't be sure I'm interpreting it the way it was meant to be interpreted.
13:19:29 <shachaf> @instances-import Control.Category Control.Lens Category
13:19:30 <lambdabot> (->), Indexed i, Kleisli m
13:19:39 <shachaf> @instances-import Control.Category Control.Lens Control.Lens.Internal Category
13:19:40 <djahandarie> Kleisli is fun.
13:19:40 <lambdabot> (->), Indexed i, Kleisli m
13:19:47 <shachaf> @instances-import Control.Category Control.Lens Data.Profunctor Category
13:19:48 <hiptobecubic> dmwit, in the example they use  `sort = sortBy cmp`, but cmp is not defined anywhere we can see
13:19:48 <lambdabot> (->), Indexed i, Kleisli m, WrappedArrow p
13:20:08 <dmwit> hiptobecubic: Well, sort = sortBy ?cmp
13:20:08 <dmwit> =)
13:20:11 <hiptobecubic> dmwit, i call cmp a free variable because it's not bound in sort
13:20:19 <hiptobecubic> yes, ?cmp  :)
13:20:28 <hiptobecubic> bound by* sort
13:21:17 <dmwit> Depends how you define binding. You could say that the type given to sort indicates that it does indeed bind ?cmp. =)
13:22:14 <dmwit> Anyway, I think that what you said is a reasonable interpretation of what's happening.
13:22:25 <hiptobecubic> dmwit, binds it to what? It's just a predicate
13:22:54 <dmwit> As always, you can't tell what it's bound to until you pass that function an argument.
13:23:11 <mcstar> it is passed implicitely
13:23:13 <hiptobecubic> this seems like a really useless extension. At least by this example. You'll have to define cmp somewhere else anyway and it will have a type already.
13:23:13 <dmwit> In this case you pass the argument by giving it the name ?cmp locally.
13:24:21 <dmwit> (For comparison: in "\cmp -> sortBy cmp", what is "cmp" bound to? "cmp" certainly wouldn't be considered free there, even though you don't know what it's bound to until the lambda gets applied to an argument.)
13:24:40 <hiptobecubic> sure, but then it's just a normal argument. Why would you want it implicit?
13:24:57 <dmwit> I don't know. I've never wanted this extension as far as I can recall.
13:25:01 <mcstar> because different environments can lead to different cmp functions
13:25:14 <dmwit> "Why is this good?" is a much harder question than "What does this do?". =)
13:25:15 <ab9rf> i too have not seen the merits of implicit arguments
13:25:16 <mcstar> the calling site determines which function gets called
13:25:17 <VF2> could haskell be used for soft realtime or is it to unpreditcable
13:25:37 <ab9rf> VF2: there are issues with the garbage collector
13:25:41 <hiptobecubic> mcstar, this is standard haskell practice though. You just pass cmp in.
13:25:50 <dmwit> What does soft realtime even mean?
13:25:55 <mcstar> i know it should be passed
13:25:56 <ab9rf> VF2: but that can probably be worked with
13:26:01 <DanBurton> VF2: what exactly do you mean by "used for soft realtime"
13:26:01 <mcstar> i dont like implicit arguments either
13:26:17 <mcstar> (well, havent seen any in fact, except ghc's docs)
13:26:23 <hiptobecubic> dmwit, things which are expected to be ~ realtime but not with hard limits.
13:26:28 <DanBurton> I like Scala's type-driven implicit arguments
13:26:29 <hiptobecubic> messenging for example
13:26:36 <DanBurton> not name-driven implicit arguments
13:26:45 <hiptobecubic> as opposed to hardware control on a fighter jet
13:26:49 <ab9rf> DanBurton: i need to look at scala more, but not right now
13:26:52 <mcstar> DanBurton: implicit dict passing?
13:26:52 <structuralist> Is there a special name for the kleisli identity morphism?
13:27:03 <mcstar> i read, scala can do it explicitely, and thats the power
13:27:03 <DanBurton> mcstar: yeah basically
13:27:18 <structuralist> oh, return duh
13:27:24 <structuralist> disregard
13:27:35 <DanBurton> indeed, that's what's nice. Dicts are first class and you can explicitly pass in the one you want.
13:28:03 <dmwit> hiptobecubic: I don't understand what that means, either.
13:29:20 <hiptobecubic> dmwit, it's the difference between "the data took to long and now we have total system failure" and "the data too long which was annoying"
13:29:41 <sproingie> i accidentally the data too long
13:29:42 <hiptobecubic> "Thus, the goal of a hard real-time system is to ensure that all deadlines are met, but for soft real-time systems the goal becomes meeting a certain subset of deadlines in order to optimize some application specific criteria."
13:29:49 <hiptobecubic> too* :)
13:30:04 <trescenzi> quick question: can you use or in a case statement?
13:30:07 <dmwit> Hard real-time I understand. You make a guarantee.
13:30:15 <tgeeky> dmwit: the "1202" error on the lunar lander, which was indicative that the system was ignoring computation on less important tasks because of system overload, is an example of a soft realtime system.
13:30:19 <dmwit> Soft real-time I do not understand. There is no guarantee, so why bother saying "soft realtime"?
13:30:45 <geekosaur> trescenzi, I have to guess you want to share case patterns, and the answer is no
13:30:46 <hiptobecubic> dmwit, it's not about what you promise to do. It's about the consequences of failure to do them
13:30:56 <ab9rf> tgeeky: more a fail-robust system
13:31:05 <hiptobecubic> dmwit, if failing to do it on time means it's worthless and everything is boned, then that's hard realtime
13:31:18 <trescenzi> geekosaur: so you have to just have two different cases that do the same thing?
13:31:40 <hiptobecubic> if failing to do it on time sucks but doesn't kill everyone and it's probably a good idea to still do it, even though it's late, then that's soft
13:31:43 <ab9rf> tgeeky: as i recall that was because they left an instrument on that they should have turned off and it was still feeding telemtry into the computer that they didn't need
13:31:59 <geekosaur> or you can rephrase in terms of guards, which do support alternation. but note that you can also have case x of thing1 -> foo; thing2 -> foo; thing3 -> some other action where foo = ...
13:32:20 <ab9rf> tgeeky: and to think that my TV remote has more processing power than the apollo 13 LM
13:32:30 <sproingie> there are various degrees even of hard realtime ranging from "drop the frame" to "initiate emergency robot shutdown"
13:32:31 <trescenzi> geekosaur: alright thanks
13:33:04 <ab9rf> realtime systems tend to be fairly sui generis in dealing with such issues
13:33:19 <mcstar> 'dont kill the human, never kill the human!!!'
13:33:22 <ab9rf> it can range from "soldier on with best data" to "immediate abort"
13:33:38 <ab9rf> the 'right' decision depends on the application
13:34:29 <dmwit> What I'm trying to get at is that the question "Can Haskell be used for soft realtime?" is meaningless. You have to just ask about the thing you want to do instead of using a term so vague that there is no good criterion by which your question can be answered "yes" or "no" truthfully.
13:34:39 <ab9rf> i want to hit every person in the world who recommends either php or javascript as a first language
13:35:05 <tgeeky> ab9rf: yes, I concede. The 1201/1202 errors were about irrelevant data, not about time-sensitive data.
13:35:25 <sproingie> hell, shell script can be used for soft realtime
13:35:47 <sproingie> i have soft realtime deadlines in my data collection apps of five minutes
13:36:27 <ab9rf> i don't think there's a meaningful line between "soft" and "hard"
13:36:27 <mcstar> first language needs to be a shell language
13:36:31 <sproingie> "is haskell fast", and the answer is "hells yeah"
13:36:49 <ab9rf> in this case
13:36:59 <yitz> @faq can haskell be fast?
13:36:59 <lambdabot> The answer is: Yes! Haskell can do that.
13:37:12 <sproingie> @faq can haskell be slow?
13:37:12 <lambdabot> The answer is: Yes! Haskell can do that.
13:37:18 <ab9rf> haha
13:37:25 <sproingie> it answered that awful quickly
13:37:30 <mcstar>  @faq only shows that haskell doesnt understand natural language...
13:37:35 <ab9rf> network monitoring is "realtime"; if you don't poll at lest every five minutes data is lost
13:38:17 <tgeeky> my hard real-time has gone soft real-time :(
13:38:25 <sproingie> there's medications for that
13:38:46 <sproingie> ghciagra
13:39:20 <mcstar> that warrants a lol
13:39:21 <sproingie> (ghcialis probably would have been funnier, oh well)
13:39:22 <ab9rf> snerk
13:40:12 <dmwit> ?remember sproingie <tgeeky> my hard real-time has gone soft real-time :( <sproingie> ghcialis
13:40:12 <lambdabot> It is forever etched in my memory.
13:40:53 <sproingie> yay :)
13:41:05 <timtom> @faq Can you program a 3SAT whose complexity lies in P using Haskell?
13:41:05 <lambdabot> The answer is: Yes! Haskell can do that.
13:41:36 <timtom> bahaha
13:42:09 <mcstar> @remember WinstonChurchill It is a good thing for an uneducated man to read books of quotations.
13:42:09 <lambdabot> Okay.
13:42:22 <otters> ghcialis
13:42:23 <yitz> @nixon
13:42:23 <lambdabot> Government enterprise is the most inefficient and costly way of producing jobs.
13:42:35 <timtom> is there a list of lamdabot commands?
13:42:41 <timtom> @reaggan
13:42:41 <lambdabot> Unknown command, try @list
13:42:42 <sproingie> @help
13:42:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:42:45 <timtom> @list
13:42:45 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:43:02 <timtom> @lojban
13:43:10 <yitz> timtom: that list is likely outdated though
13:43:32 <timtom> @prontotorpedo
13:43:32 <lambdabot> on the haskell site they compare haskell to a spreadsheet
13:43:44 <mcstar> yitz: not surprising, lists are immutable
13:43:58 <timtom> yitz: ok
13:44:31 <otters> #haskell is funny this afternoon
13:46:58 <trescenzi> Are steps in do blocks executed sequentially or might they be executed lazily?
13:47:41 <geekosaur> depends on how (>>=) is defined for the monad
13:47:41 <timtom> trescenzi: do blocks are just syntactic sugar for monad bindings (i.e >>= )
13:47:52 <timtom> trescenzi: so it all depends on the monad you are using
13:48:05 <otters> i think in the IO monad they're executed sequentially aren't they
13:48:33 <trescenzi> I guess it would be IO in my case. It's all going on inside do blocks inside functions in main
13:48:43 <otters> yeah, it would have to be in IO
13:48:52 <trescenzi> Ok makes sense.
13:49:03 <trescenzi> So IO is sequential? It would have to be wouldn't it?
13:49:22 <tac_> There's lazy IO
13:49:27 <otters> right, b
13:49:38 <timtom> System.IO is lazy and sequential afaik
13:49:48 <otters> steps aren't executed out of order
13:49:52 <otters> as far as I know
13:49:56 <otters> "order" being how the programmer wrote it
13:50:18 <mcstar> wouldnt be any point in using a monad for IO if it wasnt sequential
13:50:38 <trescenzi> Yea that could return weird results if it wasn't sequential
13:53:35 <ab9rf> IO monad guarantees order only
13:53:52 <ab9rf> you're not guaranteed that IO will have actually occurred
13:55:00 <mcstar> order is sequentiality
13:55:04 <mcstar> in my dict
13:55:08 <mcstar> am i wrong?
13:55:28 <ab9rf> do you want to be wrong?
13:55:40 <mcstar> that doesnt matter
13:56:23 <trescenzi> I agree with mcstar lol in the long run what I care about is execution order of my functions
13:56:43 <mcstar> i want to hear what ab9rf has to say
13:56:49 <hpc> i also care that it actually runs though
13:57:03 <armlesshobo> mcstar: if you don't care whether or not it actually happens, then you're fine.
13:57:11 <hpc> it brings to mind a certain nosql database
13:57:20 <hpc> where it doesn't matter what happens as long as it gets done really fast
13:57:22 <elliott> ab9rf: whtat does "you're not guaranteed that IO will have actually occurred" mean?
13:57:29 <trescenzi> hpc: why would you ever use nosql and haskell together
13:57:46 <hpc> trescenzi: i wouldn't, unless you lump acid-state into that godawful category
13:57:47 <mcstar> well, there are stuff that i write in IO (pure code) that might actually not happen, but IO actions when happen happen in order/sequentially
13:58:12 <hpc> actually, speaking of which
13:58:15 <DanBurton> trescenzi: any number of reasons dealing with an existing nosql database
13:58:19 <hpc> has takusen been maintained?
13:58:35 <hpc> or something similar? i like the concept of combinator generators for sql
13:59:15 <trescenzi> DanBurton: yea existing would make sense I guess
13:59:47 <Tene> My last company has production code that talks to sql and nosql.  It's interoperating with existing data stores.
14:00:36 <Tene> They're working on getting away from PHP.
14:04:09 <DanBurton> God rest their souls
14:04:16 <ab9rf> elliott: at any particular point you can't be sure whether any particular IO action has happened, except that you know that all IO actions that have actually happened occurred in order
14:05:04 <ab9rf> elliott: it is possible for an IO action to _never_ happen, although i think that would only happen in the case of an abnormal termination.
14:05:07 <elliott> ab9rf: what do you mean by "at any particular point"? at a certain point in a sequence of IO actions?
14:05:17 <elliott> are you just thinking of unsafeInterleaveIO or such? e.g. as used by getContents
14:05:17 <hpc> oh, i see what you mean
14:05:25 <DanBurton> well if we're getting really existential, we could argue about whether anything has ever actually occurred >.>
14:05:34 <Tene> Another reason to use nosql is for nonrelational data sets, caching, plenty of reasons.
14:05:44 <hpc> 17:04 < ab9rf> at any particular point in evaluating the value "main", you can't be sure whether any particular IO action has happened, except that you know that all IO actions that have actually happened occurred in order
14:05:49 <hpc> ab9rf: ^ that, yes?
14:05:50 <ab9rf> sql is a crappy database for storing object-structured data
14:06:08 <ab9rf> hpc: something like that
14:06:29 <sproingie> objects are a crappy schema for representing relational data
14:06:34 <ab9rf> sproingie: that too
14:06:54 * elliott really doesn't understand what ab9rf means. if you have "do { s <- getLine; ... }" then you know that by the time of ..., a line has been gotten
14:07:10 <hpc> ab9rf: so basically, "execution of IO actions is slower or equal to evaluation of IO actions"
14:07:10 <ab9rf> elliott: not necessarily, not until you do something that needs s
14:07:14 <elliott> ab9rf: that is false.
14:07:22 <elliott> it would be true if it was "unsafeInterleaveIO getLine".
14:07:26 <elliott> but it is not.
14:07:36 <hpc> or even "haskell's standard evaluation semantics plus the fact that execution depends on evaluation"
14:07:52 <c_wraith> execution of IO requires evaluating it.
14:07:56 <c_wraith> So...  yeah
14:07:56 <DanBurton> but the fact that unsafeInterleaveIO exists should put you on edge, wondering if any of the IO actions you use are unsafely interleaved
14:08:08 <ab9rf> DanBurton: hence the 'unsafe'
14:08:08 <DanBurton> e.g. readFile or whatever
14:08:21 <elliott> ab9rf: in do { s <- getLine; ... } it is unambiguous
14:08:24 <ab9rf> elliott: hm, i'll have to go reread soet stuff again
14:08:50 <elliott> it is true that unsafeInterleaveIO can make the evaluation of values cause execution like this, but that is more a pitfall of readFile/getContents than IO
14:09:19 <elliott> just as unsafePerformIO's existence doesn't really mean that Haskell is impure so much that it means unsafePerformIO is unsafe
14:09:20 <DanBurton> I would call it a pitfall of unsafeInterleaveIO
14:09:56 <c_wraith> The best way to treat it is the observation that unsafeInterleaveIO is a crazy kind of concurrency
14:11:16 <DanBurton> You should worry about IO values using "unsafeInterleaveIO" in the same way that you should worry about pure values using "unsafePerformIO". Just make sure you trust where your values are coming from.
14:12:16 <c_wraith> I really dislike that things exposed by Prelude use unsafeInterleaveIO, though
14:12:40 <c_wraith> If they were all in modules that made it clear what they do, it'd be way nicer as a policy.
14:12:50 <c_wraith> Though it'd make quick example programs more work
14:12:51 <tac_> what are the operational semantics of unsafeInterleaveIO?
14:12:53 <dmwit> There's lots of things not to like about the Prelude.
14:13:03 <DanBurton> dmwit++
14:13:30 <c_wraith> tac_: GHC implementation specifically?
14:14:07 <tac_> sure. I don't use anything else.
14:14:18 <c_wraith> It is roughly equivalent to return . unsafePerformIO
14:14:31 <tac_> hmm
14:14:43 <c_wraith> With a couple added tricks to make sure that the IO action it's passed isn't ever duplicated by the optimizer
14:14:57 <c_wraith> Or rather, hit by CSE
14:15:19 <tac_> so it's executed at most once, but only when the value is forced?
14:15:23 <c_wraith> yes
14:15:32 <tac_> kk
14:15:37 <tac_> So it's how you implement lazy IO then, right?
14:15:41 <c_wraith> yes
14:15:59 <tac_> and "Prelude things that use it" would be mostly getContents
14:16:06 <dmwit> I marvel that "it's like return . unsafePerformIO" was an acceptable answer to "what are the operational semantics".
14:16:21 <c_wraith> getContents, readFile, interact
14:16:30 <dmwit> It seems like you'd at least want to know the operational semantics of "unsafePerformIO" next. =P
14:16:37 * tac_ marvels that dmwit marvels at that thing.
14:17:15 <dmwit> ...and I think an operational semantics of unsafePerformIO would have to include an operational semantics of pure values, which nobody's done, right?
14:17:57 <c_wraith> Not formally for the language
14:18:07 <c_wraith> However, you can say "look at the GHC implementation"
14:18:08 * tac_ wasn't asking a formal question, really.
14:18:17 <c_wraith> Which is a terrible way to specify something
14:18:23 <c_wraith> but it works, more or less, for these purposes
14:18:35 <monochrom> I have done. http://www.vex.net/~trebla/haskell/lazy.xhtml
14:18:44 <c_wraith> The problem is when a new version of GHC *changes* some detail
14:18:52 <elliott> dmwit: "how can I express the operational semantics of this in terms of my intuition about the operational semantics of the rest of the language?"
14:19:02 <c_wraith> like the change that allowed one-arg infix functions
14:19:05 <elliott> monochrom: does that handle async exceptions and stuff?
14:19:34 <monochrom> not yet, I haven't done errors
14:19:52 <c_wraith> That seems like a significant source of complication
14:21:53 <dmwit> monochrom: cool
14:24:17 <dmwit> I would also point at "A Natural Semantics for Lazy Evaluation".
14:27:23 <monochrom> actually, I have done errors. "If none of the equations is chosen, it's a runtime error". that is one source of async exceptions. (the other source is throwTo)
14:29:40 <monochrom> perhaps the async exception paper has done too much scaremongering of "you never know". but you can know. not perfectly, but enough for practice.
14:30:53 <c_wraith> Well, there is a history of imprecise exceptions messing up some parts of hUnit
14:31:06 <c_wraith> You can make the point that it means those parts of hUnit weren't implemented well
14:31:10 <monochrom> suppose thread A constructs "head []" and hands it to thread B, and thread B prints "hello" and then prints what it receives from thread A. then the exception occurs in thread B, and it is after printing "hello". this much you know.
14:31:16 <c_wraith> But you can also make the point that it's hard to implement right
14:32:42 <jbu> hi all: can someone help explain what "forall a. a -> a" means? specifically the forall and the period are confusing me.  I couldn't even understand the haskell description here http://www.haskell.org/haskellwiki/Keywords#forall
14:33:21 <shachaf> jbu: It means that the person who's using it can choose any "a" they want.
14:33:26 <monochrom> the period is punctuation, delimiter, whatever you call it for mere syntax
14:33:33 <elliott> jbu: it means that it is type (a -> a) for any a you want at all when using it
14:33:43 <elliott> you can use it as Int -> Int, String -> String, (Char -> Bool) -> (Char -> Bool), etc.
14:34:03 <otters> correct me if I'm wrong, but there's an implicit forall in most type signatures
14:34:07 <otters> those that use type variables, that is
14:34:13 <monochrom> yes
14:34:18 <elliott> yes, "foo :: a -> a" is the same as "foo :: forall a. a -> a"
14:34:19 <hpc> otters: in any polymorphic type signature, yes
14:34:22 <elliott> except the latter is non-standard
14:34:22 <jbu> elliott & shachaf: I thought a type variable already let you do that?  it just substitutes any type for "a" ... I've never seen the need for "forall"
14:34:30 <otters> jbu: right, but in some cases
14:34:33 <shachaf> jbu: Yes, "id :: forall a. a -> a" means the same thing as "id :: a -> a"
14:34:47 <ciaranm> jbu: think a -> (forall a. a)
14:34:48 <elliott> jbu: you use the forall for three things:
14:34:51 <shachaf> (In some cases it can be different but not in a fundamental way.)
14:34:54 <elliott> 1. being explicit (rarely)
14:34:56 <shachaf> ciaranm: What?
14:35:00 <elliott> 2. for ScopedTypeVariables
14:35:06 <elliott> 3. rank-2 types -- where you have (forall a. ...) -> b
14:35:16 <ciaranm> where a is b, obviously!
14:35:18 <elliott> for instance, ST uses a type (forall s. ST s a) -> a. this is the primary use of forall
14:35:28 <elliott> and can't be expressed without it
14:35:31 <otters> data BlackBox = forall a. Box a
14:35:35 <monochrom> consider whee :: (forall a. a -> Int) -> Int.  you cannot omit the forall now. if you omit it, different type altogether.
14:36:12 <twomashi> is it ok if my project depends on multiple versions of containers?
14:36:19 <jbu> hmm to be  honest, nobody's explanation reached through to me...
14:36:19 <shachaf> callCC :: ((forall b. a -> b) -> a) -> a -- has the same variance
14:36:24 <shachaf> twomashi: Probably not.
14:36:25 <hiptobecubic> twomashi, not if you want it to work ever
14:36:29 <twomashi> i just installed 0.5.0.0 to get Data.Map.Strict
14:36:39 <shachaf> jbu: It can take a while to figure it out. :-)
14:36:47 <twomashi> It compiled, though many modules didn't compile from scratch..
14:37:03 <hiptobecubic> jbu, ghc will try to resolve the a in a -> Int. If it later needs to use a different type for 'a', it will barf.
14:37:38 <oren1> Random Question:Who knows a Haskell module that (1) can be run from the command line with a file as an argument and (2) generates some output from that file.
14:37:42 * hackagebot filestore 0.6.0.1 - Interface for versioning file stores.  http://hackage.haskell.org/package/filestore-0.6.0.1 (JohnMacFarlane)
14:38:13 <monochrom> cabal-install always chooses unique containers (or any lib) per project
14:38:33 <oren1> I'm looking for some example source code to see how people have structured this kind of use case in Haskell.
14:38:43 <hiptobecubic> > let f g = (g (), g [])
14:38:44 <lambdabot>   not an expression: `let f g = (g (), g [])'
14:38:53 <hiptobecubic> @let f g = (g (), g [])
14:38:54 <lambdabot>  <local>:17:16:
14:38:54 <lambdabot>      Couldn't match expected type `()' with actual type `[a0]...
14:39:00 <hiptobecubic> jbu, ^
14:39:05 <elliott> jbu: let's say you have (forall a. a -> a) -> (Int, String)
14:39:12 <hpc> oren1: you'd get the file path from getArgs, open the file, do something with it, then close it
14:39:15 <elliott> jbu: foo :: (forall a. a -> a) -> (Int, String); foo f = (f 123, f "abc")
14:39:17 <hpc> same as any language
14:39:25 <elliott> jbu: this means you have to pass a function with type (forall a. a -> a) in
14:39:36 <elliott> of course, the only function of that type is id. (so this isn't very useful, but it's just an example.)
14:39:42 <hpc> oren1: without more info on what you want, the best abstraction i can give you is to use a with-function
14:39:44 <elliott> in particular, "foo" gets to pick what "a"s it uses your function with.
14:40:04 <elliott> with "foo :: (a -> a) -> (Int, String)", the *caller* of "foo" would get to pick the "a". because it is "foo :: forall a. (a -> a) -> (Int, String)"
14:40:11 <elliott> (i.e., foo works with any "a" you want.)
14:40:17 <elliott> which doesn't work, of course
14:40:37 <jbu> elliott: thanks, I understand that
14:41:01 <jbu> elliott: your case 2 and 3 earlier confused me , but I'm not sure if I need to understand those at the moment
14:41:21 <elliott> this is an example of 3
14:41:24 <elliott> the type of foo is a rank-2 type
14:41:25 <jbu> elliott: so is forall just omitted a lot of the time in function signatures?
14:41:50 <elliott> forall is only omitted at the "top level". i.e., if you have "foo :: t", and t uses a lot of type variables, then it's "foo :: forall v1 v2 v3 ... . t"
14:41:51 <oren1> i want to do some text transformations and format source code
14:41:59 <elliott> "foo :: (a -> a) -> (Int, String)" is "foo :: forall a. (a -> a) -> (Int, String)"
14:42:19 <elliott> this is why you only need forall if you want to write a rank-2 signature: i.e. a function that takes something like (forall a. ...) as an argument, like the correct foo I gave
14:42:21 <thorsten`> can i somehow tell haskell to check that a function never ends in an error/exception? i've got this http://wwwcip.cs.fau.de/~re06huxa/p/995841750456dcf01ad7b9775e2f38a3 and theoretically the "head" might fail
14:42:43 <c_wraith> thorsten`: that's beyond haskell's ability to check
14:42:51 <elliott> #2 is an unrelated use that you'll probably end up needing at some point but isn't very relevant otherwise :P
14:43:05 <elliott> (ScopedTypeVariables only uses the "forall" keyword for backwards compatibility with standard Haskell, anyway)
14:43:33 <c_wraith> thorsten`: (this is because Haskell is a turing-complete language)
14:44:04 <thorsten`> i mean i could do pattern matching and then it could be checked at compile time if the pattern matching is exhaustive
14:44:21 <c_wraith> oh. GHC will do that if you use the -Wall flag
14:44:29 <c_wraith> But there are many other ways to get exceptions
14:45:03 <thorsten`> e.g.?
14:45:22 <monochrom> exhaustive pattern matching is easy, and does not eliminate errors/exceptions
14:45:38 <monochrom> Prelude's head definitely passes the -Wall test.
14:45:59 <c_wraith> > head [] -- does not actually contain any incomplete pattern matches
14:46:01 <lambdabot>   *Exception: Prelude.head: empty list
14:46:03 <DanBurton> well no one thing could possibly "eliminate errors/exceptions" except god
14:46:21 <DanBurton> @src head
14:46:21 <lambdabot> head (x:_) = x
14:46:21 <lambdabot> head []    = undefined
14:46:32 <c_wraith> that source is not actually correct, but whatever
14:46:36 <aristid> > head []
14:46:38 <lambdabot>   *Exception: Prelude.head: empty list
14:46:44 <DanBurton> It's cute how @src lies :P
14:46:46 <c_wraith> it's clearly using error with a custom message
14:46:47 <jbu> elliott: does Forall mean something different if it appears without the period: "data Scheme  =  Forall [TVar] Type" ?
14:47:00 <shachaf> jbu: It's just a plain old constructor there, nothing special.
14:47:04 <shachaf> Might as well be called Foo.
14:47:05 <elliott> jbu: that's just someone else's code
14:47:10 <elliott> presumably modelling a programming language with forall
14:47:11 <shachaf> The keyword is "forall".
14:47:19 <monochrom> it is the same as "data Scheme = Hello [TVar] Type"
14:47:29 <monochrom> what an XY Problem
14:47:35 <jbu> shachaf: You're saying that it could just be written as "data Scheme = Foo [TVar] Type"?
14:47:42 * hackagebot libxml-sax 0.7.4 - Bindings for the libXML2 SAX interface  http://hackage.haskell.org/package/libxml-sax-0.7.4 (JohnMillikin)
14:47:59 <jbu> monochrom: gotcha
14:48:04 <jbu> thanks all
14:48:08 <elliott> monochrom: well, jbu would arguably be unable to understand what Scheme means in terms of what the code is modelling without the info given :P
14:48:09 <shachaf> jbu: Yes.
14:48:46 <shachaf> elliott: I found forall in logic much more obvious than forall in Haskell.
14:49:13 <elliott> shachaf: this looks to be modelling a programming language
14:49:24 <shachaf> OK.
14:49:55 <monochrom> data Moca = forall a. Forall a [TVar] Type
14:50:21 <c_wraith> woo, useless existentials
14:50:33 <c_wraith> you have a value of some type.  you can't do anything with it!
14:50:46 <monochrom> I can seq it
14:51:01 <shachaf> I can unsafeCoerce it using the Type tag.
14:51:06 <monochrom> soon, I can typeOf it too, what with "universal Typeable for everyone!"
14:51:36 <DanBurton> what seriously?
14:51:53 <c_wraith> Typeable handles polymorphic types now?
14:52:24 <monochrom> not now. but in a possible future if some evil people's dream comes true
14:52:39 <c_wraith> That would obsolete an Oleg library.
14:52:43 <c_wraith> I can't tell if that's good or bad.
14:52:50 * DanBurton will fight those dreams off with pointy lambdas
14:53:22 <monochrom> I can tell you what you will lose. "f :: forall a. a -> a" can be other than id and bottom
14:53:23 <DanBurton> only if it's called unsafeTypeOf
14:53:49 * DanBurton fights for the free theorems
14:53:55 <monochrom> (because it is implicitly "f :: forall a. (Typeable a) => a -> a"
14:54:03 <shachaf> monochrom: id, bottom, and const bottom
14:54:14 <shachaf> We have already lost that battle.
14:54:20 <edwardk> byorgey: that diagrams patch should fix the thing ozgun and carter were rambing about.
14:54:35 <monochrom> this is with precedence. one upon a time, seq :: (SomeClassName a) => a -> b -> b. then that class was dropped.
14:54:43 <edwardk> I've only proven it correct, not actually executed it.
14:56:20 <DanBurton> wat :( SomeClassNameForSeq sounds nice
14:56:21 <c_wraith> manually proven correct, or just thrown the type checker at it?
14:56:44 <DanBurton> go go, SMT solvers!
14:56:48 <shachaf> I think it was called Eval.
14:57:00 <c_wraith> DanBurton: until you want to add strictness to a polymorphic argument in a function a billion layers deep
14:57:21 <monochrom> I can also tell you what you will gain. next time a newbie asks "I want to write magic :: a->a but it has to do something funny when a=Int", you won't have to talk him/her out of it.
14:57:23 <c_wraith> admittedly, that does suggest that if there were better refactoring tools back then, the class might still exist
14:58:06 <c_wraith> what are the overlapping rules for type families?
14:58:29 <monochrom> I think the rule is "absolutely no overlap"
14:58:32 <tac_> monochrom: case () of () | a ~ Int -> unsafeKillSelf
14:58:37 <c_wraith> That's a good rule
15:03:25 <mgccl> is there a way to do pattern matching in guards?
15:03:46 <monochrom> yes
15:04:22 <c_wraith> as of Haskell2010, it's not even an extension
15:04:35 <monochrom> @let monofunc x | listToMaybe x -> Nothing = "whee"
15:04:35 <lambdabot>   Parse error: ->
15:04:36 <elliott> monochrom: in ghc head you can get overlapping
15:04:41 <monochrom> @let monofunc x | listToMaybe x <- Nothing = "whee"
15:04:42 <lambdabot>   Parse error in pattern: listToMaybe
15:04:56 <monochrom> hmm I need to look up the syntax
15:05:36 <monochrom> @let monofunc x | Nothing <- listToMaybe x = "whee"
15:05:38 <lambdabot>  Defined.
15:05:44 <monochrom> > monofunc []
15:05:47 <lambdabot>   "whee"
15:06:05 <monochrom> you write " | pattern <- expression = body"
15:06:18 <parcs> shachaf: does Typeable have your 'same' method yet?
15:06:27 <shachaf> parcs: No.
15:06:36 <monochrom> (of course, it is not "=" if you're writing case-of)
15:06:50 <mgccl> monochrom: thanks, this saves me from defining so many functions...
15:11:50 <ab9rf> ah, i was looking for that yesterday
15:11:58 <ab9rf> i found another way to do it but that would save some typing
15:13:36 <monochrom> I'm thinking whether pattern guard subsumes view pattern
15:14:07 <c_wraith> it's plausible. They both do roughly the same thing.
15:14:47 <c_wraith> I wouldn't check a proof that guard patterns does everything view patterns does too closely. (I could be fooled on the basis of plausibility)
15:15:26 <shachaf> At any rate I hope they don't eliminate view patterns because of that.
15:16:05 <c_wraith> I doubt they'll be eliminated. But if they are, it's likely they'll never be included in the base language.
15:16:08 <hpc> view patterns act in place of arguments
15:16:20 <hpc> they express a different concept, like let/where
15:16:22 <c_wraith> err, if they are *subsumed*, that is
15:16:44 <c_wraith> hpc: except it's even less work to rewrite one in terms of the other.
15:21:21 <q66> miasma, it's never too late to start! ;D
15:21:22 <monochrom> oh, I see
15:25:04 <parcs> i wonder if this should typecheck: http://paste.debian.net/243231/
15:25:42 <tgeeky> parcs: I thought the beauty is that you don't have to wonder!
15:25:58 <parcs> it doesn't, but maybe it should!
15:26:15 <c_wraith> yeah.  You can wonder about "should" regardless of whether it does or doesn't
15:26:58 <parcs> "could not deduce (a ~ Bool) from the context (a0 ~ b0)", among other errors
15:26:58 <monochrom> are you allowed to use "==" as a user-defined type name? even under TypeOperators?
15:27:05 <elliott> monochrom: sure, why not?
15:27:09 <parcs> monochrom: yeah, new to 7.8
15:27:32 <monochrom> because then nothing says whether "==" is a type variable or a type constant
15:27:35 <heatsink> You have a lazy value of type (a == b), which isn't sufficient to prove that a and b are the same type
15:27:46 <parcs> monochrom: it's no longer considered a type variable
15:27:51 <heatsink> You would at least need to force it with a 'case'
15:28:00 <heatsink> to prove that it's not _|_
15:28:15 <parcs> heatsink: it's being pattern matched on
15:28:29 <heatsink> oh
15:29:38 <monochrom> I thought you had to add a colon
15:29:49 <parcs> the problem is that GHC wants (a ~ Bool) but it can't seem to deduce that from the constraint introduced by Refl
15:29:53 <shachaf> Not as of 7.6 (or so).
15:30:07 <monochrom> that's pretty sick
15:30:38 <shachaf> parcs: You have to annotate.
15:30:42 <parcs> however if you use ScopedTypeVariables to give Refl the type a == Bool then it works
15:30:51 <monochrom> perhaps come October, "data my_type = my_type" will be allowed, too
15:31:28 <parcs> shachaf: i don't wanna annotate
15:32:13 <shachaf> parcs: I don't either.
15:32:18 <shachaf> But how should it know same's type?
15:33:27 <heatsink> Same could have type Maybe (a :== Bool) or type Maybe (Bool :== a)
15:33:44 <heatsink> There isn't an obvious choice
15:33:58 <shachaf> You could give same Proxy arguments.
15:34:05 <shachaf> Or even non-Proxy arguments!
15:34:13 <shachaf> | Just Refl <- same x True = ...
15:34:27 <shachaf> I mentioned a few helpers like that in my original email.
15:35:50 <shachaf> monochrom: Perhaps we should require explicit forall.
15:36:13 <shachaf> As Python says: Explicit is better than implicit.
15:36:17 <monochrom> I support that
15:36:40 <elliott> as elliott says, forall a b p q k r x. is annoying
15:37:13 <monochrom> I also support building IDEs that write "forall" for you :)
15:37:23 <ion> forall m a s t a b.
15:37:38 <shachaf> elliott: I'd rather take language design advice from Python than from elliott!
15:37:52 <mauke> forall ∀.
15:38:14 <parcs> unpossible!
15:38:16 <ion> forall forall. forall …
15:38:31 <geekosaur> pl/1, anyone?
15:39:08 <mauke> forall ∃.
15:39:23 <augur> are there any good proof search techniques that can handle "naughty" recursive definitions nicely?
15:40:06 <ion> @type undefined :: forall forall. forall
15:40:08 <lambdabot> parse error on input `forall'
15:40:16 <monochrom> I don't know how naughty is naughty.
15:40:38 <augur> @type undefined :: forall furfural. furfural
15:40:40 <lambdabot> furfural
15:40:43 <dmj> hey guys, is it possible to pattern on negative numbers in haskell?
15:40:45 <ion> @type undefined :: forall forаll. forаll
15:40:45 <lambdabot> fd:9: commitBuffer: invalid argument (invalid character)
15:40:49 <ion> aww
15:40:56 <shachaf> dmj: You may be after parentheses.
15:41:09 <parcs> > case -5 of -5 -> ()
15:41:10 <lambdabot>   ()
15:41:15 <monochrom> if your arguments are integers, and the recursion changes them linearly, it is a solved problem
15:41:22 <augur> monochrom: im thinking of definitions of transitive predicates, for instance, which will loop forever on certain queries
15:41:29 <parcs> > let (-5) = -5 in -5
15:41:30 <lambdabot>   -5
15:41:35 <Lethalman> swineflu, http://feeds.feedburner.com/technology/case-studies/
15:41:39 <ion> monochrom: Integer?
15:41:52 <monochrom> integer
15:41:56 <augur> monochrom: for instance,   a(X,Y) :- p(X,Y)  ;  p(X,Z), a(Z,Y).
15:41:59 <ion> Integers are integers.
15:42:07 <Lethalman> swineflu, sorry: https://www.fpcomplete.com/blog/2013/02/announcing-case-studies
15:42:14 <hpaste> dmj pasted “P-match negs” at http://hpaste.org/84394
15:42:30 <augur> monochrom: if you query   ?- a(X,j)   it'll loop forever, expanding out the right recursive a
15:42:34 <dmj> I'm implementing signum on the peano dedekind nat nums
15:42:43 * hackagebot caledon 3.0.0.0 - a logic programming language based on the calculus of constructions  http://hackage.haskell.org/package/caledon-3.0.0.0 (MatthewMirman)
15:42:46 <swineflu> Lethalman: ty
15:42:49 <dmj> Is there something like the above snippet that I could use?
15:42:49 <monochrom> then I don't know
15:43:12 <augur> well, the right part is irrelevant -- the part that's problematic is that the only fixed input variable is also used only in a recursive position
15:43:18 <swineflu> I'm trying to think of something to build to show to potential employers so they like "damn"
15:45:16 <parcs> prove the riemann hypothesis
15:46:27 <ion> Solve the halting problem.
15:47:51 <Lethalman> \o/ http://hackage.haskell.org/package/pianola-0.1.0
15:48:18 <Lethalman> not writing java swing directly but controlling it ahah
15:48:31 <Lethalman> nice
15:50:32 <DanBurton> people need to stop making their own pet languages so that I can focus on making my own pet language :P
15:59:48 <heatsink> Is there a way to tell GHC to use only the global package directory, without changing the command line options to GHC or setting GHC_PACKAGE_PATH?
16:00:11 <heatsink> I don't want to change the command line options because GHC is being invoked from a complicated makefile
16:00:26 <monochrom> there is
16:00:43 <heatsink> I would like to know of it.
16:00:54 <monochrom> -no-user-package-conf
16:01:07 <geekosaur> that's a command line option, no?
16:01:16 <monochrom> yes, oops
16:01:28 <geekosaur> of course, I'm hard put to think of a way to tell a command to do something without, er, telling it]
16:02:05 <monochrom> this is mission impossible. how about nuking ~/.ghc so there is in practice no user package directory?
16:02:44 <heatsink> That may work
16:02:55 <monochrom> or perhaps build a custom version of GHC that never looks at the user package directory
16:03:15 <mauke> replace ghc
16:03:22 <mauke> this can be done by setting PATH from outside
16:03:39 <monochrom> quite frankly, this is time to say: this is what command line options are for.
16:05:56 <heatsink> I could make a script that invokes GHC with the right options, and put that in the path
16:06:42 <heatsink> that will probably work.
16:07:13 <monochrom> it will also be pretty fragile, i.e., I copy your files and makefile to my computer, now it does funny things
16:07:35 <hpaste> vf2 pasted “nbr of lines wrong” at http://hpaste.org/84395
16:07:58 <heatsink> The issue is that I'm using a locally installed GHC to compile another instance of GHC
16:08:39 <heatsink> So I'm not going to be distributing this setup
16:09:35 <heatsink> It's a C file.  Maybe ask in ##c
16:10:15 <geekosaur> vf2 didn't ask here, just misdirected their paste
16:10:39 <geekosaur> #haskell is not the only channel that uses hpaste, oddly enough (check the channel announce dropdown sometme)
16:12:21 <heatsink> I didn't know that.  Usually I see pastebin and gist getting used
16:28:05 <ezyang_> darcsden issue tracker is giving me 400 errors on issue create
16:28:09 <ezyang_> anyone know what's up?
16:28:19 <shachaf> Not the darcsden issue tracker!
16:28:56 <Rotaerk> hmm where can I find the source for haskell libraries such as Data.Traversable
16:29:10 <shachaf> Rotaerk: Data.Traversable is in base.
16:29:18 <shachaf> hoogle will tell you.
16:30:44 <Rotaerk> k thanks
16:32:01 <VF2> what is a good way to represent a graph? a matrix sucks since it has a static size. but having all neighbouring nodes in a linked list seems slow?
16:32:40 <Kinnison> There are graph libraries out there
16:32:52 <Kinnison> which one is good for you depends to some extent on what you want to do with the data
16:33:54 <Rotaerk> shachaf, is there a way to get *readable* source?  the code here is formatted for minimal whitespace http://hackage.haskell.org/packages/archive/base/4.2.0.1/base-4.2.0.1.tar.gz
16:34:26 <shachaf> Rotaerk: ...Are you reading the raw .tar.gz or something?
16:34:34 <S11001001> Rotaerk: click source on any haddock page
16:34:46 <Rotaerk> no, I'm reading the Traversable.hs file within it
16:35:03 <shachaf> In other words, this file? http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/src/Data-Traversable.html
16:35:28 <Rotaerk> hmm
16:35:41 <elliott> perhaps you are using windows and using an editor that is interpreting the linebreaks incorreclty
16:35:42 <shachaf> Maybe you're using Windows and opened the .hs file in notepad.exe?
16:35:44 <elliott> e.g. notepad
16:35:51 <Rotaerk> ah... yea notepad did it
16:37:45 <VF2> Kinnison: i want to write one...
16:40:00 <Rotaerk> hmm never realized notepad didn't understand just \n... figured it was only that it *wrote* \r\n
16:42:34 <c_wraith> files are line printers, right?
16:43:01 <c_wraith> I mean, \r\n actually makes sense when you're sending control codes to a line printer
16:45:37 <geekosaur> dos inherited that behavior from cp/m, which lifted it from a old Dec minicomputer OS
16:45:51 <geekosaur> er DEC
16:46:06 <monochrom> \n is a unix convention, and also a haskell convention. \r\n is what geekosaur says
16:46:53 <monochrom> unix was right there in the line printer age, too
16:47:49 <geekosaur> but took the daring step of not basing its conventions on either line printers or punched cards or paper tape...
16:48:03 <c_wraith> yes, but unix understood the difference between file format and printer control codes
16:48:46 <monochrom> "files are line printers" is a bit strange
16:49:22 <geekosaur> /dev/lpr0 baby!
16:50:02 <monochrom> if anything, unix was the only OS give every device a file look-and-feel. other OSes made sure that files and printers had unlike APIs
16:50:03 <c_wraith> copy foo.txt prn
16:50:58 <c_wraith> ...  I can't believe there are still neurons in my brain devoted to remembering that.
16:50:59 * geekosaur notes that trsdos actually was a bit ahead of its time in that area, and ldos took it a bit farther along the way. although device specifiers still looked different from files
16:51:22 <geekosaur> but you could at least treat *ki, *do, *lp, etc. as if they were files
16:51:42 <c_wraith> worst typewriter ever: copy con prn
16:52:01 <c_wraith> I may have done that once or twice.
16:52:05 <geekosaur> c_wraith, niot quite worst, try the pip version that cp/m had
16:52:28 <c_wraith> I managed to never deal with cp/m
16:52:40 <geekosaur> (and also cribbed from that DEC OS)
16:52:45 <c_wraith> my pre-dos computer use was..  more primitive. radio shack hardware!
16:52:52 <shachaf> for x in str dex int wis cha; do copy con $x; done
16:53:42 <monochrom> I write "prn:" to remind the human that it is a device name
16:53:47 * geekosaur points to trsdos comment above :)
17:03:47 <twomashi> i put bangs next to every assignation in my program and still get Stack space overflow...
17:04:04 <shachaf> That's not very surprising.
17:04:20 <swineflu> is there away i can do lower s = filter isLower s without importing?
17:04:37 <elliott> why do you not want to import?
17:05:38 <swineflu> Don't think we're aloud
17:05:42 <swineflu> but i cant think of an otherway to do it
17:07:41 <swineflu> is there away I can look at the chars in the array as ascii values
17:07:46 <geekosaur> so they're teaching you how to only deal with hardcoded ascii?
17:07:49 <geekosaur> that
17:08:00 <geekosaur> that's a very bad practice
17:08:10 <swineflu> I'm not sure but I like to think about all the approaches
17:08:10 <monochrom> you must find the exact cause of the memory consumption and cure it, rather than believing in simplistic falsehoods such as "it is always laziness" or "it is always eagerness"
17:08:27 <geekosaur> we really do not need "teachers" who teach bad i18n practices
17:08:50 <swineflu> They guy who teaches this course is quite well known in mathematically structured programming circles
17:09:07 <swineflu> So i trust what ever he wants us to write is to learn something
17:09:10 <monochrom> who is the guy, and where can I read the assignment?
17:09:11 <swineflu> even if it seems strange
17:09:22 <geekosaur> but you're not allowed to use a proper unicode-aware toLower?
17:09:44 <geekosaur> note also that someone can be great at math and lousy at internationalization issues
17:10:29 <swineflu> well we're learning about lists so i dont think i have the correct solution
17:11:40 <elliott> swineflu: if it really involves checking characters for lowercase, then I simply don't believe you're forbidden from importing Data.Char
17:12:28 <swineflu> he gave us a little bit of code to fill in the blanks,-- lower s = filter ?? s --           where ??
17:12:41 <swineflu> and all we have to do is return lower case chars
17:12:48 <swineflu> I dont seem to need the where
17:13:26 <swineflu> infact
17:13:39 <swineflu> perhaps i need a second thing in the where clause to remove numbers
17:14:23 <swineflu> or not :s
17:28:52 <swineflu> I didnt know you could use ranges of chars :o
17:32:09 <QinGW> q,,
17:32:10 <twomashi> this is so frustrating. program takes between 10 seconds and 4 minutes to Stack Space Overflow depending on how many bangs I litter it with
17:33:11 <shachaf> Sounds like the 10 second version is better.
17:33:15 <heatsink> twomashi, have you compiled with profiling to determine where the overflow occurs?
17:34:22 <twomashi> heatsink: I have but I couldnt recognise anything in my program in the output files.
17:35:36 <heatsink> You need to insert cost-center annotations for your code to show up in the profile.  Easiest way is to use the -auto flag.
17:35:46 <monochrom> please don't speak like adding and deleting bangs is the only option. you should also consider the nature of your algorithm and maybe use a different algorithm that has good nature
17:37:01 <twomashi> http://imgur.com/jyCOkvu
17:37:12 <twomashi> heatsink: will try that
17:37:22 <heatsink> Then running with +RTS -xc should show the functions that are on the stack when overflow occurs.  A function won't appear more than once on the stack trace.
17:38:28 <monochrom> you build a lot of tuples and hold on to them forever
17:39:25 <twomashi> monochrom: potentially millions of tuples, yes...
17:40:46 <heatsink> @arr words
17:40:46 <lambdabot> Swab the deck!
17:44:01 <wires> VF2: look at inductive graphs
17:44:23 <wires> if you want to deal with finite graphs it is good
17:45:16 <wires> VF2: http://web.engr.oregonstate.edu/~erwig/papers/InductiveGraphs_JFP01.pdf
17:52:53 <swineflu> is there a difference between fst and head?
17:53:02 <swineflu> other than fst works on all lists?
17:53:06 <geekosaur> lists are not tuples
17:53:18 <swineflu> but isnt a tuple a kind of list
17:53:21 <geekosaur> fst is the first element of a 2-tuple (only). head is the head of a list
17:53:24 <geekosaur> no
17:53:29 <swineflu> ohhh
17:53:33 <geekosaur> it is in python, but it is not in haskell
17:53:36 <monochrom> please consider tuple and list unrelated
17:53:37 <swineflu> I thought everything in haskell was a form of list
17:53:41 <elliott> no
17:54:07 <swineflu> already makes sence, I managed to write my function with out imports aswell :)
17:59:01 <thoughtpolice> preflex: seen Peaker
17:59:02 <preflex>  Peaker was last seen on #haskell 1 day, 1 hour, 25 minutes and 19 seconds ago, saying: @pl \x -> mod x 2 == 0
17:59:11 <tac> Which lens package is the most popular on Hackage?
17:59:25 <thoughtpolice> tac: 'lens' is pretty much the winner, these days
17:59:31 <tac> thoughtpolice: thanks :)
17:59:42 <tac> thoughtpolice: that's the one described in https://www.fpcomplete.com/user/tel/basic-lensing right?
17:59:53 <thoughtpolice> (i mean, edwardk wrote like 3/5ths of the lens libraries on Hackage, including lens)
17:59:56 <thoughtpolice> tac: yep!
18:00:12 <tac> cool
18:00:47 <thoughtpolice> well, maybe it's not fair to say it's the winner. people stick to other libraries for minimalism and simplicity, but i think lens wins out on critical factors like contributions, usage, and flexibility
18:01:33 <thoughtpolice> i don't really mind the dependency chain myself. none of it is superfluous, and frankly haskell packages are generally small, so i expect slightly bigger dependency chains for 'full blown' libraries.
18:01:38 <tac> Well, I just want to try out the one that will give me the best experience so I know wtf people are talking about when they talk about them
18:01:45 <tac> So this works, I guess :)
18:02:13 <thoughtpolice> tac: you can also join #haskell-lens and bug people there
18:02:19 <thoughtpolice> it's got someone in there almost 24/7
18:02:27 <tac> ty ty
18:02:55 <tac> 79 files to compile for what is described by nearly everyone as "fancy getters and setters" o___O
18:02:59 <tac> lol
18:03:21 <thoughtpolice> tac: 'lens' includes a lot of built in combinators for almost the entire Haskell Platform, which is why it's so big
18:03:31 <tac> I gotcha
18:03:33 <thoughtpolice> i'd say like 1/3rd or even less of all the modules have to do with lens itself
18:04:52 <donri> basically the ones in the Control.Lens namespace
18:05:22 <donri> of which half are exposed internals :)
18:07:23 <tac> Is the underscore convention a template haskell thing?
18:07:33 <tac> or do I really end up defining a function called _blah in my data types?
18:08:09 <elliott> you write _blah but you don't need to use it.
18:08:11 <elliott> the TH turns _blah into blah
18:08:22 <tac> ah, ok
18:08:28 <latro`a> _1 is a thing, though, yes?
18:08:29 <tac> So I still have to mind namespace pollution
18:08:40 <latro`a> as in, it goes through the TH
18:08:45 <donri> tac: saying fancy getters/setters is a bit narrow. lens includes lens based apis that supersedes a number of older packages like newtype, zippo, uniplate and does a lot more than previous lens packages yet
18:09:16 <donri> latro`a: _1 has nothing to do with TH
18:09:36 <latro`a> I guess I phrased that badly, the _ isn't TH-only
18:09:57 <elliott> _1 is _1 because you can't call anything 1 :)
18:10:18 <donri> there's also a convention of _Right = prism for Right
18:11:20 <donri> but _foo in records is just a way to name lenses without conflict and we're discussing an alternative to makeLenses without that requirement
18:13:05 <ab9rf> i have yet to figure out what this lens thing is
18:13:27 <tac> erk
18:13:38 <tac> Do you need to turn on the template haskell pragma or something?
18:13:56 <tac> I get a syntax error on $
18:14:05 <donri> yes
18:14:06 <tac> in $(makeLenses ''RateLimiter)
18:14:17 <donri> also the $() is optional there
18:14:27 <tac> why is it optional?
18:14:44 <donri> because no other expression is allowed at the module top-level
18:15:52 <tac> Server.hs:38:24: Not in scope: type constructor or class `IrcCreds' <-- I'm getting these weird errors when turning on TH
18:15:57 <tac> IrcCreds is a type I've defined
18:16:37 <thoughtpolice> tac: paste?
18:16:57 <tac> @hpaste
18:16:57 <lambdabot> Haskell pastebin: http://hpaste.org/
18:17:24 <hpaste> tac pasted “tac” at http://hpaste.org/84400
18:17:41 <tac> Code compiles fine without the TemplateHaskell pragma
18:18:13 <donri> where did you put the pragma?
18:18:25 <donri> it should go before the module declaration
18:18:29 <tac> yep
18:18:35 <tac> that's where it ended up
18:18:52 <tac> oh.... I guess it has to be the FIRST pragma
18:19:01 <tac> or
18:19:03 <tac> hm
18:19:06 <donri> shouldn't matter
18:19:17 <tac> I guess it's the makeLenses call that's causing it
18:19:35 <donri> yes, TH makes source order significant
18:19:48 <donri> so may need to define those types before the makeLenses call
18:20:01 <tac> good to note. but they are already in order
18:20:06 <donri> either by moving the types or the makeLenses call
18:20:16 <donri> what order?
18:20:37 <tac> makeLenses happens after the data decl
18:20:55 <donri> but before data TwitterConfig etc, right?
18:21:37 <tac> it was after all of them
18:21:55 <donri> although POSIXTime is probably imported, so that's odd ...
18:22:18 <donri> better paste a full example
18:23:13 <tac> oops, my bad
18:23:23 <tac> I guess I put the makeLenses after half of the data decls used
18:23:31 <tac> false alarm :)
18:23:43 <tac> Will makeLenses work recursively on all the other data types then?
18:24:19 <donri> nope, but TH still needs to know everything about the type, regardless of lens
18:26:42 <Torr> hi
18:27:06 <tac> thanks for the help guys
18:27:17 <tac> I'm gonna read up more before I destroy my project with these
18:27:32 <mgsloan> tac / donri: though it /could/ work recursively.  You could even detect if the generated definitions would alias any existing definitions
18:27:56 <mgsloan> It just wouldn't be very reasonable to do so :)
18:28:15 <donri> yeah
18:28:36 <Torr> can someone explain to me how to animate a square so that it gets bigger with time using gloss?
18:31:38 <Torr> unable to find an article on how to animate using gloss
18:46:18 <Kaidelong> Torr: are you using the game interface or something else?
18:46:24 <Kaidelong> oh he is gone
18:46:52 <fxr> hi
18:47:20 <Kaidelong> hello there
18:47:44 <fxr> is it possible to execute an "IO a" repeatedly until (a->Bool) and return [a] ?
18:48:13 <fxr> I have tried my chance with Applicatives
18:48:17 <hpaste> fxr pasted “accumulating IO until pred” at http://hpaste.org/84401
18:48:34 <fxr> but I think I'm creating lot's of thunks
18:48:53 <fxr> any ideas?
18:48:54 <bytes> hi i just started using haskell, i was wondering, how would i convert an input of a variable x and change it into an int if i have gotten the input through getLine
18:49:17 <Mortchek> bytes, read
18:49:26 <Mortchek> > read "10" :: Int
18:49:28 <lambdabot>   10
18:49:45 <bytes> okay thank you i will try it out
18:50:05 <geekosaur> :t readLn
18:50:07 <lambdabot> Read a => IO a
18:50:20 <geekosaur> ^^ alternative to getLine
18:50:55 <Mortchek> Oh great, that's even better than using read since you can at least handle errors
18:51:36 <geekosaur> not really, an error is still an exception in either case
18:51:40 <geekosaur> @src readLn
18:51:40 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
18:52:06 <Mortchek> So you can't handle failure there either?
18:52:08 <bytes> so i can do this? b <- readLn :: Int
18:52:16 <geekosaur> I think it's just an IO exception instead of a general exception, but these days there should be no difference (as we deprecated the IO-exception-only stuff)
18:52:29 <napping> fxr: you don't seem to use acc at all
18:52:44 <napping> That looks like it will pile up stack frames rather than thunks
18:52:55 <geekosaur> bytes, no, the :: doesn't scope past the <- so the type should be IO Int
18:52:57 <napping> go (bs:acc) would be using the accumulator
18:53:19 <Mortchek> bytes, also, you don't need to specify the type if it can be inferred from how you use the value
18:53:28 <geekosaur> or with appropriate pragma, b :: Int <- readLn
18:53:31 <bytes> oh, i thought it didn't infer it
18:53:33 <bytes> thank you!
18:53:33 <napping> the (bs:) <$> go acc h you have makes a non-tail recursive call to get more input, then prepends a new element
18:53:38 <Mortchek> I said "if"
18:53:46 <Mortchek> not "since"
18:53:47 <fxr> napping: you're right
18:53:54 <fxr> napping: thanks for pointing out
18:54:05 <geekosaur> whether it will infer it correctly or not depends on what you do with it
18:54:16 <geekosaur> it may end up inferring Integer
18:55:19 <hpaste> fxr annotated “accumulating IO until pred” with “accumulating IO until pred (annotation)” at http://hpaste.org/84401#a84402
18:55:31 <fxr> got rid of acc
18:55:57 <fxr> I couldn't see such a function in Control.Monad
18:57:24 <monochrom> I recommend using reads instead to be notified of errors. http://www.vex.net/~trebla/haskell/reads.xhtml
18:58:17 <monochrom> readIO and readLn notify you of errors, but perhaps too tied to IO and not really anything to do with IO
18:58:54 <Mortchek> I like using Read a => String -> Maybe a
18:59:00 <Mortchek> which can be implemented with reads
18:59:08 <monochrom> yes, that is even nicer
19:05:48 <elliott> monochrom: that's readMaybe, in recent GHC
19:06:37 <elliott> er, I meant Mortchek
19:07:20 <monochrom> readMaybe is still rather new and uncommon. but one day, it will be common enough, and I will recommend it instead
19:07:21 <Mortchek> I don't have it, so I wrote it myself
19:25:09 <bytes> i'm trying to use type casts and for some reason i am getting an error with this
19:25:10 <bytes> http://pastebin.com/8ETMb96Y
19:25:14 <mauke> The paste 8ETMb96Y has been copied to http://hpaste.org/84403
19:25:18 <bytes> without the 1st line it works fine
19:26:21 <monochrom> terminology: it is type annotation, not type cast. you clarify the type, not change the type
19:26:46 <bytes> oh, sorry
19:27:04 <bytes> but what am i doing wrong?
19:27:15 <Mortchek> bytes, (x + y) is Int, but (/) is not defined over Int.
19:27:23 <monochrom> you cannot do int / 2. instead: fromIntegral (x + y) / 2.
19:27:58 <Mortchek> And the arguments and result of (/) have to be the same type
19:28:02 <Mortchek> :t (/)
19:28:03 <lambdabot> Fractional a => a -> a -> a
19:28:14 <monochrom> when you omitted the type, you were getting essentially Double -> Double -> Double
19:28:24 <bytes> oh
19:33:06 <geekosaur> that fromIntegral *is* a type cast, after a fashion (since it's a Prelude function, not a language builtin)
19:33:48 <monochrom> it does conversion. I would prefer "cast" to mean no conversion, use the same bits.
19:34:11 <geekosaur> C and C++ disagree with you there, though and I think java
19:34:33 <geekosaur> none of them reuse the bits if you cast an int to double or vice versa
19:34:54 <kadoban> well, depends on which cast, but usually not
19:37:00 <c_wraith> reinterpret_cast
19:37:58 <shachaf> Why can't we have nice long identifiers like that?
19:38:07 <shachaf> > map length ["unsafeCoerce", "reinterpret_cast"]
19:38:09 <lambdabot>   [12,16]
19:43:55 <DanielDiaz> hi all
20:08:09 <heath> does cabal support keywords for packages?
20:09:22 <heath> i like how the grunt guys autogenerate a list of plugins based on the keyword "gruntplugin" from the npm directory listing
20:09:26 <heath> http://gruntjs.com/plugins
20:10:09 <c_wraith> heath: it has categories, which can be anything...
20:10:24 <c_wraith> So they might as well be keywords, the way some people use them
20:14:49 <dibblego> does lambdabot support jabber?
20:16:24 <simpson> dibblego: Probably not.
20:16:44 <lispy> dibblego: I'm pretty sure she had support for it at some point
20:16:53 <lispy> dibblego: I want to say it was unused and removed
20:17:02 <dibblego> bummer
20:17:32 <lispy> dibblego: https://github.com/mokus0/lambdabot
20:17:47 <dibblego> mokus_: ?
20:20:20 <monochrom> @type compare
20:20:21 <lambdabot> Ord a => a -> a -> Ordering
20:25:47 <lispy> @type check
20:25:49 <lambdabot> Not in scope: `check'
20:34:33 <liyang> heath: hackage2 has tags.
20:34:52 <heath> thanks liyang, thanks c_wraith
20:43:23 <tac> Does anyone know what a usable binding for sqlite in Haskell would be?
20:45:29 <napping> what do you need?
20:45:47 <liyang> tac: this doesn't help, but we rolled our own. :-/
20:45:54 <tac> liyang: that sounds grim for me
20:45:58 <liyang> (Inside a larger library.)
20:46:24 <liyang> (I'm not sure why we did that; I didn't write it.)
20:46:30 <napping> there are several libraries on hackage, I think I've tried at least some basic stuff with sqlite-simple
20:47:29 <tac> liyang: It appears that many libraries on hackage use that same approach
20:47:40 <tac> napping: is sqlite-simple usable thne?
20:47:42 <tac> then*
20:51:24 <napping> what do you mean usable?
20:52:21 <napping> It seems to work, and follow postgresql-simple as far as the interface goes
20:55:31 <liyang> Takusen supports Sqlite doesn't it?
20:56:15 <napping> There seem to be a bunch of bindings, including HDBC, HSQL, and HaskellDB over either of those drivers
20:57:24 <napping> I wouldn't know if sqlite has fancy features some of those might miss
21:01:10 <dacto> could some one review a small piece of code for me if I post on hpaste? I'm hoping to get some advice on reducing the if and case.
21:02:05 <liyang> dacto: yes, someone could.
21:02:09 <geekosaur> sqlite isn't much for fancy features; the "lite" is part of the name for a reason...
21:02:54 <hpaste> dacto pasted “if/case reduce” at http://hpaste.org/84404
21:05:11 <tac> dacto: You rarely want to use if-then-else
21:05:16 <tac> instead, do a case statement on your list
21:05:30 <tac> that will 1) test null automatically and 2) split the list into your head and tail safely
21:05:34 <dacto> ohhh yeah, then jus tput a case for []
21:05:42 <tac> yep
21:05:47 <dacto> doh'
21:05:49 <liyang> and don't indent so much. I'm guessing you're following the style from a textbook. Don't. They suck.
21:05:51 <tac> case list of [] -> .... ; (x:xs) -> ....
21:06:24 <dacto> tac: yeah, I don't know why I didnt think of that
21:06:38 <dacto> liyang: yeah, it gets kind of annoying haha
21:06:47 <tac> dacto: you didn't think of it because you're not used to it :)
21:06:58 <tac> the rule to follow is "rarely, if then else"
21:07:10 <tac> instead, pattern match + use guards
21:07:17 <dacto> yeah, i know that rule; that's why i wanted to get rid of i
21:07:19 <dacto> it*
21:07:39 <dacto> it was for prototyping something.
21:07:50 <applicative> yes, this will look much better with case filter (\v->show v==z) s of [] -> ... etc
21:08:22 <dacto> yep, i completely agree. I feel dumb for not thinking of that b/c I've used that many times haha - just didnt connect the dots
21:09:34 <applicative> but it seems substantively okay, no?
21:09:45 <napping> the show in the filter looks funny
21:10:16 <liyang> You could use listToMaybe too. And maybe the maybe helper.
21:10:20 <dacto> napping: yeah my data type has a string for a name and I'm checking against a string that is already pulled out.
21:10:49 <hpaste> liyang annotated “if/case reduce” with “if/case reduce (annotation)” at http://hpaste.org/84404#a84405
21:11:27 <liyang> > listToMaybe
21:11:29 <lambdabot>   No instance for (GHC.Show.Show ([a0] -> Data.Maybe.Maybe a0))
21:11:29 <lambdabot>    arising fr...
21:11:31 <liyang> :t listToMaybe
21:11:33 <lambdabot> [a] -> Maybe a
21:11:38 <liyang> :t maybe
21:11:39 <lambdabot> b -> (a -> b) -> Maybe a -> b
21:12:06 <dacto> liyang: couldn't I just use one case for all 4 cases (including the empty list)?
21:12:38 <liyang> dacto: you could. It'll looks messy since you don't use the tail though.
21:12:54 <tac> welp, sqlite-simple might even work
21:13:05 <liyang> It looks to me like what you really want is listToMaybe.
21:13:23 <dacto> I shall go check it out
21:14:35 <dacto> oh, also - does the hpastes expire or is there a way to delete them (granted there isn't something to verify ownership so I think manual is a no)?
21:18:31 <liyang> Looks like ‘no’: http://hpaste.org/browse?page=1207
21:18:49 <adnap> I got a "Tabs are not allowed in Hamlet indentation" error message. Is this true in general?
21:19:19 <dacto> lol, ok - thanks for looking. Didn't necessarily want to make you do work. Just an off-top-of-head question ;)
21:19:24 <liyang> adnap: we'll shun you if we catch you using tabs.
21:19:46 <liyang> dacto: good thing you did. I just found a bug in hpaste.
21:19:47 <adnap> liyang: Are you trying to start a tabs/spaces argument?
21:20:02 <tac> fucking prelude man....
21:20:07 <tac> :t log
21:20:09 <lambdabot> Floating a => a -> a
21:20:10 <dacto> liyang: oh really? what was the bug?
21:20:15 <liyang> adnap: trolling as usual. :)
21:20:27 <adnap> The tab character is for indentation and I only have to press one key!
21:20:28 <liyang> dacto: look at the paste # range on the last page…
21:20:40 <liyang> adnap: set expandtab
21:20:57 <ab9rf> i need to convince notepad++ that i don't want tabs in .hs files
21:21:29 <adnap> liyang: I can't easily delete a bunch of spaces. I can delete a tab character with one key press!
21:21:30 <tac> @where ghc
21:21:31 <lambdabot> http://haskell.org/ghc
21:21:40 <tac> err
21:21:42 <tac> @where trac
21:21:42 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
21:21:50 <tac> hmm
21:21:51 <dacto> liyang: ah, the first page should be # - 0 eh?
21:22:09 <dacto> or 0 - #*
21:22:11 <liyang> adnap: here's a tuppence, go buy yourself a real editor kid. ;)
21:22:20 <geekosaur> adnap, if you're using vi/vim, you might want to use ^T to indent and ^D to delete indentation backwards
21:22:28 <ab9rf> aha, i found the spot for convincing notepad++ not to use tabs :)
21:22:52 <geekosaur> oh, notepad++. can't help
21:24:01 * liyang uses set et ts=4 sts=4 sw=4 with vim.
21:24:12 <ab9rf> this was driving me knuts yesterday, i kept having to manually force a tab->space converzion
21:24:20 * arkeet too.
21:24:29 <adnap> geekosaur: Well, I didn't know about that, but I still prefer tab and backspace to curling my pinkies to reach ctrl
21:25:01 <arkeet> aha, I didn't know about ^T and ^D.
21:25:04 <arkeet> I just press tab or backspace.
21:25:20 <geekosaur> note that those use sw instead of ts/sts
21:25:36 <liyang> adnap: put that in ~/.vim/after/ftplugin/haskell.vim
21:38:13 * hackagebot scc 0.8 - Streaming component combinators  http://hackage.haskell.org/package/scc-0.8 (MarioBlazevic)
21:38:15 * hackagebot monoid-subclasses 0.1.1 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.1.1 (MarioBlazevic)
21:39:22 <Ralith> is there any better way to work out where a program is busylooping other than scattering traces absolutely everywhere?
21:44:29 <alang> edwardk: hi
21:59:00 <Ralith> is there any way to get a printable address value from a STRef?
22:00:28 <mm_freak> Ralith: you could detect busy-looping by using a profiled build
22:00:54 <mm_freak> and it's unlikely that you can get an address for an STRef
22:01:03 <mm_freak> you need Ptr+Storable for that
22:01:04 <arkeet> you could unsafeCoerce it to a word
22:01:15 <arkeet> :c
22:01:22 <arkeet> maybe
22:01:52 <mm_freak> unsafeCoerce may give you some kind of pointer, but it's unlikely to be the pointer to the data
22:02:01 <arkeet> no, that's not stable
22:02:12 <arkeet> yeah
22:02:22 <Ralith> I don't need it to be stable or usable for anything other than eyeballing
22:02:23 <mm_freak> in particular unsafeCoerce will disagree about two variables holding the same value
22:02:25 <arkeet> well he didn't say what he wanted the address to point to
22:02:45 <Ralith> I just want to be able to judge 'are these two STRefs equal' in some debug output without n^2 comparisons
22:02:58 <mm_freak> Ralith: there is an Eq instance for STRef
22:03:03 <Ralith> ...
22:03:06 <arkeet> he said n^2
22:03:07 <arkeet> :c
22:03:14 <mm_freak> oh, i missed that
22:03:33 <mm_freak> well, check out the source code of the Eq instance
22:03:43 <Ralith> 'cause there's nothing I like more than debug output containing a polynomially-growing number of booleans :P
22:03:44 <arkeet> STRef v1# == STRef v2# = sameMutVar# v1# v2#
22:03:44 <arkeet>  
22:03:44 <mm_freak> it's probably comparing something you will find in some GHC.* module
22:03:59 <Ralith> well that's not very useful
22:04:27 <mm_freak> Ralith: bottom line:  STRefs don't have a portable notion of address
22:04:51 <Ralith> I don't want it to be portable
22:05:04 <Ralith> what have I said that is unclear?
22:05:16 <arkeet> and sameMutVar# is a primop
22:05:21 <arkeet> so, magic
22:05:26 <Ralith> I'm trying to do some debugging and a way to look at a bunch of strefs and judge identity would be really helpful.
22:05:41 <arkeet> you could tag all your strefs with a stable name?
22:05:47 <Ralith> yeah, that's the fallback
22:05:49 <Ralith> lot of wiring though
22:06:37 <mm_freak> Ralith: i don't see any way to do it
22:06:56 <mm_freak> unsafeCoerce may be your only option
22:07:01 <arkeet> you could make a wrapper around STRef to simplify the plumbing I guess
22:07:21 <mm_freak> do you need ST?
22:07:48 <mm_freak> Ralith: there is good reasoning that it's impossible
22:08:14 <mm_freak> runST (newSTRef () >>= getSTRefPointer)
22:08:18 * hackagebot bytestring-lexing 0.4.2 - Parse and produce literals efficiently from strict or lazy bytestrings.  http://hackage.haskell.org/package/bytestring-lexing-0.4.2 (WrenThornton)
22:08:29 <mm_freak> could return 1234 now and 4321 later
22:08:29 <Ralith> mm_freak: it's obviously unsafe, yes, I know that.
22:08:51 <mm_freak> Ralith: yeah, and a quick glance at the low level facilities for STRef makes it look impossible
22:09:04 <mm_freak> but i know that there is a library to compare heap pointers
22:09:18 <mm_freak> it's much more general than comparing STRef, but unfortunately that one needs IO
22:09:28 <mm_freak> so in that case you would have to use unsafePerformIO
22:10:22 <Ralith> I'll just run the plumbing
22:11:18 <mm_freak> Ralith: http://hackage.haskell.org/package/vacuum
22:11:44 <mm_freak> that's the library i meant
22:12:08 <Ralith> looks fun
22:12:51 <mm_freak> see the bottom of the GHC.Vacuum module
22:12:58 <Ralith> whee, found the loop
22:13:22 <mm_freak> lol
22:14:47 <Ralith> ?
22:15:42 <mm_freak> now that i looked up the library =P
22:16:27 <Ralith> ..?
22:16:33 <Ralith> oh
22:16:37 <mm_freak> nevermind
22:16:51 <mm_freak> i'm back to OS dev =)
22:17:02 <Ralith> ^^
22:17:17 <Ralith> lemme know if you have something idrissy to discuss there
22:18:11 <mm_freak> Ralith: my first step is to finish a small kernel design…  that one can be a basis for an RTS
22:18:59 <Ralith> sounds like fun
22:19:12 <Ralith> do you expect it to be able to share an RTS with the regular environment?
22:19:17 <Ralith> or significant components thereof?
22:19:51 <mm_freak> if this works out the RTS will power the entire system…  programs will be compiled only to STG or something similar and no further
22:20:16 <mm_freak> well, slightly further…  opcode routines will be allowed, but they will run with minimal privileges with no way to call the kernel
22:21:36 <Ralith> oh, sorry, I thought you were talking about the idris RTS
22:21:49 <Ralith> that sounds pretty neat
22:21:54 <Ralith> I assume you've looked into proof-carrying code?
22:22:00 <mm_freak> well, depending on what language i choose, it may well be an idris RTS =)
22:22:05 <mm_freak> yes, i did
22:22:17 <Ralith> the used by idris, not one written in :p
22:23:00 <mm_freak> yeah…  recall that i want to compile idris to standalone code powered by an RTS that is essentially a mini-kernel
22:23:31 <mm_freak> it includes only the bare essentials like memory management/GC and the bridge to some devices
22:24:07 <mm_freak> the goal is to use idris for what it's supposedly good at:  systems programming =)
22:30:18 <Pods> Hi I have been acquainted with haskell , and know fair amount of oop, I am looking to contribute for haskell, where can i start from ??
22:33:03 <arkeet> start by forgetting everything about oop :p
22:34:29 <Bynbo7> and then forgetting everything about sequential programming
22:36:31 <wavewave> Pods: follow your interest.
22:37:14 <Pods> I got acquainted with haskell to implement semantic ontologies for search engines.
22:37:29 <Pods> is there any project related to it haskell.org is upto??
22:37:43 <Pods> Anything similar coming about for gsoc2013??
22:37:52 <wavewave> Pods: good. that's actually where haskell can excel but not very much developed yet.
22:38:18 <luite> Pods: too early to tell, but you'll be able to submit your own proposal in a month or so
22:38:30 <luite> perhaps earlier :)
22:38:41 <Pods> yes, that is where it has a foothold much stronger comapred to other languages
22:38:43 <luite> if you're a student of course
22:38:49 <Pods> luite: yes am a student :)
22:38:56 <wavewave> I remember there are some packages about rdf and semantic webs but things look not maintained much.
22:39:32 <luite> Pods: do you want to do a gsoc project?
22:39:48 <Pods> until then are there any bugs I could look at solving , any major prerequisites for gsoc apart from the main application and project proposal.
22:39:54 <Pods> Eventually yes.
22:39:55 <wavewave> luite: good to see you. I was about to try your ghcjs branch.
22:40:09 <Pods> I am planning to apply for gsoc2013
22:40:11 <luite> wavewave: oh, you'll need some unpublished GHC patches to compile it
22:40:43 <wavewave> luite : do you have some documentation on it yet?
22:41:43 <luite> Pods: obviously you need some proposal that's interesting and useful for the community, but perhaps more importantly, you need to convince the admins that you're capable of doing the project succesfully on time. so try to show what earlier work you've done
22:41:52 <luite> wavewave: uh not really sorry
22:41:58 <Ralith> mm_freak: so what'd you make of pcc?
22:42:16 <luite> wavewave: problem is that it requires GHC HEAD, and you need lots of patches to get even the dependencies to install correctly
22:42:51 <Pods> luite: yes, I undertsand that, I will be including the projects I have done so far for the admins to evaluate my competance ofcource
22:43:15 <Pods> Are there any bugs/fixes assigned to assist this mode of evaluation though
22:43:38 <Pods> Maybe something which gets beginners familiarized with the source etc??
22:44:24 <luite> hmm, i don't think there's an official policy for the haskell organization for that, but individual projects can probably do some checks
22:44:48 <wavewave> luite: i see.. I just wiped out my 5 month old ghcjs installation, so wonder whether I move gen2-alth or not
22:46:01 <Pods> okay, so until then maybe I could look into the general workings of haskell projects which have been there earlier ..and wait for the student applications to start to put up my projects and stuff ?
22:46:41 <luite> wavewave: i'm almost done adding the major features to gen2, working on weak refs and CAF retaining now (i think weak refs is the only major missing feature compared to the old code generator now)
22:47:37 <wavewave> luite: sweet.. so gen2-alth will be merged to gen2, soon.
22:47:51 <luite> nah master
22:48:13 <luite> the non-alth gen2 is less finished since it relies on a garbage collector implemented in js
22:48:31 <luite> the alth uses javascript objects
22:48:55 <wavewave> luite: I see..
22:49:03 <luite> alth still has some gc-like stuff, but that only does marking, and finalizing for CAFs and weak refs
22:50:14 <luite> wavewave: there are some cool features, `foreign import javascript' for example, with async calls: foreign import javascript safe "threadDelay(function() { $c(); }, $1);" js_sleep :: Int -> IO ()
22:50:32 <luite> wavewave: suspends the current haskell thread for the number of milliseconds, then wakes it up again
22:50:48 <wavewave> Pods: I suggest you to start with some simple parsers for semantic web things. Old codes exist, but I think it had better be rewritten anyway in my opinion.
22:50:56 <luite> of course there's threadDelay that does the same thing, but you can use this pattern for other things like ajax
22:51:30 <luite> mr <- timeout 1000000 $ js_ajax "http://blah"
22:51:34 <Pods> wavewave: that would be perfect, any links or documentations I could find for the same??
22:51:49 <wavewave> luite: cool. I am excited!
22:52:12 <luite> wavewave: lots of stuff needed to work for that, threading, async exceptions, ffi import patterns :)
22:53:18 <wavewave> Pods: look at the package swish
22:53:33 <Pods> okay :)
22:53:48 <wavewave> Pods: by the way, I just found that swish is updated recently after a long break. didn't know that.
22:54:46 <luite> wavewave: me too :) the threading code will take a while to stabilize i think, i just pushed it last week. blackholes, threading and async exceptions are pretty complex together
22:55:12 <ezyang_> heh
22:55:35 <ezyang_> At least you don't have to build it with real threads :^)
22:56:00 <Pods> wavewave : good there has been work, will go check it out :)
22:56:02 <luite> that's true
22:56:15 <wavewave> luite: sounds already complex to me. I do not understand things in detail.. but I am thinking about now it's near to have porting a bunch of javascript functions into haskell. ;-)
22:56:24 <luite> but in return i get a platform that's really not meant for this :p
22:57:10 <ezyang_> luite: Are you guys compiling into asm.js, by any chance?
22:57:17 <luite> no, at least not yet
22:57:42 <luite> i'm not sure if it's really possible to get a good benefit from asm.js
22:58:05 <luite> since javascript doesn't have tailcalls, we have to return to a main loop every time
22:58:18 <luite> where arguments are passed in global variables
22:58:33 <ezyang_> well, trampolines are going to suck for performance
22:58:39 <c_wraith> don't look at how the sausage is made
22:58:43 <ezyang_> but they're not that bad :)
22:58:58 <luite> ezyang_: the trampoline itself is not terrible actually, performance becomes much worse one you do heap allocation
22:58:59 <wavewave> btw, will it be possible to have ghcjs installation using simple cabal any time in near future?
22:59:12 <luite> wavewave: yes when 7.8.1 is out
22:59:32 <wavewave> luite: oh.. ghc 7.8 accepted some required change?
22:59:48 <luite> wavewave: uh well i still need to submit the patches :)
23:00:01 <wavewave> luite: ;-)
23:00:04 <c_wraith> better get to that.
23:00:20 <c_wraith> It's only a few months from being too late to consider new features@
23:00:24 <c_wraith> also, !
23:00:59 <wavewave> I think cabal install ghcjs is the monumental moment.
23:01:28 <luite> i have four things, one is a custom Way to allow GHCJS to keep the native and javascript platform files apart, another is something to override GHC.Prim in a GHC API program, another is adding a JavaScriptCallConv calling convention, and the last is adding JavaScript as an architecture to Platform
23:02:03 <luite> all pretty simple patches though
23:02:18 <wavewave> sounds great!
23:03:30 <wavewave> I dream that we will see javascript package on hackage..
23:03:38 <wavewave> for example, node.hs
23:03:48 <luite> what would that do?
23:03:59 <luite> cabal support is one of the things where there's still some work
23:04:23 <luite> ideally a package distributing a foreign C file should als be able to distribute a foreign .js file
23:04:40 <wavewave> luite: that's what I exactly mean.
23:04:47 <luite> and then #ifdef __GHCJS__ foreign import javascript ... #else foreign import ccall ... #endif
23:05:16 <wavewave> hQuery etc.
23:05:21 <luite> oh right
23:05:30 <luite> fay does a few of those things already
23:06:47 <wavewave> i am very interested in writing html5 canvas binding for my purpsoe.
23:06:57 <luite> oh yeah you mentioned that in a ticket
23:07:22 <wavewave> yeah. long term goal.
23:08:28 <luite> wavewave: shouldn't be that long now. hamish already has one working through jsc
23:08:37 <luite> for the old codegen
23:09:46 <wavewave> yes. I was about to try jsc. and start wondering which branch of ghcjs to be installed.
23:10:16 <wavewave> luite: probably I will be stick to master for the time being, waiting for merging gen2 into master.
23:10:21 <luite> oh that doesn't yet work with the new cg, hamish has been working on ghc while i've been doing gen2
23:10:26 <luite> right
23:11:20 <wavewave> good to know that gen2 is now forming its final shape.
23:11:37 <wavewave> how much performance gain do you expect now?
23:12:05 <luite> uh, well a lot for many things, a bit less for others ;)
23:12:17 <luite> fib n = fib (n-2) + fib (n-1) is 100x faster or so :)
23:12:29 <wavewave> oh... great!!
23:12:35 <luite> but that's probably a best case scenario for gen2
23:12:43 <luite> since it has no heap allocation at all
23:12:58 <luite> just lots of function calls through the trampoline
23:13:03 <luite> and those are a lot faster
23:13:32 <wavewave> luite : do you have a blog writing for that? or any plan to write about the detail?
23:14:26 <luite> i had hoped to stay within 10x native ghc (so 10x slower at worst usually), but that's not yet achieved...
23:14:40 <luite> fib is quite good actually, only 7x slower than native code or so
23:15:19 <wavewave> that's actually pretty good performance. faster than python ;D
23:15:33 <luite> but jsbn (bignumber) is much worse than gmp, and allocation-heavy things are also worse
23:16:27 <wavewave> the first application using ghcjs should be for GUI application for which haskell is just miserable yet.
23:16:30 <luite> maybe with a lot more finetuning, but first the basic features and usability need to be in order :)
23:16:47 <wavewave> for those code, actually 10x slower ghc code performs perfectly well.
23:16:55 <luite> oh i wasn planning on writing a paper about this... but i'm not sure now
23:17:32 <wavewave> luite: you had better write something on it. this is just great.
23:17:47 <luite> i'd like to go to icfp, but the paper deadline is in a week
23:18:32 <wavewave> I need to write something about my libraries and apps, too, though...  ahh writing is hard.
23:19:08 <ab9rf> words need to be more cooperative
23:21:23 <wavewave> major blocking step in fficxx is to write a documentation. :-P
23:24:06 <edwardk> alang: heya
23:24:11 <edwardk> alang: was suffering intermittent connectivity and was showing luqui stuff earlier
23:25:25 <alang> edwardk: hey no problem
23:25:33 <edwardk> whats up?
23:25:57 <alang> what do you think of making Lifted, Mode, Jacobian be MPTCs?
23:26:12 <edwardk> i could be talked into it
23:26:22 <alang> adding the numeric type in
23:26:32 <edwardk> actually you could do one better
23:26:40 <edwardk> if you do them as a type family then you can get defaulting
23:26:56 <edwardk> thats one big part of the current reasoning behind the separate args
23:27:09 <edwardk> but i've gotten better at getting defaulting to fire otherwise
23:27:38 <wavewave> btw, what is the most promising library for indexed monad currently?
23:27:40 <edwardk> the main thing that is important to keep is that things like diff sin 2   -- needs to keep working without annotation
23:28:03 <edwardk> wavewave: github.com/ekmett/indexed will be interesting, but whatever tekmo has released is the defacto standard right now ;)
23:29:06 <edwardk> with an MPTC it won't default the arg type to 'Double' there
23:29:13 <alang> right
23:29:16 <wavewave> edwardk: is it the same as indexed on hackage?
23:29:18 <alang> that's not very good =(
23:29:24 <edwardk> this would mean adapting the mode so that the mode contains the type argument
23:29:34 <edwardk> that actually has a ton of knock on effects, but isn't hard per se
23:30:06 <alang> you mean if we go the type family route?
23:30:07 <edwardk> wavewave: no, though since reiner took his indexed code from my category-extras he gave me permission to take back the name ;)
23:30:08 <wavewave> I am currently using it now. and confused about the relation between it and indexed-core
23:30:10 <edwardk> alang: yeah
23:30:28 <edwardk> indexed-core is the one you want, not the one based on my code
23:30:43 <edwardk> er index-core
23:30:49 <alang> so i tried to naively add a type family, but I got some GHC error and I forgot what it was
23:30:55 <alang> let me see if I can reproduce it
23:31:13 <edwardk> to get the type family is a lot of work but perfectly doable
23:31:34 <edwardk> its some scoped type variables for us, but it means you can make nicely unboxed modes for doubles, etc.
23:32:03 <edwardk> we can also likely kill most of the abs1 machinery
23:33:02 <wavewave> currently i need indexed state monad. seems that only indexed-extra provides it.
23:33:55 <edwardk> you can make an indexed state monad on the foundation provided by tekmo, its just now what you are used to
23:34:09 <edwardk> i do so in my version of indexed on github, which is based on the same kind of foundation
23:34:38 <edwardk> but i can't implement the indexed indexed-monad transformers until we get real product kinds
23:35:05 <edwardk> er *just not what you are used to
23:35:48 <wavewave> edwardk: hmm there was some theoretical issues.. i see.
23:36:01 <edwardk> alang: if you wanted to start a branch for monomorphic modes i'd happily contribute
23:36:26 <edwardk> wavewave: yeah product kinds don't evaluate to the product of their kinds =(
23:36:33 <edwardk> they are bigger
23:40:46 <wavewave> edwardk : would you elaborate it a little more?
23:41:10 <edwardk> wavewave: every kind has an extra inhabitant 'Any'
23:41:31 <elliott> edwardk: it's to emulate the fun experience of having _|_ at every level at the value level
23:41:38 <edwardk> wavewave: so (*,*)  is inhabited by '(a,b) for a :: *, b :: * and Any
23:41:40 <elliott> wouldn't be Haskell otherwise
23:41:51 <edwardk> elliott: worse its like having _|_ you can pattern match on
23:41:59 <elliott> like having unamb!
23:42:54 <wavewave> hmmm..
23:43:18 <edwardk> wavewave: the indexed repo worked around this by using 'herp' and 'derp' to match with the eta laws that should exist
23:44:09 <edwardk> wavewave: but in the presence of type families and someone importing GHC.Prim.Any you can derive unsafeCoerce with them
23:44:51 <edwardk> and without type families you can break confluence of typeclass resolution, yay
23:45:09 <wavewave> hmm...
23:45:44 <wavewave> so this is a problem in all the indexed monad implementation currently?
23:45:50 <edwardk> So 'Any' causes some serious theoretical problems
23:45:59 <edwardk> other indexed monads don't write indexed monad transformers
23:46:12 <edwardk> ever notice? =)
23:46:51 <edwardk> i'm not sure that with corrected polykinds i could, but i definitely can't without usable product kinds
23:47:30 <edwardk> i can write a monadic transformation of an indexed monad or vice versa
23:47:44 <edwardk> but they don't write indexed indexed-monad transformers
23:48:03 <wavewave> edwardk : I am confused with IMonadTrans in index-core and indexed indexed monad transformer
23:48:36 <edwardk> wavewave: try to combine indexed IndexedWriterT and IndexedState
23:48:51 <wavewave> I see..
23:48:54 <edwardk> not WriterT and IndexedState, not IndexedWriterT and State
23:49:20 <edwardk> but get an indexed monad where the index is based product-like on the indices of both
23:51:51 <wavewave> edwardk : i vaguely got your point. thanks for the clarification.
23:52:04 <edwardk> sorry it wasn't clearer. bit tired =)
23:53:45 <wavewave> edwardk: it's difficult for me anyway. I am type-system novice. thanks =)
23:55:56 <alang> edwardk: I get a "Can't represent irreducible predicates in Template Haskell: Numeric.AD.Internal.Classes.Domain t a" in the call to deriveNumeric where Domain :: (* -> *) -> * -> Constraint
23:56:23 <alang> edwardk: Do you know what this is about?
23:58:02 <alang> this is probably a bit vague
23:58:03 <alang> sec
23:59:08 <alang> edwardk: https://github.com/alang9/ad/tree/type-familize
