00:00:04 <arkeet> or at least, how to unsafeCoerce a soufflé .
00:00:07 <DanBurton> > let lookupTable = zip ['1'..'9'] [1 .. 9]; charToInt x = convertMaybe (lookup x lookupTable); convertMaybe m = case m of Just c -> c; Nothing -> 0 in charToInt 'a'
00:00:08 <lambdabot>   0
00:00:14 <shachaf> I think defaulting to 0 is awful.
00:00:19 <shachaf> Worse than an error.
00:00:24 <arkeet> I agree.
00:00:32 <shachaf> But an error is awful.
00:00:32 <lightquake> me too.
00:00:34 <arkeet> clearly, the result should be wrapped in a Maybe.
00:00:34 <DanBurton> I think it's slightly better than error
00:00:36 <shachaf> Worse than handling it correctly.
00:00:42 <ben22> "parse error (possibly incorrect indentation"
00:00:43 <ben22> convertMaybe :: Maybe Int -> Int
00:00:43 <ben22> convertMaybe x = case x of Just x -> x; Nothing undefined
00:00:51 <DanBurton> arkeet: sounds like a job for spoon
00:00:58 <shachaf> 00:00 <ben22> "parse error (possibly incorrect indentation"
00:01:00 <shachaf> I like that.
00:01:03 <shachaf> The error is self-describing.
00:01:05 <elliott> ben22: we're not going to teach you haskell syntax just by you feeding us a sequence of errors.
00:01:18 <ben22> there is no indentation error here
00:01:18 * DanBurton will >.>
00:01:25 <arkeet> but there is a parse error
00:01:31 <DanBurton> ben22: you forgot the ->
00:01:34 <DanBurton> in the Nothing case
00:01:41 <shachaf> λ> parse error (possibly incorrect indentation
00:01:41 <shachaf> <interactive>:2:44: parse error (possibly incorrect indentation or mismatched brackets)
00:01:52 <ben22> maybe it's the semi-colon
00:02:12 <arkeet> maybe it's the thing that someone told you it was.
00:02:14 <dmwit> shachaf: Now iterate to make a quine!
00:02:36 <ben22> ohhhh now it works thanks DanBu
00:02:39 <shachaf> quines don't work that way!! :-(
00:02:41 <DanBurton> ben22: you can use Haskell's whitespace sensitivity by putting Just x -> x and Nothing -> undefined on newlines
00:02:44 <elliott> {--} <interactive>:2:1: parse error on input `<'
00:02:44 <elliott> <interactive>:2:1: parse error on input `<'
00:02:47 <elliott> kimian quine!
00:02:48 <DanBurton> ben22: and omit the semicolon
00:03:01 <shachaf> elliott: I think I know what to set your prompt to.
00:03:02 <ben22> yea i'm gonna get an F on the final at this rate
00:03:07 <ion> @type maybe
00:03:09 <lambdabot> b -> (a -> b) -> Maybe a -> b
00:03:11 <shachaf> Well, OK, maybe that's cheating.
00:03:12 <ben22> I need a better way to learn haskell
00:03:14 <elliott> ben22: maybe you should put in some work.
00:03:15 <ion> @type fromMaybe
00:03:17 <lambdabot> a -> Maybe a -> a
00:03:20 <elliott> yes, we gave you several
00:03:24 <arkeet> ben22: sure, like effort, and reading.
00:03:29 <ben22> i read
00:03:49 <DanBurton> ben22: instead of <<< undefined >>>, use <<< error "zomg it's not an ideal world after all" >>>
00:03:58 <ben22> look that book is not useful to read word-for-word. just good for looking up things you need right-away
00:04:11 <arkeet> have you tried reading it in order?
00:04:15 <pharaun> ben22: try - real world haskell?
00:04:15 <DanBurton> I found it quite useful reading straight through
00:04:16 <startling> ben22: huh? no, it's great for reading in order.
00:04:18 <ben22> it's not going to help
00:04:19 <elliott> well you obviously haven't actually tried reading it word for word.
00:04:22 <arkeet> it's a pretty awful reference actually.
00:04:24 <elliott> and apparently looking things up hasn't got you very far.
00:04:29 <elliott> anyway we should really stop feeding this guy.
00:04:32 <DanBurton> arkeet: agreed
00:04:51 <ben22> look when I was a freshman at this university, I read books a lot. but I saw that my grades didn't improve at all
00:04:54 <elliott> nothing we say is going to change ben22's mind. he wants to exploit the resources of the channel, clearly
00:04:56 <ben22> so I stopped doing that
00:05:00 * DanBurton is still giving good answers
00:05:21 <ben22> yea DanBurton better than y'all
00:05:27 <ben22> thanks Dan you're awesome
00:05:28 <pharaun> ben22: well unfortunately haskell is a language that you will need to read at least this resource to learn the basics
00:05:36 <shachaf> DanBurton: Answers that reïnforce asking bad questions are not necessarily good answers.
00:05:47 <ben22> I like you bunch
00:05:50 <ben22> witty nerds
00:05:53 <pharaun> ben22: i tried to hack at xmonad for a bit, but in the end i served myself by reading the book
00:06:19 <elliott> ben22: insulting people in the channel won't get you anywhere, either.
00:06:26 <ben22> it's not an insult
00:06:34 <DanBurton> shachaf: answers that serve to confuse and drive away the one asking questions are worse
00:06:42 <ben22> better to be called a nerd than an idiot right
00:06:54 <elliott> I was referring to <ben22> yea DanBurton better than y'all.
00:07:18 <DanBurton> elliott: he was just stating fact /ducks
00:07:45 <shachaf> DanBurton: Maybe? I'm not sure that's relevant here.
00:07:50 <ben22> finally, my friends, you have helped me to get my character to an int!!
00:07:56 <ben22> was that TOO HARD?!
00:08:19 <DanBurton> we'll make a haskeller out of you yet
00:08:25 <shachaf> ben22: Look, you're just making this place unpleasant. Please stop.
00:08:37 <ben22> and how so?
00:08:55 <elliott> by persistently badgering everyone with trivial questions that we have repeatedly told you how to find the answers for.
00:09:04 <elliott> which you then refuse to do by saying patent nonsense and go around in a loop again.
00:09:11 <ben22> yea, the book. it's not there, mate
00:09:15 <elliott> and nobody accomplishes anything. you've been doing this for an hour.
00:09:20 <elliott> stop.
00:09:34 <ben22> ok elliott, since you said it nicely
00:09:43 <ben22> with good english
00:10:14 <elliott> the disrespect you're showing to people trying to help you is far greater.
00:10:23 <ben22> i'm not disrespectful
00:10:30 <ben22> i just want some help
00:10:37 <ben22> and DanBurton is a great man
00:11:20 <kqr1> i think you have different goals, or something
00:11:35 <kqr1> ben22, you don't actually want to learn the language, you want to pass the final, right?
00:11:43 <DanBurton> ben22: try reading this chapter. ctrl+f for Maybe if you must. http://learnyouahaskell.com/making-our-own-types-and-typeclasses
00:11:45 <ben22> isn't that we all want?
00:11:49 <kqr1> elliott, and you assume ben22 wants to learn the language?
00:12:07 <Iceland_jack> (please, make this stop)
00:12:26 <elliott> I assume ben22 probably doesn't want to learn the language. but I am sure that is the advice he is going to get from this channel
00:12:26 <DanBurton> kqr1: you say that as if the two options were mutually exclusive
00:12:36 <elliott> since this is #haskell, not #passingfinals.
00:12:50 <ben22> wow you guys take this so seriously o.O
00:12:56 <ben22> just chill man
00:12:58 <DanBurton> It should come at no surprise that learning Haskell will lead to passing the final
00:13:03 --- mode: ChanServ set +o elliott
00:13:12 --- mode: elliott set +b *!*benblue20@*.cg.shawcable.net
00:13:12 --- kick: ben22 was kicked by elliott (persistent timewasting)
00:13:17 --- mode: elliott set -o elliott
00:13:25 <kqr1> DanBurton, i'm assuming the final is very soon, in which case yes, they are
00:13:28 <kqr1> DanBurton, at least for a start
00:13:38 <DanBurton> oh yeah if he has a final soon he's screwed
00:13:52 <kqr1> i think he realises that somewhere about now
00:14:07 <pharaun> i never understood that attitude
00:14:32 <kqr1> pharaun, did you go to uni?
00:14:51 <DanBurton> so maybe I joined late during this ben22 debacle, but it didn't seem like he did terribly much timewasting. has he been trolling around here for a while?
00:14:58 <mysticc> I am getting this error when I am adding args annotation while using cmdargs System.Console.CmdArgs.Implicit, unexpected flag (args/argPos)?
00:15:12 <dmwit> DanBurton: yes
00:15:15 <arkeet> mysticc: paste code and error?
00:15:18 <pharaun> kqr1: yes :) a while ago
00:15:23 <kqr1> DanBurton, that and his attitude
00:15:24 <elliott> DanBurton: it was the same thing over and over again for an hour and he clearly wasn't interested in changing his behaviour or investing any effort himself.
00:15:34 <elliott> and it was taking up the entire channel
00:15:56 <pharaun> kqr1: sometime if all things failed i would do what i needed to pass exams, but overall i preferred to actually make an attempt to learn the materials *shrugs*
00:16:18 <DanBurton> i mean, he went that long badgering you guys and still didn't learn pattern matching? :/ whatevs..
00:16:48 --- mode: ChanServ set +o elliott
00:16:55 <elliott> a little birdie tells me you're meant to do it like this instead:
00:16:59 --- mode: elliott set -b *!*benblue20@*.cg.shawcable.net
00:17:07 --- mode: elliott set +b *!*benblue20@*.cg.shawcable.net$#haskell-ops
00:17:12 --- mode: elliott set -o elliott
00:17:47 <kqr1> pharaun, yeah, sure. i've found that sometimes there aren't enough time to learn something properly, in which case "just passing the final" works out better economically
00:18:21 <kqr1> pharaun, for example, if you have five weeks to learn haskell and barely any programming experience (or worse -- a lot of experience in languages like java) you'll have a hard time actually learning the language in time
00:18:29 <kqr1> pharaun, but i guess that depends on how advanced the class is too
00:19:15 <lightquake> elliott: what's the $? never seen that before
00:19:19 <kqr1> pharaun, i know almost nobody of my classmates managed to learn erlang in the three weeks (or whatever it was) they had. for me, the final was a breeze, but they had to rely on the C++ part of it
00:19:51 <mysticc> arkeet: http://hpaste.org/84024 and http://hpaste.org/84025
00:20:06 <pharaun> kqr1: ouch >_<
00:20:20 <pharaun> kqr1: my univ unfortunately was mostly a "java school"
00:20:25 <mysticc> http://hpaste.org/84025
00:20:30 <elliott> lightquake: apparently it redirects a user to another channel if they try and join
00:20:31 <kini> why did I think that A* would be a good choice for solving arbitrary 15-puzzles...
00:20:36 <pharaun> but i managed to get away from java by branching a bit into CE *shrugs* learned haskell after i left the univ
00:20:47 <DanBurton> mine too. They recently switched the intro to programming course over to C++ and called it progress :/
00:21:42 <kqr1> pharaun, yeah, mine is too. it's just that single course with three weeks of erlang in the middle of everything
00:21:44 <DanBurton> It was hilarious to see one teacher teach Intro to Programming in C++ as if it were Racket, though.
00:21:52 <kqr1> pharaun, i made sure to enjoy the hell of it 8)
00:22:14 <kqr1> +out
00:22:15 <arkeet> DanBurton: how does that work?
00:22:16 <kqr1> maybe
00:22:54 <DanBurton> arkeet: with a lot of boilerplate conventions. Immutable cons lists were taught very early.
00:23:15 <pharaun> kqr1: hehe excellent
00:24:20 --- mode: ChanServ set +o elliott
00:24:26 --- mode: elliott set -b *!*benblue20@*.cg.shawcable.net$#haskell-ops
00:24:29 --- mode: elliott set -o elliott
00:25:18 <mysticc> Any help with this cmdargs error http://hpaste.org/84024 and http://hpaste.org/84025 ? I doubt I am missing something very small.
00:25:28 <ben22> sorry
00:26:11 <DanBurton> arkeet: code sample: http://faculty.cs.byu.edu/~jay/courses/2011/fall/142/code/9-2.cc
00:26:31 <ben22> alright well, I just wanna say thanks for your help DanBurton and sorry for wasting all of your time for the others here
00:26:56 <ben22> good night
00:27:04 * hackagebot wordexp 0.2.0.0 - wordexp(3) wrappers  http://hackage.haskell.org/package/wordexp-0.2.0.0 (MatveyAksenov)
00:29:01 <dmwit> Thanks, elliott.
00:29:44 <elliott> dmwit: no problem. let's just hope it doesn't happen again.
00:30:15 <dmwit> mysticc: I dunno. Maybe the type of an "I take all the rest of the arguments you don't know what to do with" annotated thing has got to be a list or something.
00:31:18 <ag90> Hey, so in a the heap profiling log, what does "pinned" mean?
00:32:37 <ag90> I mean, the legend mentions different functions in my program, or random strings, and a "PINNED". And that seems to me taking the largest chunk.
00:34:16 <ag90> Ah, never mind. -hy refers to it as ARR_WORDS. It's all those Bytestrings.
00:34:24 <dmwit> A search for "GHC pinned" suggests that it  might be ByteStrings.
00:34:27 <dmwit> ...ah
00:34:44 <ag90> :)
00:35:24 <mysticc> dmwit: http://neilmitchell.blogspot.in/2010/08/cmdargs-example.html I tried with argPos as mentioned here and it is not working as well.
00:58:48 <kini> map is (a -> b) -> [a] -> [b]; is there something like [a -> b] -> a -> [b] ? (mapping an argument over functions rather than a function over arguments)
01:01:15 <elliott> kini: \fs x -> map ($ x) fs
01:01:46 <Fubar^> > [(+1), (+2)] <*> pure 1
01:01:47 <ag90> Or <*>: [succ, pred] <*> [1] => [2, 0]
01:01:48 <lambdabot>   [2,3]
01:01:48 <elliott> (same as (\fs x -> map (\f -> f x) fs))
01:02:41 <kini> ag90: I don't know anything about applicative style but the type signature of <*> seems almost right (just need to wrap the a in [])
01:03:08 <elliott> :t map . ($)
01:03:10 <lambdabot> (a -> b) -> [a] -> [b]
01:03:15 <elliott> oh hm, duh.
01:03:16 <kini> :t flip map (undefined :: [a -> b]) . ($)
01:03:18 <lambdabot> ((a -> b1) -> b) -> [b]
01:03:24 <kini> oops, that's not right haha
01:03:34 <elliott> @pl \x fs -> map ($ x) fs
01:03:35 <lambdabot> map . flip id
01:03:40 <elliott> :t map . flip ($)
01:03:41 <lambdabot> b1 -> [b1 -> b] -> [b]
01:03:45 <elliott> massive improvement in readability, there.
01:03:57 <kini> ... flip id!?
01:04:07 <elliott> sure. ($) is just a specialisation of id.
01:04:16 <kini> oh. right.
01:05:25 <c_wraith> if I would use ($), the no-arg section, I'll nearly always use id instead. Just because it's easier to type and I'm lazy
01:05:32 <c_wraith> I probably confuse some people doing that.
01:05:40 <sgk284> hey all, wondering if anyone could help me out with criterion. Trying to benchmark: https://gist.github.com/stevekrenzel/d501a0ddf1842f91f41c but the benchmarks are showing the function to effectively execute and finish immediately
01:06:01 <sgk284> which at first I assumed meant something wasn't being evaluated, but `nf` should take care of that, no?
01:06:28 <sgk284> I'm running the binary with: ./repmin -o repmin.html -s 10
01:09:37 <sgk284> hmm... nevermind, it seems to be working now
01:09:43 <sgk284> not sure what I changed
01:10:19 <johnw> that's so odd.  id and ($) have pretty different signatures (one is a -> a and the other is (a -> b) -> a -> b), but flip id and flip ($) have identical signatures.  How does that happen?
01:12:03 <johnw> ah, because flip is inferring id to be of type forall a b. (a -> b) -> (a -> b)
01:12:10 <johnw> that's rather clever
01:12:12 <ion> flip :: (a -> b -> c) -> b -> a -> c
01:12:16 <johnw> sounds like a good interview question :)
01:12:18 <ion> id :: d -> d
01:12:29 <ion> (d -> d) ~ (a -> b -> c)
01:12:39 <srhb> johnw: It's not that clever when you think of the definition of flip
01:12:40 <ion> a ~ (b -> c)
01:13:03 <johnw> it's kind of like a trick of the light; it's polymorphism that makes it work
01:13:35 <DanBurton> flip f x y = f y x --> flip id arg func = id func arg
01:14:04 <johnw> ah, that's helpful, thanks DanBurton
01:15:21 <DanBurton> amazing what a little alpha-varying can do
01:17:01 <kamatsu> hi all
01:17:06 <kamatsu> what pprint library should I use?
01:17:19 <srhb> kamatsu: Depends what you're doing!
01:17:31 <kamatsu> wl-pprint? mainland-pretty? hughespj?
01:18:02 <kamatsu> I am writing a pretty printer for a small haskell-like language for my students to hack on in their assignments.
01:18:37 <kamatsu> so, it doesn't have to be fast, but i'd like it to be clear and easy to read
01:21:24 <srhb> pretty is quite easy to understand, I think.
01:21:49 <ion> There are also http://hackage.haskell.org/package/wl-pprint-terminfo http://hackage.haskell.org/package/wl-pprint-extras by edwardk. I haven’t used them so far.
01:22:31 <edwardk> fwiw i mostly use ansi-wl-pprint
01:23:05 <edwardk> it has the benefits of doing all the stuff that wl-pprint does + color.
01:23:13 <edwardk> which is occasionally useful
01:23:37 <kamatsu> looks cool
01:23:51 <kamatsu> yeah, might go with that one
01:23:57 <kamatsu> does it work on windows?
01:25:00 <kamatsu> ah
01:25:14 <kamatsu> yes it does, cool. Thanks
01:31:13 <snowylike> where could i find a good introduction to parser combinators?
01:32:15 <johnw> the Parsec manual is not bad
01:33:11 <ag90> There's also the Parsec chapter in Real World Haskell.
01:34:03 <ag90> Though, that probably assumes that you read the previous chapters.
01:34:50 <snowylike> that's not a real problem, I'm not in a hurry
01:35:06 <supki> write yourself a scheme has a bunch of parsing exersices which could be useful as well
01:35:47 <snowylike> so that's three things I can look at
01:35:53 <snowylike> should be enough for now, thanks for the help
01:38:29 <ion> The Parsec chapter in RWH uses an old Parsec API IIRC. But the concepts apply, you just have to look up the new way to do it from the Parsec documentation.
01:38:54 <srhb> Be warned, I think many of the RWH examples are actually broken nowadays.
01:38:54 <pharaun> weee
01:38:54 <pharaun> i think i finally got fd passover via exec to work
01:38:54 <pharaun> that was/is a little gross
01:39:02 <pharaun> yeah i had that trouble ^
01:39:13 <pharaun> it was a good kickstart but yeah you're going to have to find the new way of doing it
01:39:30 <snowylike> okay
01:39:35 <srhb> I didn't find it useful, but I was at a very early stage of Haskelling when I read the RWH chapters on Parsec.
01:39:42 <srhb> It was mostly confusing because things didn't work.
01:48:21 <DanBurton> SoH should start producing the new generation of RWH/LYAH-esque content
01:53:39 <mauke> kini: sequence
02:11:46 <`ramses> Anyone here has an opinion about Awodey's book on category theory?
02:12:24 <startling> `ramses, basically everyone was recommending it some time ago
02:12:41 <startling> (I haven't read it, the name just stuck with me)
02:16:35 <`ramses> startling: ah, that's encouraging :) I'm trying to determine whether it is a good starting point to get into the subject
02:19:22 <johnw> `ramses: it's a good book, just be ready to put in the work
02:19:36 <johnw> I'm still reading Lawvere's book as a kind of intro to that noe
02:20:14 <`ramses> johnw: which one of Lawvere?
02:20:24 <johnw> Conceptual Mathematics
02:20:40 <johnw> it has a lots of pictures to help you visualize mappings into Set
02:21:13 <johnw> some in ##categorytheory call it "the baby book", but that suits me perfectly
02:22:47 <`ramses> johnw: ah, I hadn't seen that one yet, might indeed be interesting to start with then. Do you like it?
02:26:00 <johnw> yes, I do
02:26:21 <johnw> it's approachable, and pretty easy to read, but it doesn't gloss things over either
02:31:11 <`ramses> johnw: okay, sounds like what I'm looking for :)
02:33:11 <johnw> also, Awodey assumes a bit of background with linear and abstract algebra, while Lawvere's book mainly relies on set theory
02:34:54 <`ramses> johnw: then it depends on what background that is, I know quite some linear algebra and group theory, stuff like rings etc. is rustier. I actually suspect I might be better with algebra then set theory..
02:34:55 <`ramses> s/then/than
02:35:33 <johnw> with the pictures, you don't need much set theory either
02:35:42 <johnw> the concepts of membership and mappings are made visual
02:38:51 <`ramses> okay, I don't suspect I'd have many problems with set theory anyway, just never used it much
02:50:34 <sopvop> edwardk: here?
02:50:40 <edwardk> ish
02:51:31 <sopvop> Trifecta does break if passed empty strand with non empty delta. Have to use LineDirective when cutting out comments.
02:52:03 <edwardk> I'd be happy to take a patch. i haven't looked at that portion of the code in quite a while
02:53:55 <sopvop> I can't imagine where to look :)
02:54:34 <mikeplus64> > fmap (\ ~_ -> "why can't it be lazy?") (let x = x in x) :: Maybe String
02:54:38 <lambdabot>   mueval-core: Time limit exceeded
02:55:00 <mikeplus64> > fmap (\ ~_ -> "why can't it be lazy?") (Just (let x = x in x)) :: Maybe String
02:55:01 <lambdabot>   Just "why can't it be lazy?"
02:55:07 <elliott> ~_ = _
02:55:19 <mikeplus64> ~_=_
02:55:30 <mikeplus64> some kind of pirate smiley
03:04:54 <pharaun> @version
03:04:54 <lambdabot> lambdabot 4.2.2.1
03:04:54 <lambdabot> darcs get http://code.haskell.org/lambdabot
03:43:21 <canta> blist
03:43:24 <canta> sry
03:55:24 <johnw> i thought this was an alist channel
03:55:38 <srhb> alist?
03:55:48 <johnw> A list
03:55:53 <johnw> like, cream of the crop
03:55:56 <srhb> Ah
03:56:31 <tdammers> association list. [(k,v)]
03:56:37 <srhb> Yeah that's what I thought too :P
03:56:49 <tdammers> functional programming does that to you
04:02:39 <basdirks> if I have a Word8 12 which in binary looks like "1100", can I efficiently pop off all unset bits on the right hand side?
04:04:17 <typoclass> > (reverse . dropWhile (== '0') . reverse) "101100"
04:04:19 <lambdabot>   "1011"
04:04:32 <typoclass> ;-)
04:05:00 <basdirks> yeah, but I probably want to avoid changing type on my Word8
04:05:03 <basdirks> is that inevitable?
04:05:32 <typoclass> basdirks: my suggestion was meant as a joke
04:05:51 <basdirks> sure
04:06:16 <typoclass> basdirks: you could divide by 2 repeatedly
04:06:39 <basdirks> yeah
04:07:09 <arkeet> just watch out for 0
04:07:35 <basdirks> that works, but if I magically shiftR to a number with no leading 0's that would be le awesome
04:07:45 <typoclass> > let pop x = if x `mod` 2 == 0 then pop (x `div` 2) else x in pop 1234
04:07:47 <lambdabot>   617
04:07:52 <arkeet> > let pop x = if x `mod` 2 == 0 then pop (x `div` 2) else x in pop 0
04:07:56 <lambdabot>   mueval-core: Time limit exceeded
04:08:07 <typoclass> arkeet: plagiator!
04:08:08 <typoclass> ;-)
04:08:34 <basdirks> quot and rem are faster for me btw
04:09:12 <arkeet> shouldn't bit testing/shifting be fastest?
04:09:35 <basdirks> yeah probably, I'll try
04:10:09 <paolino> good day, I have a problem with  ambiguous types
04:10:18 <hpaste> paolino pasted “ambiguous types” at http://hpaste.org/84028
04:11:54 <paolino> I'm not sure what is related to, if it's for the phantom type , or the list in the class
04:12:05 <paolino> or none of those :-/
04:12:26 <notdan> What is the way to do functor composition in Haskell?
04:12:32 <paolino> if anyone can explain, please
04:13:37 <paolino> :type (<$>)
04:13:39 <notdan> Say, I have a data N n = N { unN :: n Int }. I want to write a type signature of a function which takes N n (assuming n is a functor) and a function (Int -> m Int) for some functor m and return a N (m . n)
04:14:44 <notdan> paolino: <$> is just a synonim for fmap
04:14:52 <notdan> synonym*
04:14:56 * typoclass has no idea about type families. typoclass also has no idea what it means when ghc says "NB: `Taglia' is a type function, and may not be injective"
04:15:03 <typoclass> :t (<$>)
04:15:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:15:32 <supki> typoclass: type families are not injective
04:15:35 <mikeplus64> notdan: .
04:15:50 <mikeplus64> oops didn't read after
04:16:02 <mauke> typoclass: that tends to mean you've got something like 'Taglia a :: B' but you can't deduce a from B
04:16:12 <Cale> notdan: There's a library or two defining explicit functor composition...
04:16:37 <mauke> because Taglia A1 and Taglia A2 may be both B for different A1, A2
04:16:45 <supki> @hoogle Compose
04:16:45 <lambdabot> Data.Functor.Compose Compose :: f (g a) -> Compose f g a
04:16:45 <lambdabot> Data.Functor.Compose newtype Compose f g a
04:16:45 <lambdabot> package compose-trans
04:17:00 <mikeplus64> notdan: i'm not sure you can change the functor though, i think haskell functors are endofunctors
04:17:02 <typoclass> mauke: hmm interesting
04:17:12 <notdan> Cale: but is there a good way without all the wrapping/unwrapping?
04:17:40 <Cale> notdan: no
04:17:49 <Cale> notdan: http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Data-Functor-Compose.html#t:Compose
04:18:31 <Cale> There's even http://hackage.haskell.org/packages/archive/comonad-transformers/3.0.1/doc/html/Data-Functor-Composition.html -- because too many people have had to reinvent functor composition.
04:21:12 <mikeplus64> with TypeOperators you could probably use a ⋅ or similar if you don't like Compose, or :.: or whatever is popular
04:21:40 <notdan> Ok, thanks
04:21:42 <paolino> mauke, is my problem related to type families ?
04:22:01 <mauke> paolino: no idea
04:23:13 <basdirks> typoclass, arkeet, testBit/shift is as fast as odd/quot 2
04:23:19 <mauke> I tried looking at your code but it was too hard (too many unfamiliar concepts at once: custom kinds, GADTs, type families, all identifiers in Italian)
04:23:27 <mauke> so I just gave up
04:23:39 <arkeet> basdirks: maybe it gets compiled to the same code
04:23:44 <basdirks> yep
04:24:14 <basdirks> for large numbers it is probably actually faster to use typoclass's "joke" solution
04:24:23 <arkeet> haha
04:24:54 <typoclass> performance is just very counterintuitive ... which is why profiling is so important
04:25:19 <mauke> > let foo n | n .&. 1 /= 0 = n | otherwise = foo (n `shiftR` 1) in foo 12
04:25:21 <lambdabot>   3
04:25:49 <paolino> mauke, I can resolve the italian identifiers :-P
04:27:17 <paolino> but I see the not injectiveness can make it impossible to select class instances
04:27:28 <elliott> you might want a data family
04:28:17 <basdirks> mauke yes, I had that
04:28:28 <paolino> elliot , oh, that should be injective
04:30:11 <paolino> in fact, it does compile. Thanks elliott
04:34:47 <elliott> :)
05:11:59 <notdan> I think I found a broken link on Hackage, where should I report this?
05:12:11 * hackagebot hS3 0.5.7 - Interface to Amazon's Simple Storage Service (S3)  http://hackage.haskell.org/package/hS3-0.5.7 (GergelyRisko)
05:12:19 <notdan> (broken link in the base package)
05:12:48 <notdan> .. and you know, broken formatting in general: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#Functor
05:13:06 <basdirks> typoclass, arkeet, I think I can just change endianness on the number
05:13:52 <typoclass> notdan: http://hackage.haskell.org/package/base-4.6.0.1 says the maintainer is libraries@haskell.org
05:14:14 <typoclass> notdan: wait, they even have a bug tracker listed :-)
05:18:27 <elliott> notdan: the broken links are weird ghc internal stuff
05:18:41 <notdan> typoclass: right, thanks
05:18:48 <elliott> that broken formatting thing is due to questionable handling of literate haskell, i think
05:18:54 <elliott> but, you should probably report this as a bug in haddock, not base
05:19:38 <elliott> or maybe even hscolour for the source one...
05:19:58 <sclv> what's broken about that formatting?
05:20:22 <notdan> sclv: the \end{code} %********************************************************* %* * \subsection{The list type} %* * %********************************************************* \begin{code}  thing?
05:20:45 <sclv> but that's what it says in the source file!
05:20:54 <sclv> that's literate haskell style with tex
05:21:18 <sclv> that's the actual text in the file -- there's no other way to display it
05:21:23 <notdan> Hm.. true. I guess that' snot a bug per se
05:21:41 <sclv> that's a source listing. if it showed me anything other than the actual source, i'd be peeved
05:21:46 <notdan> I just assumed that the haddock would treat it in a more sublte way
05:22:10 <sclv> if there was a full haddock it would ignore it, typically. that's the actual source listing.
05:22:14 <notdan> still, there is this broken link thing: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Functor
05:22:23 <notdan> if you try pressing the (,) a link
05:22:54 <sclv> yeah, the links i think are a real issue
05:23:19 <notdan> Ah dammit, I spent quite a bit of time writing abstract functions over functors when I've realized that neither Set nor MultiSet are functors :(
05:23:22 <elliott> sclv: it should show it in monospaced font.
05:23:34 <elliott> since right now it just all gets jumbled together (is it interpreting it as HTML?)
05:23:41 <notdan> and I suspect there is no way to make them functors without abusing the compiler or whatnot
05:23:47 * sopvop wonders why it is so hard to get proper output from "easy to use" PrettyPrinting combinators...
05:24:43 <sclv> elliott: yeah, block formatting for literate blocks might help, i suppose
05:26:01 <sclv> oddly enough, it keeps everything in <pre> tags _except_ the literate bit. so this was a design decision, if no a wise one :-)
05:26:54 <elliott> yeah, if you look at the html source it is just inlining it directly in the html
05:27:08 <elliott> so you can use hscolour to format your literate haskell and HTML programs
05:27:14 <elliott> which I'm sure is useful to about 3 people in the world :P
05:27:23 <elliott> I guess it's good for blog posts
05:27:47 <quchen> Does anyone know why you most of the GHC.* packages from Base don't have their source online?
05:28:07 <quchen> http://hackage.haskell.org/package/base
05:28:17 <sclv> haddock is just spotty on how it builds some internal stuff
05:28:28 <quchen> Hmm
05:28:33 <sclv> i'm sure patches would be welcome
05:28:37 <quchen> To look at GHC.Bool I have to go back to version 3
05:28:50 <supki> quchen: they have their source online, but not on hackage :]
05:28:58 <sclv> for browsing ghc internals i find its better to browse the actual repo
05:29:15 <typoclass> so in summary, hscolour should escape the tex parts of .lhs files, so that browsers show them correctly? i.e. the usual &lt; and &amp; stuff
05:30:00 <elliott> typoclass: not just escape, format in monospace
05:30:10 <elliott> i.e., there should simply be a way to turn off its special handling of .lhs (and it should be default)
05:30:27 <typoclass> elliott: right
05:31:13 <quchen> supki: Where can I find it then?
05:31:27 <supki> quchen: http://www.haskell.org/ghc/docs/7.6.1/html/libraries/index.html
05:32:06 <Saizan> notdan: you can have Traversal's for them i think though, which could be just as nice
05:33:19 <supki> hmm
05:40:19 <quchen> Finding "data IO" in the Haskell source is like needles and haystacks.
05:40:42 <quchen> Except there's someone pointing you to a new haystack every time you see something that might work
05:43:28 <elliott> quchen: note that what you find will be a GHC-specific definition, and it isn't quite what it looks like.
05:49:52 <supki> quchen: probably because IO is a newtype
05:50:28 <davean> quchen: newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
05:50:42 <davean> ?
05:55:09 <quchen> davean: Maybe. Where's that in the source?
05:56:05 <Kinnison> Is State# ST ?
05:56:14 * Kinnison understood IO to be a mutated ST
05:57:05 <quchen> Haha. Found RealWorld: https://raw.github.com/ghc/packages-base/master/GHC/Base.lhs
05:57:08 <Jonno_FTW> how do I stop a lazy bytestring being printed as Chunk "text" Empty? do I have to use unpack?
05:57:13 <quchen> At the very bottom, in an #ifdef HADDOCK
05:57:21 <quchen> So it really *is* magic
05:59:58 <davean> quchen: http://www.haskell.org/ghc/docs/7.6.1/html/libraries/ghc-prim-0.3.0.0/src/GHC-Types.html
06:00:22 <davean> quchen: but really, these are compiler primatives
06:00:30 <davean> To understand them you should read the GHC source code.
06:01:13 <quchen> I'm not sure the GHC source is suitable for me
06:01:14 <Jonno_FTW> well?
06:01:35 <davean> quchen: Hum?
06:02:12 <quchen> davean: I can't just look at the source of GHC. It seems like a giant project to understand even small parts of it.
06:03:37 <elliott> quchen: the most important thing to realise is that (State# RealWorld) doesn't exist.
06:03:43 <elliott> at runtime, it is 0 bits worth of information.
06:03:47 <elliott> it is no "state" at all.
06:07:14 * hackagebot syntactic 1.6.1 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-1.6.1 (EmilAxelsson)
06:37:00 <turiya> hi
06:38:01 <hpaste> turiya pasted “memory” at http://hpaste.org/84031
06:38:09 <turiya> hi
06:38:26 <notdan> hello
06:38:38 <turiya> i am trying to find why my program consumes so much of memory
06:39:16 <turiya> even after strictness annotations, it is at http://hpaste.org/84031
06:39:57 <quchen> Have you profiled it?
06:40:03 <notdan> turiya: I am quite a newbie in the area of optimization of Haskell programms, especially when it comes to laziness, but I can recommend using several tools from Don's answer: http://stackoverflow.com/questions/3276240/tools-for-analyzing-performance-of-a-haskell-program/3276557#3276557
06:41:13 <shachaf> You should ask questions like that by @pasting a complete, runnable program.
06:41:25 <turiya> notdan: thanks for the link
06:41:27 <shachaf> With type annotations!
06:41:54 <turiya> shachaf: oh, i will do so. ( i was running the code in ghci)
06:42:41 <shachaf> Oh, that's probably the first problem, then. :-)
06:42:55 <supki> I don't get the point of !acc
06:43:11 <ab9rf> ghci is a memory pig
06:43:39 <ab9rf> it's always fun to watch it grab 2 gigs of RAM for a fairly simple program
06:43:51 <otend> I'm up to five chapters through LYAH.  Would you guys have any suggestions as to what to practice with?
06:43:56 <otend> I honestly can't think of anything.
06:44:04 <Martty> something useful
06:44:05 <otend> (i.e. what to make using basic concepts)
06:44:15 <ab9rf> otend: if you're otterly at ends for ideas, try solving some of the euler problems
06:44:20 <otend> mmkay
06:44:24 <srhb> ab9rf: Urgh
06:44:27 <srhb> I can't second that suggestion
06:44:40 <ab9rf> srhb: shrug
06:44:50 <ab9rf> i did about 30 of them when i was first learning haskell
06:44:51 <otend> I got stuck on one earlier.  well, less "stuck," more "my algorithm is terrible what am I doing"
06:45:03 <otend> know what I mean?
06:45:19 <Martty> yeah, we're no match for mr euler
06:45:40 <ab9rf> wrote some really crappy haskell doing them too
06:45:43 <hpaste> turiya revised “memory”: “memory” at http://hpaste.org/84031
06:47:13 <turiya> supki: i was trying to make that strict.. is there anything wrong with that?
06:47:15 <ab9rf> i admit that i learned more writing a simple web app in haskell
06:47:54 <quchen> srhb: I second that not seconding. ProjectEuler teaches Haskell like writing children books makes you an author.
06:48:37 <Kinnison> I find playing with PE helps me to exercise my haskell muscles, but it's certainly not a way to learn
06:48:57 <supki> turiya: I don't think it's "wrong", just useless
06:49:04 <otend> I'm basically trying to not forget everything
06:52:15 * hackagebot FailureT 15778.1 - Failure Monad Transformer  http://hackage.haskell.org/package/FailureT-15778.1 (MatthewFarkasDyck)
06:53:50 <ab9rf> otend: oh, you will forget everything, but that's normal
07:02:19 <supki> turiya: also, why are you accumulating list instead of producing right away?
07:05:28 <turiya> supki: frankly, i don't know. this was just one of the ways in which i could write a correct program. there might be better methods but i dont know them.
07:06:38 <turiya> btw, that program consumes 219 Mb of heap whereas it should only take about 10Mb.
07:07:11 <Botje> turiya: lists are awful memorywise
07:07:56 <Botje> turiya: also, forcing acc like that won't help
07:08:12 <supki> turiya: well, you are storing a list of 2095103 elements
07:09:07 <ab9rf> heh
07:09:49 <turiya> supki: i get a list of 1024x1024 tuples
07:09:50 <Botje> turiya: switching to strict pairs might help, since you save two pointers per vector element
07:10:24 <supki> turiya: how can I check that result is correct without printing that vector?
07:10:27 <turiya> total memory for that should be 1024x1024x8 (for the two Ints), which is approximately 10Mb
07:10:52 <Botje> turiya: a tuple is more than just two pointers.
07:11:10 <Botje> it's a data constructor for (,) plus two pointers to Ints plus two Int#s
07:11:14 <turiya> supki: i dont think i can check that
07:11:29 <shachaf> Botje: (Int,Int) will also have the I#s
07:11:30 <quchen> I'm not even sure what the code is supposed to do. Maybe there's a better algorithm?
07:12:07 <turiya> it is supposed to generate neighbours in a 1024x1024 grid
07:13:07 <basdirks> why does unsafeRead etc only take Ints?
07:13:16 <turiya> the case expressions are for handling the cases on the boundary
07:13:25 <srhb> :t unsafeRead
07:13:26 <lambdabot> Not in scope: `unsafeRead'
07:13:48 <ab9rf> so basically you iterate from 0 to m*n-1 and accumulate each value?
07:14:03 <turiya> yes
07:14:10 <basdirks> :t Data.Array.Base.unsafeRead
07:14:12 <lambdabot> (Ix i, Data.Array.Base.MArray a e m) => a i e -> Int -> m e
07:14:34 <ab9rf> i'm sure that can be produced lazily
07:15:00 <supki> ab9rf: why not?
07:15:12 <ab9rf> supki: i don't see a reaso why not
07:15:24 <ab9rf> it looks like each value is indepndent of others
07:15:47 <ab9rf> the inner generator doesn't manipulate acc other than to append things to it
07:15:55 <ab9rf> or actually prepend
07:16:15 <johnw> turiya: all the tuples you're putting into your list in allAdjRegsf contain thunks
07:16:22 <johnw> i+n, i+1, etc.
07:16:46 <ab9rf> so just generate it backwards
07:17:00 <johnw> I think you want let !x = i+1 in (i,x) : acc
07:17:29 <turiya> johnw: i see that now
07:18:20 <turiya> johnw: but doesn't the !acc evaluate those thunks
07:18:33 <johnw> !acc does not force evaluation
07:18:36 <johnw> it sequences evaluation
07:18:58 <quchen> Well, it forces WHNF
07:19:02 <johnw> also, it's only WHNF
07:19:09 <turiya> oh..
07:19:14 <johnw> tuples are a classic place where people accumulate thunks
07:19:21 <byorgey> weak head normal form for a tuple is  (THUNK, THUNK)
07:19:25 <turiya> can i use something like deepseq
07:19:27 <byorgey> as opposed to just THUNK
07:19:30 <johnw> deepseq is overkill
07:19:43 <johnw> just using strictness annotations for the values you're putting in the tuples
07:20:04 <johnw> either x `seq` (i,x), or let !x ... in (i,x)
07:20:24 <turiya> johnw: i see, i will try that
07:21:02 <johnw> you could also use ghc-heap-vis to look at your list before you print it
07:21:09 <johnw> that might be very illuminating
07:21:09 <turiya> ab9rf: i could not follow "just generate backwards"
07:21:58 <supki> turiya: iterate from m*n-1 to 0
07:22:24 <supki> (without acc, that is)
07:22:58 <ab9rf> yes thank you
07:22:59 <turiya> i will try both the solutions and get back.. thanks
07:23:03 <ab9rf> you don't need acc at all
07:23:15 <ab9rf> just have allAdjRefsf generate one list (possibly empty)
07:23:32 <johnw> yes, if you can build the list such that earlier values are not needed after being printed, and later values are not generated until they are needed, then your total heap utilization will be close to the size of a single tuple!
07:23:36 <ab9rf> use 0 as your bottom casestart at n, and go backwards
07:23:53 <ab9rf> you don't need t accumulate
07:24:07 <ab9rf> you can eliminate the accumulator entirely
07:24:46 <turiya> i will try to see if i can do that
07:29:25 <ab9rf> d;oh
07:30:08 <ab9rf> wow, that spews a lot of output
07:30:39 <hpaste> turiya revised “memory”: “memory” at http://hpaste.org/84031
07:31:26 <johnw> turiya: return Maybe (Int,Int) from allAdjRefsf
07:31:36 <johnw> and use catMaybes instead of folding ++
07:31:47 <ab9rf> johnw: needs to be [(Int,Int)], it can return two tuples in some cases
07:31:51 <johnw> ah
07:32:03 <johnw> then use a DList at least
07:32:08 <johnw> folding ++ is going to suck
07:32:10 <turiya> oh..i see
07:32:30 <johnw> or does Haskell know to do in-place snocs?
07:32:51 <johnw> turiya: or, you could use Data.Sequence
07:32:54 <shachaf> Instead, you should foldr (++)
07:32:55 <ab9rf> hm, i wouldn't fold ++
07:32:55 <supki> foldring (++) should be ok
07:33:09 <shachaf> (++) wants to be foldred, not foldl'ed.
07:33:10 <johnw> ah, foldr (++), that's the trick
07:33:11 <ab9rf> i actually wrote an explicit recursion
07:33:15 <ab9rf> but foldr (++) is fine
07:33:51 <shachaf> @src concat
07:33:51 <lambdabot> concat = foldr (++) []
07:33:59 <johnw> shachaf: doh!
07:34:01 <supki> @src concatMap
07:34:01 <lambdabot> concatMap f = foldr ((++) . f) []
07:34:17 <johnw> shachaf: sometimes I miss the forest for the trees
07:35:00 <supki> so allAdjRegs would be  VU.fromList (concatMap allAdjRegsf [0..n*m-1])
07:35:15 <supki> ..and I think you forgot to reverse iteration
07:35:20 <ab9rf> turiya: i think one of your cases is incorrect, too
07:35:47 <turiya> ab9rf: oh, which one
07:36:01 <turiya> i just tried foldr1, it works very well
07:36:02 <ab9rf> in the x==0 case you generate [(i,i+1),(i,i+1)], which is the same tuple twice
07:36:15 <ab9rf> i don't think that's what you intend
07:36:24 <shachaf> turiya: Please take supki's advice.
07:37:11 <shachaf> There are a few advices here: Use foldr (with [] as the base case) instead of foldr1. Use concat instead of foldr (++) []. Use concatMap instead of concat and and a list comprehension (optional).
07:38:01 <turiya> ab9rf: true, one of them is (i,i+n), thanks
07:38:35 <ab9rf> do you care what order the tuples are generated in?
07:38:45 <turiya> no
07:38:57 <ab9rf> if not, then just concatMap the inner function over the list comprehension
07:39:06 <johnw> shachaf: what's wrong with foldr1?
07:39:23 <shachaf> It's partial.
07:39:31 <johnw> ah, true
07:39:45 <shachaf> There is no point to using it here, given that (++) has a simple identity.
07:39:49 <turiya> with foldr1, my heap size became 70mb (from 291 mb)
07:40:29 <shachaf> :-(
07:41:00 <johnw> i haven't seen a shachaf frownie in ages
07:41:13 <turiya> i did not understand the concatMap route
07:41:24 <shachaf> Well, that part is optional.
07:41:31 <johnw> turiya: it's the same route, just more succinct
07:41:35 <shachaf> > foldr1 (++) ["ab","cde"]
07:41:38 <lambdabot>   "abcde"
07:41:43 <shachaf> > foldr1 (++) []
07:41:45 <lambdabot>   *Exception: Prelude.foldr1: empty list
07:42:03 <shachaf> > (foldr (++) [] ["ab","cde"], foldr (++) [] [])
07:42:05 <lambdabot>   ("abcde",[])
07:42:11 <ab9rf> shachaf: allAdjRegsfff len = concatMap allAdjRegsf [0..len]
07:42:17 <shachaf> ab9rf: I know.
07:42:23 <shachaf> Therefore you should use foldr instead of foldr1.
07:42:29 <shachaf> Now, foldr (++) [] has a name:
07:42:32 <shachaf> @src concat
07:42:32 <ab9rf> shachaf: sorry, wrong complete
07:42:32 <lambdabot> concat = foldr (++) []
07:42:33 <ab9rf> i'm tired
07:42:58 <ab9rf> and i have trouble thinking when blue's clues is on in any case (the wonders of having small children)
07:51:27 <turiya> i would not have understood what was wrong with my program without all of your help.. thanks
07:52:38 <turiya> i am now thinking if i can still reduce the heap size (from 70mb)..
07:53:10 <ab9rf> i'm wondering how much of that is the Vector
07:53:43 <turiya> how can I know that
07:55:25 <turiya> i think i can remove the Vector and see !
07:59:01 <turiya> ab9rf: wow, without the Vector, i get 1MB. :)
07:59:41 <ab9rf> turiya: go figure
08:00:09 <supki> (that doesn't mean vector takes 69mb)
08:02:16 * hackagebot monomorphic 0.0.1.2 - Library to convert polymorphic datatypes to/from its monomorphic represetation  http://hackage.haskell.org/package/monomorphic-0.0.1.2 (HiromiIshii)
08:03:01 <turiya> i will try to figure why this is so, may be later..
08:03:11 <turiya> thanks for all your help
08:03:34 <turiya> ab9rf++
08:03:37 <turiya> supki++
08:03:50 <turiya> shachaf++
08:03:54 <turiya> johnw++
08:03:58 * johnw claps
08:04:51 <johnw> well, the vector has to represent the whole list in memory
08:05:00 <johnw> as a lazy list, you only ever need to represent a single tuple at a time
08:05:10 <johnw> if all you're doing is printing them, that is
08:05:17 <johnw> oh, he's gone
08:12:16 * hackagebot monitor 0.1.0 - Do things when files change.  http://hackage.haskell.org/package/monitor-0.1.0 (MartinStensgard)
08:17:34 <byorgey> hmm, looks like 'monitor' is linux-only?
08:21:44 <johnw> byorgey: hobbes does the same thing, and works on mac
08:22:49 <ocharles> heh, hobbes is our test/ci server - I was a bit confused reading that at first :)
08:23:58 <byorgey> oh, looks like there's fsnotify, which is used by yesod and claims to be cross-platform
08:24:12 <ocharles> I just use inotifytools and a little bit of bash
08:24:25 <johnw> there you go, 4 solutions to the same problem
08:24:30 <johnw> if only I could mappend them...
08:53:00 <saml> hey
08:58:34 <srhb> saml: Hey!
08:58:55 <saml> srhb, how do you deserialize json to polymorphic data?
08:59:07 <saml> let's say you have data Foo, Bar  both are instance of typeclass FooBar
08:59:17 <saml> given json, I want a FooBar instance
08:59:27 <saml> Foo has constructors Foo1, Foo2, ...
08:59:45 <saml> depending on json structure, i want to get a data
08:59:57 <saml> maybe i should just write this manually
09:00:33 <saml> you can't get a tree of all instances and constructors of FooBar  with their signature (types, names for records..) to unify it with json, right?
09:02:00 <srhb> saml: Isn't that basically what aeson does?
09:02:11 <srhb> Well, It does the parsing at least
09:03:04 <srhb> I'm not sure it's particuarly useful to have a tree of those values though, but I may be wrong.
09:04:34 <saml> let me try aeson
09:07:18 <absence_> is there a way to convert a strict bytestring to lazy? pack . unpack?
09:07:20 <srhb> saml: If you just want to see the direction serialization, decode yourJsonHere :: Result JSValue
09:07:43 <srhb> absence: Something that rhymes with chunk, I think.
09:07:53 <mauke> fromChunks . (: [])
09:08:25 <absence> cool, thanks
09:10:25 <byorgey> absence: pack . unpack is like going to the store, buying some groceries, and then shipping them to your uncle in New Zealand and asking him to ship them back to your house
09:12:26 <absence> so if i want to process a huge binary file using Control.Proxy instead of lazy io, can i just make a producer that reads a fixed amount of bytes from the handle (say 64k) and then use fromChunks to get a lazy bytestring i can read single bytes from as if it was the full file, without destroying performance due to single-byte reads?
09:13:12 <shachaf> Didn't you just say you want to avoid "lazy io"?
09:15:24 <ab9rf> byorgey: heh
09:16:07 <absence> shachaf: yes
09:16:25 <shachaf> So I'm not sure what you mean by "lazy bytestring".
09:16:26 <fryguybob> byorgey: What if you live in New Zealand with your uncle?
09:17:46 <absence> shachaf: just that :) the idea was that Control.Proxy will trigger the producer, causing a strict read, whenever the lazy bytestring is out of data
09:18:25 <shachaf> So -- you want lazy I/O?
09:18:31 <fryguybob> I suppose that's when you have {-# RULES "pack/unpack" ... #-}
09:18:43 <shachaf> I must be misunderstanding.
09:19:20 <absence> shachaf: "lazy io" without the unsafePerformIO stuff
09:19:47 <fryguybob> "trigger ... causing a strict read..." => unsafePerformIO
09:20:25 <absence> fryguybob: except it's not unsafe in this case, since the producer is in the IO monad and has the handle
09:20:42 <srhb> I'm not sure unsafe means what you think it means
09:20:52 <mauke> absence: how is that not unsafe?
09:21:11 <mauke> all possible "producers" are in the IO monad, otherwise unsafePerformIO foo wouldn't typecheck
09:21:25 <absence> mauke: it doesn't perform IO outside the IO monad
09:21:40 <mauke> yes, that's what unsafePerformIO does
09:21:59 <absence> unsafePerformIO performs IO outside the IO monad right?
09:22:07 <mauke> does it?
09:22:18 * hackagebot binary-bits 0.3 - Bit parsing/writing on top of binary.  http://hackage.haskell.org/package/binary-bits-0.3 (LennartKolmodin)
09:22:18 <absence> you can call it from pure code
09:22:24 <mauke> yes
09:22:31 <shachaf> I think you mean unsafeInterleaveIO, not unsafePerformIO.
09:22:38 <mauke> that's what you're saying you want to do
09:22:48 <absence> mauke: that's what i'm saying i DONT want :)
09:23:00 <mauke> yes, but you're contradicting yourself
09:23:42 <absence> maybe, but i'm still not saying i want to perform IO from pure code
09:24:16 <shachaf> What is it that you want to avoid, and what is it that you want to do, and how are they different?
09:25:46 <absence> shachaf: i want to read (and process) a file piece by piece without performing IO from pure code
09:26:56 <shachaf> Hmm.
09:27:00 <shachaf> I recommend listening to mauke.
09:27:26 <mauke> I recommend listening to shachaf
09:27:28 <srhb> Isn't that impossible in this sense of "performing IO from pure code"?
09:27:43 <fryguybob> absence: Consider what would happen if the IO failed.  What happens to the pure value?
09:27:45 <srhb> I mean, you want your pure code to alter the behaviour of the file reading
09:28:09 <srhb> (Just like if I only ask for the first character in a lazily read file)
09:28:19 <srhb> Which, as far as I know, requires unsafeInterleaveIO
09:29:33 <srhb> NOt that _you_ have to use unsafeInterleaveIO directly
09:29:51 <absence> fryguybob: i'm not entirely sure how Control.Proxy handles that
09:29:56 <srhb> And by the way, I recommend not listening to me, since I'm not sure what you're doing.
09:30:13 <tertl3-laptop> what does (..) mean here module MyData
09:30:13 <tertl3-laptop>     (MetricUnit(..),
09:30:28 <srhb> tertl3-laptop: Every constructor of that type
09:30:31 <fryguybob> absence: Don't worry about Control.Proxy.  What does it mean for a pure value?  Can it still be "pure"?
09:30:32 <absence> fryguybob: i think the pipeline breaks up and you can report an error or something, but i'm still new to this lib
09:30:50 <absence> fryguybob: Control.Proxy is the domain of my question
09:30:52 <fryguybob> So sometimes your pure value is the contents of the file and sometimes it is part of the contents and an error?
09:31:01 <fryguybob> Is that pure?
09:31:17 <tertl3-laptop> srhb where is the docs for it, whats it called?
09:31:28 <srhb> Wildcard something?
09:32:31 <srhb> tertl3-laptop: "abbreviated form" in the docs.
09:32:34 <absence> fryguybob: i know what purity is. let's stick to the Control.Proxy related issue at hand :)
09:33:06 <srhb> tertl3-laptop: 5.2.2
09:33:10 <srhb> tertl3-laptop: Oops, here: http://www.haskell.org/onlinereport/modules.html
09:35:23 <tertl3-laptop> ok ty
09:47:22 <wuttf> How can I add the parent folder to the search pathes in GHCi?
09:47:31 <wuttf> I am messing around with -idirs
09:47:40 <wuttf> says no to .. ;)
09:50:10 <tertl3-laptop> srhb i like your definition better than that docs :)
09:57:16 <calvin> #haskell
09:57:32 <c_wraith> You've identified your location
09:58:34 <calvin> Hi haskellers ! I would like to know what match this pattern : (n1:rest@(n2:_)) on a list of double, if someone can help me :)
09:59:13 <bartavelle> for [1,2,3,4], you will have n1 = 1, n2 = 2, rest = [2,3,4]
09:59:38 <calvin> thank you very much !
09:59:45 <fizbin> calvin: first of all, that pattern only matches if you have at least two elements in the list. Once you do, what bartavelle said.
09:59:46 <bartavelle> well you should check this :)
10:01:42 <donri> wuttf: how about -i $PWD/..
10:01:51 <calvin> I find the ocaml equivalent more understandable : n1::((n2::_) as rest)
10:01:52 <donri> hm not sure the shell expands that
10:03:22 <mm_freak> calvin: "@" is a flipped version of "as" there
10:03:50 <fizbin> wuttf: Can you try -i `dirname $PWD` ?
10:03:50 <mm_freak> haskell: identifier@pattern
10:03:56 <mm_freak> ocaml: pattern as identifier
10:04:08 <tomejaguar> Is there an equivalent of ghc-core for STG language?
10:04:12 <mm_freak> calvin: feel free to add spaces as you see fit:  identifier @ pattern
10:04:13 <wuttf> donri, fizbin I want it to work on win too. Will that?
10:04:22 <fizbin> Oh, no.
10:04:24 <mm_freak> tomejaguar: as STG is lower than core i doubt it
10:04:29 <fizbin> That's a blatant unixism.
10:04:47 <mm_freak> tomejaguar: STG is the level immediately above C--/assembly
10:04:56 <calvin> mm_freak : alright ! thank you
10:05:34 <donri> absence: lazy bytestrings are chunked so there is no "single byte reads"
10:06:19 <donri> absence: but with pipes, you probably want to work with strict bytestrings
10:06:45 <tomejaguar> mm_freak: STG is not a huge amount lower level than core
10:11:28 <mm_freak> tomejaguar: it's still lower and the last functional level before going to machine code
10:11:46 <mm_freak> tomejaguar: i'm not sure what would be "core of STG"
10:12:17 <mm_freak> perhaps tell us what purpose you have in mind
10:12:26 <tomejaguar> mm_freak: I mean a pretty-printing of the intermediate STG
10:12:40 <tomejaguar> ghc-core compiles to core and pretty prints it
10:12:47 <donri> absence: not on hackage yet but maybe take a look at pipes-bytestring https://github.com/Gabriel439/Haskell-Pipes-ByteString-Library
10:12:54 <tomejaguar> there could be ghc-stg which compiles to stg and pretty prints it
10:13:44 <Xaratas> has the && function short circuit logic? does it stop the second part from being evaluated if the first one is false?
10:14:26 <supki> > False && undefined
10:14:27 <lambdabot>   False
10:14:31 <donri> absence: then you might want to use pipes-safe for opening file handles
10:14:44 <Xaratas> > undefined && False
10:14:46 <lambdabot>   *Exception: Prelude.undefined
10:14:56 <absence> donri: thanks, i'm starting to realise that while trying to implement a simple file copier for testing :) i guess i just have to create some kind of buffer that downstream can request from
10:15:00 <Xaratas> arg, why left first?
10:15:12 <absence> donri: great, i'll check out those!
10:15:42 <supki> Xaratas: why not? anyway, it's easy to define the other one
10:16:15 <donri> absence: in particular look at fromHandleS and hGetSomeS in pipes-bytestring
10:16:58 <donri> absence: they produce strict chunks of bytestrings on demand (on 'request') from the handle
10:17:12 <fizbin> > let (>&&<) = flip (&&) in undefined >&&< False
10:17:13 <lambdabot>   False
10:17:57 <donri> absence: for file copying you could then compose with toHandleD to write the outfile handle
10:18:44 <Xaratas> ok, noted, for my code the normal && is the "do less work" option
10:18:53 <shachaf> (⅋⅋)
10:19:26 <donri> flip it horizontally instead: &&
10:19:30 <donri> > reverse "&&"
10:19:32 <lambdabot>   "&&"
10:19:35 <donri> \o/
10:20:19 <shachaf> /o\
10:21:14 <absence> donri: that looks very handy. how would downstream best cope with reading across bytestring boundaries though?
10:22:24 <merijn> Xaratas: eh, how is left first different from "the normal &&"?
10:22:35 <Xaratas> in no way
10:23:00 <Xaratas> its just that everything else in haskell is right associative
10:23:14 <merijn> Is it?
10:23:19 <Xaratas> *nearly
10:23:29 <donri> absence: you mean a request with no respond? i think runProxy just discards those?
10:23:39 <merijn> I think most are left associative, except for (.)
10:24:21 <absence> donri: a somewhat silly and contrieved example would be splitting the contents of the file into [Word8] chunks of a different size than defaultChunkSize
10:24:55 <donri> absence: not sure i see how the chunk size matters
10:25:43 <donri> most pipes will just loop forever and request a production from upstream and process that
10:25:55 <donri> what is the problem you're imagining?
10:26:08 <c_wraith> merijn: nearly anything that benefits from laziness is made infixr
10:27:20 <absence> donri: say the ByteString chunks are 128 bytes, and i want to split the file contents into chunks of 50 bytes. so you request the next bytestring, and respond once for the first 50 bytes, then again for the next 50 bytes, but now there are only 28 bytes left. another bytestring has to be requested before 50 bytes (28 from the old and 22 from the new) can be produced again, etc
10:28:12 <absence> donri: i just wondered if the boundary handling has to be done explicitly by the user, or if there's some magic available :)
10:34:21 <donri> absence: i don't understand the problem. why should downstream care about the size of the bytestring productions?
10:50:39 <absence> donri: if there's a proxy that parses the binary data in the file, it might need more than one chunk
10:51:02 <absence> donri: depending on the chunk size
10:52:18 <donri> absence: maybe look at pipes-attoparsec, which deals with something similar
10:55:28 <donri> absence: with binary i think runGetIncremental is similar to attoparsec
10:55:47 <donri> http://hackage.haskell.org/packages/archive/binary/0.7.0.1/doc/html/Data-Binary-Get.html#g:3
10:57:29 <parcs> > iterate (*1.6) 1
10:57:30 <lambdabot>   [1.0,1.6,2.5600000000000005,4.096000000000001,6.553600000000002,10.48576000...
10:57:42 <parcs> > map floor $ iterate (*1.6) 1
10:57:44 <lambdabot>   [1,1,2,4,6,10,16,26,42,68,109,175,281,450,720,1152,1844,2951,4722,7555,1208...
10:59:34 <absence> donri: ahh right, so it's up to Data.Binary.Get to handle cases of incomplete input, etc. i was thinking in terms of runGet
11:02:04 <skp> hi
11:03:07 <hpaste> “Gun Control Update 12” pasted “Gun Control Update 12” at http://hpaste.org/84039
11:04:17 <donri> (spam)
11:09:20 <parcs> oooh guns *clicks*
11:26:32 <tomoj> in relative time Reactive-style FRP, for a Reactive r, what is (r >>= const r)? r? or r with all the values replaced with (extract r)?
11:42:21 <monochrom> it seems to me r >>= const r = r >>= (\_ -> r) = r >> r
11:42:39 <johnw> precisely
11:43:05 <monochrom> unless you say, Reactive >>= is unrelated to Monad >>=
11:43:18 <srhb> Or just a lying Monad.
11:43:25 <johnw> that too
11:43:27 <srhb> That would be impressive though.
11:51:12 <hpaste> “Anonymous Coward” pasted “Build error” at http://hpaste.org/84040
11:51:56 <nouitfvf> hello guys I have trouble with installing libary 'show' via cabal
11:52:04 <nouitfvf> it's here http://hpaste.org/84040
11:52:14 <nouitfvf> can someone help please?
11:53:52 <c_wraith> nouitfvf: It looks like the problem is that the show package didn't set an upper bound on its dependency on quickcheck
11:54:16 <c_wraith> nouitfvf: and quickcheck changed the number of arguments to the Failure constructor at some point
11:54:33 <hpaste> “Anonymous Coward” pasted “OS, etc” at http://hpaste.org/84041
11:55:42 <nouitfvf> c_wraith, oh.. but how can I fix it?
11:55:44 <c_wraith> nouitfvf: You can experiment with versions of quickcheck, or you can see about updating the show library to compile against the version of quickcheck you have installed
11:57:14 <c_wraith> nouitfvf: if you run « cabal unpack show », it'll give you the source to work with.  When you get it working right, you can cabal install it from there.  And you should send the maintainer an email about what you fixed if you do.
11:57:26 * hackagebot snap-app 0.2.2 - Simple modules for writing apps with Snap, abstracted from hpaste.  http://hackage.haskell.org/package/snap-app-0.2.2 (ChrisDone)
11:57:50 <srhb> c_wraith: I really love how that works, too. Fixed so many things because I needed them now and the sources were just that command away.
12:05:15 <hpaste> awgn pasted “Compile Error” at http://hpaste.org/84042
12:06:14 <awgn> what's going on there? I'm trying to send a ByteString obtained with a the Binary packet over a Socket
12:06:42 <awgn> it seems that the two ByteString are different
12:06:47 <aCube> awgn: Seems like you're mixing lazy and strict bytestrings
12:07:09 <nouitfvf> c_wraith, hm.."runhaskell Setup configure" says that I missed some dependencies but all OK.. I'm trying to build it manually with -fno-warn-orphans
12:07:10 <monochrom> does Binary give you a lazy bytestring or a non-lazy bytestring?
12:07:18 <awgn> let me check
12:08:01 <awgn> Binary gives a lazy ByteString
12:08:03 <monochrom> it gives you a lazy one
12:08:03 <c_wraith> nouitfvf: you should use "cabal configure" instead. It actually looks places where you have things installed
12:08:24 <c_wraith> nouitfvf: followed by "cabal build" to build it, and "cabal install" to make it visible to everything else
12:08:40 <awgn> so that's the problem
12:09:51 <nouitfvf> c_wraith, thanks..
12:12:25 <hpaste> tomejaguar pasted “Where is n forced?” at http://hpaste.org/84043
12:12:30 <cajla> I've been doing the roll your own irc bot tutorial and I'm getting an ambiguous type variable in the main function, how do I resolve that>
12:12:34 <cajla> ?
12:12:46 <ab9rf> disambiguate the type :)
12:12:51 <srhb> cajla: By constraining that variable to a type with an annotation, sometimes.
12:12:52 <tomejaguar> Can someone help me interpret that ^^ core?
12:12:58 <tomejaguar> I don't see where n is forced
12:13:00 <tomejaguar> What am I missing?
12:13:57 <absence> donri: using something like a writer monad (e.g. toListD) is the only way to get data out of a session since it's closed?
12:14:46 <Cale> tomejaguar: I think it's the Str=DmdType SS
12:15:11 <srhb> Dmd for demand?
12:15:38 <Cale> yeah
12:15:50 <dmwit> And Str for String!
12:15:55 <srhb> dmwit: Thanks :P
12:15:56 <dmwit> (okay, strictness, probably)
12:21:46 <tomejaguar> Thanks all.  Where "Str=DmdType SS" crop up in the Core syntax?  I can't see what it corresponds to.  http://www.haskell.org/ghc/docs/7.6.2/html/libraries/ghc-7.6.2/CoreSyn.html
12:25:57 <__Hybris__> Hi all! I am pretty new to haskell. I've read ~60% of learnyouahaskell and done 5-6 project euler problems. I want to implement A* search for a class I'm taking, using Data.Tree. Without giving away the complete solution, could someone tell me what specific things I should learn to be able to do this?
12:26:07 <Cale> tomejaguar: I think those are annotations
12:26:15 <__Hybris__> And yes, I know I am in over my head :)
12:26:35 <ab9rf> i don't remember how A* works :)
12:26:38 <Cale> __Hybris__: In order to do it well, you ought to be familiar with some data structure that you can effectively use as a priority queue
12:26:51 <ab9rf> i know it's a pathfinding algorithm but the specifics evade me
12:26:52 <Cale> I recommend the PSQueue package from Hackage for that.
12:26:58 <__Hybris__> Cale, yes, I want to use PSQueue
12:28:01 <__Hybris__> So somehow I'll use PSQueue to keep track of the nodes I haven't visited.
12:28:09 <parcs> tomejaguar: strictness information is a part of the 'Id' type, specifically the 'IdInfo' record
12:28:42 <Cale> I wrote the astar package on hackage (and proceeded not to test it very well, but I have some users, so it can't be that bad), just following along with the code on wikipedia. I used Data.Map and Data.PSQueue to do it. I had a data type with all the state for the algorithm like this:
12:29:04 <Cale> data AStar a c = AStar { visited  :: !(Set a), waiting  :: !(PSQ a c), score    :: !(Map a c), memoHeur :: !(Map a c), cameFrom :: !(Map a a), end      :: !(Maybe a) } deriving Show
12:29:18 <Cale> (sorry about the spacing, I flattened that)
12:29:59 <Cale> I just wrote the thing in a directly recursive fashion, I didn't bother with a state monad or anything even.
12:30:05 <nouitfvf> c_wraith, now I have "Could not find module `Control.OldException'"
12:30:27 <Cale> (though it might be nice to)
12:31:02 <Cale> http://hackage.haskell.org/packages/archive/astar/0.2.1/doc/html/Data-Graph-AStar.html -- you can see the type of the function I wrote here :)
12:31:27 <Cale> I just had it take all the inputs, including the relevant details of the graph representation, as functional parameters.
12:31:43 <Cale> as such, it's not dependent on any one type of graph
12:32:51 <srhb> What happens to A* if you can't come up with a good heuristic for the distance?
12:33:04 <__Hybris__> Cale, thanks. It only needs to work on trees. I'll have to read up on data types, map and PSQueue.
12:33:10 <johnw> i think it just becomes the same as djikstra
12:33:46 <srhb> Hm yes, that makes sense.
12:33:50 <ab9rf> srhb: as long as the metric isn't actively wrong, it just reduces the benefit
12:33:51 <cajla> with an arc cost of 1?
12:33:54 <Cale> srhb: If your heuristic ever overestimates the distance to the goal, you end up with suboptimal results.
12:34:09 <srhb> Oh, I meant if I can't come up with any heuristic at all, sorry
12:34:24 <Cale> Well, if you can't come up with a heuristic, you can't apply the algorithm
12:34:24 <ab9rf> with no metric it's just dijkstra
12:34:33 <Cale> because the heuristic is one of the inputs
12:34:55 <ab9rf> but even euclidean distance will work
12:35:07 <ab9rf> manhattan works as well if you don't allow diagonal steps
12:35:20 <srhb> So if I wanted to play six degrees of Kevin Bacon, I wouldn't be able to come up with a metric, and I'd have to go with Dijkstras.
12:35:33 <ab9rf> srhb: yes, probably
12:35:52 <srhb> Makes sense.
12:36:01 <Cale> If you had an embedding of that graph, you could use a heuristic based on the embedding.
12:36:08 <srhb> "embedding"?
12:36:18 <ab9rf> i'm not sure how you could meaningfully embed the bacon graph though
12:36:38 <srhb> Well, no, you'd need a graph of all people's relations
12:36:47 <ab9rf> srhb: you need that anyway
12:36:47 <srhb> Ah I see graph embedding is on Wikipedia
12:37:07 <srhb> Er, true. :P
12:37:08 <Cale> Make all edge lengths 1
12:37:09 <ab9rf> srhb: although you may not inspect all edges
12:37:25 <ab9rf> you quit once you find Bacon
12:37:36 <ab9rf> you're making me hungry
12:37:42 <cajla> well once you know there is no shorter path i guess?
12:37:53 <ab9rf> cajla: the first path you find in A* is the shortest
12:37:54 <srhb> Dijkstras guarantees that, doesn't it?
12:37:55 <Cale> and map points in the graph to points in R^n satisfying that
12:37:56 <Cale> You might need to make n large
12:37:56 <srhb> Yeah
12:38:06 <ab9rf> or is at least tied for shortest
12:38:16 <ab9rf> there may be others that are equally short but no path is shorter
12:38:32 <cajla> assuming you have the distance correct
12:38:37 <srhb> I have to write this now, too funny. Wikipedia will have to be a standin for real people's relations
12:38:56 <ab9rf> srhb: use imdb instead
12:39:07 <srhb> Oh yeah, that would work, too.
12:39:27 <srhb> Extraction might be messier though. Regexing on anything..wiki/article seems nice
12:39:42 <ab9rf> A* uses  the heuristic to order the fringe by likelihood of getting closer
12:41:27 <ab9rf> ok, yeah, i'm remembering this algorithm now
12:41:29 <ab9rf> it's been ages
12:41:56 <armlesshobo> man, this repl makes like easier.
12:42:00 <ab9rf> Cale: i suspect n would be quite large
12:42:03 <Cale> tbh, constructing that embedding is probably computationally more expensive than all pairs shortest paths
12:42:15 <armlesshobo> life*
12:42:18 <srhb> armlesshobo: :)
12:43:09 <srhb> Can Parsec replace regexes? Say for finding URLs that match a certain pattern in a blob of HTML?
12:43:26 <ab9rf> srhb: yes
12:43:37 <srhb> Neat, then I have an actual reason to try this. :P
12:43:39 <ab9rf> srhb: although it gets interesting if you want to be able to specify the blob at runtime
12:43:46 <srhb> Oh.
12:43:50 <srhb> How come?
12:43:56 <ab9rf> the needle to find, that is
12:44:08 <Cale> srhb: Because parsec parsers consist of Haskell code
12:44:13 <ab9rf> srhb: well, if it's a simple string
12:44:13 <srhb> Yes, I see.
12:44:13 <geekosaur> however I'd say there are some caveats; html is notoriously hard to parse and it's often better to leave it to the experts (i.e. existing well-tested libraries)
12:44:20 <cajla> Ok i can't understand why this ambiguous type matters. It comes from Control.Exception.catch, :: Exception e => IO a -> (e -> IO a) -> IO a, and it is the e it complains on
12:44:27 <ab9rf> but if you want a complicated pattern, that requires invoking the compiler
12:44:35 <geekosaur> especially given that HTML the spec and HTML in the wild are often two rather different things
12:44:39 <srhb> cajla: It needs to know what exception to catch
12:44:50 <srhb> ab9rf: Yeah. Hm. Not sure what is cleverest then.
12:44:56 <srhb> geekosaur: What libraries are good for that, then?
12:45:07 <cajla> Nothing int the tutorial mentions that, and this is my first encounter with exceptions
12:45:14 <ab9rf> srhb: regexps are good for searching for patterns that will be specified later
12:45:23 <Cale> cajla: You might be reading a somewhat older tutorial?
12:45:30 <cajla> not really
12:45:32 <geekosaur> the tutorial may be out of date; several of them predate extensible exceptions
12:45:52 <ab9rf> geekosaur: heh, yeah, html is a wild beast
12:45:56 <cajla> I can't finding any dates but I think it is atleast from 2010's
12:46:03 <Cale> cajla: The exception system was (a fair amount of time ago) replaced with this system which allows for easy introduction of new sub and superclasses of exceptions.
12:46:25 <cajla> regex's are only great if you know at compile the pattern, jit or otherwise
12:46:33 <awgn> what's the recommended linux distribution for Haskell? Arch Linux, Debian or NixOs ?
12:46:41 <hiptobecubic> awgn, that makes no sense.
12:46:42 <srhb> awgn: None or any.
12:46:42 <Cale> If you want to just catch anything, you can replace the handler (\e -> ...) with (\(SomeException e) -> ...)
12:46:44 <Taneb> awgn, it doesn't matter, at all
12:46:49 <ab9rf> awgn: haskell doesn't care
12:47:08 <Taneb> awgn, you could even use Windows!
12:47:15 <ab9rf> Taneb: shush :)
12:47:16 <awgn> I mean from the point of view of packages
12:47:19 <hiptobecubic> Unless you want a gui
12:47:24 <srhb> Doesn't matter, you get your packages via cabal
12:47:27 <ab9rf> awgn: cabal
12:47:28 * hackagebot tagged 0.4.5 - Haskell 98 phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.4.5 (EdwardKmett)
12:47:29 <hiptobecubic> which is pretty ironic now that i think about it
12:47:38 <monochrom> arch has more packages
12:47:52 <srhb> arch also tends to break their Haskell packages for extended periods, it seems.
12:47:55 <ab9rf> i don't care if the distributio has packages, you'll just get them with cabal
12:47:59 <srhb> I remember that month of arch flooding in here. ugh.
12:48:07 <hiptobecubic> arch also tends to break their distro for extended periods
12:48:13 <monochrom> oh, then don't use arch's packages :)
12:48:18 <aCube> for me, arch is quite stable
12:48:18 <cajla> Cale: Gonna look at the new exceptions, because i can't say how this code in the tutorial makes any sense at all actually
12:48:26 <aCube> But I don't use the haskell packages
12:48:28 <ab9rf> i stay out of distro wars generally
12:48:34 <Cale> Yeah, for me the answer to which linux distribution to use is that it's a moot point because I'll be installing the GHC generic linux binary package anyway.
12:48:36 <ab9rf> so much religion, so little logic
12:48:38 <srhb> ab9rf: How about this one specifically?
12:48:52 <Cale> cajla: Which tutorial?
12:48:57 <ab9rf> srhb: i don't have any experience really, i've only used haskell on debian and on windows
12:49:06 <aCube> The haskell packages in arch are unusable:
12:49:08 <aCube> warning: cannot resolve "haskell-void=0.5.11-2", a dependency of "haskell-lens"
12:49:11 <ab9rf> srhb: but i've been using debian since 1999, and have had no reason to change
12:49:19 <cajla> Cale: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
12:49:32 <edwardk> ?
12:49:36 <monochrom> I stay out of distro wars too, except when people mock ubuntu's unity, and then I stand up and say I use ubuntu and unity and they work great
12:49:37 * geekosaur is not sure what haskell package is currently blessed for html parsing
12:49:42 <srhb> ab9rf: Re. 1999 - I recently met a fellow on IRC that, when prompted of his distro, replied "Mandrake"
12:49:51 <hiptobecubic> edwardk, do you highlight on "lens" ?
12:49:55 <ab9rf> srhb: i nearly got a job at mandrake
12:49:56 <cajla> monochrom: or upstart or MIR
12:49:57 <edwardk> hiptobecubic: ?
12:49:58 <edwardk> =)
12:50:01 <edwardk> yes
12:50:03 <Cale> cajla: Yeah, that's using the old exceptions
12:50:18 <edwardk> its got a pretty bad false hit rate these days though so i'll probably drop it
12:50:18 <ab9rf> srhb: i was all but hired as supervisor of customer service when they decided to cancel the whole project
12:50:21 <hiptobecubic> edwardk, false alarm then :)  someone was complaining that arch's packages are incoherent
12:50:24 <cajla> good to know, is the type for that catch even the same?
12:50:28 <srhb> ab9rf: Eck.
12:50:44 <Cale> cajla: You can fix it by replacing (const $ return ()) with (\(SomeException e) -> return ())
12:50:50 <srhb> hiptobecubic: Are you telling that that's beyond the scope of Control.Lens?!
12:50:53 <ab9rf> srhb: that was like 1998?  i forget, it was ages ago.
12:50:59 <srhb> ab9rf: Sounds about right.
12:51:17 <cajla> AH
12:51:35 <Cale> hah, it looks like someone fixed it on that page farther down, but put it in a comment
12:51:39 <ab9rf> maybe 2000
12:51:43 <cajla> I just make an exception handler for any exception
12:51:49 <ab9rf> i dunno, it was somewhere near Y2K
12:51:49 <cajla> that just return ()
12:51:55 <Cale> cajla: Yeah.
12:52:00 <ab9rf> before i got my First Real Job
12:52:12 <cajla> also, comments?
12:52:32 <cajla> I see no comment system on that page
12:52:50 <Cale> No, in a code comment
12:53:06 <Cale>     loop st    = catch (runReaderT run st) (const $ return ())
12:53:06 <Cale>     --           catch (runReaderT run st) (\(SomeException _) -> return ()) -- *** Control.Exception with base-4
12:53:06 <Cale>  
12:53:12 <monochrom> (\ ~(SomeException e) -> return ()) hehehe. (more seriously, it doesn't matter in practice, don't pull your hair out on this :) )
12:53:43 <cajla> oh im so blind
12:54:02 <awgn> I quit. Bye :-)
12:54:13 <cajla> sorry to have wasted your time and thanks for the help
12:54:19 <Cale> Well, it is in ever-so-fucking-slightly-darker-grey on a light-grey background.
12:54:35 <Cale> Like so many things on the web today
12:54:43 <johnw> Cale: I SO AGREE
12:54:49 <johnw> drives me nuts
12:54:57 <cajla> Well
12:55:00 <cajla> me too
12:55:05 <johnw> there are even apps that are darkish grey on lightish grey with like 9pt fonts where nothing is configurabel
12:55:13 <cajla> the designers are fapping hardcore to that stuff
12:55:20 <johnw> clearly their market demographic is 19 year olds, period
12:55:23 <tomejaguar> parcs: thanks
12:55:27 <srhb> johnw: Careful :P
12:55:31 <monochrom> the computer can do 2^24 colours. it is important to use them all!
12:55:43 <johnw> srhb: whaddisay? :)
12:55:53 <johnw> 19yr olds have better eyesight!
12:56:00 <johnw> i'm a 15pt minimum guy nowadays
12:56:01 <srhb> Haha. Sorry. :P
12:56:08 <cajla> Also it works great now
12:56:23 <cajla> also designers have VA panels
12:56:38 <cajla> so they actually have that many colors
12:56:54 <monochrom> ideally, each pixel stands for one unicode codepoint, and so your screen can display 2000x1500 code points, or whatever your resolution is
12:56:54 <cajla> unlike most of us who have 6 bits per color
12:56:58 <Cale> I have very good eyesight with glasses, and can probably read it as well as anyone, but that doesn't magically excuse it from being obnoxious.
12:57:05 <srhb> monochrom: "ideally"
12:58:03 <monochrom> 2000-character wide source code ought to be enough for everybody!
12:58:12 <Cale> It seems fpcomplete has mostly fixed their problem with it
12:58:20 <Cale> I was about to give them some more flak
12:58:43 <johnw> i gave flak on your behalf, Cale :)
12:58:54 <Cale> There's still some of it
12:59:03 <johnw> then i shall resume flakking
12:59:05 <Cale> but at least their main article text is no longer light grey
12:59:16 <johnw> if you see mgsloan, give it to him
12:59:18 <srhb> I feel like my monitor is dying when I see grey text.
12:59:41 <johnw> grey text should cause Chromatic Affective Disorder or something
12:59:51 <johnw> then we excuse ourselves from work on legal grounds
13:00:02 <monochrom> anyway, speaking unsarcastically, web designers should be confined to working on a 12" netbook, because that's what we normal users use, not their current quad-head 40" oh-so-awesome highend displays
13:00:15 <Cale> It makes me rage that there are people who are *paid* to do this shit and should know better, and yet they don't do their jobs properly.
13:00:42 <johnw> Cale: like the people who write password login code for websites, but don't even salt the pw hash?
13:00:51 <Cale> yes, it's about as bad as that
13:01:13 <Cale> (well, obviously security is much more serious to begin with, but still)
13:01:31 <monochrom> no, Cale, I think it makes you rage less if you know that their practice is being given highend displays
13:01:57 <Cale> monochrom: I don't care how highend your display is. Maximise contrast.
13:02:15 <cajla> Cale: it's about the UX
13:02:21 <cajla> ;)
13:02:34 <monochrom> a web page that says "this page best in 4000x2500" is clearly made by someone who actually is given such a ridiculously out-of-earth display
13:03:03 <monochrom> I think similarly web pages that uses hard-to-distinguish colours
13:03:05 <Cale> It's not about the UX for these people, it's about the experience of the guy who's standing across the room and blurring his eyes while looking at the site design that has lorem ipsum text in it.
13:03:40 <Guest38848> hello
13:03:45 <cajla> My company is currently looking to hire a designer
13:03:57 <cajla> those persons i\ve met..
13:04:30 <Guest38848> tailleGoban = 19
13:04:33 <Cale> Grey text "looks better" in that it's less distracting from the site design itself, but since the text is the whole reason that the thing exists, you shouldn't be noticing the site design, and if you do, it's probably bad.
13:04:34 <Guest38848> voisins (i,j) = case (i,j) of
13:04:42 <monochrom> and the irony is that they say "I'm an artist, I need these high-end huge colour-accurate displays"
13:05:14 <ag90> With ByteString.split, is there an alternative that preserves the byte that it split on?
13:05:30 <Cale> http://www.perceptualedge.com/blog/ -- this guy makes great points about presentation of data, all the while in text which is needlessly difficult to read
13:05:42 <johnw> we should write a book, How To Design Websites Like GoDaddy, and then collect the names of everyone who buys it and put them on a no-work list
13:06:15 * labo likes that idea
13:06:21 <vlatkoB> Is it possible to write several bool checks in point-free style?
13:06:21 <vlatkoB> Like "(\x -> isDigit x && x =='.')" to "digit.(=='.')"
13:06:57 <Cale> ag90: break/span?
13:07:03 <parcs> vlatkoB: it's possible but it's ugly
13:07:05 <geekosaur> @pl \x -> isDigit x || x == '.'
13:07:05 <lambdabot> liftM2 (||) isDigit ('.' ==)
13:07:10 <geekosaur> I dont think you meant && there?
13:07:23 <geekosaur> there's also an Applicative phrasing
13:07:30 <ag90> Cale: Doesn't it find just one split point?
13:07:32 <vlatkoB> Indeed, ||
13:07:42 <Cale> ag90: yeah, I had to look up what that function did
13:07:46 <geekosaur> but sometimes it's clearer to just use the lambda
13:08:05 <danharaj> anyone have a reference on how the type of callCC is wrong for the current MonadCont?
13:08:26 <ag90> vlatkoB: (||) <$> isDigit <*> (== '.') is available too, but it's ugly as well.
13:08:32 <monochrom> haskell wiki has one
13:09:09 <vlatkoB> Yes, I thought there might be a short ans pretty style. it is for map, so I wanted it shorter. Thanks.
13:09:20 <danharaj> monochrom: the wiki one gives callCC a rank-2 type. I've heard that callCC should have a rank-3 type but I haven't seen it.
13:09:27 <vlatkoB> In fact, I have HLint active and gives me the warning.
13:10:08 <monochrom> the type you see there is already rank-3. it is mistakenly called rank-2
13:10:25 <danharaj> I am so bad at counting ranks.
13:10:27 <danharaj> :|
13:10:35 <parcs> :t callCC
13:10:37 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
13:10:38 <monochrom> i.e., the article author mistakenly calls it rank-2. therefore, it is not just you :)
13:10:49 <parcs> it should be (forall b. a -> m b)
13:11:02 <danharaj> monochrom: also it's probably slightly nicer to write it as callCC :: ((forall b. a -> m b) -> m a) -> m a
13:11:14 <danharaj> And I guess that makes the rank-3ness manifest.
13:11:37 <monochrom> yeah, I do that too
13:11:51 <parcs> i wonder what the practical difference of a rank-1 vs rank-2 callCC is
13:12:04 <Cale> ag90: lol, you could use groupBy :)
13:12:14 <Cale> ag90: groupBy (\x y -> y /= ' ')
13:12:25 <Cale> Some people would consider that ugly
13:12:30 <ag90> Hah
13:14:00 <Cale> ag90: There's a really excellent package called split, which operates on lists
13:14:27 <danharaj> :t groupBy (const (/= ' '))
13:14:29 <lambdabot> [Char] -> [[Char]]
13:14:30 <mcstar> is it possible for a function's return type to depend on one of its argument's type? (i dont mean parametrically, like a -> a, or g a -> f a)
13:14:39 <Cale> I wonder how hard it would be to extend it to work on ByteStrings
13:15:01 <parcs> mcstar: a -> f a ?
13:15:01 <Cale> (efficiently)
13:15:14 <ag90> Right now, I've just implemented a line-to-line copy of ByteString.split to keep the split character.
13:15:17 <parcs> mcstar: where f is a type function
13:15:24 <mcstar> parcs: no, it possibly doesnt have 'a' in the return type
13:15:46 <ag90> In fact, for this program, I seem to be using more ByteString.Internal than would be deemed advisable.
13:15:49 <parcs> mcstar: that's OK if f is a type function
13:16:08 <mcstar> parcs: ok, should i search the wiki for 'type function's?
13:16:28 <Cale> ag90: I'd probably just write something recursive with span or break tbh
13:16:29 <parcs> mcstar: type families or associated types is a more accurate term
13:16:30 <monochrom> imagine: callCC (\k -> if x then (k () :: m Bool) else even <$> (k () :: m Int)). this requires k () to be forall b. m b
13:16:30 <donri> absence: well you can 'return' from a proxy
13:16:37 <mcstar> parcs: thanks
13:17:29 <ag90_> My connection just dropped. What is this, 1990?
13:17:29 * hackagebot layers 0.1 - Modular type class machinery for monad transformer stacks.  http://hackage.haskell.org/package/layers-0.1 (ShaneOBrien)
13:17:35 <Cale> http://hackage.haskell.org/packages/archive/split/0.2.1.2/doc/html/Data-List-Split.html
13:17:35 <Cale> This library is really cool though ;)
13:17:37 <Cale> It lets you define and transform strategies for splitting strings.
13:17:42 <monochrom> 1913
13:17:45 <sproingie> ag90_: did you see NO CARRIER on your screen? :)
13:17:46 <Cale> also, I'm severely lagged
13:18:13 <Cale> +++
13:18:16 <ag90_> You know, I wasn't looking. My client just said "disconnected."
13:18:20 <monochrom> ATH
13:18:40 <johnw> sproingie: you just took me back, thanks
13:18:47 <johnw> +~-...~NO CARRIER
13:19:07 <monochrom> my quit message is also set to "NO CARRIER"
13:20:44 <Cale> I had high hopes for http://www.carrier.no/
13:21:46 <sproingie> norwegian refrigerated shelving manufacturer, looks like
13:22:17 <sproingie> it's norway, open a window ;)
13:22:41 * geekosaur was thinking yes, norwegians would know a thing or two about refrigerated shelving
13:23:04 <dmwit> I would think the Norwegians would know a lot about heating, if anything.
13:23:18 <dmwit> Ask people who live in a hot place for your refigeration tech.
13:23:31 <monochrom> after all, it's Carrier
13:23:53 * monochrom 's home HVAC is also a Carrier
13:24:47 <sproingie> reminds me of that old joke: why do the English drink warm beer?  English fridges.
13:26:06 <parcs> do refridgerators run correctly in cold environments?
13:27:05 <johnw> yes
13:27:29 <johnw> it's a contained, insulated phase-change cooling system
13:27:56 <sproingie> "phase change cooling" makes it sound so sexy when it's for computers
13:28:13 <johnw> it relies on evaporation due to the pressure differential, I believe, so even if it's cold throughout it should work just fine
13:28:29 <sproingie> pretty sure the joke was a dig on british engineering :)
13:28:54 <sproingie> or manufacturing anyway
13:30:07 <mcstar> i dont get the joke
13:30:44 <sproingie> it's a bit dated.  wasnt terribly hilarious in the first place.  *shrug*
13:31:16 <mcstar> were english fridges considered unreliable at some time? or what?
13:31:35 <sproingie> one imagines so
13:32:21 <geekosaur> see also lucas electrics, the prince of darkness
13:34:49 <ben22> :r
13:35:00 <mcstar> oh, ben22, i read the logs
13:35:13 <ben22> hi
13:35:17 <mcstar> i feel like i know you already
13:35:26 <ben22> really?
13:35:35 <mcstar> yeah, you are the guy who doesnt read the books
13:36:05 <ben22> well when I was a freshman, I used to read them a lot but they never helped me that much get As and stuff
13:36:16 <mcstar> yeah, i know, i read the logs
13:36:17 <ben22> so I kind of got hopeless
13:36:38 <mcstar> and your buddies seemingly didnt read and yet got good grades
13:36:55 <ben22> well yea, my friends are much brighter than me
13:37:12 <mcstar> in response they told you, "you dont know what hard work they did" or something like that
13:37:42 <ben22> well these guys can say that cause they enjoy doing this stuff cause they discovered the language on their coffee break not at school
13:38:23 <ben22> when you discover something at school, it tends to get depreciated than appreciated
13:38:49 <ben22> mcstar, you think you can help me out with something?
13:39:16 <mcstar> ben22: anyway, my advice: next time you pay attention to the code the others execute when you are talking to them/asking questions, you might have gotten your answer much earlier
13:39:33 <mcstar> (i mean you did, just didnt notice)
13:39:51 <ben22> I was too absorbed giving these people a good time yesterday
13:39:53 <mcstar> ben22: it goes like this: you ask and someone might help
13:39:56 <ben22> i think they enjoyed it
13:40:39 <ben22> mcstar, I don't like the "lookup" function in haskell
13:40:46 <ben22> I want to do it with list comprehension
13:40:51 <ben22> but this doesn't compile
13:40:53 <ben22> lookupTable = zip ['1'..'9'] [1..9]
13:40:53 <ben22> charToInt :: Char -> Int
13:40:53 <ben22> charToInt c = [ b | (a,b) <- lookupTable, a == c ]
13:41:18 <Heffalump> ben22: and what's the error?
13:41:36 <ben22> expected type "Int" with actual type "[t0]
13:41:40 <mcstar> a==c ?
13:41:45 <Heffalump> ok, so what might that mean?
13:42:13 <ben22> well a == c, simply compares my user input char to the lookuptable chr
13:42:22 * geekosaur notes that list comprehensions are ... lists
13:42:39 <mcstar> ben22: the problem that that doesnt select one element
13:42:49 <mcstar> as geek* says, it gives a list of one element
13:43:15 * mcstar forgot to use tab completion on geekosaur
13:43:17 <ezyang> @djinn Monad m => m (m a) -> m a
13:43:18 <lambdabot> f = join
13:43:19 <ben22> so if I want ('3', 3) and get 3 from it, do I need to tweak my list comprehension a bit?
13:43:26 <ezyang> @djinn (Monad m, MonadTrans t) => t (t m) a -> t m a
13:43:27 <lambdabot> Error: Class not found: MonadTrans
13:43:38 <ezyang> bah
13:43:59 <mcstar> > let charToInt c = head [ b | (a,b) <- zip ['1'..'9'] [1..9], a == c ] in charToInt '1'
13:44:01 <lambdabot>   1
13:44:10 <sproingie> ben22: what's the expected result of charToInt 'a' ?
13:44:22 <ben22> it's an error
13:44:30 <sproingie> then head will do the job
13:44:35 <mcstar> ben22: so you see, you are back to your problem with Maybe
13:44:41 <ben22> thanks, I didn't know much about head
13:44:48 <sproingie> > head []
13:44:49 <lambdabot>   *Exception: Prelude.head: empty list
13:45:02 <sproingie> > let charToInt c = head [ b | (a,b) <- zip ['1'..'9'] [1..9], a == c ] charToInt 'a'
13:45:03 <lambdabot>   not an expression: let charToInt c = head [ b | (a,b) <- zip ['1'..'9'] [1....
13:45:09 <mcstar> in
13:45:14 <sproingie> hell?
13:45:26 <sproingie> doh copypasta
13:45:29 <ben22> it says ***Exception:Prelude.head: empty list!
13:45:34 <sproingie> exactly
13:45:47 <mcstar> sproingie: italian cuisine? copypasta? lol
13:45:47 <sproingie> the list comprehension gives you an empty list
13:45:57 <robde> hello, why isn’t it possible to write "foo :: [a] -> Num" instead of "foo :: (Num b) => [a] -> b"? the compiler says: "Expecting one more argument to `Num'"
13:45:58 <ben22> I need a base case of [] = 0
13:46:03 * sproingie just had some (rather regrettable) calzone for lunch
13:46:18 <Nisstyre-laptop> robde: Num isn't a type
13:46:22 <mcstar> sproingie: is that the filled kind of pasta?
13:46:36 <ben22> thanks sproingie and mcstar, I went through a lot of trouble yesterday (as mcstar very well knows..)
13:46:40 <sproingie> not pasta.  pastry shell around what amounts to pizza toppings
13:46:52 <mcstar> ah, righ
13:46:54 <mcstar> t
13:46:58 <hiptobecubic> it's delicious
13:47:11 <sproingie> unless it's burnt and salty like that one was
13:47:12 <mcstar> yes i know, wasnt sure what was it called
13:47:15 <robde> Nisstyre-laptop: oh! it’s a type class, of course!
13:47:20 <robde> ty
13:49:00 <mcstar> that error doesnt make sense to me, Expecting one more argument to `Num
13:49:04 <ben22> how can I check the fact that char 'a' to any invalid char = 0?
13:49:38 <sproingie> ben22: think it through.  you know the list comprehension returns an empty list, right?
13:49:40 <mcstar> if it knows what Num is, and it needs an argument, why doesnt it dismiss that typing altogether?
13:49:47 <mcstar> Num a should be before the =>
13:49:55 <ben22> right, but my signature for charToInt is Char -> Int
13:50:03 <ben22> no list here
13:50:22 <sproingie> ben22: so define a function that gives you either the head of a nonempty list, or a default for an empty one
13:50:34 <sproingie> actually there's maybe something in the prelude but it's good practice
13:50:48 <mcstar> fromList?
13:50:53 <mcstar> :src fromList
13:50:59 <sproingie> @src fromList
13:50:59 <lambdabot> Source not found. You speak an infinite deal of nothing
13:51:05 <sproingie> > fromList []
13:51:07 <lambdabot>   Not in scope: `fromList'
13:51:07 <lambdabot>  Perhaps you meant one of these:
13:51:07 <lambdabot>    `IM.fromList' ...
13:51:07 <mcstar> okok, calm down
13:51:24 <mcstar> sproingie: i thought it might be named that, analogous to fromMaybe
13:51:26 <sproingie> anyway it's trivial to write it yourself, and good practice
13:51:35 <sproingie> > listToMaybe [123]
13:51:37 <lambdabot>   Just 123
13:51:48 <sproingie> > listToMaybe [] :: Maybe Int
13:51:49 <lambdabot>   Nothing
13:52:10 <johnw> safeHead = fmap head . listToMaybe
13:52:12 <sproingie> that works, though it's extra steps.  i'd just go write the function
13:53:24 <sproingie> @hoogle Maybe m => m a -> a -> a
13:53:24 <lambdabot> Warning: Unknown class Maybe
13:53:24 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
13:53:24 <lambdabot> Prelude asTypeOf :: a -> a -> a
13:53:27 <mcstar> if his input is really restricted to '1'..'9' then dont bother
13:53:44 <mcstar> Monad
13:53:52 <sproingie> grmbl, i'm rusty, what's the haskell equivalent of getOrElse?
13:54:09 <shachaf> sproingie: What does "Maybe m =>" mean?
13:54:24 <mcstar> if there was a maybe typeclass...
13:54:39 <sproingie> something my fevered imagination made up
13:54:56 <shachaf> Right.
13:55:00 <shachaf> So what's the actual type?
13:55:06 <mcstar> shachaf: whats your opinion on that error message?
13:55:19 <mcstar> "Expecting one more argument to `Num'"
13:55:21 <shachaf> I think Hoogle will find it if you figure out the type. :-) What are you after?
13:55:41 <mcstar> i think he is looking for the dafulting frommaybe
13:56:00 <shachaf> Yes, I know.
13:56:19 <mcstar> which is fromMaybe..
13:56:42 <mcstar> shachaf: did you see how that error msg is produced?
13:56:48 <ben22> charToInt :: Char -> Int
13:56:49 <ben22> charToInt c
13:56:49 <ben22> 	| isDigit c = head [ b | (a,b) <- lookupTable, a == c ]
13:56:49 <ben22> 	| otherwise = undefined
13:57:00 <sproingie> @hoogle a -> Maybe a -> a
13:57:01 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
13:57:01 <lambdabot> Prelude asTypeOf :: a -> a -> a
13:57:01 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
13:57:07 <sproingie> yay.  i remember haskell again.
13:57:13 <ben22> does this work sproingie ?
13:57:29 <sproingie> i wouldn't bother with the Maybe, i'd just write a function
13:57:36 <sproingie> i'm not gonna spoonfeed it :)
13:58:11 <sproingie> you've got the list resulting from the listcomp.  now pass it to a function of a [Int] -> Int
13:58:28 <mcstar> ben22: your use of 'undefined' is puzzling, you were made felt his yesterday too, but you didnt notice
13:58:45 <sproingie> if it gets an empty list, return the default.  for other lists, return the head.
13:58:53 <sproingie> i actually just wrote it for you, you just have to translate that to haskell
13:58:55 <ben22> so im done right? 'a' -> ***Exception Prelude.undefined/
13:58:56 <ben22> ?
13:59:54 <mcstar> also, i mustache you shachaf, did i cross you with that perl joke? thats why the cold shoulder?
14:00:08 <Nomad> hello :)
14:00:18 <ab9rf> olleh
14:00:21 <Nomad> Is it possible to use monads to act as a gobal counter? :X
14:00:38 <mcstar> @faq Is it possible to use monads to act as a gobal counter? :X
14:00:38 <lambdabot> The answer is: Yes! Haskell can do that.
14:00:57 <ab9rf> gobal?
14:00:59 <Nomad> O_o?
14:01:04 <monochrom> not "global", but yes you can make and use a counter
14:01:15 <Nomad> only pipelined counter?
14:01:18 <monochrom> "global" is overrated anyway
14:01:36 <monochrom> even in OOP, you avoid "global"
14:01:49 <ben22> alright thanks sproingie, I got it
14:01:52 <mcstar> global confusion, it is there...
14:02:06 <Nomad> But there's an evil design pattern called Singleton which relies on a global counter >.>
14:02:09 <sproingie> ben22: yay :)
14:02:16 <Nomad> which people do avoid
14:02:24 <ben22> now all my invalid chars are = 0 sproingie
14:02:35 <ab9rf> Nomad: just because people do a thing does not make it advisable.
14:02:46 <sproingie> singleton doesn't inherently rely on counting anything
14:02:59 <Nomad> it has an internal counter which it relies on...
14:03:03 <sproingie> the closest idiom in haskell to singletons is Reader
14:03:07 <Nomad> well, unless it holds an instance
14:03:08 <mcstar> that counts what?
14:03:16 <Nomad> well, i guess u have a point
14:03:32 <Nomad> since you can just store instances instead of counters
14:03:33 <sproingie> no singleton implementation i've seen counts anything.  they check whether their reference is null
14:03:41 <sproingie> i suppose you could call that a sort of boolean counter
14:03:52 <mcstar> or not call it a counter?
14:03:58 <sproingie> better still
14:04:10 <Nomad> so each counter is "stack based" and /or pipeline based?
14:04:13 <hiptobecubic> a boolean counter?
14:04:19 <hiptobecubic> Like it counts to 1?
14:04:27 <mcstar> and doesnt overflow
14:04:47 <sproingie> Nomad: you're throwing out terms without what appears to be a clear understanding of them
14:04:49 <Nomad> i implemented a few singletons with counters of instances, but that is redundant because you can just check the instances
14:04:51 <mcstar> Nomad: what is a pipline based counter?
14:04:55 <ParahSailin> will attoparsec result in lazy lists?
14:04:56 <Nomad> thats only needed to avoid null issues
14:05:07 <ab9rf> i don't understand what you're talking about, nomad
14:05:14 <sproingie> all monadic actions are in some sense "pipelined", yes
14:05:15 <Nomad> it's okay, nobody does
14:05:46 <Nomad> So you use Monads as temporary contexts?
14:05:51 <sproingie> that's one use for them
14:06:06 <sproingie> a monad is a pattern you derive out of a lot of different computing patterns
14:06:22 <ab9rf> it's more of a challenge to find something you can't use a monad for :)
14:06:26 <Nomad> a monad is not a pattern, it's an abstraction :\
14:06:34 <sproingie> all of them are "within some context about a thing, do something with that thing"
14:07:06 <Nomad> and monads are not about returning, they are about pushing?
14:07:12 <sproingie> (which is actually fmap, i'm having a hard time with the single-sentence summary of monads)
14:07:19 <Nomad> yeah im trying to understand fmap
14:07:37 <Nomad> it requires a Functor, but I don't know how to instantiate a Functor
14:07:38 <sproingie> fmap is the essence of the thing, understand it and you're most of the way there
14:07:47 <ab9rf> sproingie: just say they're like a burrito and run waway
14:08:01 <shachaf> ab9rf: Is that really necessary?
14:08:02 <Nomad> We already discussed the Burrito Monad yesterday
14:08:07 <ab9rf> sorry, i missed that
14:08:19 <Nomad> It was pretty tasty
14:08:19 <ben22> I find zipping and using list comprehension a slick way as opposed to: '1' == 1, '2' = 2, '3' = 3... etc.
14:09:02 <sproingie> analogies abound, but i find it's it's easier to just see monads in action and recognize the pattern rather than be told the pattern up front then derive it for every instance
14:09:07 <mcstar> ben22: id find using the ascii encoding better
14:09:19 <sproingie> humans are really good about detecting patterns, not so good at synthesizing from them
14:09:25 <ben22> mcstar, like ord('c') etc.?
14:09:33 <mcstar> ord 'c'
14:09:35 <ab9rf> sproingie: funny how that works
14:09:40 <ben22> oh right
14:09:42 <Nomad> I was thinking about calculus a bit ago, and realized how amazingly useful partial application is.
14:09:58 <Nomad> Especially trying to compose (x+1)/(x-1) and such
14:10:04 <sproingie> it's powerful stuff
14:10:18 <Nomad> I feel Calculus neglects operators, and treats them as magic until you're old enough
14:10:28 <ab9rf> @pl \x -> (x+1)/(x-1)
14:10:28 <lambdabot> liftM2 (/) (1 +) (subtract 1)
14:10:31 <mcstar> calculus is magic
14:10:32 <Nomad> operators being functions of R -> R -> R
14:10:38 <ab9rf> heh
14:10:38 <sproingie> the parallels to calculus are not accidental, though i was never good enough at math to grok them
14:10:54 <Nomad> I mean, (+)a a = (*)2 a, is this not a partial application?
14:11:05 <sproingie> there's a lot of papers and blog post about doing differentiation on functions that aren't even, well, mathy
14:11:05 <mcstar> thats prefix notation?
14:11:10 <Nomad> yeah
14:11:19 <shachaf> "partial application" is, to a first approximation, a meaningless phrase.
14:11:43 <shachaf> (You can actually give it a good meaning, but that's not really relevant right now.)
14:11:45 <Nomad> What better way to learn category theory than saying abstract nonsense until it starts making sense
14:11:59 <ab9rf> Nomad: that's just because you've gone insane
14:11:59 <mcstar> nomad++
14:12:09 <mcstar> oh, i wanted the other one
14:12:11 <mcstar> nomad--
14:12:14 <sproingie> never worked for me.  i had to see the real thing first and intuit the abstract nonsense out of it
14:12:23 <Nomad> its okay, nomad-- doesnt change who I am, --nomad would
14:12:27 <sproingie> left-brained deductive thinking i guess
14:12:33 <mcstar> @karma nomad
14:12:33 <lambdabot> nomad has a karma of 0
14:12:40 <shachaf> Let's just leave it at that.
14:12:55 <Nomad> This chat has a karma system?
14:13:05 <sproingie> zero karma is supposed to be ideal anyway :)
14:13:18 <mcstar> i hope im negative
14:13:19 <Nomad> agreed
14:13:22 <mcstar> @harma mcstara
14:13:22 <lambdabot> mcstara has a karma of 0
14:13:24 <sproingie> my brother's the only one i know who uses the term correctly when he talks about "feature karma"
14:13:25 <mcstar> @harma mcstar
14:13:25 <lambdabot> You have a karma of -1
14:13:31 <sproingie> as in "if i add this feature, i have to take another out"
14:13:33 <hiptobecubic> haha
14:13:42 <sproingie> of course he's a buddhist so there's that
14:13:47 <ab9rf> sproingie: heh
14:13:51 <Nomad> how do you get negative karma, is it when shachaf doesn't like you?
14:14:01 <hiptobecubic> Nomad--
14:14:01 <Nomad> then again i'd suppose  that would lead to infinite regress
14:14:18 <monochrom> there is no "correctly" until you define "feature"
14:14:22 <sproingie> oh does lambdabot recognize ++ and -- anywhere?   i love bots that do that.  C and Notepad end up with hugely high karma
14:14:25 <mcstar> it was mauke who took my karma
14:14:28 <sproingie> @karma notepad
14:14:28 <lambdabot> notepad has a karma of 41
14:14:33 <hiptobecubic> :D
14:14:34 <ab9rf> sproingie: heh
14:14:35 <mcstar> shachaf just doesnt talk to my no more
14:14:37 <sproingie> @karma C
14:14:37 <lambdabot> C has a karma of 1
14:14:39 <mcstar> me*
14:14:47 <hiptobecubic> @karma c
14:14:47 <lambdabot> c has a karma of 1
14:14:51 <hiptobecubic> shocking
14:14:52 <Nomad> @karma Nomad
14:14:52 <lambdabot> You have a karma of -1
14:14:53 <sproingie> well haskell does have an intermediate form called C--
14:14:58 <monochrom> however, he's a buddhist, so there is also disbelief in precise definitions
14:14:59 <hiptobecubic> Oh right
14:15:11 <Nomad> Well that's not nice, I'm just asking questions and i'm losing karma :(
14:15:27 <ab9rf> Nomad: to be fair, you also blather a lot
14:15:35 <shachaf> Let's just leave the karma be, everyone.
14:15:45 <shachaf> @karma+ Nomad
14:15:45 <lambdabot> Nomad's karma raised to 0.
14:15:50 <Nomad> :)
14:15:54 <dacto> lol
14:16:03 <mcstar> then whats the point in having a karma system?
14:16:35 <Nomad> It effectively makes good people feel bad, and good people feel better
14:17:19 <ab9rf> i feel ambivalent
14:17:21 <silver> @karma c
14:17:21 <lambdabot> c has a karma of 1
14:17:31 * hackagebot git-annex 4.20130314 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20130314 (JoeyHess)
14:17:44 <mcstar> i wonder how did they solve the 'change karma' problem in an immutable fully functional channel
14:18:02 <monochrom> they used ReadWorld passing
14:18:06 <sproingie> we just create a new freenode
14:18:06 <ben22> :t Haskell
14:18:07 <lambdabot> Not in scope: data constructor `Haskell'
14:18:09 <Nomad> well, time doesnt change, we are constantly putting time frames on a stack
14:18:09 <monochrom> err, RealWorld
14:18:47 <Nomad> although we optimize it into loops
14:18:48 <Nomad> but still
14:19:20 <sproingie> there is the theory of the möbius.  a twist in the fabric of space, where time becomes a loop.
14:19:29 <sproingie> (great tune by orbital)
14:20:04 <ben22> from list comp. to primitive recursion, one does not have to use "head"; rather they will use pattern matching syntax such as (x:xs)?
14:20:18 <ab9rf> ben22: that's an option
14:20:45 <ben22> I want to take elliott's word to heart. i want to learn haskell
14:20:46 <mcstar> sproingie: lol, thats from star trek, right?
14:21:05 <Nomad> Ugh, I wish Lambda Calculus and Calculus merged into one, and be called Lambda Calculus
14:21:17 <mcstar> i think picard wasa explaining the fake theory in a horrible waya
14:21:37 <sproingie> strangely enough, it's worf explaining it.  it's all treknobabble anyway.
14:21:52 <sproingie> they used a couple clips from that in that track.  it's an awesome techno track.
14:22:14 <mcstar> oooh, then thats why it was weird, he is the muscle
14:22:25 <yitz> Nomad: no i really don't think you want to be expressing, say, separation of fraction integrals in lambda calculus. it would be a complete nightmare.
14:22:27 <byorgey> fryguybob: pack . unpack is actually efficient in New Zealand.  No one is quite sure why.
14:22:30 <sproingie> michael dorn just has an awesome voice
14:22:49 <Nomad> it would be an expressive and rigorous nightmare :)
14:22:54 <mcstar> sproingie: he is the psychologist bekett used to visit in castle
14:23:01 <ab9rf> sproingie: i'd even watch CHiPs to hear his voice.
14:23:19 <sproingie> he was in CHiPs?  i didnt know that.
14:23:59 <ab9rf> sproingie: yup.  officer jeb turner.
14:25:38 <ben22> thanks guys for the help. au revoir !
14:25:49 <mcstar> bb
14:34:19 <Nomad> I cant help but to break calculus functions like (x+1)/(x-1) into "fc x = let f x = x + 1; g x = x - 1; in (f x) / (g x)"
14:34:40 <Nomad> composes so nicely
14:35:41 <monochrom> Hi. How can I extract Space from Vector Space?
14:37:04 <mcstar> Nomad: i dont see anything worth getting excited there
14:37:18 <mcstar> *for there
14:37:57 <Nomad> because there isn't, it's just nice being able to express  that
14:38:10 <mcstar> what exactly?
14:38:33 <Nomad> that form of composition
14:38:51 <Nomad> and decomposition
14:38:59 <mcstar> f . g is composition
14:39:05 <mcstar> pointless ofc
14:39:13 <Nomad> yeah, but that I did above isn't a . composition
14:39:24 <Nomad> i think...
14:39:43 <Nomad> well, it is if you consider the operator, but I don't
14:39:47 <mcstar> you composed functions
14:39:51 <monochrom> no, "composition" is a general term for a lot of things. use "function composition" specifically for (.)
14:40:04 <Nomad> division is a binary operator, it's confusing to compose
14:40:29 <mcstar> i still dont get it...
14:40:44 <parcs> mcstar: you're just already desensitized to some of the nicities of haskell
14:40:58 <mcstar> really?
14:41:04 <parcs> maybe
14:41:12 <mcstar> are you saying, that code cannot be written in more mainstream languages?
14:41:27 <Nomad> not formally to my understanding
14:41:31 <parcs> it can but not as tersely
14:41:54 <mcstar> i see! thats what i was not 'getting', the terseness
14:42:03 <mcstar> yes, i didnt notice..
14:42:17 <Nomad> eg let f(x) = x, how do I turn it into f(x) = (x+1)/(x-1) through only using composition
14:42:22 <mcstar> also, it is still pointless to me to write it that way
14:42:23 <Nomad> i don't know how to without lambdas
14:42:43 <Nomad> well turn it into f' = (x+1)/(x-1)
14:42:53 <shachaf> Composition is not magic. It's just another function.
14:42:54 <parcs> Nomad: by the way you might want to compile/interpret with -Wall
14:43:06 <parcs> Nomad: you'll notice that you have variable shadowing going on there
14:43:06 <mcstar> f(x+1)/f(x-1)?
14:43:22 <ab9rf> @pl \x -> (x+1)/(x-1)
14:43:22 <lambdabot> liftM2 (/) (1 +) (subtract 1)
14:43:29 <ab9rf> that's how
14:43:45 <Nomad> parcs, I was always curious of the purpose of -Wall flag
14:43:57 <mcstar> also, f' is \x -> 1
14:44:06 <mcstar> if f x = x
14:44:06 <monochrom> it gives you a wall of text. it is therefore called -Wall
14:44:12 <ab9rf> monochrom: haha
14:44:21 <Nomad> >.>
14:45:48 <Nomad> Still really hard to deal with multiple variables in Calculus until you're really deep into calculus, whereas in programming you always deal with multiple variables to do anything useful
14:46:08 <Nomad> which bothers me
14:46:36 <mcstar> i just imagine functions taking multiple arguments asa taking one argument that is a tuple
14:47:11 <Nomad> that helps at first, but tuples are hard to analyze :| to me anyways
14:47:21 <mcstar> so, i write math like this: f (x,y)
14:47:25 <ab9rf> it's also not how haskell approaches it
14:47:29 <mcstar> thats f taking 1 argument of a 2-tuple
14:47:57 <mcstar> nobody gets my joke it seems
14:48:23 <monochrom> wait, it is a joke?!
14:48:36 <mcstar> affirmitive
14:49:03 <Nomad> I mean I can define f(x) = x + 2, but I can't say f'(x,y) = \x->\y->(x+y), then say f(x) = f'(2)
14:49:19 <parcs> lies. + is a function of two variables, and you learn about it in 1st grade
14:49:21 <monochrom> I confess I don't get the joke
14:49:33 <ab9rf> parcs: kindergarten these days
14:49:44 <Nomad> yeah, all operators are two variable, or partially applied two variable
14:49:52 <Nomad> ln x = log e x
14:50:00 <mcstar> monochrom: the joke is, the 'new' way i introduced to denote functions in math, is just like the old one...
14:50:01 <Nomad> which is partially applied two variable
14:50:23 <monochrom> I see now :)
14:50:30 <ab9rf> mcstar: analytically they are interconvertible
14:50:39 <ab9rf> mcstar: although it's tedious to do so
14:51:13 <mcstar> Nomad: have you seen the unary minus or negation?
14:51:25 <Nomad> yeah
14:52:07 <Nomad> havent considered it
14:52:29 <Nomad> (-) :: R -> R
14:52:43 <mcstar> not just R
14:53:42 <mcstar> anybody familiar with norman wildberger?
14:54:18 <Nomad> then again, negation is just a multiplication by -1 isn't it?
14:54:32 <Nomad> so it can be partially applicable
14:54:33 <mcstar> how do you get -1 ?
14:54:41 <Nomad> -1 exists in Real space
14:54:43 <Nomad> we dont need to get it
14:54:46 <Nomad> it just exists
14:55:04 <mcstar> also, it is is multiplication by -1, then 1 argument is already applied...
14:55:13 <Nomad> (neg) x = (mul) (-1) x
14:55:13 <mcstar> so you are back to (-)
14:55:15 <Nomad> so its binary
14:55:19 <mcstar> no
14:55:28 <mcstar> neg x <- unary
14:55:36 <Nomad> its unary by notation
14:55:41 <mcstar> jesus
14:55:42 <Nomad> its partially applied binary
14:55:50 <Nomad> like ln x
14:56:00 <Nomad> (ln) x = (log) e x
14:56:19 <Nomad> -1 exists in real space, so we dont need to negate 1 to get it
14:56:36 <mcstar> what does it mean to exist in real space?
14:56:39 <Nomad> so it makes sense for (neg) x = (mul) (-1) x
14:56:58 <Nomad> anything in the exclusive set of (-infinity, infinity) exists in real space
14:57:02 <Nomad> R1 *
14:57:25 * mcstar is off
14:59:21 <tac> Nomad: what's with your parentheses?
14:59:27 <tac> (ln) x?
14:59:49 <Nisstyre> mcstar: Wildberger is a crank...
14:59:50 <Nomad> just wanted to emphasize it to be prefix, but thats redundant
14:59:57 <Nomad> ln is prefix anyways
15:00:00 <mcstar> Nisstyre: not entirely..
15:00:05 <Nisstyre> mcstar: he's smart
15:00:07 <Nisstyre> but he's insane
15:00:28 <Nomad> ln x = log e x
15:00:28 <mcstar> Nisstyre: i wonder if a geometry over Q^2 is workable
15:00:39 <Nomad> so ln x is partially applied binary operator
15:00:48 <Nisstyre> mcstar: I watched some of his videos, particularly the one where he says functions are nonsense
15:00:57 <Nisstyre> and the one where he says infinite sets don't exist
15:01:01 <mcstar> Nisstyre: i watched 35 of his...
15:01:10 <Nomad> knowing this, if i see a test using log 90 x extensively, I can say lg x = log 90 x
15:01:16 <mcstar> he is a dear fellow strict finitist...
15:01:32 <Nisstyre> mcstar: he's an extreme constructivist I guess
15:02:02 <Nomad> brb
15:02:09 <mcstar> Nisstyre: i am more concerned about doing geometry over Q^2 and solving stuff with quanatifier elimination over Q
15:02:21 <Nisstyre> mcstar: I haven't really looked into his geometry stuff
15:04:14 <mcstar> "The concept of a type family comes from type theory." noway
15:04:16 <Nisstyre> mcstar: I actually discovered his videos while I was researching the Stern-Brocot tree
15:04:23 <Nisstyre> that particular video was actually really good
15:04:50 <mcstar> Nisstyre: i think i was searaching for crackpots, when i discovered him
15:04:58 <Nisstyre> heh
15:06:52 <Nomad> a derivative is a higher order function right?
15:06:59 <Nomad> binary higher order function*
15:07:38 <pdexter> Nomad: what do you mean by ``all operators'', you mention ln in your examples, is that an operator in this case? if so, what about cos, sin, etc. how can those be represented as binary operators
15:08:05 <Nomad> yeah ln is a partially applied function of the log(a, b) operator
15:08:38 <mcstar> stop this pls
15:09:13 <mcstar> an operator is something that can have preference, because it it stands between terms
15:09:19 <mcstar> precedence*
15:09:42 <Nomad> that's true.
15:09:57 <tac> Nisstyre: I agree on the Wildberger comment
15:10:14 <mcstar> in haskell, they are composed from certain characters, mainly non-abc
15:10:18 <tac> he has a knack for teaching things geometrically, for sure
15:10:34 <mcstar> tac: he has a good teaching style
15:10:46 <mcstar> i wouldnt mind him teaching children
15:11:03 <mcstar> (not necessairly teaching his stuff, but his style is good)
15:11:11 <tac> As long as he isn't allowed to teach them set theory, right :)
15:11:12 <Nomad> njwildberger?
15:11:16 <Nisstyre> yeah he seems like a good expositor
15:11:22 <tac> Nomad: yeah
15:11:23 <Nisstyre> but, wtf man
15:12:31 <tac> When I first read about ultra-finitists, I thought they were just a hypothetical argument to explain to constructivists that their viewpoint was not absolute
15:12:42 <tac> but it turns out, they're real!
15:12:48 <tac> and they get thousands of hits on YouTube!!!
15:13:08 <mcstar> maybe it is an electronic band
15:14:23 <mcstar> wait, why youtube?
15:14:34 <tac> (because that's where he posts his videos)
15:14:36 <mcstar> far from the standard way to learn about math
15:14:48 <monochrom> perhaps, the very first ultra-finitist was pulling that prank. but you know, some people must take it seriously and become the second ultra-finitists.
15:15:20 <tac> monochrom: I'm just glad that same principle doesn't work for calling into work with a fake illness
15:15:22 <mcstar> monochrom: and then ppl invested multi billion dollars in it, so they must keep the ruse going
15:15:38 <tac> (mcstar: like PHP's continued existence?)
15:15:43 <mcstar> right
15:15:59 * tac feels like this is a #haskell-blah kinda convo
15:16:09 <tac> To the appropriate channel!
15:16:17 <monochrom> mcstar come to #haskell-blah!
15:16:27 <mcstar> im am slow, wait up
15:16:32 <monochrom> do { x <- #haskell-blah; x }
15:17:13 <mauke> I see what you did there
15:24:04 <hpaste> PS pasted “space leak” at http://hpaste.org/84051
15:24:26 <ParahSailin> is there any obvious way to fix the memory allocation in http://hpaste.org/84051
15:25:12 <jtbandes> @pl (\f g -> p (q (r f g)))
15:25:12 <lambdabot> ((p . q) .) . r
15:33:09 <lispy> @pl \p q -> (not p) || q
15:33:09 <lambdabot> (||) . not
15:33:50 <shachaf> @pl \p q -> q || not p
15:33:50 <lambdabot> flip (||) . not
15:34:00 <lispy> Pointless logic :)
15:34:13 <monochrom> under some circumstance, you can use <= for that
15:34:16 <mcstar> lispy: what do you imply?
15:34:38 * lispy can't tell if that's a pun or a question
15:34:45 <monochrom> hehe
15:34:54 <ab9rf> or a dessert topping
15:34:57 <mcstar> oleg doesnt need to define the implication operator, he has got the typelevel =>
15:35:06 <mcstar> lispy: pun
15:35:08 <monochrom> @check \x y -> (x <= y) == (not x || y)
15:35:10 <lambdabot>   Not in scope: `myquickcheck'
15:35:16 <monochrom> ooohhh
15:35:36 <lispy> mcstar: okay. I thought so :)
15:35:45 <lispy> well, thought it likely
15:38:39 <otters> :t (<=)
15:38:40 <lambdabot> Ord a => a -> a -> Bool
15:39:03 <shachaf> data Bool = True | False deriving (Eq,Ord)
15:40:53 <monochrom> if you prefer that order, use =>
15:40:56 <monochrom> err, <=
15:41:00 <monochrom> err, >=
15:41:37 <shachaf> Why?
15:41:46 <Spockz> monochrom: didn't you mean =< ? :)
15:41:48 <shachaf> I want "a<=b" to mean "b implies a"
15:41:57 <monochrom> I am suggesting operators for "implies"
15:42:30 <parcs> is a  conditional boolean expression usually true or false?
15:42:32 * hackagebot hails 0.9.2.2 - Multi-app web platform framework  http://hackage.haskell.org/package/hails-0.9.2.2 (DeianStefan)
15:43:03 <monochrom> conditional boolean expression? is it different from simply boolean expressions?
15:43:05 <shachaf> parcs: Usually it's true.
15:43:05 <mcstar> what is a conditional boolean expression?
15:43:25 <parcs> one that's used for branching i guess
15:43:31 <monochrom> but I guess it is "yes, usually true or false"
15:43:37 <mcstar> ^
15:43:47 <parcs> no but seriously
15:43:50 <mcstar> except for types that coerce to true or false
15:43:51 <shachaf> Usually it's true or false, but sometimes it's neither.
15:44:02 <monochrom> then I don't know. depends on the expression
15:44:13 <parcs> do developers tend to use boolean expressions that usually evaluate to true or false?
15:44:24 <mcstar> haskell developers yes
15:44:37 <parcs> it's funny because the sentence is ambiguous!
15:44:50 <mcstar> exclisive or
15:44:53 <mcstar> exclusive
15:45:14 <monochrom> ok, I see your question. programmers certainly intend the boolean expression to be non-bottom
15:45:46 <monochrom> if anything, because "if bottom then... else..." is bottom
15:46:05 <parcs> there is probably no tendency either way i think
15:46:10 <mcstar> you cant test for bottom
15:46:26 <parcs> yeah you can
15:46:30 <monochrom> ok, I didn't see your question
15:46:35 <mcstar> parcs: how?
15:46:56 <parcs> you can test for some non bottom, those that throw an exception
15:46:59 <mcstar> without looking at the program from the outside
15:47:02 <parcs> er, bottom
15:48:17 <monochrom> if you have a loop/recursion that goes "if the set is empty, then done; otherwise do something and repeat on a smaller set", then "the set is empty" is likely false most of the time
15:48:42 <shachaf> ZF with branch prediction
15:49:13 <monochrom> but you could have equally written "if the set is not empty, do something and repeat on a smaller set; otherwise done", then the operand is likely true most of the time
15:49:29 <monochrom> so, I must say, that depends on the expression
15:50:17 <mcstar> lets just pattern mathc, and forget about 'if'
15:50:25 <mcstar> problem solved
15:50:41 <monochrom> yes, but pattern match is not available for set, map, vector
15:50:50 <mcstar> why not?
15:50:55 <mcstar> surely it is
15:51:15 <monochrom> because their APIs don't expose it
15:51:47 <monochrom> also bytestring, text, sequence
15:53:10 <mcstar> monochrom: are you talking about haskell?
15:53:18 <mcstar> i wasnt
15:53:56 <mauke> through a scanner, darkly
15:53:57 <monochrom> I am talking about haskell
15:54:19 <monochrom> specifically Haskell Platform, too
15:54:26 <shachaf> That *is* what this channel is for, mcstar.
15:54:41 <mcstar> ty shachaf i missed your voice
15:55:08 * shachaf sighs.
16:04:18 <Nomad> is it possible to create a data type u which is recursively defined to be itself, but if we subtract u from u, we get 0?
16:04:35 <Nomad> if we add u + u, we get u
16:04:44 <Nomad> and if we divide u by u, we get 1
16:05:09 <Hafydd> What does it mean to add two types?
16:05:32 <c_wraith> In fact, what do 0 and 1 mean?
16:05:32 <Nomad> I want to represent the smallest positive number nonzero
16:05:39 <Nomad> which does not exist
16:05:43 <Nomad> but I can define it to be itself
16:05:47 <Nomad> and associate properties to it
16:06:00 <Nomad> like dx + dx = dx, dx / dx = 1, dx - dx = 0
16:06:07 <Nomad> is this possible?
16:06:12 <c_wraith> Oh, you want to add infinitesimals to a set?
16:06:20 <Nomad> sounds about right
16:06:34 <c_wraith> The standard way to do that is to extend the number system in a manner similar to complex numbers
16:06:59 <Nomad> hmm?
16:07:03 <c_wraith> Except instead of creating i such that i*i = -1, you create u such that u * u = 0 (but u /= 0)
16:07:13 <latro`a> that's not really the "standard" way
16:07:14 <Nomad> i never said u*u = 0 :|
16:07:20 <Nomad> i dont know what u*u is :|
16:07:29 <Nomad> i think its u
16:07:31 <HowToStartATP> @Nomad, look at this blog post: http://blog.sigfpe.com/2006/09/infinitesimal-types.html
16:07:31 <lambdabot> Unknown command, try @list
16:07:33 <Hafydd> Is u*u less, greater or equal to u?
16:07:38 <Nomad> less
16:07:41 <Nomad> but not 0
16:07:43 <Nomad> so still u
16:07:46 <Hafydd> Then u isn't the smallest number.
16:07:47 <Nomad> since u is infinitesimal
16:07:51 <latro`a> u can't be less than itself
16:07:51 <Hafydd> []
16:07:53 <Nomad> exactly!
16:08:01 <c_wraith> that's why u * u = 0
16:08:07 <latro`a> infinitesimals are smaller than all finite things
16:08:13 <latro`a> not all infinitesimal things
16:08:26 <TravisD> hmm, isn't 0 "finite"?
16:08:34 <Nomad> yeah, its not 0
16:08:35 <Nomad> its u
16:08:35 <latro`a> *finite positive
16:08:50 <Nomad> u*u is going to be smaller than u but greater than 0, so its still u
16:08:59 <latro`a> no, it's a different infinitesimal
16:09:00 <Nomad> infinitesimals are magic like that
16:09:00 <c_wraith> so..  u < u ?
16:09:07 <Hafydd> I recommend thinking about the mathematics a bit before trying to implement a representation in Haskell.
16:09:08 <latro`a> or in smooth infinitesimal analysis 0
16:09:33 <Nomad> i mean limit wise, its 0, but its not actually 0 :|
16:09:33 <latro`a> but in what is more commonly called "nonstandard analysis", it's a different, positive infinitesimal
16:09:43 <latro`a> which is "far smaller" than the first one
16:09:54 <latro`a> no, in smooth infinitesimal analysis you *define* infinitesimals to have square 0
16:10:01 <Nomad> hmm
16:10:02 <c_wraith> Nomad: you should really read the post HowToStartATP posted above.
16:10:12 <Nomad> what's ATP?
16:10:19 <c_wraith> doesn't matter, that's a username
16:10:45 <latro`a> smooth infinitesimal analysis is probably the closest thing to how physicists handle infinitesimals
16:10:59 <Nomad> anyways, im more interested in creating the data for now, is it possible or not
16:10:59 <mcstar> adenosin triphosphate?
16:11:13 <latro`a> you have to decide what it means to be infinitesimal
16:11:16 <TravisD> Nomad: You can add a new element to the field of real numbers with the properties that u * u = 0 and u != 0. It turns out that if you do this, u behaves a lot like an "infinitesimal"
16:11:17 <Nomad> eg, arbitrary data which gives: a+a=2, a-a=3
16:11:18 <c_wraith> Nomad: you *really* should read the link. You would then stop asking these questions, because it answers them
16:11:18 <Hafydd> Not if you don't know what properties it must satisfy.
16:11:29 <Nomad> i missed the link, can you repost?
16:11:37 <Hafydd> Or while the properties are self-contradictory.
16:11:44 <c_wraith> http://blog.sigfpe.com/2006/09/infinitesimal-types.html
16:11:47 <latro`a> it's a bit more like a formal symbol
16:11:55 <latro`a> like how i is added in to the reals as a formal symbol
16:13:12 <lambdazerocool> silly question - I've got runState and runWriter, but why only runErrorT and no runError?
16:13:30 <latro`a> the motivating example for why they should have square zero is the product rule: (f+df)(g+dg)-fg=fg+fdg+gdf+dfdg-fg=fdg+gdf+dfdg
16:13:53 <latro`a> (a formal symbolic calculation)
16:14:04 <latro`a> then if dfdg=0 you get the product rule in differential form
16:14:48 <latro`a> anyway, from a computational angle you can define them as vectors, sort of like how complex numbers are vectors
16:15:07 <Nomad> im just frustrated by definition of derivatives, it doesnt seem to flow, i can't explain it any better.
16:15:19 <Nomad> well, limits
16:15:21 <Nomad> not derivatives
16:15:32 <latro`a> limits don't involve any infinitesimals
16:15:43 <Nomad> they don't, they involve an arbitrary constant
16:15:51 <Nomad> well, derivatives do
16:15:52 <mcstar> not arbitrary
16:16:18 <Hafydd> They don't involve any constant (necessarily)
16:17:27 <latro`a> derivatives don't involve a constant at all, antiderivatives are another story
16:17:46 <Nomad> lim h->0 (f(x+h) - f(x))/h
16:17:51 <Nomad> h is an arbitrary constant
16:17:54 <latro`a> no it's not
16:18:01 <latro`a> it's not a constant at all, it's universally quantified
16:18:19 <latro`a> eh, not universally, but quantified
16:18:19 <TravisD> hmm - clearly taking the derivative of a constant somehow involves a constant. Some of these statements aren't very precise
16:18:22 <latro`a> not constant
16:18:27 <Nomad> i mean, i'd like to define it as data h a = h a
16:18:36 <Nomad> actually, that's a terrible definition
16:18:39 <latro`a> ????
16:18:40 <Nomad> ignore that
16:18:51 <Hafydd> I'm glad you have come to this opinion.
16:19:28 <latro`a> in smooth infinitesimal analysis, (a,b)+-(c,d)=(a+c,b+d); (a,b)*(c,d)=(a*c,a*d+b*c),
16:19:30 <latro`a> gah
16:19:34 <latro`a> hit enter too soon
16:19:54 <latro`a> in smooth infinitesimal analysis, (a,b)+-(c,d)=(a+-c,b+-d); (a,b)*(c,d)=(a*c,a*d+b*c), and division isn't defined
16:20:05 <Nomad> latro, kinda curious, where did you learn all that?
16:20:12 <latro`a> links like the one above
16:20:28 <latro`a> the idea there is just that of a formal calculation, (x+dx)+(y+dy) etc.
16:21:20 <Nomad> i mean i wanted to definite an infinitesimal in the sense of concrete infinitesimal, where I * I = I, I / I = 1, I + I = I, I - I = 0, im more interested in whether I can declare such a data type in haskell or not
16:21:26 <Nomad> even if its completely wrong
16:21:37 <latro`a> having I*I=I breaks a lot of things
16:21:44 <latro`a> as in, that makes the object useless
16:21:47 <latro`a> since it makes I=1
16:21:54 <latro`a> and then breaks I+I=I
16:22:08 <latro`a> (as in, you can prove that such a thing can't be...what is it, a ring I guess)
16:22:29 <latro`a> the addition and multiplication will not do the normal things with those rules
16:22:35 <TravisD> latro`a: What about the trivial ring {0}?
16:22:56 <c_wraith> Fine, they can't be part of a ring with more than one element.
16:23:00 <latro`a> that doesn't have the inverse he wants, but I guess that works
16:23:02 <Nomad> if  you start throwing I around as if it was a number, yes it would be possible to prove 1 = 9
16:23:05 <latro`a> but still, trivial ring isn't satisfactory
16:23:08 <Nomad> but that's not the reason I want I
16:23:20 <Nomad> I is not a number
16:23:20 <latro`a> you can't do analysis in that framework, I'll put it that way
16:23:30 <latro`a> I*I=I and I+I=I together make your system a trivial ring
16:23:36 <Nomad> I dont want it for analysis, I want it for testing
16:23:37 <latro`a> assuming you want it to be a ring, which you almost certainly do
16:23:40 <latro`a> testing of what?
16:23:42 <Nomad> whether or not I can do something like that
16:23:59 <latro`a> sure, it's a trivial ring, you have a type with one element and some binary functions that have one return value
16:24:01 <Nomad> I mean, it wouldnt harm the system, because it'll only go by rules I define for that type
16:24:20 <Nomad> for instance, I want a type A which A+A=0, A-A=1, A*A=2, A/A=3
16:24:27 <Nomad> makes no sense, but in context of A... it does
16:24:35 <Nomad> would it be possible though?
16:24:37 <TravisD> Nomad: If you force yourself to follow the already established rules (commutativity of addition, distributivity, etc) then your rules force the number system to break down so that everything is equal to I
16:24:42 <Hafydd> What does it mean to add two types?
16:24:56 <Nomad> it means what I tell it to mean
16:25:02 <Nomad> oh
16:25:04 <Nomad> i see what u mean
16:25:10 <TravisD> Nomad: only if you're willing to be inconsistent
16:25:15 <Hafydd> Have you read about Haskell's type system? Do you know what a "type" is?
16:25:26 <Nomad> So i cant do that because i'd need to redefine meaning of the standard arithmetic
16:25:36 <Nomad> which would effectively make me evil
16:25:49 <Hafydd> I don't think that's the problem.
16:25:49 <latro`a> beyond that, if you even required a few of the basic rules you still get a trivial ring
16:26:10 <Nomad> In other words, if I want to do something like that, I should use C++ instead
16:26:19 <TravisD> heh
16:26:37 <latro`a> but yes, you can have data Foo = Foo; f Foo Foo = Foo -- (+); g Foo Foo = Foo -- (*); h Foo Foo = Foo -- (-)
16:26:51 <Hafydd> Nomad: is that you, afat?
16:27:00 <Nomad> who's afat? O_o
16:27:32 <latro`a> your rules+a few of the basic arithmetic rules (not all of them, in particular no requirement of division) force that to be the only way to do what you want (up to isomorphism)
16:28:00 <latro`a> and I assume that isn't really what you wanted from this
16:28:16 <Nomad> No, but thanks a lot for the ideas
16:28:27 <Nomad> and answers...
16:31:38 <Nomad> wait, so it is possible to override + for operations for a particular set, or not?
16:31:57 <silver> set of what
16:32:21 <Nomad> sets of data A = A deriving Show
16:32:30 <geekosaur> if you can figure out what to define all its members including (+) to do, you could make it an instance of Num, yes
16:32:42 <c_wraith> You can override (+) for a set of values.
16:32:55 <c_wraith> However, if you're talking about adding types, you're not talking about sets of values
16:33:11 <Nomad> ah
16:33:15 <Nomad> I can only add objects
16:33:18 <c_wraith> And adding types is something that only exists at a meta level in haskell
16:33:29 <c_wraith> It's talked about because it's a meaningful concept
16:33:39 <c_wraith> But it isn't something you do in the language
16:34:03 <mcstar> you dont have to define the other functions, only (+)
16:34:10 <mcstar> if you want that..
16:37:39 <quchen> Can I use TH as a sort of poor man's supercompiler easily?
16:38:49 <quchen> I've been trial-and-error-ing a bit with $() and [| |] in GHCi, but to no avail.
16:38:52 <monochrom> perhaps possible but not easily
16:39:22 <quchen> monochrom: Oh. So I can't just put $() around a function and it'll compute it at compile time?
16:39:30 <Hafydd> Nomad: numerical operators can be overloaded in Haskell, by way of the Num typeclass.
16:39:38 <quchen> (Not that it compiles like that, but that was the way I thought it could go)
16:39:43 <monochrom> I don't know
16:39:47 <Nomad> hmm
16:40:04 <Hafydd> (as can Numeric literals)
16:40:33 <Nomad> I successfully created a = MyType... just trying to figure out how to make silly operator overriding between two objects of this category
16:42:40 <mcstar> is there a book on the advanced type system features of haskell(the ghc extensions)?
16:42:50 <mcstar> or the way to learn them, is by going over the wiki?
16:43:25 <monochrom> I go over the GHC user's guide first. and then, I find that I seldom need the wiki
16:43:30 <hpaste> Hafydd pasted “(+) overloading” at http://hpaste.org/84053
16:43:56 <Hafydd> Nomad: there's an example.
16:44:13 <Nomad> thanks :)
16:52:17 <liyang> mcstar: usually the GHC user guide is enough, but you can always look up the paper where it is described.
16:52:59 <mcstar> if i had all the time in the world..., but good idea
16:53:25 <monochrom> in most cases I find that I don't need the papers either
16:53:35 <Nomad> i tried running your code, but I got errors `No explicit method nor default method for '*'  `
16:53:44 <Hafydd> Those are warnings, not errors.
16:53:49 <mcstar> warning, not eror
16:53:53 <Nomad> ph
16:53:54 <Nomad> oh*
16:54:07 <Nomad> what is it warning me about >.>
16:54:13 <mcstar> what it says
16:54:24 <Hafydd> The fact that I didn't define some of the other member functions of Num.
16:54:36 <ben22> I made this here:
16:54:40 <ben22> pairs :: [(Integer, Integer)]
16:54:40 <ben22> pairs = [(m, n) | m <- [0..], n <- [0..m]]
16:54:48 <Nomad> ah, so Num must satisfy all operations of Num
16:54:51 <Nomad> whereas you only defined one
16:54:52 <ben22> but when I put pair (3,7872) it infinite loops to check if it exists
16:54:55 <ben22> partOf :: (Integer, Integer) -> Bool
16:54:55 <ben22> partOf singlePair
16:54:55 <ben22> 	| elem singlePair pairs = True
16:54:55 <ben22> 	| otherwise = False
16:55:29 <geekosaur> "should"; it's a warning. (it's also a very good idea)
16:55:46 <mcstar> if something returns a bool and you dont negate it, you can just return that
16:55:50 <Nomad> i got that, im trying to think if I can derive my own Num, called "Illogical"
16:55:51 <mcstar> you dont need the guards
16:56:03 <Nomad> it would be a class though
16:56:07 <Nomad> i think
16:56:47 <monochrom> infinite loop is correct behaviour here. the computer does not know that (3,7872) is not in the list until the end of the list is seen.
16:57:05 <ben22> thanks monochrom, so is it correct as the way it is?
16:57:10 <monochrom> yes
16:57:16 <ben22> you are golden, thanks
16:57:31 <mcstar> ben22: you can enumerate pars of integers in c = a + b way, c = 0..
16:57:32 <monochrom> FWIW, elem False (repeat True) is also supposed to be an infinite loop
16:57:34 * hackagebot neat-interpolation 0.1.0 - A quasiquoter for neat and simple multiline text interpolation  http://hackage.haskell.org/package/neat-interpolation-0.1.0 (NikitaVolkov)
16:57:41 <mcstar> pairs*
16:58:02 <mikeplus64> ben22: (also note what mcstar said; partOf singlePair = elem singlePair pairs
16:58:05 <mikeplus64> )
16:58:15 <ben22> ok, thanks for the input fellows !!!
16:58:17 <monochrom> fortunately, or (repeat True) is not an infinite loop
16:58:49 <danharaj_> Does anyone know why my .lhs file written in markdown causes GHC to freak out at '#'?
16:59:21 <monochrom> I don't
17:00:08 <mikeplus64> danharaj_: CPP, maybe?
17:00:30 <danharaj_> mikeplus64: CPP is an extension it shouldn't matter if it's off.
17:01:00 <mikeplus64> yeah, hence the maybe
17:01:42 <mcstar> oh byorgey you actually helped build the inference engine
17:02:07 <danharaj_> mikeplus64: so you were right. it's a GHC bug: http://hackage.haskell.org/trac/ghc/ticket/4836
17:02:10 <mcstar> (i didnt know you were such high profile...i guess there might be others too then)
17:04:57 <mcstar> anyway, gn
17:08:01 <ben22> what are "hamming numbers"?
17:10:29 <pdxleif> It's a table of numbers indicating the durations to cure/age various weights of ham
17:10:34 <amindfv> http://en.wikipedia.org/wiki/Regular_number
17:10:42 <bobajett> noob question. how do I convert ["001","002","003"] into Ints with map? map (read :: Int) ["001","002","003"] doesn't work.
17:10:53 <amindfv> actually, sorry, pdxleif is right
17:11:07 <shachaf> bobajett: The type of read is not Int.
17:11:21 <shachaf> When you say (read :: Int), you're specifying that its type is Int.
17:11:28 <centrinia> :t read
17:11:30 <lambdabot> Read a => String -> a
17:11:30 <bobajett> oh.
17:11:35 <monochrom> (read :: String -> Int)
17:11:39 <shachaf> But you want it to return an Int.
17:11:51 <monochrom> or, map read [] :: [Int]
17:11:56 <ben22> read"12"::Int
17:11:57 <shachaf> You can do what monochrom said. You can also do this: map read ["001","002","003"] :: [Int]
17:12:08 <shachaf> Hmm, Scratch the second half.
17:12:11 <shachaf> Just do what monochrom said.
17:12:51 <monochrom> you see why I keep saying: I use partial functions just fine, I can prove that they cause no errors!
17:15:07 <pdxleif> In idris they have "cast", and it's a total function, e.g. cast "5" can give you a '5'.
17:16:18 <bobajett> Im sorry, I don't even understand how to translate what monochrom said to functioning code. map read ["001","002","003"] :: Int ?
17:16:33 <c_wraith> > map read ["001","002","003"] :: Int
17:16:35 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
17:16:35 <lambdabot>              with actual type ...
17:16:42 <c_wraith> > map read ["001","002","003"] :: [Int]
17:16:43 <lambdabot>   [1,2,3]
17:16:54 <bobajett> oh
17:16:55 <c_wraith> Looks like what monochrom said was functioning code
17:17:11 <bobajett> I made the same mistake as you did up there :-)
17:17:18 <bobajett> Int instead of [Int]
17:17:23 <c_wraith> Well, I just copied your text without reading it. :)
17:17:32 <bobajett> recursive mistakes
17:18:04 <bobajett> In Haskell even your mistakes are recursive :-)
17:18:24 <c_wraith> mistakes are often recursive.  sometimes infinitely..
17:18:38 <sipa> you mean you can be infinitely wrong?
17:18:42 <c_wraith> > let f x = x : x in f 0
17:18:42 <bobajett> thats where laziness really helps
17:18:43 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
17:18:43 <sproingie> > fix error
17:18:45 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
17:26:53 <latro`a> I should start putting that in programs at random
17:27:06 <latro`a> if catastrophic_failure then fix error else win
17:27:38 <lispy> > if True then fix error else hGetContents
17:27:39 <lambdabot>   Not in scope: `hGetContents'
17:27:39 <lambdabot>  Perhaps you meant one of these:
17:27:39 <lambdabot>    `BSC.hGetC...
17:27:46 <lispy> > if True then fix error else BSC.hGetContents
17:27:48 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:27:48 <lambdabot>              with actual ty...
17:28:23 <absence> is there a way to find out how many bytes have been consumed with attoparsec?
17:29:24 <Xaratas> hm
17:29:45 <Xaratas> takeIf
17:29:47 <Xaratas> hmm
17:30:59 <latro`a> if that's what I think it is, it's called filter
17:39:12 <Xaratas> hm
17:39:41 <Xaratas> a list of bool and a list of something, and a takeIf would be nice
17:41:33 <latro`a> @type let f bs xs = filter fst $ zip bs xs in f
17:41:34 <lambdabot> [Bool] -> [b] -> [(Bool, b)]
17:41:39 <latro`a> erm
17:41:57 <latro`a> eh
17:42:11 <latro`a> guess you want to map snd or something
17:42:35 * hackagebot Win32-services 0.1 - Windows service applications  http://hackage.haskell.org/package/Win32-services-0.1 (MichaelSteele)
17:43:08 <Xaratas> maybe its a zipWith
17:43:27 <Xaratas> but if i put in an if, whats the else part?
17:43:31 <latro`a> zipWith would have the same length
17:43:35 <latro`a> as the shortest one
17:44:01 <latro`a> you'd want a filter+map in one traversal arguably
17:44:06 <Xaratas> yes, i want to reduce my list of something to only these wher my predicate list is true
17:44:19 <Xaratas> +e
17:46:26 <latro`a> :t foldr (\(b,x) xs -> if b then x:bxs else bxs) []
17:46:27 <lambdabot>     Not in scope: `bxs'
17:46:28 <lambdabot>     Perhaps you meant `xs' (line 1)
17:46:28 <lambdabot>     Not in scope: `bxs'
17:46:31 <latro`a> er
17:46:37 <latro`a> :t foldr (\(b,x) xs -> if b then x:xs else xs) []
17:46:39 <lambdabot> [(Bool, a)] -> [a]
17:47:03 <latro`a> Xaratas, ^
17:47:52 <Xaratas> hm
17:49:42 <latro`a> if you know the list is finite you can reverse the arguments and do foldl' (and then maybe reverse the list at the end, if the order matters)
17:50:30 <bobajett> let stringNumberIsBigger some_string m = n > m where n = read some_string :: Int
17:50:51 <bobajett> as silly as that function is, if I want to use it in a map ...
17:51:08 <bobajett> or rather in a filter ...
17:51:34 <bobajett> filter (stringNumberIsBigger 3) ["1","2","3",4"]
17:51:45 <arkeet> bobajett: you'll have to flip the arguments.
17:51:46 <bobajett> do I have to use flip to get the arguments right?
17:52:38 <bobajett> so when designing functions like this, one should just flip the arguments in the function definition to begin with?
17:54:06 <arkeet> it depends on how you intend to use it.
17:54:33 <arkeet> if you expect one of the arguments the vary a lot, you might put it as the last argument
17:54:38 <arkeet> so that it's easy to use partially applied
17:55:27 <hammersbang> Hello guys, I need your opinions. I'm doing a minor in computer science. So far, I have chosen to take the following courses: System Hardware, Mathematics for Computer Science, Object-Oriented Programming I, Object-Oriented Programming II, Data structures and Algorithms, Advanced Program Design in C++,  and Databases. I need eight courses in total so I need one more. Any suggestions of a computer science course that would 
17:55:27 <hammersbang> me more "well-rounded" as a programmer? Thanks
17:55:36 <centrinia> :t map snd . filter fst
17:55:38 <lambdabot> [(Bool, b)] -> [b]
17:55:50 <latro`a> centrinia--I mentioned that, but it will traverse twice
17:55:56 <bobajett> I guess where Im coming from is, in lisp I read (> 2 3) as: Is 2 greater than 3. So the thing being compared to (compartor?) is on the right
17:56:29 <bobajett> and so I end up writing my Haskell functions the same way with the invariant so to speak as the last argument
17:56:46 <sipa> bobajett: that's equivalent to ((>) 2 3) in Haskell
17:57:30 <bobajett> but I guess in Haskell one writes a functions arguments with partial application in mind (especially if the function would be fed to a map/filter)?
17:57:43 <Xaratas> o, was simpler than i thought
17:57:54 <latro`a> often, yeah, but lambdas aren't so bad either
17:59:58 <arkeet> @ty (>>= \a -> guard (fst a) >> return (snd a))
18:00:00 <lambdabot> MonadPlus m => m (Bool, b) -> m b
18:00:21 <latro`a> nice
18:00:55 <arkeet> let's make it more point-free.
18:01:07 <arkeet> :t (=<<) (liftA2 (>>) (guard.fst) (return.snd))
18:01:08 <lambdabot> MonadPlus m => m (Bool, b) -> m b
18:02:02 <arkeet> but surely map and filter can be fused.
18:02:05 <arkeet> :t build
18:02:07 <lambdabot>     Not in scope: `build'
18:02:07 <lambdabot>     Perhaps you meant `buildG' (imported from Data.Graph)
18:02:16 <latro`a> they can, but I don't think you can be assured that they will
18:02:32 <latro`a> Data.List might have rules for that fusion though
18:02:36 <arkeet> @let build :: (forall b. (a -> b -> b) -> b -> b) -> [a]; build g = g (:) []
18:02:37 <lambdabot>   TypeOperators is not enabled
18:02:42 <arkeet> :/
18:03:06 <arkeet> @let build g = g (:) []
18:03:09 <lambdabot>  Defined.
18:04:05 <arkeet> @src filter
18:04:05 <lambdabot> filter _ []     = []
18:04:05 <lambdabot> filter p (x:xs)
18:04:05 <lambdabot>     | p x       = x : filter p xs
18:04:05 <lambdabot>     | otherwise = filter p xs
18:04:28 <latro`a> the fusion is in the pragmas, not elsewhere
18:04:33 <arkeet> indeed
18:04:34 <latro`a> (if anywhere)
18:06:26 <arkeet> @ty \p -> build (\c z -> foldr (\x y -> if p x then x `c` y else y) z)
18:06:28 <lambdabot> (a -> Bool) -> [a] -> [a]
18:06:59 <ben22> how can one filter an infinite list of numbers to its respective divisors of 2,3,5?
18:07:18 <arkeet> @ty \f -> build (\c z -> foldr (\x y -> f x `c` y) z)
18:07:19 <lambdabot> (a1 -> a) -> [a1] -> [a]
18:07:27 <latro`a> you mean requiring the values to be divisible by all three numbers?
18:07:28 <Xaratas> at least it works like expected
18:07:28 <latro`a> or what
18:07:37 <ben22> for example
18:07:49 <Xaratas> o
18:08:01 <ben22> hamming 100 = [1,2,4,5] but factors 100 = [1,2,4,5,10,20,50,100]
18:08:10 <Xaratas> this are the hamming numbers
18:08:30 <ben22> I want to get rid of 10,20,50,and 100 because their divisors surpass the hamming numbers
18:08:36 <arkeet> @ty foldr ((:) . ?f) []
18:08:38 <lambdabot> (?f::a -> a1) => [a] -> [a1]
18:08:58 <dmwit> ben22: Prime factorize, then only recombine powers of 2, 3, and 5 instead of doing all recombinations.
18:09:06 <Xaratas> for hamming numbers the easy way use listcomprehension
18:09:11 <latro`a> ^is technically valid but an absolutely terrible idea
18:09:13 <latro`a> @ dmwit
18:09:20 <ben22> here is my work so far:
18:09:35 <dmwit> latro`a: Really? Why?
18:09:41 <ben22> factors :: Int -> [Int]
18:09:41 <ben22> factors x = [ y | y <- [1..x], x `mod` y == 0 ]
18:09:42 <ben22> hamming :: [Int] -> [Int]
18:09:42 <ben22> hamming fac = [ y | y <- fac, (*filtering goes here*)]
18:09:43 <latro`a> prime factorization is a hard problem
18:09:46 <latro`a> as currently understood at least
18:09:56 <dmwit> latro`a: Not prime factorization when you're only looking for the factors 2, 3, and 5.
18:10:13 <latro`a> then it isn't really factorization, is it?
18:10:18 <ben22> do you guys have ideas?
18:10:27 <dmwit> ...and laziness can turn your general factorization algorithm into one that looks only for 2, 3, and 5 as factors very easily.
18:10:34 <latro`a> sure
18:10:49 <dmwit> So, this satisfies all your objections?
18:11:11 <latro`a> with the modification, yeah
18:11:19 <latro`a> I think a faster way in general would be to use logarithms, though
18:11:37 <ben22> in hamming, i'm populating the list with function "factors" and then later I want to filter the divisors that are above the hamming numbers
18:11:49 <nejucomo> If you want the prime factorization of the first N natural numbers, it's not a hard problem (it's a variation of the sieve of eratosthenes).
18:12:08 <nejucomo> (I don't have much context on the conversation, sorry if that's noisy.)
18:12:17 <latro`a> it's a hard problem relative to N, rather than relative to the whole list
18:12:59 <latro`a> eh nvm my logarithm idea doesn't actually make sense
18:13:10 <ben22> maybe I need to use "map"?
18:13:22 <latro`a> first you need a predicate for "is a hamming number"
18:13:32 <latro`a> then filter
18:13:43 <ben22> uh-huh
18:13:46 <ben22> gonna try that!
18:13:56 <dmwit> I think constructing numbers that you know are hamming numbers is going to be better than constructing arbitrary numbers and then checking if they were hamming numbers post facto.
18:14:07 <latro`a> I think he wants the latter, however
18:14:17 <ben22> yes the latter
18:14:22 <ben22> because this is for an infinite list
18:14:23 <latro`a> that is, wants the hamming numbers in a given list
18:14:31 <ben22> infinite amount of hamming numbers
18:14:37 <latro`a> oh
18:14:41 <latro`a> you just want all the hamming numbers?
18:14:48 <latro`a> for that you can diagonalize
18:14:50 <ben22> yes all of them to infinity
18:14:59 <ben22> I can what?
18:15:19 <sipa> > 2**3
18:15:21 <lambdabot>   8.0
18:15:29 <ben22> I just need this part
18:15:31 <ben22> hamming fac = [ y | y <- [1..], (*filtering goes here*)]
18:15:31 <latro`a> find an enumeration x_n of an infinite 3D array (i,j,k), i=0,... j=0... k=0...
18:15:55 <BMeph> What he fac? ;p
18:15:58 <hiptobecubic> there is a testing library that does that kind of thing
18:16:01 <latro`a> then hamming (i,j,k) = 2^i * 3^j * 5^k
18:16:03 <hiptobecubic> i don't recall the name now
18:16:05 <ben22> nvm fac... that was an accident
18:16:35 <ben22> ok latro`a thanks!!
18:16:37 <hiptobecubic> It's for exhaustively testing possibly input I think, but it handles those kinds of nested infinite sequences cleverly
18:16:42 <hiptobecubic> possible*
18:16:43 <latro`a> the tricky part is figuring out how to enumerate an infinite 3D array, however
18:16:55 <latro`a> you can't just do i <- [1..], j <- [1..], k <- [1..]
18:16:56 <bobajett> \q
18:17:00 <latro`a> as that will not actually get to all of them
18:17:16 <ben22> well for now, latro`a, I just want the finite list factors 100
18:17:18 * BMeph is still not sure why "hamming 100 = [1,2,4,5]"
18:17:33 <ben22> cause 20 has divisor of 10, 20
18:17:38 <ben22> beyond hamming
18:17:48 * BMeph coughs * 25 *
18:17:50 <latro`a> er, what?
18:18:19 <ben22> 25 works... cause it can have 2,3, or 5
18:18:24 <ben22> am I not understanding something?
18:18:53 * BMeph would say, "all week!"...but he's feeling nice today... ;þ
18:18:57 <Xaratas> what means the compiler with: parse error on input `|' ? without the guard the code is ok
18:19:16 <sipa> ben22: so what is the correct output for hamming 100?
18:19:22 <geekosaur> it means you either mis-indented or you used the guard wrong
18:19:40 <ben22> well uhh factors of 100 are [1,2,4,5,10,20,50,100]
18:19:44 <latro`a> actually, what is the convenient way to enumerate a 2D array? all I see how to do is diagonalize the 2D array and then diagonalize that list with another list
18:19:48 <ben22> so the hamming should be [1,2,4,5]
18:19:52 <sipa> ben22: and 25 ?
18:19:55 <latro`a> which is probably undesirable
18:20:23 <ben22> well 25 is not a factor of 100 so that doesn't matter right
18:20:34 <sipa> > 25*4
18:20:35 <latro`a> 25 is a factor of 100...
18:20:36 <lambdabot>   100
18:21:01 <ben22> oh... heh it is
18:21:07 * BMeph whistles through the graveyard...
18:21:27 <latro`a> 100 only has factors of 2 and 5 so the same is true for alll its divisors
18:21:28 <ben22> right!
18:21:32 <latro`a> so alll its divisors are hamming numbers
18:21:35 <latro`a> *all
18:21:38 <ben22> hamming 100 = [1,2,4,5,25]
18:21:47 <latro`a> why not 50 or 100
18:21:53 <latro`a> and why not 10 or 20
18:21:53 <sipa> why not 10? 10=2*5, so it's a hamming number
18:22:07 <ben22> cause 50 the divisor could be like 10 and that's too big!!
18:22:15 <latro`a> wut
18:22:24 <sipa> why is 10 to big?
18:22:24 <ben22> o_O
18:22:28 <sipa> *too
18:22:31 <ben22> cause we can only have 2,3,5
18:22:39 <latro`a> 10 is a hamming number however
18:22:49 <sipa> a hamming number is a number that only has 2, 3 and 5 as prime factors
18:22:52 <latro`a> the only *prime* factors of 10 are 2,3,5
18:22:57 <sipa> 7 is not a hamming number
18:22:57 <latro`a> er
18:22:59 <latro`a> 2,5
18:23:05 <sipa> but 10, as it can be written as 2*5, IS
18:23:05 <ben22> oh is that how you do it?
18:23:13 <latro`a> the factors can be huge, the *prime* factors can only be those three
18:23:24 <sipa> even 50 can be written as 2*5*5
18:23:26 <ben22> oh it has to multiply to get the numba right
18:23:42 <ben22> oh I understood this hamming concept totally wrong
18:23:44 <ben22> sorry
18:23:56 * BMeph facepalms
18:24:13 <ben22> yea yea laugh it up fellahs
18:24:15 <Xaratas> hihi
18:25:09 <Xaratas> in my book the hamming numbers are all numbers which are multiple of 2, 3 or 5, and thereof the ordered set/list
18:25:45 <lambdazerocool> anyone have a moment to help me try to work with MonadError?
18:27:17 <sipa> > [ 2**(i-j) * 3**(j-k) * 5**k | i <- [0..], j <- [0..i], k <- [0..j] ]
18:27:19 <lambdabot>   [1.0,2.0,3.0,5.0,4.0,6.0,10.0,9.0,15.0,25.0,8.0,12.0,20.0,18.0,30.0,50.0,27...
18:27:49 <arkeet> > [ 2^(i-j) * 3^(j-k) * 5^k | i <- [0..], j <- [0..i], k <- [0..j] ]
18:27:51 <lambdabot>   [1,2,3,5,4,6,10,9,15,25,8,12,20,18,30,50,27,45,75,125,16,24,40,36,60,100,54...
18:28:22 <ben22> wow, how did you guys think of that?!
18:28:35 <Xaratas> listcomprehension
18:28:43 <ben22> no like
18:28:45 <ben22> the math and stuff
18:29:05 <Xaratas> it should be one of the first chapters in "lerning haskell", at least for me it was
18:29:27 <ben22> hamming numbers?
18:29:35 <latro`a> as I was saying, the tricky part is getting an enumeration of [0..] x [0..] x [0..]
18:29:36 <Ralith> didn't ben22 get banned?
18:29:50 <latro`a> that one there is pretty nice
18:29:51 <ben22> Ralith, no I talked to elliott and we got along after all
18:29:56 <Ralith> okay
18:30:37 <ben22> Ralith, I can't survive without you guys
18:30:42 <ben22> you people are very helpful
18:31:54 <ben22> arkeet, why cannot you just simply do 2^(i) * 3^(j) * 5^(k)
18:32:01 <ben22> without subtracting the two formers?
18:32:19 <arkeet> ben22:
18:32:27 <arkeet> > [(i,j) | i <- [0..], j <- [0..]]
18:32:28 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(0,11),...
18:32:36 <arkeet> that will never produce, say, (1,0)
18:32:41 <ben22> oh, I see..
18:32:47 <arkeet> > [(i-j,j) | i <- [0..], j <- [0..i]]
18:32:47 <ben22> clever
18:32:48 <parcs> yay nullary type clasess!
18:32:49 <lambdabot>   [(0,0),(1,0),(0,1),(2,0),(1,1),(0,2),(3,0),(2,1),(1,2),(0,3),(4,0),(3,1),(2...
18:32:52 <ben22> very clever
18:33:02 <ben22> I understand
18:33:04 <arkeet> parcs: what for?
18:33:55 <sipa> ben22: this is called 'diagonalization'
18:34:10 <ben22> the subtraction ?
18:34:41 <arkeet> it's just one of many ways to enumerate N x N
18:34:46 <ben22> right so isn't this the same thing as
18:34:46 <parcs> arkeet: for stuff like 'foo :: Deprecated => ...' or 'Unsafe => ...' or 'RiemannHypothesis => ...'
18:34:50 <ben22> [(i,j) | i <- [0..], j <- [0..i]]
18:34:50 <sipa> ben22: as you're walking subsequent diagonal lines in the number square
18:35:11 <arkeet> parcs: I see.
18:35:26 <ben22> sipa, I think I sort of get it
18:35:27 <arkeet> ben22: that'll miss the pairs where j > i
18:36:08 <latro`a> > [(i,j) | i <- [0..], j <- [-i..i]]
18:36:09 <lambdabot>   [(0,0),(1,-1),(1,0),(1,1),(2,-2),(2,-1),(2,0),(2,1),(2,2),(3,-3),(3,-2),(3,...
18:36:24 <ben22> that doesn't look right compared to yours
18:36:26 <ben22> you're right
18:36:27 <latro`a> er, derp, that doesn't make sense
18:36:54 <latro`a> have to move around with a slope, so it can't be {i,j)
18:37:04 <ben22> diagnolization..
18:37:17 <ben22> i remember this from linear algebra mathemtics
18:37:29 <ben22> I never knew it could be implemented such a way
18:37:32 <ben22> thanks!
18:37:46 <Xaratas> the guard problem is really strange
18:37:56 <arkeet> ben22: no, that's unrelated
18:38:02 <ben22> oh
18:38:03 <Xaratas> strange as in "i dont understand it"
18:38:06 <sipa> > [ (i-j,j-k,k) | i <- [0..], j <- [0..i], k <- [0..j] ]
18:38:08 <lambdabot>   [(0,0,0),(1,0,0),(0,1,0),(0,0,1),(2,0,0),(1,1,0),(1,0,1),(0,2,0),(0,1,1),(0...
18:38:18 <sipa> is a diagonalization for 3 dimensions
18:38:19 <ben22> i'll brb i'm going to go eat some fish
18:52:51 <Sgeo> I should write a Reddit bot
18:53:11 <arkeet> you should write a replacement for lambdabot. :p
18:53:24 <Ralith> in idris
18:53:26 <Ralith> :D
18:54:18 <Hermit> Ralith: what's good about idris?
18:54:31 <Ralith> Hermit: the types, of course
18:54:55 <Hermit> you mean the dependent types? I'm not quite sure what they are. Last time I checked I couldn't make much sense of it
18:55:46 <Ralith> I need to get to the store right now, but I encourage you to repeat that question in #idris
18:56:11 <Hermit> I will
18:58:26 <parcs> a simple example of a dependent type is a function that takes an Int, and returns a Bool if the Int is equal to 3, otherwise returns a Char
18:59:16 <parcs> the closest thing to this in haskell is 'Int -> Either Bool Char'
18:59:41 <parcs> but with dependent types you can write (x :: Int) -> (if x == 3 then Bool else Char)
19:00:17 <Hermit> oh, so it's like good old multiple types return values?
19:00:31 <Hermit> like in dynamic typing but statically checked?
19:01:30 <parcs> yes but the "statically checked" part is very important and very powerful
19:02:48 <arkeet> how about a less contrived example? :p
19:03:44 <Hermit> arkeet: remember how you could return anything at all from functions in scripting languages?
19:03:59 <Hermit> (functions don't need to return always the same type on every branch)
19:04:00 <parcs> i don't know of a less contrived example that is still immediately understandable by somebody not familiar with dependent types
19:04:30 <Hermit> yeah, I got it on a glimpse
19:04:42 <dan> hi all.  What is a good method for communicating/synchronizing between a GUI frontend and a logic backend?  I've seen Chans and MVars mentioned.  Any suggestions?  In my case, the frontend is snap with ji, if that matters.
19:05:39 <pdxleif> a : if 1 + 2 == 3 then String else Int; a = "hello"
19:08:01 <tgeeky> pdxleif: so, either "hello" : String (invalid) or "hello" : Int (invalid)
19:09:00 <pdxleif> Yeah, if 1 + 3 does not equal 3, it won't compile (unless you change "hello" to something like 5)
19:09:34 <pdxleif> a : Vect 4 Int; a = [1,2,3,4]
19:09:55 <arkeet> where 4 is the *value* 4, not some type-level number.
19:10:00 <pdxleif> Basically your types are allowed to be aware of the your values.
19:11:31 <Hermit> what? so the vector size goes in the type system? guess that makes bound checks statically checked
19:11:38 <Hermit> pretty nice
19:12:04 <pdxleif> Yup
19:12:09 <parcs> the leap from haskell to dependent type land is about as big as the leap from procedural language to haskell land
19:12:25 <Hermit> parcs: you sure?
19:12:39 <parcs> Hermit: see for yourself
19:12:46 <pdxleif> You can start programming in idris and use it like haskell, for the most part.
19:12:47 <Hermit> so procedural -> dependent types == overkill² ?
19:13:00 <arkeet> so what do you lose?
19:13:07 <Hermit> pdxleif: even if it's eager?
19:13:23 <pdxleif> idris is strict (not lazy), and without the type inference (at the top level).
19:13:33 <pdxleif> Also, you lose all your haskell libs.
19:14:14 <pdxleif> But you get idiom brackets, ad-hoc extendable syntax, GADTs, ...and dependent types.
19:14:35 <Hermit> pdxleif: being strict/eager, how are combinators written? (in case you need to terminate some chain early)
19:15:21 <pdxleif> Dunno, maybe ask in #idris?  You can add annotate certain function args as lazy (by-need), if you want.
19:15:45 <pdxleif> You mean like a boolean thing like "if"?
19:15:53 <Hermit> precisely
19:16:29 <pdxleif> Yeah, for that case, just mark the arguments as lazy - https://github.com/edwinb/Idris-dev/blob/master/lib/Builtins.idr#L84
19:16:39 <arkeet> how different is idris from, say, agda?
19:16:42 <pdxleif> (the | means that param is lazy)
19:18:24 <kinzed> hi
19:18:30 <Hermit> I would have used ' (lisp style), but I guess | is fine too
19:18:37 <pdxleif> Umm, I'm not qualified to answer that... they have some similar stuff... to me, Idris seems more like haskell - it's an environment I can carry on (mostly) the same-ish.  Idris seems more pragmatic - a dependently-typed systems language.  Maybe agda is more academic? - http://stackoverflow.com/questions/9472488/differences-between-agda-and-idris
19:19:01 <pdxleif> Agda generates haskell source code, Idris generates C.
19:20:12 <kinzed> I m a newbie and I have problems understanding why " let rightTriangles' = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24] " gives [(6,8,10)]  while  " let rightTriangles' = [ (a,b,c) | a <- [1..10], b <- [1..a], a <- [1..a], a^2 + b^2 == c^2, a+b+c == 24] " gives []
19:20:14 <pdxleif> I liked idris better cause I didn't have to learn emacs (the repl works great, and it's got a nice vim mode).
19:20:23 <dan> hi all.  What is a good method for communicating/synchronizing between a GUI frontend and a logic backend?  I've seen Chans and MVars mentioned.  STM?  Any suggestions?  In my case, the frontend is snap with ji, if that matters.
19:20:38 <arkeet> kinzed: the last says that both b and c can't exceed a.
19:21:13 <kinzed> err, typo, the last is c <- [1..b]
19:21:22 <arkeet> same problem.
19:21:52 <monochrom> if b=8, c can only try 1-8, not 10
19:22:04 <kinzed> arkeet: how ?
19:22:17 <arkeet> kinzed: c <- [1..b], right?
19:22:21 <arkeet> so c can't exceed b.
19:22:37 <kinzed> yep
19:22:47 <arkeet> so it will never find (a,b,c) = (6,8,10)
19:23:00 <arkeet> > [ (a,b,c) | a <- [1..10], b <- [a..10], c <- [b..10], a^2 + b^2 == c^2, a+b+c == 24]
19:23:02 <lambdabot>   [(6,8,10)]
19:23:30 <Hermit> pdxleif: you mean learn emacs for the repl?
19:23:35 <kinzed> but why [(10,8,6)] is not a solution ?
19:23:43 <kinzed> pardon my ignorance
19:23:44 <arkeet> kinzed: because 10^2 + 8^2 is not 6@
19:23:45 <arkeet> 6^2
19:23:48 <kinzed> 8)
19:24:16 <kinzed> nods
19:25:28 <kinzed> thanks arkeet, that made me feel stupid ;)
19:26:12 <arkeet> nah, sometimes it takes having someone else looking to find a mistake.
19:26:13 <arkeet> :p
19:26:23 <Hermit> so true
19:26:29 <Hermit> happens to me sometimes
19:26:46 <heatsink> Does Idris compile to C code?  The SO page says it does, but the website doesn't say that it does.
19:27:02 <pdxleif> It does
19:27:20 <pdxleif> Also, to JavaScript, or Java.
19:27:39 <pdxleif> Has a nice C FFI, too.
19:27:46 <kvda> Is it possible to apply a where block to multiple function bodies?
19:27:49 <heatsink> Hmm
19:28:03 <monochrom> not really
19:28:05 <heatsink> Is there documentation about the compiler?
19:28:14 <arkeet> kvda: alas, no :(
19:28:32 <hpaste> kvda pasted “where block” at http://hpaste.org/84060
19:28:46 <arkeet> oh
19:28:48 <arkeet> ...yes
19:28:52 <arkeet> not multiple functions, though.
19:29:02 <arkeet> however, the type of qp has to agree everywhere.
19:29:05 <monochrom> if you have a group of guards, where applies to all of them. if you have a group of equations, no
19:29:10 <pdxleif> Umm, maybe ask in #idris - this is all I know of - http://idris-lang.org/documentation
19:29:14 <arkeet> oh, no?
19:29:15 <arkeet> ok
19:29:18 <kvda> ah guards could be the solution
19:29:27 <arkeet> noo
19:29:38 <heatsink> okay
19:29:38 <pdxleif> He just gave a talk on it - it's up on vimeo.  Here's some C generation, if you're curious - https://github.com/edwinb/Idris-dev/blob/master/src/IRTS/CodegenC.hs#L64
19:29:53 <heatsink> Oh thanks
19:29:55 <kvda> What I'm trying to do is to have an optional parameter really
19:30:03 <kvda> or a default setting
19:30:13 <arkeet> :t fromMaybe
19:30:15 <lambdabot> a -> Maybe a -> a
19:30:22 <kvda> Would guards make more sense in this particular example?
19:30:29 <arkeet> fromMaybe 20 would make more sense.
19:30:58 <kvda> I had an implementation with isJust, fromJust
19:31:11 <arkeet> never do that.
19:31:12 <arkeet> ever.
19:31:19 <kvda> hah!
19:31:35 <monochrom> oh, fromMaybe 20 solves it. queryPeople x = qp (fromMaybe 20 x)
19:32:38 <arkeet> > fromMaybe 20 Nothing
19:32:40 <lambdabot>   20
19:32:41 <arkeet> > fromMaybe 20 (Just 3)
19:32:42 <lambdabot>   3
19:33:07 <kvda> agh good stuff
19:33:10 <kvda> *ahh
19:33:39 <kvda> care to enlighten me about the isJust, fromJust?
19:33:53 <arkeet> fromJust is evil, because it's not total.
19:33:56 <latro`a> isJust is alright, fromJust is bad because it's partial
19:33:58 <kvda> thank you monochrom, arkeet :) the fromMaybe solution works
19:34:10 <arkeet> isJust is pointless when you care about the value inside the Just
19:34:23 <kvda> hm
19:34:25 <latro`a> an isJust/fromJust solution is hard to reason about because you have to "nonlocally" check that the fromJust will never act on Nothing
19:34:36 <latro`a> whereas fromMaybe does this check "locally"
19:34:52 <latro`a> as does maybe (little m)
19:35:05 <arkeet> :t maybe
19:35:06 <lambdabot> b -> (a -> b) -> Maybe a -> b
19:35:12 <arkeet> pattern matching is also fine.
19:35:12 <kvda> right that makes sense latro`a
19:35:28 <latro`a> right, anything that does everything in the same place is good
19:35:51 <kvda> funnily enough i'm finding i have to do a lot more tracing back/forward in haskell code
19:36:12 <kvda> but i guess that's more the flow of the types
19:36:58 <latro`a> hm...
19:37:01 <latro`a> :t maybe Nothing
19:37:02 <lambdabot> (a -> Maybe a1) -> Maybe a -> Maybe a1
19:37:17 <latro`a> hi =<<?
19:37:48 <monochrom> the pattern matching is elegant, like natural deduction. the constructors Nothing and Just corresponds to introduction rules. the pattern matching (case ... of Nothing -> ... Just x -> ...) corresponds to an elimination rule. isJust and fromJust do not have a similar elegant story.
19:37:58 <pdxleif> Oh, I remembered another agda <-> idris difference: Agda is full of unicode
19:38:35 <Hermit> pdxleif: you mean like Coq?
19:39:03 <arkeet> latro`a: hehe, yep
19:39:35 <kvda> monochrom, right, thanks for that
19:39:36 <arkeet> :t maybe Nothing id
19:39:37 <lambdabot> Maybe (Maybe a) -> Maybe a
19:42:55 <kvda> In that question that I posted, I'm limiting to a number, how would you make the 'limit' function not run when Nothing is passed?
19:43:28 <kvda> if count … (/)
19:44:10 <monochrom> then I move the pattern-matching or fromMaybe inside the do-block
19:44:25 <arkeet> case x of Just count -> limit count; Nothing -> return ()
19:44:26 <arkeet> perhaps?
19:44:44 <arkeet> if that works.
19:44:55 <arkeet> where x is the Maybe Int64.
19:45:02 <arkeet> Data.Foldable.mapM_ limit x -- heh
19:45:11 <monochrom> queryPeople x = select ... orderBy [...] <insert what arkeet says> return p
19:45:36 <monochrom> @type maybe
19:45:37 <lambdabot> b -> (a -> b) -> Maybe a -> b
19:45:38 <arkeet> :t maybe (return ()) (?limit)
19:45:39 <lambdabot> (?limit::a -> m (), Monad m) => Maybe a -> m ()
19:45:42 <kvda> ahh i see
19:46:04 <kvda> thanks again, this is very helpful :)
19:46:20 <kvda> these little common things still don't come naturally in haskell
19:46:28 <arkeet> :t \n j -> maybe n j ?m
19:46:29 <lambdabot> (?m::Maybe a) => b -> (a -> b) -> b
19:46:40 <pdxleif> Hermit: Like so? ∀ {a ℓ} →
19:46:42 <arkeet> Maybe a ~ forall b. (b -> (a -> b) -> b)
19:46:44 <latro`a> what extension is that called again?
19:46:51 <arkeet> ImplicitParams
19:46:57 <latro`a> ty
19:47:03 <pdxleif> Never seen any Coq (that I recall)
19:47:17 <Hermit> pdxleif: yeah, that kind of stuff
19:47:27 <pdxleif> What was the extension for it to print out the foralls on stuff?
19:47:33 <arkeet> uh
19:47:44 <arkeet> it's not an extension, it's some -f option.
19:47:44 <pdxleif> so :t id would say forall a. a -> a
19:49:07 <tieTYT2> is there a way to set the encoding used for System.IO.readFile and writeFile?
19:49:21 <arkeet> pdxleif: -fprint-explicit-foralls
19:49:33 <arkeet> it's also turned on by -fglasgow-exts
19:50:27 <ParahSailin_> im a little disappointed that lazy io on large streams ended up with horrible memory leaks and i had to go with io-streams
19:50:38 <arkeet> tieTYT2: you'll have to open a handle and use hSetEncoding
19:51:40 <tieTYT2> arkeet: also looks like I can use this: http://hackage.haskell.org/packages/archive/encoding/0.6.2/doc/html/System-IO-Encoding.html
19:51:59 <tieTYT2> what's that ?enc thing?
19:52:01 <arkeet> that won't let you set the encoding.
19:52:13 <arkeet> ?enc is an implicit parameter (see ImplicitParams extension)
19:52:13 <lambdabot> Maybe you meant: ghc rc src wn
19:52:19 <arkeet> oh
19:52:20 <arkeet> ohh.
19:52:26 <arkeet> so you can set it with that.
19:52:37 <tieTYT2> yeah i think so
19:52:46 <arkeet> looks weird.
19:53:09 <arkeet> but should work.
19:53:36 <arkeet> let ?enc = UTF8
19:53:38 <arkeet> and then do your stuff.
19:53:44 <tieTYT2> yeah i'll try it out
19:53:45 <ParahSailin_> weird, implicitparams
19:53:57 <Hermit> ImplicitParams are dynamic scope done right
19:54:02 <arkeet> are they done right?
19:54:05 <ezyang> Uh
19:54:13 <Hermit> I guess better than in most languages
19:54:18 <ezyang> We used to make fun of John Launchbury for putting implicit params in Haskell ^^"
19:54:30 <arkeet> haha
19:54:44 <arkeet> I use them all the time for holes, but never in actual code.
19:55:01 <Hermit> I still enjoy dynamic scope
19:55:22 <Hermit> the problem is when it's abused
19:56:44 <tieTYT2> my understanding of this is it lets you define a variable outside the function that gets used inside, without directly passing it in?
19:56:56 <Hermit> yep, that's it, no big deal
19:57:05 <tieTYT2> what is the benefit of this?
19:58:21 <Hermit> for example, if you have many functions that take an implicit handle, just altering a variable you can get them all to output to a certain location. And so, if you call a monadic chain of such functions, you don't need to pass explicit argumens or use the reader monad
19:58:25 <Hermit> simple as that
19:59:06 <Hermit> that's dynamic scope for ya ;-)
19:59:16 <tieTYT2> i see
19:59:31 <tieTYT2> so you set it once and then that value is used from every call after that
19:59:42 <Hermit> as long as it's in scope, yes
19:59:53 <tieTYT2> ok thanks
20:00:20 <arbn> Is that clearer or easier to type than using Reader or ReaderT, for that purpose?
20:01:02 <Hermit> IMHO yes. More convenient at the very least
20:12:39 <tieTYT2> ugh
20:12:41 <tieTYT2> ok i'm a newb
20:12:47 <tieTYT2> http://hackage.haskell.org/packages/archive/encoding/0.6.2/doc/html/System-IO-Encoding.html
20:12:52 <tieTYT2> is this something i need to cabal install?
20:13:06 <tieTYT2> if I find it on hackage, does that usually mean "yes"?
20:13:28 <kamatsu> yes
20:13:33 <kamatsu> cabal install encoding
20:13:38 <tieTYT2> ok thanks
20:13:41 <kamatsu> if you installed the haskell platform
20:13:44 <kamatsu> you may already have it
20:13:46 <Clint> tieTYT2: ghc-pkg list should tell you what you have installed already
20:13:50 <tieTYT2> i did, but I don't have it
20:13:59 <kamatsu> but if so, cabal-install will just say so
20:14:32 <tieTYT2> ok, this is pretty big
20:18:58 <tieTYT2> i got this error installing: http://hpaste.org/84061
20:19:05 <tieTYT2> i don't know what to do with this.  I'm on windows 7
20:33:39 <nejucomo> Is there an attoparsec parser for URIs or HTTP request / response?
20:35:05 <kamatsu> tieTYT2: it's looking for C header files
20:35:24 <kamatsu> i'm not sure if they're available on windows, but you'll probably need a C environment set up
20:35:59 <kamatsu> in general, i find I don't get these difficulties if I stick to *nix operating systems, so if that's an option perhaps you should pursue that.
20:36:40 <kamatsu> if it's not an option, I can't help you much, I don't use windows and I never have.
20:36:56 <sproingie> tieTYT2: do you have the haskell platform installed?
20:37:39 <tieTYT2> sproingie: i'm pretty sure I do
20:37:51 <tieTYT2> that's the most convenient way to use haskell isn't it?  I have winghci
20:38:02 <tieTYT2> how can I confirm that I have it?
20:38:16 <sproingie> you installed something called "The Haskell Platform"?
20:38:25 <sproingie> as opposed to just ghci
20:38:32 <tieTYT2> yep
20:38:58 <tieTYT2> from some googling, it seems I need to install cygwin and then use that config option to look at cygwin's header files
20:39:01 <sproingie> that should have come with a mingw environment
20:39:30 <sproingie> one that ghc is configured to look at by default
20:39:42 <arkeet> but you'll still need to install the C library.
20:40:04 <sproingie> maybe system_encoding.h is some linux-ism assumption.  it doesn't look very posix
20:40:08 <tieTYT2> i got it to work!
20:40:16 <tieTYT2> cabal install encoding --extra-include-dirs='C:\cygwin\usr\include'
20:40:28 <tieTYT2> at least it says it's registered
20:40:32 <tieTYT2> i'm going to create a SO post about this
20:40:37 <sproingie> if it compiles, that'll do it
20:40:44 <sproingie> did it require an extra cygwin package?
20:41:08 <tieTYT2> define extra.  It comes with cygwin
20:41:22 <sproingie> hm.  haskell platform comes with mingw
20:42:07 <arkeet> hm, there isn't an external C library dependency.
20:42:20 <arkeet> system_encoding.{c,h} come in the package.
20:42:35 <tieTYT2> sproingie: how do I use it correctly?  I typed cabal install in cygwin
20:42:43 <tieTYT2> do i need to do all cabal installs in mingw instead?
20:43:19 <sproingie> should work in whatever, cabal is a windows exe that shouldn't inherit any cygwinisms
20:43:46 <arkeet> should work in a mingw shell too.
20:43:58 <arkeet> that's what I do, anyway.
20:44:03 <sproingie> i run mine from powershell, works fine
20:44:14 <tieTYT2> have you ever installed encoding?
20:44:21 <tieTYT2> maybe you'd get the same error as me
20:44:41 <sproingie> not sure my windows haskell install is working.  guess i can try
20:44:55 <arkeet> I could try.
20:45:16 <arkeet> all these dependencies
20:45:16 <sproingie> boy it's got some odd deps
20:45:51 <sproingie> tons and tons of warnings
20:46:10 <tieTYT2> sproingie: yep
20:46:22 <arkeet> not to menion implicitparams
20:46:22 <nejucomo> I guess I'll embed Network.URI.parseURI into my attoparsec parser for now.
20:46:23 <arkeet> :p
20:46:44 <arkeet> tieTYT2: I do simply suggest opening a handle and using hSetEncoding on it
20:47:25 <arkeet> :t hSetEncoding
20:47:26 <lambdabot> Not in scope: `hSetEncoding'
20:47:28 <arkeet> aw
20:47:39 <sproingie> lambdabot doesn't have a lot of io
20:48:02 <tieTYT2> arkeet: but writeFile is so convenient (when you don't have to install a package with a cryptic error)
20:48:16 <sproingie> ok after muuuuch warning spam, i get the same error
20:48:32 <sproingie> i think the package is just written portably
20:48:38 <sproingie> er just NOT written portably
20:49:12 <tieTYT2> ah, good to know this will be a rare experience
20:49:30 <arkeet> tieTYT2: you could even write a wrapper for that
20:50:25 <arkeet> writeFileWithEncoding enc f x = withFile f WriteMode $ \h -> hSetEncoding h enc >> hPutStr h x
20:51:03 <tieTYT2> hrmmm
20:51:07 <tieTYT2> ok that's easier than I thought
20:51:23 <tieTYT2> when I learned writeFile existed, I wanted to avoid handles whenever possible
20:51:27 <arkeet> writeFile is defined somewhat like this.
20:51:36 <arkeet> writeFile f txt = withFile f WriteMode (\ hdl -> hPutStr hdl txt)
20:52:13 <tieTYT2> i see
20:52:40 <sproingie> it's still good to use high level wrappers
20:53:51 <tieTYT2> http://stackoverflow.com/questions/15424390/in-haskell-how-do-i-install-the-encoding-package-on-windows/15424391#15424391
20:54:07 <tieTYT2> maybe that'll help others
20:58:29 <tieTYT2> aw crap: Loading package encoding-0.6.7.2 ... linking ... ghc: unable to load package `encoding-0.6.7.2'
20:58:51 <sproingie> yah i'd say it's broken on windows
20:58:56 <tieTYT2> wtf
20:59:10 <sproingie> ghc makes a heroic effort to work on windows ... third party packages not so much
20:59:30 <tieTYT2> this is the first time I've stepped outside a book exercise, it's giving me a pretty bad impression
21:00:11 <sproingie> there's still lots of annoyances on windows
21:06:51 <tieTYT2> i figure I should remove encoding since it doesn't work
21:07:01 <tieTYT2> ghc-pkg.exe: cannot find package encoding
21:07:08 <tieTYT2> what am I doing wrong?
21:07:39 <Hermit> you are using windows, that's what you are doing wrong
21:07:46 <Hermit> :-P
21:08:32 <tieTYT2> good one
21:09:05 <latro`a> I tihnk he was serious
21:09:07 <latro`a> *think
21:09:10 <latro`a> or semi-serious
21:09:18 <Hermit> learn using ghc on GNU/Linux, which is fully supported. Then, when you become more experienced, you'll be able to figure out how to run it ok in windows
21:09:31 <latro`a> dependency issues are a pain in the ass on windows
21:09:48 <Hermit> but starting trying to set everything up with windows is... a bit overkill
21:11:50 <fryguybob> tieTYT2: Did you try  cabal install encoding -f-systemencoding ?
21:12:22 <nejucomo> Is there a concise standard implementation of: (t -> Bool) -> (t -> Bool) -> t -> Bool  -combining the results with (&&) or (||) ?
21:12:23 <tgeeky> i had a ton of success in Windows.
21:12:47 <tgeeky> all the problems I ever faced which weren't easily surmountable in windows had to do with external dependencies (on C, sometimes)
21:12:48 <nejucomo> I've tried the All and Any monoids, but it ends up longer than a straight forward lambda.
21:13:01 <ion> @type liftA2 (||) `asAppliedTo` (undefined :: a -> Bool)
21:13:03 <lambdabot> (a -> Bool) -> (a -> Bool) -> a -> Bool
21:13:38 <tieTYT2> fryguybob: nope
21:14:18 <nejucomo> ion: Thanks.
21:14:26 <nejucomo> Is that Applicative?
21:14:32 <fryguybob> tieTYT2: Well that worked for me on Windows.
21:14:41 <ion> nejucomo: The Applicative instance of ((->) r), yeah.
21:14:43 <tieTYT2> fryguybob: i'm trying it, thanks
21:14:45 <nejucomo> :t liftA2
21:14:46 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
21:15:01 <nejucomo> Nice.
21:15:12 <ion> nejucomo: http://heh.fi/haskell/functors/#function-instance
21:15:57 <fryguybob> tieTYT2: It isn't too unusually for there to be some flags in the cabal file that make it easier to compile in the face of missing libraries, so if I'm having a problem I poke around the cabal file to see what the options are.
21:16:33 <tieTYT2> fryguybob: that gave me this error when I tried to use it: Loading package transformers-0.3.0.0 ... linking ... ghc: unable to load package `transformers-0.3.0.0'
21:16:58 <tieTYT2> not sure why it's trying to use that
21:17:58 <tieTYT2> does that just mean I need to install that package?
21:18:54 <tieTYT2> cabal says I've already got that though
21:18:55 <fryguybob> tieTYT2: Not sure why that would be.  ghc-pkg check might give some hints.
21:20:43 <tieTYT2> aw man
21:21:49 <tieTYT2> fryguybob: I restarted ghci and it worked!
21:22:10 <tieTYT2> thanks a lot
21:22:56 <jhickner> Is there a data structure besides IxSet that can give you multiple indexes?
21:24:35 <jhickner> I have a list of items that look like (Address, TranslatedId Int, ActualId Int) and I want to be able to look them up quickly using either Int as a key
21:26:00 <Pseudonym> jhickner: Why not insert the items into two Data.Maps?
21:26:06 <Pseudonym> The instances of the values will be shared.
21:27:06 <jhickner> it would be nice to avoid that extra bookkeeping if possible, but that would work
21:27:18 <Pseudonym> Well, it complicates update, obviously.
21:28:06 <jhickner> using an IxSet I can make in index on both Ints, but there's a lot of setup, and it requires DeriveDataTypeable
21:28:34 <Pseudonym> The other obvious option is to add a level of indirection, which is the solution to pretty much every software engineering problem.
21:28:44 <Cale> jhickner: The extra bookkeeping is exactly what IxSet does, iirc.
21:29:02 <Pseudonym> Yeah.
21:29:14 <tieTYT2> fryguybob: do I have to restart winghci after I install a pacakge or is there a way to get it to reload its dependencies?
21:29:45 <Pseudonym> The best option, BTW, is write a library which does exactly what you want hiding all the bookkeeping and/or indirection, and then reuse it.
21:29:51 <jhickner> :)
21:29:55 <Pseudonym> For added points, release it.
21:29:57 <fryguybob> tieTYT2: I don't know.  I would expect that you would need to.  I just use normal ghci in PowerShell when I'm on windows.
21:30:11 <jhickner> agreed, just checking it doesn't already exist
21:40:41 <tieTYT2> k
21:47:25 <zeta-> I'm trying to install the platform with ./configure --prefix= --with-ghc= --with-ghc-pkg= but when make gets to OpenGL, I get "WARNING: unrecognized options: --with-hc-pkg, --with-gcc" NB missing 'g'
21:47:48 <Jonno_FTW> is there a more efficient way to test if a list is a subset of another? isSubset a b = all (\x->x `elem` b) a
21:48:20 <Pseudonym> The most efficient algorithm depends on a and b.
21:48:35 <Pseudonym> If a is a single-element list, you can't do better than that.
21:48:59 <Jonno_FTW> a might have up to k elements, b will have at most k elements
21:49:13 <Pseudonym> Sort and merge?
21:49:30 <Pseudonym> Even better if you can maintain the lists in sorted order.
21:52:41 <Guest74670> Jonno_FTW: isSubset a b = not $ any (`notElem` b) a
21:52:49 <Guest74670> would be a micro-opt
21:53:24 <Guest74670> maybe
21:54:02 <otters> how do I create a fromJSON instance that reads a key from a nested object?
21:54:13 <otters> like, an object that is one of the valus of the top-level object
21:55:08 <ParahSailin_> do {gi <- decimal; char '\t'; txid <- decimal; endOfLine; return (gi, txid)} -- this parser seems to be big cpu bottleneck
21:56:41 <ParahSailin_> is decimal really that bad of a parser?
21:57:31 <Hermit> have you found that profiling?
21:57:42 <Hermit> or you *think* that's the bottleneck?
21:58:38 <otters> alternatively, can anybody recommend a good DSL for querying a Data.Aeson.Value that contains nested objects?
21:59:31 <ParahSailin_> Hermit: yes, i did profile
22:00:17 <arkeet> otters: lens? :v
22:00:18 <hpaste> ParahSailin pasted “profile” at http://hpaste.org/84072
22:00:43 <otters> arkeet: is there any lens stuff for aeson?
22:00:52 <arkeet> there's aeson-lens, and aeson-traversal
22:00:58 <arkeet> statusfailed: how usable is aeson-traversal?
22:01:03 <otters> oh there is aeson-lens
22:01:14 <ParahSailin_> Hermit: see above
22:01:15 <hammersbang> Do I need to know operating systems concepts in order to build and maintain huge databases with very large data sets?
22:01:22 <arkeet> aeson-lens is a bit odd because it doesn't quite satisfy the lens laws
22:01:22 <Hermit> ParahSailin_: reading
22:01:26 <arkeet> or traversal
22:02:37 <Hermit> ParahSailin_: so I guess this loadgitax is what you just pasted
22:03:10 <Hermit> or gitaxline
22:03:28 <ParahSailin_> Hermit: gitaxline is that one i pasted above, correct
22:05:41 <ParahSailin_> im not sure how to further profile that function, but it seems like decimal parser is the only one that should be very computational
22:06:30 <Hermit> ParahSailin_: this is strange, gitaxline entries value is 0 on that 50% cpu line
22:06:37 <sw2wolf> @src deciaml
22:06:37 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
22:06:50 <sw2wolf> @src decimal
22:06:50 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
22:07:20 <sw2wolf> @hoogle decimal
22:07:21 <lambdabot> Data.Char DecimalNumber :: GeneralCategory
22:07:21 <lambdabot> package Decimal
22:07:21 <lambdabot> Text.Parsec.Token decimal :: GenTokenParser s u m -> ParsecT s u m Integer
22:07:48 <ParahSailin_> decimal = B8.foldl' step 0 `fmap` I.takeWhile1 isDig where {isDig w  = w >= 48 && w <= 57; step a w = a * 10 + fromIntegral (w - 48)}
22:08:52 <Hermit> probably silly question, is it checking for eof?
22:09:22 <sw2wolf> @let decimal = B8.foldl' step 0 `fmap` I.takeWhile1 isDig where
22:09:23 <lambdabot>  <local>:7:11:
22:09:23 <lambdabot>      Not in scope: B8.foldl'
22:09:23 <lambdabot>      Perhaps you meant one of the...
22:09:23 <sw2wolf> 			   {isDig w  = w >= 48 && w <= 57; step a w = a * 10 +
22:09:24 <sw2wolf> 			   fromIntegral (w - 48)}
22:11:07 <hpaste> ParahSailin pasted “more functions” at http://hpaste.org/84074
22:11:30 <ParahSailin_> there's no checking for eof anywhere
22:11:58 <ParahSailin_> (and im using io-streams because it cured the memory leak of doing it just with regular lazy lists)
22:12:31 <Hermit> @ty optional
22:12:32 <lambdabot> Alternative f => f a -> f (Maybe a)
22:13:39 <Hermit> got to admit it, I'm at a loss of words. No idea why it's being so heavy yet
22:14:06 <ParahSailin_> Hermit: oh, that makes sense that there's but a synonym for what i wrote already :)
22:14:13 <ParahSailin_> s/but//
22:14:44 <Hermit> yeah, it's a common idiom
22:15:40 <ParahSailin_> i think decimal is just a slow function when you have to run it 6e8 times
22:16:26 <ParahSailin_> and i somehow doubt that making a ffi version would help
22:16:41 <Hermit> now that I notice it, it's not even listed in the strace. Are you sure you built attoparsec for profiling too?
22:16:56 <Hermit> s/strace/profiling
22:16:58 <ParahSailin_> Hermit: pretty sure i did, how would i check
22:17:32 <ParahSailin_> i went through entire ordeal of putting library-profiling in cabal conf and rebuilding everything a while back
22:18:16 <Hermit> ParahSailin_: did you try with --enable-library-profiling ?
22:18:21 <Hermit> oh
22:18:34 <Hermit> =|
22:19:53 <Hermit> ParahSailin_: did you also put -auto-all?
22:20:28 <ParahSailin_> Hermit: -main-is Taxonomy -prof -auto-all -caf-all -fforce-recomp
22:21:39 <ParahSailin_> i wonder if i should try with llvm backend
22:22:21 * Hermit never tried it
22:23:57 <Hermit> sorry ParahSailin_, wish I could help but it seems I'd be biting more than I can chew at the moment. Still, I'd like to know what was it once you have it figured out
22:25:05 * Hermit needs to become more skilled
22:26:41 <ParahSailin_> thanks for talking me through
22:31:27 <otters> so (^.) is infix view
22:31:29 <otters> is there an infix use
22:35:31 <hpaste> otters pasted “missing something obvious, part 1” at http://hpaste.org/84075
22:35:44 <otters> surely there is a shorter way of writing someAccessor
22:37:38 <arkeet> otterdam: someAccessor = view someLens
22:37:41 <arkeet> otters  *
22:37:44 <arkeet> :t view
22:37:45 <lambdabot> MonadReader s m => Getting a s t a b -> m a
22:39:43 <dmj> Does anyone know the status of developing iphone apps with haskell? Is it worth the effort or should I just go with Obj-C?
22:40:37 <ParahSailin_> how do i dump cmm or asm in ghc
22:41:02 <arkeet> -ddump-cmm or -ddump-asm
22:41:17 <arkeet> http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/options-debugging.html
22:41:35 <ParahSailin_> where exactly do i put that, because i dont see any extra output
22:41:48 <ParahSailin_> ghc gitx.hs -O2 --make -main-is Taxonomy -ddump-cmm
22:41:58 <ParahSailin_> im on that exact page
22:42:48 <NemesisD> anyone know if there's a there's a pattern, preferably with lenses, to look up an item in a list based on some predicate and then update it in place, returning the updated list
22:43:26 <arkeet> NemesisD: example?
22:43:48 <Heffalump> what does it do if there are 0 or >=2 matches?
22:43:53 <NemesisD> looking through lens, its got an "At" class but thats for using an index into a map-like contianer
22:44:00 <NemesisD> Heffalump: stops at the first
22:44:55 <NemesisD> example: update :: (Item -> Item) -> [Item] -> [Item]
22:45:01 <Heffalump> and with 0 matches?
22:45:11 <arkeet> NemesisD: that looks like map
22:45:15 <NemesisD> Heffalump: its a noop, returns an unmodified item
22:45:46 <Hermit> NemesisD: the type signature you just pasted is that of map
22:46:02 <Hermit> NemesisD: how is update supposed to find the right item to update?
22:46:36 <Hermit> by eq? with a function? by position?
22:48:05 <Hermit> > map (\c -> if c == 'c' then 'C' else c) "abcde"
22:48:06 <lambdabot>   "abCde"
22:49:07 <NemesisD> i was trying to abstract my actual problem case. the actual function i'm working on is more along the lines of: Request -> [(RequestMatcher, Response)] -> [(Maybe Response, [(RequestMatcher, Response)]
22:49:53 <NemesisD> so it would find the first matcher that matches the request, potentially update that entry in the list and return the match, Maybe
22:50:40 <arkeet> I can't parse that type.
22:50:46 <NemesisD> i can probably figure out how to do this with recursion, it just felt like something lens or maybe a zipper-like pattern could handle. better i learn a useful new tool than do it the naive way
22:51:19 <Hermit> NemesisD: your type signature is broken
22:52:14 <NemesisD> Request -> [(RequestMatcher, Response)] -> (Maybe Response, [(RequestMatcher, Response)])
22:52:48 <Hermit> why do you want to return the [(RequestMatcher, Response)] again? is it the same as the second parameter?
22:52:54 <arkeet> :t lookup
22:52:56 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
22:53:06 <arkeet> ...not quite
22:53:10 <Hermit> arkeet: he probably wants find
22:53:12 <Hermit> :t find
22:53:13 <arkeet> :t find
22:53:13 <lambdabot> (a -> Bool) -> [a] -> Maybe a
22:53:14 <NemesisD> Hermit: it is potentially modified
22:53:14 <lambdabot> (a -> Bool) -> [a] -> Maybe a
22:53:16 <Heffalump> if you want something point-free, something like (uncurry (++) . (id *** f) . break predicate)
22:53:27 <arkeet> :X
22:53:29 <Hermit> NemesisD: how so? the matched clause is removed?
22:53:50 <Heffalump> where f should leave an empty list alone, and apply your transformation to the first element of a non-empty list
22:54:21 <NemesisD> Hermit: i'm writing an HTTP mocking library, Response is an ADT, one of the constructors is a sequence of canned responses
22:54:53 <NemesisD> so my function will look up the canned response and in that case, it will remove the head off of that sequence down to the last one
22:55:05 <NemesisD> i'm using a type for that sequence that is guaranteed non-empty
22:55:56 <Heffalump> I don't understand lens from a very quick glance, but I guess something like At 0 might help with implementing f.
22:56:44 <NemesisD> yeah i've used At on some other projects, i'll keep searching. At doesn't exactly work because i'm not really looking up by an index. i'm basically doing a linear search until a RequestMatcher matches the given Request
22:57:04 <NemesisD> btw RequestMatcher is a newtype over Request -> Bool
22:57:07 <Heffalump> NemesisD: the rest of what I said handles the linear search
22:57:26 <Heffalump> At 0 is just to apply the transformation at the head of the list after using break
22:57:56 <NemesisD> hmm is the *** an arrow? haven't seen that before
22:58:05 <arkeet> no, it's a function
22:58:18 <Heffalump> it's an arrow-based function, but the arrow can be (->)
22:58:19 <arkeet> (***) :: (a -> b) -> (c -> d) -> (a,c) -> (b,d)
22:58:23 <Heffalump> it's a convenient way of working on tuples
22:58:34 <NemesisD> ah ok. i haven't really dove very deep into arrows
22:58:56 <sw2wolf> @type (***)
22:58:57 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
22:59:00 <Heffalump> in my code above, replace f with onHead update, where onHead _ [] = [] ; onHead f (x:xs) = f x:xs
22:59:21 <Heffalump> so then the only question is how to implement onHead in a more elegant/point-free way
22:59:21 <arkeet> :t over _head
22:59:23 <lambdabot> Cons (->) Mutator t t b b => (b -> b) -> t -> t
22:59:31 <arkeet> > over _head (+1) [3,4,5]
22:59:33 <lambdabot>   [4,4,5]
22:59:53 <Nisstyre> arkeet: are you familiar with Forth?
22:59:57 <arkeet> no
23:00:12 <Nisstyre> oh, well over is something from Forth
23:00:30 <arkeet> over is a lot of things
23:00:37 <Heffalump> @type \predicate update -> uncurry (++) . (id *** over _head) . break
23:00:39 <lambdabot>     Couldn't match expected type `(t0 -> t0, b0 -> b0)'
23:00:39 <lambdabot>                 with actual type `[a0] -> ([a0], [a0])'
23:00:39 <lambdabot>     Expected type: (a0 -> Bool) -> (t0 -> t0, b0 -> b0)
23:00:56 <Nisstyre> :t over
23:00:57 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
23:01:14 <Heffalump> @type \predicate update -> uncurry (++) . (id *** over _head update) . break predicate
23:01:15 <lambdabot> (a -> Bool) -> (a -> a) -> [a] -> [a]
23:01:40 <arkeet> how about
23:01:45 <Heffalump> NemesisD: hmm, did you want predicate/update to be specified by a single Maybe-returning function?
23:01:46 <arkeet> do it in a more lensy way.
23:01:46 <NemesisD> the types in lens are pretty brutal for newbies like me
23:02:08 * Heffalump is also scared of lens :-)
23:02:31 * sw2wolf is also scared of lens 
23:02:31 <Heffalump> and why there is something called _head is a bit odd, I thought variables beginning _ were for ignoring
23:02:47 <NemesisD> Heffalump: the predicate can actually be internal to the function, i'm not designing this to be very geneeral, really under the newtype you're just passing the first Request argument into the RequestMatcher, as newtype RequestMatcher = RequestMatcher (Request -> Bool)
23:02:51 <arkeet> @type \p u -> over (traverse . filtered p . taking 1) u
23:02:53 <lambdabot>     Couldn't match expected type `Mutator b0'
23:02:53 <lambdabot>                 with actual type `s0
23:02:53 <lambdabot>                                   -> Control.Lens.Internal.Bazaar.BazaarT p0 f0 a0 a0 t0'
23:03:16 <arkeet> @type \p u -> over (taking 1 (filtered p traverse)) u
23:03:17 <lambdabot>     Couldn't match expected type `b0
23:03:17 <lambdabot>                                   -> Control.Lens.Internal.Bazaar.BazaarT (->) Mutator b0 b0 b0'
23:03:17 <lambdabot>                 with actual type `Control.Lens.Internal.Bazaar.BazaarT
23:03:24 * arkeet reads the types
23:03:49 <arkeet> @type \p u -> over (taking 1 (traverse . filtered p)) u
23:03:50 <lambdabot> Traversable t => (b -> Bool) -> (b -> b) -> t b -> t b
23:03:56 <NemesisD> lens has been a huge win for me in the simpler cases for me and a "wtf. go ask edkmett" in the other cases
23:04:13 <arkeet> note: this is an unlawful use of filtered
23:04:23 <arkeet> unless the update preserves the predicate
23:04:41 <arkeet> wait
23:04:52 <arkeet> (\predicate update -> uncurry (++) . (id *** over _head update) . break predicate) even (+2) [1..5]
23:04:56 <arkeet> > (\predicate update -> uncurry (++) . (id *** over _head update) . break predicate) even (+2) [1..5]
23:04:58 <lambdabot>   [1,4,3,4,5]
23:05:04 <arkeet> yeah ok
23:05:12 <arkeet> > (\p u -> over (taking 1 (traverse . filtered p)) u) even (+2) [1..5]
23:05:15 <lambdabot>   [1,4,3,4,5]
23:06:10 <arkeet> hmm, how come taking isn't something we compse like filtered?
23:06:21 <NemesisD> hmm
23:07:20 <hpaste> Hermit pasted “request matcher  -- NemesisD” at http://hpaste.org/84076
23:08:15 <Sgeo> Would arrowized STM be more efficient, since you could presumably know which things are being accessed up-front?
23:08:16 <arkeet> right, we want the thing that matched.
23:08:53 <Sgeo> So you wouldn't actually need to "retry", just see what it wants and pause if something else is running that is using the things that you'll request
23:08:53 <NemesisD> hmm oh yeah i forgot about break
23:09:13 <arkeet> hmm
23:09:15 <arkeet> oh perfect
23:09:25 <arkeet> edwardk: do we have something like <%~ that returns some function applied to the result?
23:09:39 <edwardk> :t (<%~)
23:09:41 <lambdabot> Profunctor p => Overloading p q ((,) b) s t a b -> p a b -> q s (b, t)
23:09:46 <edwardk> :t (%%~)
23:09:47 <lambdabot> Overloading p q f s t a b -> p a (f b) -> q s (f t)
23:09:52 <lispy> Sgeo: my hypothesis is that we can't know without trying it?
23:09:58 * Hermit sees that signature and runs away
23:10:18 <Nisstyre> I see "f s t a b" and think of mounting drives
23:10:26 * lispy agrees
23:10:34 <arkeet> edwardk: use case: modify the targets of a traversal, which contains values which aren't in some monoid
23:10:35 <edwardk> :t both %%~ \x -> let y = 1 + y in (2 * y, y)
23:10:37 <lambdabot> (Num b, Num t, Monoid t) => (a, a) -> (t, (b, b))
23:10:45 <arkeet> hmm
23:11:03 <edwardk> which is of course just both $ \x -> ...
23:11:11 <arkeet> :p
23:13:18 <otters> :t (%%~)
23:13:20 <lambdabot> Overloading p q f s t a b -> p a (f b) -> q s (f t)
23:13:29 <otters> ^ is why I can't learn lens myself
23:13:39 <edwardk> otters: (%%~) = id
23:13:41 <arkeet> (%%~) = id
23:13:41 <arkeet> haha
23:13:57 <arkeet> > (\p u -> (taking 1 (traverse . filtered p)) (\x -> ([x],u x))) even (+2) [1..5]
23:13:59 <lambdabot>   ([2],[1,4,3,4,5])
23:14:02 <otters> a definition of id with seven type variables
23:14:08 <edwardk> (p a (f b) -> q s (f t)) -> p a (f b) -> q s (f t)
23:14:23 <edwardk> otters: yep.
23:14:32 <NemesisD> it kind of hard. im not sold on the haskell idiom of single-letter type variables. they use different letters that obviously have some sort of significance, why not something closer to english
23:14:33 <otters> I have only good things to say about lens
23:14:35 <edwardk> it is provided for consistency, not need
23:15:08 <arkeet> edwardk: ok, say I wanted to take the msum of the results.
23:15:13 <arkeet> after being modified by my function.
23:15:21 <edwardk> NemesisD: i'll say this the type variables there are not what i care about most of the time. so making the incidental crap take up more of my screen just makes it harder for me to think about the parts that matter
23:15:45 <arkeet> as opposed to them being combined in a monoid.
23:16:02 <lispy> NemesisD: I find that what actually matters with type variables is their relationship, which is exspressed by their position in the type signature. For this reason, I find short identifiers nicer because I can mentally diff them more easily.
23:16:17 <edwardk> NemesisD: i once told zed shaw that i feel that making SuperVerboseTypeVariableNames focuses on the wrong part of the type signature. i care about the concrete parts, the type variables are just placeholders. i want them to be near invisible but distinguishable.
23:16:18 <arkeet> or
23:16:20 <NemesisD> edwardk: fair, its just much harder on discoverability of the API for outsiders. usually i start out on the github wiki and then get dropped into a world of pain if i end up having to go to the haddock
23:16:55 <lispy> edwardk: well, and you want to reconstruct the graph in your brain. Perhaps we need type graphs?
23:17:16 <edwardk> given m a -> (a -> m b) -> m b    turned into "someMonad theVariable -> (theVariable -> someMonad anotherVariable) -> someMonad anotherVariable"  -- i get lost
23:17:17 <lispy> (and it's probably simpler than a full graph, dag?)
23:17:21 <edwardk> my brain can't chunk the latter
23:17:51 <edwardk> linguistic chunking is a _huge_ factor in the readability of haskell types to me
23:18:02 <lispy> edwardk++ -- for telling zed shaw what for
23:18:36 <NemesisD> edwardk: i think in those cases, a is fine, m is ok, but like earlier when i leaarned that one of lens' functions, t meant target. i had no idea until i was told that
23:19:09 <arkeet> t is the thing that gets stabbed.
23:19:21 <arkeet> by s.
23:19:26 <NemesisD> lol
23:19:48 <trolling> t is to be drunk
23:20:01 <trolling> with biscuits, and casual racism
23:20:20 <edwardk> NemesisD: honestly? t is the next character after 's'
23:20:22 <NemesisD> wat
23:20:25 <edwardk> that was the original meaning
23:20:41 <edwardk> the way i finally summarized for zed shaw: http://www.youtube.com/watch?v=sDW6vkuqGLg&t=1m14s
23:21:21 <NemesisD> edwardk: http://24.media.tumblr.com/tumblr_lxviinIM491qbuuz3o1_400.gif
23:21:25 <edwardk> s is for state, a and b are chosen so they line up with the a and b in (a -> f b)
23:21:37 <edwardk> NemesisD: =)
23:22:07 <edwardk> i originally used 'a b c d'
23:22:09 <ab9rf> edwardk: i agree with you on the type variables
23:23:01 <edwardk> then shachaf made a case that they were too similar and that to read the type signature for traverse as a traversal you had to alpha rename c and d to a and b and simultaneously substitute the old a and b to (t a) (and (t b)
23:23:25 <edwardk> so we golfed around choices until i told him i'd be willing to switch to 's t a b' if he did the patch
23:23:32 <edwardk> several thousands of lines of patch later, it was done
23:23:41 <edwardk> s t a b was chosen so that when you use
23:23:47 <edwardk> :t (.=)
23:23:49 <lambdabot> MonadState s m => ASetter s s a b -> b -> m ()
23:23:54 <edwardk> s is the state
23:24:00 <edwardk> :t (%=)
23:24:01 <lambdabot> (MonadState s m, Profunctor p) => Setting p s s a b -> p a b -> m ()
23:24:02 <Sgeo> Someone should make a thing similar to operational for arrows. It would give you a list of all things the invocation uses, not just the interpretation stuff
23:24:21 <Sgeo> That's what arrows provide, right? Before executing the "effects", you get a static list of all the arrows that run?
23:24:28 <Sgeo> Assuming app is not used, of course
23:24:42 <edwardk> 'source and target' as a convenient mnemonic was secondary
23:24:52 <edwardk> but a happy coincidence
23:26:00 <edwardk> sgeo: i have lots of arrows that can do lots of recursive effects. what you described doesn't model things like automaton arrows, etc.
23:26:24 <edwardk> i can't always see all the arrow parts
23:27:15 <Sgeo> There was an arrow tutorial someone was working on, what happened to it?
23:27:45 <edwardk> http://revision3.com/melodysheep/bruce-lee is the version i actually used in that discussion ;)
23:28:49 <Sgeo> Why is arr mandatory?
23:29:05 <Sgeo> It makes it impossible to write arrows that are supposed to just translate to functions in other languages, I think
23:29:21 <edwardk> arrows are generally a bad point in the design space
23:29:47 <Sgeo> ?
23:29:50 <edwardk> they have a few uses over and above applicatives, but for the most part when you go to reach for an arrow ask if you can't get there with an applicative
23:30:21 <Sgeo> Arrows have nice syntax sugar. I think applicatives should get some syntax sugar :/
23:30:25 <edwardk> if applicative captures context free, and monads capture 'context sensitivity', arrows sit somewhere in the middle
23:31:30 <Sgeo> What do arrows provide precisely above applicatives?
23:31:35 <Sgeo> I get what monads provide over arrows
23:31:46 <edwardk> arr is mandatory mostly because to define a proper CCC without arr you need things beyond haskell 98, and because that was the first abstraction folks thought of that could cover swierstra and duponcheel's non-monadic parser
23:32:05 <Sgeo> CCC?
23:32:21 <edwardk> that said, that particular usecase is covered by applicative, so the initial 'guess' at what was needed was in many ways too big
23:32:27 <edwardk> cartesian closed category
23:33:23 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Category-Cartesian.html#t:PreCartesian gives me the parts of arrow i want mostly
23:33:38 <edwardk> er there is a version of that in 'categories' now
23:35:22 <tieTYT2> my question: http://stackoverflow.com/questions/15426156/in-haskell-how-can-i-write-an-http-client-to-traverse-a-website-and-submit-form
23:40:25 <Sgeo> :t \foo -> foo {bar = 'a'}
23:40:26 <lambdabot> `bar' is not a (visible) constructor field name
23:47:55 <ag90_> tieTYT2: There's a library called shpider or something similar that might make your job easier. I'm not sure how active that is.
23:48:28 <tieTYT2> ag90_: I've had bad luck with libraries.  I've yet to find one that works on windows :(
23:49:33 <tieTYT2> ag90_: this does look useful though, is there any way for me to know if this'll work on windows without trying it out?
23:50:06 <tieTYT2> it depends on curl, which I can't figure out how to get working on windows :(
23:50:30 <Ralith> arkeet: to be precise, idris generates any of [C, assembly, javascript, java]
23:50:37 <Ralith> oh wow I was scrolled up
23:50:38 <Ralith> anyway
23:50:43 <arkeet> :p
23:50:49 <Ralith> still worth note ^^
23:51:05 <Ralith> (the backend that outputs assembly is distinct from the backend that outputs C)
