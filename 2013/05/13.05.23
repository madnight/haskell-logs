00:01:39 <hrookie> forgot to rejoin - did my hpaste broadcast?
00:05:27 <lpvb> I need a search bar in my browser for hoogle and hayoo
00:05:37 <hrookie> ooo, hayoo, what's hayoo?
00:06:08 <lpvb> hrookie: searches all of hackage for your function
00:06:37 <hrookie> lol, i will keep it in mind! i love how hoogle is purple, while hayoo has google colors. these guys have a sense of humor
00:08:14 <MasseR> lpvb: Duckduckgo
00:08:16 <MasseR> !hoogle foo
00:08:18 <MasseR> !hayoo foo
00:09:08 <hrookie> (and nobody mentioned whether the hpaste announcement came in - this is where i slapped my code regarding similar records http://hpaste.org/88394)
00:12:27 <supki> I don't see how these records are similar besides 3 common fields?
00:12:52 <supki> hrookie: how would inheritance help?
00:13:30 <hrookie> supki: i want for both of them to have a "starGameClock", "stopGameClock", and "getTimeDelta" function
00:13:50 <dpwright_> dmwit, pqmodn, bos -- managed to build it using the swapfile.  Thanks for your help
00:14:00 <hrookie> supki: possibly among other things. having a base class with all the commonalities, then deriving to cover the differences, would be ideal. repeating large constructors seems overkill?
00:14:43 <supki> hmm
00:15:42 <supki> hrookie: I would factor common fields in say CommonState, define your functions for CommonState then and use lenses to access them: state^.playerstate.commonstate.to stopGameClock  for example
00:16:46 <hrookie> yeah, that's what i ran into on SO (sans lenses, but those just seem like a good idea for large records)
00:17:10 <supki> yes, they make large records much nicer to work with
00:17:24 <hrookie> do you ever use template haskell with your lenses?
00:18:01 <supki> sure, makeLenses is handy
00:18:11 <hrookie> awesome, thankx
00:18:17 <hrookie> i'm learning a ton of haskell in doing this project =D
00:18:23 <hrookie> i think what you're describing is the tidiest way to do it
00:19:21 <hrookie> so thanks for your input! i will take a look at lenses and see how fast i can learn them
00:19:53 <hrookie> i know the general principle, i've just never used them
00:20:06 <supki> I imagine it's nice to understand lenses
00:20:31 <supki> fortunately you don't need to undestand them to use them ;)
00:20:46 <hrookie> xD i have issues allowing myself to write code when i have no idea wtf it actually does
00:22:11 <hrookie> in my PL class a lot of people did "brute force haskell" -- we'd be editing big modules and they'd be sophisticated enough that if you had the general idea, and it compiled, and it looked kinda right, you were right
00:22:26 <hrookie> because there was only one way left to accomplish filling out that tiny line
00:22:50 <hrookie> but i really can't just write code, even if the output is right, and be satisfied if i'm not sure why. i have to go back and solve it.
00:27:37 <gaze__> http://hpaste.org/88395 what's the least amount of gross stuff required to get close to this syntax?
00:30:57 * hackagebot prelude-prime 0.1 - A slightly better (but conservative) Prelude  http://hackage.haskell.org/package/prelude-prime-0.1 (RomanCheplyaka)
00:36:52 <hrookie> supki: if control.lens is really just pretty printing and sugar on all the functions i'd normally write, then i'm more than happy to use with makeLenses :D
00:37:17 <hrookie> supki: i'm totally digging le composition
00:37:35 <hrookie> so, here's a fun question. why is it called a "lens"?
00:41:39 <bartavelle> there is also a loupe
00:45:47 <hrookie> well, thanks for insight all, and to all a goodnight
00:46:06 <Sgoettschkes> hi
00:46:49 <Sgoettschkes> Can anybody explain to me what a function call like "functionName !! parameter" on a function that doesn't take parameters does?
00:47:09 <shachaf> There's no such thing as a function that doesn't take parameters.
00:47:10 <sopvop> @hoogle (!!)
00:47:10 <lambdabot> Prelude (!!) :: [a] -> Int -> a
00:47:10 <lambdabot> Data.List (!!) :: [a] -> Int -> a
00:47:11 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
00:47:33 <shachaf> The thing on the left of !! is a list. The thing on the right is an index.
00:47:36 <shachaf> > "hello" !! 4
00:47:38 <lambdabot>   'o'
00:47:50 <shachaf> (Do you have ghci? That's a good way to experiment with this sort of thing.)
00:47:57 <Sgoettschkes> ah, ok
00:49:10 <Sgoettschkes> shachaf: I got ghci and definitly need to use it more, thanks
00:49:46 <adinapoli> I think it's pretty informative to also look at the implementation, should be easy enough even for a beginner :)
00:49:51 <adinapoli> @src (!!)
00:49:52 <lambdabot> xs     !! n | n < 0 = undefined
00:49:52 <lambdabot> []     !! _         = undefined
00:49:52 <lambdabot> (x:_)  !! 0         = x
00:49:52 <lambdabot> (_:xs) !! n         = xs !! (n-1)
00:50:41 <Sgoettschkes> I don't know, my mind has a hard time getting used to the functional way
00:50:58 * hackagebot egison 3.0.5 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-3.0.5 (SatoshiEgi)
00:51:34 <adinapoli> Sgoettschkes, in that case I suggest ghci and a good dose of LYAH :)
00:51:35 <Sgoettschkes> seeing something like (primes !! 1000) I immediatly think that primes get passed the integer instead of thinking of !! as a function
00:52:07 <shachaf> What about (5 + 3)?
00:52:12 <adinapoli> Sgoettschkes, well, that's because is defined as an infix function so you call it between 2 args
00:52:24 <shachaf> That has nothing to do with "functional way", though. That's just Haskell syntax.
00:53:54 <Sgoettschkes> Maybe it's a mixture of me used to oop and my knowledge of Racket, which has no infix (so it would be (!! primes 1000))
00:55:39 <Sgoettschkes> anyway, functional programming is hard for me. So thank you very much for answering my "beginner questions" :)
00:56:53 <adinapoli> Sgoettschkes, yw, nobody born with the infused Haskell knowledge from the Almighty, even though it would have been nice :D
00:58:50 <Sgoettschkes> adinapoli: It would indeed ;)
01:00:08 <jesyspa> Sgoettschkes: You could always make it prefix with (!!) primes 1000, though it may confuse those reading.  (Also, huh, I seem to remember Racket having infix...)
01:01:32 <sopvop> > (Just <$> "hello") & mapped %~ Last & getLast.fold
01:01:32 <sopvop> > (Just <$> "hello") & ala Last foldMap
01:01:32 <sopvop> "lens" are huge :(
01:01:35 <lambdabot>   can't find file: L.hs
01:01:35 <lambdabot>   Just 'o'
01:02:37 <sopvop> This Control.Lens.Wrapped thing is awesome
01:02:38 <supki> > "hello" & lastOf folded
01:02:39 <lambdabot>   Just 'o'
01:03:27 <sopvop> > [Just 1, Nothing, Just 2] & ala Last foldMap
01:03:29 <lambdabot>   Just 2
01:03:35 <sopvop> ^ I needed this
01:04:27 <supki> > [Just 1, Nothing, Just 2] & lastOf (folded . folded)
01:04:30 <lambdabot>   Just 2
01:04:31 <supki> :P
01:05:24 * shachaf notes that lastOf is something like three orders of magnitude slower than it could be.
01:05:39 <johnw> 1000 is a popular number lately, so makes sense
01:05:42 <sopvop> Swiss army knife just got bigger
01:06:29 <sopvop> > [Just 1, Nothing, Just 2, Nothing] & lastOf (folded . folded)
01:06:31 <lambdabot>   Just 2
01:08:18 <sopvop> so lastOf is slower than `ala Last foldMap`?
01:08:40 <gaze__> Would anyone mind having a look at this http://stackoverflow.com/questions/16708700/bind-monadic-variables-over-several-functions stack overflow question?
01:09:07 <Latermuse> Sure
01:09:38 <shachaf> sopvop: Replace the last two "let"s with whitespace; indent the do block one more space in.
01:09:45 <shachaf> s/sopvop/gaze__/
01:11:52 <bartavelle> also you need to use moof somewhere
01:16:20 <gaze__> haha I had no idea you could let bind a bunch of stuff
01:16:22 <gaze__> cool, thanks
01:16:39 <sopvop> http://hpaste.org/88399
01:17:01 <sopvop> I rember hpaste was reported by lambdabot. I pasted and forgot to link it here
01:17:06 <covi> Data.Text is missing on my machine. What's wrong?
01:17:22 <sopvop> covi: you don't have "text" package installed
01:17:31 <covi> sopvop: how can i install it
01:17:40 <sopvop> depends how you installed ghc
01:17:46 <sopvop> or cabal
01:17:48 <covi> sopvop: i installed haskell-platform
01:17:57 <bartavelle> you should have text then
01:18:00 <sopvop> covi: it should include text
01:18:17 <bartavelle> isn't it an issue where you didn't add text to the dependencies in a .cabal file ?
01:18:20 <covi> I may mess up the ghc's
01:18:26 <sopvop> covi: run gchi and type "import Data.Text"
01:18:50 <covi> it says could not find module
01:20:03 <bartavelle> you can list modules with "ghc-pkg list"
01:20:05 <sopvop> covi: try "ghc-pkg list" and check if it has text or anything beside b
01:20:10 <sopvop> :)
01:20:11 <bartavelle> so you can see if it's broken or missing
01:20:34 <covi> not there :(
01:21:22 <sopvop> covi: easises way to fix is delete ~/.ghc ~/.cabal and reinstall everything
01:21:40 <bartavelle> except ~/.cabal/bin/cabal, that will comme handy :)
01:21:42 <covi> sopvop: crap, i just did that...
01:21:51 <sopvop> :)
01:22:05 <covi> maybe i should delete this VM and tried another linux dist, lol
01:22:09 <sopvop> bartavelle: I think haskell-platform comes with cabal
01:22:15 <Latermuse> Good idea
01:22:20 <bartavelle> yes it does, but text comes with ghc, right ?
01:22:25 <sopvop> No
01:22:31 <bartavelle> ah it's bytestring then ?
01:22:38 <arnsholt> Is there a way to express that two arguments should be identical, or should I just use a guard?
01:22:50 <shachaf> Yes and yes.
01:23:21 <arnsholt> Right. It's doable but not advisable, I take it?
01:23:31 <Latermuse> Yes
01:23:42 <shachaf> ?
01:23:48 <shachaf> The way to express it is to use guards.
01:23:52 <Aetherspawn> :t maybe
01:23:53 <lambdabot> b -> (a -> b) -> Maybe a -> b
01:23:55 <shachaf> Assuming that by "identical" you mean "equal".
01:24:02 <sopvop> foo a b | a == b = ...
01:24:11 <arnsholt> shachaf: Right, that was the alternative interpretation
01:24:31 <arnsholt> Yeah, equal. Too much Prolog seeping into my Haskell =)
01:24:39 <covi> I had a yesod project. But running 'yesod devel' gives error
01:25:13 <sopvop> bartavelle: bytestring does
01:26:21 <Latermuse> Covi: what was the error?
01:26:40 <gaze__> http://hpaste.org/88400 Any way to get rid of the ;s, maybe make this prettier?
01:26:47 <sopvop> covi: you can also try asking #yesod
01:29:53 <Aetherspawn> @pl return . maybe (Done ()) (HaveOutput pull close)
01:29:53 <lambdabot> return . maybe (Done ()) (HaveOutput pull close)
01:30:01 <Aetherspawn> ofc -_-
01:30:10 <Aetherspawn> @pl PipeM $ liftSTM $ readCh ch >>= translate
01:30:10 <lambdabot> PipeM (liftSTM (translate =<< readCh ch))
01:30:23 <Aetherspawn> no thanks.
01:30:43 <sopvop> gaze__: if you want braces/semi style - use SPJ style for do notation. like in annotation http://hpaste.org/88400
01:30:55 <sopvop> And for the love of god don't use tabs!
01:33:36 <Aetherspawn> @pl liftSTM $ readCh ch
01:33:37 <lambdabot> liftSTM (readCh ch)
01:33:55 <Aetherspawn> is liftSTM $ readCh ch the same as liftSTM . readCh ch ?
01:34:05 <shachaf> No.
01:34:14 <sopvop> :t readCh
01:34:16 <lambdabot>     Not in scope: `readCh'
01:34:16 <lambdabot>     Perhaps you meant one of these:
01:34:16 <lambdabot>       `readIO' (imported from Prelude), `readLn' (imported from Prelude),
01:34:21 <johnw> Aetherspawn: liftSTM . readCh $ ch is the same as liftSTM $ readCh ch
01:35:04 <Aetherspawn> oh okay
01:50:59 * hackagebot Workflow 0.8.0.5 - Workflow patterns and a monad for thread state logging & recovery  http://hackage.haskell.org/package/Workflow-0.8.0.5 (AlbertoCorona)
02:10:03 <weebl> @hoogle liftM
02:10:03 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
02:10:03 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
02:10:03 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
02:10:31 <quchen> Boo. Use fmap and liftA* instead of liftM and liftM*.
02:11:06 * weebl are confused
02:11:12 <weebl> liftA*?
02:11:20 <quchen> liftA2, liftA3, ...
02:11:22 <sopvop> :t liftA2
02:11:24 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
02:11:27 <quchen> instead of liftM2, liftM3
02:11:40 <no-n> > let reverse = foldl (flip (:)) [] in reverse "hello, world"
02:11:42 <lambdabot>   "dlrow ,olleh"
02:11:42 <quchen> liftA is more general, but does the same
02:12:11 <weebl> it's not my code actually
02:12:13 <supki> the problem with liftA* is that they can make code /less/ general
02:12:23 <weebl> i'm trying to fix a parser
02:12:38 <supki> if you have  MonadIO m =>  constraint for example, you better use liftM
02:12:56 <quchen> supki: I refuse! :-C
02:13:05 <sopvop> The problem with liltA is extra constraint
02:13:24 <weebl> anyone familiar with parsec?
02:13:26 <sopvop> because everyone fears breaking code
02:13:35 <supki> quchen: we all hope for your proposal to be accepted!
02:13:56 <quchen> supki: First, I hope Github repairs my page :-/
02:14:10 <merijn> Apparently we will first have to elect Library Tsars :p
02:14:27 <quchen> merijn: That's for Foldable/Traversable though.
02:14:50 <johnw> edwardk for Tsar!
02:15:22 <quchen> The AMP doesn't need Tsars. It needs many people saying "yes that's what I wanted for a long time". :-)
02:15:26 <weebl> http://hpaste.org/88402 - if i try to parse ((n*2) <= (n * y * 12)), it gives me unexpected ")" column 9
02:15:42 <weebl> column 9 in this case is the ")" prior to 2
02:15:45 <sopvop> We can't make edwardk Tsar, who will then do the dirty work of implementing fancy libraries?
02:15:48 <weebl> after*
02:16:06 <shachaf> Edward the Terrible
02:16:29 <sopvop> Ivan the Terrible killed his own son...
02:16:35 <quchen> sopvop: Only if Lens isn't added to Base. But if edwardk is Tsar ... :-D
02:17:21 <johnw> you don't want lens in base
02:17:27 <johnw> development would effectively halt
02:17:30 <Aetherspawn> tries to explain TChan to a C++ programmer
02:17:35 <Aetherspawn> ends up talking about quantum buckets
02:17:36 <hvr> johnw: why that?
02:17:37 <quchen> johnw: True
02:18:02 <quchen> hvr: Compatibility breaking things in Base are hard to do
02:18:46 <quchen> Aetherspawn: It's a little like explaining "red" to a blind person ;-)
02:18:58 <Aetherspawn> ^ lol
02:19:20 <johnw> Aetherspawn: I would think that just describing it in terms of a database wouldn't be all that difficult for them to grasp
02:19:24 <nickray> hi guys... as a casual user of haskell... why does everything have to be rebuilt even after a minor update of GHC?
02:19:27 <quchen> weebl: Your code is cut off on HPaste
02:19:36 <weebl> quchen: it's just a snippet
02:19:50 <shachaf> nickray: Because there is no ABI compatibility between versions of GHC.
02:20:16 <weebl> prior to the binary operators it cannot deal with parentheses well, after the binary operator it has no problems with parentheses
02:20:16 <quchen> weebl: Well, the error is about the parenthesis, and your code doesn't show the parentheses parser
02:20:17 <johnw> even between versions that might be ABI compatible!
02:20:46 <shachaf> johnw: Fine. There is no guarantee of ABI compatibility.
02:20:46 <quchen> weebl: Do you know the "between" combinator? It's made for things like parentheses
02:20:54 <weebl> quchen: http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Token.html
02:20:59 <weebl> there is the parens function
02:21:01 <sopvop> Because every ghc version is tied to a version of base
02:21:18 <ethercrow> is there something simpler to turn x into [x+1, x+2, ..] than unfoldr (\y -> Just (y + 1, y + 1)) ?
02:21:28 <quchen> weebl: Yeah, that one will do as well
02:21:36 <no-n> ghci seems to be funny about using infixl. how exactly do I write let (//) = div ; infixl 7 // in ghci?
02:21:49 <shachaf> Works for me.
02:22:13 <quchen> You can define fixities in GHCi?
02:22:32 <shachaf> You can define fixities in let, as no-n demonstrated.
02:22:52 <shachaf> So defining a local fixity is part of syntax that can be in an expression.
02:23:05 <nickray> shacha: that's more or less a reformulation of what i asked ;-) so... why no ABI compatibility?
02:23:34 <no-n> it doesn't state its fixity when I type :info //
02:23:50 <shachaf> OK, but does it behave fixfully?
02:24:00 <shachaf> nickray: OK. Lots of reasons.
02:24:01 <no-n> hmm, it does
02:24:04 <no-n> wasn't the other day lol
02:24:08 <no-n> oh well
02:24:40 <shachaf> ABI compatibility is something to actively put effort into.
02:25:04 <sopvop> recompiling is not such a big issue anyway
02:25:19 <weebl> :r
02:26:08 <sopvop> Compiling all the dependencies of snap and my web-app takes only a small fraction of time required to compile boost...
02:28:27 <weebl> quchen: any idea on how to fix it?
02:29:36 <quchen> weebl: Not really. Still looking at it
02:31:08 <quchen> weebl: The code looks right to me (unfortunately)
02:31:16 <quchen> At least the part you posted
02:32:15 <quchen> weebl: Have you tried making a minimal example? What happens if you parse "(n * y * 12)" for example? What about "(y * 12)" or "(12)"?
02:32:22 <weebl> all fail
02:32:24 <quchen> "((12))"?
02:32:31 <quchen> All fail? :x
02:32:33 <quchen> That's a lot
02:32:40 <weebl> only if you use y*(z*x)
02:32:41 <weebl> will it work
02:32:46 <weebl> but start with parentheses = fail
02:33:19 <quchen> Ah, I see. Could it be that your expression parser parses only binary ones?
02:33:26 <quchen> i.e. it can handle x*y, but not x*y*z?
02:33:53 <weebl> it can handle x*y*z, just not in parentheses
02:34:01 <weebl> it's boggling my mind
02:34:13 <quchen> Care to post the rest of the code?
02:34:27 <quchen> (Of the parser, at least)
02:35:08 <weebl> http://www.weebl.me/weebl/ParseWhile.hs
02:35:13 <weebl> trying to parse the while language
02:36:14 <weebl> don't mind the retarded procedureStmt parser lol ;x
02:37:24 <weebl> also: http://www.weebl.me/weebl/WhileSyntax.hs
02:39:38 <quchen> Hm. Well somehow parens parses the "(", then the expression. It then seems to consume the ")" *in the expression*, and afterwards wants to parse the closing parenthesis.
02:39:54 <quchen> This is odd.
02:40:08 <weebl> yep very odd
02:40:17 <weebl> it thinks the aExpression is somehow finished and tries to parse the boolean op
02:40:21 <quchen> So even "(1)" fails?
02:40:25 <weebl> yep
02:40:31 <quchen> "()"?
02:40:37 <quchen> Or is that a grammatical error
02:41:25 <weebl> fails too
02:41:47 <weebl> if ((1) < (2)) fails, if (1 < (2)) works
02:42:07 <quchen> weebl: In line 164ff (definition of aTerm), you use 'parens' twice. Is that intended?
02:42:23 <quchen> parens aExpression, parens aTerm
02:42:23 <weebl> the parens aTerm was a test
02:42:36 <weebl> it shouldn't be there, but it made no difference
02:43:23 <quchen> Well then I'm out of clues again :-(
02:43:43 <quchen> And since I'm out of food as well I'm going to eat something now
02:43:59 <weebl> have a nice meal
02:44:11 <quchen> Good luck with that parser, sorry I wasn't much of a help
02:49:58 <weebl> fixed it by swapping parens bExpression with rExpression
02:50:06 <beaky> hello
02:50:13 <weebl> hi
02:50:33 <beaky> how did you gys discover haskell?
02:50:36 <beaky> guys*
02:50:38 <weebl> college
02:50:58 <beaky> ah neat
02:51:15 <beaky> how is haskell used in college? compiler class?
02:51:50 <beaky> or as a programming intro?
02:53:49 <weebl> beaky: intro to functional programming, language, parsers & compilers classes
02:53:56 <shanse> teacher in high school used it for a semester
02:55:47 <beaky> wow that is awesome
02:55:55 <beaky> i wanna us haskell to do cool things
02:56:14 <beaky> but my classes force me to use java or C or C++ :(
02:56:48 <capisce> so use it outside of class
02:59:37 <HugoDaniel> beaky: drink a few beers and try this one after: http://hackage.haskell.org/package/language-java
03:01:01 * hackagebot Clean 0.3 - A light, clean and powerful utility library  http://hackage.haskell.org/package/Clean-0.3 (MarcCoiffier)
03:01:32 <beaky> aj
03:03:12 <aleator> A bit of help please, what is a suitable common name for stuff like monads and applicatives?
03:03:43 <mm_freak> aleator: algebraic structures?  i don't understand the question
03:03:56 <beaky> they are type classes?
03:04:30 <mm_freak> aleator: they are all structures from abstract algebra, so i'd just call them algebraic structures
03:04:33 <aleator> Well, I'm writing a proposal, in which I need to say that my students had problems with <insert here>.
03:05:29 <mm_freak> if you want to be more specific, you can say categorical structures
03:05:37 <aleator> And I can't figure out a better term than "algebraic structures such as monads", and I don't want people to think I'm about to write yet another monad tutorial.
03:05:44 <mm_freak> in the context of haskell programming 'patterns' instead of 'structures' would also be fine
03:05:53 <aleator> Hmm. categorical structure seems nice.
03:06:04 <mm_freak> i'd use algebraic structures
03:06:18 <beaky> yeah they are algebras
03:06:29 <beaky> or correspond to lgebras*
03:07:57 <aleator> mm_freak, beaky:  context at http://hpaste.org/88403. I really can't write :)
03:08:47 <mm_freak> aleator: sounds fine to me
03:09:09 <aleator> mm_freak: ok. Thanks
03:09:23 <aleator> BTW. anyone of you teach Haskell currently?
03:09:29 <mm_freak> because then you can start with the basics (monoids, Hask, Hask functors) and then move ahead
03:10:00 <mm_freak> not currently, but i've given a number of intro tutorials/workshops in the past
03:11:13 <aleator> I'm looking for exercise ideas which would be suitable for machine grading.
03:12:22 <mm_freak> any exercise with a well-defined result =)
03:13:13 <mm_freak> use hlint as one source, compiler warnings as the second one, the program's output as the third, combine
03:13:39 <mm_freak> (for the warnings, use -W, not -Wall)
03:14:45 <amosr> quickcheck!
03:17:06 <aleator> amosr: That I did already. Very nice for beginner problems, since it can show counter examples
03:17:43 <aleator> I've also toyed with a program that shows step-wise evaluation traces of the programs and ask students to name which equation was used at each step.
03:17:48 <mm_freak> even with -W be cautions:  foldr f z [] = z
03:17:51 <mm_freak> gives a warning
03:18:08 <aleator> Doesn't work with anything more complex than cases and simple patterns, but still.
03:18:42 <aleator> mm_freak: Yeah. Warnings. How didn't I think of that.
03:26:30 <latermuse> is there any way for a function with type (a -> a) have any idea what kind of type is passed to it? if I pass an Int to an (a -> a) function, can the function know that an Int was passed to it?
03:26:40 <beaky> ls
03:27:20 <amosr> type families, maybe?
03:27:43 <_emm_> latermuse: what do you want to do?
03:27:51 <shachaf> latermuse: Fortunately not.
03:29:27 <latermuse> shachaf: this type of functionality would make haskell impure, no?
03:29:32 <merijn> latermuse, shachaf: Typeable a => a -> a :>
03:30:19 <shachaf> latermuse: Not by any meaning of "purity" that I'm familiar with.
03:30:26 <latermuse> oh
03:30:32 <shachaf> But that word is already close to meaningless, so sure.
03:30:51 <shachaf> merijn: a ~ Int => a -> a
03:31:04 <merijn> "Can haskell do X?" 'No' "oh, so that would make Haskell impure, right?" '...'
03:31:15 <merijn> shachaf: Oh, right
03:31:57 <latermuse> I want to do something like: f a = if (a == Int) then ... else ...
03:32:07 <mm_freak> when talking about monoid morphisms, commonly two axioms are stated:  f (x + y) = f x + f y, f id = id
03:32:35 <shachaf> I recommend not wanting that.
03:32:40 <latermuse> and not with Int in particular. I am doing it with custom types
03:32:54 <merijn> latermuse: I second "not wanting that", but if you have to, Typeable is the only way
03:33:03 <latermuse> shachaf: yeah, i feel it seems pretty ridiculous now that Ive thought about it some more
03:33:03 <mm_freak> it seems to me that the former includes the latter implicitly:  f (x + id) = f (id + x) = f x + f id = f id + f x = f x
03:33:09 <merijn> Well, the only sane way...
03:33:11 <mm_freak> am i missing something?
03:33:26 <latermuse> f x = if (x == Int) then x + 5 else x + 5.0
03:33:28 <latermuse> this would be a disaster
03:33:33 <latermuse> thanks for showing me the way!
03:34:07 <merijn> latermuse: That'd be a type error, even if you do use Typeable
03:34:17 <latermuse> for sure
03:35:25 <mm_freak> wikipedia says:  "Not every semigroup homomorphism is a monoid homomorphism since it may not preserve the identity."
03:35:26 <supki> x == Int is meaningless anyway
03:35:28 <shachaf> mm_freak: x + y = x doesn't mean that y = id
03:35:37 <mm_freak> shachaf: ah, true
03:35:39 <mm_freak> thanks
03:35:48 <merijn> supki: Of course it is, it was pseudo code to illustrate what he wants
03:36:11 <latermuse> merijn: yes pseudo code
03:38:36 <supki> latermuse: another not recommended way would be to have typeclass C with overlapping instances C a and C Int
03:41:06 <t4nk145> hi anyone knows how to prove that a<=c -> c<=a -> a=c? in agda
03:42:17 <shachaf> Maybe #agda would know.
03:42:37 <t4nk145> ok thanks=,=
04:03:33 <fluffynukeit> hi.  What is the idiomatic way to communicate two-way between two threads?
04:04:00 <Saizan> fluffynukeit: use two channels
04:05:10 <fluffynukeit> Saizan: is there a library that wraps up the two channels into one two-way construct, or is that not possible?
04:05:51 <hiptobecubic> shachaf, how not?
04:09:31 <Saizan> fluffynukeit: i think it'd be possible, no idea if there's a lib
04:10:18 <magicman> shachaf: When quantified, it's true. forall x. x + y = x -> y = id. If there is an y' with that property, you have id + y' = y', but also id + y' = id, resulting in y' = id. When not quantified, anything goes.
04:12:02 <papyrus> i am reading "Understanding Functional Dependencies vi Constraint Handling Rules" Martine Sulzmann , http://research.microsoft.com/pubs/67435/jfp06.pdf
04:12:18 <papyrus> Functional dependencies describe properties of relations, a functional dependency a -> b for a relation R ( a, b, c) states that in the relation R for a given value of the second argument a there is a unique possible value for the second argument b .  So for example the relation {(1,2,3),(1,2,1),(2,3,1)} satisfies the functional dependency while { (1,2,3) ,(1,1,2) } does not.
04:13:09 <papyrus> i don't understand. R (a,b,c) means.. a = (1,2,3), b = (1,2,1),c= (2,3,1) ?
04:13:15 <shachaf> magicman: There's no forall x. there.
04:15:19 <magicman> I think there is in mm_freak's derivation.
04:16:15 <magicman> Wait, no. Only the argument to f is quantified, not f x itself. Point!
04:17:05 <shachaf> Operation: (||). Identity: False. (endo-) "homomorphism": const True.
04:17:13 <magicman> *nod*
04:17:24 <shachaf> mm_freak: ☝, if you wanted a concrete example
04:18:02 <mm_freak> shachaf: i thought of an easier (for me) one:  modular arithmetic =)
04:18:08 <mm_freak> but thanks =)
04:19:55 <magicman> My new favourite monoid is the monoid of radicals of integers...
04:20:09 <shachaf> The case I gave is the simplest possible one. :-)
04:20:58 <shachaf> (It can be seen as modular arithmetic too, of course.)
04:22:43 <mm_freak> say i have a category C with two objects A and B and a single nontrivial morphism f : A -> B
04:23:00 <mm_freak> A and B denote sets, f denotes a function
04:23:02 <adas> is it possible that a package and build system like that of Golang could be good for haskell?
04:23:13 <mm_freak> F : C -> C^op
04:23:22 <mm_freak> what does F f in C^op denote?
04:24:21 <mm_freak> put differently, what's the meaning of flipping the sin : ℂ -> ℂ arrow in Set?
04:24:56 <mm_freak> shachaf: the simplest possible case isn't always the easiest one =)
04:26:29 <mm_freak> back to the question:  does C^op even have a meaning or is that meaning established by the functor that does the mapping?
04:26:49 <mm_freak> adas: anything wrong with cabal?
04:29:25 <byorgey> mm_freak: the image of an arrow in C^op still "means" the same thing
04:29:45 <byorgey> or rather, there isn't any general "meaning" you can assign to flipping morphisms
04:30:05 <byorgey> it's just that you switch which object you consider the "source" and which the "target" and composition goes the other way.
04:30:42 <byorgey> for example, if I started writing haskell types as   (b <- a)  instead of  (a -> b)  it wouldn't change anything about the meaning of terms with those types.
04:30:55 <adas> mm_freak: its just that cabal leaves whatever linux distro I use in an unstable state due to the inability to properly install or uninstall hasell libraries
04:31:34 <hpc> byorgey: except for partial application of types being much more awkward
04:31:53 <byorgey> hpc: I didn't say it was a good idea =)
04:32:01 <hpc> :P
04:32:24 <mm_freak> byorgey: ok, so there is this opposite category, but the interpretation is up to you?
04:32:46 <mm_freak> adas: i don't understand…  i can install packages both through my distribution and through cabal-install just fine
04:32:51 <arkeet> if the objects and morphisms of C are sets and functions,
04:32:58 <arkeet> then the objects and morphisms of C^op are sets and functions
04:33:10 <arkeet> just that a morphism A -> B in C^op is a morphism B -> A in C
04:33:20 <mm_freak> arkeet: are you sure?  say F is the functor that does the mapping
04:33:23 <shachaf> arkeet: Why are you awake?
04:33:24 <mm_freak> then what is F sin?
04:33:25 <arkeet> what mapping?
04:33:34 <mm_freak> arkeet: C -> C^op
04:33:43 <arkeet> there is no functor like that.
04:33:51 <arkeet> well, no natural one.
04:33:57 <adas> mm_freak: uninstalling is the problem. You never addressed taht
04:34:04 <shachaf> If you have a category with a bunch of structure, you can look at its opposite category and see if it happens to be equivalent to some category that you know.
04:34:34 <mm_freak> adas: uninstalling through the distribution works fine, too…  uninstalling through ghc-pkg works, too
04:34:53 <mm_freak> shachaf: that's what i wanted to know…  thanks
04:35:03 <arkeet> mm_freak: I think you might review the definition of category. and functor.
04:35:07 <shachaf> mm_freak: ?
04:35:20 <shachaf> I didn't actually really say anything.
04:35:28 <mm_freak> shachaf: yes, but it helped =)
04:36:28 <mm_freak> arkeet: F : C -> C^op, F (f : A -> B) : B -> A
04:36:34 <mm_freak> isn't that a contravariant functor?
04:36:52 <arkeet> contravariant functors aren't functors.
04:37:27 <mm_freak> well, terminology, ok =)
04:37:42 <arkeet> a contravariant functor C -> D is just a functor C^op -> D
04:38:23 <mm_freak> so a contravariant functor C^op -> C^op is just a functor (C^op)^op -> C^op?
04:38:34 <shachaf> arkeet: you gotta tell me if you're a C^op
04:38:36 <arkeet> sure. but (C^op)^op = C
04:38:45 <mm_freak> arkeet: my point ;)
04:40:12 <mm_freak> but yes, Set was a bad example
04:40:27 <arkeet> Set is a fine example.
04:40:32 <shachaf> Your functor is the identity functor.
04:40:58 <arkeet> in Set^op, objects are sets, and morphisms from A to B are functions from B to A.
04:41:08 <arkeet> and composition is flipped function composition.
04:41:09 <arkeet> that's it.
04:41:17 <mm_freak> i see
04:42:06 <arnsholt> Is there a more idiomatic way to cross-product two lists, other than a list comprehension: [(x, y) | x <- xs, y <- ys]?
04:42:16 <arkeet> liftA2 (,) xs ys
04:42:16 <mauke> liftA2 (,)
04:42:29 <arkeet> or  (,) <$> xs <*> ys
04:42:48 <arnsholt> Neat. Thanks!
04:43:09 <shachaf> concat (map (\x -> concat (map (\y -> [(x,y)]) ys)) xs)
04:44:25 <mm_freak> arkeet: but isn't that just an interpretation?  consider a subcategory C of Set with only two objects 0, 1 and a single nontrivial morphism:  f : 0 -> 1
04:44:37 <arkeet> mm_freak: no, it is a definition.
04:44:51 <mm_freak> in C^op, f : 1 -> 0, which isn't really a function
04:45:06 <arkeet> 0 and 1 aren't really sets, unless you explain to me how they're sets.
04:45:21 <mm_freak> 0 is the empty set, 1 is a single-element set
04:45:32 <arkeet> ok, then in C^op, the arrow 1 -> 0 is a function from 0 to 1.
04:45:42 <mm_freak> ah!
04:45:50 <arkeet> like I said.
04:46:03 * hackagebot statistics-linreg 0.2.4 - Linear regression between two samples, based on the 'statistics' package.  http://hackage.haskell.org/package/statistics-linreg-0.2.4 (AlpMestanogullari)
04:46:25 <mm_freak> thanks
05:13:28 <augur> @tell ski the variant on ->L i suggested actually does exist! also, no need for this funny business about identiers, probably.
05:13:29 <lambdabot> Consider it noted.
05:26:16 <quchen> So I was silentbanned from Github yesterday for doing multiple quick commits to a Gist. Grr.
05:26:27 <Kinnison> quchen: oops
05:26:36 <quchen> Good thing their support is pretty fast, so now my ApplicativeMonad repo is working again :-)
05:33:34 <ion> quchen: Whoa. I didn’t know they’ll do something like that.
05:34:13 <quchen> Yeah neither did I
05:34:28 <quchen> For me everything was still working as usual when I was logged in
05:34:42 <quchen> Everyone else got 404s for all my stuff
05:34:54 <ion> nice
05:35:57 <ion> Which one is the authoritative one? I’d suggest replacing the other one with a document that just links to the other one. https://github.com/quchen/articles/blob/master/applicative_monad.md https://gist.github.com/quchen/5501031
05:36:26 <quchen> ion: Dunno. I posted the Gist to Github because Gist didn't seem to work (even for me).
05:36:42 <quchen> I think Gist might be better because it has a nice comment section and isn't tied to the rest of my repo.
05:36:53 <quchen> Also it has all the previous revisions.
05:37:26 <ion> Re: the previous revisions, it would be possible to simply merge from that gist to your articles repo.
05:38:35 <quchen> ion: Still the articles repo has no nice way of commenting. Also I wouldn't know how to do that merge. Clone, create patch, apply to other repo?
05:39:41 <ion> Clone the articles repo, git remote add gist https://gist.github.com/5501031.git, git fetch --all, git merge gist/master, git mv amp.md articles/applicative_monad.md, git commit
05:39:57 <ion> Or something along those lines.
05:40:45 <Aetherspawn> HaskellPlatform 2012.4 installs 7.4.2
05:40:50 <Aetherspawn> I thought it was supposed to be 7.6.3?
05:41:27 <quchen> Aetherspawn: No, it's 7.4.2.
05:41:34 <Aetherspawn> ;__; OK
05:41:38 <quchen> The platform doesn't always use the latest compiler version.
05:41:45 <Aetherspawn> I love new compiler releases
05:41:49 <Aetherspawn> especially performance ones
05:41:49 <quchen> However, the next platform release is almost ready
05:41:58 <Aetherspawn> its so fun t obuild your old stuff and benchmark against the previous compiler
05:42:03 <weebl> anyone ever did automatic program analysis using monotone frameworks in haskell?
05:42:06 <Aetherspawn> Makes me feel like haskell is moving forwards all the time
05:42:44 <quchen> Aetherspawn: Right now, the RCs for the new Platform are checked and packaged (for the distros). The new platform is 7.6.3 based.
05:43:49 <ion> aetherspawn: I tend to do this instead of using the Haskell Platform: https://gist.github.com/ion1/2815423
05:44:11 <Aetherspawn> I'm on Windows :)
05:44:18 <Aetherspawn> [not by choice]
05:45:19 <ion> Well… there seems to be a binary tarball for Windows™ as well. As for whether it and cabal are as easy to install on it, i have no idea.
05:45:54 <ion> But if you don’t mind waiting a bit, what quchen said.
05:48:27 <t7> how do i install haskell platform on gnu/hurd?
05:49:01 <Botje> download tarball, unpack tarball, hack
05:49:14 <Botje> (if you're on debian gnu/hurd it's a bit easier, of course)
05:50:11 <ion> I hear this year should be the year of GNU/Hurd on the desktop.
05:51:04 * hackagebot reenact 0.7.4 - A reimplementation of the Reactive library.  http://hackage.haskell.org/package/reenact-0.7.4 (HansHoglund)
05:51:07 <Botje> I'm holding out for the first GNU/Hurd tablet.
05:52:12 <magicman> weebl: Years ago, so I lost most of the details, but yes. I took a course that involved doing that in 2010.
05:54:17 <t7> Botje: lel
05:54:37 <t7> you made me laugh out loud at work...
05:57:35 <quchen> ion: Alright, I did it! Since I used my Github (and not Gist) repo on the mailing list, I've decided to make the articles repo contain the full thing. Comments can still be sent by mail or on IRC.
05:57:39 <weebl> magicman: where did you take that course
05:57:45 <ion> quchen: alright
05:57:48 <quchen> ion: https://github.com/quchen/articles/blob/master/applicative_monad.md
05:57:50 <quchen> Should work now :-)
05:59:38 <magicman> weebl: Utrecht University. Course was taught by Jurriaan Hage.
05:59:45 <weebl> i'm taking that course now
05:59:54 <weebl> same lecturer still
06:00:02 <magicman> *nod*
06:00:15 <weebl> did you take it as part of the programming technology track
06:01:01 <weebl> magicman: did you analyse the while language or did you take a "real" language?
06:01:04 <magicman> If that's the current equivalent of what used to be called "Software Technology", then sure. They revamped the whole CS master system in the last few years.
06:01:04 * hackagebot reenact 0.7.5 - A reimplementation of the Reactive library.  http://hackage.haskell.org/package/reenact-0.7.5 (HansHoglund)
06:01:20 <magicman> I had an attempt at a type checker for PHP.
06:02:12 <quchen> magicman: is_int($foobar)? :-D
06:02:51 <weebl> lolol
06:02:56 <magicman> XD
06:03:03 <MasseR> Haha :D
06:03:16 <MasseR> quchen: To be honest function foo(Foobar $x) works
06:03:21 <weebl> magicman: "had an attemept" i.e. did not finish it?
06:03:31 <MasseR> Altough you can't 'typecheck' elementary types
06:04:11 <magicman> Eh, it was finished, but it was a *really* restricted version of PHP. Like not dealing with objects.
06:04:13 <quchen> MasseR: Type hints are relatively new. Also they're a sorry excuse for a type system.
06:04:34 <magicman> In the end, it might as well've been While :p
06:04:46 <Twey> But type hints are useless because a) they're not statically checked, b) they don't support primitive types, and c) there are no type functions
06:05:05 <quchen> No type functions? Use eval!
06:05:35 <Twey> I'm… not sure how eval() even could be used in lieu of type functions :þ
06:05:39 <MasseR> Twey: No arguments here :/
06:05:55 <MasseR> No wait, why am I sad? I'm no longer coding php \o/
06:05:59 <Twey> Haha
06:06:35 <Twey> It looks like I might get a Python job this summer, which means the first summer in three years not spent coding PHP on some gods-awful framework \o/
06:06:52 <magicman> Sweet!
06:07:18 <MasseR> Twey: I hope you do. No-one deserves to write php
06:07:27 <MasseR> I'm a java (and xml) coder now mostly
06:08:10 <Twey> Writing XML isn't a whole lot better :þ
06:08:30 <Twey> I've never understood why people throw away Java's perfectly decent type-system to write XML instead
06:08:38 <quchen> Maybe we should take this to #haskell-blah
06:09:39 <marr> best choice for benchmarking is criterion ?
06:10:24 <quchen> marr: "best" is relative. Using GHC's profiling feature is often enough.
06:11:04 * hackagebot language-c-quote 0.7.2 - C/CUDA/OpenCL/Objective-C quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.7.2 (GeoffreyMainland)
06:14:17 <t7> Twey: yey. im doing c# asp.net of lord
06:14:24 <t7> oh*
06:33:54 <ion> quchen: I wonder where adding liftA2 to the Applicative class would be on the idiotic–sane scale? I wrote definitions of some Applicatives in terms of liftA2 for myself, they (unsurprisingly) seem to be almost identical in general shape to the definitions in terms of (<*>). I suppose someone might like to implement an Applicative instance with liftA2, but there’s no clear win. IIRC shachaf has mentioned
06:33:56 <ion> that teaching about Applicative to a newbie might be more understandable in terms of liftA2 since it’s a more obvious extension from fmap. https://gist.github.com/ion1/5636082
06:34:32 <illissius> I think it would be sane
06:35:48 <illissius> liftA2, (<*>), and dunnowhattocallthis :: (f a, f b) -> f (a, b) can all be implemented in terms of each other
06:35:59 <quchen> ion: Can you give an implementation of <*> using liftA2?
06:36:08 <ion> @type liftA2 id
06:36:11 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
06:36:13 <illissius> you can
06:36:19 <quchen> Oh. Well that was easy.
06:36:50 <quchen> ion: I'm not sure about this though, I think this might lead a little too far away from the proposal
06:36:56 <ion> true
06:37:12 <ion> One step at a time. :-)
06:37:20 <quchen> ion: I would file that under the same section as removing fail
06:37:34 <quchen> Is arguably a good thing, but doesn't go hand in hand with the proposal
06:38:04 <ion> Conceptually i would file that under the same section as adding join to Monad, but i agree it might not be worth bloating the proposal with this.
06:38:29 <quchen> ion: Well, join is not part of Monad because it relies on fmap
06:38:41 <quchen> If every Monad has fmap, then adding join seems very natural to me
06:38:50 <quchen> But I see your point
06:40:23 <quchen> Learning Applicative was much weirder for me than Monad
06:40:29 <quchen> (Presumably because Monad has do)
06:40:44 <byorgey> ion: I motivate Applicative by trying to implement liftA2 using only Functor and seeing where it falls down.
06:41:01 <byorgey> when I teach it I mean.
06:41:07 <ion> aye
06:41:32 <byorgey> I am not sure whether that means I would be for or against adding liftA2 to Applicative.
06:41:32 <quchen> byorgey: Where does it fall down with that approach?
06:41:40 <ion> Teaching Monad in the same way works, too. It’s easy to reach the position where you just need a join.
06:42:00 <byorgey> quchen: you can get something of type  f (a -> b), and something of type  f a, and you need to make an  f b  =)
06:42:04 <quchen> ion: Especially for the beginner monads (List, Maybe) I find join to be much clearer
06:42:22 <byorgey> quchen: i.e. you need precisely (<*>) to make it work out.
06:43:02 <quchen> byorgey: Hm, well that's just looking at the types.
06:43:12 <byorgey> quchen: what else is there to look at?
06:43:45 <quchen> I thought you had something similar to the Applicative-to-Monad transition in mind: >>= takes m a and (a -> m b), which you can use to make a m (m b).
06:44:00 <quchen> This then shows nicely that you need join :: m (m b) -> m b to make the whole thing work.
06:44:28 <quchen> (And it's fairly obvious that you can't make "join" with Applicative.)
06:44:47 <quchen> In the transition from Functor to Applicative, can you make a similar argument?
06:45:22 <quchen> Like "you can compose that like this, but then there's this one step that won't work with only Functor, you need more"
06:46:16 <byorgey> quchen: yes, that's exactly what I was talking about
06:46:30 <ion> State: join ssa = State (uncurry runState . runState ssa)
06:46:45 <quchen> ion: For State I would suggest >>=.
06:47:16 <byorgey> quchen: if you try to implement something with the type of liftA2 using only Functor, it shows precisely that you need  f (a -> b) -> f a -> f b  to make it work.
06:47:24 <quchen> byorgey: Hm. Well, when you've got "f (a -> b)" and "f a", I don't see how you can crystallize out the breaking point.
06:47:53 <quchen> byorgey: When I try doing it, it just won't work at all. I don't reach a point where I see "oh, I need *this* additional structure".
06:48:35 <byorgey> quchen: well, it seems obvious that you can't do anything with  f (a -> b)  and  f a  using only Functor.
06:48:48 <byorgey> fmap requires a function as an argument, and you don't have any functions.
06:48:56 <quchen> Fair point.
06:49:14 <byorgey> or rather, you do have a function, but you already used it with fmap, and using it again clearly doesn't help.
06:49:58 <byorgey> and it's quite tantalizing because it feels kind of like you have an  (a -> b)  and an  a  and you need a  b,  which would just be function application
06:50:06 <byorgey> except everything is wrapped up inside f.
06:50:16 <quchen> Oh, so you start off with  (a -> b -> c) -> f a -> f b -> f c. You can then use fmap to make this to a  f (b -> c) -> f b -> f c, at which point you run out of functions to use with fmap.
06:50:21 <byorgey> right.
06:50:26 <Clint> AfC: there was a theory that hOpenPGP would merge with openpgp but that only got so far
06:50:27 <quchen> Well, now that I wrote this down it's very obvious.
06:50:31 <byorgey> =)
06:50:31 <quchen> Should've done that earlier. :-9
06:50:34 <byorgey> hehe
06:50:45 <Aetherspawn> I think I failed at using the ghc-devs mailing list
06:50:46 <Aetherspawn> <_<
06:50:48 <Aetherspawn> Oh well.
06:50:50 <quchen> ..?
06:51:00 <Clint> AfC: conduit is necessary for the way i'm handling keyrings (which is not particularly a good way)
06:51:03 <Aetherspawn> I may have quoted the mailing list summary
06:51:06 <Aetherspawn> by accident.
06:51:11 <quchen> Oh, that was you
06:51:15 <Aetherspawn> LOL <_<
06:51:46 <Aetherspawn> But yeah, throw away my message because it was crappy
06:52:06 <Aetherspawn> Someone should look into a withSocketsDo warning though
06:52:13 <Aetherspawn> if you're going to add in other language warnings
06:52:54 <quchen> Aetherspawn: The point of these warnings is to ease language transitions. A withSocketsDo warning on the other hand would be equivalent to hardcoding it into the compiler to add that function automatically.
06:53:10 <Aetherspawn> Ah.
06:53:10 <dmwit> :t Data.Traversable.sequenceA
06:53:12 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
06:53:42 <dmwit> quchen: See, you just need Traversable so you can turn your f (a -> b) into an a -> f b...
06:53:45 <dmwit> ;-)
06:54:03 <dmwit> (Does Traversable therefore imply Applicative?)
06:54:18 <quchen> dmwit: Cool! And since I can derive Traversable from any Functor, then wait no.
06:54:42 <dmwit> Oh, that actually is even worse because then you need join. =P
06:54:43 <merijn> @hoogle Eq a => a -> [a] -> [[a]]
06:54:44 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
06:54:44 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
06:54:44 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
06:54:55 <merijn> @hoogle Eq a => [a] -> a -> [[a]]
06:54:56 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
06:54:56 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
06:54:56 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
06:55:00 <merijn> aww
06:55:00 <ion> All functions in the Traversable class have either an Applicative or a Monad constraint, don’t they?
06:55:11 <dmwit> quchen: Well, I guess the question was "how much more power than Functor do you need" and I was trying to point out that "Applicative" is just one answer. But I was wrong anyway.
06:55:14 <quchen> dmwit: And I'm hesitant answering your question about whether Traversable => Applicative.
06:55:21 <dmwit> It doesn't.
06:55:26 <quchen> Oh.
06:55:30 <quchen> Well then it was a trick question.
06:55:31 <merijn> Applicative => Traversable, I think?
06:55:54 <quchen> merijn: Yes, but the question was whether Traversable implies Applicative.
06:56:03 <quchen> (I shouldn't have used "=>" there)
06:56:29 <byorgey> merijn: no, I don't think so
06:56:59 <dmwit> ion: sequenceA doesn't...
06:57:10 <byorgey> e.g. consider  (->) Integer
06:57:17 <byorgey> it is Applicative but not Traversable
06:57:31 <ion> @type sequenceA
06:57:32 <lambdabot>     Not in scope: `sequenceA'
06:57:32 <lambdabot>     Perhaps you meant one of these:
06:57:33 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
06:57:35 <ion> @type Data.Traversable.sequenceA
06:57:37 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
06:57:44 <merijn> byorgey: I meant that in an "class Applicative f => Traversable f" way
06:57:49 <quchen> That reminds me of that I don't understand Traversable/Foldable much. :-(
06:57:53 <dmwit> (The Applicative constraint is on the other type constructor.)
06:58:20 <byorgey> merijn: oh. yes, interpreting those implications is tricky. =)
06:58:49 <byorgey> merijn: but actually, that isn't true
06:59:00 <byorgey> it's   Functor f, Foldable f => Traversable f
06:59:41 <byorgey> I don't think you can implement Applicative in terms of Traversable
06:59:50 <byorgey> though you can implement Functor and Foldable
06:59:52 <merijn> bah
07:00:43 <byorgey> (,) e   is  Traversable but not Applicative
07:00:48 <byorgey> (not without  Monoid e)
07:01:58 <merijn> bah, there's no way to split a list at all elements x? i.e. lines but with a specific separator?
07:02:16 <quchen> merijn: Data.List.Split
07:02:20 <byorgey> merijn: see Data.List.Split from the split package
07:02:42 <quchen> :t splitOn
07:02:44 <lambdabot> Eq a => [a] -> [a] -> [[a]]
07:02:49 <byorgey> > linesBy (=='x') "merijnxbyorgeyxquchenx"
07:02:51 <lambdabot>   ["merijn","byorgey","quchen"]
07:03:03 <quchen> splitOn "x" "helloxworld"
07:03:09 <quchen> > splitOn "x" "helloxworld"
07:03:11 <lambdabot>   ["hello","world"]
07:03:12 <byorgey> splitOn works too, they have slightly different semantics
07:03:15 <byorgey> see the documentation for details
07:03:28 <merijn> byorgey: \o/
07:08:53 <AfC> Clint: I see
07:09:20 <ion> quchen: In “Outline of the new code”, MonadPlus is typoed as MonadZero.
07:09:32 <ion> quchen: And there is no definition of Alternative.
07:09:32 <AfC> Clint: well, if you ever have a reason to factor that part out, then I'd encourage you!
07:10:13 <Clint> AfC: do you have a use case in mind?
07:11:08 <quchen> ion: Alternative won't change.
07:11:45 <ion> quchen: Neither does Functor, but it’s included.
07:11:55 <ion> Ditto for Applicative
07:11:56 <quchen> That MonadZero typo is starting to annoy me. Made it > 10 times in the last days.
07:12:34 <quchen> Hm. So you think I should add Alternative?
07:13:08 <ion> Either that, or remove the definitions that don’t change just to be consistent. In either case, perhaps mention the ones that don’t change explicitly.
07:13:18 <ion> near the code for the ones that do
07:14:14 <AfC> Clint: yeah; I'd be happier using GPG keys for the asymmetric crypto between a set of autonomous agents than something centralized; the updates being transmitted are not necessarily going to go through a hierarchical path to get back to a point where they need to be validated. I know & trust GPG so would rather use it than a CA based cert system. But admittedly that's not a problem I'm going to have for a little while yet.
07:16:27 <quchen> ion: Updated.
07:16:28 <Clint> AfC: ok, you may want to use singpolyma's openpgp package; he wants to keep it Haskell98 with no extensions and minimal dependencies
07:17:01 <ion> quchen: Alright, looks good.
07:17:04 <pxqr> i just thinking is (x `div` 2) optimized to shiftL/shiftR depending on platform? div might raise error, so its result is lifted. is it problem for optimizer?
07:17:07 <quchen> ion: Actually, why should MonadPlus have a Monad constraint in the first place?
07:17:30 <ion> quchen: So a Monad constraint is implied by the MonadPlus constraint.
07:17:47 <quchen> ion: ...
07:17:56 <dmwit> quchen: Why should Monad have an Applicative constraint?
07:18:02 <ion> Isn’t that its only function nowadays? :-P
07:18:04 <quchen> dmwit: MonadPlus.
07:18:16 <dmwit> quchen: I am modifying the question. Pray I don't modify it any further.
07:18:54 <quchen> dmwit: Oh. Well, Monad should have an Applicative constraint because every Monad is also an Applicative (and a little more). MonadPlus on the other hand is the same as Alternative.
07:19:15 <dmwit> ?src Alternative
07:19:15 <lambdabot> class Applicative f => Alternative f where
07:19:15 <lambdabot>     empty :: f a
07:19:15 <lambdabot>     (<|>) :: f a -> f a -> f a
07:19:22 <AfC> Clint: just flipped through the hackage pages there. It seems you two are relatively close in implementation terms.
07:19:23 <ion> myfoo :: (Monad f, Alternative f) => … is conceptually equivalent to myfoo :: MonadPlus f => …
07:19:49 <ion> Since we can’t just remove MonadPlus, it’ll have to exist with those semantics, i guess.
07:20:02 <dmwit> quchen: Why can't we say that every MonadPlus is a Monad (and a little more)?
07:20:16 <geekosaur> we do?
07:20:31 <Clint> AfC: there's been some cross-pollination
07:20:47 <quchen> dmwit: Hm. I would find Alternative+Monad nicer her..........oh I see.
07:21:03 <geekosaur> (now if you ask why we don't say that MonadPlus is Alternative plus a little more...)
07:21:17 <dmwit> geekosaur: read scrollback =)
07:21:22 <quchen> I am convinced.
07:22:03 <geekosaur> I'm trying to understand your comment [23 10:19] <dmwit> quchen: Why can't we say that every MonadPlus is a Monad (and a little more)?
07:22:06 <geekosaur> since, well, it *is*
07:22:42 <quchen> geekosaur: I basically thought that MonadPlus = Alternative, and completely forgot about the fact that MonadPlus also implies having >>= at hand.
07:23:06 <dmwit> geekosaur: quchen was proposing removing the Monad superclass of MonadPlus
07:23:10 <AfC> The proliferation of crypto libraries in Haskell is frustrating - you look for one thing, try to glue it to another, and nothing works together
07:23:24 <geekosaur> oh
07:23:27 <dmwit> geekosaur: And I was using his own argument for the Applicative superclass of Monad against him.
07:23:28 <quchen> Now I see MonadPlus as a short way of writing "Alternative, Monad".
07:23:29 <geekosaur> um, that would be. weird.
07:23:40 <Kinnison> AfC: Mmm :-(
07:23:53 <geekosaur> (seeing as it has Monad in the name...)
07:24:14 <quchen> geekosaur: Well, that wold be an odd name, yes, but names are arbitrary anyway
07:24:37 <quchen> geekosaur: Also, we can't complain about bad names until we rename nub
07:24:39 <quchen> :-D
07:25:23 <t7> @hoogle A a b c -> a -> c
07:25:24 <lambdabot> Did you mean: A -> a -> c
07:25:24 <lambdabot> No results found
07:25:43 <t7> @hoogle A a c -> a -> c
07:25:45 <lambdabot> Did you mean: A -> a -> c
07:25:45 <lambdabot> Data.Array.IArray (!) :: (IArray a e, Ix i) => a i e -> i -> e
07:25:45 <lambdabot> Data.Graph.Inductive.Graph deg :: Graph gr => gr a b -> Node -> Int
07:25:51 <geekosaur> I have tno problem with nub, but then I knew the word well before I discovered Haskell
07:26:23 <quchen> It's a word? Oh
07:27:24 <geekosaur> has somewhat fallen out of common usage but you can still find the occasional "the nub of the matter..." phrasing
07:27:28 <applicative_> the nub of something is, say, the essence of it, the main thing, etc
07:27:37 <piezo> It is possible to lift "atomically" to ResourceT STM a -> ResourceT IO a ?
07:27:49 <AfC> (context for that last quip was seeing http://hackage.haskell.org/package/openpgp-crypto-api then http://hackage.haskell.org/package/openpgp-Crypto one each for two of the different crypto stacks floating around)
07:27:56 <piezo> I'm still new to monad transformers
07:28:25 <applicative_> @type atomically
07:28:27 <lambdabot> Not in scope: `atomically'
07:28:30 <applicative_> bah
07:28:56 <dmwit> Depends on what operations ResourceT provides.
07:29:04 <quchen> applicative_: atomically :: STM a -> IO a
07:29:08 <applicative_> rigt
07:29:14 <applicative_> right, even
07:29:15 <dmwit> I don't think the standard MonadTrans class provides lifting of monad homomorphisms, but some other class might and ResourceT might be an instance of it.
07:29:38 <dmwit> It really ought to be possible in principle for any true monad transformer.
07:29:45 <applicative_> you should be able to liftM atomically resourcetstmthing
07:30:04 <piezo> ok so it depends on the transformer
07:30:20 <dmwit> applicative_: That will give you STM a -> ResourceT IO a, a different operation.
07:30:33 <dmwit> If that's enough, it's very easy to do, though.
07:30:45 <piezo> I see
07:31:03 <dmwit> :t lift . atomically
07:31:12 <lambdabot> Not in scope: `atomically'
07:31:49 <piezo> does "t m a -> (m a -> t n a) -> t n a" exist ?
07:32:16 <applicative_> dmwit yes, still thinking
07:32:27 <piezo> or make any sense ?
07:32:34 <applicative_> :t lift . listToMaybe
07:32:37 <lambdabot> MonadTrans t => [a] -> t Maybe a
07:33:21 <dmwit> There should be a "liftH :: (forall a. m a -> n a) -> (t m a -> t n a)" somewhere in a class.
07:33:31 <Pranz> :t listToMaybe
07:33:33 <lambdabot> [a] -> Maybe a
07:33:42 <dmwit> ...which would give you liftH atomically directly.
07:34:14 <dmwit> Of course, you would have to instantiate this class for ResourceT. =)
07:36:00 <piezo> ok, thanks
07:36:19 <piezo> it seams bit complicated :-(
07:36:39 <quchen> :t atomically
07:36:41 <lambdabot> stm a -> IO a
07:36:42 <quchen> :-D
07:37:23 <dmwit> > atomically "nowai"
07:37:25 <lambdabot>   Not in scope: `atomically'
07:37:50 <quchen> > atomically "nowai"
07:37:52 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO GHC.Types.Char))
07:37:52 <lambdabot>    arising fr...
07:37:55 <quchen> I updated it.
07:37:59 <quchen> :t atomically
07:37:59 <dmwit> > atomically "nowai" `seq` "nowai"
07:38:01 <lambdabot> _STM a -> IO a
07:38:02 <lambdabot>   "*Exception: Prelude.undefined
07:38:02 <applicative_> oh this ResourceT has an MFunctor instance
07:38:05 <quchen> Now with capitals! :-)
07:38:07 <dmwit> Yeah, I thought so.
07:38:39 <applicative_>  :t hoist atomically
07:38:40 <applicative_> hoist atomically :: MFunctor t => t STM b -> t IO b
07:39:00 <dmwit> See! I knew liftH had to be in a class somewhere. =)
07:39:06 <dmwit> I just got the name wrong.
07:39:08 <merijn> Is there a quick and easy function for taking seconds (Integer) and turning them into a hours/minutes/seconds type thing?
07:39:23 <dmwit> merijn: fromInteger
07:39:24 <dmwit> (seriously)
07:39:25 <piezo> oh thank you :)
07:39:39 <merijn> dmwit: Yes, but which type?
07:39:49 <applicative_> piezo: you just import Control.Monad.Morph I guess
07:40:01 <dmwit> merijn: DiffTime, I would assume.
07:40:32 <dmwit> hm
07:40:40 <dmwit> It's not that easy to retrieve the appropriate values.
07:40:42 <applicative_> somehow I was thinking mmorph would be outside the conduit universe
07:40:42 <dmwit> Let's see...
07:40:52 <merijn> Oh "secondsToDiffTime :: Integer -> DiffTime"
07:41:14 <dmwit> merijn: (Yes, but also instance Num DiffTime, so fromInteger really is available.)
07:42:10 <dmwit> merijn: Maybe that + formatTime "%T"...
07:42:14 <dmwit> dunno for sure what the best way is
07:44:18 <dmwit> merijn: I'm almost tempted to say this is more work than just using divMod 60. =P
07:54:32 <merijn> Apparently I want "System.Time.Utils (renderSecs)" but I dunno where that is :(
07:55:30 <mauke> MissingH
07:55:37 <mauke> @hackage MissingH
07:55:37 <lambdabot> http://hackage.haskell.org/package/MissingH
07:56:06 * hackagebot snaplet-postgresql-simple 0.4 - postgresql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-postgresql-simple-0.4 (DougBeardsley)
08:01:53 <merijn> mauke: Thanks :)
08:06:52 <yitz> merijn: timeToTimeOfDay
08:07:29 <dmwit> yitz: But how do you get the hours, minutes, and seconds out afterwards?
08:07:34 <yitz> merijn: but it only works for up to 24 hrs
08:07:35 <dmwit> ...wait
08:07:37 <dmwit> I'm an idiot.
08:07:53 <dmwit> yitz++
08:09:21 <yitz> merijn: so if you need more than 24 hrs., do divMod 3600 and just feed the remainder into timeToTimeOfDay
08:10:50 <Kinnison> Could someone remind me what the ~ means in something like: ~(a, b) <- something
08:11:20 <dmwit> http://www.haskell.org/haskellwiki/Lazy_pattern_match
08:11:55 <Kinnison> that's the badger, ta
08:12:15 <Kinnison> google doesn't do well with ~ :-)
08:12:21 <dmwit> indeed
08:12:25 <dmwit> Some things are just hard to search for.
08:13:42 <geekosaur> symbolhound.com?
08:15:28 <yitz> geekosaur: hey, that's cool. third result there for "haskell ~" is this: http://stackoverflow.com/questions/2263541/what-does-mean-in-haskell
08:15:40 <rootzlevel> searching google for "haskell tilde" does work, too
08:16:54 <yitz> rootzlevel: there happen to be pages where people literally wrote the name of the symbol.
08:17:24 <yitz> rootzlevel: you won't always be that lucky, and google doesn't seem to be smart enough to make the obvious transformation
08:18:03 <rootzlevel> sure. but in this case it worked ;)
08:24:27 <Sculptor> yo
08:25:18 <dmwit> w3rd
08:29:46 <fruitFly> I'm trying to set up a dev environment on my android phone; I've downloaded vim touch... is there any way to compile using vim on android?
08:30:31 <fruitFly> can a plugin help me? or at least set up a reply inside vim?
08:33:25 <Twey> fruitFly: Have you managed to set up GHC on Android?  o.@
08:36:07 * hackagebot git-annex 4.20130521.1 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20130521.1 (JoeyHess)
08:49:50 <Taneb> Hmm... where would be the correct channel to discuss pipes?
08:50:04 <`^_^v> #plumbing
08:50:09 <Taneb> :P
08:51:01 <Reite> I hear so much about these pipes
08:51:05 <Reite> and something called Wire
08:51:18 <byorgey> NetWire?
08:51:38 <Reite> I dont know, Ive seen people talking about Wire in here on several ocations
08:51:54 <Taneb> I'm fairly sure pipes is nothing to do with Wire
08:52:03 <Reite> I just assumed it something way over my head
08:53:22 <Taneb> Reite, the thing about Haskell is, there will always be things above you, but you are soaring right from the start
08:53:44 <Taneb> Even SPJ finds some things in Haskell confusing
08:53:57 <Taneb> And I don't believe Oleg exists.
08:54:14 <Taneb> So Oleg doesn't count.
08:54:37 <Reite> Thats nice to hear :)
08:54:40 <Adeon> my next haskell program will be written using hypermonadic lasers
08:55:05 <Reite> Yeah I wonder how many made up words haskell people could get away with
08:55:49 <Reite> "Applicative functors" come on
08:56:08 <Reite> Im sure it makes sense if you know maths though :)
08:56:54 <k00mi_> no, Applicatives are haskell-only
08:56:58 <sleepynate> "pointer" and "stack" didn't mean much to me either until i learned to program
08:57:04 <zerokarmaleft> Reite: zygohistomorphic prepromorphisms takes the cake for me so far :D
08:57:11 <sleepynate> so, just as well that i learn "functor" and "applicative"
08:57:12 <merijn> hmm, is there a show that renders Fractionals without the scientific notation?
08:57:44 <dmwit> Applicatives are not Haskell-only, though they have a much less prominent place in mathematics than they do in everyday programming.
08:58:01 <dmwit> merijn: import Numeric, use show{E,F,G}Float
08:58:04 <k00mi_> sure they exist
08:58:06 <dmwit> merijn: ...or printf =)
08:59:13 <dmwit> %e, %f, and %g ship out to showEFGFloat
08:59:17 <glguy> > showFFloat Nothing (1e100) ""
08:59:19 <lambdabot>   "10000000000000000000000000000000000000000000000000000000000000000000000000...
09:03:42 <merijn> dmwit: Thanks, that's more useful :)
09:11:12 <drewr> anybody know of a good hs package similar to this? http://search.cpan.org/~bloonix/Sys-Statistics-Linux-0.66/lib/Sys/Statistics/Linux.pm
09:15:38 <hidenori> i'm wondering why `lookup` is not `lookUp`
09:16:33 <Taneb> hidenori, I think that predates Haskell
09:16:34 <Lethalman> hidenori, you don't want to waste time pressing Shift, right?
09:16:43 <dmwit> lookup is one word.
09:16:48 <dmwit> ?wn lookup
09:16:49 <lambdabot> *** "lookup" wn "WordNet (r) 3.0 (2006)"
09:16:49 <lambdabot> lookup
09:16:49 <lambdabot>     n 1: an operation that determines whether one or more of a set
09:16:49 <lambdabot>          of items has a specified property; "they wrote a program to
09:16:49 <lambdabot>          do a table lookup" [syn: {search}, {lookup}]
09:16:53 <otters> anybody using GHC on debian jessie?
09:17:13 <otters> or more accurately, not using
09:17:51 <dmwit> I use Debian Jessie, but I also manage my own Haskell stuff.
09:17:54 <hidenori> but a lot of functions have upper case letter (zipWith, fromList maximumBy)
09:18:05 <dmwit> hidenori: Those are two words each.
09:18:09 <dmwit> lookup is one word.
09:18:42 <hidenori> dwit: Ohhhhh i see thanks! it makes perfect sense
09:18:53 <hidenori> dmwit sorry ><
09:19:57 <Philonous> Is there a type class for values that have a canonical text representation (e.g. email addresses, URLs )
09:20:03 <Philonous> ?
09:21:00 <otters> dmwit: Have you hit the "eventfd: function not implemented" thing yet?
09:21:17 <dmwit> no
09:21:20 <otters> nice
09:21:40 <dmwit> Philonous: I don't know of one.
09:26:28 <chrisdotcode_> hey guys, what's wrong with yesod's site? a little while ago it wasn't working at all, and now the css and js files are 404ing. is it my browser?
09:27:20 <Taneb> chrisdotcode_, looks fine to me?
09:27:51 <Twey> chrisdotcode_: WFM
09:28:46 <chrisdotcode_> Twey, Taneb: heh, I"m getting all sorts of sporadic results: from working pages just now, to the root file structure, to no css files on pages...
09:28:59 <Taneb> That sounds weird
09:28:59 <Twey> That's odd
09:29:16 <Twey> Catch what you can & send it to Snoyman?
09:29:28 <user123abc> I have questions about getopt and flag arguments
09:29:29 <user123abc> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html#t:ArgDescr
09:29:48 <user123abc> what are the string arguments to the ArgDescr constructors supposed to be?
09:30:16 <user123abc> and does getopt not support putting whitespace between flags and their arguments on the command line?
09:30:46 <user123abc> s/flag/option
09:30:53 <dmwit> getopt supports putting whitespace between flags and their arguments.
09:32:21 <user123abc> here's what I've got
09:32:23 <user123abc> http://hpaste.org/88417
09:32:24 <dmwit> The String arguments to ReqArg and OptArg are human-readable descriptions of what kinds of things can go in that argument slot.
09:32:42 <user123abc> ah, thanks
09:32:51 <Twey> user123abc: See the example on that page: Option ['o']     ["output"]  (OptArg outp "FILE")  "output FILE"
09:33:01 <dmwit> If you are calling fromJust, then you probably want a ReqArg, not an OptArg.
09:33:09 <user123abc> if I take that code and pass "-f 1", I get a Nothing out of my Maybe String
09:33:37 <user123abc> dmwit, good point - I was just messing around there
09:33:45 <beaky> hello
09:34:24 <Twey> beaky: Hi
09:34:31 <user123abc> oh, I suppose that it's putting the 1 into the list of nonoptions
09:34:48 <user123abc> since it's an optarg and it's ambiguous
09:37:48 <mm_freak> Philonous: Serializable?
09:38:04 <mm_freak> well, if ByteString counts as String
09:43:36 <beaky> I am writing a game of hangman in haskell :D
09:44:04 <monochrom> ByteString : String :: jelly fish : fish
09:44:06 <beaky> but I'm not sure how to think about doing it
09:46:26 <ziman> :: guinea pig : pig ? :)
09:46:38 <monochrom> hehe
09:47:29 <Twey> beaky: Pick a random word from a list of words; output censored word; give the user the option of picking a letter or making a guess; if guess, check against actual word; if letter, check if letter is in word and if so remove censor from letter; repeat
09:48:31 <beaky> ah that's how I did it in C++ :D I used a vector of char/bool pairs to represent the censored word
09:48:37 <Clint> you left out the hanging
09:48:53 <beaky> yeah and I also represented the hangman according to the number of incorrect guesses
09:49:06 <beaky> but now I want to do it the purely-functional way :D
09:50:12 <benj_> state monad!
09:50:28 <Twey> beaky: I'd use two strings, one to represent censorship and one to represent the word
09:50:37 <Twey> If you wanted to get fancy the former could be a Set Char
09:50:40 <user123abc> so it does seem like getopt will allow spaces between options and option arguments, but only for required arguments
09:50:48 <Twey> user123abc: Seems reasonable
09:51:08 <user123abc> it looks like C's getopt does the same
09:52:44 <beaky> hangman in haskell would surely be fun :D
09:53:01 <beaky> and I'll finally learn how to use Data.Set and co
09:53:10 <mm_freak> beaky: data Hangman = Hangman String (Char -> Hangman)
09:53:21 <mm_freak> or…
09:53:27 <mm_freak> data Hangman = Hangman String (Char -> Maybe Hangman)
09:53:52 <beaky> Hangman is a monad? wow
09:53:56 <mm_freak> no
09:55:23 <mm_freak> beaky: the point is…  don't use Bool ;)
09:56:05 <beaky> ah why not?
09:56:22 <mm_freak> because Bool is evil
09:56:25 <beaky> I guess compared to C++, Haskell has better ways to reify the state of teh Hangman
09:56:27 <josephle> beaky: http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
09:56:37 <beaky> ah
09:56:57 <josephle> a bit theoretical, but it tells you why bools are bad
09:57:13 <mm_freak> beaky: your char/bool representation is /very/ powerful and contains very little semantic information
09:57:24 <beaky> right
09:57:36 <mm_freak> beaky: my representation is only as powerful as you want it to be…  it can play hangman, but not much else
09:58:07 <mm_freak> a value of type Hangman is a particular game state and a set of possible moves
09:58:31 <mm_freak> Hangman "h__ke__" (\guess -> …)
09:58:40 <josephle> mm_freak, so just decreasing the amount of possible programs of Hangman that can be written and will typecheck
09:59:12 <mm_freak> and writing a hangman game in terms of Hangman is sufficiently tricky that you will learn to write more idiomatic haskell =)
09:59:46 <josephle> sounds good to me :)
10:00:26 <beaky> maybe I should make a Hangman typeclass
10:00:32 <mm_freak> no!
10:00:39 <nooodl> mm_freak: why not use an actual Set Char instead of (Char -> ...)?
10:00:57 <mm_freak> nooodl: why do it?
10:01:52 <nooodl> well it does represent a set of characters. Set Char seems to make more sense to me
10:02:34 <nooodl> might also be easier to remove characters from? not sure
10:03:04 <mm_freak> nooodl: this is for a set of game rules…  if you use Set, you get a giant data structure that gets even larger as you increase the word length
10:04:10 <josephle> nooodl: technically you can just hide the set under (Char -> Maybe Hangman) if you really wanted a set
10:04:13 <nooodl> hmm. i think i'm just misunderstanding your use of (Char -> Maybe Hangman)
10:04:26 <acube> mm_freak: Is the String in your Hangman the censored string?
10:04:31 <mm_freak> nooodl: no, your understanding of that is fine
10:04:37 <mm_freak> acube: yeah
10:05:02 <acube> mm_freak: How do you implement guessing then? (Checking for the correct word directly)?
10:05:15 <nooodl> if you had (Hangman "h__ke__" f), (f 'a') would be (Just $ Hangman "ha_ke__" f') right?
10:05:45 <mm_freak> acube: good point
10:05:50 <josephle> nooodl: my next guess is 's'
10:06:12 <mm_freak> data Hangman = Solved String | Hangman String (Char -> Maybe Hangman)
10:06:51 <josephle> mm_freak, does this take into account the actual hangman?
10:07:11 <mm_freak> josephle: no, the actual hangman would be handled outside by counting Nothings
10:07:18 <mm_freak> but you can get it into Hangman as well
10:07:24 <josephle> true
10:07:39 <mm_freak> data Hangman = Solved Int Hangman | Hangman Int String (Char -> Hangman)
10:07:48 <mm_freak> (notice the Maybe is gone)
10:08:33 <josephle> mm_freak, but your previous datatype has less "bad" values so I'd go with that one
10:08:58 <acube> mm_freak: With that datastructure, it's still not possible to specify a guess directly (I.e. if i'd want to guess "haskell" with the String being "h_s_ell" directly, without saying a and then k)
10:09:11 <acube> Or am I missing something?
10:09:33 <mm_freak> acube: you can apply the function recursively for the missing characters, but adding another "full guess" function is also fine
10:10:04 <mm_freak> btw, s/Solved Int Hangman/Solved Int String/
10:10:55 <josephle> I'm kinda paranoid that (Hangman -1 "h_s_ell" f) is a valid value of Hangman
10:11:21 <mm_freak> josephle: that's why i didn't have the Int in the first representation
10:11:34 <mm_freak> i'd keep track of the hangman outside of that structure
10:12:07 <hcaulfield57> I'm having difficulty understanding the (.) and ($) operators. Could someone explain to me why "sum . map $ (+1) [1,2,3]" doesn't work?
10:12:09 <nooodl> clearly, data Nat = Z | S Nat, etc :)
10:12:10 <Twey> data Hangman = Solved [()] Hangman | Hangman [()] String (Char → Hangman) (String → Hangman)
10:12:25 <hrookie> not my original hpaste, but the same problem (http://hpaste.org/74503) -- when importing Control.Lens, I try to use makeLenses ''MyRecord, and I get told (by GHCI) that makeLenses ''MyRecord is a naked expression at top level. Insight is greatly appreciated!
10:12:27 <mm_freak> nooodl: that doesn't help, because Hangman 0 "x___" f is still invalid
10:12:34 <Twey> hcaulfield57: Because that parses as (sum . map) $ ((+ 1) [1, 2, 3])
10:13:00 <edwardk> hrookie: {-# LANGUAGE TemplateHaskell #-}
10:13:05 <Twey> hcaulfield57: (+ 1) [1, 2, 3] is [1, 2, 3] + 1, which is not valid
10:13:06 <hrookie> edwardk: thanks a million =)
10:13:31 <hrookie> they should allow hpaste comments so someone can just write it in and then people who come across it later don't bug people a second time >.>
10:13:32 <hcaulfield57> Twey: Isn't that what I want?
10:13:47 <Twey> hcaulfield57: What do you get if you add a list to an integer?
10:14:15 <Twey> hcaulfield57: You probably meant sum $ map (+ 1) [1, 2, 3], or, equivalently, sum . map (+ 1) $ [1, 2, 3]
10:14:18 <dmwit> hcaulfield57: Presumably you want sum ((map (+1)) [1,2,3]).
10:14:19 <nooodl> mm_freak: huh, is it? i thought we were counting the number of mistakes
10:15:06 <mm_freak> nooodl: in that case it's not, but you can still construct arbitrary game states…  just like boolean blindness there is also an "integer blindness" =)
10:15:20 <dmwit> I don't really feel like "x__" is better than ("xyz", [True, False, False]).
10:15:25 <Philonous> mm_freak:  Serialize is more for binary encodings. I mean specifically strings.
10:15:41 <dmwit> Knowing that "_" means "not guessed" is not better than knowing that False means "not guessed".
10:15:56 <mm_freak> dmwit: the String there is really just informative
10:16:01 <nooodl> oh right. Hangman 12345 "x___" f -- would be impossible because the game would've been over after something like 12 mistakes
10:16:09 * hackagebot taglib-api 0.1.1.0 - An FFI layer over TagLib's C bindings  http://hackage.haskell.org/package/taglib-api-0.1.1.0 (KyleCarter)
10:16:11 <mm_freak> dmwit: you would print it, but not compute with it
10:16:29 <dmwit> Sounds like String blindness to me.
10:17:16 <mm_freak> dmwit: what you really need is a sparse string type
10:17:17 <nooodl> anyway, i guess there's a Char blindness, too... "{.__-^\\_" wouldn't be a valid value for the string
10:17:19 <mm_freak> for example Map Int Char
10:18:02 <dmwit> I feel like (String, [Bool]) is a pretty darn good choice, given the facilities available.
10:18:33 <mm_freak> dmwit: the problem is that the String reveals the word
10:18:34 <nooodl> dmwit: what about [Just 'x', Nothing, Nothing]
10:18:42 <mm_freak> nooodl: yeah, that's a good one
10:18:46 <dmwit> mm_freak: You need to know the word to handle guesses correctly.
10:19:00 <mm_freak> dmwit: the guesses are handled by the Hangman itself
10:19:22 <mm_freak> data Hangman = Solved String | Hangman [Maybe Char] (Char -> Maybe Hangman)
10:19:26 <dmwit> Knowing the word in a closure is just as good as knowing the word as a list, as far as I'm concerned.
10:19:34 <dmwit> I hate your type. It's too complicated for the task at hand.
10:19:34 <n_b> Is there a vim+haskell getting-started guide anywhere? I've checked the wiki and not sure which of the given options would be best for a newcomer
10:19:52 <kennethmosquera> what is this (x:ys@(y:_)) ?
10:19:55 <mm_freak> dmwit: is it?  it gives rise to a short and elegant implementation
10:20:00 <dmwit> *especially* for beaky and other beginners.
10:20:17 <dmwit> mm_freak: No it doesn't. It just pushes the implementation into the construction of a value of type Hangman.
10:20:18 <josephle> n_b: since when was vim+ghci bad idea? :(
10:20:19 <mm_freak> kennethmosquera: a@(b:_) means that 'b' is the head and 'a' is the entire list
10:20:54 <n_b> josephle: I just spent a few minutes trying to figure out a compilation error caused by indendation, so even a better .hs syntax file would do me nicely for now
10:21:03 <mm_freak> dmwit: i don't understand
10:21:10 <liyang> There's also a@ ~(b:_)
10:21:36 <josephle> n_b, if that's your problem, then I feel your pain
10:21:40 <nooodl> kennethmosquera: in [[1,2],[3,4],[5,6]], x is [1,2], ys is [[3,4],[5,6]], y is [3,4]
10:21:45 <dmwit> mm_freak: Writing the function of type "String -> Hangman" becomes just as difficult as implementing the whole game in the traditional way.
10:21:56 <dmwit> mm_freak: Except that now you're trying to think with closures instead of concrete lists.
10:22:03 <mm_freak> dmwit: my goal is to construct a type that a) doesn't suffer from boolean blindness, b) doesn't allow cheating
10:22:09 <dmwit> Your goals suck.
10:22:17 <nooodl> cheating?
10:22:47 <n_b> josephle: So is the common answer to this issue "Use emacs" or "Learn exactly how things must be indented?"
10:23:11 <dmwit> n_b: Make your whitespace visible, and turn on copyindent and preserveindent.
10:23:15 <mm_freak> dmwit: i don't understand your problem, honestly…  but then haskell is a beautiful imperative language, so feel free to do it the traditional way ;)
10:23:18 <kennethmosquera> thnx
10:23:23 <josephle> n_b: I did the latter, but I'm sure there's better vim support somewhere
10:23:25 <user123abc> n_b the common answer to many questions is "use emacs"
10:23:26 <sclv_> i think mm_freak's type is perfectly cromulent
10:23:27 <user123abc> :)
10:23:28 <liyang> > let yes ~False = "okay" in yes True
10:23:30 <lambdabot>   "okay"
10:23:38 <Cale> n_b: Turn on whatever option you have in your editor to convert tabs to spaces, for one.
10:23:45 * dmwit sighs
10:23:51 <dmwit> Just know the rules.
10:23:54 <Cale> n_b: (in vim, it's expandtab)
10:24:30 <dmwit> n_b: I also like :set listchars=tab:>\ ,trail:#,extends:>
10:24:50 <Cale> and then, once you have that set up, the general rule to nicely laying things out is to make sure that siblings are aligned vertically, and anything which is part of something else needs to start in a deeper column.
10:24:51 <liyang> And if you already have tabs in the code, use :retab to convert them to whatever the current expandtabs setting says.
10:25:06 <josephle> I have a friend who wrote ML code with hard tabs. Oh the pain when reviewing his code.
10:25:07 <Cale> But the more specific rule is that there are four layout keywords
10:25:14 <Cale> "let", "of", "where", "do"
10:25:26 <hrookie> liyang: wait, :retab just does that? you mean i don't need to do my %s\\t/    /g trick? >.>
10:25:34 <Cale> the first non-whitespace character after one of these sets the column for the block of code
10:25:53 <Cale> and the first line which starts in a column shallower than that will close the block
10:25:57 <josephle> hrookie: we learn something new about vim every day >_>
10:26:12 <hrookie> josephle: you know they say emacs has a million commands, but i keep running into vim ones >.>
10:26:25 <Cale> Friends don't let friends use hard tabs.
10:26:26 <liyang> hrookie: nope, you don't.
10:26:48 <n_b> did not know about retab either. Should look into one of those "One vim command a day" calendars
10:26:51 <hrookie> honestly, if M-x package-install Evil and M-x package-install haskell-mode worked, i'd be using vim *in* emacs at the same time... but alas, it doesn't work, and i'm too lazy to fix it, so tmux, vim, and ghci it is :D
10:26:53 <liyang> I've been using vim for over 13 years and I'm still finding new things.
10:27:01 <dmwit> Friends don't let friends spread FUD about tabs.
10:27:10 <Twey> mm_freak: But you can always cheat if you have access to the constructor
10:27:34 <Cale> Don't listen to dmwit, he's one of the very few people who actually puts tabs in his code. It's possible to do that, but you'll just annoy yourself and others.
10:27:39 <Twey> iWin = Solved
10:28:08 <Cale> (On other matters, listen to him, but not on this :D)
10:28:33 <hrookie> tabs are the devil. i do not know why people still use them in code.
10:28:34 <dmwit> Tabs vs. spaces are an aesthetic choice, and you do not need to trust Cale. Make your own decision. Don't trust me, either.
10:28:44 <liyang> dmwit: with those listchars, you can't copypasta code from your terminal. Try these lines instead: highlight SpecialKey term=underline cterm=underline | set listchars=tab:\ \ ,trail:_,extends:+
10:28:58 <hrookie> any aesthetic choice you can achieve with tabs can be achieved with spaces
10:29:01 <Cale> I personally think that tabs should be considered a lexical error
10:29:03 <hrookie> however, the converse is not true.
10:29:05 <dmwit> liyang: I have no trouble copy-pasting from my terminal.
10:29:16 <dmwit> hrookie: Incorrect.
10:29:28 <int-e> dmwit: you'll have to agree though that "don't use tabs" is very simple rule, much simpler than the rules for using tabs correctly.
10:29:30 <Cale> Because they just lead to confusion and trouble, and having the compiler reject them would make sure that people got things straight from the outset.
10:29:34 <n_b> Tabs v. spaces is a great discussion I'd love to stay out of
10:29:38 <josephle> Cale: personally I think significant whitespace was a poor design decision
10:29:40 <liyang> dmwit: tabs are copiped as ">   "
10:29:45 <hrookie> dmwit: if you want to achieve whatever it is with tabs that you can with spaces, you'll have to mix tabs and spaces. that's bad juju and *everyone* knows it.
10:29:57 <Cale> josephle: I don't think so, it gets rid of a lot of syntactic noise.
10:29:59 <applicative_> oh has a tabs defender appeared
10:30:01 <dmwit> int-e: "things are indented more when the whitespace is a prefix of the other line" is a very simple rule that sums up how to use tabs correctly.
10:30:02 <applicative_> ?
10:30:04 <Cale> You just need to not use tabs.
10:30:08 <Twey> n_b: Note that the options you are choosing between are ‘no tabs’ or ‘smart tabs’, where you use tabs for indentation and spaces for alignment
10:30:09 <dmwit> liyang: I do not have that problem.
10:30:15 <liyang> I use tabs in non-Haskell files.
10:30:19 <Twey> n_b: ‘Tabs everywhere’ is not really an option for Haskell.
10:30:20 <liyang> Problem?
10:30:40 <hcaulfield57> Twey: Sorry I lagged out
10:30:44 <dmwit> hrookie: I mix tabs and spaces, and I like it.
10:31:02 <liyang> I mean, no one writes Makefiles anymore?
10:31:04 <applicative_> '\t' should be booted out of Char!
10:31:05 <Twey> hcaulfield57: No problem
10:31:11 <Twey> Haha
10:31:56 <dmwit> liyang: Perhaps you should look into the 'mouse' option.
10:31:59 <dmwit> :set mouse=a
10:32:08 <hcaulfield57> So isn't that what I want, something like (sum . map) ((+1) [1,2,3])
10:32:13 <n_b> So uh, the answer is basically just "Learn that 'let', 'of', 'where', 'do' have special layouts?"
10:32:24 <dmwit> n_b: correct
10:32:36 <n_b> and that Haskell error messages for parse failures compete with Clojure for non-utility?
10:32:41 <hrookie> dmwit: do you do this at work where you have multiple people collaborating on the same code with different IDE's, editors, operating systems, and preferences?
10:32:50 <dmwit> hcaulfield57: Presumably you will prefer ((map (+1)) [1,2,3]) to (map ((+1) [1,2,3])
10:32:56 <liyang> dmwit: I don't understand... you're using GUI vim?
10:33:01 <Twey> hcaulfield57: ((+ 1) [1, 2, 3]) means you're adding an integer to a list.  What do you think the result should be when you add an integer to a list?
10:33:06 <dmwit> liyang: I use both gvim and vim.
10:33:20 <Twey> Also known as [1, 2, 3] + 1
10:33:42 <dmwit> hrookie: I have not yet begun a project and had collaborators join afterwards. =)
10:33:46 <liyang> ah. I only use vim under screen so I can reattach to it from elsewhere. :-/
10:33:57 <hrookie> dmwit: have you ever had a real job >.>
10:34:04 <int-e> > fmap fmap fmap sum fmap (+1) [1,2,3]
10:34:04 <hcaulfield57> Twey: Nothing that makes no sense
10:34:05 <lambdabot>   9
10:34:13 <dmwit> hrookie: Read my sentence carefully. I have collaborated on many things.
10:34:16 <Cale> applicative_: I actually almost agree. I think it should have similar status to things like '\DC3' and stuff which people never use.
10:34:16 <liyang> int-e: not in public please.
10:34:22 <Twey> hcaulfield57: Right — that's why you get the type error
10:34:23 <dmwit> hrookie: But I have not *started* a project and had other people join in afterwards.
10:34:33 <dmwit> hrookie: If the project already exist, I use the existing whitespace style.
10:34:39 <dmwit> hrookie: Anything else would be a crime.
10:34:50 <Twey> hcaulfield57: Instead, what you wanted to do was call ‘map’ with the two arguments (+ 1) and [1, 2, 3]
10:34:51 <elliott> oh god
10:34:53 <elliott> are we doing this *again*?!
10:35:03 <edwardk> ?
10:35:08 <hrookie> dmwit: at least we can all agree on that. however, i do see how you have carefully avoided my own question :-P. there's a reason nobody joins your projects, it's tabs and spaces =D
10:35:13 <liyang> Internet argument time!
10:35:14 * elliott thought he spied a tabs/spaces discussion
10:35:19 <hrookie> OH NO, SOMEONE IS WRONG ON THE INTERNET
10:35:25 <dmwit> liyang: I just tested. This works fine in screen, too.
10:35:34 <hcaulfield57> Twey: I get that, I guess I'm just having trouble with what ($) does? It just takes the right function and applies it to the left, but at lowest precedence right?
10:35:52 <Cale> hcaulfield57: The function is on the left
10:35:56 <Cale> f $ x = f x
10:35:59 <hrookie> in unrelated news, i think that the current lens syntax is a barrier to haskell becoming popular
10:36:00 <liyang> dmwit: I'm confused how enabling the mouse would help me...
10:36:12 <dmwit> liyang: How are you copying and pasting?
10:36:16 <Twey> hcaulfield57: In Haskell, that's the same thing as calling map with the argument (+ 1) and then calling the resulting function with the argument [1, 2, 3], also known as (map (+ 1)) [1, 2, 3]
10:36:17 <hrookie> weird operators like ^. and .~
10:36:18 <Cale> hcaulfield57: The thing on the right of the $ needn't be a function
10:36:21 <dmwit> "+ and "* have never given me issues. For all other things, you select with a mouse first.
10:36:28 <hrookie> as if >>= and <=< weren't bad enough =D
10:36:36 <edwardk> hrookie: such things didn't even exist until this last year =P
10:36:40 <elliott> there are non-operator forms of those.
10:36:41 <sclv_> hrookie: that's insane because the 'current lens syntax' is something that was introduced by a relatively new library less than a year ago or so
10:36:44 <edwardk> hrookie: so its hardly a barrier to popularity
10:36:58 <hrookie> edwardk: xD
10:37:00 <josephle> hrookie: there's no permuation of characters as operators that's going to make everyone happy
10:37:12 <Cale> How many projects actually even use lenses yet?
10:37:12 <liyang> dmwit: shift-select-with-mouse (so gnome-terminal doesn't send mouse events to vim via screen), then ctrl+shift+c.
10:37:16 <hrookie> josephle: yes, but haskell's are notoriously not like anybody elses
10:37:23 <sclv_> Cale: only the best ones!
10:37:25 <Twey> hcaulfield57: The point of $ is to avoid brackets — it's kind of like wrapping the things on either side in brackets.  So sum . map $ (+ 1) [1, 2, 3] means (sum . map) ((+ 1) [1, 2, 3]) — i.e. call (+ 1) on [1, 2, 3], then call (sum . map) on the result
10:37:28 <sclv_> (none of mine :-P)
10:37:40 <edwardk> lens has 74 reverse dependencies right now
10:37:47 <dmwit> liyang: Well, there's your problem. Just use normal select with mouse, so gnome-terminal does send mouse events to vim.
10:37:49 <liyang> dmwit: I can't rely on $DISPLAY being correct or even set!
10:38:00 <dmwit> aha
10:38:02 <dmwit> Yes, okay.
10:38:11 <edwardk> and its not because i've written 74 libraries since lens ;)
10:38:12 <fryguybob> "Maybe before we ruch to adopt lens we should stop to consider the consequences of blithely giving this technology such a central position in our lives." -- xkcd
10:38:14 <hrookie> edwardk: 74 isn't bad. i think they'll probably stick around. i mean, with templates, it just takes the edge off editing large records.
10:38:17 <liyang> It's habitual now. :<
10:38:18 <josephle> Cale: I had one just for the sake of having lenses. I think I managed to shoehorn DPH in as well
10:38:37 <edwardk> hrookie: good to know ;)
10:38:39 <liyang> We use lens in production!
10:38:46 <hcaulfield57> Twey: functions are left associative, yes? Okay, well I'm kind of getting it. Thanks
10:39:20 <Twey> hcaulfield57: Right.  map (+ 1) [1, 2, 3] means (map (+ 1)) [1, 2, 3], where map (+ 1) is the function that maps (+ 1) over a list.
10:39:26 <dmwit> hrookie: (I'm exaggerating a tiny bit. Some people have submitted patches to some of my projects. These patches have been tab-correct, so far as I can tell.)
10:39:47 <Twey> hcaulfield57: That's why sum . map (+ 1) $ [1, 2, 3] is valid.
10:39:47 <dmwit> hrookie: (But they also weren't significant chunks of code, so it hardly counts.)
10:40:26 <edwardk> i can't say anything bad about dmwit's tab usage or i'll wind up sleeping on the floor when i visit ;)
10:40:41 <Twey> Hehe
10:40:49 <dmwit> Ah, well, you're safe then! You'll be sleeping on the floor anyway. =D
10:41:25 <hcaulfield57> Twey: Okay I didn't think you could have any arguments to (.) other than functions, doesn't that make it read like (sum . map (+1))
10:41:33 <hrookie> still dodging my question dmwit. that's okay though =)
10:41:48 <dmwit> Am I?
10:41:56 <Twey> hcaulfield57: Yep.  That's fine.  map (+ 1) is a function, and is an argument to . there.
10:41:57 <hrookie> dmwit: yep. =D
10:42:07 <dmwit> I'm not dodging it on purpose. What have I missed?
10:42:16 <fruitFly> I'm trying to set up a dev environment on android with vim touch? There's no way to do that right? can I at least get a repl with a plugin?
10:42:34 <hrookie> "have you ever had a real job where you had different people with different editors, IDE's, operating systems, and settings within each, where you collaborated on the same code?"
10:42:41 <dmwit> yes
10:42:46 <hrookie> dmwit: that's all you had to say fool :-P
10:42:49 <elliott> (as opposed to a fake job?)
10:42:51 <dmwit> Okay, then.
10:42:56 <dmwit> I misinterpreted the question, I guess.
10:42:56 <hrookie> i say fool endearingly
10:42:58 <hrookie> it's not an insult
10:43:01 <Twey> hcaulfield57: As you say, . only takes functions (unless you're using lambdabot), but that parses as (sum . (map (+ 1))), and (map (+ 1)) is a function, so it's all fine
10:43:21 <hrookie> elliott: as opposed to just like being at home working on your own projects and not having had a job
10:43:25 <hrookie> elliott: i know more than one
10:43:55 <hcaulfield57> Twey: Okay, thanks. I dunno why I'm having so much trouble with (.) and ($)
10:43:57 <liyang> Maybe if you wrote (.) prefix, that'd clarify things.
10:44:03 <josephle> hrookie: "grad student" kinda fits your description >_>
10:44:18 <jix> hrookie: in my limited experience "real job" coding takes place in a far more uniform environment than any other collaborative projects
10:45:00 <edwardk> hrookie: yes
10:45:03 <Twey> hcaulfield57: It's just about precedence.  $ has a lower precedence than ., which has a lower precedence than function application.
10:45:05 <hrookie> josephle: currently grad student, formerly employed =D it's true, we all used Visual Studio, i admit it
10:45:08 <fruitFly> huh guys?! Haskell on android?! (with vim touch?)..  I don't have a computer
10:45:13 <Twey> (everything has a lower precedence than function application)
10:45:25 <hrookie> there was a stray mac user here and there
10:45:33 <dmwit> Twey: (except record update)
10:45:41 <sclv_> (and function application)
10:45:47 <dmwit> ...yes =)
10:46:06 <hrookie> come to think of it the mac guys never wrote code though. all the code was in VS 2010
10:46:12 <edwardk> hrookie: i've been in that environment. i've also been in the java shop where everyone uses eclipse and the c# shop where everyone used visual studio, etc. i tend to prefer the heterogeneous environment. systems tend to be factored better and more portable and the whole thing is likely to be more resilient to change
10:46:27 <hcaulfield57> Twey: Okay, does ($) work because it lets it's right side evaluate first before applying left function?
10:46:44 <hrookie> edwardk: yeah, and if you plan on X-platform deployment, you just start knocking out issues from the foundation on up. i really like it.
10:46:44 <sclv_> if everyone works in an ide, often they have no idea how builds actually work
10:46:49 <sclv_> because it is eclipse magik
10:46:50 <Twey> hcaulfield57: No
10:47:14 <sclv_> f $ x is exactly the same as f x
10:47:19 <sclv_> its just about associativity
10:47:20 <Twey> hcaulfield57: Evaluation order and operator precedence are orthogonal
10:47:34 <sclv_> f (g x) is different from f g x
10:47:34 <hrookie> the ($) operator just says "everything to the right gets finished, then passed as an argument to whatever's on the left"
10:47:38 <elliott> haukeh: it's because f . g $ x is ((f . g) $ (x))
10:47:41 <elliott> no magic
10:47:43 <elliott> er
10:47:46 <elliott> hcaulfield57: it's because f . g $ x is ((f . g) $ (x))
10:47:47 <sclv_> the former applies g x then f to that result
10:47:48 <dmwit> I would also like to say this: I began using tabs as an experiment to see how far I could push it. I'm actually not convinced it's the right choice -- but I also feel morally obligated to object when people make factually inaccurate claims about tabs vs. spaces.
10:47:57 <elliott> hcaulfield57: ($) isn't magic, just a regular old operator.
10:48:02 <sclv_> the latter applies f to g and the result of that to x
10:48:02 <mm_freak> dmwit, beaky: http://hpaste.org/88419 ⇐ if this is not an elegant hangman, i don't know what is =)
10:48:12 <hrookie> dmwit: mixing tabs and spaces is the devil. that is fact. it is an objective claim!
10:48:29 <dmwit> I object.
10:48:45 <elliott> my objective claim: i object to tabs vs. spaces discussions on the gounrds that they are so, so very tiring
10:48:51 <elliott> hey, dmwit stole my pun.
10:48:58 <elliott> now I have to object to dmwit too.
10:49:37 <hrookie> completely unrelated: new code jamming music - Gold Panda! =D
10:49:42 <hrookie> i highly recommend.
10:49:43 <hcaulfield57> Yea I get (kinda) what ($) is doing, I suppose I just want to know how it does it.
10:49:54 <mm_freak> most games like that are monoids and writing a type like i did makes writing the monoid instance very easy
10:49:55 <sclv_> it does it just like any old function
10:50:02 <sclv_> we just declare the precedence of operators explicitly
10:50:19 <Twey> hcaulfield57: Haskell allows you to define operator precedence.  ($) is just declared with the lowest possible precedence.
10:50:38 <mm_freak> and then 'hangman' is a monoid morphism:  hangman (word1 <> word2) = hangman word1 <> hangman word2
10:50:40 <liyang> hcaulfield57: ($) :: (a -> b) -> a -> b; ($) f x = f x
10:50:48 <hcaulfield57> So other functinos get done first?
10:51:04 <liyang> and infixr 0 $
10:51:28 <elliott> mm_freak: shouldn't you define hangman with foldMap if you want to go down that route?
10:51:45 <fruitFly> mm_freak to convert [word8] to base64 should I convert it to a binary string then operate on 6 bits at a time?
10:52:17 <mm_freak> fruitFly: that's not what you would do normally…  but you can as a first attempt
10:52:30 <fruitFly> what would you recommend?
10:52:31 <mm_freak> :t foldMap
10:52:32 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
10:52:40 <hrookie> hey, hey, i have a punny. why did they pick the symbol $ for the operator ($) ?
10:52:52 <mm_freak> elliott: indeed
10:52:54 <dmwit> Why?
10:53:02 <liyang> Y?
10:53:19 <dmwit> mm_freak: (The monoid instance for (String, [Bool]) is already written...)
10:53:30 <hrookie> because $ is for dollars, the sign of capitalism, and parentheses go with LISP, a la communism, see: McCarthy
10:53:32 <mm_freak> fruitFly: start with base64 (a:b:c:xs) = g a b c ++ base64 xs
10:53:44 <liyang> . . .
10:53:55 <hrookie> disclaimer: i said punny, not funny. it doesn't even really add up.
10:53:56 <mm_freak> fruitFly: there will be a total of four such clauses
10:54:14 <liyang> Mind = blown.
10:54:35 <Twey> hrookie: That is a dreadful pun on historical grounds :þ
10:54:39 <liyang> May also due to it being 02:54:30.
10:54:54 <hrookie> Twey: yeah, especially since it's mixing up John and Joseph McCarthy =D
10:54:57 <haasn> mm_freak: lines 18-22 could be replaced by (f1 c <|> t1) <> (f2 c <|> t2) -- ?
10:54:59 <mm_freak> dmwit: i understand your complaint, but with the same reasoning you should use TYPO3 instead of happstack
10:55:22 <Twey> hrookie: I was more thinking about how McCarthy hated communists :þ
10:55:26 <haasn> or whatever that operator is
10:55:33 <mm_freak> haasn: i thought about doing that, but then i was operationally concerned =)
10:55:44 <hrookie> Twey: well, wait, apparently, John McCarthy's dad owned a communist newspaper. I was going for Joseph McCarthy. LOL
10:56:03 <hrookie> wow. that's terrible.
10:56:08 <hrookie> i outpunned myself.
10:56:18 <hrookie> (not owned, managed)
10:56:29 <haasn> mm_freak: at any rate more elegant than a manual case analysis on every possible case ;)
10:56:29 <dmwit> Yes, yes, we must always choose between dependent types and untyped. Those are the only choices, there is nothing in between.
10:56:37 <mm_freak> liftA2 (<>) (f1 c) (f2 c) <|> fmap (<> h2') (f1 c) <|> fmap (h1' <>) (f2 c)
10:56:44 <quchen> dmwit: What? NOOOO
10:56:46 <Twey> Haha
10:56:52 <haasn> oh, h1' and h2' instead of t1 and t2
10:56:55 <haasn> of course
10:57:05 <hrookie> anyway, i'm going to go dive into my hole and be productive. cheers guys
10:57:11 <fruitFly> mm_freak how do you convert 3 bytes to base 64 without braking them up into four 6 bit chunks? do you import anything?
10:57:39 <mm_freak> fruitFly: you can bitshift them to the form you need them in
10:57:39 <haasn> (f1 c <|> h1') <> (f2 c <|> h2') -- still more elegant if you ask me
10:57:57 <mm_freak> haasn: that's not the same thing
10:58:09 <mm_freak> or well
10:58:11 <mm_freak> yes, it is
10:58:30 <mm_freak> oh!  no, it's not
10:58:35 <mm_freak> consider the Nothing/Nothing case
10:58:40 <fruitFly> omg mm_freak Thanks!
10:58:53 <mm_freak> fruitFly: look into Data.Bits
10:58:54 <haasn> oh!
10:59:09 <fruitFly> THANKS!
11:00:00 <nooodl> @ty (<|>)
11:00:04 <lambdabot> Alternative f => f a -> f a -> f a
11:00:55 <haasn> next time my friends ever play hangman I'm gonna tell them “hangman's just a monoid morphism, what's the big deal?”
11:01:24 <tem> pls provide some usage examples of "Data.Configurator" There are no examples given on hackage.haskell.org/packages/archive/configurator/latest/doc/html/Data-Configurator.html
11:02:22 <elliott> there is https://github.com/bos/configurator/blob/master/tests/Test.hs.
11:02:32 <hcaulfield57> When I do something like a $ b , why doesn't function a try to take $ as it's argument?
11:02:39 <haasn> it's an operator
11:02:44 <haasn> that parses (and gets applied) as ($) a b
11:02:46 <elliott> hcaulfield57: when you write 1 + 2, 1 doesn't try to take + as its argument
11:02:50 <haasn> ($) is the function, a and b are the arguments
11:02:52 <elliott> because (+) is an infix operator because it is made out of symbols
11:03:25 <hcaulfield57> Okay, that makes sense, thank you.
11:03:27 <nejucomo> I'm hunting for terminology to distinguish that which can be expressed in a programming language, by its syntax, and that which is not expressed in the language, but which interacts with the language (such as interpreter extensions, native libraries, ffi code, …).  Any suggestions?
11:03:53 <nejucomo> (This is slightly off topic, but I'm curious if there's a standard haskell terminology.)
11:03:55 <applicative_> it tries to take a as an argument
11:04:51 <applicative_> nejucomo: the choices, as we know, are three, syntax, semantics, pragmatics.
11:05:15 <haasn> if you ask me, “things outside the language which interact with the language” are part of the language
11:05:43 <applicative_> like the world, it's obviously a part of English, which is my language
11:05:50 <josephle> haasn: is Core part of Haskell?
11:05:55 <nejucomo> So when refering to a package on hackage, is there a concise terminology to mean "the entire source of that package are written in haskell" versus "some of that package is written in C" ?
11:06:27 <geekosaur> (remembering that different compilers have different ideas of what constitutes Core)
11:06:28 <applicative_> people say 'pure haskell', or 'pure haskell 98' using pure in the less technical sense
11:06:33 <haasn> Core doesn't “interact with the language”, in my opinion - it's an internal implementation detail GHC uses, but to my knowledge, it doesn't ‘reach the surface’
11:06:55 <nejucomo> python culture also uses "pure" and it's frustratingly conflated (especially for my toy language).
11:07:02 <applicative_> "MissingH is a library of all sorts of utility functions for Haskell programmers. It is written in pure Haskell and thus should be extremely portable and easy to use.
11:07:13 <josephle> but surely you can link Core files with haskell files and have a working program
11:07:19 <nejucomo> applicative_: Thanks for the example.
11:07:33 <mm_freak> haasn: "hangman is a monoid generated by single character guessing games"
11:07:34 <mm_freak> =)
11:07:37 <applicative_> nejucomo: that seems pretty typical ^^^ but I agree one could do with a more technical and precise term
11:07:43 <haasn> ‘pure Haskell’ here means ‘Haskell without the FFI’?
11:07:55 <tem> elliott: is there any simpler example that a beginner can understand without much difficulty? This code is going over my head.
11:07:56 <elliott> or GHC specifics, presumably
11:07:57 <hcaulfield57> Okay one more question, then I'm done for the day.
11:08:10 <nejucomo> haasn: I would guess some people mean that.  (But it could mean no language extensions, or no IO, or … ?)
11:08:21 <applicative_> haasn: I think that would be part of it, but I think there's no official phrase like that, that's nejucomos point
11:08:21 <haasn> language extensions aren't part of Haskell ;)
11:08:23 <haasn> strictly speaking
11:08:25 <hcaulfield57> data Color = Red | Green What is the technical term for Red and Green?
11:08:39 <elliott> tem: googling "haskell configurator" turns up http://ocharles.org.uk/blog/posts/2012-12-21-24-days-of-hackage-configurator.html as the fifth result. beyond that, I don't know
11:08:48 <mm_freak> in most cases "pure haskell" really just means something along the lines of "no C under the hood"
11:08:50 <applicative_> hcaulfield57: data constructors
11:08:59 <applicative_> Color is a type constructor.
11:09:01 <nejucomo> haasn: Ok, let me propose the distinction another way:  I have a haskell interpreter that supports all of GHC's langauge extensions, but it cannot compile.
11:09:11 <nejucomo> Now, I want to know which hackage packages my interpreter can use.
11:09:25 <applicative_> hcaulfield57: in this case, the expressions are a little silly, but with data Maybe a = Nothing | Just a
11:09:35 <applicative_> we call Just a data constructor and Maybe a type constructor
11:09:36 <nejucomo> It sounds like "pure haskell" is the common term.
11:09:51 * nejucomo reads various wikipedia pages about programming languages and linguistics, hunting for the distinction.
11:10:01 <hcaulfield57> applicative_: Okay, thanks that's what I wanted to know. Reading three books, and couldn't find consistent term
11:10:43 <tem> elliott: I was searching for Data.Configurator and couldn't get that result. Anyway the example given there is not complete. thanks anyway.
11:10:43 <applicative_> hcaulfield57: this jargon is used in the Haskell report, I don't know that it has wider cs or type theoretic use
11:11:00 <elliott> tem: it seems like you will have to be the one to figure it out and write the example then :)
11:11:00 <haasn> ‘data constructor’ is special in that you can pattern match on them as well, which you certainly can with Red/Green
11:11:23 <josephle> applicative_: I can confirm that your terminology is pretty widely used in PLT publications
11:11:34 <elliott> tem: you could also read code that uses configurator by looking at its reverse dependencies http://packdeps.haskellers.com/reverse
11:11:36 <hcaulfield57> applicative_: Well that works :)
11:12:18 <dolio> nejucomo: Does it support the FFI?
11:12:44 <johnw> applicative_: I don't think Color is a type constructor
11:12:57 <johnw> according to the wiki "A type constructor is used to construct new types from given ones."
11:13:03 <josephle> type constructor is used because haskell's type system is under its kinding system
11:13:04 <nejucomo> dolio: Hmph.  Ok, fine every language extension except the FFI-related extensions.  ;-)
11:13:06 <johnw> Color cannot be used to construct new types
11:13:09 <haasn> yeah, Color is a type, not necessarily a type constructor
11:13:22 <dolio> I don't think that's a very good definition of type constructor.
11:13:27 <haasn> though there's not an awful lot of distinction between ‘plain’ types and type constructors, theoretically
11:13:38 <hcaulfield57> If it takes an argument it's a type constructor?
11:13:48 <haasn> that's more of an informal naming thing I guess
11:13:59 <johnw> well, the wiki also mentions "nullary data constructors", so perhaps the same logic can be applied to type constructors
11:14:00 <josephle> I personally think that types t :: T (or * in haskell) are types, and everything else is a constructor
11:14:06 <johnw> i just always thought that type constructors had kind * -> *
11:14:10 <dolio> It makes some sense to define type constructors by analogy to data constructors.
11:14:16 <haasn> johnw: but what about (* -> *) -> *
11:14:18 <josephle> johnw: depends on your kind calculus
11:14:19 <dolio> In which case Color and Int are constructors.
11:14:23 <johnw> that's still just kind * -> *
11:14:58 <josephle> sml's core language has <*,*>, for example
11:15:00 <johnw> dolio: true, maybe that's the right way to think about it
11:15:05 <haasn> josephle: it gets trickier when you add in GHC's extensions
11:15:19 <dolio> And in plain Haskell, you define type classes by case analysis on type constructors, for instance.
11:15:22 <dolio> And nothing else.
11:15:26 <elliott> johnw: (* -> *) -> * is not * -> *.
11:15:49 <johnw> elliott: in the same sense that a -> b covers the case where a is a function
11:15:52 <dolio> (Not true for all GHC extensions.)
11:15:54 <haasn> because now you have types like “3 :: Nat” and “Monoid :: * -> Constraint” which aren't of the form * but don't really make sense as type constructors
11:15:58 <josephle> haasn: is it? I guess if some extension gives you singleton kinds we're in trouble
11:15:59 <elliott> johnw: * is not a wildcard
11:16:01 <elliott> it is a star
11:16:08 <elliott> (Char -> Char) is not ((Char -> Char) -> Char)
11:16:17 <johnw> ah, ok, I stand corrected
11:16:33 <elliott> * is perhaps an unfortunate choice of ASCII symbol given its connotations
11:16:48 <johnw> i knew it wasn't a wildcard, but I've hear it explained that there are only two kinds: * and * -> *
11:16:57 <tem> how do I install "Data.Configurator" using cabal?
11:17:15 <elliott> "cabal install configurator"
11:17:18 <johnw> is there a native Nat kind now?
11:17:24 <int-e> ugh.
11:17:33 <elliott> johnw: in standard Haskell, the kinds are given by kind := * | kind -> kind
11:17:39 <int-e> johnw: am I supposed to read that as  k ::= * | k -> k ?
11:17:43 <johnw> ah, that makes sense
11:17:55 <elliott> so it is true that every kind has * at the leaves, but it is not true that both sides of -> are necessarily *
11:18:00 <johnw> wait, it's not * | kind -> *?
11:18:36 <johnw> I guess i can have a type function that yields a type function, can't I
11:18:40 <int-e> * -> (* -> *)  is allowed
11:18:41 <acube> johnw: there is (* -> *) -> (* -> *)
11:18:44 <applicative_> josephle: constructor in the sense of 'data constructor' is pretty ancient, it's 'type constructor' that seems to me special use and maybe slightly illiterate
11:18:46 <johnw> cool
11:18:47 <elliott> johnw: data Either a b = ...
11:18:51 <elliott> johnw: Either :: * -> * -> *
11:18:55 <elliott> aka * -> (* -> *)
11:19:00 <johnw> ah, yes
11:19:05 * nejucomo is tempted to appropriate the terms "emic" and "etic": https://en.wikipedia.org/wiki/Emic
11:19:46 <int-e> @kind Control.Monad.State.StateT
11:19:48 <lambdabot> * -> (* -> *) -> * -> *
11:20:44 <applicative_> emetic
11:21:12 <johnw> eww
11:21:33 <haasn> memetic
11:21:50 <applicative_> mimetic
11:22:01 <tem> when I run "cabal install configurator" I got error: cabal: The program ghc version >=6.4 is required but the version of C:\Program Files (x86)\Haskell Platform\2012.4.0.0\bin\ghc.exe could not be determined.
11:22:11 <josephle> applicative_: well, the idea is we're constructing terms on the type level that fulfills a certain kind signature
11:22:12 <applicative_> hm
11:22:33 <applicative_> 'type constructor' as haskell jargon predates the kind system, no?
11:22:39 <elliott> tem: sounds like your haskell platfor minstallation is broken somehow. I don't know Windows though
11:22:41 <applicative_> what is the hugs kind system
11:23:00 <johnw> applicative_: tight and squeezie, or A-frame
11:23:13 <josephle> applicative_: the kind system has been around since SML
11:23:50 <josephle> there's just no way for a programmer to construct kinds in an ML language. Instead it's their way of compiling modules to a smaller core langauge
11:24:24 <Twey> applicative_: What makes you call it ‘illiterate’?  It constructs a type; I see it as having as much validity as ‘data constructor’
11:24:41 <applicative_> sml isn't very ancient
11:24:53 <Peaker> it just occurred to me that there's a strong relationship between higher-kinded polymorphism and structural records/variants..  Much harder to have both than just one of them
11:25:08 <Peaker> Can explain why Haskell doesn't have structural records/variants, and why OCaml and others don't have higher kinded polymorphism
11:25:33 <josephle> applicative_: seems to be exactly as old as haskell in fact
11:25:35 <tem> I have installed Haskell platform just now. Is it already broken on windows?
11:26:23 <applicative_> tem oh no one knew what to say above?
11:27:07 <josephle> Peaker: can you define higher-kinded polymorphism so I'm on the same page?
11:27:31 <Peaker> josephle, having type constructors and having type variables which take on their value
11:27:42 <Peaker> With structural records/variants, there aren't any type constructors at all, are there? Just type synonyms which are surjective type functions
11:27:42 <josephle> ok
11:27:56 <elliott> josephle: in OCaml you cannot write the equivalent of quantifying over anything of type (* -> *) or whatever
11:28:01 <josephle> Peaker: actually modules don't get compiled to structural records
11:28:03 <hcaulfield57> In class declarations, is it necessary to have a parameter for the class, like "class Foo a where"
11:28:11 <Peaker> elliott, does OCaml have type constructors at all?
11:28:15 <elliott> hcaulfield57: except in very recent GHC with an extension, yes
11:28:17 <applicative_> higher kinded polymorpism is the most intoxicating drug known to man
11:28:18 <josephle> they get compiled to things of kind Sigma(t : ...).etc
11:28:24 <elliott> Peaker: sure you can define Maybe in OCaml...
11:28:55 <hcaulfield57> elliott: Okay thanks
11:29:00 <josephle> elliot: do you mean anything more complex than (* -> *)?
11:29:06 <Peaker> elliott, but if you define Maybe to be a type synonym like:   type Maybe a = (Nothing | Just a)      then Maybe is just a surjective type-level function, not a bijection. You can add another data constructor "on the fly" to get a larger sum
11:29:24 <Peaker> elliott, IOW, you can have Maybe as a type synonym that takes an argument without actually having any type constructors
11:29:50 <josephle> it's true that in ML you're only allowed to make types of kind * or (* -> *)
11:29:51 <hcaulfield57> Out of curiosity, does anyone know if there is some type of man page documentation for Haskell?
11:29:54 <Peaker> (I'm assuming the use of anonymous sums/variants to build types, and using type synonyms to give them names)
11:29:56 <josephle> nothing fancy like haskell's (kind -> kind)
11:30:06 <applicative_> newtype Nu f = Nu {nu :: f (Nu f)}
11:30:20 <Peaker> josephle, if you have variants and structural records, when do you have a kind like *->*?
11:30:31 <josephle> Peaker: functors
11:30:34 <elliott> Peaker: ok, but I don't see what this has to do with whether OCaml has type constructors :)
11:30:37 <Peaker> ah, the first-class modules
11:30:42 <josephle> yep
11:30:43 <elliott> josephle: well, you can also do (*, *) -> *, right?
11:30:45 <Peaker> elliott, if we ignore them for a second :)
11:30:52 <Peaker> s/elliott/josephle
11:31:02 <elliott> so it's effectively kind ::= * | * -> kind, without the currying.
11:31:02 <josephle> Pi(t : k).k
11:31:24 <josephle> ML's underlying core language actually uses a *dependent* kind system
11:31:28 <josephle> which scares me to no end
11:31:32 <Peaker> the reason I'm wondering about this is because in lamdu, we wanted to have variants and structural records and type synonyms, rather than having type constructors
11:31:42 <Cale> josephle: Why does it scare you?
11:32:01 <Peaker> but then we can't have higher kinded polymorphism, e.g: the Monad class
11:32:14 <applicative_> that seems pretty horrible
11:32:41 <josephle> Cale: because my professor made me implement a conversion from modules to kinds, and bugs based on debrujn indices still haunt me
11:32:43 <Peaker> applicative_, I agree, though OTOH, Haskell's requirement to give every ADT a distinct name is also bad
11:33:22 <Peaker> applicative_, I want to be able to easily add cases to a sum or fields to a record and get a precise type for that without duplicating the whole thing or adding tons of parameters that are only relevant for a single sub-expression
11:33:42 <josephle> s/debrujn/debruijn/g
11:34:17 <Peaker> applicative_, (same w.r.t removal of data constructors or fields)
11:34:18 <Cale> josephle: Fair enough :)
11:34:29 <johnw> josephle: have you played with edwardk's bound library?
11:34:45 <josephle> johnw: I haven't
11:34:55 <Peaker> I hate having Haskell code like:   case Foo of One .. -> Just $ ...   Two .. -> Just $ ..  Three .. -> Just $ ..  .....   Hundred -> Nothing
11:35:18 <Peaker> would be nicer to have:  case foo of Hundred -> Nothing ; x -> Just $ case x of ...
11:35:26 <johnw> josephle: he has a presentation on it called "Making De Bruijin succ less"
11:35:26 <Peaker> (and have "x" be a smaller sum)
11:36:01 <Cale> Peaker: Of course, you can just write that code...
11:36:15 <josephle> johnw: oh I found it. Will read.
11:36:31 <Cale> (but the case exhaustiveness checking probably will complain)
11:36:40 <monochrom> Peaker: you may like http://lambda-the-ultimate.org/node/4631
11:36:44 <Peaker> Cale, Yes, and my code will crash if I make a mistake there, or if cases are added
11:37:26 <Peaker> monochrom, yeah, I read about row polymorphism and variants - they're cool, but just today I realized it's not easy to have them alongside type constructors easily, and/or higher kinded polymorphism
11:37:57 <Cale> Peaker: They'd be new kinds (rows and variants)
11:38:29 <applicative_> don't most of the record fripperies people want come from barely typed languages they are used to?
11:38:37 <Peaker> Cale: That's not what I mean, I mean that once you have row polymorphism/variants, suddenly there's no one-to-one mapping from a data constructor to some type constructor -- it seems the straightforward thing to do once you have that is to shun type constructors completely for type synonyms
11:39:55 <Cale> hmm
11:39:55 <Peaker> I guess there could be a primitive to explicitly define a type constructor by making a tagged copy of all the data constructors/fields
11:40:18 <shergill> josephle: in a dependent kind system, what are the kind's dependent on? the types? or the data values?
11:40:18 <applicative_> ... oh what a tangled web ...
11:40:35 <Cale> applicative_: Well, there are two quite different directions things come from
11:40:45 <Peaker> but if you have variants, the way you'd have "Maybe" is:   type<synyonm> Maybe a = Nothing | Just a    and you could easily say:  Maybe a | Foo       and it'd be equivalent to:  Nothing | Just a | Foo
11:40:54 <Peaker> And that's a good thing, but "Maybe" is no longer a thing of some given kind
11:41:08 <Peaker> or rather, it's a surjective thing rather than a bijective thing
11:41:30 <applicative_> Peaker: in your language I can later add a constructor KindOf a, alongside Nothing and Maybe a
11:41:40 <applicative_> then Necessarily a
11:41:53 <Peaker> applicative_, sure, you could add those to the sum
11:41:56 <Cale> applicative_: There's the "herp derp I just don't want to invent field names because I'm used to C++" thing, and then there's the "I genuinely want to be able to write code which is row-polymorphic"
11:42:09 <Peaker> applicative_, in Haskell you can (cumbersomely) do:  data Necessarily a = NMaybe (Maybe a) | ...
11:42:23 <josephle> shergill: dependent on types
11:42:24 <Cale> Peaker: I don't think I would unify row/variant types with algebraic datatypes.
11:42:28 <applicative_> yes, but it makes so much sense...
11:43:03 <applicative_> Peaker you need a distinct kind of anti-types
11:43:20 <Peaker> Cale, if you have both, might as well have some sort of mechanism to "bless" a bunch of data constructors into a type constructor -- so that you only have one sum and product mechanism, rather than 2
11:43:21 <Cale> Peaker: Instead, just adopt altogether new notation for rows and variants, possibly not even containing anything which looks quite like a data constructor.
11:44:07 <Peaker> Cale, imagine defining a large AST, of which you want various subsets
11:44:14 <Cale> I suppose there's some desire to not repeat things, but I wouldn't want to randomly be treating Maybe constructors as possibly being injections into a polymorphic variant.
11:44:38 <josephle> shergill: I mean, if you had dependent types, then kinds are just higher order types
11:44:46 <fruitFly> what's wrong with 254 in main at the bottom? http://ideone.com/rbeHcx
11:45:13 <Cale> But maybe there ought to be a map from any algebraic type to a polymorphic variant.
11:45:27 <Cale> (an explicit generalisation)
11:45:32 <Peaker> I think maybe each data constructor should optionally have a copy for each explicitly declared type constructor -- and you should be able to have:  Maybe a -> (Nothing | Just a)  and (Nothing | Just a) -> Maybe a.   And:   Nothing :: (Nothing | other) ; Maybe.Nothing :: Maybe a
11:45:45 <applicative_> fruitFly: it doesn;t know what type to assign 254 and 2
11:46:00 <applicative_> and how the bits instance will work for them
11:46:43 <applicative_> if you put 254::Int it will be okay
11:46:56 <Cale> Peaker: Of course, once we figure out a computational interpretation for univalence, this kind of issue will solve itself :D
11:47:10 <applicative_> it can't figure out what to print; for all it knows, there's a Num instance for String, and a Bits instance
11:47:13 <fruitFly> applicative thanks
11:47:41 <Cale> Peaker: (i.e. being able to treat types as equal once you can provide an isomorphism between them)
11:47:46 <josephle> and suddenly we're off to Homotopy Type Theory
11:48:14 <Twey> josephle: You say this like it's a bad thing ;)
11:48:56 <fruitFly> applicative so the output is either an int or a string and its not sire?
11:49:01 <fruitFly> sure
11:49:29 <josephle> Twey: exciting times are ahead! :)
11:53:59 <user123abc> I want to read the string "1 2 3" into the list [1, 2, 3] - is there a prepackaged way to do this?
11:54:13 <user123abc> I don't want to give the string as "[1, 2, 3]"
11:54:21 <elliott> > (map read . words) "1 2 3"
11:54:24 <lambdabot>   [*Exception: Prelude.read: no parse
11:54:28 <elliott> uh.
11:54:31 <elliott> > (map read . words) "1 2 3" :: [Integer]
11:54:33 <lambdabot>   [1,2,3]
11:54:36 <user123abc> <3
11:54:40 <Peaker> Cale, but even if you do that, say you have (Nothing | Just a) and you know it's isomorphic to  Maybe a    you still cannot infer it is Maybe a, and cannot match the type "m a", such that m=Maybe
11:56:22 <gds> Am I right in thinking that the most popular way to talk to SQL databases these days is HDBC?
11:56:42 <Clint> from my skewed perspective, it's persistent
11:58:01 <gds> Cool.
11:59:03 <fruitFly> oooh yeeeah! developing on android now with vim touch :D...  compiling through ideone.com though
12:01:03 <applicative_> man, the expression 'code motion' seems like language on holiday but it must make sense ...
12:05:05 <user123abc> so I keep running into errors when I attempt to use (.) and ($) to omit parentheses - and I'm realizing that the rules for function application as it relates to l/r associativity aren't clear to me
12:05:49 <user123abc> could anyone recommend a reference or description of the expression syntax as it relates to those things?
12:07:12 <sclv_> ?where report
12:07:12 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
12:07:35 <sclv_> that's the definitive reference, but not necessarily the easiest read compared to a tutorial
12:07:39 <user123abc> I've considered it, although the language is a bit out of my league for now
12:08:16 <sclv_> the easiest thing to do is write foo (bar (baz x))
12:08:22 <user123abc> the issue with the tutorials is that the rules that they give for l/r associativity don't seem to apply to function application
12:08:24 <sclv_> then transform it a step at a time
12:08:49 <sclv_> well function application isn't infix so it doesn't have associativity, just precedence
12:09:15 <sclv_> f g x y z is (((f g) x) y) z
12:09:20 <sclv_> that's all you really need to know
12:09:35 <sclv_> and that in a loose sense "every function in haskell takes only one argument"
12:10:02 <sclv_> i.e. \x y -> x + y ~=~ \x -> \y -> x + y
12:10:09 <user123abc> I do get that
12:10:15 <sclv_> then that's it
12:10:32 <user123abc> where I have problems is in trying to understand when (.) can and can't be applied
12:10:35 <user123abc> or ($)
12:10:56 <conal> i think of application as infix (juxtaposition) with a high precedence (10) and left-associativity.
12:11:06 <sclv_> don't think of using (.) to omit parens -- think of it as using it to capture composition
12:11:34 <sclv_> so start by taking your expression with parens and taking off "one set" of parens and substituting that with at $
12:11:38 <sclv_> then keep doing that...
12:11:42 <user123abc> sclv_, someone pointed out yesterday that . can be used to replace instances of $ when arguing for a left-associative $
12:11:52 <sclv_> and eventually you get foo $ bar $ baz $ x
12:11:54 <sclv_> right.
12:12:02 <sclv_> then go ahead and transform that to foo . bar . baz $ x
12:12:20 <sclv_> $ gets rid of parens, (.) gets rid of $s :-)
12:12:36 <quchen> I'm kind of hesitant posting the Applicative/Monad proposal. On the other hand, I'm not sure why I shouldn't, except for being afraid of the avalanche it may trigger. Any opinions? (Except Shachaf, who already told me it's not a good time. No reason given though.)
12:12:39 <user123abc> that's very reasonable, and that's what I'll do, although I'd like to understand the rules well enough to skip the first phase
12:13:05 <user123abc> but if the rule you gave is in fact enough, then maybe I can convince myself of that fact and that'll be it
12:13:06 <user123abc> thanks
12:13:19 <sclv_> right -- the key is not to think of (.) as getting rid of parens. the key is to think of it as doing what the type says -- composing functions
12:13:55 <sclv_> so you build up a chain of composed functions using (.) and eventually apply that "compound function" to some value, and $ lets you do so with less parens
12:15:11 <user123abc> > map (read . words) "1 2 3" :: [Integer]
12:15:15 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
12:15:15 <lambdabot>              with actual type...
12:15:39 <sclv_> > map read . words $ "1 2 3" ::[Integer]
12:15:43 <lambdabot>   [1,2,3]
12:16:02 <sclv_> you want to map the read over the result of words, but you don't want to map words, just apply it once
12:16:05 <user123abc> so map read is being curried
12:16:08 <user123abc> and then composed?
12:16:16 <sclv_> ?ty map
12:16:18 <lambdabot> (a -> b) -> [a] -> [b]
12:16:34 <sclv_> map is partially applied to read, yielding a function of type [String] -> [Integer]
12:16:41 <Fuco> I'd like a function (a -> Bool) -> a -> Maybe a that would take a predicate, a value and return Just x or Nothing based on the predicate. Is there something built-in already?
12:16:42 <user123abc> yeah, I do know that, and I was trying to figure out why elliot was mapping words onto the string
12:16:51 <Fuco> I don't want to use if/then/else :/
12:17:07 <user123abc> (which he wasn't, but that's my point)
12:17:13 <sclv_> we then compose it with a function from String -> [String], and get a compound function of String -> [Integer]
12:17:42 <user123abc> ok - got it, that's what I was trying to say by "map read is being curried"
12:17:57 <sclv_> right but that's not how we use the word curry :-)
12:18:04 <sclv_> ?ty curry
12:18:05 <user123abc> yeah
12:18:06 <lambdabot> ((a, b) -> c) -> a -> b -> c
12:18:26 <Twey> Fuco: I miss that sometimes too, but no
12:19:17 <sclv_> ?ty find
12:19:19 <lambdabot> (a -> Bool) -> [a] -> Maybe a
12:19:47 <Twey> Fuco: A more generally useful function is: (t ?? _) True = t; (_ ?? f) False = f;
12:19:48 <sclv_> so you can do \f -> find f . (:[])
12:20:06 <Twey> Fuco: Then you can write (Just ?? const Nothing)
12:20:22 <Twey> sclv_: That feels wrong :þ
12:21:42 <Fuco> is (??) an operator? I don't get it
12:22:12 <Twey> Fuco: Haskell operators are just functions whose names are made of symbol characters
12:22:49 <Fuco> I'm asking if by ?? you ment "put something here"
12:22:50 <Twey> Fuco: I defined an operator (??) ∷ a → a → Bool → a that is basically if/then/else in a more convenient form
12:22:55 <Twey> Oh, no
12:23:21 <Fuco> also I didn't know you can have ternary operators
12:23:25 <Fuco> or at least using that syntax
12:23:26 <Twey> (Just ?? const Nothing) ∷ Bool → a → Maybe a
12:23:41 <josephle> Twey: so basically the maybe function for bools?
12:23:44 <applicative_> One in five teenagers will experiment with higher-kinded polymorphism.  Learn to recognize the early warning signs. Talk to your kids about higher kinds.
12:23:46 <Twey> josephle: Yep
12:23:54 <Twey> Hehe
12:25:49 <kennethmosquera> are where a lets interchangeable ?
12:26:21 <Twey> kennethmosquera: Mostly.  where scopes over guards.
12:27:26 <Fuco> what about this, is there some nicer way: leq (_,d,_) (_,e,_) = d <= e ?
12:27:28 <applicative_> there isnt a deep difference of the sort there is between case and let/where
12:28:33 <Peaker> I wonder how hard it would be to change ghc's lexer to allow  "foo do" or "foo case"  rather than "foo $ do" or "foo $ case"
12:28:41 <Peaker> s/lexer/parser
12:30:05 <kennethmosquera> this to a where
12:30:08 <kennethmosquera>            pr8_1 (g:gs)
12:30:08 <kennethmosquera>                    | g == x = let (un,u) = pr8_1 gs in (g:un, u)
12:30:09 <kennethmosquera>                    | otherwise = ([], (g:gs))
12:30:43 <alexander__b> dear lord pastebin
12:31:00 <JordiGH> Are applicative functors a purely Haskegorical concept? I can't find a definition of them in Maclane.
12:31:03 <applicative_> hah, like alexander__b says
12:31:20 <applicative_> JordiGH: 'lax monoidal functor' is the fancy jargon
12:31:31 <applicative_> dunno if it's mac lane
12:32:09 <JordiGH> Hm, nothing about lax nor monoidal either.
12:32:11 <JordiGH> Oh well.
12:32:54 <JordiGH> I probably ought to stop approaching Haskell as if it was done by mathematicians.
12:33:02 <JordiGH> It was done by programmers.
12:34:10 <arkeet> maclane doesn't talk about monoidal functors/categories?
12:34:37 <JordiGH> Nope.
12:34:50 <arkeet> yes he does
12:34:59 <JordiGH> which page?
12:35:01 <arkeet> chapter VII
12:35:12 <JordiGH> Ah, I couldn't find it in the index.
12:35:17 <arkeet> I found it in the TOC.
12:35:41 <arkeet> also it's right there in the index. under monoidal categories
12:35:52 <JordiGH> I was looking for Functor, monoidal.
12:36:43 <sclv_> note that applicatives are also closed
12:36:46 <Twey> Fuco: snd3 (_, x, _) = x, and use: on (<=) snd3
12:36:46 <sclv_> lax closed
12:36:58 <Luke> stepcut: the acid-state website is down
12:37:04 <Twey> leq = on (<=) snd3
12:37:04 <sclv_> which comes for free b/c monoidal between two closed categories
12:37:14 <Twey> Fuco: But triples are often a code smell
12:37:20 <Luke> stepcut: http://acid-state.seize.it/
12:37:30 <Twey> You should probably define a datatype with an accessor
12:37:39 <arkeet> sclv_: fair, that's closer to the haskell definition
12:38:30 <elliott> non-infix on...
12:38:42 <applicative_> JordiGH: the 'programmer'ish aspect of applicative functors is the applicative aspect
12:39:43 <applicative_> JordiGH: the more 'categorical' definition would have pure :: a -> f a; pair :: (f a, f b) -> f (a,b)
12:40:23 <applicative_> rather than (<*>) :: f (a -> b) -> f a -> f b
12:40:36 <Fuco> Twey: I'm trying to keep it as simple aspossible. It's a rough "pseudoimplementation" of an algorithm
12:40:37 <arkeet> applicative_: the definition of a lax closed functor is basically the definition of Applicative http://ncatlab.org/nlab/show/closed+functor
12:40:52 <Fuco> it has to fit on 18 lines or so :P
12:41:21 <JordiGH> applicative_: I see.
12:42:54 <applicative_> arkeet: but why not the usual http://ncatlab.org/nlab/show/monoidal+functor
12:43:38 <arkeet> probably because the Applicative interface is more useful for programmers.
12:43:56 <sclv_> applicative_: they're equiv in power between two closed categories
12:44:20 <sclv_> but the closedness helps us thing about the "applicativeish" bit
12:45:05 <sclv_> so saying something is lax monoidal and lax closed is much more useful for situating it in categoryland than just one or the other
12:46:35 <acube> can I make a Typeable instance for a type like the following: data T a b f = T (f (T a b f)) ?
12:47:05 <applicative_> i see yes
12:47:31 <acube> deriving gives the error message: T must only have arguments of kind *
12:48:04 <acube> And I don't know how to define my own typeable instances correctly
12:48:12 <applicative_> it's a kind error yes
12:48:21 <c_wraith> acube: upgrade to GHC 7.8 >_>
12:48:25 <applicative_> oh wait
12:48:43 <byorgey> acube: it is certainly possible to make a Typeable instance for that in theory
12:48:48 <applicative_> it's typable47
12:49:41 <user123abc> is it correct to say that I need the $ in map read . words $ "1 2 3" :: [Int] because ($) has lower precedence than (.) ?
12:49:48 <acube> applicative_: What is typeable74 ?
12:49:54 <acube> typeable47*
12:50:53 <acube> c_wraith: once 7.6 finally gets into the platform, I'm getting things where I'd need features of GHC 7.8 ....
12:51:01 <sclv_> user123abc: nope
12:51:25 <user123abc> sclv_, why is the ($) necessary?
12:51:28 <sclv_> i guess you could say that that's why it works
12:51:38 <sclv_> but you could also write (map read . words) "1 2 3"
12:51:50 <user123abc> yeah, I'm aware
12:52:03 <byorgey> user123abc: if you simply omitted the $, it would parse as  map read . (words "1 2 3")
12:52:07 <Twey> Fuco: It'll get simpler if you define your datatypes right
12:52:11 <sclv_> you "need" it because $ has lower precedence than function application
12:52:12 <byorgey> because function application has higher precedence than .
12:52:15 <shachaf> quchen: I would say: Don't post it.
12:52:24 <applicative_> or map read $ words "1 2 3" and have done with it...
12:52:39 <user123abc> byorgey, right, the (words "1 2 3") is how I was seeing it
12:52:47 <user123abc> if parens and $ are omitted
12:52:52 <shachaf> But it seems that I'm excluded from saying things.
12:53:05 <sclv_> right -- so your understanding is pretty good, its just getting down a precise way of communicating it to us that you're working on now :-)
12:53:24 <user123abc> not really, I'm still missing a model of how expressions are evaluated
12:53:33 <sclv_> graph reduction
12:53:34 <quchen> shachaf: You can say things, but they would be more convincing if you gave reasons.
12:54:14 <sclv_> user123abc: i just saw this tutorial on the topic -- it may help: https://www.fpcomplete.com/user/mutjida/order-of-evaluation
12:55:05 <applicative_> reasons? shachaf don't don't need no stinkin' reasons
12:55:17 <user123abc> that looks like it's explaining lazy evaluation in cases where the semantics (syntax?) could allow for multiple orders
12:55:43 <user123abc> (and the laziness issue is what makes it hard for me to google around for a description of the semantics)
12:55:45 <sclv_> ok but that's my best understanding of what you're asking about?
12:55:59 <elliott> user123abc: I endorse http://www.vex.net/~trebla/haskell/lazy.xhtml
12:56:10 <applicative_> lazy v. strict, which is better, chapter xlxxii
12:56:40 <applicative_> non-strict is a complete pseudo-term.
12:56:49 <user123abc> sclv_, I wouldn't say so, but I can't explain why
12:57:17 <byorgey> user123abc: you can understand the syntax of expressions perfectly well without knowing anything about how they are evaluated.
12:57:32 <user123abc> byorgey, yes, and I'm trying to do exactly that
12:57:33 <elliott> applicative_: howso?
12:57:40 <user123abc> I'm not interested in lazy vs strict issues at this point
12:57:54 <byorgey> ok.
12:58:26 <acube> byorgey: How would that Typeable instance look like?
12:58:42 <applicative_> in my system, a function application with two args is bottom if the second arg is bottom, otherwise not
12:58:58 <byorgey> acube: well, you just have to construct a TypeRep
12:59:08 <applicative_> this is my non-strict 'semantics'
12:59:21 <byorgey> acube: see the documentation of Data.Typeable for tools to help you do that
12:59:47 <dav> I LOOOOOOVEEE HASKEEEEEEEEELLLLLLLLLLLll!!
12:59:52 <dav> (sorry I needed to vent it)
13:00:06 * applicative_ is will dav
13:00:10 <applicative_> with
13:01:43 <monochrom> I ♥ Haskell too
13:02:02 <Hafydd> I >>= Haskell
13:02:26 <user123abc> I Maybe <3 Haskell
13:02:29 <user123abc> we'll see :-)
13:02:35 <monochrom> did you know: "I heart Haskell" is valid by OED. "heart" is accepted as a verb.
13:02:41 <user123abc> I (Maybe <3) Haskell ?
13:02:57 <Hafydd> The symbol for "love" being asymmetric is more reflective of the cruel reality...
13:02:58 <simukis_> It's (Just <3)
13:03:03 <monochrom> another valid OED word is "lol"
13:03:22 <user123abc> I $ Maybe <3 $ Haskell
13:03:28 <Hafydd> (Just (<3)), surely.
13:03:43 <simukis_> Maybe ain't a constructor.
13:03:55 <sclv_> its a type constructor
13:03:56 <Iceland_jack> simukis_: It's a type constructor
13:03:58 <Iceland_jack> ,)
13:04:00 <Iceland_jack> ;)*
13:04:07 <monochrom> perhaps "I $ Maybe <3 $ Haskell" is a type
13:04:19 <simukis_> I meant data constructor :)
13:04:24 <user123abc> yeah good point
13:04:29 <user123abc> I clearly don't know shit :-)
13:05:48 <mgsloan> Hmm, yeah, ($) could actually be made into a type operator now.  Could be fun!
13:05:55 <monochrom> in these postmodern days of DataKinds, data constructor, type constructor, and kind constructor are interchangeable
13:19:57 <byorgey> monochrom: not quite, but they will be soon =)
13:23:10 <earthy> *:* *:☐ ☐:☐ ☐:* *whee*
13:29:52 <shachaf> hvr: I don't know about anyone implementing it. I've been vaguely hoping that someone would but if no one else does I'll probably just do it myself.
13:30:47 <hvr> shachaf: it'll get a bit more publicity now, and someone will jump on :)
13:30:55 <hvr> +maybe
13:31:18 <shachaf> That's the plan.
13:45:30 <tre> Hi, http://i41.tinypic.com/2vnhnh2.jpg <- can someone explain to me how this test works? how is anything tested by capturing packets before the Device Under test(DUT)? What does it test? Wouldnt this mean it is the conn orig that is under test? or what is the effect tested by such a capture?
13:46:18 * hackagebot monadLib 3.7.2 - A collection of monad transformers.  http://hackage.haskell.org/package/monadLib-3.7.2 (IavorDiatchki)
13:51:18 * hackagebot smtLib 1.0.4 - A library for working with the SMTLIB format.  http://hackage.haskell.org/package/smtLib-1.0.4 (IavorDiatchki)
13:56:18 * hackagebot taglib-api 0.1.1.1 - An FFI layer over TagLib's C bindings  http://hackage.haskell.org/package/taglib-api-0.1.1.1 (KyleCarter)
13:58:46 <tgeeky> is 'An FFI' correct? because it's really an interface?
13:59:16 <Clint> how do you pronounce 'FFI'?
13:59:32 <tgeeky> foreign function interface?
13:59:39 <Clint> then no
13:59:47 <Clint> but i say 'eff eff eye'
13:59:47 <tgeeky> i thought so :O
13:59:48 <arkeet> eff eff eye
13:59:59 <tgeeky> but it's still wrong there?
14:00:04 <Clint> no, there it's correct
14:00:47 <tgeeky> oh, i see, the e in eff
14:00:50 <tgeeky> weird.
14:00:54 <Clint> english
14:01:11 <hvr> Old MacDonald had a farm, Eff Eff Eye
14:01:21 <tre> please, can someone answer my post?
14:01:21 <tre> Hi, http://i41.tinypic.com/2vnhnh2.jpg <- can someone explain to me how this test works? how is anything tested by capturing packets before the Device Under test(DUT)? What does it test? Wouldnt this mean it is the conn orig that is under test? or what is the effect tested by such a capture?
14:01:31 <Clint> tre: does that have anything to do with haskell?
14:02:04 <geekosaur> tre, you might ask that in a channel about networks, as opposed to one about haskell
14:02:55 <RichyB> At least ask about the libpcap bindings first. ;)
14:03:23 <elliott> tre: are you dontdoMDMA?
14:04:41 <tre> i dont like mdma if thats what you are asking
14:04:56 <enigmuriatic> lol, weird first comment to see ^
14:05:18 <enigmuriatic> anyway, i was wondering, does getContents lazily return lines by default?
14:05:33 <enigmuriatic> or does it discern whether it needs to return a line or the whole file based on the context?
14:05:38 <arkeet> it lazily returns a list of characters.
14:05:52 <enigmuriatic> the whole file in a list?
14:06:11 <arkeet> the file is read as the list is evaluated
14:06:13 <tgeeky> enigmuriatic: it says in the docs. "returns all user input as a single string"
14:07:11 <elliott> tre: ok, never mind. (another user of your ISP by that name was persistently asking off-topic questions in the past few days)
14:07:35 <arkeet> so if you only evaluate the first 100 characters in the list, it will only read 100 characters from the file.
14:07:56 <arkeet> lazy IO is gross
14:08:02 <enigmuriatic> ah i see. the way Learn You a Haskell discussed its laziness made it sound like it returned lines
14:08:07 <enigmuriatic> arkeet, why?
14:08:38 <arkeet> well, for one thing, it's easy to accidentally make it less lazy than you intended.
14:08:43 <tgeeky> enigmuriatic: it consumes resources greedily and doesn't release them
14:08:59 <Twey> enigmuriatic: Evaluation of a lazy-IO'd value is impure
14:09:15 <Twey> You can get IO exceptions in ‘pure’ code, with no way to deal with them
14:09:22 <arkeet> unsafeGetContents? :p
14:11:29 <arkeet> evaluating the list causes side effects, so it's morally wrong. :p
14:12:21 <Twey> arkeet: getContents &c. use unsafeInterleaveIO
14:12:28 <arkeet> exactly.
14:13:44 <arkeet> enigmuriatic: note that depending on buffering, evaluation may block until e.g. an entire line has been input.
14:14:53 <mm_freak> the problem of unsafeInterleaveIO isn't really exceptions…  it's that the garbage collection loses track of some objects…  usually this works out fine, but not always
14:15:17 <FreeFull> I don't like lazy IO as much as I used to
14:15:30 <FreeFull> IO is the one place where strictness is good
14:15:40 <mm_freak> i don't like it either, but it's not because of exceptions
14:17:01 <carter> dcoutts: i hear you're the right person to talk to about using cabal to script interesting build processes
14:17:05 <Twey> IO exceptions thrown in pure code aren't enough to put you off it?  :þ
14:17:33 <carter> dcoutts  would you mind me pestering you with a few questions at some point in th next few days / week when you have time?
14:17:36 <mm_freak> Twey: considering that exceptions are semantically equivalent to bottom, not really
14:17:54 <josephle> Twey: Just another day in the life of a ML programmer
14:18:00 <Twey> Hehe
14:18:19 <mm_freak> Twey: look at it this way:  unsafeInterleaveIO, if exceptions were the only thing that could go wrong, would really move the decision whether something is bottom to the run-time
14:18:30 <Twey> mm_freak: But unsafeInterleaveIO can introduce bottom into values that would otherwise be completely safe
14:18:56 <mm_freak> so you have something, of which you can't make any precise statements about definedness…  it will reveal its definedness as you evaluate it
14:19:03 <mm_freak> that's the only thing exceptions do
14:19:05 <Twey> Hmn
14:19:10 <Twey> It's a point you make
14:19:25 <Twey> I suppose you could always pass ‘let x = x in x’ and get breakage anyway
14:19:45 <mm_freak> right, but in that case you can make statements about definedness before running the code
14:19:52 <mm_freak> this is the difference to unsafeInterleaveIO
14:20:30 <Twey> Well, I was thinking of the perspective of the function-writer
14:21:19 * hackagebot entropy 0.2.2 - A platform independent entropy source  http://hackage.haskell.org/package/entropy-0.2.2 (ThomasDuBuisson)
14:22:08 <mm_freak> Twey: from that perspective, again if exceptions were the only problem, unsafeInterleaveIO wouldn't be any worse than fromJust
14:22:21 <mm_freak> or an irrefutable Just-pattern on a Maybe value
14:24:22 <josephle> mm_freak: so unsafeInterleaveIO is bad due to memory issues?
14:25:15 <mm_freak> josephle: if you disregard the side effects in pure code it's resource issues
14:26:19 * hackagebot DRBG 0.5 - Deterministic random bit generator (aka RNG, PRNG) based  HMACs, Hashes, and Ciphers.  http://hackage.haskell.org/package/DRBG-0.5 (ThomasDuBuisson)
14:26:21 * hackagebot commsec 0.3 - Provide communications security using symmetric ephemeral keys  http://hackage.haskell.org/package/commsec-0.3 (ThomasDuBuisson)
14:27:14 <josephle> mm_freak: is this a philisophically unresolvable problem or is it because the GC never expects the unsafeInterleaveIO?
14:28:01 <mm_freak> josephle: no, the GC is still aware of everything…  the problem is that you may keep file handles open for longer than you intended
14:28:21 <josephle> ah, that makes sense
14:28:43 <mm_freak> a getContents string only closes the handle, when the string is fully known…  if you never consume the entire string you rely on the garbage collection
14:29:02 <mm_freak> and there is no way to tell the GC, "hey, i'm done with this"
14:29:55 <c_wraith> the GC knows your done with it as soon as there are no remaining code paths that might use the value.
14:29:59 <c_wraith> *you're
14:30:02 <josephle> one of these days I should just sit down and spend the time figuring out the internals of ghc
14:30:05 <mm_freak> combine this with the fact that in linux you get only 1024 file handles per process by default…  this is fine for a small command line application, but may become a hazard for a highly concurrent web application
14:30:08 <c_wraith> However, that doesn't mean it will actually collect it!
14:31:39 <Peaker> How does Haskell98 cope with FlexibleInstances when those are inferred?
14:31:59 <Peaker> i.e: You might have a definition's type inferred to be: (Functor f, Show (f a)) => ...
14:32:00 <mm_freak> Peaker: you mean flexible contexts?
14:32:08 <Peaker> Oops, yeah
14:32:49 <zammy> is this a quiz?
14:33:00 <elliott> Peaker: it works
14:33:04 <elliott> you just can't write a sig
14:33:06 <elliott> iirc
14:33:30 <mm_freak> i don't think h98 type inference ever infers a partially polymorphic type
14:33:30 <Peaker> elliott, according to the report, or according to ghc?
14:34:00 <Peaker> @type show . fmap id
14:34:01 <zammy> h98 != ghc right?
14:34:02 <lambdabot> (Functor f, Show (f b)) => f b -> String
14:34:16 <elliott> Peaker: the former. I may be wrong.
14:34:47 <Peaker> if there are inferred types you cannot write down, it makes for a silly situation
14:34:58 <Peaker> I guess this already happens for missing exports
14:35:07 <dolio> It is the situation, nevertheless.
14:35:28 <Peaker> but in this case, the whole notion of having FlexibleContexts as a thing is to make it easier to implement the language -- but this makes it seem like it needs to be supported/implemented anyway
14:35:39 <Peaker> might as well add it to the standard?
14:35:51 <mm_freak> related question:  is there anything wrong with FlexibleContexts that prevents it from making it into the language?
14:36:10 <dolio> Peaker: Inferring something and verifying something aren't the same thing.
14:37:09 <Peaker> dolio, hard for me to imagine it being easier to infer a flexible context than to verify some type is at least as general as a flexible context
14:37:23 <dolio> I don't know about flexible contexts in particular.
14:37:51 <dolio> But sometimes it's easier to infer things than to check things.
14:38:23 <dolio> It's probably not true for flexible contexts.
14:46:19 * hackagebot commsec-keyexchange 0.2 - Key agreement for commsec.  http://hackage.haskell.org/package/commsec-keyexchange-0.2 (ThomasDuBuisson)
14:49:56 <hrookie> say, I'm using lenses from Control.Lens -- is it possible to export lenses with the templatehaskell pragma for use in other moduels, or not? is this considered bad practice?
14:51:03 <hrookie> templatehaskell pragma and makeLenses****
14:51:08 <hiptobecubic> hrookie, does it even work? also try #haskell-lens maybe
14:51:52 <hrookie> hiptobecubic: "does it even work" - control.lens, you mean? and thanks for the pointer~
14:52:06 <hiptobecubic> hrookie, i mean what you're specifically trying to do.
14:53:14 <hrookie> hiptobecubic: yes, i'm just operating on records.
14:53:31 <hiptobecubic> i mean the cross module thing
14:53:54 <hrookie> hiptobecubic: well, i've got a few modules that i'm building up into a bigger package, and i'm using lenses in some modules that are lower-down, and i want to be able to use them as i build upon them
14:54:04 <acowley> What's the best way to define values for use in doctest tests?
14:54:46 <hiptobecubic> hrookie, ok sure. I'm asking you if you have actually tried doing it? Are you just asking if it's "haskelly" to do this or are you asking if it is possible at all?
14:54:56 <lispy> acowley: hmm...I bet edwardk would know
14:55:23 <edwardk> acowley: make a $setup block
14:56:23 <edwardk> Put something like -- $setup\n-- >>> let x = somethingI'mGoingToUseALot  -- after the last import directive, and then write the rest of your tests elsewhere as usual.
14:56:27 <hrookie> hiptobecubic: it wasn't working. i got the low-down from our friend edwardk in haskell-lens :)
14:57:09 <acowley> edwardk: I have to use funny syntax to give type signatures to values defined in that way, right?
14:57:36 <edwardk> acowley: foo = (blah :: SomeType) -- yes
14:57:47 <acowley> :( This makes the test unreadable
14:57:51 <edwardk> or let foo :: SomeType; foo x = ...
14:58:18 <edwardk> i tend to limit myself to putting things in the $setup block like imports or 'obvious' definitions.
14:59:02 <acowley> edwardk: Yeah, I should just make these unit tests. Fighting the syntax seems like a code smell to me.
15:06:32 <adnap> Does http://hackage.haskell.org/packages/archive/hint/0.3.3.6/doc/html/Language-Haskell-Interpreter.html#v:setImports actually import modules, or just guarantee that they will be?
15:45:05 <tre> can someone explain this to me. You want to test how device B behaves under load. So you send data from A to B. Then you add some traffic to the network while you send data from A to B. you catch the data with a capture device between A and B. I dont get how this tests B. Since it only receives. Doesnt it test A?
15:45:13 <tre> #networking doesnt answer
15:45:38 <mauke> tre: how is this a haskell question?
15:46:43 <shachaf> #networking doesn't answer, therefore it is a Haskell question.
15:47:21 <shachaf> If #haskell doesn't answer perhaps it will become a Bitcoin question or an Ubuntu question.
15:47:52 <koala_man> fair enough. tre: perhaps it's a TCP based protocol where B sends ACKs indicating how much it's consumed?
15:48:44 <arkeet> koala_man: I believe shachaf was being sarcastic.
15:48:56 <arkeet> I mean.
15:49:01 --- mode: ChanServ set +o elliott
15:49:02 <arkeet> he wasn't being sarcastic at all. totally.
15:49:16 --- mode: elliott set +q $a:mrBG
15:49:20 --- mode: elliott set -o elliott
15:49:35 <elliott> they were already told their networking questions are off-topic
15:50:33 <koala_man> arkeet: your hypothesis warrants further research
15:53:31 <madjestic> do I sense sarcasm?
15:54:25 <koala_man> did everyone develop a six sense while I was playing android games in the bathroom?
15:57:23 <chrisdotcode> hello all
15:57:46 <quchen> koala_man: You didn't have to tell us you went to the bathroom. We knew.
15:58:14 <koala_man> that's game integrated social media for you
16:02:21 <roconnor> is Seq an instance of Applicative?
16:06:53 <roconnor> I guess I can use WrappedMonad
16:09:37 <elliott> huh, it seems not to
16:20:52 <roconnor> Is there something like (Applicative f, Monoid m) => Monoid (f m) somewhere?
16:21:23 <roconnor> with mempty = pure mempty and x <> y = (<>) <$> x <*> y
16:22:19 <acowley> roconnor: We were just talking about that in #lens. I don't think there is.
16:23:17 <roconnor> #haskell-lens ?
16:24:04 <edwardk> roconnor: http://hackage.haskell.org/packages/archive/monoids/0.3.2/doc/html/src/Data-Monoid-Applicative.html#App but i don't think i ported it out of monoids into a more modern package yet
16:25:06 <roconnor> ah
16:25:54 <roconnor> seems like it ought to be in base in Control.Applicative
16:26:24 <edwardk> probably. i have several monoids like that one.
16:26:40 <edwardk> i should probably put together a semigroup-extras package with them
16:27:12 <edwardk> or just bolt them into the semigroups package to the hue and cry of the minimalists in the crowd.
16:29:30 <nan`> l.o.
16:36:34 <acowley> edwardk: Shall I push a new branch with all the new Plucker stuff for your inspection?
16:37:00 <edwardk> or just make the changes to master
16:37:20 <edwardk> i don't have any applications for the existing code, so if you have a use for yours, your interest trumps my apathy ;)
16:37:23 <acowley> edwardk: I'll wait on that. I need to figure out some of your definitions since they differ from mine
16:37:30 <edwardk> k
16:37:53 <acowley> I don't know that I have a use for it, but I needed to learn it.
16:37:55 <edwardk> mine was written from a several year old memories ;)
16:38:10 <edwardk> so beware. some of the randomness may be just that
16:38:41 <acowley> edwardk: Understood. I guess I just want some review on my definitions, and then we need to retire old definitions if they are indeed broken.
16:38:46 <edwardk> i have a thesis lying around somewhere that gives the math to my version i think
16:39:05 <acowley> edwardk: I've added a handful of unit tests for my parts that are at least demonstrating some amount of sanity
16:39:07 <edwardk> well, its on comonad.com and the server is down right now and i don't have the ip for the new box yet
16:39:11 <nan`> what is a good way to apply a single function to a bunch of homogenous things in the same type class, i.e. http://pastebin.com/tv4TD5dP (which will not work since its list members are homogenous)
16:39:16 <mauke> The paste tv4TD5dP has been copied to http://hpaste.org/88437
16:39:34 <nan`> thanks mauke, hehe
16:41:34 <nan`> basically i want that table [F.fileMode, F.fileOwner, ...] to be easily updatable
16:42:34 <nan`> maybe i add F.fileSize later
16:44:09 <acowley> nan`: Something like, map ($ status) [show.foo, show.bar]
16:45:33 <dwcook> What properties would some function f :: a -> b -> b have to have so that when you fold with it, the order of the elements doesn't matter?
16:45:55 <dwcook> I think you need f a (f b c) = f b (f a c), but I'm not sure if that has a name
16:47:10 <josephle> dwcook: that almost looks like commutativity
16:47:26 <dwcook> Right, but you don't necessarily need f to be an operation
16:49:05 <nan`> acowley: i was hoping there would be a better abstraction?
16:49:27 <copumpkin> sequence [show.foo, show.bar] status
16:49:50 <nan`> i don't like have show on the inside
16:49:56 <copumpkin> then don't!
16:50:00 <nan`> i want it factored!
16:50:26 <copumpkin> oh, are they not homogeneous?
16:50:32 <acowley> nan`: It seems like you're edging towards wanting existential types, which means I have the duty to link http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
16:50:33 <nan`> no =(
16:50:51 <nan`> yes or a preprocessor would also help
16:50:52 <copumpkin> nan`: you can make an existential, but it's not much better than just calling show
16:51:16 <nan`> show is bad because i can't build a generic operation and apply it to the collection
16:51:24 <nan`> plus if i need to use that group in some other way in the program, i have to repeat everything
16:51:30 <copumpkin> what would you be generic over?
16:51:33 <copumpkin> what do they all share?
16:51:47 <acowley> If you're re-using the group, you should use a data type with distinct fields.
16:51:49 <nan`> they are all type Show i want to show them and in this case hash them
16:52:09 <copumpkin> yes, but when you say "if I need to use that group in some other way" or "I can't build a generic operation"
16:52:19 <copumpkin> what properties do they all share beyond show that you envision needing?
16:52:32 <copumpkin> since any generic operation you devise will need to know about it
16:54:10 <nan`> say suddenly i need to use them as Storable
16:55:16 <nan`> acowley: a datatype, ok hm
16:55:35 <copumpkin> so take what you know about them when you build the group and save it :P
16:55:47 <copumpkin> because you're not going to be able to find it out later
16:57:48 <josephle> what was the reasoning for making 'forall' the keyword for existential types?
16:59:00 <c_wraith> existential/universal duality
16:59:25 <c_wraith> A universal quantification inside a datatype is an existential quantification outside of it
17:00:04 <josephle> huh
17:00:51 <elliott> josephle: it gives the constructor a forall type
17:00:58 <elliott> data Foo = forall a. Bar a
17:01:01 <elliott> Bar :: forall a. a -> Foo
17:01:28 <josephle> elliott: what I'm asking is why forall, which is associated with universal types, being used as the keyword for existential types
17:01:34 <josephle> but c_wraith answered my question
17:01:43 <elliott> because an existential type corresponds to giving the constructor a universal type
17:01:46 <elliott> as I said
17:01:54 <elliott> you're defining the /constructor/ Bar
17:01:59 <josephle> ah
17:02:14 <nan`> wait classes can be used as data types?
17:02:20 <nan`> i'm lost
17:02:29 <c_wraith> nan`: no, they can't. where are you seeing that?
17:02:42 <nan`> in that exi page http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
17:03:07 <nan`> "See how this is going? Classes become data types, instances become functions."
17:03:33 <c_wraith> nan`: Oh, that's talking about how you would rewrite things
17:03:40 <nan`> oh ok
17:03:45 <c_wraith> nan`: it's saying "instead of using a class, use a data type"
17:04:02 <nan`> it's theoretical
17:04:06 <nan`> ??
17:04:11 <nan`> oh
17:04:21 <nan`> i think i see let me read it again
17:04:22 <merijn> nan`: No, it's saying "you should do this instead"
17:04:27 <c_wraith> Well, it's suggesting a different (and it claims more useful) pattern for implementing the same functionality
17:04:41 <c_wraith> Having used both, I think I agree about 90%
17:04:49 <dmwit> josephle: The real reason is to avoid snagging more keywords.
17:05:24 <dmwit> forall is a terrible name for it, and is also a terrible name for the ScopedTypeVariables usage. But it's already a keyword, so nothing can possibly break by using it...
17:05:27 <dmwit> =/
17:05:33 <elliott> well, just using "exists" instead would be a bit misleading
17:05:38 <elliott> given the general structure of constructor definitions
17:05:42 <merijn> GADT syntax is much nicer for existentials anyway
17:05:47 <elliott> GADTs -- yes, that
17:06:00 <c_wraith> UHC has an exists keyword
17:06:20 <c_wraith> It isn't actually all that useful..  You can't use it with a class constraint.
17:06:42 <cmccann> clearly the ideal solution is to make ∃ a keyword.
17:06:42 <shachaf> forall is a terrible name for what?
17:06:49 <shachaf> ExistentialTypes as it's implemented in GHC?
17:06:54 <cmccann> does unicode syntax allow ∀? I can't recall.
17:07:05 <elliott> yes iirc
17:07:09 <merijn> shachaf: Yes
17:07:18 <shachaf> The exists keyword is completely different from forall. forall is the right keyword for the way GHC does existentials.
17:07:51 <shachaf> data Type a = Blah a => Con a -- just like you have =>, not *>, you should have forall, not exists
17:07:55 <merijn> "data Foo where Bar :: a -> Foo" <- the only right way to write existentials!
17:08:14 <arkeet> Bar :: forall a. a -> Foo
17:08:17 <shachaf> exists would belong on the *right* side of the constructor. But there's no good way of doing that.
17:08:29 <merijn> arkeet: That's unnecessary
17:08:48 <shachaf> dmwit: What's your proposed syntax instead of forall?
17:08:53 <merijn> arkeet: The forall is implicit in "Bar :: a -> Foo"
17:09:10 <arkeet> I know
17:10:06 <cmccann> shachaf: "data Foo = Foo (forall a. a)" works fine. using exists instead would be syntactically straightforward.
17:10:29 <merijn> cmccann: That requires ImpredicativeTypes, doesn't it?
17:10:39 <cmccann> no
17:10:45 <shachaf> cmccann: OK, how about data Foo = forall a. Foo a (a -> Int)?
17:10:53 <shachaf> How would you use exists instead?
17:11:17 <josephle> I'm getting confused now. Is there something inherently different with haskell existentials than with existential types defined in PL literature?
17:11:19 <cmccann> data Foo = Foo (exists a. (a, a -> Int))
17:11:36 <elliott> cmccann: ew.  josephle: not really
17:11:44 <shachaf> cmccann: What elliott said.
17:11:48 <merijn> josephle: No, it's just the matter of how not hogging keywords and the specific way they're implemented
17:12:00 <elliott> cmccann: also, not technically the same. _|_s and so on.
17:12:08 <shachaf> cmccann: Also, what elliott said.
17:12:09 <cmccann> yes, but you already have to do the same thing in some cases with forall.
17:12:17 <cmccann> exists would be no worse syntactically.
17:12:19 <merijn> "data Foo where Foo :: a -> (a -> Int) -> Foo"
17:12:24 <merijn> GADT wins again!
17:12:34 <shachaf> cmccann: Now what do you do about constraints? Do you introduce *>?
17:12:36 <dmwit> I dunno. What's so awful about "data Foo = exists a. Foo a (a -> Int)"?
17:12:57 <shachaf> dmwit: The main awful thing is that it doesn't make any sense.
17:13:08 <merijn> shachaf: Eh...why not?
17:13:10 <shachaf> How do you add a constraint?
17:13:23 <josephle> ah this example finally makes sense
17:13:39 <dmwit> exists a. data Foo = Foo a (a -> Int)
17:13:46 * cmccann constrains shachaf
17:14:10 <dmwit> No, I take that back.
17:14:17 <dmwit> Anyway, I don't see why constraints should be hard.
17:14:22 <shachaf> OK, maybe it's not as senseless as I thought...
17:14:25 <dmwit> data Foo = exists a. Ord a => Foo a (a -> Int)
17:14:27 <shachaf> Is it?
17:14:34 <shachaf> dmwit: Ugh. exists a. Ord a =>?
17:14:46 <dmwit> It parallels forall a. Ord a => very nicely, don't you think?
17:15:07 <shachaf> Except for the part where => makes sense with forall and not with exists.
17:15:07 <cmccann> I bet shachaf would be happier if the type variables had umlauts.
17:15:16 <shachaf> cmccann: tremas
17:15:25 <dmwit> But forall doesn't make sense here.
17:15:26 <shachaf> dmwit: forall is a function. => is a function. exists is a tuple.
17:15:35 <cmccann> shächäf: pf whatever, same diff
17:15:50 <dmwit> => is a tuple when used with exists.
17:15:55 <dmwit> => is a function when used with forall.
17:15:56 <dmwit> Deal with it.
17:16:07 <shachaf> c̈m̈c̈c̈än̈n̈: hi
17:16:16 <cmccann> yes good
17:16:22 <elliott> exists doesn't make sense there. forall does.
17:16:22 <shachaf> No, that's nonsense, because => can be used standalone.
17:16:26 <cmccann> if only I could really set that as my nick.
17:16:29 <elliott> thus says elliott.
17:16:41 <cmccann> elliott: you don't make sense there.
17:16:54 <shachaf> forall a. ... -> (Blah a => ...) -> ... -- no forall next to the =>!
17:17:00 <shachaf> exists a. ... -> (Blah a => ...) -> ...
17:17:16 <shachaf> => and *> (ski's notation for the tuple) just mean different things.
17:17:23 <shachaf> (Was that ski? I think it was ski.)
17:17:38 <Aura> Hi there! may i ask a question about java programming?
17:18:01 <cmccann> Aura: the answer is don't use java
17:18:03 <cmccann> it's terrible
17:18:03 <sipa> does Java have closures these days?
17:18:08 <nimdAHK> lol
17:18:23 <geekosaur> why would you come to #haskell to ask about java?
17:18:28 <dmwit> Aura: Perhaps you should try a Java channel.
17:18:39 <cmccann> geekosaur: I bet we give better advice than #java.
17:18:46 <cmccann> for example I bet they wouldn't advise not using java.
17:18:51 <Aura> all of them have problems!
17:18:54 <cmccann> q e f'in d.
17:19:21 <shachaf> Aura: This Java channel also has problems.
17:19:23 <Aura> ok, tnx; seems that today isn't my day!
17:20:22 <nimdAHK> How To Get Rid of a Java Programmer, Volume 1
17:20:27 <elliott> bizarre.
17:22:05 <dmwit> I feel quite good about what just happened.
17:22:16 <dmwit> I'm sorry for Aura and all, but I'm happy for the community.
17:22:30 <cmccann> dmwit: hey, I was totally helpful.
17:30:56 <nan`> my teeth feel dirty
17:35:0