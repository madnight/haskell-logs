00:02:13 <doomlord> that looks like the error it was giving
00:03:44 <doomlord> (ok  now  i see - my extra function adds a signature that says whhat type of Vertex3 to use)
00:04:19 <Ralith> is something wrong with your h key?
00:04:45 <doomlord> i have a crappy keyboard on this laptop yes
00:05:13 <doomlord> spacebar sticks, etc...
00:23:54 <Fuuzetsu> > 1
00:23:54 <kappabot>   1
00:24:10 <Fuuzetsu> RIP lambabot
00:26:51 <supki> @ty (^@..)
00:26:52 <kappabot> Not in scope: `^@..'
01:01:51 * hackagebot language-slice 0.2.0.0 - AST and parser for the ZeroC Slice language (Specification language for ICE)  http://hackage.haskell.org/package/language-slice-0.2.0.0 (PaulKoerbitz)
01:04:18 <hpaste_> “Dharmender Kumar” pasted “Deal @ +91-261-3090200 Nursing Scrubs Service” at http://hpaste.org/87945
01:05:02 --- mode: ChanServ set +o shachaf
01:05:46 --- mode: shachaf set +q *!*hpaste@*
01:06:14 <quchen_> Noooo! Hpaste! :-(
01:06:53 --- mode: shachaf set -o shachaf
01:07:00 <mauke> preflex: seen chrisdone
01:07:00 <preflex>  chrisdone was last seen on #haskell 2 days, 13 hours, 28 minutes and 38 seconds ago, saying: (●´∀｀●) it's beautiful …
01:07:07 <shachaf> Oh, I missed him.
01:07:23 <shachaf> Maybe someone should send an email or something.
01:07:53 <quchen_> I @told him a week ago
01:08:05 <quchen_> Didn't get an answer though
01:08:20 <mauke> chrisdone@gmail.com
01:09:53 <johnw> quchen_: what's the question?
01:10:43 <quchen_> johnw: Not a question. Chrisdone is the guy behind HPaste, which is heavily spammed the last couple of weeks.
01:11:03 <johnw> ah, ok
01:11:13 <mauke> speak of the devil
01:11:15 <johnw> chris is my co-worker now, so I'll mention it to him
01:11:34 <chrisdone> johnw's got my chrisman sign =p
01:12:29 <shachaf> chrisdone: The hpaste spam is getting really annoying. I +qed the bot for now.
01:12:35 <shachaf> Can something be done about it?
01:12:56 <shachaf> For what it's worth it's all been by the author "Dharmender Kumar" recently.
01:13:03 <Kinnison> It'd be nice if people had to get a token from hpaste on IRC before pasting
01:13:04 <shachaf> Not that a filter on that is likely to work in the long term.
01:13:06 <Kinnison> (IMO)
01:13:18 <chrisdone> sure. i can see if the spam is coming from the same IP and ban it int he short term
01:13:30 <quchen_> That'll be effective for 24 hours.
01:14:04 <quchen_> Have you considered the "require a certain amount of time for a paste" solution?
01:14:26 <quchen_> Even if you copy+paste the code in there, you'll need say 3 seconds. A bot is faster than a human.
01:14:28 <johnw> how about the "solve this type error before you can paste"
01:14:44 <quchen_> johnw: Captchas are awful.
01:14:50 <johnw> yeah, just a joke
01:15:01 <quchen_> So are captchas. ;-)
01:15:22 * Kinnison thinks getting a token from the bot on IRC would be reasonable.  It's not like it would have to expire.  And if a token is used to spam, you can expire just that one.
01:15:33 <Kinnison> Spammers are unlikely to want to go through that complexity
01:15:36 <chrisdone> Kinnison: i think the a proportion of irc announcers are newbies who don't care to go get a token
01:16:07 <mauke> I'd only restrict the "announce on #haskell" option
01:16:13 <Kinnison> That'd be fine
01:16:14 <chrisdone> alternatively we could just match up the name field with irc's nick
01:16:24 <chrisdone> mauke: restrict it how?
01:16:32 <quchen_> Another effective strategy is having a dummy field with an "email" label or something, which is then hidden using CSS (!). Bots will most likely fill out that field, hence identify themselves as such.
01:16:45 <mauke> dunno
01:16:48 <quchen_> Just make sure it's clear nothing is to be entered in that field (think of no CSS agents etc)
01:17:13 <mauke> you could use the token thing, a captcha, or require a valid nick
01:17:28 <chrisdone> quchen_: that already exists, a hidden email field. it stops 90% of bots
01:17:34 <Kinnison> chrisdone: Only allow announcing on #haskell if the nick matches someone already on the channel?  Or perhaps require a token from IRC if you want to announce on IRC
01:18:32 <quchen_> chrisdone: What about the timer thing?
01:19:21 <mauke> quchen_: timer between what?
01:20:11 <quchen_> mauke: Requiring a minimum and maximum time to fill out the paste. Minimum gets rid of the bots requesting and immediately sending, maximum time beats cached botnet requests.
01:20:22 <mauke> quchen_: timer between what?
01:20:53 <quchen_> mauke: Getting the page and sending the POST request
01:21:07 <chrisdone_> did i miss anything important?
01:21:27 <mauke> chrisdone_: we have public logs :-)
01:21:34 <canta> could be checked if it contains any valid haskell?
01:21:43 <merijn> mornin'! Is the freenode DDOS still on-going or is it just my connection that's slow this morning
01:21:45 <quchen_> canta: That rules out pseudocode
01:22:13 <mauke> quchen_: feels icky
01:22:22 <quchen_> mauke: Why?
01:22:28 <Saizan> matching nick on chan seems the best bet
01:22:38 <chrisdone_> yeah i think so
01:22:47 <chrisdone_> only problem is shachaf will not be able to use the announcer
01:22:47 <mauke> now you're requiring a GET and have to correlate it with a POST
01:23:13 <mauke> and of course it would complicate my repaster a bit
01:23:14 <chrisdone_> (but i don't suppose he cares, either =)
01:23:25 <Saizan> maybe specify the author field should be a nick in the form
01:23:39 <chrisdone_> Saizan: nod
01:23:41 <shachaf> Allow Anonymous Coward as the author.
01:24:23 <quchen_> mauke: The idea is adding a hidden field with a timestamp and a hash so it can't be faked. The POST gets this timestamp, verifies it, and can then calculate how much time has been between GET and POST. No DB needed, only a secret salt or something.
01:24:27 <chrisdone_> shachaf: haha, ok
01:24:55 <mauke> quchen_: I know how to do it
01:25:27 <mauke> quchen_: it's just that I don't visit the form page, ever
01:25:54 <quchen_> Well your repaster is a bot/script, which is precisely what we're trying to get rid of.
01:26:07 <mauke> not just my repaster
01:26:17 <mauke> when I use a web pastebin, it's from the command line
01:26:21 <quchen_> Ah, all the auto-HPaste scripts
01:26:24 <quchen_> Hmm.
01:26:45 <mauke> on the other hand, maybe those don't need to announce
01:26:55 <mauke> my repaster certainly doesn't
01:26:58 <shachaf> mauke's bot is good.
01:27:05 <shachaf> We're not trying to get rid of bots, we're trying to get rid of spam.
01:28:39 <quchen_> I guess the nickname comparison with the channel could work as well then. Just make sure to add "nick_" etc to the comparison list or I'll be screwed ;-)
01:29:32 <shachaf> It's not so bad if it doesn't announce.
01:29:58 <shachaf> It's OK to have false somethingitives for your filter. People can always announce by themselves.
01:30:09 <quchen_> That'll get rid of the IRC part of the spam, but HPaste will still be hosting tons of porn links in that case.
01:30:13 <mauke> ~party soft~
01:30:40 <mauke> quchen_: you could use a keyword filter :-)
01:31:37 <quchen_> mauke: Filter this :P http://hpaste.org/87943
01:31:58 <quchen_> Okay, that's very innocent spam.
01:32:45 <mauke> quchen_: easy, require more than one line of content
01:33:06 <mauke> and there are no porn links there
01:34:30 <chrisdone_> mauke: weirdly i have access logs from "GET /87943%0F HTTP/1.1" 302 0 "-" "irssi/0.5 libwww-perl/6.04" for that. it seems to be the same one creating pastebin thingies. do you have some way to read pastes from your irssi?
01:35:51 <mauke> %0F? what the heck
01:36:33 <chrisdone_> yeah, dunno what that is either
01:36:40 <chrisdone_> it's on all of them
01:37:26 <chrisdone_> anyway, won't get fixed before the end of today so i made a ticket: https://github.com/chrisdone/hpaste/issues/15
01:37:31 <chrisdone_> laters
01:39:07 <hiptobecubic> It's such a strange way to advertise.
01:39:35 <quchen_> hiptobecubic: I think the main purpose is SEO, not using HPaste directly.
01:39:39 <hiptobecubic> Is it really *that* effective to advertise fitness classes in mumbai in a channel about programming languages?
01:39:50 <hiptobecubic> ah yes
01:40:04 <hiptobecubic> is hpaste even indexed?
01:40:09 --- mode: ChanServ set +o shachaf
01:40:10 <quicksil2er> yes, hpaste is indexed
01:40:19 --- mode: shachaf set -q *!*hpaste@*
01:40:20 <quicksil2er> however, such attempts at seo probably don't work any more
01:40:23 --- mode: shachaf set -o shachaf
01:40:32 <quicksil2er> but since it's so hard to test I expect people do it anyway
01:40:40 <quchen_> Indexed? ... it's a website, why shouldn't it be indexed?
01:40:51 <quicksilver> quchen_: many possible reasons.
01:41:09 <quicksilver> its authors may have asked for it not to be indexed, or google might choose not to.
01:42:23 <quchen_> Makes sense.
01:43:13 <quchen_> Why shouldn't such SEO work though? I can hardly see a filter that gets rid of spam like this on a global scale.
01:43:17 <mauke> quchen_: can you repeat your "filter this" message, please?
01:43:22 <hiptobecubic> It's a shame google doesn't do grammatical analysis, then these would be pretty easy to filter :)
01:43:35 <quchen_> <quchen_> mauke: Filter this :P http://hpaste.org/87943
01:43:50 <mauke> hmm, no errors
01:44:38 <mauke> timestamps of the %0F thing would be useful
01:44:51 <quchen_> 0F is space, right?
01:44:59 <mauke> no
01:45:13 <quchen_> Oh, that was 1F
01:46:53 <quchen_> Nope, still wrong. Well, 0F seems to be some very odd character.
01:47:40 <mauke> it's ^O, which makes some sense for IRC at least
01:47:45 <quchen_> Shift-in. Hm. Makes me wonder how much of the first 30 characters are still used in practice.
01:48:03 <mauke> but I can't find anything like it in my fetch logs
02:10:29 <osa1> do we have a library like gloss but for drawing trees and graphs? I will need to update graph/tree structure dynamically and drawing should be able to reflect the changes(ie. calling graphviz doesn't work)
02:17:24 <mstksg> hi all :)
02:23:50 <idntfy2> just tried to write hello world with happstack. I've nearly died when forced to work ctrl+c in cmd with runhaskell.
02:24:35 <Hafydd> idntfy: you nearly died?! What was it like?
02:27:46 <Zeev> some newbie questions: i've installed haskell platform, how do I ran cabal?
02:27:58 <Zeev> my os windows
02:28:27 <merijn> Zeev: You can just open cmd.exe and/or powershell to run cabal
02:29:34 <Zeev> i don't see no cabal.exe in my haskell\2012.4.0.0\bin
02:29:44 <Zeev> ^^^ merjin:
02:30:10 <merijn> Have you tried just typing "cabal" in the command prompt? I think the Platform install should fix your path automagically
02:31:18 <Zeev> merjin: thanks, i've found it in lib\extralibs\bin
02:39:30 <mstksg> does anyone mind helping me with a problem having to do with composing IO/MonadRandom?
02:39:33 <mstksg> my code is at https://gist.github.com/mstk/0449822b1832ca6344b9
02:39:49 <mstksg> basically i want a way to reapply a function to itself a million times
02:40:00 <mstksg> where the function is from MonadRandom
02:40:15 <mstksg> but my method right now ends up chaining IO's so deep the stack can't handle it :'(
02:44:30 <ocharles> :t replicateM
02:44:30 <kappabot> forall (m :: * -> *) a. Monad m => Int -> m a -> m [a]
02:44:35 <merijn> That doesn't have anything to do with the IO/random and more with the strictness of your computation, afaict
02:44:49 <merijn> i.e. you're building a massive thunk in DoublePath, I think
02:45:11 <mstksg> yeah the first time i had ever even heard of a thunk was when researching this
02:45:26 <ocharles> hmm yes, try 'data Path = DoublePath !Double'
02:45:43 <ocharles> though that's probably not the entire problem
02:45:51 <mstksg> @ocharles replicateM seems to only do the same computatoin multiple times?  but in this case each one is dependent on the last?  it's more like a fold, isn't it?
02:45:51 <kappabot> Unknown command, try @list
02:46:05 <ocharles> yea, replicateM isn't what you want, I was just double checking
02:46:54 <mstksg> the bang doesn't seem to do anything :(
02:47:20 <merijn> kappabot: The point is, every time you unwrap the DoublePath in step it's not actually evaluating the computation, it's just making a new thunk referring to the old one (until you eventually force everything in the end)
02:47:33 <ocharles> the bang just makes (x + dx) / x strict
02:47:46 <merijn> Which means you're creating a list of 1,000,000 thunks when running this
02:47:53 <ocharles> but you'll still build up 1million thunks
02:47:54 <ocharles> right
02:47:57 <merijn> Doesn't it need BangPatterns?
02:47:59 <mstksg> merijin yeah i think i got that far, but how do i force it before it reaches that huge thunk?
02:48:19 <ocharles> merijn: no, bang patterns are for strict pattern matches
02:48:37 <merijn> mstksg: I'm not great at this, but maybe "step (DoublePath !x) =" would worh when used with BangPatterns
02:49:32 <merijn> Someone tell me I'm right? :x
02:49:41 <ocharles> this stuff isn't my forte either :(
02:49:43 <mstksg> merijn it doesn't seem to do anything :(
02:49:50 <ocharles> I'd just randomly throw seq and evaluate at it
02:49:59 <merijn> mstksg: Did you compile with "-XBangPatterns"?
02:50:09 <mstksg> yeah i did, it compiled fine but still overflow
02:50:21 <mstksg> how would i use seq here?
02:50:36 <johnw> why not make the data type strict?
02:50:41 <johnw> DoublePath !Double
02:51:12 <mstksg> johnw we tried that heh
02:51:12 <ocharles> I suggested that
02:51:17 <ocharles> It also doesn't overflow here
02:51:19 <johnw> i'm also not sure about the Rand monad
02:51:29 <mstksg> hm it doesn't overflow for you ocharles?
02:51:29 <johnw> what happens when you do a million >>= invocations
02:51:32 <mstksg> did the original code overflow?
02:51:39 <ocharles> no
02:51:44 <ocharles> I downloaded that gist and it works
02:51:45 <merijn> Me neither, I was gonna try it, but I don't have Control.Monad.Random, apparently
02:51:48 <ocharles> it's a bit slow, but it does work
02:52:12 <mstksg> huh it must be my system
02:52:29 <merijn> Did you compile with -O2?
02:52:36 <merijn> If not, did you, ocharles?
02:52:42 <ocharles> no
02:52:45 <ocharles> runghc
02:52:52 <mstksg> oh i did not
02:52:56 <mstksg> what does that even mean haha
02:53:00 <mstksg> it runs fine now
02:53:09 <merijn> mstksg: -O2 is with optimisations
02:53:40 <merijn> You almost always want to compile with -O2
02:53:45 <johnw> or at least -O
02:54:37 <mstksg> okay the O2 works but in my original more computationally intensive code, it is still overflowing
02:55:14 <mstksg> i think i just want a general way to prevent that giant thunk buildup
02:55:30 <merijn> mstksg: That would be "data DoublePath = DoublePath !Double"
02:55:34 <johnw> yep
02:55:55 <merijn> mstksg: The ! says that that field should be strict, i.e. no thunks
02:56:23 <johnw> but that doesn't mean that the list won't contain thunks
02:56:26 <mstksg> okay let me ! up my actual code
02:56:32 <johnw> you have a list filled with thunks that build up calls to >>=
02:56:39 <merijn> oh, right
02:57:47 <merijn> iterate isn't strict, I guess
02:58:22 <johnw> no, and since each element N references the computation in element N-1, the millionth element is a million binds
02:58:35 <mstksg> where do i put the ! in record syntax?
02:58:47 <merijn> mstksg: Just in front of the name of the field
02:59:13 <merijn> Wait, no, I think it's "data Foo a = Foo { field :: !a }"
02:59:42 <mstksg> compiler isn't too happy with that; i'm using a concrete type though
03:00:06 <johnw> what about something like this:
03:00:15 <johnw> thecomputation = foldM (const (step acc)) (return (DoublePath 10.0)) [1..1000000]
03:00:24 <johnw> oops
03:00:34 <johnw> thecomputation = foldM (\acc _ -> step acc) (return (DoublePath 10.0)) [1..1000000]
03:00:43 <mstksg> actually nvm
03:01:08 <mstksg> i put ! in front of types in functions
03:01:25 <mstksg> johnw i've tried foldM too but ti doesn't seem to make a difference
03:01:38 <mstksg> in exactly the same syntax
03:01:38 <johnw> thecomputation = foldM (\!acc _ -> step acc) (return (DoublePath 10.0)) [1..1000000]
03:01:44 <mstksg> oh ok
03:02:48 <mstksg> well good news is that stricting up all of my data type constructor types
03:02:52 <mstksg> has fixed all my problems
03:02:53 <mstksg> :)
03:02:56 <mstksg> thanks guys
03:03:05 <mstksg> this is my first time running into stack overflow/thunk problems
03:03:25 <mstksg> and the dark side of lazy evaluation
03:03:51 <johnw> I wouldn't call it a dark side
03:03:53 <johnw> it's just a side
03:04:05 <johnw> strict programs have their own problems, like algorithm fusion
03:04:13 <Hafydd> Only a Sith deals in absolutes.
03:04:42 <mstksg> i guess i'll explore it more
03:04:47 <mstksg> this is only my third or fourth haskell project
03:09:32 <Zeev> how do I quit from ghci (on windows)? quit exit Ctrl-c doesn't seem to work
03:09:57 <Chousuke> Strictness is probably strictly (:P) easier to mentally simulate, though.
03:10:48 <Chousuke> even if that simulation ends up in an infinite loop.
03:11:31 <merijn> Zeev: ":quit"
03:11:40 <merijn> And maybe ctrl-d works too
03:12:01 <Zeev> merjin: thanks again :)
03:12:59 <mauke> or ctrl-z
03:13:22 <Zeev> mauke: no ctrl-z doesn't work
03:13:28 <Zeev> mauke: on windows at least
03:13:39 <mauke> did you hit enter afterwards?
03:13:54 <Zeev> mauke: even with enter
03:14:01 <mauke> hmm
03:15:20 <mstksg> ctrl+d should work
03:32:18 <hpaste_> “Dharmender Kumar” pasted “Placement Consultants In Delhi For It Jobs” at http://hpaste.org/87949
03:36:34 <jeremy_c> Is there a source code beautifier for Haskell? I saw the Stack Exchange question on this, but their answer of using haskell-src-exts isn't a good one, I don't think, because it strips all comments :-(
03:36:59 * hackagebot simple-firewire 0.1.3.4 - Simplified interface for firewire cameras  http://hackage.haskell.org/package/simple-firewire-0.1.3.4 (VilleTirronen)
03:40:04 <merijn> jeremy_c: I think hlint gives some suggestions on simplifying code, but I'm not sure if there's a full blown code beautifier
03:41:01 <jeremy_c> merijn: bummer. I do a lot of coding by voice and a tool to fix up double spaces between assignments, indent things a bit better, etc... makes that a lot easier.
03:43:28 <Saizan> jeremy_c: iirc haskell-src-exts has also a mode that preserves comments, Annotated or something
03:44:35 <jeremy_c> Saizan: hm, I must have missed that, I'll look again, thanks.
03:44:56 <bitonic> sometimes, when using a CPP macro in capitals, I get ‘Not in scope: data constructor `IMPOSSIBLE'’
03:45:00 <bitonic> where IMPOSSIBLE is the macro
03:45:21 <bitonic> is this a problem familiar to someone?  for some reason the macro doesn’t seem to be replaced by cpp
03:47:52 <bitonic> I think it has to do with '
03:56:24 <bitonic> yeah.  if the line where the CPP macro has a ' in it things go wrong
04:04:58 <merijn> :t cofmap
04:04:59 <kappabot>     Not in scope: `cofmap'
04:04:59 <kappabot>     Perhaps you meant one of these:
04:04:59 <kappabot>       `fmap' (imported from Control.Monad),
04:05:18 <merijn> cofmap is just "(a -> b) -> f b -> f a", right?
04:06:41 <dmwit> merijn: right
04:07:12 <merijn> Whoo, I get contravariant functors. Now I just need to grok profunctors >.>
04:11:32 <RoboTeddy> is this a good way to count word frequencies in the string `text`?: Map.fromListWith (+) (zip (words text) [1,1..])
04:12:00 <RoboTeddy> I'm just reading Learn You A Haskell -- wondering if there's a better way to do the above
04:14:34 <merijn> RoboTeddy: Seems like a good way
04:14:56 <RoboTeddy> merijn: cool, thanks
04:15:34 <merijn> RoboTeddy: There might be a more optimal complex way to do it, but as a quick and simple solution I don't think you can do much better
04:16:04 <RoboTeddy> merijn: OK, thanks. what's the best way to learn to reason about optimality in haskell?
04:22:41 <merijn> I guess it'd be, pastebin code and ask here or on StackOverflow how to make it better?
04:22:55 <merijn> Real World Haskell has a chapter on profiling and optimising too, I think
04:23:32 <miasma> RoboTeddy: time and space complexity aren't somehow limited to haskell. you should read about those
04:24:07 <RoboTeddy> merijn: cool, thanks, I'll check out that chapter in RWH
04:24:08 <SpockzT> miasma: laziness does play a role in Haskell though
04:24:50 <Chat9706> Hi...
04:25:35 <RoboTeddy> miasma: I know a fair amount about analyzing complexity in general, but as a newbie I have no idea what ghci does or doesn't do behind the scenes!
04:25:56 <Chat9706> Anybody here?
04:26:18 <Chat9706> ???????????
04:26:20 <osfameron> Chat9706: patience...
04:26:36 <osfameron> yes, there are people here.  Either ask a question or lurk for a bit...
04:26:36 <Chat9706> Okay
04:26:58 <Chat9706> Okay
04:27:24 <deech> Hi all, I've made some updates to GreenCard but there's no repo listed on the Hackage page and it hasn't been updated since 2009. Is Sigbjorn Finne still the maintainer?
04:27:50 <merijn> deech: Have you tried emailing the maintainer?
04:28:18 <Chat9706> You know I'm a kid.Nine
04:28:26 <merijn> I tend to assume that 2-3 weeks of no response == abandoned
04:28:38 <deech> merijn: Yes, it's listed as Sigbjorn Finne and I did email him this morning, but I just wanted to make sure because the page hadn't been updated in a while.
04:29:26 <Chat9706> :(
04:29:40 <Chat9706> :(:(:(:(:(:(:(
04:29:54 <Chat9706>  :( :( :( :(
04:30:01 <deech> merijn: I think GreenCard's pretty heavily-used. No?
04:30:14 <merijn> deech: I've never heard of it? :>
04:30:16 <osfameron> Chat9706: this is a channel about the Haskell programming language.  Did you have an interest in, or question about that?
04:30:17 <typoclass> Chat9706: hello, this channel is about the programming language haskell
04:30:18 <Chat9706> !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
04:30:46 <Chat9706> What is that!?!
04:31:30 <Chat9706> 1 2 3 4 5 6 7 8 9...
04:31:36 <t7> haha
04:31:36 <mgsloan> > [1..9]
04:31:37 <kappabot>   [1,2,3,4,5,6,7,8,9]
04:31:54 <Chat9706> Bye.
04:32:17 <no-n> lol
04:32:46 * osfameron wonders if these people turn up at random shops or peoples' houses demanding to be entertained and informed
04:33:00 <Chat9706> Hey my family call me lol.
04:33:19 <no-n> Either Bot LittleKid
04:33:32 <no-n> :t Chat9706 ^
04:33:33 <kappabot> parse error (possibly incorrect indentation)
04:33:34 <Chat9706> :(
04:33:35 <typoclass> Chat9706: here, you can try out haskell on this website http://tryhaskell.org/
04:34:14 <Chat9706> You know I'm a kid...right
04:34:26 <osfameron> Bot, I think
04:34:36 <no-n> bedtime, kid
04:34:45 <no-n> :P
04:34:46 <osfameron> Chat9706: this isn't a kindergarten.
04:34:58 <Chat9706> F... Off
04:35:03 <RoboTeddy> so, how might one reason about the optimality of these two lines (which afaik are functionally equivalent)? https://gist.github.com/RoboTeddy/fdec507456cca3728e46
04:35:15 <merijn> @localtime mm_freak
04:36:02 <Chat9706> I'm 9 years old. July 5th is my birthday
04:36:58 <Chat9706> I'm leaving for real
04:37:50 <Chat9706> :(
04:38:19 <typoclass> Chat9706: anyway, check tryhaskell.org :-) if you're interested in computers and programming at all, it'll be very interesting to you
04:39:12 <Chat9706> I'm in love with my new video game
04:39:22 <osfameron> @where ops
04:39:22 <kappabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
04:39:34 <eikke> #haskell, the channel where people are so friendly they even try to convince a spammy kid to get into programming ;-)
04:39:47 <kryft> :)
04:40:32 <eikke> ah, a BB Playbook. No wonder he was bored :-D
04:43:48 <bitonic> what’s the quickest route to ‘(a -> b -> m c) -> m a -> m b -> m c’?  am I missing some obvious combinator?
04:44:20 <byorgey> no, you're not missing something obvious
04:44:41 <byorgey> @type \f a b -> join (f <$> a <*> b)
04:44:42 <kappabot> forall (m :: * -> *) a a1 a2. (Monad m, Applicative m) => (a2 -> a1 -> m a) -> m a2 -> m a1 -> m a
04:44:52 <byorgey> probably just sticking an extra "join" on is the easiest
04:44:52 <bitonic> right, I did the join thing too
04:44:55 <bitonic> but that’s kinda ugly
04:45:17 <byorgey> sure
04:45:29 <byorgey> so define your own combinator =)
04:45:33 <bitonic> mhmmm
04:45:44 <bitonic> I’m somewhat surprised that it’s not there already
04:46:19 <merijn> bitonic: Word, I had the same thing earlier
04:47:18 <byorgey> bitonic: well, there are a lot of such combinators one could imagine adding
04:47:31 <byorgey> the problem is if we added all of them, it would be a giant mess
04:47:48 <bitonic> byorgey: let me rephrase then: I’m surprised this one didn’t make the cut :)
04:48:13 <byorgey> fair enough, though personally I don't think I have ever wanted that one
04:48:14 <eikke> we'd run out of combinator character combinations, especially since lens took half of them already (;-))
04:48:36 <RoboTeddy> would it be possible to mine public haskell code for user-defined combinators, and add the most popular ones?
04:48:55 <merijn> RoboTeddy: Should be possible, yeah
04:48:58 <bitonic> byorgey: in the code I’m working with now I find myself often wanting that
04:48:59 <typoclass> RoboTeddy: heh, that's a neat idea
04:49:07 <merijn> Deciding equality would be hard, though
04:49:12 <deech> merijn: I think it's the thing that c2hs and hsc2hs compile down to.
04:50:10 <merijn> blah, three things to work on and all of them have me blocked waiting for people to answer my questions :<
04:50:54 <typoclass> RoboTeddy: people have occasionally downloaded all of hackage.haskell.org (which is like 3 gb or something) and grepped through all the stuff, to support arguments like "we should add a function isLeft/isRight to the base package". but i haven't heard of any systematic effort
04:51:25 <quchen> 3 GB of code!?
04:51:26 <RoboTeddy> typoclass: interesting, thanks
04:51:40 <typoclass> quchen: i dunno :-) i might be misremembering
04:52:00 <quchen> Maybe when you compile it
04:52:46 <typoclass> RoboTeddy: you could look around in http://ircbrowse.net/ a little. i think it was only a few weeks ago that we in here discussed searching all of hackage
04:52:48 <quchen> Or Hackage is a lot larger than I had expected
04:53:04 <phischu> quchen: if you unzip it it is 11GB i have it right here
04:53:16 <quchen> phischu: Only source? Wow.
04:53:50 <typoclass> phischu: is that all versions ever, or only the current ones? i bet that'll make a hell of a difference
04:53:53 <phischu> quchen: about 5000 packages, about 20000 package versions
04:54:03 <quchen> phischu: How did you download it? cabal install everything?
04:54:05 <phischu> typoclass: all ever
04:54:12 <quchen> Oh, so you downloaded all versions of all packages?
04:54:17 <phischu> quchen: custom crawler
04:54:29 <quchen> How long does it take to compile? ;-)
04:55:12 <quchen> "I'm going to compile Haskell now." "You mean GHC?" "No, I mean *Haskell*". :-D
04:55:19 <phischu> quchen: i have never compiled it and i do not intend to i want to parse it though which with haskell-src-exts takes about eleven hours
04:55:42 <quchen> phischu: What's that program for?
04:55:57 <typoclass> quchen: you should wget all files on the internet, then try to compile them with ghc
04:55:58 <quchen> Is it a Haskell parser to analyze files with?
04:56:32 <phischu> quchen: for my master's thesis. i want to analise existing haskell packages to answer questions about code duplication, api evolution, etc.
04:57:06 <quchen> phischu: Is there any chance you could find out how many packages have Monad instances without corresponding Functor/Applicative ones?
04:58:00 <RoboTeddy> phischu: I wonder what would happen if you compared all fns with the same type signature against each other by giving them random inputs and seeing if their output matched
04:58:03 <phischu> quchen: that would be too hard
04:58:09 <typoclass> phischu: oooh, very interesting. you're going to put it online when it's done, right?
04:58:16 <quchen> phischu: Damn. Well, back to brute forcing it then I guess.
04:58:49 <phischu> roboteddy: yes would be interesting
04:59:03 <phischu> typoclass: yes i will put it online
04:59:05 <typoclass> RoboTeddy: hah, that's a cute idea. maybe you could use quickcheck for that
04:59:15 <typoclass> phischu: thanks :-)
05:00:31 <typoclass> "these two functions have the same signature, and give identical results for identical inputs." -- "these functions seem related; they give 90% identical outputs"
05:01:22 <eikke> typoclass: would be hard I figure
05:01:28 <hpaste_> “Anonymous Coward” pasted “uuugly” at http://hpaste.org/87955
05:01:43 <plhk> ^ this looks quite ugly, doesn't it?
05:01:48 <plhk> what can i do?
05:02:30 <typoclass> eikke: possibly. i wasn't sure where i was going with these ideas anyway :-)
05:09:46 <quchen> plhk: Add comments.
05:10:10 <quchen> plhk: Also, your case statement can be simplified using Control.Monad.when
05:10:25 <quchen> when p x = if p then x else return ()
05:11:02 <typoclass> plhk: have you looked at alternatives to the select-seek thing? it feels a bit un-haskelly to me :-)
05:11:06 <quchen> Working with your RasPi? :-)
05:11:34 <plhk> quchen: yup
05:11:56 <quchen> plhk: I started writing a GPIO lib a couple of months ago but eventually lost interest :-/
05:13:32 <plhk> typoclass: no idea where to look
05:14:29 <quchen> I would just keep a file handler open and check its contents periodically. Basically a combination of threadDelay and getChar.
05:14:55 <plhk> but latency!
05:14:56 <quchen> Well, that's what you're doing. But you can separate that into multiple functions.
05:15:11 <quchen> You can delay your thread for pretty small amounts of time.
05:15:27 <quchen> The delay is useful, otherwise the thing will do nothing but read the pin I guess.
05:15:45 <typoclass> plhk: i thought, just readFile or something :-) maybe that's too naive. but maybe worth a shot
05:17:03 <typoclass> plhk: if you want to watch for changes, you could use inotify. there's two or three haskell libraries. however i'm not sure if they work on "weird" files from /sys
05:17:44 <quicksilver> I'd guess not.
05:17:46 <plhk> i tried command-line inotify-watch
05:17:48 <plhk> it doesn't work
05:18:05 <quicksilver> generating notifications for every change in /proc and /sys would be ridiculous :)
05:18:28 <merijn> plhk: Why are you bothering with select?
05:18:32 <typoclass> plhk: ah very good. that's what i would have suggested next
05:19:12 <plhk> merijn: C mindset, i guess
05:19:40 <merijn> plhk: You could just do a blocking read from the file in a separate forkIO thread
05:20:05 <merijn> Or something like that, I think?
05:20:37 <typoclass> quicksilver: with inotify you register for one specific file (or directory) which you want to watch for changes
05:21:01 <quicksilver> typoclass: I know, but the filesystem still has to generate the events which are being listened for.
05:21:16 <quicksilver> typoclass: I don't think anyone wants procfs and sysfs to have support for event generation.
05:21:39 <quicksilver> unlike real filesystems, procfs and sysfs don't "know" when their files change
05:21:43 <quicksilver> because they're not real files
05:21:51 <typoclass> quicksilver: *shrug* the alternative seems to be the "read, wait 100 ms, read again" thing. that seems more wasteful
05:21:51 <quicksilver> they'd direct windows into some underlying kernel structures
05:21:59 <quicksilver> s/they'd/they're/
05:22:15 * hackagebot slice-cpp-gen 0.2.0.0 - Generate C++ skeletons from slice files  http://hackage.haskell.org/package/slice-cpp-gen-0.2.0.0 (PaulKoerbitz)
05:22:56 <jeremy_c> Saizan: I spoke with Niklas about parsing/pretty printing comments. The comment parser is there for verbatim output, not for pretty printing. He said pretty printing comments is a "Very Hard Problem" to solve and no code exists in his packages to accomplish that task :-(
05:23:51 <hpaste_> quchen annotated “uuugly” with “uuugly (annotation)” at http://hpaste.org/87955#a87956
05:28:22 <typoclass> "procfs and sysfs don't 'know' when their files change" <- before anything like inotify existed, maybe people said the same thing about all filesystems
05:28:58 <hpaste_> quchen revised “uuugly (annotation)”: “bracketing” at http://hpaste.org/87956
05:29:38 <hpaste_> plhk annotated “uuugly” with “uuugly (annotation) (annotation)” at http://hpaste.org/87955#a87958
05:30:25 <plhk> that looks much nicer, thanks quchen and others
05:31:06 <quicksilver> typoclass: of course.
05:31:18 <quicksilver> typoclass: but true filesystems know when their files change.
05:31:48 <quicksilver> typoclass: because filesystems' files change at a well-defined place in their APIs - that's a propery of a filesystem with all changes going through an API.
05:32:27 <quicksilver> typoclass: however, /sys and /proc are not real files, and the filesystem doesn't know when they change. Many of them directly map portions of memory and can change just because a bit of code runs on a chip somewhere.
05:32:34 <quicksilver> as I tried to explain just above.
05:32:43 <hpaste_> quchen annotated “uuugly” with “uuugly (annotation)” at http://hpaste.org/87955#a87960
05:32:53 <quchen> You should break the functionality up as well.
05:33:01 <quchen> Opening the file has nothing to do with checking its contents.
05:33:20 <quchen> Plus like this you can expose the bracketing much nicer, so it's more obvious the thing doesn't do anything weird.
05:33:41 <quchen> All I have left now is discussing about which indentation style is nicer. Let's not go there ;-)
05:35:19 <plhk> yeah, this was just test code
05:37:51 <quchen> Oh, and put a "lift . threadDelay $ 10^4" in there somewhere.
05:38:04 <typoclass> quicksilver: yes, i get that more code would have to be changed. first implementing inotify was relatively centralized. "we just need to add some stuff to open() and write() and a few other sys calls". i get that for other filesystems it might be more difficult to implement. but i don't think it's quite so impossible. e.g. for /proc, new processes don't mystically show up and go away, with the kernel having no way of knowing. the kernel
05:38:16 <quchen> Otherwise I'll have to report you to the Raspberry anti cruelty organization.
05:39:29 <quicksilver> typoclass: I didn't say it was impossible. I said that you wouldn't want it.
05:40:12 <plhk> ah, wait! so it's looping and not magic ):
05:41:04 <typoclass> quicksilver: no. i do want /proc to tell me things via inotify!!!1!!1!
05:41:05 <typoclass> ;-)
05:41:32 <quchen> plhk: Looping?
05:43:26 <plhk> quchen: i mean it reads file in a loop without blocking
05:44:12 <quchen> It won't consume the entire CPU like this, yes.
05:44:27 <quchen> Consume? Occupy.
05:44:29 <typoclass> plhk: if you're worried about blocking, you can always stick it in a forkIO very easily
05:44:30 <plhk> yeah, only 50%
05:44:48 <typoclass> plhk: so you have a dual-core cpu?
05:45:00 <plhk> no, it's on ras-pi
05:45:31 <plhk> typoclass: i *want* blocking
05:45:49 <typoclass> plhk: ok
05:46:19 <quchen> forkIO doesn't really have much to do with how many cores you have. It just schedules the computation for concurrent execution. If the runtime schedules these on multiple CPUs, then it effectively is a "run this on many cores" command.
05:46:57 <plhk> it's a pity threadWaitRead doesn't work ]:
05:47:21 <quchen> I don't understand what you mean with "blocking".
05:47:24 <typoclass> quchen: uh yes. i suspected he had a dual-core because he mentioned an infinitely spinning thing consumed 50% of the cpu. nothing to do with forkIO :-)
05:47:30 <quchen> You want the entire RasPi to do nothing except checking that file?
05:47:36 <plhk> quchen: well, select()
05:47:42 <quchen> Select?
05:48:06 <plhk> >Block the current thread until data is available to read on the given file descriptor (GHC only).
05:48:28 <plhk> ^ i want this
05:48:52 <quchen> readChar blocks automatically if there's no data, doesn't it?
05:49:13 <quchen> On the other hand, gpio/value always contains a 0 or 1, so reading that won't ever block I guess
05:49:52 <plhk> yeah, it never blocks
05:50:38 <plhk> and threadWaitRead uses select() on readfd's while linux gpio docs says you must use exceptfd's to check for new values in these files
05:51:24 <quchen> Oooh, that's why you're doing this "select''" business, I'm beginning to understand.
05:51:36 <plhk> yeah!
05:51:40 <quchen> You basically want a "block until changed" function, instead of repeatedly checking for an update.
05:51:53 <plhk> right
05:51:57 <quicksilver> however that is not what select() does.
05:52:08 <quicksilver> (1) you don't need to use select() in haskell, the IO manager does it for you
05:52:25 <quicksilver> (2) select() doesn't block until changed, it blocks until there is data ready to read (or write)
05:52:33 <quicksilver> /sys/class/gpio/gpio1/value is always read to read.
05:52:37 <quicksilver> ready to read.
05:53:48 <plhk> https://www.kernel.org/doc/Documentation/gpio.txt <- scroll to "exceptfds"
05:54:25 <klrr> i get some weird runtime error :(
05:54:33 <quchen> I'd be surprised if you didn't have to take a byte to find out how the apple tastes.
05:55:19 <quicksilver> quchen: oh, OK, that's intresting. The put exception support in especially so you could use select(2) on it. Nice :)
05:56:49 <savask> @pl (\(a, (b, c)) -> (a ++ [b], c))
05:56:50 <kappabot> uncurry ((`ap` snd) . (. fst) . ((,) .) . (. return) . (++))
05:57:35 <quchen> quicksilver: Eh, what?
05:57:49 <neurocyte> plhk, it should block if you set "edge" to "both"
05:58:11 <quchen> quicksilver: Read it three times now and it doesn't make much sense to me.
05:58:18 <plhk> quchen: s/The/They/
05:58:31 <quchen> plhk: That's not the part I struggled with ;-)
05:58:32 <neurocyte> plhk, assuming rpi gpio pins can generate interrupts.
05:58:57 <plhk> neurocyte: block on reading?
05:59:11 <plhk> it's set to both
05:59:43 <quicksilver> quchen: in general, you don't get 'select' to trigger just because a file changes.
06:00:05 <quchen> quicksilver: I don't know about any of the functions mentioned there: select, poll, ...
06:00:11 <neurocyte> plhk, yes, and you should also configure the pin to generate interrupts
06:00:30 <quicksilver> quchen: however, because this is useful, the kernel has arranged to trigger select by (ab)using the little used third parameter to select
06:00:43 <quicksilver> quchen: which triggers if there is an error (or exception) on that FD
06:01:00 <quicksilver> "exceptfds" is the fourth parameter to select(2)
06:01:09 <plhk> neurocyte: well, it says "[edge] file exists only if the pin can be configured as an interrupt generating input pin."
06:01:14 <quicksilver> although in this manual page I have here it's called errorfds
06:01:30 <typoclass> man select_tut says «This set is watched for "exceptional conditions". In practice, only one such exceptional condition is common: the availability of out-of-band (OOB) data for reading from a TCP socket.»
06:01:41 <quicksilver> right, as typoclass says
06:01:48 <quchen> I don't understand anything.
06:01:49 <quicksilver> so they're re-using a little-used bit of the select API
06:01:50 <typoclass> quicksilver: so the gpio people reused this for their thing? that's interesting
06:01:54 <quicksilver> yes, exactly.
06:02:02 * typoclass purrs
06:02:20 <quicksilver> quchen: well you might first of all read http://linux.die.net/man/2/select
06:02:29 <quicksilver> quchen: to give you some idea of what select(2) is.
06:02:32 <neurocyte> doesn’t the rts set exceptfds?
06:03:16 <merijn> quicksilver: This sounds like there might be a case to add "threadWaitError :: Fd -> IO ()" to the runtime system
06:03:17 <quchen> quicksilver: select blocks until one of its arguments becomes available?
06:03:30 <merijn> quchen: One or more
06:03:45 <quchen> That's what I said.
06:03:47 <typoclass> quchen: select() is a system call that you give a bunch of file descriptors (you know those, right) and it will block until one of the fds has changed. this way your c program can wait efficiently until any of these 14 tcp sockets has data available to read. same for writing, files, etc.
06:03:51 <quicksilver> quchen: yes, it blocks until one of the things you want to read has data to read, or one of the things you want to write to has space to write to.
06:04:07 <quicksilver> it *does not* block until a file has changed
06:04:19 <quicksilver> however the gpio guys in the linux kernel have re-used a little-used part of the API
06:04:33 <quicksilver> so that it works that way for gpio ports (if they support interrupts at all)
06:04:43 <merijn> mm_freak: Ping?
06:04:48 <quchen> quicksilver: It blocks until something changes (that may or may not be useful to what you're trying to accomplish) then?
06:04:57 <quicksilver> yes, if you like.
06:05:02 <quicksilver> it's normally fairly specific.
06:05:04 <drbalor> eikke_: I've been looking at your BaconAndFay, which seems to fail to build due to a missing typeclass "Foreign".  Can you remember where that typeclass came from?
06:05:12 <quicksilver> it's waiting for data on pipes or sockets
06:05:21 <quicksilver> and for permission to write to other pipes and sockets
06:05:26 <merijn> quchen: The third set of fd's to select checks for error conditions on those fd's
06:05:44 <merijn> quchen: If you write a device driver, error condition can be whatever you like
06:06:03 <neutrino> hey guys
06:06:15 <neutrino> has anyone here used scalaz? is it very disappointing or just somewhat bad?
06:06:55 <quchen> Try #scala or something?
06:07:21 <quchen> merijn: So to sum it up, there is a way of abusing standard functions to make GPIO values block until changed.
06:07:42 <quchen> I think that's what I'm going to take out of this. And that I should carefully avoid Linux kernel manpages ;-)
06:07:52 <typoclass> neutrino: you might check ircbrowse.net for what edwardk has said about scala. i think his opinion was that it's somewhat bad compared to haskell
06:09:07 <quchen> edwardk on Scala: http://ircbrowse.net/browse/haskell?id=15058649&timestamp=1359525034#t1359525034
06:13:14 <supki> neutrino: you should ask in #scalaz
06:16:51 <jonkri> has anyone experienced an error that there is no instance Show for PortID? for some reason, PortID is in scope, but it's show instance is not. i can define a Show instance myself, and it will work. any ideas?
06:18:02 <quchen> jonkri: That's pretty odd. The source says it's got an autoderived instance. http://hackage.haskell.org/packages/archive/network/latest/doc/html/src/Network.html#PortID
06:18:41 <dmwit> Did you know that PortID is a constructor, but not for the PortID type?
06:18:56 <typoclass> jonkri: maybe it's an oversight? maybe the library didn't offer a Show instance, which only recently got corrected?
06:19:04 <dmwit> Surprise! It is a constructor for the PortNumber type. This makes sense because reasons.
06:20:00 <dmwit> (However, PortNumber also has a Show instance. So I don't really know what's up with jonkri's code.)
06:20:27 <dmwit> Aha, old versions of network do not include a Show instance.
06:20:33 <dmwit> Perhaps that is your problem.
06:20:46 <dmwit> You could upgrade network, or you could use StandaloneDeriving, or you could write the instance by hand.
06:21:09 <quchen> StandaloneDeriving?
06:21:32 <dmwit> Yep, it lets you write "deriving instance Show PortID" all on its own line, separate from the declaration of Show or PortId.
06:21:36 <dmwit> Nice, right?
06:21:44 <quchen> Wat
06:21:48 <quchen> Wow, finally!
06:21:56 <quchen> deriving instance Ord (Complex a)
06:22:00 <jonkri> thanks all :)
06:22:09 <quchen> Complex numbers in a Map, the easy way. Yipee :-)
06:22:27 <efie> is there a specific reason why in Data.Vector.Unboxed there is ifoldl' but no ifoldM' (just foldM')? is it ok to ask the autor via email to include it?
06:22:48 <quchen> dmwit: I was hoping for that for some time now, and now you tell me it's always been there :D
06:22:54 <mauke> instance (Ord a) => Ord (Complex a) where compare (x1 :+ y1) (x2 :+ y2) = compare (x1, y1) (x2, y2)  -- not much harder
06:22:54 <typoclass> dmwit: i'd like to meet those alleged reasons that make this alleged sense. in a dark alley, while i have my atomic blaster locked and loaded
06:23:10 <dmwit> quchen: "always" in this case means since 7.4, I think
06:23:24 <quchen> dmwit: Well, that's almost "always" for me then. :-)
06:23:42 <quchen> mauke: And now again for quaternions.
06:24:16 <quchen> Lots of boilerplate is "not hard". Still I appreciate when I can avoid having to write it.
06:26:01 <merijn> What happens if you have a standalone derived instance and you try to compile when there already is an instance? Is that a compile error?
06:26:06 <mauke> merijn: yes
06:26:21 <quchen> Probably the same as a double instance
06:26:31 <fizbin> > 1
06:26:31 <kappabot>   1
06:26:57 <fizbin> Huh. so… kappa is the new lambda?
06:27:15 <quchen> Probably the alternative nickname in case of network trouble
06:27:44 <fizbin> Yet lambdabot is still here.
06:28:23 <Zariel> What is the concept called where the function call is called within a monad, like how the parsec parser you never pass it the current parser state?
06:28:33 <fizbin> @pl \x y z -> (x z) (y z)
06:28:34 <kappabot> ap
06:29:03 <fizbin> @pl \x y -> x
06:29:03 <kappabot> const
06:29:31 <fizbin> @pl \x -> x ap const
06:29:31 <kappabot> flip ($ ap) const
06:30:26 <t7> @pl \a b c d e f g -> g (a c) b (f e) d
06:30:26 <kappabot> (((flip . ((flip . (flip .)) .)) .) .) . flip flip (flip id) . ((flip . (((.) . (.) . flip) .)) .) . flip . ((flip . flip id) .)
06:31:11 <quchen> Zariel: Passing around the parser state is pretty much what the Parsec monad is useful for. I don't think the concept itself has another name than "it's a monad that gets rid of the bookkeeping".
06:31:13 <t7> @unpl (((flip . ((flip . (flip .)) .)) .) .) . flip flip (flip id) . ((flip . (((.) . (.) . flip) .)) .) . flip . ((flip . flip id) .)
06:31:14 <kappabot> (\ az cd cg b c f i -> i (az cg) cd (f c) b)
06:31:30 <t7> what happened to lambda bot?
06:31:59 <geekosaur> they're still trying to figure that out
06:32:11 <dmwit> "broken"
06:32:20 <t7> should have written it in python or something
06:32:37 <quchen> So it couldn't break because it already is? :s
06:32:55 <dmwit> How old is lambdabot now?
06:33:07 <mauke> mueval is broken
06:33:26 <t7> isnt it stateless?
06:33:31 <fizbin> let i = flip ($ ap) const in (i(i(i(i i)))) ++ show "let i = flip ($ ap) const in (i(i(i(i i)))) ++ show "
06:33:44 <fizbin> > let i = flip ($ ap) const in (i(i(i(i i)))) ++ show "let i = flip ($ ap) const in (i(i(i(i i)))) ++ show "
06:33:44 <kappabot>   Couldn't match expected type `a0 -> b0'
06:33:45 <kappabot>              with actual type `[GHC...
06:33:50 <fizbin> Darn.
06:33:54 <Zariel> quchen: are there any good examples of implementing a similar monad simply?
06:34:04 <merijn> Zariel: State?
06:34:05 <fizbin> :t let i = flip ($ ap) const in (i(i(i(i i))))
06:34:06 <kappabot>     Occurs check: cannot construct the infinite type:
06:34:06 <kappabot>       b2
06:34:06 <kappabot>       =
06:34:22 <mauke> :t flip ($ ap)
06:34:23 <kappabot> forall a b (m :: * -> *) a1 b1. Monad m => a -> ((m (a1 -> b1) -> m a1 -> m b1) -> a -> b) -> b
06:34:29 <quchen> Zariel: Yes, RWH has a chapter on writing a parser from scratch.
06:34:32 <dmwit> Zariel: You might like sigfpe's You Could Have Invented Monads, and you might like Good Math Bad Math's thing on the State monad.
06:34:43 <Zariel> dwcook: quchen thanks
06:34:54 <fizbin> :t let i = flip ($ ap) const in i i
06:34:55 <kappabot>     Occurs check: cannot construct the infinite type:
06:34:55 <kappabot>       b0 = a0 -> b0 -> a0
06:34:56 <kappabot>     Expected type: (((a0 -> b0 -> a0) -> (a0 -> b0) -> a0 -> a0)
06:35:23 <quchen> fizbin: You can also do type experiments in a private query. :-)
06:35:54 <fizbin> :t let i = \f -> (f ap) const in i i
06:35:57 <kappabot>     Occurs check: cannot construct the infinite type:
06:36:01 <kappabot>       b0 = a0 -> b0 -> a0
06:36:03 <kappabot>     Expected type: (((a0 -> b0 -> a0) -> (a0 -> b0) -> a0 -> a0)
06:36:31 <dmwit> Zariel: http://scientopia.org/blogs/goodmath/2007/01/29/more-monads-stateful-programming/ for GMBM, and Google has sigfpe's one.
06:36:39 <t7> computer cant find most general unifier :O
06:36:40 <fizbin> Oh well. So much for the iota combinator - I guess it does only work untyped.
06:37:14 <haasn> I'm sure it's possible by using a recursive newtype wrapper
06:37:17 <dmwit> :t (\f -> f ap const) (\f -> f ap const)
06:37:17 <kappabot>     Occurs check: cannot construct the infinite type:
06:37:18 <kappabot>       b0 = a0 -> b0 -> a0
06:37:18 <kappabot>     Expected type: (a0 -> b0 -> a0) -> a0 -> b0
06:47:19 <eikke_> drbalor: not really. afaik Fay's APIs aren't stable, so maybe things moved around quite a bit since I wrote that code
06:47:26 * hackagebot uu-interleaved 0.1.0.0 - Providing an interleaving combinator for use with applicative/alternative style implementations.  http://hackage.haskell.org/package/uu-interleaved-0.1.0.0 (DoaitseSwierstra)
06:47:28 * hackagebot uu-parsinglib 2.8.1 - Fast, online, error-correcting, monadic, applicative, merging, permuting, idiomatic parser combinators.  http://hackage.haskell.org/package/uu-parsinglib-2.8.1 (DoaitseSwierstra)
06:47:44 <eikke_> wow, that's a buzzwordpackage
06:52:26 * hackagebot uu-options 0.1.0.0 - Parse command line options using uu-interleave and uu-parsinglib  http://hackage.haskell.org/package/uu-options-0.1.0.0 (DoaitseSwierstra)
06:53:06 <efie> I need all possible permutations of a list l restricted to a length n. If n = 2 I can do it with [[x,y] | x <- l, y <- l], but how can I do for arbitrary n?
06:53:54 <quchen> That code will give you the cartesian product of the list, not all permutations.
06:54:23 <quchen> If you want the product of many lists, use sequence.
06:54:34 <quchen> > sequence [[1],[2,3],[4,5,6]]
06:54:35 <kappabot>   [[1,2,4],[1,2,5],[1,2,6],[1,3,4],[1,3,5],[1,3,6]]
06:54:36 <klrr> ?src flip
06:54:36 <kappabot> flip f x y = f y x
06:55:21 <klrr> ?type mapM
06:55:22 <kappabot> forall (m :: * -> *) a b. Monad m => (a -> m b) -> [a] -> m [b]
06:55:33 <klrr> ?type fmap
06:55:34 <kappabot> forall (f :: * -> *) a b. Functor f => (a -> b) -> f a -> f b
06:55:40 <efie> quchen: thanks
07:36:24 <mm_freak> merijn_: pong
07:57:31 * hackagebot scion-browser 0.2.17 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.2.17 (JeanPhilippeMoresmau)
08:03:42 <whald> believe
08:03:43 <osa1> do we have a gloss-like library for graph/tree drawing?
08:04:27 <ClaudiusMaximus> osa1: http://hackage.haskell.org/packages/archive/diagrams-contrib/latest/doc/html/Diagrams-TwoD-Layout-Tree.html ?
08:05:32 <byorgey> osa1: diagrams may or may not count as "gloss-like" depending on which properties of gloss you care about =)
08:05:51 <osa1> byorgey: I need to update the graph/tree dynamically
08:05:53 <byorgey> but I don't know of any other tree drawing library
08:06:07 <osa1> does that allow drawing graphs or is it only for trees?
08:06:37 <byorgey> osa1: right, diagrams doesn't have built-in support for interactive things like gloss does, but you can certainly do it
08:06:48 <byorgey> osa1: that module is just trees
08:07:03 <byorgey> we don't have a general graph-drawing module yet, but it shouldn't be hard to write
08:07:30 <osa1> byorgey: I'm interested in writing in using gloss if anyone can point me the algorithms requrired :-)
08:07:31 <merijn_> mm_freak: Right, I'm alive! I had a question last night about whether there's something like a Wire transformer
08:07:42 <osa1> s/writing in/writing it/
08:08:11 <byorgey> osa1: the documentation ClaudiusMaximus linked has a reference to a nice paper with a functional tree-drawing algorithm, if you want to draw trees
08:08:19 <byorgey> which is where we got our algorithm
08:08:27 <mm_freak> merijn_: what's that?
08:08:53 <byorgey> osa1: as for graph layout, I don't know, it's quite a bit harder
08:09:11 <osa1> byorgey: have you seen that? https://github.com/jacomyal/sigma.js it draws graphs and codebase is really small, maybe I can port it(no pointers to papaers/tutorials in source code)
08:09:57 <byorgey> osa1: cool, I hadn't seen that
08:10:20 <byorgey> osa1: if you port it I'd be very interested to see the result
08:10:44 <merijn_> mm_freak: I dunno! :) I was writing down some datatype for a widget, which I figured should be something like "Widget :: s' -> (s' -> s) -> Wire e (StateT s' m) a b -> Widget a b s", i.e. a widget has some internal state, some projection of that state and a Wire governing it's behaviour. The problem is that that wire should probably also produce a new widget at the end
08:11:28 <osa1> byorgey: ok, I let you know if I finish porting. I'm open to paper/tutorial recommendations about graph drawing algorithms.
08:12:18 <mm_freak> merijn_: that sounds like:  Wire e (StateT s' m) a (Widget a b s)
08:12:49 <merijn_> mm_freak: i.e. it unwraps to something like "a -> StateT 's m (Either e b, Wire e (StateT s' m) a b, Widget a b s)"
08:12:58 <mm_freak> merijn_: to answer your question, i'm working on a concept of wire transformers similar to proxy transformers, but it's nothing solid yet
08:13:18 <merijn_> mm_freak: Yeah, but if it produces a Widget it doesn't produce any actual b's, does it
08:13:34 <mm_freak> merijn_: what should 'b' be?
08:13:48 <mm_freak> wouldn't the wire denote a time-varying widget?
08:15:21 <merijn_> mm_freak: I basically want a notion of "Widget a b s" to be a widget that takes events of type a, produces events of type and has a projectable state s. I'm not sure how to couple an implementation of behaviour using Wires to the Widget, though...
08:15:57 <mm_freak> merijn_: what's an "event"?
08:16:09 <acube> Can I write a function that takes (another function of the (simplified) type v -> a that accepts both T1 and T2 as v) ?
08:16:14 <merijn_> mm_freak: I've also been looking at conal's TV stuff, which seems very similar to what I want too
08:16:35 <merijn_> mm_freak: Things like keypress, resize, timer expired
08:17:01 <acube> @ty \f -> f (1 :: Word16) >> f (2 :: Word32)
08:17:01 <kappabot>     Couldn't match expected type `Word16' with actual type `Word32'
08:17:02 <kappabot>     In the first argument of `f', namely `(2 :: Word32)'
08:17:02 <kappabot>     In the second argument of `(>>)', namely `f (2 :: Word32)'
08:17:21 <acube> ^ That's what I want to write
08:17:23 <merijn_> i.e. a keypress may modify the internal widget state and, possibly, generate X output events to send somewhere else
08:17:38 <acube> @help
08:17:38 <kappabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:17:42 <acube> @list
08:17:42 <kappabot> http://code.haskell.org/lambdabot/COMMANDS
08:17:49 <acube> kappabot is lambdabot?
08:18:08 <acube> Lambdabot is still there :O
08:18:14 <mm_freak> merijn_: i'm still not sure what you need…  in any case it doesn't sound like netwire works the way you would like it to
08:18:18 <ocharles> acube: If you want to accept either T1 or T2, then have your function take Either T1 T2
08:18:32 <acube> @ty \f -> f (1 :: Word16) >> f (2 :: Word32)
08:18:32 <kappabot>     Couldn't match expected type `Word16' with actual type `Word32'
08:18:33 <kappabot>     In the first argument of `f', namely `(2 :: Word32)'
08:18:33 <kappabot>     In the second argument of `(>>)', namely `f (2 :: Word32)'
08:18:39 <acube> ocharles: That's what I want to write
08:18:48 <ocharles> you can't, as you can see
08:18:56 <ocharles> If you want that type of generality, you need a type class
08:19:05 <ocharles> but still the type class will bring both values into a common domain
08:19:13 <mm_freak> acube: you can do that, but not without a type system extension
08:19:31 <merijn_> mm_freak: Yeah, that's what I thought too, but that annoys me, because then I end up with two FRP like things, something TV like for the UI and something Wire like for the networking. I was hoping to come up with a nice unified idea :\
08:20:29 <merijn_> It feels like there should be a way to get these two notions to play together nicely...
08:20:40 <mm_freak> > let func :: (Monad m) => (forall a. (Integral a) => a -> m ()) -> m (); func f = f (1 :: Word16) >> f (2 :: Word 32) in func (const $ Just ())
08:20:41 <kappabot>   Only unit numeric type pattern is valid
08:20:53 <mm_freak> > let func :: (Monad m) => (forall a. (Integral a) => a -> m ()) -> m (); func f = f (1 :: Word16) >> f (2 :: Word32) in func (const $ Just ())
08:20:54 <kappabot>   Just ()
08:21:01 <mm_freak> @ acube, ocharles
08:21:03 <acube> WHo is kappabot?
08:21:11 <ocharles> mm_freak: >> is bitshift, I thought
08:21:11 <acube> mm_freak: thanks, that should work
08:21:14 <ocharles> not monadic sequence
08:21:25 <mm_freak> how would i know?  this is #haskell
08:21:40 <shachaf> kappabot is a lambdabot alternative.
08:21:43 <ocharles> acube: did you intend >> to be Monad's >> or some sort of bitwise operation?
08:21:57 <mm_freak> merijn_: there is nothing wrong with keeping the two separate, even if you were to use the same FRP framework
08:22:28 <mm_freak> for UIs netwire 4 isn't the best choice right now…  it's really more useful for networking applications
08:22:30 <merijn_> mm_freak: Well, one thing is that I keep getting myself confused when I have to keep them separate :p
08:22:57 <merijn_> So, when's netwire 5 coming out, then? ;)
08:23:20 <mm_freak> that's gonna take a while =)
08:24:02 <merijn_> Not using netwire means I'd have to reimplement any sort of continuous time stuff myself, though :\
08:24:10 <merijn_> Curses!
08:24:22 <acube> ocharles: Just used (>>) for an operation that came to my mind to combine two function calls :P
08:24:48 <acube> Where are these *.net *.split leaves comming from?
08:25:11 <mm_freak> merijn_: if you keep the wires and widgets separate netwire is fine as a UI framework
08:25:22 <mm_freak> however, i'd like to unify them
08:25:26 <mauke> acube: netsplits
08:25:30 <merijn_> acube: Netsplits from freenode, they're being DDOSed
08:25:35 <merijn_> still, I think
08:25:46 <Kinnison> Indeed :-(
08:25:52 * Kinnison wonders how long his current connection will last
08:26:18 <Sculptor> yo
08:26:39 <merijn_> mm_freak: Yeah, but then I don't think it's possible to have the behaviour result in a new Widget?
08:26:57 <mm_freak> merijn_: sorry, i don't understand that one
08:28:06 <merijn_> Maybe I don't either, I only half get what I'm doing :p
08:29:11 <merijn_> I'll just go back to randomly hacking things and seeing if I can get them to work...
08:30:21 <HugoDaniel> hi
08:31:03 <HugoDaniel> is there any package in haskell that abstracts inotify,kqueue,FindFirstChangeNotification ?
08:37:32 * hackagebot OptDir 0.0.2 - The OptDir type for representing optimization directions.  http://hackage.haskell.org/package/OptDir-0.0.2 (MasahiroSakai)
08:47:47 <magicman> HugoDaniel: http://hackage.haskell.org/package/fsnotify ?
08:54:49 <luite> HugoDaniel: kqueue is rather inefficient for watching directory trees, so it's not used in fsnotify on OS X
08:55:09 <luite> (and for freebsd it falls back to polling)
09:05:33 <fizbin> :t sequence . repeat
09:05:34 <kappabot> forall (m :: * -> *) a. Monad m => m a -> m [a]
09:05:44 <fizbin> @hoogle m a -> m [a]
09:05:44 <kappabot> A Hoogle error occurred.
09:10:15 <byorgey> fizbin: note, sequence . repeat is unlikely to be useful for many monads
09:11:09 <fizbin> byorgey: Yeah. I guess for most monads it's equivalent to "forever".
09:11:13 <HugoDaniel> thanks magicman and luite fsnotify is just what i need :)
09:11:20 <fizbin> @src forever
09:11:20 <kappabot> Source not found. It can only be attributed to human error.
09:11:26 <simpson> :t forever
09:11:27 <kappabot> forall (m :: * -> *) a b. Monad m => m a -> m b
09:11:57 * simpson wonders what forever does to ContT
09:12:45 <simpson> Cont r a -> Cont r b... Which is like ((a -> r) -> r) -> (b -> r) -> r
09:13:38 <fizbin> forever x = x >> (x >> (x >> (x >> (x >> ….
09:15:14 <S11001001> @djinn ((a -> r) -> r) -> (b -> r) -> r
09:15:14 <kappabot> No output from Djinn; installed?
09:17:16 <ClaudiusMaximus> @tell osa1 re graphs/trees in diagrams, i just dug out and reuploaded some screenshots of my work-in-progress graph editor (untouched since June 2012) http://mathr.co.uk/misc/ (first few images), probably bitrotten source is here: https://gitorious.org/maximus/graphgrow/blobs/master/Fractal/GraphGrow/Editor/Graph.hs
09:17:17 <kappabot> Consider it noted.
09:53:20 <hpaste_> zert pasted “Map” at http://hpaste.org/87968
09:53:32 <zert> can someone help me with this? im very new to programming and trying to get into list comprehension :)
09:53:51 <zert> what i want is for z to be a list and for y+z to be y + every element of z
09:54:14 <shachaf> List comprehensions are overrated.
09:54:34 <zert> sadly I have no choice :/
09:54:36 <shachaf> To the thing you said in IRC: map (y+) z
09:54:40 <shachaf> No choice?
09:54:48 <zert> yes im also not allowed to use map thats the problem im having
09:54:56 <shachaf> If you're asking a homework question you should mention that.
09:55:28 <zert> I am .. what I know is that [f x | x <- xs] equals map but I dont quite get how to use it
09:56:06 <Hafydd> Substitute the usage "map (+y) z" into a list comprehension.
09:57:40 <frontendloader> he might not get that you can have additional terms in a list comp on the right side?
09:59:08 <frontendloader> are you expecting your result list to be y*z in size zert
09:59:36 <zert> the size doesnt matter it also doesnt matter how often i get the same results
09:59:49 <zert> as long as the correct ones are included
10:00:49 <frontendloader> > [y+z | y <- [1,2,3,4], z <- [5,6,7,8]]
10:00:50 <kappabot>   [6,7,8,9,7,8,9,10,8,9,10,11,9,10,11,12]
10:01:09 <Floris> hi, i'm new here, can someone help me?
10:02:42 <byorgey> Floris: you've come to the right place!  Just ask your question and someone might help.  There's no need to ask permission to ask. =)
10:02:59 <oodb_mahran> :)
10:03:04 <byorgey> In particular no one knows whether they can help before they know what your question is.
10:03:35 <SaBer_> zert: if "[f x | x <- xs]" equals "map f xs" and you want "map (+y) z", you just need to replace f with (+y) and xs with z. It works just like the substitution principle in maths
10:04:09 <Floris> i just starter haskell 2-3 days ago, and when i print a line in the console and then ask for an input the input goes first..
10:04:11 <zert> i tink i might have asked my question in a stupid way
10:04:42 <SaBer> zert: if it's homework, it's supposed to make you think, and I won't give you the direct answer :)
10:04:54 <frontendloader> oh add a single number to every element in a list?
10:05:51 <Floris> like this: 	putStr "enter your lucky number"
10:05:52 <Floris> 	x <- getInt
10:05:55 <frontendloader> I missed what you asked completely
10:06:12 <SaBer> zert: btw, I'm curious, where do they teach haskell to people new to programming?
10:06:15 <zert> the z in (x,y,z) <- q is supposed to be a list and the z in (x*y,y+z) should be something ilke zs, an element from the list z.
10:06:30 <byorgey> Floris: that is probably due to output buffering
10:06:42 <zert> well the thing is i didnt start in the winter so basically i am half a year behind the rest, they already learned python etc thats why im struggling so much.
10:06:47 <byorgey> Floris: try adding a call to 'hFlush stdout' right after you print the prompt
10:06:56 <byorgey> Floris: that will force it to be output before continuing
10:07:03 <Floris> huh never heard of that..
10:07:05 <zert> and I have to start with haskell withotu any programming experience whatsoever
10:07:06 <Hafydd> zert: are you actually trying to write a list comprehension in Python?
10:07:15 <zert> no^^
10:07:19 <zert> I dont even know python
10:07:31 <Floris> i only know it's creator
10:07:49 <byorgey> Floris: this actually has nothing to do with Haskell specifically, you might run into the same problem in any language
10:08:13 <Floris> oh ole, in c it is something else
10:08:15 <luite> though many other languages flush stdout if you read from stdin
10:08:23 <Floris> thanks for the help
10:08:57 <luite> putStrLn would've flushed for you btw
10:09:21 <Floris> hem, what files do i have to import, this is not recognized by the compiler
10:09:28 <zert> oh and to answer your question, its frankfurt
10:09:32 <luite> Floris: System.IO
10:09:33 <Floris> but then i get a newline
10:09:37 <Floris> ah oke
10:09:55 <Floris> what file's should i always import?
10:10:06 <luite> Floris: you import only the modules you need :)
10:10:37 <oodb_mahran> Floris: import upon needed
10:10:40 <Floris> like in c you almost always add stdio.h
10:10:55 <luite> Prelude is automatically imported, there's not really anything you always need
10:11:11 <Floris> thats nice :)
10:12:02 <luite> Floris: use hoogle to find functions by name or type, if you don't know where they're from: for example http://www.haskell.org/hoogle/?hoogle=hFlush
10:12:03 <SaBer> zert: maybe try reading some more if you feel stuck with trying stuff out. Are you using ghci to test things interactively? LYAH is a good beginner resource: http://learnyouahaskell.com/starting-out#im-a-list-comprehension
10:12:50 <Floris> seBer: i'm following that one :) only testing some stuff
10:13:14 <zert> yes Im reading around all the time and using ghci to test stuff out.. Sadly the ressources we have are very limited and the tasks we are given seem quite hard to me :d
10:13:23 <zert> also read LYAH
10:14:50 <Hafydd> If you're always importing stdio.h in your C files, your programming style probably suffers from a lack of separation of concerns.
10:15:26 <Floris> well, i only write some small stuff in c
10:16:31 <zert> oh a different question, how do you cancel your ghci when its in an infinite loop, printing an endless list etc without restarting it?
10:16:44 <Floris> crtl z?
10:16:44 <luite> zert: ctrl+c
10:16:48 <zert> kk thx :)
10:17:04 <geekosaur> on unix, ctrl-c. windows, I think there's  abug in at least some versions and that may not work?
10:17:33 <frontendloader> same on windows
10:17:49 <acube>     Could not deduce (Arbitrary a1) arising from a use of `property'
10:17:51 <acube>     from the context (V.Unbox a1, Eq a1, Arbitrary a1)
10:17:52 <acube> hmm ?
10:18:16 <acube> how's that possible?
10:18:20 <monoidal> acube: hpaste?
10:18:40 <monoidal> acube: one bug like that was fixed
10:18:56 <frontendloader> sending EOF is ctrl+d on unix type systems and ctrl z on windows afaik
10:19:01 <acube> monoidal: I'm using GHC 7.6.3
10:19:11 <monoidal> acube: yes, fixed in head
10:19:55 <acube> monoidal: Can you link the bug report so I can see if it looks similar to my code?
10:20:32 <monoidal> acube: http://hackage.haskell.org/trac/ghc/ticket/7862
10:25:18 <ClaudiusMaximus> osa1: hi, i left you a message with kappabot
10:26:07 <shachaf> kappabot is very unreliable
10:26:42 <Taneb> kappabot is a thing that exists!?
10:26:55 <Eduard_Munteanu> @bot
10:26:55 <kappabot> :)
10:27:06 <Eduard_Munteanu> @vixen You're back!
10:27:06 <kappabot> I hear ya!
10:27:34 <Hafydd> Which of the greek letters have been used as bot names?
10:27:39 * hackagebot confsolve 0.3.8 - A command line tool for resolving conflicts of file synchronizers.  http://hackage.haskell.org/package/confsolve-0.3.8 (DanielTrstenjak)
10:27:51 <Hafydd> (Equivalently, which of them haven't?)
10:28:24 <Eduard_Munteanu> Somebody here is asking non-constructive questions. :P
10:29:02 <Hafydd> Hahahah.
10:34:14 <hpaste_> tux pasted “hmm this is crazy” at http://hpaste.org/87972
10:34:18 <doomlord> is there a typeclass for things convertable to Int
10:34:41 <osa1> ClaudiusMaximus: ok, how can I read it :*)
10:34:42 <kappabot> osa1: You have 1 new message. '/msg kappabot @messages' to read it.
10:34:42 <ClaudiusMaximus> doomlord: Enum
10:34:50 <osa1> ah
10:35:13 <Eduard_Munteanu> Integral makes more sense, IMO
10:35:17 <acube> monoidal: I pasted a simplified example that reproduces the issue
10:35:47 <acube> Oops, disregard that, it's a different error
10:35:54 <doomlord> its for a type used asan argument to !! ... integral was my first gues, i tried ord aswell. i thinnk i need to add other signatures though elsewhere.i was trying to generalize some code taking "Int"
10:36:23 <ClaudiusMaximus> @hoogle [a] -> Integer -> a
10:36:23 <kappabot> A Hoogle error occurred.
10:36:33 <doomlord> index lists for dereferencing could be 8bit, 16bit, 32bit
10:36:35 <monoidal> doomlord: genericIndex can be used instead of !! for non-Int
10:36:53 <acube> :t genericIndex
10:36:54 <kappabot> forall a b. Integral a => [b] -> a -> b
10:39:29 <Cale> Oh, lambdabot has been misbehaving?
10:41:33 <glguy> Cale: it's mueval: undefined'ing
10:41:47 <Cale> yeah
10:41:55 <monoidal> acube: there's also fixed http://hackage.haskell.org/trac/ghc/ticket/7786 where GHC reports it could not deduce A from A. I can't tell much more without looking at your code.
10:42:43 <monoidal> acube: if possible, you should try to minimise dependencies - e.g. usually you can redefine imported functions using type signatures + undefined and the error will still be there
10:44:54 <Floris> how do i only read integers from the console?
10:45:13 <Eduard_Munteanu> :t reads
10:45:15 <kappabot> forall a. Read a => ReadS a
10:45:48 <efie> could you help me with this memoization problem please? http://hpaste.org/87973
10:47:01 <Floris> member:kappabot: not working :(
10:49:57 <Floris> does someone know how i filter al the numbers out of an input?
10:50:48 <Floris> so i only have the numbers left
10:52:07 <Eduard_Munteanu> Floris: that 'reads' was for you. You can't only read integers, you read everything and decide what to keep, or decide how much more to ask for. :)
10:52:18 <Eduard_Munteanu> @src ReadS
10:52:18 <kappabot> Source not found. Wrong!  You cheating scum!
10:52:39 * hackagebot haxr 3000.9.2 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.9.2 (BrentYorgey)
10:52:42 <Eduard_Munteanu> type ReadS a = String -> [(a, String)]
10:52:49 <Floris> readS was not found..
10:53:16 <Floris> i will try that
10:53:17 <Eduard_Munteanu> Check the case again.
10:53:20 <geekosaur> case matters
10:53:26 <int-e> efie: Actually I don't see how memoSecond can be of much use.  fib myData = fibMD where fibMD = Memo.integral fibMD'; fibMD' 0 = 0'; fibMD' 1 = 1; fibMD' n = fibMD (n-2) + fibMD (n-2)   should work better
10:53:32 <geekosaur> ReadS is a type, reads is a function, readS doesn't exist
10:54:13 <Eduard_Munteanu> > reads "123" :: [(Int, String)]
10:54:14 <kappabot>   [(123,"")]
10:54:19 <Eduard_Munteanu> > reads "abc" :: [(Int, String)]
10:54:20 <kappabot>   []
10:54:51 <Floris> huh? i don't get it anymore
11:00:55 <efie> int-e: thank you, this reads clever! I will try to transfer this to my problem
11:01:14 <Eduard_Munteanu> Floris: that list is a makeshift Maybe
11:03:11 <amyers_> Is there a function of type `(a -> b) -> (a -> c) -> (b, c)`?
11:03:21 <monoidal> @hoogle (a -> b) -> (a -> c) -> (b, c)
11:03:21 <kappabot> A Hoogle error occurred.
11:03:21 <amyers_> I seem to remember using one but I can't find it now
11:03:49 <amyers_> Tried the online hoogle but didn't turn it up
11:03:53 <int-e> efie: There is one usage where memoSecond works well: memoizing a two-argument function as in   integral (memoSecond integral f)   The problem with using  f' = memoSecond integral f  is to ensure that when  f'  is applied to the same argument twice, it'll use the same inner call to the memoization function (integral in the example). That's exactly what the outer memoization accomplishes. In your case, however, the compiler...
11:03:59 <int-e> ...will recompute 'fib myData' over and over again.
11:04:01 <monoidal> amyers_: Control.Arrow.&&&
11:04:10 <monoidal> amyers_: (strange hoogle does not find that.)
11:04:41 <monoidal> > (sin &&& cos) 0
11:04:42 <kappabot>   (0.0,1.0)
11:04:47 <amyers_> monoidal: Perfect, thanks!
11:05:24 <Cale> lol, just noticed kappabot's realname
11:05:28 <Cale> 28% loyal
11:07:58 <Floris> hm, i meant getting an int out of getLine function
11:08:33 <ClaudiusMaximus> :t readLn
11:08:34 <kappabot> forall a. Read a => IO a
11:11:27 <shachaf> Maybe I should just host lambdabot, if the current server keeps having trouble with it...
11:12:17 <thoughtpolice> is laambdabot's hosting just being flaky?
11:15:37 <saml> liaamdabot?
11:19:08 <acube> @ty (.)
11:19:08 <kappabot> forall (cat :: * -> * -> *) b c a. Category cat => cat b c -> cat a b -> cat a c
11:19:15 <acube> > 1 2 3
11:19:16 <kappabot>   Overlapping instances for GHC.Show.Show (a2 -> a0)
11:19:16 <kappabot>    arising from the lite...
11:19:28 <acube> @ty 1 2 3
11:19:29 <kappabot> forall t. Num t => t
11:20:12 <dmwit> :t show (1 2 3)
11:20:13 <kappabot> String
11:20:22 <dmwit> > show (1 2 3)
11:20:23 <kappabot>   Overlapping instances for GHC.Show.Show (a2 -> a0)
11:20:23 <kappabot>    arising from the lite...
11:20:29 <dmwit> strange
11:20:32 <dmwit> > id
11:20:33 <kappabot>   Ambiguous occurrence `id'
11:20:33 <kappabot>  It could refer to either `GHC.Base.id',
11:20:34 <kappabot>         ...
11:20:36 <acube> lambdabot: > 1 2 3
11:20:41 <dmwit> > Prelude.id
11:20:42 <kappabot>   Not in scope: `Prelude.id'
11:20:43 <S11001001> @ty flip 1
11:20:44 <kappabot> forall (f :: * -> *) a b. (Functor f, Num (f (a -> b))) => a -> f b
11:20:57 <shachaf> Or maybe elliott can host it.
11:21:13 <acube> @ty GHC.Base.id
11:21:14 <kappabot> forall a. a -> a
11:21:20 <dmwit> > \() -> ()
11:21:21 <kappabot>   Overlapping instances for GHC.Show.Show (() -> ())
11:21:21 <kappabot>    arising from a use of...
11:21:27 <dmwit> hum =)
11:21:34 <acube> @ty Control.Category.id
11:21:35 <kappabot> forall (cat :: * -> * -> *) a. Category cat => cat a a
11:22:05 <acube> > 1 + 2 $ 3
11:22:05 <kappabot>   Overlapping instances for GHC.Show.Show (a1 -> a0)
11:22:06 <kappabot>    arising from the lite...
11:22:20 <acube> This is crazy
11:22:23 <dmwit> So how come :t show (1 2 3) doesn't complain about overlapping instances?
11:23:09 <monoidal> :t show (1 2)
11:23:10 <kappabot> String
11:23:20 <silasm> dmwit: because show a will always be of type string no matter how you define an instance?
11:23:35 <shachaf> @undefine
11:23:36 <acube> > show (1 2 3) :: String
11:23:36 <kappabot>   L.hs:103:37: Not in scope: `.'L.hs:107:19: Not in scope: type constructor o...
11:23:42 <acube> > show (1 2 3) :: String
11:23:42 <kappabot>   L.hs:103:37: Not in scope: `.'L.hs:107:19: Not in scope: type constructor o...
11:23:45 <shachaf> Hmm.
11:23:52 <acube> > show (1 2 3) :: String
11:23:53 <kappabot>   L.hs:103:37: Not in scope: `.'L.hs:107:19: Not in scope: type constructor o...
11:23:57 <acube> > 1 + 3
11:23:58 <kappabot>   L.hs:103:37: Not in scope: `.'L.hs:107:19: Not in scope: type constructor o...
11:24:00 <glguy> <_<
11:24:07 <acube> shachaf: you broke it!
11:24:21 <glguy> now we have two broken bots!
11:24:29 <otters> > 1
11:24:30 <kappabot>   L.hs:103:37: Not in scope: `.'L.hs:107:19: Not in scope: type constructor o...
11:24:31 <dmwit> :t show (read "foo") -- silasm
11:24:32 <kappabot> String
11:24:36 <dmwit> eh, what!
11:24:42 <otters> :t 3
11:24:42 <kappabot> forall a. Num a => a
11:24:46 <otters> :t \x -> x x
11:24:46 <kappabot>     Occurs check: cannot construct the infinite type: t1 = t1 -> t0
11:24:46 <kappabot>     In the first argument of `x', namely `x'
11:24:47 <kappabot>     In the expression: x x
11:24:58 <monoidal> :t read "x"
11:24:59 <kappabot> forall a. Read a => a
11:25:07 <shachaf> > 1
11:25:07 <kappabot>   1
11:25:08 <otters> :t read . (>>=)
11:25:08 <kappabot>     Couldn't match expected type `String'
11:25:08 <kappabot>                 with actual type `(a0 -> m0 b0) -> m0 b0'
11:25:08 <kappabot>     Expected type: m0 a0 -> String
11:25:25 <acube> :( In a channel of a language that claims that it's programs will have less bugs than programs in other languages ...
11:25:39 <glguy> You were reading "less" as "none"?
11:25:47 <Floris> ^ lol
11:26:04 <int-e> acube: besides all those type errors are bugs that you can't write
11:26:30 <Floris> how do i get 123 to of [(123,"just a string")] ??
11:26:31 <silasm> acube: compiler errors are exactly what keep you from writing bugs...
11:26:54 <glguy> Floris: case expression
11:27:03 <dmwit> :t def def
11:27:04 <kappabot>     Not in scope: `def'
11:27:04 <kappabot>     Perhaps you meant one of these:
11:27:05 <kappabot>       `dff' (imported from Data.Graph),
11:27:12 <dmwit> :t Data.Default.def Data.Default.def
11:27:13 <kappabot> Couldn't find qualified module.
11:27:17 <otters> :t a
11:27:18 <kappabot> Not in scope: `a'
11:27:41 <acube> @import
11:27:41 <kappabot> Unknown command, try @list
11:27:42 <monoidal> Floris: case x of [(n,s)] -> n; ... ?
11:27:43 <Floris> case expression?
11:27:53 <monoidal> Floris: yes
11:27:59 <monoidal> @info M.->
11:27:59 <kappabot> (M .->)
11:28:01 <acube> @define id a = a
11:28:03 <Floris> ah thanks will try that
11:29:38 <acube> > id 3
11:29:38 <kappabot>   3
11:29:43 <acube> > 3 + 4
11:29:44 <kappabot>   7
11:29:55 <acube> It works again! :)
11:30:16 <dmwit> > 1 2 3 :: ()
11:30:17 <kappabot>   Overlapping instances for GHC.Show.Show (a0 -> a1 -> ())
11:30:17 <kappabot>    arising from th...
11:30:19 <ptek> I am trying to install cabal with the ghc-7.6.3 and it fails on the unix dependency
11:30:22 <ptek> https://gist.github.com/ptek/6b6abc7b8c6a53701f97
11:30:28 <ptek> is this a know problem?
11:30:33 <dmwit> > 1 2 3 :: Integer
11:30:34 <kappabot>   Overlapping instances for GHC.Show.Show
11:30:34 <kappabot>                              (a0 ->...
11:31:08 <glguy> ptek: It looks like the version of Cabal you are trying to install is too old for 7.6.3
11:31:09 <acube> > 1
11:31:10 <kappabot>   1
11:31:24 <monoidal> ptek: try cabal  1.16.0.2
11:31:26 <ptek> glguy: its the newest I could get on the webpage
11:31:35 <ptek> http://www.haskell.org/cabal/download.html
11:31:46 <dmwit> Aha! Maybe kappabot is using a version of GHC where Show is a superclass of Num.
11:31:51 <Igloo> ptek: GHC comes with Cabal. You probably just want to use that
11:32:03 <ptek> ah
11:32:21 <ptek> Igloo but not the cabal-install, right?
11:32:30 <Igloo> ptek: Right
11:32:44 <monoidal> ptek: http://hackage.haskell.org/package/cabal-install
11:32:52 <silasm> @info Show
11:32:52 <kappabot> Show
11:32:55 <shachaf> dmwit: kappabot is using a released version of lambdabot.
11:32:57 <shachaf> So pretty old.
11:33:05 <shachaf> I don't know about the version of GHC anymore.
11:33:05 <monoidal> shachaf: which ghc?
11:33:19 <shachaf> It's either 7.0.3 or 7.4.2
11:33:22 <shachaf> Probably 7.0.3
11:33:25 <dmwit> That still doesn't explain why :t show (1 2 3) doesn't give an error, though.
11:33:38 <monoidal> > 1 2
11:33:38 <kappabot>   Overlapping instances for GHC.Show.Show (a1 -> a0)
11:33:38 <kappabot>    arising from the lite...
11:33:48 <ptek> monoidal: oh. Thank you! Didn't think of that
11:33:56 <shachaf> It should be noted that > goes via mueval and :t goes via ghci
11:34:08 <ptek> monoidal: looks like it works now
11:34:27 <dmwit> shachaf: ah... so extended defaulting...?
11:35:13 <shachaf> I don't know.
11:35:24 * shachaf has developed a remarkable apathy as far as figuring anything out about lambdabot is concerned.
11:35:32 <dmwit> < 1 2 3
11:35:36 <goodfellow>   mueval-core: Time limit exceeded
11:35:40 <dmwit> ...yes
11:35:51 <dmwit> < 1 2 3
11:35:52 <goodfellow>   1
11:36:19 <acube> who's goodfellow?
11:36:30 <dmwit> goodfellow is another lambdabot instance.
11:36:42 <acube> < 1 2 3
11:36:43 <dmwit> ...but with my patches to include universe. =)
11:36:43 <goodfellow>   1
11:36:51 <dmwit> < (==) == (/=) . not -- my favorite intro
11:36:54 <goodfellow>   True
11:36:55 <Eduard_Munteanu> LOL, wtf, doppelganger lambdabot week? :)
11:36:59 <dmwit> < (==) == (/=)
11:37:00 <goodfellow>   False
11:37:05 <acube> what's universe
11:37:10 <dmwit> Eduard_Munteanu: goodfellow has been hanging around in here more much more than a week =)
11:37:13 <dmwit> ?hackage universe
11:37:14 <kappabot> http://hackage.haskell.org/package/universe
11:37:15 <shachaf> lambdabot is still in this channel, by the way
11:37:17 <shachaf> Just +q
11:37:29 <Eduard_Munteanu> What's the point of this and kappabot?
11:37:35 <dmwit> lambdabot is broken
11:37:41 <dmwit> and kappabot doesn't have universe =)
11:37:56 <Eduard_Munteanu> dmwit: broken how? :/
11:38:00 <dmwit> "email"
11:38:26 <dmwit> (Nobody really knows what's broken. But mueval isn't working properly.)
11:39:58 <efie> I have to change entries in a vector a lot of times. I use Data.Vecto, is it recommend to use unsafeFreeze and unsafeThaw (and making sure that the 'old' vetors aren't used later on) or should I stick to IOVector throughout the whole program? Personally I think I wouldl like to try the first option
11:40:25 <shachaf> The first option is certainly not recommended.
11:41:12 <dmwit> Don't know much about Vector; is STArray a suitable substitute?
11:41:20 <shachaf> I don't know that the second option is recommended either; it dependson what you're doing.
11:41:28 <fizbin> STUArray.
11:41:53 <efie> shachaf: why? If I used IOVector this would pollute a bit of the code and would make think more difficult
11:42:04 <efie> ok
11:42:18 <efie> dmwit I don't know STArray
11:42:46 <efie> shachaf: In which case which option would be preferable over the other?
11:43:21 <dmwit> efie: No time like the present for learning!
11:43:28 <shachaf> there is a reason that unsafeFreeze and unsafeThaw are called those names.
11:43:46 <shachaf> Why would you take an immutable vector and then mutate it?
11:43:46 <Eduard_Munteanu> Hey, no calling names. :P
11:44:18 <glguy> efie: We don't know enough about what you're doing to give you a definitive answer, and even if the channel gave you permission to pollute your code with all kinds of hidden invariants with unsafe* it wouldn't make bughunting later any easier...
11:46:12 <Cale> Maybe try using the safe versions of thaw and freeze first
11:46:46 <Cale> and then if it performs poorly, you can try to find ones which it would be safe to replace with the unsafe versions of those functions.
11:46:51 <shachaf> Yes. Or, if you need mutation, use a mutable vector.
11:49:06 <Eduard_Munteanu> Moving stuff in and out of ST isn't really convenient either.
11:49:46 <Eduard_Munteanu> It is nicer for self-contained stuff, but if it pollutes your types, not so much.
11:49:57 <shachaf> Or use safe functions that can fuse in various ways. I think vector does some of that.
11:50:11 <shachaf> Anyway, I can't really say without knowing what the code is doing.
11:50:25 <shachaf> But I certainly won't blindly recommend unsafely mutating immutable vectors.
11:52:01 <tromp> the old question of what happens if an unstoppable mutation meets an immutable object
11:52:34 <c_wraith> usually the program crashes
11:52:58 <Hafydd> Can shachaf create an object so immutable that even he cannot mutate it?
11:54:57 <acube> > unsafeCoerce 1 :: Void -- Would that work? XD
11:55:00 <kappabot>   Not in scope: type constructor or class `Void'Not in scope: `unsafeCoerce'
11:55:10 <efie> thank you for your hints - shachaf: I used a mutable vecotr until now, but I want to use Data.MemoCombinators with a function which itself uses the mutable vector. But since type Memo a = forall r. (a -> r) -> a -> r I cannot use it with a function of type a -> IO a, because a and IO .. does not match, is this right?
11:55:34 <c_wraith> acube: it will work (not on the bots, though). It won't even crash, since Void doesn't have a runtime representation
11:55:50 <efie> 'because r and IO ... do not match'
11:56:11 <c_wraith> acube: the fact that void has no runtime representation means that nothing you can do with it will crash because the representation isn't what's expected
11:56:45 <Cale> efie: r will match IO a
11:56:54 <efie> oh ok
11:56:58 <shachaf> c_wraith: Well... It depends on how much you trust Void values.
11:57:04 <dmwit> Cale, efie: ...but not in a helpful way here.
11:57:08 <Cale> efie: However, you'll be memoising *which* IO action it is
11:57:14 <shachaf> c_wraith: For example you might write foo :: T Void -> T a; foo = unsafeCoerce
11:57:21 <Cale> efie: rather than the result of executing that IO action'
11:57:21 <shachaf> For some covariant type T.
11:58:35 <shachaf> c_wraith: This is safe for normal Void values (i.e. ⊥) but not for weird ones like this.
11:58:49 <dmwit> I blame the second unsafeCoerce, not the first one.
11:58:59 <dmwit> Let me try again.
11:59:06 <dmwit> I blame foo's unsafeCoerce, not acube's.
11:59:11 <c_wraith> I'm not sure it matters *which* unsafeCoerce is unsafer. :)
11:59:17 <shachaf> foo's unsafeCoerce is useful, though.
11:59:28 * dmwit nods agreeably at shachaf
11:59:50 <shachaf> It's useful and completely valid in the presence of only valid Void values.
12:00:11 <acube> lol that's an easy way to make an endless hang (unsafeCoerce 0 :: Void)
12:00:14 <shachaf> Whereas acube's is invalid and you just happen not to be able to find out.
12:00:49 <Hafydd> I wouldn't rely on unsafeCoerce being deterministic.
12:01:15 <dmwit> I would.
12:01:18 <dmwit> Random is hard.
12:01:58 <Hafydd> I wouldn't call it "deterministic" if it can perform IO.
12:02:17 <shachaf> Random over? I 'ardly touched 'em!
12:02:54 <acube> can you do IO with unsafeCoerce?
12:03:21 <shachaf> That depends on what you mean by "can".
12:04:13 <tromp> main = unsafeCoerce ()   ?
12:04:28 <tromp> unsafeCoerce:t
12:04:31 <tromp> :t unsafeCoerce
12:04:35 <kappabot> Not in scope: `unsafeCoerce'
12:04:36 <shachaf> I'm still waiting for Oleg to write type-level unsafeCoerce.
12:04:37 <monoidal> you can define unsafePerformIO x = runST (unsafeCoerce x) - although of course this relies on how GHC implements IO.
12:05:26 <`Jake`> Hey, I've got a little problem with my Gtk2hs GUI, basically I don't really know what's the best approach. I want to display the name of the user at all times in a label, and at the beginning, the name is obtained from a file. But while the program is running, the user should be able to click on a button and change their name via a dialog window. I don't really know how to store the name.
12:05:30 <Eduard_Munteanu> Interesting, that's weird.
12:07:07 <dmwit> `Jake`: The label is already storing it. See labelLabel (I wish I was joking).
12:07:27 <`Jake`> Oh, that's useful. Thanks.
12:07:44 <`Jake`> So I'm gonna be storing it using the FFI, basically?
12:07:56 <`Jake`> hidden in the gtk2hs library
12:08:00 <dmwit> You can of course store it yourself, too, if you want, e.g. in an IORef.
12:08:16 <ClaudiusMaximus> `Jake`: alternatively you can use IORef, MVar, TVar - take your pick (the last one with stm is probably best, because you can fork a thread that watches it, and if anything changes then postGUI updates all the things that need changing)
12:08:46 <byorgey> label_labelLabel
12:08:57 <`Jake`> OK, so these are the right options. I considered something like that, but it seemed so... agressive
12:09:34 <dmwit> If you plan on writing a multithreaded gtk2hs app, be sure to check out http://dmwit.com/gtk2hs first.
12:10:35 <`Jake`> Multithreading might be something I'm gonna do, but I don't think it's going to affect the GUI
12:10:59 <dmwit> I'd be very surprised.
12:11:11 <dmwit> It's pretty hard to write a thread that does something useful without wanting to show the result in the GUI.
12:11:40 * dmwit shrugs
12:11:43 <dmwit> It's possible, though.
12:12:07 <`Jake`> Alright... Well, I'm gonna bookmark that and check back when I do that part of the program, or should I read it before I even continue designing the GUI?
12:12:41 <t7> > let f x = x !! iterate (* 1.2) 2 in f 11
12:12:41 <kappabot>   Couldn't match expected type `GHC.Types.Int'
12:12:41 <kappabot>              with actual type ...
12:12:53 <`Jake`> Well, I guess it's not that long. I might as well read it.
12:12:53 <t7> > let f x = iterate (* 1.2) 2 !! x in f 11
12:12:54 <kappabot>   14.860167413759998
12:13:11 <t7> how do i make that an O(1) function?
12:13:27 <t7> do i need a power in there?
12:13:30 <t7> to the power of
12:13:48 <t7> how do i do curves? i never did this at school :(
12:13:54 <shachaf> You can't make in O(1) function.
12:13:59 <aavogt> probably    2*1.2^x  isn't O(1)
12:14:06 <shachaf> s/in/it an/
12:14:30 <dmwit> You probably don't need to read it before you write your first forkIO.
12:14:39 <aavogt> or maybe it is depending on how you feel like defining the machine it runs on
12:15:08 <monoidal> ^ is defined using binary exponentiation, so it's O(log n) multiplications. how fast multiplications are, depends on the type.
12:15:23 <dmwit> Depending on how you define n.
12:15:32 <monoidal> exponent
12:15:32 <aavogt> monoidal: 1/log n of course
12:15:49 <t7> computers dont have an exp instruction>
12:15:59 <Hafydd> Yours doesn't.
12:16:20 <dmwit> > 1.2^11 * 2
12:16:21 <kappabot>   14.860167413759998
12:16:32 <t7> 2 * 1.2 ^ x  <- it was that simple...
12:16:35 <`Jake`> dmwit: I'm gonna do it anyways. Can't hurt.
12:16:43 * dmwit agrees
12:17:11 <`Jake`> :t (2 * 1.2 ^ x)
12:17:12 <kappabot> Not in scope: `x'
12:17:24 <`Jake`> :t (\x -> 2 * 1.2 ^ x)
12:17:25 <kappabot> forall a b. (Fractional a, Integral b) => b -> a
12:17:29 <`Jake`> :t (\x -> 2 * 1.2 ** x)
12:17:29 <kappabot> forall a. Floating a => a -> a
12:17:53 <Cale> :t (\x -> 2 * 1.2 ^^ x)
12:17:54 <kappabot> forall a b. (Fractional a, Integral b) => b -> a
12:18:08 <Cale> (Same type, but that one can handle negative exponents)
12:18:15 <Cale> :t (^)
12:18:16 <kappabot> forall a b. (Integral b, Num a) => a -> b -> a
12:18:17 <Cale> :t (^^)
12:18:18 <kappabot> forall a b. (Fractional a, Integral b) => a -> b -> a
12:18:20 <Cale> :t (**)
12:18:21 <kappabot> forall a. Floating a => a -> a -> a
12:18:24 <dmwit> > 2 * 1.2 ** 11 -- this may actually be one instruction, right?
12:18:25 <kappabot>   14.860167413759994
12:18:32 <dmwit> Well, not the (2*) part.
12:18:41 <dmwit> O(1) instructions =P
12:19:36 <`Jake`> Wow. I didn't even notice until now that lambdabot isn't participating in our conversation.
12:20:56 <Cale> dmwit: Well, maybe, though I think the floating point units usually implement base 2 log?
12:21:51 <Cale> So it would compute log_2 1.2, multiply that by 11 and then raise 2 to that power.
12:22:26 <Cale> Yeah, the instruction on x86 is FYL2X
12:29:50 <Cale> One thing which I've never understood is why assemblers still use such awkward mnemonics and syntax. Just because each line refers to a machine instruction doesn't mean that the names of the instructions have to be 3 or 4 letter abbreviations all the time. :P
12:30:15 <shachaf> The mnemonics are standardized.
12:30:28 <Cale> kinda
12:30:51 <Cale> For any one architecture they are
12:31:10 <Cale> But... why is the standard so awkward? I guess it's just cultural.
12:31:36 <fizbin> Cale: given the sheer volume of instructions needed for relatively simple things, wouldn't you want terse mnemonics?
12:32:06 <simon___> terse?
12:32:31 <mauke> no, I love to type "perform" instead of "do"!
12:33:04 <shachaf> I,I progn
12:33:30 <Cale> fizbin: To some extent, yes. But when it gets to the point where you have to look up what these little suffixes of 1 or 2 characters on the end of something otherwise recognisable mean all the time, it's maybe time to consider separating those off.
12:33:53 <shachaf> Cale is probably thinking of reading assembly, not writing it.
12:33:58 <Cale> yes
12:34:04 <shachaf> When each instruction takes a whole line anyway, saving space doesn't matter much.
12:34:06 <Cale> Who writes assembly by hand anyway? :)
12:34:59 <Cale> and "oh no, my compiler's intermediate assembly file might be *kilobytes* larger" just doesn't seem like a big deal
12:35:04 <acube> assembly is just like lens: you always need a reference to understand code writen in it
12:37:05 <Ralith> acube: by corrolary, someone will have to write a compiler that uses lens expressions as IR
12:40:41 <Eduard_Munteanu> Then someone will come up with a Lens Machine to execute that efficiently. :P
13:10:35 <NemesisD> hey guys, was looking for some advice on a library that binds to an HTTP REST API
13:11:18 <NemesisD> a common pattern I'll have is a resource like Dashboard. i'll have functions for createDashboard :: Dashboard -> ..., updateDashboard :: Dashboard -> ...
13:12:10 <NemesisD> the problem is that the create case has no id, the update case needs to know the id of an existing dashboard. and i'm a bit uneasy about keeping the id in a separate data structure
13:12:53 <NemesisD> one solution is: createDashboard :: NewDashboard -> IO (Dashboard), updateDashboard :: Dashboard -> IO ()
13:14:25 <NemesisD> but i think i'd have to use the same fields for NewDashboard and Dashboard, but the new one would have no id. don't want to have a maybe ID field because it allows you to do nonsensical things like update a dashboard without an id. what do you guys think?
13:16:39 <NemesisD> i could wrap it, like data BaseDashboard = ... data Dashboard = Dashboard { dashboardId :: Text, dashboard :: BaseDashboard }, wonder if that will make it too hard to work with
13:16:49 <supki_> createDashboard :: Dashboard Void -> IO (Dashboard Id)  ?
13:17:17 <acube> Why Void? You need one value for Id, so i'd use () instead?
13:18:05 <NemesisD> ahhh. i didn't consider that. but how do i restrict values of a for Dashboard a
13:18:18 <NemesisD> because the only valid things are Dashboard () and Dashboard ID, presumably
13:18:23 <supki_> why would you?
13:18:29 <supki_> you restrict function types
13:18:52 <NemesisD> ohh i see
13:19:11 <supki_> acube: I personally just like Void, () will work too
13:19:17 <dmwit> That is one possibility.
13:19:36 <NemesisD> supki_: i guess the only thing i worry about there is discoverability. the docs would need to communicate that they should only construct Dashboard () and Dashboard ID. i know the call sites would enforce this but i'm aiming for ease of use
13:19:52 <dmwit> Another is data WithID a = { id :: ID, v :: a }, and then use Dashboard and WithID Dashboard.
13:20:04 <dmwit> The benefit of this approach is that it's quite uniform if you're going to have many Dashboard-like types.
13:20:26 <dmwit> e.g. you might reasonably expect there to be a function Create a => a -> WithID a
13:21:02 <NemesisD> dmwit: ah interesting
13:21:38 <NemesisD> dmwit: i kind of like keeping the ID on the object itself as it is just as useful as any other attribute i think
13:21:49 <dmwit> Use lens. =)
13:22:01 <NemesisD> dmwit: oh i am :D
13:22:15 <NemesisD> though definitely not to full potential
13:22:23 <dmwit> So what's the problem? All the other attributes are just as easy to set and get on a WithID a as they are on an a, given appropriate lenses.
13:22:34 <NemesisD> i tend to do things the hard way and then go back and clean up my functions to use lens stuff
13:22:42 <dmwit> instance HasFoo Dashboard; instance HasFoo a => HasFoo (WithID a)
13:23:08 <thetallguy1> can anyone recommend light reading on the Constraint kind?  Something with a lot of examples, say?
13:23:09 <NemesisD> ah ok
13:26:19 <byorgey> thetallguy1: http://dorchard.wordpress.com/2011/09/22/constraint-kinds-in-haskell-finally-bringing-us-constraint-families/
13:27:56 <thetallguy1> byorgey: thanks, I hadn't found that yet
13:32:16 <Ben1> Hi, I am a Haskell beginner. I am using Ubuntu. I used apt-get install haskell-platform, but I didn't get ghci. I do have ghc, any ideas how to get ghci?
13:32:48 * hackagebot steeloverseer 0.1.0.1 - A tool that runs a list of commands after files change on disk.  http://hackage.haskell.org/package/steeloverseer-0.1.0.1 (SchellScivally)
13:33:09 <tgeeky> Ben1: search for ghci using find or updatedb or whatever
13:33:28 <shachaf> ghc --interactive
13:33:35 <shachaf> But it should be there somewhere.
13:33:41 <tgeeky> shachaf: yes, but there are other shortcuts that are installed somewhere
13:33:45 <tgeeky> cabal, etc
13:34:10 <tgeeky> Ben1: private message me I'll try to help you out
13:34:56 <Shamar> Hi, I need some help with a lazy function that works like it was strict
13:35:17 <Shamar> obviously, I'm wrong somewhere but I can't grasp where
13:35:27 <Shamar> here is the full problem http://codereview.stackexchange.com/questions/26107/how-to-improve-readability-and-memory-footprint-of-this-haskell-script
13:36:46 <Shamar> I have an IO function that should foldl lines of a files and produce other files
13:36:54 <Shamar> it's signature is transformFile :: FilePath -> ([String] -> a) -> (a -> IO r) -> IO r
13:37:02 <c_wraith> Shamar: a left fold will never be lazy
13:37:14 <Shamar> huh?
13:37:50 <Shamar> no... is so huge my misunderstanding? :-o
13:37:53 <Shamar> really?
13:38:10 <c_wraith> Shamar: just by the definition of foldl, it will always need to traverse the whole list before it produces any output
13:38:18 <Cale> @src foldl
13:38:19 <kappabot> foldl f z []     = z
13:38:19 <kappabot> foldl f z (x:xs) = foldl f (f z x) xs
13:38:35 <Cale> foldl does nothing but apply itself to different arguments until it reaches the end of the list
13:38:38 <Cale> @src foldr
13:38:38 <kappabot> foldr f z []     = z
13:38:39 <kappabot> foldr f z (x:xs) = f x (foldr f z xs)
13:39:10 <Cale> foldr on the other hand immediately passes control to f, who can then decide whether to produce some output before continuing
13:39:10 <Shamar> omg...
13:39:47 <Ndit> Cale why cant records be modules
13:39:47 <Shamar> I did initially wrote it with a foldr... but it was reverting the input
13:40:02 <Shamar> so I thought that it was strict...
13:40:18 <Shamar> thus the problem was in the folding function, right?
13:40:36 <Cale> Shamar: I don't know what the problem actually is...
13:40:42 <Cale> Ndit: ?
13:41:35 <Cale> Ndit: Modules in Haskell are only used to control namespaces.
13:41:51 <Cale> Ndit: Records are not, because modules can already do that job.
13:41:52 <Ndit> Why cant records create modules?
13:41:56 <Shamar> Cale c_wraith thanks, btw...
13:42:25 <Ndit> If I create a record, obviously I want a module for it ...
13:42:26 <Cale> Why?
13:42:33 <Ndit> I do not want global functions splattered out into my thing like some 1970's code
13:42:40 <Cale> I often don't put records off in their own modules.
13:42:45 <Ndit> its not even reasonable, i hate it
13:42:46 <Cale> ?
13:42:48 * hackagebot steeloverseer 0.1.0.2 - A tool that runs a list of commands after files change on disk.  http://hackage.haskell.org/package/steeloverseer-0.1.0.2 (SchellScivally)
13:42:57 <Cale> I don't understand your reaction.
13:43:35 <Ndit> Cale: the problem with the name clash cause of records creating getters in the module instead of module.foo
13:43:47 <Ndit> That is the stupidest thing obsolete and bad
13:43:53 <Cale> Ndit: Now, the fact that the field names correspond to extraction functions rather than something a little more general like lenses is a bit unfortunate
13:44:04 <Cale> But it's understandable given that lenses are a new invention.
13:44:17 <Ndit> I dont want extra syntax or words
13:44:19 <Ndit> I want
13:44:36 <Ndit> only the nouns and adjectives and verbs etc
13:44:44 <Cale> ?
13:44:50 <Ndit> records without using lenses as extra syntax is like that
13:45:08 <Cale> This is a programming language. It doesn't have those syntactic classes.
13:45:42 <Ndit> Cale, I want to create records with almost no syntax, and not a lot of keywords, or setting up lenses
13:46:04 <Ndit> just my own identifiers in a super short test case
13:46:06 <Cale> What are you actually trying to accomplish?
13:46:21 <Cale> Maybe you don't even need a record type?
13:47:57 <Cale> There are always tuples. People usually don't like those because they express less type structure, but they certainly require less setup.
13:48:13 <tgeeky> does anyone know if there ever was a haskell-platform 2012-1.0.0 release?
13:48:27 <tgeeky> it doesn't seem to be there on the wiki, the earliest 2012 one being -2.0.0
13:48:30 <Botje_> we don't talk about 2012-1.0.0.
13:48:35 <Cale> Ndit: Do you have an actual program that you're trying to improve in some way?
13:48:50 <tgeeky> Botje_: ok. that makes sense, it didn't even include ghci, evidently :o
13:48:51 <Cale> Ndit: If you stick it on hpaste, perhaps people can make suggestions about how to improve it.
13:49:10 <Igloo> tgeeky: http://trac.haskell.org/haskell-platform/wiki/VersionNumbers
13:49:12 <Ndit> Cale: I had a program that I tried making in Haskell but I gave up on it because it required using 40 .hs files instead of 1 .cpp file for one of the parts of it
13:49:28 <Ndit> it drove me insane
13:49:32 <Cale> You can always collapse multiple modules into a single one.
13:49:58 <Ndit> i want to read the damn .hs file, not browse the file system
13:50:07 <Ndit> i dont even like the filesystem
13:50:11 <Cale> Then only write one .hs file
13:50:23 <Ndit> and have lenses everywhere
13:50:27 <Ndit> which is not expressive
13:50:29 <Cale> ?
13:50:39 <glguy> Ndit: If you just want to rant you are in the wrong channel
13:51:08 <Cale> Ndit: I'm confused. What are you trying to express? Why do you feel that lenses are inadequately expressive (relative to what?)
13:51:10 <tgeeky> Igloo: I was going to say this doesn't help me, but I think you're pointing out that you use odd/even testing/stable, and that 2012-1.xx was a testing release.
13:51:13 <tgeeky> Igloo: correct?
13:51:47 <Cale> Ndit: Also, just because you collapse things into one file doesn't mean you have to use lenses
13:51:51 <Igloo> tgeeky: Right (or it may not have existed at all, I don't know)
13:51:52 <Cale> that's an orthogonal issue
13:52:17 <Cale> It does mean that you have to name things properly with non-colliding names
13:52:23 <Cale> But that is *not* hard to do.
13:52:36 <tgeeky> Igloo: yes, that's what I was getting at: I can't seem to even find a record, and yet evidently chrubuntu (crhomebook version) still has 2012-1.0.0.0 as the latest haskell-platform, which doesn't even contain ghci!
13:52:39 <Cale> And imo is also more convenient most of the time anyway.
13:52:48 * hackagebot hledger-irr 0.1.1.1 - computes the internal rate of return of an investment  http://hackage.haskell.org/package/hledger-irr-0.1.1.1 (JoachimBreitner)
13:53:22 <Ndit> Cale I am angry at you
13:53:26 <Cale> I tend to think of the module system as being a means of last resort to provide a way to deal with name collisions, rather than something which you should lean on to name lots of things with the same identifier.
13:53:35 <Ndit> telling me to name stuff with non colliding names makes me furious
13:53:40 <Ndit> they dont have fucking non colliding names
13:53:45 <Ndit> the names ARE WHAT THEY ARE
13:53:56 <Cale> The names are whatever you want them to be.
13:53:59 <Ndit> i am not renaming bullshit to stupid fucking non colliding names for no reason besides a problem in haskell
13:54:02 <Cale> It's your source code.
13:54:04 --- mode: ChanServ set +o glguy
13:54:10 --- mode: glguy set +q Ndit!*@*
13:54:17 <glguy> Please take a break and calm down
13:54:23 <Cale> glguy: Hey, I was talking to him.
13:54:29 <Cale> oh well.
13:54:37 <Cale> I suppose he does need to take a break
13:56:15 <Shamar> Cale actually names are often important
13:56:47 <Cale> Shamar: They're important, sure.
13:57:00 <Shamar> and despite being "my" source code, it's often a good practice to use names from the domain
13:57:02 <Cale> But to say that you have no control over what they are whatsoever is a lie.
13:57:15 <Cale> You absolutely do have choices.
13:57:41 <Cale> and choosing to use the same name for many unrelated things of different types often isn't the best idea
13:57:42 <Shamar> well, sometimes choise are a bit poor
13:58:04 <Cale> unless you really want/need that polymorphism, in which case, that's what typeclasses are for
13:58:23 * geekosaur dares whoever to name something in their C++ "template", since names are so very important...
13:58:31 <Shamar> names are not always related to polymorphism
13:59:02 <Cale> In the case that you don't want the polymorphism, you probably also *shouldn't* name those things the same.
13:59:19 <Cale> Maybe I'm a little old fashioned in that regard.
13:59:23 <hiptobecubic> Why?
13:59:47 <Cale> I started programming in Haskell back when modules actively tried to be importable unqualified.
14:00:07 <Cale> and not step on each others' toes
14:00:14 <Cale> (Or on the Prelude's)
14:00:21 <hiptobecubic> If I have a datatype "Man" and "m :: Man" and i want "head m" to return the head of the Man, is it that crazy?
14:00:29 <Shamar> Cale, I'm looking at the question from a cognitive perspective
14:00:44 <rhodesd> data Point2 = Point2 { pt1_x :: Int, pt2_y :: Int}
14:00:48 <rhodesd> crap
14:00:58 <Shamar> take for example the term Line
14:00:59 <tgeeky> Igloo: ARM support is more recent than any haskell-platform, yes?
14:01:13 <Shamar> it's appropriate in many different contexts
14:01:40 <Cale> hiptobecubic: Well, it sounds reasonable, up until there's an occurrence of head somewhere that you can't immediately tell that m is a Man.
14:02:17 <Cale> hiptobecubic: and then you have to typecheck everything under the assumption that it's a list and under the assumption that it's a Man and see what works, and maybe both do, or maybe just one does.
14:02:39 * bitonic tends to agree with Cale
14:02:48 <Cale> and it's a lot of cognitive burden for a tiny amount of vanity
14:02:58 <Shamar> lool
14:02:59 <bitonic> I wouldn’t mind the module system to be more flexible though
14:02:59 <`Jake`> Is lambdabot broken?
14:03:11 <Cale> `Jake`: The machine it's running on is misbehaving
14:03:22 <Igloo> tgeeky: I haven't been following the arm story, sorry. But unreg at least will work with older GHCs
14:03:35 <`Jake`> ok...
14:03:50 <Cale> So shachaf brought in a clone of lambdabot called kappabot -- it's the same thing running on another machine.
14:03:50 <bitonic> and they idea of records being modules is actually not too bad
14:03:59 <`Jake`> I see
14:04:13 <bitonic> at least it seems to be OK (especially if your module system is more flexible)
14:04:26 <Shamar> Cale, I see what you mean, but still in complex domains using the language model isn't that vanity
14:04:35 <Cale> I really hate the concrete syntax of modules in Haskell though.
14:04:52 <Cale> Overloading '.' was a kind of shitty choice.
14:04:54 <thetallguy1> I speculate that Ndit's frustrations are deeply related to the oo v functional divide
14:05:03 <hiptobecubic> :t x
14:05:04 <kappabot> Not in scope: `x'
14:05:17 <thetallguy1> also, to Wadler's law about syntax vs semantics
14:05:50 <bitonic> thetallguy1: well this is not really syntax.
14:06:34 <bitonic> (before Cale started talking about syntax a minute ago)
14:06:35 <thetallguy1> bitonic:  Ndit: the names ARE WHAT THEY ARE
14:06:52 <bitonic> lol OK but he was referring to how the module system works
14:06:53 <Cale> bitonic: I have to confess that part of the reason I don't like the idea of making record types into submodules is that the syntax of module qualification sucks and I try to avoid it at every turn.
14:07:16 <bitonic> Cale: OK, but this is not what Ndit was unhappy about
14:07:23 <thetallguy1> bitonic: also how record work in haskell, right?
14:07:25 <staafl_alt> does this helper method exist in the prelude: "ifelse a b bool = if bool then a else b"
14:07:30 <bitonic> thetallguy1: ?
14:07:32 <Shamar> to my money, it's related to OO... but still in complex "human driven" domains names ARE what they are
14:07:50 <staafl_alt> I mean, not the thing itself, but something equivalent
14:07:54 <Hafydd> @hoogle Bool -> a -> a -> a
14:07:54 <kappabot> A Hoogle error occurred.
14:07:55 <Shamar> for example in regulations
14:08:13 <staafl_alt> Hafydd, would hoogle detect a permutation of arguments?
14:08:20 <Hafydd> IDK.
14:08:25 <Hafydd> Probably not.
14:08:31 <Cale> Of course, if we were dependently typed, the only real difference between a module and a record type would be the namespacing aspects.
14:08:43 <thetallguy1> he says Ndit: I dont want extra syntax or words // I want // only the nouns and adjectives and verbs etc
14:08:48 <bitonic> Cale: I don’t see how dependent types affect this
14:08:54 <Cale> thetallguy1: I didn't understand that comment at all.
14:09:06 <Cale> Haskell doesn't have adjectives, nouns or verbs.
14:09:13 <Shamar> I've worked a lot with legal software (not in haskell, of course) and I had to debug code with a lawyer near me... in that case, DDD and OOP had a value
14:09:16 <mel-> hi
14:09:23 <staafl_alt> hmm, I guess it doesn't exist
14:09:33 <bitonic> Shamar: had a value compared to what?
14:09:34 <staafl_alt> what's a more eloquent way to write it?
14:09:37 <thetallguy1> and  Ndit: Cale: the problem with the name clash cause of records creating getters in the module instead of module.foo
14:09:57 <Cale> thetallguy1: indeed
14:10:13 <thetallguy1> Cale: indeed.  I am attempting to read between the lines of NDit's frustration
14:10:13 <Shamar> to code that had just expressed my own understanding of the domain
14:10:28 <Cale> thetallguy1: Though, see, we could get away with the names being getters from outside the module then.
14:10:31 <Shamar> that OO code expressed his own understanding of the domain
14:10:38 <staafl_alt> sorry for repeating :-) is there a more civilized way to implement this: ifelse a b bool = if bool then a else b
14:10:39 <Shamar> he could almost read the code alone
14:10:54 <elliott> staafl_alt: you could do: ifelse a b True = a; ifelse a b False = b
14:10:57 <staafl_alt> it's useful but this it looks pretty naive
14:10:58 <Cale> thetallguy1: If we accepted somewhat different module qualification syntax, where the names would then be functions taking a module parameter...
14:11:02 <bitonic> Shamar: but I’m asking what was the OO compared to.  did you try with data types and functions?  what was the ‘other’ code?
14:11:14 <Cale> Of course, we'd need module types then, and things might be a bit elaborate.
14:11:37 <staafl_alt> elliott, yeah, that's not much of an improvement though :-/
14:11:48 <elliott> staafl_alt: well, you only have to define it once
14:11:52 <dmwit> staafl_alt: That's a fine implementation, though I typically name that function "bool" (by comparison to "maybe", "either").
14:11:54 <thetallguy1> part of it seems to be simply that all languages he has experienced to date have a much different scoping behavior of record accessors and he feels suddenly like he sis speaking a foreign language
14:11:56 <elliott> btw, "bool" is a more common name
14:12:03 <elliott> though if you call it "bool" then the False case usually comes first, I think
14:12:18 <Shamar> no, I didn't... but name clashes would be common in functional code as they are in OO one
14:12:19 <Cale> Which ought to be understandable because he is :P
14:12:24 <staafl_alt> elliott, yeah, but prefer to figure out the most intelligent way usually
14:12:25 <shachaf> We shouldn
14:12:38 <staafl_alt> dmwit, I'll take your suggestion
14:13:12 <Shamar> bitonic, I mean: in Haskell I'd have to cope with such clashes with conventions
14:13:13 <staafl_alt> elliott, dmwit, thanks :-)
14:13:47 <thetallguy1> Cale: it seems to me rather like Richard Dawkins' point about evolution: humans tend to think they are experts in being human, simply because they are human
14:14:04 <bitonic> Shamar: I don’t know, I think it’s simply that people tend to transfer their habits to Haskell and it doesn’t really work out.  record fields scoping can be annoying in Haskell, but it’s way less of a big deal than most people make it imo...  I just prefix the field names with an abbreviation of the type
14:14:32 <Cale> bitonic: exactly
14:14:53 <thetallguy1> programmers tend to think they are experts in language design, by virtue of having programmed in many languages
14:14:56 <Cale> and if you didn't do that, you'd be qualifying them with module names everywhere anyway
14:15:16 <Cale> so it doesn't really make that much difference to have a little prefix
14:15:48 <Shamar> Cale, bitonic, you see no noise?
14:15:55 <bitonic> Shamar: not really
14:16:05 <Cale> Shamar: I see relevant information.
14:16:05 --- mode: glguy set -q Ndit!*@*
14:16:09 <fizbin> What I'd like to see is record fields that automatically created type classes the way makeFields (in Control.Lens.TH) does it.
14:16:56 <Ndit> thetallguy1, you can't derive from my critique of the language that I'm some java programmer trying to write a class in Haskell, because there's no proof for that anyways, so why guess about it
14:16:57 <Shamar> well... actually, lawyers aren't good at higher order abstractions... :-)
14:16:57 <thetallguy1> bitonic: indeed.  But suddenly being mute, when you were formerly fluent, affects us humans at a very fundamental level
14:16:59 <Cale> The extra tag lets me distinguish which record type I'm accessing from in many settings where that would otherwise be ambiguous.
14:17:02 <fizbin> So that I could use the field names as accessor functions without prefixing them, and use the same names in pattern matching.
14:17:14 <Ndit> you try to say I haven't "adjusted" to the language, yet it is not theoretical
14:17:27 <Ndit> it is *literal* a bunch of extra files on my filesystem that I have to browse, or a bunch of prefix names
14:17:30 <Ndit> and the code is shorter in C++
14:17:31 <thetallguy1> Ndit: I felt like guessing about it
14:17:32 <Shamar> thus they probably can't read haskell code even with such kind of name overloads
14:17:33 <elliott> Ndit: chil.
14:17:35 <elliott> *chill
14:17:44 <thetallguy1> Ndit: and you weren't here
14:17:51 <bitonic> thetallguy1: but you’re talking about different languages—I think that if you are willing to take subtyping onboard, for example, you’re already halfway done
14:18:01 <bitonic> (and Haskell is not willing :)
14:18:15 <Cale> Ndit: You might get a better response if you asked for a code review and put the source on github or something.
14:18:34 <Cale> (or on hpaste, though that can be awkward for larger chunks of code)
14:18:42 <thetallguy1> Ndit: and mostly, I was trying to understand your frustrations with an eye to improving the experience of people learning and using Haskell.
14:19:26 <Ndit> operator 'this' is overloaded in C++ to invoke the correct getter function based upon the type
14:19:30 <Cale> bitonic: That's an excellent point
14:19:35 <Ndit> you dont need to keep referring to the namespace of it
14:19:41 <Ndit> Why can't haskell do that?
14:19:41 <thetallguy1> bitonic: really, I'm thinking about how emotions affect our thinking.
14:20:27 <elliott> Ndit: the reason has already been explained during this discussion, even.
14:20:38 <Cale> Ndit: C++ enjoys far worse type inference than Haskell does.
14:20:42 <bitonic> thetallguy1: I’m not sure I’m confident to talk about that ehe
14:20:43 <elliott> such ad-hoc overloading of everything is problematic from a typechecking/inference POV.
14:20:50 <Ndit> I read it, did not see a reason against that
14:21:00 <thetallguy1> bitonic: me neither, but I was forging ahead anyway
14:21:37 <bitonic> Ndit: what are you proposing, exactly?  ‘wrapping’ each record fields in a module named like the record?  overload record fields?
14:21:46 <Ndit> Both
14:21:50 <Cale> Ndit: This is in part due to these kinds of overloading, which require the knowledge of certain types in order to select an overloading of various things, with no way of deferring that choice until higher up in the program.
14:22:20 <bitonic> Ndit: I think Cale did explain why the latter is dangerous—inference becomes brittle
14:22:32 <bitonic> (and I’m not sure why you’d want both)
14:22:32 <Shamar> elliott, that's probably the main issue... we are use to code to developers, not to compilers...
14:22:58 <elliott> Shamar: we must code within the realm of possibility. we make endless compromises for that.
14:23:07 <Cale> Ndit: In Haskell, we use type classes to provide overloading of terms. The fact that type classes have names allow them to appear in types of things, and allow definitions in which the choice of instance to use is ambiguous to have polymorphic inferred types.
14:23:07 <Ndit> how can the polymorphism be ambiguous in any place?
14:23:09 <Shamar> sure
14:23:16 <bitonic> Ndit: having records = module is not really viable with Haskell current system—if we had more flexible modules like, say, in Agda, then it would be nice imo
14:23:18 <thetallguy1> elliott:ooh, elegant
14:23:54 <Ndit> Cale: it would use an operator that is unused in a currently invalid syntax construct
14:23:55 <bitonic> Ndit: ‘data Foo1 = Foo1 {bar :: Int}; data Foo2 = Foo2 {bar :: Int}’, what’s the type of ‘quux x = bar x’?
14:24:25 <Ndit> I don't mean overloading like that
14:24:35 <Cale> Ndit: Suppose I write foo.x in C++ and I don't know the type of foo. There's no way to express the idea that "foo is any type which has a field with the name x". Of course, in C++ it's less of an issue, since you tend to explicitly type every one of your variables at its point of introduction.
14:24:42 <Cale> But we don't want to have to do that.
14:24:42 <bitonic> Ndit: OK, then explain more precisely what ‘overloading’ means
14:24:44 <Shamar> still, elliott, I would accept to always define functions signature for a better "overloading"...
14:24:59 <Shamar> but probably, this comes from my OOP experience
14:25:26 <Shamar> I can see how an haskeller prefer type inference...
14:25:27 <acowley> Something like, ("bar":::Int) ∈ rs => PlainRec rs -> Int
14:27:29 <sm> is there an automated way to find redundant/unused build-depends in a cabal file ?
14:27:30 <bitonic> acowley: that’s not that viable either from std Haskell, and still pretty awkward with GHC Haskell
14:28:00 <acowley> What is "std Haskell"?
14:28:08 <bitonic> acowley: standard
14:28:31 <Ndit> Cale: why is there no way to express that foo is any type with a field name x?
14:28:37 <Cale> Ndit: In C++?
14:28:50 <bitonic> Ndit: but that’s not what (most) OO languages do
14:28:52 <Cale> Ndit: It doesn't have syntax or semantics for such type descriptions.
14:28:59 <acowley> bitonic: I don't think that's a useful goal
14:29:25 <acowley> bitonic: If you want to target a specific compiler or standard, okay, but then asking for language extensions is out of scope.
14:29:52 <Ndit> Cale, not in C++, in the overload selection you presented
14:29:58 <Cale> Ndit: Doing this right involves something called row polymorphism. While there have been many proposals to add row types to Haskell, none of them have really taken off in popularity, and few of them have been implemented.
14:30:02 <bitonic> acowley: well, I think it’s dangerous to offer that as the solution to the ‘record’ problem since it’s not obvious to me how it could replace the current system nicely
14:30:03 <Ndit> in C++ it's done via Concepts
14:30:05 * geekosaur wonders if the real question here isn't it "why isn't it an OO language?"
14:30:08 <acowley> bitonic: So, yes, my answer is only accepted in relatively modern versions of GHC
14:30:09 <glguy> Ndit: There are other record systems that have been proposed and even implemented in other contexts for Haskell. Check out http://hackage.haskell.org/trac/ghc/wiki/ExtensibleRecords
14:30:23 <Ndit> I am checking it
14:31:00 <Cale> Ndit: But yeah, the main problem is that it's obnoxiously difficult to admit such a system without making type inference worse.
14:31:08 <bitonic> acowley: I mean personally I don’t think that it would be elegant to have a system like that, but I guess it’s a matter of taste
14:31:45 <acowley> bitonic: We already have a system like that. People (beyond just me) should play with it!
14:31:49 <Ndit> Cale: but records are sealed, therefore it's statically inferrable the whole way through
14:31:54 <bitonic> I don’t like the fact that you are accessing fields ‘syntactically’ in a generic manner—that kind of generic access can probably be abstracted better with a typeclass
14:32:02 <Cale> Ndit: What do you mean by "sealed"?
14:32:09 <bitonic> acowley: what of the various record systems are you referring to?
14:32:15 <bitonic> *which one of
14:32:16 <Ndit> Cale, not using an extensible records system
14:32:16 <acowley> bitonic: vinyl
14:32:36 <ocharles> lazy web: does anyone have a copy of The Underappreciated Unfold by Jeremy Gibbons in PDF that doesn't suck at rendering?
14:32:58 <Shamar> guys, may be the problem is context and readability... type inference is far better for compiler than for humans
14:33:07 <Ndit> Cale, can you add a new field to a record?
14:33:27 <bitonic> acowley: eh I did take a brief look but it muddles up things in terms of types...  I’d like to keep a system where things are fairly clear (at least in Haskell)
14:33:28 <Ndit> if you cannot, then the whole thing reduces to no ambiguity
14:33:53 <acowley> bitonic: How does it muddle up things in terms of types?
14:34:34 <bitonic> acowley: well for me is simply the fact that I don’t have a clear pictures of all the things fit together in terms of inference and even checking, and I try to limit that
14:34:57 <Cale> Ndit: If I'm allowed to write something which is the equivalent of "extract the value of the field x from the record r", and different record types in scope are allowed to have fields with the same name x, I either need some way to express the polymorphism in that operation, allowing different types of records r, or I end up needing to know which type of record r is -- i.e. I can't infer it.
14:34:59 <bitonic> even much simpler things can be very surprising, I try to avoid surprises :P
14:35:12 <acowley> bitonic: That sounds like a good reason to play with it to increase your familiarity with the approach
14:35:24 <dolio> Vinyl is all implemented in type hackery, no?
14:35:31 <ocharles> hardly hackery
14:35:35 <bitonic> acowley: but I can’t point you at specific things now.  but for example even ‘simpler’ things like RankNTypes can be very surprising
14:35:43 <ocharles> it uses advanced type machinery, but i wouldn't say it's a hack
14:35:45 <acowley> bitonic: I certainly don't want to argue that vinyl is perfect, or the future, or anything, but it offers a pretty wonderful amount of flexibility.
14:35:56 <acowley> dolio: :((((
14:35:59 <dolio> Yes, I suppose it's close to acceptable tools nowadays.
14:36:01 <Ndit> Cale: why can't the overload apply to anything with the record type of r?
14:36:07 <dolio> Way better than hlist.
14:36:14 <cmccann> the automagic witness thingie that Vinyl uses is cute.
14:36:14 <Cale> Ndit: The problem is we don't know which type r is.
14:36:14 <ocharles> dolio: hlist uses the same machinery
14:36:37 <Cale> Ndit: r is presumably some variable, say introduced by a lambda, and we're trying to discover its type.
14:36:46 <acowley> Yeah, modern iterations of hlist lack a champion to spread the word
14:36:54 <acowley> I was surprised to see hlist using the newer pieces
14:36:57 <Ndit> Cale: template <class X, class Y> struct S { void f() { X x; Y y = x.foo(); } };
14:37:05 <Ndit> Why is this not a problem?
14:37:45 <bitonic> acowley: maybe yes.  but I wouldn’t use it in a serious project where I want to focus on other things—maybe at some point I’ll spend more time on it :)
14:37:45 <Cale> When you use that template, you will need to supply the types X and Y explicitly.
14:37:54 <hpc> i expect you would need something like template <class X, class Y> struct S { void f() { X<Y> x; ...
14:38:01 <Cale> They won't be inferred, at least, as far as I know.
14:38:01 <hpc> also that
14:38:33 <bitonic> ahah templates.  great fun
14:38:42 <cmccann> acowley: btw, I hacked a bit of support for sum types into Vinyl, it actually mostly worked
14:38:56 <acowley> cmccann: I saw that but didn't dig into it
14:39:04 <ocharles> cmccann: i saw that, are your sum types open?
14:39:04 <Ndit> Cale: template types can be inferred
14:39:06 <Cale> Ndit: Also, if you're willing to accept that, you would also not be unhappy writing type classes manually.
14:39:06 <acowley> cmccann: The very concept made me recoil a bit
14:39:09 <cmccann> acowley: but lack the motivation to make it properly usable because I really don't care that much about records tbh
14:39:11 <bitonic> template specialisation!  link time errors!  everybody loves templates
14:39:15 <ocharles> as in, does it let people add new cases later?
14:39:39 <Ndit> Cale: It's no problem to infer the T in multiple ways. calling functions will infer the T from the type passed to the function
14:39:39 <Cale> Ndit: You'll have to forgive me, the last time I wrote any C++ code was 1996 or something.
14:39:48 <Ndit> or you can do Foo<decltype(X)> etc
14:40:18 <cmccann> ocharles: the "sum type" is actually just a phantom type list. the case analysis is basically a product type.
14:40:18 * Shamar still astonished by his own misunderstanding of foldl
14:40:19 <bitonic> Ndit: C++ type inference is a joke, template are a joke, so much that they screwed them up and fixed them in C++11
14:40:22 <Ndit> Cale, the T can be inferred because the type info was never lost in the first place, it's static
14:40:29 <Cale> But yeah, if you can infer it, then the explicit template is vaguely analogous to using a type class.
14:40:33 <Ndit> theres no way it couldnt be inferred
14:40:45 <Cale> and you can already use type classes in Haskell for this purpose
14:40:47 <bitonic> Ndit: it’s just one hack on top of the other
14:40:51 <cmccann> ocharles: so it's basically the same as everything else in vinyl, just applied in reverse.
14:41:15 <ocharles> right
14:41:32 <Ndit> why can't type classes and records be merged into less syntax?
14:41:48 <Cale> Ndit: Why cant the C++ compiler infer that template for you?
14:41:50 <Cale> can't*
14:42:13 <Ndit> Cale what do you mean
14:42:19 <cmccann> acowley: recoil how? it's relatively straightforward how sum types "should" work in the same style as vinyl's existing product type stuff.
14:42:20 <bitonic> Ndit: is the problem syntax now?  you seem confused about what you want precisely, apart from ‘something that sort behaves like a C++ class’
14:42:29 <acowley> cmccann: It never occurred to me
14:42:41 <Cale> Ndit: I mean, your proposal here is vaguely that record field extractors are polymorphic in the record type they extract from.
14:43:02 <acowley> cmccann: It just surprised me because I never thought there'd be a use for it
14:43:15 <Cale> and while you can express that in C++ by manual construction of a template, you can express it in Haskell as well by manual construction of a type class.
14:43:55 <Ndit> in C++ it's not expressing that, the members aren't virtual, you cant even make virtual data members
14:44:41 <Ndit>  o.x relies and works on the type for o, only, non polymorphically
14:44:51 <Ndit> i'd have to write o.get_x(), a virtual function, for that
14:45:14 <Cale> Right, so when you write o.x in the code, and the compiler has no other information about the type of o, it has to *complain*.
14:45:15 <cmccann> acowley: really? the idea is pretty common in other guises. moreso in dynamic languages where everything is implicitly a union type and tags are checked at runtime, but it works statically the same way extensible product types can.
14:45:26 <thoughtpolice> i still need to try vinyl, but i too can't find myself caring about crappy records *that* much either tbh. at the same time, if we had something like row polymorphism i think i'd love it. someone, do all the hard work and implement this!
14:45:36 <acowley> cmccann: Yeah, it makes total sense.
14:45:40 <Ndit> Cale: it never has no information about o, except on the first pass of compilation
14:45:40 <bitonic> Ndit: C++ classes are nothing like Haskell types.  really.  square peg round hole etc.  and the fact that fields are statically resolved as you say is what got me confused when you wanted polymorphic fields
14:45:51 <bitonic> Ndit: since that’s very much *unlike* C++ fields
14:46:02 <Cale> Ndit: That's because you're constantly writing explicit type annotations everywhere, because you're syntactically forced to.
14:46:03 <Ndit> it instanciates the templates and then all information about o is known after the 2nd pass
14:46:05 <cmccann> thoughtpolice: vinyl actually seems nice enough to cross the threshold of usability for me, in that if I really wanted records like that for some specific purpose I might use it
14:46:10 <acowley> cmccann: I wasn't saying anything bad about it, just surprised that I hadn't thought of it! :P
14:46:17 <Ndit> Cale: but not there
14:46:19 <monochrom> thoughtpolice: I'm wondering whether it's hard work or hard decision
14:46:19 <Cale> Ndit: But in Haskell, we don't want to be forced to write out the type of every variable in the code.
14:46:21 <Ndit> Cale: class X
14:46:29 <Ndit> you dont need to
14:46:35 <acowley> thoughtpolice: I'm trying to provide a compelling demonstration
14:46:36 <Cale> Ndit: You would need a type declaration *somewhere* for o.
14:46:42 <Ndit> yes somewhere
14:46:43 <Ndit> but only once
14:46:46 <bitonic> Ndit: why don’t you tell us about a real problem you are having?  maybe you just need to update your practices ehe
14:46:49 <Cale> Presumably where the variable is introduced.
14:46:54 <Ndit> you could write 30 classes all accessing eachother and never relying on any explicit types, and only using the template parameters passed around
14:46:58 <thoughtpolice> cmccann: really? that's sort of the impression i got (very close to quite usable at a glance,) but i was afraid it would quickly devolve into crazy-land in practical use. i should give it a real shot.
14:47:08 <Ndit> originating from a single T parameter on a single thing
14:47:20 <Ndit> so that is not true Cale
14:47:26 <Cale> Ndit: But we don't like that in Haskell. We want, as far as possible, to be able to infer the type of the code from the code itself.
14:47:33 <cmccann> thoughtpolice: that was my impression from digging into how it works a bit and playing around with it for a while. I've not used it extensively.
14:47:50 <thoughtpolice> monochrom: hard work includes making all the decisions for me!
14:47:55 <thoughtpolice> :P
14:47:57 <Cale> Ndit: While there are some compromises which can and have been made, this kind of thing isn't taken lightly.
14:47:58 <cmccann> but at least for the simple cases that motivate it's use (and with the usual caveats that you might need extra type annotations now and then) it's not bad.
14:48:17 <monochrom> OK!
14:48:19 * thoughtpolice can deal with an extra type annotation here and there
14:48:26 <Ndit> Cale: that's just saying that syntactically you have invisible X's
14:48:39 <Ndit> which is a syntax issue, not an issue in static type resolution
14:49:01 <glguy> Ndit: Are you hoping that if you pursue this long enough that Cale will cave and tell you how to do it in Haskell?
14:49:09 <cmccann> thoughtpolice: I was just mentioning that I hacked some support for sum types on top of vinyl, but that's a little harder to make work nicely.
14:49:14 * bitonic is already irritated enough by having to annotate all polymorphically recursive local definition :P
14:49:16 <Cale> Ndit: The extent to which the compiler can't automatically infer the types of programs also implies a greater burden on programmers reading the code.
14:49:33 <thoughtpolice> acowley: i mean, i'm fairly certain i'd like them, because from ur/webbin' enough you get somewhat used to it. but at the same time, ur relies on records *a lot*, much less than we do, so it's a toss up
14:49:47 <thoughtpolice> i'd love to see a records solution in this area, i'm just not very annoyed by the status quo
14:49:48 <cmccann> at least with the approach I used, it's not possible to have a polymorphic "default" case without causing type ambiguity issues
14:49:51 <thoughtpolice> cmccann: link?
14:49:57 <acowley> thoughtpolice: I have two use-cases that I'm part way through developing
14:50:02 <Cale> Ndit: To go and search for the places where the types are annotated in order even to understand *which* operations are being applied.
14:50:23 <acowley> thoughtpolice: One is a mapping from storable vectors of vinyl records to GLSL shader parameters
14:50:29 <acowley> thoughtpolice: That seems to work very well
14:50:29 <cmccann> thoughtpolice: https://github.com/isomorphism/Vinyl
14:50:57 <acowley> thoughtpolice: Another is a way of defining parallel folds over an input, but which folds are run depends on the type of the output requested by the caller
14:51:39 <acowley> thoughtpolice: You can imagine a library that can compute a variety of statistics of some data set, and you just want a few fields. If you call the library code at the smaller record type you want, the library code runs faster.
14:51:42 <cmccann> thoughtpolice: there's an example at the bottom of the readme file
14:51:47 <Ndit> Cale: Maybe you should say that the type system is runtime and relies on a bunch of thunks instead of being static as in C++
14:51:51 <Cale> Ndit: and since type information can travel globally throughout a program, this can result in a situation where the person writing the code has an easy time not annotating things locally, but the person who eventually has to read it ends up being annoyed having to look everywhere for the one type annotation which starts pinning things down.
14:51:56 <Ndit> since I was trying to argue that you can resolve it statically
14:52:02 <Cale> The type system is static.
14:52:05 <thoughtpolice> acowley: you need to show me some notes on this! but at the moment i must go drink
14:52:17 <acowley> thoughtpolice: You coming to hacphi?
14:52:42 <Ndit> Cale: if it is static, there's no way you can prove there's an ambiguous context where a simple error that the type does not have this field, would not suffice
14:52:52 * hackagebot OddWord 1.0.0.2 - Provides a wrapper for deriving word types with fewer bits.  http://hackage.haskell.org/package/OddWord-1.0.0.2 (RobinKay)
14:53:01 <Ndit> because at runtime, the type is known and tagged
14:53:01 <thoughtpolice> acowley: very unlikely, my sister is tenatively moving that weekend since she got a new job
14:53:05 <Cale> Ndit: But that might be a lie!
14:53:10 <Shamar> Ndit, Cale's position is similar to that of Torvalds about C
14:53:11 <thoughtpolice> but i don't give up so easily of course :P
14:53:39 <acowley> thoughtpolice: Darn! I hope you can make it. I'm writing these experiments up in any case.
14:53:45 <shachaf> thoughtpolice: Coming to BayHac?
14:53:53 <thoughtpolice> OK, i should know definitively in the next few days actually
14:53:54 <Cale> In C it's actually easier, because you're again forced to give type annotations all over the fucking place.
14:53:59 <thoughtpolice> shachaf: definitely can't :P
14:54:06 <Ndit> Cale: look at Clay
14:54:07 <Shamar> he want to minimize the context needed to understand a line of code
14:54:08 <Cale> The type inference in C sucks
14:54:14 <Ndit> Clay is the 'successor' to C++
14:54:17 <Shamar> lool
14:54:18 <Ndit> or trying to be
14:54:19 <acowley> Someone please help me find the generalization I'm missing here, \f x -> (fromMaybe <$> x) <*> (f <$> x)
14:54:24 <cmccann> Cale: also in C you can't really write any interesting higher order stuff and there's no meaningful polymorphism
14:54:27 <Cale> and yet you see people who don't like this kind of overloading even there
14:54:29 <Ndit> you can do stuff like f(x) = x * 2;
14:54:39 <Ndit> so you should not make these arguments
14:54:48 <Ndit> because they're arguments about a syntax implementation
14:54:51 <Ndit> not the truth about static resolution
14:55:07 <elliott> is this still going on?
14:55:26 <acowley> elliott: IRC? Yes.
14:55:31 <Cale> The comment I made about C was about C, rather than about some other language.
14:55:38 * bitonic is a bit bored
14:55:45 <cmccann> elliott: apparently some people regard records as more than an excuse for type hackery! it is very strange.
14:55:49 <elliott> acowley: I mean this "discussion" that everybody is sick of.
14:55:54 <Cale> Ndit: basically, there are tradeoffs being made here
14:55:57 <Ndit> Cale: about the whole C++ argument from before, apply it to Clay rather
14:56:01 <Ndit> where you don't have to keep passnig the type
14:56:11 <Ndit> or annotating the type all over, as you say
14:56:14 <shachaf> Maybe you should take this to #haskell-overflow.
14:56:16 <Ndit> yet it's the same core language as C++
14:56:20 <Cale> Ndit: Personally, I think the tradeoffs which Haskell has decided on in this particular regard are good ones.
14:56:23 <acowley> shachaf +1
14:56:25 <elliott> #haskell-/dev/null
14:56:29 <cmccann> overloaded record names are not a big deal and not worth sacrificing better language features over and that's really all there is to say on the matter
14:56:32 <shachaf> It's taking up way too much #haskell time and seems to be irritating a bunch of people.
14:56:35 * bitonic should set up a little shrine to Cale’s patience
14:56:56 <cmccann> bitonic: Cale's patience is legendary.
14:57:00 <bitonic> yeah
14:57:38 <Ndit> Cale: How can you say that? There's no gain from lacking a language feature that would be an operator in a currently invalid syntax constructor and is never ambiguous in a static type system
14:57:42 <Cale> Ndit: You might not be so used to them, and might find them initially uncomfortable, but I would argue that if you try programming like this for a while, and just take bitonic's advice to annotate your field names with (a possibly abbreviated version of) the type name, you'll find it's really not so bad.
14:57:56 <Ndit> *syntax construct
14:57:58 <Cale> and that there really are some benefits to this approach too
14:58:08 <Ndit> it's not a mutex
14:58:17 <Ndit> if the type system is static and you use an unused syntax
14:58:30 <Ndit> Nothing was gained or lost
14:58:33 <Ndit> the featured only exists or not
14:58:35 <elliott> this has ceased to even be coherent
14:58:37 <Cale> Ndit: On the other hand, you might try implementing your idea.
14:58:42 <bitonic> Ndit: no offense, but I’m not sure you understand fully what Cale talks about inference manageable in Haskell—sure in C++ then can come and add ‘auto’ and hack up together some inference, but it’s a different matter.  you are talking under the very wrong assumption that C++’s inference and type manageability is good
14:58:43 <Shamar> bitonic, to me, it's interesting...
14:58:57 <monochrom> I vote for moving to #haskell-overflow
14:58:57 <Cale> Ndit: If you tried implementing this, you might understand what I mean better.
14:59:38 <glguy> OK, move accepted
14:59:53 <Shamar> any body used haskell with a legal domain here?
14:59:58 <bitonic> bah I don’t think it’s *disturbing* anybody.  it’s just boring.
15:00:07 <elliott> I think it is disturbing people
15:00:12 <bitonic> well, OK then.
15:00:37 <cmccann> I think enough people are annoyed that their annoyance is going to cause a disturbance sooner or later.
15:00:54 <bitonic> I’m not sure how you can be ‘disturbed’ by this kind of conversation but OK.  you can just avoid taking part
15:00:55 <quchen> Meta language discussions again?
15:01:07 <bitonic> I agree that it’s inconclusive ehe
15:01:15 <blackdog> Shamar: that's an interesting idea - would be fascinating to see if you could implement law as a DSL :)
15:01:27 <Cale> I think there are real points about language design to be made here
15:01:53 <Saizan> the big point is "adding features can take away guarantees"
15:01:54 <Cale> and it's certainly the case that Ndit's side of the tradeoff has been chosen more frequently than Haskell's here.
15:02:00 <Saizan> and we like our guarantees
15:02:00 <Shamar> mmm... that's almost a definition of my job (but in C#...)
15:02:01 <bitonic> Cale: yes, they have been made more than half an hour ago
15:02:08 <Ndit> it's not a tradeoff
15:02:12 <Ndit> I can prove that
15:02:17 <Shamar> and note: C#
15:02:23 <Cale> Ndit: If you want to prove it, actually implement it :)
15:02:26 <elliott> Ndit: come back with a proof.
15:02:41 <Cale> Ndit: I expect to see an implementation of Haskell with your changes in the future :)
15:02:41 <cmccann> Ndit: look, I don't think you understand what's actually involved in adding anything like this to Haskell.
15:02:43 <Shamar> because lawyers want to ignore exceptions they don't raise :-D
15:02:59 <simpson> Ndit: Could you please take this to #haskell-overflow if you want to continue?
15:03:35 <Cale> Ndit: yeah, please raise any additional points you might have here in #haskell-overflow
15:03:57 <Ndit> I wont continue but I will only say one more thing
15:04:07 <bitonic> ‘I won’t continue but I will’
15:04:14 <Ndit> you cannot prove that a type of quux in 'quux x' is not known at runtime, therefore you are wrong
15:04:20 <elliott> stop.
15:04:26 --- mode: glguy set +q ndit!*@*
15:04:31 <Cale> Ndit: *facepalm*
15:04:48 --- mode: glguy set -o glguy
15:05:24 <Shamar> can I ask a related question about internal DSL in haskell?
15:05:34 <bitonic> Shamar: of course
15:05:34 <monochrom> I guess that sentence is why you folks love intuitionistic logic :)
15:05:54 <acowley> hahaha
15:06:07 <cmccann> acowley: what were you saying earlier about a compelling demonstration of something about vinyl or records whatnot of some other kind?
15:06:30 <acowley> The intuitionistic poncho protects our fine garments
15:06:51 <Shamar> even with internal DSLs you would sacrify domain names? or type classes always are the solutions in that context?
15:07:23 <bitonic> Shamar: I don’t understand the question.  we still haven’t seen an example of this problem
15:07:31 <acowley> cmccann: I'm putting together some code that makes heavy use of vinyl. If the code comes out cool, I'll write up what it buys you.
15:07:48 <cmccann> acowley: ok.
15:08:02 <Shamar> ok
15:08:04 <monochrom> I like intuitionistic logic too, to the extent that in Natural Deduction it is nice pairs of intro rules and elim rules
15:08:19 <Shamar> I have a fund that can be buyed, subscribed or sell
15:08:35 <cmccann> acowley: good motivating examples of what you can do using something as baroque as vinyl and have it turn out nice makes a good rallying point for eventual extensions to obviate the hackery
15:08:38 <Shamar> I have a bond that can be buyed,subscribed or sell
15:08:46 <acowley> cmccann: That's my hope
15:08:48 <bitonic> monochrom: the fact that you can program in ITT is enough for me
15:08:56 <Shamar> I have an equity that can be buyed and sell
15:08:58 <thetallguy1> what sort of vinyl are you guys talking about?
15:09:15 <Shamar> ad a deposit that can be only increased or decreased
15:09:18 <cmccann> thetallguy1: vinyl is a library for extensible records (ha, ha)
15:09:29 <thetallguy1> cmccann: thanks
15:09:40 <cmccann> thetallguy1: cf. http://hackage.haskell.org/package/vinyl
15:10:03 <acowley> Dammit, I have been punched in the head by this robot twice today.
15:10:15 <bitonic> Shamar: you can have a simple typeclass hierarchy, or a GADTs with indices that tell you with actions you can take, or restricted operations without exporting constructors, or... it depends what you actually need to do.  these vague examples don’t go a long way
15:10:30 <dmwit> acowley: Don't pretend you didn't deserve it.
15:11:26 <Shamar> bitonic, what I mean is that I want to use "buy" "sell" "subscribe" "increase" and "decrease" as terms of my DSLs
15:11:33 <Shamar> and
15:11:51 <acowley> dmwit: It is standing right behind me, and its arm keeps drifting out to be right over where I'm sitting. I stand up and feel the blunt force trauma of the future.
15:11:52 <thetallguy1> cmccann: closer to home than I expected.  Ithought it was a c++ thing
15:12:05 <bitonic> Shamar: write down the monomorphic instances of the functions on a ‘Bond’, for example
15:12:14 <bitonic> or the ideal DSL for a Bond
15:12:16 <dmwit> ?remember acowley It [my robot] is standing right behind me, and its arm keeps drifting out to be right over where I'm sitting. I stand up and feel the blunt force trauma of the future.
15:12:16 <kappabot> Done.
15:12:17 <Shamar> that each of this functions requires different type of arguments according to the type of the first one (Fund, Bond atc)
15:12:21 <dmwit> oh, kappabot =(
15:12:46 <acowley> What did kappabot do with lambdabot?
15:12:52 <shachaf> dmwit: lambdabot is here too.
15:12:54 <shachaf> Just +q
15:13:03 <dmwit> Shamar: Have you read the "composing contracts" paper?
15:13:11 <dmwit> It seems like you might want to take some inspiration from it.
15:13:12 <dmwit> possibly
15:13:15 <Shamar> dmwit no...
15:13:18 <arkeet> acowley: why was epsilon afraid of zeta?
15:13:20 <Shamar> where?
15:13:34 <dmwit> https://research.microsoft.com/en-us/um/people/simonpj/Papers/financial-contracts/contracts-icfp.htm
15:14:08 <Shamar> one of the strangest things of Haskell, is Microsoft support... :-)
15:14:16 <acowley> arkeet: Because 7,8,9!
15:14:21 <Shamar> let's give a look...
15:14:56 <monochrom> arkeet: I want to know too!
15:15:17 <arkeet> because zeta eta theta. =(
15:15:19 <dmwit> What comes between fear and sex?
15:15:25 <arkeet> I blame shachaf for this one.
15:15:28 <dmwit> fünf!
15:15:34 <shachaf> arkeet: I wasn't even here!
15:15:41 <arkeet> irrelevant
15:15:53 <dmwit> I blame shachaf for everything.
15:15:59 <monochrom> hahaha thanks
15:16:03 <acowley> I, too, enjoy blaming shachaf for a wide variety of things
15:16:13 <shachaf> @quote blame.shachaf
15:16:14 <kappabot> No quotes match. Just try something else.
15:16:21 <shachaf> Well, lambdabot has the quote.
15:16:25 <thetallguy1> dmwit: have an upvote
15:16:35 <shachaf> A subtle hint from the universe that this belongs in -blah.
15:16:39 <dmwit> Moreover, because well-typed programs can never be blamed, I conclude that shachaf is not a well-typed program.
15:16:55 <simpson> Ah, a practical result.
15:17:31 --- mode: ChanServ set +o elliott
15:17:36 --- mode: elliott set +b *!*ident@*.socal.res.rr.com
15:17:36 --- kick: Ndit was kicked by elliott (Ndit)
15:17:39 --- mode: elliott set -q ndit!*@*
15:17:43 <elliott> uh.
15:17:46 <elliott> that ban seems a bit wide, irssi.
15:17:55 --- mode: elliott set -b *!*ident@*.socal.res.rr.com]
15:18:36 <Hafydd>  /set ban_type
15:18:45 <Cale> Wait, why wasn't the +q enough?
15:18:53 --- mode: elliott set -b *!*ident@*.socal.res.rr.com
15:19:00 <elliott> stupid interface
15:19:10 --- mode: elliott set +b *!*@cpe-108-185-218-246.socal.res.rr.com
15:19:14 --- mode: elliott set -o elliott
15:19:31 <Shamar> dmwit fine article... I'll give a better read tomorrow...
15:19:55 <Shamar> btw, I'm not sure that it talks about name clashes :-)
15:20:11 <Shamar> still... see you soon!
15:20:17 <resnik_> is there any way to do a bind but end up with a different monad? something along the lines of  :: m1 a -> (a -> m2 b) -> m2 b
15:20:24 <Shamar> and thanks for the foldl enlightenment... :-D
15:20:40 <shachaf> resnik_: That doesn't really make sense generally.
15:21:26 <arkeet> resnik_: such a thing ought to be basically the same thing as  m1 a -> m2 a
15:22:38 <Cale> resnik_: You might be interested in indexed monads.
15:22:47 <arkeet> I have no idea what he might be interested in.
15:22:50 <resnik_> so if you wanted to use bind on a Maybe a and end up with an IO a you'd be forced to compose fromJust in somehow?
15:23:12 <Cale> (>>>=) :: IxMonad m => m i j a -> (a -> m j k b) -> m i k b
15:23:36 <Cale> resnik_: You... wouldn't use bind there.
15:23:49 <resnik_> thanks will definitely look into that. im really just curious as to why monads force you to preserve context.
15:24:09 <shachaf> I suspect the intuition of "context" that people use is a bad one.
15:24:09 <Cale> resnik_: You'd use case to pull apart the Maybe a and decide which IO action to carry out in each case.
15:24:41 <Cale> resnik_: Monad is just a shape which occurs in many otherwise-unrelated APIs
15:25:06 <Cale> There's very little that different monads have in common in general, apart from what's directly specified there.
15:25:58 <Cale> resnik_: Maybe and IO are pretty much unrelated, even though they're both monads, and the extent to which they are related has very little to do with the monadic aspect of either one.
15:27:27 <dmwit> :t traverse
15:27:27 <kappabot>     Not in scope: `traverse'
15:27:27 <kappabot>     Perhaps you meant `reverse' (imported from Prelude)
15:27:35 <shachaf> sorrymwit
15:27:42 <Cale> resnik_: But there are cases where it makes sense to have some kind of "family of related monads" which are in some way tied together.
15:27:42 <shachaf> This bot is a bit of a stopgap.
15:27:46 <shachaf> I'm having trouble installing things.
15:27:48 <dmwit> :t Data.Traverseable.traverse
15:27:49 <kappabot> Couldn't find qualified module.
15:27:51 <cmccann> Cale: Maybe is for computations that can fail safely, while IO is for computations that can fail with unpleasant consequences!
15:27:52 <dmwit> okay okay
15:27:57 <shachaf> (I tried to install universe but there's an old version of cabal or something.)
15:28:04 <shachaf> @ty Data.Traversable.traverse
15:28:05 <kappabot> forall (t :: * -> *) (f :: * -> *) a b. (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
15:28:18 <dmwit> resnik_: Perhaps this function satisfies your need to turn Maybe into IO.
15:28:37 <lambdazerocool> Suppose I have a TCP connection between a client and a server, and I'd like them to *exchange* messages -- best practices, or way to go about this? I can get one-directional things in just fine with lazy IO, and I won't have load necessary for something like network-conduit
15:28:42 <dmwit> Specializing: traverse :: (a -> IO b) -> Maybe a -> IO (Maybe b)
15:29:19 <resnik_> well that was maybe a bad example, i was just picking two monads somewhat arbitrarily..
15:29:23 <monochrom> IO fails safely, too
15:29:29 <acowley> lambdazerocool: What problem are you having? Does the one-directional code not work when you want to exchange messages?
15:29:40 <dmwit> resnik_: traverse is pretty polymorphic.
15:29:59 <dmwit> resnik_: In any case you certainly have to know a little bit about the two monads you want to convert between if you want to have a chance of converting between them.
15:30:03 <dmwit> Which means a type class.
15:30:13 <resnik_> do all monads have an extraction function? like join but m a -> a instead of m (m a) -> m a
15:30:21 <dmwit> No, many don't.
15:30:23 <dmwit> e.g. IO
15:30:28 <dmwit> or State s
15:30:42 <resnik_> wow so you can never lose an IO wrapper once you have it?
15:30:45 <dmwit> correct
15:30:54 <resnik_> *head splodes*
15:30:55 <resnik_> thanks guys
15:31:03 --- mode: ChanServ set +o mauke
15:31:03 --- mode: mauke set +b $a:Ndit
15:31:05 <ocharles> the only thing you can really "do" with it, is call it from main
15:31:27 <lambdazerocool> acowley: The server side I've got with a handle for a socket, and it listens lazily. If I have a client listen lazily, will it go on to continue int he rest of my code where I need to send messages to the server?
15:32:14 <lambdazerocool> acowley: by listen lazily, i mean the handle is buffered with lines, I use hGetContents, and then I mapM_ with my handler functions
15:32:39 <monochrom> m a -> a is overrated
15:33:03 --- mode: mauke set -o mauke
15:33:15 <hpc> yeah, the real future is in (a -> w a)
15:33:24 <monochrom> actually, come to think of it, if you had m a -> a, I would ask why you don't use a directly
15:33:32 <acowley> lambdazerocool: Do you have some code like that that isn't working?
15:34:14 <cmccann> hpc: better yet compose those to get (m a -> w a). clearly that is the ultimate function.
15:35:00 <acowley> cmccann: You mean (m a -> w ɐ)
15:35:08 <cmccann> ahahaha yes good
15:35:11 <lambdazerocool> acowley: not at present - i'm just not sure i'm going about finding this via best practices. Should something like this work? { "messages <- hGetContents handle; mapM_ handler (lines messages); hPutStr handle "sending you a message!"}
15:36:14 <ocharles> resnik_: btw, (m a -> a) is extract for Comonad's
15:36:24 <resnik_> what typeclass would w a be?
15:36:33 <ocharles> Comonad
15:36:33 <acowley> lambdazerocool: The last hPutStr wouldn't happen
15:36:47 <ocharles> oh, you were talking about hpc
15:37:21 <lambdazerocool> acowley: that's what i suspected. so i'm wondering what avenues to take to have bidirectional TCP communication on a single connection
15:37:21 <cmccann> a "w" type constructor conventionally represents a comonad, because it looks like an upside-down m, geddit?
15:37:47 <shachaf> ш α -> α
15:38:02 <acowley> lambdazerocool: The problem is that your second line doesn't return, just move the third line ahead of it and things would improve.
15:38:07 <resnik_> lol, clever
15:38:28 <elliott> cmccann: except when it means a monoid.
15:39:09 <lambdazerocool> acowley: ultimately, i'm developing an interactive application where user input is fed to the server, and the client responds to messages from the server. a nice quick fix for this program, but it doesn't quite get to the heart of the problem
15:39:29 <acowley> This is a confusing error message (to me): "Could not deduce (Sing I Nat n)... "
15:40:52 <acowley> lambdazerocool: There are a lot of options with how to make it work without much fuss at all, but it would be much easier to have some code to frame the discussion.
15:41:21 <lambdazerocool> acowley: alrighty. well, thank you for the initial insight~ as for now, it looks like i've lost track of the time and am late for class.
15:41:29 <lambdazerocool> acowley: cheers =)
15:41:34 <acowley> lambdazerocool: np!
15:43:06 <acowley> So nobody had any comments about my little function, \f x -> (fromMaybe <$> x) <*> (f <$> x)?
15:44:13 <cmccann> acowley: you really want that to duplicate the "effects" of x?
15:44:43 <ocharles> :t \f x -> (fromMaybe <$> x) <*> (f <$> x)
15:44:44 <kappabot> forall (f :: * -> *) a. Applicative f => (a -> Maybe a) -> f a -> f a
15:45:05 <acowley> cmccann: In my case, x is just a data type
15:45:38 <cmccann> acowley: it's still doubling up the Applicative whatsit part.
15:45:45 <acowley> cmccann: Yeah
15:46:01 <acowley> cmccann: I don't want that
15:46:02 <cmccann> which is usually not what you'd want
15:46:07 <acowley> cmccann: But I don't know how to avoid it
15:46:31 <monochrom> Applicative doesn't let you avoid it
15:46:46 <acowley> I'm not married to Applicative for this
15:46:53 <acowley> it was just the shortest code
15:47:28 <acowley> I think the code will get optimized into something reasonable, but I haven't tested that yet.
15:47:52 <cmccann> acowley: why does fmap (\f x-> fromMaybe x (f x)) or something not work?
15:48:04 <acowley> It does
15:48:28 <cmccann> actually I think I messed that up but anyway
15:49:03 <acowley> :t \f -> fmap (\y -> frommaybe y (f y))
15:49:03 <kappabot>     Not in scope: `frommaybe'
15:49:04 <kappabot>     Perhaps you meant `fromMaybe' (imported from Data.Maybe)
15:49:09 <acowley> :t \f -> fmap (\y -> fromMaybe y (f y))
15:49:09 <kappabot> forall (f :: * -> *) b. Functor f => (b -> Maybe b) -> f b -> f b
15:49:17 <naz__> @help
15:49:18 <kappabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:49:22 <cmccann> acowley: anyway, that should be equivalent except for not duplicating the "effect"
15:49:33 <haasn> acowley is married to applicative?
15:49:38 <cmccann> hahaha
15:49:49 <naz__> @list
15:49:50 <kappabot> http://code.haskell.org/lambdabot/COMMANDS
15:50:14 <naz__> @source putstrln
15:50:15 <kappabot> putstrln not available
15:50:19 <naz__> @source putStrLn
15:50:20 <kappabot> putStrLn not available
15:50:21 <cmccann> clearly that should point to code.haskell.ord/kappabot/COMMANDS instead.
15:50:56 <haasn> putStrLn is an opaque function defined in base Haskell, right?
15:51:05 <mauke> @src putStrLn
15:51:05 <kappabot> putStrLn s =  do putStr s; putChar '\n'
15:51:22 <cmccann> http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/src/System-IO.html#putStrLn
15:51:48 <cmccann> the actual opaque primitive functions are several turtles deeper.
15:52:29 <naz__> ouh, I thought the commands weren't visible -.-
15:52:31 <haasn> I guess putStr = mapM_ putChar
15:52:38 <mauke> @src putStr
15:52:38 <kappabot> putStr s  = hPutStr stdout s
15:52:43 <shachaf> You can also /msg lambdabot or /msg kappabot
15:52:52 <cmccann> apparently it turns into matryoshka dolls instead of turtles somewhere along the way which is an important implementation detail I hear.
15:52:57 <naz__> That would have made more sense, ty ^^
15:53:01 <shachaf> For instance "/msg lambdabot ?" to get a list of all commands.
15:53:15 <cmccann> what about /msg shachaf does that work
15:53:19 <monochrom> cmccann: try /msg lambdabot @quote monochrom primop :)
15:53:40 <haasn> putStr s   =  mapM_ putChar s  -- from the haskell 2010 report
15:53:45 <cmccann> monochrom: yes that's what I was playing off of :]
15:53:50 <monochrom> \∩/
15:54:17 <cmccann> although I think "matryoshka dolls" sounds much more formal and technical and clearly makes the statement more profound.
15:54:21 <haasn> @quote monochrom primop :)
15:54:21 <kappabot> No quotes match. Wrong!  You cheating scum!
15:54:40 <cmccann> <lambdabot> monochrom says: primop is where the turtle tower ends and the russian dolls begin!
15:54:44 <`Jake`> @quote monochrom primop
15:54:44 <kappabot> No quotes match. My pet ferret can type better than you!
15:54:59 <cmccann> lambdabot is not talking to us, apparently.
15:55:05 <haasn> what happened to lambdabot anyhow?
15:55:13 <haasn> and who is this newfangled kappabot blasphemer?
15:55:20 <monochrom> we put it on +q because it malfunctions
15:55:23 <cmccann> Cale put lambdabot in time-out or something I guess.
15:55:29 <`Jake`> The machine lambdabot is running on is misbehaving, I've been told
15:55:32 <geekosaur> nobody knows yet, it's horked and kappa is standing in for it until it's fixed
15:55:41 <haasn> oh no
15:55:45 <haasn> did somebody find an exploit?
15:55:49 <cmccann> lambdabot has been obstinate and disobedient for a while lately.
15:55:54 <elliott> we exploited it to not work.
15:56:08 <hpc> i doubt it's an exploit
15:56:41 <`Jake`> [00:56] <`Jake`> > 1
15:56:43 <`Jake`> [00:56] <lambdabot>   mueval: ExitFailure 1
15:56:44 <`Jake`> [00:56] <lambdabot>  mueval: Prelude.undefined
15:56:56 <monochrom> yes, that is the malfunction
15:57:33 <haasn> as far as I'm aware that used to happen at random much earlier already, does kappabot actually solve those kinds of race conditions as well or is it just a vanilla copy of lambdabot in a non-broken environment?
15:57:41 <acowley> What is 1, anyway?
15:57:44 <monochrom> so we put it on +q and let kappabot instead compute 1 for you :)
15:57:58 <cmccann> acowley: the successor of 0
15:58:12 <acowley> Oh, I know: 1 is a nullary function, because this is Haskell!
15:58:17 <eikke> What is 0, anyway?
15:58:19 <monochrom> well, so far kappabot seems to work fine for >
15:58:25 <latro`a> it's also a constant function in lambdabot
15:58:28 <haasn> eikke: the predecessor of 1
15:58:39 <eikke> error: loop
15:58:44 <acowley> I think we found the loop in mueval
15:58:50 <monochrom> haha
15:58:55 <haasn> just add laziness
15:58:59 <naz__> Can anybody tell me how to concatenate a string and a newline? string ++ "\n" doesn't seem to work
15:59:10 <shachaf> What does it mean that it doesn't work?
15:59:13 <monochrom> > "hello kitty" ++ "\n"
15:59:14 <kappabot>   Ambiguous occurrence `++'
15:59:14 <kappabot>  It could refer to either `L.++', defined at L.hs...
15:59:17 <cmccann> haha
15:59:17 <shachaf> Hmm.
15:59:19 <haasn> oh god
15:59:24 <monochrom> @define
15:59:25 <monochrom> > "hello kitty" ++ "\n"
15:59:26 <kappabot>   Ambiguous occurrence `++'
15:59:26 <kappabot>  It could refer to either `L.++', defined at L.hs...
15:59:37 <monochrom> I am foiled
15:59:42 <elliott> @undefine
15:59:45 <elliott> > "q" ++ "r"
15:59:46 <kappabot>   Ambiguous occurrence `++'
15:59:46 <kappabot>  It could refer to either `L.++', defined at L.hs...
15:59:47 <shachaf> @undefine
15:59:48 <haasn> :t (L.++)
15:59:48 <kappabot> Not in scope: `L.++'
15:59:52 <shachaf> There.
15:59:55 <elliott> you've done even better than Cale, shachaf
16:00:02 <shachaf> elliott: ?
16:00:03 <haasn> > [] ++ []
16:00:03 <kappabot>   []
16:00:07 <elliott> shachaf: it's barely recognisable as Haskell!
16:00:08 <monochrom> > "hello kitty" ++ "\n"
16:00:09 <kappabot>   "hello kitty\n"
16:00:16 <cmccann> shachafskell
16:00:16 <monochrom> works for me
16:00:29 <cmccann> or maybe just shachaskell?
16:00:33 <cmccann> yes that works better
16:00:35 <cmccann> problem solved
16:00:43 <shachaf> It works better in that it doesn't hilight me.
16:00:45 * haasn likes to think the error message continues as “or `Control.Lens.++' ...”
16:00:58 <monochrom> I guess kappabot doesn't honour my @undefine
16:01:14 <shachaf> Not when you're not the one editing Pristine.hs
16:01:15 <eikke> > let (++) = (-) in 5 ++ 3
16:01:16 <kappabot>   2
16:01:32 <monochrom> haha haasn
16:01:35 <acowley> I'm sure Control.Lens.++'s type would be epic.
16:01:59 <`Jake`> let f (++) x = (++) + x in f 2 3
16:02:05 <`Jake`> > let f (++) x = (++) + x in f 2 3
16:02:06 <kappabot>   5
16:02:47 <eikke> I recently needed "((f a -> FocusingWith [Command] m (SomeState a) (f a)) -> s a -> FocusingWith [Command] m (SomeState a) (s a))" in some Lens-using code
16:02:47 <haasn> > let 2+2 = 5 in 2+2
16:02:48 <kappabot>   5
16:03:01 * hackagebot hyakko 0.6.5 - Literate-style Documentation Generator  http://hackage.haskell.org/package/hyakko-0.6.5 (JeremyHull)
16:03:44 <tikhonjelvis_> ah, is lambdabot now superseded?
16:04:18 <kappabot> no
16:04:32 <kappabot> yes!
16:04:38 <shachaf> > "λ⊥"
16:04:39 <kappabot>   "\955\8869"
16:05:02 <cmccann> I was worried there for a moment, when kappabot said "no" I thought it had turned into a Prolog bot instead.
16:05:03 <`Jake`> kappabot: Some internal struggles in your circuits?
16:05:28 <hpc> cmccann: my bot on another network had that as an april fools feature
16:05:29 <monochrom> you are right
16:05:42 <cmccann> hpc: haha nice
16:05:46 <monochrom> when kappabot said "no", it was acting as a Prolog bot
16:06:06 <monochrom> and then it said "yes!" because it retracted the closed-world assumption and tried again
16:06:41 <tikhonjelvis_> it can't be hard to embed a prolog interpreter into lambda bot
16:06:49 <kappabot> this is too complicated.
16:07:10 <tikhonjelvis_> or kappa bot, as the case may be
16:08:05 <tikhonjelvis_> hmm,I can't figure this irc client out :(
16:09:11 * cmccann wonders why kappa instead of mu
16:09:31 <shachaf> cmccann: Mu.
16:09:32 <shachaf> hth
16:09:37 <cmccann> >:[
16:09:38 <tikhonjelvis_> mubot does sound much better
16:09:49 <shachaf> Feel free to run mubot.
16:10:00 <shachaf> kappabot: @admin + cmccann
16:10:29 <cmccann> I don't think we really need multiple lambdabot clones.
16:10:36 <cmccann> maybe I could invent a different bot.
16:11:10 <tikhonjelvis_> it could do something less useful
16:11:13 <eikke> is there a reason for liftIO to exist (next to lift)?
16:11:30 <tikhonjelvis_> eikke: yes
16:11:51 <tikhonjelvis_> it's more convenient and makes your code more polymorphic
16:12:22 <tikhonjelvis_> with a larger monad stack, you would sometimes need more than one lift
16:12:41 <eikke> yes, but why special-case IO then?
16:12:44 <cmccann> we should have a liftIdentity too, for all those monads that use it as the bottom of the stack. that sounds extremely useful and not at all redundant.
16:12:45 <tikhonjelvis_> but liftIO can lift IO actions through any number of levels
16:13:09 <tikhonjelvis_> there are also classes like MonadState
16:13:29 <acowley> Because under every rock lies another rock, or the IO monad.
16:13:36 <hpc> eikke: MonadIO is differently-kinded
16:13:39 <eikke> yes, but those don't have a 'lift' operation :) or dont call it like that at least
16:14:04 <tikhonjelvis_> that's because state has a very small number of primitive actions
16:14:18 <hpc> and instances of MonadState auto-lift those operations
16:14:26 <tikhonjelvis_> whereas all the basic IO APIs are magic
16:14:31 <eikke> right
16:14:42 <hpc> you can do all your stateful work in the top-level monad
16:17:01 <tikhonjelvis_> it would be really cool if all the primitive IO actions were polymorphic
16:17:13 <hpc> it would... be kind of hell
16:17:21 <eikke> hpc: why's that?
16:17:28 <hpc> monomorphism restriction
16:17:33 <tikhonjelvis_> eh, I never read error messages anyway
16:17:36 <tikhonjelvis_> oh
16:17:46 <tikhonjelvis_> that too, I guess
16:17:47 <hpc> yeah, you'll be reading those :P
16:18:01 * hackagebot exception-mailer 0.2 - Catch all runtime exceptions and send an email  http://hackage.haskell.org/package/exception-mailer-0.2 (DavidPowell)
16:18:10 <cmccann> meh, just turn the DMR off.
16:18:12 <cmccann> who needs it.
16:18:12 <tikhonjelvis_> but basically, I want to completely mock out my operating system
16:18:28 <tikhonjelvis_> that's not too much to ask
16:18:43 <eikke> tikhonjelvis_: you'd put the operations in some typeclass?
16:18:57 <tikhonjelvis_> something like that
16:19:17 <tikhonjelvis_> maybe if Haskell also had first-class modules...
16:19:22 <eikke> oh. I thought you were referring to lifted-base stuff
16:19:27 <tikhonjelvis_> well
16:19:31 <tikhonjelvis_> that too
16:19:51 <tikhonjelvis_> with typeclasses you could accomplish both
16:20:10 <tikhonjelvis_> that is, lifting and mocking
16:20:19 <tikhonjelvis_> or even both at the same time
16:21:09 <DrChaos> Wow, this is a dead _simple_ IRC client
16:22:55 <tikhonjelvis_> for some reason, my IRC client is swallowing my /nick command :/
16:23:14 <silver_> try /raw
16:23:37 <tikhonjelvis_> hmm
16:23:44 <Hafydd> Are you sure your desired nick isn't already taken?
16:23:47 <Hafydd> Check your server messages.
16:23:48 <tikhonjelvis_> didn't seem to work either
16:24:04 <tikhonjelvis_> well, it is
16:24:10 <Hafydd> There you go, then.
16:24:13 <silver_> huh
16:24:13 <tikhonjelvis_> but I thought I identified for it
16:24:19 <silver_> ghost it
16:24:35 <silver_> /ns help release
16:24:38 <tikhonjelvis_> hmm
16:24:42 <tikhonjelvis_> one sec
16:24:59 <hpc> my ident alias is "ghost, release, recover, nick, identify"
16:25:36 <hpc> not all networks do all commands, but that whole series will unlock you on 99% of networks
16:25:42 <tikhonjelvis_> hmm
16:25:56 <silver_> you did ghost?
16:25:59 <silver_> or release?
16:26:11 <tikhonjelvis_> yeah, I think the client I'm using is trying to be too clever
16:26:11 <silver_> release should rename the dude who's using your nick
16:26:19 <silver_> oh
16:26:52 <hpc> iirc, release is rename and recover is un-ident
16:27:10 <hpc> some networks need both in that order
16:27:18 <tikhonjelvis_> the problem is that I'm that guy
16:27:35 <silver> which nick you wish to use?
16:27:46 <tikhonjelvis_> and my client seems to not be forwarding lines starting with /at all
16:28:43 <tikhonjelvis_> it's just some random android app
16:28:44 <silver> oh, maybe there's special syntax for that
16:29:08 <Michael_> Is there a way, using the typeable extension, to check if one constructor is the same constructor as another, without converting both to strings beforehand? For example, if I had a data Foo = Bar Int | Baz Double, as way to check if a varialbe is an instance of bar?
16:29:54 <tikhonjelvis_> toConstr gives you a representation of the constructor
16:30:03 <Cale> Michael_: You might want an instance of Data for that.
16:30:07 <tikhonjelvis_> you can compare that for equality
16:30:31 <tikhonjelvis_> oh yeah, it might be part of Data rather than Typeable
16:30:48 <tikhonjelvis_> I've never used one without the other
16:31:21 <Michael_> Cale: I'm sorry, what do you mean by an instance of data?
16:31:37 <tikhonjelvis_> there's a typeclass called Data
16:31:48 <cmccann> its fully-qualified name is better.
16:31:51 <tikhonjelvis_> under Data.Data
16:32:20 <Fuuzetsu> > "When will lambdabot be back? ;_;"
16:32:21 <kappabot>   "When will lambdabot be back? ;_;"
16:32:23 <Fuuzetsu> RIP
16:32:33 <Cale> Michael_: Typeable only exposes information about the types of things, rather than the value
16:32:53 <Michael_> so, would it just be: x = Bar 5; (toContr x) == Bar
16:32:56 <Michael_> ?
16:33:12 <tikhonjelvis_> not quite
16:33:17 <Cale> Michael_: If you want to generically decompose values of various datatypes, the class Data in the Data.Data module (no, really) gives you some ways.
16:33:38 <Cale> toConstr x will give you a value of type Constr which represents the constructor Bar, but not the constructor itself.
16:33:56 <hpc> http://images1.wikia.nocookie.net/__cb20120501005520/memoryalpha/en/images/d/d4/Data_and_Lore_%282364%29.jpg -- not enough Data
16:33:58 <Cale> (an operation which gave you the constructor itself would have to have a very strange type indeed)
16:34:37 <Botje_> I'm sure you can do that with the continuation monad somehow >:)
16:39:05 <tikhonjelvis_> maybe with existential types?
16:40:08 <tikhonjelvis_> toConstr :: b -> exists a. (a ->  b)
16:42:23 <tikhonjelvis_> that type wouldn't play well with curried constructors though
16:42:42 <monochrom> exists a. (a -> b) is not very useful
16:42:48 <tikhonjelvis_> meh
16:43:00 <tikhonjelvis_> usefulness is grossly overrated
16:43:49 <monochrom> then I can implement it for all types
16:44:54 <tikhonjelvis_> I don't think a better solution is possible because we don't know anything about a type's constructors just from the type itself
16:45:47 <tikhonjelvis_> we can fix that with typeclasses, of course
16:46:25 <monochrom> data E b = forall a. E (a -> b)    -- this is your exists a. (a -> b)
16:46:40 <tikhonjelvis_> right
16:46:41 <monochrom> toConstr b = E (\_ -> b)
16:58:06 <copumpkin> what do you call an invertible semigroup?
16:59:28 <tikhonjelvis_> does the notion of an inverse make sense in that case?
17:00:15 <copumpkin> good point :P
17:00:32 <cmccann> so the answer is "a group"? :P
17:00:38 <copumpkin> yup :P
17:00:42 <tikhonjelvis_> would it be some function such that for all x, f(f(x)) = x?
17:02:24 <Hafydd> That sounds a bit like a quasigroup.
17:02:47 <Hafydd> ...but not really, because it needs to be associative.
17:03:26 <tikhonjelvis_> honestly, coming up with a taxonomy of every possible algebraic structure just sounds tedious
17:03:56 <tikhonjelvis_> we should just have anonymous algebras for obscure things like that
17:04:12 <copumpkin> yeah, I agree
17:04:21 <copumpkin> I still want a row-typed dependently typed language
17:04:27 <copumpkin> so I can just request properties I need
17:04:48 <copumpkin> I could obviously just request the properties I need in the proofs that need them
17:04:50 <copumpkin> but meh, it's cuter my way
17:05:16 <Hafydd> Wow, I was convinced this was ##math for a few minutes.
17:05:43 <copumpkin> this place gets more obscure than ##math
17:05:57 <Hafydd> On average, I agree.
17:06:08 <tikhonjelvis_> well
17:06:17 <tikhonjelvis_> obscure in very specific ways
17:06:44 <copumpkin> the next frontier of haskell
17:06:48 <copumpkin> is to implement a cosmos
17:06:50 <tikhonjelvis_> to me, it's less obscure because I really don't know much about math
17:07:12 <tikhonjelvis_> unless it's actually CS in disguise
17:07:30 <cmccann> all the good parts of math are ;]
17:08:24 <tikhonjelvis_> and, come to think of it, I avoid CS unless it's math in disguise
17:08:38 <Hafydd> All mathematics is CS in disguise, which is really mathematics in disguise.
17:08:51 <Botje_> tikhonjelvis_: the rest would just be engineering, no ? :)
17:08:57 <tikhonjelvis_> some stuff is really a stretch
17:09:18 <tikhonjelvis_> yeah, I don't like the engineering stuff much, mostly
17:09:27 <tikhonjelvis_> like most of networking
17:09:53 <tikhonjelvis_> or virtually anything called "systems" that isn't about types
17:12:01 <tikhonjelvis_> e.g. the way the internet works is mostly arbitrary: sure it's based on some math, but most of the actual specifics are very far from it
17:12:58 <Hafydd> I don't think "the way that the Internet works" is considered "CS" by many people.
17:13:09 <Hafydd> The models used to come up with it might be.
17:14:12 <Fuuzetsu> There's a fair bit of CS involved. All that routing isn't done based on naive algorithms.
17:14:29 <Ghoul_> @pl (\f -> getByteString . f . fromIntegral)
17:14:29 <kappabot> (getByteString .) . (. fromIntegral)
17:15:01 <Ghoul_> Is there a function which does absolutely nothing which I could substitute as f above
17:15:09 <Ghoul_> and simply get getByteString . fromIntegral as output ?
17:15:25 <Botje_> id
17:15:30 <Ghoul_> thanks
17:15:51 <tikhonjelvis_> more generally, unsafeCoerce
17:16:04 <tikhonjelvis_> (don't actually do that)
17:16:08 <Hafydd> D:
17:16:18 <Ghoul_> Also, can this be done any simpler (ie, without so many dots) : (getByteString .) . (. fromIntegral)
17:16:31 <arkeet> looks fine.
17:16:51 <arkeet> you could also do  (. fromIntegral) . (getByteString .)
17:16:59 <Ghoul_> :|
17:17:17 <Botje_> Ghoul_: i wouldn't use the pointfree version.
17:17:21 <arkeet> you're trying to compose two functions onto your thing, so you'd definitely need at least two dots
17:17:43 <arkeet> you should feel fortunate that all you need is a third
17:17:44 <arkeet> :P
17:21:46 <Fuuzetsu> ((.) . (.)) for president
17:22:01 <Ghoul_> heh, boob application
17:24:47 <TravisD> Is computing the euclidian projection of a point x onto a convex polytope computationally challenging?
17:29:04 <TravisD> oops, meant to ask that in the #math channel - sorry
17:29:19 <dmwit> Ghoul_: You can use a lot fewer dots, yes.
17:29:28 <dmwit> ?unpl (getByteString .) . (. fromIntegral)
17:29:28 <kappabot> (\ e h -> getByteString (e (fromIntegral h)))
17:29:43 <cmccann> eh
17:30:16 <dmwit> ?unpl join . flip id
17:30:16 <kappabot> (\ g -> (\ c -> c g) >>= \ h -> h)
17:30:25 <dmwit> ?pl \e h -> h e h
17:30:25 <kappabot> join . flip id
17:30:29 <TravisD> (though, if anyone knows the answer I would appreciate it just as much in this channel)
17:30:34 <dmwit> joke ruined =P
17:39:04 <Ghoul_> sigh
17:39:10 <Ghoul_> I updated cabal and got dependancy hell
17:40:34 <monochrom> next time, use a sandbox to update cabal, then copy out just the exe, and throw away the sandbox
17:40:42 <Ghoul_> lolo
17:40:45 <Ghoul_> http://puu.sh/2TFtF/e59b7c4c76.png
17:41:15 <cmccann> I think we need to bring back the cabal upgrade command, to make everything else seem better in comparison.
17:41:36 <Ghoul_> cabal file http://hpaste.org/87983
17:41:38 <Ghoul_> :(
17:42:09 <Ghoul_> should I just reinstall cabal
17:42:13 <Ghoul_> err, haskell platform
17:42:17 <Ghoul_> or is this a fixable issue
17:42:54 <dmwit> Well, it did warn you.
17:43:10 <dmwit> Why not tell it which version of bytestring you want to use and let it work out how to make that happen.
17:43:13 <Ghoul_> strangely it worked for like 2 hours
17:43:26 <Ghoul_> uh, okay, so specify the version exactly
17:43:28 <Ghoul_> I'll try that
17:43:44 <dmwit> as in cabal configure --constraint bytestring==0.10.0.2
17:43:54 <dmwit> This will tell you that you need to reinstall some things.
17:44:12 <dmwit> But perhaps you will like cabal install --constraint bytestring==0.10.0.2 --only-dependencies
17:44:49 <monochrom> Burrito? :)
17:46:01 <Adeon> the future of haskell is burritos
17:46:16 <Ghoul_> bleh, I'm able to take the errors down to 4
17:46:24 <Ghoul_> several packages wanting different versions of directory
17:48:27 <dmwit> Is it possible that you have accidentally installed a local version of one or more of the packages that come with GHC?
17:48:31 <dmwit> Don't Do That =P
17:49:20 <monochrom> every reinstall adds to the problem, not reduce the problem. here reinstall means reinstall without cleaning first.
17:50:48 <dmwit> A reinstall that changes the reinstalled package's dependencies to be more in line with the dependencies of other installed packages could reduce the problem.
17:51:00 <Ghoul_> bleh, solved the problem kinda
17:51:35 <Ghoul_> Just explicitly versioned bytestring (for now) and ignored the other warnings
18:07:41 <Ghoul_> I assume that =<< and >>= give the same performance
18:08:00 <cmccann> @src (=<<)
18:08:00 <kappabot> f =<< x = x >>= f
18:08:08 <Ghoul_> Ah, lol.
18:08:22 <Ghoul_> thanks :)
19:12:11 <Michael_> If I want to build a subset of a programming language for use in genetic expression programming, where you mutate programs to try to reach a certain goal, would it be beter to define a micro language, or use template haskell?
19:19:08 <Botje_> representing your program tree as haskell datatypes sounds like a good plan, yes
19:21:27 <Maxdamantus> as types?
19:25:19 <Maxdamantus> eval (undefined :: Mul (Plus One One) X) 4
19:25:24 <otters> @pl \x -> x
19:25:24 <kappabot> id
19:25:50 <otters> @pl \f -> doesFileExist f >>= \g -> if g then foo else bar f
19:25:50 <kappabot> liftM2 (>>=) doesFileExist (flip (flip if' foo) . bar)
19:27:55 <elliott> Maxdamantus: as values
19:29:22 <otters> we need lambda if
19:29:31 <otters> or something
19:29:55 <Maxdamantus> @pl \x -> if' x then not x else x
19:29:55 <kappabot> (line 1, column 13):
19:29:56 <kappabot> unexpected reserved word "then" or 't'
19:29:56 <kappabot> expecting variable, "(", operator or end of input
19:30:03 <Maxdamantus> er
19:30:05 <otters> :t if'
19:30:06 <kappabot> Not in scope: if'
19:30:10 <otters> not in scope
19:30:11 <otters> nice
19:30:14 <Maxdamantus> @pl \x -> if' x (not x) x
19:30:14 <kappabot> join (ap if' not)
19:32:20 <Maxdamantus> > let if' a _ b _ c = if a then b else c; (then', else') = undefined in if' ("P" == "NP") then' "P equals NP" else' "P does not equal NP"
19:32:21 <kappabot>   "P does not equal NP"
19:36:37 <mm_freak> otters: we got lambda case
19:36:49 <mm_freak> but you need GHC 7.6 for that
19:37:07 <mm_freak> \case of …
19:37:36 <otters> yeah
19:37:40 <otters> but lambda if would be nice
19:37:42 <otters> or ternary
19:38:23 * hackagebot yesod-auth-kerberos 1.2.0 - Kerberos Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-kerberos-1.2.0 (ArashRouhani)
19:50:11 <jfischoff> is there a way to ignore all files with names *Test.hs with hlint?
20:20:23 <tgeeky> jfischoff: nope
20:20:42 <tgeeky> jfischoff: your best bet would be to move them to something other than .hs or .lhs
20:21:10 <jfischoff> not an option. I wrote a find regex to get them
20:21:20 <jfischoff> now I am getting the same warning twice
20:21:33 <tgeeky> jfischoff: yep, the other option is just to not let hlint do the recursive search and do it yourself
20:21:58 <jfischoff> this rule is being applied twice: error = fromJust x ==> Data.Maybe.fromMaybe (error "A more informative error message") x
20:23:30 <blaenk> there's a flag for cabal apparently caleld --builddir which lets you change where it puts generated build files (default: dist/), can I modify this from within the .cabal file?
20:37:08 <mm_freak> > fix$(0:).scanl(+)1
20:37:09 <kappabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:47:06 <dwcook> mm_freak, funny how much Haskell begins to resemble Perl if you take out the whitespace.
20:47:52 <dwcook> I guess what I'm trying to say is it seems more noisy. :P
20:52:18 <LLckfan> Can some1 tell me why in Google Chrome it sometimes wll not go to the address I ype in but if I lick a link somewhere it goes to that address with an issue
20:52:30 <mm_freak> dwcook: i don't think reintroducing the whitespace really helps here =)
20:52:44 <cmccann> ...why on earth does the Num instance for Complex require RealFrac?
20:52:56 <cmccann> oh, abs and signum I bet
20:52:59 <cmccann> dammit
20:55:55 <lispy> What is RealFrac trying to capture?
20:56:08 <cmccann> er, RealFloat, I meant
20:56:40 <lispy> well, my question is the same
20:56:52 <lispy> The RealFoo type classes seem like a half-baked idea to me
20:56:58 <mm_freak> > abs (2 :+ 2)
20:56:59 <copumpkin> the whole hierarchy is
20:56:59 <kappabot>   2.8284271247461903 :+ 0.0
20:57:12 <cmccann> oh, I thought you were asking about why Complex needs it
20:57:22 <mm_freak> > signum (2 :+ 2) * abs (2 :+ 2)
20:57:23 <kappabot>   2.0 :+ 2.0
20:57:23 <lispy> copumpkin: yeah, I guess some parts seem worse to me than the others
20:57:24 <cmccann> what it needs is the trig functions
20:57:40 <Cale> Well, Real is kind of misnamed
20:57:55 <mm_freak> cmccann: does it?  it probably needs sqrt instead
20:58:05 <mm_freak> > sqrt 8
20:58:06 <kappabot>   2.8284271247461903
20:58:18 <cmccann> or that, yeah
20:58:31 <lispy> the best type classes are ones where we can state a contract for the instances.
20:58:32 <Cale> The hierarchy is better thought out than it looks, but yeah, it needs some serious tweaking
20:58:48 <lispy> I have no idea what those would be for most of the numeric type classes
20:59:17 <mm_freak> fromInteger x + fromInteger y = fromInteger (x + y)
20:59:21 <cmccann> lispy: well Real describes a subset of the rational numbers
20:59:35 <cmccann> which is still hilarious in a really sad way
21:05:05 <lispy> > sqrt 8 - exp 1
21:05:05 <kappabot>   0.1101452962871452
21:05:34 <lispy> Cale: any idea what we should do about lambdabot?
21:05:55 <Cale> lispy: I have no idea what's wrong. mueval just randomly fails now
21:06:15 <Cale> It happens not just in the bot, but also when I run it on the commandline
21:07:03 <elliott> maybe something got upgraded?
21:11:51 <kludgy> Hi all, what's the word on a good defacto lens library for beginners?
21:12:15 <simpson> kludgy: The lens package is what you want.
21:12:16 <edwardk> lens. you can use it without knowing how all the internals work
21:12:23 <kludgy> Thank you kindly!
21:12:30 <edwardk> > (1,"hello")^._2
21:12:30 <kappabot>   Not in scope: `_2'Not in scope: `^.'
21:12:44 <edwardk> did lambdabot lose lens?
21:12:45 <cmccann> pretty sure lens is not any more confusing for beginners than it is for experts.
21:12:51 <cmccann> edwardk: that's not lambdabot
21:13:04 <edwardk> what happened to lambdabot?
21:13:20 <cmccann> Cale and lispy broke lambdabot or something
21:13:25 <edwardk> ah
21:14:02 <Cale> It... sorta still works
21:14:17 <Cale> It's still running, just quieted, since earlier all the muevals were randomly dying
21:14:27 <tgeeky> memtest86?
21:14:40 <edwardk> nobody has figured out how to make the muevals run longer before giving up?
21:14:48 <Cale> It's running on a linode host
21:14:59 <Cale> edwardk: They weren't making it to their timeout time
21:15:09 <Cale> Something was killing them about a second in
21:15:16 <edwardk> blech
21:15:30 * lispy wonders if gettimeofday works reliably on a linode
21:25:38 <robonerd> anyone in here do reactive programming GUIs?
21:25:47 <robonerd> would be fun to share a convo
21:34:31 <onr> lispy: why wouldn't?
21:37:36 <hrookie> I'm writing a game in haskell which has shared state on a server. Players communicate via a client and update the state. The server broadcasts such changes. All this communication happens in the IO monad. What would be the best way to maintain state? I feel like the easiest way is MVar, even though I'm going to be doing updates and stuff, because STM and IO are not fans of one another. Thoughts? Opinions?
21:38:24 <simpson> hrookie: You're writing the server in Haskell too?
21:38:37 <tgeeky> STM and IO are not fans of each other? Do apples envy grapes?
21:38:48 <hrookie> simpson: seems simple enough xD
21:39:25 <hrookie> tgeeky: it's my (potentially mis-) understanding that when you're in the IO monad, calling on STM is bad juju
21:40:37 <hrookie> my current thought is that each player has a socket open, one thread per player on the server, and when updates come in to the server, the state is updated, then each socket gets a message out broadcasting the update. STM comes in with processing the update - is it bad practice to have an IO (STM a)?
21:40:58 <simpson> :t atomically -- hrookie
21:40:59 <kappabot>     Not in scope: `atomically'
21:40:59 <kappabot>     Perhaps you meant `IOSpec.atomically' (imported from Test.IOSpec)
21:41:04 <simpson> Grar.
21:41:12 <robonerd> lol, hrookie i just said a few min ago on #iosdev : " <robonerd>	 i can either do that, or i can go the route of making the c lib a network server and do communication over socket connections within the objc framework"
21:41:16 <robonerd> i'm doing the same kinda thing
21:41:25 <robonerd> i want some C code to call out to code which is using it as a library
21:41:36 <simpson> atomically :: STM a -> IO a -- lets you execute an STM transaction as an IO action.
21:41:47 <robonerd> seems i can do function callbacks with a context ptr, or turn the lib into a server which communicates through sockets
21:42:50 <simpson> hrookie: TBH I would seriously consider structuring this using conduits or pipes so that you get some semblance of a Real Networking Library.
21:43:24 <robonerd> in what ways?
21:45:28 <robonerd> hrookie ?
21:45:38 <hrookie> sorry, afk'd a second
21:46:18 <hrookie> simpson: a friend of mine recommended i examine conduit, although for the level of complexity of the project, i'm not sure it's totally necessary. that, and, network-conduit was having issues on my machine
21:46:33 <LLckfan> Hello
21:46:33 <LLckfan> Can some1 tell me why in Google Chrome it sometimes will not go to the address I type in but if I click a link somewhere it goes to that address with an issue
21:46:39 <hrookie> robonerd: i'm not entirely sure i follow your line of logic
21:46:46 <robonerd> what part
21:47:36 <simpson> hrookie: "A friend recommended that I use a fork, but for the depth of spaghetti on my plate, I'm not sure it's necessary. That, and forks are a little hard to hold." :3
21:47:50 <hrookie> robonerd: what do you mean "a c library to call out to code which is using it as a library"
21:47:59 <simpson> hrookie: Real Networking Libraries enable serious development. Haskell still doesn't *have* such a library, but conduit's about half of what you need.
21:48:47 <robonerd> hrookie well i have a c library which manages state. image a tiny db server. now, i want a way so that code which uses this library can in some way 'register' to receive notification of changes to certain state within the library
21:49:17 <robonerd> so when that data is updated, notices are posted to the subscribed observers
21:49:27 <robonerd> then they can, eg, update their state
21:53:32 <hrookie> robonerd: i see
21:54:05 <lispy> onr: I don't have any reason to suspect that it doesn't, but when faced with a weird debugging problem it's good to start with the basics and make sure they still work :)
21:54:20 <hrookie> simpson: if by "a fork is too hard to hold" you mean "ServerSettings which is clearly exported in the Conduit.Network model isn't found by my linker" then yes :D. What serious advantages would conduit provide in a really lightweight application with only a few players?
21:54:28 <hrookie> module*
21:55:08 <onr> lispy: there's Digital Ocean if things go wrong :)
21:55:38 <simpson> hrookie: You are falling prey to the common misbelief that networking is somehow easy or simple.
21:55:43 <simpson> hrookie: And you are wrong. :c
21:56:36 <lispy> onr: cool
21:57:06 <hrookie> simpson: i don't think networking as a whole is super simple - i think this task is =D
21:58:21 <hrookie> robonerd: why the choice of C for your application? performance?
21:59:24 * tgeeky guess he's a student and wants to actually hit all of the potholes
21:59:28 <simpson> hrookie: Best of luck.
22:02:34 <simpson> Hey, is there a Unique monoid or something like that? I want to take a list of a custom enum and determine whether there are any duplicates in it.
22:03:05 <hrookie> simpson: but you did not quite answer what i was asking above - i am open to the idea of conduit, but you have only said "it's closer to a real library" - what does conduit offer that i'm after?
22:04:21 <simpson> hrookie: Control over otherwise-independent streams of data.
22:04:56 <robonerd> anyone here do function reactive GUI coding before?
22:05:19 <johnw> simpson: what would your Unique monoid do?
22:05:42 <johnw> i'm wondering how it's different from just sorting a list and looks for two matching elements in sequence
22:06:02 <simpson> johnw: I guess that that would work.
22:06:09 <robonerd> johnw that's a goo didea
22:06:14 <robonerd> the sort then 2 in a row
22:06:23 <robonerd> hrookie hey
22:06:26 <simpson> johnw: I'm just derping, I guess.
22:06:37 <hrookie> why not insert into an O(1) data structure and fold across to shave off dat log(N) factor?
22:06:56 <hrookie> robonerd: yo
22:08:34 <robonerd> hrookie hey i messaged you
22:09:12 <boothead> Hi all. Is there a way to go from IO (Maybe a) to MaybeT (IO a) or even better something that lets me say what went wrong like EitherT or ErrorT?
22:09:32 <shachaf> You mean MaybeT IO a?
22:09:55 <boothead> Is this even a valid question? Or should I just stick with the maybe inside IO
22:10:19 <shachaf> IO does have exceptions, which may or may not be appropriate for what you want.
22:10:39 <shachaf> But possibly you should spend a bit more time understand monad transformers before using them.
22:10:47 <shachaf> In this case the answer to your question is
22:10:53 <shachaf> @ty Control.Monad.Trans.Maybe.MaybeT
22:10:54 <kappabot> forall (m :: * -> *) a. m (Maybe a) -> Control.Monad.Trans.Maybe.MaybeT m a
22:11:32 <boothead> shachaf: yes, sorry I have a web api which does a lot of IO (Maybe a) and I wondered if there's a better API I could transform it to easily
22:12:12 <shachaf> Well, the function I just mentiond.
22:12:14 <shachaf> @src MaybeT
22:12:14 <kappabot> Source not found. It can only be attributed to human error.
22:12:29 <shachaf> newtype MaybeT m a = MaybeT {runMaybeT :: m (Maybe a)}
22:12:50 <boothead> shachaf: is that saying that IO (Maybe a) and MaybeT IO a are equivalent?
22:13:00 <boothead> ohhh I see
22:14:29 <boothead> and how about going from a maybe to something that can propogate an error message?
22:15:13 <hrookie> boothead: have you checked out (Error e) => Either e ?
22:15:29 <johnw> :t note
22:15:30 <kappabot>     Not in scope: `note'
22:15:30 <kappabot>     Perhaps you meant `not' (imported from Data.Bool)
22:15:39 <boothead> I have something like getToken >>= doSomething and I'd like to know at the end which went wrong (both have the IO (Maybe a) pattern at the moment
22:15:40 <johnw> boothead: http://localhost:8687/file//Users/johnw/.cabal/share/doc/errors-1.4.1/html/Control-Error-Util.html#v:note
22:15:44 <johnw> ack
22:15:49 <boothead> hrookie: is that in the errors package?
22:15:49 <johnw> anyway, the 'note' function from errors
22:15:58 <johnw> note :: a -> Maybe b -> Either a b
22:16:24 <boothead> johnw: sweet thanks
22:17:15 <hrookie> boothead: an alternative is to go from Maybe to Either altogether - Either a b has Left a (used to represent errors or failure, where a can carry information), or Right b (a successful result)
22:17:29 <boothead> shachaf: thanks for your help too
22:17:45 <shachaf> "errors" is probably the wrong path toward whatever its goal is.
22:17:46 <hrookie> boothead: Either is in prelude, no fancy imports necessary
22:18:01 <shachaf> Then again I don't really want to argue it either way so I should just not say anything.
22:19:20 <boothead> hrookie: yes, I was wondering how to do that. Is it something like maybe (const . Left "msg") Right result?
22:21:00 <RoboTeddy> just reading about making your own types/typeclasses in Learn You a Haskell -- is it at all correct to think of a hierarchy that looks like [typeclasses] -> [typesubclasses] -> [type constructors] -> [types] -> [values] ?
22:21:12 <shachaf> Not really.
22:21:20 <hrookie> boothead: hmm, what do you mean? there is an EitherT transformer so you can have an EitherT e (IO a)
22:21:31 <RoboTeddy> shachaf: ok, thanks
22:21:39 <hrookie> boothead: in this case, the result is IO (Either e a)
22:22:36 <RoboTeddy> shachaf: but a value has_a type has_a type_constructor has_a typeclass, correct?
22:23:24 <Rotaerk> RoboTeddy, no
22:23:36 <RoboTeddy> Rotaerk: ok, thanks. /me rereads tutorial
22:23:37 <boothead> hrookie: If It take a step back. What I want is a way to string IO calls to a webservice (each of which might need information from earleit ones) together in such a way as I can keep track of which part the error came from.
22:23:45 <boothead> sorry for the essay :-)
22:24:01 <shachaf> RoboTeddy: Not really.
22:24:21 <shachaf> RoboTeddy: A value has a type. I don't know what you mean by "a type has a type constructor".
22:24:35 <shachaf> A type can be an instance of zero or more type classes.
22:24:37 <boothead> If I go with IO (Either a b) that means that I continually have to case on the Either doesn't it?
22:24:56 <shachaf> It doesn't "have" one.
22:25:03 <RoboTeddy> I guess, types can come from type constructors, right? e.g. Maybe
22:25:05 <hrookie> boothead: yes - but this is no different from continually having to use Just with the Maybe monad.
22:25:20 <RoboTeddy> (but I suppose they don't have to)
22:25:30 <shachaf> The relationship might be a bit closer to what you're after with kinds -- a type has a kind -- but you probably don't need to worry about that.
22:25:42 <hrookie> boothead: oh wait, do you mean "case x of Left err -> " "right result ->" ?
22:25:52 <RoboTeddy> ok, well, thanks guys. it's very helpful to know what I don't understand yet as I learn, so I appreciate it!
22:25:56 <shachaf> Is Int a type constructor? Is Either Char a type constructor? Is Maybe Int a type constructor?
22:26:30 <RoboTeddy> according to http://learnyouahaskell.com/making-our-own-types-and-typeclasses , Int is a type; Either Char is a type; Either is a type constructor (as far as I understand)
22:26:59 <boothead> hrookie: right. Is there nothing i can use off the shelf that will let me thread this type transparently through my IO calls?
22:27:06 <zRecursive> RoboTeddy: right
22:27:44 <boothead> getToken >>= fetchResource should give me "token failed" "resource failed" or the resource
22:27:47 <shachaf> LYAH is a bit fast-and-loose with its terminology, if I remember correctly.
22:27:58 <shachaf> Also you shouldn't worry about terminology too much.
22:28:14 <hrookie> boothead: see, what's nifty is the way (>>=) is implemented for the Either monad. Left error >>= f = Left error, while Right result >>= f = f result. The bind operator (>>=) takes care of all that for you seemlessly =D
22:28:17 <shachaf> Different people mean different things by the word "type", for instance. As long as you're clear on what you mean it doesn't matter what words you use. :-)
22:28:25 <shachaf> Anyway, there are no values of type Either Char. There are values of type Either Char Int.
22:28:44 <shachaf> So if Either Char is a "type", then surely Either is also?
22:29:20 <zRecursive> Either is type constructor
22:29:36 <hrookie> boothead: the end result, if you're chaining things monadically with (>>), (>>=), or (<-), and an error occurs, the error is what gets passed up
22:29:48 <shachaf> I hate terminology discussions like this!
22:29:49 <shachaf> They're useless.
22:29:54 <shachaf> I'm not going to participate any more.
22:29:56 <shachaf> There.
22:30:08 <boothead> But I'm also in IO hrookie, how does it work then?
22:30:25 <zRecursive> noone cares
22:31:12 <tinyghost> hi! I'm trying to install the ncurses library via cabal on OS X 10.7.5, and it complains about how it can't find panelw and ncursesw, where do I find those?
22:31:20 <tinyghost> they're not in homebrew
22:31:40 <tinyghost> OS X comes with ncurses and panel, but I don't know if they're the same
22:33:23 <hrookie> boothead: you are doing IO on the outside to fetch your data, then you run a validation on the inside which results in Left or Right, and return the result
22:34:16 <hrookie> boothead: check out this: http://en.wikibooks.org/wiki/Haskell/Monad_transformers
22:34:38 <hrookie> boothead: specifically the part on binding
22:34:56 <hrookie> botohead: the example used is MaybeT, but the same principle applies - i'd love to stick around and help, but i need to go to sleep now :(
22:35:45 <boothead> hrookie: and I need to work now :-( thanks a lot
22:36:11 <hrookie> boothead: any time :D
22:36:13 <boothead> I was looking at transformers before I'll check out the section on binding
22:36:46 <hrookie> boothead: the (>>=) operator. if you're not comfortable with it, make sure you check out the Learn You A Haskell For Great Good chapters on monads - they have a wonderful explanation of (>>=) and (>>) and do notation
22:36:58 <hrookie> cheers~
22:45:26 <shachaf> Is a classical disjunction monad interesting for anything?
22:51:35 <johnw> shachaf: are you talking about something similar to LogicT?  I don't really know what the "classical disjunction monad" is
22:53:32 * hackagebot steeloverseer 0.2.0.0 - A file watcher.  http://hackage.haskell.org/package/steeloverseer-0.2.0.0 (SchellScivally)
22:54:31 <ahihi> tinyghost: ncursesw is just ncurses compiled with --enable-widec
22:54:52 <shachaf> I don't know. Maybe something like newtype Foo r e a = Foo ((a -> r) -> (b -> r) -> r)
22:55:07 <ahihi> you can find it in homebrew-dupes
23:03:20 <charco> Hi
23:07:18 <charco> Anyone there?
23:07:24 <simpson> charco: Sure.
23:07:30 <charco> Hello
23:07:35 <shachaf> There is only silence and some second-hand clothes.
23:07:54 <charco> I'm having trouble understanding why GHC doesn't optimize some code
23:08:04 <charco> I think it's pretty clear that it can be optimizable
23:08:28 <hpaste_> Marco pasted “GHC Optimization” at http://hpaste.org/87988
23:08:56 <shachaf> Next time ask your question first and then see if anyone is around. :-)
23:09:08 <shachaf> Anyway, GHC doesn't do common subexpression elimination almost anywhere.
23:09:25 <charco> Oh :(
23:09:28 <shachaf> It's not such an easy optimization.
23:09:39 <shachaf> Er, by which I mean it's not easy to tell whether it's an optimization or not.
23:10:09 <charco> shachaf, but isn't this the case that, because of transparential referency, that call would give you the same answer?
23:10:15 <shachaf> Yep.
23:10:20 <charco> so it could just "replace it"
23:10:24 <shachaf> It's a correct transformation.
23:10:30 <shachaf> It's just not always right. :-)
23:10:37 <charco> How so?
23:10:45 <charco> I mean, if you let alone IO, it's all pure and magic
23:11:04 <shachaf> It can make the program worse by taking up more space.
23:11:47 <charco> I mean, why not just replacing it with a where clause as in funO ?
23:12:03 <shachaf> Because sometimes it makes performance worse.
23:12:13 <shachaf> Sometimes it makes it better. Sometimes it makes it worse.
23:12:24 <shachaf> GHC doesn't like to guess like that.
23:12:55 <charco> Isn't there a way to tell him
23:13:04 <shachaf> Yes, the way you did it.
23:13:07 <charco> Hey GHC, come on, replace all the subexpresion (?)
23:13:10 <charco> oh :(
23:13:37 <charco> Ok
23:14:19 <charco> Do you know any example where it would be worse?
23:14:53 <shachaf> @google ghc cse
23:14:55 <kappabot> http://www.haskell.org/haskellwiki/GHC_optimisations
23:14:55 <kappabot> Title: GHC optimisations - HaskellWiki
23:14:59 <shachaf> I'm sure you can find examples online somewhere.
23:15:31 <charco> Ok, thanks! :D
23:20:13 <cmears> print (length [1..10^8]) >> print (length (0:[1..10^8]))
23:20:21 <cmears> doing CSE on the big list is not such a great idea
23:21:53 <tero-> from the wiki page, "GHC compiles to the spineless tagless G-machine (STG)." and "'Spineless' because it can't stand up to bullies."
23:22:00 <tero-> what are bullies in this case? :)
23:22:20 <shachaf> That soudns like vandalism.
23:23:40 <shachaf> Oh, it's what's-his-name. Not intentionl, then.
23:25:11 <hpaste_> “BLA  ETECH  PVT.  LTD.” pasted “Power line filter design in delhi” at http://hpaste.org/87989
23:26:55 * shachaf sighs.
23:27:07 --- mode: ChanServ set +o shachaf
23:27:20 --- mode: shachaf set +q *!*hpaste@*
23:27:23 --- mode: shachaf set -o shachaf
23:31:45 <charco> shachaf, I have tried with cse-ghc-plugin but couldn't suceed :(
23:32:07 <shachaf> Look, GHC doesn't do CSE (except in very specific cases).
23:32:12 <shachaf> I don't recommend plugins.
