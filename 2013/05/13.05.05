00:00:09 <kwantam> some languages do need it but let you leave it out and then try (badly) to insert it
00:00:13 <kwantam> e.g., Javascript :)
00:00:38 <Javran> > let f 1 = 1; f x = x * f (x-1) in f 10
00:00:40 <lambdabot>   3628800
00:00:58 <Javran> I meant here ";" has nothing to do with IO monad..
00:01:31 <kwantam> in all the conversational churn, it seems to me we're all agreeing on that one way or another.
00:01:39 <kwantam> but it's more fun than mundane agreement
00:01:56 <shachaf> I disagree with everybody except cmccann.
00:02:22 <kwantam> I disagree with everyone except people who disagree with me.
00:02:31 <cmccann> I agree with everyone except shachaf.
00:02:56 <kwantam> sadly since disagreement isn't reflexive, that's less nonsensical than I'd like it to be.
00:03:50 <kwantam> (inasmuch as english isn't a precise language, that is)
00:05:11 <cmccann> it's hard being nonsensical in english :[
00:05:24 <kwantam> it's hard *not* being nonsensical in English!
00:05:29 <kwantam> :D
00:10:38 <shachaf> cmccann: How brusque!
00:13:04 <cmccann> shachaf: brusque is a good word. has a nice sort of choppy flair.
00:13:51 <shachaf> Google gives the pronunciation as /brəsk/.
00:13:57 <shachaf> I'm pretty sure you're not allowed to do that.
00:14:11 <kwantam> schwa is the catchall for "you know that vowel-ish sound"
00:14:42 <cmccann> also, schwa looks like a lowercase existential quantifier.
00:14:46 <arkeet> haha
00:14:58 <shachaf> Yes, but how can it be the stressed vowel?
00:15:22 <arkeet> what's wrong with that?
00:15:28 <shachaf> Everything.
00:15:33 <shachaf> I cmccann was in -blah I'd expand.
00:15:37 <cmccann> shachaf: you just need to harass it enough. maybe yell a bit.
00:15:40 <kwantam> generally schwa is unstressed but it's not required to be
00:15:48 <cmccann> that will stress it out eventually.
00:31:19 <vervic> Hi! i have to implement an BTree, I need a direction to start from?
00:31:32 <mm_freak> vervic: start with a type
00:31:38 <mm_freak> data BTree a = …
00:32:00 <johnw> and I'd read up on BTrees
00:34:07 <shachaf> They say that ATrees' children are ATrees, but BTrees' children are CTrees.
00:36:26 <mm_freak> BTree's child is []
00:36:34 <cmccann> shachaf: did you see the moneys I used to pay elliott for doing a useless proof?
00:36:42 <shachaf> cmccann: No.
00:36:47 <shachaf> mm_freak: ?
00:37:00 <cmccann> I am thinking I should do that more often so that he'll actually do something.
00:37:02 <mm_freak> ∂ BTree = []
00:37:33 <shachaf> cmccann: ?
00:37:33 <cmccann> shachaf: http://i.imgur.com/I6ROu7Q.png
00:37:46 <cmccann> I already paid elliott with that though so don't try to use it yourself!!1
00:38:30 <shachaf> Wow.
00:38:36 <shachaf> I've never gotten paid for doing useless proofs.
00:38:50 <cmccann> especially not paid with totally legit moneys.
00:38:53 <mm_freak> me neither =/
00:39:32 <shachaf> cmccann: Which BTree are you talking about here?
00:40:10 <cmccann> I don't think this has anything to do with BTrees.
00:40:31 <shachaf> s/cmccann/mm_freak/
00:41:05 <shachaf> cmccann: You should have given elliott linearly-typed moneys.
00:41:09 <shachaf> Well... Affinely-typed.
00:41:35 <cmccann> frankly I think I did give him a fine moneys.
00:45:35 <mm_freak> shachaf: the one with a one-hole context
00:46:11 <__xc> the pigeon-hole
01:01:15 <mm_freak> __xc: surprisingly that's related
01:01:26 <mm_freak> a zipper can't represent the empty list
01:01:43 <__xc> I hitted randomly though
01:02:49 <mm_freak> i'm thinking of making videos for a number of domain-specific concepts in haskell
01:03:57 <__xc> I don't like lisp syntax, but idk it seems a language well used for logic http://stackoverflow.com/a/4755/1125394
01:05:13 <__xc> hehe: "but with enough money and programmers it isn't hard" -- that said, given sufficiently many programmers it becomes impossible ;-)
01:06:58 <hpaste> “Ertugrul Söylemez” pasted “Benchmarks of various stream implementations” at http://hpaste.org/87262
01:07:04 <mm_freak> this benchmark is very interesting
01:07:34 <mm_freak> if you need to generate and consume a stream you should use the 'streams' library or a custom Stream type like Stream3 in that code
01:07:56 <mm_freak> interestingly using Str.iterate yields slower code than using explicit recursion
01:08:05 <__xc> not to confoud with scream3
01:08:28 <mm_freak> in particular, if you have a stream, use Stream, not []
01:08:36 <mm_freak> it's not only more correct, but also faster and more convenient
01:08:58 <mm_freak> that's my conclusion
01:09:16 <mm_freak> the worst stream implementation is the one at the bottom called LS
01:09:31 <mm_freak> it's isomorphic to Stream
01:09:44 <shachaf> Streamplementation.
01:10:04 <mm_freak> i could probably optimize index5 a bit
01:11:41 <mm_freak> another interesting result is that for Integer 'x - 1' is faster than 'pred x'
01:11:47 <mm_freak> i would have expected the opposite
01:12:09 <mm_freak> while for bounded types like Int and Word the performance is equal
01:13:26 <mm_freak> i now optimized index5 by removing the repeated reconstruction of LS…  it gives only a marginal speedup, but it's still the worst of all five
01:14:37 <mm_freak> what baffled me is that corecursively producing and recursively consuming a Stream is actually faster than a monolithic recursive algorithm
01:15:10 <mm_freak> (cf. index2)
01:16:13 <__xc> even the quicksort in lisp, I can't understand, though haskell ones were explicit, http://stackoverflow.com/a/8789/1125394
01:20:39 <ion> That function implements quicksort?
01:23:15 <c_wraith> ion: that's more or less identical to the haskell versions tutorials like to point out
01:23:36 <ion> I’m not sure they implement quicksort either.
01:24:03 <c_wraith> Eh. It's quicksort on a non-ideal data structure.
01:24:15 <c_wraith> But it fits the exact definition of quicksort as it was originally described
01:26:40 <ion> So i take it the original description didn’t assume mutation?
01:26:40 <Guest68060> it has poor choice of pivot element
01:26:42 <c_wraith> running in-place appears to be an optional optimization in Hoare's original description
01:26:56 <ion> ok
01:27:18 <c_wraith> Guest68060: sure. but making a good choice needs about 3x the code
01:27:28 <Guest68060> yeah
01:27:28 <c_wraith> kind of ruins it as a "simple" example
01:27:40 <Guest68060> idk why it should be used as an example at all
01:37:22 <__xc> at least you seem to get lisp syntax, congrats
01:37:28 <wole> @ty runIO
01:37:29 <lambdabot> Not in scope: `runIO'
01:37:30 <mm_freak> one thing people forget is that the asymptotic running time is usually part of qsort's definition
01:37:37 <wole> @hoogle runIO
01:37:37 <lambdabot> Language.Haskell.TH.Syntax runIO :: IO a -> Q a
01:37:37 <lambdabot> Language.Haskell.TH runIO :: IO a -> Q a
01:37:38 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
01:38:08 <mm_freak> so what we see as the nice shiny qsort in haskell isn't actually qsort
01:39:05 <Taneb> Isn't the canonical quicksort in-place?
01:39:58 <mm_freak> on the other hand i'd like to point out that the performance of the idiomatic qsort-like function people like to give as a showcase for haskell doesn't actually perform that bad
01:40:04 <mm_freak> it's just far from optimal
01:43:02 <Adeon> is it conceivable that someone would actually use it in real code
01:44:11 <Araneidae> Hi folks.  I'm trying to get my head around monad transformers using ReaderT ... and it's harder than I expected!
01:44:37 <Araneidae> Does this fellow have a name: \f -> \a -> lift $ f a ?
01:44:37 <XexonixXexillion> Are there any good functional ways of implementing a maxheap?
01:45:30 <Chousuke> Araneidae: isn't that just lift
01:45:56 <Araneidae> Chousuke, not sure, because it abstracts the a.  THe type is (a -> m b) -> a -> t m b
01:46:11 <Araneidae> so isn't the lift in the wrong place?  Simple lift didn't do the job for me
01:46:49 <Chousuke> oh never mind that $ somehow didn't register to me
01:47:07 <Araneidae> I feel I'm somewhat diving in at the deep end here!
01:53:33 <Guest68060> hey guys is "product (take n [1..])" actually slower than "xs=[1..n] \n product xs"? This guy in a vid gives it as an example of where lazy evaluation may not be ideal
01:55:32 <Primoz128> Guys what IDE do you use for Haskell ?
01:55:50 <latermuse> vim
01:55:55 <Taneb> Primoz128: I use emacs. If you want a full IDE, I'd say either Eclipse or Leksah
01:56:00 <Taneb> But you really don't need one
01:56:13 <Araneidae> vim and alt-tab
01:56:48 <latermuse> I use iterm, it lets me open lots of terminal windows at the same time
01:56:55 <latermuse> usually run vim in one pane, and ghci in another
01:57:05 <latermuse> and have another pane for browsing file system, and another pane for irc
01:57:06 <Primoz128> Ill try Leksah, not gona use Eclipse ever again.
01:57:25 <latermuse> eclipse for haskell would probably be overkill
01:57:35 <latermuse> leksah is designed with haskell in mind, so you should give that a shot
01:57:59 <shachaf> Guest68060: Try it out!
01:58:24 <shachaf> I don't see an obvious reason it should be slower.
02:14:21 <Darkproger> what's the general way of working on a cabal app + a cabal library in a separate repo?
02:14:48 <Darkproger> i currently have to re-install my library  every time i'm going to recompile an app which is annoying
02:17:31 <__xc> sorry but I've a git question, and can"t send in #git for some reason, is the .git folder 'linked' with the folder name containing it?
02:17:31 <__xc> I mean renaming the folder will change something
02:17:49 <johnw> Darkproger: cabal-meta was designed to solve that very problem
02:18:22 <johnw> __xc: it is not linked
02:18:59 <__xc> but when you have a repo it's stuff.git, and extracted under stuff/
02:19:11 <Darkproger> johnw: awesome! thanks
02:19:24 <johnw> __xc: that's convention
02:19:32 <__xc> there I created a stuff_foo/ then git init inside then want to rename to stuff :)
02:19:41 <__xc> o ok
02:21:03 <__xc> else seems lisp is kind of an opposite to haskell in the type strictness
02:21:26 <johnw> i really don't know what you mean by that
02:23:47 <zert> Hey, could someone help me with a small problem of mine ?:)
02:25:35 <shachaf> zert: Not if you don't say what it is, I'm afraid.
02:25:53 <zert> ah i was kinda scared to spam this channel thought this would go over query srry :)
02:26:14 <shachaf> No, that's the opposite of how you should do it.
02:26:40 <zert> okay so I have this function that filters words with certain elements, in this case '?' and '!'
02:27:02 <shachaf> If someone volunteers to help you without knowing what the question is, and it turns out they can't help you, they'll probably feel bad about it. So no one wants to volunteer without knwoing what the problem is.
02:27:21 <zert> now as a result for the cases in which these elements exist i return []
02:27:39 <zert> instead I want to return nothing so that my result isnt spammed with all these ugly empty lists
02:27:43 <zert> the particular function is this
02:27:44 <zert> fun5 :: [[Char]] -> [[Char]]
02:27:44 <zert> fun5 (x:xs) = map (\n-> hilfi n) (map (\n-> funhilf2 n) (x:xs))
02:27:44 <zert> funhilf2 [] = []
02:27:44 <zert> funhilf2 (x:xs) = if '?' `elem` (x:xs) || '!' `elem` (x:xs) then [] else (x:xs)
02:28:12 <shachaf> You shouldn't paste more than a couple lines into this channel. Use hpaste.org.
02:28:23 <zert> alright ill keep that in mind, sorry. first time im here
02:28:39 <Darkproger> johnw: is it possible to make cabal-meta figure out that the dependency has to be recompiled and reinstalled ?
02:28:54 <Darkproger> johnw: or should that step be done manually each time?
02:29:11 <johnw> Darkproger: if you "cabal-meta install", it rebuilds everything in the correct order
02:29:32 <johnw> i don't know that it's smart enough to do incremental builds, and install only the things needed to build the library you're working on
02:29:40 <hpaste> zert pasted “function” at http://hpaste.org/87263
02:34:32 <FireFly> zert: well, your function has to return *something*.  What is the problem with returning an empty list?
02:36:39 <FireFly> zert: oh, wait, I think I see what you mean.  You could always filter out the empty lists in `fun5`, after the mapping
02:36:47 <zert> ah thats a great idea
02:37:16 <zert> thanks! :)
02:37:29 <FireFly> By the way, you don't *have* to pattern match on lists with (x:xs), so in this case you could just use xs directly instead
02:37:38 <Primoz128> Oh so Leksah is is for Haskell in Haskell, legit, gona use
02:37:46 <zert> ye I was trying some stuff with recursion to get rid of the empty lists tho
02:37:50 <zert> so thats why its a leftover
02:37:53 <FireFly> Aha
02:38:09 <zert> i guess filtering is the obvious answer tho :P
02:38:20 <FireFly> Yeah, I think that's the easiest
02:40:02 <__xc> johnw thnk I'm wrong I saw a lisp example like (foo x5) and (foo x `apple) but in haskell you could still create a type to gather integers and lists
03:02:06 <Darkproger> what's the way to serialize access to stderr? i want threads to at least write a line at a time
03:04:08 <mauke> you could use an MVar Handle
03:06:06 <mietek> What's the problem with filtered as a lens traversal?
03:06:59 <shachaf> It violates a law.
03:07:16 <shachaf> Namely over l f . over l g = over l (f . g)
03:10:43 <donri> mietek: i think traversals need to retain the size/shape of the structure. it's like Functor and you wouldn't expect map over a list to change the list length.
03:12:14 <shachaf> Note that ifiltered -- filtering on the index -- is an OK traversal.
03:12:20 <shachaf> And filtered is an OK fold.
03:12:51 <klrr> can someone help? https://gist.github.com/klrr/5520388 at line 66 i try to write a function that takes prims(at line 103) and creates a new Env(a map of Strings and Exprs) with those prims, anyone got an idea how i dont understand how i can make this loop over?
03:12:54 <donri> hm what does filtering on the index mean?
03:13:36 <shachaf> Hmm, I'm not thinking of ifiltered.
03:13:38 <shachaf> That one is evil.
03:13:44 <shachaf> I'm thinking of indices.
03:14:08 <shachaf> > over (traversed . Lens.indices even) toUpper "hello world"
03:14:10 <lambdabot>   "HeLlO WoRlD"
03:14:53 <shachaf> The trouble with filtered is that the predicate might change after you map.
03:15:29 <mjrosenb_> hey, does anyone know where I can clone the ghc repo?
03:15:53 <shachaf> The official repository is at http://darcs.haskell.org/ghc.git/
03:16:12 <shachaf> See http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources
03:16:14 * mjrosenb_ likes darcs.*\.git
03:16:38 <mjrosenb_> shachaf: ahh, Iwas looking in the 'downloads' section
03:16:38 <shachaf> At least it's not on cvs.haskell.org.
03:17:59 <mjrosenb_> that *looked* like a netsplit
03:18:11 <mjrosenb_> but normally freenode knows when there is a netsplit
03:18:24 <mjrosenb> also
03:18:39 <mjrosenb> svn://darcs.haskell.org/ghc.git
03:23:39 <FireFly> Hm. How is "DataConstructor . function" disambiguated from "Package.identifier"?
03:24:12 <shachaf> It's not.
03:24:22 <shachaf> > (Just.id) 5
03:24:38 <shachaf> > (Just . id) 5
03:24:52 <shachaf> Well, whatever. The former is an error.
03:25:11 <FireFly> All right
03:27:34 <liyang> Is ezyang around these parts?
03:28:04 <liyang> He has a crufty http://hackage.haskell.org/package/system-posix-redirect , was wondering if he'd mind if I NMU'd it.
03:28:31 <FireFly> > "welcome back, lambdabot"
03:28:59 <FireFly> Hm, I guess not then..
03:29:00 <lambdabot>   "welcome back, lambdabot"
03:30:15 <Araneidae> I'm getting horribly bemused by library flux and multiple versions.  As a beginner what how do I figure out what versions I should be using?  Currently trying to use Data.Binary.{Get,Put}
03:30:55 <Araneidae> I seem to have 0.5.1.0 installed, but hackage points me to 0.7.1.0 by default, and there seem to be some significant changes
03:31:10 <Araneidae> ... suspect I want the improved error handling in Get
03:32:17 <shachaf> If you aren't using any library that relies on the old version of binary, you might as well use the new one.
03:33:00 <Araneidae> I had to install ghc by hand locally (don't have admin, this is RHEL6) -- should I use cabal to get the latest version?
03:33:22 <Araneidae> I installed ghc 7.4.2
03:33:35 <Araneidae> Ouch
03:33:39 <ghorn> Araneidae: if you installed ghc by hand, you probably should use cabal for all your library related needs
03:34:02 <shachaf> You should use cabal-install, yes.
03:34:11 <shachaf> It will install in your home directory by default.
03:35:00 <Araneidae> Yii.  The world (or freenode) is falling apart
03:35:00 <ghorn> haha
03:35:32 <Araneidae> How do I figure out the package name?  data-binary and Data.Binary aren't valid names...
03:36:02 <Araneidae> Maybe it's just "binary"?
03:36:15 <ghorn> try looking here http://www.haskell.org/hoogle/
03:36:44 <ghorn> I searched for Data.Binary and clicked the first link
03:36:49 <ghorn> getting this http://hackage.haskell.org/package/binary
03:37:00 <ghorn> and in fact, it shows Data.Binary in that package
03:37:10 <Araneidae> Yes... but that's a bit hit and miss.  However, I see that the top of the hackage page shows exactly the package name
03:37:11 <ghorn> it takes a bit of trial and error
03:37:20 <ghorn> yeah
03:37:29 <Araneidae> So ... binary update coming up
03:38:02 <ghorn> there's also hayoo http://holumbus.fh-wedel.de/hayoo/hayoo.html
03:38:57 <Araneidae> Ouch.  My Data.Binary.IEEE754 is out of step now.  Guess that's just a reinstall
03:39:07 <ghorn> careful about using --reinstall
03:39:38 <ghorn> it can be safer to manually do "ghc-pkg unregister oldpackage" to uninstall, then you do a fresh install
03:40:02 <Araneidae> ?  So that's a non cabal operation followed by cabal?
03:40:09 <ghorn> yes
03:40:13 <ghorn> cabal-install wraps ghc-pkg
03:40:19 <ghorn> ghc-pkg is the low level tool
03:40:33 <Araneidae> Eww.  TMI ;)
03:40:40 <hpaste> Svarg pasted “Space leak with StateT + Writer” at http://hpaste.org/87265
03:40:51 <ghorn> i only use "ghc-pkg list" to show all insatlled packages, "ghc-pkg unregister" to uninstall, and "ghc-pkg check" to tell me if anything is broken
03:41:03 <ghorn> everything else is cabal
03:41:25 --- mode: adams.freenode.net set +o ChanServ
03:41:25 * Araneidae makes nots
03:42:30 <donri> Svarg: maybe try the strict writer
03:42:44 <Svarg> nope doesn't help
03:43:03 <Svarg> as far as i can tell test1 through to test4 should be identical
03:43:07 <Svarg> but they behave differently
03:43:13 <Svarg> in test4 there is no space leak
03:43:24 <Svarg> in test3, there is no space leak unless profiling is enabled
03:43:32 <Svarg> and test1 and 2 always leak
03:44:16 <alpounet> Svarg, you should check the GHC Core for these guys and compare them to see what's going on
03:44:23 <alpounet> (using e.g ghc-core)
03:44:45 <Svarg> ok - will have a go at that
03:45:17 <alpounet> but you'd need to be familiar with Core -- hopefully that's a little bit the case? that's quite similar to Haskell but understanding what's really going on can be hard sometimes
03:46:15 <shachaf> Core is much easier to understand with -dsuppress-all
03:46:31 * shachaf needs to get around to adding all the exciting things to ghc-core that he's been planning to.
03:46:43 <Svarg> i know of it and know people use it for debugging things like this - i haven't played with that side of things though
03:47:26 <mjrosenb> anyone know how to build ghc without building haddock?
03:48:43 <kartoffelbrei> Araneidae: you may want to check out hsenv as well. it's an isolation tool which lets you build independent sandboxes for ghc, cabal and friends. that way you can often escape the dependency hell when installing stuff with lots of dependencies that somehow confilct with your current setup.
03:50:27 <Araneidae> kartoffelbrei, thanks for the suggestion.  I remember bouncing off cabal dependency hell a few years ago, but haven't had much chance to play since then
03:50:57 <shachaf> mjrosenb: What elliott said.
03:51:15 <Araneidae> At the moment I'm trying to hack together a simple protocol interface ... I presume Data.Binary.{Put,Get} is the right building block for a byte stream interpreter?
03:51:24 <mjrosenb> shachaf: I didn't see elliott say anything.
03:51:59 <Svarg> gah.. ghc-core failed to install because it depends on pcre which failed to install...
03:52:09 <shachaf> mjrosenb: Exactly.
03:52:14 <shachaf> (OK, that was just unhelpful. Sorry.)
03:52:54 <jamy> Hello everybody!
03:53:34 <Araneidae> Is this the best way to convert a String to a UTF-8 ByteStream: bytes = BB.toLazyByteString $ mconcat $ map BB.putCharUtf8 s ? Seems horribly clunky
03:54:14 <shachaf> Araneidae: Perhaps Data.Text.Encoding.encodeUtf8 . Data.Text.pack
03:54:23 <Araneidae> Ta
03:54:26 <shachaf> Or the Lazy equivalent, I suppose.
03:54:44 * Araneidae is painfully hazy about the difference laziness will make
03:55:14 <shachaf> Lazy ByteString/Text is a list of strict ByteString/Text
03:56:13 <kartoffelbrei> Araneidae: Data.Binary is for serialization of Haskell Values. Not for general binary parsing. However if you somehow represent everything in your protocal as a simple Haskell value, then binary should be fine. Note that you don't even have to implement the binary class yourself. Just let ghc derive a Generic instance and use the default instances from binary. This depends on how recent your GHC + binary is, though.
03:56:25 <Svarg> is there a way to get cabal to pass a -l option to the linker?
03:56:48 <Svarg> that's lower case L, not upper case i
03:57:06 <shachaf> There's a way to get cabal to pass an option to GHC.
03:57:13 <shachaf> And there's a way to get GHC to pass an option to the linker.
03:57:31 <shachaf> I recommend figuring out each of those ways separately and then combining them.
03:57:52 <Svarg> hmm ok i'll try that
03:58:15 <Araneidae> kartoffelbrei, I didn't really get that.  I need something to read and write integers and floats of varying sizes, and I'm coding against an existing protocol to interpret and generate byte streams corresponding to Haskell types I'm writing.  Don't think there's a role for autogeneration?
03:58:16 <jamy> Anybody want scientific calculator which programming on haskell?
03:58:18 <kartoffelbrei> Araneidae: For general binary parsing, you may want to look at the attoparsec package. AFAIK it supports incremential parsing too. I havent used it myself though.
03:58:29 <Araneidae> attoparsec.  Hmm, ok
03:58:35 <donri> Svarg: there's --ld-option[s] but that might be for C sources
03:58:48 <Svarg> oh right
03:58:48 <ghorn> Araneidae: what is teh existing protocol?
03:59:05 <donri> Svarg: so probably safer to use --ghc-option[s] as shachaf suggested
03:59:19 <shachaf> Oh, I might be wrong and maybe --ld-options is OK.
03:59:40 <mjrosenb> did Data.Map have a different name in 7.4?
03:59:43 <Araneidae> ghorn it's called PV types: http://epics-pvdata.sourceforge.net/ and it's very m uch a work in progress
04:00:56 <mm_freak> mjrosenb: no
04:01:03 <Araneidae> kartoffelbrei, think I'll have to take a look at attoparsec later, it may be rather a close match...
04:01:05 <shachaf> mjrosenb: No, but the modules were organized differently.
04:01:10 <Svarg> hmm is there a way to get ghc to output core directly without installing ghc-core? thinking that might be easier - not sure why but i seem to have a ton of problems when installing certain packages
04:01:17 <mjrosenb> Distribution/ParseUtils.hs:88:18: Could not find module `Data.Map'
04:01:18 <mm_freak> mjrosenb: but the latest containers library actually gives you two interfaces to Map
04:01:22 <shachaf> Svarg: ghc foo.hs -ddump-simpl
04:01:27 <Svarg> ah
04:01:31 <Svarg> so what's ghc-core do then?
04:01:33 <shachaf> mjrosenb: I guess you don't have containers installed, or something?
04:01:39 <mm_freak> mjrosenb: Data.Map is not part of the base library…  you need to install the 'containers' library
04:01:44 <shachaf> Svarg: Syntax-highlights it and cleans it up and puts it through a pager.
04:01:51 <Svarg> oh right
04:01:54 <shachaf> In the future, hopefully more than that. :-)
04:02:09 <Svarg> i can live without that - think i'll just use -ddump-simpl for now
04:02:14 <mjrosenb> I'm not seeing a containers library.
04:02:26 <mm_freak> jamy: feel free to write one =)
04:02:36 <mm_freak> mjrosenb: are you using the 'cabal' command line utility?
04:02:55 <shachaf> mjrosenb: It comes with GHC.
04:03:03 <shachaf> You must be "doing something fishy" -- but we knew that already.
04:03:13 <mjrosenb> mm_freak: no, I'm trying to build cabal.
04:03:16 <mm_freak> shachaf: the containers library comes with the platform
04:03:36 <shachaf> mm_freak: And with GHC.
04:03:38 <jamy> I mean pocket calc
04:04:26 <shachaf> mjrosenb: cabal-install or Cabal?
04:04:31 <mjrosenb> shachaf: cabal
04:04:39 <mjrosenb> shachaf: I don't like cabal-install.
04:04:45 <kartoffelbrei> Araneidae: I guess you could use a comination of attoparsec and binary. Use attoparsec to parse stuff like the protocolheaders etc. and use binary (de)serialize the raw data.
04:04:51 <shachaf> "cabal" with a lowercase c is a bit ambiguous. :-)
04:04:59 <mjrosenb> /usr/lib64/ghc-7.4.2/containers-0.4.2.1/Data/Map.hi
04:05:03 <mjrosenb> shachaf: fair enough.
04:05:04 <shachaf> mjrosenb: Are you the SPARC person or something?
04:05:26 <mjrosenb> shachaf: ppc64.
04:05:30 <shachaf> Ah, right.
04:05:35 <Araneidae> kartoffelbrei, I'm going to stick with Binary for the time being -- need to get something I can understand to start with...
04:05:36 <shachaf> So that's why you're running into all the weird trouble.
04:05:49 <mm_freak> shachaf: you're right, sorry
04:05:50 <shachaf> mjrosenb: So does ghc-pkg list see containers?
04:05:51 <mjrosenb> shachaf: well, that and gentoo
04:06:25 <mjrosenb>    containers-0.4.2.1
04:06:29 <mjrosenb> shachaf: but it is in red
04:06:38 <mjrosenb> I'm not sure what that means, but re is usually not go
04:07:10 <jamy> mm_freak: I mean pocket calc
04:07:26 <mjrosenb> https://gist.github.com/5520511
04:08:27 <Araneidae> Argh!  How many different representations of byte strings are there?!
04:08:35 <donri> two
04:09:00 <donri> and one is implemented using the other
04:09:16 <Araneidae> Just two?  Still too many!  Do I want Data.ByteString.Lazy.ByteString or Data.ByteString.Internal.ByteString ?
04:09:30 <Svarg> i can't make heads or tails of this
04:09:38 <Araneidae> The latter is what encodeUtf8 gave me, the former is what I was expecting.
04:09:42 <Svarg> it's about as readable as xml
04:09:55 * hackagebot case-insensitive 1.0.0.2 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-1.0.0.2 (BasVanDijk)
04:09:58 * hackagebot lifted-base 0.2.0.5 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.2.0.5 (BasVanDijk)
04:10:23 <donri> Araneidae: http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString-Lazy.html#v:fromStrict
04:11:00 <Araneidae> Thanks!
04:11:16 <Araneidae> Ok, it's strict vs lazy.  Ho hum
04:12:11 <donri> Araneidae: lazy is basically a list of strict chunks
04:12:35 <Araneidae> That actually makes sense to me, and I can see why you'd want to do that.
04:12:53 <Araneidae> Not sure I want to be using putLazyByteString to write my strings though...
04:13:11 <donri> Araneidae: or import Data.Text.Lazy.Encoding instead
04:13:31 <donri> it converts between lazy bytestrings and lazy texts, and you seem to have a lazy text
04:14:46 <Araneidae> Not necessarily.  On the one side I've got a String, on the other a ...um... ByteString.  Well, actually, what Data.Binary.Put writes, which is a lazy byte string.
04:16:27 <donri> Araneidae: surely binary has instances for strings
04:16:49 <Araneidae> I'm drowning in the documentation, actually.
04:17:33 <Araneidae> Right now I have a Data.ByteString.Internal.ByteString which is what encodeUtf8 gave me.  I need its length, and I need to Put it.
04:17:37 <donri> Araneidae: just use 'put'
04:18:08 <donri> unless you're targeting some specific format
04:18:38 <donri> Araneidae: what is your end goal?
04:19:28 <Araneidae> donri, twofold: 1/ actually write some Haskell code and understand the process!  and 2/ write a simple byte stream protocol interface for PV types
04:19:51 <donri> what are PV types?
04:20:32 <Araneidae> Some weird protocol being developed by the EPICS community (don't ask)  Google "epics V4" if you really care
04:20:41 <Araneidae> Doesn't matter, it's an exercise
04:21:37 <Araneidae> When you said "just use 'put'", which put did you mean: Hoogle gives me three, none of which look illuminating to me
04:21:41 <jamy> In general, those who need pocket scientific calculator which programming on haskell then please contact me
04:21:48 <donri> Araneidae: Data.Binary.put
04:21:53 <Araneidae> ta
04:22:42 <donri> Araneidae: sources suggest String is serialized as UTF-8
04:23:08 <Araneidae> Yes, UTF-8 preceded by a rather strangely encoded length
04:23:31 <Araneidae> Unfortunately there's some nastiness regarding endianess, so I have to do a bit of wrapping on the way
04:23:39 <donri> ah
04:23:50 <Araneidae> For the moment I've defined: type StreamPut = ReaderT Endian P.PutM ()
04:24:12 <Araneidae> Have to say my first encounter with monad transformers was a bit painful
04:24:33 <donri> Araneidae: seems the length is a 4 bytes big endian
04:24:39 <Araneidae> You wish
04:24:57 <Araneidae> Actually, it's a byte if it's less that 255, or it's 4 bytes in the current endian mode
04:24:58 <donri> Araneidae: if you use "put str"
04:25:27 <Araneidae> ... actually that was a lie, it's 255 then 4 bytes in current endian mode
04:26:19 <Araneidae> Here's the offending document: http://epics-pvdata.sourceforge.net/pvAccess_Protocol_Specification.html
04:26:38 <donri> Araneidae: are you describing what binary does or what you need?
04:26:45 <Araneidae> What I need
04:27:08 <mjrosenb> There are problems in package deepseq-1.3.0.0: Warning: library-dirs: /usr/lib64/deepseq-1.3.0.0/ghc-7.4.2 doesn't exist or isn't a directory
04:27:22 <Araneidae> Of course, if binary did that then I'd just take what it gives me (once I'd figure out how!)
04:27:28 <mjrosenb> but it looks like the files are actually located at: ./usr/lib64/ghc-7.4.2/deepseq-1.3.0.0/ ?
04:27:42 * mjrosenb thinks ghc-pkg check is confused?
04:28:19 <donri> Araneidae: well from the binary sources i gather that the Binary class serializes String as first 4 big endian bytes for the length and then the string encoded as utf-8.
04:28:30 <donri> Araneidae: so you probably can't just use "put" and be done with it
04:28:44 <Primoz128> How do i make an EXE in Haskell ?
04:29:03 <ion> ghc, for instance.
04:29:43 <Araneidae> donri, absolutely.  My current strategy is to encode into bytes then put the length followed by the bytes, but I'm trying to use encodeUtf8 instead of `map putCharUtf8` and haven't figured out the changes yet
04:29:57 <mjrosenb> how can I find out why ghc-pkg thinks deepseq is located at /usr/lib64/deepseq-1.3.0.0?
04:31:08 <donri> Araneidae: you could possibly use http://hackage.haskell.org/package/text-binary
04:31:55 <Araneidae> Interesting documentation page: http://hackage.haskell.org/packages/archive/text-binary/0.1.0/doc/html/Data-Text-Binary.html -- it's empty for me
04:32:09 <donri> Araneidae: yes, it defines Binary instances only
04:32:48 <donri> Araneidae: anyway you probably can't use text-binary *nor* encodeUtf8 because all these options encode the length for you
04:33:15 <Araneidae> Oh ... didn't realise encodeUtf8 gave me a length code!  Grr
04:33:31 <donri> Araneidae: it doesn't, but put'ing the bytestring will
04:33:50 <Araneidae> Wasn't planning on put'ing the bytestring (that was your suggestion!)
04:34:07 <donri> Araneidae: probably best use mapM_ put str, after put'ing the length the right way yourself
04:34:18 <Primoz128> In the build folder of a package, which of the following folders contains the true executoble: autogen ; Package ; test-Package  ?????
04:34:22 <thorsten`> can i mark a case-of distinction as total? i want ghc to check that i didn't forget a type constructor in my pattern matching
04:34:31 <Araneidae> I'll go and play a bit, think I've got enough stuff to fiddle with for now.  Would like to come back later for a code critique if that'll work
04:34:57 * hackagebot system-posix-redirect 1.0.0.1 - A toy module that allows you to temporarily redirect  a program's stdout.  http://hackage.haskell.org/package/system-posix-redirect-1.0.0.1 (LiyangHu)
04:35:09 <donri> Araneidae: well not sure what encodeUtf8 buys you if you're not putting the bytestring :) i guess you could unpack it and put the word8's but not really better than the chars
04:35:32 <donri> it could be faster, but too early to optimize!
04:35:36 <kartoffelbrei> thorsten`: ghc can emit warnings about incomplete pattern matches
04:35:38 <Araneidae> So my original: BB.toLazyByteString $ mconcat $ map BB.putCharUtf8 s -- is the best it can be?
04:35:44 <Araneidae> Just seemed ugly
04:36:27 <donri> Araneidae: wait, you're using Builder? i thought you were using binary...
04:36:52 <thorsten`> kartoffelbrei: thanks! -fwarn-incomplete-patterns does exactly what i want :)
04:36:56 <kartoffelbrei> thorsten`: with -fwarn-incomplete-patterns. it's probably a good idea to allways compile with -Wall.
04:37:08 <Araneidae> No, I think I'm *only* using the bulder in this one special case on the way to a `putLazyByteString bytes`
04:37:21 <Araneidae> ... sounds pretty wrong to me
04:37:31 <Primoz128> im trying to build an exe in Leksah: In the build folder of a package, which of the following folders contains the true executoble: autogen ; Package ; test-Package  ?????
04:37:42 * Araneidae wonders where the BB came from
04:38:38 <Araneidae> That was it: I needed putCharUtf8, and Binary.Builder was where I found it
04:39:51 <donri> oh, binary's builder
04:40:08 <donri> Araneidae: well 'put' for Char is just putCharUtf8 anyway i think
04:40:14 <donri> but in the Put monad
04:42:30 <Araneidae> I'll go dig into Data.Text.Encoding.encodeUtf8, see if it comes out any nicer for me
04:44:25 <donri> Araneidae: i think you just want: foo str = let len = length str in if len > 255 then put str else putWord8 (fromIntegral len) >> mapM_ put str
04:44:59 <hseg> Was thinking the other day, and noted that the Functor typeclass does not completely capture actual category-theoretical functors, as it is lacking a function pure :: (Functor f) => a -> f a. I haven't seen this pointed out before. Are people aware of this or is my reasoning wrong?
04:45:29 <shachaf> hseg: Your reasoning is wrong. Or your understanding is.
04:46:12 <shachaf> hseg: Maybe if you elaborate people can tell you how it's wrong. :-)
04:47:07 <Svarg> hseg: are you saying Applicative should be renamed to Functor?
04:47:22 <Araneidae> donri, need to encode the string first -- the length has to be the length of the UTF-8 byte sequence, not the original string.
04:47:35 <hseg> OK. Why is that? http://en.wikipedia.org/wiki/Functor claims that functors F:C->D are a pair of maps f_o: Ob(C)->Ob(D) and f_m: Ar(C)->Ar(D) satisfying certain laws.
04:48:24 <hseg> Svarg: No. Applicative has an additional law that allows one to construct apA :: (Applicative a) => a (b -> c) -> a b -> a c
04:49:03 <Svarg> hseg: oops, yes that's right
04:49:04 <shachaf> hseg: There are two maps.
04:49:12 <donri> Araneidae: ah, of course
04:49:17 <shachaf> Maybe_o maps the type Int to the type Maybe Int
04:49:30 <shachaf> Maybe_m maps the type (Char -> Bool) to the type (Maybe Char -> Maybe Bool)
04:49:56 <hseg> Right. And the definition of Functor only forces you to construct f_m, not f_o.
04:50:00 <shachaf> No.
04:50:07 <shachaf> We're talking about mapping the *type*. I.e., for any type T you give me, I can give you the type Maybe T.
04:50:11 <Svarg> hseg: have you looked at category-extras
04:50:23 <shachaf> Objects in Hask are types, not values.
04:50:34 <shachaf> Svarg: How would that help?
04:50:59 <Svarg> not sure it would help but it's sort of related as it breaks down many of the type classes further
04:52:02 <byorgey> Svarg: note, category-extras is actually deprecated
04:52:16 <Svarg> ah yes
04:52:23 <byorgey> but it now has a chart showing you all the packages it exploded into
04:52:25 <Svarg> i know one of them is deprecated… couldn't remember which
04:52:28 <hseg> shachaf: Yes and no. While it is true that the Functor instance must be of kind * -> *, that does not force the existence of an arrow (Functor f) => a -> f a
04:53:04 <shachaf> hseg: You are mixing things up.
04:53:15 <shachaf> This is not a function on the value level. This is a function on the type level.
04:53:15 <hseg> OK. Care to clarify?
04:53:31 <shachaf> The type-level "function" Maybe maps the type Int to the type Maybe Int.
04:54:01 <byorgey> shachaf: "Maybe_m maps the type (Char -> Bool) to the type (Maybe Char -> Maybe Bool)"  -- you stated that confusingly.
04:54:10 <byorgey> Maybe_m maps *values of the type* ... to *values* ...
04:54:17 <shachaf> byorgey: Er, quite right.
04:54:30 <shachaf> Listen to byorgey. I messed that up.
04:55:30 <shachaf> Maybe_m maps functions of type (Char -> Bool) to functions of type (Maybe Char -> Maybe Bool)
04:56:33 <byorgey> more pithily, to highlight the difference:  Maybe_o (i.e. Maybe) maps types to types.  Maybe_m (i.e. fmap) maps functions to functions.
04:57:05 <shachaf> Yes.
04:57:14 <shachaf> Since objects of Hask are types and arrows of Hask are functions.
04:57:28 <shachaf> thyorgey for showing up and saving the day.
04:57:28 <hseg> Oh.
04:57:50 <keithodulaigh> I compile a Haskell program successfully (its called Hets) but when I execute it, the GUI starts to appear and then app crashes. I get this error then in the console hets: fd:10: hFlush: resource vanished (Broken pipe).
04:58:21 <shachaf> The function you're after maps values to values. But we don't talk about values in general at all, just functions between values.
04:58:35 <mauke> keithodulaigh: does your program open any network connections?
04:59:37 <hseg> Still quite confused. Why does the fact that one has the type-level function f :: * -> * mean one can construct values f a from any value a?
04:59:46 <shachaf> It doesn't.
04:59:56 <keithodulaigh> mauke: It shouldn't be opening network connections.
04:59:58 <shachaf> You're the one who wanted (a -> f a) to be part of Functor.
05:00:00 <shachaf> It's not.
05:00:22 <Svarg> hseg: http://hackage.haskell.org/packages/archive/pointed/3.0.2/doc/html/Data-Pointed.html
05:00:32 <hseg> Right. Because the definition of functors requires an object map and an arrow map.
05:00:50 <shachaf> Svarg: That's not Functor and it's a fishy type class that should be treated as fishy.
05:01:06 <Svarg> it's not a functor
05:01:32 <Svarg> but i thought it was in that hierarchy to lift a value into one?
05:01:38 <Svarg> like pure
05:01:49 <Svarg> from applicative but split up
05:02:04 <shachaf> Yes. But it's a fishy type nonetheless.
05:02:10 <shachaf> s/type/class/
05:02:27 <Svarg> hmm not sure - not more fishy that standard haskell type classes i think
05:02:42 <shachaf> For example: What laws does it have?
05:03:00 <Svarg> i don't think there are any for something that simple
05:03:06 <Svarg> but you'd have to ask ed kmett
05:03:14 <Svarg> since he wrote that
05:03:37 <shachaf> He also thinks it's fishy.
05:03:42 <shachaf> Maybe he'd use a different word.
05:04:07 <Svarg> hmm fair enough then
05:04:22 <Svarg> he put a fair bit of thought into that stuff
05:04:36 <shachaf> Yes.
05:04:46 <shachaf> There are some justified uses of this class.
05:10:21 <hseg> Oh, wait. Since the objects in haskell are types and the morphisms between them are the functions on those types, Functor needs only concern itself with the construction of types and the mapping of the functions between them? That's a bit.. confusing
05:11:03 <shachaf> I'm not sure what you mean.
05:11:27 <shachaf> A functor needs to give you two things: A way to map objects to objects and a way to map arrows to arrows.
05:11:51 <shachaf> Objects are types and arrows are functions.
05:12:12 <shachaf> I think the confusing thing might be that you're thinking of objects as important and arrows as secondary, or something like that.
05:12:22 <shachaf> Objects aren't important. They're just there so the arrows have somewhere to point to.
05:12:23 <mm_freak> hseg: read the type of fmap like this:  (Functor f) => (a -> b) -> (f a -> f b)
05:12:53 <shachaf> You know how you can look at a monoid as a category with one object?
05:12:59 <hseg> No, the confusing part is that I thought that the objects of Hask are the values of all possible types in it, not the types themselves
05:13:34 <hseg> As in, Ob(Hask) = {'a','b','c',...,1,2,3,...,[],['a'],['b'],...} etc
05:13:46 <shachaf> No, that's not it.
05:13:55 <shachaf> The objects are just there so that the arrows can have types.
05:14:04 <hseg> ?
05:14:18 <shachaf> Never mind.
05:15:01 <hseg> Anyway, I understand from the above that Ob(Hask) = {Int,Char,Bool,String,Maybe Int,Maybe Char,...}
05:15:11 <shachaf> Yes.
05:15:25 <shachaf> Everything should make a lot more sense now.
05:15:32 <hseg> So by the fact that Functor f implies that f is of kind * -> *, we trivially have the object mapping.
05:15:40 <FireFly> Relatedly... my understanding is that Hask's objects are "concrete" types, like Int etc, and that the function `id` would correspond to multiple arrows in Hask (one from each type to itself). Is this correct?
05:15:41 <shachaf> Right.
05:15:49 <shachaf> FireFly: Yep.
05:15:54 <FireFly> Oh, good
05:15:56 <hseg> Although it still doesn't make sense why Hask was defined this way
05:16:08 <shachaf> Yes it does. :-)
05:16:36 <FireFly> hseg: what part doesn't make sense?
05:16:51 <hseg> BTW, in re FireFly, does this mean that polymorphic functions define an infinite amount of functions, one for each type that a variable could be instantiated to?
05:17:07 <FireFly> That's my understanding anyway
05:17:25 <shachaf> hseg: Yes.
05:17:31 <shachaf> That's one way of looking at them, anyway.
05:18:35 <hseg> The part where a programmer deals in day-to-day life with values of these types, and would expect functions a -> b to construct b^a arrows, while the definition of Hask doesn't allow one to reason about, say, an individual Int.
05:18:49 <shachaf> That's right.
05:18:50 <Svarg> what would a terminal object be in hask?
05:19:10 <hseg> Basically, what I'm saying is that the degree of resolution of Hask is too coarse, in my opinion.
05:19:11 <shachaf> In a way this is the point of category theory. You talk about the relationships between things rather than the things themselves.
05:19:23 <hseg> Svarg: In my view, or the real view?
05:19:24 <shachaf> Svarg: ()
05:19:34 <Svarg> aah right, of course
05:19:34 <Svarg> unit
05:20:00 <hseg> shachaf: This I get. But the degree of resolution you're using is too coarse.
05:20:18 <shachaf> I don't know what that means.
05:21:13 <Svarg> so hask is a certesian closed categroy then? it has a terminal object, all finite products and exponentials
05:21:39 <hseg> As in, you're talking about the entire set of Integers and arrows on them and forbidding talking about integer values and arrows on them
05:22:12 <FireFly> Hm
05:22:19 <hseg> While if you would have the values of all types be the objects of Hask, you would be able to talk about both
05:22:20 <FireFly> is bottom part of Hask?
05:22:26 <dmwit> > undefined
05:22:27 <lambdabot>   *Exception: Prelude.undefined
05:22:27 <Svarg> FireFly: bottom is the initial object
05:22:33 <FireFly> Ah
05:22:36 <dmwit> what
05:22:39 <dmwit> bottom isn't an object
05:22:57 <Svarg> oh hmm… that's true.. it's a value
05:23:15 <Svarg> so does that mean there is no initial object in hask?
05:23:20 <Taneb> "forall a. a"?
05:23:29 <Svarg> aah yes
05:23:33 <shachaf> Svarg: data Void
05:23:40 <shachaf> Let's not get rank-2 types into it.
05:23:41 <mm_freak> dmwit: many people call Void bottom
05:24:06 <shachaf> Those people are risking confusing people.
05:24:28 <dmwit> mm_freak: Eh? Who does that?
05:24:37 <mm_freak> dmwit: type theory people
05:24:41 <dmwit> no way
05:24:47 <dmwit> source: I am a type theory people
05:25:03 <mm_freak> dmwit: ok, agda people
05:25:05 <hpc> HINDLY-MILNER IS PEOPLE!
05:25:05 <shachaf> dmwit: https://en.wikipedia.org/wiki/Bottom_type
05:25:06 <dmwit> Maybe if there's some subtyping involved...?
05:26:05 <dmwit> shachaf: Yeah, that's really only used if there's subtyping.
05:26:15 <mm_freak> dmwit: so agda has subtyping?
05:26:27 <dmwit> I don't think so. Are you sure Agda people call the empty type bottom?
05:26:32 <mm_freak> yes
05:26:57 <shachaf> dmwit: I think Agda uses "data ⊥ where".
05:27:01 * mjrosenb thought one of the neat things about agda was the subtyping?
05:27:14 <shachaf> and "data ⊤ where somethingorother : ⊤" for ()
05:27:23 <shachaf> mjrosenb: ?
05:27:25 <dmwit> So they do. Those nutters.
05:27:32 <dmwit> Alright, well, I'm wrong.
05:27:45 <dmwit> mm_freak++ shachaf++
05:27:47 <shachaf> dmwit: People who try to use this terminology in Haskell are wrong too.
05:27:58 <shachaf> By "wrong" I mean "confusing beginners".
05:28:07 <mm_freak> dmwit: see the Data.Empty module
05:28:10 <mm_freak> it defines ⊥
05:29:01 <dmwit> corollary: I am bad at type theory
05:30:01 <shachaf> I like the link at the bottom of that page.
05:30:03 <shachaf> Haskell's Denotational semantics (Discusses the role of Bottom in the denotational semantics of programming languages)
05:30:21 <shachaf> Evidence that this punning mixes people up.
05:30:53 <mm_freak> dmwit: to be fair i also found that confusing, because it disagrees with what you might call bottom when you have a different notion
05:31:01 <mm_freak> the unevaluatable type
05:31:08 <mm_freak> x : Set; x = x
05:31:20 <mm_freak> but of course that type doesn't exist in agda
05:31:58 <Svarg> so is hask then a cartesian closed category?
05:31:59 <shachaf> But it exists in GHCskell!
05:32:07 <shachaf> Yes.
05:32:13 <Svarg> ah
05:36:18 <hseg> Ok. So by the definition of Functors and Hask, we have that it suffices that f be of kind * -> * and that the function fmap :: (a -> b) -> (f a -> f b) exist for f to be a functor. So why do Applicative and Monad have pure and return, respectively?
05:36:38 <mm_freak> hseg: you also need to satisfy a set of laws
05:36:46 <shachaf> Because that's part of their definitions?
05:36:47 <hseg> Right.
05:36:51 <shachaf> And, yes, you need laws. Always laws.
05:36:52 <FireFly> Because of the definition of a monad
05:36:57 <mm_freak> fmap id = id;  fmap f . fmap g = fmap (f . g)
05:37:24 <hseg> OK. Where do Monads require that?
05:37:32 <shachaf> Functors require that.
05:37:35 <shachaf> Those are the functor laws.
05:37:54 <shachaf> Monads also require that. Monads are functors.
05:37:58 <hseg> I know the functor laws. I meant, why do Monads require return
05:38:01 <FireFly> http://en.wikipedia.org/wiki/Monad_(category_theory)#Formal_definition
05:38:30 <FireFly> I think `return` corresponds to the η transformation, and `join` to μ
05:38:36 <shachaf> hseg: Because that's the definition.
05:39:05 <shachaf> Why do monoids require an identity?
05:39:39 <hseg> Oh. So eta is defined as an additional required from Hask to M(Hask)?
05:40:13 <hseg> i.e. it's not the object map that its underlying functor defines?
05:40:42 <shachaf> eta is a natural transformation 1 to M.
05:41:07 <shachaf> A natural transformation is something like a polymorphic function in this case.
05:41:32 <shachaf> foo :: T a -> S a is a natural transformation from S to T, where S and T are both endofunctors.
05:41:43 <hseg> Right, right. So it's distinct from the object morphism of the underlying functor?
05:42:01 <shachaf> "object morphism"?
05:42:31 <shachaf> eta :: Identity a -> Maybe a
05:42:39 <shachaf> Except instead of Identity a we just write a
05:44:01 <hseg> Right. But what I meant was that it's distinct from the morphism f_o that the functor for that monad defines
05:44:06 <shachaf> Yes.
05:44:30 <hseg> OK. I think I'm getting this slightly better than I got this before.
05:46:16 <FireFly> What resources on category theory have you been reading?
05:46:25 * FireFly is also trying to teach himself some CT
05:46:29 <hseg> One last thing. Since a monad is defined over any category - eta, for example, is an arrow from the identity functor of the category C to M - couldn't this be used to define monad transformers as monads over the Kleisli category on the underlying category
05:46:30 <FreeFull> You can't write all the monad laws without using return
05:46:56 <shachaf> Monad transformers are a hack.
05:47:15 <hseg> FireFly: A hodgepodge of resources. Every book I've tried reading lost me after functors.
05:47:17 <shachaf> That's not what they are.
05:47:32 <hseg> I got the feeling I'm lacking some background
05:47:59 <FreeFull> For Applicative you need pure or fmap, but I don't think you need both
05:48:25 <int-e> they are the same.
05:48:44 <hseg> shachaf: IIRC, a monad transformer T over the monad M is a new monad T_M whose semantics are defined by the semantics of T and M
05:48:44 <shachaf> int-e: ?
05:48:58 <int-e> just like return. (and when I say "they are the same" I mean that's what the theory expect. implementations can cheat.)
05:49:19 * int-e thinks
05:49:50 <int-e> sigh.
05:49:56 <int-e> ignore me, please.
05:50:29 <int-e> (pure and return are the same; they make a functor pointed)
05:50:59 <hseg> Thus, I think that monad transformers represent the CT definition of monads, and that the Haskell definition of monads is actually monads over Hask, i.e. the monad transformer applied to Identity.
05:52:34 <shachaf> What do you say IO is?
05:53:09 <hpaste> “Anonymous Coward” pasted “IO and record syntax” at http://hpaste.org/87267
05:53:10 <int-e> FreeFull: Without 'pure', you can never construct any elements of the Applicative. So it's indisposable. It could be replaced by  point :: f (), then pure a = fmap (const a) point
05:54:19 <hseg> A weird construct that the compiler exposes that can be manipulated like a monad. Or a monad over the category RealWorld
05:55:02 <FreeFull> int-e: Ah, you're right
05:55:05 <shachaf> RealWorld has nothing to do with anything.
05:55:14 <FreeFull> So it's just the fmap you don't need
05:55:18 <shachaf> Anyway, you're wrong about monads.
05:55:30 <trapdInIO> Hi every one. i have a problem with reading data from file and using it to fill a struct. any suggestions http://hpaste.org/87267 ?
05:55:32 <shachaf> I don't understand what you mean well enough to tell you where you're wrong.
05:55:41 <shachaf> A monad is an endofunctor.
05:55:44 <mauke> instance MTV RealWorld
05:55:46 <shachaf> For example, Maybe.
05:55:57 <FreeFull> Identity
05:56:11 <hseg> shachaf: Right. But its an endofunctor over some category.
05:56:36 <shachaf> Yes, Haskell monads are monads in Hask.
05:56:36 <hseg> Thus, all Monads are just endofunctors over Identity
05:56:39 <latermuse> endofunctors are just functors with one type, right? like F a -> F a
05:56:39 <Botje> trapdInIO: *strongly* suggest you look at binary or cereal.
05:56:40 <shachaf> What?
05:56:46 <shachaf> What's an endofunctor over something?
05:57:02 <shachaf> latermuse: No. Endofunctors are functors from a category to itself. All Haskell Functors are endofunctors.
05:57:17 <trapdInIO> I am using Word* data types from Binary
05:57:20 <hseg> Right. I was wrong here
05:57:49 <shachaf> See the last half hour of discussion on what endofunctors are. :-)
05:58:26 <latermuse> thanks :)
05:58:31 <Botje> trapdInIO: you can use the Get monad to write a reader function for your struct
05:58:55 <latermuse> can haskell tell me why the crontab wont run my script... bah
05:59:24 <mauke> latermuse: does your script make assumptions about environment variables or the current working directory?
05:59:38 <trapdInIO> Botje: thank you very much, i'll look ito this.
05:59:47 <latermuse> mauke: no it doesnt
05:59:58 <latermuse> my other scripts are running fine, just this one script is being fickle
06:00:03 <Botje> getHeaderMZ = do a <- getWord16be; b <- getWord16be; c <- getWord16be; ... ; return $ HeaderMZ { mzLastPageSize = a, mzPagesCount = b, ... }
06:00:31 <icarot> Shachaf: then an endofunctor is to category morphisms what a homomorphism is the sets?
06:01:08 <shachaf> ?
06:01:10 <Botje> and then you can use runGet on a bytestring somehow.
06:01:10 <icarot> to sets, rather.
06:01:40 <Botje> trapdInIO: to rescue your current readHeaderMZ you basically have to perform all hGetAts in advance and bind them to temporary variables
06:01:53 <trapdInIO> Botje: yeah, it is a solution, but it will be a pain to write :)
06:02:21 <hseg> Anyway, so the definition of a monad must involve the underlying category.
06:02:45 <shachaf> Yes.
06:02:47 <icarot> set closure = homomorphism = endofunctor?
06:02:52 <shachaf> An instance of Monad is a monad in Hask.
06:03:08 <Botje> trapdInIO: if you have more of these structs, it might pay off to write some TH to generate the getter for you.
06:03:14 <shachaf> An instance of MonadTrans isn't a monad in the kleisli category of some Hask monad.
06:03:24 <hseg> So I claim the following. An instance of Monad is a monad in the category Hask.
06:03:40 <hseg> In addition, the monad transformer T it
06:03:45 <Botje> (or even just a small perl script ;))
06:03:52 <icarot> speaking as structure mappings.
06:04:06 <trapdInIO> Botje: or a C library...
06:04:42 <hseg> as applied to some monad M, gives the monad T in the Kleisli category of M. I'm not too sure about this, but it seems correct.
06:05:52 <akamaus> hi!
06:06:03 <akamaus> why this isn't parsed?
06:06:09 <latermuse> found out why my script would run! hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
06:06:10 <akamaus> let f = do {print "aaa"; let a = 2; print "bbb"}
06:06:38 <mauke> akamaus: let triggers layout
06:07:08 <hpaste> anonymous annotated “IO and record syntax” with “IO and record syntax (annotation)” at http://hpaste.org/87267#a87268
06:07:38 <akamaus> mauke, is there any other form to express it as a oneliner?
06:07:43 <akamaus> with do notation
06:07:43 <geekosaur> add braces
06:07:48 <akamaus> ok
06:07:51 <mauke> akamaus: learn about layout
06:07:54 <geekosaur> let { ... }; print ...
06:07:58 <akamaus> thanks :)
06:08:02 <akamaus> I will
06:08:51 <dmwit> akamaus: ...or use let/in instead of let.
06:09:01 <dmwit> let a = 2 in print "bbb"
06:09:14 <dmwit> > do { "aaa"; let a = 2 in "bbb" }
06:09:16 <lambdabot>  Terminated
06:09:24 * dmwit sticks his tongue out at lambdabot
06:09:28 <dmwit> > do { "aaa"; let a = 2 in "bbb" }
06:09:31 <lambdabot>   "bbbbbbbbb"
06:09:37 <mauke> > do { "aaa"; let a = 2 in do "bbb"; [a] }
06:09:38 <lambdabot>   [2,2,2,2,2,2,2,2,2]
06:10:30 <trapdInIO> Thanks to the kind person who annotated my code :)
06:10:31 <dmwit> > do { "aaa"; let a = 2 in [a, a, a]; "b" }
06:10:34 <lambdabot>   "bbbbbbbbb"
06:12:06 <djcoin> > do { "aaa" ; "b" }
06:12:09 <lambdabot>   "b
06:12:18 <ion> wat
06:12:20 <Tanea> pfff
06:12:21 <geekosaur> wat
06:12:21 <dmwit> wat
06:12:28 <Tanea> hahaha
06:12:29 <mauke> >implying
06:13:09 <int-e> > runWriter $ do{ tell "aaa"; let{ a = 2 }; tell "bbb"; return a }
06:13:12 <lambdabot>   (2,"aaabbb")
06:13:14 <dmwit> > do { "aaa" ; "b" } -- glitch in the matrix
06:13:16 <lambdabot>  Terminated
06:13:24 <dmwit> lambdabot--
06:13:36 <djcoin> lol, what did I do
06:13:48 <dmwit> You exercised some race condition somewhere, probably.
06:14:13 <djcoin> > do { "aaa" ; "b" }
06:14:16 <lambdabot>   "bbb"
06:14:37 <mauke> well, it is the nondeterminism monad
06:15:28 <latermuse> how does this kind of thing even work?  do {"aaa";"b"}
06:15:29 <djcoin> scary !
06:15:31 <djcoin> :)
06:15:34 <plhk> trapdInIO: you can try this: http://hackage.haskell.org/packages/archive/binary/0.7.1.0/doc/html/Data-Binary.html#g:3
06:15:40 <mauke> @undo do {"aaa";"b"}
06:15:41 <lambdabot> "aaa" >> "b"
06:15:46 <Tanea> It annoys me that Writer is backwards
06:15:46 <dmwit> latermuse: concatMap (\_ -> "b") "aaa"
06:15:48 <mauke> @src [] (>>)
06:15:48 <lambdabot> xs >> ys      = concatMap (const ys) xs
06:16:12 <latermuse> weird!
06:16:22 <trapdInIO> plhk: Thanks. I am looking into it
06:19:09 <trapdInIO> I was not asking programming questions for years, looking for solutions by myself but haskell is ... challenging some times
06:19:54 <geekosaur> stretch your mind, it's good for you
06:20:49 <ion> > map (const "b") "aaa"
06:20:53 <lambdabot>   ["b","b","b"]
06:20:55 <djcoin> trapdInIO: yep - i'm far from being an expert - but roughly, the list monad is a bit special, it call function bound to it for each element of list
06:20:59 <ion> > concat ["b","b","b"]
06:21:02 <lambdabot>   "bbb"
06:21:28 <dmwit> s/is a bit special, it/
06:21:52 <ion> s/bound to it //
06:22:04 <djcoin> yeah my english is not really correct,  sorry
06:22:16 <djcoin> (and my haskell skills too :))
06:22:22 <trapdInIO> :)
06:22:24 <mauke> s/english/mental model/
06:22:27 <dmwit> I don't mind bad English. But the list monad doesn't really have a special status in Haskell.
06:22:29 <geekosaur> people look at monads and think of the sewer that is IO, but it's the list monad that is seriously brain twisting
06:23:00 * geekosaur is for the moment ignoring the *real* brain twister, the mother of all monads
06:23:13 <dmwit> ContT RWS?
06:23:18 <mauke> Cont
06:23:34 <shachaf> Codensity
06:23:34 <dmwit> mauke: Yeah, I know. Just failing at being snarky.
06:23:46 <mauke> Contdensity
06:23:50 <shachaf> Codensity > Cont hth
06:24:56 <dmwit> Are there any exercise akin to You Could Have Invented Monads guiding you to invent Cont?
06:26:01 <haasn> You Could Have Written Confusing Code
06:26:06 <Peaker> > let (==>) = M.singleton in   mconcat [1 ==> 2, 3 ==> 4]   !  3
06:26:07 <geekosaur> :)
06:26:08 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i0 e0'
06:26:08 <lambdabot>              with actual...
06:26:16 <Peaker> > let (==>) = M.singleton in   mconcat [1 ==> 2, 3 ==> 4]   M.!  3
06:26:17 <lambdabot>   4
06:26:44 <haasn> Peaker: neat little trick
06:26:46 <Peaker> Maybe with the new overloaded lists extension, it'll be possible to avoid the "mconcat" too
06:26:57 <haasn> new overloaded lists extension?
06:27:03 <mauke> let (~>) = (,)
06:27:11 <notdan_> @ty M.singleton
06:27:14 <lambdabot> k -> a -> M.Map k a
06:27:28 <dmwit> mauke++ especially because it's useful for a bunch of other stuff, too
06:27:32 <Peaker> mauke, it's nice to be able to throw maps there though
06:27:49 <haasn> > M.fromList [1 ~> 2, 3 ~> 4] M.! 3
06:27:49 <Araneidae> How do I report an encoding error in the Data.Binary.Get monad?  I'll have a UnicodeException in hand...
06:27:50 <lambdabot>   Not in scope: `~>'
06:27:50 <lambdabot>  Perhaps you meant one of these:
06:27:51 <lambdabot>    `>' (imported from D...
06:27:58 <haasn> oh
06:28:02 <haasn> I thought mauke did @let
06:28:13 <dmwit> > let (-->) = (,) in M.fromList [1 --> 2, 3 --> 4] M.! 3
06:28:15 <lambdabot>   4
06:28:19 <haasn> > let (~>) = (,) in M.fromList [1 ~> 2, 3 ~> 4] ^? at 3
06:28:21 <lambdabot>   Just (Just 4)
06:28:26 <haasn> oh
06:28:29 <haasn> > let (~>) = (,) in M.fromList [1 ~> 2, 3 ~> 4] ^? ix 3
06:28:31 <lambdabot>   Just 4
06:28:39 <notdan_> @ty at
06:28:41 <lambdabot> (Functor f, Indexable (Index m) p, At m) => Index m -> p (Maybe (IxValue m)) (f (Maybe (IxValue m))) -> m -> f m
06:29:14 <FireFly> aka "lens stuff"
06:29:25 <notdan_> hah :)
06:35:05 <Peaker> We need all the lens stuff in @src
06:35:20 <Tanea> @help src
06:35:20 <lambdabot> src <id>. Display the implementation of a standard function
06:35:23 <mauke> PJBoy: I haven't whois'd you
06:35:26 <Tanea> @list src
06:35:26 <lambdabot> source provides: src
06:35:29 <Tanea> :(
06:35:41 <PJBoy> mauke, why would you have?
06:35:45 <ion> Me neither.
06:35:53 <mauke> PJBoy: exactly
06:35:57 <Araneidae> Is `fail` the only way to inject an error report into the Data.Binary.Get monad?  Seems a bit weak to me ...
06:36:24 <PJBoy> ah, you've seen my witty whois comment
06:36:41 <mauke> it's not a "whois comment", it's the "real name" field
06:36:57 <PJBoy> eh, what's the difference
06:37:19 <PJBoy> who wants to reveal their real name online these days
06:37:24 * ion
06:37:25 <PJBoy> 'cept for social networking
06:37:58 * dmwit  
06:38:27 <dmwit> Araneidae: Why is that weak?
06:38:28 <Tanea>  @src filtered
06:38:35 <Tanea>  <lambdabot> filtered p = dimap (\x -> if p x then Right x else Left x) (either pure id) . right'
06:38:38 <dmwit> Isn't that what fail is for?
06:39:10 <Araneidae> I'd probably like to return a rather more structured failure ...
06:39:29 <Tanea> lens being in @src would not help much
06:39:41 <dmwit> Araneidae: Use ErrorT or similar, then?
06:40:09 <Araneidae> Yes, possibly.  I'll go with fail for now
06:41:52 <chrisyoung> Has anyone else attempted to install lambdabot (ghc 7.4.2) on OS X?
06:42:04 <chrisyoung> I get an exit failure when it tries to install readline
06:42:19 <shachaf> Sounds right.
06:42:23 <geekosaur> chrisyoung, you need to install a real readline
06:42:31 <geekosaur> apple's "readline" isn't
06:42:38 <chrisyoung> Ah, I see.
06:42:42 <chrisyoung> Recommendations?
06:43:22 <haasn> linux?
06:43:33 <chrisyoung> Ha ha
06:43:42 <chrisyoung> I'm starting to think so
06:43:44 <geekosaur> most people use macports/fink/homebrew to install stuff on os x
06:44:02 <chrisyoung> Will brew install readline get me a real readline?
06:44:17 <geekosaur> yes
06:44:58 <chrisyoung> Ah, many thanks. I'll give that a try.
06:45:35 <chrisyoung> readline-6.2.4 already installed
06:45:50 <chrisyoung> So I have readline. Perhaps I need a modern version?
06:46:45 <deech> Hi all, some of you may have seen: http://parleys.com/play/51704efce4b095cc56d8d4b5/about. Odersky states at 29:25 that large Haskell codebases would be difficult/impossible to deal with because it lacks a good module system, and OO is strictly better than modules for code organization.
06:46:59 <geekosaur> more likely you need to make sure it looks under /usr/local for readline
06:47:08 <chrisyoung> I see.
06:47:30 <deech> So my question is: are there large Haskell codebases (~ 1,000,000 lines) and how do they deal with it.
06:47:39 <chrisyoung> 'which readline' gives me nothing. Hmmm, I guess brew didn't link properly?
06:47:48 <geekosaur> if you're using the official HP package instead of one built via homebrew, it probably isn't looking under /usr/local
06:47:51 <geekosaur> readline is not a program
06:47:56 <geekosaur> it's a library
06:48:06 <chrisyoung> Whoops.
06:48:50 <chrisyoung> I am using the official HP package. How do I fiddle with where it looks for stuff?
06:50:45 <mm_freak> deech: GHC's code base is in the upper half of 1M code lines according to my last measurement
06:50:52 <mm_freak> something like 800k lines
06:51:19 <deech> mm_freak: And is it considered well-organized?
06:51:42 <mm_freak> well, judge yourself:  you get new extensions and improvements all the time
06:52:16 <mm_freak> deech: but to answer your question, it's unlikely that you see such large code bases, because haskell projects tend to get packagized
06:52:35 <geekosaur> chrisyoung, by far the easiest way is to remove the package (uninstall-hs, I think) and 'brew install haskell-platform'
06:53:16 <mm_freak> if you were to count the number of lines including all the referenced haskell libraries you would probably easily get at least a 6-digit number of lines
06:54:06 <chrisyoung> Cool. OK, I'll try that. Thanks for the help.
06:54:06 <Chousuke> I'm not sure about code organization, but as far as modularity and code reuse goes, Haskell is top tier
06:55:04 <deech> mm_freak: That makes sense. Odersky also implies that million line codebases are inevitable and that something that big requires a good object system.
06:55:15 <mm_freak> deech: that's nonsense
06:55:29 <Chousuke> a well-organized set of modules isn't going to help you much if they're all interdependent
06:55:45 <mm_freak> deech: claims like that are often made by people who don't understand haskell and the way we write code
06:56:42 <mm_freak> Chousuke: luckily you can't have that easily in haskell
06:56:47 <mm_freak> nobody likes to write boot files =)
06:57:17 <Chousuke> mm_freak: yeah, that was sort of my point :)
07:03:07 <Chousuke> I'm having a hard time imagining a Haskell project that has a million lines of code though :/
07:04:10 <mm_freak> Chousuke: because nobody would do that
07:04:46 <Tanea> What Haskell is really good at is little pieces that fit together
07:04:46 <Chousuke> even counting all the librarified dependencies that is
07:04:54 <mm_freak> haskell code is generally shorter anyway…  a page of java hardly means anything, while a page of haskell can easily be an entire server program
07:07:29 <liyang> Corollary: the same number of lines of Haskell takes longer to read/understand than Java.
07:07:44 <parcs> it can also easily be the list of imported modules and enabled language extensions
07:07:47 <Chousuke> liyang: that's actually not always true
07:07:57 <mm_freak> liyang: i'd go further to say that it's never true
07:08:20 <Boreeas> It really depends on what language one knows better
07:08:23 <mm_freak> parcs: that's one of the main reasons a haskell code base is unlikely to pass 1M lines
07:08:33 <Chousuke> liyang: mostly because with java you have to be aware of all the implicit assumptions that the code makes
07:08:46 <trapdInIO> liyang: in java everything happens elsewhere
07:09:05 <mm_freak> @remember trapdInIO in java everything happens elsewhere
07:09:05 <lambdabot> It is forever etched in my memory.
07:09:10 <Chousuke> haskell code is abstract, but it's (nearly) always explicit
07:09:21 <liyang> Chousuke: depends on who wrote it.
07:09:35 <mm_freak> liyang: not really…  it only depends on whether they used unsafePerformIO
07:09:44 <ab9rf> mm_freak: and yet java is terse compared to cobol :)
07:09:45 <dmwit> There's a famous study that showed that the number of bugs scaled with the number of lines and was independent of implementation language.
07:09:47 <Chousuke> well, if all your code is
07:09:53 <Chousuke> er
07:10:04 <Chousuke> if all your code is IO whatever then of course it will have the same problems
07:10:12 <ab9rf> dmwit: that makes sense from a psychological perspective
07:11:47 <mm_freak> dmwit: i can agree with that, but linear proportionality always has a constant factor
07:11:51 <Okasu> http://vpaste.net/HKrmr cpp vs haskell http://vpaste.net/7lkAA
07:11:51 <mm_freak> and that factor depends on the language
07:11:59 <Okasu> Not sure which is worse.
07:12:10 <dmwit> mm_freak: 1. I didn't say linear 2. the scaling was independent of language.
07:12:28 <dmwit> independent means independent, not dependent =P
07:12:38 <Okasu> But cpp version at least not ehaust all memory in one minute.
07:13:04 <mm_freak> dmwit: you said that the number of bugs scales with the number of lines
07:13:09 <dmwit> yes
07:13:16 <mm_freak> numBugs = c*numLines
07:13:18 <dmwit> no
07:13:27 <mm_freak> yeah, i'm assuming linearity
07:13:33 <mm_freak> numBugs = f(numLines)
07:13:34 <mm_freak> better?
07:13:37 <dmwit> yes
07:13:40 <mauke> f = const 42
07:13:46 <mm_freak> ok, then f depends on the language
07:13:46 <dmwit> Note that f does not take language as an input.
07:13:49 <dmwit> No.
07:13:53 <dmwit> That was the whole point of the study.
07:14:08 <ab9rf> Okasu: if your haskell code exhausts all memory in under a minute, it's probably badly written
07:14:15 <parcs> hmmmm
07:14:21 <Okasu> ab9rf: Please, teach me.
07:14:31 <Okasu> Lol.
07:14:32 <mm_freak> dmwit: the interpretation being that 1000 lines of haskell have on average the same number of bugs as 1000 lines of C?
07:14:50 <dmwit> mm_freak: correct
07:14:55 <mm_freak> do you agree with that?
07:15:03 * hackagebot assert 0.0.1.0 - Helpers for Control.Exception.assert  http://hackage.haskell.org/package/assert-0.0.1.0 (LiyangHu)
07:15:05 <dmwit> I have no reason to believe the study lied.
07:15:06 <Okasu> It's more liekly haskell binding to cpp library heas a leaks.
07:15:12 <dmwit> s/the study/the report about the study/
07:15:22 <typoclass> mm_freak: i think the idea is that 1000 lines of haskell do as much as 5000 lines of c
07:15:25 <Philonous> What does it mean to say that Haskell "has no built-in support for state and mutation"?
07:15:28 <ab9rf> Okasu: yeah, there's unsafe ops in here
07:15:34 <mm_freak> typoclass: i get that, but even then i don't agree
07:15:41 <ab9rf> Okasu: it's likely that lazines is biting you somewhere
07:15:50 <mm_freak> i easily have 1000 lines codebases in haskell that contain far less bugs than 10 lines of PHP
07:15:54 <Tanea> Philonous: it means you're a liar
07:16:07 <Philonous> Tanea:  I'm not the one claiming this
07:16:22 <Philonous> Tanea:  Rather, I was puzzled by the statement.
07:16:26 <Okasu> ab9rf: Yeah, but not sure, i've already asked question here about that code long time ago but never got an answer.
07:16:33 <ab9rf> mm_freak: 0 lines of PHP probably has more bugs than the entire corpus of haskell code, beause of all the bugs in the PHP interpreter
07:16:39 <Tanea> Philonous: hence my (somewhat rude, I apologise) reaction
07:16:48 <Okasu> Good answer*
07:16:48 <int-e> Philonous: it's a way of framing purity as a bad thing
07:16:58 <mm_freak> ab9rf: yeah
07:17:01 <ab9rf> Okasu: you've got a marked unsafe function in there, i'm not going to try to go past that
07:17:11 <Philonous> int-e:  I'm trying to figure our in what sense this is true.
07:17:15 <klrr> i use case a LOT, is it good or is it better to use If-else expressions?
07:17:27 <dmwit> klrr: case is good style
07:17:28 <ab9rf> klrr: if is just sugar for case
07:17:31 <typoclass> Philonous: i think they mistook "by default no mutation" as "mutation not supported"
07:17:43 <Tanea> klrr: they compile down to the same thing, so whichever looks cleaner
07:17:44 <typoclass> (they = whoever wrote the quote)
07:18:13 <dmwit> I'm a bit concerned that ab9rf and Tanea are simplifying things.
07:18:14 <klrr> okey good :)
07:18:19 <dmwit> if and case are interchangeable only on Bool.
07:18:30 <dmwit> Using "if" as a replacement for "case" on other types is unwieldy and bad style.
07:18:30 <ab9rf> dmwit: bah
07:18:35 <int-e> Philonous: if you ignore ST and IO (you can call them "just hacks") if you want to go that route, then all data is immutable; if you furthermore postulate that state is inherently mutable, then haskell doesn't have support for that either.
07:18:36 <Philonous> So, it's fair to say this is an unreasonable statement. I didn't muss anything.
07:18:39 <Primoz128> Guys can someone help me out with Leksah and it's building of executobles ? Im not sure which fodler contains the true EXE....
07:18:50 <Philonous> miss*
07:18:52 <Tanea> dmwit: I completely forgot you can do that
07:18:52 <ab9rf> i had someone tell me that haskell has "half-implemented half-assed OO"
07:18:54 <int-e> Philonous: (hopefully) obviously I disagree :)
07:18:59 <dmwit> It is a somewhat common beginner mistake to write things like "if isJust x then ... else ..." instead of using a more straightforward case.
07:19:01 <Okasu> ab9rf: Sure, but it's just the way CV lib works, unsafe everywhere.
07:19:22 <ab9rf> Okasu: mmm
07:20:29 <Primoz128> Im being ignored bohohoho
07:20:42 <Philonous> int-e:  I'm talking about http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html btw.
07:20:54 <Okasu> localhost: curl -s "http://hackage.haskell.org/packages/archive/CV/0.3.7/doc/html/src/CV-Image.html"|grep unsafe|wc -l
07:20:57 <Okasu> 45
07:20:58 <dmwit> Primoz128: If somebody knows, they'll answer. Everybody else won't. You're not being ignored.
07:20:59 <Philonous> int-e:  The first sentence irked me.
07:21:05 <Okasu> ab9rf: Enjoy.
07:21:13 <ab9rf> Okasu: i'd bee leery of a binding that has that many unsafe calls
07:21:14 <hamishmack> Primoz128: Leksah builds with "cabal build" and installs with "cabal copy" and "cabal register"
07:21:24 <dmwit> ab9rf: What do you think "unsafe" means?
07:21:37 <Okasu> ab9rf: Too bad there is no other option.
07:21:39 <ab9rf> dmwit: it dpeends on who wrote the binding
07:21:40 <Primoz128> i got 3 folders after i build
07:21:41 <int-e> Philonous: it's more that Haskell forces you to be honest about mutation and stateful computations.
07:21:50 <Okasu> Good option*
07:21:55 <dmwit> ab9rf: eh?
07:22:05 <dmwit> ...oh, there's a function with "unsafe" at the beginning of its name.
07:22:05 <Primoz128> autoget, Package and test-Package
07:22:12 <Primoz128> which one is the coorect one ?
07:22:13 <dmwit> ab9rf: I thought you were talking about unsafe imports.
07:22:15 <ab9rf> dmwit: lots of them, in fact
07:22:15 <int-e> Philonous: but that's easily misunderstood; that's how I would like to read the first sentence (I don't want to read the rest right now)
07:22:18 <dmwit> ab9rf: never mind
07:22:31 <int-e> Philonous: so I won't speculate what the author really meant.
07:22:55 <typoclass> Philonous: i think he has misphrased this. it's expressed awkwardly. i don't think the author is substantially confused about haskell; gabriel has enough packages on hackage
07:23:00 <parcs> i wonder what native support for state and mutation actually entails
07:23:00 <ab9rf> dmwit: i refuse to NEVER MIND!
07:23:09 <Primoz128> Hello ?
07:23:15 <ab9rf> parcs: "being able to write code the way i always have in C"
07:23:15 <Okasu> Primoz128: Hi.
07:23:36 <typoclass> Primoz128: yes hello. most people here are linux users
07:23:53 <Philonous> typoclass:  Tekmo surely knows what he's talking about, I'm not doubting that. That's why I'd rather ask than dismiss what he wrote as an error..
07:23:56 <parcs> dunno about that. i would think most are mac users
07:24:00 <Primoz128> i think Package is correct, im windows users
07:24:09 <Primoz128> user *
07:24:22 <ab9rf> Primoz128: i use the haskell platform in windows
07:24:43 <Primoz128> What is that supposed to mean ?
07:24:50 <dmwit> ab9rf: Yeah, what is that supposed to mean?
07:25:06 <ab9rf> dmwit: i don't know, what are yuo talking about?
07:25:23 <dmwit> Primoz128 is talking about how to use Leksah correctly.
07:25:30 <ab9rf> ah, i was confused
07:25:33 <mm_freak> Philonous: what's this about?
07:25:34 <ab9rf> please disregard
07:25:42 <tem_> How to insert nodes in Data.Tree?
07:26:05 <Primoz128> will i never need to use main.hs file when programnig ?
07:26:08 <tem_> there is no insert method in Data.Tree !
07:26:23 <dmwit> tem_: The question is ill-formed. You just make a new tree with the node in!
07:27:21 <tem_> dmwit:: ok, I want to create a object of type Data.Tree and then insert some data into it BUT there is no insert method in Data.Tree
07:27:46 <dmwit> You just build the tree out of your data right from the get-go. No need to build one and then insert.
07:27:54 <dmwit> This is the Functional Programming Way.
07:27:59 <hamishmack> Primoz128: I think you are looking in the "dist" folder which is where "cabal build" does it's thing
07:28:09 <Primoz128> ye i found
07:28:17 <ab9rf> you don't insert, you make a new tree
07:28:21 <Primoz128> i wana know where do i put my codes
07:28:28 <parcs> tem_: Data.Tree is a rose tree. are you sure that's what you want
07:28:29 <Primoz128> i got main.hs opened too...
07:28:49 <typoclass> tem_: i think you're looking for the unfoldTree function, but i'm not sure how Data.Tree works
07:28:50 <tem_> parcs: yes, that's what I want
07:29:13 <hamishmack> Primoz128: normally you would put them in a src subdirectory
07:29:34 <dmwit> tem_: Can you give us a sample input and sample output that you'd like to code up?
07:29:44 <Chousuke> I suppose it's sort of correct to say that haskell has no support for mutation in the language (excepting things that break the type-system), but you can still do side-effecting things by representing them as values and having the runtime treat those values specially.
07:29:57 <hamishmack> Primoz128: In Leksah you should be able to do File -> New Module or right click in the Module browser and select Add Module
07:29:57 <mauke> C has no support for I/O
07:30:07 <typoclass> dmwit: by building the tree from the get-go, you mean using the Node constructor?
07:30:45 <Primoz128> how must a module be named ?
07:30:58 <liyang> Technically unsafePerformIO is part of the Haskell language.
07:30:59 <dmwit> typoclass: for example
07:31:11 <typoclass> Primoz128: it must start with a captical letter ("Main", "Foo", ...)
07:31:24 <dmwit> Primoz128: GHC will look in a file named Foo/Bar/Baz.hs for the module named Foo.Bar.Baz
07:31:31 <parcs> Chousuke: i don't think the distinction is meaningful tbh
07:31:48 <Primoz128> These modules are files of code that get put into the main.hs ?
07:31:52 <Chousuke> parcs: well, in practice I guess it isn't.
07:32:46 <parcs> Chousuke: http://conal.net/blog/posts/the-c-language-is-purely-functional
07:33:15 <geekosaur> Primoz128, you sound like you might need to go through LYAH first...
07:33:18 <geekosaur> @where lyah
07:33:18 <lambdabot> http://www.learnyouahaskell.com/
07:33:27 <liyang> (Every language is purely functional. It's what you do with it that's sinful.)
07:34:10 <Primoz128> im annoyed by the amount of stuff it wants it to teach me, which i don't need at all atm, i just wana make some small program
07:34:53 <typoclass> Primoz128: have you tried ghci? it lets you evalutate one-liners directly
07:35:04 <Primoz128> ye i got it open
07:35:04 <dmwit> You should not need to deal with the module system to write a small program.
07:35:12 <Primoz128> im messing out a bit
07:35:17 <dmwit> (other than importing modules already defined by a library)
07:35:41 <typoclass> Primoz128: also, you can write some code into a file and then do "runhaskell somefile.hs"
07:36:03 <Primoz128> ok
07:36:53 <shachaf> liyang: Which Haskell language?
07:37:05 <tem_> dmwit: how do I populate the object of type Data.Tree with a list of my own elements?
07:38:03 <dmwit> > [Node 3 [], Node 4 [], Node 5 []]
07:38:05 <dncr> How do I figure out why anything using Sound.Portaudio will segfault if I "ghc --make" it but work fine if I "runghc" it?  Even the examples included with the Haskell Portaudio bindings.
07:38:05 <lambdabot>   [Node {rootLabel = 3, subForest = []},Node {rootLabel = 4, subForest = []},...
07:38:16 <dmwit> There's a forest containing 3, 4, and 5.
07:38:26 <dmwit> > map (\x -> Node x []) [3, 4, 5] -- another spelling
07:38:28 <lambdabot>   [Node {rootLabel = 3, subForest = []},Node {rootLabel = 4, subForest = []},...
07:38:30 <klrr> IO is a pain in the ass xD
07:38:44 <klrr> why cant i use a IO function inside a IO function ? xd
07:38:55 <dmwit> klrr: You can. You're just doing it wrong.
07:38:55 <typoclass> dncr: how bizarre
07:39:09 <dncr> typoclass: indeed
07:39:30 <dmwit> dncr: Perhaps runghc uses the threaded runtime and ghc --make uses the non-threaded one.
07:39:33 <Botje> klrr: you're not allowed to use an IO action in place of a regular value.
07:39:37 <typoclass> klrr: you might be looking for 'join'. otherwise, please put some code on hpaste.org :-)
07:39:45 <liyang> shachaf: the one in your head!
07:39:56 <shachaf> liyang: My head doesn't support unsafePerformIO. Sorry.
07:40:21 <geekosaur> dncr: that sounds like thread issues, yeh. see -threaded and sandboxing.
07:40:33 <Philonous> dncr:  Have you tried building with --threaded ?
07:40:34 <liyang> shachaf: So it's pure...
07:40:44 <dmwit> (just -threaded, not --threaded)
07:41:00 <hamishmack> dmwit: I pushed some fixes for compiling Gtk2Hs with GHC HEAD to https://patch-tag.com/r/hamish/gtk2hs
07:41:06 <shachaf> liyang: Not necessarily.
07:41:11 <klrr> dmwit:  Botje typoclass thanks, but im done with haskell today, my dev process is basically "write ten lines, try solving error for an hour, write ten lines, try solving errors for an hour"
07:41:40 <Botje> klrr: thinking before writing usually reduces the solving errors part enormously.
07:41:40 <dmwit> parcs: I find conal's exposition a bit disappointing, because C's ADT doesn't exist at runtime and can't be manipulated at runtime, but Haskell's can.
07:41:49 <dncr> Philonous: actually -threaded, i did try that :(
07:41:54 <dmwit> hamishmack: I'll take a look, thanks!
07:42:00 <mm_freak> klrr: as long as the errors are type errors… =)
07:42:00 <typoclass> klrr: yeah, that's largely how it works :-/ at least at first. you could maybe make more use of hpaste.org and then asking in here
07:42:14 <Botje> every time ghc tells you "expected type Something actual type IO Something", you are passing in an io action instead of a value
07:42:17 <Philonous> dncr:  Err, right.
07:42:35 <dmwit> hamishmack: (P.S. would you like to take over maintainership of gtk2hs =P)
07:42:43 <klrr> yeah but im done for it today :P and now i have like 10 errors so it'll take 2 hours even if i get help, bb later or tommorow :)
07:42:50 <Botje> and every time tells you "expected type Something actual type SomethingElse -> Something" you passed too few arguments to a function
07:42:53 <liyang> shachaf: do I want to know what goes on inside it?
07:43:48 <typoclass> klrr: ok fair enough. keep at it, it'll get easier over time :-) don't get frustrated
07:45:29 <dmwit> Perhaps that is the way to sell things.
07:45:37 <dmwit> Not "Haskell is pure" but "IO is first-class".
07:45:49 <hamishmack> dmwit: Not sure I have time for that.  Perhaps I could do GtkSourceView and WebKit?
07:46:31 <dmwit> hamishmack: Sure, no pressure. I'll see if we can get you set up for the keys to sourceview and webkit repositories.
07:46:56 <typoclass> dmwit: oooh, nice writing. impressive
07:47:27 <Philippa> dmwit: "first-class and exposed to the type system", perhaps? But yeah
07:48:28 <ijp> dmwit: that's IMO a more honest way of putting it
07:48:57 <jmcarthur> "effects are first class"
07:49:03 <Tanea> Best way to decompress a .tar.gz into a temp folder in a Haskell program?
07:49:13 <jmcarthur> it's really just a different way of looking at "code is data"
07:49:40 <Philippa> one that doesn't conflate as much as lisp encourages you to, you mean? :-)
07:49:54 <tem_> I cannot get how to create a rose tree from a list by using a method from Data.Tree.
07:50:05 <jmcarthur> Philippa: right
07:50:05 <typoclass> Tanea: «system "tar xf abc.tar.gz"»?
07:50:14 <Philippa> (the way things were done in early lisp systems spread a worrying number of misconceptions about functional programming)
07:50:24 <shachaf> tem_: Don't use a method. Use a function. hth
07:50:35 <ijp> Philippa: if you specify really early, then they didn't even get functions right
07:50:36 <jmcarthur> it's "code is data" without actually breaking abstractions
07:50:40 <dmwit> tem_: We're still waiting on a sample input and output here. =)
07:50:42 <Tanea> typoclass: the .tar.gz only exists as a ByteString
07:51:04 <dmwit> tem_: I gave a short program earlier for a guess at what a sample input and output might be, but it was just a guess.
07:51:06 <shachaf> jmcarthur: It's more "data is code" than "code is data".
07:51:07 <liyang> Oh... do we have a tar library? :-/
07:51:07 <ijp> it's 2013, and the way languages carry on you'd think scoping was hard
07:51:24 <geekosaur> it is hard in some languages...
07:51:25 <typoclass> tem_: have you seen the examples that dmwit gave to lambdabot about 15 mins ago?
07:51:35 <liyang> Tanea: you can popen "tar" (or however that's done) and feed it the ByteString.
07:52:13 <liyang> shachaf: is "is" symmetric?
07:52:26 <dmwit> ?hackage tar -- yes, we have a tar library
07:52:26 <lambdabot> http://hackage.haskell.org/package/tar -- yes, we have a tar library
07:52:27 <shachaf> "is" is symmetric, but symmetric is not "is"
07:52:40 <dmwit> ?hackage zlib -- and this one
07:52:40 <lambdabot> http://hackage.haskell.org/package/zlib -- and this one
07:52:48 <liyang> shachaf: *splodes*
07:53:11 <dmwit> What if I told you "A is not B" is not "not (A is b)"?
07:53:37 <shachaf> "A is not B" is "not (not (A is B))"?
07:53:42 <shachaf> That's certainly not right.
07:53:57 <mandu> some questions about functors: i've learned that functor is a mapping between categories..for example fmap for lists is just a map function. Is every functor in haskell implicitly defined some base category? and what that category is? I mean, if functor is mapping from cat(a) -> cat(b), what is cat(a)?
07:54:03 <dmwit> "is" and "is not" are just two relations with no particular relationship between them
07:54:07 <typoclass> Tanea: (just checking) are you downloading gz-compressed stuff from http? maybe your http library supports decompressing that automatically, after some configuring
07:54:26 <dmwit> mandu: The category is Hask; its objects are Haskell types and its arrows are Haskell functions.
07:54:29 <Philippa> ijp: Oh, I've implemented a lisp per the original paper. Once you accept it's only 'inspired' by the lambda calculus the value of 'right' shifts a little, though - "less useful", perhaps
07:54:32 <shachaf> mandu: Every functor in Haskell is an "endofunctor", i.e. from a category to itself. The category is the one where objects are Haskell types and arrows are Haskell functions.
07:54:38 <Tanea> typoclass: oh, huh, it does
07:55:22 <typoclass> Tanea: very good. my mind-reading powers are strong today :-)
07:55:23 <dmwit> mandu: The functor is mapping from Hask to Hask (so I think your question may be a bit wrong: we're not mapping from "cat(a)" to "cat(b)" unless "cat" is a particularly stupid function).
07:56:29 <Tanea> Okay, so now I have a lazy bytestring that somehow represents a file system
07:56:40 <Tanea> Or part thereof
07:56:50 <Tanea> It represents a folder with some files and other folders in it
07:56:55 <Tanea> How do I traverse around these?
07:57:03 <dmwit> ?hackage tar -- did you miss this suggestion?
07:57:03 <lambdabot> http://hackage.haskell.org/package/tar -- did you miss this suggestion?
07:57:27 <typoclass> Tanea: you mean, like a "directory listing" html page that apache generated?
07:57:48 <Tanea> typoclass: really I just want to do a line-count on all the files in the archive
07:58:07 <dmwit> Maybe you should use shell instead of Haskell.
07:58:17 <typoclass> Tanea: example -- http://hackage.haskell.org/packages/archive/newtype/0.2/ suppose the web server sends this page gz-compressed
07:58:39 <typoclass> Tanea: is that what you're dealing with?
07:58:40 <Tanea> dmwit: I don't know shell, and I want to practise Haskell
07:58:48 <Tanea> typoclass: no, I'm downloading a .tar.gz file
07:59:11 <Tanea> But network-conduit does have the option of decompressing even them
07:59:32 <Chousuke> klrr: I
07:59:35 <deech> Is it still impossible to generate modules in TH?
07:59:47 <Chousuke> klrr: I've found that once you solve all those errors your program actually works, though :P
08:00:17 <tem_> typoclass: yes, but still I cannot get how is it a general tree? what is the root of that tree? which are the children? and how the method decided which one to make a child of which other node?
08:01:34 <dmwit> tem_: The root of the tree is the label on the Node. The children are the trees in the subForest of the Node. There is no logic in the library itself; all decisions are up to the programmer.
08:02:04 <dmwit> As for "how is it a general tree?", well, how is it not? =)
08:02:57 <klrr> Chousuke: hehe that's good :) im trying to use ErrorT and now i get strange errors from all functions inside a function that returns it
08:03:15 <tem_> dmwit: Ok, suppose this is a tree i want to make [1 [2 [5[10,11],6[],7[]],3 [8[],9[]],4[]], How do i use the Data.Tree for this?
08:03:25 <typoclass> Tanea: hm ... does network-conduit do that? fundamentally there's a difference between downloading tar.gz files (use the packages dmwit suggested, or try using the 'system' function to run "tar xf"), and downloading a gz-compressed web page (probably your http library can be made to automatically decompress the html page/other content)
08:03:55 <Tanea> typoclass: by default, network-conduit doesn't decrypt things with the mime type application/x-tar
08:04:11 <Chousuke> klrr: you probably need some lifts :P
08:04:22 <typoclass> Tanea: you mean http-conduit? i can't find things like that in network-conduit
08:04:28 <Tanea> Yes, sorry
08:04:30 <Tanea> http-conduit
08:04:36 <typoclass> Tanea: no problem :)
08:05:13 <dmwit> tem_: Almost exactly like what you wrote, but with "Node" stuck in: [Node 1 [Node 2 [Node 5 [Node 10 [], Node 11 []], Node 6 [], Node 7 []], Node 3 [...
08:05:33 <tem_> Well, then if "all decisions are up to the programmer." then what the library is doing at all (apart from drawTree and drawForest) ?
08:05:56 <klrr> Chousuke: yeah, im using my own lift, but what does liftIO, does it makes IO not IO or a not IO an IO?
08:06:10 <dmwit> Well, there are Monad, Functor, Typeable1, Applicative, Foldable, Traversable, Eq, Read, Show, and NFData instances.
08:06:24 <typoclass> tem_: i don't know Data.Tree, but it looks to me like it's really a minimal definition of a tree type, with not many utility functions :-(
08:06:46 <dmwit> I feel like Monad, Foldable, and Traversable hardly qualifies as "not many utility functions".
08:06:57 <Tanea> typoclass: what utility function would you add?
08:07:54 <typoclass> Tanea: tem_ was asking for an insert function of some sort
08:08:00 <Chousuke> klrr: liftIO lifts IO actions to match the monad formed by your transformer stack (which must be based on IO) regardless of how many transformers you have applied
08:08:10 <tem_> "Monad, Foldable, and Traversable" might mean a great deal of functionality , BUT sorry if I cannot do a simple insert into that tree
08:08:15 <dmwit> typoclass: What type would you want insert to have?
08:08:31 <klrr> Chousuke: okey, i get the same errors though :/ let me paste them just a sec
08:08:40 <Tanea> tem_: how would you specify where to insert?
08:08:54 <dmwit> tem_: So far, every challenge you have posed with actual inputs and outputs has been trivial to do with Data.Tree.
08:08:57 <simpson> @unmtl StateT s [] a
08:08:57 <lambdabot> s -> [(a, s)]
08:09:02 <tem_> Tanea: just like a directory path
08:09:20 <simpson> Oh, I get it now.
08:09:24 <dmwit> tem_: You may want a trie rather than a rose tree.
08:09:37 <mm_freak> tem_: you don't "insert" into a tree
08:09:47 <klrr> https://gist.github.com/klrr/5521062 (code and errors in paste) i have some annoying type errors and maybe even other errors, any ideas?
08:09:52 <mm_freak> tem_: you construct a new tree with the value inserted, as has been pointed out to you
08:09:53 <dmwit> tem_: http://new-hackage.haskell.org/packages/find?name=trie
08:09:54 <mandu> dmwit, shachaf thanks, I still have some problems to grasp the idea of one big category instead of multiple smaller ones...At first I thought that I want code my functions in 'base' category (hask) and then use functors to achieve better generalization. But now you said that all functors are endofunctors, so my abstraction level was clearly wrong. :) If every functor is endofunctor, is there other categories in haskell than hask?
08:10:19 <tem_> mm_freak: ok, then what is a counterpart of (:) cons that is there for a list ?
08:10:31 <Tanea> :t Node
08:10:31 <dmwit> mandu: There are, and there are other type classes than Functor for more general functors.
08:10:34 <lambdabot> a -> Forest a -> Tree a
08:10:44 <shachaf> mandu: If you want to learn to program in Haskell, I don't know that all this category theory business will help you that much.
08:10:45 <mm_freak> tem_: depends on the tree…  Node, Branch, …
08:10:50 <Chousuke> klrr: the first one is just you returning a value of the wrong type (IORef Expr' is not Expr)
08:11:07 <Chousuke> oops, extra '
08:11:22 <tem_> mm_freak: yes, but is impossible to give that as a method in the Data.Tree library?
08:11:30 <typoclass> dmwit: i don't know the type :-) all i know is, he wanted some sort of insert for Data.Tree, and Data.Map has one, and [] has one, so superficially question is not that far-fetched
08:11:58 <dmwit> typoclass: He is adamant that he wants a rose tree. But I don't believe him.
08:11:59 <mm_freak> tem_: why would you want that?  (:) is just a constructor as well, just like Node
08:12:30 <dmwit> There's almost nothing you can actually do without specializing your rose tree to some more structured type.
08:12:30 <klrr> Chousuke: true will fix that
08:12:38 <Chousuke> klrr: for the rest of the errors you just need to use lift
08:12:43 <typoclass> tem_: could you give an example call and arguments how this insert function would work?
08:12:49 <mandu> I've already learned the basics, I am just more interested about the theory and comparison against oop...probably I should just code more..
08:12:49 <tem_> mm_freak: I want it precisely because I want to implement a file-system type object with the help of Data.Tree...
08:12:55 <dmwit> typoclass: (I've also asked that precise question several times.)
08:13:02 <mm_freak> tem_: what's wrong with Node?
08:13:16 <mm_freak> tem_: Node is to Tree what (:) is to []
08:13:38 <dmwit> tem_: Data.Tree is the wrong type for your file system. Use a trie instead. See my link above for a bunch of implementations of tries over various key types.
08:13:54 <tem_> typoclass: type of the method would something like insert :: Tree a -> Path a -> Element a -> Tree a
08:14:17 <Chousuke> klrr: eg. lift $ lookupEnv ...
08:14:19 <mm_freak> tem_: you need to write that one yourself, but it's easy…  also you need an Eq constraint
08:14:37 <mm_freak> insertNode :: (Eq a) => Path a -> Element a -> Tree a -> Tree a
08:14:46 <dmwit> I don't believe that's the right type.
08:14:56 <dmwit> Perhaps k -> v -> Tree (k, v) -> Tree (k, v)
08:15:03 <dmwit> But then, *again*, you want a trie.
08:15:05 * hackagebot indexed-free 0.2 - indexed monads for free  http://hackage.haskell.org/package/indexed-free-0.2 (FumiakiKinoshita)
08:15:13 <dmwit> or [k] -> v -> Tree (k, v) -> Tree (k, v), I mean
08:15:22 <mm_freak> i don't know what Path and Element are, so i can't tell
08:16:08 <Chousuke> klrr: if you look at the error messages, you have a type IO whatever, but the expected type is ErrorT Err IO whatever
08:16:13 <tem_> dmwit: you mean a filesystem type of object is better represented by a trie rather than a tree?
08:16:23 <typoclass> tem_: ok fair enough! Element and Path and that sort of thing go beyond the scope of Data.Tree. you need a more powerful package, as dmwit suggested (see http://new-hackage.haskell.org/packages/find?name=trie )
08:16:40 <mm_freak> tem_: yes
08:16:40 <Chousuke> klrr: so you need to lift
08:16:42 <dmwit> tem_: Yes, or just cook up your own type.
08:17:10 <tem_> dmwit: ok, but can I start with Data.Tree for this thing?
08:17:31 <dmwit> You can. But it will not help you very much.
08:17:58 <tem_> dmwit: Ok. and I don't want a trie. Is there any Haskell library for "general tree "?
08:18:03 <geekosaur> tem_, "tree" is a very generic thing. there are lots of different kinds of trees. (Data.Tree is arguably misnamed.) and to confuse things a bit more, most filesystems are actually DAGs, not general trees (which can have loops)
08:18:40 <nicoo> geekosaur: Eh, trees are usually defined as being acyclic
08:18:55 <dmwit> nicoo: Nothing about geekosaur's statement contradicts that.
08:19:09 <nicoo> « not general trees (which can have loops) »
08:19:15 <dmwit> Although the claim that DAGs can have loops is probably wrong. =)
08:19:35 <nicoo> dmwit: Obviously.
08:19:35 <shachaf> dmwit: I think you're grouping it incorrectly.
08:19:39 <dmwit> nicoo: I think "(which can have loops)" was attached to "DAGs", not "general trees".
08:19:51 <nicoo> Ah.
08:19:51 <shachaf> Or not, actually.
08:19:52 <geekosaur> no, it was attached to general trees
08:19:57 <shachaf> OK.
08:20:03 <shachaf> I'm not sure what anyone means anymore.
08:20:05 <geekosaur> the A in DAG is acyclic...
08:20:13 <shachaf> imo filesystems should support hard links of directories and have gc rather than reference counting
08:20:18 <nicoo> geekosaur: I'ld like to see you definition of “general trees” then
08:20:20 <tem_> OK, but is there any Haskell library for "general tree "?
08:20:29 <dmwit> Okay, then I'm with nicoo now. General trees can't have loops. =)
08:20:39 <typoclass> tem_: if you're just starting out with haskell, it might be valuable exercise to write the required tree data type yourself. if you're already competent, you might want to look around on hackage, starting with those trie packages
08:21:47 <dmwit> tem_: Can you explain why you do not wish to use a trie, or what you expect from a "general tree" library that the trie libraries do not have?
08:23:16 <typoclass> tem_: ... in both cases, make sure you're not using the tree just for unnecessary bookkeeping :-) for example, if you're writing an actual filesystem that waits for requests from fuse, and you have whatever functions that produce the contents of those requests, you might plausibly tie the producer directly to the fuse consumer. there might not even be a need to have producers produce a tree, and then pass parts of the tree to the consum
08:23:18 <dmwit> (It is not possible to give good advice with the information you have given us so far.)
08:23:41 <Mortchek> You can actually make a cyclic graph using Data.Tree
08:23:54 <Mortchek> > unfoldTree (\x -> (x, [x, x])) a
08:23:56 <lambdabot>   Node {rootLabel = a, subForest = [Node {rootLabel = a, subForest = [Node {r...
08:24:09 <dmwit> Mortchek: As usual, there's a difference between tree and Tree. =)
08:24:16 <nicoo> Mortchek: Is it cyclic or infinite ?
08:24:17 <dmwit> just like monad and Monad, functor and Functor, etc.
08:24:29 <dmwit> nicoo: The in-memory representation in GHC is cyclic.
08:24:38 <nicoo> Oh, nice.
08:24:48 <Mortchek> Well, you could do both I guess.
08:24:51 <dmwit> Maybe not from Mortchek's sample.
08:24:55 <Mortchek> Yeah, my example maybe not.
08:25:05 <nicoo> GHC is too smart for me. Or I'm too dumb for it.
08:25:10 <dmwit> But you can write let t = Node 3 [t, t] in t and it would be cyclic in-memory.
08:25:30 <Mortchek> > let n = Node a [n, n] in n
08:25:32 <lambdabot>   Node {rootLabel = a, subForest = [Node {rootLabel = a, subForest = [Node {r...
08:25:33 <nicoo> dmwit: With the let, I agree it would be cyclic
08:25:36 <tem_> If those trie packages are implementing this type of tries (http://en.wikipedia.org/wiki/Trie), then I don't want them because my needs are more liek http://en.wikipedia.org/wiki/Rose_Tree
08:25:36 <Mortchek> That one is definitely cyclic.
08:25:58 <dmwit> tem_: That sentence had no content. In what way are your needs more like rose trees?
08:26:55 <tem_> dmwit: is a directory structure on a typical filesystem "more close" to rose tree than to a "trie"?
08:27:10 <dmwit> no
08:27:49 <dmwit> For example: you can't have two different files with the same name. The naive rose-tree encoding of a file-system would allow this with no complaints.
08:27:50 <tem_> I am not interested in hard and/or soft links. just directory as containers of files which are atomic.
08:28:11 <dmwit> Whereas the trie-based encoding would encode that invariant correctly.
08:28:38 <tem_> what about the container relation?
08:28:54 <typoclass> tem_: how do you mean?
08:29:11 <dmwit> What is the container relation?
08:29:23 <tem_> I mean directory contains files and files are atomic w.r.t. the filesystem objects
08:29:34 <tem_> I mean directory contains files and directories and files are atomic w.r.t. the filesystem objects
08:30:24 <tem_> in this way, I can represent directories with internal nodes and files with leaf nodes of a rose tree.
08:30:30 <dmwit> I'm not sure what "atomic w.r.t. the filesystem objects" means, but the whole point of the trie is that it nicely encodes the "directories contain stuff" thing.
08:31:16 <typoclass> tem_: yes, tries have internal nodes and leaf nodes, same as trees
08:31:17 <dmwit> It's true that there is no invariant that directories do not have file contents. This is unfortunate.
08:31:24 <dmwit> But this is not remedied by choosing rose trees instead of tries.
08:32:18 <dmwit> This *is* remedied by cooking up your own type (which I also suggested some time ago, for exactly this reason).
08:32:41 <tem_> but afaik, tries do have a requirement of lexicographical ordering between the elements
08:32:50 <dmwit> typoclass: Really? Most trie implementations I can think of don't have such a distinction.
08:33:49 <simpson> tem_: Only of equality on characters. (Also are you saying that you intend to use file names which aren't strings of characters?)
08:34:02 <typoclass> dmwit: i would like a filesystem like that! /etc/passwd could have file contents, which e.g. root can read, but at the same time it is a directory, containing one file per line with appropriate permissions so that only root and i can write into my own password "file"
08:34:45 <typoclass> dmwit: not sure ...? i thought they had
08:34:51 <dmwit> Using a trie would not restrict your file names to be strings of characters.
08:34:53 <simpson> :t \x -> do { x' <- lines x; x'' <- words x'; return $ read x'' } -- am I making a horrible mistake?
08:34:56 <lambdabot> Read b => String -> [b]
08:35:08 <hpc> a bit, yes
08:35:12 <dmwit> simpson: Yes, because you are not using reads instead of read.
08:35:36 <simpson> Oh?
08:35:56 <dmwit> :t reads
08:35:58 <lambdabot> Read a => ReadS a
08:36:02 <dmwit> urk
08:36:09 <dmwit> type ReadS a = String -> [(a, String)]
08:36:17 <dmwit> > read "3"
08:36:19 <lambdabot>   *Exception: Prelude.read: no parse
08:36:20 <dmwit> > reads "3"
08:36:22 <lambdabot>   []
08:36:34 <quchen> > readMaybe "3"
08:36:36 <lambdabot>   Not in scope: `readMaybe'
08:36:39 <dmwit> > reads "()3"
08:36:40 <quchen> Dammit.
08:36:40 <lambdabot>   [((),"3")]
08:36:46 <dmwit> quchen: I treat readMaybe as a code smell.
08:36:54 <simpson> Ah. This is for a small puzzle solver, and I'm just trying to read in a puzzle or fail.
08:36:58 <quchen> dmwit: I treat read as a code smell.
08:37:00 <dmwit> Maybe is just an inferior []
08:37:11 <dmwit> quchen: Me, too!
08:37:24 <typoclass> dmwit: hm, but does reads ever give a list with more than 1 element?
08:37:37 <dmwit> Not on any of the Prelude types.
08:38:02 <tem_> simpson: ok, and tries are mainly meant for dictionary type (involving typical key-value pairs) lookups; a rose tree is not exactly the same
08:38:03 <quchen> dmwit: When I use reads, I feel the need of looking through the list for the "right" parse. Using readMaybe solves that issue for me.
08:38:29 <typoclass> dmwit: but for lists that can only be length 0 or 1, Maybe isn't inferior :-)
08:38:34 <quchen> dmwit: That may not be a good argument, but I'll use it anyway :>
08:38:56 <simpson> tem_: It's not "meant" for anything. It's a general-purpose tree that is optimized on certain lookups because of its structure.
08:39:20 <typoclass> quchen: what is readMaybe? "case reads ... of [(x,"")] -> Just x ; _ -> Nothing"?
08:39:36 <quchen> typoclass: Pretty much fromList . reads
08:39:42 <quchen> So yes
08:39:43 <klrr> can i get some help with this type error? https://gist.github.com/klrr/5521156 (code and error in paste)
08:40:07 <tem_> simpson: may be and similarly a rose tree? I mean, you cannot substitute a rose tree by a trie in all cases (especially when you are dealing with something like filesystem)
08:40:33 <ski> elliott : Significant Other account ?
08:40:48 <dmwit> StackOverflow
08:40:53 <nicoo> ski: StackOverflow
08:41:02 * nicoo is too slow for dmwit.
08:41:15 <Philippa> ski: or an OSO account, or...
08:41:26 <epta> Or quora account
08:41:39 <simpson> tem_: Hey, if you wanna go use a rose tree right now and experience why it's wrong, then go for it.
08:41:48 <simpson> tem_: AFAICT dmwit's on the money here.
08:43:21 <tem_> simpson: no need to be angry, all I was asking for is there a implementation of general tree library in Haskell...if not, I will get away with whatever half-decent implementation I have had
08:43:30 <quchen> Neat, the new Platform's RC1 is out.
08:43:47 <dmwit> This is beyond frustrating. I give up.
08:43:48 <simpson> tem_: I'm not angry. Data.Tree is a general tree.
08:44:03 <ski> @google OSO account
08:44:04 <lambdabot> http://www.glassdoor.com/Interview/Facebook-Interview-RVW508003.htm
08:44:04 <lambdabot> Title: Facebook Account Manager OSO Interview | Glassdoor
08:44:29 <quchen> dmwit: This may enlighten and or amuse you right now: http://me.veekun.com/blog/2011/04/16/architectural-fallacies/
08:45:13 <Philippa> ski: "Other Significant Other"
08:45:24 <Philippa> (relevant to my life, at least)
08:45:35 <ab9rf> IO -> insignificant other
08:45:40 <ski> ok (haven't heard that one before)
08:46:55 <tem_> may be, but I cannot figure it out how to use it ... and I could not find any examples using Data.Tree where you do some operations like (insert/delete/search) elements from the general tree.
08:47:14 <tem_> may be, but I cannot figure it out how to use Data.Tree ... and I could not find any examples using Data.Tree where you do some operations like (insert/delete/search) elements from the general tree.
08:47:31 <simpson> tem_: Well, write the type that you'd like things to have, and then roll up your sleeves and write some code.
08:48:00 <klrr> can i get some help with this type error? https://gist.github.com/klrr/5521156 (code and error in paste)
08:48:08 <parcs> "Programmers really like carpentry metaphors. We like to think anything we do is anywhere near as important as building houses. Ha ha!" :)
08:48:35 <quchen> :-)
08:48:39 <simpson> tem_: I mean, you *can* see how to write something like insertT, right? insertT :: Tree a -> a -> Tree a
08:48:57 <hpc> network programmers really like insect metaphors; they have no illusions of importantce
08:49:23 <tem_> simpson: yes, i have already implemented something, without using Data.Tree, i was wondering whether there is a library that does this type of things.
08:50:02 <simpson> tem_: Data.Tree.Lens! :3
08:50:37 <quchen> klrr: The liftIO before the "$" ranges over the entire expression, I could imagine that's where the issue comes from
08:50:51 <quchen> So the second liftIO may be unnecessary
08:51:32 <klrr> quchen: oh okey thanks!
08:51:49 <quchen> klrr: That was just a thought though, I may be off entirely
08:52:12 <kniren> hi there, I'm trying to process a big file (8G). To do this fast enough, I'm mapping some chunks to memory with mmapFileByteStringLazy to read it with getWord32le. The problem is that the memory doesn't seem to be freed after the function that process the chunk finishes, if I call it enough times I get an stack overflow due to lack of RAM. Any suggestions? I'm also trying to understand how to work with
08:52:15 <kniren> mmapFilePtr, but I don't know how to read from the pointer data
08:52:45 <typoclass> tem_: how much haskell do you know? for beginners or intermediates, writing the insertT function that simpson suggested would be an excellent exercise
08:53:03 <quchen> kniren: Sounds like the streaming problem. Have you heard of conduit, pipes etc?
08:53:44 <kniren> well, I've worked extensively with pipes in C
08:53:57 <kniren> but I don't know about conduit
08:54:21 <quchen> I don't know what pipes are in C, but my guess would be something very different than in Haskell (that's a good basic assumption I've found). :-)
08:54:22 <arkeet> pipes in C has nothing to do with pipes
08:54:23 <typoclass> kniren: oh, he meant a specific package :-)
08:54:26 <typoclass> @package pipes
08:54:26 <lambdabot> http://hackage.haskell.org/package/pipes
08:54:45 <arkeet> @zackage conduit
08:54:46 <lambdabot> http://hackage.haskell.org/package/conduit
08:54:52 <kniren> oh, ok. I'm checking that out. Thx
08:55:08 <pxqr> kniren: mmap from package mmap use finalizer to unmap memory. I guess you'd better to use conduits.
08:55:13 <dmwit> zackage.haskell.org
08:55:22 <quchen> kniren: The Pipes package has an excellent "Tutorial" sub-module.
08:55:35 <quchen> kniren: http://hackage.haskell.org/packages/archive/pipes/3.2.0/doc/html/Control-Proxy-Tutorial.html
08:55:51 <typoclass> quchen: oh, excellent link, thanks
08:55:51 <tem_> typoclass: I am somewhat of an lightly experienced beginner. I have written a simple rose tree implementation for myself, it allows me to insert a node at a subtree rooted at a specific node in the tree, also allows me to delete a subtree rooted at a given node etc.
08:56:05 <kniren> woah, thnx very neat package
08:56:17 <pxqr> or use finalizeForeignPtr to unmap manually.
08:56:57 <tem_> typoclass: I started looking for the Data.Tree when I saw that it "says" that it implements a rose tree.
08:57:29 <simpson> tem_: It *is* a rose tree. :T
08:58:45 <dmwit> ?remember veekun Here, I'll let you know the ultimate secret behind debugging: <dramatic pause> Something is wrong.
08:58:45 <lambdabot> Okay.
08:58:49 <tem_> simpson: ok, it may be but are there any functions that allow me to do something like: access and rearrange the subtrees within a rose tree?
08:59:11 <simpson> tem_: Sure! You get to write them.
08:59:11 <pxqr> Anyone used hslogger? I set custom stdout handler for logger, but I don't any output.
08:59:18 * geekosaur wonders if the problem here is that tem_ is looking for an OO/procedural interface instead of a functional one
08:59:30 <geekosaur> which, well, haskell.
08:59:45 <simpson> tem_: What kind of signature do you want for your access-and-rearrange function?
09:00:07 <mm_freak> pxqr: make sure that you have enabled the proper verbosity level
09:00:37 <pxqr> mm_freak: I set formatter and verbosity, yes. But what doesn't help.
09:00:40 <typoclass> tem_: ok. i suppose Data.Tree fits somewhat, but doesn't fit amazingly well. but the missing insert function (at least) isn't too bad since you'll have to write an insert function anyway to ensure a directory doesn't contain two things of the same name, and stuff like that
09:01:16 <mm_freak> pxqr: in that case i don't know, sorry
09:02:36 <hpaste> pxqr pasted “silent logger” at http://hpaste.org/87274
09:02:38 <ab9rf> quchen: that is a fairly decent article, but of course it'll only be read by people who already understnd the problems :)
09:03:26 <pxqr> the "args" are misc options passed from closure.
09:03:33 <dmwit> ab9rf: Yep. On the other hand, just naming things is sometimes a contribution. "chunking" and all that
09:03:39 <mm_freak> pxqr: my conclusion from that code is that two spaces aren't sufficient =)
09:03:40 <hamid> @src curry
09:03:40 <lambdabot> curry f x y = f (x, y)
09:04:03 <hamid> @src snd
09:04:03 <lambdabot> snd (_,y) =  y
09:04:05 <quchen> ab9rf: It's funny how often you recognize the patterns when you're aware of them though, and then you'll be able to figure out better answers (e.g. not saying anything).
09:04:15 <ab9rf> quchen: that is the whole idea behind patterns :)
09:04:21 <tem_> Ok I am confused by the functions in Data.Tree. can you give me  links where Data.Tree is used to solve some problems.
09:04:26 <pxqr> mm_freak: that code is from where clause :)
09:04:46 <simpson> tem_: Do you understand the type in Data.Tree?
09:06:16 <ab9rf> Data.Tree is an implementation of rose trees, isn't it?
09:06:17 <mm_freak> i don't think anyone uses Data.Tree seriously
09:06:19 <kniren> what is the difference between pipes and conduit? both of them seem to be strict datastream
09:06:43 <mm_freak> kniren: pipes is well defined and lacks real world features, conduit is ill-defined but gets stuff done
09:06:46 <mm_freak> basically =)
09:06:55 <kniren> hehe, nice
09:07:02 <dmwit> ?hackage sgf uses Tree
09:07:02 <lambdabot> http://hackage.haskell.org/package/sgf uses Tree
09:08:19 <dmwit> My Project Euler solutions file uses Tree a few times.
09:08:25 <typoclass> kniren: not sure, but snoyberg and his folks have blogged quite a bit about conduit, and probably the pipes people will have talked about why they're starting a new thing instead of using conduit. check for blog posts on pipes and/or "announce" mails to haskell-cafe
09:08:56 <dmwit> ...and my attempt to solve the "Gold Rush" game by brute force uses Tree. =)
09:09:51 <kniren> typoclass: thank you very much. Seems like I have work to do :)
09:12:23 <vervic> Hi! I want to define a data structure with a Function that can be applied on Int. I can't figure out how to define this.
09:12:43 <Eduard_Munteanu> vervic: what's the type of the function?
09:12:43 <dmwit> data Foo a = MkFoo (Int -> a)
09:12:50 <mmaruseacph2> vervic: data MyData = Constructor (Int -> a)
09:13:07 <vervic> ty
09:13:11 <mmaruseacph2> or data MyData = Constructor { function :: Int -> a}
09:13:19 <ab9rf> that smells like a homework assignment :)
09:13:24 <mmaruseacph2> in the second case you can get the function immediately
09:13:25 <typoclass> vervic: a function will normally have type "Int -> Something". Something is the return value and could be a String or something else
09:13:52 <mmaruseacph2> ab9rf: yup, it does look like a homework but it is a precise question
09:13:54 <typoclass> ab9rf: ... which really only means that we should do what we should do anyway, i.e. point people in the right direction
09:14:02 <mmaruseacph2> about a certain limited scope
09:14:14 <mmaruseacph2> I am of the opinion that those questions are ok to be answered
09:14:14 <dmwit> I've searched all of Hackage. 125 packages import Data.Tree.
09:14:21 <vervic> the function should return Bool, i'm interested in compare functions only
09:14:40 <mmaruseacph2> vervic: see typoclass' answer for more details
09:14:41 <Eduard_Munteanu> mmaruseacph2: I see suspiciously few .ro students in here, or they're good at hiding it
09:14:47 <typoclass> vervic: ok, then "Something" will be "Bool"
09:14:54 <mmaruseacph2> Eduard_Munteanu: they were on stackoverflow two weeks ago
09:15:00 <mmaruseacph2> now the haskell assignment is quite over
09:15:07 <ab9rf> heh
09:15:08 <Eduard_Munteanu> Ah, fair.
09:15:14 <quchen> dmwit: What's the "depends on ..." URL? I remember there was something on Haskell.org, but didn't find it yesterday
09:15:15 <pxqr> the problem was related to verbosity level, indeed. Level passed streamHandler doesn't affect resulting level. So i just set verbosity for the entire logger. I still don't understand why per handler verbosity doesn't work.
09:15:25 <hpaste> dmwit pasted “imports of Data.Tree as of April last year” at http://hpaste.org/87275
09:15:47 <mmaruseacph2> quchen: I guess those fields are used by cabal install to install dependent packages
09:15:47 <dmwit> quchen: Revdeps are too coarse here, because Data.Tree is in "containers", which has other popular modules.
09:15:51 <dmwit> but
09:15:53 <dmwit> ?where revdeps
09:15:53 <lambdabot> http://packdeps.haskellers.com/reverse
09:16:24 <quchen> dmwit: Thanks. (I need it for something else where it should be sufficient)
09:17:31 <Chaze> very general question: do you know of any PL which doesn't make a distinction between instances and types? the thought here is, that an instance is just a highly specific subtype
09:18:25 <typoclass> Chaze: hmmm!
09:18:26 <dmwit> Only 97 packages match if I change the regex to 'import Data\.Tree'. not sure what to think of that
09:18:29 <simpson> Chaze: I can think of an entire family which does not discriminate between types and values (Smalltalk and relatives), but that's probably not what you wanted.
09:18:49 <dmwit> Chaze: Perhaps you will be interested in contract-based type systems.
09:19:15 <dmwit> You can write, e.g. x : Int { x = 3 } for the subtype of Int inhabited only by 3.
09:19:28 <typoclass> dmwit: hehe. how bizarre
09:19:29 <Eduard_Munteanu> Chaze: Agda, though it has nothing to do with subtypes
09:19:43 <Chaze> dmwit: interesting
09:20:14 <cmccann> dmwit: the gtk bindings don't build if I turn off the gtk3 flag halp plz
09:20:20 <Eduard_Munteanu> Chaze: instances are just unique values in scope, unique meaning they're the only one with the right type
09:20:30 <dmwit> cmccann: moar details plz kthxbai
09:21:40 <Chaze> Eduard_Munteanu: i will definitely take a look at that
09:21:55 <cmccann> dmwit: I grabbed latest from darcs to start trying to add the input device stuff properly and I get a bunch of errors from c2hs or whatever it's called
09:22:01 <cmccann> saying it can't find definitions in a header file
09:22:05 <typoclass> cmccann: i can has error messages?
09:22:20 <dmwit> Yeah, seriously. It's like you're new to the channel or something.
09:22:22 <typoclass> *eror messigis
09:22:48 <Eduard_Munteanu> Chaze: e.g.   functor-id : Functor Identity   functor-id = record { fmap = id }
09:22:56 <cmccann> yeah I didn't have the message saved, gimme a sec
09:26:53 <cmccann> dmwit: hm ok actually it seems to be working now??? man I dunno. obviously I was doing something stupid last night when trying to build it.
09:27:07 <dmwit> \o/
09:27:14 <cmccann> but I guess it was a more transient kind of stupid than I assumed.
09:28:12 <Tanea> Well, I've discovered my problem
09:28:21 <Tanea> gzip unzips into a tarball
09:28:23 <mmaruseacph2> pebcak?
09:28:24 <Tanea> ish
09:28:35 <cmccann> dmwit: incidentally, it's kind of annoying not being able to write type signatures for some event handlers, is it really necessary to not export the HasFoo classes?
09:28:42 <Tanea> I don't know how to phrase it, but I've discovered my problem
09:28:51 <cmccann> or is there some way around that I'm not aware of
09:29:10 <typoclass> Tanea: true. conceptually, you un-gzip the tar.gz, giving a .tar file. then you untar the single file to get a bunch of files
09:29:29 <typoclass> Tanea: ("tar xf ..." combines both steps)
09:29:59 <dmwit> cmccann: Not sure, but I know some classes are not exported to prevent the user from writing instances.
09:30:17 <Tanea> typoclass: I wish I knew that an hour ago
09:30:22 <dmwit> cmccann: Can you give a concrete example for me to look at?
09:30:36 <Tanea> typoclass: I'm trying to do as much as I can inside Haskell
09:30:44 <dmwit> cmccann: (If the user could declare instances, he could write *even more* things that crash.)
09:30:51 <typoclass> Tanea: urgh yeah, i maybe should have mentioned it to you, sorry
09:30:59 <cmccann> dmwit: yes, that's the stated reason, but it means that you can't write a type signature for something in the EventM monad polymorphic in those event types
09:31:04 <Tanea> typoclass: it's alright!
09:31:44 <cmccann> dmwit: specifically I was combining a few types of events into a single queue and wanted to write something that would attach a timestamp
09:32:03 <typoclass> Tanea: can i remind you of system/rawSystem and System.Process? you could just run tar xf, and it's a useful haskell module to know :-)
09:32:39 <Tanea> typoclass: I know about it, I just don't want to do that for reasons that don't actually make sense but shh
09:32:47 <geekosaur> it didn't look to me like it was that hard to process a tarball directly with the tar package...
09:32:54 <cmccann> dmwit: so it needed to have a type like "(HasTime e) => InpueEvent -> EventM e InputEvent" so it could be used from different event handlers
09:33:13 <cmccann> which works fine if I let GHC infer the type, but I can't write an explicit type signature as far as I know
09:33:17 <cmccann> which is a bit annoying
09:33:20 <typoclass> Tanea: heh :-) fair enough
09:34:16 <dmwit> cmccann: Yep, it's a bit annoying.
09:35:13 <cmccann> not exporting the class to prevent new instances feels like kind of a hack tbh
09:36:09 <dmwit> We're interfacing with glib's type system, which is implemented on top of C's type system.
09:36:12 <dmwit> Hacks are inevitable.
09:36:14 <mcstar> a flat namespace with dynamic binding would be cool
09:36:19 <simpson> Is there a function Int -> [a] -> [[a]] which groups a list into sublists by taking n elements at a time? Like a repeated splitAt or something.
09:36:30 <dmwit> simpson: Yes, Data.List.Split.chunk
09:36:34 <ab9rf> simpson: look at Data.List.Split
09:37:05 <ab9rf> as usual dmwit beats me to it
09:37:19 <simpson> Great, thanks.
09:38:22 <dmwit> I have tab-completion for Haskell answers.
09:38:27 <dmwit> You can't beat the machine, man.
09:40:21 <quchen> I bet dmwit's script is some dirty Perl hack
09:40:28 <cmccann> dmwit: would you be willing to consider hackier hacks that accomplish the same goal but still allow writing type signatures? :P
09:41:02 <dmwit> Go on....
09:41:24 <dmwit> (I can't resist a good lead-in!)
09:41:29 <cmccann> well, I have a few ideas but I need to test them first
09:42:12 <mcstar> put the classes in .Internals, and import that when you want to write type sigs, but in the docs tell them not to build on things exported from .Internals
09:42:39 <dmwit> That is the standard solution, yes.
09:42:51 <dmwit> I would be pretty open to patches implementing that solution.
09:43:16 <dmwit> Provided the documentation for .Internal was sufficiently strongly worded, of course. ;-)
09:44:18 <ab9rf> and assuming people actually read documentation
09:44:27 <ab9rf> although for haskell that's a fairly safe assumption
09:48:48 <cmccann> dmwit: ok, my hack is pretty hacky but seems to work-ish
09:49:04 <dmwit> ?
09:49:34 <hpaste> “C. McCann” pasted “read my lips no new instances” at http://hpaste.org/87277
09:49:48 <cmccann> technically you can write new instances
09:49:55 <cmccann> but using them gives overlapping instance errors
09:50:28 <dmwit> -XOverlappingInstances ?
09:50:54 <cmccann> needs to be enabled for the instance being potentially overlapped
09:51:02 <cmccann> i.e. don't add that to the Internal module
09:51:04 <dmwit> I see.
09:51:35 <cmccann> at least I think that's how it works
09:52:48 <cmccann> hm, actually maybe not
09:52:50 <cmccann> bluh.
09:53:55 <cmccann> I could probably prevent that as well but would end up adding more (and newer) GHC extensions I think
09:54:09 <dmwit> I wrote "{-# LANGUAGE FlexibleInstances #-} module Test where class Foo a; instance Foo a" and in another file "import Test; instance Foo Int" and got no complaints.
09:54:12 <dmwit> (!)
09:54:22 <cmccann> did you try using it
09:54:31 <cmccann> the instance will compile if you don't try to use it
09:54:35 <dmwit> aha
09:55:37 <otters> "I'm not gonna touch it, Mom! I just wanna LOOK at it"
09:55:56 <dmwit> Okay. But yeah, OverlappingInstances seems to make it OK in the eyes of GHC, even using it.
09:56:11 <dmwit> Probably TypeFamilies could do this correctly.
09:56:11 <cmccann> oh wait I'm being stupid again.
09:56:40 <dmwit> type family CopyOfHasFoo a; type instance CopyOfHasFoo a = HasFoo a
09:56:40 <hpaste> “C. McCann” annotated “read my lips no new instances” with “read my lips no new instances (annotation)” at http://hpaste.org/87277#a87278
09:56:45 <cmccann> try that
09:57:23 <dmwit> aha
09:57:26 <dmwit> That's better.
09:58:24 <cmccann> I don't think there's any way around that
09:58:29 <dmwit> Okay, I'd consider a patch that added FooInternal classes as superclasses of the exposed ones.
09:58:55 <dmwit> Or even just a single FooInternal class...
09:59:11 <dmwit> class OnlyGTKCanInstantiate a -- =)
09:59:19 <cmccann> it could probably be trimmed down a bit, yeah
10:00:10 <dmwit> I guess you can probably still get around it with GeneralizedNewtypeDeriving, but not in a way that matters, right?
10:00:45 <cmccann> the internal instance does need to distinguish between the exported classes, otherwise you'd be able to steal the internal instance of one type and use it to write an instance for another
10:00:56 <cmccann> so either multiple classes, or a data type like I used
10:02:47 <cmccann> dmwit: well you can probably get around it by using unsafeCoerce
10:02:59 <cmccann> I think at that point it's time  to stand back and let people aim at their foot
10:03:04 <dmwit> yes
10:03:40 <dmwit> Good point about distinguishing between different exported classes.
10:03:45 <cmccann> so I wouldn't worry about the newtype deriving or anything along those lines, that's essentially impossible to do without knowingly attempting to break stuff
10:04:17 <triyo> I am trying to read the output of a process using System.Process.readProcess like so: (readProcess "dict" [""] "some-word") >>= putStrLn
10:04:21 <triyo> I get *** Exception: fd:15: hFlush: resource vanished (Broken pipe)
10:04:45 <triyo> dict process is meant to connect to the net to find the match for the supplied word
10:05:26 <triyo> So I gather thats where the problem sits.
10:05:34 <triyo> Tied the `ls' command without problems.
10:05:40 <triyo> *tried
10:05:44 <cmccann> dmwit: so which do you prefer, a single class with a wrapper type like my example, or an internal version of each HasFoo class
10:06:23 <triyo> What is the common way to trap the stdout when the process executed takes some time to complete computing
10:06:36 <dmwit> Wait, I thought an internal version of each HasFoo class was like your example.
10:06:37 <triyo> *trap=grab
10:07:05 <cmccann> dmwit: my example just has one internal class
10:07:06 <geekosaur> does dict really take an empty string as a parameter?
10:07:06 <dmwit> triyo: Perhaps "dict" is expecting some input.
10:07:23 <cmccann> dmwit: with a wrapper type to distinguish each exported class
10:07:32 <cmccann> it really doesn't make much difference
10:07:38 * geekosaur suspects the word's supposed to be inside the parameter list and stdin should be ""
10:08:43 <dmwit> cmccann: Oh, yeah, seems to me adding one internal class per external class is preferable to adding one internal class plus (one data type per external class).
10:08:52 <dmwit> One fewer entities. =)
10:08:54 <triyo> dmwit: I did supply the input `readProcess "dict" [] "some-word"`. The last string arg
10:09:28 <latermuse> is there a reason to upgrade to 7.6 from 7.4?
10:09:29 <triyo> the list is meant to be for options if I recall. And I'm going with the defaults
10:09:37 <cmccann> dmwit: ok sounds good
10:09:51 <dmwit> triyo: I see. Then perhaps dict is expecting to see "some-word\n".
10:09:59 <dmwit> I don't know for sure, just taking stabs in the dark.
10:09:59 <geekosaur> triyo: if you do it from the shell, do you say "dict word" or "echo word | dict"
10:10:04 <dmwit> Is dict something I can install locally and test?
10:10:07 <geekosaur> because the latter is what you've done with readProcess
10:10:18 <dmwit> Actually, he's done echo -n word | dict, right?
10:10:28 <geekosaur> probably, yes
10:10:57 <monochrom> latermuse: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/release-7-6-1.html tells you what's new in 7.6. you have to decide it yourself
10:11:06 <mcstar> just use runProcess and see whats the return code
10:11:14 <triyo> geekosaur: Hmm, I just plain want, `dict word`
10:11:23 <geekosaur> then you want the word inside the brackets
10:11:26 <mcstar> and maybe grab stderr too and see whats there
10:11:41 <geekosaur> it's not just "options", there is no such distinction. all command line parameters go in that list
10:11:43 * triyo need to go look at that System.Process doc again
10:12:10 <mcstar> it does not depend on haskell and System.Process
10:12:33 <mcstar> arguments that are supplied after the command name are the arguments, they dont go to stdin
10:12:42 <geekosaur> you put the word as the command's standard input (which is to say, what you would feed it with redirection or pipe or what you would type into the program itself)
10:13:10 <latermuse> monocrhom: thanks :)
10:15:28 <triyo> mcstar: good point on trapping the stderr, having a loom now as there is a runProcessWithExitCode variant as I recall
10:16:39 <mcstar> readProcess is a convenience function better used interactively imho
10:18:03 <ab9rf> a loom?
10:18:30 * geekosaur guesses typo for look
10:18:30 <mcstar> i think he means he is undecided which one to use?
10:18:50 <dmwit> How can readProcess be used interactively?
10:19:03 <mcstar> dmwit: when experimenting in ghci
10:19:03 <ab9rf> with great care?
10:19:18 <dmwit> Oh, that kind of interactively.
10:19:36 <dmwit> As in, not interactively, but when there's a REPL lying around.
10:19:47 <ab9rf> dare to repl
10:20:50 <mcstar> i dont think my terminology was far off, but apparently it is debatable
10:21:33 <mcstar> (i was away from #haskell for too long, i got sloppy)
10:24:38 <dmwit> You're fine. I'm just easily confused.
10:37:30 * ski usually calls it an "interactor"
10:39:00 <heatsink> What's the relationship between the Haskell and Scala communities?
10:39:25 <dmwit> I guess there's a bit of overlap?
10:40:45 <Cale> I've heard it said that most Scala programmers are thinking in Haskell
10:40:50 <typoclass> heatsink: occasionally i've heard haskellers who use it on the job describe it as not so great (which is why i, for one, didn't have much motivation looking into scala)
10:40:51 <heatsink> Presentations of programming concepts in Scala often include Haskell code for comparison, sometimes the other way around too
10:40:52 <Cale> But I don't really know
10:40:53 <mekeor> heatsink: we are like good friend walking on different ways but constantly talking with each other by mobile phone using hsdpa.
10:40:55 <mcstar> the overlap has a name, Edward
10:41:33 <mekeor> *friends
10:42:17 <heatsink> I answered a Scala question on StackOverflow a while ago.  My answer started with "I don't know Scala, but here's an answer based on Haskell."  I got the most upvotes.
10:42:30 <monochrom> hahaha
10:42:34 <typoclass> heatsink: :-D
10:42:37 <mekeor> :D
10:45:18 <heatsink> I get the impression that there's a bit of "my language is better" rivalry going on
10:45:54 <aristid> ridiculous, because haskell is so obviously much better.
10:46:30 <elliott> my impression of Scala from people who have also used Haskell involves lots of screams and fire and suffering
10:46:43 <Cale> heatsink: Not quite what I've heard. It seems like many of the people who are programming in Scala would like to be programming in Haskell, but need JVM support.
10:46:57 <heatsink> Hmm
10:47:09 <Okasu> Scala tries to be haskell and java at same time. Don't really like it.
10:47:40 <Okasu> Huge complex cpp of 21st century.
10:47:41 <typoclass> heatsink: not sure about rivalry. i have (very vaguely) the impression that scala looks up to haskell, trying to approximate some of our standard libraries
10:48:04 <heatsink> I see, so Scala is more difficult to work with, but if you need to interface with Java then that's what you will be using
10:48:39 <aristid> well the alternative would be clojure i guess.
10:48:51 <typoclass> aristid: needs moar type system plz
10:49:07 <aristid> y u no type system?!
10:49:11 <Okasu> http://jaskell.codehaus.org/
10:49:38 <heatsink> Lisp programmers are too smart for types.
10:50:55 * mcstar wishes haskell had numpy and scipy and matplotlib functionality in a natural way (whatever that would be)
10:51:44 <mekeor> Okasu: https://github.com/Frege/frege
10:52:24 <luite> mcstar: better plotting hopefully coming this summer with a gsoc
10:52:35 <edwardk> mcstar: give us time ;)
10:52:38 <heatsink> mcstar, we're almost there.  All we need to do is unify Data.Array, Data.Vector, Data.Bytestring, DPH, and Repa.
10:52:52 <mcstar> haha good to hear that guys
10:57:07 <dncr> I need to run a bunch of IO (Either e a) and fail out early on any Left.  Should I use Control.Monad.Either.runEitherT category-extras or Control.Monad.Trans.Either.runEitherT in either or another one?
10:58:49 <mmaruseacph2> there's also http://hackage.haskell.org/packages/archive/easyplot/1.0/doc/html/Graphics-EasyPlot.html
10:58:53 <heatsink> It's likely that any msum instance will do what you want
11:18:46 <jkff> Hi! I'm looking for inspiration: can anyone point me to a simple compiler written in Haskell which tracks the correspondence between generated instructions and positions in original code?
11:19:38 <jkff> I'm trying to write an EDSL whose target language is a form of assembly and which allows me to define higher-level macros as simple Haskell functions that would concurrently generate 1) the pretty-printed syntax 2) code 3) correspondence between the two
11:20:15 <shachaf> hi jkff
11:20:24 <jkff> Hi shachaf
11:20:30 <shachaf> I think edwardk might've mentioned doing something like that in the context of talking about Trifecta but I'm not sure.
11:21:07 <jkff> Hm, ok, I'll look at it
11:21:29 <edwardk> i have a c preprocessor that i need to port into trifecta still that does that, clang-style tracking what macros are being expanded at any point for error reporting
11:21:57 <edwardk> "at this location, while expanding that macro with these args, while expanding this other macro with these args, etc. "
11:22:25 <nicoo> edwardk: What's Trifecta ?
11:22:27 <jkff> Sounds cool - is the source open?
11:22:44 <shachaf> jkff: Are you coming to BayHac, by the way?
11:22:52 <edwardk> trifecta is. i never bothered to release the c preprocessor because it was entangled with an old compiler of mind
11:22:53 <jkff> shachaf: sure! with this very project
11:22:53 <edwardk> er mine
11:23:07 <jkff> I'm writing a modelchecker
11:23:14 * nicoo compiles edwardk's mind.
11:23:28 <edwardk> nicoo: watch out i'm full of type errors
11:23:45 <jkff> So I have a target "concurrent assembly" language and some convenience macros that just expand to lists of instructions
11:24:01 <jkff> but I'd like to make the output intelligible and help the user map a violating trace into the original code
11:24:01 <typoclass> @remember edwardk i never bothered to release the c preprocessor because it was entangled with an old compiler of mind
11:24:01 <lambdabot> I will never forget.
11:24:08 <edwardk> =P
11:24:38 <edwardk> remind me not to make typos around here. =P
11:25:12 <nicoo> I will never forget.
11:25:36 <jkff> Heh, what I'm trying to achieve sounds a little like a comonad...
11:27:18 <typoclass> edwardk: just to be sure, i wasn't mocking the typo, i found the concept of a "compiler of mind" creative and interesting and funny. the typo was a very happy accident
11:28:09 <mcstar> > newtypo EdwardK = a -> (Typo, a) -- here's your spellchecker
11:28:12 <lambdabot>   <hint>:1:17: parse error on input `='
11:29:36 <mm_freak> newtypo CompilerOfMind = forall a. String -> a
11:29:48 <nicoo> mm_freak: Noooooes !
11:29:49 <mm_freak> s/newtypo/typo/
11:38:13 <benzrf> python : pythonic :: haskell : ?
11:38:39 <dmwit> Can't we just say "idiomatic" for both languages?
11:38:46 <benzrf> right, that's good
11:38:55 <benzrf> I was just trying to find a way to refer to idiomatic haskell
11:39:00 <benzrf> forgot that word
11:39:00 <__xc> c: sick
11:39:13 <byorgey> "Haskelly"
11:39:26 <benzrf> mheh
11:39:33 <byorgey> I am actually serious.
11:39:56 <byorgey> it's somewhat more informal than 'pythonic' though.  And I prefer "idiomatic Haskell" myself.
11:40:03 <nicoo> Hask-hellish ?
11:41:12 <byorgey> that's different.  Hask-hellish refers to code which is only one line but uses 16 libraries and five concepts from advanced category theory.
11:42:23 <edwardk> oh. my code.
11:42:24 <typoclass> byorgey: it's 1 line, but 34 lines of imports
11:42:27 <edwardk> good to know it has a name
11:42:39 <byorgey> typoclass: right
11:42:48 <edwardk> Haskhell
11:43:04 <byorgey> edwardk: don't worry, I write code like that too occasionally =)
11:43:41 <edwardk> haskhell tends to send you to cabal hell
11:44:01 <nicoo> edwardk: So does normal Haskell, right ?
11:44:08 <ab9rf> and the one line only makes sense to Very Special People
11:44:15 <edwardk> nicoo: to be honest? i never have any of these problems that people whine about
11:44:50 <edwardk> i mean i occasionally invalidate a package or two, but i know when i'm doing it that i'll have to reinstall them
11:44:56 <nicoo> edwardk: Tbh, the few time where it happened, I just exported the set of packages I had, deleted my .cabal, and reinstalled them
11:45:29 <dmwit> delete your .cabal, hit the gym, lawyer up
11:45:42 <typoclass> nicoo: it's gotten much better recently. and you're right, it's usually not difficult to fix
11:45:54 <elliott> edwardk has other cabal hells
11:45:58 <elliott> like pvp.
11:46:15 <edwardk> yeah
11:46:15 <edwardk> i finally found a way out of most of those problems though
11:46:26 <dmwit> I've had a lot less trouble with cabal since dcoutts taught me the magic of "cabal install foo bar baz".
11:46:40 <nicoo> dmwit: What magic ?
11:46:41 <edwardk> by giving myself the broader contract that i only bump the first version when i break my internal packages, that has cut the amount of packages i have to send to cabal by a factor of 15
11:47:03 <dmwit> nicoo: When you run cabal install, tell it *all* the things you want installed, not just the new things you want installed.
11:47:05 <edwardk> so i still comply with the PVP, but i'm able to give myself some more internal flexibility
11:47:13 <nicoo> dmwit: Ah, yes
11:47:33 <Tanea> I've just written a little thing that counts the lines of Haskell code in a package on Hackage
11:47:53 <dmwit> Tanea: neat!
11:48:10 <byorgey> edwardk: ah, so when you depend on your own packages you say  && < 3  or whatever?
11:48:11 <Tanea> dmwit: it's pretty niave
11:48:23 <edwardk> byorgey: yeah
11:48:27 <byorgey> edwardk: that's a good idea
11:48:27 <Tanea> It just searches for files with a .hs or .lhs suffix and counts the lines in them
11:48:36 <byorgey> perhaps I will try it
11:48:43 <edwardk> byorgey: then i only bump the first digit when i break myself
11:48:51 <byorgey> right
11:48:57 <Tanea> Lens has over 20000
11:49:53 <edwardk> Tanea: sounds about right
11:50:04 <typoclass> edwardk: so, you switched from "&& == 1.2.3" to "&& < 2"?
11:50:10 <Tanea> base has even more!
11:50:26 <edwardk> typoclass: only for depedencies on my own packages from my own packages
11:50:43 <typoclass> edwardk: hmmm ok
11:51:09 <edwardk> typoclass: i used to literally have to ship 20-50 packages if i changed something down deep in my dependency chain that technically broke PVP
11:51:10 <FreeFull> Sometimes stuff I installed with cabal seems to disappear and I have to install it again
11:51:18 <elliott> dmwit: you list every package you have installed when you add a new one?
11:51:20 <FreeFull> I think it has to do with ghc updates
11:51:32 <edwardk> typoclass: even if i knew none of my other code cared
11:51:37 <dmwit> elliott: Nah, just the top-level ones, and just when something is about to break. =)
11:51:39 <typoclass> edwardk: right
11:51:59 <elliott> dmwit: hehe, I wish I could predict breakage.
11:52:05 <dmwit> elliott: e.g. by "top-level" I mean I don't say "X11 X11-xft xmonad xmonad-contrib", I just say "xmonad-contrib".
11:52:12 <elliott> right
11:52:12 <dmwit> elliott: You can. cabal tells you right before it breaks.
11:52:14 <edwardk> at one point i had to ship out something like 120 packages in a day, and then i decided i had had enugh
11:52:19 <edwardk> er enough
11:52:43 <Tanea> edwardk: was that when I pointed out the lack of a Semigroup instance for Ordering
11:52:49 <edwardk> (the 120 was multiples of the same packages because of two pvp breaking changes i hadnt realized i needed)
11:52:51 <dmwit> elliott: You say "cabal install foo" and it goes "ummmm" and then you're like "cabal install foo and all my other stuff" and it's like "oh, yeah, right on, mang!" and then you're like, "well, duh"
11:53:24 <edwardk> Tanea: might have been. i think i had gotten fed up with it on a previous incident and that was the day i finally snapped.
11:53:34 <Tanea> :)
11:53:44 <Tanea> Can anyone name a library that they think is bigger than base?
11:53:54 <edwardk> Tanea: how many lines is it?
11:53:55 <Tanea> Well, a package available from Hackage
11:54:06 <Tanea> 38465, according to this, edwardk
11:54:10 <edwardk> ah
11:54:19 <edwardk> so lens is only half the size of base. hrmmph
11:54:23 <Araneidae> What does this error: http://sprunge.us/Jfei mean and how do I avoid it?
11:54:29 <Tanea> edwardk: keep trying!
11:54:30 <elliott> dmwit: usually when it goes "ummm" I try --solver=modular
11:54:40 <Araneidae> I get it when compiling with -Wall
11:54:48 <Tanea> Araneidae: add a type signature
11:54:51 <edwardk> i wonder how big the old category-extras was
11:54:56 <edwardk> back when i thought that was a big package
11:55:10 <Tanea> It means "I know it's some sort of Num, so I'm gonna guess it's an Int"
11:55:19 <Araneidae> Tanea, alas, there's nowhere to put a type signature in the code
11:55:19 <typoclass> Araneidae: have you tried adding {-# LANGUAGE NoMonomorphismRestriction #-} ?
11:55:21 <typoclass> @where dmr
11:55:21 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
11:55:28 <Araneidae> typoclass, will try
11:55:29 <typoclass> Araneidae: see also this link
11:56:01 <Araneidae> Doesn't make any difference.  Guess I'd better post some code
11:56:02 <Tanea> edwardk: only 4744 lines, apparently
11:56:20 <Tanea> That's category-extras-0.53,5,1
11:56:39 <typoclass> Araneidae: yes. i was only guessing :-/
11:57:01 <Araneidae> This is the offending code: http://sprunge.us/ZQai
11:57:21 <Tanea> lambdabot is 12134 lines
11:57:30 <Araneidae> StreamPut is just a ReaderT wrapping of Data.Binary.Put
11:57:55 <dmwit> Araneidae: There is always a place to put a type signature.
11:58:00 <Araneidae> Oops, here's the code: http://sprunge.us/ZQai
11:58:01 <dmwit> In this case, 2^(31 :: Int) - 1
11:58:06 <dmwit> (for example)
11:58:18 <mauke> Araneidae: add a type signature
11:58:22 <Araneidae> Ah, I see.  I'll try that ... but that's 'orrible
11:58:30 <Araneidae> mauke, where?
11:58:33 <Araneidae> It's got one
11:58:47 <mauke> In the first argument of `(-)', namely `2 ^ 31'
11:59:00 <dmwit> no
11:59:06 <dmwit> That's not enough.
11:59:06 <Araneidae> Yes, that's utterly horrible -- why does that need a type signature?
11:59:24 <dmwit> Araneidae: Because (^) is class-polymorphic, meaning its behavior depends on what type it's monomorphed to.
11:59:32 <mauke> ah, it's about 31 specifically
11:59:39 <edwardk> running sloccount on my personal haskell project folder gives back 262,989 lines
11:59:51 <Araneidae> Hmmmmm.  I wonder if I should use shifts fro Data.Bits instead
12:00:06 <dmwit> Or bit.
12:00:09 <mauke> Bits can't even be defaulted
12:00:19 <edwardk> it also purports that I should have made 10 million dollars for my efforts. If only. =)
12:00:23 <dmwit> mauke: doesn't need to be
12:00:32 <dmwit> mauke: bit :: Bits a => Int -> a
12:00:36 <jfischoff> @tell parcs ping me, I'd like to pick you brain on parallel ghc compilation.
12:00:36 <lambdabot> Consider it noted.
12:00:43 <Araneidae> Putting (31::Int) makes the problem go away
12:00:50 <dmwit> mauke: The first argument isn't polymorphic, and the second is determined by the type of the function being defined as Int.
12:01:31 <Araneidae> Ah well, it's a workaround :(
12:01:52 <Tanea> I think the next step with this is to make it not hard-coded for Hackage
12:01:58 <dmwit> > bit 31
12:02:00 <lambdabot>   2147483648
12:02:28 <dmwit> hum
12:02:35 <dmwit> Extended defaulting, I guess, for that one.
12:15:16 <heath> does anyone have a link which shows haskell compiling down to assembly for any platform?
12:15:44 <Tanea> I'm suspecting this program I wrote may be innaccurate
12:16:11 <Tanea> Unless base-4.0.0.0 is 100 times bigger than base-3.0.3.1
12:16:44 <typoclass> heath: this might be relevant http://blog.ezyang.com/2011/04/tracing-the-compilation-of-hello-factorial/ though i don't think it talks about "any platform"
12:18:27 <Tanea> Anyone have a library they know how many lines of code there are?
12:19:23 <mm_freak> Tanea: what do you mean?  you want me to tell you how many lines my code bases have?
12:19:58 <Tanea> mm_freak: I've got a program which counts how many lines of code there are in a package
12:20:05 <Tanea> But I'm pretty sure it's faulty
12:20:59 <mm_freak> Tanea: the latest netwire release should have 3383 lines below Control
12:21:20 <mm_freak> but i'm not sure i made changes since the last release to that old code base
12:21:33 <Tanea> mm_freak: it counts all .hs and .lhs files including setup.lhs
12:21:38 <Tanea> And removes blank lines
12:22:06 <mm_freak> well, get my xmonad configuration
12:22:10 <_just> but blank lines are the best :/
12:22:27 <Tanea> Okay, it's doing it correctly for groups-0.2.0.1
12:22:28 <mm_freak> https://github.com/ertes/config/tree/master/myxmonad
12:22:46 <Tanea> mm_freak: unfortunately, at the moment it's hard-coded to Hackage
12:23:10 <mm_freak> % wc -l **/*.{l,}hs
12:23:16 <mm_freak>   722 total
12:23:34 <mm_freak> well, next step, de-hardcode it =)
12:23:54 <Tanea> And even then, it's REALLY hard-coded to fold through a tarball
12:24:00 <flebron> Hi. Am I being hit with the monomorphism restriction? f = print . product . map (shiftL 1 . (subtract 1) . C.length) . C.group, where C = Data.ByteString.Char8. C.length can't output anything other than Int. shiftL, however (from Data.Bits), whose signature is shiftL :: Bits a => a -> Int -> a, complains that "Ambiguous type variable `b0' in the constraints:      (Data.Bits.Bits b0) arising from a use of `shiftL'".
12:24:08 <doshitan> Tanea, maybe compare the count with something like http://cloc.sourceforge.net/ ?
12:24:16 <mm_freak> Tanea: then just compare to what 'wc -l' gives you
12:24:28 <typoclass> Tanea: i think there's a tool named sloccount or similar (at least one tool). you could use that to get a second opinion
12:24:28 <flebron> Oh I think it doesn't know what type 1 is. I get it. Nevermind.
12:31:52 <adnap> How do I write multiple commands in one line for GHCI (e.g. let a = 2; let b = 3)?
12:32:50 <mm_freak> adnap: let a = 2; b = 3
12:33:39 <adnap> How about let a = (+2); a 4
12:33:53 <adnap> oh
12:34:00 <adnap> let a = (+2) in a 4
12:34:28 <adnap> > let a = 2; b =3 in a + b
12:34:30 <lambdabot>   5
12:34:56 <skyflash> Hmm, first time I've tried quick-n-dirty serialization via show-read with a structure containing a Data.Set.  It doesn't seem to work (fromList?).  Any ideas?
12:36:18 <geekosaur> that's expected, because there's no direct constructor exported (nor should there be) for Data.Set (or Data.Map)
12:36:23 <rod|> anyone experienced in pathfinding algs ?
12:36:45 <supki> > read "fromList [1,2,3]" :: S.Set Int
12:36:46 <lambdabot>   fromList [1,2,3]
12:37:00 <skyflash> geekosaur: OK, what's the best quick-n-dirty serialization then?
12:37:12 <geekosaur> are you suggesting that's not for some reason? why?
12:38:43 <geekosaur> also, just in case my previous comment did not tell you what it should have: you cannot serialize the internal format of a Set. At all. This is intentional, it is necessary to preserve invariants.
12:38:44 <skyflash> geekosaur: maybe I misunderstood your response.  I thought you were confirming that read wouldn't work because show writes out a form that can't be re-read.
12:38:58 <geekosaur> no, it can be reread fine
12:39:49 <kostja> hello! why is this not working as expected? foldr (\x _ -> print x) (return ()) [1..9]
12:39:53 <geekosaur> the Read instance for Set knows how to handle a fromList, as long as what's inside that alkso has Read instances
12:40:11 <skyflash> Which it does
12:40:11 <benzrf> kostja: print is not a function afaik
12:40:17 <geekosaur> kostja, what were you expecting that to do?
12:40:18 <benzrf> wait
12:40:19 <benzrf> never mind
12:40:32 <Tanea> Could someone please name me a huge package available from Hackage that is neither base nor lens?
12:40:34 <kostja> I'd like that to print the numbers from 1 to 9
12:40:47 <benzrf> kostja: you don't understand how I/O works in haskell
12:41:07 <kostja> yeah, print is an "action" is there a way to fold actions?
12:41:07 <benzrf> hello! I just finished rewriting a small, useful-ish python script in haskell to try and get a feel for the language, but I have a feeling it's not very good code, given that it's 29 lines to the original's 14. Can somebody look at my code and give me some pointers? The Python is at http://paste.pound-python.org/show/32940/ and the haskell equivalent'
12:41:11 <benzrf>  is at http://paste.pound-python.org/show/32941/
12:41:27 <benzrf> kostja: you need to sequence them together, right now you're discarding the previous ones
12:41:54 <benzrf> try something like foldr (\x prints -> prints >> print x) (return ()) [1..9]
12:42:15 <geekosaur> but fold is probably not what you actually want there at all
12:42:21 <fdgs> anybody know how I can use Text.Parser.Token's stringLiteral for strings that span over multiple lines?
12:42:25 <elliott> mapM_ is better suited for this task.
12:42:30 <elliott> though you can also do it with foldr.
12:42:42 <troydm> transformers-compat-0.1.1.1 failed during the configure step. The exception
12:42:44 <troydm> was:
12:42:45 <Tanea> kostja: look at mapM_
12:42:47 <troydm> Failure 1
12:42:52 <kostja> this is just an exercise what would be a more approriate thing to do?
12:43:04 <troydm> does that mean i'm experiencing cabal hell?
12:43:09 <geekosaur> troydm, nice pasting only the useless part of the error
12:43:18 <geekosaur> @paste *full* error output
12:43:18 <lambdabot> Haskell pastebin: http://hpaste.org/
12:43:32 <troydm> geekosaur: ExitFailure 1 is full error output
12:43:39 <monoidal> kostja: instead of  (show $ ind + 1) ++ ... you can use show (ind + 1) ++ ...
12:43:57 <troydm> i have ghc 7.4.2
12:44:22 <monoidal> troydm: you should see something above
12:44:34 <troydm> monoidal: nothing
12:44:51 <troydm> is there a way to turn on verbose install procedure?
12:44:58 <monoidal> troydm: above "transformers-compat-0.1.1.1 failed during the configure step." you see nothing?
12:45:09 <kostja> actually the exercise is something like implementing mapM
12:45:14 <skyflash> What gets written out with show is: AppState {portConfigs = fromList [PortConfig {portName = "Bluetooth Modem", portDevice = "/dev/cu.Bluetooth-Modem", serialSpeed = 19200}], currentPort = PortConfig {portName = "Bluetooth Modem", portDevice = "/dev/cu.Bluetooth-Modem", serialSpeed = 19200}}
12:45:40 <skyflash> Both AppState and PortConfig are Show and Read instances (deriving)
12:45:42 <troydm> monoidal: ohh above it
12:45:44 <troydm> i see
12:45:55 <troydm> it says my transformers package is broken
12:45:57 <troydm> strange
12:46:04 <cmccann> benzrf: that 29 lines is including blank lines, type signatures, and imports that the python version doesn't need. the meaningful lines of code aren't all that different.
12:46:07 <skyflash> but reading in says "No parse"
12:46:35 <edwardk> Tanea: i don't have anything publicly released larger than lens
12:46:44 <geekosaur> skyflash, how are you reading it in? it is possible that read is simply being defaulted to the wrong type
12:47:16 <Tanea> edwardk: I'm just trying to find a third library in that order of magnitude
12:47:22 <cmccann> benzrf: so for a direct port it looks fine, anything that would reduce the linecount would either be useless golfing or a complete change of design
12:47:37 <rod|> anyone experienced in pathfinding algs ?
12:47:55 <edwardk> Tanea: it is an exponential distribution and afaict base is the largest point we have
12:48:10 <cmccann> GHC itself is pretty big, innit?
12:48:16 <skyflash> geekosaur: hmm, I think it's getting the right type, but I'll just check I'm not suffering some laziness with 'withFile' closing the file...
12:48:24 <Tanea> cmccann: I don't think GHC is on Hackage
12:48:27 <geekosaur> that's also possible
12:48:30 <cmccann> oh, true
12:48:37 <edwardk> after lens it drops off another factor of 2 and you start finding containers, etc.  and another factor of 2 below that is algebra, and my bigger packages and some others
12:49:19 <Tanea> Containers is 15431
12:49:26 <geekosaur> Tanea, we tend to break up most larger things into smaller packages instead. see for example Yesod, which might well be the biggest package of all were it not broken into many subpackages
12:49:36 <Tanea> geekosaur: I know
12:49:38 <geekosaur> (the GHC folks are always looking for ways to break up base too)
12:49:41 <benzrf> hello! I just finished rewriting a small, useful-ish python script in haskell to try and get a feel for the language, but I have a feeling it's not very good code, given that it's 29 lines to the original's 14. Can somebody look at my code and give me some pointers? The Python is at http://paste.pound-python.org/show/32940/ and the haskell 'equivalent' is at http://paste.pound-python.org/show/32941/
12:49:54 <Tanea> I have written one of the smallest libraries on Hackage
12:50:17 * hackagebot hspec 1.5.4 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.5.4 (SimonHengel)
12:50:37 <Tanea> geekosaur: I'm playing around with a little program I wrote to see how many lines of code there are in a package on Hackage
12:50:52 <cmccann> benzrf: I just responded to that a few minutes ago
12:50:56 <typoclass> benzrf: nice :-) congratulations on your first haskell program (or one of the first ones)
12:51:14 <monoidal> benzrf: you can use mapM_ in showInstructions; instead of (show $ ind + 1) ++ ... you can use show (ind + 1) ++ ...
12:51:38 <geekosaur> benzrf: if you re-paste that to hpaste.org, hlint will provide code suggestions on the paste
12:51:51 <benzrf> oh sorry cmccann
12:51:52 <mjrosenb> argh@debian
12:52:04 <benzrf> ok!
12:52:08 <geekosaur> (alternately you can 'cabal install hlint' and run it locally)
12:52:15 <kostja> what does (>>)?
12:52:24 <mjrosenb> can I just modify every package ever to not pass --hash-size=31?
12:52:25 <mjrosenb> :(
12:52:39 <benzrf> kostja: you need to understand monads first
12:52:57 <Tanea> kostja: it ignores the value of the LHS but not the effects
12:53:03 <skyflash> Argh... OK, it was withFile closing the file before read did it's thing.
12:53:03 <benzrf> but the basic usage in IO is that it binds together two actions
12:53:04 <Tanea> Except that's a bad analogy
12:53:11 <typoclass> kostja: do you know (>>=)? (>>) is similar, but does not pass a value from the left to the right
12:53:26 <benzrf> kostja: for example, 'putStrLn "foo" >> putStrLn "bar"' creates an action that prints foo and then bar
12:53:32 <kostja> I know the bind operator (>>=)
12:53:35 <benzrf> ok
12:53:44 <kartoffelbrei> kostja: it chains two monadic action while discarding the intermediate result.
12:53:47 <kartoffelbrei> :t (>>)
12:53:49 <lambdabot> Monad m => m a -> m b -> m b
12:53:54 <eikke> a >> b = a >>= \_ -> b
12:53:59 <kartoffelbrei> :t (>>=)
12:54:01 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:54:24 <Tanea> syb is pretty big
12:54:30 <Tanea> 4th biggest I've seen so far, I think
12:54:38 <kostja> yeah, I checked the typed, but didn't understand what it does. thank you for the anwser
12:55:17 * hackagebot hspec-meta 1.5.4 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.5.4 (SimonHengel)
12:55:31 <benzrf> kostja: you need to understand monads to understand what the binding operator does
12:55:40 <rod|> i have a working implementation of IDA* witch terminates and gives optimal path but it takes about 7 min for intermediate problem ( find way around a wall with u-shaped badarea).Maybe i missed something.
12:55:40 <geekosaur> kostja, everything in Haskell has to return *something*; for IO actions, it's an IO (). nobody really cares abiut the () part, so >> lets us ignore it while keeping the IO part (implicitly via the type)
12:56:09 <geekosaur> well, for output-style IO operations. obviously you care with e.g. getLine
12:56:18 <mjrosenb> so, is there some way of figuring out where the argument --hash-size=31 is coming from?
12:56:19 <kartoffelbrei> kostja: maybe you should play a bit with some monad instances. State could be particulary enlighting for understanding (>>).
12:56:30 <mjrosenb> I can't find it in any text file in /usr/lib/ghc
12:56:38 <Tanea> hspec-meta 1.5.4 has 1502 lines of code
12:56:53 <kostja> in the moment I'm working with the wikimedia haskell book
12:57:06 <mjrosenb> ugh.  is this hard-coded into the ghc binary?
12:57:29 <kostja> I'm doing the exercises in 19.6 right now
12:58:35 <kostja> thank you very much
13:01:40 <typoclass> hm benzrf is gone already ...
13:07:51 <bjackman> Does anyone know how I can get a debug trace to tell which function caused a stack overflow?
13:08:03 <Tanea> I don't think you can
13:08:08 <Tanea> No wait
13:08:11 <Tanea> Of course you can
13:08:16 <Tanea> Just not with Debug.Trace
13:08:20 <Tanea> And I don't know how
13:08:45 <raek> bjackman: that info should be in the stacktrace, which you should get in your repl
13:09:15 <bjackman> ah i wasnt using a repl
13:09:48 <bjackman> Is there a way to run "main" from a repl?
13:10:03 <raek> if you use a very basic repl you might only get the name "StackOverflowError". if so, you need to run (.printStackTrace *e)
13:10:10 <typoclass> bjackman: try ":l abc.hs" and "main"
13:10:20 <raek> bjackman: of course. just (require 'your.ns) and then call (main ...)
13:10:32 <bjackman> but how do I mock getArgs
13:10:32 <typoclass> raek: hello, this is #haskell. are you sure you're in the right window? :-)
13:10:44 <raek> haha
13:10:56 <raek> I have this and #cojure next to each other
13:11:02 <raek> sorry... :-)
13:11:11 <bjackman> haha never mind
13:11:22 <bjackman> ummmm
13:11:30 <raek> (ignore me)
13:11:35 <bjackman> so is there any way at all to track down the function that's causing a stack overflow?
13:11:41 <bjackman> (in haskell lol)
13:12:17 <cmccann> a stackoverflow in haskell can mean something rather different than other languages
13:12:54 <cmccann> though first, make sure you're compiling with optimization enabled
13:13:10 <typoclass> bjackman: if all else fails, try the option "+RTS -xc" when running the program: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-debugging
13:13:13 <typoclass> @where stacktrace
13:13:13 <lambdabot> compile with -prof -fprof-auto -rtsopts and run with +RTS -xc
13:13:33 <typoclass> bjackman: ... but probably folks in here will figure it out in minutes, if you put your code on hpaste.org :-)
13:15:14 <bjackman> ok ill try all those options first
13:15:15 <cmccann> generally a stackoverflow means you've written a recursive function with a lazy accumulator of some sort
13:15:29 <cmccann> foldl being the best built-in way to make this mistake
13:15:52 <bjackman> yeah i'd read that
13:16:09 <bjackman> and I only have one candidate recursive function
13:16:23 <bjackman> but i tested from the repl with the same size input that was causing the error and it worked fine
13:17:07 <cmccann> well, hpaste the code if you can't find anything
13:18:13 <hpaste> bjackman pasted “knapsack by enumeration” at http://hpaste.org/87289
13:18:53 <bjackman> wow
13:19:00 <bjackman> hpaste bot is a stroke of genius!
13:19:17 <dmwit> ?src sum
13:19:17 <lambdabot> sum = foldl (+) 0
13:19:21 <bjackman> i've actuall just noticed another of my functions could be the problem
13:20:24 <bjackman> but it also doesn't error at the repl
13:23:14 <yitz> bjackman: maximumBy ought to get you a stack overflow quite nicely
13:25:03 <yitz> bjackman: combinations might work too. but you can't run that one with a really huge list anyway, so maybe not.
13:26:43 <bjackman> yitz: I did think that they were both possible culprits, but when I run them from the repl with inputs of size 200 (which is the input size that's causing the error), they work fine (except of course combinations goes on and on and on)
13:29:21 <yitz> > let maximumBy _ [only] = only; maximumBy f (head:tail) = let tm = maximumBy f tail; ordering = f head tm in if ordering == GT then head else tm in maximumBy (<) [1..200]
13:29:22 <lambdabot>   Couldn't match expected type `GHC.Types.Ordering'
13:29:23 <lambdabot>              with actual ...
13:29:36 <yitz> > let maximumBy _ [only] = only; maximumBy f (head:tail) = let tm = maximumBy f tail; ordering = f head tm in if ordering == GT then head else tm in maximumBy compare [1..200]
13:29:38 <lambdabot>   200
13:29:49 <yitz> yeah 200 isn't enough to trigger it
13:31:01 <bjackman> although.. the list returned by combinations would have a size of 200!
13:31:53 <bjackman> which is more than the number of atoms in the observable universe
13:32:18 <bjackman> by 300 factors of 10
13:33:21 <Novimundus> is currying similar to pipelining functions
13:33:22 <bjackman> I think this might actually just be that you can't brute force knapsack problems larger than about 10 items
13:33:22 <yitz> bjackman: and your version of it won't return even one of them until it has stored almost all of them in memory
13:33:31 <ski> Novimundus : not really
13:33:36 <Novimundus> Oh. =\.
13:33:49 <bjackman> yitz: i should juist get MORE MEMORY then hahaha
13:33:54 <ski> Novimundus : function composition is more similar to pipelining functions
13:34:10 <Guest46091> But less than the number of ways to arrange the atoms in the observable universe in a list.
13:34:15 <yitz> Novimundus: currying is a great tool to help you pipeline functions though
13:35:08 <ski> Novimundus : currying is the process of turning a function which takes its arguments in a tuple (all at the same time) into a curried function (which takes its arguments one at a time, returning a new function that takes the rest of them; until there's no more arguments to be taken, at which point it computes the result)
13:35:49 <Novimundus> Okay. I don't see how that's different from pipelining.
13:36:20 <dmwit> What is pipelining?
13:36:33 <yitz> @type let f (x, y) = x + y
13:36:34 <lambdabot> <no location info>: not an expression: `let f (x, y) = x + y'
13:36:35 <pete_> I am having great difficulty understanding <*>
13:36:43 <yitz> @type let f (x, y) = x + y in f
13:36:44 <lambdabot> Num a => (a, a) -> a
13:36:45 <cmccann> Novimundus: is a door handle different from opening a door?
13:36:51 <yitz> @type let f (x, y) = x + y in curry f
13:36:53 <lambdabot> Num c => c -> c -> c
13:37:00 <ski> Currying is either something you manually do to the source code, or it's a higher-order function that takes an uncurried function (let's call it "tupled function") and returns a curried function
13:37:16 <cmccann> oh hey ski is talking again :O
13:37:30 <Novimundus> Pipelining -> A series of functions that take in different inputs that modify a persistent input to produce some cumulative output
13:37:49 <pete_> Given: (<*>) :: f (a -> b) -> f a -> f b
13:37:50 <yitz> hi ski. and nice to see you too, cmccann!
13:37:58 <pete_> I am confused about: f (a -> b)
13:38:13 <cmccann> yitz: I never really went anywhere though...
13:38:16 <ski> Novimundus : while function composition takes *two* functions, and "sticks them together" so that the output of one is fed as the input of the outher one, returning a new function which passes its input to the first function, and returns the result of the second function
13:38:23 <pete_> What's an example of a value that's: f (a -> b) ?
13:38:25 <cmccann> we were just wondering the other day why ski hadn't said anything for like a month
13:38:28 <pete_> or an expression
13:38:30 <ski> cmccann : hiya
13:38:31 <dmwit> pete_: [(+)]
13:38:35 <yitz> cmccann: maybe not but we haven't spoken in a while
13:38:44 <pete_> hrm
13:38:51 <dmwit> > [(+1), (*2)] <*> [5, 50]
13:38:52 <ski> and you too, yitz
13:38:52 <lambdabot>   [6,51,10,100]
13:39:00 <cmccann> yitz: yeah I've been really busy off and on in real life with moving and new job stuff
13:39:08 <Hafydd> @hoogle Functor f => f (a -> b)
13:39:08 <lambdabot> Data.Generics.Aliases unGQ :: GenericQ' r -> GenericQ r
13:39:08 <lambdabot> Data.Generics.Schemes everything :: (r -> r -> r) -> GenericQ r -> GenericQ r
13:39:08 <lambdabot> Data.Generics.Schemes everythingBut :: (r -> r -> r) -> GenericQ (r, Bool) -> GenericQ r
13:39:12 <yitz> cmccann: oh congrats on both
13:39:15 <Moggle> lenses: the coolest or the coolest? you decide!
13:39:19 <Moggle> @src lift
13:39:19 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
13:39:27 <Moggle> blergh
13:39:41 <ski> @type [Just cos,Nothing,Just log]  -- pete_ ?
13:39:43 <lambdabot> Floating a => [Maybe (a -> a)]
13:40:09 <Hafydd> @type [cos, sin, tan]
13:40:09 <pete_> [(+2)] and Just cos don't seem particularly useful
13:40:11 <lambdabot> Floating a => [a -> a]
13:40:25 <ski> > fmap (fmap ($ 2)) [Just cos,Nothing,Just log]
13:40:26 <lambdabot>   [Just (-0.4161468365471424),Nothing,Just 0.6931471805599453]
13:40:32 <cmccann> yitz: if memory serves me I was going to send you my resume to pass along a while back and then I ended up getting an interview and an almost immediate offer like the next day, heh
13:40:38 <cmccann> at which point I kinda dropped out of sight for a while
13:40:50 <cmccann> so my apologies if I was rude in vanishing suddenly
13:40:55 <ski> pete_ : it's sometimes useful to put functions into datastructures
13:41:31 <yitz> cmccann: i hope my suggestion to send it played a role in adding to your good luck
13:41:33 <ski> pete_ : imagine `Map Command (CmdArgs -> CmdResult)' or something like that
13:41:34 <pete_> I can see that, but I'm not sure why typeclassopedia is treating <*> like a very big deal
13:41:49 <pete_> I'm sure it is, but I'm not making the mental leap
13:41:54 <dmwit> pete_: Perhaps a better example is a parser that can return one of many constructors as it parses the beginning of a chunk of text.
13:41:55 <cmccann> yitz: your feedback on my resume at the time was actually really helpful, I don't know if I ever actually thanked you for that
13:42:13 <yitz> cmccann: ok great to hear it
13:42:17 <dmwit> pete_: So your parser might have type Parser (BinOp -> Expr -> Expr -> Expr).
13:42:19 <dmwit> or something
13:42:33 <pete_> ok
13:42:45 <ski> Novimundus : btw, i'm not sure i agree with the "modify" and "persistent input" (and maybe not with "cumulative output" either ?) parts -- but i assume you're thinking about stuff like *nix pipelines, aye ?
13:43:05 <ski> dmwit : yeah, better example
13:43:11 <dmwit> pete_: It makes perfect sense (to me at least) to take one of these things and a Parser BinOp and mash them together to get a Parser (Expr -> Expr -> Expr). That's what (<*>) does.
13:43:17 <Novimundus> Not anymore. I'm a total noob to CS, and I saw a Haskell presentation, so I'd bet money what I'm thinking isn't accurately portrayed by my semantics.
13:43:45 <Novimundus> So ignore whatever I'm defining xP
13:44:03 <ski> Novimundus : aye or nay ? :)
13:44:09 <dmwit> Novimundus: Pipelining is about composing functions. Currying is (in part) about making it easy to compose functions.
13:44:30 <Novimundus> dmwit : That makes a lot of sense. Perhaps I was getting lost with ideas.
13:44:38 <Novimundus> ski : I don't know, because I don't know what * nix pipelines are.
13:45:02 <yitz> pete_: e.g. a parser for an IP address might look like: data IP = IP Int Int Int Int; ipParser = IP <$> decimal <*> decimal <*> decimal <*> decimal
13:45:47 <ski> Novimundus : ok, then ignore that ftm
13:45:52 <yitz> oops wait forgot the periods
13:45:56 <ski> Novimundus : sometimes when using a higher-order function (in this case, a function taking another function as argument), you want to pass a function as argument that doesn't "fit" exactly
13:46:20 <dmwit> yitz: just claim "decimal" handles them ;-)
13:46:23 <yitz> pete_: e.g. a parser for an IP address might look like: data IP = IP Int Int Int Int; ipParser = IP <$> decimal <* "." <*> decimal <* "." <*> decimal <* "." <*> decimal
13:46:26 <Novimundus> I can see that being a problem in a strong typed language.
13:46:33 <yitz> dmwit: ha right
13:46:53 <ski> Novimundus : this is commonly because the function you want to use as argument is more general than the function argument you have to pass is supposed to me
13:47:02 <pete_> yitz: Hrm, I'm not sure I know enough for that to have been helpful :)
13:47:07 <ski> Novimundus : it would be a problem in a dynamically typed language as well :)
13:47:12 <Novimundus> Oh.
13:47:15 <pete_> Maybe I should switch back to LYAH for a bit
13:47:22 <yitz> pete_: where <* is just like <*> except it doesn't contribute to the output of the parser
13:47:29 <dmwit> Novimundus: It's not really about strong typing. It's just that curried and uncurried are different calling conventions.
13:47:52 <dmwit> In e.g. Python foo(a)(b) and foo(a,b) are very different things.
13:48:02 <cmccann> dmwit: what's the expectation for haddocks in gtk? is "copypasta from the gtk.org API docs" reasonable?
13:48:10 <ski> Novimundus : so, what you do is you want to make a "specialized version" of the general function -- saying i want to fix this general argument to be this value, say --, and then you can pass the specialized function, because you've specialized it to fit the interface expected
13:48:21 <bjackman> rs0: are you named after an SSH server?
13:48:30 <yitz> dmwit: kind of like the language "99" on the 99-bottles-of-beer site, where the empty program generates the lyrics to 99 bottles of beer.
13:48:34 <dmwit> cmccann: I think most of the Gtk haddocks are copied from gtk.org, perhaps with a bit of markup.
13:48:47 <cmccann> ok cool
13:49:01 <ski> Novimundus : this process of taking a function, and "prefeeding" it with some of its arguments, and getting back a function that only expects the rest of the arguments, is known as *partially applying* the (general) function
13:49:13 <Novimundus> ski : That makes sense.
13:49:34 <dmwit> yitz: "for sufficiently smart parsers"
13:50:03 <ski> Novimundus : now, say `f' is our general function, and that calls to it looks like `f(someFoo,someBar,someBaz)'
13:50:54 <ski> Novimundus : and we want to take `ourBar' and stick it in there, so that we get a new function `g' that will be called later like `g(someFoo,someBaz)', and that will immediatelly then call `f(someFoo,ourBar,someBaz)'
13:52:07 <yitz> pete_: it's simple. you start with the output function into which you want to feed the things you parse, followed by <$>. after that, you put parsers for each thing you want to parse, in order, separated by <*> things. the result is each parsed thing fed into your output function as arguments.
13:52:07 <ski> Novimundus : in some languages, you'd have to define the function `g' here explicitly, giving it a name -- and in case `ourBar' depends on arguments of whatever function we're currently inside, then we'd have to define `g' *inside* the current function
13:52:12 <ski> Novimundus : following, so far ?
13:52:25 <Novimundus> ski : yes.
13:52:37 <yitz> pete_: and if you look at the types of <$> and <*>, it's not hard to see why that works.
13:53:12 <ski> Novimundus : now, say `hof' is the higher-order function, and it's to be called like `hof(someNumber,someFun,somethingElse)'
13:54:07 <ski> Novimundus : and what we want to do is to pass `g' for `someFun' (and some other stuff for the two other arguments) -- and then it (usually) will call `someFun', iow our `g', with `someFoo' and `someBaz' arguments of its choosing
13:54:57 <yitz> bjackman: maybe rs0 *is* an ssh server. the strangest things happen on irc.
13:55:06 <ski> Novimundus : so, by making `g' out of `f', we make `hof' eventually call `f' with `someFoo',`ourBar',`someBaz', where the middle one is of our choosing (possibly depending on local context in the function calling `hof'), while the other two are determined by `hof'
13:55:34 <Novimundus> ski : So this is really just function decomposition and allows swapping out of parts?
13:56:40 <bitonic> is it possible to get an ‘executable’ cabal target pick up the local ‘data-dir’?
13:57:18 <dmwit> bitonic: Perhaps you would be interested in the documentation on the Paths module that cabal generates for you?
13:57:22 <ski> Novimundus : i'm not quite sure what you include in the terms "function decomposition" and "swapping out of parts"
13:57:25 <ski> Novimundus : in Haskell syntax, this might look like `doStuff ... = ..(hof (someNumber,g,somethingElse)).. where g (someFoo,someBaz) = f (someFoo,ourBar,someBaz)'
13:57:41 <bitonic> dmwit: yes, I would
13:57:54 <ski> Novimundus : in the `where', `g' is defined to call `f' with its arguments, and the extra `ourBar' argument
13:58:33 <dmwit> http://www.haskell.org/cabal/users-guide/developing-packages.html#prefix-independence
13:58:33 <Novimundus> ski : all right. I think I get it.
13:58:37 <Novimundus> ski : thanks a lot :-)
13:58:38 <ski> Novimundus : however, note that `g (someFoo,someBaz) = f (someFoo,ourBar,someBaz)' is syntactic sugar to `g = \(someFoo,someBaz) -> f (someFoo,ourBar,someBaz)'
13:59:04 <dmwit> bitonic: That # doesn't seem to work, actually, but if you search for prefix independence, you'll be in the right place.
13:59:47 <ski> Novimundus : where `\(someFoo,someBaz) -> f (someFoo,ourBar,someBaz)' is *the* (not yet named) function, which when called with a pair of arguments, call them `someFoo',`someBaz', will call `f' with a triple of arguments : `someFoo',`ourBar',`someBaz'
14:00:25 * ski wasn't quite finished yet :/
14:00:28 <yitz> ski: oops he's gone
14:00:35 <ski> yea, noticed
14:02:14 <bitonic> dmwit: is it the tip about ‘getDataFileName’?
14:02:20 <dmwit> yes
14:02:32 <dmwit> If that's not enough, perhaps I'm misunderstanding your request.
14:02:47 <dmwit> Hell, even if it *is* enough perhaps I'm misunderstanding.
14:03:17 <bitonic> dmwit: using that, cabal tries to look up in ~/.cabal/share
14:03:21 <bitonic> I want to use it the local files
14:03:43 <dmwit> um
14:03:57 <dmwit> You want it to use ./whatever before it's installed, but ~/.cabal/share after it's installed?
14:04:01 <dmwit> That's not possible, so far as I know.
14:04:18 <dmwit> (Installing just means copying the executable to ~/.cabal/bin, basically!)
14:04:42 <dmwit> You could give your program a command-line parameter that overrides getDataFileName...?
14:04:52 <bitonic> dmwit: it’s very weird because it seems to work for another cabal package I have
14:05:07 <bitonic> well, I use the Paths module in the tests of this package and it gets the right path
14:05:11 <bitonic> (the ‘local’ one)
14:05:24 <bitonic> maybe for tests it *always* uses the local path?
14:06:07 <dmwit> Possibly, yes.
14:07:14 <bitonic> well, I was fooled then!  thanks anyway
14:10:10 <hpaste> arbn pasted “cabal test error” at http://hpaste.org/87290
14:10:54 <arbn> Has anyone else seen an error like that when running "cabal test"? I get an error about TestStub file if I add Cabal as a depend... not sure what's going on.
14:12:49 <yitz> arbn: where did you add Cabal as a dep? it should be in build-depends of the test stanza
14:13:01 <yitz> arbn: what was the "TestStub" error?
14:14:12 <hpaste> arbn pasted “stub error ” at http://hpaste.org/87291
14:14:25 <arbn> yitz: If I add Cabal as a depend, I get that error.
14:15:19 <yitz> arbn: hmm? the error says that you *forgot* to add Cabal as a dep
14:16:19 <arbn> yitz: The second paste.
14:16:28 <yitz> oh ok one sec
14:17:19 <yitz> arbn: do you call stubMain?
14:17:43 <arbn> yitz: Nope. Would you like to see the Test module?
14:18:42 <arbn> yitz: I think this might be related somehow to me importing functions on foreign types.
14:19:13 <hpaste> arbn pasted “test module” at http://hpaste.org/87292
14:20:08 <yitz> arbn: stubMain first appeared in Cabal 1.16. could that have something to do with it?
14:21:09 <arbn> yitz: Yes! I only have Cabal 1.14
14:21:57 <arbn> yitz: So, how should I fix this?
14:23:39 <yitz> arbn: the haddocks say you need to write stubMain directly into the stub. you can look at the source code on hackage: http://hackage.haskell.org/packages/archive/Cabal/1.16.0.1/doc/html/src/Distribution-Simple-Test.html#stubMain
14:26:54 <arbn> yitz: Manually? Can't I just install a newer version of Cabal and depend on that?
14:27:55 <yitz> arbn: hmm. i try very hard to avoid that. maybe it works nowadays, but in the past it caused the package system to become very broken.
14:28:09 <`Jake`> I just upgraded to Ubuntu 13.04. Considering there is no haskell-platform package (yet?), I guess the best way is to install everything I need manually?
14:28:20 <yitz> arbn: i just stick with whatever version of cabal came with the Haskell Platform it came with.
14:28:48 <arbn> yitz: OK. So, I should write stubMain into the autgenerated stub every time?
14:29:35 <yitz> `Jake`: on ubuntu, i usually install the generic binary tarball of ghc, from the ghc site, for the version of ghc that goes with the version of HP that i want. (ignoring the warnings on that site)
14:30:00 <yitz> `Jake`: then i do cabal install haskell-platform-<version>
14:30:10 <`Jake`> yitz: OK, thanks, I'll try that
14:30:17 <yitz> (well cabal update first of course)
14:30:53 <yitz> `Jake`: it takes about 20 min on my machine, so not much lost if it goes wrong.
14:31:03 <`Jake`> yitz: alright
14:36:39 <yitz> arbn: hmm well if its autogenerated you'd want to figure out how to get it in automatically. what test framework are you using?
14:38:09 <quchen> Hello #haskell-trivial. Survey question: how smart would it be to include "add join as a Monad method" in an "Applicative => Monad" scenario? I've reached a point where I would find it desirable, and Hayoo says there aren't many packages that define a "join" function themselves. However, the issue isn't directly related to the proposal, it's more along the lines "when we're messing around in Base anyway, why not include that as well". Of co
14:38:09 <quchen> urse, that wouldn't be worth jeopardizing the entire thing.
14:40:00 <typoclass> quchen: i don't know. why does join need to be in the Monad class? currently it's an extra function outside of the typeclass and any instances, it's just tied to Monad via its constraint, isn't it?
14:40:10 * typoclass purrs happily and has little idea what's going on
14:42:06 <quchen> typoclass: I'm in the planning phase of making an Applicative => Monad proposal. I successfully modified GHC to support it (plus the join change). The next step would be putting the patch in HEAD, going public (as in Reddit or whatever) and have people compile as many modules as they can using the modified GHC. That would be stage 2: getting an overview over how many packages the change will break.
14:42:44 <elliott> getting it in HEAD happens after assessing the problems it'd cause, surely?
14:42:45 <quchen> Next step is asking the maintainers of the breaking packages to please release a version that includes Functor/Applicative instances for their Monads.
14:43:11 <quchen> elliott: I meant "HEAD" as in "a fork of HEAD so we're not doing this with an outdated version".
14:43:33 <ski> typoclass : sometimes it's nicer to define `join' than to define `(>>=)' (i know i've done `instance Monad Blah where ma >>= amb = join (fmap amb ma) where join ... = ...')
14:43:45 <mm_freak> you could replace Applicative f => Alternative f by Functor f => Alternative f along the way
14:43:47 <quchen> Anyway, depending on the previous two steps, we can decide whether it's too broken to be fixed or whether the proposal has a realistic chance of success.
14:44:02 <typoclass> ski: ah ok, i understand. thanks
14:44:20 <elliott> quchen: ah, I see.
14:44:56 <quchen> typoclass: List: join = concat. Reader: join f x = f x x. Maybe: join (Just (Just x)) = x; join _ = Nothing.
14:45:11 <johnw> ski: I typically write join for a new monad, and then use equational reasoning to transform it into the proper >>= definition
14:45:14 <cmccann> with Applicative and Functor as requirements, defining join would be sufficient, and sometimes the easiest way to define the instance.
14:45:24 <quchen> Well, for Maybe it doesn't matter, but the "join" reader version is much simpler if you ask me.
14:45:31 <elliott> including join in Monad seems a reasonable additional change.
14:45:36 <elliott> since it requires a Functor superclass to be meaningful.
14:45:37 <cmccann> especially when join is a sensible and useful operation on its own, e.g. concat
14:45:38 <elliott> they are linked.
14:45:42 <johnw> elliott: it sure does
14:45:51 <eikke> that's the scala definition
14:45:55 <eikke> (iirc)
14:46:15 <cmccann> yeah, I think adding join to Monad makes good sense along with adding Applicative as a requirement
14:46:39 <eikke> if applicative is added, can return be dropped?
14:46:40 <mm_freak> quchen: your Maybe join is wrong, btw
14:46:43 <quchen> The Monad I would propose right now would contain "return = pure; m >>= f = join $ fmap f m; join m = m >>= id".
14:46:50 <quchen> mm_freak: Oh?
14:46:53 <mm_freak> join (Just c) = c
14:47:04 <quchen> mm_freak: Oh, I forgot a Just there.
14:47:22 <quchen> Or it's too verbose. Anyway, this is IRC, which is not typechecked ;-)
14:47:34 <mm_freak> quchen: anyway, keep (>>=) in the class
14:47:41 <quchen> mm_freak: Oh of course
14:47:45 <cmccann> yes, keep (>>=) and (>>)
14:47:50 <quchen> Removing bind would be *very* awful.
14:47:56 <mm_freak> yeah
14:47:59 <johnw> >> isn't in the type class
14:48:04 <johnw> is it?
14:48:07 <quchen> It is
14:48:10 <cmccann> @src Monad
14:48:10 <lambdabot> class  Monad m  where
14:48:10 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
14:48:10 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
14:48:10 <lambdabot>     return      :: a -> m a
14:48:10 <lambdabot>     fail        :: String -> m a
14:48:12 <eikke> johnw: iirc it is, for optimization purposes
14:48:16 <cmccann> yep
14:48:18 <johnw> ah
14:48:26 * typoclass scratches his head
14:48:39 * sipa scratches his HEAD
14:48:40 * dmwit scratches typoclass' head
14:48:56 <typoclass> dmwit: awww, very nice thanks. *purr*
14:49:13 * yitz doesn't even scratch the surface
14:49:23 <mm_freak> if you keep 'return' in the class for now and provide a default implementation of 'join', then most packages will survive the change without breaking…  you probably don't want to use the packages that don't anyway
14:49:28 <typoclass> quchen: i'm slightly uneasy with those typeclasses that have default implementations that refer to each other, meaning you get infinite loops if you overlook something in the haddock. (if it's documented at all.)
14:49:43 <quchen> For the interested: here's what I would suggest. http://codepad.org/fnPkpU6N
14:49:57 <ski> quchen : i'd prefer no `$' there ;)
14:49:58 <eikke> typoclass: there was some discussion about that (and some Trac #) some time ago in here
14:50:11 <mm_freak> then you can slowly migrate away from 'return'
14:50:12 <eikke> typoclass: some {-# MINIMAL #-} pragma IIRC
14:50:12 <cmccann> typoclass: that is annoying but it's an existing problem in other type classes anyway
14:50:18 <elliott> quchen: i think you should inline the default (>>=), pure, join
14:50:20 <elliott> er
14:50:22 <elliott> default return, not pure
14:50:25 <quchen> typoclass: You only get infinite loops only if you don't implement the minimal complete definition, which would be "bind or join" for monad.
14:50:26 * hackagebot hakyll-agda 0.1.2 - Wrapper to integrate literate Agda files with Hakyll  http://hackage.haskell.org/package/hakyll-agda-0.1.2 (FrancescoMazzoli)
14:50:35 <typoclass> eikke: yes i think shachaf had a proposal that typeclasses should know about their "minimal complete definitions" via a new pragma
14:50:41 <eikke> idd
14:50:47 <cmccann> quchen: the annoyance is that technically both are defined, so you don't get a compiler warning about missing definitions
14:50:47 <ski> hm, is there any actual case where `(>>)' is defined ?
14:50:49 <typoclass> eikke: but that's not here yet :-)
14:50:50 <elliott> also, I suggest giving some documentation on return saying that it must be equal to pure
14:51:32 <quchen> cmccann: I've never had an issue with forgetting to define Eq's methods, which has the same issue.
14:51:38 <dmwit> ski: WASH has one of the only ones I've seen. (>>) can make the log a bit shorter than (>>=) can.
14:51:41 <quchen> I'm not sure how realistic that scenario is.
14:51:41 <cmccann> with Eq it's pretty obvious
14:51:41 <elliott> also also, I'd like to reiterate my realisation that having an "apDefault" defined as current "ap" is a good idea
14:51:50 <elliott> since in time, ap = (<*>) and just requiring Applicative should be true
14:51:55 <dmwit> ...I think.
14:51:56 <quchen> elliott: What do you mean with "default return, not pure"?
14:51:56 <elliott> (and hence it would become inappropriate to define Applicative instances with)
14:51:59 <dmwit> My memory is a bit hazy.
14:52:02 <elliott> though that change itself breaks compatibility, so maybe it's irrelevant.
14:52:03 <cmccann> less so in other cases. I think I made an infinite looping instance with Foldable or Traversable once or something
14:52:04 <typoclass> quchen: yes as cmccann said, i was uneasy about an instance that humans will see as obvious junk, but the compiler doesn't reject it
14:52:10 <elliott> quchen: <elliott> quchen: i think you should inline the default (>>=), pure, join
14:52:17 <elliott> s/pure/return/ on that sentence
14:52:24 <quchen> Ah, I see.
14:52:32 <elliott> ski: I think transformers defines (>>)
14:52:32 <mm_freak> what do you guys thinking about replacing the Applicative constraint on Alternative by Functor?
14:52:34 <dmwit> ski: Actually, now that I think of it, maybe what surprised me about WASH was that they defined their own "forever" that was better than the usual one (for their specific monad).
14:52:41 <mm_freak> i'd like that change a lot
14:52:50 <elliott> mm_freak: it's a good idea. Applicative => Monad is a tough enough sell by itself though.
14:52:54 <quchen> The problem is I can't use "ap" in GHC.Base, as importing Control.Monad introduces a circular dependency.
14:52:57 <cmccann> mm_freak: what's the justification of having the constraint there in the first place?
14:53:02 <cmccann> (is there a justification?)
14:53:07 <mm_freak> cmccann: i don't think so
14:53:14 <typoclass> quchen: so how about moving "return = pure" outside the typeclass? btw how about renaming return entirely? :-)
14:53:22 <mm_freak> i'd even split that class in two
14:53:32 <cmccann> mm_freak: my guess is it's mostly there because whoever wrote it was thinking about applicative parsers and nothing else
14:53:33 <quchen> typoclass: That would break all present Monad definitions that implement "return".
14:53:44 <quchen> ... "return isn't a method of Monad BEEEP"
14:53:50 <cmccann> typoclass: yeah, too much gratuitous breakage with little benefit
14:53:59 <mm_freak> the funny thing is that for Arrow you get ArrowZero and ArrowPlus and the constraints are entirely braindamaged
14:54:11 <ski> dmwit : hm .. i wonder whether using corresponding `Applicative' combinators would fill the same purpose
14:54:13 <cmccann> if you're going to break lots of existing instance definitions, start by removing fail
14:54:14 <cmccann> :P
14:54:28 <mm_freak> then you have that MonadPlus, which nobody needs
14:54:53 <quchen> Initially I was a lot more ambitious, but after some talk here I decided that we should keep the changes as minimal as possible. Once we're over the hurdle of the AMP (I'll abbreviate the Applicative => Monad Proposal by now because it's just too long), we can maybe fix the other things in the long run.
14:55:04 <cmccann> are there any situations where a MonadPlus instance would reasonably differ from Alternative for the same type?
14:55:05 <elliott> Alternative => MonadPlus should possibly be included in the change
14:55:11 <elliott> since it'll be a pain to do later.
14:55:12 <ski> (i recall reading an argument for making `ap' a method of `Monad', on the grounds of being able to do better in some circumstances -- though iirc, there they actually wanted to change semantics, not just performance)
14:55:20 <elliott> this is all a very big fuss
14:55:49 <mm_freak> the ultimate solution for this mess is to get rid of ArrowZero, ArrowPlus, Alternative and MonadPlus altogether and replace them by two completely new classes:  Functor => FunctorPlus and FunctorPlus => FunctorZero
14:56:17 <ski> mm_freak : "replacing the Applicative constraint on Alternative by Functor" -- hm, doesn't the `Alternative' laws interact with the `Applicative' methods ?
14:56:39 <cmccann> some type classes have laws that only apply when other instances exist
14:56:40 <dolio> What if I have a definition that uses zero but not plus?
14:56:44 <cmccann> but don't require them
14:56:46 <quchen> I think this is way too much for the proposal. Anyway, I'm in the process of modifying my Gist to include the current status, I'll post it in a couple of mins, feel free to put your comments below then.
14:57:25 <mm_freak> ski: laws?  according to the documentation an Alternative is "a monoid on applicative functors"
14:57:31 <mm_freak> why not a monoid on functors?
14:57:41 <typoclass> quchen: yes there is good reason to keep changes minimal. but there's also good reason against "make breaking changes now, make more breaking changes later". in my opinion it needs to be weighed carefully
14:57:48 <elliott> Alternative and the tuple-based form of Applicative are dual
14:57:54 <cmccann> quchen: it might make sense to have MonadPlus require Alternative since that parallels the main intent of the change
14:58:08 <elliott> f () vs. f Void, f a -> f b -> f (a,b) vs. f a -> f b -> f (Either a b)
14:58:15 <quchen> cmccann: That's true. Hmm.
14:58:22 <elliott> (f Void ~ f a, f a -> f a -> f a ~ f a -> f b -> f (Either a b))
14:58:26 <elliott> (er, swap those.)
14:58:31 <mm_freak> the problem with the Applicative constraint is that you rule out a number of very useful instances
14:58:49 <quchen> The main problem here is that it will be a balance act between "adding everything that is good" and "getting it approved".
14:58:58 <cmccann> elliott: maybe we should rename Alternative to FunctorPlus and Applicative to FunctorTimes, and then require distributivity. that would be entertaining and not break anything at all.
14:59:04 <elliott> Alternative => MonadPlus will be sore if it's not done now
14:59:17 <elliott> because it breaks compatibility in much the same places as Applicative => Monad
14:59:21 <elliott> and is desirable for much the same reasons
14:59:28 <cmccann> yeah, changing Alternative drastically is too much at once, even if it is a good idea (which is true)
14:59:41 <cmccann> but Alternative => MonadPlus does make sense here
14:59:48 <mm_freak> yes
15:00:02 <elliott> in effect it's a deprecation of MonadPlus, or at least the methods in it
15:00:37 <mm_freak> another way is to deprecate MonadPlus
15:00:49 <quchen> Here's the updated Gist: https://gist.github.com/quchen/5501031
15:00:51 <ski> mm_freak : i was thinking of a "left distribution" law
15:01:02 <cmccann> well, deprecating and removing MonadPlus later will be easier later if the Alternative constraint is added
15:01:26 <dolio> @type mfilter p m = do x <- m ; guard (p x) ; return x
15:01:27 <lambdabot> parse error on input `='
15:01:36 <dolio> @type let mfilter p m = do x <- m ; guard (p x) ; return x in mfilter
15:01:37 <lambdabot> MonadPlus m => (b -> Bool) -> m b -> m b
15:02:14 <fizbin> So… in this new world, will WrappedMonad go away?
15:02:44 <mm_freak> ski: (a <|> b) <*> c = a <*> c <|> b <*> c?
15:03:37 <ski> yes
15:03:53 <mm_freak> makes sense, but it's not a law
15:04:05 <fizbin> Also, are there any thoughts to Applicative => Arrow in addition to Applicative => Monad ?
15:04:23 <typoclass> fizbin: sure why not. the proposal has become more extensive by the minute. first Arrow got into it, then monoids, why not WrappedMonad and all kinds of things
15:04:53 <ski> mm_freak : yes, but perhaps it ought to be one ?
15:05:06 <ski> also see
15:05:06 <ski> @wiki MonadPlus
15:05:07 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus
15:05:09 <ski> @wiki MonadPlus reform proposal
15:05:10 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
15:06:24 * ski has always been annoyed by the fact that there's no common (methodless) subclass of `Read' and `Show', embodying the law/constraint exhibited at <http://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18600011.4>
15:07:23 <elliott> methodless subclasses :(
15:07:27 <fizbin> I always thought that WrappedMonad and WrappedArrow existed only to patch over mistakes in the type system. Since the mistakes they patch over seem to be addressed by this proposal, it makes sense to have them go away. (or at least be heavily deprecated)
15:07:49 <ski> mm_freak : anyway, i would possibly be fine with a `FunctorPlus', and a methodless `Alternative' (or whatever you want to call it) subclass -- assuming we decide those laws are useful enough
15:08:35 <mm_freak> ski: i find that proposal very questionable
15:08:51 <ski> elliott : it means documenting someone as being responsible for having checked that the "interaction laws" holds
15:08:58 <typoclass> mm_freak: the Read Show subclass?
15:09:05 <fizbin> As an aside, does anyone know what the ArrowZero class is for? I can't figure out what it means on its own without ArrowPlus.
15:09:08 <mm_freak> typoclass: no, the MonadPlus reform
15:09:27 <mm_freak> fizbin: it has no meaning
15:10:17 <cmccann> it has... B] ...zero meaning
15:10:18 <ski> mm_freak : elaborate ?
15:10:40 <mm_freak> ski: it would make the current mess even more messy
15:10:55 <mm_freak> we don't want to extend MonadPlus…  ultimately we want to get rid of it
15:11:06 <mm_freak> and much less do we want its methods in the Monad class!
15:11:19 <mm_freak> in fact we want to get rid of fail and replace it by a saner mechanism
15:11:40 <ski> fizbin : probably `forall g. zeroArrow >>> g = zeroArrow' and `forall f. f >>> zeroArrow = zeroArrow' ?
15:12:02 <ski> i agree about getting rid of `fail'
15:12:15 <mm_freak> get rid of MonadPlus in favor of Alternative and introduce a new class like MonadFail
15:12:28 <ski> (also, i don't want those methods in `Monad')
15:12:28 <mm_freak> or even fix the definition of MonadError and put it into base
15:12:44 <fizbin> ski: I'm not sure all ArrowZero implementations satisfy that. It'd be nice if they did, but...
15:12:48 <typoclass> mm_freak: (i think a good step would be to write up why precisely the current mess is in fact a mess. if that hasn't been done already)
15:12:54 <ski> (and `MonadFail' would be fine)
15:13:04 <typoclass> mm_freak: i'm not up to date; why do we want to get rid of MonadPlus
15:13:12 <fizbin> ski: Though… let me go check. Maybe they do.
15:13:25 <ski> mm_freak : note that most of what's written on the page was (i think) before `Alternative' was introduced
15:13:29 <mm_freak> typoclass: because except for the left-dist/left-catch stuff it's pretty much redundant
15:13:31 <yitz> change the name of fail to something like defaultDoBind
15:13:38 <monoidal> 'fail' is an autological word
15:13:54 <monoidal> (meaning, it describes itself)
15:14:49 <mm_freak> typoclass: i can summarize it in one sentence:  there is no well-defined 'fail' for State, Reader, Writer, ST, …
15:15:13 <typoclass> mm_freak: sure. no dispute on that :)
15:15:21 <ski> mm_freak : if there's no competing definitions with different semantics for `Alternative' and `MonadPlus', and the laws of the former together with `Monad' laws entail the laws of the latter, then i'd be ok with scrapping `MonadPlus' in favor of `Alternative' (or, a `FunctorPlus', if ditto holds there)
15:15:47 <ski> fizbin : i'd argue that if they didn't, then they're incorrect
15:16:03 <`Jake`> yitz: Erm... cabal tells me there is no haskell-platform package
15:17:00 <geekosaur> it's not a package on hackage
15:17:27 <yitz> `Jake`: oops sorry you're right. download it from http://www.haskell.org/platform/linux.html and follow the instructions there
15:17:34 <`Jake`> alright, thanks
15:17:35 <geekosaur> every haskell platform release is described by a cabal file, which you should be able to download from haskell.org/platform (finding it ... that)
15:17:43 <mm_freak> ski: i've seen type classes which say:  "if an instance of X additionally the following laws should hold:"
15:17:51 <mm_freak> i think that's fine
15:17:52 <ski> mm_freak : my main points are (a) we want to think about what laws we want to hold (and that might mean we need both `FunctorPlus' and `FunctorOr' (or whatever you want to call it)); (b) a methodless subclass of at least two classes can be useful to document that someone has (or ought to have) checked that the reasonable "interaction" laws hold
15:18:22 <mm_freak> ski: i'm fine with that
15:18:29 <ski> (in case the interaction laws are entailed by the laws of the superclasses, then the methodless subclass wouldn't need to exist)
15:18:38 <mm_freak> i'm not trading laws for less constraints
15:19:05 <fizbin> ski: Certainly that law's got to be true for any ArrowZero that's also ArrowPlus and ArrowApply. (by the laws for mzero for MonadPlus)
15:19:10 <mm_freak> Alternative could be such a methodless subclass, just like MonadPlus
15:19:14 <fizbin> So it may be universal.
15:19:18 <mm_freak> MonadPlus and MonadOr
15:19:30 <quchen> ... are there any selling points for the AMP (Applicative => Monad Proposal) you'd like to see in the proposal? I feel like right now I'm not making the point very well in my file.
15:19:43 <mm_freak> both constrained on Alternative, say
15:19:57 <yitz> let's keep in mind that while a rich hierarchy is nice, we also don't want to put a huge burden on anyone who implements a quick monad
15:20:10 <ski> fizbin : yes, but if you have an arrow that's not beed declared as `ArrowPlus' or `ArrowApply', you'd still want those two laws to hold. imho
15:20:19 <typoclass> yitz: very good point
15:20:22 <bitonic> yitz: default instances
15:20:22 <hpc> yitz: it's not undue burden
15:20:25 <quchen> yitz: You can always make a quick Functor/Applicative out of any monad. It's 5 lines.
15:20:34 <hpc> once you have a monad, you are sure as hell going to want to do <*> and <$> to it
15:20:34 <johnw> yitz: even now that we have deriving Functor?  we just need deriving Applicative
15:20:48 <johnw> quchen: like with MonadApply
15:20:57 <quchen> What's that?
15:21:05 <johnw> turns any Monad into an Applicative
15:21:05 <mm_freak> deriving Applicative is far from trivial
15:21:23 <ski> mm_freak : well, "if an instance of X additionally the following laws should hold:" makes me uncomfortable. what happens when a different party unbeknownst makes it an instance of `X' and then a third party tries to combine both modules ?
15:21:33 <yitz> quchen: yes a few more important constraints than what we have now are good, and default methods can indeed help... if they don't cause trouble in practice themselves. i'm just saying let's not go *too* crazy.
15:21:39 <mm_freak> in fact deriving Applicative is impossible
15:21:53 <mm_freak> you can only default-instance Applicative
15:22:12 <quchen> yitz: My main goal here is to maintain as much compatibility as possible. The only problems we're having right now are libs defining their own (<*>) really.
15:22:22 <mm_freak> ski: the whole "laws are just documentation" machinery makes me nervous
15:22:26 <mm_freak> but then this is haskell, not agda
15:22:31 <fizbin> mm_freak: What's the difference between deriving a class and default-instancing a class ?
15:22:32 <yitz> and auto deriving should be thought about very carefully (cf. GeneralizedNewtypeDerving. it was a wonderful idea, but ...)
15:22:36 <johnw> mm_freak: why is deriving Applicative so hard?
15:22:37 <quchen> yitz: Fixing GHC is mainly an issue of adding boilerplate Applicative definitions. :-)
15:22:53 <mm_freak> fizbin: the former invents semantics
15:22:56 <elliott> quchen: do yo have something to say re: the standard "we should wait for superclass instances" objection?
15:23:09 <bitonic> fizbin: <http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html>
15:23:22 <mm_freak> johnw: data MyList a = Empty | Cons a (MyList a)
15:23:29 <mm_freak> what would a derived Applicative class look like?
15:23:31 <quchen> elliott: I didn't catch that objection. What do you mean with it?
15:23:33 <bitonic> fizbin: actually it might not be there
15:23:37 <ski> mm_freak : *nod*
15:23:44 <bitonic> fizbin: ah yes, ‘7.6.1.4. Default method signatures’
15:23:47 <quchen> elliott: Are you referring to my "phase 2: mail package maintainers to add Applicative instances"?
15:24:16 <bitonic> fizbin: you’d have ‘default pure :: Monad m => a -> m a; pure = return’
15:24:26 <bitonic> and same for (<*>) and fmap
15:24:32 <finishingmove> is haskell a good choice for things like machine learning and AI ?
15:24:38 <mm_freak> finishingmove: yes
15:24:41 <ski> johnw : i suspect that in some specific sense, there can be at most one (lawful) `Functor' instance, but may be many valid `Applicative' ones
15:24:42 <elliott> quchen: the proposed default superclass instances extension
15:24:43 <bitonic> @faq can Haskell do machine learning and AI?
15:24:43 <lambdabot> The answer is: Yes! Haskell can do that.
15:24:46 <fizbin> bitonic: ok.
15:25:19 <fizbin> @faq Can Haskell do everything?
15:25:19 <lambdabot> The answer is: Yes! Haskell can do that.
15:25:31 <quchen> elliott: I haven't heard of that. Is it an extension that would automatically derive Applicative for my Monads?
15:25:34 <bitonic> @faq can Haskell?
15:25:34 <lambdabot> The answer is: Yes! Haskell can do that.
15:25:41 <johnw> mm_freak: Empty <*> _ = Empty; _ <*> Empty = Empty; Cons f fs <*> Cons x xs = Cons (f x) (fs <*> xs)
15:25:44 <typoclass> quchen: what does this mean? "The goal of this proposal is maintaining compatibility at all possible cost." -- "want to keep code changes minimal"?
15:25:55 <fizbin> @faq The walrus.
15:25:55 <lambdabot> The answer is: Yes! Haskell can do that.
15:26:14 <mm_freak> johnw: and how would the compiler know i wanted that one?
15:26:15 <finishingmove> @faq Can Haskell make the world a better place?
15:26:15 <lambdabot> The answer is: Yes! Haskell can do that.
15:26:16 <quchen> typoclass: "Don't do fancy things like removing fail"
15:26:33 <finishingmove> ok, i'm sold...
15:26:33 <quchen> typoclass: Basically I meant to say "let's not overshoot it".
15:26:36 <johnw> mm_freak: how do you mean?
15:26:38 <hpc> confession: i like fail
15:26:47 <mm_freak> johnw: you are assuming that MyList is ZipList
15:26:48 <elliott> quchen: yes
15:27:09 <quchen> elliott: That sounds very helpful to our cause here.
15:27:11 <elliott> quchen: issues being too strict superclass constraints, no definite semantics, no implementation effort, etc.
15:27:27 <johnw> mm_freak: ah
15:27:37 <elliott> but a lot of people think it's a magic wand that will remove the need to ever break backwards compatibility like this, which has stalled discussions on this topic before
15:27:48 <yitz> i hate fail. but it would be hard to remove it without causing a huge amount of... well, you know.
15:27:51 <mm_freak> you can't derive Applicative without making semantics assumptions
15:28:45 <quchen> elliott: Hm. It sounds useful, but it also makes me wonder whether it's a little odd when Haskell automatically derives superclasses.
15:28:55 <quchen> elliott: With a compiler warning I'd be OK with it.
15:29:08 <mm_freak> johnw: to expand, the compiler can't check the laws, so for the definition you just gave it could add:  pure x = Cons x (Cons x Empty)
15:29:39 <quchen> elliott: How likely is that to be implemented though? This proposal will take long enough on its own already I think
15:29:59 <mm_freak> there are infinitely many type-correct ways to write 'pure', but only one that satisfies the laws
15:30:02 <quchen> Waiting for something that may or may not be proposed, discussed, implemented may be a little much
15:30:04 <ski> quchen : see "Supertyping Suggestion for Haskell" <http://repetae.net/recent/out/supertyping.html>,"Class Alias Proposal for Haskell" <http://repetae.net/recent/out/classalias.html> by John Meacham, and also <http://www.haskell.org/haskellwiki/Superclass_defaults>
15:30:39 <yitz> ski: with particular attention to the dates of those pages
15:30:55 <yitz> they are great proposals btw
15:31:14 <johnw> mm_freak: I guess the other definition is something like: Empty <*> _ = Empty; _ <*> Empty = Empty; Cons f fs <*> Cons x xs = join $ Cons (fmap (f $) xs) (Cons (fmap ($ x) fs) Empty)
15:31:44 <johnw> oh, another cons in there
15:31:50 <mm_freak> johnw: "the" other?  there are likely many others
15:31:53 <typoclass> quchen: ah i see. how about writing "For compatibility, this proposal considers only this single change."
15:32:04 <johnw> well, this is the non-deterministic variant
15:32:07 <johnw> but I see what you mean
15:32:55 <mm_freak> johnw: deriving Functor is easy, because a derived Functor instance is unique and satisfies the functor laws
15:33:04 <johnw> yeah
15:33:10 <johnw> thanks for clarifying
15:33:14 <mm_freak> deriving Applicative has neither of those properties
15:33:20 <mm_freak> sure
15:34:43 <elliott> quchen: I am not proposing you include its implementation in the proposal
15:35:08 <elliott> I am saying that the existence of the (flawed) superclass instances proposal will be used as an objection against making this breaking change
15:35:30 <dmwit> ski: As I recall, it used internal implementation details and assumptions that forever "never returns", so I'm skeptical that generic combinators could reproduce what they did there.
15:35:39 <dmwit> Though I've been wrong before!
15:35:43 <quchen> elliott: Wait - does that thing exist already, or is it in the "figure out how" stage?
15:35:57 <elliott> ?
15:36:03 <FreeFull> I have an STM question
15:36:15 <quchen> elliott: How can something not currently implemented be an objection?
15:36:24 <johnw> FreeFull: yay!  i love STM
15:36:27 <FreeFull> If you have a bunch of threads writing to the same TChan, will there be any failed transactions?
15:36:28 <quchen> elliott: I.e. how bad is the situation ;-)
15:36:38 <cmccann> quchen: ah, so naive :P
15:36:48 <FreeFull> Failed as in the transaction restarts
15:36:52 <elliott> quchen: because if it were implemented and did work as perfectly as one would like, you could avoid breaking almost any compatibility whatsoever and get shorter instances to boot
15:36:56 <ski> dmwit : mhm, ok
15:37:05 <elliott> hence the argument is "let's not do this -- default superclass instances are a better way"
15:37:22 <johnw> FreeFull: very likely
15:37:40 <typoclass> quchen: they'll say "we don't need the AMP, because in 3 months we'll have superclass whatnots anyway. the AMP would just be wasted effort"
15:37:45 <cmccann> i.e. "let's not do any incremental improvements until we figure out the one Grand Unified Improvement that will solve everything and give everyone a pony"
15:37:57 <johnw> FreeFull: if thread A tries to write to the TChan at the same time as thread B, one of them will restart
15:38:15 <FreeFull> Aw
15:38:19 <typoclass> quchen: (question is of course, how sure are we that the stuff arrives "soon", and how soon is "soon")
15:38:35 <johnw> FreeFull: what were you expecting?
15:38:47 <quchen> I see. It would basically be a very pragmatic approach of the type "let's not fix the issue but find a fix for the issue".
15:38:58 <quchen> ... issue
15:38:59 <johnw> FreeFull: STM doesn't work by using locks to stop B in its tracks while A is writing to the TChan
15:39:23 * quchen just thought of the Swiss Army Rock
15:39:35 <FreeFull> johnw: I was hoping that since the order when multiple threads write to a TChan doesn't matter, they wouldn't conflict
15:39:51 <FreeFull> At least, as long as they aren't reading from it too
15:40:49 <johnw> FreeFull: STM means that the value of the TChan can change out from underneath another thread while they are in the same atomic block.  But I'd do some testing before determining that the performance is bad
15:40:52 <mm_freak> FreeFull: if the write to the TChan is the only operation in the transaction, it's not going to be that bad
15:40:53 <johnw> s/can/can't
15:41:08 <mm_freak> FreeFull: you basically get about the same behavior as a regular Chan
15:41:56 <quchen> elliott: I'm not sure how to counter that argument beyond calling it "hacky". :-/
15:41:58 <FreeFull> Let's say there is one thread that exclusively reads from the TChan, and a bunch of threads that exclusively write to it (a sort of funnel arrangement)
15:42:13 <johnw> yeah, even a transaction restart isn't going to be too much work in that case
15:42:19 <FreeFull> How bad it is going to be compared to there being a tchan for each thread?
15:42:21 <eikke> If I do trickery like "data A, data B, data C a where A :: C A, B :: C B", is there a way to define "foo :: C A -> C a" which can yield both "A A" and "B B"?
15:42:33 <eikke> euh, A and B in the end
15:42:44 <quchen> elliott: On the other hand, the superclass deriving would make the AMP a somewhat trivial change, wouldn't it?
15:42:47 <mm_freak> FreeFull: that's totally fine, but i'd recommend separate TChans regardless
15:42:52 <typoclass> FreeFull: sounds perfectly fine to me. you think it's going to be bad?
15:43:04 <FreeFull> eikke: Maybe    foo A = undefined
15:43:52 <eikke> FreeFull: not 'any code', obviously
15:44:23 <elliott> quchen: sure, if anyone knew how it worked (e.g. interaction with orphan instances) and wanted to put the effort into implementing it instead of just trotting it out as an objection :p
15:44:31 <elliott> and you'd still have it producing overly restrictive Applicative instances etc
15:44:56 <ski> elliott : not sure what you're after. elaborate ?
15:45:34 <ski> er
15:45:44 <ski> eikke : not sure what you're after. elaborate ?
15:45:50 <eikke> ski: working on a paste
15:45:59 <FreeFull> eikke: I can't think of any non-bottom way myself
15:46:02 <mm_freak> FreeFull: keep in mind that restarts would still happen and livelocks become more likely with higher load
15:46:15 * ski is imagining a bowl of pasta
15:46:18 <mm_freak> that's why i recommend separate TChans or even regular Chans, if you don't actually use transactions
15:46:30 <elliott> ski: not sure who you're after, elaborate? :P
15:46:37 <FreeFull> Chans would work fine in this arrangement?
15:46:47 <mm_freak> sure
15:46:58 <FreeFull> Ok, will keep that in mind
15:47:03 <johnw> mm_freak: if he uses multiple TChans, then his reader thread would just loop through and consume from all of them in what, one transaction or many?
15:47:19 <mm_freak> johnw: one, of course
15:47:26 <ski> > repeat "elliott : meet eikke : meet "
15:47:28 <FreeFull> It was just a random question that was lingering in my head
15:47:30 <lambdabot>   mueval-core: Time limit exceeded
15:47:32 <johnw> ok
15:47:49 <mm_freak> but in a "funnel" arrangement you would want to have a single Chan
15:49:11 <FreeFull> So the takeaway is "only use STM where it matters"?
15:49:19 <jmcarthur> i wouldn't say that
15:49:21 <johnw> i use it everywhere
15:49:30 <mm_freak> FreeFull: i use it pretty much everywhere
15:49:45 <mm_freak> but there are cases where STM may be harmful
15:49:52 <jmcarthur> i see no reason not to prefer TVar and TChan unless there is some performance reason not to (which is rare)
15:50:00 <mm_freak> but that's not a fault of STM
15:50:04 <FreeFull> Say, if you would write concurrent code that doesn't need locks
15:50:07 <jmcarthur> STM is a pretty good default for shared data, is all i mean
15:50:13 <mm_freak> it's the way it's currently implemented
15:50:26 <mm_freak> restarts aren't exactly the best way to go
15:51:29 <jmcarthur> TChans can actually be faster than Chans sometimes since they don't require taking multiple locks for every enqueue/dequeue operation
15:51:37 <hpaste> eikke pasted “Magic” at http://hpaste.org/87294
15:51:40 <eikke> ski: ^^
15:52:21 <johnw> also, if you don't need dup/clone, TQueue can perform better
15:52:24 <ski> @tell fizbin anyway, re `zeroArrow' laws, see <http://en.wikipedia.org/wiki/Zero_morphism>,<http://en.wikipedia.org/wiki/Preadditive_category>,<http://en.wikipedia.org/wiki/Zero_object>
15:52:24 <lambdabot> Consider it noted.
15:52:25 <FreeFull> jmcarthur: Is the locking done by the code using the Chan or by the implementation?
15:53:00 <mm_freak> FreeFull: the implementation
15:53:21 <FreeFull> I do like the idea of message passing rather than locks
15:53:23 <jmcarthur> FreeFull: the Chan implementation involves MVars. nothing wrong with that. just not the fastest for every possible use. neither is TChan
15:53:49 <parcs> use TQueue. its implementation is dead simple and it's fast
15:53:57 <mm_freak> FreeFull: the way you program in regular concurrent haskell is waiting, not locking
15:54:00 <mm_freak> you never lock
15:54:05 <jmcarthur> i think locks, message passing, transactions, etc. all have their places and that dogmatic adherence to just one is foolish
15:54:13 <hpc> jmcarthur: agreed
15:54:14 <mm_freak> STM improves this by allowing to fork your waiting
15:54:21 <hpc> jmcarthur: write code to look like what it does
15:54:25 <mm_freak> and to have transactions, of course
15:54:27 <ski> eikke : neither your `demo' nor your `loop' typechecks
15:54:37 <ski> eikke : as i suspected, it appears you want existentials
15:54:40 <FreeFull> mm_freak: Which is why Haskell is often listed as one of the top languages for concurrent code
15:55:00 <mm_freak> i noticed that many people forget that STM's killer feature is not transactions, but that little combinator called (<|>)
15:55:09 <mm_freak> that's what makes STM /really/ powerful
15:55:15 <FreeFull> Having to write code with locks is just asking for bugs
15:55:25 <jmcarthur> *GHC's flavor of STM
15:55:25 <eikke> ski: hm.. uh? :D
15:55:30 <hpc> mm_freak: (<|>) is the killer feature of just about everything that has it
15:55:47 <mm_freak> hpc: true =)
15:55:48 <jmcarthur> (>>=) is pretty killer!
15:55:55 <ski> eikke : judging from the code, it appears you want essentially `demo :: C A -> exists a. C a' and (maybe ??) `loop :: (forall a. C a) -> Int'
15:55:56 <mm_freak> (>>=) is too killer
15:55:56 <quchen> mm_freak: <|> = orElse?
15:56:01 <FreeFull> I like (<*>)
15:56:07 <mm_freak> quchen: in the case of STM, yeah
15:56:17 <quchen> And empty = retry I assume
15:56:26 <eikke> ski: I thought all I needed was `demo :: C A -> (forall a. C a)`, but that seems not to be the case
15:56:28 <mm_freak> i'm not actually that fond of monads
15:56:29 <ski> eikke : however, that alternative signature for `loop' wouldn't work with you passing `A False' (of type `C A') to it in `main'
15:56:47 <hpc> eikke: forall in that position is the same as forall in the typical position
15:56:47 <FreeFull> The STM code I saw used orElse and retry directly rather than <|> and empty
15:56:50 <hpc> it's not a higher ranked type
15:57:07 <eikke> hpc: indeed
15:57:17 <quchen> FreeFull: msum uses them implicitly, I've seen that used a couple of times
15:57:30 <eikke> ski: so basically you're saying I cant do what I intend to do?
15:57:33 <ski> eikke : however, if you want to return a `C A' or a `C B' depending on the value of the input, then it seems you indeed want an existential
15:57:33 <quchen> (That brings us back to Alternative => MonadPlus) :-)
15:57:46 <mm_freak> FreeFull: there is no reason to go with those ad hoc names though…  if you have (<|>), you should use it
15:57:48 <FreeFull> MonadPlus is cool
15:58:08 <FreeFull> mm_freak: I haven't actually used orElse or retry yet either =P
15:58:28 <eikke> use case: 'C a' is the state of an FSM, and the 'a' denotes what position the FSM is in, so I can encode specific handlers only take a specific input state, and most of them can return 'any' other state, depending on the input event (hence the demo signature)
15:58:39 <ski> eikke : saying `demo :: C A -> (forall a. C a)' is equivalent to saying `demo :: forall a. C A -> C a' (which means `demo :: forall a. (C A -> C a)', if you were unsure), which is what your present `demo :: C A -> C a' amounts to (the `forall' is implicit there, gets inferred)
15:59:22 <ski> eikke : saying `demo :: C A -> (forall a. C a)'/`demo :: forall a. C A -> C a' means you promise to be able to return a `C a' for *any type* `a' the caller wants
15:59:23 <FreeFull> Although so far the only program I wrote using STMs is a demonstration of how threads don't operate in lockstep, and if you don't think you'll have race bugs
15:59:57 <eikke> ski: I guess that could be fixed using kinds and ghc 7.6
16:00:12 <ski> eikke : however, that's not what your code wants to do : it wants to decide for itself what the type `a' will actually be (depending on the argument value), so that the caller will have to put up with any type `a' `demo' chooses
16:00:23 <eikke> indeed
16:00:28 <mm_freak> btw, there is an alternative to STM, which is sometimes useful:  write a manager thread and communicate with it through an MVar
16:00:40 <mm_freak> reason is that such a manger thread can perform IO as part of its transactions
16:01:01 <FreeFull> How could demo choose? There are only two possible inputs, one of which is bottom
16:01:25 <ski> eikke : "so basically you're saying I cant do what I intend to do" -- i'm not saying that -- i'm just trying to explain why the current signature is not what you (apparently) want, and also trying to determine exactly what it is you do want (and then perhaps give a way to do that)
16:01:39 <eikke> ski: appreciated
16:02:33 <ski> eikke : do you understand why `demo :: C A -> exists a. C a' would express what you want ?
16:02:57 <eikke> ski: yes, but I never saw 'exists' being used in Haskell
16:03:03 <FreeFull> ski: What would the implementation look like?
16:03:33 <eikke> does haskell do existentials? :-/
16:03:45 <monoidal> uhc has "exists"
16:03:58 <ski> eikke : note that a `forall' in the result type (or wrapped around the whole type) means that the caller/user decides what actual type the type variable should be (and the callee have to be able to work with that choice)
16:04:16 <eikke> yup
16:04:25 <ski> eikke : otoh an `exists' in the result type means the *callee* gets to decide the actual type (possibly depending on values of arguments), and the *caller* have to be able to work with whatever choice the callee makes
16:04:29 <eikke> and (I think) I want it the other way around
16:05:07 <ski> FreeFull : `A :: Bool -> C A', the input is a `C A', the bool decides
16:05:07 <FreeFull> I'm thinking that if I'll ever want a more powerful type system than Haskell's, I'll just use Idris
16:05:44 <FreeFull> ski: I thought A was a constructor with no arguments
16:06:23 <ski> eikke : GHC doesn't have a `exists' keyword, but i think it's useful to state things in these terms (rather than the more roundabout encoding in terms of an auxilary datatype), to explain the concept, and to determine what type signatures you actually want
16:06:48 <ski> eikke : we'll have to use the encoding if you want to use GHC, though
16:07:05 <ski> FreeFull : see <http://hpaste.org/87294>
16:07:48 <eikke> I was afraid I was going to need a wrapper datatype anyway :)
16:08:33 <FreeFull> I see
16:08:42 <ski> eikke : anyway, so assume `demo :: C A -> exists a. C a' would work as expected. then the `demo c' call in `loop' would return something of type `C a', for an *unknown* type `a'
16:09:11 <ski> however, this situation can already happen with out existentials
16:09:14 <ski> if we had
16:09:21 <ski>   foo :: forall a. C a -> String
16:09:28 <ski>   foo c = case c of
16:09:29 <eikke> ski: that was a typo, the 'a' in loop
16:09:46 <ski>     A b -> "It's an A : " ++ show b
16:09:55 <ski>     B   -> "It's a B"
16:10:12 <ski> eikke : which ?
16:10:23 <eikke> loop :: C A -> Int
16:10:30 <ski> oh, fine
16:10:45 <ski> (but i'll continue with the `foo' example anyway, just to explain the similarity)
16:10:53 <eikke> I added a wrapper (data RC = RA (C A) | RB (C B)) and adapted demo accordingly (demo :: C A -> RC), which works of course
16:11:28 <ski> since we have a `forall' (around the whole type) here, the caller of `foo' gets to decide what type `a' is
16:11:39 <ski> so that means, to `foo', the type `a' is *unknown*
16:11:39 <FreeFull> eikke: I wonder if you could have used Either there
16:11:53 <eikke> FreeFull: my FSM has more than 2 states :)
16:12:01 <FreeFull> Fair enough
16:12:10 <ski> this is the same situation as your `loop' is in, after calling `demo c' and getting back a `C a', for an unknown type `a'
16:12:16 <eikke> and I dislike reusing things like Either to represent anything at all
16:12:29 <ski> the difference is that in the `loop' case, the unknown type `a' comes from *returning* a result from a call to `demo'
16:12:49 <ski> in the `foo' example above, it simply comes from an argument of (the *polymorphic*) `foo'
16:12:57 <eikke> yup
16:13:28 <ski> anyway, in *either* case can we still patternmatch on the `C a' (we know what data type `C' is, and what constructors it has (including types))
16:13:54 <ski> and, by matching, we can (sometimes, such as in this case) *recover* what type `a' actually was (because `C' was a GADT)
16:14:08 <eikke> that was the whole idea ;)
16:14:26 <ski> so, in the `A b' branch, we know that we actually matched on a `C A', and in the other branch, on a `C B'
16:14:41 <ski> so, it has recovered information that `a' is `A' in one branch, and is `B' in the other
16:15:02 <ski> now, your `loop' only returns an `Int', so it's not making much use of this extra information
16:15:13 <eikke> just a demo, obviously
16:17:24 <ski> but if it was returning `Blah a', then it could actually return a `Blah A' in one branch, and a `Blah B' in the other one
16:17:24 <ski> (and yes, you possibly know most of this already. i'm just trying to connect it to the existential stuff, stating it explicitly)
16:17:24 <eikke> ski: thanks :)
16:17:24 <eikke> I indeed should've thought a bit more upfront *oops*
16:17:24 <ski> anyway, i *thought* that you actually wanted `loop :: (forall a. C a) -> Int' there
16:17:25 <eikke> nope
16:17:45 <ski> because if you pass in a *polymorphic* thing, of type `C a', for any type `a' *`loop'* (not `main') wants, then it could decide that `a' is to be `A', so that it could pass it to `demo' (which wants a `C A')
16:18:17 <ski> but then the code in `main' wouldn't work, since it passes a `C A', not a polymorphic one of type `forall a. C a'
16:18:45 <ski> but, of course a plain `loop :: C A -> Int' would work fine here, since it's what you actually want to pass to `demo', as well as what `main' wants to pass
16:19:06 <ski> eikke : ok, so the existential
16:19:21 <ski>   demo :: C A -> exists a. C a
16:19:34 <ski> there's two basic ways you could encode this
16:19:49 <ski> one is using an "existential datatype"
16:20:00 <ski> the other is using CPS (Continuation-Passing Style)
16:20:14 <ski> you can define
16:20:42 <ski>   data SomeC = forall a. WrapC (C a)
16:20:45 <eikke> don't want to go the CPS route, would clutter things too much and one of the goals is being able to simply validate the FSM follows the spec (or as much as possible, that is)
16:20:57 <ski> this declaration means that
16:21:02 <copumpkin> ski: that's one of those things that should be a newtype but can't be :(
16:21:08 <ski>   WrapC :: forall a. C a -> SomeC
16:21:26 <eikke> hmh, interesting approach, and maybe better than my RC thing
16:22:46 <ski> which is logically equivalent to `WrapC :: (exists a. C a) -> SomeC', which is what we want if we're going to replace `demo :: C A -> exists a. C a' by `demo :: C A -> SomeC'
16:23:09 <eikke> ski: cool!
16:23:09 <ski> however, you'll now need to manually wrap in `demo', and unwrap when you want to get the result out
16:23:09 <eikke> fair enough
16:23:10 <ski> an equivalent (but perhaps more scrutable) way of declaring `SomeC' is by a GADT :
16:23:10 <ski>   data SomeC
16:23:10 <ski>     where
16:23:13 <ski>     WrapC :: C a -> SomeC
16:23:20 <ski> (you may add `forall a.' in there, if you want to)
16:23:30 <ski> eikke : the CPS approach is to define
16:23:58 <ski>   withDemo :: C A -> (forall a. C a -> o) -> o
16:24:21 <ski>   withDemo (A b) k = if b then k B else k (A True)
16:25:18 <ski> so, instead of calling `..(demo c)..', you now have to call `withDemo c (\r -> ..r..)
16:25:53 <ski> eikke : so, you would only have to CPS the calls to `demo', not *everything* that calls it
16:25:57 <eikke> I feel like the wrapper encoding will be easier to maintain / explain to others
16:26:22 <ski> copumpkin : yeah, conservativeness
16:26:50 <copumpkin> EVIL
16:27:26 <shachaf> copumpkin: Didn't dolio have an argument that it shouldn't be newtype?
16:27:26 <ski> i suppose in an implementation with type(-representation)-passing, an existential `newtype' wouldn't work
16:27:42 <copumpkin> dolio: do you have an argument that it shouldn't be newtype?
16:27:58 <ski> (does/did JHC work like that ? or maybe i'm thinking of one of the others ? NHC ?)
16:28:19 <eikke> ski: thanks for all input, really
16:28:27 * eikke off now, time to catch some sleep
16:29:12 <ski> eikke : depending on how many existentials you need, you might want `data Some f = forall a. Wrap (f a)' and `Some C' (or something similar) instead
16:29:37 <Bor0> I have a couple of questions regarding lambda calculus (and I'm pretty much confused about it, just started self-learning). why do we define 0 to be equal to λf.λx.x ?
16:30:06 <shachaf> Bor0: Why not?
16:30:16 <ski> (one could add class constraints, or an extra parameter for a class to constrain by .. ior an extra type function)
16:30:23 <Bor0> why simply not, let's say λf.0
16:30:31 <elliott> what is 0? you are defining 0.
16:30:52 <NemesisD> today i learned about viewpatterns. they're pretty cool
16:31:03 <ski> Bor0 : the intuition here is : represent a natural number `n' by "do it `n' times"
16:31:05 <Bor0> as wikipedia states, λx.x <=> f(x) = x, so why not have λx.0 <=> f(x) = 0 ?
16:31:23 <elliott> because all lambda calculus has is functions.
16:31:26 <coppro> ^
16:31:27 <elliott> there is no notion of 0.
16:31:32 <elliott> you are encoding 0 in terms of functions
16:31:51 <ski> Bor0 : if "it" is a function `f', and we're acting on `x', then "doing it twice" means `f (f x)', and "doing it thrice" means `f (f (f x))'
16:31:58 <Bor0> so it has no constants, but operations (such as multiplication of functions) are allowed?
16:32:13 <ski> Bor0 : "doing it once" means `f x', and "doing it zero times" means `x'
16:32:28 <cmccann> one operation is allowed, namely applying a function.
16:33:08 <Bor0> I don't understand, on wikipedia they relate this with exponents (f^n)
16:33:20 <cmccann> that's a shorthand notation
16:33:25 <Bor0> so, when we "apply", we are actually using multiplication (i.e. exponents) ?
16:33:35 <cmccann> f^3 = (\x -> f (f (f x)))
16:33:57 <cmccann> no, the exponent here means applying the same function multiple times
16:34:03 <watch> anyone have a link to some good Data.Graph examples? I'm trying to implement something that requires depth-first travesal
16:34:05 <watch> traversal*
16:34:09 <cmccann> there is no multiplication or exponentiation in plain lambda calculus
16:34:21 <cmccann> or numbers, or anything that isn't a function
16:34:53 <ski> Bor0 : however, we don't want to decide on what `x' to act, so we abstract over `x' : `λ x. x',`λ x. f x',`λ x. f (f x)',`λ x. f (f (f x))',&c. -- these are "the identity function" (sometimes written `1' or `I'),`f',`f ∘ f',`f ∘ f ∘ f',&c.
16:34:58 <Bor0> I see, okay, that cleared something up. how about this one: λn.λf.λx.f (n f x). how does this expression represent successor? I can't even evaluate that in my mind (note. I'm coming from imperative programming languages background)
16:35:42 <elliott> Bor0: it's adding "one more f"
16:35:53 <elliott> f^(n+1)(x) = f(f^n(x))
16:35:53 <ski> Bor0 : and these would sometimes be written as `f⁰',`f¹',`f²',`f³',&c.
16:36:08 <cmccann> Bor0: if n is a function that takes two arguments f and x, and applies f to x some number of times, then that function applies f one more time than n does
16:36:49 <monoidal> it might be written, using Haskellish notation, as (succ n) f = f . n f
16:37:08 <Bor0> elliott, could you please explain how you evaluated to that?
16:37:10 <ski> Bor0 : generally ,`fⁿ' is `f ∘ f ∘ ⋯ ∘ f', the function that will perform `f' `n' times on its input
16:37:11 <cmccann> I kinda doubt haskell notation is going to make things simpler for him :P
16:37:30 <monoidal> ah, sorry
16:37:37 <ski> Bor0 : finally, we don't want to decide which function `f' to use, so we abstract over that as well
16:37:46 <Bor0> I understand
16:38:10 <cmccann> Bor0: most halfway-decent imperative languages these days have lambdas anyhow
16:38:16 <Bor0> I think I got how church encoding works in an abstract way, I still have troubles evaluating any lambda expression
16:38:43 <cmccann> so you might be able to try these ideas out in a more familiar setting
16:38:44 <monoidal> do it on paper
16:38:58 <Bor0> for instance, how do I even start evaluating λn.λf.λx.f (n f x) ?  f^(n+1)(x) = f(f^n(x)) is much easier for me
16:39:10 <cmccann> there's nothing to evaluate there
16:39:21 <Bor0> :D
16:39:25 <cmccann> it's a function not applied to anything
16:39:41 <Bor0> okay, how can I convert that to a notation that will be understandable to me? (e.g. standard functions notation)
16:40:02 <silasm> watch: if you have the patience for it, the paper the library's based off of is good.
16:40:03 <cmccann> what languages do you know?
16:40:20 <Bor0> c/c++
16:40:31 <cmccann> ok I dunno
16:40:33 <Eduard_Munteanu> g(n, f, x) = f(n(f, x))
16:40:54 <Eduard_Munteanu> Some pseudosomething.
16:40:56 <silasm> watch: when I last had to use depth-first search I didn't have the patience and ended up using a really awful naive implementation that was pretty similar to the imperative one. It was a pain to implement lol.
16:40:57 <shachaf> c/c++ is an even better language than its predecessor, c/c
16:41:15 <Eduard_Munteanu> @karma c/c
16:41:15 <lambdabot> c/c has a karma of 461
16:41:41 <otters> hahahahaha
16:41:45 <elliott> Bor0: what I showed was a conversion.
16:41:46 <elliott> more or less.
16:41:59 <ski> @where C/C++
16:41:59 <lambdabot> "C/C++ : A new language for the new Millennium" by Richard Heathfield in 2005-02 at <http://web.archive.org/web/20090421080714/http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html>
16:42:01 <elliott> if you represent the number n by something that takes a function f to its iteration f^n
16:42:13 <elliott> then you can define what it means to iterate one more time: f^(n+1)(x) = f(f^n(x))
16:42:24 <elliott> and then you can flip it around and get λn.λf.λx.f (n f x)
16:42:31 <elliott> note the similarity between f(f^n(x)) and f (n f x)
16:42:35 <ski> @karma C/C++
16:42:36 <lambdabot> C/C++ has a karma of 1
16:42:36 <elliott> since (n f x) represents f^n(x)
16:42:48 <elliott> this takes an encoded "n" and gives n+1
16:43:04 <Bor0> how does (n f x) represent f^n(x) ?
16:43:07 <epta> @karma prolog
16:43:07 <lambdabot> prolog has a karma of 1
16:43:28 <cmccann> Bor0: in something vaguely resembling javascript, the successor function might look like "function(n) { return function(f) { function(x) { return f(n(f)(x)); }}}"
16:43:35 <ski> Bor0 : `n' represents "do it `n' times"
16:43:37 <cmccann> which begins to show you why the lambda notation is vastly superior
16:43:50 <flebron> What was the syntax to say "This is some other way type Foo is an instance of typeclass Bar"?
16:43:52 <ski> Bor0 : `it' being the `f' argument, and it's being done to the `x' argument
16:43:53 <Eduard_Munteanu> Er, what?
16:44:12 <Eduard_Munteanu> Not standard notation I suspect.
16:44:22 <monoidal> flebron: newtype Foo' = Foo' Foo; instance Bar Foo'
16:44:30 <epta> Sorry for interrupting your lambda stuff, but could someone take a look? http://stackoverflow.com/q/16390273/
16:44:31 <flebron> Ah, newtype. Thanks :)
16:44:45 <flebron> Is newtype a reasonable way to define "Integer mod m", for some m?
16:44:46 <FreeFull> > let fn 0 _ x = x; fn n f x = f (fn (n-1) f x); in fn 3 (+1) 0
16:44:49 <lambdabot>   3
16:45:02 <elliott> Bor0: because that's how we're defining the naturals
16:45:04 <monoidal> flebron: fixed compile time? i say yes
16:45:10 <flebron> Not fixed at compile time.
16:45:48 <flebron> Oh drat. This needs dependent types, doesn't it?
16:45:56 <monoidal> flebron: such type will not have Num instance, for examlpe
16:45:59 <flebron> I was going to make MyType m be an instance of Num, with m a variable representing the modulus. But m would need to be an Integer.
16:46:37 <silasm> flebron: yeah, that'd be a weaker implementation of Idris's Fin, iirc.
16:46:40 <monoidal> flebron: you could do something like this with type-level nats, but that will still be compile-time
16:46:48 <cmccann> elliott: you should suggest reflection.
16:46:48 <silasm> so I think it'd require dependent
16:46:51 <flebron> And performance would be nonexistent :p
16:47:05 <flebron> (I'm essentially wanting to do matrix modular exponentiation quickly.)
16:47:24 <flebron> (With a very old Haskell platform, without Repa or such. By hand. *snif*.)
16:47:29 <elliott> reflection.
16:47:41 <elliott> it lets you do this thing efficiently.
16:47:43 <elliott> with no dependent types!
16:47:45 <elliott> and strong type checking.
16:47:54 <elliott> cmccann: i require more moneys.
16:48:17 <flebron> How would reflection help? (I have no experience with it, I'm still an intermediate Haskeller.)
16:48:32 <silasm> while I'm here, is there a way to write to a file in an encoding with more bits than UTF-8? I'm writing an LZ78 algorithm for a class and want to compress a bit more than UTF8 will allow.
16:48:56 <silasm> like, are there Word32 or Word64 ByteStrings?
16:48:57 <ski> flebron : you could use existentials, i suspect
16:48:59 <elliott> flebron: it's a package
16:49:24 * flebron can't install packages on the server he's using :( Programming competition. I can try to check if it exists by importing it and failing, though? :)
16:49:25 <ski> possibly using the `reflection' package, yes
16:49:38 <silasm> (although I guess that wouldn't be a ByteString since it's more than 8 bits...)
16:49:40 <edwardk> flebron: reflection lets you turn values into types you can turn back into values
16:49:51 <flebron> Oh nasty
16:49:57 <elliott> googling finds http://hpaste.org/79794
16:50:05 <elliott> which I didn't write but is more or less what I did write.
16:50:07 <edwardk> flebron: its useful when you want to use a type that needs a number, or to depend on some user function. etc.
16:50:10 <elliott> for modular arithmetic with reflection
16:50:51 <ski> @hackage reflection
16:50:51 <lambdabot> http://hackage.haskell.org/package/reflection
16:51:23 <edwardk> also note that reflection 1.3.1 has some intrinsic support for reflecting type level natural numbers without using reify
16:51:45 <edwardk> e.g. with the hyperloglog library you can just use HyperLogLog $(5)          as weill as use reify to lift some runtime value.
16:51:48 <cmccann> elliott: ok. I will get you some brand new moneys. less this time because that was an easier task.
16:52:04 <elliott> cmccann: I'm going to be rich in no time
16:52:10 <shachaf> cmccann: can i get some monets too plz thx
16:52:14 <edwardk> (it makes a Num instance for Type and Expr, and a lifting for Num into the Q monad)
16:52:25 <cmccann> elliott: ok here, 100% brand new moneys http://i.imgur.com/rqlnSnf.jpg
16:52:33 <edwardk> that way you can use numeric literals in splices
16:53:12 <elliott> cmccann: wow, they put the same dead guy on two different moneys.
16:53:19 <elliott> cost-cutting measures gone too far
16:53:20 <cmccann> no that is a different guy
16:53:22 <elliott> oh.
16:53:23 <arbn> yitz: Thanks for your help earlier. I just switched to exitcode-stdio-1.0 instead of detailed-1.0, and it works well enough for now. I don't understand this Cabal test-hook stuff, but I have something working. :)
16:53:30 <shachaf> elliott: wow that's kind of racist
16:53:35 <cmccann> the, uh. first guy's twin brother I guess.
16:53:45 <cmccann> or maybe son.
16:53:47 <cmccann> I'm not really sure.
16:53:57 <elliott> twin son.
16:54:00 <arbn> Err. detailed-0.9, rather.
16:54:03 <cmccann> yes, clearly.
16:54:14 <elliott> Mr. Totally Legit Moneys II
16:54:20 <edwardk> arbn: afaict detailed-1.0 was never finished
16:54:35 <edwardk> i'd love to be proven wrong
16:54:36 <cmccann> elliott: so incredibly legit like you have no idea.
16:54:39 <DiegoNolan> how come my UTCTime has not instance of show when the documentation sasys it does?
16:54:44 <shachaf> elliott: Isn't it annoying how American monets are all Green?
16:54:48 <epta> Is there some blog post about reflection usage of there is just a paper?
16:54:50 <shachaf> It's a good thing Monet was French.
16:54:53 <arbn> edwardk: Oh. OK. So, using exitcode-stdio-1.0 for now might be sensible.
16:55:03 <edwardk> epta: there are acouple of posts on comonad.com but nothing really current
16:55:07 <arbn> edwardk: I was getting a weird Cabal-y bug with detailed.
16:55:11 <edwardk> arbn: its what i use everywhere
16:55:26 <arbn> edwardk: Cool.
16:55:55 <Bor0> is it correct to read λn.λf.λx.f (n f x) as nfx -> f nfx ? and does the order of parentheses matter there?
16:56:13 <edwardk> the parens matter there
16:56:14 <shachaf> Not just the order, but the placement!
16:56:16 <shachaf> Haskell is so picky.
16:56:53 <Bor0> what do they represent?
16:58:01 <silasm> Bor0: f is applied to the result of (nfx) instead of being applied to n, f, and x when they're grouped in parentheses.
16:58:40 <silasm> shouldn't be anything new there.
17:00:16 <silasm> actually reducing a couple of church-encoded operations should make the way they work somewhat clear, once you understand how application works.
17:00:35 <Hafydd> Are we conflating Haskell and Lambda Calculus here?
17:01:13 <silasm> though deriving them has never been easy for me.
17:03:29 <ski> Bor0 : if you write `a b c', it means `(a b) c'; if you mean `a (b c)', you have to write that
17:04:18 <Bor0> does λn.λf.λx.f (n f x) mean that we have a function with three arguments?
17:04:51 <ski> Bor0 : it means that we have a function that when given an argument will return a function that wen given an argument will return a function
17:05:17 <silasm> Bor0: do you have ghc installed? I found questions like that were best answered with a :t (lambda expression) in ghci
17:05:22 <Bor0> okay, that makes sense. so the shorthand notation they use on wikipedia λabc instead of λa.λb.λc can be confusing for beginners
17:05:36 <ski> Bor0 : `λ a. λ b. ..a..b..' means `λ a. (λ b. (..a..b..))'
17:05:55 <ski> and `λ a b. ..a..b..' means `λ a. λ b. ..a..b..', yes
17:06:05 <silasm> Bor0: yeah, they're equivalent. the notation wikipedia uses emphasizes that lambda expressions can be curried, but it can be confusing.
17:06:21 <ski> (where `..a..b..' is meant to signify any expression, that may possibly depend on `a' and `b')
17:06:41 <Bor0> I think I'm getting somewhere :) so the level of abstractions applied (n f x, which I thought are just 3 inputs, which I was wrong) are a way of computing stuff
17:08:25 <Bor0> how about when we want a function with 2 inputs, is λ(ab).something equivalent to λab.something? or does the former take 2 inputs
17:08:32 <ski> Bor0 : try hand-reducing `(λ n. λ f. λ x. f (n f x)) (λ f. λ x. f (f (f x)))' (essentially computing `succ 3')
17:08:55 <jfischoff> how do I get hoogle to build databases from my personal local packages on ubuntu?
17:09:01 <Bor0> great, I'm just at that phase (now that I think I understood how numbers are defined). I'll try that
17:09:09 <jfischoff> yay ski's here!
17:09:11 <ski> Bor0 : `λ(ab). ...' is just bad syntax, in the usual syntax we write λ-calculus
17:09:21 <silasm> Bor0, I don't think parentheses in between λ and . has any meaning in untyped lambda calculus.
17:09:39 * ski shifts uncomfortably in jfischoff's direction
17:09:43 <Bor0> ok, so how do we define a function with 2 parameters?
17:09:49 <ski> Bor0 : no
17:09:56 <jfischoff> hehe
17:10:03 <Bor0> is there no need for such a thing?
17:10:17 <BMeph> ski: Shouldn't that be "mu"? :)
17:10:19 <ski> instead you typically define a function that takes one argument (as every function does), and returns a function that takes the other argument, and then returns the "real result"
17:10:32 <silasm> in Haskell, \(A b) would signify pattern matching on a type A to get a type b out of it (as in \(Just a) -> a), but pure lambda calculus has no notion of types
17:10:42 <ski> BMeph : perhaps, though i suppose i was feeling Prology
17:11:22 <Bor0> but in the λn.λf.λx.f (n f x) as nfx -> f nfx, it's said that f(n) = n+1, can I supply more arguments to that same definition? I don't get it
17:12:51 <arbn> Hmm. What does "Segmentation fault: 11" mean?
17:13:25 <silasm> Bor0: I think what you're struggling with here is that f(n) returns an unfinished function. In lambda calculus, it has to. But what it does return is of type λf.λx.(some number of f's) x, which can be interpreted as a natural number.
17:13:45 <silasm> by "unfinished" I mean a function that still takes more arguments even after we've applied one.
17:13:46 <ski> Bor0 : i can only follow what you (presumably) mean, because i know the subject comfortably -- you should try to express yourself more clearly than "in the λn.λf.λx.f (n f x) as nfx -> f nfx, it's said that f(n) = n+1", otherwise we'll probably soon have a hard time following you
17:14:49 <mm_freak> arbn: SIGSEGV = signal 11, which means that the corresponding process tried to perform an invalid memory access
17:14:59 <mm_freak> which basically means that the program is buggy
17:15:07 <Bor0> sorry about that, but it's hard to follow myself. this is a complete new area for me and I decided to spend some time on it. I'll play a bit more with pen and paper
17:15:21 <ski> Bor0 : if we define `succ' to mean `λ n. λ f. λ x. f (n f x)' (or if you prefer, `succ' is a shorthand for that large expression), then `succ n f x' (meaning `((succ n) f) x') will β-reduce to `f (n f x)', yes
17:15:26 <mm_freak> silasm: minor nitpick:  A and a aren't types in your example
17:15:39 <arbn> mm_freak: OK. Thanks.
17:15:44 <mm_freak> A is a constructor and 'a' is a value
17:15:55 <mm_freak> s/'a'/'b'/
17:16:01 <silasm> mm_freak: I was kinda iffy about using the word "type" there when I said it, but forgot the correct terminology. Thanks.
17:16:11 <mm_freak> value =)
17:16:27 <ski> Bor0 : so, therefore `succ n' will (reducing under `λ's) β-reduce to `λ f. λ x. f (n f x)'
17:16:28 <Bor0> ski: but what is the "role" of n there? why simply not f (f x) ?
17:16:37 <mm_freak> silasm: "something of type A" is also fine
17:16:46 <mm_freak> if you're uncomfortable with "value"
17:16:58 <ski> let's, for the sake of argument, assume that `n' is `λ f. λ x. f (f (f x))'
17:17:21 <silasm> mm_freak: I'm fine with value. I forgot "constructor" and just derped when I should have said "value".
17:17:48 <mm_freak> =)
17:18:26 <ski> Bor0 : then `succ n f x' β-reduces to `f (n f x)', which means `f ((λ f. λ x. f (f (f x))) f x)', which β-reduces to `f ((λ x. f (f (f x))) x)', which β-reduces to `f (f (f (f x)))'
17:19:17 <Bor0> ah, I see
17:19:20 <ski> Bor0 : so, therefore `succ n' (reducing under `λ's) β-reduces to `λ f. λ x. f (f (f (f x)))', when `n' is `λ f. λ x. f (f (f x))'
17:20:01 <ski> so, we need `n f x' in `f (n f x)', not just `f x' as in `f (f x)' to "copy over" as many `f's as `n' wants to, inside the outer `f' we're adding
17:20:34 <ski> Bor0 : now consider `λ n. λ f. λ x. n f (f x)' -- what happens when you apply this to the same `n' e.g. ?
17:21:54 <Bor0> f(n) = n+2 ?
17:22:00 <cschneid> the stdlib documentation of haskell is super-academic (see the monoid newtype of Any: "Boolean monoid under disjunction"). Is documentation with real-world usage snippets accepted as patches? Or would the be better as a separate project.
17:22:03 <ski> Bor0 : "sorry about that, but it's hard to follow myself." -- it's fine, as long as you understand it can be an issue, and you try your best :)
17:22:11 <cschneid> (not that in particular, but that general problem of terseness in the stdlib
17:22:12 <ski> Bor0 : try and see ? ;)
17:22:44 <jfischoff> I'm getting a Hoogle parse error with bang pattern:  Parse error: !
17:22:53 <jfischoff> anyone know a workaround?
17:23:06 <mm_freak> cschneid: one point of abstract algebra is that it allows you to be concise
17:23:32 <ski> Bor0 : btw, when you said "in the λn.λf.λx.f (n f x) as nfx -> f nfx, it's said that f(n) = n+1", i first by "nfx -> f nfx' you really meant something like "this function transforms the three arguments `n',`f',`x' into `f (n f x)'"
17:23:33 <mm_freak> cschneid: when you know what a monoid is, then you just say "monoid" instead of enumerating all the laws
17:23:52 <mm_freak> and you have a huge number of monoids in haskell
17:24:15 <Bor0> yes, I was thinking that. but things were cleared up when you told me to assume n as the input and apply the beta reduction
17:24:32 <cschneid> mm_freak: got monoids, but in this case it's a specific instance of the monoid, and I need to glance at how they implement `mappend`. Docs are orthogonal from the code beauty part. Being verbose w/ examples is good for a language.
17:24:45 <ski> Bor0 : secondly, by "it's said that f(n) = n+1", you presumably mean that this function just described has the numeric effect as the function `f' defined by `f(n) = n+1' (for all (natural numbers) `n')
17:25:00 <mm_freak> cschneid: conjunction is and, disjunction is or
17:25:26 <ski> Bor0 : however, it's confusing that you use the name `f' here, since the `f' in `λ n. λ f. λ x. f (n f x)' is something completely different
17:25:57 <NemesisD> are there any idioms for partially applying/doing pointfree for > 1 omitted argument like so: foo :: k -> v -> [a], foo' :: [[a]] -> k -> v -> [[a]], foo' acc = (:acc) . foo
17:26:21 <ski> Bor0 : so, it would be better if you instead of "it's said that f(n) = n+1" had said something like "this function corresponds to the function `f(n) = n+1"
17:26:35 <NemesisD> foo' acc = (:acc) . foo doesn't work. foo' acc k = (:acc) . foo k works but im curious if i could eliminate the k
17:26:36 <Bor0> yup, that's what I meant
17:26:54 <ski> Bor0 : er, rather :  so, it would be better if you instead of "it's said that f(n) = n+1" had said something like "this function corresponds to the function `succ(n) = n+1"
17:27:02 <parcs> NemesisD: ((:acc) .) . foo
17:27:11 <parcs> NemesisD: or fmap (:acc) . foo
17:27:15 <mm_freak> cschneid: and if you can't memorize those two terms just read the name:  true if "any" is true, true if "all" are true
17:27:18 <ski> Bor0 : even better, imho, would be "this function corresponds to the function `succ' defined by `succ(n) = n+1' (for all `n')"
17:27:32 <Bor0> :D the same reason I changed a couple of paper sheets
17:27:56 <NemesisD> parcs: ooh i like the second one better. the first one is less grokkable
17:28:10 <cschneid> mm_freak: it's not just this, it's constant through stdlib docs. It all ends up leaning toward super-terse and mathy explainations. What I'm wondering is if I provide patches with more code examples to elucidate, then would they get accepted
17:28:58 <mm_freak> cschneid: i don't know…  some might like it, others might consider it clutter
17:29:19 <typoclass> cschneid: i think it's sorely needed
17:29:20 <parcs> NemesisD: neither is grokkable, really :P
17:29:31 <ski> Bor0 : these are just suggestions. there's probably many other ways to convey the same information. the point is to be more clear about what you mean, and not to needlessly use same names for different things
17:29:54 <simpson> Does failing a pattern match in a MonadPlus do the same thing as zeroing it out (mzero, guard, etc.)?
17:30:00 <cschneid> typoclass: is that in ghc itself, or a separate doc project?
17:30:14 <simpson> Or is it still dependent on the specific monad?
17:30:17 <ski> Bor0 : so, what does `λ n. λ f. λ x. n f (f x)' applied to some sample `n's β-reduce to ? :)
17:30:25 <cschneid> I might start writing some of them as I understand more of haskell (for example, I get the example Sum and Product monoid stuff, so I can doc it).
17:30:25 <mm_freak> cschneid: also often you can't really have better explanations without giving up the generality…  for example how do you explain Applicative's 'many' and 'some'?
17:31:10 <cschneid> mm_freak: I don't want to delete the text there now, just show a bit of somewhat useful code to show a specific use of it. If some doesn't have a good code snippet, then it doesn't get one
17:31:12 <cmccann> @src many
17:31:12 <lambdabot> Source not found. My brain just exploded
17:31:14 <cschneid> mm_freak: doesn't mean they're never useful
17:31:15 <cmccann> pf
17:31:41 <mm_freak> cschneid: it's probably appreciated, but don't get too verbose
17:31:49 <typoclass> (honestly, just deleting the current text will often be an improvement ...)
17:32:28 <cschneid> mm_freak, typoclass: most of this comes as I am learning - running against opaque docs. I figure it out eventually, just unnecessarily terse for new & intermediate people I think.
17:32:40 <cmccann> I think most people would agree that examples are good
17:32:45 <cschneid> and really, even since I've been using ruby for 5+ years, I still go back and reread docs.
17:32:47 <mm_freak> cschneid: i agree with that
17:32:50 <cschneid> ok - ghc itself holds them?
17:32:53 <typoclass> cschneid: no i agree. better docs are absolutely needed
17:33:05 <Bor0> before I answer that, could you tell me if this is correct: λx.f x is equivalent to (x->x) applied to f, so it beta reduces to f?
17:33:38 <ski>   many act = some act <|> pure []
17:33:39 <ski>   some act = liftA2 (:) act (many act)
17:33:41 <Bor0> before (I am able to) answer that*
17:33:41 <ski> iirc
17:34:05 <cschneid> typoclass, cmccann, mm_freak: is the source of the stdlib docs the ghc codebase itself?
17:34:07 <ski> Bor0 : well
17:34:13 <mm_freak> cschneid: improving the explanations in the base API docs is a good idea, but a better place for thorough explanations and examples may be something external
17:34:29 <mm_freak> the typeclassopedia is an example that addresses this
17:34:41 <mm_freak> cschneid: i think so, yes
17:34:46 <cmccann> for core libraries it might actually be better to have separate comprehensive docs
17:34:48 <mm_freak> the "stdlib" is called the base library
17:34:54 <cmccann> and leave the haddocks as bare-bones reference material
17:35:17 <typoclass> cschneid: largely the base package (not ghc itself). for examples, click the 'source' links on the right hand side, it'll show you what the comments (if any) look like in source
17:35:30 <ski> Bor0 : surely, if we apply `λ x. (...) x' (where `...' is an expression not containing `x' (freely)) to any expression `e', then it β-reduces to `(...) e'
17:35:31 <cmccann> haddocks are really not a great place for extended explanations to my mind
17:35:37 <mm_freak> cschneid: keep in mind that most people use the base API docs to look up types and quick documentation
17:36:35 <cschneid> mm_freak: of course. I'm thinking no more than the rubydocs look: http://ruby-doc.org/core-2.0/Hash.html#method-i-each -- not much to say, so it's no more than a super-basic example.
17:36:37 <typoclass> i think 3-line usage examples are perfectly alright in the haddocks
17:36:51 <ski> Bor0 : therefore, if the only way we can actually *use* (inspect) a term like `λ x. (...) x' (inside the system. not talking about the human inspecting the final result here), then `λ x. (...) x' and `...' ought to be equivalent in some sense, because applying them to any expression `e' reduces to the same thing
17:37:19 <typoclass> cschneid: at first glance, that's in my opinion how documentation should look
17:38:40 <mm_freak> cschneid: as long as i can still see at least three definitions on one screenful of docs i'm fine with that
17:38:42 <ski> Bor0 : however, `λ x. (...) x' and `...' are not *β*-equivalent (and therefore one can't β-reduce to the other) -- for the simple reason that *β* reduction doesn't allow us to make this reduction step
17:39:08 <mm_freak> cschneid: for example it's fine to give examples for things like liftM, but it would be totally exaggerated to give examples for 'head'
17:39:19 <ski> Bor0 : traditionally, we say that `λ x. (...) x' and `...' are *η*-equivalent, and the former η-reduces to the latter
17:39:45 <Bor0> that's helpful, thanks
17:39:58 <mm_freak> cschneid: one thing about the API docs of listlike interfaces is that a quick sentence tells you everything you need to know, so i can skim through the docs very quickly and see many functions on one screen
17:40:11 <typoclass> mm_freak: to me, the "not so much text" objection seems much more an issue of haddock's css files and such. until a while ago it used to show a "synopsis" section with only type signatures
17:40:13 <ski> Bor0 : η-equivalence embodies "extensionality", that the only thing we can really do with a function (inside the system) is to apply it to an argument and see what the result is
17:40:32 <mm_freak> typoclass: that section is still there, but it's a bit hidden
17:40:43 <cschneid> anyway, I'm going to do some stuff, and then people can merge or not :)
17:40:54 <ski> (compare with "extensionality of sets", which means that the only thing that matter for a set is what elements it has : if two sets have exactly the same elements, then they've got to be the same set)
17:41:07 <mm_freak> typoclass: see the "synopsis" rider at the top right
17:41:24 <typoclass> cschneid: huge thanks from me. i've got some notes myself. i should really turn them into patches
17:41:41 <mm_freak> cschneid: yeah, i would appreciate the effort
17:41:44 <cschneid> typoclass: haven't done it yet :) thank me later. But yeah, I like writing as I learn, might as well share.
17:42:18 <ski> Bor0 : you could state extensionality for sets as `(∀ x. x ∊ S ⇔ x ∊ T) ⇒ S = T'
17:42:36 <mm_freak> cschneid: i know from personal experience that when you write haskell documentation it's easy to get lost in details =)
17:42:44 <ski> Bor0 : and extensionality for functions as `(∀ x. f(x) = g(x)) ⇒ f = g'
17:43:00 <Eduard_Munteanu> Hm, that one weird ∈.
17:43:28 <ski> oh, didn't notice there was many to select from
17:43:45 <Eduard_Munteanu> ski: how are you typing those?
17:43:50 * Eduard_Munteanu uses SCIM here
17:44:07 <ski> (`(∀ x. x ∈ S ⇔ x ∈ T) ⇒ S = T' using the other symbol)
17:44:25 <ski> Eduard_Munteanu : i was copying from character map, since i'm not sitting at my computer atm
17:44:25 <typoclass> cschneid: have you seen this? http://undergraduate.csse.uwa.edu.au/units/CITS1211/Documentation/tourofprelude.html
17:44:31 <Eduard_Munteanu> Ah.
17:44:54 <int-e> hehe I wasn't aware of those ... U+2208 ELEMENT OF vs. U+220A SMALL ELEMENT OF
17:44:57 <cschneid> typoclass: no I had not. That's exactly the kinds of docs I was thinking, although extended out past prelude itself
17:45:58 <typoclass> cschneid: yes, exactly. there's a "tour of monad functions" as well. i'm not aware of any more "tours". this could be used as a basis for those patches :-)
17:46:21 <cschneid> yeah, I'll talk to him and see if I can get permission to adapt & merge in the preexisting work
17:46:31 <parcs> when can one turn 'foldr f z xs' into 'foldl (flip f) z xs'? when f is strict in its 2nd argument and when forall x. f z x == f x z ?
17:47:42 <ski> parcs : you also need a finite `xs'
17:48:08 <ski> > foldr f z [a,b,c,d]
17:48:12 <lambdabot>   mueval-core: Time limit exceeded
17:49:01 <parcs> lambdabot is sucking right now
17:49:03 <Eduard_Munteanu> > foldr f z [a,b,c,d]
17:49:07 <lambdabot>   f a (f b (f c (f d z)))
17:49:19 <flebron> So other than the fact that I'm going to hell for it, performance wise, and knowing the integers I'm reading are between 0 and 2^64-1, is there anything I could improve in the following code, which essentially computes a modular 3x3 matrix power? http://ideone.com/WkrDK6
17:49:20 <ski> > foldl (flip f) z [a,b,c,d]
17:49:25 <lambdabot>  Terminated
17:49:45 <ski> > foldl (flip f) z [a,b,c,d]
17:49:47 <lambdabot>   f d (f c (f b (f a z)))
17:50:07 <typoclass> cale: ping? lambdabot has a cat sitting on her keyboard
17:50:24 <flebron> (The matrix is [[7, -14, 8], [1, 0, 0], [0, 1, 0]], the power is n-2, the modulus is m.)
17:50:38 <Cale> typoclass: hello?
17:50:40 <ski> > foldl (flip f) z (reverse [a,b,c,d])
17:50:44 <lambdabot>   mueval-core: Time limit exceeded
17:50:57 <Cale> There's probably nothing I can really do about that
17:50:59 <ski> > foldl (flip f) z (reverse [a,b,c,d])
17:51:01 <Cale> But I'll have a look
17:51:01 <lambdabot>   f a (f b (f c (f d z)))
17:51:12 <typoclass> Cale: oh thanks. i thought restarting or something
17:51:16 <Eduard_Munteanu> Cale: lispy hosts it right?
17:51:40 <Cale> The CPU is almost entirely idle
17:51:44 <Cale> So I don't know
17:52:00 <Eduard_Munteanu> Odd.
17:52:20 <typoclass> Cale: thanks for checking
17:52:32 <ski> parcs : seems you need commutativity and associativity, or at least some kind of combined associacummutativity
17:53:03 <ski> > foldl f z [a,b,c,d]
17:53:05 <lambdabot>   f (f (f (f z a) b) c) d
17:53:07 <djahandarie> Cale, try `time sleep 1' and see if it takes a long time to run (i.e., a lot more than 1 second)
17:53:16 <ski> would require associativity and unit laws
17:53:28 <djahandarie> You can usually detect issues with the VM host with that
17:53:43 <djahandarie> (Like physical CPU saturation)
17:54:12 <Cale> I'm also going to try extending the time limit to 10 seconds
17:54:35 <parcs> ski: aha thanks
17:55:00 <Eduard_Munteanu> Cale: maybe network latency somehow counts against that limit?
17:55:23 <Eduard_Munteanu> @bot
17:55:23 <lambdabot> :)
17:55:37 <Eduard_Munteanu> There is a fair bit of latency even for simple stuff.
17:56:00 <ski>      f a (f b (f c (f d z)))  =  f a (f b (f d (f c z)))  =  f a (f d (f b (f c z)))  =  f d (f a (f b (f c z)))  =  f d (f a (f c (f b z)))  =  f d (f c (f a (f b z)))  =  f d (f c (f b (f a z)))
17:56:49 <ski> could be done with `forall a b c. f a (f b c) = f b (f a c)', iow `forall a b. (f a . f b) = (f b . f a)'
17:57:21 <ski> so, "updating the state" with `b', and then with `a', is the same as updating it with `a', and then with `b'
17:57:38 <Cale> djahandarie: Takes only 1.004s or so, so that doesn't seem to be it
17:57:43 <jfischoff> parcs: finally starting compiling … right now
17:57:55 <parcs> jfischoff: yay
17:58:09 <parcs> i am just wondering what it takes to turn a non-tail recursive loop into a tail recursive one
17:58:20 <jfischoff> parcs: I'll let you know how it goes. Very excited
17:58:32 <Cale> Well, hopefully the time limit is significantly extended
18:00:15 <Eduard_Munteanu> parcs: it's not always possible
18:00:39 * hackagebot direct-sqlite 2.3.4 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-2.3.4 (IreneKnapp)
18:00:53 <parcs> Eduard_Munteanu: right, i want to know the criteria
18:01:02 <djahandarie> Cale, I'm out of ideas that are easy to test then, assuming you've checked the usual things like making sure nothing is swapping or whatever. Would probably be left to strace things or source modifying. Oh well.
18:01:28 <parcs> Eduard_Munteanu: it would be an immensely useful optimization i think, like TCO in other languages
18:01:30 <Cale> Yeah, the machine doesn't *look* like it's under any stress, but it is a linode
18:01:55 <elliott> it would be nice to get a slightly higher timeout for >
18:02:02 <elliott> since people just repeat it anyway, taking up more resources in total :p
18:02:11 <Cale> So it's possible that if I were to repeat that sleep 1 experiment, it wouldn't always be so nice.
18:02:12 <Eduard_Munteanu> parcs: useful in Haskell? Not a lot
18:02:27 <Cale> Maybe I should set up some kind of script to do that over and over and look for bad results
18:02:40 <Eduard_Munteanu> @bot
18:02:42 <lambdabot> :)
18:02:53 <Cale> > product [1..1000]
18:02:58 <lambdabot>   mueval: ExitFailure 1
18:02:58 <lambdabot>  mueval: Prelude.undefined
18:03:00 <Cale> hm
18:03:02 <Cale> > product [1..1000]
18:03:07 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
18:03:09 <Eduard_Munteanu> @bot
18:03:11 <lambdabot> :)
18:03:15 <Cale> still kinda flaky
18:03:22 <Eduard_Munteanu> Seems like it's not mere latency. :/
18:03:29 <djahandarie> > 1
18:03:33 <lambdabot>   1
18:03:39 <centrinia> > let fib 0 = 0; fib 1 = 0; fib n = fib (n-1) + fib (n-2) in fib 100
18:03:44 <lambdabot>   mueval: ExitFailure 1
18:03:45 <lambdabot>  mueval: Prelude.undefined
18:03:47 <centrinia> > let fib 0 = 0; fib 1 = 0; fib n = fib (n-1) + fib (n-2) in fib 10
18:03:49 <Cale> Well, that will definitely fail
18:03:49 <lambdabot>   0
18:03:55 <centrinia> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib 10
18:03:57 <djahandarie> I recall that the last time this sort of thing happened, it was due to another evaluation going on forever in the background and not getting killed properly.
18:03:58 <lambdabot>   55
18:04:01 <ski> parcs : btw, this reminds me of "State update transformation" by Peter Ross,Zoltan Somogyi (in 1999 ? 2000 ?) at <http://www.mercurylang.org/information/papers.html#update> and the earlier "Making Mercury programs tail recursive" by Peter Ross,David Overton,Zoltan Somogyi in 1999-09 at <http://www.mercurylang.org/information/papers.html#tail_lopstr_lncs>
18:04:03 <parcs> Eduard_Munteanu: dunno, i would like to not have to worry about when to use foldl for efficiency or when to add an accumulator to a recursive loop, and rather have the compiler figure out for me
18:05:35 <Eduard_Munteanu> parcs: generally foldl' for strict functions, foldr for productive stuff
18:05:45 <pablo_> hi, i am having trouble to calculate manually the type of zipWith . (++)
18:06:03 <Eduard_Munteanu> parcs: hi.
18:06:07 <Eduard_Munteanu> Er.
18:06:09 <parcs> Eduard_Munteanu: hi
18:06:16 <Eduard_Munteanu> pablo_: hi... where do you get stuck?
18:06:20 <parcs> Eduard_Munteanu: right but i don't wanna think about it :)
18:06:21 <Eduard_Munteanu> :)
18:06:37 <ski> parcs : also, LeoNerd (in #scheme) has implemented a system that can make some related optimizations (like TCMC/LCMC, and also the associativity-based ones, for specific operations like e.g. addition) at run-time
18:07:15 <Eduard_Munteanu> parcs: TCO isn't the problem actually
18:07:25 <parcs> ski: cool. gcc can perform some crazy optimizations on tail recursive functions, even doubly or nested tail recursive functions like fib or ackermann
18:07:39 <parcs> it is almost magic
18:07:48 <cmccann> oh boy, optimized ackermann functions
18:07:52 <cmccann> so useful.
18:07:53 <Eduard_Munteanu> parcs: even if you could convert some functions to a tail-recursive form, you might still want foldr
18:08:15 <ski> parcs : btw, if you didn't know, "TCMC/LCMC" is "Tail/Last -Call optimization Modulo Cons(tructor)"
18:08:21 <Eduard_Munteanu> foldr is the idiomatic Haskell way. :)
18:09:20 <parcs> Eduard_Munteanu: why might you still want foldr if f is strict in its 2nd argument, associative and has the appropriate unit laws?
18:09:45 <pablo_> for example, when i calculate the type of zipWith . uncurry where zipWith has type (a -> b -> c) -> [a] -> [b] -> [c] and uncurry has type (r -> s -> t) -> ((r,s) -> t) i write that a = (r,s) and b = t, but it does not work with zipWith . (++)
18:09:57 <parcs> cmccann: it's not useful but it's interesting! check out the ASM generated by gcc -O3 on the basic ackermann function
18:10:06 <ski> parcs : hm, are you talking about ordinary tail calls (by `-fsibling-calls' iirc) ? or something else/more ?
18:10:09 <pablo_> for example, when i calculate the type of zipWith . uncurry where zipWith has type (a -> b -> c) -> [a] -> [b] -> [c] and uncurry has type (r -> s -> t) -> ((r,s) -> t) i write that a = (r,s) and b = t, but it does not work with zipWith . (++)
18:10:23 <Eduard_Munteanu> parcs: yeah, it sucks if things are strict... but ideally they aren't
18:10:39 <Eduard_Munteanu> Hence foldr is ideal. :)
18:11:09 <ski> (hm, is ideality idempotent ?)
18:11:43 <nicoo> identity, you mean ?
18:12:25 * Eduard_Munteanu thinks of the ideality monad
18:15:46 <ski> parcs : anyway, in LeoNerd's system, if you `(define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))', then `(factorial 4)' reduces to `(* 4 (factorial 3))', which reduces to `(* 4 (* 3 (factorial 2)))', which reduces to `(* 12 (factorial 2))', which reduces to `(* 12 (* 2 (factorial 1)))', which reduces to `(* 24 (factorial 1))', which reduces to `(* 24 (* 1 (factorial 0)))', which reduces to `(* 24 (factorial 0))', which reduces to `24'
18:16:13 <ski> (possibly cut off near end : "... which reduces to `(* 24 (factorial 0))', which reduces to `24'")
18:16:17 <rpr> can you write foldl' in terms of foldr?  or just foldl
18:16:40 <parcs> ski: i'm not sure. thought i noticed that gcc can optimize the naive definitions of fib and ackermann into ones with a single tail recursive call (as opposed to 2 for fib and i don't know how many for ackermann)
18:16:43 <parcs> though*
18:16:52 <ski> nicoo : no, i was thinking that "`foldr' is ideally ideal" and wondered whether "`foldr' is ideal" followed from that
18:16:55 <_just> pablo_: zipWith . (++) does not work
18:16:58 <parcs> ski: ah, pretty neat!
18:17:37 <ski> parcs : afaiu, it examines the frame at run-time, and reuses (modifies) the existing frame, for (some) associative functions
18:17:55 <parcs> ah
18:18:45 <ski> parcs : the Mercury variant (see papers above) instead relies on the programmer promising at compile-time that the function is associative (and possibly commutative^Worder-independent), and then it'll rearrange code when compiling
18:19:34 <ski> (the implementation is allowed, but not required, to check your promises)
18:21:17 <pablo_> _just: sorry, i mean zipWith . (+)
18:21:44 <ski> (hm, forgot the penultimate step `(* 24 1)' above, for some reason)
18:22:56 <ski> pablo_ : you could systematically infer it ..
18:24:28 <ski> parcs : "cool. gcc can perform some crazy optimizations on tail ..." -- "hm, are you talking about ordinary tail calls (by `-fsibling-calls' iirc) ? or something else/more ?"
18:26:14 <parcs> ski: i responded to that!
18:26:27 <parcs> ski: "i'm not sure. though i noticed..."
18:27:14 <parcs> ski: would you consider doubly recursive and tree recursive tail calls to be ordinary? :)
18:27:24 <ski> oh .. i didn't notice that was an answer to that
18:27:31 <pablo_> ski _just : i don't know how to do it
18:27:43 <ski> to be associated as " check out the ASM generated by gcc -O3 on the basic ackermann function
18:27:48 <ski> er
18:28:21 <ski> to be associated as "ordinary (tail calls)"
18:28:54 <ski> so, if only they actually are tail calls (as opposed to tail calls modulo cons or some of the above variants), then sure
18:29:03 <watch> How do I use Data.Graph to determine whether or not a graph is acyclic?
18:30:05 <Bor0> ski: regarding λn.λf.λx.f (nfx). can I first beta-reduce λx.f (nfx) [I get results nff] then attempt to beta-reduce λf.nff (nfx) [I get results nnff] then attempt to beta-reduce λn.nnff (nfx)? or is this completely wrong
18:30:09 <ski> pablo_ : you start with your expression `zipWith . (+)'
18:30:35 <ski> pablo_ : which we may desugarize to `(.) zipWith (+)', to make it more clear what is the main function, and what is the arguments
18:30:41 * hackagebot free-game 0.9.2 - Create graphical applications for free  http://hackage.haskell.org/package/free-game-0.9.2 (FumiakiKinoshita)
18:31:10 <ski> then we start with te general (poly-)types for the variables `(.)',`zipWith',`(+)', which are
18:31:26 <ski>   (.) :: forall a b c. (b -> c) -> (a -> b) -> (a -> c)
18:31:54 <ski>   zipWith :: forall a b c. (a -> b -> c) -> ([a] -> [b] -> [c])
18:32:04 <ski>   (+) :: forall a. Num a => a -> a -> a
18:33:00 <Mortchek> Bor0, beta reduction is the substitution of an argument into the body of a lambda. In \n.\f.\x.f (n f x), is there anything you can do that with?
18:33:31 <Mortchek> (Is there a lambda to which you are applying an argument?)
18:33:56 <ski> Bor0 : `λ n. λ f. λ x. f (n f x)' does not β-reduce to `λ x. f (n f x)' -- perhaps you meant the former, *applied to* (some given) `f' and `n', β-reduces to that ?
18:34:19 <cmccann> dmwit: ping
18:34:37 <Bor0> I thought λ n. λ f. λ x. f (n f x) meant (n f x) applied to λ n. λ f. λ x. f
18:34:49 <Bor0> which probably doesn't make much sense
18:34:57 <Mortchek> Bor0, no, the lambda continues as far to the right as possible.
18:35:27 <ski> Bor0 : hm, i possibly misunderstood you
18:36:11 <Bor0> I think my confusion went on a higher level than before now, could you recommend some good tutorials for beginners on this subject? Wikipedia doesn't help me much
18:36:24 <Mortchek> (\n.(\f.(\x.(f (n (f x))))))
18:36:30 <Mortchek> Errrr
18:36:37 <ski> Bor0 : `λ n. λ f. λ x. f (n f x)' means `λ n. (λ f. (λ x. (f ((n f) x))))'
18:36:37 <Mortchek> (\n.(\f.(\x.(f ((n f) x))))))
18:37:01 <Mortchek> My parens have run wild
18:38:26 <ski> Bor0 : you can't β-reduce `λ n. λ f. λ x. f (n f x)', because it doesn't contain any β-redex ("redex" meaning "reducible expression")
18:38:34 <Bor0> ok, let's apply λf.λx.x to it (I know the result in advance). could you show me step by step how one applies that? and eventually gets to the result
18:39:03 <ski> Bor0 : you *could* possibly β-reduce that expression *applied* to some expression (call it `n'), i.e. β-reduce `(λ n. λ f. λ x. f (n f x)) n'
18:39:36 <ski> Bor0 : e.g. when `n' is `λ f. λ x. f (f (f x))' (note this `n' has nothing (directly) to do with the `n' inside `λ n. λ f. λ x. f (n f x)')
18:40:27 <ski> Bor0 : iow, you could β-reduce `(λ n. λ f. λ x. f (n f x)) (λ f. λ x. f (f (f x)))' (which is what i meant by β-reduce that first expression applied to `n', when `n' is shorthand for `λ f. λ x. f (f (f x))')
18:41:07 <Bor0> how did you get to that expression?
18:41:28 <Bor0> how do you* get to that beta reduced expression
18:42:08 <ski> Bor0 : i took the original expression, `λ n. λ f. λ x. f (n f x)', and applied it to the expression `n', yielding `(λ n. λ f. λ x. f (n f x)) n', which means `(λ n. λ f. λ x. f (n f x)) (λ f. λ x. f (f (f x)))' (since `n' was just a shorthand here for the expression `λ f. λ x. f (f (f x))')
18:43:01 <ski> Bor0 : and this β-reduces in one step to `λ f. λ x. f (n f x)', which is now short for `λ f. λ x. f ((λ f. λ x. f (f (f x))) f x)'
18:43:28 <ski> i.e. : `(λ n. λ f. λ x. f (n f x)) n' β-reduces in one step to `λ f. λ x. f (n f x)' (i hope you agree here)
18:44:31 <ski> (it's just that the "outer" `n' here was a shorthand for the expression `λ f. λ x. f (f (f x))' (being a numeral we test the original function term with))
18:44:43 <ski> pablo_ : continuing
18:44:45 <ski> we know
18:44:53 <ski>   (.) :: forall a b c. (b -> c) -> (a -> b) -> (a -> c)
18:44:55 <ski>   zipWith :: forall a b c. (a -> b -> c) -> ([a] -> [b] -> [c])
18:44:58 <ski>   (+) :: forall a. Num a => a -> a -> a
18:45:17 <ski> pablo_ : the `forall' stuff here means that these operations are *polymorphic*
18:45:46 <ski> they work for *any* actual types substituted for the type variables enumerated after the `forall'
18:46:42 <ski> pablo_ : however, each *use* of a polymorphic operation is (ignoring higher-rank stuff) monomorphic, meaning it has to be used at some concrete type, with actual types substituted for the type variables
18:47:35 <ski> so, the first step is to, for each occurance of a polymorphic operation in the expression `(.) zipWith (+)', decide which monomorphic instance will be used in that place
18:48:03 <ski> (if there had been several uses of the same polymorphic function, then each use could possibly use a different monomorphic instance)
18:48:19 <ski> an example of a monomorphic instance of e.g. `(.)' is
18:48:57 <ski>   (.) :: ([Int] -> String) -> ([(String,Int)] -> [Int]) -> ([(String,Int)] -> String)
18:49:26 <ski> (in this case replacing `a' by `[(String,Int)]',`b' by `[Int]',`c' by `String')
18:49:47 <ski> another one is
18:50:16 <ski>   (.) :: (Bool -> Maybe Bool) -> (Int -> Bool) -> (Int -> Maybe Bool)
18:50:39 <u_> > product $ take 1000 $ map (1.01**) $ randomRs (-1,1) $ unsafePerformIO $ newStdGen
18:50:41 * hackagebot binary-file 0.15.22 - read/write binary file  http://hackage.haskell.org/package/binary-file-0.15.22 (YoshikuniJujo)
18:50:45 <lambdabot>   mueval: ExitFailure 1
18:50:45 <lambdabot>  mueval: Prelude.undefined
18:50:46 <ski> however, we don't know yet which concrete instance we want to use for `(.)',`zipWith',`(+)' yet
18:50:53 <ski> and, we'd like to avoid guessing
18:50:54 <u_> hm what was it
18:51:08 <u_> > unsafePerformIO newStdGen
18:51:11 <lambdabot>   *Exception: Prelude.undefined
18:51:23 <ski> so, for the time being, we'll introduce "placeholder" names for the concrete types we want to use instead of the type variables
18:51:28 <ski> so, from
18:51:33 <ski>   (.) :: forall a b c. (b -> c) -> (a -> b) -> (a -> c)
18:51:36 <ski>   zipWith :: forall a b c. (a -> b -> c) -> ([a] -> [b] -> [c])
18:51:39 <ski>   (+) :: forall a. Num a => a -> a -> a
18:51:42 <ski> we get to
18:52:01 <ski>   (.) :: (_b0 -> _c0) -> (_a0 -> _b0) -> (_a0 -> _c0)
18:52:02 <u_> > product $ take 1000 $ map (1.01**) $ randomRs (-1,1) $ unsafePerformIO $ getStdGen
18:52:05 <lambdabot>   *Exception: Prelude.undefined
18:52:20 <ski>   zipWith :: (_a1 -> _b1 -> _c1) -> ([_a1] -> [_b1] -> [_c1])
18:52:31 <ski>   (+) :: _a2 -> _a2 -> _a2
18:52:45 <u_> ok well
18:52:49 <u_> it's not working in lambdabot
18:52:51 <u_> but basically i do that
18:52:55 <ski> were we know that we'll have to make sure that `_a2' is in class `Num'; iow that
18:52:58 <u_> and it always gives me an answer above 1
18:52:59 <ski>   Num _a2
18:53:01 <ski> holds
18:53:03 <u_> when it should be more or less 1
18:53:22 <u_> all those things i'm multiplying ought to cancel out to 1 ish on average, but they don't
18:53:42 <ski> next step is to look at each sub-expression of the expression `(.) zipWith (+)'
18:53:43 <u_> is this a floating point thing?
18:53:45 <u_> how do i avoid it?
18:54:11 <ski> `(.) zipWith (+)' really means `((.) zipWith) (+)', so let's look at the subexpression `(.) zipWith' first
18:54:14 <ski> we know
18:54:19 <ski>   (.) :: (_b0 -> _c0) -> (_a0 -> _b0) -> (_a0 -> _c0)
18:54:22 <ski>   zipWith :: (_a1 -> _b1 -> _c1) -> ([_a1] -> [_b1] -> [_c1])
18:54:50 <u_> actually it may need to be more than 1000
18:54:53 <u_> but its definitely biased
18:55:17 <ski> and to be able to apply a function expression with type like `foo -> bar' to an argument expression of type `baz', it has to be the case that the type `foo' is equal to `baz' -- and the result will have type `bar'
18:55:42 <ski> in this case, it means that we know the following type equality (equation, if you will) must hold :
18:55:58 <ski>   _b0 -> _c0  =  (_a1 -> _b1 -> _c1) -> ([_a1] -> [_b1] -> [_c1])
18:56:08 <ski> and we also know the type of the result of this application :
18:56:17 <ski>   (.) zipWith :: (_a0 -> _b0) -> (_a0 -> _c0)
18:56:56 <ski> now, we have the expression `((.) zipWith) (+)', which applies the above to `(+)', and we decided this occurance of `(+)' had type :
18:57:04 <ski>   (+) :: _a2 -> _a2 -> _a2
18:57:18 <ski> again, formal and actual parameter types must match :
18:57:29 <ski>   _a0 -> _b0  =  _a2 -> _a2 -> _a2
18:57:39 <ski> and we know the type of the result :
18:57:53 <ski>   (.) zipWith (+) :: _a0 -> _c0
18:58:15 <ski> summing up the equations and constraints, we know
18:58:19 <ski>   Num _a2
18:58:26 <ski>     _b0 -> _c0  =  (_a1 -> _b1 -> _c1) -> ([_a1] -> [_b1] -> [_c1])
18:58:31 <ski>   _a0 -> _b0  =  _a2 -> _a2 -> _a2
18:58:40 <ski> the first equation can be simplified to
18:58:42 <u_> increasing it still won't yield the bias
18:58:44 <u_> it was something else
18:58:46 <u_> sorry
18:58:50 <ski>   _b0  =  _a1 -> _b1 -> _c1
18:58:50 <u_> trying to figure out what
18:58:51 <ski> and
18:58:58 <ski>   _c0  =  [_a1] -> [_b1] -> [_c1]
18:59:07 <ski> while the second equation can be simplified to
18:59:16 <ski>   _a0  =  _a2
18:59:19 <ski> together with
18:59:25 <ski>   _b0  =  _a2 -> _a2
18:59:32 <ski> so, now we have the four equations
18:59:40 <ski>   _b0  =  _a1 -> _b1 -> _c1
18:59:43 <ski>   _c0  =  [_a1] -> [_b1] -> [_c1]
18:59:46 <ski>   _a0  =  _a2
18:59:49 <ski>   _b0  =  _a2 -> _a2
18:59:56 <ski> and the constraint
18:59:59 <ski>   Num _a2
19:00:06 <ski> togeter with the final result typing
19:00:11 <ski>   (.) zipWith (+) :: _a0 -> _c0
19:00:41 * hackagebot hyakko 0.6.0 - Literate-style Documentation Generator  http://hackage.haskell.org/package/hyakko-0.6.0 (JeremyHull)
19:00:53 <ski> seeing `_a0  =  _a2', we could simplify by removing this equation and replace every `_a2' by `_a0' (or the other way around, if you'd prefer), getting
19:01:06 <ski>   Num _a0
19:01:16 <ski>   _b0  =  _a0 -> _a0
19:01:25 <ski>   _b0  =  _a1 -> _b1 -> _c1
19:01:28 <ski>   _c0  =  [_a1] -> [_b1] -> [_c1]
19:01:32 <ski>   (.) zipWith (+) :: _a0 -> _c0
19:01:57 <ski> well, we see `_b0' must be equal to two types here
19:02:28 <ski> and since `_b0' isn't used otherwise, we can just "fuse" those two equations together and remove the `_b0' from sight, getting the equation
19:02:35 <ski>   _a0 -> _a0  =  _a1 -> _b1 -> _c1
19:02:39 <ski> which can be simplified to
19:02:46 <ski>   _a0  =  _a1
19:02:55 <ski>   _a0  =  _b1 -> _c1
19:03:24 <ski> as before, we remove the `_a0  =  _a1' equation, renaming every `_a1' to `_a0', getting
19:03:30 <ski>   Num _a0
19:03:39 <ski>   _a0  =  _b1 -> _c1
19:03:46 <ski>   _c0  =  [_a0] -> [_b1] -> [_c1]
19:03:50 <ski>   (.) zipWith (+) :: _a0 -> _c0
19:04:18 <ski> now we can't simplify the equations anymore
19:04:54 <ski> (and we haven't discovered any unsolvable equation, like `_a0 -> _a1  =  Maybe _a2' or something; so there's no type error)
19:05:24 <ski> we proceed by just removing `_a0' and `_c0', replacing them otherwhere by what they're equal to :
19:05:31 <ski>   Num (_b1 -> _c1)
19:06:03 <ski>   (.) zipWith (+) :: (_b1 -> _c1) -> ([_b1 -> _c1] -> [_b1] -> [_c1])
19:06:35 <pablo_> ski: you made my day
19:06:41 <ski> and, as a final step, we *generalize* on the remaining placeholders, turning them into new type variables (and also adding the constraints into the type signature) :
19:07:15 <ski>   (.) zipWith (+) :: forall a b. Num (a -> b) => (a -> b) -> ([a -> b] -> [a] -> [b])
19:07:56 <ski> (here i generalized `_b1' to `a' and `_c1' to `b' -- it doesn't matter what you call the type variables, as long as you use some type variables which are unused in the current context)
19:08:02 <ski> pablo_ : and that's it
19:08:23 <pablo_> ski: thank you, it was the best explanation
19:08:28 * ski bows
19:08:34 <pablo_> ski i really understand it now
19:09:13 <ski> pablo_ : now try inferring the type of `map map' :)
19:10:14 <ski> pablo_ : also note that i carefully made sure that, when making the monomorphic instances, that i didn't use the same placeholder name twice
19:11:09 <ski> (that's why i used `_a0',`_b0',`_c0' for `(.)', and the *different* `_a1',`_b1',`_c1' for `zipWith', and the *different* `_a2' for `(+)')
19:11:29 <ParahSailin> i wish i could define a parsec parser at runtime based on io, then compile it and use it
19:12:13 <ski> @type mkStdGen
19:12:15 <lambdabot> Int -> StdGen
19:12:30 <ski> u_ : try using that ^ if you want to experiment with `StdGen' in lambdabot
19:14:38 <jmcarthur> ParahSailin: there's always http://www.haskell.org/haskellwiki/GHC/As_a_library
19:14:52 <ski> u_ : also, you shouldn't use `unsafePerformIO' here, since the `IO'-action you pass isn't semantically equivalent to `return x' for some value `x'
19:15:01 <jmcarthur> it's not quite as nice as something like  compile :: a -> a  though
19:15:10 <ski> > map (1.01 **) [-1,1]
19:15:15 <lambdabot>   [0.9900990099009901,1.01]
19:15:42 * hackagebot husk-scheme 3.9 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.9 (JustinEthier)
19:15:57 <ski> ParahSailin : why can't you ?
19:16:52 <ParahSailin> jmcarthur, the problem i was basically solving was to parse a table based on the columns on the first line, ie i was expecting to parse the same record type but the columns could have been in any order
19:17:18 <ParahSailin> the way i had to do it was much less pretty than being able to define parser at runtime based on the first line
19:17:20 <jmcarthur> yeah that seems a pretty reasonable example of when dynamic specialization is awesome
19:18:00 <ski> ParahSailin : why can't you do it at runtime based on the first line ?
19:18:13 <ParahSailin> especially because i wanted to be able to generate useful error messages like "unexpected x at N"
19:18:43 <ParahSailin> when each of the columns were different formats
19:19:06 <jmcarthur> ski: he wants to be able to compile it (presumably with optimizations so that it gets specialized)
19:19:16 <ParahSailin> would have been so much easier to be able to template/macro/meta rearrange a couple lines of the applicative tree at runtime based on that first line
19:21:29 <ParahSailin> to illustrate, the first parser, vs the second http://hpaste.org/87300
19:22:12 <ParahSailin> if i got to rearrange "manualline" in there based on the first line, it would be a lot prettier than all that mess in the second parser
19:22:48 <ski> jmcarthur : oh, i see
19:23:02 <Bor0> thanks for all your help for today, continuing tomorrow on the same subject :-). good night
19:23:04 <ParahSailin> as it is, im sure you could, in a lot more code, write something that would do the same as the second but do extensive checks of the formats of the cells and give helpful error messages
19:23:33 <ski> i was thinking of the sense of "compilation" which just means a curried function that does non-trivial analysis of its first argument(s) before accepting the rest
19:24:46 * ski thinks staged programming would be appropriate here
19:25:01 <ParahSailin> this sort of thing is making me consider that maybe lisp is a bit higher in the abstraction scale on some things
19:26:13 <ski> sexprs as a representation of code at run-time works, though you really want a representation that's aware of bound variables
19:26:24 <ski> like in MetaML/MetaOCaml
19:26:51 <ski> (though not necessarily with CSP (Cross-Stage Persistence) included)
19:27:13 <u_> ski: unsafePerformIO was just for demonstration purposes, in the code (which i had deleted) i don't use it
19:27:33 <u_> also now i'm having trouble finding out where the bias was actually coming from
19:27:33 <ski> u_ : fine. for lambdabot `mkStdGen' works, as mentioned
19:27:37 <u_> but it doesn't appear to be that part
19:27:43 <u_> ic thank you
19:28:27 <ski> > randomRs (-3,3) (mkStdGen 0)
19:28:30 <lambdabot>   [-3,-1,2,2,0,0,-2,2,1,2,0,-3,-2,3,-3,-3,0,2,-3,-3,1,1,-3,1,-3,-2,3,-3,0,3,-...
19:28:42 <ParahSailin> ski, staged programming?
19:28:58 <ski> (obviously you'll get the same next time around. can be useful with repeatability for debugging)
19:29:41 <ski> ParahSailin : yes, like quasi-quotation and `eval' in the lisps, Template Haskell, and also MetaML/MetaOCaml
19:30:08 <cmccann> though all but the last are kinda weaksauce as far as staged compilation goes
19:30:22 <ski> where you can construct (and in some cases, deconstruct) pieces of code at run-time, and then evaluate (possibly compiling) it
19:30:24 <cmccann> I'm not sure if they actually qualify or not
19:31:21 <ski> i'm not very familiar with TH -- i'm not even sure whether it's properly (by default) hygienic or not
19:31:28 <cmccann> it is
19:31:49 <cmccann> but there's a way provided to be deliberately unhygienic
19:31:52 <cmccann> at least that's my understanding
19:32:01 <ski> that's ok, as long as it's not the default
19:32:11 <ijp> CLers still haven't learned the lesson, but at least Haskellers have
19:32:32 <ski> (similar to how dynamic scope^Wextent can be ok, as long as it's not the default)
19:33:04 <cmccann> ski: http://hackage.haskell.org/packages/archive/template-haskell/2.8.0.0/doc/html/Language-Haskell-TH.html#g:8
19:33:08 <cmccann> for the explicit versions
19:33:19 <ijp> ski: speaking of which, syntax parameters are a nice practical solution to many unhygiene problems
19:34:01 <cmccann> if memory serves me anything that automatically generates names will avoid any clashes or captures
19:34:14 <ski> cmccann : if i say `[| \x -> $(...) |]', can i refer to `x' inside `...' ?
19:34:23 <ski> ijp : *nod*
19:34:34 <cmccann> ski: I think you'd need to quote it
19:34:42 <cmccann> since the actual generated code will mangle "x" to something unique
19:35:11 <cmccann> but I'm far from a TH expert
19:36:31 <cmccann> the main thing I remember is that you have to jump through hoops to capture existing names
19:36:45 <ski> "Dirty Looking Hygiene" by Eli Barzilay in 2008-02-23 at <http://blog.racket-lang.org/2008/02/dirty-looking-hygiene.html>
19:36:46 <cmccann> well, more hoops than usual. TH isn't lacking in hoops.
19:36:54 <ski> cmccann : quote it in which way ?
19:37:50 <cmccann> ski: actually I'm not sure, I think you'd either need to use 'x or explicitly reify it inside the splice
19:37:53 * zRecursive not hygiene, but gensym is enough in CL ?
19:38:05 <cmccann> dealing with nesting splices and quotes gives me a headache sorry
19:38:30 <ski> cmccann : just  [| x |]  or  'x  would be fine
19:38:47 <cmccann> yeah
19:38:50 <ski> zRecursive : `gensym' is not enough
19:39:02 <cmccann> something like that, to explicitly grab the "x" from that scope
19:39:06 <zRecursive> ski: for example ?
19:40:26 <u_> aha
19:40:27 <u_> found it
19:40:36 <ski> zRecursive : `gensym' only solves the problem of identifiers in user code inadvertently referring to binding sites introduces by the expanding code
19:40:59 <hpaste> u_ pasted “random walk” at http://hpaste.org/87301
19:41:10 <u_> oooh magic
19:41:13 <u_> so yeah
19:41:15 <u_> if you run that
19:41:18 <u_> the result is always more than 1
19:41:28 <ijp> zRecursive: your file - (defun foo () ...) (defmacro bar (...) .... '(foo ...))   my file: (let ((foo zot)) (bar ...))
19:41:30 <u_> there's a bias
19:41:37 <u_> is there anything i can do about it?
19:41:41 <ski> zRecursive : the other problem with inhygiene is that expanding code can't expand to uses of identifiers which aren't in scope at the expansion site (e.g. it should be able to expand to uses of identifiers not exported from the module defining the macro)
19:43:02 <ijp> (ignoring for a minute the bug in my code due to f'ing lisp-2)
19:43:09 <zRecursive> seems clear, thx
19:44:17 <ski> (s/let/labels/,s/foo zot/foo (...) zot/ or something ..)
19:47:10 <zRecursive> It is better for macro not to use identifiers outside the scope. Otherwise, the macto is NOT general
19:47:35 <zRecursive> at most of time
19:51:30 <dmwit> cmccann: pong
19:51:58 <cmccann> dmwit: I get build errors when I enable the gtk3 flag
19:52:11 <dmwit> Did you clean first?
19:52:19 <cmccann> yes
19:52:27 <dmwit> ?hpaste
19:52:28 <lambdabot> Haskell pastebin: http://hpaste.org/
19:52:47 <dmwit> Also, have you reinstalled the newest buildtools?
19:53:23 <ijp> zRecursive: er what?
19:53:38 <cmccann> dmwit: it's the same error as http://sourceforge.net/mailarchive/forum.php?thread_name=20130209213552.168542ib9o2oga6g%40webmail.seas.upenn.edu&forum_name=gtk2hs-devel
19:53:43 <cmccann> wow that's a hideous link
19:53:50 <ijp> if you can't build macros safely from other macros, then why bother?
19:54:05 <rpr> ski, can you give an example of the last problem that can't be solved with gensym? didn't quite understand it
19:54:52 <ijp> anyway, I find it deeply amusing that people are defending an unsafe-by-default practice on #haskell
19:54:53 <cmccann> dmwit: anyway, other than that I have my inputdevice stuff cleaned up a bit along with the hackier hack for event classes, but haven't really tested all of it yet
19:55:22 <ski> rpr : ijp's example
19:55:29 <dmwit> Are you sure you cleaned before you built with the gtk3 flag?
19:55:58 <ijp> that example can be fixed, by introducing yet more machinery, (in this case putting the identifiers in a different package namespace)
19:56:30 <rpr> unless I'm misunderstanding it, that's only a problem in scheme, not in CL
19:56:31 <cmccann> I thought I did. why, did that fix the problem in that thread?
19:56:37 <zRecursive> rpr:  CL lives for decades with inhygiene macro :)
19:56:37 <cmccann> I can try again if you want.
19:56:46 <dmwit> I vaguely recall that was what fixed it, yes.
19:56:46 <ijp> rpr: scheme fixed the problem
19:57:11 <rpr> it's a problem with defmacro in scheme, because unlike CL variables and functions share the same namespace
19:57:17 <ski> rpr,zRecursive : also see <http://community.schemewiki.org/?hygiene-versus-gensym>
19:57:36 <ijp> rpr: first 1) there is no defmacro in scheme 2) I already pointed out that bug in my code
19:57:42 <ijp> s/first//
19:57:52 <rpr> ijp many scheme implementaitons come with (broken) defmacro
19:58:01 <cmccann> dmwit: ok. anyway, I haven't really tried to make the gtk3 stuff complete as far as the input device stuff goes.
19:58:09 <ijp> thirdly, this doesn't break defmacro
19:58:38 <cmccann> the API changed a bit there it seems, so I just preprocessor'd out the stuff that was removed and fixed anything with direct counterparts
19:59:40 <cmccann> dmwit: I also tried to register on the gtk trac but no confirmation email :[
19:59:41 <rpr> ijp the problem in your example is specifically because functions and variables share the same namespace in scheme
19:59:52 <dmwit> Yes, I don't know what's up with that.
19:59:54 <ijp> rpr: so pretend I used it as a variable
19:59:56 <dmwit> I can't find anything wrong.
20:00:06 <dmwit> I can send emails manually as the user that's running Trac and they go through just fine.
20:00:08 <ski> rpr : or use `labels'
20:00:11 <ijp> rpr: I know why my example was broken, but the fix is very simple
20:00:13 <rpr> ijp (foo..) would call a function called foo in CL, which is different than a variable called foo
20:00:14 <dmwit> And other people's Trac instances don't have this problem, apparently.
20:00:17 <dmwit> So WTF
20:00:22 <cmccann> yay
20:00:29 <cmccann> anyway, there's a ticket for extended input device support
20:00:50 <ski> rpr : i believe ijp is aware of the meaning of Lisp-2
20:01:06 <ijp> rpr: your file - (defvar foo () ...) (defmacro bar (...) .... '(... foo ...))   my file: (let ((foo zot)) (bar ...))
20:01:17 <ijp> happy?
20:01:33 <ijp> the code is still broken, and it doesn't rely on your conflating lisp-2 with defmacro
20:02:04 <rpr> ijp, whether it's broken or not is up for debate. dynamically binding global variables is a common thing in CL.
20:02:34 <cmccann> dmwit: how much testing do you want me to do before submitting it? I mean, I'm using it in the application I'm working on so I know it at least works for the essential bits
20:03:49 <ski> rpr : dynamic scope^Wextent by *default* is broken
20:03:52 <dmwit> That... sounds pretty good?
20:04:10 <ijp> rpr: I consider it a problem that a variable you use in your macro unintentionally captures the variables in a users program
20:04:16 <dmwit> If you're vaguely familiar with how gtk2hs does memory management, things are probably fine.
20:04:40 <rpr> you are capturing the same variable, foo, which is dynamically binded in let
20:04:59 <ski> rpr : also, what if someone locally rebinds `let',`defun',`lambda',`if',`cond' (for a DSL, say) ?
20:05:10 <ijp> ski: well, in this case the standard gets in the way
20:05:11 <rpr> the only problem I see there is that you didn't put earmuffs around foo, ie (defvar *foo* ..)
20:06:00 <ijp> whatever, I can't make you see the value of encapsulation
20:06:10 <rpr> ski then code macro expanded to will use those macros, which was pressumably the point?
20:06:15 <ski> rpr : how about  (defun foo (a b c) ...) (defmacro bar (...) .... '(foo ...))  with  (labels ((foo (x y z) zot)) (bar ...))  ?
20:06:45 <cmccann> dmwit: I'm vaguely familiar with the concept of needing to worry about memory management when FFI stuff is involved...
20:07:35 <cmccann> also, build just died with the same error after doing "cabal clean".
20:08:19 <ski> rpr : using whatever is in scope is brittle, shouldn't be the default
20:08:20 <zRecursive> ski: which 'foo will be used during macro expanding in your code ?
20:08:23 <dmwit> hum
20:08:27 <rpr> ski I see no problem. you are redefining foo, and then complaining that the macro uses the redefined version?  wasn't that the whole point of redefining it?  I mean how is it different than (defun foo () .. ) (labels ((foo)) .. ) ?
20:08:52 <ijp> rpr: the problem is not that _we_ are redefining, but that a user might bind a variable and _unintentionally_ break the macro
20:09:11 <ijp> which is why I took care to label the forms with "our file" "their file"
20:09:25 <ski> rpr : the caller of `bar' shouldn't have to know (or care) that the implementation of `bar' (or maybe some helper function or macro it calls ?) uses a function that is called `foo'
20:09:26 <cmccann> dmwit: most of the stuff I added is either using primitive types or is working with references that the docs say "this is statically allocated plz do not free"
20:10:02 <cmccann> it's entirely possible I've screwed up memory management somehow despite that
20:10:20 <rpr> ijp that is very unlikely. if it's your macro you should know what you are doing. if it's someone elses macro, it will use macrospackage:foo,, which is a different  foo
20:10:23 <dmwit> back, sorry
20:10:27 <ski> rpr : i don't deny that there can be cases where this kind of capture can be useful. i'm only claiming that it should not be the default. the default should be that a name refers to what is lexically in scope around the lexical use of the name
20:10:28 <ijp> rpr: unlikely happens
20:10:31 <dmwit> there was an enderbro ripping up my world
20:10:51 <cmccann> a what
20:10:51 <ijp> why go for a shitty probabilistic solution when you can fix it
20:11:04 <dmwit> cmccann: Alright. If the gtk system isn't reference counting anything, there's not much that can go wrong.
20:11:22 <dmwit> s/gtk/glib/
20:11:55 <rpr> as far as I can tell it will only break if the macro and foo are not placed in appropriate package
20:12:06 <ski> rpr : if you compare with  (defun foo (a b c) ...) (defun bar (...) .... (foo ...))  and  (labels ((foo (x y z) zot)) (bar ...))  you'll see that in this case proper lexically scoped closures makes the user-defined `foo' not interfere with the `foo' called by (the function, not macro) `bar'
20:12:17 <ski> rpr : why should it be different if we make `bar' a macro ?
20:12:39 <cmccann> dmwit: you may want to look over what I did anyway to make sure it looks sane
20:12:40 <zRecursive> If a macro uses any global symbol, it seems hard to make it work all around ?
20:12:45 <dmwit> of course
20:12:45 <cmccann> I am complete noobsauce with this stuff
20:12:52 <ijp> zRecursive: the "solution" is package
20:14:02 <zRecursive> ijp: you mean using package to limit its scope ?
20:14:36 <ski> zRecursive : "which 'foo will be used during macro expanding in your code ?" -- i'd like the first `foo' to be used. but unhygiene will make the local (`labels') `foo' be used instead
20:15:54 <zRecursive> i see now
20:16:19 <lime_> Does anyone know of a study that analyzes the frequency of math characters, symbols, alphabets, etc...?
20:16:37 <zRecursive> i know little scheme, curious how scheme implements hygiene macro ?
20:16:48 <ski> (the first `foo' is in the same file (same lexical scope) as `bar'. the second thing with `labels' is in a different file, possibly written by a different programmer)
20:16:56 <ijp> zRecursive: a "more complicated" symbol type
20:17:10 <lime_> Not exactly haskell, but I know many people are interested in the math side of things
20:17:40 <rpr> ski, I actually often prefer the macro bar behavior. I don't think I have ever accidentally redefined a function. but more than once I wanted to intentionally redefine some function locally.
20:17:49 <cmccann> dmwit: anyway, I'm going to see if I can get the gtk3 build to work and then maybe add some example code to the haddocks
20:18:08 <rpr> ski in practice packages solve this problem
20:18:12 <cmccann> that should be all I need to do though
20:18:29 <ski> aiui, packages require a global database, which is problematic
20:18:51 <dmwit> cmccann: Try checking out a clean copy of the repository.
20:18:57 * dmwit suggests the dead-chicken route
20:19:22 <dmwit> With your patches, of course. I just mean I don't trust cabal clean to really clean up everything.
20:19:35 <ski> zRecursive : did you see <http://community.schemewiki.org/?hygiene>,<http://community.schemewiki.org/?hygiene-versus-gensym> yet ?
20:19:41 <cmccann> dmwit: ah, ok
20:19:45 <ski> zRecursive : <http://library.readscheme.org/page3.html> might also be interesting
20:20:07 <cmccann> I was about to say that I pulled latest like 12hrs ago so it's not out of date or anything
20:20:08 <zRecursive> ski: ok
20:20:15 <ijp> rpr: sure, and in practice custom-prefix-var works for emacs. and in practice PHP is widely used
20:20:39 <ijp> that doesn't mean we shouldn't be fixing it in newer systems
20:21:09 <zRecursive> ski: i am using CL. so i always avoid using global symbol in macro.
20:21:25 <ski> zRecursive : also, the Barzilay post i mentioned above is interesting wrt when you want to (in a controlled fashion) break hygiene
20:21:31 <ijp> zRecursive: so, you've never written a macro?
20:22:01 <zRecursive> not never but few
20:22:30 <zRecursive> the symbol is from #'gensym
20:25:48 <flebron> Is it more efficient to say a = if x then foo else bar, b = if x then baz else quux, or to say (a, b) = if x then (foo, baz) else (bar, quux)?
20:26:38 <flebron> And if I don't care about currying, is it more efficient to pass things as tuples, or as regular parameters?
20:27:00 <latro`a> I doubt you're going to get a clean answer to that question
20:27:08 <ijp> premature optimisation much?
20:27:12 <latro`a> at any rate it should be a small difference
20:27:15 <latro`a> if any difference
20:27:18 <flebron> Not premature, coding competition. Every msec matters :)
20:27:23 <latro`a> given GHC being itself, I doubt it matters
20:27:35 <cmccann> flebron: that kind of local case analysis is something GHC is good at, I think
20:27:42 <rpr> ijp, I am not sold on the fix. when it takes 2 pages to introduce hygienic macros, vs 2 sentences it takes to explain backquoted macro syntax
20:27:47 <cmccann> you should inspect the generated core to see if they're even different at all
20:27:56 <ski> flebron : personally i'd use guards ..
20:28:24 <cmccann> cf. monochrom being thwarted by GHC when trying to complain about conditional checks vs. pattern matches
20:28:43 <cmccann> (which was hilarious)
20:28:48 <ijp> rpr: not really an accurate comparison
20:29:07 * u_ witnesses some sort of sneaky HFT thing happening on bitstamp
20:29:11 <u_> only it's more like MFT
20:29:15 <u_> medium freq trading
20:29:16 <ijp> I agree it takes much less time to do something the wrong way, than to explain the problem, and tell people how to fix it
20:29:21 <u_> cause they limit API accesses to one per second
20:30:26 <u_> some guy tried to order one bitcoin, and some seller was making the price slowly creep up by one cent every few seconds
20:30:58 <ijp> rpr: the accurate comparison would number of pages to describe hygienic macros, vs number of pages to introduce defmacro, gensym, and packages
20:31:28 <u_> oh fuck
20:31:29 <u_> wrong channel
20:31:30 <u_> sorry
20:31:46 <ijp> not to mention, now they are duplicating this information every time they write a macro
20:32:06 <silasm> ski: speaking of guards, is there a good reason for the fact that putting a comment line between two guards causes a compilation error? Cause that's mega-frustrating.
20:32:40 <silasm> I was trying to deal with that today and ended up just using if then else's instead, and now my syntax (or rather, style) checker is complaining.
20:32:42 <kennyd> ijp, how is the problem different than accidentally redefining a special that is used by some function?
20:32:43 <Cale> what?
20:32:51 <ski> > let a | otherwise = 0 {- comment -} | otherwise = 1 in a
20:32:53 <lambdabot>   0
20:33:08 <Cale> silasm: putting comment lines between guards should be fine
20:33:33 <silasm> no, a full newline causes a parse error for me.
20:33:33 <ijp> kennyd: the problem is fundamentally the same one, just the context is different
20:33:38 <Cale> (even with --)
20:33:41 <ski> silasm : works for me
20:33:48 <silasm> I could try {- on the previous line or something...
20:33:53 <Cale> silasm: perhaps you could put your code on hpaste?
20:33:53 <rpr> and that problem is fixed with packages - something tha scheme lacks
20:34:01 <silasm> Cale: sure
20:34:15 <silasm> It's kind of monstrous, too. Maybe you can suggest a better way to format it.
20:34:22 <ijp> rpr: yes, good for you that you have ignored all the work on scheme since the 90s
20:35:15 <rpr> ijp, there's a standard scheme package system?
20:35:35 <ijp> let's see. 1) lots of research went in to modules for scheme 2) every practical scheme has a module system 3) r6rs specifies a modules system 4) r7rs will specify a module system
20:35:49 <xplat> rpr: pretty much the way sql injection is fixed by forbidding semicolons in input fields?
20:36:06 <rpr> every practical scheme has one. and they are all incompatible with each other
20:36:14 <ijp> yes, ignore points 3 and 4
20:36:57 * Cale is amused by this discussion by rpr and ijp. Which untyped language is safer? :D
20:37:16 <ijp> Cale: that was actually my point earlier :)
20:37:52 <xplat> Cale: heh, but srsly, untyped languages do have different *degrees* of scariness
20:37:56 <silasm> gah, hang on. I'll try to write up an example.
20:38:08 <silasm> since I already formatted my code and comments for if statements
20:38:08 <rpr> given my experience in scheme, I am not putting much faith into portability of r6rs and r7rs module systems
20:38:28 <xplat> let's put a package system on elisp so we can solve the problems with dynamic scope too!
20:38:37 * ski thinks the lexical scoping issue is mostly orthogonal to type regime
20:38:53 <ijp> rpr: r7rs: who knows? But I have _personally_ written code that runs on upwards of six schems using the r6rs module system
20:39:13 <ski> xplat : ELisp actually has gained `lexical-let', now
20:39:16 <ijp> that's amazing when you consider scheme is balkanised worse than the balkans
20:39:34 <sparky3> why doesn't (-2) make a function?
20:39:53 <sparky3> map (-2) [1..5]
20:39:55 <ski> > map (subtract 2) [0 .. 4]
20:39:55 <Cale> sparky3: because it's negative 2
20:39:57 <lambdabot>   [-2,-1,0,1,2]
20:40:12 <ski> > map (flip (-) 2) [0 .. 4]
20:40:15 <lambdabot>   [-2,-1,0,1,2]
20:40:22 <ski> > map (\n -> n - 2) [0 .. 4]
20:40:23 <Cale> sparky3: there's a bit of a special case there
20:40:23 <sparky3> ah I see
20:40:24 <lambdabot>   [-2,-1,0,1,2]
20:40:31 <xplat> is this off-topic discussion supposed to be about the advantages of hygienic vs unhygienic macros or about whether common lisp or scheme is swankier?
20:40:34 <ski> > map (- 2) [0 .. 4]
20:40:37 <lambdabot>   [-2,-2,-2,-2,-2]
20:41:12 <ski> xplat : (afaiu) it's about hygiene, as that applies to macros and other staged computation
20:41:40 <ijp> xplat: it's degenerated somewhat
20:41:46 <silasm> hm, I'm not getting the error anymore. Must have been something more complicated. My bad, I'll get back to you when I know more.
20:41:55 <silasm> if it's still relevant
20:42:13 <sparky3> > map (- 2) [1..5]
20:42:15 <ski> silasm : might have been bad indentation. perhaps caused by tabs vs. spaces
20:42:16 <lambdabot>   [-2,-2,-2,-2,-2]
20:42:19 <sparky3> so I need space
20:42:28 <ski> > 2 3 4
20:42:31 <lambdabot>   2
20:42:38 <carter> hey all, wasn't there some folks who'd recently made a new version of the haskell financial contracts code released ?
20:42:41 <mapreduce> Could there exist an encoding of balanced trees (AVL trees) that precludes any unbalancing in the type system without requiring dependent types?
20:42:43 <carter> i'm trying to dig up a reference for a friend
20:42:43 <sparky3> wait, why did that return all -2s ?
20:42:45 <ski> > map (-2) [0 .. 4]  -- look ma, no space
20:42:47 <lambdabot>   [-2,-2,-2,-2,-2]
20:43:30 <Cale> sparky3: Because there's an instance of Num for functions in scope
20:43:30 <sparky3> I get error in ghci
20:43:33 <mapreduce> > map ((-)2) [0..4]
20:43:36 <lambdabot>   [2,1,0,-1,-2]
20:43:38 <ski> sparky3 : because `instance Num a => Num (rho -> a) where fromInteger n = \_ -> fromInteger n; f0 + f1 = \r -> f0 r + f1 r; ...'
20:43:46 <xplat> mapreduce: yes, you could use GADTs and if you count those as dependent types somehow because of their origin you could always just use nested types instead
20:44:12 <silasm> silasm: mayhaps. Maybe I was missing an = somewhere. Either way it's working with guards now, so sorry for the false alarm.
20:44:18 <Cale> sparky3: where integer literals are interpreted as constant functions, and numerical operations on functions are pointwise
20:44:41 <Cale> ski: In a way, it's true that issues about type safety are separate from issues about macro hygiene. But if you're just looking at things from a "how well does this language help me prevent myself from writing code which is horribly broken?" standpoint...
20:45:50 <mapreduce> xplat: A nested type would be such as data AVL a = Leaf a | Left (AVL a) a | Right a (AVL a) | Both (AVL a) a (AVL a), right?
20:45:55 <silasm> ski: err, meant to direct that at you rather than myself, lol.
20:46:33 <ijp> Cale: <ijp> anyway, I find it deeply amusing that people are defending an unsafe-by-default practice on #haskell
20:47:08 <mapreduce> xplat: If so, that doesn't prevent unbalancing afaict, one could still have Left (Left (Left (Leaf 3) 4) 5) 6
20:47:56 <ski> mapreduce : <http://www.reddit.com/r/programming/comments/w1oz/how_are_gadts_useful_in_practical_programming/cw3i9> is red-black. possibly something similar is possible for AVL
20:48:27 <xplat> mapreduce: no, nested is when you change the parameter (the argument of AVL) in the recursive uses.  there's an article called 'faking it' that will teach you how to do things like that
20:48:31 <sparky3> > map (2-) [5..10]
20:48:33 <lambdabot>   [-3,-4,-5,-6,-7,-8]
20:48:45 <ski> mapreduce : "Polymorphic stanamically balanced AVL trees" by Oleg Kiselyov in 2003-04-26 at <http://www.okmij.org/ftp/Haskell/types.html#stanamic-AVL> might also be fun
20:49:05 * mapreduce prepares to be olegged.
20:49:51 <ski> Cale : *nod*. still different concerns, though
20:49:58 <Cale> ijp: Not only is it amusing from that perspective, but the fact that it's an argument about a kind of safety which is only a tiny fraction as meaningful as type safety in languages which have eschewed type safety...
20:50:08 <ski> (and possibly they apply with different weight to different people)
20:51:39 <Cale> But yeah, I'm sure not everyone sees it the same way :)
20:51:48 <ski> mapreduce : `data PerfectlyBalancedTree a = Elements a | Double (PerfectlyBalancedTree (a,a))' is an example of nested
20:52:29 <sparky3> nice, there's printf in haskell too
20:52:39 <ski> (with `PerfectlyBalancedTree a' being essentially `(n :) |N * a^n')
20:52:39 <Cale> fsvo nice
20:53:03 <ski> > printf "%s" 0 :: String
20:53:05 <lambdabot>   "*Exception: Printf.printf: bad argument
20:53:11 <Cale> There are some things for which I have to admit it's convenient.
20:53:34 <xplat> also, with macros you can embed a typed language in a lisp, but that can hardly be safe if the macros are not hygienic :P
20:53:36 <mapreduce> ski: xplat: Thanks.
20:53:37 <cmccann> Cale: the value of nice involved is polymorphic and depends on context and what arguments you apply it to
20:53:50 <Cale> (specifically, the functions for numeric formatting kinda suck enough that it makes printf look good)
20:53:54 <ski> mapreduce : try figuring out a couple of (total) values of type `PerfectlyBalancedTree Integer', e.g.
20:54:43 <Cale> sparky3: You might be amused to note that printf is both printf and sprintf
20:54:47 <sparky3> > printf "%s" "hello"
20:54:49 <lambdabot>   Ambiguous type variable `a0' in the constraints:
20:54:49 <lambdabot>    (GHC.Show.Show a0)
20:54:49 <lambdabot>     ...
20:54:56 <cmccann> dmwit: something I may or may not have done may or may not have magically fixed the gtk3 build.
20:55:00 <Cale> > printf "%s" "hello" :: String
20:55:01 <lambdabot>   "hello"
20:55:09 <Cale> :t printf "%s" "hello" :: IO ()
20:55:12 <lambdabot> IO ()
20:55:14 <simpson> Okay, still trying to get the hang of StateT []. Am I right in my thinking that *all* modifications I make to my state will be "undone on backtrack"?
20:55:24 <Cale> simpson: yes
20:55:55 * ski wants macros which have statically assigned syntactic classes to its subforms and result
20:55:56 <Cale> simpson: StateT s m a ~= s -> m (a,s)
20:56:14 <Cale> simpson: So, StateT s [] a ~= s -> [(a,s)]
20:56:28 <simpson> Cale: Right. So when I guard, I'm just taking my [(a, s)] and setting it to [] on that branch.
20:56:53 <Cale> yeah, basically
20:57:42 <ski> (so that i can get different namespaces for different "languages" (say in Racket sense, perhaps sans reader syntax), and so that i can get call-by-value macros)
20:58:09 <ski> @untml StateT s m a
20:58:09 <lambdabot> Maybe you meant: unmtl unpl
20:58:14 <ski> @unmtl StateT s m a
20:58:14 <lambdabot> s -> m (a, s)
20:58:20 <ski> @unmtl StateT s [] a
20:58:20 <lambdabot> s -> [(a, s)]
20:58:46 <xplat> a ListT (State s) otoh will have your state persist across branches (although the normal ListT doesn't 'work right' for noncommutative base monads like State, you have to use a special one)
20:59:00 <ski> simpson : think of `StateT s m' as `s'-state passing "on top of" basic effects described by `m'
20:59:17 <xplat> @unmtl ListT (State s) a
20:59:19 <lambdabot> s -> ([a], s)
20:59:38 <Cale> ListT does not produce a monad when applied to State s though
20:59:40 <latro`a> doesn't ListT turn out to not be a valid transformer?
20:59:41 <latro`a> yeah
20:59:44 <ski> simpson : so `StateT s []' means that you have a basic system with nondeterminism, and then you pass state on top of that (so each "branch" will have its own state, which is passed forward (only))
20:59:51 <xplat> yeah, that's the ListT that's not quite right
21:00:22 <Cale> ListT is only okay to apply to commutative monads, of which there are not so many practical examples.
21:00:28 <cmccann> the "bad" ListT is the one that wants to be a nondeterminism monad transformer
21:00:35 <Cale> (basically Reader and Identity)
21:00:44 <cmccann> it needs a commutative monad because it's trying to pretend that the order of items in the list doesn't matter
21:02:31 <simpson> ski: Sure.
21:02:38 <cmccann> the "good" ListT is the one that acts like a stream, where the order is significant
21:07:20 <xplat> Cale: also Writer if the Monoid is commutative...
21:10:57 <_just> > tail $ dropWhile (/=',') "10,2"
21:10:59 <lambdabot>   "2"
21:12:23 <xplat> > let dropTo = (drop 1 .) . dropWhile . (/=) in dropTo ',' "10,2"
21:12:25 <lambdabot>   "2"
21:14:16 <sparky3> Cale that is amusing (printf being both sprintf and printf)
21:16:04 <ski> simpson : also see "Monads, a Field Guide" by dpiponi in 2006-10 at <http://blog.sigfpe.com/2006/10/monads-field-guide.html>
21:16:48 <simpson> ski: Nice.
21:17:17 <sparky3> it's impressive haskell can do that.. but I think I prefer separate names for them. maybe I'll like it when I get used to it though
21:19:52 <ski> @let dropTo = (drop 1 .) . dropWhile . (/=)
21:19:54 <lambdabot>  Defined.
21:20:03 <ski> > dropTo ',' "10,2,34"
21:20:05 <lambdabot>   "2,34"
21:20:20 <ski> hm, no `remberUptoLast', i see
21:21:36 <sparky3> > dropWhile (/=',') "10,2,34"
21:21:37 <lambdabot>   ",2,34"
21:21:49 <sparky3> ah I see what you wanted
21:23:21 <ski>   "The function `rember-upto-last' takes an atom `a' and a `lat' [list of atoms] and removes all the atoms from the `lat' up to and including the last occurence of `a'. If there are no occurences of `a', `rember-upto-last' returns the list."
21:23:55 <ski>   (from "The Seasoned Schemer" by Matthias Felleisen,Daniel P. Friedman in 1996)
21:29:11 <ski> (also "`rember-upto-last' without `cons'-ing" at <http://www.ccs.neu.edu/home/matthias/BTSS/rember-upto-last.html> and "Categorical Structure of Continuation Passing Style" (pages 9 through 14) (Ph. D. thesis) in 1997 at <http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-376/>, by Hayo Thielecke)
21:36:46 <flebron> So say I had some ugly, but short code as such: http://ideone.com/yu8MaO . What would be the effect of using BangPatterns on go's parameters? (go inside g).
21:37:08 <flebron> The code is computing the power of a 2x2 matrix, modulo some number m, logarithmically.
21:40:46 * hackagebot binary-file 0.15.24 - read/write binary file  http://hackage.haskell.org/package/binary-file-0.15.24 (YoshikuniJujo)
21:47:01 <jfischoff> parcs: the patch is working. I'm gathering some informal stats
21:47:16 <jfischoff> got bytestring to build twice as fast with -N4 and -j3 playing with packages and configs
21:48:22 * jfischoff is pretty excited about parallel ghc make
21:50:06 <arbn> jfischoff: Woah. There's a parallel ghc make? In what version?
21:50:27 <tgeeky> path => versionless
21:50:30 <tgeeky> patch*
21:52:30 <jfischoff> arbn: parcs made a patch I'm testing out
21:52:39 <jfischoff> against HEAD
22:05:56 <arbn> jfischoff: Cool.
22:26:00 <matthiasgoergens> Are there some already written functions to sort arrays in Haskell?  (Not lists.)
22:26:41 <simpson> matthiasgoergens: When you say "array", are you talking about Data.Array?
22:27:33 <matthiasgoergens> Possibly, but I wouldn't mind another array or vector library.  I just need a data structure that has less overhead than lists.
22:27:48 <matthiasgoergens> My access pattern would actually be suited to lists otherwise.
22:28:17 <matthiasgoergens> My data is immutable, too.
22:30:26 <matthiasgoergens> But it is (currently) around 10 MiB, and Lists didn't seem to handle that well.
22:31:52 <cmccann> try using vector
22:32:22 <cmccann> which are basically arrays optimized for being treated like lists in certain ways
22:32:35 <cmccann> depeneding on what exactly you're doing it might work well
22:34:19 <AfC> I still wonder why (:) and [ , ] syntax aren't implemented by the compiler as Data.Vector (or whatever)
22:34:46 <applicative> you mean rather than as pertaining to lists?
22:34:50 <cmccann> because often lists are actually what you want
22:35:11 <cmccann> they have relatively low overhead for small amounts of data and behave nicely for lazy iteration and such.
22:35:26 <applicative> I think there was an idea of 'stream fusion'izing ghc's list handling, but it lost out to the going method of optimization
22:35:42 <cmccann> I don't think they ever got it working well enough to make official.
22:35:47 <matthiasgoergens> AfC, you could get overloaded lists, like you can get overloaded strings.
22:36:02 <latermus1> matthiasgoergens: vector looks good for what you are talking about
22:36:06 <cmccann> that's in GHC HEAD now, isn't it?
22:36:12 <applicative> it is for example not too great for things like concatMap
22:36:17 <Ghoul_> Hi haskell
22:36:36 <matthiasgoergens> latermus1, ok, I'll try.  Alternatively, I have used the Unix sort programme to sort my records, and then read them back in.
22:36:51 <Ghoul_> http://hpaste.org/87304 line 18 I would like to have another structure inside one of the variants of Stmt, however I cannot
22:37:02 <applicative> matthiasgoergens: there is a sorting package for Data.Vector.Unboxed
22:37:08 <applicative> what's it called?
22:37:14 <Ghoul_> I get "Not in scope: type constructor or class 'Call'"
22:37:25 <Ghoul_> (But shouldn't it be in global scope?)
22:37:54 <applicative> matthiasgoergens: http://hackage.haskell.org/package/vector-algorithms
22:38:29 <applicative> eight implementations, pick your poison ...
22:39:18 <matthiasgoergens> Thanks!
22:40:26 <matthiasgoergens> I am trying to break the two time pad.
22:46:11 <Ghoul_> can anyone help me with my question up there a bit ^
22:46:17 <Ghoul_> :)
22:47:59 <applicative> Ghoul_: yeah, line 18 doesnt make sense as it stands
22:48:32 <Ghoul_> applicative: well
22:48:44 <Ghoul_> How do I express something like that
22:49:09 <Ghoul_> a CallStmt must be an Expr of type Call
22:49:14 <Ghoul_> or, can't I?
22:50:53 * hackagebot pipes 3.3.0 - Compositional pipelines  http://hackage.haskell.org/package/pipes-3.3.0 (GabrielGonzalez)
22:51:17 <hpaste> “Dharmender Kumar” pasted “manpower consultants in delhi” at http://hpaste.org/87306
22:51:52 <applicative_> there isn't such a thing as 'Expr of type Call'
22:52:18 <applicative_> any Call is a value of type Expr
22:53:09 <applicative_> there isn't a type Call as it stands Ghoul_
22:53:25 <applicative_> Is there are reason for wanting a Call to be both an Expr and a Statement?
22:54:20 <hpaste> alex pasted “X11 "Hello World"” at http://hpaste.org/87307
22:54:21 <hpaste> alex pasted “X11 "Hello World"” at http://hpaste.org/87308
22:54:22 <Ghoul_> applicative_: yes, there is
22:54:35 <Ghoul_> I couldn't really distinguish between a = b();
22:54:40 <Ghoul_> and b(); easily
22:56:10 <applicative_> there is also the possibility of           | Call String [Expr]  and           | CallStatement String [Expr]
23:11:30 <Watabou> ahhh why is haskell so confusing... I feel extremely dumb trying to follow "Learn you a haskell"
23:13:28 <applicative_> Watabou: don't worry our friends here can help .  Or they can with any given definite problem....
23:13:37 <kostja> Good morning! :)
23:13:56 <Watabou> I'm just confused by how pattern matching actually works
23:14:15 <Watabou> I'm on this chapter: http://learnyouahaskell.com/syntax-in-functions#pattern-matching
23:15:04 <Watabou> I guess I will get it soon enough. This is not a chapter to be read in a day haha
23:15:10 <jocolloman> I am looking for a haskell testing framework. I've heard of HUnit. Are there others that people suggest?
23:15:22 <applicative_> its a little odd to take 'lucky 7 = "blah" as a paradigmatic pattern match, Watabou
23:16:18 <dmwit> cmccann: That was about how I felt when things started working for me, too.
23:16:25 <dmwit> no freaking clue what I changed
23:16:30 <dmwit> but suddenly: everything works
23:16:40 <cmccann> I poked a bunch of things and reinstalled some dependencies
23:16:43 <cmccann> one of which clearly helped
23:16:55 * dmwit shrugs apologetically
23:17:58 <Ghoul_> :t call
23:18:00 <lambdabot>     Not in scope: `call'
23:18:00 <lambdabot>     Perhaps you meant one of these:
23:18:00 <lambdabot>       `all' (imported from Data.List),
23:18:04 <silasm> jocolloman: haven't tried it myself, but isn't that what quickcheck is for?
23:18:09 <Watabou> applicative_: Yeah I doubt I will use something like that. But that factorial example seems pretty nice. it's so beautiful.
23:18:09 <kostja> I think I got the concept of monads, but I actually don't understand the implications for syntax. I'm trying to run a sequence of IO actions and collect the results in a list. The following attemt fails with a type error, and I'm not sure, if I can solve this issue or if the "ansatz" is completely wrong: sequenceIO :: [IO a] -> IO [a]; sequenceIO [] = return []; sequnceIO (a:as) = a >>= (: sequenceIO as)
23:19:01 <cmccann> dmwit: anyway, I decided to add a couple minor things from the input device stuff, which I'd skipped before
23:19:22 <djahandarie> Watabou, I don't really like that chapter too much, I wish it explained pattern matching based on a previous defined data type.
23:19:36 <shachaf> kostja: You're trying to make it point-free. Don't do that.
23:19:39 <jocolloman> silasm: I'm not sure. I have not done any testing in Haskell but my latest project is actually large enough that I think it owuld be a good idea. I am hoping to provide a library that others could use and would like to keep myself from breaking it between versions :P
23:19:48 <shachaf> kostja: Expand it out, first.
23:19:53 <applicative_> @type let sequenceIO [] = return []; sequenceIO (a:as) = a >>= (: sequenceIO as) in sequenceIO
23:19:54 <lambdabot> [[[a]]] -> [[a]]
23:19:58 <shachaf> Then think about the types of each thing.
23:20:19 <applicative_> hm, what have you done there kostja
23:20:27 <Watabou> yeah I'm just confused by what pattern matching really means at this point, djahandarie. Some exercises might help. I wish this book had some.
23:20:41 <djahandarie> Watabou, basically, if you know a given input is of some type, you know that it will be one of some possible different values -- with pattern matching you can give the function different behavior for each of those those different values.
23:21:16 <cmccann> dmwit: and re-test some stuff to make sure everything works. I got a random inexplicable segfault but I think that was because something confused GHCi while I was reinstalling other things somehow, not sure. :T
23:21:35 <kostja> shachaf: to 'expand it out'? what do you mean by this?
23:21:36 <djahandarie> Watabou, i.e.,     data Dog = Bob | Joe; dogId :: Dog -> Int; dogId Bob = 1; dogId Joe = 2          or something silly like that might help.
23:21:48 <Watabou> oh okay that makes sense. djahandarie. so it's somewhat like an if statement?
23:22:01 <elliott> it's better than if
23:22:02 <shachaf> kostja: Start out by writing out the lambda: a >>= (\x -> x : sequenceIO as)
23:22:10 <applicative_> djahandarie: right,  "I wish it explained pattern matching based on a previous defined data type."  that's what i was finding odd about lucky 7 etc though they arent wrong
23:22:13 <shachaf> kostja: Now tell me the type of each thing there.
23:22:21 <djahandarie> Watabou, it's kind of related.
23:22:38 <djahandarie> Certainly it shares the conditional nature.
23:22:48 <Watabou> elliott: hmm okay, as in just syntax or...?
23:22:58 <arkeet> as in
23:23:03 <arkeet> if only lets you branch in 2 ways.
23:23:20 <arkeet> with no extra information.
23:23:23 <shachaf> if is the devil only because booleans are the devil.
23:23:30 <arkeet> but most things aren't Bool
23:23:39 <Watabou> oh okay, got it.
23:23:56 <cmccann> dmwit: anyway, I was about to go sleep, sometime in the next few days I'll try to figure out how to send a patch with darcs
23:23:57 <Watabou> thanks for the explanation
23:24:20 <applicative_> Watabou: if a type has == then the first few examples in lyah could be reduced to if x == 7 then ..., and if x == 'a' then ... else if x == 'b' then .... but that would be a bad idea ...
23:24:21 <elliott> cmccann: "darcs send" or something?
23:24:29 <cmccann> I don't know. maybe.
23:25:08 <cmccann> it's probably something just exactly simple enough that I'll manage to do it wrong anyhow.
23:25:08 <applicative_> booleans are the devil!
23:25:37 <Watabou> haha, why though, I kinda like booleans in other languages
23:25:40 <kostja> shachaf: the type of (a >>=) is (b -> m c) -> m c and the type of (\x -> x : sequenceIO as) should be exactly that, where [c] = b and b is the type of the variable a
23:25:45 <Watabou> Or is this just for haskell?
23:26:35 <djahandarie> Watabou, re: pattern matching vs if-statements; if-statements branches on booleans, pattern matching is about branching (and often, extracting information) based on the different inputs you have.
23:27:00 <applicative_>  (\x -> x : sequenceIO as) has type something like  a -> [a]
23:27:03 <shachaf> kostja: What is the type of: a, x, as, sequenceIO as
23:27:32 <cmccann> the flip side of pattern matching vs. booleans is the advice in OO languages of using polymorphism to dispatch for different behaviors, rather than writing a bunch of conditionals.
23:28:13 <djahandarie> Watabou, people don't like if-statements because they 'lose information' in some sense, but that's kind of a high-level point and honestly not very relevant for most of anything someone would write in Haskell.
23:28:30 <shachaf> djahandarie: ?
23:28:52 <Watabou> ah okay, I think I'm getting it a little djahandarie.
23:29:01 <shachaf> djahandarie: It is relevant to if null xs then 0 else head xs + f (tail xs)
23:29:09 <kostja> if IO b is the type of a, then x has type b, as has type [IO b] and sequenceIO as has type IO [b]
23:29:20 <shachaf> Right.
23:29:20 <applicative_> ick
23:29:25 <shachaf> And the type of (:)?
23:29:50 <djahandarie> shachaf, I mean to say that people use if-statements and booleans all the time in 'real world' haskell and it's fine. Sometimes you can get rid of them easily but other times it's a pain.
23:30:24 <djahandarie> In the end it's only something a higher-level programmer would be caring about though, I think.
23:32:21 <kostja> shachaf: it should be b -> IO [b], which of course it hasn't
23:32:22 <MercurialAlchemi> djahandarie: How do you lose information with if statements?
23:32:35 <Watabou> ^ yeah I want to know this as well
23:32:40 <shachaf> kostja: No, I asked what it is, not what it should be. :-)
23:32:57 <shachaf> But I guess you see where the error is now, at least.
23:33:05 <MercurialAlchemi> djahandarie: you could actually make the argument that you're more at risk of losing information by pattern-matching if your match is not total
23:33:13 <arkeet> don't do that then.
23:33:14 <applicative_> Watabou: shachaf's example, blah f xs = if null xs then 0 else head xs + f (tail xs) is a typical definition without pattern matching ; how would we write it with pattern matching?
23:33:18 <kostja> in general it has type t -> [t]
23:33:30 <elliott> MercurialAlchemi: see http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
23:33:44 <elliott> in "if isJust x then ... else ..." you lose the information that x is (Just y) for some y in the then branch
23:33:51 <shachaf> applicative_: "f" was meant to be a recursive call there. :-)
23:33:54 <elliott> which means you the programmer have to keep track of it manually
23:33:55 <shachaf> @where crossroad
23:33:55 <lambdabot> http://www.vex.net/~trebla/haskell/crossroad.xhtml
23:34:01 <elliott> and e.g. this affects the validity of fromJust inside ...
23:34:01 <shachaf> monochromticle!
23:34:37 <kostja> shachaf: in general it has type t -> [t]
23:34:46 <applicative_> shachaf: yeah it doesn't matter what it is
23:34:57 <shachaf> kostja: No, t -> [t] -> [t]
23:35:02 <shachaf> applicative_: I know.
23:35:22 <applicative_> Watabou: shachaf's example f xs = if null xs then 0 else head xs + f (tail xs)
23:35:38 <Watabou> yeah I was just reading that
23:35:51 <Watabou> I'm thinking of a way to do it with pattern matching
23:36:12 <applicative_> @type let f xs = if null xs then 0 else head xs + f (tail xs) in f
23:36:14 <lambdabot> Num a => [a] -> a
23:36:26 <kostja> shachaf: yes, you're right. so I would need a bind to get it work with IO [t]
23:37:32 <applicative_> Watabou: well, lists have two basic cases, or patterns, [] and x : xs
23:37:44 <shachaf> kostja: You need another >>=, yes.
23:38:01 <Watabou> what is the type of x in this case applicative_
23:38:19 <Watabou> oh a list oops
23:38:33 <Watabou> okay so an empty list and [x]
23:38:33 <applicative_> Watabou: so  f [] = ?  in the definition f xs = if null xs then 0 else head xs + f (tail xs)
23:39:08 <applicative_> Watabou: it doesn't matter what the type of x is as long as it has 0 and +, thats why the inferred type was Num a => [a] -> a
23:39:33 <MercurialAlchemi> elliott: I kind of see where he is coming from, but I'm not sure of how convinced I am
23:39:59 <applicative_> > let f xs = if null xs then 0 else head xs + f (tail xs) in f [1,2,3]
23:40:02 <lambdabot>   6
23:40:19 <MercurialAlchemi> elliott: though considering I use pattern matching when possible, I'm probably somewhat convinced :)
23:40:24 <applicative_> Watabou: so thats f [1,2,3] what is f [] going to be?
23:40:37 <arkeet> MercurialAlchemi: if you write  if isJust x then ... (fromJust x) ... else ...
23:40:39 <djahandarie> MercurialAlchemi, few different things. First, elliott's point about the compiler not knowing about 'what happened' in the predicate. Secondly, you lose the ability to reflect info on the type level with GADT value matching. Thirdly, you lose the ability to construct equality proofs / types when using a bool, which means it's possible to lie to the compiler about things being equal sometimes.
23:40:43 <Watabou> hmm okay
23:40:56 <djahandarie> (Let me know if that got cut off.)
23:41:01 <applicative_> > let f xs = if null xs then 0 else head xs + f (tail xs) in f []
23:41:03 <lambdabot>   0
23:41:13 <arkeet> MercurialAlchemi: when you use fromJust x, you have to remember that x is necessarily a Just. you've checked that it is, but the checking and consumption are not in the same place.
23:41:14 <Watabou> wait f[] would be 0
23:41:34 <djahandarie> (Note, first two points were about if-statements, third was about booleans, but they are all related.)
23:41:36 <applicative_> Watabou: so we might start over and define on two lines, first, f [] = 0
23:41:51 <djahandarie> Lists are like the /worst/ thing to learn about pattern matching on.
23:41:51 <elliott> djahandarie: it did not
23:41:52 <applicative_> Watabou: right
23:41:54 <djahandarie> Due to special syntax.
23:41:58 <Watabou> yeah, I already have that but what would the next case be?
23:42:01 <arkeet> so if you change that code, it's possible to accidentally forget to maintain that you're using fromJust on a Just value.
23:42:02 <Watabou> f[xs] =
23:42:31 <MercurialAlchemi> arkeet: on the other hand, you have plenty of things you need booleans for, since you can't pattern match on it
23:42:50 <applicative_> Watabou: but now the list might have one or more elements, so it has the shape (x:xs)  -- note xs might be [] -- so what should we write after f (x:xs) = ...
23:42:55 <arkeet> meanwhile, matching on the Just keeps the checking and extraction in one place, and the compiler can check that you're using it properly.
23:42:56 <Watabou> something like f [x] = head x + tail f[x]
23:43:19 <arkeet> MercurialAlchemi: sometimes you can't avoid them, sure.
23:43:24 <Watabou> this is with my poor knowledge of haskell syntax thus far
23:43:27 <applicative_> [x] is a good pattern, short for x:[] but we dont need it here
23:43:42 <Watabou> really? how come?
23:43:53 <applicative_> f [] = 0; f (x:xs) = ....
23:43:54 * djahandarie reiterates point about lists being a piss-poor example for learning about pattern matching
23:44:12 <MercurialAlchemi> arkeet: though I have to admit I'm a bit divided about pattern matching - it's absolutely wonderful, but it also absolutely breaks encapsulation
23:44:23 <applicative_> Watabou: because the case x:xs covers it, since as  I said, it covers the case where xs is []
23:44:27 <arkeet> breaks what now?
23:44:43 <Watabou> ah okay
23:45:01 <applicative_> Watabou: in some definitions we would want to make a special case for [x] the singleton one-member lists
23:45:17 <applicative_> Watabou: but this isn't one.
23:45:30 <arkeet> [x] always means a list with just one element.
23:45:38 <matthiasgoergens> MercurialAlchemi: you can restrict pattern matching to things that you do not need encapsulated in a specific context.  And there are always View Patterns.
23:45:46 <Watabou> ah, did not actually know that arkeet
23:45:56 <MercurialAlchemi> arkeet: well, with a clever use of lenses and not exporting constructors, you can hide the shape of your data
23:45:59 <Watabou> So does x:xs mean multiple elements?
23:46:07 <matthiasgoergens> Means: At least one element.
23:46:10 <MercurialAlchemi> matthiasgoergens: you can?
23:46:15 <matthiasgoergens> x:[] is equivalent to [x].
23:46:18 <applicative_> x:xs is made up of a value and a list of things of that same type (which might be empty)
23:46:24 <arkeet> x:xs has one more element than xs.
23:46:26 <arkeet> whatever xs may be.
23:46:31 <arkeet> it may be empty.
23:46:35 <Watabou> ah gotcha
23:47:00 <matthiasgoergens> MercurialAlchemi: See http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
23:47:00 <arkeet> it's probably best to forget about the [x,y,z] syntax for the moment.
23:47:03 <Watabou> so f (x:xs) = head x + tail f(xs)
23:47:27 <matthiasgoergens> Watabou: don't forget the tail case!
23:47:32 <matthiasgoergens> oops, base case.
23:47:36 <applicative_> close but why are you using head, what is the head of (x:xs)
23:47:47 <Watabou> oh it's just x
23:48:00 <applicative_> what is the tail of x:xs
23:48:11 <Watabou> [xs] right?
23:48:23 <applicative_> xs
23:48:35 <Watabou> is xs not a list?
23:48:36 <arkeet> it's probably best to forget about the [x,y,z] syntax for the moment.
23:48:39 <arkeet> xs is a list.
23:48:43 <applicative_> [xs] is the one member list of lists, whose only member is xs whatever it is
23:48:45 <arkeet> [xs] is a list of lists.
23:48:47 <MercurialAlchemi> matthiasgoergens: thanks
23:49:00 <Watabou> hmm okay
23:49:08 <matthiasgoergens> MercurialAlchemi: some form of lenses might be more modern.  But I am not up to date on those.
23:49:53 <matthiasgoergens> The view patterns make sense, e.g. for splitting your heap into top element and rest, no matter how your heap is implemented.
23:50:20 <applicative_> so instead of f zs = if null zs then 0 else head zs + tail zs Watabou if we pattern match we write
23:50:31 <applicative_> f [] = 0 -- as above , and
23:50:35 <Watabou> yeah
23:50:38 <applicative_> f (x : xs) = ?
23:50:51 <Watabou> x + tail f(xs)
23:51:08 <arkeet> what does tail f(xs) mean?
23:51:20 <Watabou> oh sorry tail (xs)
23:51:24 <Watabou> forget the f there
23:51:25 <applicative_> the tail in the other definition was the tail of the whole list; but the whole list here is x:xs, whats the tail of x:xs
23:51:50 <Watabou> it's xs
23:51:51 <kostja> shachaf: I don't get it done. I think I need to bind sequenceIO as into the second argument of (:), but I don't understand how to do so.
23:51:54 <arkeet> are we trying to write sum?
23:52:01 <arkeet> (just to make sure I'm following)
23:52:05 <applicative_> Watabou: yes! so we write
23:52:13 <applicative_> f (x:xs) = x + ???
23:52:17 <kostja> shachaf: I tried (sequence as) >>= (\x->(x:))
23:52:26 <MercurialAlchemi> matthiasgoergens: I see, this is nice
23:52:29 <Watabou> applicative_: so just x + xs
23:52:31 <Watabou> ?
23:52:32 <shachaf> kostja: You keep trying to make things point-free.
23:52:37 <arkeet> Watabou: that's a type error.
23:52:50 <shachaf> kostja: Don't do it. Give everything names.
23:52:54 <arkeet> I don't know what 1 + [2,3,4] is.
23:52:59 <applicative_> Watabou: you forgot the f
23:53:02 <shachaf> And reason about what the type of each thing should be.
23:53:04 <MercurialAlchemi> matthiasgoergens: I can even see where I could use this
23:53:12 <Watabou> x + f(xs)?
23:53:16 <applicative_> Watabou: maybe it would be clearer if we wrote 'sum' instead of 'f'
23:53:24 <applicative_> Watabou: yes!
23:53:31 <Watabou> yeah
23:53:32 <arkeet> except we write that as  x + f xs
23:53:36 <applicative_> look no head or tail
23:53:54 <applicative_> f [] = 0; f (x:xs) = x + f xs
23:54:05 <Watabou> ah ofcourse this would be the sum of the list
23:54:10 <arkeet> sum [] = 0; sum (x:xs) = x + sum xs
23:54:17 <Watabou> this is pretty cool
23:54:30 <applicative_> so why call those nasty partial functions that presage disaster, head and tail, when you can pattern match?
23:54:31 <zRecursive> @src sum
23:54:31 <lambdabot> sum = foldl (+) 0
23:54:41 <arkeet> "the sum of a nonempty list is the head + the sum of the tail"
23:54:50 <arkeet> it's like you're writing an equation.
23:54:53 <arkeet> (you are.)
23:54:54 <watch> Does anyone here have exprience with graph processing in Haskell?
23:55:25 <Watabou> arkeet: yeah that's a good analogy and I'll keep that in mind
23:55:42 <Watabou> applicative_: okay I think I perfectly got the point of pattern matching now
23:55:43 <zRecursive> @src product
23:55:44 <lambdabot> product = foldl (*) 1
23:56:03 <zRecursive> @src foldl
23:56:03 <lambdabot> foldl f z []     = z
23:56:04 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:56:04 <MercurialAlchemi> arkeet: yes, off with their heads
23:56:12 <MercurialAlchemi> arkeet: err, off with 'head'
23:56:25 <arkeet> head and tail are evil.
23:56:59 <silasm> arkeet: at least they're easier to follow than "car" and "cdr".
23:57:13 <applicative_> Watabou: I think this is the sort of case that makes the name 'pattern matching' make sense, though LYAH's examples are pattern matching too. 7 is like []
23:57:24 <arkeet> silasm: but no less evil.
23:57:30 <shachaf> silasm: car and cdr are fst and snd
23:57:34 <shachaf> That's not evil.
23:57:57 <arkeet> ?
23:58:13 <silasm> shachaf: really? Thought they operated on lists (as well?). Been a while since I read up on lisp.
23:58:33 <MercurialAlchemi> arkeet: though there are safe versions of head and tail in 3rd party libs, but why use this when you have pattern matching
23:58:34 <shachaf> Lisp doesn't have lists. Just pairs.
23:58:41 <Watabou> applicative_: hmm okay, so in the real world are pattern matching used?
23:58:44 <applicative_> shachaf: tail is snd if you squint properly
23:58:54 <arkeet> shachaf: what about the empty list?
23:59:03 <zRecursive> no, tail is init
23:59:07 <Watabou> it feels like they are slightly realted to guards and that's the next section in the book
23:59:15 <zRecursive> > init [1,2,3,4,5]
23:59:17 <lambdabot>   [1,2,3,4]
23:59:22 <shachaf> arkeet: OK, that's not a pair. Which is why car and cdr -- pair operators -- don't work on it.
23:59:30 <arkeet> sounds evil.
23:59:43 <zRecursive> > snd [1,2,3,4,5]
23:59:43 <shachaf> On the other hand if x = (cons 1 2) then (car x) = 1 and (cdr x) = 2
23:59:46 <lambdabot>   Couldn't match expected type `(a0, b0)' with actual type `[t0]'
