00:03:15 <SparkyFlary> is it possible to use the logic of haskell and with it something like c# for the gui to make a program?
00:04:07 <shachaf> Surely possible. Possibly not very convenient.
00:04:47 <SparkyFlary> what why not
00:04:53 <shachaf> You'll need to make them communicate somehow.
00:05:22 <shachaf> There's no direct .NET FFI for Haskell, so it would involve some mechanism or another.
00:05:57 <shachaf> E.g. both going via C FFI, or sending data as bytes over a socket
00:07:39 <SparkyFlary> then how does one make a program with gui with haskell?
00:08:15 <johnw> there's Salsa, but I'm not sure how up-to-date it is
00:08:21 <johnw> and also hs-dotnet
00:08:23 <latermuse> theres a lot of GUI libraries
00:14:25 <dottedmag> I wonder is there more idiomatic way to express this: http://hpaste.org/88535
00:14:44 <dottedmag> As pasted, it reminds me of Erlang, not of Haskell :)
00:14:52 <shachaf> @src unless
00:14:53 <lambdabot> unless p s = if p then return () else s
00:14:54 <shachaf> @src when
00:14:55 <lambdabot> when p s = if p then s else return ()
00:15:02 <shachaf> @src forever
00:15:02 <lambdabot> Source not found. Just what do you think you're doing Dave?
00:15:16 <shachaf> forver x = do { x; forever x }
00:15:19 <dibblego> readLn >>= \a -> unless (a == 42) (print a >> main)
00:15:45 <shachaf> Oh, maybe that doesn't quite work.
00:15:54 <dottedmag> Yes, the problem is return ()
00:16:21 <shachaf> Sometimes I would use fix for this sort of thing, though you don't gain anything in this case.
00:20:22 <dottedmag> shachaf: thanks
00:21:11 <shachaf> fix would be useful if this was embedded in some bigger thing.
00:21:25 <shachaf> fix $ \again -> do { ...; when ... again }
00:45:25 <dottedmag> > ceiling $ sqrt $ fromIntegral 5
00:45:26 <lambdabot>   3
00:45:38 <dottedmag> :t ceiling $ sqrt $ fromIntegral
00:45:40 <lambdabot>     No instance for (RealFrac (a0 -> b0))
00:45:40 <lambdabot>       arising from a use of `ceiling'
00:45:40 <lambdabot>     Possible fix: add an instance declaration for (RealFrac (a0 -> b0))
00:46:15 <dottedmag> :t ceiling $ sqrt $ fromIntegral :: Integer -> Integer
00:46:16 <lambdabot>     No instances for (Integral (Integer -> Integer),
00:46:16 <lambdabot>                       RealFrac (a0 -> b0))
00:46:16 <lambdabot>       arising from a use of `ceiling'
00:46:23 <dottedmag> How do I define function like this?
00:46:31 <croikle> :t ceiling . sqrt . fromIntegral
00:46:32 <lambdabot> (Integral a, Integral c) => a -> c
00:46:50 * dottedmag slaps himself 
00:46:52 <dottedmag> croikle: thanks :)
00:47:00 <croikle> np :)
01:16:02 <fruitFly> how to an element in a list a certain index... and I know it's there
01:16:06 <fruitFly> at a*
01:16:15 <johnw> :t (!!)
01:16:17 <lambdabot> [a] -> Int -> a
01:17:19 <fruitFly> johnw: yeah? not working in try haskell.org
01:17:39 <fruitFly> how do i return an element at a certain index in a list?
01:19:01 <johnw> > [1,2,3,4] !! 3
01:19:03 <lambdabot>   4
01:19:32 <supki> > [1,2,3,4] ^? element 3
01:19:34 <lambdabot>   Just 4
01:19:44 <supki> > [1,2,3,4] ^? element 7
01:19:45 <lambdabot>   Nothing
01:20:00 <supki> > [1,2,3,4] !! 7
01:20:01 <lambdabot>   *Exception: Prelude.(!!): index too large
01:29:01 <johnw> fruitFly: typically if you need !!, you're doing something wrong
01:29:22 <Nisstyre> johnw: what about for getting the second element of a list?
01:29:38 <johnw> I prefer to use case in those cases
01:29:40 <sipa> Nisstyre: pattern match
01:29:41 <Nisstyre> (I know you said typically, just curious if you consider that bad)
01:29:51 <johnw> yes, I consider it pretty bad
01:29:55 <johnw> *except* when i'm writing unit tests
01:29:58 <latermuse> > head . tail $ [1..10]
01:29:59 <lambdabot>   2
01:30:00 * latermuse laughs
01:30:02 <johnw> in which case writing partial code is usually just fine
01:30:55 <shachaf> johnw: What if I generated an infinite list, so I know (!!) can't fail?
01:31:11 <johnw> shachaf: if the type indicates that, then it's all good
01:31:24 <shachaf> It doesn't.
01:31:36 <johnw> usually when a statement starts, "I know that... <is an invariant>", that's the sign of bad things to come
01:31:43 <shachaf> I would use an infinite Stream type but it's really awkward because all my functions operate on lists.
01:31:54 <johnw> better to (a) move the invariant into the type, or (b) write total functions
01:32:26 <johnw> shachaf: you yourself convinced me to treat fromJust like the plague!
01:32:43 <shachaf> OK, but I have lots of helper functions on lists. Do I have to rewrite them all for Streams?
01:33:04 <johnw> i'm not saying that you have to
01:33:28 <shachaf> Should I?
01:33:42 <Nisstyre> I think he's just saying that you can either do that or make sure they won't raise exceptions/that you should cover every possibility
01:33:53 <johnw> I guess that depends.  If it's a long-lived library that will have other developers changing it over a rather long period of time, then it's an investment that's worth the time
01:34:07 <johnw> but if it's a quick and dirty script that will rarely ever change, then no, it's not worth it
01:34:13 <shachaf> What about this:
01:34:39 <shachaf> > map (\x -> (length x, head x)) . group $ "hello wworrrrrld!!!!!"
01:34:40 <lambdabot>   [(1,'h'),(1,'e'),(2,'l'),(1,'o'),(1,' '),(2,'w'),(1,'o'),(5,'r'),(1,'l'),(1...
01:34:56 <shachaf> I don't like how I'm using head there. What should I do?
01:35:03 <shachaf> Rewrite group to give nonempty lists?
01:36:06 <shachaf> Maybe I'm just giving you a hard time here. But Haskell is giving me a hard time!
01:36:12 <johnw> no, I see your point
01:36:13 <shachaf> I want the easy thing and the right thing to be the same thing.
01:36:19 <johnw> and sometimes writing total code can be a drag
01:36:40 <johnw> you'd have to introduce Maybe into that code, otherwise it's undefined if x is []
01:36:53 <johnw> shachaf: I hear you!
01:36:57 <shachaf> x is never []
01:37:12 <johnw> oh, you will actually always be using that constant string?
01:37:15 <shachaf> No.
01:37:17 <shachaf> That composed function is completely total.
01:37:30 <johnw> > group []
01:37:32 <lambdabot>   []
01:37:34 <shachaf> (Well, except for infinite lists, I guess, where length might fail.)
01:37:47 <johnw> group [[]]
01:37:50 <johnw> > group [[]]
01:37:51 <lambdabot>   [[[]]]
01:38:04 <johnw> > group [1]
01:38:05 <lambdabot>   [[1]]
01:38:06 <johnw> i see
01:38:09 <johnw> hmm
01:38:13 <shachaf> group gives you a list of nonempty lists.
01:38:14 <johnw> you know, I've run into this before
01:38:33 <johnw> where the parts of the composed functions are partial, but the composition is by definition total
01:38:54 <johnw> the difficulty is: what if another engineer comes along and changes the composition, and it's suddenly not total anymore?
01:38:57 <shachaf> Sure. Anything where you're using a partial function + a boolean.
01:39:12 <shachaf> That's the whole Boolean Blindness issue.
01:39:18 <johnw> yeah
01:39:25 <shachaf> You're keeping a totality proof in your head rather than in the code.
01:39:29 <shachaf> The compiler can't check your head.
01:39:43 <johnw> what do you think the best approach is?
01:39:44 <shachaf> (I'm sort of glad GHC can't type-check my head. Who knows what it would find in there.)
01:39:50 <shachaf> I don't know.
01:41:42 <mgsloan> group :: Eq a => [a] -> [NonEmpty a]
01:41:54 <shachaf> Sure.
01:42:24 <shachaf> But if you do that everywhere you get very awkward code.
01:42:40 <Taneb> That reminds me
01:42:54 <mgsloan> True.  It does seem like the safer things get, the more verbose your code needs to be
01:42:56 <Taneb> I want to learn Agda, anyone suggest any resources to get started?
01:43:05 <shachaf> tutorial.pdf
01:43:07 <johnw> Taneb: youtube and the tutorials
01:43:11 <mgsloan> This is why writing a verified C compiler is 10% code and 90% proof
01:43:22 <hsn> what is agda
01:43:32 <arkeet> google is good at answering questions like that
01:43:38 <shachaf> what is google
01:44:38 <hsn> its student project
01:45:42 <Saizan> mgsloan: that just means we're not good enough at proofs yet!
01:45:55 <mgsloan> Saizan: I could buy that :D
01:46:17 <johnw> hsn: a dependently-typed language that at times resembles Haskell
01:46:44 <mgsloan> Still, there does seem to naturally be an increase in complexity whenever you want to have more static checking
01:46:54 <mgsloan> Normal haskell style seems to strike a pretty reasonable balance
01:47:51 <johnw> I think the question is: how much is work up-front a better use of resources than work down the road
01:47:58 <dalaing1> mgsloan: is that because we're used to it and/or the idioms have stabilized over a long time?
01:48:11 <johnw> the more we realize the value of types, I think the more work we'll be willing to accept during the coding process
01:48:43 <lizzin> hsn: mind if i msg you?
01:48:48 <johnw> if it takes me 5x longer to write code that simply cannot fail, is that better than all the bugs I'd ever have to fix in the code I wrote in 1/5th the time, but spent more than 5x as much time debugging in production?
01:49:44 <dalaing1> it also might mean you spend less time on "defensive" coding practices across module boundaries
01:51:37 <johnw> i think what I've come to realize is that you always have to pay.  there is no silver bullet.  It's just about when you have to pay.  Personally, bugs that only I will ever see (because my code won't compile) are far better than bugs that everyone will see.  So I'm in favor of more work in exchange for more provably correct code.  At least, I'm getting there as the days go by
01:52:29 <johnw> other days, it's very motivating to see your code actually doing something real for you in the first few minutes of coding.  I see the attraction of so-called dynamic languages
01:52:51 <shachaf> It's not really a zero-sum game.
01:52:54 <mgsloan> dalaing1: Maybe so!  The issue is the granularity at which you can specify types.  For example, "NonEmpty a" is the same as "[a]", but with one less value.  There are plenty of times when there's a judgment call as to whether to introduce a new datatype or not.  For example, if you're working on a compiler where the AST representation in between some later stages is guaranteed to not have certain constructors.  It can be a tricky decis
01:53:14 <shachaf> I can make a language strictly worse than Haskell. You pay more and gain nothing for it.
01:53:33 <shachaf> So surely there's also one strictly better than Haskell.
01:53:34 <johnw> shachaf: ah, you mean that paying through the teeth is not in itself a sign of betterness
01:53:57 <johnw> I'm not sure if the dependently-typed languages are indeed the best way to achieve what they seek
01:54:33 <Taneb> What's the serious bug in mtl-2.1 that breaks the Agda program?
01:58:32 <Brongue> Any SDL experts online?
02:11:17 <Okasu> johnw: Well, code cannot fail but you pretty much can, wrong reasoning, broken logic and stuff like that. Nobody in the world will save you from that. Rockets still falling as proff of what i'm saying. :)
02:12:01 * hackagebot carettah 0.2.0 - A presentation tool written with Haskell.  http://hackage.haskell.org/package/carettah-0.2.0 (KiwamuOkabe)
02:13:42 <Okasu> You even can write a proof you your wrong reasoning it terms of your broken logic, coq/agda should be powerfull enough to support that feature. :D
02:13:50 <Okasu> Sorry, just joking.
02:14:18 * Okasu wrote a bit of coq back then.
02:19:22 <hsn> @faq
02:19:22 <lambdabot> The answer is: Yes! Haskell can do that.
02:19:38 <fosskers> Haha haskell can do eeeeverything.
02:22:09 <no-n> replicate 10000000 dollars
02:23:07 <hsn> in our monetary system money are just something typed into computer if you have bank license
02:27:06 <fosskers> replicate 100000000 no-n
02:27:18 <no-n> no don't
02:27:29 <no-n> that's gonna get me g-lined :(
02:27:35 <fosskers> better idea!
02:27:37 <fosskers> repeat no-n
02:27:59 <no-n> lol
02:28:46 <aristid> > intercalate " " $ repeat "no-n"
02:28:48 <lambdabot>   "no-n no-n no-n no-n no-n no-n no-n no-n no-n no-n no-n no-n no-n no-n no-n...
02:29:03 <no-n> :>
02:29:16 <aristid> see, no need to worry about g-lining ;)
02:33:53 <fosskers> i guess lambdabot is smart about printing infinite lists
02:34:23 <Taneb> > fix show
02:34:25 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
02:34:38 <osfameron> if lambdabot wasn't, it would get /kick'd pretty sharpish I imagine
02:34:45 <arkeet> > text $ fix show
02:34:53 <lambdabot>  Terminated
02:34:59 <arkeet> > text . take 100 $ fix show
02:35:01 <osfameron> > ones = 1 : ones
02:35:13 <arkeet> oh dear
02:35:14 <lambdabot>   thread killed
02:35:16 <lambdabot>   <hint>:1:6: parse error on input `='
02:35:17 <arkeet> > text . take 100 $ fix show
02:35:19 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
02:35:28 <osfameron> > let ones = 1 : ones in ones
02:35:31 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:35:47 <shachaf> > preview (base 8) "12"
02:35:55 <lambdabot>   Just 10
02:36:13 <shachaf> > preview (base 8) "12" <&> subtract 3
02:36:15 <lambdabot>   Just 7
02:36:28 <Taneb> > preview (base 8) "25"
02:36:29 <lambdabot>   Just 21
02:36:43 <Taneb> > view (base 8) 25
02:36:44 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
02:36:44 <lambdabot>    arising from the literal ...
02:36:58 <Taneb> > view (re$ base 8) 25
02:37:00 <lambdabot>   "31"
02:37:28 <fosskers> what wizardry is <&>?
02:37:34 <fosskers> :t <&>
02:37:39 <lambdabot> parse error on input `<&>'
02:37:48 <fosskers> :t (<&>)
02:37:49 <lambdabot> Functor f => f a -> (a -> b) -> f b
02:37:54 <arkeet> it's a flipped fmap
02:37:59 <osfameron> why do you pass in a string "12"?
02:38:02 <fosskers> neat
02:38:08 <arkeet> why not?
02:38:30 <osfameron> isn't that number an actual decimal Int?
02:38:48 <shachaf> The string "12" is a String.
02:38:52 <arkeet> > preview (base 16) "beef"
02:38:54 <osfameron> it's the output which is in base 8, and so might make sense as a string
02:38:54 <lambdabot>   Just 48879
02:39:06 <typoclass> > preview (base 8) 123 -- no worky
02:39:08 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
02:39:08 <lambdabot>    arising from the literal ...
02:39:30 * osfameron gets more coffee
02:39:31 <shachaf> So you're saying 12 is 10 in base 8?
02:39:44 <Taneb> The "error" function annoys me but it's too damn useful
02:40:03 <shachaf> Taneb: What, https://en.wikipedia.org/wiki/Error_function ?
02:40:14 <Taneb> shachaf, that oo
02:40:16 <Taneb> *too
02:40:20 <Taneb> :t error
02:40:21 <lambdabot> [Char] -> a
02:40:30 <Taneb> But that was the error function I referred to
02:41:21 <osfameron> shachaf: good point.  coffee...
02:41:41 <shachaf> > review (base 8) 123
02:41:43 <lambdabot>   "173"
02:42:15 <fosskers> You can factor out `error` with MaybeT or ErrorT
02:43:53 <arkeet> haskell cookies http://twitpic.com/ct0dj2
03:03:57 <FreeFull> > base 8
03:03:59 <lambdabot>   Ambiguous type variable `p0' in the constraint:
03:03:59 <lambdabot>    (Data.Profunctor.Choice ...
03:05:02 <Taneb> :t base 8
03:05:03 <lambdabot> (Integral a, Applicative f, Choice p) => p a (f a) -> p String (f String)
03:05:41 <Taneb> :t base 8 :: APrism' String Integer
03:05:43 <lambdabot> APrism' String Integer
03:06:34 <Taneb> :t base 8 :: Prism' String Integer
03:06:35 <lambdabot> (Applicative f, Choice p) => p Integer (f Integer) -> p String (f String)
03:06:42 <magneticduck> I just found the most inexplicable bug ever
03:06:50 <magneticduck> I think I need some haskell ninja help
03:06:54 <magneticduck> hpasting it now
03:06:57 <arkeet> > let f [] = [[]]; f (x:xs) = [] : tail (f xs >>= \a -> [a,x:a]) in f [1..]
03:06:58 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
03:07:07 <johnw> magneticduck: haskell ninjas are very quiet
03:07:12 <arkeet> > let f [] = [[]]; f (x:xs) = [] : tail (f xs >>= \a -> [a,x:a]) in map length $ f [1..]
03:07:13 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
03:07:25 <johnw> their shuriken are pointless
03:07:30 <arkeet> haha
03:07:30 <magneticduck> johnw: hopefully they can still help me out somehow
03:08:06 <johnw> you'll have to manually paste in the hpaste link
03:08:11 <johnw> hpaste auto-announcements are disabled
03:08:17 <magneticduck> I noticed that yesterday
03:08:58 <Entroacceptor> s
03:10:13 <magneticduck> http://hpaste.org/
03:10:18 <magneticduck> I'm sorry it's a mouthfull
03:10:21 <magneticduck> its*
03:10:31 <magneticduck> but the code that makes it stall
03:10:37 <fosskers> it's is correct there
03:10:41 <Taneb> http://hpaste.org/88536
03:10:41 <magneticduck> is starting at 75
03:10:54 <magneticduck> really?
03:10:57 <magneticduck> MY LIFE IS A LIE
03:11:04 <magneticduck> moving on though
03:11:17 <magneticduck> lol ty Taneb
03:11:53 <magneticduck> I've checked all the geometry routines pretty well
03:12:00 <magneticduck> and I can't recreate the problem from GHCi
03:12:07 <magneticduck> maybe it's gloss's fault?
03:12:20 <magneticduck> (that's what I'd like to believe)
03:12:37 <typoclass> magneticduck: "you can't recreate" in the sense of, you call it in ghci and it works as expected?
03:12:42 <magneticduck> yeah
03:12:44 <supki> do you compile with -threaded?
03:12:44 <magneticduck> and no stalling
03:12:49 <magneticduck> no, actually
03:12:58 <magneticduck> I was just using runhaskell for the time being
03:13:05 <magneticduck> I'll try compiling it with ghc -threaded
03:13:06 <supki> try with -threaded
03:13:15 <typoclass> magneticduck: i bet it'll have to do with compiler switches
03:13:53 <magneticduck> another thing that you might find usefull
03:13:57 <magneticduck> to kill the program from htop
03:14:03 <magneticduck> I have to use sigkill
03:14:07 <magneticduck> sigterm doesn't have effect
03:14:23 <magneticduck> yeah, I compiled it with -threaded
03:14:28 <magneticduck> no warnings, same problem
03:16:14 <magneticduck> also, replacing (EU.vectorToAngle (vec - p2)) works fine
03:17:40 <magneticduck> sorry
03:17:48 <magneticduck> replacing that expression with a constant works fine
03:17:58 <magneticduck> and I found no problems with EU.vectorToAngle..?
03:18:04 <magneticduck> it just uses atan and multiplication
03:18:08 <magneticduck> atan2*
03:20:07 <typoclass> magneticduck: hm. have you checked all the inputs? as a random example, suppose vectorToAngle had a bug where it goes in an infinite loop when given the vector 0,0,0
03:20:21 <magneticduck> nope
03:20:27 <magneticduck> I tested vectorToAngle pretty well
03:20:35 <magneticduck> including with nullVector
03:20:43 <magneticduck> (it just gives degreeToAngle 0)
03:21:21 <magneticduck> typoclass: also, I never put any compiler switches on in any of the code
03:21:25 <magneticduck> it's just the default
03:21:32 <magneticduck> and I use runhaskell to test it
03:22:02 <Licenser> magneticduck did you ever had problems with people tossing money in the pond?
03:22:18 <magneticduck> huh?
03:23:19 <typoclass> magneticduck: er, vectorToAngle 0,0,0 was just an example. it could be another function, and it could be another input value. i just meant this could explain why it works with ghci when run as "foo 123", but doesn't work in the actual program when applied to a value that isn't 123
03:23:47 <magneticduck> I did Gloss based tests in the path on vectorToAngle
03:23:50 <magneticduck> just moved my mouse around
03:23:50 <Licenser> sorry it just is a question that really came to mind when reading the backlog, propably a bit off topic so
03:23:58 <magneticduck> always got a result that made sense
03:25:14 <magneticduck> github page for the code is at https://github.com/MagneticDuck/EuclieanThings/blob/master/src/EuclideanThings/Primitives/LineAndCircle.hs in case you ddin't get it
03:25:30 <magneticduck> other stuff is in the Primitives folder too
03:25:38 <magneticduck> Angle and Vector definitions namely
03:25:58 <magneticduck> thanks guys
03:26:20 <arkeet> magneticduck: you should probably put *.swp in .gitignore :p
03:27:06 <magneticduck> hehe
03:27:17 <magneticduck> yueah
03:27:36 <magneticduck> aw darn
03:27:38 <magneticduck> I have to go
03:27:42 <magneticduck> I'll be back in a hour or so
03:27:47 <arkeet> me too, it's 03:30
03:27:48 <arkeet> almost
03:27:48 <magneticduck> sorry and thanks for your help
03:27:55 <magneticduck> I'll just be away on ircd
03:28:03 <magneticduck> if you have any ideas PM me please
03:28:26 <magneticduck> would be awesome
03:53:49 <danbru> is there a name for 'data T f a = Return a | T f (f a)'  ?
03:54:56 <acube> That'd be a free monad ?
03:55:25 <arkeet> that would be a kind error.
03:55:29 <danbru> nope, Free is 'data Free f a = Pure a | Free (f (Free f a))
03:56:04 <arkeet> fix your kind error first
03:56:51 <arkeet> if you meant Return a | T (f (f a)), then it's not really anything.
03:57:30 <danbru> ah..'data T f a = Return a | T (T f (f a))
03:57:33 <arkeet> wait.
03:57:34 <arkeet> I'm dumb.
03:57:38 <danbru> i meant
03:57:43 <typoclass> danbru: did you mean ... ah, yes :-)
03:57:44 <arkeet> no wait I'm not.
03:58:02 <shachaf> Whew!
04:00:30 <arkeet> = a + f a + f (f a) + f (f (f a)) + ...
04:01:05 <shachaf> I don't think you can really distribute the + like that.
04:01:26 <arkeet> no, the free monad is a + f (a + f (a + ...))
04:01:31 <arkeet> his thing is not that
04:01:36 <shachaf> Oh, you're talking about something else.
04:01:47 <danbru> yup so for 'type Pair a = (a,a)' 'T Pair a' would make a balanced binary tree of 'a's
04:02:26 <acube> T Pair a would be an error if Pair is only a type synonym :p
04:02:37 <arkeet> we can pretend.
04:03:17 <arkeet> anyway, it
04:03:19 <arkeet> 's not a monad. :p
04:04:07 <arkeet> I don't know of a name for it.
04:05:57 <danbru> oh.. it seems it doesnt work :o
04:09:06 <danbru> so.. is there a type T where  'T Pair a' would mean 'a | Pair a | Pair (Pair a)'
04:09:21 <quchen> Is there a way of deprecating single class methods, or can I just deprecate the entire class?
04:09:41 <typoclass> danbru: just those three, or does it go on recursively?
04:09:58 <danbru> typoclass: recurseive
04:10:38 <acube> danbru: Doesn't your type T do that?
04:11:15 <danbru> acube: i belived it first, but is haveing trouble with the typechecker now :(
04:12:28 <acube> T f a = Zero a | Succ (f (T f a)) ?
04:14:05 <danbru> acube: that 'T Pair' type can represent unbalanced trees :/
04:16:41 <acube> danbru: But It can represent Zero a | Succ (Pair (Zero a)) | Succ (Pair (Succ (Pair (Zero a)))) | ... which gives a | Pair a | Pair (Pair a) | ... removing the constructor noise
04:19:20 <acube> Ah ok, I see the problem now. You can have two different levels of Succ's between the Pair's branches
04:20:51 <danbru> it works now.. turns out using 'data T f a = Return a | T (T f (f a))' and the declare Pair using 'data' rather then 'type' works
04:21:19 <shachaf> If it's data you might as well get rid of the tuple.
04:21:49 <acube> Hmm, you could just use T (,) a
04:22:38 <danbru> 'a = T . T . Return $ Pair (Pair 1 2) (Pair 3 4))' compiles now :D
04:23:09 <danbru> why doesnt 'type Pair a = (a,a)' work ?
04:23:32 <shachaf> acube: No.
04:23:32 <byorgey> because type sysnonyms must be fully applied
04:23:59 <acube> shachaf: Why not?
04:24:11 <danbru> byorgey: ok, thanks :)
04:24:46 <acube> ah right, you need only 1 type argument
04:26:02 <beaky> hello
04:26:13 <weebl> hi
04:26:22 <beaky> anyone had any luck writing haskell for the arduino? wouldn't it be great to write ISRs and state machines in haskell? :D
04:27:33 <quchen> It works on Raspi.
04:27:36 <beaky> wow
04:47:29 <kartlos> I've started working on my first small project other than the 99 haskell problems, I'm trying to implement a simple random game of life, I think I've got the main mechanisms working but for some reasons after a few generations the cells simply seem to mirror on the diagonal axis, this has puzzled me for the last three hours, here's my code: http://hpaste.org/88538
04:47:43 <kartlos> any other comments on the code are also greatly appreciated
04:49:47 <horlicks> what's the simplest way of generating a list like [1,6,2,7,3,8]? I was thinking of zipping [1..3] and [6..8] but then I get a list of tuples
04:50:17 <shachaf> concat $ zipWith (\x y -> [x,y]) [1,2,3] [6,7,8]
04:50:19 <typoclass> horlicks: have you had a look at the function zipWith?
04:51:07 <horlicks> perfect, thanks shachaf
04:51:22 <horlicks> I looked at zipWith, but I couldn't work out how to do the concatenation
04:56:03 <Taneb> Overkill solution: toListOf (folded.both) $ zip [1..3] [6..8]
04:59:35 <byorgey> horlicks: concat . transpose $ [[1..3],[6..8]]   is another way
05:00:10 <magneticduck> heey everyone, anybody remember me? I'm back and I still have that super weird bug
05:00:12 <magneticduck> http://hpaste.org/88539
05:00:22 <magneticduck> program stalls when I add that code
05:00:29 <magneticduck> (comments explain)
05:00:56 <magneticduck> however, when I substitute the expresion (p1 - nullVector) for ANYTHING that doesn't have p1 or p2, the program works fine
05:01:00 <magneticduck> double u tee eff?
05:01:08 <shachaf> byorgey++ # more sensible
05:03:46 <magneticduck> the geometry routines are tried and tested pretty well
05:03:53 <magneticduck> no weird recursion cycles possible there
05:04:22 <magneticduck> again, the program stalls; the window doesn't even get rendered and the only way to exit out is to send it a sigkill
05:05:17 <magneticduck> also, the picture rendered given anglep1 isn't the problem
05:05:26 <magneticduck> anything else that uses anglep1 stalls too
05:05:50 <magneticduck> (the intersections created work fine, it's just the evaluation of the angle that makes the program stall)
05:05:59 <magneticduck> can anybody help?
05:06:03 <magneticduck> would be awesome
05:07:13 <magneticduck> but here's the weird part.. I can't recreate the problem in ghci
05:07:33 <magneticduck> (vectorToAngle and nullVector have no problem)
05:07:45 <magneticduck> I'm going to see if I can recreate the problem in a context free example
05:08:30 <magneticduck> uhh, is anybody here?
05:08:32 <magneticduck> :<
05:08:59 <mekeor> yes
05:09:23 <magneticduck> awesome
05:09:27 <mekeor> no, xmonad
05:09:35 <magneticduck> what?
05:09:56 <mekeor> (awesome is another tiling wm but xmonad is more awesome than awesome ;])
05:10:05 <magneticduck> ik
05:10:06 <magneticduck> I use xmonad
05:10:09 <magneticduck> xmonad ftw
05:10:12 <mekeor> !
05:10:16 <typoclass> magneticduck: yes there are people here, but they don't have any ideas about your problem. (at least i don't, sorry.) if there's no answers even after some waiting, try re-asking your question on haskell-cafe or possibly stack overflow
05:10:26 <magneticduck> darn
05:10:33 <mekeor> same here :/
05:10:36 <magneticduck> well I'll just try and recreate my problem context-free
05:10:40 <magneticduck> maybe that will help
05:10:44 <mekeor> exactly
05:10:53 <magneticduck> and if nobody has any answers I'll name it "the unsolved bug"
05:11:08 <magneticduck> and feel really smug about how I found a bug
05:11:35 <mekeor> magneticduck: so, if the discussion of you issue is canceled, may i ask my question? :)
05:11:39 <magneticduck> yeah
05:11:45 <magneticduck> you may proceed
05:11:49 <mekeor> here it is: why does this not work?:
05:12:05 <mekeor> http://hpaste.org/88540
05:13:06 <mekeor> so, is really not allowed to document the type-class in a type-signature of a function using haddock or is it just me doing it wrong?
05:13:10 <magneticduck> that would appear because you cannot use the standard --^ for documentation of required typeclasses
05:13:30 <mekeor> magneticduck: hm okay. but why not? :( that's a bummer.
05:13:45 <magneticduck> ima researching it
05:13:47 <magneticduck> google ftw
05:14:23 <magneticduck> aaand I got nothin
05:14:30 <mekeor> :D
05:14:42 <magneticduck> back to making my bug context-free
05:14:45 * mekeor accidentally removed the code from hpaste... anyway.
05:14:54 <mekeor> magneticduck: :)
05:15:32 <byorgey> mekeor: I would probably be able to answer your question if you hadn't deleted the code...
05:15:40 <mekeor> uh
05:15:44 <mekeor> wait a sec :)
05:16:52 <mekeor> byorgey: http://hpaste.org/88540 :)
05:17:14 <typoclass> magneticduck: cutting down the context of a hard bug will help. it will help you look for a solution, and also help others if you send it to a mailing list
05:17:26 <magneticduck> I'm making a little program
05:17:30 <magneticduck> will be done in a minute
05:17:38 <mekeor> byorgey: so, i can't document the class. uhm, am i doing it wrong or is this really not possible/allowed in haddock?
05:17:46 <byorgey> mekeor: yeah, I think you simply can't document constraints
05:18:00 <byorgey> mekeor: though I agree it would be nice if you could
05:18:17 <mekeor> i see. thanks :)
05:21:52 <kartlos> I've noticed that hpaste gives some usefell comments/suggestions about the code, is there a program does that locally?
05:22:01 <mekeor> kartlos: hlint :)
05:22:03 <johnw> hlint
05:22:04 <mekeor> @where hlint
05:22:04 <lambdabot> http://community.haskell.org/~ndm/hlint/
05:22:14 <johnw> hlint is pretty awesome
05:22:14 <kartlos> thanks! :)
05:22:20 <johnw> i've learned some functions from it :)
05:22:51 <typoclass> johnw: well some of its messages could be clearer :-)
05:23:25 <mekeor> there's also a nice tool from jaspervdj... uhm, how was it called? it arranges imports etc, i think. ah: https://github.com/jaspervdj/stylish-haskell
05:23:35 <typoclass> "eta reduce" <- two-word message, one of it a random greek letter :-)
05:23:57 <johnw> typoclass: yeah, that's very true
05:24:37 <typoclass> johnw: iota revocation
05:24:52 <typoclass> sorry, "iota revoke"
05:25:09 <johnw> at least it's using the latin alphabet
05:25:12 <johnw> that's one concession
05:26:02 <acube> Does the version of template-haskell depend on the GHC version?
05:26:09 <typoclass> johnw: omicron resolve
05:28:13 <typoclass> johnw: ah, i've figured out what it sounds like. the "operation" names of a parallel-universe pentagon. "airborne forces are now deploying to the elbonian capital for operation eta reduce"
05:28:20 <mekeor> acube: well, it depends on certain versions of the base-package which is shipped together with ghc, afaik. :)
05:28:34 <magneticduck> well that sucks; my context-free example doesn't fail
05:28:50 <mekeor> acube: e.g. template-haskell-2.7.0.0 depends on base >=4.2 && <5
05:28:58 <mekeor> magneticduck: hah :D :P
05:29:07 <magneticduck> shitshitshitshitshit
05:29:08 <acube> But I can use e.g. emplate-haskell-2.8.0.0 with GHC 7.4?
05:29:21 <mekeor> idk :)
05:29:30 <typoclass> magneticduck: i think it doesn't really suck, i think you're homing in on the problem. the context that you cut away must contain the cause or a cause
05:29:41 <mekeor> oh wait. uhm, i was refering to template-haskell-2.7.0.0, btw, sorry.
05:29:43 <acube> cabal install template-haskell-2.8.0.0 doesn't fail, I just want to know if this might cause some issues?
05:29:51 <mekeor> acube: no
05:30:01 <mekeor> acube: :)
05:30:11 <mekeor> acube: it's a good sign! ;)
05:30:18 <mekeor> (afaik :D)
05:31:30 <mekeor> uhm, is there a lib for prompts? so, when i just do “putStr "Input: " >> hFlush stdout >> getLine”, i can't use the arrow keys etc.. what could i use instead? ncurses? O.o
05:31:30 <supki> acube: yes
05:31:35 <supki> acube: https://github.com/ekmett/lens/issues/276
05:31:40 <supki> (for example)
05:31:49 <acube> supki: That was the issue I was seeing I think :P
05:31:50 <mekeor> supki: O.o
05:31:53 <magneticduck> this bug is killing me
05:31:55 <magneticduck> :<
05:32:04 <mekeor> wth
05:32:08 <acube> magneticduck: What bug? :P
05:32:12 <typoclass> mekeor: haskeline is a readline-ish thing written in haskell
05:32:34 <magneticduck> acube: this really werid bug; I posted code and stuff a while ago, and nobody has figured it out yet
05:32:40 <typoclass> acube: see log (ircbrowse.net), it was described in detail about 25 min ago
05:32:55 <mekeor> typoclass: pefect!! thanks :)
05:33:00 <magneticduck> when I tried to cut away what I thought was arbitrary context (things I KNOW FOR A FACT WORK WELL)
05:33:03 <magneticduck> the bug went away
05:33:12 <acube> supki: Thanks, was exactly that bug
05:33:14 <magneticduck> I think some sort of ghost is toying with me
05:34:44 <Taneb> Any recommendations for a CSV library?
05:35:10 <magneticduck> if you can figure out what's going on, acube, I'll give you 20 dollars and a blessing
05:35:52 <typoclass> Taneb: there's the "casanova" thing now, but i haven't tried it yet
05:35:59 <typoclass> @hackage cassava
05:35:59 <lambdabot> http://hackage.haskell.org/package/cassava
05:36:10 <magneticduck> Taneb: CSV, as in comma seperated value file?
05:36:15 <magneticduck> use parsecs for parsing
05:36:18 <Taneb> magneticduck, yeah
05:36:22 <magneticduck> parsecs ftw
05:36:24 <Taneb> typoclass, I'll give it a look!
05:36:32 <typoclass> casanova, cassava, close nuff *shrug*
05:36:36 <typoclass> =)
05:36:47 <magneticduck> oh cool
05:36:52 <magneticduck> didn't know it existed
05:36:56 <Taneb> magneticduck, this is the kind of thing I'd prefer attoparsec for, but that's just my personal opinion
05:37:15 <magneticduck> I use a funky home-grown intendation format for my readable data storage
05:37:23 <magneticduck> but I'm a funky home-grown duck
05:38:33 <magneticduck> I wrote https://github.com/MagneticDuck/IndentParse/blob/master/src/IndentParse.hs a long time ago and I use it for all kinds of stuff
05:38:48 <magneticduck> it's really useful for encoding haskell datatypes
05:39:18 <magneticduck> but it probably sucks
05:42:02 <magneticduck> does anybody else like using that kind of indentation style?
05:42:18 <magneticduck> that is, for storing data?
05:44:08 <mekeor> typoclass: wow. haskeline is quite powerful O.o
05:44:57 <magneticduck> pretty cool
05:45:27 * magneticduck is starting to suspect a prank is being played on him by a restless haskell ghost
05:45:49 <magneticduck> anybody here know how to exorcise a directory?
05:45:57 <malc__> rm -fr /
05:46:00 <magneticduck> mm
05:46:47 <acube> shred -f $(find /)
05:46:52 <mekeor> sudo dd if=/dev/zero of=/dev/sdba
05:47:00 <magneticduck> xD
05:47:04 <mekeor> *sda
05:47:19 <magneticduck> I believe you need to add --force-demons
05:48:27 <magneticduck> error: /tmp/dark-cave-58910irios has called forth the forces of the Darkness
05:48:36 <acube> Why did they rename StarK to StarT in template-haskell-2.8.0.0 ?!
05:48:51 <magneticduck> so it rhymes?
05:48:55 <magneticduck> with dark
05:49:01 <magneticduck> and hark
05:49:07 <magneticduck> no
05:49:16 <magneticduck> so it DOESN'T rhyme with dark and hark
05:49:29 <mekeor> magneticduck -> #haskell-blah :)
05:49:34 <acube> Hmm, but now I have to write #ifdef's :(
05:52:01 <acube> Is there a macro that allows to switch on a specific version of a dependency package?
05:52:15 <acube> (using cabal?)
05:53:34 <gienah> acube: cabal configure --constraint==CONSTRAINT # see cabal configure --help
05:54:51 <acube> gienah: That's not quite what I want ... I wanted to have a macro that I can use with #ifdef ... #endif to be defined when the version of a package is lower than a given bound, otherwise I don't want it to be defined
05:55:23 <mekeor> typoclass: it works like a charm! i love haskeline :)
05:55:37 <typoclass> mekeor: you're welcome :)
05:56:37 <gienah> acube: something like: #if MIN_VERSION_QuickCheck(2,5,0)
05:57:05 <acube> gienah: That's possible?
05:57:12 <gienah> acube: yes :)
05:57:30 <gienah> acube: just replace QuickCheck with whatever the pkg is called
05:57:46 <acube> gienah: thanks, I will try it :)
05:58:03 <mikeplus64> edwardk: small feature request for linear: Data.Vector.Unboxed.Unbox instances for V0,V2,V3,V4
05:58:16 <mikeplus64> seeing as it depends on vector already
05:59:02 <acube> gienah: for the template-haskell package, what would the macro be?
05:59:12 <acube> MIN_VERSION_template_haskell?
06:00:07 <gienah> acube: yes I think so (replacing - with _ )
06:02:18 <gienah> acube: I'm not sure it will work with template-haskell though, since template-haskell is interpreted (not sure it will run the cpp pre-processor when its interpreted)
06:04:08 <gienah> acube: I don't know, I guess you would have to try it
06:07:27 <magneticduck> what's the function that transforms Float -> Double; Double -> Float?
06:07:38 <magneticduck> (Fractional a, Real b) => a -> b or something
06:07:43 <magneticduck> hoogle doesn't give me any hints
06:08:36 <Taneb> :t realToFrac
06:08:37 <lambdabot> (Fractional b, Real a) => a -> b
06:08:54 <Taneb> > realToFrac (17.8 :: Float) :: Double
06:08:55 <lambdabot>   17.799999237060547
06:09:18 <magneticduck> ty
06:09:38 <Taneb> > 17.8 :: Float
06:09:39 <lambdabot>   17.8
06:09:47 <Taneb> > 17.8 :: Double
06:09:48 <lambdabot>   17.8
06:09:54 <mauke> > 17.8 :: Rational
06:09:55 <lambdabot>   89 % 5
06:10:00 <Taneb> > let x = 17.8; x :: Float in x
06:10:02 <lambdabot>   17.8
06:10:09 <kartlos> > round 2.5
06:10:11 <lambdabot>   2
06:10:17 <kartlos> ?? why 2 ??
06:10:17 <lambdabot>  why 2
06:10:29 <acube> > round ()
06:10:31 <lambdabot>   No instance for (GHC.Real.RealFrac ())
06:10:31 <lambdabot>    arising from a use of `GHC.Real.r...
06:10:39 <acube> > round (2.5 :: Float)
06:10:41 <lambdabot>   2
06:10:59 <fosskers> > round (2.50000000000000000001 :: Double)
06:11:00 <lambdabot>   can't find file: L.hs
06:11:14 <fosskers> > round (2.50000000000001 :: Double)
06:11:15 <lambdabot>   3
06:11:22 <ChongLi> I think it's funny how they had the gumption to call them "real numbers"
06:11:23 <fosskers> > round (2.50000000000000 :: Double)
06:11:24 <lambdabot>   2
06:11:41 <Taneb> ChongLi, they are all subsets of Real numbers
06:11:43 <acube> > round (2.5 :: Rational)
06:11:44 <lambdabot>   2
06:11:47 <acube> Wow
06:11:50 <Taneb> > realToFrac (7 :: Int) :: Rational
06:11:52 <lambdabot>   7 % 1
06:11:59 <acube> > round (5 % 2)
06:12:00 <lambdabot>   Not in scope: `%'
06:12:00 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
06:12:04 <acube> > round (5 R.% 2)
06:12:06 <lambdabot>   2
06:12:07 <Taneb> Can't do that with, eg, Complex
06:12:12 <ChongLi> Taneb: sure, but the implication is that you could have any real number
06:12:15 <acube> I think it use bankers rounding method, or something
06:12:29 <mauke> > map round [0.5, 1.5 ..]
06:12:29 <Taneb> ChongLi, I think that the implication is that any number you have is real
06:12:29 <ChongLi> but you cannot, since computers cannot represent any real number
06:12:30 <fosskers> ceiling 2.5
06:12:31 <lambdabot>   [0,2,2,4,4,6,6,8,8,10,10,12,12,14,14,16,16,18,18,20,20,22,22,24,24,26,26,28...
06:12:35 <fosskers> > ceiling 2.5
06:12:36 <lambdabot>   3
06:12:55 <Taneb> You wouldn't expect an instance of Integral to allow 7.43 as a value
06:13:11 <ChongLi> right
06:13:17 <kartlos> so is there any specific reason as to why 2.5 rounds down to 2?
06:13:26 <mauke> kartlos: equality and justice
06:13:32 <Aetherspawn> @pl (\s -> s $$ chanSink c writeTMChan closeTMChan)
06:13:32 <lambdabot> ($$ chanSink c writeTMChan closeTMChan)
06:13:33 <ChongLi> I suppose I couldn't just represent any old integer either
06:13:47 <kartlos> mauke: brotherhood? :-)
06:13:51 <ChongLi> since most of them exceed all memory that might possibly exist in the universe
06:14:19 <geekosaur> actually Haskell's Real has nothing to do with mathematical reals
06:14:59 <fosskers> geekosaur: that warrents an explanation
06:15:28 <geekosaur> there used to be one but I pulled up the current Prelude and the bit about it meaning numbers that can be represented in hardware is apparently gone
06:16:18 <geekosaur> (this implies that Real includes Int... which it does; Real is a prerequisite for Integral)
06:16:55 <ChongLi> I suppose you could just represent irrationals as functions!
06:17:06 <mgsloan> Maybe it should have been "Rationalizable" ;)
06:17:12 <geekosaur> (thing is, as far as I can tell it is correctly gone. it was a lie anyway, Integer is not represented in hardware...)
06:17:44 <geekosaur> this is one of those things that sets off the folks who want to redo the whole numeric hierarchy in Haskell
06:17:59 <ChongLi> yeah, and the prelude too
06:18:01 <geekosaur> the existing one has not a whole lot of rhyme or reason
06:18:06 <mauke> haskell Real is for numbers that aren't complex
06:18:09 <ChongLi> classy prelude etc.
06:18:09 <magneticduck> lol, the numeric hierarchy in haskell is almost the opposite that it is in conventional math
06:18:17 <magneticduck> at least that's how it looked to me
06:18:21 <magneticduck> it's all turned around
06:18:22 <mgsloan> > showCReal 100 $ pi ** pi
06:18:23 <lambdabot>   "36.46215960720791177099082602269212366636550840222881873870933592293407436...
06:18:38 <Aetherspawn> is it better to manually chain things together using where
06:18:39 <Aetherspawn> and >>=
06:18:43 <Aetherspawn> or to just use do?
06:18:46 <Aetherspawn> (in terms of performance)
06:18:52 <magneticduck> that is, instead of starting with natural numbers and building up, you specify the largest sets and then carve down
06:18:59 <ChongLi> do is syntactic sugar
06:19:04 <ChongLi> it goes away
06:19:05 <mauke> Aetherspawn: what
06:19:13 <geekosaur> Aetherspawn, do notation is rewritten into >>=
06:19:39 <ChongLi> this is one of the beautiful things you'll come to realize about Haskell
06:19:43 <Aetherspawn> does it only affect the monad it's working with
06:19:51 <ChongLi> most of it is just syntactic sugar for a much smaller language
06:19:51 <geekosaur> you might gain a tiny (microseconds) improvement in compile time, maybe
06:19:52 <Aetherspawn> or does it execute a little bit of code at each level?
06:19:52 <magneticduck> Aetherspawn: the biggest performance gain you're getting per use of non-sugared-syntax is constant
06:19:55 <magneticduck> and very small
06:20:36 <Aetherspawn> mhm, I don't like the look of do at all
06:20:41 <magneticduck> and after it's compiled it goes away
06:20:56 <Aetherspawn> thansk
06:20:58 <Aetherspawn> *thanks
06:21:04 <mauke> magneticduck: what performance gain?
06:21:09 <ChongLi> what don't you like about it?
06:21:37 <quchen> Aetherspawn: do { e } == e. do { something; more } == something >> do more. do { p <- something; more } == something >>= \p -> do more.
06:25:31 <Aetherspawn> is there something which lets me pass the argument through to the next statement and not the value produced by the thing
06:25:52 <Aetherspawn> let's say f >>= a (something) b equivalent to
06:26:00 <Aetherspawn> f <- whatever; a f; b f;
06:26:21 <ChongLi> whatever >>= \f -> a f >> b f
06:26:22 <quchen> whatever >>= \f -> a f >> b f
06:26:27 <quchen> Grr :-)
06:26:30 <ChongLi> :)
06:26:39 <Aetherspawn> Oh, I see
06:26:40 <Aetherspawn> thanks.
06:27:00 <ChongLi> oh and you can keep nesting lambdas
06:27:10 <ChongLi> and thanks to lexical scoping
06:27:24 <ChongLi> you can excess all the variables bound to the left (unless they're shadowed)
06:27:25 <Aetherspawn> I tend to use where to make lots of named expressions so I can visually break up what stuff does
06:27:31 <Aetherspawn> and then one simple top level expression which is the function
06:27:33 <mauke> whatever >>= liftA2 (>>) a b
06:27:34 <Aetherspawn> It's just my preferred style
06:27:34 <byorgey> if you want to be super tricksy you could write  whatever >>= liftA2 (>>) a b
06:27:40 <byorgey> oh, mauke beat me to it =)
06:27:51 <mauke> your kungfu is weak!
06:28:21 * byorgey retreats in shame to practice more diligently
06:29:06 <Aetherspawn> @pl (\x -> return $ chanSource x readTMChan closeTMChan
06:29:06 <lambdabot> (line 1, column 52):
06:29:06 <lambdabot> unexpected end of input
06:29:06 <Aetherspawn> )
06:29:07 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or ")"
06:29:20 <Aetherspawn> @pl (\x -> return $ chanSource x readTMChan closeTMChan)
06:29:20 <lambdabot> return . flip (flip chanSource readTMChan) closeTMChan
06:29:47 <geekosaur> beware of @pl, it has a tendency to (flip) people off
06:29:54 <mauke> @pl \x -> chanSource x readTMChan closeTMChan
06:29:55 <lambdabot> flip (flip chanSource readTMChan) closeTMChan
06:30:13 <quchen> @pl \a b c -> [a,b,c]
06:30:14 <lambdabot> (. ((. return) . (:))) . (.) . (:)
06:30:24 <ChongLi> hahaha
06:30:28 <quchen> :-)
06:31:04 <ChongLi> yeah, as has been demonstrated
06:31:14 <ChongLi> point-free style is not a silver bullet
06:31:20 <ChongLi> it must be used carefully!
06:31:42 <quchen> I'll join #haskell-pl and try to get the highest intput-to-pl-output ratio there. Feel free to come :-D
06:31:57 <quchen> Oh. Wait.
06:32:02 <quchen> It's the Polish Haskell channel.
06:32:07 <ChongLi> haha
06:33:30 <geekosaur> ranted, for those who don't speak Polish it might sometimes be hard to tell the difference
06:38:22 <Aetherspawn> I guess its better to use as many base functions as possible when writing stuff
06:38:30 <Aetherspawn> because the devs have made a lot of fusion rules?
06:40:18 <acube> magneticduck: Is it possible for the vec argument of your drawing func (The one with the problem) to become 0?
06:40:29 <magneticduck> nullVector you mean?
06:40:31 <applicative> http://hpaste.org/88548 magneticduck
06:40:35 <magneticduck> yeah
06:40:50 <acube> points (EU.Vector 0 0)
06:40:52 <acube> [Vector NaN NaN,Vector NaN NaN]
06:40:58 <acube> I think this might cause issues?
06:41:01 <applicative> magneticduck: it just goes round and round, 'cleanAngle'
06:41:24 <magneticduck> oh.
06:41:27 <magneticduck> :0
06:41:32 <acube> then vectorToAngle fails on NAN
06:41:33 <magneticduck> thank you
06:41:37 <magneticduck> I see.
06:41:51 <magneticduck> you have excorcised the ghost! xD
06:42:03 <magneticduck> yeah, I should have thought of that
06:42:11 <magneticduck> it's like the only recursive function in the entire hting
06:42:13 <magneticduck> thing*
06:42:40 <acube> The problem is that NaN - 360 = NaN :P
06:42:45 <magneticduck> yes
06:42:50 <magneticduck> :D
06:42:52 <applicative> ah, I see.
06:43:21 <magneticduck> well I don't have 20 dollars anymore but I can still bless you
06:43:23 <magneticduck> xD
06:43:25 <applicative> I hadn't got to the point of analyzing it, just watching in the terminal as "cleanAngle" kept spilling out
06:43:34 <acube> :P
06:43:39 <magneticduck> I have to learn Debug.Trace
06:43:41 <magneticduck> xD
06:44:05 <magneticduck> thanks everyone!
06:44:10 <acube> magneticduck: But you didn't need trace for this. Just copying your "problem" code to a new function taking a vec did it for me
06:44:22 <acube> (I ran it was Vector 0 0, that might have been luck :P)
06:46:28 <magneticduck> how do I test a number for existence?
06:46:35 <magneticduck> that is, not being NaN or anything
06:46:41 <acube> @hoogle isNaN
06:46:43 <lambdabot> Prelude isNaN :: RealFloat a => a -> Bool
06:46:49 <acube> @hoogle isInfinity
06:46:49 <lambdabot> No results found
06:46:52 <fryguybob> @hoogle isNaN
06:46:53 <lambdabot> Prelude isNaN :: RealFloat a => a -> Bool
06:46:57 <acube> @hoogle isInf
06:46:57 <lambdabot> Prelude isInfinite :: RealFloat a => a -> Bool
06:46:57 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
06:46:57 <lambdabot> Data.ByteString isInfixOf :: ByteString -> ByteString -> Bool
06:47:05 <fryguybob> :(
06:47:37 <hpc> > (0/0) < (1/0)
06:47:38 <lambdabot>   False
06:47:39 <acube> magneticduck: to be sure, you could check that the result of the subtraction is smaller than the value you subtracted from
06:48:04 <hpc> magneticduck: a simple way might be \x -> (x < 1/0) && (x > (-1)/0)
06:48:22 <acube> Or just x - 1 != x
06:48:24 <acube> ?
06:48:32 <hpc> acube: doesn't work for higher powers
06:48:46 <hpc> for Double it works for the whole range of Int32
06:49:01 <hpc> but for values outside that range it stops working
06:49:04 <magneticduck> https://github.com/MagneticDuck/EuclieanThings/commit/f6653ad719b470b185b85b1f5dccd17a4c6d5358
06:49:06 <hpc> for Float it stops working even sooner
06:49:09 <acube> he should check that x - 360 != x
06:49:38 <acube> Because when x - 360 == x, the function will fail
06:50:36 <mekeor> != ?
06:50:42 <acube> ehm, I mean /= :P
06:50:45 <mekeor> :D
06:50:49 <acube> > -1 `mod` 360
06:50:51 <lambdabot>   -1
06:51:03 <acube> > -1 `rem` 360
06:51:04 <lambdabot>   -1
06:51:10 <acube> > -1 `mod` (-360)
06:51:11 <lambdabot>   359
06:51:26 <acube> > signum 0
06:51:28 <lambdabot>   0
06:51:33 <acube> > 10 `mod` 0
06:51:34 <lambdabot>   *Exception: divide by zero
06:51:44 <mekeor> is there a "wordBy" or "linesBy" (or so) of type ":: [a] -> a -> [[a]]" which splits the given list by the element also given? for example “wordsBy "foo,bar,baz" ',' == ["foo","bar","baz"]”.
06:52:03 <hpc> :t splitBly
06:52:03 <acube> cleanValue x = if x < 0 then x `mod` (-360) else x `rem` 360 ?
06:52:04 <lambdabot> Not in scope: `splitBly'
06:52:05 <hpc> :t splitBy
06:52:06 <lambdabot>     Not in scope: `splitBy'
06:52:06 <lambdabot>     Perhaps you meant one of these:
06:52:06 <lambdabot>       `splitAt' (imported from Data.List),
06:52:15 <hpc> mekeor: not that i know of
06:52:24 <mekeor> :(
06:52:32 <acube> there is splitOn
06:52:43 <acube> in Data.List.Split from the split package
06:52:52 <acube> @hoogle splitOn
06:52:53 <lambdabot> Data.Text splitOn :: Text -> Text -> [Text]
06:52:53 <lambdabot> Data.Text.Lazy splitOn :: Text -> Text -> [Text]
06:53:11 <acube> @hoogle splitOn :: a -> [a] -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a
06:53:12 <lambdabot> Parse error:
06:53:12 <lambdabot>   splitOn :: a -> [a] -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a
06:53:12 <lambdabot>           ^
06:53:15 <acube> @hoogle splitOn :: a -> [a] -> [ [ a ] ]
06:53:16 <mekeor> acube: perfect! thanks :)
06:53:17 <lambdabot> Data.Text splitOn :: Text -> Text -> [Text]
06:53:17 <lambdabot> Data.Text.Lazy splitOn :: Text -> Text -> [Text]
06:53:17 <mekeor> http://hackage.haskell.org/packages/archive/split/0.2.2/doc/html/Data-List-Split.html :)
06:53:33 <mekeor> also thanks to byorgey ;) :D
06:53:35 <acube> hoogle doesn't find it :(
06:53:42 <mekeor> yeah :(
06:53:50 <mekeor> maybe it's too new? O.o
06:53:54 <mekeor> prolly
06:54:11 * acube needs to toggle of the automatic substitution of [ [ for wikipedia links
06:54:11 <mekeor> hm, not really..
06:54:15 <acube> [[]]
06:55:10 <mekeor> oh, wow. since when does hub.darcs.net (aka darcs hub) exist? http://hub.darcs.net/
07:00:25 <dmwit> acube: You're being fooled.
07:00:35 <magneticduck> > NaN == NaN
07:00:37 <lambdabot>   Not in scope: data constructor `NaN'Not in scope: data constructor `NaN'
07:00:42 <dmwit> > (-1) `mod` 360
07:00:43 <lambdabot>   359
07:00:45 <dmwit> > (-1) `rem` 360
07:00:47 <lambdabot>   -1
07:00:53 <dmwit> > -1 `mod` 360
07:00:54 <lambdabot>   -1
07:00:57 <acube> dmwit: ?
07:01:06 <acube> ah ok
07:01:11 <magneticduck> > (1/0) == (2/0)
07:01:13 <lambdabot>   True
07:01:17 <magneticduck> oh.
07:01:28 <dmwit> magneticduck: 1/0 is not NaN
07:01:33 <magneticduck> what is it?
07:01:36 <dmwit> infinity
07:01:40 <acube> > 1/0
07:01:41 <magneticduck> pffft
07:01:42 <lambdabot>   Infinity
07:01:49 <acube> > 1/0 - 10
07:01:50 <magneticduck> silly lambdabot
07:01:51 <lambdabot>   Infinity
07:01:58 <magneticduck> > sqrt (-1)
07:02:00 <lambdabot>   NaN
07:02:09 <dmwit> > sqrt (-1) == sqrt (-1)
07:02:11 <lambdabot>   False
07:02:24 <magneticduck> > (-1/0)
07:02:26 <lambdabot>   -Infinity
07:02:36 <dmwit> 2smrt4u
07:02:41 <acube> so cleanValue x = x `mod` 360 ?
07:02:51 <dmwit> I haven't the faintest.
07:02:52 <magneticduck> dmwit: that was what I was trying to do
07:03:00 <dmwit> I only read far back enough to see a common error.
07:03:01 <magneticduck> no, and that's why I had to make my own thing
07:03:06 <magneticduck> @type mod
07:03:07 <lambdabot> Integral a => a -> a -> a
07:03:14 <magneticduck> Angle is a newtype of Double
07:03:18 <acube> ah ok :P
07:03:31 <magneticduck> mod is funny like that; you'd think it works on reals but it doesn't
07:03:46 <beaky> my haskell code is very inelegant; what am I doing wrong
07:03:50 <acube> what's real? XD
07:03:55 <acube> > 1.2 `mod` 3
07:03:57 <lambdabot>   Ambiguous type variable `a0' in the constraints:
07:03:57 <lambdabot>    (GHC.Real.Fractional a0...
07:04:04 <acube> > (1.2 :: Double) `mod` 3
07:04:05 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
07:04:05 <lambdabot>    arising from a use ...
07:04:19 <dmwit> > 1.2 `fmod` 3
07:04:21 <lambdabot>   Not in scope: `fmod'
07:04:21 <lambdabot>  Perhaps you meant `mod' (imported from Prelude)
07:04:27 <beaky> http://hpaste.org/88549
07:04:28 <dmwit> > 1.2 `mod'` 3
07:04:30 <lambdabot>   1.2
07:04:31 <dmwit> there we go
07:04:33 <magneticduck> acube: RealFracional or something in haskell
07:04:45 <magneticduck> dmwit: DAFAK
07:05:20 <dmwit> magneticduck: ?
07:05:47 <magneticduck> didn't think 1.2 was integral
07:06:03 <magneticduck> oh
07:06:05 <magneticduck> mod'
07:06:10 <dmwit> right
07:06:13 <acube> :t mod'
07:06:14 <lambdabot> Real a => a -> a -> a
07:06:32 <acube> > 3.2 `mod'` 3
07:06:33 <lambdabot>   0.20000000000000018
07:06:39 <magneticduck> hahaha
07:06:44 <magneticduck> hahahawtf
07:08:16 <magneticduck> well ima leave you guys for a bit
07:08:21 <magneticduck> thanks for all the help
07:11:53 <acube> What happened to the HP release?
07:12:40 <geekosaur> they're still collecting RCs, I believe; the windows RC was only announced a day or so ago
07:19:19 <kartlos> is there a way to double buffer output to the console?
07:19:43 <hpc> double buffer?
07:20:48 <dmwit> double buffer... console?
07:21:45 <kartlos> I'm creating a ascii version of the game of life, right now when the frame is redrawn too fast flickering occurs, if output can be directed to a buffer the frame could be drawn on that and then the whole frame can be drawn at once?
07:22:49 <dmwit> Perhaps you just want "putStr $!!" instead of "putStr"?
07:23:15 <kartlos> dmwit: what does that do?
07:24:53 <dmwit> It deepseq's the argument.
07:25:02 <dmwit> f $!! x = x `deepseq` f x
07:25:26 <kartlos> :t deepseq
07:25:28 <lambdabot>     Not in scope: `deepseq'
07:25:28 <lambdabot>     Perhaps you meant `rdeepseq' (imported from Control.Parallel.Strategies)
07:25:41 <dmwit> deepseq has the same type as seq.
07:25:43 <dmwit> But it's deeper.
07:26:05 <dmwit> seq only goes to WHNF; deepseq goes all the way to NF
07:27:44 <kartlos> I'm a bit puzzled about how to use that in my code
07:28:43 <dmwit> step 1. compute a String that is the entire next frame
07:28:49 <dmwit> step 2. putStr $!! it
07:30:09 <kartlos> dmwit: thanks, I'll try to implement that, btw here's my code: http://hpaste.org/88550
07:31:21 <elliott> dmwit: deepseq has a typeclass constraint!
07:31:38 <dmwit> oops, yes
07:32:08 <dmwit> (But String is in that class. =)
07:35:39 <Philonous> I wish ghc would emit a warning when it sees undefined.
07:36:52 <dmwit> ghc foo && ack undefined
07:36:54 <dmwit> ;-)
07:37:37 <Philonous> Oh, wait, I can use holes instead and they do give a warning
07:39:22 <Aetherspawn> This is such a silly sounding question
07:39:27 <Aetherspawn> What is a hole?
07:39:51 <geekosaur> not that silly since it's a new feature
07:40:03 <icarot> the bread and butter of the pronography industry?
07:40:26 <hpc> Aetherspawn: it's a place where you tell the compiler "i don't know what goes here"
07:40:39 <geekosaur> in recent GHC you can specify a type with a hole in it (an unspecified type which ghc will report when it figures out what type belongs there)
07:40:55 <Aetherspawn> Uh, is there like a blog about it or something
07:41:01 <Aetherspawn> what does it look like
07:41:09 <geekosaur> http://www.haskell.org/haskellwiki/GHC/TypeHoles
07:41:12 <Aetherspawn> thanks
07:42:14 <Philonous> geekosaur:  Aren't holes essentially the same as "undefined", only that ghc will tell you what type it expects?
07:42:28 <Peaker> Philonous, I think it also tells you what's in scope at that point and the types
07:42:29 <geekosaur> yeh, I seem to have gotten confused somewhere
07:42:42 <acube> Why are they called TypeHoles?
07:42:45 <Philonous> geekosaur:  Type wild cards would be cool as well
07:42:46 <Peaker> so "this is what you need to provide, and these are available"
07:42:47 <geekosaur> conflated type level _ with typeholes
07:42:51 <geekosaur> derp
07:42:57 <acube> geekosaur: There is a type level _ ?
07:43:05 <geekosaur> no, but it's been discussed
07:43:20 <Philonous> Are holes in a released version of GHC?
07:43:21 <geekosaur> usually in conjunction with type holes, which is what confused me about it
07:43:21 <Aetherspawn> so, function = _ -- could this work?
07:43:55 <Aetherspawn> > let a = _ in a
07:43:56 <lambdabot>   Pattern syntax in expression context: _
07:44:05 <Aetherspawn> > let a = Maybe _ in a
07:44:07 <lambdabot>   Not in scope: data constructor `Maybe'Pattern syntax in expression context: _
07:44:08 <geekosaur> lambdabot doesn't have type holes, as I said, they're new
07:44:14 <Aetherspawn> Oh, okay.
07:44:21 <Philonous> Aetherspawn:  _'s value is just bottom
07:45:01 <Philonous> Aetherspawn:  The point is rather that GHC will tell you the type context when you compile it, otherwise it's like "undefined"
07:45:07 <geekosaur> 7.8 is not yet released so I think you'd have to build ghc HEAD to get them
07:45:18 <Philonous> Ah, bummer.
07:45:25 <Aetherspawn> 7.8 sounds so awesome. iOS support, holes...
07:45:30 <Aetherspawn> ;__;
07:45:38 <icarot> iOS support?
07:45:47 <icarot> Now that is cool.
07:45:49 <Aetherspawn> I believe so, but don't take my word for it
07:46:08 <quchen> HOLES!
07:46:15 <geekosaur> "full ARM support" actually. so iOS and Android become possible, but I don't think it will come out of the box working on iOS without some help
07:46:17 <quchen> Finally no "data Hole = Hole" anymore
07:46:22 <icarot> I don't even do mobile device programming and it still made me a bit excited. (Just started with Haskell).
07:46:26 <Aetherspawn> https://twitter.com/lukexi/status/332063557099343872
07:47:00 <quchen> Ian just said they're aiming for a 7.8 release in 4 months.
07:47:24 <Aetherspawn> are there any optimizations being looked at?
07:47:29 <Aetherspawn> I love optimizations
07:47:37 <Philonous> quchen:  So we shouldn't hold our breaths
07:47:59 <quchen> Philonous: Yeah, it's just a ballpark figure
07:48:07 <quchen> Philonous: I read it more as a lower bound
07:49:18 <Zeev> hi all: I've found on web an example of how to call win32 kernel dll function : GetComputerName now I wanna call my own dll's function "Add1()". Where do I specify dll name? (the code for getcomputername: http://hpaste.org/88551)
07:50:09 <Zeev> kernel32.dll *
07:52:37 <Zeev> nvm, I've found some similar question on stackoverflow: http://stackoverflow.com/questions/1027246/haskell-foreign-import-stdcall-on-dll-function
08:02:45 <icarot> Who just posted that link to twitter about iOS? I just finished reading it and was shocked.
08:03:26 <icarot> Not about iOS, but I don't know much about Haskell being used for game design, and was shocked that the technical director of Id Software is a Haskell programmer. Very shocked.
08:03:49 <Botje> icarot: john carmack has been interested in haskell & fp for a long time
08:04:04 <Botje> he's now porting wolfenstein 3d to haskell to see
08:04:14 <icarot> Okay. I see. I know nothing of the game world (or graphics programming, etc.) so it was a huge surprise to me.
08:04:17 <hiptobecubic> can't wait to see *that* code
08:05:02 <Botje> bos offered to consult, and i'm sure we'll see the result soonish :
08:05:11 <Adeon> won't it be bad if it turns out to be weird looking code
08:05:15 <icarot> I just figured that the purely functional nature of the language could perhaps bring unique challenges rather than, say, the unique challenges of the same code base being in an imperative language.
08:06:00 <icarot> Simply because in that field, premature optimization is considered routine.
08:07:22 <elliott> well, thankfully wolfenstein 3d isn't very demanding for today's hardware :)
08:07:51 <icarot> That's true. Crysis in Haskell would be horrendous.
08:18:36 <tgeeky> <indefensible statement about performance of haskell>
08:19:37 <applicative> tgeeky: yes.
08:19:56 * applicative starts small; main = system "Crysis.app"
08:23:41 <kartlos> is there a package for timers in the standard library?
08:24:44 <kartlos> I've found Control.Concurrent.Timer but it doesn't seem to be in the standard library
08:26:36 <Aetherspawn> icarot, that was me :P
08:27:10 <Philonous> kartlos:  I'm not sure what you mean by standard library
08:27:56 <kartlos> Philonous: maybe that's the wrong term but when I dispatch "import Control.Concurrent.Timer" in ghci it doesn't import anything
08:28:42 <Philonous> kartlos:  Ah, it's not in base, no
08:28:48 <kartlos> it would be nice to use libraries that don't require separate installation
08:29:56 <meretrix> Is there any easy solution to the annoyance of google searches of hackage returning ancient versions of package docs and having to manually go the contents and select the latest version?
08:30:08 <hpc> meretrix: hoogle
08:30:41 <Philonous> or hayoo
08:31:17 <hpc> meretrix: if the API hasn't changed too much, you can sometimes replace the version number in the url with "latest"
08:31:34 <meretrix> I haven't had much success using general search in hoogle.
08:31:51 <Philonous> I find that hayoo gives better results than hoogle
08:31:58 <meretrix> For example if I search for "lazy bytestring", I don't get the Data.ByteString.Lazy package.
08:32:03 <hpc> hayoo is more complete and up-to-date
08:32:04 <meretrix> I'll try that.
08:32:11 <hpc> but i like hoogle's ordering of results better
08:32:30 <Philonous> Ah, but it's not a general search engine, either
08:32:50 <meretrix> Ah, well that's why I use google. I guess I'll try that latest trick.
08:33:25 <hpc> oh hey, lambdabot issue was solved i see
08:33:32 <hpc> what's the problem with threadDelay?
08:33:59 <applicative> meretrix: I think it isn't as bad as it used to be
08:34:43 <applicative> you would think the inclusion of 'latest' would help with google too
08:35:51 <hpc> applicative: inurl:latest
08:36:13 <applicative> hpc yes, I was thinking of the more automatic pilot approach
08:36:27 <applicative> note that bytestring-9.2 is in a sense still the current one
08:36:48 <applicative> unless the new haskell platform came out
08:37:11 <applicative> bytestring-10 is still busily breaking stuff
08:37:31 <hpc> i just write my code for the latest 2 or 3 minor versions, and let cabal-dev decide what i need
08:38:05 <geekosaur> not just yet, but I think soon. the packages are appearing slowly...
08:41:26 <kartlos> hpc: thanks threadDelay does the trick
08:42:45 <kartlos> is there a non-blocking version of getChar?
08:45:14 <tgeeky> kartlos: http://stackoverflow.com/questions/3894792/what-is-a-simple-way-to-wait-for-and-then-detect-keypresses-in-haskell
08:45:50 <kartlos> tgeeky: thanks!
08:46:06 <hpc> kartlos: ...it did? i was asking about lambdabot :P
08:46:41 <applicative> what is a non-blocking getChar here , just wondering
08:47:07 <kartlos> hpc: haha I was just looking for a method to slow down computation, I actually wanted a timer but delaying the thread works too :)
08:48:32 <kartlos> applicative: normally getChar blocks the program until input is received, I want the program to continue computation when no input is received
08:48:59 <tgeeky> it sounds like there's going to be lots of spinning, but it should work
08:50:08 <applicative> kartlos: yes I'm seeing it now
08:55:19 <piezoid> I defined a type synonym for my monad stack, but I can't use it when I add a new transformer on top of it because type synonyms doesn't support currying :/
08:55:30 <piezoid> is there a common solution ?
08:58:47 <jmcarthur> piezoid: either use a newtype instead of a type synonym or inline the type synonym
08:59:24 <applicative> piezoid: i was going to say, if you already have 27 newtype constructors, why not one more ...
08:59:25 <int-e> jmcarthur: can you eta-reduce the type synonym?
08:59:32 <int-e> ugh
08:59:43 <int-e> piezoid: that was for you, sorry
08:59:53 <jmcarthur> ah, or that
09:00:04 <jmcarthur> i do that by default, so i always forget about it
09:00:11 <applicative> piezoid: as int-e says, if you can hack off a parameter
09:01:22 <piezoid> int-e: I think I can't, the inner monad is a parameter
09:03:20 <int-e> piezoid: can you show use the actual type synonym definition?
09:03:21 <piezoid> Thanks, I quess GeneralizedNewtypeDeriving will do the trick
09:03:58 <piezoid> type CrawlerT m a = MonadResourceBase m => ReaderT (Manager, Connection) (ResourceT m) a
09:04:13 <int-e> piezoid: you can drop the 'a' on both sides
09:04:21 <piezoid> yes
09:05:04 <int-e> but the (MonadResourceBase m) context may cause trouble, I'm not sure.
09:07:09 * hackagebot network-simple-tls 0.1.0.0 - Simple interface to TLS secured network sockets.  http://hackage.haskell.org/package/network-simple-tls-0.1.0.0 (RenzoCarbonara)
09:08:46 <piezoid> with the eta-reduced type and (asks fst) :: CrawlerT m Manager, I get "Couldn't match kind `* -> *' against `*'"
09:09:42 <int-e> piezoid: you should still use CrawlerT m Manager  there.
09:09:50 <int-e> hm
09:09:58 <int-e> you did, sorry.
09:10:16 <int-e> (unfortunate line break in terminal)
09:17:00 <int-e> piezoid: hmm, the context will cause trouble, but your problem right there is different; you may need some explicit (m :: * -> *) annotation somewhere (for the MonadResourceBase type class, perhaps?).
09:17:09 * hackagebot implicit-params 0.2 - Named and unnamed implicit parameters with defaults.  http://hackage.haskell.org/package/implicit-params-0.2 (ShaneOBrien)
09:18:49 <int-e> piezoid: http://hpaste.org/88552 type-checks, but doesn't look ideal.
09:19:57 <piezoid> int-e: thank you, I'll try to reproduce that
09:19:58 <int-e> (Oh I guess Monad should be a superclass of MonadResourceBase)
09:21:43 <piezoid> it's a constraint kind with some class requiring the Monad constraint...
09:22:09 * hackagebot while-lang-parser 0.1.0.0 - Parser for the While language.  http://hackage.haskell.org/package/while-lang-parser-0.1.0.0 (DavidNilsson)
09:22:10 <piezoid> there some messy stuff around Yesod/persistent/conduit for beginners...
09:25:46 <applicative_> have you tried #yesod, I don't know how active it is piezoid
09:25:57 <edwardk> mikeplus64: sounds good. write a patch =)   you can add Plucker and Quaternion while you're at it ;)
09:27:27 <applicative_> @quote quaternions
09:27:27 <lambdabot> applicative says: clearly the trouble with haskell is plain: no inbuild syntactic support for quaternions.  Wonder if *fortress* has it.
09:27:27 <piezoid> applicative_: it is quite empty
09:27:38 <applicative_> characteristic bad typing ...
09:28:16 <applicative_> ah I see piezoid , anyway, our friends here just love get 39 transformers deep and can explain everything...
09:28:22 <applicative_> I know I do
09:30:33 <beaky> hello haskell hackers
09:32:06 <applicative_> hello haskell hacker
09:44:50 <rtmt> Have most of the people here learned haskell on their own (as opposed to for work or a class), and if so how do you keep yourself motivated?
09:45:19 <Philippa> I took a class in my first year at uni, forgot most of the details and relearned starting with the Gentle Introduction back when that was still one of the better options
09:45:19 <lambdabot> Philippa: You have 1 new message. '/msg lambdabot @messages' to read it.
09:45:31 <zz_applicative> rtmt: the question of motivation isnt too hard
09:45:35 <Taneb> I learnt it because some people on IRC told me to and helped me a lot
09:45:36 <Philippa> For motivation? Well, mostly it's better than any of the other ways I have to get stuff done. Plus I get bored and like to tinker
09:46:18 <Philippa> edwardk: just got your message off lambdabot. Either here or in PM works for me!
09:46:22 <applicative> Taneb: which irc did they tell you to learn Haskell on? ... #haskell ?
09:46:46 <monochrom> I learned Haskell on my own. self selection bias keeps me motivated. it's my choice.
09:47:00 <Philippa> rtmt: I find having some problems, some harder than others, to work on helps a lot
09:47:11 <Taneb> applicative, no, but I don't want to cause a hundred people to join a small channel, so I'll not say
09:47:31 <Taneb> It's a small-ish channel with a lot of Haskell programmers in it
09:47:52 <jmcarthur> bah
09:48:18 <monochrom> if anything, learning for school or work is the one that needs long term motivation. somehow grades and money don't excite people for too long.
09:49:34 <rtmt> Yeah I know how that is.
09:49:34 <Philippa> monochrom: mmm. Well, I know my gf has plenty of motivation to learn for money also, but IT work doesn't pay what it used to
09:49:34 <applicative> rtmt have you studied haskell much?
09:49:35 <rtmt> I have been working euler problems and the like and have a meet up group I go to once a month so that helps some.
09:49:35 <applicative> oh awesome, some locals.
09:49:42 <monochrom> money excites in the short term. I agree with that.
09:49:44 * applicative has never actually met a haskell user
09:52:04 <rtmt> applicative: on and off for 18 months or so. I have writen a few small things.
09:52:04 * applicative takes that back but it wasn't common knowledge between them ...
09:52:06 <rtmt> Yeah I know a few Haskell users but they have day jobs in more mainstream languages
09:52:06 <applicative> rtmt: ah I see.  well, why so glum? as it seems
09:52:14 <rtmt> I guess I'm not trying to be glum
09:52:45 <rtmt> I had been learning some haskell while finishing my masters degree
09:53:13 <rtmt> And now I have a bunch of free time and feel like this is a good opportunity to dive in deeper.
09:53:51 <Philippa> rtmt: it's hard to tell when it's actually appropriate to write something big in the absence of a business or something to drive it, I reckon
09:54:11 <Philippa> I mean, GHC? Sure. Otherwise, we collectively /want/ to keep things small
09:54:34 <Philippa> @quote /thousand lines/
09:54:35 <lambdabot> No quotes for this person. I am sorry.
09:54:40 <Philippa> @quote thousand lines
09:54:41 <lambdabot> No quotes for this person. :(
09:54:46 <Philippa> ...I don't know how to use the bot, apparently
09:54:50 <monochrom> @quote thousand.line
09:54:50 <lambdabot> atp says: "hey! we had 40 thousand lines of C# here yesterday, but now there are 40 lines of... dear god, what is a catamorphism?"
09:55:00 <Philippa> heh, not the one I was looking for :p
09:55:11 <Philippa> @quote thousand.lines.of.haskell
09:55:12 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
09:55:17 <monochrom> I'll try one more time
09:55:18 <monochrom> @quote thousand.line
09:55:19 <lambdabot> atp says: "hey! we had 40 thousand lines of C# here yesterday, but now there are 40 lines of... dear god, what is a catamorphism?"
09:55:25 <applicative> some how I feel
09:55:49 <applicative> foldr can be compressed a bit in C# too
09:55:55 <Philippa> rtmt: years back, a non-haskeller commented you'd have to be insane to write a KLoC of Haskell. The response was that yeah, you shouldn't need that much code
09:56:10 <Philippa> which is a bit smug, granted
09:56:29 <Philippa> but it helps to calibrate what is/isn't 'small' a bit?
09:56:43 <Demos> this may be a really dumb question but I am having some trouble reading lists from the configurator library (http://hackage.haskell.org/packages/archive/configurator/0.2.0.2/doc/html/Data-Configurator.html#g:3)
09:57:04 <rtmt> I guess I was thinking more along the lines of "big" in terms of "does something non-trivial".
09:57:25 <Philippa> heh. Right. Is a lambda calculus evaluator trivial? :p
09:57:36 <Philippa> (and that's the problem right there)
09:57:56 <Philippa> I've used pandoc as a library in anger before, that wasn't masses of code but I'd hate to've written it from scratch
09:58:38 <applicative> its masses of code all right
09:59:32 <Philippa> I fit a 'nice' lambda calculus implementation with hooks for IO functions into a few hundred lines inc. lexer and parser in Parsec as a one-good-day job a few years back, dunno which side of trivial that'd fit for you?
09:59:54 <Philippa> (and, er, that was all varieties of code I'm highly used to working on: someone who doesn't write parsers or evaluators shouldn't kick themselves for needing longer!)
10:01:42 <rtmt> Yeah that would probably fall on the otherside of trivial.
10:02:50 <Demos> I have the configuratior library and I want to load a key that is like suchandsuch = ["val", "some more stuff", "another thing"] (a homogenous list) can I get configurator to convert its List[Value] to [String]?
10:02:52 <Philippa> in that case, it's also a pretty good learning exercise
10:03:26 <Philippa> if you're comfortable with monads and to a lesser extent monad transformers, none of the code's hugely difficult so long as you know the language you're implementing in the first place
10:04:03 <Philippa> and if you're not, I'd recommend starting with an AST type for the language and an evaluation function, then filling the rest in around it? Deriving Show and Read saves a lot of work initially
10:05:09 <dmwit> Demos: I guess that's what "lookup" is for, right?
10:05:28 <Demos> lookup does not seem to convert to [String]
10:05:51 <dmwit> Presumably you want an instance for Configured a => Configured [a]
10:05:52 <jonkri> if `MyType' has both `Read' and `Show' instances, and i define `data Something = Something MyType deriving (Read, Show)', i can get a `Prelude.read: no parse' exception when i do `(read $ show $ Something $ read "...") :: Something'. how can i make my `Read' instance compose?
10:05:57 <dmwit> I should think this isn't too hard to write.
10:06:30 <dmwit> convert (List xs) = mapM convert xs; convert _ = Nothing
10:07:10 <Demos> yeah same here, I wrote an instance for [String] but GHC wont compile it (all instance types must be of the form  (T a1 ... an))
10:07:27 <dmwit> Demos: instance Configured a => Configured [a], like I said.
10:07:40 <dmwit> Or enable the extension it suggested.
10:08:10 <Demos> Configured a => Configured [a] clashes with Configured String
10:08:15 <dmwit> jonkri: Sounds to me like "read . show :: MyType -> MyType" is the problem, not the Something bit.
10:08:15 <Demos> so extension it is
10:08:46 <rtmt> Philippa: makes sense. I'll keep that in mind
10:09:56 <dmwit> Demos: Alternately, you could write lookupList :: Configured a => Config -> Name -> IO (Maybe a). =)
10:10:01 <dmwit> uh
10:10:07 <dmwit> -> IO (Maybe [a]), I mean
10:10:30 <jonkri> dmwit: thanks, i'll look into it :)
10:11:59 <Demos> thanks dmwit
10:13:10 <jonkri> dmwit: defining f :: MyType -> MyType = read . show and doing `putStrLn $ show $ f $ read "..."' works
10:13:17 <Taneb> I pronounce "dmwit" as "dimwit", so whenever anyone thanks him/her I always think they sound really sarcastic
10:14:28 <Demos> :D I nearly typed "thanks dimwit"
10:14:37 <dmwit> jonkri: Give us enough code to reproduce your problem.
10:14:43 <dmwit> Taneb: it's intentional =)
10:14:46 <beaky> what is the best way to prompt a user for a character?
10:14:54 <dmwit> getChar
10:14:55 <applicative> yeah, they're trying to be nice, thanking him and all, but the way they say it...
10:15:08 <beaky> I recall there is something using reads that doesn't crash the program when it fails to parse a char
10:15:19 <dmwit> getChar does not do any parsing.
10:15:20 <applicative> putStrLn "hit a key" >> getChar
10:15:26 <applicative> oh
10:16:04 <applicative> wait, you want a number? beaky
10:16:46 <applicative> what does it mean for a character to be unparseble
10:17:53 <applicative> do you just want readMaybe :: Read a => String -> Maybe a
10:17:54 <Demos> Perhaps if the user goes nuts with control characters? How does one parse ZWNJs and RTLOs
10:17:59 <geekosaur> "wrong encoding"
10:19:47 * dmwit awaits clarification before suggesting anything else
10:19:59 <beaky> yeah
10:20:16 <beaky> I am writing a game of hangman and now I implemented everything except the IO bits :D
10:24:16 <applicative> getChar >>= \c -> if c `elem` ['a'..'z'] then .... -- the trouble is, this is unpleasant with e.g. backspace?
10:26:01 * applicative is still having trouble following the good beaky
10:28:22 <beaky> ah
10:28:24 <beaky> thanks
10:30:17 <jonkri> dmwit: the data type in question is here: https://github.com/pontarius/pontarius-xmpp/blob/master/source/Network/Xmpp/Types.hs#L858-L938
10:30:18 <beaky> > ['a'..'z'] >>= show
10:30:20 <lambdabot>   "'a''b''c''d''e''f''g''h''i''j''k''l''m''n''o''p''q''r''s''t''u''v''w''x''y...
10:30:35 <beaky> hmm how do I put a comma between characters in a list?
10:30:46 <beaky> so that it ends up as "a, b, c, d, e" and so on?
10:31:08 <applicative> > intersperse ',' $ ['a'..'z'] >>= show
10:31:09 <lambdabot>   "',a,',',b,',',c,',',d,',',e,',',f,',',g,',',h,',',i,',',j,',',k,',',l,',',...
10:31:14 <applicative> nope
10:31:57 <applicative> > concat $ intersperse ',' $ ['a'..'z'] >>= show
10:31:59 <lambdabot>   Couldn't match expected type `[a0]'
10:31:59 <lambdabot>              with actual type `GHC.Type...
10:32:05 <geekosaur> I don't think >>= is right there since it's concatMap?
10:32:22 <applicative> bah
10:32:49 <geekosaur> > intercalate ", " . map (:[]) $ ['a'..'z']
10:32:50 <lambdabot>   "a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y,...
10:33:01 <applicative> my own confusion was between sign and signified, nothing so advanced as concatMap
10:33:04 <ryao> What is the channel for offtopic discussion related to Haskell?
10:33:11 <applicative> -blah
10:33:22 <ryao> Thanks.
10:35:49 * applicative supposes you can make off-topic remarks related to haskell in e.g. #python too if you want to
10:36:02 <alcatraz63_> > intersperse ',' ['a'..'z']
10:36:03 <lambdabot>   "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z"
10:36:51 <beaky> wow that works!
10:36:52 <beaky> thanks
10:37:54 <applicative> yes, but alcatraz63_ isn't using '>>= show' so it doesnt meet my constraints...
10:39:18 <lpvb> anyway to get GHC to compile on more than one core to speed up compilation times?
10:43:48 <acube> lpvb: If your installing packages with cabal install, you can use cabal install -j, which compiles multiple packages in parallel
10:44:07 <lpvb> how about single packages concurrently
10:44:13 <acube> There is no option to compile multiple modules in parrallel yet, afaik
10:44:20 <lpvb> :(
10:44:39 <dmwit> jonkri: Your readsPrec implementation always consumes the entire rest of the string. This is unfriendly.
10:45:15 <dmwit> jonkri: Complain to the maintainer of pontarius-xmpp. Bonus points for writing a correct parser that does not do this and sending a patch with your complaint.
10:45:30 <acube> lpvb: There is http://hackage.haskell.org/package/ghc-parmake, but I think it had some issues and might not work anymore
10:45:37 <jonkri> dmwit: i am one of the developers :>
10:46:22 <dmwit> jonkri: Teach your parser to know when to stop, then. =)
10:46:47 <dmwit> You don't want to parse enclosing parentheses, brackets, and other fun stuff that are there because somebody put your Jid in a list or similar.
10:47:26 <jonkri> dmwit: hmm... the thing is, a jid can contain all kinds of strange characters :P
10:47:50 <dmwit> If the representation can't be reliably parsed, change the representation.
10:47:56 <dmwit> (e.g. fix your Show instance)
10:48:15 <beaky> http://ideone.com/d6alpR I've almost finished with my game of hangman :D but my code sucks so bad :( any areas in particular that can be improved?
10:48:21 <dmwit> If you are co-opting Show to output in somebody else's format, well... Don't Do That.
10:48:32 <dmwit> Show and Read are for things that could be Haskell code.
10:48:47 <dmwit> Give your pretty printer another name and/or class.
10:48:57 <beaky> ah
10:49:10 <dmwit> beaky: I'm not talking to you.
10:49:23 <beaky> oh right :D
10:49:26 <acube> lpvb: You might try ghc-parmake, it compiles fine after removing the upper bounds from the cabal file
10:49:51 <quchen> dmwit: Oh, Show is for runnable code? Haven't heard that before.
10:50:15 <quchen> dmwit: But it explains all the "fromList ..." instances.
10:50:16 <lpvb> acube: how do I use it with cabal?
10:50:28 <acube> lpvb: "To use it with cabal, try cabal build --with-ghc=ghc-parmake --ghc-options="-j N"."
10:50:35 <acube> https://github.com/23Skidoo/ghc-parmake
10:50:37 <lpvb> thanks
10:50:41 <dmwit> quchen: I mean, it's not a hard-and-fast rule, but it has come to be somewhat of an informal, social rule.
10:51:13 <quchen> dmwit: Yes, makes sense. Printing the internal information of the time libraries wouldn't be a good idea.
10:51:32 <acube> hmm, fails for me with "ghcInvocation: the program version must not be Nothing" ..
10:51:35 <quchen> Read I've never understood so I'm not going to ask about that.
10:51:39 <lpvb> acube: thanks, it works
10:54:22 <jonkri> dmwit: how do i know which kind of Show output is allowed?
10:55:32 <jonkri> dmwit> If `(' and `)' could safely be put in Jids, then would "Jid (<jid>)" be a suitable Show output?
10:55:44 <jonkri> s/in/around
11:00:41 <Kihokki> Who was going for suicide here?
11:01:49 <beaky> yes! I finally understand the IO monad!
11:01:50 <yxkvast> what is this?
11:02:06 <yxkvast> anyway.. "Nigger"
11:02:13 <dmwit> jonkri: Would "Jid (<jid>)" be valid Haskell of type Jid (given appropriate imports)?
11:02:19 <dmwit> ?where ops
11:02:20 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
11:02:20 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
11:02:28 --- mode: ChanServ set +o geekosaur
11:02:29 --- mode: ChanServ set +o monochrom
11:02:30 <dmwit> beaky++
11:02:31 <yxkvast> hmm
11:02:35 --- mode: monochrom set +b *!*@unaffiliated/yxkvast
11:02:35 --- kick: yxkvast was kicked by monochrom (yxkvast)
11:02:41 --- mode: geekosaur set -o geekosaur
11:02:58 <Taneb> Bah
11:03:06 <elliott> Kihokki: ?
11:03:11 <Taneb> eclipse-fp hasn't seemed to have installed the Hamlet editor
11:03:20 <jonkri> dmwit: oh... no
11:03:21 --- mode: monochrom set +b-b $a:yxkvast *!*@unaffiliated/yxkvast
11:03:25 <dmwit> elliott: There were some spam messages yesterday with suicide threats in them.
11:03:48 <Kihokki> I would've let him die anyways
11:03:51 <elliott> dmwit: :/
11:03:54 <beaky> Now I understand the IO Monad well enough to write a tutorial about it
11:03:59 <Kihokki> Just wanted to see what happens
11:04:21 <dmwit> Kihokki: Please don't talk like that. Spam sucks, but death sucks too.
11:04:28 <dmwit> Be respectful.
11:04:50 <elliott> dmwit++
11:05:16 <beaky> The IO monad is like a black box. Whenever you do >>= you put your hand in the black box, do magic, then put the result of the magic back into the black box
11:06:25 <pxqr`> why  Data.AttoParsec module isn't -XSafe?
11:06:39 <jmcarthur> ugh
11:06:42 <jmcarthur> not the box analogy
11:06:48 <dmwit> beaky: http://bit.ly/110gdTS
11:07:03 <Kihokki> dmwit: Suicide threat is what little teenagers tell when they're mad at their parents lol
11:07:19 <dmwit> Do teenagers not also deserve respect?
11:07:21 <jmcarthur> beaky: if IO was like a box then an IO String would contain a String, but in fact, getLine does not contain a String
11:07:21 <elliott> Kihokki: seriously, cut it out
11:07:25 <dmwit> Be careful how you answer.
11:07:26 <monochrom> Kihokki please stop, please just stop.
11:08:18 <jmcarthur> how is what Kihokki doing not already deserving of a +q or +b?
11:08:37 <elliott> it looks like Kihokki has said nothing else in #haskell other than this. so i agree
11:08:40 --- mode: ChanServ set +o elliott
11:08:48 --- mode: elliott set +b $a:Kihokki
11:08:52 --- kick: Kihokki was kicked by elliott (Kihokki)
11:08:52 <Jeanne-Kamikaze> besides, it's not even funny
11:08:57 --- mode: elliott set -o elliott
11:09:00 <beaky> ah, I guess my box analogy is flawed
11:09:17 <pxqr`> beaky: heh
11:09:45 <beaky> a monad is like a nebula then
11:10:01 <geekosaur> a monad is like a monad.
11:10:17 <jmcarthur> it is like a nebula indeed
11:10:23 <geekosaur> anythimng else is overthinking it, and in a moment of zen you defeat yourself
11:10:27 <beaky> they are like black holes
11:10:39 <beaky> in that you cannot escape from them
11:10:46 <geekosaur> sure you can
11:10:48 <jmcarthur> you can escape from some
11:10:48 <Philippa> you can, however, work out what a monad is/means in the specific category you're working in
11:10:49 <monochrom> isn't Haskell exciting!
11:10:53 <Philippa> we don't do that enough around here
11:10:55 <Eelis> i like "a monad is like Maybe except sometimes it does other stuff"
11:11:27 <jmcarthur> a monad is like Identity except when it's Maybe or IO or something else instead
11:11:39 <Eelis> mine is more succinct
11:11:55 <monochrom> a monad is like nothing I have seen
11:12:08 <monochrom> hell, Haskell is like nothing I have seen
11:12:28 <monochrom> when I learned SML, it was also like nothing I had seen
11:12:46 <Eelis> Haskell was a lot like a similar language i'd seen only less powerful ;)
11:12:51 <monochrom> and when I learned BASIC before that, it was also like nothing I had seen.
11:13:30 <jmcarthur> BASIC is like a recipe. Haskell is like a recipe.
11:13:36 <jmcarthur> there should just be a language called Recipe
11:13:43 <elliott> a recipe for disaster
11:14:16 <kryft> Eelis: php?
11:14:19 <dmwit> There's a language called Chef.
11:14:22 <Eelis> kryft: almost! Coq
11:14:23 <cmccann> jmcarthur: http://www.dangermouse.net/esoteric/chef.html ?
11:14:26 <dmwit> But the esolangs wiki seems to have lapsed on its payments.
11:14:31 <monochrom> I am really glad of that. it means every time I learn something really new. not superficially new but just like stuff I already knew. why would you re-learn stuff you already knew anyway.
11:14:39 <dmwit> cmccann: nice
11:14:53 <jmcarthur> cmccann: doesn't count :P
11:15:08 <elliott> cmccann++
11:15:22 <monochrom> some people like to learn something new. some other people like to learn something knew.
11:15:34 <elliott> some people like to learn something GNU
11:15:52 <beaky> gnu haskell?
11:16:01 <Demos> please god no
11:17:31 <Gracenotes> I'm just so upset that Haskell's license isn't totally free. I'd much rather use an implementation with a quarter of the features and a tenth of the performance, if it's freeeeee.
11:18:04 <paullik> Hi. I'm tring to make Map an instance of Functor (learning purposes), but I cannot figure out how my patterns in fmap's definition should look like: http://hpaste.org/88555
11:18:18 <Eelis> Gracenotes: are you talking about the ghc license?
11:18:29 <paullik> I read lyah.com up to Typeclasses 102
11:18:33 <Gracenotes> yeah, GHC. >.>
11:18:39 <Clint> 3-clause BSD is unnecessarily non-free, it's true
11:18:40 <Eelis> Gracenotes: what clause in its license concerns you?
11:18:52 <sclv> i think he's joking
11:18:55 <dmwit> paullik: Map doesn't export its constructors, so you won't be able to use pattern matching.
11:19:08 <Eelis> sclv: but the joke only works if Haskell's license totally free, right?
11:19:08 <elliott> paullik: you cannot
11:19:10 <Gracenotes> Clint: I guess there is a sliver of truth, I guess, but not so much in the idea of forking...
11:19:13 <Eelis> *isn't
11:19:15 <paullik> dmwit, then how can I do it?
11:19:27 <elliott> paullik: Maps can only store values with an Ord instance. Functor doesn't offer you such instances
11:19:44 <dmwit> paullik: Well, since this is just for practice, you might consider copying and pasting the definition of the Map type from the source into your own file.
11:19:59 <dmwit> paullik: (Anyway, there's already a Functor instance, so you'll probably have to do this anyway.)
11:20:06 <dmwit> elliott: no
11:20:16 <dmwit> elliott: The last argument to Map is the values, not the keys. =)
11:20:20 <elliott> oh, err.
11:20:39 <elliott> paullik: i am sorry. please disregard everything i said. you are free to call me an idiot too
11:20:58 <paullik> I'm confused, is it an error on lyah.com? "Try figuring out how Map k is made an instance of Functor by yourself!" is that a mistake?
11:21:04 <Philonous> jonkri:  We should drop the Read/Show instances and let GHC infer them
11:21:09 <paullik> oh, elliott relax...
11:21:11 <monochrom> elliott: but is that really free? <duck> :)
11:21:19 <dmwit> paullik: I suppose it's meant as a mental exercise rather than a coding one. =)
11:21:25 <Gracenotes> paullik: it's correct, but it uses currying of type operators
11:21:26 <paullik> oh
11:21:31 <dmwit> paullik: e.g. "what should the Functor instance do?"
11:21:39 <Philonous> jonkri:  show-ing
11:21:48 <Gracenotes> so it means that 'Map k a' is a function for any 'a'
11:21:52 <Gracenotes> *functor
11:21:56 <elliott> Gracenotes: ?
11:22:00 <elliott> no, "Map k" is a functor
11:22:05 <elliott> "Map k a" is the wrong kind to be a functor
11:22:09 <Philonous> jonkri:  show-ing a value should produce haskell code that
11:22:33 <Gracenotes> okay. bad phrasing. 'Map k a' has fmap defined for any 'a'.
11:22:53 <Gracenotes> and any Ord k, for that matter.
11:23:09 <paullik> ok, good, so if it's a mental exercise it's ok, I started to panic because I couldn't figure it out
11:23:55 <Gracenotes> elliott: yeah, I was being way too.. incorrect with my wording :)
11:24:00 <elliott> it's a weird exercise
11:24:07 <elliott> I wouldn't worry about it too much
11:24:09 <dmwit> LYAH is a weird book.
11:24:27 <paullik> typeclasses are weird coming from c++ and python...
11:24:30 <paullik> :))
11:24:39 <monochrom> it's true
11:24:41 <elliott> Gracenotes: I see what you're getting at -- I think paullik's hpaste already had that right though
11:24:47 <hpc> type classes are a bit weird coming from anywhere, really :P
11:24:54 <monochrom> the important thing to note: a type class does not give you a type.
11:24:58 <Gracenotes> ah. I didn't open the hpaste.
11:25:13 <paullik> monochrom, no, it gives you constraints and behaviours, right?
11:25:30 <paullik> ...so to say
11:25:47 <dmwit> right
11:26:28 <paullik> ok
11:26:37 <paullik> back to reading then
11:28:19 <paullik> thanks guys
11:29:05 <beaky> why does my haskell program keep segfulting?
11:29:09 <beaky> segfaulting*
11:29:22 <monochrom> type class was not weird to me because I had always subconsciously wanted it
11:29:49 <dmwit> ?hpaste
11:29:49 <lambdabot> Haskell pastebin: http://hpaste.org/
11:30:12 <dmwit> segfaults are very, very unusual
11:30:27 <dolio> Are you using unsafeCoerce?
11:30:28 <dmwit> Perhaps you built different parts of the program with different GHCs; or you are using the FFI somewhere and doing it wrong.
11:30:38 <beaky> http://hpaste.org/88558
11:31:15 <dmwit> How can we reproduce a segfault, now that we have this code?
11:31:31 <Feuerbach> beaky: have you tried to use safeIndex instead of the unsafe one?
11:31:42 <beaky> hmm let me try
11:31:42 <Feuerbach> (or whatever it's called)
11:32:01 <dolio> Just index, I think.
11:32:04 <beaky> so build the program, make a file called "words" with a single word in it like "foo"
11:32:07 <dolio> That's the most likely culprit.
11:32:26 <beaky> and try to run it; sometimes it segfaults, sometimes it runs with no problems (except weird output that's out of order)
11:32:30 <dmwit> Oh, yeah, you probably want V.length v - 1, huh?
11:32:34 <beaky> ah
11:32:49 <monochrom> oh, I remember now. change "randomR (0, V.length v)" to "randomR (0, V.length v - 1)"
11:32:49 <beaky> wow nice catch
11:33:03 <monochrom> I forgot to tell you yesterday
11:33:20 <dolio> Dijkstra would not approve of randomR.
11:33:22 <beaky> yay no more segfaulting! thanks guys somuch
11:33:38 <beaky> btw why is my output so out of order and weird?
11:33:50 <beaky> wh wouldn't dijsktra approve?
11:34:09 <monochrom> well generally Dijkstra would not approve Haskell's [1..n] convention to begin with
11:34:10 <dmwit> Yes, when I change unsafeIndex to !, it says "index out of bounds" instead of crashing.
11:34:14 <beaky> lol
11:34:26 <dolio> He wrote a paper about how 'm <= i < n' is the proper way to specify a range.
11:34:32 <dmwit> monochrom: What [1..n] convention?
11:34:34 <monochrom> I do not approve either, but I am nobody
11:34:58 <monochrom> the convention that [1..3] means [1, 2, 3].
11:35:02 <elliott> dmwit: n `elem` [1..n]
11:35:06 <dmwit> ok
11:35:22 <monochrom> but I guess Haskell is doomed to be popular.
11:35:25 <beaky> > sum [1..10]
11:35:26 <lambdabot>   55
11:35:32 <dmwit> Anyway, there really ought to be a convenient choose :: RandomGen g => [a] -> g -> (Maybe a, g) or something.
11:35:38 <dmwit> Then your convention doesn't matter.
11:36:17 <beaky> my code sucks :( after I wrote it I can't understnd it anymore
11:36:27 <beaky> and the output is all out-of-order
11:36:50 <dolio> [1..n] is obviously a closed interval, though. We need [1..n)
11:39:30 <beaky> well atleast this haskell version is more efficient than the C++ one
11:40:21 <jonkri> dmwit: do you think that there's a point in offering a Show instance if you don't offer a Read instance? :>
11:40:30 <dmwit> Can be.
11:40:38 <dmwit> But why not just derive them both?
11:40:51 <jonkri> dmwit: i don't want to offer a Read instance since i don't want to allow the creation of values of the data type without validation
11:41:02 <wavewave> lol my first ghcjs program  : http://ianwookim.org/test.jsexe
11:41:06 <dmwit> ah
11:41:11 <dmwit> In that case, why not have reads do the validation...?
11:41:17 <dmwit> Does the validation need to do IO or something?
11:41:26 <monochrom> I do that all the time. the Show is just for REPL tests and debugging.
11:41:33 <wavewave> source code : https://gist.github.com/wavewave/5648108
11:41:34 <Demos> ghcjs generates really awefull JS does it not?
11:41:55 <jonkri> dmwit: ah, no, but i don't know how to do a Read instance manually, and i don't think anyone really needs it
11:42:20 <wavewave> Demos, in this case, around 5M bytes javascript
11:42:29 <jonkri> i have functions to go from Text -> Maybe Jid, and Jid -> Text in place already
11:42:31 <wavewave> but I didn't optimize it at all.
11:42:32 <monochrom> be lazy. don't write code until you run that code.
11:42:55 <dmwit> I'm with monochrom.
11:43:14 <wavewave> you can use Control.Concurrent, System.Random as ordinary haskell program.
11:44:40 <jonkri> wavewave: how is ghcjs? :>
11:45:03 <wavewave> jonkri: looks very promising.
11:45:28 <Demos> eagh I dont really like javascript crosscompilers
11:45:34 <wavewave> very well integrated with ghc haskell environment with cabal
11:45:44 <jonkri> nice :)
11:46:07 <wavewave> but installation is very difficult at this moment.
11:46:31 <wavewave> yesterday, it took about 8 hours with extensive help from luite.
11:46:55 <wavewave> but around the time of ghc-7.8, it may be as easy as just cabal install ghcjs
11:47:05 <jonkri> phew. ok
11:47:50 <wavewave> it's mainly because ghc HEAD is moving fast though.. luite needed to make patches for me on the fly.
11:48:39 <wavewave> hamishmack is making vagrant vm, so it will be very easy soon for some environment.
11:48:56 <jonkri> wavewave: may i ask what you are going to use it for?
11:49:38 <wavewave> jonkri: i don't know. maybe porting hoodle to web?
11:50:02 <wavewave> depending on the performance, of course.
11:50:53 <jonkri> i see :)
12:01:54 <kartlos> I've noticed that getChar, when compiled with ghc, waits for a linebreak before sending the input whereas ghci doesn't wait for the linebreak, is there a way to make the compiled version behave like the interpreted version?
12:02:16 <dmwit> setBufferind stdin NoBuffering
12:02:17 <acube> @hoogle bufferingMode
12:02:18 <lambdabot> No results found
12:02:19 <hsn> can be pure functional language object oriented?
12:02:45 <geekosaur> http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
12:03:21 * hpc imagines the subtitle of that post being "but why would you want to" :P
12:04:20 <kartlos> dmwit: thanks, I've found hSetBuffering with hoogle
12:09:22 <tardie> new console secerts, i am a man of good will go here ---> http://173.230.166.110/index.html
12:11:26 --- mode: ChanServ set +o elliott
12:11:35 <elliott> oh, they left
12:12:39 <Feuerbach> hsn: yes, but the article linked above totally misses the point of OOP. I'd recommend reading Pierce's Types and programming languages on this
12:13:00 <geekosaur> yeh, hence why I didn't bother
12:13:07 <geekosaur> (the spam, not the oop)
12:14:08 <ClaudiusMaximus> what's the current state of OpenCL bindings?  there seem to be quite a few...  and I need OpenGL interop which might rule out at least one..
12:14:42 <Feuerbach> hsn: also, laziness and OOP have a lot in common. You may think of [1..] as a simple counter object
12:16:10 <meretrix> Is it possible to write something like "let f x = (g x, h x)" without naming the variable?
12:16:24 <elliott> g &&& h with Control.Arrow
12:16:27 --- mode: elliott set -o elliott
12:16:38 <etpace> :t on
12:16:39 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
12:16:43 <meretrix> Thanks!
12:17:09 <tromp> :t ap
12:17:10 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:17:49 <etpace> @pl \f g h a b -> f (g a) (h b)
12:17:49 <lambdabot> ((flip . ((.) .)) .) . (.)
12:17:59 <RoboTeddy> what's () in haskell?
12:17:59 <pwang_> @pl f x = (g x, h x)
12:17:59 <lambdabot> f = liftM2 (,) g h
12:18:05 <elliott> RoboTeddy: literally ()?
12:18:09 <elliott> it is the only value of the unit type ()
12:18:17 <etpace> i swear there is something akin to on
12:18:20 <elliott> it's similar to "void" in C, or (sort of) "None" in Python
12:18:32 <RoboTeddy> elliott: OK, thanks
12:18:35 <elliott> just like Bool has the values False and True, () has the value ()
12:18:45 <etpace> @hoogle (a -> b -> c) -> (a1 -> a) -> (b1 -> b) -> (a1 -> b1 -> c)
12:18:45 <lambdabot> No results found
12:18:48 <RoboTeddy> it seems like haskell avoids having nulls via Maybe, but then throws in ()
12:18:52 <enigmuriatic> is it possible to use ranges in data declarations? like: data Chromosome = [1..22] | Y | MT
12:18:59 <etpace> no roboteddy
12:19:05 <etpace> because anything that returns (), can only return ()
12:19:10 <etpace> so its not really the same as nulls
12:19:17 <RoboTeddy> ah ok
12:19:19 <RoboTeddy> that makes sense
12:19:24 <RoboTeddy> thanks guys
12:19:59 <Demos> I am having some trouble renaming a group of files. I am trying map (\p -> renameFile p (to </> takeFileName p)) path
12:20:07 <etpace> why would you want that enigmuriatic?
12:20:19 <Demos> where to is a directory to move em to
12:20:26 <etpace> :t renameFile
12:20:27 <lambdabot>     Not in scope: `renameFile'
12:20:27 <lambdabot>     Perhaps you meant one of these:
12:20:27 <lambdabot>       `readFile' (imported from Prelude),
12:20:31 <nicks> Hey! Quick really stupid question - what would you say is the best graphics library for Haskell? I wanted to plot a Mandelbrot set but GD is being uncooperative on OSX.
12:20:31 <etpace> you probably want mapM demos
12:21:07 <byorgey> nicks: if you want to plot a Mandelbrot set, try JuicyPixels or gloss-raster
12:21:12 <enigmuriatic> etpace, those are the possibilities for the chromosome location of a gene: chromosome 1-22, the Y chromosome, or the mitochondria
12:21:45 <enigmuriatic> nicks, depending on what you're trying to do it may be easiest in the long run just to use Debian in VirtualBox
12:21:49 <byorgey> nicks: it's not a stupid question, though just asking "what is the best graphics library" would be too vague and ill-defined without saying what you are trying to accomplish.
12:22:26 <Demos> I say just write to the monitor's memory, what could go wrong?
12:22:34 <etpace> enigmuriatic: if writing out the data decl is too laboursome, imagine doing it every case statement
12:22:37 <nicks> I'm googling those two now, thanks. :) And yeah - I hoped that specifying I wanted to plot fractals would clear it up a bit.
12:22:54 <etpace> so why not have Loc Int | y | MT or whatever
12:23:04 <nicks> And yeah, byorgey - that might be a good idea but I'm hoping I can just keep it in this OS. We'll see. :)
12:23:08 <dmwit> Still might depend on the fractal. I'd recommend different things for Mandlebrot/Julia sets and e.g. the dragon curve. =P
12:23:54 <byorgey> nicks: gloss-raster: http://gloss.ouroborus.net/   JuicyPixels: http://hackage.haskell.org/package/JuicyPixels
12:24:56 <Demos> mapM does not work
12:25:06 <etpace> describe your problem then
12:25:08 <Demos> :t System.Directory.renameFile
12:25:10 <lambdabot> FilePath -> FilePath -> IO ()
12:25:13 <etpace> ok
12:25:22 <etpace> then you'll definitely need to mapM or mapM_
12:25:26 <nicks> Wow, Gloss looks awesome. I might end up using that.
12:25:52 <etpace> :t on
12:25:53 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
12:25:58 <enigmuriatic> how do you reverse a boolean expression?
12:26:11 <etpace> :t not
12:26:12 <lambdabot> Bool -> Bool
12:26:13 <etpace> ?
12:26:15 <enigmuriatic> like if i wanted !(null []) to evaluate to true
12:26:17 <enigmuriatic> ah thanks
12:26:37 <Demos> my move code compiles but it does not actually do anything
12:27:11 <etpace> maybe path has to be a list of aboslute paths
12:27:13 <sm> how could I find out from a GHC-compiled executable which package versions it was built with ?
12:27:23 <etpace> try debugging in GHCI to get your renameFile fn working atleast
12:27:28 <Demos> wait one sec, forgot to save after changing map to mapM
12:27:31 <Demos> deeeeeerppppp
12:27:31 <etpace> :p
12:28:00 <adu> derpa derpa
12:28:39 <geekosaur> sm: afaik you don't. (might be nice if building a package added a comment to the object file indicating the package version... portability might be an issue though)
12:32:00 <alcatraz63_> what exactly is the difference between shift and control? (del. cont.)
12:34:36 <sm> geekosaur: th
12:34:40 <sm> thanks
12:35:01 <enigmuriatic> is there any easy way to take a list with x parameters and convert it into a custom data type that has x fields?
12:36:01 <nooodl_> enigmuriatic:  \[a,b,c,d] -> Custom a b c d
12:36:17 <enigmuriatic> thanks nooodl_
12:36:25 <enigmuriatic> does that apply if i named the fields?
12:36:38 <nooodl_> sure
12:36:39 <enigmuriatic> using the { name :: String, age :: Int } format
12:36:39 <geekosaur> yes
12:36:42 <enigmuriatic> nice, thanks
12:36:54 <geekosaur> they're still positional like that, they just also have named accessors
12:37:29 <supki> > undefined & partsOf each .~ [1,2,3,4] :: (Int, Int, Int, Int)
12:37:31 <lambdabot>   (1,2,3,4)
12:39:18 <enigmuriatic> what happens if the length isn't four?
12:39:26 <monochrom> http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
12:39:26 <enigmuriatic> i'm trying to find a good place to catch the error
12:39:55 <FreeFull> > undefined & partsOf each .~ [1,2,3,4] :: (Int, Int, Int)
12:39:56 <lambdabot>   (1,2,3)
12:40:06 <FreeFull> > undefined & partsOf each .~ [1,2,3,4] :: (Int, Int, Int, Int, Int)
12:40:07 <lambdabot>   (1,2,3,4,*Exception: Prelude.undefined
12:40:53 <FreeFull> Maybe could use Maybe
12:41:18 <FreeFull> > Nothing & partsOf each .~ [Just 1] :: (Maybe Int, Maybe Int)
12:41:20 <lambdabot>   Couldn't match type `Data.Maybe.Maybe'
12:41:20 <lambdabot>                 with `(,) (Data.Mayb...
12:42:07 <FreeFull> > (Nothing, Nothing) & partsOf each .~ [Just 1] :: (Maybe Int, Maybe Int)
12:42:09 <lambdabot>   (Just 1,Nothing)
12:42:54 <nicks> Yeah, I'm having a pain in the ass time trying to install Gloss too - I think a virtualbox might be a good idea.
12:43:10 <FreeFull> > (Nothing, Nothing) & partsOf each .~ [Just 1] :: (Maybe Int, Maybe Int, Maybe Int)
12:43:12 <lambdabot>   Couldn't match type `(,)'
12:43:12 <lambdabot>                 with `(,,) (Data.Maybe.Maybe GHC....
12:44:34 <nicks> I keep having the same error as this guy: http://stackoverflow.com/questions/16005372/cabal-install-couldnt-read-cabal-file But I think it'd be just easier to simply do my ubuntu virtual box or whatever.
12:44:54 <nomeata> byorgey: hi. if you use conteq and find it useful, let me know. and also (and especially) if you have issues with it
12:45:55 <enigmuriatic> > filter (\x -> head x /= '#') ["hey man", "yo dude", "#this is a comment"]
12:45:56 <lambdabot>   ["hey man","yo dude"]
12:46:26 <nicks> Thanks for your help, and the reference to Gloss, guys. :)
12:46:29 <enigmuriatic> > map words ["hey man", "yo dude", "#this is a comment"]
12:46:31 <lambdabot>   [["hey","man"],["yo","dude"],["#this","is","a","comment"]]
12:47:06 <enigmuriatic> > map words . filter (\x -> head x /= '#') $ ["hey man", "yo dude", "#this is a comment"]
12:47:07 <lambdabot>   [["hey","man"],["yo","dude"]]
12:47:40 <nooodl_> enigmuriatic: might wanna /query lambdabot
12:47:52 <enigmuriatic> > map words . filter (\x -> head x /= '#') . filter (\x -> not $ null x) $ ["hey man", "yo dude", "#this is a comment"]
12:47:53 <lambdabot>   [["hey","man"],["yo","dude"]]
12:48:00 <enigmuriatic> nooodl_, what does that do?
12:48:14 <nooodl_> allow you to privately send commands to lambdabot so as to not flood #haskell with them
12:48:17 <enigmuriatic> i have essentially this exact same code in a function and it isnt working
12:48:23 <enigmuriatic> haha i guess you're right, sorry about that
12:48:32 <enigmuriatic> i guess i was implicitly seeking help :P
12:48:38 <enigmuriatic> but everything is working thus far
12:48:48 <byorgey> nomeata: thanks, I will!
12:49:36 <nooodl_> enigmuriatic: anyway, what kind of "isn't working" are you having trouble with?
12:49:50 <enigmuriatic> it's giving me a type error, nooodl_
12:50:05 <enigmuriatic> Couldn't match type `Char' with `[Char]'
12:50:55 <nooodl_> are you sure you're giving it the right kind of argument
12:51:04 <enigmuriatic> my function is: process str = map words . filter (\x -> head x /= '#') . filter (\x -> not $ null x) . lines $ str
12:51:17 <enigmuriatic> and i'm passing it a string (it's :: String -> [[String]])
12:51:43 <enigmuriatic> the type signature is correct
12:52:58 <nooodl_> strange
12:53:20 <enigmuriatic> i think i found the problem
12:53:48 <enigmuriatic> i was trying to store a string as an int in a function that called process and it somehow got passed down the line
12:54:01 <Demos> I may give up on using System.Directory to move files about and just system "mv bla"
12:54:16 <Demos> and on windows system "powershell -c \" mv bla \""
12:54:57 <Luke1> can someone help take a look at this: There's a StripeT monad transformer but it doesn't seem to have a MonadTrans instance: https://github.com/michaelschade/hs-stripe/blob/master/src/Web/Stripe/Client.hs#L142
12:55:13 <Luke1> I'm unclear about how I would make a MonadTrans instance for StripeT
12:56:31 <Philonous> Luke1:  I think you should be able to derive it with -XStandaloneDeriving and -XGeneralizedNewtypeDeriving
12:56:38 <Luke1> thanks
12:56:57 <elliott> I think GeneralizedNewtypeDeriving would do something unsafe there? not sure
12:57:00 <elliott> maybe not
12:57:12 <elliott> anyway it looks like it should have an instance, report a bug in the package?
12:57:14 <byorgey> why would it be unsafe?
12:57:28 <elliott> byorgey: I was thinking because it has two transformers nested. but I think I am confused
12:58:07 <byorgey> probably easier to just submit a pull request than submitting a bug =)
12:58:08 <Luke1> Philonous: no luck: "Can't make a derived instance of `MonadTrans StripeT' (even with cunning newtype deriving):  cannot eta-reduce the representation type enough In the newtype declaration for `StripeT'"
12:58:34 <byorgey> hmm, I thought deriving would work too
12:58:58 <Philonous> Luke1:  instance MonadTrans StripeT where lift = StripeT . lift . lift
12:58:59 <byorgey> in any case, it should just be  instance MonadTrans StripeT where lift = StripeT . lift . lift
12:59:11 <Luke1> haha ok thanks =D
12:59:46 <Luke1> just "deriving MonadTrans" should have done it right?
13:00:29 <Luke1> well that worked - thanks
13:00:32 <byorgey> deriving instance MonadTrans StripeT, yes
13:00:35 <Luke1> the lift. lift
13:02:21 <supki> someone should make a patch and add Applicative to deriving clause :[
13:02:51 <byorgey> that too.
13:02:53 <hpc> isn't it not possible to derive Applicative?
13:03:11 <hpc> (in general, that is)
13:03:17 <supki> in general no
13:03:33 <supki> for newtypes it should work though
13:03:41 <arkeet> isn't that what GeneralizedNewtypeDeriving is for
13:04:53 <Luke1> crap. now I need an instance for: "(Control.Monad.Trans.Control.MonadBaseControl IO (StripeT IO))"
13:04:58 <Luke1> this is getting out of hand
13:05:05 <Luke1> I'm I missing something at a higher level?
13:05:47 <Luke1> I'm trying to make getAccessToken in the StripeT monad so I can pull out the config: https://github.com/michaelschade/hs-stripe/blob/master/src/Web/Stripe/Connect.hs#L82
13:05:58 <Luke1> and it's missing all these crazy instances
13:06:19 <Luke1> am I doing something wrong or is this just expected?
13:06:58 <byorgey> that looks like a sensible instance to have
13:07:04 <byorgey> not sure how hard it is to write
13:11:01 <Luke1> haha
13:11:14 <Luke1> byorgey: I just wonder how many instances I'm going to have to write
13:11:24 <byorgey> Luke1: don't worry, probably only 10 or 12
13:11:29 <Luke1> I'm trying to use HTTP conduits + Stripe
13:11:32 <Luke1> haha
13:12:17 <Philonous> Luke1:  instance MonadBase b m => MonadBase b (StripeT m) where liftBase = StripT . lift . lift . liftBase
13:12:32 <Philonous> s/StripT/StripeT
13:12:42 <Luke1> haha Philonous thanks =)
13:13:00 <Luke1> I'm not trying to get you guys to write them all or anything. Just wondering if I'm heading in the general right direction
13:13:12 <Luke1> how are you figuring these out so fast though?
13:14:01 <Philonous> Luke1:  Practice
13:15:19 <Luke1> I guess I just take for granted that someone wrote all these instances
13:15:51 <Philonous> Luke1:  Oh, wait, I was looking at the wrong MonadBaseControl
13:17:41 <Luke1> What's weird to me is that this code does essentially the same thign: https://github.com/michaelschade/hs-stripe/blob/master/src/Web/Stripe/Client.hs#L239
13:18:00 <Luke1> how did that code get away without having all these instances?
13:27:48 <Philonous> Luke1:  IO has a MonadBasControl instance
13:27:56 <Philonous> Base*
13:28:21 <Luke1> I was just thinking that. I think the problem was I was trying to take the function from StripeT IO... to StripeT m where (MonadIO m) =>
13:28:31 <Luke1> so I was losing all the IO instances that I was using
13:28:37 <Philonous> Luke1:  Btw. the documentation page for MonadBaseControl has a snippet with a default instance. http://hackage.haskell.org/packages/archive/monad-control/0.3.1/doc/html/Control-Monad-Trans-Control.html#t:RunInBase
13:29:20 <Luke1> that's some complex code =D
13:29:25 <Luke1> pretty abstract
13:40:57 <Luke1> well my brain is fried for the moment. Thanks for your help Philonous and byorgey
13:41:33 <Philonous> Luke1:  I'm banging my head at MonadBaseControl, trying to figure out what it's trying to accomplish
13:47:56 <Luke1> yeah same here
13:49:14 <Luke1> I guess if I hardcode (MonadIO m) to just IO, then the liftBase is just liftIO because IO is the base
13:52:15 <Philonous> I think liftBase of a MonadIO monad should always be liftIO
13:55:48 <Philonous> Btw. I would be surprised if the example code given on the haddock page worked. It seems to be missing MonadTransControl constraints
13:56:40 <Philonous> Oh, never mind, the constraints are on the base monad
14:13:12 <gelisam> I see that the room topic mentions threadDelay. I have a question about that method
14:13:48 <mauke> it's in microseconds
14:14:05 <gelisam> yes, I know
14:14:40 <FreeFull> What's the question?
14:14:42 <enigmuriatic> what happens if the lambda i pass to map isn't exhaustive
14:14:55 <gelisam> the doc mentions that I should use threadDelay instead of usleep, because of threading issues. I only have a single thread, yet my program  hung when I used usleep, and the hang was fixed when I used threadDelay
14:14:55 <arkeet> "exhaustive"?
14:15:00 <enigmuriatic> for example, if it pattern matches to a list of length 4 (the length could be less than four)
14:15:03 <gelisam> my question is: why?
14:15:05 <glguy> > map (\Nothing -> ()) [Just True]
14:15:06 <lambdabot>   [*Exception: <interactive>:3:6-19: Non-exhaustive patterns in lambda
14:15:10 <arkeet> gelisam: haskell threads are not OS threads.
14:15:16 <glguy> You get an asynchronous exception
14:15:43 <FreeFull> glguy: I think ghc will warn on compile
14:15:48 <FreeFull> Lemme test
14:16:03 <gelisam> arkeet: I wasn't using any kind of threading, it was a simple IO loop
14:16:33 <arkeet> there is threading behind the scenes then.
14:16:54 <arkeet> hmm
14:17:01 <arkeet> I'll stop talking.
14:17:05 <gelisam> does IO do threading when printing?
14:17:12 <FreeFull> Oh, it doesn't warn on compile
14:17:21 <FreeFull> At least not by default
14:17:43 <arkeet> non-exhaustive pattern matches don't warn by default.
14:18:22 <shachaf> Asynchronous exception?
14:19:30 <FreeFull> Even with -Wall it doesn't warn about that
14:20:44 <enigmuriatic> gelisam, i'm parsing some data and every subarray should have length four, but might not if something goes wrong
14:21:33 <enigmuriatic> also, how do i divide two Ints and get a Double?
14:21:49 <gelisam> er, I'm the one who asked about the threads, not the non-exaustive lambdas.
14:22:20 <Philonous> > let x = 4 :: Integer in (fromIntegral x) / (fromIntegral x) :: Double
14:22:21 <lambdabot>   1.0
14:23:19 <glguy> shachaf: imprecise exceptions
14:23:23 <FreeFull> fromIntegral will work for Int and other similar types too
14:25:17 <gelisam> I'll try to reproduce the hang on a shorter piece of code.
14:25:33 <shachaf> Why do you want to use usleep?
14:26:16 <gelisam> I don't; threadDelay works fine, I'm just trying to understand why I get a hang even though I don't use threads.
14:27:20 <enigmuriatic> percentage xs pattern = (fromIntegral length . filter (\x -> genotype x == pattern) $ xs) / (fromIntegral . length $ xs) :: Double
14:27:27 <enigmuriatic> why can't haskell infer the type of that?
14:27:45 <enigmuriatic> i would think i would need the binding at the end regardless, as the function definition says it returns a Double
14:28:47 <elliott> "fromIntegral length" is wrong
14:29:17 <enigmuriatic> oh, i need a dot
14:29:20 <adnap> What is the simplest way to install your own modules for use in various projects?
14:29:49 <enigmuriatic> it compiled. the question is, is the answer accurate?
14:29:55 <adnap> Should I create cabal packages for them and cabal install them?
14:30:29 <gelisam> adnap: that would work, if you want to install them locally.
14:30:39 <adnap> gelisam: I do. Is that the simplest way?
14:30:50 <adnap> (It doesn't seem so simple to me)
14:31:06 <gelisam> it's easier than it looks
14:31:57 <gelisam> you could also just copy your code into all your projects.
14:32:06 <adnap> gelisam: I did that and it was a mistake
14:32:50 <adnap> gelisam: What happens is that one copy gets a bunch of changes, and then I want to merge those changes into other repos, and I don't know how
14:33:40 <adnap> Wouldn't it make more sense to keep a separate repo for the module and have other projects refer to it?
14:33:59 <adnap> (the module)
14:34:31 <arkeet> cabal is easy.
14:35:12 <aristid> not as easy as monoids.
14:36:22 <adnap> I have used cabal to make packages before, but not enough to not forget how
14:36:25 <gelisam> anyway, here's a minimal code sample exhibiting the hang I encountered earlier. where is the threading?
14:36:33 <gelisam> main = forM_ [0..] $ \i -> do
14:36:33 <gelisam>          usleep 100000
14:36:33 <gelisam>          print i
14:36:58 <adnap> I know there's like a command than runs a sort of "wizard" that does almost everything
14:38:09 <elliott> cabal init
14:39:31 <adnap> elliott: Thanks
14:39:52 <adnap> Is there a tool that removes, or at least notifies of, unnecessary imports in source files?
14:39:59 <elliott> -Wall notifies
14:40:05 <adnap> elliott: Thanks :)
14:40:19 * adnap adds to Makefile
14:40:40 <arkeet> gelisam: and if you compile with -threaded?
14:41:28 <gelisam> arkeet: also hangs
14:42:31 <arkeet> oh, so it doesn't even print anything.
14:43:08 <gelisam> sometimes it does. the hang is non-deterministic, so sometimes it hangs before printing anything, sometimes it hangs after ~50 entries
14:43:13 <arkeet> http://hackage.haskell.org/trac/ghc/ticket/1156
14:43:23 <arkeet> maybe relevant?
14:44:20 <arkeet> also #850
14:44:31 <arkeet> explains it further
14:44:36 <arkeet> but
14:44:42 <arkeet> that's a fixed bug. hm
14:45:27 <gelisam> maybe I stumbled upon a new edge case of that bug, then!
14:45:50 <FreeFull> The solution seems to be "use nanosleep, not usleep"
14:46:26 <FreeFull> Although I'd just use threadDelay
14:48:33 <gelisam> (sorry, my IRC client logs me out all the time for some reason)
14:49:50 <gelisam> using threadDelay fixes the hang, but nanosleep doesn't
14:51:52 <gelisam> I guess I'll report this as a bug, then.
15:02:05 <int80_h> http://hpaste.org/88568
15:07:57 <Rarrikins> Is there an ETA for getting `apt-get install haskell-platform` working on Ubuntu 13.04?
15:08:09 <Rarrikins> Or is ghc the proper package?
15:08:24 <hpc> what isn't working?
15:08:51 <Rarrikins> It can't find the package.
15:09:02 <Rarrikins> It's not in the raring repositories or whatever they're called.
15:09:15 <Rarrikins> (the haskell-platform package)
15:09:21 <hpc> that's odd
15:09:24 <hpc> i see it fine on debian
15:09:28 <hpc> did you apt-get update?
15:09:36 <FreeFull> You could just install ghc and other haskell packages
15:09:57 <FreeFull> You'll probably get newer versions than what's in the platform
15:09:57 <hpc> or given that it's ubuntu, and their track record for updates
15:10:01 <Rarrikins> Yeah, apt-get update didn't help.
15:10:05 <hpc> you should install ghc from apt, and use cabal for the rest
15:10:12 <Rarrikins> http://packages.ubuntu.com/search?keywords=haskell-platform says the latest thing it was in was quantal.
15:10:18 <Rarrikins> OK, I'll do that.
15:10:23 <alcatraz63_> ghc is version 7.6, so no platform
15:12:51 <Rarrikins> Yay, now I can do data statements in ghci.
15:13:54 <danharaj> does anyone know how to put promoted data kinds in export lists without their unpromoted data?
15:14:02 <FreeFull> ghc 7.6 is nice to have
15:14:45 <johnw> FreeFull: what do you like most about it?
15:15:38 <FreeFull> I know that any feature I might want will be there, unless it's super-experimental and only in the dev version
15:16:28 <FreeFull> I never used any non 7.6 version so I don't know the differences between 7.6 and the older ones
15:18:20 <quchen> ... so you meant to say GHC is nice to have
15:18:53 <quchen> For reference, here's the changelog. http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/release-7-6-1.html
15:19:12 <johnw> the only feature differences I really ran into were LambdaCase and MultiWayIf, which I do miss from time to time (I'm using 7.4.2)
15:20:01 <quchen> Hm. I kind of find adding the LambdaCase extension more annoying than writing \x -> case x of ...
15:20:20 <johnw> quchen: I write a lot of this: for mfoo $ \foo -> case foo of ...
15:20:33 <quchen> So do I
15:20:37 <johnw> better: for mfoo $ \case ...
15:20:56 <quchen> I just meant to say that LambdaCase is neat but not really important
15:20:58 <quchen> ... to me
15:21:01 <johnw> ah, yes
15:21:07 <johnw> i only miss the convenience
15:21:12 <enigmuriatic> mapM_ doesn't use the stack while mapM does, right?
15:21:19 <quchen> If it was made part of Haskell and I didn't have to add the extension, then yes, I'd like that
15:21:28 <johnw> mapM_ is a fold
15:21:38 <monochrom> that depends
15:21:45 <johnw> well, it can be a fold
15:21:59 <johnw> @src mapM_
15:21:59 <lambdabot> mapM_ f as = sequence_ (map f as)
15:22:04 <johnw> yeah, not there it isn't
15:22:04 <monochrom> I mean which uses stack, don't worry :)
15:22:06 <quchen> johnw: I guess the next larger thing I'm looking forward to is holes
15:22:19 <johnw> quchen: yes, definitely me too
15:22:22 <shachaf> Just use ImplicitParams.
15:22:27 <enigmuriatic> because i'm processing a list of length 960,613 and mapM caused a stack overflow while mapM didn't
15:22:36 <shachaf> It's better than holes as available last time I checked HEAD.
15:22:47 <johnw> shachaf: I'll have to try that
15:22:51 <quchen> shachaf: Oh. I thought holes in HEAD would also hint what's in scope that I could use
15:22:57 <shachaf> Admittedly holes have been improved since then.
15:23:04 <monoidal> quchen: they do
15:23:23 <quchen> shachaf: Right now I'm pretty much used to adding "data Hole = Hole" to every module at some point. It makes me feel dirty
15:23:34 <monoidal> quchen: (however, sometimes too little. For example, if you have a hole needing "a" and you have "b" and "b -> a" in scope, it will show only the second one.)
15:23:44 <shachaf> So use ?hole instead.
15:23:52 <shachaf> Or ()
15:25:09 <quchen> The update to setNumCapabilities is nice as well.
15:25:43 <quchen> Without that concurrency was always a bit like gambling: will I use my CPU while the program is running otherwise?
15:26:26 <elliott> you could always set the # of capabilities with +RTS -N<number> before
15:26:41 <quchen> elliott: Yes, but only at launch
15:27:03 <quchen> Now you can be like "oh pardon the intrusion, you need this CPU, yes please go ahead" ;-)
15:27:15 <johnw> 7.4.2 has setNumCapabilities
15:27:20 <johnw> what was the 7.6 change?
15:27:31 <quchen> johnw: You can now decrease the number
15:27:33 <johnw> ahh
15:27:36 <quchen> In 7.4 you could only increase it
15:28:19 <monochrom> GHC 8 will allow fractional number of capabilities. GHC 9 will allow complex numbers. :)
15:28:34 <johnw> in GHC 10 I can specify infinity
15:28:34 <quchen> No hyperreals? :-C
15:28:42 <geekosaur> quaternions
15:28:53 <Adeon> octionions
15:28:53 <monochrom> that will come too. the future is bright!
15:28:59 <Adeon> octonions*
15:29:09 <Rarrikins> oct-onions
15:29:14 <Hafydd> :)
15:29:29 <quchen> I'm sure all you said is already implemented in acme-php
15:29:43 <monochrom> haha
15:30:51 <quchen> I'm also looking forward to the ARM change in 7.8.
15:30:56 <quchen> And so is my RasPi.
15:31:56 <quchen> But most importantly, hopefully the inclusion of the first step towards the AMP :-)
15:32:59 <fosskers> quchen: ARM change?
15:33:28 <quchen> fosskers: As far as I know, ARM will be properly supported in 7.8. Right now it relies on LLVM.
15:33:36 <fosskers> ah
15:33:51 <fosskers> well my haskell project would like to be on arm :)
15:34:01 <quchen> I think TH isn't working properly in 7.6 for example. (I'm using 7.4 where it does not work for sure, and neither does GHCi.)
15:34:37 <quchen> fosskers: Well, you can already compile stuff on the RasPi with Haskell.
15:34:45 <quchen> It's not fully un-supported either
15:35:09 <fosskers> so long as the OS has a ghc package eh?
15:36:24 <quchen> Haven't tried compiling GHC on the Raspi yet.
15:36:37 <quchen> I imagine it's not a pleasant experience.
15:36:56 <fosskers> I think recently they upgraded the ArchLinuxARM ghc package to 7.6
15:37:09 <quchen> Well, I'm on Raspbian ...
15:37:32 <quchen> I do wonder how they create those packages though.
15:37:34 <fosskers> is it any good?
15:37:45 <fosskers> cross compiling?
15:37:59 <fosskers> cause compiling on the RPi takes like 900 years
15:38:13 <quchen> Maybe. I don't know.
15:38:19 <quchen> Compiling on the Raspi isn't that slow to be honest.
15:38:24 <quchen> I mean it is slow, but not mindblowingly so
15:38:45 <fosskers> I compiled fish shell in not *that* long, i guess
15:38:59 <fosskers> i haven't touched my pi in a while though
15:39:07 <fosskers> thinking about turning it into a bittorrent sync machine
15:39:20 <quchen> What's that?
15:39:25 <fosskers> BitTorrent Sync
15:39:31 <quchen> Yes.
15:39:41 <fosskers> it's basically dropbox without the middle man
15:39:58 <fosskers> encrypted file syncing
15:40:04 <quchen> You mean the Raspi is the middle man, instead of Dropbox servers
15:40:29 <fosskers> it uses the bittorrent protocol to sync files between different machines
15:40:44 <johnw> i tried btsync
15:40:50 <fosskers> any good?
15:40:51 <johnw> at least on the Mac, it crashes too often
15:41:07 <johnw> i couldn't get it to ever finish indexing the folders I wanted to sync
15:41:11 <johnw> i'll wait a few revs
15:41:16 <fosskers> it's still pretty new
15:42:03 <fosskers> johnw: it seems like you're always on
15:42:14 <johnw> if my heart stops beating, I die
15:42:17 <quchen> Maybe he uses his Raspi as a BNC :-)
15:43:19 <fosskers> johnw: good thing I'm an android and don't have to worry about that
15:50:09 <danharaj> edwardk: Is there a formulaic way of building something like a free monad (i.e. trees with free variables) for mutually recursive trees?
15:50:52 <scp> Anyone here use ghc on ubuntu?
15:51:06 <quchen> Yes.
15:51:11 <edwardk> danharaj: 'its complicated'
15:51:40 <scp> quchen: You just install ghc and cabal-install, then use cabal to get haskell packages?
15:51:56 <danharaj> edwardk: 'My dating life' complicated or 'climbing a mountain' complicated :)
15:52:19 <quchen> scp: What I did was download the GHC binaries from the page. I don't like to trust OS repos for compiler stuff.
15:52:47 <scp> quchen: Hmm, probably smart. Especially w/ ubuntu, send my haskell source to amazon =P
15:52:54 <edwardk> well, i've done the cofree version of it to get annotations in syntax trees with mutually recursive type for statements and expressions and whatnot. i just didn't like the result
15:53:07 <johnw> danharaj: maybe: taking the fixed-points of adjoint functors complicated? :)
15:53:07 <quchen> scp: But I guess that if you just install a package for the Platform, and GHC will come automatically as a dependency
15:53:12 <edwardk> i'm being deliberately vague in the hopes you find a better local optimum than i did ;)
15:54:28 <danharaj> edwardk: I'll try not to let you down :P. My first idea is to index variables by which tree they expect.
15:55:35 <monochrom> http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
16:03:12 <hrookie> I'm tampering with openGL bindings. In those bindings, the type GLFloat is a type synonym for a CFloat. I'd like to build a float into a GLFloat. What's the best way to do this? Using the C Type CFloat constructor doesn't type check.
16:05:04 <arkeet> hrookie: what do you mean? that works for me.
16:05:12 <arkeet> care to paste your code and error message?
16:05:29 <Peaker> hrookie, typically, realToFrac
16:05:42 <Peaker> it's the equivalent of fromIntegral, for Fractionals
16:05:53 <arkeet> isn't realToFrac slower? since it has to go through Rational
16:06:18 <arkeet> wait
16:06:22 <arkeet> there's a RULES thing.
16:06:26 <Peaker> I think there are supposed to be rewrite rules, yeah
16:06:27 <arkeet> ok, use realTofrac
16:06:33 <arkeet> "realToFrac/a->CFloat"    realToFrac = \x -> CFloat   (realToFrac x)
16:06:48 <hrookie> that's what i gathered. i actually found something even better that worked -- i just made my own "fromFloat :: Float -> GLfloat" function, where fromFloat x = x
16:06:58 <arkeet> that shouldn't typecheck.
16:07:03 <hrookie> arkeet: lol
16:07:05 <hrookie> arkeet: yeah.
16:07:20 <arkeet> which OpenGL version are you using?
16:07:46 <hrookie> oh wait, wtf, okay, yeah, now it's not working. i mixed up my dependencies in my cabal file :D
16:07:57 <hrookie> OpenGL 2.2
16:08:01 <monochrom> this question looks less and less rossy.
16:08:06 <monochrom> err, rosy.
16:08:24 <arkeet> hrookie: right, in there one has type GLfloat = Float
16:08:34 <arkeet> newer versions use CFloat
16:08:56 <arkeet> 2.2 is from 2009
16:09:11 <hrookie> arkeet: hrum dee, wonder why cabal grabbed me that one
16:09:23 <arkeet> it is a mystery
16:09:39 <Peaker> hrookie, you can add a command line option to cabal: "--constraint OpenGL == sane_ver"
16:09:52 <Peaker> hrookie, and it will tell you the reason not to.. with -v, more useful info about it
16:11:05 <hrookie> (so is realToFrac the way to go here? fromFloat x = realToFrac x, effectively?)
16:11:16 <hrookie> Peaker: typing that on the command line or editing ~/.cabal/config?
16:11:25 <Peaker> hrookie, on the cmdline
16:12:55 <hrookie> Peaker: hrum, doesn't appear to be working >.>
16:13:28 <Peaker> hrookie, it's not supposed to "work", but to tell you what is wrong
16:13:37 <Peaker> (i.e: which package is demanding the ancient OpenGL version)
16:14:38 <hrookie> Peaker: unrecognised command: OpenGL == sane_ver (try --help)
16:14:56 <Peaker> hrookie, --constraint "OpenGL == ..."
16:18:03 <hrookie> it's rather unhelpful. i'm installing 2.8 manually now, i'll see what i get
16:20:03 <hrookie> also, best practices on package upgrades in cabal? cabal upgrade is apparently gone because people would get lossa broken packages >.>
16:21:31 <blackdog> hrookie: delete .cabal and .ghc. turn your computer off. throw it into a volcano. provoke nuclear apocalypse. reboot a new technical civilisation based on strontium. then, download new packages and cross your fingers.
16:22:12 <hrookie> blackdog: i like your style. but, why strontium?
16:22:43 <blackdog> hrookie: because my chemistry/physics is very poor and it sounded cool :)
16:23:16 <hrookie> so, for whatever reason, just throwing 2.8 and cabal init-ing my directory again gives me latest >.>
16:25:26 <hrookie> and blackdog: =D
16:27:43 <hrookie> blackdog: to be honest i just felt like asking about strontium, i really know nothing about physics at all
16:27:54 <blackdog> hrookie: *grin*
16:28:04 <blackdog> hrookie: so, a more serious answer
16:28:27 <blackdog> upgrade is a bit of a quagmire - one option is to just use cabal-dev or virthualenv everywhere
16:29:02 <blackdog> and then, any time you want to upgrade a package, you can just cabal-dev install it again
16:29:28 <Radsr> nnection reset by p
16:29:36 <Radsr>  ^ÂÊÎÔÛâêîôûĈĉĜĝĤĥĴĵŜŝŴŵŶŷˆ̭̂᷍ḒḓḘḙḼḽṊṋṰṱṶṷẐẑẤấẦầẨẩẪẫẬậẾếỀềỂểỄễỆệỐốỒồỔổỖỗỘộ⨣⨶⩯ꞈ＾󠁞
16:40:51 <Peaker> one cute consequence of having explicit type variable instantiation ala System F, is that if you want an explicit type annotation, you just use: "id Type" on your expression
16:41:17 <hrookie> System F?
16:42:05 <Peaker> The "polymorphic lambda calculus"
16:43:11 <quchen> Peaker: Explicit type variable instantiation?
16:43:20 <piezoid> \join #yesod
16:43:29 <piezoid> sorry :/
16:43:54 <Peaker> i.e:   id :: (a::*) -> a -> a ; id t (x:t) = x
16:44:01 <dmwit> quchen: You know how "forall"s in Haskell are automatically turned into monomorphic things by unification?
16:44:04 <dmwit> Well, you don't get that.
16:44:31 <dmwit> e.g. instead of "map (+1)" you get to write "map Int Int (+ Int 1)"
16:44:34 <dmwit> thaaaank goodness
16:44:41 <dmwit> (It actually *is* quite useful in some cases.)
16:45:09 <dmwit> (But it's also a *lot* more boilerplate if you don't have good tool support.)
16:45:26 <quchen> I think I got roughly half of that.
16:45:27 <Peaker> dmwit, our IDE hides all those Ints
16:45:38 <Peaker> dmwit, unless you press return on the expression to expand them (and then you can edit them too)
16:45:48 <dmwit> quchen: Right, so "map :: (a -> b) -> [a] -> [b]", right?
16:45:55 <quchen> Yes.
16:46:03 <dmwit> quchen: And then when you write "map (+1)" it infers that "a ~ Int" and "b ~ Int".
16:46:10 <quchen> Yes.
16:46:14 <dmwit> quchen: You don't get that.
16:46:22 <dmwit> You have to write what "a" and "b" should be manually.
16:46:53 <dmwit> Or rather, you're allowed to write what "a" and "b" should be manually, and you hope to goodness the guy writing your compiler figured out heuristics that guess the right choice for you most of the time so you don't have to add all that information to your source.
16:47:36 <dmwit> (This is actually the strategy GHC uses. Its core language has explicit type instantiation, and you can see it with -ddump-simpl.)
16:47:38 <quchen> That doesn't sound very convenient. Like manually typed lambda calculus.
16:47:47 <Peaker> dmwit, we have a type inference engine that infers the right choice much like Haskell does, but lets you override it
16:48:08 <Peaker> dmwit, it's not a heuristic any more than Haskell's type inference is (the only heuristic is assuming Rank1)
16:48:30 <dmwit> If it can be wrong, it's a heuristic. =)
16:48:45 <dmwit> And yes, in the presence of higher-rank types, both GHC's type inference and yours can be wrong.
16:48:52 <Peaker> Well, there's no real difference between inferring the value of the type variables to be passed, and what Haskell does
16:48:56 <dmwit> And yes, I understand that you're saying it gets it right almost all the time, and for that I'm very happy.
16:49:03 <Philippa> GHC's type inference can also be wrong if you want a more specific type
16:49:05 <dmwit> Yes, I know it's no different.
16:49:09 <dmwit> I'm not saying it's different.
16:49:22 <Peaker> dmwit, ah, I thought that was implied by "hope to goodness the guy writing your compiler figured out .."
16:49:22 <Nisstyre> Philippa: it's supposed to give you the principal type though
16:50:14 <Philippa> quchen: there are circumstances where explicit typing is actively desirable. Many of them aren't for code written by humans, sure
16:50:35 <Peaker> quchen, writing expanded SystemF directly is not convenient. You have to automatically wrap stuff with type lambdas and auto-pass the type-args -- either at the compiler level, or at the UI level.  We choose the latter (I think that's a novel idea, but I'm not sure)
16:50:36 * Philippa still wants typing debuggers, though
16:50:38 <dmwit> quchen: http://hpaste.org/88573 <- take a look at the @ signs
16:50:53 <dmwit> quchen: Those are explicit type applications, where a polymorphic thing is instantiated to a monomorphic type.
16:50:56 <danharaj> edwardk: This is my attempt at doing it by hand. I think I see a way to generalize this approach, but if you have something to say I would like to hear it :) http://hpaste.org/88572
16:51:38 <quchen> dmwit: Oh wait, Core is System F?
16:51:48 <dmwit> quchen: System F plus a few extra features, yes.
16:51:50 <danharaj> Core is System FC{up arrow}
16:51:55 <danharaj> (and maybe some other stuff)
16:52:18 <quchen> dmwit: Oh. I always assumed Core is a few stages before System F and Cmm and whatever magic GHC uses.
16:52:50 <Philippa> Core is part of the magic GHC uses
16:53:02 <Philippa> (System F predates Haskell by some time)
16:53:32 <dmwit> GHC actually does rather a lot of legwork to hide type applications for you.
16:53:54 <dmwit> floating foralls and reordering them and eliminating unused variables and...
16:53:55 <dmwit> phew
16:54:05 <quchen> So in Core there's generally no polymorphism left then?
16:54:17 <dmwit> The polymorphism is still there.
16:54:26 <dmwit> Terms like map are still polymorphic.
16:54:31 <quchen> Ah right.
16:54:36 <dmwit> They're just functions from types to monomorphic things.
16:54:56 <quchen> Like the lambda in "(\x -> x) 1" can still take any number.
16:55:02 <dmwit> right
16:55:04 <quchen> It's applied to 1, but still fully general.
16:55:08 <quchen> I see.
16:55:34 <monochrom> all types are explicit. no inference.
16:55:50 <quchen> So the inference is what leads to Core.
16:56:08 <Peaker> monochrom, in lamdu we have explicit type applications/lambdas, and the inference simply infers the values to put in the applications
16:56:29 <Peaker> (and the UI collapses the lambdas/applications of type params)
16:56:39 <dmwit> quchen: right
16:56:50 <Peaker> (so we have both explicit types + inference)
16:57:44 <quchen> dmwit: When Core is System F, what's Haskell? HM?
16:57:53 <Peaker> Maybe we ought to even put <> brackets around all of them, to make it familiar to lesser language programmers
16:58:01 <Peaker> (and they're hidden most of the time anyway)
16:58:04 <quchen> Or is HM just something that sounds right in my head here but belongs to an entirely different place :s
16:58:14 <danharaj> Haskell is sugar.
16:58:40 <no-n> isn't everything but machine code sugar
16:58:45 <quchen> For ASM. Which is sugar for electronics. Which is sugar for reductionism is rarely fruitful.
16:58:46 <Peaker> quchen, HM is the inference logic on top of System F to automate the generation of the type variable lambda wrappers and applications
16:59:11 <Peaker> (well, originally, Haskell extends on HM quite a bit)
16:59:18 <no-n> HM?
16:59:20 <quchen> Peaker: Ah, so it's not its own type system per se then?
16:59:25 <geekosaur> Jindley-Milner
16:59:33 <geekosaur> er
16:59:35 <geekosaur> Hindley...
16:59:38 <quchen> Peaker: Is it more like the inferrable subset of System F or something?
16:59:46 * geekosaur apparently can't type
17:00:07 <Peaker> https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner says "HindleyMilner (HM) is a classical type inference method with parametric polymorphism for the lambda calculus"
17:00:43 <Peaker> quchen, http://augustss.blogspot.co.il/2007/10/simpler-easier-in-recent-paper-simply.html <-- awesome blog post about this subject by Augustutsson
17:00:53 <Philippa> HM is entirely its own system
17:00:54 <aristid> Peaker: heh i was briefly thinking "why is hindley milner trade-marked?!"
17:01:04 <Philippa> amongst other things, IIRC it predates System F
17:01:18 <quchen> Peaker: Thanks!
17:01:26 <Philippa> the fact HM's types and type schema have System F representations is helpful, of course
17:06:06 <monochrom> have you seen my newly written http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml ?
17:07:38 <elliott> now I have
17:08:00 <danharaj> monochrom: are you serious about cabal not doing -O2 by default :|
17:08:04 <danharaj> that makes me sad.
17:08:19 <elliott> it's deliberate.
17:08:35 <elliott> IIRC it used to do -O2 and was changed to -O because -O2 was too slow for not enough benefit
17:08:40 <danharaj> elliott: is pretending the switch is a bool deliberate too? :P
17:09:52 <monochrom> I am serious. and it made sense a long time ago. GHC user's guide recommends -O but not -O2. well it still does but people suspect that it's outdated.
17:10:39 <monochrom> I also think a long time ago the .cabal/config setting was a boolean, but I have not actually checked history or source code.
17:11:16 <monochrom> anyway now you know you have a choice! :)
17:11:47 <danharaj> monochrom++
17:12:23 <monochrom> I only knew when I was looking at the source code for something else, then stumbled over the "optimization: ..." part and "wait, what? you accept 0 1 2?!"
17:13:44 <danharaj> Troolean
17:14:24 <Tene> I think I must be misunderstanding cabal-dev somehow.  From a clean environment, I install the latest cabal-install and cabal-dev with 'cabal install', then from an empty directory 'cabal-dev install vty', which after installing dependencies fails due to not being able ot find those dependencies.  If I install the dependencies globally with 'cabal install', it works fine.
17:15:45 <johnw> Tene: what is the exact sequence of commands you are using?
17:15:54 <johnw> once you use cabal-dev, you always need to use cabal-dev
17:16:40 <Tene> johnw: cabal install cabal-install; cabal install cabal-dev; mkdir test; cd test; cabal-dev install vty
17:16:52 <johnw> right, that should work
17:17:24 <monochrom> Tene is saying that "cabal-dev install vty" installs some packages and then reports can it can't find those packages.
17:17:43 <monochrom> s/reports can it/reports that it/
17:17:55 <johnw> hmm...
17:18:02 <johnw> this sounds oddly familiar
17:18:02 <Tene> Yes, exactly.  It installs terminfo, string-11, and utf8-string, then while working on vty, fails with: <command line>: cannot satisfy -package-id terminfo-0.3.2.5-4d1c81be8d263b97c08424418c50ad5a
17:19:17 <Tene> I eventually tried installing terminfo globally with 'cabal install terminfo', and now 'cabal-dev install vty' fails in the same way but on utf8-string.
17:19:27 <yitz> Tene: that usually means that some packages had insufficient dep bounds, usually because of not following PVP. then cabal makes an unfortunate early choice of a dep version, and later gets confused.
17:20:14 <yitz> Tene: usually you can find out where the problem is by running cabal-dev install again. this time, only the first one that failed will try to build, and will fail again.
17:20:30 <yitz> Tene: work back from there and figure out where the missing bounds are.
17:21:17 <yitz> Tene: johnw is right. once you start installing things globablly at all, cabal-dev becomes less useful. you no longer really have control over dep versions.
17:21:51 <Tene> When I try 'cabal-dev install vty', it now starts with trying to build vty.  Trying 'cabal-dev install terminfo' or any of the other dependencies just tells me that they're already installed.
17:21:58 <yitz> Tene: if you want to use cabal-dev - which is what i do and recommend - you might want to re-install ghc/hp, which isn't as bad as it sounds.
17:22:28 <Tene> yitz: Yes, that's what I expected.  'ghc-pkg unregister terminfo' gets me back to the same failure as before.
17:22:35 <yitz> ok
17:23:22 <Tene> I don't understand what you're saying about dependency boundaries and PVP, so I don't know if that's what you were recommending I try installing or not.
17:23:34 <yitz> so try putting a dep on the correct version of terminfo in your cabal file. then you can figure out what to do about the utf8-string problem.
17:24:06 <Tene> I don't yet have a cabal file; this is in an empty directory.  I'll make one.
17:24:12 <yitz> Tene: i just mean that you can solve these kinds of problems by constraining the versions of deps
17:24:39 <yitz> Tene: sometimes you have to add indirect deps into your own cabal file to do that.
17:25:18 <yitz> Tene: also, the order that the packages get installed is significant, yet you don't have total control over that with a single cabal-dev install command.
17:26:00 <yitz> Tene: so sometimes you have to cabal-dev install <dep> for some of the individual deps before you say just cabal-dev install
17:27:04 <Tene> I added 'terminfo == 0.3.*' to build-depends, and get the same failure: <command line>: cannot satisfy -package-id terminfo-0.3.2.5-4d1c81be8d263b97c08424418c50ad5a
17:27:31 <yitz> Tene: if you have a large number of deps, this can be very time-consuming.
17:27:45 <yitz> Tene: rm -r cabal-dev and start again
17:28:04 <Tene> Okay.
17:28:55 <Tene> Can you confirm that I'm not doing anything conceptually wrong here, and this would normally be expected to work?
17:28:59 <monochrom> do you really start clean? "ghc-pkg list --user" should output almost nothing
17:29:09 <yitz> Tene: when you have to do this for a package with, say, 100 indirect deps, you begin to really get a feel for how big 100! is.
17:30:10 <Tene> monochrom: That only lists Cabal, setenv, and tar.
17:30:35 <monochrom> they may live then.
17:31:06 <yitz> monochrom: nice, thanks! finding out the secret syntax for installed constraints is really helpful.
17:31:18 <Tene> yitz: Same failure after removing ./cabal-dev
17:31:35 <yitz> monochrom: now we just need to know the syntax for that constraint in cobol.
17:32:13 <yitz> Tene: what version of terminfo do you think you actually need?
17:33:01 <Tene> yitz: vty specifies >= 0.3 && < 0.4
17:34:37 <yitz> Tene: what ghc are you using? do you have haskell platform installed?
17:34:52 <yitz> Tene: are you just trying to install vty, or something that depends on it?
17:36:25 <Tene> yitz: ghc 7.4.2; I have haskell-platform installed from my distro's package manager (fedora).  I'm just trying to install vty.
17:36:35 <Tene> I've done very little with haskell before this.
17:38:43 <yitz> Tene: i'm not on fedora, but i just did cabal-dev install vty with pretty much the same setup and it worked fine
17:39:28 <Tene> I did change a couple of lines in my ~/.cabal/config
17:39:31 <Tene> library-profiling: True
17:39:31 <Tene> shared: True
17:39:49 <yitz> Tene: hmm, but i haven't done a cabal update in a while. i'd rather not do that just now.
17:40:02 <yitz> Tene: that should all be ok
17:41:36 <Tene> Huh.  If I remove those from ~/.cabal/config and cabal-dev/cabal.config and try again, it runs just fine.
17:41:44 <yitz> Tene: what happends if you rm -r cabal-dev and then cabal-dev install terminfo?
17:41:59 <yitz> Tene: oh, really? weird.
17:42:06 <Tene> Let's find out which it was
17:43:29 <Tene> yitz: do you have either of those enabled?
17:44:07 <yitz> no
17:44:38 <yitz> Tene: i found this. it is very old though, a lot has changed in cabal-dev since then: https://github.com/creswick/cabal-dev/issues/7
17:44:54 <yitz> Tene: but maybe that's it
17:46:54 <yitz> Tene: is shared important for you?
17:48:02 <yitz> Tene: could you add a comment to that bug to vote for it?
17:48:48 <Tene> yitz: The first time I tried this, everything installed okay, but then 'cabal-dev ghci' complained that it couldn't find a .so, so I trashed everything and started over with --enable-shared.  I'm trying to reproduce it now.
17:51:42 <yitz> Tene: which .so couldn't it find?
17:51:57 <Tene> I don't remember; that's why I wish I had taken notes.
17:53:13 <yitz> Tene: yeah i know the feeling
17:53:25 <Tene> Ahh, found it in my scrollback: Loading package terminfo-0.3.2.5 ... <command line>: can't load .so/.DLL for: libHSterminfo-0.3.2.5.so (libHSterminfo-0.3.2.5.so: cannot open shared object file: No such file or directory)
17:56:13 <yitz> Tene: the terminfo cabal file says it binds to the curses library. not clear from there exactly what it needs, because it uses a non-standard build via automake.
17:57:04 <yitz> Tene: but that's probably the problem. maybe try installing the dev headers for curses (not sure what it's called on fedora).
17:58:08 <yitz> Tene: i.e., i think it might be that libHSterminfo is having trouble loading something else, not that ghci is having trouble loading libHSterminfo
18:00:12 <geekosaur> yitz, terminfo (as opposed to termcap) was always part of curses
18:00:16 <Tene> I've already got them installed.
18:02:02 <Tene> yitz: I can't reproduce that original problem at all.
18:02:03 <geekosaur> that is, BSDish curses was built on top of the termcap library; SysVish curses had terminfo as part of the curses library, terminfo did not have independent existence
18:02:54 <Tene> I haven't tried clearing my ~/.cabal and ~/.ghc though
18:03:08 <Tene> I suspect I probably did something unusual before then
18:05:36 <yitz> Tene: meaning you can build vty and load it in cabal-dev ghci?
18:06:23 <Tene> Yes.  With shared disabled, everything builds fine, and cabal-dev ghci loads vty in without complaining about missing shared objects.
18:06:35 <yitz> Tene: great!
18:07:00 <yitz> Tene: that business about shared not appearing to work in cabal-dev is worrying though.
18:07:32 <Tene> Yes, I'm updating the issue on github now
18:08:27 <yitz> Tene: thanks
18:10:33 <yitz> geekosaur: interesting. but should that affect what you need in your ld_library_path to get the haskell terminfo library to load in ghci?
18:10:51 <yitz> geekosaur: anyway, Tene seems to have solved that.
18:11:09 <geekosaur> if it binds to the ncurses terminfo implementation, that will mean libcurses.so.whatever. yes
18:11:36 <geekosaur> which is what I understood the question to be?
18:12:10 <geekosaur> (or libncurses, or libncursesw, or whatever the host system library is called)
18:12:43 <yitz> geekosaur: right. the configure.ac calls for ncursesw or ncurses or curses, plus setupterm.
18:13:30 <geekosaur> someone sounded confused that use of terminfo meant the curses shared library. which, well, yes. term*cap* separated them, terminfo did not)
18:13:34 <yitz> geekosaur: but really it shouldn't matter; whatever it happens to be ought to be in some standard lib dir on any normal platform
18:13:53 <mauke> there's actually a separate library just for reading terminfo files
18:14:26 <yitz> mauke: is that setupterm?
18:14:38 <geekosaur> yes, setupterm() is the terminfo level stuff
18:14:44 <mauke> unibilium
18:14:59 <geekosaur> whether it's separate depends on the exact curses implementation
18:15:47 <geekosaur> (IIRC the separate terminfo library is a build time option and was intended for cross-compatibility on termcap-based systems)
18:15:53 <geekosaur> (in ncurses)
18:16:08 <mauke> unibilium is an independent reimplementation
18:16:46 <yitz> mauke: ah i see. ok. judah doesn't seem to have used that for the terminfo library.
18:17:38 <yitz> iirc judah is on mac os x, if that makes any difference
18:24:39 <yitz> i posted a link on reddit to the cabal-dev shared libraries issue. maybe someone with more knowledge of ghc and/or cabal-dev internals will comment.
18:35:51 <felzix> hello, I'm trying to build ghc on ubuntu to cross-compile so I can run xmonad on a raspberry pi. Since for some reason ghc isn't already available in the arch repos for ARM. I'm following http://hackage.haskell.org/trac/ghc/wiki/Building/Preparation/RaspberryPi . My question is, what is the build.mk and how do I make a useful one?
18:35:55 <felzix> or use it, even
18:37:16 <felzix> oh I found a wiki on regular compiling that actually explains this. nvm
18:37:24 <felzix> s/wiki/article/
18:45:53 <felzix> new question: how do I choose which llvm to cross compile with? I have 3.0 and 3.1 installed but 3.1 won't work due to missing code introduced in 3.0.
18:48:10 <blackdog> felzix: i have no direct experience, but a friend claims that http://elinux.org/RPi_Kernel_Compilation#Ubuntu_Linux led him fairly painlessly through building xmonad for the Pi.
18:51:43 <felzix> blackdog: unfortunately that is just the linux kernel. I am using the arch linux build provided by that community. All of the articles on getting xmonad on the raspberry pi assume you can install ghc through pacman but you can't do so anymore... or at least I can't
18:52:01 <felzix> thanks though! I will poke around that wiki in case there's something there I can use
18:55:23 <leroux> felzix: Possibly the AUR?
18:55:48 <leroux> I used to use yaourt as my frontend to pacman so that I could use the AUR.
18:56:06 <leroux> felzix: https://aur.archlinux.org/packages/ghc-7.4.2/
19:00:00 <felzix> leroux: no such package exists for arm, though. just i686 and x86_64... but I didn't realize pacman didn't access everything
19:00:14 <felzix> maybe there's an arm package and the haskell webpage doesn't list it?
19:00:19 <leroux> Ahh, that's too bad.
19:05:02 <TheGrandInquisit> @undo do x <- [1]
19:05:02 <lambdabot>  Parse error at end of input
19:05:15 <ion> [1] >>= \x ->
19:05:36 <TheGrandInquisit> @undo do x <- [1];
19:05:37 <lambdabot>  Parse error at end of input
19:05:48 <ion> what i said
19:06:20 <TheGrandInquisit> yah, but I thought there was a way to test a command here
19:06:30 <TheGrandInquisit> that I'm obviously not doing
19:06:57 <shachaf> ion: You missed the do.
19:07:07 <ion> The undo command only supports valid do blocks.
19:07:14 <ion> shachaf: true
19:07:28 <TheGrandInquisit> @type map
19:07:29 <lambdabot> (a -> b) -> [a] -> [b]
19:07:39 <prophile> @undo { x <- [1] ; x }
19:07:39 <lambdabot>  Parse error at "{" (column 1)
19:07:46 <prophile> @undo do { x <- [1] ; x }
19:07:46 <lambdabot> [1] >>= \ x -> x
19:07:56 <TheGrandInquisit> ah...
19:08:17 <shachaf> Note that that's a type error unless something weird is going on.
19:08:43 <prophile> I think it's possible?
19:08:56 <prophile> it'd have to be (m a) with m being a monad and (m a) being a Num instance I think?
19:08:59 <prophile> or Integral?
19:09:40 <shachaf> Whoops. Add "unless something weird is going on" to the end of my sentence.
19:09:59 <johnw> prophile: I think you mean (Num a, Monad m) => m a
19:10:08 <johnw> m a itself would not be a Num instance
19:10:12 <prophile> uh, yes, that's right
19:10:20 <prophile> thanks johnw
19:10:30 <shachaf> No, it would be Num (m a)
19:10:31 <shachaf> Where m is []
19:10:38 <prophile> yes, I was right
19:10:41 <johnw> ah, ok
19:10:50 <prophile> damn it, stop making me question my sanity
19:10:59 <johnw> apparently, that is the role of #haskell
19:11:05 <prophile> I've only just recovered from my PHP days
19:11:09 <johnw> my sanity has been in doubt for months now
19:11:34 <johnw> i'm convinced now that shachaf incarnates my superego
19:11:44 <shachaf> johnw: I don't think you're supposed to make people question their sanity by telling them wrong things.
19:11:56 <shachaf> That is the easy way out.
19:11:56 <TheGrandInquisit> @undo do x <- [3..4] ; [1..2] ; return (x, 42)
19:11:56 <lambdabot> [3 .. 4] >>= \ x -> [1 .. 2] >> return (x, 42)
19:12:02 <johnw> shachaf: I didn't read the whole thread of debate, so I should have kept quiet
19:12:22 <johnw> but see, I provided a double-check :)
19:12:42 <johnw> shachaf: are you coming to ICFP?
19:12:55 <blaenk> > [3 .. 4] >>= \ x -> [1 .. 2] >> return (x, 42)
19:12:56 <lambdabot>   [(3,42),(3,42),(4,42),(4,42)]
19:13:15 <shachaf> johnw: No plans to at the moment. Is registration open yet?
19:13:47 <johnw> not yet it seems
19:14:01 <johnw> you should come, as it seems I will not make it to the west coast for a while
19:14:36 <TheGrandInquisit> @suffer_my_syntax
19:14:36 <lambdabot> Unknown command, try @list
19:14:41 <TheGrandInquisit> @undo do {g <- get ; (x,g') <- return $ random g; put g'; return x} :: (Random a) => State StdGen a
19:14:41 <lambdabot> get >>= \ g -> return $ random g >>= \ (x, g') -> put g' >> return x :: (Random a) => State StdGen a
19:15:39 <ski> instead of  (x,g') <- return $ random g  consider using  let {(x,g') = random g}  (no curly brackets needed if using layout)
19:15:39 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
19:15:44 <ski> @messages
19:15:45 <lambdabot> augur said 2d 14h 2m 22s ago: the variant on ->L i suggested actually does exist! also, no need for this funny business about identiers, probably.
19:17:02 <shachaf> I heard a rumour that cmccann is going to arrange tickets for me!
19:17:34 <johnw> oh nice!
19:18:12 <shachaf> In exchange I will arrange tickets for him to go to EPACFP.
19:18:24 <shachaf> (I'm just making things up, by the way.)
19:19:34 * cmccann arranges tickets to send shachaf to Lower Elbonia.
19:20:49 <monochrom> Elbonia is a great country
19:23:00 <danharaj> edwardk: do you want to look at my code snippet?
19:23:06 <danharaj> (caveat lector)
19:23:12 <shachaf> Anyway, I probably won't go to ICFP unless something changes between now and then.
19:23:18 <shachaf> But something might well change. So who knows.
19:23:25 <johnw> shachaf: I predict many things will change between now and then
19:23:45 <solrize> could someone look at http://hpaste.org/88576
19:24:01 <solrize> the commented out "main" at the end computes and prints the answers to euler problems 8 and 10
19:24:08 <solrize> the uncommented one prints out JUST the answer to problem 10
19:24:19 <solrize> the one that prints out both answers is about 1.5x faster
19:24:21 <solrize> ????
19:25:14 <danharaj> That sounds weird.
19:25:52 <solrize> ghc 7.4.1 with -O2
19:26:14 <solrize> ohhh
19:26:20 <shachaf> Why don't you write type signatures? :-(
19:26:24 <shachaf> I bet it's the DMR or something.
19:26:24 <solrize> yeah
19:26:33 <solrize> no i bet it's inference to int instead of integer
19:26:51 <shachaf> Yes. Because of the DMR.
19:27:00 <solrize> well because of [e8,e10]
19:27:07 <danharaj> Democratic Monomorphic Republic of Haskell
19:27:35 <shachaf> If you turned off the MR it probably wouldn't happen.
19:27:43 <shachaf> (Instead you would have consistent bad performance.)
19:28:08 <solrize> e8 has to be Int because of digitToInt  it would be a type error for it to be Integer
19:28:13 <solrize> therefore [e8,e10] has to be [Int]
19:28:30 <solrize> sorry nm :)
19:28:31 <shachaf> Yes, but e10 would be polymorphic without the MR.
19:28:43 <shachaf> You should really get into the habit of writing type signatures in your code.
19:28:52 <shachaf> Especially if you @paste it. It makes it so much easier to see what's going on.
19:28:56 <johnw> +1 for type signatures
19:29:05 <shachaf> @quote rwbarton inference
19:29:06 <lambdabot> rwbarton says: type inference is supposed to be the compiler's job, not the reader's job
19:29:15 <solrize> yeah true, I left the sigs out for this because i was trying to show someone how succinct the haskell solutions to these problems were
19:29:23 <danharaj> goodquote
19:29:35 <solrize> it was originally problems 1..10 but i saw the timing weirdness and made a stripped down example
19:29:45 <danharaj> http://hpaste.org/88575
19:29:56 <shachaf> OK, but why show them unidiomatic Haskell?
19:30:04 * ski . o O ( type error slicers )
19:30:10 <shachaf> Unless you're golfing.
19:30:27 <solrize> it was sort of golfing
19:30:28 * BMeph yells: FORE!!
19:30:42 <danharaj> Could someone help me massage IMonad in that snippet to be able to use it with rebindable syntax.
19:31:47 <danharaj> (This is free monads over mutually recursive tree types that are indexed by some kind)
19:31:52 <danharaj> ' monads '
19:32:05 <dolio> shachaf: Not writing any type signatures is the only way to satisfy the Harrop criteria for a good language.
19:33:09 <Philippa> which leads to the correlation that Harrop doesn't think sufficiently modular&polymorphic code can be good
19:33:11 <cmccann> dolio: I thought the main criteria was whether he had books and consulting services to peddle based on it.
19:33:22 <Philippa> er, corrolary (sp)
19:33:25 <Philippa> (it's late...)
19:33:36 <dolio> :)
19:33:37 * cmccann still finds it hilarious that harrop got banned from wikipedia for spamming.
19:33:44 <solrize> lol
19:34:11 <shachaf> No, it doesn't lead to that corollary.
19:34:31 <shachaf> I wish people wouldn't fight trolling with trolling.
19:35:40 <Philippa> shachaf: ...you have complete type inference for System F?
19:36:21 <ski> "Harrop criteria" ?
19:36:25 <solrize> ML doesn't benefit as much as haskell does from type signatures apparently
19:36:27 <shachaf> No.
19:36:49 <Philippa> solrize: not at core level. The module system(s) are another matter.
19:36:50 <solrize> btw does anyone know wtf shen is?  tarver isn't as annoying as harrop but same idea sort of.  and he's back
19:37:32 <dolio> Oh.
19:37:37 <dolio> Is Shen the successor to Qi?
19:37:41 <solrize> yeah
19:37:44 <dolio> Okay.
19:37:48 <danharaj> These are words I do not know.
19:38:04 <dolio> Qi is kind of interesting, although I wouldn't necessarily use it.
19:38:12 <Philippa> mmm, that's more or less my take too
19:38:26 <dolio> Also, I feel like Tarver is kind of nuts, but earnest.
19:38:37 <solrize> is it something like: write your typing judgments directly in sequent calculus so there is not even any pretense at ensuring consistency
19:38:43 <solrize> then write out all the derivations by hand
19:38:44 <Philippa> It's certainly nice to see someone seriously taking on lisp's own need for greenspun stuff
19:38:48 <solrize> and claim you've got a theorem prover?
19:39:29 <dolio> I feel a little bad for him, actually.
19:39:52 <dolio> I saw a thread way back on comp.lang.functional, where he posted about this project he had built....
19:40:11 <dolio> He'd basically invented a type system for Tk, with tons of nuance, and encoded it in Qi.
19:40:13 <Philippa> ...yeah. clf for you
19:40:17 <solrize> www.shenlanguage.org
19:40:25 <dolio> And, Tk is a mess, so it was really complicated.
19:40:33 <Philippa> nobody'll want to know about something like that because lots of ick
19:40:33 <solrize> wow i don't remember that one
19:40:36 <elliott> "turing complete type system for lisp" is certainly a unique point in the design space
19:40:42 <dolio> And then a bunch of lisp people replied with, "this is too much code. Types suck. You suck."
19:40:54 <johnw> I wanted to like Qi many years back, read the manual, conversed with Tarver, but it was just too... fringe
19:40:55 <cmccann> dolio: ouch.
19:41:09 <cmccann> elliott: you're a unique point in the design space.
19:41:13 <johnw> the time investment to master it didn't seem like it would ever pay off
19:41:24 <danharaj> We are all points on the lambda hypercube.
19:41:46 <dolio> johnw: Yeah, his website and stuff is a little weird. Like, it's dangerously close to looking like a crackpot website.
19:41:50 <dolio> From what I remember.
19:41:57 <johnw> I think Xanadu should be written in Qi
19:42:28 * elliott agrees with dolio from what he's read of Qi stuff
19:42:35 <solrize> xanadu as in ted nelson?
19:42:43 <elliott> it's very advanced for crackpot work though :)
19:42:45 <johnw> yeah
19:42:56 <solrize> the xanies are way too anarchistic for that :)
19:43:03 <Philippa> dolio: yeah. I looked far enough to realise it wasn't totally crackpot and then decided I still didn't want to follow it. It also helped me realise I probably have that effect on people sometimes too
19:43:05 <johnw> the Qi manual is quite good too, as I remember
19:44:48 <solrize> how does the turing-complete type system work?
19:44:58 <elliott> solrize: by failing to always terminate
19:45:00 <danharaj> for an unbounded amount of time
19:45:02 <cmccann> the most subtle form of crackpottery is the people who aren't wrong, and actually accomplish something, but what they work on is so ill-conceived it will never be useful
19:45:26 <johnw> cmccann: like that proof of the ABC Conjecture?
19:45:33 <cmccann> (this is the part where someone makes a joke about lens)
19:45:39 <Philippa> I'm wary of calling that crackpottery - a surprising amount of it gets mined for something more useful later
19:46:10 <Philippa> (after all, if you just bound that to "useful within a century", you've described pure mathematics)
19:46:25 <canta> why a joke about lens? they seem useful, as far as i understand them at least
19:46:26 <cmccann> Philippa: that's why it's subtle, because a lot of useful stuff started off that way.
19:46:58 <danharaj> canta: 'as far as i understand them' wildly varies between users and implementers of that library :)
19:47:19 <johnw> i wonder how category theory looked to people in the 50s
19:47:26 <Philippa> you say that as if it's a simple distinction :p
19:47:37 <canta> they seem to be like functional, composeable setter/getter things :)
19:47:48 <johnw> canta: that is so cute :)
19:48:05 <dolio> solrize: I don't really know it. But I think it's just like having a logic language that you write programs in for your types.
19:48:07 <Philippa> johnw: y'know, I might actually suggest to my gf that we work through Conceptual Mathematics together sometime
19:48:09 <johnw> that was before prisms and profunctors and traversals and...
19:48:10 <shachaf> That is exactly what lenses are.
19:48:14 <cmccann> @quote Taneb lens
19:48:16 <lambdabot> Taneb says: lens has got to be the only library with more contributors than people who know how it works
19:48:23 <Philippa> I'll get turned down, but mostly on grounds of sheer time
19:48:24 <danharaj> Philippa: Is that the Lawvere book?
19:48:34 <dolio> And you can define subtypes and stuff by defining arbitrary predicates on the values of another type. Stuff like that.
19:48:49 <Philippa> danharaj: Lawvere and Schanuel
19:49:04 <Philippa> it's fairly light
19:49:23 <canta> traversals afaiui are just a lens thing so that the composeable lens-things work on stuff in lists :p profunctors i have no idea at the moment
19:49:23 <danharaj> Philippa: I read that a long while ago and I was disappointed by how light it was. It didn't cover natural transformations at all IIRC!
19:49:28 <johnw> i like the Lawvere book
19:49:32 <danharaj> And that's where all the fun is :P
19:49:43 <johnw> danharaj: just supplement it with Awodey after
19:49:54 <danharaj> johnw: Cats4Mats is my go-to.
19:50:08 <Philippa> right. What it does do, though, is work well for someone whose "proper" maths background ended before university
19:50:34 <danharaj> Philippa: In that case I guess I didn't enjoy it due to the curse of knowledge.
19:51:01 <dolio> solrize: Imagine if 'e :: T' in Haskell allowed T to be a prolog program that got fed e to determine if the typing judgment was valid. I think it might be like that.
19:51:02 <johnw> danharaj: likely.  as a total math newb, Lawvere was pleasantly approachable
19:51:09 <danharaj> I was hovering on the precipice of understanding the Yoneda lemming and I was hoping Lawvere waxing philosophical would push me over the edge.
19:51:23 <danharaj> ... lemma.
19:51:26 <cmccann> danharaj: lemmings are tricky like that.
19:51:26 <Philippa> (and give us something to wind up a friend of ours whose PhD didn't go anywhere near CT)
19:51:31 <johnw> Yoneda lemmings are isomorphic to those at the bottom of the cliff
19:51:35 <solrize> dolio hmm, interesting, and not nearly as lame as i had thought shen was
19:51:42 <solrize> but, what about the typing judgments?
19:51:49 <Philippa> cmccann: Oh no!
19:52:56 * ski now has a lemmings tune playing in head. ty
19:53:04 <Philippa> yw
19:53:45 <shachaf> import qualified Thielemann.Henning as Lemming
19:54:10 <elliott> :i Lemming.T
19:54:29 <dolio> > map succ "Lemming"
19:54:31 <lambdabot>   "Mfnnjoh"
20:00:51 <edwardk> shachaf: i kind of want to import Henning unqualified just to see what happens
20:01:25 <cmccann> edwardk: that sounds dangerous
20:01:31 <cmccann> like "don't cross the streams" territory here
20:01:55 <danharaj> This joke is floating over my head
20:03:04 <NiceOneBrah> is there a way to stub out a function in haskell similar to using the keyword "pass" in python
20:03:15 <blackdog> NiceOneBrah: undefined
20:03:21 <blackdog> NiceOneBrah: also, look at Hole-Driven Programming
20:03:31 <blackdog> slightly more sophisticated version.
20:03:43 <NiceOneBrah> blackdog: awesome, thanks!
20:05:16 <blackdog> NiceOneBrah: no worries.
20:06:54 <johnw> blackdog: sometimes error "function: Not implemented" is better, because if you have too many undefineds in your code, it's hard to know which path you went down
20:06:55 <liyang> So did anyone back that Mojo FPGA board on Kickstarter? (Mine arrived a few weeks ago.)
20:07:11 <blackdog> johnw: yes, true.
20:07:36 <blackdog> johnw: i don't leave them there for any length of time (or even long enough to actually run the program, tbh)
20:07:40 <johnw> blackdog: I find that especially true when you're doing TDD, and trying to implement only the minimum that you need to get each test to pass
20:07:58 <blackdog> NiceOneBrah: i should point out that if it ever actually runs, it'll raise an exception that will stop your program.
20:08:34 <NiceOneBrah> blackdog: ah that's cool. I was just wanting to lay out some function definitions before actually diving into their implemntation
20:08:49 <blackdog> johnw: i find when i'm hacking haskell, that the very short cycle of tdd tends to be between writing code and getting it to typecheck
20:08:51 <johnw> NiceOneBrah: in that case, undefined works well
20:09:11 <blackdog> i actually run the tests less often than i would in ruby
20:09:15 <johnw> codeGoesHere = undefined :)
20:09:52 <liyang> Trying to figure out if the Mojo can implement a Reduceron...
20:10:01 <blackdog> johnw: seen hole-driven development, btw? i saw greg davis talk about it at lambdajam recently - really interesting technique
20:10:15 <blackdog> especially when you're not exactly sure what you're doing and you're leaning on the types a bit.
20:10:29 <johnw> blackdog: yes
20:10:43 <johnw> was he showing agda-mode in Emacs?
20:10:53 <blackdog> johnw: no, all in Haskell
20:11:03 <johnw> ah.  I think I've watched that talk
20:11:08 <blackdog> just "data Hole = Hole; hole=undefined"
20:11:09 <johnw> Agda does a really nice job at that kind of development
20:11:29 <blackdog> and you flip back and forth - check that you aren't completely screwed by using "hole", then flipping back to Hole to see what it really should be
20:12:12 <johnw> I'd like to see an example of shachaf using implicit parameters to do hole-driven programming
20:12:23 <shachaf> Ask elliott.
20:12:35 <johnw> elliott: oh ellioooot!
20:13:30 <johnw> well, gonna duck out now, i'll poke him later
20:13:43 <elliott> put ?x where you want a hole in a definition with a type signature and examine the type error
20:14:03 <solrize> there's lots of cheap fpga dev boards these days... mojo just seems like yet another one?
20:14:45 <danharaj> ooh, I've never gotten a GHC error telling me about untouchable types.
20:15:14 <blackdog> hammer time
20:17:37 <solrize> untouchable types?  is that a new ghc extension?  wow
20:23:49 <dolio> It's part of the new inference algorithm.
20:23:55 <dolio> I forget what they are.
20:25:33 <canta> cannot find something with hoogle, is there no buildin equivalent to  repliF n f = foldl (.) id (replicate n f)  ?
20:25:53 <shachaf> There is not.
20:26:29 <shachaf> Probably you're better off using foldr (or maybe foldl'? Certainly not foldl)
20:27:50 <Saizan> untouchable types are like "under all these bindings and assumptions i'm not gonna attempt more simplifications"
20:28:18 <canta> foldr is indeed faster, thanks
20:28:39 * shachaf didn't have faster in mind.
20:30:37 <dolio> Not sure foldl vs. foldl' matters much in this case.
20:30:44 <dolio> Kind of like reverse.
20:32:46 <danharaj> edwardk: I have the feeling you don't want to humor me but this is as far as I think I can get ;) http://hpaste.org/88577
20:32:53 <canta> Is something unhaskellic going on in my program if I run accross cases were repeated composition of the same function seems useful?
20:33:04 <elliott> canta: no
20:33:04 <danharaj> Type safe XML templates!
20:33:12 <edwardk> danharaj: you have the right idea
20:33:23 <edwardk> sadly you converged to more or less my solution =P
20:33:26 <danharaj> edwardk: aw.
20:33:42 <danharaj> edwardk: You know what would be hella nice? If datakinds gave you a whole stack of kind, data, and value index.
20:33:56 <danharaj> So you don't have to write the evidence to pass around by hand.
20:33:59 <dolio> canta: That kind of natural number eliminator is just missing.
20:34:03 <danharaj> Also if rebindable syntax let you use a higher rank >>= :P
20:34:28 <danharaj> edwardk: anyway I consider it an accomplishment to use >9 GHC extensions and converge to the same solution as Edward Kmett ;)
20:34:32 <danharaj> Thanks for humouring.
20:34:39 <dolio> Probably should be around.
20:35:11 <dolio> Natural number types are missing, too.
20:36:22 <elliott> I assign dolio to come up with good numeric typeclasses and add Nat.
20:36:28 <wavewave> edwardk: hi, I have some question to you.
20:36:39 <edwardk> shoot
20:36:52 <shachaf> elliott: That's a big task for dolio to not do.
20:36:56 <shachaf> I assign cmccann to help.
20:36:59 <elliott> yes, so he'd better do it instead
20:37:17 <dolio> Wasn't copumpkin importing the GMP natural stuff?
20:37:33 <wavewave> I heard from carter that someone wanted to make a qt binding to haskell as a GSoC project.
20:37:50 <carter> wavewave … not quite
20:37:54 <carter> but thats the students goal
20:38:00 <carter> so yes
20:38:09 <wavewave> carter: oh. you are here. good.
20:38:14 <edwardk> wavewave: if you'd like to offer to co-mentor or mentor i'd recommend signing up on the gsoc website. i'm not sure if i can change assignments at this point though
20:38:29 <carter> but you can still unofficially comentor
20:38:45 <carter> edwardk the student is on channel,should we say hi?
20:38:48 <edwardk> wavewave: but under the assumption we approve that proposal, if you wanted to offer to help out with mentoring the project we'd love to have you
20:39:18 <edwardk> wavewave: to do so you should sign up up the google-melange.com website, and send a connection request to haskell.org if you haven't already
20:39:24 <wavewave> i am not sure that I am able to do that, but I would like to help by letting my fficxx visible to the applicatn.
20:39:46 <carter> wavewave understanding someone elses code is sometimes harder thatn writing their own
20:40:00 <edwardk> fficxx?
20:40:05 <carter> unless you're there to walk them through it, knowing it exists doesn't necessarily make things easier
20:40:06 <wavewave> carter: yeah. exactly. that's so good chance to me.
20:40:21 <edwardk> oh ffi c++
20:40:22 <edwardk> just parsed
20:40:26 <wavewave> http://github.com/wavewave/fficxx
20:40:38 <edwardk> wavewave: ah nice
20:40:44 <wavewave> it's automatic c++-haskell binding generator.
20:40:47 <edwardk> good to know that exists. i'll have to dig in deeper
20:40:55 <wavewave> I use it for my HROOT package.
20:41:07 <wavewave> which is a haskell binding to ROOT.
20:41:20 <danharaj> wavewave: Do you know how amazing you are to me right now.
20:41:30 <wavewave> see also http://github.com/wavewave/HROOT-generate
20:41:57 <canta> dolio: If you don't mind: Why would a natural number eliminator help with composition repetition?
20:42:12 <wavewave> for example, you can see HROOT-generate/lib/HROOT/Data/Core/Class.hs
20:42:30 <shachaf> canta: Because that's what a natural number eliminator is.
20:42:43 <wavewave> there some interface to C++ is defined as a haskell data structure.
20:42:52 <dolio> canta: The eliminator for natural numbers is like: elim f z 0 = z ; elim f z n = f (elim f z (n-1))
20:43:01 <wavewave> and then fficxx makes a haskell cabal package for it.
20:43:10 <Clint> wacky
20:43:11 <carter> edwardk would you have any idea how to make sure both ghc and cabal both pick up clang as their assembler instead of gcc?
20:43:28 <edwardk> carter: no idea
20:43:32 <carter> ok
20:43:43 <shachaf> @ty foldr . const
20:43:44 <lambdabot> (b -> b) -> b -> [a] -> b
20:43:47 <carter> at this point its pretty clear to me that its either a cabl or ghc bug
20:44:02 <Sgeo> I wish I participated in GSoC
20:44:08 <Sgeo> Never did :(
20:44:17 <carter> Sgeo i'm mentoring now, never participated
20:44:18 <edwardk> Sgeo: get in as a mentor next year ;)
20:44:19 <carter> though tried to
20:44:30 <carter> Sgeo its less work as amentor :)
20:44:32 <edwardk> i didn't know haskell back when i was elegible to be a student
20:44:33 <carter> ish
20:44:42 <carter> or that
20:44:51 <Sgeo> edwardk, butbut... I'm not _that_ familiar with various OSS projects
20:45:02 <wavewave> edwardk: okay, so I will sign up first there. comentoring or just helping is okay. I just want to have some connection for such work.
20:45:07 <Sgeo> And only just recently got a 'real' job
20:45:26 <SrPx> Coming from JavaScript, how would you recommend me to work with dynamic objects in Haskell? I'd just use maps as if they were JS objects; is that fine? No antipattern here?
20:45:32 <edwardk> wavewave: feel free to pitch in as much or as little as you have time for. i'm sure carter would like the help =)
20:45:47 <wavewave> danharaj: thank you for your cheering me up. :-D
20:45:49 <carter> wavewave that data model of c++ objects is slick
20:45:51 <Sgeo> SrPx, what do you need dynamic objects for, precisely?
20:46:10 <carter> edwardk yes wavewave  will be owed a pint of gratitude per unit of help
20:46:25 <carter> payable in the RL future at some unspecified time
20:46:34 <edwardk> carter: you'll probably get to offer him that pint at hac phi assuming you both show
20:46:49 <carter> edwardk is wavewave  coming?
20:46:55 <edwardk> ask him =)
20:47:26 <edwardk> if he doesn't i won't have anyone to talk to about physics that goes way over my head
20:47:37 <carter> 8o
20:47:38 <wavewave> i do not know. I might be in Europe.
20:47:44 <carter> wavewave where are you now?
20:47:48 <edwardk> shucks
20:47:53 <carter> edwardk http://hackage.haskell.org/trac/ghc/ticket/7929#comment:4
20:48:00 <wavewave> now in Michigan, but move to CERN in August.
20:48:08 <shachaf> hacphi is in two weeks.
20:48:28 <carter> edwardk at this point i may  have to just not allow cabal / ghc to build c code
20:48:36 <carter> because it messes it up too much :)
20:49:07 <wavewave> oh. it's june. i thought it's in July.
20:49:17 <carter> wavewave so no go?
20:49:20 <carter> or yes go
20:49:20 <edwardk> you can always get configure to do the work and steal a lot of the machinery from the old analytics build
20:49:59 <SrPx> Sgeo: hm I'm not sure, but I could be making an evolutionary algorithm that could benefit from having the ability to define new properties for a specific object in runtime...
20:50:00 <wavewave> carter: I couldn't say right now but will tell you before Monday.
20:50:39 <carter> wavewave you should talk with dmwit about it
20:50:43 <carter> he's organizing!\
20:50:55 <wavewave> okay, sure.
20:50:56 <carter> also: if you call the right person at the hotel they recommend at the right time
20:51:03 <carter> you get the upenn discount
20:51:09 <carter> club quarters
20:51:17 <carter> but because they didn't organize the discount
20:51:33 <carter> its kinda a try calling when its different people social engineering thing
20:51:38 <carter> which only works out by accident
20:51:46 <carter> edwardk i'll look at it
20:52:09 <dolio> Is the discount based on UPenn being a 'club member'?
20:52:17 <carter> dolio no clue
20:52:37 <edwardk> dolio: it should be the same discount we get for mcgraw-hill
20:52:39 <dolio> Because in such a case, you might be able to learn the secret password and type it in on the website.
20:52:57 <dolio> Yes, ours is available via the website.
20:53:42 <carter> edwardk at that pont I kinda just want to standardize the alphaheavy/nathan howell hack of using C via clang, doin the  llvm bitcode hack, and then foreign primop calling the c
20:53:50 <carter> because thats not much more work
20:53:55 <carter> than modding a configure thing
20:53:57 <carter> i think
20:53:59 <carter> ish
20:54:32 <carter> it actually won't be that hard to support (seperately) doing the right calling convention for 7.4, 7.6 and pending 7.8
20:55:01 <carter> i could probably even with the right mangling, do machinery to make it saner to a) pull values off the stack spilling
20:55:07 <carter> b) do multiple return values nicely
20:55:26 <carter> 7.4 and 7.6 do the same callling convention stuff afaict
20:55:31 <carter> 7.8 is slightly different
20:57:28 * hackagebot parseargs 0.1.3.5 - Command-line argument parsing library for Haskell programs  http://hackage.haskell.org/package/parseargs-0.1.3.5 (BartonMassey)
20:58:37 <wavewave> hmm I think I can drive to philadelphia.
20:58:40 <carter> edwardk you mean the stuff in m4 and configure stuff as of say https://github.com/analytics/analytics/tree/e4abfadecac626731b8fe0b6b7576ab0f2221d0c
20:58:47 <edwardk> probably
20:58:54 <edwardk> yes
20:59:50 <carter> which bits would be usable for compiling the c codes before setup?
21:00:07 <carter> oh, the makefile
21:00:15 <carter> errr
21:00:48 <edwardk> it moves you out of cabal into autoconf hell but that is pretty well documented and can do everything
21:00:57 <carter> i kinda feel like a simpler hack would be to have a mini shake thing that runs before the main setup.hs
21:01:29 <carter> and then just have cabal say "oh, huh, .a stuff in cbits/libs with headers in cbits/include"
21:01:29 <edwardk> the benefit of this approach is you can just cabal install and it works
21:01:37 <carter> yes
21:01:53 <edwardk> if i can't distribute the haskell code via cabal it might as well not exist ;)
21:02:06 <carter> edwardk i mean more like
21:02:10 <carter> main =
21:02:16 <carter> do shake thing ; cabal stuff
21:02:44 <carter> which doesn't cheat too much...
21:03:14 <carter> or am i missing something
21:03:57 <Saizan> carter: you'd better let cabal be the driver and call shake from one of the hooks
21:04:06 <carter> Saizan cabal is the problem
21:04:09 <carter> i think
21:04:25 <Saizan> from the hooks you can do anything, at pretty much anytime
21:04:26 <carter> Saizan i'm just wanting to have a library built before cabal does other things
21:04:51 <Saizan> putting stuff in Setup's main is going to mess with how cabal-install calls it
21:04:58 <carter> Saizan how so?
21:05:42 <Saizan> if you have a "Custom" Setup.hs it gets called a few times during the configure/build/install process
21:06:22 <carter> and if i do not custom, hows it call it?
21:06:28 <Saizan> it doesn't
21:06:44 <carter> ahhh
21:07:09 <Saizan> but what i meant is that you probably don't want your shake thing to run for every Setup command
21:07:20 <Saizan> just somewhere between configuring and building, probably
21:07:37 <Saizan> and you can configure the "defaultMain" to do so
21:07:54 <carter> Saizan shake only  reruns stuff if the stamps are bad though, right?
21:07:59 <carter> time stampes
21:08:06 <carter> i'm ok with that
21:08:11 <carter> unless its making it epic slow
21:08:44 <carter> also or is there another reason that aside?
21:09:07 <Saizan> you want to build the c stuff even for e.g. "cabal sdist"?
21:09:23 <carter> touche
21:09:29 <carter> ok
21:09:34 <carter> so i have a shake stanza
21:09:41 <carter> thats run before the configure or build steps
21:09:59 <carter> + giving cabal some info on how to do a clean
21:10:24 <carter> right?
21:10:29 <Saizan> it's not a stanza in the .cabal file btw, it's a function you pass to the defaultMain, to be clear
21:10:49 <carter> yes
21:10:53 <carter> thats what i mean
21:11:15 <carter> basically i want to make sure my shake shime runs before anything else when cabal does a build or configure run
21:11:23 <Saizan> then yes
21:11:26 <Saizan> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/Cabal/Distribution-Simple-UserHooks.html
21:11:39 <carter> so i can lie and say "look over there,http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Simple-UserHooks.html"
21:11:41 <carter> ok
21:11:52 <carter> "look over there, heres a static lib for you"
21:12:54 <Saizan> i don't know how to say that specifically, but there should be a way
21:13:00 <carter> Saizan i have that covered
21:13:08 <carter> or at least a way that should work
21:13:25 <carter> Saizan so i just have some code that augments the preconf and prebuild hooks
21:13:41 <carter> \a b c -> do mything ; preconfhook a b c
21:13:53 <carter> \a b -> do mything ; preconfhook a b
21:14:00 <carter> \a b -> do mything ; prebuildhook a b
21:14:13 <Saizan> yeah
21:14:24 <carter> SWEAT
21:14:26 <carter> SWEET
21:14:28 <carter> ok
21:15:00 <carter> Saizan basically its kinda hard to get ghc / cabal to use clang instead for c codes
21:15:05 <carter> so i seem to ahve to do that myself
21:16:52 <wavewave> okay, i registered hacphi by emailing to dmwit now.
21:17:05 <wavewave> so see you guys there.
21:17:13 <wavewave> lol
21:17:14 <shachaf> Half a cheer for wavewave! Hip hip -- hoo!
21:17:27 <wavewave> shachaf: :D
21:17:44 <carter> woot
21:17:59 <wavewave> shachaf: sorry that I couldn't join in bay hac
21:18:05 <carter> Saizan thanks
21:18:09 <carter> now i can focus on the fun bit
21:18:10 <Saizan> carter: np
21:18:15 <shachaf> wavewave: As revenge, I won't join in hac phi.
21:18:25 <carter> making it possible to use c via clang rather than cmm to write primops
21:18:29 <wavewave> :-P
21:18:47 <carter> shachaf so no change of plans for you then
21:19:20 <shachaf> You're free to arrange for plane tickets for me!
21:19:49 <carter> shachaf just give me your CC info and i can make it so
21:20:17 <shachaf> I keep it with cmccann.
21:20:53 <carter> cmccann are to pass along his cc stuff so i can arrange the travel?
21:21:15 <carter> and not the cartesian categorical sort mind you
21:21:33 <cmccann> carter: I think elliott handles shachaf's expenses. ask him.
21:21:43 <carter> cmccann you do it
21:21:58 <elliott> cmccann: sorry, I'm retired.
21:22:09 <monochrom> I handle shachaf's income. give his money to me!
21:22:21 <elliott> I can vouch for monochrom
21:22:24 <carter> cmccann you're already the unoffical head of the commitee for bikeshed decaration
21:22:26 <cmccann> monochrom: ok, sounds good.
21:22:41 <carter> monochrom he signed it over to me, pass it my way man
21:22:57 <shachaf> monochrom: Joke's on you, I have no income!
21:24:28 <carter> shachaf lets fix tht!
21:24:53 <carter> anyone seen the most recent dr who?
21:26:32 <wavewave> edwardk: i registered in google-melange as wavewave
21:27:00 <shachaf> @where gsoc
21:27:01 <lambdabot> #haskell-gsoc | http://www.google-melange.com/gsoc/org/google/gsoc2013/haskell
21:32:17 <NemesisD> anyone know how to grab a PID from a call to createProcess? it returns a ProcessHandle but i cannot figure out how to get the pid from it
21:32:32 <monochrom> I can't either
21:34:19 <shachaf> I don't think pid is exposed.
21:34:25 <shachaf> At least, without using .Internals.
21:35:06 <shachaf> Note that System.Process is compatible with Windows.
21:36:23 <NemesisD> ugh
21:37:18 <NemesisD> i'd use something *nix specific but the interface posix exposes is not nearly as nice
21:38:06 <shachaf> You can use .Internals to get the PID if you want.
21:38:27 <shachaf> Just, uh, use very specific version constraints? There aren't many guarantees.
21:38:42 <NemesisD> pretty sketchy
21:38:56 <shachaf> Yep.
21:39:12 <NemesisD> i was looking to add pidfile support to the angel process monitor
21:41:10 <Aetherspawn> ;__; I'm having a monad hell problem and I'm too noob to solve it
21:41:46 <shachaf> @wn hell
21:41:46 <lambdabot> *** "hell" wn "WordNet (r) 3.0 (2006)"
21:41:46 <lambdabot> hell
21:41:47 <lambdabot>     n 1: any place of pain and turmoil; "the hell of battle"; "the
21:41:49 <lambdabot>          inferno of the engine room"; "when you're alone Christmas
21:41:50 <lambdabot>          is the pits"; [syn: {hell}, {hell on earth}, {hellhole},
21:41:52 <lambdabot> [17 @more lines]
21:41:54 <shachaf> Sounds unpleasant.
21:42:18 <Aetherspawn> Here's my code at the moment: http://hpaste.org/88581
21:42:55 <Aetherspawn> On line 80 I get this: http://hpaste.org/88582
21:43:13 <Aetherspawn> And I'm not exactly sure what I means (i've tried wrapping in runResourceT and such, but then it doesn't satisfy as being a Source)
21:43:18 <Aetherspawn> ;__; confused.
21:43:32 <shachaf> Maybe #yesod are experts in Conduit.
21:44:04 <carter> shachaf i experienced trying to build yesod in a sandboxed env recently, it didn't work
21:44:13 <carter> IN A Sandbox
21:44:22 <carter> speaking of which, cabal head is really nice
21:44:34 <carter> the sandboxing ui is now exposed
21:44:58 <NemesisD> would that replace hsenv?
21:45:36 <carter> NemesisD mebe
21:45:49 <carter> i mean, i don't think you can shim in different ghcs
21:45:56 <carter> or could you....
21:46:50 <NemesisD> dunno
21:48:25 <carter> NemesisD do you just want build isolation
21:48:31 <carter> or local builds using diffferent ghcs?
21:48:56 <carter> theres apparently a tool called stow that lets you switch up ghc versions or other binaries easily
21:49:04 <NemesisD> build isolation, or more accurately just avoiding cabal hell
21:49:09 <carter> NemesisD then yes
21:49:20 <carter> NemesisD it subsumes any sane reason to use cabal-dev
21:49:25 <carter> but mroe awesome
21:49:46 <NemesisD> my other main problem is compiling for other systems
21:50:06 <NemesisD> i.e. i develop on archlinux and my production servers use centos
21:50:32 <NemesisD> refusing to set up a VM with centos, i just compile in production :/
21:51:20 <felzix> heh I'm getting to learn all about cross-compilation...
21:51:28 <monochrom> centos has very different c lib versions. different enough to force you to build on centos
21:54:13 <NemesisD> yeh ive come to terms with that
21:55:58 <monochrom> perhaps incompatibility with the rest of the world is a way to achieve security
21:56:49 <monochrom> would be awesome if someone's worm fails on centos just because of old glibc :)
21:57:20 <shachaf> all my c is glib
21:58:04 <NemesisD> i believe our centos boxes are still on ghc 6
21:58:54 <monochrom> my worm needs DataKinds. it is futile on ghc 6
21:59:54 <NemesisD> lol
22:03:10 <danharaj> edwardk: comonad.com has been down for me for quite some time now. Is it ok?
22:03:10 <carter> NemesisD ghc 6….. <twitches>
22:06:48 <monochrom> oh, have you seen my new http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
22:09:00 <shachaf> Libraries compile with -O by default?
22:09:09 <carter> WAT of sadness
22:09:13 <monochrom> yes. has been a long time actually
22:09:44 <monochrom> because a long time ago -O2 was not officially recommended. (see GHC user's guide)
22:11:03 <Aetherspawn> Wouldn't it be better to move to -O2 now?
22:12:17 <monochrom> however, bytestring and text etc use their own "ghc-options: -O2"
22:12:41 <monochrom> in bytestring.cabal and text.cabal
22:13:12 <shachaf> Sure.
22:13:30 <shachaf> What about e.g. base?
22:15:12 <monochrom> IIRC GHC build.mk goes with just -O
22:16:04 <monochrom> and base.cabal doesn't specify anything
22:38:32 <sclv> @tell danharaj nope comonad.com is busted by evil hackerbots and needs some tlc and perhaps a move to something that's not a crummy PHP cms. dunno when that's coming tho :-)
22:38:32 <lambdabot> Consider it noted.
22:59:43 <shachaf> sclv: What, comonad.com is just down and that's it?
22:59:50 <shachaf> What happened?
23:01:42 <tgeeky> unable to connect! a travesty!
23:57:39 <hrookie> favorite IDE's? i'm tmux-vim-ing it right now but i am making too many typos that i don't catch til compile time =D
23:57:49 <johnw> use hdevtools with vim
23:59:30 <Aetherspawn_> Ugh fusing two sources in conduit
23:59:34 <Aetherspawn_> is so painful
