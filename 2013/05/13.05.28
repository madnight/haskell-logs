00:00:09 <shachaf> The type errors are there for you, not against you.
00:00:45 <shachaf> Anyway, I think special cases make life more complicated. You can think about them when you aren't a beginner.
00:01:29 <dpwright_> right... for now I'll stick with return ().. I might have another go at exitWith later if I want to return a code
00:01:36 <dpwright_> thanks for the tips!
00:23:36 * hackagebot rabocsv2qif 1.1.3 - A library and program to create QIF files from Rabobank CSV exports.  http://hackage.haskell.org/package/rabocsv2qif-1.1.3 (SanderVenema)
00:29:57 <no-n> whoever is posting all the porn links on hpaste.org is quite annoying :/
00:32:10 <flebron> :o new haskell platform
00:37:06 <no-n> :o
01:08:37 * hackagebot rabocsv2qif 1.1.4 - A library and program to create QIF files from Rabobank CSV exports.  http://hackage.haskell.org/package/rabocsv2qif-1.1.4 (SanderVenema)
01:14:13 <Itkovian> Nice work with the new platform release guys. Can somebody adjust the topic?
01:14:39 --- mode: ChanServ set +o shachaf
01:14:54 --- mode: ChanServ set +o johnw
01:15:03 --- topic: set to '["Haskell Platform 2013.2: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down,try: http://hdiff.luite.com "]' by shachaf
01:15:20 --- topic: set to '["Haskell Platform 2013.2: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down,try: http://hdiff.luite.com "]' by johnw
01:15:26 <shachaf> ?
01:15:27 <johnw> heh
01:15:31 <johnw> sorry, didn't know you were editing it
01:15:33 <typoclass> shachaf: magnificent stereo
01:15:38 --- mode: johnw set -o johnw
01:16:30 --- topic: set to '["Haskell Platform 2013.2: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down, try: http://hdiff.luite.com "]' by shachaf
01:16:35 --- mode: shachaf set -o shachaf
01:17:16 <johnw> next release is 2013.4?
01:17:21 <johnw> wouldn't that be 2013.6 now?
01:18:07 <typoclass> johnw: not sure if 4 and 6 are months, it could be just a running number. (odd numbers = development, even = release)
01:18:17 <arkeet> then why not .0?
01:18:58 <typoclass> arkeet: no idea. i'm just speculating. i should shut up :-)
01:19:27 <Itkovian> thx
01:21:21 <typoclass> tangentially, why do we have that faux-[String] look on the topic? it could be edited with that lambdabot facility, but folks don't seem to normally use that
01:21:35 <shachaf> To fit in.
01:23:17 <johnw> typoclass: I have no idea
01:24:13 <typoclass> shachaf: "all the cool kids" are doing it?
01:26:03 <elliott> lambdabot's facility cannot edit it
01:26:08 <elliott> because lambdabot is not an op
01:27:10 <typoclass> elliott: ok, one of several problems
01:27:34 <elliott> I think it's traditional by now
01:27:51 <shachaf> It's the kind of thing dons would do.
01:28:01 <shachaf> I bet he started it.
01:28:27 <typoclass> elliott: i recall that one evening in -blah where people tried to use lambdabot on the topic, and it took about hour with many attempts by many people. the combined brain power took quite a while to get it to work =)
01:29:17 <shachaf> Hmm, I don't believe that.
01:29:25 <shachaf> But that's offtopic for this channel.
01:29:45 <shachaf> OK, maybe it precedes dons.
01:34:34 <typoclass> anyway, here is a suggestion that's 20 chars shorter. Haskell Platform 2013.2: http://bit.ly/Clv5r – GHC 7.6.3 http://v.gd/wie445 – Paste code/errors: http://hpaste.org – Haskell news: http://reddit.com/r/haskell – The Haskell programming language: http://haskell.org – Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D – If Hackage is down, try http://hdiff.luite.com
01:34:39 * typoclass purrs
01:34:55 <shachaf> IRC measures the topic in octets, not characters.
01:36:29 * elliott thinks we're too far into this [] thing to abandon it now.
01:37:53 <neutrino> data Topic = HaskellPlatform2013_3 "http://bit.ly/Clv5r" | GHC7_6_3 "http://v.gd/wie445" | More Topic
01:38:27 <neutrino> because type-based program interpretation is better than structure-based interpretation
01:39:33 <arkeet> I prefer something like | over a dash for a separator
01:40:03 <elliott> another advantage of using []: the Report dictates our separator. no arguments
01:40:13 <arkeet> :p
01:40:50 <typoclass> elliott: no, we have a choice between 1:2:3:[] and [1,2,3]. cue the endless wars :-)
01:42:40 <alevy> @hoogle [a] -> [a]
01:42:40 <lambdabot> Prelude cycle :: [a] -> [a]
01:42:40 <lambdabot> Data.List cycle :: [a] -> [a]
01:42:41 <lambdabot> Prelude init :: [a] -> [a]
01:44:00 <alevy> @hoogle iterIO
01:44:00 <lambdabot> package iterIO
01:44:00 <lambdabot> package criterion
01:44:00 <lambdabot> package criterion-to-html
01:46:58 <Zeev> what's a haskell !! operator / is there an index in lyah
01:47:12 <johnw> > [1,2] !! 1
01:47:13 <lambdabot>   2
01:47:13 <Zeev> in the book itself I mean
01:50:21 <typoclass> Zeev: i'm not sure about lyah, but we have hoogle and hayoo. example: http://www.haskell.org/hoogle/?hoogle=%21%21
02:12:53 <johnw> @hoogle (!!)
02:12:53 <lambdabot> Prelude (!!) :: [a] -> Int -> a
02:12:53 <lambdabot> Data.List (!!) :: [a] -> Int -> a
02:12:53 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
02:18:38 * hackagebot idris 0.9.8 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.8 (EdwinBrady)
02:36:42 <yezariaely> I have to implement an equivalence relation on a data structure and then retrieve reflexive and transitive closure. Is there anything predefined in haskell to do this simple?
02:37:15 <shachaf> Why do you have to?
02:38:19 <yezariaely> I have to extract the members of the equivalence classes to do some further processing of the structures the domain of the equivalence relation represents.
02:45:50 <Cale> There's a transitive closure implementation in the fgl package
02:46:02 <typoclass> yezariaely: ^^
02:47:19 <Cale> http://hackage.haskell.org/packages/archive/fgl/5.4.2.4/doc/html/Data-Graph-Inductive-Query-TransClos.html
02:48:01 <Cale> I really don't know why the fgl authors give things such short names.
02:49:06 <Taneb> Cale, to counterbalance the module names
02:49:34 <Cale> yeah, lol
02:49:39 <Aetherspawn> Heads up, there's 400 SO bounty on this question now ;___; http://stackoverflow.com/questions/16757060/haskell-conduit-one-processing-conduit-2-io-sources-of-the-same-type
02:49:50 <Aetherspawn> (Sorry for spamming)
02:57:09 <eikke> kvanberendonck, sounds dutch :)
03:12:41 <Aetherspawn> eikke, yeah it is :)
03:13:39 * hackagebot digestive-functors 0.6.1.0 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.6.1.0 (JasperVanDerJeugt)
03:13:41 * hackagebot digestive-functors-heist 0.7.0.0 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.7.0.0 (JasperVanDerJeugt)
03:13:43 <eikke> can't answer your question though except for looking into stm-conduit which you apparently did
03:17:06 <Cryovat> Digestive functors sounds like a type of biscuit :o
03:17:13 <johnw> to me too
03:17:24 <johnw> something to have with coffeescript
03:17:33 <Cryovat> Haha
03:18:39 * hackagebot digestive-functors-blaze 0.6.0.1 - Blaze frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.6.0.1 (JasperVanDerJeugt)
03:30:07 <unlink> If I'm slicing up a lot of big ByteStrings and only hanging on to little pieces, is there any way to purge the big ByteStrings?
03:30:44 <Cale> unlink: Just make sure that the little pieces are evaluated
03:30:51 <Kinnison> Once you're not using them any more they should get thrown away, no?
03:30:56 <Cale> yes
03:30:59 <shachaf> Nothing with the ByteString API, as far as I know.
03:31:03 <shachaf> Cale: ?
03:31:26 <Cale> shachaf: Just garbage collection
03:31:42 <shachaf> Cale: How will GC cause this to happen?
03:32:00 <shachaf> Remember, a big ByteString is a malloc()ed chunk of memory. Slices of it point to the same big chunk of memory.
03:32:44 <Cale> Er, hmm. Surely that isn't also true for the Lazy variant
03:33:23 <shachaf> Lazy is a bit more complicated, but it'll still happen to some degree.
03:33:52 <shachaf> Lazy = [Strict]. Each Strict chunk that holds any bytes referred to by at least one slice will be kept entirely.
03:33:56 <Cale> right
03:34:04 <unlink> It's particularly nasty in my case because I'm transforming most -- but not all -- of my input
03:34:38 <shachaf> Anyway, I've wanted a way to handle this before and as I remember ByteString doesn't really have anything.
03:34:50 <unlink> Strings are about 20% more memory efficient in this particular case >_<
03:34:50 <shachaf> Well... It has copy.
03:34:54 <Cale> oh, right, there's copy
03:34:56 <Cale> yeah
03:35:08 <unlink> Ah, perfect.
03:35:25 <shachaf> unlink: Strings aren't even comparable with ByteStrings. :-( String is like Text; [Word8] is like ByteString.
03:37:46 <unlink> In general you're right, of course, but in my ASCII dataset it's all the same.
03:37:55 <shachaf> :-(
03:38:05 <unlink> What amazing to me is that a linked list of characters can be more efficient than...well, anything.
03:39:06 <tdammers> unlink: lazy evaluation.
03:39:21 <Cale> If what you're doing is iterating over those characters, then a list is fairly appropriate.
03:39:31 <hpc> @quote list.is.a.loop
03:39:31 <lambdabot> No quotes match. Just what do you think you're doing Dave?
03:39:39 <hpc> @quote is.a.loop
03:39:39 <lambdabot> No quotes match. There are some things that I just don't know.
03:39:39 <tdammers> a typical scenario in string processing is where you have a producer, a filter, and a sink
03:39:55 <hpc> the quote is something like "a list is a for-loop waiting to happen"
03:40:08 <Cale> Or just a loop waiting to happen
03:40:17 <tdammers> e.g., an input stream, a Char -> Char function, and an output stream
03:40:32 <shachaf> @quote waiting.to.happen
03:40:32 <lambdabot> elliott says: race condition waiting to happen
03:40:46 <Cale> Just as a loop either doesn't have any iterations (because its precondition isn't met) or consists of an iteration followed by another loop
03:40:58 <Cale> a list is either empty, or consists of a single element followed by another list
03:41:08 <unlink> Well, I'm not, but yeah.
03:41:28 <tdammers> the key is that such a setup only ever needs to keep one character in memory, and lazy evaluation makes that happen
03:42:51 <tdammers> so even though you do getContents >>= liftM toUpper >>= putStr on a 6TB input file, you're only processing one character at a time, and the code will run in constant space.
03:42:52 <Cale> unlink: btw, at one point while trying to make a program which chopped up ByteStrings run faster, I replaced ByteStrings with functions (ByteString -> ByteString) which added the given ByteString to the beginning of their argument, and used composition instead of concatenation, and the program ran hundreds of times faster and used far less memory. :)
03:43:52 <Cale> (which is a normal thing to do with Strings or lists, but I rarely see people try it with ByteString or Text)
03:51:26 <FreeFull> I wonder what the point of liftM and liftA is when there is fmap
03:51:46 <Cale> Mostly to implement fmap in instances of Functor
03:52:36 <elliott> because liftM works on Monad which is disconnected from Functor
03:53:24 <Cale> Even if Functor were a superclass of Monad, you could still write the instance by writing the Monad instance first, and then providing the required Functor instance using fmap = liftM
04:00:14 <diabel232> I'm trying to learn new language i was thinking about haskell or scala but  haskell looks more friendly for beginners
04:01:47 <ketil> diabel232, did you read about monads yet? :-)
04:01:57 <diabel232> not yet :)
04:02:17 <ketil> No, seriously, Haskell is worth learning.  In my humble non-Scalaized opinion.
04:02:37 <diabel232> I'm thinking more to use it for web development :)
04:02:40 <diabel232> yesod
04:03:08 <ketil> 12:58 * snoyberg (~ubuntu@109-186-6-184.bb.netvision.net.il) has left #haskell
04:03:17 <ketil> Think you just missed somebody.
04:04:05 <ketil> There are some good frameworks (yesod, snap, happstack...and more) but I haven't really used any of them.  Lots of people do, though, so you're likely to get a lot of help if you ask around.
04:04:27 <diabel232> thanks :)
04:05:00 <schoppenhauer> is there a way of formatting an if-then-elseif-then-elseif-...-else-expression in a way that the alternatives have the same indention?
04:05:17 <schoppenhauer> like in case-of?
04:05:18 <shachaf> ketil: I think making a big deal about monads for beginners is pretty harmful. There's already enough mystique.
04:05:35 <FreeFull> schoppenhauer: I think you might want to use guards
04:05:41 <shachaf> schoppenhauer: Guards would be the standard way. ... | x = ... | y = ... | otherwise = ...
04:06:02 <ketil> Yes, sorry - I'm in a flippant mood, and it leaks out.
04:06:18 <shachaf> If you happen to have an equation or case-of handy, you can use guards with that. Otherwise you can make a new case-of like case () of _ | ... -> ... | ... -> ...
04:06:25 <ketil> diabel232, forget the monads comment, I meant endomorphic functors!
04:06:32 <diabel232> ketil you mean monads are terrible or good?
04:06:36 <schoppenhauer> FreeFull, shachaf: thank you
04:06:36 <shachaf> ketil: ...
04:06:53 <ketil> diabel232, seriously, though: you'll bump into some rather abstract stuff, especially on the mailing lists - don't worry about it too much is my advice.
04:06:54 <shachaf> With GHC 7.6 you can use an extension to get the syntax: if | ... -> ... | ... -> ...
04:07:20 <shachaf> diabel232: The FAQ has a good answer to this question. You should read it.
04:07:22 <ketil> Let theoreticians do the theoreticizing - it's usually easy enough to apply the stuff you need to get work done.
04:07:22 <shachaf> @where faq
04:07:22 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
04:07:27 <ketil> shachaf, better? :-)
04:07:29 <diabel232> thanks
04:07:31 <shachaf> Not really.
04:07:33 <tero-> diabel232: Yesod uses Haskell extensions which can make its internals look intimidating
04:07:43 <tero-> and the errors messages, too
04:08:30 <ketil> shachaf, okay, okay.  There _is_ a lot of scary terms being passed around though, and I think the beginner should be prepared to see them - and know that he doesn't necessarily need to understand everything.
04:08:34 <shachaf> ketil: Monad isn't this crazy theoretical idea. It's a simple thing that people worry about way too much due to people making a big deal about it.
04:08:58 <FreeFull> The problem with monads is all the monad tutorials
04:08:58 <shachaf> "monad" isn't any less scary than "abstract base class"
04:10:04 <ketil> shachaf, yes, I agree.  But often explanations of relatively simple concept is discussed in terms of category theory etc, so the ML can be scary if you worry about these things.
04:10:20 <tero-> diabel232: but after the painful learning phase I've been very happy to use it
04:10:34 <diabel232> because i have hard choice now
04:10:42 <diabel232> stay with play framework or learn yesod
04:10:47 <diabel232> yesod looks awensome
04:11:11 <shachaf> If you're learning Haskell, I strongly recommend learning the language not via one of the web frameworks.
04:11:47 <tero-> diabel232: you read real world haskell already?
04:12:06 <diabel232> not yet :) i am at early beginning
04:12:19 <diabel232> I'm at point of making choice
04:12:42 <ketil> diabel232, sorry if I was less than helpful, I do wish you luck and welcome to Haskell.  Enjoy!
04:13:02 <diabel232> thank you! :) it was very friendly hand helpful thanks
04:14:17 <schoppenhauer> FreeFull, shachaf: do guards also work inside another construct (like inside case-of, etc.)
04:14:29 <schoppenhauer> (and after let ... in)
04:14:41 <shachaf> Guards work with equations -- as in "foo = bar" -- and with case-of.
04:14:49 <shachaf> foo | x = bar | y = vaz
04:15:10 <Sgoettschkes> Hi, I'm back with another beginner question: I am trying to sort a list of strings but "sort" seems to be not implemented although this documentation: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-List.html#v:sort
04:15:31 <shachaf> sort is implemented, I promise.
04:15:44 <schoppenhauer> shachaf: I have a case x of Just st -> ..., where ... must be this way. is that possible?
04:15:44 <merijn> > sort ["ab", "bb", "aa"]
04:15:45 <lambdabot>   ["aa","ab","bb"]
04:16:02 <shachaf> Is GHC giving you a "not implemented" error? :-)
04:16:13 <Mortomes_> Sgoettschkes: Did you import Data.List?
04:16:16 <Sgoettschkes> "Not in scope"
04:16:19 <shachaf> schoppenhauer: case x of Just st | blah st -> ... | otherwise -> ...; Nothing -> ...
04:16:26 <Sgoettschkes> maybe that's the problem :)
04:16:28 <shachaf> OK. You need to import Data.List to use sort.
04:17:28 <schoppenhauer> shachaf: thanks.
04:17:49 <Sgoettschkes> shachaf: Thanks, it works now :)
04:18:08 <Sgoettschkes> Just wondering why head/tail and the other functions are working without importing Data.List?
04:18:26 <shachaf> Because they are in the Prelude.
04:18:47 <shachaf> By the way, head/tail are unsafe functions and you should generally not use them. This isn't lisp.
04:19:01 <shachaf> I don't know if you've learned about pattern-matching yet. That's what you should use instead, most of the time.
04:20:14 <Sgoettschkes> shachaf: I know pattern matching (mostly from Scala) and I'm using it now. In the beginning I used some head/tail but now I try not to ;)
04:24:30 <nikola> shachaf: why are head and tail unsafe?
04:24:38 <eikke> > head []
04:24:40 <lambdabot>   *Exception: Prelude.head: empty list
04:25:00 <shachaf> nikola: Unsafe in the sense that they crash your program if given an empty list.
04:25:23 <nikola> Oh, yeah.
04:27:17 <synonymous> Hi.. Has anyone tried using GHC 7.6 as library to dynamicaly compile and load Haskell modules?
04:28:03 <synonymous> It compiles the module fine, but complains when trying to load it (module name is Plugin): `Cannot add module Plugin to context: not interpreted'
04:29:02 <hiptobecubic> the platfoorrrrrrrrrrrmmmmm!
04:29:15 <synonymous> sorry, osx 10.8.2
04:30:42 <synonymous> Host.hs: http://hpaste.org/88746
04:30:43 <synonymous> Plugin.hs: http://hpaste.org/88747
04:32:12 <fosskers> evenin'
04:32:35 <Philonous> Is there a way of seeing the code that ghc generates for derived instances?
04:32:53 <elliott> -ddump-deriv or such IIRC
04:33:11 <hpc> that's exactly it
04:33:22 <Philonous> Thanks a bomb!
04:33:34 * hpc shamelessly plugs ghc-man-completion
04:33:59 <eikke> Philonous: also check the "ghc-core" tool
04:34:19 <eikke> (although that might be too low-level for your use-case)
04:36:01 <timbod> jbracker: Hi. Welcome to GSOC.
04:36:16 <jbracker> timbod: Hi, thanks!
04:36:18 <fosskers> elliott: is that a ghc flag?
04:36:30 <elliott> yes
04:36:30 <jbracker> timbod: Want to come over to haskell-gsoc?
04:36:35 <shachaf> @where gsoc
04:36:35 <lambdabot> #haskell-gsoc | http://www.google-melange.com/gsoc/org/google/gsoc2013/haskell
04:36:44 <timbod> jbracker: sure
04:37:10 <craigInnes> Hi, I am trying to use the cairo graphics package to draw images with a gtk2hs backend. Most of the tutorials i have found on how to do this seem to be outdated (the commands they use dont match up with the current api documentation). So far it seems like i need to create some sort of "surface" on the cairo end and link it up to a "drawingArea" on the gtk end. Can anyone help me out?
04:38:15 <hpc> craigInnes: you create a gtk element, i forget which one
04:38:17 <timbod> I'm trying to install the haskell platform on a mac for the first time (for a talk tomorrow). Should I install the 32 or 64 bit version? Does it depend on my machine, or just my preferences?
04:38:30 <hpc> craigInnes: then get the surface out of it to use with cairo
04:38:45 <Botje> timbod: 64bit is probably better, performance-wise.
04:39:10 <timbod> It doesn't depend on anything else being installed "64 bit
04:39:13 <timbod> "
04:39:31 <Botje> most of osx is 64 bit already.
04:39:41 <fosskers> elliott: thanks
04:39:49 <shachaf> timbod: At one point the 32-bit version was recommended, on OS X, because the 64-bit version had bugs.
04:40:07 <shachaf> I don't know whether those are fixed. If they are, you probably want the 64-bit version.
04:40:26 <andrea_> does someone have experience with a gui?
04:40:36 <andrea_> wxhaskell or gtk2hs ,what is easier to learn ?
04:41:09 <hpc> andrea_: both are fairly close bindings to their underlying libraries
04:41:24 <craigInnes> hpc: I am assuming it might be drawingArea which is the correct element? I am not sure how I go about "getting the surface out of it" though. I am currently looking through the cairo api and it seems the only functions for creating surfaces are to make them from scratch e.g "createImageSurface"
04:41:27 <hpc> i have heard that wx is easier, but if you already know gtk you might have better luck with that
04:41:32 <timbod> shachaf: Thanks. It's only for a demo. So I'll just choose 32 bit on the assumption that it may be more reliable.
04:41:42 <craigInnes> hpc: maybe I am looking in the wrong place?
04:42:06 <fosskers> wow, got a hell of a dump
04:42:11 <hpc> craigInnes: look in gtk
04:42:30 <hpc> craigInnes: everything should be there except Render
04:42:46 <hpc> i have to leave and can't help much futher, though
04:43:20 <merijn> Botje: What...
04:43:31 <merijn> Botje: 64bit will likely be worse than 32bit performance wise
04:43:55 <merijn> He probably wants 32bit unless he explicitly knows he wants 64bit
04:44:07 <andrea_> in past i worked with qt but i don't like it, in c++ gtk is more difficult than wx, i think
04:44:13 <Botje> oh, really?
04:44:20 <Botje> I thought 64 bit would do better because it has more registers
04:44:46 <merijn> Botje: Yes, increased pointer size means anything with indirection (like everything in haskell!) will wreck your caches
04:45:29 <andrea_> is htk an alternative ?
04:45:37 <merijn> Basically, 32bit is usually faster than 64bit, so assume that, until proven otherwise through benchmarks
04:45:38 <Botje> oh, brr
04:45:43 <Botje> right :[
04:45:53 <Botje> (can't we have x32 already)
04:45:57 <andrea_> tk is easier than gtk and wx widgets
04:46:04 <shachaf> merijn: No, assume nothing until proven something.
04:46:06 <elliott> I think the Haskell Tk bindings are all ancient.
04:46:08 <andrea_> does someone use htk ?
04:46:14 <elliott> and so probably unusable now
04:46:21 <shachaf> There are lots of advantages to x86-64.
04:48:40 * hackagebot rabocsv2qif 1.1.5 - A library and program to create QIF files from Rabobank CSV exports.  http://hackage.haskell.org/package/rabocsv2qif-1.1.5 (SanderVenema)
04:53:41 * hackagebot Monadius 0.99 - 2-D arcade scroller  http://hackage.haskell.org/package/Monadius-0.99 (HideyukiTanaka)
04:55:37 <Aetherspawn> "Monadius" hrnng.
04:57:53 <shachaf> Aetherspawn: You're Ghoul_?
04:58:18 <Aetherspawn> ;__; am I famous for being stupid or something
04:58:24 <Aetherspawn> Ghoul_ is my BNC.
05:23:41 * hackagebot xdot 0.2.3.1 - Parse Graphviz xdot files and interactively view them using GTK and Cairo  http://hackage.haskell.org/package/xdot-0.2.3.1 (DennisFelsing)
05:24:25 <yezariaely> Is there some magic function doing the following? type: (a,b) -> (a,a), denotationally: (x,y) -> (x,x)
05:24:33 <yezariaely> and for the second element, too?
05:24:49 <shachaf> What does "denotationally" mean?
05:24:50 <yezariaely> simpler than (fst p,fst p)
05:24:52 <elliott> f (a,_) = (a,a)?
05:25:01 <elliott> that's a pretty weird function to want
05:25:03 <shachaf> There's no function in the standard library that does this.
05:25:16 <Cale> (\(x,y) -> (x,x)) is about as short a name as you could reasonably ask for
05:25:20 <FreeFull> yezariaely: What do you mean by simpler?
05:25:25 <Cale> and it's self-descriptive
05:25:41 <yezariaely> sometimes there is some arrow magic or lens magic which handles such things.
05:25:53 <elliott> you could say: fst &&& fst
05:26:02 <elliott> or even join (&&&) fst. if you really wanted to.
05:26:11 <shachaf> Don't want to.
05:26:42 <yezariaely> :t fst &&& fst
05:26:43 <lambdabot> (c', b) -> (c', c')
05:26:54 <yezariaely> :t &&&
05:26:56 <lambdabot> parse error on input `&&&'
05:27:02 <yezariaely> :t (&&&)
05:27:03 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
05:27:28 <yezariaely> hmm I see, that's way to complex ;-) thx, anyway
05:27:49 <FreeFull> For the -> Arrow, that type is (b -> c) -> (b -> 'c) -> (b -> (c, c'))
05:31:21 <jonkri> Since Read and Show is not supposed to used for serialization (and that the Show instance ideally should be Haskell code), would it make sense to offer a new type class for values that have a canonical Text/String representation?
05:31:21 <lambdabot> jonkri: You have 1 new message. '/msg lambdabot @messages' to read it.
05:32:01 <jonkri> Hi, dmwit! :-)
05:33:14 <jonkri> (For things like e-mail addresses, URLs, and so on.)
05:34:12 <merijn> jonkri: The IsString class?
05:34:20 <shachaf> Cale: Can you publish State/quotes somewhere semiregularly?
05:34:27 <merijn> Oh, wait. That's the reverse
05:34:31 <shachaf> Just a copy on a web server or something.
05:44:25 <jonkri> merijn: I want to go in both directions, a -> String/Text, and String/Text -> a. I also want parsing to be able to fail in a predictable way, perhaps by String/Text -> Maybe a
05:46:40 <elliott> jonkri: there's no need for such a thing to be a typeclass, really
05:46:56 <elliott> prettyURL :: URL -> String; url :: Parser URL and you're done
05:50:36 <jonkri> elliott: Could it not be useful for, for example, libraries that parses between strings and values? For example, for a library such as <http://hackage.haskell.org/package/xml-picklers>.
05:55:31 <elliott> jonkri: seems like it'd want its own typeclass
05:55:32 <Philonous> elliott:  Just as there is no need for the Show and Read classes?
05:56:24 <elliott> Philonous: for what Show/Read are useful for, they're invaluable. if we had to live without them we'd invent them quickly; I don't feel such a pressing need for the use-cases of a less programmer-oriented String conversion setting
05:57:03 <elliott> typeclasses are what I turn to only when everything more direct proves overly tedious :)
05:58:59 <Philonous> elliott:  It's not only about tedium, but rather being able to write polymorphic code
06:00:57 <mgore> hi all, got a question regarding GTK+
06:01:05 <elliott> Philonous: yes, but function parameters serve that purpose first and foremost
06:01:06 <jonkri> elliott: I share Philonous' concern. "url :: Parser URL" is dependent on a specific kind of parser, is it not? With a type-class, the String serialization operations would be the same for all implementing types.
06:01:33 <elliott> jonkri: well, if you want parsing, then you want parser combinators. you know Read ties you to a specific kind of parser with its own parser combinators, right?
06:01:55 <mgore> the Gtk2hs project seems to publish a seperate package for gtk3. does anyone know the status of that package, or when it'll be available?
06:03:13 <Philonous> elliott:  Sure you can pass around your own instance dictionaries everywhere. But why would you want to do that?
06:05:15 <elliott> Philonous: I am concerned -- higher-order programming is derided as dictionary passing now? after all, many :: Parser a -> Parser [a] could just be many :: Parseable a => Parser [a] or even instance Parseable a => Parseable [a]... I'm not anti-typeclass, but combined with the ambiguity of such typeclasses (defining a "canonical" String representation -- but canonical for what purpose?) and (AFAICT) no strong evidence of saving a lot of boilerplate by
06:05:22 <elliott> that may have gotten cut off.
06:07:18 <jonkri> elliott: It ended with "boilerplate by".
06:07:37 <elliott> -- structuring it as a typeclass, I'll err on the side of values
06:07:38 <elliott> jonkri: thanks
06:07:51 <jonkri> elliott: :-)
06:17:00 <Philonous> elliott:  Your Parseable example doesn't work out because there's no unique way of combining parsers on a into parsers on [a]. But if there was, what would we gain from having to mention it every time?
06:22:15 <elliott> well, there isn't any uniqueness here. there are multiple ways to turn values into Strings and back, which is the whole point (Show/Read being inappropriate)
06:22:52 <elliott> even if you privilege certain conversions as canonical on a per-type basis, you need cohesion between *all* the types with such canonical conversions, otherwise there's no structural commonality to exploit with a typeclass
06:23:24 <Philonous> Ah, but the Class was for values that have a canonical representation, like email address, URLs. If there's no unique way to convert it to a string, it does indeed make little sense
06:23:40 <elliott> "myGenericParser" vs. "myURLParser" is really not very different. the latter may even be less verbose because it will never require type disambiguation
06:23:50 <elliott> similarly for "myGenericShower url" vs. "myURLShower url"
06:24:27 <elliott> even if you do write something polymorphic over this generic conversion stuff, you'd still want to expose one that takes regular parameters, for cases when you have a _non_-canonical conversion
06:25:06 <elliott> so in the end, I really don't think you save much, coupled with the unclear meaning meaning of the typeclass and the overhead of it having to have a place to go to be designated as something "standard", etc.
06:45:29 <eikke> ok, this stm stuff is pretty damn great
06:47:17 <fryguybob> eikke: :D
06:47:28 <eikke> I have some code which should handle packets comming from a network, or do something else when some timeout occurs, so it should block on both conditions, and prefer handling the timeout if it occurred, then continue handling messages. Thanks to STM, the timeout can be a TMVar, my message thing can push stuff on some TChan-like thing, and my main code can "readTVar `orElse` readTChan"
06:47:44 <eikke> in other systems I'd need some complicated priority heap and whatnot
06:48:40 <eikke> (hmh, should be readTMVar above, etc, but whatever)
06:52:38 <simon> for some reason, I get: Could not find module `Control.Monad.Writer'. shouldn't it be in the standard library?
06:53:17 <eikke> it's in 'mtl'
06:54:16 <byorgey> simon: you should already have it if you installed the Haskell Platform
06:54:52 <byorgey> simon: if you are on debian or Ubuntu, they have split up the Haskell packages rather finely so you may need to install another package
06:55:26 <simon> I installed it now. I'm not sure why it was missing, it hasn't always been. byorgey, I use cabal in Arch Linux.
06:55:26 <byorgey> simon: if neither of those apply, then you'll have to explain your situation =)
06:55:29 <mux> unordered-containers & attoparsec in the haskell platform. yummy !
06:56:15 <byorgey> simon: ah, ok.  just make sure 'mtl' is listed only once in the output of 'ghc-pkg list'
06:56:31 <elliott> every time HP gets new packages I'm surprised it doesn't already have some of them
06:56:48 <byorgey> elliott: I think that's the ideal situation =)
06:59:49 <neutrino> byorgey++
07:00:10 <byorgey> neutrino: thanks, what's that for?
07:00:25 <neutrino> 15:56 < byorgey> elliott: I think that's the ideal situation =)
07:00:45 <byorgey> heh =)
07:01:50 <quchen> Why is the platform not a usual package you can install with Cabal anyway? To take some stress off the Hackage servers?
07:03:13 <byorgey> quchen: that doesn't really make sense.  The platform is GHC + tools like cabal + standard packages (some of which are needed for the GHC installation).
07:03:28 <byorgey> quchen: so by the time you have enough stuff to even be able to run cabal, you have most of the platform anyway.
07:03:45 <quchen> byorgey: I don't think so. The platform does not include GHC.
07:04:05 <quchen> (And I just looked at the file, it's 2.4 MB for me, so the traffic argument doesn't hold)
07:04:22 <eikke> the platform should be a package which exports all modules contained in the platform, so one can depend on "haskell-platform-2013.2" in a cabal file without listing anything else
07:04:22 <byorgey> quchen: that is false.  The platform does include GHC on Windows + Mac.
07:04:25 <eikke> :P
07:04:42 <byorgey> now, there IS actually a cabal package for the platform
07:04:44 <eikke> (^^ that was not a serious proposal)
07:05:45 <byorgey> but putting it on Hackage would not work very well, for various reasons.  (Those reasons do not include taking stress off the Hackage servers.)
07:06:21 <quchen> And what are those reasons?
07:06:36 <byorgey> for one thing, you usually want the HP packages installed in the global package DB, and other things in user.
07:07:01 <byorgey> letting users manage this manually themselves by cabal-installing it just makes it easier for new users to shoot themselves in the foot.
07:07:47 <quchen> The "GHC+Platform is the Haskell standard library" argument is convincing.
07:08:55 <quchen> On the other hand, it's odd that there's no option to install it as a package either.
07:09:19 <quchen> Oh well, I'll just take it as it is then.
07:13:43 * hackagebot Elm 0.8.0.3 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.8.0.3 (EvanCzaplicki)
07:14:07 <timbod> I'm using hGetLine on a new installation on the platform on osx. Oddly, it seems to be reading the whole file in one go, and ignoring the line breaks.
07:14:37 <timbod> This seems to happen with both System.IO.hGetLine, and also ByteString.hGetLine.
07:30:28 <geekosaur> woo, HP 2013.2
07:31:52 <Ankhers> When did this happen?
07:32:46 <geekosaur> announcement sent ~ 9 hours ago
07:34:05 <Ankhers> awesome, thanks.
07:49:57 <Sculptor> yo
07:54:30 <Ankhers> What up
08:13:00 <allsystemsarego> Hi all, how does one exit a "forever" loop upon a certain condition being met, in do notation?
08:14:35 <beaky> hello
08:14:40 <beaky> :t (<*>)
08:14:56 <lambdabot> thread killed
08:14:57 <beaky> if <$> is the fmap symbol, what is the name of the <*> symbol?
08:15:12 <ozgura> beaky: ap?
08:15:25 <ozgura> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#v:ap
08:15:33 <mekeor> allsystemsarego: i suppose you're not supposed to do that. (?)
08:15:33 <beaky> :t ap
08:15:37 <beaky> ah
08:15:42 <lambdabot> Monad m => m (a -> b) -> m a -> m b
08:16:26 <beaky> (,) `fmap` [1..3] `ap` [False]
08:16:28 <beaky> > (,) `fmap` [1..3] `ap` [False]
08:16:31 <lambdabot>   [(1,False),(2,False),(3,False)]
08:16:35 <beaky> wow this is awesome
08:16:38 <beaky> what does ap mean?
08:17:42 <mekeor> maybe "fmap" without "fm" or "map" without "m" or probably "ap" for "applicative"?
08:17:53 <dmwit> (it's the last one)
08:17:53 <beaky> ah
08:17:53 <shanse> apply
08:18:24 <beaky> wow applicative is awesome
08:20:04 <tgeeky> Improve Haddock Markup and Capabilities by Fūzetsu, mentored by Simon
08:20:12 <tgeeky> ^^ does anyone know the irc handles of either of those people?
08:20:17 <tgeeky> Simon Hengel*
08:20:43 <beaky> :t join
08:20:46 <lambdabot> Monad m => m (m a) -> m a
08:21:00 <beaky> > join [ [3] ]
08:21:02 <lambdabot>   [3]
08:21:05 <mekeor> beaky: you might want to /msg lambdabot ...
08:21:08 <beaky> ah thanks
08:21:11 <mekeor> :)
08:21:48 <beaky> how does join work
08:22:02 <mekeor> @src join
08:22:02 <lambdabot> join x =  x >>= id
08:22:13 <beaky> wow
08:22:38 <byorgey> tgeeky: Fuuzetsu and solirc
08:22:46 <tgeeky> byorgey: thank you sir
08:23:20 <byorgey> beaky: it works in a different way for each monad.
08:23:23 <allsystemsarego> mekeor, why is it a bad idea?
08:23:36 <schoppenhauer> hello. is there any useful method of debugging for haskell? I am trying +RTS -xc, but the stack traces are not useful at all.
08:23:50 <merijn> schoppenhauer: Have you looked at Debug.Trace.trace?
08:23:59 <allsystemsarego> mekeor, why is it a bad idea?
08:24:01 <mekeor> allsystemsarego: uhm, i didn't (meant to) say that it's a bad idea. i just think it's not possible (elegantly).
08:24:15 <mekeor> but i might be wrong! ;)
08:24:17 <allsystemsarego> ok, thanks
08:24:22 <byorgey> allsystemsarego: if you want to do something forever, you use 'forever'.  If you don't want to do something forever (i.e. if you want to stop), you don't use 'forever'.
08:24:23 <schoppenhauer> merijn: yes. but then I would have to tag all functions.
08:24:37 <schoppenhauer> merijn: when I could actually just see a real backtrace of the evaluated stuff
08:24:49 <allsystemsarego> byorgey, it's the event loop for a game
08:24:50 <mekeor> byorgey: you're a good explanatorian
08:25:03 <merijn> schoppenhauer: I'm not really sure what type of code you're debugging, so I'm not quite sure what the best approach would be
08:25:03 <mekeor> :D
08:25:10 <byorgey> allsystemsarego: you might be interested in something here: http://hackage.haskell.org/packages/archive/IfElse/0.85/doc/html/Control-Monad-IfElse.html
08:25:22 <Fuuzetsu> tgeeky: can I help?
08:25:24 <allsystemsarego> thanks, I'll have a look
08:25:25 <schoppenhauer> merijn: isn't there any possibility to just get a trace of the whole calling stack?
08:25:37 <schoppenhauer> merijn: that is, chain of called functions, etc.?
08:26:00 <schoppenhauer> merijn: or at least the part of the source, where the error occurs?
08:26:07 <schoppenhauer> merijn: line and char, etc.
08:26:17 <tgeeky> Fuuzetsu: uh, no, not yet. I just wanted to be a fly on the wall to improvements and the direction you guys are taking with haddock.
08:26:24 <geekosaur> there is no calling stack, there is a pattern match stacl
08:26:27 <geekosaur> 8stack
08:26:51 <geekosaur> (no, this is not the same thing under a different name)
08:26:52 <Fuuzetsu> tgeeky: The overview is here: https://gist.github.com/jbracker/6d4f6515fecb117166db
08:27:16 <schoppenhauer> geekosaur: well, at least the position in the source code would be helpful.
08:27:31 <schoppenhauer> geekosaur: like usual debug information one gets in ... most other languages.
08:27:59 <klugez> schoppenhauer: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html - Still no "real" stack trace, but some help.
08:29:19 <tgeeky> Fuuzetsu: bookmarked, and reading. If you could guess, would you say that there are too few goals to keep you busy, or too many? or just right?
08:29:41 <merijn> schoppenhauer: But what would that chain show? I don't really see how a stack trace would make sense in a lazy setting
08:30:10 <schoppenhauer> merijn: what sense do errors make in a lazy setting?
08:30:35 <schoppenhauer> merijn: is it possible to get the code-position of the code causing the error?
08:31:11 <merijn> schoppenhauer: For your own code, yes. For library code, I don't know
08:31:27 <Fuuzetsu> tgeeky: Honestly, I'm unsure. I'm fairly confident I can finish everything outlined before the end of the summer but you should mind that I have no experience working on the Haddock source code so I might be grossly wrong. The most important part seems to be porting it to Attoparsec as that enables us to do everything else.
08:31:46 <schoppenhauer> merijn: how do I get it for my own code?
08:31:49 <merijn> There is a line number macro, which you could use input to "error" to your own code.
08:31:57 <merijn> schoppenhauer: What error is your code dying on?
08:32:17 <Fuuzetsu> If it turns out that I finish early, there is a fair amount of bugs on Haddock Trac that are just waiting to be stumped, not to mention that some additional features might come up later.
08:32:35 <schoppenhauer> merijn: Map.find: element not in the map
08:32:58 <Fuuzetsu> Feel free to follow me on GitHub where I'll be pushing the code as I work with it (before it goes into the main repository): https://github.com/Fuuzetsu
08:33:00 <tgeeky> Fuuzetsu: ok. One thing I don't even know if you want to tackle, or if it's even if I'm correct about it needing doing, but if I recall correctly, there are many GHC core modules which are written in .lhs and whose docs don't get generated now
08:33:04 <dmwit> Fuuzetsu: Any project that starts with "step one: parse Haskell" sounds like a big one to me. =)
08:33:49 <merijn> schoppenhauer: That sounds like you're using (!) in your code...
08:34:00 <schoppenhauer> merijn: yes
08:34:14 <Eduard_Munteanu> :t Data.Map.lookup
08:34:16 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
08:34:21 <sclv_> We don't need to parse full haskell i think?
08:34:23 <Fuuzetsu> dmwit: Well, it's not like I'm starting from scratch *positive*
08:34:24 <merijn> (!) is terrible to use if you're not sure about a key existing in your map
08:34:37 <sclv_> We're just changing how we parse the haddock bits
08:34:42 <Fuuzetsu> ^
08:34:49 <sclv_> the former is outrageous -- the latter very tractable :-)
08:34:53 <Fuuzetsu> Well, there is some new stuff to parse like GADTs
08:35:00 <merijn> schoppenhauer: lookup should be preferred, lookup returns Maybe, which means the compiler will check whether you handle the case of a missing element
08:35:04 <dmwit> sclv_: Oh, yes, okay.
08:35:23 <Fuuzetsu> tgeeky: That's not really in scope of the project as-is but why aren't they getting generated?
08:35:25 <byorgey> step one: reimplement haskell-src-exts. step two: tear out hair.
08:35:30 <Fuuzetsu> Do you know? Is there a ticket?
08:35:31 <schoppenhauer> merijn: it is obviously a bug. probably some +-1-stuff. now, is it possible to get the position of the sourcecode causing that error, or is it not?
08:35:36 <dmwit> byorgey: yeah =)
08:35:59 * byorgey <3 haskell-src-exts
08:36:07 <merijn> Maybe? I've never had to try
08:36:11 * tgeeky <3 haskell-src-meta :o
08:36:39 <schoppenhauer> ok ... 20 minutes of discussion wasted ...
08:37:01 <tgeeky> schoppenhauer: nonsense! You learned enough to know you wasted your time! That's not a waste of time!
08:37:13 <merijn> tgeeky: That's not very helpful
08:37:58 <tgeeky> Fuuzetsu: http://hackage.haskell.org/package/base many of the GHC.*** files I think are .lhs files that aren't being turned into Haddock?
08:38:05 <sclv_> they're not generated because they don't have haddocks!
08:38:18 <Eduard_Munteanu> schoppenhauer: maybe using ghci debugging facilities, e.g. :set -fbreak-on-exceptions
08:38:55 <Eduard_Munteanu> Erm, -fbreak-on-exception
08:38:56 <sclv_> oh the ones where nothing at all is generated...
08:39:14 <Fuuzetsu> tgeeky: Anything without docks and/or that isn't exported clearly won't have docs generated for it…
08:39:15 <sclv_> yeah that's unrelated. i don't remember the details.
08:39:32 <Fuuzetsu> Do you have any specific examples where you believe docs should be generated but aren't?
08:39:46 <beaky> why is it easy to define a monad typeclass in haskell, but impossible to do so in a language like c++ or java?
08:39:57 <tgeeky> Fuuzetsu: I was looking for some, but they are all not generated so I can't get a link easily :o
08:40:01 <Fuuzetsu> beaky: You can have Monads in Java.
08:40:07 <beaky> ah
08:40:11 <Fuuzetsu> http://logicaltypes.blogspot.co.uk/2011/09/monads-in-java.html
08:40:15 <beaky> wow
08:40:16 <osfameron> you may not get some of the syntactic convenience
08:40:32 <tgeeky> Fuuzetsu: http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/src/GHC-Num.html
08:40:49 <tgeeky> Fuuzetsu: # hide :(
08:41:09 <Philippa> beaky: to the extent you can't do it, it's generally because they don't support "higher kinds" in any useful form. A monad's type constructor has kind * -> *, doing anything with that requires a kind that'll take that as a parameter
08:41:26 <schoppenhauer> Eduard_Munteanu: it still just sais "Stopped at <exception thrown>" ... and not the file position ...
08:41:30 <Philippa> (including the kind of the Monad typeclass/constraint, for those in a nitpickier-than-thou mood)
08:41:30 <beaky> I thought java had generics, which are like higher kinds
08:41:38 <Fuuzetsu> tgeeky: hide will still generate if it's the only exporting module but otherwise the exported stuff will be generated in the mother module
08:41:42 <Eduard_Munteanu> schoppenhauer: you can ask for a backtrace, I forget how
08:41:51 <schoppenhauer> Eduard_Munteanu: ok
08:41:52 <Fuuzetsu> After all, you still get docs for Num.
08:42:12 <tgeeky> Fuuzetsu: http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/GHC-Num.html
08:42:21 <Philippa> beaky: "generics"/parametric polymorphism doesn't necessarily support higher-kinded parameters - sometimes they only support a first-order kind
08:42:24 <Fuuzetsu> http://www.haskell.org/haddock/doc/html/hyperlinking.html
08:42:26 <schoppenhauer> Eduard_Munteanu: ah, using :trace and :hist. finally what I was looking for. Thank you.
08:42:36 <Philippa> (whether that's still the case with Java I don't know: I haven't used the language remotely seriously in a decade)
08:42:46 <tgeeky> Fuuzetsu: oh, I see what you mean. I thought this was a problem with haddock and .lhs, but it's just that everything is intentionally hidden and exported elsehwere.
08:42:51 <beaky> ah
08:43:21 <Fuuzetsu> tgeeky: Prelude re-exports it and gets picked as a home module http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Num
08:43:25 <tgeeky> Fuuzetsu: the actual thing I wanted to change is like this: http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/src/GHC-ST.html
08:43:39 <tgeeky> Fuuzetsu: where there are comments "definition of runST" which nobody can see except in the source view
08:44:33 <tgeeky> Fuuzetsu: but I realize that this is not even close to being related to your project, so you can ignore all of this.
08:44:45 <Fuuzetsu> Ah. I… don't believe that's currently supported. Would you just have LaTeX macros stripped and parse it as-is as Haddock?
08:45:23 <Fuuzetsu> Sure, it's not very related but it doesn't mean I'm not interested~ You should consider filing a feature request or something.
08:45:45 <tgeeky> Fuuzetsu: let me run some code to find out how much of this (missing comments) there is
08:45:49 <tgeeky> Fuuzetsu: I'll get back to you
08:45:56 <dav> so x <- readLn :: IO Integer works in ghci but x <- readLn :: IO String doesn't ("no parse" exception). Any ideas?
08:46:32 <eikke> dav: did you quote the input?
08:46:54 <dav> eikke: no. readLn is the inverse of show?
08:47:15 <dav> eikke: works now, thanks.
08:47:16 <eikke> 'read' is supposed to be the inverse of 'show', and readLn uses read
08:47:18 <eikke> so yeah :)
08:47:20 <quicksilver> more like the inverse of print
08:47:24 <dav> thanks :)
08:47:26 <beaky> What is the difference between a monad and a monoid?
08:47:28 <quicksilver> readLn from stdin, print to stdout
08:47:35 <dmwit> beaky: monads are typed monoids
08:47:41 <dmwit> alternately, monoids are monads with only one type
08:47:47 <dmwit> wait
08:47:49 <Fuuzetsu> wut
08:47:55 <beaky> so monads have an extra type?
08:47:56 <dmwit> No, *categories* are typed monoids.
08:48:00 <dmwit> I need more sleep.
08:48:07 <dav> dmwit: I was shot down at a haskell meetup last week when a pointed out that monoids looked like monads
08:48:19 <Fuuzetsu> beaky: http://www.youtube.com/watch?v=ZhuHCtR3xq8
08:48:21 <dmwit> dav: You're not wrong. Monads are monoids in a particular category.
08:48:24 <eikke> for starters, the kind of monoids and monads is different
08:48:38 <dav> dmwit: the append operation looked like bind..
08:48:46 <beaky> :k return
08:48:47 <dmwit> Heck, just look at the laws: f >=> (g >=> h) = (f >=> g) >=> h and f >=> return = return >=> f = f
08:48:47 <lambdabot> Not in scope: type variable `return'
08:48:53 <dmwit> dav: They're just like the monoid laws.
08:49:18 <dmwit> dav: The only difference is that for monoids, all those (>=>) operations are the same one, but for monads you've got a bunch of different ones for each type. =)
08:49:20 <beaky> :t (>=>)
08:49:22 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
08:49:26 <dmwit> (one different one for each type, I mean)
08:50:16 <Philippa> dav: you just met the tendency for some people to shoot down informal statements just because they can't see how they might be right. Too common, alas :-(
08:50:51 <jamy> Hello! I has:  type FirstType = (OtherType, OtherType)
08:51:01 <Philippa> and yes, you're entirely right as dmwit is saying. Also, feel free to snark at people who conflate monad/monoid (the mathematical concepts, embedded however you like) with Monad/Monoid (the Haskell typeclasses)
08:51:36 <jamy> And i has mkFirstTYpe :: [OtherType] -> FirstTYpe
08:51:38 <byorgey> dmwit: the fact that monads are monoids in a particular category is not related to the category structure of (>=>)
08:51:42 <Lethalman> is it possible to say data Foo a = Foo a such that "a" is not Bar ?
08:51:51 <Philippa> As a community, we should reward people for having the right intuition, not punish them for not being able to turn it into a formal statement!
08:52:20 <byorgey> dmwit: with "monads are monoids in the category of endofunctors", the monoidal operation being talked about is 'join'
08:52:31 <dav> Philippa: yes I don't have the background required to defend my intuitive statements..
08:52:32 <merijn> Lethalman: Yes, if you have 7.7 and don't mind using TypeFamilies! (In other words "maybe")
08:52:57 <merijn> Lethalman: What are you trying to do?
08:52:58 <jamy> like this: mkFirstType (OtherType:OtherTYpe:[]) = ????
08:53:05 <Philippa> dav: right, but you shouldn't have to. Others should be trying to work out what they're referring to and helping you explore them!
08:53:17 <byorgey> well "not related" is too strong I'm sure, everything is related =)
08:53:53 <mekeor> jamy: i guess you're mixing up lists and pairs.
08:53:54 <monochrom> Philippa, that is how the communities of New Age and Postmodernism works. that is anti-scientific.
08:54:22 <merijn> monochrom: No it's not
08:54:23 <jamy> And my question how to construct instance defined throw "type" keyword?
08:54:34 <quicksilver> byorgey: well, dmwit's laws are the statement that Kleisli m is a category
08:54:34 <dav> Philippa: in all fairness, there was like 2 minutes left in the meetup and the guy had to cover monoids, functors and monads in those remaining minutes so maybe he just didn't have time to explore this with me :)
08:55:04 <quicksilver> byorgey: and it's a fairly basic theorem that T is a Monad if and only if Kleisi(T) is a category
08:55:06 <jamy> if FirstType is the alias to the pairs
08:55:11 <merijn> monochrom: Philippa didn't say "accept all handwavey nonsense" she said that people shouldn't be so brutal in striking down informal intuitions
08:55:15 <byorgey> quicksilver: indeed.
08:55:18 <quicksilver> byorgey: so they're the same thing and, yet, they're not the same thing
08:55:25 <quicksilver> byorgey: depends how many theorems you're allowed to assume :)
08:55:29 <Philippa> monochrom: *sigh*. No, it's not in the slightest. Anti-scientific is when you insist that *novel* or *unproven* claims be taken as gospel until shown otherwise. WTF that has to do with individual learning, I don't know
08:55:51 <quicksilver> it's certainly "not a coincidence" that when you right them down formally the kleisli equations resemble the monoid equations.
08:55:53 <merijn> monochrom: I've encountered that tendency a couple of time here too, where my informal intuition gets struck down over some obscure edge case
08:55:54 <byorgey> quicksilver: I was just pointing out that if you unpack the definition of "monads are monoids in a category of endofunctors" you get some statements about join and return, not (>=>) and return.
08:55:57 <quicksilver> s/right/write/;
08:56:09 <quicksilver> byorgey: and I was agreeing with you and making the correspondence more precise?
08:56:16 * applicative hadn't realized that the logical principles were 'anti-scientific'
08:56:19 <byorgey> quicksilver: ok, fair enough
08:56:20 <Philippa> it's actually a necessary part of science that people explore what /might/ be in a slightly less critical fashion in order to generate more accurate/useful hypotheses
08:56:39 <merijn> See this quote I love
08:56:44 <merijn> Suppose that you want to teach the 'cat' concept to a very young child. Do you explain that a cat is a relatively small, primarily carnivorous mammal with retractible claws, a distinctive sonic output, etc.? I'll bet not. You probably show the kid a lot of different cats, saying 'kitty' each time, until it gets the idea. To put it more generally, generalizations are best made by abstraction from experience.
08:56:50 <merijn> - R. P. Boas (Can we make mathematics inelligible?, American Mathematical Monthly 88 (1981), pp. 727-731)
08:57:38 <Philippa> merijn: yeah. I'm maybe a little brutal when some kinds of not-totally-accurate intuition are phrased as The Truth, but otherwise I try to do that in a "here are some things to think about for refinement" way if I can
08:57:42 <jamy> And one more time: How to construct instance defined throw "type" keyword if FirstType is the alias to the pairs?
08:57:53 <monochrom> I am objecting to the part "other people should help you to". other people aren't obliged. especially not obliged when they judge that there is little chance of success.
08:58:24 <Philippa> monochrom: *shrug*. Not all "should" is obligation
08:58:45 * hackagebot snap-extras 0.6 - A collection of useful helpers and utilities for Snap web applications.  http://hackage.haskell.org/package/snap-extras-0.6 (DougBeardsley)
08:58:56 <Philippa> (also: I take it your previous claim is withdrawn?...)
08:59:07 <monochrom> ok. the inventor is free to explore more and speak more sense. sure.
08:59:08 <merijn> monochrom: I don't think people *have* to help, but I do think their is a moral duty that *if* you're not going to help, at least don't be counterproductive by just telling people "that's wrong!"
08:59:13 <byorgey> jamy:  mkFirstType (other1:other2:[]) = (other1, other2)
08:59:38 <byorgey> jamy: the 'type' keyword defines a type *synonym*, that is, type A = B  means types A and B are exactly the same
08:59:49 <jamy> mkFirstType :: [OtherType] -> FirstType
08:59:53 <byorgey> jamy: so there's nothing special you need to do to construct one
09:00:25 <Philippa> merijn: quite. If you don't see it yourself, communicate /that/ and don't communicate the expectation that if it were there, you'd see it.
09:00:48 <Philippa> (that last bit being something that's often communicated via 'implicit' and/or non-verbal means, of course)
09:01:08 <applicative> monochrom: if they meant people on #haskell, then no, they are under an obligation. no one has a right to speak here at all except that they are willing to help people including even unusually stupid people, if you like; this pretty well follows from what it says on the wiki
09:01:12 <jamy> byorgey: Would be other way to construct?
09:01:38 <applicative> monochrom: lame grammar and typing are allowed, though, I think...
09:02:08 <Lethalman> merijn, ok, I was looking at: http://twistedoakstudios.com/blog/Post4008_collapsing-futures-easy-to-use-hard-to-represent
09:02:16 <byorgey> jamy: I don't understand your question.
09:02:37 <dmwit> byorgey: well, yes
09:03:06 <Philippa> honestly? I think the biggest tragedy of "everything must be formal" is watching people try to bury their informal-at-this-stage yet valid concerns behind unsound formal arguments
09:03:21 <Philippa> "People don't have the right to (D)DoS me for help" is perfectly legit
09:03:45 * hackagebot restful-snap 0.1.1.1 -   http://hackage.haskell.org/package/restful-snap-0.1.1.1 (DougBeardsley)
09:03:45 <merijn> Lethalman: ok, I don't have the time to read that entirely, but after skimming it looks like you want to do something like "Foo a = if a == sometype then Bar a else SomeOtherType"?
09:03:49 <applicative> one shouldn't show "WHY WONT THIS TYPECHECK?" in a crowded theater
09:04:09 <beaky> if types are kinda like sets, is there a way to define types that are a set intersection of types, a set union of types, or a set product?
09:04:12 <applicative> shout for show
09:04:21 <merijn> Lethalman: (At the type level, I mean)
09:04:25 <Philippa> beaky: yep. 2-tuples are products, for example
09:04:29 <beaky> ah
09:04:47 <Philippa> intersection and union types are... complicated and with good reasons to be wary of them, though Either gives you disjoint union
09:04:58 <beaky> type set unions are interesting :D
09:04:58 <byorgey> beaky: 2-tupes are products, Either is (disjoin) union.
09:05:06 <Lethalman> merijn, I think it's like getValue(Future<Future<...<G>>>) return value should be G
09:05:07 <otters> "Beardsley" is the coolest last name ever.
09:05:09 <jamy> byorgey: because a have error: "Type error in explicitly typed binding ... *** Term: mkFirstType *** Type: [OtherType] -> (OtherType,OtherType)*** Does not match : [OtherType] -> FirstType
09:05:15 <byorgey> beaky: intersection is meaningless in Haskell since all types are disjoint.
09:05:19 <applicative> an (A,B) has to be in both A and B ... except its a different type; an Either A B is in one or the other ... kinda
09:05:40 <Philippa> algebraic datatypes are polynomials built out of disjoint unions and products, in fact
09:05:47 <byorgey> jamy: can you paste your code and error message on hpaste.org?
09:06:07 <arnsholt> Philippa: I think the Gricean maxims are good to have in mind when trying to teach/explain stuff
09:06:21 <merijn> Lethalman: You can do that, yes
09:06:42 <Philippa> byorgey: that's only true of function types /because we don't allow it/, though. An area where polarity matters
09:07:01 <otters> oh, I get it
09:07:10 <Philippa> arnsholt: I have to admit I'm not familiar with those, at least not by that name. Is wikipedia just about trustworthy on that front?
09:07:11 <arnsholt> Of course, they're from a gloriously non-formal part of science, speaking of formal =)
09:07:16 <otters> The number of non-bottom inhabitants of (A,B) is the number of inhabitants of A * the number of inhabitants of B
09:07:23 <otters> whereas the number of non-bottom inhabitants of Either A B is A + B
09:07:33 <osfameron> non-bottom inhabitants!
09:07:33 <beaky> ah
09:07:34 <Philippa> arnsholt: quite! The idea that everything can-and-should be formal is for those who can't do meta
09:07:36 * applicative thinks they come from the only genuinely formal part of 'science'
09:07:42 <otters> right
09:07:44 <merijn> Lethalman: I have something similar implemented using TypeFamilies + GADTs
09:07:46 <otters> s/inhabitants/non-bottom inhabitants/g
09:07:53 <arnsholt> Wikipedia is ok on it. They can be summed up very easily though: Be truthful, be relevant, be succinct
09:08:13 <b_jonas> how about functions thne_
09:08:15 <Lethalman> merijn, ah so it's possible somehow
09:08:22 <beaky> woah
09:08:31 <applicative> Lightning!
09:08:36 <arnsholt> applicative: Depends on what you call formal, I guess. But (natural) languages have a tendency to resist formalisation
09:08:45 * hackagebot snaplet-actionlog 0.2.0.1 - Generic action log snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-actionlog-0.2.0.1 (DougBeardsley)
09:08:53 <merijn> Lethalman: i.e. I have a FFI callback with any number of arguments (gotten from a record) resulting in an IO action and I want to apply that function, statically checking the number of arguments, without having to specify every time what the arguments are
09:09:10 <Philippa> *nod*. I have a few extras I try to follow as well (eg "leave dangling threads and keywords for later where appropriate", "sometimes more structure is relevant/useful"), but yeah
09:09:18 <merijn> Lethalman: Take a look at the apply function in https://github.com/merijn/SNet2.0/blob/master/SNet/Task.hs (plus other modules in the repo)
09:09:36 <Lethalman> ok
09:09:41 <Lethalman> thanks :D
09:09:45 <merijn> Lethalman: I think your example could be done even simpler though, just using typeclass recursion
09:09:52 <Lethalman> ah
09:09:55 <Lethalman> something like printf
09:10:06 <jamy> byorgey: http://hpaste.org/88762
09:10:15 <Philippa> arnsholt: So do the things people use them to talk about. The humanities are /much/ harder work than people from outside them tend to understand, in ways that are more relevant for how we use computers than we generally accept
09:10:16 <Lethalman> basically, if data types were functions, I could write something like rettype (Future g) = rettype g; rettype g = g;
09:10:20 <Lethalman> merijn, ^^
09:10:23 <arnsholt> Philippa: Yeah, teaching is tricksy business. A pedagogics class or two would probably do me some good
09:10:37 <applicative> arnsholt: if by 'formalize natural language' you mean fit all of natural language in a familiar very narrow fragment of human language right, its worse than 'difficult'
09:10:59 <arnsholt> Philippa: Tell me about it! I'm in NLP, and getting linguists and computer scientists to understand each other is a non-trivial problem I think
09:11:04 <b_jonas> "< merijn> Lethalman: I think your example could be done even simpler though, just using typeclass recursion" -- should we addquote this?
09:11:06 <byorgey> jamy: Bool is not the same as Triangle
09:11:13 <Philippa> arnsholt: *nod*. I especially need to learn more about teaching more than one person at once
09:11:13 <merijn> Lethalman: Wouldn't that example already work?
09:11:27 <jonkri> elliott: if we use something like parseAddress "<address>" in the show output, would it be okay to hide away parseAddress in some internal module, or should it be in scope whenever the address type is?
09:11:28 <merijn> b_jonas: Why? It's not particularly funny or insightful?
09:11:42 <byorgey> jamy: you would need to do  mkPyramid (fours:third: ....) = (Triangle first, Triangle second, ...)
09:11:46 <Philippa> heh, yeah, I'm not surprised. I haven't paid enough on the linguist side myself - Ehud Lamm links stuff I /should/ read on LtU once in a while
09:11:57 <b_jonas> it's funny if taken out of context, using something so complicated as typeclass recursion to make something simpler
09:12:12 <Philippa> as it is, I'm too used to adding an extra syllable to "cluster concept", and fed up of dealing with people who expect to never have to reason about cluster concepts
09:12:21 <byorgey> jamy: Pyramid and (Triangle,Triangle,Triangle,Triangle)  are the same
09:12:31 <arnsholt> applicative: That's the blunt way to put it, yeah =)
09:12:39 <byorgey> but since Triangle and Bool are not the same,  Pyramid is not the same as (Bool,Bool,Bool,Bool)
09:12:42 <jamy> byorgey: Thanks!
09:12:54 <Lethalman> merijn, mh I have to study your code first :P it's a little hard to understand, I'm newbie :)
09:12:58 <merijn> Lethalman: Oh, no, wait you do need TypeFamilies to make it typecheck
09:13:19 <Philippa> b_jonas: it's one of those things that's complicated because typeclasses are ever so subtly messier than they need to be because Three (Four-Five?) Decades Of Historical Accidents
09:14:07 <b_jonas> typeclasses have historical accidents? I thought they were reasonable limitations so that the compiler doesn't loop.
09:14:32 <applicative> accident?
09:14:44 <bitonic> not having UndecidableInstances is not an historical accident, if that’s what you mean
09:14:47 <merijn> Lethalman: You probably need 7.7 for this code to work, but I'll show you
09:14:52 <jamy> Its works! Thanks to all!
09:15:25 <applicative> * Overloaded record fields for GHC by Adam Gundry, mentored by Simon
09:15:33 <applicative> Peyton-Jones
09:15:55 <applicative> that is a surprising summer of code scheme ^^^
09:16:17 <Philippa> b_jonas: typeclasses involve a *mass* of historical accidents, including how long it took to realise their relationship to ML-style modules
09:16:17 <Fuuzetsu> IIRC Adam was feeling fairly confident about it
09:16:28 <beaky> they are related tomodules?
09:16:35 <Philippa> and the amount of time the community spent carefully /not/ talking about them in terms of constraint problems
09:16:39 <applicative> Fuuzetsu: you mean that it will be completable, etc?
09:17:09 <monochrom> I hope it works out. it's time to arbitrarily choose one record scheme and make it de facto.
09:17:14 <Fuuzetsu> applicative: I don't remember the details. There's a thread on haskell-cafe if you're interested.
09:17:52 <applicative> oh okay.  gundry I have heard about in connection with Epigram etc.
09:18:17 <Fuuzetsu> http://www.haskell.org/pipermail/haskell-cafe/2013-April/107865.html
09:19:17 <applicative> ah yes
09:19:27 <jonkri> elliott: nevermind :)
09:19:29 <jonkri> are IsString instances allowed to fail?
09:19:52 <Philippa> b_jonas: consider how the development of typeclasses might have gone differently if we had named instances as a sort, but still had to have a solver that does 1:1 type -> instance dispatch?
09:19:57 <jonkri> (in String -> a)
09:20:03 <Philippa> say, if we'd had those before we had constructor classes?
09:21:22 <Fuuzetsu> jonkri: fromString shouldn't fail… I imagine bad things would happen
09:21:33 <Fuuzetsu> I'm guessing runtime errors
09:21:44 <jonkri> Fuuzetsu: thanks :)
09:22:11 <b_jonas> Philippa: I don't understand what you just said. It seems to go over my head.
09:22:37 <b_jonas> what's a "constructor class"?
09:23:17 <merijn> Lethalman: hmmm, the "simple" idea I had is not quite as simple as I thought, and I'm not entirely sure it's even needed
09:23:23 <Philippa> b_jonas: Once upon a time, typeclasses were only defined on "proper types" - ones of kind *
09:23:43 <jamy> And one more question. I can define code of "data" constructor like in JavaScript? Or he explicit automic?
09:23:51 <b_jonas> Philippa: was that before instance Monad IO ?
09:23:53 <Philippa> so Monad wasn't a type class, it was a "constructor class". We don't need the term any more, because they've been standard long enough and the extension is so obvious from a modern perspective that it's surprising you wouldn't have it
09:23:55 <jamy> *automatic
09:24:08 <b_jonas> I see
09:24:23 <b_jonas> so a constructor class is a typeclass of a higher kind?
09:24:28 <merijn> Lethalman: I have to go home, so I can't look into it further. Maybe you should write up a pseudo code version of what you want, that'd probably simplify trying to figure out what to do
09:24:30 <Philippa> of a kind that isn't *
09:24:36 <dav> Is there not a verison of "words" that takes a (Char->Bool) function i.e. is there an f in Prelude such that words = f isSpace ?
09:24:55 <monochrom> Data.Split may have one
09:24:59 <Philippa> *->* isn't a higher kind
09:25:10 <Philippa> (*->*) -> * is
09:25:17 <monoidal> @src words
09:25:17 <lambdabot> words s = case dropWhile isSpace s of
09:25:17 <lambdabot>     "" -> []
09:25:17 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
09:25:25 <Philippa> (see also: types of dictionaries!)
09:25:50 <monoidal> dav: Data.List.Split.splitWhen
09:26:25 <b_jonas> btw, now that ghc has custom kinds that aren't derived from * and -> , does it also have open custom kinds to which you can add types later? or can those be emulated somehow?
09:26:39 <monoidal> b_jonas: No. Custom kinds are closed.
09:26:45 <jamy> And one more question. I can define code of "data" constructor like in JavaScript? Or he explicit automatic?
09:27:01 <geekosaur> jamy: no, you're not constructing "smart" objects
09:27:07 <dav> monoidal: interesting. I looked for (a -> Bool) -> [a] -> [[a]] in Hoogle and didn't find anything. That's exactly splitWhen's type sig..
09:27:19 <monoidal> dav: Hoogle might not index it.
09:27:30 <geekosaur> (you can hide the constructor(s) and make your own "smart constructor" but you can't use it to pattern match)
09:27:33 <Fuuzetsu> probably on Hayoo
09:28:08 <jamy> And i can't have patternmatching in data constructor?
09:29:23 <dav> Fuuzetsu: didn't know hayoo. thanks!
09:30:07 <geekosaur> not sure what you're asking
09:32:50 <monochrom> I guess it's enough to just say: 1. javascript constructor is unrelated to haskell data constructor. 2. there is no pattern matching in javascript. 3. pattern matching in haskell can use data constructor
09:33:19 <Taneb> Is there a function StateT IO s a -> IORef s -> IO a? Should there be?
09:33:35 <isBEKaml> Hey folks, I just noticed this ticket: http://trac.haskell.org/haskell-platform/ticket/209 - Is there any reason we do not have a 64 bit build for Windows?
09:33:39 <monochrom> java constructor : haskell constructor :: catfish :: jellyfish
09:34:21 <monochrom> err, s/java/javascript/
09:34:57 <monochrom> haskell class : java class :: sparkling water : king's water
09:35:01 <applicative_> Taneb, it's pretty easy to define, no? readIORef ref >>= runStateT ?? mystate
09:35:07 <applicative_> or something like that
09:35:20 <applicative_> Taneb, it's pretty easy to define, no? readIORef ref >>= runStateT mystate
09:35:23 <applicative_> rather
09:35:33 <Taneb> Thinking about it, I can just use atomicModifyIORef
09:36:58 <mekeor> in <http://hpaste.org/88763> the kleisli-adequat of “mapA (fid Just) `frun` [1..5]” is “mapA (kid Just) `krun` [1..5]” which is nice. but what's the kleisli-adequat to “mapA' `frun` (fid Just) `frun` [1..5]”?  – it's probably a quite senseless and weird question.. :D
09:37:24 <monochrom> isBEKaml: I think they just forgot. they were busy.
09:39:11 <isBEKaml> monochrom: I understand - I was wondering if 64bit version will be available anytime now.
09:39:49 <monochrom> someone also asked on haskell-cafe mailing list. you may be able to monitor it for answers.
09:39:57 <monochrom> (no answer yet)
09:40:01 <applicative_> isBEKaml: http://www.haskell.org/ghc/download_ghc_7_6_3#windows64  there could be some other trouble with platform libraries
09:40:24 <isBEKaml> applicative_: that was my last option :-)
09:40:49 <isBEKaml> monochrom: Okay, I'll monitor the cafe list (which I'm subscribed to anyway)
09:41:29 <applicative_> isBEKaml: I think that the 64 bit haskell platform for os x was still experimental with the last release; didn't see what they're saying now
09:42:44 <isBEKaml> applicative_: I have no idea about OSX. Last I saw, I got a good impression that there will be a stable 64 bit build for windows.
09:43:25 <isBEKaml> applicative_: I'm in no hurry to download Platform. I'll wait.
09:44:04 <applicative_> isBEKaml: well, if you know about these things, I'm sure mzero and the windows egghead, Mikhail could use help....
09:44:18 <monochrom> I was in such hurry, I already installed it during release candidate :)  (linux, build from source)
09:45:40 <applicative_> isBEKaml: it occurs to me my last remark might look snide; I meant it seriously
09:47:16 <isBEKaml> applicative_: I haven't tried building Platform from source on windows. This would be my first time :) Ofcourse, I'm willing to help where I can.
09:47:18 <isBEKaml> applicative_: No offence taken.
09:47:41 <monochrom> I am not going to build from source on windows :)
09:48:12 <isBEKaml> monochrom: You're in a hurry to get to Linux - Ofcourse, you won't :-)
09:48:40 * applicative_ builds from source on os x following monochrom's recipe
09:49:12 <isBEKaml> applicative_: that said, I'll try building from source sometime this weekend. Let's see how that pans out.
09:49:24 <Adeon> oh, it's the new platform
09:49:28 <Adeon> now with 2013 instead of 2012
09:49:56 <applicative_> yes, it's 2013!
09:50:14 <isBEKaml> Adeon: indeedy! :)
09:50:15 <applicative_> maybe they should change to a Chinese or Hebrew calendar as occasion requires.
09:50:15 <Adeon> praise the haskell platform god
09:50:28 <mm_freak> is there another relational algebra library than haskelldb for (at least) postgresql?
09:53:28 <example> Hell0
09:54:04 <applicative_> Hell0 3xample
09:54:26 <applicative_> @leet hello example
09:54:27 <lambdabot>   TemplateHaskell is not enabled
09:54:30 <applicative_> awww
09:54:51 <example> how it works?
09:55:00 <applicative_> what?
09:55:16 <example> this group
09:55:37 <applicative_> #haskell is devoted to teaching learning and discussing the Haskell programming language
09:56:09 <applicative_> so, if you are trying to learn Haskell but are getting obscure errors, this is a place to come to.
09:56:15 <fizbin> applicative_: And occasional silliness.
09:56:17 <example> nice
09:56:28 <fizbin> > putStrLn$((++)<*>show)"> putStrLn$((++)<*>show)"
09:56:30 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
09:56:30 <lambdabot>    arising from a use of ...
09:56:44 <fizbin> Oh come on LambdaBot...
09:57:06 <applicative_> see example , fizbin is playing the characteristic part of the learner here.
09:57:13 <applicative_> we're not going to help him though ....
09:57:17 <pqmodn> heh
09:57:21 <latro`a> it's well known lambdabot won't let you run IO :p
09:57:25 <example> I'm trying to develop a data to store things about a graph
09:57:45 <example> but i don't know if i am doing the things right
09:57:46 <fizbin> > text$((++)<*>show)"> text$((++)<*>show)"
09:57:48 <lambdabot>   > text$((++)<*>show)"> text$((++)<*>show)"
09:58:03 <Fuuzetsu> what kind of bot doesn't ignore itself?
09:58:48 <applicative_> example: you can use hpaste.org or some like paste site to paste your experimental module, and people here might try to comment
09:59:08 <applicative_> example: it's best to have source to look at ... at least for some of us
09:59:24 <isBEKaml> Fuuzetsu: spacey-spacey lambdabot? :-)
09:59:27 <example>  data graph = graph Char Char Float Float
09:59:56 <applicative_> data Graph = Graph Char Char Float Float it should be
10:00:24 <applicative_> data Graph = Graph Char Char Float Float deriving (Show, ...)
10:00:45 <example> why graph is wrong?
10:00:50 <applicative_> lower case
10:00:53 <fizbin> example: capitals matter. However, I'm more puzzled by what you want to store. So your graphs only have two nodes?
10:01:12 <example> not
10:01:51 <example> i am triyng to implement the dijkstra reading the nodes from the IO
10:02:28 <example> and i think to create a graph data to store the edges and the costs
10:02:56 <applicative_> example so this is really data Edge = Edge Char Char Float Float ?
10:02:58 <example> but in the case i'm trying to use two costs, so i decided put two Floats
10:03:30 <applicative_> I guess the costs come from the larger graph though
10:03:31 <example> if i create an edge in this way, how i do the graph?
10:03:32 <applicative_> ?
10:03:51 <fizbin> Ah. Well, okay. So first I would try to see if I could use a different structure for storing the graph, such as what's used in Data.Graph.Inductive.
10:03:52 <example> the input is something like this
10:04:07 <example> first line: init_vertex end_vertex
10:04:11 <fizbin> That's the library I've used in the past to hold a graph.
10:04:51 <example> next lines: edge_init_vertex edege_end_vertex cost velocity
10:05:34 <acube> @src Data.DList.append
10:05:34 <lambdabot> Source not found. My brain just exploded
10:05:55 <example> @src Data.Graph
10:05:55 <lambdabot> Source not found. Sorry.
10:06:04 <example> what is @ src ?
10:06:15 <Fuuzetsu> shows you source
10:06:17 <acube> @src id
10:06:17 <lambdabot> id x = x
10:06:23 <acube> @src (
10:06:23 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:06:25 <acube> @src (++)
10:06:25 <lambdabot> []     ++ ys = ys
10:06:25 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
10:06:25 <lambdabot> -- OR
10:06:25 <lambdabot> xs ++ ys = foldr (:) ys xs
10:06:30 <jnerula> Neat
10:06:31 <example> @src ++
10:06:31 <lambdabot> []     ++ ys = ys
10:06:32 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
10:06:32 <lambdabot> -- OR
10:06:32 <lambdabot> xs ++ ys = foldr (:) ys xs
10:06:56 <beaky> wow that second one is nice
10:07:35 <jnerula> @ty Data.ByteString.Char8.pack
10:07:36 <lambdabot> String -> BSC.ByteString
10:07:43 <applicative_> example: it's a special lambdabot thing.  unfortunately ghci does do anything like that....
10:07:51 <applicative_> does not ...
10:08:08 <applicative_> @src Data.ByteString.Char8.pack
10:08:09 <lambdabot> Source not found. The more you drive -- the dumber you get.
10:08:18 <startling> it's a terrible hack
10:08:25 <applicative_> whoa a Repo Man allusion in lambdabot
10:08:35 <example> @src data
10:08:36 <lambdabot> Source not found. You speak an infinite deal of nothing
10:08:48 <fizbin> example: Data.Graph.Inductive is in the fgl package: http://hackage.haskell.org/package/fgl
10:09:04 <applicative_> @src is a terrible hack?
10:09:04 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
10:09:36 * applicative_ does his best thinking on the bus
10:10:27 <startling> applicative_, it's a file that's indexed just for @src
10:10:31 <example> It is from Prelude module?
10:10:55 <applicative_> startling: yeah thats what I thought, but I'm not sure it rises to the level of a 'hack'
10:11:01 <applicative_> well, its terrible maybe...
10:11:43 <startling> I guess I just wish there were an actual "search the source of x modules" utility
10:12:04 <applicative_> example: what is in the Prelude? (or not?)
10:12:17 <applicative_> oh that definition of (++), for example.
10:13:53 <example> Data.Graph.Inductive is in the fgl package. How i use it?
10:15:33 * applicative_ , believing that Hackage must prepare itself for the coming apocalypse, is trying to get the 'BASIC' package to compile again...
10:15:48 <Fuuzetsu> Hand over your Haskeller badge.
10:16:21 <beaky> I love imperative programming and mutable variables
10:16:41 <beaky> how does haskell manage to get by without them?
10:17:10 <applicative_> beaky: by having them?
10:17:32 <beaky> wow it does?
10:18:07 <applicative_> import Data.STRef ; import Control.Monad.ST ... for example
10:18:08 <Fuuzetsu> I can already see beaky's next question to do with his global stae.
10:18:21 * applicative_ pretends to go along
10:18:29 <applicative_> for global state beaky, we use
10:18:35 <acube> ReaderT
10:18:41 <beaky> ah whats a reader
10:18:56 <Fuuzetsu> …haven't you been here for like a year?
10:19:08 <applicative_> global_version_state = unsafePerformIO getGLUTversion
10:19:33 <arnsholt> example: Import one of the the packages with an implementation of the Graph and DynGraph typeclasses (D.G.I.Tree or D.G.I.PatriciaTree) and use D.G.I.mkGraph
10:19:54 <beaky> I
10:19:59 <beaky> I learn very slowly
10:20:08 <applicative_> beaky, crudely Reader config a = config -> a
10:20:40 <applicative_> the 'reader monad' is a way of writing compositionally so that everything depends on an unspecified configuration or environment
10:20:47 <applicative_> I mean, thats a typical use
10:20:58 <Gibheer> hi. I;m trying to use HTTP and would like to get the hole body from the response. But every time I get a type error saying, that what I want is packed in IO. How can I get everything back?
10:21:40 <applicative_> Gibheer: this is a type error or a runtime error?
10:21:41 <Fuuzetsu> Gibheer: You can use do notation… body <- yourResponse
10:21:51 <applicative_> a type error
10:22:09 <Gibheer> it is a type error
10:22:18 <applicative_> body <- getResponseBody blah; putStrLn body
10:22:38 <Gibheer> Fuuzetsu: what is <- doing? All I could find was, that it is the same as =. Must have been older then
10:22:40 <applicative_> where blah is the parse url or whatever, if I remember
10:22:56 <Fuuzetsu> Gibheer: It has never been the same as =…
10:23:15 <applicative_> Gibheer: it is like a certain use of = in imperative languages
10:23:27 <Gibheer> okay, then I should get back to reading
10:23:30 <Gibheer> thank you :)
10:23:44 <isBEKaml> #haskell is pretty nifty - I can see if I haven't got a connection drop just by being connected to it!
10:23:49 <Fuuzetsu> http://learnyouahaskell.com/a-fistful-of-monads talks about the do notation and <-
10:24:03 <applicative_> you could read it as saying, bind the name 'body' to the actual webpage we get from getResponseBody ...
10:24:07 <applicative_> or something like that
10:24:42 <applicative_> getResponseBody ... is an action; body is a string or bytestring
10:24:50 <applicative_> this is all being put with maximum crudity
10:24:52 <example> someone have an example of a code using the Data.Graph reading from the stdin? I don't know how to do this
10:25:45 <Gibheer> applicative_: okay, that helps me a bit with understanding
10:26:30 <Gibheer> the language itself is still a bit confusing, but cabal is really awesome
10:26:37 <applicative_> example: what do you want it to read from stdin?
10:26:50 <Fuuzetsu> Gibheer: heh, funny how it's cabal that I usually hear complaints about
10:27:32 <isBEKaml> Gibheer: OOC, why do you think cabal is awesome?
10:27:42 <Gibheer> Fuuzetsu: really? it just worked on freebsd out of the box
10:27:53 <example> the first line the initial and end vertex
10:27:56 <Gibheer> and that is the first package manager which did it for me
10:27:58 <Fuuzetsu> Gibheer: it Just Works™ until it doesn't
10:27:59 <startling> it works fine at first. :)
10:28:02 <example> and the next lines the edges and cost
10:28:17 <example> to calculate the minimun path
10:28:33 <Gibheer> Fuuzetsu: uninstall is missing, yes, but apart from that very nice tool
10:28:36 <pqmodn> example: the Learn You a Haskell tutorial on IO is pretty decent: http://learnyouahaskell.com/input-and-output
10:29:14 <isBEKaml> Gibheer: cabal isn't a package manager (there used to be a blog post about that)
10:29:36 <example> I was there
10:29:54 <example> but i cannot figure out how to pass the code to Graph
10:30:00 <example> what i do:
10:30:01 <amyers> isBEKaml: http://www.vex.net/~trebla/haskell/sicp.xhtml
10:30:12 <pqmodn> example: good! the important part is the distinction between IO actions and non-IO, and how to connect them
10:30:38 <example> main = do
10:30:38 <example>   -- read initial and finish vertex 		
10:30:38 <example>     path <- getLine
10:30:38 <example>     let init :: Char
10:30:41 <example>         init =  head path
10:30:44 <example>     let end :: Char
10:30:46 <example>         end = last path
10:30:47 <startling> Gibheer: it's more of a dependency hell thing
10:30:49 <example>     putStrLn ("init: " ++ [init] ++ " end: " ++ [end])
10:30:53 <example>  
10:30:56 <example>     dat <- getContents
10:30:57 <Eduard_Munteanu> @where hpaste
10:30:57 <lambdabot> http://hpaste.org/
10:30:59 <example>     let allLines = lines dat
10:31:02 <beaky> How do I do a while loop in haskell?
10:31:02 <example>     let graph  :: Graph
10:31:05 <example>  
10:31:06 <Eduard_Munteanu> example: don't paste here, use ^^
10:31:06 <pqmodn> example: use hpaste for an example more than one or two lines, please
10:31:07 <Fuuzetsu> RIP chat
10:31:09 <example> graph = ???
10:31:17 <example> i'm sorry
10:31:23 <example> i don't know hpaste
10:31:27 <Gibheer> startling: isBEKaml: I don't really care much about what it is and what not, but what it does worked for me so far, which is a nice experience :)
10:31:28 <pqmodn> example: hpaste.org
10:31:49 <isBEKaml> amyers: I was thinking of this: http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
10:32:11 <startling> Gibheer: sure; just explaining other peoples' revulsion.
10:32:18 <isBEKaml> Gibheer: That's good if it works for you :-)
10:32:24 <Gibheer> it even differenciates between system and user installation without any work from me, which rubygems has and various python lib managers have problems with
10:33:00 <Fuuzetsu> I think rubygems and Python pmanagers aren't model examples of package managers
10:33:02 <beaky> @hoogle Monad m => m Bool -> m () -> m ()
10:33:09 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
10:33:09 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
10:33:09 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
10:33:09 <klrr> hey haskellers :D
10:33:14 <Gibheer> now my only hope now is, that haskell and I can understand each other better
10:33:22 <Eduard_Munteanu> klrr: hi
10:33:39 <example> what i do after submit my code to hpaste ? paste the link here?
10:33:43 <Fuuzetsu> Gibheer: shower it with love and flowers 3 times a day for long-lasting relationship
10:33:47 <klrr> GHC hates me and i hate her :D
10:33:51 <Fuuzetsu> example: yes
10:33:57 <Eduard_Munteanu> example: yes, but if you select #haskell as the channel, it will do so automatically
10:34:02 <Gibheer> Fuuzetsu: even worse was the experience with Clojure, which did not even began working ;)
10:34:30 <Gibheer> "hey, you need that from maven. I installed that for you, but where the heck did I put it?"
10:35:04 <example> http://hpaste.org/88767
10:35:13 <Eduard_Munteanu> klrr: you just need to get to know her :P
10:35:35 <klrr> Eduard_Munteanu: or haskell so she wont yell at me soo much :D
10:36:01 <Gibheer> Fuuzetsu: hehe
10:36:03 <Fuuzetsu> GHC should have her own fan-art
10:49:56 <FreeFull> > 0.3 + 0.3 + 0.3 + 0.1
10:49:58 <lambdabot>   0.9999999999999999
10:50:15 <example> @src head
10:50:15 <lambdabot> head (x:_) = x
10:50:15 <lambdabot> head []    = undefined
10:50:27 <geekosaur> mmm, floating point
10:53:47 * hackagebot Eq 1.1.3 - Render math formula in ASCII, and perform some simplifications  http://hackage.haskell.org/package/Eq-1.1.3 (VincentBerthoux)
10:59:05 <carter> ofan yo
10:59:05 <lambdabot> carter: You have 1 new message. '/msg lambdabot @messages' to read it.
10:59:28 <carter> xplat awesome
11:08:47 * hackagebot Webrexp 1.1.1 - Regexp-like engine to scrap web data  http://hackage.haskell.org/package/Webrexp-1.1.1 (VincentBerthoux)
11:09:42 <Twey> Scrap?  :þ
11:10:26 <Clint> there are already enough libraries that scrape
11:11:28 <geekosaur> don't be scrappy about it :p
11:12:35 <example> hello someone could see my code ?
11:13:29 <example> http://hpaste.org/88768
11:14:01 <example> i don't know how to analise the empty list in the generateGraph
11:14:16 <example> in the case i want to return something like void
11:15:31 <exFalso> example: is Array a =[a]
11:15:31 <exFalso> ?
11:15:54 <exFalso> oh no its just a constructor
11:16:19 <example> yep
11:16:31 <edwardk> preflex: xseen syntaxpolice
11:16:31 <preflex>  Sorry, I haven't seen syntaxpolice
11:17:08 <example> i tried generateGraph [] = [] but this give me the error
11:17:27 <example>  Couldn't match expected type `Graph' with actual type `[a0]'
11:17:36 <exFalso> example: not sure how that code compiles
11:17:45 <exFalso> example: exactly, thats the error message i'd expect
11:18:10 <monoidal> example: with your definition, a graph is equivalent to a description of *exactly one* node
11:18:20 <exFalso> you use the do syntax, which means you are trying to define a monadic computation
11:18:24 <monoidal> example: you might have wanted data Graph = Array [Edge] deriving(Show)
11:18:28 <exFalso> Graph is not a monad
11:18:47 <Twey> example: I don't think that code will compile anyway.  (++) is an operation on lists, but you're passing it a [Graph] and a Graph.
11:19:00 <Twey> exFalso: That's actually okay
11:19:12 <example> how can fix it @exFalso ?
11:19:15 <Twey> > do { let x = 5; x } :: Int
11:19:17 <lambdabot>   <hint>:1:19: parse error on input `}'
11:19:32 <Twey> Well, it used to be.
11:19:35 <monoidal> Twey: no, it isn't.
11:20:00 <exFalso> well, i'm not sure what you're trying to do, are you trying to use the list monad?
11:20:09 <Twey> Ah, missing braces
11:20:33 <Twey> > do let { x = 5 }; x -- monoidal, exFalso
11:20:35 <otters> > (do { let x = 5; x }) :: Int
11:20:36 <lambdabot>   5
11:20:38 <lambdabot>   <hint>:1:20: parse error on input `}'
11:20:46 <otters> > do 5 :: Int
11:20:49 <monoidal> ah, right
11:20:49 <lambdabot>   5
11:20:55 <otters> > succ $ do 5 :: Int
11:20:57 <lambdabot>   6
11:21:02 <exFalso> woot
11:21:09 <Twey> I've never been sure whether that's standard
11:21:13 <otters> the do thing is probably my favorite haskell "trick"
11:21:18 <Twey> I suppose it is, since it's just desugaring
11:21:41 <geekosaur> there have been arguments over whether it should be accepted or not
11:21:53 <exFalso> geekosaur: shouldnt be imho
11:22:09 <exFalso> geekosaur: pretty... ambiguous
11:22:10 <Twey> I feel like it wouldn't be worth it to make the ‘do’ translation type-aware just to disallow that case
11:22:27 <Twey> It's perfectly valid if viewed in terms of a mechanical translation
11:23:01 <exFalso> you mean it uses the (->)a monad and not care about the return type?
11:23:02 <Twey> ‘do let { x = 5 }; x’ should be identical to ‘let x = 5 in x’ by the do-notation rules
11:23:16 <monoidal> example: Note that words x is [String]
11:23:17 <Twey> exFalso: It doesn't use a monad at all.  That's why people think it should be forbidden.
11:23:26 <monoidal> example: which means that w!!0 is String
11:23:40 <monoidal> example: which means that head (w !! 0) is Char. You can use read on strings, not chars
11:23:53 <Twey> exFalso: It translates into a simple let expression, which means that ‘do’ is not strictly restricted to use with monads
11:24:12 <exFalso> Twey: i understand i was wondering about binds
11:24:19 <example> i tried use this with only w!!0 and don't work
11:24:28 <Twey> exFalso: Binds would just give the usual type error
11:24:34 <Twey> (post-desugaring)
11:24:35 <exFalso> example: what are you trying to do?
11:24:42 <monoidal> example: it's only one error, you've got others
11:25:03 <monoidal> example: how do you want to define Graph?
11:25:26 <example> i'm trying to read the edges and costs of a graph to stdin and put in the Graph data
11:25:32 <exFalso> exFalso: as i understand it now you have a String which you want to parse into a graph
11:25:36 <exFalso> *example:
11:25:44 <monoidal> example: do you want Graph to be a list of nodes?
11:25:50 <monoidal> * edges
11:26:29 <exFalso> how is the data laid out in the String?
11:26:36 <exFalso> please give an example, example:)
11:26:40 <monoidal> example: may I suggest "type Graph = [Edge]"?
11:26:45 <example> something like this graph = [[(a,b),(10,20)], ... ,[(y,z),(1,2)]
11:27:02 <example> where (a,b) is the edge
11:27:15 <example> and (10,20) is the cost
11:27:25 <example> in the case i have two costs
11:27:54 <exFalso> example: is that an example input string?
11:28:04 <example> no
11:28:09 <francoisbeau> Hi all! Using Text.JSON.Generic, is there a way to use field names that are different than the actual JSON keys?
11:28:18 <example> the input is like this : a b 11.2 15
11:28:28 <francoisbeau> Or must I hand-code the decoding routines myself?
11:28:49 <francoisbeau> I get "Main: fromJSON: field does not exist iService", but the key in the JSON is named "service"
11:29:21 <monoidal> > words "a b 11.2 15"
11:29:24 <lambdabot>   ["a","b","11.2","15"]
11:29:34 <FreeFull> :t \x - > do x
11:29:35 <lambdabot> parse error on input `-'
11:29:40 <FreeFull> :t \x -> do x
11:29:42 <lambdabot> t -> t
11:29:57 <monoidal> example: Do you see the above? You need to look at words x !! 0, !! 1, !! 2, !! 3
11:30:03 <monoidal> example: or better, use pattern matching
11:30:40 <monoidal> > let [x,y] = [1,2] in x+y -- example
11:30:44 <lambdabot>   3
11:30:48 <exFalso> example: or better, use a simple parser library or scanf
11:31:15 <FreeFull> > sum [1,2]
11:31:17 <lambdabot>   3
11:33:34 <example> @exFalso the parameter of generateGraph is the allLines that comes from getContent. So the parameter is [String]. when I use words what i have?
11:33:34 <lambdabot> Unknown command, try @list
11:33:43 <example> @list
11:33:43 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:34:07 <exFalso> :t words
11:34:09 <lambdabot> String -> [String]
11:34:30 <example> :t words
11:34:32 <lambdabot> String -> [String]
11:34:41 <Ankhers> How can I find where a certain package is installed? (Mac)
11:34:43 <exFalso> example: see what monoidal wrote
11:35:17 <example> this  let [x,y] = [1,2] in x+y ?
11:35:25 <monoidal> yes
11:35:32 <example> what this do?
11:35:39 <monoidal> let [x,y] = words "1 3" in (x,y)
11:35:40 <exFalso> example: if you don't care that your code is partial, the cleanest way to do this is with pattern matching
11:35:40 <exFalso> well not exactly that
11:36:01 <example> i don't care
11:36:13 <geekosaur> Ankhers, pkgutil --files packageid
11:36:14 <example> how i do with pattern matching ?
11:36:16 <monoidal> example: Start with writing a function String -> Edge that parses a single edge
11:36:18 <geekosaur> "man pkgutil"
11:36:26 <exFalso> or rather, [[x],[y],w0,w1]=words "a b 12 23"
11:36:33 <monoidal> example: Call it "parseEdge"
11:36:47 <exFalso> this will give you x ='a', y='b', w0 = "12", w1 = "23"
11:36:59 <monoidal> example: so you'll expect that parseEdge "a b 12 23" will give Edge 'a' 'b' 12 23
11:37:07 <geekosaur> the thing for specifying a volume is only useful when manipulating a volume containing a different OS X installation
11:38:08 <Ankhers> geekosaur: Sorry, I should say hackage, not package.
11:38:19 <Ankhers> geekosaur: Installed via cabal
11:39:04 <geekosaur> ghc-pkg describe packagename
11:39:28 <geekosaur> ghc-pkg field $packagename pkgroot
11:39:57 <geekosaur> hm, not that last apparently :/
11:40:19 <example> exFalso how i do this ?
11:40:26 <example> for example
11:41:32 <Ankhers> Follow up question, how do I remove a certain package (and all of its dependencies)?
11:41:36 <example> parseEdge s = [[x],[y],w0,w1] where z =words s, x = head z ... ??
11:43:33 <exFalso> :t (\s -> let [[x],[y],w0,w1] = s in (x,y,read w0 :: Double, read w1 :: Double))
11:43:35 <lambdabot> [[Char]] -> (Char, Char, Double, Double)
11:44:07 <exFalso> smoething like this
11:44:43 <monoidal> example: Yes. But instead of x = head z, y = z !! 1 etc. you can get all of them with a single match
11:45:04 <monoidal> example: ... where z = words s, [x,y,z,t] = z
11:45:31 <monoidal> example: whoops, names collision
11:45:40 <monoidal> example: ... where z = words s, [a,b,c,d] = z
11:45:43 <exFalso> type infinito
11:45:54 <monoidal> example: and this can be written as ... where [a,b,c,d] = words s
11:46:45 <exFalso> :t map (\s -> let [[x],[y],w0,w1] = words s in (x,y,read w0 :: Double, read w1 :: Double))
11:46:46 <lambdabot> [String] -> [(Char, Char, Double, Double)]
11:48:17 <example> @monoidal in this example a,b,c,d are equals to x , y, w0 ,w1 ?
11:48:17 <lambdabot> Unknown command, try @list
11:48:31 <rtmt> is there a more generic version of the function "words"
11:48:39 <monoidal> example: a,b,c,d are equal to words !! 0, words !! 1, words !! 2, words !! 3, respectively
11:48:56 <monoidal> words s !! 0, words s !! 1, words s !! 2, words s !! 3, respectively
11:48:59 <exFalso> rtmt: what do you mean by "more generic"?
11:49:23 <rtmt> Like say break a list up into sublist by something other than just removing spaces or lines.
11:49:38 <rtmt> Such as wordsBy or something like that
11:50:13 <FreeFull> > let x = x in x
11:50:29 <lambdabot>   thread killed
11:50:33 <exFalso> you want to pass in a function that tells whether an element is a delimiter?
11:50:40 <rtmt> sure
11:50:56 <rtmt> (a -> Bool) -> [a] -> [[a]]
11:51:10 <FreeFull> > let x = flip const x in x 3
11:51:13 <lambdabot>   3
11:51:23 <example> so the function is parseEdge s = [[x],[y],w0,w1] where [a,b,c,d] = words s
11:51:31 <monoidal> rtmt: there's split library with many functions
11:51:55 <rtmt> whats the name?
11:52:06 <monoidal> rtmt: it's on hackage, called split
11:52:21 <rtmt> No standard libraries though?
11:52:29 <monoidal> rtmt: Not that I'm aware of.
11:52:41 <exFalso> example: no, monoidal and i were saying different things, and thats just kind of mixing them together, sorry for the confusion:)
11:52:44 <FreeFull> http://hackage.haskell.org/packages/archive/split/0.2.2/doc/html/Data-List-Split.html
11:52:50 <monoidal> example: Make your function return Edge, not a list
11:53:02 <monoidal> example: so it will be parseEdge s = Edge ... ... ... ... where ... <- fill the blanks
11:54:10 <rtmt> Well thanks anyway, seems like something common enough it should be a standard things, but go figure.
11:55:17 <applicative_> data.list.split is in the haskell platform.
11:55:21 <example`> monoidal something like this
11:55:24 <example`> parseEdge s = Edge x y w0 w1 where [x,y,c,d] = words s, w0 = read c::Int, w1 = read d::Int
11:55:32 <example`> ??
11:56:02 <exFalso> example`: almost there, x and y are Strings, and you want them to be Char
11:56:16 <monoidal> example`: what exFalso said
11:57:41 <rtmt> applicative: just noticed that, I withdraw my criticism.
11:59:51 <example`> and now exFalso parseEdge s = Edge x y w0 w1 where [x,y,c,d] = words s,read x::Char,read y::Char, w0 = read c::Int, w1 = read d::Int
12:00:18 <exFalso> example`: yes, that works
12:00:35 <example`> yeah
12:00:36 <exFalso> replacing [x,y,c,d] with [[x],[y],c,d] also works
12:01:32 <example`> put [[x],[y],c,d] and remove read Char?
12:02:03 <exFalso> example`: well it's your choice at this point, whichever you think is cleaner:)
12:12:03 <example`> exFalso i have the error : parse error on input ','
12:12:43 <geekosaur> @paste
12:12:43 <lambdabot> Haskell pastebin: http://hpaste.org/
12:14:05 <acube> @ty liftA2 (<$)
12:14:06 <lambdabot> (Functor f1, Applicative f) => f a -> f (f1 b) -> f (f1 a)
12:14:13 <acube> @hoogle (Functor f1, Applicative f) => f a -> f (f1 b) -> f (f1 a)
12:14:14 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
12:14:14 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
12:14:14 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
12:14:32 <acube> @hoogle f a -> f (f1 b) -> f (f1 a)
12:14:33 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
12:14:33 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
12:14:33 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
12:16:48 <acube> @ty \f g -> liftA2 (<$) f (guard . g)
12:16:50 <lambdabot> (Functor f, MonadPlus f) => (a1 -> a) -> (a1 -> Bool) -> a1 -> f a
12:17:00 <acube> @google (Functor f, MonadPlus f) => (a1 -> a) -> (a1 -> Bool) -> a1 -> f a
12:17:01 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
12:17:02 <lambdabot> Title: Control.Monad
12:17:06 <acube> @hoogle (Functor f, MonadPlus f) => (a1 -> a) -> (a1 -> Bool) -> a1 -> f a
12:17:06 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
12:17:06 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
12:17:07 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
12:17:19 <example`> code http://hpaste.org/88769
12:23:12 <exFalso> example`: you can't have comma separated equalities in where clauses, only in let binding
12:23:12 <exFalso> s
12:23:21 <example`> i fix it just now =)
12:23:26 <exFalso> ok:)
12:23:58 <example`> exFalso how i use the parse in the generateGraph ?
12:24:44 <exFalso> example`: well first we have to fix your definition of Graph, as it stands its just a single edge
12:25:01 <exFalso> example`: i think you want it to be a list of edges instead?
12:25:05 <example`> put Graph = [Edge] ?
12:25:23 <exFalso> type Graph = [Edge] will work
12:25:34 <example`> ok changed
12:26:20 <dmwit> You can't have comma-separated equalities, period. Not in where clauses nor let cluases.
12:26:29 <dmwit> You can have semicolon-separated equalities in both places.
12:26:46 <exFalso> dmwit: oh right, my bad
12:27:45 <exFalso> example` so now you have a list of strings [String], a function String -> Edge and you want to return a list of edges [Edge]
12:28:03 <exFalso> example`: correct?
12:28:33 <example`> yep
12:29:06 <example`> something like generateGraph (x:xs) = parseEdge x ++ generateGraph xs  ??
12:29:28 <exFalso> example`: almost, but you dont want to use ++
12:29:56 <exFalso> ++ accepts two lists, but parseEdge x :: Edge, generateGraph xs :: [Edge]
12:31:33 <example`> exist some function to generate the list?
12:31:37 <dmwit> :t map
12:31:38 <lambdabot> (a -> b) -> [a] -> [b]
12:32:12 <exFalso> example`: yes, lists have two constructors, the empty list constructor  is [] and the cons constructor is (:) : a -> [a] -> [a]
12:32:27 <exFalso> dmwit: a bit later;)
12:33:02 <dmwit> get 'em hooked early
12:33:17 <example`> i never used the cons constructor, how i use then ?
12:33:33 <dmwit> > 1 : [2,3,4] -- like this
12:33:35 <lambdabot>   [1,2,3,4]
12:33:50 <exFalso> example`: ^
12:33:54 <dmwit> > [1, 2] ++ [3, 4] -- for comparison with (++)
12:33:56 <lambdabot>   [1,2,3,4]
12:34:02 <example`> parseEdge x : generate ... in this case?
12:34:07 <exFalso> exactly
12:34:07 <dmwit> right
12:34:35 <exFalso> now you just need to take care of the "base case" where the input is an empty list
12:34:46 <example`> i can return a empty list?
12:34:52 <exFalso> exaclty:)
12:34:58 <example`> nice
12:35:16 <exFalso> now dmwit mentioned a function that abstracts what you just did
12:35:29 <dmwit> ?src map
12:35:29 <lambdabot> map _ []     = []
12:35:29 <lambdabot> map f (x:xs) = f x : map f xs
12:35:45 <exFalso> basically what you did was you had a function parseEdge and a list of Strings, and you applied the function to each element
12:35:48 <exFalso> :t map
12:35:51 <lambdabot> (a -> b) -> [a] -> [b]
12:35:55 <exFalso> map does exactly that
12:36:28 <example`> i receveid an error in Graph data
12:36:35 <example`> parse error in constructor in data/newtype declaration: [Edge]
12:36:40 <example`> data Graph = [Edge] deriving(Show)
12:36:51 <example`> data Edge = Edge Id Id Weight Velocity deriving(Show)
12:36:53 <exFalso> example`: yes, that should say "type" instead of "data"
12:37:00 <exFalso> in the Graph definition
12:37:01 <example`> why?
12:37:07 <example`> what is the difference?
12:37:09 <exFalso> "type" declares a synonym
12:37:23 <exFalso> basically Graph will be treated exaclty the same as [Edge]
12:37:29 <example`> hum
12:37:39 <exFalso> if you use "data" you will create a completely new type
12:37:47 <example`> so Graph is a synonym for an array of Edges right?
12:37:52 <exFalso> yes
12:38:08 <exFalso> if you want you can make it a new type too, but in that case you need a constructor for it
12:38:19 <dmwit> exFalso: "type" declares a new name for an old type. "data" creates a fresh, clean, shiny new type. "data" declarations must give constructors that mark locations of the shiny new type.
12:38:30 <exFalso> the same way [] is a constructor for lists, you need one for data Graph
12:39:13 <exFalso> but a synonym in this case is sufficient
12:39:23 <dmwit> (A constructor is an identifier that starts out upper-cased. For this purpose, ":" is considered upper-case.)
12:39:40 <example`> in my case i don't need a constructor
12:40:05 <exFalso> yes, so if you just say "type Graph = [Edge]" it will work fine
12:40:20 <exFalso> now back to the function definition:)
12:40:20 <example`> yep , it works
12:40:38 <exFalso> you can define the function in a single line if you use the map function
12:42:51 <dmwit> carter: ping
12:42:57 <carter> dmwit pong
12:42:58 <example`> finally i can read the graph from input. Now i need to generate a function that create the dijkstra in the graph
12:42:59 <carter> sup?
12:43:01 <example`> any help?
12:43:16 <dmwit> carter: Did you get your ghc-pkg problem figured out...?
12:43:23 <carter> dmwit which one was that?
12:43:42 <dmwit> carter: ...all of a sudden I noticed an 's' in the name in this email
12:43:48 <dmwit> sorry, it isn't you
12:43:51 <carter> ah
12:43:53 <carter> np
12:44:06 <carter> i did find a panic / pattern failure in cabal-install head yesterday
12:44:32 <carter> + borked llvm-hs for a minor version then had to unbork my cabal to haskell platform version to push an unborked llvm-hs
12:44:36 <carter> but thats a different thing i htink :)
12:44:42 <dmwit> yeah =)
12:45:45 <exFalso> example': well i won't tell you the solution, but it's always a good way to go about implementing such an algorithm to think about the simpler helper functions you will be needing, specify the types for them and finally implement them
12:46:16 <exFalso> example`: so first off you will need to specify the type of the final function
12:47:57 <example`> exFalso, i need to compute two things: the minimun cost path and the minimum velocity path. Is possible create a function that return a pair of integers? at the first time i think in create two functions one for each case
12:47:59 <Ankhers> What would be a better way to write the following?
12:48:03 <Ankhers> > map floor $ map (**2) $ [1..5]
12:48:05 <lambdabot>   [1,4,9,16,25]
12:48:34 <exFalso> :t map (floor . (**2)) $ [1..5]
12:48:34 <dmwit> > map (^2) [1..5]
12:48:36 <lambdabot> Integral b => [b]
12:48:36 <lambdabot>   [1,4,9,16,25]
12:48:51 <dmwit> > map (join (*)) [1..5] -- just for fun
12:48:53 <lambdabot>   [1,4,9,16,25]
12:48:58 <exFalso> lol
12:49:23 <exFalso> example`: yes, haskell has pairs triples, quadruples etc
12:49:29 <exFalso> :t (1,2)
12:49:31 <lambdabot> (Num t1, Num t) => (t, t1)
12:49:32 <Ankhers> dmwit: I completely forgot about (^)... Thanks...
12:49:41 <dmwit> There's also (^^).
12:49:45 <dmwit> The happiest of operators.
12:49:46 <example`> haha
12:50:03 <example`> how i lived without it
12:50:37 <tromp> 2 haskell talks tomorrow night in NYC
12:51:20 <example`> :t (11.2,3)
12:51:21 <lambdabot> (Fractional t, Num t1) => (t, t1)
12:52:10 <example`> exFalso something like minimumPath :: Graph -> (Float, Float)
12:52:35 <Cryovat> Does lambdabot work in pms+
12:52:36 <Cryovat> *?
12:52:44 <dmwit> Cryovat: try it =)
12:52:46 <dmwit> (yes)
12:52:59 <dmwit> The only difference is that :t has to be ?ty instead.
12:53:02 <exFalso> example`: almost, but you also need some input nodes
12:53:06 <Cryovat> Ah, thanks
12:53:14 <Cryovat> I was trying :t but being met with silence :)
12:53:25 <acowley> Why doesn't :t work in PMs?
12:53:46 <exFalso> example`: you want to find the minimum path between two specified nodes
12:53:49 <dmwit> It just goes through a different mechanism that ? and @ commands.
12:53:54 <dmwit> s/that/than/
12:53:56 <Cryovat> ?vixen
12:53:56 <lambdabot> In a flat choice between smoke and jobs, we're for jobs...But just keep me out of trouble on environmental issues.
12:54:00 <exFalso> acowley: the lambdabot is not listening to your pms:)
12:54:07 <Cryovat> Neat
12:54:18 <dmwit> ?vixen is ?nixon
12:54:18 <lambdabot> In a flat choice between smoke and jobs, we're for jobs...But just keep me out of trouble on environmental issues.
12:54:52 <example`> i don't understand ? i need the graph in the function right? implicity i have the Edges because Graph = [Edge]
12:55:15 <exFalso> example`: right, but what does dijstra compute?
12:55:41 <exFalso> example`: given a graph and two vertices it computes the shortest path between them right?
12:55:52 <example`> exact
12:56:15 <exFalso> Graph -> (Edge, Edge) only takes a Graph, but you havent specified the two vertices
12:56:47 <example`> oh yeah
12:56:52 <exFalso> sry (Float,Float)
12:58:36 <example`> minimumPath :: Graph -> (Edge,Edge)-> (Float, Float) ??
12:59:52 <exFalso> example` well you dont want the path between two edges, you want them between two vertices
13:02:21 <Guest77920> Running some tests with JudySL from http://members.shaw.ca/akochoi/articles/Haskell-bindings-for-JudySL/JudySL.hsc
13:02:39 <Guest77920> JudySL.new returns an IO a
13:02:48 <Guest77920> Is there a way to escape the IO monad from something that does FFI?
13:03:10 <example`> yes i have the init and finish vertex and want the path between the vertex
13:03:24 <example`> but i need the Edges to compute the values
13:04:20 <RichyB> Guest22326: You can foreign import without putting IO on the import type. This is only really sensible when importing C functions that are actually pure, like the functions in <math.h>
13:05:08 <dmwit> Guest77920: Yes, but there is a proof burden to using that way. Given the name "new", I very much doubt you're going to be able to discharge that burden.
13:05:57 <Guest77920> dmwit: Yes, well, the FFI binds to the Judy Array library. So, nothing is really "pure"
13:06:09 <exFalso> example`: not sure what you mean
13:06:12 <dmwit> You're likely stuck in IO (or at least ST), then. Sorry about that.
13:06:15 <geekosaur> so why do you want to call it pure? do you like programs randomly malfunctioning?
13:06:18 <RichyB> Guest22326: if you have a subroutine that uses IO internally, but whose interface to the outside world is pure, (e.g. a piece of code that allocates a mutable array, mutates it in a complex way and then returns an immutable result) then it's perfectly reasonable to take the IO qualifier off using unsafePerformIO.
13:06:48 <example`> exFalso i am wrong
13:07:12 <example`> minimumPath :: Graph -> (vertex,vertex)-> (Float, Float)
13:07:13 <RichyB> Guest22326: usually though, whatever subroutines you've foreign imported from C are actually going to have side effects and you should not try to use them outside the IO monad.
13:07:28 <Guest77920> RichyB: There are two stages: 1st, load a large array of data into memory - this is unpure. After that, I enumerate STDIN and match with the internal memory structures. Think deduplication, which is essentially what I'm doing.
13:07:35 <Guest77920> Stage two is pure
13:07:43 <dmwit> example`: By the way, when you finish your function, you might like to read the fgl paper to see how an experienced Haskeller would tackle this problem.
13:07:46 <dmwit> Or you might not, dunno.
13:08:09 <dmwit> Guest77920: enumerating stdin is pure?
13:08:13 <dmwit> this is my skeptical face...
13:08:22 <exFalso> example`: yes, that is a good type signature
13:08:40 <Guest77920> dmwit: Wel, technically, no. I come from Ruby. Learning my way around Haskell.
13:08:53 <dmwit> Learn to use IO, then.
13:09:00 <Guest77920> dmwit: Yeah, probably best. Thanks.
13:09:16 <RichyB> Reading from stdin is not pure at all; it shows up very visibly to any process in the outside world that has a pipe attached to your stdin!
13:10:36 <exFalso> example`: now think about what an intermediate state in the dijkstra algorithm consists of
13:12:45 <example`> i need to study and understand the dijkstra algorithm
13:12:56 <example`> before try to implement
13:13:14 <exFalso> example`: yes, thats a good start:)
13:13:26 <monoidal> example`: Not to discourage you, but I would start with something simpler, like DFS/BFS
13:13:50 * hackagebot Webrexp 1.1.2 - Regexp-like engine to scrap web data  http://hackage.haskell.org/package/Webrexp-1.1.2 (VincentBerthoux)
13:15:15 <ion> “A web scrapping utility”
13:15:23 <acowley> Some programmers, when confronted with a problem, think "I know, I'll use regexp in Haskell!" Now they have scrapped the web.
13:15:57 <acowley> ion: burn it all down
13:17:06 <dmwit> example`: Are you implementing this as an exercise, or to use in something bigger?
13:17:34 <dmwit> Never mind; either way you may learn something from http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP01 =)
13:17:38 <example`> exercise
13:17:50 <dmwit> (I just read it, and it was an eye-opener for me about how to think about graphs.)
13:18:15 <example`> if i would use this for something bigger, i will study fgl
13:24:29 <tgeeky> dmwit: there's also erwig's earlier approach to graphs
13:25:03 <tgeeky> http://web.engr.oregonstate.edu/~erwig/meta/
13:25:26 <dmwit> tgeeky: Thanks for the link. Can you summarize it in a witty catchphrase?
13:25:51 <tgeeky> dmwit: He told me in an e-mail that it's still a dead end.
13:26:04 <dmwit> o
13:27:47 <Sadache> good day
13:28:06 <tgeeky> dmwit: I suppose he wasn't quite that negative.
13:28:32 <tgeeky> While I found several applications of metamorphisms, the approach also seems to run into difficulties when trying to implement more complex applications. So going forward, I would be interested to either learn about new applications, or, which would be IMO equally or even more valuable, what it is about certain applications that prevents them from (or makes it hard) being expressed as metamorphisms. Such insights could lead to
13:29:04 <tgeeky> dmwit: a cleaned up, compilable version of his code is in http://hackage.haskell.org/package/metamorphic-0.1.2.3
13:29:08 <tgeeky> if you want to look at it
13:29:54 <dmwit> Dat module list!
13:29:56 <acowley> That package defies users
13:29:58 <acowley> hah
13:30:00 <acowley> indeed
13:30:10 <acowley> Should've gone with modules Foo, Bar, Baz, etc.
13:31:19 <tgeeky> acowley: I did some substitution of the names, but the flatness of it reflects that it was written before heiarchial models were put into GHC
13:32:01 <acowley> tgeeky: The whole thing looks opaque, though. It's just bad names combined with no documentation.
13:32:26 <dmwit> The documentation is the website, I guess.
13:32:28 <dmwit> and paper
13:32:36 <Sadache> I have two ranges a b and c d, I want to compute a three elements list, of three ranges of the intersection of these two ranges
13:32:44 <Sadache> before, in and after
13:32:55 <acowley> dmwit: Presumably, yes, but as a potential user I wouldn't consider this unless I was really desperate.
13:32:55 <dmwit> > intersection [1..5] [3..10]
13:32:57 <lambdabot>   Not in scope: `intersection'
13:32:57 <lambdabot>  Perhaps you meant one of these:
13:32:57 <lambdabot>    `IM.inters...
13:32:58 <tgeeky> acowley: yep. it's a little better than the original code (in that it's in a hackage package), and worse (in that I obsfucated things renaming things)
13:33:03 <tgeeky> acowley: it's not meant to be used at all.
13:33:10 <dmwit> > intersect [1..5] [3..10]
13:33:12 <lambdabot>   [3,4,5]
13:33:14 <tgeeky> acowley: it's educode
13:33:41 <ParahSailin> @src intersect
13:33:41 <lambdabot> intersect = intersectBy (==)
13:33:46 <acowley> tgeeky: It kind of hits a nerve for me :)
13:33:46 <ParahSailin> @src intersectBy
13:33:46 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
13:34:02 <tgeeky> acowley: I totally understand. The list of TODOs on the package are *huge*.
13:34:25 <dmwit> Sadache: http://stackoverflow.com/q/7468948/791604
13:34:42 <acowley> tgeeky: And I'd rather the code be available than have it squirreled away one one person's hard drive.
13:35:03 <Sadache> if I have for example 1 , 5 and 2,6 it should give 1,2   2,5 5,6
13:35:08 <acowley> tgeeky: So good on you for getting it out there.
13:35:20 <FreeFull> > Node 3 []
13:35:22 <lambdabot>   Node {rootLabel = 3, subForest = []}
13:35:28 <dmwit> Sadache: See my link. It even cleanly generalizes to having more than just two intervals.
13:35:45 <tgeeky> acowley: I could have more directly just fixed his original code, but I didn't understand it at the time. One of the things that stopped me from going further, is I put effort into specifically aligning and spacing certain type signatures
13:35:48 <Sadache> ok thank you, i am looking at it
13:36:04 <tgeeky> and all of that effort is wasted by haddock's reformatting out of a monospaced layout
13:36:50 <tgeeky> Fuuzetsu: there's a request. Change default haddock theme to one which keeps the same monospaced alignment for type signatures :o
13:37:05 <startling> is there a good "decimal" type somewhere?
13:37:15 <dmwit> What is a decimal type?
13:37:20 <hiptobecubic> startling, Ratio Int?
13:37:26 <dmwit> We have many, many good number types.
13:37:30 <hiptobecubic> startling, or do you mean fixed precision
13:37:45 <startling> hiptobecubic, I'd like to be able to query e.g. significant figures
13:37:46 <hiptobecubic> s/Int/Integer
13:38:00 <dmwit> Rational, CReal, Cyclotomic, Fixed
13:38:07 <dmwit> depending on what you want, exactly
13:38:18 <startling> I want to store user-input numbers losslessly
13:38:21 <tgeeky> not cyclotomic, probably (though they are cool)
13:38:27 <dmwit> startling: Rational lets you get a resolution with the "denominator" function.
13:38:39 <startling> dmwit, oh, that's not bad
13:39:22 <startling> do Rational operations simplify them?
13:39:29 <dmwit> yes
13:39:36 <hiptobecubic> Do we have a type that propagates uncertainty?
13:39:39 <dmwit> > 5/10 :: Rational
13:39:41 <lambdabot>   1 % 2
13:39:50 <startling> hmm
13:40:34 <dmwit> hiptobecubic: I think there is a package for interval arithmetic.
13:41:00 <hiptobecubic> hm
13:41:28 <dmwit> Seems there are several, in fact. =)
13:42:03 <mgsloan> yeah, I think there's only one that actually uses proper rounding modes, though.  That could have changed since I looked of course
13:42:49 <mgsloan> yeah, edwardk's intervals is good stuff
13:43:03 <mgsloan> err nvm
13:43:54 <yogert> Hey all, could someone help me understand why something looking like this doesn't work. http://hpaste.org/88774 I'm guessing its because "Foo" wraps another type and in the class declaration "boo" is a type of "a -> b -> [b]", whereas it really should be "Foo a -> a -> [a]"
13:44:19 <mgsloan> So, looks like intervals-0.1.* controls rounding mode, but 0.2.* doesn't :/
13:45:09 <dmwit> yogert: Yes, that's roughly right: boo will be expected to have type "Foo a -> b -> [b]" but the function you wrote has type "Foo a -> a -> [a]", which is more specific.
13:45:41 <yogert> How might I fix that in the class declaration?
13:45:46 <dmwit> There's a couple ways.
13:45:50 <yogert> given that "a" is Foo a
13:45:56 <dmwit> You could write class Bar f where boo :: f a -> a -> [a], for example.
13:46:28 <yogert> huh. I thought I tried that and had the same problem…
13:46:29 <dmwit> Or, you might choose class Bar a where type Elem a; boo :: a -> Elem a -> [Elem a]
13:46:30 <yogert> one sec
13:46:43 <Fuuzetsu> tgeeky: I'm unsure what you're asking about. The type signatures seem aligned to me.
13:47:03 <dmwit> Fuuzetsu: People sometimes like to make ASCII art out of their type signatures.
13:47:12 <Fuuzetsu> Do you want it to preserve the spaces in cases like ‘IO      ()’? If yes, I recommend that you file a feature request on the track.
13:47:15 <dmwit> This is lost when haddock does its pass, because haddock respaces everything.
13:47:50 <dmwit> I'm pretty sure I don't want haddock to preserve whitespace by default, but as you say it seems like a feature request by some not-default means.
13:48:25 <yogert> dmwit: yeah when I try the first suggestion i get an error complaining about a kind mismatch
13:48:31 <Fuuzetsu> Yes, I don't think that would be desirable either. A flag would be better I guess…
13:48:41 <dmwit> yogert: Yes, you will need to modify your instance declaration to match, of course.
13:48:53 <dmwit> yogert: e.g. instance Bar Foo instead of instance Bar (Foo a).
13:49:23 <dmwit> Fuuzetsu: It would probably have to be some binding-specific thing. I'm sure I wouldn't want to only be able to enable and disable it for whole modules, let alone whole packages.
13:49:28 <yogert> ooh
13:49:30 <yogert> ok
13:49:53 <dmwit> yogert: Are you sure you want a type class at all...?
13:50:35 <yogert> nope : )
13:50:51 <yogert> I'm just playing around
13:51:50 <yogert> But, so far, in my usage of Haskell, I haven't come across a situation which screamed to me that I needed to use a typeclass. How often do you make use of them/
13:51:51 <yogert> ?
13:52:12 <yogert> but that could simply be my inexperience etc
13:52:30 <Nik05> wow many people here nice, hi :)
13:52:40 <ski> yogert : i think it's not *that* common to want to make a new type class
13:53:11 <ski> yogert : generally, you should at least have two different instances of it in mind, if you consider defining one
13:53:35 <adnap> I am having a problem with the Haskell interpreter. I am interpreting an expression which includes a call to a foreign function, and I get a GHC runtime exception saying the symbol for the C function is "unknown"
13:53:35 <ski> and you should consider whether not a record, or some other approach would be sufficient (or better) for what you want to do
13:53:36 <yogert> okay. What I imagined they would be best for was interoperable libraries.
13:53:37 <Fuuzetsu> @package proxy
13:53:37 <lambdabot> http://hackage.haskell.org/package/proxy
13:53:58 <acowley> Why do I always want to zip together traversables?
13:54:04 <adnap> However, when I call the function normally, outside of an interpret, it works fine
13:54:13 <dmwit> Well, there's a handful of small typeclasses that I've implemented over and over.
13:54:13 <adnap> I can paste the whole example if necessary
13:54:14 <yogert> But for my usage I couldn't see any reason not to simply create a function with the desired type
13:54:39 <dmwit> PPrint, Parse, Attoparse come to mind right off the bat
13:54:53 <yogert> those are classes you implement?
13:55:26 <dmwit> Those are classes that I have probably declared in half a dozen toys and instantiated 50 times or more.
13:55:42 <dmwit> I used to declare and implement Default and Universe over and over, too, but at least those are on Hackage now. =)
13:55:53 <ski> signatures of `PPrint' ?
13:55:54 <yogert> Univeraw?
13:56:09 <adnap> Why wouldn't you just create a package with your classes and import it?
13:56:29 * ski would presume inertia
13:56:36 <dmwit> ski: Basically the same as Show, but not as a pre-image of Read.
13:56:56 <yogert> this it?
13:56:56 <yogert> http://hackage.haskell.org/package/universe-th-0.0.0.6
13:57:05 <dmwit> ?hackage universe <- no, this
13:57:05 <lambdabot> http://hackage.haskell.org/package/universe <- no, this
13:57:08 <yogert> http://hackage.haskell.org/package/universe-th-0.0.0.6
13:57:10 <yogert> oh
13:57:15 <ski> dmwit : so no fancy indenting or stuff, then ?
13:57:33 <adnap> So, nobody knows the answer to my problem?
13:57:37 <acube> @hackage lens <- this + Data + uniplate (from Data.Data.Lens)
13:57:37 <lambdabot> http://hackage.haskell.org/package/lens <- this + Data + uniplate (from Data.Data.Lens)
13:57:38 <dmwit> ski: Depends how big of a thing I'm gonna need to pprint. =)
13:57:41 <dmwit> (but mostly no)
13:59:39 <dmwit> acowley: I could have sworn edwardk had a package with a class for zipping, but now I can't find it.
13:59:59 <edwardk> keys
14:00:18 <dmwit> Yes, keys.
14:01:01 <acowley> dmwit: I end up whining about this every few weeks, and every solution ends up going through lists or otherwise being iffy due to the potential for mismatched lengths.
14:01:01 <dmwit> alternately: Applicative =P
14:01:13 <dmwit> yes
14:01:28 <dmwit> You might look at unification-fd's solution, too, though with unification mismatched shapes is usually okay
14:01:35 <acowley> Really, I should stop whining about it. But it's a surprise how frequently I run into it.
14:01:38 <dmwit> because the mismatched shape on one end will be a unification variable, which is fine.
14:02:31 <Sadache> I looked at the SO answer and it doesn't seem to be solving the same problem, my problem is having two overlapping ranges and splitting the first range into three ranges: before, in and after the second range
14:02:37 <dmwit> (What do you want to happen when the shapes don't match?)
14:03:50 <acowley> dmwit: The truth is I'm usually reasoning about things using information not captured in the types.
14:03:56 <Shamar> I've a puzzle on lazy IO
14:03:57 <dmwit> Sadache: You're right. I apologize. The SO problem is symmetric and your problem is asymmetric.
14:03:59 <Shamar> http://hpaste.org/88777
14:04:01 <dmwit> Sadache: I misunderstood you.
14:04:06 <dmwit> Sadache: Okay, so what have you tried?
14:04:30 <Shamar> can anybody help me understand what's wrong with such simple function?
14:04:31 <Sadache> for 1,5 2,4 it will give 1,2 2,4 4,5
14:04:40 <carter> acowley you'll be at hackphi yes?
14:04:46 <acowley> carter: Yes!
14:04:51 <carter> woot
14:05:34 <Sadache> dmwit:  no problem
14:05:44 <dmwit> Shamar: no lazy IO here...
14:06:04 <Sadache> for 2,4 1,5 it will give empty 2,4 empty
14:07:03 <Shamar> the problem is: read more than 10000 medium sized files (> 3M) one at a time, for each file collect some statistics (around 10 Double), collect the statistics in a list, Binary.encodeFile the list
14:07:21 <Shamar> dmwit, really? why?
14:07:32 <FreeFull> > do do do do do do 3
14:07:33 <lambdabot>   3
14:07:44 <Shamar> I've tried with pipes too... but with no success
14:07:53 <fizbin> @type do do do do do do 3
14:07:54 <lambdabot> Num a => a
14:08:00 <Shamar> still too much memory
14:08:19 <FreeFull> > id id id id id id id 3
14:08:21 <lambdabot>   3
14:08:47 <dmwit> Shamar: Hm. Well, which thing did you expect to do lazy IO?
14:09:26 <hpc> > do bedo bedo
14:09:29 <lambdabot>   dobedo
14:09:53 <Shamar> read files, collect stats... it's not that I WANT to use lazy IO
14:09:53 <fizbin> Oh, right. NumInstances gives us "3" as r -> Int and r-> has a Monad instance.
14:09:59 <dmwit> fizbin: nope
14:10:01 <dmwit> > do ()
14:10:02 <lambdabot>   ()
14:10:02 <fizbin> > 3 "a"
14:10:04 <lambdabot>   3
14:10:10 <Shamar> I want to read files, collect stats... :-)
14:10:10 <hpc> fizbin: try desugaring it
14:10:14 <dmwit> fizbin: I mean, that's true, but it's not what's happening here.
14:10:32 <ezyang> If I gave you the type "Map (Key a) a", and told you GADTs were on, what do you think this map would be?
14:10:36 <Shamar> the problem, seem to be that I want to use a binary file
14:10:47 <FreeFull> > do id do id do id do ":D"
14:10:49 <lambdabot>   <hint>:1:7: parse error on input `do'
14:10:53 <FreeFull> Aww =P
14:11:12 <Shamar> that requires the full list to be computed and stored in memory...
14:11:52 <dmwit> > do id $ do id $ do id $ do ":D"
14:11:53 <lambdabot>   ":D"
14:12:04 <hpc> Haskell' request: the ability to run (function do {...}) without the intervening ($)
14:12:10 <hpc> ditto for lambda in place of do
14:12:14 <adnap> :t setTopLevelModules
14:12:15 <lambdabot> Not in scope: `setTopLevelModules'
14:12:16 <beaky> the dollar sign operator is very ugly
14:12:19 <fizbin> @type \x -> do x
14:12:21 <lambdabot> t -> t
14:12:34 <fizbin> Ah. That's what's going on.
14:12:37 <Shamar> I could use a csv files or just the show of the stats... but I CANT understand why I have to change my requirements for using Haskell
14:12:53 <dmwit> Shamar: You should not have to change your files.
14:13:13 <dmwit> Shamar: You have some choices for next steps.
14:13:14 <adnap> I don't understand the difference between setImports and setTopLevelModules
14:13:19 <adnap> http://hackage.haskell.org/packages/archive/hint/0.3.3.6/doc/html/Language-Haskell-Interpreter.html
14:13:20 <dmwit> Shamar: 1. Run the profiler and learn to read its output.
14:13:37 <dmwit> Shamar: 2. Concoct a minimal, but complete, example showing something that uses a lot of memory and try asking here again.
14:14:03 <dmwit> Shamar: (Your current code isn't very minimal, and also isn't complete as far as I can tell -- decodeFile is missing, sampleAnalysis is missing, etc.)
14:15:04 <ski> ezyang : not a map where type of values depend on which GADT constructor a key was, anyway ..
14:15:31 <Shamar> mmm... let's try with 2... sorry for the example, I hoped that it had some evident error
14:15:56 <ezyang> ski: Does it work?
14:15:59 <adnap> Oh, setTopLevelModules only works on modules whose source is available and it brings everything, including non-exported symbols, into scope
14:16:11 <ski> ezyang : your type, or what i described ?
14:16:24 <ezyang> Both, I suppose
14:16:35 <ski> well, i'm not sure what you wanted your type to express
14:16:45 <ski> (and i don't know where `a' is bound)
14:17:12 <ski> for what i described, i think you'd need a new type of map
14:17:12 <ezyang> Hmm. (forall a. Map (Key a) a)
14:17:21 <ezyang> Yeah, that's what I was thinking too.
14:17:21 <ski> doesn't help, no
14:17:25 <dmwit> ezyang: I feel like this is a trick question, but... I would expect to have a map whose values had type "a" and whose keys had type "Key a".
14:17:37 <ski> and `foo :: forall a. Map (Key a) a -> ...' wouldn't help either
14:17:46 <ezyang> Well, that's more wrong
14:17:47 <ski> (regardless of whether `...' mentions `a' or not)
14:17:52 <example`> \quit
14:17:54 <example`> quit
14:17:58 <dmwit> Perhaps you should make it Map (Key A) A -- ?
14:18:06 <example`> how i shut down the ERC ?
14:18:08 <ski> /quit
14:18:14 <example`> thanks
14:18:26 <ezyang> dmwit: What's the difference¿
14:18:39 <dmwit> A is not polymorphic =)
14:18:40 <ski> a value in `forall a. Map (Key a) a' wouldn't be what i described
14:18:52 <ezyang> dmwit: Ah, but that's cheating! :-(
14:19:18 <ezyang> Right, so what I would like is a map, where the value depends on the key, and I can pattern match on the key to refine the result of the map.
14:19:30 <dmwit> ezyang: Well, I expect the "a" in "Map (Key a) a" not to be polymorphic, either. That is, I expect it will eventually be instantiated to some monomorphic type.
14:19:30 <ski> `forall a. Map (Key a) a' is simply the type of a polymorphic map, whose keys all have type `Key a', for any type `a', and corresponding values have type `a'
14:20:04 <ezyang> Curiously enough, [forall a. (Key a, a)] would work fine, that's just a classic heterogenous list
14:20:14 <applicative_> Shamar: the isBinary test is unnecessarily complicated; why not isBinary xs = take 4 (reverse xs) == "nib." or the like
14:20:23 <ski> ezyang : if `a' is instantiated, then it'd be a map where all the keys had the same type, say `Key Blah', and the values all had type `Blah'
14:20:33 <ski> ezyang : nope
14:20:36 <dmwit> ezyang: You are hoping for the dependent type "Map Key (\key : Key -> elem)", I guess.
14:20:47 <ski> ezyang : itym `[exists a. (Key a,a)]'
14:20:48 <ezyang> ski: Oh, really? Oops!
14:20:50 <dmwit> ezyang: We don't do those in Haskell. =)
14:20:54 <ezyang> oh yes, I need another data-con
14:21:00 <applicative_>  isBinary xs = take 4 (reverse xs) == reverse ".bin"
14:21:20 <ezyang> OK, so that's how you do it.
14:21:36 <ezyang> Map (Key a) (exists b. Key b, b)
14:21:38 <ski> ezyang : what i described above is basically the `[exists a. (Key a,a)]' idea, though possibly using an ordering on keys and a tree instead of just an equality
14:21:48 <ski> huh ?
14:22:03 <ezyang> with some representational cleverness to eliminate the redundant copy of Key
14:22:11 <ski> (a) `(exists b. Key b, b)' means `((exists b. Key b),b)'
14:22:15 <dmwit> ezyang: Perhaps you would like something like Map TypeDescription (Map Key Dynamic)?
14:22:26 <ski> (b) what does the type `a' (and the free `b') represent here ?
14:22:29 <ezyang> Dynamic? Why I never!
14:22:29 <dmwit> or Map (Key, TypeDescription) Dynamic, I guess
14:22:42 <ezyang> Hmm, that doesn't work does it
14:22:47 <fizbin> ski: you have some sort of ordering that works across key types?
14:22:58 <ezyang> Map (exists a. Key a) (exists a. Key a, a)?
14:22:59 <dmwit> ezyang: You would wrap it in some more principled-ly-typed accessors, of course. =)
14:23:08 <adnap> Anyway, here's my code demonstrating my problem: http://hpaste.org/88779
14:23:28 <dmwit> ezyang: The problem you're having is that you want the value (or type) of the key to be bound when choosing the type of the value.
14:23:33 <Shamar> applicative_, ok just written the first thing that I thought :-)
14:23:34 <ezyang> I suppose the point of the matter is I want to ignore 'a' for the purposes of lookup; it's only relevant when I actually am trying to look at a
14:23:34 <dmwit> Haskell doesn't really have a syntax for that.
14:23:43 <fizbin> I'll note that I've seen people flail when attempting to address this problem in the much more loosey-goosey java type system.
14:23:46 <ezyang> dmwit: Hmm.
14:24:08 <ski> fizbin : it's a simple generalization of `class Eq1 f where eq1 :: f i -> f j -> Maybe (Equal i j)'
14:24:13 <ski> ezyang : consider `newtype Map1 key value = MkM1 (Assoc1 key value); data Assoc1 key value = forall i. MkA1 (key i) (value i)' -- this is roughly what i had in mind
14:24:32 <ski> ezyang : er, `newtype Map1 key value = MkM1 [Assoc1 key value]', i.e.
14:25:07 <ski> (this is just an encoding of `[exists a. (key a,value a)]')
14:25:18 <chrisdone> hey ski
14:25:31 <ski> and then we could have `lookup1 :: Eq1 key => Map1 key value -> key i -> value i'
14:25:44 <fizbin> ski: what's this "Equal" type class?
14:25:44 <ski> hello chrisdone
14:25:46 <chrisdone> finally got that backtick surgically removed? ;-)
14:26:17 <ski> fizbin : no type class. `data Equal :: * -> * -> * where Refl :: Equal a a'
14:26:25 <ski> (backtick ?)
14:27:08 <dmwit> fizbin: You also know it as ~
14:27:16 <dmwit> with some minor differences.
14:28:12 <fizbin> dmwit: no, I don't. It seems to be a compile-time assertion that two types are equal, masquerading as a type.
14:28:15 <chrisdone> (ski: you used to be ski` last i remember)
14:28:22 <dmwit> fizbin: That is just what it is.
14:28:32 <chrisdone> (ski: or maybe ski_`)
14:28:34 <ski> `Eq1' is a class for "(decidable) heterogenous equality" -- more or less John-Major equality, i think
14:28:47 <ski> just an underscore, i believe
14:29:29 <ski> ezyang : anyway, to get your `[exists a. (Key a,a)]', just set `value' to `Identity'
14:30:07 <fizbin> Ok, but I can't figure out what a value of type "Equal Int Int" or "Equal String String" would be. It seems there's only one value of type "Equal a a" for any a, the way there is for (). Correct?
14:30:16 <ski> yep
14:30:19 <Shamar> Stack space overflow: current size 3221225472 bytes.
14:30:22 <Shamar> :-(
14:30:35 <Shamar> this with the pipe-based version...
14:30:56 <ski> fizbin : if you have a value of type `Equal a b' for some unknown types `a' and `b', then if you `case' on it, matching on `Refl', then in that branch the type system knows that `a' is actually the same type as `b'
14:31:36 <mm_freak> 'lens' has reached the point where i usually have to import it qualified
14:31:43 <Shamar> I go for textual files that can be written one line at a time... it should be easier
14:31:54 <ski> fizbin : so, it's a way to reflect compile-time knowledge of type equality into a run-time value, and back
14:32:40 <bakingbread> hi! I see in the code operators like <+>, =?, --> ... can I have a list with description what they do? google really sucks at searching funky names like these
14:32:58 <monoidal> bakingbread: http://www.haskell.org/hoogle/
14:33:01 <ski> fizbin : as a very simple example, `foo :: Equal Int a -> a -> a; foo Refl n = n + 1' -- after having matched on `Refl', it knows that the type `a' is really `Int', and so can call `+' on it
14:33:21 <fizbin> Okay… but (Equal Int String) is still a valid type, the way Void is a valid type with no values.
14:33:23 <bakingbread> monoidal: lol.. cool stuff.. thanks
14:33:30 <ski> fizbin : yep
14:33:49 <ski> (you can't make any (non-bottom) value in `Equal Int String')
14:34:18 <mm_freak> edwardk: how does the performance of 'tables' compare to ixset?
14:34:19 <fizbin> So ok. I think I see now how Eq1 is heterogenous equality.
14:34:23 <ski> bakingbread : different libraries may have different definitions of such operations. you should consult the libraries the code you're reading is using
14:34:48 <edwardk> mm_freak: haven't benchmarked. i was mostly concerned with having a non-terrible API
14:35:11 <edwardk> palmik has some benchmarks i think showing both data-store and tables beating ixset, but data-store edging out tables
14:35:31 <edwardk> i'm not willing to build the horrible API that would be required to win the benchmark ;)
14:36:34 <mm_freak> i'm not even sure i want to go the acid-state route with this project
14:36:42 <DanC> anybody here using haskell to get at data from MS SQL Server?
14:36:54 <mm_freak> but then my earlier question remained unanswered, probably for a good reason =/
14:37:22 <mm_freak> → is there another relational algebra library than haskelldb for (at least) postgresql?
14:37:37 <applicative_> Shamar: what does your version look like now?
14:37:52 <ski> fizbin : the idea for `Eq1 f' is that the operation `eq1' will satisfy laws `forall i j. forall (fi :: f i) (fj :: f j). eq1 fi fj = Just Refl => fi = fj' and `forall i j. forall (fi :: f i) (fj :: f j). eq1 fi fj = Nothing /\ (Refl :: Equal i j) => fi =/= fj'
14:38:54 <ski> (where `=' means semantic equality, and `=/=' semantic inequality)
14:40:43 <shachaf> twanvl++
14:40:46 <fizbin> ski: right.
14:40:48 <shachaf> twanvl_: Thanks!
14:41:05 <startling> did we ever figure out good lensy things disparate for sum types?
14:41:12 <startling> er, "for disparate sum types"
14:41:17 <twanvl_> shachaf: you are welcome
14:41:28 <dsaa-temp> mm_freak: Did you take a look at Esqueleto?
14:42:16 <Shamar> applicative_, the one with pipes?
14:42:37 <edwardk> startling: ?
14:42:42 <Shamar> it's far longer than the lazy one...
14:42:50 <mm_freak> dsaa-temp: thanks for the pointer!
14:43:18 <applicative_> Shamar: oh.  Anyway, I was just trying to figure out the types of the stuff missing from your paste
14:43:28 <mm_freak> "Currently only SELECTs are supported." =/
14:43:53 <startling> edwardk, say I have data A = B String | C Int . what's the best way to have lenses on the String and/or the Int?
14:44:12 <dsaa-temp> mm_freak: you're welcome! I just came in, why are you giving up on acid-state?
14:44:20 <edwardk> you can have a traversal of the string and a traversal of the int, and/or you can have a prism that leads to each
14:44:46 <dsaa-temp> mm_freak: I'm actually contemplating the possibility of using it for a project
14:44:49 <edwardk> makePrisms ''A   will give you prisms named _B and _C that get to the string and int respectively
14:45:59 <mm_freak> dsaa-temp: i'm not giving it up, but i'm anticipating a lot more datasets than will fit into my memory, while only a small subset of them will really be in use
14:46:20 <Shamar> dateOf provide a Day, history xs = MyList xs, sampleAnalysis tA tB is a pure function returning a tuple of 10 doubles
14:46:31 <Shamar> applicative_, dateOf provide a Day, history xs = MyList xs, sampleAnalysis tA tB is a pure function returning a tuple of 10 doubles
14:46:36 <mm_freak> only this particular project may suffer from that, and i don't want to find myself having to migrate to postgresql later when the site is already live =)
14:47:28 <Shamar> buildDay is another smart constructor for something like ([a], Day)
14:47:43 <dsaa-temp> mm_freak: You can always purchase more memory…
14:49:03 <mm_freak> dsaa-temp: say you have one billion data sets and your memory can only hold one million =)
14:49:22 <mm_freak> don't worry, i'm a fan of acid-state, and i use it where it's appropriate ;)
14:50:44 <startling> edwardk: yeah, I get that you can have a traversal -- it's kind of clumsy, though. prisms look promising; I'll have a look.
14:51:58 <mm_freak> i wonder if it would be a good idea to write a relational algebra library
14:52:14 <mm_freak> would be a nice alternative to lenses for certain data models
14:53:34 <mm_freak> for now i'll just go with tables and swap out part of the data manually if necessary
14:53:58 <jamy> Are the mistake when for helper function using the same name as main function? Like this: fun a = fun a [] where fun b c = b:c
14:54:15 <mm_freak> edwardk: still no TH… =/
14:54:41 <mm_freak> jamy: it's not a mistake per se, but you shadow your outer 'fun' function
14:54:51 <mm_freak> so you can't recurse directly
14:56:09 <jamy> So shadowing outer function its by standarts?
14:56:17 <mm_freak> jamy: a common naming scheme is to go with "fun'", "go", "loop" or an abbreviation of the actual function name, depending on what you're doing…
14:56:23 <mm_freak> jamy: yes
14:56:48 <jamy> ok. Thanks!
14:56:54 <mm_freak> jamy: or well, i'm not sure i understood your question…  it's standard, but it's not used much =)
14:57:08 <mm_freak> shadowing is usually a bad idea
14:57:55 <mm_freak> when refactoring it may replace "not in scope" errors by weird type errors and in edge cases even by bugs
15:00:23 <jamy> <offtopic>Anybody here earn money by work on Haskell?</offtopic>
15:00:34 <mm_freak> jamy: me
15:00:41 <ezyang> jamy: Does a PhD stipend count? :-)
15:00:57 <jamy> no. Only busines
15:01:31 <mm_freak> jamy: well, i don't work "on" haskell, i work in haskell =)
15:01:53 <jamy> mm_freak: What???
15:02:10 <johnw> jamy: me too
15:02:21 <Clint> i work under haskell
15:02:24 <mm_freak> i don't work on the language/tools, i use the language/tools to get stuff done
15:02:26 <johnw> i work around haskell some days
15:02:51 <jamy> sory for my English =)
15:03:11 <mm_freak> no worries, i'm not a native english speaker either =)
15:04:07 <jamy> mm_freak: how you find this job? Or you work for self?
15:04:17 <mm_freak> jamy: the latter
15:05:47 <Shamar> but shouldn't "decodeFile file >>= \x -> return $! show" be a strict IO String function?
15:06:08 <jamy> mm_freak: and enough money?
15:07:11 <mm_freak> jamy: enough to live =)
15:07:33 <mm_freak> Shamar: as far as i see that's a type error
15:07:38 <mm_freak> (likely)
15:07:51 <Shamar> ??
15:08:25 <johnw> (return $!) . show
15:08:26 <mm_freak> it's missing an 'x' at the end, i guess
15:08:28 <johnw> is what I think you meant
15:08:31 <johnw> or yeah
15:08:35 <johnw> it's a lambda, you need the x at the end
15:08:45 <Shamar> ehm... yes
15:08:48 <mm_freak> Shamar: anyway, the ($!) strictifies it, but probably not the way you would expect
15:08:51 <Shamar> missing x at the and
15:08:52 * hackagebot hlibgit2 0.18.0.6 - Low-level bindings to libgit2  http://hackage.haskell.org/package/hlibgit2-0.18.0.6 (JohnWiegley)
15:08:58 <adnap> Will someone help me?
15:09:04 <mm_freak> in particular the actual string is not computed…  it's just established whether the string is empty or not
15:09:24 <Shamar> ??? :-o
15:09:30 <mm_freak> Shamar:
15:09:33 <Shamar> is not computed?
15:09:39 <mm_freak> > [undefined] `seq` ()
15:09:41 <lambdabot>   ()
15:09:44 <Clint> adnap: impossible to predict
15:10:06 <adnap> http://hpaste.org/88779
15:10:21 <adnap> I can't interpret code using foreign functions
15:10:33 <mm_freak> Shamar: f $! x = x `seq` f x
15:10:54 * Shamar feels dumb...
15:10:57 <Shamar> ok
15:10:58 <johnw> adnap: you're not providing us with a question to answer
15:11:07 <mm_freak> Shamar: in the case of 'return' for IO it pretty much means:  "don't go any further before computing the outermost constructor of the given thing"
15:11:31 <mm_freak> now String = [Char]
15:11:41 <mm_freak> and for a list the outermost constructor only determines whether the list is empty
15:11:54 <mm_freak> i.e. it determines whether the [] or the (:) constructor has been used
15:11:58 <Shamar> wow...
15:12:01 <Shamar> ok
15:12:13 <mm_freak> to compute the entire string you will have to use deepseq or ($!!)
15:12:25 <mm_freak> but i highly doubt that artificially adding strictness is what you want
15:12:35 <Shamar> now, what if instead of show would be a smart constructor?
15:12:59 <Shamar> a function that call a constructor and pass it's arguments
15:13:07 <mm_freak> Shamar: doesn't change the semantics of 'seq' =)
15:13:25 <mm_freak> Shamar: in haskell producers are usually lazy and consumers are usually strict
15:13:30 <mm_freak> this is how you should model your interfaces
15:13:35 <mm_freak> don't add strictness for producers
15:13:53 * hackagebot hamid 0.8 - Binding to the OS level MIDI services (fork of system-midi).  http://hackage.haskell.org/package/hamid-0.8 (HansHoglund)
15:14:03 <adnap> johnw: The question is, "can this code be modified to work?"
15:14:12 <johnw> I have no idea what's wrong with your code
15:14:22 <adnap> Try compiling it
15:14:26 <johnw> no thank you
15:14:31 * adnap laughs
15:14:42 <johnw> if you show me the error that *you're* seeing, I might have an opinion
15:14:50 <Shamar> this looks like a good advice... :-)
15:14:51 <johnw> but don't ask me to do the work to present your issue
15:14:54 <adnap> It compiles
15:14:56 <adnap> Then it says
15:14:57 <adnap> 42.42
15:14:57 <adnap> Main: External.o: unknown symbol `f'
15:14:58 <adnap> GhcException ""
15:15:39 <johnw> I think your import ccall is wrong.  Why is there an "f.h f"?
15:15:43 <adnap> (When you run the executable
15:15:48 <adnap> johnw: It's not wrong
15:16:04 <adnap> johnw: The f.h is unnecessary. It's the old style, but it's not wrong
15:16:24 <johnw> ah, hadn't seen it before
15:16:48 <Shamar> mm_freak, but what if I have long list of binary files: "mapM decodeFile list" looks a reasonable approach (while it exhaust resources)
15:16:58 <johnw> should the type of cf be Ptr CFloat?
15:17:05 <adnap> johnw: No
15:17:10 <adnap> johnw: The function returns a float
15:17:43 <johnw> i dunno then
15:17:53 <mm_freak> Shamar: i doubt that any reasonable portion of that remains unevaluated given that decodeFile is an IO action
15:19:35 <mm_freak> Shamar: why are you doing this anyway?  are you getting overflow errors?
15:19:49 <Shamar> yes
15:19:51 <Shamar> sigh
15:20:31 <mm_freak> Shamar: what you're doing won't fix it
15:20:46 <mm_freak> Shamar: where does the overflow happen?  decodeFile?
15:20:52 <Shamar> I'm tring to load the file (large) evalate a pure function that should produce a small ADT and return just that...
15:21:34 <Shamar> no... actually no, when I try to encodeFile a list of the values
15:22:00 <mm_freak> Shamar: so you decodeFile, transform, encodeFile again…  and encoding overflows?
15:22:48 <Shamar> yes, but I decode a lot of large files, transform each one and encode the list of the results
15:22:58 <mm_freak> Shamar: i don't know your data model, so i can only speculate, but the error is probably inside of decodeFile
15:23:13 <mm_freak> Shamar: are you aware of the difference between foldl and foldl'?
15:23:33 <applicative_> how many files are there buried in these subdirectories Shamar?
15:23:35 <Shamar> mm_freak not so much...
15:23:43 <Shamar> 10129
15:23:46 <applicative_> foldl is on the index
15:23:53 <Shamar> right noe
15:23:55 <Shamar> right now
15:24:13 <mm_freak> Shamar: this is about strict producers…  sometimes you don't produce the individual steps to a result, but only the end result
15:24:30 <mm_freak> the simplest way to capture this notion is foldl, but it has a problem:
15:24:46 <mm_freak> foldl f z (x:xs) = foldl f (f z x) xs
15:25:00 <mm_freak> it passes an unevaluated chunk recursively
15:25:06 <enthropy> adnap: the same kind of problem happens if you try 'ghci External.hs'. That problem doesn't exist if you try to print f from a 'ghci f.o External.hs'
15:25:09 <mm_freak> this is where foldl' steps in:
15:25:22 <blaenk> @undo a <- (*2); b <- (+10); return (a+b)
15:25:22 <lambdabot>  Parse error at "<-" (column 3)
15:25:22 <mm_freak> foldl' f z (x:xs) = let y = f z x in y `seq` foldl f y xs
15:25:27 <blaenk> how do I use the @undo command?
15:25:32 <blaenk> @undo do a <- (*2); b <- (+10); return (a+b)
15:25:32 <lambdabot> (* 2) >>= \ a -> (+ 10) >>= \ b -> return (a + b)
15:25:35 <blaenk> there we go
15:25:36 <mm_freak> don't call recursively until the intermediate result is evaluated
15:25:45 <mm_freak> Shamar: you may be experiencing a problem of that sort
15:25:52 <mm_freak> accumulating without forcing evaluation
15:26:05 <Shamar> yes, that's my guess
15:26:18 <Shamar> but I can't understand how to force evaluation
15:26:22 <applicative_> Shamar: try something like this, maybe to structure the IO ? http://hpaste.org/88780 It is well behaved printing the first 4 lines of all the haskell on my system.
15:26:24 <mm_freak> Shamar: if you paste your decodeFile source code, i can probably point you to the problem
15:27:20 <Shamar> that's the decodeFile of Data.Binary
15:27:26 <mm_freak> oh
15:27:54 <mm_freak> Shamar: but then you said you fold the individual results for many files
15:28:02 <mm_freak> you didn't express it that way though =)
15:28:44 <Shamar> ehm... what I did say?
15:28:48 * Shamar confused...
15:29:14 <mm_freak> Shamar: you decode many files and accumulate their results
15:29:18 <mm_freak> right?
15:29:27 <Shamar> yes
15:29:41 <mm_freak> how exactly do you combine them?  do you fold?
15:29:56 <Shamar> no
15:30:05 <mm_freak> mapM and then recurse on the list?
15:30:27 <Shamar> http://hpaste.org/88777
15:30:47 <Shamar> loadMeasure file = putStrLn file >> decodeFile file >>= \x -> return $ sampleAnalysis tA tB x
15:31:00 <Shamar> this is the function that I mapM over the list of file names
15:31:42 <Shamar> sampleAnalysis is a pure function returning a small tuple of Double
15:32:27 <Shamar> (it's not a tuple, actually, just an ADT build with data keyword)
15:34:06 <mm_freak> Shamar: minor style note:  f x >>= \y -> return (g y) = fmap g (f x)
15:34:23 <johnw> or: loadMeasure file = sampleAnalysis tA tB <$> (putStrLn file >> decodeFile file)
15:34:57 <adnap> enthropy: But did you see my Makefile? I am including the object file in the ghc --make command
15:35:12 <blaenk> anyone know of resources for the function monad? I don't know if that's what its called, it's described in the sectionf or the reader monad
15:35:13 <blaenk> instance Monad ((->) r)
15:35:16 <mm_freak> loadMeasure file = putStrLn file >> fmap (sampleAnalysis tA tB) (decodeFile file)
15:35:29 <johnw> oh snap!
15:35:35 <johnw> yeah, that's better
15:35:36 <mm_freak> blaenk: newtype Reader r a = Reader (r -> a)
15:35:37 <adnap> enthropy: Notice in my main function that I successfully print the result of f before trying to interpret it
15:35:49 <mm_freak> blaenk: does that help?
15:36:05 <johnw> or better, drop the putStrLn: loadMeasure = fmap (sampleAnalysis tA tB) . decodeFile
15:36:11 <blaenk> nah I'm having trouble at a more basic level, I can't understand the 'function monad' or whatever, like the way the bind function works
15:36:20 <blaenk> mainly
15:36:33 <startling> :t (>>=) -- blaenk
15:36:35 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:36:37 <mm_freak> blaenk: Reader r and '(->) r' are the same thing, the former is just wrapped by a Reader constructor
15:36:47 <blaenk> startling: ?
15:37:02 <blaenk> mm_freak: alright, but that's not the misunderstanding I'm having
15:37:04 <blaenk> for example this
15:37:11 <blaenk> h >>= f = \w -> f (h w) w
15:37:14 <enthropy> adnap: right, but hint basically runs a separate ghci
15:37:16 <blaenk> given example
15:37:20 <startling> blaenk, that specifies to "(x -> a) -> (a -> (x -> b)) -> (x -> b)"
15:37:32 <blaenk> > do a <- (*2); b <- (+10; return (a+b)
15:37:33 <lambdabot>   <hint>:1:24: parse error on input `;'
15:37:38 <blaenk> oh pddf
15:37:40 <enthropy> adnap: and that one doesn't get the hint to look into f.o
15:38:03 <johnw> think of the "function monad" as binding on the return value of a function
15:38:05 <blaenk> startling: hmmm okay I'll anaylze that for a second
15:38:07 <johnw> >  (+1) >>= return . (+2) $ 3
15:38:08 <lambdabot>   6
15:38:14 <blaenk> alright let me reread that 5 times
15:38:33 <Shamar> mm_freak, johnw, got it, but this don't make the evaluation stricter... but is the use of mapM the problem here?
15:38:39 <johnw> it's not much different from the functor functor, though
15:38:44 <johnw> > fmap (+2) (+1) $ 3
15:38:44 <mm_freak> blaenk: you have an r -> a and an a -> (r -> b)…  if the argument of the latter function is produced by the former, then you can use (>>=)
15:38:45 <lambdabot>   6
15:38:57 <mm_freak> blaenk: check the type of (>>=) and replace every "m a" by "r -> a"
15:39:07 <enthropy> adnap: doing a bit of digging into how ghci works, it seems that you somehow need to add "f.o" to StaticFlags.v_Ld_inputs
15:39:13 <blaenk> startling did that I think: "(x -> a) -> (a -> (x -> b)) -> (x -> b)"
15:39:14 <enthropy> which may or may not be possible through hint
15:39:16 <blaenk> I'll take a look at it for a bit
15:39:26 <blaenk> what would help me I think is to replace for example what johnw provided
15:39:33 <blaenk> (+1) >>= return . (+2) $ 3
15:39:35 <mm_freak> Shamar: mapM can be a problem /after/ the execution of the IO actions
15:39:45 <blaenk> but 'unwrapped, like replace >>= with what it means, but I don't know
15:39:47 <mm_freak> because it gives you a possibly unevaluated list
15:39:49 <blaenk> I tried doing it but got lost quickly
15:39:58 <adnap> enthropy: Oh, cool. Thanks for explaning. I'm going to read through the Hint hackage docs to see if there's a way to do it through the API
15:39:59 <mm_freak> Shamar: it's important that you traverse that list using a strict consumer
15:40:17 <johnw> blaenk: are you familiar with the functor instance for (->) r?
15:40:18 <hpc> blaenk: a good exercise might be to expand the type signatures of Monad functions from in terms of 'm' to (->)
15:40:24 <hpc> blaenk: and then pass those types through @djinn
15:40:28 <blaenk> johnw: yeah I think so, it's basically compose (.) right?
15:40:40 <johnw> yes
15:40:48 <johnw> but do you know what it's basically like compose?
15:40:51 <blaenk> hpc: yeah startling did that I think: (x -> a) -> (a -> (x -> b)) -> (x -> b)
15:40:51 <johnw> s/what/why
15:40:54 <mm_freak> Shamar: to understand 'seq' just think of pattern matching…  when you pattern-match on the outermost constructor of a Maybe Int, you establish whether it's a Just or a Nothing, but nothing more
15:41:10 <mm_freak> Shamar: case mx of Just _ -> y; Nothing -> y
15:41:17 <mm_freak> there is a shorthand notation for that:  mx `seq` y
15:41:18 <blaenk> johnw: I forgot why but I'll look it up again
15:41:38 <blaenk> @djinn (x -> a) -> (a -> (x -> b)) -> (x -> b)
15:41:38 <lambdabot> f a b c = b (a c) c
15:41:41 <johnw> the function monad is nothing special here, you can think of it as monadic syntax on top of the functor, plus a definition for "return x" that yields "const x"
15:41:44 <Shamar> what make a consumer strict?
15:41:55 <Shamar> for the list, I mean
15:42:01 <mm_freak> Shamar: if it pattern-matches on its argument, it's strict
15:42:16 <blaenk> hmmm okay I think that's given me a lead to follow, I'll give this another try
15:42:19 <blaenk> *johnw
15:42:24 <mm_freak> Shamar: however, you want to be strict on the list /elements/
15:42:34 <Shamar> right
15:42:54 <mm_freak> Shamar: the easiest way to ensure that is to express your traversal in terms of foldl'
15:43:36 <blaenk> instance Functor (r ->) where; fmap f g = (\x -> f (g x))
15:43:41 <blaenk> I understand that one I think
15:43:42 <blaenk> but
15:43:42 <enthropy> adnap: maybe that if you interpret some code that adds to that IORef before interpreting `f' it'll work
15:44:01 <blaenk> h >>= f = \w -> f (h w) w ; I don't understand why it's f (h w) w, and not just f (h w)
15:44:10 <johnw> blaenk: in the function functor, you can think of it as fmap'ing over the *result* of the given function
15:44:23 <johnw> so, fmap g f is applying g to the result of f, which is the meaning of composition
15:44:30 <blaenk> alright cool yeah, makes snse
15:44:49 <blaenk> a connection is primed to be made I think
15:44:52 <blaenk> please go on lol
15:44:52 <Chousuke> blaenk: what is the type of f?
15:45:04 <Chousuke> that's a good place to start
15:45:57 <blaenk> johnw: ?
15:46:02 <blaenk> guess you're typing something
15:46:20 <adnap> enthropy: What IORef?
15:46:30 <johnw> I'm trying to think of the best way to put this
15:46:33 <blaenk> alright
15:46:41 <johnw> h >>= return . f matches your intuition of fmap
15:46:43 <blaenk> to recap, what you last said did help me understand the function functor
15:46:53 <blaenk> I just don't understand why: h >>= f = \w -> f (h w) w
15:46:55 <johnw> h >>= f adds another wrinkle
15:47:05 <blaenk> why unlike the function functor, it's f (h w) w instead of just f (h w)
15:47:18 <enthropy> adnap: StaticFlags.v_Ld_inputs
15:47:20 <blaenk> oh because f (h w) would return a function?
15:47:24 <johnw> exactly!
15:47:38 <blaenk> alright I'll go back to drawing board with that bit of informatino
15:47:56 <mm_freak> blaenk: let me give you a small hint
15:48:00 <enthropy> http://www.haskell.org/ghc/docs/7.6.3/html/libraries/ghc-7.6.3/StaticFlags.html#v:v_Ld_inputs
15:48:08 <blaenk> functor just composes the functions, but monad applies them?
15:48:11 <adnap> enthropy: I can't find the hackage doc that lists StaticFlags.v_Ld_inputs
15:48:33 <enthropy> that's probably because the ghc-api isn't on hackage
15:48:40 <adnap> enthropy: It is
15:48:46 <mm_freak> blaenk: in the context of reader monads it pays off to read "r -> a" not as "function of r that results in an a", but instead:  "a value of type a that depends on a value of type r"
15:48:55 <enthropy> adnap: well in any case check my link above
15:49:01 <blaenk> mm_freak: hmm, alright
15:49:03 <adnap> enthropy: http://www.haskell.org/ghc/docs/7.6.2/html/libraries/ghc-7.6.2/StaticFlags.html
15:49:04 <mm_freak> and where 'r' stays the same all the time:  "a parametric value"
15:49:15 <mm_freak> (>>=) allows you to combine parametric values
15:49:25 <blaenk> oh so in
15:49:28 <blaenk> f (h w) w
15:49:31 <adnap> enthropy: Oh, I was searching for "        "function of r that results in an a", but instead:  "a value of type a that
15:49:32 <blaenk> w would be that r?
15:49:34 <adnap>                   depends on a value of type r"
15:49:35 <adnap> oops
15:49:37 <adnap> 17:46 < enthropy> adnap: well in any case check my link above
15:49:37 <adnap> "        "function of r that results in an a", but instead:  "a value of type a that
15:49:39 <blaenk> and it's giving it to both cause both depend on it?
15:49:41 <adnap>                   depends on a value of type r"
15:49:42 <adnap> >_<
15:49:44 <adnap> 17:46 < enthropy> adnap: well in any case check my link above
15:49:47 <adnap> Sorry
15:49:50 <mm_freak> blaenk: i don't know…  you're outside the reader monad context =)
15:49:56 <blaenk> oh haha
15:50:00 <adnap> I was searchign for StaticFlags.v_Ld_inputs
15:50:01 <enthropy> adnap: you found the `v_Ld_inputs :: IORef [String]'?
15:50:05 <blaenk> I think that's how it is though, seems like it
15:50:05 <adnap> enthropy: Yeah
15:50:13 <johnw> blaenk: yes, every "step" in the monadic chain receives that r, that's how >>= is defined for the reader monad
15:50:21 <johnw> the "r" is the "context"
15:50:35 <blaenk> gonna try to retrace johnw's simple example: (+1) >>= return . (+2) $ 3
15:50:53 <johnw> use equational reasoning, and evaluate it by hand step-by-step
15:51:06 <blaenk> will do
15:51:12 <johnw> then you'll see what happens to the 3, and the results of applying those functions
15:51:27 <blaenk> alright
15:51:30 <mm_freak> blaenk: the example may be confusing, because the (+1) and (+2) represent different things there
15:51:35 <blaenk> there wouldn't happen to be an irc command to do it for me would there xD
15:51:38 <johnw> yes, true
15:51:42 <mm_freak> (+1) is one of those "values parameterized on an r"
15:51:52 <blaenk> right
15:51:55 <mm_freak> (+2) is just a plain old function that you apply to such a parametric value
15:52:06 <johnw> you need this:
15:52:07 <johnw> > (+1) >>= (+) $ 3
15:52:08 <blaenk> ohh really?
15:52:09 <lambdabot>   7
15:52:15 <johnw> break that down
15:52:17 <blaenk> will do
15:52:19 <mm_freak> johnw: that's probably even more confusing =)
15:52:23 <blaenk> o :|
15:52:26 <mm_freak> sin >>= return . f
15:52:33 <blaenk> ok
15:52:39 <mm_freak> 'sin' is a parametric value…  a two-dimensional value so to say
15:52:49 <mm_freak> "return . f" is also such a parametric value
15:53:02 <mm_freak> given x it results in f x
15:53:23 <mm_freak> no
15:53:29 <blaenk> any chance I can get an example I can apply a parameter to at the end
15:53:35 <blaenk> like johnw'
15:53:36 <mm_freak> it ignores its parameter =)
15:53:36 <blaenk> s
15:53:41 <blaenk> oh does it
15:53:52 <Chousuke> remember what the type of the thing on the right hand side of >>= is
15:53:53 <mm_freak> 'return' builds a constant parametric value
15:54:11 <mm_freak> 'return x' ignores the parameter and just gives you a constant x
15:54:15 <adnap> enthropy: I don't know how to import the module. IF I try ":m + StaticFlags" in GHCI, it says...
15:54:18 <adnap>     Could not find module `StaticFlags'
15:54:21 <adnap>     It is a member of the hidden package `ghc-7.4.2'.
15:54:29 <blaenk> Chousuke: will do
15:54:34 <mm_freak> (remember that when i say "parameter" i always refer to that 'r')
15:54:39 <blaenk> mm_freak: oh right
15:55:30 <mm_freak> blaenk: paradoxically one easy way to understand reader monads is by looking at do-notation:  do x <- sin; y <- cos; return (x + y)
15:55:38 <johnw> blaenk: (+) >>= (+1) $ 3 is equivalent to fmap ((+) 3) (+1) $ 3.  It's the definition of >>= for the reader monad which is applying 3  to (+) before composing with (+1).  It's like having a hidden argument which is applied to every function in the chain of composition
15:55:43 <mm_freak> that's a function that returns the sum of the sine and cosine of its argument
15:55:56 <blaenk> mm_freak: I was trying to understand the function monad first, but they seem pretty similar
15:55:57 <Shamar> mm_freak, did you mean something like this?
15:56:00 <Shamar> mapStrict f list = foldl' folding [] list
15:56:00 <Shamar>     where folding xs x = f x : xs
15:56:27 <blaenk> johnw: alright will parse that a bit lol
15:56:29 <mm_freak> Shamar: if the result is another list that is somehow built by applying a function to each element, then foldl' is the wrong approach
15:56:42 <blaenk> johnw: so NOT equivalent to fmap (+ 3) (+ 1) $ 3
15:56:43 <mm_freak> Shamar: because you don't really /accumulate/, you 'map'
15:56:44 <Shamar> sigh!
15:56:52 <johnw> correct
15:56:55 <blaenk> specifically ( (+) 3) (+ 1)
15:56:56 <enthropy> adnap: you need to add a:   -package ghc   since that package is hidden by default
15:56:58 <adnap> enthropy: Looks like I have to do it this way: http://www.haskell.org/haskellwiki/GHC/As_a_library#Getting_Started
15:57:11 <johnw> I think I confused you with the difference in meaning between h >>= f and h >>= return . f
15:57:13 <johnw> sorry about that
15:57:17 <adnap> Hah
15:57:20 <blaenk> no worries
15:57:20 <Shamar> yes, I map... but I need to map strictly! sigh!
15:57:35 <blaenk> :t fmap ((+) 3) (+1)
15:57:36 <lambdabot> Num b => b -> b
15:57:40 <blaenk> :t fmap (+3) (+1)
15:57:41 <lambdabot> Num b => b -> b
15:57:46 <blaenk> same thing?
15:57:47 <adnap> enthropy: So, I guess I have to somehow pass this flag in the interpreter code
15:57:48 <johnw> yes
15:57:55 <blaenk> oh okay, thought you wrote it that way on purpose
15:58:06 <johnw> i did, but you can ignore that purpose if you like :)
15:58:17 <blaenk> well not if it's important haha
15:58:22 <johnw> i was just trying to show the direct translation from >>= to fmap in both cases
15:58:26 <blaenk> ohh okay
15:58:30 <blaenk> yeah that'll help then
15:58:32 <blaenk> to compare them
15:59:21 <johnw> the only reason I can do that, though, is that "Join" is sort of built-in where functions are concerned.  You _cannot_ translate every use of >>= into something involving just fmap
15:59:32 <johnw> just to be clear
15:59:44 <blaenk> ohh okay
15:59:58 <startling> (only the ones that look like f >>= return . g)
16:00:13 <johnw> exactly
16:00:32 <otters> but you can do it with fmap and join!
16:00:40 <johnw> yeah, if you have join, you're golden
16:00:44 <startling> blaenk: have you seen Maybe's instance?
16:00:46 <blaenk> book says (+) <$> (*2) <*> (+10) is equivalent to do a <- (*2); b <- (+10); return (a+b)
16:00:48 <blaenk> startling: for monad?
16:00:59 <startling> correct
16:01:02 <blaenk> yep
16:01:13 <josephle> well, isn't Hask a Klesli Category?
16:01:18 <enthropy> adnap: doesn't seem that it's possible to set it from inside ghc, since the following doesn't work:
16:01:20 <enthropy>  ghc -package ghc -e "import StaticFlags" -e "import Data.IORef" -e 'modifyIORef v_Ld_inputs ("f.o":)' External.hs -e 'print f'
16:01:30 <startling> do you see how >>= adds extra uncertainty, but fmap doesn't?
16:01:31 <johnw> josephle: monads in Hask form a Kleisli Category
16:01:43 <johnw> in the Kleisli category, all arrows have type a -> m b
16:01:52 <blaenk> startling: second, will revise both definitions
16:01:52 <josephle> johnw: oops, that's what I meant
16:02:39 <josephle> I can only imagine that some monads don't have join because it's a pain to implement
16:02:46 <josephle> provided they follow the monad laws
16:03:04 <shachaf> Every monad has join.
16:03:21 <adnap> enthropy: :(
16:03:21 <shachaf> It's almost universally less of a "pain to implement" than (>>=).
16:03:28 <johnw> i tend to write my monads by definining join and return, and then using equational reasoning to arrive at a definition for >>=.  Keeps me sane
16:03:41 <Peaker> johnw, return, join, fmap
16:03:51 <johnw> yes, yes
16:04:05 <enthropy> adnap: also it doesn't seem to accept "f.o" as an argument for Language.Haskell.Interpreter.Unsafe.unsafeRunInterpreterWithArgs
16:04:10 <blaenk> startling: in what way? I'm thinking because fmap >>= either does the operation or not (not if it's Nothing), but >>= does it if left side is Just, /and/ then it depends on the right side of >>= ?
16:04:17 <blaenk> *because fmap either does the
16:04:35 <startling> blaenk: x >>= f lets f fail, too
16:04:39 <quchen_> josephle: join m = m >>= id, always. To give an example of shachaf's claim that join is often easier to implement, take Reader as discussed here: `join f x = f x x`  vs  `m >>= f = \r -> f (m r) r`.
16:04:44 <blaenk> startling: oh yeah
16:04:48 <josephle> shachaf: maybe I got confused with fmap
16:04:48 <startling> blaenk: whereas fmap f x only fails if x already failed
16:04:57 <blaenk> startling: got it
16:05:07 <shachaf> Every monad has fmap, too.
16:05:23 <shachaf> (FSNO fmap.)
16:05:25 <startling> blaenk: do you see how this analogizes to (r ->)'s Monad instance? :)
16:05:29 <enthropy> adnap: might be worth asking elsewhere (email hint's maintainer?, ghc or haskell-cafe mailing list)
16:06:03 <adnap> enthropy: Okay
16:06:12 <adnap> enthropy: Thanks for helping
16:07:13 <josephle> shachaf: ok, I see how that's the case
16:07:31 <blaenk> startling: haha, in what way? tried drawing the connection but couldn't. you mean that the monad instance allows for failure too?
16:07:45 <startling> blaenk: nah, it has nothing to do with failure
16:09:11 <mm_freak> Shamar: no, you don't need to map strictly
16:09:16 <blaenk> startling: it's only applied if the previous part was fully applied? I don't even know how to word that
16:09:23 <mm_freak> Shamar: at some point you consume…  and that's where you need to be strict
16:09:26 <blaenk> (* 2) >>= \ a -> (+ 10) >>= \ b -> return (a + b)
16:10:01 <mm_freak> Shamar: usually only the final operation on a list is a strict operation
16:10:08 <mm_freak> strict in the elements that is
16:10:22 <quchen_> blaenk: I wrote something up that was once useful to me, it's how I got to understand Reader. Maybe have a look at it later for a different angle. (Reading it too early may confuse you while thinking about the other explanations given though, so be careful.) http://hpaste.org/88781
16:10:23 <Chousuke> blaenk: for the Reader monad, in h >>= f means f is a function that produces values of the reader monad. ie. functions. that means it takes two parameters, but the only parameter bind has access to is the parameter r of the monadic values
16:10:25 <blaenk> no problem if you guys lose patience with me haha, I'll figure it out
16:10:46 <blaenk> quchen_: thanks, can use any help I can get
16:10:57 <Chousuke> blaenk: so all bind can do is pass that parameter to the two-argument function to get a 1-argument function. :P
16:11:04 <josephle> Reader seems to be ideal when you're writing typecheckers :)
16:11:05 * mekeor cya
16:11:15 <blaenk> Chousuke: ohhh I think I get this
16:11:56 <blaenk> you guys keep mentioning the Reader monad, which seems to me very similar to the function monad, is there a reason for that? for explaining the reader monad? I only ask cause I figured I'd try to nail the function monad first, which I can't seem to manage
16:12:11 <quchen_> blaenk: Reader is what you call "Function monad".
16:12:40 <blaenk> is it really though? alright then, that's news to me and changes things haha
16:12:41 <quchen_> newtype Reader r a = Reader { runReader :: r -> a }
16:12:59 <quchen_> Strip the type wrappers away and you've got "Reader r a = r -> a"
16:13:12 <blaenk> ohh I see
16:13:21 <quchen_> Therefore, "Reader r = (->) r"
16:13:28 <quchen_> ... and that's the Monad.
16:14:52 <irene-knapp1> .
16:15:01 <blaenk> so trying to understand this I just realized I'm not familiar with the following, how does point-free form apply to monadic functions? say you have blah = asdf >>= abc123
16:15:21 <blaenk> the parameter passed to bhal is passed to asdf or abc123, eh I guess it depends on which monad it is?
16:15:38 <quchen_> blaenk: If you don't understand pointfree, add the points :-) blah = asdf >>= \x -> abc123 x
16:16:23 <quchen_> How "x" actually looks like, i.e. which value it gets, depends on the Monad, yes.
16:16:29 <blaenk> oh okay, didn't know where to 'add the points', that or blah = \x -> asdf >>= abc123, but I guess that doesn't make sense
16:16:43 <quchen_> Consider the pathological example of "blah = Nothing >>= \x -> f x", that'll never give x a value. :-)
16:16:51 <blaenk> if its a1 >>= a2 >>= a3, it'd be applied to a3? so always the last one?
16:17:23 <quchen_> a1 >>= \x -> (a2 x >>= \y -> (a3 y))
16:17:43 <blaenk> oh so aa1 >>= a2 >>= a3 would take two arguments?
16:18:00 <blaenk> or maybe that depends on the type of a2? if a2 is already a function taking one parameter?
16:18:05 <quchen_> That takes no arguments. All the lambdas are on the inside.
16:18:11 <blaenk> ohhh yeah
16:18:16 <Chousuke> I think things like that are easier to understand with actual real examples
16:18:22 <blaenk> yeah
16:18:28 <blaenk> let me link the code that prompted the question
16:18:37 <blaenk> http://stackoverflow.com/questions/14430397/about-the-function-monad
16:18:40 <quchen_> Anyway, gotta go to sleep now. See you around
16:18:46 <blaenk> thanks for the help quchen_
16:18:56 <blaenk> notice the first example has the parameter explicitly, but the asecond one addStuff' doesn't
16:19:37 <blaenk> oh I think the first one is incorrect
16:19:41 <blaenk> if I understand the answer correctly
16:20:14 <Chousuke> blaenk: like, say,  fmap (map toUpper) getLine >>= putStrLn >> putStrLn "Done"
16:20:24 <johnw> blaenk: using =<< instead of >>= for clarify, then with the function monad: f =<< g =<< x $ 3  ==  f (g ( x 3) 3) 3.  The "context" represented by this monad is the implicit argument being passed to each function being bound by =<<.
16:20:50 <johnw> it's like composition "plus"
16:20:58 <blaenk> johnw: aah okay, composition with an implicit argument?
16:21:01 <johnw> yes!
16:21:05 <johnw> you can think of it that way
16:21:16 <blaenk> ok ok I'll take this and run
16:21:16 <Chousuke> blaenk: if putStrLn actually returned a useful value, you could use >>= to print it instead of "Done" there
16:21:33 <johnw> it'll be tricky to read "do" notation with that intutition, but you can get there
16:21:46 <blaenk> yeah at least it gives me something to go off of now haha
16:22:34 <blaenk> Chousuke: ah okay
16:23:44 <kqr> in there:  f =<< g =<< x $ 3  ==  f (g ( x 3) 3) 3
16:23:56 <kqr> am i correct in thinking f/g and x have different arities?
16:23:59 <kqr> or am i confusing something
16:24:13 <johnw> you are right
16:24:21 <johnw> x is 1-ary, f and g are 2-ary
16:24:35 <kqr> oh i guess that makes sense yeah
16:24:44 <hpc> kqr: f :: c -> m b; g :: b -> m a; x :: m a
16:24:50 <kqr> yeah
16:25:04 <hpc> for m = blahblahblah
16:27:00 <Chousuke> I guess that asymmetry is why the operator is >>= while the symmetric operator is >=> :P
16:27:39 <blaenk> oh man >=> would probably confuse me even more, since I think that's like monadic composition or something?
16:27:49 <blaenk> monadic composition over a monad that composes functions
16:27:50 <blaenk> too much
16:28:08 <Chousuke> blaenk: two different kinds of composition (sort of)
16:28:11 <johnw> >=> is a kitten, you'll love it
16:28:13 <blaenk> oh okay
16:28:20 <johnw> > ((+) <=< (+) <=< (+) $ 3) 3
16:28:22 <lambdabot>   12
16:28:56 <johnw> anytime you have: f x >>= g, you can write f >=> g $ x
16:29:03 <blaenk> ohh okay
16:29:06 <blaenk> nice
16:29:13 <Chousuke> blaenk: with >=>, you have two things of the same kind producing a third thing of the same kind
16:29:17 <johnw> makes for some nice point-free monadic definitions
16:29:25 <blaenk> yeah
16:29:37 <Chousuke> blaenk: so it's just <> but for a -> m b :P
16:29:51 <blaenk> <> mappend for monoid?
16:30:00 <otters> @src (<>)
16:30:01 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:30:03 <johnw> Chousuke: or it's like <> for the 'm' part along with . for the a -> b part ;)
16:30:11 <Chousuke> I guess.
16:30:24 <johnw> which is, tada, what monads *are*
16:30:29 <Chousuke> though I bet in the end those are the same thing at some level, anyway
16:31:34 <Chousuke> it's like the proverbial turtles, except they must obey the monoid laws
16:32:13 <johnw> it's functorial turtles all the way down
16:33:32 <johnw> luckily for us, we can keep join'ing them
16:33:40 <johnw> giving us the One Turtle To Rule Them All
16:35:22 <Cale> The real analogy is between <> and join
16:35:37 <Cale> But it's maybe a little bit harder to see
16:35:38 <johnw> what did the monad turtle say to a bunch of functor turtles?  "can I join you?"
16:36:14 <johnw> Cale: yes, very good point.  saying <> and . in the same sentence is like mixing metaphors
16:49:21 <Aune> Which library should I use if I want to play around with blobs of binary data?
16:49:54 <acowley> Totally opaque blobs you get from FFI?
16:50:07 <acowley> Or do you want to interact with them on the Haskell side?
16:50:19 <Aune> The haskell side
16:50:24 <johnw> I think he means ByteString?
16:50:39 <acowley> Quite possibly!
16:50:42 <c_wraith> what are you going to *do* with it? ByteString alone is sufficient for storage and transmission
16:51:04 <c_wraith> If you want to parse binary fields out of it, you might look into libraries like binary or cereal
16:51:14 <Aune> I want to play around with encryption.
16:51:24 <c_wraith> then ByteString will suffice
16:51:47 <c_wraith> It's the data type for "a sequence of bytes, with no other implied structure"
16:53:19 <Aune> Ok, I have done a cursory read on bytestring. How would I for example xor two bytestrings?
16:53:44 <c_wraith> that one's slightly annoying, for reasons that are inexplicable to man
16:54:13 <c_wraith> But you'd do something like: B.pack $ B.zipWith xor input1 input2
16:54:35 <c_wraith> with imports like  import qualified Data.ByteString as B  and   import Data.Bits
16:54:59 <FreeFull> :t B.zipWith
16:55:00 <lambdabot> Couldn't find qualified module.
16:55:10 <c_wraith> :t Data.ByteString.zipWith
16:55:12 <lambdabot> (Word8 -> Word8 -> a) -> BSC.ByteString -> BSC.ByteString -> [a]
16:55:28 <eikke> don't be mistaken by zipWith yielding [Word8] when applied with xor
16:55:39 <FreeFull> xor is from Data.Bits
16:55:49 <Aune> That seems reasonable, didnt know about Data.Bits.
16:55:59 <eikke> there's a rule which rewrites zipWith yielding [Word8] combined with BS.pack into a more efficient version which doesnt create an intermediate list
16:56:04 <eikke> (I was bitten by that once)
16:57:14 <eikke> (although I do believe that's slightly too much magic, and having a zipWithBS :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString -> ByteString would be preferable
16:57:54 <FreeFull> ( I wonder why it's not that in the first place )
16:58:46 <eikke> caus you might e.g. want to use (\a b -> (fromIntegral a + fromIntegral b) :: Int) ?
16:59:11 <eikke> or use (==)
16:59:28 <Shamar> good night everybody... and thanks for the help... solved moving to a line based format
16:59:34 <Shamar> see you soon!
17:00:40 <Aune> Im really a bit confused about how to work with different encodings though.
17:01:04 <Aune> But I will have to work on finding what Im confused about.
17:01:14 <eikke> Aune: it doesn't, bytestring is about bytes
17:01:25 <merijn> Aune: Have you read the Spolsky unicode article?
17:02:01 <merijn> http://www.joelonsoftware.com/articles/Unicode.html
17:02:12 <eikke> Aune: if you think about encodings, you most likely want the 'text' package instead of bytestring
17:02:14 <Aune> merijn, yes I have
17:02:19 <merijn> Ah, ok :)
17:02:26 <c_wraith> note that spolsky's article is *wrong* in some cases.
17:02:35 <merijn> c_wraith: Oh? Such as?
17:02:36 <c_wraith> The unicode consortium changed a few things shortly after it was published
17:02:41 <c_wraith> and he never updated the article
17:03:06 <c_wraith> there are no 6-byte utf-8 sequences anymore, for instance
17:03:19 <c_wraith> They were removed shortly after that article was written
17:03:32 <merijn> That's unlikely to matter to anyone using library functions for encoding/decoding in Haskell, though
17:03:35 <Aune> but I have encodings and encryption with for example simple bitwise xor cryptos. To work with those I will still need to work on the binary layer
17:03:50 <merijn> bitwise xor != encryption
17:04:09 <merijn> bitwise xor == obfuscation
17:04:20 <Aune> true, but in the exercises I am doing it is the first steps.
17:04:51 <merijn> Aune: ByteString is the binary layer, it's just strings of bytes (similar to char arrays in C)
17:04:53 <c_wraith> xor is sufficient if the key size is >= the message size, and the key is never re-used
17:05:30 <merijn> c_wraith: I don't expect people that call xor encryption to properly use one time pads...
17:10:21 <Aune> I get binary data, "encrypted" by xoring with a cyclic bit-pattern. I want to crack that. I could start with a decent crypto like AES, but that exercise would be a bit to hard.
17:11:35 <Aune> But seems like ByteString is by consensus the recommended library.
17:12:16 <c_wraith> AES used by someone who doesn't know what they're doing isn't that hard to break. for instance, CBC completely falls apart if you have a padding oracle.
17:12:38 <merijn> Data.Bits has a xor function, which works on all numeric types. You can probably get "ByteString -> [Word8]" and "[Word8] -> ByteString" and then use "zipWith xor" to xor the data and the cyclic bit-pattern
17:12:43 <c_wraith> (this is something I've actually implemented. It's amazing to see how easily it fails)
17:13:03 <merijn> My new response to using crypto is: use NaCl
17:13:38 <merijn> There's haskell bindings already, so!
17:18:23 <cmears> merijn, you mean these bindings?  http://thoughtpolice.github.io/salt/
17:21:20 <merijn> Yeah, haven't tried them yet, though!
17:21:39 <cmears> merijn, it's odd that the documentation says "just cabal install", but the package isn't on hackage
17:22:26 <merijn> cmears: Cloning the repo and running "cabal install" in that dir will install it
17:22:48 <merijn> The default for cabal is to fetch it from hackage, but all you need is a .cabal file
17:23:01 <merijn> You'd have to ask thoughtpolice why it's not on hackage
17:24:27 <c_wraith> merijn: I think because it depends on a system installation of nacl, which makes installing it a bit annoying.
17:24:48 <cmears> yeah, especially when their instructions are "cabal update && cabal install salt"
17:25:04 <c_wraith> merijn: he's documented plans to add a local copy of the native code to the repo, which should make installing it way easier
17:25:18 <merijn> In the past salt shipped with it's own copy of the nacl source, which I wasn't to convinced about
17:25:19 * dcoutts_ notes that it's also possible to cabal install http://example.com/foo-1.0.tar.gz
17:25:53 <merijn> c_wraith: I argued against that, actually. And anyway, zeromq bindings also depend on local copy of the ZMQ, but they install just fine
17:25:54 <c_wraith> Hmm.  does that need to be a tarfile structured like one cabal sdist would create?
17:26:07 <merijn> Anyway, bed time for me
17:26:11 <merijn> (long past, even)
17:26:35 <dcoutts_> c_wraith: if that Q was directed at me, the answer is yes.
17:26:50 <c_wraith> dcoutts_: yeah it was. sorry I wasn't as clear as I should have been.
17:29:08 <dcoutts_> c_wraith: so yes, same src tarball format everywhere, on hackage or hosted in isolation
17:31:19 <Aune> I have a bit of trouble with building my ByteStrings. If I have a String "128a7b", how would I build a ByteString with the corresponding bit-pattern?
17:31:48 <Aune> The string above being a hex-representation of a bit-pattern
17:33:13 <cmears> Aune, perhaps make a list of Word8 and then use "pack"?
17:33:34 <c_wraith> Aune: something like http://hpaste.org/88783
17:33:48 <c_wraith> that will require importing Data.Char, too
17:33:55 * hackagebot Nomyx-Language 0.2.0 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.2.0 (CorentinDupont)
17:33:57 * hackagebot Nomyx 0.2.0 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-0.2.0 (CorentinDupont)
17:34:14 <Aune> c_wraith, that was a nice solution.
17:34:43 <c_wraith> I happened to have that lying around already, from doing the coursera crypto course programming stuff in haskell.
17:38:39 <Aune> neat
17:39:37 <JoeyA> Has anyone else but me wanted this function?  transpose :: (Ord k1, Ord k2) => Map k1 (Map k2 v) -> Map k2 (Map k1 v)
17:41:10 <c_wraith> @hoogle m1 (m2 x) -> m2 (m1 x)
17:41:10 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
17:41:10 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
17:41:10 <lambdabot> Test.QuickCheck.Gen promote :: Monad m => m (Gen a) -> Gen (m a)
17:41:30 <Peaker> JoeyA, Map k has a Traversable instance
17:41:38 <c_wraith> so, there you go.  it's sequenceA
17:41:41 <JoeyA> > Map.fromList [(1, 'a'), (2, 'b')]
17:41:42 <lambdabot>   Not in scope: `Map.fromList'
17:41:42 <lambdabot>  Perhaps you meant one of these:
17:41:42 <lambdabot>    `M.fromLis...
17:41:46 <JoeyA> > M.fromList [(1, 'a'), (2, 'b')]
17:41:48 <lambdabot>   fromList [(1,'a'),(2,'b')]
17:42:33 <JoeyA> Thanks.  I'll try it out.
17:42:53 <Peaker> > sequenceA (M.fromList [(1, M.fromList [('x', 1), ('y', 2)]), (2, M.fromList [('z', 3)])])
17:42:55 <lambdabot>   Not in scope: `sequenceA'
17:42:55 <lambdabot>  Perhaps you meant one of these:
17:42:55 <lambdabot>    `Data.Travers...
17:43:05 <Peaker> > Data.Traversable.sequenceA (M.fromList [(1, M.fromList [('x', 1), ('y', 2)]), (2, M.fromList [('z', 3)])])
17:43:07 <lambdabot>   No instance for (Control.Applicative.Applicative
17:43:07 <lambdabot>                     (Data....
17:43:15 <c_wraith> Well that's silly
17:43:33 <Peaker> yeah, that won't work, it ain't applicative :)
17:43:47 <c_wraith> Functor, but nothing stronger
17:44:14 <FreeFull> Just what would transpose do here
17:45:26 <JoeyA> @let testMap = let fm = M.fromList in fm [(1, fm [('a',"1a"), ('b', "1b")]), (2, fm [('a', "2a")])]
17:45:29 <lambdabot>  Defined.
17:45:33 <JoeyA> > testMap
17:45:35 <lambdabot>   fromList [(1,fromList [('a',"1a"),('b',"1b")]),(2,fromList [('a',"2a")])]
17:46:13 <JoeyA> @let testMapTExpected = let fm = M.fromList in fm [('a',fm [(1,"1a"),(2,"2a")]),('b',fm [(1,"1b")])]
17:46:15 <lambdabot>  Defined.
17:46:22 <JoeyA> > sequenceA testMap
17:46:24 <lambdabot>   Not in scope: `sequenceA'
17:46:24 <lambdabot>  Perhaps you meant one of these:
17:46:24 <lambdabot>    `Data.Travers...
17:46:33 <Peaker> sequenceA won't work, it needs an Applicative instance
17:46:45 <JoeyA> Could not deduce (Applicative (Map Char))
17:46:52 <JoeyA> Right, just seeing for myself.
17:47:15 <JoeyA> So my question stand: has anyone else but me wanted transpose for Map?
17:47:19 <JoeyA> stands*
17:47:29 <FreeFull> Does Map not fulfill one of the applicative laws?
17:47:46 <Peaker> it has no instance, so it doesn't fulfill any of them :)
17:48:01 <zRecursive> @instances Applicative
17:48:01 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
17:48:13 <JoeyA> :t ap
17:48:15 <lambdabot> Monad m => m (a -> b) -> m a -> m b
17:48:34 <FreeFull> :t (<*>)
17:48:36 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:48:42 <zRecursive> @instances Control.Applicative
17:48:43 <lambdabot> Couldn't find class `Control.Applicative'. Try @instances-importing
17:48:46 <JoeyA> Map k (a -> b) -> Map k a -> Map k b
17:48:54 <johnw> I would think that an Applicative instance for Map would be zippery, and only apply to matching keys
17:48:58 <c_wraith> You could write such an instance, but you'd probably need a monoid constraint on the values
17:49:10 <c_wraith> actually, you'd need a monoid or something on the keys, too
17:49:13 <c_wraith> to make pure work
17:49:26 <JoeyA> k, I'm done with Haskell.
17:49:32 <JoeyA> 3 years of this is enough
17:49:33 <JoeyA> jk jk
17:52:42 <JoeyA> Another cool function to have would be curry :: Map a (Map b c) -> Map (a, b) c
17:53:09 <JoeyA> In keeping with the function analogy, 'flip' might be a better name than 'transpose'.
17:54:18 <copumpkin> JoeyA: call it uncurryMap :P
17:54:33 <copumpkin> it seems a little misleading to call it curry
17:54:33 <JoeyA> Err, meant uncurry
17:54:35 <copumpkin> :)
17:54:38 <JoeyA> My bad
17:54:53 <JoeyA> Why not just 'uncurry', in a module with other colliding names?
17:55:00 <copumpkin> fair enough :)
17:55:00 <johnw> JoeyA: so, in this definition: https://gist.github.com/5667261, the code under 'otherwise' is teh problematical part
17:55:03 <JoeyA> Unless, of course, it were added directly to Data.Map
17:55:21 <johnw> if the two maps match up key for key, then it works; but if the keys don't match up...
17:55:33 <copumpkin> JoeyA: I've used transpose on Map before, but you need Map k (Set v) -> Map v (Set k)
17:55:34 <copumpkin> or something
17:55:40 <copumpkin> to be general
17:55:43 <JoeyA> johnw: Just do intersection, then?
17:56:08 <JoeyA> copumpkin: why would that be general?
17:56:28 <copumpkin> JoeyA: what's the transpose of x -> 1, y -> 1?
17:56:32 <JoeyA> Map k1 (Map k2 ()) is isomorphic to Map k1 (Set k2), right?
17:56:41 <copumpkin> oh, sure
17:56:47 <copumpkin> didn't see your original signature
17:57:16 <JoeyA> If you're wondering, transpose . transpose /= id
17:57:23 <JoeyA> it drops empty submaps
17:57:33 <copumpkin> yeah, I've written it before
17:57:37 <copumpkin> unacceptable!
17:57:50 <JoeyA> Not if it's documented!
17:57:56 <copumpkin> write a NonEmptyMap type
17:57:57 <copumpkin> :P
17:58:02 <Peaker> copumpkin, I think you're talking about Map k v -> Map v k?
17:58:03 <shachaf> Empty submaps sound illegal.
17:58:23 <Peaker> copumpkin, and JoeyA talking about more of a "sequenceA" thing for (Map k0) and (Map k1)
17:58:28 <JoeyA> copumpkin: That would open a can of semigroups.
17:58:37 <Peaker> Map k0 (Map k1 a) -> Map k1 (Map k0 a)
17:58:49 <copumpkin> Peaker: same thing, really
17:58:55 <copumpkin> I didn't know what signature he wanted
17:58:59 <copumpkin> so I gave the most obvious thing
17:59:10 <JoeyA> const Map.empty
17:59:17 <copumpkin> :)
17:59:53 <JoeyA> It'd be kind of nice if type Set k = Map k ()
18:00:00 * JoeyA dodges a volley of tomatoes
18:00:42 <hpc> JoeyA: that kind of proposal earns you a chinese ballista squadron of pineapple :D
18:00:53 <JoeyA> Do I get to eat the mess?
18:01:00 <enthropy> that'll let you fmap your Set
18:01:02 <hpc> possibly
18:01:18 <hpc> ooh, it does
18:01:27 <hpc> and it lets you map over the keys, as well
18:01:37 <hpc> letting you quickly "escape" from Set to Map
18:02:02 <ion> http://hpaste.org/50278
18:02:18 <JoeyA> If course, then Set couldn't be a monad.
18:02:36 <hpc> Flip Set () can be though
18:03:59 <ion> (Functor, Applicative and Monad instances for Data.Set)
18:04:36 <hpc> obviously, it has to be a constrained monad, which takes a separate class definition
18:05:11 <shachaf> ion: You can make an actual Functor instance for something equivalent to Data.Set using a Yoneda-like type.
18:06:38 <shachaf> data CoYoSet a = forall x. Ord x => CoYoSet (x -> a) (S.Set x)
18:07:06 <shachaf> But if you fmap a non-injective function over a CoYoSet it won't shrink (until you lower it back to a Set).
18:08:40 <ion> :-)
18:09:05 <shachaf> :☹)
18:09:29 <JoeyA> But CoYoSet (x -> a) is isomorphic to YoYoMa
18:11:41 <davesq> hi all, has anyone else had any problems cabal installing test-framework-quickcheck2 on haskell platform 2013.2?
18:38:14 <mjrosenb> let's say I have an infinite ordered list of Integers.  Is there a pre-existing datastructure/function pair that will let me do elem checks?
18:40:09 <blaenk> johnw: you around
18:40:35 <blaenk> > f =<< g =<< x $ 3
18:40:36 <tromp> :t \x -> (elem x) . dropWhile (<x)
18:40:37 <lambdabot>   Couldn't match expected type `m0 a0'
18:40:37 <lambdabot>              with actual type `Debug.S...
18:40:38 <lambdabot> Ord a => a -> [a] -> Bool
18:40:57 <blaenk> > f =<< g =<< return x $ 3
18:40:58 <lambdabot>   Ambiguous type variable `a0' in the constraints:
18:40:58 <lambdabot>    (GHC.Show.Show a0)
18:40:59 <lambdabot>     ...
18:41:06 <blaenk> nevermind
18:41:27 <tromp> :t \x -> (==x) . head . dropWhile (<x)
18:41:28 <lambdabot> Ord b => b -> [b] -> Bool
18:41:54 <mjrosenb> *in sub-linear time
18:42:14 <mjrosenb> I know it will always be at least linear to build up the first portion of any datastructure
18:42:43 <mjrosenb> but if I look up 999, then 998 and 997, I don't want to do a linear walk for all three numbers
18:43:02 <shachaf> Hmm.
18:43:27 <tromp> Data.Set.fromAscList requires a finite input list
18:43:37 <shachaf> tromp: Set is always finite. It's spine-strict.
18:44:09 <mjrosenb> if not, I'll build up an infinite list of sets, with 2^n elements in each set.
18:44:10 <shachaf> Well, I suppose it's strict in general.
18:44:35 <mjrosenb> err, 2^n elements in the nth set.
18:45:12 <tromp> sounds like a good plan
18:46:13 <blaenk> is it necessary to write a $ before a do block, so someFunc = otherFunc $ do, then the rest of the do block on the next lines
18:46:18 <shachaf> mjrosenb: Well, you can keep one set and add to it from the list as more elements are required, or something like that.
18:46:19 <tromp> except when generating e.g. elements 3*2^n..4*2^n-1 takes WAY longer than elements 2*2^n..3*2^n-1
18:46:19 <blaenk> or can it just be otherfunc do\netcetc
18:46:46 <blaenk> guess I'll try it myself in a second
18:46:46 <tromp> and you want to finish your elem in the latter range
18:47:33 <shachaf> mjrosenb: I mean data Foo a = Foo (Set a) (Stream a), and then when you ask for membership of an element > the maximum in the Set, you take that many elements from the Stream and add them to the Set.
18:48:59 <shachaf> (But of course you need to return a new Foo on membership tests that way.)
18:49:14 <mjrosenb> shachaf: yeah, that sounds awkward.
18:50:56 <shachaf> I think your list of sets is probably more reasonable since you can just rely on laziness.
19:05:52 <gaze__> http://stackoverflow.com/questions/16804190/cpu-emulation-in-haskell-functional-data-structures-and-maybe-zippers hey! Would someone mind having a look at my stackoverflow question? It's about zippers, data structures, stuff
19:14:05 <gwern> SoC for 2013: '* Parallelise 'cabal build' by Mikhail Glushenkov, mentored by Johan Tibell'. SoC for 2011: 'Mikhail Glushenkov: Build multiple Cabal packages in parallel' http://blog.johantibell.com/2011/04/this-years-haskellorg-gsoc-projects.html I N C E P T I O N
19:14:11 <gwern> we need to go deeper
19:14:55 <tgeeky> ah, there you go. I thought it looked repetitive, but I only looked at 2012
19:14:55 <gwern> SoC for 2014: Parallelise Glushenkov, by Mikhail Tibell, mentored by the Johan Cabal
19:15:57 <shachaf> gwern: There's #haskell-gsoc, by the way.
19:15:59 <luite> yeah they'll ahve some overlap in the immediate goals, but even then they'll be quite impactful
19:16:24 <shachaf> luite: gwern isn't comparing parcs's and refold's projects, he's comparing refold's project with the one from 2011.
19:16:44 <gwern> shachaf: I was getting around to registering my predictions for this year, and was struck by a feeling of deja vu
19:17:08 <luite> oh
19:17:19 <adnap> Why does "forever" have the type "Monad m => m a -> m b"? Where does "b" come from?
19:17:33 <shachaf> Nowhere. You never get b.
19:17:35 <gwern> bottom?
19:17:47 <adnap> Okay
19:18:01 <adnap> So, is it just to emphasize that forever never returns?
19:18:20 <tgeeky> doesn't it "actually" come from some place in GHC which has a list of characters to give out?
19:18:46 <startling> :t let f a = f a in f
19:18:47 <lambdabot> t -> t1
19:18:48 <tgeeky> ie, b is just the next one on the list after a
19:19:13 <shachaf> No, the next one on the list after a is a1.
19:19:14 <luite> tgeeky: i don't it gives out bs, only ts
19:19:22 <luite> unless you give it something first
19:20:03 <jmcarthur> adnap: it's not so much to emphasize it as it just is. since it never returns, it can be anything, so that's what the type says
19:20:04 <gwern> https://www.google-melange.com/gsoc/org/google/gsoc2013/haskell enhancing darcsden? I thought that site was shut down
19:24:21 <wavewave> adnap : bottom is the only value which type (all a) can have.
19:25:09 <saml> how can I get unicode name of a character?
19:25:22 <saml> for example,  '('  ==> "LEFT PARENTHESIS"
19:25:51 <gwern> ffs. google-melange.com is still making it hard to see the whole writeup for an SoC? >.,
19:26:22 <mjrosenb> so, I just tried out this primes function: http://www.haskell.org/haskellwiki/Prime_numbers#Tree_merging
19:26:52 <mjrosenb> the list it generates seems to contain 996341
19:28:03 <saml> @hoogle Char -> String
19:28:03 <lambdabot> Network.URI escapeURIChar :: (Char -> Bool) -> Char -> String
19:28:03 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
19:28:03 <lambdabot> Text.Html prettyHtml :: HTML html => html -> String
19:28:05 <shachaf> mjrosenb: That's not a very good primes list.
19:28:29 <mjrosenb> shachaf: indeed!
19:29:19 <cmears> when I run it I even get 25
19:29:24 <adnap> Is it possible to interpret the result of a function in the same file as the interpreter code?
19:29:55 <shachaf> mjrosenb: It also contains 25.
19:30:02 <mjrosenb> cmears: I am not very good at checking small input, evidently.
19:30:34 <gwern> adnap: you mean like template haskell?
19:30:40 <adnap> gwern:
19:30:44 <adnap> gwern: I don't know
19:30:47 <cmears> I cheated and used isPrime from Math.NumberTheory.Primes to check
19:30:54 <adnap> I've never used Template Haskell
19:31:05 <adnap> I'll paste an example of what I mean
19:31:08 <enthropy> gwern: I think with hint
19:31:16 <adnap> Yes, with hint
19:31:25 <enthropy> adnap: you can get the result out of a call to runInterpreter
19:31:51 <adnap> but can you call "interpret "f"", where "f" is defined in the same file?
19:32:03 <enthropy>  Right variableThat'sProbably2 <- runInterpreter (interpret "1+1")
19:32:09 <mjrosenb> the examples given on the wiki should probably be correct
19:32:36 <zRecursive> > runInterpreter (interpret "1+1")
19:32:37 <lambdabot>   Not in scope: `runInterpreter'Not in scope: `interpret'
19:32:39 <mjrosenb> :t pairs
19:32:40 <lambdabot> Not in scope: `pairs'
19:32:46 <saml> > charFullName '('
19:32:48 <lambdabot>   Not in scope: `charFullName'
19:33:01 <saml> @import Data.Text.ICU.Text
19:33:01 <lambdabot> Unknown command, try @list
19:33:13 <adnap> Currently, I am having to isolate my interpreter code from every function mentioned in the interpert String
19:33:13 <mjrosenb> the next implementation has an undefined variable, 'pairs' :(
19:33:48 <shachaf> mjrosenb: The ONeill code in NumberSieves doesn't contain 25, by the way.
19:33:50 <enthropy> adnap: bad things happen if you load module A from module A?
19:34:35 <enthropy> it's not a very big deal to keep things in separate files though
19:35:09 <enthropy> maybe somebody smarter won't be confused by that situation that isn't really a loop
19:36:20 <adnap> Like this: http://hpaste.org/88793
19:37:10 <gwern> '  The objective of this project is to improve the darcs record command implementing several options. '  https://www.google-melange.com/gsoc/project/google/gsoc2013/jlneder/16001 oh, of course. that explains everything.
19:37:13 <enthropy> you'd have to add Main to the imports
19:37:23 <gwern> (also goddamn google-melange.com for putting freaking whitespace everywhere)
19:37:27 <mjrosenb> shachaf: did it give you the warning:     Ignoring unusable UNPACK pragma on the first argument of `Br'
19:37:28 <adnap> enthropy: Well, it means that my interpreter function can't take any arguments that affect what it is interpeting
19:37:36 <enthropy> gwern: nevermind that darcs record already has tons of options
19:37:47 <Guest78746> anybody from Rus?
19:37:59 <gwern> enthropy: apparently it needs moar. record all the things!
19:38:09 <adnap> enthropy: Everything has to be defined statically in another module
19:38:24 <gwern> thank god there's a sane proposal - not that google-melange.com, that shitty cms, links to it in the abstract - at http://darcs.net/GSoC/2013-BetterRecord
19:38:37 <shachaf> mjrosenb: Yep.
19:38:52 <shachaf> mjrosenb: (I'm not saying it's good or bad. I've never used it before. I'm just saying it didn't give me 25.)
19:39:22 <shachaf> mjrosenb: (That UNPACK pragma is indeed unusable.)
19:39:32 <adnap> Hm...
19:41:21 <adnap> Well doing "loadModule "Main"" and adding "Main" to "setImports" doesn't work
19:41:44 <adnap> Oh wait
19:41:48 <adnap> I messed up
19:42:48 <adnap> Okay, yeah, it doesn't work
19:43:06 <adnap> It compiles, but it still says "x" is not in scope
19:45:23 <enthropy> adnap: interesting. I get this message: NotAllowed "module is not loaded: `Main' (./Main.hs)"
19:45:39 <mjrosenb> shachaf: it seems to work.
19:46:41 <zRecursive> adnap: myabe XMonad.Actions.Eval gives clue ?
19:48:26 <enthropy> it doesn't seem like XMonad.Actions.Eval does that kind of thing with hint
19:49:32 <zRecursive> enthropy: i ever tried XMonad.Actions.Eval, but got nothing after evaluating some expr
19:49:55 <zRecursive> ehamberg: XMonad.Actions.Eval seems use hint
19:51:09 <enthropy> right it uses hint, but it doesn't suggest that you can refer to definitions in your xmonad.hs (Main) in the String that gets passed to hint
19:52:18 <gaze__> http://stackoverflow.com/questions/16804190/cpu-emulation-in-haskell-functional-data-structures-and-maybe-zippers Anyone mind chatting this through with me?
19:54:44 <adnap> What is going on here? http://hpaste.org/88794
19:56:54 <BMeph> adnap: My guess? You're doing it wrong! ;þ
19:57:06 <adnap> BMeph: Gee, thanks :P
19:57:48 <enthropy> preflex: zdec __stginit_ghczm7zi4zi2_DsMeta
19:57:49 <preflex>  __stginit_ghc-7.4.2_DsMeta
19:59:24 <ski> hm, there was some blog post(?) which talked about how compilers for imperative languages typically don't provide much checking at all for ensuring that you're doing your state changes in the right order, and how immutability by making versions more explicit can catch such errors
20:00:00 <ski> i can't seem to find it now, any idea about where this may have been ?
20:00:19 <tabemann> I've found even in coding in OCaml, which I would regard as an imperative language, its support for things being immutable-by-default helps a lot nonetheless
20:01:19 * ski would regard OCaml as a(n impure) functional programming language, with some support for imperative programming
20:01:44 <ski> (and potentially the same for Scheme, depending on how it is used)
20:01:53 <shachaf> And Haskell?
20:01:59 <tabemann> Scheme is the same way
20:02:05 <shachaf> (Minus the parentheses.)
20:02:14 <tabemann> except it has some things that are mutable that aren't mutable in OCaml, e.g. pairs
20:02:26 <ski> well, Scheme has `set!', and mutable lists (well, Racket removed mutable lists as default)
20:02:27 <shachaf> Well, imperative statements are first-class in Haskell, unlike in most languages.
20:03:20 <tabemann> imperativeness is marked on the type in Haskell
20:03:26 <ski> shachaf : well, i consider side-effects one of the main points of imperative programming
20:03:28 <tabemann> so to speak
20:03:51 <ski> (or, at least, of the traditional conception of it)
20:04:03 * hackagebot hsbencher 1.0 - Flexible benchmark runner for Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.0 (RyanNewton)
20:09:03 * hackagebot monad-par 0.3.4.2 - A library for parallel programming based on a monad  http://hackage.haskell.org/package/monad-par-0.3.4.2 (RyanNewton)
20:13:36 <adnap> It is annoying when a new version of a package on Hackage doesn't have documentation, and you have to go back to an old version
20:18:30 <tgeeky> adnap: because the new one hasn't built docs yet? or because the new one isn't building at all?
20:37:30 <johnw> adnap: you don't build the docs locally?
20:54:04 * hackagebot yesod-pure 0.1.0.1 - Yesod in pure Haskell: no Template Haskell or QuasiQuotes  http://hackage.haskell.org/package/yesod-pure-0.1.0.1 (MichaelSnoyman)
21:04:04 * hackagebot hstatistics 0.2.5.1 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.5.1 (VivianMcPhail)
21:04:06 * hackagebot hsbencher 1.1 - Flexible benchmark runner for Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.1 (RyanNewton)
21:28:54 <pqmodn> my understanding was _|_ was a type (e.g., the absurd proposition) but i occasionally see people refer to things like `let x = x in x` as a _|_ value. is this just loose terminology, since it doesn't ever evaluate to a "value"?
21:29:36 <shachaf> These are two mostly-unrelated uses of ⊥.
21:29:59 <pqmodn> ok, so it's not the case that 'let x = x in x` is an inhabitant of _|_
21:30:01 <shachaf> They're both the bottom of some lattice, but not the same one. :-)
21:30:23 <shachaf> Well, it *is* an inhabitant of the empty type Void, since it's an inhabitant of everything.
21:30:43 <pqmodn> oh, you're right
21:30:46 <shachaf> In Haskell people usually mean the value. I don't use ⊥ to refer to the empty type.
21:31:06 <shachaf> It's called "bottom" because it's the "least-defined" value.
21:31:42 <monochrom> I used ⊡ in my thesis, because ⊥ already refers to a boolean value
21:31:54 <pqmodn> are lattices treated as a topic of their own in mathematics, or which branch addresses them?
21:32:57 <monochrom> but imagine a square cardboard with a needle or pen erected. from one angle, you see ⊥. from another angle, you see ⊡ :)
21:33:11 <otters> if I want to replace a node in a Text.Blaze.Html with another node, how do you guys recommend I do that?
21:33:12 <sipa> haha
21:36:37 <bos> @pl go m (k,v) = snd $ insertWith (++) k v m
21:36:37 <lambdabot> go = (`ap` snd) . (. fst) . ((snd .) .) . flip (flip . insertWith (++))
21:36:42 <bos> ooookay
21:37:29 <shachaf> @pl go (k,v) m = snd $ insertWith (++) k v m
21:37:29 <lambdabot> go = uncurry (((snd .) .) . insertWith (++))
21:37:47 <shachaf> There you go! flip (uncurry (snd .:: insertWith (++)))
21:37:59 <shachaf> (I do not recommend the above.)
21:38:04 <bos> :)
21:39:05 * hackagebot chell-quickcheck 0.2.2 - QuickCheck support for the Chell testing library  http://hackage.haskell.org/package/chell-quickcheck-0.2.2 (JohnMillikin)
21:39:12 <tabemann> what is @pl - a bot feature to turn code into point-free style?
21:39:17 <shachaf> Yes.
21:39:34 <tikhonjelvis> it stands for "pointless"
21:39:40 <tikhonjelvis> although it could also mean "perl"
21:39:47 <tabemann> my thought was perl
21:40:27 <tikhonjelvis> golfed perl has quite a bit more magic than pointless Haskell code
21:40:31 <otters> it doesn't look like there's any good way to do this
21:40:35 <otters> I guess I could pattern match on HtmlM
21:40:41 <otters> but that's gross
21:40:48 <copumpkin> shachaf: time for pi
21:40:53 <tabemann> one thing I wonder about (new to Haskell, being an OCaml coder) is what does one get from making any but the most trivial code point-free?
21:41:13 <copumpkin> ( ͡° ͜ʖ ͡°)﻿
21:41:17 <shachaf> Readability.
21:41:21 <tabemann> I often find myself having a much harder time understanding point-free code than point-ful code
21:41:30 <tikhonjelvis> you usually only make trivial code point-free
21:41:37 <Gracenotes> copumpkin: hey don't look at me like that
21:41:37 <shachaf> You make code point-free when it, or your understanding of it, is improved by it.
21:41:40 <tikhonjelvis> but it turns out that trivial code comes up *a lot* when using higher-order functions and the like
21:41:48 <copumpkin> > let w(p,q)i=(p*i+1,q*i);d%(p,q)=p*d`div`q;(x:y:s)^d|d%y>d%x=s^d|0<1=mod(d%x)10:s^(10*d)in 2:scanl w(1,1)[1..]^10>>=show
21:41:49 <lambdabot>   "27182818284590452353602874713526624977572470936999595749669676277240766303...
21:41:52 <shachaf> @where pi
21:41:53 <lambdabot> I know nothing about pi.
21:41:54 <shachaf> @where pi_10
21:41:54 <lambdabot> (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
21:41:58 <shachaf> > (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
21:41:59 <tikhonjelvis> e.g. code like map (foo . bar)
21:42:00 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
21:42:02 <copumpkin> shanse: oh that one's pretty good
21:42:10 <copumpkin> shachaf
21:42:16 <tikhonjelvis> I think we can all agree that (foo . bar) is more readable than (\ x -> foo (bar x))
21:42:33 <tabemann> tikhonjelvis: well I find myself doing things like that in my own code, where they are all little, trivial cases
21:42:38 <copumpkin> I had the older one you were working on
21:42:39 <tikhonjelvis> I can look around some recent code for better examples :P
21:42:39 <copumpkin> > '3':fix(\s n->let a%i=10^(3*n)`div`(a^i*i)in(take n.drop n.show.sum$takeWhile(/=0)[4*(-1)^div i 2*(2%i+3%i)|i<-[1,3..]])++s(2*n))1
21:42:41 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
21:42:43 <otters> shachaf: that's really pretty
21:42:43 <tgeeky> tikhonjelvis: I just read both of them just fine.
21:42:49 <Gracenotes> shachaf: interestingly, that'll get slower digit by digit
21:42:51 * shachaf 's favowrite thing is when simple algebraic manipulation of code (/mathß) yields new insights about it.
21:43:02 <tikhonjelvis> I have Emacs set up to render it as (foo ∘ bar)
21:43:06 <shachaf> Gracenotes: I think every computation of pi will.
21:43:15 <Gracenotes> yes, certainly
21:43:17 <shachaf> Though sometimes it's logarithmic. :-)
21:43:18 <tikhonjelvis> which I find to be much easier to read at a glance than the . version or the lambda version
21:43:31 <copumpkin> ᶘ ᵒᴥᵒᶅ
21:43:36 <Gracenotes> yeah, the spigot ones from the shootout grow very nicely.
21:43:48 <shachaf> copumpkin: did you read the thing
21:43:50 <Gracenotes> they require arbitrary-size integers.
21:43:50 <tikhonjelvis> but yeah, @pl is mostly for fun: if you actually have to use it, you shouldn't be making that code point-free at all!
21:44:00 <copumpkin> shachaf: not yet, but I have renewed impetus now
21:44:10 <carter> copumpkin hello
21:44:12 <carter> !
21:44:14 <copumpkin> hi carter
21:45:10 <tikhonjelvis> I don't use the point-free style *that* much in my Haskell code, but I've found I miss it quite a bit when I do OCaml
21:45:23 <copumpkin> Shaladdle
21:45:26 <copumpkin> shachaf: must sleep
21:45:31 <copumpkin> dammit why do you share prefixes with people
21:45:35 <Gracenotes> I found I miss, say, being able to easily enumerate list items with their indices in OCaml
21:45:38 <copumpkin> we need some sort of no-common-prefix coding in here
21:45:50 <shachaf> copumpkin: I agree. We should kick shapr -- I was here first.
21:45:53 <Gracenotes> or having a dictionary/map object that doesn't require imperative updates
21:46:03 <copumpkin> shapr isn't here
21:46:10 <shachaf> True. :-(
21:46:18 <shachaf> @get-shapr
21:46:18 <lambdabot> shapr!!
21:46:44 <tabemann> in Haskell, from all the warnings about *space leaks*, I am tempted to pepper my code with bangs (and enable BangPatterns)
21:46:45 <monochrom> we need 1000 letters. that will avoid common prefixes for a little while.
21:46:50 <shachaf> What's copton_'s excuse, eh?
21:46:54 <carter> tikhonjelvis thats reasonable
21:46:57 <carter> oops
21:47:00 <carter> tabemann thats reasonable
21:47:09 <shachaf> tabemann: You'll probably make things worse by blindly adding !s.
21:47:13 <tikhonjelvis> heh, the shared prefixes strike again
21:47:15 <Gracenotes> it is probably good to recognize extraneous bangs
21:47:28 <nejucomo> I occasionally find myself writing something which is a sequence of: m (Maybe t), where the t's vary, all in the same Monad instance m...
21:47:43 <nejucomo> Is there a way I can combine the Maybe monad into m?
21:47:57 <tikhonjelvis> hmm
21:48:01 <Gracenotes> just adding them arbitrarily is a matter of syntactic translation, but recognizing strictness will show where they help and where they hinder.
21:48:08 <carter> tabemann i write really strict code by default
21:48:13 <monochrom> it is best to learn lazy evaluation properly before adding bangs. read my http://www.vex.net/~trebla/haskell/lazy.xhtml
21:48:17 <tabemann> well the main place I'm adding them is to datastructures, e.g. I created types named Vector2, Vector3, Vector4, and Matrix in the code I'm working on, and made their contents strict
21:48:31 <tikhonjelvis> aww, IRC doesn't seem to like non-ASCII handles
21:48:37 <monochrom> but yes those are good places
21:48:43 <Gracenotes> tabemann: you're using arrays for linear-algebra objects?
21:48:51 <Watabou> question: how do I use function composition with a map? I want to do something like this    unlines (map (++" ") (lines "this is a test"))    but with function composition. How would I do that?
21:48:52 <Gracenotes> tikhonjelvis: back in the day, all you had for a nick was 8 characters
21:48:52 <tabemann> geometry transformations
21:48:54 <carter> monochrom i'm giving a talk on ghc primops tomorrow
21:48:59 <carter> tabemann use linear
21:49:05 <monochrom> ooohhh primops
21:49:12 <Gracenotes> as long as you're not using, say, nested lists to represent matrices
21:49:13 <monochrom> @quote monochrom primop
21:49:13 <lambdabot> monochrom says: primop is where the turtle tower ends and the russian dolls begin!
21:49:14 <shachaf> Watabou: (unlines . map (++" ") . lines) "this is a test"
21:49:24 <Watabou> I came up with unlines . map (++" ") . lines   but that doesn't work. I'm still not getting the syntax down
21:49:36 <shachaf> It works real good. You just need parentheses.
21:49:38 <carter> monochrom also walking through a teeny bit of cps + closure conversion frist
21:49:42 <tikhonjelvis> nejucomo: are you familiar with monad transformers?
21:49:54 <tabemann> Gracenotes: oh no - I was originally going to use arrays, but then I realized even that would have been less efficient than, say, data Matrix = Matrix !Double !Double !Double...
21:50:03 <carter> tabemann for low dim algebra use Linear
21:50:14 <carter> tabemann for high dim, wait a month or so for my open tech preview release :)
21:50:35 <nejucomo> tikhonjelvis: I am somewhat familiar with mtl, such as the ErrorT and StateT types.
21:50:36 <carter> somewhere in between I may randomly try to SIMDify Linear
21:50:37 <Watabou> shachaf: hmm okay, but what if I have a function like this:    printstuff str =   Would I still have to put the str at the end of the parenthesis?
21:50:44 <Gracenotes> tabemann: sounds good, although I can't guarantee unpacking a lot of values at once might not necessarily be efficient, depending on how you're doing it
21:50:45 * nejucomo hunts for ways to integrate Maybe into an mtl stack.
21:50:54 <tikhonjelvis> MaybeT
21:51:00 <tikhonjelvis> probably
21:51:03 <Gracenotes> @package linear
21:51:03 <lambdabot> http://hackage.haskell.org/package/linear
21:51:08 <tabemann> carter: tried to look up linear algebra in HaskellWiki, but it seemed to be broken
21:51:18 <tikhonjelvis> that's my usually "hello world" monad transformer, when I try to explain the idea to people
21:51:18 <carter> tabemann hackage/linear
21:51:29 <tikhonjelvis> but I've never actually used it in real code :P
21:51:48 <Gracenotes> that seems very.. abstract-algebra based
21:52:11 <shachaf> Watabou: What?
21:52:15 <carter> tabemann theres no good bsd3 numerical linear algebra on hackage *YET*
21:52:17 <carter> :)
21:52:26 <carter> linear is good for 2-4 dim algebra
21:52:33 <Gracenotes> not a bad thing at all though
21:52:48 <shachaf> Watabou: Function application is "stickier" than any operator. So if you see "f x @#$% g y", that always means (@#$%) (f x) (g y)
21:52:55 <shachaf> . is an operator.
21:53:01 <Watabou> shachaf: Okay So I have a function like this: printSomeStuff str = (unlines . map (++" ") . lines) str
21:53:02 <tikhonjelvis> usually
21:53:18 <Watabou> when I try to compile that, ghc complains that I have an "eta reduce"
21:53:20 <Watabou> Not sure what that means
21:53:24 <shachaf> Watabou: A good way to write this function: printSomeStuff = unlines . map (++" ") . lines
21:53:30 <tikhonjelvis> it means you could write it without the str argument
21:53:44 <tikhonjelvis> basically, since it appears at the end of both sides of the =, you can cancel it out
21:53:47 <Watabou> Ah yeah, that's what I was going for. thanks
21:53:48 <tikhonjelvis> just like high-school algebra :)
21:53:51 <tabemann> carter: now I presume linear includes stuff like cross products and all that? (does it contain the typical geometric transformations?)
21:53:52 <shachaf> Watabou: Eta-reduce means turning something like "f x = blah x" into "f = blah"
21:54:04 <carter> tabemann sure, read the libs docs
21:54:05 <Watabou> Ah okay, got it, thanks!
21:54:07 <Gracenotes> it's calculus
21:54:23 <nejucomo> There is indeed a MaybeT in transformers…  I just noticed I have mtl and transformers as dependencies.  Is this a bad idea?
21:54:25 <Watabou> where can I read about eta-reduce? Google doesn't come up with any helpful links
21:54:30 <shachaf> @google eta reduction
21:54:31 <Gracenotes> just don't eta-reduce everything away with type-classes
21:54:31 <lambdabot> http://www.lambda-bound.com/book/lambdacalc/node21.html
21:54:31 <lambdabot> Title: Eta Reduction
21:54:38 <carter> tabemann reading the docs is more effective than asking me, usually :)
21:54:43 <monochrom> this is why when people ask about prerequisites of Haskell, I answer highschool algebra.
21:54:56 <tikhonjelvis> you could probably read about it in some book on the lambda calculus
21:55:00 <tikhonjelvis> maybe TAPL?
21:55:16 <shachaf> monochrom: Perhaps a prerequisite of highschool algebra is Haskell!
21:55:17 <Gracenotes> wikipedia isn't bad for learning about LC
21:55:20 <Watabou> I took Calculus 1,2 and 3 but I haven't heard about eta-reduction unless I missed something monochrom
21:55:26 <lispy> Prerequisites for asking in #haskell? TAPL...
21:55:28 <shachaf> Or at least some notions that you get in Haskell. Like unification.
21:55:35 <tikhonjelvis> eta-reduction would never come up in calculus
21:55:42 <Gracenotes> Watabou: calculus they teach in high school/college is usually calculus of variations
21:55:46 <carter> monochrom i have funny opinions on linear since i read TAPL and ATAPL in high school
21:55:50 <Gracenotes> there are other calculi
21:55:50 <monochrom> sure, but you learned "subsitution equal for equal", you learned "do the same thing to both sides of an equation"
21:55:52 <carter> *learning
21:56:04 <monochrom> s/substitution/substitute/
21:56:11 <shachaf> Perhaps Gracenotes meant "(lambda) calculus".
21:56:13 <Watabou> sure, I just didn't know you could do that in haskell
21:56:22 * Watabou is still learning
21:56:34 <tabemann> okay, I am looking over the linear documentation, and it contains a *lot* of linear algebra stuff, and yet I can't find the stuff I'd need of it
21:56:43 <lispy> I thought algebra was for doctors
21:56:45 <lispy> http://www.etymonline.com/index.php?allowed_in_frame=0&search=algebra&searchmode=none
21:56:52 <carter> tabemann whats the goal
21:56:56 <carter> describe your goal
21:57:03 <carter> not the specific path you're tyring
21:57:04 <tabemann> okay, found normalize and dot products...
21:57:18 <Gracenotes> Watabou: this might be clearest: http://en.wikipedia.org/wiki/Lambda_calculus
21:57:20 <monochrom> right, so, remember this: "f x = x+1", this does not say "f x returns x+1". we don't do imperative "return" control-flow here. f x *is* x+1. f x *equals* x+1.
21:57:51 <shachaf> monochrom++
21:58:04 <tabemann> I am basically trying to implement constructing transformation matrices through multiplying multiple ones so as to be able to feed them into OpenGL; I also want dot and cross products to be able to do certain kinds of operations on vectors (for geometric stuff)
21:58:16 <Gracenotes> or maybe not, if you just want to do Haskell :)
21:58:52 <carter> tabemann you should check out #haskell-game
21:58:59 <carter> or talk with lispy
21:59:03 <Watabou> Gracenotes: It's great that people recommend me math books when I ask what the hell an "eta-reduce" is
21:59:03 <carter> or jmcarthur
21:59:08 <lispy> hello, I am lispy
21:59:10 <otters> actually, I don't even know if it's possible to do this on blaze-markup's Html type since it's a rank-n type
21:59:14 <tabemann> and I am preferring to implement something fast rather than something general
21:59:20 <carter> tabemann http://hackage.haskell.org/packages/archive/linear/1.1.2/doc/html/Linear-V3.html
21:59:27 <carter> tabemann fast is simd :)
21:59:32 <tikhonjelvis> Watabou: It's hard to tell math and CS books apart, really
21:59:45 <carter> cross product in that link
21:59:51 <tikhonjelvis> at some point, you just start conflating logic and programming stuff
22:00:04 <tikhonjelvis> the lambda calculus is basically that point
22:00:17 <Gracenotes> on that note, I recently bought Judea Pearl's Causality, which is probability theory, philosophy, and possibly some algorithms
22:00:34 <carter> Gracenotes cool, i got it a few months ago but haven't had time to stare at ityet :(
22:00:37 <Gracenotes> looking forward to reading it somewhere nice outside, once somewhere nice can be found outside
22:00:48 <Watabou> Yeah I know about lambda calculus, and I have a book related to haskell actually that I will read later
22:00:52 <Gracenotes> I've also gotten into graphical models a bit lately
22:01:03 <tabemann> carter: it's still looking like I might need to add my own code for creating certain kinds of matrices, some of which is trivial, some which is less trivial (rotate), and some which I have to probably dig down into my OpenGL docs to figure out (ortho and frustum)
22:01:13 <tikhonjelvis> My point is that you can't really get away from math if you want to delve into Haskell
22:01:21 <tikhonjelvis> even if you don't acknowledge it, you're going to learn some
22:01:27 <tikhonjelvis> so math books make sense
22:01:28 <Watabou> I've taken a lot of math courses, it's just weird when someone points out I need to take highschool algebra just because I don't know what eta-reduce is
22:01:31 <tikhonjelvis> and they're actually CS books
22:01:33 <carter> tabemann you should lurk on #haskell-game and talk with people there
22:01:39 <carter> or ping jmcarthur  et al
22:01:49 <carter> linear algebra for games
22:01:52 <tikhonjelvis> oh no, the point isn't that eta-reduction is covered in high school algebra
22:01:59 <tikhonjelvis> rather, it's just an analogy
22:02:00 <carter> is different from fast linear algegra generally
22:02:10 <tabemann> okay just joined #haskell-game
22:02:12 <carter> I'd know, i'm doing the thatter :)
22:02:17 <carter> *latter
22:02:19 <tikhonjelvis> that is, eta-reduction is just like cancelling variables on both sides of an equation
22:02:21 <lispy> tabemann: I've never used linear, but I would guess that you want to work with M44 Double (or M44 Float) as your underlying matrix type.
22:02:23 <tikhonjelvis> just like in elementary algebra
22:02:26 <gaze__> eta reduction isn't covered in a usual undergraduate math curriculum
22:02:35 <otters> http://hpaste.org/88795
22:02:40 <otters> is lambdabot away
22:02:41 <Watabou> yeah, that's why I asked
22:02:47 <lispy> tabemann: to compose the linear transformations you would then multiple the matrices
22:02:55 <tabemann> lispy: well yes
22:02:58 <tikhonjelvis> I think that I was not entirely clear on that point earlier
22:03:02 <otters> you can't recurse into Parent because its children have a different type :|
22:03:19 <lispy> tabemann: Cool. So you know how homogeneous coordinates and the prespective projection work?
22:03:33 <Watabou> I'm just a beginner so I don't really understand ghc errors yet
22:03:35 <carter> lispy i have some fast 4x4 c code using simd I wrote a few weeks back http://hackage.haskell.org/packages/archive/linear/1.1.2/doc/html/Linear-V3.html
22:03:37 <carter> oops
22:03:37 <otters> I could do a string replace, but ugh, that's nasty
22:03:39 <carter> i mean
22:03:40 <lispy> affine transformations and all that jazz
22:03:41 <carter> https://gist.github.com/cartazio/5586232#file-matexperiments-c-L106-L151
22:03:49 <carter> SIMD and stuff
22:04:07 <Gracenotes> oh, hm, quantified constructors. fun.
22:04:15 <tikhonjelvis> yeah, the error messages can be a bit confusing sometimes
22:04:23 <tikhonjelvis> but eta-reduction isn't an error, it's more of a style thing
22:04:24 <carter> rowmatrixA = rowmatrixB * colmatrixC + rowMatrixA
22:04:25 <lispy> carter: I think you were showing me that. Looks like line noise to me :)
22:04:26 <tikhonjelvis> are you using hlint?
22:04:28 <tabemann> perspective projection is one of the things that I need to figure out how to implement (the way that some of the matrices are specified in the OpenGL docs are kind of opaque, and that's what I have to go off of...)
22:04:48 <carter> lispy my brains been warped, i look forward to focusing on APIs and types and things again at some point
22:05:26 <Gracenotes> otters: sounds like maybe the type system (well, the API) wants you to go about it another way
22:05:32 <Gracenotes> but I've never used it before, I'm afraid
22:05:34 <otters> yeah it looks that way :|
22:05:45 <lispy> tabemann: my advice there is to work in 2D with a 3 dimensional homogeneous space instead of 3D with a 4D homogeneous psace
22:06:36 <tikhonjelvis> hmm, talking about error messages—do you think it would make sense for libraries to have a way to customize their error messages?
22:06:41 <tabemann> well the matrices I am going to be feeding into OpenGL are going to be 4x4 matrices
22:06:45 <tikhonjelvis> I think it would be a useful feature, but I'm not sure what it would look like.
22:06:59 <lispy> tabemann: right. I meant when you work out examples on paper :)
22:07:02 <carter> tabemann … lispy is the opengl-hs maintainer last i checked :)
22:07:27 <Gracenotes> yeah, I am confused
22:07:34 <lispy> tabemann: I found this article to be really helpful (but depending on your level of maths background it may just be gibberish): https://en.wikipedia.org/wiki/Homogeneous_coordinates
22:07:37 <gaze__> tikhonjelvis: How's your experience been with the greenarrays processors?
22:07:44 <tikhonjelvis> umm
22:07:47 <gaze__> all I know is the company is pretty nutty
22:07:48 <tikhonjelvis> limited :P
22:07:51 <tikhonjelvis> oh yeah
22:07:52 <Watabou> tikhonjelvis: Oh yeah, that's what I meant, not ghc, it is hdevtools that complains. Interestingly, it marks it as an error, not a warning
22:07:53 <tikhonjelvis> definitely
22:07:53 <gaze__> but full of very bright people
22:08:07 <tikhonjelvis> that's a fair assessment
22:08:32 <tabemann> oh good - I just opened the opengl 2 spec, which I had on hand, and it went right to the page with the frustum and ortho matrices, and they're actually specified straightforwardly
22:08:33 <tikhonjelvis> I wrote a little emulator for the chip
22:08:38 <tikhonjelvis> and I've been basically living in that
22:08:49 <tikhonjelvis> their development tools... leave a little to be desired
22:08:50 <lispy> tabemann: also, if your goal is to understand how rendering works, I actually found it easier to start with raytracing (of course, your mileage may vary)
22:08:53 <tikhonjelvis> and the actually chip itself is a pain to use
22:08:55 <gaze__> ah fair enough
22:09:08 <gaze__> they basically leave everything to be desired
22:09:13 <tikhonjelvis> if you're interested, you should check out my array-forth pacakge :P
22:09:23 <tikhonjelvis> I'm just adding support for modelling multiple cores
22:09:30 <Gracenotes> rendering, for me, is a matter of why one or two matrix transformations can magically make things look 3D.
22:09:39 <Gracenotes> plus z-ordering business.
22:09:46 <tikhonjelvis> the name is a bit misleading, because I don't actually support forth
22:09:52 <tikhonjelvis> I just model their instruction set directly
22:10:12 <tikhonjelvis> it's a very cute instruction set, coincidentally
22:10:13 <Gracenotes> I found a textbook helped most with that... raytracing can easily get pretty complicated if you implement reflections and stuff
22:10:15 <tabemann> I understand how rendering works, aside from that I am not familiar with this whole shader business that you are now supposed to implement things in terms of
22:10:38 <tabemann> rendering with drawing polygons, not raytracing, that is
22:11:04 <tikhonjelvis> gaze__: are you familiar with GreenArrays?
22:11:05 <gaze__> yeah I mean the one thing you definitely can't deny about their setup is that it's full of lots of very clever bits
22:11:15 <gaze__> yeah yeah, I spoke to some of their engineers
22:11:22 <tikhonjelvis> "some" probably means "all"
22:11:23 <otters> hehe, I can use unsafeCoerce to fix it...
22:11:48 <gaze__> I mean that kind of ideology usually has interesting people backing it, so I really figured I ought to have some kind of conversation with them
22:11:57 <gaze__> and boy oh boy did I get an earfull
22:12:01 <tikhonjelvis> oh yes, very interesting
22:12:01 <Gracenotes> This tutorial seems like a great GLSL-integrated way to do modern OpenGL: http://www.arcsynthesis.org/gltut/
22:12:07 <Gracenotes> I've partly followed it in the past
22:12:16 <tikhonjelvis> last time I talked to them, they explained that they needed to find some young person to train
22:12:20 <tikhonjelvis> because they're all going to die soon
22:12:23 <Gracenotes> none of the glBegin/glEnd nonsense
22:12:30 <tikhonjelvis> pretty direct :P
22:12:49 <tikhonjelvis> so yes, *very* interesting people
22:13:06 <gaze__> YES! I got the exact same thing!
22:13:08 <Gracenotes> tabemann: but yes, I can recommend it for sure, as an intro to shaders
22:13:13 <lispy> glBegin/glEnd is nice when starting out, but it can become cumbersome quickly
22:13:27 <gaze__> They had this entire plan to convince kids to not go to university to be educated stupid (see time cube)
22:13:36 <tikhonjelvis> yep
22:13:40 <tabemann> I remember doing the whole glBegin/glEnd thing back when
22:13:49 <gaze__> and learn to design semiconductors using floppy disks and graph paper
22:13:53 <tikhonjelvis> for better or worse, I like to live at too high a level of abstraction to be interested
22:14:01 <tikhonjelvis> and I'm already at a university
22:14:09 <gaze__> me too
22:14:10 <Gracenotes> yeah, me too. the flow is a lot easier than buffer objects, to be certain.
22:14:12 <gaze__> I'm sure I'd learn a hell of a lot
22:14:18 <tikhonjelvis> I'm guessing they would not be very interested in category theory
22:14:27 <Gracenotes> (me too regarding using glBegin etc)
22:14:28 <gaze__> they're clearly brilliant and have seen a lot of stuff. Clearly their methods aren't *wrong*
22:14:46 <tikhonjelvis> well, for some value of "wrong", anyhow
22:14:47 <gaze__> tikhonjelvis: Oh hell no. He gave me a 15 minute diatribe chewing out lisp
22:15:01 <gaze__> and basically any sort of high level anything
22:15:05 <gaze__> I think they just don't believe in abstraction
22:15:09 <gaze__> or floating point numbers
22:15:14 <tikhonjelvis> yes
22:15:14 <gaze__> or IDEs
22:15:16 <gaze__> or usability
22:15:18 <gaze__> or bounds checking
22:15:20 <tikhonjelvis> they wrote their own IDE
22:15:23 <Gracenotes> well, IDEs aren't super necessarily
22:15:29 <tikhonjelvis> but, like every single other IDE, it's strictly inferior to Emacs
22:15:35 <tikhonjelvis> except in their case, it's also crazy
22:15:45 <Gracenotes> anyway, my motto is: model essential complexity, not accidental complexity
22:15:55 <gaze__> When I saw the line in the manual "If you don't see the cursor, hold up and left."
22:16:03 <gaze__> I shook my head and figured I was in for a ride.
22:16:07 <tikhonjelvis> the Haskell community actually also has some hardware people
22:16:13 <tikhonjelvis> but they actually like category theory
22:16:17 <gaze__> me being one of them.
22:16:39 <tikhonjelvis> some people at BayHac were working on compiling Haskell to hardware
22:16:48 <gaze__> but I don't see category theory being terribly useful for what I'm working on right now
22:16:58 <tikhonjelvis> with the main design being based around cartesian-closed categories
22:17:00 <carter> gaze__ what are you workin gon now?
22:17:09 <Gracenotes> this EDSL compiles to some hardward spec language: http://raintown.org/lava/
22:17:14 <gaze__> I do superconducting/quantum circuits
22:17:26 <carter> i'm eyeing dabbling in hardware stuff at some point in the next year or so
22:17:27 <tikhonjelvis> yeah, their goal was to *not* have an EDSL
22:17:28 <carter> ahhhhh
22:17:30 <gaze__> which may some day require some kind of higher design language. not now.
22:17:45 <gaze__> now it's basically all done in LEdit
22:17:51 <tikhonjelvis> one of them (Conal) wrote some DSLs like that in the past and wanted to try something new
22:17:53 <Gracenotes> hardware stuff seems better when it's declarative, to me, not having done it
22:17:54 <carter> gaze__ elaborate on whatyou'r doing?
22:18:10 <carter> tikhonjelvis conal emailed cafe about this in fact
22:18:12 <Gracenotes> but I have simply not seem much other approaches
22:18:16 <Gracenotes> *seen
22:18:25 <gaze__> http://web.physics.ucsb.edu/~martinisgroup/ I work here, and I'm moving here http://qulab.eng.yale.edu/
22:18:29 <carter> Gracenotes the subtle bit is the geometry constraints on circuit layout
22:18:37 <carter> gaze__ new haven sucksss
22:18:40 <carter> come visit us in nyc
22:18:49 <carter> though Bruar BAR has good beer and pizza
22:19:02 <gaze__> I mean I'm not pleased about moving away from santa barbara.
22:19:02 <Gracenotes> nyc is great. says I, as I move out to CA
22:19:17 <carter> Gracenotes were you at any ahskell meetups?
22:19:19 <gaze__> and yes BAR has amazing potato bacon pizza
22:19:29 <carter> YES
22:19:32 <Gracenotes> carter: I didn't make anyway, they only popped up over the last year
22:19:41 <tabemann> random question: I don't remember how to do multiline strings in Haskell (even though I probably have read somewhere)
22:19:51 <carter> Gracenotes yes, i'm giving a  talk at one tomrrow..
22:19:57 <Gracenotes> hm, you don't say
22:20:00 <Gracenotes> when/where is it?
22:20:03 <shachaf> @google haskell multiline strings
22:20:04 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2006-January/013911.html
22:20:04 <lambdabot> Title: [Haskell-cafe] multiline strings in haskell?
22:20:11 <shachaf> Like that. :-)
22:20:11 <carter> gaze__ and the undergrads thare are messed in the head
22:20:22 <carter> still get twitchy about that school
22:20:29 <gaze__> fortunately I don't really have to interact with them
22:20:45 <tabemann> okay, good, so I can embed my GLSL code in my Haskell code
22:20:48 <Gracenotes> carter: or have a link?
22:20:53 <gaze__> carter: haha what exactly left you twitchy
22:20:58 <carter> the people
22:21:00 <carter> sucked
22:21:39 <gaze__> haha in what way?
22:21:51 <carter> all fo them
22:21:55 <carter> i will not speak of this further
22:22:14 <tikhonjelvis> I'd be a little suspicious of undergrads in general
22:22:15 <tikhonjelvis> especially me
22:23:35 <tikhonjelvis> Hmm, how often do they have the Haskell NY meetups, coincidentally? Once a month?
22:23:43 <gaze__> yeah me too. I have no idea what I'm doing.
22:24:15 <Gracenotes> carter: well I think I will stalk you, and see ya tomorrow
22:24:30 <carter> lets just say when i intro'd two friends from yale to eachother a few months back , i may have said "yale dudes who i don't put in the same class of people at pedophiles"
22:24:34 <Gracenotes> okay, maybe just the latter
22:24:39 <carter> Gracenotes cool
22:25:12 <carter> *as
22:26:16 <Gracenotes> looks like it'll be another rainy day in Manhattan tomorrow
22:27:21 <carter> Gracenotes i have an umbrella,its ok
22:27:44 <Gracenotes> me too :)
22:28:11 <dolio> Just don't go outside.
22:28:13 <Gracenotes> although, I've been meaning to go to MoMA and get another one of theirs (my previous one broke)
22:30:10 <carter> cool
22:36:23 <tikhonjelvis> hmm, what is the difference between cabal-dev and hsenv?
22:49:54 <Gibheer> how can I do something like the following in haskell? foo(bar(23)). I tried foo(bar 23), but then it tells me, that foo does not take two arguments and foo(bar(23)) also gets interpreted as two arguments
22:50:25 <mauke> Gibheer: ಠ_ಠ
22:50:33 <mauke> show your actual code and the actual error message
22:50:55 <zRecursive> Gibheer: foo $ bar 23
22:51:01 <mauke> zRecursive: fail
22:51:17 <tabemann> foo . bar $ 23
22:52:01 <tikhonjelvis> the important point is that foo (bar 23) *should* work by itself
22:52:02 <shachaf> Uh, zRecursive, tabemann, something is not understood about what's going on, but surely adding even more, more complicated, variations isn't going to clarify anything.
22:52:09 <Gibheer> mauke: https://gist.github.com/Gibheer/575fde1ca536537c27ed
22:52:27 <shachaf> Aha. See?
22:52:47 <mauke> Gibheer: it's complaining about getResponseBody, not simpleHTTP
22:53:26 <mauke> you're doing 'foo bar (baz 42)' but foo only takes 1 argument
22:53:28 <shachaf> "foo bar(vaz(duck))" means "(foo bar) (vaz duck)"
22:53:39 <mauke> "duck"?!
22:53:46 <tikhonjelvis> vaz?
22:53:51 <shachaf> "barvaz" means "duck".
22:54:00 <tikhonjelvis> I have not heard that one before
22:54:17 <mauke> oh, nice
22:54:34 <tabemann> I've never seen "vaz" used in the place of "baz" and "duck" used in the place of "quux"
22:54:39 <tikhonjelvis> beats the qux, quux, quuux convention
22:54:55 <shachaf> "quux" certainly doesn't belong anywhere.
22:55:08 <Gibheer> the syntax is a bit irritating
22:55:13 <mauke> Gibheer: false
22:55:14 <tikhonjelvis> well, to be fair, having a variable number of "u"s allows you to extend the series indefinitely
22:55:16 <shachaf> But the whole point of these words is that it doesn't matter what they are.
22:55:26 <mauke> shachaf: ah, not quite
22:55:41 <shachaf> Well, also that it stands out that it doesn't matter what they are.
22:55:48 <mauke> shachaf: they have to look implicitly universally quantified to the reader
22:55:54 <shachaf> Right.
22:56:21 <shachaf> Gibheer: mauke is right. You don't understand the syntax yet. I agree that the mental model you currently have is a bit irritating, but I don't think it matches Haskell's actual syntax. :-)
22:56:42 <tikhonjelvis> mathematicians would just use f, g and h
22:56:53 <tikhonjelvis> I don't know if that's better than foo, bar, baz though
22:57:39 <johnw> who was the first to use foo?
22:57:41 <Gibheer> shachaf: yeah, that may be the case
22:57:56 <shachaf> Let's not talk about the origin of "foo". It's offtopic enough as it is.
22:58:08 <johnw> just a question, shachaf, no need to be grumpy
22:58:55 <shachaf> I agree. I'm not grumpy.
22:59:06 * hackagebot postgresql-simple 0.3.3.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.3.3.0 (LeonSmith)
23:00:52 <shachaf> It's not as if there isn't an offtopic channel.
23:04:35 <tabemann> lispy: you're the maintainer for HOpenGL, right?
23:07:35 <hcaulfield57> Could someone tell me why line 3 doesn't work http://hpaste.org/88797
23:08:26 <mauke> "doesn't work" is not a problem description
23:08:41 <hcaulfield57> Is it trying to pass the Handle as the second parameter to hPrint?
23:08:47 <mauke> yes
23:09:10 <cmears> 10 isn't a handle
23:09:35 <hcaulfield57> mauke: Okay thank you, so does >>= only work on one parameter functions?
23:09:51 <mauke> all functions take exactly one argument
23:09:52 <shachaf> All functions are one-parameter functions.
23:10:41 <hcaulfield57> Yea I know, but I don't know how else to phrase my question I suppose
23:11:04 <cmears> hcaulfield57, you want "... >>= \handle -> hPrint handle 10"
23:11:12 <mauke> or flip hPrint
23:11:39 <hcaulfield57> cmears: Okay, would that be the general way to do something like that, with the lambda
23:11:53 <ski> yes, or
23:11:54 <ski> @undo do handle <- openFile "file.txt" WriteMode; hPrint handle 10
23:11:54 <lambdabot> openFile "file.txt" WriteMode >>= \ handle -> hPrint handle 10
23:12:20 <cmears> yes, that's the general way, or use do-notation like that, or in this case you can use flip
23:12:35 <ski> (or a right section)
23:12:47 <johnw> or: withFile "file.txt" WriteMode $ \handle -> hPrint handle 10
23:13:25 <ski> that closes the file, though
23:13:25 <mauke> writeFile "file.txt" "10\n"
23:13:38 <johnw> mauke: even better!  yes, it closes the file
23:13:45 <hcaulfield57> Okay, that all makese sense to me, I can see that my question was a little silly now
23:13:50 <qfwfq> I present a new emoticon; the double negative: '¬○¬'
23:14:06 * hackagebot markdown-kate 0.1.2.1 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-kate-0.1.2.1 (JoelTaylor)
23:14:12 <cmears> I don't think it's silly, it seems like a sensible enough question to me (:
23:14:24 <lispy> tabemann: yes, although it was written by someone else
23:14:45 <lispy> tabemann: I'm maintainer because no one else was doing it, not because I know it well :)
23:15:04 * lispy goes to bed
23:15:44 * ski . o O ( `¬○⌐' )
23:17:23 <hcaulfield57> cmears: Thanks :)
23:44:07 * hackagebot pipes-network-tls 0.1.0.0 - TLS-secured network connections support for pipes.  http://hackage.haskell.org/package/pipes-network-tls-0.1.0.0 (RenzoCarbonara)
