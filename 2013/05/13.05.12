00:01:32 <b__> Is there a library (or function) that has operations like add, subtract etc wrapped in an overflow check?
00:02:09 <dmwit> What would you like to happen on overflow?
00:02:27 <mauke> error
00:02:40 <wagle> hi -- what are "bird tracks" with respect to LHS and haskell and wikis and ...
00:02:47 <b__> error yes
00:02:50 <mauke> wagle: "> "
00:02:57 <wagle> thanks
00:03:05 <b__> I guess it can be typeclassed
00:03:13 <dmwit> Not that I know of.
00:03:32 <dmwit> Why error though?
00:04:12 <mauke> dmwit: correctness
00:04:54 <b__> If a node in a waveform (sound) overflow, I've messed up somewhere else
00:05:20 <dmwit> Why error over Maybe?
00:05:44 <mauke> less annyoing to use
00:05:49 <b__> because at this point I either have correct sound, or something unusable
00:05:57 <mauke> also, overflow indicates an error in the code, not the data
00:06:05 <b__> yes
00:06:26 <mauke> that is, the fix is to change the program
00:06:46 <b__> yes, eventually it should all work
00:13:54 * hackagebot ascetic 0.0.0.1 - Generic markup builder.  http://hackage.haskell.org/package/ascetic-0.0.0.1 (AndreiLapets)
00:15:18 <supki> @hackage safeint
00:15:19 <lambdabot> http://hackage.haskell.org/package/safeint
00:15:27 <supki> b__: ^
00:16:12 <scroy> @pf \n -> print n >> print (n+1)
00:16:12 <lambdabot> Maybe you meant: bf pl
00:16:41 <b__> supki, thanks
00:16:43 <scroy> @pl \n -> print n >> print (n+1)
00:16:44 <lambdabot> liftM2 (>>) print (print . (1 +))
00:18:47 <scroy> @unpl liftM2 (>>) print (print . (1 +))
00:18:47 <lambdabot> (print >>= \ b -> (\ i -> print (1 + i)) >>= \ a -> return (b >> a))
00:19:15 <b__> the thing is I have to work with Doubles, and only finally convert these to Words
00:19:42 <b__> so I have to check the Doubles for overflowing "as Words"
00:20:30 <mauke> fromIntegral (maxBound :: Word)
00:22:38 <b__> yeah that's what I do now
00:22:51 <b__> it works, it's just ugly
00:39:07 <fruitFly> mm_freak: you here?
00:53:05 <wagle> if i get this from a cabal install:      Module `Language.Haskell.TH' does not export `Inline'   .... am I running a GHC thats too new or too old?
00:57:14 <fruitFly> mm_freak: yo?!
00:59:33 <no-n> http://hpaste.org/87797 -- what should I do to make this code better? it's for making random (sometimes made up words) based on strings like "cve" (consonant, vowel, either)
01:01:53 <opqdonut_> :t randomR
01:01:57 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
01:02:19 <opqdonut_> no-n: 1) use a RandomGen and make it pure 2) use one of the Random monads
01:06:02 <no-n> randomRIO uses the global gen. do you mean to use a gen with an arbitrary seed?
01:07:25 <Ralith> use
01:07:27 <Ralith> @hoogle random-fu
01:07:27 <lambdabot> package random-fu
01:07:27 <lambdabot> package gsl-random-fu
01:07:31 <Ralith> er
01:07:33 <Ralith> @hackage random-fu
01:07:33 <lambdabot> http://hackage.haskell.org/package/random-fu
01:10:21 <jermey> anyone here know about helper functions?
01:10:36 <mauke> taking a poll?
01:10:56 <jermey> i kinda want private help where i can bounce questions off them (willing to pay for there time)
01:11:20 <mauke> ew, private help
01:11:41 <elliott> you should just ask in the channel. it's more likely to get a response.
01:11:54 <mauke> probably trying to cheat on homework
01:12:01 <jermey> no
01:12:16 <jermey> i m just worried if someone else from my class might steal my idea
01:12:31 <mauke> haha
01:12:51 <mauke> file a patent
01:13:06 <jermey> sif i m not apple
01:14:13 <Hafydd> jermey: what is your class?
01:14:21 <jermey> 3141?
01:14:26 <Hafydd> How many of your co-students do you think are here?
01:14:31 <Hafydd> What school is that in?
01:15:00 <mauke> well, this channel has public logs
01:16:22 <Hafydd> > pi
01:16:25 <lambdabot>   3.141592653589793
01:16:30 <Hafydd> Is that a coincidence?
01:16:31 <jermey> i ll just ask here
01:16:38 <jermey> without trying to post code
01:17:00 <jermey> or post it and be like fuck you to anyone stealing shit
01:18:15 <jermey> i have a function satisfiable :: Formula ts -> Bool which checks if something satisfiable for formula
01:18:20 <mauke> newtype Counter = C Int  -- ORIGINAL TYPE DO NOT STEAL
01:18:28 <no-n> let pi = 3
01:18:49 <blaenk> haha someone was already asking about that assignment earlier
01:19:03 <jermey> damm
01:19:10 <jermey> was it about that function?
01:19:21 <blaenk> I just remember Formula and satisfiability
01:19:27 <blaenk> I didn't pay attention
01:24:00 <jermey> i have a function test (Body as) = eval as
01:24:00 <jermey> test(Forall (v:vs) p) = ????
01:24:10 <jermey> in the ???? i am trying to call truncated list with remove head
01:24:16 <jermey> anyone know syntax for this?
01:24:25 <mauke> what do you mean by "call truncated list"?
01:24:35 <mauke> 1) what list?  2) what "call"?
01:27:07 <wagle> @hoogle Inline
01:27:07 <lambdabot> GHC.Exts inline :: a -> a
01:27:07 <lambdabot> Language.Haskell.TH.Syntax InlineP :: Name -> InlineSpec -> Pragma
01:27:07 <lambdabot> Language.Haskell.TH InlineP :: Name -> InlineSpec -> Pragma
01:28:05 <jermey> wow that was a bad question on my part
01:28:14 <jermey> hold on i ll show you the code
01:29:35 <hpaste_> jermey pasted “jermey” at http://hpaste.org/87800
01:31:12 <jermey> i m trying to write that sudo code in haskell
01:31:45 <mauke> *pseudo
01:31:55 <mauke> the main problem is that the pseudo code makes no sense
01:32:01 <mauke> my questions still stand
01:33:59 <jermey> 1) we have formula's ex1, ex2 etc
01:34:14 <jermey> which are called e.g. Solver> satisfiable ex1
01:34:26 <jermey> that checks if ex1 satisfy is true or not
01:34:45 <ByronZED> Rippln Mobile Apps Social Gamification - http://www.rippln.by/get-started/
01:35:11 --- mode: ChanServ set +o elliott
01:35:13 --- mode: elliott set +b *!*bzed@5.102.200.*
01:35:14 --- kick: ByronZED was kicked by elliott (ByronZED)
01:35:16 <mauke> aw
01:35:20 <mauke> I wanted to see the kill
01:35:39 <elliott> freenode always gets the spammers first! I wanted to be special for once
01:35:42 --- mode: elliott set -o elliott
01:40:23 <savask> Hello. I would like to do something like counting sort in Haskell: function takes a list of Word8 and returns a 256-long list of Int. So, for example, if I give it [1, 2, 1], the output will be [0, 2, 1, 0, 0,...0]. I'm sure I should use ST monad to do that in a fast fashion, but how?
01:41:38 <fizruk> jermey: in your Forall (v:vs) p, v is of type [a] and p is of type a -> Formula as ?
01:42:37 <mauke> savask: why are you sure you need to use ST?
01:42:48 <natnayr> anyone hear about a list comprehension inside a list comprehension?
01:43:34 <savask> mauke: Because otherwise it will be too slow, won't it? Firstly I will add [0..255] to the input, sort it, group, then map ((-1) . length)
01:43:38 <fizruk> savask: why you want to use list as an output? I'd used Map or something like that
01:43:52 <mauke> savask: what?
01:43:55 <mauke> savask: what exactly will be slow?
01:44:05 <mauke> savask: what do you mean by adding [0..255]?
01:44:12 <savask> mauke: Sorting
01:44:14 <mauke> savask: map ((-1) . length) is a type error
01:44:20 <savask> mauke: Ehh, let me try
01:44:22 <mauke> savask: you've lost me
01:44:26 <savask> Haha
01:46:36 <savask> > map (pred . length) . group . sort $ [0..10] ++ [1, 2, 1]
01:46:39 <lambdabot>   [0,2,1,0,0,0,0,0,0,0,0]
01:46:43 <savask> mauke^^
01:46:57 <savask> My case is the same, just I have 256 cells, not 10.
01:47:07 <mauke> oh, I see
01:47:14 <mauke> how slow is it?
01:47:17 <savask> fizruk: HNN uses lists as an input for neural network :C
01:47:33 <savask> mauke: Well, definitely slower than O(N)
01:47:39 <mauke> prove it
01:47:50 <savask> Sort is slower than O(N)
01:48:06 <mauke> O(N) isn't even a real time
01:48:13 <fruitFly> Is there an easier way to convert a Char to Word8? http://ideone.com/4D0859
01:49:16 <savask> fruitFly: read ['7'] :: Word8
01:49:34 <fruitFly> savask: pff.. why I soo stupid.. Thanks :)
01:49:35 <Eelis> fruitFly: have you given thought to the character encoding you wish to use? in UTF-8, the most common character encoding, a Char may require several Word8s to encode
01:49:57 <savask> mauke: Soooo, it will be still slower in practice :-P
01:50:03 <Taneb> Eelis, he's doing the other thing
01:50:10 <chirpsalot> Apparently I am confused about how modules work at the moment :(. If I have a directory Blah, and in that directory I have Mod1.hs and Mod2.hs - where Mod1.hs has "module Blah.Mod1 where"... Shouldn't Mod1.hs be able to import it with "import Blah.Mod1"?
01:50:16 <Eelis> Taneb: what other thing?
01:50:24 <Taneb> Eelis, '7' -> 7 etc
01:50:45 <fruitFly> Eelis: I'm converting hex Chars to binary
01:50:50 <Eelis> ah
01:50:50 <mauke> savask: prove it
01:50:52 <savask> mauke: My "imaginary" way of doing that is just incrementing cells of the vector as you do in imperative languages, and then turn it to list. That will O(N) which is faster than sorting lists and grouping them -_-
01:50:54 <Taneb> rather than '7' -> 55
01:51:04 <mauke> savask: how do you know it will be faster?
01:51:30 <savask> mauke: Because O(N) is always faster than sorting, and there are no expensive operations to make that false.
01:51:37 <mauke> savask: bullshit
01:51:49 <savask> mauke: So you say sorting will be faster?
01:52:23 <savask> mauke: I mean, if I had to calculate 10000000th digit of pi while my O(N) algo, then yes, I would use sorting instead.
01:52:48 <savask> But in this example counting in a cycle is a lot better.
01:53:28 <mauke> "Because O(N) is always faster than sorting" is nonsensical
01:53:43 <savask> Ehm, don't cut my phrases, please.
01:53:43 <fizruk> afaik, radix sort is O(N)
01:53:51 <fizruk> sort of
01:54:01 * hackagebot accelerate-io 0.13.0.1 - Read and write Accelerate arrays in various formats  http://hackage.haskell.org/package/accelerate-io-0.13.0.1 (TrevorMcDonell)
01:54:01 <savask> mauke: If there are no expensive operations to make that false.
01:54:03 * hackagebot accelerate-cuda 0.13.0.1 - Accelerate backend for NVIDIA GPUs  http://hackage.haskell.org/package/accelerate-cuda-0.13.0.1 (TrevorMcDonell)
01:54:53 <mauke> savask: it's not even wrong
01:54:53 <mauke> it makes no sense
01:54:57 <savask> Eeeh
01:55:14 <savask> I feel like you just want to prove that sometimes O(N log N) algos are faster than O(N)
01:55:36 <savask> That depends on the "coefficient", right?
01:56:06 <chirpsalot> O(n) \in O(n * log n)
01:56:12 <mauke> no, it depends on the actual runtime
01:56:35 <savask> mauke: Okay, can you help me to implement a ST one then so we can test two approaches?
01:56:50 <elliott> chirpsalot: such misuse of \in :(
01:56:55 <chirpsalot> For sufficiently large input an O(n) algorithm will always execute faster than an O(n * log n) one on the same input - however a sufficiently large input may be VERY large indeed.
01:57:21 <chirpsalot> elliott: oh crap. Subset?
01:57:43 <mauke> savask: you're implying there are only two approaches, one of which is "a ST one"
01:57:54 <savask> Nope, not ONLY
01:58:05 <elliott> chirpsalot: right. hey, at it's not as bad as saying a function "= O(n)" :)
01:58:07 <fizruk> it
01:58:40 <cmccann> fizruk: fwiw radix sorts are O(k*n) or something, where k is the size of things being sorted
01:59:09 <fizruk> cmccann: aha :)
01:59:22 <savask> mauke: I see two ways of solving my problem. Word8 can be 0-255 so we can use an array [0..255] and increment it's cells while sliding down the input list. Or we can do that weird way I showed at the start.
01:59:27 <chirpsalot> elliott: I was thinking just n \in O(n * log n). My bad.
01:59:34 <cmccann> but if you want to make your algorithm sound faster you claim that k is constant and now you can say hash tables are O(1) lookup with a straight face
01:59:45 <mauke> savask: or you can use a Data.Map instead of an array
01:59:53 <mauke> savask: or an association list
01:59:58 <mauke> or Data.IntMap
01:59:59 <savask> mauke: And that will be still slower
02:00:08 <fizruk> savask: I'd use an intermediate structure to make sorting faster
02:00:11 <mauke> ah, I forgot about the profiler in your head
02:00:48 <savask> mauke: I have tried both ways
02:00:52 <wagle> if the code does "import Data.Time.Clock (diffUTCTime)", why is old-time used instead of time?
02:01:04 <mauke> savask: define "both"
02:01:35 <savask> mauke: Sorting way and counting way. My old program used hmatrix for that, but now I'm going to get rid of it, so I'm seeking for another method.
02:02:09 <fizruk> mauke: as I understand, he can use a mutable array (within ST) to make things faster, if he doesn't need that intermediate structure anymore
02:02:28 <hpaste_> savask pasted “Hmatrix counting” at http://hpaste.org/87802
02:02:41 <savask> Here is my old code.
02:03:26 <fizruk> however, if one needs to sort a number of similar lists - it should be faster to use common substructures
02:03:36 <fizruk> is that right?
02:04:01 * hackagebot accelerate 0.13.0.1 - An embedded language for accelerated array processing  http://hackage.haskell.org/package/accelerate-0.13.0.1 (TrevorMcDonell)
02:10:00 <hpaste_> efie pasted “memory, laziness” at http://hpaste.org/87803
02:10:08 <efie> hello, could someone take a look at this?
02:10:33 <efie> oh, I forgot to import Data.Tree
02:12:20 <elliott> you can use "repeat tree" to define "trees", btw
02:12:33 <elliott> anyway, the list will still be traversed and all the cells allocated, though they will get GC'd as you go long enough in the list
02:12:38 <elliott> I would guess that that is what is causing the additional usage
02:12:52 <elliott> "repeat tree" should avoid that problem, also
02:12:59 <elliott> since it will create a cyclic list in memory, not a lazy infinite one
02:14:48 <fruitFly> does anyone here also program imperatively? How does it feel? Will learning haskell make most other languages feel extremely awkward and unusable?
02:15:03 <popl> no
02:16:08 <Eelis> fruitFly: no
02:16:26 <popl> fruitFly: you just "switch gears"
02:17:16 <popl> if you program in one language for awhile then switch to another you may have some instances of muscle memory creeping in, but that's not specific to haskell.
02:17:21 <fruitFly> popl:  sounds like a helluva a gear to switch
02:17:28 <popl> not at all dude
02:17:46 <popl> when I was at school I learned all sorts of different languages
02:17:47 <popl> it's fun
02:18:15 <fruitFly> popl: ok cool... i cam from imperative.. not that much experience... no just beginning coding in haskell i looked at an imperative example and it just look yuck
02:18:19 <fruitFly> looked*
02:18:37 <fruitFly> now* just
02:18:44 <efie> elliott: I don't understand yet, Ok, the list will be traversed but I thought because the 100000 first elements of this list are not needed, they won't be transformed, they aren't used later, and therefore they don't need to be stored?
02:19:32 <elliott> efie: the list structure has to be stored because it is generated as you scan down it linearly (it is a linked list) to find the 100001st element
02:20:04 <elliott> because you are generating it from a mapping over the infinite list [1..]
02:20:10 <elliott> whereas "repeat tree" is equivalent to
02:20:12 <elliott> trees = tree : trees
02:20:17 <elliott> which creates a "loop" in memory
02:20:28 <elliott> so that traversing down "trees" just gets you "trees" over and over and never allocates a new cell
02:20:39 <efie> ah okay
02:21:00 <efie> that's interesting
02:21:01 <efie> thanks =)
02:21:25 <popl> Do you mean: recursion
02:23:23 <efie> elliott: do you know why (intifiy trees) !! 100000 has even a less bytes maximum residency (28,528 bytes) versus (intifiy trees) !! 1 (44,416 bytes)?
02:23:58 <elliott> no. that confuses me.
02:24:20 <wagle> how do you convert from unix time (Int, int) to UTCTime?
02:24:27 <popl> intifiy?
02:24:35 <popl> efie: do you need sleep? :)
02:24:46 <efie> see my link above
02:24:51 <efie> its early in the morning =)
02:25:08 <popl> oh, you were consistent at least :)
02:31:38 <fizruk> savask: you here?
02:31:43 <savask> Yes.
02:32:48 <savask> fizruk: Eh?
02:33:04 <hpaste_> fizruk pasted “count sort” at http://hpaste.org/87806
02:33:31 <fizruk> savask: ^ is that what you wanted?
02:33:51 <savask> Yes, I think.
02:33:59 <efie> elliott: assuming I would wrote down let trees = [Node 1[] , Node 2, [] ... -- 10000 more trees], and I would like to get the last element of the list to be mapped over; would still be few memory used? I'm wondering because because all trees are different, there is no 'loop' in memory?
02:34:48 <fizruk> savask: I didn't test runtime of those, though
02:35:07 * wagle places the git blame on "    Don't use old-time, so we can build successfully with ghc 7.6.2."
02:35:16 <savask> fizruk: Okay, thanks :-) I'll try to use your code.
02:35:25 <wagle> is that even out?
02:36:10 <elliott> efie: well, it'd use as much memory as it takes to store your list.
02:39:11 <efie> elliott: um that's what I want to avoid, if element 1000 is needed, why isn't it like 'I read the first element, but I need element 1000, so I discard the first element, notice at which elemen I am and procees like this?'
02:39:29 <elliott> well, for a start you've stored trees at the top level.
02:39:36 <elliott> it won't discard anything because you could use it later.
02:40:45 <Taneb> I don't think ghc-mod is error-checking for me
02:41:12 <efie> elliott: could you give me a hint what I need to change to achieve what I want?
02:41:33 <elliott> I don't really understand what you want. if you only want one tree in the list, just write that tree and don't have a list at all?
02:42:36 <Botje> wagle: topic says GHC 7.6.3 is already out ;)
02:43:32 <efie> elliott: in the end there are more trees in the list, I wanted to check if the program uses laziness and as less memory as possible
02:43:44 <Taneb> Which is weird
02:43:51 <Taneb> Because I can do a hell of a lot else
02:44:53 <efie> elliott: if only the last of the Int Trees is used later in the program, I don't want the programm to use this much memory because of the other trees in the list
02:45:16 <elliott> why are you using a list?
02:46:35 <wagle> Botje: yeah, but not as a haskell platform..  8/
02:46:37 <efie> well thats part of the task, but I guess if you read write and write parse trees from a file they will be stored in a list
02:47:12 <wagle> trying 7.6.2 to see what happens
02:48:44 <wagle> Botje: thanks for noticing the topic, I'm switching to 7.6.3
02:49:02 * hackagebot largeword 1.0.5 - Provides Word128, Word192 and Word256 and a way of producing other large words if required.  http://hackage.haskell.org/package/largeword-1.0.5 (DominicSteinitz)
02:49:52 <efie> elliott: it's the same when I don't write trees at the top level
02:51:32 <elliott> again, if you just want one list, why are you storing a million others?
02:51:36 <elliott> maybe you want a function instead?
03:00:35 <efie> [1..] !! 1000000000 takes as much maximum memory as [1..] !! 1 - I don't see the difference to (intify (map (\_ -> tree1) [1..])) !! 1000000000 and (intify (map (\_ -> tree1) [1..])) !! 1
03:12:27 <Hafydd> Ninjya re (!!)
03:13:49 <wagle> efie: hold on to the first element while traversing to the last
03:14:03 * hackagebot tianbar 0.1.0.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.1.0.0 (AlexeyKotlyarov)
03:14:42 <wagle> never mind, i missed whatever the intify is
03:16:00 <efie> wagle: if you would like to take a look, I posted it here: http://hpaste.org/87803
03:39:43 <hpaste_> ASFsa revised “Sweet! I've just received my free Riot Points!  >> FreeRiotPoints.me <<”: “Fas” at http://hpaste.org/84861
03:40:12 <mauke> preflex_: seen chrisdone
03:40:12 <preflex_>  chrisdone was last seen on #haskell 16 hours, 1 minute and 50 seconds ago, saying: (●´∀｀●) it's beautiful …
03:40:40 <Fuuzetsu-> > 1
03:40:46 <lambdabot>   1
03:45:03 <Hafydd> ಠ_ಠ Someone is really using hpaste to spam the channel?
03:52:21 <merijn> Hafydd: Yes
03:52:34 <merijn> Hafydd: Titles with URLs in them are already being filtered
04:02:19 <socumbersome> Hi. Could someone please explain me why this: map f = foldr ((:) . f) []   works? In particular, at the end of recursive calls of foldr we will reach ((:) . f) x [], right?
04:02:45 <socumbersome> but do ((:) . f) take 2 parameters?
04:03:11 <merijn> socumbersome: Yes, but "foldr f z []" = z
04:03:39 <elliott> socumbersome: no, you will never reach ((:) . f) x []
04:03:45 <elliott> wait
04:03:46 <elliott> never mind
04:03:55 <merijn> In the case of "map f = foldr ((:) . f) []" z = [], so "map f [] = []", which is right
04:04:23 <merijn> elliott: ಠ_ಠ
04:04:32 <merijn> I have higher expectations of you :p
04:05:33 <socumbersome> ummm... sorry, but I cannot see the conclusion : )
04:05:59 <mauke> socumbersome: yes, ((:) . f) takes 2 arguments
04:06:41 <mauke> (((:) . f) x) y = ((:) (f x)) y = (:) (f x) y = f x : y
04:06:42 <merijn> socumbersome: "((:) . f)" is identical to "\x y -> f x : y"
04:06:50 <socumbersome> so this expands to something like:  (:) (f x) [] ?
04:06:57 <merijn> socumbersome: Yes
04:07:29 <zebr> hey all. just to double check, would you say that a non-function value is of order 0 (if you had to assign it an order)?
04:07:30 <socumbersome> oh, okay, thank, now it makes sense : )
04:07:46 <merijn> socumbersome: "(f . g) x = f (g x)", so "((:) . f) x = (:) (f x)"
04:07:46 <zebr> where by order i mean first-order function, second-order, etc.
04:08:14 <merijn> socumbersome: Which can also be written as "(f x :)"
04:09:01 <merijn> And since "(:) :: a -> [a] -> [a]" then "(:) (f x) :: [a] -> [a]" where "f :: b -> a"
04:09:38 <merijn> :t (:)
04:09:41 <lambdabot> a -> [a] -> [a]
04:09:52 <merijn> :t (:) . (undefined :: a -> b)
04:09:55 <lambdabot> a -> [b] -> [b]
04:11:32 <socumbersome> hm, just one more thing - why "(f x :)" is legitimate?
04:11:50 <socumbersome> cons at the end?
04:12:11 <elliott> just like (2 +)
04:12:14 <elliott> is (\y -> 2 + y)
04:12:19 <elliott> (f x :) is (\xs -> f x : xs)
04:13:04 <merijn> socumbersome: Section syntax, it works for any operator
04:13:20 <socumbersome> got it - nice and misleading (for laymans like me :P )
04:14:06 <merijn> socumbersome: Yeah, you get used to sectioning quite quick, though. And it's nice way to clean up some lines sometimes
04:16:54 <merijn> Similarly to elliott's example (+2) and (/3) translate to "\x -> x + 2" and "\x -> x / 3"
04:17:45 <Hafydd> socumbersome: FYI, the plural of "layman" is "laymen".
04:18:28 <socumbersome> pardon for my lame English ; )
04:23:47 <merijn> Anyone here using hsdevtools (possibly include syntastic) in vim to get real time typechecking while coding?
04:26:32 <merijn> I'm having a problem where my package includes a library and two executables (each in their own source dir) and hsdevtools isn't finding the library when I import it (probably because it's not globally installed...) anyone solve similar issues before?
04:27:10 <merijn> Unrelated, when will cabal finally start automatically running configure if I forgot it when I run "cabal build"? >.<
04:29:52 <Entroacceptor> why no cabal install
04:30:17 <supki> merijn: you can pass -i option to ghc via g:hdevtools_options
04:30:46 <supki> let g:hdevtools_optins = '-g -ifoo -g -ibar ...'
04:35:05 <merijn> Entroacceptor: Because I'm just compiling to test as I'm writing this thing
04:35:30 <merijn> supki: Ah, that's nice. To bad it's not really portable with different layouts
04:35:43 <merijn> I should just write something that queries the cabal file for source dirs...
04:36:20 <supki> merijn: yeah, I have .vim.custom file in the root of my projects with such customizations
04:36:27 <supki> the trick is to autoload it
04:37:01 <merijn> That sounds like begging to be exploited :\
04:49:40 <merijn> Is there a way to text search Hackage docs? i.e. not just type signatures...
04:55:10 <J> Hi
04:55:32 <Guest47528> Hi
04:55:47 <acube> merijn: I think the hackage search does that
04:56:38 <acube> merijn: http://hackage.haskell.org/packages/archive/pkg-list.html there is a search box
04:59:39 <Guest47528> Does anybody konw how to define a dual type in GADT?
04:59:54 <merijn> Guest47528: What do you mean by "dual type"?
05:00:01 <Guest47528> Both Int and Bool
05:00:44 <merijn> What does "both" mean here?
05:01:37 <dario> something like C union i'd suspect
05:03:02 <merijn> "data MyGadt where MyBool :: Bool -> MyGadt; MyInt :: Int -> MyGadt"
05:03:54 <Guest47528> Well, the unsafe type def is like: data Term = Con Val
05:04:05 <Guest47528> and Val is a data Val either Int or Bool
05:04:34 <no-n> @src (++)
05:04:34 <lambdabot> []     ++ ys = ys
05:04:34 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
05:04:34 <lambdabot> -- OR
05:04:34 <lambdabot> xs ++ ys = foldr (:) ys xs
05:07:30 <merijn> "data Val a where Val :: a -> Val a"?
05:07:35 <Guest47528> But doesn't that work with any other types? I'd like it to be restricted to only Int and Bool
05:09:07 <merijn> "data Val a where ValInt :: Int -> Val Int; ValBool :: Bool -> Val Bool"
05:09:32 <merijn> Doesn't the GADT wikibook show exactly this example?
05:14:08 * hackagebot tianbar 0.1.1.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.1.1.0 (AlexeyKotlyarov)
05:14:10 * hackagebot tianbar 0.1.2.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.1.2.0 (AlexeyKotlyarov)
05:15:30 <Guest47528> I have already have the Val GADT, but I was wondering how to access the Int and Bool specifically in another GADT which has the other defs like And, Or, Add etc
05:31:08 <acube> @ty (>>=) `asAppliedTo` id
05:31:15 <lambdabot> (a -> a) -> (a -> a -> b) -> a -> b
05:32:28 <Eelis> @src asAppliedTo
05:32:28 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
05:32:38 <merijn> I think asAppliedTo is just const
05:33:13 <merijn> With a funky type
05:33:30 <Eelis> intriguing name
05:39:17 <Eelis> merijn: no wait, it wouldn't have that type if it was just const
05:39:19 <Eelis> @ty (>>=) `const` id
05:39:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:40:06 <Eelis> oh, it's an instance of it
05:40:33 <gadtnoob> ?
05:46:34 <acube> asAppliedTo is const with a restricted type
05:46:56 <acube> :t asAppliedTo
05:46:59 <lambdabot> (t -> b) -> t -> t -> b
05:47:36 <acube> > (asAppliedTo (+3) undefined) 4
05:47:42 <lambdabot>   mueval: ExitFailure 1
05:47:42 <lambdabot>  mueval: Prelude.undefined
05:47:55 <acube> > (asAppliedTo (+3) 10) 4
05:48:01 <lambdabot>   mueval: ExitFailure 1
05:48:01 <lambdabot>  mueval: Prelude.undefined
05:48:05 <acube> :O
05:48:23 <acube> it is just undefined with a restricted type
05:48:30 <Fuuzetsu-> > 1
05:48:32 <lambdabot>   1
05:48:43 <acube> > 1 2 3 4
05:48:46 <lambdabot>   1
05:49:24 <Botje> eek! a cross!
05:58:54 <hpaste_> DMcGill pasted “Problems when building hmatrix with msys” at http://hpaste.org/87812
05:59:18 <DMcGill> I'm pretty sure it's the space in my windows username that's causing the problem
05:59:51 <DMcGill> is there a way to specify the temp folder?
06:01:03 <patrikf> I'd try TMPDIR
06:03:17 <gadtnoob> How do you turn this "data Term = Con Val | And Term Term | ... | Plus Term Term" into a GADT where Val is either Int or Bool?
06:03:41 <gadtnoob> Specifically, defining Con Val
06:04:04 <DMcGill> data Term where ConI :: Int -> Term
06:04:07 <DMcGill> and so on
06:04:19 <DMcGill> or data Term where Con :: Either Int Bool -> Term
06:05:13 <DMcGill> patrikf: that worked, thanks
06:06:11 <DMcGill> gadtnoob: you couldn't have `Con :: Int -> Term' and `Con :: Bool -> Term' at the same time
06:06:54 <DMcGill> it might be worth parametising the Term itself
06:07:54 <DMcGill> data Term a where Con :: a -> Term; And :: Term Bool -> Term Bool -> Term Bool; Plus :: Term Int -> Term Int -> Term Int
06:08:00 <DMcGill> it all depends on how exactly you want it to work
06:12:05 <gadtnoob> Thanks. But I have an error with this "Con :: a -> Term"
06:12:06 <FreeFull> You surely mean   a -> Term a
06:12:20 <DMcGill> I do, yes
06:12:20 <shelf> hello gadtnoob are you a 3141 student?
06:12:22 <gadtnoob> Yeup
06:12:23 <shelf> you have 49 minutes to finish that task lol
06:12:23 <gadtnoob> It's been bugging me the whole weekend haha
06:12:32 <shelf> while i'm not sure my solution is correct, I allowed any value to be used with the Con constructor
06:12:46 <shelf> and then i used a typeclass to prevent things other than Int or Bool from being eval'd
06:13:36 <DMcGill> if you do my suggestion, then you can have constants of any type but can only use operations when they typecheck
06:13:53 <DMcGill> after all, eval (Con "str") should be fine
06:13:59 <DMcGill> eval :: Term a -> a or something
06:14:24 <DMcGill> but then I don't know what your assignment actually is
06:14:44 <shelf> it's a finite domain solver over Int and Bool, just enumerating solutions to simple formuals
06:17:24 <DMcGill> if you really want to exclude other values, you could do `Con :: Valid a => a -> Term a'
06:17:50 <DMcGill> the type class on the constructors means that you fail `earlier' than waiting until calling eval
06:17:56 <shelf> yeah. as we cant change the Formula data definition that causes errors later on
06:17:59 <DMcGill> doesn't make that much difference tbh
06:18:08 <shelf> i think it's safe to have Con :: a -> Term a
06:18:32 <DMcGill> it lets you construct invalid values though
06:18:54 <DMcGill> like I said, little difference for this simple example
06:19:00 <shelf> yeah, but they can't be evaluated and any formula containing them will fail typecheck
06:19:10 * hackagebot shake 0.10.3 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.10.3 (NeilMitchell)
06:19:27 <shelf> at least they were failing for me, i'm on the same level as gadtnoob :>
06:20:14 <DMcGill> I just think it's bad practice in general because it pushes the type errors to trying to use the invalid values, not when creating them
06:22:02 <shelf> i agree
06:23:13 <shelf> it's nice that this channel doesn't have a problem with the discussion of homework
06:23:34 <Botje> I don't think any channel does, as long as it's not "solve it for me" :)
06:23:38 <DMcGill> doesn't #python still have "NO PROJECT EULER" in its topic?
06:23:39 <gadtnoob> ^
06:23:52 <hpc> Botje: you underestimate the ability for people on irc to be unreasonable
06:23:57 <shelf> ^
06:24:14 <shelf> i did see a fellow post this entire homework task on SO
06:24:18 <shelf> and ask for a solution
06:25:16 <jermey> testing
06:25:54 <jermey> anyone here? (checking my connection)
06:26:11 <Fuuzetsu-> Yes.
06:26:24 <Fuuzetsu-> You could just use /ping
06:26:32 <jermey> oh right i could have
06:26:35 <jermey> that was stupid of me
06:36:06 <merijn> To be fair, Project Euler gets a significant amount of hate here too
06:36:09 <merijn> And with good reason
06:37:14 <Fuuzetsu-> I think it's a neat way to exercise yourself
06:38:13 <hpc> here though, the hate it gets isn't "too many people ask questions about it so we just blanket ban"
06:38:31 <hpc> it's the more pertinent issue that it doesn't really teach anything besides number theory
06:38:47 <Fuuzetsu-> I think it's more of ‘I bet I could write it in a more concise way’.
06:39:13 <merijn> Fuuzetsu-: Oh, sure, it's ok for practicing code golfing, but that's different from learning exercises
06:39:26 <elliott> hpc: or sometimes brute-forcing.
06:39:36 <elliott> (sure, you're not meant to. people do)
06:40:28 <hpc> elliott: the site supports brute-forcing for problems that have a small enough problem-space
06:40:57 <hpc> there's a reason they use combinatorially ridiculous numbers in their problems
06:40:58 <Fuuzetsu-> Like the first 10.
06:41:08 <Rembane> o
06:41:59 <DMcGill> setup.exe: The program pkg-config version >=0.9.0 is required but it could not be found.
06:42:10 <DMcGill> is that immediately indicative of something?
06:42:25 <DMcGill> trying to install hsfml currently
06:42:38 <Fuuzetsu-> it's indicative of the fact that the program pkg-config version >=0.9.0 is required but it
06:42:39 <Fuuzetsu->           could not be found.
06:44:14 <klrr> why do i get this type error? http://hpaste.org/87813
06:45:09 <merijn> klrr: Which type error?
06:45:11 <merijn> oh, my bad
06:45:12 <merijn> Underneath the hlint gunk :)
06:45:12 <geekosaur> shouldn't pkg-config come with mingw?
06:46:06 <absence> reading about category theory, and it says a monoid is a category with a single object, where the arrows are the elements of the monoid and the identity arrow is the unit element. do all these arrows point "out" of the particular monoid category and into another? there is only one object, and pointing back to itself would make it an identity arrow, right?
06:47:08 <merijn> klrr: The do in main is an IO block getArgs/getContents are IO actions to, so that's fine, but liftErrorOr is IOErrorOr
06:47:49 <merijn> klrr: So line 20 is wrong, as you're trying to use an IOErrorOr value inside a do block for IO
06:48:37 <merijn> klrr: The solution is to use some sort of "runIOErrorOr :: IOErrorOr a -> IO ?" function
06:49:04 <merijn> oh, runIOErrorOr is exactly what it's called :)
06:49:49 <merijn> Which incidentally, is exactly what the error says
06:50:23 <merijn> line 20 of Main.hs "expected type IO something, found IOErrorOr something" in the expression "(liftErrorOr $ readExprFile str)"
06:51:24 <merijn> klrr: Why not write it as "_ <- readExprFile str >>= interpret env"? It seems like that should be correct...
06:52:41 <jermey> hey guys
06:52:41 <jermey> satisfiable (Forall vs p) = any (satisfiable . p . Con) vs
06:52:48 <jermey> what is any doing?
06:53:21 <merijn> :t any
06:53:24 <lambdabot> (a -> Bool) -> [a] -> Bool
06:53:24 <Botje> checks if any element of vs satisfies the predicate
06:53:57 <Fuuzetsu-> Return True if f applied to any of the elements is True
06:54:16 <Fuuzetsu-> > any (\x -> x == 2) [1 .. 10]
06:54:20 <lambdabot>   True
06:56:29 <FreeFull> any is a fold with ||
06:56:31 <FreeFull> :t (||)
06:56:35 <lambdabot> Bool -> Bool -> Bool
06:56:41 <FreeFull> Actually, no, wait
06:56:50 <FreeFull> This any is a map and then a fold with (||)
06:57:25 <quchen> any p = and . map p = foldr True (&&) . map p
06:57:36 <quchen> Eh, that was "all".
06:57:48 <quchen> Any is that with ||, yes.
06:58:35 <johanneslippmann> any (\x -> x == 20000) [1 .. 10]
06:58:49 <johanneslippmann> > any (\x -> x == 20000) [1 .. 10]
06:58:51 <Fuuzetsu-> @src any
06:58:51 <lambdabot> any p =  or . map p
06:58:54 <lambdabot>   mueval: ExitFailure 1
06:58:54 <lambdabot>  mueval: Prelude.undefined
06:59:02 <johanneslippmann> > any (\x -> x == 2000) [1 .. 10]
06:59:07 <lambdabot>   mueval: ExitFailure 1
06:59:07 <lambdabot>  mueval: Prelude.undefined
06:59:21 <johanneslippmann> Hmm, I had thought so.
06:59:27 <johanneslippmann> > any (\x -> x == 20) [1 .. 10]
06:59:32 <lambdabot>   False
06:59:44 <johanneslippmann> > any (\x -> x == 2000) [1 .. ]
06:59:46 <Fuuzetsu-> There's something really wrong with lambdabot recently…
06:59:46 <lambdabot>   True
07:00:09 <Fuuzetsu-> > any (== 200000000) [1]
07:00:14 <lambdabot>   mueval: ExitFailure 1
07:00:15 <lambdabot>  mueval: Prelude.undefined
07:00:31 <Fuuzetsu-> > any (== 200000000) []
07:00:36 <lambdabot>   mueval: ExitFailure 1
07:00:36 <lambdabot>  mueval: Prelude.undefined
07:04:11 <libre> I'm trying to make "sum2lists[][]=[];sum2lists(h:t)(h1:t1)=h+h1:sum2lists t t1" return Nothing if the lists have different lengths, I need to make a wrapper to ":"?
07:06:24 <merijn> libre: You need a new Nothing case when the lists don't match and you need to make the existing functions return values wrapped in Just
07:07:50 <klrr> merijn: if i do so i get this error: Couldn't match expected type `IO a0'
07:07:50 <klrr>                 with actual type `ErrorOr [Expr]'
07:07:50 <klrr>     In the return type of a call of `readExprFile'
07:07:50 <klrr>     In the first argument of `(>>=)', namely `readExprFile str'
07:07:51 <klrr>     In a stmt of a 'do' block: _ <- readExprFile str >>= interpret env
07:08:29 <merijn> ah
07:08:43 <merijn> I didn't check the type of readExprFile, to be honest
07:09:03 <libre> merijn: yes, I tried that: "sum2lists[][]=Just[];sum2lists(h:t)(h1:t1)=Just(h+h1:sum2lists t t1);sum2lists__=Nothing", but ":" wants "[a]", not "Maybe [b]" the error says
07:09:16 <merijn> Sounds like you want "runIOErrorOr" wrapping the readExprFile
07:09:26 <merijn> libre: fmap to the rescue!
07:09:29 <merijn> :t fmap
07:09:31 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:09:37 <merijn> :t fmap (1:)
07:09:39 <lambdabot> (Functor f, Num a) => f [a] -> f [a]
07:09:56 <merijn> :t fmap ('a':) `asAppliedTo` Just ""
07:10:02 <lambdabot> Maybe [Char] -> Maybe [Char]
07:11:00 <merijn> In other words, in your example "(h+h1 :) `fmap` sum2lists t t1"
07:11:48 <merijn> > fmap ('a':) (Just "")
07:11:52 <lambdabot>   Just "a"
07:12:25 <klrr> merijn: use runIOErrorOr? runIOErrorOr is black magic from a tutorial actually :x
07:14:47 <libre> merijn: helium can't handle that, I'll try hugs
07:17:06 <geekosaur> any reason you're not using ghc? I think helium and hugs are both unsupported and a bit dated
07:17:51 <Fuuzetsu-> Funny idea of ‘a bit’ you have there.
07:18:15 <libre> geekosaur: I have a live usb, space is scarce
07:18:16 <klrr> haskell is a lips dialect
07:19:55 <merijn> klrr: runIOErrorOr is something that's converting IOErrorOr values into IO values, which is what you need there :p
07:20:21 <merijn> klrr: You'd be surprised how many people's problems I've managed to fix without understanding their code, just by looking at the types like here :p
07:20:29 <jmcarthur> klrr: "haskell is a lips dialect" wut?
07:20:42 <jmcarthur> it most certainly is not
07:20:54 <merijn> libre: Yeah, hugs is becoming increasingly out-of-date, I haven't heared ot helium before
07:20:55 <klrr> jmcarthur: it's true a phd student in CS just told me
07:21:02 <merijn> klrr: ...
07:21:03 <hpc> i am struggling to come with a pun for that sentence
07:21:11 <jmcarthur> that phd student is wrong then
07:21:19 <klrr> merijn: okey :D
07:21:51 <libre> klrr: pattern matching is from prolog
07:21:51 <merijn> klrr: I'd claim I'm a phd student too, but so far no one's funding me. Regardless that other guy is still wrong :>
07:21:57 <jmcarthur> they may have meant "haskell is a functional language like lisp" but even that is pretty unclear
07:22:05 <geekosaur> merijn, helium is an ancient, limited teaching not-quite-haskell
07:22:29 <Fuuzetsu-> It's probably a reference to that horrible post on some Google group about Haskell being invented my McCarthy
07:23:10 <klrr> merijn: well both is based on lambda calculus, plus you can basically write haskell with lisp syntax
07:23:26 <Fuuzetsu-> …which I can't find now
07:23:28 <klrr> im new to programming dont hit me i know nothing :P
07:24:56 <absence> lisp syntax, huh?
07:24:57 <merijn> klrr: Yeah, that's just a variation of the age-old joke:
07:24:58 <merijn> @quote sufficiently.well.commented
07:24:59 <lambdabot> MartinDeMello says: Any sufficiently well-commented Lisp program contains an ML program in its comments.
07:25:11 <absence> haha
07:25:11 <libre> klrr: the syntax is mainly from some old languages I don't remember the name
07:26:12 <merijn> libre: Anyway, I'd really recommend trying to get ghc+ghci, it'll be much nicer than hugs
07:28:23 <jmcarthur> klrr: haskell syntax is not lisp syntax. also, saying one is a dialect of the other because they are both "based on" the lambda calculus, whatever that means, is like saying x86 assembly and ruby are related because they are both "based on" the von neumann architecture
07:28:50 <jmcarthur> err, rather, it's like saying that ruby is a dialect of x86 assembly
07:29:07 <klrr> jmcarthur: not really but okey :P
07:29:19 <jmcarthur> i think my analogy is a little more extreme than i intended
07:29:52 <madjestic> [5..1]
07:29:58 <hpc> i think we all know that ruby is a dialect of python, and python is a dialect of the one true language: python2.4
07:30:47 <madjestic> I don't quite understand why [1..5] prdocues an ordered set, while [5..1] returns an empty set.  [5,4..1], on the other hand, works fine
07:31:05 <Fuuzetsu-> madjestic: I swear that this is the billionth time someone asked this…
07:31:12 <jmcarthur> python is a dialect of haskell in that haskell was one of its weaker influences :P
07:31:33 <acube> madjestic:  [5..1] is equavilent to [5,6..1]
07:31:41 <jmcarthur> (i guess list comprehensions is the only thing directly borrowed from haskell?)
07:31:47 <hpc> madjestic: to abuse imperative syntax a bit, it's the same as
07:31:59 <madjestic> Fuuzetsu-: sorry, I did not know about that (you probably heard that excuse 10^9 times before as well)
07:32:00 <hpc> madjestic: for (int i = 5; i <= 1; i++)
07:32:05 <acube> and counting from 5 upwards till one reaches 1 is an empty list, because 1 is already hit when we start
07:32:29 <jmcarthur> @src enumFromTo
07:32:30 <lambdabot> Source not found. Maybe if you used more than just two fingers...
07:32:53 <acube> @src enumFromToStep
07:32:54 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:33:00 <quchen> jmcarthur: enumFromTo is a function of the Enum typeclass. It doesn't have "a" definition.
07:33:02 <madjestic> interesting.  Thanks guys.  Should be in FAQ somewhere?
07:33:06 <geekosaur> enumFromThenTo
07:33:17 <acube> @src enumFromThenTo
07:33:17 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
07:33:32 <acube> ah /me didn't notice what quchen said
07:33:32 <geekosaur> but not in @src which is a pretty crappy database
07:33:36 <Eduard_Munteanu> @src Int enumFromThenTo
07:33:37 <lambdabot> Source not found. You untyped fool!
07:33:37 <Fuuzetsu> damn ZNC
07:33:39 <geekosaur> @index enumFromThenTo
07:33:39 <Fuuzetsu> I swear
07:33:39 <lambdabot> Prelude
07:34:11 <acube> @src enumFromThenTo Int
07:34:11 <lambdabot> Source not found. My brain just exploded
07:34:19 <jmcarthur> quchen: yeah i'm aware of that. i just wasn't thinking
07:34:29 <jmcarthur> @src Int enumFromTo
07:34:30 <lambdabot> Source not found. That's something I cannot allow to happen.
07:34:40 <jmcarthur> that used to work, but i've not seen it work in a long time now
07:34:43 <jmcarthur> @src enumFromTo Int
07:34:44 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:34:50 <acube> @src Integer enumFromThenTo
07:34:50 <lambdabot> Source not found. My brain just exploded
07:34:53 <acube> :(
07:34:53 <Eduard_Munteanu> @src Maybe (>>=)
07:34:53 <lambdabot> (Just x) >>= k      = k x
07:34:54 <lambdabot> Nothing  >>= _      = Nothing
07:34:59 <Eduard_Munteanu> So that should do.
07:35:00 <jmcarthur> yay!
07:36:07 <Eduard_Munteanu> @src Bool enumFromThenTo
07:36:07 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
07:36:12 <Eduard_Munteanu> Oh, well.
07:36:24 <acube> > [False,False..True]
07:36:26 <lambdabot>   A section must be enclosed in parentheses thus: (False.. True)Not in scope:...
07:36:41 <hpc> > [False, False .. True]
07:36:45 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
07:36:49 <acube> Why is this?
07:37:02 <Eduard_Munteanu> acube: the step is 0
07:37:03 <jmcarthur> acube: False. could indicate a module prefix
07:37:13 <Eduard_Munteanu> [1,1..5]
07:37:17 <Eduard_Munteanu> > [1,1..5]
07:37:17 <acube> > [False,False ..True]
07:37:20 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:37:20 <lambdabot>   can't find file: L.hs
07:37:23 <acube> > [False,False ..True]
07:37:29 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
07:37:34 <acube> jmcarthur: that's silly
07:37:39 <jmcarthur> not it's not
07:37:49 <jmcarthur> :t [Prelude..]
07:37:53 <lambdabot> parse error on input `]'
07:37:57 <jmcarthur> ah i need parens
07:38:03 <burp> how does a program compiled with -threaded and run with -N1 compare with a non-threaded version?
07:38:06 <jmcarthur> :t [Prelude.."foo"]
07:38:09 <lambdabot>     A section must be enclosed in parentheses thus: (Prelude.. "foo")
07:38:22 <jmcarthur> huh, didn't occur to me that [] can't be used for section syntax
07:38:28 <hpc> burp: it should be very minor
07:38:36 <burp> in my case the non-threaded version runs 50% faster
07:38:37 <klrr> haskell should be untyped
07:38:43 <hpc> indistinguishable with scheduling noise from other programs on the same box
07:38:46 <jmcarthur> klrr: now i know you're trolling
07:39:06 <burp> hpc: yea, I thought the same
07:39:14 <jmcarthur> burp: it depends on the program
07:39:45 <burp> what is changed specifically with threaded N1 towards non-threaded?
07:40:09 <hpc> the threaded runtime is linked in instead of the non-threaded
07:40:21 <Eduard_Munteanu> The synchronization primitives could be reduced to a check.
07:40:27 <hpc> and.... i think that's it unless you do any real multi-threading
07:40:39 <jmcarthur> burp: for one, thunk entry is pretty different between the two, iirc
07:40:52 <klrr> jmcarthur: i get type errors all the time and its annoying :x
07:40:52 <Eduard_Munteanu> I think he means the runtime RTS option?
07:41:01 <burp> yea, runtime -N
07:41:15 <Eduard_Munteanu> Oh, vs without -threaded at compile-time, hm.
07:41:19 <jmcarthur> klrr: that means your code is wrong. would it really be less annoying for it to just run incorrectly, potentially without you realizing?
07:41:33 <Eduard_Munteanu> Well, even better then, synchronization could be completely removed quite easily, I suspect.
07:42:05 <Eduard_Munteanu> I wonder if DiffArray got "optimized" for that usecase.
07:42:17 <Eduard_Munteanu> It performs pretty badly due to synchronization.
07:42:34 <jmcarthur> burp: another difference is the way safe FFI calls are handled
07:43:07 <jmcarthur> burp: in the threaded runtime, a safe FFI call runs in its own os thread. that way it doesn't interfere with other haskell threads
07:43:19 <jmcarthur> where by interfere i mean block
07:43:25 <libre> klrr: you can try guile
07:44:00 <jmcarthur> klrr: if you really want a less typeful haskell and are using a recent ghc, you can use -fdefer-type-errors
07:44:24 <jmcarthur> klrr: this turns all errors into warnings and allows you to run the parts of your code that are well typed without having to fix the other parts yet
07:44:31 <elliott> klrr: type errors are there whether you acknowledge them or not.
07:44:46 <elliott> your code will break just the same if you bypass them or use a language which doesn't show you them at all
07:44:50 <jmcarthur> klrr: and if you happen to run a bit of code that didn't actually type check it's a runtime error
07:45:21 <jmcarthur> klrr: but really, if you have type errors your code is just wrong
07:47:03 * geekosaur wonders how exatcly "don't tell me my code is wrong" is an improvement
07:47:40 <hpc> geekosaur: imagine all the poorly-typed programs you can write that actually work!
07:47:46 <elliott> geekosaur: people hate being told they're wrong
07:47:59 <klrr> jmcarthur: then i hate myself for not writing correct code
07:48:00 * geekosaur is a perl programmer, knows all about that, thanks :p
07:48:01 <elliott> whether it's in attempt to help them or not. #haskell logs provide extensive evidence :P
07:48:20 <hpc> man, perl would be the best damn language if it had a type system
07:48:54 <hpc> between regexes and the amazing array/hash/list relationship
07:50:02 <arnsholt> Perl 6 actually has a type system =)
07:50:03 <hpc> i have not yet tried perl6
07:50:13 <arnsholt> Not quite Haskell-levels of types, but more types than your garden-variety scripting language
07:51:43 <libre> merijn: ghci complains too: "Non-exhaustive patterns in function"
07:53:33 <libre> merijn: it's syntax, solved, thanks
07:55:56 <jmcarthur> klrr: why? you're still learning
08:04:40 <vexy> > sequence $ [randomRIO (1,6) | x <- [1..5]]
08:04:46 <lambdabot>   mueval: ExitFailure 1
08:04:46 <lambdabot>  mueval: Prelude.undefined
08:05:03 <vexy> is there a nicer way to do this? perhaps without list comprehensions
08:05:49 <danr> vexy: use replicateM
08:06:15 <vexy> nice
08:09:36 <vexy> is there a similar elegant one-liner that would to the same with randomR instead of randomRIO ?
08:09:47 <hpc> :t randomR
08:09:50 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
08:09:51 <hpc> :t randomRIO
08:09:51 <latermuse> i was jerking around in perl today. it makes me sad
08:09:58 <lambdabot> Random a => (a, a) -> IO a
08:10:02 <ion> @type replicateM 6 (state . randomR (1,6))
08:10:03 <latermuse> woah im way late to convo. disregard everything
08:10:05 <hpc> vexy: i expect StateT to make an appearance
08:10:07 <lambdabot>     Couldn't match expected type `s0 -> (a0, s0)'
08:10:07 <lambdabot>                 with actual type `(a2, a1)'
08:10:07 <lambdabot>     Expected type: a1 -> s0 -> (a0, s0)
08:10:30 <ion> @type replicateM 6 (state (randomR (1,6)))
08:10:37 <lambdabot> (Num a, MonadState s m, RandomGen s, Random a) => m [a]
08:11:01 <ion> @type runState . replicateM 6 . state . randomR $ (1,6)
08:11:10 <lambdabot> (Num a, RandomGen s, Random a) => s -> ([a], s)
08:11:11 <luite> vexy: also check the monadrandom package for a monad that wraps a random generator
08:16:03 <phaul>  HexChat: 2.9.5 ** OS: Linux 3.8.11-1-ARCH i686 ** Distro: ArchLinux ** CPU: 2 x Inte(R) Core(TMM)2 Duo CPU     T5550  @ 1.83GHz (GenuineIntel) @ 1000MHz ** RAM: Physical: 2.0GB, 79.7% free ** Disk: Total: 107.8GB, 16.3% free ** VGA: Intel Corporation Mobile GM965/GL960 Integrated Graphics Controller ** Sound: HDA-Intel - HDA Intel ** Ethernet: Marvell Technology Group Ltd. 88E8
08:16:04 <phaul> 040 PCI-E Fast Ethernet Controller ** Uptime: 19h 8m 7s **
08:17:00 <Botje> those things still exist?
08:17:25 <libre> merijn: with helium and hugs don't work, with ghci it works, thanks
08:17:31 <elliott> phaul: uh, don't do that :P
08:17:46 <phaul> it was a stupid mistake :)
08:19:15 <elliott> no worries :)
08:20:27 <merijn> libre: \o/
08:28:10 <vexy_> MonadRandom is nice
08:31:54 <mr-> Suppose you are searching in a big tree, is there a clever way to "free/delete" the part that has been searched already?
08:34:19 * hackagebot hlint 1.8.45 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.45 (NeilMitchell)
08:35:27 <Fuuzetsu> …and I _just_ installed 1.8.44 hlint…
08:35:30 <monochrom> yes. just lose all aliases to the parts you want to free
08:39:07 <keith_> Hi, I have a do block that looks like this: parseDescription x = do
08:39:08 <keith_>         putStr "test"
08:39:08 <keith_>         return $ Description [testClass] [testAccess] but it seems to be trying to return the value of the putStr (i.e. IO()) rather than what I want it to return. I though the do block always returned the value of the last line...Am I missing something?
08:39:35 <shachaf> keith_: Maybe you're missing compiling your code, or checking the type of the right function.
08:39:53 <shachaf> The typee of that whole thing should be IO Whatever.
08:40:21 <keith_> Why is that shachaf? If I remove the putStr then it works.
08:41:04 <shachaf> Pleease paste your full code and full error message.
08:41:36 <shachaf> You're not giving enough information for people to help you. The problem is not where you think it is.
08:41:45 <shachaf> Also, something is wrong with my e key.
08:42:27 <keith_> I can't paste the whole code. It's spread across too many files. But this is the error:     Couldn't match expected type `GenParser Char (AnnoState st) a0'
08:42:27 <keith_>                 with actual type `IO ()'
08:42:27 <keith_>     In the return type of a call of `putStr'
08:42:27 <keith_>     In a stmt of a 'do' block: putStr "test"
08:42:27 <keith_>     In the expression:
08:42:29 <keith_>       do { putStr "test";
08:42:31 <keith_>            return $ Description [testClass] [testAccess] }
08:43:05 <shachaf> Please use hpaste.org when you have more than a couple of lines of code to paste.
08:43:07 <simpson> Ah. You're trying to mix monads.
08:43:23 <shachaf> s/of code //
08:43:24 <simpson> I think that you're trying to print some debugging information.
08:43:30 <keith_> Yes :)
08:43:36 <simpson> Consider Debug.Trace for this kind of work.
08:43:40 <keith_> I did!
08:43:51 <Taneb> :t liftM mconcat . sequence
08:43:54 <lambdabot> (Monad m, Monoid r) => [m r] -> m r
08:44:04 <simpson> And trace wasn't sufficient for you?
08:44:13 <keith_> No, I will paste the error it gives.
08:44:26 <Taneb> :t fmap mconcat . sequenceA
08:44:29 <lambdabot>     Not in scope: `sequenceA'
08:44:29 <lambdabot>     Perhaps you meant one of these:
08:44:29 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
08:44:36 <Taneb> :t fmap mconcat . Data.Traversable.sequenceA
08:44:40 <lambdabot> (Applicative f, Monoid b) => [f b] -> f b
08:44:42 <hpaste_> Keith pasted “Keith” at http://hpaste.org/87822
08:45:00 <Fuuzetsu> That's not how you use trace
08:45:33 <Fuuzetsu> http://www.haskell.org/haskellwiki/Debugging http://www.haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html
08:45:49 <simpson> keith_: trace's type is String -> a -> a. It prints the string and then returns its second argument.
08:45:53 <mr-> monochrom: I.e. just create a new tree without the unnecessary stuff?
08:46:17 <simpson> keith_: So you have to provide it with that second argument. This is so that you can know exactly when it's being evaluated, and also so that it won't get optimized away.
08:46:17 <monochrom> no need to even create. just lose.
08:46:46 <mr-> monochrom: what does that mean? ;-)
08:47:02 <keith_> Okay thank you, I will look at the documentation and modify my code.
08:47:19 <monochrom> it means nothing references the things you want freed
08:48:07 <monochrom> do you know garbage collection?
08:48:36 <mr-> monochrom: how would that happen without creating another tree? The root is always going to stay (thus referencing the rest of the tree)
08:49:45 <monochrom> I see. then create a new root to not have some children. sure.
08:50:28 <monochrom> (on this Mother's Day I dare not say "unwanted children"! what a disgusting idea...)
08:51:19 <Fuuzetsu> No children are unwanted. Some of them are simply… no longer needed.
08:51:40 <mr-> monochrom: Ok, thanks
08:51:52 <Apollonius_Perga> Hi, I'm working on a library for elliptic curve cryptography. I have a bunch of functions for doing operations (addition, scalar multiplication, linear combination) on points on an elliptic curve whose type signatures all start with "Curve ->", like "ptAdd :: Curve -> Point -> Point -> Point". Would this be a good use of the Reader monad, in order to kind of suppress having to write the Curve?
08:51:59 <monochrom> don't forget to lose the old root!
08:52:14 <mr-> I will never forget my roots
08:52:22 <ion> bloody ruuts
08:52:24 <ion> oots
08:53:02 <Fuuzetsu> Apollonius_Perga: but then your functions become Reader Curve -> …
08:54:00 <Fuuzetsu> (or whatever the signature would be)
08:54:57 <Apollonius_Perga> Like right now, I define pointMul like so:
08:54:58 <Apollonius_Perga> pointMul :: Curve -> Integer -> Point -> Point pointMul _ _ Infinity = Infinity pointMul curve k pt  | k == 0 = Infinity  | odd k  = pt .+ ((k-1) .* pt)  | even k = let half = (k `div` 2) .* pt             in half .+ half  where (.+) = pointAdd curve        (.*) = pointMul curve
08:55:11 <Apollonius_Perga> ugg...i donno how to copy and paste into irc :-/
08:55:20 <Fuuzetsu> Apollonius_Perga: use hpaste.org
08:55:22 <geekosaur> you don't, mostly
08:55:23 <geekosaur> @paste
08:55:24 <lambdabot> Haskell pastebin: http://hpaste.org/
08:55:27 <Apollonius_Perga> https://github.com/echatav/elliptic/blob/master/Elliptic.hs
08:56:10 <hpaste_> “Apollonius of Perga” pasted “pointMul” at http://hpaste.org/87823
08:56:19 <Apollonius_Perga> http://hpaste.org/87823
08:56:21 <Apollonius_Perga> thanks
08:56:41 <Apollonius_Perga> is this an elegant way to handle it...with the where clause? or would using Reader make sense?
09:08:17 <jdoles> My cabal is sad: http://paste.kde.org/742160/
09:09:41 <dcoutts__> jdoles: you have a better chance if you use --reorder-goals --max-backjumps=-1
09:09:52 <no-n> what is Infinity?
09:10:23 <Fuuzetsu> data Point = Point Integer Integer | Infinity deriving Show
09:10:31 <dcoutts__> jdoles: but it may be that it's impossible to install all your current world packages consistently
09:10:50 <no-n> oh, I mean the Infinity you get in ghc
09:10:55 <no-n> > 5/0
09:11:00 <Fuuzetsu> oh
09:11:01 <lambdabot>   mueval: ExitFailure 1
09:11:01 <lambdabot>  mueval: Prelude.undefined
09:11:05 <dcoutts__> > 1/0 :: Float
09:11:10 <lambdabot>   Infinity
09:11:25 <no-n> > Infinity
09:11:29 <lambdabot>   Not in scope: data constructor `Infinity'
09:11:51 <jdoles> dcoutts__: and how would a complete clean install look like? rm -rf ~/.cabal and ?
09:12:00 <no-n> how does it get to be a value but not a value? I guess it's just a string being printed.
09:12:27 <dcoutts__> jdoles: yes, you can do that. Did it not work with those flags?
09:12:55 <Fuuzetsu> no-n: It's just the IEEE infinity representation I believe
09:13:14 <dcoutts__> jdoles: the issue is that cabal does not enforce that all your packages have consistent deps, but if you ask for --reinstall world then it's trying to find a solution that does have consistent deps, and so that may not be possible,
09:13:27 <Fuuzetsu> formatRealFloat fmt decs x
09:13:28 <Fuuzetsu>    | isNaN x                   = "NaN"
09:13:28 <Fuuzetsu>    | isInfinite x              = if x < 0 then "-Infinity" else "Infinity"
09:13:30 <no-n> IEEE?
09:13:48 <Fuuzetsu> http://en.wikipedia.org/wiki/IEEE_floating_point
09:14:03 <no-n> okay
09:14:04 <jdoles> dcoutts__: no, http://paste.kde.org/742208/
09:14:21 <no-n> well, bedtime for me :>
09:14:25 <dcoutts__> jdoles: sorry, to be clear: cabal enforces that when you install a set of packages that they use consistent deps, but it doesn't enforce that everything you have in your package environment has consistent deps.
09:14:40 <Apollonius_Perga> Fuuzetsu: Infinity means the point at infinity...it's the neutral element of an elliptic curve
09:14:57 <Fuuzetsu> Apollonius_Perga: read up~
09:15:15 <dcoutts__> jdoles: ah, if your ghc package is broken then it will indeed have trouble, since that package cannot be reinstalled.
09:15:21 <Fuuzetsu> I'm not even the one asking and the question was about the output you get with division by 0 and such.
09:15:59 <Apollonius_Perga> What? Are we talking about my question?
09:16:14 <jdoles> dcoutts__: how can it be broken? It is a package from my distribution.
09:16:20 <pqmodn> CT question time: functors map objects and morphisms from one category to those in another. is there only one category Hask, does a Functor then just map from Set to Set?
09:16:36 <pqmodn> i mean from Hask to Hask, i guess
09:16:38 <dcoutts__> jdoles: ask ghc-pkg check.
09:16:47 <Apollonius_Perga> it has nothing to do with "Infinity"...I was asking more for code review...would it make sense for me to use the Reader monad for my code?
09:17:06 <dcoutts__> jdoles: most likely is that you have a package in your user db that masks one of the global ones.
09:17:22 <jdoles> dcoutts__: there is some list of packages that is broken. How can I purge those?
09:17:37 <Apollonius_Perga> Pqmodn: Yes, in Haskell all "Functor"s are endofunctors on Hask
09:17:40 <dcoutts__> jdoles: ghc-pkg unregister --user ${pkgname}
09:18:00 <pqmodn> Apollonius_Perga: thanks!
09:18:26 <Apollonius_Perga> yw :-)
09:19:03 <Apollonius_Perga> Fuuzetsu: I was not asking about division by 0
09:19:20 <Fuuzetsu> Apollonius_Perga: I know. Someone else was.
09:19:26 <Fuuzetsu> This and that are unrelated.
09:19:31 <Apollonius_Perga> oh...sorry
09:19:32 <Apollonius_Perga> heheh
09:19:41 <Apollonius_Perga> you posted my def of Point
09:19:46 <Apollonius_Perga> I got confused :-)
09:20:08 <Fuuzetsu> Apollonius_Perga: I posted it because that's what I initially thought the person was asking about too.
09:22:06 <magneticduck> what's a good way to get from Doubles to Floats and vice-versa?
09:22:22 <magneticduck> I understand that I'm going to loose information on occasion in Double -> Float
09:22:22 <ion> realToFrac
09:22:24 <magneticduck> ty
09:22:29 <magneticduck> and then fracToReal?
09:22:34 <ion> no
09:22:42 <ion> @type realToFrac
09:22:48 <lambdabot> (Fractional b, Real a) => a -> b
09:22:55 <magneticduck> ah, doubles are fractional
09:22:58 <ion> Both are Fractional and Real.
09:23:02 <magneticduck> aaahhh
09:23:11 <magneticduck> haskell has the most interesting way to deal with numbers...
09:23:16 <magneticduck> ty
09:23:31 <magneticduck> I could also do read . show, come to think of it
09:23:48 <magneticduck> but that would be overkill
09:24:00 <ion> and evil
09:24:29 <jdoles> dcoutts: the same problem, but now ghc-pkg check only outputs warnings.
09:24:53 <magneticduck> ion: yes, morality is also something to have in consideration when dealing with haskell
09:24:57 <magneticduck> =P
09:25:46 <dcoutts> magneticduck: it wouldn't be overkill, it'd be worse in every respect :-)
09:26:58 <magneticduck> overkill, as in it would be doing things that would in the end be redundant
09:27:04 <magneticduck> somewhere during the processing
09:27:08 <dcoutts> jdoles: sorry, I don't have quite enough context. I'm not sure what you're trying to do now exactly.
09:27:18 <Fuuzetsu> Why isn't there a typeclass equivalent to Python's __repr__? Show asks that you can Read it back but we could use Repr as a pretty printing interface.
09:27:46 <Fuuzetsu> The way it is now, you have to write a prettyPrint<Whatever> for everything you want pprinted
09:27:48 <applicative> there is a Pretty class
09:27:52 <Fuuzetsu> Oh?
09:28:03 <jdoles> dcoutts: cabal install --reinstall --enable-shared world --reorder-goals --max-backjumps=-1
09:28:15 <applicative> the result type is Doc, which ghci displays properly
09:28:15 <jdoles> dcoutts: and same output as before.
09:28:31 <dcoutts> jdoles: you mean it still says ghc package is borked, but ghc-pkg check says it isn't?
09:28:33 <applicative> Fuuzetsu: see Text.PrettyPrint
09:28:58 <jdoles> dcoutts: rejecting: ghc-7.4.1/installed-2e8... (package is broken)
09:29:29 <jdoles> dcoutts: I don't know what installed-2e8 means.
09:29:33 <bitonic`> applicative: you mean in wl-pprint?
09:29:50 <Fuuzetsu> That's neat. Thanks!
09:30:02 <dcoutts> jdoles: it's referring to the installed instance (as opposed to the source one) and that's the first few chars from the installed package id hash
09:30:57 <dcoutts> jdoles: and ghc-pkg check says there are no broken packages?
09:31:05 <jdoles> dcoutts: correctamundo.
09:31:21 <Fuuzetsu> :t isFloatInfinite
09:31:27 <lambdabot> Not in scope: `isFloatInfinite'
09:31:44 <Fuuzetsu> Heh. I hate trying to find source of something just to find that it's an FFI call
09:32:24 <jdoles> dcoutts: if you can just tell me the reset button of all of this, that would we swell.
09:32:30 <applicative> bitonic: yeah I take that back, I remembered a Pretty class in the base pretty business, but they just float around
09:32:34 <dcoutts> jdoles: that's probably easier
09:32:45 <dcoutts> jdoles: then the issue is that cabal incorrectly thinks it's broken, because it's looking at local user packages that mask global ones. The ghc package depends on various things, and you probably have some of those registered in your user package db.
09:33:04 <bitonic> applicative: there is no pretty in ‘base’ (there is in the HP)
09:33:11 <bitonic> and there is no Pretty in the HP
09:33:12 <magneticduck> is there any objective reason why multiple declarations of the same function have to have the same number of bonded terms?
09:33:14 <dcoutts> jdoles: when you reinstall things, ask to install them all at once, not one by one.
09:33:26 <jdoles> dcoutts: will do.
09:33:31 <dcoutts> jdoles: ie the "install world" is basically the right approach
09:33:32 <magneticduck> it's terrible. x|
09:33:47 <dcoutts> jdoles: rather than doing install a; install b; install c; ... etc
09:33:52 <jdoles> dcoutts: but what should I remove?
09:34:15 <jdoles> dcoutts: judging by Google, it seems this isn't exactly uncommon.
09:34:35 <dcoutts> jdoles: the drastic approach is to remove ~/.ghc, the less drastic would be to remove just the particular offending packages
09:37:23 <applicative> bitonic: yes thats what I was saying, after saying the opposit
09:37:25 <applicative> e
09:39:02 <bitonic> it should be ehe
09:39:24 * hackagebot yesod-auth 1.2.0.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.2.0.1 (MichaelSnoyman)
09:39:28 * hackagebot yesod-core 1.2.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.1 (MichaelSnoyman)
09:39:35 <applicative> on reflection this is sensible since there would just be ugly conflicts unless; the Doc type was the thing to mention to Fuuzetsu , bitonic
09:40:23 <Fuuzetsu> Well, he did mention Text.PrettyPrint in the end which uses Doc so that kind of counts~
09:40:26 <applicative> man irssi is too hard for me.  There would be lots of conflicts between instances, most likely. But the concrete type and ghci's behavior are good
09:40:45 <applicative> Fuuzetsu: yes, I was misremembering such a class as a base thing
09:41:29 <applicative> but only the Doc type is a base thing...
10:05:02 <magneticduck> maaan, is it just me or does atan2 behave really weirdly
10:05:12 <magneticduck> I'm trying to get a nice angle out of a vector
10:05:17 <magneticduck> from 0 to 2pi
10:05:31 <magneticduck> using gloss to do some testing, and atan2 is behaving erratically
10:05:51 <magneticduck> hmm, might have found the problem
10:07:03 <magneticduck> no, I still have the problem
10:07:14 <magneticduck> where x is close to 0, I get values over wpi
10:07:17 <magneticduck> 2pi*
10:08:39 <magneticduck> :<
10:13:00 <magneticduck> atan2's documentation is a LIE
10:13:14 <magneticduck> > atan2 0.001 1
10:13:18 <lambdabot>   9.999996666668668e-4
10:13:26 <magneticduck> totally not between -pi and pi!
10:13:34 <int-e> ?!
10:13:35 <lambdabot> Maybe you meant: . ? @ v
10:13:40 <geekosaur> 9.9e-4? sure it is
10:13:43 <int-e> that's about 0.0001
10:13:53 <int-e> uhm. 0.001.
10:14:01 <magneticduck> aaaaaahhhh
10:14:15 <magneticduck> aaaaaaaaahhhhh
10:14:17 <Mortomes_> scientific notation: 1 magneticduck: 0
10:14:22 <magneticduck> we meet again, mister scientific notation
10:14:30 <magneticduck> =P
10:14:44 <magneticduck> :|
10:15:00 <magneticduck> I was going by the first few decimals of "show"
10:15:48 <jmcarthur> > atan2 0.001 1 <= pi
10:15:53 <lambdabot>   mueval: ExitFailure 1
10:15:53 <lambdabot>  mueval: Prelude.undefined
10:15:55 <jmcarthur> > atan2 0.001 1 <= pi
10:16:00 <lambdabot>   True
10:16:49 <mauke> > inRange (atan2 0.001 1) (-pi, pi)
10:16:52 <lambdabot>   No instance for (GHC.Float.RealFloat ((t0, t1), (t0, t1)))
10:16:52 <lambdabot>    arising from ...
10:16:54 <mauke> my bad
10:16:57 <magneticduck> turns out my angle cleaning code was a lie
10:20:37 <magneticduck> angles are tricky little devils
10:20:50 <magneticduck> but I'll get 'em eventually
10:21:02 <mauke> rouge angles of satin
10:21:24 <magneticduck> and then, my vector math library will be that much closer to completion
10:21:26 <magneticduck> xD
10:23:23 <hiptobecubic> :t inRange
10:23:27 <lambdabot> Ix a => (a, a) -> a -> Bool
10:23:59 <Alamo777> hello all! Please explain to me what is haskell? In what fields it is being used? Is it c related language?
10:24:15 <mauke> Alamo777: are you doing homework?
10:24:33 <Alamo777> mauke, no in a couple of words
10:24:41 <Fuuzetsu> You should probably just go on Wikipedia for the answers to all these questions and more!
10:24:41 <nimdAHK> lol
10:24:41 <mauke> have you tried the internet?
10:24:54 <Alamo777> mauke, trolling?
10:25:01 <mauke> are you?
10:25:13 <dario> *plonk*
10:25:19 <nimdAHK> if only someone would make a machine to search the entirety of human knowledge in 2 tenths of a second!
10:25:21 <Alamo777> mauke, i ask a simple question regarding this programming language
10:25:25 <magneticduck> Alamo777: WE DO NOT TALK OF THE LANGUAGE CALLED C IN THIS HOUSE
10:25:30 <mauke> Alamo777: yes
10:25:47 <mauke> Alamo777: why are you asking us that question instead of just looking at the haskell website or wikipedia or whatever?
10:25:59 <magneticduck> Alamo777: www.giyf.com
10:26:01 <Alamo777> i like to communicate with people
10:26:19 <nimdAHK> I'll be your human google proxy
10:26:20 <Fuuzetsu> People don't like saying something that's already readily available elsewhere with minimal effort.
10:26:22 <mauke> I don't like being used as a wikipedia proxy
10:26:30 <osfameron> Alamo777: once you've done a *tiny* bit of research and have actual questions, people will be really happy to answer those here
10:26:47 <Alamo777> mauke, well i am not using you, just asking a simple question in this chanel
10:26:48 <jmcarthur> Alamo777: from the web site: Haskell is an advanced purely-functional programming language. An open-source product of more than twenty years of cutting-edge research, it allows rapid development of robust, concise, correct software. With strong support for integration with other languages, built-in concurrency and parallelism, debuggers, profilers, rich libraries and an active community, Haskell makes it
10:26:50 <jmcarthur> easier to produce flexible, maintainable, high-quality software.
10:26:55 <magneticduck> Alamo777: haskell is a typed lambda calculus, interpreted and compiled with GHC, portable to a number of platforms, and capable of doing anything you'd ever a programming language to do
10:26:58 <mauke> Alamo777: what's the difference?
10:27:02 <monochrom> don't answer to answer. just don't answer.
10:27:14 <Fuuzetsu> magneticduck: except dependent typing ;_;
10:27:19 <magneticduck> yeah
10:27:22 <magneticduck> except..that..
10:27:23 <magneticduck> THING
10:27:25 <jmcarthur> i don't really like that as an elevator pitch, but whatever
10:28:17 <magneticduck> srsly tho alamo, www.giyf.com
10:28:57 <magneticduck> feel free to come back when you have awesome questions about this awesome language that aren't answered with a simple search on google
10:29:02 <beefcube> Alamo777: I am using Haskell heavily on the server side at the moment. I try to use it pretty much anywhere that a GUI isn't involved
10:29:37 <magneticduck> technically, haskell has ports to GTK and wxWidgets (not to mention GLUT and the like), but it's kind of annoying to make GUIs
10:29:40 <Alamo777> mauke, so you are the most active and clever here in this channel, but you cant simple say in couple of words what does haskell and in what fields it is used, but sitting here in this channel all day and trolling people, thats not good, channels usually using for helping people, but if this is trolling you can go other chanel, noone is asking you
10:29:48 <Alamo777> beefcube, thanks for example dude, now i understand it
10:29:55 <magneticduck> "understand it"
10:29:56 <magneticduck> ehehehehehe
10:30:15 <jacobw> What does any language 'do'?
10:30:18 <mauke> Alamo777: I'm not the most active and clever in this channel, your questions were already answered, I'm not sitting in this channel all day and trolling people
10:30:27 <mauke> Alamo777: and you were in fact asking me
10:30:28 <Fuuzetsu> mauke: s-stop trolling and answer my stupid question
10:30:29 <osfameron> ah, the sound of self-righteous lazy people lecturing
10:30:30 <Alamo777> magneticduck, yes and the abode if  for teacher of english too
10:30:34 <Alamo777> *above
10:30:41 <mauke> Alamo777: ... along with 1000 other people who are in this channel
10:30:42 <jmcarthur> Alamo777: mauke is a productive and usually pleasant user here
10:30:45 <cmccann> mauke: I think you're spending more effort complaining than Alamo777 spent doing anything
10:30:50 <Alamo777> mauke, yes you do
10:30:54 <jmcarthur> Alamo777: we will not be your google
10:30:55 <cmccann> mauke: that's pretty much the definition of getting trolled :P
10:31:04 <mauke> Alamo777: all because you couldn't be bothered to read a single paragraph by yourself
10:31:08 <magneticduck> Alamo777: thanks though, you've united us, if only to explain why your question is silly
10:31:10 <monochrom> this is getting silly
10:31:16 <magneticduck> I like silly!
10:31:17 <jmcarthur> Alamo777: i already pasted the elevator pitch from haskell.org
10:31:17 <Alamo777> jmcarthur, seriously?
10:31:24 <Earnestly> Drama in #haskell? More likely than you think
10:31:28 <mauke> cmccann: not necessarily
10:31:35 <Alamo777> jmcarthur, oh that was a copy paste, i thought that was your thoughts
10:31:38 <magneticduck> mm drama
10:31:38 <shachaf> I,I trolling amplification
10:31:41 <magneticduck> let me get some popcorn
10:31:42 <Mortomes_> jmcarthur: I don't think you can really say that *after* you've been his google 5 minutes ago.
10:31:45 <nimdAHK> meanwhile, I don't know a byte of haskell
10:31:49 <Fuuzetsu> [drama intensifies]
10:31:54 <shachaf> What is the longest useless discussion you can cause with a single line of IRC?
10:32:02 <magneticduck> DO YOU KNOW HOW MANY KEYSTROKES YOU'VE COST US ALREADY Alamo777
10:32:05 <nimdAHK> shachaf: mention abortion
10:32:09 <magneticduck> neither do I, Alamo777
10:32:12 <jmcarthur> Mortomes_: i humored him until he kept pestering
10:32:12 <mauke> shachaf: depends on your definition of "useless"
10:32:21 <magneticduck> but I bet it cost us about 0.03 cents already!
10:32:37 <Alamo777> magneticduck, who cares
10:32:38 <cmccann> shachaf: how is a raven like a writing desk?
10:32:38 <magneticduck> in keyboard maintaince, new keyboards, cleaning solvents for keyboards, the like
10:32:50 <monochrom> could everyone please shut up?
10:32:53 <Fuuzetsu> millions of dollars in man-hours lost today in #haskell
10:33:00 <Alamo777> magneticduck, use  google voice
10:33:08 <jmcarthur> Alamo777: so what do you mean by "my thoughts"? you want my opinion on haskell?
10:33:10 <magneticduck> yes, I do have an awesome voice
10:33:18 <chuzz> anyone knows how i can do this? http://osdir.com/ml/beginners@haskell.org/2010-02/msg00255.html
10:33:21 <nimdAHK> Alamo777: then you're using extra bandwidth
10:33:25 <nimdAHK> battery life
10:33:26 <nimdAHK> etc
10:33:32 --- mode: ChanServ set +o monochrom
10:33:34 <cmccann> this is stupid.
10:33:40 <monochrom> last call. could everyone please shut up?
10:33:52 <magneticduck> yes sir
10:33:52 <Mortomes_> So, about them monads.
10:34:27 <Alamo777> nimdAHK, what is the difference? Who cares?? counting traffic is for loosers, dont use internet rather then complaining for internet traffic tarriff,
10:34:33 --- mode: monochrom set +b *!*@host-224.244.34.212.ucom.am
10:34:33 --- kick: Alamo777 was kicked by monochrom (Alamo777)
10:34:47 <nimdAHK> lol
10:34:50 <Fuuzetsu> kowai
10:34:51 <magneticduck> woah.
10:35:05 <magneticduck> good move
10:35:10 <int-e> @type Foreign.Storable.peekElemOff
10:35:15 * magneticduck shuts up
10:35:18 <lambdabot> Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> Int -> IO a
10:35:29 <nimdAHK> that drama was better than #baot
10:35:42 <monochrom> ok, please really stop.
10:35:47 --- mode: monochrom set -o monochrom
10:35:57 <int-e> chuzz: peekElemOff should be what you need.
10:36:28 <nimdAHK> can Haskell access the flat Win32 API?
10:36:48 <cmccann> via FFI?
10:36:55 <int-e> (Though using it makes baby seals cry. It's basically C :) )
10:36:56 <nimdAHK> just in general
10:37:06 <cmccann> I can't remember whether Win32 is C or C++ or what.
10:37:11 <cmccann> FFI to C is pretty easy.
10:37:24 <monochrom> I think so. the package name is "Win32"
10:37:29 <Fuuzetsu> No one wants to use Win32.
10:37:39 <nimdAHK> except the people on windows...
10:37:41 <chuzz> int-e: i get a "No instance for ([...].Storable [...].PixelsData)"
10:37:46 <monochrom> it comes with GHC on Windows
10:37:51 <cmccann> no, even the people on windows don't want to use the Win32 API.
10:37:58 <nimdAHK> cmccann: I'll give you that
10:38:07 <cmccann> I don't think even microsoft wants to use the Win32 API.
10:38:15 <nimdAHK> but sometimes user32.dll is inevitable
10:38:31 <chuzz> hmm i used peekArray though, wait
10:39:29 <absence> microsoft seems a bit schizophrene about the win32 api. they tout .net and winrt and what not, yet keep writing all their own stuff in win32 api :p
10:40:04 <nimdAHK> can I call user32.dll from Haskell?
10:40:34 <chuzz> nope, no instance for (Storable PixelsData)
10:40:43 <nimdAHK> or would I have to wrap it in C++ and do some IPC?
10:41:59 * magneticduck is IMing Alamo777 about how he NEEDS haskell
10:42:16 <absence> nimdAHK: i think it should work if you call the symbols and make sure it links with user32, but i don't know exatly how as i have only done ffi to statically linked c code
10:42:19 <Fuuzetsu> You're a bad person magneticduck.e
10:42:40 <int-e> chuzz: hrm. you can cast the pointer (Foreign.Ptr.castPtr), but this really feels like a gap in the SDL haskell bindings
10:42:43 <magneticduck> ty, Fuuzetsu; I try my best
10:42:58 <nimdAHK> absence: I'm not quite sure what you just said, but thanks
10:43:29 * nimdAHK does not yet know Haskell
10:43:31 <absence> nimdAHK: the Win32 package has a lot of the stuff wrapped already though, so you might not need to do it yourself
10:43:40 <absence> http://hackage.haskell.org/package/Win32
10:44:46 <shachaf> Haskell is the opposite of AutoHotKey. If you like one you will probably not like the other.
10:44:56 <shachaf> But perhaps I'm wrong. We'll see.
10:45:13 <Fuuzetsu> What's trying to be achieved?
10:45:25 <Fuuzetsu> Someone released a keyboard + mouse automation in Haskell recently.
10:45:37 <Fuuzetsu> It's still very young but should be simple to improve.
10:45:42 <nimdAHK> Fuuzetsu: that's arbitrary. As an example, user32.dll\SetDoubleClickTime
10:45:57 <magneticduck> how is Haskell comparable to AutoHotKey?
10:46:02 <magneticduck> O.o
10:46:04 <nimdAHK> shachaf: they're obviously for different purposes
10:46:17 <magneticduck> oh, for scripting
10:46:40 <magneticduck> yeah, haskell is incomparable, although AutoHotKey might be more.. convienient for some stuff
10:46:54 <_anycat> need to make a lotto picker, based on the time zone of where they drawr the numbers
10:47:06 <xplat> a while ago i gave up on my project of having a haskell version of the PostgresQL SPI, because after all the assumptions made by Haskell code about the environment it would run in and by the SPI about what environment extension code should expect to run in seemed incompatible
10:47:38 <nimdAHK> shachaf: AHK is also pretty opposite from J
10:47:42 <nimdAHK> but I use that occasionally
10:47:46 <xplat> this really makes me wish disciple was in a better state, or even that Atom was more generic in its ambitions
10:48:00 <xplat> _anycat: based on the time zone why?
10:54:25 <Pranz_> @pl \p x -> p x && all p xs
10:54:25 <lambdabot> liftM2 flip ((&&) .) (flip all xs)
10:55:56 <shachaf> foldr hth
10:57:32 --- mode: ChanServ set +o jmcarthur
10:58:03 --- mode: jmcarthur set -b *!*@host-224.244.34.212.ucom.am
10:58:06 --- mode: jmcarthur set -o jmcarthur
11:01:53 <Garyuutensei> Hi, I'm trying to profile a haskell program I wrote and I see GHC.Float.CAF, also when profiling with -hy there is a part using Integer although I'm only using Doubles and Int s.
11:02:12 <Garyuutensei> What am I missing?
11:02:43 <shachaf> Could be lots of things. Is your code unpostable?
11:06:36 <Garyuutensei> shachaf: You can find it here https://github.com/Grieverheart/hPartSim
11:08:04 <int-e> Garyuutensei: GHC.Float implements the numeric instances for both Float and Double
11:08:29 <shachaf> Yes, GHC.Float is a module, not a type.
11:09:18 <Garyuutensei> Ok, that makes sense
11:23:11 <warrenharris> is there something like Traversable for a data type with kind * ?
11:23:39 <Garyuutensei> So what about the Integer? Clearly from the space profiling, both the Integer and Int constructors are present although I'm not using Integers.
11:23:51 <shachaf> warrenharris: What would it be like?
11:24:07 <shachaf> (a -> f a) -> s -> f s?
11:24:13 <warrenharris> I have: data Expr = ...
11:24:32 <shachaf> Start with something like Functor for *.
11:24:34 <warrenharris> and I find myself writing applicative operations for each case
11:24:35 <shachaf> What does it mean?
11:25:12 <shachaf> warrenharris: You can define traversals for things with kind *. In fact, you can define lots of different traversals.
11:25:39 <shachaf> None of them is special like traverse, so a class is probably not the right answer.
11:26:22 <warrenharris> so I guess I should just write a generic traverse function, no class
11:27:04 <shachaf> Well, a traversal for each thing you want to traverse.
11:27:09 <shachaf> There could be lots of different things.
11:27:53 <shachaf> Sometimes you can derive them automatically.
11:27:59 <jdoles> I did rm -f .ghc .cabal && write new config file && cabal update && cabal install a lot of packages here. The result? cabal: The following packages are likely to be broken by the reinstalls: xmonad-contrib-0.10
11:28:00 <warrenharris> how?
11:28:01 <shachaf> Also note that they're composable.
11:28:20 <jdoles> How can something be broken if nothing is installed?
11:28:22 <shachaf> For example Control.Lens has some TH code for deriving a particular sort of traversal.
11:29:03 <warrenharris> there's no deriving for this w/o TH?
11:29:13 <shachaf> jdoles: Well, xmonad-contrib is installed.
11:29:17 <jmcarthur> warrenharris: the lens library is basically built around things like are "like" traversals
11:29:18 <shachaf> Find out where it comes from, if you didn't install it.
11:29:31 <jmcarthur> warrenharris: anything you can do with TH you can do without
11:30:02 <aavogt> jdoles: did you also include -r in the rm command?
11:30:57 <shachaf> warrenharris: I don't know what "this" is.
11:31:07 <popl> jdoles: if you don't use -r then rm won't recurse
11:31:37 <shachaf> Yes, but it'll give an error message.
11:31:44 <Zenol> Hi. Are there a non lazy + operator? (Or should i write v `seq` v where v = a + b) ? Are there a "reduce the first level" operator?
11:31:48 <popl> not with -f will it?
11:31:57 <popl> nope
11:32:10 <jmcarthur> Zenol: whether (+) is lazy depends on the type
11:32:18 <shachaf> Yes, with -f it will.
11:32:30 <popl> wait, I didn't test it well enough
11:32:36 <popl> :)
11:32:37 <jmcarthur> Zenol: in any case, i suspect that the problem you may be having is not that (+) is lazy (it's probably strict)
11:32:44 <popl> I tested it on an empty directory d'oh :)
11:32:47 <shachaf> Zenol: Writing v `seq` v is never correct and hints at an incomplete understanding of laziness.
11:32:54 <warrenharris> shachaf: I meant I there's no way to define: data Expr = ... deriving (Traversable) if Expr doesn't have a type param
11:33:14 <shachaf> warrenharris: Yes. What is the function that you want to derive, exactly?
11:33:21 <shachaf> popl: So did I.
11:33:40 <warrenharris> my question exactly :-)
11:33:50 <shachaf> warrenharris: What?
11:33:52 <jmcarthur> warrenharris: what do you hope to accomplish?
11:34:11 <popl> shachaf: Are you using GNU rm?
11:34:21 <popl> I am using GNU rm.
11:34:23 <shachaf> popl: Yep. Anyway this is offtopic and irrelevant.
11:34:28 <jmcarthur> warrenharris: are you just asking about possible generalizations of traversable? if so, i recommend looking at the lens library.
11:34:30 <shachaf> warrenharris: You want GHC to generate some code for you. What is the code that you want it to generate?
11:34:59 <Zenol> jmcarthur> I have an efficiency issue probably related to the fact that a lot's of thunk are build for calculs that could be directly computed and will always computed. It's alwais thing like +, &, -, and replacing values.
11:35:19 <jmcarthur> Zenol: you probably have some accumulator somewhere that you aren't using strictly enough
11:35:28 <popl> shachaf: OH crap I made an error.
11:35:34 <popl> shachaf: you're right, it's OT
11:35:56 <jmcarthur> Zenol: if you write a recursive function with an accumulator and don't force it on each step then it will just be a chain of thunks
11:36:46 <jdoles> How do I get the -j option for cabal?
11:36:47 <warrenharris> that's my question: Is there something like Traversable for a data type w/o a type parameter - just application of some monadic function to each constructor parameter with the same type
11:37:01 <jmcarthur> jdoles: if you don't have it, you just need to install a more current version of cabal-install
11:37:03 <Zenol> jmcarthur> THere isn't accumulator i think, just lot's of call of recursive function, and that's why i wan't to reduce expressions like somefunction oldValue newValue to the resulting value.
11:37:09 <shachaf> warrenharris: "with the same type"?
11:37:18 <shachaf> warrenharris: I don't understand quite what you're trying to accomplish.
11:37:28 <jmcarthur> Zenol: can you put your code on hpaste.org?
11:37:46 <Zenol> jmcarthur> Actualy it's the omegagb project i'm looking at....
11:38:02 <Zenol> jmcarthur> So it's a bit too big I think...
11:38:11 <jmcarthur> Zenol: have you narrowed the problem down to any particular module?
11:38:12 <warrenharris>  data Expr = Foo Expr Expr;  myfun f (Foo a b) = Foo <$> f a <*> f b
11:38:22 <jdoles> jmcarthur: I just did cabal install cabal 3 minutes ago.
11:38:35 <shachaf> warrenharris: In data Foo a = Blah a String a | Blue Int | Bleh (Foo a), it's easy to see what the traverse function should do. It should "traverse" all the 'a's.
11:38:36 <Zenol> jmcarthur> Yap, the "machine" module where binary code is processed.
11:38:56 <warrenharris> shachaf: correct
11:39:05 <shachaf> warrenharris: Without the 'a', it's not really clear: data Foo = Blah Char String Char | Blue Int | Bleh Foo -- do you want to traverse the Chars or the Ints or the Strings or what?
11:39:13 <jmcarthur> jdoles: cabal install cabal-install
11:39:20 <jdoles> jmcarthur: yeah, you were too late.
11:39:29 <Zenol> jmcarthur> And, also, did the memory profiling -hc include in a function's memory the heap cost of calling it? Because the worst function for memory is the simplyest.
11:39:38 <warrenharris> for data Expr = ... I want to traverse all the Exprs
11:39:53 <shachaf> warrenharris: That's a pretty odd type you have there. :-)
11:39:57 <jmcarthur> Zenol: RegisterStates looks very suspicious to me, right off the bat
11:40:05 <warrenharris> I don't see why?
11:40:11 <jmcarthur> Zenol: those are strict types, but since it's a lazy tuple they will not be forced
11:40:27 <shachaf> Well, it has no finite inhabitants without ⊥.
11:40:49 <warrenharris> I don't know what that means
11:40:58 <shachaf> I mean that there are no values of that type.
11:41:11 <shachaf> (That's not what I mean but it's close enough.)
11:41:19 <shachaf> Can you give an example of how you'd use this sort of thing?
11:41:19 <jmcarthur> no values with a normal form?
11:42:17 <Zenol> jmcarthur> Are there "non lazy" tuples?
11:42:54 <jmcarthur> Zenol: not in the standard library, but you could define your own data type:    data RegisterStates = RegisterState !Word8 !Word8 !Word8... etc.
11:43:25 <jmcarthur> Zenol: to be clear, i don't know that this is the problem. it's just a problematic looking type
11:43:32 <shachaf> You should use "nick:" rather than "nick>" to address people. :-(
11:44:14 <jmcarthur> still highlights me at least
11:45:46 <warrenharris> shachaf: basically what I wrote above, although I should have written: myfun (Foo a b) = Foo<$> myfun a <*> myfun b ... for each constructor. What I'm wondering if there something more generic I can use to apply myfun to each sub-Expr... kinda like fmap, but here there's no type parameter, so the function I'm applying has to be Expr->Expr
11:46:18 <shachaf> warrenharris: I think you should give a concrete example.
11:46:28 <shachaf> Here: data Expr = Plus Expr Expr | Lit Int
11:46:34 <warrenharris> yes
11:46:37 <shachaf> What should the traversal for that look like? What should it do?
11:47:10 <shachaf> (By the way: Consider adding a type variable if you can possibly get away with it. It'll make your life better to have one.)
11:49:57 <warrenharris> shachaf: thanks. let me play around with this more and see if I can come up with a more concrete question.
11:51:03 <shachaf> warrenharris: I guess I should say: In data Expr a = Plus (Expr a) (Expr a) | Lit a, the traversal doesn't "traverse" Exprs; it "traverses" 'a's.
11:51:59 <shachaf> Look at its type: (a -> f b) -> Expr a -> f (Expr b)
11:52:17 <warrenharris> yes I guess I could define data Expr a = ... and then use Traversable, but I would probably want to Fix Expr before using it in most of the code
11:53:28 <shachaf> Fix Expr? So Expr (Expr (Expr (Expr ...?
11:53:30 <Zenol> jmcarthur> It's certainely one of the problems :) Have you a link/ref about strict types (about the operator ! in type declaration) ?
11:53:35 <shachaf> I'm really not sure what it is you're trying to do.
11:54:32 <jdoles> Why is the -j flag not documented in cabal --help output?
11:54:42 <jmcarthur> Zenol: http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-680004.2
11:54:51 <byorgey_> jdoles: it's a conspiracy.
11:54:56 <dcoutts> it is
11:54:58 <dcoutts>  -j --jobs[=NUM]                    Run NUM jobs simultaneously.
11:55:27 <byorgey_> it is documented in  cabal install --help, but not  cabal --help.
11:55:35 <byorgey_> but I don't know why you would want it in  cabal --help.
11:55:38 <jmcarthur> Zenol: http://stackoverflow.com/questions/8576795/advantages-of-strict-fields-in-data-types
11:56:51 <jmcarthur> Zenol: http://johantibell.com/files/haskell-performance-patterns.html#(1)
11:57:32 <ijp> Is there a function for splitting a fraction into its numerator and denominator?
11:58:05 <hpaste_> warrenharris pasted “Traversable?” at http://hpaste.org/87835
11:58:05 <jdoles> byorgey_: much more complicated programs also do this. One is breaking the standard when one does not.
11:58:19 <warrenharris> shachaf: Here's some actual code: http://hpaste.org/87835
11:58:25 <ijp> as opposed to two separate ones
11:58:28 <byorgey_> jdoles: when one does not what?
11:58:43 <jdoles> byorgey_: that should have been clear from the context.
11:58:47 <shachaf> ijp: http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ratio.html has two functions, numerator and denominator
11:59:00 <shachaf> I don't think there's one function that gives you both as a tuple, if that's what you're after.
11:59:17 <byorgey_> ijp: not really, though there is  properFraction
11:59:18 <ijp> I was, but I suppose I'll live
11:59:33 <shachaf> warrenharris: You should get rid of the Monad m constraint. :-( You don't need it. Monad is evil.
11:59:58 <warrenharris> ok
12:00:11 <shachaf> warrenharris: Anyway, I still don't understand.
12:00:19 <shachaf> warrenharris: Oh, now I understand. The traversal isn't recursive.
12:00:23 <warrenharris> so my question here is whether there's something like traversable that covers this sort of pattern
12:00:48 <shachaf> warrenharris: So unlike the derived Traversable traversal, which is recursive, you just want to find the immediate subchildren of the same type.
12:01:07 <warrenharris> yes :-)
12:01:26 <shachaf> OK.
12:01:37 <shachaf> So it's very different from deriving Traversable!
12:01:39 <shachaf> Sounds Platey.
12:03:06 <shachaf> If you derive Typeable and Data, there's a function in lens that will work and do this for any normal data type.
12:03:30 <warrenharris> sounds promising
12:07:00 <shachaf> warrenharris: The function is uniplate from Data.Data.Lens, I think.
12:07:07 <shachaf> I guess uniplate has a similar function.
12:07:18 <shachaf> In fact uniplate has a class for this! But you shouldn't use it.
12:07:31 <warrenharris> why not?
12:07:55 <shachaf> I don't remember. I've never used Uniplate.
12:08:01 <shachaf> lens also has a class for this, but using it is less bad because of the way lens works. lens's class is called Plated.
12:08:14 <shachaf> I think the thing was that people might want alternate implementations or something. I don't know.
12:08:47 <warrenharris> shachaf: thank - I'll go read up on that
12:08:59 <warrenharris> (now I know what you meant by "Platey") :-)
12:10:38 <shachaf> I've never really used Plated either.
12:11:05 <shachaf> Anyway, this is probably the class you're after.
12:11:09 <shachaf> A Plated type is one where we know how to extract its immediate self-similar children.
12:11:14 <shachaf> (From the documentation.)
12:12:08 <warrenharris> thanks again
12:19:35 <shachaf> What is a good type for "a list of elements, one of which is marked"?
12:19:52 <shachaf> Actually it's not the element that's marked, it's a space between elements. The list could be empty.
12:20:25 <luite> ([],[])
12:20:37 <luite> (i mostly suggested this because it looks like an owl ;) )
12:20:40 <Ralith> (Vect a n, Fin n)
12:20:44 <Ralith> oh wait this is #haskell
12:20:52 <mm_freak> shachaf: a zipper without the hole
12:21:23 <luite> ([o],[o]) is better
12:21:50 <shachaf> I guess that's all it is, yes.
12:21:52 <mm_freak> a nerd face?
12:21:55 <mm_freak> or an ass?
12:22:13 <shachaf> What about a list with a marked element?
12:22:28 <luite> that would be a regular zipper
12:22:32 <shachaf> I guess that's just a -- right.
12:23:00 <hpaste_> warrenharris pasted “Traversable? 2” at http://hpaste.org/87839
12:23:29 <shachaf> warrenharris: I think you're asking for too much here.
12:23:48 <shachaf> If I make newtype Foo = Foo (Maybe Path) and include a Foo, should that be "traversed into"?
12:24:10 <warrenharris> just trying to see if there was something I should know about to solve this sort of thing
12:24:46 <shachaf> I think you'll probably have to write the function yourself at that point.
12:25:06 <shachaf> luite: Are you making fun of me with the owl thing?
12:25:07 <jdoles> Why does cabal install package && cabal install package run twice as slow as just running it once?
12:25:16 <shachaf> At least you see what I mean, right?
12:25:28 <luite> shachaf: yes
12:25:38 <shachaf> jdoles: Because it installs it twice, presumably.
12:26:38 <jdoles> Out of the 3 people that said anything to me, 2 have given less than helpful answers.
12:27:23 <jdoles> Why are you even in this channel if all you want to do is troll?
12:27:34 <dcoutts> jdoles: it's because the package dependency solver doesn't have quite the property you're expecting
12:27:41 <shachaf> What?
12:27:51 <Garyuutensei> Does anyone know if you have a boolearn expression, a || b, if 'b' needs to be evaluated incase 'a' is True?
12:28:04 <philipdexter> it isn't evaluated
12:28:09 <dcoutts> > True || undefined
12:28:12 <lambdabot>   True
12:28:25 <Garyuutensei> ah, nice, thanks
12:28:26 <dcoutts> Garyuutensei: you can check these kinds of lazyness properties
12:28:28 <jdoles> Garyuutensei: you would have to try hard to find any language in which b is evaluated.
12:28:32 <dcoutts> use ghci, and use undefined
12:28:47 <Garyuutensei> yes, I didn't think about that
12:28:54 <Garyuutensei> thanks though
12:29:25 <Zenol> jmcarthur> from 64kk to 13kk used in a test by swaping from a lazy to a strict type :o Than you a lot!
12:30:02 <jdoles> dcoutts: what dependency solver? All it needs to do is figure out the requested version, compare that to the installed version and then call exit.
12:30:21 <jdoles> dcoutts: note that nowhere it required to compile anything.
12:30:27 <dcoutts> jdoles: no it's much more complicated than that
12:31:06 <dcoutts> jdoles: in general finding a solution to install a package requires constraint solving, it's actually an NP-complete problem.
12:31:38 <jdoles> dcoutts: note that nowhere it required to compile anything.
12:31:58 <greg`> hi i wonder how i can insert a stacktrace for an Exception
12:32:04 <dcoutts> jdoles: cabal-install has a constraint solver and that's what it's using. If the solver end up picking all installed instances then in that case nothing needs to be done
12:32:51 <dcoutts> jdoles: but, if the solver decides that the package should be rebuilt against a different version of some dependency then it'll do that
12:33:00 <greg`> also any recommended papers for functional design patterns?
12:33:08 <byorgey_> jdoles: someone seems to be trolling, but it isn't shachaf.
12:33:15 <jdoles> dcoutts: I'd say the constraint solver is completely broken if cabal install foo && cabal install foo etc (for 1 million times) compiles it more than one time.
12:33:16 <dcoutts> jdoles: now some kind of stability property would be nice it's true
12:33:30 <jdoles> dcoutts: and by completely broken I mean off the scale broken.
12:33:54 <jdoles> dcoutts: can you understand that everyone would see it that way>
12:33:59 <shachaf> jdoles: You're being pretty hostile here.
12:34:03 <dcoutts> jdoles: mind showing me the example? use --dry-run
12:34:33 <pete_> greg`: For something important, or you just want an introduction?
12:35:11 <greg`> design patterns introduction i guess
12:35:19 <pete_> greg`: Have you read The Little Schemer?
12:35:28 <greg`> no, thats scheme isnt it?
12:35:37 <greg`> good for learning a functional style though?
12:35:42 <jdoles> dcoutts: http://paste.kde.org/742388/
12:35:53 <pete_> greg`: Excellent for it
12:36:08 <pete_> greg`: You could read "The Little MLer" instead if you wanted, but they're just the same except for the language
12:36:13 <dcoutts> jdoles: ohhh
12:36:16 <shachaf> gtk2hs-buildtools is an executable, not a library...
12:36:30 <greg`> ah greg thats just what i need
12:36:31 <pete_> dcoutts: Hrm, I know you from somewhere
12:36:46 <dcoutts> jdoles: ok, yes that's "just" the issue that only libraries are actually recorded with ghc-pkg
12:36:57 <greg`> i actually have the little schemer on my shelf just havent got round to reading it yet :#/
12:37:15 <jdoles> dcoutts: what a "minor" issue...
12:37:23 <dcoutts> jdoles: cabal-install isn't a "proper" package manager in that it doesn't keep track of everything it installs (e.g. files). It only asks ghc-pkg what libs are installed.
12:37:32 <pete_> greg`: It's easily done, get yourself a copy of DrRacket and get going
12:37:34 <pete_> greg`: it's fun!
12:37:55 <dcoutts> jdoles: so if you ask it to install an executable, it doesn't know if you installed that already
12:38:23 <jdoles> dcoutts: then why do people package executables with a system which hasn't been designed for it?!
12:38:48 <pete_> dcoutts: Did you used to ride a funny recumbant bicycle?
12:38:51 <luite> jdoles: it's designed for building them, not for keeping track of them ;)
12:38:54 <jdoles> dcoutts: and why did you add support for executables?
12:38:57 <dcoutts> pete_: yes
12:39:01 <pete_> there we go
12:39:05 <mauke> jdoles: would you prefer to have no executables?
12:39:14 <dcoutts> pete_: so where do you know me from?
12:39:15 <shachaf> jdoles: You could probably get answers to your question without calling people trolls and telling people that their code is completely broken. Please try to be nice.
12:39:28 <jdoles> mauke: sure. Their would be a reason to improve then.
12:39:39 <niteria> are there parsing libraries with bit-level granularity?
12:39:47 <mauke> jdoles: improve? like adding support for installing executables to the installer?
12:39:49 <pete_> dcoutts: I worked at Virus Bulletin for a little while. Also I note you have my supervisor as a connection on LinkedIn
12:40:08 <dcoutts> pete_: did you work for Sophos?
12:40:22 <pete_> dcoutts: No, I worked for Virus Bulletin. Which was in the same building, mind
12:40:41 <dcoutts> pete_: oh, I didn't realise that
12:40:50 <dcoutts> pete_: that was a long time ago :-)
12:41:00 <pete_> I think that was my second job out of high school
12:41:00 <Zenol> GADT types's field are lazy or strict?
12:41:01 <greg`> ok thanks pete looking for the doctor now
12:41:13 <dcoutts> pete_: I was only there for a year, before going off to do a PhD :-)
12:41:19 <shachaf> Zenol: GADTs are just like regular types as far as strictness is concerned.
12:41:41 <pete_> One day when I've made it rich, I will go do a PhD
12:42:04 <dcoutts> jdoles: cabal-install was not designed as a package manager, it started just as a tool to help developers automate the process of compiling and installing Cabal packages
12:42:05 <jdoles> shachaf: should I be telling them that it has been designed like only God would do instead?
12:42:35 <aristid> dcoutts: Cabal came before cabal-install? huh
12:42:35 <dcoutts> jdoles: which is why for example it's never even had uninstall capability
12:42:43 <nejucomo> I want to write a generic function to translate a (typeName :: String, contents) tuple, where for any constructor, contents would be a tuple whose first element is the constructor names, and the other elements are recursive (bottom up) translations...
12:42:48 <dcoutts> aristid: about 3-4 years before, yes.
12:43:01 <nejucomo> -but I can't quite understand the Data.Generic api docs.  Should I use synthesize?
12:43:01 <aristid> dcoutts: and when did hackage come in?
12:43:17 <dcoutts> aristid: similar time as cabal-install
12:43:32 <cpehle> hi, i'm looking for a parser like naturalOrFloat in Text.Parser.Token but that parses Integer and Rational instead
12:43:33 <jdoles> dcoutts: the reason why it doesn't work is because there is no commercial interest in making things that work.
12:43:43 <shachaf> jdoles: No. Just try to be civil.
12:43:48 <aristid> dcoutts: old-style Cabal was using the Setup.hs stuff?
12:43:55 <dcoutts> aristid: yes
12:44:02 <aristid> hmm
12:44:24 <dcoutts> jdoles: getting commercial support for infrastructure is a hard problem
12:44:27 <nejucomo> Oh… the output I described might not have consistent types.  Just imagine the output is a JSON representation that names all types and constructors as JSON strings.
12:44:37 <dcoutts> jdoles: I've been working on that issue for years
12:45:19 <pete_> nejucomo: What are you actually trying to do?
12:45:49 <pete_> nejucomo: You seem to be asking about a potential solution to a problem, rather than the problem
12:46:29 <nejucomo> pete_: Translate any Data type to a JSON-equivalent representation.
12:47:04 <pete_> What does "Data type" mean, specifically, here?
12:47:07 <greg`> sorry and can anyone tell me how to get a stacktrace from ghci
12:47:31 <nejucomo> More specifically, I have an AST which is the output of a parser, and I want to make a one-to-one representation that can be consumed by a dynamically typed language without ambiguity.
12:47:36 <pete_> greg`: What does that mean?
12:47:48 <pete_> greg`: Or rather, what do you want it for?
12:48:12 <greg`> well im doing some execise from why functional programming matters
12:48:12 <nejucomo> So some serializations rely on types for context, but others do not.  I want a serialization that does not, by explicitly naming the type of each node.
12:48:26 <greg`> im getting Exception Negative exponent
12:48:35 <greg`> i cant see where its happening
12:48:45 <greg`> or rather why its happening
12:48:52 <pete_> greg`: What's the actual error message, in full, in hpaste or similar?
12:49:10 <frankbro> Anyone knows if haskell's lexer and parser files are available somewhere?
12:49:19 <greg`> its short so i'll write it inline
12:49:35 <greg`> *** Exception: Negative exponent
12:49:40 <greg`> thats all i get
12:49:49 <greg`> when i tryi to run my program
12:49:57 <nejucomo> frankbro: I have a package called "haskell-src" which has Language.Haskell.Parser.
12:50:15 <nejucomo> -there's also a syntax module.
12:50:19 <dcoutts> frankbro: and in practice everyone uses a package calls haskell-src-exts
12:50:25 <dcoutts> calls/called
12:50:39 <pete_> greg`: Do you know that that means?
12:50:44 <nejucomo> I'm curious if GHC et al rely on that library, or if they have custom parsers...
12:51:09 <dcoutts> nejucomo: it's got it's own
12:51:22 <greg`> yeah i guess it means that ive raised something to a negative power?
12:51:35 * nejucomo pokes around the source of aeson to see if there's an example of what he wants...
12:51:52 <greg`> but firstly i dont see anything wrong with that , and secondly i cant see how my program could produce that
12:52:02 <greg`> shall i hpaste my program?
12:52:19 <nejucomo> When I hoogle for a library, the resulting page has source links.  Can I instruct cabal to do the same with my local documentation?
12:52:40 <pete_> greg`: do it!
12:53:13 <Zenol> shachaf> So how should I do to make fields strict (like the bang pattern ! with data declaration)?
12:53:26 <supki> nejucomo: cabal haddock --hyperlink-source
12:53:29 <shachaf> Zenol: There's a syntax for it that involves an !.
12:53:35 <shachaf> Zenol: The GHC manual describes it.
12:54:13 <Zenol> shachaf> Ow, I should't doing it right. I'll check the manual.
12:54:56 <nejucomo> Ah, here's an example of almost exactly what I want: http://hackage.haskell.org/packages/archive/aeson/0.6.1.0/doc/html/src/Data-Aeson-Generic.html#toJSON
12:55:07 <hpaste_> greg` pasted “whyfunctionalprogrammingisaproblematicmatter” at http://hpaste.org/87843
12:55:13 <nejucomo> I feel like the Data.Generic docs could be improved...
12:55:40 <nejucomo> For example I found ext1Q by looking at the aeson source, but it's in a module called Data.Generics.Aliases.
12:56:01 <nejucomo> I assumed that module would not have the primary documentation for generics stuff, but would just be shorthand.
12:56:13 <greg`> so i try to execute the following:   within 10 (super (differentiate 3423 (^2)
12:56:31 <nejucomo> I don't understand where to look first to understand the docs...
12:56:31 <pete_> greg`: elimerror n (a:b:rest) = ((b * (2^n) - a)/ ((2^n)-1):(elimerror n ( b:rest)))
12:57:03 <greg`> yes i suppose its coming from there
12:57:08 <nejucomo> Also, I try reading the Data class docs every few months and still have yet to grok how to use it…  :-(
12:57:16 <greg`> but i only ever halve n
12:57:29 <greg`> so how is it becoming negative?!
12:58:05 <pete_> (order s) must occasoinally return negative
12:58:22 <greg`> oooh lemme look again
12:58:43 <pete_> that seems to be the only place elimerror is getting called
12:58:46 <shachaf> nejucomo: https://docs.google.com/viewer?url=http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/Boilerplate%20v3.ppt had a good explanation, I think.
12:58:58 <pete_> well, and it recurses, but, not with a different n
12:59:03 <nejucomo> Thanks.
12:59:37 <greg`> @pete yes you are right
12:59:38 <lambdabot> Maybe you meant: let paste vote
12:59:53 <greg`> pete yes you are right
13:00:03 <greg`> need to cross reverence the paper
13:00:04 <pete_> fantastic, and as it happens, it's also lunch time!
13:00:11 <nuttycom1> nejucomo: are you the nejucomo I know?
13:00:16 <gwern> @quote
13:00:16 <lambdabot> Dijkstra says: "It is practically impossible to teach good programming style to students that have had prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of
13:00:16 <lambdabot> regeneration."
13:00:52 <pete_> There's something about travelling half way across the world to sunny destinations which makes me want to stay in my hotel room and write Perl
13:02:49 <nejucomo> Yeah, this slide deck is exactly what I was looking for.
13:03:01 <jmcarthur> Zenol: great! you're welcome
13:03:15 <nejucomo> nuttycom1: I am the nejucomo you know if you are the nuttycom1 I know.  ;-)
13:03:31 <nejucomo> I think the answer is yes.  I mean, how many nicks can there be on the internet?
13:04:09 <nejucomo> Hi!
13:06:13 <nejucomo> hehe…  It was going great with the deck where slide 10 clearly shows how awesome this library is, but I'm starting to wonder when slide 14 is about how to implement type classes.
13:06:53 <shachaf> nejucomo: SPJ's favorite way to explain what type classes are is to explain how to implement them.
13:07:04 <Guest1802> how do I import State? I tried Control.Monad.State but keep getting errors. I have mtl installed
13:07:36 <nejucomo> I like it.
13:07:56 <Guest1802> never mind. I got it.
13:09:39 * hackagebot uuid 1.2.13 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.2.13 (AntoineLatter)
13:10:12 <Guest1802> hoogle Control.Monad.State
13:10:52 <nejucomo> Slide 17 which implements mkT with cast is giving me pleasurable spine tinglies.
13:11:14 <nejucomo> Too bad I don't know how cast is implemented. Turtles...
13:11:32 <tinyghost> Ambiguous module name `Prelude':
13:11:45 <tinyghost> it was found in multiple packages: base haskell98-2.0.0.1 ( ´ - `)
13:11:45 <nejucomo> hehe…  implementing cast is the next slide.
13:12:57 <nejucomo> If I see: data Foo
13:13:17 <nejucomo> -with no constructor definitions, does this introduce a type which may never have values?
13:14:10 <hpc> yes
13:14:14 <hpc> an empty type, as it were
13:14:19 <arcatan> well, there's always undefined
13:14:22 <hpc> it requires a language extention, iirc
13:14:36 <luite> EmptyDataDecls yeah
13:14:39 * hackagebot midi 0.2.1 - Handling of MIDI messages and files  http://hackage.haskell.org/package/midi-0.2.1 (HenningThielemann)
13:14:50 <shachaf> No, in the report.
13:15:05 <luite> oh realli
13:15:13 <shachaf> truli
13:15:15 <shachaf> http://www.haskell.org/haskellwiki/Haskell_2010
13:15:28 <luite> ah
13:46:21 <pqmodn_> > "ok"
13:46:25 <lambdabot>   "ok"
13:49:05 <Taneb> There doesn't exist a quasiquoter for Heist like Hamlet, does there?
14:09:07 <tboyt> hi y'all. does anyone know a ghci+vim repl plugin that won't hard lock my computer when an infinite recursion occurs? :S
14:09:59 <shachaf> Which ones have you tried? What does it mean for an infinite recursion to occur?
14:10:46 <tboyt> as in when i have a function that recurses infinitely (for some reason it's not hitting its base case properly)
14:11:06 <shachaf> Oh, this is about REPLs, not typechecking.
14:12:10 <tboyt> yeah. i've tried the ":GHCi" command that's in haskellmode-vim and i've tried the actual GHCi panel you get from SHIM and both of them will very quickly eat up all of my resources and make it impossible for me to terminate them. and, on this macbook, the five-minute restart process is not pleasant :p
14:14:39 <HectorAE> How did Haskell get its name?
14:14:56 <Eduard_Munteanu> @google haskell curry
14:14:57 <lambdabot> http://en.wikipedia.org/wiki/Haskell_Curry
14:14:57 <lambdabot> Title: Haskell Curry - Wikipedia, the free encyclopedia
14:16:20 <absence> haskell curry sounds like functional stew :p
14:16:22 <shachaf> @google haskell named after
14:16:23 <lambdabot> http://en.wikipedia.org/wiki/Haskell_(programming_language)
14:16:23 <lambdabot> Title: Haskell (programming language) - Wikipedia, the free encyclopedia
14:16:26 <merijn> HectorAE: Haskell Curry was a famous logician (the guy after which currying is named)
14:16:38 <Nisstyre> HectorAE: there's also a similar language called Frege
14:16:42 <Nisstyre> named after another famous logician
14:17:28 <Nisstyre> pronounced "fray guh"
14:18:14 <HectorAE> Sweet
14:18:32 * djahandarie 's home computer is named "curry". His laptop is "church"
14:18:48 <popl> mine is called nemo
14:18:50 <cmccann> there is also Coq, which is named for making tasteless jokes.
14:19:04 <Nisstyre> mine is Sagan
14:19:08 <Nisstyre> laptop is QED
14:19:14 <popl> As in Captain, not Finding.
14:19:17 <popl> :)
14:19:55 <popl> actually either is fine
14:20:01 <HectorAE> I really should think of a better name for my laptop
14:20:02 <popl> also http://en.wikipedia.org/wiki/Little_nemo
14:20:12 <popl> ^ was my first inspiration
14:23:29 <popl> Pascal, Ada, and Haskell are all examples of people naming languages after their nerdcrushes :)
14:23:55 <shachaf> @quote shachaf Agda
14:23:56 <lambdabot> shachaf says: Everyone forgets about Agda Lovelace, the first constructivist.
14:34:30 <Michae___> fruitFly_:
14:55:24 <fizbin> Quiet here today.
14:56:09 <sellout-> Everyone’s kids are probably taking them out for Mothers Day.
14:56:31 <simpson> I don't have kids. I did call my mom though.
14:56:42 <pharaun> heh i texted my mom
14:57:36 <Zenol> hum.I might be missing something. is doSomeStuf :: Word 8 -> Word 8 -> Word 8, doSomeStuff lo hi = ((fromIntegral lo)::Word16) + (shiftL ((fromIntegral hi)::Word16) 8) "lazy" or not? I mean, if I call doSomeStuff 4 5, this will create thunks or just compute the answer?
14:57:40 <blackdog> as usual, the australians have the jump on all of you
14:58:30 <sellout-> blackdog: They need all the advantage they can get.
14:58:45 <blackdog> sellout-: them's fighting words, cobber :)
14:58:54 <fizbin> Zenol: it's lazy
14:59:31 <simpson> Zenol: (+) is strict for most Nums, including Words IIRC.
15:00:04 <simpson> Zenol: But you'll get thunks for the intermediate steps.
15:01:17 <Zenol> fizbin, simpson > If I wan't it to be strict, I should use $! when applying fromIntegral et shiftL ?
15:02:10 <simpson> Zenol: Or seq or something. Why do you need it to be stricter?
15:02:41 <fizbin> The easiest thing to do is make the pattern strict (i.e. use ! on the parameters)
15:04:49 <Zenol> fizbin> like doSomeStuf !lo !hi = ? It don't want to compile with ghc ;
15:05:43 <Zenol> simpson> It's an emulator of a Z80 ship and there is a loooots of memory allocation that are lost of time / memory because everithing will have to be computed.
15:06:05 <simpson> Zenol: Is this an actual problem right now, or is it something that you anticipate down the road?
15:06:31 <Zenol> fizbin> Illegal bang pattern. Should I use -XbangPattern?
15:06:54 <applicative> LANGUAGE BangPatterns
15:06:58 <Zenol> simpson> Actual problem. 5s to compute 10 frame is far too much.
15:07:23 <Zenol> applicative> Oh, ok :)
15:07:27 <BMeph> Zeno1: Have you checked to see where the allocation happens, or are you "programming by using the Force"? ;þ
15:07:51 <Zenol> BMeph> Both, since I don't really understand fully the -hc output.
15:08:17 <Zenol> BMeth> Actualy a method using this function is allocating a lot's of memory, and it should'nt allocate.
15:10:52 <BMeph> Zeno1: Just curious, but...why isn't it: "doSomeStuf :: Word8 -> Word8 -> Word16"? :)
15:13:44 <applicative> hm data Word8 = GHC.Word.W8# GHC.Prim.Word#
15:14:01 <applicative> data Word16 = GHC.Word.W16# GHC.Prim.Word#
15:14:15 * applicative recommends unsafeCoerce just to be a menace
15:16:09 <Zenol> BMEph it's 16.
15:16:57 <Zenol> And it didn't seems it reduce heap usage. It's seems that it's increasing it. So that should be more complex than I though. I'll think about tomorow. Good night
15:17:07 <Zenol> And thanks for your help.
15:22:40 <tgeeky> BMeph++
15:28:43 <LLckfan> Does any1 know how to stop Shockwave flash from crashing? I have uninstalled both Flash and my browser (Chrome), installed both from a fresh download, and scanned my computer (come up clean). Everything is updated
15:29:17 <Clint> the only way to do that is to not use flash
15:29:30 <LLckfan> I do not use flash
15:29:37 <nejucomo> There's a joke: "How can I stop Shockwave Flash from crashing? Don't give it access to an instruction pointer."  <ba dump, crash>
15:30:01 <nejucomo> LLckfan: Which platform are you on?
15:30:24 <LLckfan> XP and 7
15:33:17 <nexx> why are you asking a haskell chan for that?
15:33:26 <LLckfan> Hello
15:33:35 <typoclass> LLckfan: hello, this channel is about the programming language haskell
15:33:55 <luite> :(
15:33:59 <pete_> saw him off
15:34:05 <nejucomo> nexx: Excellent point.
15:35:00 <typoclass> nexx: i think s/he didn't know what haskell is, so "a haskell chan" doesn't mean much to him :)
15:35:13 <typoclass> or her
15:35:17 <Eduard_Munteanu> But now he knows it's not "a flash chan"
15:35:42 <nexx> typoclass are there people who don't notice the name of the channel they are in?
15:42:07 <typoclass> nexx: not many presumably. that's why i think the problem was knowing the channel name #haskell, just not knowing what that word means. for all anyone knows, it could be a general chat channel that just happened to be started by someone from haskell, texas
15:42:11 <typoclass> anyway, never mind
15:48:14 <Eduard_Munteanu> Well, if you look at conal's homepage, his photo does leave the impression it's a Texan community. :)
15:50:51 <cpehle> i'm trying out parsec and run into the following type error http://pastebin.com/WkcVYuCk, although word = many1 letter is even one of the examples in  Text.Parsec.Combinator
15:50:54 <mauke> The paste WkcVYuCk has been copied to http://hpaste.org/87857
15:52:09 <typoclass> cpehle: i guess that you need to import another module that contains this instance. though i don't know which module :-/
15:52:36 <nejucomo> It may be Text.Parsec.String.
15:52:51 <typoclass> cpehle: or possibly it's the dmr?
15:52:54 <typoclass> @where dmr
15:52:54 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
15:53:16 <RichyB> Please tell me that the "d" in "dmr" stands for "dreaded"?
15:53:59 <typoclass> RichyB: yes
15:54:11 <RichyB> ♥
15:54:17 <cpehle> hm, ok because the types seem to match, :t letter is Text.Parsec.Prim.Stream s m Char => Text.Parsec.Prim.ParsecT s u m Char
15:54:43 <cpehle> and :t many1 is Text.Parsec.Prim.Stream s m t => Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m [a]
15:55:21 <applicative_> @tell Zenon here's a simple way to do some benchmarking of doSomeStuff etc: http://hpaste.org/87858
15:55:22 <lambdabot> Consider it noted.
15:55:31 <cpehle> Text.Parsec.Prim.Stream s m t => Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m [a]
15:56:09 <shachaf> Zenol's paradox is that people keep misspelling their name.
15:57:07 <applicative_> cpehle: this is the #1 use case for {-#LANGUAGE NoMonomorphismRestriction#-}
15:57:28 <applicative_> cpehle: or :set -XNoMonomorphismRestriction inside ghci
15:58:10 <applicative_> shachaf: ah thanks
15:58:31 <nejucomo> I'm pretty confused about the phrase "T.toJSON" inside the toJSON definition here: http://hackage.haskell.org/packages/archive/aeson/0.6.1.0/doc/html/src/Data-Aeson-Generic.html#toJSON
15:58:32 <applicative_> @tell Zenol  here's a simple way to do some benchmarking of doSomeStuff etc: http://hpaste.org/87858
15:58:33 <lambdabot> Consider it noted.
15:58:37 <shachaf> It's not a very good paradox.
15:59:17 <nejucomo> I parse it as either <module name> . <identifier from module>   -or-  <function named T> <composition operator> <toJSON defined in this module>
15:59:18 <typoclass> shachaf: agreed. i think we should call it a "fallacy"
15:59:42 <nejucomo> In the first case, there is a qualified import where T is Data.Traversable, but there is no Data.Traversable.toJSON.
15:59:56 <applicative_> import qualified Data.Aeson.Types as T
15:59:59 <nejucomo> In the second case, I don't understand what T is in scope.
16:00:16 <applicative_> nejucomo: its the module,no?
16:00:49 <nejucomo> What?!  Both of these lines exist:  "import qualified Data.Aeson.Types as T" and "import qualified Data.Traversable as T"
16:00:52 <applicative_> the other T is a constructor
16:00:53 <nejucomo> That's possible?!
16:00:55 <typoclass> nejucomo: there's two or three things imported "as T"
16:00:57 <applicative_> oh yeah
16:01:08 <nejucomo> Argh!  How frustrating.
16:01:23 <applicative_> usually I do that with Data.Text as T; Data.Text.IO as T; ...
16:01:39 <applicative_> this is admittedly a really confusing definition
16:01:53 <applicative_> T's everywhere
16:02:01 <shachaf> import qualified Data.{Traversable,Text,Tree,Typeable,TotalMap,Time,Tagged} as T
16:02:19 <nejucomo> I can guess how it performs the same ambiguity checks as non-qualified imports, except restricted to the alias namespace...
16:02:23 <applicative_> hm, I wonder how many clashes that would give you
16:02:24 <typoclass> nejucomo: (T can't be a function in the narrow sense, since they always need to start with a lower-case letter. it could however be a constructor. think like e.g. "Just")
16:02:38 <applicative_> nejucomo: exactly, thats my understanding
16:02:48 <nejucomo> typoclass: I realized that, but the only non-module alias I saw was a type T.
16:03:05 <typoclass> nejucomo: right, then it's confusing indeed
16:03:21 <nejucomo> So basically I saw the type T, and then scanned backwards to hit the bottom qualified import, and assumed import aliases could not collide, then was left wondering.
16:03:30 <nejucomo> Now I know that qualified aliases aren't unique.
16:03:42 <frontendloader> Speaking more broadly, how would you handle a function where the value returned varies with time? Something as simple as displaying the current time of day or system load average.
16:03:48 <typoclass> nejucomo: and yes. if you call T.foo, and both a Data.Aeson.Types.foo and Data.Traversable.foo exist, then you get a compile-time error about ambiguity
16:04:10 <nejucomo> frontendloader: It would require IO.
16:05:06 <nejucomo> Ok.  Well, this is at least safe, although I personally find it a distasteful choice in the import feature.
16:06:24 <cpehle> applicative_: thanks, i tried annotating it with explicit types (it is word :: Stream s m Char => ParsecT s u m String) but now he wants -XFlexibleContexts, does it matter which extension i choose?
16:07:25 <cpehle> it won't let me give it the type word :: Stream s m t => ParsecT s u m String
16:07:55 <typoclass> nejucomo: i'd say, you get used to it. i'm more worried about this habit of people importing eleventy modules unqualified and the reader of the code having no idea where "f" came from ...
16:09:13 <typoclass> frontendloader: yes, should be IO. the only alternative i can think of is one of the new-fangle frp things
16:09:15 <nejucomo> Yeah.  I'm trying to be religious about explicit imports.
16:09:27 <applicative_> cpehle: what are you going to parse, strings, texts, bytestrings, ...
16:09:47 <nejucomo> In fact, I wish I had a tool that would parse, discover "ambient" references, determine which import they come from, then rewrite the imports to be explicit.  ;-)
16:10:01 <Peaker> nejucomo, -ddump-minimal-imports?
16:10:02 <nejucomo> -or perhaps simpler: parse, discover "ambient" references, then complain and exit.
16:10:21 <nejucomo> Peaker: No way!  That's awesome!
16:10:40 <Peaker> I dislike that it also adds import lists to qualified imports
16:10:43 <typoclass> nejucomo: my rule of thumb is to use plain imports for stuff from the base package, and "... as Xyz" for the more unusual stuff
16:10:46 <Peaker> and I always have to clean that up
16:10:55 <Peaker> And also, I like one import per line, so I can use sort-lines on my imports
16:10:58 <applicative_> cpehle: http://hackage.haskell.org/packages/archive/parsec/3.1.3/doc/html/Text-Parsec-String.html
16:10:59 <frontendloader> I'll have to check out the frp stuff then, I feel like IO is something to be avoided?
16:11:14 <applicative_> cpehle: if you call it Parser String, you shouldnt have a problem, for example
16:11:26 <Peaker> frontendloader, IO is the "sin bin".. used for stuff we don't understand well enough to abstract in a nice functional way
16:11:29 <typoclass> i agree that import lists are unnecessary in 99% of cases
16:11:51 <applicative_> frontendloader: why would you avoid IO
16:11:53 <Peaker> qualified imports avoid the need
16:12:03 <Peaker> applicative_, because IO has insane/complex semantics?
16:12:20 <pete_> IO in particular, or Monads?
16:12:28 <applicative_> Peaker: it can't be worse than, e.g. Python?
16:13:07 <pete_> this hotel has done some real bait-and-switch on the free coffee
16:13:10 * pete_ goes looking for more
16:13:24 <Peaker> applicative_, of course not
16:13:27 <nejucomo> Peaker: Yes, I also wanted this tool to lexically sort all modules and names imported, then to lay out the whitespace in a canonical manner.
16:13:30 <blackdog> so, i've been working on a combinator for bos's Configurator
16:13:31 <blackdog> https://gist.github.com/mwotton/5565313
16:13:32 <Peaker> applicative_, Python should be avoided much more than IO :)
16:13:42 * applicative_ rests his case ...
16:14:08 <typoclass> frontendloader: in my view, you should try to have clear separation between pure functions and IO in your programs. (there's probably something wrong if each of your functions is in IO.) but "avoid IO" is a bit much. not sure if that rule makes any sense :-)
16:14:17 <blackdog> am i missing something obvious there? I tried to do without the IORef, but couldn't see an obvious way, and the combinator seems useful - "run this action until the config changes, then boot up a new one with the new config")
16:14:41 <nejucomo> frontendloader: IO should be avoided at all costs.  The safest way is to not run your program.  You don't need a computer, just a notebook and a lot of time.  Good luck.  ;-p
16:14:50 * hackagebot cipher-aes128 0.3.1 - AES128 using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.3.1 (ThomasDuBuisson)
16:15:31 <nejucomo> I'm just kidding of course.
16:16:49 <nejucomo> One thing I found when I first started writing haskell was I had many functions which returned IO t, and over time I could remove the IO from callees, until I had fewer IO functions and more pure functions.
16:17:34 <nejucomo> -along the way I picked up many useful techniques.  Like a common starting place might be Control.Monad.
16:27:50 <dmj> What does "Constraint" mean when I type :k Functor in (* -> *) -> * -> *
16:28:02 <hpaste_> blaenk pasted “groupByYear” at http://hpaste.org/87860
16:28:17 <blaenk> anyone mind helping me out, I've created a monster I think :(
16:28:34 <shachaf> dmj: It's a GHC extension.
16:28:40 <shachaf> (I suppose kinds are a GHC extension in general.)
16:28:55 <shachaf> It means a constraint. As in a thing that you put on the left side of =>
16:28:55 <blaenk> in the paste, the last function (archivesList) does work, but I want to change it similar to what I've attempted
16:29:28 <blaenk> I've devolved to just slapping liftM's all over the place and essentially cargo culting so I figured I'd ask here before going any further
16:29:58 <dmj> shachaf: How come IdentityT doesn't have "Constraint" on its kind?
16:30:19 <shachaf> dmj: It's not a class.
16:30:24 <shachaf> Functor is a class.
16:32:00 <typoclass> blaenk: tangential question -- why is MonadMetadata m necessary in line 2? because of getItemUTC in line 7?
16:32:10 <blaenk> typoclass: yeah, that's correct
16:32:21 <typoclass> blaenk: right, thanks
16:32:25 <blaenk> I took that code largely from the hakyll source: http://hackage.haskell.org/packages/archive/hakyll/4.2.2.0/doc/html/src/Hakyll-Web-Template-List.html#recentFirst
16:32:31 <blaenk> the function 'chronological'
16:32:49 <blaenk> I want the same thing (well, the same as 'recentFirst' which is just a variation of it)
16:32:52 <blaenk> but I want them to be grouped by year
16:33:01 <dmj> shachaf: so type constructors and classes have kinds. The kinds ofclasses can be used to constrain type constructors?
16:33:31 <shachaf> dmj: Do you already understand types and classes and type constructors, and now you're trying to understand kinds?
16:33:40 <shachaf> Or what? I'm not sure what you're trying to figure out.
16:34:18 <shachaf> blaenk: Try writing groupByYear with do-notation first?
16:34:19 <dmj> shachaf: Yes
16:34:29 <blaenk> shachaf: I'll try that, thanks for the idea
16:34:44 <shachaf> liftM etc. can be used to simplify the definition when you already understand everything.
16:34:53 <blaenk> yeah I figured :S
16:34:54 <shachaf> They capture a pattern that you'll run into a lot.
16:35:10 <blaenk> any opinion on line 17?
16:35:14 <blaenk> I'll eventually need to do something like that
16:35:20 <blaenk> but I don't know if it's correct
16:35:39 <typoclass> blaenk: i haven't tried it, but i suggest instead of foldM, you use mapM. (or sequence.)
16:35:42 <typoclass> @type mapM
16:35:49 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
16:35:50 <typoclass> @type sequence
16:35:57 <lambdabot> Monad m => [m a] -> m [a]
16:36:09 <blaenk> ohh okay
16:36:14 <typoclass> blaenk: the types should be clear enough. you can then concat over the [b] list you got as a result. or something ...
16:36:29 <blaenk> alright thanks guys, I'll give this another try
16:37:34 <blaenk>     list    <- mapM (applyTemplateList itempTpl postCtx) posts
16:37:38 <blaenk> I bet that should work fine :D
16:37:54 <blaenk> now I'll try fixing groupedByYear
16:38:06 <blaenk> and yeah, then just concat that list I bet
16:38:45 <dmj> shachaf: types seems to be like typedefs in C, newtype is used only when you have one data constructor and this elminates boxing overhead at runtime. data is the standard way to make types and data constructors, which is a struct at the compiler level. I don't understand the importance of kinds and understanding type signatures is a weakness
16:39:26 <shachaf> dmj: OK, I don't think you should be worrying about this relatively recent GHC extension yet.
16:39:34 <shachaf> Just pretend that Functor doesn't have a kind.
16:40:29 <Ghoul_> tolerance filter :) quite proud lol
16:40:42 <Ghoul_> > filter (\x -> (<=) (abs $ x - 50) 10) [1..100]
16:40:47 <lambdabot>   mueval: ExitFailure 1
16:40:47 <lambdabot>  mueval: Prelude.undefined
16:41:01 <typoclass> Ghoul_: lambdabot seems to be on the fritz again
16:41:02 <dmj> shachaf: I need to know that Functors can only be made on types with kinds * -> * no?
16:41:06 <Ghoul_> :C
16:41:13 <shachaf> dmj: Yes.
16:41:22 <Cale> dmj: Kinds are like types, but one level up -- they just make sure that the types that you write make some amount of sense.
16:41:23 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:41:54 <Cale> dmj: For example, Maybe needs a type parameter, and just one, so  x :: Maybe  doesn't make sense, and  x :: Maybe Int Char  doesn't either
16:42:05 <Cale> and so the kind system prevents that kind of nonsense
16:42:50 <Cale> shachaf: What's Refl?
16:42:59 <shachaf> Cale: data Is a b where Refl :: Is a a
16:43:04 <Cale> oh, okay
16:43:12 <Cale> How would you use that from lambdabot?
16:43:14 <dmj> Cale: thank you
16:43:22 <Cale> Well, I can stick it in L.hs anyway
16:43:38 <shachaf> Thanks!
16:44:59 <Cale> @undefine
16:45:11 <Cale> I added #haskell-gsoc to the autojoin list
16:45:17 <Cale> :t Refl
16:45:26 <Cale> ...
16:45:26 <lambdabot> Not in scope: data constructor `Refl'
16:45:36 <Cale> wat
16:45:54 <Cale> @undefine
16:45:57 <shachaf> Whoops.
16:45:59 <Cale> :t Refl
16:46:05 <typoclass> > 42
16:46:06 <lambdabot> Not in scope: data constructor `Refl'
16:46:10 <lambdabot>   mueval: ExitFailure 1
16:46:11 <lambdabot>  mueval: Prelude.undefined
16:46:38 <Cale> @undefine
16:46:40 <Cale> > 1
16:46:45 <lambdabot>   mueval: ExitFailure 1
16:46:45 <lambdabot>  mueval: Prelude.undefined
16:46:51 <Cale> I don't understand why there's so much failure
16:46:51 <shachaf> @ty gcast Refl
16:46:55 <lambdabot> (Typeable b, Typeable a) => Maybe (Is a b)
16:47:07 <shachaf> Maybe lispy's Up To Something.
16:47:09 <Cale> There's supposed to be a 10 second limit
16:47:27 <Cale> I'm pretty sure it's failing quicker than that though
16:47:30 <Cale> I have no idea why
16:47:36 <typoclass> Cale: she's been availing herself of the bar again?
16:48:02 <Cale> :t Refl
16:48:07 <lambdabot> Is a a
16:48:10 <Cale> ...
16:48:11 <Cale> okay
16:48:13 <Cale> lol
16:48:14 <djahandarie> > 1
16:48:19 <lambdabot>   mueval: ExitFailure 1
16:48:20 <lambdabot>  mueval: Prelude.undefined
16:48:20 <cmccann> shachaf: gcast Refl is approximately 300% more awesome if you write the type as "Maybe (a `Is` b)".
16:48:22 <Cale> I didn't change anything
16:48:30 <djahandarie> :t Refl
16:48:33 <lambdabot> Is a a
16:48:35 <shachaf> cmccann: See if you can get Cale to turn on TypeOperators and call Is "=="
16:48:43 <shachaf> data a == b where
16:48:48 <Cale> I'm somewhat bitter about TypeOperators
16:48:53 <Cale> tbh
16:48:57 <shachaf> You and conal.
16:48:58 <jmcarthur> i both like and dislike the change
16:49:07 <blaenk> do x <- calc; return x is the same as just do calc?
16:49:10 <blaenk> or no?
16:49:11 <cmccann> Cale has good reason to hold a grudge against TypeOperators though.
16:49:12 <jmcarthur> i dislike that i can no longer use (~>) polymorphically
16:49:14 <shachaf> blaenk: Yep. That's one of the monad laws.
16:49:18 <blaenk> cool thanks
16:49:24 <shachaf> @google monad laws
16:49:25 <lambdabot> http://www.haskell.org/haskellwiki/Monad_laws
16:49:25 <lambdabot> Title: Monad laws - HaskellWiki
16:49:33 <Cale> I have thousands of lines of code which uses (~>) as a type variable
16:49:40 <Cale> ;___;
16:49:51 <shachaf> Yes, but I bet it's all Arrow code.
16:49:54 <Cale> yes
16:50:00 <conal> Yeah. I'm bummed also. Looking at uglifying my code right now. Disheartening.
16:50:11 <Cale> Well, it's funky extended arrow code.
16:50:12 <shachaf> hi conal
16:50:28 <typoclass> was that the thing where they removed the requirement for initial ":"?
16:50:29 <conal> I wish I'd pressed for a flag to resurrect the old syntax.
16:50:31 <Cale> We could probably just modify the preprocessor which we already require to do the necessary rewriting
16:50:39 <cmccann> to be fair, it makes things look much nicer with monomorphic types and type families and such.
16:50:47 <conal> shachaf: hi
16:50:56 <cmccann> no operators as type variables is annoying though.
16:51:02 <Cale> Maybe there should just be declarations of whether infix operators are constructors or not.
16:51:07 <jmcarthur> i also don't like how inconsistent the change is. why is the type level so special?
16:51:12 <conal> shachaf: going to bayhack next weekend?
16:51:17 <Cale> (at least at the type level)
16:51:33 <Cale> But also that would be pretty nice at the value level perhaps.
16:51:33 <cmccann> jmcarthur: the motivating case was, I think, stuff like + on type nats
16:51:37 <jmcarthur> Cale: maybe explicit quantification would be a reasonable way around?
16:51:40 <Peaker> Wasn't there a workaround for (~>) with "forall" prefixes or such?
16:51:44 <shachaf> conal: That is the plan.
16:51:51 <Cale> Like, we already have infix(l/r) declarations
16:51:58 <jmcarthur> Peaker: oh i hadn't heard about that.
16:51:59 <shachaf> Peaker: I don't think so.
16:52:02 <conal> shachaf: me, too
16:52:40 <Cale> infixr (~>) 9 as variable
16:52:52 <Cale> infixr (+) 5 as constructor
16:52:58 <Cale> or whatever
16:53:12 <Cale> With some sensible defaults
16:53:27 <jmcarthur> cmccann: yeah i know the motivating cases because i have already benefited from them. i just don't think they are motivating enough :\
16:53:31 <Cale> (I wouldn't care so much what the defaults were at that point)
16:53:38 <typoclass> Cale: previously, a leading ":" indicated constructor, right?
16:53:42 <Cale> yes
16:53:47 <cmccann> I wonder if it would actually be more consistent in a way if type families, type synonyms, and anything else that isn't injective were switched to being lowercase in general.
16:53:48 <typoclass> Cale: thanks
16:53:53 <conal> jmcarthur: ditto.
16:54:15 <jmcarthur> it *is* really nice to be able to use == at the type level at least
16:54:40 <cmccann> and reserve uppercase types for newtypes and data and such.
16:54:44 <Cale> cmccann: We should be able to define type families using the same syntax as function declarations.
16:54:53 <cmccann> Cale: that would be the obvious next step!
16:54:59 <jmcarthur> cmccann: yes. i have felt that way for some time
16:55:38 <jmcarthur> cmccann: of course then you have to quantify type variables, for sure
16:56:52 <cmccann> anyway, it seems to me that the most important distinction at the type level these days (with all the recent extensions in play) is whether something is legal partially applied as a type class instance and everything that goes along with that
16:57:05 <luite> need to run some more tests, then do unboxing of simple values (two constructor enums and one-constructor things that contain one value that is mapped to a JS number are just stored as a JS primitive directly, saves half the allocation for String)
16:57:06 <hpaste_> blaenk pasted “groupByYear” at http://hpaste.org/87864
16:57:10 <luite> oops
16:57:35 <blaenk> can someone please tell me why in that code, line 10's `items` parameter is inferred as [[Item String]] when I think it should be [Item String] ?
16:57:40 <Cale> I'm almost getting tired of the extremely gradual climb toward dependent typing, but I also have started to realise how inconvenient it is not to have really good type inference in dependently typed settings by playing around with Coq and writing a monad library.
16:57:57 <blaenk> I replaced the line numbers in the errors pasted below, but they're wrong (the line numbers), instead of line 11 it should be line 10 in the error messages
16:58:20 <Cale> It seems like it would be good if we at least moved to a full dependently typed core language.
16:58:54 <cmccann> isn't Core's type system already more expressive than Haskell's in some ways?
16:59:13 <typoclass> is it too late to add a flag to switch to the old ":" behavior?
16:59:31 <shachaf> cmccann: Haskell's or GHCwitheverything's?
16:59:59 <cmccann> the latter
17:00:01 <Cale> blaenk: Probably it's the type of compareYear
17:00:16 <conal> typoclass: I think it (flag) could be done. however, ghc 7.6.3 is just about to become standard for a good while, iiuc.
17:00:24 <Cale> blaenk: What's the type of compareYear? Give f an explicit type signature and you might get a better error message.
17:00:34 <typoclass> conal: hm ...
17:00:46 <conal> which is why i regret not pushing when 7.6.1 came out with the change.
17:00:47 <blaenk> Cale will do thanks. It's just meant to return a Bool, taking in an Item String
17:00:50 <Cale> (and do the same for compareYear)
17:00:52 <blaenk> I'll do that though and see what happens
17:01:04 <blaenk> *for compareYear that is
17:01:05 <Cale> blaenk: Well, f certainly doesn't produce a Bool
17:01:10 <blaenk> yeah meant for compareYear
17:01:17 <Cale> ah, yeah
17:01:29 <blaenk> what f does is it takes the parameter, gets the utc time and returns the year
17:01:36 <blaenk> so that compareYear can compare the items based on year
17:01:39 <Cale> but its parameters have whatever the type of parameter to f is
17:01:47 <blaenk> ok
17:01:48 <Cale> and f applies itemIdentifier to its parameter
17:01:55 <Cale> What's the type of itemIdentifier?
17:02:21 <blaenk> Identifier
17:02:33 <blaenk> it's meant to be passed as the second parameter to getItemUTC
17:02:34 <blaenk> oh, the whole type
17:02:45 <blaenk> itemIdentifier Item :: Identifier
17:02:50 <blaenk> itemIdentifier is a constructor for Item a
17:03:00 <blaenk> http://hackage.haskell.org/packages/archive/hakyll/4.2.2.0/doc/html/Hakyll-Core-Item.html
17:03:02 <typoclass> conal: yeah. well my lay opinion is that we should just open a ticket
17:03:21 <Cale> uhhh... maybe it's a field, but it can't be a constructor, because it's lowercase
17:03:34 <Cale> yeah, it's a field extractor
17:03:37 <blaenk> oh okay yeah field haha
17:03:39 <conal> typoclass: probably worthshile.
17:03:40 <Ghoul_> > filter (\x -> (<=) (abs $ x - 50) 10) [1..100]
17:03:44 <lambdabot>   [40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60]
17:03:48 <Cale> So, itemIdentifier :: Item a -> Identifier
17:04:02 <Ghoul_> @pl filter (\x -> (<=) (abs $ x - 50) 10) [1..100]
17:04:02 <lambdabot> filter ((<= 10) . abs . subtract 50) [1..100]
17:04:11 <blaenk> yep
17:04:25 <Ghoul_> Anyway to bring the 50 and the 10 out?
17:04:35 <Cale> So, f :: Item a -> m t for some m and t
17:04:47 <blaenk> exactly
17:04:53 <Ghoul_> @pl (\z y f -> filter (\x -> (<=) (abs $ x - z) y) f)
17:04:53 <lambdabot> (filter .) . flip . (((<=) . abs) .) . subtract
17:04:54 <Cale> and so compareYear :: Item a -> Item a -> Bool
17:05:16 <Cale> Maybe even Item a -> Item b -> Bool
17:05:18 <Ghoul_> > let f = (filter .) . flip . (((<=) . abs) .) . subtract in f 50 10 [1..100]
17:05:23 <lambdabot>   mueval: ExitFailure 1
17:05:23 <lambdabot>  mueval: Prelude.undefined
17:05:51 <Cale> But put that type signature in and make sure it really is that.
17:06:10 <blaenk> yeah already did and got a nice long list of errors, so I'll go through it for now haha
17:06:40 <Cale> blaenk: Usually as you add type signatures, it's able to report things more clearly
17:07:01 <blaenk> yeah I've noticed that, pretty helpful
17:07:10 <typoclass> Ghoul_: i think in this case, it's not worth it :-) pl is not worth the point and parens clutter. i'd go with \limit mid -> ... (<= limit) ... subtract mid ...
17:07:42 <Ghoul_> typoclass: thanks, but I was more interested in just seeing what it would look like :)
17:07:53 <Ghoul_> I tried to do it myself but it warped my brain
17:07:57 <Ghoul_> lambdabot is good at it :P
17:07:57 <blaenk> Cale: haha now I've got pretty much the same errors again, will paste
17:08:40 <hpaste_> blaenk revised “groupByYear”: “groupedByYear” at http://hpaste.org/87864
17:08:54 <johnw_> it would be good to drop the last point: \z y -> filter (\x -> abs (x - z) <= y)
17:09:08 <johnw_> (the f)
17:09:50 <blaenk> it's like somehow, posts on line 4 is [[Item String]]? but return type of recentFirst is [Item String]
17:10:25 <blaenk> well the return type of recentFirst is (MonadMetadata m, Functor m) => [Item a] -> m [Item a]
17:10:28 <blaenk> http://hackage.haskell.org/packages/archive/hakyll/4.2.2.0/doc/html/src/Hakyll-Web-Template-List.html#recentFirst
17:10:43 <typoclass> Ghoul_: sure. converting "f $ g x" to "f . g" in your head is easy. the stuff that's hard to do in your head also tends to be hard to read, imho
17:11:30 <blaenk> for reference, line 111 is line 10 in the paste
17:13:20 <blaenk> I think I have an idea, that it might be caused by the mapM line 5
17:13:21 <blaenk> *6
17:13:30 <blaenk> I'm probably using that wrong, gonna check
17:13:38 <blaenk> using that incorrectly I mean
17:14:14 <blaenk>  yeah it does look like I'm using it wrong
17:14:31 <blaenk> or hmmm
17:23:17 <blaenk> is it possible to add type annotations to do-notation code? how should it be done?
17:23:33 <blaenk> for example if I add the annotation before it's used, as I usually do outside of do-notation, I get 'not in scope'
17:23:35 <Peaker> blaenk, foo <- getLine :: IO String
17:23:40 <blaenk> oh okay thanks
17:23:48 <shachaf> blaenk: The scope thing is different.
17:23:54 <shachaf> It doesn't have to do with do-notation, I'm guessing.
17:24:06 <shachaf> (But I can't do more than guess because you didn't give an example. :-) )
17:24:33 <blaenk> if I have x <- some =<< operation :: thisType
17:24:39 <blaenk> what does thisType refer to, the whole thing to the right of <- ?
17:24:44 <blaenk> or just the last one, 'operation'
17:25:33 <Peaker> blaenk, whole thing
17:25:38 <blaenk> cool thanks
17:25:41 <Peaker> :: is lowest precedence
17:25:45 <blaenk> got it
17:29:01 <blaenk> ok I think I have a lead on to my problem haha
17:30:19 <blaenk> there's nothing syntactically wrong with this right?
17:30:20 <blaenk> list    <- mapM (applyTemplateList itemTpl postCtx :: [Item String] -> Compiler String) grouped :: Compiler [[Item String]]
17:30:26 <blaenk> meaning, I can make type annotations like that
17:30:32 <blaenk> nested within parentheses
17:30:45 <blaenk> seems like I can so I'll go with it
17:34:08 <Cale> blaenk: Yes, you absolutely can do that :)
17:34:25 <blaenk> yeah I found the source of my problem, I just have to figure out how to solve it haha
17:34:43 <blaenk> but yeah it was a type mismatch
17:34:44 <aavogt> blaenk: you should end up with a  Compiler [String]
17:34:52 <BMeph> blaenk: Yes. -- note: it's incorrect, but you can do type signatures that way.
17:35:05 <blaenk> oh, it's incorrect :{ and it helped me find my problem haha
17:35:07 <aavogt> or maybe you need anothe rmapM
17:35:18 <blaenk> aavogt: yeah!
17:35:43 <blaenk> the problem I'm having is that I'm using mapM (function return type Compiler String) [[Item String]]
17:36:01 <blaenk> I don't know if that's possible, to different monad types, or something
17:36:04 <blaenk> with mapM
17:36:05 <shachaf> I,I (mapM.mapM)
17:36:09 <blaenk> I'll paste to make it clearer
17:36:52 <blaenk> aavogt: oh okay, so you're saying that doing that, I'll end up with Compiler [String]
17:37:19 <BMeph> :t mapM -- heads up, blaenk :)
17:37:19 <blaenk> yeah that makes sense
17:37:22 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
17:37:39 <blaenk> yeah now I notice that :D
17:37:41 <aavogt> blaenk: if   (grouped :: [Item String]),which is apparently not the case
17:38:00 <blaenk> ohh okay, yeah grouped is actually [[Item String]], or it should be at least
17:38:02 <BMeph> aavogt: [[Item String]]
17:38:25 <copumpkin> [foo bar]
17:38:25 <aavogt> shachaf has the answer, as usual
17:38:38 <shachaf> You shouldn't use my answer unless you understand how it works.
17:38:44 <blaenk> what's it mean, what he said? oh okay, yeah I don't haha
17:38:51 <shachaf> It's better to expand it out first.
17:39:03 <shachaf> Make it work and then figure out why the short version works.
17:39:16 <blaenk> alright so I have [[Item String]], so one [Item String] gets passed to the function in mapM, which gets passed to applyTemplateList which should return a Compiler String
17:39:21 <shachaf> mapM means "do something for each thing". You have a list of lists.
17:39:25 <shachaf> Of items.
17:39:36 <shachaf> So for each list, you want to: For each item in this list, do something with this item.
17:39:36 <blaenk> yeah, applyTemplateList takes a list of items
17:39:41 <shachaf> That means you want to use mapM twice.
17:39:49 <blaenk> oh, really, hmm
17:40:23 <shachaf> First figure out what the regular mapM gives you.
17:40:23 <blaenk> I figured go through the list consisting of lists, because each 'sublist' (list within the list passed to mapM) is then passed to applyTemplateList to produce a Compiler String
17:40:45 <blaenk> oh okay mapM would give me Compiler [String]
17:41:13 <shachaf> I haven't actually been following, by the way. I just came in in the middle.
17:41:29 <shachaf> I think this code is a bit too complicated to be figuring out mapM with -- at least, it's too complicated for me to understand.
17:41:34 <shachaf> But you'll work it out eventually. :-)
17:41:44 <blaenk> oh haha, alright
17:42:02 <blaenk> yeah I'm only using mapM because it was suggested earlier, and it seems to make sense to use
17:42:29 <shachaf> Oh, mapM is good.
17:47:40 <no-n> @src replicateM
17:47:40 <lambdabot> replicateM n x = sequence (replicate n x)
17:48:14 <no-n> does the M stand for Monad?
17:48:21 <no-n> in mapM, replicateM, etc?
17:48:28 <simpson> no-n: Yes.
17:49:08 <simpson> no-n: Also _ for discarding results and only having effects: mapM_ filterM_ ...
17:49:16 <no-n> ah, yes
17:49:16 <shachaf> The _ stands for _.
17:49:29 <blaenk> haha applyTemplateList eventually uses mapM, so there's the second use of mapM you guys were suggested I would need
17:49:30 <hpc> @remember shachaf The _ stands for _.
17:49:31 <lambdabot> It is stored.
17:49:52 <shachaf> The first time I saw mapM_, I thought: In Haskell they have so many mapping functions that they've used up the entire alphabet and have had to start adding _s?
17:50:30 <hpc> shachaf: no, just _
17:50:35 <hpc> _s comes later
17:51:08 <shachaf> blaenk: Later on you can work out why
17:51:11 <shachaf> @ty mapM . mapM
17:51:12 <shachaf> works.
17:51:16 <lambdabot> Monad m => (a -> m b) -> [[a]] -> m [[b]]
17:51:40 <blaenk> oh I know what you meant about using it two times, what I was saying was that the function I was using with mapM already was doing it
17:51:53 <blaenk> I'm doing mapM (someFunc), and someFunc already does the second mapM for me
17:52:03 <hpc> i am remembering that double mapM trick
17:52:20 <shachaf> Right.
17:55:46 <Peaker> If Haskell does the Applicative=>Monad thing, we can deprecate mapM for traverse, rename sequenceA to sequence, get rid of "return" (use "pure") and have a lot fewer redundant functions...
17:56:03 <blaenk> sounds like a plan
17:56:09 <hpc> i would keep "return"
17:56:15 <hpc> but i love torturing the newbies :P
17:57:27 <shachaf> Peaker: Probably can't get rid of return :: Monad m => a -> m a, because of backwards compatibility.
17:57:32 <shachaf> Though we can not use it in new code.
17:57:38 <shachaf> Though "pure" is such an ugly name.
17:57:45 <Peaker> backwards compatibility can use a flag maybe
17:58:06 <hpc> or a new language version
17:58:19 <shachaf> I don't think so.
17:59:20 <hpaste_> blaenk revised “groupByYear”: “groupedByYear'” at http://hpaste.org/87864
17:59:28 <blaenk> anyone think they can see anything glaringly wrong?
17:59:32 <blaenk> through a quick skim perhaps?
17:59:51 <blaenk> annotated everything I could think of
18:01:05 <hpaste_> blaenk revised “groupByYear”: “groupedByYearRead” at http://hpaste.org/87864
18:01:13 <blaenk> maybe improved readability in that new paste
18:01:17 <blaenk> aligned type annotations
18:02:14 <blaenk> line 113 in errors is line 12 in paste
18:02:35 <blaenk> so still, somehow groupBy is being passed [[a]] instead of just [a]
18:02:45 <blaenk> if this is happening, shouldn't it error before that, in groupByYear, not in groupBy?
18:02:52 <blaenk> since groupByYear's type is that it expects [a]?
18:04:25 <blaenk> okay okay I think I know the problem but I'm not very familiar with this
18:04:40 <blaenk> I use groupedByYear using <-, doesn't that mean groupedByYear gets implicitly passed something else?
18:04:48 <blaenk> aside from just what I gave it
18:05:02 <blaenk> I'll see
18:05:04 <Peaker> blaenk, groupByYear says it returns    m [[.. ]]
18:05:20 <Peaker> blaenk, but it actually calls groupBy which doesn't wrap anything with any "m"
18:06:24 <blaenk> hmmm okay, I'm thinking just prepend with a `return`, but now I'm getting a cannot deduce (MonadMetadata m0) arising from use of 'f' from context (MonadMetadata m) bound by type signature groupedByYear etc.
18:06:33 <Peaker> blaenk, don't do that
18:06:39 <blaenk> shows what I know
18:06:40 <Peaker> blaenk, if you have some pure function "f"
18:06:45 <Peaker> blaenk, then its type should be pure
18:06:50 <blaenk> I see
18:06:59 <Peaker> blaenk, if you need to use it in a monadic context somewhere, do the "return" at that context
18:07:12 <Peaker> blaenk, or in your case, just use "let" rather than "<-" in the do block that uses it
18:07:22 <blaenk> ohh okay I see
18:07:35 <hpc> @let let = (<- return)
18:07:36 <lambdabot>   Parse error: =
18:07:45 <Peaker> blaenk, i.e: instead of: grouped <- groupedByYear posts   use   let grouped = groupedByYear posts
18:07:57 <Peaker> blaenk, in a "do" block you can have "let" lines too
18:08:08 <Peaker> blaenk, (separate from ordinary "let .. in .." expressions
18:08:10 <blaenk> Peaker: got it! will try that, what about the fact taht groupedByYear returns m [[a]] like you said? doesn't matter?
18:08:22 <Peaker> blaenk, it returns [[Item String]]
18:08:26 <Peaker> blaenk, you need to fix the type
18:08:29 <blaenk> got it
18:08:49 <blaenk> so I get rid of mention of MonadMetadata
18:09:05 <Peaker> blaenk, unless... you did it because of the call to getItemUTC in there?
18:09:09 <blaenk> yeah :/
18:09:20 <Peaker> blaenk, well, compareYear's type is wrong then
18:09:34 <Peaker> as is its body
18:09:43 <blaenk> it needs monadmetadata?
18:09:59 * hackagebot cellrenderer-cairo 1.0.0.0 - Cairo-based CellRenderer  http://hackage.haskell.org/package/cellrenderer-cairo-1.0.0.0 (JohnLato)
18:10:01 <blaenk> (MonadMetadata m) => Item String -> Item String -> m Bool
18:10:07 <Peaker> blaenk, f a == f b   tries to compare two "m Integer" values
18:10:19 <Peaker> blaenk, and they're probably not comparable
18:10:25 <blaenk> yeah, before I had liftM2 (==) (f a) (f b)
18:10:30 <Peaker> blaenk, yeah that makes more sense
18:10:32 <blaenk> but I didn't know if that was correct
18:10:33 <shachaf> That does not do what you think.
18:10:33 <blaenk> ok
18:10:36 <doomlord> am i the only one that finds haskells record system feels weird after years of c.. do you work around it by sticking to un-named elements (desstructure to acess), or just put up with naming little prefixes to disambiguate structure members
18:10:37 <blaenk> :{
18:10:50 <shachaf> Hmm.
18:10:53 <shachaf> Maybe it does.
18:11:14 <Peaker> doomlord, I use little prefixes, and don't find it that big a deal
18:11:42 <blaenk> Peaker: the problem now is that compareYear returns m Bool, what's the suggestion there?
18:11:49 <doomlord> i mean i did use little prefixes when i worked in 68k asm and one was just making offsets from register pointers :)
18:12:13 <blaenk> I bet I need to lift something else
18:12:20 <blaenk> or maybe use do notation
18:12:20 <doomlord> but there you could do a sort of single-inheritance and share the same names between different structures if they were in the same slot
18:12:23 <Peaker> blaenk, basically you need either a monadic version of groupBy or you need to mapM all the actions you need first, and groupBy afterwards
18:12:45 <Peaker> blaenk, probably the latter
18:13:19 <blaenk> I don't think I can mapM the stuff first, basically recentFirst returns a list of posts, which are usually then converted to html string with applyTemplateList
18:13:21 <doomlord> i suppose the little prefixes mean you can map them as functions to extract particular elements
18:13:27 <blaenk> but I want to group the list by year (the list returned by recentfirst)
18:13:39 <Peaker> blaenk, for example:  fmap (groupBy compareYear) $ mapM (getItemUTC defaultTimeLocale . itemIdentifier) items
18:13:42 <blaenk> and then applyTemplateList each list of posts grouped by year, into one big html string
18:13:51 <blaenk> okay I'll take a look at that thanks
18:14:26 <Peaker> blaenk, groupedByYear can first do a mapM over all the items to get all the years.. tho what I said is bad cause you lose the original item
18:14:55 <blaenk> yeah I need the item to then use it with applyTemplateList
18:15:26 <Peaker> blaenk, so more like:  addYear item = do { year <- fmap yearFromUTC . getItemUTC defaultTimeLocale $ itemIdentifier item ; return (year, item) }
18:16:03 <Peaker> blaenk, fmap (groupBy fst) $ mapM addYear items
18:16:28 <Peaker> blaenk, perhaps with a "map snd" thrown in after the groupBy to throw away the year
18:16:33 <blaenk> thanks I'll play around with that
18:16:45 <blaenk> that's actually how recentFirst is more or less implemented I think
18:16:54 <blaenk> Peaker: http://hackage.haskell.org/packages/archive/hakyll/4.2.2.0/doc/html/src/Hakyll-Web-Template-List.html#applyTemplateList
18:16:57 <blaenk> look at chronological
18:17:00 <dmj> is there a guide to all the language pragmas? i.e. MultiParamTypeClasses, FlexibleInstances
18:18:00 <johnw> dmj: some would call it the user manual
18:18:10 <Peaker> blaenk, yearFromUTC = (^. _1) . toGregorian . utctDay
18:18:28 <dmj> johnw: this piece? http://www.haskell.org/ghc/docs/latest/html/users_guide/
18:18:33 <blaenk> Peaker: will do
18:18:33 <johnw> yep
18:18:41 <johnw> it has a section on every pragma, every option, etc.
18:18:58 <Peaker> blaenk, yeah, chronological is very similar
18:19:15 <blaenk> Peaker: I was originally going to work with that, so that I didn't have to do getItemUTC twice per post, but it seemed daunting
18:19:22 <Peaker> blaenk, concat $ intersperse = intercalate
18:19:29 <Peaker> blaenk, use hlint...
18:19:44 <blaenk> that is, I was going to make my version of chronological that would also groupBy
18:19:47 <blaenk> Peaker: ?
18:19:49 <dmj> johnw: ahhhhh nice
18:19:51 <Peaker> blaenk, why daunting? Why not have the time inside the Item btw?
18:20:01 <Peaker> blaenk, ? ?
18:20:17 <blaenk> the concat thing
18:20:24 <Peaker> @src intercalate
18:20:24 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
18:20:40 <Peaker> blaenk, you have a    concat $ intersperse delimiter $  ...
18:20:52 <blaenk> that's not my code
18:20:54 <blaenk> that's from the hakyll source
18:20:58 <Peaker> oh whoops :)
18:21:36 <blaenk> I was saying that I was thinking of implementing my own version of chronological but it seemed too complicated, so I figured instead just group the results of chronological, but now after all this it seems simpler to just do that
18:21:47 <blaenk> that is, own version of chronological, since the code you suggested is very similar
18:22:15 <blaenk> probably won't be as difficult as I originally thought
18:22:30 <blaenk> also I wouldn't have to do getItemUTC twice per post, since it's already dont in chronological
18:24:13 <frankbro> Does anyone have a book to suggest? I've been reading "Programming erlang 2nd edition" lately and I love the mini-project driven approach. I didn't really enjoy "Learn you a haskell" much.
18:24:33 <blaenk> frankbro: real world haskell has projects
18:24:56 <popl> frankbro: http://www.haskell.org/onlinereport/
18:25:03 <blackdog> frankbro: LYAH is more about global understanding
18:25:07 <popl> oh, you said book
18:27:13 <frankbro> blaenk, looks sweet, thx
18:34:37 <applicative_> frankbro: some of the examples are a bit out of date -- partly thanks to the authors' improving some libraries, but people here can explain if something comes up with the rwh examples
18:39:37 <blaenk> Peaker: where can I look at information on that thing you suggested, (^. _1)? what's it called?
18:39:48 <johnw> a lens
18:39:53 <blaenk> oh ok
18:40:03 <frankbro> applicative_, thx (づ｡◕ ‿‿◕｡)づ
18:40:38 <no-n> (づ｡◕ ‿‿◕｡)づ
18:41:15 <no-n> and just like that, my plan to steal frankbro's emoticon had backfired when I clumsily pasted it into the same channel :3
18:41:16 <frankbro> >mfw I weaboo'd the channel
18:49:51 <haasn> :t ┐('～`；)┌
18:49:51 <lambdabot> fd:9: commitBuffer: invalid argument (invalid character)
18:56:30 <Shou> ヽ(ｏ`皿′ｏ)ﾉ
18:56:40 <Axman6> yes
18:58:10 <enigmuriatic> why doesn't ghci update in OS X after I reinstall the new version?
18:58:18 <mm_freak> is there a functor class for functors between Control.Category categories?
18:58:41 <johnw> mm_freak: interesting question!
18:58:52 <johnw> you mean, a natural transformation class?
18:59:01 <mm_freak> no, that would be between functors
18:59:15 <johnw> you want a CatFunctor class?
18:59:22 <Axman6> enigmuriatic: probabl;y because you've got two versions installed, and the earlier one appears first in yout PATH
18:59:35 <enigmuriatic> Axman6, how do i fix that?
19:00:03 <haasn> mm_freak: http://hackage.haskell.org/packages/archive/categories/1.0.5/doc/html/Control-Categorical-Functor.html ?
19:00:04 <mm_freak> yeah, something that generalizes:  cmap :: (a -> b) -> Kleisli m a b
19:00:05 <Axman6> run which ghci and see where it's installed first
19:00:35 <mm_freak> haasn: thanks
19:00:42 <geekosaur> installer should have told you to run unnstall on the older version
19:01:03 <geekosaur> although it might not find it if the older one was installed with fink/macports/homebrew
19:01:12 <geekosaur> in which case run the appropriate uninstall command
19:01:14 <enigmuriatic> it's telling me the directory name given isn't a directory when i try to cd to it...
19:01:45 <Axman6> enigmuriatic: what does it tell you?
19:01:50 * geekosaur wonders if they're trying to cd into the executable or somehting
19:02:01 <enigmuriatic> it tells me /usr/bin/ghci
19:02:03 <Axman6> my thought too
19:02:20 <tgeeky> or cd into a symlink?
19:02:35 <geekosaur> right, that's an executable, not a directory
19:02:41 <haasn> you can cd into a symlink
19:02:47 <geekosaur> (actually it's a symlink to a shell script)
19:02:57 <haasn> (as long as the target is a directory, obviously)
19:03:11 <tgeeky> if something ends in "/", it's a directory
19:03:17 <jbackus> @gwern mind if I pm you real quick?
19:03:17 <lambdabot> Unknown command, try @list
19:03:27 <geekosaur> um, not everything shows you trailing / for directory
19:03:47 <enigmuriatic> i think i figured it out
19:03:49 <enigmuriatic> thanks
19:03:52 <tgeeky> enigmuriatic: share!
19:04:13 <jbackus> Or is gwern afk
19:04:13 <enigmuriatic> found a bunch of old ghci stuff in bin, deleted, reinstalling
19:04:26 <danharaj> :t (<**>)
19:04:31 <lambdabot>     Ambiguous occurrence `<**>'
19:04:32 <lambdabot>     It could refer to either `Control.Applicative.<**>',
19:04:32 <lambdabot>                              imported from `Control.Applicative' at State/L.hs:4:1-26
19:04:42 <danharaj> :t Control.Applicative.<**>
19:04:50 <lambdabot> parse error on input `Control.Applicative.<**>'
19:05:12 <danharaj> lambdabot it is bad when hoogle is faster than you.
19:05:18 <geekosaur> :t (Control.Applicative.<**>)
19:05:26 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
19:05:38 <applicative_> enigmuriatic: mzero has a general find and delete osx haskell platform script somewhere
19:07:43 <enigmuriatic> now its telling me usr/bin/ghci isn't a directory
19:07:47 <enigmuriatic> when i try to run ghci
19:07:54 <enigmuriatic> but i ran the configure and the make install
19:10:24 <blaenk> neater way to write map (\ys -> map (\t -> fst t) ys) xs ?
19:10:49 <shachaf> map (map fst) xs
19:10:53 <blaenk> haha
19:10:55 <shachaf> (\blah -> foo blah) is the same as foo
19:11:05 <blaenk> oh duh
19:11:07 <blaenk> ;_;
19:11:16 <applicative_> /usr/bin is a directory enigmuriatic , is the .profile $PATH mistyped
19:11:34 <enigmuriatic> applicative_, i don't know what that means
19:13:17 <applicative_> enigmuriatic: i was just noticing no / before usr/bin and that it mentioned ghci as a directory not bin as the directory
19:13:38 * geekosaur doesn't see how running ghci could produce /usr/bin/ghci isn't a directory... what exactly are you typing and where?
19:13:50 <enigmuriatic> i just forgot it
19:14:06 <enigmuriatic> geekosaur, i'm just typing ghci in the terminal
19:14:17 <enigmuriatic> -bash: /usr/bin/ghci: No such file or directory
19:14:24 <blaenk> he probably has something in his profile where if he just types a word that's not a program, it tries to cd into it
19:14:26 <geekosaur> ohm that is not the same thing
19:14:27 <geekosaur> hash -r
19:14:31 <blaenk> maybe comes packaged with something like oh-my-zsh or something idk
19:14:42 <geekosaur> shells remember where they sw things, you removed it and it hasn't caught up yet
19:14:54 <geekosaur> lemme try that again
19:14:56 <geekosaur> type: hash -r
19:15:04 <geekosaur> then try running ghci again
19:15:38 <applicative_> oh thank god, unixboy is here
19:15:55 <enigmuriatic> oh weird, it works
19:16:02 <enigmuriatic> thanks geekosaur
19:16:07 <enigmuriatic> what exactly did that do?
19:16:20 <geekosaur> [12 22:14] <geekosaur> shells remember where they sw things, you removed it and it hasn't caught up yet
19:16:33 <enigmuriatic> i don't know what sw is
19:16:39 <geekosaur> "saw"
19:16:43 <geekosaur> sorry, typo
19:16:56 <geekosaur> anyway if you built ghc yourself it's probably in /usr/local/bin instead of /usr/bin
19:17:09 <geekosaur> but the shell saw it in /usr/bin before so you needed to tell it to forget that
19:25:45 <Jookia1> Hello! Is it possible to tell QuickCheck to test some specific values, along with its usual random haze? I don't want to miss them.
19:26:31 <simpson> Jookia1: Off the top of my head, you can control the order of any Arbitrary instance you define yourself, including newtypes...
19:26:40 <simpson> Jookia1: But that might be a little awkward. Dunno if there's a better way.
19:26:52 <cschneid> Jookia1: integrate hunit for targeted testing?
19:27:09 <Jookia1> Mmm...
19:28:00 <Jookia1> Quickcheck for the actual tests, and HUnit to just call specific tests to ensure they actually happen?
19:28:39 <cschneid> Jookia1: I don't know. I'm a haskell noob, but the feel of the two testing frameworks is different. hunit is "when x, then y result", and quickcheck is "hey, make sure it always passes this rule"
19:28:55 <cschneid> and there's no harm in using both. Even in the same test run. (hspec has integration for instance)
19:30:03 <Jookia1> Hmm, I suppose this would be a case where I want to HUnit then. I'm trying to test specific outputs, not general rules.
19:30:51 <cschneid> Jookia1: right. Use both. Plus a solid type setup to avoid even having the chance of some bugs. (not sure how to actually do that... but seems like a good idea)
19:32:20 <Jookia1> Well in this case I'm kind of on the edge of IO. I'm testing whether or not parsing options will give me expected settings on an Options data type
19:34:46 <cschneid> Jookia1: dunno. Minimize the amount of non-pure code involved? So minimal that it's trivial to look at and verify
19:35:19 <joe9> I am following this state monad tutorial: http://brandon.si/code/the-state-monad-a-tutorial-for-the-confused/, but, do not understand how the get and put functions there work. this is my version of the source code working off of the tutorial: http://codepad.org/FId2IMUD and this is the ghci error: http://codepad.org/srDCQLmk
19:35:27 <joe9> any thoughts on what I am missing, please?
19:35:41 <Jookia1> It's pure, though: http://sprunge.us/dOdN?haskell
19:38:03 <cschneid> Jookia1: that seems testable w/o ever involving IO right? So test it alone, and make sure your io layer is pretty skinny?
19:38:21 <Jookia1> mhm
19:38:28 <cschneid> Jookia1: I'm a heavy ruby tester, trying to feel around in haskell. So hell if I know what I'm talking about :)
19:39:08 <cmccann> man, why hotels gotta be so expensive.
19:41:16 <skuggi> joe9: in the put function you put the state in the wrong place
19:41:34 <Jookia1> On another note, does anybody here know how I'd import modules from my source code directory in to modules in my test source code directory
19:41:41 <skuggi> joe9: just swap the elements of tha pair.
19:50:03 * hackagebot cipher-aes128 0.3.2 - AES128 using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.3.2 (ThomasDuBuisson)
19:50:05 * hackagebot DRBG 0.4 - Deterministic random bit generator (aka RNG, PRNG) based  HMACs, Hashes, and Ciphers.  http://hackage.haskell.org/package/DRBG-0.4 (ThomasDuBuisson)
19:52:54 <dmj> why is liftM's type (a1 -> r) -> m a1 -> m r, and not (a -> b) -> m a -> m b
19:53:27 <dmj>  why is liftM's type (a1 -> r) -> m a1 -> m r, and not (a -> b) -> m a ->
19:53:28 <dmj>       m b
19:53:41 <zRecursive> seems no difference
19:53:50 <dmj> liftA and fmap use a -> b
19:54:09 <dmj> just curious why a1 and r were chosen
19:54:11 <tommd> Do any mac users want to help make sure the new "entropy" package won't break everything?
19:54:12 <lambdabot> tommd: You have 1 new message. '/msg lambdabot @messages' to read it.
19:54:19 <ParahSail1n> @src liftM
19:54:20 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:54:44 <dmj> ParahSail1n: woa, can you do that in ghci?
19:54:44 <ParahSail1n> they probably put those letters in there for the type signature
19:54:57 <dmj> the @src thing
19:54:59 <cmccann> tommd: isn't entropy breaking things called the second law of thermodynamics?
19:55:05 <ParahSail1n> dmj i dont think so
19:55:24 <tgeeky> cmccann: yes, though it breaks the (-1)st law first: conservation of information
19:55:25 <tommd> cmccann: That's a matter of definition (of the word "break")
19:56:06 <tommd> But seriously, I'd like to release "entropy" that uses the RDRAND instruction and would like to know if it breaks Macs (and thus, Macs wouldn't build Yesod and other large packages)
19:56:10 <dmj> ParahSail1n: how else do you get your source info? Do you use hoogle and have to open up a browser and waste 5 seconds?
19:56:29 <ParahSail1n> yeah, either that or lambdabot
19:57:05 <dmj> ParahSail1n: Can I do queries with lambdabot w/o everyone seeing?
19:57:08 <tommd> Or hoogle from the command line (and access that from vim/emacs/ghci)
19:57:16 <ParahSail1n> /msg lambdabot
19:57:17 <monochrom> yes, use pm
19:58:20 <dmj> I use haskell-mode, but when I M-x hoogle liftM it says , "process hoogle finished""
19:58:32 <dmj> browser doesn't open
19:59:09 <dmj> ~/Library/Haskell/bin/hoogle is where it's stored
19:59:26 <applicative_tmp> tommd what do we do on os x
20:00:52 <applicative_tmp> tommd: oh i see it on github, entropy
20:03:55 <applicative_tmp> tommd, it builds & installs properly
20:17:13 <pete_> So people are always saying how concise Haskell is
20:17:33 <pete_> But I've always felt it lacked the nice sharp angles you get in Perl
20:17:49 <pete_> So I decided to implement a recursive function for composing subrefs
20:17:50 <pete_> sub c {@_?sub{my($a,$b)=@_;sub{$b->($a->(@_))}}->(shift(@_),c(@_)):sub{@_};}
20:18:07 <pete_> tell me that isn't beautiful
20:18:35 <zRecursive> too ugly
20:18:55 <cmccann> that is certainly a piece of code which possesses a quantifiable amount of beauty.
20:19:06 <applicative_tmp> you can get haskell about that bad
20:19:23 <pete_> It's basically: map (.)
20:19:41 <applicative_tmp> beautiful, map (.) !
20:20:12 <pete_> I am planning to add this to some code that people actual use for things
20:21:44 <Watabou> hi everyone, I'm wondering what is the difference between takeWhile and filter. Both are similar to me and have the same type signature.
20:21:57 <Watabou> for example why can't I do this:    length (filter (<1000) (scanl1 (+) (map sqrt [1..]))) + 1
20:22:28 <Watabou> to find the number of elements it takes for the sum of the roots of all natural numbers to exceed 1000
20:22:40 <pete_> takeWhile stops when it stops being true
20:22:42 <dmj> Watabou, filter is applied to every element in the list, takeWhile
20:22:50 <dmj> 's predicate stops when it is no longer true
20:23:27 <Watabou> oh interesting, that's an important thing to know, thanks. I was wondering why the filter was running forever
20:23:31 <copumpkin> Watabou: it has no way of knowing that a value below 1000 won't appear five million elements of the input down the line
20:23:37 <copumpkin> you know that because you know that it's monotonically increasing
20:23:42 <Watabou> yeah
20:23:59 <copumpkin> but in fact, given the wrapping behavior of Int, it could actually produce more stuff later on :P
20:24:01 <copumpkin> assuming you instantiate that to Int
20:24:03 <Watabou> I see that now, that was pretty dumb of me, hah, thanks!
20:25:18 <cmccann> Watabou: that's a pretty common point of confusion actually
20:25:24 <dmj> Watabou: it's not dumb of you, they have the same type signature. Outside of playing with them and reading the source your best bet was to guess by their name.
20:26:18 <Watabou> yeah just reading the lyah book didn't tell me that, I actually had to try and see why it didn't work
20:27:39 <cmccann> Watabou: and beyond that, think about if you have a filter that removes every element in the list
20:28:20 <cmccann> Watabou: filter's implementation has no way of knowing whether that's the case in general, so it just keeps going hoping to find an element to keep
20:29:48 <Watabou> yeah, that's really interesting
20:30:04 * hackagebot monoid-subclasses 0.1.2 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.1.2 (MarioBlazevic)
20:31:18 <applicative_tmp> > maxBound :: Int
20:31:23 <lambdabot>   mueval: ExitFailure 1
20:31:24 <lambdabot>  mueval: Prelude.undefined
20:32:02 <Watabou> why was that an error applicative_tmp?
20:32:17 <cmccann> lambdabot is sulking.
20:32:31 <cmccann> I think Cale hurt lambdabot's feelings or something.
20:32:55 <cmccann> (by which I mean, I think lambdabot is broken)
20:32:55 <Watabou> oh haha because I tried that yesterday and it worked for me :o
20:33:41 <Cale> I'm not sure why
20:33:54 <Cale> The only thing I did was to *increase* the time limit
20:33:58 <cmccann> hahaha
20:50:02 <applicative_tmp> I take it "-Di386_HOST_ARCH=1" means, yes i386
20:51:58 <applicative_tmp> in any case cabal/ghc/cpp changes its mind to '-Dx86_64_HOST_ARCH=1' in the end...
20:52:16 <applicative_tmp> contradiction
20:52:19 <applicative_tmp> !
21:05:06 * hackagebot ghc-mod 1.12.5 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.12.5 (KazuYamamoto)
21:15:06 * hackagebot unix-time 0.1.7 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.1.7 (KazuYamamoto)
21:18:17 <mebaran151> anybody here know much about ghc-mod and emacs? I want to get the show type functionality to work but it to always throw an error
21:25:07 * hackagebot unix-time 0.1.8 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.1.8 (KazuYamamoto)
21:27:25 <dmj> mebaran151: what's the error
21:27:38 <dmj> mebaran151: are you using haskell-mode for emacs?
21:30:07 * hackagebot stm-chans 2.0.0 - Additional types of channels for STM.  http://hackage.haskell.org/package/stm-chans-2.0.0 (WrenThornton)
21:39:15 <johnw> yeah, knowing what error you're seeing is pretty essentially to us having any clue
21:53:01 <dmj> instance [safe] Functor ((,) a) -- where does [safe] come from?
21:54:58 <mebaran151> dmj: yep I'm using haskell-mode for emacs
21:55:23 <johnw> dmj: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/safe-haskell.html
21:55:23 <mebaran151> it mostly works but I'm trying to get ghc-mod to work with this Yesod project
21:55:26 <johnw> dmj: section 7.23.3
21:56:14 <shachaf> johnw: I don't think that's what that means.
21:56:50 <mebaran151> as far as I can tell, ghc-mod's show type fuction works on functions in the root directory, but if I go up a directory it gets confused and errors out
21:57:17 <dmj> mebaran151: What happens when you try C-c C-t ?
21:57:30 <dmj> johnw: thank you
21:57:37 <shachaf> It is about overlapping instances.
21:57:44 <shachaf> Nothing to do with SafeHaskell.
21:57:53 <mebaran151> dmj: ghc-show-type: Wrong type argument: listp, Dummy:0:0:Error:Could
21:58:51 <mebaran151> I also don't know how to get it to auto insert the nice declarations at the top when ghc-mod is active (C-u C-c C-t from haskell-mode looks like it stops working)
22:05:10 <XexonixXexillion> Is there a language extension that will let me define type T a b c = Either a (b,c) and then let me use (T a b) without requiring c?
22:05:49 <shachaf> T a b is already a thing. It has kind * -> *
22:06:01 <shachaf> Er, that's type.
22:06:06 <shachaf> Never mind.
22:06:09 <shachaf> No, there's no such thing.
22:06:55 <XexonixXexillion> So I just have to use newtype?
22:07:40 <shachaf> Hmm.
22:07:47 <shachaf> LiberalTypeSynonyms is a small exception to this rule.
22:09:55 <johnw> dmj: shachaf is right
22:10:08 <shachaf> That should go in the topic.
22:29:40 <arnsholt> GHC's garbage collector is something other than refcounting, right?
22:29:49 <shachaf> Yes.
22:30:24 <arnsholt> Excellent. Thanks!
22:30:49 <otters> I don't get conduit. I have a Source (ResourceT IO) ByteString and I want to get the length of the ByteSTring.
22:30:52 <otters> What do I do?
22:41:55 <Cale> arnsholt: It's a generational collector which is hybrid copy collector and mark/sweep. It is stop-the-world, but it runs in parallel.
22:45:55 <mebaran151> how does the ghc gc compare to something like the Java GC, basically similar designs no?
22:49:57 <dolio> No, I don't think so.
22:51:31 <dolio> They're designed with different use cases in mind.
22:51:54 <shachaf> I hear that one of the HotSpot people spent some time looking at GHC's GC and concluded there was a lot of room for improvement.
22:54:36 <blackdog> if a haskell thread is killed, is there anything that will clean up its open file handles?
22:54:43 <blackdog> (ghc, i mean)
22:55:15 <shachaf> "killing" a thread is just throwing it a KillThread exception.
22:55:20 <johnw> aristid: ping
22:56:03 <blackdog> shachaf: ok. so i need to set a handler for every thread to make sure it explicitly closes everything once it has finished?
22:56:34 <blackdog> i suppose i can't really rely on GC cleaning them up if i'm not running out of memory...
22:56:40 <shachaf> Well, I think bracket-style things like openFile should handle it anyway?
22:56:59 <johnw> or use ResourceT
22:57:01 <dolio> Why would you need to be running out of memory for GC to run?
22:57:20 <blackdog> dolio: i know very little about ghc's runtime - assumed that was the trigger for running gc
22:57:36 <dolio> That would be spectacularly crappy behavior.
22:58:16 <shachaf> Well, *relying* on GC running at a particular point is often a bad idea.
22:58:20 <dolio> Although if some of the posts on that stack bug report were any indication, that's what some people do expect.
22:58:45 <blackdog> dolio: well, perhaps not running out of memory - but presumably there's at least a level you break that suggests to the runtime to run a GC? If you never allocate anything, will the runtime still schedule collection?
22:58:46 <shachaf> Why would GC matter, anyway?
22:58:53 <shachaf> Unless you're using lazy I/O.
22:58:56 <tangentstorm> hey guys
22:59:08 <blackdog> shachaf: it was probably a silly path for me to go down.
22:59:26 <tangentstorm> is there any way we could get lambdabot to come hang out in #learnprogramming ?
22:59:46 <dolio> Yes, if you never allocate anything at all, GC may have a hard time running.
22:59:49 <tangentstorm> or... just any haskell-flavored irc bot that can evaluate haskell expressions?
22:59:57 <shachaf> tangentstorm: Cale would be the person to ask.
23:00:01 <dolio> But, if you never allocate anything at all, you probably won't be running out of file descriptors.
23:01:15 <blackdog> shachaf: but i think bracket looks like the right tool, thank you.
23:01:35 <shachaf> blackdog: withFile already uses bracket
23:01:45 <blackdog> shachaf: not reading from a file.
23:02:00 <dolio> It's also hard for GHC to preempt threads if you never allocate anything at all.
23:02:11 <dolio> At least in the non-threaded runtime.
23:02:14 <shachaf> blackdog: OK. But that sort of thing.
23:02:15 <dolio> Not sure about the threaded one.
23:02:32 <shachaf> The threaded one has trouble too.
23:03:56 <Cale> tangentstorm: I can make lambdabot join. Do you want it permanently, or just for now?
23:04:03 <zRecursive> @ty withBinaryFile
23:04:06 <lambdabot> Not in scope: `withBinaryFile'
23:04:48 <zRecursive> @ty System.IO.withBinaryFile
23:04:52 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> IO r) -> IO r
23:05:03 <shachaf> @ty System.IO.withFile
23:05:06 <tangentstorm> Cale, shachaf : thanks!
23:05:06 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> IO r) -> IO r
23:05:32 <Cale> lambdabot: @join #learnprogramming
23:05:32 <shachaf> withBinaryFile :: FilePath -> IOMore -> ContT r IO Handle
23:06:05 <tangentstorm> Cale: um... can we just try it for a bit? i'd love to have it around permanently but we have another bot in there and i'm worried the url shortening stuff, etc might cause problems.
23:06:14 <Cale> okay, cool
23:06:19 <tangentstorm> thanks :)
23:06:41 <zRecursive> @unmtl ContT r IO Handle
23:06:41 <lambdabot> (Handle -> IO r) -> IO r
23:13:32 <blackdog> shachaf: hrm. this is very strange: even when i use withSocket from zeromq3-haskell, which uses bracket in its definition, killing the thread running it doesn't seem to lead to the fd being closed.
23:13:59 <blackdog> admittedly i'm actually killing its parent thread - would the child threads also receive the exception?
23:14:26 <shachaf> No?
23:14:30 <shachaf> There's no such thing as a parent thread.
23:20:55 <blackdog> shachaf: ... yes, you're right. i am not having a good day with modelling this stuff today.
23:23:30 <hpaste_> “Dharmender Kumar” pasted “Best Sports Nutrition Courses in Mumbai” at http://hpaste.org/87873
23:26:31 <shachaf> chrisdone...
23:26:46 <shachaf> Someone ought to do something about this.
23:27:23 <djahandarie> You could try pinging him on twitter.
23:28:21 <shachaf> djahandarie: You don't even follow me on Twitter!
23:28:53 <djahandarie> You've never tweeted anything.
23:29:12 <arkeet> it's no use following *after* he tweets.
23:29:15 <shachaf> djahandarie: Untrue.
23:29:21 <arkeet> what if he only ever tweets once and you aren't there for it?
23:29:34 <shachaf> I tweeted and then deleted it.
23:29:43 <epta> smart
23:30:07 <popl> shachaf: that's a definite way to drive someone crazy
23:34:01 <johnw> lispy: do you use Orc?
23:40:14 * hackagebot robot 1.1 - Simulate keyboard and mouse events  http://hackage.haskell.org/package/robot-1.1 (ChrisWong)
23:44:19 <chairs> silasm
23:56:19 <arnsholt> Cale: Cool. Not refcounting was the most important (since I'm going to make some structures with cycles and would like my data to be GCed) but detail is always good to have =)
23:57:18 <shachaf> Yes, GHC can definitely GC cyclical data.
23:58:00 <shachaf> Though that's an odd way of putting that question. Some GCs use refcounting and also other things, and can handle cycles. You should've just asked about cycles. :-)
23:58:36 <arnsholt> True, true
23:58:56 <arnsholt> I'll use asking the question early in the morning as my excuse =)
