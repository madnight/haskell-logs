00:00:11 <applicative_> Watabou: well you'll see.  guards are closer to if then else really
00:00:19 <silasm> Watabou: what do you mean "in the real world"? Pattern matching is typically used where possible, but it's use is a little limited
00:00:21 <shachaf> arkeet: In Common Lisp lists are terminated by the atom 'NIL.
00:01:04 <silasm> Watabou: e.g., you can't use f a a = result to match the case where f is called with two equivalent arguments :/
00:01:16 <Watabou> silasm: yeah I just meant if it's a good programming practice that people use
00:01:20 <silasm> maybe with a compiler extension of some sort you could make that work.
00:01:38 <applicative_> the real world is for people who cant handle pattern matching, Watabou
00:01:48 <Watabou> haha okay
00:02:19 <arkeet> pattern guards are good.
00:02:44 <shachaf> silasm: I'm glad that's not allowed.
00:03:24 <djahandarie> silasm, how would that even work?
00:03:45 <arkeet> f a a = e  might be sugar for  f a a' | a == a' = e
00:03:47 <arkeet> or something.
00:03:57 <silasm> djahandarie: i dunno, only work on instances of Eq of the same type. What arkeet said.
00:04:07 <Watabou> yeah arkeet. just got to that section in lyah. the bmi programm in it seems a bit like switch statement in other languages.
00:04:28 <djahandarie> I'm not sure why hiding an Eq requirement like that is desirable at all.
00:04:41 <arkeet> djahandarie: do you think f 0 = ... is evil?
00:05:03 <arkeet> I agree though, I don't want to be able to write  f a a =
00:05:13 <silasm> djahandarie: yeah, it'd be weird. I really don't mind having it, it's just something that trips me up every once in a while. Sometimes I wish pattern matching had things like that. But guards are good enough as it is :).
00:05:16 <shachaf> arkeet: It's mildly evil but it's OK.
00:05:35 <shachaf> Also, there's some real trickiness with making f a a = ... work
00:05:41 <silasm> s/having it/not having it/g
00:06:12 <shachaf> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/PAGES/065.HTM
00:08:45 <zRecursive> head==car, tail==cdr right ?
00:09:30 <silasm> shachaf: makes sense.
00:09:34 <kostja> shachaf: http://pastebin.com/UQiFyb9q thank you!
00:09:45 <mauke> The paste UQiFyb9q has been copied to http://hpaste.org/87312
00:09:54 <shachaf> No instance for Eq ([a] -> [a]) arising from a use of `=='
00:10:27 <shachaf> @src sequence
00:10:28 <lambdabot> sequence []     = return []
00:10:28 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
00:10:28 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
00:11:08 <shachaf> Or: sequence [] = return []; sequence (m:ms) = m >>= (\x -> sequence ms >>= (\xs -> return (x:xs)))
00:11:43 <Watabou> :t sum
00:11:45 <lambdabot> Num a => [a] -> a
00:11:54 <Watabou> Why is that Num a and not Num [a]
00:12:09 <shachaf> Why would it be Num [a]?
00:12:12 <kostja> ok, my trouble was really binding to an operator
00:12:23 <djahandarie> arkeet, yes, if the function is left to be fully polymorphic. I think that is not very nice and there should be a better solution than having Eq sneak in.
00:12:27 <Watabou> I thought it worked on a list
00:12:31 <applicative_> its not the particular list of as thats a number but the a
00:14:13 <djahandarie> I don't really like the whole situation with numbers anyways. I wish there was an easier way to work with unary representations of numbers without things getting hellishly inefficient.
00:14:45 <applicative_> Watabou: as a first approximation, the way to read sum  :: Num a => [a] -> a is something like, for any numerical type a, sum :: [a] -> a
00:15:08 <kostja> shachaf: isn't there a rule, that binding to a return is the same as calling the function directly?
00:15:24 <Ghoul_> anyone know how to bench a piece of code
00:15:27 <kostja> shachaf: or is the return here at the wrong position?
00:15:29 <arkeet> Ghoul_: criterion
00:15:33 <Watabou> applicative_: right but a here is a list is it not?
00:15:43 <Ghoul_> Anyone know how to bench a piece of code for time taken
00:15:47 <arkeet> Ghoul_: criterion
00:15:59 * hackagebot indexed-free 0.2.1 - indexed monads for free  http://hackage.haskell.org/package/indexed-free-0.2.1 (FumiakiKinoshita)
00:16:04 <applicative_> No, Watabou good readings of 'a' are: Int, Integer, Float, Double
00:16:06 <Watabou> oh you mean the things in the list
00:16:24 <applicative_> Watabou: those are the builtin types that are in the Num class
00:16:35 <Watabou> yeah, I know
00:16:49 <applicative_> sum takes you from a list of such things to a single such thing
00:17:03 <Ghoul_> Sorry, my IRC broke and I couldn't see messages going through
00:17:21 <Ghoul_> arkeet: I want to know the time taken if the code were compiled under -O2
00:17:23 <applicative_> > sum [1::Int, 2, 3]
00:17:27 <lambdabot>   6
00:17:29 <Watabou> ah okay, got it and that's why it's not Num [a] otherwise it will work on a lit of lists?
00:17:32 <arkeet> ok, then compile it with -O2 and use criterion.
00:17:35 <Watabou> s/lit/list
00:17:42 <applicative_> > sum [1::Integer, 2, 3]
00:17:44 <Ghoul_> Oh, criterion is a thing, gotcha :)
00:17:45 <arkeet> er, the other way around.
00:17:46 <lambdabot>   6
00:17:56 <applicative_> > sum [1::Float, 2, 3]
00:17:58 <lambdabot>   6.0
00:18:19 <Watabou> okay
00:18:48 <applicative_> Watabou: yes, you could somehow make a Num instance for lists, or lists of things that have a Num instance or are numerical
00:19:06 <kostja> shachaf: thank you very much!
00:19:29 <shachaf> kostja: blah >>= (\x -> return x) is the same as blah.
00:19:34 <Watabou> applicative_: got it thanks
00:19:44 <applicative_> you'd have to figure out how to add and multiply these lists and what the lists called 0 , 1 , 2 ... are
00:19:45 <shachaf> kostja: blah >>= (\x -> return (x:xs)) is not.
00:20:42 <kostja> shachaf: ok, I see. thank you
00:20:59 * hackagebot free-game 0.9.3 - Create graphical applications for free  http://hackage.haskell.org/package/free-game-0.9.3 (FumiakiKinoshita)
00:22:24 <applicative_> Ghoul_: https://github.com/bos/criterion/blob/master/examples/Fibber.hs is almost self-explanatory
00:27:19 <kostja> shachaf: can one say, that the way to manipulate something in a monad is to make a do block, fetch the values with a '<-', do the algebraic operations and then end with a 'return'
00:27:57 <shachaf> Sometimes.
00:28:30 <kostja> :)
00:29:43 <silasm> http://learnyouahaskell.com/input-and-output does the "copyFile" function here read and write chunk by chunk automatically, or will it overflow on large inputs?
00:30:14 <arkeet> silasm: it'll use constant space, because of lazy IO.
00:30:28 <simpson> Is there a package that helps one write finite-domain or constraint solvers as standalone executables, with things like printing statistics to the console and such?
00:30:31 <arkeet> but lazy IO is tricky and it's easy to accidentally make it less lazy than you intended.
00:30:44 <silasm> arkeet: neat. Does the same apply to B.hGetContents and B.hPutContents?
00:30:54 <arkeet> for a lazy bytestring? I think so.
00:31:00 <Ghoul_> applicative_: I have the situation where I need to load my sample data from a file
00:31:04 <Ghoul_> I've got this so far
00:31:13 <simpson> I'm admittedly used to `print "%d iterations/second" % iterations"`, but that's not really possible here. :3
00:31:20 <applicative_> silasm: if it is Data.ByteString , not Data.ByteString.Lazy, no
00:31:26 <Ghoul_> http://hpaste.org/87313
00:31:35 <arkeet> yes, strict bytestrings are not lazy.
00:31:38 <coppro> why is unsafeinterleaveio unsafe?
00:31:44 <silasm> arkeet: I'll keep that in mind. Trying to implement lz78 compression. applicative_ : it's lazy.
00:31:45 <Ghoul_> I need to convert the IO String into a String or criterion won't eat it
00:31:51 <Ghoul_> I'm not sure how..
00:31:55 <hpaste> “Dharmender Kumar” pasted “Medical Clothing services in your city” at http://hpaste.org/87314
00:32:02 <silasm> just seems a little too magical
00:32:52 <silasm> so would it be wrong to view a lazy B.hGetContents into a lazy B.hPutStr as sort of a connected pipe through which data flows?
00:32:59 <arkeet> Ghoul_: no, you just need to use something other than whnf.
00:33:04 <simpson> coppro: It changes the order of operations in IO.
00:33:05 <arkeet> look in the criterion docs to see what.
00:33:26 <Ghoul_> ok
00:33:37 <applicative_> Ghoul_: you shoiuld extract the string in main before you get to defaultMain
00:33:57 <coppro> simpson: is it unsafePerformIO levels of unsafe, or is it just that things might interleave weirdly?
00:34:25 <applicative_> main = do tst <- readFile "test2.txt"; defaultMain [ .. ..   . tst .. tst ...]
00:34:27 <simpson> coppro: I could see a not-so-contrived operation that has to happen in a certain order or things go horribly wrong.
00:34:32 <simpson> coppro: Saving a file to disk, for example.
00:34:41 <arkeet> applicative_: unless he's trying to benchmark reading the file.
00:35:08 <coppro> simpson: but you can't do something dumb like break type safety right?
00:35:11 <arkeet> which sounds like not a thing to do.
00:35:15 <applicative_> arkeet: yes indeed. I had a picture of comparing algorithms on a definite pile of data
00:36:06 <simpson> coppro: Not sure. I wouldn't think so, but I'm no expert.
00:36:42 <elliott> unsafeInterleaveIO :: IO a -> IO a, so it'd be quite a feat for it to break type safety
00:36:52 <coppro> elliott: i dunno
00:36:55 <coppro> i r d m
00:41:15 <applicative_> Ghoul_: here's a possibly lame example http://hpaste.org/66050
00:42:32 <Ghoul_> applicative_: yeah, I figured it out :) thanks
00:42:47 <Ghoul_> Under windows I can't benchmark my thing stable enough though, I don't think
00:43:04 <Ghoul_> It varies by 10ms (~50%) even though I give the same pure function the same input
00:49:52 * applicative_ hadn't noticed bos's tirade http://www.serpentine.com/blog/2013/04/30/big-fucking-deal/
00:54:08 <simpson> Ha.
00:56:01 * hackagebot yackage 0.7.0 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.7.0 (MichaelSnoyman)
01:11:04 <Reite> Im looking for a datastructure where I can do fast lookup of all item inside a closed interval. For example I have a big list of floats and I want to find all of them between 12.35 and 15.52. Should work with all instances of Ord. Im thinking the best might be to make a search tree to find the lower bound, and then keep a link between all the ordered items so I can traverse them until I reach
01:11:04 <Reite> my upper bound.
01:12:26 <johnw> Reite: maybe an attributed tree could solve this, where each node indicates the minimum of all nodes on its left, and the maximum of all nodes on its right
01:12:51 <Reite> My use case is that I have a 2 big lists of records and for every record in l1 I want to find all records in l2 where a specified field is withing the interval. So the construction cost doesnt matter but the lookup cost needs to be very efficient
01:13:41 <Reite> johnw: thanks I will have a look at it!
01:14:06 <johnw> if you are googling, it is often called an "augemented tree"
01:14:12 <johnw> augmented
01:16:52 <silasm> is there a more general foldM that works on foldables other than lists?
01:16:59 <johnw> yes
01:17:02 <johnw> look at Data.Foldable
01:17:15 <silasm> johnw: will do, thanks
01:17:20 <shachaf> Data.Foldable has foldlM and foldrM
01:17:38 <shachaf> Becase some Foldable structure isn't necessarily biased the same way a list is.
01:17:50 <shachaf> Similary, foldr' and foldl'
01:28:51 <silasm> shachaf: seems to be exactly what I was looking for. Now I just hope what I'm doing works properly with lazy I/O.
01:31:02 <latermuse> where is the IO monad defined?
01:31:46 <shachaf> In the Haskell Report.
01:31:47 <mauke> do you mean IO itself or the monad instance?
01:31:53 <latermuse> IO itself
01:31:53 <shachaf> Alternatively, nowhere.
01:32:03 <latermuse> or the monad instance, if that was a trick question
01:32:07 <latermuse> :)
01:32:08 <mauke> what
01:32:26 <mauke> do you have any idea what you're asking?
01:32:29 <latermuse> for instance the type: a -> b -> IO ()
01:32:33 <shachaf> ?
01:32:33 <latermuse> where is "IO ()" defined?
01:32:38 <arbn> latermuse: System.IO might be what you're looking for.
01:33:43 <mauke> latermuse: GHC.Types, maybe
01:34:01 <latermuse> Ah! GHC.Types sounds about right
01:34:46 <shachaf> latermuse: :i in ghci will answer all your questions.
01:35:29 <latermuse> wow thanks! thats exactly what i was looking for shachaf!
01:35:44 <latermuse> instance Monad IO -- Defined in `GHC.Base'
01:35:44 <arbn> Except for the questions that only lambdabot can answer.
01:37:48 <arbn> QuickCheck just revealed to me the startling fact that converting to and back from a CString is lossy if the string contains null. :P
01:38:05 <shachaf> quickcheck++
01:38:19 <johnw> arbn: yes, I've run into that before
01:38:38 <johnw> with ByteString, packCString and packCStringLen can give very different results because of this :)
01:49:04 <hpaste> hamid pasted “I know it's possible to do the comment one but how? with Typeclasses?” at http://hpaste.org/87315
01:49:59 <hamid> any idea about the pasted code?
01:50:04 <mauke> hamid: it's not possible
01:50:09 <shachaf> print $ chainFunctions ((+1) >>> (+310) >>> (+3) >>> show >>> print) 0
01:50:18 <mauke> hah
01:50:30 <mauke> shachaf: needs more [ ]
01:50:46 <hamid> @src (>>>)
01:50:47 <lambdabot> Source not found. :(
01:50:58 <arbn> That's Arrow composition?
01:51:17 <elliott> used on (->)
01:51:43 <mauke> function composition
01:51:59 <mauke> :t [(+1) >>> (+310) >>> (+3) >>> show >>> print]
01:52:01 <lambdabot> (Num b, Show b) => [b -> IO ()]
01:52:07 <shachaf> mauke: let [a] & [b] = [b . a]; chainFunctions = head in print $ chainFunctions ([(+1)] & [(+310)] & [(+3)] & [show] & [print]) 0
01:52:27 <raid> Can I check for value constructors in if's and/or guards?
01:52:47 <mauke> raid: not directly
01:52:49 <shachaf> You can in guards: ... | Just x <- y = ...
01:53:02 <raid> the only way is case of and pattern matching?
01:53:03 <shachaf> But not in ifs. And, really, case is better.
01:53:20 <arbn> raid: The only way is pattern-matching. They're patterns. :P
01:53:21 <mauke> raid: case/of is pattern matching
01:53:45 <raid> arbn: i c, thx
01:54:12 <hamid> :i (>>>)
01:54:25 <hamid> where is this? monad?
01:54:30 <latro`a> arrow
01:54:32 <arbn> hamid: Arrow
01:54:36 <shachaf> let a >>> b = b . a
01:54:37 <shachaf> hth
01:54:59 <hamid> oh thanks
01:55:30 <latro`a> (that's not what (>>>) always means, though it is what it means for (->))
01:55:57 <shachaf> latro`a: It's what it always means in real code. hth
01:56:19 <shachaf> OK, (>>>) actually works for Category, not just Arrow.
01:56:20 <quchen> Well, it's Category's ".". hth. (<- we add "hth" to each sentence now?)
01:56:39 <shachaf> Category is a bit more justifiable than Arrow.
01:56:52 <arbn> shachaf: Arrow re-exports it as (>>>), although it's defined in Category, I thought?
01:56:57 * arbn has used Arrow in real code.
01:57:11 <latermuse> i love using arrow
01:58:39 <latro`a> what is "hth"
01:59:00 <hamid> so it's not really possible to do such a things with functions  with different signitures ?  [(+1), show, print]
01:59:14 <arbn> latro`a: http://www.urbandictionary.com/define.php?term=HTH ?
01:59:14 <latro`a> you can build heterogeneous containers
01:59:15 <shachaf> That list is a type error.
01:59:22 <latro`a> but [a] is not the type for the job
01:59:25 <shachaf> So you can't use that syntax.
01:59:41 <hamid> shachaf, yes but can't typeclasses help here?
01:59:58 <latro`a> no; lists only contain one type
02:00:16 <shachaf> No, because [foo, bar] is already a type error when foo and bar have mismatching types.
02:00:37 <latro`a> you could have a polymorphic list, one of type Foo a => [a], but then for any choice of a all the types inside are the same
02:00:46 <shachaf> Maybe you could do something like [blah show, blah (+1), blah hmm]
02:00:54 <latro`a> for example you could have a Num a => [a], then it could become instantiated as [Int] or [Double] or ...
02:00:55 <shachaf> But not [show, (+1), [...]]
02:01:02 <m3ga> is it correct that modules listed under Other-Modules in a cabal file are not available outside the package which defines them?
02:01:15 <shachaf> And you can also use another list syntax: (show `myCons` (+1) `myCons` myNil)
02:01:16 <hychen> Hi
02:01:16 <hamid> i meant something like this>  foo :: Chainable a => [a]
02:01:17 <hychen> Hi
02:01:20 <arbn> m3ga: Yes.
02:01:20 <hychen> Hi
02:01:22 <shachaf> But at this point you gain nothing over using (.) itself.
02:01:22 <hychen> Hi
02:01:31 <m3ga> arbn: thanks
02:01:32 <hychen> Hi
02:01:34 <latro`a> hamid: any instance of that will have the same type in the whole list
02:01:34 <hychen> Hi
02:01:57 <hamid> Yep, Got it.
02:01:58 <hychen> Hi
02:02:01 --- mode: ChanServ set +o mauke
02:02:03 --- kick: hychen was kicked by mauke (hychen)
02:03:14 <hamid> shachaf, how is that type? [blah show, blah (+1), blah hmm]. That kinda helps me understand to write monads and types like this :P
02:03:34 <mauke> this has nothing to do with monads
02:03:47 <shachaf> I don't know. You'd have to figure out what blah is. Maybe it's possible, maybe it's not.
02:04:03 --- mode: mauke set -o mauke
02:04:06 <FireFly> blah = const 1  -- ta-daa
02:04:14 <shachaf> For example maybe blah is toDyn and then you look at all the types and do awful things with that.
02:04:31 <hamid> shachaf, it is indeed :D
02:05:02 <shachaf> ?
02:05:14 <shachaf> Anyway, the point is that the thing you asked for can't be done.
02:05:15 <arbn> Or maybe blah involves an existential type.
02:05:25 <shachaf> GHC doesn't have first-class existentials.
02:05:39 <hamid> arbn, what's that? :/
02:05:44 <hychen> ['#haskell', '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down,try: http://hdiff.luite.com "]']
02:05:58 --- mode: ChanServ set +o shachaf
02:06:01 <arbn> hamid: Google can help with questions like that.
02:06:01 --- mode: shachaf set +b *!*hychen@175.41.48.*
02:06:02 --- kick: hychen was kicked by shachaf (hychen)
02:06:08 <hamid> arbn, ok
02:06:10 --- mode: shachaf set -o shachaf
02:06:30 <yitz> FireFly: blah = undefined would also work
02:06:45 <shachaf> And it's possible that existential types solve this but it's not quite as simple as people generally think.
02:07:34 <mauke> CTCP VERSION reply from hychen: xchat 2.8.8 Ubuntu
02:07:37 <mauke> oh wow
02:07:53 <shachaf> ?
02:08:15 <mauke> that means someone is manually copying and pasting stuff
02:10:50 <hamid> "[(+1), (+310), (-3), show, print]" -> i wanted to do something like (>>>). type of first function's input need to matches next function's input.
02:11:07 * hackagebot hspec-jenkins 0.1.1 - Jenkins-friendly XML formatter for Hspec  http://hackage.haskell.org/package/hspec-jenkins-0.1.1 (KoheiSuzuki)
02:14:22 <quchen> hamid: You can do something like that with endomorphisms (a -> a functions) using `foldr (.) id`.
02:15:16 <quchen> For functions that "typecheck when chained pairwise" there's no type, so your general list isn't possible.
02:16:46 <latro`a> what you're thinking of is really a tuple
02:17:00 <latro`a> or at least most straightforwardly a tuple
02:17:10 <latro`a> (a->b,b->c,c->d,...)
02:17:22 <quchen> hamid: A simple proof for that: suppose you have a list of type [Chainable], and you write such a list that maps an Int to a String through a chain. This would be something along the lines of "[Int ~~> String]".
02:18:22 <quchen> Now that you have such a hypothetical list, you should always be able to concatenate two of them. But that would give you a "[Int ~~> String, Int ~~> String]" thing, so somewhere along the way you've got a collision of a String and an Int.]
02:19:27 <quchen> Or alternatively, here's the shorter version: if you feel like you need a heterogeneous list: redesign your solution. ;-)
02:21:52 <hamid> quchen, I really don't think I need one. It just helps me to understand this whole thing better. :P actually that (>>>) is what solves problems! and haskell is curried by default no need to do that :P
02:22:20 <hamid> thank you haskellers.
02:22:20 <elliott> (.) is just the flipped version of (...), by the way.
02:22:25 <elliott> *(>>>)
02:22:55 <mauke> > (length . show) 42
02:22:58 <lambdabot>   2
02:23:36 <quchen> > (show >>> length) 42
02:23:40 <lambdabot>   2
02:23:43 <quchen> That looks very odd. :-)
02:25:13 <Watabou> I was just wondering why the type signature is ommitted for some functions and not for others
02:25:17 <Watabou> for example
02:25:20 <Watabou> :t head
02:25:24 <lambdabot> [a] -> a
02:25:25 <Watabou> :t sum
02:25:28 <lambdabot> Num a => [a] -> a
02:25:36 <latro`a> what's omitted, exactly?
02:25:43 <Watabou> sum has Num a => but head doesn't
02:25:44 <latro`a> both of those are type signatures
02:25:49 <latro`a> that's a typeclass constraint
02:26:07 <Watabou> ah okay then, I'm still learning so I didn't know what those were called
02:26:07 <latro`a> making sum make sense requires the contents of the list to be instances of Num, so that you can add them
02:26:14 <elliott> head doesn't require the list elements to be a number
02:26:24 <latro`a> but head makes sense no matter what type the elements are
02:26:38 <quchen> hamid: Often, needing a hetero list is a hint that you should unify your types in some combined data type. For example, if you need a list of Doubles and Ints, make it a [Either Int Double] (or define your own type).
02:26:39 <Watabou> but you can't do head (1, 2)
02:26:58 <yezariaely> anyone knows a standard function or representation (in a math kind of view, not haskell) for cutting a tree.
02:27:02 <yezariaely> ?
02:27:16 <quchen> hamid: You'll have to define your own functions to work with that list however, for example calculating the sum.
02:28:32 <hamid> quchen, yep i tried to write this typeclass but it was going to be a mess :P
02:29:03 <arbn> Watabou: Yes. head is only defined for a list. This is because of the [a] in the type signature.
02:29:18 <elliott> [a] means list of a.
02:29:21 <Watabou> ah gotcha, thanks
02:30:16 <hamid> quchen, I was trying to implement the chain actions design pattern and this came to my mind,
02:30:45 <donri> > view _1 (1, 2)
02:30:49 <lambdabot>   1
02:31:19 <hamid> quchen, thinking of "why not push functions to a list and apply them to passed data."
02:34:41 <shachaf> I bet the answer is Yoneda. hth
02:35:30 <hamid> shachaf, yeah :D
02:35:38 <rod|> yezariaely, what subtrees do u have to cut ?
02:36:29 <yezariaely> rod|: I simple have to write (formally) that I want to cut a given (arbitrary) tree to height n. Wondered if there is a standard symbol for that.
02:36:55 <yezariaely> of course I can and must write in prose what I want to do.
02:38:22 <tsinnema> how do i 'flip
02:38:23 <tsinnema>  asdasf
02:38:39 <tsinnema> how do i 'flip' the rightmost of three parameters to the leftmost position?
02:38:59 <tranceholic> hi
02:40:28 <quchen> tsinnema: Hand code it yourself. There's no "higher" flip in the standard libs.
02:41:26 <tsinnema> quchen, any pointers to what the cleanest way is to do something like this? i'm still very newbie when it comes to things like this
02:41:39 <danr> @unpl \ f a b c -> f a c b
02:41:40 <lambdabot> \ f a b c -> f a c b
02:41:49 <danr> @pl \ f a b c -> f a c b
02:41:50 <lambdabot> (flip .)
02:41:51 <danr> oops
02:42:04 <shachaf> tsinnema: Cleanest way is to just write the lambda. hth
02:42:09 <tsinnema> thanks!
02:42:26 <supki> @unpl ((flip .) .)
02:42:26 <lambdabot> (\ e h k b c -> e h k c b)
02:43:22 <quchen> flip331 f x y z = f z y x <- Something like that. Just make sure you document your naming scheme somewhere. (In my case, it's a 3-argument function, and I'm flipping #3 with #1.)
02:43:40 <supki> @unpl ((flip .) . flip)
02:43:40 <lambdabot> (\ j m b c -> j c m b)
02:44:07 <shachaf> quchen: Or, better yet, don't do it.
02:44:14 <shachaf> Just name your arguments.
02:44:20 <quchen> shachaf: The Zen way. :-)
02:44:28 <shachaf> No.
02:44:53 <shachaf> Reading code that uses things like flip331 sounds like a terrifically unpleasant experience.
02:46:24 <donri> shachaf: 'hth'?
02:47:35 <quchen> shachaf: True. I find 'flip' to be too pointfree quite often actually. For some reason, `flip runState` is much harder to read than say (`runState` ...).
02:47:52 <shachaf> I agree.
02:48:47 <elliott> runState ?? ... $ ...
02:49:05 <quchen> "??"?
02:49:21 <quchen> Probably a Lens thing? ;-)
02:51:22 <pete_> import Control.Applicative hiding (instance Applicative Maybe)
02:51:27 <pete_> What's the real way of saying that?
02:51:44 <quchen> pete_: Instances are always imported from a module.
02:51:52 <quchen> You don't need to specify them (nor can you).
02:52:03 <pete_> That's annoying
02:52:18 <quchen> If you want your own instance, you'll have to write a newtype wrapper.
02:52:51 <donri> pete_: it's necessary for type classes to give certain guarantees
02:53:44 <quchen> There was a post on StackOverflow explaining this, but I can't find it :-/
02:54:06 * pete_ gives up and simply copies Maybe from the prelude and renames it
02:54:11 <quchen> http://stackoverflow.com/questions/8728596/explicitly-import-instances
02:54:19 <donri> pete_: for example if you use two Ord instances for the same type, Set will not necessarily behave correctly
02:54:20 <quchen> Ha. Google beats StackOverflow's search once again.
02:55:31 * elliott wonders what alternative Applicative instance pete_ is defining
02:56:02 <pete_> elliott: I am attempting to work out what an Applicative instance for Maybe should be
02:56:47 <elliott> ah
02:57:07 <elliott> you could write functions with the same type but not in an actual Applicative instance to save some work
02:59:15 <shachaf> elliott: But then you don't get a big library of Applicative functions to test with.
03:01:13 <hpaste> Matthias pasted “mmap-ing a vector” at http://hpaste.org/87316
03:01:32 <matthiasgoergens> Why does the mmap-ing not work?
03:01:57 <shachaf> You tell us.
03:02:21 <hpaste> Matthias pasted “Error message” at http://hpaste.org/87317
03:02:59 <matthiasgoergens> ghc complains about Vector and Data.Vector.Storable.Vector not being matchable..
03:03:14 <shachaf> I guess they're not the same type!
03:04:03 <matthiasgoergens> Yeah.
03:04:14 <matthiasgoergens> They might just have the same name..
03:04:33 <matthiasgoergens> I can't seem to get the right name into scope.
03:05:13 <supki> import Data.Vector.Storable ?
03:05:17 <shachaf> matthiasgoergens: Did you try importing Data.Vector.Storable?
03:05:30 <supki> I like amount of things named Vector in vector package
03:05:44 <matthiasgoergens> shachaf: Just found Data.Vector.Storable myself via source digging.  Thanks!
03:05:46 <matthiasgoergens> That worked.
03:06:06 <matthiasgoergens> I guess next time I should talk to my rubber duckie first.
03:11:15 <Taneb> To download the happstack-server package and all dependencies requires 172283 lines of haskell code
03:14:22 <Taneb> The top five biggest libraries in happstack-servers depends are:
03:14:23 <Taneb> base
03:14:30 <Taneb> blaze-html
03:14:41 <Taneb> containers
03:14:52 <Taneb> bytestring
03:15:10 <Taneb> syb
03:15:38 <Taneb> Other than those, only text has more than 10 kiloLOC
03:17:50 <quchen> Taneb: How large is Base? I feel like that makes the statistic a little weird.
03:18:01 <Taneb> 38 kLOC
03:20:23 <Taneb> I was most surprised by how big blaze-html is
03:21:41 <Taneb> 30853
03:21:45 <Taneb> *30753
03:29:52 <FreeFull> I think I'll do http://projecteuler.net/problem=351
03:30:39 <mekeor> FreeFull: just do it. why do say it us? O.o
03:31:00 <FreeFull> I don't know
03:31:12 <FreeFull> But if you think about it this is actually pretty simple
03:31:12 <mekeor> fine :)
03:33:36 <ClaudiusMaximus> matthiasgoergens: btw, mmap Vector Char might not do what you expect on a text file  (Haskell's instance Storable Char probably uses 32bits?)
03:35:06 <shachaf> Yes, it certainly won't be as efficient as, say, Text.
03:35:12 <shachaf> Oh, er, mmap.
03:35:26 <shachaf> Yes, you'll need to handle encoding/decoding somehow.
03:36:16 <ClaudiusMaximus> (not sure if it is a text file, though)
03:41:25 <Taneb> snap needs 247122
03:45:55 <Taneb> Measuring Yesod now...
03:46:58 <donri> Taneb: is that snap fullstack or core/server/whatever?
03:47:09 <Taneb> donri: snap full and all dependencies
03:47:21 <Taneb> Well, it's the "snap" package with all dependencies
03:47:47 <Taneb> yesod needs 307804
03:47:54 <donri> Taneb: for fun you should measure yesod-platform
03:48:11 <donri> Taneb: and perhaps happstack-foundation
03:48:32 <Taneb> The previous number for happstack was just happstack-server, I'll try the "happstack" package first
03:48:52 <Taneb> happstack is 172037
03:48:55 <donri> Taneb: that's deprecated i think
03:50:02 <tranceholic> hi, i have a piece of code that ghc7.4.2 does not interpret. Could any one help?
03:50:32 <Taneb> happstack-foundation is 226739
03:50:37 <Taneb> tranceholic: almost certainly
03:50:41 <elliott> tranceholic: sure, can you paste the code and the full error?
03:50:42 <elliott> @paste
03:50:42 <lambdabot> Haskell pastebin: http://hpaste.org/
03:50:44 <FreeFull> How fast is the default gcd function?
03:51:27 <Taneb> donri: this isn't very fast because it's downloading them all off Hackage and unzipping them and then converting them to text and then counting the lines
03:52:24 <donri> Taneb: work faster! *whip*
03:52:26 <Taneb> yesod-platform is 325904
03:52:34 <donri> that's surprisingly low
03:54:03 <Taneb> I'd suggest that yesod is highest because it comes with a lot more templating by default than either snap or happstack
03:54:10 <fxr> donri: yeah you have to count after macroexpansion ;)
03:54:23 <timbod> Is there a standard name for the function of type (a->b,a->c) -> (a->(b,c)) ?
03:54:31 <Taneb> And snap is pretty high because it includes lens, which is one of the biggest libraries on hackage
03:54:39 <Taneb> :t uncurry (&&&)
03:54:41 <lambdabot> Arrow a => (a b c, a b c') -> a b (c, c')
03:54:53 <Taneb> :t uncurry (&&&) :: (a -> b, a -> c) -> (a -> (b, c))
03:54:54 <lambdabot> (a -> b, a -> c) -> a -> (b, c)
03:55:12 <donri> well i thought yesod-platform included things like persistent backends but seems not
03:55:28 <timbod> Thanks. So it's an operator in the arrows package?
03:55:39 <donri> timbod: it's in base
03:55:41 <donri> Control.Arrow
03:56:06 <timbod> Found it.
03:56:38 <timbod> Are there variants for 3-tuples, 4-tuples etc?
03:56:47 <fxr> Taneb: how are they compare by package dependency count rather than loc?
03:57:02 <donri> timbod: not in arrow, but you might be able to write a solution with lens
03:57:37 <Taneb> fxr, I'll check
03:57:46 <timbod> donri:  "write a solution with lens" sounds like a universal answer :-)
03:57:47 <fxr> Taneb: thank you
03:58:05 <donri> timbod: :) well it includes a class for dealing with up to 9-tuples
03:58:15 <Taneb> happstack-foundation is 61 depends
03:58:26 <donri> Taneb: recursive?
03:58:33 <Taneb> donri: yeah
03:58:33 <timbod> donri: It's easy enough to write them myself, I just wondered if they existed somewhere already.
03:58:37 <Taneb> I'm using the packdeps API
03:58:40 <donri> > sequenceOf each (Just a, Just b, Just c)
03:58:43 <lambdabot>   Just (a,b,c)
03:59:23 <Taneb> yesod-platform is 165
03:59:40 <Taneb> It feels unfair to just use snap
03:59:50 <Taneb> Is there a snap-platform package or anything
03:59:57 <Taneb> But snap is 74
04:00:45 <Taneb> fxr, ^
04:00:56 <fxr> Taneb: many thanks
04:02:14 <Taneb> I'm gonna see what the union of "snap", "yesod" and "happstack" is like
04:04:43 <Taneb> Man, I wish I could make this ping when it's done
04:05:12 <Fuuzetsu> :t sequenceOf
04:05:17 <lambdabot> LensLike (WrappedMonad m) s t (m b) b -> s -> m t
04:05:40 <Fuuzetsu> :t each
04:05:42 <lambdabot> (Indexable (Index t) p, Each f s t a b) => p a (f b) -> s -> f t
04:06:09 <donri> \o/
04:06:23 <Taneb> Or even cache results
04:07:29 <Fuuzetsu> :t sequenceOf each
04:07:31 <lambdabot> Each (WrappedMonad m) s t (m b) b => s -> m t
04:07:54 <Taneb> 368224 LOC for all of happstack, snap, and yesod
04:08:04 <mekeor> is hayoo down?
04:08:14 <ClaudiusMaximus> mekeor: was when i tried earlier
04:08:18 <Fuuzetsu> seems to be
04:08:19 <Taneb> mekeor: I don't think so?
04:08:34 <mekeor> Taneb: the search doesn't seem to work.
04:08:40 <Taneb> Oh, so it doens't
04:09:02 <mekeor> well, we all have our up and down times. :)
04:10:24 <mekeor> i need it though =D
04:10:39 <Taneb> What do you need to know?
04:11:43 <mekeor> uhm. i need the documentation of buildTagsWith from hakyll. i could look for the docs myself of course, too. but, as a typical haskeller, i am a lazy person. ;)
04:11:57 <Taneb> Hang on, this isn't right
04:12:46 <Taneb> It's saying that old-time only has four lines of code
04:13:19 <mekeor> Taneb: huh?
04:13:26 <Taneb> mekeor: irrelevant to you, sorry
04:13:32 <mekeor> ok
04:14:11 <Taneb> mekeor: http://hackage.haskell.org/packages/archive/hakyll/4.2.2.0/doc/html/Hakyll-Web-Tags.html#v:buildTagsWith
04:14:27 <mekeor> yeah
04:14:42 <mekeor> (or <http://jaspervdj.be/hakyll/reference/Hakyll-Web-Tags.html>)
04:14:55 <Taneb> Aaaah, I'm not counting .hsc files
04:15:02 <int-e> Taneb: it's a single .hsc file... right.
04:15:30 <Taneb> Other than .hs, .lhs, and .hsc, any other suffixes I should worry about?
04:16:10 <ClaudiusMaximus> Taneb: alex/happy input?
04:16:31 <Taneb> ClaudiusMaximus: yeah, probably
04:16:40 <isomorphic> Terminology-wise - am I correct to say that Left and Right are data constructors for the Either monad?
04:16:49 <donri> Taneb: y u no use sloccount or cloc or something like that
04:16:53 <elliott> isomorphic: "Either monad" reads weirdly there
04:17:00 <elliott> the constructors have nothing to do with the fact that it's a monad
04:17:09 <Taneb> donri: reasons
04:17:14 <elliott> it's correct to say that Left and Right are data constructors for the Either type, or more formally, for the type Either a b for any a, b
04:17:27 <elliott> what you said isn't technically incorrect, but it's bizarre
04:17:43 <int-e> Taneb: .chs ... and then there's the question whether you're interested in bundled C or CMM code that is used with FFI.
04:17:47 <donri> Taneb: good point
04:17:52 <isomorphic> Oh - elliott:  Ah, no that's helpful.   So, it's more a data type that happens to have a monad instance
04:18:04 <Taneb> donri: it's a little toy program, there's not that much case for caring
04:18:26 <donri> Taneb: well i thought it would be easier. maybe not
04:18:34 <int-e> Taneb: (C++ too. so then the list of file extensions will explode)
04:18:40 <elliott> isomorphic: right.
04:18:42 <Taneb> I don't know sloccount or cloc, I'm afraid, donri
04:18:58 <elliott> isomorphic: it can make sense to talk about "the Either monad" -- that's when you're talking about Either coupled with the semantics the Monad instance gives it
04:19:09 <donri> Taneb: they count lines of code recursively in directories
04:19:12 <elliott> isomorphic: like, you could say that Left is a data constructor that represents failure in the Either monad
04:19:13 <donri> (surprise!)
04:19:35 <Taneb> donri: I think I'm doing it without fully expanding the tarball
04:19:40 <fxr> Taneb: is there a quick way to see how many packages my project depends recursively?
04:19:44 <isomorphic> elliott:  The distinction is useful - I'm not reading you as being overly pedantic, if that's what you're thinking ;)
04:20:06 <Taneb> fxr: packdeps.haskellers.com is a place to start if it's on hackage
04:20:13 <int-e> donri: thanks for the pointer, I wasn't aware of cloc :)
04:20:22 <Taneb> However, it's not something you should really care about, fxr
04:20:53 <fxr> Taneb: unfortunately it's not on hackage yet
04:22:23 <rod|> yezariaely, do u still need the formalism for cutting trees ?
04:23:01 <Taneb> fxr: I wouldn't worry too much
04:35:55 <parcs> @tell jfischoff i've been testing it against the Cabal package since it has no external dependencies and is a fairly large project with lots of modules
04:35:55 <lambdabot> Consider it noted.
04:38:16 <tranceholic> hello
04:38:19 <Chousuke> huh, looks like I got disconnected :/
04:38:27 <mekeor> hello tranceholic :)
04:40:21 <tranceholic> i have a piece of code i would like someone to review
04:40:52 <Botje> put it on hpaste and stand back :)
04:41:20 <tranceholic> im new here, where is "hpaste" ?
04:41:45 <supki> @hpaste
04:41:46 <lambdabot> Haskell pastebin: http://hpaste.org/
04:42:25 <isomorphic> If I declare a type without using the record syntax, is it possible to still have automatically generated accessor functions?
04:42:30 <tranceholic> oh ok thnx a lot
04:43:41 <hpaste> tranceholic pasted “`join` behavior” at http://hpaste.org/87320
04:47:50 <Botje> tranceholic: consider using the maybe function
04:47:50 <Botje> @type maybe
04:47:50 <lambdabot> b -> (a -> b) -> Maybe a -> b
04:47:50 <donri> val >>= \ms -> ms = val >>= id = join val
04:47:50 <Botje> except valMMM :: Maybe String
04:47:50 <Botje> you're not going to be able to get the IO out, i'm afraid.
04:47:52 <tranceholic> really?
04:48:18 <Botje> val :: IO (Maybe String)
04:48:30 <tranceholic> i thought `join` could get into IO a and access a
04:48:33 <Botje> and >>= requires the same monad everywhere
04:51:04 <Chousuke> tranceholic: join takes m (m a) and gives you m a, but it can't turn m a into a
04:52:07 <tranceholic> let me see...
04:53:12 <Chousuke> if you think about it, a side-effecting computation that results in more side-effecting computations that result in values may be joined into a single computation that performs all those side-effects and results in a value, but you can't remove the side-effects and just get the value.
04:54:31 <Eduard_Munteanu> tranceholic: (>>=) gives you access to 'a' but the result must end up back in IO.
04:54:36 <Eduard_Munteanu> :t (>>=)
04:54:38 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:54:54 <Eduard_Munteanu> x >>= f = join (fmap f x)
04:55:25 <tranceholic> on ghc interactive, "  :t join (return (Just "a")) " gives :: Maybe [Char]  , this is where i began with
04:55:58 <Botje> tranceholic: the argument to join is Maybe (Maybe Char)
04:56:04 <Botje> uh, Maybe (Maybe String)
04:56:18 <Botje> you can't do it with IO (Maybe String), as your example has
04:56:28 <quchen> "join" allows you to flatten a nested monadic structure, but only to the point where there's one layer left. It turns a "m (m a)" into a "m a", but never an "m a" to a plain "a".
04:56:54 <quchen> (Also it requires nesting of identical monads, not just any two monads. You can't join a IO (Maybe a) for example)
05:02:33 <tranceholic> another source is Chapter 24 Real World Haskell with "waitFor2" function, where it seems to me `join` could get into IO (IO (Maybe a)) ...
05:03:16 <Botje> tranceholic: yes, it merges the two IO layers into one, then.
05:03:25 <Botje> :t join ( undefined :: IO (IO (Maybe a)))
05:03:27 <lambdabot> IO (Maybe a)
05:04:41 <TeifionJordan> I'm still learning Haskell and I'm struggling with a few things. I was told this is a good place to ask questions, is that right?
05:04:42 <Chousuke> tranceholic: to access the a you can just compose fmap as many times as you have layers (because both IO and Maybe are Functors)
05:05:04 <Eduard_Munteanu> TeifionJordan: hi, sure
05:05:43 <TeifionJordan> Awesome sauce. I'm trying to solve Euler problems. I'm currently trying to work out palindromes.
05:05:57 <TeifionJordan> reverse (show 12321) == show 12321 ---- This works in the GHCI
05:06:17 <TeifionJordan> but as part of a function it breaks
05:06:20 <TeifionJordan> is_palimdrone :: (Integral a) => a -> Bool
05:06:21 <TeifionJordan> is_palimdrone x = reverse (show x) == show x
05:06:26 <TeifionJordan> specifically I tried the above
05:06:41 <Botje> TeifionJordan: show requires its argument to be an instance of Show as well.
05:06:59 <Botje> so your type should be (Integral a, Show a) => a -> Bool
05:07:03 <TeifionJordan> ahhhh
05:07:17 <TeifionJordan> success!
05:07:27 <TeifionJordan> thank you very much
05:07:47 <TeifionJordan> Botje++
05:08:39 <Botje> no problem
05:08:56 <Botje> stick around, we're always happy to answer more questions
05:09:11 <TeifionJordan> thanks, I shall
05:10:27 <tranceholic> so, with "waitFor2", `join` could get into IO m,  and the consequent m is still a monad. What's the difference between this and my pasted code?
05:11:33 <Zeev> what does the symbol: @ mean? in let abc@(a,b,c) = (10,20,30) in (abc,a,b,c)
05:12:27 <Chousuke> tranceholic: what do you mean "get into"?
05:12:51 <klugez> Zeev: It lets you give the name to the whole thing and pattern match it into components. abc means (a,b,c) in the body.
05:14:47 <Zeev> klugez: thanks
05:15:27 <tranceholic> stripping Just from (Just (Just "a")) is Just "a", which seems equivalent to getting to the inner Just from the outer Just
05:16:13 <Eduard_Munteanu> > join (Nothing :: Maybe (Maybe String))
05:16:15 <lambdabot>   Nothing
05:16:34 <Eduard_Munteanu> :t join (Nothing :: Maybe (Maybe String))
05:16:37 <lambdabot> Maybe String
05:16:59 <nh2> has anybody experience with replacing/speeding up a cabal build system with shake?
05:17:23 <Chousuke> tranceholic: hm
05:17:36 <Chousuke> tranceholic: but you still have the same monad being nested
05:18:07 <Chousuke> tranceholic: the join operation requires the monad to be ther same. otherwise it can't know what to do to join the effects
05:19:24 <Chousuke> joining the effect of two maybes is clear: just return the inner value, or Nothing if there is no inner value
05:19:56 <Chousuke> that means Just Just 1 becomes Just 1, Nothing becomes Nothing, and Just Nothing becomes Nothing
05:20:42 <Eduard_Munteanu> > Nothing >>= undefined
05:20:46 <lambdabot>   Nothing
05:21:12 <Chousuke> but say the value was Just getLine. what would join do to "join" the two nested monads in that case?
05:21:14 <Eduard_Munteanu> > (Just 3) >>= undefined
05:21:17 <lambdabot>   *Exception: Prelude.undefined
05:21:30 <Botje> Chousuke: you have to do that manually, unfortunately.
05:22:04 <Botje> also, your result type will be in the IO monad.
05:23:07 <Eduard_Munteanu> :t Data.Traversable.sequence $ Just (undefined :: IO String)
05:23:12 <lambdabot> IO (Maybe String)
05:24:35 <Chousuke> Botje: yeah, I was asking tranceholic :P
05:25:02 <tranceholic> well
05:26:34 <tranceholic> so the two monads which `join` intervenes in between must be the same kind?
05:26:51 <Eduard_Munteanu> :t join
05:26:55 <lambdabot> Monad m => m (m a) -> m a
05:27:04 <Eduard_Munteanu> The type makes it pretty clear.
05:27:26 <Eduard_Munteanu> It's not m (n a) -> m a  or  m (n a) -> n a
05:28:28 <Chousuke> there's no way to implement operations of those types either, for arbitrary monads m and n
05:28:50 <hpaste> asd pasted “asd” at http://hpaste.org/87321
05:30:06 <Eduard_Munteanu> It would sort of defeat the point if you could, consider one of them could be the identity monad.
05:30:26 <Eduard_Munteanu> You could pretty much get an  m a -> a  out of that.
05:31:30 <matthiasgoergens> If you want :: m (n a) -> n (m a), try sequenceA.
05:31:40 <hpaste> asd pasted “asd” at http://hpaste.org/87322
05:31:48 <Eduard_Munteanu> :t Data.Traversable.sequence
05:31:49 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
05:32:01 <Eduard_Munteanu> :t Data.Traversable.sequenceA
05:32:02 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
05:32:04 <tranceholic> thanks a lot, folks, i think i got it, and i didnt know all the m's are the same kind in a type signature
05:32:18 <hpaste> asd pasted “asd” at http://hpaste.org/87323
05:32:26 <Eduard_Munteanu> tranceholic: same variables => same type
05:32:59 <Eduard_Munteanu> Like when you do basic algebra, e.g. a + a = 2*a
05:33:49 <matthiasgoergens> :t Data.Traversable.mapM
05:33:50 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
05:34:19 <matthiasgoergens> :t Data.Traversable.sequence
05:34:20 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
05:34:39 <matthiasgoergens> sequence and sequenceA are basically the same, only for the missing Applicative constraint in Haskell's monads.
05:35:39 <Eduard_Munteanu> tranceholic: mind if you have different variable, that doesn't mean the types have to be different, they can still be the same but it's not required
05:41:15 <isomorphic> Cabal keeps telling me I'm missing dependencies - however, putting the suggested dependencies in the cabal file verbatim doesn't help.  Has anybody seen this behavior?
05:46:03 <parcs> you might have to perform 'cabal configure' or something
05:48:42 <tranceholic> let me close this issue, thanks a lot, folks
06:04:40 <pxqr> many bytestring operations might be much faster if we will use aligned read/write Word64 operation. Which one package should I use if I want to manipulate bytestring in this way? I need fast bitwise operations for exsample.
06:46:13 <flebron> Since both (*) and mod are infixl 7, how is a * b `mod` c interpreted? As mod c a * b, which would be (mod c a) * b?
06:47:07 <parcs> (a*b) `mod` c
06:47:09 <yitz> mod (a * b) c
06:47:36 <flebron> New bot?
06:47:39 <yitz> > 5 * 7 `mod` 3
06:47:42 <lambdabot>   2
06:48:18 <yitz> flebron: two of us
06:48:23 <flebron> :p
06:49:17 <flebron> It's interesting, then, that hlint doesn't suggest removing parenthesis when I say k' = (k * k) `mod` m.
06:50:18 <quchen> flebron: It probably doesn't know about ` fixities
06:50:19 <latermuse> flebron: you can add that defintion to hlint
06:50:51 <kosmikus> does it suggest anything for (2 * 2) + 3 ?
06:51:03 <kosmikus> I don't think it generally knows about priorities
07:24:01 <LowPotential> Hello everyone. I have a module (say 'Foo.Bar') that defines a function 'read' (which is unrelated to 'Prelude.read'). If I want to use my function within my module unmodified, GHC complains about an ambiguous reference, as expected. What I'd like to know is if it's possible to refer to my local module's 'read' within the module itself without specifying 'Foo.Bar.read'. Sort of like '::foo' in C++. Any ideas?
07:24:48 <ramses_> LowPotential: one possibility is "import Prelude hiding (read)"
07:24:58 <MercurialAlchemi> import Prelude hiding (read)
07:25:01 <ramses_> if you don't need Prelude's read as well
07:25:23 <LowPotential> ramses_ MercurialAlchemi: In this case I don't, but what if I did? :)
07:25:24 <ramses_> otherwise a qualified import of Foo.Bar.read
07:25:35 <LowPotential> ramses_: Inside 'Foo.Bar' itself?
07:25:52 <acube> otherwise, you can import your module with an alias, like so: import qualified Foo.Bar as FO; then you can use Foo.Bar.read as FO.read
07:26:05 <ramses_> LowPotential: no, in the module which uses it
07:26:11 <Cale> LowPotential: You could then import the Prelude again, but qualified
07:26:28 <Cale> import Prelude hiding (read); import qualified Prelude as P
07:26:37 <LowPotential> I see. Thanks everyone!
07:27:39 <MercurialAlchemi> LowPotential: in general, I try to avoid doing this sort of thing, this avoids having to wonder six month later why this function "read" does not behave like "read"
07:27:56 <MercurialAlchemi> LowPotential: especially when you have many lines of import at the top of your module
07:28:32 <Cale> Though in some cases, it's sorta okay. Like Data.Set and Data.Map force a lot of that.
07:29:06 <Cale> I still sometimes miss having names like lookupFM, etc and not having to import things qualified.
07:34:08 * elliott mumbles something about a proper module system
07:41:47 <tdammers> Haskell's module system is actually one of the better ones I've seen
07:44:34 <dEPy> when mappend-ing the monoids should the order matter or not? Or is it up to us?
07:45:07 <tdammers> afaik order is allowed to matter
07:45:36 <donri> dEPy: not all monoids are commutative, no
07:45:40 <dEPy> I'm just asking, cause in case I want to make my tree foldable, it's then actually important no?
07:45:56 <tdammers> > "foo" `mappend` "bar"
07:46:01 <lambdabot>   "foobar"
07:46:03 <donri> > ([a] <> [b], [b] <> [a])
07:46:08 <lambdabot>   ([a,b],[b,a])
07:46:08 <Philippa> tdammers: it manages to not mess up the basics, but if you've seen the ML family's systems it's... well, zeroth-order
07:46:12 <Philippa> like doing FP in spreadsheets
07:46:54 <tdammers> hm, OK... not familiar with those
07:47:08 <donri> dEPy: the important property is that it's associative. commutativity is optional and depends on the monoid.
07:47:53 <donri> > ([a] <> [b]) <> [c] == [a] <> ([b] <> [c])
07:47:55 <lambdabot>   True
07:49:20 <amatsu> Is there any way I can pass a variable in an STRef between functions?
07:51:19 <gds> Probably an old question, but I don't see any threads in haskell-cafe with subject's containing "ubuntu"...
07:51:51 <gds> They've removed the package haskell-platform from the latest ubuntu, because "there is no haskell platform for ghc 7.6 yet"
07:52:23 <gds> Am I right in thinking I can just install ghc and cabal, and will likely be more or less ok? :S
07:52:40 <mauke> yes
07:52:45 <gds> Awesome - thanks :)
07:54:49 <Cale> amatsu: That shouldn't be an issue, but you can't share STRefs between different applications of runST
07:55:42 <amatsu> Cale: alright then, thanks!
08:05:31 <Ankhers> Does anyone know if the new Haskell Platform will actually be released at some point today?
08:06:01 <geekosaur> unlikely to be today, since the first test release only just came out
08:06:31 <Ankhers> Oh okay, by the end of the month?
08:06:38 <b__> how does one chain updates of multiple fields of a type with lens again?
08:06:40 <geekosaur> (delay occasioned by required bug fixes in ghc and cabal)
08:06:59 <geekosaur> before the end of the month, certainly. how far before, I couldn't say
08:07:40 <tdammers> > set _1 4 . set _2 5 $ (6,6)
08:07:45 <lambdabot>   mueval: ExitFailure 1
08:07:46 <lambdabot>  mueval: Prelude.undefined
08:07:47 <Ankhers> kk, thanks geekosaur
08:07:54 <tdammers> "P
08:08:07 <b__> cheers tdammers
08:08:15 <dEPy> am, I'm doing:  import qualified Foldable as F    in my .hs file and when trying to load it into ghci it says "File name does not match modue name: Saw: `Main` Expected: `Foldable` ...
08:08:21 <tdammers> there might be a better way, not sure
08:09:21 <b__> okay
08:09:59 <geekosaur> dEPy, is Foldable your module? if so, does it have a "module Foldable" declaration at the top?
08:10:09 <dEPy> nevermind, it should be Data.Foldable I think
08:10:09 <b__> there was a time (when the sun didn't shine so much) when I knew
08:10:16 <geekosaur> yes
08:11:59 <`^_^v> atomicmodifyioref has this warning: Extending the atomicity to multiple IORefs is problematic, so it is recommended that if you need to do anything more complicated then using MVar instead is a good idea.
08:12:12 <`^_^v> actually, never mind
08:17:20 <Cale> `^_^v: Or STM of course :)
08:21:33 <Taneb> How fancy-schmancy is blank-canvas?
08:31:32 * hackagebot free-operational 0.2.0.0 - Operational Applicative, Alternative, Monad and MonadPlus, built with free types.  http://hackage.haskell.org/package/free-operational-0.2.0.0 (LuisCasillas)
08:33:53 <osa1> is there a built-in type in stdlib like data Void = Void ?
08:34:16 <Taneb> osa1: there's ()
08:34:32 <Taneb> For NO values, there's the void library
08:35:01 <osa1> ok, thanks
08:38:32 <marcot> Hi. I'm seeing some inconsistent behaviour in aeson.  I try to decode the same string two times, and in one of them it works, and in the other it fails.
08:38:38 <marcot> Has anyone experienced this?
08:38:48 <marcot> I'm using aeson 0.6.1.0.
08:39:46 <donri> marcot: how same is 'same'?
08:40:02 <stelleg> does anyone know if there is an analog for the function either for lists?
08:40:04 <donri> marcot: i think for example, single quotes aren't allowed in json
08:40:18 <donri> stelleg: map?
08:40:40 <stelleg> donri: I'm thinking something of the form
08:40:48 <mauke> stelleg: foldr
08:41:27 <geekosaur> @paste your code, marcot?
08:41:27 <lambdabot> Haskell pastebin: http://hpaste.org/
08:41:32 <stelleg> ([a] -> b) -> b -> [a] -> b
08:41:41 <stelleg> mauke: yeah I think thats probably right
08:41:50 <stelleg> or left :)
08:42:06 <donri> @hoogle ([a] -> b) -> b -> [a] -> b
08:42:06 <lambdabot> No results found
08:42:24 <stelleg> I think it should be possible with a fold
08:42:44 <stelleg> just throw away the default value for the nil case if there are elements in the list
08:43:19 <fizbin> :t either
08:43:21 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
08:45:47 <dEPy> In LYAH, last bit of this page http://learnyouahaskell.com/functors-applicative-functors-and-monoids it makes a Tree Foldable.
08:45:54 <dEPy> Then it does: F.foldl (+) 0 testTree
08:46:23 <dEPy> and in Foldable implementation it's implemented like:  foldMap f (Node x l r) = ...
08:46:30 <dEPy> where does the f comes from?
08:46:40 <dEPy> in last sample? is f just (+) ?
08:47:06 <mauke> yes, that's how function calls work
08:47:15 <mauke> parameters are bound to the parameters that are passed in
08:47:20 <mauke> er
08:47:24 <mauke> parameters are bound to the arguments that are passed in
08:47:34 <dEPy> so when folding a tree you basically get partially applied functions? which you then combine using mappend?
08:47:43 <mauke> ?
08:48:04 <dEPy> well (+) takes 2 arguments
08:48:20 <dEPy> and foldMap is defined like: foldMap f (Node x l r) = F.foldMap f l `mappend` f x `mappend` F.foldMap f r
08:48:37 <mauke> oh, interesting
08:48:44 <dEPy> am I right?
08:49:00 <mauke> wait
08:49:10 <mauke> where's the definition of foldl?
08:49:21 <fizbin> @src foldl
08:49:22 <lambdabot> foldl f z []     = z
08:49:22 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:49:26 <mauke> fizbin: not that one
08:49:35 <dEPy> from Data.Foldable I think
08:50:05 <mauke> foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
08:50:27 <mauke> thus f = Dual . Endo . flip f
08:50:33 <dEPy> I'm not sure how that example working when provided (+)
08:51:07 <fizbin> @type \f d l -> either f (const d) $ foldr (\x -> Left . either (x:) (const $ x:[])) (Right ()) l
08:51:11 <lambdabot> ([a] -> c) -> c -> [a] -> c
08:51:22 <fizbin> stelleg: ^^^ what you wanted.
08:51:30 <dEPy> u guys are just confusing me more O_o
08:51:42 <marcot> donri: the exact same string, read from the same file.
08:51:45 <arkeet> you should probably try to understand how Foldable.foldr works, first.
08:51:46 <fizbin> stelleg: Or rather, what you asked for. Nobodoy wanted that mess.
08:51:51 <stelleg> fibin :)
08:52:08 <dEPy> arkeet, says nothign about it in the book I think.. O_o
08:52:23 <arkeet> then go outside the book
08:52:28 <stelleg> fizbin: well done, I decided to use a case expression to make it readable
08:52:29 <mauke> dEPy: the answer to your question is yes
08:52:32 <dEPy> Just says we get foldr and foldl somehow magically? :D
08:52:32 <arkeet> read the source, actually
08:52:51 <mauke> it's using the Endo monoid
08:53:02 <mauke> which is basically (.)
08:53:48 <fizbin> :t either id id
08:53:52 <lambdabot> Either c c -> c
08:54:26 <fizbin> @pl \f d l -> either f (const d) $ foldr (\x -> Left . either (x:) (const $ x:[])) (Right ()) l
08:54:26 <lambdabot> flip flip (foldr ((Left .) . liftM2 either (:) (const . return)) (Right ())) . ((.) .) . (. const) . either
08:55:24 <capisce> uh
08:55:33 <capisce> haskell rap
08:56:32 <hpaste> marcot pasted “Inconsistent aeson” at http://hpaste.org/87328
08:56:42 <dEPy> How do I find the source of the haskell functions?
08:56:57 <marcot> geekosaur: pasted.
08:57:31 <mauke> dEPy: click on the Source link in the docs
08:58:34 <dEPy> tnx
09:00:04 <dEPy> So Endo is a monoid for combining functions?
09:00:19 <dEPy> Or rather composing?
09:00:32 <fizbin> marcot: So what string is working sometimes and sometimes failing?
09:00:49 * fizbin suspects utf-8 encoding issues...
09:01:53 <mauke> dEPy: yes
09:02:00 <mauke> mappend = (.), mempty = id
09:05:29 <marcot> fizbin: The string mentioned in the comments.
09:07:01 <fizbin> marcot: Ah, so you're reading in that gigantic string.
09:07:07 <marcot> fizbin: Yes.
09:08:44 <fizbin> Okay, and by "reading it twice", do you mean that you run the program once, get the output, and then try to run the program on the output?
09:09:08 <marcot> No, I mean sometimes I run the program and it gives Nothing, sometimes it gives the correct parse.
09:12:04 <fizbin> Huh. Well, I would suggest that instead of "decode", you use "eitherDecode" and when you get a Left print out the error message.
09:13:38 <fizbin> Actually, just change what you pasted to use "eitherDecode" instead of "decode" and then run the program in a way that generates "Nothing" with the current program.
09:13:56 <marcot> Left "When parsing the record JCity of type Crawler.Crawlers.CorrespondentesNaWeb.JCity the key nomeNormalizado was not present."
09:14:27 <dEPy> So, why is Dual usefull? It's just swapping argument and then mappending them?
09:14:29 <marcot> Also, this is not consistent.
09:14:31 <frojnd> Hi there.
09:16:27 <supki> > (appEndo $ foldMap Endo [f, g, h]) x
09:16:31 <lambdabot>   f (g (h x))
09:16:34 <supki> > (appEndo $ getDual $ foldMap (Dual . Endo) [f, g, h]) x
09:16:37 <lambdabot>   h (g (f x))
09:16:42 <supki> dEPy: ^
09:17:02 <fizbin> dEPy: sometimes you're working with some code which will use mappend deep inside itself and rather than rewriting the whole thing it's easier to apply it to a Dual.
09:17:36 <fizbin> marcot: Meaning you get different error messages different times you run it?
09:18:17 <marcot> Yes.  Actually, this happens only in GHCi.
09:18:24 <marcot> In GHC, I get this error all the time.
09:18:55 <marcot> In GHCi, when I run main, I get this error.
09:21:28 <marcot> The key missing changes between runs too.
09:21:49 <fizbin> marcot: Okay, now I would begin to eliminate improbable causes. First check that you don't have weird system-level instability going on.
09:22:16 <fizbin> Run md5sum on the json file, run the haskell program, then run md5sum again.
09:22:16 <marcot> fizbin: Well, this is most unlikely, but how
09:22:18 <marcot> ?
09:22:23 <marcot> Ok.
09:22:32 <fizbin> Make sure md5sum keeps saying the same thing.
09:22:44 <marcot> No changes.
09:22:49 <marcot> Can you try to reproduce it?
09:25:06 <fizbin> I'll try. I assume that the original file had proper UTF-8 where what you posted has the broken utf8-interpreted-as-latin1 disease, e.g. "JiquiriÃ§Ã¡"
09:25:57 <marcot> hum, Ok, I don't think this should be an issue, but here I'm with the broken file.
09:26:12 <cschneid> supki: Endo is a function of type a->a? or am I misunderstanding? (just guessing based on your examples above)
09:26:22 <cschneid> supki: well, the Monoid instance of that.
09:26:48 <mauke> newtype Endo a = Endo{ appEndo :: a -> a }  -- or something like that
09:26:51 <supki> cschneid: yes
09:27:03 <marcot> fizbin: I just corrected it here, and I have the same behaviour.
09:27:07 <fizbin> marcot: Let's try a non-haskell validator while I'm waiting for cabal to compile aeson. Does your machine have python?
09:27:21 <marcot> Yes.
09:27:38 <supki> marcot: how often do you have parse errors?
09:27:58 <fizbin> marcot: What does this say: python -mjson.tool < /tmp/bahia > /dev/null ?
09:28:17 <cschneid> supki: so it's useful to take an array of [a,b,c] where each is a function of a->a and apply the whole chain?
09:28:28 <marcot> fizbin: It parses correctly.
09:28:35 <supki> cschneid: yes
09:28:39 <marcot> supki: It seems that about 4 of 5 tries.
09:28:45 <cschneid> supki: handy. Thanks for verifying what I saw.
09:28:47 <marcot> But I just checked this some times.
09:28:48 <supki> marcot: interesting
09:29:05 <supki> marcot: I didn't get any error in 20 tries
09:29:18 <supki> marcot: what version of hashable?
09:30:22 <supki> marcot: if it's >= 1.2 you could try with 1.1.something
09:30:25 <marcot> hashable-1.2.0.7
09:30:38 <marcot> Ok, I'll do it.
09:31:47 <supki> (I have 1.1.2.5 here.)
09:32:36 <marcot> supki: And what aeson version
09:32:38 <marcot> ?
09:33:39 <marcot> YAY!
09:33:46 <marcot> Downgrading hashable fixed the issue.
09:33:47 <marcot> Thanks, supki.
09:34:45 <supki> np
09:34:56 <supki> you should probably report that as a bug
09:36:35 <latermuse> when is it advisable to use existential types?
09:39:00 <dmwit> I think you got your answer.
09:40:06 <marcot> supki: Just did.
09:40:57 <fizbin> marcot: with 1.2.0.5 of hashable, I also see no issues.
09:41:30 <marcot> https://github.com/tibbe/hashable/issues/66
09:41:36 <marcot> If you have anything to add.
09:42:43 <quchen> Is there some difference between GHC's master and HEAD? The "current build" is referred to as HEAD, but shouldn't it be called "master"?
09:43:14 <geekosaur> master is a branch. HEAD is a (virtual) commit
09:43:18 <quchen> Or does HEAD mean "HEAD of the guys that have commit access to the real deal"
09:43:37 <quchen> geekosaur: I thought HEAD was your current location in the git tree
09:43:46 <geekosaur> HEAD is, specifically, the most recent commit on a branch
09:45:03 <quchen> geekosaur: So what's called "GHC HEAD" is the last commit in the master branch?
09:45:11 <geekosaur> yes
09:45:21 <quchen> Alright, thanks
09:45:54 <geekosaur> as opposed to some other branch, or sticking to some past commit instead of tracking the current state of the codebase
09:46:19 <geekosaur> (although I don;t think ghc is actually doing much with branches...)
09:49:21 <`^_^v> what is the best solution for finite size pre-determined arrays with fast arbitrary index read/update
09:50:17 <fizbin> `^_^v: STUArray inside the ST monad.
09:52:44 <dmwit> (What does pre-determined mean?)
09:53:03 <`^_^v> that its static
09:53:13 <`^_^v> the size i mean
09:53:20 <dmwit> ok
09:53:41 <ChongLi> but mutable?
09:53:58 <dmwit> I have to assume yes, since "fast arbitrary update".
10:08:55 <Bor0> (λab.a)(λab.b), I get λb.(λab.b) is this correct? if yes, further  I get λbab.b while the end result should just be λab.b
10:10:32 <Philippa> I don't see why you're expecting that end result
10:11:07 <Bor0> I'm following a tutorial where True AND False is applied, so the answer should be False
10:11:26 <Philippa> sure, the non-binding b refers to the inner of the three lambdas? That still doesn't let you skip a layer
10:11:30 <Bor0> maybe some of my previous reductions were incorrect
10:11:36 <Philippa> I only see tru fals
10:11:54 <Bor0> (λab.a)(λab.b)(λuv.v) this is one step back
10:12:11 <Philippa> no, it's not
10:12:12 <Bor0> I thought (λab.b)(λuv.v) is simply λab.b
10:13:00 <Philippa> how could it be? The LHS wants two parameters, you've only given it one
10:13:02 <pkkm> it's λb.λuv.u
10:13:17 <elliott> Bor0: (λa.a)(λuv.v) is λuv.v
10:13:22 <elliott> (λab.b)(λuv.v) is what pkkm said
10:13:27 <sellout> Bor0: (λab.b) wants two parameters, (λuv.v) is the first, what is the second?
10:13:44 <Bor0> ohh. for the whole time I was assuming that λab.b is the identity function
10:13:49 <Philippa> ...of course it's not
10:13:50 <Bor0> that's correct, hmm. thanks
10:13:54 <Philippa> the a is there for a reason
10:14:00 <sellout> Bor0: (λa.a) is identity.
10:14:06 <Bor0> sorry, blindness + little confusion
10:14:23 <Philippa> λab.b is λa.λb.b
10:14:36 <Bor0> yeah, I'll re-do my calculations and see if I get correct result, thanks
10:14:38 <Philippa> ah. Yes, I can see how a screenreader'd make things harder to work with
10:16:17 * elliott is bad enough at keeping binders and nesting straight with sight
10:16:45 <Philippa> mmm, at least there you have the option of drawing the abstract syntax tree out
10:16:47 <Bor0> (λbuv.v)(λab.b) = λuv.v, is this correct?
10:16:58 <Philippa> looks about right, yeah
10:17:18 <elliott> yep, it just ignores the (λab.b) argument
10:18:08 <Bor0> okay. regarding definition of True and False. could you tell me why λab.a is defined as true?
10:18:42 <Bor0> is it so that when expression is applied to it, that same expression will be returned?
10:18:57 <Taneb> Bor0: it's so that when two expressions are applied, the first is returned
10:19:01 <Taneb> So, if-then-else = id
10:19:14 <Cale> Bor0: Are you familiar with basic algebraic data types in Haskell?
10:19:32 <Bor0> I'm not familiar with Haskell at all. I just thought this would be a good intro before stepping into Haskell
10:19:37 <Cale> ah, okay
10:19:59 <Cale> Well, it might be easier to understand true and false if I rename the parameters a little:
10:20:21 <Cale> (λ true false. true) and (λ true false. false)
10:20:44 <`^_^v> is there a function that counts trailing zeros in an int, preferably using a bsf instruction or similar where it is available
10:21:34 <Bor0> it is a bit confusing to me. how can I apply two expressions to a definition of a constant (True)? I understand that there are no constants in lambda, but how does all of this stuff work
10:21:39 <carter> is the state of the Art in nice HOAS librarys still bound http://hackage.haskell.org/package/bound (making sure i'm upt to date)
10:21:46 <Cale> The idea is that in order to represent a choice between a bunch of things, we can use a function which takes those things as parameters, and produces one of them as its result.
10:21:46 <monochrom> lambda calculus this far is not a good intro before haskell. the only lambda calculus knowledge you need is (λa. ...a...) blah = ...blah..., and (λa. ...a...) = (λb. ...b...)
10:22:16 <carter> `^_^v you mean a primop
10:22:20 <carter> you can definitely write one
10:22:23 <Cale> Bor0: Which of the two parameters is "true" is just convention
10:22:24 <carter> read hackders delight
10:22:29 <carter> *hackers delight
10:22:31 <carter> its a lovely book
10:22:35 <Cale> (and you can do it either way)
10:23:26 <Cale> Bor0: If you think about what you *do* with a boolean value -- you typically make use of it in an if/then/else expression.
10:24:10 <Bor0> do you mean a convention in the sense like the definition of church numerals?
10:24:14 <Cale> Bor0: Well, if we want to represent a boolean value with a lambda, we can just write the function which would take the 'then' and 'else' parts as parameters, and produce the appropriate result.
10:24:21 <monochrom> to a large extent, haskell is an intro to lambda calculus, not the other way round
10:25:01 <Bor0> monochrom, I have zero experience with functional programming languages. I have a good background with imperative ones though
10:25:03 <sellout> Bor0: The definition of True and False are tied to the definition of if – (λtca.t c a) – if you look at that, you can see how the test (t) is applied to c and a. If the test is True (λab.a), then it evaluates to c, if the test is False (λab.b), it evaluates to a.
10:25:14 <Cale> Bor0: I mean, it doesn't matter if it's (λfalse true. false) and (λfalse true. true) or if it's (λtrue false. false) and (λtrue false. true), so long as we stick to one or the other.
10:25:18 <monochrom> sure, that doesn't change my statement
10:25:54 <Mortomes> learning lambda calculus before learning haskell makes about as much sense as learning assembly before learning C or whatever
10:26:15 <Bor0> I used to know a good bit of assembly before stepping into C
10:26:19 <monochrom> more like learning abstract algebra before learning counting
10:26:47 <monochrom> counting is concrete. abstract algebra is abstract. haskell is concrete. lambda calculus is abstract.
10:26:58 <Mortomes> Or creating the universe before making an apple pie.
10:27:00 <monochrom> Piaget's theory. concrete before abstract. special before general.
10:27:25 <Cale> It's possible to do things either way around
10:27:38 <Cale> But you really don't need to understand this encoding to get by just fine in Haskell :)
10:27:46 <Bor0> sellout, Cale, thank you. that helped, especially (λtca.t c a) test, I'll try it by hand and see what I get
10:27:46 <Cale> However, it can be nice anyway
10:28:20 <Cale> Bor0: Let me introduce you to simple Haskell datatypes, and we can compare with the encodings of some other things
10:28:25 <ChongLi> monochrom: is that why we have map instead of fmap?
10:28:34 <monochrom> I don't know
10:28:36 <Bor0> sure
10:28:41 <Cale> Bor0: If Haskell didn't have a list datatype built in, we could define one like this:
10:28:51 <Cale> data List a = Nil | Cons a (List a)
10:29:26 <Cale> this means that for any choice of type "a", every value of type List a will either be the value Nil
10:29:52 <Cale> or it will be an expression of the form Cons x xs where x is a value of type a, and xs is a value of type (List a)
10:30:08 <Cale> i.e. every list is either empty, or it is constructed by adding an element to another list
10:30:37 <Cale> e.g. we could have Cons 1 (Cons 2 (Cons 3 Nil))
10:30:50 <Cale> a list with three elements
10:30:59 <Cale> of type List Integer, say
10:31:03 <Bor0> would that list be equivalent to [0, 3, 2, 1] ?
10:31:11 <Cale> It would be [1,2,3]
10:31:35 <Cale> which is syntax sugar for 1 : (2 : (3 : []))
10:31:57 <Bor0> I see, so unlike lambda calculus not the inner-most element is applied first?
10:31:58 <Cale> (the colon is the same thing as Cons, and [] is the same thing as Nil)
10:32:06 <tac> > 1 : (2 : (3 : []))
10:32:09 <lambdabot>   [1,2,3]
10:32:30 <Bor0> s/applied/evaluated/whatever is the right term
10:32:33 <Cale> Now, to represent this sort of list in lambda calculus, we can use functions which take these constructors Nil and Cons as parameters
10:32:37 <monochrom> math enthusiasists' ideal curriculum: category theory in kindergarten, universal algebra in grades 1-12, rings and fields in university, and finally natural number arithmetic in grad school.
10:33:19 <Cale> So, for example, we would use the lambda term (λnil cons. cons 1 (cons 2 (cons 3 nil)))
10:33:20 <sellout> monochrom: Hahaha – seems totally reasonable ;)
10:33:20 <c_wraith> natural number arithmetic is *hard*
10:33:44 <Cale> to represent the list [1,2,3]
10:33:54 <Mortomes> So counterintuitive too.
10:34:04 <fizbin> monochrom: No one should be inflicted with category theory before they can spell.
10:34:38 <Cale> Bor0: Of course, there's a choice of convention involved there, we could decide to take the nil and cons arguments in the other order (which is often convenient for various reasons), but either way works.
10:34:57 <Bor0> you lost me a bit with that last lambda expression
10:35:01 <sellout> fizbin: It’s a good opportunity to learn Greek in concert with your local language.
10:35:23 <Cale> Bor0: Well, in Haskell, we have a way to introduce these new symbols Nil and Cons
10:35:49 <Cale> Bor0: In lambda calculus, we don't exactly have that, but we do have a way to introduce a new symbol locally, which is lambda.
10:36:04 <Bor0> can it not simply be λcons. cons 1 (cons 2 (cons 3))) ?
10:36:38 <Cale> Well, how do you represent an empty list in that scheme?
10:37:01 <Bor0> but aren't we interested in representing only [1, 2, 3] ?
10:37:02 <monochrom> "cons 3" looks incomplete
10:37:25 <fizbin> Bor0: How many arguments does "cons" take?
10:37:34 <Cale> [1,2,3] is structurally 1 : (2 : (3 : []))
10:37:36 <simukis_> this λ calculus discussion is rather interesting. Lo and behold I'll learn λ calculus myself this way :D
10:37:38 <Bor0> one I guess
10:38:05 <simukis_> Bor0, then how (cons 1 (cons 2)) is possible?
10:38:14 <Cale> Bor0: It takes an element x and a list xs, and produces the list whose first element is x, and whose tail is xs
10:38:36 <newsham> LET nil (\f \g f)   LET cons (\x \xs \f \g g x xs)
10:39:19 <Cale> newsham: at least use n and c instead of f and g ;)
10:39:28 <fizbin> Bor0: Either Cons takes two arguments, and (cons 3) is invalid, or it takes one argument and (cons 2 (cons 3)) is invalid.
10:39:31 <newsham> http://www.thenewsh.com/~newsham/lambda/prelude.lam
10:40:10 <Cale> In the untyped lambda calculus, both cons 3 and cons 3 (cons 4) might be "valid"
10:40:19 <Bor0> I see. so in λnil cons. cons1 (cons 2(cons 3 nil))) we are first applying cons 3 and nil, then cons 2 and (cons 3 and nil) then cons 1 and (cons 2 and (cons 3 and nil)) ?
10:40:21 <erisco> working with the eclipse haskell plugin... ever since I got the hoogle database working, the editor has been unusable
10:40:30 <Cale> But there's still a kind of "type error" taking place
10:40:33 <erisco> I can't open any haskell files. the editor hangs indefinitely it seems
10:40:46 <Cale> in that this is going to produce a mess when we try to use it for various reasons
10:40:55 <klrr> i get a really strange runtime error, apperently it says it cant take a type, but it's excpecting that type , https://gist.github.com/klrr/5526630 (code and error in paste)
10:40:56 <Cale> (not least of which being that it's hard to understand how to encode an empty list)
10:40:58 <klrr> any ideas?
10:40:59 <fizbin> Bor0: Yes, that's how we're applying stuff.
10:41:13 <Bor0> okay, it is a bit more clear now
10:41:16 <Cale> Bor0: Well, "first"
10:41:25 <Cale> Bor0: There's no sense of time in the lambda calculus.
10:41:38 <monochrom> fun fact: this Böhm-Berarducci encoding of [a] by (forall r. a -> (a -> r -> r) -> r) is part of list fusion in Prelude and Data.List
10:41:46 <Bor0> how are we getting to the ordered list [1, 2, 3] then?
10:41:49 <Cale> and an evaluator which evaluates outermost first will actually get into fewer infinite loops
10:41:52 <newsham> bor0: why not use a lambda calculus evaluator to play with it? :)
10:42:06 <klrr> i get a really strange runtime error, apperently it says it cant take a type, but it's excpecting that type , https://gist.github.com/klrr/5526630 (code and error in paste), any ideas?
10:42:10 <Cale> Bor0: Well, that's our representation of the ordered list
10:42:19 <Bor0> newsham, that's a good idea. I'll google that, thanks
10:42:29 <fizbin> klrr: Those are two different types.
10:42:29 <Cale> Bor0: What do you want to do with the list?
10:42:33 <newsham> https://docs.google.com/presentation/d/16a4v4UGH71ytOUGd0Y-HgGPPqt7GWIaeZqaufkBgPzw/edit
10:42:44 <newsham> bor0: i've got one at www.thenewsh.com/~newsham/lambda/   also you can easily make your own
10:43:04 <Cale> Bor0: If you want to sum its elements, for example, you could apply the list to the value 0 and the function which adds a pair of numbers.
10:43:07 <klrr> fizbin: no, env is that type
10:43:09 <fizbin> klrr: One type is (IO [(String, IORef Expr)]) and the other type is (IO (IORef [(String, IORef Expr)]))
10:43:39 <Bor0> Cale, I am confused with the representation. I thought that (a(b(c(d)))) the innermost element is evaluated "first", and that's why I thought it's [Nil, 3, 2, 1] instead of [1, 2, 3]
10:43:46 <klrr> fizbin: how do i solve this?
10:43:49 <erisco> and I see to be the only one on google with this problem :(
10:43:49 <Cale> Bor0: Evaluation order doesn't matter
10:44:15 <Bor0> but how are we getting an ordered list as we want then?
10:45:00 <Cale> Bor0: Our representation for the ordered list [1,2,3] *is* the function (λ nil cons. cons 1 (cons 2 (cons 3 nil)))
10:45:25 <Cale> Bor0: Just as in Haskell with my custom list datatype, our representation for that list would be Cons 1 (Cons 2 (Cons 3 Nil))
10:45:33 <newsham> bor0: let f(x) = x + x in   f(g(h(3))    you can do the h(3) first or you can do:   g(h(3)) + g(h(3))
10:45:36 <newsham> you'll get the same
10:45:50 <newsham> there are no side effects to distinguish the ordering of evaluations
10:45:56 <fizbin> klrr: Does this work in ghci?  runIOThrows $ fmap show $ (liftToIO $ readExpr "(+ 2 2)") >>= eval (liftIO $ readIORef defaultEnv)
10:45:57 <Bor0> I see
10:46:14 <Cale> Bor0: Any two evaluation orders which terminate will produce the same result in the lambda calculus.
10:46:27 <newsham> but some orders of evaluation might not terminate while others do
10:47:01 <erisco> how do you delete the local hoogle database?
10:47:10 <erisco> maybe I can get my editor back =\
10:47:23 <Cale> It's safest to always evaluate outermost-first, because it turns out that if any evaluation order terminates, then outermost-first does.
10:47:32 <newsham> the slide deck above (docs.google.com url) talks about lambda calc and mentions all of this
10:47:48 <klrr> fizbin: nope :x
10:47:52 <newsham> its fairly non-formal overview
10:49:14 <Cale> Bor0: so anyway, we could similarly construct a data type for binary trees:
10:49:23 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
10:49:36 <Cale> i.e. a binary tree of values of type a, is either the empty tree Tip
10:49:49 <Cale> or it is a Branch together with a value of type a, and two subtrees of type Tree a
10:50:13 <Cale> Given a tree like:
10:50:21 <Bor0> that is interesting, and probably makes sense to me due to the natural way of implementing trees in imperative programming
10:50:25 <Cale> Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip)
10:50:29 <Bor0> (i.e. recursion)
10:50:45 <erisco> so natural
10:50:52 <Cale> We could encode this in the lambda calculus by again making tip and branch parameters of a function:
10:51:13 <Cale> λtip branch. branch 1 (branch 2 tip tip) (branch 3 tip tip)
10:51:26 <fizbin> klrr: I get an interesting different error from: runIOThrows $ fmap show $ (liftToIO $ readExpr "(+ 2 2)") >>= eval (liftIO (defaultEnv >>= readIORef))
10:51:45 <monochrom> if you get trees, you get all of "algebraic data types". they're all tree-like. even the nil-cons list, that's just a very biased tree.
10:51:52 <Bor0> is that equal to (λtip branch. branch 1) (branch 2 tip tip) (branch 3 tip tip) ? e.g. A * B * C
10:52:10 <klrr> fizbin: I FIXED IT :D
10:52:11 <Cale> Bor0: no, the lambda surrounds the entire expression
10:52:19 <klrr> fizbin: thanks for the help though :3
10:52:25 <Cale> tip and branch are not free variables anywhere there
10:52:56 <Cale> But we never have to say what tip and branch "are", they're just parameters wished into existence by the lambda.
10:53:18 <Cale> When we *use* the tree, we'll specify functions to replace tip and branch with throughout.
10:53:48 <Bor0> okay
10:55:49 <Cale> For example, suppose we want to know how many elements (i.e. branch nodes) the tree has. We could supply 0 for the tip argument, and (λx l r. 1 + l + r) for the branch argument, and this will turn the tree into an expression which computes its size.
10:56:29 <Cale> > (\tip branch -> branch 1 (branch 2 tip tip) (branch 3 tip tip)) 0 (\x l r -> 1 + l + r)
10:56:32 <lambdabot>   3
10:56:40 * hackagebot fb 0.14.6 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.14.6 (FelipeLessa)
10:57:33 <simukis_> Cale: What's the `|`?
10:57:46 <simukis_> >:t (\x l r -> 1 + l + r)
10:57:46 <Cale> simukis_: In the data declaration?
10:57:54 <Cale> :t (\x l r -> 1 + l + r)
10:57:56 <acube> simukis_:  it's a l as in language i think
10:57:59 <lambdabot> Num a => t -> a -> a -> a
10:58:06 <erisco> simukis_, are you looking at a lower L rather?
10:58:14 <simukis_> oh :D
10:58:23 <acube> |l looks pretty similar
10:58:31 <erisco> they look entirely different on my font :P
10:58:32 <Cale> (in a bad font for code ;)
10:58:50 <monochrom> r is right, l is left, candy is sweet, but not as sweet as your cheek
10:59:39 <geekosaur> acube, you need a better font for IRC :)
10:59:44 <Cale> If we instead supply the function (\x l r -> x + l + r), then we add all the elements of the tree
10:59:52 <geekosaur> and/or simukis_
11:00:07 <acube> what font are you using? :P
11:00:28 <monochrom> data I l = I l | II l
11:00:39 <erisco> acube, whatever xchat calls "monospace 9"
11:01:08 <erisco> oh, 9 is the size
11:01:14 <Cale> If we want to know whether the tree has a given element v in it, we can supply false for the tip argument, and the function (\x l r -> x == v || l || r) (sorry to people with bad fonts)
11:01:35 <Cale> > (\tip branch -> branch 1 (branch 2 tip tip) (branch 3 tip tip)) False (\x l r -> x == 5 || l || r)
11:01:40 <lambdabot>   False
11:01:40 <erisco> acube, in that case I presume it is the Monospace font
11:01:43 <Cale> > (\tip branch -> branch 1 (branch 2 tip tip) (branch 3 tip tip)) False (\x l r -> x == 2 || l || r)
11:01:47 <lambdabot>   True
11:02:08 <erisco> acube, then again, my l's look different than the reference here: http://en.wikipedia.org/wiki/Monospace_(Unicode)
11:02:17 <Cale> Of course, in pure lambda calculus, we'd need to implement (==) on numbers, as well as logical OR and booleans...
11:02:20 <oconnor0> optparse-applicative is amazing. it's a decent big of magic to me, but i like it. and haskell's nifty typeclasses make it quite mind blowing. :)
11:02:31 <acube> erisco: Ok, but monospace looks so ugly :/ I will test some fonts :)
11:02:36 <Cale> But these are all things which we can build up :)
11:02:51 <simukis_> acube: Source Code Pro?
11:03:03 <erisco> ugly? would you read code in something not monospace?
11:03:12 <acube> IRC is not only code :D
11:04:08 <Cale> <interactive>:3:1: Not in scope: data constructor `IRC'
11:05:46 <Cale> I'm using Deja Vu Sans Mono 9
11:05:59 <Cale> Sorry, no space in DejaVu
11:06:01 <bitonic> acube: misc-fixed rocks, if you want a unicode font
11:06:09 <bitonic> but I’m biased towards bitmaps :)
11:06:30 <bitonic> and if you have linux you most definitely already have it ehe
11:06:34 <Cale> I just rely on freetype to substitute glyphs from other fonts
11:06:46 <Bor0> thanks for all the help guys. will continue a bit later after break
11:07:10 <bitonic> Cale: that often turns very ugly
11:07:23 <monochrom> I have a feeling we're going to prove the Church-Rosser theorem before we learning basic Haskell
11:07:36 <bitonic> if you use misc-fixed or even better unifont you’ll probably never have to see the backup font
11:08:03 <dmwit> monochrom: Sounds like a fun course.
11:08:59 <bitonic> monochrom: what course is this?
11:09:07 <Cale> bitonic: I don't think there's any font which has actually good looking results for both English and Japanese
11:09:09 <monochrom> Bor0's self-inflicted course
11:09:43 <bitonic> Cale: ah, that’s true... I was mostly referring to symbols
11:09:43 <simukis_> Cale: Oh, most japanese fonts has rather good english glyphs
11:09:45 <Cale> monochrom: Church did
11:09:48 <monochrom> "I want to learn Haskell. I think I can solve this by learning lambda calculus first." see the XY problem.
11:10:06 <Cale> (but he never made it as far as Haskell)
11:10:41 <erisco> acube, I did the survey at identifont and my font is close to "EF Lucida Mono" but not exactly
11:11:07 <sproingie> monochrom: but hey if you learned lambda calculus, then the diversion paid off anyway
11:11:21 <Cale> monochrom: Also, can you *really* say that you understand the lambda calculus these days if you don't know about Cartesian closed categories? Better throw in at least a first course on category theory :)
11:11:32 <sproingie> now "I need to write X in haskell, so I'll learn lambda calculus first", that would be a real XY problem
11:11:36 <sproingie> (XY combinator problem)
11:12:01 <geekosaur> erisco, "monospace" on most linuxes is bitstream vera mono by default; you can override the font mappings somewhere in your settings
11:12:24 <dmwit> lambda calculus is a gateway drug
11:12:38 <geekosaur> er, bitstream vera sans mono
11:12:50 <erisco> geekosaur, hmm not on linux but that font seems to match
11:13:36 <geekosaur> well, some platform using gnome or kde. usually linux but also available on the *bsds and solaris/illumos, among others
11:14:18 <Cale> @quote shapr
11:14:18 <lambdabot> shapr says: Size matters.
11:14:38 <Cale> I wonder if the X combinator quote is still in there somewhere
11:14:39 <Cale> @quote shapr
11:14:40 <lambdabot> shapr says: If I were to do this in Python, it would be done by now. and it would be full of bugs.
11:14:42 <Cale> @quote shapr
11:14:43 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
11:14:43 <lambdabot>  what you just said?"
11:14:59 <geekosaur> *snrk*
11:15:52 <erisco> well since my editor is borked and I can't work maybe I'll just do reading on lambda calculus today
11:16:00 <erisco> http://plato.stanford.edu/entries/lambda-calculus/ seems quite interesting
11:16:05 <monochrom> "I want to learn lambda calculi. I think I can solve this by following Moggi's path and learn monads first." this is the ηµ problem.
11:16:18 <Cale> ahaha
11:16:24 <simpson> @quote x.comb
11:16:24 <lambdabot> kmc says: a wise man once said that the entire world can be described as convex combinations of drugs, math, and cardboard
11:17:28 <Cale> oh, it was a Riastradh quote...
11:17:34 <Cale> <SyntaxNinja> it is a little disturbing when lambdabot starts channeling shapr
11:17:35 <Cale> <Riastradh> What about when shapr starts channeling lambdabot?
11:17:35 <Cale> <Riastradh> shapr: @yow
11:17:35 <Cale> <shapr> I was in MINNETONKA!
11:17:35 <Cale> <shapr> Butch Cassidy had my children!
11:17:36 <Cale> <Riastradh> shapr: @eval (X X X) (X (X X)) (X (X X)) ((X (X X) (X X X))
11:18:02 <Cale> also a little too long for @quote I guess
11:18:17 <Cale> http://web.archive.org/web/20070609061216/http://www.haskell.org/hawiki/QuotesPage -- I miss this
11:20:56 <monochrom> why was shapr trolling in #java?! "I would use monadic parser combinators"
11:22:47 <dEPy> any1 can look at this http://hpaste.org/87337 ? says "parse error on input 'let'" ... O_o
11:23:27 <monochrom> which line? 21?
11:23:38 <dmwit> dEPy: "m <- getLine" is indented differently than the lines following it.
11:23:41 <monochrom> as you see you have allignment problems there
11:23:45 <c_wraith> yeah, line 20 is indented wrong
11:24:06 <dmwit> You and your value judgments.
11:24:14 <dmwit> Maybe lines 21-23 are indented wrong.
11:24:18 <c_wraith> The compiler will back me up on this.
11:24:24 <dEPy> oh my, tnx
11:24:25 <c_wraith> they're all wrong.
11:24:28 <dmwit> Or maybe they're all indented wrong and he intended to use {;}.
11:24:36 <dmwit> Or maybe they're all indented right!
11:25:11 <monochrom> line 20 is too right, which is wrong  <duck>
11:25:14 <dEPy> btw, do I have to import somethign to use Just ?
11:25:22 <monochrom> no
11:25:28 <dmwit> ?index Just
11:25:28 <lambdabot> Data.Maybe, Prelude
11:25:40 <dmwit> The Prelude is implicitly imported unless you explicitly ask for it not to be.
11:26:28 <sproingie> you may have to import things to use various instances of Maybe
11:26:39 <sproingie> Control.Monad for example
11:26:59 <sproingie> but Just by itself is in Prelude
11:27:16 <dmwit> foldr (++) [] is probably better spelled "concat"
11:27:45 <dmwit> (foo `div` n, foo `mod` n) can be spelled foo `divMod` n
11:29:20 <dEPy> Also says parse error on input 'Just'
11:29:30 <dmwit> for getList, you may enjoy replicateM
11:29:33 <dmwit> :t replicateM
11:29:36 <lambdabot> Monad m => Int -> m a -> m [a]
11:29:50 <dmwit> dEPy: Paste the code you're trying now?
11:29:55 <acube> @src replicateM
11:29:55 <lambdabot> replicateM n x = sequence (replicate n x)
11:30:14 <dEPy> oh y, sry.. here it is: http://hpaste.org/87338
11:30:43 <dmwit> dEPy: Lines 10 through 16 must align with the 'f' in line 9.
11:30:59 <dmwit> As they did in your previous paste. Not sure why you changed it...?
11:31:17 <acube> dEPy: Maybe it's also a good idea to use 'where' in this case
11:31:41 <dEPy> dmwit, I see now.
11:31:55 <dEPy> acube, first I'll I wanna make it work. :D then optimize
11:32:29 <dmwit> "let" and "where" don't really have different time complexity. When both are available, the choice is mostly aesthetic.
11:36:08 <monochrom> using "let" is just fine
11:38:04 <dEPy> another error http://hpaste.org/87339 -> Irrefutable pattern failed for pattern Data.Maybe.Just mIdx
11:38:46 <monochrom> then that means, (elemIndex "m" grid) is Nothing
11:38:55 <dEPy> oh sh1t, forgot about that
11:39:38 <n00b101> hello, I have a theoretical question about programming language design. I am trying to implement a programming language (and compiler) that is as dead simple as possible. So far I have been sticking to pure functional programming expression. But now I have a tricky situation, where I need to store values in an array. This means I have to introduce statements into my language, like assign stmt and return stmt. Is there any way to avo
11:40:10 <dmwit> cut off at "any way to avo"
11:40:22 <n00b101> sorry ... "any way to avoid this"
11:40:54 <dmwit> Haskell does not have statements as a distinct syntactic category from expressions.
11:40:58 <dmwit> Does this answer your question?
11:41:21 <n00b101> Destructive updating of memory languages is a hard requirement, because the language is targeting GPUs. In CUDA, GPU "kernel" functions can only have void return type, kernel functions produce results by updating values in arrays that have been pre-allocated in the GPU's memory
11:41:32 <n00b101> sorry i mean "destructive updating of memory LOCATIONS"
11:43:13 <ATuin> The type signature for `nmHeader' lacks an accompanying binding <- what does this exactly means?
11:43:29 <dmwit> It means you gave a type signature for nmHeader, but never defined it.
11:43:38 <dmwit> > let foo :: Int in 3
11:43:42 <lambdabot>   The type signature for `foo' lacks an accompanying binding
11:43:50 <n00b101> i get that it's impossible in a pure functional programming language, but im trying to understand what options are available other than making it into whole-hog imperative lamguage
11:43:56 <dmwit> > let foo :: Int; foo = 3 in 5
11:43:58 <lambdabot>   5
11:44:01 <ATuin> so its not defined the equation
11:44:09 <dmwit> yes
11:44:16 <ATuin> ok
11:44:25 <ATuin> i saw the problem :)
11:44:38 <Botje> n00b101: CPS-style updates.
11:44:56 <Botje> write position memory (\_ -> ...)
11:45:08 * dmwit notes once again that Haskell (and other functional languages -- OCaml, for example) support mutation and nevertheless are not imperative
11:45:50 <tomejaguar> Can ScopedTypeVariables work with constraints to disambiguate an instance?
11:46:09 <dmwit> Sometimes. Can you make the question more concrete?
11:47:21 <hpaste> tomejaguar pasted “Instances” at http://hpaste.org/87341
11:47:29 <tomejaguar> dmwit: ^^
11:47:54 <tomejaguar> That paste is quite far from what I want to do, but if I can get the paste to work I should be able to get my full featured case to work
11:49:06 <dmwit> Dunno what Function is, but at a guess just enabling STV and putting a "forall b." in front of the type of composeFunction will work.
11:49:52 <dmwit> ...if all you need is to say that the "b" in "columns'"'s type annotation is the same as the "b" in "composeFunction"'s type annotation.
11:49:56 <tomejaguar> Ah does STV always need explicit forall?
11:50:11 <dmwit> The explicit forall indicates when you want the variables to be bound.
11:50:18 <dmwit> With no forall, they are not bound.
11:50:24 <dmwit> Sometimes you want them bound, sometimes not.
11:50:43 <tomejaguar> I thought "a -> b" was always "forall a b. a -> b"
11:50:55 <n00b101> Botje: thanks, ill look into that
11:50:59 <dmwit> ScopedTypeVariables changes the meaning of forall.
11:51:54 * dmwit feels as though n00b101 is ignoring him for some reason
11:52:13 <tomejaguar> dmwit: Oh OK.  Thanks dmwit!
11:52:44 <n00b101> dmwit: sorry brb
11:53:58 <dEPy> Need help with making this code more readable and simpler: http://hpaste.org/87343   it basically gets a grid of '-' and there is 'm' whic his Mario and 'p' which is princess and it should print the moves for mario to get to the princess (UP, DOWN, ...)
11:55:12 <simukis_> oh, by the way, how to you look at code which actually uses unicode instead of regular ascii. That is → instead of -> and ≡ instead of ==.
11:55:47 <sellout> simukis_: What do you mean “how do you look at it”?
11:56:04 <dmwit> dEPy: I made a few suggestions above. Did you see them?
11:56:09 <raid> some1 has an idea how i can write a data declaration to represent a tic tac toe field? "data Row = A | B | C" and "data Column = X | Y | Z" are predefined
11:56:19 <simukis_> sellout: your first reaction when you have to maintain code written like that :)
11:56:27 <dmwit> raid: What have you tried?
11:56:40 <dEPy> dmwit, sry I didn't :S
11:56:50 <dmwit> This sounds like homework, and the general homework policy is to ask for Big Tall Moneys. But we make an exception for people who try hard.
11:56:52 <dEPy> oh you mean let and where?
11:56:52 <monochrom> simukis_: no reaction. I'll just do it.
11:57:04 <dmwit> I don't mean let and where.
11:57:20 <hpaste> Teifion pasted “Euler problem 7” at http://hpaste.org/87345
11:57:20 <raid> dmwit: a list with a pair ((Row,Column), Maybe Player)
11:57:21 <dmwit> 14:27 < dmwit> foldr (++) [] is probably better spelled "concat"
11:57:36 <dmwit> 14:27 < dmwit> (foo `div` n, foo `mod` n) can be spelled foo `divMod` n
11:57:38 <raid> but i dunno how to efficiently work with that structure
11:57:44 <dmwit> 14:29 < dmwit> for getList, you may enjoy replicateM
11:58:05 <dmwit> raid: That sounds like a pretty good start.
11:58:10 <dEPy> I can only change my displayPathtoPrincess sincei t's automated testing
11:58:11 <TeifionJordan> I'm having a go at a Euler problem again (7 this time) and trying to build up a list of primes. I get a compile error though and was wondering if someone could point me in the right direction please - http://hpaste.org/87345
11:58:32 <dmwit> raid: To begin with, I suggest that you ignore efficiency a little bit. Don't worry about O(n) vs. O(log n)... but do worry about O(n^2) vs O(n).
11:58:35 <TeifionJordan> If anybody can suggest a better and "more Haskell" way of doing things that'd be handy too, I'm probably still thinking in Python
11:58:52 <dEPy> btw, was that "homework" and stuff regarding what I do? :)
11:59:00 <dmwit> No, it was aimed at raid.
11:59:12 <dEPy> oh :) I'm too old for homework anyways :)
11:59:13 <int-e> TeifionJordan: you need parentheses around the  counter+1  argument
11:59:19 <int-e> or arguments.
11:59:32 <dmwit> And it was premature. I shouldn't have said it at all.
11:59:49 <dmwit> raid: Have you found an inefficient way to work with that structure? Just how bad is it?
12:00:00 <TeifionJordan> Added it in, I get the same error :(
12:00:08 <raid> dmwit: i'm currently struggling with the Show instance
12:00:18 <dmwit> hm
12:00:31 <dmwit> The derived Show instance should be fine, provided Row, Column, and Player have Show instances.
12:00:45 <raid> is there something like splitAt which keeps splitting until the list is empty and returns [[a]]
12:00:55 <dmwit> Yes, see Data.List.Split.chunks
12:00:58 <dmwit> ?hackage split
12:00:58 <lambdabot> http://hackage.haskell.org/package/split
12:01:07 <monochrom> "data Row = A | B | C deriving Show" similarly for Column
12:01:40 <dmwit> I guess it's actually called "chunksOf"?
12:01:45 <monochrom> Data.List.Split is in the Haskell Platform
12:02:15 <Blablu> is here anybody who used the mongodb haskell driver? Can I use logical operators with the driver? I don't see how.
12:02:19 <dEPy> dmwit, tnx for the pointers, looks abit better now :)  I really like divMod
12:02:26 <int-e> TeifionJordan: the thing it's complaining about there though is that the second argument of xth_prime is of type 'a', which cannot be compared to the Int that is returned by 'length primes'. So maybe change that type signature to say ... => [a] -> Int -> a -> a.
12:02:57 <TeifionJordan> int-e: Perfect, it compiles
12:03:01 <TeifionJordan> thank you very much :)
12:03:19 <TeifionJordan> especially thank you for explaining why there was an issue
12:03:27 <dEPy> Could I improve anything else here? http://hpaste.org/87347   Is the approach to the solution ok? Or it there much shorter version of this?
12:04:56 <Botje> dEPy: well, getList n = replicateM n getLine :]
12:05:41 <int-e> negate (my - py)  looks funny :)
12:05:42 <raid> ah, splitEvery does the job. Hoogle does not know that, hmm, weird
12:05:50 <dEPy> just displayPathtoPrincess function, can't change anything else cause of automated testing :)
12:05:50 <int-e> (py - my) is equivalent
12:06:05 <dEPy> int-e, good catch
12:07:16 <dmwit> raid: Try adding "+split" to your Hoogle query.
12:07:29 <dmwit> raid: (Yes, I know this sort of defeats the purpose in that you have to know which package to query.)
12:07:51 <dmwit> raid: Also, Hayoo is quite nice as well.
12:08:53 <int-e> dEPy: I'd be tempted to abuse replicate, saying  replicate y "UP" ++ replicate (-y) "DOWN" ++ replicate x "RIGHT" ++ replicate (-x) "LEFT", but your version is more readable :)
12:09:21 <dmwit> dEPy: Also, the interface you're coding to is awful. You can tell your teacher I said so. =)
12:11:00 <monochrom> the current state of most Haskell teachers is similar to that of highschool math teachers, i.e., not knowledgeable enough
12:11:38 <int-e> dEPy: it may make sense to define a function  findCoord :: [String] -> Char -> Maybe (Int, Int)  that determines the coordinates of a character.
12:12:14 <int-e> and have a type synonym, type Grid = [String] -- tentatively, to be changed later.
12:12:24 <Chousuke> Our maths teacher in high school was pretty good.
12:12:29 <simukis_> monochrom: Why do they teach it then? I haven't been to university yet, but I figure professors get to choose whatever language they prefer?
12:12:38 <Chousuke> But I think the requirements for becoming a teacher are pretty high in Finland
12:13:12 <int-e> the language chosen won't matter much if you can't program ;)
12:13:38 <monochrom> I don't know. I'm sure they prefer Haskell too, but they also prefer, you know, String as the universal data structure...
12:13:52 <monochrom> and various other personal delusions
12:15:17 <monochrom> look at http://hpaste.org/41000
12:15:40 <mantovani> http://hackage.haskell.org/package/soap
12:15:45 <mantovani> someone has examples ?
12:16:23 <Botje> monochrom: I .. uh .. vaguely remember that code from helping someone a few years ago.
12:17:00 <n00b101> dmwit: i suppose what im trying to understand is how does haskell support mutation while remaining functional?
12:17:30 <Chousuke> that's a very interesting question
12:17:33 <monochrom> this is the homework given out by some prof a few years ago. this prof defines this mapReduce which is the most general universal list function ever, and tortures students to do various simple tasks by shoehorning into mapReduce
12:17:40 <Chousuke> the answer is interesting as well
12:17:53 <dEPy> dmwit, it's not for teacher :D I'm just started doing some challenges on www.hackerrank.com to get Haskell under my fingers more permanently. I'm long way out of schoold :D I'm 27
12:17:59 <Botje> monochrom: that was indeed th experience :)
12:18:26 * dmwit is 27 and still in school =P
12:18:39 <dEPy> :D
12:18:48 <monochrom> the students did not even have time to grok higher-order functions and simpler ones like foldr before this
12:18:57 <dmwit> n00b101: One way people explain it is that the functional language builds up a description of the mutations to do, then the runtime does those mutations.
12:18:59 <dEPy> I am thinking about going back to getting masters in computer science, not sure yet :)
12:19:31 <dmwit> n00b101: But OCaml's model is simpler: some functions just Do Stuff when they're called with arguments.
12:19:33 <monochrom> this is what I mean by personal delusions. one single prof thinks he has the best thing since generalized sliced bread, and he's going to inflict it on students
12:19:51 <n00b101> dmwit: im looking at it from a compiler implementation perspective. as soon as i introduce assignment statement into the abstract syntax tree, i have a problem because statements are fundamentally different from expressions -- the distinguishing feature seems to be that statements do not return a value
12:20:07 <immanuelkant> monochrom: that will prepare his students well for creating googles mapreduce tasks
12:20:15 <dmwit> n00b101: Yes, you should not have a separate syntactic class for statements.
12:20:33 <Botje> n00b101: introduce a (begin exp exp) construct, fixed :P
12:20:38 <dmwit> Scratch that. What I mean is that you do not *need* a separate syntactic class for statements.
12:20:39 <n00b101> dmwit: I'm implementing a compiled language using LLVM, so "runtime does mutations" is difficult for me to understand in my context
12:20:51 <Chousuke> n00b101: another way is to wrap all side-effecty stuff in functions, and never allowing the user to run those functions directly
12:21:00 <dmwit> I'm not sure I see why "runtime" and "compiled" are at odds.
12:22:08 <n00b101> Chousuke: that's what im doing now. I left the "Function" class as a pure function, and introduced a new calls called "Procedure" which is an ordered collection of statements and may return a value (in which case it can be called from expressions). But i feel like this simple changed has punched a hole in the language that will make it difficult to reason about down the road
12:22:48 <Chousuke> n00b101: say you have some function "evil" that does side-effects
12:23:16 <Chousuke> then the lambda \_ -> evil is a  pure value
12:23:48 <Chousuke> and if you  abstract that away, you can make it so that only the runtime can execute lambdas like that, in a well-defined way
12:24:19 <Chousuke> and you provide the tools to combine two such lambdas to allow combining side-effects
12:24:41 <dmwit> n00b101: What I'm saying is this: eventually you will have to have some terms which are not defined in the language itself; primitive operations. There's nothing wrong with these primitive operations doing IO.
12:25:37 <n00b101> Chousuke: but what is the return type of evil?
12:25:48 <dmwit> One standard choice is "unit".
12:25:50 <dmwit> data () = ()
12:26:08 <dmwit> :t putStrLn -- for example
12:26:11 <lambdabot> String -> IO ()
12:27:05 <Chousuke> n00b101: well, that depends on what it does. 'evil' is basically a primitive op that is allowed to circumvent the purity
12:27:32 <simukis_> I mildly recall a quote relating to IO and evil… http://www.reddit.com/r/haskell/comments/1c32n4/can_someone_explain_haskells_wager_to_me/c9cjpdi here it is.
12:27:38 <Chousuke> but by wrapping it behind an opaque, pure interface, you can control the side-effects
12:28:02 <immanuelkant> is there a way to type multiline expression in GHCi,
12:28:19 <Botje> immanuelkant: :{ and :}
12:28:36 <n00b101> Chousuke: i'm specifically interested in the side effect of storing values in arrays (nothing else)
12:28:43 <Chousuke> n00b101: that's pretty much what haskell does as far as I know (IO is basically an opaque state monad, where the only purpose of the "state" is to enforce sequential execution)
12:28:53 <n00b101> hm i see
12:31:26 <immanuelkant> when i do :{ my prompt is changing to all the modules i imported
12:31:34 <immanuelkant> is there a way to change that
12:32:10 <n00b101> i guess what i was hoping for was some "pure functional" way of representing storing values in an array without getting into full-blown side effects semantics. but it seems to be all-or-nothing, as soon as the language can mutate some value then all other side effects follow
12:32:51 <Chousuke> n00b101: well you can always return a new array
12:33:08 <Chousuke> n00b101: and you can restrict your language to only allow certain kinds of side-effects
12:33:47 <Chousuke> after all, the only side-effects that will be possible are the ones that the runtime actually implements
12:33:54 <dmwit> n00b101: Not at all. You can certainly allow only mutability.
12:34:18 <Chousuke> so if you never expose anything but array mutation, it's probably not possible to implement any other side-effect... unless your implementation is exploitable somehow :P
12:34:39 <dmwit> If your only primops are to write to a mutable array, then... well, there's nothing more to say. All you can do is write to mutable arrays.
12:34:47 <n00b101> Chousuke: the trouble is that im targeting GPU processors. a GPU program basically has to be of the form "void foo(float* in, float* out)"  ... the body of the function cant allocation any memory, it needs to mutate its arguments.
12:35:05 <Chousuke> n00b101: that's possible to do, yes
12:35:16 <n00b101> with CPS?
12:35:20 <dmwit> no need
12:35:49 <Chousuke> n00b101: you can define all your primops as a data type, and then write a compiler for a list of values of that data type.
12:36:00 <Chousuke> that's one way
12:36:14 <sproingie> ST.  the "batchy" nature of GPU programs would suit it well
12:36:23 <dmwit> indeed
12:36:29 <Rags_> Hi - any gvim users?
12:36:36 <Chousuke> isn't there a haskell library for GPGPU programming?
12:36:37 <dmwit> ?where justask
12:36:37 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
12:36:58 <Chousuke> http://hackage.haskell.org/package/accelerate
12:37:06 <dmwit> Or, the more snarky answer: "yes, there are gvim users".
12:37:32 <n00b101> Chousuke: yes ive heard of that library
12:37:40 <simukis_> Rags_: gvim as in graphical vim frontend or just a vim compiled with GUI?
12:38:03 <monochrom> I would much prefer: every non-user speaks up and says "no, I am not a gvim user"
12:38:25 <Heffalump> I'm not a gvim user.
12:38:25 <dmwit> "I am not a gvim user, therefore there are no gvim users."
12:38:34 <monochrom> I am not a gvim user
12:38:51 <monochrom> and no, the point is not "therefore there are none"
12:39:16 <dmwit> If the question is "are there any gvim users" and the answer is "no, I am not a gvim user", what would you infer?
12:39:43 <Rags_> my question is how do i use c-c c-z and c-c c-l in gvim
12:39:46 <dmwit> Personally, the smallest inferential leap for me is to insert "because" after the comma.
12:40:26 <geekosaur> Rags_, those look like emacs keys. (g)vim is very very unlike emacs
12:41:15 <Rags_> how do I get that functionality in gvim. i have haskellmode vim installed
12:41:33 <Rags_> how do i get the interactiion with ghci as a repl
12:42:16 <dmwit> Personally, I get my ghci interaction from a terminal, not from vim.
12:42:28 <quchen> Why is cycle defined as "cycle xs = xs' where xs' = xs ++ xs'", and not the naive way "cycle xs = xs ++ cycle xs"? Inlining?
12:42:36 <dmwit> No, sharing.
12:42:40 <Rags_> i have a haskell file open in gvim, how do I interact with ghci similar to emacs
12:42:51 <dmwit> "you don't"
12:43:01 <sproingie> by installing emacs
12:43:13 <quchen> dmwit: Sharing?
12:43:16 <Taneb> I ought to learn how to use pipes or conduit or something one day
12:43:17 <lambdabot> Taneb: You have 1 new message. '/msg lambdabot @messages' to read it.
12:43:33 <dmwit> quchen: GHC will share named things. In "cycle xs = xs ++ cycle xs", the only named things are "cycle" and "xs", so the result of calling "cycle xs" is not shared.
12:43:34 <quchen> Taneb: Pipes has an excellent "Tutorial" module.
12:43:38 <monochrom> quchen: it uses O(1) memory vs O(n) memory
12:43:51 <Taneb> quchen: the matter is sitting down and reading it
12:43:52 <Taneb> And then remembering it
12:43:53 <acowley> pipes seems to still be going through pretty significant changes as it evolves
12:43:54 <aristid> Taneb: and tekmo has written a lens tutorial, so you owe it to him
12:44:03 <dmwit> quchen: On the other hand, in "cycle xs = xs' where xs' = xs ++ xs'", "xs'" is also given a name, so it will be shared and, in particular, in "xs ++ xs'" it refers to itself.
12:44:39 <quchen> dmwit: Oh, so the naive approach will unroll xs again and again?
12:44:42 <geekosaur> Rags_, vim standard behavior is :make runs a program, there's also :ghci to evaluate some expression in ghci, but it looks like haskellmode-vim does not support an interaction buffer
12:44:44 <dmwit> quchen: Where here "itself" really means "the in-memory representation of itself", and not "the semantic object it represents".
12:44:47 <dmwit> quchen: correct
12:44:59 <quchen> I see. Good to know, thanks.
12:45:39 <quchen> Taneb: Well, just look over it. Even if you don't remember it you'll have kind of a "woah" moment. :-)
12:46:19 <fragamus> whats the topic today
12:46:38 <monochrom> the () type
12:47:02 <fragamus> ah
12:47:13 <quchen> Ah, (), my favourite monoid.
12:47:57 <Taneb> quchen: it's also a group!
12:48:13 <quchen> > () <> () <> () <> () <> () <> () <> () <> () <> () <> () <> () <> ()
12:48:17 <lambdabot>   ()
12:48:45 <Taneb> > mconcat [(),(),(),()]
12:48:47 <lambdabot>   ()
12:49:07 <dmwit> It's a vector space! It's an ultrametric space! It's.... UNIT
12:49:18 <quchen> () is simply *the* type.
12:49:48 <quchen> Wait, it's not a Functor?
12:49:49 <quchen> :-(
12:50:46 <dmwit> Nearly. data Unit a = Unit is a Functor.
12:51:00 <dmwit> (but not a Monad)
12:51:05 <quchen> Ah right, it's not a type constructor, silly me
12:51:06 <dmwit> wait
12:51:11 <dmwit> It might even be a Monad, by golly.
12:51:30 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/88120/
12:51:33 <quchen> It probably is.
12:51:41 <sproingie> (FloorWax a, DessertTopping a) => Shimmer a
12:51:41 <quchen> I wonder whether there is a typeclass () is not.
12:52:45 <monochrom> () is not a Num instance
12:52:48 <dmwit> monochrom: I find this answer unsatisfying. "Q: How is pseq different from seq? A: We can observe that pseq is different from seq." <- this is not the answer to a "how" question
12:53:18 <monochrom> perhaps some other posts answered that.
12:53:53 <monochrom> there are too many people explaining theories, and too few people showing empirical, observable evidence
12:54:19 <monochrom> at the extreme, none of the theories match empirical evidence
12:54:25 <quchen> Well the question is theoretical in nature
12:54:44 <quchen> seq = pseq is a valid implementation of seq after all (or would be if it wasn't primitve etc)
12:55:02 <tomejaguar> Is it sensible to write a typeclass "FlattenN" with instances that turn nested tuples with N leaves into a flat size N tuple?
12:55:10 <tomejaguar> or is that kind of thing going to lead to madness?
12:55:22 <dmwit> It leads to madness.
12:55:26 <c_wraith> that will lead to madness, but you might learn something along the way.
12:55:30 <quchen> tomejaguar: Tuples aren't very easily generalized to "length N".
12:55:31 <dmwit> For one thing, how do you know when to stop flattening?
12:55:33 <c_wraith> that is, you might learn why not to do it
12:55:34 <c_wraith> :)
12:55:42 <quchen> tomejaguar: Actually, it's impossible, unless you're edwardk.
12:55:51 <c_wraith> that's more of an Oleg trick
12:56:03 <DanBurton> you can turn it into a size N list
12:56:05 <quchen> tomejaguar: Actually, it's impossible, unless you're one of the Lens guys..
12:56:22 <edwardk> > ("hello","world","!!!")^._2
12:56:26 <lambdabot>   "world"
12:56:30 <quchen> Hello there! :-)
12:56:42 <tomejaguar> Is it really impossible?
12:56:50 <edwardk> > ("hello","world","!!!") & _2 %~ length
12:56:52 <tomejaguar> I would have thought you could just have one instance per "shape" of nesting.
12:56:53 <lambdabot>   ("hello",5,"!!!")
12:56:56 <quchen> tomejaguar: It's possible, but you have to enter a world of pain.
12:57:10 <dmwit> tomejaguar: The problem is that you don't know the nesting shape.
12:57:23 <edwardk> tomejaguar you can write the typeclass you just have to write a ton of instances
12:57:24 <dmwit> tomejaguar: (a, b) unifies with both (Int, Double) and (Int, (Double, Char)).
12:57:32 <monochrom> quchen: Haskell is not merely theoretical. every Haskell question has an empirical side. I would not be doing this "empirical" "scientific" thing in a math forum.
12:57:34 <tomejaguar> edwardk: yeah that's what I was thinking
12:57:34 <edwardk> and they overlap in one direction
12:57:38 <edwardk> so inference will suck
12:57:52 <tomejaguar> Oh I see
12:57:57 <tomejaguar> they do indeed overlap
12:58:00 <edwardk> you can use the (,,,) side to figure out the nested shape
12:58:04 <edwardk> but not vice versa
12:58:09 <quchen> monochrom: I was just referring to this question specifically, not Haskell in general. What you say is right of course.
12:58:19 <tomejaguar> OK, maybe it's possible if you know the first component is a leaf
12:58:20 <dmwit> edwardk: I challenge this assertion.
12:58:31 <monochrom> this question specifically is also a Haskell question and cannot be purely theoretical.
12:58:41 <edwardk> dmwit: of sucking inference?
12:58:47 <quchen> monochrom: I just meant to say "seq follows certain semantics, and you shouldn't make any assumptions about it beyond that. seq may or may not be (p)seq-ential.
12:58:56 <dmwit> edwardk: That you can infer the nested side from the flattened one.
12:59:07 <edwardk> dmwit: for a finite number of instances
13:00:18 <mekeor> i need your advice for the implementation of a tree-like data structure. it has one root and the root has "children" (idk how to call them correctly) and the children have children etc.. but the important difference to a tree is that two (random) elements can have the same child. i need to do two operations on the data structure: (1) finding all *direct* children of an element; and (2) finding all (direct and indirect) "ancestors" of
13:00:18 <mekeor> one element/child. – how would you implement it? (oh, btw, a child contains a string.)
13:00:21 <edwardk> dmwit: class Derp x y | x -> y where derp :: x -> y; instance Derp (a,b) (a,b) where derp = id; instance Derp (a,b,c) ((a,b),c) where derp (a,b,c) = ((a,b),c); instance Derp (a,b,c,d) (((a,b),c),d) where derp (a,b,c,d) = (((a,b),c),d)
13:00:43 <quchen> TH to the rescue! ;-(
13:00:48 <edwardk> you just need to pick when to stop or use TH =)
13:01:04 <edwardk> in which case you still need to pick when to stop but don't get carpal tunnel
13:01:04 <dmwit> Your nesting is insufficiently exciting.
13:01:35 <edwardk> oh you want arbitrary nestings? then you're screwed =)
13:01:36 <DanBurton> it's ok, TH can perform IO and randomize the nesting... /gag
13:01:38 <mekeor> i thought of [(String,[String])] where the [String] is the list of direct fathers of one element... but with this implementation it's not nice to do the first task.
13:01:45 <edwardk> you can select _a_ canonical nesting is all i was asserting
13:02:11 <dmwit> Okay.
13:02:33 <DanBurton> this is where you reify the typeclass into a plain old record and pass the desired instances along by hand
13:03:05 <acowley> This is where you step back and ask yourself why you're doing this.
13:03:18 <dmwit> acowley++
13:03:35 <DanBurton> aw that's no fun
13:03:37 <conphile> @pl \f -> lp f f
13:03:38 <lambdabot> join lp
13:03:42 <conphile> thanks lambdabot
13:03:51 <dmwit> mekeor: I don't have good advice for you, but I think the structure you're describing is usually called a DAG.
13:03:58 <DanBurton> conphile: requires the function instance of Monad
13:04:08 <mekeor> dmwit: what does DAG stand for?
13:04:10 <conphile> DanBurton: aye
13:04:15 <dmwit> mekeor: You might consider just going straight to fgl and reusing its implementations of various algorithms for your task.
13:04:18 <conphile> I thought that was what it was, just checking with lambdabot
13:04:21 <quchen> conphile: That's the reader monad.
13:04:23 <dmwit> mekeor: Directed, Acyclic Graph
13:04:32 <mekeor> hm
13:04:37 <conphile> aye
13:04:48 <mekeor> dmwit: thank you.
13:04:51 <DanBurton> import Control.Monad.Instances
13:04:52 <conphile> lambdabot's @pl seems to abuse it quite hard for the more complicated instances
13:05:08 <dmwit> mekeor: (trees add the "only one path between any two nodes" constraint which you seem to want to violate)
13:05:19 <conphile> thanks for the advice DanBurton and quchen
13:05:52 <mekeor> dmwit: yep
13:05:57 <quchen> conphile: The reason that Lambdabot is using those extensively is probably rooted in the fact that Reader is somewhat close to SKI calculus.
13:06:18 <quchen> (Just a guess though.)
13:10:25 <mekeor> dmwit: fgl seems somewhat ugly
13:12:11 <immanuelkant> t
13:21:51 <immanuelkant> -: is this a valid operator
13:22:01 <immanuelkant> @ty (-:)
13:22:04 <lambdabot>     Not in scope: `-:'
13:22:04 <lambdabot>     Perhaps you meant one of these:
13:22:04 <lambdabot>       `-' (imported from Prelude),
13:22:25 <immanuelkant> x -: f = f x
13:22:29 <Taneb> > let x -: y = replicate y x in 3 -: 5
13:22:34 <lambdabot>   [3,3,3,3,3]
13:22:53 <immanuelkant> from learnyouahaskell
13:23:49 <FireFly> Sure is
13:24:37 <immanuelkant> ohh, so he first defined -: by x -: f = f x
13:26:47 * hackagebot simplex 0.3.7 - A simple markup language that translates to LaTeX  http://hackage.haskell.org/package/simplex-0.3.7 (JulianFleischer)
13:29:35 <andrewsw> anyone up to speed on http-conduit and memory usage?
13:29:57 <andrewsw> even the most simple example, when used to fetch over https allocates 495MB.
13:31:38 <donri> andrewsw: might want to ask #yesod
13:43:32 * mekeor just asked his first SO question O.o – <http://stackoverflow.com/questions/16406950/how-to-define-a-tree-like-dag-in-haskell>
13:44:36 <hpaste> immanuelkant pasted “do notation in monads” at http://hpaste.org/87356
13:44:57 <Bor0> hi. is this correct: (λab.a)(λcd.d) = λbcd.d
13:45:32 <immanuelkant> why does Nothing in the do block makes foo Nothing
13:45:45 <immanuelkant> explain intuitively
13:45:50 <hpc> Bor0: the first step of reduction is λb. (λcd. d)
13:45:52 <geekosaur> @src Maybe (>>=)
13:45:53 <lambdabot> (Just x) >>= k      = k x
13:45:53 <lambdabot> Nothing  >>= _      = Nothing
13:45:59 <hpc> Bor0: so yes
13:46:12 <geekosaur> (I have no idea what you're getting at by "intuitively")
13:46:31 <hpc> (somehow it looked wrong to me until i started actually typing up what i thought it was supposed to be)
13:46:45 <_just> immanuelkant: Maybe computes things with possible failure, so if you "sequence this computations it should be obvious that if one fails, the whole computation fails
13:46:56 <pxqr> we want to serialize a few (say 5) strict bytestrings or just a lazy bytestring consisting of 5 chunk. what should be faster, cereal or binary?
13:46:56 <geekosaur> anyway, do blocks are just applications of (>>=) (or its variant (>>)), and in Maybe (>>=) always short-circuits if handed a Nothing
13:46:57 <Bor0> this online calculator spits out just "a" as a result, http://ozark.hendrix.edu/~burch/lambda/index.html but I guess that's wrong. the input is: (\ab.a)(\cd.d)
13:47:06 <immanuelkant> convert the do block into chain notation
13:47:15 <geekosaur> as indicated by the second equation for (>>=) in Maybe
13:47:16 <immanuelkant> with >>=
13:47:21 <_just> @undo
13:47:22 <lambdabot> ()
13:47:38 <geekosaur> @undo do { x <- Just 3; Nothing; y <- Just "!"; Just (show x ++ y) }
13:47:39 <lambdabot> Just 3 >>= \ x -> Nothing >> Just "!" >>= \ y -> Just (show x ++ y)
13:47:56 <immanuelkant> whoa
13:49:10 <edwardk> pxqr: binary will avoid copying over and over.
13:49:44 <pxqr> edwardk: this is that i want
13:51:02 <tromp> Bor0: try (\a.\b.a) (\c.\d.d)
13:51:08 <immanuelkant_> have a really flaky connection, kept getting disconnected..
13:51:20 <immanuelkant_> how do i use undo in ghci
13:52:08 <immanuelkant_> @undo do {x <- Just 3  ; Nothing ;  y <- Just "!"  ; Just (show x ++ y)}
13:52:09 <lambdabot> Just 3 >>= \ x -> Nothing >> Just "!" >>= \ y -> Just (show x ++ y)
13:52:12 <hpc> immanuelkant_: ctrl-z, but don't save or it clears your history
13:52:16 <hpc> immanuelkant_: no wait, that's excel :P
13:52:19 <_just> immanuelkant_: use lambdabot in a query
13:52:29 <hpc> immanuelkant_: there's a lambdabot plugin of some kind
13:52:41 <geekosaur> it's not normally availale in ghci. you can use lambdabot online (in /query to get a private dialog) or there's goa if it still builds
13:53:35 <immanuelkant_> where else can i get lambdabot, i want to play with her.. but i dont want you people to see
13:53:54 <geekosaur> immanuelkant_, do you know about /query in irc?
13:54:02 <immanuelkant_> no..
13:54:10 <geekosaur> type '/query lambdabot' to get a private dialog with the bot
13:54:16 <immanuelkant_> oh okay
13:54:43 <geekosaur> you can also try to build lambdabot locally but that has tended to be somewhat painful
13:54:57 <immanuelkant_> is there some documentation of lambdabot, so i can see what commands i have?
13:55:10 <immanuelkant_> this is fine..
13:55:12 <Clint> @help
13:55:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:55:22 <Bor0> is this correct: (λbabb.b) = λb.b ?
13:55:29 <Bor0> λba.b rather
13:55:32 <andrewsw> donri: good point, thanks
13:55:48 <dmwit> Bor0: No, you cannot throw away unreferenced arguments.
13:55:52 <dmwit> In most calculi.
13:56:14 <Bor0> I'm having troubles evaluating True OR False. namely, (λab.a) (λpq.ppq) (λab.b)
13:56:46 <sellout-> Bor0: The OR doesn’t go in the middle.
13:56:58 <sellout-> It is the function that you apply both True and False to.
13:57:14 <dmwit> um
13:57:22 <dmwit> It is the function that you apply to both True and False.
13:57:36 <sellout-> Yes, sorry.
13:57:36 <Bor0> how can I apply true and false to it?
13:57:51 <fxr> what is the difference between TCache and acid-state? anyone?
13:57:55 <_just> OR True False
13:57:59 <hpc> Bor0: (or true false)
13:58:33 <dmwit> Bor0: You should think about this trem instead: (\pq. ppq) (\ab. a) (\ab. b)
13:58:36 <Bor0> I first try to beta-reduce (λab.a) (λab.b) and then apply this to the OR function?
13:58:39 <dmwit> term
13:59:47 <dmwit> (\pq. ppq) (\ab. a) (\ab. b) -> (\ab. a) (\ab. a) (\ab. b) -> (\ab. a)
13:59:55 <dmwit> yay, true or false equals true!
14:01:27 <Bor0> can you simplify  (\ab. a) (\ab. b) ? I get (\b.(\ab.b)) = \bab.b
14:01:48 <dmwit> Application associates to the left.
14:02:08 <FireFly> It's promising to @pl it :p
14:02:14 <FireFly> er, tempting*
14:02:24 <FireFly> What the heck, brain <.<
14:02:26 <dmwit> However, if that were not true, the reduction you gave looks fine to me, though it's common to alpha-vary things a bit to reduce confusion.
14:03:08 <Bor0> so first evaluate (\ab. a) (\ab. a) = something and then something (\ab.b) ?
14:03:15 <dmwit> No.
14:03:20 <dmwit> wait, yes
14:03:21 <dmwit> =P
14:03:46 <Bor0> (\ab.a)(\ab.a) = \bab.a ?
14:04:06 <tromp> yes
14:04:24 <Bor0> okay, now I don't get how (\bab.a)(\ab.b) equals \ab.a
14:04:24 <dmwit> Yes, but again, I warn you that you should alpha-vary more things or you will confuse yourself eventually.
14:04:40 <dmwit> (\ab. a) (\ab . a) = (\ab. a) (\cd. c) = (\bcd. c)
14:05:03 <Bor0> okay
14:05:50 <dmwit> Now, to reduce (\bcd. c) (\ab. a), we look for all the occurrences of "b" in "c" and replace them with "(\ab. a)". There are no occurrences, so we get "\cd. c".
14:05:57 <Bor0> okay, I see it. right, thanks
14:07:13 <silasm> hum, so I have a Data.Text.Lazy.Text string and am trying to write it to a file with Data.Text.Lazy.IO.hPutStr. But that's complaining that it's not of type Data.Text.Internal.Text. Any way to fix this?
14:07:55 <dmwit> ?hpaste some minimal code and the error you get
14:07:55 <lambdabot> Haskell pastebin: http://hpaste.org/
14:08:19 <rck> silasm: you're using lazy and it wants strict I think
14:09:12 <dmwit> But yes, it sounds to me like you are not trying to write it to a file with Data.Text.Lazy.IO.hPutStr after all.
14:09:52 <hpaste> silasm pasted “Text vs. Text” at http://hpaste.org/87359
14:10:48 <dmwit> silasm: ccat takes and returns strict Text
14:11:14 <dmwit> So your claim that you have a Data.Text.Lazy.Text is faulty.
14:11:28 <silasm> dmwit: T is Data.Text.Lazy...
14:11:37 <dmwit> I.
14:11:37 <dmwit> But.
14:12:02 <silasm> is it the foldl or something?
14:13:15 <dmwit> Okay, what is the type of readStr?
14:13:29 <dmwit> And what is LZ78Text?
14:13:42 <silasm> ah, derp.
14:14:07 <silasm> I had imported Data.Text instead of Data.Text.Lazy in LZ78Text.hs
14:14:12 <silasm> thanks for the help
14:14:49 <fxr> any TCachers?
14:16:44 <rck> relatively new to working with a language that incorporates a repl. anyone mind detailing their usual dev workflow? I use dwm and terminal vim
14:17:07 <Fuuzetsu> Step 1: Switch to emacs
14:17:10 <Fuuzetsu> ~
14:17:15 <rck> pffffffttt
14:17:23 <fxr> Step 2: use haskell-mode
14:17:24 <ATuin> :)
14:17:41 <Fuuzetsu> We even get the GHCi inferior process!
14:18:08 <rck> I have GHCi set to use vi bindings thank you very much
14:18:11 <Fuuzetsu> Out of curiosity what kind of utilities are there available for vim in regards to Haskell development?
14:18:23 <ATuin> what does $(expr)?
14:18:43 <Fuuzetsu> rck: You can use vi(m?) bindings in emacs~
14:18:46 <tgeeky> everything that emacs can do re:haskell, vim can do
14:19:10 <Fuuzetsu> tgeeky: Is there something cool it can do that emacs can't?
14:19:19 <tgeeky> Fuuzetsu: nope
14:19:22 <Fuuzetsu> (and by can't, I just mean that no one has implemented it)
14:19:41 <rck> haha guys, I'm happy with my choice of editor. I want workflows for using the repl to help development
14:19:45 <tgeeky> they are equally good and equally bad
14:19:54 <tgeeky> rck: ghc-mod and/or haskell-mode
14:20:13 <tgeeky> rck: look on github for people's vim/haskell dev environments
14:20:21 <Fuuzetsu> tgeeky: b-but how will we have our holy editor wars if we just agree that they do the same thing?
14:20:51 <rck> tgeeky: I mean, how do you guys use it? say I have an editor open with a .hs file. when would I want to use the repl? right now I mostly use it to discover types of things I'm unsure about
14:20:58 <tgeeky> Fuuzetsu: go to your local Catholic church confession booth and have it out
14:21:13 <monochrom> I don't use the repl intensively. I use it, sure, to see error messages and test trivial things (more like sanity checks)
14:21:15 <hpc> screen, vim, ghci
14:21:20 <hpc> C-| for vertical split
14:21:32 <hpc> er, C-a |
14:22:20 <joaopizani> Fuuzetsu: I use a workflow that took me years to develop, it's on github:  https://github.com/joaopizani/modular-hs-vim-ide
14:22:54 <joaopizani> Fuuzetsu: in this repo there are general vim modifications, if you only want to see what I use for Haskell, look at this submodule: https://github.com/joaopizani/haskell-vim-cfgs
14:22:55 <Fuuzetsu> Probably want to reply to rck, joaopizani.
14:23:01 <joaopizani> ow right
14:23:13 <rck> I'm checking it out now, joaopizani
14:23:15 <joaopizani> rck: look at what I sent to Fuuzetsu  :)
14:23:26 <joaopizani> Fuuzetsu: sorry for the SPAM :P
14:24:00 <joaopizani> rck: I basically use ghc-mod with some other goodies, like fancy unicode, folding, module name insertion
14:24:23 <rck> joaopizani: when/how do you use the repl?
14:24:31 <rck> ghci
14:24:56 <joaopizani> rck: I usually run screen alongisde, and then ghci inside of it
14:25:09 <joaopizani> it's not so fancy as emacs, but I can copy and paste code into GHCi
14:25:10 <meowtoo> @help
14:25:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:25:21 <meowtoo> @list
14:25:22 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:25:24 <joaopizani> rck: and also ghc-mod can print the type of expressions
14:25:26 <Fuuzetsu> If anyone wants to post their emacs environment and workflow, that'd be pretty cool.
14:25:49 <Fuuzetsu> My setup for Haskell is incredibly basic so I could probably learn a thing or two.
14:25:52 <joaopizani> rck: so, if I want to know the type of an expression, I just hit <Leader>t
14:26:04 <rck> joaopizani: ahh now that sounds handy
14:26:39 <joaopizani> rck: with <Leader>T you can insert the type of a (top-level) expr as a type signature
14:26:57 <Fuuzetsu> What's a <Leader> key?
14:27:02 <Fuuzetsu> ‘:’?
14:27:23 <rck> Fuuzetsu: mapped to \ by default. it's a global modifier that extensions use to configure custom commands in normal mode.
14:27:55 <Fuuzetsu> Right. What if you have more than one extension active? Do you get clashes?
14:29:11 <rck> assuming they bind to the same key, yes. rarely an issue. most extensions encourage keybinding to whatever the user wants, or provides a set of functions bound to combos that are pretty unlikely to conflict
14:29:46 <joaopizani> Fuuzetsu: usually the plugins provide named commands, that the user then binds to whatever he/she wants
14:29:51 <rck> ^
14:30:00 <augustss> howdy
14:30:25 <joaopizani> Fuuzetsu: and by using the <Leader> as prefix, the user has a orthogonal "namespace" for bindings
14:49:40 <NihilistDandy> rck: Can I assume let mapleader=',' on your part? I don't know anyone that uses \ in the wild :D
14:50:10 <rck> NihilistDandy: I use that to search backwards in the line!
14:50:10 <NihilistDandy> rck: Also, I'd be interested to see your vimrc
14:50:29 <NihilistDandy> What, comma or \?
14:50:35 <rck> comma
14:50:56 <NihilistDandy> Interesting
14:51:17 <NihilistDandy> Do you keep your vimrc somewhere accesible?
14:51:17 <rck> well that's the default binding
14:51:20 <rck> opposite of ;
14:52:02 <NihilistDandy> Ah, I suppose that's true. I map ; to :, anyway
14:52:35 <rck> one sec, let me figure out this hpaste thing
14:54:03 <hpaste> rck pasted “vimrc” at http://hpaste.org/87364
14:54:14 <rck> NihilistDandy: there ^
14:55:24 <rck> I use ctrlp, snipmate, supertab, tcomment, tagbar
14:56:04 <NihilistDandy> rck: https://github.com/jhenahan/vimrc
14:56:45 <rck> ascii is a nice touch
14:57:00 <NihilistDandy> hehe
14:57:24 <monochrom> you ascii artists
14:57:27 <rck> do you actively use folds?
14:57:31 <monochrom> but haha nice
14:57:59 <NihilistDandy> Yeah, I like folds. They're great for skimming Haskell files, especially
14:58:08 <NihilistDandy> Just following the types
14:59:17 <rck> one of the best things I've found is :set relativenumber
14:59:29 <rck> vertical motions are much easier
14:59:36 <NihilistDandy> I should probably split powerline into its own section, now, though. I'm using the python-heavy version and I can't reliably get that on any arbitrary machine.
14:59:45 <NihilistDandy> Yeah, relative line numbers are awesome
15:00:07 <rck> yeah I like powerline but it spews bad characters in terminal vim occasionally so I tossed it
15:00:16 <rck> works great in gvim
15:01:01 <NihilistDandy> I've been using it for zsh and tmux, lately, and it's been pretty good. Once it's stable I'm sure it will be better
15:01:31 <hpaste> orzo pasted “lazySequence” at http://hpaste.org/87366
15:02:18 <orzo> My question is in the paste, it involves a problem that seems like a job for type classes, but for which a specific solution eludes me as yet
15:02:31 <orzo> it's a 12 line paste
15:02:41 <NihilistDandy> rck: Also, if you don't know about numbers.vim, it'll make relative numbering even better
15:02:43 <NihilistDandy> https://github.com/myusuf3/numbers.vim
15:04:24 <rck> NihilistDandy: I haven't seen that. will check it out
15:05:12 <orzo> It seems like I ought to be able to write a general lazySequence function for any number of elements in my list.  But if I try, the compiler will complain of an infinite type, and there's no clear way to use a type class to resolve it
15:06:17 <orzo> Maybe existential qualification is neccessary?
15:07:01 <NihilistDandy> orzo: I don't know that I follow what it's meant to do
15:08:40 <NihilistDandy> orzo: What are the definitions of HCons and HNil?
15:09:37 <orzo> Oh, those are imported from Data.HList, HNil is a single value type, and HCons is an algebriac type with two arguments, isomorphic to a pair
15:10:17 <cmccann> yes, you need type classes to do that generically
15:11:09 <orzo> cmccann: okay, but do you see a way?
15:11:58 * hackagebot pipes-concurrency 1.1.0 - Concurrency for the pipes ecosystem  http://hackage.haskell.org/package/pipes-concurrency-1.1.0 (GabrielGonzalez)
15:12:07 <cmccann> I would expect there to be something similar in HList already, actually.
15:12:19 <arkeet> oh wow, thanks for numbers.vim
15:12:25 <arkeet> someday I should go looking around for cool vim plugins.
15:12:28 <orzo> i doubt that, but if you find one, i'd be greatful
15:12:41 <NihilistDandy> arkeet: I have all sorts of recommendations. :D
15:12:56 <arkeet> shall we go to -blah?
15:13:37 <cmccann> orzo: see http://hackage.haskell.org/packages/archive/HList/0.2.3/doc/html/Data-HList-HListPrelude.html#t:HMapOut
15:14:06 <orzo> i dont see how that applies
15:14:19 <cmccann> oh, I misread your paste I think
15:16:33 <cmccann> orzo: are you trying to avoid the length of the output list being statically known?
15:16:39 <cmccann> because that complicates things immensely
15:17:22 <orzo> yes, i do wnat to avoid that
15:17:37 <orzo> and i intend to use this with MonadPlus, not simply Functor
15:17:59 <orzo> i have an uncons function written already that compiles and such, that uses mzero on list termination
15:18:14 <orzo> should i paste it?
15:18:24 <cmccann> if you want the result type to depend on the length of the input list it's going to be a gigantic pain in the ass to use
15:18:43 <cmccann> because you'll need to muck around with existential types and other awkwardness
15:18:53 <orzo> i was thinking that
15:18:58 <orzo> existential
15:19:12 <cmccann> I doubt it's worth it
15:20:03 <orzo> its an experiment, i have code that uses sequence, but sequence forces a lot of monadic structure to be computed before you can even operate on the heads of the lists
15:20:19 <orzo> and its irrelevent structure that makes the operation less efficient
15:20:43 <orzo> so i want to experiement with this lazySequence idea
15:20:51 <cmccann> orzo: also, if your lists are going to stay homogeneous using HList is probably complicating things unnecessarily
15:20:54 <orzo> its probably worth the experiemnt at least
15:21:15 <mike4_> hey functionalists.
15:21:31 <orzo> im using hlist for not much reason, i could have used (,)
15:21:31 <cmccann> you can cut out some headaches if you use something that still encodes the length but has homogeneous element types
15:21:48 <orzo> i use hlist in other parts of the program though, so i figured why not
15:21:52 <NihilistDandy> mike4_: Hi
15:22:12 <orzo> my element types are not homogenous
15:22:16 <orzo> as you can see
15:22:24 <orzo> they might become homogenous with an existential type, i dont know
15:23:00 <orzo> every element has one more layer of monad
15:23:24 <orzo> or Functor i should say i guess
15:23:25 <mike4_> hi dandy.
15:23:51 <cmccann> but the first argument to HCons (the type) is always the same, right?
15:24:16 <cmccann> and the Functor is consistent as well
15:25:53 <orzo> ya i guess
15:26:35 <cmccann> anyway, I'm pretty sure that however you go about it will be a pain to work with and probably not worth the hassle
15:29:22 <orzo> do you even understand the motivation for it in the first place?
15:30:33 <cmccann> I'm not sure what you're using this for, no
15:30:52 <cmccann> I've just spent enough time mucking with this kind of fancy type stuff to be aware of how annoying it can get :P
15:31:03 <orzo> so've i
15:33:17 <cmccann> you seem to be building some sort of HList-y version of the alternate ListT
15:33:22 <cmccann> sort of free monad-ish
15:33:33 <yogert> hey, how could I turn a [Maybe Int] into a Maybe [Int]? I've been trying to use some of the functions in Control.Applicative, and haven't come up with a good way
15:33:40 <cmccann> but I dunno what the purpose is
15:34:02 <cmccann> yogert: do you want to keep all the Just values? Or get the whole list if everything is Just?
15:34:20 <hpc> there are many functions of type [Maybe Int] -> Maybe [Int]
15:34:35 <yogert> cmccann:  you mean drop any Nothings?
15:34:37 <hpc> if you don't know which one you want, might i suggest const Nothing? :P
15:34:50 <cmccann> yogert: you probably want either sequence or catMaybes
15:35:02 <cmccann> your type suggests sequence
15:35:18 <yogert> sorry I shouldn't have said [Maybe Int]. [Maybe a] is more exact
15:35:21 <yogert> okay
15:35:24 <Watabou> quick question about the replicate example in this chapter: http://learnyouahaskell.com/recursion
15:35:26 <cmccann> :t sequence
15:35:29 <lambdabot> Monad m => [m a] -> m [a]
15:35:39 <Watabou> the type class constraints for that is Num i and Ord i
15:35:47 <Watabou> Any reason why it's not just Num?
15:35:55 <Watabou> I'm a little unclear on that
15:36:33 <Watabou> I mean I think the problem would be pretty much the same if it was just Num i, no?
15:36:51 <luite> Watabou: the <= requires Ord
15:37:08 <yogert> cmccann: ah okay. that worked. Hmm while I'm starting to get a hang of a lot of haskell, its things like this that make me question what I actually understand. I think I'm in a phase where I know what works, but couldn't tell you with any certainty why it works
15:37:10 <Watabou> ah okay
15:37:13 <Watabou> thanks luite
15:38:06 <DanBurton> and the typical example of why Num is insufficient for <= is imaginary numbers. 2i <= 3 ?
15:38:10 <luite> Watabou: instances of Num arent always ordered, for complex numbers there's no standard ordering
15:38:39 <cmccann> yogert: most people end up reinventing quite a few standard library functions while learning because they want to do something but don't know how to find it and/or that it exists at all
15:39:17 <Watabou> luite: Oh hmm, what is the complex number called in Haskell? I don't see that in :i Ord
15:39:34 <luite> Watabou: Complex a
15:40:19 <Watabou> hmm don't see that in :i Ord, is that a subclass of another type?
15:40:38 <luite> Watabou: it's not an instance of Ord
15:41:00 <arkeet> you'd have to import Data.Complex to see it anyway
15:41:08 <Watabou> :i Complex doesn't seem to work
15:41:19 <luite> ah right, import Data.Complex
15:41:28 <Watabou> oh okay
15:41:44 <Watabou> thanks
15:42:23 <luite> Watabou: since there's no 'best' instance (none would satisfy the ordered field laws) there is none defined in the standard libs
15:43:11 <Watabou> hmm okay
15:43:44 <luite> Watabou: makes it a bit annoying if you want to store them in a Set or similar though
15:43:48 <luite> since you need Ord for that
15:44:02 <luite> and orphan instances (defining the instance somewhere else) are icky
15:44:27 <NihilistDandy> In particular: http://www.proofwiki.org/wiki/Complex_Numbers_Cannot_be_Totally_Ordered
15:44:41 <Watabou> okay so (Num i, Ord i) says that i has to be an instance of Num AND Ord, correct?
15:44:47 <NihilistDandy> Correct
15:44:56 <Watabou> okay, cool, thanks
15:45:41 <luite> Watabou: yep. sometimes you can leave one out, for example (Integral a, Num a) can be simplified to Integral a, since Num a is a superclass, so it's already implied
15:46:19 <luite> NihilistDandy: hm that title is a tad misleading :)
15:46:56 <NihilistDandy> Is it?
15:47:18 <arkeet> I hate proofwiki.
15:47:23 <cmccann> you can assign them a bogus total order.
15:47:26 <luite> NihilistDandy: well you can easily make total orders, and implement Ord instances for them, they just wouldn't make it an ordered field
15:47:30 <cmccann> it just won't play nice with arithmetic.
15:47:47 <Watabou> ah Complex shows up in Num when I import it
15:48:01 <NihilistDandy> Well, that's true, but you can do all sorts of nonsensical things in math
15:48:06 <NihilistDandy> That doesn't mean they're useful :
15:48:07 <Watabou> so that's why the Ord i is needed, I see
15:48:07 <NihilistDandy> *:D
15:48:51 <luite> NihilistDandy: they'd certainly be useful in Haskell though, since you need it for a Set of Complex a
15:49:26 <cmccann> the problem is that Haskell uses Ord for both sensible total orders, bogus total orders only useful for e.g. Set, and buggy non-orderings like Float
15:50:26 <NihilistDandy> True
15:50:38 <NihilistDandy> Maybe a TOrd class is in order :)
15:51:29 <cmccann> > compare (0/0) (0/0)
15:51:30 <lambdabot>   GT
15:51:33 <cmccann> I rest my case
15:51:59 * hackagebot network-bitcoin 1.2.0 - An interface to bitcoind.  http://hackage.haskell.org/package/network-bitcoin-1.2.0 (ClarkGaebel)
15:52:16 <arkeet> > (0/0) > (0/0)
15:52:19 <lambdabot>   False
15:52:25 <cmccann> arkeet: :D
15:52:39 <cmccann> arkeet: ain't it great?
15:52:48 <arkeet> it's terrible
15:53:07 <NihilistDandy> Though with the axiom of choice I'd think that you could enforce a well-ordering on a Set, I'd think, regardless of where the set is drawn from
15:53:09 <DanBurton> I think I just died a little
15:53:21 <NihilistDandy> Whether it would be useful is another matter
15:53:38 <NihilistDandy> Also, battery dying. Back later.
15:55:00 <cmccann> > (1/0 == 1/(-0), 0 == (-0)) -- also fun
15:55:02 <lambdabot>   (False,True)
15:56:08 <atamagawarui> > 1/0
15:56:11 <lambdabot>   Infinity
15:56:32 <cmccann> plus there's the whole thing where inserting NaN into a (Set Float) breaks the invariants and makes other elements of the Set inaccessible
15:56:48 <DanBurton> > 1 / (-0)
15:56:50 <lambdabot>   -Infinity
15:56:56 <cmccann> so you can insert something and suddenly other elements vanish (or appear to)
15:57:24 <atamagawarui> Floating-points were never Ord-friendly, right?
15:57:39 <Bor0> using lambda calculus can we simply define natural numbers as λx.x = 1, λx.xx = 2, and so on? my question is, is the second argument there just to be able to define zero? i.e. λfx.f = 0
15:58:03 <otters> you can make set elements vanish? ooooh
15:58:24 <Bor0> correction: λfx.x = 0
15:58:42 <cmccann> otters: see my example here: http://stackoverflow.com/a/6399798/157360
15:59:01 <cmccann> which is based on an example from dafis
16:00:54 <tromp> that doesn't look like a very useful definition of numbers
16:01:08 <cmccann> tromp: what, Float? :D
16:01:19 <tromp> no, what Bor0 proposed
16:01:25 <Bor0> hm, can you please elaborate?
16:01:27 <cmccann> yeah, I figured
16:01:32 <cmccann> but I'm picking on floats right now
16:01:52 <tromp> how would you test if your number is zero or not?
16:02:10 <Bor0> excluding zero, positive natural numbers. is that definition good enough?
16:02:34 <cmccann> Bor0: I don't think you can implement multiplication that way. at least, not easily.
16:02:53 <tromp> a number representation is only as good as the ease with which you can do arithmetic with them
16:02:56 <Bor0> I am just trying to understand why the second argument is there
16:03:09 <cmccann> maybe it would, I'm not sure. either way, the standard encoding is much more convenient.
16:03:15 <Bor0> so I assume it allows an easy definition of zero and easy way of implementing operations?
16:03:29 <cmccann> it's also a very conceptually simple encoding
16:03:32 <arkeet> Bor0: 0 f = id, 1 f = f, 2 f = f . f, etc.
16:03:39 <cmccann> the number N = apply a function N times
16:03:45 <tromp> church numerals make addition, multiplicatoin, exponentiation very easy
16:04:02 <arkeet> (m + n) f = m f . n f
16:04:05 <arkeet> (m * n) f = m (n f)
16:04:06 <arkeet> etc.
16:04:41 <tromp> only decrement is a little harder
16:05:01 <cmccann> I'm not sure decrement is possible with Bor0's encoding at all
16:05:46 <arkeet> (m ^ n) f = n m f
16:05:46 <cmccann> then again it's not obvious that it's possible with the standard encoding either
16:06:40 <arkeet> so, m * n = m . n, heh
16:08:42 <Fuuzetsu> @pl (m `g` n) f = m f . n f
16:08:42 <lambdabot> (line 1, column 14):
16:08:42 <lambdabot> unexpected " "
16:08:42 <lambdabot> expecting operator
16:08:49 <Fuuzetsu> Hmm, didn't think so.
16:08:56 <cmccann> write it as a lambda
16:09:14 <cmccann> or maybe a let expression, dunno
16:09:18 <cmccann> pl is kinda picky
16:09:21 <atamagawarui> @pl \m n f -> m f . n f
16:09:22 <lambdabot> liftM2 (.)
16:09:27 <cmccann> heh
16:09:34 <Fuuzetsu> gets me every time
16:09:57 <acowley> Has anyone played with bos's crit-bit trees yet?
16:10:57 <cmccann> acowley: what's their gimmick?
16:11:20 <cmccann> that's basically what IntSet and IntMap are, if memory serves me
16:11:31 <acowley> Nothing: I think this sets the context quite well: http://cr.yp.to/critbit.html
16:12:16 <acowley> They are related to IntSet and IntMap, but bos was on here last week (I think) saying he was getting a nice speedup.
16:12:17 <_just> http://www.imdb.com/title/tt2053463/ is this a haskell movie? *scnr
16:12:38 <bos> cmccann: they're more akin to Data.Map with the key being bytestring or text
16:13:28 <acowley> bos: Is it worth trying them out yet?
16:13:31 <lightquake> > foldl f z [a,b,c]
16:13:33 <lambdabot>   f (f (f z a) b) c
16:14:13 <bos> cmccann: generally faster than Data.Map, ranging from faster to slower than Data.HashMap depending on the operation, but retaining keys in order and allowing some kinds of interesting operations that neither of the others support
16:14:34 <bos> acowley: depends on what you want to do, i suppose
16:14:40 <cmccann> I mean, they're a kind of trie, right?
16:14:40 <arkeet> @pl g m n f = m f . n f
16:14:40 <lambdabot> g = liftM2 (.)
16:14:45 <acowley> I want to hash a few million Int triples
16:15:00 <acowley> de-dup the collection into a set
16:15:12 <bos> acowley: they're not a good fit for that
16:15:29 <acowley> Ah, I'm glad I asked before trying!
16:15:32 <DanBurton> > foldr cons nil [a, b, c]
16:15:35 <lambdabot>   Not in scope: `nil'
16:15:41 <DanBurton> doh
16:16:10 <DanBurton> lambdabot why u no read my mind and magically create Exprs
16:16:28 <Fuuzetsu> lambdabot confirmed for horrible
16:16:57 <Fuuzetsu> We now wait for edwardk to provide a lens that can read minds
16:17:14 <arkeet> @let cons = SimpleReflect.fun "cons"; nil = SimpleReflect.var "nil"
16:17:16 <lambdabot>  <local>:5:8: Not in scope: `SimpleReflect.fun'
16:17:16 <lambdabot>  
16:17:16 <lambdabot>  <local>:5:40: Not in scope...
16:17:24 <arkeet> uh
16:17:26 <arkeet> > fun
16:17:30 <lambdabot>   Ambiguous type variable `a0' in the constraint:
16:17:30 <lambdabot>    (Debug.SimpleReflect.Exp...
16:17:32 <Fuuzetsu> no fun allowed
16:17:35 <cmccann> lambdabot is no fun, clearly.
16:17:42 <nimish> bos : what are some good use cases of critbit trees over ye olde hashmaps?
16:17:48 <arkeet> @let cons = Debug.SimpleReflect.fun "cons"; nil = Debug.SimpleReflect.var "nil"
16:17:49 <lambdabot>  <local>:5:46:
16:17:49 <lambdabot>      Not in scope: `Debug.SimpleReflect.var'
16:17:49 <lambdabot>      Perhaps you ...
16:17:52 <arkeet> =(
16:18:14 <Fuuzetsu> :i SimpleReflect
16:18:21 <Fuuzetsu> Oh, no :i
16:18:36 <atamagawarui> @hoogle SimpleReflect
16:18:37 <lambdabot> No results found
16:18:39 <bos> nimish: they're almost as fast as hashmaps, but they maintain the keys sorted
16:19:04 <arkeet> :t var "blah"
16:19:04 <Fuuzetsu> Hayoo still down…
16:19:06 <lambdabot> Sym a
16:19:38 <bos> acowley: a trie-like structure only works well for a type that can be efficiently decomposed into a sequence of fixed-size parts
16:19:59 <bos> so an Int can be turned into bytes, a bytestring into bytes, but (Int,Int,Int)? not so much
16:20:14 <acowley> bos: I figured I had a bunch of length 3 paths
16:20:54 <bos> not without a bunch of boilerplate you don't
16:22:00 * hackagebot heredoc 0.2.0.0 - multi-line string / here document using QuasiQuotes  http://hackage.haskell.org/package/heredoc-0.2.0.0 (JamesFisher)
16:24:23 <cmccann> bos: you could do something along the lines of unboxed vectors maybe, with the data family and whatnot
16:24:27 <cmccann> but that'd be a lot of work
16:24:45 <bos> cmccann: yes, hence my comment about "a bunch of boilerplate" :-)
16:25:10 <cmccann> yep
16:25:51 <bos> i would like to see if i can inline the keys into the leaves of the tree, but that too seems like a lot of work
16:26:32 <acowley> If it helps, I'm pulling these from a storable vector already, so I have the bytes just sitting there. I guess I'll try a few things to see what works best.
16:26:59 <TotallyWorthIt> @type (***)
16:27:00 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
16:27:28 <bos> acowley: the library is not far along yet, but it has test and benchmark suites. have at it, by all means.
16:30:16 <hpaste> orzo annotated “lazySequence” with “lazySequence (annotation)” at http://hpaste.org/87366#a87373
16:30:46 <orzo> cmccann: checkout my solution, i managed it without type classes and without existentials
16:31:12 <acowley> Well, it's not obvious to me why my case of 24 byte strings doesn't fit the trie data structure, so I'll read up a bit on the options.
16:31:57 <cmccann> orzo: yeah, that's why I said that using HList was complicating things
16:32:52 <orzo> hlist wasnt complicating it, i knew i was basically using a tuple, I had the solution with HCons first, and just decided to nix it
16:33:51 <orzo> but the HCons version copiled and worked just as well
16:34:31 <cmccann> yes, because a homogeneous type makes it much easier
16:35:25 <orzo> what was neccessary was the NestedList algebraic type.
16:35:51 <orzo> without it, you have an infinite type situation
16:36:47 <cmccann> yes
16:36:52 <cmccann> I'm not sure why you didn't just do that in the first place
16:37:00 <cmccann> or use one of the many variations on that type already on hackage...
16:37:14 <rhyce> How, in general, can one use a Monad from inside of another Monad? For example, I can't seem to get this to work... http://hpaste.org/87375
16:37:38 <rhyce> Essentially, I need access to the thawed vector INSIDE of the spawned computations
16:38:05 <rhyce> Line 7 is where the trouble starts
16:38:58 <rhyce> I am able to use them seperatly, but I cannot combine their effects
16:40:07 <c_wraith> in general, the answer to that is "monad transformers", but that doesn't apply there
16:40:33 <rhyce> ah, I've been poking around transformers so that's good to hear
16:40:48 <rhyce> any hints?
16:41:02 <c_wraith> Mostly because the whole point of the monad Par is to come up with pure results
16:41:14 <hpc> the first thing to remember about transformers is that they are robots in disguise
16:41:15 <c_wraith> but unsafeThaw is IO
16:41:24 <cmccann> hpc: an excellent point
16:41:45 <hpc> i am waiting for edwardk to write a comonad decepticon package
16:41:50 <cmccann> :D
16:42:02 * hackagebot crypto-api 0.12.1 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.12.1 (ThomasDuBuisson)
16:42:15 <rhyce> c_wraith: Ah... but even thaw has the same problem I think
16:42:33 <rhyce> they are both m (MVector (PrimState m) a)
16:42:37 <cmccann> hpc: you should upload a package like that which just re-exports his comonad transformers
16:42:37 <c_wraith> rhyce: well, yes
16:42:44 <rhyce> I need mutable vectors! ;)
16:42:44 <cmccann> that seems like an entirely reasonable thing to do.
16:42:44 <BMeph> hpc: Maybe...he - already - HAS!! (cue dramatic music) =8*O
16:43:06 <hpc> cmccann: wouldn't be the first re-export package i have made
16:43:12 <hpc> about comonads, even
16:43:16 <cmccann> was Ntrol.Monad yours?
16:43:18 <hpc> yep
16:43:22 <cmccann> nice
16:43:59 <hpc> i must do this... later
16:43:59 <cmccann> I guess comonad-decepticons could depend on that package then
16:44:21 <c_wraith> rhyce: I have to say, I'm bothered by that code. It looks like it's trying to do lots of mutation in parallel, but pretend it isn't
16:44:23 <cmccann> or whatever you call the package
16:44:38 <hpc> cmccann: it'd be just decepticons
16:44:42 <c_wraith> rhyce: that's a recipe for problems
16:44:42 <hpc> after transformers
16:44:45 <cmccann> ah, true
16:44:55 <hpc> it'd be deprecated in favor of cdl
16:45:00 <cmccann> of course
16:45:10 <rhyce> c_wraith: perhaps, but without the mutable vectors it's just too slow
16:45:50 <rhyce> c_wraith: perhaps it would help to look at a "working" version of the program that I am trying to fix
16:46:17 <c_wraith> rhyce: I didn't say not to use mutable vectors - just that you can't mix updating them with Par in a way that doesn't cause problems
16:46:21 * cmccann wonders if a parallelized version of ST is possible.
16:46:29 <c_wraith> I was just wondering that.
16:46:48 <cmccann> it sounds like Par + ST is roughly the goal here
16:46:52 <c_wraith> yeah
16:46:52 <cmccann> but that doesn't exist
16:46:53 <c_wraith> it is
16:46:56 <cmccann> and I dunno if it can
16:47:04 <cmccann> but it isn't obviously impossible...?
16:47:05 <cmccann> hm.
16:47:28 <rhyce> cmccann: yes, that's it
16:47:32 <acowley> You can unsafeSTtoIO, go nuts, then come back to ST
16:47:49 <c_wraith> acowley: at that point, you might as well just use unsafePerformIO
16:48:15 <acowley> c_wraith: This way is slightly more complicated.
16:48:28 <c_wraith> hah
16:50:03 <c_wraith> cmccann: I don't know that you can preserve determinism guarantees mixing Par and ST.  Each of them have that as their guarantee individually, but it seems like mixing them has a serious risk of introducing nondeterminism
16:50:21 <cmccann> c_wraith: yeah, I was about to say. the trick would be to expose the parallel mutability without allowing nondeterminism. somehow.
16:50:37 <cmccann> like I said, not obviously impossible but... tricky
16:50:57 <acowley> My unsafeSTtoIO suggestion would have been better received in #haskell-lens
16:50:58 <cmccann> it would almost certainly have to be its own thing, there's probably no way to mix Par and ST to make it work
16:51:11 <cmccann> acowley: they'd tell you to use unsafeCoerce instead
16:51:17 <rhyce> (putting together example)
16:51:19 <cmccann> IO and ST have the same representation after all
16:51:39 <acowley> Fits like a glove
16:52:08 <hpc> http://25.media.tumblr.com/tumblr_lnhfy1ynkO1qgosouo1_250.jpg -- like a glove
16:52:43 <rhyce> c_wraith, cmccann: Ok, here's the working code: http://hpaste.org/87377
16:52:46 <jfischoff> surprised MaybeT doesn't have a Newtype instance
16:52:55 <rhyce> The idea here is that I have parallelism at the top level
16:53:01 <acowley> Just wrote some good code: fmap . fmap . fmap . fmap . V.map . fmap
16:53:05 <jfischoff> I find myself wanted to do ala MaybeT msum a lot
16:53:06 <acowley> That V.map is a jerk
16:53:11 <hpaste> c_wraith pasted “terror 2 - the terrorening” at http://hpaste.org/87378
16:53:24 <acowley> jfischoff: Doesn't lens cover that need?
16:53:29 <rhyce> (Line 62))
16:53:48 <rhyce> c_wraith: terror!
16:54:13 <c_wraith> What I pasted is very very very bad code that should never be used. :)
16:54:15 <jfischoff> acowley: that's write there is ala stuff in lens. Do you know the lensy way?
16:54:22 <jfischoff> s/write/right
16:54:29 <rhyce> c_wraith: This is just crazy optimization stuff
16:54:35 <acowley> au (wrapping …..)
16:54:37 <Nafai> John Carmack is asking for code review for Haskell code: https://twitter.com/ID_AA_Carmack/status/331557216488390656
16:54:40 <acowley> (that was for jfischoff)
16:54:47 <acowley> jfischoff: http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/Control-Lens-Iso.html
16:54:55 <cmccann> Nafai: nice
16:55:01 <rhyce> I'm just trying to write a really good parallel sort algo in Haskell that *scales* well
16:55:19 <acowley> I'm going to suggest he comes here
16:55:38 <rhyce> So far my simplistic mergesort is the best -- but I've gone down this rabbit hole of bitonic sorting
16:55:40 <c_wraith> rhyce: I'm a little scared that you're using unsafeThaw in a case where you can't prove that it's safe locally.
16:55:41 <jfischoff> acowley: yeah that works
16:56:04 <rhyce> c_wraith: bitonic sort gives this as a assumption
16:56:07 <c_wraith> rhyce: it is safe in your case, but you need to look at everything calling it to prove that.
16:57:48 <rhyce> c_wraith: what exactly is happening in that snippet you pasted?
16:58:03 <cmccann> rhyce: terrible things
16:58:07 <rhyce> I can see that
16:58:15 <cmccann> terrible, horrible things
16:58:40 <c_wraith> rhyce: I'm not actually certain this is going to be efficient anyway.. You're allocating all kinds of new vectors during bisort. That really can't be faster than just a single allocation
16:58:49 <rhyce> OK, how about this -- is there a "nice" way to let two sparks sort on the same data at the same time?
16:59:11 <c_wraith> sparks are pure computations, by necessity. They can't perform that mutation at all
17:00:07 <rhyce> perhaps I am using the wrong terminology -- in Java I'd say threads for what I mean in Haskell
17:00:34 <c_wraith> yeah, solving this requires going to concurrency, with current tooling.
17:00:42 <c_wraith> and that means IO and forkIO
17:00:59 <rhyce> I did, however, make an interesting discovery that Arrays in haskell are crazy slow to create
17:01:16 <Philippa> (things I am glad we don't have: Control.Monad.ST.Lazy.forkST)
17:01:35 <c_wraith> Philippa: does lazy even matter for the horrible that would cause?
17:02:11 <acowley> My code that used forkST worked out fine in the end. Empiricism over good taste and reason!
17:02:23 <Philippa> c_wraith: I suspect it at least exacerbates it, yeah
17:02:36 <c_wraith> I mean, all the terrible stuff I did with unsafeInterleaveST in the example above is the same bad stuff that forkST allows
17:03:05 <c_wraith> (further proof that unsafeInterleave* is a form of concurrency)
17:04:33 <cmccann> c_wraith: using unsafeInterleave* definitely resembles the behavior of coroutine-style cooperative multitasking in an impure language
17:04:44 <cmccann> I did some awful hackery along those lines in python a couple times
17:04:50 <hpc> it's a very specific type of concurrency
17:04:54 <hpc> tied to evaluation order
17:05:09 <c_wraith> rhyce: Here are my thoughts - Write it as a non-parallel version in IO that only allocates one result vector (mutable at first, then use unsafeFreeze at the conclusion of the sort). When that's working, look at using forkIO to speed it up with concurrency.
17:05:26 <hpaste> “Anonymous Coward” pasted “Best so far” at http://hpaste.org/87382
17:05:39 <rhyce> Ironically, that paste http://hpaste.org/87382 is my best so far
17:05:43 <rhyce> and it is dead simple
17:05:46 <c_wraith> rhyce: if you get that working, you *might* consider then calling that sort with unsafePerformIO
17:05:56 <c_wraith> rhyce: if you can prove it's actually safe
17:06:58 <rhyce> c_wraith: In theory, it should be safe: http://en.wikipedia.org/wiki/Bitonic_sorter
17:07:16 <rhyce> c_wraith: as long as the length is a perfect power of two
17:07:41 <c_wraith> rhyce: but first things first - you're doing a ton of allocation. It needs to cut that down to the minimum (one allocation of output space, since you're not mutating the input in-place), before you should worry about making it run in parallel
17:08:23 <rhyce> c_wraith: that's a good question -- how can I limit that? I've seen lots of stuff around about keeping a preallocated array around
17:08:38 <cmccann> acowley: I'm not sure if I like that someone suggested carmack look at GHC itself
17:08:49 <acowley> cmccann: Did they really?
17:08:54 <acowley> cmccann: That's terrible
17:09:03 <cmccann> it's got most of the problems that large, well-aged software projects have
17:09:06 <rhyce> c_wraith: in C I'd just keep the same array and use pointers -- but I'm not sure what technique to use in Haskell
17:09:09 <acowley> Yeah
17:09:16 <cmccann> I mean, GHC isn't BAD as far as such things go
17:09:22 <cmccann> but it's also no longer "nice" code
17:09:25 <cmccann> like, at all
17:09:43 <acowley> I always send programming neophytes to the Linux kernel
17:09:51 <cmccann> acowley: https://twitter.com/ReinH/status/331558003876708352
17:09:53 <hpc> somehow i am not finding the cabal docs on google; how do you put a newline in a description field?
17:09:57 <c_wraith> rhyce: you can write remarkably similar code in haskell. Though instead of pointers, you'd just be using offsets, while everything keeps the same output vector in scope.
17:10:05 <acowley> hpc: skip a line?
17:10:17 <acowley> hpc: But the line can't be empty
17:10:23 <rhyce> acowley: I think I learned quite a few things from reading GNU and kernel code back in the day myself
17:10:24 <jfischoff> cmccann: But at least ghc is allowed to use underscore_names (seriously I wish that was the convention)
17:10:46 <hpc> acowley: not doing it for me
17:10:53 <c_wraith> rhyce: like, use thaw to get a mutable copy of the vector to work on, then at the conclusion of the algorithm, use unsafeFreeze to make it immutable without copying it..
17:10:57 <acowley> hpc: Like this? https://github.com/acowley/HOpenCV/blob/master/HOpenCV.cabal
17:11:09 <c_wraith> rhyce: and other than that, don't allocate any new vectors at all. Just mutate the one in scope.
17:11:16 <rhyce> c_wraith: but that sounds like I'd have to limit my recursion, no?
17:11:27 <acowley> rhyce: It's not that there's nothing to learn, it's just that the authors of those code bases have considerations and compromises in mind that are of no concern to most programs
17:11:54 <c_wraith> rhyce: limit in what way?
17:12:06 <thoughtpolice> honestly, i think as far as documentation, layout, and refactored-ness goes, GHC is pretty good. is it gnarly? yes. but i'd say part of that also comes with the territory
17:12:55 <c_wraith> I wish the ghc api had a few dozen more types.
17:13:00 <jfischoff> thoughtpolice: legacy code, speed, I'm curious which territory?
17:13:07 <c_wraith> So that it was actually possible to understand how to use it just based on the types.
17:13:09 <thoughtpolice> the territory of being a compiler :P
17:13:11 <rhyce> acowley: I certainly think they are a great place to learn "tricks"
17:13:28 <thoughtpolice> especially one a lot of people rely on, on a lot of different systems, that offers competetive code generation, advanced tools, etc
17:13:41 <cmccann> thoughtpolice: but would you point someone to GHC as a place to learn good programming habits for Haskell? :T
17:13:59 <hpc> acowley: https://github.com/headprogrammingczar/decepticons/blob/master/decepticons.cabal
17:14:05 <rhyce> c_wraith: well, my current appraoch is divide and conquer -- to keep the vectors in scope I'd have to convert it to a non-recursive form
17:14:08 <cmccann> hpc: you are a hero
17:14:17 <hpc> it's coming up on one line
17:14:24 <jfischoff> thoughtpolice: Not sure if I agree, but then again does GHC have restrictions on the type of GHC features it can use?
17:14:30 <c_wraith> rhyce: that's not true at all. You can easily define the recursive function in a scope where the vector is closed over
17:14:41 <rhyce> c_wraith: ohhhh, tricky
17:14:46 <thoughtpolice> cmccann: oh, probably not.
17:14:48 <acowley> hpc: Did you look at the .cabal I linked you?
17:15:02 <hpc> i did
17:15:06 <simpson> LogicT seems pretty cool. However, I'm not terribly sure how to go about using it to improve old code which just used [] as the logic monad of choice. Are there any tutorials or docs on this?
17:15:10 <rhyce> c_wraith: good idea!
17:15:11 <cmccann> thoughtpolice: context here is https://twitter.com/ID_AA_Carmack/status/331557216488390656
17:15:37 <acowley> hpc: skip a line between the two lines of your description, and put a period under the opening 'T' of the first line.
17:15:52 <rhyce> c_wraith: honestly, this sort of code is really hard to write in Haskell IMO
17:15:58 <hpc> that's such a stupid thing to have to do
17:16:09 <acowley> hpc: Yes. Yes it is.
17:16:33 <acowley> We should have Carmack study the the way cabal files get typeset after he's done with GHC.
17:16:37 <cmccann> :[
17:16:38 <thoughtpolice> jfischoff: well, yes, there are some restrictions on that, but what does that have to do with it? i'd still say GHC is a complex application, and with complexity comes some degree of gnarlyness to handle.
17:16:43 <rhyce> fascinating, but hard
17:17:12 <thoughtpolice> especially for GHC, because it doesn't have as easy of a job as say, a C compiler. it has to work with multiple C compilers now, which offer varying features, capabilities. same with the hardware. same with the OS
17:17:21 <c_wraith> rhyce: it's true. Haskell doesn't optimize for writing code with heavy mutation, because it really does want to encourage you to find a different way to solve it. Though you often can write a couple one-liners for combining common operations together so that the code is still easily readable.
17:17:56 <acowley> I write lots of mutation heavy code in Haskell!
17:18:11 <jmcarthur> laziness doesn't count :P
17:18:19 <dmwit> GHC works with a C compiler?
17:18:37 <thoughtpolice> dmwit: i guess i more mean the RTS, but this has various interactions with how the compiler etc behave
17:18:48 <acowley> jmcarthur: I wasn't counting laziness, but now I wish I had thought of that
17:18:50 <dmwit> mm
17:19:13 <rhyce> c_wraith: for sure. I started down this path because I noticed that all of the "high performance" libraries use mutation -- and some initial experiements with it showed it was vastly faster.
17:19:25 <thoughtpolice> my argument is more is that GHC's not doing an exactly easy job, and with that i can expect and understand a measure of gnarlyness. it could definitely be better even then
17:20:00 <acowley> rhyce: What are you writing?
17:20:01 <thoughtpolice> but i still think it's pretty good in a lot of aspects. just the documentation is amazing, although it's hard to read and keep up with
17:20:19 <rhyce> acowley: parallel sorting algorithm
17:20:41 <rhyce> acowley: which is actually hard on its own
17:21:07 <acowley> rhyce: What algorithm?
17:21:21 <rhyce> acowley: I started out with the usual suspects: radix, mergesort
17:21:29 <rhyce> acowley: but I have gotten the best results so far with bitonic sort
17:22:03 * hackagebot decepticons 0.1.0.0 - The categorical dual of transformers.  http://hackage.haskell.org/package/decepticons-0.1.0.0 (JoeQuinn)
17:22:16 <Hafydd> Hahaha/
17:22:22 <cmccann> hpc: well done
17:23:17 <rhyce> acowley: my "naive" mergesort is here: http://hpaste.org/87382
17:23:31 <rhyce> acowley: the bitonic one is that monster I pasted a while back
17:24:44 <Ankhers> In GHC, is there a way to see how a type is defined?
17:25:07 <acowley> rhyce: The wikipedia page on it makes bitonic look intrinsically monstrous
17:25:07 <rhyce> :t
17:25:29 <rhyce> acowley: it's really simple but the writeup is horrible
17:25:31 <Hafydd> In GHCi, you can use :i to achieve something like that.
17:25:33 <jmcarthur> Ankhers: in GHCi, you can use :i to get info about a type
17:26:10 <rhyce> acowley: the idea is basically on arrays that a perfect power of two you can split them up so that you can swap elements without having conflicting memory access
17:26:35 <Ankhers> jmcarthur: Thanks
17:26:53 <rhyce> acowley: and you just enforce the bitonic property to make it all jam -- that's really it
17:27:03 * hackagebot hyakko 0.6.1 - Literate-style Documentation Generator  http://hackage.haskell.org/package/hyakko-0.6.1 (JeremyHull)
17:27:13 <rhyce> it's kinda like a mergesort that swaps stuff
17:28:01 <rhyce> but it's designed to be very parallel
17:28:09 <rhyce> as you can probably tell from some of the discussion
17:28:32 <rhyce> whereas, say, bubblesort can't be made parallel
17:28:54 <c_wraith> I'm not sure that's true
17:29:16 <rhyce> c_wraith: each iteration works over the whole array
17:29:18 <c_wraith> perhaps it can't be made parallel in a way that gives much profit, though
17:29:35 <rhyce> c_wraith: the only way to do it would be to split, bubble sort, then merge
17:29:41 <rhyce> but that's not really bubblesort anymore
17:29:44 <Ankhers> does Haskell have a positive integer type?
17:29:50 <rhyce> or to just do it in a crazy way ;)
17:30:04 <dmwit> Ankhers: There are a few floating around Hackage.
17:30:09 <dmwit> Perhaps in...
17:30:12 <dmwit> ?hackage numbers
17:30:12 <lambdabot> http://hackage.haskell.org/package/numbers
17:30:15 <c_wraith> rhyce: nah, do each non-overlapping pair in parallel, then flip the set of pairs being operated on, do them in parallel, etc, until there are no more changes to be made
17:30:43 <hpc> dmwit: oh god, that package reminds me of the tv show now, for some reason
17:30:46 <dmwit> Well, numbers has Natural, but that's even more special than just positive: it's also lazy.
17:30:47 <c_wraith> rhyce: I don't think that will get you much profit. But it's certainly parallel with much of the flavor of bubble sort
17:31:08 <dmwit> I'm sure there's an efficient newtype wrapper around Integer on Hackage somewhere, though.
17:31:15 <rhyce> c_wraith: right, you'd get killed in the indexing
17:31:28 <Ankhers> dmwit: thanks.
17:31:54 <rhyce> the comparison operations are so fast if you tried to use the declarative parallelism approach you'd probably end up with a bunch of duds
17:32:08 <rhyce> "fizzled" sparks
17:32:08 <timemage> Ankhers,  if you're dealing with a file format or something like that, Data.Word might be what you're looking for.
17:32:09 <rhyce> rather
17:32:12 <c_wraith> rhyce:  my old algorithms textbook would call it a parallel algorithm! But it's not practical on current hardware, since it depends on barriers everywhere
17:32:28 <Ankhers> dmwit: forgive my ignorance, but how do natural number differ from positive numbers?
17:32:49 <rhyce> natural numbers are 1, 2, 3, etc
17:33:00 <dmwit> uh
17:33:07 <rhyce> Ankhers: you are thinking of Z^+
17:33:22 <dmwit> I'm not sure I'm on board with rhyce here.
17:33:27 <rhyce> Z+
17:33:34 <rhyce> Z+ is the space of positive integers
17:33:42 <rhyce> which is what I think is what you mean?
17:33:43 <c_wraith> I'm pretty sure the definition of "natural numbers" changes based on what side of the atlantic you're on.
17:33:48 <dmwit> yes
17:34:09 <copumpkin> c_wraith: I think it's more depending on what you plan to do with the numbers
17:34:12 <rhyce> There is no universal agreement about whether to include zero in the set of natural numbers: some define the natural numbers to be the positive integers {1, 2, 3, ...}, while for others the term designates the non-negative integers {0, 1, 2, 3, ...}. The former definition is the traditional one, with the latter definition having first appeared in the 19th century. Some authors use the term natural number to exclude 0 and whole number to
17:34:13 <rhyce> include it; others use whole number in a way that includes both 0 and the negative integers, i.e., as an equivalent of the integer term.
17:34:13 <rhyce>  
17:34:13 <rhyce>  
17:34:16 <dmwit> Ankhers: But as I said, the main thing I think is special about the Natural type defined in the "numbers" package is that it's lazy.
17:34:18 <rhyce> from wikipedia
17:34:19 <cmccann> dmwit: is there usually much happening on Sunday at hac phi? I'm not sure I can make the whole weekend :[
17:34:28 <dmwit> Ah, bummer!
17:34:32 <rhyce> over where I am it starts at 1 ;)
17:34:45 <copumpkin> who cares
17:34:49 <copumpkin> use whichever works for what you need :P
17:34:59 <dmwit> Sunday is usually more of the same of Friday and Saturday: lots of hacking and noise.
17:35:09 <copumpkin> omg hax
17:35:10 <thoughtpolice> sunday ends sooner however!
17:35:21 <Nisstyre-laptop> dmwit: can you work with lots of noise?
17:35:21 * cmccann doesn't see why you'd even want a name for the natural numbers sans 0.
17:35:28 <dmwit> Yes, Sunday is special because that is the day where we kick you out.
17:35:29 <Nisstyre-laptop> cmccann: the positive integers
17:35:31 <rhyce> is everyone on here mostly from the non-US side of the atlantic ;)
17:35:34 <Ankhers> starting at 1 works for me, I can pass in a Nothing if need be.
17:35:49 <jmcarthur> i like to pretend that mathematicians usually start at 1 and computer scientists start at 0, but it's not really true
17:35:51 <dmwit> Nisstyre-laptop: I can't really work, period. =/
17:35:56 <Nisstyre-laptop> dmwit: same
17:36:07 <Nisstyre-laptop> unless I go to the student lounge and stay there all night
17:36:10 <dmwit> rhyce: I am in the US, and natural includes 0 for me.
17:36:10 <Nisstyre-laptop> even then I don't get much done
17:36:20 <rhyce> dmwit: http://mathworld.wolfram.com/Z-Plus.html
17:36:29 * BMeph is VERY curious as to which side of the Atlantic Canada is supposed to be.... ;þ
17:36:47 <Ankhers> I am interested in knowing that too...
17:37:04 <Nisstyre-laptop> also, can't the natural numbers (by the Peano axioms) start at any number really? Whichever one you choose as the "first", it doesn't really matter except that there is a first natural number.
17:37:34 <dmwit> Ugh, how did this devolve into a terminology argument?
17:37:35 <rhyce> BMeph: My comment was intentionally inflammatory ;)
17:37:43 <Ankhers> dmwit: sorry...
17:37:48 <cmccann> dmwit: people some people misuse the term "natural numbers" clearly :P
17:37:52 <dmwit> The real question here is what Ankhers wants, not what we all call the various kinds of numbers.
17:37:53 * cmccann is not helping
17:38:08 * ab9rf is not helping either
17:38:12 <cmccann> I vote we call all of the numbers George.
17:38:13 <rhyce> I think the bottom line is: 0, 1, 2, 3 or 1, 2, 3 is a valid answer
17:38:24 <ab9rf> cmccann: that name is taken.  it's my daughter's nickname.
17:38:39 <Nisstyre-laptop> cmccann: Russell's "Introduction to Mathematical Philosophy" makes it clear that the natural numbers by the Peano axioms don't have to correspond to our intuitions about what the natural numbers are, so it could start at 0, 1, or 55, it only matters that there is a first one.
17:38:48 <ab9rf> cmccann: i will, however, accept the notion of calling all numbers greater than 4 "Yellow"
17:39:04 <rhyce> I don't include zero because it wasn't a number for a long time
17:39:20 <Nisstyre-laptop> rhyce: but it has been one for a long time
17:39:28 * copumpkin sighs
17:39:33 <DanBurton> zero has been a number for a nonzero amount of time
17:39:35 <rhyce> zero is a very controversial number
17:39:40 * dmwit pats compumpkin on the back, then sighs, too
17:39:44 <ab9rf> teach the controversy!
17:39:46 <Nisstyre-laptop> rhyce: if you live in ancient Persia
17:39:50 * ab9rf runs
17:39:55 <rhyce> hahah
17:40:01 <rhyce> I'm just saying
17:40:02 * copumpkin catches and slaps ab9rf 
17:40:14 <cmccann> dmwit: anyway yeah, transportation is kind of awkward so I'll probably have to leave sunday morning
17:40:14 <rhyce> if people didn't believe it existed, that doesn't sound very natural to me! ;)
17:40:15 <ab9rf> i am a bad person :)
17:40:17 <dmwit> ?slap basically everybody
17:40:18 * lambdabot orders her trained monkeys to punch basically everybody
17:40:18 <Nisstyre-laptop> rhyce: in which case tyranny is also cool
17:40:25 <Nisstyre-laptop> and so is invading Greece
17:40:44 <cmccann> dmwit: unless there's anything really important likely to be going on sunday afternoon
17:41:06 <ab9rf> is invading greece a pure computation?
17:41:11 <dmwit> cmccann: I look forward to meeting you for Friday and Saturday, then!
17:41:19 <dmwit> I'll take a day and a half of cmccann if that's all I can get.
17:41:35 <hpc> ab9rf: it's like ST
17:41:36 <Nisstyre-laptop> ab9rf: depends
17:41:43 <hpc> there's side effects, but nothing the rest of the world will notice
17:41:51 <rhyce> ouch
17:42:00 <cmccann> dmwit: edwardk put up with me for about that long, so you should survive.
17:42:23 * dmwit ponders ways to make this conversation get even more sidetracked
17:42:36 <dmwit> "Invading Greece has a side effect: the price of bitcoin skyrockets."
17:42:42 <cmccann> anyway, the natural numbers are just a shorthand notation for church numerals, so pf.
17:42:45 <ab9rf> dmwit: heh
17:42:59 <rhyce> cmccann: I don't know if I agree with that ;)
17:43:08 <copumpkin> just FYI
17:43:13 <copumpkin> john carmack will soon join this channel
17:43:19 <copumpkin> and will get scared away by people talking about a bunch of pointless crap
17:43:20 <cmccann> oh boy
17:43:22 <rhyce> cmccann: because the church numerals for sure include zero
17:43:33 <tgeeky> rhyce: which element is the smallest is not important
17:43:37 <copumpkin> not even the usual interesting pointless crap that goes on in here
17:43:42 <copumpkin> pure mental masturbation for the sake of being right
17:43:47 <Nisstyre-laptop> copumpkin: how do you know that?
17:44:06 <copumpkin> because he tweeted about wanting to do a haskell project and wanting feedback and he got a dozen tweets back telling him to come in here
17:44:10 <cmccann> yeah
17:44:14 <cmccann> that was discussed earlier
17:44:15 <coppro> hahaha
17:44:17 <rhyce> copumpkin -- that's pretty cool
17:44:24 <cmccann> then it got sidetracked over someone suggesting he look at GHC's source
17:44:27 <rhyce> what kind of haskell project?
17:44:28 <Nisstyre-laptop> copumpkin: let's start talking about rocket science then
17:44:29 <cmccann> as an example of haskell code to learn from
17:44:38 <ab9rf> heh
17:44:40 <dmwit> In #haskell's defense, it does tend to clean its act up once a serious Haskell question comes along.
17:44:44 <copumpkin> :)
17:44:50 <ab9rf> i don't know if looking at other people's haskell code is a good way to learn
17:45:16 <cmccann> dmwit: at least until the question has been answered, and we proceed to abstraction golf it into absurdity
17:46:07 <Nisstyre-laptop> ab9rf: I've learned more from reading papers, hoogle, stackoverflow, and my own blundering around
17:46:48 <rhyce> Nisstyre: for real
17:47:15 <Nisstyre-laptop> rhyce: probably the paper that helped me most was the one by Luca Cardelli that explains type inference
17:47:28 <Nisstyre-laptop> PLAI also does a really good job at that
17:47:40 <rhyce> Nisstyre-laptop: I recently read the Milner papers and this other one that was quite good
17:47:47 <rhyce> leme find it
17:48:05 <cmccann> getting edwardk wound up on whatever he's currently doing is another good way to learn stuff
17:48:13 <cmccann> bit of a crapshoot what exactly you learn though
17:48:18 <rhyce> The title was Basic Polymorphic Typechecking I think
17:48:28 <Nisstyre-laptop> rhyce: that's exactly the one I was talking about
17:48:31 <Nisstyre-laptop> I think
17:48:35 <tgeeky> cmccann: yes, though he's not the only one. There are a few prolifics among us. Carmack is probably one, but I've never met him.
17:48:49 <acowley> rhyce: Do you have a benchmark set up for your sorting stuff?
17:48:52 <rhyce> Nisstyre: ah, nice
17:48:55 <ab9rf> i spent a good part of today uninstalling IE 10 so i'm not in the mood to try to make sense of anything more complicated than a manhattan
17:49:06 <rhyce> acowley: sure
17:49:08 <Nisstyre-laptop> rhyce: it's the one with the Modula-2 implementation of H-M right?
17:49:16 * tgeeky is sad that there can now be a (10) after IE
17:49:16 <rhyce> Nisstyre: yes
17:49:22 <rhyce> not that I read that part :)
17:49:37 <Nisstyre-laptop> me neither
17:50:00 <acowley> rhyce: Can I see it?
17:50:00 <ab9rf> i think it's notable that Ie is a swear word in Rihannsu
17:50:55 <rhyce> acowley: the benchmarking rig? or results?
17:51:03 <acowley> rhyce: The benchmarking rig
17:51:09 <rhyce> ok, one sec
17:53:40 <hpaste> “Anonymous Coward” pasted “Benchmark Rig” at http://hpaste.org/87384
17:53:54 <rhyce> acowley: thar you go
17:54:00 <rhyce> drop a big text file in there
17:55:44 <acowley> Oy, that's Stringy
17:56:53 <rhyce> acowley: if it weren't I'd be using unboxed types ;)
17:57:24 <acowley> Do you really need to use String?
17:57:33 <acowley> Not ByteString and not Text?
17:57:38 <ab9rf> one stringy dingy
17:58:19 <rhyce> acowley: not strictly, but I just subtract out the initialization time when I'm looking at it
17:58:36 <rhyce> like, in comparison to each other
17:59:22 <rhyce> are you cooking something up?
17:59:28 <rhyce> ;)
18:08:39 <acowley> rhyce: I wrote a stupid par version that gets me a 30% speedup on my dual core (with HT) machine
18:08:53 <acowley> rhyce: But it's probably slow overall, and I don't actually know if it's right
18:09:11 <rhyce> acowley: want to paste?
18:10:15 <Ankhers> :r
18:10:18 <Ankhers> ...miss...
18:12:44 <Ankhers> I don't even know if this makes sense, but how would I go about making a type that can either be and Integer, or a list of Integers?
18:13:40 <geekosaur> data These = This Integer | These [Integer] -- ?
18:14:37 <Ankhers> geekosaur: Thanks.
18:15:05 <Eduard_Munteanu> Dat Integer | Them [Integer] might cater to regional variations
18:15:21 <geekosaur> "Dem", surely?
18:15:28 <Ankhers> I thought so.
18:15:31 <Eduard_Munteanu> Pehraps. :)
18:15:54 <luite> Surely Integer | Perhaps [Integer]
18:15:58 <geekosaur> maybe even more generally: data These a = This a | These [a] -- and instantiate as These Integer
18:16:48 <Ankhers> probably a better idea...
18:17:49 <hpaste> acowley pasted “naive bitonic” at http://hpaste.org/87385
18:18:05 <hpc> data State a = Integer a | String [a] | FILE_NOT_FOUND
18:18:14 <Eduard_Munteanu> Poor bitonic.
18:18:18 <hpaste> “Anonymous Coward” annotated “mucking around” with “mucking around (annotation)” at http://hpaste.org/53363#a87386
18:18:28 <acowley> I don't think that code is very good, but it's not worth worrying about a benchmark unless it's measuring something you know is useful
18:18:56 <acowley> don't pity bitonic
18:20:25 <rhyce> acowley: Nice!
18:20:48 <acowley> Those vector appends are reason to weep :(
18:21:59 <rhyce> acowley: I experimented quite a bit with those appends and found that ++ was actually pretty much the BEST you can do except for the techniques used here: http://hackage.haskell.org/packages/archive/vector-algorithms/0.5.4/doc/html/src/Data-Vector-Algorithms-Merge.html#sort
18:22:36 <rhyce> ++ is O(m+n) in vector
18:23:07 <acowley> Yeah, I'd do some grotty pointer munging, seal it behind a respectable type, and be on my way :/
18:23:18 <acowley> If it needed to be faster than the pure-ish version I pasted
18:23:47 <rhyce> acowley: also, the fastest way to split up the vector I found to be: (unsafeTake ((length v) `quot` 2) v, unsafeDrop ((length v) `quot` 2) v
18:24:01 <rhyce> acowley: no, it's very nice, I'm reading through it now
18:24:10 <acowley> I don't think anything can be faster than slice
18:24:15 <acowley> other than unsafeSlice
18:24:24 <rhyce> acowley: try ;)
18:25:09 <acowley> rhyce: unsafeDrop n v = unsafeSlice n (length v - n) v
18:25:27 <rhyce> say it isn't so!
18:25:39 <acowley> http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/src/Data-Vector-Generic.html#unsafeDrop
18:25:49 <lpvb> are there any benchmarks for frege
18:26:10 <rhyce> guess I missed that
18:26:30 <rhyce> I wonder what I was comparing it to, hurm
18:27:02 <rhyce> either way I guess they end up being the same
18:29:07 <acowley> I save a subtraction
18:36:02 <rhyce> acowley: on my machine on a 7M file it runs in about 21s
18:36:52 <rhyce> back in a bit
18:38:17 <rhyce> acowley: also, strangely no sparks get created
18:38:20 <rhyce> hurm
18:38:34 <acowley> rhyce: I got 101 sparks
18:38:37 <acowley> on my test dat
18:38:40 <acowley> data
18:38:53 <acowley> rhyce: How are you compiling and running the program?
18:39:04 <rhyce> ghc -O2 Par2.hs -threaded -rtsopts -eventlog
18:39:06 <acowley> ghc -O2 -fllvm -threaded Bitonic.hs
18:39:14 <acowley> ./Bitonic +RTS -N
18:39:20 <rhyce> ./Par2 +RTS -N2 -s -ls
18:39:39 <rhyce> SPARKS: 0 (0 converted, 0 overflowed, 0 dud, 0 GC'd, 0 fizzled)
18:39:57 <rhyce> weird... hurm. Anyhoo, back in a bit. It's time to go outside ;)
18:52:43 <Taslem> Would there be a parallel IO function out there, along the lines of: par :: IO () -> IO () -> IO (), which executes its arguments in parallel, but blocks until they're both done?
18:53:36 <acowley> Taslem: monad-par supports that kind of thing
18:53:43 <benzrf> hi!
18:54:14 <benzrf> I feel like I understand monads well enough to use them, if not fully, but there's one thing I don't get and it makes me think maybe I don't understand them:
18:55:17 <benzrf> why is >>= of type 'm a -> (a -> m b) -> m b' and not 'm a -> (a -> b) m b'?
18:55:40 <benzrf> why does it need to be the bound function's responsibility to return a monad and not the monads"
18:55:52 <benzrf> for that matter, why not just 'm a -> (a -> b) -> b'?
18:55:53 <acowley> :t flip fmap
18:55:54 <lambdabot> Functor f => f a -> (a -> b) -> f b
18:56:18 <benzrf> was that directed toward me?
18:56:20 <NetBat> folks: would one have to load `parsec with a `:l' or `:m' command?
18:56:22 <Shou> benzrf, yes
18:56:29 <Shou> Monads are also Functors, so you can use fmap
18:56:30 <benzrf> I don't get what you're illustrating :<
18:56:34 <benzrf> oh, ok
18:56:39 <Shou> and fmap does what you want
18:56:40 <monochrom> functor already gives you m a -> (a -> b) -> m b. this is very little expressive power.
18:56:42 <geekosaur> NetBat, unless you're working directly witht he parsec library source, :m
18:57:14 <benzrf> erm, I guess what I meant was, what's the point of the bound function returning a monad instead of it being the monad's responsibility? what functionality does it serve?
18:57:21 <monochrom> m a -> (a -> b) -> b can be combined with id::a->a to give you m a -> a, which is too much expressive power, for example IO cannot support this, [] cannot either
18:57:24 <NetBat> I don't seem to be getting very far with it though
18:57:26 <benzrf> I have a feeling that question reveals a deep misunderstanding
18:57:39 <benzrf> ok
18:58:10 <benzrf> so it's important that a binding return a new monad so that monads can represent 'unpackable' types?
18:58:16 <benzrf> *ununpackable
18:58:20 <benzrf> nonunpackable?
18:59:02 <monochrom> m a -> (a -> m b) -> m b is "just right". it doesn't leak like "m a -> a", and it still forwards that "a" to the next stage (the "a -> m b")
18:59:46 <benzrf> ok... so, what is the purpose of making the function return a monad?
18:59:57 <benzrf> what does that enable?
19:00:40 <atamagawarui> What is the purpose of making a function return an Integer? What does that enable? :-O
19:00:52 <benzrf> >:P
19:00:55 <_just> what do you mean with 'making the function return a monad'?
19:00:56 <Shou> benzrf, what if you do `getLine >>= putStrLn'. With your proposal, it'd turn into `IO (IO ())' if it were to
19:00:56 <sellout-> benzrf: You mean, why isn’t it m a -> (a -> b) -> m b ?
19:01:01 <monochrom> I think I'm saying, instead, it disables.
19:01:02 <Taslem> Just 5 >>= (\x -> x + 5) --> Just 10
19:01:03 <benzrf> yes, sellout
19:01:07 <benzrf> oh, right
19:01:10 <benzrf> ok
19:01:14 <Taslem> Whoops, return should be in there.
19:01:22 <geekosaur> benzrf, on the one hand, it means you can't escape from e.g. IO or ST. on the other, consider the Maybe monad; how do you work with Nothing if a Just is forced on you?
19:01:22 <Taslem> Just 5 >>= (\x -> return (x + 5)) --> Just 10
19:01:31 <Taslem> Nothing >>= (\x -> return (x + 5)) --> Nothing
19:01:44 <benzrf> actually, I was thinking about Taslem's example
19:01:53 <benzrf> in there the return is redundant for that usage
19:02:00 <benzrf> ait
19:02:01 <benzrf> no it's not
19:02:04 <benzrf> never mind I feel silly
19:02:05 <benzrf> q.q
19:02:11 <benzrf> ok, I think I got it
19:02:21 <Taslem> In that case, I could say "Just" instead of "return" but that's less monad-y.
19:02:32 <monochrom> ok, a->b is a much smaller space than a->m b
19:02:32 <Taslem> The real power is chaining them together, so I could do:
19:02:39 <benzrf> if the monad you bind to has to turn the b into m b, then you have less control in the function about what to return
19:02:48 <sellout-> benzrf: The “interesting” case is when you can’t just wrap the result with return.
19:02:58 <benzrf> sellout-: exactly what I meant with that :>
19:03:08 <Taslem> Just 4 >>= (\x -> if x < 0 then Nothing else return (sqrt x)) >>= (\y -> return (y + 1)) -- Just 3
19:03:10 <benzrf> ok my head feels more orderly
19:03:14 <Taslem> Just (-10) >>= (\x -> if x < 0 then Nothing else return (sqrt x)) >>= (\y -> return (y + 1)) -- Nothing
19:04:10 <Taslem> Maybe monad encodes possible failure, in a safe manner [though it gives no way of telling how the error occurred.] For that, you can use the (Either e) monad.
19:04:20 <benzrf> ok, so a Functor is like a specific case of what you can use a monad for?
19:04:36 <benzrf> i.e. a wrapper around function invocation
19:04:40 <Taslem> All Monads are functors; you can derive a valid definition of fmap from (>>=) and return.
19:04:50 <benzrf> hrm
19:04:53 <Taslem> For historical reasons that's not the default
19:05:24 <monochrom> fmap f m = m >>= \x -> return (f x)
19:05:33 <Taslem> Right.
19:05:47 <geekosaur> (see also liftM)
19:06:00 <benzrf> I don't really know what a Functor is
19:06:01 <monochrom> but there are many interesting a->mb's that are not \x -> return (f x)
19:06:05 <benzrf> I haven't read any docs about it
19:06:06 <benzrf> >_>
19:06:08 <Taslem> Functors are like wrappers
19:06:23 <Taslem> Technically they're a weak form of "computational context." Functions are functors, but that's not obvious.
19:06:26 <benzrf> ok, so, a functor is a wrapper around a value that performs magic before passing a function to a value? basically the same as one thing you can do with a monad?
19:06:40 <Taslem> You can wrap it up, you can do things to it, but you can't unwrap it.
19:06:48 <benzrf> ...wait
19:06:49 <benzrf> ok hm
19:07:07 <benzrf> I should probably read some actual documentation
19:07:09 <benzrf> brb
19:07:13 <monochrom> I think these "magic" "wrapping" are not useful
19:07:22 <benzrf> hrmph
19:07:47 <monochrom> I mean, imagine "java is about enterprise synergy"
19:08:01 <Philippa> benzrf: Functors take functions on one "family of types" (in Haskell, "all types") to another (eg lists of some type)
19:08:13 <tgeeky> monochrom: ... energy?
19:08:16 <Philippa> "family of types" - formally, I actually mean "category"
19:08:21 <monochrom> synergy
19:09:02 <cmccann> monochrom: that java one sounds accurate though
19:09:13 <Philippa> cmccann: you mean it's not about applets?!
19:09:24 <cmccann> nobody likes applets
19:09:39 <Philippa> well no - they're not flashy enough
19:09:44 <benzrf> apparently there will actually be some mild support for FP in Java 8
19:09:49 <benzrf> nothing too alarming though
19:10:18 <benzrf> but there will at least be phony sugary lambdas and function pointers
19:10:20 <benzrf> :|
19:11:11 <benzrf> ok... a functor is kind of like a monad... but the functor rewraps the return value instead of the function wrapping it?
19:13:42 <Philippa> benzrf: monads are structures that contain functors anyway
19:13:47 <Philippa> liftM = fmap
19:13:53 <benzrf> hm
19:14:38 <monochrom> when you write "map f [1,2,3] = [f 1, f 2, f 3]", you're using functor
19:15:27 <monochrom> note how [1,2,3] >>= \x -> return (f x) is [f 1, f 2, f 3] again
19:15:38 <Philippa> right - lists are a new "kind of thing" you can compute on (compared to "plain values"), the functor takes your function from plain values to lists of values
19:15:40 <benzrf> it just occurred to me... how are RNGs handled in haskell?
19:16:16 <cmccann> as RNGs
19:16:24 <benzrf> >_.
19:16:25 <cmccann> well, PRNGs
19:16:30 <Philippa> benzrf: there's an optional impure bit for picking a seed, then you get a sequence of numbers same as anywhere else
19:16:36 <cmccann> as opposed to a magic "function" that spits out "random" numbers from nowhere
19:16:48 <benzrf> hm
19:17:04 <Philippa> it's just that we talk about the sequence rather than a stateful function to give you the next number from it
19:17:17 <ParahSail1n> @ty random
19:17:18 <benzrf> ok
19:17:18 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
19:17:27 <ParahSail1n> thats how rngs are handled
19:17:31 <benzrf> aaah
19:19:08 <Philippa> which is effectively an "uncons" operation
19:19:47 <Philippa> you can have a RandomGen instance for lists, in which case you get random l = (head l, tail l)
19:20:15 <parcs> there should be a randomsIO
19:22:30 <Philippa> cmccann: so one of the 'interesting' things about Haskell is the way we tend to end up building 'objects' or 'abstract machines' in which it's totally normal for us to pass around machine-continuations as values and poke them with sticks
19:22:34 <tromp> also see http://byorgey.wordpress.com/ about Control.Monad.Random
19:22:45 <Philippa> (not to mention machine-states, of course)
19:23:01 <Philippa> but we don't just do that kind of stuff for eg monadic code
19:23:25 <Philippa> in an odd way, we actually get "more OO than OO"
19:23:47 <benzrf> how so>
19:24:05 <Philippa> we get more control over our 'objects'
19:24:12 <benzrf> hrm
19:24:36 <DigitalKiwi> OO isn't about object
19:24:37 <DigitalKiwi> s
19:24:40 <DigitalKiwi> it's about turtles
19:24:41 <DigitalKiwi> duh
19:25:06 <Philippa> (I had a conversation with my gf about this last year in a curry house in Birmingham, we had a couple of... probably IT consultants on the table next to us too who were wondering what we were talking about)
19:25:49 <DigitalKiwi> """Alan Kay creates Smalltalk and invents the term "object oriented." When asked what that means he replies, "Smalltalk programs are just objects." When asked what objects are made of he replies, "objects." When asked again he says "look, it's all objects all the way down. Until you reach turtles"""
19:26:10 <Philippa> ...congratulations, you found that post too
19:26:36 <DigitalKiwi> http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
19:26:39 <DigitalKiwi> :)
19:27:06 <DigitalKiwi> found it? I practically discovered it!
19:27:26 <monochrom> a chain of ω objects and then ω turtles
19:27:44 <monochrom> and what happens after turtles? I have an answer
19:27:49 <monochrom> @quote monochrom primop
19:27:50 <lambdabot> monochrom says: primop is where the turtle tower ends and the russian dolls begin!
19:30:08 <benzrf> what's the best intro to smalltalk though
19:30:19 <benzrf> if I'm used to python and/or java
19:30:58 <Philippa> forgetting both of them and thinking of it as message-passing on top of an imperative FPL
19:31:11 <benzrf> :P
19:31:24 <Philippa> not kidding there: they use church encodings in anger
19:31:31 <benzrf> wah?
19:31:45 <Philippa> Smalltalk doesn't need a built-in if statement or booleans!
19:31:53 <benzrf> neat
19:32:01 <benzrf> I know a little ruby...
19:32:12 <benzrf> d:
19:32:25 <Philippa> that'll help, yeah
19:32:40 <Philippa> dunno what's supposed to be good tutorial material, I suspect it depends on which Smalltalk you picked
19:32:56 <Hafydd> Smalltalk uses Church booleans?
19:33:04 <levi> Ruby is like the bastard child of Smalltalk, Scheme, and Perl.
19:33:15 <Philippa> Hafydd: some Smalltalks certainly have done
19:33:25 <benzrf> levi: scheme?
19:33:28 <benzrf> how so
19:33:57 <Philippa> Smalltalk's effectively lisp-descended in its own right
19:34:23 <levi> http://stephane.ducasse.free.fr/FreeBooks/BlueBook/Bluebook.pdf
19:34:36 <DigitalKiwi> thanks to #haskell talk about that prolog joke and my subsequent research I understand this now >.> 1972 - Alain Colmerauer designs the logic language Prolog. His goal is to create a language with the intelligence of a two year old. He proves he has reached his goal by showing a Prolog session that says "No." to every query.
19:34:57 <benzrf> ahaha
19:35:06 <Hafydd> Hahahah.
19:35:36 <DigitalKiwi> the joke being "How many prolog programmers does it take to change a light bulb?" "No"
19:35:38 <levi> benzrf: Matz cited it as one of his influences. It's got (or had, at least) a form of call/cc, IIRC.
19:35:49 <benzrf> oh hm
19:36:23 <levi> call/cc and regexp literals. What a language!
19:37:27 <benzrf> if I'm writing something where regexp literals are worthwhile, I probably don't need anything ruby has that perl doesn't...
19:42:43 <levi> Well, I never really thought ruby was worthwhile enough to write anything with it.
19:44:26 <sevvie>  Textual IRC Client:
19:44:26 <sevvie>           http://www.textualapp.com/)
19:53:45 <bobajett> Im trying to write a function 'mygroup', such that mygroup " h e ll o" --> results in ["h","e","ll","o"], so basically it groups consecutive letters together skipping over space characters
19:54:02 <bobajett> here is what I have:
19:54:21 <bobajett> mygroup :: String -> [String]
19:54:21 <bobajett> mygroup xs = let (xs', ys') = span (/= ' ') xs
19:54:21 <bobajett>              in xs' : if null ys'
19:54:21 <bobajett>                       then []
19:54:24 <bobajett>                       else mygroup (tail ys')
19:54:35 <bobajett> but this results in
19:54:47 <bobajett> ["","h","e","ll","o"]
19:55:02 <bobajett> is there a way I can get rid of the first blank within the function itself?
19:55:14 <Nisstyre-laptop> @src groupBy (==)
19:55:14 <lambdabot> Source not found. Sorry.
19:55:17 <Nisstyre-laptop> @src groupBy
19:55:17 <lambdabot> groupBy _  []       =  []
19:55:17 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
19:55:17 <lambdabot>     where (ys,zs) = span (eq x) xs
19:55:24 <Nisstyre-laptop> > group "hello"
19:55:27 <lambdabot>   ["h","e","ll","o"]
19:55:55 <Nisstyre-laptop> bobajett: various ways you can do that
19:56:24 <bobajett> Nisstyre-laptop: groupBy compares for equality consecutive characters no? Im trying to group by non-space characters.
19:56:43 <Nisstyre-laptop> bobajett: oh, so you just want to split by ' ' ?
19:56:50 <bobajett> right
19:57:07 <Nisstyre-laptop> http://hackage.haskell.org/packages/archive/MissingH/1.0.0/doc/html/Data-String-Utils.html
19:57:31 <tromp> http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
19:57:37 <Nisstyre-laptop> that was the third result for "haskell strip whitespace"
20:00:07 <Nisstyre-laptop> bobajett: you could write "mygroup (' ':xs) = ... "
20:00:12 <Nisstyre-laptop> and just ignore it that way
20:00:27 <Nisstyre-laptop> if you don't want to use a library function
20:01:06 <bobajett> Nisstyre-laptop: cool I'll try that, and yes I was actually trying to write my own rather than use any library function.
20:10:57 <zebr> hey all. is there a name for a 'dead-end object' in category theory, analogous to a normal form in lambda calculus?
20:12:13 <atamagawarui> zebr: What do you mean by "dead-end object"?
20:12:34 <zebr> atamagawarui: i mean it doesn't have any outward arrows (bar identity)
20:13:33 <dncr> Style may mean less to the Haskelligensia than say for Python, but what are some good Haskell projects to look at to see examples of good style (even if differs between such projects)?
20:13:37 <atamagawarui> zebr: IIRC, an object F is final if for any object O there is exactly one morphism O -> F.
20:13:45 <hpaste> bobajett pasted “myGroup” at http://hpaste.org/87388
20:14:12 <atamagawarui> zebr: sorry, the correct name is "terminal", not "final".
20:15:46 <zebr> atamagawarui: hmm, yeah, i'm looking for, rather, a name for an object O such that there is only one morphism with it as a domain, and that is its identity.
20:16:15 <Mortchek> zebr, you might try asking ##categorytheory as well.
20:16:33 <zebr> ah, i didn't know that was a thing, thanks
20:17:01 <bobajett> can someone suggest how to cleanup 'mygroup'? http://hpaste.org/87388  , I dislike the nested if-else, (hiding behind a 'case of' doesn't make it any better)
20:17:21 <byorgey> atamagawarui: "final" is used also
20:17:39 <hpaste> bobajett revised “myGroup”: “myGroup” at http://hpaste.org/87388
20:17:40 <atamagawarui> byorgey: Ah!
20:17:41 <byorgey> zebr: note the concept of a terminal object is quite a bit stronger than what you're asking for
20:17:52 <alang> also coinitial
20:18:35 <byorgey> zebr: I don't know of a name for your concept, honestly it doesn't sound all that useful
20:18:35 <zebr> byorgey: yeah, so i figured
20:19:04 <zebr> byorgey: how so? in abstract rewriting normal forms, which are analogous but with rewrites instead of morphisms, are used all the time
20:19:51 <jfischoff> parcs:ping
20:19:57 <parcs> jfischoff: hi
20:20:06 <dncr> bobajett: what about using instead stuff from http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
20:20:34 <jfischoff> parcs: any new thoughts on the code?
20:21:16 <jfischoff> parcs: I was thinking we could abstract the parUpsweep function in way to make it easier to test
20:21:52 <jfischoff> or may there is some sort of profiling I should do on ghc?
20:22:07 <bobajett> dncr: this is basically a noob's learning exercise on how to write a split like function, without using Data.List.Split, I guess Im trying to figure out how to cleanly get rid of a leading blank, I don't know if Data.List.Split gets rid of the leading blank?
20:22:08 <byorgey> zebr: I don't think it's common to talk about categories where morphisms mean "reduces to"
20:22:50 <byorgey> zebr: such categories are necessarily posets (given two terms, either one reduces to the other or it doesn't) so thinking of them as categories does not really add anything.
20:22:59 <dncr> bobajett: that module has a lot of functions so you can probably get what you want there somehow
20:23:14 <bobajett> Prelude Data.List.Split>  splitOn ".." "..b...c....d.."
20:23:14 <parcs> jfischoff: i don't think the parUpsweep function has a lot of overhead. probably the thing with the biggest overhead is mkSplitUniqueSupply which i changed to use unsafeInterleaveIO
20:23:14 <bobajett> ["","b",".c","","d",""]
20:23:16 <dncr> bobajett: also, doesn't (words " a b") already do what you want?
20:23:42 <byorgey> zebr: so while the concept of a normal form is useful in rewriting systems, I don't think it's very useful in the context of category theory
20:23:49 <dncr> but writing your own version for fun is also fine
20:23:51 <Philippa> zebr: would it make sense to look up how category theory has been applied to rewriting?
20:24:21 <bobajett> dncr: ah yes, words does do that, I should look at its source to see how they get rid of the leading blanks.
20:24:22 <byorgey> zebr: it's possible I'm completely wrong, though.
20:25:11 <jfischoff> parcs: how should I profile ghc?
20:25:13 <dncr> bobajett: also starting with doing a (dropWhile isSpace " a b") in your function is an option
20:25:35 <dncr> or more specifically dropWhile (== ' ')
20:25:38 <parcs> jfischoff: i'm not sure :P
20:25:56 <byorgey> zebr: I guess it becomes a bit more interesting if there can be multiple ways to rewrite a given term to another term, and the different rewritings actually have some computational content
20:26:07 <parcs> jfischoff: maybe you can use threadscope on ghc?
20:26:42 <zRecursive> @hoogle thread
20:26:43 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
20:26:43 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
20:26:43 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
20:26:53 <parcs> jfischoff: you can build GHC with profiling support by altering the mk/build.mk file in the source tree and then profile it like any other haskell application
20:27:00 <dncr> bobajett: or having a pattern-match: mySplit (' ':x) = mySplit x
20:27:06 <zebr> Philippa: i have done, but what i've read doesn't seem to be applicable (and the category theory is realllly hard. :p)
20:27:07 <jfischoff> aye
20:27:56 <simpson> Is taking :: [a] -> [(a, [a])] -- somewhere in a standard library? It's just a function that gives you each item in the list and the list that no longer contains that element.
20:28:10 <zebr> byorgey: that makes sense. i may be going down the wrong route myself, though i am indeed using it to reason about multiple 'rewrite paths', where objects aren't necessarily terms, and things.
20:28:42 <bobajett> dncr: I'll try that pattern-match that you suggested, I was trying that earlier but couldn't get it work. I'll try againg. Thanks though!
20:28:49 <dncr> answers to my earlier question: http://stackoverflow.com/questions/6398996/good-haskell-source-to-read-and-learn-from
20:29:02 <Cale> simpson: I've occasionally requested something like that go into Data.List
20:29:03 <zebr> anyway, i should sleep. thanks for the help.
20:29:39 <Cale> simpson: But no, I end up writing it again every time
20:30:07 <Cale> select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
20:30:36 <dncr> bobajett: good luck. if you later want more specific advice on deuglification, maybe say exactly what you want the function to do (note all the subtly different possibilities in Data.List.Split functions).  and maybe what way you find your current version ugly.
20:31:56 <simpson> Cale: Also, unrelated: Are there any sweet lessons you learned from writing a full game in Haskell that you feel the community doesn't know? (Sorry for springing that, but I just remembered that you are awesome.)
20:32:12 <Philippa> zebr: the bits of CT that give you enough structure to find the really fun bits are often harder than just pushing basic categories around, yeah
20:32:24 <bobajett> dncr: ah yes, I should have said why my function looked ugly, I suppose it looked so ugly to me that I thought it would be just obviously ugly to any seasoned haskeller :-)
20:33:18 <Cale> hmm... there's some stuff which isn't easy to squish into a few lines
20:34:17 <Cale> Well, Arrow is "wrong", would be one thing.
20:34:30 <Cale> (and we know how to fix it to make it much more useful)
20:35:00 <dncr> bobajett: it primarily looks spread-out. what's the line "beautiful code is obviously correct"? sometimes spread-out code is good.
20:36:14 <Cale> simpson: The main thing which would attract someone to using the Arrow interface over Monad is that Monad fundamentally forces you to build up your computations using opaque parts (functions) everywhere.
20:36:58 <simpson> Cale: Whereas Arrow lets you build things out of types? I haven't Arrow'd much.
20:37:00 <Cale> simpson: i.e. whenever you have x >>= f, the implementation of >>= can't inspect f and do anything to improve the way that x is being computed.
20:37:31 <Cale> The only thing it can do is to apply f to some value(s), which it presumably gets by running x.
20:37:58 <simpson> I am reminded of "If you have some data x and some function f, and f wants to do things to x, maybe you wanted to do f(x)."
20:38:00 <Cale> With Arrow, you have a little more hope: when implementing f >>> g, the f and g are both values of a type that you control
20:38:22 <bobajett> dncr: it was an if-else cross-product going on in there - heh! repetition of the same condition in multiple clauses. yuck. but looking at the source for Prelude's "words", makes me realize I've got a long way to go. I can't even grok that source.
20:38:37 <simpson> Cale: Aha.
20:38:47 <Cale> and so the implementation of >>> (and/or the run function for your arrow) will hopefully be able to inspect how that computation was built up to some extent and optimise things dynamically
20:39:20 <Cale> However, there's one problem: Arrow, and the proc/do notation in particular relies very heavily on a primitive called arr
20:39:22 <Cale> :t arr
20:39:24 <lambdabot> Arrow a => (b -> c) -> a b c
20:39:41 <Philippa> mmm. Or if you're really feeling 'nasty' you can turn those dynamic optimisations static by using some carefully-placed template haskell
20:39:51 <bobajett> anyway thanks for the helps folks, gotta grab dinner.
20:39:52 <Cale> and what happens is that sticks black boxes in between each of your arrow computations
20:39:55 <bobajett> \q
20:40:10 <simpson> So if you wanted to do things like, say, reorder drawing commands, now you can't.
20:40:18 <Cale> right
20:40:36 <Cale> Or fuse together state updates in an FRP implementation
20:41:13 <Cale> By adding some primitives to the Arrow class, the extra wiring between the computations can be made more explicit though
20:41:22 <dncr> Cale: So is that why Yampa hasn't been touched in a year?
20:41:31 <Cale> Possibly
20:41:39 <dncr> and still has no proper documentation or even variable names
20:42:20 <dncr> just a lot of "we'd like to tweak things, but no one knows how Space Invaders might be affected"
20:42:24 <Cale> To some extent, Applicative has killed Arrow
20:42:44 <tikhonjelvis> To me, Applicative seems much more natural than Arrow
20:42:52 <Cale> But there's a better Arrow to be had which would be more competitive at least :)
20:43:09 <Cale> Which looks quite a lot like the definition of a symmetric (or perhaps braided) monoidal category
20:43:46 <tikhonjelvis> hmm, I remember reading about symmetric monoidal categories recently
20:43:53 <tikhonjelvis> are they related to linear types?
20:44:09 <Cale> hmm, maybe, I don't know much about linear types
20:44:35 <tikhonjelvis> my understanding is that it basically means you can type a term to be used *exactly* once
20:45:12 <Cale> Like a stronger flavour of uniqueness types, right.
20:45:21 <tikhonjelvis> something like that, yes
20:45:52 * tikhonjelvis doesn't actually know much about uniqueness types
20:45:56 <Cale> I suppose there's a sense in which there's a connection here.
20:46:43 <tikhonjelvis> can you explain exactly what a symmetric monoidal category is?
20:47:48 <Cale> Well, what things do you already know? :)
20:47:59 <tikhonjelvis> the basics, anyhow
20:48:11 <Cale> Okay, so a monoidal category...
20:49:10 <tikhonjelvis> I gather it's a category that has some sort of construction that looks like a monoid
20:49:13 <Cale> Is a category C which comes along with a bifunctor ⊗: C x C -> C
20:49:31 <Cale> and an object I which is a sort of unit for that bifunctor
20:50:08 <Cale> and it's sort of a monoid up to natural isomorphisms
20:50:27 <tikhonjelvis> what does it mean for an isomorphism to be "natural"?
20:50:49 <Cale> So there's a natural isomorphism assoc : (A ⊗ B) ⊗ C -> A ⊗ (B ⊗ C)
20:51:07 <Cale> It means that it's a natural transformation of the implied functors
20:51:23 <Cale> each of whose components is an isomorphism
20:51:37 <tikhonjelvis> okay
20:51:49 <Algabe> help me please
20:52:00 <Cale> So, there's a functor here, C x C x C -> C, which sends (A,B,C) to (A ⊗ B) ⊗ C
20:52:30 <Cale> but if we're in Haskell mode, natural transformations are pretty much polymorphic functions
20:52:45 <tikhonjelvis> right
20:53:02 <Algabe> http://pastebin.com/Kfm1Bnr3 http://i.imgur.com/AX1yZPk.png
20:53:14 <mauke> The paste Kfm1Bnr3 has been copied to http://hpaste.org/87390
20:55:14 <dncr> Has anyone ported YampaSynth to a more current or actively-developed FRP library?
20:56:21 <dncr> Or, are any other FRP libraries efficient enough for producing low-latency audio?
20:56:56 <Cale> tikhonjelvis: So, we have the associator, which is this explicit isomorphism (A ⊗ B) ⊗ C -> A ⊗ (B ⊗ C), and left and right unitors, which are I ⊗ A -> A and A ⊗ I -> A (and the inverses of everything involved here are important if you're translating this into typeclasses)
20:57:25 <tikhonjelvis> and those are just the monoid laws reified
20:57:29 <Cale> yeah
20:57:33 <tikhonjelvis> which is pretty cool
20:58:32 <Cale> and there are some laws which give conditions that ensure any diagram you can form using just the isomorphisms you get by sticking together associators and unitors in various ways will commute
20:59:00 <Cale> They're kind of awkward to write down, but you can see them on http://en.wikipedia.org/wiki/Monoidal_category
20:59:15 <jfischoff> Is there a deadcode analyzer for Haskell?
20:59:23 <cmccann> tikhonjelvis: note that if you parse a syntax tree according to the parentheses, the associator is precisely a tree rotation on that AST :]
20:59:44 <tikhonjelvis> that makes sense
20:59:45 <Cale> and then a symmetric monoidal category in addition to these things has a commutator, which is an isomorphism A ⊗ B -> B ⊗ A
21:00:22 <Cale> (and there are some axioms governing how that interacts with the other things too)
21:00:29 <tikhonjelvis> and how does this relate to a different version of Arrow?
21:01:26 <byorgey> Algabe: dunno, it looks good to me
21:01:43 <Cale> So, when you define an Arrow, you define a category of sorts (albeit one whose objects are all Haskell types and whose composition has to be polymorphic)
21:01:45 <byorgey> Algabe: the error is what I would expect if the closing square brace on line 15 were missing
21:02:12 <Algabe> solved ?
21:02:43 <Cale> :t (<<<)
21:02:45 <lambdabot> Control.Category.Category cat => cat b c -> cat a b -> cat a c
21:03:30 <byorgey> Algabe: you mean you solved it?
21:03:40 <Cale> Back in the old days before they messed with the syntax, we could write that   (Category (~>)) => (b ~> c) -> (a ~> b) -> (a ~> c)
21:04:07 <Cale> But then one of the other things that Arrow comes with is (***)
21:04:14 <Cale> :t (***)
21:04:16 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
21:04:42 <Cale> Or, in the old notation
21:04:44 <tikhonjelvis> which is like × for morphisms
21:05:10 <Cale> (Arrow (~>)) => (b ~> c) -> (b' ~> c') -> ((b,b') ~> (c,c'))
21:05:11 <Cale> right
21:05:47 <Cale> Or: (,) might be our bifunctor for our monoidal category, and this is its "fmap"
21:06:05 <simpson> Oh my. That's pretty powerful stuff.
21:06:06 <tikhonjelvis> and then I is ()?
21:06:24 <Cale> i.e. it's taking a pair of arrows (an arrow in C x C), and turning it into an arrow between pairs
21:06:27 <Cale> and yeah, I is ()
21:06:33 <Cale> if we take that view
21:06:49 <Algabe> byorgey: help me please!!
21:06:51 <Cale> and the associator is an arrow (a,(b,c)) ~> ((a,b),c)
21:07:06 <Cale> (and its opposite)
21:07:10 <Algabe> line 15 "]"
21:07:18 <byorgey> Algabe: I tried. I do not know what is wrong.  Are you absolutely 100% sure that the file you posted is what's in your .xmobarrc?
21:07:24 <tikhonjelvis> which is pretty trival to write
21:07:56 <Algabe> byorgey: yes
21:08:03 <Cale> tikhonjelvis: Well, it probably is, but in general it's going to have some internal structure of some sort in a case where you're really using this properly.
21:08:42 <Cale> tikhonjelvis: i.e. though it could be, it won't just be arr (\(a,(b,c)) -> ((a,b),c))
21:08:55 <Cale> because the arr was the problem which we're trying to avoid :)
21:09:04 <tikhonjelvis> right
21:09:11 <tikhonjelvis> I was just thinking about the case where ~> is ->
21:09:17 <Cale> yeah
21:09:20 <byorgey> Algabe: I don't know then.  I am not familiar with xmobar.  Maybe it is a parser bug.  Have you tried putting the ] on the end of line 14, or indenting it less, or anything like that?
21:10:04 <Algabe> byorgey: not
21:10:41 <Cale> Another thing which is true about symmetric monoidal categories, but not generally true of Arrow instances (but true of all the FRP ones, and something we consider really important)
21:10:58 <Cale> is that (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k)
21:11:32 <Cale> (This is part of the bifunctoriality of ***)
21:12:10 <Algabe> , sepChar = "%"
21:12:11 <Cale> and it's also commonly called the interchange law
21:13:00 <Cale> It ensures that you can paste together arrow diagrams without worrying whether the diagram is being cut up vertically or horizontally first.
21:13:27 <tikhonjelvis> hmm, and interesting way to think about it
21:13:42 <byorgey> string diagrams, huzzah! =)
21:13:48 <Cale> Kleisli arrows (i.e. ones which consist of functions a -> m b) don't tend to satisfy this, unless m is a commutative monad
21:14:47 <Cale> So, Hughes, wanting to capitalise on the popularity of monads at the time he wrote his paper, specifically excluded this law.
21:15:01 <Cale> But I think it's actually very important to maintaining sanity when actually working with Arrows
21:15:08 <tikhonjelvis> I can see that
21:15:22 <tikhonjelvis> also, in the little I've played with arrows, monads haven't really come up
21:15:31 <Cale> It ensures that you only have local state, and all the communication between arrow computations is explicit.
21:15:58 <Cale> In that sense, it also behaves a lot like the lumped circuit abstraction in electrical engineering
21:17:26 <Cale> You don't usually expect that electronic components wired in parallel with each other (on separate lines) have crosstalk, even though sometimes maybe that abstraction breaks down because of inductive effects or something.
21:19:07 <tikhonjelvis> well, thanks for the explanation
21:19:22 <tikhonjelvis> a new take on arrows seems very welcome because the original formulation never sat well with me
21:20:03 <Cale> I see this as a first step toward understanding what higher category theory might have to offer to the design of practical libraries for writing programs :)
21:20:23 <tikhonjelvis> certainly sounds promising
21:20:39 <tikhonjelvis> you're thinking of using something like that for FRP?
21:21:30 <Cale> yes, so the FRP library we wrote at iPwn uses a new Arrow library along these lines
21:21:53 <tikhonjelvis> iPwn?
21:23:02 <Cale> The game startup I was working for (and I guess will still work for if it comes out of hiatus at some point -- we have most of a working game engine, we just need a large number of little details taken care of to have a game)
21:23:19 <tikhonjelvis> a game in Haskell, eh? pretty cool
21:23:22 <Cale> yeah
21:23:47 <Cale> We were working on an action RPG for iPhones and other mobile devices
21:24:27 <tikhonjelvis> but never finished it?
21:25:09 <tikhonjelvis> amusingly, that sounds surprisingly similar to a startup I worked at last summer, except with OCaml
21:25:31 <tikhonjelvis> also, by the time I got there, they had given up on actually making a game and were working on tools for WebGL instead :P
21:25:32 <Cale> The simple combat was working pretty well, and we had a bunch of basic AIs of various sorts, and a terrain editor with lots of terrain, and props and forests and towns and such, but the story and RPG aspects weren't there, and we'd have lots of stuff to do to really make the thing complete.
21:26:12 <tikhonjelvis> I imagine writing the story requires a different set of skills than most of the rest of it
21:26:51 <Cale> Well, we had a writer write some things, but it wasn't really integrated into the game :)
21:26:55 <tikhonjelvis> ah
21:27:27 <tikhonjelvis> if you let the programmers write, you get brilliant copy like "Here we see transport portals that have been implemented using magic."
21:27:40 <tikhonjelvis> which is taken directly from the company I mentioned
21:27:45 <Cale> :D
21:29:58 <tikhonjelvis> are you still working with Haskell now?
21:30:02 <Cale> So a highbrow, short way to describe what a monoidal category is, is to say that it's a 2-category with only one 0-cell. 2-categories have a lot of geometric intuition to them -- basically you have these higher dimensional arrows which you can think of as directed 2D sheets, that fit in between parallel 1D arrows.
21:32:08 <Cale> Or, taking the geometric dual of that picture, you can represent objects by 2D regions, arrows by 1D boundaries between them, and then the arrows between arrows become points at which boundaries meet up (where you might draw a bubble and stick a label there)
21:32:17 * hackagebot yesod-platform 1.2.0.1 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.0.1 (MichaelSnoyman)
21:32:28 <Cale> and if you do that right, you get the wiring diagrams that people draw for Arrows :)
21:32:51 <tikhonjelvis> sounds neat, but geometric intuition has never been my forte
21:32:54 <Cale> http://www.haskell.org/arrows/addA.png
21:33:09 <Cale> (http://www.haskell.org/arrows/syntax.html)
21:36:28 <Cale> (the reason you don't have to label the empty space between the wires being that there's only one 0-cell, and when you take this dual, only one 2D region to refer to, so it's not worth mentioning)
21:45:48 <sclv> note of course that applicatives form a version of monoidal categories too
21:46:05 <sclv> with the additional restriction that there's a monoidal functor to them from Hask
21:46:25 <sclv> (which is what gives you "pure" and the whole arr problem all over again)
21:47:14 <arkeet> well, applicatives are supposed to be monoidal functors from Hask to Hask
21:48:00 <sclv> endofunctors on hask
21:48:51 <sclv> but a monoidal functor is between two monoidal categories. one is hask. the other is some subset of hask
21:48:58 <sclv> subcategory rather
21:49:02 <watch> is there are way to more idiomatically represent \x y -> x:5:y ?
21:49:17 <sclv> ?pl \x y -> x : 5 : y
21:49:17 <lambdabot> (. (5 :)) . (:)
21:49:22 <sclv> of course
21:49:43 <watch> i.e. to write a function to interspace every element of an array with the number 5, foldl [] (\x y -> x:5:y)
21:49:44 <watch> heh
21:49:56 <sclv> ?ty intersperse
21:49:57 <lambdabot> a -> [a] -> [a]
21:50:04 <watch> omg
21:50:06 <watch> thank you
21:50:10 <sclv> > intersperse 5 [1,2,3]
21:50:13 <lambdabot>   [1,5,2,5,3]
21:50:19 <tikhonjelvis> do you know about http://www.haskell.org/hoogle/?
21:50:30 <watch> i do, it's been a while since i've touched haskell
21:50:36 <tikhonjelvis> ah
21:50:41 <tikhonjelvis> well, it's a fun tool to use
21:50:42 <ParahSail1n> @src intersperse
21:50:42 <lambdabot> intersperse _   []     = []
21:50:42 <lambdabot> intersperse _   [x]    = [x]
21:50:43 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
22:01:02 <no-n> @src []
22:01:03 <lambdabot> data [] a = [] | a : [a]
22:13:51 <dmwit> Actually, ?src is wrong about intersperse.
22:14:09 <dmwit> > intersperse 5 (3:undefined)
22:14:11 <lambdabot>   [3*Exception: Prelude.undefined
22:14:41 <dmwit> > let intersperse _ [] = []; intersperse _ [x] = [x]; intersperse sep (x:xs) = x : sep : intersperse sep xs in intersperse 5 (3:undefined)
22:14:43 <lambdabot>   *Exception: Prelude.undefined
22:15:36 <dmwit> Usually that doesn't matter, though. =P
22:20:37 <arkeet> > let intersperse _ [] = []; intersperse sep (x:xs) = x : if null xs then [] else sep : intersperse sep xs in intersperse 5 (3:undefined)
22:20:39 <lambdabot>   [3*Exception: Prelude.undefined
22:20:44 * arkeet looks at the real source
22:21:18 <arkeet> ah, basically the same.
22:21:28 <arkeet> well no
22:21:47 <arkeet> basically the same in the sense that you get the same answers.
22:26:04 <zRecursive> "/msg lambdabot @wn <word>" is helpful ! How can i make it work at any time (i.e. not in IRC) ?
22:27:00 <leroux> @wn hello
22:27:02 <lambdabot> *** "hello" wn "WordNet (r) 3.0 (2006)"
22:27:02 <lambdabot> hello
22:27:02 <lambdabot>     n 1: an expression of greeting; "every morning they exchanged
22:27:02 <lambdabot>          polite hellos" [syn: {hello}, {hullo}, {hi}, {howdy}, {how-
22:27:02 <lambdabot>          do-you-do}]
22:27:06 <leroux> Oops, sorry.
22:27:12 <leroux> Wordnet...
22:27:21 <dmwit> Install the "wordnet" package from your distro's repository.
22:27:29 <dmwit> Don't bother with Haskell bindings or anything like that.
22:27:56 <zRecursive> @where wordnet
22:27:57 <lambdabot> I know nothing about wordnet.
22:28:07 <zRecursive> @package wordnet
22:28:07 <lambdabot> http://hackage.haskell.org/package/wordnet
22:28:32 <leroux> zRecursive: I think he may have meant your OS's packages..
22:28:55 <watch> so i want to convert a double to a string but "show" is not enough because for cases where the Double is something like 1.2e6, the string is "1.2e6" but i need it to be "1200000"
22:29:30 <leroux> watch: Type annotations?
22:29:38 <tikhonjelvis> try printf?
22:29:42 <dmwit> watch: import Numeric
22:29:46 <tikhonjelvis> > printf "%f" 1.2e6
22:29:47 <lambdabot>   Ambiguous type variable `a0' in the constraints:
22:29:48 <lambdabot>    (GHC.Show.Show a0)
22:29:48 <lambdabot>     ...
22:29:51 <dmwit> watch: and use showEFloat, showFFloat, showGFloat
22:29:58 <tikhonjelvis> > printf "%f" (1.2e6 :: Double)
22:30:00 <lambdabot>   Ambiguous type variable `a0' in the constraints:
22:30:00 <lambdabot>    (GHC.Show.Show a0)
22:30:00 <lambdabot>     ...
22:30:13 <dmwit> > printf "%f" 1.2e6 :: String
22:30:18 <tikhonjelvis> ah
22:30:19 <lambdabot>   mueval: ExitFailure 1
22:30:19 <lambdabot>  mueval: Prelude.undefined
22:30:25 <tikhonjelvis> umm
22:30:26 <dmwit> > Numeric.showFFloat 1.2e6
22:30:28 <lambdabot>   No instance for (GHC.Real.Fractional
22:30:28 <lambdabot>                     (Data.Maybe.Maybe ...
22:30:29 <tikhonjelvis> anyhow, it works on my system :P
22:30:42 <dmwit> what the heck
22:30:57 <dmwit> > printf "%f" (1.2e6 :: Double) :: String
22:30:59 <lambdabot>   "1200000.0"
22:31:08 <dmwit> > Numeric.showFFloat (1.2e6 :: Double)
22:31:11 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int'
22:31:11 <lambdabot>              ...
22:31:21 <dmwit> :t Numeric.showFFloat
22:31:22 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
22:31:24 <dmwit> ah
22:31:34 <dmwit> > Numeric.showFFloat Nothing 1.2e6 ""
22:31:36 <lambdabot>   "1200000.0"
22:32:10 <tikhonjelvis> Does lambdabot default types different from GHCi?
22:32:36 <dmwit> possibly
22:32:45 <dmwit> ghci might be more willing to believe in IO
22:32:59 <dmwit> > printf "%f" 1.2e6 :: IO ()
22:33:01 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
22:33:01 <lambdabot>    arising from a use of ...
22:33:17 <tikhonjelvis> and more willing to believe in Double?
22:33:27 <dmwit> not really
22:33:27 <tikhonjelvis> > printf "%f" 1.2e6
22:33:30 <lambdabot>   Ambiguous type variable `a0' in the constraints:
22:33:30 <lambdabot>    (GHC.Show.Show a0)
22:33:30 <lambdabot>     ...
22:33:34 <tikhonjelvis> > printf "%f" 1.2e6 :: String
22:33:35 <lambdabot>   "1200000.0"
22:33:40 <tikhonjelvis> oh yeah, never mind
22:33:42 <watch> which is more idiomatic
22:33:49 <watch> printf or showFFloat?
22:33:55 <tikhonjelvis> umm, I'd probably go with printf
22:33:57 <watch> i'd imagine printf
22:33:58 <dmwit> showFFloat is better typed
22:33:58 <watch> yeah
22:34:02 <tikhonjelvis> but I'd feel bad doing it
22:34:21 <Hafydd> :t printf
22:34:21 <tikhonjelvis> mostly because it's something of an ugly throwback to C
22:34:23 <lambdabot> PrintfType r => String -> r
22:35:20 <Hafydd> :t printf "%f"
22:35:22 <lambdabot> PrintfType r => r
22:35:47 <tikhonjelvis> the PrintfType class is what lets printf accept different numbers of arguments
22:35:54 <Hafydd> Existential witchcraft.
22:35:59 <tikhonjelvis> e.g. "printf "%f %d" 1.2 1 :: String
22:36:01 <dmwit> No existentials.
22:36:07 <Cale> No existentials, just type classes
22:36:12 <tikhonjelvis> > printf "%f %d" 1.2 1 :: String
22:36:12 <Hafydd> Oh.
22:36:14 <lambdabot>   "1.2 1"
22:36:28 <tikhonjelvis> it's pretty clever, actually
22:36:34 <tikhonjelvis> but a bit awkward as well
22:37:52 <tikhonjelvis> The trick is that there's an instance of PrintfType which looks like this:
22:37:53 <tikhonjelvis> (PrintfArg a, PrintfType r) => PrintfType (a -> r)
22:38:28 <tikhonjelvis> this is recursion at the type level
22:39:04 <Hafydd> > printf "hello" 1 :: String
22:39:06 <lambdabot>   "hello*Exception: Printf.printf: formatting string ended prematurely
22:39:16 <Hafydd> > :t printf "hello" 1
22:39:18 <lambdabot>   <hint>:1:1: parse error on input `:'
22:39:22 <Hafydd> :t printf "hello" 1
22:39:25 <lambdabot> PrintfType t => t
22:39:27 <tikhonjelvis> yeah, that's one of the problems: formatting errors happen at *runtime*
22:39:33 <Hafydd> It doesn't seem any more type safe than accepting a list of arguments.
22:39:45 <tikhonjelvis> a list wouldn't work very well
22:39:51 <dmwit> Lists are homogeneous.
22:39:52 <tikhonjelvis> because you want to accept different types of arguments
22:40:09 <tikhonjelvis> > printf "%f %d" 1.2 1 :: String
22:40:13 <lambdabot>   "1.2 1"
22:40:15 <Hafydd> Oh, fair point.
22:40:17 <tikhonjelvis> the 1.2 is a Double and the 1 and Integer
22:40:36 <arkeet> > printf "%f %d" 2 1 :: String
22:40:38 <lambdabot>   "*Exception: Printf.printf: bad argument
22:41:00 <tikhonjelvis> that's the defaulting rules being stupid
22:41:12 <arkeet> surely it's printf being stupid
22:41:18 <tikhonjelvis> well, both
22:41:31 <mm_freak> why would the defaulting rules be stupid?
22:41:42 <c_wraith> crap.  I never thought this would happen to me.  But I'm getting a stack overflow and I can't tell why.
22:42:15 <zRecursive> @where lambdabot
22:42:15 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
22:42:17 <tikhonjelvis> well, wouldn't the above have worked if the numbers stayed fully polymorphic?
22:42:33 <tikhonjelvis> hmm, maybe not
22:42:37 <mm_freak> tikhonjelvis: that doesn't make sense…  types disappear when compiling
22:44:17 <tikhonjelvis> yeah, I guess it really is all printf's fault
22:44:55 <tikhonjelvis> I've never seen anyone use printf with a dynamic format string—it's always a string literal
22:45:15 <arkeet> that's how it should always be used.
22:45:30 <zRecursive> @version
22:45:30 <lambdabot> lambdabot 4.2.2.1
22:45:31 <lambdabot> darcs get http://code.haskell.org/lambdabot
22:45:33 <tikhonjelvis> so it would be cool to have it reflected in the type system
22:46:00 <c_wraith> you can use a compile-time printf to guarantee that.
22:46:03 <arkeet> a better printf is like the standard example use of TH
22:46:06 <tikhonjelvis> maybe with something like a reader macro?
22:46:47 <mm_freak> you can make a reasonable printf, even one that takes a string
22:46:59 <arkeet> there was something else though. I don't remember whose thing it was, but shachaf knows.
22:47:04 <mm_freak> but its type would be very different and you would need an extra operator
22:47:18 <tikhonjelvis> how would you get the format information out of the string?
22:47:30 <arkeet> where you'd build a format "string" by a monoid really.
22:47:42 <arkeet> well, function composition.
22:47:46 <tikhonjelvis> yeah, but I want a string literal or something like a string literal
22:47:56 <tikhonjelvis> that then desugars into a monoid or something like it
22:47:58 <arkeet> yeah
22:48:07 <mm_freak> tikhonjelvis: with a type system extension
22:48:16 <tikhonjelvis> which one?
22:48:21 <tikhonjelvis> the type-level string literals?
22:49:02 <mm_freak> RankNTypes
22:49:13 <mm_freak> your portal into dependent types =)
22:49:19 <tikhonjelvis> oh
22:49:26 <tikhonjelvis> I'm not sure exactly how that would work
22:49:36 <mm_freak> let me write an example
22:49:43 <tikhonjelvis> also, I always assumed GADTs were the portal
22:49:56 <arkeet> if you want to get a type-safe printf that parses a string literal, you pretty much have to use TH, I think.
22:49:59 <dmwit> Yeah, GADTs seem much more like a gateway drug than RankNTypes do.
22:50:19 <tikhonjelvis> rank-n types are fairly natural with just normal parametric polymorphism
22:50:19 <dmwit> Also, GADTs seem like the perfect thing to use for a type-safe printf in Haskell.
22:50:37 <tikhonjelvis> not having them by default is one of those stupid compromises with reality
22:50:46 <tikhonjelvis> I am not always happy with reality :/
22:51:07 <arkeet> there are bigger things about haskell to be unhappy about.
22:51:12 <dmwit> printf :: Format t -> t
22:52:12 <tikhonjelvis> than reality, or than printf?
22:52:47 <tikhonjelvis> also, printf isn't the issue, it's just a symptom
22:53:05 <tikhonjelvis> the real issue is a lack of good compile-time metaprogramming
23:02:34 <c_wraith> seriously, does something other than recursive evaluation cause stack overflows in GHC?
23:02:54 <c_wraith> I can't see anything I'm doing that could possibly stack overflow.
23:04:08 <c_wraith> unfortunately, I can't really put the code online, since it's homework for a coursera course.  Makes it even harder to ask about.
23:05:13 <mjrosenb> c_wraith: unfortunately thingslike sum and fold are defined recursively.
23:05:46 <mm_freak> now he left…
23:06:22 <mm_freak> anyway, both GADTs and RankNTypes give you lightweight dependent types
23:06:28 <mm_freak> together i mean
23:06:33 <mm_freak> but you don't always need both
23:06:39 <dmwit> With enough extensions:
23:06:43 <dmwit> printf (Double `Concat` Literal " " `Concat` Int) :: Double -> Int -> String
23:06:49 <c_wraith> concatMap is approximately the only thing I'm using that's recursive.
23:07:00 <c_wraith> and it would be more accurate to call it corecursive
23:07:06 <c_wraith> It's not going to overflow the stack
23:07:39 <dmwit> (And it even works! =)
23:08:50 <mjrosenb> c_wraith: you sure?
23:08:54 <hpaste> dmwit pasted “typed printf lol, so usable” at http://hpaste.org/87394
23:09:06 <c_wraith> oh.  I forgot about the utility function I wrote.  let me double-check it for any retardedness
23:09:20 <mjrosenb> c_wraith: also, I've seen compiling with optimizations eliminate unexpected stack overflows
23:09:38 <c_wraith> I'm using optimizations
23:09:38 <mjrosenb> (usually due to deep recursion due to lazy evaluation)
23:09:43 <mjrosenb> c_wraith: fun!
23:09:52 <c_wraith> No stack overflows should be possible in the helper function, either.
23:10:02 <c_wraith> though it is recursive
23:10:21 <c_wraith> It's tail recursive and uses both of its arguments to figure out what to do.
23:10:30 <c_wraith> That should compile down to a simple loop
23:11:16 * c_wraith checks the core dump for that function again
23:15:14 <atamagawarui> c_wraith: It is my understanding that tail recursion can only help you avoid stack overflows when you use strict evaluation.
23:19:10 <c_wraith> well, I found it.
23:20:08 <c_wraith> One of the paramaters wasn't being used in the conditionals after all. That means two things - it was leaking stack space, and I could rewrite that whole function to get rid of it
23:20:23 <mm_freak> with enough extensions you can write something like:  printf "%s: %i\n" ! "blah" ! 15
23:22:03 <mm_freak> "enough extensions" = RankNTypes
23:22:30 <c_wraith> and here's the problem with implementing attacks on cryptosystems that are more efficient than brute force, but still not great.  When they take 10 minutes, you don't know if there's a bug or just that much work required.
23:22:47 <zRecursive> I have installed /usr/ports/textproc/wordnet, but `wn apple` returns messy things. How can i make it return what lambdabot returns ?
23:23:07 <mm_freak> c_wraith: are you doing a crypto challenge?
23:23:31 <c_wraith> mm_freak: coursera crypto course. Implementing attacks on known weak RSA key construction methods.
23:23:58 <mm_freak> cool, where are they?
23:26:01 <bitonic> is there a good document about the implementation of computable reals?
23:26:11 <c_wraith> mm_freak: it's this course, but coursera schedules rather tightly:  https://www.coursera.org/course/crypto
23:26:31 <centrinia> What are some weak RSA key characteristics?
23:27:07 <c_wraith> centrinia: in this case, the prime factors of the modulus being known to be very close to each other.
23:27:19 <centrinia> Or too far apart. ;)
23:28:02 <centrinia> Wouldn't that be easier to factor?
23:28:18 <dmwit> zRecursive: Perhaps man wn?
23:28:24 <c_wraith> well, if one of them is less than 32 bits, sure.
23:28:37 <mm_freak> centrinia: no, you can attack a key easily if abs (p - q) is small
23:29:19 <zRecursive> dmwit: it is `wn apple -over`, just get it !
23:29:40 <c_wraith> agh.  That wasn't the cause of the stack overflow after all
23:31:07 <mm_freak> c_wraith: thanks, that sounds like a cool challenge
23:33:19 <mm_freak> why do they all start with symmetric stuff?
23:33:27 <mm_freak> i find the asymmetric stuff much more interesting
23:33:44 <c_wraith> because the underlying theory is easier to teach in terms of symmetric
23:34:16 <c_wraith> the course is heavily about the math of cryptosystem properties, and how properties of subsystems add up to nice properties about larger systems.
23:34:34 <c_wraith> It's easier to define almost all of the properties with symmetric primitives
23:34:39 <mm_freak> well, i'll do the matasano challenge first
23:38:18 <bitonic`> uff, the paper that seems to be related to CReal is paywalled and the springer website is broken.
23:42:27 <Araneidae> Is Hayoo! broken at the moment?  Won't do searches for me
23:49:27 <ehamberg> Araneidae: looks like it. :|
