00:00:23 <lightquake> so i have a type synonym FooBar a = Foo (Bar a). i can define an fmap-like, but i can't make FooBar a functor
00:00:31 <lightquake> what do i want to do?
00:01:11 <BMeph> lightquake: Drink more edwardk-flavored Kool-Aid. ;)
00:01:27 <lightquake> BMeph: i'm actually curious what the edwardk solution is
00:01:32 <lightquake> since Foo is actually Table
00:03:11 <Recursive> @ty (<*>)
00:03:12 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
00:04:34 <arkeet> :t liftA2
00:04:35 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
00:05:15 <arkeet> :t liftA2 ($)
00:05:17 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
00:05:37 <arkeet> :t pure
00:05:38 <lambdabot> Applicative f => a -> f a
00:06:54 <arkeet> :t liftA2 const
00:06:55 <lambdabot> Applicative f => f c -> f b -> f c
00:08:04 <arkeet> :t \f -> liftA2 (const f) (pure ())
00:08:05 <lambdabot> Applicative f => (b -> c) -> f b -> f c
00:09:02 <arkeet> :t liftA2 id . pure
00:09:04 <lambdabot> Applicative f => (b -> c) -> f b -> f c
00:17:07 <Codeir> learned about monads today in Javascript(d. crockford), now learning Haskell ;)
00:17:13 <klrr> how does this makes sense?
00:17:14 <klrr> Couldn't match expected type `Either Err Expr' with actual type `Expr'
00:17:44 <klrr> has something happened to ghc beacase if it's an Either Err Expr it should be able to return an Expr without errors
00:18:29 <supki> what
00:18:56 <klrr> supki: what's wrong with it cant i return an Expr if it's of type Either Err Expr ?
00:18:58 <supki> what if it's  Left err ?
00:19:07 <Chousuke> klrr: because the types don't match
00:19:16 <klrr> how so?
00:19:19 <Chousuke> Either e a is not a :P
00:19:23 <arkeet> Codeir: there are no monads in javascript
00:19:46 <Codeir> arkeet: I beg to defer (you can implement them in javascript)
00:19:48 <klrr> Chousuke: but i used "return $ TypeConstructorOfExpr "hello"
00:20:20 <Codeir> ugh *differ
00:20:32 <arkeet> Codeir: no, people have supposedly claimed certain things are monads, but really have no clue.
00:20:34 <arkeet> hi edwardk
00:20:42 <Chousuke> klrr: and I assume that returns an Either? so what is the code you're passing that value to expecting
00:20:56 <Codeir> If it meets the monad axioms then I imagine its a monad.
00:21:21 <edwardk> arkeet: you _can_ implement monads in javascript, its just that almost all of the crap that people say are monads in javascript aren't.
00:21:32 <arkeet> that's what I'm trying to say.
00:21:39 <Codeir> http://www.youtube.com/watch?v=dkZFtimgAcM
00:21:41 <klrr> Chousuke: https://gist.github.com/klrr/5500660
00:21:43 <Codeir> ^ douglas crockford on it
00:21:58 <edwardk> Codeir: doug crockford is completely full of shit on that one
00:22:00 <klrr> Chousuke: the thing is, i tried do the same as in a tutorial, but when i did it myself it doesnt work =x
00:23:36 <fruitFly> addThree x y z = x + y + z  EQUALS addThree = \x -> \y -> \z -> x + y + z  ... Is that because on the right x takes a function that takes a function that takes x y AND z? I'm trying to see it.
00:23:38 <klrr> Chousuke: any idea what's wrong? do i need to use Right/Left type constructs?
00:23:54 <arkeet> Codeir: also, monads are not a Big Deal in haskell
00:24:00 <Chousuke> klrr: eval env pred returns an ErrorOr (which is Either) so you need to match on that.
00:24:37 <edwardk> monads were a big deal in haskell.. in 1993. =)
00:24:51 <klrr> Chousuke: yes and Either Err Expr means it either returns an Err or a Expr, right? and i return an Expr :x
00:25:07 <Chousuke> klrr: no, it returns an Either Err Expr
00:25:20 <hiptobecubic> klrr, no. It means the value will be one of Left Err or Right Expr
00:25:21 <Chousuke> klrr: you can't use that as if it were just an Expr
00:25:45 <hiptobecubic> :t Left "a"
00:25:47 <lambdabot> Either [Char] b
00:25:51 <hiptobecubic> :t Right "a"
00:25:53 <lambdabot> Either a [Char]
00:25:53 <Codeir> "The Haskell programming language is a functional language that makes heavy use of monads, and includes syntactic sugar to make monadic composition more convenient." ;)
00:26:16 <klrr> Chousuke: so how should i write it? im really sry that im spamming question but i dont know :x
00:26:53 <edwardk> Codeir: The man talked for 54 minutes on a topic. It'd be hard to go that long without making one statement that was somehow correct. ;)
00:27:05 <hiptobecubic> > case (Left 1) of Left a -> show a; Right a -> error "NONONONO"
00:27:07 <lambdabot>   "1"
00:27:26 <shachaf> edwardk: I bet I could do it.
00:27:38 <Chousuke> case (eval env pred) of Left err -> ... Right exp -> case exp of Bool ... something like that
00:27:45 <arkeet> I've seen people do it. it's not impossible.
00:27:45 <arkeet> :p
00:28:04 <hiptobecubic> Chousuke, just make two cases for RIght
00:28:22 <Chousuke> hiptobecubic: yeah, that's probably better
00:28:23 <hiptobecubic> Right (Bool True) -> whatever; Right (Bool False) -> whatever else
00:28:46 <shachaf> class Functor m => Monad m where monad :: Either a (m (m a)) -> m a
00:28:50 <hiptobecubic> _ -> error "Apparently this program involves more than bools"
00:30:18 <klrr> Chousuke: eh, i didnt use any Right or Left constructors i but now it works anyway when i binded the result to a variable
00:30:33 <hiptobecubic> I think the hardest part of learning Haskell is believing the compiler when it tells you exactly what the error is.
00:31:05 <Chousuke> klrr: you get the Right/Left stuff because of return.
00:31:10 <hiptobecubic> Or maybe just understanding it when it does
00:31:18 <klrr> Chousuke: nope i didnt before
00:31:25 <klrr> haskell is a mess
00:31:33 <Chousuke> well you will now because you're using the Either type :P
00:32:27 <Chousuke> Was your code written without Eithers first?
00:33:04 <hpaste> “Dharmender Kumar” revised “Power Line Filter in Delhi”: “Power Line Filter in Delhi” at http://hpaste.org/87057
00:33:21 <klrr> Chousuke: i dont understand anything, actually i got too low IQ for haskell but since you should stick with one language when you learn programming and haskell is the one i know most i have to continue :x
00:33:52 <Chousuke> klrr: You need to think of this as what the types allow you to express. An Expr is never not an Expr. Its type guarantees that
00:34:12 <hiptobecubic> klrr, it helps to have paper around when you're programming
00:34:27 <Chousuke> klrr: But Either Err Expr is a type that can have values of both Left someerror and Right someexpr
00:34:57 <Chousuke> the Left and Right are basically tags that distinguish between the options
00:35:23 <Chousuke> so when dealing with values of any Either a b type, you'll need to match on those
00:35:27 <klrr> Chousuke: i know but why doesnt haskell not just let me return one of those types why do i need to think if im returning the logical value
00:35:39 <Chousuke> klrr: because that would be magic
00:35:42 <klrr> no
00:35:47 <hiptobecubic> klrr, i'm not even sure what you meant there
00:35:52 <klrr> i mean
00:35:57 <klrr> if I use Either Err Expr
00:35:58 <hiptobecubic> return one of those types? the Err or the Expr, you mean?
00:36:02 <klrr> and if i return an Expr
00:36:04 <hiptobecubic> ah
00:36:05 <klrr> i dont want an error
00:36:09 <klrr> i want that expr
00:36:11 <klrr> instead
00:36:19 <hiptobecubic> but you're looking at this from the wrong perspective
00:36:19 <Chousuke> klrr: and what would it mean to Return Either Err Expr where Expr is required and the value is instead an Err?
00:36:45 <hiptobecubic> every function is self contained and knows *nothing* about the rest of the world
00:36:47 <klrr> Chousuke: i dont understand what you mean
00:37:03 <klrr> if i wanna return an error i simply use throwError, at least that was i though
00:37:18 <Chousuke> klrr: you're returning Expr, but the value is Left "ERROR!". what should happen?
00:38:00 <Chousuke> klrr: remember, any code dealing with just Exprs doesn't know what to do with Eithers
00:38:00 <hiptobecubic> klrr, a value can only have one type. Ever. Period.
00:38:02 <klrr> Chousuke: i dont know what you mean, i dont want any Left or Right, i want to return either Err or Expr, i can define fibonacci without error checking required
00:38:20 <Ghoul_> "actually i got too low IQ for haskell" -- some guy above
00:38:22 <Ghoul_> this is my feel man.
00:38:37 <klrr> how do i define a functiona that's return either Err or Expr then? (not using Either)
00:38:38 <Chousuke> klrr: but you can't return two different types from a function.
00:38:48 <Chousuke> you can't
00:38:51 <hiptobecubic> klrr, so if you want to be able to return two different types of things, you have to make a new type that says "I'm a blob that has either an A or a B in it, you'll have to ask me which one when I arrive"
00:38:52 <klrr> why not?
00:38:57 <Chousuke> because it's not possible
00:39:06 <Chousuke> it's just the way haskell works
00:39:06 <klrr> then how should you write a useful program in haskell?
00:39:09 <hiptobecubic> klrr, you can't do it in any other language either
00:39:16 <Chousuke> klrr: use more expressive types
00:39:37 <klrr> okey so if i restructer the question, how do i make this work? how do i use this Either shit?
00:39:39 <Chousuke> klrr: if you are going to return *either* an error or a result, your type should reflect that
00:39:54 <klrr> i dont understand why you mean
00:40:07 <klrr> i do return an error if something goes wrong
00:40:07 <Chousuke> klrr: maybe it's easier to understand with Maybe :P
00:40:19 <klrr> maybe is eay
00:40:21 <klrr> logical
00:40:24 <klrr> Either is mess
00:40:27 <hiptobecubic> klrr, you can only expect one "kind" of thing
00:40:46 <Chousuke> klrr: maybe is just either where the left type has only one value
00:40:51 <Chousuke> ie. Left Nothing
00:40:54 * hackagebot hledger-irr 0.1.1 - computes the internal rate of return of an investment  http://hackage.haskell.org/package/hledger-irr-0.1.1 (JoachimBreitner)
00:41:26 <klrr> Chousuke: no Maybe works, Either dont, well i dont know how it works, how do i use it? types doesnt help me
00:41:36 <Chousuke> you deal with eithers the exact same way as with Maybe
00:41:41 <hiptobecubic> klrr, do you know any other languages?
00:41:49 <klrr> a little bit of C and Scheme
00:41:52 <h4199> Handle /both/ cases, that is all
00:42:18 <hiptobecubic> klrr, in C, do you know what a struct is?
00:42:26 <klrr> hiptobecubic: kind of
00:42:43 <Chousuke> klrr: you should really come up with a simpler example to explain Either to yourself
00:42:46 <hiptobecubic> it's a "box" that has some data in it that you can access like "mybox.data1"
00:43:13 <Chousuke> klrr: it's a fundamental construct if you want to write haskell programs that have error handling
00:43:22 <klrr> Chousuke: i want to know how i return an error or an expression, i dont care about either i care about what i should type for code to make it work
00:43:34 <klrr> how should i write it?
00:43:35 <Chousuke> klrr: you should care!
00:43:36 <klrr> i need examples
00:43:45 <hiptobecubic> klrr, so imagine a struct like  struct { int a; float b }.  You can access the integer by doing  "myval.a" or the float by doing "myval.b"
00:43:51 <Chousuke> the type system is there to help you write correct code
00:43:53 <Chousuke> use it
00:43:57 <klrr> i cant understand something with Type Theory PHD student stuff, i need code examples
00:43:59 <hiptobecubic> Chousuke, we're getting there
00:44:20 <hiptobecubic> klrr, structs, do you understand how they work?
00:44:24 <klrr> and i have a code example and i used either the exactyl same way but in my code it doesnt work beucase GHC hates ,me
00:44:29 <hiptobecubic> not the implentation or anything, just how they are used
00:44:36 <klrr> hiptobecubic: yes i understand them
00:44:38 <hiptobecubic> implementation*
00:44:43 <h4199> http://book.realworldhaskell.org/read/error-handling.html
00:44:46 <klrr> but i cant really use them i dont remember exact syntax
00:44:46 <hiptobecubic> klrr, ok so if you write a function that expects to get that struct
00:44:50 <h4199> Scroll down for Either
00:45:08 <Chousuke> klrr: I think that sort of thinking is not helping at all. It's not difficult or complicated, it's just different from what you're used to.
00:45:30 <hiptobecubic> the function will expect to get a box with a float or an int in it, and it will do some operations to get the float or the int by doing "myval.a" or "myval.b" or whatever it is
00:45:46 <klrr> okey
00:45:52 <hiptobecubic> klrr, would you expect that you could just pass the function an integer directly?
00:45:54 * hackagebot indexed-free 0.1 - indexed monads for free  http://hackage.haskell.org/package/indexed-free-0.1 (FumiakiKinoshita)
00:46:01 <klrr> hiptobecubic: no
00:46:04 <hiptobecubic> klrr, why?
00:46:10 <klrr> hiptobecubic: beaucase it's not logical
00:46:13 <klrr> hiptobecubic: but
00:46:35 <klrr> hiptobecubic: i asked how i can return a Either, i tried using return it doesnt work, is there any other function which can return an either?
00:46:50 <Chousuke> klrr: you can use the constructors
00:46:55 <klrr> i did
00:47:04 <klrr> return $ ConstructorOfExpr value
00:47:19 <Chousuke> that's not where your error is
00:47:29 <Chousuke> that does return an Either
00:48:17 <Chousuke> your error is in the part of eval where you're supposed to be deconstructing the Either but you're treating it as if it were only an Expr
00:48:33 <klrr> i used throwError for the errors
00:48:42 <Chousuke> yeah, that's not the problem either.
00:49:45 <klrr> https://gist.github.com/klrr/5500756 i dont get what the problem is
00:49:49 <Chousuke> the problem is in the case (eval env pred) ... expression. you need to think about what (eval env pred) produces
00:50:02 <klrr> it produces Either
00:50:05 <klrr> so should i use
00:50:06 <klrr> Right
00:50:11 <klrr> in in the case?
00:50:14 <Chousuke> yes
00:50:35 <klrr> im stupid and doesnt deserve to live *facepalm* sry for being an idiot :/
00:50:50 <Chousuke> don't worry about it.
00:51:46 <Chousuke> When you encounter problems like this again, just make sure you're working with the types that you expect.
00:52:33 <klrr> haskell is awesome for awesome people, horrible for horrible xD
00:52:34 <hiptobecubic> klrr, are we clear on what "Either a b" means now?
00:52:41 <klrr> yes
00:52:51 <Chousuke> klrr: Haskell makes you awesome if you stick with it
00:53:03 <klrr> the problem was i was stupid, i forgot that it returned with Right or Left
00:53:11 <hiptobecubic> Not either a or b, but a single Either a b, which might be spelled "Left a" or "Right b"
00:53:12 <hiptobecubic> right
00:54:05 <h4199> left
00:54:06 <Chousuke> klrr: I can certainly understand your viewpoint though. Some days I don't understand half of what these guys are talking about
00:54:19 <Chousuke> but that just means there's more to learn
00:54:54 <klrr> may i just ask one more question, if i want to pass an Right Expr to a function that expects Expr is there a convinient way to extract an the Expr out of it so i dont have to type x2 in my code?
00:55:57 <hiptobecubic> val >>= funcThatWantsExprandReturnEitherErrExpr
00:56:34 <hiptobecubic> fmap func val  -- (Will change the value without unwrapping it)
00:56:42 <klrr> oh thanks!
00:56:45 <hiptobecubic> if func is Expr -> Expr
00:56:49 <Chousuke> oh yeah fmap is awesome
00:56:51 <klrr> >>= and fmap is good
00:57:02 <klrr> and <$> ofc :D
00:57:06 <Chousuke> that's just fmap
00:57:09 <Chousuke> :)
00:57:09 <klrr> and <*> is cool
00:57:13 <klrr> i know :P
00:57:14 <hiptobecubic> fmap (+1) (Right 3)
00:57:18 <hiptobecubic> > fmap (+1) (Right 3)
00:57:20 <lambdabot>   Right 4
00:57:30 <klrr> thanks for all help btw !
00:58:46 <Chousuke> With haskell it seems it takes a while after you start before you really begin to work in a functional way, and using things like fmap and >>= becomes second nature.
00:59:47 <Chousuke> You basically just go "I'm writing too many case expressions, there must be a better way"
01:00:32 <klrr> eval nullEnv (List [Sym "quote", Num 2, Num 5, Num 3])
01:00:39 <klrr> Right (List [Sym "quote",Num 2,Num 5,Num 3])
01:00:40 <klrr> :D
01:00:55 * hackagebot data-store 0.3.0.3 - Type safe, in-memory dictionary with multidimensional keys.  http://hackage.haskell.org/package/data-store-0.3.0.3 (PetrPilar)
01:01:47 <klrr> eval nullEnv (List [Sym "if", Bool True, Num 1, Num 2])
01:01:54 <klrr> Right (Num 1)
01:01:56 <klrr> :D
01:02:03 <klrr> time for food brb
01:02:09 <hiptobecubic> :t Right . flip const
01:02:11 <lambdabot> a -> Either a1 (c -> c)
01:02:29 <hiptobecubic> hm
01:02:34 <Hail_Spacecake> I want to implement tetris in haskell as a learning exercise
01:02:39 <Hail_Spacecake> what is the best way to display graphics?
01:03:21 <aoshi> can someone help me in a pm with a terribly newbie question?
01:03:52 <aoshi> it's too beginner to be displayed before the masses
01:04:05 <Hail_Spacecake> why not post it anyway?
01:04:17 <aoshi> ok
01:04:36 <aoshi> fact :: Integral a => a -> a
01:04:42 <aoshi> fact 0 = 1
01:04:53 <aoshi> fact n = n * fact (n - 1)
01:04:54 <aoshi> ok...
01:05:13 <aoshi> now if I want to compile this and have it compute, say, fact 10, how do I do that?
01:05:17 <aoshi> I keep fooling with main
01:05:23 <aoshi> and I can't decipher the error messages...
01:05:28 <Hail_Spacecake> make a file with that, ideally ending in .hs
01:05:35 <Hail_Spacecake> then open up ghci in the directory the file is in
01:05:39 <Hail_Spacecake> and type :l <filename>
01:05:50 <Hail_Spacecake> ghci should tab-complete the filename, and I'm not sure if the .hs is strictly necessary
01:06:07 <h4199> or write: main = putStrLn (fact 10)
01:06:29 <h4199> and compile with ghc --make filename.hs
01:06:30 <aoshi> usually I'm in linux, but not atm, I'd want to be able to do ./name after compiling and have it spit out the number to std out
01:06:42 <supki> s/putStrLn/print/
01:06:48 <h4199> then run filename.exe
01:06:54 <Hail_Spacecake> then you'll need to put what h4199 said in the file
01:07:12 <aoshi> blarg, I knew it was something small
01:07:21 <aoshi> I tried main = print fact 10 before
01:07:23 <aoshi> oops
01:07:26 <aoshi> thank you for the help
01:07:36 <Chousuke> heh
01:15:55 * hackagebot data-store 0.3.0.4 - Type safe, in-memory dictionary with multidimensional keys.  http://hackage.haskell.org/package/data-store-0.3.0.4 (PetrPilar)
01:19:32 <Hail_Spacecake> so, is there a good library to use in haskell
01:19:38 <Hail_Spacecake> for something like tetris that needs a simple gui?
01:23:05 <arkeet> well, there are bindings to gtk and wxwidgets, you could use some opengl thing (through glfw or glut or whatever), or
01:23:11 <arkeet> there's stuff like gloss, I guess
01:23:26 <hiptobecubic> i would think gloss, but i don't know
01:23:29 <hiptobecubic> maybe just sdl?
01:23:51 <arkeet> sure, bunch sdl together with glfw and glut.
01:26:01 <hiptobecubic> is there a good "tui" library in haskell?
01:26:14 <hiptobecubic> like urwid in python?
01:27:40 <arkeet> I dunno
01:27:47 <arkeet> there's vty if you want to do console stuff
01:28:14 <arkeet> but urwid sounds like it does more
01:28:37 <arkeet> oh what do you know, there's a vty-ui
01:30:56 * hackagebot directory-layout 0.3.1.0 - Declare, construct and verify directory layout  http://hackage.haskell.org/package/directory-layout-0.3.1.0 (MatveyAksenov)
01:32:29 <arkeet> hiptobecubic: so yeah, vty-ui sounds like something you'd want?
01:32:42 <hiptobecubic> checking
01:37:12 <arkeet> looks pretty cool actually, I might use it for a future project
01:37:19 <arkeet> thanks :)
01:37:46 <hiptobecubic> Boy i really love it when people set their dependencies as the latest versions of everything for no reason
01:38:31 <arkeet> eh? =(
01:39:15 <hiptobecubic> looking a github project using vty-ui
01:39:39 <arkeet> ah
01:40:14 <hiptobecubic> and LambdaCase
01:49:48 <hiptobecubic> this one's pretty good: https://github.com/jtdaugherty/vty-ui
01:49:52 <hiptobecubic> oops, no tthat :D
01:50:09 <hiptobecubic> here it is: https://github.com/glguy/vty-samegame
01:51:13 <arkeet> let's look
01:53:09 <hiptobecubic> there's no way to quit apparently
01:53:12 <hiptobecubic> but the game is nicely done
01:53:17 <hiptobecubic> animated even :)
01:53:58 <arkeet> you quit with esc
01:54:04 <arkeet> like it says =)
01:54:36 <hiptobecubic> ain't nobody got time for no readin'
01:54:59 <hiptobecubic> it's bad enough this thing uses the arrows instead of hjkl
01:55:19 <arkeet> haha
01:55:20 <latermuse> i make all my rogue-likes in haskell with hjkl movement
01:56:31 <shachaf> hjklyubn
01:57:30 <shachaf> arkeet: Thanks to you, I'm going to have to do this Core-diving and benchmarking thing myself!
01:57:35 <shachaf> Hope you're pleased with yourself.
01:57:39 <arkeet> =)
01:58:09 <arkeet> core diving? is that the thing they do in that film The Core?
01:59:08 <maukf> coregex
01:59:17 <shachaf> haukf
02:07:27 <danr> hiptobecubic: think of the dvorak users! you should obviously have htns movement
02:10:15 <hiptobecubic> danr, they are used to remapping their keys. They'll live :)
02:12:07 <shachaf> Hah, GHC will drop quotes around a thing whose name ends with a '?
02:12:16 <shachaf> Map.hs:93:37: Not in scope: `M.insertWith'
02:12:19 <shachaf> Map.hs:99:38: Not in scope: M.insertWith'
02:12:25 <ion> ಠ
02:15:52 <quicksilver> cute, shachaf
02:16:16 * quicksilver things it should switch to guillemots
02:16:26 <quicksilver> Not in scope: <<M.insertWith'>>
02:16:34 <quicksilver> alternative sea-birds available on request.
02:18:24 <ion> “M.insertWith'” «M.insertWith'» 「M.insertWith'」
02:20:02 <maukf> "M.insertWith'"
02:21:11 <ion> Any quotation is rather redundant in that message, though.
02:22:04 * shachaf notes that his laptop is a terrible benchmarking machine.
02:23:04 <arkeet> cpu frequency scaling does mess things up, doesn't it.
02:23:44 <arkeet> shachaf: can't you set it to stay on the max frequency?
02:23:52 <shachaf> Also having lots of other processes running.
02:23:59 <arkeet> that would do it too.
02:27:16 <shachaf> OK, I'm making a module Data.Map.New which I was hoping would reëxport a bunch of things from Data.Map
02:27:50 <shachaf> So I import qualified Data.Map as M; lookup = M.lookup, and export lookup. It comes out much slower.
02:28:00 <shachaf> Even if I INLINABLE or INLINE it.
02:28:04 <ion> Also make Data.Map.New.OldInstead which reëxports Data.Map verbatim.
02:28:08 <shachaf> Is there an obvious reason it should behave that way?
02:30:00 <hiptobecubic> Data.Map.New.JustKidding.ActuallyOld.Refactor.Types.Internal.Map
02:31:58 <arkeet> hiptobecubic: but module names should be singular, so it ought to be Data.Map.New.JustKidding.ActuallyOld.Refactor.Type.Internal.Map
02:32:19 <h4199> @src Data.Map.New.JustKidding.ActuallyOld.Refactor.Type.Internal.Map
02:32:19 <lambdabot> Source not found.
02:33:44 <ion> shachaf: I don’t know why that’s slower, but you could add M.lookup to your export list instead.
02:34:06 <shachaf> ion: Yes, but I'm going to be writing my own version.
02:34:18 <shachaf> I want to be able to switch back and forth between them in .New.
02:34:37 <hiptobecubic> arkeet, "Types" is pretty common though.
02:34:58 <arkeet> explain Control.Lens.Type then
02:35:44 <shachaf> That's for the type "Lens".
02:35:50 <Spockz_> Is there a way to bootstrap my own Ord instance with the one generated by GHC? I have to heavily alter the code that is given by -ddump-deriv. Is there a better/faster way?
02:35:51 <shachaf> Or it was originally.
02:36:10 <shachaf> I.e. Control.Lens.Traversal for Traversal, Control.Lens.Type because edwardk doesn't like repeating himself.
02:37:07 <hiptobecubic> Spockz_, if you have to heavily modify it, what good will it do to have the original?
02:37:33 <shachaf> arkeet: Ugh, what's going on here?
02:37:35 <shachaf> The Core is the same.
02:37:38 <arkeet> haha
02:37:50 <Spockz_> hiptobecubic: I have to modify it to get it to compile, add semi-colons, removing references to GHC internal types the lot
02:37:59 <shachaf> arkeet: This is why I pay *you* to do these things.
02:38:08 <arkeet> how much, exactly, do you pay me?
02:38:15 <Spockz_> hiptobecubic: So the essence of the Ord instance doesn't change
02:38:20 <shachaf> Obviously not enough.
02:38:21 <hiptobecubic> Spockz_, oh. I don't know
02:38:25 <hiptobecubic> Seems unlikely though
02:38:31 <arkeet> shachaf: I agree.
02:38:54 <arkeet> are you sure it's actually slower?
02:39:08 <shachaf> That's what the criterion benchmark is saying.
02:39:23 <arkeet> the benchmark code compiles to the same core?
02:39:24 <shachaf> I consistently get ~+170% for one version and ~+0% for the other.
02:39:29 <shachaf> It seems to.
02:39:43 <arkeet> wait
02:39:45 <arkeet> which one is slower?
02:40:01 <shachaf> The version that has "lookup = M.lookup" rather than reëxporting the entire module.
02:40:09 <arkeet> weird
02:40:17 <shachaf> It would've been weirder the other way around...
02:40:37 <arkeet> I don't know.
02:40:41 <arkeet> it would have still been weird, for sure.
02:41:13 <arkeet> is the benchmark code in the same module as your lookup?
02:41:19 <shachaf> No.
02:41:20 <arkeet> (I have no idea why this would matter)
02:41:25 <arkeet> of course not.
02:41:26 <shachaf> It would matter because of inlining.
02:41:33 <shachaf> But I added an INLINE pragma.
02:41:34 <arkeet> (that's why I asked)
02:41:50 <shachaf> Hmm, now the effect seems to be gone.
02:41:54 <shachaf> Or not.
02:42:08 <shachaf> Now it's different.
02:42:10 * shachaf sighs.
02:43:13 <shachaf> OK, I'll just try the following approach: Not caring.
02:44:01 <shachaf> Ugh, it's back.
02:44:05 * shachaf is no good at this apathy thing.
02:47:16 <osfameron> try harder!
02:48:02 <arkeet> shachaf: still on the laptop?
02:49:22 <shachaf> Yes.
02:49:34 <shachaf> But it works too reliably when I switch back to reëxporting the module to blame it on that.
02:50:43 <arkeet> weird.
02:51:53 <Arrmand> Is there something esoteric about using where with guards? It's complaining me about the = of the second where condition, if I have more than one, no matter what they are or if I switch them around... Learn You A Haskell says to keep them indented correctly, and I have done that exactly like in the book
02:52:13 <maukf> Arrmand: less vague plz
02:52:22 <maukf> what's your code? what's the error message?
02:52:26 <maukf> @hpaste
02:52:26 <lambdabot> Haskell pastebin: http://hpaste.org/
02:52:47 <Arrmand> => what is the correct syntax for using "where" with more than one line
02:52:57 <maukf> what's your code? what's the error message?
02:53:32 <Botje> Arrmand: you wouldn't be mixing spaces and tabs, would you?
02:54:01 <maukf> the syntax for 'where' is 'where' BLOCK
02:54:24 <maukf> and BLOCK = '{' decl* '}'
02:54:40 <maukf> except 'where' also triggers layout
02:54:52 <Eduard_Munteanu> Heh.
02:55:12 <Eduard_Munteanu> maukebnf
02:56:17 <Arrmand> Hmm, it seems to work if I drop the first declaration onto the line after where, unlike in the book
02:56:21 <Arrmand> Oh well, *shrugs*
02:57:26 <maukf> Arrmand: so are you going to show your code or not?
02:59:32 <quicksilver> it will be indentation, Arrmand
02:59:40 <quicksilver> where foo = blah
02:59:49 <quicksilver>       bar = blah -- exactly six more spaces
03:00:04 <quicksilver> to make the 'f' of foo line up with the 'b' of bar.
03:00:22 <shachaf> {-hi-}bar = blah
03:00:22 <Elision> Unexpected parallel statement in a list comprehension
03:00:27 <Elision> bah! what!
03:00:43 <shachaf> What, indeed!
03:00:51 <shachaf> I recommend that you follow maukf's advice.
03:00:59 <Arrmand> Oh sorry maukf, well I got it sorted out now, and it's kind irrelevant anyway as the content didn't matter
03:01:03 <maukf> Elision: too many |
03:01:33 <shachaf> Arrmand: It is not irrelevant to learning Haskell, if that's your goal. Something behaved in a way you didn't expect. Figure out why.
03:02:44 <Arrmand> Good point
03:03:09 <Arrmand> I tried quicksilver's advice and instead of using a tab and two spaces, used exactly six spaces, and now it works
03:03:13 <shachaf> Hmm.
03:03:23 <Arrmand> I dont' think that makes much sense, but I acknowledge that languages sometimes have obscure stuff like this
03:03:26 <shachaf> Aha.
03:03:26 <arkeet> yes, haskell puts tab stops at 8 spaces.
03:03:33 <arkeet> so, never use tabs.
03:03:40 <shachaf> Tabs behave like tabs. Tabstops are every 8 columns.
03:03:55 <quicksilver> the simple solution is never use tabs
03:03:58 <shachaf> Don't use tabs. But if you do use tabs, learn how tabs work.
03:04:09 <arkeet> but never use tabs
03:04:12 <arkeet> @where style
03:04:12 <lambdabot> http://urchin.earth.li/~ian/style/haskell.html http://snapframework.com/docs/style-guide
03:04:18 <quicksilver> if you like using tabs, then always putting a newline after every layout-introducer (like where) makes it easier to use tabs and remain sane.
03:04:23 <Elision> maukf: herp
03:04:51 <shachaf> Elision: Also: If you get an error from code, please post both the code and the error. :-)
03:05:09 <Arrmand> This is why I wouldn't mind the language requiring {} and ignoring whitespace, instead of indentation strangeness
03:05:09 <Elision> I figured it out as I was copying the code >_>
03:05:26 <maukf> Arrmand: you're free to use {} and ignore whitespace
03:05:32 <Arrmand> I am?
03:05:36 <maukf> of course
03:05:37 <Arrmand> Sweet! :D
03:05:48 <maukf> this isn't python :-)
03:05:51 <shachaf> Adding an INLINE pragma to a function that's only used once makes it compile into worse Core. :-(
03:05:55 <maukf> TMTOWTDI
03:06:00 <Eduard_Munteanu> @arrmand
03:06:18 <lambdabot> Unknown command, try @list
03:06:20 <arkeet> I find layout nicer to write and look at though.
03:06:20 <arkeet> well, mostly look at.
03:06:20 <arkeet> while writing.
03:06:27 <Arrmand> Eduard_Munteanu: Put a space there
03:07:17 <arkeet> time to sleep.
03:24:24 <djcoin> What do you think about Clojure ? Immutability and typing (optional with https://github.com/clojure/core.typed inspired by typed racket) seems to approach in some way haskell
03:26:27 <zomg> djcoin: I did some coding in it, seems decent. Easier to get started with than haskell for sure, but I find haskell more interesting
03:28:36 <djcoin> zomg: I am a beginner in haskell and clojure. I'm tired of programming without types and haskell seems to be a gem. But laziness/space leaks makes me worried :s
03:31:28 * hackagebot yesod-platform 1.2.0 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.0 (MichaelSnoyman)
03:31:30 * hackagebot hledger-interest 1.4.3 - computes interest for a given account  http://hackage.haskell.org/package/hledger-interest-1.4.3 (PeterSimons)
03:31:48 <nebnesknarf> djcoin: yea, but lazyness is soooo cute
03:32:42 <zomg> djcoin: if you want to learn more new concepts and other useful things I think I'd go with haskell :)
03:33:04 <zomg> I'm not a huge pro either and haven't really had any kind of issues with laziness or space leaks or anything
03:33:12 <djcoin> nebnesknarf: can't fight back with this :)
03:33:44 <djcoin> zomg: yeah I already read tuts about haskell (monads etc. are okay now - but not transformers yet ;)) - reading real world haskell now
03:34:00 <djcoin> I'm a bit worried about debugging though - like over optimization + laziness
03:37:32 <quicksilver> debugging is 'interesting' or painful in all languages, for different reason
03:37:55 <quicksilver> certainly memory leaks can be a pain in long-running haskell programs (as they can be in long-running java, python, perl programs)
03:37:58 <shachaf> Wait. Data.Map.insertWith' is different from both Data.Map.{Lazy,Strict}.insertWith?
03:38:04 <shachaf> But it's deprecated in favour of the latter?
03:38:36 <quicksilver> you have to balance out the particular painful parts against the possible benefits of using the language, it's quite hard to do that equation without trying them all a bit.
03:40:46 <MOMI> Hi has anyone this paper available
03:40:47 <MOMI> http://runtime.bordeaux.inria.fr/shenry/papers/HS_FunctionalHetero.pdf
03:41:00 <MOMI> I can not find it anywhere
03:43:59 <quicksilver> MOMI: do you know its full name?
03:45:19 <djcoin> quicksilver: How difficult is it to track memory leaks ?
03:47:27 <quicksilver> that's a hard question to answer. I've never had one I couldn't find, in haskell. I have in other languages.
03:47:41 <quicksilver> haskell's heap profiling tools are quite good.
03:48:19 <quicksilver> MOMI: no, that seems to be the only copy :( http://hgpu.org/?p=6193
03:48:24 <quicksilver> you might just have to ask the author.
03:55:07 <MOMI> Thanks will make a website archive for all haskell papers books and tutorials
04:02:41 <MOMI> What sounds better http://archive.haskell.com/ or the thehaskellarchives.com  or  thehaskellarchive.com haskellarchives.com
04:03:01 <MOMI> gonna register the name
04:04:14 <shachaf> Where does Data.Map.insertLookupWithKey' behave differently from Data.Map.Strict.insertLookupWithKey?
04:05:53 <Elision> so how can I reasonably step through a complicated where clause
04:06:05 <Elision> in debugging
04:06:42 <nebnesknarf> shachaf: the docs say Data.Map.insertLookupWithKey' is deprecated in favour of Data.Map.Strict.insertLookupWithKey, so they should do the same
04:07:16 <shachaf> nebnesknarf: No. Read the rest of that paragraph. :-)
04:08:51 <nebnesknarf> shachaf: oops, just did that
04:09:04 <nebnesknarf> shachaf: but now i do not understand your question
04:09:58 <shachaf> Can you give me an example of using the two where they behave differently?
04:12:35 <MOMI> how about haskellhub.net
04:13:50 <nebnesknarf> shachaf: No. I think the extra comment in the docs is bogus, since insertLookupWithKey unconditionally inserts the new value, so it must always be evaluated (to WHNF). At least this is how I understand the docs.
04:14:42 <shachaf> nebnesknarf: Yes, that's what I thought.
04:14:44 <shachaf> But look at the code:
04:14:45 <shachaf> -- We do not reuse Data.Map.Strict.insertLookupWithKey, because it is stricter -- it
04:14:48 <shachaf> -- forces evaluation of the given value.
04:15:11 <shachaf> Maybe this doesn't apply to insertLookupWithKey but does apply to some other ' functions?
04:15:35 <shachaf> Or maybe not.
04:16:37 <shachaf> Oh, I see.
04:18:59 <shachaf> Oh...
04:19:09 <shachaf> 0.5.0.0 is different from 0.5.2.1 :-(
04:19:19 <shachaf> That's why my tests weren't working.
04:20:19 <nebnesknarf> shachaf: You do? I don't. AFAICS they could replace it with the version from Data.Map.Strict.
04:20:23 <MOMI> Any suggestions?
04:21:01 <shachaf> nebnesknarf: No. Read the comment above.
04:21:06 <shachaf> -- We do not reuse Data.Map.Strict.insertWith, because it is stricter -- it forces evaluation of the given value. Some people depend on the original behaviour, which forces only the key and the result of combining function. Particularly, people use insertWith' as a strict version of adjust, which requires to use undefined in the place of the value.
04:21:43 <shachaf> If you give undefined as the value, and it's found in the Map, but your function isn't strict in it, then you won't get _|_.
04:22:07 <nebnesknarf> shachaf: Ahhhh, I completely overlooked the combining function. You/they are right.
04:22:40 <no-n> when I have :set +s in ghci, and type 5 and press enter, why does it say 1069616 bytes? what does that mean exactly?
04:23:19 <shachaf> nebnesknarf: But they were wrong in 0.5.0.0, which is what I was testing with. :-)
04:23:37 <shachaf> Presumably that many bytes were allocated.
04:24:17 <hpc> not all of those bytes will be resident at the same time, typically
04:24:39 <hpc> and i think that number is high because of some RTS initialization
04:24:41 <no-n> seems like a lot of bytes for just an integer
04:24:50 <nebnesknarf> shachaf: guess it was a bug and they fixed it in the later version
04:24:51 <hpc> successive runs of 5 yield smaller numbers
04:24:54 <hpc> and occasionally 0
04:25:34 <hpc> the first lesson everyone learns about ghci is that it lies in everything it does
04:25:46 <shachaf> An integer and a bunch of work related to it.
04:25:56 <no-n> should I just not use +s?
04:25:58 <hpc> an Integer, rather
04:26:25 <hpc> no-n: it's useful for longer calculations
04:26:37 <hpc> but yes, if you really care you will do profiling
04:27:15 <nebnesknarf> shachaf: the profileration of all these map functions that combine other functions in a more efficient way smells bad to me
04:27:18 <hpc> no-n: hopefully you will also notice that it doesn't actually take 0.04 seconds to make an Integer, either ;)
04:27:31 <no-n> where can I learn how to do profiling?
04:27:40 <hpc> RWH has a good chapter on it
04:27:45 <no-n> hehe, well yeah
04:27:51 <no-n> ah, neato
04:27:55 <hpc> it might even still be relevant to new ghc!
04:28:07 <no-n> ;s
04:28:09 <nebnesknarf> There must be a way to optimize this automatically
04:28:09 <shachaf> nebnesknarf: I have one function that generalizes all of them!
04:29:44 <nebnesknarf> shachaf: cool, now implement all the others a specialized versions of the most general one and add some ghc reweite rules, then send a patch ;-)
04:29:58 <nebnesknarf> s/reweite/rewrite/
04:31:55 <nebnesknarf> shachaf: or maybe just see if ghc already optimizes them enough (with -O2)
04:57:28 <quchen> Morning everyone! I have a simple question: what would *you* like about the change "Applicative => Monad"? I think now that the Haskell 2014 committee has been formed, it may be an excellent time to propose this change again. However, a strong case would be desirable. I'll basically write it all issues up in a gist and then make a mailing list post out of that.
04:58:36 <quchen> The usual arguments are the huge amount of redundancy in the libraries (fmap = liftA = liftM etc), the silly type sigs you get when using fmap in monadic code, and how it confuses everyone getting into Haskell.
04:59:51 <quchen> So if you have specific issues or comments about how this change would be good or not good that you would like to discuss before it's thrown out to the mailing list arena I'd like to hear about them.
05:01:45 <nebnesknarf> quchen: i think it is just The Right Thing to do, and everyone agrees with that
05:01:48 <quchen> I haven't given much thought to other libraries yet except Traversable, where sequence = sequenceA and traverse = mapM
05:02:09 <nlogax> quchen: I haven't used Applicative very much, but I think it would be nice if the libraries reflected the literature more :)
05:02:13 <quchen> nebnesknarf: Just because it's right doesn't make it happen or make a good case.
05:02:44 <nebnesknarf> quchen: but it should (make a good case)
05:02:56 <nlogax> quchen: Like how LYAH builds up to Monad through Monoid, Functor, Applicative.. then you look at the libraries and go "huh"
05:03:22 <quchen> nebnesknarf: That doesn't help. Killing is wrong, people kill. Yelling "but it's wrong" doesn't help at all.
05:03:43 <quchen> nebnesknarf: Also note that this is a very practical topic, not just an argument of beauty.
05:03:51 <shachaf> LYAH says a lot of bad things too. It is not a good source to cite for how libraries should be designed.
05:04:20 <nebnesknarf> quchen: but practical arguments have counter-arguments: it will break code
05:04:38 <shachaf> There are efficiency reasons to use Applicative instead of Monad.
05:04:42 <shachaf> Also lots of other reasons.
05:04:50 <shachaf> nebnesknarf: Every major release of GHC breaks code.
05:05:16 <quchen> shachaf: Sadly, edwardk isn't online to rant against the current hierarchy.
05:05:21 <nlogax> shachaf: It was the first one that came to mind, but it is often presented like that
05:05:30 <nebnesknarf> quchen: i don't mean to dissuade you from finding all sorts of arguments to convince the conservatives, just wanted to express my opinion
05:05:50 <quchen> shachaf: Got any suggestions yourself? I feel like you may have a much deeper understanding of the consequences.
05:06:45 <monoidal> quchen: I support the change, but I'm not sure if starting with the standard is a good idea. Perhaps the Applicative => Monad change should go to GHC first.
05:07:04 <nlogax> Is there a way that they could co-exist, so that you can opt into it?
05:07:11 <quchen> monoidal: That would mean GHC isn't Haskell anymore.
05:07:11 <Philippa> quchen: has anyone taken stats on how much published code is broken by the change yet?
05:07:21 <monoidal> quchen: It isn't currently
05:07:37 <quicksilver> quchen: that's how it always works.
05:07:41 <quchen> Philippa: Presumably, it will break every single module. However, a legacy module should be a relatively easy fix.
05:07:52 <monoidal> quchen: for example, Num, Bits, NondecreasingIndentation etc
05:07:53 <quicksilver> every change to haskell has been implemented in GHC first.
05:07:53 <Philippa> quchen: the way we tend to phrase it is that there's such a thing as GHC Haskell that is distinct from eg Haskell 2010
05:08:19 <shachaf> GHC is already not Haskell.
05:08:22 <quicksilver> I think no one has the stomach to handle the migration process.
05:08:38 <quicksilver> would it be an option? do we have libaries peppered with #ifdefs until it's complete
05:08:41 <quicksilver> ?
05:08:46 <shachaf> quicksilver: As opposed to the migration process after eliminating two Num superclasses?
05:08:54 <shachaf> Or the migration process that took away a Prelude function?
05:09:10 <tsinnema> can anyone recommend good readings on tradeoffs between strictness and laziness and of ways to manage between the two?
05:09:10 <Philippa> this'd be where I look sheepish about Parsec 3 again, wouldn't it?
05:09:17 <quicksilver> shachaf: seems to me they're not a comparable size problem?
05:09:22 <quchen> This change would certainly be part of a major release of GHC, not just some "7.X" one.
05:09:26 <shachaf> quicksilver: They seem like bigger problems to me.
05:09:31 <quicksilver> many more libraries contain Monad instances than Num instances
05:09:43 <shachaf> quicksilver: This is only a problem for a type which has a Monad instance and no Applicative instance.
05:09:52 <shachaf> quicksilver: It's not about defining Num instances, it's about using them.
05:10:00 <tsinnema> ^^ not necessarily just in a haskell context but in FP in general
05:10:13 <shachaf> quicksilver: foo :: Num a => a -> Bool; foo x = x == 0 doesn't type-check anymore.
05:10:20 <quicksilver> well it was only a problem for polymorphic code which assumed that  Num instance had a Show or Eq instance.
05:10:50 <quicksilver> shachaf: that never should have type-checked, it was "obviously" wrong and lots of libraries didn't contain code like that.
05:10:51 <monoidal> here's a problem with Applicative => Monad: either we have to make Applicative part of Prelude, or each Monad definition would have to import Control.Applicative to define Applicative first
05:11:09 <shachaf> quicksilver: Obviously wrong?
05:11:13 <quicksilver> yes.
05:11:13 <shachaf> Why?
05:11:24 <quicksilver> it's "obvious" that you shouldn't assume Num instances give you Eq instances
05:11:29 <quicksilver> I'd never have written that code
05:11:29 <shachaf> Er, why?
05:11:33 <shachaf> The standard says they do.
05:11:44 <quicksilver> and it's "obviously" not nice to compare polymorphic numbers.
05:11:44 <nlogax> tsinnema: There are probably better things to read about that specific topic but this has some interesting parts about it http://www.cse.unsw.edu.au/~benl/papers/thesis/lippmeier-impure-world.pdf
05:11:46 <maukf> ghci says they do
05:11:50 <quicksilver> I know what the standard says.
05:11:57 <tsinnema> nlogax, thanks
05:11:58 <quchen> What's the problem with having Applicative in the Prelude anyway?
05:12:03 <quicksilver> I'm just saying, I'd never have written that :)
05:12:09 <quicksilver> did it cause much trouble in practice?
05:12:13 <shachaf> quicksilver: How about the fact that lambdabot is *still* not compiling under 7.6 because of the exception change?
05:12:16 <maukf> quchen: I'd like that, actually
05:12:40 * quicksilver shrugs
05:12:55 <quicksilver> I'm only saying that the applicat/functor/monad thing sounds more painful to me. Perhaps I'm wrong.
05:13:00 <maukf> shachaf: didn't lambdabot have its own polymorphic exception system?
05:13:19 <maukf> (incompatible with SomeException)
05:13:21 <shachaf> quicksilver: I started converting it to 7.6 compatibility and then stopped after seeing what a project it would be.
05:13:36 <shachaf> maukf: Did it? I don't remember the details anymore. It had something odd.
05:13:56 <quchen> Anyway, here's a crude version of what I'm trying to say: https://gist.github.com/quchen/5501031 - constructive comments appreciated
05:14:16 <maukf> shachaf: I see we have similar experiences
05:14:33 <shachaf> quicksilver: This Applicative superclass is fixable with a constant amount of work per type.
05:14:50 <quicksilver> shachaf: well that's probably an important anecdote, but my experience is that lambdabot is pathological.
05:14:58 <shachaf> I.e. instance Functor Foo where fmap = liftM; instance Applicative Foo where pure = return; (<*>) = ap
05:15:00 <quicksilver> I looked at the source code once to try to fix one or two minor issues.
05:15:12 <shachaf> quicksilver: OK. But I also had to convert other code to this. There is a lot of code that uses exceptions.
05:15:25 <quicksilver> it took a long time for the pain to fade and I still have flashbacks.
05:15:31 * quicksilver nods
05:15:37 <shachaf> You can fix the superclass thing with a localized change. It's a couple of completely mechanical instances per class, at most.
05:15:42 <quicksilver> shachaf: yes, I understand the extra code required.
05:15:59 <quicksilver> what I don't understand is whether or not this will be an optional flag or a required one
05:16:16 <quicksilver> and whether every single library on hackage declaring a monad instance will need a PVP-major bump all at once
05:16:31 <quicksilver> and if they do, whether the optional flag will let you use the old versions.
05:16:35 <shachaf> Only the ones that don't declare Applicative instances, no?
05:17:15 <shachaf> If GHC had a long history of trying to maintain backwards compatibility, then possibly such a flag would be worthwhile. But I don't think this is likely to happen.
05:17:30 <shachaf> 7.8 is also breaking compatiblity with Typeable. Admittedly Typeable isn't in the Report like Num is.
05:19:01 <quicksilver> shachaf: maybe it's not as bad as I think.
05:19:13 <nebnesknarf> The advantage of doing this in the standard /before/ changing ghc is that ghc can then add a -H2014 switch to ghc that selects a different Prelude and base package
05:19:18 <quicksilver> maybe because it's been debated so long it has a spectre of being worse than it is.
05:19:31 <quicksilver> nebnesknarf: erm, you can do it anyway?
05:19:46 <quicksilver> you just put the flag in (under a different name) and rename it when the standard comes in.
05:19:50 <nebnesknarf> quicksilver: you can, but what is the semantics?
05:20:01 <quicksilver> but I doubt anyone wants to maintain two bases and two preludes long term
05:20:05 <monoidal> I have some doubts what would happen with multiple base packages. bit like python2/3 transition.
05:20:17 <shachaf> quicksilver: People want a silver bullet extension that lets you solve every type class hierarchy problem retroäctively.
05:20:32 <shachaf> quicksilver: I want such an extension too. But I don't want to wait for it for this particular change.
05:20:39 <quicksilver> :)
05:20:47 <quicksilver> sure, perhaps people should be bolder.
05:21:17 <nebnesknarf> base-3 to base-4 was not the end of the world
05:21:29 <quicksilver> not at all, but we didn't try to run them simultaneously
05:21:35 <quicksilver> controlled by a flag.
05:22:25 <nebnesknarf> simultaneously? i don't understand
05:23:14 <shachaf> quchen: However, I don't think you should post this proposal for a while yet.
05:23:33 <nebnesknarf> right now in ghc you can select H89 or H2010 isn't that similar?
05:23:39 <quicksilver> nebnesknarf: no.
05:23:50 <quicksilver> nebnesknarf: those are very minor tweaks, they don't involve separate versions of 'base'
05:23:51 <monoidal> nebnesknarf: that is just language extensions change
05:24:02 <shachaf> quchen: You know that liftA exists despite Functor being a superclass of Applicative, right?
05:24:40 <quicksilver> Of course it's not impossible to maintain two versions of base - I'm just saying that I don't know who would volunteer to do it.
05:24:46 <quicksilver> there are lots of other interesting things to spend time on.
05:24:49 <nebnesknarf> I always thought H2010 has a different Prelude
05:24:59 <monoidal> nebnesknarf: it doesn't
05:25:20 <quchen> shachaf: No, I didn't know that. I thought liftA was there because there's a liftM.
05:25:51 <shachaf> I don't know the motivation for liftA, but one might guess that it's the same as fmapDefault's.
05:25:58 <Philippa> shachaf: partly because it provides a naming scheme for liftAn, of course
05:26:28 <monoidal> quchen: IMO it's too radical. I would export Applicative from base and add Applicative => Monad only.
05:26:32 <shachaf> Yes. But fmapDefault sounds like a much bigger reason to me.
05:26:43 <shachaf> monoidal: But Monad is in the Prelude.
05:26:46 <nebnesknarf> monoidal: i stand corrected
05:26:46 <monoidal> quchen: (also, I don't know why we can't deprecate things in the report.)
05:26:58 <quchen> shachaf: Also, why shouldn't I post it? I didn't plan to do so in the next couple of days until I've heard more input anyway. Your comment sounds like it shouldn't be proposed in general.
05:27:02 <monoidal> shachaf: I mean export from Prelude
05:27:03 <shachaf> If you want to declare a Monad instance for your own type, you would have to declare an Appliactive instance.
05:27:20 <quchen> monoidal: The report should stand on its own I suppose. Deprecations are basically historical things.
05:27:23 <monoidal> shachaf: yes, agreed.
05:27:24 <shachaf> So it would be impossible to declare an instance for a Prelude class without importing a module.
05:28:54 <monoidal> or, even more slowly, in H2013 I would only export Applicative from Prelude, and in H2014 add the Applicative => Monad constraint
05:28:58 <maukf> import Prelude'
05:29:18 <shachaf> monoidal: But each one of them is a breaking change.
05:29:47 <quicksilver> I don't see any benefit in the first change alone
05:29:59 <shachaf> Yes.
05:30:00 <quicksilver> it's mildly breaking without making things better.
05:30:16 <b_jonas> monoidal: you's also need the standard to support defaulting suitable metohds in an Applicative instance from the Monad instance
05:30:29 <monoidal> hm, I see. it gives little benefit.
05:31:06 * shachaf wonders whether liftA2 should be in Applicative...
05:31:33 <maukf> I'd like to propose renaming liftM to liftM1
05:31:37 <maukf> and return to liftM0
05:31:40 <nebnesknarf> Declaring the Applicative instance one would need to make something an instance of Monad is completely mechanical
05:32:02 <shachaf> maukf: Those are good names pedagogically, at least.
05:32:49 <nebnesknarf> Hmm, what about 'deriving Applicative' (given a Monad instance)?
05:33:28 <monoidal> there's also a question, should the Monad class contain some form of return :: a -> m a? It's part of the mathematical definition, and it somehow bothers me that it would be in the applicative instance.
05:33:31 <b_jonas> I think ghc actually has an extension where with a suitable definition of Applicative you could just say instance Applicative Foo; and it would use the right default methods that depend on the Monad intsance
05:33:37 <shachaf> I don't think deriving looks at instances that are declared outside of deriving...
05:33:59 <monoidal> b_jonas: there's default methods, but Applicative and Monad do not use them.
05:34:09 <shachaf> monoidal: Well, it should contain it to maintain backwards compatibility.
05:34:16 <shachaf> Otherwise every Monad instance breaks.
05:34:45 <shachaf> Maybe that's what quicksilver meant before.
05:34:57 <monoidal> shachaf: and even disregarding backwards compatibility? I think there is some ground to argue that return is part of defining a monad.
05:35:16 <monoidal> (on the other hand, functor is too, but we don't write fmap inside monads...)
05:35:42 <shachaf> Right.
05:35:47 <shachaf> That doesn't seem like a big deal to me.
05:36:53 <nebnesknarf> It's like saying a ring is a +group with a multiplication added, it is a correct definition, it just factors out the group
05:37:24 <monoidal> OK, I'm convinced.
05:37:41 <Philippa> nebnesknarf: The thing about "deriving Applicative" is that we're at the stage where you may as well figure out a general mechanism for such things
05:37:46 <shachaf> class Semigroup m => Monoid m, while you're at it.
05:37:48 <Philippa> for bonus points, several of us know how to at least sketch one
05:38:13 <shachaf> Philippa: No, because that'll never be agreed on within the next year and a half.
05:38:15 <quchen> shachaf: Thumbs up :-)
05:38:33 <nebnesknarf> Philippa: that would be awesome to have
05:38:34 <quchen> shachaf: But that's for another proposal some day.
05:38:51 <Astro> hi
05:38:51 <shachaf> monoidal: Do you object to: class Semigroup a where (++) :: a -> a -> a; class Semigroup a => Monoid a where empty :: a?
05:39:13 <monoidal> shachaf: no
05:39:20 <shachaf> OK.
05:39:25 <Philippa> shachaf: it won't, no. But someone's going to make the "ad-hoc" objection
05:39:27 <shachaf> I guess you just said you were convinced anyway.
05:39:27 <quicksilver> WONT SOMEBODY PLEASE THINK OF THE MAGMAS
05:39:31 <Astro> when compiling vector-0.10.0.1 on a raspberrypi (debian armel) with ghc 7.6.3 I get:
05:39:38 <Astro> Loading package ghc-prim ... linking ... ghc: /usr/lib/ghc/ghc-prim-0.3.0.0/HSghc-prim-0.3.0.0.o: unhandled ELF relocation(Rel) type 40
05:39:42 * mr- thinks of magmas
05:39:50 <quicksilver> and the quasigroups, and the loops, etc etc
05:39:58 <monoidal> shachaf: (btw note that the order here is inverted. we would have Semimonad with join and Monad with return.)
05:40:03 <nebnesknarf> I meant the 'deriving' as a stop-gap measure for people who can't be bothered to type out the instance
05:40:04 <Philippa> shachaf: that said - I can see such a mechanism being faster to agree than many because we have a lot of the underpinning via the research on the relationship between type classes and ML modules
05:40:15 <Philippa> the problem'd be getting someone to implement it
05:40:21 <shachaf> monoidal: ?
05:40:41 <shachaf> quicksilver: data Magma a = Zero | One a | Two (Magma a) (Magma a); instance Monoid (Magma a) where mempty = Zero; mappend = Two
05:41:35 <monoidal> shachaf: semigroups give (++), monoids give empty, and we have Semigroup => Monoid. however, for complete analogy, we would have semimonad with join and monad with return
05:41:41 <shachaf> monoidal: I just gave it as an example. Part of the definition of a monoid involves mappend, but the Monoid class doesn't.
05:41:48 <quicksilver> shachaf: that's a free magma, no?
05:41:52 <quicksilver> not all magmas are free.
05:41:58 <quicksilver> the interesting ones aren't...
05:42:14 <shachaf> monoidal: Applicative isn't a superclass of Monoid in the sense of being a semigroup in the category of endofunctors, certainly.
05:42:19 <shachaf> quicksilver: It's also not a monoid.
05:42:24 <quicksilver> sure.
05:42:43 <monoidal> shachaf: I would have to think if there are applications of class Functor f => Semimonad f where join :: f (f a) -> f a
05:42:46 <shachaf> That's why it's such a great Monoid instance!
05:42:57 <quicksilver> my clumsy rhetorical point was that it doesn't necessarily make sense to refine mathematical hierarchies all the way
05:43:14 <shachaf> monoidal: edwardk has that class.
05:43:15 <quicksilver> it's an actual decision we have to take about which points of refinement make good typeclasses.
05:43:26 <shachaf> quicksilver: Yes, but Semigroup is very useful in practice.
05:43:34 <quicksilver> shachaf: right. but that had to be proven.
05:43:43 <shachaf> Right.
05:43:53 <quicksilver> edwardk has a remarkable knack for finding applications of points of refinement
05:44:48 <shachaf> There are certainly applications for two superclasses of Applicative, one for lift0 and one for lift2.
05:45:11 <shachaf> Although Pointed is kind of evil. But there are applications, namely affine traversals.
05:47:01 <Chousuke> if you were to rework the Monad class, wouldn't removing fail from it also make sense :P
05:47:15 <Cale> Chousuke: yes
05:47:24 <Latermuse> Isn't fail there for legacy purposes?
05:47:34 <quchen> Chousuke: Maybe. But the goal here isn't reworking Monad, it's changing the hierarchy.
05:47:41 <Cale> No, it's there because of the translation of the do-notation
05:47:51 <Cale> It's to handle pattern match failures
05:48:04 <quchen> Chousuke: There's enough debatable content already, adding a discussion about fail won't help the cause.
05:48:28 <Cale> But it doesn't actually need to be in the Monad class. If it were in a separate class, you'd get more type information when you wrote a do-block with pattern matches that might fail.
05:48:36 <quchen> Cale: I think that is easily fixable though: if there's pattern matching beyond a simple name in the do block, add a "MonadFail" constraint.
05:48:58 <quchen> Ninja'd :-)
05:48:58 <shachaf> That is what Haskell 1.4 did, except it used MonadZero.
05:49:03 <maukf> that happens automatically anyway
05:49:04 <Cale> exactly, yes
05:49:11 <maukf> you just desugar and let the typechecker do its job
05:49:27 <Cale> right, it wouldn't need anything special
05:49:31 <quchen> maukf: You're maue, right?
05:49:34 <quchen> mauke*
05:49:50 <shachaf> maukf is maukd
05:50:34 <quchen> shachaf: So it's mauke on average?
05:50:44 <Latermuse> There's an enum joke in there
05:51:14 <Philippa> shachaf: A constraint-supporting version of Pointed has more potential uses, too
05:51:14 <maukf> and an fnum joke
05:51:38 <shachaf> Philippa: Constraint-supporting?
05:52:21 <Philippa> shachaf: one that lets you put a constraint on the types you have points for
05:52:34 <shachaf> Are you talking about ConstraintKinds or something else?
05:52:45 <shachaf> Er, associated types, I guess.
05:52:54 <Philippa> the two together, yeah
05:53:26 <shachaf> I certainly hope ConstraintKinds isn't going in H2014.
05:53:35 <shachaf> Associated types most likely shouldn't either.
05:53:36 <Philippa> *nod*. It's a bit early for that, yeah
05:54:22 <shachaf> Being an extension isn't a bad thing
05:55:38 <Philippa> except insofar as it affects the library infrastructure, anyway
05:56:13 <shachaf> Yes.
05:59:01 <quchen> shachaf: You didn't say why you thought proposing the Applicative=>Monad change wasn't a good idea right now. Are there specific reasons for that standpoint?
06:06:25 <monoidal> in GHCi, type T = a gives "no a in scope" error, while type T = () => a and type T = (Num a) => a work. is this intended?
06:08:11 <quicksilver> is the same true in a .hs file?
06:08:32 <quicksilver> although I don't know what I think would be correct, either way
06:08:37 <shachaf> monoidal: I suspect not.
06:08:51 <shachaf> The implicit forall thing happened at one point, I don't remember when.
06:09:29 <isomorphic> What's a good way to cause an attoparsec parser to fail?  ie: if some test within my parser fails - so that some other parser can continue from where it started
06:09:42 <dmwit> :t fail -- ?
06:09:43 <lambdabot> Monad m => String -> m a
06:10:12 <dmwit> Or will that not work because of attoparsec's lies about backtracking?
06:10:51 <isomorphic> dmwit:  To be honest, I'm not sure.  I looked at the hackage page for a fail-like function and didn't see one - so I'd figured I was missing something more general
06:10:58 <monoidal> quicksilver: yes, the same in .hs
06:11:16 <quicksilver> pretty sure that's a bug then monoidal
06:20:36 <mm_freak> isomorphic: 'empty'
06:20:57 <mm_freak> to add a failure message use <?> at some higher level
06:22:07 <isomorphic> mm_freak: Thanks :)
06:26:30 <monoidal> what would you expect - should "type T = () => a" fail with "not in scope: 'a'"?
06:27:03 <shachaf> Is this implicit-forall thing documented anywhere?
06:31:14 <monoidal> shachaf: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/other-type-extensions.html, section 7.12.5.1
06:31:25 <monoidal> That is, since the type variable b isn't in scope, it's implicitly universally quantified. (Arguably, it would be better to require explicit quantification on constructor arguments where that is what is wanted. Feedback welcomed.)
06:31:25 <Elision> hm. I'm making a class for tropical reals (semiring with a + b = min(a,b), ab = a + b
06:31:30 <Elision> type*
06:32:14 <Elision> would it be reasonable to make it an instance of Num, since, for example, fromIntegral(a*b) /= fromIntegral(a) * fromIntegral(b)
06:32:24 <elliott> monoidal: I find that behavour incredibly unintuitive, fwiw
06:32:25 <monoidal> shachaf: actually this part of manual is outdated; the examples do not work
06:32:38 <elliott> as in, I am surprised even now that it happens, even though have I learned that it happens before
06:32:52 <monoidal> I think rank-N-types should always use "forall", never quantification that happens with =>
06:33:55 <shachaf> type Traversal' s a = Applicative f => (a -> f a) -> s -> f s
06:34:26 <elliott> monoidal: on some days I think rank-1 types should use forall
06:35:23 <mm_freak> monoidal: it's a bit odd that "() => a" and "a" behave differently, so i would either expect both to work or both to fail
06:35:44 <mm_freak> but on the other hand ScopedTypeVariables makes "forall a. a" and "a" behave differently, which is equally confusing
06:36:15 <monoidal> shachaf: for consistency, it would be type Traversal' s a = forall f. Applicative f => (a -> f a) -> s -> f s, right?
06:36:43 <shachaf> That's what the unquantified version means.
06:36:51 <mm_freak> i would expect 'type T = a' to work when RankNTypes is enabled…  we get implicit foralls everywhere, so we could just as well get them here
06:37:05 <shachaf> We don't get them everywhere.
06:37:26 <mm_freak> shachaf: id :: a -> a
06:37:31 <mm_freak> const :: a -> b -> a
06:37:42 <shachaf> Yes. We get them there.
06:37:53 <shachaf> We don't get them in data Foo = Foo a
06:38:42 <mm_freak> shachaf: data Foo where Foo :: a -> Foo
06:39:17 <shachaf> Yes.
06:39:25 <elliott> type T = a looks a lot more like data T = T a than a GADT.
06:39:27 <shachaf> You must mean something different by the word "everywhere" than I do.
06:39:33 <elliott> it should behave similarly
06:39:35 <mm_freak> read "everywhere" intuitively
06:39:44 <shachaf> type ... = ... looks like substitution.
06:39:57 <shachaf> Implicit foralls don't work well with that.
06:40:10 <no-n> is haskell haskell?
06:40:17 <mm_freak> elliott: type T = a looks like data Foo
06:40:41 <mm_freak> except a highly polymorphic version of it
06:41:38 <mm_freak> shachaf: well, you wouldn't expect a type synonym to refer to free variables
06:41:58 <mm_freak> if anything, only an error or an implicit forall make sense
06:42:31 <mm_freak> and personally i wouldn't mind the implicit forall
06:42:36 <monoidal> I think type signatures x :: ... should be with implicit quantification, equalities x = ... should not.
06:42:51 <monoidal> * equalities T = ... should not.
06:42:52 <shachaf> monoidal: data Foo = Foo { x :: a } is also an error. :-)
06:42:53 <mm_freak> good point
06:43:11 <shachaf> (But this is an abuse of ::.)
06:46:11 <fruitFly> head' :: [a] -> a   head' = foldr1 (\x _ -> x)  ... why would one fold from the right instead of the left?
06:46:41 <mm_freak> fruitFly: foldr const undefined (x:xs) = const x (foldr const undefined xs)
06:46:42 <mm_freak> = x
06:47:34 <mm_freak> fruitFly: the misconception is that foldr does not fold from the right…  it folds from the left, but applies its function right-associatively
06:47:36 <fruitFly> mm_freak: heh
06:48:54 <mm_freak> now try the same with foldl:  foldl (const id) undefined (x:xs) = foldl (const id) (const id undefined x) xs = foldl (const id) x xs
06:49:00 <monoidal> shachaf: data Foo = Foo { x :: () => a }, incidentally, does work
06:49:23 <mm_freak> this goes on until you hit:  foldl (const id) x [] = x
06:49:26 <mm_freak> which is the /last/ element
06:49:33 <mm_freak> > foldl (const id) undefined [1..10]
06:49:35 <lambdabot>   10
06:49:37 <Kinnison> Which in an infinite list never happens
06:50:35 <mm_freak> > foldr (const . Just) Nothing [1..10]
06:50:36 <lambdabot>   Just 1
06:51:34 <mm_freak> > foldl (const Just) Nothing [1..10]
06:51:37 <lambdabot>   Just 10
06:51:50 <Kinnison> const is one of those functions I love when I see it in use, but never think of using it myself
06:52:16 <fruitFly> @type const
06:52:18 <lambdabot> a -> b -> a
06:52:43 <fruitFly> @src const
06:52:43 <lambdabot> const x _ = x
06:52:52 <mm_freak> Kinnison: practice a bit with abstraction elimination =)
06:53:11 <Kinnison> mm_freak: Unfortunately I'm not getting much chance to code in Haskell right now
06:53:33 <fruitFly> Kinnison: UNFORTUNATELY*
06:53:36 <mm_freak> Kinnison: you don't have to…  i did my first steps there on actual dead trees
06:53:38 <fruitFly> me too
06:53:47 <Kinnison> Work has me being a PM/Arch instead of coding, and my personal work is centering around my git service (which is written in Lua)
06:54:04 <mm_freak> ugh
06:54:09 * Kinnison ought to go back to his Haskell runtime template stuff
06:55:09 <elliott> monoidal: maybe we could make (() => e) specifically mean "e with automatic quantification"!
06:55:16 <Kinnison> mm_freak: ugh?
06:55:17 <elliott> map :: () => (a -> b) -> [a] -> [b]
06:55:22 <mm_freak> Kinnison: lua
06:55:27 <Kinnison> mm_freak: I like Lua
06:55:52 <mm_freak> personal taste i guess…  i have difficulty programming in any non-static language
06:55:58 <Kinnison> :-)
06:58:02 <shachaf> monoidal: Oh.
06:58:11 <fruitFly> @src flip
06:58:11 <lambdabot> flip f x y = f y x
06:59:16 <tromp> pair x y f = f x y
06:59:45 <monoidal> elliott: would () => (() => a -> a) -> b mean forall b. (forall a. a) -> b? IMO it would be too complicated (scoping would depend on where the identifiers are)
07:00:03 <elliott> monoidal: sounds good to me!!
07:00:11 <elliott> this isn't really a serious proposal btw.
07:00:19 <elliott> but it would be nice to have some marker for automatic quantification...
07:02:09 <Kinnison> mm_freak: As non-static languages go, Lua is delightful IMO
07:02:14 <monoidal> elliott: maybe "forall _: ..."?
07:02:26 <elliott> forall all
07:02:51 <shachaf> monoidal: We need to have constraints wtihout foralls.
07:03:10 <elliott> shachaf: monoidal is referring to my proposal
07:03:13 <monoidal> shachaf: agreed. But I think (not sure) that currently in GHC they're coupled
07:03:17 <no-n> can I make ghci's autocomplete use less instead of more?
07:03:29 <Eduard_Munteanu> Does non-static include dynamic with possible static features?
07:03:31 <maukf> does it actually use more?
07:03:34 <monoidal> shachaf: (for example, nullary type classes do not need forall.)
07:03:35 <shachaf> monoidal: No, there are cases in GHC where you can use constraints without foralls.
07:03:40 <no-n> maybe not :3
07:03:49 <monoidal> shachaf: I see
07:04:00 <elliott> () => a being forall a. a would make sense if not for the fact that
07:04:02 <shachaf> I don't remember off-hand...
07:04:05 <elliott> a -> (Num a => r) -> r
07:04:07 <elliott> is not
07:04:11 <elliott> a -> (forall a. Num a => r) -> r
07:04:12 <elliott> but instead
07:04:14 <shachaf> There was a good GADT example.
07:04:18 <elliott> forall a. a -> (Num a => r) -> r
07:04:19 <elliott> er
07:04:21 <elliott> forall a r. a -> (Num a => r) -> r
07:04:25 <monoidal> in any case I'd like to file a bug report, perhaps the situation with implicit quantification can be improved, but I'd like to be specific on how
07:05:47 <monoidal> is the odd behavior only on "type T = a" vs "type T = () => a"?
07:06:28 <Eduard_Munteanu> Um, do we have () constraints?
07:06:35 <Eduard_Munteanu> I should catch up with this stuff.
07:06:57 <shachaf> monoidal: I think the data behavior is much odder.
07:06:58 <monoidal> Eduard_Munteanu: yes. you can also write (((), ()), ()) => Int if you're in mood for fun
07:07:11 <shachaf> data Foo = Foo (() => a)
07:07:27 <Eduard_Munteanu> monoidal: I guess the point is to substitute () for a Constraint when you don't need an actual constraint
07:08:01 <monoidal> shachaf: right. So in type and data declarations, => introduces implicit quantification, but it shouldn't.
07:08:48 <monoidal> Eduard_Munteanu: yes, that's the point. e.g. you can have "restricted functor" (to some constraint) and then substitute () to get an unrestricted functor.
07:21:59 <mm_freak> Kinnison: i have an aversion to non-static languages in general…  especially if they are strongly typed, which may sound weird at first
07:22:33 <monoidal> Eduard_Munteanu: (btw () was available before constraintkinds.)
07:22:33 <maukf> don't worry, "strongly typed" doesn't really mean anything
07:23:01 <mm_freak> maukf: in the sense that functions will complain about wrong argument types
07:23:28 <Eduard_Munteanu> monoidal: interesting... was there any purpose for it? (perhaps just having a canonical form for all polymorphic types?)
07:24:00 <Eduard_Munteanu> mm_freak: look at Erlang
07:24:07 <Philippa> maukf: you're not happy with eg Pierce's definition?
07:24:16 <Eduard_Munteanu> Strongly-typed, but there isn't much "type" in the mix.
07:24:37 <monoidal> Eduard_Munteanu: I doubt it. in 7.2 you could only use it to write () => a. I guess it was for consistency - since you could put arbitrary number of constraints inside (), you should be able to put 0 as well.
07:24:51 <Eduard_Munteanu> Hm.
07:24:51 <elliott> well, ConstraintKinds is relevant here
07:24:53 <mm_freak> maukf is unhappy by construction
07:24:54 <elliott> () :: Constraint
07:24:57 <mm_freak> =)
07:25:10 <maukf> mm_freak: :-D
07:25:11 <Eduard_Munteanu> But we should've had nullary typeclasses too. :(
07:25:23 <Eduard_Munteanu> (at least with MPTC)
07:25:38 <maukf> Philippa: I'm happy with pretty much any definition, I just don't think there's a universal definition without context
07:25:44 <shachaf> Eduard_Munteanu: Nullary type classes are in HEAD!
07:25:46 <mm_freak> Eduard_Munteanu: the reason i have a stronger aversion to strongly typed non-static languages is that i think:  "if they check types, why the hell don't they check them at compile/load time?!"
07:25:47 <Philippa> Eduard_Munteanu: I think you need one more thing for those to make sense
07:25:52 <shachaf> Thanks to monoidal.
07:26:16 <isomorphic> mm_freak:  before you mentioned empty to fail an attoparsec parser.   Am I right to understand that as Data.Text.empty?
07:26:25 <monoidal> (shachaf and me wrote the patch in fact.)
07:26:34 <mm_freak> Eduard_Munteanu: mainly a "the language designers didn't really have a reason to omit static typing, so they must be retarded" thing
07:26:42 <mm_freak> both erlang and python fall in this category
07:26:50 <Philippa> maukf: "highly overloaded" is probably a more useful comment than "doesn't really mean anything", then - the latter applies to eg stuff you could publish in the Journal of the Empty Set
07:27:06 <mm_freak> isomorphic: Control.Applicative.empty
07:27:10 <Philippa> mm_freak: given Erlang's age, they had good reason to at the time
07:27:11 <Eduard_Munteanu> mm_freak: SPJ actually tried to add static typing after the fact and couldn't, best he could do is that success typing thing
07:27:19 <Eduard_Munteanu> To Erlang, I mean.
07:27:25 <isomorphic> mm_freak:  That would explain it ;) Thanks again :)
07:27:31 <mm_freak> sure
07:27:41 <maukf> Philippa: some people use the term without thinking about it
07:27:57 <maukf> hmm. partially defined? :-)
07:27:59 <Philippa> maukf: sure. But you can invite them to show their thinking
07:28:01 <mm_freak> Philippa: i don't get that one
07:28:01 <Eduard_Munteanu> Philippa: what would that thing be?
07:28:11 <mm_freak> what's the age got to do with it?
07:28:44 <Kinnison> mm_freak: dynamic languages are a taste one either acquires or abhors, I will agree :-)
07:29:25 <Philippa> mm_freak: it affects what we knew we could reliably do with static typing. Especially when you know Erlang is descended from prolog - static typing for logic languages was a research project
07:29:33 <Philippa> hell, it still is
07:29:38 <mm_freak> Kinnison: i simply don't see a valid application for dynamic languages
07:29:44 <Philippa> (one with some known-good basic answers, granted)
07:29:52 <Kinnison> mm_freak: :-)
07:30:01 <Philippa> mm_freak: dodging Goedel
07:30:11 <mm_freak> oh, i used "dynamic language"…  of course i mean non-static language =)
07:30:17 <Kinnison> mm_freak: fortunately most of my language-lawyering is spent on my colleague's butchering of written English
07:30:32 <Kinnison> mm_freak: It's amazing what crap he produces
07:30:50 <Philippa> (as far as I'm concerned there are also good applications for 'dynamic languages' in the lisp-environments-and-smalltalk sense too, though)
07:31:49 <elliott> I wouldn't want to use a static language that's even a little weaker in terms of the ability of the type system than standard Haskell.
07:31:58 <elliott> were typeclasses even known at the time Erlang was designed?
07:32:08 <elliott> (if known, then known /enough/?)
07:32:10 <mm_freak> elliott: true
07:32:12 * Eduard_Munteanu wonders what else dynamic languages offer besides reflective and macro-y capabilities
07:32:26 <Philippa> elliott: nope
07:32:33 <mm_freak> Eduard_Munteanu: run-time errors
07:32:44 <Philippa> 1986. The amusing miscommunication/quantifier confusion that led to typeclasses hadn't happened yet
07:32:49 <Eduard_Munteanu> Let's not go there.
07:33:14 <elliott> Philippa: hm, typeclasses arose from quantifier confusion? that sounds like fun; do you have any links/refs for me to dig into?
07:33:26 <Eduard_Munteanu> mm_freak: how about I argue Haskell is a dynamic dependently-typed language, coz array bounds are checked at runtime? :P
07:33:30 <Philippa> mm_freak: I can picture a language I'd call dynamic but which is sufficiently staged that you shouldn't get errors from a given phase appearing as it runs
07:33:50 <mm_freak> Eduard_Munteanu: "dynamic dependently typed"?
07:34:10 <Philippa> elliott: the HOPL paper on Haskell.  Summary: Wadler /heard/ "forall single-variable constraints [of some reasonable class]"
07:34:13 <Eduard_Munteanu> mm_freak: yes, your arrays are actually size-indexed, but you can only check typing at runtime ;)
07:34:22 <mm_freak> Philippa: then the language is practically static
07:34:43 <Eduard_Munteanu> Of course, Haskell just hides that from you.
07:34:47 <mm_freak> Eduard_Munteanu: so like passing the size in a constructor field?
07:34:59 <Eduard_Munteanu> Yeah, why not? :P
07:35:06 <Philippa> mm_freak: It's also practically dynamic. Just not dynamically typed.
07:35:13 <mm_freak> Eduard_Munteanu: so like…  uhm…  not dependently typed at all?
07:35:22 <elliott> Philippa: hehe, nice -- I swear I've already read that paper, so I must have forgotten :/
07:35:35 <mm_freak> Philippa: haskell can do that…  see RankNTypes
07:35:44 <mm_freak> well, ok, haskell + RankNTypes
07:36:22 <Philippa> mm_freak: No. That's no more accurate than "Haskell has HOFs, therefore it's reflective!"
07:36:37 <Eduard_Munteanu> Well, I am stretching it, but I was sorta poking at "runtime errors" there. That's not really a feature unless you actually have a good reason.
07:37:08 <Philippa> elliott: It's an amusing class of communication error. Also an amusing one to pull on purpose, it has a way of getting stuff done if you can see something to quantify across
07:37:25 <Philippa> Eduard_Munteanu: Quite. Erlang does, of course - let it crash! :p
07:37:34 <mm_freak> Philippa: the point is that RankNTypes basically allows you to load a program from disk, type-check it and then integrate it into the running program
07:37:44 <Eduard_Munteanu> Uh, yeah, never wrapped my head around that.
07:37:48 <mm_freak> all statically checked
07:37:54 <elliott> Philippa: "amusing class" intentional? :P
07:39:06 <Philippa> mm_freak: For programs with types of arbitrary rank? Not convinced
07:39:33 <Eduard_Munteanu> I guess you can stretch it the other way... blame all runtime checks on some RTS and pretend you have a static, but useless type-system. :)
07:39:53 <Philippa> I mean, you'd expect textbooks covering System F to make a really big deal about that, otherwise
07:40:11 <mm_freak> Philippa: as long as the program doesn't expose those higher rank types sure
07:40:15 <Philippa> Eduard_Munteanu: Never seen that done before!...
07:40:15 <mm_freak> the loaded one that is
07:40:41 <Philippa> mm_freak: Right. Not good enough.
07:41:32 <mm_freak> Philippa: in fact the loaded program /can't/ expose higher rank types unless you expect it to do so, but that basically allows arbitrary rank polymorphism in the loaded program
07:41:32 <Philippa> (nor, of course, does it give you arbitrary reflection on the running program or even a scope-bounded chunk of it)
07:42:14 <mm_freak> Philippa: i don't understand…  could you give me a real world application that you think is impossible in haskell the way you could do it in a language like you imagine?
07:42:30 <Philippa> mm_freak: there are Smalltalk derivatives where you can /rewrite the VM as it's running/
07:42:43 <Philippa> there were a lot of Pentium owners who would've loved to do that to their FPU...
07:43:17 <`^_^v> what's it called when a function is defined as f (n + 1) = … i assume it was present in an older haskell, is there a ghc extension to enable it
07:43:29 <Philippa> `^_^v: "n+k patterns"
07:43:36 <mm_freak> Philippa: are you suggesting that you would like to be able to change the RTS as it's running?
07:44:06 <Philippa> mm_freak: I'm saying that it's not hard for me to envisage scenarios where being able to do so might save a company megabucks
07:44:07 <monoidal> `^_^v: you can enable it with -XNPlusKPatterns, but it is highly discouraged. It's better to use f n = .. (refer to n-1)
07:44:16 <Philippa> merely doing so to the program that's actually running? Even easier
07:44:32 <mm_freak> Philippa: i mean this sounds like apples and oranges to me…  in smalltalk you would like to be able to change the VM, but there is no haskell equivalent to this
07:44:49 <mm_freak> just like saying that haskell has no lisp-style macros…  of course it doesn't
07:44:55 <Philippa> mm_freak: Yes. To me, this appears to be a conversation about whether oranges have any business existing
07:45:29 <Philippa> also, about whether it is worth investigating how far we can get with allowing apples to do orangey things
07:45:40 <mm_freak> exactly
07:46:10 <Philippa> Erlang is dyntyped because it was going to be used for mega-to-gigabucks purposes and we didn't have an answer
07:46:28 <mm_freak> i'm not saying that erlang is bad
07:46:39 <Eduard_Munteanu> Just a bit bad, no? :)
07:46:50 <mm_freak> Eduard_Munteanu: just that today we have haskell =)
07:46:56 <Eduard_Munteanu> Yay.
07:47:10 <tromp> you mean it's naughty?
07:47:36 <Philippa> sure. What we don't have is strong enough evidence that Cloud Haskell is yet worth betting gigabucks on
07:48:05 <mm_freak> Philippa: certainly not…  cloud haskell is basically in its infancy
07:48:31 <mm_freak> and i don't think it will get much further before portions of it are supported by the RTS
07:48:44 <Philippa> indeed
07:48:53 <Philippa> Haskell per se just doesn't address the needs Erlang does
07:49:02 <Eduard_Munteanu> Stuff like function marshalling right?
07:49:24 <mm_freak> Philippa: actually i think it does, but it's missing the cloudiness yet
07:49:38 <Philippa> mm_freak: "the cloudiness" would be a need that Erlang /does/ address
07:49:43 <mm_freak> Eduard_Munteanu: for example
07:49:58 <Eduard_Munteanu> I should try CH sometime.
07:50:43 <mm_freak> Philippa: what i mean is that haskell is going into that direction (it's going into many directions)
07:50:51 <mm_freak> it's about the most universal language i know
07:51:20 <elliott> maybe you just don't see the ways in which other languages are universal because of that?
07:51:51 <mm_freak> elliott: like?
07:52:19 <Philippa> mm_freak: "going". We get to complain about the extant languages in those areas being bad ideas once we're there, not before. And even then, if we're doing it on the back of decades of extra research we're still being arseholes
07:52:20 <elliott> well, if you focus on Haskell because it's the best, then you're unlikely to hear about the ways in which Python or Erlang or whatever is excelling
07:52:55 <Philippa> (Python as a dynamically-typed language also makes sense. Python being as popular as it is now because nobody built ML-with-Python-syntax is the problem)
07:53:09 <Philippa> (history *matters*)
07:53:42 <bitonic> Philippa: are you arguing that ML would have been as popular as Python if its syntax resembled Python’s?
07:53:52 <mm_freak> elliott: no, i'm very interested in other languages…  but all that doesn't change that haskell is very versatile
07:54:03 <mm_freak> Philippa: i wouldn't be so arrogant
07:54:11 <mm_freak> and as said, i don't think that erlang is bad
07:54:37 <mm_freak> i think that haskell can become a valid choice as a successor
07:54:43 <mm_freak> in that particular field that is
07:55:16 <mm_freak> that doesn't mean we forget erlang's contributions…  in fact we build on them right now
07:55:22 <Philippa> bitonic: Not quite. I'm arguing that you can build a language that's most of the way to being a modern ML and reads like Python, that it would have been competitive with Python at some point in the 00s given lib support (a big if) and that this would seriously affect the landscape for languages that pay attention to scripting
07:55:28 <mm_freak> lightweight concurrency wasn't haskell's invention after all
07:55:30 <bitonic> mm_freak: the Haskell and Erlang communities have *very* different ways of developing software.  they’re not heading in the same direction
07:56:19 <mm_freak> bitonic: but erlang does address very large scale applications, and i can see that haskell will be a viable alternative in the future with some unique advantages
07:56:36 <bitonic> Philippa: I think singling out syntax is a bit naive... the factor that made python popular were a very low barrier and super broad standard libraary
07:56:37 <bitonic> *library
07:57:06 <bitonic> mm_freak: sure, I’m just saying that putting it in terms of one ‘succeeding’ the other is weird, they’re very parallel
07:57:29 <Philippa> bitonic: right. I already mentioned libraries. Consider what "Python-with-HM" would be like?
07:57:44 <mm_freak> bitonic: also TBH i don't think that the erlang community is very different =)
07:58:05 <Philippa> (which, I realise, messes with syntax to an extent that both MLers and Pythonistas might consider semantic!)
07:58:11 <mm_freak> we have one very important thing in common:  we are both innovative
07:58:43 <monoidal> are there any mainstream imperative languages with HM?
07:58:58 <Philippa> monoidal: nope, and it's a crying shame
07:58:58 <bitonic> Philippa: you seem to assume that adding HM to Python is trivial, but treating objects (at the type level) is not obvious at all
07:59:10 <monoidal> weird nobody filled this gap.
07:59:27 <bitonic> there’s Scala
07:59:28 <Philippa> bitonic: "seem". I'm familiar with the problems
07:59:49 <bitonic> Philippa: right, so to put it in another way, I can’t picture Python-with-HM :)
08:00:01 <Philippa> there's a really obvious solution if you're going to follow something similar to Python's own development, of course: early versions just don't do inheritance
08:00:11 <bitonic> unless you mean Python without Python objects.  which ceases to be Python really
08:00:19 <mapreduce> Scala doesn't have HM, as that doesn't work with inheritance.
08:00:50 <Philippa> bitonic: I'm certainly not expecting to do that /and/ have a sound type system, no. We're going to end up with a less dynamic language (though it's possible to preserve a lot of the introspection, for example)
08:00:54 <mapreduce> Instead they encode the typesystem in the brain of the inventor, and the compiler just tries to emulate him.
08:01:13 <Philippa> but most of the time, Python isn't popular because of its object model as such
08:01:22 <bitonic> mapreduce: well HM is still the foundation of most type systems, including the one with subtyping
08:01:48 <Philippa> bitonic: depends what you think "HM" is
08:02:18 <gustavderdrache> cabal-install hangs when i try to download anything from the network, but i think it's something in the GHC runtime acting strange... is this a good channel to ask for some help figuring out where the bug (if any) may lie?
08:02:22 <Philippa> and in fairness: you'd probably be better off ditching generalisation for something in Python's ballpark
08:03:04 <Philippa> (if you don't have a generalisation rule somewhere, I'm loathe to call it HM at all: given how obvious instantiation is, the rest's just monotype equality constraints)
08:03:25 <mm_freak> monoidal: it's not that weird when you consider the implications of HM for an imperative language, which, i suppose, has side effects
08:03:29 <bitonic> Philippa: yeah with ‘HM’ I more or less meant that you have a rule similar to the polymorphic let
08:03:34 <bitonic> which is really what distinguishes HM
08:04:01 <Philippa> bitonic: I don't think it's totally unfair to be wanting something based on row types by the early-to-mid 00s, though?
08:04:13 <monoidal> mm_freak: even then I think they're not that serious (for example, ML has references)
08:04:22 <bitonic> the point is that how this ‘imperative language with HM’ work is all but clear to me
08:04:34 <Philippa> oh, "imperative language with HM" is a piece of cake. ML already is it
08:04:39 <mm_freak> monoidal: i commented this: <monoidal> weird nobody filled this gap.
08:04:41 <bitonic> Philippa: yeah but coming up with something nice and usable seems to be hard
08:04:41 <Philippa> "OO language with HM" is the hard bit
08:04:49 <monoidal> mm_freak: me too
08:05:07 <bitonic> Philippa: right, we needed to define what imperative is first ehe.  then yeah SML is very nice.
08:05:24 <mm_freak> monoidal: i'm having trouble with making sense of HM in an imperative language with non-first-class actions
08:05:35 <Eduard_Munteanu> Can you do type inference for stuff like bounded quantification, subtyping + polymorphism?
08:05:45 <bitonic> Philippa: OCaml has got objects
08:05:47 <Philippa> mm_freak: which is ironic, because it's a trivial restriction
08:05:49 <hpaste> “Anonymous Coward” annotated “bfs” with “bfs (annotation)” at http://hpaste.org/41886#a87074
08:05:50 <bitonic> row types and such
08:05:56 <monoidal> mm_freak: why? A function A -> B might have IO side effects, and that's basically it
08:05:57 <Philippa> bitonic: yep. And it's a lousy Python stand-in
08:06:23 <mm_freak> monoidal: there are languages with type inference, e.g. C++1x or D, but it's highly nontrivial
08:06:24 <bitonic> I suppose if you took OCaml and focused more on fewer concepts it could be nice
08:06:28 <Philippa> and a lot of that is because the syntactic tradition makes /no sense whatsoever/ to the sort of person who's going to be reading early Python tutorials and takes a lot of explaining
08:06:38 <elliott> you have to be careful with references
08:06:41 <monoidal> mm_freak: I believe "auto" in C++ (and probably D) is much more restricted than HM.
08:06:42 <elliott> see ML's value restriction
08:06:47 <elliott> but that's more or less it
08:06:51 <mm_freak> monoidal: auto is probably the best you can get
08:07:05 <Philippa> elliott: yep. Long-documented by now though, and also the sort of thing that imperative langs screw up regularly anyway
08:07:25 <bitonic> still, the value restriction keeps confusing people
08:07:30 <mm_freak> monoidal: at least in a language like C++ where the parametric polymorphism is actually fake
08:07:30 <elliott> so does the monomorphism restriction
08:07:41 <bitonic> elliott: but one of them is not needed for soundness
08:07:46 <elliott> true
08:07:58 <elliott> but people program in haskell just fine, even if they find it confusing
08:08:08 <elliott> no reason why you can't overcome the same confusion to use ML
08:08:09 <monoidal> mm_freak: right. but we could have parametric polymorphism in an imperative language.
08:08:11 <bitonic> elliott: oh yeah, sure.
08:08:27 <elliott> I agree it's an ugly restriction though
08:08:29 <Philippa> elliott: if we're gunning for Python then that's the wrong attitude, though
08:08:39 <bitonic> I was just arguing on the nature of the restriction
08:08:47 <mm_freak> monoidal: we do have parametric polymorphism in an imperative language…  it's just very different from traditional imperative languages like C++…  that language is called haskell
08:09:13 <bitonic> mm_freak: we have parametric polymorphism in languages much more imperative than Haskell
08:09:14 <elliott> Philippa: quite possibly
08:09:22 <elliott> I'd never try to gun for Python so I'm not qualified to comment :P
08:09:23 <mm_freak> bitonic: "much more imperative"?
08:09:50 <bitonic> mm_freak: SML & OCaml, Scala, C# and Java in a more restricted sense
08:10:01 <monoidal> mm_freak: well, haskell has no side-effects, "true" variables (not STRef), imperative control feel etc. it's hard for mainstream adoption
08:10:02 <mm_freak> bitonic: those aren't any more imperative than haskell
08:10:12 <Philippa> mm_freak: let's start with "don't need a library to be imperative at all, even if it is standard" :p
08:10:20 <mm_freak> bitonic: you even get while/for/foreach loops and goto in haskell…  how much more imperative can you get?
08:10:24 <bitonic> mm_freak: what did you mean by ‘imperative’?
08:10:36 <elliott> you can get higher-order functions in python too
08:10:43 <Philippa> elliott: quite
08:10:47 <elliott> http://docs.python.org/2/library/functools.html
08:10:52 <mm_freak> bitonic: programming in recipe mode, i.e. writing instructions
08:11:07 <elliott> or how about the kind of stuff we do with iteratee-type stuff? http://docs.python.org/2/library/itertools.html
08:11:30 <elliott> does that make Python as functional as Haskell? I hope not
08:11:32 <bitonic> mm_freak: that’s a bit vague.  I see it mostly as working on some mutable state, and in the cited languages you do that much more than in Haskell
08:11:34 <mm_freak> monoidal: haskell's variables are the true variables…  what you get in a language with side effects is mutable memory cells and haskell totally has those, even with better syntax
08:11:58 <Philippa> mm_freak: which is something we accomplish strictly by embedding. Swap the prelude out and arguably do notation and suddenly you don't have any imperative support at all
08:12:42 <Philippa> mm_freak: yeah, if I'm going to build this "nicer python", mutable variable declaration will be sugar for binding + cell allocation
08:12:44 <mm_freak> Philippa: (>>=) applications don't look much worse than do-notation…  it just looks unusual
08:12:54 <Philippa> mm_freak: and is *strictly an embedding*
08:12:58 <mm_freak> Philippa: and you need the standard library for putStrLn just like you need the standard library for printf()
08:13:24 <Philippa> yet C is clearly an imperative language with no libs at all, just one that can't say "Hello World"
08:13:40 <tgeeky> Philippa: can you unban me from #haskell-blah yet?
08:13:41 <mm_freak> Philippa: haskell doesn't have any functional features predefined either, when you remove the prelude…  so haskell is not a functional language?  is python more functional than haskell?
08:13:50 <bitonic> Philippa: ‘IO’ and ‘do’ are in Haskell, the language
08:13:54 <bitonic> as defined by the standard
08:14:09 <Philippa> mm_freak: lambda and function application aren't functional features? Do you consider the lambda calculus "not a functional language"?
08:14:15 <tdammers> mm_freak: haskell minus the prelude can still define and apply functions
08:14:29 <tdammers> and pass them around as first-class values
08:14:31 <mm_freak> Philippa: python has those as well and even comes with predefined reduce/map/…
08:14:50 <mm_freak> tdammers: most of today's languages can do that, even PHP
08:15:03 <companion_cube> come on, python doesn't really have lambdas
08:15:16 <mm_freak> my point:  obviously this is a bad metric to measure the functionalness/imperativity of a language
08:15:30 <mm_freak> C is not any more imperative than haskell…  it's just that we don't usually program imperatively in haskell
08:15:33 <Philippa> bitonic: sure. Don't make me piss about finding a neater phrasing of the concept I'm referring to
08:15:39 <mm_freak> but if we do, haskell turns out to be a better imperative language than C
08:16:06 <Philippa> mm_freak: Python can do all that and /still/ be less functional than the lambda calculus, for good reason
08:16:18 <monoidal> perhaps calling the distinction denotative/operational is better.
08:16:47 <mm_freak> Philippa: why?  python is bad as a declarative language, but there is nothing wrong with calling it a functional language
08:17:20 <Philippa> mm_freak: it's further from the center of mass of the cluster[fuck] concept that is "functional programming" than Haskell is
08:17:38 <mm_freak> Philippa: the point is that "functional" is vague to begin with
08:17:48 <hpaste> “J Tromp” pasted “primes.py” at http://hpaste.org/87075
08:17:53 <bitonic> Philippa: I think what you were saying is that in Haskell side effects can be neatly carved out of the language?  which is true eh :)
08:17:56 <Philippa> I just /described/ it as a cluster concept, how much more explicit an acknowledgement of that do you want?
08:18:24 <mm_freak> so is imperative…  when we define imperative programming as the art of passing instructions to the machine and manipulating mutable state, then haskell is in no way less imperative than C, PHP, python or assembly
08:18:28 <tromp> that looks like a functional language, but the runtime system is lacking...
08:18:45 <Philippa> bitonic: Not just that, but that if you factor the standard into "language-per-se" and "libraries" there's a strong case that even do isn't an imperative feature as such (it's just a renamed let)
08:19:06 <tromp> it only manages to compute primes up to 250
08:19:36 <mm_freak> as said, you can even have goto in haskell…  not as part of an expression language you define, but actually as part of a very common control structure
08:19:42 <bitonic> Philippa: well but mm_freak is right in saying that in the same way you can’t really do IO in C without system calls.  so along the same lines C, ‘language-per-se’, has no side effects
08:20:01 <Philippa> bitonic: *No*
08:20:12 <Philippa> that involves a redefinition of "side effect"
08:20:25 <bitonic> sorry, I meant IO
08:20:25 <monoidal> bitonic: it might have no IO, but modifying a global var usually is called a side effect
08:20:37 <mm_freak> bitonic: actually you can have visible side effects in pure C
08:20:52 <Philippa> you also have "probably-IO-in-practice" in the form of peeking and poking through pointers, which you /can/ do in C-per-se
08:21:07 <Philippa> hell, it can even cause nasal demons :p
08:21:11 <mm_freak> but then we are back to apples and oranges…  haskell without the prelude can't do /anything/
08:21:19 <Philippa> mm_freak: it can evaluate to something
08:21:43 <Philippa> as such, it can /possess meaning/
08:21:44 <elliott> it can do as much as the lambda calculus...
08:21:59 <mm_freak> Philippa: what can evaluate to something?  without the prelude you can't force anything
08:22:01 * bitonic is just not sure what the point of this conversation is.
08:22:21 <Philippa> mm_freak: Aaaaand you just exhibited a major misunderstanding of call-by-need
08:22:36 <mm_freak> Philippa: without the prelude even GHCi can't force expressions, much less display them…  you need to refer to some RTS features to be able to do anything
08:22:37 <quchen> I think you should clarify what you mean with Haskell here. There's the programming language used to make programs for computers, there's the ideal of a theoretical language, and there's the thing that the Report specifies. I see them mixed up a lot right now.
08:22:46 <elliott> mm_freak: I can define Nat and plus and two and then define four = plus two two
08:22:48 <bitonic> obviously C has mutability much more ingrained in than Haskell and it offers a very different interface to memory
08:22:57 <Philippa> mm_freak: without the Prelude GHCi doesn't exist and the interpreter's written in another language. No big deal.
08:22:59 <elliott> and confidently state that four evaluates to S (S (S (S Z)))
08:23:03 <mm_freak> elliott: and type-check them, but not evaluate them
08:23:09 <elliott> um, why the hell not?
08:23:21 <elliott> whatever application typechecks nats.hs can also tell me the value of four
08:23:37 <Philippa> for example: pen and friggin' paper. Or the turing machine I left over there ->
08:23:45 <Philippa> note that turing machines /also/ don't do IO
08:24:07 <mm_freak> elliott: you can't evaluate values…  you certainly still have the type system to evaluate types
08:24:17 <elliott> ??
08:24:19 <Philippa> mm_freak: you have some very strange notions
08:24:20 <bitonic> if turing machines themselves could do IO they’d be very different ehe
08:24:27 <elliott> I have no idea what you mean.
08:24:33 <Philippa> *I* can evaluate all the terms I like
08:24:37 <elliott> but I am sure at least one of your definitions is nonstandard
08:24:39 <Philippa> the terms just can't be said to evaluate themselves
08:24:56 <Philippa> they *do*, however, evaluate to other terms under a given semantics
08:25:03 <elliott> mm_freak: what do you count as "evaluating a value" (i.e. what must be done for something to count as that), and what counts as "the type system evaluating types"?
08:25:15 <mm_freak> Philippa: it's the way haskell is defined…  to cause any evaluation you need to force things…  regular haskell with the prelude gives you a number of options:  GHCi, main, seq, …
08:25:27 <elliott> the Haskell Report does not define GHCi
08:25:38 <Philippa> the "forcing" is when I say to myself "I wanna see what that evaluates to". Nothing to do with the program itself, any more than me asking my OS to call runghc
08:25:42 <elliott> note that GHCi could easily be written in C -- call it Hugs
08:25:54 <Philippa> mm_freak: right. You just get a looser type for main
08:25:56 <bitonic> mm_freak: I think what Philippa is saying is that as long as Haskell term have some semantics they can be ‘evaluated’
08:25:56 <elliott> the ability to evaluate four and get S (S (S (S Z))) in hugs does not depend on IO or main or anything
08:26:08 <elliott> (no, it doesn't necessarily depend on Show either)
08:26:14 <elliott> (Hugs has an option to use an internal printer)
08:26:18 <mm_freak> yeah, you could evaluate by hand and see the naked expression
08:26:25 <mm_freak> just like you can in lambda calculus
08:26:32 <elliott> how is that any more by hand than typing :main into GHCi and having it run your program?
08:26:33 <Philippa> mm_freak: you can evaluate with /any mechanism that implements the semantics/
08:26:39 * hackagebot computational-algebra 0.1.3.1 - Well-kinded computational algebra library, currently supporting Groebner basis.  http://hackage.haskell.org/package/computational-algebra-0.1.3.1 (HiromiIshii)
08:27:09 <mm_freak> Philippa: but what's the point of this discussion?  my original point is that haskell is not any less imperative than C/python/…
08:27:29 <bitonic> yet another terminology argument
08:27:32 <Kinnison> It's a pity we're unlikely to be able to use hugs to bootstrap ghc :-(
08:27:33 <Philippa> mm_freak: and mine is that if I'm allowed these distinctions I can point out exactly how it is, in fact, less imperative
08:27:51 <shachaf> Or the Church numeral (\s z -> s (s (s (s z)))))
08:28:00 <monoidal> mm_freak: seq does not give extra power to "force" in this context.
08:28:06 <klrr> my lisp is starting to get somewhere :) https://gist.github.com/klrr/5503002 , should i use a Map instead of a simple list of pairs, or should i maybe use IORef? or will the simple list of pairs be enough to hold the state?
08:28:10 <mm_freak> Philippa: how?  because you get a predefined while loop?
08:28:12 <Philippa> bitonic: yeah. I reckon the best candidate for a 'canonical' solution's still a minor tweak of PvR's work - which aligns with my usage
08:28:17 <elliott> yeah, you can define seq for any concrete type like Nat anyway
08:28:27 <Philippa> mm_freak: because you get predefined *assignment*
08:28:40 <Philippa> because you get a predefined mutable heap
08:28:40 <elliott> seq's addition is just the polymorphism and working on functions (and weirdo primitive things like IO or whatever)
08:28:40 <mm_freak> monoidal: it does actually, but it can't act as the original forcer
08:28:44 * shachaf notes that arguments about "what's more functional" are pointless.
08:28:46 <bitonic> saying that ‘Haskell is as imperative at C’ is misleading to downright wrong, in today’s world :P
08:28:53 <bitonic> but yeah it’s all poooointless
08:29:03 <monoidal> if you can't "see" that with definition x = 2 + 2 the value x evaluates to 4, adding seq to your tools won't help
08:29:06 * Kinnison heads off
08:29:18 <bitonic> Philippa: PvR?
08:29:33 <Philippa> shachaf: I offered a reasonable informal criterion for that earlier and effectively had the very existance of that criterion used as an argument that there wasn't one
08:29:43 <mm_freak> Philippa: are you arguing that haskell is less imperative because you need to import a module to get assignment?
08:29:44 <Philippa> bitonic: Peter van Roy, sorry
08:29:59 <Philippa> mm_freak: because you have to *embed an entire imperative language into it*, yes
08:30:13 <bitonic> Philippa: oh, the Oz book guy (right?)!  yes they like categorising thing
08:30:18 <Philippa> you might as well decide C's a good functional language because you can write a lambda calculus interpreter in it
08:30:30 <bitonic> that book is hefty
08:30:44 <Philippa> yeah, it actually ripped up a compartment in one of my bags
08:30:49 <mm_freak> Philippa: you need to embed an entire concurrent language into it, yet we call haskell a language that supports concurrency, so that's not reasonable
08:31:04 <Philippa> mm_freak: "supports X" and "is X" are different statements
08:31:06 <dolio> Haskell doesn't support concurrency, I think.
08:31:08 <dolio> GHC does.
08:31:26 <mm_freak> Philippa: so C "is assignment"?
08:31:31 <mm_freak> it supports assignment
08:31:35 <Philippa> I am happy to say that Haskell has /support/ for imperative programming
08:31:43 <tac> dolio: No one uses "Haskell"
08:31:56 <dolio> tac: Okay.
08:31:58 <Philippa> C *has* assignment as a fundamental part of it
08:31:59 <monoidal> mm_freak: I feel that you are a "imperative nihilist", it seems you could call every Turing-complete language imperative since you can embed imperative constructs there.
08:32:23 <mm_freak> Philippa: fundamental in what way?
08:32:32 <mm_freak> monoidal: exactly
08:32:59 <Philippa> mm_freak: removing it totally changes the semantics of the language as specified. You'd remove the notion of the heap, for example
08:33:02 <tac> monoidal: I believe that's called the Turing Tarpit in common lore.
08:33:06 <elliott> so every TC language is functional, imperative, logic, nondeterministic,
08:33:20 <elliott> concurrent, event-based, ...
08:33:22 <mm_freak> hell, even lambda calculus can be imperative, if you are really a masochist…  but lambda calculus is arguably a very bad language for imperative programming
08:33:24 <dolio> Assignment is a language construct in C. Not a library.
08:33:35 <elliott> I don't believe that you really believe that
08:33:45 <Philippa> mm_freak: I would say that imperative programming can be embedded in it. I would *not* say it /supports/ it.
08:33:53 <mm_freak> but haskell is a good language for imperative programming, IMO better than most languages we would intuitively call "imperative languages"
08:33:59 <Philippa> (and I would concur that the embedding is painful)
08:34:12 <Philippa> mm_freak: right. But that's still a different statement
08:34:17 <mm_freak> Philippa: yes, but haskell actually supports imperative programming
08:34:20 <bitonic> mm_freak: what’s the point of having the word ‘imperative’ in the first place if it’s as you say?
08:34:24 <mm_freak> there is no such thing as an "imperative language"
08:34:27 <bitonic> what languages are not imperative?
08:34:36 <bitonic> so wait what’s a good use of the word?
08:34:44 <Philippa> mm_freak: bullshit. Cluster concept /= non-existence
08:34:54 <elliott> if you don't think there's such a thing as an imperative language, don't get into a long, drawn-out argument where you are arguing against "Haskell is not an imperative language".
08:34:57 <elliott> it's just dishonest.
08:35:02 <Philippa> elliott: quite.
08:35:09 <elliott> or at least state this position first
08:35:27 * bitonic had understood the opposite, since mm_freak said multiple times that Haskell *is* imperative :P
08:36:14 <elliott> me too
08:36:26 <elliott> hence my bafflement.
08:36:39 <oconnor0> if i go to http://hackage.haskell.org/packages/search.html and search, i get a 403 Forbidden\
08:36:56 <Taneb> Wow
08:36:56 <mm_freak> you're just twisting my words…  i'm not a native english speaker, so this discussion is very difficult for me, but in any case my point is that you can do imperative programming in haskell, and IMO haskell supports you there much better than most languages do, including those that are commonly called "imperative languages"
08:37:04 <Taneb> flip is just a restricted distribute
08:37:34 <monoidal> oconnor0: works for me
08:37:42 <monoidal> oconnor0: whoops, sorry, doesn't
08:37:45 <Taneb> :t distribute
08:37:46 <lambdabot>     Not in scope: `distribute'
08:37:46 <lambdabot>     Perhaps you meant `distrib' (imported from Control.Lens)
08:37:50 <Taneb> :/
08:38:04 <Philippa> mm_freak: which we're not disagreeing with. I also prefer to do my constraint logic programming in Haskell
08:38:05 <mm_freak> and "there is no such thing as an imperative language" = "imperative language" doesn't have a formal definition
08:38:29 <Philippa> yeah. That's... not a polite usage
08:38:32 <bitonic> mm_freak: don’t feel bad, this is a discussion on what ‘imperative’ means.  you’re basically saying ‘I can model mutability in Haskell just as well (maybe better) than in C’!  Philippa is simply saying ‘C takes side effects and memory management etc. in a very different way from Haskell’.  you’re arguing different things
08:38:49 <oconnor0> monoidal: do you know who i can report that to?
08:39:21 <monoidal> oconnor0: not sure who is the hackage maintainer
08:39:26 <Philippa> "cluster concept" is a notion in philosophy (which has what /they/ consider a formal definition, even if we wouldn't) for handling things that aren't formally or uniquely defined
08:39:55 <monoidal> oconnor0: Ross Patterson is responsible for new accounts at hackage. if you won't find any better reference, I'd contact him.
08:40:15 <mm_freak> Philippa: but you can find notions of imperativity that would call all, some or even no languages imperative
08:40:36 <mm_freak> so i question it even as a cluster concept
08:40:54 <oconnor0> monoidal: thanks.
08:41:07 <Philippa> mm_freak: sure. So: I believe more consider C an imperative language than Haskell, and that this is for the reason that "imperative language" is a distinct cluster within "programming language"
08:41:45 <Philippa> I also offered something related to that as my measure earlier (I phrased it in terms of "center of mass")
08:42:01 <hpaste> Zamarok pasted “recurWhile” at http://hpaste.org/87076
08:42:02 <Zamarok> Is there a better/built-in way to do this? (my hpaste)
08:42:10 <Philippa> (see also: "design space")
08:42:29 <mm_freak> Philippa: yes, you can measure it that way:  languages are more imperative when a greater percentage of code is written imperatively
08:42:52 <Philippa> that's a related but different metric
08:43:07 <monoidal> mm_freak: in this case it's hard to defend that haskell "the best imperative language"
08:43:10 <Philippa> (mine is actually a meta-metric)
08:43:16 <monoidal> *haskell is "the best imperative language"
08:43:18 <mm_freak> Philippa: my metric on the other hand:  how well does the language support you in programming imperatively?
08:43:31 <mm_freak> monoidal: it's /a/ metric, not /my/ metric
08:43:39 <monoidal> ok.
08:43:45 <Philippa> yeah. I find the distinction between being imperative and having support for imperative programming to be useful enough to be worth not erasing
08:44:54 <Philippa> while I'm admittedly relocating your metric somewhat, given that relocation the two can coexist in the same framework
08:45:08 <mm_freak> Philippa: your points are just as valid as mine, but we are discussing different models
08:45:16 <Philippa> you are welcome to value support more highly, of course!
08:45:52 <Philippa> we are, but mine is... less aggressive towards others when phrased as we each have
08:46:37 <Philippa> you were previously, based on yours, asserting mine /can't exist/. I'm happy to put that down to language and sorry that's been difficult.
08:46:37 <mm_freak> Philippa: i do, because for example when it comes to choosing a language for imperative programming, the center-of-mass framework will be utterly useless, because you would come to the conclusion that you should use assembly
08:46:40 * hackagebot snap 0.11.3.1 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.11.3.1 (DougBeardsley)
08:47:04 <mm_freak> Philippa: that's my original point and the reason why i prefer the support framework
08:47:18 <bitonic> mm_freak: I don’t think ‘imperative programming’ is ever a need in itself
08:47:21 <Philippa> mm_freak: Mine isn't "the center-of-mass framework". It's a framework in which "center-of-mass" is one of a number of questions that can be phrased
08:47:25 <bitonic> or in any case, I don’t think it that way
08:47:47 <Philippa> bitonic: perhaps, but it can be a strong preference and CTM gives a reasonable argument as to why
08:47:48 <mm_freak> Philippa: i was very careful not to say /your/ framework ;)
08:48:08 <mm_freak> bitonic: i agree
08:48:16 <Philippa> mm_freak: Sure. I still need a term of reference to hang mine on, though :p
08:49:55 <Philippa> and there's something... fundamental here. For example, from my framework we can try the statement "a less imperative language can actually support imperative programming better" on for size - and then compare Haskell to, say, Frank + a similar level of development
08:50:26 <Philippa> (I'd call Frank "more imperative than Haskell", even if it arguably accomplishes it by making the embeddings easier)
08:52:17 <Philippa> now, I probably could've done more to let you know I don't disagree with the notion that "Haskell is good at/has good support for imperative programming" (phrased from within my framework)? But it's kinda hard to do when someone else's phrasing is as strong as yours were. And I guess I'm mostly saying this so you've got some example language to play with for a discussion like this: I hope it's been useful rather than an
08:52:18 <Philippa> noying or patronising
08:53:27 <Philippa> hi conal - I imagine you would've been helpful in the discussion we more or less just wrapped up, even if we don't see eye-to-eye on how to handle things
08:53:56 <conal> Philippa: i'll take a look at the log.
08:56:51 <mm_freak> Philippa: i don't disagree with you — never have during this discussion…  i just have a different notion and your "bullshit." response to a part of it was indeed annoying ;)
08:58:03 <Philippa> mm_freak: So were some of your (non-)existential statements! Have you met Chesterton's definition of "bullshit"?
08:58:24 <mm_freak> no
09:00:12 <Philippa> It's useful - Chesterton calls something bullshit when it's not necessarily a lie, but has been said without regard to whether it's true. Given what you've said about English I don't think that's an entirely fair thing to hold against you. People will tend to interpret "X does not exist" as "forall X. X does not exist" rather than "exists X. X does not exist" though?
09:00:52 <Philippa> (Chesterton's "bullshit" is good for circumstances when you want to call a politician a liar but the politician may have pointedly not investigated the truth /so that they are not technically lying/ but are quite possibly misleading, for example)
09:02:08 <luite> conal: last year you asked about compiling diagrams to some standalone output that still has some interactivity (if i remember correctly). are you still interested in that? there's a gsoc proposal for it now
09:02:13 <sellout-> “bullshit” implies not so much an intent to deceive, but an intent to be seen as “right” without consideration as to whether the statement is true.
09:02:20 <mm_freak> Philippa: huh?  i don't think i made a quantification like that even with my limited english
09:03:17 <conal> luite: i've forgotten what i asked about, but i'm still interested in closely related questions. what's the gsoc proposal?
09:03:20 <Philippa> mm_freak: okay, more fully? "forall X. X is a reasonable definition of the word in question. X does not exist". I don't think I was the only person to read it that way
09:03:38 <mm_freak> Philippa: i think my only statement was:  forall x, imperative haskell > imperative x
09:03:51 <oconnor0> anyone have recommendations on what library to use for parsing command line options. (http://www.haskell.org/haskellwiki/Command_line_option_parsers has quite a few options)
09:03:59 <mm_freak> where 'imperative' was in my support framework
09:04:02 <Nisstyre> sellout-: "bullshit", to me, means not only an intent to deceive but also a lack of regard for the ability of the person hearing your bullshit to realize that it's bullshit.
09:04:11 <mm_freak> Philippa: and that's the source of the misunderstanding
09:04:13 <Clint> oconnor0: optparse-applicative is the current fave, i think
09:04:58 <mm_freak> oconnor0: cmdargs for shortest possible code, optparse-applicative for nice, composable code
09:05:10 <Philippa> mm_freak: I'm happy that's the meaning you meant, yeah. It's... not what was said
09:05:11 <mm_freak> my personal favorite is the latter
09:05:29 <oconnor0> thanks.
09:05:31 <Clint> dunno, i shortened code by switching from cmdargs
09:05:39 <luite> conal: the gsoc is about making a backend for diagrams that makes it easy to compile things like f :: Double -> Double -> Diagram to a user interface that has two input sliders and a diagram output (as well as a pastebin-like site to easily experiment with them, share code)
09:05:55 <mm_freak> Clint: hard to imagine…  cmdargs is about as short as you can get
09:06:01 <Clint> mm_freak: i mean in the overall program
09:06:04 <mike4_> Haha! --> http://rebelscience.blogspot.com/2007/09/functional-programming-is-worse-than.html
09:06:08 <luite> conal: the result is some javascript and an html snippet that can be run in a browser, included in other pages etc
09:06:23 <mm_freak> Clint: i don't think that's related to the choice between cmdargs and optparse-applicative
09:06:34 <mike4_> please check that link that gives an extensive critique on FUNCTIONAL PROGRAMMING.
09:07:12 <mm_freak> Clint: but applicative style has this weird property that when you start using it in one part of your program, some other parts improve as well =)
09:07:33 <oconnor0> i'll check out optparse-applicative. :)
09:07:39 <elliott> mike4_: please don't troll
09:07:42 <conal> luite: oho! maybe it could also work with webgl. i have a DSEL compiler that turns elegant denotative haskell code into crazy-fast glsl, which could then be plugged into webgl, with auto-generated GUIs (as in Eros/TV).
09:07:53 <mike4_> Why go functional even! Please!
09:07:54 <Philippa> that URI looks suspiciously familiar, yeah
09:08:01 <mike4_> I'm not trolling....
09:08:07 <Philippa> why go non-functional?
09:08:16 <elliott> I've seen that site enough to know it's trolling.
09:08:23 <mike4_> it's Easier!
09:08:31 <elliott> but more generally, joining #haskell just to link someone saying functional programming is worse than X is a trolly action.
09:08:33 <Philippa> maybe for you. Hasn't been for me for a long time
09:08:34 <mm_freak> mike4_: i think i've seen that…  ignore it
09:08:59 <mike4_> haha oh but what is your opinion about it.
09:09:00 <mm_freak> i didn't bother to read all of it, though…  if there is any truth to that article, it's very well hidden
09:09:04 <mike4_> Why ignore it?
09:09:13 <luite> conal: the current plan is compiling the whole diagrams code to javascript with ghcjs. there's no webgl support yet, but it wouldn't be terribly hard to add it (just a lot of work, probably)
09:09:31 <Nisstyre> mike4_: Haskell doesn't parallelize based on functions
09:09:41 <conal> luite: oh, wow. ambitious.
09:10:01 <Nisstyre> well, I mean it does parallelize computations that include function calls
09:10:04 <elliott> mike4_: every time you have been in this channel (as philosophy or mike4) it has been to talk about how difficult Haskell is. why is that?
09:10:04 <mike4_> They seem to make an active point. Why functional indeed, it makes no sense, it just adds a big thick layer of complexity ontop of programming.
09:10:09 <Nisstyre> but it doesn't just take a bunch of functions and run them in parallel
09:10:18 <mm_freak> mike4_: it's a weird thing to say that stateful programming is safe/safer
09:10:28 <elliott> also, why are you continuing to make baseless assertions?
09:10:53 <luite> conal: compiling diagrams already works though, that was my job :p (also gloss works, http://hdiff.luite.com/gloss/styrene/ , faster, but much less nice)
09:10:57 <Iceland_jack> (because apparently it's easy to get #haskell-ers to respond to baseless claims?)
09:10:57 <Philippa> mike4_: let's grab a pen and some paper and do some computing, yeah?
09:11:07 <Philippa> After all, back when "computer" was a job title that's exactly how it was done
09:11:15 <mike4_> elliot I'm not trolling. I'm trying to understand why there is an added layer of difficulity ontop of something that should be used to simplify real world problems.
09:11:26 <Philippa> even the turing machine's based on that - that's what the tape's about
09:11:48 <tac> Iceland_jack: you mean claims like this? http://rebelscience.blogspot.com/2007/09/functional-programming-is-worse-than.html
09:11:49 <conal> speaking of gsoc, has anyone proposed a foundation gui library that supports multiple platforms, ghci, and opengl? it's been a terribly long time since we've had one.
09:11:50 * tac ducks
09:11:52 <elliott> mike4_: your question presupposes that functional programming has no value (that it is an "added layer of difficulty"), but I think you know that.
09:11:54 <Philippa> mike4_: there isn't. It's a layer removed, it's just that removing that layer forces people to see complexity they were already dealing with
09:12:35 <mm_freak> mike4_: unless you identify abstraction as difficulty your statement is wrong
09:12:44 <Iceland_jack> > Computer geeks are notoriously political animals who cannot fathom that others may look down on their supposed intellectual superiority.
09:12:51 <Iceland_jack> At least they got something right :)
09:13:03 * elliott sigh
09:13:04 <Philippa> Iceland_jack: yeah. Failure to self-apply, though?
09:13:07 <Nisstyre> mike4_: some of his claims are demonstrably false
09:13:12 <Nisstyre> "FP is non-deterministic" is bullshit
09:13:19 <luite> conal: no proposals this year for that... might also be too ambitious
09:13:32 <Iceland_jack> I'm not sure writing an entire article about the “FP geeks” will shrink their ego though ;)
09:13:35 <conal> luite: maybe so. i wonder how we can get there.
09:13:39 <Philippa> Nisstyre: that's a framing issue, actually
09:13:51 <luite> and gui libs tend to be poorly maintained, there would need to be a good plan to continue after the project ends
09:14:07 <Philippa> it's quite easy for an FPL to not determine certain things that someone who cares about implementation issues wants determined
09:14:33 <mm_freak> mike4_: i'm not sure whether you're trolling, but if you're indeed interested in this, this article will answer some of your questions:  http://www.haskell.org/haskellwiki/Why_Haskell_just_works
09:14:38 <Philippa> (see also: "GCed languages aren't deterministic about when deallocation happens" - for appropriate values of "deallocation" that's true, for others it's not)
09:15:02 <mike4_> I think it's just non automized adding of complexity to something that could have been done in a simpler way. it's like "Keep it simple Stupid!". Why would you want to complicate programming at all if there was another more effortless and simpler method?
09:15:05 <fizbin> Nisstyre: Lazy languages are non-deterministic about when a particular calculation happens.
09:15:30 <elliott> I don't think mike4_ wants to be convinced otherwise.
09:15:33 <mike4_> I'm not trolling. I'm interested in your opinions about this for a minute of my break.
09:15:39 <Nisstyre> fizbin: he was talking about functional programming languages
09:15:48 <Philippa> "adding of complexity"... to what?
09:15:56 <mm_freak> mike4_: the question can't be answered, because we are in fact not complicating things
09:15:58 <Nisstyre> Scheme's evaluation strategy is perfectly deterministic
09:15:59 <Philippa> what baseline are you measuring against?
09:16:00 <mike4_> elliott: please just don't counter me with that sort of thing.
09:16:22 <Rotaerk> mike4_, the problem is a misunderstanding on your part
09:16:32 <Rotaerk> the premise of your question
09:16:38 <Philippa> mike4_: ever traced an imperative program by hand?
09:16:44 <osfameron> that rebelscience guy has a big bee in his bonnet about "Using Variables to Automatically Find and Resolve Data Dependencies"
09:17:01 <mm_freak> mike4_: functional code is usually shorter, correct and fast…  as an additional bonus, a functional programmer can understand functional code very quickly, because you can view everything in isolation…  this is not true for imperative programming
09:17:14 <latermuse> mm_freak: haskell code is usually shorter, correct, and fast
09:17:35 <danr> are we playing feeding the troll?...
09:17:44 <fizbin> I'll concede that predictability is vital in safety-critical systems. I don't see how one gets from "must be predictable" to "functional bad".
09:17:49 <Philippa> danr: it's the #haskell way
09:18:00 <elliott> danr: aren't you used to it by now? :)
09:18:15 <Nisstyre> elliott: apparently that post is a joke
09:18:21 <fizbin> latermuse: Except when the haskell code is only two of those three.
09:18:33 <Nisstyre> so I see why he made obviously false claims now
09:18:35 <mike4_> I don't understand why do you call me a troll when I say Functional Programming is an added layer of complexity that isn't even required to execute a program in the normal expected way. But alright..
09:18:43 <Philippa> "normal expected way"?
09:18:49 <mike4_> Keep it SIMPLE!
09:18:57 <mm_freak> mike4_: simple ≠ easy
09:19:04 <mm_freak> mike4_: by your reasoning you don't need anything but assembly
09:19:08 <Nisstyre> mike4_: then we should be using the lambda calculus
09:19:12 <Nisstyre> that's about as simple as it gets
09:19:13 <latermuse> its an added layer of abstraction, not compelexity
09:19:14 <tgeeky> mm_freak: is the origin of the "additional bonus" just the fact that you can do equational reasoning with the code?
09:19:14 <levi> Whenever you use dynamic memory allocation, your predictability is going to go out the window unless you have a very specialized allocator. In fact, you can probably get better real-time behavior with a real-time GC than a standard malloc/free implementation.
09:19:18 <bartavelle> exactly, the only normal expected way would be assembly
09:19:18 <elliott> are we just going to counter this claim over and over again without it changing in response to any input given in reply?
09:19:33 <Philippa> Nisstyre: SK calculus. Lambda calculus needs capture-avoiding substitution, after all
09:19:46 <Nisstyre> Philippa: good point
09:20:03 <mm_freak> tgeeky: part of it…  the other part is:  because of the lack of side effects and the compositional style you don't need to read the entire code or understand the entire project to reason about a specific piece of code
09:20:17 <tgeeky> mm_freak: that is the same point, though
09:20:29 <tgeeky> the equation reasoning is only valid when side effects are correctly dealt with
09:20:33 <Philippa> levi: it's an unconventional FPL that doesn't have to do any dynamic allocation, though
09:20:46 <mm_freak> tgeeky: not really, because you can do equational reasonoing for a complex piece of code…  composability is not part of the equation
09:21:19 <levi> Philippa: I'm just saying that it's an unconventional application in general that doesn't have to do any dynamic allocation, so the problem is not unique to FPLs.
09:21:42 <tgeeky> mm_freak: yes, I didn't affect the compsability. I was arguing that equational reasoning is what lets you start to address composability
09:21:44 <Philippa> levi: Not to the same extent at all
09:22:02 <mm_freak> tgeeky: agreed
09:22:27 <mike4_> There are a million ways to do things programmatically I guess. But really.... for simplicity's sake, Functional Programming way isn't the better way in my opinion.
09:22:27 <Philippa> (I'm not happy to imply that C is an unconventional language yet!)
09:22:33 <tgeeky> mm_freak: [anything could happen] . [anything could happen] is not a great starting point :O
09:22:53 <levi> Your memory profile will be more deterministic if you manually alloc/free, but the time spent for each malloc/free operation will likely be less deterministic than if you use a realtime garbage collector.
09:23:13 <mm_freak> mike4_: you should try it
09:23:16 <mm_freak> give haskell a shot
09:23:40 <mike4_> hm
09:23:45 <Philippa> heck, just do a little FP on paper. If you're willing to spend time cranking the sums it's not hard to write a parser /and test it/
09:23:46 <tgeeky> mike4_: "better" is not something that is defensible at all. It doesn't really have a good definition. Try defining it in natural languages. Is French better than English?
09:23:57 <Philippa> I'd hate to do that in, say, C
09:24:13 <maukf> tgeeky: yes
09:24:14 <bartavelle> tgeeky, way more cursing words, so I'd say yes
09:24:26 <tgeeky> see? two responses, two different metrics :)
09:25:13 <mm_freak> mike4_: get the haskell platform and try it out…  that will save you from further preconceptions and also show you why functional programming is a good choice =)
09:25:20 <mm_freak> @where hp
09:25:38 <mm_freak> oh my
09:25:46 <mm_freak> http://www.haskell.org/platform/
09:25:49 <lazy-no-n> read learn you a hasekll, mike4_
09:25:50 <fizbin> @hp
09:25:55 <maukf> fizbin: ENOBOT
09:26:01 <quchen> Lambdabot isn't here.
09:26:03 <fizbin> Wah!
09:26:03 <mm_freak> EMOBOT
09:26:05 <elliott> Cale!!!!!
09:26:15 <quchen> Cale is Lambdabot?
09:26:34 <elliott> Cale begats lambdabot
09:26:35 <fizbin> Cale is the keeper of the lambdabot.
09:26:55 <monoidal> mike4_: even if you don't intend to use FP in your work, learning it will teach you a lot. many mainstream languages get functional features (for example, python got list compherensions, C# has LINQ, java will get lambdas etc.). it's good to understand where did they come from.
09:27:30 <fruitFly> I'm really feeling like haskell is getting started in chap 6 Higher Order Functions of LYAH... I can't to start coding some real stuff. The next chapter is Modules.. and I'm just wondering what are some simple ideas for programs that will help put to practice all that I'm learning so far?
09:27:36 <mm_freak> mike4_: if you don't mind funny pictures you can read the LYAH book online…  it's a good way to get started:  http://learnyouahaskell.com/
09:27:40 <tgeeky> mike4_: don't let my correction deter you from using Haskell. Haskell is a fine language, and can do anything you'll want or need to do.
09:27:41 <fruitFly> I can't WAIT*
09:27:49 <levi> Philippa: C applications, especially large applications, use *tons* of dynamic allocation via malloc/free. Even low-level kernels need to do quite a bit of it, but they typically have more customized allocators. It's not nearly as much as in a FPL like Haskell that makes thunks all over the place, but the memory management is tweaked such that allocation is *way* cheaper and more deterministic than it is in a typical C malloc.
09:28:09 <mike4_> ok
09:28:16 <Philippa> levi: A substantial subset of C applications does *no dynamic allocation whatsoever*
09:28:16 <mm_freak> fruitFly: you could write a command line application or a web app
09:28:37 <arkeet> fruitFly: but before you do that, you should probably at least read chapter 9 ;)
09:28:37 <mm_freak> fruitFly: web frameworks tend to use advanced haskell features, so a command line app is probably the easier way to get started
09:28:41 <Philippa> levi: that is something that has been very intentionally considered during the standardisation process
09:28:44 <fruitFly> mike4_: I'm loving LYAH so far... very succint and informative
09:29:05 <tac> > 1 + 1
09:29:08 <levi> Philippa: How much C programming do you do?  There is definitely a subset, but I wouldn't say it's the norm, even in modern embedded development (which is my field of employment).
09:29:14 <lambdabot>   2
09:29:27 <fruitFly> arkeet: I will get there soon... Ive been writing so liitle programs on the way to apply what Ive been learning (just a few liners) but I was just wondering the next step.
09:29:40 <mm_freak> @botsnack welcome back, buddy =)
09:29:46 <lambdabot> :)
09:29:55 <levi> The more deeply embedded, low-level, and safety critical you get, the less dynamic allocation you do.
09:30:01 <fragamus> YES!!! I HAVE MASTERED THE BANANAMORPHISM
09:30:09 <Philippa> levi: These days? As little as I can. Modern embedded development is big enough that it's not the norm, yeah. It gets more frequent as things are treated as more safety-critical though (hello NASA), much as we also get scary shit like life support machines running winXP and hooked up to the 'net
09:30:10 <levi> But that kind of development is slow and expensive.
09:30:19 <Philippa> no argument there
09:30:38 <cathoderay> a funny comic -> http://changingbit.blogspot.com.br/2013/05/rtfm.html
09:30:55 <fruitFly> mm_freak: a command line app? like use haskell to do some OS commands? could you give me an example.. I'm super noob if you haven't realized already lol :P
09:31:26 <tgeeky> levi: There are a handful of prolific coders in #haskell whose prolicifc-ness attests that one can code quickly and cheaply.
09:31:27 <Philippa> now, I know how I'd start building an FPL that could do such work reasonably verifiably
09:31:28 <mm_freak> fragamus: great, next learn the supercalifragilisticexpialidomorphism
09:32:04 <levi> tgeeky: But they're not programming under those kinds of constraints.
09:32:05 <cschneid> fruitFly: I've been learning haskell by working through this: http://www.matasano.com/articles/crypto-challenges/ -- learning crypto & codebreaking at the same time.
09:32:09 <mm_freak> fruitFly: write a simple REPL for a small expression language
09:32:11 <nebnesknarf> That kind of development results in systems that need to be re-compiled or at least re-started in order to add, say, a new I/O signal. Inknow because I am working with such beasts. Not always funny.
09:32:17 <maukf> write a command line calculator
09:32:21 <cschneid> fruitFly: it's cool because mostly you don't need to do much fancy haskell stuff to get answers out
09:32:23 <levi> No doubt they could if they applied themselves to it, but it would undoubtedly slow them down!
09:32:35 <tgeeky> levi: they probably arne't using Haskell either, so perhaps it's their fault!
09:32:40 <mm_freak> fruitFly: what cschneid said…  the crypto challenge is neat
09:32:45 <fruitFly> cschneid: oh shit... that's exactly where my interests lie at... I saw that on reddit... what do you think of the challenges?
09:32:54 <tgeeky> levi: I know there is very little Haskell use at CERN, and they certainly work under pretty stringent constraints
09:33:00 <lazy-no-n> what challenges?
09:33:01 <levi> tgeeky: I think the original point is that you *can't* use Haskell for those domains.
09:33:02 <monoidal> fruitFly: if you know how to get random numbers, write a guessing game (computer chooses a number and tells you if the guess is too lowor too high)
09:33:11 <tgeeky> levi: I doubt that's true.
09:33:19 <mm_freak> fruitFly: /join ##crypto =)
09:33:24 <fruitFly> cschneid: I'm interested in crypto but am learning some haskell first. Are you into bitcoin?
09:33:33 <Philippa> levi: rather, it's a lot trickier to do so safely. In an "inspect the compiler IR and/or asm to be sure" way
09:33:38 <levi> How many mature haskell implementations are there for processors other than x86?
09:33:48 <Philippa> so, y'know, *I* sure as hell wouldn't
09:33:49 <mm_freak> fruitFly: lambdabot is there, too ;)
09:33:59 <Philippa> GHC works reasonably on ARM, GHCi doesn't
09:34:42 <Philippa> ("reasonably" - it's still pretty slow on a raspi but comfortable on the Samsung chromebook)
09:35:00 <cschneid> fruitFly: I am into bitcoin, but not related to haskell.  Those crypto challenges are cool since you get to use haskell to solve actual problems. But the problems are phrased in such a way at first that you don't need to do anything fancy beyond pure functions and a tiny bit of IO to print results
09:35:02 <elliott> raspi always makes me think raspy, as in of a voice
09:35:03 <levi> Working 'reasonably' for someone playing with it is entirely different than the programming domain we're discussing, though.
09:35:07 <Philippa> (I have zero intention of running it on one of the 50MHz embedded chips)
09:35:11 <fruitFly> mm_freak: expression language... the crypto challenges sound really neat too
09:35:20 <fragamus> mm_freak: so I'm starting to understand… these 4 recursion forms are well understood and have properties that we can define, as opposed to arbitrary code that isn't as readily definable
09:35:22 <mm_freak> fruitFly: i've implemented a large number of crypto-relevant number theory algorithms in haskell…  it's a great way to get started in doing high performance number crunching in haskell
09:35:34 <tgeeky> levi: so you would have to assume the cost of developing your thing + the cost of porting a very small part of GHC to [your platform] with support from the GHC team themselves
09:35:54 <mm_freak> fruitFly: with "expression language" i basically mean what maukf said…  a command line calculator
09:35:55 <Philippa> levi: Sure. So you'd be looking to check LLVM's okay, for example
09:35:56 <levi> Haskell just isn't currently designed for deeply embedded, safety-critical systems. Not to say you couldn't make a new Haskell-like language that was.
09:35:59 <tgeeky> levi: which still might be much cheaper.
09:36:22 <fruitFly> mm_freak: cschneid WOW amazing guys... I will definitely take a look at the crypto challenges... what are you thinking of them cschneid ?
09:36:23 <fruitFly> :D
09:36:38 <levi> tgeeky: Almost certainly not.
09:36:49 <mm_freak> levi: although the part haskell isn't designed for is the "embedded" bit, not the "safety-critical" bit
09:37:03 <cschneid> fruitFly: I'm on problem 6ish, with not much work. So far it's been cracking single-character xors, and now onto multi character xors. It's not conceptually hard, but spending the time to learn haskell around it has been useful
09:37:12 <CaptainLex> levi and tgeeky: what is the metric of "safety-critical?" Just trying to keep up :)
09:37:14 <levi> Safety-critical is often as much about real-time constraints as it is about not making logic errors.
09:37:18 <cschneid> simple enough that you can figure it out in a night of work, but hard enough that it isn't stupid fib examples.
09:37:26 <levi> And Haskell is not designed for real-time execution constraints.
09:37:36 <hpaste> “Anonymous Coward” annotated “SDL-mixer not installing” with “SDL-mixer not installing (annotation)” at http://hpaste.org/80608#a87079
09:37:37 <tgeeky> I suspected you meant real-time
09:38:03 <levi> Most embedded systems have some sort of real-time constraints.
09:38:10 <Philippa> CaptainLex: "if it goes wrong, someone's [generally physical] safety can be compromised". Anything from not operating the door while someone's in the doorway to not detonating the entire arsenal of nukes
09:38:38 <mm_freak> levi: "safety-critical" is a very broad term though, and i think that "real time" is the only requirement that the current haskell implementations don't meet…  and even then you can employ something like the atom library
09:38:48 <fruitFly> cschneid: so why are you learning haskell otherwise (instead of a lang with dependent types)? for it's general applicability?
09:38:50 <fragamus> :t foldr
09:38:54 <lambdabot> (a -> b -> b) -> b -> [a] -> b
09:38:54 <CaptainLex> Ah. It seems counter-intuitive to me that languages more susceptible to programmer error would be better for those applications, but I can see how performance would be an issue
09:38:56 <cschneid> fruitFly: email and ask for the questions - at worst it'll be interesting to look at and/or solve elsewhere.
09:39:12 <cschneid> fruitFly: uhh, since it's interesting. I day-job in ruby, so was like: "what's the most different possible" and then did that
09:39:16 <fruitFly> fragamus: just learned that today :D
09:39:48 <CaptainLex> cschneid: At a conference at my school recently, a  guy gave a presentation on how similar Ruby and Haskell
09:39:55 <mm_freak> levi: in other words, you can actually program embedded safety-critical devices using haskell without actually compiling haskell to those devices
09:39:59 <Philippa> mm_freak: there's also how convinced you are that the toolchain's not got a critical bug in it. I still wouldn't want to use GHC for a life support machine even if I were satisfied I had a realtime RTS and wasn't worried about other resource usage issues
09:40:20 <Philippa> mm_freak: yeah, Haskell-as-metalanguage is still a good approach
09:40:24 <levi> Anyway, my point is that in the world where you're doing fairly standard application-level programming with lots of dynamic allocation/freeing, A suitable Haskell compiler with a real-time garbage collector could probably get you what you need such that your real-time performance is on par with or possibly more predictable than a C/C++ program that does manual management of dynamic memory.
09:40:27 <Philippa> but you need to know what it's targetting too
09:40:29 <cschneid> CaptainLex: yeah? What argument that they're similar?
09:40:30 <fruitFly> cschneid: aah... cool. And so you just have a general interest in crypto then? I'm interested in the scalability of crypto currency and related systems. I hope to make a difference in this area.
09:40:45 <Philippa> levi: Yeah. No argument there
09:41:02 <cschneid> fruitFly: yeah, I don't know crypto well, and wanted to learn it. Ran across that challenge set and am learning crypto + haskell just for the heck of it
09:41:03 <mm_freak> Philippa: i wouldn't either…  but i could totally see something like atom with a rigorous test suite make it into such devices
09:41:27 <CaptainLex> cschneid: He has some blog posts on the subject: http://bendyworks.com/geekville/articles/2012/12/from-ruby-to-haskell-part-1-testing
09:41:32 <CaptainLex> Sadly I couldn't attend the talk
09:41:46 <fruitFly> cschneid: go for it dude.. sounds like an aewsome challge... I know I'm gonna. Thanks for the idea. :)
09:42:06 <Philippa> mm_freak: If you're spitting out object code you can always just check the object code, yeah
09:42:46 <levi> mm_freak: I would view implementing a compiler in Haskell for an embedded target a related but not quite equivalent thing than "running Haskell" on an embedded target. Definitely a very useful application of Haskell skills towards safety-critical domains, though.
09:42:50 <Philippa> CaptainLex: I've had that conversation with an old friend, too
09:43:03 <mm_freak> levi: yeah
09:43:36 <levi> In fact, many C code analysis tools are implemented in FPLs. Frama-C, for example, is all in OCaml.
09:43:51 <CaptainLex> Philippa: The ruby/haskell conversation? Or the programmer-error-susceptibility conversation?
09:44:07 <cschneid> CaptainLex: they share some ideas for sure, but they're so different in actual implementation and how you break down the problem. Higher order functions don't really happen in ruby for instance.
09:44:27 <mm_freak> fruitFly, cschneid: if you'Re interested in crypto, ##crypto is a channel with quite some activity…  i'm myself very interested in crypto and do my crypto research with haskell
09:44:36 <cschneid> mm_freak: cool - I'll lurk :)
09:44:55 <fruitFly> mm_freak: you sound like the man :)
09:44:57 <levi> Whether your memory allocation is deterministic or not is entirely irrelevant for those tasks, though, which makes them the easiest to use FPLs for.
09:45:18 <fruitFly> mm_freak: i would like to have tea and/or fruit with you sometime
09:45:33 <cschneid> CaptainLex: but yeah, borrowing best practices from each other is cool, but they have very different feels while you actually write the code.
09:45:37 <Iceland_jack> what an odd thing to say
09:46:00 <CaptainLex> cschneid: I would never hope to disagree with that statement!
09:46:14 <CaptainLex> Iceland_jack is correct, that is an odd thing to say
09:46:25 <tgeeky> Iceland_jack: using "feels" is a reddit meme of some sort
09:46:48 <mm_freak> fruitFly: i have a feeling that you're making fun of me
09:47:29 <tgeeky> mm_freak: that doesn't make sense. fruit flies probably don't even drink tea.
09:47:40 <mm_freak> tgeeky: hence the feeling
09:47:43 <hpaste> “Anonymous Coward” annotated “SDL-mixer not installing” with “SDL-mixer not installing (annotation)” at http://hpaste.org/80608#a87080
09:48:04 <ocharles> mm_freak: ping!
09:48:13 <mm_freak> ocharles: pong?
09:48:14 <cschneid> it's actually interesting that in my ruby code, I've pushed myself further to more traditional OO, not fearing instance variables, but having much smaller objects that they scope over, so to make it easy to logic about.
09:48:14 <ocharles> I'm trying to learn me a netwire :)
09:48:15 <tgeeky> mm_freak: the 'ol double bluff!
09:48:18 <cschneid> s/logic/reason/
09:48:39 <ocharles> I was trying to write a really basic application which just has the string | X        | where the X bounces from left to right and back
09:48:43 <CaptainLex> cschneid: I think we should introduce logic as a verb
09:49:00 <cschneid> CaptainLex: logic that one through first. Is it violating the DRY principle in english?
09:49:02 <ocharles> I did that with a 'integral' wire, but I couldn't work out how to make it change direction when it's value was over 10 (for example)
09:49:07 <cschneid> hah.
09:49:26 <CaptainLex> cschneid: English has no DRY principle
09:49:30 <fruitFly> mm_freak: what?! NO. If you saw my comment above I'm interested in the scalability of crypto currencies like bitcoin because I think it's very important people have good alternative to government (inflating) money. I have a genuine interest in crypto and have had for at least a year now. One of my main motivations for learning haskell is to supplement my learning of crypto. I think your are totally awesome if you're into haskell and
09:49:54 <fruitFly> mm_freak: not making fun of you in any respect. I think at least your interests are awesome... and I'm sure you are too :)
09:49:55 <tgeeky> ocharles: The difference is (in an ideal world) that in Haskell we might carry the proof with the code, whereas in Ruby we might have to expect each person to prove correctness to themselves.
09:50:00 <cschneid> CaptainLex: yeah, english is like the marauding vikings, sacking other languages, and throwing its words over its shoulder and running away.
09:50:16 <CaptainLex> cschneid: And I love it for that!
09:50:26 <ocharles> https://gist.github.com/ocharles/0e5dbcbcaacf7160528c was as far as I got
09:50:33 <ocharles> tgeeky: I don't think you meant to send that to me
09:50:37 <cschneid> sometimes the french invade the english. And the english language still steals their words. It's sneaky like that
09:50:47 <mm_freak> ocharles: well, a very poor but short way to do it is this:  x = require (< 10) . integral_ 0 . 1 --> require (>= 0) . integral_ 10 . (-1)
09:50:57 <mm_freak> ocharles: --> x
09:51:18 <tgeeky> ocharles: correct
09:51:18 <mm_freak> fruitFly: ok, sorry =)
09:51:20 <CaptainLex> cschneid: Was the Great Vowel Shift a left shift or a right one?
09:51:24 <tgeeky> cschneid: The difference is (in an ideal world) that in Haskell we might carry the proof with the code, whereas in Ruby we might have to expect each person to prove correctness to themselves.
09:51:48 <cschneid> tgeeky: interesting.  Ruby certainly doesn't rely on types to prove anything, although it can be a handy abstraction anyway.
09:51:55 <ocharles> mm_freak: hmm interesting. what would be a less poor way?
09:52:13 <cschneid> tgeeky: I really like both the languages. They both force me to think in different directions
09:52:14 <tgeeky> cschneid: where I'm taking the (newly invented) verb "logic" to mean, have proofs of various things
09:52:28 <mm_freak> ocharles: a less poor way is to use feedback, i.e. either ArrowLoop or fixW…  then you can perform proper collision detection
09:52:36 <Philippa> CaptainLex: The Haskell/Ruby one
09:52:45 <ocharles> mm_freak: ok, it seems like that is what I should read up on then
09:52:55 <tgeeky> cschneid: absolutely. I like both, and in some senses I think Ruby is more applicable to being creative and inspired when coding.
09:53:08 <CaptainLex> I gotta bounce, later gaters
09:53:16 <CaptainLex> Direct any comments at CaptainLex|AFK
09:53:27 <cschneid> tgeeky: it's cool to see the overlaps too, but then achieved very differently.  DSLs for instance are common in both
09:53:42 <cschneid> tgeeky: even if in haskell, the language is line-noise operators :)
09:53:50 <tgeeky> hehe
09:53:58 <mm_freak> ocharles: yeah, but unfortunately there isn't much to read right now…  however, the rule is pretty much this:  if the haddock docs say, "depends: current instant", then feedback with the wire in question causes a <<loop>>
09:54:09 <mm_freak> ocharles: in all other cases feedback is possible
09:54:31 <ocharles> what is <<loop>>? as in `undefined` type loop?
09:54:46 <ocharles> nontermination?
09:54:50 <mm_freak> ocharles: yeah
09:54:57 <ocharles> ok, cool
09:55:20 <ocharles> well there might not be much to read, but I can try and learn how ArrowLoop and MonadFix work outside wire
09:55:21 <Philippa> the sort known as a "black hole" - it can be detected at runtime, at least
09:55:21 <mm_freak> also feedback can be broken by inhibition, in which case you get an error message explaining that feedback was broken by inhibition =)
09:55:23 <ocharles> those are new classes to me
09:55:31 <Philippa> "I tried to force X while forcing X"
09:55:32 <mm_freak> ocharles: for example when you do this:  "rec x <- empty -< x"
09:55:37 <mm_freak> that obviously doesn't work
09:56:21 <ijp> I don't know if this question is well defined, but here goes. Can two normalised lambda terms be observationally equivalent, but not alpha equivalent?
09:56:27 <mm_freak> ocharles: MonadFix and ArrowLoop outside of Wire won't really help you =)
09:56:32 <mm_freak> except with Auto perhaps
09:57:25 <monochrom> MonadFix: http://www.haskell.org/haskellwiki/MonadFix
09:57:25 <ocharles> mm_freak: hmmm. well do you think i would have most luck writing what I want with fixW or loop for now? fixW feels less abstract nonsense and thus might get me results quicker :)
09:57:29 <mm_freak> ijp: what's observational equivalence?
09:58:05 <mm_freak> ocharles: fixW is really just a convenient special case of 'loop' when you don't use arrow style =)
09:58:26 <mm_freak> ocharles: read on how arrow syntax interacts with ArrowLoop in the GHC manual on arrow notation
09:58:47 <mm_freak> that's the easiest way to get started with ArrowLoop in netwire
09:58:50 <ijp> mm_freak: like, If I applied them both to the same lambda term, I would get the same result. Similarly, if I supplied them both as arguments to another lambda term, I would get the same result
09:58:58 <ijp> I suppose this definition is somewhat circular
09:59:05 <ocharles> mm_freak: yes, I don't know arrow style yet
09:59:13 <ocharles> ok, maybe I should arrow syntax then :)
09:59:25 <ocharles> gotta commute home now though, will have a trawl in the manual
09:59:28 <ocharles> thanks for the pointers!
09:59:49 <mm_freak> ocharles: alternatively you can read my still unfinished arrow tutorial =)
09:59:56 <ocharles> where's that?
10:00:13 <mm_freak> http://ertes.de/new/tutorials/arrows.html
10:00:31 <ocharles> will do :)
10:01:04 <mm_freak> it's not finished, but it explains Auto very well…  from that you might be able to gain a better understanding what ArrowLoop means for Wire
10:01:23 <Taneb> I got bored, so I wrote a version of on that works with any Arrow
10:01:35 <mm_freak> ijp: (\x -> x) y = (\y -> y) y = y
10:01:37 <Taneb> :t \f g -> f <<< g *** g
10:01:39 <lambdabot> Arrow cat => cat (c', c') c -> cat b' c' -> cat (b', b') c
10:01:54 <ijp> mm_freak: right, but that isn't in a normal form
10:01:59 <Taneb> Which is "on", with some curry
10:02:05 <mm_freak> ijp: (\x -> x) is a normal form
10:02:17 <ijp> oh sorry, I misinterpreted your example
10:02:27 <ijp> mm_freak: anyway, it fails the "not alpha equivalent" test
10:02:30 <mm_freak> ijp: but they are alpha-equivalent, too
10:02:56 <mm_freak> i don't think there is any such example, because i have a strong feeling that it would be a weird thing to have
10:03:35 <ijp> I suspect that it doesn't exist, but I have no idea how to prove it, and I've been out for the past few hours, so I haven't had time to consulte barendreght
10:04:01 <mm_freak> ijp: in fact i think that alpha equivalence can be reduced to not being able to tell an expression from another by application
10:04:18 <mm_freak> but i might be wrong there
10:04:36 <Philippa> mm_freak: given that there are an infinite number of fixpoint operators, I'm suspicious of that
10:04:54 <ijp> what I was really thinking about was debruijn indices, and wondering if I could restrict function equality to be purely structural
10:05:04 <Philippa> (alpha-distinct fixpoint operators!)
10:05:14 <Philippa> ijp: No
10:05:31 <xivix> Hey, I'm trying to make a function  [(a, Maybe b)] -> [(a, b)]  (with the (_, Nothing) removed but I'm banging my head against the wall trying to figure out how to do it idiomatically.
10:05:35 <Philippa> ijp: I mean, we would've done that decades ago if it worked!
10:05:36 <ijp> Philippa: obviously I can't in the normal untyped lambda calculus
10:05:47 <Philippa> ah, did I miss you stating your setting?
10:05:49 <ijp> this is why I was only considering normal forms
10:05:55 <jfischoff> does anyone use eclipseFP ?
10:06:06 <Philippa> oh, right, yeah. Which fixpoint operators aren't
10:06:41 <Philippa> (...wait, that's not true, Y is normalised at least)
10:06:45 <mm_freak> Philippa: huh?  if you use de bruijn indices then alpha equivalence = identity, no?
10:06:50 <Philippa> (it's the /application/ of Y that isn't)
10:07:25 <Philippa> hrmm. "strict Y" works in a non-strict setting still, right?
10:08:18 <applicative_> xivix: well filter ((Nothing ==) . snd) is a little primitive
10:08:39 <applicative_> Nothing /= rather
10:08:39 <c_wraith> I *really* don't understand what the strict function does
10:08:51 <dschoepe> xivix: perhaps `catMaybes . map (\(a, b) -> fmap ((,) a) b))'
10:08:56 <byorgey> how about  filter (isJust . snd)
10:09:08 <byorgey> oh, that doesn't get rid of the Maybe type, never mind
10:09:15 <applicative_> ah isJust, too slow there
10:09:16 <h4199> xivix: map (fromJust.snd) $ filter (isJust. snd)
10:09:23 <byorgey> ughhh
10:09:37 <applicative_> oh indeed that was the initial problem. we want to move it outside maybe, and then catmaybe?
10:09:39 <mm_freak> xivix: first lift the Maybe:  map (\(x, my) -> fmap (x,) my)
10:09:42 <mm_freak> then use catMaybes
10:09:50 <byorgey> yes, that's exactly what dschoepe said above
10:09:57 <magicman> f xs = [(a,b) | (a, Just b) <- xs] -- comprehensions :p
10:09:57 <monoidal> I believe that lifting is called strength
10:10:01 <mm_freak> :t catMaybes . map (\(x, my) -> fmap ((,) x) my)
10:10:03 <lambdabot> [(a1, Maybe a)] -> [(a1, a)]
10:10:20 <applicative_> yes
10:10:24 <byorgey> magicman's solution is probably simplest =)
10:10:34 <h4199> magicman has the right of it
10:10:35 <byorgey> @type strength
10:10:36 <xivix> magicman: That's clever.
10:10:38 <lambdabot> Not in scope: `strength'
10:10:41 <Philippa> ijp: does that work for you as a counterexample? (Besides, I suspect if it was that simple the dependent types folks would've done it decades ago too - they generally already know their terms normalise)
10:10:54 <mm_freak> or what byorgey said, but isJust feels so weird that i don't ever thing about using it =)
10:11:00 <mm_freak> think
10:11:07 <byorgey> no, I reject my solution
10:11:17 <h4199> @src catMaybes
10:11:18 <lambdabot> catMaybes ls = [x | Just x <- ls]
10:11:21 <arkeet> > Data.Traversable.sequenceA (1,Just 2)
10:11:23 <lambdabot>   Just (1,2)
10:11:30 <applicative_> > [(a,b) | (a, Just b) <- [(1,Just 2),(2,Just 3),(3,Nothing)]]
10:11:32 <lambdabot>   [(1,2),(2,3)]
10:11:55 <mm_freak> but list comprehensions feel so weird that i don't ever thing about using it =)
10:11:56 <mm_freak> think
10:12:01 <tgeeky> so f = catMaybes2of2
10:12:03 <arkeet> but thy're good
10:12:06 <arkeet> they're
10:12:11 * applicative_ declares magicman the winner
10:12:14 <mm_freak> typo tea time
10:12:16 <byorgey> @type catMaybes . map Data.Traversable.sequenceA
10:12:18 <lambdabot> Traversable t => [t (Maybe a)] -> [t a]
10:12:25 <byorgey> nice arkeet =)
10:12:36 <xivix> Thanks guys.
10:12:45 <applicative_> mm_freak: isn't this a nice example of how nice they are?
10:12:47 <arkeet> not as good as strength, but at least it's in base
10:13:06 <byorgey> yep
10:13:27 <byorgey> well, it's actually more general than strength!
10:13:32 <magicman> @type catMaybes . map (uncurry (fmap . (,)))
10:13:33 <lambdabot> [(a, Maybe a1)] -> [(a, a1)]
10:13:45 <byorgey> for some reason I had never made the connection between strength and sequenceA
10:13:51 <arkeet> but it requires an Applicative.
10:13:57 <xivix> Is (\(x, my) -> fmap ((,) x) my) the best way to go from  (a, Maybe b) to Maybe (a, b) ?
10:13:59 <mm_freak> applicative_: sure
10:14:00 <byorgey> ah, that's true
10:14:18 <mm_freak> xivix: i don't see a better way
10:14:22 <applicative_> what is strength? i can't remember
10:14:24 <xivix> @type uncurry (fmap . (,))
10:14:26 <applicative_> @type strength
10:14:26 <lambdabot> Functor f => (a, f a1) -> f (a, a1)
10:14:27 <lambdabot> Not in scope: `strength'
10:14:28 <byorgey> so it's more general in one dimension (works over any Traversable, not just pairs) and less general in another (requires Applicative instead of just Functor).
10:14:46 <xivix> magicman wins again, before I even asked the question this time
10:14:57 <kqr> if i have a lot of "somethingBy accessor a b = something (accessor a) (accessor b)" is that when I should learn lenses?
10:15:01 <magicman> I believe that's the "strength" that's being talked about.
10:15:24 <fizbin> @djinn (f a, f b) -> f (a,b)
10:15:25 <lambdabot> -- f cannot be realized.
10:15:25 <byorgey> kqr: no, just write   something `on` accessor
10:15:30 <mm_freak> kqr: so far i only see a use case for 'on'
10:15:33 <byorgey> where on is from Data.Function
10:15:39 <arkeet> :t uncurry (liftA2 (,))
10:15:41 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
10:15:54 <mm_freak> > (f `on` g) x y
10:15:55 <xcvii> hey, is there a straightforward way to get the syntax tree of a haskell expression given the textual representation? the ghc api docs lost me pretty quickly (:
10:15:56 <lambdabot>   Ambiguous type variable `b0' in the constraints:
10:15:56 <lambdabot>    (GHC.Show.Show b0)
10:15:56 <lambdabot>     ...
10:16:00 <mm_freak> > (f `on` g) x y :: Expr
10:16:01 <lambdabot>   Ambiguous type variable `b0' in the constraints:
10:16:02 <lambdabot>    (GHC.Show.Show b0)
10:16:02 <lambdabot>     ...
10:16:08 <fizbin> :t (,)
10:16:09 <kqr> byorgey, that sounds clever
10:16:10 <lambdabot> a -> b -> (a, b)
10:16:17 <arkeet> xcvii: haskell-src-exts package parses haskell
10:16:44 <kqr> byorgey, awesome thanks
10:17:26 <xcvii> arkeet: sweet, thanks, i'll give it a look
10:18:39 <arkeet> @let _2' f (x,y) = (,) x <$> f y
10:18:41 <lambdabot>  Defined.
10:18:42 <arkeet> :t sequenceAOf _2'
10:18:44 <lambdabot> Functor f => (a1, f b) -> f (a1, b)
10:18:50 <arkeet> :t sequenceAOf _2
10:18:52 <lambdabot> (Functor f, Field2 s t (f b) b) => s -> f t
10:19:03 <elliott> sequenceAOf f, aka f id
10:19:08 <arkeet> sure
10:19:18 <elliott> :t sequenceAOF_
10:19:20 <elliott> :t sequenceAOf_
10:19:20 <lambdabot>     Not in scope: `sequenceAOF_'
10:19:20 <lambdabot>     Perhaps you meant one of these:
10:19:20 <lambdabot>       `sequenceAOf_' (imported from Control.Lens),
10:19:23 <lambdabot> Functor f => Getting (Traversed a f) s (f a) -> s -> f ()
10:19:24 <elliott> heh.
10:19:27 <applicative_> aren't most things in lens id?
10:19:35 <applicative_> or ($ id)
10:20:20 <tgeeky> applicative_: judging from the title in #haskell-lens, most things in lens are unsafeCoerce
10:20:30 <arkeet> =)
10:20:40 <ijp> Philippa: well, no, because I need two terms
10:20:51 <ijp> And is Y normalised? That sounds a little off to me
10:20:55 <applicative_> wow, 'cabal is evil' is still gathering 'discussion'.  They must be ripping out each others' throats by now.
10:21:14 <ijp> since they can be beta reduced surely?
10:21:23 <applicative_> tgeeky: right, id is safeNoCoerce
10:21:39 <Philippa> ijp: their applications can be
10:21:55 <fragamus> so, do we yet have enough morphisms and monads etc, to write provably correct code for arbitrary applications
10:21:56 <Philippa> "call-by-value Y" is not the same term
10:22:03 <ijp> and applications aren't normalised either
10:22:25 <applicative_> hah, tgeeky I see the unsafeCoerce-counter
10:22:50 <Philippa> other way round: I'm saying there aren't any redexes in Y, it's normalised
10:23:14 <Eduard_Munteanu> fragamus: no, and the benchmark is "rich enough types" rather
10:23:37 <ijp> λf.(λx.f (x x)) (λx.f (x x))
10:23:42 <dmwit> :t findAll
10:23:45 <lambdabot> Not in scope: `findAll'
10:23:54 <ijp> you can beta in the body
10:24:14 <Eduard_Munteanu> No as in you can't prove correctness.
10:24:15 <fragamus> Eduard_Munteanu: so what is an example of a pathological case
10:24:30 <ijp> maybe I am using the term 'normal form' incorrectly?
10:24:56 <Eduard_Munteanu> fragamus: pretty much any non-trivial theorem? Haskell types get you the very basic stuff only.
10:25:31 <fragamus> Eduard_Munteanu: so we are really just getting started here, and we have no idea if the goal is achievable right?
10:25:54 <Eduard_Munteanu> fragamus: it might be but not from Haskell. You should try Agda (and #agda). ;)
10:26:43 * hackagebot monoid-extras 0.3.0.0 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.3.0.0 (BrentYorgey)
10:26:49 <Eduard_Munteanu> fragamus: for example look at Compcert, a certified C compiler written in ML and Coq.
10:27:01 <Philippa> ijp: no, I'm just not as awake as I should be
10:28:59 <hiptobecubic> Eduard_Munteanu, neat
10:30:06 <Eduard_Munteanu> Philippa: not in -blah anymore?
10:31:12 <Philippa> I haven't been in for a while, no
10:31:15 <fragamus> whoa everyone stopped talking… we're all heads down looking ad agda and coq
10:31:46 <Eduard_Munteanu> Come back. :P
10:32:37 <hiptobecubic> hah
10:32:44 <Philippa> I have to say, I can't see how it would've been a net win for me the last couple of weeks. Maybe sometime I've not got the DWP reassessing me, say
10:32:44 <hiptobecubic> 11 formally defined intermediate languages
10:33:09 <Philippa> hiptobecubic: Well yeah. Beats fusing both the transforms and the proofs
10:33:11 <Nisstyre> hiptobecubic: I put a core language in your core language so you can desugar while you desugar
10:33:36 <hiptobecubic> I never really grokked how computer assisted proofs really work.
10:34:14 <Eduard_Munteanu> Philippa: ok, mind asking you something via pm? (I admit to selfish reasons for asking about -blah, yes.)
10:34:33 <Philippa> go ahead
10:35:14 <applicative_> hiptobecubic: you type out imperatives and slowly the computer builds a hideous unreadable lambda term
10:35:42 <hiptobecubic> inria seems like a pretty interesting place to be
10:35:54 <tgeeky> Eduard_Munteanu: while you're asking, ask Philippa to unban me, since I'm apparently on /ignore
10:35:56 <applicative_> autos. simpl.
10:36:10 <Eduard_Munteanu> Alright.
10:36:16 <applicative_> hiptobecubic: have you tried Idris, it has a little 'proof assistant' built in
10:36:20 <hiptobecubic> tgeeky, still?
10:36:35 <tgeeky> hiptobecubic: yep. Month(s?) later
10:36:37 <luite> is it possible with GHC generics to find ot how many constructors a datatype has?
10:37:15 <hiptobecubic> tgeeky, even Zhivago is faster than that :)
10:37:36 <luite> or to go from a String based on the constructor name to a representation of a constructor
10:37:40 <tgeeky> hiptobecubic: I know, and Sibera is a *really* low entropy enviornment!
10:38:11 <applicative_> luite: dataTypeConstrs $ dataTypeOf (Just 1)    --- [Nothing,Just]
10:38:35 <Saizan> luite: the Data class should have the former at least, check dataTypeOf
10:38:36 <applicative_> that's Data.Data or is that what you meant
10:38:49 <luite> applicative_: that's the wron generics
10:38:54 <luite> i mean GHC.Generics
10:38:58 <applicative_> thats what i figured
10:39:09 <luite> :)
10:39:40 <applicative_> a little hard to miss...
10:40:38 <dreixel> luite: yes
10:40:46 <luite> applicative_: it's in the type of Rep, so i guess it would be possible to use reflection to get it out, dunno if that's the way though
10:40:54 <applicative_> thats a pretty savage module, GHC.Generics
10:40:58 <luite> dreixel: ah do you have an example somewhere?
10:41:43 <dreixel> luite: look at http://hackage.haskell.org/packages/archive/generic-deriving/1.5.0/doc/html/Generics-Deriving-ConNames.html
10:41:48 <dreixel> that gives you all the names of the constructors
10:41:58 <dreixel> you could take the length of that list... or write a new function
10:43:29 <applicative_> wow, you found the right guy luite
10:43:45 <luite> yeah
10:43:56 <luite> dreixel: tnx that's exactly what i needed :)
10:46:33 <mdmkolbe> GHC 7.6.1 depends on libgmp.so.3, but Ubuntu 13.04 no longer packages that (instead packaging libgmp.so.10).  Is there a simple solution to work around this?  (I can always build and install my own version, but I'd rather avoid the effort.)
10:46:53 <hiptobecubic> how do dependent types really work?
10:47:24 <Philippa> just like functions (term- or type-level) and parametric polymorphism
10:47:34 <hiptobecubic> Is it supposed to be all done at compile time still?
10:48:30 <Philippa> type-checking is. It's common for 'residue' of the types to make it into runtime behaviour
10:49:14 <Philippa> (so you don't have to manually pass the length of that vector for two different phases)
10:51:05 <hiptobecubic> hm
10:51:14 <hiptobecubic> Ugh... why swap ':' and "::" ?
10:51:36 <Cale> hiptobecubic: Haskell is the one who made that swap :)
10:52:05 <hiptobecubic> ok sure. Why?
10:52:17 <Eduard_Munteanu> Think typing rules.
10:52:39 <Eduard_Munteanu> Or simpler, stuff like "f : A -> B" for math functions.
10:53:06 <Cale> It's just concrete syntax. You'd choose one convention or the other based on how frequently you expect to be writing types vs. list conses.
10:53:10 <Eduard_Munteanu> Besides, Agda uses a unicode variant of ::, for list consing.
10:53:49 <hiptobecubic> yuck
10:54:38 <Cale> For some odd reason, all the dependently typed systems decide to go with strict evaluation, which makes lists a whole lot less useful anyway?
10:55:06 <h4199> f (x ∷ xs) is not /so/ terrible
10:55:15 <Mortchek> a
10:55:19 <h4199> b
10:55:19 <Mortchek> Wrong window
10:55:37 <bitonic> Cale: the strategy doesn’t matter for finite lists, denotationally
10:55:50 <monoidal> anyone knows the reason why it was swapped?
10:56:07 <Philippa> monoidal: Guess which one was more frequent in early Haskell code?
10:56:09 <h4199> convenience?
10:56:28 <monoidal> Philippa: I would be surprised if that was cons.
10:56:32 <bitonic> Cale: the strategy doesn’t matter for total languages, period, actually :P
10:56:36 <mm_freak> Cale: the idea is that dependently typed languages are usually total anyway
10:56:54 <acube> monoidal: Maybe there was more space in the line for type annotiations?
10:57:47 * sproingie googles for "total language" and gets something rather different than he expected
10:58:08 <Philippa> monoidal: at the time, the only thing that needed a type annotation was polymorphic recursion
10:58:10 <mm_freak> sproingie: total = all programs are well defined and terminate
10:58:27 <magicman> I'm guessing that, back in the day, people were all "Whoa, we don't need type signatures!".
10:58:31 <sproingie> sounds incompatible with turing completeness
10:58:36 <Philippa> whereas many structures were being expressed in terms of lists regardless of how appropriate that actually was because it's quick (association lists for maps, for example)
10:58:39 <magicman> VS right now: "Type signatures are good practice."
10:58:47 <mm_freak> sproingie: yes, dependently typed languages are usually not turing complete
10:59:09 <mm_freak> sproingie: but i should replace "terminate" by "always give an answer in finite time"
10:59:19 <mm_freak> that doesn't mean they can't run forever
10:59:31 <bitonic> sproingie: you can embed non termination in them, in a similar way that you can embed side effects in a pure language like Haskell
10:59:55 <sproingie> right, just have to be explicit about it
11:00:18 <bitonic> sproingie: besides, most algorithms you write are terminating—most non-terminating program are some sort of event loop or state machine, and that can be modelled successfully too with corecursion
11:00:34 <bitonic> most programmers are really coprogrammers
11:00:46 <mm_freak> sproingie: it's not that there is something like a non-termination monad like there is a real-world-action monad in haskell
11:00:54 <bitonic> most pieces of software are coprograms really
11:00:57 <Eduard_Munteanu> bitonic: they keep churning out code and do not terminate? :)
11:01:07 <sproingie> i have a coworker like that
11:01:12 <bitonic> Eduard_Munteanu: they write coprograms
11:01:15 <Eduard_Munteanu> Woo, a *co*worker!
11:01:16 <h4199> while 1 .....
11:01:20 <mm_freak> lol
11:01:38 <Cale> bitonic, mm_freak: just because you can prove termination doesn't mean that performance isn't a composability issue.
11:01:56 <sproingie> Eduard_Munteanu: yes, he also tends to create a lot of extra work for me too
11:02:06 <mm_freak> Cale: i don't like strict-by-default either
11:02:06 * sproingie wants to challenge him to a dual
11:02:12 <Eduard_Munteanu> Heh.
11:02:28 * magicman groans.
11:02:30 <mm_freak> Cale: i guess the real reason why people do that is that it makes writing the compiler a lot simpler
11:02:37 <bitonic> Cale: OK, performance-wise lazyness is always useful—that’s why I added the ‘denotationally’.  but in Haskell, in my experience, most of the advantages of lazyness are due to the fact that dealing with infinite (co) data is a breeze
11:02:49 <sproingie> me and math jokes, bad combination
11:03:36 <mm_freak> Cale: dependently typed languages are currently in a stage where parts of the language are designed for the language implementation rather than for the programmer
11:03:59 <jfischoff> non-strictness makes defining control structures easier. That's the main advantage for me.
11:04:02 <bitonic> mm_freak: really?  looking at Agda’s syntax I’d say the opposite.
11:04:17 <mm_freak> bitonic: agda isn't really for programmers at all
11:04:20 <jfischoff> writing a parser combinator in a strict language I found annoying
11:04:20 <bitonic> or at the fact that if the HoTT people want a feature in Coq, it appears pretty quickly :P
11:04:40 <bitonic> mm_freak: it isn’t?  I’ve been using it for a bit...
11:04:43 <Eduard_Munteanu> Maybe DT language designers valued conceptual simplicity over application-specific sugar?
11:04:50 <mm_freak> bitonic: for writing applications?
11:05:02 <Philippa> Eduard_Munteanu: Idris has some fun DSL features, though
11:05:10 <fruitFly> what's the development for idris like?
11:05:16 <Eduard_Munteanu> Hm. I have to try Idris sometime.
11:05:25 <bitonic> no, but you said ‘agda isn't really for programmers at all’.  most of the people that play with Agda are actually programmers of some kind
11:05:57 <bitonic> I think there is a point in delegating lazyness to infinite data, for the time being
11:05:58 * Eduard_Munteanu is kidding himself Coq is too ugly and Idris too Haskell-y, and that one day he will improve Agda and pull out some verified software from it
11:05:59 <hiptobecubic> HoTT ?
11:06:19 <hiptobecubic> What's wrong with being Haskelly? :)
11:06:34 <Eduard_Munteanu> hiptobecubic: as in "we didn't design it as a theorem prover"
11:06:34 <bitonic> hiptobecubic: homotopy type theory, the cool thing right now in type theory land
11:06:44 <mm_freak> bitonic: sure, but i'm saying that most DT languages don't support application development very well…  in fact idris seems to be the first language that actually tries to, but then idris is strict by default, so i'll probably never prefer it over haskell
11:06:55 <h4199> http://vimeo.com/user16996198 -- Idris videos
11:07:04 <hiptobecubic> oh weird
11:07:13 <bitonic> mm_freak: that’s true, but we’re still figuring out how DT languages will work, it’s going to take a while
11:07:25 <ousado> ATS tries that, too
11:07:26 <mm_freak> bitonic: sure
11:07:32 <hiptobecubic> It would be hard for me to separate functional idioms from laziness idioms now
11:07:39 <hiptobecubic> I've only experienced them together
11:07:42 <bitonic> mm_freak: also, programs have been written in Coq
11:07:50 <hiptobecubic> like that C compiler
11:07:59 <hpaste> koral pasted “FFI gtk2hs” at http://hpaste.org/87082
11:07:59 <mm_freak> bitonic: i'm not blaming anyone…  implementing a DT language alone is difficult enough =)
11:08:00 <bitonic> yes, like that C compiler :P
11:09:13 <Eduard_Munteanu> Are there working prototypes of HTT-based theorem provers?
11:09:17 <mm_freak> well, you can write programs in agda, too…  like that web framework ;)
11:09:28 <mm_freak> lemmachine
11:09:31 <k0ral> Hello, would you please have a look at http://hpaste.org/87082 and tell me what's wrong ? I mimmic'd  what's done in webkit package but it won't build
11:09:34 <Eduard_Munteanu> (FSVO working, I realize the theory is incomplete)\
11:09:44 <bitonic> Eduard_Munteanu: since nobody knows how to make HoTT compute, no.  you can assume the univalence axiom just fine in Agda/Coq
11:09:58 <Eduard_Munteanu> Hm.
11:10:15 <Eduard_Munteanu> But you don't get that isomorphism is equality thingie natively, I suppose, and other fun stuff.
11:10:18 <dcoutts> k0ral: you probably need a pointer hook, to tell c2hs the relationship between the Haskell type NetworkRequest and the C type WebKitNetworkRequest*
11:10:24 <bitonic> Eduard_Munteanu: ‘Isomorphism is Equality’ is a nice paper on the subject (univalence in Agda)
11:10:28 <mm_freak> what's that HoTT anyway?  i've read that a number of times now
11:10:41 <Eduard_Munteanu> mm_freak: Homotopy Type Theory
11:10:58 <mm_freak> a short summary why it matters?
11:11:09 <Eduard_Munteanu> dolio's slides are rather nice as an introduction
11:11:10 <bitonic> Eduard_Munteanu: well again nobody knows if that’s ever going to really work!  I hope it will someday, but we have much lower level problems for what concerns equality, we don’t even get functional extensionality now!
11:11:13 * Eduard_Munteanu looks
11:11:26 <k0ral> dcoutts: you mean I have to duplicate the {#pointer directive from gtk2hs package (Types.chs) ?
11:11:55 <Eduard_Munteanu> http://comonad.com/reader/2011/homotopy-and-directed-type-theory-slides/
11:11:59 <Eduard_Munteanu> mm_freak: ^^
11:12:18 <mm_freak> Eduard_Munteanu: thanks, i'll read it
11:12:19 <Eelis> bitonic: wouldn't HoTT provide that (assuming you have a proper constructive proof of extensionality)?
11:12:29 <bitonic> mm_freak: it provides a much more flexible propositional equality than the usual type theories employed in Agda/Coq—isomorphic types are equal
11:12:30 <monochrom> w00t, Haskell Weekly News finally!
11:12:55 <dcoutts> k0ral: c2hs can import such things, however that relies on the .chi files and those don't get installed, so in practice you cannot do that across modules in different packages
11:12:55 <bitonic> Eelis: you can derive extensionality with univalence (and reflexivity obviously)
11:13:03 <Eelis> bitonic: right
11:13:32 <k0ral> dcoutts: so I have to hide the NetworkRequest definition from Webkit also, otherwise it conflicts
11:13:34 <dcoutts> k0ral: if it were in the same package, you'd just {# import Types #}, and c2hs would look at the Types.chi file
11:13:45 <Eduard_Munteanu> HoTT types doing ITT all.
11:14:03 <dcoutts> k0ral: um, I think you can get c2hs to point to an existing type rather than generate a new one
11:14:13 <dcoutts> but I may be mis-remembering
11:14:28 <k0ral> I wrote: {#pointer *WebKitNetworkRequest as NetworkRequest foreign newtype #}
11:14:47 <k0ral> now it's complaining about the conflict (as I'm importing also Webkit.NetworkRequest)
11:15:18 <k0ral> how can I get c2hs to understand those are the same ?
11:15:48 <monochrom> @quote MartinDeMello
11:15:49 <lambdabot> MartinDeMello says: Any sufficiently well-commented Lisp program contains an ML program in its comments.
11:16:23 <monochrom> I like that one very much! it's what I did, unknowingly, when I first used Lisp. (I hadn't learned ML back then.)
11:16:38 <monochrom> well, at least, I wrote type sigs in comments.
11:18:42 * fizbin has been known to annotate python code with ML-like signatures in the comments.
11:18:59 <Nisstyre> fizbin: yeah I've done that before
11:19:09 <Nisstyre> I think there are libraries that even allow contracts in Python
11:19:35 <Philonous> dcoutts:  Hi! What do I need to do to get a c2hs to the maintainers? I sent it on the mailing list but so far no one has reacted.
11:19:59 <Nisstyre> I'm not sure if you can say "must implement these methods" though
11:19:59 <Philonous> a patch, I mean
11:20:24 <dcoutts> Philonous: talking to me here I guess :-). Sorry, it's my fault. I've not been paying attention.
11:21:11 <dcoutts> Philonous: which is your patch?
11:21:14 <Philonous> dcoutts:  It's http://www.haskell.org/pipermail/c2hs/2013-March/001113.html
11:21:43 * dcoutts has a quick look
11:21:45 * hackagebot yesod-auth-zendesk 1.2 - Zendesk remote authentication support for Yesod apps.  http://hackage.haskell.org/package/yesod-auth-zendesk-1.2 (FelipeLessa)
11:22:34 <dcoutts> Philonous: so it's "get me the address of <path>" right?
11:22:54 <Philonous> dcoutts:  Yes
11:23:52 <Philonous> dcoutts:  It's a like "offsetof" only that it chases nested pointers
11:24:26 <dcoutts> Philonous: I wonder if "addressof" or "addrof" might be clearer as a name
11:24:31 <dcoutts> Philonous: looks ok btw
11:25:05 <Philonous> scgilardi:  hsc2hs calls it #ptr , but ptr is already taken in c2hs
11:25:16 <Philonous> dcoutts:  ^
11:26:05 <Philonous> dcoutts:  The only problem are bit fields. It only gives the base address but not the bit offset. I didn't know what to do about that.
11:26:52 <dcoutts> Philonous: yeah, that's not possible, must be an error. Presumably C does not allow to use & addr operator on bitfields
11:27:05 <sproingie> istr there's a specific restriction against it
11:27:51 <sproingie> best it could do would give you the aligned start of the fields, which would be wrong most of the time
11:29:58 <dcoutts> Philonous: yes, I think "addrof" would make most sense, it's really like C's  '&' operator
11:31:43 <Philonous> sounds good. Should I change the name and resubmit?
11:32:28 <k0ral> sorry to push you again: any clue about http://hpaste.org/87082 ?
11:34:35 <Philonous> k0ral:  call doesn't to any marshaling, so you need to unwrap the newtype (I presume?) and possibly use castptr
11:35:46 <Philonous> k0ral:  If the newtype constructor is not in scope (and it's indeed a newtype) you can just use unsafeCoerce.
11:36:33 <dcoutts> Philonous: yes please
11:38:00 <dcoutts> Philonous: and cc me, or I might not notice (sorry)
11:38:06 <k0ral> Philonous: do you have an example from which I could get inspired ?
11:38:34 <dcoutts> k0ral: note that gtk2hs uses a fork of c2hs that does some limited marshalling for {# call #}
11:38:58 <dcoutts> k0ral: so if you've been looking at that code, that'll be what's confusing things
11:39:08 <kamatsu> is anyone here familiar with linear types? I have a few questions
11:40:08 <bitonic> kamatsu: don’t ask to ask, etc :)
11:40:36 <kamatsu> well, it's not exactly haskell related, as haskell doesn't have linear types. I just figure there are a few PLs theory people here
11:41:10 <bitonic> kamatsu: I think questions about linear types will be fine here... they usually don’t mind people talking about type theory at large
11:42:03 <kamatsu> Ok, well, Wadler introduces a let! construct that allows one to temporarily have read-only, shareable view of a linear type - but he mandates that in let! (a) x = v in _, no component of the type of v can be the same as the type of a.
11:42:23 <kamatsu> what is the reason for this restriction?
11:42:35 <k0ral> dcoutts: yeah I was looking at gtk2hs code, I guess I need to find what's that extra marshalling stuff they're doing
11:42:44 <Philippa> so that view can't escape the scope of the let! binding
11:43:37 <kamatsu> hm
11:44:09 <hpaste> Philonous annotated “FFI gtk2hs” with “FFI gtk2hs (annotation)” at http://hpaste.org/87082#a87085
11:44:23 <kamatsu> so, suppose I just had ints, and I had Plus : Int -> Int -> Int (where Int here is shared, not linear)
11:44:30 <Philonous> k0ral:  See annotation.
11:44:58 <Philippa> kamatsu: then you're SOL, yeah
11:45:08 <kamatsu> right
11:45:46 <kamatsu> ok, next question
11:45:54 <kamatsu> what's the difference between uniqueness typing and linear typing?
11:46:36 <Eduard_Munteanu> The former is more specific, you get values which you can only look at once.
11:46:56 <kamatsu> how is that different from linear typing, then?
11:47:23 <Philippa> Eduard_Munteanu: linear typing requires that they be used exactly once
11:47:39 <Eduard_Munteanu> Hrmpf.
11:47:50 <kamatsu> so is the difference that uniqueness refers to affine typing?
11:47:51 <bitonic> kamatsu: iirc unique types = things with only one reference to them, linear types = things that can be observed once, which is different
11:47:53 <Eduard_Munteanu> I guess Philippa can answer this better. :)
11:48:33 <Eduard_Munteanu> (but I do think that uniqueness ⊂ linear is correct)
11:49:01 <k0ral> Philonous: I'll have to read some documentation to understand what this coerce thing is, it works like a charm :)
11:49:02 <bitonic> kamatsu:  <https://en.wikipedia.org/wiki/Uniqueness_type#Relationship_to_linear_typing>
11:49:10 <k0ral> Philonous: thank you
11:49:33 <Eduard_Munteanu> Oh, hm.
11:49:38 <kamatsu> ah, ok, then my work will be more accurately described as uniqueness typing, then.
11:49:42 <kamatsu> i have no dereliction rule
11:49:49 <Eduard_Munteanu> I do remember reading that, so I guess I misremembered it in a twisted way.
11:49:50 <kamatsu> is that the litmus test for uniqueness vs linear?
11:50:13 <kamatsu> i see now
11:50:39 <Philippa> I am not sure I trust wikipedia's distinction
11:51:10 <Philippa> certainly ATTaPL's presentation doesn't require !
11:51:17 <bitonic> Philippa: but it references Wadler!
11:51:46 * hackagebot computational-algebra 0.1.3.5 - Well-kinded computational algebra library, currently supporting Groebner basis.  http://hackage.haskell.org/package/computational-algebra-0.1.3.5 (HiromiIshii)
11:51:54 <Philippa> bitonic: yeah, I'm not about to skim the entire paper for the word "uniqueness"
11:51:57 <kamatsu> crap, I left my ATTaPL copy at work
11:52:58 <Philonous> k0ral:  unsafeCoerce is id, but changes the type. So it's really unsafe unless you know that some two types have the same representation, like newtyped values
11:53:14 <bitonic> Philippa: I was just kidding, but I might give a look for that paper at some point.  it is a question I asked myself
11:53:27 <bitonic> (‘Is there a use for linear logic?’)
11:53:46 <kamatsu> A lot of uniqueness typing systems (e.g clean) don't have the same sort of restrictions on viewing unique things as non-unique things that let! does, right? In particular, I think I remember subtyping being involved
11:53:51 <Philonous> k0ral:  If you can extract the ForeignPtr from the NetworkRequest by other means you should do that. This is only a stop gap measure to circumvent restrictive API design.
11:54:16 <bitonic> 1990–‘Linear types can change the world!’ 1991–‘Is there a use for linear logic?’ 1993–‘There's no substitute for linear logic’
11:54:19 <Philippa> kamatsu: there's a multitude of tricks out there, sure
11:54:35 <kamatsu> so, I'm looking for something which has an easy refinement to destructive update
11:54:42 <kamatsu> (seeing as I have to prove such a refinement)
11:54:45 <Eduard_Munteanu> He doesn't seem to make up his mind. :P
11:54:58 <bitonic> ehe
11:55:00 <Philonous> k0ral:  It seems like Graphics.UI.Gtk.WebKit.Types exports the constructor. If you have access to that you should just pattern match
11:56:23 <kamatsu> so, as a basic starting point, I was thinking of just trying to do this process for a language with just ints, but then that actually seems impossible without making int operations polymorphic on uniqueness or something.
11:56:41 <kamatsu> at least, using let!
11:57:14 <kamatsu> so now I'm looking for less cumbersome alternatives.
11:57:51 <Philippa> being polymorphic on uniqueness isn't necessarily a bad thing
11:58:06 <Philippa> (it is, however, a /complex/ one when it comes to your data structures)
11:58:34 <woozletoff> @pl \(_, b) (c, d) -> (c, b+d)
11:58:35 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,)) . (+) . snd
11:58:50 <hiptobecubic> woozletoff, no.
11:59:31 <elliott> :t (&&&) id . (+)
11:59:34 <lambdabot> Num c' => c' -> c' -> (c', c')
11:59:40 <elliott> :t (&&&) id . (+) . snd
11:59:42 <lambdabot> Num c' => (a, c') -> c' -> (c', c')
11:59:45 <elliott> :t (*** id . (+) . snd
11:59:47 <elliott> oops
11:59:49 <lambdabot> parse error (possibly incorrect indentation)
11:59:49 <elliott> :t (***) id . (+) . snd
11:59:51 <lambdabot> Num c' => (a, c') -> (c, c') -> (c, c')
11:59:55 <elliott> don't try this at home
12:00:05 <elliott> > ((***) id . (+) . snd) (a,b) (c,d) :: (Expr,Expr)
12:00:07 <lambdabot>   (c,b + d)
12:00:16 <hiptobecubic> I never understood arrows really.
12:00:31 <hiptobecubic> Beyond "some convenient functions for working with 2-tuples"
12:00:45 <Hardolaf> So, I'm relatively new to Haskell, what's a good resource for learning it for an experienced programmer?
12:00:49 <kamatsu> Philippa, this is just a toy example to start from, so I would rather something simpler. Right now there isn't even regular parametric polymorphism on types, and it's unlikely that that will ever be necessary.
12:00:55 <elliott> that just uses the tuple functions on (->)
12:00:58 <hiptobecubic> Hardolaf, experienced with what?
12:01:03 <elliott> Hardolaf: try lyah
12:01:05 <elliott> @where lyah
12:01:06 <lambdabot> http://www.learnyouahaskell.com/
12:01:12 <kamatsu> so adding polymorphism just for uniqueness feels ugly
12:01:17 <elliott> Hardolaf: there's a bit of unlearning involved. your existing programming skill probably won't transfer as well as you hope
12:01:22 <Hardolaf> hiptobecubic: Primarily c like languages, but I have used LISP before.
12:01:26 <elliott> so the learning materials are similar for most everyone
12:01:32 <Hardolaf> Cool.
12:01:41 <Hardolaf> Thanks.
12:01:51 <hiptobecubic> Hardolaf, don't be fooled by the art. It's a great book :)
12:02:18 * hiptobecubic thought the art made it great before he even understood the content
12:02:21 <k0ral> Philonous: there is already an "unNetworkRequest" from Webkit.Types, but it has a different type (NetworkRequest -> ForeignPtr NetworkRequest instead of NetworkRequest -> ForeignPtr ())
12:02:22 <Hardolaf> hiptobecubic: great books can have great art. I mean, look at git-scm. It's a beautiful website, also one of the most useful.
12:02:56 <hiptobecubic> Hardolaf, I don't think you'll mistake this for git-scm
12:02:56 <Philippa> kamatsu: you can always provide all the variations manually, then
12:03:17 <Hardolaf> hiptobecubic: I probably won't.
12:03:31 <viller> I want to experiment with some image processing algorithms. Which library would be useful for reading/writing PNGs and fiddling with pixels?
12:04:09 <luite> viller: JuicyPixels is a simple one
12:04:24 <luite> viller: and repa for the manipulation of the bitmap data if you want parallel processing
12:04:39 <kamatsu> Philippa: That would solve the current problem, yeah.
12:04:54 <kamatsu> Philippa: In general, it feels like let!'s type-based restriction is still too onerous..
12:05:08 <kamatsu> Philippa: seeing as this language I'm working on won't be turing complete, I could perhaps do analysis to determine if the unique reference is ever actually leaked…
12:05:09 <viller> luite: thank you. Seems like what I needed.
12:06:03 <Philippa> kamatsu: how about unique values and /regioned/ values? Then you can have a global region if you insist
12:06:12 <Philippa> huh, that's a point
12:06:38 <Taneb> Is ArrowMonad (Cokleisli ((->) m)) equivalent to Identity?
12:06:45 <Philippa> You should read this, perhaps: http://lambda-the-ultimate.org/node/3581
12:07:57 <Philonous> k0ral:  Yeah, in that case you need to castPtr the pointer you get from withForeignPtr
12:08:27 <kamatsu> or perhaps just have a copy operation !Int -> Int that actually copies the int.. in practice this would all be in registers because Ints are so small.
12:09:02 <kamatsu> oh wait, you'd need !Int -> (!Int, Int)
12:09:44 <Philippa> not if you have the other kind of copy as well
12:11:11 <kamatsu> ah, right, because then you'd just use let!.
12:11:30 <hpaste> facepalm pasted “Haskell function” at http://hpaste.org/87086
12:11:41 <kamatsu> ?
12:11:44 <Hardolaf> ?
12:12:30 <facepalm> Do I have the right idea for this?  I need to write function that takes a row and column each [0-9] then Construct and Address and return it. Use toEnum to index into row and column
12:13:25 <Botje> facepalm: uh .. toEnum 5 :: Column will produce F :: Column.
12:14:13 <Botje> facepalm: and your toAddress function needs to take _two_ arguments, not one.
12:14:48 <facepalm> do I can just put toEnum 0 :: Column for 0-9?
12:15:05 <k0ral> Philonous: I think I'm starting to get it, thank you
12:15:19 <Botje> facepalm: what you have right now is a function with twenty identical pattern matches.
12:15:31 <Botje> your haskell compiler is screaming bloody murder right now, i imagine.
12:15:36 <cschneid> what does a ! do in a data declaration? What should I search on.
12:15:48 <h4199> facepalm: you already derived Enum for your Rows and Columns, to you already can use toEnum, you get it for free
12:15:49 <luite> cschneid: it make the field strict
12:16:00 <Botje> facepalm: please revisit your teaching material for functions that pattern match on more than one argument.
12:16:11 <cschneid> luite: so evals any thunk that lands in it?
12:16:34 <luite> cschneid: if you force the constructor to whnf it will also force that field to whnf
12:17:04 <cschneid> whnf? what?
12:17:07 <Botje> facepalm: basically, scrap those twenty lines and start over with "toAddress row column = "
12:17:21 <Eduard_Munteanu> @google Weak Head Normal Form
12:17:23 <lambdabot> http://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form
12:17:23 <lambdabot> Title: definition - Haskell: What is Weak Head Normal Form? - Stack Overflow
12:17:34 <luite> cschneid: weak-head normal form, for things like Int it mean that it's fully evaluated
12:17:37 <h4199> facepalm: delete your to Addres stuff and just load the file with your data declarations into GHCi. Then write toEnum 2 :: Row and tell me what happens.
12:17:37 <Eduard_Munteanu> Oh, good, I didn't expect a SO q&a.
12:17:47 <Botje> facepalm: we have already shown you how to convert an Int into a Row or Column value.
12:17:47 <luite> cschneid: but for lists, only the outermost constructor is forced
12:18:04 <facepalm> C
12:18:08 <cschneid> ahh, so it doesn't recurse to eval the whole thing, just the outer thing.
12:18:11 <cschneid> (logically)
12:18:15 <facepalm> Iwas playing with that last night
12:18:31 <facepalm> I just dont know how to actually use in my fuction.
12:18:34 <luite> cschneid: yep, it might 'recurse' if the outer thing has strict fields itself
12:19:01 <cschneid> sure. Cool. I've had to use bangpatterns in one of my scripts so far. Not quite groking the whole world of controlling what evals and when.
12:19:07 <cschneid> but I'll figure it out as I go
12:19:07 <luite> cschneid: an Int only has one field, which is primitive (and therefore strict), so it's fully evaluated
12:19:13 <Eduard_Munteanu> cschneid: that's what forcing usually means, i.e. the effects of bang patterns or seq.
12:19:15 <Botje> facepalm: start by pattern matching on two arguments as I told you above.
12:19:27 <facepalm> yep I got that
12:19:45 <Eduard_Munteanu> cschneid: you need stuff like deepseq to eval things completely
12:21:11 <h4199> facepalm: Well first off you have defined your to Address backwards, an Address is a Row and a Column, so toAddress should take 2 Ints and returns an Address, the function you tried to write takes a row/column and returns a number
12:21:45 <Botje> facepalm: so now you need to invoke the Address constructor with a Row and Column value.
12:22:01 <facepalm> I had Row Column lastnight and someone toldme to change it to Int Int lol
12:22:20 <kamatsu> Philippa: thanks for pottier's slides, very helpful to understanding.
12:22:50 <facepalm> I had toAddress :: Row -> Column -> Address
12:23:09 <Botje> uh, yeah, that already exists. it's called Address.
12:23:10 <h4199> facepalm: the type of toAddress should be Int -> Int -> Address
12:24:39 <cschneid> how aggressively do people use data and newtype in applications vs. reusing stdlib types like String and Int and such?
12:25:03 <opqdonut> very
12:25:07 <h4199> facepalm: you already have the function that will make this work, toEnum, you just need to use it
12:25:27 <opqdonut> of course it depends on what you are doing, but usually if you use an existing type for something semantically different, you newtype it
12:26:13 <Eduard_Munteanu> cschneid: the issue isn't something like stdlib vs ad-hoc data/newtype
12:26:55 <Eduard_Munteanu> You often build more complex types from what you already have (stdlib or not).
12:27:01 <facepalm> h4199: yeahI know of toEnum I am just not sure how to use it. I have toAddress :: Int -> Int -> Address               toAddress row column  = and I am guessing the toEnum part goes after the equals
12:27:11 <cschneid> opqdonut: a simple 'type' doesn't provide you any additional type checking abilities right?
12:27:19 <opqdonut> cschneid: right
12:27:23 <Eduard_Munteanu> (besides you can't really reimplement stuff like Int)
12:27:49 <cschneid> so a 'Inches Int' newtype is better than 'type Inches = Int' for most cases
12:27:58 <Botje> facepalm: call the Address constructor.
12:28:00 <cschneid> (really it'd be a better type, but you get the idea)
12:28:04 <Botje> facepalm: it takes a Row and a Column object.
12:28:58 <h4199> facepalm: and toEnum can produce Rows and Columns because you derived them that way
12:29:16 <h4199> > toEnum 77 :: Char
12:29:18 <lambdabot>   'M'
12:30:17 <h4199> facepalm:: Int to Char just like that. And you said that you understood how that worked with your rows and columns right?
12:33:28 <h4199> facepalm: the English wording of the problem is practically your answer: You want a function, toAddress, that takes two Ints as arguments and produces an Address Row Char using toEnum and the Ints.
12:33:29 <facepalm> in ghci and just typing toEnum 2 :: Row
12:34:03 <h4199> facepalm: and what did that produce for you? It should have been C
12:34:34 <facepalm> yes. but in my script I cant write toEnum 2 :: Row
12:35:33 <h4199> right you write toEnum x, variables are your friend
12:36:13 <h4199> toRow x = toEnum x ::Row
12:36:29 <h4199> Can you see how that would work?
12:36:55 <h4199> @ty toEnum
12:36:57 <lambdabot> Enum a => Int -> a
12:38:39 <Botje> facepalm: what would your function look like if you had a toRow (:: Int -> Row) and toColumn (:: Int -> Column) function?
12:40:52 <facepalm> Row row =
12:41:19 <Mortchek> row . row . row $ yourBoat
12:41:21 <h4199> row your boad
12:41:25 <h4199> gah too late
12:41:35 <Mortchek> :)
12:41:54 <Botje> facepalm: no, just write toAddress given those two functions.
12:43:28 <hpaste> jekor pasted “Unbound implicit parameter” at http://hpaste.org/87088
12:44:28 <jekor> I can't figure out if I'm misunderstanding something about implicit parameters or if they're broken.
12:44:57 <dmj> anyone have good documentation on using zippers with trees? Am trying to implement the hilbert r-tree with zippers. The concept makes sense, just need more concrete examples.
12:45:01 <jekor> The compiler has correctly derived the function type in many cases but not in this (simplified) case.
12:45:45 <facepalm> toAddress row column  = Address toRow toColumn
12:46:23 <h4199> facepalm: So close, where did row and column from the lhs go?
12:46:45 <jekor> Hmm...I just removed the template haskell splice and it works.
12:46:46 <hiptobecubic> I really liked the utility of Atoms in Erlang, but I can't seem to make sense of how they would work in any other language
12:47:01 <sproingie> what's special about erlang atoms?
12:47:09 <facepalm> oh toAddrress row column = Address toRow row toColumn column
12:47:19 <h4199> add parens
12:47:53 <hiptobecubic> sproingie, nothing "special" per se, but they were just a fluid and natural way to tag things.
12:48:20 <facepalm> toAddrress row column = Address( toRow row toColumn column)
12:48:25 <Botje> facepalm: urgh, don't guess.
12:48:36 <Botje> Address takes two arguments. not four, not one, not three.
12:48:44 <h4199> ^^
12:48:54 * geekosaur wonders if facepalm has any understanding whatsoever of this or is just throwing random syntax into the air
12:49:53 <facepalm> geekosaur: I am not throwing random syntax in the air. I have not had much exposer to it so as I said before I am kinda learning as I go along here
12:50:28 <burp> does it make sense to use forkProcess together with Control.Concurrent structures like MVar or Chan? (I guess not)
12:50:56 <h4199> facepalm: You gave Address 4 arguments, then you gave it 1, you want to give it 2.
12:51:24 <geekosaur> but you've been through this part of it already. multiple times, from what I've seen. yet you just threw what looks like random parens at that without any comprehension of what they mean or how they relate to anything
12:51:59 <geekosaur> burp, MVar and Chan only work within the same process
12:53:02 <burp> geekosaur: yea, that's what I guessed :D do you know a shared data structure that can be used with multiple processes?
12:53:17 <h4199> burp: forkIO not what you want?
12:53:49 <burp> h4199: no, I have an non-threadsafe external library, that I want to process data with
12:56:19 <geekosaur> burp, sharing data between processes is tricky anyway, but I suspect you just want pipes or possibly sockets
12:58:08 <facepalm> this should mean 2 args toAddrress row column = Address(toRow row)  (toColumn column)
12:58:33 <h4199> that will work
12:58:36 <burp> geekosaur: yes, I think that is what I want ;)
12:58:39 <Botje> facepalm: okay. now remember what we told you about toEnum.
12:58:54 <Botje> toRow row = toEnum row :: Row
12:59:05 <Nafai> jekor: I've been enjoying your videos.  Thanks for taking the time to make them!
12:59:07 <Botje> likewise for toColumn.
12:59:53 <facepalm> so I should be able tojust replace toColumn and toRow with toEnum column and toEnum row
13:00:04 <Botje> yes.
13:00:26 <Botje> because toEnum is being used in a place where its return type *must* be Row or Column.
13:00:58 <Botje> which means that Haskell picks the correct Enum instance and thus the correct toEnum function.
13:01:16 <facepalm> ah I see. now i just gotta fix this lacking accompanying binding error and should be good to go
13:01:41 <Botje> that means you forgot to write code for a variable whose type you've defined.
13:01:50 <facepalm> cool once this class is out I want to laern this a lot more in depth
13:02:22 <facepalm> oh I had toAddrress haha
13:02:31 <facepalm> extra r mistype
13:02:35 <Botje> buy a copy of LYAH or read it on a tablet.
13:03:54 <jekor> Hmm...I expanded the Template Haskell splice manually and it worked. Apparently they're incompatible :(
13:10:53 <Philonous> dcoutts:  http://www.haskell.org/pipermail/c2hs/2013-May/001115.html
13:12:25 <Philonous> dcoutts:  I hope I haven't missed anything. But at least it compiles and seems to generate valid code.
13:14:28 <ocharles> mm_freak: had a little play with loop and fixW, but think I'm missing something :(
13:14:36 <ocharles> your arrow tutorial is fantastic thoguh, i hope you finish that!
13:15:32 <ocharles> I wrote the wire at https://gist.github.com/ocharles/711c724faa69a1769f3e and was then trying to 'fixW' that or 'loop' it
13:15:51 <ocharles> loop doesn't make a difference (it just gives +1 on whatever goes into it) and fixW doesn't seem to ever produce any output
13:16:14 <monoidal> jekor: does it change if you write main :: IO () ?
13:20:05 <jekor> monoidal: Interesting...it does...
13:20:26 <jekor> Why would that be?
13:20:52 <jekor> Can it not tell that I have a let ?db = binding in main?
13:21:23 <monoidal> jekor: I don't know. what type you get infered for main? (you might change the name to main' and ask ghci.)
13:23:43 * jfischoff is delighted to learn he can fix ghci panics cabal cleaning his interface files
13:23:45 <jekor> OK, leaving it as it is, I get the same error loading the module into GHCi. If I rename it to main' I get main' :: (?db::Handle) => IO () as the infered type.
13:24:41 <monoidal> jekor: can you try let ?db = db in print' ?db 1 "test"
13:24:59 <elliott> jekor: nobody really understands how implicit parameters are inferred
13:25:05 <xcvii> hey, so now i've parsed a haskell expression into a Language.Haskell.Exts.Exp. i'd like to get the kind of the type of the expression (the type i don't really need right now). can it be done with haskell-src-exts? or otherwise?
13:25:09 <elliott> but the fact that their behaviour wrt type signatures is confusing is one of the reasons few people use them
13:25:35 <jfischoff> elliot: do you know of a legitimate use of them?
13:25:45 <luite> xcvii: haskel-src-exts doesn't have a typechecker
13:26:07 <jekor> monoidal: Sure, but the arguments would be wrong. Do you mean convert print''s ?db to an explicit param?
13:26:12 <elliott> jfischoff: they work as holes
13:26:15 <elliott> which is convenient
13:26:21 <jfischoff> elliot: how so?
13:26:24 <luite> xcvii: but there's some project to make one, haskell-suite
13:26:36 <elliott> jfischoff: foo :: Int; foo = length . ?x
13:26:37 * jfischoff has never use implicit paramters
13:26:45 <elliott> uh
13:26:53 <elliott> jfischoff: foo :: IO () -> IO Int; foo = return . length . ?x
13:26:55 <elliott> you get an error
13:26:55 <jekor> I believe this is a legitimate use: per-thread read-only (')
13:26:59 <elliott> could not deduce (?x :: IO () -> [a])
13:27:13 <elliott> I don't know any time I'd use them for their intended purpose :P
13:27:27 <xcvii> luite: ah ok, thanks. i'll check haskell-suite out
13:27:32 <jekor> per-thread read-only ("global") variables instead of dragging a transformed monad everywhere.
13:28:13 <elliott> jekor: check out the reflection package.
13:28:16 <elliott> @package reflection
13:28:17 <lambdabot> http://hackage.haskell.org/package/reflection
13:28:28 <elliott> it does the same as implicit parameters but IMO less error-prone
13:28:29 <jekor> I looked at that first but then balked at the apparent complexity.
13:28:51 <elliott> the interface is very simple (a single-member class and a function)
13:28:58 <Taneb> reflection is scary at first
13:29:00 <jekor> OK, I'll take a second look.
13:29:09 <elliott> the implementation is also only a handful of lines and very fast, though there is a much more elaborate implementation that is more portable and used as a fallback
13:29:12 <elliott> (described by the paper)
13:29:16 <jekor> An excample would really help.
13:29:30 <Taneb> But turns out easy if you sort of squint and pretend the types just say "this does what you want it to do"
13:29:33 <elliott> jekor: the git repo has some examples
13:29:50 <elliott> jekor: here's another one I wrote: http://hpaste.org/66715
13:29:53 <elliott> comparing it to ReaderT
13:30:26 <jekor> OK, thanks.
13:30:39 <monoidal> jekor: I don't know why this happens. this might be a ghc bug, but I'd have to look further. I'd just leave the type signatures visible.
13:31:10 <mm_freak> ocharles: first learn the semantics of feedback, so experiment a bit with simple constructions like this:  rec x <- integral_ 1 -< x; id -< x
13:31:23 <elliott> jekor: that said, if your DB can only be accessed from IO then ReaderT DBHandle IO isn't really that much noise on top
13:31:27 <elliott> especially if you define a short name for liftIO
13:31:34 <mm_freak> ocharles: that is:  rec { x <- integral_ 1 -< x }; id -< x
13:32:53 <jekor> elliott: There is a bit of pure config data passed along as well, which is my main motivation for getting rid of it (not using monad notation and the possibility of doing IO when I just want to get at that).
13:33:10 <mm_freak> ocharles: it's a slightly weird concept, because it doesn't really have a mathematical counterpart, at least not in calculus
13:33:46 <elliott> jekor: right
13:33:47 <jekor> (a user record constructed from a possible cookie)
13:34:32 <jekor> If it were not per-request I would just use unsafePerformIO and be done with it. I'm tempted to do that anyway with a thread-indexed data structure.
13:35:22 <mm_freak> ocharles: technically it's a very simple thing, but it has a problem:  feedback exposes the discreteness of time in wires:  it can only happen when a wire's current instant depends only on inputs from an earlier instant
13:40:07 <Haskell123c> How can i make ghci evaluate a function but not return its output?
13:40:34 <simpson> Haskell123c: You just want side effects to happen?
13:40:36 <jekor> You guys have been very helpful, and I have one more question/problem. I don't know how to reduce this one to a simple example: Could not deduce (MonadIO m0) arising from the ambiguity check [properly inferred type of function here]. The type variable `m0' is ambiguous. Then it goes on to list MonadIO instances MonadIO IO, one from parsec, one of my own MonadIO instances (SCGI monad), etc.
13:40:51 <facepalm> would this be correct if I want to take in an address and return and column row pair? toRowColumn :: Address -> Int -> Int -> (Int, Int)  toRowColumn address  = (Row(fromEnum address),Column(fromEnum address))
13:40:55 <Haskell123c> i want to test the time it takes to evaluate two different functions without having to see the output
13:41:02 <elliott> Haskell123c: x `seq` ()
13:41:03 <jekor> If I manually add the type signature that it tells me it has inferred ([...] -> IO a) it works.
13:41:10 <elliott> you might also like :set +s for timing info, if you don't know about it
13:41:15 <elliott> note that that only evaluates to weak head normal form
13:41:23 <elliott> if you return Int or such it is ok, if you return [Int] or whatever you need to do more
13:41:27 <Botje> facepalm: why is your type Address -> Int -> Int -> (Int, Int) ?
13:41:43 <elliott> jekor: it has no reason to pick IO over any other MonadIO instance
13:41:55 <Botje> facepalm: also, Row is not a data constructor.
13:42:09 <Botje> facepalm: also also, fromEnum takes a Row or a Column, not an Address.
13:42:19 <Botje> facepalm: pattern match on the address variable if you want the row and column.
13:43:01 <facepalm> so my type sig just needs to be Address ->(Int,Int)
13:43:07 <Haskell123c> i'll just ask the length of the list after the evaluation
13:43:08 <Botje> yes.
13:43:17 <Haskell123c> thanks
13:43:35 <jekor> elliott: I sort of think I understand, although I was thrown off by the inferred type showing IO. Is there a way to tell it to without adding a complete type signature?
13:44:21 <facepalm> and my lhs should just be adddress too?
13:44:37 <elliott> jekor: no, but it's good practice to give full type signatures for top-level definitions anyway
13:44:48 <elliott> if the type is long you could reduce the size with type synonyms
13:45:19 <Botje> facepalm: no, you need to pattern match on it to grab the Row and Column values inside.
13:48:58 <facepalm> so I can have like toRowColumn (x:xs) or (x,y) something along those lines for lhs
13:50:53 <Botje> that matches on lists and tuples, respectively. You need to match an Address value.
13:56:49 * hackagebot simplex 0.3.4 - A simple markup language that translates to LaTeX  http://hackage.haskell.org/package/simplex-0.3.4 (JulianFleischer)
13:57:16 <facepalm> perhaps something like toRowColumn address a a1 =
13:57:33 <Botje> facepalm: that's a function of three arguments.
13:59:42 <facepalm> and I only need 2
13:59:51 <Botje> why 2?
14:00:15 <Botje> you're taking one Address object and pattern matching two things out of it.
14:00:17 <facepalm> oh 1 argument but the result is a pair
14:00:34 <Botje> the result has no business being on the pattern matching side of your function definition
14:01:51 <facepalm> on lhs it should just be address then how I had it before
14:02:10 <Botje> but then you're pattern matching the entire address without knowing what's inside.
14:02:51 <Botje> might as well write 'toRowColumn pumpernickle = ...' as far as haskell is concerned
14:04:49 <nwf> Anybody used wl-pprint-extras or the like and know how to get it to insert a prefix before every line it prints?  I'd like to have it lay out pretty comments in a language that only knows about per-line commentary.
14:05:01 <Botje> facepalm: pattern matching on data types looks exactly the same as constructing them.
14:05:11 <Botje> facepalm: you just created an Address value in your toAddress function.
14:05:13 <h4199> facepalm: you want 1 argument that matches the pattern of an address, what would that look like?
14:05:17 <facepalm> I just changed it to Address a
14:05:27 <Botje> you changed what?
14:05:28 <Botje> the type?
14:06:02 <h4199> fromAddress (something that looks like an Address) = ...
14:07:03 <k00mi> @undo do Just x <- [Nothing]; return x
14:07:04 <lambdabot> [Nothing] >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
14:07:10 <k00mi> where does that case come from?
14:07:50 <nwf> k00mi: From the pattern match to the left of the <-
14:08:20 <monoidal> jekor: I think I know what happens in your code. For type inference, GHC groups definitions by strongly connected component, and typechecks them sequentially. This allows to infer general types.
14:08:25 <nwf> That behavior, including the "fail", is a tad bit unpleasant, but it's there to support some practical programming patterns with MonadPlus.
14:08:37 <nwf> k00mi: ^
14:08:46 <monoidal> jekor: However, if you use TH we cannoot sensibly define the connected components, and everything is grouped into one pile
14:09:05 <k00mi> nwf: so that gets insertet when desugaring do-notation?
14:09:27 <nwf> k00mi: Yes.
14:09:33 <facepalm> oh so my lhs is actually going to be the fromEnum
14:09:42 <k00mi> strange
14:09:54 <monoidal> jekor: your print' could, in principle, refer to main and that would form mutual recursion
14:10:39 <monoidal> looks like GHC first determines the connected components and only then runs TH. I don't know if the inverse order would make sense.
14:11:26 <monoidal> Since main and print' are in the same group, GHC infers the same constraint ?db :: Handle even though main defines ?db = db
14:12:33 <h4199> facepalm, toAddress takes numbers and returns an Address, so it makes sense that fromAddress should take an Address and return numbers, right? I don't understand your lhs question
14:12:53 <nwf> k00mi: Sort of, yes, but it's handy when using list comprehension notation.  mapMaybe f xs === [ f x | Just x <- xs ], for example.
14:13:26 <Botje> h4199: facepalm doesn't know how to pattern match on Address values.
14:13:47 <mitchellsalad> hi, anyone here have experience with the Language.C library?
14:14:58 <dmwit> ?where justask
14:14:58 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
14:15:41 <facepalm> h4199: yes that makes sense the difference between the 2
14:16:02 <k00mi> nwf: that's where I found it
14:16:59 <devth> haskell neophyte here: i learned how to capture piped input from stdin using getContents, but how do I detect if the user didn't provide any?
14:17:20 <mitchellsalad> alright, so according to the documentation (in Language.C.Analysis) you can "provide callbacks in the MonadTrav m" (for example, to execute some code when a function definition is traversed over), but i'm not really sure /how/ to provide a callback in the monad
14:17:27 <Botje> devth: you can't. the user might wait three years before typing something.
14:17:40 <Cale> devth: You could check if the string is empty
14:17:53 <devth> Cale: it blocks until the user hits ctrl-d
14:18:04 <Cale> getContents is somewhat magic, and gets the entirety of the user input lazily
14:18:18 <devth> so do I need to use a different function?
14:18:40 <Cale> Well, quite possibly, depending on what you're trying to do.
14:18:48 <h4199> facepalm: Figure out how to match the Address pattern in a way so that you can use the row and column information on the rhs. This is just /pattern/ matching and you are the person that wrote the pattern in the first place.
14:18:51 <Cale> Are you looking to wait for a timeout?
14:18:55 <devth> i want to be able to handle both cases of running my cli: `echo foo | hs-cli` or `hs-cli bar`
14:19:19 <Botje> devth: why not check for the presence of arguments first and resort to repl afterwards?
14:19:32 <devth> Botje: because they could provide both actually
14:19:51 <devth> echo foo | hs-cli bar -- in this case i want the string "bar foo"
14:20:13 <devth> all 3 ways are valid uses, and none should block
14:20:15 <Botje> devth: okay, so process the arguments first, then grab the rest using getArguments.
14:20:33 <Botje> you cannot really handle `hs-cli bar' like that, though.
14:20:51 <Botje> unless you expect the user to redirect STDIN to /dev/null
14:21:21 <devth> i've been using getArgs to get the "bar" part so far. that works.
14:21:50 <devth> seems like i should just be able to check the length of stdin
14:22:36 <Cale> The length of stdin is only well-defined once it's closed.
14:22:36 <Botje> if you call `hs-cli bar' like that, the user's terminal is connected to the stdin of your process.
14:22:44 <Botje> and a very slow user might type a character every year.
14:23:37 <devth> starting to understand
14:23:53 <hpaste> monoidal annotated “Unbound implicit parameter” with “Unbound implicit parameter (annotation)” at http://hpaste.org/87088#a87092
14:24:06 <Cale> (this isn't really a Haskell thing, it's a unix thing)
14:24:34 <monoidal> jekor: ^ here's a simpler example: even though f is defined as identity, substituting generalizes the type
14:25:00 <monoidal> jekor: Arguably this is a limitation of TH. GHC devs plan to make major improvements that might fix this.
14:25:07 <devth> yeah. it seems like i should be able to make a decision to not even attempt to read from stdin if its length is 0. i only care if it's immediately available, like when using pipes: echo foo | hs-cli
14:25:48 <arkeet> you might be more interested in checking if stdin is a terminal.
14:25:55 <arkeet> er, tty
14:26:19 <adas> are GADTs commonly used in place of the traditional "data = ...
14:26:29 <arkeet> @hoogle hIsTerminalDevice
14:26:30 <lambdabot> System.IO hIsTerminalDevice :: Handle -> IO Bool
14:26:30 <lambdabot> GHC.IO.Handle hIsTerminalDevice :: Handle -> IO Bool
14:26:30 <facepalm> toRowColumn (Address row column)  = ((fromEnum row), (fromEnum column))
14:26:58 <devth> arkeet: that might work
14:27:10 <hiptobecubic> for all the whining people do about haskell's IO, it sure seems to have everything.
14:27:55 <facepalm> h4199: got it
14:28:22 <devth> this guy seems to handle it in C http://stackoverflow.com/questions/12129134/c-only-read-from-stdin-if-the-desired-input-exists
14:28:23 <elliott> adas: if you don't need the GADT features, not really
14:28:29 <elliott> but some people use it, i'm sure
14:28:31 <h4199> facepalm: great
14:28:31 <elliott> it's more verbose :p
14:29:02 <arkeet> I think the GADT syntax makes more sense.
14:29:55 <h4199> facepalm: btw, if the assignment wants pairs I would modify your toAddress to take a (Int,Int) instead of Int ->Int . That way your functions invert each other correctly
14:30:50 <elliott> arkeet: agreed. it is also more verbose.
14:30:56 <arkeet> of course.
14:31:04 <arkeet> so I never use it unless I need a real GADT.
14:31:21 <elliott> arkeet: normal ADT syntax would make more sense if it, was, like, data Maybe a = Nothing | Just (_::a) or something.
14:31:24 <elliott> but that's hideous.
14:31:27 <arkeet> quite
14:31:32 <elliott> (and you'd read an implicit :: Maybe a at the end of each)
14:32:59 <elliott> arkeet: what if you could omit the data type name in GADTs?
14:33:05 <elliott> data where Nothing :: Maybe a; Just :: a -> Maybe a
14:33:09 <elliott> that might be good.
14:33:23 <elliott> you could also define, like, multiple data types in the same block, I guess.
14:33:53 <arkeet> sounds dangerously close to having open ADTs.
14:34:06 <Eduard_Munteanu> How about open GADTs you'd just add constructors to, like typeclasses/instances? :)
14:34:18 <Eduard_Munteanu> Ah.
14:35:03 <elliott> arkeet: well, it'd define the whole type in one "data where".
14:35:08 <elliott> it'd just be shorter.
14:35:08 <arkeet> I know.
14:35:27 <elliott> data where Left :: a -> Either a b; Right :: b -> Either a b
14:35:50 <elliott> newtype where StateT :: { runStateT :: s -> m (s, a) } -> StateT m s a
14:36:13 <arkeet> hmm
14:36:19 <Eduard_Munteanu> elliott: might be problematic if you want to specify kinds, or constraints
14:36:45 <arkeet> I think we are in a good position where we are now.
14:36:51 <elliott> Eduard_Munteanu: data where Cons :: forall (x :: k). ... -> Foo x?
14:37:08 <elliott> constraints on data types are useless
14:37:14 <elliott> I think GHC disallows them by default or something?
14:37:29 <elliott> arkeet: the two syntaxes for the same thing sorta sucks
14:37:31 <Eduard_Munteanu> Hrm... I also forgot Haskell doesn't distinguish parameters from indices. :/
14:38:45 <arkeet> elliott: I guess.
14:38:52 <arkeet> I guess by good I meant fine.
14:39:00 <monoidal> elliott: that's right, NoDatatypeContexts (it is non-H98 or H2010 compilant, but H2011 removed it)
14:39:10 <elliott> ah right, it's gone from the standard too.
14:39:11 <elliott> good riddance
14:39:21 <devth> arkeet: hIsTerminalDevice worked! ty
14:39:26 <devth> arkeet: contents <- hIsTerminalDevice stdin >>= \isT -> if isT then return "" else getContents
14:39:33 <Eduard_Munteanu> I wish they worked somehow.
14:40:05 <oio> an example of guard with Left Right ?
14:40:48 <elliott> Eduard_Munteanu: you can achieve something better with gadts
14:40:55 <monoidal> elliott: though H2011 was only announced with in a rather laconic message.
14:41:09 <elliott> yeah
14:41:12 <elliott> did they even publish a report?
14:41:29 <monoidal> don't know. the message is http://www.haskell.org/pipermail/haskell/2011-January/022497.html
14:41:53 <sirspazzolot> is there a haskell offtopic channel?
14:42:18 <sipa> #haskell-blah
14:42:18 <arkeet> #haskell-blah
14:42:20 <monoidal> in any case, DatatypeContexts are gone
14:42:23 <elliott> monoidal: ok, so there is no Haskell 2011
14:42:39 <elliott> they just released an official statement saying that the next Haskell standard will not have datatypecontexts
14:42:42 <monoidal> elliott: right.
14:42:45 <elliott> so it's not actually technically gone, I guess.
14:43:02 <arkeet> aren't they gone in haskell 2010?
14:43:05 <elliott> no
14:43:08 <arkeet> oh
14:43:12 <arkeet> just my wishful thinking then
14:45:40 <monoidal> trivia:  grep gives 86 occurrences of "stupid" in GHC compiler source. all or almost all refer to stupid theta (datatypecontexts).
14:46:36 <monoidal> I think some parts of the code get much messier because of it.
14:49:34 <hpaste> oio pasted “case to guards” at http://hpaste.org/87094
14:49:40 <oio> it is possible to translate this to guards?
14:49:54 <otters> why's it called stupid theta?
14:50:34 <monoidal> otters: it's useless / the way it is defined is stupid
14:51:10 <Rotaerk> hmm, if I have a bunch of functions with the same class constraints, and i'd rather not repeat myself in each, is there another way to do it besides:  type WithContraints x a = Constraints x => a; and then defining my functions like:  f :: WithConstraints x (x -> x)
14:51:13 <otters> monoidal: why theta?
14:51:15 <monoidal> otters: if you match on a constructor of a type, you should be able to *get* the context; but you are required to *supply* it
14:51:46 <latro`a> Rotaerk, you can abbreviate a little bit with DataKinds
14:51:47 <monoidal> otters: theta is used in formal notation to denote constraints
14:51:53 <elliott> stupid theta is the best name.
14:51:54 <otters> oh
14:52:12 <latro`a> you still wind up having to supply a constraint, but if you have a bunch of common ones you can give the whole "unit" a single name
14:52:13 <Rotaerk> latro`a, what's that
14:52:30 <Rotaerk> google's not turning up anything obvious
14:52:43 <latro`a> it's an extension that lets you define typeclasses like
14:52:53 <latro`a> type Foo a = (Bar a,Baz a)
14:53:07 <latro`a> not really a typeclass, actually, it just desugars to the ordinary constraint
14:53:24 <latro`a> then you get f :: Foo a => ...
14:53:27 <monoidal> oio: you should be able to do it with pattern guards, but I recommend against it. your code is perfectly fine use for case IMO.
14:53:38 <Rotaerk> latro`a, that's perfect; though I don't seem to find that via google
14:53:43 <Rotaerk> sure that's what it's called?
14:54:10 <latro`a> ...maybe I misremembered it, one sec
14:54:13 <Rotaerk> http://www.haskell.org/ghc/docs/7.4.2/html/libraries/Cabal-1.14.0/Language-Haskell-Extension.html
14:54:19 <Rotaerk> is all the extensions I think
14:54:25 <latro`a> ConstraintKinds, sorry
14:54:29 <mm_freak> latro`a: what you mean is ConstraintKinds
14:54:30 <latro`a> DataKinds is a thing, it's just not that
14:54:32 <oio> monoidal: i know but how?
14:54:40 <Rotaerk> thanks
14:54:58 <latro`a> an example I used was
14:55:12 <latro`a> type R r = (Fractional r,Ord r)
14:55:12 <latro`a> type N n = (Num n,Ord n)
14:56:19 <hpaste> monoidal annotated “case to guards” with “case to guards (annotation)” at http://hpaste.org/87094#a87095
14:56:24 <monoidal> oio: ^
14:56:36 <monoidal> once again, I strongly recommend against it.
14:57:41 <oio> monoidal: seems fine?
14:57:55 <monoidal> oio: it's unidiomatic.
14:58:09 <monoidal> oio: (btw ghc gives a bogus inexhaustive pattern match error)
14:58:30 <monoidal> it might be better with "Right x <- k" replaced with "otherwise"
14:59:25 <Rotaerk> latro`a, awesome; worked.  thanks
14:59:34 <monochrom> hrm, interesting
15:00:02 <monochrom> oh! view patterns may be a better alternative
15:00:33 <monoidal> monochrom: I thought about it, but avoided it because it would parse twice
15:00:52 <monochrom> readExpr (Left excp <- f) = "No seme " ++ show excp   (f x = parse symbol "Scheme" x)
15:01:05 <monochrom> no, somehow GHC won't evaluate twice
15:01:13 <monoidal> monochrom: isn't the syntax (f -> Left expr) ?
15:01:24 <monochrom> oh heh, I suck at view patterns!
15:01:42 * monochrom sucks at syntax! even scheme syntax!
15:02:09 <elliott> monoidal: single evaluation is guaranteed
15:02:11 <elliott> for view patterns
15:02:14 <elliott> otherwise they'd be sort of useless
15:02:26 <elliott> guaranteed by GHC, I mean. documented to be so
15:03:41 <monochrom> well, if you write "readExpr (parse symbol "Scheme" -> Left excp)", I am not too sure. but I am sure about "readExpr (f -> Left excp)"
15:04:07 <mo1> Is it possible to uninstall all cabal packages that i installed on windows. I tried to delevel ../AppData/Roaming/Cabal, but still there is old packages
15:04:15 <mo1> delete*
15:04:45 <monoidal> elliott: I see, thanks. (I agree with monochrom concerning non-var patterns)
15:05:18 <elliott> monochrom: I am sure about the former, I think.
15:05:20 <elliott> the GHC manual has details.
15:06:06 <elliott> The current notion of when two view pattern expressions are "the same" is very restricted: it is not even full syntactic equality. However, it does include variables, literals, applications, and tuples; e.g., two instances of view ("hi", "there") will be collected. However, the current implementation does not compare up to alpha-equivalence, so two instances of (x, view x -> y) will not be coalesced.
15:06:12 <elliott> nasty.
15:07:09 <monochrom> if you don't mind reading core, it is not too bad to try and find out for uncertain cases
15:07:54 <elliott> even easier to not use view paterns
15:07:56 <monoidal> fortunately, it would work in the original code
15:10:24 <oconnor0> i am trying to string together a bunch of functions that call "rawSystem" and return "IO ExitCode"; right now everything is called, but i want to changed that so that execution is stopped at the first "ExitFailure"; i think wrapping this in an "Either ExitCode (IO a)" or some such is the right approach.
15:11:16 <oconnor0> how do i go about introducing that monad into it without needing to rewrite every function but just make the changes in main?
15:11:44 <neutrino_> interesting problem
15:12:05 <elliott> oconnor0: you could just throw an exception for the cheap solution.
15:12:20 <oconnor0> cheap solution?
15:12:32 <elliott> failing that, you could make them use EitherT ExitCode IO a.
15:12:34 <elliott> you'll need edwardk's either package and to put liftIO in places, though.
15:12:37 <elliott> oconnor0: as in, that requires the least amount of global effort.
15:14:20 <oconnor0> elliot: i haven't used either throwing exceptions or EitherT in haskell, where's a good place with examples/explanations?
15:15:22 <elliott> oconnor0: Control.Exception has examples of the exception system
15:15:31 <elliott> EitherT is just like the Either monad, if you know that
15:15:42 <elliott> you just write a different thing instead of Left and have to liftIO your IO actions in.
15:16:00 <oconnor0> never used it, but have an idea of what it should do.
15:16:50 <cmccann> the Either monad is like the Maybe monad, except with something instead of Nothing.
15:16:52 * cmccann helps
15:17:05 <arkeet> haha
15:17:33 <arkeet> @remember cmccann the Either monad is like the Maybe monad, except with something instead of Nothing.
15:17:34 <lambdabot> Good to know.
15:18:17 * djahandarie doesn't like how people use "monad" when they're just talking about the type itself and not the monad instance
15:18:42 * arkeet too
15:24:22 <monochrom> the Either applicative and the Maybe Kleisli arrow :)
15:25:33 <oconnor0> monochrom: that means nothing to me :)
15:25:35 <hiptobecubic> djahandarie, but aren't we talking about the monad instance? Otherwise Either a and Maybe a aren't really "alike" other than "has 2 constructors"
15:25:37 <arkeet> Maybe isn't a Kleisli arrow. =(
15:26:05 <hiptobecubic> I guess you could say Either functor or something
15:26:13 <arkeet> it's a fine monad.
15:26:16 <hiptobecubic> but come on, who does that
15:26:53 <monochrom> the Either type and the Maybe type. that's Haskell Report's wording!
15:26:58 <bitonic> hiptobecubic: Maybe = Either ()
15:27:19 <hiptobecubic> bitonic, isomorphic sure. But not =
15:27:26 <hiptobecubic> At least not if you ask GHC
15:27:40 <hiptobecubic> And she's the only one I trust!
15:27:42 <monochrom> GHC would use ~ not = anyway :)
15:27:43 <bitonic> hiptobecubic: well I think nobody doubted the fact that they’re separate data types
15:28:09 <bitonic> but one is a more general version of the other—they are similar in a way.  the Monad instance reflects that
15:28:22 <hiptobecubic> bitonic, yes. Which is what I was saying.
15:28:32 <djahandarie> And you're wrong! Mwuahahaha
15:28:34 * djahandarie runs
15:29:10 <hiptobecubic> bitonic, if you pretend like cmccann *wasn't* talking about the monad instance then i don't think the sentence even makes sense.
15:29:20 <hiptobecubic> (not that you were)
15:29:34 <bitonic> hiptobecubic: well.  they’re more alike than any two types with 2 constructors.  I don’t know about the discussion before, I just read ‘Either a and Maybe a aren't really "alike" other than "has 2 constructors"’, which is misleading
15:30:05 <latro`a> strictly speaking Either a and Maybe a don't even have the same kind
15:30:09 <latro`a> although I did know what you meant
15:30:12 <hiptobecubic> latro`a, yea that was my bad
15:30:27 <djahandarie> hiptobecubic, sure it makes sense. The entire sentence is essentially stating that Either () is isomorphic to Maybe, if anything.
15:30:32 <djahandarie> But this really doesn't matter, it was a joke.
15:30:39 <djahandarie> My comment was meant to be general.
15:30:49 <cmccann> "Either ()" being isomorphic to Maybe is exactly what I meant, phrased in the most ridiculous way possible
15:31:01 <hiptobecubic> right
15:32:01 <cmccann> also, I only said "the Foo monad" because that's the phrasing elliott had just used. clearly the isomorphism between the types has nothing to do with their monad instances.
15:32:37 * djahandarie possibly picks up his Kleisli arrows of outrageous fortune and runs
15:33:30 <djahandarie> I sometimes wonder how much time Conor spends purely on inserting puns into his papers.
15:34:06 <elliott> re: "* djahandarie doesn't like how people use "monad" when they're just talking about the type itself and not the monad instance", I view both my statements and cmccann's as being about the monad instance
15:34:10 <hiptobecubic> Amazon Mechanical Turk probably handles it
15:34:20 <elliott> like, I parse cmccann's statement as "like the Maybe monad's semantics, but you get a thing when the computation fails"
15:34:22 <cmccann> djahandarie: my guess would be, less time than he spends inserting papers into his puns.
15:35:03 <hiptobecubic> elliott, that was what i thought as well. Clearly the types alone don't need that to be isomorphic, but the discussion was about the semantics of the monad instance i thought
15:36:14 <elliott> I think Conor is just made of puns.
15:36:23 <cmccann> elliott: yes, that was the intended interpretation in context, but is needlessly specific since the isomorphism extends beyond their monad instances.
15:36:23 <elliott> he eats a breakfast of puns every day.
15:36:28 <cmccann> also, this is a very silly conversation.
15:36:37 <mauke> he's a pundit
15:36:47 <djahandarie> LOL
15:36:52 <hiptobecubic> a con man, i say
15:37:05 <hiptobecubic> He probably has ghostwriters doins his material
15:37:07 <hiptobecubic> going*
15:37:35 <oconnor0> so conor puns his material off on ghostwriters for them to flesh out?
15:39:02 <hiptobecubic> sew it seams
15:39:33 * hiptobecubic flushes his head down the toilet
15:52:13 <jfischoff> how should I do dead code analysis on haskell code base?
15:52:15 <acowley> What's the package that abstracts over IO and ST to provide reference cells?
15:52:25 <hiptobecubic> hpc is it called?
15:52:32 <hiptobecubic> I just discovered it today
15:52:36 <hiptobecubic> or maybe it was yesterday
15:52:42 <hiptobecubic> it looks really solid
15:53:10 <hiptobecubic> acowley, not for you sorry. for jfischoff
15:53:18 <hiptobecubic> acowley, although i imagine you knew that
15:53:26 <acowley> hiptobecubic: Yeah, np
15:53:30 * jfischoff looks
15:53:35 <acowley> I wanted a package called, unsurprisingly, reference
15:53:42 <hiptobecubic> jfischoff, it's for code coverage
15:53:52 <monoidal> acowley: I believe there are several packages for that, reference might be most popular
15:54:09 <jfischoff> hpc might be exactly what I want
15:54:11 <hiptobecubic> jfischoff, but can *also* tell you things like whether or not a particular conditional was always true or always false, for example
15:54:27 <jfischoff> that's pretty cool
15:54:34 <elliott> acowley: there's StateVar too!
15:54:35 <hiptobecubic> i thought so
15:54:37 <elliott> and uh, other things.
15:55:13 * cmccann prefers to just wrap "readFoo" and "writeFoo" in a record type parameterized by the monad
15:55:15 <acowley> Yeah, monad-statevar does IO and ST
15:55:23 <cmccann> this is a case where dictionary passing seems simpler.
15:56:02 <elliott> cmccann: oh, good idea.
15:56:14 <hpc> wait what?
15:56:19 <hiptobecubic> and you don't even have to do anything. it's ghc -fhpc when you build and then `hpc markup file.tix` for a colored coded html rendering of the code
15:56:21 <elliott> cmccann: you need a typeclass for newRef though.
15:56:31 <hpc> hiptobecubic: how dare you have the same first letter as me! ;)
15:56:45 <cmccann> elliott: there are enough minor differences in semantics between different reference types that I don't trust code relying on that anyway
15:56:58 <hiptobecubic> hpc, I was telling jfischoff about how you manually test programs and count the number of times every conditional passes or fails
15:58:03 <cmccann> I should start naming packages after random people on IRC, just to confuse everyone.
15:58:08 <elliott> cmccann: you're a minor difference in semantics.
15:58:08 <hpc> haha
15:58:23 <kyle__> Is there any way get funtions to return their output into the void, instead of the "Couldn't match type `[]' with `IO'" if you don't print the output?
15:58:26 <cmccann> elliott: no, I don't have a well-defined semantics
15:59:26 <elliott> cmccann: yeah well, you don't even have a well-defined semantics in the first place.
15:59:30 <elliott> cmccann: thanks for writing my next burn for me btw.
15:59:47 * cmccann is helpful
16:00:16 <jfischoff> am I right that hpc requires one to run the code before it can be analyized?
16:00:28 <jfischoff> I was hoping for something that I could use statically on the code
16:00:42 <hpc> jfischoff: it's true
16:00:47 <jfischoff> I don't trust that the tests are hitting all code that is being used
16:00:48 <jfischoff> hmm
16:00:52 <hpc> i am a big stickler for those thigns
16:01:09 <jfischoff> is there another alternative (nothing against you hpc)?
16:01:22 <cmccann> jfischoff: try elliott instead
16:01:32 <elliott> isn't the whole point of coverage checking that it tells you where your tests aren't hitting?
16:01:49 <jfischoff> no that is not what I am trying to determine
16:02:03 <hiptobecubic> jfischoff, it tests code, not tests.
16:02:11 <hiptobecubic> tests can be code
16:02:13 <jfischoff> I want to no which files in a project are no longer being used
16:02:20 <hiptobecubic> but don't have to be
16:02:22 <jfischoff> are no longer reachable from main
16:02:33 <hiptobecubic> oh
16:03:08 <hiptobecubic> jfischoff, graphmod maybe?
16:03:27 <andrewsw> :t not . flip isPrefixOf
16:03:28 <lambdabot>     Couldn't match expected type `Bool' with actual type `a0 -> c0'
16:03:29 <lambdabot>     Expected type: a1 -> Bool
16:03:29 <lambdabot>       Actual type: a1 -> a0 -> c0
16:03:35 <hiptobecubic> makes a "dot" dependency graph
16:03:49 <jfischoff> hiptobecubic: yes perhaps
16:04:21 <andrewsw> :t map (not . flip isPrefixOf "abc")
16:04:23 <lambdabot> [[Char]] -> [Bool]
16:05:04 <andrewsw> @pl \x -> map (not . flip isPrefixOf x)
16:05:05 <lambdabot> map . (not .) . flip isPrefixOf
16:05:30 <andrewsw> @pl \x -> and $ map (not . flip isPrefixOf x)
16:05:31 <lambdabot> and . map . (not .) . flip isPrefixOf
16:06:11 <andrewsw> :t \x -> and $ map (not . flip isPrefixOf x)
16:06:14 <lambdabot>     Couldn't match expected type `[Bool]'
16:06:14 <lambdabot>                 with actual type `[a0] -> [b0]'
16:06:14 <lambdabot>     In the return type of a call of `map'
16:06:23 <andrewsw> :t (\x -> and $ map (not . flip isPrefixOf x))
16:06:25 <lambdabot>     Couldn't match expected type `[Bool]'
16:06:26 <lambdabot>                 with actual type `[a0] -> [b0]'
16:06:26 <lambdabot>     In the return type of a call of `map'
16:12:32 <otters> ghci is that way
16:12:37 <bwr> Can someone point me in the right direction? Using SAX parsing with hexpat I get [SaxEvent String String], but I'm not really sure how t
16:12:40 <bwr> o process this in a functional manner.
16:14:06 <acowley> bwr: You'll have to supply more details for anyone to help
16:14:12 <bwr> acowley: ok
16:16:20 <Ralith> bwr: walk it with a fold and build up whatever output data you want
16:16:22 <bwr> I'm trying to parse the wikipedia xml dataset. It has a huge number of <page> tags with various tags inside of the <page> tag. I basically just want to extract some of the data. The problem I'm having is that the data is just a list of stuff like [..,StartElement "title" [], CharacterData "title of article", EndElement "title",...]
16:16:55 <acowley> That's the nature of SAX parsing
16:17:15 <bwr> Ok, i'll try to do it with fold
16:17:23 <monoidal> andrewsw: and (map f x) == all f x
16:17:43 <acowley> bwr: I would break it down into several smaller functions
16:17:52 <andrewsw> monoidal: yeah.
16:18:10 <acowley> bwr: At the very least something that deals with one <page>…</page> at a time
16:18:34 <bwr> ok
16:19:01 <Ralith> this might be a case where it's best to write the walker by hand
16:19:29 <bwr> what's the walker?
16:19:31 <acowley> bwr: So now you just want to pull out the sections of the event list corresponding to the page elements, and send them to your helper function, that helper function pulls out the data you want
16:19:56 <Ralith> the walker is the code you are trying to write
16:20:36 <chrisdotcode> hey haskellians :)
16:21:00 <chrisdotcode> haskellians, or is it haskellites?
16:21:13 <monoidal> haskellers
16:21:19 <ijp> haskelloids
16:21:32 <Rembane> Haskellors!
16:21:44 <acowley> Haskellerooneys, if we're being formal.
16:21:45 <ijp> and cohaskelloids
16:23:59 <Ralith> I'll have you know that I'm haskellese
16:24:07 <oio> combine guard and returns ? return $ |
16:26:33 <geekosaur> was that a question?
16:27:01 <monoidal> oio: you can use multi-way if in 7.6: return $ if | ...
16:27:19 <chaoslynx> hi, why does let zs = [z**4 | z <- [1..], z**4 <= 10**6] hang, when evaluating zs in ghci?
16:27:49 <geekosaur> chaoslynx, because haskell cannot tell that after some point the filter expression will always be false
16:28:02 <geekosaur> it is a filter, not a takeWhile
16:28:13 <monoidal> oio: though I prefer if-then-else
16:28:18 <chaoslynx> oh, i see
16:28:18 <ijp> well, there is a list comprehension extension that you could use here
16:28:22 <oio> monoidal: nope..
16:28:35 <monoidal> oio: ?
16:28:44 <oio> monoidal: no 7.6
16:29:00 <monoidal> ah you poor soul.
16:29:27 <monoidal> oio: is that just a sequence of bools? then if-then-else
16:29:42 <monoidal> oio: you can write "return x" and below "where x | ... "
16:30:08 <oio> monoidal: not bools .. custom types..
16:30:25 <monoidal> oio: you are using pattern guards?
16:30:59 <oio> monoidal: no
16:31:48 <monoidal> oio: then I don't understand. can you hpaste?
16:34:01 <oio> monoidal: func =do add "nuj"  return $ case mol of
16:35:01 <monoidal> oio: and line below?
16:36:35 <oio> "zxc" -> Bool True
16:37:28 <ijp> chaoslynx: http://www.haskell.org/ghc/docs/6.10.2/html/users_guide/syntax-extns.html
16:37:48 <ijp> you could do something like [z**4 | z <- [1..], then takeWhile by z**4 <= 10**6]
16:38:40 <monoidal> oio: but you don't have guards here. It's normal pattern matching. I'd leave it as it is. Or, you can write "let x = case mol of ..." and later "return x"
16:39:19 <oio> monoidal: k smart dude
16:40:29 <chaoslynx> ijp: thanks, i am just writing a brute force program that searches for all xyzw, such that x**4 + y**4 + z**4 = w**4
16:41:02 <monoidal> oio: alternatively, you can define a _function_ f such that f "zxc" = Bool True and other cases, and then write "return (f x)"
16:41:11 <ijp> isn't the first example for that pretty big?
16:41:32 <chaoslynx> ijp: i have a fast processor :)
16:41:52 <ijp> suit yourself
16:42:12 <monoidal> note ** is for doubles. [z^4 | z <- [1..]] might be more appropriate
16:42:36 <Hafydd> map (^4) [1..]
16:42:56 <acowley> ah crap, kindFunResult impossible happened
16:43:00 <acowley> this code has bad karma
16:43:06 <monoidal> > map (^4) [1..]
16:43:08 <lambdabot>   [1,16,81,256,625,1296,2401,4096,6561,10000,14641,20736,28561,38416,50625,65...
16:43:21 <monoidal> acowley: almost certainly this means you have a type error
16:43:33 <acowley> Yes, I just wanted more information on my type error
16:44:03 <chaoslynx> oh, ok i should use ^ then
16:44:42 <chaoslynx> and i think i need a better way to generate all symmetric triples
17:04:24 <Ghoul_> Can somebody help me convert a list into a reverse linked list via a data constructor with a Maybe recursive member
17:05:00 <Ghoul_> Here's my code (so far): http://hpaste.org/87108 . In `varExpr` I have a list of things, `vchain`
17:05:55 <Ghoul_> VarCtx (Maybe Expr) Var should be able to nest a VarCtx( VarCtx( VarCtx .. but I've been trying for a couple days and keep getting lost in the logic :|
17:08:32 <cmears> vchain has a value like [e1,e2,e3], where each ei is an Expr (specifically, a VarRef) ?
17:08:53 <Ghoul_> It's always a chain of VarRef's
17:09:18 <Ghoul_> I want to transform it into a backwards linked list of VarCtx's where the last element that doesn't link anywhere uses Nothing
17:09:27 <Ghoul_> ie: the first element of the list becomes the back
17:09:31 <cmears> By "chain" you mean list?
17:09:54 <Ghoul_> Oh, yes, sorry.
17:10:03 <cmears> OK (:
17:10:43 <cmears> So for example vchain might be [VarRef (Var "a") Nothing, VarRef (Var "b") Nothing, VarRef (Var "c") Nothing]
17:10:53 <cmears> What would your desired result be for that?
17:11:09 <cmears> (I mucked up the brackets a bit)
17:11:27 <cmears> (should be VarRef (Var "a" Nothing), etc.)
17:11:56 <Ghoul_> VarCtx ( VarCtx ( VarCtx ( Nothing, Var "a" ) Var "b" ) Var "c" ) I think
17:12:11 <Ghoul_> woops, it's a little wonky
17:12:53 <Ghoul_> Also, I didn't include the second member to Var since it's not completely important in the analogy of how it should look
17:14:19 <cmears> A fold seems like the right way
17:15:09 <Ghoul_> The nested construction is really confusing. I know that I think I need to use either a helper lambda or flip and that the input list has to be in reverse
17:15:54 <cmears> "foldl (\innerContext var -> VarCtx innerContext var) Nothing (reverse vchain)" seems right
17:15:59 <cmears> But it looks like you already tried that
17:16:28 <Ghoul_> Yours looks slightly different, I'll give it a shot
17:16:48 <Ghoul_> I couldn't get mine to compile because I'm not that hot w/ hask
17:19:35 <Ghoul_> `Couldn't match Maybe  Expr with actual type Expr`. I tried wrapping it like so; VarCtx (Just innerContext) var but then I got `couldn't match expected type Expr with actual type "Maybe a0"`
17:19:59 <cmears> Oh yes
17:20:57 <cmears> Perhaps the best way is to use foldl1 instead
17:22:45 <acowley> That cafe thread on compatibility was very frustrating
17:23:35 <cmears> Ghoul_, maybe "foldl (\innerContext var -> Just (VarCtx innerContext var)) Nothing (reverse vchain)"
17:23:57 <cmears> Although that will give you an extra "Just" on the outside you'll want to remove
17:24:05 <cmears> (with a fromJust perhaps)
17:24:17 <cmears> It's not the most beautiful way
17:24:45 <Ghoul_> Is there any difference if I just wrap innerContext in just
17:27:46 <cmccann> acowley: people who don't want to deal with compatibility issues should just not upgrade any packages or GHC itself more than once every 2-3 years at most
17:27:58 <cmccann> that would reflect the situation they experience elsewhere much more closely
17:28:53 <c_wraith> cmccann: the problem with that is new installs
17:29:08 <acowley> cmccann: Yeah, not to mention that they didn't seem to stumble across any useful tutorials written in the past 5 or so years.
17:29:18 <cmccann> the older versions of everything still exist out there
17:29:26 <acowley> cmccann: But I respect their frustrating at evidently having wasted a bunch of time. Not much anyone can do to address that.
17:29:36 <c_wraith> sure, but where are they going to get old hackage indexes?
17:29:39 <Ghoul_> OK made it work. Wrapping it in fromJust is probably dangerous since zero elements will crash the compiler
17:29:44 <Ghoul_> but it'll work for now! thanks
17:30:12 <Ghoul_> (And actually, come to think of it -- that test case is not possible anyway because sepBy1 only matches 1 or more~)
17:30:27 <acowley> cmccann: But no matter the language, if I download code from some website that hasn't been touched in several years, I feel really lucky if it works first try
17:30:33 <cmccann> c_wraith: cloning whatever existing systems they have? that's also a real thing that people do when it's impossible to reconstruct a perfectly compatible environment.
17:31:01 <cmccann> and if they don't have any pre-existing systems they have no reason to need the older stuff so eh
17:31:13 <c_wraith> unless they want to use ancient libraries, apparently
17:31:47 <elliott> acowley: I didn't understand that thread because the first post was some nonsense I didn't understand and everyone replied seriously?
17:31:53 <elliott> like, what on earth was that about "import Prelude"?
17:32:03 <acowley> elliott: I have no idea
17:32:30 <acowley> elliott: I think the rant was close enough to the usual problems people have with version compatibility that everyone assumed it was that old argument
17:33:20 <acowley> Regular haskellers get pretty heated about upper version constraints, for example.
17:33:21 <cmccann> elliott: some weird issue with H98 and the old-style flat module namespace it seemed
17:33:53 <cmccann> ugh, gratuitous upper bounds in cabal files have caused me more hassle than anything else
17:34:12 <Clint> they suck
17:34:17 <elliott> cmccann: edwardk eliminated all the upper bounds for his own packages.
17:34:23 <cmccann> elliott: yes I know
17:34:27 <elliott> more edwardk platform lock-in.
17:34:34 <cmccann> I was on IRC for the day he decided to do that
17:34:42 <elliott> "where were you the day edwardk removed his upper bounds?"
17:34:48 <cmccann> after reuploading roughly 20% of hackage because of one change in one of his packages
17:34:53 <acowley> Wow, I didn't know that
17:34:58 <elliott> uh oh
17:34:59 <elliott> we called him
17:35:03 <cmccann> apparently
17:35:03 <acowley> Glad to hear it though
17:35:05 <elliott> everyone hide
17:35:14 <elliott> acowley: it was only the upper bounds on his own dependencies though.
17:35:16 <elliott> not on external packages.
17:35:16 * acowley hides under elliott's upper bound
17:35:20 <c_wraith> no one was talking about edwardk.  no one at all.
17:35:22 <acowley> ah
17:36:04 <c_wraith> Honestly, what's really needed is the ability to edit upper bounds of a package without uploading a new version.
17:36:18 <c_wraith> That would make a "no upper bounds until something breaks" policy actually work.
17:36:20 <sclv> refold: ping
17:36:36 <refold> sclv: pong
17:36:36 <elliott> c_wraith: isn't that functionally equivalent to adding a very small number to the version number?
17:36:50 <sclv> so you have a really nice soc proposal
17:36:57 <cmccann> elliott: but yeah, I think he spent several hours updating all of his packages to have new upper bounds because one little change, it was utterly ridiculous
17:36:59 <sclv> but it overlaps with another really nice soc proposal :-(
17:37:10 <c_wraith> elliott: sure, and indicating it that way would be fine. The thing that would make it nice is avoiding uploading new packages with tweaked cabal files
17:37:30 <sclv> if you both had alternate proposals it would make everyone feel better i think?
17:37:48 <sclv> because then we could pick based on technical considerations without worrying about knocking out one or another good candidate
17:37:53 <sclv> just a heads up!
17:37:57 <refold> sclv: which one?
17:38:05 <sclv> does it overlap with you mean?
17:38:09 <refold> sclv: yes
17:38:18 <cmccann> sclv: alternatively, the matter could be settled with pistols at dawn
17:38:41 <sclv> refold: http://www.google-melange.com/gsoc/proposal/review/google/gsoc2013/parcs/1
17:38:46 <cmccann> I mean if it's good enough for galois who are we to argue
17:38:54 <c_wraith> cmccann: that requires being in the same place.  your choice of competitive online games at dawn in some time zone.
17:38:56 <sclv> see where that got him!
17:39:01 <sclv> set group theory back by decades
17:39:03 <cmccann> sclv: a minor detail
17:40:17 <sclv> refold: that proposal is for doing ghc --make -j directly, basically
17:40:40 <blackdog> hey, i wrote up something on testing in haskell - anyone feel like giving it a quick once-over to check i'm not doing anything too stupid? http://www.shimweasel.com/2013/05/03/guard-for-haskellcabalhspec-projects/
17:40:47 <sclv> alternately you could formulate the -server portion of your proposal to make it more broadly useful than just in parallel builds
17:40:52 <elliott> @quote shachaf galois
17:40:53 <lambdabot> shachaf says: It is a sobering thought that by the time Galois was my age, he had been dead for almost two months.
17:41:02 <sclv> hahaha
17:41:15 <refold> sclv: this should be compatible with my proposal
17:41:44 <sclv> right but i'm not sure why both are better than one, assuming they both succeed?
17:41:59 <sclv> maybe you could explain that more clearly for my feeble brane
17:42:06 <sclv> :-P
17:42:52 <refold> sclv: ghc --make -j is useful in itself
17:43:38 <refold> sclv: and the Cabal support that I implement as part of my proposal should be possible to extend to support ghc --make -j
17:43:45 <sclv> right. but if we can do that, what will the -server thing add?
17:43:47 <luite> refold: do you also distributed builds with shake and cabal in mind?
17:43:50 <luite> with the -server?
17:44:10 <parcs> refold: "Additionally, this has been attempted by Thomas Schilling in the past before, with negative results - parallel patches were slowing down the serial compilation too much." where can i read more about this?
17:44:18 <sclv> @quote OlinShivers galois
17:44:18 <lambdabot> OlinShivers says: As my advisor said, the tragedy of Galois is that he could have contributed so much more to mathematics if he'd only spent more time on his markmanship.
17:44:18 <refold> luite: no
17:44:26 <refold> parcs: ask nominolo
17:45:02 <hiptobecubic> blackdog, I've been doing this kind of thing for awhile now using inotifytools (linux only). It's really great
17:45:10 <hiptobecubic> I use it for everything now
17:45:24 <sclv> i just only realized btw that semantics with adjunctions were traditionally done with galois connections hence why they picked the name for the company. doh
17:45:50 <hiptobecubic> blackdog, and it works from the commandline so you can start one up on the fly. Maybe I should blog it :)
17:46:19 <hiptobecubic> blackdog, it's not smart about code though. Just a shell that looks for filesystem events and runs a command
17:47:18 <cmccann> sclv: were you the one with the horrible, terrible joke about galois's adjunctions being backwards or whatever it was?
17:47:37 <sclv> no but i vaguely remember it?
17:47:49 <cmccann> sclv: they're backwards because he never got the hang of duals
17:47:51 <cmccann> obviously
17:47:57 <sclv> oh no
17:48:04 <shachaf> cmccann: :☹(
17:48:23 <ab9rf> cmccann: that's terrible
17:48:33 <parcs> aha http://www.haskell.org/pipermail/glasgow-haskell-users/2011-August/020848.html
17:48:33 <cmccann> sclv: coulda sworn I heard that from you originally but I may be misremembering
17:48:41 <sclv> oh wait i did say it!
17:48:49 <djahandarie> Haha
17:48:58 <hiptobecubic> cmccann, :D
17:49:00 <sclv> the one google result in the universe for it is me
17:49:02 <cmccann> ab9rf: it really is and I feel bad for laughing so hard :[
17:49:06 <sclv> i make so many bad jokes
17:49:09 <refold> sclv: ghc --server thing can be a start for a more general 'compile daemon' mode that will allow faster incremental builds. and a hedge against the other project failing.
17:49:39 <ab9rf> the haskell compiler should anticipate the code you're going to write and start compiling it before you've written it
17:49:55 <refold> sclv: for now it has an intentionally limited scope.
17:50:13 <hiptobecubic> ab9rf, GHC thought police.
17:50:21 <hiptobecubic> Think how *safe* we'll be
17:50:31 <refold> sclv: because I'm more familiar with the Cabal codebase.
17:50:35 <luite> refold: ah that's actually quite useful. yesod devel has a compile daemon for that reason, faster restarts
17:51:36 <sclv> refold: might be useful just to recast your proposal to emphasize that sort of stuff as an "if both are accepted i'll lean towards where they differ" sort of thing
17:51:50 <refold> luite: as does snap IIRC
17:52:11 <luite> refold: oh i thought snap had the handlers run through hint or something
17:52:16 <cschneid> what are people's workflows around haskell? Does the community standardize around processes like test-driven-dev, or other small-scale workflow approaches?
17:52:23 <refold> sclv: I can add a section about that
17:52:46 <elliott> type-driven dev
17:52:53 <sclv> @remember sclv Q: Why are the adjunctions of Galois connections backwards? A: He never got the hang of duals.
17:52:53 <lambdabot> Done.
17:52:59 <sclv> self remember, bad look i know :-P
17:53:22 <cschneid> elliott: :) so it's a "think hard up front" approach to some degree?
17:53:29 <cschneid> elliott: data structures first, then build up
17:53:45 <cmccann> sclv: nah I brought it up so it's fair
17:54:04 <sclv> refold: cool. thx.
17:54:18 <elliott> cschneid: type-driven dev is similar to test-driven development, I think.
17:54:40 <elliott> cschneid: before you go to write a procedure, decide how you'd like it to behave --> before you go to write a function, decide what its type should be
17:54:58 <elliott> then write it. if it doesn't type-check (pass the tests), you've made a mistake. if it does, you still might have made a mistake
17:55:50 <cmccann> elliott: it totally is test-driven development. first you write your type signatures that say what the code does, then you write implementations to test whether the types are correct
17:56:00 <cmccann> the only difference is that you ship the tests as the final application for some weird reason
17:56:07 <cmccann> :P
17:56:24 <acowley> What is the right name for this: Monad m => StateT s m (a -> b) -> a -> StateT s m b
17:56:25 <sclv> this is truth. when i write a function i never make a mistake. when i write types, on the other hand, i'm frequently wrong.
17:56:52 <elliott> cmccann: hehe
17:56:58 <sclv> \x -> liftM ($x)
17:57:11 <sclv> or a flip of that
17:57:15 <elliott> acowley: flip, if you're ski
17:57:52 <cmccann> @pl \f x -> liftM ($ x) f
17:57:53 <lambdabot> flip (fmap . flip id)
17:57:59 <cmccann> there we go
17:58:01 <cmccann> clear as can be
17:58:10 <cschneid> cmccann: hah, fun way to look at it. What behavior level testing do you guys do? hunit? (to prove that your func not only typechecks, but does what you expect)
17:58:10 <acowley> :/
17:58:25 <dolio> acowley: flip
17:58:26 <cschneid> i've seen hunit, hspec, and quickcheck. And then combos of those
17:58:27 <dolio> Obviously.
17:58:28 <acowley> Not even I hate myself enough to leave that in my code
17:58:28 <sclv> if your types are good enough it can only do one thing
17:58:36 <acowley> "flip"
17:58:52 <elliott> quickcheck is useful for testing functions where the type is loose enough and the implementation complex enough to provide reasonable expectation of gross error
17:59:17 <refold> parcs: http://www.haskell.org/pipermail/glasgow-haskell-users/2011-August/thread.html#20811
17:59:23 <cmccann> quickcheck is good for catching all my stupid mistakes involving basic arithmetic
17:59:23 <cschneid> I imagine a fair bit is just keeping individual functions small enough that you can reason them correct, then combining them and reasoning that combo correct?
17:59:42 <sclv> yeah quickcheck for off by one errors and corner cases ftw
18:00:03 <cmccann> cschneid: also, sanity testing in GHCi
18:00:11 * tgeeky thinks we underuse the hell out of quickcheck (and smallcheck)
18:00:12 <sclv> i'm a slob with testing honestly. i mainly do poking it in ghci and then big integration tests
18:00:23 <cschneid> tgeeky: smallcheck huh, time to google
18:00:31 <dolio> acowley: I called it 'eta' previously.
18:00:35 <elliott> cmccann: in an ideal language the interface we use to do tests in GHCi would be the same interface we use to write checkable doctests. :(
18:00:40 <parcs> refold: yep, thanks
18:00:56 <elliott> acowley: I think I've seen it called "strength"
18:00:57 <cmccann> elliott: that sounds quite ideal indeed
18:00:57 <dolio> Because it's the equivalent of doing \x -> f x in a language with side effects.
18:01:06 <acowley> dolio: That's a thought provoking name
18:01:12 <dolio> But eta is really overloaded.
18:01:18 <elliott> the nice thing about naming something eta is that it could mean thousands of things.
18:01:21 <cschneid> sclv: it's interesting coming to haskell from ruby, since ruby forces you to do practically all verification, and because of that, has tools that make that easy.
18:01:24 <elliott> so nobody will ever doubt that it's an accurate name
18:01:24 <Ghoul_> How an I append a single maybe element to the start of a list /only/ if it isn't nothing
18:01:31 <sclv> strength usually is lifting (,) not $
18:01:34 <cmccann> elliott: better still is to name it η
18:01:36 <elliott> or ask which eta you mean, then they'd look ignorance.
18:01:38 <elliott> ignorant.
18:01:39 <Ghoul_> The list is of a Maybe type, so I also need to remove the monad
18:01:40 <elliott> sclv: oh, right
18:01:58 <Ghoul_> err, the thing I'm appending is Maybe. The list is not.
18:02:03 <cmccann> elliott: man I hate to look ignorance.
18:02:14 <sclv> fmapDollar
18:02:18 <sclv> :-P
18:02:37 <acowley> Well, I'm just not going to export it from my module so I don't have to worry too much about the name
18:02:47 <acowley> I'll paste an IRC log in the comment just to keep things clear
18:03:00 <sclv> ?ty maybe
18:03:01 <lambdabot> b -> (a -> b) -> Maybe a -> b
18:03:17 <cmears> Ghoul_, you can use "maybeToList" and then a regular append with ++
18:03:19 <tgeeky> cschneid: that said: doctest is probably more implactful to helping your package than any of these.
18:03:25 <cmccann> :t maybe id (:)
18:03:27 <lambdabot> Maybe a -> [a] -> [a]
18:05:12 <sclv> perfect !
18:05:12 <tgeeky> cschneid: also, I was intrigued by this: http://hackage.haskell.org/package/ClassLaws .
18:05:12 <mapreduce> [1..10] ++ maybeToList (Just 20)
18:05:12 <Ghoul_> thanks.
18:05:12 <sclv> tgeeky: reminds me of this: http://hackage.haskell.org/package/checkers
18:05:56 <sclv> cschneid: we have those tools too. things like test-framework are great and we also have integration with cabal, etc. we also just have a chunk of people who never mess with that stuff for day to day hacking
18:06:40 <elliott> i always feel artificial writing tests. I know for a fact I'm not going to be good at picking the edge-case data that actually breaks my function
18:06:55 <ab9rf> i'm not fond of test-driven development
18:06:57 * tgeeky wishes I had the confidence that some of you have.
18:07:06 <blackdog> hiptobecubic: i'm glad someone else is concerned with the quick feedback
18:07:31 <Ghoul_> :t (<*)
18:07:34 <lambdabot> Applicative f => f a -> f b -> f a
18:08:28 <hiptobecubic> blackdog, it's amazing
18:08:51 <hiptobecubic> blackdog, my first exposure was using nosetester with python, which i think is highly similar to what you describe here
18:09:05 <hiptobecubic> but now it's an essential part of life
18:10:27 <hiptobecubic> blackdog, actually. I retract that. The first I saw anything like it was probably sbt, scala's thing.
18:10:35 <hiptobecubic> When I did the coursera course
18:10:36 <blackdog> hiptobecubic: it would be nice if it could be a bit faster - as it stands with cabal, i don't really want to build everything, don't want to do optimisation, all that sort of thing.
18:10:44 <blackdog> but the big problem is ghc-mod does autosave
18:11:08 <blackdog> i love ghc-mod, it makes that feedback even quicker, but autosave means filesave detection is worthless
18:11:26 <acowley> ghc-mod is glorious
18:11:47 <hiptobecubic> well if you're in linux, inotifytools are pretty powerful. You can put a lot of constraints on what causes it to to fire
18:12:01 <hiptobecubic> I suppose it's a problem if your target file is saving constantly though
18:12:05 <blackdog> hiptobecubic: how would you tell the difference?
18:12:06 <blackdog> yeah
18:12:08 <acowley> My GHC panicking code from earlier was screwing up flymake and I was lost without my rainbow of error reports
18:13:01 <blackdog> absolute best case would be a way of feeding back information to ghc-mod such that it could highlight failing test cases too, and a mod to ghc-mod so that it did all of its sneaky autosaving in a shadow directory somewhere.
18:14:45 <elliott> maybe I should start using that ghc-mod thing.
18:15:16 <acowley> elliott: It is a thick, snugly coding comfort blanket
18:15:19 <parcs> hmm, why is unsafeDupablePerformIO marked NOINLINE?
18:15:22 * elliott doesn't even really know what it does, but it sounds fancy.
18:15:39 <hpc> parcs: so it goes through the function call multiple times
18:15:40 <parcs> never mind, the comment right underneath it explains why
18:15:41 <blackdog> elliott: it is sex on toast. all the best bits of an ide.
18:15:48 <acowley> elliott: It highlights mistakes when they're still just a glimmer in your eye, and pats you on the back when you clean up your act
18:15:50 <hpc> or yeah, comments
18:16:28 <elliott> how is the vim support?
18:16:41 <parcs> ghc uses a variant of unsafeDupablePerformIO that's marked INLINE
18:16:45 <acowley> blackdog's experience with IDEs is apparently both more sensual and more culinary than mine
18:16:58 <Ghoul_> > (<*)
18:17:01 <lambdabot>   Ambiguous type variable `f0' in the constraint:
18:17:01 <lambdabot>    (Control.Applicative.App...
18:17:08 <Ghoul_> :t (<*)
18:17:10 <lambdabot> Applicative f => f a -> f b -> f a
18:17:19 <acowley> elliott: I have no experience with it, but I know it has users
18:18:09 <blackdog> @remember acowley blackdog's experience with IDEs is apparently both more  sensual and more culinary than mine
18:18:10 <lambdabot> It is stored.
18:18:23 <blackdog> acowley: beautiful :)
18:18:35 <elliott> I hear thinks about hdevtools too. I don't know what that is, either, but it sounds equally fancy
18:18:38 <elliott> *things
18:19:31 <acowley> elliott: ghc-mod does nice things like highlight errors as you work, and then, in a separate color, highlight warnings from GHC and hlint. Things like unused imports are highlighted.
18:19:56 <blackdog> elliott: hdevtools looks interesting, but i think it'd suffer from the same problem that you either enable autosaving, or don't get error reports until you save.
18:20:02 <blackdog> also, no emacs support yet.
18:20:41 <elliott> acowley: if it highlights hlint warnings then probably whole files get coloured :p
18:20:53 <blackdog> elliott: you get used to fixing things as you go along
18:21:02 <blackdog> i have no hlint warnings any more
18:21:06 <Mortchek> Dang, it even highlights missing instances
18:21:08 <acowley> Me neither
18:21:18 <acowley> It makes you a better person!
18:21:20 <Mortchek> But how do you figure out what it's complaining about? I only figured that out by deduction
18:21:30 <blackdog> Mortchek: C-c C-d
18:21:53 <blackdog> wait, C-c d. sorry.
18:21:59 <acowley> I do M-?
18:22:10 <elliott> blackdog: I've sen what hlint spits out when run wild on lens (and hpaste). it's not something I have an interest in appeasing :p
18:22:20 <elliott> especially having to stub out various language extensions from its view
18:22:45 <blackdog> elliott: fair enough. you have to explicitly ask it to run hlint with C-c C-c anyway - it's not something that's going to get in your face.
18:22:48 <Ghoul_> anyone know a library that converts a `show` tree of a data into a visual representation (svg, image, html, etc.)?
18:23:08 <Mortchek> C-c d is undefined
18:23:24 <edwardk> blackdog: the ratio of 'crap worth fixing' to 'crap hlint just can't parse and complains about' makes it a hard sell for me going forward
18:23:42 <Mortchek> This would probably be easier if I had ever used emacs before
18:24:10 <edwardk> 9 out of 10 things hlint complains about for me are invalid suggestions =(
18:24:26 <acowley> edwardk is linty
18:24:42 <sclv> they have brushes for that
18:24:49 <edwardk> acowley: thats because i have cats
18:24:57 <acowley> What's a lens file that is likely to cause trouble?
18:25:08 <sclv> yes you have whole libraries about cats
18:25:21 <elliott> I think all the lens files properly shut hlint up
18:25:21 <acowley> edwardk: I thought we just had Hask
18:25:26 <elliott> things like #ifdef HLINT and ( # ) instead of (#)
18:25:29 <edwardk> acowley: skim through and look at the HLint.hs, and the various module annotations in there
18:25:43 <edwardk> acowley: also every #ifdef HLINT is a hack to work around some quirk in the parser
18:25:53 <edwardk> and the ( # ) noise all over
18:26:09 <acowley> Is patching hlint out of the question?
18:26:17 <acowley> Or is it a bug in haskell-src-exts or whatever
18:26:29 <edwardk> i set it up as part of the build process so virtually everything i write copiles hlint free, but had i known how bad it would be in terms of signal to noise ratio i wouldn't have bothered.
18:26:50 <edwardk> most of the issues are limitations in the parser for haskell-src-exts
18:26:52 <acowley> I remember seeing the default instance stuff having to be ifdef'd
18:26:55 <sclv> if its any consolation jslint is worse :-(
18:27:03 <edwardk> some of the remaining ones is that its eta-reduce happy because it can't see the types
18:27:12 <edwardk> so in the presence of rank-2 types, it gives really really bad advice
18:27:32 <acowley> Why does haskell-src-exts lag as far behind GHC as it seems to?
18:27:37 <edwardk> sclv: i largely refuse to use jslint on the grounds that crockford gets under my skin
18:27:45 <acowley> I thought there were a number of groups regularly working on it
18:28:32 <blackdog> edwardk: that monad talk was pretty groanworthy.
18:28:55 <Mortchek> Crockford's?
18:29:02 <blackdog> edwardk: heh, i think i'm still writing yeoman haskell - it's pretty concret.
18:29:06 <blackdog> *concrete
18:29:08 <blackdog> Mortchek: yeah.
18:29:20 <edwardk> blackdog: i just wish it wasn't the thing all the javascript guys went to watch to grok monads. his 'Maybe' monad is nothing of the sort =(
18:29:47 <sclv> jslint is so paranoid i'm sort of shocked it lets anything through at all
18:29:49 <elliott> edwardk: hey, he only said it's maybe a monad!
18:29:56 <cmccann> a proper lint utility for javascript would discard all input and spit out the message "suggestion: rewrite this shit in a better language."
18:29:57 <elliott> (get it)
18:29:57 <edwardk> elliott: =P
18:30:09 <elliott> "=P" is how edwardk tells you your joke was awful
18:30:18 <blackdog> edwardk: @rioter atd @puffnfresh are fighting the good fight, but there aren't many of them.
18:30:25 <sclv> some of the 'opinions' are ridiculous, in part because they highlight what a crappy language javascript is.
18:30:35 <shachaf> elliott: In my experience, /.*/ is how edwardk tells you your joke was awful.
18:30:40 <elliott> sclv: I like how jslint has an option to tolerate stupidity
18:30:46 <sclv> like lift var decls to the top of functions since that's the only place they legitimately go, since its scope is so hosed
18:30:51 <elliott> I wonder what it does
18:31:02 <edwardk> shachaf: thats just sampling bias. so far all of his jokes have been awful
18:31:21 <elliott> edwardk: hey, it could be worse.
18:31:24 <elliott> they could be shachaf's jokes.
18:31:31 <sclv> elliott: it lets you use blocking functions
18:31:39 <edwardk> shachaf doesn't make jokes, only funpuns.
18:31:58 <cmccann> shachaf jokes are what the quotes section of HWN is for.
18:32:14 <cmccann> though lately there have been not as many :[
18:32:17 <shachaf> cmccann: Hey, there wasn't a single shachaf quote in the last HWN!
18:32:19 <shachaf> Leave me alone.
18:32:41 <shachaf> There were two cmccann quotes.
18:32:42 <edwardk> you know if you go by sheer ratio of lines to number of lines quoted in HWN, you'd see that he's actually a bit less funny than the average person on channel, so I rest my case. ;)
18:33:17 <elliott> @remember shachaf <cmccann> shachaf jokes are what the quotes section of HWN is for.  <cmccann> though lately there have been not as many :[  <shachaf> cmccann: Hey, there wasn't a single shachaf quote in the last HWN!  <shachaf> Leave me alone.  <shachaf> There were two cmccann quotes.
18:33:17 <cmccann> shachaf: yeah but those weren't jokes.
18:33:18 <lambdabot> Good to know.
18:33:20 <cmccann> totally different.
18:33:30 <shachaf> elliott...
18:33:32 <sclv> here's a *great* opinion from jslint: http://jslint.com/lint.html#inc
18:33:36 <cmccann> elliott: that's either too meta or not meta enough to be funny.
18:33:42 <cmccann> I'm not really sure which.
18:33:51 <elliott> cmccann: look, we need a shachaf quote in the next HWN. we have to work with what we've given.
18:34:05 <elliott> perhaps shachaf will deign to say something funny quickly enough.
18:34:07 <shachaf> cmccann: He who is without pun among you, let him throw the first stone.
18:34:20 <tgeeky> I got in there this week, and I'm not happy. I am pretty sure it's not technically correct (the kind of correct I want).
18:34:22 <edwardk> sclv: i forgot about that little bit of stupidity
18:34:30 <elliott> sclv: haha enabling viruses
18:34:52 <elliott> "Warning: JSLint will hurt your feelings.
18:34:53 <elliott> "
18:35:17 <sclv> he's a hacker, he uses peano arithmetic!
18:35:23 <Recursive> @ty (first)
18:35:25 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
18:35:34 <cmccann> I still prefer the jslint implementation I suggested earlier.
18:35:40 <cmccann> I think it cuts right to the heart of the issue.
18:40:06 <elliott> cmccann: hlint should do the same.
18:40:38 <cmccann> is there an agda lint yet?
18:40:58 <cmccann> just complain about any use of mixfix or unicode and you'd be off to a good start
18:41:12 <napping> what's a good way to get from [(a,b)] -> Map a [b]?
18:41:32 <elliott> cmccann: aw, c'mon. mixfix is cute. unicode is cute. agda is cute.
18:41:39 <cmccann> :t fromListWith (++)
18:41:41 <lambdabot>     Not in scope: `fromListWith'
18:41:41 <lambdabot>     Perhaps you meant one of these:
18:41:41 <lambdabot>       `IM.fromListWith' (imported from Data.IntMap),
18:41:45 <cmccann> argh
18:42:03 <cmccann> :t M.fromListWith (++)
18:42:05 <lambdabot> (Ord k, Monoid a) => [(k, a)] -> M.Map k a
18:42:21 <cmccann> ...pf, caleskell
18:42:48 <cmccann> napping: ok anyway just use something like that except correctly
18:43:16 <shachaf> @ty M.fromListWith (++) . map (fmap (:[]))
18:43:18 <cmccann> need to turn all your b values into singleton lists too
18:43:19 <lambdabot> Ord k => [(k, a)] -> M.Map k [a]
18:43:43 <cmccann> hm looks like shachaf cracked the case
18:43:44 <cmccann> well done
18:43:51 <shachaf> @yarr
18:43:52 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
18:44:05 <napping> looks like it is associated reasonably
18:44:21 <napping> needs an M.map reverse to get them in the proper order
18:44:42 <elliott> (flip (++)) instead.
18:44:49 <elliott> an extra reverse pass is a bit silly
18:44:57 <cmccann> napping: if you care about the order, do what elliott suggested
18:45:12 <shachaf> elliott: But then you get it associated the wrong way.
18:45:26 <cschneid> I am working with a whole bunch of standalone applications in a single directory, ie, no single top level main, but a bunch of standalones, does cabal handle that well?
18:45:27 <napping> biglist ++ smalllist is a bad idea
18:45:28 <elliott> shachaf: you're associated the wrong way.
18:45:31 <shachaf> If you have a lot of items mapping to the same key you'll do quadratic work.
18:45:33 <ab9rf> @src reverse
18:45:34 <lambdabot> reverse = foldl (flip (:)) []
18:45:38 <elliott> well, how big is the list really?
18:45:45 <cschneid> also I just installed vim + hdevtools, which is slick :)
18:45:46 <napping> a few thousand items
18:45:48 <elliott> I guess M.map reverse might be better.
18:46:04 <napping> and about three distinct keys
18:46:48 <shachaf> @ty M.map (($ []) . appEndo) . M.fromListWith (<>) . map (fmap (Endo . (:)))
18:46:48 <acowley> elliott: You are really picking up good burns today
18:46:50 <lambdabot> Ord k => [(k, a)] -> M.Map k [a]
18:47:11 <elliott> acowley: i will add this to my list of testimonials.
18:47:33 <ab9rf> terrycloth testimonials
18:47:56 <acowley> I think ragging on someone's associativity and lack of semantics is pretty good material. You should enter a rap battle or something.
18:47:59 <Ralith> does the haskell platform ship with an editor?
18:48:02 <Ralith> on windows
18:48:21 <cmccann> acowley: maybe he could challenge djahandarie to a rap battle
18:48:25 <Ralith> and if not, what's a good editor I can recommend to a newbie on windows?
18:48:39 <elliott> acowley: the problem is all my opponents just type something in without thinking about it. they're not strongly typed.
18:48:47 <acowley> hahaha
18:48:54 <elliott> ok that one was kind of bad.
18:48:57 <tgeeky> Ralith: pick some person's vim or emacs environment that uses msys somewhere on github
18:49:06 <cmccann> elliott: you're kind of bad.
18:49:10 <acowley> cmccann: That should be a scheduled event at NYHUG or HacPhi
18:49:18 <shachaf> elliott's tipe sistem had some serious bugs iesterdai.
18:49:28 <Ralith> tgeeky: that tends to be overwhelming for a newbie, and I can't easily help debug an emacs env I don't use
18:49:31 <Hafydd> ellyott
18:49:34 <cmccann> acowley: that sounds vaguely terrifying
18:49:42 <djahandarie> I'm retired from the rap game
18:49:43 <elliott> cmccann: yeah well, you're cmccann.
18:49:52 <elliott> the ultimatest burn of all.
18:50:08 <tgeeky> Ralith: eclipseFP it is, then, I guess
18:50:13 <cmccann> djahandarie: pff
18:50:17 <Ralith> tgeeky: that's badly unmaintained last I saw
18:50:26 <shachaf> djahandarie: You're retired like I'm retired from lens.
18:50:34 <tgeeky> Ralith: check again?
18:50:35 <shachaf> s/lens/reading Core/
18:50:49 <geekosaur> it was just an unsatisfied functional dependency...
18:50:50 <Ralith> huh.
18:50:52 <Ralith> lively.
18:51:01 <Ralith> still, is there anything that's *not* huge and complex?
18:51:10 <ab9rf> Ralith: death
18:51:18 <Ralith> good idea
18:51:28 <acowley> #haskell after dark
18:51:50 <djahandarie> Haha
18:51:54 <acowley> Ralith: There's EclipseFP, Leksah, and Yi
18:52:07 <acowley> Ralith: But I think everyone should be encouraged to use emacs
18:52:51 <Ralith> I like emacs, but I'm worried about scaring off skittish newbies with it
18:52:51 <tgeeky> I can vouch for Leksah being kind of simple and self contained, given the gtk libs and whatnot.
18:53:09 <tgeeky> Ralith: browser based editor environments?
18:53:44 <acowley> If you're teaching, is the FPComplete web interface a viable option?
18:53:51 <acowley> (I don't know anything about how that works)
18:53:59 <Ralith> not familiar with it
18:54:26 <acowley> Ralith: If this is just for one or two people on Windows, you could Remote Desktop in and setup emacs for them
18:54:37 <acowley> Ralith: Depends how much you like these people, I suppose
18:54:40 <tgeeky> Ralith: there's also this, which is especially good for teaching and/or assignments: http://pnyf.inf.elte.hu/fp/Diagrams_en.xml
18:54:48 <tgeeky> http://pnyf.inf.elte.hu/fp/FunctionGraphs_en.xml
18:54:53 <tgeeky> http://hackage.haskell.org/package/dia-functions
18:55:05 <Ralith> tgeeky: ooh, that looks fun
18:55:21 <luite> \o/
18:55:32 <luite> i mean booh
18:57:53 <robonerd> does a haskell function have a return value like C functions do?
18:58:20 <arkeet> yes
18:58:25 <arkeet> in fact, returning is all they can do.
18:58:51 <cmccann> return values are the one thing haskell functions don't not have.
18:59:32 <latro`a> note that "function" in haskell is more restricted than C; generic C functions are "procedures", and haskell has an analogue of those. they're just not functions
18:59:39 <jfischoff> trying to get lambdabot to build. What's a replacement for throwDyn?
18:59:53 <cmccann> jfischoff: ragequitting?
18:59:55 <robonerd> does haskell have multiple return values? or only 1?
19:00:01 <tgeeky> robonerd: if this doesn't make you think confusing things about haskell (how do you get anything done?) or C (what else can they do besides return? ANYTHING?!), then you need to study
19:00:01 <jfischoff> ?
19:00:07 <arkeet> robonerd: you can return tuples, which contain multiple values.
19:00:10 <jfischoff> oh
19:00:12 <Cale> robonerd: one, but it can be an arbitrary data structure including tuples
19:00:17 <Mortchek> robonerd, just the one, but it can be a value that contains other values, such as a tuple
19:00:18 <robonerd> ok
19:00:23 <latro`a> it can also be a function itself
19:00:24 <latro`a> :D
19:00:37 <latro`a> (the return value, that is)
19:00:38 <Cale> robonerd: for that matter, every function also has exactly one parameter
19:00:39 <ab9rf> or a tuple containing a function
19:00:39 <robonerd> is this like haskell only allowing 1 parameter, but it could be a map or list with multiple actual values
19:00:41 <ab9rf> or a list of functions
19:00:44 <arkeet> robonerd: I suggest you look at a haskell tutorial, because it wil lanswer a lot of your questions.
19:00:44 <ab9rf> or evena kitten
19:00:48 <arkeet> such as LYAH
19:00:49 <jfischoff> cmccann: let me rephrase. an equivalent replacement
19:00:50 <arkeet> @where lyah
19:00:51 <lambdabot> http://www.learnyouahaskell.com/
19:01:10 <Cale> robonerd: and functions which appear to take more parameters are really just functions which produce other functions.
19:01:14 <ab9rf> kittenas have an CanMeow instance
19:01:44 <Mortchek> Also a CanHazCookie instance
19:02:14 <Mortchek> class CanHazCookie a where { canHazCookie :: a -> Bool }
19:02:31 <cmccann> cf. http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg#!i=960526161&k=XwKHSBM
19:05:25 <Mortchek> I never realized Haskell could be so adorable. :>
19:10:16 <sclv> haha this was one of my first contributions to the haskell community: http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg#!i=960526371&k=M22CXrF
19:10:50 <monochrom> heh
19:11:05 * byorgey is still inordinately proud of http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg#!i=960824968&k=NLLt4fx
19:11:22 <djahandarie> Hahahaha
19:11:26 <monochrom> hahaha
19:12:35 <djahandarie> Too bad you couldn't work in barbed wire, lenses, and envelopes into the picture also.
19:13:35 <tgeeky> djahandarie: lenses were involved
19:13:42 <tgeeky> djahandarie: those other two sound dangerous
19:13:46 <djahandarie> True
19:17:13 <blackdog> acowley: success! http://www.shimweasel.com/2013/05/03/guard-for-haskellcabalhspec-projects/
19:17:48 <blackdog> if you have the latest ghc-mod, it saves the file under inspection in a different filename: ignore those filenames, and your tests will only run when you explicitly save it
19:18:15 <blackdog> i think this means i can put delete-trailing-whitespace back in *happy*
19:18:25 <acowley> blackdog: Make a screencast!
19:18:41 <blackdog> acowley: do you think so? is the blog not clear enough?
19:18:59 <cschneid> I want to inline the helper method `bitDiffCount` in this: https://gist.github.com/cschneid/203868fce2eb4a21e598 but am having issues.  Can somebody walk me through the steps to do that?
19:21:15 <acowley> blackdog: Even seasoned haskellers haven't even seen ghc-mod (as we learned tonight), and I think a demo of this interactive test running would actually turn a few heads outside of the haskell community.
19:22:05 <elliott> yay, I count as seasoned
19:22:11 <elliott> lightly seasoned elliott
19:22:34 <blackdog> acowley: hrm. perhaps you're right. i have to get some more focused work done today, but it's on my list now. Need to poke kazu to release a new version on elpa too, copying .el files around is muy oldschool.
19:22:51 <acowley> I install ghc-mod manually :/
19:30:43 <blackdog> so, curious: why does "ghc test/spec.hs -isrc -itest" create a binary fine, but "runghc test/spec.hs -- -isrc -itest" fail to find the files in ./test ?
19:30:49 <bobajett> howdy folks, how do I write this function 'foo' where foo "abbcb" results in ["a", "bb", "c","b"], that is consecutive characters are bunched together?
19:31:18 <c_wraith> bobajett: start by writing a type signature.  It always helps
19:31:24 <cmccann> > group "abbcb"
19:31:28 <lambdabot>   ["a","bb","c","b"]
19:32:03 <c_wraith> the implementation of group is actually a little complicated. Though I'm not sure you can really do it better than that.
19:32:27 <bobajett> c_wraith: I did, but my code was a hideous nesting of if elses.
19:32:57 <blackdog> c_wraith: takeWhile/dropWhile?
19:33:17 <h4199> http://www.haskell.org/haskellwiki/99_questions/Solutions/9
19:33:28 <h4199> various solutions
19:34:23 <c_wraith> blackdog: that would work, I suppose.  the standard library version is in terms of span, which is just combining those two functions together
19:34:52 <blackdog> yeah, that's the obvious optimisation to make next.
19:35:07 <hpaste> bobajett pasted “myGroup” at http://hpaste.org/87117
19:36:50 <c_wraith> bobajett: well, first thing, you can pattern match instead of using "if null ..."
19:36:59 <c_wraith> bobajett: that's a big conceptual simplification
19:37:55 <napping> would any libraries help for combining several foldl  operations into a single traversal?
19:38:12 <bobajett> c_wraith: how do I do a pattern match within the "in" part of the let?
19:38:21 <napping> data Folder x a = forall s . Folder s (s -> x -> s) (s -> a)
19:38:22 <c_wraith> bobajett: you can use a case expression
19:38:33 <elliott> napping: it's Cofree ((->) a)
19:38:37 <bobajett> c_wraith: ah ok.
19:38:39 <monochrom> w00t pattern matching!
19:38:48 <applicative> case foo xs of ....
19:39:04 <elliott> napping: i.e., data Fold a b = Fold b (a -> Fold a b)
19:39:42 <elliott> done (Fold x _) = x; feed (Fold _ f) = f; run fld = done . foldl feed fld
19:39:45 <sclv> blackdog: screencast++
19:39:54 <elliott> and it forms an applicative
19:39:55 <applicative> > group []
19:39:57 <lambdabot>   []
19:40:00 <elliott> so you can do avgF = (/) <$> sumF <*> lengthF
19:40:16 <elliott> er, that should be foldl' feed.
19:40:24 <applicative> ^^^ bobajett I wonder about the first case foo [] = [[]]
19:40:31 <elliott> then e.g. mkFoldl' f z = Fold z (\a -> mkFoldl' f $! f z a)
19:40:51 <elliott> (it's also a comonad)
19:41:15 <blackdog> sclv: alright, i'll try to make the time.
19:41:30 <napping> I guess that's the one
19:41:34 <bobajett> applicative: without it, it won't compile? since my type sig is foo String -> [String]
19:41:43 <applicative> napping there are excellent essays by conal on it, following http://squing.blogspot.com/2008/11/beautiful-folding.html
19:41:49 <napping> I think I'll stick with the existential version
19:42:08 <applicative> a list of strings can be empty
19:42:27 <applicative> it needn't include the empty string
19:42:49 <monochrom> [], [[]], [[], []], [[], [], []] :)
19:43:28 <elliott> napping: needless use of existentials make me sad. :(
19:43:45 * applicative concedes its maybe a little mind bending, but no more than the opposite would be
19:43:47 <bobajett> applicative: ah you're right, it does compile, but fails at run time, foo "abbcb"
19:43:48 <bobajett> *** Exception: 01_try.hs:5:18-32: Irrefutable pattern failed for pattern (y : ys)
19:43:51 <monochrom> existentials make nihilists cry :)
19:44:20 <elliott> you can do "more" with the non-existential version. like step it only a bit and get a Fold out without making it ugly.
19:44:47 <applicative> bobajett: yes as you wrote it you say 'let y:ys = foo xs"  but what if foo xs is []
19:45:00 <applicative> wait no sooner do I type this than I see what youre thinking
19:45:27 <napping> The existential one is easy to step too
19:46:16 <applicative> bobajett: but thats why you shold do what c_wraith said and start = case foo xs of [] -> ...; y:ys -> ....
19:46:38 <applicative> then you also wont need head
19:46:56 <bobajett> cool, I'll try that. looks much nicer. thanks!
19:50:22 <cschneid> why is example code so rare in haskell libraries. I'm reading that checkers lib, and can't make heads or tails on how it might help me (well, the generators are cool by themselves).
19:51:23 <monochrom> I don't know. but examples are rare in math books, too
19:52:14 <cschneid> makes it harder to quickly eval a library. "ohh, this is what this does, and how I might drop it into an app"
19:52:26 <monochrom> (you probably don't see this in 1st-year math books, but that's only because publishers keep nagging authors to add more examples.)
19:52:28 <cschneid> I understand that the details will require you to actually read the code, and the types
19:52:58 <cschneid> ahh well, just complaining. I'll go figure stuff out and submit pull requests on github :)
19:54:04 <monochrom> the structure of documenting each value individually also fosters a non-holistic culture of documenting
19:55:14 <monochrom> once you decide to write non-holistically, examples become pointless, because examples always talk about a more holistic view, how to combine several values as opposed to what "means" each value
19:56:46 <monochrom> this disease plagues both haddock and javadoc. as you can see they use the same doc structure
20:03:32 <applicative> cschneid: I think the answer is that its just a really bad habit; better libraries don't do it
20:04:22 <cschneid> applicative: ok, I may just be spoiled by ruby docs, which push pretty hard as a community to nice high level "how the heck does this new lib fit into my workflow" docs, and then leaves the details to readers of the code
20:04:30 <cschneid> applicative: ahh well, I'll write docs as I learn more
20:04:52 <applicative> it may be that conal has written about this material on his site somewhere
20:06:13 <applicative> cschneid: at least now we have http://packdeps.haskellers.com/reverse/checkers to show us what others made of it
20:06:25 <cschneid> hmm, cool
20:06:49 <cschneid> applicative: that's just the example I was looking at more than the library itself causing me issues
20:07:08 <applicative> ah
20:07:31 <Cale> cschneid: In my day, we were lucky if there was anything more than a type signature, and we liked it! http://www.haskell.org/ghc/docs/5.02.3/set/finitemap.html
20:07:54 <Cale> (Honestly, that's what the documentation was like when I was first learning Haskell :)
20:08:01 <cschneid> Cale: "guess what!" hah.
20:08:08 <cschneid> Cale: I like that in the docs
20:08:50 <cschneid> applicative: I've seen that lack of holistic docs a bunch. :-/ the entirely right answer is me fixing stuff, and not complaining. Beyond what I'm doing. Crap.
20:09:15 <blackdog> cschneid: without good docs, nobody uses anything in ruby :)
20:09:31 <cschneid> blackdog: to be fair, without good docs, nothing is usable in ruby.
20:09:40 <cschneid> luckily we managed to bootstrap ourselves up :)
20:09:44 <applicative> ha
20:09:46 <blackdog> chatsiri_: that's pretty much what i mean
20:09:52 <blackdog> urgh. cschneid i meant
20:11:59 <applicative> well cschneid just keep your current state of irritation in mind when you start flooding hackage ....
20:11:59 <cschneid> but yeah, as a newbie who's finally starting to grok haskell a bit, it's rough to not be able to understand libraries well.
20:11:59 <cschneid> applicative: I like writing docs. Teaching is fun
20:16:39 <Recursive> As a haskell newbie, xmonad is a big help for me to tweak haskell :-D
20:17:19 <h4199> Are there any high priority libs that are crying out for a more holistic documentation approach?
20:17:23 <Recursive> now xmonad is my first && everyday desktop
20:17:28 <chatsiri_> - -
20:17:52 <no-n> can you configure it in Haskell?
20:17:56 <no-n> or is it just written in it
20:18:04 <blackdog> no-n: config file is a haskell file.
20:18:10 <no-n> neat
20:18:15 <no-n> might check it out
20:18:42 <Cale> The "config file" is actually the main executable :)
20:19:01 <blackdog> Cale: ultimate triumph of libraries over frameworks :)
20:19:09 <hpaste> allenj12 pasted “parse error help.” at http://hpaste.org/87120
20:19:10 <no-n> does that mean you have to restart it each time you want to change something?
20:19:16 <Recursive> studying haskell and tweaking xmonad at the same time
20:19:26 <Cale> It is able to exec itself and maintain state
20:19:31 <allenj12> hey can someone help me figure this parse error out i cant find what could be possibly wrong
20:19:37 <levi> no-n: Yes, but you can restart it without losing your X session.
20:20:08 <levi> And it comes with a handy default keybinding to recompile and restart!
20:20:33 <levi> Unless you write an error, you could accidentally hit it and not really notice.
20:20:55 <blackdog> it's the research paper that comes with a bonus window manager
20:22:08 * hackagebot git-annex 4.20130501.1 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20130501.1 (JoeyHess)
20:22:23 <Recursive> no-n: AFAIK, xmonad is the most frequently used haskell app. I heard of some Google engineers like to use it
20:22:28 <monochrom> allenj12: delete "let"s
20:23:10 <allenj12> thanks monochrom
20:23:15 <jfischoff> does anyone have a repo of lambdabot that runs on 7.6.2?
20:23:30 <jfischoff> err build with
20:24:23 <chrisdotcode_> so, haskellians, which graphical library/bindings should I use if I wanted to make a game with haskell? opengl? sdl?
20:26:40 <no-n> I started up and have a blank screen. what keystroke do I need to get something? :P
20:26:53 <Hafydd> Alt+shift+return
20:26:59 <no-n> ty
20:27:07 <Hafydd> And Alt+p
20:27:48 <no-n> where does the config file live?
20:27:57 <Hafydd> ~/.xmonad/
20:28:06 <Hafydd> (This is off-topic, I suppose)
20:28:14 <no-n> sorry
20:28:16 <Recursive> no-n: Google some xmonad.hs
20:28:26 <no-n> okay :]
20:29:00 <Cale> jfischoff: try https://github.com/mokus0/lambdabot
20:29:16 <jfischoff> Cale: yeah building that right now
20:29:26 <jfischoff> Cale: wish me luck :)
20:30:28 <chrisdotcode_> Cale: any recommendations for graphic libraries with haskell? sdl? opengl?
20:30:54 <Cale> It really depends on the details of what you're doing.
20:31:03 <Cale> There are bindings to both of those.
20:31:25 <Cale> as well as user friendly simple interfaces like gloss
20:31:39 <chrisdotcode_> I'm a game-dev newbie, and getting my feet with with a purely functional language for gaming sounds good in theory
20:32:06 <chrisdotcode_> but something with a clea and haskellian-API would always be nice :)
20:32:52 <Cale> You'll probably eventually outgrow it, but try gloss to start with
20:34:37 <chrisdotcode_> Cale: good for beginners? sweet! sounds perfect!
20:35:50 <chrisdotcode_> by the way, should I dive straight into real world haskell right after I finish LYAH?
20:37:03 <Cale> You can certainly try it :)
20:37:24 <chrisdotcode_> what's the next logical step usually?
20:38:20 <Cale> Writing programs and reading library documentation
20:38:42 <Cale> Maybe also check out some of SPJ's papers eventually, a lot of them are really good.
20:40:07 <jfischoff> @hoogle Monad m => Int -> m a
20:40:08 <lambdabot> Prelude return :: Monad m => a -> m a
20:40:09 <lambdabot> Control.Monad return :: Monad m => a -> m a
20:40:09 <lambdabot> Control.Monad.Instances return :: Monad m => a -> m a
20:40:30 <chrisdotcode_> Cale: spj is simon, right?
20:40:39 <arkeet> yes.
20:40:41 <arkeet> many people are simon.
20:41:16 <h4199> marlow, peyton jones, ...
20:45:27 <NihilistDandy> & Garfunkel
20:46:39 <jfischoff_> let it be known git://github.com/mokus0/lambdabot.git compiles on 7.6.2
20:47:40 <NihilistDandy> Nice
20:48:23 <NihilistDandy> Now the question is, does GoA?
20:52:33 <lispy> chrisdotcode: hi. You might try asking some of these questions in #haskell-game. Cale is right that gloss is a good place to start. It's friendly (I just don't know if it's haskell-beginner friendly).
20:52:47 <hpaste> jfischoff pasted “regex-pcre failed” at http://hpaste.org/87121
20:52:56 <chrisdotcode> lispy: I didn't know that there was a haskell game...
20:52:59 <chrisdotcode> thanks :D
20:53:02 <jfischoff> ^ anyone know how to get around that
20:53:25 <jfischoff> getting something like Wrap.hsc:393: error: ‘PCRE_ERROR_NULL’ when install regex-pcre?
20:53:26 <chrisdotcode> join #haskell-game
20:53:28 <chrisdotcode> oops
20:53:47 <lispy> chrisdotcode: #haskell-game is for haskell folks who have an interest in making games.
20:53:55 <cmears> jfischoff, is it possible you don't have the libpcre development package installed?
20:53:57 <chrisdotcode> :D
20:54:22 <jfischoff> cmears: very, but i would have assumed cabal would have complained?
21:07:34 <dainanaki> Is there some way to user GHC.Generics to get a hold of a particular record accessor function of a data type?
21:07:38 <dainanaki> *use
21:18:34 <xunatai> dainanaki: probably not
21:19:39 <dainanaki> I was hoping I could maybe get away with not using template haskell in a few places, but I may not have a choice.
21:21:12 <xunatai> the best you can do is make a wrapper function for it
21:27:34 <chrisdotcode_> test
21:44:55 <Recursive> :t fmap
21:44:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:45:28 <Recursive> :t (<*>)
21:45:31 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:47:25 <shachaf> I bet one of you feels like doing some really annoying benchmarking and Core-diving!
21:47:45 <cmears> How much would you like to bet?  (:
21:48:30 <NihilistDandy> <$>
22:02:36 <nwf> edwardk: Any chance wl-pprint-extras knows how to ensure that all the linebreaks it inserts are prefixed with, e.g., "#"? I am trying to have it output some Python for me and would like pretty comments...
22:03:06 <edwardk> sadly no, ansi-wl-pprint is also useless there
22:04:36 <nwf> How bad would you estimate the effort to add such a hook?
22:04:47 <nwf> If it's not crazy I might dive in.
22:05:39 <nwf> Incidentally, is there a reason that ansi-wl-pprint is not just a particular Effect and wl-pprint-extras?
22:10:35 <amosr> if I have an "instance Class (Ty a b c)" then a function inside that instance "foo", can I reference the types a, b and c?
22:10:50 <amosr> eg as (undefined :: a) as a phantom type argument
22:10:51 <coppro> try it and see!
22:11:23 <amosr> ok. well it looks like it's adding a forall to the function so it's a different 'a'
22:11:44 <nwf> You may need {-# LANGUAGE ScopedTypeVariables #-}; I'm not sure.
22:11:52 <amosr> ooh
22:12:11 * hackagebot yesod-core 1.2.0.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.0.1 (MichaelSnoyman)
22:12:31 <amosr> nwf: yes! that got rid of one error :-)
22:32:11 * hackagebot hyakko 0.5.1 - Literate-style Documentation Generator  http://hackage.haskell.org/package/hyakko-0.5.1 (JeremyHull)
22:37:28 <FreeFull> When I restart xmonad with mod-q sometimes xmobar doesn't take up its space anymore, even if I press mod-b, and I end up having to restart X to stop it from being hidden under windows
22:37:38 <shachaf> Sounds like a good question for #xmonad.
22:37:43 <shachaf> @where xmonad
22:37:44 <lambdabot> http://xmonad.org/
22:37:45 <shachaf> Hmm.
22:37:55 <shachaf> @where+ xmonad #xmonad | http://xmonad.org/
22:37:55 <lambdabot> I will never forget.
22:38:15 <FreeFull> shachaf: It's on the community page
22:38:41 <cmears> FreeFull, sometimes I have to switch workspaces a bit to get it to work it out
22:39:49 <FreeFull> cmears: Doesn't work for me, it's like that on all workspaces
22:40:50 <shachaf> FreeFull: #xmonad is really a much better channel for that question than #haskell.
22:41:44 <immanuelkant> is there a way to open a new channel in wechat.freenode
22:41:53 <immanuelkant> in the same chrome tab..
22:42:30 <FreeFull> shachaf: I just figured a lot people in here used it =P
22:47:12 * hackagebot yesod-core 1.2.0.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.0.2 (MichaelSnoyman)
23:24:08 <dreixel> dainanaki: I think that might be possible
23:25:04 <FreeFull> shachaf: Well, I am getting no help in there and I have to leave soon
23:25:12 <FreeFull> Maybe I picked the wrong time
23:27:13 * hackagebot yesod 1.2.0.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.2.0.1 (MichaelSnoyman)
23:47:13 * hackagebot cgi 3001.1.7.5 - A library for writing CGI programs  http://hackage.haskell.org/package/cgi-3001.1.7.5 (AndersKaseorg)
23:47:59 <shachaf> ThansersKaseorg
23:49:52 <elliott> shachaf: *thanders
23:50:07 <shachaf> thelliott
23:51:38 * Clint claps.
