00:03:04 <johnw> an XY question! :)
00:03:59 <fruitFly> mm_freak: yo!
00:04:40 --- mode: ChanServ set +o shachaf
00:05:29 --- mode: shachaf set -b *!*hychen@175.41.48.*
00:05:33 --- mode: shachaf set -o shachaf
00:07:07 <P1RATEZ> I'm reading the learnyousomehaskell guide. I just wanted to know the reason behind this one. "To make a list with all the numbers from 20 to 1, you can't just do [20..1], you have to do [20,19..1]"
00:07:33 <P1RATEZ> how come the reverse can't be as simple as the other direction
00:07:38 <cmears> it's just that the default step is 1
00:07:49 <cmears> so if you write [x..y], it means [x, x+1 .. y]
00:07:54 <P1RATEZ> ooooh
00:07:59 <silasm> P1RATEZ: so that there's a generalizable default behavior, yeah
00:08:20 <silasm> otherwise [x..y] would be really unpredictable.
00:10:16 <shachaf> I'm glad that it works that way. I wouldn't want [20..1] to mean [20,19,..1].
00:10:16 <P1RATEZ> ahhh makes functional sense now
00:10:16 <popl> :)
00:11:07 <P1RATEZ> these live programming demo for most languages popping up on the web is really nice, i like the http://tryhaskell.org
00:12:16 <P1RATEZ> to get haskell on a web host that serves some odd hundreds of web clients, one just needs to configure the server to interpret haskell pages?
00:13:34 <arkeet> P1RATEZ: haskell web applications run in their own server process, and then you set up your web server as a reverse proxy.
00:13:46 <arkeet> or so
00:16:27 <P1RATEZ> i was messing around with that set notation math stuff with haskell, i was so shocked... all that math crap as a child looked so alien to me, never thought i'd be able to do it in a single line of code and understand it with ease... x*2 | x <- .... | ...
00:23:56 <P1RATEZ> who runs http://learnyouahaskell.com/starting-out? anyone in here?
00:24:54 <djahandarie> P1RATEZ, bonus does, though I don't think I've seen him in here for a really long time.
00:25:16 <simpson> preflex: xseen BONUS
00:25:17 <preflex>  BONUS was last seen on freenode/#haskell 2 years, 13 days, 11 hours, 57 minutes and 31 seconds ago, saying: yeah i think that's better as well
00:25:21 <simpson> :c
00:25:43 <P1RATEZ> oh, just wanted to report a not so obvious line in the tutorial that had me scratching my head for a few minutes until a read what it was trying to tell me
00:25:51 <P1RATEZ> the line goes:     boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
00:26:21 <P1RATEZ> but it fails in the interpreter, but realizing it was trying to create a function, it needed the 'let' infront of it
00:27:03 <P1RATEZ> i wish you guys wrote the android programming tutorial
00:27:10 <silasm> interactive examples will show the prompt. Good catch.
00:27:13 <djahandarie> A lot of things before that fail in the interpreter again.
00:27:18 <djahandarie> also*
00:27:40 <djahandarie> It doesn't have gchi> before it so you aren't suppose to run it in the interpreter (at least not without modifications like you did).
00:27:57 <P1RATEZ> oh
00:28:41 <silasm> examples like that are typically meant to be saved to a file and then loaded into ghci by either giving it to ghci as a paramter or using :l filename.hs while in ghci.
00:28:51 <silasm> but you need ghc installed on your system for that ;)
00:29:00 <P1RATEZ> oh yea, i'm using that
00:29:05 <P1RATEZ> i already completed the baby.hs one
00:29:50 <P1RATEZ> i have my window split in two interpreter/text editor and web page on one half following along, its really well done, and i now like caterpillars too for some reason
00:30:33 <silasm> ha yeah, I recently bought the book to support the author and lend it out to friends even though I finished reading it all online. Love LYaH.
00:30:50 <silasm> only "textbook" I've read "cover-to-cover".
00:31:06 <P1RATEZ> no shit, i can't stop reading it and its like 3:30 AM
00:31:11 <P1RATEZ> very addicting
00:31:19 <johnw> P1RATEZ: that's the "Haskell Effect"
00:31:22 <P1RATEZ> lol
00:31:24 <johnw> i ran into this morning at 2am
00:31:35 <djahandarie> edwardk is a terminal case
00:31:52 <johnw> spent 2 hours reading about delimited continuations, GADTs, type-safe API design, recursion patterns and data parallelism :)
00:32:08 <johnw> at 2am!!!
00:32:13 <johnw> this language is awesome
00:32:15 <djahandarie> And now some people are going to spend 2 hours reading about what those words mean
00:32:34 <johnw> oh, and iteratees too
00:32:36 <silasm> johnw: heh, doing the same thing with Idris right now.
00:32:52 <johnw> silasm: I'm kind of bummed that Idris is not lazy
00:33:01 <johnw> or is it like Agda where it doesn't matter?
00:33:53 <silasm> johnw: eh, it's not that hard to make lazy functions. When you consider that he wants to make it work for embedded systems programming (which is awesome), it makes some sense that he'd avoid some of the issues lazy evaluation by default brings up.
00:34:26 <johnw> true, but I find that lazy vs. non-lazy is merely a question of how you want to pay the piper
00:34:37 <silasm> but afaict so far making a function lazy takes little more than adding a vertical bar to the beginning of its type declaration.
00:34:52 <fruitFly> silasm: What do you think about the state of idris pertaining to general purpose programming right now, and where do you think it's going?
00:36:24 <silasm> fruitFly: no idea, I really don't know much about it, just going through the idris tutorial pdf from idris-lang. If it becomes functional for embedded systems that'd be awesome enough to make it worth learning imo, but I'm pretty sure it's supposed to work for general purpose as well. I'm honestly not the one to ask, though, I'm just having a ball trying to wrap my head around dependent types, and thinki
00:36:24 <silasm> ng of potential applications for them.
00:38:08 <silasm> dependently typed data structures in particular is an awesome idea that I can't wait to explore, like how they could apply to something like a binary search tree, you know, it wouldn't compile until all functions operating on it would be proven to preserve invariants and such. That seems like it'd be doable and would be a really desirable property to have built into the language.
00:38:18 <seenah> P1RATEZ: nice to see another new haskeller here, I'm also using learn you ..
00:38:49 <P1RATEZ> heh
00:39:29 <P1RATEZ> i installed it on parents computer and releatives and told them to follow along and read the picture book
00:39:37 <P1RATEZ> 6 year old girls doing it
00:40:09 <P1RATEZ> next generation of kids are going to be ninja programmers
00:40:34 <seenah> I already see the generation after mine like that
00:40:49 <seenah> much more integrated with the sw side of computing
00:40:53 <P1RATEZ> yep
00:41:16 <P1RATEZ> you must be a 80-90's product like most on irc :)
00:41:24 <seenah> 80s
00:41:26 <silasm> fruitFly: but if I had to venture a guess I'd say that if (god forbid) haskell actually becomes popular, Idris or Agda will kind of take its place as the language people use when they want more dependability. Otherwise I'm not really sure where it'd fit in.
00:41:28 <P1RATEZ> same :P
00:41:47 <seenah> P1RATEZ: I only got into SW dev about 2 years ago though
00:41:54 <seenah> so most of this is new to me anyway
00:42:46 * silasm is a young babby from the 90s ._.
00:43:14 * mgsloan was born a few months after Haskell
00:44:20 <P1RATEZ> nice i figured most would be like that here, i dont think current generation cares for irc or know what the heck it is, if its not facebook it's old
00:44:37 <simpson> IYSS.
00:45:30 <seenah> P1RATEZ: that depends on the channel you're in. Some I'm on actually have a decent number of teenagers there.
00:46:05 <shachaf> This doesn't sound Haskell-related.
00:46:56 <silasm> shachaf: heh, allow me to bring us slightly back on subject then. Would auditing an abstract algebra class next semester give me as much benefit as I think it will?
00:46:58 <P1RATEZ> i was just looking at the GUI aspect of this
00:47:27 <silasm> in terms of learning useful skills for Haskell programming theory
00:47:30 <shachaf> silasm: That depends on the benefit you think it will.
00:47:50 <shachaf> But I'll go with "no".
00:48:11 <silasm> well I see blogs like http://www.haskellforall.com/2012/08/the-category-design-pattern.html and I get really jealous.
00:48:13 <silasm> heh
00:49:24 <johnw> silasm: I'll go with "yes"
00:49:28 <johnw> this is a point shachaf and I disagree on
00:49:35 <shachaf> johnw: ?
00:49:50 <johnw> I think he'll find knowing about monoids and algebras and such quite rewarding
00:50:07 <shachaf> johnw: I have no idea how much silasm thinks they'll benefit, but their guess is unlikely to be accurate.
00:50:43 <johnw> you seem to discourage people in general from seeking out abstract math as a way to enrich their Haskell foundation
00:50:47 <shachaf> Also, I've never called knowing about monoids and algebras unrewarding.
00:50:55 <P1RATEZ> this is interesting if microsoft itself invests in it, http://research.microsoft.com/apps/pubs/default.aspx?id=67496
00:50:56 <johnw> or at least, it has seemed that way to me
00:51:11 <silasm> well to some degree I'd do it just to satisfy my curiosity (which is part of why I'd be auditing it instead of enrolling)
00:51:15 <johnw> silasm: Gabriel is a good guy to get jealous about :)
00:51:21 <johnw> he's on here as Tekmo sometimes
00:52:15 <Chousuke> in my experience Haskell is a good tool for learning these abstract mathematical concepts :P
00:52:19 <silasm> johnw: ooh. On that note, is the edwardk here the Edward K. he talks about having written the lenses library?
00:52:25 <johnw> yes
00:52:37 <silasm> awesome. I had a sneaking suspicion.
00:52:38 <shachaf> johnw: What I discourage people from doing is more nuanced than that.
00:52:48 <johnw> shachaf: what is it that you discourage?
00:53:00 <Chousuke> instead of just learning abstract maths, if you learn haskell you will learn how the abstract stuff actually applies to programming in practice.
00:53:26 <P1RATEZ> Chousuke: yea, i agree. I really like the set notation stuff, and the way you actually learn how the function actually works
00:53:26 <johnw> silasm: Haskell gives you a nice playground to test out your understanding of a lot of those maths too; not all, but a lot
00:53:50 <silasm> Chousuke: true, and I appreciate that. But I'd like to learn the theory a bit because I usually feels that allows me to understand things on a deeper level.
00:54:46 <johnw> silasm: I would say that's the best reason to do it
00:54:56 <Chousuke> silasm: I've been learning the theory mostly through haskell or agda blogs explaining it.
00:55:01 <blaenk> speaking of this, anyone know of a good book or place to learn about this theory, I guess it's called category theory? I don't know
00:55:21 <johnw> @hoogle Awodey Category Theory
00:55:22 <lambdabot> Did you mean: :: Awodey Category Theory
00:55:22 <lambdabot> No results found
00:55:27 <johnw> @google Awodey Category Theory
00:55:28 <lambdabot> http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182
00:55:52 <blaenk> nice thanks. I guess the best thing would be if it taught it applied to haskell, but any good resource should do
00:55:59 <P1RATEZ> http://www.youtube.com/watch?v=tDgOBM29ny4
00:56:09 <johnw> blaenk: if you google for that question, you will find many resources
00:56:22 <silasm> Chousuke: that's the issue I've been having, really, I get a pretty superficial understanding of abstract algebra from the Haskell/Agda blogs I've read. There are a lot of terms that would probably make a lot more sense to me with what would likely be a pretty easy explanation, but which were outside of the scope of what was being talked about.
00:56:46 <supki> blaenk: I don't think haskell is very interesting from CT point of view
00:57:04 <mgsloan> ":: Awodey Category Theory" would imply ":k Awodey" being "((* -> * -> *) -> Constraint) -> * -> *" ;)
00:57:26 <johnw> lol
00:57:36 <silasm> the best resource I had that was making me start to understand that sort of thing was Haskell Curry's Combinatory Logic book, but that was a checkout from my university library. I have yet to go pick it back up. I'll probably do that.
00:57:37 <blaenk> supki: well, I don't know if it's CT then, I mean I'd like to understand when people talk about bs like 'hey does endomorph have an instnace of functor over the kleisli category"
00:57:44 <blaenk> I'd really like to be in on what all of that means
00:58:20 <blaenk> obviously made that up, bet it makes no sense at all
01:00:32 <Chousuke> a lot of the terminology is just big words for something that's almost intuitive.
01:00:40 <supki> blaenk: ime knowing what thing /is/ does not really help with how to /use/ thing in the context of haskell
01:00:47 <tangentstorm> such is the way of math :)
01:00:52 <blaenk> yeah, I can imagine that, for what little I know, I just would like to know 'of' it to begin with
01:01:41 <blaenk> yeah I never figured it'd suddenly make me godlike at haskell, I just think I'm missing out not knowing
01:01:50 <silasm> I picked up a couple of functional programming books recently, a data structures book and an algorithms book. Got a little tired of the "language-independent" imperative data structures and algorithms I'm taught in my classes here. I kind of picked at random, but the DS book is turning out to be really excellent so far.
01:02:13 <silasm> blaenk: my feelings exactly
01:03:18 <blaenk> yeah sometimes people say things like 'oh yeah thing is just blah in the category of foos' as if knowing the definition of those things suddenly would make it 'click' in someone who knew those things. feels like I'm missing out on that potential intuition
01:03:42 <popl> blaenk: I hate that feeling.
01:03:44 <popl> :)
01:03:54 <blaenk> yeah haha
01:04:22 <Aetherspawn> Mannn, I read this channel about anything
01:04:25 <popl> like mathematicians using the word obviously.
01:04:29 <Aetherspawn> and it flies right over my head
01:04:38 <silasm> it's the same sort of thing as, say, linear algebra. You can just show someone who knows it a gaussian elimination and it'll be really succinct and much easier for them to keep track of and understand, but anyone who doesn't is kind of boned if you use that approach.
01:04:42 <Aetherspawn> unless it's like in the first 5 pages of LYAH
01:05:52 <blaenk> haha, me I think I have an ok grasp of the language but it seems in 'the real world' (most packages on haskell) they go out of their way to be as extravagantly generic as possible with insanely abstract functions/types that seems pretty difficult to comprehend
01:06:07 <blaenk> it's like you can get a good grasp of the language, but then there's this whole other larger thing you have to learn
01:06:19 <blaenk> since it's not something you can easily bring in from other languages one might be used to
01:06:26 <popl> blaenk: http://youtu.be/lytxafTXg6c
01:06:38 <popl> that explains the feeling
01:07:16 <blaenk> 'put 2 sticks together to get the banana' = matching types to please the compiler
01:07:17 <Chousuke> blaenk: In category theory, a functor is a mapping between categories, (which requires mapping both the objects and their morphisms) but in the context of haskell, that just means that a functor is a thing that takes a type that gives you a new type (object mapping) along with an operation to lift the corresponding functions (morphism mapping). therefore, a functor is a type
01:07:23 <Chousuke> constructor + the corresponding fmap
01:07:57 <Chousuke> the concept is very general, but in haskell, it's just a generalized "map" over a whole bunch of different constructs
01:08:09 <silasm> popl: watching that video was really meta for me until I finally remembered who Richard Feynman was.
01:08:38 <blaenk> see, morphism, that I'll have to look up. I know of the monomorphism restriction for example but I have no idea what it means
01:08:58 <blaenk> oh yeah, I'd say functor is one of the ones I'm understanding of the most
01:08:58 <Chousuke> the cool thing is that the type constructor defined the "structure", instead of the basic abstraction over a concrete type
01:09:04 <Chousuke> defines
01:09:45 <Chousuke> blaenk: as far as I understand morphism is just a "how to get from a to b" thing
01:09:51 <blaenk> yeah was just reading that
01:09:54 <blaenk> cool then :D
01:09:57 <Chousuke> often, a function
01:10:08 <shachaf> Chousuke: "morphism" is rather more abstract than that.
01:10:20 <shachaf> In fact it doesn't really mean anything, on its own.
01:10:52 <shachaf> In a category it means the same thing as "arrow". People sometimes think of it as a transformation but that's very Set-influenced.
01:11:02 <popl> it's a map
01:11:14 <shachaf> For example today we were talking about the category where morphism are NxM matrices.
01:11:29 <blaenk> "arrow" like an arrow pointing or arrow "like" in Control.Arrow
01:11:29 <Chousuke> well, as far as I understand you apply a morphism to some thing and the result is another thing, or the same thing, depending on the morphism
01:12:11 <blaenk> so knowing that, what is the monorphism restriction?
01:12:17 <hpaste_> “Dharmender Kumar” pasted “Petluxury.in - faridabad affordable dog supplies online” at http://hpaste.org/87878
01:12:19 <popl> monomorphism
01:12:21 <shachaf> That's completely unrelated.
01:12:21 <popl> :)
01:12:25 <blaenk> o :{
01:12:29 <shachaf> It's described on the wiki.
01:12:33 <shachaf> @google monomorphism restriction
01:12:35 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
01:12:35 <lambdabot> Title: Monomorphism restriction - HaskellWiki
01:12:36 <Saizan> Chousuke: morphisms of a category are only guaranteed to have a composition operation, not an application
01:13:10 <shachaf> I think people should come up with better terms than "object" and "morphism" for categories.
01:13:41 <Saizan> 0-cell, 1-cell!
01:13:41 <Chousuke> Saizan: what does that even mean? you can compose morphisms but you can't use them to get from one object in the category to another?
01:13:43 <shachaf> People think that objects are central, but they're really only there to classify the morphisms, or something like that. The morphisms are the important thing.
01:14:02 <popl> what's the difference between morphism and arrow?
01:14:04 <shachaf> Chousuke: Take a poset category, for instance.
01:14:18 <popl> that's cool
01:14:19 <shachaf> popl: They are the same.
01:14:21 <Saizan> Chousuke: right, objects might not have a "into" meaning
01:14:25 <popl> shachaf: that's what I thought. thank you.
01:14:49 <popl> shachaf: what you say is cool. objects are not important except for the connections between them?
01:15:02 <Saizan> s/"into" meaning/sense of "into"/ -- i'm not making much sense atm
01:15:30 <popl> that's a philosophical statement if I've ever read one. ;P
01:15:53 <shachaf> What is a thing that both "source" and "target" are?
01:15:59 <quicksilver> the reason that people sometimes view objects as central is in lots of the common examples the 'object' part is the bit people are used to considering central.
01:16:02 <silasm> shachaf: is this at all related to formal systems which only contain functions (like CL or lambda calculus)?
01:16:19 <quicksilver> that gives you a poor intuition for examples of category not like that, though.
01:16:23 <shachaf> silasm: Maybe vaguely? I don't know what "this" is.
01:16:53 <silasm> shachaf: just the emphasis on morphisms rather than the objects they operate on.
01:17:02 <shachaf> Not really.
01:17:16 <shachaf> I don't know what CL is.
01:17:22 <popl> common lisp probably
01:17:25 <shachaf> Oh, Combinatory Logic.
01:17:28 <popl> oh
01:17:30 <popl> haha
01:17:40 <popl> context is important :)
01:18:10 <silasm> shachaf: yeah, combinatory logic. I was more referring to the idea that morphisms could be composed but needn't necessarily be applied.
01:18:13 <Chousuke> shachaf: Am I understanding this right: the ordering relation between two objects is encoded as a morphism?
01:18:27 <shachaf> What does "encoded as" mean?
01:19:07 <Chousuke> as in, the morphisms have that meaning.
01:19:32 <shachaf> There is a (unique) morphism : A -> B iff A ≤ B
01:19:32 <silasm> is the composition with no application case specific to systems in which there aren't really "objects", or are those orthagonal?
01:19:42 <shachaf> I suppose that's what you mean.
01:19:56 <Chousuke> yeah
01:19:59 <silasm> wouldn't that be a relation?
01:21:46 <Chousuke> I suppose that makes sense.
01:21:48 <silasm> I guess more what I'm asking is, if morphisms that can be applied and morphisms that can only be composed can exist in the same system. Cause I'm having trouble wrapping my head around how that'd work.
01:22:30 <shachaf> I don't really know what "applied" means.
01:22:58 <silasm> Saizan> Chousuke: morphisms of a category are only guaranteed to have a composition operation, not an application
01:23:14 <shachaf> Maybe composing foo :: A -> B with bar :: () -> A or something like that?
01:23:45 <Chousuke> you can compose the morphisms in a poset category because the ordering is transitive, but you can't really "apply" the morphism.
01:23:46 <shachaf> silasm: Right. They are also not guaranteed to have hindrolifoozation.
01:23:50 <shachaf> It's up to you to say what "application" means.
01:24:18 <shachaf> @google category theory as coherently constructive lattice theory
01:24:19 <lambdabot> http://www.cs.nott.ac.uk/~rcb/MPC/CatTheory.ps.gz
01:24:35 <quicksilver> "applied" only means something for functions. Not all morphisms are functions.
01:24:51 <quicksilver> some morphisms are a bit like functions and you might find something a bit like application in those cases.
01:25:28 <silasm> quicksilver: now does composition apply to non-functions then?
01:25:45 <silasm> shachaf: thanks, that should keep me busy for a while
01:26:06 <shachaf> I don't think that paper is recommended as an introduction. :-)
01:26:16 <shachaf> It's an interesting perspective, though.
01:26:26 <latermuse> is there an arrow that takes 2 inputs and one function and returns a tuple?
01:26:31 <quicksilver> silasm: in this context, we are re-defining composition.
01:26:56 <quicksilver> silasm: we're saying : let's define a new abstract structure which has the following operations. Let's call this operation 'composition'.
01:27:02 <Chousuke> silasm: well, if you look at the poset morphisms, you should be able to see how they compose if a <= b and b <= c leads to a <= c
01:27:10 <quicksilver> silasm: so, clearly, the word is being "borrowed" from the world of functions.
01:27:26 <quicksilver> borrowing words can lead to good intuitions and bad intuitions.
01:27:38 <silasm> quicksilver: ah, that clears things up a bit.
01:27:55 <silasm> I'll be poring through wiki pages for a bit I guess.
01:30:20 * hackagebot haskdogs 0.3.2 - Generate ctags file for haskell project directory and it's deps  http://hackage.haskell.org/package/haskdogs-0.3.2 (SergeyMironov)
01:37:29 <fruitFly> cschneid: I have a quesiton about the hex to base64 converter.. you here?
01:38:27 <fruitFly> test
01:38:39 <fruitFly> anyone home
01:38:41 <Waynes> no
01:38:43 <Waynes> go away
01:38:57 <merijn> fruitFly: lambdabot supports @tell nickname to send messages when people aren't here
01:39:22 <merijn> i.e.
01:39:28 <fruitFly> merijn: thanks.. but it said my bro just connected... but he ain't answering :(
02:05:54 <Saizan> silasm: what i meant is that the presence of a sensible notion of application depends on the specific category, i can't think of examples where in the same category some morphims can be applied and others can't
02:06:48 <johnw> why, the Category of partially applicable morphisms, of course
02:06:51 <johnw> ;)
02:07:02 <Saizan> actually there's the one induced by a profunctor
02:07:25 <Saizan> assuming you start from a concrete category :)
02:07:52 <johnw> the one induced by a profunctor is the one in Set where there are morphism pairs that go back and forth?
02:07:54 <t7> class ConcreteCategoryFactory
02:09:43 <johnw> @tell aristid Would you mind if I uploaded an aws point release (0.7.6.4) to relax the upper-bound for cryptohash?  We're trying to get it into Stackage
02:09:43 <lambdabot> Consider it noted.
02:10:49 <Saizan> no, iirc Hom(X,Y) = C(X,Y) + P(X,Y) + D(Y,X) for a profunctor P : C x D^op -> Set, but icbw
02:10:49 <mauke> preflex: seen chrisdone
02:10:50 <preflex>  chrisdone was last seen on #haskell 1 day, 14 hours, 32 minutes and 27 seconds ago, saying: (●´∀｀●) it's beautiful …
02:11:51 <Saizan> johnw: http://ncatlab.org/nlab/show/cograph+of+a+profunctor
02:12:22 <Saizan> they are more precise there :)
02:12:34 <johnw> thanks
02:15:21 * hackagebot tianbar 0.1.3.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.1.3.0 (AlexeyKotlyarov)
02:15:29 <mauke> putting the cog into cograph
02:21:44 <quicksilver> Stackage?
02:48:07 <johnw> quicksilver: "Stable Hackage"
02:48:41 <quicksilver> johnw: I googledit. Interesting. Is it working?
02:49:11 <hpaste_> adit pasted “Just Try” at http://hpaste.org/87882
02:49:19 <johnw> yes
02:49:33 <johnw> any code you write on FP Complete's School of Haskell can import any package from Stackage
02:55:02 <neutrino> johnw: does Stackage exist? will it be used in the next HP?
02:56:38 <johnw> yes and yes
02:56:51 <johnw> stackage is on github
02:57:19 <johnw> https://github.com/fpco/stackage
03:00:08 <arnsholt> Is flg (functional graph library) a good library?
03:03:58 <arnsholt> s/flg/fgl/
03:10:33 <HugoDaniel> http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable
03:11:02 <HugoDaniel> when is expected to be released the next version of the platform ?
03:15:28 * hackagebot hs-bibutils 4.17.1 - Haskell bindings to bibutils, the bibliography  conversion utilities.  http://hackage.haskell.org/package/hs-bibutils-4.17.1 (AndreaRossato)
03:34:42 <Zenol> Hum, Guys, I have a question about a bit of coe of omegagb. Binary instructions are converted by a function named mcti :: Opcode -> (Word8, Word16) -> (Instruction, CycleCount, ArgumentCount) where type Opcode = Word8, and CycleCount/ArgumentCount are type Int.
03:34:43 <lambdabot> Zenol: You have 1 new message. '/msg lambdabot @messages' to read it.
03:37:44 <evancz> hi, anyone around?
03:37:58 <Zenol> First, is using lazy 3-uples a good idea?
03:38:08 <tangentstorm> hey evancz :)
03:38:21 <evancz> oh, hi :)
03:38:38 <evancz> I am looking for academic studies or industry stories about how learning FP leads to better imperative code
03:38:44 <evancz> do you guys know anything?
03:38:49 <Zenol> Then, Instruction, cyclecount and argumentcount are taken by functions like opcodeCycleCount o = let (_, c, _) = mcti o (0,0) in c. Since each of this function call mcti, will mcti evaluated more than 1 time?
03:38:56 <evancz> I have never seen a good academic study on this
03:39:07 <evancz> always they have 15 or 20 participants
03:39:30 <evancz> it's inherently hard to measure productivity as well
03:40:21 <evancz> as a side note, it is totally obvious to me that this is true, I am just looking for a more legit source than my personal experience
03:41:14 <evancz> hmm, I have to run to lunch earlier than I thought
03:41:24 <tangentstorm> I don't know of any studies like that.
03:41:28 <evancz> tangentstorm: can you tell me if anyone things of something?
03:41:37 <evancz> yeah, me neither :/
03:41:52 <tangentstorm> evancz: sure, if you're around in #elm :)
03:41:54 <evancz> I know I read one about scheme/racket but I cannot find it now
03:42:27 <tangentstorm> oh right. that paper about frp...
03:42:28 <evancz> okay, I'll get back on there after lunch :)
03:44:31 <Aetherspawn> is the cereal package high performance
03:44:41 <Aetherspawn> or is there a faster method for data serialization from bytestrings?
03:47:00 <johnw> cereal is pretty good I hear
03:47:04 <johnw> it's what yesod uses
03:47:28 <Aetherspawn> oke doke
03:48:21 <plhk> or you can try binary
03:48:23 <plhk> @hackage binary
03:48:24 <lambdabot> http://hackage.haskell.org/package/binary
03:53:59 <merijn> evancz: I don't there's anything significant in that category of research
03:54:49 <merijn> evancz: Oh, semi-relevant, I remember Tim Sweeney's POPL talk had a distribution of bugs in their code and how FP approaches would help prevent/eliminate those
04:12:21 <dmwit_> Zenol: Nothing wrong with lazy triples. mcti will not be cached unless you explicitly ask for it to be with let.
04:22:13 <hpaste_> “Dharmender Kumar” pasted “textile manufacturing industry in surat” at http://hpaste.org/87887
04:22:48 --- mode: ChanServ set +o mauke
04:22:48 --- kick: hpaste_ was kicked by mauke (hpaste_)
04:24:49 --- mode: mauke set -o mauke
04:50:35 * hackagebot ChasingBottoms 1.3.0.6 - For testing partial and infinite values.  http://hackage.haskell.org/package/ChasingBottoms-1.3.0.6 (NilsAndersDanielsson)
05:00:29 <envogue> anyone here good with make?
05:00:43 <envogue> BUILD_TYPE = TEST
05:01:00 <envogue> ifeq($(BUILD_TYPE), TEST) ... endif
05:01:04 <envogue> why doesnt that work
05:01:23 <mux> quote TEST in the ifeq line?
05:01:35 <mux> and make sure you're running gmake. ifeq is gmake-specific
05:03:45 <envogue> what is general?
05:03:56 <envogue> and how do I quote TEST?
05:05:01 <mux> I meant ifeq ($(BUILD_TYPE), 'TEST')
05:05:18 <mux> general? gmake is GNU make, check with make --version if you're unsure what make variant you're running
05:05:21 <mauke> since when does make support quoting?
05:05:29 <mux> since about forever
05:06:15 <envogue> i am using gmake
05:06:36 <envogue> but BUILD_TYPE = TEST and not 'TEST'
05:06:40 <mauke> mux: [citation needed]
05:07:04 <mux> mauke: quoting is often not needed in make but it's been possible since as far as I can remember. EOQ (author: mux :-P)
05:07:17 <mux> envogue: which is fishy to begin with
05:07:23 <envogue> still not wokring with quotes
05:07:31 <mauke> mux: there's nothing about quotes in the manual
05:07:44 <mux> mauke: what manual? you know make isn't standardized at all reight?
05:07:52 <mauke> mux: 'info make', the gnu make documentation
05:08:01 <mux> that's not telling much
05:08:06 <mauke> yes, it is
05:08:13 <mux> no, not really
05:08:19 <mauke> if you can find any make that supports quoting, I'd like to see it
05:08:27 <mux> pmake
05:08:29 <mux> gmake does too
05:08:32 <mux> ...
05:08:55 <mauke> mux: gmake doesn't (see the manual)
05:09:05 <mux> sigh, gmake does, just try it and you'll see.
05:09:39 <mux> I'm pretty sure your manual wouldn't talk about the $$ escpae to have $ in commands; yet that too is supported by most make variants since the dawn of times
05:09:42 <mauke> mux: try what?
05:09:53 <mauke> of course the manual describes $$
05:10:17 <mux> envogue: maybe copy-paste your Makefile code somewhere and be a little more explicit about what's not working
05:12:10 <dmwit> Surely one of the two of you is right. Whichever it is can settle this quite satisfactorily by writing a makefile that demonstrates their correctness.
05:12:33 <mux> http://pastebin.com/2YqgLRbd
05:12:38 <mauke> The paste 2YqgLRbd has been copied to http://hpaste.org/87890
05:12:43 <mux> enjoy.
05:12:58 <dmwit> um
05:13:16 <mux> also note that vim highlights quoted text in a specific way; it surely wouldn't do that if it wasn't supported
05:13:18 <dmwit> This does not indicate that makefiles know anything special about quoting...?
05:13:26 <mux> yes it does
05:13:35 <elliott> that just executes
05:13:37 <hpaste_> “mr makefail” pasted “make problem” at http://hpaste.org/87891
05:13:38 <mux> it correctly interpreted the text inside single quotes
05:13:38 <elliott> echo bar baz bal
05:13:41 <elliott> echo supports multiple arguments
05:13:44 <elliott> oh hm
05:13:46 <elliott> it probably executes
05:13:48 <elliott> echo 'bar baz bal'
05:13:54 <mux> it executes that yes
05:13:54 <elliott> because you put literal quote characters into your variable
05:13:59 <elliott> for some reason
05:14:00 <mux> remove the @ and see
05:14:09 <mux> I shouldn't have put it there
05:14:12 <elliott> I admit I have no idea what the argument is about
05:14:18 <elliott> but it seems to demonstrate that make just copies variables verbatim?
05:14:32 <mux> it's useful if you want to iterate over make variables
05:15:06 <mauke> mux: that proves the opposite of what you're claiming
05:15:10 <envogue> ^^ did you see the paste
05:15:12 <mux> lol
05:15:12 <elliott> scrolling up, I see a more important issue
05:15:13 <dmwit> mux: I added a space inside the quotes. It was preserved. I removed the quotes. The removal was preserved. This indicates to me that quotes are not treated specially at all.
05:15:21 <elliott> which is that envogue joined this channel to ask a question that has nothing to do with Haskell :P
05:15:33 <elliott> isn't there a channel for (at least gnu) make?
05:15:44 <applicative_tmp> #gnu-make-beginners
05:15:56 <applicative_tmp> #gnu-make-beginners-lens
05:16:02 <mauke> envogue: what does that have to do with haskell?
05:16:16 <mux> dmwit: that proves nothing. it's just that (as I said earlier), most of the time you don't /need/ the quotes
05:16:29 <Peaker> make :-(
05:16:32 <dmwit> mux: what
05:16:55 * applicative_tmp assumed envogue was make-ing some haskell, why not?
05:17:00 <dmwit> mux: "you don't need the quotes" suggests to me that the quotes don't change the behavior in the cases where they're not needed; the quotes changed the behavior here
05:17:03 <hpaste_> mauke pasted “Makefile” at http://hpaste.org/87893
05:17:07 <mauke> mux: ^
05:17:28 <elliott> this argument is pointless unless "handling/supporting quotes" is defined
05:17:34 <Aetherspawn> Sigh, so many Haskell haters
05:17:35 <elliott> well... it's pointless even then
05:18:07 <Saizan> it just seems quotes are part of strings like any other char, but yeah we should drop this
05:18:11 <Aetherspawn> When ever I try to show a C++'er how succint and easy Haskell is, they always get all angry
05:18:14 <dmwit> So yes, I'm with mauke here. make itself doesn't do anything special with quotes.
05:19:19 <Peaker> Aetherspawn, where?
05:20:03 <Aetherspawn> Peaker, just amongst people on skype, in person or in general programming IRC's. When people start complaining about language limitations I always offer Haskell as an alternative.
05:20:26 <dmwit> I'd be pissed, too, and I love Haskell.
05:21:38 <tdammers> it's not like Haskell is without limitations
05:21:54 <tdammers> the question is, do the limitations match your problem.
05:22:22 <Peaker> at our workplace, they use Python to write extremely-long-running test suites
05:22:36 <Peaker> the productivity of test writing is extremely awful, because of silly crashes/typos after long runs
05:22:58 <Peaker> Haskell would be very suitable to replace Python there, though it would require porting quite a bit of test infrastructure.  Nobody would hear of it..
05:23:27 <mauke> should've used TAP
05:23:32 <Peaker> TAP?
05:23:40 <mauke> test anything protocol
05:23:46 <mauke> what perl modules use
05:23:59 <AfC> Is that like subunit?
05:24:07 <mauke> what's subunit?
05:24:09 <typoclass> Aetherspawn: i think it depends a great deal on the tone and how exactly you phrased that. it's just so easy to be understood as "this guy is trying to provoke us with pointless criticisms of c++"
05:24:20 <Peaker> mauke, how does it help long running tests?
05:24:32 <mauke> Peaker: it doesn't
05:24:45 <Peaker> what does it help with (in this context)?
05:25:01 <Aetherspawn> I actually take a course in C++ and have scored 100% for the last running 12 months in every assesment task. I also maintain a few open source projects in C/C++. People are aware I don't criticise C/C++ as a worthless language
05:25:06 <Aetherspawn> But I do know a great thing when I see it ;)
05:25:11 <mauke> Peaker: ah, depends on the kind of infrastructure
05:25:19 <Aetherspawn> (this is approaching #haskell-blah sorry)
05:25:33 <mm_freak> Aetherspawn: there is an alternative to proposing haskell
05:25:37 <arnsholt> @pl \x -> return (x !! 0)
05:25:37 <lambdabot> return . (!! 0)
05:25:39 <mm_freak> you can propose a categorical style
05:25:47 <mauke> Aetherspawn: the correct phrasing is: "Just use Haskell™!"
05:26:07 <mm_freak> that makes the code easier to work with even when they don't use haskell
05:26:37 <elliott> I think "use a categorical style" is roughly the most useless statement you can make to a C++ programmer who has a problem with their code.
05:26:50 <mm_freak> right
05:26:57 <mm_freak> that's why you have to teach them as well =)
05:27:05 <hape01> perhaps call it "declarative style" ?
05:27:23 <mm_freak> i considered giving a talk about categorical style in non-haskell languages
05:27:30 <mm_freak> hape01: no, i mean specifically a categorical style
05:27:38 <hape01> mm_freak: ah I see
05:27:56 <capisce> mm_freak: is there a blog post or article on the subject?
05:28:08 <mm_freak> capisce: i don't know
05:28:23 <Peaker> mauke, they wrote a comprehensive Python wrapper for all the system interfaces (CLI, network interfaces, fault injection interfaces), and a system-state-tracker that implements a black-boxish expected-state logic, and they write tests by tinkering with all those interfaces and verifying the state tracker matches the real state
05:28:38 <osfameron> mm_freak: please do give the talk and write it up, sounds interesting
05:29:00 <mm_freak> yeah, but i'm not sure which language to choose
05:29:03 <Peaker> mauke, due to how comprehensive this wrapper is, it would be a lot of work to port it to Haskell, but it would be worth it very quickly, IMO
05:29:31 <mm_freak> i thought about naming the talk "extreme from extreme to extreme" and doing it in PHP =P
05:29:33 <mauke> ah, I see
05:29:39 <osfameron> mm_freak: eeeek!
05:30:02 <neutrino> johnw: thanks
05:32:08 <HugoDaniel> is there any real advantage in calling forkIO to handle the input of a datagram socket ?
05:32:41 <merijn> HugoDaniel: advantage as compared to what?
05:32:43 <HugoDaniel> its like stateless so why care about forking a new child to handle it ?
05:33:13 <HugoDaniel> as to not using it, just answering
05:33:30 <HugoDaniel> stalling until answer is ready
05:33:54 <merijn> HugoDaniel: Because you want your main thread to do something else in the mean time?
05:34:02 <Peaker> HugoDaniel, you want concurrent handling of all the sockets, or just handling one at a time?
05:34:34 <HugoDaniel> in a server, with only 1 datagram socket
05:35:04 <neutrino> HugoDaniel: you want to be able to handle more than 1 datagram at once.
05:35:25 <HugoDaniel> well consider a dns server for example
05:35:59 <HugoDaniel> its a simple protocol with quick lookups, why take the payload of forkIO ?
05:36:22 <mauke> forkIO is dirt cheap
05:36:42 <elliott> forkIO is not fork()
05:36:55 <HugoDaniel> i know, but adding a forkIO on top of a simple lookup may not make it sound like dirt cheap
05:36:58 <elliott> it is not even pthreads
05:39:25 <MasseR> HugoDaniel: If I remember correctly, dons did a benchmark with a simple tcp pong which used forkIO in that manner
05:39:32 <HugoDaniel> oh nice
05:39:55 <MasseR> Nothing more than a putstrln response inside a forkIO :)
05:46:55 <loz> hello
06:08:44 <Reite> Im having some trouble using aeson to parse an object that can be of different types. This is what I have which doesnt work: https://gist.github.com/reite/5568152
06:13:21 <arnsholt> Reite: Looks like aeson doesn't return lists for the [...] notation, but arrays
06:14:33 <quchen> Reite: I assume you've tried the generics provided by Aeson? You often don't have to write your own instances for fromJSON with that.
06:14:44 <Reite> The problem is that my input json isnt consistent
06:15:40 <Reite> So the generic way will only work in some cases
06:19:06 <Peaker> arnsholt, seems like a weird choice, given that it's easy to call Array.fromList, and it's O(N) parsing anyway, and lazy streaming of the input could be possible with a list
06:21:45 <Reite> Array is not Data.Array, but a aeson constructor representing a json array
06:22:18 <fizbin> :t let opy op a b = a . op . b; opy' = opy (*) in opy' . opy' $ id
06:22:22 <lambdabot> Num b => (a -> b) -> a -> b -> b -> b
06:22:26 <fizbin> :t let opy op a b = a . op . b; opy' = opy (*); cmby f = f . f in cmby opy' $ id
06:22:33 <lambdabot>     Occurs check: cannot construct the infinite type: b0 = b0 -> b0
06:22:33 <lambdabot>     Expected type: ((b0 -> b0) -> b0 -> b0) -> (b0 -> b0) -> b0 -> b0
06:22:34 <lambdabot>       Actual type: ((b0 -> b0) -> b0 -> b0)
06:22:51 <applicative_tmp> Array in aeson is a Data.Vector. Vector
06:23:01 <quchen> Reite: What is "Object" anyway? It's not something provided by JSON, is it?
06:23:14 <quchen> Nevermind.
06:23:17 <quchen> :s
06:23:20 <fizbin> Okay, I sort of understand why those two expressions aren't equivalent, but...
06:24:13 <quchen> Adding to applicative_tmp's remark, http://hackage.haskell.org/packages/archive/aeson/0.6.1.0/doc/html/Data-Aeson.html#t:Value
06:24:48 <quchen> So objects store HashMaps, Arrays store Vector.
06:25:48 <quchen> So the first line in your "case" makes the program infer the type "[Object]" for [v].
06:26:08 <quchen> That fixes the overall type of your case block.
06:26:29 <quchen> The second line then tries to calculate an "Array", and the typecheker fails.
06:27:07 <applicative_tmp> this is still missing something https://gist.github.com/michaelt/5568271
06:28:21 <applicative_tmp> oh wait type Object = HashMap Text Value
06:31:33 <applicative_tmp> nice weather we're having.
06:40:50 * hackagebot phone-push 0.1.1 - Push notifications for Android and iOS  http://hackage.haskell.org/package/phone-push-0.1.1 (DavidFendrich)
07:01:50 <fizbin> :sheesh.
07:01:53 <Sculptor> yo
07:13:55 <fizbin> Hey, anyone know what the "some" and "many" functions that are part of Control.Alternative actually mean? What are they for?
07:14:06 <fizbin> > some (Just 5)
07:14:11 <lambdabot>   mueval: ExitFailure 1
07:14:11 <lambdabot>  mueval: Prelude.undefined
07:14:27 <Taneb> fizbin: they're useful for parsers
07:15:05 <Taneb> Where "some (pure 'a')" would mean "parse the letter 'a' one or more times".
07:15:11 <Taneb> Other than that, I have no idea
07:15:15 <fizbin> I suppose, but doesn't Parsec have its own functions called "some" and "many" that work there? What's the point of them on general Alternative?
07:15:21 <Eduard_M1nteanu> @src some
07:15:21 <lambdabot> some v = some_v
07:15:21 <lambdabot>   where many_v = some_v <|> pure []
07:15:21 <lambdabot>         some_v = (:) <$> v <*> many_v
07:15:42 <Taneb> > many []
07:15:44 <lambdabot>   [[]]
07:15:46 <Eduard_M1nteanu> It's like * vs + in regexps.
07:15:50 <Taneb> > many ['a']
07:15:55 <lambdabot>   mueval: ExitFailure 1
07:15:56 <lambdabot>  mueval: Prelude.undefined
07:16:39 <fizbin> Eduard_M1nteanu: Right, that's what it means in parsers. What's the meaning elsewhere; is there one?
07:16:46 <elliott> fizbin: parsec also has its own (<|>)
07:16:58 <elliott> alternative generalises the operations from parsec
07:17:08 <elliott> some and many do not belong in the same class as (<|>) though
07:17:32 <Eduard_M1nteanu> fizbin: same thing basically, think of combining tests with (<|>)
07:17:37 <fizbin> Ah, so Alternative is supposed to be some sort of generalized parser. At least in some sense.
07:17:56 <Eduard_M1nteanu> Alternative is a monoid for Applicatives.
07:18:15 <Eduard_M1nteanu> Like MonadPlus is for Monad.
07:18:17 <fizbin> Eduard_M1nteanu: The types of "some" and "many" don't seem to go with my idea of combining tests with (<|>)
07:18:50 <elliott> just ignore some and many if they don't apply to you.
07:19:24 <Taneb> "many foo" is kinda like "(foo *> many foo) <|> empty"
07:19:37 <Taneb> No it isn't
07:19:42 <Taneb> Hang on
07:21:07 <fizbin> Trying most expressions with some or many using the Maybe or List applicative instances just hangs.
07:21:12 <fizbin> > Some (Just 1)
07:21:15 <lambdabot>   Not in scope: data constructor `Some'
07:21:18 <fizbin> > some (Just 1)
07:21:23 <lambdabot>   mueval: ExitFailure 1
07:21:23 <lambdabot>  mueval: Prelude.undefined
07:21:50 <Taneb> :t get
07:21:52 <lambdabot> MonadState s m => m s
07:22:04 <Taneb> :t Text.ParseCombinators.ReadP
07:22:08 <lambdabot> Couldn't find qualified module.
07:22:14 <Taneb> :t Text.ParserCombinators.ReadP
07:22:19 <lambdabot> Couldn't find qualified module.
07:22:30 <fizbin> :t Text.ParserCombinators.ReadP.get
07:22:36 <lambdabot> Text.ParserCombinators.ReadP.ReadP Char
07:23:35 <Taneb> :t Text.ParserCombinators.ReadP.readP_to_S (many (Text.ParseCombinators.ReadP.char 'a')) "aaa"
07:23:37 <lambdabot> Couldn't find qualified module.
07:23:55 <Taneb> :t Text.ParserCombinators.ReadP.readP_to_S (many (Text.ParserCombinators.ReadP.char 'a')) "aaa"
07:23:59 <lambdabot>     No instance for (Alternative Text.ParserCombinators.ReadP.ReadP)
07:23:59 <lambdabot>       arising from a use of `many'
07:23:59 <lambdabot>     Possible fix:
07:24:16 <Taneb> ...huh?
07:24:43 <fizbin> Parsec's many is not Alternative's many.
07:24:56 <elliott> it behaves the same
07:26:11 <fizbin> Is there somewhere something that defines Alternative instances for the appropriate Parsec data structures?
07:26:22 <elliott> Parsec has an Alternative instance
07:39:12 <Saizan> is there a variant of haskell-mode (or similar for emacs) which uses Cabal to call ghci with the correct options for the cabal package?
07:40:38 <applicat1ver> fizbin: here's a -cafe tempest on the theme of 'some' and 'many' http://www.haskell.org/pipermail/haskell-cafe/2011-December/thread.html#97476 It goes on forever but if I remember some good things are said
07:40:51 * hackagebot bitset 1.4.3 - A space-efficient set data structure.  http://hackage.haskell.org/package/bitset-1.4.3 (FedorGogolev)
07:41:24 * fizbin hates the lack of word-wrap on the haskell-cafe archives.
07:41:38 <Reite> I reduced my aeson problem to a problem due to my limited understanding of the type system: https://gist.github.com/reite/5568677
07:43:25 <mauke> Reite: huh?
07:44:05 <Reite> Does it not make sense? Im fairly new to haskell and dont know what im doing
07:44:17 <mauke> objToArray takes a JSON value and if it is an object, it wraps it in an array (otherwise it dies)
07:44:17 <Taneb> Reite: do you have GHCi open?
07:44:25 <mauke> {...} -> [{...}]
07:44:35 <Taneb> If you do, can you type ":t Value" (without quotes)
07:44:50 <Taneb> Assuming you have Data.Aeson in scope
07:44:56 <mauke> Reite: now what are you trying to do? take the object out again or rewrap the array into Value?
07:45:14 <Reite> I want to rewrap it so it has type Value
07:46:01 <mauke> Array (V.singleton obj)
07:46:19 <mauke> Array :: Array -> Value
07:46:33 <mauke> note: the 'Array' on the left and the 'Array' on the right are different things
07:48:34 <mauke> Reite: do you understand how 'data' works?
07:49:57 <Reite> mauke: Doesnt seem so
07:50:04 <Reite> But I see now
07:50:11 <Reite> Its like Just  vs Maybe
07:50:15 <mauke> yes
07:51:03 <mauke> data Value = Null | Bool Bool | Number Number | String Text | Array (Vector Value) | Object (HashMap Text Value)
07:51:06 <mauke> hmm, still confusing
07:53:41 <imalsogreg> Hi.  I'm working on a School of Haskell post, trying to show how when you add a constructor to a sum type while refactoring, the compiler will help you find all the functions that you need to update, via the 'Warning, pattern match(es) are non-exhaustive" message.  Anyone know if this is possible on School of Haskell yet?
07:54:54 <joe9> :vsp
07:55:28 <joe9> I am trying to understand the state monad. i read the rwh state monad chapter. but, seem to get stuck here: http://codepad.org/kMmIxC9v
07:55:49 <Clint> joe9: type error
07:55:50 <joe9> error: http://codepad.org/pfuNGtQG
07:56:01 <mauke> several type errors
07:56:18 <Clint> joe9: have you read lyah?
07:56:23 <mauke> joe9: first off, you can't add 1 to put s1
07:56:37 <twoolie> has anyone here read this post (http://jaspervdj.be/posts/2012-09-07-applicative-bidirectional-serialization-combinators.html) and know why the GADT is defined `Table t f`?
07:56:44 <mauke> second, even if you add the missing parens, s1 is not a number
07:56:44 <joe9> clint, mauke: ok, back to the books again.
07:56:56 <mauke> s1 is just another name for get
07:58:47 <dmwit> joe9: Perhaps more helpfully than the other folks here... perhaps you meant do { s1 <- get; put (s1 + 1) }.
07:59:06 <fizbin> I guess I don't really understand what the Alternative class is for.
07:59:21 <dmwit> fizbin: As far as I can tell, it's for parsers.
07:59:28 <dmwit> Don't think I've seen it used for much else. =P
08:00:14 <quchen> dmwit: STM! <|> = orElse, empty = retry
08:00:33 <dmwit> Oh yes, STM is a great example.
08:00:42 <dmwit> LogicT is an example, but not what I would call a great one.
08:01:14 <quchen> For what it's worth, every use of MonadPlus should be Alternative
08:01:53 <fizbin> And that Haskell cafe thread is not convincing me that other people know what it's for either.
08:02:31 <fizbin> It's certainly for parsers, but there seems to be great debate and grumbling over whether it's "just" for parsers or not.
08:02:48 <dmwit> Which thread, for those of us who have access to the archives but don't really follow along?
08:02:49 <quchen> STM. Again.
08:03:36 <quchen> It's also useful with Maybe to chain multiple independent actions together.
08:03:51 <dmwit> Maybe is just a worse implementation of LogicT. ;-)
08:04:17 <quchen> I don't know what LogicT is. :-(
08:04:28 <dmwit> LogicT is [] done right.
08:04:32 <fizbin> dmwit: The one applicat1ver pointed at: http://www.haskell.org/pipermail/haskell-cafe/2011-December/thread.html#97476 
08:04:44 <poucet> dmwit: you mean an array instaed of a list?
08:04:51 <quchen> dmwit: []T?
08:05:03 <dmwit> quchen: Yes, but satisfying the monad laws.
08:05:04 <fizbin> quchen: Do "some" and "many" make sense with STM? I don't know STM at all, so can't judge.
08:05:06 <dmwit> poucet: I do not mean that.
08:05:09 <poucet> dmwit: ;)
08:07:05 <dmwit> I guess some and many don't really make sense for STM.
08:07:32 <dmwit> uh
08:07:34 <dmwit> hm
08:08:05 <quchen> dmwit: I just came to the same conclusion.
08:08:13 <dmwit> Yeah, doesn't really make sense, since empty = retry.
08:08:31 <quchen> But some/many don't use empty.
08:08:40 <quchen> They use `pure []`.
08:09:04 <dmwit> ah, right
08:09:06 <Peaker> dmwit, there's also the List package for ListT done right
08:09:08 <dmwit> Okay, so they might make sense, then.
08:09:10 <Peaker> (without the CPS stuff)
08:09:11 <nooodl> hey, what's a good place to read about monad transformers?
08:09:25 <dmwit> nooodl: "All About Monads"
08:09:27 <dmwit> ?where aam
08:09:27 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
08:09:38 <quchen> dmwit: That's cruel.
08:09:50 <dmwit> Is it? Why?
08:09:57 <mauke> seems like STM many would execute its action as many times as possible until it fails/retries
08:10:00 <Peaker> A long ago, I wrote a little Monad Transformers tutorial at http://www.haskell.org/haskellwiki/Monad_Transformers_Tutorial  though my understanding has sharpened since then
08:10:07 <quchen> STM-some pretty much says "run this but don't worry if it fails". many says "run it at least once". Not sure what this might be useful for.
08:10:20 <mauke> quchen: other way round
08:10:37 <quchen> mauke: Right.
08:10:55 <dmwit> I guess STM-many might reasonably be used for "read as many things from this channel as are available right now" or something like that.
08:11:18 <quchen> That's a good one. Something like a channel flusher.
08:11:20 <dmwit> Sort of a non-blocking read kind of thing.
08:11:28 <Peaker> nooodl, I'd love to hear feedback if my tutorial is useful
08:12:00 <dmwit> quchen: (Still wondering why "All About Monads" is cruel.)
08:12:05 <nooodl> Peaker: all about monads is yours?
08:12:12 <Peaker> nooodl, no, http://www.haskell.org/haskellwiki/Monad_Transformers_Tutorial is
08:12:39 <nooodl> i'll take a look at it
08:12:41 <dmwit> Transformers are very underwhelming.
08:12:53 <dmwit> You sort of look at them long enough to grok the code and go, "That's it?".
08:12:55 <quchen> dmwit: It's #1 of awful monad tutorials if you ask me, based on my own experience. It uses all the words, but doesn't explain anything. "Here's the implementation of Cont, it's quite logical, here's a 20 line example of how to use it"
08:12:58 <dmwit> Yep, that's it.
08:13:25 <fizbin> I thought the RWH section on monad transformers was quite good.
08:13:27 <dmwit> quchen: I see. I thought it was a pretty good follow-on to sigfpe's one, which doesn't cover transformers at all.
08:13:29 <fizbin> Let me find it...
08:13:44 <quchen> dmwit: http://abstrusegoose.com/474 -- This one, minus the rabbits
08:13:50 <fizbin> http://book.realworldhaskell.org/read/monad-transformers.html
08:15:07 <quchen> dmwit: I learned transformers head first by using them. The "click" moment was when I realized that the new monad is simply added to the last parameter as a value, i.e. MaybeT takes "m a" and puts a Maybe in the a.
08:15:18 <dmwit> Using symbols before you define them is not one of AAM's flaws.
08:15:45 <nooodl> Peaker: i like this
08:15:46 <dmwit> quchen: What, that's not even true.
08:15:47 <quchen> Even worse, not defining symbols at all is one of its flaws.
08:15:52 <dmwit> ?unmtl StateT s m a
08:15:52 <lambdabot> s -> m (a, s)
08:15:53 * hackagebot phone-push 0.1.2 - Push notifications for Android and iOS  http://hackage.haskell.org/package/phone-push-0.1.2 (DavidFendrich)
08:16:13 <quchen> dmwit: Well, it doesn't work for State, but it's my intuition nevertheless.
08:16:40 <quchen> dmwit: The basic idea is that it puts something in the "a", instead of doing magic.
08:16:41 <fizbin> From the name "Alternative" and from the typeclass documentation of what it's supposed to be, the Maybe instance of Alternative makes complete sense. The List instance surprised me. I'm not sure whether I would have found the instance used in parser libraries to make sense or not.
08:17:08 <nooodl> Peaker: the "break" example at the start is kind of confusing, i think; i'd just put it where it says "Now we can also break from the first example's loop!" right now
08:17:11 <Peaker> quchen, there's more to understand though, regarding Applicative composition not requiring transformers (Using StateT as an example, it emphasizes the difference between:  s -> m (s, a)  and m (s -> (s, a)) )
08:17:17 <quchen> dmwit: I always got confused that "MonadT" is on the outside of the type sig, yet what it does actually modify is somewhere on the inside. ._)
08:17:30 <dmwit> quchen: Well, I can safely say I'm glad I didn't read your transformer tutorial. =)
08:17:31 <Peaker> nooodl, ah, you mean using a "break" value that doesn't exist is confusing?
08:17:50 <quchen> dmwit: Good thing I didn't write one ;-)
08:17:54 <fizbin> > [3] <|> [4] -- this I did not suspect.
08:18:00 <lambdabot>   [3,4]
08:18:00 <nooodl> well, it's mostly just, introducing the example then immediately moving on
08:19:15 <Peaker> nooodl, feel free to edit it up :)
08:19:16 <fryguybob> STM many will repeat the transaction until it executes retry.
08:19:34 <quchen> Peaker: What did you mean with "Applicative composition not requiring transformers"?
08:20:00 <nooodl> i don't have an account... looks like i need to mail an admin about creating one, too :(
08:20:12 <Peaker> quchen, if you only need an Applicative instance, then you can compose your type constructors straight-forwardly, no need to use transformers..  For example, you can compose State, Writer, Foo, ... to get an Applicative instance
08:20:20 <nooodl> (nominolo: are you around?)
08:20:27 <Peaker> nooodl, oh, what do you suggest? Just dropping the first example?
08:20:46 <Peaker> quchen, Do you know the (:.) type operator from the TypeCompose library?
08:21:04 <nooodl> Peaker: explaining the "tryConnect" example first, then introducing the "break" one
08:21:07 <quchen> Peaker: No. I've also never transformed Applicatives (or whatever the equivalent is)
08:21:30 <Peaker> nooodl, ah, ok
08:21:43 <monoidal> today I observed: the State s applicative is a product of two applicatives, Reader s and Const (Endo s).
08:21:47 <elliott> applicatives compose, which is nice
08:22:00 <Peaker> quchen, The main idea is that Applicatives compose, Monads don't. That's why transformers are needed, it's one way to compose Monads but since monads are uncomposable it requires modifying the monad types themselves
08:22:18 <monoidal> just like Writer is a product of Const m and Identity applicatives.
08:22:45 <fizbin> > (liftA2 (<*>)) ( (pure . pure) (+1) ) [Just 4, Nothing, Just 1]
08:22:50 <lambdabot>   mueval: ExitFailure 1
08:22:50 <lambdabot>  mueval: Prelude.undefined
08:23:13 <quchen> Peaker: And how do they "compose"? Is there something like a "transform" type combinator, presumably like the :. you mentioned?
08:23:21 <fizbin> Trust me, that does work on something not as enfeebled as lambdabot.
08:24:06 <fizbin> quchen: They compose in the sense I just showed.
08:24:56 <monoidal> applicatives f,g compose giving a new applicative h x = f (g x). However, we need a newtype to make this precise.
08:24:58 <fizbin> quchen: Namely, you can define <*> and pure for two applicatives F and G that operate on values of type (F (G x))
08:25:34 <quchen> fizbin: Ah, cool.
08:25:47 <quchen> Do the mechanics use the (->) instance in the background somewhere?
08:25:54 <fizbin> quchen: And when you do, "pure" is just pure . pure and (<*>) is just (liftA2 (<*>))
08:26:11 <magicman> @type pure . pure
08:26:13 <quchen> I guess I'll have to go over this in quiet later. Gotta catch my bus now :-)
08:26:16 <lambdabot> (Applicative f1, Applicative f) => a -> f (f1 a)
08:26:22 <magicman> @type liftA2 (<*>)
08:26:27 <lambdabot> (Applicative f1, Applicative f) => f (f1 (a -> b)) -> f (f1 a) -> f (f1 b)
08:26:35 <magicman> Cool!
08:27:06 <Peaker> quchen, data (f :. g) a = f (g a)
08:27:28 <fizbin> Peaker: Yeah, but TypeCompose uses so many extensions, who knows what it's doing.
08:27:31 <Peaker> quchen, well, modulu the missing data constructor :)
08:27:42 <Peaker> quchen, instance (Functor f, Functor g) => Functor (f :. g) where fmap = fmap . fmap  -- again, modulu data constructor packing/unpacking
08:28:14 <Peaker> quchen, instance (Applicative f, Applicative g) => Applicative (f :. g) where pure = pure . pure ; liftA2 = liftA2 . liftA2 -- also modulu the need to define (<*>) which is harder than defining liftA2 in this case :)
08:28:23 <fizbin> Peaker: For showing how Applicatives compose, I prefer Data.Functor.Compose.
08:29:06 <Peaker> quchen, so now:  (Writer w :. Reader r :. State s) a    is very similar to:  WriterT w (ReaderT r (StateT s)) a
08:29:10 <fizbin> Peaker: (<*>) isn't hard to define. (<*>) is just (liftA2 (<*>))
08:29:15 <Peaker> quchen, except it can only do applicative stuff, not monad stuff
08:29:27 <Peaker> fizbin, well, harder to fit in an IRC method definition :)
08:29:42 <Peaker> @type (liftA2 (<*>))
08:29:47 <lambdabot> (Applicative f1, Applicative f) => f (f1 (a -> b)) -> f (f1 a) -> f (f1 b)
08:29:56 <Peaker> oh, I guess not :)
08:30:53 * hackagebot grid 5.1 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-5.1 (AmyDeBuitleir)
08:30:55 * hackagebot bitset 1.4.4 - A space-efficient set data structure.  http://hackage.haskell.org/package/bitset-1.4.4 (FedorGogolev)
08:31:17 <monoidal> note that liftA2 id = (<*>). So liftA2 (<*>) = liftA2 (liftA2 id), which gives some idea why the composition is equivalent to liftA2 = liftA2 . liftA2.
08:31:28 <fizbin> > let pure' = pure.pure; star' = liftA2 (<*>) in pure' (+) `star'` [Just 10, Nothing] `star'` [Nothing, Just 1, Just 2]
08:31:32 <lambdabot>   [Nothing,Just 11,Just 12,Nothing,Nothing,Nothing]
08:34:46 <fizbin> monoidal: So your reasoning is (liftA2 id) = (<*>) = (liftA2 (<*>)) = liftA2 (liftA2 id), which makes it reasonable to suppose liftA2 = liftA2 . liftA2 ?
08:35:02 <monoidal> fizbin: yes
08:35:16 <monoidal> fizbin: um, not precisely
08:35:31 <monoidal> liftA2 id is not liftA2 (<*>)
08:35:53 * hackagebot grid 6.0 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-6.0 (AmyDeBuitleir)
08:35:56 <fizbin> Oh, but it is. Or rather, different liftA2's make that true.
08:36:00 <monoidal> right.
08:36:27 <fizbin> Let me add subscripts to make that clear...
08:37:23 <monoidal> liftA2_(FG) id = (<*>)_(FG) = liftA2_F (<*>)_G = liftA2_F (liftA2_G id) = (liftA2_F . liftA2_G) id -- something like that
08:38:00 <fizbin> Something like: (liftA2_{F :. G} id) = (<*>)_{F :. G} = (liftA2_F (<*>)_G) = liftA2_F (liftA2_G id) so it's reasonable to think that maybe liftA2_{F :. G} might be liftA2_F . liftA2_G
08:38:27 <fizbin> Clearly we were typing simultaneously.
08:38:57 <enigmuriatic> what's the best/easiest way to manipulate a simple two-dimensional canvas in haskell? i'm playing with evolutionary algorithms and trying to write a version of Conway's Game of Life
08:39:30 <monoidal> and just as a curiosity, liftAn = liftAn . liftAn for natural n
08:40:40 <fizbin> monoidal: huh.
08:41:35 <fizbin> I wonder what (fp a b = a . (<*>) . b) translates to for composed instances.
08:42:55 <fizbin> Since liftA = fmap is "fp id pure", and liftA2 is "(fp . fp) id pure", liftA3 is (fp.fp.fp) id pure, etc.
08:42:59 <dwcook> lambdabot's eval is dead.
08:43:05 <dwcook> I think.
08:43:09 <dwcook> > 1
08:43:13 <fizbin> dwcook: It was very nearly dead earlier.
08:43:14 <lambdabot>   mueval: ExitFailure 1
08:43:14 <lambdabot>  mueval: Prelude.undefined
08:43:22 <Kinnison> poor lambdabot
08:44:32 <fizbin> enigmuriatic: I assume that at the moment speed is not a concern?
08:50:02 <fizbin> @tell enigmuriatic Simple 2-dimensional array usage example at https://groups.google.com/d/msg/comp.lang.functional/CQiBay3eRDA/H88qPHQP2vUJ
08:50:02 <lambdabot> Consider it noted.
08:57:38 <enigmuriatic> what's the simplest solution for drawing a simple black-and-white bitmap animation on OS X using haskell?
08:57:38 <lambdabot> enigmuriatic: You have 1 new message. '/msg lambdabot @messages' to read it.
09:08:15 <oio> How can i replace a file?
09:08:37 <oio> overwriting it?
09:08:51 <Kinnison> The commonly accepted way is to write a new file and then rename it over the top
09:08:59 <Kinnison> Assuming you're asking about good filesystem behaviour
09:09:03 <hseg> A couple of days ago (http://tunes.org/~nef/logs/haskell/13.05.11 @ 16:58:52), I noted that monads in CT are just the a functor and two natural transformations from one category to another. However, it was pointed out to me that I was wrong. I don't quite understand why.
09:10:29 <oio> mmm ok
09:11:13 <monoidal> hseg: natural transformations are not from one category to another. They are from one functor to another.
09:11:36 <mm_freak> cartesian closed 'Category' categories correspond to ArrowApply, right?
09:11:55 <monoidal> hseg: but fix this, specify what functors, add laws, and the statement is correct.
09:12:19 <oio> when files are renamed they delete the older file with the same name?
09:12:31 <mm_freak> oio: yes
09:12:47 <oio> ok
09:13:06 <ramses_> oio: ultimately that depends on the fs, some never delete anything
09:13:46 <mm_freak> :t moveFile
09:13:48 <monoidal> hseg: in the IRC logs, it seems that you raised the issue of transformers. they're a different beast
09:13:54 <lambdabot> Not in scope: `moveFile'
09:14:00 <mm_freak> :t renameFile
09:14:07 <lambdabot>     Not in scope: `renameFile'
09:14:08 <lambdabot>     Perhaps you meant one of these:
09:14:08 <lambdabot>       `readFile' (imported from Prelude),
09:14:41 <mm_freak> :t brain
09:14:48 <lambdabot> t
09:15:08 <hseg> What I meant there is that the monad transformer t of some base monad m as applied to some wrapped monad w, at least AFAICT, is just the monad m on the Kleisli category of w.
09:15:17 <ATuin> Could not find module `GHC.Read' <- how can i solve this error
09:15:19 <`^_^v> has anyone encountered this while working with data.time? http://pastebin.com/2Dzy1qmW (obviously someone else has cause i found this pastebin on google)
09:15:27 <mauke> The paste 2Dzy1qmW has been copied to http://hpaste.org/87910
09:15:33 <ATuin> ghc says that is member of a hidden class
09:15:47 <ATuin> s/class/package sorry
09:15:56 <hseg> However, seeing as these are all definitions that I'm really not familiar with, I might be completely wrong.
09:16:48 <hseg> Restating my statement as a question, what is the difference between the monad transformer t of some monad m as applied to some wrapped monad w, and the monad m on the Kleisli category of w?
09:18:50 <mm_freak> ATuin: sounds like you're compiling without --make or something
09:19:07 <ATuin> mm_freak: nope, im using cabal-dev and yesod
09:19:14 <ATuin> the package seems to be 'base'
09:19:25 <fizbin> enigmuriatic: Best current option seems to be http://stackoverflow.com/a/5922788 though I would really recommend instead seeing if a web app is easier/more approriate to your use case.
09:19:36 <ATuin> is not hidden when running ghc-pkg list
09:19:36 <mm_freak> then you should ask in #ghc
09:19:42 <ATuin> ok, thanks
09:20:15 <mm_freak> hseg: i don't even understand what you mean
09:20:59 <hseg> I believe I might be making statements on stuff I don't understand fully yet.
09:21:07 <otters> is there any GHC that supports type holes right now?
09:21:09 <mm_freak> hseg: could you give examples?
09:21:13 <merijn> hmm, is there a quick "arrow law" overview somewhere?
09:21:14 <ATuin> mm_freak: maybe the problem is with the package fay-base, it adds a module Prelude
09:21:17 <merijn> otters: HEAD, I think?
09:21:18 <mm_freak> otters: i think GHC HEAD does
09:21:27 <otters> rats
09:21:34 <benzrf> wow I just had a really stupid moment
09:21:35 <mm_freak> ATuin: i don't know, sorry
09:21:41 <merijn> I need to figure out if what I have in my head is actually an arrow...
09:21:50 <benzrf> I came here to complain that openTempFile wasn't referentially transparent since the filename is random
09:21:56 <mm_freak> merijn: you mean the ~20 arrow laws?
09:21:59 <benzrf> ...I should probably practice my understanding of this stuff more
09:22:02 <otters> I just need to figure out a type signature for this value I'm not using
09:22:02 <merijn> Oh, bah
09:22:13 <merijn> mm_freak: I dunno, are there that many? >.>
09:22:18 <mm_freak> merijn: i think in the original arrow paper there is an overview of them
09:22:20 <mm_freak> yeah
09:22:37 <mm_freak> somewhere between 20 and 30…  arrows are messy
09:22:43 <merijn> I have something that feels arrowy, but probably isn't at all
09:22:58 <merijn> Oh, maybe I just want to implement Category...
09:23:02 <mm_freak> merijn: what's the type?
09:23:21 <hseg> What I meant was that, e.g. StateT s Maybe a is equivalent to State_(Kleisli Maybe) s a, where State_(Kleisli Maybe) is to be interpreted as the State monad on the Maybe monad's Kleisli category.
09:23:51 <mm_freak> hseg: i can't make sense of that
09:24:10 <mm_freak> hseg: not without either a kind error or a type error
09:24:57 <acube> @hoogle (Monad m) => m a -> (c -> a -> m b) -> c -> m b
09:24:58 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
09:24:58 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
09:24:58 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
09:25:01 <hseg> Again, I think a lack of theoretical knowledge on my part is causing me to spout nonsense. I'd rather table this discussion until I obtain a better understanding of the topics involved
09:25:23 <mm_freak> hseg: there is:  a -> T M b, which is Kleisli (T M) a b
09:25:37 <acube> @pl (\m f a -> m >>= f a)
09:25:38 <lambdabot> (.) . (>>=)
09:25:42 <merijn> mm_freak: I'm still trying to figure out the type I want, I wanted to see if Arrow would've been a good base. Essentially I have things that'll be "a -> b -> c -> (d, e, f)" that I want to compose with "d -> e -> f -> (g, h)" (i.e. the number of arguments varies but is statically known for each composition)
09:26:01 <hseg> Hm. That resembles the types I was thinking of.
09:26:16 <merijn> I probably want a heterogeneous list instead of tuples for the return type, to look nicer
09:26:29 <mm_freak> merijn: well, you have categories with products, but they are messy as well
09:26:47 <enigmuriatic> what's generally accepted as the best lightweight reliable haskell web framework?
09:26:52 <acube> Is there a nicer way to write (m >>=) . f ?
09:26:57 <mm_freak> C (a, b, c) (d e f), C (d, e, f) (g, h)
09:27:03 <merijn> enigmuriatic: Snap or happstack, probably
09:27:09 <mm_freak> enigmuriatic: all of them
09:27:19 <merijn> mm_freak: Yesod is lightweight? :D
09:27:23 <mm_freak> although yesod is slightly more integrated
09:27:26 <mm_freak> merijn: pretty much
09:27:31 <mm_freak> most of its features are optional
09:27:52 <mm_freak> enigmuriatic: very lightweight, but also inconvenient:  scotty
09:28:02 <mm_freak> i suggest using happstack or snap
09:28:47 <mm_freak> acube: not really, unless f is return . g
09:28:53 <mm_freak> in which case you have fmap
09:28:57 <mm_freak> otherwise you might find (<*>) helpful
09:29:43 <merijn> hmm, I should just start writing this and try to figure out the abstraction afterwards...
09:30:03 <mm_freak> merijn: the abstraction is Category and you likely get an Arrow as well
09:30:13 <mm_freak> but you don't need to write it, because (->) is predefined =)
09:30:23 * hseg apologises profusely for spamming the channel with non-useful noise caused by a lack of understanding of the subject.
09:30:44 <merijn> mm_freak: I don't think (->) is defined in the way I'd need it?
09:31:04 <mm_freak> merijn: can you name an example application?
09:31:35 <merijn> mm_freak: I'm back to figuring out a wire inspired GUI approach :p
09:32:03 <merijn> I've scrapped my earlier ideas as to complicated
09:32:13 <mm_freak> merijn: did you check out tangible values?
09:32:27 <merijn> The Conal paper? Yeah
09:32:41 <merijn> That actually seems fairly similar to what I want, yeah
09:32:56 <mm_freak> yeah, now add time and you get Wire =)
09:32:59 <merijn> Well, I only saw the presentation of tangible values, I should read the paper, I guess
09:33:10 <mm_freak> all, add time and you get SF
09:33:35 <merijn> The problem I have with Wire is that it only has one input type and one output type
09:33:36 <mm_freak> i didn't read the paper, but the library API is pretty much self-explanatory
09:33:52 <mm_freak> well, you have (,) and Either
09:34:06 <merijn> And I don't want to define wrappers by hand all the time
09:34:38 <mm_freak> the problem is:  if you want to get rid of the products and sums you need a monadic FRP framework, which comes with its own problems
09:35:08 <merijn> Yes
09:35:26 <mm_freak> my personal conclusion is:  monadic FRP does not work, period
09:35:49 <kryft> FRP?
09:35:59 <dmwit> ?google frp
09:36:00 <lambdabot> http://en.wikipedia.org/wiki/FRP
09:36:00 <lambdabot> Title: FRP - Wikipedia, the free encyclopedia
09:36:17 <dmwit> booo
09:36:21 <dmwit> Functional Reactive Programming
09:36:31 <dmwit> Oh, it is on that page. yaaay
09:37:57 <mm_freak> merijn: i tried to come up with a sensible monadic FRP type for years now, and there doesn't seem to be a way around the diagonalization problem, unless you give up switching
09:38:02 <mm_freak> and you really don't want that
09:38:28 <merijn> mm_freak: Maybe, but I think I have to find that out on my own, because for some reason, no matter what I do I'm not really getting my head around AFRP
09:38:45 <mm_freak> merijn: do you understand Auto?
09:38:54 <mm_freak> newtype Auto a b = Auto (a -> (b, Auto a b))
09:38:59 <merijn> Yeah
09:39:07 <mm_freak> now consider this type:
09:39:11 <Scabe> What's that site again where you can type up your code and then send it into this chat channel?
09:39:15 <merijn> Don't get me wrong, I understand the type of, say, netwire
09:39:26 <merijn> Everything in netwire seems to make clear sense
09:39:35 <merijn> I just don't grok how to do anything with it >.<
09:39:42 <merijn> Scabe: hpaste.org
09:39:49 <Scabe> thanks merijn
09:39:57 <mm_freak> merijn: data LS a b = forall s. LS s ((a, s) -> (b, s))
09:40:01 <mm_freak> does this type make as much sense?
09:40:31 <merijn> Actually, by now I even understand how to do things with netwire, but when I want to hook it up to something GUI I become clueless again...
09:40:49 <hpaste_> Scabe pasted “Struggling for hours on this” at http://hpaste.org/87911
09:41:30 <mm_freak> Scabe: use size_of_tree recursively
09:41:32 <merijn> mm_freak: LS has an existential s that gets passed along as second tuple value to the function stored in LS
09:41:50 <mm_freak> merijn: yeah, now what could the "LS" mean?
09:42:14 <merijn> local state?
09:42:17 <mm_freak> right
09:42:37 <monochrom> Scabe: the Prelude function "map" may help you deal with lists
09:42:38 <mm_freak> and that's basically it…  you have a bunch of components with local state
09:42:50 <mm_freak> and Category and Applicative/Arrow give you ways to compose them
09:42:50 <ocharles> mm_freak: what is a 'diagonalization problem'?
09:43:04 <mm_freak> ocharles: data Stream a = Stream a (Stream a)
09:43:08 <mm_freak> write a Monad instance for that one
09:43:16 <mm_freak> one that agrees with its Applicative instance that is
09:43:38 <merijn> mm_freak: Yes, my problem is more around "what if I want a or b to get merged/split conveniently"
09:44:02 <mm_freak> merijn: merge liftA2, split (<|>)?
09:44:02 <Scabe> I haven't tried map yet, recursive I have, the problem is when I put in a pattern, I get a new warning to place a different pattern and so on
09:44:04 <mm_freak> or what do you mean?
09:44:20 <merijn> Scabe: What pattern are you putting in?
09:44:34 <ocharles> return = let s x = Stream x (s x) in s ; (Stream a b) >>= f = Stream (f a) (b >>= f)
09:44:37 <ocharles> or something?
09:45:05 <mm_freak> ocharles: now you are at element 10000 in the stream…  how long does it take to get element 10001?
09:45:30 <ocharles> how do you "get to" element 10000?
09:45:39 <mm_freak> by iterating for example
09:45:48 <merijn> mm_freak: Doesn't <|> only take one of two branches? What if I want to take part of the b data and send it to one branch and another part to another branch and have those branches continue in parallel
09:46:05 <mm_freak> merijn: that's (<*>)
09:46:07 <ocharles> ok, well can't you just pattern much on elemente 10000 and take the rest of the stream? or do you mean I only have the 'a'?
09:46:11 <Scabe> So the next pattern I try and do is Rose_Node _ [Rose_Node a []] ->
09:46:32 <merijn> mm_freak: I guess I just don't understand the applicative of wires?
09:46:38 <merijn> Scabe: You don't want that
09:46:44 <Scabe> And then I just do some ghing like 1 + size_of_tree (Rose_Node a)
09:46:52 <merijn> Scabe: You want to use "Rose_Node _ (r:rs) ->"
09:47:17 <ReinH_> Scabe: and please call it RoseNode and RoseTree so my OCD will stop acting up
09:47:17 <merijn> Or maybe not even that
09:47:26 <mm_freak> ocharles: the correct definition is:  Stream x xs >>= f = let Stream y _ = f x in Stream y (xs >>= f)
09:47:34 <Scabe> I've just been taught to write it like that ha
09:48:05 <ReinH_> just use CamelCase
09:48:09 <ocharles> mm_freak: oh right, yes, f produces a Stream
09:48:09 <mm_freak> ocharles: since 'f' is opaque you can only build an ever-increasing chain of f-binds and they can only resolved at the instants in question
09:48:31 <mm_freak> so the complexity to ask for element n is O(n²)
09:49:13 <ReinH_> merijn: probably just RosTree _ leaves -> -- foldr (+) and such
09:49:14 * monochrom invents invert case: iNVERTcASE
09:49:19 <mm_freak> ocharles: that's what i refer to as the diagonalization problem
09:49:52 <ocharles> ok, thanks
09:50:01 <hseg> What is the recommended way to generate XML?
09:50:16 <monochrom> > let mYlIST = [(), (), ()] in sort mYlIST
09:50:18 <hseg> I could just use string concatenation, but it seems ugly to me.
09:50:21 <lambdabot>   mueval: ExitFailure 1
09:50:22 <lambdabot>  mueval: Prelude.undefined
09:50:36 <ReinH_> RoseNode _ leaves -> sum . map size_of_tree $ leaves -- ?
09:50:37 <mm_freak> ocharles: this is just the base problem, but it gets worse:  newtype StreamT m a = StreamT (m (a, StreamT m a))
09:50:42 <monochrom> haha, lambdabot throws up on inverted case :)
09:50:59 <mm_freak> ocharles: now it doesn't work at all, because you need to repeat all past events for every single step
09:51:06 <merijn> mm_freak: I guess my problem is that I have a sort of intuitive understanding of how "type Wire e m a b = a -> m (Either e b, Wire e m a b)" works, and how to implement Functor for that. But I've got no intuition for Applicative and looking at the code isn't really helping
09:51:13 <merijn> monochrom: lambdabot evaluation is broken atm
09:51:14 <merijn> > 1
09:51:19 <lambdabot>   1
09:51:25 <merijn> Oh, that works at least
09:51:28 <merijn> > 1 + 1
09:51:32 <mm_freak> merijn: can you write Applicative for Auto a?
09:51:33 <lambdabot>   2
09:51:49 <monochrom> it is probably limited to "10 evaluation steps" :)
09:52:09 <merijn> mm_freak: Lemme try
09:52:14 <mm_freak> merijn: or for its equivalent LS a =)
09:52:20 <mm_freak> yes, Auto is isomorphic to LS
09:54:42 <ReinH_> Scabe: you want to match against RoseTree _ leaves for the non-empty case and fold over each leaf in leaves, adding 1 to the size of that leaf (which I forgot to do) and summing.
09:56:39 <hpaste_> merijn pasted “Let's start simple: Auto Functor” at http://hpaste.org/87912
10:00:40 <hpaste_> fizruk pasted “Auto Applicative (my try)” at http://hpaste.org/87913
10:01:18 <mm_freak> merijn: that's right
10:01:21 <fizruk> mm_freak: are my instances correct?
10:01:34 <mm_freak> uhm
10:01:49 <mm_freak> fizruk = merijn?
10:02:21 <hseg> What is the recommended way to generate XML using only the Platform?
10:02:24 <fizruk> mm_freak: nope, just intruding your conversation :)
10:04:13 <fizbin> hseg: Does the HP include Text.XML.Simple ?
10:04:18 <mm_freak> i see
10:04:25 <mm_freak> fizruk: yeah, your instance is correct
10:04:40 <ReinH_> merijn: it might help you to define pure first
10:04:49 <fizruk> mm_freak: thanks)
10:05:04 <fizbin> Sorry, Text.XML.Light is what I meant.
10:05:10 <hseg> No. It does include Text.XHtml though.
10:05:26 <hseg> But that's probably not useful
10:06:01 <hseg> Simplification: no nodes have attributes, and literal data is only stored in the leafs.
10:06:19 <hpaste_> merijn annotated “Let's start simple: Auto Functor” with “Auto Applicative” at http://hpaste.org/87912#a87914
10:06:40 <simukis_>   File "test.py", line 2
10:06:40 <simukis_>     hello –= 10
10:06:40 <simukis_>             ^
10:07:06 <merijn> ReinH_: pure is the easy part
10:07:17 <ReinH_> merijn: does that satisfy fmap f x = pure f <*> x ?
10:07:19 <fizruk> ReinH_: I always though that it is better to start with (<*>) — pure will follow from the laws
10:07:28 <merijn> ReinH_: No clue
10:07:51 <ReinH_> fizruk: if you want to test your understanding of <*>, pure is nice to have :)
10:08:37 <ReinH_> merijn: maybe apply a little equational reasoning?
10:08:43 <merijn> ReinH_: I think it does
10:09:11 <merijn> Frankly, I care more about getting the intuition than correctness
10:09:33 <ReinH_> so pure is Auto $ const (x, pure x) ?
10:09:39 <ReinH_> merijn: ok :)
10:10:03 <merijn> Yes, clearly
10:10:28 * fizbin1 is trying to figure out what the intuition is here for Auto.
10:10:46 <merijn> Which means that the a in <*> will always be f if you do "pure f <*>"
10:11:14 <dmwit> fizbin1: It's an automaton (actually a transducer).
10:11:20 <merijn> fizbin: It's feeding every a into two Auto's then feeding the result of the second Auto into the first Auto
10:11:21 <dmwit> fizbin1: It reads tokens of type a and emits tokens of type b.
10:11:22 <fizruk> i thought of an Auto as a funky Stream, is that intuition correct?
10:12:02 <merijn> fizbin: -ish, but you can change the behaviour of future steps, streams can't
10:12:33 <fizbin1> Ah, okay. So one example of Auto would be a FSM that took in "a"s and emitted "b"s on each transition.
10:12:40 <dmwit> right
10:12:49 <fizruk> merijn: just some more actions to get next item in a strem
10:12:53 <fizruk> *stream
10:14:32 <mm_freak> merijn: now that you have (<*>) change the type slightly
10:14:50 <mm_freak> newtype Wire a b = Wire (a -> (Maybe b, Wire a b))
10:14:58 <mm_freak> write Functor for that one
10:15:30 * fizbin1 wonders if pure would be better written with explicit sharing as (let a' = Auto (const (x, a')) in a')
10:15:50 <mm_freak> yes, you should use sharing
10:16:19 <mm_freak> the easy way to do it:  pure x = fix (\a -> Auto (const (x, a)))
10:16:42 <fizbin1> mm_freak: Not sure that's easier than using a let like I did.
10:16:58 <byorgey_> well, that only works because of the particular way fix happens to be defined.
10:17:07 <hpaste_> merijn annotated “Let's start simple: Auto Functor” with “Applicative with Maybe” at http://hpaste.org/87912#a87915
10:17:08 <mm_freak> byorgey_: right
10:17:40 <fizruk> byorgey: what do you mean?
10:17:49 <mm_freak> merijn: that's right
10:18:00 <mm_freak> merijn: now the interesting part:  implement Alternative for Wire =)
10:18:10 <byorgey> fizruk: I mean that 'fix' is defined in a way that uses sharing, but it doesn't have to be
10:18:10 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
10:18:22 <merijn> I don't really know how Alternative is defined, hold on >.>
10:19:11 <mm_freak> merijn: if the wire outputs a Just, it produces, otherwise it inhibits
10:19:11 <mm_freak> empty always inhibits
10:19:16 <mm_freak> that's the idea
10:19:17 <fizbin1> mm_freak: This gets back to my issue that "Alternative" has unclear intuition.
10:19:28 <fizbin1> So it isn't always clear what it's supposed to mean.
10:19:47 <mm_freak> fizbin1: i don't understand
10:19:50 * mekeor realises the module containing the main-function has to be called "Main". (right?)
10:19:58 <fizruk> byorgey: m... do other implementations for fix make much sense?
10:20:03 <mm_freak> mekeor: right
10:20:04 <byorgey> mekeor: right
10:20:13 <dmwit> mekeor: You can ask GHC to use other modules' main.
10:20:21 <byorgey> mekeor: alternatively you can pass the -main-is flag if the module has some other name
10:20:22 <dmwit> mekeor: (Also, being pedantic: main is not a function.)
10:20:36 <byorgey> fizruk: sure.  fix f = f (fix f)
10:20:39 <mm_freak> mekeor: but since we love special cases so much, Main is the only module which doesn't have to match its file name =)
10:20:40 <mekeor> dmwit: :D okay.
10:20:52 <mekeor> mm_freak: oh, cool
10:21:01 <byorgey> fizruk: versus   fix f = let x = f x in x
10:21:31 <byorgey> fizruk: they have exactly the same denotational semantics, but operationally the second one introduces some sharing and the first one doesn't
10:21:38 <mekeor> byorgey: nice... uhm, could i do "ghc-options: -main-is ...." in my *.cabal-file?
10:21:42 <byorgey> at least, given the way GHC compiles things.
10:21:56 <mm_freak> mekeor: just use "main-is" in your cabal-file
10:22:01 <mm_freak> "main-is: blah.hs"
10:22:15 <mekeor> hm, i'm already doing that, actually..
10:22:17 <fizbin> mm_freak: I was complaining earlier that the Alternative definition for [] doesn't fit the intuitive description in the documentation. Also, that "some" and "many" don't make sense for Alternative instances that aren't parsers.
10:22:25 * mekeor is probably having some other issue
10:22:30 <dmwit> I have a radical proposal: what if the *.cabal file was just named "cabal" instead of "arbitrary.cabal".
10:22:41 <mm_freak> fizbin: yeah, i usually ignore 'some' and 'many'
10:22:48 <fizruk> byorgey: thanks
10:23:18 <byorgey> dmwit: that would be consistent, elegant, beautiful, and super annoying
10:23:27 <fizbin> mm_freak: In that sense, Alternative's intuitive meaning seems a bit schizophrenic: it means either "parserish" or "failure-with-retryish", but the [] instance doesn't really mean either of those.
10:23:40 <dmwit> Why annoying?
10:23:47 <mm_freak> fizbin: to me it means "monoid"
10:23:50 <mm_freak> nothing more
10:24:07 <hpaste_> merijn annotated “Let's start simple: Auto Functor” with “Alternative Auto?” at http://hpaste.org/87912#a87916
10:24:18 <byorgey> dmwit: just too much opportunity for confusion, overwriting one cabal file with another, etc. etc.
10:24:18 <mm_freak> so to me the most annoying part of Alternative is the Applicative constraint
10:24:52 <dmwit> dunno lol
10:25:11 <mm_freak> merijn: that's one way (the netwire 4 way) to do it
10:25:29 <merijn> Alternatively (ha!) you could always run both f and g, but then you need to decide which to keep
10:25:37 <fizbin> mm_freak: But that's not enough. Both the [] Alternative instance that exists standardly and the [] Alternative instance I thought it should have are monoids.
10:25:38 <mm_freak> yeah
10:25:58 <merijn> mm_freak: Yeah, but this doesn't run two wires in parallel, right? If f succeeds, g doesn't get run
10:26:11 <mm_freak> fizbin: well, you can raise that argument against Monoid as well
10:26:20 <merijn> Which is not a model that's nice for stringing tangible values together, for example
10:26:42 <mm_freak> fizbin: that's why we have a bunch of newtype wrappers to capture the different meanings
10:27:06 <mm_freak> merijn: yeah, that's why i said "netwire 4" =)
10:27:12 <mm_freak> it will be different in the next netwire
10:27:27 <merijn> mm_freak: My head wants to think of GUI components as more something like CSP, but that doesn't gel well with this approach
10:27:39 <mm_freak> CSP?
10:27:55 <merijn> Communicating Sequential Processes
10:28:00 <fizbin> Fair enough. In that case, [] shouldn't have an Alternative instance then. There should be the "Concatenation" newtype wrapper and the… um… "NonEmpty" ? newtype wrapper.
10:28:29 <mm_freak> merijn: you can always use yampa's event concept…  netwire is a strict superset of yampa
10:28:36 <mm_freak> but it's an ugly concept IMO
10:28:50 <mm_freak> so i'd prefer to fix netwire's Alternative instead
10:29:04 <fizbin> Or maybe my intuition is really saying that ZipList should have an alternative instance. Hrm.
10:29:25 <acube> some [4] results in *** Exception: <<loop>>, really?
10:29:25 <mm_freak> fizbin: to Alternative ZipList is pretty much the same as []
10:29:43 <aristid> johnw: pong?
10:29:43 <lambdabot> aristid: You have 1 new message. '/msg lambdabot @messages' to read it.
10:29:58 <acube> and so does many :/
10:30:00 <acube> @src many
10:30:00 <lambdabot> Source not found. Where did you learn to type?
10:30:05 <acube> @src some
10:30:05 <lambdabot> some v = some_v
10:30:05 <lambdabot>   where many_v = some_v <|> pure []
10:30:05 <lambdabot>         some_v = (:) <$> v <*> many_v
10:30:13 <mm_freak> that's why i disagree with the Applicative constraint…  there is no specification that connects Applicative and Alternative
10:30:24 <fizbin> mm_freak: Alternative ZipList doesn't seem to exist.
10:31:08 <mm_freak> you first have to decide which law you want to have
10:31:14 <acube> But I think <|> for alternative for lists is valid, in that it first tries all of the possible results of the first list, and then later tries the results of the second list
10:31:16 <fizbin> mm_freak: I'd like to see the constraint (forall f. empty <*> f = empty = f <*> empty)
10:31:41 <mm_freak> you can have left-distributivity:  (a <|> b) <*> c = a <*> c <|> b <*> c
10:32:05 <mm_freak> or you can have left-catch
10:32:20 <fizbin> And I admit that the existing [] and Maybe Alternative instances do satisfy my "empty is like 0" law.
10:32:27 <hseg> Is there a way to construct a value of type forall a. Show a => [a] ?
10:32:27 <merijn_> And then irssi died
10:32:35 <merijn_> What was the last thing I said?
10:33:01 <mm_freak> acube: it's correct from a certain viewpoint
10:33:11 <fizbin> merijn_: You last said "Communicating Sequential Processes"
10:33:16 <merijn_> Ah
10:33:20 <hseg> Specifically, I have a typeclass Renderable which defines a function render. Now I want to construct a list of Renderable values and fmap render over that.
10:33:27 <mm_freak> my favorite example is Either:  it gives rise to two families of Alternatives which disagree
10:33:30 <merijn_> Anyway, CSP would be overkill for my mental picture
10:33:33 <mm_freak> in particular one of them isn't even a monad
10:33:52 <mm_freak> but that one is so useful that you probably want to define both
10:34:12 <merijn_> I tend to think of UI components as more of a graph, i.e. M input streams N output streams (read types instead of streams if you like)
10:34:15 <acube> mm_freak: which two are those?
10:34:15 <elliott> hseg: the only thing you can do with such a list is apply render to the elements.
10:34:18 <mm_freak> merijn: isn't Auto CSP?
10:34:20 <elliott> so use [result type of render] instead.
10:34:25 <elliott> you can use an existential type but it is pointless and more noisy
10:34:38 <merijn_> I'm just completely lost about how a type for such a graph would look
10:34:42 <mm_freak> acube: Alternative (Either e) with left-catch
10:34:59 <mm_freak> and (Monoid e) => Alternative (Either e) with left-distributivity
10:34:59 <merijn_> mm_freak: Well, it doesn't let you run two in parallel, no?
10:35:00 <hseg> elliott, That I know. I just want to construct the list so that stuff would look less ugly.
10:35:07 <mm_freak> merijn_: f . g pretty much run in parallel
10:35:14 <hseg> I'm only planning to apply render to those values.
10:35:15 <mm_freak> so do f <*> x
10:35:32 <mm_freak> in the latter case you can even actually parallelize their evaluation
10:35:43 <merijn_> I was thinking something like (&&&)
10:35:47 <elliott> hseg: the alternative is applying a constructor of an existential type, so yeah, no way to avoid it there
10:35:47 <merijn_> :t (&&&)
10:35:54 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
10:36:13 <mm_freak> merijn_: that's liftA2 (,)
10:36:20 <dmwit> mm_freak: It's not CSP unless one process can read (nondeterministically) from two others, and symmetrically can write (nondeterministically) to two others (of which only one gets any particular token).
10:36:51 <mm_freak> dmwit: Auto is an Arrow and ArrowChoice…  does that fulfill the requirement?
10:37:18 <dmwit> I doubt it.
10:37:26 <dmwit> Nondeterminism don't come for free.
10:37:40 <mm_freak> nondeterminism in what sense?
10:37:59 <hseg> elliott, I'm not sure I understand you. Given a typeclass t, how do I construct a list of values whose types a_i satisfy t a_i?
10:38:02 <dmwit> mm_freak: In the "when I takeMVar, I might get the output of either that guy or that guy depending on who putMVar first"
10:38:13 <dmwit> sense.
10:38:21 <elliott> hseg: my point is that you can define
10:38:30 <elliott> data Showable = forall a. Show a => Showable a
10:38:31 <elliott> and then do
10:38:31 <mm_freak> dmwit: Wire does that actually, except that it's left-biased
10:38:36 <mm_freak> dmwit: a . (b <|> c)
10:38:36 <elliott> [Showable 1, Showable 'a', Showable ()]
10:38:52 <dmwit> mm_freak: (...and symmetrically, "when I putMVar, I might be writing to that process or that process depending on who takeMVars first".)
10:38:54 <elliott> hseg: this is a way of expressing [exists a. Show a => a]
10:39:12 <dmwit> mm_freak: Okay. I believe you. But it doesn't look to me like Auto does that.
10:39:21 <mm_freak> no, Auto doesn't
10:39:27 <merijn_> I need to get home for food, though. I'll be back later if you're around to continue the discussion
10:39:31 <dmwit> ...which was the original question, I think?
10:39:52 <hseg> Nice. So in my case, it would be something like data Renderable = forall a. Render a => Renderable a?
10:39:54 <mm_freak> i don't think there was a question…  he wants CSP
10:39:58 <hseg> Isn't that a GADT?
10:40:08 <merijn_> CSP is more than what I need, I think
10:40:12 <merijn_> I dunno what I want :p
10:40:26 <merijn_> I just know how I want it to work :p
10:40:39 <mm_freak> merijn_: it's probably best to try and fail…  i'm happy with any approach, as long as it's categorically sound =)
10:40:51 <merijn_> anyway, food time
10:41:03 <mm_freak> good hunger =)
10:42:11 <dmwit> hseg: All Haskell data types are GADTs. However, you don't need to turn on the GADT extension to write that; just ExistentialTypes. I think.
10:42:42 <dmwit> ExistentialQuantification
10:43:44 <hseg> OK. It might not be that useful for me to define that.
10:43:52 <dmwit> hseg: ...but again, typically it's easier and clearer to just use whatever methods Render gives you than to create an existential type.
10:44:42 <hseg> Right. Although this fragment is a bit annoying:
10:45:05 <hseg> [render "class", render n, render '{'] ++ fmap render vs ++ fmap render fs ++ [render '}']
10:45:21 <LLckfan> Does any1 know how to stop Shockwave flash from crashing? I have uninstalled both Flash and my browser (Chrome), installed both from a fresh download, and scanned my computer (come up clean). Everything is updated
10:45:40 <dmwit> hseg: Not significantly more annoying than [Renderable "class", Renderable n, ... would be.
10:45:59 <djahanda1ie> Hmm, what's the fastest datastructure on Hackage for "counting"? I.e., I have a bunch of items and I want to get counts of them. Basically map (head &&& length) . group . sort, but something faster than that.
10:46:13 <hseg> Right.
10:46:15 <dmwit> LLckfan: Perhaps you should look for a more appropriate forum. This channel is for discussing Haskell.
10:46:26 <LLckfan> There are none
10:46:29 <Cale> LLckfan: This isn't really the right channel for that question, but I can tell you that I haven't had that problem in Chrome.
10:46:42 <dmwit> LLckfan: False, and also not our problem.
10:46:54 <elliott> you may find ##windows appropriate, if you use that operating system
10:47:03 <elliott> (no guarantee as to the on-topicness of that question in ##windows; just a guess.)
10:47:14 <LLckfan> Windows is no help
10:47:21 <Cale> LLckfan: you might want to go to chrome://plugins/ and check which Flash plugin(s) you have active.
10:47:29 <elliott> we will be even less help. we know about Haskell, not Flash
10:47:34 <LLckfan> I on;ly have one
10:47:55 <Cale> The one I'm using here is 11.6.602.180 and it uses PPAPI.
10:48:12 <dmwit> djahanda1ie: Seems like the only way to go faster than that is to have an Ix-alike or hash function.
10:48:23 <dmwit> (asymptotically, no idea about practically)
10:48:54 <djahanda1ie> Yeah, asymptotically, I'm more curious about specialized structures for this which just shave down the constant.
10:49:52 <dmwit> I suppose some kind of trie-like idea might not be awful, depending on what your data is shaped like.
10:50:05 <dmwit> ...what *does* your data look like?
10:50:06 <djahanda1ie> Doing it with a Map and updating counts on the fly would probably be the best in terms of memory usage at least.
10:50:25 <djahanda1ie> dmwit, I have a stream of incoming country codes.
10:50:33 <djahanda1ie> US, CA, etc. etc.
10:50:54 <dmwit> That seems structured enough that you could use an array.
10:51:12 <djahandarie> Yeah. I suppose I should just do that.
10:51:15 <dmwit> Maybe with a Map on the side for things that don't fit in the [A-Z][A-Z] pattern.
10:51:24 <djahandarie> I hate using arrays in Haskell though. :(
10:51:32 <dmwit> accumArray seems pretty clean...?
10:52:39 <djahandarie> I mean, are you suggesting a mutable array which stores the counts?
10:52:54 <dmwit> You could do that, but accumArray already abstracts that pattern.
10:53:25 <dmwit> :t \a b cs -> Data.Array.IArray.accumArray (+) 0 (a, b) (zip cs (repeat 1))
10:53:33 <lambdabot> (Num e', Ix i, Data.Array.Base.IArray a e') => i -> i -> [i] -> a i e'
10:56:21 <dmwit> hm
10:56:21 <dmwit> :t range
10:56:40 <lambdabot> Ix a => (a, a) -> [a]
10:56:40 <dmwit> > range (('a','a'),('c','c'))
10:56:41 <lambdabot>   [('a','a'),('a','b'),('a','c'),('b','a'),('b','b'),('b','c'),('c','a'),('c'...
10:56:44 <dmwit> perfect
10:57:17 <dmwit> :t \elems -> Data.Array.IArray.accumArray (+) 0 (('A','A'),('Z','Z')) (zip elems (repeat 1))
10:57:24 <lambdabot> (Num e', Data.Array.Base.IArray a e') => [(Char, Char)] -> a (Char, Char) e'
10:59:26 <dmwit> Wow, freenode's really having some trouble today.
10:59:58 <hseg> Can I make a type an instance of a typeclass? i.e. type Foo = Maybe Bar; instance Show Foo... ?
11:00:41 <simpson> dmwit: A couple Freenode providers appear to be having independent but concomitant bandwidth problems. :c
11:01:00 <elliott> hseg: yes with the TypeSynonymInstances extension, but it just means instance Show (Maybe Bar).
11:01:01 <dmwit> hseg: Yes, provided you can make Maybe Bar an instance. Use TypeSynonymInstances.
11:01:03 <elliott> which overlaps
11:01:10 <elliott> likely, you want to create a newtype. overlapping is bad.
11:01:16 <elliott> (and disallowed without evil extensions)
11:01:24 <dmwit> simpson: I see.
11:01:39 <simpson> dmwit: We've got our top men examining it.
11:02:02 <dmwit> Apologies, but: is this sarcasm?
11:02:06 <hseg> Right. So I probably will just write instance Show (MAybe Bar)
11:02:47 <simpson> dmwit: Top. Men.
11:02:54 <dmwit> =)
11:03:44 <simpson> Nah, I'm just having some fun. I know that people are trying to figure things out, but apparently the problem is way upstream.
11:04:20 <dmwit> Okay. Bummer! I hope things go well for the Top Men.
11:04:28 <elliott> I hear something about DDoSes
11:04:39 <elliott> in my incredibly secret global notices that only get sent to me
11:04:43 <dmwit> Is there a partial evaluator for CPP lying around?
11:04:58 <elliott> (they're called global because I receive them no matter where on the planet I am)
11:05:01 <hseg> elliott, Wait, why would I prefer a newtype to a type declaration?
11:05:10 <dmwit> elliott: My global notices are lost in a sea of reconnection spam because I can't get a stable connection.
11:05:12 <Heffalump> dmwit: http://dotat.at/prog/unifdef/
11:05:31 <dmwit> Heffalump++
11:06:21 <dmwit> hseg: A newtype can have a different instance than the type it wraps.
11:07:08 <hseg> Nice, although I thought that you meant that as a general statement - newtypes being better than types.
11:07:22 <dmwit> It doesn't simplify complex expressions that are partially known, but it's a dang good start. Thanks, Heffalump.
11:08:24 <elliott> hseg: it also provides more static checking
11:08:29 <elliott> but yes, it was a statement in context
11:08:58 <elliott> dmwit: the notice was yesterday
11:09:06 <elliott> -kloeri(~kloeri@freenode/staff/exherbo.kloeri)- [Global Notice] Hi all, apologies for the continued netsplits. We're having some issues stemming from a DDoS attack but we're working  with our sponsors on attack mitigation. Thank you for using freenode.
11:09:22 <dmwit> elliott: In that case, the notice is potentially lost in *two* seas of reconnect spam. =P
11:09:27 <dmwit> But thank you for pointing it out to me.
11:09:32 <hseg> OK. Seeing as I'm not making an instance for Maybe a, I should be safe using TypeSynonymInstances.
11:09:41 <elliott> dmwit: I was just kidding, btw, not trying to be snarky
11:10:06 <dmwit> snark comes naturally, and I love it
11:16:09 <djahandarie> dm 'snark' wit
11:18:58 <yitz> hseg: really, use newtypes. that's idiomatic haskell.
11:19:30 <hseg> Really? I didn't know that.
11:20:11 <dmwit> I'm not sure I agree there.
11:20:21 <yitz> @wn snarky
11:20:22 <lambdabot> No match for "snarky".
11:20:40 <dmwit> I don't see anything wrong with using a type alias here and there.
11:21:07 <yitz> dmwit: oh, sure. but not when you want to make it an instance.
11:21:17 <dmwit> Why not?
11:22:10 <yitz> dmwit: well, it seems to me to be pretty rare around hackage, and for good reason, in my opinion.
11:22:37 <yitz> dmwit: since instance are violently global, it seems like a bad idea to hide them behind an alias.
11:25:25 <dmwit> I'm not sure how I feel about type aliases in general, to be honest.
11:26:09 <arkeet> they just save a bit of typing here and there.
11:27:03 <arkeet> I'm glad lens has them.
11:29:05 <monochrom> most type aliases are leaky abstractions
11:29:59 <arkeet> but sure, they shouldn't be used for any sort of encapsulation.
11:31:45 <joe9> this code is from lyah: pop = State $ \(x:xs) -> (x,xs)
11:32:00 <joe9> but, I get the error that there is no data constructor called State
11:32:11 <mauke> oh yeah
11:32:14 <monochrom> change State to state. the library has changed.
11:32:16 <mauke> try state instead
11:32:24 <joe9> ok, thanks.
11:32:29 <jeremy_c> <- executes an IO action, why is it not needed on putStrLn?
11:32:37 <mauke> jeremy_c: <- doesn't execute
11:32:42 <mauke> it only lets you give a name to the result
11:32:47 <mauke> putStrLn has no useful result
11:32:53 <monochrom> <- does not execute an IO action. please question your assumptions
11:33:04 <mauke> but you can still do { x <- putStrLn "hello"; print x }
11:33:08 <jeremy_c> mauke: hm, OK, I'll go back and read the IO section again.
11:37:11 <joe9> mauke: monochrom: has state transformer constructor changed to stateT or something like that too?
11:37:24 <hseg> joe9, yes
11:37:53 <monochrom> no
11:37:53 <mauke> no
11:37:55 <mauke> overruled
11:37:56 <hseg> Sorry, misread. State *transformer* didn't change
11:38:05 <hseg> Other classes *did*
11:38:29 <hseg> This is probably because ST, like IO, is implemented in the compiler, right?
11:38:40 <monochrom> no
11:39:32 <dmwit> The State constructor is gone. The StateT constructor hasn't changed. state is new
11:39:40 <geekosaur> no, because the standalone ones were rephrased in terms of the transformers
11:39:51 <monochrom> please read the source code of package "transformers" and compare with source code of mtl-1
11:40:07 <dmwit> ST and IO are unrelated.
11:40:37 <mekeor> -- can i make cabal/haddock generate the documentation for not-exported stuff, too?
11:40:46 <dcoutts> yes
11:40:47 <hseg> Wait, wait. Misunderstanding here. Yes, State s was replaced by StateT s Identity. I thought joe9 was asking about ST
11:40:57 <mekeor> dcoutts: cool. how? :)
11:41:11 <dcoutts> mekeor: see $ cabal haddock --help
11:41:14 <hseg> dmwit, IIRC, they *are* related, as IO is a special case of ST.
11:41:21 <hseg> Or something similar
11:41:29 <dmwit> ST and IO together are not related to using State or StateT.
11:41:34 <dmwit> Yes, ST and IO are related to each other.
11:41:37 <dcoutts> mekeor: --internal
11:41:41 <hseg> See stToIO
11:41:48 <int-e> @src IO
11:41:49 <lambdabot> Source not found. Take a stress pill and think things over.
11:41:50 <mekeor> dcoutts: was just writing... cool! thank you! :)
11:41:59 <monoidal> IO is not a special case of ST, but of GHC.ST.ST
11:42:18 <monoidal> ummm State#
11:42:35 <dmwit> (Surely, if anything, ST is a special case of IO. IO can do More Things.)
11:43:40 <int-e> dmwit: but as a type, IO is just two newtypes away from ST RealWorld
11:44:10 <int-e> in ghc
11:44:24 <dmwit> ok
11:55:09 <dolio> That implementation of IO doesn't really make any sense, though.
11:55:53 <dolio> Whereas it's sensible for ST, I believe.
11:57:28 <Cale> I think we can all agree that the implementation of IO in GHC is an ugly hack :)
11:57:47 <Cale> (it's an ugly hack that works well, but it's ugly nonetheless)
11:57:56 <dolio> Yes.
12:06:00 * hackagebot histogram-fill 0.8.1.0 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.8.1.0 (AlexeyKhudyakov)
12:06:05 <yitz> dmwit: ST plus an STRef is isomorphic to State.
12:06:11 <chrisdotcode_> hi everyone :)
12:07:55 <Peaker> Read what row polymorphism is.. much simpler than I thought
12:08:16 <arkeet> yitz: I disagree
12:08:34 <dcoutts_> yitz: but the magic is that ST allows multiple STRefs, that can't be simulated with a State monad
12:08:51 <arkeet> ST requires no initial state either.
12:08:55 <monochrom> perhaps change to: ST limited to one STRef
12:09:09 <arkeet> State requires an initial state.
12:09:10 <monochrom> perhaps change to: ST limited to one STRef that needs initialization :)
12:09:20 <arkeet> that's passed to it on runState
12:09:31 <arkeet> ST does no such thing.
12:09:32 <dcoutts_> yitz: it's actually quite magic, from a typing point of view imho.
12:10:05 <dcoutts_> yitz: e.g. I can "hide" the type of state, by having ST s () actions that act on STRefs that I never get to see the type of
12:10:46 <hpaste_> gdoteof pasted “parse error on input 'requests'” at http://hpaste.org/87918
12:11:00 <gdoteof> trying to compile very basic program
12:11:25 <Peaker> gdoteof, you seem to be confusing Python and Haskell
12:11:37 <gdoteof> lol
12:11:38 <gdoteof> sry
12:12:10 <yitz> yes. full ST is more than State. but it is easy to show that ST with a single STRef is isomorphic to State.
12:12:18 <elliott> gdoteof: try #python? but note that python has no compilation.
12:12:26 <Hafydd> Python does have compilation.
12:12:33 <elliott> well, OK. but not the usual kind.
12:12:33 <Peaker> yitz, how about a single STArray?
12:12:36 <elliott> at least not in CPython.
12:12:38 <merijn> elliott: ಠ_ಠ
12:12:40 <Hafydd> What is the usual kind?
12:12:49 <elliott> the kind where you get an executable out, rather than cached bytecode.
12:12:58 <Hafydd> Bytecode is executable.
12:13:05 <elliott> a native executable.
12:13:10 <Peaker> Java is compiled like Python, except with less silly deferral of errors to customer sites
12:13:15 <Hafydd> Python bytecode is native to the Python VM.
12:13:15 <elliott> OK, restatement for pedantry: an absolute beginner is unlikely to be trying to compile a very basic program.
12:13:21 <elliott> they are likely to be trying to run it instead.
12:14:31 <Hafydd> (insert "C" as appropriate)
12:17:25 <yitz> Peaker: hmm. well, denotationally i guess it's the same as a State of an immutable Array, but operationally if you mutate a single element in ST it would recreate the array of pointers in State. and a STUArray is even more different.
12:17:57 <elliott> you can't define ST in pure askell 2010
12:17:58 <elliott> *Haskell
12:17:59 <yitz> Peaker: so it's still different than the case of a single STRef in that sense.
12:18:00 <elliott> you need unsafeCoerce.
12:18:10 <Peaker> yitz, yeah, ST is mostly about the operational semantics.. I don't think the STRef flexibility is why anyone uses ST
12:19:08 <shachaf> elliott: Even with unsafeCoerce you can't define St in Haskell 2010.
12:19:37 <Peaker> Yeah, "forall" trickery
12:19:41 <elliott> shachaf: OK, + rank-2 types
12:20:14 <shachaf> But anyway, yes, you need some additional primitive to make something that acts like ST.
12:20:15 <Peaker> Haskell2014 maybe?
12:21:03 <yitz> Peaker: i doubt rank-2 will make it in
12:22:20 <Peaker> is there no consensus? Or trying to figure out better inference rules?
12:22:21 <doomlord> does any research exist on compiling haskell programs without GC .. i know that haskells' execution model is very differnt to C++, but what if you think of a haskell program as an abstract description of an algorithm (the same exact algorithm can be implemented in C++ and you get the same answer)
12:22:30 <yitz> shachaf: how about with gadts? is that enough to define ST?
12:22:43 <shachaf> No.
12:22:46 <Peaker> doomlord, many Haskell programs can be compiled down to programs that do no allocations
12:22:47 <shachaf> Well, I'd be very surprised.
12:22:49 <doomlord> ^^^ an application would be to select different size/speed tradeoffs
12:22:51 <Peaker> doomlord, but there's no way to guarantee it
12:23:05 <elliott> doomlord: jhc compiles Haskell sort-of without GC.
12:23:05 <doomlord> i suppose profiling tools can report what it does
12:23:06 <shachaf> yitz: The trouble is that STRefs are completely polymorphic.
12:23:08 <elliott> it does region inference stuff.
12:23:29 <yitz> shachaf: i see, that makes sense
12:24:11 <doomlord> i think Rust is closer to C++, but i like its' abiliity to manually avoid the GC by designing code to use ~ ... but i wonder how much of that can be infered by a compiler
12:25:17 <yitz> doomlord: you could use reference counts.
12:25:49 <nlogax> Isn't ~ more or less like a C++11 std::shared_ptr?
12:25:56 <doomlord> unique_ptr
12:26:00 <nlogax> Oh
12:26:41 <merijn> There's no real way to specify a non-IO monad constraint, I guess?
12:26:42 <shachaf> How do you catch a unique_ptr?
12:26:58 <doomlord> catch as in try.. catch?
12:27:08 <shachaf> merijn: As in type inequality? No, not really.
12:27:09 <dmwit> doomlord: https://code.google.com/p/guru-lang/ ?
12:27:39 <merijn> shachaf: Yeah, I'm writing some code that works for pretty much any monad, but I want to disallow IO for sanity reasons
12:28:08 <shachaf> merijn: You could come up with some class for the thing that has the property that you want which IO doesn't.
12:28:27 <dmwit> doomlord: Guru includes, in part, a resource management language called Carraway.
12:28:30 <shachaf> E.g. it's not Copointed (though a lot of good monads aren't, either).
12:28:37 <arkeet> shachaf: unique up on it, of course.
12:28:50 <shachaf> But as a plain type-inequality thing you're probably better off not doing it.
12:29:02 <doomlord> i dont know all the jargon, i've encountered the term "linear types" in relation to what rust does.
12:32:41 <doomlord> i also wondered if in theory one could supply hints - in a seperate file - for transforming haskell into something with a more C++-esque execution model (allocation hints seperated from the programs meaning)
12:34:36 <simpson> doomlord: Your question, BTW, is equivalent to "Can one write C without malloc() and free()?"
12:34:55 <doomlord> simpson, RAII ? :)
12:35:11 <chrisdotcode_> test
12:35:13 <simpson> doomlord: C, not C++.
12:35:17 <simpson> chrisdotcode_: Yes, we can hear you.
12:35:25 <doomlord> you could think of RAII as a generator for C
12:35:27 <chrisdotcode_> simpson: thanks :)
12:37:46 <armlesshobo> simpson: write C code? yes
12:37:51 <armlesshobo> everything is a stack var :P
12:38:01 <armlesshobo> make everything a stack var*
12:38:35 <companion_cube> reserve large parts of the stack as allocators :)
12:38:44 <merijn> mm_freak: Would having a type like "Foo a b = Foo (a -> ([b], Foo a b))" make sense? i.e. have a list instead of Maybe/Either to return 0 or more outputs or should that be done by having Maybe and returning a new Foo a b that immediately returns the next value without looking at it's input?
12:43:06 <dmwit> I feel like newtype Auto a b = Auto (a -> (b, Auto a b)) already covers this by monomorphing to Auto a [b].
12:55:50 <johnw> greetings
12:55:57 <Taneb> Hi, johnw
12:56:59 <johnw> are you coming to ICFP, Taneb?
12:57:18 <Taneb> It's a tad outside my travel range, I'm afraid
12:57:58 <Taneb> (which, to be fair, in most circumstances is limited to the north of England)
12:58:04 <Taneb> (even Manchester is pushing it)
12:58:09 <johnw> :)
12:58:26 <johnw> then Brighton is just flat out
12:59:00 <Taneb> Only a little
13:00:31 <levi> Many C programs don't use malloc() or free(). Mainly small embedded systems, especially safety-critical ones.
13:02:36 <tangentstorm> i'm working on a C program that doesn't use malloc or free too
13:02:36 <companion_cube> Ada programs, too
13:02:39 <johnw> did anyone read my tutorial on continuations?  was it really a horrible way to present, as the only reddit comments suggestion?
13:02:45 <tangentstorm> at least not in my part of the code... maybe behind the scenes :)
13:02:48 <Peaker> levi, I avoid malloc/free for almost all purposes in my C program because it's easier to avoid them and do MM correctly, and I like the extra operational guarantees
13:02:49 <merijn> johnw: When's ICFP, wasn't that only recently?
13:02:50 <johnw> (http://www.reddit.com/r/haskell/comments/1e977w/john_wiegleys_understanding_continuations_on/)
13:02:54 <tangentstorm> https://github.com/tangentstorm/gotopaint muahahahaha
13:02:55 <johnw> merijn: Sep 24-28
13:03:00 <merijn> hmmm
13:03:10 <atamagawarui> levi: So, static, fixed-size arrays, or something like alloca() ? :-P
13:03:56 <johnw> s/suggestions/seem to suggest
13:03:58 <companion_cube> I'd say arena allocators, with bounded size
13:03:58 <merijn> Oh...Boston :(
13:04:53 <merijn> I'm guessing there's no way I can convince the uni to fund my travel there
13:04:58 <eikke_> I'm pondering to come over for ICFP
13:04:58 <Hafydd> Enter the programming competition, win it, and use the prize money to go there.
13:05:03 <eikke_> $company won't pay this year (since I have no talk), but I'll be in SFO for personal reasons till 24th, so maybe I can get them to pay stuff if I fix the flight
13:05:15 <johnw> merijn: where are yoU?
13:05:45 <merijn> johnw: Edinburgh
13:06:10 <johnw> oh, yeah
13:06:15 <johnw> you should grab Taneb on your way down
13:06:19 <rgrinberg> johnw: coming from a limited haskell background I liked it.
13:06:26 <tangentstorm> johnw: i understand continuations but my haskell isn't strong enough to understand your code :/
13:06:34 <merijn> Pretty sure my supervisor will go, but I don't think there's any reason that justifies for flying me there >.<
13:06:35 <rgrinberg> what's the difference between callCC and the kind of call/cc in scheme?
13:06:47 <tangentstorm> johnw: i was fine up until the named continuations section
13:06:52 <johnw> rgrinberg: I think almost none, except that Haskell's callCC has to happen within the ContT monad
13:06:59 <johnw> (or Cont)
13:07:13 <johnw> tangentstorm: if there's anything I could do to make it clearer, just let me know
13:07:44 <fizruk> merijn: become a supervisor :)
13:07:47 <johnw> there's always a problem when you describe something from the point of view of how you yourself finally understood it, because it's bound to be the opposite way that other people have of understanding the same thing
13:09:31 <tangentstorm> johnw: yeah tell me about it... i've been writing a tutorial series on building a database :)
13:10:38 <johnw> tangentstorm: I'd be happy to review it for you if you'd like
13:10:56 <rgrinberg> johnw: can the continuation itself escape the monad?
13:11:00 <Nafai> tangentstorm: sounds interesting!
13:11:24 <johnw> rgrinberg: you can return the value, sure, but it will be of type ContT ans IO t, which won't be of much use to you
13:11:29 <rgrinberg> johnw: in scheme, many examples revolve around setting k to some global variable and messing around with it
13:11:32 <tangentstorm> johnw: i still have 'getting the /r/learnprogramming and /r/lpmc guys involved in ledger' on my to-do list. it's a bit like herding cats, though :)
13:12:08 <tangentstorm> i think there will be much more of an interest in the haskell branch though :)
13:12:20 <Hafydd> Or exactly like herding cats, in some cases.
13:12:53 <tangentstorm> Nafai, johnw : http://tangentstorm.github.io/mr0.pas.html (it's pascal, not haskell though) :/ (also mr1.pas.html for the next episode)
13:13:00 <rgrinberg> johnw: also in your last point about implementing green threads with callcc
13:13:08 <johnw> Pascal?  oh wow
13:13:12 <rgrinberg> do you mean cooperative threads in particular?
13:13:17 <johnw> rgrinberg: yes
13:13:27 <rgrinberg> so basically coroutines
13:13:30 <johnw> exactly
13:14:01 <johnw> once you have callCC, you can abuse a program's flow of control in any way you like
13:14:09 <shachaf> You don't need callcc to implement threads.
13:14:15 <shachaf> It is too much.
13:14:24 <rgrinberg> I remember there's a simple example in reppy's concurrent ml on how to implement threading like that with call/cc
13:14:30 <rgrinberg> would love to see it translated to haskell :D
13:14:46 <shachaf> The way to do it in Haskell would be to make some sort of coöperative threading monad.
13:14:49 <fizruk> are going to discuss delimited continuations too? 'Cause I don't understand them in Haskell.
13:14:50 <eikke> "Cheap but Functional Threads"
13:14:51 <shachaf> Not continuations.
13:14:53 <eikke> old but good
13:15:10 <johnw> shachaf: it was just an exercise, since it CAN be done, not the "right way"
13:15:36 <Nafai> tangentstorm: cool, I'll take a look!
13:15:42 <johnw> hi Nafai!
13:15:44 <shachaf> Continuations are *too* powerful. You need less than continuations.
13:15:59 <Nafai> johnw: hey!
13:16:21 <johnw> shachaf: is there a name for the less powerful concept you're thinking of?
13:16:49 <shachaf> Coroutines? Sort of.
13:17:08 <shachaf> It's related to free monads also, at least vaguely.
13:17:15 <johnw> http://c2.com/cgi/wiki?ContinuationsAndCoroutines says: "CoRoutines are just two or more continuations that call each other whenever they block, end, or just feel like being polite."
13:17:21 <eikke> check the paper I referred to above ^^
13:17:26 <johnw> I think I've come across the explanations of coroutines in terms of continuations too many times
13:17:37 <johnw> it should be reversed, based on what shachaf is saying
13:17:46 <eikke> you dont need all of ContT for coroutines. Oleg has some stuff on that IIRC
13:18:13 <johnw> eikke: actually, my reason for writing that tutorial was based on trying to digest Oleg papers :)
13:18:26 <johnw> oleg is mind fiber
13:19:02 <eikke> I'm looking for some other paper about monadic threading next to the Harrison one, but can't find it
13:19:56 <rgrinberg> is there a monad transformers article on SoH?
13:20:08 <johnw> rgrinberg: I don't think so yet, but that's a great idea
13:20:17 <rgrinberg> i would probably get a lot more out of the continuation tutorial
13:20:20 <rgrinberg> if i understood them bettter
13:20:32 <johnw> I don't really use the transformery aspect of transformers much
13:21:06 <simpson> @unmtl ContT r IO a
13:21:07 <lambdabot> (a -> IO r) -> IO r
13:21:27 <quchen_> rgrinberg: The continuation tutorial just uses the transformer to use "print" in the Cont monad. Just ignore the "lift" if you're trying to get at Cont.
13:21:28 <merijn> If you nest StateT's which one will be accessed? The outer or inner?
13:21:45 <johnw> merijn: try it!
13:22:00 <merijn> johnw: But I'm lazy!
13:22:04 <johnw> merijn: and what do you mean by "access"?  calling "get"?
13:22:05 <quchen_> @unmtl StateT s (StateT t Identity) a
13:22:05 <lambdabot> s -> t -> (a, s, t)
13:22:10 <merijn> johnw: yeah
13:22:11 <quchen_> Tadaa.
13:22:13 <johnw> it will be the outer one
13:22:19 <johnw> lift to get the inner
13:22:27 <merijn> oh, that's convenient :)
13:22:40 <merijn> (for my use case, at least)
13:23:29 <otters> in constraints, is Foo a => Bar a b => a -> b equivalent to (Foo a, Bar a b) => a -> b?
13:23:41 <simpson> otters: Pretty much, IIUC.
13:24:02 <shachaf> In GHC, yes.
13:27:50 <merijn> awww....I can't have multiple GADT constructors with the same record syntax field name? :(
13:32:27 <johnw> how come the monoid instance for Map does a union instead of unionWith (<>)?  because it's fewer dependencies?
13:35:13 <hseg> Anyone know where to ask about XSD? #xml is empty.
13:36:34 <lispy> maybe in a java channel?
13:36:43 <Peaker> johnw, Data.Map's API is just badly designed, becomes apparent when you read conal's TCM paper and see his API for TMap
13:36:56 <Peaker> johnw, if it did the mappend correctly as you mention, it would save the API from a whole bunch of unnecessary functions
13:36:57 <byorgey> johnw: this was just discussed recently on the libraries@ mailing list, I think
13:37:02 <Nafai> tangentstorm: minor typo, first sentence of section 3.4.3, s/reaing/reading/
13:37:46 <johnw> byorgey: really?  I think I missed that discussion
13:38:15 <johnw> Peaker: thanks, looking up TMap no
13:38:17 <johnw> w
13:40:51 <dmwit> merijn: I didn't even know GADT syntax and record syntax could be mixed at all.
13:41:49 <tangentstorm> Nafai: thanks :)
13:43:43 <merijn> dmwit: They can!
13:44:02 <eikke> merijn: how?!
13:44:19 * eikke didnt know either
13:44:40 <eikke> that opens windows of opportunities for GADT-backed lenses
13:44:40 <merijn> "data Foo a b c where Foo :: { bar :: a, baz :: b -> a, xyzzy :: Int } -> Foo a b Bool"
13:44:52 <eikke> w00t
13:44:55 <johnw> huh
13:45:01 <johnw> had no clue
13:45:04 <elliott> is that the new syntax or the old syntax?
13:45:14 <merijn> That works in 7.4 at least
13:45:43 <rgrinberg> gotta try this in ocaml..
13:46:00 <eikke> works in 7.6 ghci
13:46:25 <eikke> that's good to know
13:48:33 <merijn> Man...I wish it was possible to have "Foo :: Maybe * -> *" and make "Foo (Just s)" an instance of Functor, but not "Foo Nothing"
13:48:43 <elliott> rgrinberg: OCaml has GADTs now right?
13:48:46 <merijn> But that won't work without Compose/tedious unwrapping :(
13:48:48 <elliott> amazing that it has those but not higher-kinded polymorphism
13:48:52 <eikke> elliott: since 4.0
13:49:19 <eikke> elliott: https://gist.github.com/NicolasT/5373649
13:50:10 <rgrinberg> always wandered about taht as well
13:50:18 <rgrinberg> could it be because of subtyping?
13:52:23 <elliott> eikke: cool
13:53:25 <eikke> it does often require quite some explicit typing and (without type families) feels rather 'basic' in what you can get done
13:55:03 <rgrinberg> eikke: could you comment on the differences in type inference if you've noticed any?
13:55:23 <rgrinberg> I know that it's done completely differently but I'm not really sure about the specifics
13:55:32 <eikke> rgrinberg: can't really. That's about the only gadt-using code I wrote (for a colleague some time ago)
13:55:53 <eikke> rgrinberg: there was a talk about it during ICFP/CUFP/OUD last year, but I didn't attend it (colleague did)
13:56:37 <rgrinberg> the one by garrigues?
13:56:41 <eikke> maybe https://www.youtube.com/watch?v=vEsnyUhFS9M is interesting
13:56:43 <eikke> yes
13:57:03 <rgrinberg> ya I saw it online the quality is kind of terrible and it was over my head anyway
13:57:27 <eikke> heh
13:59:37 <merijn> mm_freak: I don't suppose there's something like a Wire transformer?
14:01:12 <monochrom> > map (\x -> (45^45) `mod` x) [101, 257, 31337]
14:01:16 <lambdabot>   mueval: ExitFailure 1
14:01:16 <lambdabot>  mueval: Prelude.undefined
14:01:23 <monochrom> too bad :)
14:02:38 <fizbin> > 1
14:02:43 <lambdabot>   mueval: ExitFailure 1
14:02:44 <lambdabot>  mueval: Prelude.undefined
14:03:24 <Fuuzetsu> …not again ;_;
14:04:13 <mauke> > 2
14:04:19 <lambdabot>   mueval: ExitFailure 1
14:04:19 <lambdabot>  mueval: Prelude.undefined
14:05:29 <dwcook> mueval, you were a brave one. We will miss you.
14:05:46 <hpc> hahahaha
14:06:15 <ixmatus> using HXT, 'doc >>> css "h1" >>> (deep getText)' produces a flat list containing the text of all h1's split up (not concatenated) how do I concatenate it before returning it?
14:08:46 * mekeor finally found the bug...
14:09:17 <fizbin> ixmatus: What module are you getting "css" from?
14:09:29 <ixmatus> Handsome Soup?
14:09:33 <Fuuzetsu> ixmatus: by reading the tutorial until the end~
14:09:42 <ixmatus> :-| I have
14:09:47 <dmwit> > 3 -- huh?
14:09:52 <lambdabot>   mueval: ExitFailure 1
14:09:52 <lambdabot>  mueval: Prelude.undefined
14:09:53 <dmwit> ?undefine
14:09:54 <Fuuzetsu> Really? I'm pretty sure it tells you how to do this.
14:10:02 <dmwit> > 3
14:10:07 <lambdabot>   mueval: ExitFailure 1
14:10:07 <lambdabot>  mueval: Prelude.undefined
14:10:15 <dmwit> That doesn't make any sense.
14:10:26 <Cale> ixmatus: What's the type of that arrow?
14:10:29 <dmwit> > ()
14:10:31 <hpc> it should clearly be ExitFailure 3
14:10:34 <lambdabot>   mueval: ExitFailure 1
14:10:34 <lambdabot>  mueval: Prelude.undefined
14:10:37 <Cale> dmwit: I know, it doesn't make any sense
14:10:38 <elliott> dmwit: it's broken.
14:11:01 <Fuuzetsu> http://adit.io/posts/2012-04-14-working_with_HTML_in_haskell.html tells you about >>. and >.
14:11:07 <ixmatus> yes
14:11:09 <dmwit> "How is it broken?" "...email"
14:11:24 <ixmatus> 'doc >>> css "h1" //> getText >>. concat'
14:11:27 <hpc> email is the worst kind of broken!
14:11:30 <ixmatus> that concats the whole list
14:11:37 <ixmatus> I explicitly do not want that
14:11:51 <ixmatus> I need the list concatenated by the elements that it deep selected
14:11:52 * Fuuzetsu scrolls up and re-reads the question
14:12:04 <ixmatus> an example
14:12:23 <ixmatus> this (is what it's returning to me) ["Get ","more traffic"," with less effort","\nusing Whoosh Traffic\8217s proven tools.","Three simple steps to ","more traffic\8230"]
14:12:27 <Cale> Fuuzetsu: Hooray, extra light typefaces aren't light enough for article text, so let's make them grey as well!
14:12:49 <ixmatus> this is what I want: ["Get more traffic with less effort\nusing Whoosh Traffic\8217s proven tools.","Three simple steps to more traffic\8230"]
14:13:03 <Fuuzetsu> Cale: *shrug*, not my site
14:13:07 <Fuuzetsu> fix lambdabot~
14:13:07 <Cale> :)
14:13:13 <Cale> Fuuzetsu: How?
14:13:16 <Fuuzetsu> > 1
14:13:21 <lambdabot>   mueval: ExitFailure 1
14:13:21 <lambdabot>  mueval: Prelude.undefined
14:13:21 <Fuuzetsu> I thought you were hosting it, no?
14:13:23 <ixmatus> there are two H1 tags in DOM and each has nested <spans>
14:13:26 <Cale> Yes
14:13:32 <Cale> I don't know what's wrong though.
14:13:33 <hpc> Cale: it's okay; if you use safari the subpixel rendering favors the artist's intended shape to readability
14:13:47 <Fuuzetsu> “Have you tried turning it off and on again?”
14:13:56 <Cale> of course :)
14:14:09 <Cale> > 1
14:14:14 <lambdabot>   mueval: ExitFailure 1
14:14:14 <lambdabot>  mueval: Prelude.undefined
14:14:15 <Fuuzetsu> Then no idea, my expertise with lambdabot ends there
14:14:15 <Cale> > 1
14:14:19 <Cale> @undefine
14:14:20 <dmwit> ixmatus: I wonder: is there a difference between h1 >>> deep getText >>> concat and something like h1 >>> (deep getText >>> concat)?
14:14:20 <fizbin> ixmatus: Ah, so you want it to concatenate the (deep) text children of each h1.
14:14:21 <Cale> > 1
14:14:21 <lambdabot>   mueval: ExitFailure 1
14:14:21 <lambdabot>  mueval: Prelude.undefined
14:14:26 <lambdabot>   mueval: ExitFailure 1
14:14:26 <lambdabot>  mueval: Prelude.undefined
14:14:28 <Cale> hmm
14:14:28 <dmwit> ixmatus: I am very much not an expert. =)
14:14:29 <hpc> Cale: you remembered to use haskell98 instead of windows98, right?
14:14:38 <Cale> Prelude.undefined?
14:14:47 <b_jonas> > True
14:14:52 <lambdabot>   mueval: ExitFailure 1
14:14:52 <lambdabot>  mueval: Prelude.undefined
14:14:57 <ixmatus> dmwit: any help is appreciated - Arrows are new to me as well so I'm more like a floundering fish right now
14:15:01 <Cale> oh, I guess that's just what it does
14:15:20 <Fuuzetsu> ixmatus: I'm pretty sure the solution is something along the lines of what dmwit in producing.
14:15:22 <b_jonas> look at the private logs?
14:15:29 <Fuuzetsu> Sorry I can't help much but I don't have HXT installed at the moment
14:15:56 <dmwit> ixmatus: Can you :i (>>>) in ghci for me?
14:16:10 <fizbin> dmwit: That's in Control.Category.
14:16:14 <Fuuzetsu> @hoogle >>>
14:16:41 <mekeor> is lambdabot like sleepwalking?
14:16:42 <Fuuzetsu> :t (>>>)
14:16:42 <fizbin> (>>>) :: Control.Category.Category cat => cat a b -> cat b c -> cat a c
14:16:43 <dmwit> right-associative, drat
14:17:00 <dmwit> Oh, but there's a (>>>) and (>>.).
14:17:05 <dmwit> So associativity still matters!
14:17:07 <Cale> okay, mueval is definitely doing that on the commandline, even without lambdabot running
14:17:17 <Cale> So at least we know it's a mueval thing
14:17:21 <dmwit> ixmatus: Next question, can you :i >>. in ghci for me? =P
14:17:30 <ixmatus> aha!
14:17:34 <ixmatus> I figured it out
14:17:45 <Fuuzetsu> Care to share?
14:18:05 <fizbin> ixmatus: was it doc >>> css "h1" /> getText >>. concat
14:18:07 <fizbin> ?
14:18:16 <ixmatus> doc >>> css "h1" >>> (deep getText >. concat)
14:18:25 <fizbin> Ah.
14:18:26 <ixmatus> >. returns a single value instead of a list
14:18:51 <ixmatus> okay - well thank you for the help fellas
14:19:18 <Cale> huh, lambdabot
14:19:27 <Cale> 's connection to the internet seems to suck a bit too
14:19:40 <Fuuzetsu> Is it dying? ;_;
14:19:41 <Cale> "cabal update" is taking forever
14:20:45 * dcoutts_ has been looking into incremental update techniques recently
14:20:56 <fizbin> Anyone know scala?
14:21:11 <Cale> cabal update doesn't take very long on my machine, so it's not the hackage server being slow
14:21:13 <fizbin> Even a little? Scala's "flatMap" is (>>=), yes?
14:21:24 <Cale> fizbin: yes
14:21:27 <hpc> fizbin: yes
14:21:29 <Cale> (>>=) for lists
14:21:40 <dcoutts_> Cale: the file size is getting out of hand though, we do need to move to incremental updates
14:21:44 <johnw> lispy: ping
14:21:48 <hpc> flatMap is part of an interface or something, isn't it?
14:21:58 <fizbin> Cale: It also applies to Option apparently. (Option == scala for Maybe)
14:22:08 <Cale> fizbin: Oh, well, possibly :)
14:22:27 <dcoutts_> I've been looking at the zsync approach, it's rather neat. Basically rsync but using read-only http
14:22:27 <Cale> I don't know scala very well, but I do know that flatMap is another common name for concatMap :P
14:22:30 <hpc> it's worth noting that concat is not called "flat"
14:22:36 <hpc> in scala
14:22:57 <fizbin> But not, surprisingly, to Either[A,B]. Silly scala.
14:23:36 <fizbin> I suppose that's why they had to invent Try[T] as Either[Throwable, T] with extra syntax sugar on it.
14:27:42 <fizbin> While we wait for lambdabot to get better...
14:28:04 <fizbin> ghci tells me this:
14:28:17 <fizbin> λ: :t let opy a b = a . b; compy f = f . f in opy . opy $ id
14:28:17 <fizbin> let opy a b = a . b; compy f = f . f in opy . opy $ id
14:28:17 <fizbin>   :: (a -> a1 -> c) -> a -> a1 -> c
14:28:27 <fizbin> But this errors out:
14:28:35 <fizbin> λ: :t let opy a b = a . b; compy f = f . f in compy opy $ id
14:28:49 <fizbin> (    Occurs check: cannot construct the infinite type: c0 = a0 -> c0   )
14:29:25 <monoidal> is there a writeup of *theoretical* problems with lazy IO, except oleg's note breaking ref. transparency?
14:29:44 <fizbin> What's going on? I sort-of understand it, but the understanding I had before depended on typeclasses, and that doesn't use any.
14:30:41 <hpc> monoidal: there's the practical issue of not knowing when the hell it's going to happen
14:30:55 <simpson> fizbin: Write out the types for `opy` and `compy`.
14:30:57 <hpc> monoidal: at least with concurrent IO you know progress is being made on both at the same time
14:30:59 <monoidal> fizbin: Perhaps a simpler example: let double f = f . f; then you *cannot* use double (\x -> [x]) to get x -> [[x]]because double works only on functions a -> [a]
14:31:21 <monoidal> hpc: right, but I'm now not interested in this. I'd like to write about the theory.
14:31:44 <monoidal> hpc: i.e. lazy IO makes denotational semantics harder etc
14:31:59 <monoidal> fizbin: *because double only works on functions a -> a
14:33:50 <monoidal> fizbin: you can use rank-2-types to define double :: (forall a. a -> m a) -> a -> m (m a); double f x = f (f x); then double (\x -> [x]) will work
14:35:30 <fizbin> See, if I get an explanation in my head for why double shouldn't work, then it stops making sense why (let f = (\x -> [x]) in f . f) typechecks.
14:36:22 <monoidal> fizbin: because (.) :: (b -> c) -> (a -> b) -> a -> c and you can substitute different a,b,c here
14:36:44 <c_wraith> also, because f need not be monomorphic
14:36:58 <fizbin> So I have no problem with (let double f = f . f in double (\x -> [x])) failing, and I have no problem with (let f = (\x -> [x]) in f . f) succeeding but I have a problem with both of those behaviors from the same language.
14:37:21 <c_wraith> no, those make perfect sense
14:37:51 <c_wraith> :t let double f = f . f in double
14:37:53 <monoidal> fizbin: first, we typecheck let and infer a general type for defined terms. Only then we look at "in"
14:38:02 <fizbin> What I have a problem with is that "let" is supposed to cause sharing to happen with the variables it binds, isn't it?
14:38:04 <c_wraith> huh.  lambdabot, where are you?
14:38:21 <monoidal> lambdabot is ill
14:38:21 <fizbin> So if so, why is "f" allowed to be totally different?
14:38:32 <fizbin> c_wraith: Cale is tending to her.
14:38:38 <c_wraith> fizbin: it has to do with where the polymorphism is
14:38:55 <c_wraith> fizbin: in double, you end with with (a -> a) -> (a -> a)
14:39:37 <monoidal> fizbin: note that while let double f = f . f in double (\x -> [x]) succeeds, seemingly equivalent (\f -> f . f) (\x -> [x]) fails
14:39:53 <monoidal> where I changed double to an anonymous function
14:40:20 <monoidal> whoops! sorry, big typo, ignore that
14:41:48 <fizbin> Huh. With RankNTypes and an appropriate type for double it works.
14:41:51 <fizbin> let double :: (forall a. a -> m a) -> a -> m (m a); double f = f . f in (double (\x -> [x])) 3
14:41:59 <c_wraith> yes, with RankNTypes it does
14:42:00 <dmwit> fizbin: It gets even worse. let double :: (forall a. a -> [a]) -> a -> [[a]]; double f = f . f in double (\x -> [x]) works.
14:42:04 <fizbin> λ: let double :: (forall a. a -> m a) -> a -> m (m a); double f = f . f in (double (\x -> [x])) 3
14:42:04 <fizbin> [[3]]
14:42:15 <dmwit> dang, too slow
14:42:39 <c_wraith> I'm telling you, where it works has to do with what types are inferred. And only rank-1 types are inferred.
14:43:50 <Cale> monoidal: fsvo "seemingly equivalent"
14:44:45 <fizbin> Okay, so the problem is that "double" needs a more expansive type than can be inferred. I'm not sure that (forall a. a -> m a) -> a -> m (m a) is really quite as general as it could be.
14:44:56 <monoidal> Cale: that sentence was a big slip of a pen anyway, somehow I thought that works
14:45:33 <monoidal> fizbin: it isn't general. For one, this type is incomparable with (a -> a) -> a -> a.
14:45:55 <dmwit> It's general, if m is allowed to take on sufficiently general type-level functions. =)
14:46:37 <dmwit> For example, in a dependently typed language that type would specialize to (a -> a) -> a -> a just fine.
14:46:51 <c_wraith> where m = type-level id?
14:46:59 <dmwit> right
14:48:04 <Cale> dmwit: This can make typeclasses in coq really annoying :P
14:48:32 <monoidal> fizbin: define singleton x = [x]. Do you see that while singleton . singleton typechecks, (\f -> f . f) singleton does not?
14:50:28 <dmwit> Does naming that function really help?
14:51:15 <monoidal> dmwit: I wanted to avoid writing (\x -> [x]) . (\x -> [x])
14:51:34 <Cale> If you write explicit type applications, it might be clearer why.
14:58:28 <merijn> Bleh...someone tell me something quick and fun to hack while I'm stuck waiting on people to answer my questions
14:58:38 <djahandarie> A tree
14:59:27 <acowley> merijn: An elegant cross-platform GUI library
14:59:56 <hpaste_> fizruk pasted “No instance for Num (Vector Double)” at http://hpaste.org/87928
14:59:56 <geekosaur> *snrk*
15:00:17 * djahandarie notes that he still needs to work on his pun skills
15:00:23 <yitz> merijn: a better SAT solver for cabal
15:01:15 <dcoutts_> merijn: a better approach to producing error messages from the existing constraint solver for cabal
15:01:27 <merijn> Those don't sound like short
15:01:33 <dcoutts_> :-)
15:01:34 <merijn> acowley: Ironically, I was working on that
15:01:40 <geekosaur> that's why I snerked
15:01:51 <dcoutts_> merijn: ok, shorter: implement zsync so we can use it for cabal update? :-)
15:02:02 <merijn> acowley: But then I got stuck, because mm_freak has a life and is thus not answering my questions :p
15:02:08 <yitz> merijn: if you promise to work on them, i'll try to help delay people from answering your questions
15:02:13 <fizruk> Hi! Why can't ghc find an instance of Num (Vector Double)? Vector is from hmatrix-0.14.1.0  http://hpaste.org/87928
15:06:25 <dcoutts_> merijn: how short?
15:06:25 <merijn> fizruk: Why would it find one?
15:06:25 <merijn> dcoutts_: It's 23:00 and I have work tomorrow short? ;)
15:06:26 <dcoutts_> ah
15:06:26 <dcoutts_> tricky
15:06:26 <fizruk> merijn: there is one here -> http://hackage.haskell.org/packages/archive/hmatrix/latest/doc/html/Data-Packed-Vector.html
15:06:26 <Zenol> dmwit> I was asking that because the main cost of the application are mcti, opcodeCycleCount and and an other function that look at the first element of the triplet of mcti.
15:06:29 <merijn> Alternatively I could just go back to browsing reddit and wasting my life away...
15:06:34 <dcoutts_> merijn: ah, here's an easier one: design (but don't implement) a more sensible system for keeping download counts in the new hackage-server
15:06:34 <Zenol> dmwit> mcti make a pattern matching (like a big C switch) on the opcode (a Word value 0x??) and give the good triplet associated. I don't see how it can be a smaller/more simple function.
15:06:36 <otters> so I've been getting this from cabal since I ran apt-get upgrade earlier today: eventfd: unsupported operation (Function not implemented)
15:06:36 <otters> has this happened to anyone else?
15:06:37 <otters> I'm on debian 7.0
15:06:39 <Zenol> dmwit> (Anyway, hello :))
15:06:41 <dcoutts_> merijn: requires a bit of thought, how much info do we need to keep, how should we store it, what stays in memory, what goes out on disk etc
15:07:24 <Cale> lispy: Almost everything seems to take a long time to run on the linode.
15:08:22 <Cale> er, well, that's not entirely true...
15:09:11 <otters> I can find this error in exactly one other place on the internet, which is an IRC log
15:09:12 <otters> nice
15:10:09 <otters> I guess there's been a kernel API change or something
15:10:09 <Cale> hmm
15:10:13 <Fuuzetsu> is it an IRC log from #haskell
15:10:26 <Cale> If I remove the +RTS -N2 -RTS from the mueval commandline, it works
15:10:32 <otters> Fuuzetsu: it's from #darcs
15:10:40 <Fuuzetsu> Close enough.
15:10:49 <Cale> Maybe there's something broken about this virtual machine's multicore support.
15:10:55 <Fuuzetsu> You could try poking there.
15:13:20 <dcoutts_> otters: it is a bit strange, eventfd is relatively old now, so especially if you just upgraded then your kernel should have it
15:13:53 <otters> hang on a second, I'm actually using jessie, not wheezy
15:14:07 <otters> what the hell?
15:17:10 <otters> maybe I should reboot
15:17:17 <otters> but this box is running ZNC :|
15:20:43 <mekeor> how can i write a function (:: [Either ErrorType Result] -> Either ErrorType [Results]) which either returns the first ErrorType in the list, or, if there's no ErrorType in the list, the list of Results?  – if i'd use Data.Either.partitionEithers, would it first collect the whole list of ErrorTypes if there are several?
15:21:32 <mekeor> s/'[Results]'/'[Result]'/
15:22:02 <shachaf> sequence
15:22:23 <otters> I do not like this
15:22:32 <otters> I ran dist-upgrade and installing GHC is still failing
15:22:42 <mekeor> shachaf: i tried it but i couldn't find out how to use it exactly =D
15:22:57 <mekeor> otters: debian? unstable?
15:22:58 <monoidal> > sequence [Right 2, Left "error", Right 1]
15:23:05 <shachaf> lambdabot is gone.
15:23:07 <otters> mekeor: yeah, apparently that's a thing
15:23:15 <shachaf> But sequence :: [Either a b] -> Either a [b]
15:23:17 <johnw> > bringBackLambdabot
15:23:23 <monoidal> ah, no lambdabot. mekeor: try that example and "sequence [Right 2, Right 3]"
15:23:25 <shachaf> It's literally the function you asked for.
15:23:28 <mekeor> shachaf: aah, so i have to use a type signature?
15:23:30 <shachaf> No.
15:23:34 <shachaf> Well, maybe.
15:23:35 <shachaf> Probably not.
15:23:56 <otters> maaaaan, what am I gonna do now
15:24:01 <mekeor> it doesn't work like you said, i already had tried that
15:24:31 <shachaf> "doesn't work" is not a useful thing to say.
15:24:37 <monoidal> mekeor: old GHC? maybe import Control.Monad.Instances
15:24:48 <hpaste_> mekeor pasted “error” at http://hpaste.org/87931
15:24:57 <otters> I get "Pattern match failure in do expression at libraries/base/GHC/Event/Thread.hs" if I try to run already compiled binaries
15:24:59 <shachaf> That's more useful.
15:25:06 <shachaf> Now you can read monoidal's answer. :-)
15:25:07 <mekeor> monoidal: did it
15:25:10 <otters> Thread.hs:84:3-10 actually
15:25:18 <mekeor> monoidal: yeah, Control.Monad.Instances
15:25:35 <mekeor> shachaf: :D
15:26:15 <mekeor> monoidal: so with new GHCs you don't need this?
15:26:41 <mekeor> monoidal: so, base was re-structured??
15:26:58 <monoidal> mekeor: the instances are now in Prelude, you need not export them
15:27:02 <monoidal> *need not import them
15:27:11 <mekeor> cool
15:27:16 <monoidal> mekeor: if you use GHC <= 7.2, it might be a good time to upgrade
15:27:38 <mekeor> monoidal: uhm, 7.4.1, actually...
15:27:53 <monoidal> mekeor: ah, right. So it was moved in 7.6.
15:27:54 <mekeor> but base-4.5.0.0
15:28:04 <monoidal> base is tied to GHC
15:28:10 <mekeor> yea
15:28:36 <mekeor> otters: so, you're using debian-unstable and the upgrade of ghc (to 7.6?) didn't work?
15:28:59 <mekeor> otters: i did not try to upgrade by now. do you recommend me to not try it? O.o
15:29:34 <otters> yeah, I recommend that
15:29:47 <mekeor> otters: but i want ghc-7.6 :D
15:29:57 <mekeor> otters: what's the problem?
15:30:04 <mekeor> otters: what's the error?
15:30:51 <otters> oh, it's apparently some kind of API change in the kernel
15:31:08 <mekeor> dafuq
15:31:14 <otters> eventfd: unsupported operation (Function not implemented)
15:31:27 <otters> I'm downgrading to stable now
15:31:38 <mekeor> dafuq
15:31:49 <otters> yeah, it's everywhere
15:31:59 <mekeor> why not downgrade to testing?
15:32:17 <mekeor> stable is like stone age
15:32:18 <otters> cause I forgot it exists
15:32:32 <mekeor> :O
15:33:40 <elliott> otters: didn't you say you were on jessie?
15:33:45 <elliott> testing is jessie, since a debian release happened.
15:34:00 <otters> well, I don't know about all this
15:34:07 <otters> my sources.list specified sid
15:34:30 * mekeor hates all this nicknames..
15:34:43 * mekeor just says stable, testing, unstable, experimental..
15:40:12 <otters> why does the ghc package depend on java-common?
15:41:25 <dsturnbu1l> probably because debian is the worst
15:42:06 <otters> oh, huh
15:42:09 <otters> downgrading didn't help
15:42:13 <otters> looks like I might have to restore
15:46:15 * hackagebot stm-conduit 2.0.0 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.0.0 (ClarkGaebel)
15:48:28 <mekeor> b
15:48:36 <mekeor> oops sorry
15:50:08 <ion> c
15:51:55 <jeremy_c> When writing programs in Haskell, is it pretty much given that your main function is going to be do statement? i.e. parse command line arguments, parse a file and output it's contents?
15:52:36 <shachaf> There is no such thing as a do statement. Only a do expresion.
15:53:02 <shachaf> Usually main = do { ... }. Sometimes it's not, but then it's usually = to something else that is.
15:53:05 <shachaf> At any rate it's an IO action.
15:53:23 <jeremy_c> shachaf: I was not sure what do call it, Learn You A Haskell, introduced it as do syntax.
15:53:24 <mgsloan> do or do not, there is no try
15:53:38 * mekeor has some "main = foo >>= bar"
15:54:07 <mgsloan> (although there actually is a try function)
15:54:20 <shachaf> jeremy_c: Anyway, the short answer is that probably yes. But also that "do" isn't magic, it's just a bit of syntax sugar.
15:55:58 <jeremy_c> shachaf: OK, that makes me feel better about what I am learning, today is my first day with Haskell, just skimming sections of Learn You a Haskell for Great Good. I'm just about done skimming and going to go back and start actually reading it... unless there is a suggestion here about a better way to learn Haskell?
15:56:34 <shachaf> Reading it is fine.
15:56:42 <mekeor> jeremy_c: do you know other (functional) languages?
15:56:45 <monoidal> jeremy_c: reading LYAH cover-to-cover is IMO a good way to learn.
15:57:06 * mekeor agrees that LYAH is great
15:57:23 <monoidal> jeremy_c: while reading, you can keep GHCi, paste the code from the book or try variants/experiments
15:57:43 <jeremy_c> mekeor: "know?" not really, I can create simple programs in OCaml, but wouldn't list it as a skill set.
15:58:04 <mekeor> jeremy_c: nice. read lyah.
15:58:11 <mekeor> :)
16:03:15 <HugoDaniel> im starting to love literate haskell
16:03:36 <HugoDaniel> its great to have support for it
16:31:47 <joe9>  is there any thing in haskell to show the expected type of a function, similar to how agda/type show the required type of the function with a ?<variable>
16:32:02 <elliott> you can do ?foo with the ImplicitParams extension as a hack.
16:32:05 <elliott> it's not intended for that but it works okay.
16:32:29 <joe9> elliott: cool, in the ghci prompt, too?
16:33:18 <geekosaur> :set -XImplicitParams
16:33:53 <elliott> joe9: yes, per geekosaur
16:36:49 <joe9> any thoughts on what I am missing, please? http://codepad.org/udxRhkud
16:37:04 <Cale> @bot
16:37:12 <lambdabot> :)
16:37:14 <Cale> > 1
16:37:26 <lambdabot>   1
16:37:29 <joe9> I cannot figure out how to pipe a function with output of IO Obstructions to a state function with Obstructions as input.
16:37:50 <dmj> @unmtl MaybeT (State s) a
16:37:56 <lambdabot> s -> (Maybe a, s)
16:38:00 <Cale> joe9: lift
16:38:09 <shachaf> What is a state function?
16:38:10 <Cale> :t lift
16:38:22 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
16:38:29 <Cale> (lambdabot is probably still joining channels)
16:38:47 <Cale> joe9: So, if m = IO, and t = StateT Obstructions
16:38:58 <Cale> then lift :: IO a -> StateT Obstructions IO a
16:39:20 <Cale> joe9: Is that what you're looking for?
16:39:27 <joe9> cale, thanks. that helps.
16:40:01 <Cale> joe9: The arguments to >>= must always involve a fixed chosen monad
16:40:31 <joe9> it works, cool. http://codepad.org/j4ifEuH5 cale, geekosaur : thanks.
16:40:34 <Cale> i.e. if  x :: IO a, then when you write  x >>= f  then f had better be a function of type  a -> IO b
16:41:22 <joe9> Cale, got it. thanks. this is my first usage with State and I was getting confused.
16:41:39 <shachaf> (>>=) :: m a -> ContT IO m b
16:41:46 <shachaf> Well, I guess Codensity is better than ContT there.
16:43:20 <shachaf> (Not really related to what joe9 was saying.)
16:43:39 <Cale> So, there's something wrong with the SMP support on the machine that lambdabot is running on
16:44:08 <Cale> removing the +RTS -N2 -RTS made mueval not fail
16:44:32 <Cale> (at least, it's not failing as much now, I can't really say that it won't)
16:44:59 <Cale> It looks like there's 8 cores looking at /proc/cpuinfo
16:45:55 <Cale> But it seems like any program that tries to use them dies. mueval actually wasn't timing out, or at least, it wasn't hitting the time limit that I was giving it.
16:47:54 <elliott> nice
16:48:39 <vermeille> Hey guys :)
16:50:02 <vermeille> I have a simple question, is that possible to define "operator overloading" (implementation of I-don't-remember-which-typeclass) so that we can have things like "Vector2D + Int" and "Vector2D + Vector2D" ?
16:51:14 <shachaf> You can define a (+) function that would work for both of those. But it wouldn't be Num's (+), and you probably shouldn't do it.
16:51:18 <shachaf> Just use two different names.
16:51:27 <blaenk> hey guys is there a good url sanitizing method out there, for example for post slugs in a blog, not necessarily url-escaping
16:51:39 <blaenk> so like "I'm here" would maybe become "im-here"
16:51:52 <shachaf> By the way: You can't add types. Writing "Int + Int" is an abuse of notation if you're talking about adding two values of type Int.
16:53:10 <vermeille> Obviously shachaf, it's an abuse of notation, but you understood me well :)
16:54:04 <vermeille> In fact, is that possible to define "(+) :: Vector2D -> Int -> Vector2D" *and* "(+) :: Vector2D -> Vector2D -> Vector2D" ?
16:55:51 <vermeille> I'm just looking for a convenient way to write basics maths for a game engine
16:56:10 <Cale> vermeille: What does adding an Int to a Vector2D do?
16:56:15 <shachaf> Just use two names.
16:58:17 <rgrinberg> agreed just use normal addition
16:58:26 <monochrom> Cale: I propose that the computer that runs lambdabot is made in China, i.e., it has fake parts, e.g., 1 CPU purporting to be 8 CPUs. there is an instance in the real world of a GB flash memory chip plus dead weight in deceptive casing purporting to be a TB hard disk
16:58:27 <rgrinberg> and a function that turns your const into a vector
16:58:41 <vermeille> Cale: it's just a convenient shortcut to add to its both members. For a real issue, consider multiplying a vector and a scalar, and two vectors, which can be dot or scalar product
16:58:56 <rgrinberg> so then x + (const 5)
17:01:26 <vermeille> const ?
17:01:33 <lispy> :t const
17:01:39 <lambdabot> a -> b -> a
17:01:43 <lispy> > const 1
17:01:48 <lambdabot>   mueval: ExitFailure 1
17:01:48 <lambdabot>  mueval: Prelude.undefined
17:01:52 <blaenk> haha
17:01:56 <lispy> lambdabot: why you no work?
17:02:01 <vermeille> > const 1 undefined
17:02:06 <lambdabot>   mueval: ExitFailure 1
17:02:06 <lambdabot>  mueval: Prelude.undefined
17:02:09 <lispy> Cale: Is something up with lambdabot lately?
17:02:17 <lispy> Cale: (maybe I can help)
17:02:19 <latro`a> wat.
17:02:22 <geekosaur> very
17:02:51 <mgsloan> > x ^ y
17:02:57 <lambdabot>   mueval: ExitFailure 1
17:02:57 <lambdabot>  mueval: Prelude.undefined
17:03:02 <Cale> lispy: Running mueval with +RTS -N2 -RTS causes it to always fail
17:03:07 <Cale> > 1
17:03:07 <latro`a> apparently everything is undefined
17:03:12 <lambdabot>   mueval: ExitFailure 1
17:03:12 <lambdabot>  mueval: Prelude.undefined
17:03:16 <Cale> oh, maybe that's not it
17:03:19 <Cale> hah
17:03:24 <Cale> Well, I don't know
17:03:27 <sipa> @undef
17:03:33 <Cale> > 1
17:03:35 <monochrom> ok! even the 1 CPU is fake :)
17:03:37 <lambdabot>   1
17:03:44 <Cale> > x^y
17:03:45 <sipa> > const 1
17:03:49 <lambdabot>   mueval: ExitFailure 1
17:03:49 <lambdabot>  mueval: Prelude.undefined
17:03:50 <lambdabot>   mueval: ExitFailure 1
17:03:50 <lambdabot>  mueval: Prelude.undefined
17:03:54 <sipa> :(
17:03:59 <sipa> it's too complex for her
17:04:01 <monochrom> this is probably a cheap ARM chip purporting to be a pricy Intel chip :)
17:04:04 <Cale> It's definitely not waiting the entire length of the timeout before failing
17:04:10 <Cale> The timeout is 10 seconds long
17:04:47 <elliott> can it be made just -N1 temporarily?
17:04:47 <joe9>  monad transformers are getting complicated. I read about Effects and how they help in idris. Is that available in haskell too?
17:04:51 <Cale> elliott: It is
17:04:54 <Cale> elliott: I changed it
17:04:56 <elliott> hm
17:04:58 <elliott> but it isn't working?
17:05:02 <Cale> Which improved things a bit
17:05:05 <lispy> Cale: Have you restarted her? Does it just start happening again?
17:05:12 <Cale> It seems to be responding to *some* requests now
17:05:18 <Cale> lispy: I even recompiled
17:05:30 <Cale> > product [1..100]
17:05:35 <lambdabot>   mueval: ExitFailure 1
17:05:36 <lambdabot>  mueval: Prelude.undefined
17:05:36 <Cale> > product [1..100]
17:05:42 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
17:05:51 <lispy> joe9: the idris material on Effects is pretty new and I haven't heard of a Haskell port.
17:05:56 <Cale> I also noticed weird slowness when starting vim about half the time
17:06:16 <Cale> and doing a  cabal update  took a really long time
17:06:22 <Cale> (even for cabal update)
17:06:35 <joe9> lispy: thanks.
17:06:39 <Cale> I think it took something like 5 minutes to finish
17:06:49 <Ghoul_> @pl (\t -> BS.append (bWord16 $ fromIntegral (T.length t)) (encodeUtf16BE t))
17:06:50 <lambdabot> ap (BS.append . bWord16 . fromIntegral . T.length) encodeUtf16BE
17:06:55 <joe9> lispy: they seem really cool. not sure how they translated to practical usage. any thoughts, please?
17:07:07 <lispy> Cale: okay. That's worrisome. I should possibly reboot the VM.
17:07:31 <lispy> joe9: I know of the document you're talking about, but I haven't found time to read it yet :(
17:07:39 <Ghoul_> Is there an operator for ap ?
17:07:43 <Ghoul_> That looks a little neater
17:07:46 <elliott> there is http://hackage.haskell.org/package/effects
17:07:50 <elliott> it's not really something you'd use in practice
17:07:52 <elliott> Ghoul_: (<*>)
17:08:06 <Ghoul_> Ah, so (BS.append . bWord16 . fromIntegral . T.length) <*> encodeUtf16BE -- is equivalent? :)
17:09:28 <vermeille> is the source code of Carmack's Wolfeinstein 3D available ?
17:10:43 <Ghoul_> @pl (\len -> getByteString (fromIntegral len * 2))
17:10:43 <lambdabot> getByteString . (2 *) . fromIntegral
17:10:44 <lispy> vermeille: I don't think his Haskell code has been posted, but of course the original wolf3d source is GPL
17:11:15 <vermeille> I don't care about the original :) I would like to see the Haskell implementation :p
17:11:36 <c_wraith> He probably will ask for code reviews when he finally gets it working.
17:11:36 <lispy> vermeille: this is there github page: https://github.com/id-Software
17:11:41 <c_wraith> That seems like his style
17:11:51 <lispy> their*
17:11:56 <Ghoul_> @pl decodeUtf16BE =<< (getByteString . (2 *) . fromIntegral) =<< getWord16be
17:11:56 <lambdabot> decodeUtf16BE =<< getByteString . (2 *) . fromIntegral =<< getWord16be
17:11:58 <joe9> lispy, I get lost with proofs. have no clue how they work. that has been keeping me back regarding using idris seriously.
17:12:01 <Ghoul_> Oh, good.
17:12:31 <lispy> joe9: you might try agda or coq as they are more mature (and better documented) and have a similar foundation
17:12:46 <lispy> then try idris once the core concepts are cemented
17:13:34 <lispy> Cale: my guess would be that swap is making life miserable
17:14:27 <vermeille> Great ! Thanks lispy!
17:15:01 <johnw> lispy!
17:15:06 <lispy> johnw: hi
17:15:12 <johnw> lispy: do you use Orc?
17:15:24 <lispy> No, but I sit next to one of the authors :)
17:15:50 <Ghoul_> Anyone know the operator precedence of . ?
17:15:57 <Ghoul_> ie: in f . f2
17:16:19 <lispy> Prelude λ> :info (.)
17:16:19 <lispy> (.) :: (b -> c) -> (a -> b) -> a -> c   -- Defined in `GHC.Base'
17:16:19 <lispy> infixr 9 .
17:16:22 <glguy> Ghoul_: type :i .
17:16:24 <glguy> in your GHCi
17:16:35 <Ghoul_> oh, cool
17:17:04 <johnw> lispy: tell him I said hi
17:17:38 <lispy> johnw: He says hello
17:17:43 <lispy> johnw: are you using Orc?
17:17:55 <johnw> no, but I read the Orc paper night before last
17:18:10 <johnw> i like that it's really just "a concurrent List monad"
17:18:21 <johnw> and the "cut" stuff is very neat
17:18:50 <lispy> Yeah, it's a pretty cool abstraction. For whatever reason, I just haven't needed it for anything yet.
17:19:15 <johnw> i was wondering if edwardk's speculative package couldn't be easily expressed using Orc
17:19:19 <johnw> speculation
17:30:03 <shachaf> Cale: lambdabot is still not evaluating things.
17:30:05 <mm_freak> @tell merijn i'm not sure if that's a proper category, but it is certainly sensible…  a much healthier construction is to use a transformer like this:  newtype NonDet c a b = NonDet (a `c` [b])…  that one is easier to prove
17:30:06 <lambdabot> Consider it noted.
17:30:08 <shachaf> Did you say you'd fixed it before?
17:30:26 <Cale> shachaf: thought I might've
17:30:39 <Cale> shachaf: But the machine it's running on is flaking out
17:30:52 <shachaf> > over (partsOf (traverse.filtered (`notElem`"aeiou"))) reverse "turn"
17:30:54 <Cale> shachaf: like, vim takes a while to load half the time, for example
17:30:57 <lambdabot>   mueval: ExitFailure 1
17:30:57 <lambdabot>  mueval: Prelude.undefined
17:31:18 <Cale> and it's definitely dying without waiting for the time limit
17:31:29 <lispy> Cale: how about I reboot?
17:31:37 <mm_freak> @tell merijn Wire used to be a category transformer, but that didn't really prove to be useful the way it was defined…  now i have a simpler construction in mind, which will in fact be based on Auto
17:31:37 <lambdabot> Consider it noted.
17:31:56 <lispy> Cale: Do you need any time to shut anything down?
17:32:09 <Cale> lispy: nope
17:32:22 <Cale> @flush
17:32:26 <Cale> maybe should do that though :)
17:32:28 <lispy> k
17:36:42 <monochrom> Cantonese idiom: "what's the hurry? are you hurrying to reincarnate?"  explanation: you have to die before you can reincarnate. therefore, the idiom means: are you hurrying to die?
17:37:04 <monochrom> apparently, the idiom applies to lambdabot :)
17:45:04 <blaenk> these types: data Blah = Blah { ex :: Type, ex2 :: Type2 }
17:45:24 <blaenk> have always confused me. right now I have 3 of those, I guess they're called data extracters?
17:45:34 <blaenk> ghc is giving a warning saying I'm only ever using the first one
17:45:43 <blaenk> my question is, how then would I specify this?
17:45:50 <shachaf> They're called selectors.
17:45:54 <blaenk> oh okay thanks
17:45:59 <johnw> lispy: https://gist.github.com/5572758
17:46:01 <shachaf> Specify what?
17:46:17 <blaenk> I want data Blah a b c, but I want an extracter only for the a
17:46:30 <shachaf> You can't do that.
17:46:38 <blaenk> right, so I defined an extractor for each field
17:46:46 <blaenk> selector sorry
17:46:52 <mauke> you can write a function
17:47:01 <blaenk> oh, duh haha
17:47:04 <shachaf> A function will work (though it won't work for setting).
17:47:06 <shachaf> You can export them and then GHC won't complain that they're unused.
17:47:13 <blaenk> awesome thanks
17:48:24 <acowley> Or you can prefix the names with an _
17:48:24 <blaenk> ohh
17:48:26 <shachaf> Ah, maybe that works.
17:49:19 <blaenk> nah, parser error
17:49:19 <blaenk> oh wait
17:49:22 <dcoutts_> blaenk: for the most part, it's just syntactic sugar,  data Blah = Blah { ex :: Type, ex2 :: Type2 }  is equiv of:  Data Blah Type Type2; ex (Blah x _) = x; ex2 (Blah _ x) = x
17:49:27 <blaenk> yeah it works!
17:49:46 <dcoutts_> blaenk: the extra thing that record selectors give you is record update syntax
17:50:01 <dcoutts_> blah { ex2 = thing }
17:50:15 <dcoutts_> and record patterns
17:50:47 <blaenk> dcoutts_: thanks, sec phone
17:50:53 <dcoutts_> oops, data Blah = Blah Type Type2
17:51:54 * dcoutts_ has to disappear
17:53:26 <blaenk> dcoutts_: ah yeah, thanks a bunch
18:00:07 <thetallguy1> anyone know where I can find a write up of the semantics of ghc DefaultSignatures?
18:01:49 <geekosaur> aside from the one in the manual?
18:02:07 <thetallguy1> I can't find the one in the manual
18:02:17 <thetallguy1> google keeps taking me to one that is out of date, I think
18:02:29 <thetallguy1> maybe I should search by ghc version number
18:03:17 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#class-default-signatures
18:05:38 <thetallguy1> yeah, that's what I was reading
18:05:44 <thetallguy1> seems a little weak
18:21:29 <monochrom> w00t haskell platform RC!
18:21:40 <u_> http://pastebin.com/X5fSxYgB
18:21:46 <mauke> The paste X5fSxYgB has been copied to http://hpaste.org/87936
18:21:58 <u_> trying to install chart
18:22:04 <monochrom> oh wait, it targets GHC 7.6.3?!
18:22:10 <u_> requires gtk and gtk2hs-buildtools
18:22:21 <u_> which requires glib
18:22:27 <u_> which won't install and i dunno why :(
18:22:58 <monochrom> for all the talks a few months ago about "oh our schedule is so tight it will be 7.4.2 again"
18:24:27 <u_> says "cannot find gtk2hsC2hs, make sure it's in .cabal/bin" and it definitely is
18:24:51 <dcoutts> u_: and make sure that dir is on your $PATH
18:25:14 <u_> oh
18:25:15 <arkeet> there's a continued-fractions package but it doesn't have anything for turning a Rational or so into a continued fraction =(
18:25:16 <u_> it's not
18:25:18 <u_> how do i add it?
18:26:47 <krzysz00> Is there a `map`-equivalent for Maps? That is, mapMap :: ((k, v) -> (k, v)) -> Map k v -> Map k v ? (Or one with the arguments flipped?)
18:28:22 <krzysz00> Ah. mapMaybe will do.
18:28:25 <geekosaur> several depending on what you want to do?
18:29:54 <monochrom> new libs in new Haskell Platform: attoparsec, case-insensitive,  hashable, unordered-containers
18:30:26 <monochrom> haha, case-insensitive is cute
18:31:19 <monochrom> hashable and unordered-containers will stop all debates on hash table vs search tree!
18:32:35 <dolio> It will?
18:32:36 <elliott> hashable wasn't in already?
18:32:44 <monochrom> also OpenGL and GLUT has much belated version leaps. thank or blame lispy! :)
18:32:50 <monochrom> wasn't
18:33:31 <monochrom> unordered-containers wasn't either
18:42:51 <arkeet> krzysz00: there's also a Functor (Map k) instance
18:43:01 <arkeet> oh, (k,v) -> (k,v). I dunno what that would do.
18:43:15 <arkeet> oh, no lambdabot
18:52:42 <u_> http://hpaste.org/87937
18:52:49 <u_> i added .cabal/bin to PATH
18:52:54 <u_> and now it gives me this instead
18:56:21 <amosr> u_: you might just need to apt-get install glib or something?
18:56:41 <monochrom> if you're on ubuntu, you need these from ubuntu: libgtk2.0-dev libglade2-dev
18:56:46 <u_> on a mac :(
18:56:58 <amosr> maybe homebrew
18:57:04 <amosr> what package are you trying to install?
18:57:09 <u_> Chart
18:57:09 <monochrom> then some version of gtk+ complete with "development files"
18:57:25 <geekosaur> mac package managers don't split devel files from runtime like linux does
18:57:32 <monochrom> it is not enough to just have the gtk+ runtime
18:57:38 <jmcarthur> not all linux distros do that either
18:57:45 <monochrom> oh, that should be nice
18:59:08 <monochrom> does pkg-config work on mac?
18:59:29 <monochrom> I have a cunning plan
18:59:39 <u_> uh
18:59:48 <monochrom> install virtualbox. install ubuntu inside virtualbox...
19:00:09 <u_> i just did brew install gtk
19:01:07 <geekosaur> that will have also installed a pkg-config then
19:06:07 <TheHunter> @version
19:06:34 <copumpkin> whoa, the real TheHunter
19:06:45 <copumpkin> this is unheard-of
19:06:55 <TheHunter> it's been a while, hasn't it?
19:07:10 <copumpkin> I've never even seen you on IRC. I just stole your nick to use your powers on lambdabot :P
19:07:18 <copumpkin> >_<
19:07:48 <TheHunter> where is lambdabot development hosted these days?
19:07:57 <copumpkin> not sure such a thing still exists
19:08:07 <copumpkin> Cale is the closest we have to a maintainer I think
19:08:57 <c_wraith> actually, there's been a lot of dev work on it recently
19:09:00 <monochrom> these two days, the computer that runs lambdabot has a problem. it is now offline for trouble-shooting
19:09:04 <copumpkin> ooh
19:09:22 <c_wraith> there was a thread on -cafe a couple months ago
19:09:31 <c_wraith> about all sorts of work being done
19:09:36 <copumpkin> excellent
19:09:40 <TheHunter> there's lots of activity on mokus_'s github repository, but it has diverged from the darcs repo somewhat
19:09:53 <copumpkin> oh mokus_ is alive too
19:10:07 <copumpkin> man, I'm missing out on everything
19:10:44 <applicative_tmp> u_: I seem to have Chart built with homebrew gtk+ for what it's worth.
19:11:04 <u_> applicative_tmp: aaugh homebrew gtk+ just failed to install
19:11:22 <u_> oh but its just a download connection error
19:11:35 <u_> so there is still hope
19:13:56 <u_> ttp://slackware.sukkology.net/packages/jasper/jasper-1.900.1.zi
19:13:56 <u_> curl: (7) couldn't connect to host
19:15:12 <u_> that website seems to be gone so now i'm trying brew update
19:15:18 <u_> i can barely remember what i was trying to do in the first place
19:18:12 <u_> yup, now it downloads from somewhere else
19:33:06 <monochrom> http://www.vex.net/~trebla/haskell/haskell-platform.xhtml  now updated for the new Haskell Platform still in RC!
19:39:43 <u_> aw
19:39:45 <u_> it didn't work :(
19:42:25 <u_> oh boy
19:42:29 <u_> cairo also fails to install
19:42:34 <u_> pretty sure that's a separate issue
19:42:36 <u_> i'm just gonna give up
19:43:52 <saml> do you use cabal ?
19:44:41 <u_> yeah
19:44:43 <u_> aha! http://hackage.haskell.org/packages/archive/GoogleChart/0.2/doc/html/Graphics-Google-Chart.html
19:44:50 <saml> hackage is down
19:44:54 <saml> oh it's up
19:45:02 <u_> if this doesn't install i am quitting haskell for javascript
19:45:09 <u_> it does
19:45:10 <u_> (duh)
19:45:28 <simpson> u_: Take your time; be patient.
19:45:44 <simpson> Rome was not built in a day, and neither are most applications. :3
19:45:54 <luite> javascript is the best haskell
19:47:50 <monochrom> gtk2hs is not compiled in a day :)
19:50:29 <luite> and if you wait half a year and the gsoc project is accepted and succesful, you can install chart without gtk/cairo \o/
19:57:21 <applicative_tmp> u_: you have the homebrew gtk+, and haskell cairo fails, or you just didn't complete the gtk+ installation
19:58:04 <applicative_tmp> luite: what gsoc scheme is this?
19:58:17 <u_> applicative_tmp: gtk+ installed but glib installed still fails. cairo also fails, which appears to be separate
19:58:39 <u_> *glib installation
19:59:24 <luite> applicative_tmp: plan to port chart to diagrams, so it can be used with the diagrams-svg backend
20:00:43 <applicative_tmp> ah, nice.  chart doesn't seem to be maintained I see ...
20:02:07 <applicative_tmp> u_: well this is annoying, but at least we cab blame homebrew...
20:02:12 <applicative_tmp> can
20:03:11 <applicative_tmp> oh I take back what i said about chart's maintainership...
20:36:32 <deech> Hi all, I see that catch has been removed from the Prelude in 7.6.1. What is the alternative?
20:36:44 <geekosaur> Control.Exception.catch
20:36:59 <deech> geekosaur: Ah, thanks.
20:37:03 <LLckfan> Hello
20:37:04 <LLckfan> Does any1 know how to make the mouse arrow stop moving on its own?
20:37:52 <shachaf> LLckfan: This is still not the channel for those sorts of questions. :-)
20:37:58 <elliott> LLckfan: as you were told last time, this channel is about the Haskell programming language
20:38:46 <mgsloan> LLckfan: I believe that this video will shed some light on that: http://www.youtube.com/watch?v=JfIgzSoTMOs
20:39:16 * geekosaur wonders if that was an xmonad question
20:39:49 <shachaf> geekosaur: Given the earlier questions about Flash, I doubt it.
20:39:53 <elliott> previous questions make that very unlikely
20:40:10 <elliott> shachaf: stop it. you can steal my messages after I send them.
20:47:15 <twoolie> has anyone had any luck building vinyl-0.1.0.0 on GHC 7.6.2?
21:14:05 <sclv> /join #haskell-infrastructure
21:20:14 <Ghoul_> is there an equivalent function to (*2) that is words?
21:20:24 <Ghoul_> like, double, dbl, or something
21:20:35 <shachaf> Why?
21:20:52 <Ghoul_> just wondering
21:21:27 <doomlord> (*)2 for prefix might be neater
21:21:56 <doomlord> i.e. looking more consistent with other currying
21:22:19 <doomlord> oh but then you need to wrap it in parens i guess more often
21:23:06 <amatsu> Would it be possible to pass a mutable state (STRef) around, inside a State monad?
21:23:24 <shachaf> Maybe inside StateT of ST.
21:23:34 <shachaf> You can't (usefully) have STRefs outside of ST.
21:24:31 <amatsu> StateT (STRef s (Map a b) () or something?
21:25:26 <amatsu> hmm, I'm missing the 's' in StateT.
21:25:58 <amatsu> Would wrapping the STRef into a datatype be easier?
21:26:20 <shachaf> You don't have an ST there.
21:26:39 <shachaf> I don't understand that type. Not least because of the unbalanced parentheses.
21:26:39 <amatsu> Oh, right
21:27:44 <amatsu> StateT return_state (ST s mutable_reference) ()
21:27:57 <shachaf> @unmtl StateT return_state (ST s mutable_reference) ()
21:28:01 <shachaf> Er, right.
21:28:14 <shachaf> lambdabot> unmtl StateT return_state (ST s mutable_reference) ()
21:28:14 <shachaf> return_state -> ST s mutable_reference ((), return_state)
21:29:12 <amatsu> alright..
21:29:19 <amatsu> shachaf: thanks, will go off to learn monad transformers
21:29:51 <shachaf> > 1 + 1
21:29:52 <kappabot>   2
21:30:07 <amatsu> we have a new lambdabot?
21:30:25 <shachaf> Just temporary.
21:30:31 <shachaf> @admin + Cale
21:30:42 <shachaf> Cale: Feel free to @quit when lambdabot comes back.
21:30:49 <Cale> oh, right, lispy reset
21:30:54 <shachaf> Oh, you're around.
21:32:03 <Cale> @bot
21:32:03 <kappabot> :)
21:32:11 <lambdabot> :)
21:32:17 <shachaf> > 5^2
21:32:18 <kappabot>   25
21:32:29 <lambdabot>   mueval: ExitFailure 1
21:32:34 <shachaf> Something ought to be Done.
21:32:36 <Cale> lol
21:32:42 <Cale> > 5^2
21:32:43 <kappabot>   25
21:32:53 <lambdabot>   mueval: ExitFailure 1
21:34:13 <Cale> Yeah, this happens just running mueval locally
21:34:28 <shachaf> Cale: It worked once in #-blah
21:34:35 <shachaf> So it looks like it's just really slow.
21:35:19 <Cale> It's weird, it's like mueval is internally enforcing a second time limit or something
21:35:25 <Cale> and it's oddly slow
21:42:02 <Cale> okay
21:42:06 <Cale> I might've fixed it
21:42:11 <Cale> > 5^2
21:42:12 <kappabot>   25
21:42:14 <lambdabot>   25
21:42:16 <Cale> > 5^2
21:42:17 <kappabot>   25
21:42:17 <lambdabot>   25
21:42:19 <Cale> > 5^2
21:42:19 <kappabot>   25
21:42:22 <lambdabot>   25
21:42:34 <shachaf> I wonder why kappabot is so much faster.
21:42:38 <Cale> no idea
21:42:39 <Eduard_Munteanu> Woo, what's that? Did lambdabot get a companion? :)
21:42:55 <luite> @quote stereo
21:42:55 <kappabot> LoganCapaldo says: * LoganCapaldo must resist urge to mention stereo
21:42:56 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
21:43:06 <shachaf> Hmm, this is unmodified lambdabot.
21:43:07 <shachaf> @vixen Did you get a companion?
21:43:07 <kappabot> yes
21:43:07 <lambdabot> Any lady who is first lady likes being first lady. I don't care what they say, they like it.
21:43:18 <Cale> shachaf: kappa comes before lambda, everyone knows that
21:43:26 <Eduard_Munteanu> Nice, we have @vixen.
21:43:27 <shachaf> Cale: Good point.
21:45:21 <Cale> Tyvski is the strangest apparent spelling of Tarski I've ever seen.
21:47:00 <Eduard_Munteanu> I guess the co-Banach-Tarski theorem says you can halve the volume?
21:47:21 <Eduard_Munteanu> (that should be interesting too)
21:47:51 <shachaf> According to the Banach-Tarski theorem, you can halve your cake and eat it too.
21:48:34 <blackdog> shachaf: *applause*
21:49:22 <shachaf> blackdog: This is a recycled pun:
21:49:23 <shachaf> 11:34 <ousado> I found this to be a very nice informal intro: "Some of the best things in life are free; and some are not. Truth is free. Having proved a theorem, you may use this proof as many times as you wish, at no extra cost. Food, on the other hand, has a cost. Having baked a cake, you may eat it only once. If traditional logic is about truth, then linear logic is about food"
21:49:29 <shachaf> 11:35 <shachaf> Unless you're Zeno.
21:49:32 <shachaf> 11:35 <shachaf> Zeno knew how to halve his cake and eat it too.
21:49:54 <Eduard_Munteanu> Heh.
21:50:31 <newsham> schachaf: and linear logic?
21:50:49 <Eduard_Munteanu> Now that's a recycled pun. :)
22:00:09 <amatsu> shachaf: State (ST s memo) return_value wouldn't work?
22:00:24 <shachaf> amatsu: I don't know what that means.
22:00:35 <shachaf> kappabot: @unmtl State (ST s memo) return_value
22:00:35 <kappabot> ST s memo -> (return_value, ST s memo)
22:00:45 <shachaf> This is probably not what you're after.
22:01:06 <shachaf> You should understand how ST and State work reasonably well before trying to mix them. I'm not sure what you're after here.
22:03:30 <amatsu> shachaf: I'm trying to implement a mutable map (a memoised table) that I can thread between some different functions. Threading the pure Map in the State monad seems to slow the algorithm down significantly.
22:42:59 <m3ga> @hoogle PerhapsT
22:42:59 <kappabot> A Hoogle error occurred.
22:43:00 <lambdabot> No results found
22:43:30 <lispy> m3ga: that's something they defined themselves
22:43:52 <lispy> m3ga: http://web.engr.oregonstate.edu/~erwig/pfp/
22:44:05 <m3ga> lispy: thanks
22:44:27 <lispy> m3ga: also http://www.randomhacks.net/articles/2007/02/21/refactoring-probability-distributions
22:45:03 <m3ga> lispy: yeah, thats what i'm reading. is pfp not cabal installable?
22:45:46 <lispy> m3ga: it may predate hackage :(
22:47:44 <AfC> When _was_ Hackage estabished?
22:50:52 <lispy> AfC: october 2007 I think? http://hackage.haskell.org/trac/hackage/wiki/HackageDB/History
22:51:06 <doomlord> how do i convert a Float->GLfloat .. can't find anything in hoogle... i tried (myFloat::GLfloat) but i think thats for literals?
22:51:20 <shachaf> realToFrac?
22:51:23 <lispy> it might have been a bit before that
22:54:15 <doomlord> ok so GLfloat is a "Foreign.C.Types.CFloat" ..   is my question Float -> CFloat
22:54:53 <shachaf> My answer is the same.
22:55:33 <mzero> is realToFrac slow?
22:55:34 <lambdabot> mzero: You have 1 new message. '/msg lambdabot @messages' to read it.
22:55:53 <shachaf> One would hope that it'll get compiled into nothing in this situation.
22:55:55 <lispy> mzero: yes (unless a rewrite rule fires that makes it fast again)
22:56:30 <lispy> and this could be a case where it is fast
22:56:51 <lispy> GHC has some nice rules for going between CFloat and Float (same with CDouble/Double)
22:57:22 <shachaf> lispy: Why do you need a rewrite rule?
22:58:57 <lispy> shachaf: there are a few nice instances of that class, but if you have a newtype then it tends to be crap
23:04:06 <glguy> There are rules that rewrite realToFrac on Float->CFloat to Float->Float and there is a rule from Float->Float to id
23:04:18 <glguy> so that it doesn't have to go through a rational
23:04:28 <shachaf> Ah, I remember now.
23:05:56 <shachaf> > toRational (0/0)
23:05:56 <kappabot>   (-2696539702293473861593957786183537100426965468413459859101451217365990137...
23:06:01 <lambdabot>   mueval: ExitFailure 1
23:06:01 <lambdabot>  mueval: Prelude.undefined
23:06:12 <shachaf> kappabot: @run (fromRational . toRational) (0/0) :: Float
23:06:13 <kappabot>   -Infinity
23:06:22 <shachaf> kappabot: @run realToFrac (0/0) :: Float
23:06:23 <kappabot>   -Infinity
23:06:27 <lispy> is lambdabot acting any better? (doesn't look like it)
23:06:29 <glguy> ?type ()
23:06:30 <kappabot> ()
23:06:33 <lambdabot> ()
23:06:39 --- mode: ChanServ set +o glguy
23:06:46 --- mode: glguy set +q lambdabot!*@*
23:06:54 <glguy> ?type ()
23:06:55 <kappabot> ()
23:07:12 --- mode: glguy set -o glguy
23:09:46 <amiller> what are the most popular affine linear languages
23:09:50 <amiller> like for counting polynomial time reductions
23:12:08 <DigitalKiwi> ahhh man i missed glguy
23:32:44 <doomlord> is there anything like "toFloat"  or C++ (float) casting..
23:33:04 <shachaf> I think the answer is the same as before.
23:33:04 <lispy> you probably want fromIntegral
23:33:12 <shachaf> Well, it depends on what you're doing.
23:33:16 <shachaf> But Haskell has no casting.
23:33:46 <doomlord> i have a weird situation... i get 'realToFrac' working for 2 of 3 parameters - but these come from destructuring a type which is a tuple of identical members
23:34:28 <doomlord> if i use x,y it works.. if I use x,y,z it starts telling me about ambiguous types :(
23:34:31 <lispy> ?hoogle Int -> Float
23:34:31 <kappabot> A Hoogle error occurred.
23:34:34 <Fuuzetsu> Morgawr: I didn't know you started using Haskell.
23:34:48 <doomlord> i'm not using ints - i'm trying to get from Float -> GLfloat
23:35:04 <Morgawr> Fuuzetsu: I played around with it a bit, then moved to Clojure to get myself more accustomed to functionl programming. As soon as I get some free time again I'll try to move back to Haskell for good :)
23:35:26 <lispy> > realToFrac :: Float -> GLFloat -- I bet GLFloat is not in scope...
23:35:27 <kappabot>   Not in scope: type constructor or class `GLFloat'
23:35:37 <lispy> doomlord: what version of openglraw?
23:35:47 <doomlord> how do i check the version
23:35:52 <shachaf> @ty realToFrac :: Float -> Double
23:35:52 <kappabot> Float -> Double
23:35:58 <doomlord> its possibly version related since something broke after a re-install
23:36:23 <lispy> doomlord: Well, we changed the meaning of GLFloat at some point
23:36:39 <lispy> what does cabal-dev ghc-pkg list say?
23:36:42 <doomlord> that explains things, this code worked some time ago
23:36:55 <lispy> IIRC, GLFloat = CFloat now
23:37:14 <lispy> (eg., a type GLFloat = CFloat instead of newtype)
23:37:47 <lispy> when it was a newtype it was easy to miss out on optimizations and there was very little benefit
23:38:06 <doomlord> GLURaw   1.3.0.0
23:38:26 <lispy> doomlord: http://www.haskell.org/pipermail/hopengl/2012-October/001097.html
23:38:29 <Fuuzetsu> Morgawr: Ew, Clojure.
23:39:09 <hpaste_> “Dharmender Kumar” pasted “BFY provide fitness courses in mumbai” at http://hpaste.org/87943
23:39:11 <lispy> doomlord: GLURaw is different
23:39:30 <Morgawr> Fuuzetsu: it's good, I like it. Too bad for JVM
23:39:35 <lispy> @ty realToFrac :: Float -> CFloat
23:39:36 <kappabot>     Not in scope: type constructor or class `CFloat'
23:39:36 <kappabot>     Perhaps you meant `Float' (imported from Prelude)
23:39:55 <doomlord> OpenGLRaw-1.3.0.0
23:40:12 <lispy> yeah, so that has the definition I expected
23:40:16 <Fuuzetsu> Why not go with A Proper Lisp™ instead?
23:40:26 <lispy> I think this boils down to converting from Float to CFloat
23:40:32 <lispy> and that should work fine with realToFrac
23:40:46 <lispy> (as in, there shouldn't be any cost even)
23:40:50 <doomlord> its really odd
23:41:12 <lispy> Perhaps there is some other bug in the code?
23:41:18 <Nisstyre-laptop> Fuuzetsu: does elisp fall under that category?
23:41:19 <lispy> Can you give us a minimal example?
23:41:25 <lispy> also, I really need to head to bed :
23:41:26 <lispy> :)
23:41:30 <doomlord> i'm trying to see where the types are coming from
23:41:42 <lispy> add some type signatures
23:41:50 <lispy> even wrong ones can help
23:41:55 <lispy> good luck and good night
23:42:07 <Fuuzetsu> Nisstyre-laptop: Eh, it has ‘lisp’ in the name. It just happens to be a fairly early one so it's not very… nice.
23:42:17 <doomlord> glVertex3f::Vec3->IO ()
23:42:17 <doomlord> glVertex3f (x,y,z) = vertex (Vertex3 (realToFrac x) (realToFrac y) (realToFrac z))
23:42:19 <Fuuzetsu> At least there's lexical-let now
23:42:36 <doomlord> my "Vec3" is TVec3 Float   .. TVec3 a=(a,a,a)
23:51:19 <doomlord> ok i fixed it, by making an intermediate function perform the conversion
23:51:26 <doomlord> but i dont understand why... i will paste..
23:54:10 <doomlord> http://pastebin.com/XTHv6728 <<< whhy does that not work when i try to do the "realToFrac" conversion 'inplace' - it works when i extract that conversion as a seprate function :(
23:54:12 <mauke> The paste XTHv6728 has been copied to http://hpaste.org/87944
23:56:47 <mauke> doomlord: what's the error message?
23:56:55 <simpson> doomlord: Numeric defaulting only works for Num.
23:57:16 <simpson> doomlord: Think of it this way: You're asking Haskell to pick either glVertex3f or glVertex3d, and it won't make that choice for you.
